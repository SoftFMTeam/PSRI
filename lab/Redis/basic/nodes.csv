,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,482794,acl.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1,482795,adlist.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2,482796,adlist.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
3,482797,ae.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
4,482798,ae.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
5,482799,ae_epoll.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
6,482800,ae_evport.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7,482801,ae_kqueue.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8,482802,ae_select.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
9,482803,anet.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
10,482804,anet.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
11,482805,aof.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
12,482806,asciilogo.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
13,482807,atomicvar.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
14,482808,bio.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
15,482809,bio.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
16,482810,bitops.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
17,482811,blocked.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
18,482812,call_reply.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
19,482813,call_reply.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
20,482814,childinfo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
21,482815,cli_commands.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
22,482816,cli_commands.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
23,482817,cli_common.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
24,482818,cli_common.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
25,482819,cluster.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
26,482820,cluster.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
27,482821,commands.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
28,482822,commands.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
29,482823,config.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
30,482824,config.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
31,482825,connection.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
32,482826,connection.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
33,482827,connhelpers.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
34,482828,crc16.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
35,482829,crc16_slottable.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
36,482830,crc64.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
37,482831,crc64.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
38,482832,crcspeed.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
39,482833,crcspeed.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
40,482834,db.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
41,482835,debug.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
42,482836,debugmacro.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
43,482837,defrag.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
44,482838,dict.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
45,482839,dict.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
46,482840,endianconv.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
47,482841,endianconv.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
48,482842,eval.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
49,482843,evict.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
50,482844,expire.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
51,482845,fmacros.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
52,482846,function_lua.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
53,482847,functions.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
54,482848,functions.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
55,482849,geo.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
56,482850,geo.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
57,482851,geohash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
58,482852,geohash.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
59,482853,geohash_helper.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
60,482854,geohash_helper.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
61,482855,hyperloglog.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
62,482856,intset.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
63,482857,intset.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
64,482858,latency.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
65,482859,latency.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
66,482860,lazyfree.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
67,482861,listpack.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
68,482862,listpack.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
69,482863,listpack_malloc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
70,482864,localtime.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
71,482865,logreqres.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
72,482866,lolwut.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
73,482867,lolwut.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
74,482868,lolwut5.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
75,482869,lolwut6.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
76,482870,lzf.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
77,482871,lzfP.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
78,482872,lzf_c.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
79,482873,lzf_d.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
80,482874,memtest.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
81,482875,module.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
82,482876,modules\helloacl.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
83,482877,modules\helloblock.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
84,482878,modules\hellocluster.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
85,482879,modules\hellodict.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
86,482880,modules\hellohook.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
87,482881,modules\hellotimer.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
88,482882,modules\hellotype.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
89,482883,modules\helloworld.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
90,482884,monotonic.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
91,482885,monotonic.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
92,482886,mt19937-64.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
93,482887,mt19937-64.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
94,482888,multi.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
95,482889,networking.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
96,482890,notify.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
97,482891,object.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
98,482892,pqsort.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
99,482893,pqsort.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
100,482894,pubsub.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
101,482895,quicklist.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
102,482896,quicklist.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
103,482897,rand.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
104,482898,rand.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
105,482899,rax.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
106,482900,rax.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
107,482901,rax_malloc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
108,482902,rdb.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
109,482903,rdb.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
110,482904,redis-benchmark.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
111,482905,redis-check-aof.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
112,482906,redis-check-rdb.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
113,482907,redis-cli.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
114,482908,redisassert.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
115,482909,redisassert.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
116,482910,redismodule.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
117,482911,release.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
118,482912,replication.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
119,482913,resp_parser.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
120,482914,resp_parser.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
121,482915,rio.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
122,482916,rio.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
123,482917,script.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
124,482918,script.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
125,482919,script_lua.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
126,482920,script_lua.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
127,482921,sds.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
128,482922,sds.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
129,482923,sdsalloc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
130,482924,sentinel.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
131,482925,server.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
132,482926,server.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
133,482927,setcpuaffinity.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
134,482928,setproctitle.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
135,482929,sha1.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
136,482930,sha1.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
137,482931,sha256.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
138,482932,sha256.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
139,482933,siphash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
140,482934,slowlog.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
141,482935,slowlog.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
142,482936,socket.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
143,482937,solarisfixes.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
144,482938,sort.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
145,482939,sparkline.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
146,482940,sparkline.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
147,482941,stream.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
148,482942,strl.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
149,482943,syncio.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
150,482944,syscheck.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
151,482945,syscheck.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
152,482946,t_hash.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
153,482947,t_list.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
154,482948,t_set.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
155,482949,t_stream.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
156,482950,t_string.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
157,482951,t_zset.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
158,482952,testhelp.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
159,482953,timeout.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
160,482954,tls.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
161,482955,tracking.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
162,482956,unix.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
163,482957,util.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
164,482958,util.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
165,482959,version.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
166,482960,ziplist.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
167,482961,ziplist.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
168,482962,zipmap.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
169,482963,zipmap.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
170,482964,zmalloc.c,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
171,482965,zmalloc.h,5,,,,,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
172,32,name,3,ACLCategoryItem.name,,acl.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
173,33,flag,3,ACLCategoryItem.flag,,acl.c,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
174,189,name,3,ACLUserFlag.name,,acl.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
175,190,flag,3,ACLUserFlag.flag,,acl.c,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
176,234,name,3,ACLSelectorFlags.name,,acl.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
177,235,flag,3,ACLSelectorFlags.flag,,acl.c,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
178,265,flags,3,aclSelector.flags,,acl.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
179,266,allowed_commands,3,aclSelector.allowed_commands,,acl.c,allowed_commands[USER_COMMAND_BITS_COUNT/64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
180,267,allowed_firstargs,3,aclSelector.allowed_firstargs,,acl.c,**allowed_firstargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
181,268,patterns,3,aclSelector.patterns,,acl.c,*patterns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
182,269,channels,3,aclSelector.channels,,acl.c,*channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
183,270,command_rules,3,aclSelector.command_rules,,acl.c,command_rules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
184,612,flags,3,keyPattern.flags,,acl.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
185,613,pattern,3,keyPattern.pattern,,acl.c,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
186,5422,keys_init,3,aclKeyResultCache.keys_init,,acl.c,keys_init,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
187,5423,keys,3,aclKeyResultCache.keys,,acl.c,keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
188,8189,count,3,ACLLogEntry.count,,acl.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
189,8190,reason,3,ACLLogEntry.reason,,acl.c,reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
190,8191,context,3,ACLLogEntry.context,,acl.c,context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
191,8192,object,3,ACLLogEntry.object,,acl.c,object,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
192,8193,username,3,ACLLogEntry.username,,acl.c,username,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
193,8194,ctime,3,ACLLogEntry.ctime,,acl.c,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
194,8195,cinfo,3,ACLLogEntry.cinfo,,acl.c,cinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
195,8196,entry_id,3,ACLLogEntry.entry_id,,acl.c,entry_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
196,8197,timestamp_created,3,ACLLogEntry.timestamp_created,,acl.c,timestamp_created,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
197,11714,prev,3,listNode.prev,,adlist.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
198,11716,next,3,listNode.next,,adlist.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
199,11717,value,3,listNode.value,,adlist.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,173,0,1,1,0,0,,0,0,0,0,0,
200,11720,next,3,listIter.next,,adlist.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
201,11721,direction,3,listIter.direction,,adlist.h,direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
202,11724,head,3,list.head,,adlist.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,
203,11725,tail,3,list.tail,,adlist.h,*tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
204,11742,len,3,list.len,,adlist.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,60,0,1,1,0,0,,0,0,0,0,0,
205,13516,mask,3,aeFileEvent.mask,,ae.h,mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
206,13517,rfileProc,3,aeFileEvent.rfileProc,,ae.h,*rfileProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
207,13518,wfileProc,3,aeFileEvent.wfileProc,,ae.h,*wfileProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
208,13519,clientData,3,aeFileEvent.clientData,,ae.h,*clientData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
209,13522,id,3,aeTimeEvent.id,,ae.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
210,13523,when,3,aeTimeEvent.when,,ae.h,when,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
211,13524,timeProc,3,aeTimeEvent.timeProc,,ae.h,*timeProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
212,13525,finalizerProc,3,aeTimeEvent.finalizerProc,,ae.h,*finalizerProc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
213,13526,clientData,3,aeTimeEvent.clientData,,ae.h,*clientData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
214,13528,prev,3,aeTimeEvent.prev,,ae.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
215,13530,next,3,aeTimeEvent.next,,ae.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
216,13531,refcount,3,aeTimeEvent.refcount,,ae.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
217,13534,fd,3,aeFiredEvent.fd,,ae.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
218,13535,mask,3,aeFiredEvent.mask,,ae.h,mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
219,13538,maxfd,3,aeEventLoop.maxfd,,ae.h,maxfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
220,13539,setsize,3,aeEventLoop.setsize,,ae.h,setsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
221,13540,timeEventNextId,3,aeEventLoop.timeEventNextId,,ae.h,timeEventNextId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
222,13541,events,3,aeEventLoop.events,,ae.h,*events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
223,13542,fired,3,aeEventLoop.fired,,ae.h,*fired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
224,13543,timeEventHead,3,aeEventLoop.timeEventHead,,ae.h,*timeEventHead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
225,13544,stop,3,aeEventLoop.stop,,ae.h,stop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
226,13545,apidata,3,aeEventLoop.apidata,,ae.h,*apidata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
227,13546,beforesleep,3,aeEventLoop.beforesleep,,ae.h,*beforesleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
228,13547,aftersleep,3,aeEventLoop.aftersleep,,ae.h,*aftersleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
229,13548,flags,3,aeEventLoop.flags,,ae.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
230,13668,epfd,3,aeApiState.epfd,,ae_epoll.c,epfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
231,13670,events,3,aeApiState.events,,ae_epoll.c,*events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
232,14162,portfd,3,aeApiState.portfd,,ae_evport.c,portfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
233,14163,npending,3,aeApiState.npending,,ae_evport.c,npending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
234,14164,pending_fds,3,aeApiState.pending_fds,,ae_evport.c,pending_fds[MAX_EVENT_BATCHSZ],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
235,14165,pending_masks,3,aeApiState.pending_masks,,ae_evport.c,pending_masks[MAX_EVENT_BATCHSZ],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
236,14877,kqfd,3,aeApiState.kqfd,,ae_kqueue.c,kqfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
237,14879,events,3,aeApiState.events,,ae_kqueue.c,*events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
238,14880,eventsMask,3,aeApiState.eventsMask,,ae_kqueue.c,*eventsMask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
239,15520,rfds,3,aeApiState.rfds,,ae_select.c,rfds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
240,15521,wfds,3,aeApiState.wfds,,ae_select.c,wfds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
241,15522,_rfds,3,aeApiState._rfds,,ae_select.c,_rfds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
242,15523,_wfds,3,aeApiState._wfds,,ae_select.c,_wfds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
243,28104,type,3,bio_job.header.type,,bio.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
244,28105,header,3,bio_job.header,,bio.c,header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
245,28107,type,3,bio_job.fd_args.type,,bio.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
246,28108,fd,3,bio_job.fd_args.fd,,bio.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
247,28109,offset,3,bio_job.fd_args.offset,,bio.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
248,28110,need_fsync,3,bio_job.fd_args.need_fsync,,bio.c,need_fsync:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
249,28111,need_reclaim_cache,3,bio_job.fd_args.need_reclaim_cache,,bio.c,need_reclaim_cache:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
250,28112,fd_args,3,bio_job.fd_args,,bio.c,fd_args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
251,28114,type,3,bio_job.free_args.type,,bio.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
252,28115,free_fn,3,bio_job.free_args.free_fn,,bio.c,*free_fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
253,28116,free_args,3,bio_job.free_args.free_args,,bio.c,*free_args[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
254,28122,free_args,3,bio_job.free_args,,bio.c,free_args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
255,29149,BIO_CLOSE_FILE,3,anonymous_enum_0.BIO_CLOSE_FILE,,bio.h,BIO_CLOSE_FILE = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
256,29150,BIO_AOF_FSYNC,3,anonymous_enum_0.BIO_AOF_FSYNC,,bio.h,BIO_AOF_FSYNC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
257,29151,BIO_LAZY_FREE,3,anonymous_enum_0.BIO_LAZY_FREE,,bio.h,BIO_LAZY_FREE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
258,29152,BIO_CLOSE_AOF,3,anonymous_enum_0.BIO_CLOSE_AOF,,bio.h,BIO_CLOSE_AOF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
259,29153,BIO_NUM_OPS,3,anonymous_enum_0.BIO_NUM_OPS,,bio.h,BIO_NUM_OPS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
260,33123,offset,3,bitfieldOp.offset,,bitops.c,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
261,33124,i64,3,bitfieldOp.i64,,bitops.c,i64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
262,33125,opcode,3,bitfieldOp.opcode,,bitops.c,opcode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
263,33126,owtype,3,bitfieldOp.owtype,,bitops.c,owtype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
264,33127,bits,3,bitfieldOp.bits,,bitops.c,bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
265,33128,sign,3,bitfieldOp.sign,,bitops.c,sign,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
266,36206,private_data,3,CallReply.private_data,,call_reply.c,*private_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
267,36207,original_proto,3,CallReply.original_proto,,call_reply.c,original_proto,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
268,36208,proto,3,CallReply.proto,,call_reply.c,*proto,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
269,36209,proto_len,3,CallReply.proto_len,,call_reply.c,proto_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
270,36210,type,3,CallReply.type,,call_reply.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
271,36211,flags,3,CallReply.flags,,call_reply.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
272,36212,len,3,CallReply.len,,call_reply.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
273,36214,str,3,CallReply.val.str,,call_reply.c,*str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
274,36216,str,3,CallReply.val.verbatim_str.str,,call_reply.c,*str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
275,36217,format,3,CallReply.val.verbatim_str.format,,call_reply.c,*format,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
276,36218,verbatim_str,3,CallReply.val.verbatim_str,,call_reply.c,verbatim_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
277,36219,ll,3,CallReply.val.ll,,call_reply.c,ll,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
278,36220,d,3,CallReply.val.d,,call_reply.c,d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
279,36222,array,3,CallReply.val.array,,call_reply.c,*array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
280,36223,val,3,CallReply.val,,call_reply.c,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
281,36224,deferred_error_list,3,CallReply.deferred_error_list,,call_reply.c,*deferred_error_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
282,36226,attribute,3,CallReply.attribute,,call_reply.c,*attribute,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
283,38007,keys,3,child_info_data.keys,,childinfo.c,keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
284,38008,cow,3,child_info_data.cow,,childinfo.c,cow,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
285,38009,cow_updated,3,child_info_data.cow_updated,,childinfo.c,cow_updated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
286,38010,progress,3,child_info_data.progress,,childinfo.c,progress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
287,38011,information_type,3,child_info_data.information_type,,childinfo.c,information_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
288,38559,name,3,cliCommandArg.name,,cli_commands.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
289,38560,type,3,cliCommandArg.type,,cli_commands.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
290,38561,token,3,cliCommandArg.token,,cli_commands.h,*token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
291,38562,since,3,cliCommandArg.since,,cli_commands.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
292,38563,flags,3,cliCommandArg.flags,,cli_commands.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
293,38564,numsubargs,3,cliCommandArg.numsubargs,,cli_commands.h,numsubargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
294,38566,subargs,3,cliCommandArg.subargs,,cli_commands.h,*subargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
295,38567,display_text,3,cliCommandArg.display_text,,cli_commands.h,*display_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
296,38568,matched,3,cliCommandArg.matched,,cli_commands.h,matched,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
297,38569,matched_token,3,cliCommandArg.matched_token,,cli_commands.h,matched_token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
298,38570,matched_name,3,cliCommandArg.matched_name,,cli_commands.h,matched_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
299,38571,matched_all,3,cliCommandArg.matched_all,,cli_commands.h,matched_all,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
300,38574,name,3,commandDocs.name,,cli_commands.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
301,38575,summary,3,commandDocs.summary,,cli_commands.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
302,38576,group,3,commandDocs.group,,cli_commands.h,*group,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
303,38577,since,3,commandDocs.since,,cli_commands.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
304,38578,numargs,3,commandDocs.numargs,,cli_commands.h,numargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
305,38579,args,3,commandDocs.args,,cli_commands.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
306,38581,subcommands,3,commandDocs.subcommands,,cli_commands.h,*subcommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
307,38582,params,3,commandDocs.params,,cli_commands.h,*params,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
308,39447,sni,3,cliSSLconfig.sni,,cli_common.h,*sni,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
309,39448,cacert,3,cliSSLconfig.cacert,,cli_common.h,*cacert,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
310,39449,cacertdir,3,cliSSLconfig.cacertdir,,cli_common.h,*cacertdir,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
311,39450,skip_cert_verify,3,cliSSLconfig.skip_cert_verify,,cli_common.h,skip_cert_verify,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
312,39451,cert,3,cliSSLconfig.cert,,cli_common.h,*cert,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
313,39452,key,3,cliSSLconfig.key,,cli_common.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
314,39453,ciphers,3,cliSSLconfig.ciphers,,cli_common.h,* ciphers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
315,39454,ciphersuites,3,cliSSLconfig.ciphersuites,,cli_common.h,* ciphersuites,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
316,39457,hostip,3,cliConnInfo.hostip,,cli_common.h,*hostip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
317,39458,hostport,3,cliConnInfo.hostport,,cli_common.h,hostport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
318,39459,input_dbnum,3,cliConnInfo.input_dbnum,,cli_common.h,input_dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
319,39460,auth,3,cliConnInfo.auth,,cli_common.h,*auth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
320,39461,user,3,cliConnInfo.user,,cli_common.h,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
321,39989,field,3,auxFieldHandler.field,,cluster.c,*field,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
322,39990,setter,3,auxFieldHandler.setter,,cluster.c,*setter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
323,39991,getter,3,auxFieldHandler.getter,,cluster.c,*getter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
324,39992,isPresent,3,auxFieldHandler.isPresent,,cluster.c,*isPresent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
325,39995,af_shard_id,3,auxFieldIndex.af_shard_id,,cluster.c,af_shard_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
326,39996,af_human_nodename,3,auxFieldIndex.af_human_nodename,,cluster.c,af_human_nodename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
327,39997,af_tcp_port,3,auxFieldIndex.af_tcp_port,,cluster.c,af_tcp_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
328,39998,af_tls_port,3,auxFieldIndex.af_tls_port,,cluster.c,af_tls_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
329,39999,af_count,3,auxFieldIndex.af_count,,cluster.c,af_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
330,40441,totlen,3,clusterMsgSendBlock.totlen,,cluster.c,totlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
331,40442,refcount,3,clusterMsgSendBlock.refcount,,cluster.c,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
332,40443,msg,3,clusterMsgSendBlock.msg,,cluster.c,msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
333,57170,flag,3,redisNodeFlags.flag,,cluster.c,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
334,57171,name,3,redisNodeFlags.name,,cluster.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
335,63291,conn,3,migrateCachedSocket.conn,,cluster.c,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
336,63292,last_dbid,3,migrateCachedSocket.last_dbid,,cluster.c,last_dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
337,63293,last_use_time,3,migrateCachedSocket.last_use_time,,cluster.c,last_use_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
338,66721,ctime,3,clusterLink.ctime,,cluster.h,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
339,66722,conn,3,clusterLink.conn,,cluster.h,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
340,66723,send_msg_queue,3,clusterLink.send_msg_queue,,cluster.h,*send_msg_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
341,66724,head_msg_send_offset,3,clusterLink.head_msg_send_offset,,cluster.h,head_msg_send_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
342,66725,send_msg_queue_mem,3,clusterLink.send_msg_queue_mem,,cluster.h,send_msg_queue_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
343,66726,rcvbuf,3,clusterLink.rcvbuf,,cluster.h,*rcvbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
344,66727,rcvbuf_len,3,clusterLink.rcvbuf_len,,cluster.h,rcvbuf_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
345,66728,rcvbuf_alloc,3,clusterLink.rcvbuf_alloc,,cluster.h,rcvbuf_alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
346,66730,node,3,clusterLink.node,,cluster.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,35,0,1,1,0,0,,0,0,0,0,0,
347,66731,inbound,3,clusterLink.inbound,,cluster.h,inbound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
348,66735,node,3,clusterNodeFailReport.node,,cluster.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
349,66736,time,3,clusterNodeFailReport.time,,cluster.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
350,66739,ctime,3,clusterNode.ctime,,cluster.h,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
351,66740,name,3,clusterNode.name,,cluster.h,name[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
352,66741,shard_id,3,clusterNode.shard_id,,cluster.h,shard_id[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
353,66742,flags,3,clusterNode.flags,,cluster.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
354,66743,configEpoch,3,clusterNode.configEpoch,,cluster.h,configEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
355,66744,slots,3,clusterNode.slots,,cluster.h,slots[CLUSTER_SLOTS/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
356,66745,slot_info_pairs,3,clusterNode.slot_info_pairs,,cluster.h,*slot_info_pairs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
357,66746,slot_info_pairs_count,3,clusterNode.slot_info_pairs_count,,cluster.h,slot_info_pairs_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
358,66747,numslots,3,clusterNode.numslots,,cluster.h,numslots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
359,66748,numslaves,3,clusterNode.numslaves,,cluster.h,numslaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
360,66750,slaves,3,clusterNode.slaves,,cluster.h,**slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
361,66752,slaveof,3,clusterNode.slaveof,,cluster.h,*slaveof,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
362,66753,last_in_ping_gossip,3,clusterNode.last_in_ping_gossip,,cluster.h,last_in_ping_gossip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
363,66754,ping_sent,3,clusterNode.ping_sent,,cluster.h,ping_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
364,66755,pong_received,3,clusterNode.pong_received,,cluster.h,pong_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
365,66756,data_received,3,clusterNode.data_received,,cluster.h,data_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
366,66757,fail_time,3,clusterNode.fail_time,,cluster.h,fail_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
367,66758,voted_time,3,clusterNode.voted_time,,cluster.h,voted_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
368,66759,repl_offset_time,3,clusterNode.repl_offset_time,,cluster.h,repl_offset_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
369,66760,orphaned_time,3,clusterNode.orphaned_time,,cluster.h,orphaned_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
370,66761,repl_offset,3,clusterNode.repl_offset,,cluster.h,repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
371,66762,ip,3,clusterNode.ip,,cluster.h,ip[NET_IP_STR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
372,66763,hostname,3,clusterNode.hostname,,cluster.h,hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
373,66764,human_nodename,3,clusterNode.human_nodename,,cluster.h,human_nodename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
374,66765,tcp_port,3,clusterNode.tcp_port,,cluster.h,tcp_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
375,66766,tls_port,3,clusterNode.tls_port,,cluster.h,tls_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
376,66767,cport,3,clusterNode.cport,,cluster.h,cport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
377,66768,link,3,clusterNode.link,,cluster.h,*link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
378,66769,inbound_link,3,clusterNode.inbound_link,,cluster.h,*inbound_link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
379,66770,fail_reports,3,clusterNode.fail_reports,,cluster.h,*fail_reports,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
380,66793,count,3,slotToKeys.count,,cluster.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
381,66794,head,3,slotToKeys.head,,cluster.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
382,66797,by_slot,3,clusterSlotToKeyMapping.by_slot,,cluster.h,by_slot[CLUSTER_SLOTS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
383,66807,prev,3,clusterDictEntryMetadata.prev,,cluster.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
384,66808,next,3,clusterDictEntryMetadata.next,,cluster.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
385,66811,db,3,clusterDictMetadata.db,,cluster.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
386,66814,myself,3,clusterState.myself,,cluster.h,*myself,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
387,66815,currentEpoch,3,clusterState.currentEpoch,,cluster.h,currentEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
388,66816,state,3,clusterState.state,,cluster.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
389,66817,size,3,clusterState.size,,cluster.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
390,66818,nodes,3,clusterState.nodes,,cluster.h,*nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
391,66819,shards,3,clusterState.shards,,cluster.h,*shards,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
392,66820,nodes_black_list,3,clusterState.nodes_black_list,,cluster.h,*nodes_black_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
393,66821,migrating_slots_to,3,clusterState.migrating_slots_to,,cluster.h,*migrating_slots_to[CLUSTER_SLOTS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
394,66822,importing_slots_from,3,clusterState.importing_slots_from,,cluster.h,*importing_slots_from[CLUSTER_SLOTS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
395,66823,slots,3,clusterState.slots,,cluster.h,*slots[CLUSTER_SLOTS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
396,66824,slots_to_channels,3,clusterState.slots_to_channels,,cluster.h,*slots_to_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
397,66825,failover_auth_time,3,clusterState.failover_auth_time,,cluster.h,failover_auth_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
398,66826,failover_auth_count,3,clusterState.failover_auth_count,,cluster.h,failover_auth_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
399,66827,failover_auth_sent,3,clusterState.failover_auth_sent,,cluster.h,failover_auth_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
400,66828,failover_auth_rank,3,clusterState.failover_auth_rank,,cluster.h,failover_auth_rank,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
401,66829,failover_auth_epoch,3,clusterState.failover_auth_epoch,,cluster.h,failover_auth_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
402,66830,cant_failover_reason,3,clusterState.cant_failover_reason,,cluster.h,cant_failover_reason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
403,66831,mf_end,3,clusterState.mf_end,,cluster.h,mf_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
404,66832,mf_slave,3,clusterState.mf_slave,,cluster.h,*mf_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
405,66833,mf_master_offset,3,clusterState.mf_master_offset,,cluster.h,mf_master_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
406,66834,mf_can_start,3,clusterState.mf_can_start,,cluster.h,mf_can_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
407,66835,lastVoteEpoch,3,clusterState.lastVoteEpoch,,cluster.h,lastVoteEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
408,66836,todo_before_sleep,3,clusterState.todo_before_sleep,,cluster.h,todo_before_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
409,66837,stats_bus_messages_sent,3,clusterState.stats_bus_messages_sent,,cluster.h,stats_bus_messages_sent[CLUSTERMSG_TYPE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
410,66838,stats_bus_messages_received,3,clusterState.stats_bus_messages_received,,cluster.h,stats_bus_messages_received[CLUSTERMSG_TYPE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
411,66839,stats_pfail_nodes,3,clusterState.stats_pfail_nodes,,cluster.h,stats_pfail_nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
412,66840,stat_cluster_links_buffer_limit_exceeded,3,clusterState.stat_cluster_links_buffer_limit_exceeded,,cluster.h,stat_cluster_links_buffer_limit_exceeded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
413,66841,owner_not_claiming_slot,3,clusterState.owner_not_claiming_slot,,cluster.h,owner_not_claiming_slot[CLUSTER_SLOTS / 8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
414,66874,nodename,3,clusterMsgDataGossip.nodename,,cluster.h,nodename[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
415,66875,ping_sent,3,clusterMsgDataGossip.ping_sent,,cluster.h,ping_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
416,66876,pong_received,3,clusterMsgDataGossip.pong_received,,cluster.h,pong_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
417,66877,ip,3,clusterMsgDataGossip.ip,,cluster.h,ip[NET_IP_STR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
418,66878,port,3,clusterMsgDataGossip.port,,cluster.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
419,66879,cport,3,clusterMsgDataGossip.cport,,cluster.h,cport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
420,66880,flags,3,clusterMsgDataGossip.flags,,cluster.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
421,66881,pport,3,clusterMsgDataGossip.pport,,cluster.h,pport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
422,66882,notused1,3,clusterMsgDataGossip.notused1,,cluster.h,notused1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
423,66895,nodename,3,clusterMsgDataFail.nodename,,cluster.h,nodename[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
424,66906,channel_len,3,clusterMsgDataPublish.channel_len,,cluster.h,channel_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
425,66907,message_len,3,clusterMsgDataPublish.message_len,,cluster.h,message_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
426,66908,bulk_data,3,clusterMsgDataPublish.bulk_data,,cluster.h,bulk_data[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
427,66917,configEpoch,3,clusterMsgDataUpdate.configEpoch,,cluster.h,configEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
428,66918,nodename,3,clusterMsgDataUpdate.nodename,,cluster.h,nodename[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
429,66919,slots,3,clusterMsgDataUpdate.slots,,cluster.h,slots[CLUSTER_SLOTS/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
430,66936,module_id,3,clusterMsgModule.module_id,,cluster.h,module_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
431,66937,len,3,clusterMsgModule.len,,cluster.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
432,66938,type,3,clusterMsgModule.type,,cluster.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
433,66939,bulk_data,3,clusterMsgModule.bulk_data,,cluster.h,bulk_data[3],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
434,66948,CLUSTERMSG_EXT_TYPE_HOSTNAME,3,clusterMsgPingtypes.CLUSTERMSG_EXT_TYPE_HOSTNAME,,cluster.h,CLUSTERMSG_EXT_TYPE_HOSTNAME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
435,66949,CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME,3,clusterMsgPingtypes.CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME,,cluster.h,CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
436,66950,CLUSTERMSG_EXT_TYPE_FORGOTTEN_NODE,3,clusterMsgPingtypes.CLUSTERMSG_EXT_TYPE_FORGOTTEN_NODE,,cluster.h,CLUSTERMSG_EXT_TYPE_FORGOTTEN_NODE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
437,66951,CLUSTERMSG_EXT_TYPE_SHARDID,3,clusterMsgPingtypes.CLUSTERMSG_EXT_TYPE_SHARDID,,cluster.h,CLUSTERMSG_EXT_TYPE_SHARDID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
438,66954,hostname,3,clusterMsgPingExtHostname.hostname,,cluster.h,hostname[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
439,66963,human_nodename,3,clusterMsgPingExtHumanNodename.human_nodename,,cluster.h,human_nodename[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
440,66972,name,3,clusterMsgPingExtForgottenNode.name,,cluster.h,name[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
441,66973,ttl,3,clusterMsgPingExtForgottenNode.ttl,,cluster.h,ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
442,66985,shard_id,3,clusterMsgPingExtShardId.shard_id,,cluster.h,shard_id[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
443,66996,length,3,clusterMsgPingExt.length,,cluster.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
444,66997,type,3,clusterMsgPingExt.type,,cluster.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
445,66998,unused,3,clusterMsgPingExt.unused,,cluster.h,unused,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
446,67000,hostname,3,clusterMsgPingExt.ext.hostname,,cluster.h,hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
447,67001,human_nodename,3,clusterMsgPingExt.ext.human_nodename,,cluster.h,human_nodename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
448,67002,forgotten_node,3,clusterMsgPingExt.ext.forgotten_node,,cluster.h,forgotten_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
449,67003,shard_id,3,clusterMsgPingExt.ext.shard_id,,cluster.h,shard_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
450,67004,ext,3,clusterMsgPingExt.ext,,cluster.h,ext[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
451,67013,gossip,3,clusterMsgData.ping.gossip,,cluster.h,gossip[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
452,67020,ping,3,clusterMsgData.ping,,cluster.h,ping,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
453,67022,about,3,clusterMsgData.fail.about,,cluster.h,about,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
454,67023,fail,3,clusterMsgData.fail,,cluster.h,fail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
455,67025,msg,3,clusterMsgData.publish.msg,,cluster.h,msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
456,67026,publish,3,clusterMsgData.publish,,cluster.h,publish,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
457,67028,nodecfg,3,clusterMsgData.update.nodecfg,,cluster.h,nodecfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
458,67029,update,3,clusterMsgData.update,,cluster.h,update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
459,67031,msg,3,clusterMsgData.module.msg,,cluster.h,msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
460,67032,module,3,clusterMsgData.module,,cluster.h,module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
461,67034,sig,3,clusterMsg.sig,,cluster.h,sig[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
462,67035,totlen,3,clusterMsg.totlen,,cluster.h,totlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
463,67036,ver,3,clusterMsg.ver,,cluster.h,ver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
464,67037,port,3,clusterMsg.port,,cluster.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
465,67038,type,3,clusterMsg.type,,cluster.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
466,67039,count,3,clusterMsg.count,,cluster.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
467,67040,currentEpoch,3,clusterMsg.currentEpoch,,cluster.h,currentEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
468,67041,configEpoch,3,clusterMsg.configEpoch,,cluster.h,configEpoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
469,67042,offset,3,clusterMsg.offset,,cluster.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
470,67043,sender,3,clusterMsg.sender,,cluster.h,sender[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
471,67044,myslots,3,clusterMsg.myslots,,cluster.h,myslots[CLUSTER_SLOTS/8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
472,67045,slaveof,3,clusterMsg.slaveof,,cluster.h,slaveof[CLUSTER_NAMELEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
473,67046,myip,3,clusterMsg.myip,,cluster.h,myip[NET_IP_STR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
474,67047,extensions,3,clusterMsg.extensions,,cluster.h,extensions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
475,67048,notused1,3,clusterMsg.notused1,,cluster.h,notused1[30],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
476,67049,pport,3,clusterMsg.pport,,cluster.h,pport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
477,67050,cport,3,clusterMsg.cport,,cluster.h,cport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
478,67051,flags,3,clusterMsg.flags,,cluster.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
479,67052,state,3,clusterMsg.state,,cluster.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
480,67053,mflags,3,clusterMsg.mflags,,cluster.h,mflags[3],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
481,67055,data,3,clusterMsg.data,,cluster.h,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
482,67311,ARG_TYPE_STRING,3,redisCommandArgType.ARG_TYPE_STRING,,commands.h,ARG_TYPE_STRING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
483,67312,ARG_TYPE_INTEGER,3,redisCommandArgType.ARG_TYPE_INTEGER,,commands.h,ARG_TYPE_INTEGER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
484,67313,ARG_TYPE_DOUBLE,3,redisCommandArgType.ARG_TYPE_DOUBLE,,commands.h,ARG_TYPE_DOUBLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
485,67314,ARG_TYPE_KEY,3,redisCommandArgType.ARG_TYPE_KEY,,commands.h,ARG_TYPE_KEY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
486,67315,ARG_TYPE_PATTERN,3,redisCommandArgType.ARG_TYPE_PATTERN,,commands.h,ARG_TYPE_PATTERN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
487,67316,ARG_TYPE_UNIX_TIME,3,redisCommandArgType.ARG_TYPE_UNIX_TIME,,commands.h,ARG_TYPE_UNIX_TIME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
488,67317,ARG_TYPE_PURE_TOKEN,3,redisCommandArgType.ARG_TYPE_PURE_TOKEN,,commands.h,ARG_TYPE_PURE_TOKEN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
489,67318,ARG_TYPE_ONEOF,3,redisCommandArgType.ARG_TYPE_ONEOF,,commands.h,ARG_TYPE_ONEOF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
490,67319,ARG_TYPE_BLOCK,3,redisCommandArgType.ARG_TYPE_BLOCK,,commands.h,ARG_TYPE_BLOCK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
491,67322,name,3,redisCommandArg.name,,commands.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
492,67323,type,3,redisCommandArg.type,,commands.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
493,67324,key_spec_index,3,redisCommandArg.key_spec_index,,commands.h,key_spec_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
494,67325,token,3,redisCommandArg.token,,commands.h,*token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
495,67326,summary,3,redisCommandArg.summary,,commands.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
496,67327,since,3,redisCommandArg.since,,commands.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
497,67328,flags,3,redisCommandArg.flags,,commands.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
498,67329,deprecated_since,3,redisCommandArg.deprecated_since,,commands.h,*deprecated_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
499,67330,num_args,3,redisCommandArg.num_args,,commands.h,num_args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
500,67332,subargs,3,redisCommandArg.subargs,,commands.h,*subargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
501,67333,display_text,3,redisCommandArg.display_text,,commands.h,*display_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
502,67366,name,3,deprecatedConfig.name,,config.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
503,67367,argc_min,3,deprecatedConfig.argc_min,,config.c,argc_min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
504,67368,argc_max,3,deprecatedConfig.argc_max,,config.c,argc_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
505,67810,config,3,boolConfigData.config,,config.c,*config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
506,67811,default_value,3,boolConfigData.default_value,,config.c,default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
507,67820,config,3,stringConfigData.config,,config.c,**config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
508,67821,default_value,3,stringConfigData.default_value,,config.c,*default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
509,67828,convert_empty_to_null,3,stringConfigData.convert_empty_to_null,,config.c,convert_empty_to_null,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
510,67831,config,3,sdsConfigData.config,,config.c,*config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
511,67832,default_value,3,sdsConfigData.default_value,,config.c,*default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
512,67839,convert_empty_to_null,3,sdsConfigData.convert_empty_to_null,,config.c,convert_empty_to_null,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
513,67842,config,3,enumConfigData.config,,config.c,*config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
514,67843,enum_value,3,enumConfigData.enum_value,,config.c,*enum_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
515,67844,default_value,3,enumConfigData.default_value,,config.c,default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
516,67853,NUMERIC_TYPE_INT,3,numericType.NUMERIC_TYPE_INT,,config.c,NUMERIC_TYPE_INT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
517,67854,NUMERIC_TYPE_UINT,3,numericType.NUMERIC_TYPE_UINT,,config.c,NUMERIC_TYPE_UINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
518,67855,NUMERIC_TYPE_LONG,3,numericType.NUMERIC_TYPE_LONG,,config.c,NUMERIC_TYPE_LONG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
519,67856,NUMERIC_TYPE_ULONG,3,numericType.NUMERIC_TYPE_ULONG,,config.c,NUMERIC_TYPE_ULONG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
520,67857,NUMERIC_TYPE_LONG_LONG,3,numericType.NUMERIC_TYPE_LONG_LONG,,config.c,NUMERIC_TYPE_LONG_LONG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
521,67858,NUMERIC_TYPE_ULONG_LONG,3,numericType.NUMERIC_TYPE_ULONG_LONG,,config.c,NUMERIC_TYPE_ULONG_LONG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
522,67859,NUMERIC_TYPE_SIZE_T,3,numericType.NUMERIC_TYPE_SIZE_T,,config.c,NUMERIC_TYPE_SIZE_T,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
523,67860,NUMERIC_TYPE_SSIZE_T,3,numericType.NUMERIC_TYPE_SSIZE_T,,config.c,NUMERIC_TYPE_SSIZE_T,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
524,67861,NUMERIC_TYPE_OFF_T,3,numericType.NUMERIC_TYPE_OFF_T,,config.c,NUMERIC_TYPE_OFF_T,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
525,67862,NUMERIC_TYPE_TIME_T,3,numericType.NUMERIC_TYPE_TIME_T,,config.c,NUMERIC_TYPE_TIME_T,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
526,67866,i,3,numericConfigData.config.i,,config.c,*i,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
527,67867,ui,3,numericConfigData.config.ui,,config.c,*ui,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
528,67868,l,3,numericConfigData.config.l,,config.c,*l,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
529,67869,ul,3,numericConfigData.config.ul,,config.c,*ul,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
530,67870,ll,3,numericConfigData.config.ll,,config.c,*ll,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
531,67871,ull,3,numericConfigData.config.ull,,config.c,*ull,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
532,67872,st,3,numericConfigData.config.st,,config.c,*st,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
533,67873,sst,3,numericConfigData.config.sst,,config.c,*sst,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
534,67874,ot,3,numericConfigData.config.ot,,config.c,*ot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
535,67875,tt,3,numericConfigData.config.tt,,config.c,*tt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
536,67876,config,3,numericConfigData.config,,config.c,config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
537,67877,flags,3,numericConfigData.flags,,config.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
538,67878,numeric_type,3,numericConfigData.numeric_type,,config.c,numeric_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
539,67879,lower_bound,3,numericConfigData.lower_bound,,config.c,lower_bound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
540,67880,upper_bound,3,numericConfigData.upper_bound,,config.c,upper_bound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
541,67881,default_value,3,numericConfigData.default_value,,config.c,default_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
542,67890,yesno,3,typeData.yesno,,config.c,yesno,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
543,67891,string,3,typeData.string,,config.c,string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
544,67892,sds,3,typeData.sds,,config.c,sds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
545,67893,enumd,3,typeData.enumd,,config.c,enumd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
546,67894,numeric,3,typeData.numeric,,config.c,numeric,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
547,67917,apply,3,typeInterface.apply,,config.c,apply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
548,67932,name,3,standardConfig.name,,config.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
549,67933,alias,3,standardConfig.alias,,config.c,*alias,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
550,67934,flags,3,standardConfig.flags,,config.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,43,0,1,1,0,0,,0,0,0,0,0,
551,67935,interface,3,standardConfig.interface,,config.c,interface,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
552,67936,data,3,standardConfig.data,,config.c,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,137,0,1,1,0,0,,0,0,0,0,0,
553,67937,type,3,standardConfig.type,,config.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
554,67938,privdata,3,standardConfig.privdata,,config.c,*privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
555,70734,option_to_line,3,rewriteConfigState.option_to_line,,config.c,*option_to_line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
556,70735,rewritten,3,rewriteConfigState.rewritten,,config.c,*rewritten,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
557,70736,numlines,3,rewriteConfigState.numlines,,config.c,numlines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
558,70737,lines,3,rewriteConfigState.lines,,config.c,*lines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
559,70738,needs_signature,3,rewriteConfigState.needs_signature,,config.c,needs_signature,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
560,70739,force_write,3,rewriteConfigState.force_write,,config.c,force_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
561,98086,CONN_STATE_NONE,3,ConnectionState.CONN_STATE_NONE,,connection.h,CONN_STATE_NONE = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
562,98087,CONN_STATE_CONNECTING,3,ConnectionState.CONN_STATE_CONNECTING,,connection.h,CONN_STATE_CONNECTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
563,98088,CONN_STATE_ACCEPTING,3,ConnectionState.CONN_STATE_ACCEPTING,,connection.h,CONN_STATE_ACCEPTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
564,98089,CONN_STATE_CONNECTED,3,ConnectionState.CONN_STATE_CONNECTED,,connection.h,CONN_STATE_CONNECTED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
565,98090,CONN_STATE_CLOSED,3,ConnectionState.CONN_STATE_CLOSED,,connection.h,CONN_STATE_CLOSED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
566,98091,CONN_STATE_ERROR,3,ConnectionState.CONN_STATE_ERROR,,connection.h,CONN_STATE_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
567,98135,accept_handler,3,ConnectionType.accept_handler,,connection.h,*accept_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
568,98279,type,3,connection.type,,connection.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
569,98280,state,3,connection.state,,connection.h,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
570,98281,last_errno,3,connection.last_errno,,connection.h,last_errno,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
571,98282,fd,3,connection.fd,,connection.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
572,98283,flags,3,connection.flags,,connection.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
573,98284,refs,3,connection.refs,,connection.h,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
574,98285,iovcnt,3,connection.iovcnt,,connection.h,iovcnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
575,98286,private_data,3,connection.private_data,,connection.h,*private_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
576,98287,conn_handler,3,connection.conn_handler,,connection.h,conn_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
577,98288,write_handler,3,connection.write_handler,,connection.h,write_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
578,98289,read_handler,3,connection.read_handler,,connection.h,read_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
579,98291,fd,3,connListener.fd,,connection.h,fd[CONFIG_BINDADDR_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
580,98292,count,3,connListener.count,,connection.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
581,98293,bindaddr,3,connListener.bindaddr,,connection.h,**bindaddr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
582,98294,bindaddr_count,3,connListener.bindaddr_count,,connection.h,bindaddr_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
583,98295,port,3,connListener.port,,connection.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
584,98296,ct,3,connListener.ct,,connection.h,*ct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
585,98297,priv,3,connListener.priv,,connection.h,*priv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
586,104066,keys,3,scanData.keys,,db.c,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
587,104067,o,3,scanData.o,,db.c,*o,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
588,104068,type,3,scanData.type,,db.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
589,104069,pattern,3,scanData.pattern,,db.c,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
590,104070,sampled,3,scanData.sampled,,db.c,sampled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
591,108296,proc,3,ChannelSpecs.proc,,db.c,*proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
592,108297,flags,3,ChannelSpecs.flags,,db.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
593,108298,start,3,ChannelSpecs.start,,db.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
594,108299,count,3,ChannelSpecs.count,,db.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
595,116284,key,3,dictEntry.key,,dict.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
596,116286,val,3,dictEntry.v.val,,dict.c,*val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
597,116287,u64,3,dictEntry.v.u64,,dict.c,u64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
598,116288,s64,3,dictEntry.v.s64,,dict.c,s64,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
599,116289,d,3,dictEntry.v.d,,dict.c,d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
600,116290,v,3,dictEntry.v,,dict.c,v,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
601,116292,next,3,dictEntry.next,,dict.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
602,116293,metadata,3,dictEntry.metadata,,dict.c,*metadata[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
603,116300,key,3,dictEntryNoValue.key,,dict.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
604,116301,next,3,dictEntryNoValue.next,,dict.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
605,122609,no_value,3,dictType.no_value,,dict.h,no_value:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
606,122610,keys_are_odd,3,dictType.keys_are_odd,,dict.h,keys_are_odd:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
607,122629,type,3,dict.type,,dict.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,47,0,1,1,0,0,,0,0,0,0,0,
608,122630,ht_table,3,dict.ht_table,,dict.h,**ht_table[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
609,122631,ht_used,3,dict.ht_used,,dict.h,ht_used[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,95,0,1,1,0,0,,0,0,0,0,0,
610,122632,rehashidx,3,dict.rehashidx,,dict.h,rehashidx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
611,122633,pauserehash,3,dict.pauserehash,,dict.h,pauserehash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
612,122634,ht_size_exp,3,dict.ht_size_exp,,dict.h,ht_size_exp[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,118,0,1,1,0,0,,0,0,0,0,0,
613,122635,metadata,3,dict.metadata,,dict.h,*metadata[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
614,122648,d,3,dictIterator.d,,dict.h,*d,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
615,122649,index,3,dictIterator.index,,dict.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
616,122650,table,3,dictIterator.table,,dict.h,table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
617,122651,safe,3,dictIterator.safe,,dict.h,safe,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
618,122652,entry,3,dictIterator.entry,,dict.h,*entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
619,122653,nextEntry,3,dictIterator.nextEntry,,dict.h,*nextEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
620,122654,fingerprint,3,dictIterator.fingerprint,,dict.h,fingerprint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
621,122668,defragAlloc,3,dictDefragFunctions.defragAlloc,,dict.h,*defragAlloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
622,122669,defragKey,3,dictDefragFunctions.defragKey,,dict.h,*defragKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
623,122670,defragVal,3,dictDefragFunctions.defragVal,,dict.h,*defragVal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
624,122673,DICT_RESIZE_ENABLE,3,dictResizeEnable.DICT_RESIZE_ENABLE,,dict.h,DICT_RESIZE_ENABLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
625,122674,DICT_RESIZE_AVOID,3,dictResizeEnable.DICT_RESIZE_AVOID,,dict.h,DICT_RESIZE_AVOID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
626,122675,DICT_RESIZE_FORBID,3,dictResizeEnable.DICT_RESIZE_FORBID,,dict.h,DICT_RESIZE_FORBID,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
627,123364,lua,3,luaCtx.lua,,eval.c,*lua,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
628,123365,lua_client,3,luaCtx.lua_client,,eval.c,*lua_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
629,123366,lua_scripts,3,luaCtx.lua_scripts,,eval.c,*lua_scripts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
630,123367,lua_scripts_mem,3,luaCtx.lua_scripts_mem,,eval.c,lua_scripts_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
631,123370,conn,3,ldbState.conn,,eval.c,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
632,123371,active,3,ldbState.active,,eval.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
633,123372,forked,3,ldbState.forked,,eval.c,forked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
634,123373,logs,3,ldbState.logs,,eval.c,*logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
635,123374,traces,3,ldbState.traces,,eval.c,*traces,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
636,123375,children,3,ldbState.children,,eval.c,*children,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
637,123376,bp,3,ldbState.bp,,eval.c,bp[LDB_BREAKPOINTS_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
638,123377,bpcount,3,ldbState.bpcount,,eval.c,bpcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
639,123378,step,3,ldbState.step,,eval.c,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
640,123379,luabp,3,ldbState.luabp,,eval.c,luabp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
641,123380,src,3,ldbState.src,,eval.c,*src,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
642,123381,lines,3,ldbState.lines,,eval.c,lines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
643,123382,currentline,3,ldbState.currentline,,eval.c,currentline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
644,123383,cbuf,3,ldbState.cbuf,,eval.c,cbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
645,123384,maxlen,3,ldbState.maxlen,,eval.c,maxlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
646,123385,maxlen_hint_sent,3,ldbState.maxlen_hint_sent,,eval.c,maxlen_hint_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
647,128834,idle,3,evictionPoolEntry.idle,,evict.c,idle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
648,128835,key,3,evictionPoolEntry.key,,evict.c,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
649,128836,cached,3,evictionPoolEntry.cached,,evict.c,cached,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
650,128837,dbid,3,evictionPoolEntry.dbid,,evict.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
651,130822,db,3,expireScanData.db,,expire.c,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
652,130823,now,3,expireScanData.now,,expire.c,now,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
653,130824,sampled,3,expireScanData.sampled,,expire.c,sampled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
654,130825,expired,3,expireScanData.expired,,expire.c,expired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
655,130826,ttl_sum,3,expireScanData.ttl_sum,,expire.c,ttl_sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
656,130827,ttl_samples,3,expireScanData.ttl_samples,,expire.c,ttl_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
657,132644,lua,3,luaEngineCtx.lua,,function_lua.c,*lua,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
658,132647,lua_function_ref,3,luaFunctionCtx.lua_function_ref,,function_lua.c,lua_function_ref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
659,132650,li,3,loadCtx.li,,function_lua.c,*li,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
660,132651,start_time,3,loadCtx.start_time,,function_lua.c,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
661,132654,name,3,registerFunctionArgs.name,,function_lua.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
662,132655,desc,3,registerFunctionArgs.desc,,function_lua.c,desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
663,132656,lua_f_ctx,3,registerFunctionArgs.lua_f_ctx,,function_lua.c,*lua_f_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
664,132657,f_flags,3,registerFunctionArgs.f_flags,,function_lua.c,f_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
665,133929,restorePolicy_Flush,3,restorePolicy.restorePolicy_Flush,,functions.c,restorePolicy_Flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
666,133930,restorePolicy_Append,3,restorePolicy.restorePolicy_Append,,functions.c,restorePolicy_Append,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
667,133931,restorePolicy_Replace,3,restorePolicy.restorePolicy_Replace,,functions.c,restorePolicy_Replace,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
668,133961,n_lib,3,functionsLibEngineStats.n_lib,,functions.c,n_lib,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
669,133962,n_functions,3,functionsLibEngineStats.n_functions,,functions.c,n_functions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
670,133965,libraries,3,functionsLibCtx.libraries,,functions.c,*libraries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
671,133966,functions,3,functionsLibCtx.functions,,functions.c,*functions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
672,133967,cache_memory,3,functionsLibCtx.cache_memory,,functions.c,cache_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
673,133968,engines_stats,3,functionsLibCtx.engines_stats,,functions.c,*engines_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
674,133970,engine,3,functionsLibMataData.engine,,functions.c,engine,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
675,133971,name,3,functionsLibMataData.name,,functions.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
676,133972,code,3,functionsLibMataData.code,,functions.c,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
677,137418,engine_ctx,3,engine.engine_ctx,,functions.h,*engine_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
678,137461,name,3,engineInfo.name,,functions.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
679,137462,engine,3,engineInfo.engine,,functions.h,*engine,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
680,137463,c,3,engineInfo.c,,functions.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
681,137466,name,3,functionInfo.name,,functions.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
682,137467,function,3,functionInfo.function,,functions.h,*function,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
683,137468,li,3,functionInfo.li,,functions.h,* li,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
684,137469,desc,3,functionInfo.desc,,functions.h,desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
685,137470,f_flags,3,functionInfo.f_flags,,functions.h,f_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
686,137473,name,3,functionLibInfo.name,,functions.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
687,137474,functions,3,functionLibInfo.functions,,functions.h,*functions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
688,137475,ei,3,functionLibInfo.ei,,functions.h,*ei,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
689,137476,code,3,functionLibInfo.code,,functions.h,code,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
690,141338,longitude,3,geoPoint.longitude,,geo.h,longitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
691,141339,latitude,3,geoPoint.latitude,,geo.h,latitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
692,141340,dist,3,geoPoint.dist,,geo.h,dist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
693,141341,score,3,geoPoint.score,,geo.h,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
694,141342,member,3,geoPoint.member,,geo.h,*member,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
695,141346,array,3,geoArray.array,,geo.h,*array,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
696,141347,buckets,3,geoArray.buckets,,geo.h,buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
697,141348,used,3,geoArray.used,,geo.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
698,142703,GEOHASH_NORTH,3,GeoDirection.GEOHASH_NORTH,,geohash.h,GEOHASH_NORTH = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
699,142704,GEOHASH_EAST,3,GeoDirection.GEOHASH_EAST,,geohash.h,GEOHASH_EAST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
700,142705,GEOHASH_WEST,3,GeoDirection.GEOHASH_WEST,,geohash.h,GEOHASH_WEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
701,142706,GEOHASH_SOUTH,3,GeoDirection.GEOHASH_SOUTH,,geohash.h,GEOHASH_SOUTH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
702,142707,GEOHASH_SOUTH_WEST,3,GeoDirection.GEOHASH_SOUTH_WEST,,geohash.h,GEOHASH_SOUTH_WEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
703,142708,GEOHASH_SOUTH_EAST,3,GeoDirection.GEOHASH_SOUTH_EAST,,geohash.h,GEOHASH_SOUTH_EAST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
704,142709,GEOHASH_NORT_WEST,3,GeoDirection.GEOHASH_NORT_WEST,,geohash.h,GEOHASH_NORT_WEST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
705,142710,GEOHASH_NORT_EAST,3,GeoDirection.GEOHASH_NORT_EAST,,geohash.h,GEOHASH_NORT_EAST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
706,142720,bits,3,GeoHashBits.bits,,geohash.h,bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
707,142721,step,3,GeoHashBits.step,,geohash.h,step,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
708,142724,min,3,GeoHashRange.min,,geohash.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
709,142725,max,3,GeoHashRange.max,,geohash.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
710,142728,hash,3,GeoHashArea.hash,,geohash.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
711,142729,longitude,3,GeoHashArea.longitude,,geohash.h,longitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
712,142730,latitude,3,GeoHashArea.latitude,,geohash.h,latitude,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
713,142733,north,3,GeoHashNeighbors.north,,geohash.h,north,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
714,142734,east,3,GeoHashNeighbors.east,,geohash.h,east,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
715,142735,west,3,GeoHashNeighbors.west,,geohash.h,west,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
716,142736,south,3,GeoHashNeighbors.south,,geohash.h,south,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
717,142737,north_east,3,GeoHashNeighbors.north_east,,geohash.h,north_east,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
718,142738,south_east,3,GeoHashNeighbors.south_east,,geohash.h,south_east,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
719,142739,north_west,3,GeoHashNeighbors.north_west,,geohash.h,north_west,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
720,142740,south_west,3,GeoHashNeighbors.south_west,,geohash.h,south_west,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
721,142743,type,3,GeoShape.type,,geohash.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
722,142744,xy,3,GeoShape.xy,,geohash.h,xy[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
723,142745,conversion,3,GeoShape.conversion,,geohash.h,conversion,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
724,142746,bounds,3,GeoShape.bounds,,geohash.h,bounds[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
725,142748,radius,3,GeoShape.t.radius,,geohash.h,radius,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
726,142750,height,3,GeoShape.t.r.height,,geohash.h,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
727,142751,width,3,GeoShape.t.r.width,,geohash.h,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
728,142752,r,3,GeoShape.t.r,,geohash.h,r,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
729,142753,t,3,GeoShape.t,,geohash.h,t,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
730,143910,hash,3,GeoHashRadius.hash,,geohash_helper.h,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
731,143911,area,3,GeoHashRadius.area,,geohash_helper.h,area,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
732,143912,neighbors,3,GeoHashRadius.neighbors,,geohash_helper.h,neighbors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
733,143987,magic,3,hllhdr.magic,,hyperloglog.c,magic[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
734,143988,encoding,3,hllhdr.encoding,,hyperloglog.c,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
735,143989,notused,3,hllhdr.notused,,hyperloglog.c,notused[3],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
736,143990,card,3,hllhdr.card,,hyperloglog.c,card[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
737,143991,registers,3,hllhdr.registers,,hyperloglog.c,registers[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
738,150547,encoding,3,intset.encoding,,intset.h,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
739,150548,length,3,intset.length,,intset.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
740,150549,contents,3,intset.contents,,intset.h,contents[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
741,152993,time,3,latencySample.time,,latency.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
742,152994,latency,3,latencySample.latency,,latency.h,latency,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
743,152996,idx,3,latencyTimeSeries.idx,,latency.h,idx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
744,152997,max,3,latencyTimeSeries.max,,latency.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
745,152999,samples,3,latencyTimeSeries.samples,,latency.h,samples[LATENCY_TS_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
746,153009,all_time_high,3,latencyStats.all_time_high,,latency.h,all_time_high,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
747,153010,avg,3,latencyStats.avg,,latency.h,avg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
748,153011,min,3,latencyStats.min,,latency.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
749,153012,max,3,latencyStats.max,,latency.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
750,153013,mad,3,latencyStats.mad,,latency.h,mad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
751,153014,samples,3,latencyStats.samples,,latency.h,samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
752,153015,period,3,latencyStats.period,,latency.h,period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
753,153028,cnt,3,durationStats.cnt,,latency.h,cnt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
754,153029,sum,3,durationStats.sum,,latency.h,sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
755,153030,max,3,durationStats.max,,latency.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
756,153033,EL_DURATION_TYPE_EL,3,DurationType.EL_DURATION_TYPE_EL,,latency.h,EL_DURATION_TYPE_EL = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
757,153034,EL_DURATION_TYPE_CMD,3,DurationType.EL_DURATION_TYPE_CMD,,latency.h,EL_DURATION_TYPE_CMD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
758,153035,EL_DURATION_TYPE_AOF,3,DurationType.EL_DURATION_TYPE_AOF,,latency.h,EL_DURATION_TYPE_AOF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
759,153036,EL_DURATION_TYPE_CRON,3,DurationType.EL_DURATION_TYPE_CRON,,latency.h,EL_DURATION_TYPE_CRON,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
760,153037,EL_DURATION_TYPE_NUM,3,DurationType.EL_DURATION_TYPE_NUM,,latency.h,EL_DURATION_TYPE_NUM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
761,159974,sval,3,listpackEntry.sval,,listpack.h,*sval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
762,159975,slen,3,listpackEntry.slen,,listpack.h,slen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
763,159976,lval,3,listpackEntry.lval,,listpack.h,lval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
764,161101,width,3,lwCanvas.width,,lolwut.h,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
765,161102,height,3,lwCanvas.height,,lolwut.h,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
766,161103,pixels,3,lwCanvas.pixels,,lolwut.h,*pixels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
767,161871,xoff,3,skyscraper.xoff,,lolwut6.c,xoff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
768,161872,width,3,skyscraper.width,,lolwut6.c,width,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
769,161873,height,3,skyscraper.height,,lolwut6.c,height,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
770,161874,windows,3,skyscraper.windows,,lolwut6.c,windows,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
771,161875,color,3,skyscraper.color,,lolwut6.c,color,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
772,164980,module,3,RedisModuleInfoCtx.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
773,164981,requested_sections,3,RedisModuleInfoCtx.requested_sections,,module.c,*requested_sections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
774,164982,info,3,RedisModuleInfoCtx.info,,module.c,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
775,164983,sections,3,RedisModuleInfoCtx.sections,,module.c,sections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
776,164984,in_section,3,RedisModuleInfoCtx.in_section,,module.c,in_section,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
777,164985,in_dict_field,3,RedisModuleInfoCtx.in_dict_field,,module.c,in_dict_field,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
778,164987,func,3,RedisModuleSharedAPI.func,,module.c,*func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
779,164988,module,3,RedisModuleSharedAPI.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
780,164993,ptr,3,AutoMemEntry.ptr,,module.c,*ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
781,164994,type,3,AutoMemEntry.type,,module.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
782,164996,size,3,RedisModulePoolAllocBlock.size,,module.c,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
783,164997,used,3,RedisModulePoolAllocBlock.used,,module.c,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
784,164999,next,3,RedisModulePoolAllocBlock.next,,module.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
785,165000,memory,3,RedisModulePoolAllocBlock.memory,,module.c,memory[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
786,165010,getapifuncptr,3,RedisModuleCtx.getapifuncptr,,module.c,*getapifuncptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
787,165012,module,3,RedisModuleCtx.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,79,0,1,1,0,0,,0,0,0,0,0,
788,165013,client,3,RedisModuleCtx.client,,module.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,83,0,1,1,0,0,,0,0,0,0,0,
789,165015,blocked_client,3,RedisModuleCtx.blocked_client,,module.c,*blocked_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
790,165017,amqueue,3,RedisModuleCtx.amqueue,,module.c,*amqueue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
791,165018,amqueue_len,3,RedisModuleCtx.amqueue_len,,module.c,amqueue_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
792,165019,amqueue_used,3,RedisModuleCtx.amqueue_used,,module.c,amqueue_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
793,165020,flags,3,RedisModuleCtx.flags,,module.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
794,165021,postponed_arrays,3,RedisModuleCtx.postponed_arrays,,module.c,**postponed_arrays,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
795,165022,postponed_arrays_count,3,RedisModuleCtx.postponed_arrays_count,,module.c,postponed_arrays_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
796,165023,blocked_privdata,3,RedisModuleCtx.blocked_privdata,,module.c,*blocked_privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
797,165024,blocked_ready_key,3,RedisModuleCtx.blocked_ready_key,,module.c,*blocked_ready_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
798,165025,keys_result,3,RedisModuleCtx.keys_result,,module.c,*keys_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
799,165027,pa_head,3,RedisModuleCtx.pa_head,,module.c,*pa_head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
800,165028,next_yield_time,3,RedisModuleCtx.next_yield_time,,module.c,next_yield_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
801,165030,user,3,RedisModuleCtx.user,,module.c,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
802,165034,ctx,3,RedisModuleKey.ctx,,module.c,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
803,165035,db,3,RedisModuleKey.db,,module.c,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
804,165036,key,3,RedisModuleKey.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
805,165037,value,3,RedisModuleKey.value,,module.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,128,0,1,1,0,0,,0,0,0,0,0,
806,165038,iter,3,RedisModuleKey.iter,,module.c,*iter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
807,165039,mode,3,RedisModuleKey.mode,,module.c,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
808,165042,entry,3,RedisModuleKey.u.list.entry,,module.c,entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
809,165043,index,3,RedisModuleKey.u.list.index,,module.c,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
810,165044,list,3,RedisModuleKey.u.list,,module.c,list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
811,165046,type,3,RedisModuleKey.u.zset.type,,module.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
812,165047,rs,3,RedisModuleKey.u.zset.rs,,module.c,rs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
813,165048,lrs,3,RedisModuleKey.u.zset.lrs,,module.c,lrs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
814,165049,start,3,RedisModuleKey.u.zset.start,,module.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
815,165050,end,3,RedisModuleKey.u.zset.end,,module.c,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
816,165051,current,3,RedisModuleKey.u.zset.current,,module.c,*current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
817,165052,er,3,RedisModuleKey.u.zset.er,,module.c,er,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
818,165053,zset,3,RedisModuleKey.u.zset,,module.c,zset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
819,165055,currentid,3,RedisModuleKey.u.stream.currentid,,module.c,currentid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
820,165056,numfieldsleft,3,RedisModuleKey.u.stream.numfieldsleft,,module.c,numfieldsleft,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
821,165057,signalready,3,RedisModuleKey.u.stream.signalready,,module.c,signalready,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
822,165058,stream,3,RedisModuleKey.u.stream,,module.c,stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
823,165059,u,3,RedisModuleKey.u,,module.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,51,0,1,1,0,0,,0,0,0,0,0,
824,165084,module,3,RedisModuleCommand.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
825,165085,func,3,RedisModuleCommand.func,,module.c,func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
826,165087,rediscmd,3,RedisModuleCommand.rediscmd,,module.c,*rediscmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
827,165094,module,3,RedisModuleAuthCtx.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
828,165095,auth_cb,3,RedisModuleAuthCtx.auth_cb,,module.c,auth_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
829,165098,client,3,RedisModuleBlockedClient.client,,module.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
830,165099,module,3,RedisModuleBlockedClient.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
831,165100,reply_callback,3,RedisModuleBlockedClient.reply_callback,,module.c,reply_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
832,165101,auth_reply_cb,3,RedisModuleBlockedClient.auth_reply_cb,,module.c,auth_reply_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
833,165102,timeout_callback,3,RedisModuleBlockedClient.timeout_callback,,module.c,timeout_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
834,165103,disconnect_callback,3,RedisModuleBlockedClient.disconnect_callback,,module.c,disconnect_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
835,165110,privdata,3,RedisModuleBlockedClient.privdata,,module.c,*privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
836,165111,thread_safe_ctx_client,3,RedisModuleBlockedClient.thread_safe_ctx_client,,module.c,*thread_safe_ctx_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
837,165112,reply_client,3,RedisModuleBlockedClient.reply_client,,module.c,*reply_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
838,165113,dbid,3,RedisModuleBlockedClient.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
839,165114,blocked_on_keys,3,RedisModuleBlockedClient.blocked_on_keys,,module.c,blocked_on_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
840,165115,unblocked,3,RedisModuleBlockedClient.unblocked,,module.c,unblocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
841,165116,background_timer,3,RedisModuleBlockedClient.background_timer,,module.c,background_timer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
842,165117,background_duration,3,RedisModuleBlockedClient.background_duration,,module.c,background_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
843,165157,module,3,RedisModuleKeyspaceSubscriber.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
844,165158,notify_callback,3,RedisModuleKeyspaceSubscriber.notify_callback,,module.c,notify_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
845,165159,event_mask,3,RedisModuleKeyspaceSubscriber.event_mask,,module.c,event_mask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
846,165160,active,3,RedisModuleKeyspaceSubscriber.active,,module.c,active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
847,165163,module,3,RedisModulePostExecUnitJob.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
848,165164,callback,3,RedisModulePostExecUnitJob.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
849,165165,pd,3,RedisModulePostExecUnitJob.pd,,module.c,*pd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
850,165171,dbid,3,RedisModulePostExecUnitJob.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
851,165176,rax,3,RedisModuleDict.rax,,module.c,*rax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
852,165179,dict,3,RedisModuleDictIter.dict,,module.c,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
853,165180,ri,3,RedisModuleDictIter.ri,,module.c,ri,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
854,165183,argv,3,RedisModuleCommandFilterCtx.argv,,module.c,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
855,165184,argv_len,3,RedisModuleCommandFilterCtx.argv_len,,module.c,argv_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
856,165185,argc,3,RedisModuleCommandFilterCtx.argc,,module.c,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
857,165186,c,3,RedisModuleCommandFilterCtx.c,,module.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
858,165194,module,3,RedisModuleCommandFilter.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
859,165195,callback,3,RedisModuleCommandFilter.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
860,165196,flags,3,RedisModuleCommandFilter.flags,,module.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
861,165207,done_handler,3,RedisModuleForkInfo.done_handler,,module.c,done_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
862,165208,done_handler_user_data,3,RedisModuleForkInfo.done_handler_user_data,,module.c,* done_handler_user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
863,165215,rax,3,RedisModuleServerInfoData.rax,,module.c,*rax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
864,165218,module,3,RedisModuleEventListener.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
865,165219,event,3,RedisModuleEventListener.event,,module.c,event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
866,165220,callback,3,RedisModuleEventListener.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
867,165224,user,3,RedisModuleUser.user,,module.c,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
868,165225,free_user,3,RedisModuleUser.free_user,,module.c,free_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
869,165229,from_key,3,RedisModuleKeyOptCtx.from_key,,module.c,*from_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
870,165230,to_key,3,RedisModuleKeyOptCtx.to_key,,module.c,*to_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
871,165231,from_dbid,3,RedisModuleKeyOptCtx.from_dbid,,module.c,from_dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
872,165232,to_dbid,3,RedisModuleKeyOptCtx.to_dbid,,module.c,to_dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
873,165298,name,3,ModuleConfig.name,,module.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
874,165299,privdata,3,ModuleConfig.privdata,,module.c,*privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
875,165301,get_string,3,ModuleConfig.get_fn.get_string,,module.c,get_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
876,165302,get_numeric,3,ModuleConfig.get_fn.get_numeric,,module.c,get_numeric,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
877,165303,get_bool,3,ModuleConfig.get_fn.get_bool,,module.c,get_bool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
878,165304,get_enum,3,ModuleConfig.get_fn.get_enum,,module.c,get_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
879,165305,get_fn,3,ModuleConfig.get_fn,,module.c,get_fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
880,165307,set_string,3,ModuleConfig.set_fn.set_string,,module.c,set_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
881,165308,set_numeric,3,ModuleConfig.set_fn.set_numeric,,module.c,set_numeric,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
882,165309,set_bool,3,ModuleConfig.set_fn.set_bool,,module.c,set_bool,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
883,165310,set_enum,3,ModuleConfig.set_fn.set_enum,,module.c,set_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
884,165311,set_fn,3,ModuleConfig.set_fn,,module.c,set_fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
885,165312,apply_fn,3,ModuleConfig.apply_fn,,module.c,apply_fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
886,165313,module,3,ModuleConfig.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
887,165315,ref_count,3,RedisModuleAsyncRMCallPromise.ref_count,,module.c,ref_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
888,165316,private_data,3,RedisModuleAsyncRMCallPromise.private_data,,module.c,*private_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
889,165317,module,3,RedisModuleAsyncRMCallPromise.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
890,165318,on_unblocked,3,RedisModuleAsyncRMCallPromise.on_unblocked,,module.c,on_unblocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
891,165319,c,3,RedisModuleAsyncRMCallPromise.c,,module.c,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
892,165320,ctx,3,RedisModuleAsyncRMCallPromise.ctx,,module.c,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
893,187472,module_id,3,moduleClusterReceiver.module_id,,module.c,module_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
894,187473,callback,3,moduleClusterReceiver.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
895,187475,module,3,moduleClusterReceiver.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
896,187477,next,3,moduleClusterReceiver.next,,module.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
897,187480,flags,3,moduleClusterNodeInfo.flags,,module.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
898,187481,ip,3,moduleClusterNodeInfo.ip,,module.c,ip[NET_IP_STR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
899,187482,port,3,moduleClusterNodeInfo.port,,module.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
900,187483,master_id,3,moduleClusterNodeInfo.master_id,,module.c,master_id[40],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
901,188223,module,3,RedisModuleTimer.module,,module.c,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
902,188224,callback,3,RedisModuleTimer.callback,,module.c,callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
903,188225,data,3,RedisModuleTimer.data,,module.c,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
904,188226,dbid,3,RedisModuleTimer.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
905,188734,rFunc,3,EventLoopData.rFunc,,module.c,rFunc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
906,188735,wFunc,3,EventLoopData.wFunc,,module.c,wFunc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
907,188736,user_data,3,EventLoopData.user_data,,module.c,*user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
908,188739,func,3,EventLoopOneShot.func,,module.c,func,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
909,188740,user_data,3,EventLoopOneShot.user_data,,module.c,*user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
910,192812,ctx,3,ScanCBData.ctx,,module.c,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
911,192813,user_data,3,ScanCBData.user_data,,module.c,* user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
912,192814,fn,3,ScanCBData.fn,,module.c,fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
913,192817,cursor,3,RedisModuleScanCursor.cursor,,module.c,cursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
914,192818,done,3,RedisModuleScanCursor.done,,module.c,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
915,193007,key,3,ScanKeyCBData.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
916,193008,user_data,3,ScanKeyCBData.user_data,,module.c,* user_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
917,193009,fn,3,ScanKeyCBData.fn,,module.c,fn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
918,194111,dbnum,3,KeyInfo.dbnum,,module.c,dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
919,194112,key,3,KeyInfo.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
920,194113,value,3,KeyInfo.value,,module.c,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
921,194114,mode,3,KeyInfo.mode,,module.c,mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
922,198710,type,3,RedisModuleRdbStream.type,,module.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
923,198712,filename,3,RedisModuleRdbStream.data.filename,,module.c,*filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
924,198713,data,3,RedisModuleRdbStream.data,,module.c,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
925,199865,endtime,3,RedisModuleDefragCtx.endtime,,module.c,endtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
926,199866,cursor,3,RedisModuleDefragCtx.cursor,,module.c,*cursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
927,199868,key,3,RedisModuleDefragCtx.key,,module.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
928,199869,dbid,3,RedisModuleDefragCtx.dbid,,module.c,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
929,205267,value,3,HelloTypeNode.value,,modules\hellotype.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
930,205269,next,3,HelloTypeNode.next,,modules\hellotype.c,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
931,205272,head,3,HelloTypeObject.head,,modules\hellotype.c,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
932,205273,len,3,HelloTypeObject.len,,modules\hellotype.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
933,208203,MONOTONIC_CLOCK_POSIX,3,monotonic_clock_type.MONOTONIC_CLOCK_POSIX,,monotonic.h,MONOTONIC_CLOCK_POSIX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
934,208204,MONOTONIC_CLOCK_HW,3,monotonic_clock_type.MONOTONIC_CLOCK_HW,,monotonic.h,MONOTONIC_CLOCK_HW,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
935,209710,node,3,watchedKey.node,,multi.c,node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
936,209711,key,3,watchedKey.key,,multi.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
937,209712,db,3,watchedKey.db,,multi.c,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
938,209713,client,3,watchedKey.client,,multi.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
939,209714,expired,3,watchedKey.expired,,multi.c,expired:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
940,225364,value,3,threads_pending.value,,networking.c,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
941,235196,shard,3,pubsubtype.shard,,pubsub.c,shard,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
942,235207,serverPubSubChannels,3,pubsubtype.serverPubSubChannels,,pubsub.c,**serverPubSubChannels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
943,235208,subscribeMsg,3,pubsubtype.subscribeMsg,,pubsub.c,**subscribeMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
944,235209,unsubscribeMsg,3,pubsubtype.unsubscribeMsg,,pubsub.c,**unsubscribeMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
945,235210,messageBulk,3,pubsubtype.messageBulk,,pubsub.c,**messageBulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
946,243725,prev,3,quicklistNode.prev,,quicklist.h,*prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
947,243727,next,3,quicklistNode.next,,quicklist.h,*next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
948,243728,entry,3,quicklistNode.entry,,quicklist.h,*entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,43,0,1,1,0,0,,0,0,0,0,0,
949,243729,sz,3,quicklistNode.sz,,quicklist.h,sz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
950,243730,count,3,quicklistNode.count,,quicklist.h,count : 16,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
951,243731,encoding,3,quicklistNode.encoding,,quicklist.h,encoding : 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
952,243732,container,3,quicklistNode.container,,quicklist.h,container : 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
953,243733,recompress,3,quicklistNode.recompress,,quicklist.h,recompress : 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
954,243734,attempted_compress,3,quicklistNode.attempted_compress,,quicklist.h,attempted_compress : 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
955,243735,dont_compress,3,quicklistNode.dont_compress,,quicklist.h,dont_compress : 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
956,243736,extra,3,quicklistNode.extra,,quicklist.h,extra : 9,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
957,243739,sz,3,quicklistLZF.sz,,quicklist.h,sz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
958,243740,compressed,3,quicklistLZF.compressed,,quicklist.h,compressed[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
959,243748,node,3,quicklistBookmark.node,,quicklist.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
960,243749,name,3,quicklistBookmark.name,,quicklist.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
961,243752,head,3,quicklist.head,,quicklist.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
962,243753,tail,3,quicklist.tail,,quicklist.h,*tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
963,243754,count,3,quicklist.count,,quicklist.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
964,243755,len,3,quicklist.len,,quicklist.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
965,243756,fill,3,quicklist.fill,,quicklist.h,fill : QL_FILL_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
966,243757,compress,3,quicklist.compress,,quicklist.h,compress : QL_COMP_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
967,243758,bookmark_count,3,quicklist.bookmark_count,,quicklist.h,bookmark_count: QL_BM_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
968,243759,bookmarks,3,quicklist.bookmarks,,quicklist.h,bookmarks[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
969,243767,quicklist,3,quicklistIter.quicklist,,quicklist.h,*quicklist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
970,243768,current,3,quicklistIter.current,,quicklist.h,*current,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
971,243769,zi,3,quicklistIter.zi,,quicklist.h,*zi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
972,243770,offset,3,quicklistIter.offset,,quicklist.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
973,243771,direction,3,quicklistIter.direction,,quicklist.h,direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
974,243774,quicklist,3,quicklistEntry.quicklist,,quicklist.h,*quicklist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
975,243775,node,3,quicklistEntry.node,,quicklist.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
976,243776,zi,3,quicklistEntry.zi,,quicklist.h,*zi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
977,243777,value,3,quicklistEntry.value,,quicklist.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
978,243778,longval,3,quicklistEntry.longval,,quicklist.h,longval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
979,243779,sz,3,quicklistEntry.sz,,quicklist.h,sz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
980,243780,offset,3,quicklistEntry.offset,,quicklist.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
981,251839,iskey,3,raxNode.iskey,,rax.h,iskey:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,55,0,1,1,0,0,,0,0,0,0,0,
982,251840,isnull,3,raxNode.isnull,,rax.h,isnull:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
983,251841,iscompr,3,raxNode.iscompr,,rax.h,iscompr:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,41,0,1,1,0,0,,0,0,0,0,0,
984,251842,size,3,raxNode.size,,rax.h,size:29,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,103,0,1,1,0,0,,0,0,0,0,0,
985,251843,data,3,raxNode.data,,rax.h,data[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
986,251851,head,3,rax.head,,rax.h,*head,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
987,251852,numele,3,rax.numele,,rax.h,numele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
988,251853,numnodes,3,rax.numnodes,,rax.h,numnodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
989,251856,stack,3,raxStack.stack,,rax.h,**stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
990,251857,items,3,raxStack.items,,rax.h,items,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
991,251858,maxitems,3,raxStack.maxitems,,rax.h,maxitems,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
992,251859,static_items,3,raxStack.static_items,,rax.h,*static_items[RAX_STACK_STATIC_ITEMS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
993,251860,oom,3,raxStack.oom,,rax.h,oom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
994,251876,flags,3,raxIterator.flags,,rax.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
995,251877,rt,3,raxIterator.rt,,rax.h,*rt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
996,251878,key,3,raxIterator.key,,rax.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,28,0,1,1,0,0,,0,0,0,0,0,
997,251879,data,3,raxIterator.data,,rax.h,*data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
998,251880,key_len,3,raxIterator.key_len,,rax.h,key_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
999,251881,key_max,3,raxIterator.key_max,,rax.h,key_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1000,251882,key_static_string,3,raxIterator.key_static_string,,rax.h,key_static_string[RAX_ITER_STATIC_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1001,251883,node,3,raxIterator.node,,rax.h,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,72,0,1,1,0,0,,0,0,0,0,0,
1002,251884,stack,3,raxIterator.stack,,rax.h,stack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1003,251885,node_cb,3,raxIterator.node_cb,,rax.h,node_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1004,266458,el,3,config.el,,redis-benchmark.c,*el,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1005,266459,conn_info,3,config.conn_info,,redis-benchmark.c,conn_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1006,266460,hostsocket,3,config.hostsocket,,redis-benchmark.c,*hostsocket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1007,266461,tls,3,config.tls,,redis-benchmark.c,tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1008,266463,sslconfig,3,config.sslconfig,,redis-benchmark.c,sslconfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1009,266464,numclients,3,config.numclients,,redis-benchmark.c,numclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1010,266465,liveclients,3,config.liveclients,,redis-benchmark.c,liveclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1011,266466,requests,3,config.requests,,redis-benchmark.c,requests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1012,266467,requests_issued,3,config.requests_issued,,redis-benchmark.c,requests_issued,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1013,266468,requests_finished,3,config.requests_finished,,redis-benchmark.c,requests_finished,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1014,266469,previous_requests_finished,3,config.previous_requests_finished,,redis-benchmark.c,previous_requests_finished,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1015,266470,last_printed_bytes,3,config.last_printed_bytes,,redis-benchmark.c,last_printed_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1016,266471,previous_tick,3,config.previous_tick,,redis-benchmark.c,previous_tick,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1017,266472,keysize,3,config.keysize,,redis-benchmark.c,keysize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1018,266473,datasize,3,config.datasize,,redis-benchmark.c,datasize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1019,266474,randomkeys,3,config.randomkeys,,redis-benchmark.c,randomkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1020,266475,randomkeys_keyspacelen,3,config.randomkeys_keyspacelen,,redis-benchmark.c,randomkeys_keyspacelen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1021,266476,keepalive,3,config.keepalive,,redis-benchmark.c,keepalive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1022,266477,pipeline,3,config.pipeline,,redis-benchmark.c,pipeline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1023,266478,start,3,config.start,,redis-benchmark.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1024,266479,totlatency,3,config.totlatency,,redis-benchmark.c,totlatency,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1025,266480,title,3,config.title,,redis-benchmark.c,*title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1026,266481,clients,3,config.clients,,redis-benchmark.c,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1027,266482,quiet,3,config.quiet,,redis-benchmark.c,quiet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1028,266483,csv,3,config.csv,,redis-benchmark.c,csv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1029,266484,loop,3,config.loop,,redis-benchmark.c,loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1030,266485,idlemode,3,config.idlemode,,redis-benchmark.c,idlemode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1031,266486,input_dbnumstr,3,config.input_dbnumstr,,redis-benchmark.c,input_dbnumstr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1032,266487,tests,3,config.tests,,redis-benchmark.c,*tests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1033,266488,stdinarg,3,config.stdinarg,,redis-benchmark.c,stdinarg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1034,266489,precision,3,config.precision,,redis-benchmark.c,precision,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1035,266490,num_threads,3,config.num_threads,,redis-benchmark.c,num_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1036,266492,threads,3,config.threads,,redis-benchmark.c,**threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1037,266493,cluster_mode,3,config.cluster_mode,,redis-benchmark.c,cluster_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1038,266494,cluster_node_count,3,config.cluster_node_count,,redis-benchmark.c,cluster_node_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1039,266496,cluster_nodes,3,config.cluster_nodes,,redis-benchmark.c,**cluster_nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1040,266498,redis_config,3,config.redis_config,,redis-benchmark.c,*redis_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1041,266500,latency_histogram,3,config.latency_histogram,,redis-benchmark.c,* latency_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1042,266502,current_sec_latency_histogram,3,config.current_sec_latency_histogram,,redis-benchmark.c,* current_sec_latency_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1043,266503,is_fetching_slots,3,config.is_fetching_slots,,redis-benchmark.c,is_fetching_slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1044,266504,is_updating_slots,3,config.is_updating_slots,,redis-benchmark.c,is_updating_slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1045,266505,slots_last_update,3,config.slots_last_update,,redis-benchmark.c,slots_last_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1046,266506,enable_tracking,3,config.enable_tracking,,redis-benchmark.c,enable_tracking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1047,266507,liveclients_mutex,3,config.liveclients_mutex,,redis-benchmark.c,liveclients_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1048,266508,is_updating_slots_mutex,3,config.is_updating_slots_mutex,,redis-benchmark.c,is_updating_slots_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1049,266509,resp3,3,config.resp3,,redis-benchmark.c,resp3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1050,266512,context,3,_client.context,,redis-benchmark.c,*context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1051,266513,obuf,3,_client.obuf,,redis-benchmark.c,obuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1052,266514,randptr,3,_client.randptr,,redis-benchmark.c,**randptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1053,266515,randlen,3,_client.randlen,,redis-benchmark.c,randlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1054,266516,randfree,3,_client.randfree,,redis-benchmark.c,randfree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1055,266517,stagptr,3,_client.stagptr,,redis-benchmark.c,**stagptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1056,266518,staglen,3,_client.staglen,,redis-benchmark.c,staglen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1057,266519,stagfree,3,_client.stagfree,,redis-benchmark.c,stagfree,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1058,266520,written,3,_client.written,,redis-benchmark.c,written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1059,266521,start,3,_client.start,,redis-benchmark.c,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1060,266522,latency,3,_client.latency,,redis-benchmark.c,latency,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1061,266523,pending,3,_client.pending,,redis-benchmark.c,pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1062,266524,prefix_pending,3,_client.prefix_pending,,redis-benchmark.c,prefix_pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1063,266525,prefixlen,3,_client.prefixlen,,redis-benchmark.c,prefixlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1064,266526,thread_id,3,_client.thread_id,,redis-benchmark.c,thread_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1065,266528,cluster_node,3,_client.cluster_node,,redis-benchmark.c,*cluster_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1066,266529,slots_last_update,3,_client.slots_last_update,,redis-benchmark.c,slots_last_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1067,266532,index,3,benchmarkThread.index,,redis-benchmark.c,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1068,266533,thread,3,benchmarkThread.thread,,redis-benchmark.c,thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1069,266534,el,3,benchmarkThread.el,,redis-benchmark.c,*el,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1070,266537,ip,3,clusterNode.ip,,redis-benchmark.c,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,34,0,1,1,0,0,,0,0,0,0,0,
1071,266538,port,3,clusterNode.port,,redis-benchmark.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1072,266539,name,3,clusterNode.name,,redis-benchmark.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
1073,266540,flags,3,clusterNode.flags,,redis-benchmark.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,89,0,1,1,0,0,,0,0,0,0,0,
1074,266541,replicate,3,clusterNode.replicate,,redis-benchmark.c,replicate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1075,266542,slots,3,clusterNode.slots,,redis-benchmark.c,*slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1076,266543,slots_count,3,clusterNode.slots_count,,redis-benchmark.c,slots_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1077,266544,current_slot_index,3,clusterNode.current_slot_index,,redis-benchmark.c,current_slot_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1078,266545,updated_slots,3,clusterNode.updated_slots,,redis-benchmark.c,*updated_slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1079,266546,updated_slots_count,3,clusterNode.updated_slots_count,,redis-benchmark.c,updated_slots_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1080,266547,replicas_count,3,clusterNode.replicas_count,,redis-benchmark.c,replicas_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1081,266548,migrating,3,clusterNode.migrating,,redis-benchmark.c,*migrating,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1082,266549,importing,3,clusterNode.importing,,redis-benchmark.c,*importing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1083,266550,migrating_count,3,clusterNode.migrating_count,,redis-benchmark.c,migrating_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1084,266551,importing_count,3,clusterNode.importing_count,,redis-benchmark.c,importing_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1085,266553,redis_config,3,clusterNode.redis_config,,redis-benchmark.c,*redis_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1086,266556,save,3,redisConfig.save,,redis-benchmark.c,save,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1087,266557,appendonly,3,redisConfig.appendonly,,redis-benchmark.c,appendonly,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1088,274124,AOF_RESP,3,input_file_type.AOF_RESP,,redis-check-aof.c,AOF_RESP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1089,274125,AOF_RDB_PREAMBLE,3,input_file_type.AOF_RDB_PREAMBLE,,redis-check-aof.c,AOF_RDB_PREAMBLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1090,274126,AOF_MULTI_PART,3,input_file_type.AOF_MULTI_PART,,redis-check-aof.c,AOF_MULTI_PART,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1091,275705,rio,3,rdbstate.rio,,redis-check-rdb.c,*rio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1092,275706,key,3,rdbstate.key,,redis-check-rdb.c,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1093,275707,key_type,3,rdbstate.key_type,,redis-check-rdb.c,key_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1094,275708,keys,3,rdbstate.keys,,redis-check-rdb.c,keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1095,275709,expires,3,rdbstate.expires,,redis-check-rdb.c,expires,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1096,275710,already_expired,3,rdbstate.already_expired,,redis-check-rdb.c,already_expired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1097,275711,doing,3,rdbstate.doing,,redis-check-rdb.c,doing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1098,275712,error_set,3,rdbstate.error_set,,redis-check-rdb.c,error_set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1099,275713,error,3,rdbstate.error,,redis-check-rdb.c,error[1024],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1100,277100,name,3,clusterManagerCommand.name,,redis-cli.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1101,277101,argc,3,clusterManagerCommand.argc,,redis-cli.c,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1102,277102,argv,3,clusterManagerCommand.argv,,redis-cli.c,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1103,277103,stdin_arg,3,clusterManagerCommand.stdin_arg,,redis-cli.c,stdin_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1104,277104,flags,3,clusterManagerCommand.flags,,redis-cli.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1105,277105,replicas,3,clusterManagerCommand.replicas,,redis-cli.c,replicas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1106,277106,from,3,clusterManagerCommand.from,,redis-cli.c,*from,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1107,277107,to,3,clusterManagerCommand.to,,redis-cli.c,*to,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1108,277108,weight,3,clusterManagerCommand.weight,,redis-cli.c,**weight,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1109,277109,weight_argc,3,clusterManagerCommand.weight_argc,,redis-cli.c,weight_argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1110,277110,master_id,3,clusterManagerCommand.master_id,,redis-cli.c,*master_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1111,277111,slots,3,clusterManagerCommand.slots,,redis-cli.c,slots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1112,277112,timeout,3,clusterManagerCommand.timeout,,redis-cli.c,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1113,277113,pipeline,3,clusterManagerCommand.pipeline,,redis-cli.c,pipeline,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1114,277114,threshold,3,clusterManagerCommand.threshold,,redis-cli.c,threshold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1115,277115,backup_dir,3,clusterManagerCommand.backup_dir,,redis-cli.c,*backup_dir,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1116,277116,from_user,3,clusterManagerCommand.from_user,,redis-cli.c,*from_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1117,277117,from_pass,3,clusterManagerCommand.from_pass,,redis-cli.c,*from_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1118,277118,from_askpass,3,clusterManagerCommand.from_askpass,,redis-cli.c,from_askpass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1119,277129,conn_info,3,config.conn_info,,redis-cli.c,conn_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,37,0,1,1,0,0,,0,0,0,0,0,
1120,277130,hostsocket,3,config.hostsocket,,redis-cli.c,*hostsocket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1121,277131,tls,3,config.tls,,redis-cli.c,tls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1122,277132,sslconfig,3,config.sslconfig,,redis-cli.c,sslconfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1123,277133,repeat,3,config.repeat,,redis-cli.c,repeat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1124,277134,interval,3,config.interval,,redis-cli.c,interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1125,277135,dbnum,3,config.dbnum,,redis-cli.c,dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1126,277136,interactive,3,config.interactive,,redis-cli.c,interactive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1127,277137,shutdown,3,config.shutdown,,redis-cli.c,shutdown,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1128,277138,monitor_mode,3,config.monitor_mode,,redis-cli.c,monitor_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1129,277139,pubsub_mode,3,config.pubsub_mode,,redis-cli.c,pubsub_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1130,277140,blocking_state_aborted,3,config.blocking_state_aborted,,redis-cli.c,blocking_state_aborted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1131,277141,latency_mode,3,config.latency_mode,,redis-cli.c,latency_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1132,277142,latency_dist_mode,3,config.latency_dist_mode,,redis-cli.c,latency_dist_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1133,277143,latency_history,3,config.latency_history,,redis-cli.c,latency_history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1134,277144,lru_test_mode,3,config.lru_test_mode,,redis-cli.c,lru_test_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1135,277145,lru_test_sample_size,3,config.lru_test_sample_size,,redis-cli.c,lru_test_sample_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1136,277146,cluster_mode,3,config.cluster_mode,,redis-cli.c,cluster_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1137,277147,cluster_reissue_command,3,config.cluster_reissue_command,,redis-cli.c,cluster_reissue_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1138,277148,cluster_send_asking,3,config.cluster_send_asking,,redis-cli.c,cluster_send_asking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1139,277149,slave_mode,3,config.slave_mode,,redis-cli.c,slave_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1140,277150,pipe_mode,3,config.pipe_mode,,redis-cli.c,pipe_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1141,277151,pipe_timeout,3,config.pipe_timeout,,redis-cli.c,pipe_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1142,277152,getrdb_mode,3,config.getrdb_mode,,redis-cli.c,getrdb_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1143,277153,get_functions_rdb_mode,3,config.get_functions_rdb_mode,,redis-cli.c,get_functions_rdb_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1144,277154,stat_mode,3,config.stat_mode,,redis-cli.c,stat_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1145,277155,scan_mode,3,config.scan_mode,,redis-cli.c,scan_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1146,277156,count,3,config.count,,redis-cli.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1147,277157,intrinsic_latency_mode,3,config.intrinsic_latency_mode,,redis-cli.c,intrinsic_latency_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1148,277158,intrinsic_latency_duration,3,config.intrinsic_latency_duration,,redis-cli.c,intrinsic_latency_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1149,277159,pattern,3,config.pattern,,redis-cli.c,pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1150,277160,rdb_filename,3,config.rdb_filename,,redis-cli.c,*rdb_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1151,277161,bigkeys,3,config.bigkeys,,redis-cli.c,bigkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1152,277162,memkeys,3,config.memkeys,,redis-cli.c,memkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1153,277163,memkeys_samples,3,config.memkeys_samples,,redis-cli.c,memkeys_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1154,277164,hotkeys,3,config.hotkeys,,redis-cli.c,hotkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1155,277165,stdin_lastarg,3,config.stdin_lastarg,,redis-cli.c,stdin_lastarg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1156,277166,stdin_tag_arg,3,config.stdin_tag_arg,,redis-cli.c,stdin_tag_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1157,277167,stdin_tag_name,3,config.stdin_tag_name,,redis-cli.c,*stdin_tag_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1158,277168,askpass,3,config.askpass,,redis-cli.c,askpass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1159,277169,quoted_input,3,config.quoted_input,,redis-cli.c,quoted_input,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1160,277170,output,3,config.output,,redis-cli.c,output,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1161,277171,push_output,3,config.push_output,,redis-cli.c,push_output,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1162,277172,mb_delim,3,config.mb_delim,,redis-cli.c,mb_delim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1163,277173,cmd_delim,3,config.cmd_delim,,redis-cli.c,cmd_delim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1164,277174,prompt,3,config.prompt,,redis-cli.c,prompt[128],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1165,277175,eval,3,config.eval,,redis-cli.c,*eval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1166,277176,eval_ldb,3,config.eval_ldb,,redis-cli.c,eval_ldb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1167,277177,eval_ldb_sync,3,config.eval_ldb_sync,,redis-cli.c,eval_ldb_sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1168,277178,eval_ldb_end,3,config.eval_ldb_end,,redis-cli.c,eval_ldb_end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1169,277179,enable_ldb_on_eval,3,config.enable_ldb_on_eval,,redis-cli.c,enable_ldb_on_eval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1170,277180,last_cmd_type,3,config.last_cmd_type,,redis-cli.c,last_cmd_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1171,277181,last_reply,3,config.last_reply,,redis-cli.c,*last_reply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1172,277182,verbose,3,config.verbose,,redis-cli.c,verbose,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1173,277183,set_errcode,3,config.set_errcode,,redis-cli.c,set_errcode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1174,277184,cluster_manager_command,3,config.cluster_manager_command,,redis-cli.c,cluster_manager_command,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1175,277185,no_auth_warning,3,config.no_auth_warning,,redis-cli.c,no_auth_warning,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1176,277186,resp2,3,config.resp2,,redis-cli.c,resp2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1177,277187,resp3,3,config.resp3,,redis-cli.c,resp3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1178,277188,current_resp3,3,config.current_resp3,,redis-cli.c,current_resp3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1179,277189,in_multi,3,config.in_multi,,redis-cli.c,in_multi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1180,277190,pre_multi_dbnum,3,config.pre_multi_dbnum,,redis-cli.c,pre_multi_dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1181,277191,server_version,3,config.server_version,,redis-cli.c,*server_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1182,277192,test_hint,3,config.test_hint,,redis-cli.c,*test_hint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1183,277193,test_hint_file,3,config.test_hint_file,,redis-cli.c,*test_hint_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1184,277202,hints,3,pref.hints,,redis-cli.c,hints,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1185,277560,type,3,helpEntry.type,,redis-cli.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1186,277561,argc,3,helpEntry.argc,,redis-cli.c,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1187,277562,argv,3,helpEntry.argv,,redis-cli.c,*argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1188,277563,full,3,helpEntry.full,,redis-cli.c,full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1189,277565,docs,3,helpEntry.docs,,redis-cli.c,docs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
1190,289858,nodes,3,clusterManager.nodes,,redis-cli.c,*nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1191,289859,errors,3,clusterManager.errors,,redis-cli.c,*errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1192,289860,unreachable_masters,3,clusterManager.unreachable_masters,,redis-cli.c,unreachable_masters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1193,289867,context,3,clusterManagerNode.context,,redis-cli.c,*context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
1194,289868,name,3,clusterManagerNode.name,,redis-cli.c,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1195,289869,ip,3,clusterManagerNode.ip,,redis-cli.c,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
1196,289870,port,3,clusterManagerNode.port,,redis-cli.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
1197,289871,bus_port,3,clusterManagerNode.bus_port,,redis-cli.c,bus_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1198,289872,current_epoch,3,clusterManagerNode.current_epoch,,redis-cli.c,current_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1199,289873,ping_sent,3,clusterManagerNode.ping_sent,,redis-cli.c,ping_sent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1200,289874,ping_recv,3,clusterManagerNode.ping_recv,,redis-cli.c,ping_recv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1201,289875,flags,3,clusterManagerNode.flags,,redis-cli.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1202,289876,flags_str,3,clusterManagerNode.flags_str,,redis-cli.c,*flags_str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1203,289877,replicate,3,clusterManagerNode.replicate,,redis-cli.c,replicate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1204,289878,dirty,3,clusterManagerNode.dirty,,redis-cli.c,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1205,289879,slots,3,clusterManagerNode.slots,,redis-cli.c,slots[CLUSTER_MANAGER_SLOTS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1206,289880,slots_count,3,clusterManagerNode.slots_count,,redis-cli.c,slots_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1207,289881,replicas_count,3,clusterManagerNode.replicas_count,,redis-cli.c,replicas_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1208,289882,friends,3,clusterManagerNode.friends,,redis-cli.c,*friends,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1209,289883,migrating,3,clusterManagerNode.migrating,,redis-cli.c,*migrating,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1210,289884,importing,3,clusterManagerNode.importing,,redis-cli.c,*importing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1211,289885,migrating_count,3,clusterManagerNode.migrating_count,,redis-cli.c,migrating_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1212,289886,importing_count,3,clusterManagerNode.importing_count,,redis-cli.c,importing_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1213,289887,weight,3,clusterManagerNode.weight,,redis-cli.c,weight,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1214,289888,balance,3,clusterManagerNode.balance,,redis-cli.c,balance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1215,289899,nodes,3,clusterManagerNodeArray.nodes,,redis-cli.c,**nodes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1216,289900,alloc,3,clusterManagerNodeArray.alloc,,redis-cli.c,**alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1217,289901,len,3,clusterManagerNodeArray.len,,redis-cli.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1218,289902,count,3,clusterManagerNodeArray.count,,redis-cli.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1219,289905,source,3,clusterManagerReshardTableItem.source,,redis-cli.c,*source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1220,289906,slot,3,clusterManagerReshardTableItem.slot,,redis-cli.c,slot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1221,289909,node_name,3,clusterManagerLink.node_name,,redis-cli.c,node_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1222,289910,node_addr,3,clusterManagerLink.node_addr,,redis-cli.c,node_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1223,289911,connected,3,clusterManagerLink.connected,,redis-cli.c,connected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1224,289912,handshaking,3,clusterManagerLink.handshaking,,redis-cli.c,handshaking,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1225,290170,name,3,clusterManagerCommandDef.name,,redis-cli.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1226,290171,proc,3,clusterManagerCommandDef.proc,,redis-cli.c,*proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1227,290172,arity,3,clusterManagerCommandDef.arity,,redis-cli.c,arity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1228,290173,args,3,clusterManagerCommandDef.args,,redis-cli.c,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1229,290174,options,3,clusterManagerCommandDef.options,,redis-cli.c,*options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1230,290266,name,3,clusterManagerOptionDef.name,,redis-cli.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1231,290267,desc,3,clusterManagerOptionDef.desc,,redis-cli.c,*desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1232,308482,max,3,distsamples.max,,redis-cli.c,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1233,308483,count,3,distsamples.count,,redis-cli.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1234,308484,character,3,distsamples.character,,redis-cli.c,character,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1235,310346,name,3,typeinfo.name,,redis-cli.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1236,310347,sizecmd,3,typeinfo.sizecmd,,redis-cli.c,*sizecmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1237,310348,sizeunit,3,typeinfo.sizeunit,,redis-cli.c,*sizeunit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1238,310349,biggest,3,typeinfo.biggest,,redis-cli.c,biggest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1239,310350,count,3,typeinfo.count,,redis-cli.c,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1240,310351,totalsize,3,typeinfo.totalsize,,redis-cli.c,totalsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1241,310352,biggest_key,3,typeinfo.biggest_key,,redis-cli.c,biggest_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1242,314164,ms,3,RedisModuleStreamID.ms,,redismodule.h,ms,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1243,314165,seq,3,RedisModuleStreamID.seq,,redismodule.h,seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1244,314169,REDISMODULE_ARG_TYPE_STRING,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_STRING,,redismodule.h,REDISMODULE_ARG_TYPE_STRING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1245,314170,REDISMODULE_ARG_TYPE_INTEGER,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_INTEGER,,redismodule.h,REDISMODULE_ARG_TYPE_INTEGER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1246,314171,REDISMODULE_ARG_TYPE_DOUBLE,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_DOUBLE,,redismodule.h,REDISMODULE_ARG_TYPE_DOUBLE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1247,314172,REDISMODULE_ARG_TYPE_KEY,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_KEY,,redismodule.h,REDISMODULE_ARG_TYPE_KEY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1248,314173,REDISMODULE_ARG_TYPE_PATTERN,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_PATTERN,,redismodule.h,REDISMODULE_ARG_TYPE_PATTERN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1249,314174,REDISMODULE_ARG_TYPE_UNIX_TIME,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_UNIX_TIME,,redismodule.h,REDISMODULE_ARG_TYPE_UNIX_TIME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1250,314175,REDISMODULE_ARG_TYPE_PURE_TOKEN,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_PURE_TOKEN,,redismodule.h,REDISMODULE_ARG_TYPE_PURE_TOKEN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1251,314176,REDISMODULE_ARG_TYPE_ONEOF,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_ONEOF,,redismodule.h,REDISMODULE_ARG_TYPE_ONEOF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1252,314177,REDISMODULE_ARG_TYPE_BLOCK,3,RedisModuleCommandArgType.REDISMODULE_ARG_TYPE_BLOCK,,redismodule.h,REDISMODULE_ARG_TYPE_BLOCK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1253,314180,REDISMODULE_KSPEC_BS_INVALID,3,RedisModuleKeySpecBeginSearchType.REDISMODULE_KSPEC_BS_INVALID,,redismodule.h,REDISMODULE_KSPEC_BS_INVALID = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1254,314181,REDISMODULE_KSPEC_BS_UNKNOWN,3,RedisModuleKeySpecBeginSearchType.REDISMODULE_KSPEC_BS_UNKNOWN,,redismodule.h,REDISMODULE_KSPEC_BS_UNKNOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1255,314182,REDISMODULE_KSPEC_BS_INDEX,3,RedisModuleKeySpecBeginSearchType.REDISMODULE_KSPEC_BS_INDEX,,redismodule.h,REDISMODULE_KSPEC_BS_INDEX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1256,314183,REDISMODULE_KSPEC_BS_KEYWORD,3,RedisModuleKeySpecBeginSearchType.REDISMODULE_KSPEC_BS_KEYWORD,,redismodule.h,REDISMODULE_KSPEC_BS_KEYWORD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1257,314193,REDISMODULE_KSPEC_FK_OMITTED,3,RedisModuleKeySpecFindKeysType.REDISMODULE_KSPEC_FK_OMITTED,,redismodule.h,REDISMODULE_KSPEC_FK_OMITTED = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1258,314194,REDISMODULE_KSPEC_FK_UNKNOWN,3,RedisModuleKeySpecFindKeysType.REDISMODULE_KSPEC_FK_UNKNOWN,,redismodule.h,REDISMODULE_KSPEC_FK_UNKNOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1259,314195,REDISMODULE_KSPEC_FK_RANGE,3,RedisModuleKeySpecFindKeysType.REDISMODULE_KSPEC_FK_RANGE,,redismodule.h,REDISMODULE_KSPEC_FK_RANGE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1260,314196,REDISMODULE_KSPEC_FK_KEYNUM,3,RedisModuleKeySpecFindKeysType.REDISMODULE_KSPEC_FK_KEYNUM,,redismodule.h,REDISMODULE_KSPEC_FK_KEYNUM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1261,314206,name,3,RedisModuleCommandArg.name,,redismodule.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1262,314207,type,3,RedisModuleCommandArg.type,,redismodule.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1263,314208,key_spec_index,3,RedisModuleCommandArg.key_spec_index,,redismodule.h,key_spec_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1264,314209,token,3,RedisModuleCommandArg.token,,redismodule.h,*token,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1265,314210,summary,3,RedisModuleCommandArg.summary,,redismodule.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1266,314211,since,3,RedisModuleCommandArg.since,,redismodule.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1267,314212,flags,3,RedisModuleCommandArg.flags,,redismodule.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1268,314213,deprecated_since,3,RedisModuleCommandArg.deprecated_since,,redismodule.h,*deprecated_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1269,314215,subargs,3,RedisModuleCommandArg.subargs,,redismodule.h,*subargs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1270,314216,display_text,3,RedisModuleCommandArg.display_text,,redismodule.h,*display_text,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1271,314219,since,3,RedisModuleCommandHistoryEntry.since,,redismodule.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1272,314220,changes,3,RedisModuleCommandHistoryEntry.changes,,redismodule.h,*changes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1273,314223,notes,3,RedisModuleCommandKeySpec.notes,,redismodule.h,*notes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1274,314224,flags,3,RedisModuleCommandKeySpec.flags,,redismodule.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1275,314225,begin_search_type,3,RedisModuleCommandKeySpec.begin_search_type,,redismodule.h,begin_search_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1276,314228,pos,3,RedisModuleCommandKeySpec.bs.index.pos,,redismodule.h,pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1277,314229,index,3,RedisModuleCommandKeySpec.bs.index,,redismodule.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1278,314231,keyword,3,RedisModuleCommandKeySpec.bs.keyword.keyword,,redismodule.h,*keyword,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1279,314232,startfrom,3,RedisModuleCommandKeySpec.bs.keyword.startfrom,,redismodule.h,startfrom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1280,314233,keyword,3,RedisModuleCommandKeySpec.bs.keyword,,redismodule.h,keyword,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1281,314234,bs,3,RedisModuleCommandKeySpec.bs,,redismodule.h,bs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1282,314235,find_keys_type,3,RedisModuleCommandKeySpec.find_keys_type,,redismodule.h,find_keys_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1283,314238,lastkey,3,RedisModuleCommandKeySpec.fk.range.lastkey,,redismodule.h,lastkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1284,314239,keystep,3,RedisModuleCommandKeySpec.fk.range.keystep,,redismodule.h,keystep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1285,314240,limit,3,RedisModuleCommandKeySpec.fk.range.limit,,redismodule.h,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1286,314241,range,3,RedisModuleCommandKeySpec.fk.range,,redismodule.h,range,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1287,314243,keynumidx,3,RedisModuleCommandKeySpec.fk.keynum.keynumidx,,redismodule.h,keynumidx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1288,314244,firstkey,3,RedisModuleCommandKeySpec.fk.keynum.firstkey,,redismodule.h,firstkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1289,314245,keystep,3,RedisModuleCommandKeySpec.fk.keynum.keystep,,redismodule.h,keystep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1290,314246,keynum,3,RedisModuleCommandKeySpec.fk.keynum,,redismodule.h,keynum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1291,314247,fk,3,RedisModuleCommandKeySpec.fk,,redismodule.h,fk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1292,314250,version,3,RedisModuleCommandInfoVersion.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1293,314251,sizeof_historyentry,3,RedisModuleCommandInfoVersion.sizeof_historyentry,,redismodule.h,sizeof_historyentry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1294,314252,sizeof_keyspec,3,RedisModuleCommandInfoVersion.sizeof_keyspec,,redismodule.h,sizeof_keyspec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1295,314253,sizeof_arg,3,RedisModuleCommandInfoVersion.sizeof_arg,,redismodule.h,sizeof_arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1296,314279,version,3,RedisModuleCommandInfo.version,,redismodule.h,*version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1297,314280,summary,3,RedisModuleCommandInfo.summary,,redismodule.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1298,314281,complexity,3,RedisModuleCommandInfo.complexity,,redismodule.h,*complexity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1299,314282,since,3,RedisModuleCommandInfo.since,,redismodule.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1300,314283,history,3,RedisModuleCommandInfo.history,,redismodule.h,*history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1301,314284,tips,3,RedisModuleCommandInfo.tips,,redismodule.h,*tips,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1302,314285,arity,3,RedisModuleCommandInfo.arity,,redismodule.h,arity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1303,314286,key_specs,3,RedisModuleCommandInfo.key_specs,,redismodule.h,*key_specs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1304,314287,args,3,RedisModuleCommandInfo.args,,redismodule.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1305,314302,id,3,RedisModuleEvent.id,,redismodule.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1306,314303,dataver,3,RedisModuleEvent.dataver,,redismodule.h,dataver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1307,314460,version,3,RedisModuleClientInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1308,314461,flags,3,RedisModuleClientInfo.flags,,redismodule.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1309,314462,id,3,RedisModuleClientInfo.id,,redismodule.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1310,314463,addr,3,RedisModuleClientInfo.addr,,redismodule.h,addr[46],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1311,314464,port,3,RedisModuleClientInfo.port,,redismodule.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1312,314465,db,3,RedisModuleClientInfo.db,,redismodule.h,db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1313,314474,version,3,RedisModuleReplicationInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1314,314475,master,3,RedisModuleReplicationInfo.master,,redismodule.h,master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1315,314476,masterhost,3,RedisModuleReplicationInfo.masterhost,,redismodule.h,*masterhost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1316,314477,masterport,3,RedisModuleReplicationInfo.masterport,,redismodule.h,masterport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1317,314478,replid1,3,RedisModuleReplicationInfo.replid1,,redismodule.h,*replid1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1318,314479,replid2,3,RedisModuleReplicationInfo.replid2,,redismodule.h,*replid2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1319,314480,repl1_offset,3,RedisModuleReplicationInfo.repl1_offset,,redismodule.h,repl1_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1320,314481,repl2_offset,3,RedisModuleReplicationInfo.repl2_offset,,redismodule.h,repl2_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1321,314484,version,3,RedisModuleFlushInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1322,314485,sync,3,RedisModuleFlushInfo.sync,,redismodule.h,sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1323,314486,dbnum,3,RedisModuleFlushInfo.dbnum,,redismodule.h,dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1324,314489,version,3,RedisModuleModuleChange.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1325,314490,module_name,3,RedisModuleModuleChange.module_name,,redismodule.h,* module_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1326,314491,module_version,3,RedisModuleModuleChange.module_version,,redismodule.h,module_version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1327,314494,version,3,RedisModuleConfigChange.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1328,314495,num_changes,3,RedisModuleConfigChange.num_changes,,redismodule.h,num_changes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1329,314496,config_names,3,RedisModuleConfigChange.config_names,,redismodule.h,**config_names,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1330,314499,version,3,RedisModuleCronLoopInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1331,314500,hz,3,RedisModuleCronLoopInfo.hz,,redismodule.h,hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1332,314503,version,3,RedisModuleLoadingProgressInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1333,314504,hz,3,RedisModuleLoadingProgressInfo.hz,,redismodule.h,hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1334,314505,progress,3,RedisModuleLoadingProgressInfo.progress,,redismodule.h,progress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1335,314508,version,3,RedisModuleSwapDbInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1336,314509,dbnum_first,3,RedisModuleSwapDbInfo.dbnum_first,,redismodule.h,dbnum_first,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1337,314510,dbnum_second,3,RedisModuleSwapDbInfo.dbnum_second,,redismodule.h,dbnum_second,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1338,314513,version,3,RedisModuleKeyInfo.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1339,314514,key,3,RedisModuleKeyInfo.key,,redismodule.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1340,314517,REDISMODULE_ACL_LOG_AUTH,3,RedisModuleACLLogEntryReason.REDISMODULE_ACL_LOG_AUTH,,redismodule.h,REDISMODULE_ACL_LOG_AUTH = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1341,314518,REDISMODULE_ACL_LOG_CMD,3,RedisModuleACLLogEntryReason.REDISMODULE_ACL_LOG_CMD,,redismodule.h,REDISMODULE_ACL_LOG_CMD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1342,314519,REDISMODULE_ACL_LOG_KEY,3,RedisModuleACLLogEntryReason.REDISMODULE_ACL_LOG_KEY,,redismodule.h,REDISMODULE_ACL_LOG_KEY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1343,314520,REDISMODULE_ACL_LOG_CHANNEL,3,RedisModuleACLLogEntryReason.REDISMODULE_ACL_LOG_CHANNEL,,redismodule.h,REDISMODULE_ACL_LOG_CHANNEL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1344,314832,version,3,RedisModuleTypeMethods.version,,redismodule.h,version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1345,314833,rdb_load,3,RedisModuleTypeMethods.rdb_load,,redismodule.h,rdb_load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1346,314834,rdb_save,3,RedisModuleTypeMethods.rdb_save,,redismodule.h,rdb_save,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1347,314835,aof_rewrite,3,RedisModuleTypeMethods.aof_rewrite,,redismodule.h,aof_rewrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1348,314836,mem_usage,3,RedisModuleTypeMethods.mem_usage,,redismodule.h,mem_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1349,314837,digest,3,RedisModuleTypeMethods.digest,,redismodule.h,digest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1350,314838,free,3,RedisModuleTypeMethods.free,,redismodule.h,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1351,314839,aux_load,3,RedisModuleTypeMethods.aux_load,,redismodule.h,aux_load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1352,314840,aux_save,3,RedisModuleTypeMethods.aux_save,,redismodule.h,aux_save,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1353,314841,aux_save_triggers,3,RedisModuleTypeMethods.aux_save_triggers,,redismodule.h,aux_save_triggers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1354,314842,free_effort,3,RedisModuleTypeMethods.free_effort,,redismodule.h,free_effort,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1355,314843,unlink,3,RedisModuleTypeMethods.unlink,,redismodule.h,unlink,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1356,314844,copy,3,RedisModuleTypeMethods.copy,,redismodule.h,copy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1357,314845,defrag,3,RedisModuleTypeMethods.defrag,,redismodule.h,defrag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1358,314846,mem_usage2,3,RedisModuleTypeMethods.mem_usage2,,redismodule.h,mem_usage2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1359,314847,free_effort2,3,RedisModuleTypeMethods.free_effort2,,redismodule.h,free_effort2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1360,314848,unlink2,3,RedisModuleTypeMethods.unlink2,,redismodule.h,unlink2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1361,314849,copy2,3,RedisModuleTypeMethods.copy2,,redismodule.h,copy2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1362,314850,aux_save2,3,RedisModuleTypeMethods.aux_save2,,redismodule.h,aux_save2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1363,334362,curr_location,3,ReplyParser.curr_location,,resp_parser.h,*curr_location,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,42,0,1,1,0,0,,0,0,0,0,0,
1364,334363,callbacks,3,ReplyParser.callbacks,,resp_parser.h,callbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
1365,336197,cksum,3,_rio.cksum,,rio.h,cksum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1366,336198,flags,3,_rio.flags,,rio.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1367,336199,processed_bytes,3,_rio.processed_bytes,,rio.h,processed_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1368,336200,max_processing_chunk,3,_rio.max_processing_chunk,,rio.h,max_processing_chunk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1369,336203,ptr,3,_rio.io.buffer.ptr,,rio.h,ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1370,336204,pos,3,_rio.io.buffer.pos,,rio.h,pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1371,336205,buffer,3,_rio.io.buffer,,rio.h,buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1372,336207,fp,3,_rio.io.file.fp,,rio.h,*fp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1373,336208,buffered,3,_rio.io.file.buffered,,rio.h,buffered,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1374,336209,autosync,3,_rio.io.file.autosync,,rio.h,autosync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1375,336210,reclaim_cache,3,_rio.io.file.reclaim_cache,,rio.h,reclaim_cache:1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1376,336211,file,3,_rio.io.file,,rio.h,file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1377,336213,conn,3,_rio.io.conn.conn,,rio.h,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1378,336214,pos,3,_rio.io.conn.pos,,rio.h,pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1379,336215,buf,3,_rio.io.conn.buf,,rio.h,buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1380,336216,read_limit,3,_rio.io.conn.read_limit,,rio.h,read_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1381,336217,read_so_far,3,_rio.io.conn.read_so_far,,rio.h,read_so_far,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1382,336218,conn,3,_rio.io.conn,,rio.h,conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1383,336220,fd,3,_rio.io.fd.fd,,rio.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1384,336221,pos,3,_rio.io.fd.pos,,rio.h,pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1385,336222,buf,3,_rio.io.fd.buf,,rio.h,buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1386,336223,fd,3,_rio.io.fd,,rio.h,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1387,336224,io,3,_rio.io,,rio.h,io,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1388,338606,funcname,3,scriptRunCtx.funcname,,script.h,*funcname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1389,338607,c,3,scriptRunCtx.c,,script.h,*c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1390,338608,original_client,3,scriptRunCtx.original_client,,script.h,*original_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1391,338609,flags,3,scriptRunCtx.flags,,script.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1392,338610,repl_flags,3,scriptRunCtx.repl_flags,,script.h,repl_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1393,338611,start_time,3,scriptRunCtx.start_time,,script.h,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1394,338613,flag,3,scriptFlag.flag,,script.h,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1395,338614,str,3,scriptFlag.str,,script.h,*str,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1396,343372,msg,3,errorInfo.msg,,script_lua.h,msg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1397,343373,source,3,errorInfo.source,,script_lua.h,source,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1398,343374,line,3,errorInfo.line,,script_lua.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1399,343375,ignore_err_stats_update,3,errorInfo.ignore_err_stats_update,,script_lua.h,ignore_err_stats_update,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1400,346968,flags,3,sdshdr5.flags,,sds.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1401,346969,buf,3,sdshdr5.buf,,sds.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1402,346976,len,3,sdshdr8.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1403,346977,alloc,3,sdshdr8.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1404,346978,flags,3,sdshdr8.flags,,sds.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1405,346979,buf,3,sdshdr8.buf,,sds.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1406,346986,len,3,sdshdr16.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1407,346987,alloc,3,sdshdr16.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1408,346988,flags,3,sdshdr16.flags,,sds.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1409,346989,buf,3,sdshdr16.buf,,sds.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1410,346996,len,3,sdshdr32.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1411,346997,alloc,3,sdshdr32.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1412,346998,flags,3,sdshdr32.flags,,sds.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1413,346999,buf,3,sdshdr32.buf,,sds.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1414,347006,len,3,sdshdr64.len,,sds.h,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1415,347007,alloc,3,sdshdr64.alloc,,sds.h,alloc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1416,347008,flags,3,sdshdr64.flags,,sds.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1417,347009,buf,3,sdshdr64.buf,,sds.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1418,347979,hostname,3,sentinelAddr.hostname,,sentinel.c,*hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1419,347980,ip,3,sentinelAddr.ip,,sentinel.c,*ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1420,347981,port,3,sentinelAddr.port,,sentinel.c,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1421,348046,refcount,3,instanceLink.refcount,,sentinel.c,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1422,348047,disconnected,3,instanceLink.disconnected,,sentinel.c,disconnected,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1423,348048,pending_commands,3,instanceLink.pending_commands,,sentinel.c,pending_commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1424,348049,cc,3,instanceLink.cc,,sentinel.c,*cc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1425,348050,pc,3,instanceLink.pc,,sentinel.c,*pc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1426,348051,cc_conn_time,3,instanceLink.cc_conn_time,,sentinel.c,cc_conn_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1427,348052,pc_conn_time,3,instanceLink.pc_conn_time,,sentinel.c,pc_conn_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1428,348053,pc_last_activity,3,instanceLink.pc_last_activity,,sentinel.c,pc_last_activity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1429,348054,last_avail_time,3,instanceLink.last_avail_time,,sentinel.c,last_avail_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1430,348055,act_ping_time,3,instanceLink.act_ping_time,,sentinel.c,act_ping_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1431,348056,last_ping_time,3,instanceLink.last_ping_time,,sentinel.c,last_ping_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1432,348057,last_pong_time,3,instanceLink.last_pong_time,,sentinel.c,last_pong_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1433,348058,last_reconn_time,3,instanceLink.last_reconn_time,,sentinel.c,last_reconn_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1434,348061,flags,3,sentinelRedisInstance.flags,,sentinel.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,88,0,1,1,0,0,,0,0,0,0,0,
1435,348062,name,3,sentinelRedisInstance.name,,sentinel.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1436,348063,runid,3,sentinelRedisInstance.runid,,sentinel.c,*runid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1437,348064,config_epoch,3,sentinelRedisInstance.config_epoch,,sentinel.c,config_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1438,348065,addr,3,sentinelRedisInstance.addr,,sentinel.c,*addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,38,0,1,1,0,0,,0,0,0,0,0,
1439,348066,link,3,sentinelRedisInstance.link,,sentinel.c,*link,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,76,0,1,1,0,0,,0,0,0,0,0,
1440,348067,last_pub_time,3,sentinelRedisInstance.last_pub_time,,sentinel.c,last_pub_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1441,348068,last_hello_time,3,sentinelRedisInstance.last_hello_time,,sentinel.c,last_hello_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1442,348069,last_master_down_reply_time,3,sentinelRedisInstance.last_master_down_reply_time,,sentinel.c,last_master_down_reply_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1443,348070,s_down_since_time,3,sentinelRedisInstance.s_down_since_time,,sentinel.c,s_down_since_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1444,348071,o_down_since_time,3,sentinelRedisInstance.o_down_since_time,,sentinel.c,o_down_since_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1445,348072,down_after_period,3,sentinelRedisInstance.down_after_period,,sentinel.c,down_after_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1446,348073,master_reboot_down_after_period,3,sentinelRedisInstance.master_reboot_down_after_period,,sentinel.c,master_reboot_down_after_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1447,348074,master_reboot_since_time,3,sentinelRedisInstance.master_reboot_since_time,,sentinel.c,master_reboot_since_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1448,348075,info_refresh,3,sentinelRedisInstance.info_refresh,,sentinel.c,info_refresh,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1449,348076,renamed_commands,3,sentinelRedisInstance.renamed_commands,,sentinel.c,*renamed_commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1450,348077,role_reported,3,sentinelRedisInstance.role_reported,,sentinel.c,role_reported,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1451,348078,role_reported_time,3,sentinelRedisInstance.role_reported_time,,sentinel.c,role_reported_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1452,348079,slave_conf_change_time,3,sentinelRedisInstance.slave_conf_change_time,,sentinel.c,slave_conf_change_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1453,348080,sentinels,3,sentinelRedisInstance.sentinels,,sentinel.c,*sentinels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
1454,348081,slaves,3,sentinelRedisInstance.slaves,,sentinel.c,*slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
1455,348082,quorum,3,sentinelRedisInstance.quorum,,sentinel.c,quorum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1456,348083,parallel_syncs,3,sentinelRedisInstance.parallel_syncs,,sentinel.c,parallel_syncs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1457,348084,auth_pass,3,sentinelRedisInstance.auth_pass,,sentinel.c,*auth_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1458,348085,auth_user,3,sentinelRedisInstance.auth_user,,sentinel.c,*auth_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1459,348086,master_link_down_time,3,sentinelRedisInstance.master_link_down_time,,sentinel.c,master_link_down_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1460,348087,slave_priority,3,sentinelRedisInstance.slave_priority,,sentinel.c,slave_priority,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1461,348088,replica_announced,3,sentinelRedisInstance.replica_announced,,sentinel.c,replica_announced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1462,348089,slave_reconf_sent_time,3,sentinelRedisInstance.slave_reconf_sent_time,,sentinel.c,slave_reconf_sent_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1463,348091,master,3,sentinelRedisInstance.master,,sentinel.c,*master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
1464,348092,slave_master_host,3,sentinelRedisInstance.slave_master_host,,sentinel.c,*slave_master_host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1465,348093,slave_master_port,3,sentinelRedisInstance.slave_master_port,,sentinel.c,slave_master_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1466,348094,slave_master_link_status,3,sentinelRedisInstance.slave_master_link_status,,sentinel.c,slave_master_link_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1467,348095,slave_repl_offset,3,sentinelRedisInstance.slave_repl_offset,,sentinel.c,slave_repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1468,348096,leader,3,sentinelRedisInstance.leader,,sentinel.c,*leader,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1469,348097,leader_epoch,3,sentinelRedisInstance.leader_epoch,,sentinel.c,leader_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1470,348098,failover_epoch,3,sentinelRedisInstance.failover_epoch,,sentinel.c,failover_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1471,348099,failover_state,3,sentinelRedisInstance.failover_state,,sentinel.c,failover_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1472,348100,failover_state_change_time,3,sentinelRedisInstance.failover_state_change_time,,sentinel.c,failover_state_change_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1473,348101,failover_start_time,3,sentinelRedisInstance.failover_start_time,,sentinel.c,failover_start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1474,348102,failover_timeout,3,sentinelRedisInstance.failover_timeout,,sentinel.c,failover_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1475,348103,failover_delay_logged,3,sentinelRedisInstance.failover_delay_logged,,sentinel.c,failover_delay_logged,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1476,348105,promoted_slave,3,sentinelRedisInstance.promoted_slave,,sentinel.c,*promoted_slave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1477,348106,notification_script,3,sentinelRedisInstance.notification_script,,sentinel.c,*notification_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1478,348107,client_reconfig_script,3,sentinelRedisInstance.client_reconfig_script,,sentinel.c,*client_reconfig_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1479,348108,info,3,sentinelRedisInstance.info,,sentinel.c,info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1480,348111,myid,3,sentinelState.myid,,sentinel.c,myid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1481,348112,current_epoch,3,sentinelState.current_epoch,,sentinel.c,current_epoch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1482,348113,masters,3,sentinelState.masters,,sentinel.c,*masters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1483,348114,tilt,3,sentinelState.tilt,,sentinel.c,tilt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1484,348115,running_scripts,3,sentinelState.running_scripts,,sentinel.c,running_scripts,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1485,348116,tilt_start_time,3,sentinelState.tilt_start_time,,sentinel.c,tilt_start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1486,348117,previous_time,3,sentinelState.previous_time,,sentinel.c,previous_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1487,348118,scripts_queue,3,sentinelState.scripts_queue,,sentinel.c,*scripts_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1488,348119,announce_ip,3,sentinelState.announce_ip,,sentinel.c,*announce_ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1489,348120,announce_port,3,sentinelState.announce_port,,sentinel.c,announce_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1490,348121,simfailure_flags,3,sentinelState.simfailure_flags,,sentinel.c,simfailure_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1491,348122,deny_scripts_reconfig,3,sentinelState.deny_scripts_reconfig,,sentinel.c,deny_scripts_reconfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1492,348123,sentinel_auth_pass,3,sentinelState.sentinel_auth_pass,,sentinel.c,*sentinel_auth_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1493,348124,sentinel_auth_user,3,sentinelState.sentinel_auth_user,,sentinel.c,*sentinel_auth_user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1494,348125,resolve_hostnames,3,sentinelState.resolve_hostnames,,sentinel.c,resolve_hostnames,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1495,348126,announce_hostnames,3,sentinelState.announce_hostnames,,sentinel.c,announce_hostnames,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1496,348139,flags,3,sentinelScriptJob.flags,,sentinel.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1497,348140,retry_num,3,sentinelScriptJob.retry_num,,sentinel.c,retry_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1498,348141,argv,3,sentinelScriptJob.argv,,sentinel.c,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1499,348142,start_time,3,sentinelScriptJob.start_time,,sentinel.c,start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1500,348143,pid,3,sentinelScriptJob.pid,,sentinel.c,pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1501,348146,context,3,redisAeEvents.context,,sentinel.c,*context,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1502,348147,loop,3,redisAeEvents.loop,,sentinel.c,*loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1503,348148,fd,3,redisAeEvents.fd,,sentinel.c,fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1504,348149,reading,3,redisAeEvents.reading,,sentinel.c,reading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1505,348150,writing,3,redisAeEvents.writing,,sentinel.c,writing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1506,364402,runid,3,sentinelLeader.runid,,sentinel.c,*runid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1507,364403,votes,3,sentinelLeader.votes,,sentinel.c,votes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1508,382005,flag,3,replyFlagNames.flag,,server.c,flag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1509,382006,name,3,replyFlagNames.name,,server.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1510,383918,COMMAND_LIST_FILTER_MODULE,3,commandListFilterType.COMMAND_LIST_FILTER_MODULE,,server.c,COMMAND_LIST_FILTER_MODULE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1511,383919,COMMAND_LIST_FILTER_ACLCAT,3,commandListFilterType.COMMAND_LIST_FILTER_ACLCAT,,server.c,COMMAND_LIST_FILTER_ACLCAT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1512,383920,COMMAND_LIST_FILTER_PATTERN,3,commandListFilterType.COMMAND_LIST_FILTER_PATTERN,,server.c,COMMAND_LIST_FILTER_PATTERN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1513,383923,type,3,commandListFilter.type,,server.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1514,383924,arg,3,commandListFilter.arg,,server.c,arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1515,383926,valid,3,commandListFilter.cache.valid,,server.c,valid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1516,383928,aclcat,3,commandListFilter.cache.u.aclcat,,server.c,aclcat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1517,383929,module_handle,3,commandListFilter.cache.u.module_handle,,server.c,*module_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1518,383930,u,3,commandListFilter.cache.u,,server.c,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1519,383931,cache,3,commandListFilter.cache,,server.c,cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1520,390935,BLOCKED_NONE,3,blocking_type.BLOCKED_NONE,,server.h,BLOCKED_NONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1521,390936,BLOCKED_LIST,3,blocking_type.BLOCKED_LIST,,server.h,BLOCKED_LIST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1522,390937,BLOCKED_WAIT,3,blocking_type.BLOCKED_WAIT,,server.h,BLOCKED_WAIT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1523,390938,BLOCKED_WAITAOF,3,blocking_type.BLOCKED_WAITAOF,,server.h,BLOCKED_WAITAOF,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1524,390939,BLOCKED_MODULE,3,blocking_type.BLOCKED_MODULE,,server.h,BLOCKED_MODULE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1525,390940,BLOCKED_STREAM,3,blocking_type.BLOCKED_STREAM,,server.h,BLOCKED_STREAM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1526,390941,BLOCKED_ZSET,3,blocking_type.BLOCKED_ZSET,,server.h,BLOCKED_ZSET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1527,390942,BLOCKED_POSTPONE,3,blocking_type.BLOCKED_POSTPONE,,server.h,BLOCKED_POSTPONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1528,390943,BLOCKED_SHUTDOWN,3,blocking_type.BLOCKED_SHUTDOWN,,server.h,BLOCKED_SHUTDOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1529,390944,BLOCKED_NUM,3,blocking_type.BLOCKED_NUM,,server.h,BLOCKED_NUM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1530,390945,BLOCKED_END,3,blocking_type.BLOCKED_END,,server.h,BLOCKED_END,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1531,390948,REPL_STATE_NONE,3,repl_state.REPL_STATE_NONE,,server.h,REPL_STATE_NONE = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1532,390949,REPL_STATE_CONNECT,3,repl_state.REPL_STATE_CONNECT,,server.h,REPL_STATE_CONNECT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1533,390950,REPL_STATE_CONNECTING,3,repl_state.REPL_STATE_CONNECTING,,server.h,REPL_STATE_CONNECTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1534,390951,REPL_STATE_RECEIVE_PING_REPLY,3,repl_state.REPL_STATE_RECEIVE_PING_REPLY,,server.h,REPL_STATE_RECEIVE_PING_REPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1535,390952,REPL_STATE_SEND_HANDSHAKE,3,repl_state.REPL_STATE_SEND_HANDSHAKE,,server.h,REPL_STATE_SEND_HANDSHAKE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1536,390953,REPL_STATE_RECEIVE_AUTH_REPLY,3,repl_state.REPL_STATE_RECEIVE_AUTH_REPLY,,server.h,REPL_STATE_RECEIVE_AUTH_REPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1537,390954,REPL_STATE_RECEIVE_PORT_REPLY,3,repl_state.REPL_STATE_RECEIVE_PORT_REPLY,,server.h,REPL_STATE_RECEIVE_PORT_REPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1538,390955,REPL_STATE_RECEIVE_IP_REPLY,3,repl_state.REPL_STATE_RECEIVE_IP_REPLY,,server.h,REPL_STATE_RECEIVE_IP_REPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1539,390956,REPL_STATE_RECEIVE_CAPA_REPLY,3,repl_state.REPL_STATE_RECEIVE_CAPA_REPLY,,server.h,REPL_STATE_RECEIVE_CAPA_REPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1540,390957,REPL_STATE_SEND_PSYNC,3,repl_state.REPL_STATE_SEND_PSYNC,,server.h,REPL_STATE_SEND_PSYNC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1541,390958,REPL_STATE_RECEIVE_PSYNC_REPLY,3,repl_state.REPL_STATE_RECEIVE_PSYNC_REPLY,,server.h,REPL_STATE_RECEIVE_PSYNC_REPLY,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1542,390959,REPL_STATE_TRANSFER,3,repl_state.REPL_STATE_TRANSFER,,server.h,REPL_STATE_TRANSFER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1543,390960,REPL_STATE_CONNECTED,3,repl_state.REPL_STATE_CONNECTED,,server.h,REPL_STATE_CONNECTED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1544,390970,NO_FAILOVER,3,failover_state.NO_FAILOVER,,server.h,NO_FAILOVER = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1545,390971,FAILOVER_WAIT_FOR_SYNC,3,failover_state.FAILOVER_WAIT_FOR_SYNC,,server.h,FAILOVER_WAIT_FOR_SYNC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1546,390972,FAILOVER_IN_PROGRESS,3,failover_state.FAILOVER_IN_PROGRESS,,server.h,FAILOVER_IN_PROGRESS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1547,390982,PAUSE_BY_CLIENT_COMMAND,3,pause_purpose.PAUSE_BY_CLIENT_COMMAND,,server.h,PAUSE_BY_CLIENT_COMMAND = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1548,390983,PAUSE_DURING_SHUTDOWN,3,pause_purpose.PAUSE_DURING_SHUTDOWN,,server.h,PAUSE_DURING_SHUTDOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1549,390984,PAUSE_DURING_FAILOVER,3,pause_purpose.PAUSE_DURING_FAILOVER,,server.h,PAUSE_DURING_FAILOVER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1550,390985,NUM_PAUSE_PURPOSES,3,pause_purpose.NUM_PAUSE_PURPOSES,,server.h,NUM_PAUSE_PURPOSES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1551,390995,paused_actions,3,pause_event.paused_actions,,server.h,paused_actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1552,390996,end,3,pause_event.end,,server.h,end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1553,390999,CLUSTER_ENDPOINT_TYPE_IP,3,cluster_endpoint_type.CLUSTER_ENDPOINT_TYPE_IP,,server.h,CLUSTER_ENDPOINT_TYPE_IP = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1554,391000,CLUSTER_ENDPOINT_TYPE_HOSTNAME,3,cluster_endpoint_type.CLUSTER_ENDPOINT_TYPE_HOSTNAME,,server.h,CLUSTER_ENDPOINT_TYPE_HOSTNAME,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1555,391001,CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT,3,cluster_endpoint_type.CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT,,server.h,CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1556,391131,id,3,RedisModuleType.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1557,391133,module,3,RedisModuleType.module,,server.h,*module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1558,391134,rdb_load,3,RedisModuleType.rdb_load,,server.h,rdb_load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1559,391135,rdb_save,3,RedisModuleType.rdb_save,,server.h,rdb_save,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1560,391136,aof_rewrite,3,RedisModuleType.aof_rewrite,,server.h,aof_rewrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1561,391137,mem_usage,3,RedisModuleType.mem_usage,,server.h,mem_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1562,391138,digest,3,RedisModuleType.digest,,server.h,digest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1563,391139,free,3,RedisModuleType.free,,server.h,free,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1564,391140,free_effort,3,RedisModuleType.free_effort,,server.h,free_effort,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1565,391141,unlink,3,RedisModuleType.unlink,,server.h,unlink,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1566,391142,copy,3,RedisModuleType.copy,,server.h,copy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1567,391143,defrag,3,RedisModuleType.defrag,,server.h,defrag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1568,391144,aux_load,3,RedisModuleType.aux_load,,server.h,aux_load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1569,391145,aux_save,3,RedisModuleType.aux_save,,server.h,aux_save,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1570,391146,mem_usage2,3,RedisModuleType.mem_usage2,,server.h,mem_usage2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1571,391147,free_effort2,3,RedisModuleType.free_effort2,,server.h,free_effort2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1572,391148,unlink2,3,RedisModuleType.unlink2,,server.h,unlink2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1573,391149,copy2,3,RedisModuleType.copy2,,server.h,copy2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1574,391150,aux_save2,3,RedisModuleType.aux_save2,,server.h,aux_save2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1575,391151,aux_save_triggers,3,RedisModuleType.aux_save_triggers,,server.h,aux_save_triggers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1576,391152,name,3,RedisModuleType.name,,server.h,name[10],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1577,391161,type,3,moduleValue.type,,server.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1578,391162,value,3,moduleValue.value,,server.h,*value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1579,391165,handle,3,RedisModule.handle,,server.h,*handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1580,391166,name,3,RedisModule.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1581,391167,ver,3,RedisModule.ver,,server.h,ver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1582,391168,apiver,3,RedisModule.apiver,,server.h,apiver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1583,391169,types,3,RedisModule.types,,server.h,*types,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1584,391170,usedby,3,RedisModule.usedby,,server.h,*usedby,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1585,391171,using,3,RedisModule.using,,server.h,*using,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1586,391172,filters,3,RedisModule.filters,,server.h,*filters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1587,391173,module_configs,3,RedisModule.module_configs,,server.h,*module_configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1588,391174,configs_initialized,3,RedisModule.configs_initialized,,server.h,configs_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1589,391175,in_call,3,RedisModule.in_call,,server.h,in_call,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1590,391176,in_hook,3,RedisModule.in_hook,,server.h,in_hook,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1591,391177,options,3,RedisModule.options,,server.h,options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1592,391178,blocked_clients,3,RedisModule.blocked_clients,,server.h,blocked_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1593,391179,info_cb,3,RedisModule.info_cb,,server.h,info_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1594,391180,defrag_cb,3,RedisModule.defrag_cb,,server.h,defrag_cb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1595,391182,loadmod,3,RedisModule.loadmod,,server.h,*loadmod,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1596,391183,num_commands_with_acl_categories,3,RedisModule.num_commands_with_acl_categories,,server.h,num_commands_with_acl_categories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1597,391184,onload,3,RedisModule.onload,,server.h,onload,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1598,391188,bytes,3,RedisModuleIO.bytes,,server.h,bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1599,391189,rio,3,RedisModuleIO.rio,,server.h,*rio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
1600,391190,type,3,RedisModuleIO.type,,server.h,*type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1601,391191,error,3,RedisModuleIO.error,,server.h,error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
1602,391193,ctx,3,RedisModuleIO.ctx,,server.h,*ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
1603,391195,key,3,RedisModuleIO.key,,server.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1604,391196,dbid,3,RedisModuleIO.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1605,391197,pre_flush_buffer,3,RedisModuleIO.pre_flush_buffer,,server.h,pre_flush_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1606,391199,o,3,RedisModuleDigest.o,,server.h,o[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1607,391200,x,3,RedisModuleDigest.x,,server.h,x[20],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1608,391202,key,3,RedisModuleDigest.key,,server.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1609,391203,dbid,3,RedisModuleDigest.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1610,391213,type,3,redisObject.type,,server.h,type:4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1611,391214,encoding,3,redisObject.encoding,,server.h,encoding:4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1612,391215,lru,3,redisObject.lru,,server.h,lru:LRU_BITS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1613,391216,refcount,3,redisObject.refcount,,server.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1614,391217,ptr,3,redisObject.ptr,,server.h,*ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1615,391225,size,3,clientReplyBlock.size,,server.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1616,391226,used,3,clientReplyBlock.used,,server.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
1617,391227,buf,3,clientReplyBlock.buf,,server.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1618,391235,refcount,3,replBufBlock.refcount,,server.h,refcount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1619,391236,id,3,replBufBlock.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1620,391237,repl_offset,3,replBufBlock.repl_offset,,server.h,repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1621,391238,size,3,replBufBlock.size,,server.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1622,391239,used,3,replBufBlock.used,,server.h,used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1623,391240,buf,3,replBufBlock.buf,,server.h,buf[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1624,391250,dict,3,redisDb.dict,,server.h,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,60,0,1,1,0,0,,0,0,0,0,0,
1625,391251,expires,3,redisDb.expires,,server.h,*expires,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
1626,391252,blocking_keys,3,redisDb.blocking_keys,,server.h,*blocking_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1627,391253,blocking_keys_unblock_on_nokey,3,redisDb.blocking_keys_unblock_on_nokey,,server.h,*blocking_keys_unblock_on_nokey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1628,391254,ready_keys,3,redisDb.ready_keys,,server.h,*ready_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1629,391255,watched_keys,3,redisDb.watched_keys,,server.h,*watched_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1630,391256,id,3,redisDb.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1631,391257,avg_ttl,3,redisDb.avg_ttl,,server.h,avg_ttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1632,391258,expires_cursor,3,redisDb.expires_cursor,,server.h,expires_cursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1633,391259,defrag_later,3,redisDb.defrag_later,,server.h,*defrag_later,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1634,391260,slots_to_keys,3,redisDb.slots_to_keys,,server.h,*slots_to_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1635,391265,dbarray,3,rdbLoadingCtx.dbarray,,server.h,* dbarray,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1636,391266,functions_lib_ctx,3,rdbLoadingCtx.functions_lib_ctx,,server.h,* functions_lib_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1637,391269,argv,3,multiCmd.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1638,391270,argv_len,3,multiCmd.argv_len,,server.h,argv_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1639,391271,argc,3,multiCmd.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1640,391273,cmd,3,multiCmd.cmd,,server.h,*cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1641,391276,commands,3,multiState.commands,,server.h,*commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1642,391277,count,3,multiState.count,,server.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1643,391278,cmd_flags,3,multiState.cmd_flags,,server.h,cmd_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1644,391279,cmd_inv_flags,3,multiState.cmd_inv_flags,,server.h,cmd_inv_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1645,391280,argv_len_sums,3,multiState.argv_len_sums,,server.h,argv_len_sums,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1646,391281,alloc_count,3,multiState.alloc_count,,server.h,alloc_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1647,391284,btype,3,blockingState.btype,,server.h,btype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1648,391285,timeout,3,blockingState.timeout,,server.h,timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1649,391286,unblock_on_nokey,3,blockingState.unblock_on_nokey,,server.h,unblock_on_nokey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1650,391287,keys,3,blockingState.keys,,server.h,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1651,391288,numreplicas,3,blockingState.numreplicas,,server.h,numreplicas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1652,391289,numlocal,3,blockingState.numlocal,,server.h,numlocal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1653,391290,reploffset,3,blockingState.reploffset,,server.h,reploffset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1654,391291,module_blocked_handle,3,blockingState.module_blocked_handle,,server.h,*module_blocked_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1655,391292,async_rm_call_handle,3,blockingState.async_rm_call_handle,,server.h,*async_rm_call_handle,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1656,391295,db,3,readyList.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1657,391296,key,3,readyList.key,,server.h,*key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1658,391299,name,3,user.name,,server.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1659,391300,flags,3,user.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1660,391301,passwords,3,user.passwords,,server.h,*passwords,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1661,391302,selectors,3,user.selectors,,server.h,*selectors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
1662,391303,acl_string,3,user.acl_string,,server.h,*acl_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
1663,391306,ref_repl_buf_node,3,replBacklog.ref_repl_buf_node,,server.h,*ref_repl_buf_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1664,391307,unindexed_count,3,replBacklog.unindexed_count,,server.h,unindexed_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1665,391308,blocks_index,3,replBacklog.blocks_index,,server.h,*blocks_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1666,391309,histlen,3,replBacklog.histlen,,server.h,histlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1667,391310,offset,3,replBacklog.offset,,server.h,offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1668,391313,clients,3,clientMemUsageBucket.clients,,server.h,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1669,391314,mem_usage_sum,3,clientMemUsageBucket.mem_usage_sum,,server.h,mem_usage_sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1670,391317,id,3,client.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1671,391318,flags,3,client.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,281,0,1,1,0,0,,0,0,0,0,0,
1672,391319,conn,3,client.conn,,server.h,*conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,49,0,1,1,0,0,,0,0,0,0,0,
1673,391320,resp,3,client.resp,,server.h,resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,57,0,1,1,0,0,,0,0,0,0,0,
1674,391321,db,3,client.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,166,0,1,1,0,0,,0,0,0,0,0,
1675,391322,name,3,client.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
1676,391323,lib_name,3,client.lib_name,,server.h,*lib_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1677,391324,lib_ver,3,client.lib_ver,,server.h,*lib_ver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1678,391325,querybuf,3,client.querybuf,,server.h,querybuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,58,0,1,1,0,0,,0,0,0,0,0,
1679,391326,qb_pos,3,client.qb_pos,,server.h,qb_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
1680,391327,querybuf_peak,3,client.querybuf_peak,,server.h,querybuf_peak,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1681,391328,argc,3,client.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,208,0,1,1,0,0,,0,0,0,0,0,
1682,391329,argv,3,client.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,382,0,1,1,0,0,,0,0,0,0,0,
1683,391330,argv_len,3,client.argv_len,,server.h,argv_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
1684,391331,original_argc,3,client.original_argc,,server.h,original_argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1685,391332,original_argv,3,client.original_argv,,server.h,**original_argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1686,391333,argv_len_sum,3,client.argv_len_sum,,server.h,argv_len_sum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1687,391335,cmd,3,client.cmd,,server.h,*cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,101,0,1,1,0,0,,0,0,0,0,0,
1688,391336,lastcmd,3,client.lastcmd,,server.h,*lastcmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
1689,391338,realcmd,3,client.realcmd,,server.h,*realcmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1690,391339,user,3,client.user,,server.h,*user,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
1691,391340,reqtype,3,client.reqtype,,server.h,reqtype,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1692,391341,multibulklen,3,client.multibulklen,,server.h,multibulklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1693,391342,bulklen,3,client.bulklen,,server.h,bulklen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1694,391343,reply,3,client.reply,,server.h,*reply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,50,0,1,1,0,0,,0,0,0,0,0,
1695,391344,reply_bytes,3,client.reply_bytes,,server.h,reply_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
1696,391345,deferred_reply_errors,3,client.deferred_reply_errors,,server.h,*deferred_reply_errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1697,391346,sentlen,3,client.sentlen,,server.h,sentlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1698,391347,ctime,3,client.ctime,,server.h,ctime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1699,391348,duration,3,client.duration,,server.h,duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1700,391349,slot,3,client.slot,,server.h,slot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1701,391350,cur_script,3,client.cur_script,,server.h,*cur_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
1702,391351,lastinteraction,3,client.lastinteraction,,server.h,lastinteraction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1703,391352,obuf_soft_limit_reached_time,3,client.obuf_soft_limit_reached_time,,server.h,obuf_soft_limit_reached_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1704,391353,authenticated,3,client.authenticated,,server.h,authenticated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1705,391354,replstate,3,client.replstate,,server.h,replstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
1706,391355,repl_start_cmd_stream_on_ack,3,client.repl_start_cmd_stream_on_ack,,server.h,repl_start_cmd_stream_on_ack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1707,391356,repldbfd,3,client.repldbfd,,server.h,repldbfd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1708,391357,repldboff,3,client.repldboff,,server.h,repldboff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1709,391358,repldbsize,3,client.repldbsize,,server.h,repldbsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1710,391359,replpreamble,3,client.replpreamble,,server.h,replpreamble,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1711,391360,read_reploff,3,client.read_reploff,,server.h,read_reploff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1712,391361,reploff,3,client.reploff,,server.h,reploff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1713,391362,repl_applied,3,client.repl_applied,,server.h,repl_applied,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1714,391363,repl_ack_off,3,client.repl_ack_off,,server.h,repl_ack_off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1715,391364,repl_aof_off,3,client.repl_aof_off,,server.h,repl_aof_off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1716,391365,repl_ack_time,3,client.repl_ack_time,,server.h,repl_ack_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1717,391366,repl_last_partial_write,3,client.repl_last_partial_write,,server.h,repl_last_partial_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1718,391367,psync_initial_offset,3,client.psync_initial_offset,,server.h,psync_initial_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1719,391368,replid,3,client.replid,,server.h,replid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1720,391369,slave_listening_port,3,client.slave_listening_port,,server.h,slave_listening_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1721,391370,slave_addr,3,client.slave_addr,,server.h,*slave_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1722,391371,slave_capa,3,client.slave_capa,,server.h,slave_capa,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1723,391372,slave_req,3,client.slave_req,,server.h,slave_req,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1724,391373,mstate,3,client.mstate,,server.h,mstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,49,0,1,1,0,0,,0,0,0,0,0,
1725,391374,bstate,3,client.bstate,,server.h,bstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,65,0,1,1,0,0,,0,0,0,0,0,
1726,391375,woff,3,client.woff,,server.h,woff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1727,391376,watched_keys,3,client.watched_keys,,server.h,*watched_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1728,391377,pubsub_channels,3,client.pubsub_channels,,server.h,*pubsub_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1729,391378,pubsub_patterns,3,client.pubsub_patterns,,server.h,*pubsub_patterns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1730,391379,pubsubshard_channels,3,client.pubsubshard_channels,,server.h,*pubsubshard_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1731,391380,peerid,3,client.peerid,,server.h,peerid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1732,391381,sockname,3,client.sockname,,server.h,sockname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1733,391382,client_list_node,3,client.client_list_node,,server.h,*client_list_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1734,391383,postponed_list_node,3,client.postponed_list_node,,server.h,*postponed_list_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1735,391384,pending_read_list_node,3,client.pending_read_list_node,,server.h,*pending_read_list_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1736,391385,module_blocked_client,3,client.module_blocked_client,,server.h,*module_blocked_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1737,391386,module_auth_ctx,3,client.module_auth_ctx,,server.h,*module_auth_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1738,391387,auth_callback,3,client.auth_callback,,server.h,auth_callback,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1739,391388,auth_callback_privdata,3,client.auth_callback_privdata,,server.h,*auth_callback_privdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1740,391389,auth_module,3,client.auth_module,,server.h,*auth_module,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1741,391390,client_tracking_redirection,3,client.client_tracking_redirection,,server.h,client_tracking_redirection,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1742,391391,client_tracking_prefixes,3,client.client_tracking_prefixes,,server.h,*client_tracking_prefixes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1743,391392,last_memory_usage,3,client.last_memory_usage,,server.h,last_memory_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1744,391393,last_memory_type,3,client.last_memory_type,,server.h,last_memory_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1745,391394,mem_usage_bucket_node,3,client.mem_usage_bucket_node,,server.h,*mem_usage_bucket_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1746,391395,mem_usage_bucket,3,client.mem_usage_bucket,,server.h,*mem_usage_bucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1747,391396,ref_repl_buf_node,3,client.ref_repl_buf_node,,server.h,*ref_repl_buf_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1748,391397,ref_block_pos,3,client.ref_block_pos,,server.h,ref_block_pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
1749,391398,clients_pending_write_node,3,client.clients_pending_write_node,,server.h,clients_pending_write_node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1750,391399,buf_peak,3,client.buf_peak,,server.h,buf_peak,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1751,391400,buf_peak_last_reset_time,3,client.buf_peak_last_reset_time,,server.h,buf_peak_last_reset_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1752,391401,bufpos,3,client.bufpos,,server.h,bufpos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
1753,391402,buf_usable_size,3,client.buf_usable_size,,server.h,buf_usable_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1754,391403,buf,3,client.buf,,server.h,*buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1755,391404,reqres,3,client.reqres,,server.h,reqres,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1756,391417,user_auth_failures,3,aclInfo.user_auth_failures,,server.h,user_auth_failures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1757,391418,invalid_cmd_accesses,3,aclInfo.invalid_cmd_accesses,,server.h,invalid_cmd_accesses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1758,391419,invalid_key_accesses,3,aclInfo.invalid_key_accesses,,server.h,invalid_key_accesses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1759,391420,invalid_channel_accesses,3,aclInfo.invalid_channel_accesses,,server.h,invalid_channel_accesses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1760,391423,seconds,3,saveparam.seconds,,server.h,seconds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1761,391424,changes,3,saveparam.changes,,server.h,changes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1762,391426,path,3,moduleLoadQueueEntry.path,,server.h,path,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1763,391427,argc,3,moduleLoadQueueEntry.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1764,391428,argv,3,moduleLoadQueueEntry.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1765,391430,argc,3,sentinelLoadQueueEntry.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1766,391431,argv,3,sentinelLoadQueueEntry.argv,,server.h,*argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1767,391432,linenum,3,sentinelLoadQueueEntry.linenum,,server.h,linenum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1768,391433,line,3,sentinelLoadQueueEntry.line,,server.h,line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1769,391435,pre_monitor_cfg,3,sentinelConfig.pre_monitor_cfg,,server.h,*pre_monitor_cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1770,391436,monitor_cfg,3,sentinelConfig.monitor_cfg,,server.h,*monitor_cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1771,391437,post_monitor_cfg,3,sentinelConfig.post_monitor_cfg,,server.h,*post_monitor_cfg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1772,391439,ok,3,sharedObjectsStruct.ok,,server.h,*ok,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1773,391440,err,3,sharedObjectsStruct.err,,server.h,*err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1774,391441,emptybulk,3,sharedObjectsStruct.emptybulk,,server.h,*emptybulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1775,391442,czero,3,sharedObjectsStruct.czero,,server.h,*czero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1776,391443,cone,3,sharedObjectsStruct.cone,,server.h,*cone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1777,391444,pong,3,sharedObjectsStruct.pong,,server.h,*pong,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1778,391445,space,3,sharedObjectsStruct.space,,server.h,*space,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1779,391446,queued,3,sharedObjectsStruct.queued,,server.h,*queued,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1780,391447,,3,sharedObjectsStruct.nan,,server.h,*null[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1781,391448,nullarray,3,sharedObjectsStruct.nullarray,,server.h,*nullarray[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1782,391449,emptymap,3,sharedObjectsStruct.emptymap,,server.h,*emptymap[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1783,391450,emptyset,3,sharedObjectsStruct.emptyset,,server.h,*emptyset[4],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1784,391451,emptyarray,3,sharedObjectsStruct.emptyarray,,server.h,*emptyarray,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1785,391452,wrongtypeerr,3,sharedObjectsStruct.wrongtypeerr,,server.h,*wrongtypeerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1786,391453,nokeyerr,3,sharedObjectsStruct.nokeyerr,,server.h,*nokeyerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1787,391454,syntaxerr,3,sharedObjectsStruct.syntaxerr,,server.h,*syntaxerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1788,391455,sameobjecterr,3,sharedObjectsStruct.sameobjecterr,,server.h,*sameobjecterr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1789,391456,outofrangeerr,3,sharedObjectsStruct.outofrangeerr,,server.h,*outofrangeerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1790,391457,noscripterr,3,sharedObjectsStruct.noscripterr,,server.h,*noscripterr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1791,391458,loadingerr,3,sharedObjectsStruct.loadingerr,,server.h,*loadingerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1792,391459,slowevalerr,3,sharedObjectsStruct.slowevalerr,,server.h,*slowevalerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1793,391460,slowscripterr,3,sharedObjectsStruct.slowscripterr,,server.h,*slowscripterr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1794,391461,slowmoduleerr,3,sharedObjectsStruct.slowmoduleerr,,server.h,*slowmoduleerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1795,391462,bgsaveerr,3,sharedObjectsStruct.bgsaveerr,,server.h,*bgsaveerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1796,391463,masterdownerr,3,sharedObjectsStruct.masterdownerr,,server.h,*masterdownerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1797,391464,roslaveerr,3,sharedObjectsStruct.roslaveerr,,server.h,*roslaveerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1798,391465,execaborterr,3,sharedObjectsStruct.execaborterr,,server.h,*execaborterr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1799,391466,noautherr,3,sharedObjectsStruct.noautherr,,server.h,*noautherr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1800,391467,noreplicaserr,3,sharedObjectsStruct.noreplicaserr,,server.h,*noreplicaserr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1801,391468,busykeyerr,3,sharedObjectsStruct.busykeyerr,,server.h,*busykeyerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1802,391469,oomerr,3,sharedObjectsStruct.oomerr,,server.h,*oomerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1803,391470,plus,3,sharedObjectsStruct.plus,,server.h,*plus,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1804,391471,messagebulk,3,sharedObjectsStruct.messagebulk,,server.h,*messagebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1805,391472,pmessagebulk,3,sharedObjectsStruct.pmessagebulk,,server.h,*pmessagebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1806,391473,subscribebulk,3,sharedObjectsStruct.subscribebulk,,server.h,*subscribebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1807,391474,unsubscribebulk,3,sharedObjectsStruct.unsubscribebulk,,server.h,*unsubscribebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1808,391475,psubscribebulk,3,sharedObjectsStruct.psubscribebulk,,server.h,*psubscribebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1809,391476,punsubscribebulk,3,sharedObjectsStruct.punsubscribebulk,,server.h,*punsubscribebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1810,391477,del,3,sharedObjectsStruct.del,,server.h,*del,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1811,391478,unlink,3,sharedObjectsStruct.unlink,,server.h,*unlink,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1812,391479,rpop,3,sharedObjectsStruct.rpop,,server.h,*rpop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1813,391480,lpop,3,sharedObjectsStruct.lpop,,server.h,*lpop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1814,391481,lpush,3,sharedObjectsStruct.lpush,,server.h,*lpush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1815,391482,rpoplpush,3,sharedObjectsStruct.rpoplpush,,server.h,*rpoplpush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1816,391483,lmove,3,sharedObjectsStruct.lmove,,server.h,*lmove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1817,391484,blmove,3,sharedObjectsStruct.blmove,,server.h,*blmove,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1818,391485,zpopmin,3,sharedObjectsStruct.zpopmin,,server.h,*zpopmin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1819,391486,zpopmax,3,sharedObjectsStruct.zpopmax,,server.h,*zpopmax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1820,391487,emptyscan,3,sharedObjectsStruct.emptyscan,,server.h,*emptyscan,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1821,391488,multi,3,sharedObjectsStruct.multi,,server.h,*multi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1822,391489,exec,3,sharedObjectsStruct.exec,,server.h,*exec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1823,391490,left,3,sharedObjectsStruct.left,,server.h,*left,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1824,391491,right,3,sharedObjectsStruct.right,,server.h,*right,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1825,391492,hset,3,sharedObjectsStruct.hset,,server.h,*hset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1826,391493,srem,3,sharedObjectsStruct.srem,,server.h,*srem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1827,391494,xgroup,3,sharedObjectsStruct.xgroup,,server.h,*xgroup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1828,391495,xclaim,3,sharedObjectsStruct.xclaim,,server.h,*xclaim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1829,391496,script,3,sharedObjectsStruct.script,,server.h,*script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1830,391497,replconf,3,sharedObjectsStruct.replconf,,server.h,*replconf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1831,391498,eval,3,sharedObjectsStruct.eval,,server.h,*eval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1832,391499,persist,3,sharedObjectsStruct.persist,,server.h,*persist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1833,391500,set,3,sharedObjectsStruct.set,,server.h,*set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1834,391501,pexpireat,3,sharedObjectsStruct.pexpireat,,server.h,*pexpireat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1835,391502,pexpire,3,sharedObjectsStruct.pexpire,,server.h,*pexpire,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1836,391503,time,3,sharedObjectsStruct.time,,server.h,*time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1837,391504,pxat,3,sharedObjectsStruct.pxat,,server.h,*pxat,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1838,391505,absttl,3,sharedObjectsStruct.absttl,,server.h,*absttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1839,391506,retrycount,3,sharedObjectsStruct.retrycount,,server.h,*retrycount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1840,391507,force,3,sharedObjectsStruct.force,,server.h,*force,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1841,391508,justid,3,sharedObjectsStruct.justid,,server.h,*justid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1842,391509,entriesread,3,sharedObjectsStruct.entriesread,,server.h,*entriesread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1843,391510,lastid,3,sharedObjectsStruct.lastid,,server.h,*lastid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1844,391511,ping,3,sharedObjectsStruct.ping,,server.h,*ping,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1845,391512,setid,3,sharedObjectsStruct.setid,,server.h,*setid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1846,391513,keepttl,3,sharedObjectsStruct.keepttl,,server.h,*keepttl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1847,391514,load,3,sharedObjectsStruct.load,,server.h,*load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1848,391515,createconsumer,3,sharedObjectsStruct.createconsumer,,server.h,*createconsumer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1849,391516,getack,3,sharedObjectsStruct.getack,,server.h,*getack,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1850,391517,special_asterick,3,sharedObjectsStruct.special_asterick,,server.h,*special_asterick,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1851,391518,special_equals,3,sharedObjectsStruct.special_equals,,server.h,*special_equals,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1852,391519,default_username,3,sharedObjectsStruct.default_username,,server.h,*default_username,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1853,391520,redacted,3,sharedObjectsStruct.redacted,,server.h,*redacted,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1854,391521,ssubscribebulk,3,sharedObjectsStruct.ssubscribebulk,,server.h,*ssubscribebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1855,391522,sunsubscribebulk,3,sharedObjectsStruct.sunsubscribebulk,,server.h,*sunsubscribebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1856,391523,smessagebulk,3,sharedObjectsStruct.smessagebulk,,server.h,*smessagebulk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1857,391524,select,3,sharedObjectsStruct.select,,server.h,*select[PROTO_SHARED_SELECT_CMDS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1858,391525,integers,3,sharedObjectsStruct.integers,,server.h,*integers[OBJ_SHARED_INTEGERS],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1859,391526,mbulkhdr,3,sharedObjectsStruct.mbulkhdr,,server.h,*mbulkhdr[OBJ_SHARED_BULKHDR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1860,391527,bulkhdr,3,sharedObjectsStruct.bulkhdr,,server.h,*bulkhdr[OBJ_SHARED_BULKHDR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1861,391528,maphdr,3,sharedObjectsStruct.maphdr,,server.h,*maphdr[OBJ_SHARED_BULKHDR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1862,391529,sethdr,3,sharedObjectsStruct.sethdr,,server.h,*sethdr[OBJ_SHARED_BULKHDR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1863,391530,minstring,3,sharedObjectsStruct.minstring,,server.h,minstring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1864,391531,maxstring,3,sharedObjectsStruct.maxstring,,server.h,maxstring,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1865,391569,ele,3,zskiplistNode.ele,,server.h,ele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
1866,391570,score,3,zskiplistNode.score,,server.h,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1867,391572,backward,3,zskiplistNode.backward,,server.h,*backward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1868,391575,forward,3,zskiplistNode.zskiplistLevel.forward,,server.h,*forward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1869,391576,span,3,zskiplistNode.zskiplistLevel.span,,server.h,span,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1870,391577,level,3,zskiplistNode.level,,server.h,level[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1871,391586,header,3,zskiplist.header,,server.h,*header,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1872,391587,tail,3,zskiplist.tail,,server.h,*tail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1873,391588,length,3,zskiplist.length,,server.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1874,391589,level,3,zskiplist.level,,server.h,level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1875,391592,dict,3,zset.dict,,server.h,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1876,391593,zsl,3,zset.zsl,,server.h,*zsl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1877,391596,hard_limit_bytes,3,clientBufferLimitsConfig.hard_limit_bytes,,server.h,hard_limit_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1878,391597,soft_limit_bytes,3,clientBufferLimitsConfig.soft_limit_bytes,,server.h,soft_limit_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1879,391598,soft_limit_seconds,3,clientBufferLimitsConfig.soft_limit_seconds,,server.h,soft_limit_seconds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1880,391606,argv,3,redisOp.argv,,server.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1881,391607,argc,3,redisOp.argc,,server.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1882,391608,dbid,3,redisOp.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1883,391609,target,3,redisOp.target,,server.h,target,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1884,391612,ops,3,redisOpArray.ops,,server.h,*ops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1885,391613,numops,3,redisOpArray.numops,,server.h,numops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1886,391614,capacity,3,redisOpArray.capacity,,server.h,capacity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1887,391617,peak_allocated,3,redisMemOverhead.peak_allocated,,server.h,peak_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1888,391618,total_allocated,3,redisMemOverhead.total_allocated,,server.h,total_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1889,391619,startup_allocated,3,redisMemOverhead.startup_allocated,,server.h,startup_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1890,391620,repl_backlog,3,redisMemOverhead.repl_backlog,,server.h,repl_backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1891,391621,clients_slaves,3,redisMemOverhead.clients_slaves,,server.h,clients_slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1892,391622,clients_normal,3,redisMemOverhead.clients_normal,,server.h,clients_normal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1893,391623,cluster_links,3,redisMemOverhead.cluster_links,,server.h,cluster_links,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1894,391624,aof_buffer,3,redisMemOverhead.aof_buffer,,server.h,aof_buffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1895,391625,lua_caches,3,redisMemOverhead.lua_caches,,server.h,lua_caches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1896,391626,functions_caches,3,redisMemOverhead.functions_caches,,server.h,functions_caches,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1897,391627,overhead_total,3,redisMemOverhead.overhead_total,,server.h,overhead_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1898,391628,dataset,3,redisMemOverhead.dataset,,server.h,dataset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1899,391629,total_keys,3,redisMemOverhead.total_keys,,server.h,total_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1900,391630,bytes_per_key,3,redisMemOverhead.bytes_per_key,,server.h,bytes_per_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1901,391631,dataset_perc,3,redisMemOverhead.dataset_perc,,server.h,dataset_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1902,391632,peak_perc,3,redisMemOverhead.peak_perc,,server.h,peak_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1903,391633,total_frag,3,redisMemOverhead.total_frag,,server.h,total_frag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1904,391634,total_frag_bytes,3,redisMemOverhead.total_frag_bytes,,server.h,total_frag_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1905,391635,allocator_frag,3,redisMemOverhead.allocator_frag,,server.h,allocator_frag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1906,391636,allocator_frag_bytes,3,redisMemOverhead.allocator_frag_bytes,,server.h,allocator_frag_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1907,391637,allocator_rss,3,redisMemOverhead.allocator_rss,,server.h,allocator_rss,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1908,391638,allocator_rss_bytes,3,redisMemOverhead.allocator_rss_bytes,,server.h,allocator_rss_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1909,391639,rss_extra,3,redisMemOverhead.rss_extra,,server.h,rss_extra,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1910,391640,rss_extra_bytes,3,redisMemOverhead.rss_extra_bytes,,server.h,rss_extra_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1911,391641,num_dbs,3,redisMemOverhead.num_dbs,,server.h,num_dbs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1912,391643,dbid,3,redisMemOverhead.db.dbid,,server.h,dbid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1913,391644,overhead_ht_main,3,redisMemOverhead.db.overhead_ht_main,,server.h,overhead_ht_main,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1914,391645,overhead_ht_expires,3,redisMemOverhead.db.overhead_ht_expires,,server.h,overhead_ht_expires,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1915,391646,overhead_ht_slot_to_keys,3,redisMemOverhead.db.overhead_ht_slot_to_keys,,server.h,overhead_ht_slot_to_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1916,391647,db,3,redisMemOverhead.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1917,391649,PROPAGATION_ERR_BEHAVIOR_IGNORE,3,replicationErrorBehavior.PROPAGATION_ERR_BEHAVIOR_IGNORE,,server.h,PROPAGATION_ERR_BEHAVIOR_IGNORE = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1918,391650,PROPAGATION_ERR_BEHAVIOR_PANIC,3,replicationErrorBehavior.PROPAGATION_ERR_BEHAVIOR_PANIC,,server.h,PROPAGATION_ERR_BEHAVIOR_PANIC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1919,391651,PROPAGATION_ERR_BEHAVIOR_PANIC_ON_REPLICAS,3,replicationErrorBehavior.PROPAGATION_ERR_BEHAVIOR_PANIC_ON_REPLICAS,,server.h,PROPAGATION_ERR_BEHAVIOR_PANIC_ON_REPLICAS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1920,391661,repl_stream_db,3,rdbSaveInfo.repl_stream_db,,server.h,repl_stream_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1921,391662,repl_id_is_set,3,rdbSaveInfo.repl_id_is_set,,server.h,repl_id_is_set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1922,391663,repl_id,3,rdbSaveInfo.repl_id,,server.h,repl_id[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1923,391664,repl_offset,3,rdbSaveInfo.repl_offset,,server.h,repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1924,391677,zmalloc_used,3,malloc_stats.zmalloc_used,,server.h,zmalloc_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1925,391678,process_rss,3,malloc_stats.process_rss,,server.h,process_rss,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1926,391679,allocator_allocated,3,malloc_stats.allocator_allocated,,server.h,allocator_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1927,391680,allocator_active,3,malloc_stats.allocator_active,,server.h,allocator_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1928,391681,allocator_resident,3,malloc_stats.allocator_resident,,server.h,allocator_resident,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1929,391683,cert_file,3,redisTLSContextConfig.cert_file,,server.h,*cert_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1930,391684,key_file,3,redisTLSContextConfig.key_file,,server.h,*key_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1931,391685,key_file_pass,3,redisTLSContextConfig.key_file_pass,,server.h,*key_file_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1932,391686,client_cert_file,3,redisTLSContextConfig.client_cert_file,,server.h,*client_cert_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1933,391687,client_key_file,3,redisTLSContextConfig.client_key_file,,server.h,*client_key_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1934,391688,client_key_file_pass,3,redisTLSContextConfig.client_key_file_pass,,server.h,*client_key_file_pass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1935,391689,dh_params_file,3,redisTLSContextConfig.dh_params_file,,server.h,*dh_params_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1936,391690,ca_cert_file,3,redisTLSContextConfig.ca_cert_file,,server.h,*ca_cert_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1937,391691,ca_cert_dir,3,redisTLSContextConfig.ca_cert_dir,,server.h,*ca_cert_dir,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1938,391692,protocols,3,redisTLSContextConfig.protocols,,server.h,*protocols,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1939,391693,ciphers,3,redisTLSContextConfig.ciphers,,server.h,*ciphers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1940,391694,ciphersuites,3,redisTLSContextConfig.ciphersuites,,server.h,*ciphersuites,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1941,391695,prefer_server_ciphers,3,redisTLSContextConfig.prefer_server_ciphers,,server.h,prefer_server_ciphers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1942,391696,session_caching,3,redisTLSContextConfig.session_caching,,server.h,session_caching,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1943,391697,session_cache_size,3,redisTLSContextConfig.session_cache_size,,server.h,session_cache_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1944,391698,session_cache_timeout,3,redisTLSContextConfig.session_cache_timeout,,server.h,session_cache_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1945,391701,AOF_FILE_TYPE_BASE,3,aof_file_type.AOF_FILE_TYPE_BASE,,server.h,AOF_FILE_TYPE_BASE  = 'b',-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1946,391702,AOF_FILE_TYPE_HIST,3,aof_file_type.AOF_FILE_TYPE_HIST,,server.h,AOF_FILE_TYPE_HIST  = 'h',-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1947,391703,AOF_FILE_TYPE_INCR,3,aof_file_type.AOF_FILE_TYPE_INCR,,server.h,AOF_FILE_TYPE_INCR  = 'i',-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1948,391719,file_name,3,aofInfo.file_name,,server.h,file_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
1949,391720,file_seq,3,aofInfo.file_seq,,server.h,file_seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1950,391721,file_type,3,aofInfo.file_type,,server.h,file_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
1951,391724,base_aof_info,3,aofManifest.base_aof_info,,server.h,*base_aof_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
1952,391725,incr_aof_list,3,aofManifest.incr_aof_list,,server.h,*incr_aof_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,34,0,1,1,0,0,,0,0,0,0,0,
1953,391726,history_aof_list,3,aofManifest.history_aof_list,,server.h,*history_aof_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1954,391727,curr_base_file_seq,3,aofManifest.curr_base_file_seq,,server.h,curr_base_file_seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1955,391728,curr_incr_file_seq,3,aofManifest.curr_incr_file_seq,,server.h,curr_incr_file_seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1956,391729,dirty,3,aofManifest.dirty,,server.h,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
1957,391732,CHILD_INFO_TYPE_CURRENT_INFO,3,childInfoType.CHILD_INFO_TYPE_CURRENT_INFO,,server.h,CHILD_INFO_TYPE_CURRENT_INFO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1958,391733,CHILD_INFO_TYPE_AOF_COW_SIZE,3,childInfoType.CHILD_INFO_TYPE_AOF_COW_SIZE,,server.h,CHILD_INFO_TYPE_AOF_COW_SIZE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1959,391734,CHILD_INFO_TYPE_RDB_COW_SIZE,3,childInfoType.CHILD_INFO_TYPE_RDB_COW_SIZE,,server.h,CHILD_INFO_TYPE_RDB_COW_SIZE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1960,391735,CHILD_INFO_TYPE_MODULE_COW_SIZE,3,childInfoType.CHILD_INFO_TYPE_MODULE_COW_SIZE,,server.h,CHILD_INFO_TYPE_MODULE_COW_SIZE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1961,391738,pid,3,redisServer.pid,,server.h,pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1962,391739,main_thread_id,3,redisServer.main_thread_id,,server.h,main_thread_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1963,391740,configfile,3,redisServer.configfile,,server.h,*configfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1964,391741,executable,3,redisServer.executable,,server.h,*executable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1965,391742,exec_argv,3,redisServer.exec_argv,,server.h,**exec_argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1966,391743,dynamic_hz,3,redisServer.dynamic_hz,,server.h,dynamic_hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1967,391744,config_hz,3,redisServer.config_hz,,server.h,config_hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1968,391745,umask,3,redisServer.umask,,server.h,umask,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1969,391746,hz,3,redisServer.hz,,server.h,hz,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
1970,391747,in_fork_child,3,redisServer.in_fork_child,,server.h,in_fork_child,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1971,391748,db,3,redisServer.db,,server.h,*db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,42,0,1,1,0,0,,0,0,0,0,0,
1972,391749,commands,3,redisServer.commands,,server.h,*commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,25,0,1,1,0,0,,0,0,0,0,0,
1973,391750,orig_commands,3,redisServer.orig_commands,,server.h,*orig_commands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1974,391751,el,3,redisServer.el,,server.h,*el,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1975,391752,errors,3,redisServer.errors,,server.h,*errors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1976,391753,lruclock,3,redisServer.lruclock,,server.h,lruclock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1977,391754,shutdown_asap,3,redisServer.shutdown_asap,,server.h,shutdown_asap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
1978,391755,shutdown_mstime,3,redisServer.shutdown_mstime,,server.h,shutdown_mstime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1979,391756,last_sig_received,3,redisServer.last_sig_received,,server.h,last_sig_received,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1980,391757,shutdown_flags,3,redisServer.shutdown_flags,,server.h,shutdown_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1981,391758,activerehashing,3,redisServer.activerehashing,,server.h,activerehashing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1982,391759,active_defrag_running,3,redisServer.active_defrag_running,,server.h,active_defrag_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1983,391760,pidfile,3,redisServer.pidfile,,server.h,*pidfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1984,391761,arch_bits,3,redisServer.arch_bits,,server.h,arch_bits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1985,391762,cronloops,3,redisServer.cronloops,,server.h,cronloops,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
1986,391763,runid,3,redisServer.runid,,server.h,runid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1987,391764,sentinel_mode,3,redisServer.sentinel_mode,,server.h,sentinel_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1988,391765,initial_memory_usage,3,redisServer.initial_memory_usage,,server.h,initial_memory_usage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1989,391766,always_show_logo,3,redisServer.always_show_logo,,server.h,always_show_logo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1990,391767,in_exec,3,redisServer.in_exec,,server.h,in_exec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1991,391768,busy_module_yield_flags,3,redisServer.busy_module_yield_flags,,server.h,busy_module_yield_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1992,391769,busy_module_yield_reply,3,redisServer.busy_module_yield_reply,,server.h,*busy_module_yield_reply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1993,391770,ignore_warnings,3,redisServer.ignore_warnings,,server.h,*ignore_warnings,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1994,391771,client_pause_in_transaction,3,redisServer.client_pause_in_transaction,,server.h,client_pause_in_transaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1995,391772,thp_enabled,3,redisServer.thp_enabled,,server.h,thp_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1996,391773,page_size,3,redisServer.page_size,,server.h,page_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1997,391774,moduleapi,3,redisServer.moduleapi,,server.h,*moduleapi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1998,391775,sharedapi,3,redisServer.sharedapi,,server.h,*sharedapi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
1999,391776,module_configs_queue,3,redisServer.module_configs_queue,,server.h,*module_configs_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2000,391777,loadmodule_queue,3,redisServer.loadmodule_queue,,server.h,*loadmodule_queue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2001,391778,module_pipe,3,redisServer.module_pipe,,server.h,module_pipe[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2002,391779,child_pid,3,redisServer.child_pid,,server.h,child_pid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2003,391780,child_type,3,redisServer.child_type,,server.h,child_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2004,391781,port,3,redisServer.port,,server.h,port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2005,391782,tls_port,3,redisServer.tls_port,,server.h,tls_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2006,391783,tcp_backlog,3,redisServer.tcp_backlog,,server.h,tcp_backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2007,391784,bindaddr,3,redisServer.bindaddr,,server.h,*bindaddr[CONFIG_BINDADDR_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2008,391785,bindaddr_count,3,redisServer.bindaddr_count,,server.h,bindaddr_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2009,391786,bind_source_addr,3,redisServer.bind_source_addr,,server.h,*bind_source_addr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2010,391787,unixsocket,3,redisServer.unixsocket,,server.h,*unixsocket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2011,391788,unixsocketperm,3,redisServer.unixsocketperm,,server.h,unixsocketperm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2012,391789,listeners,3,redisServer.listeners,,server.h,listeners[CONN_TYPE_MAX],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2013,391790,socket_mark_id,3,redisServer.socket_mark_id,,server.h,socket_mark_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2014,391791,clistener,3,redisServer.clistener,,server.h,clistener,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2015,391792,clients,3,redisServer.clients,,server.h,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
2016,391793,clients_to_close,3,redisServer.clients_to_close,,server.h,*clients_to_close,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2017,391794,clients_pending_write,3,redisServer.clients_pending_write,,server.h,*clients_pending_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2018,391795,clients_pending_read,3,redisServer.clients_pending_read,,server.h,*clients_pending_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2019,391796,slaves,3,redisServer.slaves,,server.h,*slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
2020,391797,monitors,3,redisServer.monitors,,server.h,*monitors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2021,391798,current_client,3,redisServer.current_client,,server.h,*current_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2022,391799,executing_client,3,redisServer.executing_client,,server.h,*executing_client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2023,391800,req_res_logfile,3,redisServer.req_res_logfile,,server.h,*req_res_logfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2024,391801,client_default_resp,3,redisServer.client_default_resp,,server.h,client_default_resp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2025,391802,client_mem_usage_buckets,3,redisServer.client_mem_usage_buckets,,server.h,* client_mem_usage_buckets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2026,391803,clients_timeout_table,3,redisServer.clients_timeout_table,,server.h,*clients_timeout_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2027,391804,execution_nesting,3,redisServer.execution_nesting,,server.h,execution_nesting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2028,391805,clients_index,3,redisServer.clients_index,,server.h,*clients_index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2029,391806,paused_actions,3,redisServer.paused_actions,,server.h,paused_actions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2030,391807,postponed_clients,3,redisServer.postponed_clients,,server.h,*postponed_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2031,391808,client_pause_per_purpose,3,redisServer.client_pause_per_purpose,,server.h,client_pause_per_purpose[NUM_PAUSE_PURPOSES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2032,391809,neterr,3,redisServer.neterr,,server.h,neterr[ANET_ERR_LEN],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2033,391810,migrate_cached_sockets,3,redisServer.migrate_cached_sockets,,server.h,*migrate_cached_sockets,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2034,391811,next_client_id,3,redisServer.next_client_id,,server.h,next_client_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2035,391812,protected_mode,3,redisServer.protected_mode,,server.h,protected_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2036,391813,io_threads_num,3,redisServer.io_threads_num,,server.h,io_threads_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2037,391814,io_threads_do_reads,3,redisServer.io_threads_do_reads,,server.h,io_threads_do_reads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2038,391815,io_threads_active,3,redisServer.io_threads_active,,server.h,io_threads_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2039,391816,events_processed_while_blocked,3,redisServer.events_processed_while_blocked,,server.h,events_processed_while_blocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2040,391817,enable_protected_configs,3,redisServer.enable_protected_configs,,server.h,enable_protected_configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2041,391818,enable_debug_cmd,3,redisServer.enable_debug_cmd,,server.h,enable_debug_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2042,391819,enable_module_cmd,3,redisServer.enable_module_cmd,,server.h,enable_module_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2043,391820,loading,3,redisServer.loading,,server.h,loading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2044,391821,async_loading,3,redisServer.async_loading,,server.h,async_loading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2045,391822,loading_total_bytes,3,redisServer.loading_total_bytes,,server.h,loading_total_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2046,391823,loading_rdb_used_mem,3,redisServer.loading_rdb_used_mem,,server.h,loading_rdb_used_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2047,391824,loading_loaded_bytes,3,redisServer.loading_loaded_bytes,,server.h,loading_loaded_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2048,391825,loading_start_time,3,redisServer.loading_start_time,,server.h,loading_start_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2049,391826,loading_process_events_interval_bytes,3,redisServer.loading_process_events_interval_bytes,,server.h,loading_process_events_interval_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2050,391827,stat_starttime,3,redisServer.stat_starttime,,server.h,stat_starttime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2051,391828,stat_numcommands,3,redisServer.stat_numcommands,,server.h,stat_numcommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2052,391829,stat_numconnections,3,redisServer.stat_numconnections,,server.h,stat_numconnections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2053,391830,stat_expiredkeys,3,redisServer.stat_expiredkeys,,server.h,stat_expiredkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2054,391831,stat_expired_stale_perc,3,redisServer.stat_expired_stale_perc,,server.h,stat_expired_stale_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2055,391832,stat_expired_time_cap_reached_count,3,redisServer.stat_expired_time_cap_reached_count,,server.h,stat_expired_time_cap_reached_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2056,391833,stat_expire_cycle_time_used,3,redisServer.stat_expire_cycle_time_used,,server.h,stat_expire_cycle_time_used,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2057,391834,stat_evictedkeys,3,redisServer.stat_evictedkeys,,server.h,stat_evictedkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2058,391835,stat_evictedclients,3,redisServer.stat_evictedclients,,server.h,stat_evictedclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2059,391836,stat_total_eviction_exceeded_time,3,redisServer.stat_total_eviction_exceeded_time,,server.h,stat_total_eviction_exceeded_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2060,391837,stat_last_eviction_exceeded_time,3,redisServer.stat_last_eviction_exceeded_time,,server.h,stat_last_eviction_exceeded_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2061,391838,stat_keyspace_hits,3,redisServer.stat_keyspace_hits,,server.h,stat_keyspace_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2062,391839,stat_keyspace_misses,3,redisServer.stat_keyspace_misses,,server.h,stat_keyspace_misses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2063,391840,stat_active_defrag_hits,3,redisServer.stat_active_defrag_hits,,server.h,stat_active_defrag_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2064,391841,stat_active_defrag_misses,3,redisServer.stat_active_defrag_misses,,server.h,stat_active_defrag_misses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2065,391842,stat_active_defrag_key_hits,3,redisServer.stat_active_defrag_key_hits,,server.h,stat_active_defrag_key_hits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2066,391843,stat_active_defrag_key_misses,3,redisServer.stat_active_defrag_key_misses,,server.h,stat_active_defrag_key_misses,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2067,391844,stat_active_defrag_scanned,3,redisServer.stat_active_defrag_scanned,,server.h,stat_active_defrag_scanned,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2068,391845,stat_total_active_defrag_time,3,redisServer.stat_total_active_defrag_time,,server.h,stat_total_active_defrag_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2069,391846,stat_last_active_defrag_time,3,redisServer.stat_last_active_defrag_time,,server.h,stat_last_active_defrag_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2070,391847,stat_peak_memory,3,redisServer.stat_peak_memory,,server.h,stat_peak_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2071,391848,stat_aof_rewrites,3,redisServer.stat_aof_rewrites,,server.h,stat_aof_rewrites,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2072,391849,stat_aofrw_consecutive_failures,3,redisServer.stat_aofrw_consecutive_failures,,server.h,stat_aofrw_consecutive_failures,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2073,391850,stat_rdb_saves,3,redisServer.stat_rdb_saves,,server.h,stat_rdb_saves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2074,391851,stat_fork_time,3,redisServer.stat_fork_time,,server.h,stat_fork_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2075,391852,stat_fork_rate,3,redisServer.stat_fork_rate,,server.h,stat_fork_rate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2076,391853,stat_total_forks,3,redisServer.stat_total_forks,,server.h,stat_total_forks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2077,391854,stat_rejected_conn,3,redisServer.stat_rejected_conn,,server.h,stat_rejected_conn,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2078,391855,stat_sync_full,3,redisServer.stat_sync_full,,server.h,stat_sync_full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2079,391856,stat_sync_partial_ok,3,redisServer.stat_sync_partial_ok,,server.h,stat_sync_partial_ok,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2080,391857,stat_sync_partial_err,3,redisServer.stat_sync_partial_err,,server.h,stat_sync_partial_err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2081,391858,slowlog,3,redisServer.slowlog,,server.h,*slowlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2082,391859,slowlog_entry_id,3,redisServer.slowlog_entry_id,,server.h,slowlog_entry_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2083,391860,slowlog_log_slower_than,3,redisServer.slowlog_log_slower_than,,server.h,slowlog_log_slower_than,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2084,391861,slowlog_max_len,3,redisServer.slowlog_max_len,,server.h,slowlog_max_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2085,391863,cron_malloc_stats,3,redisServer.cron_malloc_stats,,server.h,cron_malloc_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
2086,391864,stat_net_input_bytes,3,redisServer.stat_net_input_bytes,,server.h,stat_net_input_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2087,391865,stat_net_output_bytes,3,redisServer.stat_net_output_bytes,,server.h,stat_net_output_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2088,391866,stat_net_repl_input_bytes,3,redisServer.stat_net_repl_input_bytes,,server.h,stat_net_repl_input_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2089,391867,stat_net_repl_output_bytes,3,redisServer.stat_net_repl_output_bytes,,server.h,stat_net_repl_output_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2090,391868,stat_current_cow_peak,3,redisServer.stat_current_cow_peak,,server.h,stat_current_cow_peak,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2091,391869,stat_current_cow_bytes,3,redisServer.stat_current_cow_bytes,,server.h,stat_current_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2092,391870,stat_current_cow_updated,3,redisServer.stat_current_cow_updated,,server.h,stat_current_cow_updated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2093,391871,stat_current_save_keys_processed,3,redisServer.stat_current_save_keys_processed,,server.h,stat_current_save_keys_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2094,391872,stat_current_save_keys_total,3,redisServer.stat_current_save_keys_total,,server.h,stat_current_save_keys_total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2095,391873,stat_rdb_cow_bytes,3,redisServer.stat_rdb_cow_bytes,,server.h,stat_rdb_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2096,391874,stat_aof_cow_bytes,3,redisServer.stat_aof_cow_bytes,,server.h,stat_aof_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2097,391875,stat_module_cow_bytes,3,redisServer.stat_module_cow_bytes,,server.h,stat_module_cow_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2098,391876,stat_module_progress,3,redisServer.stat_module_progress,,server.h,stat_module_progress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2099,391877,stat_clients_type_memory,3,redisServer.stat_clients_type_memory,,server.h,stat_clients_type_memory[CLIENT_TYPE_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2100,391878,stat_cluster_links_memory,3,redisServer.stat_cluster_links_memory,,server.h,stat_cluster_links_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2101,391879,stat_unexpected_error_replies,3,redisServer.stat_unexpected_error_replies,,server.h,stat_unexpected_error_replies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2102,391880,stat_total_error_replies,3,redisServer.stat_total_error_replies,,server.h,stat_total_error_replies,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2103,391881,stat_dump_payload_sanitizations,3,redisServer.stat_dump_payload_sanitizations,,server.h,stat_dump_payload_sanitizations,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2104,391882,stat_io_reads_processed,3,redisServer.stat_io_reads_processed,,server.h,stat_io_reads_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2105,391883,stat_io_writes_processed,3,redisServer.stat_io_writes_processed,,server.h,stat_io_writes_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2106,391884,stat_total_reads_processed,3,redisServer.stat_total_reads_processed,,server.h,stat_total_reads_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2107,391885,stat_total_writes_processed,3,redisServer.stat_total_writes_processed,,server.h,stat_total_writes_processed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2108,391887,last_sample_base,3,redisServer.inst_metric.last_sample_base,,server.h,last_sample_base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2109,391888,last_sample_value,3,redisServer.inst_metric.last_sample_value,,server.h,last_sample_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2110,391889,samples,3,redisServer.inst_metric.samples,,server.h,samples[STATS_METRIC_SAMPLES],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2111,391890,idx,3,redisServer.inst_metric.idx,,server.h,idx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2112,391899,inst_metric,3,redisServer.inst_metric,,server.h,inst_metric[STATS_METRIC_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2113,391900,stat_reply_buffer_shrinks,3,redisServer.stat_reply_buffer_shrinks,,server.h,stat_reply_buffer_shrinks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2114,391901,stat_reply_buffer_expands,3,redisServer.stat_reply_buffer_expands,,server.h,stat_reply_buffer_expands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2115,391902,el_start,3,redisServer.el_start,,server.h,el_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2116,391903,el_cmd_cnt_start,3,redisServer.el_cmd_cnt_start,,server.h,el_cmd_cnt_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2117,391904,el_cmd_cnt_max,3,redisServer.el_cmd_cnt_max,,server.h,el_cmd_cnt_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2118,391905,el_cron_duration,3,redisServer.el_cron_duration,,server.h,el_cron_duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2119,391906,duration_stats,3,redisServer.duration_stats,,server.h,duration_stats[EL_DURATION_TYPE_NUM],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
2120,391907,verbosity,3,redisServer.verbosity,,server.h,verbosity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
2121,391908,maxidletime,3,redisServer.maxidletime,,server.h,maxidletime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2122,391909,tcpkeepalive,3,redisServer.tcpkeepalive,,server.h,tcpkeepalive,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2123,391910,active_expire_enabled,3,redisServer.active_expire_enabled,,server.h,active_expire_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2124,391911,active_expire_effort,3,redisServer.active_expire_effort,,server.h,active_expire_effort,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2125,391912,lazy_expire_disabled,3,redisServer.lazy_expire_disabled,,server.h,lazy_expire_disabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2126,391913,active_defrag_enabled,3,redisServer.active_defrag_enabled,,server.h,active_defrag_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2127,391914,sanitize_dump_payload,3,redisServer.sanitize_dump_payload,,server.h,sanitize_dump_payload,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2128,391915,skip_checksum_validation,3,redisServer.skip_checksum_validation,,server.h,skip_checksum_validation,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2129,391916,jemalloc_bg_thread,3,redisServer.jemalloc_bg_thread,,server.h,jemalloc_bg_thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2130,391917,active_defrag_ignore_bytes,3,redisServer.active_defrag_ignore_bytes,,server.h,active_defrag_ignore_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2131,391918,active_defrag_threshold_lower,3,redisServer.active_defrag_threshold_lower,,server.h,active_defrag_threshold_lower,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2132,391919,active_defrag_threshold_upper,3,redisServer.active_defrag_threshold_upper,,server.h,active_defrag_threshold_upper,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2133,391920,active_defrag_cycle_min,3,redisServer.active_defrag_cycle_min,,server.h,active_defrag_cycle_min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2134,391921,active_defrag_cycle_max,3,redisServer.active_defrag_cycle_max,,server.h,active_defrag_cycle_max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2135,391922,active_defrag_max_scan_fields,3,redisServer.active_defrag_max_scan_fields,,server.h,active_defrag_max_scan_fields,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2136,391923,client_max_querybuf_len,3,redisServer.client_max_querybuf_len,,server.h,client_max_querybuf_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2137,391924,dbnum,3,redisServer.dbnum,,server.h,dbnum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2138,391925,supervised,3,redisServer.supervised,,server.h,supervised,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2139,391926,supervised_mode,3,redisServer.supervised_mode,,server.h,supervised_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2140,391927,daemonize,3,redisServer.daemonize,,server.h,daemonize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2141,391928,set_proc_title,3,redisServer.set_proc_title,,server.h,set_proc_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2142,391929,proc_title_template,3,redisServer.proc_title_template,,server.h,*proc_title_template,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2143,391930,client_obuf_limits,3,redisServer.client_obuf_limits,,server.h,client_obuf_limits[CLIENT_TYPE_OBUF_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2144,391931,pause_cron,3,redisServer.pause_cron,,server.h,pause_cron,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2145,391932,latency_tracking_enabled,3,redisServer.latency_tracking_enabled,,server.h,latency_tracking_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2146,391933,latency_tracking_info_percentiles,3,redisServer.latency_tracking_info_percentiles,,server.h,*latency_tracking_info_percentiles,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2147,391934,latency_tracking_info_percentiles_len,3,redisServer.latency_tracking_info_percentiles_len,,server.h,latency_tracking_info_percentiles_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2148,391935,aof_enabled,3,redisServer.aof_enabled,,server.h,aof_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2149,391936,aof_state,3,redisServer.aof_state,,server.h,aof_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
2150,391937,aof_fsync,3,redisServer.aof_fsync,,server.h,aof_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2151,391938,aof_filename,3,redisServer.aof_filename,,server.h,*aof_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2152,391939,aof_dirname,3,redisServer.aof_dirname,,server.h,*aof_dirname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2153,391940,aof_no_fsync_on_rewrite,3,redisServer.aof_no_fsync_on_rewrite,,server.h,aof_no_fsync_on_rewrite,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2154,391941,aof_rewrite_perc,3,redisServer.aof_rewrite_perc,,server.h,aof_rewrite_perc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2155,391942,aof_rewrite_min_size,3,redisServer.aof_rewrite_min_size,,server.h,aof_rewrite_min_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2156,391943,aof_rewrite_base_size,3,redisServer.aof_rewrite_base_size,,server.h,aof_rewrite_base_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2157,391944,aof_current_size,3,redisServer.aof_current_size,,server.h,aof_current_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2158,391945,aof_last_incr_size,3,redisServer.aof_last_incr_size,,server.h,aof_last_incr_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2159,391946,aof_last_incr_fsync_offset,3,redisServer.aof_last_incr_fsync_offset,,server.h,aof_last_incr_fsync_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2160,391947,aof_flush_sleep,3,redisServer.aof_flush_sleep,,server.h,aof_flush_sleep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2161,391948,aof_rewrite_scheduled,3,redisServer.aof_rewrite_scheduled,,server.h,aof_rewrite_scheduled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2162,391949,aof_buf,3,redisServer.aof_buf,,server.h,aof_buf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2163,391950,aof_fd,3,redisServer.aof_fd,,server.h,aof_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2164,391951,aof_selected_db,3,redisServer.aof_selected_db,,server.h,aof_selected_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2165,391952,aof_flush_postponed_start,3,redisServer.aof_flush_postponed_start,,server.h,aof_flush_postponed_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2166,391953,aof_last_fsync,3,redisServer.aof_last_fsync,,server.h,aof_last_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2167,391954,aof_rewrite_time_last,3,redisServer.aof_rewrite_time_last,,server.h,aof_rewrite_time_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2168,391955,aof_rewrite_time_start,3,redisServer.aof_rewrite_time_start,,server.h,aof_rewrite_time_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2169,391956,aof_cur_timestamp,3,redisServer.aof_cur_timestamp,,server.h,aof_cur_timestamp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2170,391957,aof_timestamp_enabled,3,redisServer.aof_timestamp_enabled,,server.h,aof_timestamp_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2171,391958,aof_lastbgrewrite_status,3,redisServer.aof_lastbgrewrite_status,,server.h,aof_lastbgrewrite_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2172,391959,aof_delayed_fsync,3,redisServer.aof_delayed_fsync,,server.h,aof_delayed_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2173,391960,aof_rewrite_incremental_fsync,3,redisServer.aof_rewrite_incremental_fsync,,server.h,aof_rewrite_incremental_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2174,391961,rdb_save_incremental_fsync,3,redisServer.rdb_save_incremental_fsync,,server.h,rdb_save_incremental_fsync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2175,391962,aof_last_write_status,3,redisServer.aof_last_write_status,,server.h,aof_last_write_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2176,391963,aof_last_write_errno,3,redisServer.aof_last_write_errno,,server.h,aof_last_write_errno,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2177,391964,aof_load_truncated,3,redisServer.aof_load_truncated,,server.h,aof_load_truncated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2178,391965,aof_use_rdb_preamble,3,redisServer.aof_use_rdb_preamble,,server.h,aof_use_rdb_preamble,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2179,391966,aof_bio_fsync_status,3,redisServer.aof_bio_fsync_status,,server.h,aof_bio_fsync_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2180,391967,aof_bio_fsync_errno,3,redisServer.aof_bio_fsync_errno,,server.h,aof_bio_fsync_errno,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2181,391968,aof_manifest,3,redisServer.aof_manifest,,server.h,*aof_manifest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2182,391969,aof_disable_auto_gc,3,redisServer.aof_disable_auto_gc,,server.h,aof_disable_auto_gc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2183,391970,dirty,3,redisServer.dirty,,server.h,dirty,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2184,391971,dirty_before_bgsave,3,redisServer.dirty_before_bgsave,,server.h,dirty_before_bgsave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2185,391972,rdb_last_load_keys_expired,3,redisServer.rdb_last_load_keys_expired,,server.h,rdb_last_load_keys_expired,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2186,391973,rdb_last_load_keys_loaded,3,redisServer.rdb_last_load_keys_loaded,,server.h,rdb_last_load_keys_loaded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2187,391975,saveparams,3,redisServer.saveparams,,server.h,*saveparams,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2188,391976,saveparamslen,3,redisServer.saveparamslen,,server.h,saveparamslen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2189,391977,rdb_filename,3,redisServer.rdb_filename,,server.h,*rdb_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2190,391978,rdb_compression,3,redisServer.rdb_compression,,server.h,rdb_compression,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2191,391979,rdb_checksum,3,redisServer.rdb_checksum,,server.h,rdb_checksum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2192,391980,rdb_del_sync_files,3,redisServer.rdb_del_sync_files,,server.h,rdb_del_sync_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2193,391981,lastsave,3,redisServer.lastsave,,server.h,lastsave,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2194,391982,lastbgsave_try,3,redisServer.lastbgsave_try,,server.h,lastbgsave_try,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2195,391983,rdb_save_time_last,3,redisServer.rdb_save_time_last,,server.h,rdb_save_time_last,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2196,391984,rdb_save_time_start,3,redisServer.rdb_save_time_start,,server.h,rdb_save_time_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2197,391985,rdb_bgsave_scheduled,3,redisServer.rdb_bgsave_scheduled,,server.h,rdb_bgsave_scheduled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2198,391986,rdb_child_type,3,redisServer.rdb_child_type,,server.h,rdb_child_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2199,391987,lastbgsave_status,3,redisServer.lastbgsave_status,,server.h,lastbgsave_status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2200,391988,stop_writes_on_bgsave_err,3,redisServer.stop_writes_on_bgsave_err,,server.h,stop_writes_on_bgsave_err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2201,391989,rdb_pipe_read,3,redisServer.rdb_pipe_read,,server.h,rdb_pipe_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2202,391990,rdb_child_exit_pipe,3,redisServer.rdb_child_exit_pipe,,server.h,rdb_child_exit_pipe,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2203,391991,rdb_pipe_conns,3,redisServer.rdb_pipe_conns,,server.h,**rdb_pipe_conns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2204,391992,rdb_pipe_numconns,3,redisServer.rdb_pipe_numconns,,server.h,rdb_pipe_numconns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2205,391993,rdb_pipe_numconns_writing,3,redisServer.rdb_pipe_numconns_writing,,server.h,rdb_pipe_numconns_writing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2206,391994,rdb_pipe_buff,3,redisServer.rdb_pipe_buff,,server.h,*rdb_pipe_buff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2207,391995,rdb_pipe_bufflen,3,redisServer.rdb_pipe_bufflen,,server.h,rdb_pipe_bufflen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2208,391996,rdb_key_save_delay,3,redisServer.rdb_key_save_delay,,server.h,rdb_key_save_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2209,391997,key_load_delay,3,redisServer.key_load_delay,,server.h,key_load_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2210,391998,child_info_pipe,3,redisServer.child_info_pipe,,server.h,child_info_pipe[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2211,391999,child_info_nread,3,redisServer.child_info_nread,,server.h,child_info_nread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2212,392000,also_propagate,3,redisServer.also_propagate,,server.h,also_propagate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2213,392001,replication_allowed,3,redisServer.replication_allowed,,server.h,replication_allowed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2214,392002,logfile,3,redisServer.logfile,,server.h,*logfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2215,392003,syslog_enabled,3,redisServer.syslog_enabled,,server.h,syslog_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2216,392004,syslog_ident,3,redisServer.syslog_ident,,server.h,*syslog_ident,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2217,392005,syslog_facility,3,redisServer.syslog_facility,,server.h,syslog_facility,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2218,392006,crashlog_enabled,3,redisServer.crashlog_enabled,,server.h,crashlog_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2219,392007,memcheck_enabled,3,redisServer.memcheck_enabled,,server.h,memcheck_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2220,392008,use_exit_on_panic,3,redisServer.use_exit_on_panic,,server.h,use_exit_on_panic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2221,392009,shutdown_timeout,3,redisServer.shutdown_timeout,,server.h,shutdown_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2222,392010,shutdown_on_sigint,3,redisServer.shutdown_on_sigint,,server.h,shutdown_on_sigint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2223,392011,shutdown_on_sigterm,3,redisServer.shutdown_on_sigterm,,server.h,shutdown_on_sigterm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2224,392012,replid,3,redisServer.replid,,server.h,replid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2225,392013,replid2,3,redisServer.replid2,,server.h,replid2[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2226,392014,master_repl_offset,3,redisServer.master_repl_offset,,server.h,master_repl_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2227,392015,second_replid_offset,3,redisServer.second_replid_offset,,server.h,second_replid_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2228,392016,fsynced_reploff_pending,3,redisServer.fsynced_reploff_pending,,server.h,fsynced_reploff_pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2229,392017,fsynced_reploff,3,redisServer.fsynced_reploff,,server.h,fsynced_reploff,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2230,392018,slaveseldb,3,redisServer.slaveseldb,,server.h,slaveseldb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2231,392019,repl_ping_slave_period,3,redisServer.repl_ping_slave_period,,server.h,repl_ping_slave_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2232,392020,repl_backlog,3,redisServer.repl_backlog,,server.h,*repl_backlog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2233,392021,repl_backlog_size,3,redisServer.repl_backlog_size,,server.h,repl_backlog_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2234,392022,repl_backlog_time_limit,3,redisServer.repl_backlog_time_limit,,server.h,repl_backlog_time_limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2235,392023,repl_no_slaves_since,3,redisServer.repl_no_slaves_since,,server.h,repl_no_slaves_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2236,392024,repl_min_slaves_to_write,3,redisServer.repl_min_slaves_to_write,,server.h,repl_min_slaves_to_write,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2237,392025,repl_min_slaves_max_lag,3,redisServer.repl_min_slaves_max_lag,,server.h,repl_min_slaves_max_lag,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2238,392026,repl_good_slaves_count,3,redisServer.repl_good_slaves_count,,server.h,repl_good_slaves_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2239,392027,repl_diskless_sync,3,redisServer.repl_diskless_sync,,server.h,repl_diskless_sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2240,392028,repl_diskless_load,3,redisServer.repl_diskless_load,,server.h,repl_diskless_load,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2241,392029,repl_diskless_sync_delay,3,redisServer.repl_diskless_sync_delay,,server.h,repl_diskless_sync_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2242,392030,repl_diskless_sync_max_replicas,3,redisServer.repl_diskless_sync_max_replicas,,server.h,repl_diskless_sync_max_replicas,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2243,392031,repl_buffer_mem,3,redisServer.repl_buffer_mem,,server.h,repl_buffer_mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2244,392032,repl_buffer_blocks,3,redisServer.repl_buffer_blocks,,server.h,*repl_buffer_blocks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2245,392033,masteruser,3,redisServer.masteruser,,server.h,*masteruser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2246,392034,masterauth,3,redisServer.masterauth,,server.h,masterauth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2247,392035,masterhost,3,redisServer.masterhost,,server.h,*masterhost,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2248,392036,masterport,3,redisServer.masterport,,server.h,masterport,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2249,392037,repl_timeout,3,redisServer.repl_timeout,,server.h,repl_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2250,392038,master,3,redisServer.master,,server.h,*master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2251,392039,cached_master,3,redisServer.cached_master,,server.h,*cached_master,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2252,392040,repl_syncio_timeout,3,redisServer.repl_syncio_timeout,,server.h,repl_syncio_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2253,392041,repl_state,3,redisServer.repl_state,,server.h,repl_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2254,392042,repl_transfer_size,3,redisServer.repl_transfer_size,,server.h,repl_transfer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2255,392043,repl_transfer_read,3,redisServer.repl_transfer_read,,server.h,repl_transfer_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2256,392044,repl_transfer_last_fsync_off,3,redisServer.repl_transfer_last_fsync_off,,server.h,repl_transfer_last_fsync_off,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2257,392045,repl_transfer_s,3,redisServer.repl_transfer_s,,server.h,*repl_transfer_s,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2258,392046,repl_transfer_fd,3,redisServer.repl_transfer_fd,,server.h,repl_transfer_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2259,392047,repl_transfer_tmpfile,3,redisServer.repl_transfer_tmpfile,,server.h,*repl_transfer_tmpfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2260,392048,repl_transfer_lastio,3,redisServer.repl_transfer_lastio,,server.h,repl_transfer_lastio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2261,392049,repl_serve_stale_data,3,redisServer.repl_serve_stale_data,,server.h,repl_serve_stale_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2262,392050,repl_slave_ro,3,redisServer.repl_slave_ro,,server.h,repl_slave_ro,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2263,392051,repl_slave_ignore_maxmemory,3,redisServer.repl_slave_ignore_maxmemory,,server.h,repl_slave_ignore_maxmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2264,392052,repl_down_since,3,redisServer.repl_down_since,,server.h,repl_down_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2265,392053,repl_disable_tcp_nodelay,3,redisServer.repl_disable_tcp_nodelay,,server.h,repl_disable_tcp_nodelay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2266,392054,slave_priority,3,redisServer.slave_priority,,server.h,slave_priority,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2267,392055,replica_announced,3,redisServer.replica_announced,,server.h,replica_announced,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2268,392056,slave_announce_port,3,redisServer.slave_announce_port,,server.h,slave_announce_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2269,392057,slave_announce_ip,3,redisServer.slave_announce_ip,,server.h,*slave_announce_ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2270,392058,propagation_error_behavior,3,redisServer.propagation_error_behavior,,server.h,propagation_error_behavior,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2271,392059,repl_ignore_disk_write_error,3,redisServer.repl_ignore_disk_write_error,,server.h,repl_ignore_disk_write_error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2272,392060,master_replid,3,redisServer.master_replid,,server.h,master_replid[CONFIG_RUN_ID_SIZE+1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2273,392061,master_initial_offset,3,redisServer.master_initial_offset,,server.h,master_initial_offset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2274,392062,repl_slave_lazy_flush,3,redisServer.repl_slave_lazy_flush,,server.h,repl_slave_lazy_flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2275,392063,clients_waiting_acks,3,redisServer.clients_waiting_acks,,server.h,*clients_waiting_acks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2276,392064,get_ack_from_slaves,3,redisServer.get_ack_from_slaves,,server.h,get_ack_from_slaves,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2277,392065,maxclients,3,redisServer.maxclients,,server.h,maxclients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2278,392066,maxmemory,3,redisServer.maxmemory,,server.h,maxmemory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2279,392067,maxmemory_clients,3,redisServer.maxmemory_clients,,server.h,maxmemory_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2280,392068,maxmemory_policy,3,redisServer.maxmemory_policy,,server.h,maxmemory_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2281,392069,maxmemory_samples,3,redisServer.maxmemory_samples,,server.h,maxmemory_samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2282,392070,maxmemory_eviction_tenacity,3,redisServer.maxmemory_eviction_tenacity,,server.h,maxmemory_eviction_tenacity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2283,392071,lfu_log_factor,3,redisServer.lfu_log_factor,,server.h,lfu_log_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2284,392072,lfu_decay_time,3,redisServer.lfu_decay_time,,server.h,lfu_decay_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2285,392073,proto_max_bulk_len,3,redisServer.proto_max_bulk_len,,server.h,proto_max_bulk_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2286,392074,oom_score_adj_values,3,redisServer.oom_score_adj_values,,server.h,oom_score_adj_values[CONFIG_OOM_COUNT],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2287,392075,oom_score_adj,3,redisServer.oom_score_adj,,server.h,oom_score_adj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2288,392076,disable_thp,3,redisServer.disable_thp,,server.h,disable_thp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2289,392077,blocked_clients,3,redisServer.blocked_clients,,server.h,blocked_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2290,392078,blocked_clients_by_type,3,redisServer.blocked_clients_by_type,,server.h,blocked_clients_by_type[BLOCKED_NUM],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2291,392079,unblocked_clients,3,redisServer.unblocked_clients,,server.h,*unblocked_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2292,392080,ready_keys,3,redisServer.ready_keys,,server.h,*ready_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2293,392081,tracking_clients,3,redisServer.tracking_clients,,server.h,tracking_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2294,392082,tracking_table_max_keys,3,redisServer.tracking_table_max_keys,,server.h,tracking_table_max_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2295,392083,tracking_pending_keys,3,redisServer.tracking_pending_keys,,server.h,*tracking_pending_keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2296,392084,pending_push_messages,3,redisServer.pending_push_messages,,server.h,*pending_push_messages,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2297,392085,sort_desc,3,redisServer.sort_desc,,server.h,sort_desc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2298,392086,sort_alpha,3,redisServer.sort_alpha,,server.h,sort_alpha,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2299,392087,sort_bypattern,3,redisServer.sort_bypattern,,server.h,sort_bypattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2300,392088,sort_store,3,redisServer.sort_store,,server.h,sort_store,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2301,392089,hash_max_listpack_entries,3,redisServer.hash_max_listpack_entries,,server.h,hash_max_listpack_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2302,392090,hash_max_listpack_value,3,redisServer.hash_max_listpack_value,,server.h,hash_max_listpack_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2303,392091,set_max_intset_entries,3,redisServer.set_max_intset_entries,,server.h,set_max_intset_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2304,392092,set_max_listpack_entries,3,redisServer.set_max_listpack_entries,,server.h,set_max_listpack_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2305,392093,set_max_listpack_value,3,redisServer.set_max_listpack_value,,server.h,set_max_listpack_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2306,392094,zset_max_listpack_entries,3,redisServer.zset_max_listpack_entries,,server.h,zset_max_listpack_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2307,392095,zset_max_listpack_value,3,redisServer.zset_max_listpack_value,,server.h,zset_max_listpack_value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2308,392096,hll_sparse_max_bytes,3,redisServer.hll_sparse_max_bytes,,server.h,hll_sparse_max_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2309,392097,stream_node_max_bytes,3,redisServer.stream_node_max_bytes,,server.h,stream_node_max_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2310,392098,stream_node_max_entries,3,redisServer.stream_node_max_entries,,server.h,stream_node_max_entries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2311,392099,list_max_listpack_size,3,redisServer.list_max_listpack_size,,server.h,list_max_listpack_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2312,392100,list_compress_depth,3,redisServer.list_compress_depth,,server.h,list_compress_depth,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2313,392101,unixtime,3,redisServer.unixtime,,server.h,unixtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
2314,392102,timezone,3,redisServer.timezone,,server.h,timezone,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2315,392103,daylight_active,3,redisServer.daylight_active,,server.h,daylight_active,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2316,392104,mstime,3,redisServer.mstime,,server.h,mstime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2317,392105,ustime,3,redisServer.ustime,,server.h,ustime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2318,392106,cmd_time_snapshot,3,redisServer.cmd_time_snapshot,,server.h,cmd_time_snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2319,392107,blocking_op_nesting,3,redisServer.blocking_op_nesting,,server.h,blocking_op_nesting,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2320,392108,blocked_last_cron,3,redisServer.blocked_last_cron,,server.h,blocked_last_cron,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2321,392109,pubsub_channels,3,redisServer.pubsub_channels,,server.h,*pubsub_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2322,392110,pubsub_patterns,3,redisServer.pubsub_patterns,,server.h,*pubsub_patterns,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2323,392111,notify_keyspace_events,3,redisServer.notify_keyspace_events,,server.h,notify_keyspace_events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2324,392112,pubsubshard_channels,3,redisServer.pubsubshard_channels,,server.h,*pubsubshard_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2325,392113,cluster_enabled,3,redisServer.cluster_enabled,,server.h,cluster_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
2326,392114,cluster_port,3,redisServer.cluster_port,,server.h,cluster_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2327,392115,cluster_node_timeout,3,redisServer.cluster_node_timeout,,server.h,cluster_node_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2328,392116,cluster_ping_interval,3,redisServer.cluster_ping_interval,,server.h,cluster_ping_interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2329,392117,cluster_configfile,3,redisServer.cluster_configfile,,server.h,*cluster_configfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2330,392119,cluster,3,redisServer.cluster,,server.h,*cluster,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2331,392120,cluster_migration_barrier,3,redisServer.cluster_migration_barrier,,server.h,cluster_migration_barrier,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2332,392121,cluster_allow_replica_migration,3,redisServer.cluster_allow_replica_migration,,server.h,cluster_allow_replica_migration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2333,392122,cluster_slave_validity_factor,3,redisServer.cluster_slave_validity_factor,,server.h,cluster_slave_validity_factor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2334,392123,cluster_require_full_coverage,3,redisServer.cluster_require_full_coverage,,server.h,cluster_require_full_coverage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2335,392124,cluster_slave_no_failover,3,redisServer.cluster_slave_no_failover,,server.h,cluster_slave_no_failover,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2336,392125,cluster_announce_ip,3,redisServer.cluster_announce_ip,,server.h,*cluster_announce_ip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2337,392126,cluster_announce_hostname,3,redisServer.cluster_announce_hostname,,server.h,*cluster_announce_hostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2338,392127,cluster_announce_human_nodename,3,redisServer.cluster_announce_human_nodename,,server.h,*cluster_announce_human_nodename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2339,392128,cluster_preferred_endpoint_type,3,redisServer.cluster_preferred_endpoint_type,,server.h,cluster_preferred_endpoint_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2340,392129,cluster_announce_port,3,redisServer.cluster_announce_port,,server.h,cluster_announce_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2341,392130,cluster_announce_tls_port,3,redisServer.cluster_announce_tls_port,,server.h,cluster_announce_tls_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2342,392131,cluster_announce_bus_port,3,redisServer.cluster_announce_bus_port,,server.h,cluster_announce_bus_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2343,392132,cluster_module_flags,3,redisServer.cluster_module_flags,,server.h,cluster_module_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2344,392133,cluster_allow_reads_when_down,3,redisServer.cluster_allow_reads_when_down,,server.h,cluster_allow_reads_when_down,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2345,392134,cluster_config_file_lock_fd,3,redisServer.cluster_config_file_lock_fd,,server.h,cluster_config_file_lock_fd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2346,392135,cluster_link_msg_queue_limit_bytes,3,redisServer.cluster_link_msg_queue_limit_bytes,,server.h,cluster_link_msg_queue_limit_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2347,392136,cluster_drop_packet_filter,3,redisServer.cluster_drop_packet_filter,,server.h,cluster_drop_packet_filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2348,392137,busy_reply_threshold,3,redisServer.busy_reply_threshold,,server.h,busy_reply_threshold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2349,392138,pre_command_oom_state,3,redisServer.pre_command_oom_state,,server.h,pre_command_oom_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2350,392139,script_disable_deny_script,3,redisServer.script_disable_deny_script,,server.h,script_disable_deny_script,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2351,392140,lazyfree_lazy_eviction,3,redisServer.lazyfree_lazy_eviction,,server.h,lazyfree_lazy_eviction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2352,392141,lazyfree_lazy_expire,3,redisServer.lazyfree_lazy_expire,,server.h,lazyfree_lazy_expire,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2353,392142,lazyfree_lazy_server_del,3,redisServer.lazyfree_lazy_server_del,,server.h,lazyfree_lazy_server_del,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2354,392143,lazyfree_lazy_user_del,3,redisServer.lazyfree_lazy_user_del,,server.h,lazyfree_lazy_user_del,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2355,392144,lazyfree_lazy_user_flush,3,redisServer.lazyfree_lazy_user_flush,,server.h,lazyfree_lazy_user_flush,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2356,392145,latency_monitor_threshold,3,redisServer.latency_monitor_threshold,,server.h,latency_monitor_threshold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2357,392146,latency_events,3,redisServer.latency_events,,server.h,*latency_events,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2358,392147,acl_filename,3,redisServer.acl_filename,,server.h,*acl_filename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2359,392148,acllog_max_len,3,redisServer.acllog_max_len,,server.h,acllog_max_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2360,392149,requirepass,3,redisServer.requirepass,,server.h,requirepass,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2361,392150,acl_pubsub_default,3,redisServer.acl_pubsub_default,,server.h,acl_pubsub_default,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2362,392151,acl_info,3,redisServer.acl_info,,server.h,acl_info,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2363,392152,watchdog_period,3,redisServer.watchdog_period,,server.h,watchdog_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2364,392153,system_memory_size,3,redisServer.system_memory_size,,server.h,system_memory_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2365,392154,tls_cluster,3,redisServer.tls_cluster,,server.h,tls_cluster,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2366,392155,tls_replication,3,redisServer.tls_replication,,server.h,tls_replication,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2367,392156,tls_auth_clients,3,redisServer.tls_auth_clients,,server.h,tls_auth_clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2368,392157,tls_ctx_config,3,redisServer.tls_ctx_config,,server.h,tls_ctx_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2369,392158,server_cpulist,3,redisServer.server_cpulist,,server.h,*server_cpulist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2370,392159,bio_cpulist,3,redisServer.bio_cpulist,,server.h,*bio_cpulist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2371,392160,aof_rewrite_cpulist,3,redisServer.aof_rewrite_cpulist,,server.h,*aof_rewrite_cpulist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2372,392161,bgsave_cpulist,3,redisServer.bgsave_cpulist,,server.h,*bgsave_cpulist,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2373,392163,sentinel_config,3,redisServer.sentinel_config,,server.h,*sentinel_config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2374,392164,failover_end_time,3,redisServer.failover_end_time,,server.h,failover_end_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2375,392165,force_failover,3,redisServer.force_failover,,server.h,force_failover,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2376,392166,target_replica_host,3,redisServer.target_replica_host,,server.h,*target_replica_host,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2377,392167,target_replica_port,3,redisServer.target_replica_port,,server.h,target_replica_port,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2378,392168,failover_state,3,redisServer.failover_state,,server.h,failover_state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2379,392169,cluster_allow_pubsubshard_when_down,3,redisServer.cluster_allow_pubsubshard_when_down,,server.h,cluster_allow_pubsubshard_when_down,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2380,392170,reply_buffer_peak_reset_time,3,redisServer.reply_buffer_peak_reset_time,,server.h,reply_buffer_peak_reset_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2381,392171,reply_buffer_resizing_enabled,3,redisServer.reply_buffer_resizing_enabled,,server.h,reply_buffer_resizing_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2382,392172,locale_collate,3,redisServer.locale_collate,,server.h,*locale_collate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2383,392240,pos,3,keyReference.pos,,server.h,pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2384,392241,flags,3,keyReference.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2385,392244,keysbuf,3,getKeysResult.keysbuf,,server.h,keysbuf[MAX_KEYS_BUFFER],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2386,392245,keys,3,getKeysResult.keys,,server.h,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
2387,392246,numkeys,3,getKeysResult.numkeys,,server.h,numkeys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
2388,392247,size,3,getKeysResult.size,,server.h,size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
2389,392258,KSPEC_BS_INVALID,3,kspec_bs_type.KSPEC_BS_INVALID,,server.h,KSPEC_BS_INVALID = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2390,392259,KSPEC_BS_UNKNOWN,3,kspec_bs_type.KSPEC_BS_UNKNOWN,,server.h,KSPEC_BS_UNKNOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2391,392260,KSPEC_BS_INDEX,3,kspec_bs_type.KSPEC_BS_INDEX,,server.h,KSPEC_BS_INDEX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2392,392261,KSPEC_BS_KEYWORD,3,kspec_bs_type.KSPEC_BS_KEYWORD,,server.h,KSPEC_BS_KEYWORD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2393,392271,KSPEC_FK_INVALID,3,kspec_fk_type.KSPEC_FK_INVALID,,server.h,KSPEC_FK_INVALID = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2394,392272,KSPEC_FK_UNKNOWN,3,kspec_fk_type.KSPEC_FK_UNKNOWN,,server.h,KSPEC_FK_UNKNOWN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2395,392273,KSPEC_FK_RANGE,3,kspec_fk_type.KSPEC_FK_RANGE,,server.h,KSPEC_FK_RANGE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2396,392274,KSPEC_FK_KEYNUM,3,kspec_fk_type.KSPEC_FK_KEYNUM,,server.h,KSPEC_FK_KEYNUM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2397,392284,notes,3,keySpec.notes,,server.h,*notes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2398,392285,flags,3,keySpec.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2399,392286,begin_search_type,3,keySpec.begin_search_type,,server.h,begin_search_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2400,392289,pos,3,keySpec.bs.index.pos,,server.h,pos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2401,392290,index,3,keySpec.bs.index,,server.h,index,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2402,392292,keyword,3,keySpec.bs.keyword.keyword,,server.h,*keyword,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2403,392293,startfrom,3,keySpec.bs.keyword.startfrom,,server.h,startfrom,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2404,392294,keyword,3,keySpec.bs.keyword,,server.h,keyword,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2405,392295,bs,3,keySpec.bs,,server.h,bs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2406,392296,find_keys_type,3,keySpec.find_keys_type,,server.h,find_keys_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2407,392299,lastkey,3,keySpec.fk.range.lastkey,,server.h,lastkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2408,392300,keystep,3,keySpec.fk.range.keystep,,server.h,keystep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2409,392301,limit,3,keySpec.fk.range.limit,,server.h,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2410,392302,range,3,keySpec.fk.range,,server.h,range,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2411,392304,keynumidx,3,keySpec.fk.keynum.keynumidx,,server.h,keynumidx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2412,392305,firstkey,3,keySpec.fk.keynum.firstkey,,server.h,firstkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2413,392306,keystep,3,keySpec.fk.keynum.keystep,,server.h,keystep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2414,392307,keynum,3,keySpec.fk.keynum,,server.h,keynum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2415,392308,fk,3,keySpec.fk,,server.h,fk,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2416,392311,since,3,commandHistory.since,,server.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2417,392312,changes,3,commandHistory.changes,,server.h,*changes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2418,392315,COMMAND_GROUP_GENERIC,3,redisCommandGroup.COMMAND_GROUP_GENERIC,,server.h,COMMAND_GROUP_GENERIC,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2419,392316,COMMAND_GROUP_STRING,3,redisCommandGroup.COMMAND_GROUP_STRING,,server.h,COMMAND_GROUP_STRING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2420,392317,COMMAND_GROUP_LIST,3,redisCommandGroup.COMMAND_GROUP_LIST,,server.h,COMMAND_GROUP_LIST,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2421,392318,COMMAND_GROUP_SET,3,redisCommandGroup.COMMAND_GROUP_SET,,server.h,COMMAND_GROUP_SET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2422,392319,COMMAND_GROUP_SORTED_SET,3,redisCommandGroup.COMMAND_GROUP_SORTED_SET,,server.h,COMMAND_GROUP_SORTED_SET,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2423,392320,COMMAND_GROUP_HASH,3,redisCommandGroup.COMMAND_GROUP_HASH,,server.h,COMMAND_GROUP_HASH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2424,392321,COMMAND_GROUP_PUBSUB,3,redisCommandGroup.COMMAND_GROUP_PUBSUB,,server.h,COMMAND_GROUP_PUBSUB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2425,392322,COMMAND_GROUP_TRANSACTIONS,3,redisCommandGroup.COMMAND_GROUP_TRANSACTIONS,,server.h,COMMAND_GROUP_TRANSACTIONS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2426,392323,COMMAND_GROUP_CONNECTION,3,redisCommandGroup.COMMAND_GROUP_CONNECTION,,server.h,COMMAND_GROUP_CONNECTION,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2427,392324,COMMAND_GROUP_SERVER,3,redisCommandGroup.COMMAND_GROUP_SERVER,,server.h,COMMAND_GROUP_SERVER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2428,392325,COMMAND_GROUP_SCRIPTING,3,redisCommandGroup.COMMAND_GROUP_SCRIPTING,,server.h,COMMAND_GROUP_SCRIPTING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2429,392326,COMMAND_GROUP_HYPERLOGLOG,3,redisCommandGroup.COMMAND_GROUP_HYPERLOGLOG,,server.h,COMMAND_GROUP_HYPERLOGLOG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2430,392327,COMMAND_GROUP_CLUSTER,3,redisCommandGroup.COMMAND_GROUP_CLUSTER,,server.h,COMMAND_GROUP_CLUSTER,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2431,392328,COMMAND_GROUP_SENTINEL,3,redisCommandGroup.COMMAND_GROUP_SENTINEL,,server.h,COMMAND_GROUP_SENTINEL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2432,392329,COMMAND_GROUP_GEO,3,redisCommandGroup.COMMAND_GROUP_GEO,,server.h,COMMAND_GROUP_GEO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2433,392330,COMMAND_GROUP_STREAM,3,redisCommandGroup.COMMAND_GROUP_STREAM,,server.h,COMMAND_GROUP_STREAM,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2434,392331,COMMAND_GROUP_BITMAP,3,redisCommandGroup.COMMAND_GROUP_BITMAP,,server.h,COMMAND_GROUP_BITMAP,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2435,392332,COMMAND_GROUP_MODULE,3,redisCommandGroup.COMMAND_GROUP_MODULE,,server.h,COMMAND_GROUP_MODULE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2436,392348,declared_name,3,redisCommand.declared_name,,server.h,*declared_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2437,392349,summary,3,redisCommand.summary,,server.h,*summary,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2438,392350,complexity,3,redisCommand.complexity,,server.h,*complexity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2439,392351,since,3,redisCommand.since,,server.h,*since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2440,392352,doc_flags,3,redisCommand.doc_flags,,server.h,doc_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2441,392353,replaced_by,3,redisCommand.replaced_by,,server.h,*replaced_by,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2442,392354,deprecated_since,3,redisCommand.deprecated_since,,server.h,*deprecated_since,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2443,392355,group,3,redisCommand.group,,server.h,group,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2444,392356,history,3,redisCommand.history,,server.h,*history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
2445,392357,num_history,3,redisCommand.num_history,,server.h,num_history,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2446,392358,tips,3,redisCommand.tips,,server.h,**tips,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2447,392359,num_tips,3,redisCommand.num_tips,,server.h,num_tips,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2448,392360,proc,3,redisCommand.proc,,server.h,*proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
2449,392361,arity,3,redisCommand.arity,,server.h,arity,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2450,392362,flags,3,redisCommand.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,33,0,1,1,0,0,,0,0,0,0,0,
2451,392363,acl_categories,3,redisCommand.acl_categories,,server.h,acl_categories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
2452,392364,key_specs,3,redisCommand.key_specs,,server.h,*key_specs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,63,0,1,1,0,0,,0,0,0,0,0,
2453,392365,key_specs_num,3,redisCommand.key_specs_num,,server.h,key_specs_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
2454,392366,getkeys_proc,3,redisCommand.getkeys_proc,,server.h,*getkeys_proc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2455,392367,num_args,3,redisCommand.num_args,,server.h,num_args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2456,392369,subcommands,3,redisCommand.subcommands,,server.h,*subcommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2457,392371,args,3,redisCommand.args,,server.h,*args,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2458,392373,reply_schema,3,redisCommand.reply_schema,,server.h,*reply_schema,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2459,392374,microseconds,3,redisCommand.microseconds,,server.h,microseconds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2460,392375,calls,3,redisCommand.calls,,server.h,calls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2461,392376,rejected_calls,3,redisCommand.rejected_calls,,server.h,rejected_calls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2462,392377,failed_calls,3,redisCommand.failed_calls,,server.h,failed_calls,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2463,392378,id,3,redisCommand.id,,server.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2464,392379,fullname,3,redisCommand.fullname,,server.h,fullname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,34,0,1,1,0,0,,0,0,0,0,0,
2465,392381,latency_histogram,3,redisCommand.latency_histogram,,server.h,* latency_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
2466,392382,legacy_range_key_spec,3,redisCommand.legacy_range_key_spec,,server.h,legacy_range_key_spec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
2467,392383,subcommands_dict,3,redisCommand.subcommands_dict,,server.h,*subcommands_dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,39,0,1,1,0,0,,0,0,0,0,0,
2468,392385,parent,3,redisCommand.parent,,server.h,*parent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2469,392387,module_cmd,3,redisCommand.module_cmd,,server.h,*module_cmd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2470,392389,count,3,redisError.count,,server.h,count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2471,392391,name,3,redisFunctionSym.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2472,392392,pointer,3,redisFunctionSym.pointer,,server.h,pointer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2473,392394,obj,3,_redisSortObject.obj,,server.h,*obj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2474,392396,score,3,_redisSortObject.u.score,,server.h,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2475,392397,cmpobj,3,_redisSortObject.u.cmpobj,,server.h,*cmpobj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2476,392398,u,3,_redisSortObject.u,,server.h,u,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2477,392401,type,3,_redisSortOperation.type,,server.h,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2478,392402,pattern,3,_redisSortOperation.pattern,,server.h,*pattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2479,392405,subject,3,listTypeIterator.subject,,server.h,*subject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2480,392406,encoding,3,listTypeIterator.encoding,,server.h,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2481,392407,direction,3,listTypeIterator.direction,,server.h,direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2482,392408,lpi,3,listTypeIterator.lpi,,server.h,*lpi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2483,392409,iter,3,listTypeIterator.iter,,server.h,*iter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2484,392412,li,3,listTypeEntry.li,,server.h,*li,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2485,392413,lpe,3,listTypeEntry.lpe,,server.h,*lpe,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2486,392414,entry,3,listTypeEntry.entry,,server.h,entry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2487,392417,subject,3,setTypeIterator.subject,,server.h,*subject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2488,392418,encoding,3,setTypeIterator.encoding,,server.h,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2489,392419,ii,3,setTypeIterator.ii,,server.h,ii,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2490,392420,di,3,setTypeIterator.di,,server.h,*di,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2491,392421,lpi,3,setTypeIterator.lpi,,server.h,*lpi,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2492,392424,subject,3,hashTypeIterator.subject,,server.h,*subject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2493,392425,encoding,3,hashTypeIterator.encoding,,server.h,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2494,392426,fptr,3,hashTypeIterator.fptr,,server.h,*fptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2495,392427,vptr,3,hashTypeIterator.vptr,,server.h,*vptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2496,392428,di,3,hashTypeIterator.di,,server.h,*di,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2497,392429,de,3,hashTypeIterator.de,,server.h,*de,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2498,393694,LIST_CONV_AUTO,3,list_conv_type.LIST_CONV_AUTO,,server.h,LIST_CONV_AUTO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2499,393695,LIST_CONV_GROWING,3,list_conv_type.LIST_CONV_GROWING,,server.h,LIST_CONV_GROWING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2500,393696,LIST_CONV_SHRINKING,3,list_conv_type.LIST_CONV_SHRINKING,,server.h,LIST_CONV_SHRINKING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2501,394555,AUTH_OK,3,AuthResult.AUTH_OK,,server.h,AUTH_OK = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2502,394556,AUTH_ERR,3,AuthResult.AUTH_ERR,,server.h,AUTH_ERR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2503,394557,AUTH_NOT_HANDLED,3,AuthResult.AUTH_NOT_HANDLED,,server.h,AUTH_NOT_HANDLED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2504,394558,AUTH_BLOCKED,3,AuthResult.AUTH_BLOCKED,,server.h,AUTH_BLOCKED,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2505,394748,min,3,zrangespec.min,,server.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2506,394749,max,3,zrangespec.max,,server.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2507,394750,minex,3,zrangespec.minex,,server.h,minex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2508,394751,maxex,3,zrangespec.maxex,,server.h,maxex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2509,394754,min,3,zlexrangespec.min,,server.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2510,394755,max,3,zlexrangespec.max,,server.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2511,394756,minex,3,zlexrangespec.minex,,server.h,minex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2512,394757,maxex,3,zlexrangespec.maxex,,server.h,maxex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2513,395621,name,3,configEnum.name,,server.h,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2514,395622,val,3,configEnum.val,,server.h,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2515,395625,BOOL_CONFIG,3,configType.BOOL_CONFIG,,server.h,BOOL_CONFIG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2516,395626,NUMERIC_CONFIG,3,configType.NUMERIC_CONFIG,,server.h,NUMERIC_CONFIG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2517,395627,STRING_CONFIG,3,configType.STRING_CONFIG,,server.h,STRING_CONFIG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2518,395628,SDS_CONFIG,3,configType.SDS_CONFIG,,server.h,SDS_CONFIG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2519,395629,ENUM_CONFIG,3,configType.ENUM_CONFIG,,server.h,ENUM_CONFIG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2520,395630,SPECIAL_CONFIG,3,configType.SPECIAL_CONFIG,,server.h,SPECIAL_CONFIG,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2521,396455,flags,3,luaScript.flags,,server.h,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2522,396456,body,3,luaScript.body,,server.h,*body,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2523,407584,state,3,SHA1_CTX.state,,sha1.h,state[5],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2524,407585,count,3,SHA1_CTX.count,,sha1.h,count[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2525,407586,buffer,3,SHA1_CTX.buffer,,sha1.h,buffer[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2526,408626,data,3,SHA256_CTX.data,,sha256.h,data[64],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
2527,408627,datalen,3,SHA256_CTX.datalen,,sha256.h,datalen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2528,408628,bitlen,3,SHA256_CTX.bitlen,,sha256.h,bitlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
2529,408629,state,3,SHA256_CTX.state,,sha256.h,state[8],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
2530,411167,argv,3,slowlogEntry.argv,,slowlog.h,**argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2531,411168,argc,3,slowlogEntry.argc,,slowlog.h,argc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2532,411169,id,3,slowlogEntry.id,,slowlog.h,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2533,411170,duration,3,slowlogEntry.duration,,slowlog.h,duration,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2534,411171,time,3,slowlogEntry.time,,slowlog.h,time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2535,411172,cname,3,slowlogEntry.cname,,slowlog.h,cname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2536,411173,peerid,3,slowlogEntry.peerid,,slowlog.h,peerid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2537,415401,value,3,sample.value,,sparkline.h,value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2538,415402,label,3,sample.label,,sparkline.h,*label,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2539,415404,length,3,sequence.length,,sparkline.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
2540,415405,labels,3,sequence.labels,,sparkline.h,labels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2541,415407,samples,3,sequence.samples,,sparkline.h,*samples,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2542,415408,min,3,sequence.min,,sparkline.h,min,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2543,415409,max,3,sequence.max,,sparkline.h,max,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2544,415453,ms,3,streamID.ms,,stream.h,ms,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
2545,415454,seq,3,streamID.seq,,stream.h,seq,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,17,0,1,1,0,0,,0,0,0,0,0,
2546,415457,rax,3,stream.rax,,stream.h,*rax,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2547,415458,length,3,stream.length,,stream.h,length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
2548,415459,last_id,3,stream.last_id,,stream.h,last_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2549,415460,first_id,3,stream.first_id,,stream.h,first_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2550,415461,max_deleted_entry_id,3,stream.max_deleted_entry_id,,stream.h,max_deleted_entry_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2551,415462,entries_added,3,stream.entries_added,,stream.h,entries_added,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2552,415463,cgroups,3,stream.cgroups,,stream.h,*cgroups,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2553,415466,stream,3,streamIterator.stream,,stream.h,*stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2554,415467,master_id,3,streamIterator.master_id,,stream.h,master_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2555,415468,master_fields_count,3,streamIterator.master_fields_count,,stream.h,master_fields_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2556,415469,master_fields_start,3,streamIterator.master_fields_start,,stream.h,*master_fields_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2557,415470,master_fields_ptr,3,streamIterator.master_fields_ptr,,stream.h,*master_fields_ptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2558,415471,entry_flags,3,streamIterator.entry_flags,,stream.h,entry_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2559,415472,rev,3,streamIterator.rev,,stream.h,rev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2560,415473,skip_tombstones,3,streamIterator.skip_tombstones,,stream.h,skip_tombstones,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2561,415474,start_key,3,streamIterator.start_key,,stream.h,start_key[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2562,415475,end_key,3,streamIterator.end_key,,stream.h,end_key[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2563,415476,ri,3,streamIterator.ri,,stream.h,ri,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2564,415477,lp,3,streamIterator.lp,,stream.h,*lp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2565,415478,lp_ele,3,streamIterator.lp_ele,,stream.h,*lp_ele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2566,415479,lp_flags,3,streamIterator.lp_flags,,stream.h,*lp_flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2567,415480,field_buf,3,streamIterator.field_buf,,stream.h,field_buf[LP_INTBUF_SIZE],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2568,415481,value_buf,3,streamIterator.value_buf,,stream.h,value_buf[LP_INTBUF_SIZE],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2569,415500,last_id,3,streamCG.last_id,,stream.h,last_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2570,415501,entries_read,3,streamCG.entries_read,,stream.h,entries_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2571,415502,pel,3,streamCG.pel,,stream.h,*pel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2572,415503,consumers,3,streamCG.consumers,,stream.h,*consumers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2573,415506,seen_time,3,streamConsumer.seen_time,,stream.h,seen_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2574,415507,active_time,3,streamConsumer.active_time,,stream.h,active_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2575,415508,name,3,streamConsumer.name,,stream.h,name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2576,415509,pel,3,streamConsumer.pel,,stream.h,*pel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2577,415512,delivery_time,3,streamNACK.delivery_time,,stream.h,delivery_time,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2578,415513,delivery_count,3,streamNACK.delivery_count,,stream.h,delivery_count,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2579,415514,consumer,3,streamNACK.consumer,,stream.h,*consumer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2580,415517,keyname,3,streamPropInfo.keyname,,stream.h,*keyname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2581,415518,groupname,3,streamPropInfo.groupname,,stream.h,*groupname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2582,416211,name,3,check.name,,syscheck.c,*name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2583,433796,id,3,streamAddTrimArgs.id,,t_stream.c,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2584,433797,id_given,3,streamAddTrimArgs.id_given,,t_stream.c,id_given,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2585,433798,seq_given,3,streamAddTrimArgs.seq_given,,t_stream.c,seq_given,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2586,433799,no_mkstream,3,streamAddTrimArgs.no_mkstream,,t_stream.c,no_mkstream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2587,433800,trim_strategy,3,streamAddTrimArgs.trim_strategy,,t_stream.c,trim_strategy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2588,433801,trim_strategy_arg_idx,3,streamAddTrimArgs.trim_strategy_arg_idx,,t_stream.c,trim_strategy_arg_idx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2589,433802,approx_trim,3,streamAddTrimArgs.approx_trim,,t_stream.c,approx_trim,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2590,433803,limit,3,streamAddTrimArgs.limit,,t_stream.c,limit,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2591,433804,maxlen,3,streamAddTrimArgs.maxlen,,t_stream.c,maxlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2592,433805,minid,3,streamAddTrimArgs.minid,,t_stream.c,minid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
2593,456024,ZRANGE_AUTO,3,zrange_type.ZRANGE_AUTO,,t_zset.c,ZRANGE_AUTO = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2594,456025,ZRANGE_RANK,3,zrange_type.ZRANGE_RANK,,t_zset.c,ZRANGE_RANK,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2595,456026,ZRANGE_SCORE,3,zrange_type.ZRANGE_SCORE,,t_zset.c,ZRANGE_SCORE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2596,456027,ZRANGE_LEX,3,zrange_type.ZRANGE_LEX,,t_zset.c,ZRANGE_LEX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2597,456548,subject,3,zsetopsrc.subject,,t_zset.c,*subject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2598,456549,type,3,zsetopsrc.type,,t_zset.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2599,456550,encoding,3,zsetopsrc.encoding,,t_zset.c,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2600,456551,weight,3,zsetopsrc.weight,,t_zset.c,weight,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2601,456555,is,3,zsetopsrc.iter._iterset.is.is,,t_zset.c,*is,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2602,456556,ii,3,zsetopsrc.iter._iterset.is.ii,,t_zset.c,ii,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2603,456557,is,3,zsetopsrc.iter._iterset.is,,t_zset.c,is,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2604,456559,dict,3,zsetopsrc.iter._iterset.ht.dict,,t_zset.c,*dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2605,456560,di,3,zsetopsrc.iter._iterset.ht.di,,t_zset.c,*di,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2606,456561,de,3,zsetopsrc.iter._iterset.ht.de,,t_zset.c,*de,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2607,456562,ht,3,zsetopsrc.iter._iterset.ht,,t_zset.c,ht,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2608,456564,lp,3,zsetopsrc.iter._iterset.lp.lp,,t_zset.c,*lp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2609,456565,p,3,zsetopsrc.iter._iterset.lp.p,,t_zset.c,*p,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2610,456566,lp,3,zsetopsrc.iter._iterset.lp,,t_zset.c,lp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2611,456567,set,3,zsetopsrc.iter.set,,t_zset.c,set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2612,456570,zl,3,zsetopsrc.iter._iterzset.zl.zl,,t_zset.c,*zl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2613,456571,eptr,3,zsetopsrc.iter._iterzset.zl.eptr,,t_zset.c,*eptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2614,456572,sptr,3,zsetopsrc.iter._iterzset.zl.sptr,,t_zset.c,*sptr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2615,456573,zl,3,zsetopsrc.iter._iterzset.zl,,t_zset.c,zl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2616,456575,zs,3,zsetopsrc.iter._iterzset.sl.zs,,t_zset.c,*zs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2617,456576,node,3,zsetopsrc.iter._iterzset.sl.node,,t_zset.c,*node,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2618,456577,sl,3,zsetopsrc.iter._iterzset.sl,,t_zset.c,sl,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2619,456578,zset,3,zsetopsrc.iter.zset,,t_zset.c,zset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2620,456579,iter,3,zsetopsrc.iter,,t_zset.c,iter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2621,456582,flags,3,zsetopval.flags,,t_zset.c,flags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
2622,456583,_buf,3,zsetopval._buf,,t_zset.c,_buf[32],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2623,456584,ele,3,zsetopval.ele,,t_zset.c,ele,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
2624,456585,estr,3,zsetopval.estr,,t_zset.c,*estr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2625,456586,elen,3,zsetopval.elen,,t_zset.c,elen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2626,456587,ell,3,zsetopval.ell,,t_zset.c,ell,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2627,456588,score,3,zsetopval.score,,t_zset.c,score,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2628,459889,ZRANGE_DIRECTION_AUTO,3,zrange_direction.ZRANGE_DIRECTION_AUTO,,t_zset.c,ZRANGE_DIRECTION_AUTO = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2629,459890,ZRANGE_DIRECTION_FORWARD,3,zrange_direction.ZRANGE_DIRECTION_FORWARD,,t_zset.c,ZRANGE_DIRECTION_FORWARD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2630,459891,ZRANGE_DIRECTION_REVERSE,3,zrange_direction.ZRANGE_DIRECTION_REVERSE,,t_zset.c,ZRANGE_DIRECTION_REVERSE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2631,459901,ZRANGE_CONSUMER_TYPE_CLIENT,3,zrange_consumer_type.ZRANGE_CONSUMER_TYPE_CLIENT,,t_zset.c,ZRANGE_CONSUMER_TYPE_CLIENT = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2632,459902,ZRANGE_CONSUMER_TYPE_INTERNAL,3,zrange_consumer_type.ZRANGE_CONSUMER_TYPE_INTERNAL,,t_zset.c,ZRANGE_CONSUMER_TYPE_INTERNAL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2633,459950,type,3,zrange_result_handler.type,,t_zset.c,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2634,459951,client,3,zrange_result_handler.client,,t_zset.c,*client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
2635,459952,dstkey,3,zrange_result_handler.dstkey,,t_zset.c,*dstkey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2636,459953,dstobj,3,zrange_result_handler.dstobj,,t_zset.c,*dstobj,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2637,459954,userdata,3,zrange_result_handler.userdata,,t_zset.c,*userdata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
2638,459955,withscores,3,zrange_result_handler.withscores,,t_zset.c,withscores,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2639,459956,should_emit_array_length,3,zrange_result_handler.should_emit_array_length,,t_zset.c,should_emit_array_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2640,459957,beginResultEmission,3,zrange_result_handler.beginResultEmission,,t_zset.c,beginResultEmission,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
2641,459958,finalizeResultEmission,3,zrange_result_handler.finalizeResultEmission,,t_zset.c,finalizeResultEmission,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
2642,459959,emitResultFromCBuffer,3,zrange_result_handler.emitResultFromCBuffer,,t_zset.c,emitResultFromCBuffer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2643,459960,emitResultFromLongLong,3,zrange_result_handler.emitResultFromLongLong,,t_zset.c,emitResultFromLongLong,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
2644,465631,keys,3,bcastState.keys,,tracking.c,*keys,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2645,465632,clients,3,bcastState.clients,,tracking.c,*clients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
2646,471339,LD_STR_AUTO,3,ld2string_mode.LD_STR_AUTO,,util.h,LD_STR_AUTO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2647,471340,LD_STR_HUMAN,3,ld2string_mode.LD_STR_HUMAN,,util.h,LD_STR_HUMAN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2648,471341,LD_STR_HEX,3,ld2string_mode.LD_STR_HEX,,util.h,LD_STR_HEX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
2649,471622,prevrawlensize,3,zlentry.prevrawlensize,,ziplist.c,prevrawlensize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,54,0,1,1,0,0,,0,0,0,0,0,
2650,471623,prevrawlen,3,zlentry.prevrawlen,,ziplist.c,prevrawlen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
2651,471624,lensize,3,zlentry.lensize,,ziplist.c,lensize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,32,0,1,1,0,0,,0,0,0,0,0,
2652,471625,len,3,zlentry.len,,ziplist.c,len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,59,0,1,1,0,0,,0,0,0,0,0,
2653,471626,headersize,3,zlentry.headersize,,ziplist.c,headersize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,22,0,1,1,0,0,,0,0,0,0,0,
2654,471627,encoding,3,zlentry.encoding,,ziplist.c,encoding,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,57,0,1,1,0,0,,0,0,0,0,0,
2655,471628,p,3,zlentry.p,,ziplist.c,*p,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
2656,478177,sval,3,ziplistEntry.sval,,ziplist.h,*sval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2657,478178,slen,3,ziplistEntry.slen,,ziplist.h,slen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2658,478179,lval,3,ziplistEntry.lval,,ziplist.h,lval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2659,282,ACLResetFirstArgsForCommand,1,ACLResetFirstArgsForCommand,"void ACLResetFirstArgsForCommand (aclSelector*,long unsigned)",acl.c,"void ACLResetFirstArgsForCommand(aclSelector *selector, unsigned long id) {
    if (selector->allowed_firstargs && selector->allowed_firstargs[id]) {
        for (int i = 0; selector->allowed_firstargs[id][i]; i++)
            sdsfree(selector->allowed_firstargs[id][i]);
        zfree(selector->allowed_firstargs[id]);
        selector->allowed_firstargs[id] = NULL;
    }
}",889.0,896.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
2660,288,ACLResetFirstArgs,1,ACLResetFirstArgs,void ACLResetFirstArgs (aclSelector*),acl.c,"void ACLResetFirstArgs(aclSelector *selector) {
    if (selector->allowed_firstargs == NULL) return;
    for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
        if (selector->allowed_firstargs[j]) {
            for (int i = 0; selector->allowed_firstargs[j][i]; i++)
                sdsfree(selector->allowed_firstargs[j][i]);
            zfree(selector->allowed_firstargs[j]);
        }
    }
    zfree(selector->allowed_firstargs);
    selector->allowed_firstargs = NULL;
}",901.0,912.0,1.0,24.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2661,293,ACLAddAllowedFirstArg,1,ACLAddAllowedFirstArg,"void ACLAddAllowedFirstArg (aclSelector*,long unsigned,char*)",acl.c,"void ACLAddAllowedFirstArg(aclSelector *selector, unsigned long id, const char *sub) {
    /* If this is the first first-arg to be configured for
     * this user, we have to allocate the first-args array. */
    if (selector->allowed_firstargs == NULL) {
        selector->allowed_firstargs = zcalloc(USER_COMMAND_BITS_COUNT * sizeof(sds*));
    }

    /* We also need to enlarge the allocation pointing to the
     * null terminated SDS array, to make space for this one.
     * To start check the current size, and while we are here
     * make sure the first-arg is not already specified inside. */
    long items = 0;
    if (selector->allowed_firstargs[id]) {
        while(selector->allowed_firstargs[id][items]) {
            /* If it's already here do not add it again. */
            if (!strcasecmp(selector->allowed_firstargs[id][items],sub))
                return;
            items++;
        }
    }

    /* Now we can make space for the new item (and the null term). */
    items ...",916.0,942.0,1.0,46.0,27.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
2662,300,ACLFreeLogEntry,1,ACLFreeLogEntry,void ACLFreeLogEntry (void*),acl.c,"void ACLFreeLogEntry(void *leptr) {
    ACLLogEntry *le = leptr;
    sdsfree(le->object);
    sdsfree(le->username);
    sdsfree(le->cinfo);
    zfree(le);
}",2529.0,2535.0,1.0,1.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2663,305,ACLSetSelector,1,ACLSetSelector,"int ACLSetSelector (aclSelector*,char*,size_t)",acl.c,"int ACLSetSelector(aclSelector *selector, const char* op, size_t oplen) {
    if (!strcasecmp(op,""allkeys"") ||
               !strcasecmp(op,""~*""))
    {
        selector->flags |= SELECTOR_FLAG_ALLKEYS;
        listEmpty(selector->patterns);
    } else if (!strcasecmp(op,""resetkeys"")) {
        selector->flags &= ~SELECTOR_FLAG_ALLKEYS;
        listEmpty(selector->patterns);
    } else if (!strcasecmp(op,""allchannels"") ||
               !strcasecmp(op,""&*""))
    {
        selector->flags |= SELECTOR_FLAG_ALLCHANNELS;
        listEmpty(selector->channels);
    } else if (!strcasecmp(op,""resetchannels"")) {
        selector->flags &= ~SELECTOR_FLAG_ALLCHANNELS;
        listEmpty(selector->channels);
    } else if (!strcasecmp(op,""allcommands"") ||
               !strcasecmp(op,""+@all""))
    {
        memset(selector->allowed_commands,255,sizeof(selector->allowed_commands));
        selector->flags |= SELECTOR_FLAG_ALLCOMMANDS;
        sdsclear(selector->command_rules);
        ACLReset...",1008.0,1178.0,1.0,27.0,171.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,int
2664,312,time_independent_strcmp,1,time_independent_strcmp,"int time_independent_strcmp (char*,char*,int)",acl.c,"int time_independent_strcmp(char *a, char *b, int len) {
    int diff = 0;
    for (int j = 0; j < len; j++) {
        diff |= (a[j] ^ b[j]);
    }
    return diff; /* If zero strings are the same. */
}",162.0,168.0,1.0,1.0,7.0,6,4,10,5,1,0,2,2,0,0,,0,0,6,3,3,int
2665,346,ACLHashPassword,1,ACLHashPassword,"sds ACLHashPassword (unsigned char*,size_t)",acl.c,"sds ACLHashPassword(unsigned char *cleartext, size_t len) {
    SHA256_CTX ctx;
    unsigned char hash[SHA256_BLOCK_SIZE];
    char hex[HASH_PASSWORD_LEN];
    char *cset = ""0123456789abcdef"";

    sha256_init(&ctx);
    sha256_update(&ctx,(unsigned char*)cleartext,len);
    sha256_final(&ctx,hash);

    for (int j = 0; j < SHA256_BLOCK_SIZE; j++) {
        hex[j*2] = cset[((hash[j]&0xF0)>>4)];
        hex[j*2+1] = cset[(hash[j]&0xF)];
    }
    return sdsnewlen(hex,HASH_PASSWORD_LEN);
}",172.0,187.0,1.0,23.0,16.0,22,9,20,7,1,4,2,2,0,4,,0,0,4,2,2,sds
2666,425,ACLCheckPasswordHash,1,ACLCheckPasswordHash,"int ACLCheckPasswordHash (unsigned char*,int)",acl.c,"int ACLCheckPasswordHash(unsigned char *hash, int hashlen) {
    if (hashlen != HASH_PASSWORD_LEN) {
        return C_ERR;
    }

    /* Password hashes can only be characters that represent
     * hexadecimal values, which are numbers and lowercase
     * characters 'a' through 'f'. */
    for(int i = 0; i < HASH_PASSWORD_LEN; i++) {
        char c = hash[i];
        if ((c < 'a' || c > 'f') && (c < '0' || c > '9')) {
            return C_ERR;
        }
    }
    return C_OK;
}",191.0,206.0,1.0,19.0,16.0,16,9,10,4,0,0,4,5,0,0,,0,0,4,2,2,int
2667,493,ACLStringHasSpaces,1,ACLStringHasSpaces,"int ACLStringHasSpaces (char*,size_t)",acl.c,"int ACLStringHasSpaces(const char *s, size_t len) {
    for (size_t i = 0; i < len; i++) {
        if (isspace(s[i]) || s[i] == 0) return 1;
    }
    return 0;
}",217.0,222.0,1.0,1.0,6.0,6,5,7,3,3,0,3,4,0,0,,0,0,4,2,2,int
2668,527,ACLGetCommandCategoryFlagByName,1,ACLGetCommandCategoryFlagByName,uint64_t ACLGetCommandCategoryFlagByName (char*),acl.c,"uint64_t ACLGetCommandCategoryFlagByName(const char *name) {
    for (int j = 0; ACLCommandCategories[j].flag != 0; j++) {
        if (!strcasecmp(name,ACLCommandCategories[j].name)) {
            return ACLCommandCategories[j].flag;
        }
    }
    return 0; /* No match. */
}",226.0,233.0,1.0,1.0,8.0,9,5,8,3,4,3,3,4,2,0,,0,3,2,1,1,uint64_t
2669,566,ACLListMatchLoadedUser,1,ACLListMatchLoadedUser,"int ACLListMatchLoadedUser (void*,void*)",acl.c,"int ACLListMatchLoadedUser(void *definition, void *user) {
    sds *user_definition = definition;
    return sdscmp(user_definition[0], user) == 0;
}",238.0,241.0,1.0,1.0,4.0,3,3,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
2670,584,ACLListMatchSds,1,ACLListMatchSds,"int ACLListMatchSds (void*,void*)",acl.c,"int ACLListMatchSds(void *a, void *b) {
    return sdscmp(a,b) == 0;
}",245.0,247.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2671,596,ACLListFreeSds,1,ACLListFreeSds,void ACLListFreeSds (void*),acl.c,"void ACLListFreeSds(void *item) {
    sdsfree(item);
}",250.0,252.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2672,603,ACLListDupSds,1,ACLListDupSds,void* ACLListDupSds (void*),acl.c,"void *ACLListDupSds(void *item) {
    return sdsdup(item);
}",255.0,257.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void*
2673,615,ACLKeyPatternCreate,1,ACLKeyPatternCreate,"keyPattern ACLKeyPatternCreate (sds,int)",acl.c,"keyPattern *ACLKeyPatternCreate(sds pattern, int flags) {
    keyPattern *new = (keyPattern *) zmalloc(sizeof(keyPattern));
    new->pattern = pattern;
    new->flags = flags;
    return new;
}",267.0,272.0,1.0,1.0,6.0,7,4,7,4,1,4,1,1,0,1,,0,4,4,2,2,keyPattern
2674,641,ACLKeyPatternFree,1,ACLKeyPatternFree,void ACLKeyPatternFree (keyPattern*),acl.c,"void ACLKeyPatternFree(keyPattern *pattern) {
    sdsfree(pattern->pattern);
    zfree(pattern);
}",275.0,278.0,1.0,1.0,4.0,1,1,2,1,1,3,1,1,0,2,,0,1,2,1,1,void
2675,652,ACLListMatchKeyPattern,1,ACLListMatchKeyPattern,"int ACLListMatchKeyPattern (void*,void*)",acl.c,"int ACLListMatchKeyPattern(void *a, void *b) {
    return sdscmp(((keyPattern *) a)->pattern,((keyPattern *) b)->pattern) == 0;
}",282.0,284.0,1.0,1.0,3.0,5,3,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2676,672,ACLListFreeKeyPattern,1,ACLListFreeKeyPattern,void ACLListFreeKeyPattern (void*),acl.c,"void ACLListFreeKeyPattern(void *item) {
    ACLKeyPatternFree(item);
}",287.0,289.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2677,679,ACLListDupKeyPattern,1,ACLListDupKeyPattern,void* ACLListDupKeyPattern (void*),acl.c,"void *ACLListDupKeyPattern(void *item) {
    keyPattern *old = (keyPattern *) item;
    return ACLKeyPatternCreate(sdsdup(old->pattern), old->flags);
}",292.0,295.0,1.0,1.0,4.0,4,3,4,2,0,4,1,1,0,2,,0,3,2,1,1,void*
2678,699,sdsCatPatternString,1,sdsCatPatternString,"sds sdsCatPatternString (sds,keyPattern*)",acl.c,"sds sdsCatPatternString(sds base, keyPattern *pat) {
    if (pat->flags == ACL_ALL_PERMISSION) {
        base = sdscatlen(base,""~"",1);
    } else if (pat->flags == ACL_READ_PERMISSION) {
        base = sdscatlen(base,""%R~"",3);
    } else if (pat->flags == ACL_WRITE_PERMISSION) {
        base = sdscatlen(base,""%W~"",3);
    } else {
        serverPanic(""Invalid key pattern flag detected"");
    }
    return sdscatsds(base, pat->pattern);
}",299.0,310.0,1.0,22.0,12.0,7,5,5,2,0,4,2,2,1,2,,0,3,4,2,2,sds
2679,780,ACLCreateSelector,1,ACLCreateSelector,aclSelector ACLCreateSelector (int),acl.c,"aclSelector *ACLCreateSelector(int flags) {
    aclSelector *selector = zmalloc(sizeof(aclSelector));
    selector->flags = flags | server.acl_pubsub_default;
    selector->patterns = listCreate();
    selector->channels = listCreate();
    selector->allowed_firstargs = NULL;
    selector->command_rules = sdsempty();

    listSetMatchMethod(selector->patterns,ACLListMatchKeyPattern);
    listSetFreeMethod(selector->patterns,ACLListFreeKeyPattern);
    listSetDupMethod(selector->patterns,ACLListDupKeyPattern);
    listSetMatchMethod(selector->channels,ACLListMatchSds);
    listSetFreeMethod(selector->channels,ACLListFreeSds);
    listSetDupMethod(selector->channels,ACLListDupSds);
    memset(selector->allowed_commands,0,sizeof(selector->allowed_commands));

    return selector;
}",314.0,331.0,1.0,4.0,18.0,41,5,25,5,3,24,1,1,0,4,,0,24,2,1,1,aclSelector
2680,909,ACLFreeSelector,1,ACLFreeSelector,void ACLFreeSelector (aclSelector*),acl.c,"void ACLFreeSelector(aclSelector *selector) {
    listRelease(selector->patterns);
    listRelease(selector->channels);
    sdsfree(selector->command_rules);
    ACLResetFirstArgs(selector);
    zfree(selector);
}",334.0,340.0,1.0,1.0,7.0,3,1,5,1,3,8,1,1,0,5,,0,3,2,1,1,void
2681,930,ACLCopySelector,1,ACLCopySelector,aclSelector ACLCopySelector (aclSelector*),acl.c,"aclSelector *ACLCopySelector(aclSelector *src) {
    aclSelector *dst = zmalloc(sizeof(aclSelector));
    dst->flags = src->flags;
    dst->patterns = listDup(src->patterns);
    dst->channels = listDup(src->channels);
    dst->command_rules = sdsdup(src->command_rules);
    memcpy(dst->allowed_commands,src->allowed_commands,
           sizeof(dst->allowed_commands));
    dst->allowed_firstargs = NULL;
    /* Copy the allowed first-args array of array of SDS strings. */
    if (src->allowed_firstargs) {
        for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
            if (!(src->allowed_firstargs[j])) continue;
            for (int i = 0; src->allowed_firstargs[j][i]; i++) {
                ACLAddAllowedFirstArg(dst, j, src->allowed_firstargs[j][i]);
            }
        }
    }
    return dst;
}",343.0,362.0,1.0,28.0,20.0,33,6,30,6,1,22,6,10,3,5,,0,21,2,1,1,aclSelector
2682,1044,ACLListFreeSelector,1,ACLListFreeSelector,void ACLListFreeSelector (void*),acl.c,"void ACLListFreeSelector(void *a) {
    ACLFreeSelector((aclSelector *) a);
}",365.0,367.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2683,1053,ACLListDuplicateSelector,1,ACLListDuplicateSelector,void* ACLListDuplicateSelector (void*),acl.c,"void *ACLListDuplicateSelector(void *src) {
    return ACLCopySelector((aclSelector *)src);
}",370.0,372.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void*
2684,1063,ACLUserGetRootSelector,1,ACLUserGetRootSelector,aclSelector ACLUserGetRootSelector (user*),acl.c,"aclSelector *ACLUserGetRootSelector(user *u) {
    serverAssert(listLength(u->selectors));
    aclSelector *s = (aclSelector *) listNodeValue(listFirst(u->selectors));
    serverAssert(s->flags & SELECTOR_FLAG_ROOT);
    return s;
}",377.0,382.0,1.0,4.0,6.0,18,8,5,2,0,5,1,1,0,2,,0,3,2,1,1,aclSelector
2685,1122,ACLCreateUser,1,ACLCreateUser,"user ACLCreateUser (char*,size_t)",acl.c,"user *ACLCreateUser(const char *name, size_t namelen) {
    if (raxFind(Users,(unsigned char*)name,namelen) != raxNotFound) return NULL;
    user *u = zmalloc(sizeof(*u));
    u->name = sdsnewlen(name,namelen);
    u->flags = USER_FLAG_DISABLED;
    u->flags |= USER_FLAG_SANITIZE_PAYLOAD;
    u->passwords = listCreate();
    u->acl_string = NULL;
    listSetMatchMethod(u->passwords,ACLListMatchSds);
    listSetFreeMethod(u->passwords,ACLListFreeSds);
    listSetDupMethod(u->passwords,ACLListDupSds);

    u->selectors = listCreate();
    listSetFreeMethod(u->selectors,ACLListFreeSelector);
    listSetDupMethod(u->selectors,ACLListDuplicateSelector);

    /* Add the initial root selector */
    aclSelector *s = ACLCreateSelector(SELECTOR_FLAG_ROOT);
    listAddNodeHead(u->selectors, s);

    raxInsert(Users,(unsigned char*)name,namelen,u,NULL);
    return u;
}",389.0,411.0,1.0,15.0,23.0,42,7,35,7,5,27,2,2,2,8,,0,25,4,2,2,user
2686,1276,ACLCreateUnlinkedUser,1,ACLCreateUnlinkedUser,user ACLCreateUnlinkedUser (void),acl.c,"user *ACLCreateUnlinkedUser(void) {
    char username[64];
    for (int j = 0; ; j++) {
        snprintf(username,sizeof(username),""__fakeuser:%d__"",j);
        user *fakeuser = ACLCreateUser(username,strlen(username));
        if (fakeuser == NULL) continue;
        int retval = raxRemove(Users,(unsigned char*) username,
                               strlen(username),NULL);
        serverAssert(retval != 0);
        return fakeuser;
    }
}",417.0,428.0,1.0,8.0,12.0,12,9,17,6,3,4,4,4,0,3,,0,3,2,1,1,user
2687,1339,ACLFreeUser,1,ACLFreeUser,void ACLFreeUser (user*),acl.c,"void ACLFreeUser(user *u) {
    sdsfree(u->name);
    if (u->acl_string) {
        decrRefCount(u->acl_string);
        u->acl_string = NULL;
    }
    listRelease(u->passwords);
    listRelease(u->selectors);
    zfree(u);
}",432.0,441.0,1.0,1.0,10.0,7,2,8,2,5,11,2,2,1,5,,0,6,2,1,1,void
2688,1372,ACLFreeUserAndKillClients,1,ACLFreeUserAndKillClients,void ACLFreeUserAndKillClients (user*),acl.c,"void ACLFreeUserAndKillClients(user *u) {
    listIter li;
    listNode *ln;
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (c->user == u) {
            /* We'll free the connection asynchronously, so
             * in theory to set a different user is not needed.
             * However if there are bugs in Redis, soon or later
             * this may result in some security hole: it's much
             * more defensive to set the default user and put
             * it in non authenticated mode. */
            c->user = DefaultUser;
            c->authenticated = 0;
            /* We will write replies to this client later, so we can't
             * close it directly even if async. */
            if (c == server.current_client) {
                c->flags |= CLIENT_CLOSE_AFTER_COMMAND;
            } else {
                freeClientAsync(c);
            }
        }
    }
    ACLFreeUser(u);
}",446.0,471.0,1.0,20.0,26.0,17,7,17,7,1,9,4,7,2,3,,0,7,2,1,1,void
2689,1442,ACLCopyUser,1,ACLCopyUser,"void ACLCopyUser (user*,user*)",acl.c,"void ACLCopyUser(user *dst, user *src) {
    listRelease(dst->passwords);
    listRelease(dst->selectors);
    dst->passwords = listDup(src->passwords);
    dst->selectors = listDup(src->selectors);
    dst->flags = src->flags;
    if (dst->acl_string) {
        decrRefCount(dst->acl_string);
    }
    dst->acl_string = src->acl_string;
    if (dst->acl_string) {
        /* if src is NULL, we set it to NULL, if not, need to increment reference count */
        incrRefCount(dst->acl_string);
    }
}",476.0,490.0,1.0,1.0,15.0,18,2,14,2,3,20,3,3,2,6,,0,16,4,2,2,void
2690,1504,ACLFreeUsersSet,1,ACLFreeUsersSet,void ACLFreeUsersSet (rax*),acl.c,"void ACLFreeUsersSet(rax *users) {
    raxFreeWithCallback(users,(void(*)(void*))ACLFreeUserAndKillClients);
}",494.0,496.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
2691,1514,ACLGetCommandBitCoordinates,1,ACLGetCommandBitCoordinates,"int ACLGetCommandBitCoordinates (uint64_t,uint64_t*,uint64_t*)",acl.c,"int ACLGetCommandBitCoordinates(uint64_t id, uint64_t *word, uint64_t *bit) {
    if (id >= USER_COMMAND_BITS_COUNT) return C_ERR;
    *word = id / sizeof(uint64_t) / 8;
    *bit = 1ULL << (id % (sizeof(uint64_t) * 8));
    return C_OK;
}",504.0,509.0,1.0,14.0,6.0,13,9,7,4,2,0,2,2,0,0,,0,0,6,3,3,int
2692,1557,ACLGetSelectorCommandBit,1,ACLGetSelectorCommandBit,"int ACLGetSelectorCommandBit (aclSelector*,long unsigned)",acl.c,"int ACLGetSelectorCommandBit(const aclSelector *selector, unsigned long id) {
    uint64_t word, bit;
    if (ACLGetCommandBitCoordinates(id,&word,&bit) == C_ERR) return 0;
    return (selector->allowed_commands[word] & bit) != 0;
}",518.0,522.0,1.0,54.0,5.0,8,7,6,4,3,2,2,2,1,1,,0,2,4,2,2,int
2693,1590,ACLSelectorCanExecuteFutureCommands,1,ACLSelectorCanExecuteFutureCommands,int ACLSelectorCanExecuteFutureCommands (aclSelector*),acl.c,"int ACLSelectorCanExecuteFutureCommands(aclSelector *selector) {
    return ACLGetSelectorCommandBit(selector,USER_COMMAND_BITS_COUNT-1);
}",527.0,529.0,1.0,45.0,3.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,int
2694,1603,ACLSetSelectorCommandBit,1,ACLSetSelectorCommandBit,"void ACLSetSelectorCommandBit (aclSelector*,long unsigned,int)",acl.c,"void ACLSetSelectorCommandBit(aclSelector *selector, unsigned long id, int value) {
    uint64_t word, bit;
    if (ACLGetCommandBitCoordinates(id,&word,&bit) == C_ERR) return;
    if (value) {
        selector->allowed_commands[word] |= bit;
    } else {
        selector->allowed_commands[word] &= ~bit;
        selector->flags &= ~SELECTOR_FLAG_ALLCOMMANDS;
    }
}",536.0,545.0,1.0,54.0,10.0,6,5,7,5,2,2,3,3,1,1,,0,2,6,3,3,void
2695,1656,ACLSelectorRemoveCommandRule,1,ACLSelectorRemoveCommandRule,"void ACLSelectorRemoveCommandRule (aclSelector*,sds)",acl.c,"void ACLSelectorRemoveCommandRule(aclSelector *selector, sds new_rule) {
    size_t new_len = sdslen(new_rule);
    char *existing_rule = selector->command_rules;

    /* Loop over the existing rules, trying to find a rule that ""matches""
     * the new rule. If we find a match, then remove the command from the string by
     * copying the later rules over it. */
    while(existing_rule[0]) {
        /* The first character of the rule is +/-, which we don't need to compare. */
        char *copy_position = existing_rule;
        existing_rule += 1;

        /* Assume a trailing space after a command is part of the command, like '+get ', so trim it
         * as well if the command is removed. */
        char *rule_end = strchr(existing_rule, ' ');
        if (!rule_end) {
            /* This is the last rule, so it it to the end of the string. */
            rule_end = existing_rule + strlen(existing_rule);

            /* This approach can leave a trailing space if the last rule is ...",550.0,590.0,1.0,45.0,41.0,31,17,44,8,1,5,7,14,1,2,,0,4,4,2,2,void
2696,1774,ACLUpdateCommandRules,1,ACLUpdateCommandRules,"void ACLUpdateCommandRules (aclSelector*,char*,int)",acl.c,"void ACLUpdateCommandRules(aclSelector *selector, const char *rule, int allow) {
    sds new_rule = sdsnew(rule);
    sdstolower(new_rule);

    ACLSelectorRemoveCommandRule(selector, new_rule);
    if (sdslen(selector->command_rules)) selector->command_rules = sdscat(selector->command_rules, "" "");
    selector->command_rules = sdscatfmt(selector->command_rules, allow ? ""+%S"" : ""-%S"", new_rule);
    sdsfree(new_rule);
}",594.0,602.0,1.0,1.0,9.0,9,3,13,4,1,12,2,2,2,7,,0,9,6,3,3,void
2697,1821,ACLChangeSelectorPerm,1,ACLChangeSelectorPerm,"void ACLChangeSelectorPerm (aclSelector*,redisCommand*,int)",acl.c,"void ACLChangeSelectorPerm(aclSelector *selector, struct redisCommand *cmd, int allow) {
    unsigned long id = cmd->id;
    ACLSetSelectorCommandBit(selector,id,allow);
    ACLResetFirstArgsForCommand(selector,id);
    if (cmd->subcommands_dict) {
        dictEntry *de;
        dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);
        while((de = dictNext(di)) != NULL) {
            struct redisCommand *sub = (struct redisCommand *)dictGetVal(de);
            ACLSetSelectorCommandBit(selector,sub->id,allow);
        }
        dictReleaseIterator(di);
    }
}",606.0,619.0,1.0,1.0,14.0,10,4,19,8,1,11,3,4,2,7,,0,7,6,3,3,void
2698,1877,ACLSetSelectorCommandBitsForCategory,1,ACLSetSelectorCommandBitsForCategory,"void ACLSetSelectorCommandBitsForCategory (dict*,aclSelector*,uint64_t,int)",acl.c,"void ACLSetSelectorCommandBitsForCategory(dict *commands, aclSelector *selector, uint64_t cflag, int value) {
    dictIterator *di = dictGetIterator(commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->acl_categories & cflag) {
            ACLChangeSelectorPerm(selector,cmd,value);
        }
        if (cmd->subcommands_dict) {
            ACLSetSelectorCommandBitsForCategory(cmd->subcommands_dict, selector, cflag, value);
        }
    }
    dictReleaseIterator(di);
}",627.0,640.0,1.0,1.0,14.0,8,4,18,8,1,8,4,6,3,5,,0,6,8,4,4,void
2699,1929,ACLRecomputeCommandBitsFromCommandRulesAllUsers,1,ACLRecomputeCommandBitsFromCommandRulesAllUsers,void ACLRecomputeCommandBitsFromCommandRulesAllUsers (void),acl.c,"void ACLRecomputeCommandBitsFromCommandRulesAllUsers(void) {
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        listIter li;
        listNode *ln;
        listRewind(u->selectors,&li);
        while((ln = listNext(&li))) {
            aclSelector *selector = (aclSelector *) listNodeValue(ln);
            int argc = 0;
            sds *argv = sdssplitargs(selector->command_rules, &argc);
            serverAssert(argv != NULL);
            /* Checking selector's permissions for all commands to start with a clean state. */
            if (ACLSelectorCanExecuteFutureCommands(selector)) {
                int res = ACLSetSelector(selector,""+@all"",-1);
                serverAssert(res == C_OK);
            } else {
                int res = ACLSetSelector(selector,""-@all"",-1);
                serverAssert(res == C_OK);
            }

            /* Apply all of the commands and categories to this selector. ...",645.0,678.0,1.0,52.0,34.0,39,13,37,11,2,20,5,10,3,15,,0,12,2,1,1,void
2700,2111,ACLSetSelectorCategory,1,ACLSetSelectorCategory,"int ACLSetSelectorCategory (aclSelector*,char*,int)",acl.c,"int ACLSetSelectorCategory(aclSelector *selector, const char *category, int allow) {
    uint64_t cflag = ACLGetCommandCategoryFlagByName(category + 1);
    if (!cflag) return C_ERR;

    ACLUpdateCommandRules(selector, category, allow);

    /* Set the actual command bits on the selector. */
    ACLSetSelectorCommandBitsForCategory(server.orig_commands, selector, cflag, allow);
    return C_OK;
}",680.0,689.0,1.0,23.0,10.0,5,5,10,5,0,3,2,2,0,3,,0,1,6,3,3,int
2701,2149,ACLCountCategoryBitsForCommands,1,ACLCountCategoryBitsForCommands,"void ACLCountCategoryBitsForCommands (dict*,aclSelector*,long unsigned*,long unsigned*,uint64_t)",acl.c,"void ACLCountCategoryBitsForCommands(dict *commands, aclSelector *selector, unsigned long *on, unsigned long *off, uint64_t cflag) {
    dictIterator *di = dictGetIterator(commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->acl_categories & cflag) {
            if (ACLGetSelectorCommandBit(selector,cmd->id))
                (*on)++;
            else
                (*off)++;
        }
        if (cmd->subcommands_dict) {
            ACLCountCategoryBitsForCommands(cmd->subcommands_dict, selector, on, off, cflag);
        }
    }
    dictReleaseIterator(di);
}",691.0,707.0,1.0,1.0,17.0,11,6,19,9,1,9,5,9,5,5,,0,8,10,5,5,void
2702,2214,ACLCountCategoryBitsForSelector,1,ACLCountCategoryBitsForSelector,"int ACLCountCategoryBitsForSelector (aclSelector*,long unsigned*,long unsigned*,char*)",acl.c,"int ACLCountCategoryBitsForSelector(aclSelector *selector, unsigned long *on, unsigned long *off,
                                const char *category)
{
    uint64_t cflag = ACLGetCommandCategoryFlagByName(category);
    if (!cflag) return C_ERR;

    *on = *off = 0;
    ACLCountCategoryBitsForCommands(server.orig_commands, selector, on, off, cflag);
    return C_OK;
}",713.0,722.0,1.0,23.0,10.0,8,5,10,6,0,2,2,2,0,2,,0,1,8,4,4,int
2703,2255,ACLDescribeSelectorCommandRules,1,ACLDescribeSelectorCommandRules,sds ACLDescribeSelectorCommandRules (aclSelector*),acl.c,"sds ACLDescribeSelectorCommandRules(aclSelector *selector) {
    sds rules = sdsempty();

    /* We use this fake selector as a ""sanity"" check to make sure the rules
     * we generate have the same bitmap as those on the current selector. */
    aclSelector *fake_selector = ACLCreateSelector(0);

    /* Here we want to understand if we should start with +@all or -@all.
     * Note that when starting with +@all and subtracting, the user
     * will be able to execute future commands, while -@all and adding will just
     * allow the user the run the selected commands and/or categories.
     * How do we test for that? We use the trick of a reserved command ID bit
     * that is set only by +@all (and its alias ""allcommands""). */
    if (ACLSelectorCanExecuteFutureCommands(selector)) {
        rules = sdscat(rules,""+@all "");
        ACLSetSelector(fake_selector,""+@all"",-1);
    } else {
        rules = sdscat(rules,""-@all "");
        ACLSetSelector(fake_selector,""-@all"",-1);
    }

  ...",731.0,784.0,1.0,4.0,54.0,36,15,34,9,2,22,5,5,6,16,,0,14,2,1,1,sds
2704,2430,ACLDescribeSelector,1,ACLDescribeSelector,sds ACLDescribeSelector (aclSelector*),acl.c,"sds ACLDescribeSelector(aclSelector *selector) {
    listIter li;
    listNode *ln;
    sds res = sdsempty();
    /* Key patterns. */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) {
        res = sdscatlen(res,""~* "",3);
    } else {
        listRewind(selector->patterns,&li);
        while((ln = listNext(&li))) {
            keyPattern *thispat = (keyPattern *)listNodeValue(ln);
            res = sdsCatPatternString(res, thispat);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Pub/sub channel patterns. */
    if (selector->flags & SELECTOR_FLAG_ALLCHANNELS) {
        res = sdscatlen(res,""&* "",3);
    } else {
        res = sdscatlen(res,""resetchannels "",14);
        listRewind(selector->channels,&li);
        while((ln = listNext(&li))) {
            sds thispat = listNodeValue(ln);
            res = sdscatlen(res,""&"",1);
            res = sdscatsds(res,thispat);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Command rules. */
    sds rules = ACL...",786.0,821.0,1.0,26.0,36.0,11,4,14,3,1,8,3,3,2,6,,0,7,2,1,1,sds
2705,2573,ACLDescribeUser,1,ACLDescribeUser,robj ACLDescribeUser (user*),acl.c,"robj *ACLDescribeUser(user *u) {
    if (u->acl_string) {
        incrRefCount(u->acl_string);
        return u->acl_string;
    }

    sds res = sdsempty();

    /* Flags. */
    for (int j = 0; ACLUserFlags[j].flag; j++) {
        if (u->flags & ACLUserFlags[j].flag) {
            res = sdscat(res,ACLUserFlags[j].name);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Passwords. */
    listIter li;
    listNode *ln;
    listRewind(u->passwords,&li);
    while((ln = listNext(&li))) {
        sds thispass = listNodeValue(ln);
        res = sdscatlen(res,""#"",1);
        res = sdscatsds(res,thispass);
        res = sdscatlen(res,"" "",1);
    }

    /* Selectors (Commands and keys) */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *selector = (aclSelector *) listNodeValue(ln);
        sds default_perm = ACLDescribeSelector(selector);
        if (selector->flags & SELECTOR_FLAG_ROOT) {
            res = sdscatfmt(res, ""%s"", default_...",829.0,874.0,1.0,23.0,46.0,40,8,48,9,3,31,7,9,7,16,,0,26,2,1,1,robj
2706,2749,ACLLookupCommand,1,ACLLookupCommand,struct redisCommand ACLLookupCommand (char*),acl.c,"struct redisCommand *ACLLookupCommand(const char *name) {
    struct redisCommand *cmd;
    sds sdsname = sdsnew(name);
    cmd = lookupCommandBySdsLogic(server.orig_commands,sdsname);
    sdsfree(sdsname);
    return cmd;
}",879.0,885.0,1.0,1.0,7.0,3,2,7,4,0,3,1,1,0,3,,0,2,2,1,1,struct redisCommand
2707,2998,aclCreateSelectorFromOpSet,1,aclCreateSelectorFromOpSet,"aclSelector aclCreateSelectorFromOpSet (char*,size_t)",acl.c,"aclSelector *aclCreateSelectorFromOpSet(const char *opset, size_t opsetlen) {
    serverAssert(opset[0] == '(' && opset[opsetlen - 1] == ')');
    aclSelector *s = ACLCreateSelector(0);

    int argc = 0;
    sds trimmed = sdsnewlen(opset + 1, opsetlen - 2);
    sds *argv = sdssplitargs(trimmed, &argc);
    for (int i = 0; i < argc; i++) {
        if (ACLSetSelector(s, argv[i], sdslen(argv[i])) == C_ERR) {
            ACLFreeSelector(s);
            s = NULL;
            goto cleanup;
        }
    }

cleanup:
    sdsfreesplitres(argv, argc);
    sdsfree(trimmed);
    return s;
}",950.0,969.0,1.0,4.0,20.0,24,13,26,8,0,9,4,4,2,9,,0,5,4,2,2,aclSelector
2708,3880,ACLSetUser,1,ACLSetUser,"int ACLSetUser (user*,char*,ssize_t)",acl.c,"int ACLSetUser(user *u, const char *op, ssize_t oplen) {
    /* as we are changing the ACL, the old generated string is now invalid */
    if (u->acl_string) {
        decrRefCount(u->acl_string);
        u->acl_string = NULL;
    }

    if (oplen == -1) oplen = strlen(op);
    if (oplen == 0) return C_OK; /* Empty string is a no-operation. */
    if (!strcasecmp(op,""on"")) {
        u->flags |= USER_FLAG_ENABLED;
        u->flags &= ~USER_FLAG_DISABLED;
    } else if (!strcasecmp(op,""off"")) {
        u->flags |= USER_FLAG_DISABLED;
        u->flags &= ~USER_FLAG_ENABLED;
    } else if (!strcasecmp(op,""skip-sanitize-payload"")) {
        u->flags |= USER_FLAG_SANITIZE_PAYLOAD_SKIP;
        u->flags &= ~USER_FLAG_SANITIZE_PAYLOAD;
    } else if (!strcasecmp(op,""sanitize-payload"")) {
        u->flags &= ~USER_FLAG_SANITIZE_PAYLOAD_SKIP;
        u->flags |= USER_FLAG_SANITIZE_PAYLOAD;
    } else if (!strcasecmp(op,""nopass"")) {
        u->flags |= USER_FLAG_NOPASS;
        listEmpty(u->pa...",1250.0,1350.0,1.0,27.0,101.0,14,7,11,4,13,6,5,5,1,1,,0,5,6,3,3,int
2709,4565,ACLSetUserStringError,1,ACLSetUserStringError,const char* ACLSetUserStringError (void),acl.c,"const char *ACLSetUserStringError(void) {
    const char *errmsg = ""Wrong format"";
    if (errno == ENOENT)
        errmsg = ""Unknown command or category name in ACL"";
    else if (errno == EINVAL)
        errmsg = ""Syntax error"";
    else if (errno == EEXIST)
        errmsg = ""Adding a pattern after the * pattern (or the ""
                 ""'allkeys' flag) is not valid and does not have any ""
                 ""effect. Try 'resetkeys' to start with an empty ""
                 ""list of patterns"";
    else if (errno == EISDIR)
        errmsg = ""Adding a pattern after the * pattern (or the ""
                 ""'allchannels' flag) is not valid and does not have any ""
                 ""effect. Try 'resetchannels' to start with an empty ""
                 ""list of channels"";
    else if (errno == ENODEV)
        errmsg = ""The password you are trying to remove from the user does ""
                 ""not exist"";
    else if (errno == EBADMSG)
        errmsg = ""The password hash must be exactl...",1354.0,1382.0,1.0,1.0,29.0,3,2,5,3,3,0,2,2,0,0,,0,0,2,1,1,const char*
2710,4654,ACLCreateDefaultUser,1,ACLCreateDefaultUser,user ACLCreateDefaultUser (void),acl.c,"user *ACLCreateDefaultUser(void) {
    user *new = ACLCreateUser(""default"",7);
    ACLSetUser(new,""+@all"",-1);
    ACLSetUser(new,""~*"",-1);
    ACLSetUser(new,""&*"",-1);
    ACLSetUser(new,""on"",-1);
    ACLSetUser(new,""nopass"",-1);
    return new;
}",1385.0,1393.0,1.0,1.0,9.0,6,2,7,1,2,6,1,1,0,6,,0,1,2,1,1,user
2711,4692,ACLInit,1,ACLInit,void ACLInit (void),acl.c,"void ACLInit(void) {
    Users = raxNew();
    UsersToLoad = listCreate();
    listSetMatchMethod(UsersToLoad, ACLListMatchLoadedUser);
    ACLLog = listCreate();
    DefaultUser = ACLCreateDefaultUser();
}",1396.0,1402.0,1.0,4.0,7.0,6,2,6,4,0,10,1,1,0,4,,0,10,2,1,1,void
2712,4718,ACLCheckUserCredentials,1,ACLCheckUserCredentials,"int ACLCheckUserCredentials (robj*,robj*)",acl.c,"int ACLCheckUserCredentials(robj *username, robj *password) {
    user *u = ACLGetUserByName(username->ptr,sdslen(username->ptr));
    if (u == NULL) {
        errno = ENOENT;
        return C_ERR;
    }

    /* Disabled users can't login. */
    if (u->flags & USER_FLAG_DISABLED) {
        errno = EINVAL;
        return C_ERR;
    }

    /* If the user is configured to don't require any password, we
     * are already fine here. */
    if (u->flags & USER_FLAG_NOPASS) return C_OK;

    /* Check all the user passwords for at least one to match. */
    listIter li;
    listNode *ln;
    listRewind(u->passwords,&li);
    sds hashed = ACLHashPassword(password->ptr,sdslen(password->ptr));
    while((ln = listNext(&li))) {
        sds thispass = listNodeValue(ln);
        if (!time_independent_strcmp(hashed, thispass, HASH_PASSWORD_LEN)) {
            sdsfree(hashed);
            return C_OK;
        }
    }
    sdsfree(hashed);

    /* If we reached this point, no password matched. */
 ...",1410.0,1444.0,1.0,15.0,35.0,27,9,27,11,1,13,6,7,4,9,,0,10,4,2,2,int
2713,4844,addAuthErrReply,1,addAuthErrReply,"void addAuthErrReply (client*,robj*)",acl.c,"void addAuthErrReply(client *c, robj *err) {
    if (clientHasPendingReplies(c)) return;
    if (!err) {
        addReplyError(c, ""-WRONGPASS invalid username-password pair or user is disabled."");
        return;
    }
    addReplyError(c, err->ptr);
}",1448.0,1455.0,1.0,1.0,8.0,2,2,5,2,1,3,3,3,1,3,,0,1,4,2,2,void
2714,4868,checkPasswordBasedAuth,1,checkPasswordBasedAuth,"int checkPasswordBasedAuth (client*,robj*,robj*)",acl.c,"int checkPasswordBasedAuth(client *c, robj *username, robj *password) {
    if (ACLCheckUserCredentials(username,password) == C_OK) {
        c->authenticated = 1;
        c->user = ACLGetUserByName(username->ptr,sdslen(username->ptr));
        moduleNotifyUserChanged(c);
        return AUTH_OK;
    } else {
        addACLLogEntry(c,ACL_DENIED_AUTH,(c->flags & CLIENT_MULTI) ? ACL_LOG_CTX_MULTI : ACL_LOG_CTX_TOPLEVEL,0,username->ptr,NULL);
        return AUTH_ERR;
    }
}",1462.0,1472.0,1.0,54.0,11.0,7,3,8,4,1,6,2,2,1,4,,0,5,6,3,3,int
2715,4935,ACLAuthenticateUser,1,ACLAuthenticateUser,"int ACLAuthenticateUser (client*,robj*,robj*,robj**)",acl.c,"int ACLAuthenticateUser(client *c, robj *username, robj *password, robj **err) {
    int result = checkModuleAuthentication(c, username, password, err);
    /* If authentication was not handled by any Module, attempt normal password based auth. */
    if (result == AUTH_NOT_HANDLED) {
        result = checkPasswordBasedAuth(c, username, password);
    }
    return result;
}",1481.0,1488.0,1.0,1.0,8.0,3,2,12,6,2,2,2,2,0,2,,0,2,8,4,4,int
2716,4964,ACLGetCommandID,1,ACLGetCommandID,unsigned long ACLGetCommandID (sds),acl.c,"unsigned long ACLGetCommandID(sds cmdname) {
    sds lowername = sdsdup(cmdname);
    sdstolower(lowername);
    if (commandId == NULL) commandId = raxNew();
    void *id = raxFind(commandId,(unsigned char*)lowername,sdslen(lowername));
    if (id != raxNotFound) {
        sdsfree(lowername);
        return (unsigned long)id;
    }
    raxInsert(commandId,(unsigned char*)lowername,strlen(lowername),
              (void*)nextid,NULL);
    sdsfree(lowername);
    unsigned long thisid = nextid;
    nextid++;

    /* We never assign the last bit in the user commands bitmap structure,
     * this way we can later check if this bit is set, understanding if the
     * current ACL for the user was created starting with a +@all to add all
     * the possible commands and just subtracting other single commands or
     * categories, or if, instead, the ACL was created just adding commands
     * and command categories from scratch, not allowing future commands by
     * default (loaded via mod...",1499.0,1524.0,1.0,18.0,26.0,14,6,26,8,3,17,4,4,2,8,,0,13,2,1,1,unsigned long
2717,5037,ACLClearCommandID,1,ACLClearCommandID,void ACLClearCommandID (void),acl.c,"void ACLClearCommandID(void) {
    if (commandId) raxFree(commandId);
    commandId = NULL;
    nextid = 0;
}",1527.0,1531.0,1.0,1.0,5.0,2,1,5,3,0,5,2,2,1,1,,0,4,2,1,1,void
2718,5053,ACLGetUserByName,1,ACLGetUserByName,"user ACLGetUserByName (char*,size_t)",acl.c,"user *ACLGetUserByName(const char *name, size_t namelen) {
    void *myuser = raxFind(Users,(unsigned char*)name,namelen);
    if (myuser == raxNotFound) return NULL;
    return myuser;
}",1534.0,1538.0,1.0,1.0,5.0,3,3,8,6,7,2,2,2,0,1,,0,2,4,2,2,user
2719,5077,ACLSelectorCheckKey,1,ACLSelectorCheckKey,"int ACLSelectorCheckKey (aclSelector*,char*,int,int)",acl.c,"static int ACLSelectorCheckKey(aclSelector *selector, const char *key, int keylen, int keyspec_flags) {
    /* The selector can access any key */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) return ACL_OK;

    listIter li;
    listNode *ln;
    listRewind(selector->patterns,&li);

    int key_flags = 0;
    if (keyspec_flags & CMD_KEY_ACCESS) key_flags |= ACL_READ_PERMISSION;
    if (keyspec_flags & CMD_KEY_INSERT) key_flags |= ACL_WRITE_PERMISSION;
    if (keyspec_flags & CMD_KEY_DELETE) key_flags |= ACL_WRITE_PERMISSION;
    if (keyspec_flags & CMD_KEY_UPDATE) key_flags |= ACL_WRITE_PERMISSION;

    /* Test this key against every pattern. */
    while((ln = listNext(&li))) {
        keyPattern *pattern = listNodeValue(ln);
        if ((pattern->flags & key_flags) != key_flags)
            continue;
        size_t plen = sdslen(pattern->pattern);
        if (stringmatchlen(pattern->pattern,plen,key,keylen,0))
            return ACL_OK;
    }
    return ACL_DENIED_KEY;
}",1548.0,1572.0,1.0,26.0,25.0,28,6,26,9,2,10,10,11,5,4,,0,9,8,4,4,int
2720,5227,ACLSelectorHasUnrestrictedKeyAccess,1,ACLSelectorHasUnrestrictedKeyAccess,"int ACLSelectorHasUnrestrictedKeyAccess (aclSelector*,int)",acl.c,"static int ACLSelectorHasUnrestrictedKeyAccess(aclSelector *selector, int flags) {
    /* The selector can access any key */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) return 1;

    listIter li;
    listNode *ln;
    listRewind(selector->patterns,&li);

    int access_flags = 0;
    if (flags & CMD_KEY_ACCESS) access_flags |= ACL_READ_PERMISSION;
    if (flags & CMD_KEY_INSERT) access_flags |= ACL_WRITE_PERMISSION;
    if (flags & CMD_KEY_DELETE) access_flags |= ACL_WRITE_PERMISSION;
    if (flags & CMD_KEY_UPDATE) access_flags |= ACL_WRITE_PERMISSION;

    /* Test this key against every pattern. */
    while((ln = listNext(&li))) {
        keyPattern *pattern = listNodeValue(ln);
        if ((pattern->flags & access_flags) != access_flags)
            continue;
        if (!strcmp(pattern->pattern,""*"")) {
           return 1;
       }
    }
    return 0;
}",1579.0,1603.0,1.0,26.0,25.0,27,7,21,6,1,7,10,11,4,2,,0,6,4,2,2,int
2721,5360,ACLCheckChannelAgainstList,1,ACLCheckChannelAgainstList,"int ACLCheckChannelAgainstList (list*,char*,int,int)",acl.c,"static int ACLCheckChannelAgainstList(list *reference, const char *channel, int channellen, int is_pattern) {
    listIter li;
    listNode *ln;

    listRewind(reference, &li);
    while((ln = listNext(&li))) {
        sds pattern = listNodeValue(ln);
        size_t plen = sdslen(pattern);
        /* Channel patterns are matched literally against the channels in
         * the list. Regular channels perform pattern matching. */
        if ((is_pattern && !strcmp(pattern,channel)) || 
            (!is_pattern && stringmatchlen(pattern,plen,channel,channellen,0)))
        {
            return ACL_OK;
        }
    }
    return ACL_DENIED_CHANNEL;
}",1613.0,1630.0,1.0,22.0,18.0,11,6,17,8,5,5,3,4,2,4,,0,4,8,4,4,int
2722,5425,initACLKeyResultCache,1,initACLKeyResultCache,void initACLKeyResultCache (aclKeyResultCache*),acl.c,"void initACLKeyResultCache(aclKeyResultCache *cache) {
    cache->keys_init = 0;
}",1639.0,1641.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
2723,5435,cleanupACLKeyResultCache,1,cleanupACLKeyResultCache,void cleanupACLKeyResultCache (aclKeyResultCache*),acl.c,"void cleanupACLKeyResultCache(aclKeyResultCache *cache) {
    if (cache->keys_init) getKeysFreeResult(&(cache->keys));
}",1643.0,1645.0,1.0,1.0,3.0,3,2,2,1,4,3,2,2,1,1,,0,2,2,1,1,void
2724,5450,ACLSelectorCheckCmd,1,ACLSelectorCheckCmd,"int ACLSelectorCheckCmd (aclSelector*,redisCommand*,robj**,int,int*,aclKeyResultCache*)",acl.c,"static int ACLSelectorCheckCmd(aclSelector *selector, struct redisCommand *cmd, robj **argv, int argc, int *keyidxptr, aclKeyResultCache *cache) {
    uint64_t id = cmd->id;
    int ret;
    if (!(selector->flags & SELECTOR_FLAG_ALLCOMMANDS) && !(cmd->flags & CMD_NO_AUTH)) {
        /* If the bit is not set we have to check further, in case the
         * command is allowed just with that specific first argument. */
        if (ACLGetSelectorCommandBit(selector,id) == 0) {
            /* Check if the first argument matches. */
            if (argc < 2 ||
                selector->allowed_firstargs == NULL ||
                selector->allowed_firstargs[id] == NULL)
            {
                return ACL_DENIED_CMD;
            }

            long subid = 0;
            while (1) {
                if (selector->allowed_firstargs[id][subid] == NULL)
                    return ACL_DENIED_CMD;
                int idx = cmd->parent ? 2 : 1;
                if (!strcasecmp(argv[idx]->ptr...",1655.0,1723.0,1.0,28.0,69.0,120,19,98,18,2,31,19,43,14,11,,0,27,12,6,6,int
2725,5845,ACLUserCheckKeyPerm,1,ACLUserCheckKeyPerm,"int ACLUserCheckKeyPerm (user*,char*,int,int)",acl.c,"int ACLUserCheckKeyPerm(user *u, const char *key, int keylen, int flags) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* Check all of the selectors */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        if (ACLSelectorCheckKey(s, key, keylen, flags) == ACL_OK) {
            return ACL_OK;
        }
    }
    return ACL_DENIED_KEY;
}",1731.0,1747.0,1.0,26.0,17.0,9,5,13,8,1,5,4,5,2,3,,0,4,8,4,4,int
2726,5907,ACLUserCheckCmdWithUnrestrictedKeyAccess,1,ACLUserCheckCmdWithUnrestrictedKeyAccess,"int ACLUserCheckCmdWithUnrestrictedKeyAccess (user*,redisCommand*,robj**,int,int)",acl.c,"int ACLUserCheckCmdWithUnrestrictedKeyAccess(user *u, struct redisCommand *cmd, robj **argv, int argc, int flags) {
    listIter li;
    listNode *ln;
    int local_idxptr;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return 1;

    /* For multiple selectors, we cache the key result in between selector
     * calls to prevent duplicate lookups. */
    aclKeyResultCache cache;
    initACLKeyResultCache(&cache);

    /* Check each selector sequentially */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        int acl_retval = ACLSelectorCheckCmd(s, cmd, argv, argc, &local_idxptr, &cache);
        if (acl_retval == ACL_OK && ACLSelectorHasUnrestrictedKeyAccess(s, flags)) {
            cleanupACLKeyResultCache(&cache);
            return 1;
        }
    }
    cleanupACLKeyResultCache(&cache);
    return 0;
}",1755.0,1780.0,1.0,41.0,26.0,16,6,22,12,1,9,4,5,2,7,,0,5,10,5,5,int
2727,5987,ACLUserCheckChannelPerm,1,ACLUserCheckChannelPerm,"int ACLUserCheckChannelPerm (user*,sds,int)",acl.c,"int ACLUserCheckChannelPerm(user *u, sds channel, int is_pattern) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* Check all of the selectors */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        /* The selector can run any keys */
        if (s->flags & SELECTOR_FLAG_ALLCHANNELS) return ACL_OK;

        /* Otherwise, loop over the selectors list and check each channel */
        if (ACLCheckChannelAgainstList(s->channels, channel, sdslen(channel), is_pattern) == ACL_OK) {
            return ACL_OK;
        }
    }
    return ACL_DENIED_CHANNEL;
}",1787.0,1807.0,1.0,26.0,21.0,13,7,14,7,1,8,5,7,5,4,,0,7,6,3,3,int
2728,6066,ACLCheckAllUserCommandPerm,1,ACLCheckAllUserCommandPerm,"int ACLCheckAllUserCommandPerm (user*,redisCommand*,robj**,int,int*)",acl.c,"int ACLCheckAllUserCommandPerm(user *u, struct redisCommand *cmd, robj **argv, int argc, int *idxptr) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* We have to pick a single error to log, the logic for picking is as follows:
     * 1) If no selector can execute the command, return the command.
     * 2) Return the last key or channel that no selector could match. */
    int relevant_error = ACL_DENIED_CMD;
    int local_idxptr = 0, last_idx = 0;

    /* For multiple selectors, we cache the key result in between selector
     * calls to prevent duplicate lookups. */
    aclKeyResultCache cache;
    initACLKeyResultCache(&cache);

    /* Check each selector sequentially */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        int acl_retval = ACLSelectorCheckCmd(s, cmd, argv, argc, &local_idxptr, &...",1814.0,1852.0,1.0,26.0,39.0,27,9,36,14,3,8,5,7,1,6,,0,4,10,5,5,int
2729,6182,ACLCheckAllPerm,1,ACLCheckAllPerm,"int ACLCheckAllPerm (client*,int*)",acl.c,"int ACLCheckAllPerm(client *c, int *idxptr) {
    return ACLCheckAllUserCommandPerm(c->user, c->cmd, c->argv, c->argc, idxptr);
}",1855.0,1857.0,1.0,1.0,3.0,4,1,5,2,3,5,1,1,0,1,,0,4,4,2,2,int
2730,6203,ACLKillPubsubClientsIfNeeded,1,ACLKillPubsubClientsIfNeeded,"void ACLKillPubsubClientsIfNeeded (user*,user*)",acl.c,"void ACLKillPubsubClientsIfNeeded(user *new, user *original) {
    listIter li, lpi;
    listNode *ln, *lpn;
    robj *o;
    int kill = 0;
    
    /* First optimization is we check if any selector has all channel
     * permissions. */
    listRewind(new->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        if (s->flags & SELECTOR_FLAG_ALLCHANNELS) return;
    }

    /* Second optimization is to check if the new list of channels
     * is a strict superset of the original. This is done by
     * created an ""upcoming"" list of all channels that are in
     * the new user and checking each of the existing channels
     * against it.  */
    list *upcoming = listCreate();
    listRewind(new->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        listRewind(s->channels, &lpi);
        while((lpn = listNext(&lpi))) {
            listAddNodeTail(upcoming, listNo...",1861.0,1965.0,1.0,41.0,105.0,95,11,108,17,1,54,20,39,15,37,,0,41,4,2,2,void
2731,6571,ACLMergeSelectorArguments,1,ACLMergeSelectorArguments,"sds ACLMergeSelectorArguments (sds*,int,int*,int*)",acl.c,"sds *ACLMergeSelectorArguments(sds *argv, int argc, int *merged_argc, int *invalid_idx) {
    *merged_argc = 0;
    int open_bracket_start = -1;

    sds *acl_args = (sds *) zmalloc(sizeof(sds) * argc);

    sds selector = NULL;
    for (int j = 0; j < argc; j++) {
        char *op = argv[j];

        if (op[0] == '(' && op[sdslen(op) - 1] != ')') {
            selector = sdsdup(argv[j]);
            open_bracket_start = j;
            continue;
        }

        if (open_bracket_start != -1) {
            selector = sdscatfmt(selector, "" %s"", op);
            if (op[sdslen(op) - 1] == ')') {
                open_bracket_start = -1;
                acl_args[*merged_argc] = selector;                        
                (*merged_argc)++;
            }
            continue;
        }

        acl_args[*merged_argc] = sdsdup(argv[j]);
        (*merged_argc)++;
    }

    if (open_bracket_start != -1) {
        for (int i = 0; i < *merged_argc; i++) sdsfree(acl_args[i]);
        zfr...",1983.0,2022.0,1.0,1.0,40.0,48,13,48,12,3,8,10,14,2,8,,0,6,8,4,4,sds
2732,6731,ACLStringSetUser,1,ACLStringSetUser,"sds ACLStringSetUser (user*,sds,sds*,int)",acl.c,"sds ACLStringSetUser(user *u, sds username, sds *argv, int argc) {
    serverAssert(u != NULL || username != NULL);

    sds error = NULL;

    int merged_argc = 0, invalid_idx = 0;
    sds *acl_args = ACLMergeSelectorArguments(argv, argc, &merged_argc, &invalid_idx);

    if (!acl_args) {
        return sdscatfmt(sdsempty(),
                         ""Unmatched parenthesis in acl selector starting ""
                         ""at '%s'."", (char *) argv[invalid_idx]);
    }

    /* Create a temporary user to validate and stage all changes against
     * before applying to an existing user or creating a new user. If all
     * arguments are valid the user parameters will all be applied together.
     * If there are any errors then none of the changes will be applied. */
    user *tempu = ACLCreateUnlinkedUser();
    if (u) {
        ACLCopyUser(tempu, u);
    }

    for (int j = 0; j < merged_argc; j++) {
        if (ACLSetUser(tempu,acl_args[j],(ssize_t) sdslen(acl_args[j])) != C_OK) {
...",2029.0,2084.0,1.0,4.0,56.0,37,11,52,13,2,19,9,9,2,19,,0,10,8,4,4,sds
2733,6907,ACLAppendUserForLoading,1,ACLAppendUserForLoading,"int ACLAppendUserForLoading (sds*,int,int*)",acl.c,"int ACLAppendUserForLoading(sds *argv, int argc, int *argc_err) {
    if (argc < 2 || strcasecmp(argv[0],""user"")) {
        if (argc_err) *argc_err = 0;
        return C_ERR;
    }

    if (listSearchKey(UsersToLoad, argv[1])) {
        if (argc_err) *argc_err = 1;
        errno = EALREADY;
        return C_ERR; 
    }

    /* Merged selectors before trying to process */
    int merged_argc;
    sds *acl_args = ACLMergeSelectorArguments(argv + 2, argc - 2, &merged_argc, argc_err);

    if (!acl_args) {
        return C_ERR;
    }

    /* Try to apply the user rules in a fake user to see if they
     * are actually valid. */
    user *fakeuser = ACLCreateUnlinkedUser();

    for (int j = 0; j < merged_argc; j++) {
        if (ACLSetUser(fakeuser,acl_args[j],sdslen(acl_args[j])) == C_ERR) {
            if (errno != ENOENT) {
                ACLFreeUser(fakeuser);
                if (argc_err) *argc_err = j;
                for (int i = 0; i < merged_argc; i++) sdsfree(acl_args[i]);
  ...",2104.0,2150.0,1.0,15.0,47.0,44,14,53,15,0,14,13,24,4,12,,0,9,6,3,3,int
2734,7122,ACLLoadConfiguredUsers,1,ACLLoadConfiguredUsers,int ACLLoadConfiguredUsers (void),acl.c,"int ACLLoadConfiguredUsers(void) {
    listIter li;
    listNode *ln;
    listRewind(UsersToLoad,&li);
    while ((ln = listNext(&li)) != NULL) {
        sds *aclrules = listNodeValue(ln);
        sds username = aclrules[0];

        if (ACLStringHasSpaces(aclrules[0],sdslen(aclrules[0]))) {
            serverLog(LL_WARNING,""Spaces not allowed in ACL usernames"");
            return C_ERR;
        }

        user *u = ACLCreateUser(username,sdslen(username));
        if (!u) {
            /* Only valid duplicate user is the default one. */
            serverAssert(!strcmp(username, ""default""));
            u = ACLGetUserByName(""default"",7);
            ACLSetUser(u,""reset"",-1);
        }

        /* Load every rule defined for this user. */
        for (int j = 1; aclrules[j]; j++) {
            if (ACLSetUser(u,aclrules[j],sdslen(aclrules[j])) != C_OK) {
                const char *errmsg = ACLSetUserStringError();
                serverLog(LL_WARNING,""Error loading ACL rule '%s' fo...",2155.0,2197.0,1.0,24.0,43.0,42,15,37,10,1,18,7,13,6,15,,0,12,2,1,1,int
2735,7325,ACLLoadFromFile,1,ACLLoadFromFile,sds ACLLoadFromFile (char*),acl.c,"sds ACLLoadFromFile(const char *filename) {
    FILE *fp;
    char buf[1024];

    /* Open the ACL file. */
    if ((fp = fopen(filename,""r"")) == NULL) {
        sds errors = sdscatprintf(sdsempty(),
            ""Error loading ACLs, opening file '%s': %s"",
            filename, strerror(errno));
        return errors;
    }

    /* Load the whole file as a single string in memory. */
    sds acls = sdsempty();
    while(fgets(buf,sizeof(buf),fp) != NULL)
        acls = sdscat(acls,buf);
    fclose(fp);

    /* Split the file into lines and attempt to load each line. */
    int totlines;
    sds *lines, errors = sdsempty();
    lines = sdssplitlen(acls,strlen(acls),""\n"",1,&totlines);
    sdsfree(acls);

    /* We do all the loading in a fresh instance of the Users radix tree,
     * so if there are errors loading the ACL file we can rollback to the
     * old version. */
    rax *old_users = Users;
    Users = raxNew();

    /* Load each line of the file. */
    for (int i = 0; i < t...",2222.0,2379.0,1.0,65.0,158.0,75,13,134,25,1,48,25,34,6,43,,0,33,2,1,1,sds
2736,7752,ACLSaveToFile,1,ACLSaveToFile,int ACLSaveToFile (char*),acl.c,"int ACLSaveToFile(const char *filename) {
    sds acl = sdsempty();
    int fd = -1;
    sds tmpfilename = NULL;
    int retval = C_ERR;

    /* Let's generate an SDS string containing the new version of the
     * ACL file. */
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        /* Return information in the configuration file format. */
        sds user = sdsnew(""user "");
        user = sdscatsds(user,u->name);
        user = sdscatlen(user,"" "",1);
        robj *descr = ACLDescribeUser(u);
        user = sdscatsds(user,descr->ptr);
        decrRefCount(descr);
        acl = sdscatsds(acl,user);
        acl = sdscatlen(acl,""\n"",1);
        sdsfree(user);
    }
    raxStop(&ri);

    /* Create a temp file with the new content. */
    tmpfilename = sdsnew(filename);
    tmpfilename = sdscatfmt(tmpfilename,"".tmp-%i-%I"",
        (int) getpid(),commandTimeSnapshot());
    if ((fd = open(tmpfilename,O_WRONLY...",2384.0,2459.0,1.0,17.0,76.0,63,15,81,18,0,31,17,14,3,28,,0,18,2,1,1,int
2737,8075,ACLLoadUsersAtStartup,1,ACLLoadUsersAtStartup,void ACLLoadUsersAtStartup (void),acl.c,"void ACLLoadUsersAtStartup(void) {
    if (server.acl_filename[0] != '\0' && listLength(UsersToLoad) != 0) {
        serverLog(LL_WARNING,
            ""Configuring Redis with users defined in redis.conf and at ""
            ""the same setting an ACL file path is invalid. This setup ""
            ""is very likely to lead to configuration errors and security ""
            ""holes, please define either an ACL file or declare users ""
            ""directly in your redis.conf, but not both."");
        exit(1);
    }

    if (ACLLoadConfiguredUsers() == C_ERR) {
        serverLog(LL_WARNING,
            ""Critical error while loading ACLs. Exiting."");
        exit(1);
    }

    if (server.acl_filename[0] != '\0') {
        sds errors = ACLLoadFromFile(server.acl_filename);
        if (errors) {
            serverLog(LL_WARNING,
                ""Aborting Redis startup because of ACL errors: %s"", errors);
            sdsfree(errors);
            exit(1);
        }
    }
}",2466.0,2492.0,1.0,42.0,27.0,22,10,12,3,0,9,5,6,4,6,,0,5,2,1,1,void
2738,8199,ACLLogMatchEntry,1,ACLLogMatchEntry,"int ACLLogMatchEntry (ACLLogEntry*,ACLLogEntry*)",acl.c,"int ACLLogMatchEntry(ACLLogEntry *a, ACLLogEntry *b) {
    if (a->reason != b->reason) return 0;
    if (a->context != b->context) return 0;
    mstime_t delta = a->ctime - b->ctime;
    if (delta < 0) delta = -delta;
    if (delta > ACL_LOG_GROUPING_MAX_TIME_DELTA) return 0;
    if (sdscmp(a->object,b->object) != 0) return 0;
    if (sdscmp(a->username,b->username) != 0) return 0;
    return 1;
}",2517.0,2526.0,1.0,16.0,10.0,20,7,15,3,1,12,7,7,10,2,,0,12,4,2,2,int
2739,8306,ACLUpdateInfoMetrics,1,ACLUpdateInfoMetrics,void ACLUpdateInfoMetrics (int),acl.c,"void ACLUpdateInfoMetrics(int reason){
    if (reason == ACL_DENIED_AUTH) {
        server.acl_info.user_auth_failures++;
    } else if (reason == ACL_DENIED_CMD) {
        server.acl_info.invalid_cmd_accesses++;
    } else if (reason == ACL_DENIED_KEY) {
        server.acl_info.invalid_key_accesses++;
    } else if (reason == ACL_DENIED_CHANNEL) {
        server.acl_info.invalid_channel_accesses++;
    } else {
        serverPanic(""Unknown ACL_DENIED encoding"");
    }
}",2538.0,2550.0,1.0,18.0,13.0,4,3,2,2,1,0,2,2,0,0,,0,0,2,1,1,void
2740,8379,addACLLogEntry,1,addACLLogEntry,"void addACLLogEntry (client*,int,int,int,sds,sds)",acl.c,"void addACLLogEntry(client *c, int reason, int context, int argpos, sds username, sds object) {
    /* Update ACL info metrics */
    ACLUpdateInfoMetrics(reason);
    
    /* Create a new entry. */
    struct ACLLogEntry *le = zmalloc(sizeof(*le));
    le->count = 1;
    le->reason = reason;
    le->username = sdsdup(username ? username : c->user->name);
    le->ctime = commandTimeSnapshot();
    le->entry_id = ACLLogEntryCount;
    le->timestamp_created = le->ctime;

    if (object) {
        le->object = object;
    } else {
        switch(reason) {
            case ACL_DENIED_CMD: le->object = sdsdup(c->cmd->fullname); break;
            case ACL_DENIED_KEY: le->object = sdsdup(c->argv[argpos]->ptr); break;
            case ACL_DENIED_CHANNEL: le->object = sdsdup(c->argv[argpos]->ptr); break;
            case ACL_DENIED_AUTH: le->object = sdsdup(c->argv[0]->ptr); break;
            default: le->object = sdsempty();
        }
    }

    /* if we have a real client from the networ...",2567.0,2640.0,1.0,17.0,74.0,51,11,56,16,6,36,6,6,2,13,,0,30,12,6,6,void
2741,8670,getAclErrorMessage,1,getAclErrorMessage,"sds getAclErrorMessage (int,user*,redisCommand*,sds,int)",acl.c,"sds getAclErrorMessage(int acl_res, user *user, struct redisCommand *cmd, sds errored_val, int verbose) {
    switch (acl_res) {
    case ACL_DENIED_CMD:
        return sdscatfmt(sdsempty(), ""User %S has no permissions to run ""
                                     ""the '%S' command"", user->name, cmd->fullname);
    case ACL_DENIED_KEY:
        if (verbose) {
            return sdscatfmt(sdsempty(), ""User %S has no permissions to access ""
                                         ""the '%S' key"", user->name, errored_val);
        } else {
            return sdsnew(""No permissions to access a key"");
        }
    case ACL_DENIED_CHANNEL:
        if (verbose) {
            return sdscatfmt(sdsempty(), ""User %S has no permissions to access ""
                                         ""the '%S' channel"", user->name, errored_val);
        } else {
            return sdsnew(""No permissions to access a channel"");
        }
    }
    serverPanic(""Reached deadcode on getAclErrorMessage"");
}",2642.0,2663.0,1.0,9.0,22.0,5,2,9,5,3,11,4,6,0,7,,0,7,10,5,5,sds
2742,8744,aclCatWithFlags,1,aclCatWithFlags,"void aclCatWithFlags (client*,dict*,uint64_t,int*)",acl.c,"void aclCatWithFlags(client *c, dict *commands, uint64_t cflag, int *arraylen) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->flags & CMD_MODULE) continue;
        if (cmd->acl_categories & cflag) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            (*arraylen)++;
        }

        if (cmd->subcommands_dict) {
            aclCatWithFlags(c, cmd->subcommands_dict, cflag, arraylen);
        }
    }
    dictReleaseIterator(di);
}",2670.0,2687.0,1.0,25.0,18.0,15,7,20,8,0,12,6,8,4,6,,0,10,8,4,4,void
2743,8816,aclAddReplySelectorDescription,1,aclAddReplySelectorDescription,"int aclAddReplySelectorDescription (client*,aclSelector*)",acl.c,"int aclAddReplySelectorDescription(client *c, aclSelector *s) {
    listIter li;
    listNode *ln;

    /* Commands */
    addReplyBulkCString(c,""commands"");
    sds cmddescr = ACLDescribeSelectorCommandRules(s);
    addReplyBulkSds(c,cmddescr);
    
    /* Key patterns */
    addReplyBulkCString(c,""keys"");
    if (s->flags & SELECTOR_FLAG_ALLKEYS) {
        addReplyBulkCBuffer(c,""~*"",2);
    } else {
        sds dsl = sdsempty();
        listRewind(s->patterns,&li);
        while((ln = listNext(&li))) {
            keyPattern *thispat = (keyPattern *) listNodeValue(ln);
            if (ln != listFirst(s->patterns)) dsl = sdscat(dsl, "" "");
            dsl = sdsCatPatternString(dsl, thispat);
        }
        addReplyBulkSds(c, dsl);
    }

    /* Pub/sub patterns */
    addReplyBulkCString(c,""channels"");
    if (s->flags & SELECTOR_FLAG_ALLCHANNELS) {
        addReplyBulkCBuffer(c,""&*"",2);
    } else {
        sds dsl = sdsempty();
        listRewind(s->channels,&li);
        while...",2695.0,2734.0,1.0,19.0,40.0,7,4,11,3,0,9,3,3,2,7,,0,3,4,2,2,int
2744,8986,aclCommand,1,aclCommand,void aclCommand (client*),acl.c,"void aclCommand(client *c) {
    char *sub = c->argv[1]->ptr;
    if (!strcasecmp(sub,""setuser"") && c->argc >= 3) {
        /* Initially redact all of the arguments to not leak any information
         * about the user. */
        for (int j = 2; j < c->argc; j++) {
            redactClientCommandArgument(c, j);
        }

        sds username = c->argv[2]->ptr;
        /* Check username validity. */
        if (ACLStringHasSpaces(username,sdslen(username))) {
            addReplyErrorFormat(c,
                ""Usernames can't contain spaces or null characters"");
            return;
        }

        user *u = ACLGetUserByName(username,sdslen(username));

        sds *temp_argv = zmalloc(c->argc * sizeof(sds));
        for (int i = 3; i < c->argc; i++) temp_argv[i-3] = c->argv[i]->ptr;

        sds error = ACLStringSetUser(u, username, temp_argv, c->argc - 3);
        zfree(temp_argv);
        if (error == NULL) {
            addReply(c,shared.ok);
        } else {
            addR...",2750.0,3071.0,1.0,27.0,322.0,28,12,33,11,0,17,6,10,5,10,,0,13,2,1,1,void
2745,10430,addReplyCommandCategories,1,addReplyCommandCategories,"void addReplyCommandCategories (client*,redisCommand*)",acl.c,"void addReplyCommandCategories(client *c, struct redisCommand *cmd) {
    int flagcount = 0;
    void *flaglen = addReplyDeferredLen(c);
    for (int j = 0; ACLCommandCategories[j].flag != 0; j++) {
        if (cmd->acl_categories & ACLCommandCategories[j].flag) {
            addReplyStatusFormat(c, ""@%s"", ACLCommandCategories[j].name);
            flagcount++;
        }
    }
    setDeferredSetLen(c, flaglen, flagcount);
}",3073.0,3083.0,1.0,1.0,11.0,13,7,16,6,0,7,3,4,3,3,,0,5,4,2,2,void
2746,10486,authCommand,1,authCommand,void authCommand (client*),acl.c,"void authCommand(client *c) {
    /* Only two or three argument forms are allowed. */
    if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }
    /* Always redact the second argument */
    redactClientCommandArgument(c, 1);

    /* Handle the two different forms here. The form with two arguments
     * will just use ""default"" as username. */
    robj *username, *password;
    if (c->argc == 2) {
        /* Mimic the old behavior of giving an error for the two argument
         * form if no password is configured. */
        if (DefaultUser->flags & USER_FLAG_NOPASS) {
            addReplyError(c,""AUTH <password> called without any password ""
                            ""configured for the default user. Are you sure ""
                            ""your configuration is correct?"");
            return;
        }

        username = shared.default_username; 
        password = c->argv[1];
    } else {
        username = c->argv[1];
        password ...",3090.0,3128.0,1.0,33.0,39.0,18,9,24,9,0,11,6,7,4,6,,0,6,2,1,1,void
2747,10600,ACLUpdateDefaultUserPassword,1,ACLUpdateDefaultUserPassword,void ACLUpdateDefaultUserPassword (sds),acl.c,"void ACLUpdateDefaultUserPassword(sds password) {
    ACLSetUser(DefaultUser,""resetpass"",-1);
    if (password) {
        sds aclop = sdscatlen(sdsnew("">""), password, sdslen(password));
        ACLSetUser(DefaultUser,aclop,sdslen(aclop));
        sdsfree(aclop);
    } else {
        ACLSetUser(DefaultUser,""nopass"",-1);
    }
}",3132.0,3141.0,1.0,1.0,10.0,2,2,9,3,2,9,2,2,0,7,,0,6,2,1,1,void
2748,10647,listCreate,1,listCreate,list listCreate (void),adlist.c,"list *listCreate(void)
{
    struct list *list;

    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;
    list->head = list->tail = NULL;
    list->len = 0;
    list->dup = NULL;
    list->free = NULL;
    list->match = NULL;
    return list;
}",42.0,54.0,1.0,1.0,13.0,16,5,15,2,71,4,2,2,1,1,,0,4,2,1,1,list
2749,10696,listEmpty,1,listEmpty,void listEmpty (list*),adlist.c,"void listEmpty(list *list)
{
    unsigned long len;
    listNode *current, *next;

    current = list->head;
    len = list->len;
    while(len--) {
        next = current->next;
        if (list->free) list->free(current->value);
        zfree(current);
        current = next;
    }
    list->head = list->tail = NULL;
    list->len = 0;
}",57.0,72.0,1.0,1.0,16.0,17,3,17,5,6,9,3,4,0,2,,0,7,2,1,1,void
2750,10754,listRelease,1,listRelease,void listRelease (list*),adlist.c,"void listRelease(list *list)
{
    listEmpty(list);
    zfree(list);
}",77.0,81.0,1.0,1.0,5.0,0,0,2,1,52,2,1,1,0,2,,0,0,2,1,1,void
2751,10763,listAddNodeHead,1,listAddNodeHead,"list listAddNodeHead (list*,void*)",adlist.c,"list *listAddNodeHead(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    listLinkNodeHead(list, node);
    return list;
}",89.0,98.0,1.0,1.0,10.0,6,5,9,4,8,3,2,2,1,2,,0,2,4,2,2,list
2752,10792,listLinkNodeHead,1,listLinkNodeHead,"void listLinkNodeHead (list*,listNode*)",adlist.c,"void listLinkNodeHead(list* list, listNode *node) {
    if (list->len == 0) {
        list->head = list->tail = node;
        node->prev = node->next = NULL;
    } else {
        node->prev = NULL;
        node->next = list->head;
        list->head->prev = node;
        list->head = node;
    }
    list->len++;
}",103.0,114.0,1.0,1.0,12.0,12,4,8,3,3,6,2,2,1,0,,0,6,4,2,2,void
2753,10853,listAddNodeTail,1,listAddNodeTail,"list listAddNodeTail (list*,void*)",adlist.c,"list *listAddNodeTail(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    listLinkNodeTail(list, node);
    return list;
}",122.0,131.0,1.0,1.0,10.0,6,5,9,4,62,3,2,2,1,2,,0,2,4,2,2,list
2754,10882,listLinkNodeTail,1,listLinkNodeTail,"void listLinkNodeTail (list*,listNode*)",adlist.c,"void listLinkNodeTail(list *list, listNode *node) {
    if (list->len == 0) {
        list->head = list->tail = node;
        node->prev = node->next = NULL;
    } else {
        node->prev = list->tail;
        node->next = NULL;
        list->tail->next = node;
        list->tail = node;
    }
    list->len++;
}",136.0,147.0,1.0,1.0,12.0,12,4,8,3,2,6,2,2,1,0,,0,6,4,2,2,void
2755,10943,listInsertNode,1,listInsertNode,"list listInsertNode (list*,listNode*,void*,int)",adlist.c,"list *listInsertNode(list *list, listNode *old_node, void *value, int after) {
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    if (after) {
        node->prev = old_node;
        node->next = old_node->next;
        if (list->tail == old_node) {
            list->tail = node;
        }
    } else {
        node->next = old_node;
        node->prev = old_node->prev;
        if (list->head == old_node) {
            list->head = node;
        }
    }
    if (node->prev != NULL) {
        node->prev->next = node;
    }
    if (node->next != NULL) {
        node->next->prev = node;
    }
    list->len++;
    return list;
}",149.0,176.0,1.0,1.0,28.0,27,7,25,6,0,12,6,7,4,1,,0,12,8,4,4,list
2756,11056,listDelNode,1,listDelNode,"void listDelNode (list*,listNode*)",adlist.c,"void listDelNode(list *list, listNode *node)
{
    listUnlinkNode(list, node);
    if (list->free) list->free(node->value);
    zfree(node);
}",182.0,187.0,1.0,1.0,6.0,3,1,6,2,51,4,2,2,0,3,,0,1,4,2,2,void
2757,11079,listUnlinkNode,1,listUnlinkNode,"void listUnlinkNode (list*,listNode*)",adlist.c,"void listUnlinkNode(list *list, listNode *node) {
    if (node->prev)
        node->prev->next = node->next;
    else
        list->head = node->next;
    if (node->next)
        node->next->prev = node->prev;
    else
        list->tail = node->prev;

    node->next = NULL;
    node->prev = NULL;

    list->len--;
}",192.0,206.0,1.0,1.0,15.0,16,3,11,3,6,9,3,3,2,0,,0,9,4,2,2,void
2758,11145,listGetIterator,1,listGetIterator,"listIter listGetIterator (list*,int)",adlist.c,"listIter *listGetIterator(list *list, int direction)
{
    listIter *iter;

    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;
    if (direction == AL_START_HEAD)
        iter->next = list->head;
    else
        iter->next = list->tail;
    iter->direction = direction;
    return iter;
}",212.0,223.0,1.0,21.0,12.0,10,5,10,4,0,4,3,3,1,1,,0,4,4,2,2,listIter
2759,11194,listReleaseIterator,1,listReleaseIterator,void listReleaseIterator (listIter*),adlist.c,"void listReleaseIterator(listIter *iter) {
    zfree(iter);
}",226.0,228.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2760,11201,listRewind,1,listRewind,"void listRewind (list*,listIter*)",adlist.c,"void listRewind(list *list, listIter *li) {
    li->next = list->head;
    li->direction = AL_START_HEAD;
}",231.0,234.0,1.0,20.0,4.0,5,2,3,2,135,3,1,1,0,0,,0,3,4,2,2,void
2761,11221,listRewindTail,1,listRewindTail,"void listRewindTail (list*,listIter*)",adlist.c,"void listRewindTail(list *list, listIter *li) {
    li->next = list->tail;
    li->direction = AL_START_TAIL;
}",236.0,239.0,1.0,20.0,4.0,5,2,3,2,1,3,1,1,0,0,,0,3,4,2,2,void
2762,11241,listNext,1,listNext,listNode listNext (listIter*),adlist.c,"listNode *listNext(listIter *iter)
{
    listNode *current = iter->next;

    if (current != NULL) {
        if (iter->direction == AL_START_HEAD)
            iter->next = current->next;
        else
            iter->next = current->prev;
    }
    return current;
}",255.0,266.0,1.0,31.0,12.0,8,4,8,3,137,4,3,4,1,0,,0,4,2,1,1,listNode
2763,11284,listDup,1,listDup,list listDup (list*),adlist.c,"list *listDup(list *orig)
{
    list *copy;
    listIter iter;
    listNode *node;

    if ((copy = listCreate()) == NULL)
        return NULL;
    copy->dup = orig->dup;
    copy->free = orig->free;
    copy->match = orig->match;
    listRewind(orig, &iter);
    while((node = listNext(&iter)) != NULL) {
        void *value;

        if (copy->dup) {
            value = copy->dup(node->value);
            if (value == NULL) {
                listRelease(copy);
                return NULL;
            }
        } else {
            value = node->value;
        }
        
        if (listAddNodeTail(copy, value) == NULL) {
            /* Free value if dup succeed but listAddNodeTail failed. */
            if (copy->free) copy->free(value);

            listRelease(copy);
            return NULL;
        }
    }
    return copy;
}",276.0,310.0,1.0,1.0,35.0,23,5,31,6,6,9,7,13,3,8,,0,5,2,1,1,list
2764,11389,listSearchKey,1,listSearchKey,"listNode listSearchKey (list*,void*)",adlist.c,"listNode *listSearchKey(list *list, void *key)
{
    listIter iter;
    listNode *node;

    listRewind(list, &iter);
    while((node = listNext(&iter)) != NULL) {
        if (list->match) {
            if (list->match(node->value, key)) {
                return node;
            }
        } else {
            if (key == node->value) {
                return node;
            }
        }
    }
    return NULL;
}",321.0,339.0,1.0,1.0,19.0,7,4,11,5,16,4,4,7,3,3,,0,3,4,2,2,listNode
2765,11440,listIndex,1,listIndex,"listNode listIndex (list*,long)",adlist.c,"listNode *listIndex(list *list, long index) {
    listNode *n;

    if (index < 0) {
        index = (-index)-1;
        n = list->tail;
        while(index-- && n) n = n->prev;
    } else {
        n = list->head;
        while(index-- && n) n = n->next;
    }
    return n;
}",346.0,358.0,1.0,1.0,13.0,8,7,8,3,1,1,3,4,0,0,,0,1,4,2,2,listNode
2766,11492,listRotateTailToHead,1,listRotateTailToHead,void listRotateTailToHead (list*),adlist.c,"void listRotateTailToHead(list *list) {
    if (listLength(list) <= 1) return;

    /* Detach current tail */
    listNode *tail = list->tail;
    list->tail = tail->prev;
    list->tail->next = NULL;
    /* Move it as head */
    list->head->prev = tail;
    tail->prev = NULL;
    tail->next = list->head;
    list->head = tail;
}",361.0,373.0,1.0,8.0,13.0,20,3,16,3,0,10,2,2,1,0,,0,10,2,1,1,void
2767,11552,listRotateHeadToTail,1,listRotateHeadToTail,void listRotateHeadToTail (list*),adlist.c,"void listRotateHeadToTail(list *list) {
    if (listLength(list) <= 1) return;

    listNode *head = list->head;
    /* Detach current head */
    list->head = head->next;
    list->head->prev = NULL;
    /* Move it as tail */
    list->tail->next = head;
    head->next = NULL;
    head->prev = list->tail;
    list->tail = head;
}",376.0,388.0,1.0,8.0,13.0,20,3,16,3,1,10,2,2,1,0,,0,10,2,1,1,void
2768,11612,listJoin,1,listJoin,"void listJoin (list*,list*)",adlist.c,"void listJoin(list *l, list *o) {
    if (o->len == 0) return;

    o->head->prev = l->tail;

    if (l->tail)
        l->tail->next = o->head;
    else
        l->head = o->head;

    l->tail = o->tail;
    l->len += o->len;

    /* Setup other as an empty list. */
    o->head = o->tail = NULL;
    o->len = 0;
}",392.0,408.0,1.0,1.0,17.0,23,4,14,3,2,13,3,3,2,0,,0,13,4,2,2,void
2769,11686,listInitNode,1,listInitNode,"void listInitNode (listNode*,void*)",adlist.c,"void listInitNode(listNode *node, void *value) {
    node->prev = NULL;
    node->next = NULL;
    node->value = value;
}",413.0,417.0,1.0,1.0,5.0,6,2,6,3,1,3,1,1,0,0,,0,3,4,2,2,void
2770,11726,dup,1,list.dup,void* list.dup (void*),adlist.h,void *(*dup)(void *ptr);,50.0,50.0,10.0,27.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void*
2771,11731,free,1,list.free,void list.free (void*),adlist.h,void (*free)(void *ptr);,51.0,51.0,10.0,27.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2772,11736,match,1,list.match,"int list.match (void*,void*)",adlist.h,"int (*match)(void *ptr, void *key);",52.0,52.0,9.0,38.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
2773,11911,aeCreateEventLoop,1,aeCreateEventLoop,aeEventLoop aeCreateEventLoop (int),ae.c,"aeEventLoop *aeCreateEventLoop(int setsize) {
    aeEventLoop *eventLoop;
    int i;

    monotonicInit();    /* just in case the calling app didn't initialize */

    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;
    eventLoop->events = zmalloc(sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zmalloc(sizeof(aeFiredEvent)*setsize);
    if (eventLoop->events == NULL || eventLoop->fired == NULL) goto err;
    eventLoop->setsize = setsize;
    eventLoop->timeEventHead = NULL;
    eventLoop->timeEventNextId = 0;
    eventLoop->stop = 0;
    eventLoop->maxfd = -1;
    eventLoop->beforesleep = NULL;
    eventLoop->aftersleep = NULL;
    eventLoop->flags = 0;
    if (aeApiCreate(eventLoop) == -1) goto err;
    /* Events with mask == AE_NONE are not set. So let's initialize the
     * vector with it. */
    for (i = 0; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return eventLoop;

err:
    if (eventLoop) {
        zfree(eventLoop->events);
     ...",67.0,99.0,1.0,36.0,33.0,40,9,35,6,2,22,9,6,4,8,,0,18,2,1,1,aeEventLoop
2774,12050,aeGetSetSize,1,aeGetSetSize,int aeGetSetSize (aeEventLoop*),ae.c,"int aeGetSetSize(aeEventLoop *eventLoop) {
    return eventLoop->setsize;
}",102.0,104.0,1.0,1.0,3.0,1,1,1,1,3,1,1,1,0,0,,0,1,2,1,1,int
2775,12059,aeSetDontWait,1,aeSetDontWait,"void aeSetDontWait (aeEventLoop*,int)",ae.c,"void aeSetDontWait(aeEventLoop *eventLoop, int noWait) {
    if (noWait)
        eventLoop->flags |= AE_DONT_WAIT;
    else
        eventLoop->flags &= ~AE_DONT_WAIT;
}",111.0,116.0,1.0,28.0,6.0,2,2,2,2,1,1,2,2,0,0,,0,1,4,2,2,void
2776,12089,aeResizeSetSize,1,aeResizeSetSize,"int aeResizeSetSize (aeEventLoop*,int)",ae.c,"int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
    int i;

    if (setsize == eventLoop->setsize) return AE_OK;
    if (eventLoop->maxfd >= setsize) return AE_ERR;
    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;

    eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
    eventLoop->setsize = setsize;

    /* Make sure that if we created new slots, they are initialized with
     * an AE_NONE mask. */
    for (i = eventLoop->maxfd+1; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return AE_OK;
}",125.0,141.0,1.0,46.0,17.0,24,9,20,5,1,11,5,5,3,3,,0,11,4,2,2,int
2777,12190,aeDeleteEventLoop,1,aeDeleteEventLoop,void aeDeleteEventLoop (aeEventLoop*),ae.c,"void aeDeleteEventLoop(aeEventLoop *eventLoop) {
    aeApiFree(eventLoop);
    zfree(eventLoop->events);
    zfree(eventLoop->fired);

    /* Free the time events list. */
    aeTimeEvent *next_te, *te = eventLoop->timeEventHead;
    while (te) {
        next_te = te->next;
        zfree(te);
        te = next_te;
    }
    zfree(eventLoop);
}",143.0,156.0,1.0,1.0,14.0,7,2,12,3,0,9,2,2,0,5,,0,4,2,1,1,void
2778,12227,aeStop,1,aeStop,void aeStop (aeEventLoop*),ae.c,"void aeStop(aeEventLoop *eventLoop) {
    eventLoop->stop = 1;
}",158.0,160.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
2779,12237,aeCreateFileEvent,1,aeCreateFileEvent,"int aeCreateFileEvent (aeEventLoop*,int,int,aeFileProc*,void*)",ae.c,"int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData)
{
    if (fd >= eventLoop->setsize) {
        errno = ERANGE;
        return AE_ERR;
    }
    aeFileEvent *fe = &eventLoop->events[fd];

    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
        return AE_ERR;
    fe->mask |= mask;
    if (mask & AE_READABLE) fe->rfileProc = proc;
    if (mask & AE_WRITABLE) fe->wfileProc = proc;
    fe->clientData = clientData;
    if (fd > eventLoop->maxfd)
        eventLoop->maxfd = fd;
    return AE_OK;
}",162.0,180.0,1.0,15.0,19.0,24,9,24,8,7,9,6,6,3,1,,0,9,10,5,5,int
2780,12334,aeDeleteFileEvent,1,aeDeleteFileEvent,"void aeDeleteFileEvent (aeEventLoop*,int,int)",ae.c,"void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
{
    if (fd >= eventLoop->setsize) return;
    aeFileEvent *fe = &eventLoop->events[fd];
    if (fe->mask == AE_NONE) return;

    /* We want to always remove AE_BARRIER if set when AE_WRITABLE
     * is removed. */
    if (mask & AE_WRITABLE) mask |= AE_BARRIER;

    aeApiDelEvent(eventLoop, fd, mask);
    fe->mask = fe->mask & (~mask);
    if (fd == eventLoop->maxfd && fe->mask == AE_NONE) {
        /* Update the max fd */
        int j;

        for (j = eventLoop->maxfd-1; j >= 0; j--)
            if (eventLoop->events[j].mask != AE_NONE) break;
        eventLoop->maxfd = j;
    }
}",182.0,202.0,1.0,20.0,21.0,25,10,22,5,11,10,6,7,4,1,,0,9,6,3,3,void
2781,12443,aeGetFileClientData,1,aeGetFileClientData,"void* aeGetFileClientData (aeEventLoop*,int)",ae.c,"void *aeGetFileClientData(aeEventLoop *eventLoop, int fd) {
    if (fd >= eventLoop->setsize) return NULL;
    aeFileEvent *fe = &eventLoop->events[fd];
    if (fe->mask == AE_NONE) return NULL;

    return fe->clientData;
}",204.0,210.0,1.0,20.0,7.0,9,6,9,4,2,4,3,3,2,0,,0,4,4,2,2,void*
2782,12482,aeGetFileEvents,1,aeGetFileEvents,"int aeGetFileEvents (aeEventLoop*,int)",ae.c,"int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {
    if (fd >= eventLoop->setsize) return 0;
    aeFileEvent *fe = &eventLoop->events[fd];

    return fe->mask;
}",212.0,217.0,1.0,1.0,6.0,7,5,6,3,2,3,2,2,1,0,,0,3,4,2,2,int
2783,12510,aeCreateTimeEvent,1,aeCreateTimeEvent,"long long aeCreateTimeEvent (aeEventLoop*,long long,aeTimeProc*,void*,aeEventFinalizerProc*)",ae.c,"long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
        aeTimeProc *proc, void *clientData,
        aeEventFinalizerProc *finalizerProc)
{
    long long id = eventLoop->timeEventNextId++;
    aeTimeEvent *te;

    te = zmalloc(sizeof(*te));
    if (te == NULL) return AE_ERR;
    te->id = id;
    te->when = getMonotonicUs() + milliseconds * 1000;
    te->timeProc = proc;
    te->finalizerProc = finalizerProc;
    te->clientData = clientData;
    te->prev = NULL;
    te->next = eventLoop->timeEventHead;
    te->refcount = 0;
    if (te->next)
        te->next->prev = te;
    eventLoop->timeEventHead = te;
    return id;
}",219.0,240.0,1.0,27.0,22.0,33,9,27,8,4,15,3,3,1,2,,0,15,10,5,5,long long
2784,12608,aeDeleteTimeEvent,1,aeDeleteTimeEvent,"int aeDeleteTimeEvent (aeEventLoop*,long long)",ae.c,"int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
{
    aeTimeEvent *te = eventLoop->timeEventHead;
    while(te) {
        if (te->id == id) {
            te->id = AE_DELETED_EVENT_ID;
            return AE_OK;
        }
        te = te->next;
    }
    return AE_ERR; /* NO event with the specified ID found */
}",242.0,253.0,1.0,21.0,12.0,10,4,8,3,1,4,3,4,1,0,,0,4,4,2,2,int
2785,12652,usUntilEarliestTimer,1,usUntilEarliestTimer,int64_t usUntilEarliestTimer (aeEventLoop*),ae.c,"static int64_t usUntilEarliestTimer(aeEventLoop *eventLoop) {
    aeTimeEvent *te = eventLoop->timeEventHead;
    if (te == NULL) return -1;

    aeTimeEvent *earliest = NULL;
    while (te) {
        if ((!earliest || te->when < earliest->when) && te->id != AE_DELETED_EVENT_ID)
            earliest = te;
        te = te->next;
    }

    monotime now = getMonotonicUs();
    return (now >= earliest->when) ? 0 : earliest->when - now;
}",264.0,277.0,1.0,66.0,14.0,23,12,20,5,0,8,4,5,3,1,,0,8,2,1,1,int64_t
2786,12724,processTimeEvents,1,processTimeEvents,int processTimeEvents (aeEventLoop*),ae.c,"static int processTimeEvents(aeEventLoop *eventLoop) {
    int processed = 0;
    aeTimeEvent *te;
    long long maxId;

    te = eventLoop->timeEventHead;
    maxId = eventLoop->timeEventNextId-1;
    monotime now = getMonotonicUs();
    while(te) {
        long long id;

        /* Remove events scheduled for deletion. */
        if (te->id == AE_DELETED_EVENT_ID) {
            aeTimeEvent *next = te->next;
            /* If a reference exists for this timer event,
             * don't free it. This is currently incremented
             * for recursive timerProc calls */
            if (te->refcount) {
                te = next;
                continue;
            }
            if (te->prev)
                te->prev->next = te->next;
            else
                eventLoop->timeEventHead = te->next;
            if (te->next)
                te->next->prev = te->prev;
            if (te->finalizerProc) {
                te->finalizerProc(eventLoop, te->clientData);
           ...",280.0,344.0,1.0,22.0,65.0,54,12,51,8,1,28,13,23,7,4,,0,27,2,1,1,int
2787,12923,aeProcessEvents,1,aeProcessEvents,"int aeProcessEvents (aeEventLoop*,int)",ae.c,"int aeProcessEvents(aeEventLoop *eventLoop, int flags)
{
    int processed = 0, numevents;

    /* Nothing to do? return ASAP */
    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;

    /* Note that we want to call aeApiPoll() even if there are no
     * file events to process as long as we want to process time
     * events, in order to sleep until the next time event is ready
     * to fire. */
    if (eventLoop->maxfd != -1 ||
        ((flags & AE_TIME_EVENTS) && !(flags & AE_DONT_WAIT))) {
        int j;
        struct timeval tv, *tvp = NULL; /* NULL means infinite wait. */
        int64_t usUntilTimer;

        if (eventLoop->beforesleep != NULL && (flags & AE_CALL_BEFORE_SLEEP))
            eventLoop->beforesleep(eventLoop);

        /* The eventLoop->flags may be changed inside beforesleep.
         * So we should check it after beforesleep be called. At the same time,
         * the parameter flags always should have the highest priority.
         * Th...",361.0,469.0,1.0,18.0,109.0,109,15,87,13,2,27,14,31,11,2,,0,26,4,2,2,int
2788,13300,aeWait,1,aeWait,"int aeWait (int,int,long long)",ae.c,"int aeWait(int fd, int mask, long long milliseconds) {
    struct pollfd pfd;
    int retmask = 0, retval;

    memset(&pfd, 0, sizeof(pfd));
    pfd.fd = fd;
    if (mask & AE_READABLE) pfd.events |= POLLIN;
    if (mask & AE_WRITABLE) pfd.events |= POLLOUT;

    if ((retval = poll(&pfd, 1, milliseconds))== 1) {
        if (pfd.revents & POLLIN) retmask |= AE_READABLE;
        if (pfd.revents & POLLOUT) retmask |= AE_WRITABLE;
        if (pfd.revents & POLLERR) retmask |= AE_WRITABLE;
        if (pfd.revents & POLLHUP) retmask |= AE_WRITABLE;
        return retmask;
    } else {
        return retval;
    }
}",473.0,491.0,1.0,15.0,19.0,20,6,27,10,2,0,8,12,0,0,,0,0,6,3,3,int
2789,13413,aeMain,1,aeMain,void aeMain (aeEventLoop*),ae.c,"void aeMain(aeEventLoop *eventLoop) {
    eventLoop->stop = 0;
    while (!eventLoop->stop) {
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    }
}",493.0,500.0,1.0,35.0,8.0,11,5,3,1,1,3,2,2,1,1,,0,2,2,1,1,void
2790,13452,aeGetApiName,1,aeGetApiName,char* aeGetApiName (void),ae.c,"char *aeGetApiName(void) {
    return aeApiName();
}",502.0,504.0,1.0,1.0,3.0,0,0,0,0,1,1,1,1,0,1,,0,0,2,1,1,char*
2791,13459,aeSetBeforeSleepProc,1,aeSetBeforeSleepProc,"void aeSetBeforeSleepProc (aeEventLoop*,aeBeforeSleepProc*)",ae.c,"void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
    eventLoop->beforesleep = beforesleep;
}",506.0,508.0,1.0,1.0,3.0,2,2,2,2,1,1,1,1,0,0,,0,1,4,2,2,void
2792,13470,aeSetAfterSleepProc,1,aeSetAfterSleepProc,"void aeSetAfterSleepProc (aeEventLoop*,aeBeforeSleepProc*)",ae.c,"void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {
    eventLoop->aftersleep = aftersleep;
}",510.0,512.0,1.0,1.0,3.0,2,2,2,2,1,1,1,1,0,0,,0,1,4,2,2,void
2793,13489,aeFileProc,1,aeFileProc,"void aeFileProc (aeEventLoop*,int,void*,int)",ae.h,"typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);",66.0,66.0,14.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
2794,13497,aeTimeProc,1,aeTimeProc,"int aeTimeProc (aeEventLoop*,long long,void*)",ae.h,"typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);",67.0,67.0,13.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
2795,13504,aeEventFinalizerProc,1,aeEventFinalizerProc,"void aeEventFinalizerProc (aeEventLoop*,void*)",ae.h,"typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);",68.0,68.0,14.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2796,13510,aeBeforeSleepProc,1,aeBeforeSleepProc,void aeBeforeSleepProc (aeEventLoop*),ae.h,typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);,69.0,69.0,14.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2797,13672,aeApiCreate,1,aeApiCreate,int aeApiCreate (aeEventLoop*),ae_select.c,"static int aeApiCreate(aeEventLoop *eventLoop) {
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    FD_ZERO(&state->rfds);
    FD_ZERO(&state->wfds);
    eventLoop->apidata = state;
    return 0;
}",42.0,50.0,1.0,1.0,9.0,22,7,15,4,1,14,4,4,2,6,,0,10,2,1,1,int
2798,13746,aeApiResize,1,aeApiResize,"int aeApiResize (aeEventLoop*,int)",ae_select.c,"static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
    AE_NOTUSED(eventLoop);
    /* Just ensure we have enough room in the fd_set type. */
    if (setsize >= FD_SETSIZE) return -1;
    return 0;
}",52.0,57.0,1.0,1.0,6.0,7,4,6,4,1,4,1,1,0,1,,0,4,4,2,2,int
2799,13772,aeApiFree,1,aeApiFree,void aeApiFree (aeEventLoop*),ae_select.c,"static void aeApiFree(aeEventLoop *eventLoop) {
    zfree(eventLoop->apidata);
}",59.0,61.0,1.0,1.0,3.0,4,2,5,2,1,5,1,1,0,2,,0,3,2,1,1,void
2800,13793,aeApiAddEvent,1,aeApiAddEvent,"int aeApiAddEvent (aeEventLoop*,int,int)",ae_select.c,"static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;

    if (mask & AE_READABLE) FD_SET(fd,&state->rfds);
    if (mask & AE_WRITABLE) FD_SET(fd,&state->wfds);
    return 0;
}",63.0,69.0,1.0,1.0,7.0,27,10,27,13,1,4,4,4,1,0,,0,4,6,3,3,int
2801,13885,aeApiDelEvent,1,aeApiDelEvent,"void aeApiDelEvent (aeEventLoop*,int,int)",ae_select.c,"static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;

    if (mask & AE_READABLE) FD_CLR(fd,&state->rfds);
    if (mask & AE_WRITABLE) FD_CLR(fd,&state->wfds);
}",71.0,76.0,1.0,1.0,6.0,22,9,24,12,1,3,4,4,0,0,,0,3,6,3,3,void
2802,13971,aeApiPoll,1,aeApiPoll,"int aeApiPoll (aeEventLoop*,timeval*)",ae_select.c,"static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
    aeApiState *state = eventLoop->apidata;
    int retval, j, numevents = 0;

    memcpy(&state->_rfds,&state->rfds,sizeof(fd_set));
    memcpy(&state->_wfds,&state->wfds,sizeof(fd_set));

    retval = select(eventLoop->maxfd+1,
                &state->_rfds,&state->_wfds,NULL,tvp);
    if (retval > 0) {
        for (j = 0; j <= eventLoop->maxfd; j++) {
            int mask = 0;
            aeFileEvent *fe = &eventLoop->events[j];

            if (fe->mask == AE_NONE) continue;
            if (fe->mask & AE_READABLE && FD_ISSET(j,&state->_rfds))
                mask |= AE_READABLE;
            if (fe->mask & AE_WRITABLE && FD_ISSET(j,&state->_wfds))
                mask |= AE_WRITABLE;
            eventLoop->fired[numevents].fd = j;
            eventLoop->fired[numevents].mask = mask;
            numevents++;
        }
    } else if (retval == -1 && errno != EINTR) {
        panic(""aeApiPoll: select, %s"", strerror(...",78.0,106.0,1.0,1.0,29.0,43,13,45,14,1,7,7,16,0,0,,0,7,4,2,2,int
2803,14133,aeApiName,1,aeApiName,char* aeApiName (void),ae_select.c,"static char *aeApiName(void) {
    return ""select"";
}",108.0,110.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
2804,14291,aeApiLookupPending,1,aeApiLookupPending,"int aeApiLookupPending (aeApiState*,int)",ae_evport.c,"static int aeApiLookupPending(aeApiState *state, int fd) {
    uint_t i;

    for (i = 0; i < state->npending; i++) {
        if (state->pending_fds[i] == fd)
            return (i);
    }

    return (-1);
}",111.0,120.0,1.0,1.0,10.0,7,6,7,3,0,2,3,4,2,0,,0,2,4,2,2,int
2805,14325,aeApiAssociate,1,aeApiAssociate,"int aeApiAssociate (char*,int,int,int)",ae_evport.c,"static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {
    int events = 0;
    int rv, err;

    if (mask & AE_READABLE)
        events |= POLLIN;
    if (mask & AE_WRITABLE)
        events |= POLLOUT;

    if (evport_debug)
        fprintf(stderr, ""%s: port_associate(%d, 0x%x) = "", where, fd, events);

    rv = port_associate(portfd, PORT_SOURCE_FD, fd, events,
        (void *)(uintptr_t)mask);
    err = errno;

    if (evport_debug)
        fprintf(stderr, ""%d (%s)\n"", rv, rv == 0 ? ""no error"" : strerror(err));

    if (rv == -1) {
        fprintf(stderr, ""%s: port_associate: %s\n"", where, strerror(err));

        if (err == EAGAIN)
            fprintf(stderr, ""aeApiAssociate: event port limit exceeded."");
    }

    return rv;
}",125.0,152.0,1.0,1.0,28.0,12,6,35,16,0,2,7,8,2,0,,0,2,8,4,4,int
2806,14882,getEventMask,1,getEventMask,"int getEventMask (char*,int)",ae_kqueue.c,"static inline int getEventMask(const char *eventsMask, int fd) {
    return (eventsMask[fd/4] >> EVENT_MASK_OFFSET(fd)) & 0x3;
}",50.0,52.0,1.0,32.0,3.0,6,6,4,2,0,0,1,1,0,0,,0,0,4,2,2,int
2807,14905,addEventMask,1,addEventMask,"void addEventMask (char*,int,int)",ae_kqueue.c,"static inline void addEventMask(char *eventsMask, int fd, int mask) {
    eventsMask[fd/4] |= EVENT_MASK_ENCODE(fd, mask);
}",54.0,56.0,1.0,24.0,3.0,6,6,6,3,0,0,1,1,0,0,,0,0,6,3,3,void
2808,14931,resetEventMask,1,resetEventMask,"void resetEventMask (char*,int)",ae_kqueue.c,"static inline void resetEventMask(char *eventsMask, int fd) {
    eventsMask[fd/4] &= ~EVENT_MASK_ENCODE(fd, 0x3);
}",58.0,60.0,1.0,25.0,3.0,7,7,4,2,0,0,1,1,0,0,,0,0,4,2,2,void
2809,15878,anetSetError,1,anetSetError,"void anetSetError (char*,char*...)",anet.c,"static void anetSetError(char *err, const char *fmt, ...)
{
    va_list ap;

    if (!err) return;
    va_start(ap, fmt);
    vsnprintf(err, ANET_ERR_LEN, fmt, ap);
    va_end(ap);
}",55.0,63.0,1.0,19.0,9.0,1,1,7,3,23,0,2,2,0,0,,0,0,4,2,2,void
2810,15902,anetGetError,1,anetGetError,int anetGetError (int),anet.c,"int anetGetError(int fd) {
    int sockerr = 0;
    socklen_t errlen = sizeof(sockerr);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
        sockerr = errno;
    return sockerr;
}",65.0,72.0,1.0,1.0,8.0,8,5,11,6,1,0,2,2,0,0,,0,0,2,1,1,int
2811,15934,anetSetBlock,1,anetSetBlock,"int anetSetBlock (char*,int,int)",anet.c,"int anetSetBlock(char *err, int fd, int non_block) {
    int flags;

    /* Set the socket blocking (if non_block is zero) or non-blocking.
     * Note that fcntl(2) for F_GETFL and F_SETFL can't be
     * interrupted by a signal. */
    if ((flags = fcntl(fd, F_GETFL)) == -1) {
        anetSetError(err, ""fcntl(F_GETFL): %s"", strerror(errno));
        return ANET_ERR;
    }

    /* Check if this flag has been set or unset, if so, 
     * then there is no need to call fcntl to set/unset it again. */
    if (!!(flags & O_NONBLOCK) == !!non_block)
        return ANET_OK;

    if (non_block)
        flags |= O_NONBLOCK;
    else
        flags &= ~O_NONBLOCK;

    if (fcntl(fd, F_SETFL, flags) == -1) {
        anetSetError(err, ""fcntl(F_SETFL,O_NONBLOCK): %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",74.0,100.0,1.0,15.0,27.0,13,5,16,8,2,2,5,5,0,2,,0,0,6,3,3,int
2812,16012,anetNonBlock,1,anetNonBlock,"int anetNonBlock (char*,int)",anet.c,"int anetNonBlock(char *err, int fd) {
    return anetSetBlock(err,fd,1);
}",102.0,104.0,1.0,1.0,3.0,0,0,2,2,6,1,1,1,0,1,,0,0,4,2,2,int
2813,16023,anetBlock,1,anetBlock,"int anetBlock (char*,int)",anet.c,"int anetBlock(char *err, int fd) {
    return anetSetBlock(err,fd,0);
}",106.0,108.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2814,16034,anetCloexec,1,anetCloexec,int anetCloexec (int),anet.c,"int anetCloexec(int fd) {
    int r;
    int flags;

    do {
        r = fcntl(fd, F_GETFD);
    } while (r == -1 && errno == EINTR);

    if (r == -1 || (r & FD_CLOEXEC))
        return r;

    flags = r | FD_CLOEXEC;

    do {
        r = fcntl(fd, F_SETFD, flags);
    } while (r == -1 && errno == EINTR);

    return r;
}",113.0,131.0,1.0,1.0,19.0,16,7,21,8,6,0,4,4,0,0,,0,0,2,1,1,int
2815,16091,anetKeepAlive,1,anetKeepAlive,"int anetKeepAlive (char*,int,int)",anet.c,"int anetKeepAlive(char *err, int fd, int interval)
{
    int val = 1;

    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1)
    {
        anetSetError(err, ""setsockopt SO_KEEPALIVE: %s"", strerror(errno));
        return ANET_ERR;
    }

#ifdef __linux__
    /* Default settings are more or less garbage, with the keepalive time
     * set to 7200 by default on Linux. Modify settings to make the feature
     * actually useful. */

    /* Send first probe after interval. */
    val = interval;
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
        anetSetError(err, ""setsockopt TCP_KEEPIDLE: %s\n"", strerror(errno));
        return ANET_ERR;
    }

    /* Send next probes after the specified interval. Note that we set the
     * delay as interval / 3, as we send three probes before detecting
     * an error (see the next setsockopt call). */
    val = interval/3;
    if (val == 0) val = 1;
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL...",136.0,187.0,1.0,15.0,52.0,7,6,9,7,1,1,2,2,0,1,,0,0,6,3,3,int
2816,16132,anetSetTcpNoDelay,1,anetSetTcpNoDelay,"int anetSetTcpNoDelay (char*,int,int)",anet.c,"static int anetSetTcpNoDelay(char *err, int fd, int val)
{
    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)) == -1)
    {
        anetSetError(err, ""setsockopt TCP_NODELAY: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",189.0,197.0,1.0,15.0,9.0,5,4,7,6,2,1,2,2,0,1,,0,0,6,3,3,int
2817,16166,anetEnableTcpNoDelay,1,anetEnableTcpNoDelay,"int anetEnableTcpNoDelay (char*,int)",anet.c,"int anetEnableTcpNoDelay(char *err, int fd)
{
    return anetSetTcpNoDelay(err, fd, 1);
}",199.0,202.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2818,16177,anetDisableTcpNoDelay,1,anetDisableTcpNoDelay,"int anetDisableTcpNoDelay (char*,int)",anet.c,"int anetDisableTcpNoDelay(char *err, int fd)
{
    return anetSetTcpNoDelay(err, fd, 0);
}",204.0,207.0,1.0,1.0,4.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
2819,16188,anetSendTimeout,1,anetSendTimeout,"int anetSendTimeout (char*,int,long long)",anet.c,"int anetSendTimeout(char *err, int fd, long long ms) {
    struct timeval tv;

    tv.tv_sec = ms/1000;
    tv.tv_usec = (ms%1000)*1000;
    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
        anetSetError(err, ""setsockopt SO_SNDTIMEO: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",211.0,221.0,1.0,15.0,11.0,12,9,11,7,0,1,2,2,0,1,,0,0,6,3,3,int
2820,16239,anetRecvTimeout,1,anetRecvTimeout,"int anetRecvTimeout (char*,int,long long)",anet.c,"int anetRecvTimeout(char *err, int fd, long long ms) {
    struct timeval tv;

    tv.tv_sec = ms/1000;
    tv.tv_usec = (ms%1000)*1000;
    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
        anetSetError(err, ""setsockopt SO_RCVTIMEO: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",225.0,235.0,1.0,15.0,11.0,12,9,11,7,0,1,2,2,0,1,,0,0,6,3,3,int
2821,16290,anetResolve,1,anetResolve,"int anetResolve (char*,char*,char*,size_t,int)",anet.c,"int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
                       int flags)
{
    struct addrinfo hints, *info;
    int rv;

    memset(&hints,0,sizeof(hints));
    if (flags & ANET_IP_ONLY) hints.ai_flags = AI_NUMERICHOST;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;  /* specify socktype to avoid dups */

    if ((rv = getaddrinfo(host, NULL, &hints, &info)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    if (info->ai_family == AF_INET) {
        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;
        inet_ntop(AF_INET, &(sa->sin_addr), ipbuf, ipbuf_len);
    } else {
        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;
        inet_ntop(AF_INET6, &(sa->sin6_addr), ipbuf, ipbuf_len);
    }

    freeaddrinfo(info);
    return ANET_OK;
}",243.0,268.0,1.0,16.0,26.0,22,11,25,14,2,1,4,4,0,1,,0,0,10,5,5,int
2822,16402,anetSetReuseAddr,1,anetSetReuseAddr,"int anetSetReuseAddr (char*,int)",anet.c,"static int anetSetReuseAddr(char *err, int fd) {
    int yes = 1;
    /* Make sure connection-intensive things like the redis benchmark
     * will be able to close/open sockets a zillion of times */
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {
        anetSetError(err, ""setsockopt SO_REUSEADDR: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",270.0,279.0,1.0,15.0,10.0,6,5,8,6,3,1,2,2,0,1,,0,0,4,2,2,int
2823,16439,anetCreateSocket,1,anetCreateSocket,"int anetCreateSocket (char*,int)",anet.c,"static int anetCreateSocket(char *err, int domain) {
    int s;
    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {
        anetSetError(err, ""creating socket: %s"", strerror(errno));
        return ANET_ERR;
    }

    /* Make sure connection-intensive things like the redis benchmark
     * will be able to close/open sockets a zillion of times */
    if (anetSetReuseAddr(err,s) == ANET_ERR) {
        close(s);
        return ANET_ERR;
    }
    return s;
}",281.0,295.0,1.0,15.0,15.0,7,3,9,5,2,2,3,3,1,2,,0,1,4,2,2,int
2824,16486,anetTcpGenericConnect,1,anetTcpGenericConnect,"int anetTcpGenericConnect (char*,char*,int,char*,int)",anet.c,"static int anetTcpGenericConnect(char *err, const char *addr, int port,
                                 const char *source_addr, int flags)
{
    int s = ANET_ERR, rv;
    char portstr[6];  /* strlen(""65535"") + 1; */
    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;

    snprintf(portstr,sizeof(portstr),""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(addr,portstr,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        /* Try to create the socket and to connect it.
         * If we fail in the socket() call, or on connect(), we retry with
         * the next entry in servinfo. */
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        if (flags & ANET_CONNECT_...",300.0,378.0,1.0,12.0,79.0,59,11,75,19,2,6,25,32,2,6,,0,2,10,5,5,int
2825,16774,anetTcpNonBlockConnect,1,anetTcpNonBlockConnect,"int anetTcpNonBlockConnect (char*,char*,int)",anet.c,"int anetTcpNonBlockConnect(char *err, const char *addr, int port)
{
    return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);
}",380.0,383.0,1.0,52.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,int
2826,16790,anetTcpNonBlockBestEffortBindConnect,1,anetTcpNonBlockBestEffortBindConnect,"int anetTcpNonBlockBestEffortBindConnect (char*,char*,int,char*)",anet.c,"int anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port,
                                         const char *source_addr)
{
    return anetTcpGenericConnect(err,addr,port,source_addr,
            ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);
}",385.0,390.0,1.0,12.0,6.0,1,1,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
2827,16811,anetUnixGenericConnect,1,anetUnixGenericConnect,"int anetUnixGenericConnect (char*,char*,int)",anet.c,"int anetUnixGenericConnect(char *err, const char *path, int flags)
{
    int s;
    struct sockaddr_un sa;

    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
        return ANET_ERR;

    sa.sun_family = AF_LOCAL;
    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));
    if (flags & ANET_CONNECT_NONBLOCK) {
        if (anetNonBlock(err,s) != ANET_OK) {
            close(s);
            return ANET_ERR;
        }
    }
    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
        if (errno == EINPROGRESS &&
            flags & ANET_CONNECT_NONBLOCK)
            return s;

        anetSetError(err, ""connect: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return s;
}",392.0,418.0,1.0,48.0,27.0,21,10,23,8,0,4,6,8,2,4,,0,2,6,3,3,int
2828,16914,anetListen,1,anetListen,"int anetListen (char*,int,sockaddr*,socklen_t,int)",anet.c,"static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {
    if (bind(s,sa,len) == -1) {
        anetSetError(err, ""bind: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }

    if (listen(s, backlog) == -1) {
        anetSetError(err, ""listen: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return ANET_OK;
}",420.0,433.0,1.0,15.0,14.0,6,2,11,6,2,2,3,3,0,2,,0,0,10,5,5,int
2829,16968,anetV6Only,1,anetV6Only,"int anetV6Only (char*,int)",anet.c,"static int anetV6Only(char *err, int s) {
    int yes = 1;
    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {
        anetSetError(err, ""setsockopt: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",435.0,442.0,1.0,15.0,8.0,6,5,8,6,1,1,2,2,0,1,,0,0,4,2,2,int
2830,17005,_anetTcpServer,1,_anetTcpServer,"int _anetTcpServer (char*,int,char*,int,int)",anet.c,"static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)
{
    int s = -1, rv;
    char _port[6];  /* strlen(""65535"") */
    struct addrinfo hints, *servinfo, *p;

    snprintf(_port,6,""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = af;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */
    if (bindaddr && !strcmp(""*"", bindaddr))
        bindaddr = NULL;
    if (af == AF_INET6 && bindaddr && !strcmp(""::*"", bindaddr))
        bindaddr = NULL;

    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;

        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        ...",444.0,484.0,1.0,15.0,41.0,48,10,57,16,2,5,16,15,3,5,,0,3,10,5,5,int
2831,17211,anetTcpServer,1,anetTcpServer,"int anetTcpServer (char*,int,char*,int)",anet.c,"int anetTcpServer(char *err, int port, char *bindaddr, int backlog)
{
    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
}",486.0,489.0,1.0,1.0,4.0,0,0,5,5,0,1,1,1,0,1,,0,0,8,4,4,int
2832,17226,anetTcp6Server,1,anetTcp6Server,"int anetTcp6Server (char*,int,char*,int)",anet.c,"int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)
{
    return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);
}",491.0,494.0,1.0,1.0,4.0,0,0,5,5,1,1,1,1,0,1,,0,0,8,4,4,int
2833,17241,anetUnixServer,1,anetUnixServer,"int anetUnixServer (char*,char*,mode_t,int)",anet.c,"int anetUnixServer(char *err, char *path, mode_t perm, int backlog)
{
    int s;
    struct sockaddr_un sa;

    if (strlen(path) > sizeof(sa.sun_path)-1) {
        anetSetError(err,""unix socket path too long (%zu), must be under %zu"", strlen(path), sizeof(sa.sun_path));
        return ANET_ERR;
    }
    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
        return ANET_ERR;

    memset(&sa,0,sizeof(sa));
    sa.sun_family = AF_LOCAL;
    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));
    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)
        return ANET_ERR;
    if (perm)
        chmod(sa.sun_path, perm);
    return s;
}",496.0,516.0,1.0,15.0,21.0,25,9,24,7,1,4,5,5,2,4,,0,2,8,4,4,int
2834,17345,anetGenericAccept,1,anetGenericAccept,"int anetGenericAccept (char*,int,sockaddr*,socklen_t*)",anet.c,"static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {
    int fd;
    do {
        /* Use the accept4() call on linux to simultaneously accept and
         * set a socket as non-blocking. */
#ifdef HAVE_ACCEPT4
        fd = accept4(s, sa, len,  SOCK_NONBLOCK | SOCK_CLOEXEC);
#else
        fd = accept(s,sa,len);
#endif
    } while(fd == -1 && errno == EINTR);
    if (fd == -1) {
        anetSetError(err, ""accept: %s"", strerror(errno));
        return ANET_ERR;
    }
#ifndef HAVE_ACCEPT4
    if (anetCloexec(fd) == -1) {
        anetSetError(err, ""anetCloexec: %s"", strerror(errno));
        close(fd);
        return ANET_ERR;
    }
    if (anetNonBlock(err, fd) != ANET_OK) {
        close(fd);
        return ANET_ERR;
    }
#endif
    return fd;
}",520.0,547.0,1.0,15.0,28.0,13,5,18,7,2,4,5,5,2,4,,0,2,8,4,4,int
2835,17423,anetTcpAccept,1,anetTcpAccept,"int anetTcpAccept (char*,int,char*,size_t,int*)",anet.c,"int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port) {
    int fd;
    struct sockaddr_storage sa;
    socklen_t salen = sizeof(sa);
    if ((fd = anetGenericAccept(err,serversock,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
        return ANET_ERR;

    if (sa.ss_family == AF_INET) {
        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);
        if (port) *port = ntohs(s->sin_port);
    } else {
        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
        if (port) *port = ntohs(s->sin6_port);
    }
    return fd;
}",551.0,568.0,1.0,81.0,18.0,20,9,20,10,1,1,5,7,1,1,,0,1,10,5,5,int
2836,17533,anetUnixAccept,1,anetUnixAccept,"int anetUnixAccept (char*,int)",anet.c,"int anetUnixAccept(char *err, int s) {
    int fd;
    struct sockaddr_un sa;
    socklen_t salen = sizeof(sa);
    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
        return ANET_ERR;

    return fd;
}",572.0,580.0,1.0,72.0,9.0,9,6,8,5,1,1,2,2,1,1,,0,1,4,2,2,int
2837,17571,anetFdToString,1,anetFdToString,"int anetFdToString (int,char*,size_t,int*,int)",anet.c,"int anetFdToString(int fd, char *ip, size_t ip_len, int *port, int remote) {
    struct sockaddr_storage sa;
    socklen_t salen = sizeof(sa);

    if (remote) {
        if (getpeername(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;
    } else {
        if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;
    }

    if (sa.ss_family == AF_INET) {
        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
        if (ip) {
            if (inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len) == NULL)
                goto error;
        }
        if (port) *port = ntohs(s->sin_port);
    } else if (sa.ss_family == AF_INET6) {
        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
        if (ip) {
            if (inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len) == NULL)
                goto error;
        }
        if (port) *port = ntohs(s->sin6_port);
    } else if (sa.ss_family == AF_UNIX) {
        if (ip) {
            int res = snprintf(ip, ip_le...",582.0,628.0,1.0,1.0,47.0,27,11,25,10,1,0,12,16,0,0,,0,0,10,5,5,int
2838,17789,anetPipe,1,anetPipe,"int anetPipe (int[2],int,int)",anet.c,"int anetPipe(int fds[2], int read_flags, int write_flags) {
    int pipe_flags = 0;
#if defined(__linux__) || defined(__FreeBSD__)
    /* When possible, try to leverage pipe2() to apply flags that are common to both ends.
     * There is no harm to set O_CLOEXEC to prevent fd leaks. */
    pipe_flags = O_CLOEXEC | (read_flags & write_flags);
    if (pipe2(fds, pipe_flags)) {
        /* Fail on real failures, and fallback to simple pipe if pipe2 is unsupported. */
        if (errno != ENOSYS && errno != EINVAL)
            return -1;
        pipe_flags = 0;
    } else {
        /* If the flags on both ends are identical, no need to do anything else. */
        if ((O_CLOEXEC | read_flags) == (O_CLOEXEC | write_flags))
            return 0;
        /* Clear the flags which have already been set using pipe2. */
        read_flags &= ~pipe_flags;
        write_flags &= ~pipe_flags;
    }
#endif

    /* When we reach here with pipe_flags of 0, it means pipe2 failed (or was not attempted)...",633.0,684.0,1.0,1.0,52.0,15,7,27,8,4,0,14,14,0,0,,0,0,6,3,3,int
2839,17885,anetSetSockMarkId,1,anetSetSockMarkId,"int anetSetSockMarkId (char*,int,uint32_t)",anet.c,"int anetSetSockMarkId(char *err, int fd, uint32_t id) {
#ifdef HAVE_SOCKOPTMARKID
    if (setsockopt(fd, SOL_SOCKET, SOCKOPTMARKID, (void *)&id, sizeof(id)) == -1) {
        anetSetError(err, ""setsockopt: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
#else
    UNUSED(fd);
    UNUSED(id);
    anetSetError(err,""anetSetSockMarkid unsupported on this platform"");
    return ANET_OK;
#endif
}",686.0,699.0,1.0,4.0,14.0,2,1,5,3,1,1,1,1,0,1,,0,0,6,3,3,int
2840,17911,anetIsFifo,1,anetIsFifo,int anetIsFifo (char*),anet.c,"int anetIsFifo(char *filepath) {
    struct stat sb;
    if (stat(filepath, &sb) == -1) return 0;
    return S_ISFIFO(sb.st_mode);
}",701.0,705.0,1.0,1.0,5.0,4,4,3,2,0,0,2,2,0,0,,0,0,2,1,1,int
2841,18062,anetFormatAddr,1,anetFormatAddr,"int anetFormatAddr (char*,size_t,char*,int)",anet.h,"int anetFormatAddr(char *fmt, size_t fmt_len, char *ip, int port);",69.0,69.0,5.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
2842,18123,freeClientArgv,1,freeClientArgv,void freeClientArgv (client*),networking.c,"void freeClientArgv(client *c) {
    int j;
    for (j = 0; j < c->argc; j++)
        decrRefCount(c->argv[j]);
    c->argc = 0;
    c->cmd = NULL;
    c->argv_len_sum = 0;
    c->argv_len = 0;
    zfree(c->argv);
    c->argv = NULL;
}",1386.0,1396.0,1.0,1.0,11.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,void
2843,18128,getAppendOnlyFileSize,1,getAppendOnlyFileSize,"off_t getAppendOnlyFileSize (sds,int*)",aof.c,"off_t getAppendOnlyFileSize(sds filename, int *status) {
    struct redis_stat sb;
    off_t size;
    mstime_t latency;

    sds aof_filepath = makePath(server.aof_dirname, filename);
    latencyStartMonitor(latency);
    if (redis_stat(aof_filepath, &sb) == -1) {
        if (status) *status = errno == ENOENT ? AOF_NOT_EXIST : AOF_OPEN_ERR;
        serverLog(LL_WARNING, ""Unable to obtain the AOF file %s length. stat: %s"",
            filename, strerror(errno));
        size = 0;
    } else {
        if (status) *status = AOF_OK;
        size = sb.st_size;
    }
    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded(""aof-fstat"", latency);
    sdsfree(aof_filepath);
    return size;
}",2521.0,2541.0,1.0,11.0,21.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,off_t
2844,18134,getBaseAndIncrAppendOnlyFilesSize,1,getBaseAndIncrAppendOnlyFilesSize,"off_t getBaseAndIncrAppendOnlyFilesSize (aofManifest*,int*)",aof.c,"off_t getBaseAndIncrAppendOnlyFilesSize(aofManifest *am, int *status) {
    off_t size = 0;
    listNode *ln;
    listIter li;

    if (am->base_aof_info) {
        serverAssert(am->base_aof_info->file_type == AOF_FILE_TYPE_BASE);

        size += getAppendOnlyFileSize(am->base_aof_info->file_name, status);
        if (*status != AOF_OK) return 0;
    }

    listRewind(am->incr_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_INCR);
        size += getAppendOnlyFileSize(ai->file_name, status);
        if (*status != AOF_OK) return 0;
    }

    return size;
}",2546.0,2567.0,1.0,8.0,22.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,off_t
2845,18140,getBaseAndIncrAppendOnlyFilesNum,1,getBaseAndIncrAppendOnlyFilesNum,int getBaseAndIncrAppendOnlyFilesNum (aofManifest*),aof.c,"int getBaseAndIncrAppendOnlyFilesNum(aofManifest *am) {
    int num = 0;
    if (am->base_aof_info) num++;
    if (am->incr_aof_list) num += listLength(am->incr_aof_list);
    return num;
}",2569.0,2574.0,1.0,34.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
2846,18145,aofFileExist,1,aofFileExist,int aofFileExist (char*),aof.c,"int aofFileExist(char *filename) {
    sds file_path = makePath(server.aof_dirname, filename);
    int ret = fileExist(file_path);
    sdsfree(file_path);
    return ret;
}",770.0,775.0,1.0,1.0,6.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
2847,18150,rewriteAppendOnlyFile,1,rewriteAppendOnlyFile,int rewriteAppendOnlyFile (char*),aof.c,"int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp = NULL;
    char tmpfile[256];

    /* Note that we have to use a different temp name here compared to the
     * one used by rewriteAppendOnlyFileBackground() function. */
    snprintf(tmpfile,256,""temp-rewriteaof-%d.aof"", (int) getpid());
    fp = fopen(tmpfile,""w"");
    if (!fp) {
        serverLog(LL_WARNING, ""Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"", strerror(errno));
        return C_ERR;
    }

    rioInitWithFile(&aof,fp);

    if (server.aof_rewrite_incremental_fsync) {
        rioSetAutoSync(&aof,REDIS_AUTOSYNC_BYTES);
        rioSetReclaimCache(&aof,1);
    }

    startSaving(RDBFLAGS_AOF_PREAMBLE);

    if (server.aof_use_rdb_preamble) {
        int error;
        if (rdbSaveRio(SLAVE_REQ_NONE,&aof,&error,RDBFLAGS_AOF_PREAMBLE,NULL) == C_ERR) {
            errno = error;
            goto werr;
        }
    } else {
        if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto ...",2357.0,2418.0,1.0,8.0,62.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
2848,18155,aofLoadManifestFromFile,1,aofLoadManifestFromFile,aofManifest* aofLoadManifestFromFile (sds),aof.c,"aofManifest *aofLoadManifestFromFile(sds am_filepath) {
    const char *err = NULL;
    long long maxseq = 0;

    aofManifest *am = aofManifestCreate();
    FILE *fp = fopen(am_filepath, ""r"");
    if (fp == NULL) {
        serverLog(LL_WARNING, ""Fatal error: can't open the AOF manifest ""
            ""file %s for reading: %s"", am_filepath, strerror(errno));
        exit(1);
    }

    char buf[MANIFEST_MAX_LINE+1];
    sds *argv = NULL;
    int argc;
    aofInfo *ai = NULL;

    sds line = NULL;
    int linenum = 0;

    while (1) {
        if (fgets(buf, MANIFEST_MAX_LINE+1, fp) == NULL) {
            if (feof(fp)) {
                if (linenum == 0) {
                    err = ""Found an empty AOF manifest"";
                    goto loaderr;
                } else {
                    break;
                }
            } else {
                err = ""Read AOF manifest failed"";
                goto loaderr;
            }
        }

        linenum++;

        /* Skip comments lin...",256.0,382.0,1.0,8.0,127.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,aofManifest
2849,18160,aofManifestFreeAndUpdate,1,aofManifestFreeAndUpdate,void aofManifestFreeAndUpdate (aofManifest*),aof.c,"void aofManifestFreeAndUpdate(aofManifest *am) {
    serverAssert(am != NULL);
    if (server.aof_manifest) aofManifestFree(server.aof_manifest);
    server.aof_manifest = am;
}",412.0,416.0,1.0,4.0,5.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
2850,18165,aof_background_fsync_and_close,1,aof_background_fsync_and_close,void aof_background_fsync_and_close (int),aof.c,"void aof_background_fsync_and_close(int fd) {
    bioCreateCloseAofJob(fd, server.master_repl_offset, 1);
}",929.0,931.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2851,18170,aofInfoCreate,1,aofInfoCreate,aofInfo aofInfoCreate (void),aof.c,"aofInfo *aofInfoCreate(void) {
    return zcalloc(sizeof(aofInfo));
}",99.0,101.0,1.0,1.0,3.0,1,1,1,1,4,1,1,1,0,1,,0,0,2,1,1,aofInfo
2852,18179,aofInfoFree,1,aofInfoFree,void aofInfoFree (aofInfo*),aof.c,"void aofInfoFree(aofInfo *ai) {
    serverAssert(ai != NULL);
    if (ai->file_name) sdsfree(ai->file_name);
    zfree(ai);
}",104.0,108.0,1.0,4.0,5.0,7,6,5,2,3,5,2,2,1,3,,0,2,2,1,1,void
2853,18211,aofInfoDup,1,aofInfoDup,aofInfo aofInfoDup (aofInfo*),aof.c,"aofInfo *aofInfoDup(aofInfo *orig) {
    serverAssert(orig != NULL);
    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdsdup(orig->file_name);
    ai->file_seq = orig->file_seq;
    ai->file_type = orig->file_type;
    return ai;
}",111.0,118.0,1.0,4.0,8.0,15,7,10,3,3,9,1,1,0,3,,0,8,2,1,1,aofInfo
2854,18260,aofInfoFormat,1,aofInfoFormat,"sds aofInfoFormat (sds,aofInfo*)",aof.c,"sds aofInfoFormat(sds buf, aofInfo *ai) {
    sds filename_repr = NULL;

    if (sdsneedsrepr(ai->file_name))
        filename_repr = sdscatrepr(sdsempty(), ai->file_name, sdslen(ai->file_name));

    sds ret = sdscatprintf(buf, ""%s %s %s %lld %s %c\n"",
        AOF_MANIFEST_KEY_FILE_NAME, filename_repr ? filename_repr : ai->file_name,
        AOF_MANIFEST_KEY_FILE_SEQ, ai->file_seq,
        AOF_MANIFEST_KEY_FILE_TYPE, ai->file_type);
    sdsfree(filename_repr);

    return ret;
}",121.0,134.0,1.0,8.0,14.0,10,3,15,5,3,12,2,2,2,6,,0,11,4,2,2,sds
2855,18318,aofListFree,1,aofListFree,void aofListFree (void*),aof.c,"void aofListFree(void *item) {
    aofInfo *ai = (aofInfo *)item;
    aofInfoFree(ai);
}",137.0,140.0,1.0,1.0,4.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,void
2856,18331,aofListDup,1,aofListDup,void* aofListDup (void*),aof.c,"void *aofListDup(void *item) {
    return aofInfoDup(item);
}",143.0,145.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void*
2857,18339,aofManifestCreate,1,aofManifestCreate,aofManifest aofManifestCreate (void),aof.c,"aofManifest *aofManifestCreate(void) {
    aofManifest *am = zcalloc(sizeof(aofManifest));
    am->incr_aof_list = listCreate();
    am->history_aof_list = listCreate();
    listSetFreeMethod(am->incr_aof_list, aofListFree);
    listSetDupMethod(am->incr_aof_list, aofListDup);
    listSetFreeMethod(am->history_aof_list, aofListFree);
    listSetDupMethod(am->history_aof_list, aofListDup);
    return am;
}",148.0,157.0,1.0,4.0,10.0,22,3,13,2,1,13,1,1,0,3,,0,13,2,1,1,aofManifest
2858,18414,aofManifestFree,1,aofManifestFree,void aofManifestFree (aofManifest*),aof.c,"void aofManifestFree(aofManifest *am) {
    if (am->base_aof_info) aofInfoFree(am->base_aof_info);
    if (am->incr_aof_list) listRelease(am->incr_aof_list);
    if (am->history_aof_list) listRelease(am->history_aof_list);
    zfree(am);
}",160.0,165.0,1.0,1.0,6.0,6,1,7,1,5,10,4,4,3,4,,0,6,2,1,1,void
2859,18448,getAofManifestFileName,1,getAofManifestFileName,sds getAofManifestFileName (void),aof.c,"sds getAofManifestFileName(void) {
    return sdscatprintf(sdsempty(), ""%s%s"", server.aof_filename,
                MANIFEST_NAME_SUFFIX);
}",167.0,170.0,1.0,16.0,4.0,1,1,1,1,2,2,1,1,0,2,,0,1,2,1,1,sds
2860,18463,getTempAofManifestFileName,1,getTempAofManifestFileName,sds getTempAofManifestFileName (void),aof.c,"sds getTempAofManifestFileName(void) {
    return sdscatprintf(sdsempty(), ""%s%s%s"", TEMP_FILE_NAME_PREFIX,
                server.aof_filename, MANIFEST_NAME_SUFFIX);
}",172.0,175.0,1.0,46.0,4.0,1,1,1,1,1,2,1,1,0,2,,0,1,2,1,1,sds
2861,18481,getAofManifestAsString,1,getAofManifestAsString,sds getAofManifestAsString (aofManifest*),aof.c,"sds getAofManifestAsString(aofManifest *am) {
    serverAssert(am != NULL);

    sds buf = sdsempty();
    listNode *ln;
    listIter li;

    /* 1. Add BASE File information, it is always at the beginning
     * of the manifest file. */
    if (am->base_aof_info) {
        buf = aofInfoFormat(buf, am->base_aof_info);
    }

    /* 2. Add HISTORY type AOF information. */
    listRewind(am->history_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        buf = aofInfoFormat(buf, ai);
    }

    /* 3. Add INCR type AOF information. */
    listRewind(am->incr_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        buf = aofInfoFormat(buf, ai);
    }

    return buf;
}",192.0,220.0,1.0,4.0,29.0,27,8,28,6,1,15,4,4,3,9,,0,12,2,1,1,sds
2862,18578,aofLoadManifestFromDisk,1,aofLoadManifestFromDisk,void aofLoadManifestFromDisk (void),aof.c,"void aofLoadManifestFromDisk(void) {
    server.aof_manifest = aofManifestCreate();
    if (!dirExists(server.aof_dirname)) {
        serverLog(LL_DEBUG, ""The AOF directory %s doesn't exist"", server.aof_dirname);
        return;
    }

    sds am_name = getAofManifestFileName();
    sds am_filepath = makePath(server.aof_dirname, am_name);
    if (!fileExist(am_filepath)) {
        serverLog(LL_DEBUG, ""The AOF manifest file %s doesn't exist"", am_name);
        sdsfree(am_name);
        sdsfree(am_filepath);
        return;
    }

    aofManifest *am = aofLoadManifestFromFile(am_filepath);
    if (am) aofManifestFreeAndUpdate(am);
    sdsfree(am_name);
    sdsfree(am_filepath);
}",232.0,252.0,1.0,8.0,21.0,16,5,19,4,0,13,4,4,2,13,,0,6,2,1,1,void
2863,19144,aofManifestDup,1,aofManifestDup,aofManifest aofManifestDup (aofManifest*),aof.c,"aofManifest *aofManifestDup(aofManifest *orig) {
    serverAssert(orig != NULL);
    aofManifest *am = zcalloc(sizeof(aofManifest));

    am->curr_base_file_seq = orig->curr_base_file_seq;
    am->curr_incr_file_seq = orig->curr_incr_file_seq;
    am->dirty = orig->dirty;

    if (orig->base_aof_info) {
        am->base_aof_info = aofInfoDup(orig->base_aof_info);
    }

    am->incr_aof_list = listDup(orig->incr_aof_list);
    am->history_aof_list = listDup(orig->history_aof_list);
    serverAssert(am->incr_aof_list != NULL);
    serverAssert(am->history_aof_list != NULL);
    return am;
}",391.0,408.0,1.0,4.0,18.0,38,8,22,4,1,22,2,2,1,7,,0,19,2,1,1,aofManifest
2864,19294,getNewBaseFileNameAndMarkPreAsHistory,1,getNewBaseFileNameAndMarkPreAsHistory,sds getNewBaseFileNameAndMarkPreAsHistory (aofManifest*),aof.c,"sds getNewBaseFileNameAndMarkPreAsHistory(aofManifest *am) {
    serverAssert(am != NULL);
    if (am->base_aof_info) {
        serverAssert(am->base_aof_info->file_type == AOF_FILE_TYPE_BASE);
        am->base_aof_info->file_type = AOF_FILE_TYPE_HIST;
        listAddNodeHead(am->history_aof_list, am->base_aof_info);
    }

    char *format_suffix = server.aof_use_rdb_preamble ?
        RDB_FORMAT_SUFFIX:AOF_FORMAT_SUFFIX;

    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdscatprintf(sdsempty(), ""%s.%lld%s%s"", server.aof_filename,
                        ++am->curr_base_file_seq, BASE_FILE_SUFFIX, format_suffix);
    ai->file_seq = am->curr_base_file_seq;
    ai->file_type = AOF_FILE_TYPE_BASE;
    am->base_aof_info = ai;
    am->dirty = 1;
    return am->base_aof_info->file_name;
}",427.0,446.0,1.0,4.0,20.0,38,10,24,7,2,19,2,2,1,6,,0,16,2,1,1,sds
2865,19417,getNewIncrAofName,1,getNewIncrAofName,sds getNewIncrAofName (aofManifest*),aof.c,"sds getNewIncrAofName(aofManifest *am) {
    aofInfo *ai = aofInfoCreate();
    ai->file_type = AOF_FILE_TYPE_INCR;
    ai->file_name = sdscatprintf(sdsempty(), ""%s.%lld%s%s"", server.aof_filename,
                        ++am->curr_incr_file_seq, INCR_FILE_SUFFIX, AOF_FORMAT_SUFFIX);
    ai->file_seq = am->curr_incr_file_seq;
    listAddNodeTail(am->incr_aof_list, ai);
    am->dirty = 1;
    return ai->file_name;
}",455.0,464.0,1.0,50.0,10.0,15,4,12,4,2,12,1,1,0,4,,0,11,2,1,1,sds
2866,19472,getTempIncrAofName,1,getTempIncrAofName,sds getTempIncrAofName (void),aof.c,"sds getTempIncrAofName(void) {
    return sdscatprintf(sdsempty(), ""%s%s%s"", TEMP_FILE_NAME_PREFIX, server.aof_filename,
        INCR_FILE_SUFFIX);
}",467.0,470.0,1.0,46.0,4.0,1,1,1,1,3,2,1,1,0,2,,0,1,2,1,1,sds
2867,19490,getLastIncrAofName,1,getLastIncrAofName,sds getLastIncrAofName (aofManifest*),aof.c,"sds getLastIncrAofName(aofManifest *am) {
    serverAssert(am != NULL);

    /* If 'incr_aof_list' is empty, just create a new one. */
    if (!listLength(am->incr_aof_list)) {
        return getNewIncrAofName(am);
    }

    /* Or return the last one. */
    listNode *lastnode = listIndex(am->incr_aof_list, -1);
    aofInfo *ai = listNodeValue(lastnode);
    return ai->file_name;
}",473.0,485.0,1.0,4.0,13.0,15,9,11,4,1,8,2,2,2,3,,0,6,2,1,1,sds
2868,19549,markRewrittenIncrAofAsHistory,1,markRewrittenIncrAofAsHistory,void markRewrittenIncrAofAsHistory (aofManifest*),aof.c,"void markRewrittenIncrAofAsHistory(aofManifest *am) {
    serverAssert(am != NULL);
    if (!listLength(am->incr_aof_list)) {
        return;
    }

    listNode *ln;
    listIter li;

    listRewindTail(am->incr_aof_list, &li);

    /* ""server.aof_fd != -1"" means AOF enabled, then we must skip the
     * last AOF, because this file is our currently writing. */
    if (server.aof_fd != -1) {
        ln = listNext(&li);
        serverAssert(ln != NULL);
    }

    /* Move aofInfo from 'incr_aof_list' to 'history_aof_list'. */
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_INCR);

        aofInfo *hai = aofInfoDup(ai);
        hai->file_type = AOF_FILE_TYPE_HIST;
        listAddNodeHead(am->history_aof_list, hai);
        listDelNode(am->incr_aof_list, ln);
    }

    am->dirty = 1;
}",492.0,522.0,1.0,4.0,31.0,40,12,27,9,1,18,4,4,3,9,,0,12,2,1,1,void
2869,19681,writeAofManifestFile,1,writeAofManifestFile,int writeAofManifestFile (sds),aof.c,"int writeAofManifestFile(sds buf) {
    int ret = C_OK;
    ssize_t nwritten;
    int len;

    sds am_name = getAofManifestFileName();
    sds am_filepath = makePath(server.aof_dirname, am_name);
    sds tmp_am_name = getTempAofManifestFileName();
    sds tmp_am_filepath = makePath(server.aof_dirname, tmp_am_name);

    int fd = open(tmp_am_filepath, O_WRONLY|O_TRUNC|O_CREAT, 0644);
    if (fd == -1) {
        serverLog(LL_WARNING, ""Can't open the AOF manifest file %s: %s"",
            tmp_am_name, strerror(errno));

        ret = C_ERR;
        goto cleanup;
    }

    len = sdslen(buf);
    while(len) {
        nwritten = write(fd, buf, len);

        if (nwritten < 0) {
            if (errno == EINTR) continue;

            serverLog(LL_WARNING, ""Error trying to write the temporary AOF manifest file %s: %s"",
                tmp_am_name, strerror(errno));

            ret = C_ERR;
            goto cleanup;
        }

        len -= nwritten;
        buf += nwritten;
    }

    if...",525.0,595.0,1.0,14.0,71.0,50,10,62,15,1,15,15,12,1,15,,0,6,2,1,1,int
2870,19949,persistAofManifest,1,persistAofManifest,int persistAofManifest (aofManifest*),aof.c,"int persistAofManifest(aofManifest *am) {
    if (am->dirty == 0) {
        return C_OK;
    }

    sds amstr = getAofManifestAsString(am);
    int ret = writeAofManifestFile(amstr);
    sdsfree(amstr);
    if (ret == C_OK) am->dirty = 0;
    return ret;
}",598.0,608.0,1.0,15.0,11.0,7,3,9,3,5,5,3,3,1,3,,0,4,2,1,1,int
2871,19991,aofUpgradePrepare,1,aofUpgradePrepare,void aofUpgradePrepare (aofManifest*),aof.c,"void aofUpgradePrepare(aofManifest *am) {
    serverAssert(!aofFileExist(server.aof_filename));

    /* Create AOF directory use 'server.aof_dirname' as the name. */
    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        exit(1);
    }

    /* Manually construct a BASE type aofInfo and add it to aofManifest. */
    if (am->base_aof_info) aofInfoFree(am->base_aof_info);
    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdsnew(server.aof_filename);
    ai->file_seq = 1;
    ai->file_type = AOF_FILE_TYPE_BASE;
    am->base_aof_info = ai;
    am->curr_base_file_seq = 1;
    am->dirty = 1;

    /* Persist the manifest file to AOF directory. */
    if (persistAofManifest(am) != C_OK) {
        exit(1);
    }

    /* Move the old AOF file to AOF directory. */
    sds aof_filepath = makePath(server.aof_dirname, server.aof_filename);
    if (rename(serv...",620.0,660.0,1.0,4.0,41.0,48,13,33,6,1,22,5,5,3,14,,0,13,2,1,1,void
2872,20185,aofDelHistoryFiles,1,aofDelHistoryFiles,int aofDelHistoryFiles (void),aof.c,"int aofDelHistoryFiles(void) {
    if (server.aof_manifest == NULL ||
        server.aof_disable_auto_gc == 1 ||
        !listLength(server.aof_manifest->history_aof_list))
    {
        return C_OK;
    }

    listNode *ln;
    listIter li;

    listRewind(server.aof_manifest->history_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_HIST);
        serverLog(LL_NOTICE, ""Removing the history file %s in the background"", ai->file_name);
        sds aof_filepath = makePath(server.aof_dirname, ai->file_name);
        bg_unlink(aof_filepath);
        sdsfree(aof_filepath);
        listDelNode(server.aof_manifest->history_aof_list, ln);
    }

    server.aof_manifest->dirty = 1;
    return persistAofManifest(server.aof_manifest);
}",668.0,692.0,1.0,9.0,25.0,40,14,25,7,2,13,3,3,1,9,,0,6,2,1,1,int
2873,20322,aofDelTempIncrAofFile,1,aofDelTempIncrAofFile,void aofDelTempIncrAofFile (void),aof.c,"void aofDelTempIncrAofFile(void) {
    sds aof_filename = getTempIncrAofName();
    sds aof_filepath = makePath(server.aof_dirname, aof_filename);
    serverLog(LL_NOTICE, ""Removing the temp incr aof file %s in the background"", aof_filename);
    bg_unlink(aof_filepath);
    sdsfree(aof_filepath);
    sdsfree(aof_filename);
    return;
}",695.0,703.0,1.0,4.0,9.0,6,4,9,3,1,6,1,1,0,6,,0,2,2,1,1,void
2874,20365,aofOpenIfNeededOnServerStart,1,aofOpenIfNeededOnServerStart,void aofOpenIfNeededOnServerStart (void),aof.c,"void aofOpenIfNeededOnServerStart(void) {
    if (server.aof_state != AOF_ON) {
        return;
    }

    serverAssert(server.aof_manifest != NULL);
    serverAssert(server.aof_fd == -1);

    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        exit(1);
    }

    /* If we start with an empty dataset, we will force create a BASE file. */
    size_t incr_aof_len = listLength(server.aof_manifest->incr_aof_list);
    if (!server.aof_manifest->base_aof_info && !incr_aof_len) {
        sds base_name = getNewBaseFileNameAndMarkPreAsHistory(server.aof_manifest);
        sds base_filepath = makePath(server.aof_dirname, base_name);
        if (rewriteAppendOnlyFile(base_filepath) != C_OK) {
            exit(1);
        }
        sdsfree(base_filepath);
        serverLog(LL_NOTICE, ""Creating AOF base file %s on server start"",
            base_name);
    }

  ...",713.0,768.0,1.0,28.0,56.0,66,15,48,12,0,16,8,9,2,16,,0,8,2,1,1,void
2875,20680,openNewIncrAofForAppend,1,openNewIncrAofForAppend,int openNewIncrAofForAppend (void),aof.c,"int openNewIncrAofForAppend(void) {
    serverAssert(server.aof_manifest != NULL);
    int newfd = -1;
    aofManifest *temp_am = NULL;
    sds new_aof_name = NULL;

    /* Only open new INCR AOF when AOF enabled. */
    if (server.aof_state == AOF_OFF) return C_OK;

    /* Open new AOF. */
    if (server.aof_state == AOF_WAIT_REWRITE) {
        /* Use a temporary INCR AOF file to accumulate data during AOF_WAIT_REWRITE. */
        new_aof_name = getTempIncrAofName();
    } else {
        /* Dup a temp aof_manifest to modify. */
        temp_am = aofManifestDup(server.aof_manifest);
        new_aof_name = sdsdup(getNewIncrAofName(temp_am));
    }
    sds new_aof_filepath = makePath(server.aof_dirname, new_aof_name);
    newfd = open(new_aof_filepath, O_WRONLY|O_TRUNC|O_CREAT, 0644);
    sdsfree(new_aof_filepath);
    if (newfd == -1) {
        serverLog(LL_WARNING, ""Can't open the append-only file %s: %s"",
            new_aof_name, strerror(errno));
        goto cleanup;
    }

    ...",790.0,853.0,1.0,4.0,64.0,46,12,44,10,1,12,13,12,1,12,,0,3,2,1,1,int
2876,20903,aofRewriteLimited,1,aofRewriteLimited,int aofRewriteLimited (void),aof.c,"int aofRewriteLimited(void) {
    static int next_delay_minutes = 0;
    static time_t next_rewrite_time = 0;

    if (server.stat_aofrw_consecutive_failures < AOF_REWRITE_LIMITE_THRESHOLD) {
        /* We may be recovering from limited state, so reset all states. */
        next_delay_minutes = 0;
        next_rewrite_time = 0;
        return 0;
    }

    /* if it is in the limiting state, then check if the next_rewrite_time is reached */
    if (next_rewrite_time != 0) {
        if (server.unixtime < next_rewrite_time) {
            return 1;
        } else {
            next_rewrite_time = 0;
            return 0;
        }
    }

    next_delay_minutes = (next_delay_minutes == 0) ? 1 : (next_delay_minutes * 2);
    if (next_delay_minutes > AOF_REWRITE_LIMITE_MAX_MINUTES) {
        next_delay_minutes = AOF_REWRITE_LIMITE_MAX_MINUTES;
    }

    next_rewrite_time = server.unixtime + next_delay_minutes * 60;
    serverLog(LL_WARNING,
        ""Background AOF rewrite has repeatedly ...",877.0,907.0,1.0,49.0,31.0,22,10,18,3,1,1,5,6,0,1,,0,0,2,1,1,int
2877,21006,aofFsyncInProgress,1,aofFsyncInProgress,int aofFsyncInProgress (void),aof.c,"int aofFsyncInProgress(void) {
    /* Note that we don't care about aof_background_fsync_and_close because
     * server.aof_fd has been replaced by the new INCR AOF file fd,
     * see openNewIncrAofForAppend. */
    return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
}",915.0,920.0,1.0,1.0,6.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,int
2878,21016,aof_background_fsync,1,aof_background_fsync,void aof_background_fsync (int),aof.c,"void aof_background_fsync(int fd) {
    bioCreateFsyncJob(fd, server.master_repl_offset, 1);
}",924.0,926.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
2879,21038,killAppendOnlyChild,1,killAppendOnlyChild,void killAppendOnlyChild (void),aof.c,"void killAppendOnlyChild(void) {
    int statloc;
    /* No AOFRW child? return. */
    if (server.child_type != CHILD_TYPE_AOF) return;
    /* Kill AOFRW child, wait for child exit. */
    serverLog(LL_NOTICE,""Killing running AOF rewrite child: %ld"",
        (long) server.child_pid);
    if (kill(server.child_pid,SIGUSR1) != -1) {
        while(waitpid(-1, &statloc, 0) != server.child_pid);
    }
    aofRemoveTempFile(server.child_pid);
    resetChildState();
    server.aof_rewrite_time_start = -1;
}",934.0,947.0,1.0,29.0,14.0,18,8,9,3,1,3,4,5,0,3,,0,0,2,1,1,void
2880,21109,stopAppendOnly,1,stopAppendOnly,void stopAppendOnly (void),aof.c,"void stopAppendOnly(void) {
    serverAssert(server.aof_state != AOF_OFF);
    flushAppendOnlyFile(1);
    if (redis_fsync(server.aof_fd) == -1) {
        serverLog(LL_WARNING,""Fail to fsync the AOF file: %s"",strerror(errno));
    } else {
        server.aof_last_fsync = server.unixtime;
    }
    close(server.aof_fd);

    server.aof_fd = -1;
    server.aof_selected_db = -1;
    server.aof_state = AOF_OFF;
    server.aof_rewrite_scheduled = 0;
    server.aof_last_incr_size = 0;
    server.aof_last_incr_fsync_offset = 0;
    server.fsynced_reploff = -1;
    atomicSet(server.fsynced_reploff_pending, 0);
    killAppendOnlyChild();
    sdsfree(server.aof_buf);
    server.aof_buf = sdsempty();
}",951.0,972.0,1.0,4.0,22.0,35,11,16,2,4,6,2,2,0,6,,0,1,2,1,1,void
2881,21236,startAppendOnly,1,startAppendOnly,int startAppendOnly (void),aof.c,"int startAppendOnly(void) {
    serverAssert(server.aof_state == AOF_OFF);

    /* Wait for all bio jobs related to AOF to drain. This prevents a race
     * between updates to `fsynced_reploff_pending` of the worker thread, belonging
     * to the previous AOF, and the new one. This concern is specific for a full
     * sync scenario where we don't wanna risk the ACKed replication offset
     * jumping backwards or forward when switching to a different master. */
    bioDrainWorker(BIO_AOF_FSYNC);

    /* Set the initial repl_offset, which will be applied to fsynced_reploff
     * when AOFRW finishes (after possibly being updated by a bio thread) */
    atomicSet(server.fsynced_reploff_pending, server.master_repl_offset);
    server.fsynced_reploff = 0;

    server.aof_state = AOF_WAIT_REWRITE;
    if (hasActiveChildProcess() && server.child_type != CHILD_TYPE_AOF) {
        server.aof_rewrite_scheduled = 1;
        serverLog(LL_NOTICE,""AOF was enabled but there is already another ...",976.0,1029.0,1.0,4.0,54.0,38,12,19,3,2,6,4,4,1,6,,0,1,2,1,1,int
2882,21497,aofWrite,1,aofWrite,"ssize_t aofWrite (int,char*,size_t)",aof.c,"ssize_t aofWrite(int fd, const char *buf, size_t len) {
    ssize_t nwritten = 0, totwritten = 0;

    while(len) {
        nwritten = write(fd, buf, len);

        if (nwritten < 0) {
            if (errno == EINTR) continue;
            return totwritten ? totwritten : -1;
        }

        len -= nwritten;
        buf += nwritten;
        totwritten += nwritten;
    }

    return totwritten;
}",1038.0,1055.0,1.0,1.0,18.0,10,7,19,7,1,0,5,7,0,0,,0,0,6,3,3,ssize_t
2883,21549,flushAppendOnlyFile,1,flushAppendOnlyFile,void flushAppendOnlyFile (int),aof.c,"void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) {
        /* Check if we need to do fsync even the aof buffer is empty,
         * because previously in AOF_FSYNC_EVERYSEC mode, fsync is
         * called only when aof buffer is not empty, so if users
         * stop write commands before fsync called in one second,
         * the data in page cache cannot be flushed in time. */
        if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
            server.aof_last_incr_fsync_offset != server.aof_last_incr_size &&
            server.unixtime > server.aof_last_fsync &&
            !(sync_in_progress = aofFsyncInProgress())) {
            goto try_fsync;

        /* Check if we need to do fsync even the aof buffer is empty,
         * the reason is described in the previous AOF_FSYNC_EVERYSEC block,
         * and AOF_FSYNC_ALWAYS is also checked here to handle a case where
         * aof_f...",1076.0,1278.0,1.0,32.0,203.0,118,16,94,8,6,22,19,28,7,22,,0,14,2,1,1,void
2884,22292,catAppendOnlyGenericCommand,1,catAppendOnlyGenericCommand,"sds catAppendOnlyGenericCommand (sds,int,robj**)",aof.c,"sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
    char buf[32];
    int len, j;
    robj *o;

    buf[0] = '*';
    len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
    buf[len++] = '\r';
    buf[len++] = '\n';
    dst = sdscatlen(dst,buf,len);

    for (j = 0; j < argc; j++) {
        o = getDecodedObject(argv[j]);
        buf[0] = '$';
        len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
        buf[len++] = '\r';
        buf[len++] = '\n';
        dst = sdscatlen(dst,buf,len);
        dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
        dst = sdscatlen(dst,""\r\n"",2);
        decrRefCount(o);
    }
    return dst;
}",1280.0,1303.0,1.0,1.0,24.0,37,8,40,7,1,10,2,2,0,10,,0,9,6,3,3,sds
2885,22416,genAofTimestampAnnotationIfNeeded,1,genAofTimestampAnnotationIfNeeded,sds genAofTimestampAnnotationIfNeeded (int),aof.c,"sds genAofTimestampAnnotationIfNeeded(int force) {
    sds ts = NULL;

    if (force || server.aof_cur_timestamp < server.unixtime) {
        server.aof_cur_timestamp = force ? time(NULL) : server.unixtime;
        ts = sdscatfmt(sdsempty(), ""#TS:%I\r\n"", server.aof_cur_timestamp);
        serverAssert(sdslen(ts) <= AOF_ANNOTATION_LINE_MAX_LEN);
    }
    return ts;
}",1313.0,1322.0,1.0,8.0,10.0,16,9,13,4,2,4,2,2,0,4,,0,2,2,1,1,sds
2886,22474,feedAppendOnlyFile,1,feedAppendOnlyFile,"void feedAppendOnlyFile (int,robj**,int)",aof.c,"void feedAppendOnlyFile(int dictid, robj **argv, int argc) {
    sds buf = sdsempty();

    serverAssert(dictid == -1 || (dictid >= 0 && dictid < server.dbnum));

    /* Feed timestamp if needed */
    if (server.aof_timestamp_enabled) {
        sds ts = genAofTimestampAnnotationIfNeeded(0);
        if (ts != NULL) {
            buf = sdscatsds(buf, ts);
            sdsfree(ts);
        }
    }

    /* The DB this command was targeting is not the same as the last command
     * we appended. To issue a SELECT command is needed. */
    if (dictid != -1 && dictid != server.aof_selected_db) {
        char seldb[64];

        snprintf(seldb,sizeof(seldb),""%d"",dictid);
        buf = sdscatprintf(buf,""*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"",
            (unsigned long)strlen(seldb),seldb);
        server.aof_selected_db = dictid;
    }

    /* All commands should be propagated the same way in AOF as in replication.
     * No need for AOF-specific translation. */
    buf = catAppendOnlyGeneri...",1332.0,1371.0,1.0,4.0,40.0,38,14,37,8,1,10,5,6,0,10,,0,7,6,3,3,void
2887,22612,createAOFClient,1,createAOFClient,struct client createAOFClient (void),aof.c,"struct client *createAOFClient(void) {
    struct client *c = createClient(NULL);

    c->id = CLIENT_ID_AOF; /* So modules can identify it's the AOF client. */

    /*
     * The AOF client should never be blocked (unlike master
     * replication connection).
     * This is because blocking the AOF client might cause
     * deadlock (because potentially no one will unblock it).
     * Also, if the AOF client will be blocked just for
     * background processing there is a chance that the
     * command execution order will be violated.
     */
    c->flags = CLIENT_DENY_BLOCKING;

    /* We set the fake client as a slave waiting for the synchronization
     * so that Redis will not try to send replies to this client. */
    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
    return c;
}",1379.0,1399.0,1.0,12.0,21.0,8,3,7,3,1,4,1,1,0,1,,0,4,2,1,1,struct client
2888,22647,loadSingleAppendOnlyFile,1,loadSingleAppendOnlyFile,int loadSingleAppendOnlyFile (char*),aof.c,"int loadSingleAppendOnlyFile(char *filename) {
    struct client *fakeClient;
    struct redis_stat sb;
    int old_aof_state = server.aof_state;
    long loops = 0;
    off_t valid_up_to = 0; /* Offset of latest well-formed command loaded. */
    off_t valid_before_multi = 0; /* Offset before MULTI command loaded. */
    off_t last_progress_report_size = 0;
    int ret = AOF_OK;

    sds aof_filepath = makePath(server.aof_dirname, filename);
    FILE *fp = fopen(aof_filepath, ""r"");
    if (fp == NULL) {
        int en = errno;
        if (redis_stat(aof_filepath, &sb) == 0 || errno != ENOENT) {
            serverLog(LL_WARNING,""Fatal error: can't open the append log file %s for reading: %s"", filename, strerror(en));
            sdsfree(aof_filepath);
            return AOF_OPEN_ERR;
        } else {
            serverLog(LL_WARNING,""The append log file %s doesn't exist: %s"", filename, strerror(errno));
            sdsfree(aof_filepath);
            return AOF_NOT_EXIST;
        }
 ...",1407.0,1658.0,1.0,11.0,252.0,187,27,181,34,2,49,46,60,4,33,,0,22,2,1,1,int
2889,23735,loadAppendOnlyFiles,1,loadAppendOnlyFiles,int loadAppendOnlyFiles (aofManifest*),aof.c,"int loadAppendOnlyFiles(aofManifest *am) {
    serverAssert(am != NULL);
    int status, ret = AOF_OK;
    long long start;
    off_t total_size = 0, base_size = 0;
    sds aof_name;
    int total_num, aof_num = 0, last_file;

    /* If the 'server.aof_filename' file exists in dir, we may be starting
     * from an old redis version. We will use enter upgrade mode in three situations.
     *
     * 1. If the 'server.aof_dirname' directory not exist
     * 2. If the 'server.aof_dirname' directory exists but the manifest file is missing
     * 3. If the 'server.aof_dirname' directory exists and the manifest file it contains
     *    has only one base AOF record, and the file name of this base AOF is 'server.aof_filename',
     *    and the 'server.aof_filename' file not exist in 'server.aof_dirname' directory
     * */
    if (fileExist(server.aof_filename)) {
        if (!dirExists(server.aof_dirname) ||
            (am->base_aof_info == NULL && listLength(am->incr_aof_list) == 0) |...",1661.0,1784.0,1.0,4.0,124.0,147,20,103,17,1,46,18,30,17,27,,0,32,2,1,1,int
2890,24283,rioWriteBulkObject,1,rioWriteBulkObject,"int rioWriteBulkObject (rio*,robj*)",aof.c,"int rioWriteBulkObject(rio *r, robj *obj) {
    /* Avoid using getDecodedObject to help copy-on-write (we are often
     * in a child process when this function is called). */
    if (obj->encoding == OBJ_ENCODING_INT) {
        return rioWriteBulkLongLong(r,(long)obj->ptr);
    } else if (sdsEncodedObject(obj)) {
        return rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));
    } else {
        serverPanic(""Unknown string encoding"");
    }
}",1792.0,1802.0,1.0,25.0,11.0,4,3,3,2,13,1,2,2,0,1,,0,0,4,2,2,int
2891,24344,rewriteListObject,1,rewriteListObject,"int rewriteListObject (rio*,robj*,robj*)",aof.c,"int rewriteListObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = listTypeLength(o);

    listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
    listTypeEntry entry;
    while (listTypeNext(li,&entry)) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;
            if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
                !rioWriteBulkString(r,""RPUSH"",5) ||
                !rioWriteBulkObject(r,key)) 
            {
                listTypeReleaseIterator(li);
                return 0;
            }
        }

        unsigned char *vstr;
        size_t vlen;
        long long lval;
        vstr = listTypeGetValue(&entry,&vlen,&lval);
        if (vstr) {
            if (!rioWriteBulkString(r,(char*)vstr,vlen)) {
                listTypeReleaseIterator(li);
                return 0;
            }
        } else {
            if (!rioWriteBulkLongLong(r,lval)) {
 ...",1806.0,1844.0,1.0,52.0,39.0,24,11,30,11,0,11,7,14,5,11,,0,8,6,3,3,int
2892,24475,rewriteSetObject,1,rewriteSetObject,"int rewriteSetObject (rio*,robj*,robj*)",aof.c,"int rewriteSetObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = setTypeSize(o);
    setTypeIterator *si = setTypeInitIterator(o);
    char *str;
    size_t len;
    int64_t llval;
    while (setTypeNext(si, &str, &len, &llval) != -1) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;
            if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
                !rioWriteBulkString(r,""SADD"",4) ||
                !rioWriteBulkObject(r,key))
            {
                return 0;
            }
        }
        size_t written = str ?
            rioWriteBulkString(r, str, len) : rioWriteBulkLongLong(r, llval);
        if (!written) {
            setTypeReleaseIterator(si);
            return 0;
        }
        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
        items--;
    }
    setTypeReleaseIterator(si);
    return 1;
}",1848.0,1876.0,1.0,37.0,29.0,25,12,31,11,0,10,6,11,4,10,,0,8,6,3,3,int
2893,24589,rewriteSortedSetObject,1,rewriteSortedSetObject,"int rewriteSortedSetObject (rio*,robj*,robj*)",aof.c,"int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = zsetLength(o);

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vll;
        double score;

        eptr = lpSeek(zl,0);
        serverAssert(eptr != NULL);
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        while (eptr != NULL) {
            vstr = lpGetValue(eptr,&vlen,&vll);
            score = zzlGetScore(sptr);

            if (count == 0) {
                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                    AOF_REWRITE_ITEMS_PER_CMD : items;

                if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
                    !rioWriteBulkString(r,""ZADD"",4) ||
                    !rioWriteBulkObject(r,key)) 
                {
                    return 0;
                }
            }
            i...",1880.0,1956.0,1.0,23.0,77.0,44,16,45,14,0,13,9,24,5,13,,0,10,6,3,3,int
2894,24912,rioWriteHashIteratorCursor,1,rioWriteHashIteratorCursor,"int rioWriteHashIteratorCursor (rio*,hashTypeIterator*,int)",aof.c,"static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);
        if (vstr)
            return rioWriteBulkString(r, (char*)vstr, vlen);
        else
            return rioWriteBulkLongLong(r, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds value = hashTypeCurrentFromHashTable(hi, what);
        return rioWriteBulkString(r, value, sdslen(value));
    }

    serverPanic(""Unknown hash encoding"");
    return 0;
}",1964.0,1982.0,1.0,24.0,19.0,10,6,16,9,2,4,3,4,1,3,,0,1,6,3,3,int
2895,24998,rewriteHashObject,1,rewriteHashObject,"int rewriteHashObject (rio*,robj*,robj*)",aof.c,"int rewriteHashObject(rio *r, robj *key, robj *o) {
    hashTypeIterator *hi;
    long long count = 0, items = hashTypeLength(o);

    hi = hashTypeInitIterator(o);
    while (hashTypeNext(hi) != C_ERR) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;

            if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
                !rioWriteBulkString(r,""HMSET"",5) ||
                !rioWriteBulkObject(r,key)) 
            {
                hashTypeReleaseIterator(hi);
                return 0;
            }
        }

        if (!rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) ||
            !rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE))
        {
            hashTypeReleaseIterator(hi);
            return 0;           
        }
        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
        items--;
    }

    hashTypeReleaseIterator(hi);

    return 1;
}",1986.0,2018.0,1.0,31.0,33.0,23,12,25,7,0,11,6,11,6,11,,0,8,6,3,3,int
2896,25110,rioWriteBulkStreamID,1,rioWriteBulkStreamID,"int rioWriteBulkStreamID (rio*,streamID*)",aof.c,"int rioWriteBulkStreamID(rio *r,streamID *id) {
    int retval;

    sds replyid = sdscatfmt(sdsempty(),""%U-%U"",id->ms,id->seq);
    retval = rioWriteBulkString(r,replyid,sdslen(replyid));
    sdsfree(replyid);
    return retval;
}",2022.0,2029.0,1.0,1.0,8.0,4,2,9,4,5,7,1,1,0,5,,0,6,4,2,2,int
2897,25140,rioWriteStreamPendingEntry,1,rioWriteStreamPendingEntry,"int rioWriteStreamPendingEntry (rio*,robj*,char*,size_t,streamConsumer*,unsigned char*,streamNACK*)",aof.c,"int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
     /* XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
               RETRYCOUNT <count> JUSTID FORCE. */
    streamID id;
    streamDecodeID(rawid,&id);
    if (rioWriteBulkCount(r,'*',12) == 0) return 0;
    if (rioWriteBulkString(r,""XCLAIM"",6) == 0) return 0;
    if (rioWriteBulkObject(r,key) == 0) return 0;
    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
    if (rioWriteBulkString(r,""0"",1) == 0) return 0;
    if (rioWriteBulkStreamID(r,&id) == 0) return 0;
    if (rioWriteBulkString(r,""TIME"",4) == 0) return 0;
    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
    if (rioWriteBulkString(r,""RETRYCOUNT"",10) == 0) return 0;
    if (rioWriteBulkLongLong(r,nack->delivery_count) == ...",2035.0,2054.0,1.0,1.0,20.0,19,3,23,8,1,19,14,14,18,15,,0,18,14,7,7,int
2898,25294,rioWriteStreamEmptyConsumer,1,rioWriteStreamEmptyConsumer,"int rioWriteStreamEmptyConsumer (rio*,robj*,char*,size_t,streamConsumer*)",aof.c,"int rioWriteStreamEmptyConsumer(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer) {
    /* XGROUP CREATECONSUMER <key> <group> <consumer> */
    if (rioWriteBulkCount(r,'*',5) == 0) return 0;
    if (rioWriteBulkString(r,""XGROUP"",6) == 0) return 0;
    if (rioWriteBulkString(r,""CREATECONSUMER"",14) == 0) return 0;
    if (rioWriteBulkObject(r,key) == 0) return 0;
    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
    return 1;
}",2059.0,2068.0,1.0,1.0,10.0,8,2,11,5,1,9,7,7,9,7,,0,9,10,5,5,int
2899,25369,rewriteStreamObject,1,rewriteStreamObject,"int rewriteStreamObject (rio*,robj*,robj*)",aof.c,"int rewriteStreamObject(rio *r, robj *key, robj *o) {
    stream *s = o->ptr;
    streamIterator si;
    streamIteratorStart(&si,s,NULL,NULL,0);
    streamID id;
    int64_t numfields;

    if (s->length) {
        /* Reconstruct the stream data using XADD commands. */
        while(streamIteratorGetID(&si,&id,&numfields)) {
            /* Emit a two elements array for each item. The first is
             * the ID, the second is an array of field-value pairs. */

            /* Emit the XADD <key> <id> ...fields... command. */
            if (!rioWriteBulkCount(r,'*',3+numfields*2) || 
                !rioWriteBulkString(r,""XADD"",4) ||
                !rioWriteBulkObject(r,key) ||
                !rioWriteBulkStreamID(r,&id)) 
            {
                streamIteratorStop(&si);
                return 0;
            }
            while(numfields--) {
                unsigned char *field, *value;
                int64_t field_len, value_len;
                streamIteratorGetField(&...",2072.0,2210.0,1.0,1.0,139.0,115,11,105,18,0,74,16,42,44,53,,0,50,6,3,3,int
2900,25829,rewriteModuleObject,1,rewriteModuleObject,"int rewriteModuleObject (rio*,robj*,robj*,int)",aof.c,"int rewriteModuleObject(rio *r, robj *key, robj *o, int dbid) {
    RedisModuleIO io;
    moduleValue *mv = o->ptr;
    moduleType *mt = mv->type;
    moduleInitIOContext(io,mt,r,key,dbid);
    mt->aof_rewrite(&io,key,mv->value);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    return io.error ? 0 : 1;
}",2215.0,2226.0,1.0,4.0,12.0,28,5,31,8,0,16,2,2,1,2,,0,14,8,4,4,int
2901,25930,rewriteFunctions,1,rewriteFunctions,int rewriteFunctions (rio*),aof.c,"static int rewriteFunctions(rio *aof) {
    dict *functions = functionsLibGet();
    dictIterator *iter = dictGetIterator(functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionLibInfo *li = dictGetVal(entry);
        if (rioWrite(aof, ""*3\r\n"", 4) == 0) goto werr;
        char function_load[] = ""$8\r\nFUNCTION\r\n$4\r\nLOAD\r\n"";
        if (rioWrite(aof, function_load, sizeof(function_load) - 1) == 0) goto werr;
        if (rioWriteBulkString(aof, li->code, sdslen(li->code)) == 0) goto werr;
    }
    dictReleaseIterator(iter);
    return 1;

werr:
    dictReleaseIterator(iter);
    return 0;
}",2228.0,2245.0,1.0,1.0,18.0,13,5,19,7,1,12,8,8,7,10,,0,10,2,1,1,int
2902,26007,rewriteAppendOnlyFileRio,1,rewriteAppendOnlyFileRio,int rewriteAppendOnlyFileRio (rio*),aof.c,"int rewriteAppendOnlyFileRio(rio *aof) {
    dictIterator *di = NULL;
    dictEntry *de;
    int j;
    long key_count = 0;
    long long updated_time = 0;

    /* Record timestamp at the beginning of rewriting AOF. */
    if (server.aof_timestamp_enabled) {
        sds ts = genAofTimestampAnnotationIfNeeded(1);
        if (rioWrite(aof,ts,sdslen(ts)) == 0) { sdsfree(ts); goto werr; }
        sdsfree(ts);
    }

    if (rewriteFunctions(aof) == 0) goto werr;

    for (j = 0; j < server.dbnum; j++) {
        char selectcmd[] = ""*2\r\n$6\r\nSELECT\r\n"";
        redisDb *db = server.db+j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;
        di = dictGetSafeIterator(d);

        /* SELECT the new DB */
        if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
        if (rioWriteBulkLongLong(aof,j) == 0) goto werr;

        /* Iterate this DB writing every entry */
        while((de = dictNext(di)) != NULL) {
            sds keystr;
            robj...",2247.0,2348.0,1.0,12.0,102.0,77,15,90,22,0,28,33,58,14,25,,0,21,2,1,1,int
2903,26736,rewriteAppendOnlyFileBackground,1,rewriteAppendOnlyFileBackground,int rewriteAppendOnlyFileBackground (void),aof.c,"int rewriteAppendOnlyFileBackground(void) {
    pid_t childpid;

    if (hasActiveChildProcess()) return C_ERR;

    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        server.aof_lastbgrewrite_status = C_ERR;
        return C_ERR;
    }

    /* We set aof_selected_db to -1 in order to force the next call to the
     * feedAppendOnlyFile() to issue a SELECT command. */
    server.aof_selected_db = -1;
    flushAppendOnlyFile(1);
    if (openNewIncrAofForAppend() != C_OK) {
        server.aof_lastbgrewrite_status = C_ERR;
        return C_ERR;
    }
    server.stat_aof_rewrites++;
    if ((childpid = redisFork(CHILD_TYPE_AOF)) == 0) {
        char tmpfile[256];

        /* Child */
        redisSetProcTitle(""redis-aof-rewrite"");
        redisSetCpuAffinity(server.aof_rewrite_cpulist);
        snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) get...",2437.0,2489.0,1.0,40.0,53.0,30,9,15,5,1,12,6,7,5,12,,0,5,2,1,1,int
2904,26968,bgrewriteaofCommand,1,bgrewriteaofCommand,void bgrewriteaofCommand (client*),aof.c,"void bgrewriteaofCommand(client *c) {
    if (server.child_type == CHILD_TYPE_AOF) {
        addReplyError(c,""Background append only file rewriting already in progress"");
    } else if (hasActiveChildProcess() || server.in_exec) {
        server.aof_rewrite_scheduled = 1;
        /* When manually triggering AOFRW we reset the count 
         * so that it can be executed immediately. */
        server.stat_aofrw_consecutive_failures = 0;
        addReplyStatus(c,""Background append only file rewriting scheduled"");
    } else if (rewriteAppendOnlyFileBackground() == C_OK) {
        addReplyStatus(c,""Background append only file rewriting started"");
    } else {
        addReplyError(c,""Can't execute an AOF background rewriting. ""
                        ""Please check the server logs for more information."");
    }
}",2491.0,2506.0,1.0,29.0,16.0,2,2,2,2,0,1,2,2,0,1,,0,0,2,1,1,void
2905,27024,aofRemoveTempFile,1,aofRemoveTempFile,void aofRemoveTempFile (pid_t),aof.c,"void aofRemoveTempFile(pid_t childpid) {
    char tmpfile[256];

    snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) childpid);
    bg_unlink(tmpfile);

    snprintf(tmpfile,256,""temp-rewriteaof-%d.aof"", (int) childpid);
    bg_unlink(tmpfile);
}",2508.0,2516.0,1.0,1.0,9.0,2,1,6,2,2,2,1,1,0,2,,0,0,2,1,1,void
2906,27334,backgroundRewriteDoneHandler,1,backgroundRewriteDoneHandler,"void backgroundRewriteDoneHandler (int,int)",aof.c,"void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        char tmpfile[256];
        long long now = ustime();
        sds new_base_filepath = NULL;
        sds new_incr_filepath = NULL;
        aofManifest *temp_am;
        mstime_t latency;

        serverLog(LL_NOTICE,
            ""Background AOF rewrite terminated with success"");

        snprintf(tmpfile, 256, ""temp-rewriteaof-bg-%d.aof"",
            (int)server.child_pid);

        serverAssert(server.aof_manifest != NULL);

        /* Dup a temporary aof_manifest for subsequent modifications. */
        temp_am = aofManifestDup(server.aof_manifest);

        /* Get a new BASE file name and mark the previous (if we have)
         * as the HISTORY type. */
        sds new_base_filename = getNewBaseFileNameAndMarkPreAsHistory(temp_am);
        serverAssert(new_base_filename != NULL);
        new_base_filepath = makePath(server.aof_dirname, new_base_filename);

        /* Rename...",2578.0,2738.0,1.0,8.0,161.0,132,17,131,16,0,50,15,22,1,50,,0,16,4,2,2,void
2907,28124,bioProcessBackgroundJobs,1,bioProcessBackgroundJobs,void* bioProcessBackgroundJobs (void*),bio.c,"void *bioProcessBackgroundJobs(void *arg) {
    bio_job *job;
    unsigned long worker = (unsigned long) arg;
    sigset_t sigset;

    /* Check that the worker is within the right interval. */
    serverAssert(worker < BIO_WORKER_NUM);

    redis_set_thread_title(bio_worker_title[worker]);

    redisSetCpuAffinity(server.bio_cpulist);

    makeThreadKillable();

    pthread_mutex_lock(&bio_mutex[worker]);
    /* Block SIGALRM so we are sure that only the main thread will
     * receive the watchdog signal. */
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGALRM);
    if (pthread_sigmask(SIG_BLOCK, &sigset, NULL))
        serverLog(LL_WARNING,
            ""Warning: can't mask SIGALRM in bio.c thread: %s"", strerror(errno));

    while(1) {
        listNode *ln;

        /* The loop always starts with the lock hold. */
        if (listLength(bio_jobs[worker]) == 0) {
            pthread_cond_wait(&bio_newjob_cond[worker], &bio_mutex[worker]);
            continue;
        }
      ...",205.0,300.0,1.0,4.0,96.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
2908,28129,bioInit,1,bioInit,void bioInit (void),bio.c,"void bioInit(void) {
    pthread_attr_t attr;
    pthread_t thread;
    size_t stacksize;
    unsigned long j;

    /* Initialization of state vars and objects */
    for (j = 0; j < BIO_WORKER_NUM; j++) {
        pthread_mutex_init(&bio_mutex[j],NULL);
        pthread_cond_init(&bio_newjob_cond[j],NULL);
        bio_jobs[j] = listCreate();
    }

    /* Set the stack size as by default it may be small in some system */
    pthread_attr_init(&attr);
    pthread_attr_getstacksize(&attr,&stacksize);
    if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */
    while (stacksize < REDIS_THREAD_STACK_SIZE) stacksize *= 2;
    pthread_attr_setstacksize(&attr, stacksize);

    /* Ready to spawn our threads. We use the single argument the thread
     * function accepts in order to pass the job ID the thread is
     * responsible for. */
    for (j = 0; j < BIO_WORKER_NUM; j++) {
        void *arg = (void*)(unsigned long) j;
        if (pthread_create(&thread,&attr,bioProce...",119.0,150.0,1.0,20.0,32.0,38,13,35,14,1,10,6,7,4,2,,0,9,2,1,1,void
2909,28269,bioSubmitJob,1,bioSubmitJob,"void bioSubmitJob (int,bio_job*)",bio.c,"void bioSubmitJob(int type, bio_job *job) {
    job->header.type = type;
    unsigned long worker = bio_job_to_worker[type];
    pthread_mutex_lock(&bio_mutex[worker]);
    listAddNodeTail(bio_jobs[worker],job);
    bio_jobs_counter[type]++;
    pthread_cond_signal(&bio_newjob_cond[worker]);
    pthread_mutex_unlock(&bio_mutex[worker]);
}",152.0,160.0,1.0,1.0,9.0,14,6,16,8,4,7,1,1,0,1,,0,6,4,2,2,void
2910,28312,bioCreateLazyFreeJob,1,bioCreateLazyFreeJob,"void bioCreateLazyFreeJob (lazy_free_fn,int...)",bio.c,"void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) {
    va_list valist;
    /* Allocate memory for the job structure and all required
     * arguments */
    bio_job *job = zmalloc(sizeof(*job) + sizeof(void *) * (arg_count));
    job->free_args.free_fn = free_fn;

    va_start(valist, arg_count);
    for (int i = 0; i < arg_count; i++) {
        job->free_args.free_args[i] = va_arg(valist, void *);
    }
    va_end(valist);
    bioSubmitJob(BIO_LAZY_FREE, job);
}",162.0,175.0,1.0,1.0,14.0,11,8,14,7,6,2,2,2,0,2,,0,1,4,2,2,void
2911,28359,bioCreateCloseJob,1,bioCreateCloseJob,"void bioCreateCloseJob (int,int,int)",bio.c,"void bioCreateCloseJob(int fd, int need_fsync, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.need_fsync = need_fsync;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_CLOSE_FILE, job);
}",177.0,184.0,1.0,1.0,8.0,12,5,10,5,2,2,1,1,0,2,,0,1,6,3,3,void
2912,28397,bioCreateCloseAofJob,1,bioCreateCloseAofJob,"void bioCreateCloseAofJob (int,long long,int)",bio.c,"void bioCreateCloseAofJob(int fd, long long offset, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.offset = offset;
    job->fd_args.need_fsync = 1;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_CLOSE_AOF, job);
}",186.0,194.0,1.0,1.0,9.0,15,5,11,5,0,2,1,1,0,2,,0,1,6,3,3,void
2913,28442,bioCreateFsyncJob,1,bioCreateFsyncJob,"void bioCreateFsyncJob (int,long long,int)",bio.c,"void bioCreateFsyncJob(int fd, long long offset, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.offset = offset;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_AOF_FSYNC, job);
}",196.0,203.0,1.0,1.0,8.0,12,5,10,5,1,2,1,1,0,2,,0,1,6,3,3,void
2914,28920,bioPendingJobsOfType,1,bioPendingJobsOfType,unsigned long bioPendingJobsOfType (int),bio.c,"unsigned long bioPendingJobsOfType(int type) {
    unsigned int worker = bio_job_to_worker[type];

    pthread_mutex_lock(&bio_mutex[worker]);
    unsigned long val = bio_jobs_counter[type];
    pthread_mutex_unlock(&bio_mutex[worker]);

    return val;
}",303.0,311.0,1.0,1.0,9.0,8,3,11,6,3,4,1,1,0,0,,0,4,2,1,1,unsigned long
2915,28949,bioDrainWorker,1,bioDrainWorker,void bioDrainWorker (int),bio.c,"void bioDrainWorker(int job_type) {
    unsigned long worker = bio_job_to_worker[job_type];

    pthread_mutex_lock(&bio_mutex[worker]);
    while (listLength(bio_jobs[worker]) > 0) {
        pthread_cond_wait(&bio_newjob_cond[worker], &bio_mutex[worker]);
    }
    pthread_mutex_unlock(&bio_mutex[worker]);
}",314.0,322.0,1.0,11.0,9.0,14,5,15,6,2,7,2,2,2,0,,0,7,2,1,1,void
2916,28993,bioKillThreads,1,bioKillThreads,void bioKillThreads (void),bio.c,"void bioKillThreads(void) {
    int err;
    unsigned long j;

    for (j = 0; j < BIO_WORKER_NUM; j++) {
        if (bio_threads[j] == pthread_self()) continue;
        if (bio_threads[j] && pthread_cancel(bio_threads[j]) == 0) {
            if ((err = pthread_join(bio_threads[j],NULL)) != 0) {
                serverLog(LL_WARNING,
                    ""Bio worker thread #%lu can not be joined: %s"",
                        j, strerror(err));
            } else {
                serverLog(LL_WARNING,
                    ""Bio worker thread #%lu terminated"",j);
            }
        }
    }
}",328.0,345.0,1.0,20.0,18.0,18,11,17,6,1,7,6,9,6,1,,0,6,2,1,1,void
2917,29096,lazy_free_fn,1,lazy_free_fn,void lazy_free_fn (void[]*),bio.h,typedef void lazy_free_fn(void *args[]);,33.0,33.0,14.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
2918,29168,redisPopcount,1,redisPopcount,"long long redisPopcount (void*,long)",bitops.c,"long long redisPopcount(void *s, long count) {
    long long bits = 0;
    unsigned char *p = s;
    uint32_t *p4;
    static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};

    /* Count initial bytes not aligned to 32 bit. */
    while((unsigned long)p & 3 && count) {
        bits += bitsinbyte[*p++];
        count--;
    }

    /* Count bits 28 bytes at a time */
    p4 = (uint32_t*)p;
    while(count>=28) {
        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;

        aux1 = *p...",40.0,92.0,1.0,1.0,53.0,133,16,89,13,0,0,4,4,0,0,,0,0,4,2,2,long long
2919,29734,redisBitpos,1,redisBitpos,"long long redisBitpos (void*,long unsigned,int)",bitops.c,"long long redisBitpos(void *s, unsigned long count, int bit) {
    unsigned long *l;
    unsigned char *c;
    unsigned long skipval, word = 0, one;
    long long pos = 0; /* Position of bit, to return to the caller. */
    unsigned long j;
    int found;

    /* Process whole words first, seeking for first word that is not
     * all ones or all zeros respectively if we are looking for zeros
     * or ones. This is much faster with large strings having contiguous
     * blocks of 1 or 0 bits compared to the vanilla bit per bit processing.
     *
     * Note that if we start from an address that is not aligned
     * to sizeof(unsigned long) we consume it byte by byte until it is
     * aligned. */

    /* Skip initial bits not aligned to sizeof(unsigned long) byte by byte. */
    skipval = bit ? 0 : UCHAR_MAX;
    c = (unsigned char*) s;
    found = 0;
    while((unsigned long)c & (sizeof(*l)-1) && count) {
        if (*c != skipval) {
            found = 1;
            break;
    ...",101.0,186.0,1.0,4.0,86.0,58,21,57,13,0,1,13,17,0,1,,0,0,6,3,3,long long
2920,29925,setUnsignedBitfield,1,setUnsignedBitfield,"void setUnsignedBitfield (unsigned char*,uint64_t,uint64_t,uint64_t)",bitops.c,"void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
    uint64_t byte, bit, byteval, bitval, j;

    for (j = 0; j < bits; j++) {
        bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
        byte = offset >> 3;
        bit = 7 - (offset & 0x7);
        byteval = p[byte];
        byteval &= ~(1 << bit);
        byteval |= bitval << bit;
        p[byte] = byteval & 0xff;
        offset++;
    }
}",209.0,222.0,1.0,1.0,14.0,23,11,23,9,1,0,2,2,0,0,,0,0,8,4,4,void
2921,30001,setSignedBitfield,1,setSignedBitfield,"void setSignedBitfield (unsigned char*,uint64_t,uint64_t,int64_t)",bitops.c,"void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
    uint64_t uv = value; /* Casting will add UINT64_MAX + 1 if v is negative. */
    setUnsignedBitfield(p,offset,bits,uv);
}",224.0,227.0,1.0,1.0,4.0,1,1,6,5,1,1,1,1,0,1,,0,0,8,4,4,void
2922,30018,getUnsignedBitfield,1,getUnsignedBitfield,"uint64_t getUnsignedBitfield (unsigned char*,uint64_t,uint64_t)",bitops.c,"uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
    uint64_t byte, bit, byteval, bitval, j, value = 0;

    for (j = 0; j < bits; j++) {
        byte = offset >> 3;
        bit = 7 - (offset & 0x7);
        byteval = p[byte];
        bitval = (byteval >> bit) & 1;
        value = (value<<1) | bitval;
        offset++;
    }
    return value;
}",229.0,241.0,1.0,1.0,13.0,17,9,19,9,1,0,2,2,0,0,,0,0,6,3,3,uint64_t
2923,30080,getSignedBitfield,1,getSignedBitfield,"int64_t getSignedBitfield (unsigned char*,uint64_t,uint64_t)",bitops.c,"int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
    int64_t value;
    union {uint64_t u; int64_t i;} conv;

    /* Converting from unsigned to signed is undefined when the value does
     * not fit, however here we assume two's complement and the original value
     * was obtained from signed -> unsigned conversion, so we'll find the
     * most significant bit set if the original value was negative.
     *
     * Note that two's complement is mandatory for exact-width types
     * according to the C99 standard. */
    conv.u = getUnsignedBitfield(p,offset,bits);
    value = conv.i;

    /* If the top significant bit is 1, propagate it to all the
     * higher bits for two's complement representation of signed
     * integers. */
    if (bits < 64 && (value & ((uint64_t)1 << (bits-1))))
        value |= ((uint64_t)-1) << bits;
    return value;
}",243.0,263.0,1.0,1.0,21.0,12,8,13,6,1,1,2,2,0,1,,0,1,6,3,3,int64_t
2924,30126,checkUnsignedBitfieldOverflow,1,checkUnsignedBitfieldOverflow,"int checkUnsignedBitfieldOverflow (uint64_t,int64_t,uint64_t,int,uint64_t*)",bitops.c,"int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {
    uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
    int64_t maxincr = max-value;
    int64_t minincr = -value;

    if (value > max || (incr > 0 && incr > maxincr)) {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = max;
            }
        }
        return 1;
    } else if (incr < 0 && incr < minincr) {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = 0;
            }
        }
        return -1;
    }
    return 0;

handle_wrap:
    {
        uint64_t mask = ((uint64_t)-1) << bits;
        uint64_t res = value+incr;

        res &= ~mask;
        *limit = res;
    }
    return 1;
}",288.0,323.0,1.0,26.0,36.0,24,13,26,12,0,0,5,7,0,0,,0,0,10,5,5,int
2925,30266,checkSignedBitfieldOverflow,1,checkSignedBitfieldOverflow,"int checkSignedBitfieldOverflow (int64_t,int64_t,uint64_t,int,int64_t*)",bitops.c,"int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {
    int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
    int64_t min = (-max)-1;

    /* Note that maxincr and minincr could overflow, but we use the values
     * only after checking 'value' range, so when we use it no overflow
     * happens. 'uint64_t' cast is there just to prevent undefined behavior on
     * overflow */
    int64_t maxincr = (uint64_t)max-value;
    int64_t minincr = min-value;

    if (value > max || (bits != 64 && incr > maxincr) || (value >= 0 && incr > 0 && incr > maxincr))
    {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = max;
            }
        }
        return 1;
    } else if (value < min || (bits != 64 && incr < minincr) || (value < 0 && incr < 0 && incr < minincr)) {
        if (limit) {
       ...",325.0,378.0,1.0,26.0,54.0,42,16,42,16,1,0,7,10,0,0,,0,0,10,5,5,int
2926,30479,printBits,1,printBits,"void printBits (unsigned char*,long unsigned)",bitops.c,"void printBits(unsigned char *p, unsigned long count) {
    unsigned long j, i, byte;

    for (j = 0; j < count; j++) {
        byte = p[j];
        for (i = 0x80; i > 0; i /= 2)
            printf(""%c"", (byte & i) ? '1' : '0');
        printf(""|"");
    }
    printf(""\n"");
}",382.0,392.0,1.0,1.0,11.0,6,4,8,5,0,0,3,4,0,0,,0,0,4,2,2,void
2927,30527,getBitOffsetFromArgument,1,getBitOffsetFromArgument,"int getBitOffsetFromArgument (client*,robj*,uint64_t*,int,int)",bitops.c,"int getBitOffsetFromArgument(client *c, robj *o, uint64_t *offset, int hash, int bits) {
    long long loffset;
    char *err = ""bit offset is not an integer or out of range"";
    char *p = o->ptr;
    size_t plen = sdslen(p);
    int usehash = 0;

    /* Handle #<offset> form. */
    if (p[0] == '#' && hash && bits > 0) usehash = 1;

    if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
        addReplyError(c,err);
        return C_ERR;
    }

    /* Adjust the offset by 'bits' for #<offset> form. */
    if (usehash) loffset *= bits;

    /* Limit offset to server.proto_max_bulk_len (512MB in bytes by default) */
    if (loffset < 0 || (!mustObeyClient(c) && (loffset >> 3) >= server.proto_max_bulk_len))
    {
        addReplyError(c,err);
        return C_ERR;
    }

    *offset = loffset;
    return C_OK;
}",414.0,441.0,1.0,15.0,28.0,27,18,28,11,3,5,5,5,2,5,,0,3,10,5,5,int
2928,30632,getBitfieldTypeFromArgument,1,getBitfieldTypeFromArgument,"int getBitfieldTypeFromArgument (client*,robj*,int*,int*)",bitops.c,"int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
    char *p = o->ptr;
    char *err = ""Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is."";
    long long llbits;

    if (p[0] == 'i') {
        *sign = 1;
    } else if (p[0] == 'u') {
        *sign = 0;
    } else {
        addReplyError(c,err);
        return C_ERR;
    }

    if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
        llbits < 1 ||
        (*sign == 1 && llbits > 64) ||
        (*sign == 0 && llbits > 63))
    {
        addReplyError(c,err);
        return C_ERR;
    }
    *bits = llbits;
    return C_OK;
}",450.0,474.0,1.0,15.0,25.0,26,12,17,7,1,2,3,3,1,2,,0,1,8,4,4,int
2929,30737,lookupStringForBitCommand,1,lookupStringForBitCommand,"robj lookupStringForBitCommand (client*,uint64_t,int*)",bitops.c,"robj *lookupStringForBitCommand(client *c, uint64_t maxbit, int *dirty) {
    size_t byte = maxbit >> 3;
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return NULL;
    if (dirty) *dirty = 0;

    if (o == NULL) {
        o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
        dbAdd(c->db,c->argv[1],o);
        if (dirty) *dirty = 1;
    } else {
        o = dbUnshareStringValue(c->db,c->argv[1],o);
        size_t oldlen = sdslen(o->ptr);
        o->ptr = sdsgrowzero(o->ptr,byte+1);
        if (dirty && oldlen != sdslen(o->ptr)) *dirty = 1;
    }
    return o;
}",481.0,498.0,1.0,22.0,18.0,16,7,21,6,1,9,5,6,1,5,,0,8,6,3,3,robj
2930,30860,getObjectReadOnlyString,1,getObjectReadOnlyString,"unsigned char* getObjectReadOnlyString (robj*,long*,char*)",bitops.c,"unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {
    serverAssert(!o || o->type == OBJ_STRING);
    unsigned char *p = NULL;

    /* Set the 'p' pointer to the string, that can be just a stack allocated
     * array if our string was integer encoded. */
    if (o && o->encoding == OBJ_ENCODING_INT) {
        p = (unsigned char*) llbuf;
        if (len) *len = ll2string(llbuf,LONG_STR_SIZE,(long)o->ptr);
    } else if (o) {
        p = (unsigned char*) o->ptr;
        if (len) *len = sdslen(o->ptr);
    } else {
        if (len) *len = 0;
    }
    return p;
}",513.0,529.0,1.0,4.0,17.0,18,11,13,5,2,2,3,4,0,2,,0,1,6,3,3,unsigned char*
2931,30957,setbitCommand,1,setbitCommand,void setbitCommand (client*),bitops.c,"void setbitCommand(client *c) {
    robj *o;
    char *err = ""bit is not an integer or out of range"";
    uint64_t bitoffset;
    ssize_t byte, bit;
    int byteval, bitval;
    long on;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
        return;

    /* Bits can only be set or cleared... */
    if (on & ~1) {
        addReplyError(c,err);
        return;
    }

    int dirty;
    if ((o = lookupStringForBitCommand(c,bitoffset,&dirty)) == NULL) return;

    /* Get current values */
    byte = bitoffset >> 3;
    byteval = ((uint8_t*)o->ptr)[byte];
    bit = 7 - (bitoffset & 0x7);
    bitval = byteval & (1 << bit);

    /* Either it is newly created, changed length, or the bit changes before and after.
     * Note that the bitval here is actually a decimal number.
     * So we need to use `!!` to convert it to 0 or 1 for comparison. */
    if (dirty || (!!bitval != on)) {
    ...",532.0,576.0,1.0,65.0,45.0,51,17,47,13,0,13,6,6,5,7,,0,9,2,1,1,void
2932,31131,getbitCommand,1,getbitCommand,void getbitCommand (client*),bitops.c,"void getbitCommand(client *c) {
    robj *o;
    char llbuf[32];
    uint64_t bitoffset;
    size_t byte, bit;
    size_t bitval = 0;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;

    byte = bitoffset >> 3;
    bit = 7 - (bitoffset & 0x7);
    if (sdsEncodedObject(o)) {
        if (byte < sdslen(o->ptr))
            bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
    } else {
        if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(long)o->ptr))
            bitval = llbuf[byte] & (1 << bit);
    }

    addReply(c, bitval ? shared.cone : shared.czero);
}",579.0,603.0,1.0,65.0,25.0,32,15,28,8,0,7,5,6,6,5,,0,6,2,1,1,void
2933,31272,bitopCommand,1,bitopCommand,void bitopCommand (client*),bitops.c,"void bitopCommand(client *c) {
    char *opname = c->argv[1]->ptr;
    robj *o, *targetkey = c->argv[2];
    unsigned long op, j, numkeys;
    robj **objects;      /* Array of source objects. */
    unsigned char **src; /* Array of source strings pointers. */
    unsigned long *len, maxlen = 0; /* Array of length of src strings,
                                       and max len. */
    unsigned long minlen = 0;    /* Min len among the input keys. */
    unsigned char *res = NULL; /* Resulting string. */

    /* Parse the operation name. */
    if ((opname[0] == 'a' || opname[0] == 'A') && !strcasecmp(opname,""and""))
        op = BITOP_AND;
    else if((opname[0] == 'o' || opname[0] == 'O') && !strcasecmp(opname,""or""))
        op = BITOP_OR;
    else if((opname[0] == 'x' || opname[0] == 'X') && !strcasecmp(opname,""xor""))
        op = BITOP_XOR;
    else if((opname[0] == 'n' || opname[0] == 'N') && !strcasecmp(opname,""not""))
        op = BITOP_NOT;
    else {
        addReplyErrorObje...",607.0,793.0,1.0,13.0,187.0,149,24,181,25,0,30,28,54,2,22,,0,17,2,1,1,void
2934,32170,bitcountCommand,1,bitcountCommand,void bitcountCommand (client*),bitops.c,"void bitcountCommand(client *c) {
    robj *o;
    long long start, end;
    long strlen;
    unsigned char *p;
    char llbuf[LONG_STR_SIZE];
    int isbit = 0;
    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;

    /* Lookup, check for type, and return 0 for non existing keys. */
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;
    p = getObjectReadOnlyString(o,&strlen,llbuf);

    /* Parse start/end range if any. */
    if (c->argc == 4 || c->argc == 5) {
        long long totlen = strlen;
        /* Make sure we will not overflow */
        serverAssert(totlen <= LLONG_MAX >> 3);
        if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
            return;
        if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
            return;
        /* Convert negative indexes */
        if (start < 0 && end < 0 && start > end) {
            addReply(c,shared.czero);
    ...",796.0,874.0,1.0,15.0,79.0,73,24,68,14,0,15,16,29,11,8,,0,12,2,1,1,void
2935,32555,bitposCommand,1,bitposCommand,void bitposCommand (client*),bitops.c,"void bitposCommand(client *c) {
    robj *o;
    long long start, end;
    long bit, strlen;
    unsigned char *p;
    char llbuf[LONG_STR_SIZE];
    int isbit = 0, end_given = 0;
    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;

    /* Parse the bit argument to understand what we are looking for, set
     * or clear bits. */
    if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != C_OK)
        return;
    if (bit != 0 && bit != 1) {
        addReplyError(c, ""The bit argument must be 1 or 0."");
        return;
    }

    /* If the key does not exist, from our point of view it is an infinite
     * array of 0 bits. If the user is looking for the first clear bit return 0,
     * If the user is looking for the first set bit, return -1. */
    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
        addReplyLongLong(c, bit ? -1 : 0);
        return;
    }
    if (checkType(c,o,OBJ_STRING)) return;
    p = getObjectReadOnlyString(o,&strlen,llbuf);

    /* Parse ...",877.0,1003.0,1.0,15.0,127.0,82,24,73,15,0,21,19,33,16,10,,0,17,2,1,1,void
2936,33129,bitfieldGeneric,1,bitfieldGeneric,"void bitfieldGeneric (client*,int)",bitops.c,"void bitfieldGeneric(client *c, int flags) {
    robj *o;
    uint64_t bitoffset;
    int j, numops = 0, changes = 0, dirty = 0;
    struct bitfieldOp *ops = NULL; /* Array of ops to execute at end. */
    int owtype = BFOVERFLOW_WRAP; /* Overflow type. */
    int readonly = 1;
    uint64_t highest_write_offset = 0;

    for (j = 2; j < c->argc; j++) {
        int remargs = c->argc-j-1; /* Remaining args other than current. */
        char *subcmd = c->argv[j]->ptr; /* Current command name. */
        int opcode; /* Current operation code. */
        long long i64 = 0;  /* Signed SET value. */
        int sign = 0; /* Signed or unsigned type? */
        int bits = 0; /* Bitfield width in bits. */

        if (!strcasecmp(subcmd,""get"") && remargs >= 2)
            opcode = BITFIELDOP_GET;
        else if (!strcasecmp(subcmd,""set"") && remargs >= 3)
            opcode = BITFIELDOP_SET;
        else if (!strcasecmp(subcmd,""incrby"") && remargs >= 3)
            opcode = BITFIELDOP_INCRBY...",1030.0,1259.0,1.0,17.0,230.0,128,21,133,25,2,43,17,39,13,18,,0,33,4,2,2,void
2937,34005,bitfieldCommand,1,bitfieldCommand,void bitfieldCommand (client*),bitops.c,"void bitfieldCommand(client *c) {
    bitfieldGeneric(c, BITFIELD_FLAG_NONE);
}",1261.0,1263.0,1.0,23.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2938,34015,bitfieldroCommand,1,bitfieldroCommand,void bitfieldroCommand (client*),bitops.c,"void bitfieldroCommand(client *c) {
    bitfieldGeneric(c, BITFIELD_FLAG_READONLY);
}",1265.0,1267.0,1.0,23.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
2939,34040,unblockClientWaitingData,1,unblockClientWaitingData,void unblockClientWaitingData (client*),blocked.c,"static void unblockClientWaitingData(client *c) {
    dictEntry *de;
    dictIterator *di;

    if (dictSize(c->bstate.keys) == 0)
        return;

    di = dictGetIterator(c->bstate.keys);
    /* The client may wait for multiple keys, so unblock it for every key. */
    while((de = dictNext(di)) != NULL) {
        releaseBlockedEntry(c, de, 0);
    }
    dictReleaseIterator(di);
    dictEmpty(c->bstate.keys, NULL);
}",419.0,433.0,1.0,8.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2940,34045,handleClientsBlockedOnKey,1,handleClientsBlockedOnKey,void handleClientsBlockedOnKey (readyList*),blocked.c,"static void handleClientsBlockedOnKey(readyList *rl) {

    /* We serve clients in the same order they blocked for
     * this key, from the first blocked to the last. */
    dictEntry *de = dictFind(rl->db->blocking_keys,rl->key);

    if (de) {
        list *clients = dictGetVal(de);
        listNode *ln;
        listIter li;
        listRewind(clients,&li);

        /* Avoid processing more than the initial count so that we're not stuck
         * in an endless loop in case the reprocessing of the command blocks again. */
        long count = listLength(clients);
        while ((ln = listNext(&li)) && count--) {
            client *receiver = listNodeValue(ln);
            robj *o = lookupKeyReadWithFlags(rl->db, rl->key, LOOKUP_NOEFFECTS);
            /* 1. In case new key was added/touched we need to verify it satisfy the
             *    blocked type, since we might process the wrong key type.
             * 2. We want to serve clients blocked on module keys
             *   ...",558.0,594.0,1.0,21.0,37.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
2941,34050,unblockClientOnKey,1,unblockClientOnKey,"void unblockClientOnKey (client*,robj*)",blocked.c,"static void unblockClientOnKey(client *c, robj *key) {
    dictEntry *de;

    de = dictFind(c->bstate.keys, key);
    releaseBlockedEntry(c, de, 1);

    /* Only in case of blocking API calls, we might be blocked on several keys.
       however we should force unblock the entire blocking keys */
    serverAssert(c->bstate.btype == BLOCKED_STREAM ||
                c->bstate.btype == BLOCKED_LIST   ||
                c->bstate.btype == BLOCKED_ZSET);

    /* We need to unblock the client before calling processCommandAndResetClient
     * because it checks the CLIENT_BLOCKED flag */
    unblockClient(c, 0);
    /* In case this client was blocked on keys during command
     * we need to re process the command again */
    if (c->flags & CLIENT_PENDING_COMMAND) {
        c->flags &= ~CLIENT_PENDING_COMMAND;
        /* We want the command processing and the unblock handler (see RM_Call 'K' option)
         * to run atomically, this is why we must enter the execution unit here before
   ...",636.0,675.0,1.0,4.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2942,34056,moduleUnblockClientOnKey,1,moduleUnblockClientOnKey,"void moduleUnblockClientOnKey (client*,robj*)",blocked.c,"static void moduleUnblockClientOnKey(client *c, robj *key) {
    long long prev_error_replies = server.stat_total_error_replies;
    client *old_client = server.current_client;
    server.current_client = c;
    monotime replyTimer;
    elapsedStart(&replyTimer);

    if (moduleTryServeClientBlockedOnKey(c, key)) {
        updateStatsOnUnblock(c, 0, elapsedUs(replyTimer), server.stat_total_error_replies != prev_error_replies);
        moduleUnblockClient(c);
    }
    /* We need to call afterCommand even if the client was not unblocked
     * in order to propagate any changes that could have been done inside
     * moduleTryServeClientBlockedOnKey */
    afterCommand(c);
    server.current_client = old_client;
}",681.0,697.0,1.0,1.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
2943,34062,releaseBlockedEntry,1,releaseBlockedEntry,"void releaseBlockedEntry (client*,dictEntry*,int)",blocked.c,"static void releaseBlockedEntry(client *c, dictEntry *de, int remove_key) {
    list *l;
    listNode *pos;
    void *key;
    dictEntry *unblock_on_nokey_entry;

    key = dictGetKey(de);
    pos = dictGetVal(de);
    /* Remove this client from the list of clients waiting for this key. */
    l = dictFetchValue(c->db->blocking_keys, key);
    serverAssertWithInfo(c,key,l != NULL);
    listUnlinkNode(l,pos);
    /* If the list is empty we need to remove it to avoid wasting memory
     * We will also remove the key (if exists) from the blocking_keys_unblock_on_nokey dict.
     * However, in case the list is not empty, we will have to still perform reference accounting
     * on the blocking_keys_unblock_on_nokey and delete the entry in case of zero reference.
     * Why? because it is possible that some more clients are blocked on the same key but without
     * require to be triggered on key deletion, we do not want these to be later triggered by the
     * signalDeletedKeyAsReady. ...",512.0,545.0,1.0,4.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
2944,34069,initClientBlockingState,1,initClientBlockingState,void initClientBlockingState (client*),blocked.c,"void initClientBlockingState(client *c) {
    c->bstate.btype = BLOCKED_NONE;
    c->bstate.timeout = 0;
    c->bstate.keys = dictCreate(&objectKeyHeapPointerValueDictType);
    c->bstate.numreplicas = 0;
    c->bstate.reploffset = 0;
    c->bstate.unblock_on_nokey = 0;
    c->bstate.async_rm_call_handle = NULL;
}",75.0,83.0,1.0,1.0,9.0,22,4,10,4,1,8,1,1,0,1,,0,8,2,1,1,void
2945,34125,blockClient,1,blockClient,"void blockClient (client*,int)",blocked.c,"void blockClient(client *c, int btype) {
    /* Master client should never be blocked unless pause or module */
    serverAssert(!(c->flags & CLIENT_MASTER &&
                   btype != BLOCKED_MODULE &&
                   btype != BLOCKED_POSTPONE));

    c->flags |= CLIENT_BLOCKED;
    c->bstate.btype = btype;
    if (!(c->flags & CLIENT_MODULE)) server.blocked_clients++; /* We count blocked client stats on regular clients and not on module clients */
    server.blocked_clients_by_type[btype]++;
    addClientToTimeoutTable(c);
}",88.0,99.0,1.0,4.0,12.0,26,14,13,5,5,6,2,2,1,2,,0,4,4,2,2,void
2946,34200,updateStatsOnUnblock,1,updateStatsOnUnblock,"void updateStatsOnUnblock (client*,long,long,int)",blocked.c,"void updateStatsOnUnblock(client *c, long blocked_us, long reply_us, int had_errors){
    const ustime_t total_cmd_duration = c->duration + blocked_us + reply_us;
    c->lastcmd->microseconds += total_cmd_duration;
    c->lastcmd->calls++;
    server.stat_numcommands++;
    if (had_errors)
        c->lastcmd->failed_calls++;
    if (server.latency_tracking_enabled)
        updateCommandLatencyHistogram(&(c->lastcmd->latency_histogram), total_cmd_duration*1000);
    /* Log the command into the Slow log if needed. */
    slowlogPushCurrentCommand(c, c->lastcmd, total_cmd_duration);
    c->duration = 0;
    /* Log the reply duration event. */
    latencyAddSampleIfNeeded(""command-unblocking"",reply_us/1000);
}",106.0,120.0,1.0,4.0,15.0,29,11,21,6,5,10,3,3,0,3,,0,7,8,4,4,void
2947,34291,processUnblockedClients,1,processUnblockedClients,void processUnblockedClients (void),blocked.c,"void processUnblockedClients(void) {
    listNode *ln;
    client *c;

    while (listLength(server.unblocked_clients)) {
        ln = listFirst(server.unblocked_clients);
        serverAssert(ln != NULL);
        c = ln->value;
        listDelNode(server.unblocked_clients,ln);
        c->flags &= ~CLIENT_UNBLOCKED;

        if (c->flags & CLIENT_MODULE) {
            if (!(c->flags & CLIENT_BLOCKED)) {
                moduleCallCommandUnblockedHandler(c);
            }
            continue;
        }

        /* Process remaining data in the input buffer, unless the client
         * is blocked again. Actually processInputBuffer() checks that the
         * client is not blocked before to proceed, but things may change and
         * the code is conceptually more correct this way. */
        if (!(c->flags & CLIENT_BLOCKED)) {
            /* If we have a queued command, execute it now. */
            if (processPendingCommandAndInputBuffer(c) == C_ERR) {
                c = NULL;
 ...",125.0,155.0,1.0,11.0,31.0,32,14,20,4,1,10,7,12,4,5,,0,6,2,1,1,void
2948,34410,queueClientForReprocessing,1,queueClientForReprocessing,void queueClientForReprocessing (client*),blocked.c,"void queueClientForReprocessing(client *c) {
    /* The client may already be into the unblocked list because of a previous
     * blocking operation, don't add back it into the list multiple times. */
    if (!(c->flags & CLIENT_UNBLOCKED)) {
        c->flags |= CLIENT_UNBLOCKED;
        listAddNodeTail(server.unblocked_clients,c);
    }
}",173.0,180.0,1.0,21.0,8.0,7,5,4,2,2,3,2,2,1,1,,0,2,2,1,1,void
2949,34441,unblockClient,1,unblockClient,"void unblockClient (client*,int)",blocked.c,"void unblockClient(client *c, int queue_for_reprocessing) {
    if (c->bstate.btype == BLOCKED_LIST ||
        c->bstate.btype == BLOCKED_ZSET ||
        c->bstate.btype == BLOCKED_STREAM) {
        unblockClientWaitingData(c);
    } else if (c->bstate.btype == BLOCKED_WAIT || c->bstate.btype == BLOCKED_WAITAOF) {
        unblockClientWaitingReplicas(c);
    } else if (c->bstate.btype == BLOCKED_MODULE) {
        if (moduleClientIsBlockedOnKeys(c)) unblockClientWaitingData(c);
        unblockClientFromModule(c);
    } else if (c->bstate.btype == BLOCKED_POSTPONE) {
        listDelNode(server.postponed_clients,c->postponed_list_node);
        c->postponed_list_node = NULL;
    } else if (c->bstate.btype == BLOCKED_SHUTDOWN) {
        /* No special cleanup. */
    } else {
        serverPanic(""Unknown btype in unblockClient()."");
    }

    /* Reset the client for a new query, unless the client has pending command to process
     * or in case a shutdown operation was canceled and we a...",184.0,224.0,1.0,8.0,41.0,39,13,24,8,9,16,5,5,6,6,,0,10,4,2,2,void
2950,34641,replyToBlockedClientTimedOut,1,replyToBlockedClientTimedOut,void replyToBlockedClientTimedOut (client*),blocked.c,"void replyToBlockedClientTimedOut(client *c) {
    if (c->bstate.btype == BLOCKED_LIST ||
        c->bstate.btype == BLOCKED_ZSET ||
        c->bstate.btype == BLOCKED_STREAM) {
        addReplyNullArray(c);
        updateStatsOnUnblock(c, 0, 0, 0);
    } else if (c->bstate.btype == BLOCKED_WAIT) {
        addReplyLongLong(c,replicationCountAcksByOffset(c->bstate.reploffset));
    } else if (c->bstate.btype == BLOCKED_WAITAOF) {
        addReplyArrayLen(c,2);
        addReplyLongLong(c,server.fsynced_reploff >= c->bstate.reploffset);
        addReplyLongLong(c,replicationCountAOFAcksByOffset(c->bstate.reploffset));
    } else if (c->bstate.btype == BLOCKED_MODULE) {
        moduleBlockedClientTimedOut(c);
    } else {
        serverPanic(""Unknown btype in replyToBlockedClientTimedOut()."");
    }
}",229.0,246.0,1.0,8.0,18.0,11,4,8,4,1,5,2,2,3,2,,0,3,2,1,1,void
2951,34753,replyToClientsBlockedOnShutdown,1,replyToClientsBlockedOnShutdown,void replyToClientsBlockedOnShutdown (void),blocked.c,"void replyToClientsBlockedOnShutdown(void) {
    if (server.blocked_clients_by_type[BLOCKED_SHUTDOWN] == 0) return;
    listNode *ln;
    listIter li;
    listRewind(server.clients, &li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        if (c->flags & CLIENT_BLOCKED && c->bstate.btype == BLOCKED_SHUTDOWN) {
            addReplyError(c, ""Errors trying to SHUTDOWN. Check logs."");
            unblockClient(c, 1);
        }
    }
}",250.0,262.0,1.0,20.0,13.0,16,9,14,5,1,7,4,5,3,4,,0,4,2,1,1,void
2952,34817,disconnectAllBlockedClients,1,disconnectAllBlockedClients,void disconnectAllBlockedClients (void),blocked.c,"void disconnectAllBlockedClients(void) {
    listNode *ln;
    listIter li;

    listRewind(server.clients,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);

        if (c->flags & CLIENT_BLOCKED) {
            /* POSTPONEd clients are an exception, when they'll be unblocked, the
             * command processing will start from scratch, and the command will
             * be either executed or rejected. (unlike LIST blocked clients for
             * which the command is already in progress in a way. */
            if (c->bstate.btype == BLOCKED_POSTPONE)
                continue;

            unblockClientOnError(c,
                ""-UNBLOCKED force unblock from blocking operation, ""
                ""instance state changed (master -> replica?)"");
            c->flags |= CLIENT_CLOSE_AFTER_REPLY;
        }
    }
}",271.0,293.0,1.0,20.0,23.0,14,7,12,5,1,7,5,7,3,3,,0,5,2,1,1,void
2953,34879,handleClientsBlockedOnKeys,1,handleClientsBlockedOnKeys,void handleClientsBlockedOnKeys (void),blocked.c,"void handleClientsBlockedOnKeys(void) {

    /* In case we are already in the process of unblocking clients we should
     * not make a recursive call, in order to prevent breaking fairness. */
    static int in_handling_blocked_clients = 0;
    if (in_handling_blocked_clients)
        return;
    in_handling_blocked_clients = 1;

    /* This function is called only when also_propagate is in its basic state
     * (i.e. not from call(), module context, etc.) */
    serverAssert(server.also_propagate.numops == 0);

    /* If a command being unblocked causes another command to get unblocked,
     * like a BLMOVE would do, then the new unblocked command will get processed
     * right away rather than wait for later. */
    while(listLength(server.ready_keys) != 0) {
        list *l;

        /* Point server.ready_keys to a fresh list and save the current one
         * locally. This way as we run the old list we are free to call
         * signalKeyAsReady() that may push new elements...",315.0,359.0,1.0,4.0,45.0,28,9,25,5,1,14,4,5,1,8,,0,7,2,1,1,void
2954,34990,blockForKeys,1,blockForKeys,"void blockForKeys (client*,int,robj**,int,mstime_t,int)",blocked.c,"void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, int unblock_on_nokey) {
    dictEntry *db_blocked_entry, *db_blocked_existing_entry, *client_blocked_entry;
    list *l;
    int j;

    c->bstate.timeout = timeout;
    for (j = 0; j < numkeys; j++) {
        /* If the key already exists in the dictionary ignore it. */
        if (!(client_blocked_entry = dictAddRaw(c->bstate.keys,keys[j],NULL))) {
            continue;
        }
        incrRefCount(keys[j]);

        /* And in the other ""side"", to map keys -> clients */
        db_blocked_entry = dictAddRaw(c->db->blocking_keys,keys[j], &db_blocked_existing_entry);

        /* In case key[j] did not have blocking clients yet, we need to create a new list */
        if (db_blocked_entry != NULL) {
            l = listCreate();
            dictSetVal(c->db->blocking_keys, db_blocked_entry, l);
            incrRefCount(keys[j]);
        } else {
            l = dictGetVal(db_blocked_existing_entry);
...",368.0,415.0,1.0,55.0,48.0,36,9,48,13,2,21,8,12,2,12,,0,13,12,6,6,void
2955,35220,getBlockedTypeByType,1,getBlockedTypeByType,blocking_type getBlockedTypeByType (int),blocked.c,"static blocking_type getBlockedTypeByType(int type) {
    switch (type) {
        case OBJ_LIST: return BLOCKED_LIST;
        case OBJ_ZSET: return BLOCKED_ZSET;
        case OBJ_MODULE: return BLOCKED_MODULE;
        case OBJ_STREAM: return BLOCKED_STREAM;
        default: return BLOCKED_NONE;
    }
}",435.0,443.0,1.0,13.0,9.0,0,0,6,6,1,0,2,2,0,0,,0,0,2,1,1,blocking_type
2956,35255,signalKeyAsReadyLogic,1,signalKeyAsReadyLogic,"void signalKeyAsReadyLogic (redisDb*,robj*,int,int)",blocked.c,"static void signalKeyAsReadyLogic(redisDb *db, robj *key, int type, int deleted) {
    readyList *rl;

    /* Quick returns. */
    int btype = getBlockedTypeByType(type);
    if (btype == BLOCKED_NONE) {
        /* The type can never block. */
        return;
    }
    if (!server.blocked_clients_by_type[btype] &&
        !server.blocked_clients_by_type[BLOCKED_MODULE]) {
        /* No clients block on this type. Note: Blocked modules are represented
         * by BLOCKED_MODULE, even if the intention is to wake up by normal
         * types (list, zset, stream), so we need to check that there are no
         * blocked modules before we do a quick return here. */
        return;
    }

    if (deleted) {
        /* Key deleted and no clients blocking for this key? No need to queue it. */
        if (dictFind(db->blocking_keys_unblock_on_nokey,key) == NULL)
            return;
        /* Note: if we made it here it means the key is also present in db->blocking_keys */
    } else {
 ...",452.0,499.0,1.0,1.0,48.0,22,10,27,12,2,11,6,7,2,7,,0,8,8,4,4,void
2957,35495,signalKeyAsReady,1,signalKeyAsReady,"void signalKeyAsReady (redisDb*,robj*,int)",blocked.c,"void signalKeyAsReady(redisDb *db, robj *key, int type) {
    signalKeyAsReadyLogic(db, key, type, 0);
}",547.0,549.0,1.0,1.0,3.0,0,0,3,3,4,1,1,1,0,1,,0,0,6,3,3,void
2958,35507,signalDeletedKeyAsReady,1,signalDeletedKeyAsReady,"void signalDeletedKeyAsReady (redisDb*,robj*,int)",blocked.c,"void signalDeletedKeyAsReady(redisDb *db, robj *key, int type) {
    signalKeyAsReadyLogic(db, key, type, 1);
}",551.0,553.0,1.0,1.0,3.0,0,0,3,3,2,1,1,1,0,1,,0,0,6,3,3,void
2959,35660,blockForReplication,1,blockForReplication,"void blockForReplication (client*,mstime_t,long long,long)",blocked.c,"void blockForReplication(client *c, mstime_t timeout, long long offset, long numreplicas) {
    c->bstate.timeout = timeout;
    c->bstate.reploffset = offset;
    c->bstate.numreplicas = numreplicas;
    listAddNodeHead(server.clients_waiting_acks,c);
    blockClient(c,BLOCKED_WAIT);
}",597.0,603.0,1.0,1.0,7.0,10,3,10,6,1,5,1,1,0,2,,0,3,8,4,4,void
2960,35697,blockForAofFsync,1,blockForAofFsync,"void blockForAofFsync (client*,mstime_t,long long,int,long)",blocked.c,"void blockForAofFsync(client *c, mstime_t timeout, long long offset, int numlocal, long numreplicas) {
    c->bstate.timeout = timeout;
    c->bstate.reploffset = offset;
    c->bstate.numreplicas = numreplicas;
    c->bstate.numlocal = numlocal;
    listAddNodeHead(server.clients_waiting_acks,c);
    blockClient(c,BLOCKED_WAITAOF);
}",606.0,613.0,1.0,1.0,8.0,13,3,12,7,1,6,1,1,0,2,,0,4,10,5,5,void
2961,35742,blockPostponeClient,1,blockPostponeClient,void blockPostponeClient (client*),blocked.c,"void blockPostponeClient(client *c) {
    c->bstate.timeout = 0;
    blockClient(c,BLOCKED_POSTPONE);
    listAddNodeTail(server.postponed_clients, c);
    c->postponed_list_node = listLast(server.postponed_clients);
    /* Mark this client to execute its command */
    c->flags |= CLIENT_PENDING_COMMAND;
}",618.0,625.0,1.0,29.0,8.0,11,4,9,3,2,5,1,1,0,2,,0,3,2,1,1,void
2962,35785,blockClientShutdown,1,blockClientShutdown,void blockClientShutdown (client*),blocked.c,"void blockClientShutdown(client *c) {
    blockClient(c, BLOCKED_SHUTDOWN);
}",628.0,630.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,void
2963,35977,unblockClientOnTimeout,1,unblockClientOnTimeout,void unblockClientOnTimeout (client*),blocked.c,"void unblockClientOnTimeout(client *c) {
    replyToBlockedClientTimedOut(c);
    if (c->flags & CLIENT_PENDING_COMMAND)
        c->flags &= ~CLIENT_PENDING_COMMAND;
    unblockClient(c, 1);
}",705.0,710.0,1.0,19.0,6.0,6,4,4,1,1,4,2,2,1,2,,0,2,2,1,1,void
2964,36008,unblockClientOnError,1,unblockClientOnError,"void unblockClientOnError (client*,char*)",blocked.c,"void unblockClientOnError(client *c, const char *err_str) {
    if (err_str)
        addReplyError(c, err_str);
    updateStatsOnUnblock(c, 0, 0, 1);
    if (c->flags & CLIENT_PENDING_COMMAND)
        c->flags &= ~CLIENT_PENDING_COMMAND;
    unblockClient(c, 1);
}",714.0,721.0,1.0,19.0,8.0,6,4,7,2,1,5,3,3,1,3,,0,2,4,2,2,void
2965,36049,totalNumberOfBlockingKeys,1,totalNumberOfBlockingKeys,"void totalNumberOfBlockingKeys (long unsigned*,long unsigned*)",blocked.c,"void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey) {
    unsigned long bkeys=0, bkeys_on_nokey=0;
    for (int j = 0; j < server.dbnum; j++) {
        bkeys += dictSize(server.db[j].blocking_keys);
        bkeys_on_nokey += dictSize(server.db[j].blocking_keys_unblock_on_nokey);
    }
    if (blocking_keys)
        *blocking_keys = bkeys;
    if (bloking_keys_on_nokey)
        *bloking_keys_on_nokey = bkeys_on_nokey;
}",726.0,736.0,1.0,17.0,11.0,39,8,25,6,1,0,4,4,0,0,,0,0,4,2,2,void
2966,36159,blockedBeforeSleep,1,blockedBeforeSleep,void blockedBeforeSleep (void),blocked.c,"void blockedBeforeSleep(void) {
    /* Handle precise timeouts of blocked clients. */
    handleBlockedClientsTimeout();

    /* Unblock all the clients blocked for synchronous replication
     * in WAIT or WAITAOF. */
    if (listLength(server.clients_waiting_acks))
        processClientsWaitingReplicas();

    /* Try to process blocked clients every once in while.
     *
     * Example: A module calls RM_SignalKeyAsReady from within a timer callback
     * (So we don't visit processCommand() at all).
     *
     * This may unblock clients, so must be done before processUnblockedClients */
    handleClientsBlockedOnKeys();

    /* Check if there are clients unblocked by modules that implement
     * blocking commands. */
    if (moduleCount())
        moduleHandleBlockedClients();

    /* Try to process pending commands for clients that were just unblocked. */
    if (listLength(server.unblocked_clients))
        processUnblockedClients();
}",738.0,763.0,1.0,8.0,26.0,6,2,4,1,1,6,4,4,1,6,,0,1,2,1,1,void
2967,36227,callReplySetSharedData,1,callReplySetSharedData,"void callReplySetSharedData (CallReply*,int,char*,size_t,int)",call_reply.c,"static void callReplySetSharedData(CallReply *rep, int type, const char *proto, size_t proto_len, int extra_flags) {
    rep->type = type;
    rep->proto = proto;
    rep->proto_len = proto_len;
    rep->flags |= extra_flags;
}",67.0,72.0,1.0,1.0,6.0,7,2,8,5,11,4,1,1,0,0,,0,4,10,5,5,void
2968,36256,callReplyNull,1,callReplyNull,"void callReplyNull (void*,char*,size_t)",call_reply.c,"static void callReplyNull(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);
}",74.0,77.0,1.0,32.0,4.0,2,2,5,4,0,1,1,1,0,1,,0,0,6,3,3,void
2969,36279,callReplyNullBulkString,1,callReplyNullBulkString,"void callReplyNullBulkString (void*,char*,size_t)",call_reply.c,"static void callReplyNullBulkString(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, 0);
}",79.0,82.0,1.0,32.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,6,3,3,void
2970,36298,callReplyNullArray,1,callReplyNullArray,"void callReplyNullArray (void*,char*,size_t)",call_reply.c,"static void callReplyNullArray(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, 0);
}",84.0,87.0,1.0,32.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,6,3,3,void
2971,36317,callReplyBulkString,1,callReplyBulkString,"void callReplyBulkString (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyBulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_STRING, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",89.0,94.0,1.0,32.0,6.0,6,3,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
2972,36350,callReplyError,1,callReplyError,"void callReplyError (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyError(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_ERROR, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",96.0,101.0,1.0,32.0,6.0,6,3,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
2973,36383,callReplySimpleStr,1,callReplySimpleStr,"void callReplySimpleStr (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplySimpleStr(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_STRING, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",103.0,108.0,1.0,32.0,6.0,6,3,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
2974,36416,callReplyLong,1,callReplyLong,"void callReplyLong (void*,long long,char*,size_t)",call_reply.c,"static void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);
    rep->val.ll = val;
}",110.0,114.0,1.0,32.0,5.0,4,3,7,5,0,1,1,1,0,1,,0,0,8,4,4,void
2975,36443,callReplyDouble,1,callReplyDouble,"void callReplyDouble (void*,double,char*,size_t)",call_reply.c,"static void callReplyDouble(void *ctx, double val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_DOUBLE, proto, proto_len, REPLY_FLAG_RESP3);
    rep->val.d = val;
}",116.0,120.0,1.0,32.0,5.0,5,4,7,5,0,1,1,1,0,1,,0,0,8,4,4,void
2976,36474,callReplyVerbatimString,1,callReplyVerbatimString,"void callReplyVerbatimString (void*,char*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);
    rep->len = len;
    rep->val.verbatim_str.str = str;
    rep->val.verbatim_str.format = format;
}",122.0,128.0,1.0,32.0,7.0,12,4,11,7,0,2,1,1,0,1,,0,1,12,6,6,void
2977,36523,callReplyBigNumber,1,callReplyBigNumber,"void callReplyBigNumber (void*,char*,size_t,char*,size_t)",call_reply.c,"static void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);
    rep->len = len;
    rep->val.str = str;
}",130.0,135.0,1.0,32.0,6.0,7,4,9,6,0,2,1,1,0,1,,0,1,10,5,5,void
2978,36560,callReplyBool,1,callReplyBool,"void callReplyBool (void*,int,char*,size_t)",call_reply.c,"static void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);
    rep->val.ll = val;
}",137.0,141.0,1.0,32.0,5.0,5,4,7,5,0,1,1,1,0,1,,0,0,8,4,4,void
2979,36591,callReplyParseCollection,1,callReplyParseCollection,"void callReplyParseCollection (ReplyParser*,CallReply*,size_t,char*,size_t)",call_reply.c,"static void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) {
    rep->len = len;
    rep->val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));
    for (size_t i = 0; i < len * elements_per_entry; i += elements_per_entry) {
        for (size_t j = 0 ; j < elements_per_entry ; ++j) {
            rep->val.array[i + j].private_data = rep->private_data;
            parseReply(parser, rep->val.array + i + j);
            rep->val.array[i + j].flags |= REPLY_FLAG_PARSED;
            if (rep->val.array[i + j].flags & REPLY_FLAG_RESP3) {
                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */
                rep->flags |= REPLY_FLAG_RESP3;
            }
        }
    }
    rep->proto = proto;
    rep->proto_len = parser->curr_location - proto;
}",143.0,159.0,1.0,43.0,17.0,45,11,33,8,4,8,4,7,0,2,,0,7,10,5,5,void
2980,36730,callReplyAttribute,1,callReplyAttribute,"void callReplyAttribute (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->attribute = zcalloc(sizeof(CallReply));

    /* Continue parsing the attribute reply */
    rep->attribute->len = len;
    rep->attribute->type = REDISMODULE_REPLY_ATTRIBUTE;
    callReplyParseCollection(parser, rep->attribute, len, proto, 2);
    rep->attribute->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;
    rep->attribute->private_data = rep->private_data;

    /* Continue parsing the reply */
    parseReply(parser, rep);

    /* In this case we need to fix the proto address and len, it should start from the attribute */
    rep->proto = proto;
    rep->proto_len = parser->curr_location - proto;
    rep->flags |= REPLY_FLAG_RESP3;
}",161.0,179.0,1.0,27.0,19.0,28,6,22,6,0,14,1,1,0,3,,0,12,8,4,4,void
2981,36825,callReplyArray,1,callReplyArray,"void callReplyArray (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_ARRAY;
    callReplyParseCollection(parser, rep, len, proto, 1);
}",181.0,185.0,1.0,16.0,5.0,3,2,7,5,0,2,1,1,0,1,,0,1,8,4,4,void
2982,36850,callReplySet,1,callReplySet,"void callReplySet (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_SET;
    callReplyParseCollection(parser, rep, len, proto, 1);
    rep->flags |= REPLY_FLAG_RESP3;
}",187.0,192.0,1.0,16.0,6.0,5,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
2983,36884,callReplyMap,1,callReplyMap,"void callReplyMap (ReplyParser*,void*,size_t,char*)",call_reply.c,"static void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_MAP;
    callReplyParseCollection(parser, rep, len, proto, 2);
    rep->flags |= REPLY_FLAG_RESP3;
}",194.0,199.0,1.0,16.0,6.0,5,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
2984,36918,callReplyParseError,1,callReplyParseError,void callReplyParseError (void*),call_reply.c,"static void callReplyParseError(void *ctx) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_UNKNOWN;
}",201.0,204.0,1.0,16.0,4.0,4,3,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
2985,36935,freeCallReplyInternal,1,freeCallReplyInternal,void freeCallReplyInternal (CallReply*),call_reply.c,"static void freeCallReplyInternal(CallReply *rep) {
    if (rep->type == REDISMODULE_REPLY_ARRAY || rep->type == REDISMODULE_REPLY_SET) {
        for (size_t i = 0 ; i < rep->len ; ++i) {
            freeCallReplyInternal(rep->val.array + i);
        }
        zfree(rep->val.array);
    }

    if (rep->type == REDISMODULE_REPLY_MAP || rep->type == REDISMODULE_REPLY_ATTRIBUTE) {
        for (size_t i = 0 ; i < rep->len ; ++i) {
            freeCallReplyInternal(rep->val.array + i * 2);
            freeCallReplyInternal(rep->val.array + i * 2 + 1);
        }
        zfree(rep->val.array);
    }

    if (rep->attribute) {
        freeCallReplyInternal(rep->attribute);
        zfree(rep->attribute);
    }
}",207.0,227.0,1.0,21.0,21.0,35,8,21,2,1,12,6,8,7,3,,0,9,2,1,1,void
2986,37057,freeCallReply,1,freeCallReply,void freeCallReply (CallReply*),call_reply.c,"void freeCallReply(CallReply *rep) {
    if (!(rep->flags & REPLY_FLAG_ROOT)) {
        return;
    }
    if (rep->flags & REPLY_FLAG_PARSED) {
        if (rep->type == REDISMODULE_REPLY_PROMISE) {
            zfree(rep);
            return;
        }
        freeCallReplyInternal(rep);
    }
    sdsfree(rep->original_proto);
    if (rep->deferred_error_list)
        listRelease(rep->deferred_error_list);
    zfree(rep);
}",232.0,247.0,1.0,23.0,16.0,12,5,9,1,0,11,5,6,4,5,,0,6,2,1,1,void
2987,37115,callReplyCreatePromise,1,callReplyCreatePromise,CallReply callReplyCreatePromise (void*),call_reply.c,"CallReply *callReplyCreatePromise(void *private_data) {
    CallReply *res = zmalloc(sizeof(*res));
    res->type = REDISMODULE_REPLY_PROMISE;
    /* Mark the reply as parsed so there will be not attempt to parse
     * it when calling reply API such as freeCallReply.
     * Also mark the reply as root so freeCallReply will not ignore it. */
    res->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_ROOT;
    res->private_data = private_data;
    return res;
}",249.0,258.0,1.0,16.0,10.0,11,6,7,2,1,4,1,1,0,1,,0,4,2,1,1,CallReply
2988,37224,callReplyParse,1,callReplyParse,void callReplyParse (CallReply*),call_reply.c,"static void callReplyParse(CallReply *rep) {
    if (rep->flags & REPLY_FLAG_PARSED) {
        return;
    }

    ReplyParser parser = {.curr_location = rep->proto, .callbacks = DefaultParserCallbacks};

    parseReply(&parser, rep);
    rep->flags |= REPLY_FLAG_PARSED;
}",281.0,290.0,1.0,21.0,10.0,11,6,9,5,11,5,2,2,1,1,,0,4,2,1,1,void
2989,37268,callReplyType,1,callReplyType,int callReplyType (CallReply*),call_reply.c,"int callReplyType(CallReply *rep) {
    if (!rep) return REDISMODULE_REPLY_UNKNOWN;
    callReplyParse(rep);
    return rep->type;
}",293.0,297.0,1.0,21.0,5.0,3,3,3,1,2,2,2,2,0,1,,0,1,2,1,1,int
2990,37288,callReplyGetString,1,callReplyGetString,"const char* callReplyGetString (CallReply*,size_t*)",call_reply.c,"const char *callReplyGetString(CallReply *rep, size_t *len) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_STRING &&
        rep->type != REDISMODULE_REPLY_ERROR) return NULL;
    if (len) *len = rep->len;
    return rep->val.str;
}",309.0,315.0,1.0,21.0,7.0,10,6,8,3,2,4,3,3,2,1,,0,3,4,2,2,const char*
2991,37330,callReplyGetLongLong,1,callReplyGetLongLong,long long callReplyGetLongLong (CallReply*),call_reply.c,"long long callReplyGetLongLong(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
    return rep->val.ll;
}",320.0,324.0,1.0,21.0,5.0,4,3,4,2,2,2,2,2,1,1,,0,1,2,1,1,long long
2992,37354,callReplyGetDouble,1,callReplyGetDouble,double callReplyGetDouble (CallReply*),call_reply.c,"double callReplyGetDouble(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_DOUBLE) return LLONG_MIN;
    return rep->val.d;
}",329.0,333.0,1.0,21.0,5.0,4,3,4,2,1,2,2,2,1,1,,0,1,2,1,1,double
2993,37378,callReplyGetBool,1,callReplyGetBool,int callReplyGetBool (CallReply*),call_reply.c,"int callReplyGetBool(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_BOOL) return INT_MIN;
    return rep->val.ll;
}",338.0,342.0,1.0,21.0,5.0,4,3,4,2,1,2,2,2,1,1,,0,1,2,1,1,int
2994,37402,callReplyGetLen,1,callReplyGetLen,size_t callReplyGetLen (CallReply*),call_reply.c,"size_t callReplyGetLen(CallReply *rep) {
    callReplyParse(rep);
    switch(rep->type) {
        case REDISMODULE_REPLY_STRING:
        case REDISMODULE_REPLY_ERROR:
        case REDISMODULE_REPLY_ARRAY:
        case REDISMODULE_REPLY_SET:
        case REDISMODULE_REPLY_MAP:
        case REDISMODULE_REPLY_ATTRIBUTE:
            return rep->len;
        default:
            return 0;
    }
}",352.0,365.0,1.0,13.0,14.0,2,1,3,1,1,3,2,2,1,1,,0,2,2,1,1,size_t
2995,37445,callReplyGetCollectionElement,1,callReplyGetCollectionElement,"CallReply callReplyGetCollectionElement (CallReply*,size_t,int)",call_reply.c,"static CallReply *callReplyGetCollectionElement(CallReply *rep, size_t idx, int elements_per_entry) {
    if (idx >= rep->len * elements_per_entry) return NULL; // real len is rep->len * elements_per_entry
    return rep->val.array+idx;
}",367.0,370.0,1.0,1.0,4.0,6,5,6,4,4,1,2,2,1,0,,0,1,6,3,3,CallReply
2996,37471,callReplyGetArrayElement,1,callReplyGetArrayElement,"CallReply callReplyGetArrayElement (CallReply*,size_t)",call_reply.c,"CallReply *callReplyGetArrayElement(CallReply *rep, size_t idx) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_ARRAY) return NULL;
    return callReplyGetCollectionElement(rep, idx, 1);
}",378.0,382.0,1.0,21.0,5.0,2,2,5,3,1,3,2,2,1,2,,0,1,4,2,2,CallReply
2997,37495,callReplyGetSetElement,1,callReplyGetSetElement,"CallReply callReplyGetSetElement (CallReply*,size_t)",call_reply.c,"CallReply *callReplyGetSetElement(CallReply *rep, size_t idx) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_SET) return NULL;
    return callReplyGetCollectionElement(rep, idx, 1);
}",390.0,394.0,1.0,21.0,5.0,2,2,5,3,1,3,2,2,1,2,,0,1,4,2,2,CallReply
2998,37519,callReplyGetMapElementInternal,1,callReplyGetMapElementInternal,"int callReplyGetMapElementInternal (CallReply*,size_t,CallReply**,CallReply**,int)",call_reply.c,"static int callReplyGetMapElementInternal(CallReply *rep, size_t idx, CallReply **key, CallReply **val, int type) {
    callReplyParse(rep);
    if (rep->type != type) return C_ERR;
    if (idx >= rep->len) return C_ERR;
    if (key) *key = callReplyGetCollectionElement(rep, idx * 2, 2);
    if (val) *val = callReplyGetCollectionElement(rep, idx * 2 + 1, 2);
    return C_OK;
}",396.0,403.0,1.0,34.0,8.0,13,8,13,5,2,5,5,5,2,3,,0,4,10,5,5,int
2999,37584,callReplyGetMapElement,1,callReplyGetMapElement,"int callReplyGetMapElement (CallReply*,size_t,CallReply**,CallReply**)",call_reply.c,"int callReplyGetMapElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val) {
    return callReplyGetMapElementInternal(rep, idx, key, val, REDISMODULE_REPLY_MAP);
}",417.0,419.0,1.0,62.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
3000,37601,callReplyGetAttribute,1,callReplyGetAttribute,CallReply callReplyGetAttribute (CallReply*),call_reply.c,"CallReply *callReplyGetAttribute(CallReply *rep) {
    return rep->attribute;
}",426.0,428.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,CallReply
3001,37610,callReplyGetAttributeElement,1,callReplyGetAttributeElement,"int callReplyGetAttributeElement (CallReply*,size_t,CallReply**,CallReply**)",call_reply.c,"int callReplyGetAttributeElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val) {
    return callReplyGetMapElementInternal(rep, idx, key, val, REDISMODULE_REPLY_MAP);
}",442.0,444.0,1.0,62.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
3002,37627,callReplyGetBigNumber,1,callReplyGetBigNumber,"const char* callReplyGetBigNumber (CallReply*,size_t*)",call_reply.c,"const char *callReplyGetBigNumber(CallReply *rep, size_t *len) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_BIG_NUMBER) return NULL;
    *len = rep->len;
    return rep->val.str;
}",458.0,463.0,1.0,21.0,6.0,7,5,6,3,1,3,2,2,1,1,,0,2,4,2,2,const char*
3003,37658,callReplyGetVerbatim,1,callReplyGetVerbatim,"const char* callReplyGetVerbatim (CallReply*,size_t*,char**)",call_reply.c,"const char *callReplyGetVerbatim(CallReply *rep, size_t *len, const char **format){
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_VERBATIM_STRING) return NULL;
    *len = rep->len;
    if (format) *format = rep->val.verbatim_str.format;
    return rep->val.verbatim_str.str;
}",479.0,485.0,1.0,21.0,7.0,13,5,9,4,1,3,3,3,1,1,,0,2,6,3,3,const char*
3004,37705,callReplyGetProto,1,callReplyGetProto,"const char* callReplyGetProto (CallReply*,size_t*)",call_reply.c,"const char *callReplyGetProto(CallReply *rep, size_t *proto_len) {
    *proto_len = rep->proto_len;
    return rep->proto;
}",492.0,495.0,1.0,1.0,4.0,4,3,3,2,2,2,1,1,0,0,,0,2,4,2,2,const char*
3005,37721,callReplyGetPrivateData,1,callReplyGetPrivateData,void* callReplyGetPrivateData (CallReply*),call_reply.c,"void *callReplyGetPrivateData(CallReply *rep) {
    return rep->private_data;
}",499.0,501.0,1.0,1.0,3.0,1,1,1,1,3,1,1,1,0,0,,0,1,2,1,1,void*
3006,37730,callReplyIsResp3,1,callReplyIsResp3,int callReplyIsResp3 (CallReply*),call_reply.c,"int callReplyIsResp3(CallReply *rep) {
    return rep->flags & REPLY_FLAG_RESP3;
}",504.0,506.0,1.0,24.0,3.0,3,3,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
3007,37745,callReplyDeferredErrorList,1,callReplyDeferredErrorList,list callReplyDeferredErrorList (CallReply*),call_reply.c,"list *callReplyDeferredErrorList(CallReply *rep) {
    return rep->deferred_error_list;
}",509.0,511.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,list
3008,37754,callReplyCreate,1,callReplyCreate,"CallReply callReplyCreate (sds,list*,void*)",call_reply.c,"CallReply *callReplyCreate(sds reply, list *deferred_error_list, void *private_data) {
    CallReply *res = zmalloc(sizeof(*res));
    res->flags = REPLY_FLAG_ROOT;
    res->original_proto = reply;
    res->proto = reply;
    res->proto_len = sdslen(reply);
    res->private_data = private_data;
    res->attribute = NULL;
    res->deferred_error_list = deferred_error_list;
    return res;
}",532.0,542.0,1.0,17.0,11.0,18,5,16,5,2,9,1,1,0,2,,0,9,6,3,3,CallReply
3009,37810,callReplyCreateError,1,callReplyCreateError,"CallReply callReplyCreateError (sds,void*)",call_reply.c,"CallReply *callReplyCreateError(sds reply, void *private_data) {
    sds err_buff = reply;
    if (err_buff[0] != '-') {
        err_buff = sdscatfmt(sdsempty(), ""-ERR %S\r\n"", reply);
        sdsfree(reply);
    }
    list *deferred_error_list = listCreate();
    listSetFreeMethod(deferred_error_list, (void (*)(void*))sdsfree);
    listAddNodeTail(deferred_error_list, sdsnew(err_buff));
    return callReplyCreate(err_buff, deferred_error_list, private_data);
}",550.0,560.0,1.0,4.0,11.0,8,5,15,5,12,7,2,2,0,7,,0,4,4,2,2,CallReply
3010,37867,RedisModuleOnUnblocked,1,RedisModuleOnUnblocked,"void RedisModuleOnUnblocked (void*,CallReply*,void*)",call_reply.h,"typedef void (*RedisModuleOnUnblocked)(void *ctx, CallReply *reply, void *private_data);",36.0,36.0,14.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
3011,38013,openChildInfoPipe,1,openChildInfoPipe,void openChildInfoPipe (void),childinfo.c,"void openChildInfoPipe(void) {
    if (anetPipe(server.child_info_pipe, O_NONBLOCK, 0) == -1) {
        /* On error our two file descriptors should be still set to -1,
         * but we call anyway closeChildInfoPipe() since can't hurt. */
        closeChildInfoPipe();
    } else {
        server.child_info_nread = 0;
    }
}",45.0,53.0,1.0,1.0,9.0,3,3,2,2,1,2,2,2,1,2,,0,1,2,1,1,void
3012,38037,closeChildInfoPipe,1,closeChildInfoPipe,void closeChildInfoPipe (void),childinfo.c,"void closeChildInfoPipe(void) {
    if (server.child_info_pipe[0] != -1 ||
        server.child_info_pipe[1] != -1)
    {
        close(server.child_info_pipe[0]);
        close(server.child_info_pipe[1]);
        server.child_info_pipe[0] = -1;
        server.child_info_pipe[1] = -1;
        server.child_info_nread = 0;
    }
}",56.0,66.0,1.0,1.0,11.0,23,6,7,1,2,0,2,2,0,0,,0,0,2,1,1,void
3013,38094,sendChildInfoGeneric,1,sendChildInfoGeneric,"void sendChildInfoGeneric (childInfoType,size_t,double,char*)",childinfo.c,"void sendChildInfoGeneric(childInfoType info_type, size_t keys, double progress, char *pname) {
    if (server.child_info_pipe[1] == -1) return;

    static monotime cow_updated = 0;
    static uint64_t cow_update_cost = 0;
    static size_t cow = 0;
    static size_t peak_cow = 0;
    static size_t update_count = 0;
    static unsigned long long sum_cow = 0;

    child_info_data data = {0}; /* zero everything, including padding to satisfy valgrind */

    /* When called to report current info, we need to throttle down CoW updates as they
     * can be very expensive. To do that, we measure the time it takes to get a reading
     * and schedule the next reading to happen not before time*CHILD_COW_COST_FACTOR
     * passes. */

    monotime now = getMonotonicUs();
    if (info_type != CHILD_INFO_TYPE_CURRENT_INFO ||
        !cow_updated ||
        now - cow_updated > cow_update_cost * CHILD_COW_DUTY_CYCLE)
    {
        cow = zmalloc_get_private_dirty(-1);
        cow_updated = getMo...",69.0,119.0,1.0,46.0,51.0,60,21,58,17,3,11,6,8,0,6,,0,8,8,4,4,void
3014,38302,updateChildInfo,1,updateChildInfo,"void updateChildInfo (childInfoType,size_t,monotime,size_t,double)",childinfo.c,"void updateChildInfo(childInfoType information_type, size_t cow, monotime cow_updated, size_t keys, double progress) {
    if (cow > server.stat_current_cow_peak) server.stat_current_cow_peak = cow;

    if (information_type == CHILD_INFO_TYPE_CURRENT_INFO) {
        server.stat_current_cow_bytes = cow;
        server.stat_current_cow_updated = cow_updated;
        server.stat_current_save_keys_processed = keys;
        if (progress != -1) server.stat_module_progress = progress;
    } else if (information_type == CHILD_INFO_TYPE_AOF_COW_SIZE) {
        server.stat_aof_cow_bytes = server.stat_current_cow_peak;
    } else if (information_type == CHILD_INFO_TYPE_RDB_COW_SIZE) {
        server.stat_rdb_cow_bytes = server.stat_current_cow_peak;
    } else if (information_type == CHILD_INFO_TYPE_MODULE_COW_SIZE) {
        server.stat_module_cow_bytes = server.stat_current_cow_peak;
    }
}",122.0,137.0,1.0,1.0,16.0,15,6,15,7,1,0,4,5,0,0,,0,0,10,5,5,void
3015,38396,readChildInfo,1,readChildInfo,"int readChildInfo (childInfoType*,size_t*,monotime*,size_t*,double*)",childinfo.c,"int readChildInfo(childInfoType *information_type, size_t *cow, monotime *cow_updated, size_t *keys, double* progress) {
    /* We are using here a static buffer in combination with the server.child_info_nread to handle short reads */
    static child_info_data buffer;
    ssize_t wlen = sizeof(buffer);

    /* Do not overlap */
    if (server.child_info_nread == wlen) server.child_info_nread = 0;

    int nread = read(server.child_info_pipe[0], (char *)&buffer + server.child_info_nread, wlen - server.child_info_nread);
    if (nread > 0) {
        server.child_info_nread += nread;
    }

    /* We have complete child info */
    if (server.child_info_nread == wlen) {
        *information_type = buffer.information_type;
        *cow = buffer.cow;
        *cow_updated = buffer.cow_updated;
        *keys = buffer.keys;
        *progress = buffer.progress;
        return 1;
    } else {
        return 0;
    }
}",143.0,167.0,1.0,1.0,25.0,35,12,26,9,1,5,4,4,0,0,,0,5,10,5,5,int
3016,38498,receiveChildInfo,1,receiveChildInfo,void receiveChildInfo (void),childinfo.c,"void receiveChildInfo(void) {
    if (server.child_info_pipe[0] == -1) return;

    size_t cow;
    monotime cow_updated;
    size_t keys;
    double progress;
    childInfoType information_type;

    /* Drain the pipe and update child info so that we get the final message. */
    while (readChildInfo(&information_type, &cow, &cow_updated, &keys, &progress)) {
        updateChildInfo(information_type, cow, cow_updated, keys, progress);
    }
}",170.0,183.0,1.0,1.0,14.0,9,5,11,6,1,2,3,3,1,2,,0,1,2,1,1,void
3017,38621,cliSecureConnection,1,cliSecureConnection,"int cliSecureConnection (redisContext*,cliSSLconfig,char**)",cli_common.c,"int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err) {
#ifdef USE_OPENSSL
    static SSL_CTX *ssl_ctx = NULL;

    if (!ssl_ctx) {
        ssl_ctx = SSL_CTX_new(SSLv23_client_method());
        if (!ssl_ctx) {
            *err = ""Failed to create SSL_CTX"";
            goto error;
        }
        SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
        SSL_CTX_set_verify(ssl_ctx, config.skip_cert_verify ? SSL_VERIFY_NONE : SSL_VERIFY_PEER, NULL);

        if (config.cacert || config.cacertdir) {
            if (!SSL_CTX_load_verify_locations(ssl_ctx, config.cacert, config.cacertdir)) {
                *err = ""Invalid CA Certificate File/Directory"";
                goto error;
            }
        } else {
            if (!SSL_CTX_set_default_verify_paths(ssl_ctx)) {
                *err = ""Failed to use default CA paths"";
                goto error;
            }
        }

        if (config.cert && !SSL_CTX_use_certificate_chain_file(ss...",54.0,124.0,1.0,1.0,71.0,3,1,4,4,2,0,1,1,0,0,,0,0,6,3,3,int
3018,38639,cliWriteConn,1,cliWriteConn,"ssize_t cliWriteConn (redisContext*,char*,size_t)",cli_common.c,"ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len)
{
    int done = 0;

    /* Append data to buffer which is *usually* expected to be empty
     * but we don't assume that, and write.
     */
    c->obuf = sdscatlen(c->obuf, buf, buf_len);
    if (redisBufferWrite(c, &done) == REDIS_ERR) {
        if (!(c->flags & REDIS_BLOCK))
            errno = EAGAIN;

        /* On error, we assume nothing was written and we roll back the
         * buffer to its original state.
         */
        if (sdslen(c->obuf) > buf_len)
            sdsrange(c->obuf, 0, -(buf_len+1));
        else
            sdsclear(c->obuf);

        return -1;
    }

    /* If we're done, free up everything. We may have written more than
     * buf_len (if c->obuf was not initially empty) but we don't have to
     * tell.
     */
    if (done) {
        sdsclear(c->obuf);
        return buf_len;
    }

    /* Write was successful but we have some leftovers which we should
     * remove from the ...",140.0,190.0,1.0,1.0,51.0,26,10,28,9,2,8,6,8,2,8,,0,4,6,3,3,ssize_t
3019,38748,cliSecureInit,1,cliSecureInit,int cliSecureInit (void),cli_common.c,"int cliSecureInit(void)
{
#ifdef USE_OPENSSL
    ERR_load_crypto_strings();
    SSL_load_error_strings();
    SSL_library_init();
#endif
    return REDIS_OK;
}",194.0,202.0,1.0,1.0,9.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
3020,38755,readArgFromStdin,1,readArgFromStdin,sds readArgFromStdin (void),cli_common.c,"sds readArgFromStdin(void) {
    char buf[1024];
    sds arg = sdsempty();

    while(1) {
        int nread = read(fileno(stdin),buf,1024);

        if (nread == 0) break;
        else if (nread == -1) {
            perror(""Reading from standard input"");
            exit(1);
        }
        arg = sdscatlen(arg,buf,nread);
    }
    return arg;
}",205.0,220.0,1.0,1.0,16.0,4,2,10,4,2,2,4,4,0,2,,0,2,2,1,1,sds
3021,38802,getSdsArrayFromArgv,1,getSdsArrayFromArgv,"sds getSdsArrayFromArgv (int,char**,int)",cli_common.c,"sds *getSdsArrayFromArgv(int argc,char **argv, int quoted) {
    sds *res = sds_malloc(sizeof(sds) * argc);

    for (int j = 0; j < argc; j++) {
        if (quoted) {
            sds unquoted = unquoteCString(argv[j]);
            if (!unquoted) {
                while (--j >= 0) sdsfree(res[j]);
                sds_free(res);
                return NULL;
            }
            res[j] = unquoted;
        } else {
            res[j] = sdsnew(argv[j]);
        }
    }

    return res;
}",229.0,247.0,1.0,1.0,19.0,12,8,18,8,2,3,5,11,0,3,,0,2,6,3,3,sds
3022,38873,unquoteCString,1,unquoteCString,sds unquoteCString (char*),cli_common.c,"sds unquoteCString(char *str) {
    int count;
    sds *unquoted = sdssplitargs(str, &count);
    sds res = NULL;

    if (unquoted && count == 1) {
        res = unquoted[0];
        unquoted[0] = NULL;
    }

    if (unquoted)
        sdsfreesplitres(unquoted, count);

    return res;
}",250.0,264.0,1.0,1.0,15.0,9,5,15,5,1,2,3,3,0,2,,0,1,2,1,1,sds
3023,38915,percentDecode,1,percentDecode,"sds percentDecode (char*,size_t)",cli_common.c,"static sds percentDecode(const char *pe, size_t len) {
    const char *end = pe + len;
    sds ret = sdsempty();
    const char *curr = pe;

    while (curr < end) {
        if (*curr == '%') {
            if ((end - curr) < 2) {
                fprintf(stderr, ""Incomplete URI encoding\n"");
                exit(1);
            }

            char h = tolower(*(++curr));
            char l = tolower(*(++curr));
            if (!isHexChar(h) || !isHexChar(l)) {
                fprintf(stderr, ""Illegal character in URI encoding\n"");
                exit(1);
            }
            char c = decodeHex(h, l);
            ret = sdscatlen(ret, &c, 1);
            curr++;
        } else {
            ret = sdscatlen(ret, curr++, 1);
        }
    }

    return ret;
}",272.0,299.0,1.0,17.0,28.0,40,16,39,9,2,2,5,10,0,2,,0,2,4,2,2,sds
3024,39060,parseRedisUri,1,parseRedisUri,"void parseRedisUri (char*,char*,cliConnInfo*,int*)",cli_common.c,"void parseRedisUri(const char *uri, const char* tool_name, cliConnInfo *connInfo, int *tls_flag) {
#ifdef USE_OPENSSL
    UNUSED(tool_name);
#else
    UNUSED(tls_flag);
#endif

    const char *scheme = ""redis://"";
    const char *tlsscheme = ""rediss://"";
    const char *curr = uri;
    const char *end = uri + strlen(uri);
    const char *userinfo, *username, *port, *host, *path;

    /* URI must start with a valid scheme. */
    if (!strncasecmp(tlsscheme, curr, strlen(tlsscheme))) {
#ifdef USE_OPENSSL
        *tls_flag = 1;
        curr += strlen(tlsscheme);
#else
        fprintf(stderr,""rediss:// is only supported when %s is compiled with OpenSSL\n"", tool_name);
        exit(1);
#endif
    } else if (!strncasecmp(scheme, curr, strlen(scheme))) {
        curr += strlen(scheme);
    } else {
        fprintf(stderr,""Invalid URI scheme\n"");
        exit(1);
    }
    if (curr == end) return;

    /* Extract user info. */
    if ((userinfo = strchr(curr,'@'))) {
        if ((username =...",309.0,377.0,1.0,4.0,69.0,52,13,65,14,0,10,11,18,0,4,,0,9,8,4,4,void
3025,39304,freeCliConnInfo,1,freeCliConnInfo,void freeCliConnInfo (cliConnInfo),cli_common.c,"void freeCliConnInfo(cliConnInfo connInfo){
    if (connInfo.hostip) sdsfree(connInfo.hostip);
    if (connInfo.auth) sdsfree(connInfo.auth);
    if (connInfo.user) sdsfree(connInfo.user);
}",379.0,383.0,1.0,1.0,5.0,6,1,6,1,1,9,4,4,3,3,,0,6,2,1,1,void
3026,39336,escapeJsonString,1,escapeJsonString,"sds escapeJsonString (sds,char*,size_t)",cli_common.c,"sds escapeJsonString(sds s, const char *p, size_t len) {
    s = sdscatlen(s,""\"""",1);
    while(len--) {
        switch(*p) {
        case '\\':
        case '""':
            s = sdscatprintf(s,""\\%c"",*p);
            break;
        case '\n': s = sdscatlen(s,""\\n"",2); break;
        case '\f': s = sdscatlen(s,""\\f"",2); break;
        case '\r': s = sdscatlen(s,""\\r"",2); break;
        case '\t': s = sdscatlen(s,""\\t"",2); break;
        case '\b': s = sdscatlen(s,""\\b"",2); break;
        default:
            s = sdscatprintf(s,*(unsigned char *)p <= 0x1f ? ""\\u%04x"" : ""%c"",*p);
        }
        p++;
    }
    return sdscatlen(s,""\"""",1);
}",389.0,408.0,1.0,1.0,20.0,17,7,23,3,1,9,9,4,0,9,,0,8,6,3,3,sds
3027,39554,createClusterNode,1,createClusterNode,"clusterNode* createClusterNode (char*,int)",redis-benchmark.c,"static clusterNode *createClusterNode(char *ip, int port) {
    clusterNode *node = zmalloc(sizeof(*node));
    if (!node) return NULL;
    node->ip = ip;
    node->port = port;
    node->name = NULL;
    node->flags = 0;
    node->replicate = NULL;
    node->replicas_count = 0;
    node->slots = zmalloc(CLUSTER_SLOTS * sizeof(int));
    node->slots_count = 0;
    node->current_slot_index = 0;
    node->updated_slots = NULL;
    node->updated_slots_count = 0;
    node->migrating = NULL;
    node->importing = NULL;
    node->migrating_count = 0;
    node->importing_count = 0;
    node->redis_config = NULL;
    return node;
}",1056.0,1076.0,1.0,26.0,21.0,0,0,0,0,7,0,1,1,0,0,,0,0,4,2,2,clusterNode
3028,39560,clusterAddNode,1,clusterAddNode,void clusterAddNode (clusterNode*),cluster.c,"void clusterAddNode(clusterNode *node) {
    int retval;

    retval = dictAdd(server.cluster->nodes,
            sdsnewlen(node->name,CLUSTER_NAMELEN), node);
    serverAssert(retval == DICT_OK);
}",1571.0,1577.0,1.0,33.0,7.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,void
3029,39565,clusterAcceptHandler,1,clusterAcceptHandler,"void clusterAcceptHandler (aeEventLoop*,int,void*,int)",cluster.c,"void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd;
    int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    int require_auth = TLS_CLIENT_AUTH_YES;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    /* If the server is starting up, don't accept cluster connections:
     * UPDATE messages may interact with the database content. */
    if (server.masterhost == NULL && server.loading) return;

    while(max--) {
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_VERBOSE,
                    ""Error accepting cluster node: %s"", server.neterr);
            return;
        }

        connection *conn = connCreateAccepted(connTypeOfCluster(), cfd, &require_auth);

        /* Make sure connection is not in an error state */
        if (connGetState(conn) != CONN_STATE_ACCEPTING) {
            se...",1263.0,1313.0,1.0,14.0,51.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
3030,39573,clusterReadHandler,1,clusterReadHandler,void clusterReadHandler (connection*),cluster.c,"void clusterReadHandler(connection *conn) {
    clusterMsg buf[1];
    ssize_t nread;
    clusterMsg *hdr;
    clusterLink *link = connGetPrivateData(conn);
    unsigned int readlen, rcvbuflen;

    while(1) { /* Read as long as there is data to read. */
        rcvbuflen = link->rcvbuf_len;
        if (rcvbuflen < 8) {
            /* First, obtain the first 8 bytes to get the full message
             * length. */
            readlen = 8 - rcvbuflen;
        } else {
            /* Finally read the full message. */
            hdr = (clusterMsg*) link->rcvbuf;
            if (rcvbuflen == 8) {
                /* Perform some sanity check on the message signature
                 * and length. */
                if (memcmp(hdr->sig,""RCmb"",4) != 0 ||
                    ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)
                {
                    char ip[NET_IP_STR_LEN];
                    int port;
                    if (connAddrPeerName(conn, ip, sizeof(ip), &port) == -1) {
    ...",3320.0,3402.0,1.0,41.0,83.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3031,39578,clusterSendPing,1,clusterSendPing,"void clusterSendPing (clusterLink*,int)",cluster.c,"void clusterSendPing(clusterLink *link, int type) {
    static unsigned long long cluster_pings_sent = 0;
    cluster_pings_sent++;
    int gossipcount = 0; /* Number of gossip sections added so far. */
    int wanted; /* Number of gossip sections we want to append if possible. */
    int estlen; /* Upper bound on estimated packet length */
    /* freshnodes is the max number of nodes we can hope to append at all:
     * nodes available minus two (ourself and the node we are sending the
     * message to). However practically there may be less valid nodes since
     * nodes in handshake state, disconnected, are not considered. */
    int freshnodes = dictSize(server.cluster->nodes)-2;

    /* How many gossip sections we want to add? 1/10 of the number of nodes
     * and anyway at least 3. Why 1/10?
     *
     * If we have N masters, with N/10 entries, and we consider that in
     * node_timeout we exchange with each other node at least 4 packets
     * (we ping in the worst case i...",3539.0,3667.0,1.0,21.0,129.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,void
3032,39584,clusterSendFail,1,clusterSendFail,void clusterSendFail (char*),cluster.c,"void clusterSendFail(char *nodename) {
    uint32_t msglen = sizeof(clusterMsg) - sizeof(union clusterMsgData)
        + sizeof(clusterMsgDataFail);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAIL, msglen);

    clusterMsg *hdr = &msgblock->msg;
    memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);

    clusterBroadcastMessage(msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3744.0,3754.0,1.0,62.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3033,39589,clusterSendFailoverAuthIfNeeded,1,clusterSendFailoverAuthIfNeeded,"void clusterSendFailoverAuthIfNeeded (clusterNode*,clusterMsg*)",cluster.c,"void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
    clusterNode *master = node->slaveof;
    uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);
    uint64_t requestConfigEpoch = ntohu64(request->configEpoch);
    unsigned char *claimed_slots = request->myslots;
    int force_ack = request->mflags[0] & CLUSTERMSG_FLAG0_FORCEACK;
    int j;

    /* IF we are not a master serving at least 1 slot, we don't have the
     * right to vote, as the cluster size in Redis Cluster is the number
     * of masters serving at least one slot, and quorum is the cluster
     * size + 1 */
    if (nodeIsSlave(myself) || myself->numslots == 0) return;

    /* Request epoch must be >= our currentEpoch.
     * Note that it is impossible for it to actually be greater since
     * our currentEpoch was updated as a side effect of receiving this
     * request, if the request epoch was greater. */
    if (requestCurrentEpoch < server.cluster->currentEpoch) {
       ...",3902.0,4003.0,1.0,35.0,102.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3034,39595,clusterUpdateState,1,clusterUpdateState,void clusterUpdateState (void),cluster.c,"void clusterUpdateState(void) {
    int j, new_state;
    int reachable_masters = 0;
    static mstime_t among_minority_time;
    static mstime_t first_call_time = 0;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_UPDATE_STATE;

    /* If this is a master node, wait some time before turning the state
     * into OK, since it is not a good idea to rejoin the cluster as a writable
     * master, after a reboot, without giving the cluster a chance to
     * reconfigure this node. Note that the delay is calculated starting from
     * the first call to this function and not since the server start, in order
     * to not count the DB loading time. */
    if (first_call_time == 0) first_call_time = mstime();
    if (nodeIsMaster(myself) &&
        server.cluster->state == CLUSTER_FAIL &&
        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;

    /* Start assuming the state is OK. We'll turn it into FAIL if there
     * are the right conditions. */
    new_state = C...",4971.0,5066.0,1.0,42.0,96.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
3035,39600,clusterNodeGetSlotBit,1,clusterNodeGetSlotBit,"int clusterNodeGetSlotBit (clusterNode*,int)",cluster.c,"int clusterNodeGetSlotBit(clusterNode *n, int slot) {
    return bitmapTestBit(n->slots,slot);
}",4901.0,4903.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3036,39606,clusterGetNodesInMyShard,1,clusterGetNodesInMyShard,list* clusterGetNodesInMyShard (clusterNode*),cluster.c,"list *clusterGetNodesInMyShard(clusterNode *node) {
    sds s = sdsnewlen(node->shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards,s);
    sdsfree(s);
    return (de != NULL) ? dictGetVal(de) : NULL;
}",1651.0,1656.0,1.0,38.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,list
3037,39611,clusterNodeAddSlave,1,clusterNodeAddSlave,"int clusterNodeAddSlave (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
    int j;

    /* If it's already a slave, don't add it again. */
    for (j = 0; j < master->numslaves; j++)
        if (master->slaves[j] == slave) return C_ERR;
    master->slaves = zrealloc(master->slaves,
        sizeof(clusterNode*)*(master->numslaves+1));
    master->slaves[master->numslaves] = slave;
    master->numslaves++;
    master->flags |= CLUSTER_NODE_MIGRATE_TO;
    return C_OK;
}",1520.0,1532.0,1.0,47.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3038,39617,clusterAddSlot,1,clusterAddSlot,"int clusterAddSlot (clusterNode*,int)",cluster.c,"int clusterAddSlot(clusterNode *n, int slot) {
    if (server.cluster->slots[slot]) return C_ERR;
    clusterNodeSetSlotBit(n,slot);
    server.cluster->slots[slot] = n;
    return C_OK;
}",4909.0,4914.0,1.0,44.0,6.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
3039,39623,clusterDelSlot,1,clusterDelSlot,int clusterDelSlot (int),cluster.c,"int clusterDelSlot(int slot) {
    clusterNode *n = server.cluster->slots[slot];

    if (!n) return C_ERR;

    /* Cleanup the channels in master/replica as part of slot deletion. */
    list *nodes_for_slot = clusterGetNodesInMyShard(n);
    serverAssert(nodes_for_slot != NULL);
    listNode *ln = listSearchKey(nodes_for_slot, myself);
    if (ln != NULL) {
        removeChannelsInSlot(slot);
    }
    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
    server.cluster->slots[slot] = NULL;
    return C_OK;
}",4919.0,4934.0,1.0,19.0,16.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
3040,39628,clusterDelNodeSlots,1,clusterDelNodeSlots,int clusterDelNodeSlots (clusterNode*),cluster.c,"int clusterDelNodeSlots(clusterNode *node) {
    int deleted = 0, j;

    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (clusterNodeGetSlotBit(node,j)) {
            clusterDelSlot(j);
            deleted++;
        }
    }
    return deleted;
}",4938.0,4948.0,1.0,20.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3041,39633,clusterNodeSetSlotBit,1,clusterNodeSetSlotBit,"int clusterNodeSetSlotBit (clusterNode*,int)",cluster.c,"int clusterNodeSetSlotBit(clusterNode *n, int slot) {
    int old = bitmapTestBit(n->slots,slot);
    if (!old) {
        bitmapSetBit(n->slots,slot);
        n->numslots++;
        /* When a master gets its first slot, even if it has no slaves,
         * it gets flagged with MIGRATE_TO, that is, the master is a valid
         * target for replicas migration, if and only if at least one of
         * the other masters has slaves right now.
         *
         * Normally masters are valid targets of replica migration if:
         * 1. The used to have slaves (but no longer have).
         * 2. They are slaves failing over a master that used to have slaves.
         *
         * However new masters with slots assigned are considered valid
         * migration targets if the rest of the cluster is not a slave-less.
         *
         * See https://github.com/redis/redis/issues/3043 for more info. */
        if (n->numslots == 1 && clusterMastersHaveSlaves())
            n->flags |= C...",4866.0,4888.0,1.0,24.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3042,39639,clusterSetMaster,1,clusterSetMaster,void clusterSetMaster (clusterNode*),cluster.c,"void clusterSetMaster(clusterNode *n) {
    serverAssert(n != myself);
    serverAssert(myself->numslots == 0);

    if (nodeIsMaster(myself)) {
        myself->flags &= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
        myself->flags |= CLUSTER_NODE_SLAVE;
        clusterCloseAllSlots();
    } else {
        if (myself->slaveof)
            clusterNodeRemoveSlave(myself->slaveof,myself);
    }
    myself->slaveof = n;
    updateShardId(myself, n->shard_id);
    clusterNodeAddSlave(n,myself);
    replicationSetMaster(n->ip, getNodeDefaultReplicationPort(n));
    resetManualFailover();
}",5145.0,5162.0,1.0,4.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3043,39644,clusterHandleSlaveFailover,1,clusterHandleSlaveFailover,void clusterHandleSlaveFailover (void),cluster.c,"void clusterHandleSlaveFailover(void) {
    mstime_t data_age;
    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
    int needed_quorum = (server.cluster->size / 2) + 1;
    int manual_failover = server.cluster->mf_end != 0 &&
                          server.cluster->mf_can_start;
    mstime_t auth_timeout, auth_retry_time;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;

    /* Compute the failover timeout (the max time we have to send votes
     * and wait for replies), and the failover retry time (the time to wait
     * before trying to get voted again).
     *
     * Timeout is MAX(NODE_TIMEOUT*2,2000) milliseconds.
     * Retry is two times the Timeout.
     */
    auth_timeout = server.cluster_node_timeout*2;
    if (auth_timeout < 2000) auth_timeout = 2000;
    auth_retry_time = auth_timeout*2;

    /* Pre conditions to run the function, that must be met both in case
     * of an automatic or manual failover:
     * 1) We are a s...",4149.0,4318.0,1.0,42.0,170.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3044,39649,clusterHandleSlaveMigration,1,clusterHandleSlaveMigration,void clusterHandleSlaveMigration (int),cluster.c,"void clusterHandleSlaveMigration(int max_slaves) {
    int j, okslaves = 0;
    clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
    dictIterator *di;
    dictEntry *de;

    /* Step 1: Don't migrate if the cluster state is not ok. */
    if (server.cluster->state != CLUSTER_OK) return;

    /* Step 2: Don't migrate if my master will not be left with at least
     *         'migration-barrier' slaves after my migration. */
    if (mymaster == NULL) return;
    for (j = 0; j < mymaster->numslaves; j++)
        if (!nodeFailed(mymaster->slaves[j]) &&
            !nodeTimedOut(mymaster->slaves[j])) okslaves++;
    if (okslaves <= server.cluster_migration_barrier) return;

    /* Step 3: Identify a candidate for migration, and check if among the
     * masters with the greatest number of ok slaves, I'm the one with the
     * smallest node ID (the ""candidate slave"").
     *
     * Note: this means that eventually a replica migration will occur
     * since sla...",4347.0,4430.0,1.0,33.0,84.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3045,39654,bitmapTestBit,1,bitmapTestBit,"int bitmapTestBit (unsigned char*,int)",cluster.c,"int bitmapTestBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    return (bitmap[byte] & (1<<bit)) != 0;
}",4828.0,4832.0,1.0,1.0,5.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int
3046,39660,bitmapSetBit,1,bitmapSetBit,"void bitmapSetBit (unsigned char*,int)",cluster.c,"void bitmapSetBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    bitmap[byte] |= 1<<bit;
}",4835.0,4839.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3047,39666,bitmapClearBit,1,bitmapClearBit,"void bitmapClearBit (unsigned char*,int)",cluster.c,"void bitmapClearBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    bitmap[byte] &= ~(1<<bit);
}",4842.0,4846.0,1.0,1.0,5.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
3048,39672,clusterDoBeforeSleep,1,clusterDoBeforeSleep,void clusterDoBeforeSleep (int),cluster.c,"void clusterDoBeforeSleep(int flags) {
    server.cluster->todo_before_sleep |= flags;
}",4818.0,4820.0,1.0,1.0,3.0,0,0,0,0,21,0,1,1,0,0,,0,0,2,1,1,void
3049,39677,clusterSendUpdate,1,clusterSendUpdate,"void clusterSendUpdate (clusterLink*,clusterNode*)",cluster.c,"void clusterSendUpdate(clusterLink *link, clusterNode *node) {
    if (link == NULL) return;

    uint32_t msglen = sizeof(clusterMsg) - sizeof(union clusterMsgData)
        + sizeof(clusterMsgDataUpdate);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_UPDATE, msglen);

    clusterMsg *hdr = &msgblock->msg;
    memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
    hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
    memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
    for (unsigned int i = 0; i < sizeof(node->slots); i++) {
        /* Don't advertise slots that the node stopped claiming */
        hdr->data.update.nodecfg.slots[i] = hdr->data.update.nodecfg.slots[i] & (~server.cluster->owner_not_claiming_slot[i]);
    }

    clusterSendMessage(link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3759.0,3777.0,1.0,62.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3050,39683,resetManualFailover,1,resetManualFailover,void resetManualFailover (void),cluster.c,"void resetManualFailover(void) {
    if (server.cluster->mf_slave) {
        /* We were a master failing over, so we paused clients and related actions.
         * Regardless of the outcome we unpause now to allow traffic again. */
        unpauseActions(PAUSE_DURING_FAILOVER);
    }
    server.cluster->mf_end = 0; /* No manual failover in progress. */
    server.cluster->mf_can_start = 0;
    server.cluster->mf_slave = NULL;
    server.cluster->mf_master_offset = -1;
}",4466.0,4476.0,1.0,1.0,11.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
3051,39688,clusterCloseAllSlots,1,clusterCloseAllSlots,void clusterCloseAllSlots (void),cluster.c,"void clusterCloseAllSlots(void) {
    memset(server.cluster->migrating_slots_to,0,
        sizeof(server.cluster->migrating_slots_to));
    memset(server.cluster->importing_slots_from,0,
        sizeof(server.cluster->importing_slots_from));
}",4952.0,4957.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3052,39693,clusterSetNodeAsMaster,1,clusterSetNodeAsMaster,void clusterSetNodeAsMaster (clusterNode*),cluster.c,"void clusterSetNodeAsMaster(clusterNode *n) {
    if (nodeIsMaster(n)) return;

    if (n->slaveof) {
        clusterNodeRemoveSlave(n->slaveof,n);
        if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;
    }
    n->flags &= ~CLUSTER_NODE_SLAVE;
    n->flags |= CLUSTER_NODE_MASTER;
    n->slaveof = NULL;

    /* Update config and state. */
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                         CLUSTER_TODO_UPDATE_STATE);
}",2302.0,2316.0,1.0,8.0,15.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
3053,39698,clusterDelNode,1,clusterDelNode,void clusterDelNode (clusterNode*),cluster.c,"void clusterDelNode(clusterNode *delnode) {
    int j;
    dictIterator *di;
    dictEntry *de;

    /* 1) Mark slots as unassigned. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (server.cluster->importing_slots_from[j] == delnode)
            server.cluster->importing_slots_from[j] = NULL;
        if (server.cluster->migrating_slots_to[j] == delnode)
            server.cluster->migrating_slots_to[j] = NULL;
        if (server.cluster->slots[j] == delnode)
            clusterDelSlot(j);
    }

    /* 2) Remove failure reports. */
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node == delnode) continue;
        clusterNodeDelFailureReport(node,delnode);
    }
    dictReleaseIterator(di);

    /* 3) Remove the node from the owning shard */
    clusterRemoveNodeFromShard(delnode);

    /* 4) Free the node, unlinking it from the cluster. */
    freeClusterNode(delnode);
}",1591.0,1621.0,1.0,20.0,31.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
3054,39703,representClusterNodeFlags,1,representClusterNodeFlags,"sds representClusterNodeFlags (sds,uint16_t)",cluster.c,"sds representClusterNodeFlags(sds ci, uint16_t flags) {
    size_t orig_len = sdslen(ci);
    int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
    for (i = 0; i < size; i++) {
        struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
        if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
    }
    /* If no flag was added, add the ""noflags"" special flag. */
    if (sdslen(ci) == orig_len) ci = sdscat(ci,""noflags,"");
    sdsIncrLen(ci,-1); /* Remove trailing comma. */
    return ci;
}",5186.0,5197.0,1.0,1.0,12.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,sds
3055,39709,representSlotInfo,1,representSlotInfo,"sds representSlotInfo (sds,uint16_t*,int)",cluster.c,"sds representSlotInfo(sds ci, uint16_t *slot_info_pairs, int slot_info_pairs_count) {
    for (int i = 0; i< slot_info_pairs_count; i+=2) {
        unsigned long start = slot_info_pairs[i];
        unsigned long end = slot_info_pairs[i+1];
        if (start == end) {
            ci = sdscatfmt(ci, "" %i"", start);
        } else {
            ci = sdscatfmt(ci, "" %i-%i"", start, end);
        }
    }
    return ci;
}",5202.0,5213.0,1.0,1.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,sds
3056,39716,clusterFreeNodesSlotsInfo,1,clusterFreeNodesSlotsInfo,void clusterFreeNodesSlotsInfo (clusterNode*),cluster.c,"void clusterFreeNodesSlotsInfo(clusterNode *n) {
    zfree(n->slot_info_pairs);
    n->slot_info_pairs = NULL;
    n->slot_info_pairs_count = 0;
}",5350.0,5354.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3057,39721,clusterGetMaxEpoch,1,clusterGetMaxEpoch,uint64_t clusterGetMaxEpoch (void),cluster.c,"uint64_t clusterGetMaxEpoch(void) {
    uint64_t max = 0;
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->configEpoch > max) max = node->configEpoch;
    }
    dictReleaseIterator(di);
    if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
    return max;
}",1713.0,1726.0,1.0,1.0,14.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,uint64_t
3058,39726,clusterBumpConfigEpochWithoutConsensus,1,clusterBumpConfigEpochWithoutConsensus,int clusterBumpConfigEpochWithoutConsensus (void),cluster.c,"int clusterBumpConfigEpochWithoutConsensus(void) {
    uint64_t maxEpoch = clusterGetMaxEpoch();

    if (myself->configEpoch == 0 ||
        myself->configEpoch != maxEpoch)
    {
        server.cluster->currentEpoch++;
        myself->configEpoch = server.cluster->currentEpoch;
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                             CLUSTER_TODO_FSYNC_CONFIG);
        serverLog(LL_NOTICE,
            ""New configEpoch set to %llu"",
            (unsigned long long) myself->configEpoch);
        return C_OK;
    } else {
        return C_ERR;
    }
}",1757.0,1774.0,1.0,29.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3059,39731,moduleCallClusterReceivers,1,moduleCallClusterReceivers,"void moduleCallClusterReceivers (char*,uint64_t,uint8_t,unsigned char*,uint32_t)",module.c,"void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    moduleClusterReceiver *r = clusterReceivers[type];
    while(r) {
        if (r->module_id == module_id) {
            RedisModuleCtx ctx;
            moduleCreateContext(&ctx, r->module, REDISMODULE_CTX_TEMP_CLIENT);
            r->callback(&ctx,sender_id,type,payload,len);
            moduleFreeContext(&ctx);
            return;
        }
        r = r->next;
    }
}",8777.0,8789.0,1.0,49.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
3060,39740,clusterGetMessageTypeString,1,clusterGetMessageTypeString,char* clusterGetMessageTypeString (int),cluster.c,"const char *clusterGetMessageTypeString(int type) {
    switch(type) {
    case CLUSTERMSG_TYPE_PING: return ""ping"";
    case CLUSTERMSG_TYPE_PONG: return ""pong"";
    case CLUSTERMSG_TYPE_MEET: return ""meet"";
    case CLUSTERMSG_TYPE_FAIL: return ""fail"";
    case CLUSTERMSG_TYPE_PUBLISH: return ""publish"";
    case CLUSTERMSG_TYPE_PUBLISHSHARD: return ""publishshard"";
    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return ""auth-req"";
    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return ""auth-ack"";
    case CLUSTERMSG_TYPE_UPDATE: return ""update"";
    case CLUSTERMSG_TYPE_MFSTART: return ""mfstart"";
    case CLUSTERMSG_TYPE_MODULE: return ""module"";
    }
    return ""unknown"";
}",5473.0,5488.0,1.0,9.0,16.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,const char*
3061,39745,removeChannelsInSlot,1,removeChannelsInSlot,void removeChannelsInSlot (unsigned int),cluster.c,"void removeChannelsInSlot(unsigned int slot) {
    unsigned int channelcount = countChannelsInSlot(slot);
    if (channelcount == 0) return;

    /* Retrieve all the channels for the slot. */
    robj **channels = zmalloc(sizeof(robj*)*channelcount);
    raxIterator iter;
    int j = 0;
    unsigned char indexed[2];

    indexed[0] = (slot >> 8) & 0xff;
    indexed[1] = slot & 0xff;
    raxStart(&iter,server.cluster->slots_to_channels);
    raxSeek(&iter,"">="",indexed,2);
    while(raxNext(&iter)) {
        if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
        channels[j++] = createStringObject((char*)iter.key + 2, iter.key_len - 2);
    }
    raxStop(&iter);

    pubsubUnsubscribeShardChannels(channels, channelcount);
    zfree(channels);
}",6457.0,6479.0,1.0,1.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3062,39750,countKeysInSlot,1,countKeysInSlot,unsigned int countKeysInSlot (unsigned int),cluster.c,"unsigned int countKeysInSlot(unsigned int hashslot) {
    return (*server.db->slots_to_keys).by_slot[hashslot].count;
}",7629.0,7631.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,unsigned int
3063,39755,countChannelsInSlot,1,countChannelsInSlot,unsigned int countChannelsInSlot (unsigned int),cluster.c,"unsigned int countChannelsInSlot(unsigned int hashslot) {
    raxIterator iter;
    int j = 0;
    unsigned char indexed[2];

    indexed[0] = (hashslot >> 8) & 0xff;
    indexed[1] = hashslot & 0xff;
    raxStart(&iter,server.cluster->slots_to_channels);
    raxSeek(&iter,"">="",indexed,2);
    while(raxNext(&iter)) {
        if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
        j++;
    }
    raxStop(&iter);
    return j;
}",7664.0,7679.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,unsigned int
3064,39760,delKeysInSlot,1,delKeysInSlot,unsigned int delKeysInSlot (unsigned int),cluster.c,"unsigned int delKeysInSlot(unsigned int hashslot) {
    unsigned int j = 0;

    dictEntry *de = (*server.db->slots_to_keys).by_slot[hashslot].head;
    while (de != NULL) {
        sds sdskey = dictGetKey(de);
        de = dictEntryNextInSlot(de);
        robj *key = createStringObject(sdskey, sdslen(sdskey));
        dbDelete(&server.db[0], key);
        propagateDeletion(&server.db[0], key, server.lazyfree_lazy_server_del);
        signalModifiedKey(NULL, &server.db[0], key);
        moduleNotifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", key, server.db[0].id);
        postExecutionUnitOperations();
        decrRefCount(key);
        j++;
        server.dirty++;
    }

    return j;
}",7608.0,7627.0,1.0,13.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,unsigned int
3065,39765,clusterAddNodeToShard,1,clusterAddNodeToShard,"void clusterAddNodeToShard (char*,clusterNode*)",cluster.c,"void clusterAddNodeToShard(const char *shard_id, clusterNode *node) {
    sds s = sdsnewlen(shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards,s);
    if (de == NULL) {
        list *l = listCreate();
        listAddNodeTail(l, node);
        serverAssert(dictAdd(server.cluster->shards, s, l) == DICT_OK);
    } else {
        list *l = dictGetVal(de);
        if (listSearchKey(l, node) == NULL) {
            listAddNodeTail(l, node);
        }
        sdsfree(s);
    }
}",1675.0,1689.0,1.0,32.0,15.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,void
3066,39771,clusterLookupNodeListByShardId,1,clusterLookupNodeListByShardId,list* clusterLookupNodeListByShardId (char*),cluster.c,list *clusterLookupNodeListByShardId(const char *shard_id);,90.0,90.0,6.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,list*
3067,39776,clusterRemoveNodeFromShard,1,clusterRemoveNodeFromShard,void clusterRemoveNodeFromShard (clusterNode*),cluster.c,"void clusterRemoveNodeFromShard(clusterNode *node) {
    sds s = sdsnewlen(node->shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards, s);
    if (de != NULL) {
        list *l = dictGetVal(de);
        listNode *ln = listSearchKey(l, node);
        if (ln != NULL) {
            listDelNode(l, ln);
        }
        if (listLength(l) == 0) {
            dictDelete(server.cluster->shards, s);
        }
    }
    sdsfree(s);
}",1691.0,1705.0,1.0,38.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3068,39781,auxShardIdSetter,1,auxShardIdSetter,"int auxShardIdSetter (clusterNode*,void*,int)",cluster.c,"int auxShardIdSetter(clusterNode *n, void *value, int length) {
    if (verifyClusterNodeId(value, length) == C_ERR) {
        return C_ERR;
    }
    memcpy(n->shard_id, value, CLUSTER_NAMELEN);
    /* if n already has replicas, make sure they all agree
     * on the shard id */
    for (int i = 0; i < n->numslaves; i++) {
        if (memcmp(n->slaves[i]->shard_id, n->shard_id, CLUSTER_NAMELEN) != 0) {
            return C_ERR;
        }
    }
    clusterAddNodeToShard(value, n);
    return C_OK;
}",235.0,249.0,1.0,46.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3069,39788,auxShardIdGetter,1,auxShardIdGetter,"sds auxShardIdGetter (clusterNode*,sds)",cluster.c,"sds auxShardIdGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%.40s"", n->shard_id);
}",251.0,253.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
3070,39794,auxShardIdPresent,1,auxShardIdPresent,int auxShardIdPresent (clusterNode*),cluster.c,"int auxShardIdPresent(clusterNode *n) {
    return strlen(n->shard_id);
}",255.0,257.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3071,39799,auxHumanNodenameSetter,1,auxHumanNodenameSetter,"int auxHumanNodenameSetter (clusterNode*,void*,int)",cluster.c,"int auxHumanNodenameSetter(clusterNode *n, void *value, int length) {
    if (n && !strncmp(value, n->human_nodename, length)) {
        return C_OK;
    } else if (!n && (length == 0)) {
        return C_OK;
    }
    if (n) {
        n->human_nodename = sdscpylen(n->human_nodename, value, length);
    } else if (sdslen(n->human_nodename) != 0) {
        sdsclear(n->human_nodename);
    } else {
        return C_ERR;
    }
    return C_OK;
}",259.0,273.0,1.0,15.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3072,39806,auxHumanNodenameGetter,1,auxHumanNodenameGetter,"sds auxHumanNodenameGetter (clusterNode*,sds)",cluster.c,"sds auxHumanNodenameGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%s"", n->human_nodename);
}",275.0,277.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
3073,39812,auxHumanNodenamePresent,1,auxHumanNodenamePresent,int auxHumanNodenamePresent (clusterNode*),cluster.c,"int auxHumanNodenamePresent(clusterNode *n) {
    return sdslen(n->human_nodename);
}",279.0,281.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3074,39817,auxTcpPortSetter,1,auxTcpPortSetter,"int auxTcpPortSetter (clusterNode*,void*,int)",cluster.c,"int auxTcpPortSetter(clusterNode *n, void *value, int length) {
    if (length > 5 || length < 1) {
        return C_ERR;
    }
    char buf[length + 1];
    memcpy(buf, (char*)value, length);
    buf[length] = '\0';
    n->tcp_port = atoi(buf);
    return (n->tcp_port < 0 || n->tcp_port >= 65536) ? C_ERR : C_OK;
}",283.0,292.0,1.0,15.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3075,39824,auxTcpPortGetter,1,auxTcpPortGetter,"sds auxTcpPortGetter (clusterNode*,sds)",cluster.c,"sds auxTcpPortGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%d"", n->tcp_port);
}",294.0,296.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
3076,39830,auxTcpPortPresent,1,auxTcpPortPresent,int auxTcpPortPresent (clusterNode*),cluster.c,"int auxTcpPortPresent(clusterNode *n) {
    return n->tcp_port >= 0 && n->tcp_port < 65536;
}",298.0,300.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3077,39835,auxTlsPortSetter,1,auxTlsPortSetter,"int auxTlsPortSetter (clusterNode*,void*,int)",cluster.c,"int auxTlsPortSetter(clusterNode *n, void *value, int length) {
    if (length > 5 || length < 1) {
        return C_ERR;
    }
    char buf[length + 1];
    memcpy(buf, (char*)value, length);
    buf[length] = '\0';
    n->tls_port = atoi(buf);
    return (n->tls_port < 0 || n->tls_port >= 65536) ? C_ERR : C_OK;
}",302.0,311.0,1.0,15.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3078,39842,auxTlsPortGetter,1,auxTlsPortGetter,"sds auxTlsPortGetter (clusterNode*,sds)",cluster.c,"sds auxTlsPortGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%d"", n->tls_port);
}",313.0,315.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
3079,39848,auxTlsPortPresent,1,auxTlsPortPresent,int auxTlsPortPresent (clusterNode*),cluster.c,"int auxTlsPortPresent(clusterNode *n) {
    return n->tls_port >= 0 && n->tls_port < 65536;
}",317.0,319.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3080,39853,clusterBuildMessageHdr,1,clusterBuildMessageHdr,"void clusterBuildMessageHdr (clusterMsg*,int,size_t)",cluster.c,"static void clusterBuildMessageHdr(clusterMsg *hdr, int type, size_t msglen) {
    uint64_t offset;
    clusterNode *master;

    /* If this node is a master, we send its slots bitmap and configEpoch.
     * If this node is a slave we send the master's information instead (the
     * node is flagged as slave so the receiver knows that it is NOT really
     * in charge for this slots. */
    master = (nodeIsSlave(myself) && myself->slaveof) ?
              myself->slaveof : myself;

    hdr->ver = htons(CLUSTER_PROTO_VER);
    hdr->sig[0] = 'R';
    hdr->sig[1] = 'C';
    hdr->sig[2] = 'm';
    hdr->sig[3] = 'b';
    hdr->type = htons(type);
    memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);

    /* If cluster-announce-ip option is enabled, force the receivers of our
     * packets to use the specified address for this node. Otherwise if the
     * first byte is zero, they'll do auto discovery. */
    memset(hdr->myip,0,NET_IP_STR_LEN);
    if (server.cluster_announce_ip) {
      ...",3452.0,3514.0,1.0,14.0,63.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
3081,39860,getNodeDefaultClientPort,1,getNodeDefaultClientPort,int getNodeDefaultClientPort (clusterNode*),cluster.c,"int getNodeDefaultClientPort(clusterNode *n) {
    return server.tls_cluster ? n->tls_port : n->tcp_port;
}",106.0,108.0,1.0,1.0,3.0,4,3,3,2,4,2,1,1,0,0,,0,2,2,1,1,int
3082,39876,getNodeDefaultReplicationPort,1,getNodeDefaultReplicationPort,int getNodeDefaultReplicationPort (clusterNode*),cluster.c,"static inline int getNodeDefaultReplicationPort(clusterNode *n) {
    return server.tls_replication ? n->tls_port : n->tcp_port;
}",110.0,112.0,1.0,1.0,3.0,4,3,3,2,2,2,1,1,0,0,,0,2,2,1,1,int
3083,39892,getNodeClientPort,1,getNodeClientPort,"int getNodeClientPort (clusterNode*,int)",cluster.c,"static inline int getNodeClientPort(clusterNode *n, int use_tls) {
    return use_tls ? n->tls_port : n->tcp_port;
}",114.0,116.0,1.0,1.0,3.0,3,2,3,2,2,2,1,1,0,0,,0,2,4,2,2,int
3084,39907,defaultClientPort,1,defaultClientPort,int defaultClientPort (void),cluster.c,"static inline int defaultClientPort(void) {
    return server.tls_cluster ? server.tls_port : server.port;
}",118.0,120.0,1.0,1.0,3.0,4,2,3,1,2,0,1,1,0,0,,0,0,2,1,1,int
3085,39945,connTypeOfCluster,1,connTypeOfCluster,ConnectionType connTypeOfCluster (void),cluster.c,"static ConnectionType *connTypeOfCluster(void) {
    if (server.tls_cluster) {
        return connectionTypeTls();
    }

    return connectionTypeTcp();
}",161.0,167.0,1.0,1.0,7.0,1,1,1,1,5,2,2,2,0,2,,0,0,2,1,1,ConnectionType
3086,39970,aux_value_setter,1,aux_value_setter,"int aux_value_setter (clusterNode*,void*,int)",cluster.c,"typedef int (aux_value_setter) (clusterNode* n, void *value, int length);",189.0,189.0,13.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3087,39977,aux_value_getter,1,aux_value_getter,"sds aux_value_getter (clusterNode*,sds)",cluster.c,"typedef sds (aux_value_getter) (clusterNode* n, sds s);",193.0,193.0,13.0,54.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
3088,39983,aux_value_present,1,aux_value_present,int aux_value_present (clusterNode*),cluster.c,typedef int (aux_value_present) (clusterNode* n);,195.0,195.0,13.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3089,40025,isValidAuxChar,1,isValidAuxChar,int isValidAuxChar (int),cluster.c,"int isValidAuxChar(int c) {
    return isalnum(c) || (strchr(""!#$%&()*+:;<>?@[]^{|}~"", c) == NULL);
}",224.0,226.0,1.0,1.0,3.0,2,2,3,2,1,0,1,1,0,0,,0,0,2,1,1,int
3090,40039,isValidAuxString,1,isValidAuxString,"int isValidAuxString (char*,unsigned int)",cluster.c,"int isValidAuxString(char *s, unsigned int length) {
    for (unsigned i = 0; i < length; i++) {
        if (!isValidAuxChar(s[i])) return 0;
    }
    return 1;
}",228.0,233.0,1.0,1.0,6.0,4,4,5,3,2,1,3,4,1,1,,0,1,4,2,2,int
3091,40445,clusterLoadConfig,1,clusterLoadConfig,int clusterLoadConfig (char*),cluster.c,"int clusterLoadConfig(char *filename) {
    FILE *fp = fopen(filename,""r"");
    struct stat sb;
    char *line;
    int maxline, j;

    if (fp == NULL) {
        if (errno == ENOENT) {
            return C_ERR;
        } else {
            serverLog(LL_WARNING,
                ""Loading the cluster node config from %s: %s"",
                filename, strerror(errno));
            exit(1);
        }
    }

    if (redis_fstat(fileno(fp),&sb) == -1) {
        serverLog(LL_WARNING,
            ""Unable to obtain the cluster node config file stat %s: %s"",
            filename, strerror(errno));
        exit(1);
    }
    /* Check if the file is zero-length: if so return C_ERR to signal
     * we have to write the config. */
    if (sb.st_size == 0) {
        fclose(fp);
        return C_ERR;
    }

    /* Parse the file. Note that single lines of the cluster config file can
     * be really long as they include all the hash slots of the node.
     * This means in the worst possible case, ...",338.0,692.0,1.0,19.0,355.0,249,29,278,38,1,89,70,128,19,64,,0,56,2,1,1,int
3092,41825,clusterSaveConfig,1,clusterSaveConfig,int clusterSaveConfig (int),cluster.c,"int clusterSaveConfig(int do_fsync) {
    sds ci,tmpfilename;
    size_t content_size,offset = 0;
    ssize_t written_bytes;
    int fd = -1;
    int retval = C_ERR;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_SAVE_CONFIG;

    /* Get the nodes description and concatenate our ""vars"" directive to
     * save currentEpoch and lastVoteEpoch. */
    ci = clusterGenNodesDescription(NULL, CLUSTER_NODE_HANDSHAKE, 0);
    ci = sdscatprintf(ci,""vars currentEpoch %llu lastVoteEpoch %llu\n"",
        (unsigned long long) server.cluster->currentEpoch,
        (unsigned long long) server.cluster->lastVoteEpoch);
    content_size = sdslen(ci);

    /* Create a temp file with the new content. */
    tmpfilename = sdscatfmt(sdsempty(),""%s.tmp-%i-%I"",
        server.cluster_configfile,(int) getpid(),mstime());
    if ((fd = open(tmpfilename,O_WRONLY|O_CREAT,0644)) == -1) {
        serverLog(LL_WARNING,""Could not open temp cluster config file: %s"",strerror(errno));
        goto cleanup;
  ...",706.0,769.0,1.0,17.0,64.0,62,16,58,14,1,14,18,17,1,14,,0,7,2,1,1,int
3093,42125,clusterSaveConfigOrDie,1,clusterSaveConfigOrDie,void clusterSaveConfigOrDie (int),cluster.c,"void clusterSaveConfigOrDie(int do_fsync) {
    if (clusterSaveConfig(do_fsync) == -1) {
        serverLog(LL_WARNING,""Fatal: can't update cluster config file."");
        exit(1);
    }
}",771.0,776.0,1.0,8.0,6.0,5,5,2,2,5,2,2,2,1,2,,0,1,2,1,1,void
3094,42157,clusterLockConfig,1,clusterLockConfig,int clusterLockConfig (char*),cluster.c,"int clusterLockConfig(char *filename) {
/* flock() does not exist on Solaris
 * and a fcntl-based solution won't help, as we constantly re-open that file,
 * which will release _all_ locks anyway
 */
#if !defined(__sun)
    /* To lock it, we need to open the file in a way it is created if
     * it does not exist, otherwise there is a race condition with other
     * processes. */
    int fd = open(filename,O_WRONLY|O_CREAT|O_CLOEXEC,0644);
    if (fd == -1) {
        serverLog(LL_WARNING,
            ""Can't open %s in order to acquire a lock: %s"",
            filename, strerror(errno));
        return C_ERR;
    }

    if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
            serverLog(LL_WARNING,
                 ""Sorry, the cluster configuration file %s is already used ""
                 ""by a different Redis Cluster node. Please make sure that ""
                 ""different nodes use different cluster configuration ""
                 ""files."", filenam...",787.0,833.0,1.0,8.0,47.0,19,7,19,10,1,2,4,5,0,2,,0,0,2,1,1,int
3095,42278,deriveAnnouncedPorts,1,deriveAnnouncedPorts,"void deriveAnnouncedPorts (int*,int*,int*)",cluster.c,"void deriveAnnouncedPorts(int *announced_tcp_port, int *announced_tls_port,
                          int *announced_cport) {
    /* Config overriding announced ports. */
    *announced_tcp_port = server.cluster_announce_port ? 
                          server.cluster_announce_port : server.port;
    *announced_tls_port = server.cluster_announce_tls_port ? 
                          server.cluster_announce_tls_port : server.tls_port;
    /* Derive cluster bus port. */
    if (server.cluster_announce_bus_port) {
        *announced_cport = server.cluster_announce_bus_port;
    } else if (server.cluster_port) {
        *announced_cport = server.cluster_port;
    } else {
        *announced_cport = defaultClientPort() + CLUSTER_PORT_INCR;
    }
}",836.0,851.0,1.0,49.0,16.0,16,4,11,4,2,0,2,2,0,0,,0,0,6,3,3,void
3096,42345,clusterUpdateMyselfFlags,1,clusterUpdateMyselfFlags,void clusterUpdateMyselfFlags (void),cluster.c,"void clusterUpdateMyselfFlags(void) {
    if (!myself) return;
    int oldflags = myself->flags;
    int nofailover = server.cluster_slave_no_failover ?
                     CLUSTER_NODE_NOFAILOVER : 0;
    myself->flags &= ~CLUSTER_NODE_NOFAILOVER;
    myself->flags |= nofailover;
    if (myself->flags != oldflags) {
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                             CLUSTER_TODO_UPDATE_STATE);
    }
}",857.0,868.0,1.0,21.0,12.0,14,9,10,4,2,10,3,3,3,1,,0,9,2,1,1,void
3097,42404,clusterUpdateMyselfAnnouncedPorts,1,clusterUpdateMyselfAnnouncedPorts,void clusterUpdateMyselfAnnouncedPorts (void),cluster.c,"void clusterUpdateMyselfAnnouncedPorts(void) {
    if (!myself) return;
    deriveAnnouncedPorts(&myself->tcp_port,&myself->tls_port,&myself->cport);
}",874.0,877.0,1.0,1.0,4.0,7,3,4,1,1,8,2,2,1,1,,0,7,2,1,1,void
3098,42427,clusterUpdateMyselfIp,1,clusterUpdateMyselfIp,void clusterUpdateMyselfIp (void),cluster.c,"void clusterUpdateMyselfIp(void) {
    if (!myself) return;
    static char *prev_ip = NULL;
    char *curr_ip = server.cluster_announce_ip;
    int changed = 0;

    if (prev_ip == NULL && curr_ip != NULL) changed = 1;
    else if (prev_ip != NULL && curr_ip == NULL) changed = 1;
    else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;

    if (changed) {
        if (prev_ip) zfree(prev_ip);
        prev_ip = curr_ip;

        if (curr_ip) {
            /* We always take a copy of the previous IP address, by
            * duplicating the string. This way later we can check if
            * the address really changed. */
            prev_ip = zstrdup(prev_ip);
            redis_strlcpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
        } else {
            myself->ip[0] = '\0'; /* Force autodetection. */
        }
    }
}",881.0,905.0,1.0,64.0,25.0,13,7,21,6,2,6,6,8,1,3,,0,4,2,1,1,void
3099,42528,updateAnnouncedHostname,1,updateAnnouncedHostname,"void updateAnnouncedHostname (clusterNode*,char*)",cluster.c,"static void updateAnnouncedHostname(clusterNode *node, char *new) {
    /* Previous and new hostname are the same, no need to update. */
    if (new && !strcmp(new, node->hostname)) {
        return;
    } else if (!new && (sdslen(node->hostname) == 0)) {
        return;
    }

    if (new) {
        node->hostname = sdscpy(node->hostname, new);
    } else if (sdslen(node->hostname) != 0) {
        sdsclear(node->hostname);
    }
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}",908.0,922.0,1.0,25.0,15.0,7,5,7,2,2,5,3,3,1,2,,0,4,4,2,2,void
3100,42591,updateAnnouncedHumanNodename,1,updateAnnouncedHumanNodename,"void updateAnnouncedHumanNodename (clusterNode*,char*)",cluster.c,"static void updateAnnouncedHumanNodename(clusterNode *node, char *new) {
    if (new && !strcmp(new, node->human_nodename)) {
        return;
    } else if (!new && (sdslen(node->human_nodename) == 0)) {
        return;
    }
    
    if (new) {
        node->human_nodename = sdscpy(node->human_nodename, new);
    } else if (sdslen(node->human_nodename) != 0) {
        sdsclear(node->human_nodename);
    }
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}",924.0,937.0,1.0,25.0,14.0,7,5,7,2,2,5,3,3,1,2,,0,4,4,2,2,void
3101,42654,updateShardId,1,updateShardId,"void updateShardId (clusterNode*,char*)",cluster.c,"static void updateShardId(clusterNode *node, const char *shard_id) {
    if (memcmp(node->shard_id, shard_id, CLUSTER_NAMELEN) != 0) {
        clusterRemoveNodeFromShard(node);
        memcpy(node->shard_id, shard_id, CLUSTER_NAMELEN);
        clusterAddNodeToShard(shard_id, node);
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
    }
    if (myself != node && myself->slaveof == node) {
        if (memcmp(myself->shard_id, shard_id, CLUSTER_NAMELEN) != 0) {
            /* shard-id can diverge right after a rolling upgrade
             * from pre-7.2 releases */
            clusterRemoveNodeFromShard(myself);
            memcpy(myself->shard_id, shard_id, CLUSTER_NAMELEN);
            clusterAddNodeToShard(shard_id, myself);
            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);
        }
    }
}",940.0,957.0,1.0,41.0,18.0,14,6,18,3,1,17,4,5,6,6,,0,11,4,2,2,void
3102,42739,clusterUpdateMyselfHostname,1,clusterUpdateMyselfHostname,void clusterUpdateMyselfHostname (void),cluster.c,"void clusterUpdateMyselfHostname(void) {
    if (!myself) return;
    updateAnnouncedHostname(myself, server.cluster_announce_hostname);
}",960.0,963.0,1.0,1.0,4.0,2,2,3,2,3,3,2,2,1,1,,0,2,2,1,1,void
3103,42754,clusterUpdateMyselfHumanNodename,1,clusterUpdateMyselfHumanNodename,void clusterUpdateMyselfHumanNodename (void),cluster.c,"void clusterUpdateMyselfHumanNodename(void) {
    if (!myself) return;
    updateAnnouncedHumanNodename(myself, server.cluster_announce_human_nodename);
}",965.0,968.0,1.0,1.0,4.0,2,2,3,2,2,3,2,2,1,1,,0,2,2,1,1,void
3104,42769,clusterInit,1,clusterInit,void clusterInit (void),cluster.c,"void clusterInit(void) {
    int saveconf = 0;

    server.cluster = zmalloc(sizeof(clusterState));
    server.cluster->myself = NULL;
    server.cluster->currentEpoch = 0;
    server.cluster->state = CLUSTER_FAIL;
    server.cluster->size = 1;
    server.cluster->todo_before_sleep = 0;
    server.cluster->nodes = dictCreate(&clusterNodesDictType);
    server.cluster->shards = dictCreate(&clusterSdsToListType);
    server.cluster->nodes_black_list =
        dictCreate(&clusterNodesBlackListDictType);
    server.cluster->failover_auth_time = 0;
    server.cluster->failover_auth_count = 0;
    server.cluster->failover_auth_rank = 0;
    server.cluster->failover_auth_epoch = 0;
    server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
    server.cluster->lastVoteEpoch = 0;

    /* Initialize stats */
    for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
        server.cluster->stats_bus_messages_sent[i] = 0;
        server.cluster->stats_bus_messages_received[i] = 0;
    }...",970.0,1056.0,1.0,28.0,87.0,125,15,60,10,0,39,7,7,2,23,,0,25,2,1,1,void
3105,43156,clusterInitListeners,1,clusterInitListeners,void clusterInitListeners (void),cluster.c,"void clusterInitListeners(void) {
    if (connectionIndexByType(connTypeOfCluster()->get_type(NULL)) < 0) {
        serverLog(LL_WARNING, ""Missing connection type %s, but it is required for the Cluster bus."", connTypeOfCluster()->get_type(NULL));
        exit(1);
    }

    int port = defaultClientPort();
    connListener *listener = &server.clistener;
    listener->count = 0;
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.cluster_port ? server.cluster_port : port + CLUSTER_PORT_INCR;
    listener->ct = connTypeOfCluster();
    if (connListen(listener) == C_ERR ) {
        /* Note: the following log text is matched by the test suite. */
        serverLog(LL_WARNING, ""Failed listening on port %u (cluster), aborting."", listener->port);
        exit(1);
    }
    
    if (createSocketAcceptHandler(&server.clistener, clusterAcceptHandler) != C_OK) {
        serverPanic(""Unrecoverable error creating Redis Cluste...",1058.0,1080.0,1.0,8.0,23.0,36,12,21,5,0,17,4,4,5,11,,0,14,2,1,1,void
3106,43299,clusterReset,1,clusterReset,void clusterReset (int),cluster.c,"void clusterReset(int hard) {
    dictIterator *di;
    dictEntry *de;
    int j;

    /* Turn into master. */
    if (nodeIsSlave(myself)) {
        clusterSetNodeAsMaster(myself);
        replicationUnsetMaster();
        emptyData(-1,EMPTYDB_NO_FLAGS,NULL);
    }

    /* Close slots, reset manual failover state. */
    clusterCloseAllSlots();
    resetManualFailover();

    /* Unassign all the slots. */
    for (j = 0; j < CLUSTER_SLOTS; j++) clusterDelSlot(j);

    /* Recreate shards dict */
    dictEmpty(server.cluster->shards, NULL);

    /* Forget all the nodes, but myself. */
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node == myself) continue;
        clusterDelNode(node);
    }
    dictReleaseIterator(di);

    /* Hard reset only: set epochs to 0, change node ID. */
    if (hard) {
        sds oldname;

        server.cluster->currentEpoch = 0;
        server.cluster-...",1091.0,1150.0,1.0,8.0,60.0,41,10,36,9,0,40,7,7,5,21,,0,23,2,1,1,void
3107,43500,createClusterMsgSendBlock,1,createClusterMsgSendBlock,"clusterMsgSendBlock createClusterMsgSendBlock (int,uint32_t)",cluster.c,"static clusterMsgSendBlock *createClusterMsgSendBlock(int type, uint32_t msglen) {
    uint32_t blocklen = msglen + sizeof(clusterMsgSendBlock) - sizeof(clusterMsg);
    clusterMsgSendBlock *msgblock = zcalloc(blocklen);
    msgblock->refcount = 1;
    msgblock->totlen = blocklen;
    server.stat_cluster_links_memory += blocklen;
    clusterBuildMessageHdr(&msgblock->msg,type,msglen);
    return msgblock;
}",1155.0,1163.0,1.0,1.0,9.0,14,8,15,7,5,6,1,1,0,2,,0,5,4,2,2,clusterMsgSendBlock
3108,43545,clusterMsgSendBlockDecrRefCount,1,clusterMsgSendBlockDecrRefCount,void clusterMsgSendBlockDecrRefCount (void*),cluster.c,"static void clusterMsgSendBlockDecrRefCount(void *node) {
    clusterMsgSendBlock *msgblock = (clusterMsgSendBlock*)node;
    msgblock->refcount--;
    serverAssert(msgblock->refcount >= 0);
    if (msgblock->refcount == 0) {
        server.stat_cluster_links_memory -= msgblock->totlen;
        zfree(msgblock);
    }
}",1165.0,1173.0,1.0,4.0,9.0,15,11,8,3,6,6,2,2,1,2,,0,4,2,1,1,void
3109,43594,createClusterLink,1,createClusterLink,clusterLink createClusterLink (clusterNode*),cluster.c,"clusterLink *createClusterLink(clusterNode *node) {
    clusterLink *link = zmalloc(sizeof(*link));
    link->ctime = mstime();
    link->send_msg_queue = listCreate();
    listSetFreeMethod(link->send_msg_queue, clusterMsgSendBlockDecrRefCount);
    link->head_msg_send_offset = 0;
    link->send_msg_queue_mem = sizeof(list);
    link->rcvbuf = zmalloc(link->rcvbuf_alloc = RCVBUF_INIT_LEN);
    link->rcvbuf_len = 0;
    server.stat_cluster_links_memory += link->rcvbuf_alloc + link->send_msg_queue_mem;
    link->conn = NULL;
    link->node = node;
    /* Related node can only possibly be known at link creation time if this is an outbound link */
    link->inbound = (node == NULL);
    if (!link->inbound) {
        node->link = link;
    }
    return link;
}",1175.0,1193.0,1.0,4.0,19.0,38,9,26,5,2,20,2,2,1,4,,0,20,2,1,1,clusterLink
3110,43698,freeClusterLink,1,freeClusterLink,void freeClusterLink (clusterLink*),cluster.c,"void freeClusterLink(clusterLink *link) {
    if (link->conn) {
        connClose(link->conn);
        link->conn = NULL;
    }
    server.stat_cluster_links_memory -= sizeof(list) + listLength(link->send_msg_queue)*sizeof(listNode);
    listRelease(link->send_msg_queue);
    server.stat_cluster_links_memory -= link->rcvbuf_alloc;
    zfree(link->rcvbuf);
    if (link->node) {
        if (link->node->link == link) {
            serverAssert(!link->inbound);
            link->node->link = NULL;
        } else if (link->node->inbound_link == link) {
            serverAssert(link->inbound);
            link->node->inbound_link = NULL;
        }
    }
    zfree(link);
}",1198.0,1217.0,1.0,55.0,20.0,33,13,21,5,10,18,4,5,3,5,,0,13,2,1,1,void
3111,43833,setClusterNodeToInboundClusterLink,1,setClusterNodeToInboundClusterLink,"void setClusterNodeToInboundClusterLink (clusterNode*,clusterLink*)",cluster.c,"void setClusterNodeToInboundClusterLink(clusterNode *node, clusterLink *link) {
    serverAssert(!link->node);
    serverAssert(link->inbound);
    if (node->inbound_link) {
        /* A peer may disconnect and then reconnect with us, and it's not guaranteed that
         * we would always process the disconnection of the existing inbound link before
         * accepting a new existing inbound link. Therefore, it's possible to have more than
         * one inbound link from the same node at the same time. Our cleanup logic assumes
         * a one to one relationship between nodes and inbound links, so we need to kill
         * one of the links. The existing link is more likely the outdated one, but it's
         * possible the other node may need to open another link. */
        serverLog(LL_DEBUG, ""Replacing inbound link fd %d from node %.40s with fd %d"",
                node->inbound_link->conn->fd, node->name, link->conn->fd);
        freeClusterLink(node->inbound_link);
    }
...",1219.0,1237.0,1.0,4.0,19.0,37,10,16,3,0,18,2,2,1,5,,0,13,4,2,2,void
3112,43952,clusterConnAcceptHandler,1,clusterConnAcceptHandler,void clusterConnAcceptHandler (connection*),cluster.c,"static void clusterConnAcceptHandler(connection *conn) {
    clusterLink *link;

    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_VERBOSE,
                ""Error accepting cluster node connection: %s"", connGetLastError(conn));
        connClose(conn);
        return;
    }

    /* Create a link object we use to handle the connection.
     * It gets passed to the readable handler when data is available.
     * Initially the link->node pointer is set to NULL as we don't know
     * which node is, but the right node is references once we know the
     * node identity. */
    link = createClusterLink(NULL);
    link->conn = conn;
    connSetPrivateData(conn, link);

    /* Register read handler */
    connSetReadHandler(conn, clusterReadHandler);
}",1239.0,1260.0,1.0,8.0,22.0,7,6,13,6,0,8,2,2,1,7,,0,4,2,1,1,void
3113,44213,getClusterConnectionsCount,1,getClusterConnectionsCount,unsigned long getClusterConnectionsCount (void),cluster.c,"unsigned long getClusterConnectionsCount(void) {
    /* We decrement the number of nodes by one, since there is the
     * ""myself"" node too in the list. Each node uses two file descriptors,
     * one incoming and one outgoing, thus the multiplication by 2. */
    return server.cluster_enabled ?
           ((dictSize(server.cluster->nodes)-1)*2) : 0;
}",1317.0,1323.0,1.0,13.0,7.0,15,7,4,1,2,0,1,1,0,0,,0,0,2,1,1,unsigned long
3114,44254,keyHashSlot,1,keyHashSlot,"unsigned int keyHashSlot (char*,int)",cluster.c,"unsigned int keyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) & 0x3FFF;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) & 0x3FFF;
}",1335.0,1354.0,1.0,1.0,20.0,17,7,21,4,5,3,5,5,0,3,,0,0,4,2,2,unsigned int
3115,44544,clusterNodeAddFailureReport,1,clusterNodeAddFailureReport,"int clusterNodeAddFailureReport (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
    list *l = failing->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    /* If a failure report from the same sender already exists, just update
     * the timestamp. */
    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (fr->node == sender) {
            fr->time = mstime();
            return 0;
        }
    }

    /* Otherwise create a new report. */
    fr = zmalloc(sizeof(*fr));
    fr->node = sender;
    fr->time = mstime();
    listAddNodeTail(l,fr);
    return 1;
}",1416.0,1439.0,1.0,1.0,24.0,19,7,19,7,1,12,3,4,2,6,,0,10,4,2,2,int
3116,44612,clusterNodeCleanupFailureReports,1,clusterNodeCleanupFailureReports,void clusterNodeCleanupFailureReports (clusterNode*),cluster.c,"void clusterNodeCleanupFailureReports(clusterNode *node) {
    list *l = node->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;
    mstime_t maxtime = server.cluster_node_timeout *
                     CLUSTER_FAIL_REPORT_VALIDITY_MULT;
    mstime_t now = mstime();

    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (now - fr->time > maxtime) listDelNode(l,ln);
    }
}",1446.0,1460.0,1.0,21.0,15.0,15,8,17,9,2,7,3,4,2,4,,0,5,2,1,1,void
3117,44670,clusterNodeDelFailureReport,1,clusterNodeDelFailureReport,"int clusterNodeDelFailureReport (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
    list *l = node->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    /* Search for a failure report from this sender. */
    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (fr->node == sender) break;
    }
    if (!ln) return 0; /* No failure report from this sender. */

    /* Remove the failure report. */
    listDelNode(l,ln);
    clusterNodeCleanupFailureReports(node);
    return 1;
}",1473.0,1491.0,1.0,1.0,19.0,11,6,15,7,0,7,5,5,2,4,,0,4,4,2,2,int
3118,44724,clusterNodeFailureReportsCount,1,clusterNodeFailureReportsCount,int clusterNodeFailureReportsCount (clusterNode*),cluster.c,"int clusterNodeFailureReportsCount(clusterNode *node) {
    clusterNodeCleanupFailureReports(node);
    return listLength(node->fail_reports);
}",1496.0,1499.0,1.0,11.0,4.0,3,1,3,1,2,3,1,1,0,1,,0,2,2,1,1,int
3119,44742,clusterNodeRemoveSlave,1,clusterNodeRemoveSlave,"int clusterNodeRemoveSlave (clusterNode*,clusterNode*)",cluster.c,"int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
    int j;

    for (j = 0; j < master->numslaves; j++) {
        if (master->slaves[j] == slave) {
            if ((j+1) < master->numslaves) {
                int remaining_slaves = (master->numslaves - j) - 1;
                memmove(master->slaves+j,master->slaves+(j+1),
                        (sizeof(*master->slaves) * remaining_slaves));
            }
            master->numslaves--;
            if (master->numslaves == 0)
                master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
            return C_OK;
        }
    }
    return C_ERR;
}",1501.0,1518.0,1.0,34.0,18.0,29,13,20,4,1,10,5,10,4,0,,0,10,4,2,2,int
3120,44911,clusterCountNonFailingSlaves,1,clusterCountNonFailingSlaves,int clusterCountNonFailingSlaves (clusterNode*),cluster.c,"int clusterCountNonFailingSlaves(clusterNode *n) {
    int j, okslaves = 0;

    for (j = 0; j < n->numslaves; j++)
        if (!nodeFailed(n->slaves[j])) okslaves++;
    return okslaves;
}",1534.0,1540.0,1.0,13.0,7.0,4,3,5,3,1,1,2,2,1,0,,0,1,2,1,1,int
3121,44956,freeClusterNode,1,freeClusterNode,void freeClusterNode (clusterNode*),redis-benchmark.c,"static void freeClusterNode(clusterNode *node) {
    int i;
    if (node->name) sdsfree(node->name);
    if (node->replicate) sdsfree(node->replicate);
    if (node->migrating != NULL) {
        for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
        zfree(node->migrating);
    }
    if (node->importing != NULL) {
        for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
        zfree(node->importing);
    }
    /* If the node is not the reference node, that uses the address from
     * config.conn_info.hostip and config.conn_info.hostport, then the node ip has been
     * allocated by fetchClusterConfiguration, so it must be freed. */
    if (node->ip && strcmp(node->ip, config.conn_info.hostip) != 0) sdsfree(node->ip);
    if (node->redis_config != NULL) freeRedisConfig(node->redis_config);
    zfree(node->slots);
    zfree(node);
}",1078.0,1097.0,1.0,1.0,20.0,25,11,22,4,1,25,5,5,5,12,,0,14,2,1,1,void
3122,45220,verifyClusterNodeId,1,verifyClusterNodeId,"int verifyClusterNodeId (char*,int)",cluster.c,"int verifyClusterNodeId(const char *name, int length) {
    if (length != CLUSTER_NAMELEN) return C_ERR;
    for (int i = 0; i < length; i++) {
        if (name[i] >= 'a' && name[i] <= 'z') continue;
        if (name[i] >= '0' && name[i] <= '9') continue;
        return C_ERR;
    }
    return C_OK;
}",1625.0,1633.0,1.0,18.0,9.0,15,8,12,3,4,0,7,7,0,0,,0,0,4,2,2,int
3123,45287,clusterLookupNode,1,clusterLookupNode,"clusterNode clusterLookupNode (char*,int)",cluster.c,"clusterNode *clusterLookupNode(const char *name, int length) {
    if (verifyClusterNodeId(name, length) != C_OK) return NULL;
    sds s = sdsnewlen(name, length);
    dictEntry *de = dictFind(server.cluster->nodes, s);
    sdsfree(s);
    if (de == NULL) return NULL;
    return dictGetVal(de);
}",1636.0,1643.0,1.0,45.0,8.0,6,5,14,6,8,5,3,3,1,5,,0,3,4,2,2,clusterNode
3124,45367,clusterRenameNode,1,clusterRenameNode,"void clusterRenameNode (clusterNode*,char*)",cluster.c,"void clusterRenameNode(clusterNode *node, char *newname) {
    int retval;
    sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);

    serverLog(LL_DEBUG,""Renaming node %.40s into %.40s"",
        node->name, newname);
    retval = dictDelete(server.cluster->nodes, s);
    sdsfree(s);
    serverAssert(retval == DICT_OK);
    memcpy(node->name, newname, CLUSTER_NAMELEN);
    clusterAddNode(node);
}",1662.0,1673.0,1.0,34.0,12.0,15,10,13,5,1,9,1,1,0,6,,0,5,4,2,2,void
3125,45736,clusterHandleConfigEpochCollision,1,clusterHandleConfigEpochCollision,void clusterHandleConfigEpochCollision (clusterNode*),cluster.c,"void clusterHandleConfigEpochCollision(clusterNode *sender) {
    /* Prerequisites: nodes have the same configEpoch and are both masters. */
    if (sender->configEpoch != myself->configEpoch ||
        !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
    /* Don't act if the colliding node has a smaller Node ID. */
    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
    /* Get the next ID available at the best of this node knowledge. */
    server.cluster->currentEpoch++;
    myself->configEpoch = server.cluster->currentEpoch;
    clusterSaveConfigOrDie(1);
    serverLog(LL_VERBOSE,
        ""WARNING: configEpoch collision with node %.40s (%s).""
        "" configEpoch set to %llu"",
        sender->name,sender->human_nodename,
        (unsigned long long) myself->configEpoch);
}",1822.0,1837.0,1.0,9.0,16.0,28,11,15,3,1,18,3,3,10,2,,0,16,2,1,1,void
3126,45832,clusterBlacklistCleanup,1,clusterBlacklistCleanup,void clusterBlacklistCleanup (void),cluster.c,"void clusterBlacklistCleanup(void) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes_black_list);
    while((de = dictNext(di)) != NULL) {
        int64_t expire = dictGetUnsignedIntegerVal(de);

        if (expire < server.unixtime)
            dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
    }
    dictReleaseIterator(di);
}",1870.0,1882.0,1.0,1.0,13.0,10,5,12,5,2,6,3,4,1,6,,0,4,2,1,1,void
3127,45877,clusterBlacklistAddNode,1,clusterBlacklistAddNode,void clusterBlacklistAddNode (clusterNode*),cluster.c,"void clusterBlacklistAddNode(clusterNode *node) {
    dictEntry *de;
    sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);

    clusterBlacklistCleanup();
    if (dictAdd(server.cluster->nodes_black_list,id,NULL) == DICT_OK) {
        /* If the key was added, duplicate the sds string representation of
         * the key for the next lookup. We'll free it at the end. */
        id = sdsdup(id);
    }
    de = dictFind(server.cluster->nodes_black_list,id);
    dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
    sdsfree(id);
}",1885.0,1898.0,1.0,34.0,14.0,10,5,13,5,0,8,2,2,1,7,,0,5,2,1,1,void
3128,45931,clusterBlacklistExists,1,clusterBlacklistExists,int clusterBlacklistExists (char*),cluster.c,"int clusterBlacklistExists(char *nodeid) {
    sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
    int retval;

    clusterBlacklistCleanup();
    retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
    sdsfree(id);
    return retval;
}",1903.0,1911.0,1.0,30.0,9.0,5,4,8,5,0,4,1,1,0,4,,0,2,2,1,1,int
3129,45961,markNodeAsFailingIfNeeded,1,markNodeAsFailingIfNeeded,void markNodeAsFailingIfNeeded (clusterNode*),cluster.c,"void markNodeAsFailingIfNeeded(clusterNode *node) {
    int failures;
    int needed_quorum = (server.cluster->size / 2) + 1;

    if (!nodeTimedOut(node)) return; /* We can reach it. */
    if (nodeFailed(node)) return; /* Already FAILing. */

    failures = clusterNodeFailureReportsCount(node);
    /* Also count myself as a voter if I'm a master. */
    if (nodeIsMaster(myself)) failures++;
    if (failures < needed_quorum) return; /* No weak agreement from masters. */

    serverLog(LL_NOTICE,
        ""Marking node %.40s (%s) as failing (quorum reached)."", node->name, node->human_nodename);

    /* Mark the node as failing. */
    node->flags &= ~CLUSTER_NODE_PFAIL;
    node->flags |= CLUSTER_NODE_FAIL;
    node->fail_time = mstime();

    /* Broadcast the failing node name to everybody, forcing all the other
     * reachable nodes to flag the node as FAIL.
     * We do that even if this node is a replica and not a master: anyway
     * the failing state is triggered collecting f...",1938.0,1965.0,1.0,9.0,28.0,29,12,20,5,1,16,5,5,5,5,,0,13,2,1,1,void
3130,46084,clearNodeFailureIfNeeded,1,clearNodeFailureIfNeeded,void clearNodeFailureIfNeeded (clusterNode*),cluster.c,"void clearNodeFailureIfNeeded(clusterNode *node) {
    mstime_t now = mstime();

    serverAssert(nodeFailed(node));

    /* For slaves we always clear the FAIL flag if we can contact the
     * node again. */
    if (nodeIsSlave(node) || node->numslots == 0) {
        serverLog(LL_NOTICE,
            ""Clear FAIL state for node %.40s (%s):%s is reachable again."",
                node->name,node->human_nodename,
                nodeIsSlave(node) ? ""replica"" : ""master without slots"");
        node->flags &= ~CLUSTER_NODE_FAIL;
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
    }

    /* If it is a master and...
     * 1) The FAIL state is old enough.
     * 2) It is yet serving slots from our point of view (not failed over).
     * Apparently no one is going to fix these slots, clear the FAIL flag. */
    if (nodeIsMaster(node) && node->numslots > 0 &&
        (now - node->fail_time) >
        (server.cluster_node_timeout * CLUSTER_FAIL_UNDO_TIME_MUL...",1970.0,2000.0,1.0,4.0,31.0,46,18,20,3,0,19,3,3,5,6,,0,14,2,1,1,void
3131,46253,clusterHandshakeInProgress,1,clusterHandshakeInProgress,"int clusterHandshakeInProgress (char*,int,int)",cluster.c,"int clusterHandshakeInProgress(char *ip, int port, int cport) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (!nodeInHandshake(node)) continue;
        if (!strcasecmp(node->ip,ip) &&
            getNodeDefaultClientPort(node) == port &&
            node->cport == cport) break;
    }
    dictReleaseIterator(di);
    return de != NULL;
}",2005.0,2020.0,1.0,13.0,16.0,17,8,18,8,1,8,6,6,5,5,,0,7,6,3,3,int
3132,46321,clusterStartHandshake,1,clusterStartHandshake,"int clusterStartHandshake (char*,int,int)",cluster.c,"int clusterStartHandshake(char *ip, int port, int cport) {
    clusterNode *n;
    char norm_ip[NET_IP_STR_LEN];
    struct sockaddr_storage sa;

    /* IP sanity check */
    if (inet_pton(AF_INET,ip,
            &(((struct sockaddr_in *)&sa)->sin_addr)))
    {
        sa.ss_family = AF_INET;
    } else if (inet_pton(AF_INET6,ip,
            &(((struct sockaddr_in6 *)&sa)->sin6_addr)))
    {
        sa.ss_family = AF_INET6;
    } else {
        errno = EINVAL;
        return 0;
    }

    /* Port sanity check */
    if (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) {
        errno = EINVAL;
        return 0;
    }

    /* Set norm_ip as the normalized string representation of the node
     * IP address. */
    memset(norm_ip,0,NET_IP_STR_LEN);
    if (sa.ss_family == AF_INET)
        inet_ntop(AF_INET,
            (void*)&(((struct sockaddr_in *)&sa)->sin_addr),
            norm_ip,NET_IP_STR_LEN);
    else
        inet_ntop(AF_INET6,
            (void*)&(((struct socka...",2029.0,2084.0,1.0,17.0,56.0,32,11,33,12,0,7,6,6,1,3,,0,6,6,3,3,int
3133,46498,getClientPortFromClusterMsg,1,getClientPortFromClusterMsg,"void getClientPortFromClusterMsg (clusterMsg*,int*,int*)",cluster.c,"static void getClientPortFromClusterMsg(clusterMsg *hdr, int *tls_port, int *tcp_port) {
    if (server.tls_cluster) {
        *tls_port = ntohs(hdr->port);
        *tcp_port = ntohs(hdr->pport);
    } else {
        *tls_port = ntohs(hdr->pport);
        *tcp_port = ntohs(hdr->port);
    }
}",2086.0,2094.0,1.0,1.0,9.0,7,4,5,4,2,2,2,2,0,0,,0,2,6,3,3,void
3134,46540,getClientPortFromGossip,1,getClientPortFromGossip,"void getClientPortFromGossip (clusterMsgDataGossip*,int*,int*)",cluster.c,"static void getClientPortFromGossip(clusterMsgDataGossip *g, int *tls_port, int *tcp_port) {
    if (server.tls_cluster) {
        *tls_port = ntohs(g->port);
        *tcp_port = ntohs(g->pport);
    } else {
        *tls_port = ntohs(g->pport);
        *tcp_port = ntohs(g->port);
    }
}",2096.0,2104.0,1.0,1.0,9.0,7,4,5,4,1,2,2,2,0,0,,0,2,6,3,3,void
3135,46582,clusterProcessGossipSection,1,clusterProcessGossipSection,"void clusterProcessGossipSection (clusterMsg*,clusterLink*)",cluster.c,"void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
    uint16_t count = ntohs(hdr->count);
    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);

    while(count--) {
        uint16_t flags = ntohs(g->flags);
        clusterNode *node;
        sds ci;

        if (server.verbosity == LL_DEBUG) {
            ci = representClusterNodeFlags(sdsempty(), flags);
            serverLog(LL_DEBUG,""GOSSIP %.40s %s:%d@%d %s"",
                g->nodename,
                g->ip,
                ntohs(g->port),
                ntohs(g->cport),
                ci);
            sdsfree(ci);
        }

        /* Convert port and pport into TCP port and TLS port. */
        int msg_tls_port, msg_tcp_port;
        getClientPortFromGossip(g, &msg_tls_port, &msg_tcp_port);

        /* Update our state accordingly to the gossip sections */
        node = cluster...",2110.0,2226.0,1.0,83.0,117.0,107,21,80,13,2,53,11,32,18,12,,0,47,4,2,2,void
3136,47045,nodeIp2String,1,nodeIp2String,"int nodeIp2String (char*,clusterLink*,char*)",cluster.c,"int nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
    if (announced_ip[0] != '\0') {
        memcpy(buf,announced_ip,NET_IP_STR_LEN);
        buf[NET_IP_STR_LEN-1] = '\0'; /* We are not sure the input is sane. */
        return C_OK;
    } else {
        if (connAddrPeerName(link->conn, buf, NET_IP_STR_LEN, NULL) == -1) {
            serverLog(LL_NOTICE, ""Error converting peer IP to string: %s"",
                link->conn ? connGetLastError(link->conn) : ""no link"");
            return C_ERR;
        }
        return C_OK;
    }
}",2231.0,2244.0,1.0,32.0,14.0,5,4,4,2,2,0,2,2,0,0,,0,0,6,3,3,int
3137,47130,nodeUpdateAddressIfNeeded,1,nodeUpdateAddressIfNeeded,"int nodeUpdateAddressIfNeeded (clusterNode*,clusterLink*,clusterMsg*)",cluster.c,"int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
                              clusterMsg *hdr)
{
    char ip[NET_IP_STR_LEN] = {0};
    int cport = ntohs(hdr->cport);
    int tcp_port, tls_port;
    getClientPortFromClusterMsg(hdr, &tls_port, &tcp_port);

    /* We don't proceed if the link is the same as the sender link, as this
     * function is designed to see if the node link is consistent with the
     * symmetric link that is used to receive PINGs from the node.
     *
     * As a side effect this function never frees the passed 'link', so
     * it is safe to call during packet processing. */
    if (link == node->link) return 0;

    /* If the peer IP is unavailable for some reasons like invalid fd or closed
     * link, just give up the update this time, and the update will be retried
     * in the next round of PINGs */
    if (nodeIp2String(ip,link,hdr->myip) == C_ERR) return 0;

    if (node->tcp_port == tcp_port && node->cport == cport && node->tls_...",2258.0,2297.0,1.0,12.0,40.0,46,12,42,9,2,30,6,6,13,7,,0,26,6,3,3,int
3138,47372,clusterUpdateSlotsConfigWith,1,clusterUpdateSlotsConfigWith,"void clusterUpdateSlotsConfigWith (clusterNode*,uint64_t,unsigned char*)",cluster.c,"void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {
    int j;
    clusterNode *curmaster = NULL, *newmaster = NULL;
    /* The dirty slots list is a list of slots for which we lose the ownership
     * while having still keys inside. This usually happens after a failover
     * or after a manual cluster reconfiguration operated by the admin.
     *
     * If the update message is not able to demote a master to slave (in this
     * case we'll resync with the master updating the whole key space), we
     * need to delete all the keys in the slots we lost ownership. */
    uint16_t dirty_slots[CLUSTER_SLOTS];
    int dirty_slots_count = 0;

    /* We should detect if sender is new master of our shard.
     * We will know it if all our slots were migrated to sender, and sender
     * has no slots except ours */
    int sender_slots = 0;
    int migrated_our_slots = 0;

    /* Here we set curmaster to this node or the node this nod...",2329.0,2465.0,1.0,25.0,137.0,82,14,67,13,1,24,13,24,7,12,,0,15,6,3,3,void
3139,47783,getPingExtLength,1,getPingExtLength,uint32_t getPingExtLength (clusterMsgPingExt*),cluster.c,"static uint32_t getPingExtLength(clusterMsgPingExt *ext) {
    return ntohl(ext->length);
}",2478.0,2480.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,uint32_t
3140,47793,getInitialPingExt,1,getInitialPingExt,"clusterMsgPingExt getInitialPingExt (clusterMsg*,int)",cluster.c,"static clusterMsgPingExt *getInitialPingExt(clusterMsg *hdr, int count) {
    clusterMsgPingExt *initial = (clusterMsgPingExt*) &(hdr->data.ping.gossip[count]);
    return initial;
}",2484.0,2487.0,1.0,1.0,4.0,7,6,4,3,3,1,1,1,0,0,,0,1,4,2,2,clusterMsgPingExt
3141,47816,getNextPingExt,1,getNextPingExt,clusterMsgPingExt getNextPingExt (clusterMsgPingExt*),cluster.c,"static clusterMsgPingExt *getNextPingExt(clusterMsgPingExt *ext) {
    clusterMsgPingExt *next = (clusterMsgPingExt *) (((char *) ext) + getPingExtLength(ext));
    return next;
}",2491.0,2494.0,1.0,1.0,4.0,4,3,4,2,2,1,1,1,0,1,,0,1,2,1,1,clusterMsgPingExt
3142,47834,getAlignedPingExtSize,1,getAlignedPingExtSize,uint32_t getAlignedPingExtSize (uint32_t),cluster.c,"uint32_t getAlignedPingExtSize(uint32_t dataSize) {

    return sizeof(clusterMsgPingExt) + EIGHT_BYTE_ALIGN(dataSize);
}",2497.0,2500.0,1.0,39.0,4.0,5,4,3,2,4,0,1,1,0,0,,0,0,2,1,1,uint32_t
3143,47853,getHostnamePingExtSize,1,getHostnamePingExtSize,uint32_t getHostnamePingExtSize (void),cluster.c,"uint32_t getHostnamePingExtSize(void) {
    if (sdslen(myself->hostname) == 0) {
        return 0;
    }
    return getAlignedPingExtSize(sdslen(myself->hostname) + 1);
}",2502.0,2507.0,1.0,1.0,6.0,4,3,2,1,2,7,2,2,3,3,,0,6,2,1,1,uint32_t
3144,47876,getHumanNodenamePingExtSize,1,getHumanNodenamePingExtSize,uint32_t getHumanNodenamePingExtSize (void),cluster.c,"uint32_t getHumanNodenamePingExtSize(void) {
    if (sdslen(myself->human_nodename) == 0) {
        return 0;
    }
    return getAlignedPingExtSize(sdslen(myself->human_nodename) + 1);
}",2509.0,2514.0,1.0,1.0,6.0,4,3,2,1,2,7,2,2,3,3,,0,6,2,1,1,uint32_t
3145,47899,getShardIdPingExtSize,1,getShardIdPingExtSize,uint32_t getShardIdPingExtSize (void),cluster.c,"uint32_t getShardIdPingExtSize(void) {
    return getAlignedPingExtSize(sizeof(clusterMsgPingExtShardId));
}",2516.0,2518.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,uint32_t
3146,47908,getForgottenNodeExtSize,1,getForgottenNodeExtSize,uint32_t getForgottenNodeExtSize (void),cluster.c,"uint32_t getForgottenNodeExtSize(void) {
    return getAlignedPingExtSize(sizeof(clusterMsgPingExtForgottenNode));
}",2520.0,2522.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,1,,0,0,2,1,1,uint32_t
3147,47917,preparePingExt,1,preparePingExt,"void* preparePingExt (clusterMsgPingExt*,uint16_t,uint32_t)",cluster.c,"void *preparePingExt(clusterMsgPingExt *ext, uint16_t type, uint32_t length) {
    ext->type = htons(type);
    ext->length = htonl(length);
    return &ext->ext[0];
}",2524.0,2528.0,1.0,1.0,5.0,7,4,5,3,4,2,1,1,0,0,,0,2,6,3,3,void*
3148,47943,nextPingExt,1,nextPingExt,clusterMsgPingExt nextPingExt (clusterMsgPingExt*),cluster.c,"clusterMsgPingExt *nextPingExt(clusterMsgPingExt *ext) {
    return (clusterMsgPingExt *)((char*)ext + ntohl(ext->length));
}",2530.0,2532.0,1.0,1.0,3.0,4,3,2,1,4,1,1,1,0,0,,0,1,2,1,1,clusterMsgPingExt
3149,47959,writePingExt,1,writePingExt,"uint32_t writePingExt (clusterMsg*,int)",cluster.c,"uint32_t writePingExt(clusterMsg *hdr, int gossipcount)  {
    uint16_t extensions = 0;
    uint32_t totlen = 0;
    clusterMsgPingExt *cursor = NULL;
    /* Set the initial extension position */
    if (hdr != NULL) {
        cursor = getInitialPingExt(hdr, gossipcount);
    }

    /* hostname is optional */
    if (sdslen(myself->hostname) != 0) {
        if (cursor != NULL) {
            /* Populate hostname */
            clusterMsgPingExtHostname *ext = preparePingExt(cursor, CLUSTERMSG_EXT_TYPE_HOSTNAME, getHostnamePingExtSize());
            memcpy(ext->hostname, myself->hostname, sdslen(myself->hostname));

            /* Move the write cursor */
            cursor = nextPingExt(cursor);
        }

        totlen += getHostnamePingExtSize();
        extensions++;
    }

    if (sdslen(myself->human_nodename) != 0) {
        if (cursor != NULL) {
            /* Populate human_nodename */
            clusterMsgPingExtHumanNodename *ext = preparePingExt(cursor, CLUSTERMSG_EXT_T...",2540.0,2619.0,1.0,8.0,80.0,71,13,83,17,0,48,14,22,7,27,,0,40,4,2,2,uint32_t
3150,48239,clusterProcessPingExtensions,1,clusterProcessPingExtensions,"void clusterProcessPingExtensions (clusterMsg*,clusterLink*)",cluster.c,"void clusterProcessPingExtensions(clusterMsg *hdr, clusterLink *link) {
    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
    char *ext_hostname = NULL;
    char *ext_humannodename = NULL;
    char *ext_shardid = NULL;
    uint16_t extensions = ntohs(hdr->extensions);
    /* Loop through all the extensions and process them */
    clusterMsgPingExt *ext = getInitialPingExt(hdr, ntohs(hdr->count));
    while (extensions--) {
        uint16_t type = ntohs(ext->type);
        if (type == CLUSTERMSG_EXT_TYPE_HOSTNAME) {
            clusterMsgPingExtHostname *hostname_ext = (clusterMsgPingExtHostname *) &(ext->ext[0].hostname);
            ext_hostname = hostname_ext->hostname;
	} else if (type == CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME) {
            clusterMsgPingExtHumanNodename *humannodename_ext = (clusterMsgPingExtHumanNodename *) &(ext->ext[0].human_nodename);
            ext_humannodename = humannodename_ext->human_nodename;
        } ...",2623.0,2669.0,1.0,83.0,47.0,25,9,32,12,1,13,3,4,0,6,,0,10,4,2,2,void
3151,48529,getNodeFromLinkAndMsg,1,getNodeFromLinkAndMsg,"clusterNode getNodeFromLinkAndMsg (clusterLink*,clusterMsg*)",cluster.c,"static clusterNode *getNodeFromLinkAndMsg(clusterLink *link, clusterMsg *hdr) {
    clusterNode *sender;
    if (link->node && !nodeInHandshake(link->node)) {
        /* If the link has an associated node, use that so that we don't have to look it
         * up every time, except when the node is still in handshake, the node still has
         * a random name thus not truly ""known"". */
        sender = link->node;
    } else {
        /* Otherwise, fetch sender based on the message */
        sender = clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
        /* We know the sender node but haven't associate it with the link. This must
         * be an inbound link because only for inbound links we didn't know which node
         * to associate when they were created. */
        if (sender && !link->node) {
            setClusterNodeToInboundClusterLink(sender, link);
        }
    }
    return sender;
}",2671.0,2689.0,1.0,23.0,19.0,9,5,6,2,1,4,2,2,3,0,,0,4,4,2,2,clusterNode
3152,48584,clusterProcessPacket,1,clusterProcessPacket,int clusterProcessPacket (clusterLink*),cluster.c,"int clusterProcessPacket(clusterLink *link) {
    clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
    uint32_t totlen = ntohl(hdr->totlen);
    uint16_t type = ntohs(hdr->type);
    mstime_t now = mstime();

    if (type < CLUSTERMSG_TYPE_COUNT)
        server.cluster->stats_bus_messages_received[type]++;
    serverLog(LL_DEBUG,""--- Processing packet of type %s, %lu bytes"",
        clusterGetMessageTypeString(type), (unsigned long) totlen);

    /* Perform sanity checks */
    if (totlen < 16) return 1; /* At least signature, version, totlen, count. */
    if (totlen > link->rcvbuf_len) return 1;

    if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {
        /* Can't handle messages of different versions. */
        return 1;
    }

    if (type == server.cluster_drop_packet_filter) {
        serverLog(LL_WARNING, ""Dropping packet that matches debug drop filter"");
        return 1;
    }

    uint16_t flags = ntohs(hdr->flags);
    uint16_t extensions = ntohs(hdr->extensions);
    uint64_t ...",2700.0,3218.0,1.0,15.0,519.0,320,28,246,26,0,135,45,98,38,52,,0,102,2,1,1,int
3153,50800,handleLinkIOError,1,handleLinkIOError,void handleLinkIOError (clusterLink*),cluster.c,"void handleLinkIOError(clusterLink *link) {
    freeClusterLink(link);
}",3226.0,3228.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
3154,50807,clusterWriteHandler,1,clusterWriteHandler,void clusterWriteHandler (connection*),cluster.c,"void clusterWriteHandler(connection *conn) {
    clusterLink *link = connGetPrivateData(conn);
    ssize_t nwritten;
    size_t totwritten = 0;

    while (totwritten < NET_MAX_WRITES_PER_EVENT && listLength(link->send_msg_queue) > 0) {
        listNode *head = listFirst(link->send_msg_queue);
        clusterMsgSendBlock *msgblock = (clusterMsgSendBlock*)head->value;
        clusterMsg *msg = &msgblock->msg;
        size_t msg_offset = link->head_msg_send_offset;
        size_t msg_len = ntohl(msg->totlen);

        nwritten = connWrite(conn, (char*)msg + msg_offset, msg_len - msg_offset);
        if (nwritten <= 0) {
            serverLog(LL_DEBUG,""I/O error writing to node link: %s"",
                (nwritten == -1) ? connGetLastError(conn) : ""short write"");
            handleLinkIOError(link);
            return;
        }
        if (msg_offset + nwritten < msg_len) {
            /* If full message wasn't written, record the offset
             * and continue sending from this p...",3231.0,3270.0,1.0,24.0,40.0,62,21,52,13,0,24,5,7,4,8,,0,19,2,1,1,void
3155,51014,clusterLinkConnectHandler,1,clusterLinkConnectHandler,void clusterLinkConnectHandler (connection*),cluster.c,"void clusterLinkConnectHandler(connection *conn) {
    clusterLink *link = connGetPrivateData(conn);
    clusterNode *node = link->node;

    /* Check if connection succeeded */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_VERBOSE, ""Connection with Node %.40s at %s:%d failed: %s"",
                node->name, node->ip, node->cport,
                connGetLastError(conn));
        freeClusterLink(link);
        return;
    }

    /* Register a read handler from now on */
    connSetReadHandler(conn, clusterReadHandler);

    /* Queue a PING in the new connection ASAP: this is crucial
     * to avoid false positives in failure detection.
     *
     * If the node is flagged as MEET, we send a MEET message instead
     * of a PING one, to force the receiver to add us in its node
     * table. */
    mstime_t old_ping_sent = node->ping_sent;
    clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?
            CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
...",3275.0,3315.0,1.0,8.0,41.0,25,8,26,7,0,19,3,3,1,8,,0,14,2,1,1,void
3156,51496,clusterSendMessage,1,clusterSendMessage,"void clusterSendMessage (clusterLink*,clusterMsgSendBlock*)",cluster.c,"void clusterSendMessage(clusterLink *link, clusterMsgSendBlock *msgblock) {
    if (!link) {
        return;
    }
    if (listLength(link->send_msg_queue) == 0 && msgblock->msg.totlen != 0)
        connSetWriteHandlerWithBarrier(link->conn, clusterWriteHandler, 1);

    listAddNodeTail(link->send_msg_queue, msgblock);
    msgblock->refcount++;

    /* Update memory tracking */
    link->send_msg_queue_mem += sizeof(listNode) + msgblock->totlen;
    server.stat_cluster_links_memory += sizeof(listNode);

    /* Populate sent messages stats. */
    uint16_t type = ntohs(msgblock->msg.type);
    if (type < CLUSTERMSG_TYPE_COUNT)
        server.cluster->stats_bus_messages_sent[type]++;
}",3409.0,3427.0,1.0,8.0,19.0,29,13,18,5,5,11,4,4,3,2,,0,9,4,2,2,void
3157,51584,clusterBroadcastMessage,1,clusterBroadcastMessage,void clusterBroadcastMessage (clusterMsgSendBlock*),cluster.c,"void clusterBroadcastMessage(clusterMsgSendBlock *msgblock) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        clusterSendMessage(node->link,msgblock);
    }
    dictReleaseIterator(di);
}",3435.0,3448.0,1.0,27.0,14.0,10,6,11,6,2,7,4,4,2,5,,0,5,2,1,1,void
3158,51930,clusterSetGossipEntry,1,clusterSetGossipEntry,"void clusterSetGossipEntry (clusterMsg*,int,clusterNode*)",cluster.c,"void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
    clusterMsgDataGossip *gossip;
    gossip = &(hdr->data.ping.gossip[i]);
    memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
    gossip->ping_sent = htonl(n->ping_sent/1000);
    gossip->pong_received = htonl(n->pong_received/1000);
    memcpy(gossip->ip,n->ip,sizeof(n->ip));
    if (server.tls_cluster) {
        gossip->port = htons(n->tls_port);
        gossip->pport = htons(n->tcp_port);
    } else {
        gossip->port = htons(n->tcp_port);
        gossip->pport = htons(n->tls_port);
    }
    gossip->cport = htons(n->cport);
    gossip->flags = htons(n->flags);
    gossip->notused1 = 0;
}",3518.0,3535.0,1.0,36.0,18.0,35,7,22,5,0,19,2,2,0,0,,0,19,6,3,3,void
3159,52442,clusterBroadcastPong,1,clusterBroadcastPong,void clusterBroadcastPong (int),cluster.c,"void clusterBroadcastPong(int target) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (!node->link) continue;
        if (node == myself || nodeInHandshake(node)) continue;
        if (target == CLUSTER_BROADCAST_LOCAL_SLAVES) {
            int local_slave =
                nodeIsSlave(node) && node->slaveof &&
                (node->slaveof == myself || node->slaveof == myself->slaveof);
            if (!local_slave) continue;
        }
        clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
    }
    dictReleaseIterator(di);
}",3685.0,3704.0,1.0,30.0,20.0,27,9,24,8,1,16,9,11,4,5,,0,14,2,1,1,void
3160,52542,clusterCreatePublishMsgBlock,1,clusterCreatePublishMsgBlock,"clusterMsgSendBlock clusterCreatePublishMsgBlock (robj*,robj*,uint16_t)",cluster.c,"clusterMsgSendBlock *clusterCreatePublishMsgBlock(robj *channel, robj *message, uint16_t type) {

    uint32_t channel_len, message_len;

    channel = getDecodedObject(channel);
    message = getDecodedObject(message);
    channel_len = sdslen(channel->ptr);
    message_len = sdslen(message->ptr);

    size_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    msglen += sizeof(clusterMsgDataPublish) - 8 + channel_len + message_len;
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(type, msglen);

    clusterMsg *hdr = &msgblock->msg;
    hdr->data.publish.msg.channel_len = htonl(channel_len);
    hdr->data.publish.msg.message_len = htonl(message_len);
    memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));
    memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),
        message->ptr,sdslen(message->ptr));

    decrRefCount(channel);
    decrRefCount(message);
    
    return msgblock;
}",3713.0,3737.0,1.0,1.0,25.0,43,8,34,11,2,15,1,1,0,10,,0,10,6,3,3,clusterMsgSendBlock
3161,52862,clusterSendModule,1,clusterSendModule,"void clusterSendModule (clusterLink*,uint64_t,uint8_t,char*,uint32_t)",cluster.c,"void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
                       const char *payload, uint32_t len) {
    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    msglen += sizeof(clusterMsgModule) - 3 + len;
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_MODULE, msglen);

    clusterMsg *hdr = &msgblock->msg;
    hdr->data.module.msg.module_id = module_id; /* Already endian adjusted. */
    hdr->data.module.msg.type = type;
    hdr->data.module.msg.len = htonl(len);
    memcpy(hdr->data.module.msg.bulk_data,payload,len);

    if (link)
        clusterSendMessage(link,msgblock);
    else
        clusterBroadcastMessage(msgblock);

    clusterMsgSendBlockDecrRefCount(msgblock);
}",3782.0,3800.0,1.0,62.0,19.0,31,8,23,11,1,8,2,2,0,3,,0,6,10,5,5,void
3162,52960,clusterSendModuleMessageToTarget,1,clusterSendModuleMessageToTarget,"int clusterSendModuleMessageToTarget (char*,uint64_t,uint8_t,char*,uint32_t)",cluster.c,"int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, const char *payload, uint32_t len) {
    clusterNode *node = NULL;

    if (target != NULL) {
        node = clusterLookupNode(target, strlen(target));
        if (node == NULL || node->link == NULL) return C_ERR;
    }

    clusterSendModule(target ? node->link : NULL,
                      module_id, type, payload, len);
    return C_OK;
}",3808.0,3819.0,1.0,55.0,12.0,10,7,18,7,1,4,3,4,1,2,,0,3,10,5,5,int
3163,53015,clusterPropagatePublish,1,clusterPropagatePublish,"void clusterPropagatePublish (robj*,robj*,int)",cluster.c,"void clusterPropagatePublish(robj *channel, robj *message, int sharded) {
    clusterMsgSendBlock *msgblock;

    if (!sharded) {
        msgblock = clusterCreatePublishMsgBlock(channel, message, CLUSTERMSG_TYPE_PUBLISH);
        clusterBroadcastMessage(msgblock);
        clusterMsgSendBlockDecrRefCount(msgblock);
        return;
    }

    listIter li;
    listNode *ln;
    list *nodes_for_slot = clusterGetNodesInMyShard(server.cluster->myself);
    serverAssert(nodes_for_slot != NULL);
    listRewind(nodes_for_slot, &li);
    msgblock = clusterCreatePublishMsgBlock(channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD);
    while((ln = listNext(&li))) {
        clusterNode *node = listNodeValue(ln);
        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        clusterSendMessage(node->link,msgblock);
    }
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3831.0,3854.0,1.0,66.0,24.0,20,12,24,10,1,13,5,5,2,10,,0,7,6,3,3,void
3164,53116,clusterRequestFailoverAuth,1,clusterRequestFailoverAuth,void clusterRequestFailoverAuth (void),cluster.c,"void clusterRequestFailoverAuth(void) {
    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST, msglen);

    clusterMsg *hdr = &msgblock->msg;
    /* If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit
     * in the header to communicate the nodes receiving the message that
     * they should authorized the failover even if the master is working. */
    if (server.cluster->mf_end) hdr->mflags[0] |= CLUSTERMSG_FLAG0_FORCEACK;
    clusterBroadcastMessage(msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3866.0,3877.0,1.0,62.0,12.0,13,8,11,6,0,5,2,2,0,3,,0,3,2,1,1,void
3165,53166,clusterSendFailoverAuth,1,clusterSendFailoverAuth,void clusterSendFailoverAuth (clusterNode*),cluster.c,"void clusterSendFailoverAuth(clusterNode *node) {
    if (!node->link) return;

    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK, msglen);

    clusterSendMessage(node->link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3880.0,3888.0,1.0,62.0,9.0,8,5,9,5,0,5,2,2,1,3,,0,3,2,1,1,void
3166,53201,clusterSendMFStart,1,clusterSendMFStart,void clusterSendMFStart (clusterNode*),cluster.c,"void clusterSendMFStart(clusterNode *node) {
    if (!node->link) return;

    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_MFSTART, msglen);

    clusterSendMessage(node->link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",3891.0,3899.0,1.0,62.0,9.0,8,5,9,5,0,5,2,2,1,3,,0,3,2,1,1,void
3167,53743,clusterGetSlaveRank,1,clusterGetSlaveRank,int clusterGetSlaveRank (void),cluster.c,"int clusterGetSlaveRank(void) {
    long long myoffset;
    int j, rank = 0;
    clusterNode *master;

    serverAssert(nodeIsSlave(myself));
    master = myself->slaveof;
    if (master == NULL) return 0; /* Never called by slaves without master. */

    myoffset = replicationGetSlaveOffset();
    for (j = 0; j < master->numslaves; j++)
        if (master->slaves[j] != myself &&
            !nodeCantFailover(master->slaves[j]) &&
            master->slaves[j]->repl_offset > myoffset) rank++;
    return rank;
}",4017.0,4032.0,1.0,4.0,16.0,14,9,11,6,0,7,3,3,1,2,,0,6,2,1,1,int
3168,53841,clusterLogCantFailover,1,clusterLogCantFailover,void clusterLogCantFailover (int),cluster.c,"void clusterLogCantFailover(int reason) {
    char *msg;
    static time_t lastlog_time = 0;
    mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;

    /* Don't log if we have the same reason for some time. */
    if (reason == server.cluster->cant_failover_reason &&
        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
        return;

    server.cluster->cant_failover_reason = reason;

    /* We also don't emit any log if the master failed no long ago, the
     * goal of this function is to log slaves in a stalled condition for
     * a long time. */
    if (myself->slaveof &&
        nodeFailed(myself->slaveof) &&
        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;

    switch(reason) {
    case CLUSTER_CANT_FAILOVER_DATA_AGE:
        msg = ""Disconnected from master for longer than allowed. ""
              ""Please check the 'cluster-replica-validity-factor' configuration ""
              ""option."";
        break;
    case CLUSTER...",4056.0,4103.0,1.0,34.0,48.0,47,11,33,9,0,11,10,5,9,3,,0,9,2,1,1,void
3169,54030,clusterFailoverReplaceYourMaster,1,clusterFailoverReplaceYourMaster,void clusterFailoverReplaceYourMaster (void),cluster.c,"void clusterFailoverReplaceYourMaster(void) {
    int j;
    clusterNode *oldmaster = myself->slaveof;

    if (nodeIsMaster(myself) || oldmaster == NULL) return;

    /* 1) Turn this node into a master. */
    clusterSetNodeAsMaster(myself);
    replicationUnsetMaster();

    /* 2) Claim all the slots assigned to our master. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (clusterNodeGetSlotBit(oldmaster,j)) {
            clusterDelSlot(j);
            clusterAddSlot(myself,j);
        }
    }

    /* 3) Update state and save config. */
    clusterUpdateState();
    clusterSaveConfigOrDie(1);

    /* 4) Pong all the other nodes so that they can update the state
     *    accordingly and detect that we switched to master role. */
    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);

    /* 5) If there was a manual failover in progress, clear the state. */
    resetManualFailover();
}",4111.0,4139.0,1.0,8.0,29.0,8,6,14,4,0,16,4,5,4,9,,0,8,2,1,1,void
3170,55043,manualFailoverCheckTimeout,1,manualFailoverCheckTimeout,void manualFailoverCheckTimeout (void),cluster.c,"void manualFailoverCheckTimeout(void) {
    if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
        serverLog(LL_WARNING,""Manual failover timed out."");
        resetManualFailover();
    }
}",4479.0,4484.0,1.0,8.0,6.0,9,5,3,1,1,3,2,2,1,3,,0,1,2,1,1,void
3171,55082,clusterHandleManualFailover,1,clusterHandleManualFailover,void clusterHandleManualFailover (void),cluster.c,"void clusterHandleManualFailover(void) {
    /* Return ASAP if no manual failover is in progress. */
    if (server.cluster->mf_end == 0) return;

    /* If mf_can_start is non-zero, the failover was already triggered so the
     * next steps are performed by clusterHandleSlaveFailover(). */
    if (server.cluster->mf_can_start) return;

    if (server.cluster->mf_master_offset == -1) return; /* Wait for offset... */

    if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
        /* Our replication offset matches the master replication offset
         * announced after clients were paused. We can start the failover. */
        server.cluster->mf_can_start = 1;
        serverLog(LL_NOTICE,
            ""All master replication stream processed, ""
            ""manual failover can start."");
        clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
        return;
    }
    clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_MANUALFAILOVER);
}",4488.0,4509.0,1.0,8.0,22.0,20,8,6,1,2,4,5,5,1,4,,0,1,2,1,1,void
3172,55163,clusterNodeCronHandleReconnect,1,clusterNodeCronHandleReconnect,"int clusterNodeCronHandleReconnect (clusterNode*,mstime_t,mstime_t)",cluster.c,"static int clusterNodeCronHandleReconnect(clusterNode *node, mstime_t handshake_timeout, mstime_t now) {
    /* Not interested in reconnecting the link with myself or nodes
     * for which we have no address. */
    if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) return 1;

    if (node->flags & CLUSTER_NODE_PFAIL)
        server.cluster->stats_pfail_nodes++;

    /* A Node in HANDSHAKE state has a limited lifespan equal to the
     * configured node timeout. */
    if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
        clusterDelNode(node);
        return 1;
    }

    if (node->link == NULL) {
        clusterLink *link = createClusterLink(node);
        link->conn = connCreate(connTypeOfCluster());
        connSetPrivateData(link->conn, link);
        if (connConnect(link->conn, node->ip, node->cport, server.bind_source_addr,
                    clusterLinkConnectHandler) == C_ERR) {
            /* We got a synchronous error from connect before...",4518.0,4554.0,1.0,23.0,37.0,36,12,27,6,1,23,7,10,10,9,,0,19,6,3,3,int
3173,55311,freeClusterLinkOnBufferLimitReached,1,freeClusterLinkOnBufferLimitReached,void freeClusterLinkOnBufferLimitReached (clusterLink*),cluster.c,"static void freeClusterLinkOnBufferLimitReached(clusterLink *link) {
    if (link == NULL || server.cluster_link_msg_queue_limit_bytes == 0) {
        return;
    }

    unsigned long long mem_link = link->send_msg_queue_mem;
    if (mem_link > server.cluster_link_msg_queue_limit_bytes) {
        serverLog(LL_WARNING, ""Freeing cluster link(%s node %.40s, used memory: %llu) due to ""
                ""exceeding send buffer memory limit."", link->inbound ? ""from"" : ""to"",
                link->node ? link->node->name : """", mem_link);
        freeClusterLink(link);
        server.cluster->stat_cluster_links_buffer_limit_exceeded++;
    }
}",4556.0,4569.0,1.0,8.0,14.0,20,10,14,4,2,6,3,3,0,2,,0,4,2,1,1,void
3174,55384,clusterNodeCronFreeLinkOnBufferLimitReached,1,clusterNodeCronFreeLinkOnBufferLimitReached,void clusterNodeCronFreeLinkOnBufferLimitReached (clusterNode*),cluster.c,"static void clusterNodeCronFreeLinkOnBufferLimitReached(clusterNode *node) {
    freeClusterLinkOnBufferLimitReached(node->link);
    freeClusterLinkOnBufferLimitReached(node->inbound_link);
}",4572.0,4575.0,1.0,1.0,4.0,2,1,2,1,1,4,1,1,0,2,,0,2,2,1,1,void
3175,55397,clusterCron,1,clusterCron,void clusterCron (void),cluster.c,"void clusterCron(void) {
    dictIterator *di;
    dictEntry *de;
    int update_state = 0;
    int orphaned_masters; /* How many masters there are without ok slaves. */
    int max_slaves; /* Max number of ok slaves for a single master. */
    int this_slaves; /* Number of ok slaves for our master (if we are slave). */
    mstime_t min_pong = 0, now = mstime();
    clusterNode *min_pong_node = NULL;
    static unsigned long long iteration = 0;
    mstime_t handshake_timeout;

    iteration++; /* Number of times this function was called so far. */

    clusterUpdateMyselfHostname();

    /* The handshake timeout is the time after which a handshake node that was
     * not turned into a normal node is removed from the nodes. Usually it is
     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use
     * the value of 1 second. */
    handshake_timeout = server.cluster_node_timeout;
    if (handshake_timeout < 1000) handshake_timeout = 1000;

    /* Clear so clusterN...",4578.0,4779.0,1.0,31.0,202.0,184,19,146,22,1,81,34,53,41,29,,0,65,2,1,1,void
3176,56022,clusterBeforeSleep,1,clusterBeforeSleep,void clusterBeforeSleep (void),cluster.c,"void clusterBeforeSleep(void) {
    int flags = server.cluster->todo_before_sleep;

    /* Reset our flags (not strictly needed since every single function
     * called for flags set should be able to clear its flag). */
    server.cluster->todo_before_sleep = 0;

    if (flags & CLUSTER_TODO_HANDLE_MANUALFAILOVER) {
        /* Handle manual failover as soon as possible so that won't have a 100ms
         * as it was handled only in clusterCron */
        if(nodeIsSlave(myself)) {
            clusterHandleManualFailover();
            if (!(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
                clusterHandleSlaveFailover();
        }
    } else if (flags & CLUSTER_TODO_HANDLE_FAILOVER) {
        /* Handle failover, this is needed when it is likely that there is already
         * the quorum from masters in order to react fast. */
        clusterHandleSlaveFailover();
    }

    /* Update the cluster state. */
    if (flags & CLUSTER_TODO_UPDATE_STATE)
     ...",4786.0,4816.0,1.0,16.0,31.0,21,6,12,4,1,7,6,9,3,4,,0,3,2,1,1,void
3177,56209,clusterMastersHaveSlaves,1,clusterMastersHaveSlaves,int clusterMastersHaveSlaves (void),cluster.c,"int clusterMastersHaveSlaves(void) {
    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
    dictEntry *de;
    int slaves = 0;
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (nodeIsSlave(node)) continue;
        slaves += node->numslaves;
    }
    dictReleaseIterator(di);
    return slaves != 0;
}",4851.0,4863.0,1.0,12.0,13.0,12,6,14,6,0,6,4,4,2,4,,0,5,2,1,1,int
3178,56308,clusterNodeClearSlotBit,1,clusterNodeClearSlotBit,"int clusterNodeClearSlotBit (clusterNode*,int)",cluster.c,"int clusterNodeClearSlotBit(clusterNode *n, int slot) {
    int old = bitmapTestBit(n->slots,slot);
    if (old) {
        bitmapClearBit(n->slots,slot);
        n->numslots--;
    }
    return old;
}",4891.0,4898.0,1.0,1.0,8.0,5,3,8,3,0,5,2,2,0,2,,0,4,4,2,2,int
3179,56856,verifyClusterConfigWithData,1,verifyClusterConfigWithData,int verifyClusterConfigWithData (void),cluster.c,"int verifyClusterConfigWithData(void) {
    int j;
    int update_config = 0;

    /* Return ASAP if a module disabled cluster redirections. In that case
     * every master can store keys about every possible hash slot. */
    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
        return C_OK;

    /* If this node is a slave, don't perform the check at all as we
     * completely depend on the replication stream. */
    if (nodeIsSlave(myself)) return C_OK;

    /* Make sure we only have keys in DB0. */
    for (j = 1; j < server.dbnum; j++) {
        if (dictSize(server.db[j].dict)) return C_ERR;
    }

    /* Check that all the slots we see populated memory have a corresponding
     * entry in the cluster table. Otherwise fix the table. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (!countKeysInSlot(j)) continue; /* No keys in this slot. */
        /* Check if we are assigned to this slot or if we are importing it.
         * In both cases check t...",5090.0,5137.0,1.0,38.0,48.0,44,14,31,5,0,9,12,14,5,4,,0,6,2,1,1,int
3180,57341,clusterGenNodeDescription,1,clusterGenNodeDescription,"sds clusterGenNodeDescription (client*,clusterNode*,int)",cluster.c,"sds clusterGenNodeDescription(client *c, clusterNode *node, int tls_primary) {
    int j, start;
    sds ci;
    int port = getNodeClientPort(node, tls_primary);

    /* Node coordinates */
    ci = sdscatlen(sdsempty(),node->name,CLUSTER_NAMELEN);
    ci = sdscatfmt(ci,"" %s:%i@%i"",
        node->ip,
        port,
        node->cport);
    if (sdslen(node->hostname) != 0) {
        ci = sdscatfmt(ci,"",%s"", node->hostname);
    }
    if (sdslen(node->hostname) == 0) {
        ci = sdscatfmt(ci,"","", 1);
    }
    /* Don't expose aux fields to any clients yet but do allow them
     * to be persisted to nodes.conf */
    if (c == NULL) {
        for (int i = af_count-1; i >=0; i--) {
            if ((tls_primary && i == af_tls_port) || (!tls_primary && i == af_tcp_port)) {
                continue;
            }
            if (auxFieldHandlers[i].isPresent(node)) {
                ci = sdscatprintf(ci, "",%s="", auxFieldHandlers[i].field);
                ci = auxFieldHandlers[i].getter(...",5219.0,5313.0,1.0,41.0,95.0,74,15,81,14,1,40,14,21,10,16,,0,40,6,3,3,sds
3181,57765,clusterGenNodesSlotsInfo,1,clusterGenNodesSlotsInfo,void clusterGenNodesSlotsInfo (int),cluster.c,"void clusterGenNodesSlotsInfo(int filter) {
    clusterNode *n = NULL;
    int start = -1;

    for (int i = 0; i <= CLUSTER_SLOTS; i++) {
        /* Find start node and slot id. */
        if (n == NULL) {
            if (i == CLUSTER_SLOTS) break;
            n = server.cluster->slots[i];
            start = i;
            continue;
        }

        /* Generate slots info when occur different node with start
         * or end of slot. */
        if (i == CLUSTER_SLOTS || n != server.cluster->slots[i]) {
            if (!(n->flags & filter)) {
                if (!n->slot_info_pairs) {
                    n->slot_info_pairs = zmalloc(2 * n->numslots * sizeof(uint16_t));
                }
                serverAssert((n->slot_info_pairs_count + 1) < (2 * n->numslots));
                n->slot_info_pairs[n->slot_info_pairs_count++] = start;
                n->slot_info_pairs[n->slot_info_pairs_count++] = i-1;
            }
            if (i == CLUSTER_SLOTS) break;
            n = ...",5319.0,5348.0,1.0,25.0,30.0,55,21,37,7,2,12,11,19,2,2,,0,11,2,1,1,void
3182,57948,clusterGenNodesDescription,1,clusterGenNodesDescription,"sds clusterGenNodesDescription (client*,int,int)",cluster.c,"sds clusterGenNodesDescription(client *c, int filter, int tls_primary) {
    sds ci = sdsempty(), ni;
    dictIterator *di;
    dictEntry *de;

    /* Generate all nodes slots info firstly. */
    clusterGenNodesSlotsInfo(filter);

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node->flags & filter) continue;
        ni = clusterGenNodeDescription(c, node, tls_primary);
        ci = sdscatsds(ci,ni);
        sdsfree(ni);
        ci = sdscatlen(ci,""\n"",1);

        /* Release slots info. */
        clusterFreeNodesSlotsInfo(node);
    }
    dictReleaseIterator(di);
    return ci;
}",5371.0,5394.0,1.0,1.0,24.0,12,5,24,10,2,12,4,4,2,11,,0,8,6,3,3,sds
3183,58018,addReplyClusterLinkDescription,1,addReplyClusterLinkDescription,"void addReplyClusterLinkDescription (client*,clusterLink*)",cluster.c,"void addReplyClusterLinkDescription(client *c, clusterLink *link) {
    addReplyMapLen(c, 6);

    addReplyBulkCString(c, ""direction"");
    addReplyBulkCString(c, link->inbound ? ""from"" : ""to"");

    /* addReplyClusterLinkDescription is only called for links that have been
     * associated with nodes. The association is always bi-directional, so
     * in addReplyClusterLinkDescription, link->node should never be NULL. */
    serverAssert(link->node);
    sds node_name = sdsnewlen(link->node->name, CLUSTER_NAMELEN);
    addReplyBulkCString(c, ""node"");
    addReplyBulkCString(c, node_name);
    sdsfree(node_name);

    addReplyBulkCString(c, ""create-time"");
    addReplyLongLong(c, link->ctime);

    char events[3], *p;
    p = events;
    if (link->conn) {
        if (connHasReadHandler(link->conn)) *p++ = 'r';
        if (connHasWriteHandler(link->conn)) *p++ = 'w';
    }
    *p = '\0';
    addReplyBulkCString(c, ""events"");
    addReplyBulkCString(c, events);

    addReplyBulkCStri...",5398.0,5431.0,1.0,4.0,34.0,26,8,32,5,2,28,4,6,5,18,,0,13,4,2,2,void
3184,58143,addReplyClusterLinksDescription,1,addReplyClusterLinksDescription,void addReplyClusterLinksDescription (client*),cluster.c,"void addReplyClusterLinksDescription(client *c) {
    dictIterator *di;
    dictEntry *de;
    void *arraylen_ptr = NULL;
    int num_links = 0;

    arraylen_ptr = addReplyDeferredLen(c);

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->link) {
            num_links++;
            addReplyClusterLinkDescription(c, node->link);
        }
        if (node->inbound_link) {
            num_links++;
            addReplyClusterLinkDescription(c, node->inbound_link);
        }
    }
    dictReleaseIterator(di);

    setDeferredArrayLen(c, arraylen_ptr, num_links);
}",5435.0,5458.0,1.0,1.0,24.0,15,5,24,8,0,12,4,6,3,8,,0,8,2,1,1,void
3185,58213,getPreferredEndpoint,1,getPreferredEndpoint,const char* getPreferredEndpoint (clusterNode*),cluster.c,"const char *getPreferredEndpoint(clusterNode *n) {
    switch(server.cluster_preferred_endpoint_type) {
    case CLUSTER_ENDPOINT_TYPE_IP: return n->ip;
    case CLUSTER_ENDPOINT_TYPE_HOSTNAME: return (sdslen(n->hostname) != 0) ? n->hostname : ""?"";
    case CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT: return """";
    }
    return ""unknown"";
}",5464.0,5471.0,1.0,1.0,8.0,6,4,7,5,1,4,2,2,0,1,,0,3,2,1,1,const char*
3186,58325,getSlotOrReply,1,getSlotOrReply,"int getSlotOrReply (client*,robj*)",cluster.c,"int getSlotOrReply(client *c, robj *o) {
    long long slot;

    if (getLongLongFromObject(o,&slot) != C_OK ||
        slot < 0 || slot >= CLUSTER_SLOTS)
    {
        addReplyError(c,""Invalid or out of range slot"");
        return -1;
    }
    return (int) slot;
}",5490.0,5500.0,1.0,42.0,11.0,8,7,6,3,0,2,2,2,1,2,,0,1,4,2,2,int
3187,58362,isReplicaAvailable,1,isReplicaAvailable,int isReplicaAvailable (clusterNode*),cluster.c,"static int isReplicaAvailable(clusterNode *node) {
    if (nodeFailed(node)) {
        return 0;
    }
    long long repl_offset = node->repl_offset;
    if (node->flags & CLUSTER_NODE_MYSELF) {
        /* Nodes do not update their own information
         * in the cluster node list. */
        repl_offset = replicationGetSlaveOffset();
    }
    return (repl_offset != 0);
}",5507.0,5518.0,1.0,8.0,12.0,8,4,7,2,2,4,3,3,2,1,,0,4,2,1,1,int
3188,58401,checkSlotAssignmentsOrReply,1,checkSlotAssignmentsOrReply,"int checkSlotAssignmentsOrReply (client*,unsigned char*,int,int,int)",cluster.c,"int checkSlotAssignmentsOrReply(client *c, unsigned char *slots, int del, int start_slot, int end_slot) {
    int slot;
    for (slot = start_slot; slot <= end_slot; slot++) {
        if (del && server.cluster->slots[slot] == NULL) {
            addReplyErrorFormat(c,""Slot %d is already unassigned"", slot);
            return C_ERR;
        } else if (!del && server.cluster->slots[slot]) {
            addReplyErrorFormat(c,""Slot %d is already busy"", slot);
            return C_ERR;
        }
        if (slots[slot]++ == 1) {
            addReplyErrorFormat(c,""Slot %d specified multiple times"",(int)slot);
            return C_ERR;
        }
    }
    return C_OK;
}",5520.0,5536.0,1.0,19.0,17.0,13,10,14,8,0,2,4,6,0,2,,0,0,10,5,5,int
3189,58490,clusterUpdateSlots,1,clusterUpdateSlots,"void clusterUpdateSlots (client*,unsigned char*,int)",cluster.c,"void clusterUpdateSlots(client *c, unsigned char *slots, int del) {
    int j;
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (slots[j]) {
            int retval;
                
            /* If this slot was set as importing we can clear this
             * state as now we are the real owner of the slot. */
            if (server.cluster->importing_slots_from[j])
                server.cluster->importing_slots_from[j] = NULL;

            retval = del ? clusterDelSlot(j) :
                           clusterAddSlot(myself,j);
            serverAssertWithInfo(c,NULL,retval == C_OK);
        }
    }
}",5538.0,5554.0,1.0,20.0,17.0,17,10,19,8,0,4,4,7,0,3,,0,3,6,3,3,void
3190,58564,addNodeToNodeReply,1,addNodeToNodeReply,"void addNodeToNodeReply (client*,clusterNode*)",cluster.c,"void addNodeToNodeReply(client *c, clusterNode *node) {
    addReplyArrayLen(c, 4);
    if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_IP) {
        addReplyBulkCString(c, node->ip);
    } else if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_HOSTNAME) {
        if (sdslen(node->hostname) != 0) {
            addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));
        } else {
            addReplyBulkCString(c, ""?"");
        }
    } else if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT) {
        addReplyNull(c);
    } else {
        serverPanic(""Unrecognized preferred endpoint type"");
    }

    /* Report TLS ports to TLS client, and report non-TLS port to non-TLS client. */
    addReplyLongLong(c, getNodeClientPort(node, connIsTLS(c->conn)));
    addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);

    /* Add the additional endpoint information, this is all the known networking information
    ...",5556.0,5604.0,1.0,8.0,49.0,32,12,35,6,2,23,6,6,4,15,,0,13,4,2,2,void
3191,58746,addNodeReplyForClusterSlot,1,addNodeReplyForClusterSlot,"void addNodeReplyForClusterSlot (client*,clusterNode*,int,int)",cluster.c,"void addNodeReplyForClusterSlot(client *c, clusterNode *node, int start_slot, int end_slot) {
    int i, nested_elements = 3; /* slots (2) + master addr (1) */
    for (i = 0; i < node->numslaves; i++) {
        if (!isReplicaAvailable(node->slaves[i])) continue;
        nested_elements++;
    }
    addReplyArrayLen(c, nested_elements);
    addReplyLongLong(c, start_slot);
    addReplyLongLong(c, end_slot);
    addNodeToNodeReply(c, node);

    /* Remaining nodes in reply are replicas for slot range */
    for (i = 0; i < node->numslaves; i++) {
        /* This loop is copy/pasted from clusterGenNodeDescription()
         * with modifications for per-slot node aggregation. */
        if (!isReplicaAvailable(node->slaves[i])) continue;
        addNodeToNodeReply(c, node->slaves[i]);
        nested_elements--;
    }
    serverAssert(nested_elements == 3); /* Original 3 elements */
}",5606.0,5626.0,1.0,4.0,21.0,22,12,25,6,1,13,7,7,6,8,,0,7,8,4,4,void
3192,58844,addNodeDetailsToShardReply,1,addNodeDetailsToShardReply,"void addNodeDetailsToShardReply (client*,clusterNode*)",cluster.c,"void addNodeDetailsToShardReply(client *c, clusterNode *node) {
    int reply_count = 0;
    void *node_replylen = addReplyDeferredLen(c);
    addReplyBulkCString(c, ""id"");
    addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);
    reply_count++;

    if (node->tcp_port) {
        addReplyBulkCString(c, ""port"");
        addReplyLongLong(c, node->tcp_port);
        reply_count++;
    }

    if (node->tls_port) {
        addReplyBulkCString(c, ""tls-port"");
        addReplyLongLong(c, node->tls_port);
        reply_count++;
    }

    addReplyBulkCString(c, ""ip"");
    addReplyBulkCString(c, node->ip);
    reply_count++;

    addReplyBulkCString(c, ""endpoint"");
    addReplyBulkCString(c, getPreferredEndpoint(node));
    reply_count++;

    if (sdslen(node->hostname) != 0) {
        addReplyBulkCString(c, ""hostname"");
        addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));
        reply_count++;
    }

    long long node_offset;
    if (node->flags & CLUSTER_NODE_MYSELF...",5629.0,5690.0,1.0,39.0,62.0,35,7,57,8,1,37,6,6,6,24,,0,18,4,2,2,void
3193,59054,addShardReplyForClusterShards,1,addShardReplyForClusterShards,"void addShardReplyForClusterShards (client*,list*)",cluster.c,"void addShardReplyForClusterShards(client *c, list *nodes) {
    serverAssert(listLength(nodes) > 0);
    clusterNode *n = listNodeValue(listFirst(nodes));
    addReplyMapLen(c, 2);
    addReplyBulkCString(c, ""slots"");

    /* Use slot_info_pairs from the primary only */
    while (n->slaveof != NULL) n = n->slaveof;

    if (n->slot_info_pairs != NULL) {
        serverAssert((n->slot_info_pairs_count % 2) == 0);
        addReplyArrayLen(c, n->slot_info_pairs_count);
        for (int i = 0; i < n->slot_info_pairs_count; i++)
            addReplyBulkLongLong(c, (unsigned long)n->slot_info_pairs[i]);
    } else {
        /* If no slot info pair is provided, the node owns no slots */
        addReplyArrayLen(c, 0);
    }

    addReplyBulkCString(c, ""nodes"");
    addReplyArrayLen(c, listLength(nodes));
    listIter li;
    listRewind(nodes, &li);
    for (listNode *ln = listNext(&li); ln != NULL; ln = listNext(&li)) {
        clusterNode *n = listNodeValue(ln);
        addNodeDetailsToS...",5693.0,5721.0,1.0,4.0,29.0,31,12,31,7,1,19,5,6,3,11,,0,9,4,2,2,void
3194,59211,clusterReplyShards,1,clusterReplyShards,void clusterReplyShards (client*),cluster.c,"void clusterReplyShards(client *c) {
    addReplyArrayLen(c, dictSize(server.cluster->shards));
    /* This call will add slot_info_pairs to all nodes */
    clusterGenNodesSlotsInfo(0);
    dictIterator *di = dictGetSafeIterator(server.cluster->shards);
    for(dictEntry *de = dictNext(di); de != NULL; de = dictNext(di)) {
        addShardReplyForClusterShards(c, dictGetVal(de));
    }
    dictReleaseIterator(di);
}",5726.0,5735.0,1.0,24.0,10.0,16,6,13,5,0,7,2,2,0,7,,0,3,2,1,1,void
3195,59276,clusterReplyMultiBulkSlots,1,clusterReplyMultiBulkSlots,void clusterReplyMultiBulkSlots (client*),cluster.c,"void clusterReplyMultiBulkSlots(client * c) {
    /* Format: 1) 1) start slot
     *            2) end slot
     *            3) 1) master IP
     *               2) master port
     *               3) node ID
     *            4) 1) replica IP
     *               2) replica port
     *               3) node ID
     *           ... continued until done
     */
    clusterNode *n = NULL;
    int num_masters = 0, start = -1;
    void *slot_replylen = addReplyDeferredLen(c);

    for (int i = 0; i <= CLUSTER_SLOTS; i++) {
        /* Find start node and slot id. */
        if (n == NULL) {
            if (i == CLUSTER_SLOTS) break;
            n = server.cluster->slots[i];
            start = i;
            continue;
        }

        /* Add cluster slots info when occur different node with start
         * or end of slot. */
        if (i == CLUSTER_SLOTS || n != server.cluster->slots[i]) {
            addNodeReplyForClusterSlot(c, n, start, i-1);
            num_masters++;
         ...",5737.0,5772.0,1.0,25.0,36.0,28,11,34,8,0,3,9,12,0,3,,0,1,2,1,1,void
3196,59389,genClusterInfoString,1,genClusterInfoString,sds genClusterInfoString (void),cluster.c,"sds genClusterInfoString(void) {
    sds info = sdsempty();
    char *statestr[] = {""ok"",""fail""};
    int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;
    uint64_t myepoch;
    int j;

    for (j = 0; j < CLUSTER_SLOTS; j++) {
        clusterNode *n = server.cluster->slots[j];

        if (n == NULL) continue;
        slots_assigned++;
        if (nodeFailed(n)) {
            slots_fail++;
        } else if (nodeTimedOut(n)) {
            slots_pfail++;
        } else {
            slots_ok++;
        }
    }

    myepoch = (nodeIsSlave(myself) && myself->slaveof) ?
                myself->slaveof->configEpoch : myself->configEpoch;

    info = sdscatprintf(info,
        ""cluster_state:%s\r\n""
        ""cluster_slots_assigned:%d\r\n""
        ""cluster_slots_ok:%d\r\n""
        ""cluster_slots_pfail:%d\r\n""
        ""cluster_slots_fail:%d\r\n""
        ""cluster_known_nodes:%lu\r\n""
        ""cluster_size:%d\r\n""
        ""cluster_current_epoch:%llu\r\n""
        ""cluster...",5774.0,5850.0,1.0,20.0,77.0,83,14,73,15,1,19,11,12,1,9,,0,19,2,1,1,sds
3197,59693,clusterCommand,1,clusterCommand,void clusterCommand (client*),cluster.c,"void clusterCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""ADDSLOTS <slot> [<slot> ...]"",
""    Assign slots to current node."",
""ADDSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]"",
""    Assign slots which are between <start-slot> and <end-slot> to current node."",
""BUMPEPOCH"",
""    Advance the cluster config epoch."",
""COUNT-FAILURE-REPORTS <node-id>"",
""    Return number of failure reports for <node-id>."",
""COUNTKEYSINSLOT <slot>"",
""    Return the number of keys in <slot>."",
""DELSLOTS <slot> [<slot> ...]"",
""    Delete slots information from current node."",
""DELSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]"",
""    Delete slots information which are between <start-slot> and <end-slot> from current node."",
""FAILOVER [FORCE|TAKEOVER]"",
""    Promote current...",5852.0,6455.0,1.0,56.0,604.0,11,8,8,4,0,4,3,3,2,2,,0,2,2,1,1,void
3198,62523,createDumpPayload,1,createDumpPayload,"void createDumpPayload (rio*,robj*,robj*,int)",cluster.c,"void createDumpPayload(rio *payload, robj *o, robj *key, int dbid) {
    unsigned char buf[2];
    uint64_t crc;

    /* Serialize the object in an RDB-like format. It consist of an object type
     * byte followed by the serialized object. This is understood by RESTORE. */
    rioInitWithBuffer(payload,sdsempty());
    serverAssert(rdbSaveObjectType(payload,o));
    serverAssert(rdbSaveObject(payload,o,key,dbid));

    /* Write the footer, this is how it looks like:
     * ----------------+---------------------+---------------+
     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |
     * ----------------+---------------------+---------------+
     * RDB version and CRC are both in little endian.
     */

    /* RDB version */
    buf[0] = RDB_VERSION & 0xff;
    buf[1] = (RDB_VERSION >> 8) & 0xff;
    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);

    /* CRC64 */
    crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,
                sdslen(payload->i...",6487.0,6514.0,1.0,4.0,28.0,40,11,20,6,2,11,1,1,0,11,,0,5,8,4,4,void
3199,62655,verifyDumpPayload,1,verifyDumpPayload,"int verifyDumpPayload (unsigned char*,size_t,uint16_t*)",cluster.c,"int verifyDumpPayload(unsigned char *p, size_t len, uint16_t *rdbver_ptr) {
    unsigned char *footer;
    uint16_t rdbver;
    uint64_t crc;

    /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */
    if (len < 10) return C_ERR;
    footer = p+(len-10);

    /* Set and verify RDB version. */
    rdbver = (footer[1] << 8) | footer[0];
    if (rdbver_ptr) {
        *rdbver_ptr = rdbver;
    }
    if (rdbver > RDB_VERSION) return C_ERR;

    if (server.skip_checksum_validation)
        return C_OK;

    /* Verify CRC64 */
    crc = crc64(0,p,len-8);
    memrev64ifbe(&crc);
    return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
}",6521.0,6544.0,1.0,25.0,24.0,24,14,19,7,2,2,5,5,0,2,,0,1,6,3,3,int
3200,62754,dumpCommand,1,dumpCommand,void dumpCommand (client*),cluster.c,"void dumpCommand(client *c) {
    robj *o;
    rio payload;

    /* Check if the key is here. */
    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
        addReplyNull(c);
        return;
    }

    /* Create the DUMP encoded representation. */
    createDumpPayload(&payload,o,c->argv[1],c->db->id);

    /* Transfer to the client */
    addReplyBulkSds(c,payload.io.buffer.ptr);
    return;
}",6549.0,6565.0,1.0,1.0,17.0,13,6,11,4,0,8,2,2,3,4,,0,5,2,1,1,void
3201,62803,restoreCommand,1,restoreCommand,void restoreCommand (client*),cluster.c,"void restoreCommand(client *c) {
    long long ttl, lfu_freq = -1, lru_idle = -1, lru_clock = -1;
    rio payload;
    int j, type, replace = 0, absttl = 0;
    robj *obj;

    /* Parse additional options */
    for (j = 4; j < c->argc; j++) {
        int additional = c->argc-j-1;
        if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""absttl"")) {
            absttl = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""idletime"") && additional >= 1 &&
                   lfu_freq == -1)
        {
            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lru_idle,NULL)
                    != C_OK) return;
            if (lru_idle < 0) {
                addReplyError(c,""Invalid IDLETIME value, must be >= 0"");
                return;
            }
            lru_clock = LRU_CLOCK();
            j++; /* Consume additional arg. */
        } else if (!strcasecmp(c->argv[j]->ptr,""freq"") && additional >= 1 &&
         ...",6568.0,6674.0,1.0,23.0,107.0,87,17,98,19,0,46,13,16,14,28,,0,27,2,1,1,void
3202,63295,migrateGetSocket,1,migrateGetSocket,"migrateCachedSocket migrateGetSocket (client*,robj*,robj*,long)",cluster.c,"migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {
    connection *conn;
    sds name = sdsempty();
    migrateCachedSocket *cs;

    /* Check if we have an already cached socket for this ip:port pair. */
    name = sdscatlen(name,host->ptr,sdslen(host->ptr));
    name = sdscatlen(name,"":"",1);
    name = sdscatlen(name,port->ptr,sdslen(port->ptr));
    cs = dictFetchValue(server.migrate_cached_sockets,name);
    if (cs) {
        sdsfree(name);
        cs->last_use_time = server.unixtime;
        return cs;
    }

    /* No cached socket, create one. */
    if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {
        /* Too many items, drop one at random. */
        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);
        cs = dictGetVal(de);
        connClose(cs->conn);
        zfree(cs);
        dictDelete(server.migrate_cached_sockets,dictGetKey(de));
    }

    /* Create the connection */
    conn = co...",6702.0,6747.0,1.0,8.0,46.0,43,10,51,10,1,28,4,4,1,23,,0,19,8,4,4,migrateCachedSocket
3203,63470,migrateCloseSocket,1,migrateCloseSocket,"void migrateCloseSocket (robj*,robj*)",cluster.c,"void migrateCloseSocket(robj *host, robj *port) {
    sds name = sdsempty();
    migrateCachedSocket *cs;

    name = sdscatlen(name,host->ptr,sdslen(host->ptr));
    name = sdscatlen(name,"":"",1);
    name = sdscatlen(name,port->ptr,sdslen(port->ptr));
    cs = dictFetchValue(server.migrate_cached_sockets,name);
    if (!cs) {
        sdsfree(name);
        return;
    }

    connClose(cs->conn);
    zfree(cs);
    dictDelete(server.migrate_cached_sockets,name);
    sdsfree(name);
}",6750.0,6767.0,1.0,1.0,18.0,13,4,21,5,2,13,2,2,0,12,,0,8,4,2,2,void
3204,63536,migrateCloseTimedoutSockets,1,migrateCloseTimedoutSockets,void migrateCloseTimedoutSockets (void),cluster.c,"void migrateCloseTimedoutSockets(void) {
    dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);
    dictEntry *de;

    while((de = dictNext(di)) != NULL) {
        migrateCachedSocket *cs = dictGetVal(de);

        if ((server.unixtime - cs->last_use_time) > MIGRATE_SOCKET_CACHE_TTL) {
            connClose(cs->conn);
            zfree(cs);
            dictDelete(server.migrate_cached_sockets,dictGetKey(de));
        }
    }
    dictReleaseIterator(di);
}",6769.0,6783.0,1.0,52.0,15.0,11,6,14,5,1,10,3,4,2,8,,0,6,2,1,1,void
3205,63589,migrateCommand,1,migrateCommand,void migrateCommand (client*),cluster.c,"void migrateCommand(client *c) {
    migrateCachedSocket *cs;
    int copy = 0, replace = 0, j;
    char *username = NULL;
    char *password = NULL;
    long timeout;
    long dbid;
    robj **ov = NULL; /* Objects to migrate. */
    robj **kv = NULL; /* Key names. */
    robj **newargv = NULL; /* Used to rewrite the command as DEL ... keys ... */
    rio cmd, payload;
    int may_retry = 1;
    int write_error = 0;
    int argv_rewritten = 0;

    /* To support the KEYS option we need the following additional state. */
    int first_key = 3; /* Argument index of the first key. */
    int num_keys = 1;  /* By default only migrate the 'key' argument. */

    /* Parse additional options */
    for (j = 6; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        if (!strcasecmp(c->argv[j]->ptr,""copy"")) {
            copy = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""auth"")) {
      ...",6792.0,7130.0,1.0,64.0,339.0,292,24,313,43,0,94,44,55,16,72,,0,45,2,1,1,void
3206,64924,askingCommand,1,askingCommand,void askingCommand (client*),cluster.c,"void askingCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags |= CLIENT_ASKING;
    addReply(c,shared.ok);
}",7140.0,7147.0,1.0,16.0,8.0,5,4,5,3,0,3,2,2,0,2,,0,1,2,1,1,void
3207,64954,readonlyCommand,1,readonlyCommand,void readonlyCommand (client*),cluster.c,"void readonlyCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags |= CLIENT_READONLY;
    addReply(c,shared.ok);
}",7152.0,7159.0,1.0,16.0,8.0,5,4,5,3,0,3,2,2,0,2,,0,1,2,1,1,void
3208,64984,readwriteCommand,1,readwriteCommand,void readwriteCommand (client*),cluster.c,"void readwriteCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags &= ~CLIENT_READONLY;
    addReply(c,shared.ok);
}",7162.0,7169.0,1.0,17.0,8.0,6,5,5,3,0,3,2,2,0,2,,0,1,2,1,1,void
3209,65015,getNodeByQuery,1,getNodeByQuery,"clusterNode getNodeByQuery (client*,redisCommand*,robj**,int,int*,int*)",cluster.c,"clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
    clusterNode *n = NULL;
    robj *firstkey = NULL;
    int multiple_keys = 0;
    multiState *ms, _ms;
    multiCmd mc;
    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0,
        existing_keys = 0;

    /* Allow any key to be set if a module disabled cluster redirections. */
    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
        return myself;

    /* Set error code optimistically for the base case. */
    if (error_code) *error_code = CLUSTER_REDIR_NONE;

    /* Modules can turn off Redis Cluster redirection: this is useful
     * when writing a module that implements a completely different
     * distributed system. */

    /* We handle all the cases as if they were EXEC commands, so we have
     * a common code path for everything */
    if (cmd->proc == execCommand) {
        /* If CLIENT_MULTI flag is...",7203.0,7413.0,1.0,38.0,211.0,155,18,139,34,3,35,28,59,14,7,,0,33,12,6,6,clusterNode
3210,65692,clusterRedirectClient,1,clusterRedirectClient,"void clusterRedirectClient (client*,clusterNode*,int,int)",cluster.c,"void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
    if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
        addReplyError(c,""-CROSSSLOT Keys in request don't hash to the same slot"");
    } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
        /* The request spawns multiple keys in the same slot,
         * but the slot is not ""stable"" currently as there is
         * a migration or import in progress. */
        addReplyError(c,""-TRYAGAIN Multiple keys request during rehashing of slot"");
    } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
        addReplyError(c,""-CLUSTERDOWN The cluster is down"");
    } else if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
        addReplyError(c,""-CLUSTERDOWN The cluster is down and only accepts read commands"");
    } else if (error_code == CLUSTER_REDIR_DOWN_UNBOUND) {
        addReplyError(c,""-CLUSTERDOWN Hash slot not served"");
    } else if (error_code == CLUSTER_REDIR_MOVED ||
               error_c...",7422.0,7448.0,1.0,22.0,27.0,1,1,2,2,3,1,2,2,0,1,,0,0,8,4,4,void
3211,65809,clusterRedirectBlockedClientIfNeeded,1,clusterRedirectBlockedClientIfNeeded,int clusterRedirectBlockedClientIfNeeded (client*),cluster.c,"int clusterRedirectBlockedClientIfNeeded(client *c) {
    if (c->flags & CLIENT_BLOCKED &&
        (c->bstate.btype == BLOCKED_LIST ||
         c->bstate.btype == BLOCKED_ZSET ||
         c->bstate.btype == BLOCKED_STREAM ||
         c->bstate.btype == BLOCKED_MODULE))
    {
        dictEntry *de;
        dictIterator *di;

        /* If the cluster is down, unblock the client with the right error.
         * If the cluster is configured to allow reads on cluster down, we
         * still want to emit this error since a write will be required
         * to unblock them which may never come.  */
        if (server.cluster->state == CLUSTER_FAIL) {
            clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
            return 1;
        }

        /* If the client is blocked on module, but not on a specific key,
         * don't unblock it (except for the CLUSTER_FAIL case above). */
        if (c->bstate.btype == BLOCKED_MODULE && !moduleClientIsBlockedOnKeys(c))
          ...",7461.0,7521.0,1.0,19.0,61.0,64,12,47,13,0,26,8,18,16,10,,0,22,2,1,1,int
3212,66024,slotToKeyAddEntry,1,slotToKeyAddEntry,"void slotToKeyAddEntry (dictEntry*,redisDb*)",cluster.c,"void slotToKeyAddEntry(dictEntry *entry, redisDb *db) {
    sds key = dictGetKey(entry);
    unsigned int hashslot = keyHashSlot(key, sdslen(key));
    slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
    slot_to_keys->count++;

    /* Insert entry before the first element in the list. */
    dictEntry *first = slot_to_keys->head;
    dictEntryNextInSlot(entry) = first;
    if (first != NULL) {
        serverAssert(dictEntryPrevInSlot(first) == NULL);
        dictEntryPrevInSlot(first) = entry;
    }
    serverAssert(dictEntryPrevInSlot(entry) == NULL);
    slot_to_keys->head = entry;
}",7528.0,7543.0,1.0,4.0,16.0,35,13,25,7,2,13,2,2,0,9,,0,7,4,2,2,void
3213,66138,slotToKeyDelEntry,1,slotToKeyDelEntry,"void slotToKeyDelEntry (dictEntry*,redisDb*)",cluster.c,"void slotToKeyDelEntry(dictEntry *entry, redisDb *db) {
    sds key = dictGetKey(entry);
    unsigned int hashslot = keyHashSlot(key, sdslen(key));
    slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
    slot_to_keys->count--;

    /* Connect previous and next entries to each other. */
    dictEntry *next = dictEntryNextInSlot(entry);
    dictEntry *prev = dictEntryPrevInSlot(entry);
    if (next != NULL) {
        dictEntryPrevInSlot(next) = prev;
    }
    if (prev != NULL) {
        dictEntryNextInSlot(prev) = next;
    } else {
        /* The removed entry was the first in the list. */
        serverAssert(slot_to_keys->head == entry);
        slot_to_keys->head = next;
    }
}",7545.0,7564.0,1.0,22.0,20.0,24,9,25,8,1,9,3,3,0,7,,0,7,4,2,2,void
3214,66253,slotToKeyReplaceEntry,1,slotToKeyReplaceEntry,"void slotToKeyReplaceEntry (dict*,dictEntry*)",cluster.c,"void slotToKeyReplaceEntry(dict *d, dictEntry *entry) {
    dictEntry *next = dictEntryNextInSlot(entry);
    dictEntry *prev = dictEntryPrevInSlot(entry);
    if (next != NULL) {
        dictEntryPrevInSlot(next) = entry;
    }
    if (prev != NULL) {
        dictEntryNextInSlot(prev) = entry;
    } else {
        /* The replaced entry was the first in the list. */
        sds key = dictGetKey(entry);
        unsigned int hashslot = keyHashSlot(key, sdslen(key));
        clusterDictMetadata *dictmeta = dictMetadata(d);
        redisDb *db = dictmeta->db;
        slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
        slot_to_keys->head = entry;
    }
}",7568.0,7585.0,1.0,22.0,18.0,14,4,16,4,1,4,3,3,0,4,,0,2,4,2,2,void
3215,66357,slotToKeyInit,1,slotToKeyInit,void slotToKeyInit (redisDb*),cluster.c,"void slotToKeyInit(redisDb *db) {
    db->slots_to_keys = zcalloc(sizeof(clusterSlotToKeyMapping));
    clusterDictMetadata *dictmeta = dictMetadata(db->dict);
    dictmeta->db = db;
}",7588.0,7592.0,1.0,1.0,5.0,7,3,6,3,2,5,1,1,0,2,,0,5,2,1,1,void
3216,66381,slotToKeyFlush,1,slotToKeyFlush,void slotToKeyFlush (redisDb*),cluster.c,"void slotToKeyFlush(redisDb *db) {
    memset(db->slots_to_keys, 0,
        sizeof(clusterSlotToKeyMapping));
}",7595.0,7598.0,1.0,1.0,4.0,2,2,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
3217,66393,slotToKeyDestroy,1,slotToKeyDestroy,void slotToKeyDestroy (redisDb*),cluster.c,"void slotToKeyDestroy(redisDb *db) {
    zfree(db->slots_to_keys);
    db->slots_to_keys = NULL;
}",7601.0,7604.0,1.0,1.0,4.0,3,2,3,2,1,3,1,1,0,1,,0,2,2,1,1,void
3218,66531,slotToChannelUpdate,1,slotToChannelUpdate,"void slotToChannelUpdate (sds,int)",cluster.c,"void slotToChannelUpdate(sds channel, int add) {
    size_t keylen = sdslen(channel);
    unsigned int hashslot = keyHashSlot(channel,keylen);
    unsigned char buf[64];
    unsigned char *indexed = buf;

    if (keylen+2 > 64) indexed = zmalloc(keylen+2);
    indexed[0] = (hashslot >> 8) & 0xff;
    indexed[1] = hashslot & 0xff;
    memcpy(indexed+2,channel,keylen);
    if (add) {
        raxInsert(server.cluster->slots_to_channels,indexed,keylen+2,NULL,NULL);
    } else {
        raxRemove(server.cluster->slots_to_channels,indexed,keylen+2,NULL);
    }
    if (indexed != buf) zfree(indexed);
}",7637.0,7653.0,1.0,1.0,17.0,19,9,26,8,2,5,4,4,0,5,,0,3,4,2,2,void
3219,66623,slotToChannelAdd,1,slotToChannelAdd,void slotToChannelAdd (sds),cluster.c,"void slotToChannelAdd(sds channel) {
    slotToChannelUpdate(channel,1);
}",7655.0,7657.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
3220,66631,slotToChannelDel,1,slotToChannelDel,void slotToChannelDel (sds),cluster.c,"void slotToChannelDel(sds channel) {
    slotToChannelUpdate(channel,0);
}",7659.0,7661.0,1.0,1.0,3.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void
3221,67335,commandGroupStr,1,commandGroupStr,char* commandGroupStr (int),commands.h,const char *commandGroupStr(int index);,38.0,38.0,12.0,38.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
3222,67812,is_valid_fn,1,boolConfigData.is_valid_fn,"int boolConfigData.is_valid_fn (int,char**)",config.c,"int (*is_valid_fn)(int val, const char **err);",188.0,188.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3223,67822,is_valid_fn,1,stringConfigData.is_valid_fn,"int stringConfigData.is_valid_fn (char*,char**)",config.c,"int (*is_valid_fn)(char* val, const char **err);",194.0,194.0,9.0,51.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3224,67833,is_valid_fn,1,sdsConfigData.is_valid_fn,"int sdsConfigData.is_valid_fn (sds,char**)",config.c,"int (*is_valid_fn)(sds val, const char **err);",202.0,202.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3225,67845,is_valid_fn,1,enumConfigData.is_valid_fn,"int enumConfigData.is_valid_fn (int,char**)",config.c,"int (*is_valid_fn)(int val, const char **err);",211.0,211.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3226,67882,is_valid_fn,1,numericConfigData.is_valid_fn,"int numericConfigData.is_valid_fn (long long,char**)",config.c,"int (*is_valid_fn)(long long val, const char **err);",245.0,245.0,9.0,55.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3227,67898,apply_fn,1,apply_fn,int apply_fn (char**),config.c,typedef int (*apply_fn)(const char **err);,258.0,258.0,13.0,41.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
3228,67904,init,1,typeInterface.init,void typeInterface.init (standardConfig*),config.c,void (*init)(standardConfig *config);,261.0,261.0,10.0,40.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3229,67909,set,1,typeInterface.set,"int typeInterface.set (standardConfig*,sds*,int,char**)",config.c,"int (*set)(standardConfig *config, sds *argv, int argc, const char **err);",265.0,265.0,9.0,77.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,int
3230,67918,get,1,typeInterface.get,sds typeInterface.get (standardConfig*),config.c,sds (*get)(standardConfig *config);,271.0,271.0,9.0,38.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sds
3231,67923,rewrite,1,typeInterface.rewrite,"void typeInterface.rewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);",273.0,273.0,10.0,95.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
3232,67943,lookupConfig,1,lookupConfig,standardConfig lookupConfig (sds),config.c,"static standardConfig *lookupConfig(sds name) {
    dictEntry *de = dictFind(configs, name);
    return de ? dictGetVal(de) : NULL;
}",290.0,293.0,1.0,1.0,4.0,2,2,6,4,8,3,1,1,0,2,,0,2,2,1,1,standardConfig
3233,67960,configEnumGetValue,1,configEnumGetValue,"int configEnumGetValue (configEnum*,sds*,int,int)",config.c,"int configEnumGetValue(configEnum *ce, sds *argv, int argc, int bitflags) {
    if (argc == 0 || (!bitflags && argc != 1)) return INT_MIN;
    int values = 0;
    for (int i = 0; i < argc; i++) {
        int matched = 0;
        for (configEnum *ceItem = ce; ceItem->name != NULL; ceItem++) {
            if (!strcasecmp(argv[i],ceItem->name)) {
                values |= ceItem->val;
                matched = 1;
            }
        }
        if (!matched) return INT_MIN;
    }
    return values;
}",300.0,314.0,1.0,1.0,15.0,18,9,22,10,1,0,6,10,0,0,,0,0,8,4,4,int
3234,68042,configEnumGetName,1,configEnumGetName,"sds configEnumGetName (configEnum*,int,int)",config.c,"static sds configEnumGetName(configEnum *ce, int values, int bitflags) {
    sds names = NULL;
    int unmatched = values;
    for( ; ce->name != NULL; ce++) {
        if (values == ce->val) { /* Short path for perfect match */
            sdsfree(names);
            return sdsnew(ce->name);
        }

        /* Note: for bitflags, we want them sorted from high to low, so that if there are several / partially
         * overlapping entries, we'll prefer the ones matching more bits. */
        if (bitflags && ce->val && ce->val == (unmatched & ce->val)) {
            names = names ? sdscatfmt(names, "" %s"", ce->name) : sdsnew(ce->name);
            unmatched &= ~ce->val;
        }
    }
    if (!names || unmatched) {
        sdsfree(names);
        return sdsnew(""unknown"");
    }
    return names;
}",317.0,338.0,1.0,1.0,22.0,22,10,26,6,2,15,5,7,5,6,,0,11,6,3,3,sds
3235,68131,evictPolicyToString,1,evictPolicyToString,const char* evictPolicyToString (void),config.c,"const char *evictPolicyToString(void) {
    for (configEnum *ce = maxmemory_policy_enum; ce->name != NULL; ce++) {
        if (server.maxmemory_policy == ce->val)
            return ce->name;
    }
    serverPanic(""unknown eviction policy"");
}",341.0,347.0,1.0,4.0,7.0,8,6,7,4,1,2,3,4,0,1,,0,1,2,1,1,const char*
3236,68171,yesnotoi,1,yesnotoi,int yesnotoi (char*),config.c,"int yesnotoi(char *s) {
    if (!strcasecmp(s,""yes"")) return 1;
    else if (!strcasecmp(s,""no"")) return 0;
    else return -1;
}",353.0,357.0,1.0,1.0,5.0,1,1,1,1,1,0,2,2,0,0,,0,0,2,1,1,int
3237,68199,appendServerSaveParams,1,appendServerSaveParams,"void appendServerSaveParams (time_t,int)",config.c,"void appendServerSaveParams(time_t seconds, int changes) {
    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));
    server.saveparams[server.saveparamslen].seconds = seconds;
    server.saveparams[server.saveparamslen].changes = changes;
    server.saveparamslen++;
}",359.0,364.0,1.0,1.0,6.0,19,7,11,4,4,1,1,1,0,1,,0,1,4,2,2,void
3238,68247,resetServerSaveParams,1,resetServerSaveParams,void resetServerSaveParams (void),config.c,"void resetServerSaveParams(void) {
    zfree(server.saveparams);
    server.saveparams = NULL;
    server.saveparamslen = 0;
}",366.0,370.0,1.0,1.0,5.0,5,2,4,2,3,1,1,1,0,1,,0,0,2,1,1,void
3239,68266,queueLoadModule,1,queueLoadModule,"void queueLoadModule (sds,sds*,int)",config.c,"void queueLoadModule(sds path, sds *argv, int argc) {
    int i;
    struct moduleLoadQueueEntry *loadmod;

    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
    loadmod->argv = argc ? zmalloc(sizeof(robj*)*argc) : NULL;
    loadmod->path = sdsnew(path);
    loadmod->argc = argc;
    for (i = 0; i < argc; i++) {
        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
    }
    listAddNodeTail(server.loadmodule_queue,loadmod);
}",372.0,384.0,1.0,1.0,13.0,19,8,22,9,0,10,2,2,0,6,,0,9,6,3,3,void
3240,68333,updateClientOutputBufferLimit,1,updateClientOutputBufferLimit,"int updateClientOutputBufferLimit (sds*,int,char**)",config.c,"static int updateClientOutputBufferLimit(sds *args, int arg_len, const char **err) {
    int j;
    int class;
    unsigned long long hard, soft;
    int hard_err, soft_err;
    int soft_seconds;
    char *soft_seconds_eptr;
    clientBufferLimitsConfig values[CLIENT_TYPE_OBUF_COUNT];
    int classes[CLIENT_TYPE_OBUF_COUNT] = {0};

    /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */
    if (arg_len % 4) {
        if (err) *err = ""Wrong number of arguments in ""
                        ""buffer limit configuration."";
        return 0;
    }

    /* Sanity check of single arguments, so that we either refuse the
     * whole configuration string or accept it all, even if a single
     * error in a single client class is present. */
    for (j = 0; j < arg_len; j += 4) {
        class = getClientTypeByName(args[j]);
        if (class == -1 || class == CLIENT_TYPE_MASTER) {
            if (err) *err = ""Invalid client class specified in ""
                            ""buf...",389.0,440.0,1.0,36.0,52.0,53,13,51,14,1,3,10,18,0,3,,0,3,6,3,3,int
3241,68517,loadServerConfigFromString,1,loadServerConfigFromString,void loadServerConfigFromString (char*),config.c,"void loadServerConfigFromString(char *config) {
    deprecatedConfig deprecated_configs[] = {
        {""list-max-ziplist-entries"", 2, 2},
        {""list-max-ziplist-value"", 2, 2},
        {""lua-replicate-commands"", 2, 2},
        {NULL, 0},
    };
    char buf[1024];
    const char *err = NULL;
    int linenum = 0, totlines, i;
    sds *lines;
    sds *argv = NULL;
    int argc;

    reading_config_file = 1;
    lines = sdssplitlen(config,strlen(config),""\n"",1,&totlines);

    for (i = 0; i < totlines; i++) {
        linenum = i+1;
        lines[i] = sdstrim(lines[i],"" \t\r\n"");

        /* Skip comments and blank lines */
        if (lines[i][0] == '#' || lines[i][0] == '\0') continue;

        /* Split into arguments */
        argv = sdssplitargs(lines[i],&argc);
        if (argv == NULL) {
            err = ""Unbalanced quotes in configuration line"";
            goto loaderr;
        }

        /* Skip this line if the resulting command vector is empty. */
        if (argc == 0) ...",447.0,645.0,1.0,34.0,199.0,96,16,108,17,1,24,27,36,5,19,,0,14,2,1,1,void
3242,69259,loadServerConfig,1,loadServerConfig,"void loadServerConfig (char*,char,char*)",config.c,"void loadServerConfig(char *filename, char config_from_stdin, char *options) {
    sds config = sdsempty();
    char buf[CONFIG_READ_LEN+1];
    FILE *fp;
    glob_t globbuf;

    /* Load the file content */
    if (filename) {

        /* The logic for handling wildcards has slightly different behavior in cases where
         * there is a failure to locate the included file.
         * Whether or not a wildcard is specified, we should ALWAYS log errors when attempting
         * to open included config files.
         *
         * However, we desire a behavioral difference between instances where a wildcard was
         * specified and those where it hasn't:
         *      no wildcards   : attempt to open the specified file and fail with a logged error
         *                       if the file cannot be found and opened.
         *      with wildcards : attempt to glob the specified pattern; if no files match the
         *                       pattern, then gracefully continu...",655.0,726.0,1.0,13.0,72.0,28,10,39,12,1,7,10,25,0,7,,0,3,6,3,3,void
3243,69483,performInterfaceSet,1,performInterfaceSet,"int performInterfaceSet (standardConfig*,sds,char**)",config.c,"static int performInterfaceSet(standardConfig *config, sds value, const char **errstr) {
    sds *argv;
    int argc, res;

    if (config->flags & MULTI_ARG_CONFIG) {
        argv = sdssplitlen(value, sdslen(value), "" "", 1, &argc);
    } else {
        argv = (char**)&value;
        argc = 1;
    }

    /* Set the config */
    res = config->interface.set(config, argv, argc, errstr);
    if (config->flags & MULTI_ARG_CONFIG) sdsfreesplitres(argv, argc);
    return res;
}",728.0,743.0,1.0,24.0,16.0,11,6,15,6,3,7,3,3,2,4,,0,6,6,3,3,int
3244,69553,performModuleConfigSetFromName,1,performModuleConfigSetFromName,"int performModuleConfigSetFromName (sds,sds,char**)",config.c,"int performModuleConfigSetFromName(sds name, sds value, const char **err) {
    standardConfig *config = lookupConfig(name);
    if (!config || !(config->flags & MODULE_CONFIG)) {
        *err = ""Config name not found"";
        return 0;
    }
    return performInterfaceSet(config, value, err);
}",746.0,753.0,1.0,37.0,8.0,9,7,8,4,1,3,2,2,1,2,,0,2,6,3,3,int
3245,69591,performModuleConfigSetDefaultFromName,1,performModuleConfigSetDefaultFromName,"int performModuleConfigSetDefaultFromName (sds,char**)",config.c,"int performModuleConfigSetDefaultFromName(sds name, const char **err) {
    standardConfig *config = lookupConfig(name);
    serverAssert(config);
    if (!(config->flags & MODULE_CONFIG)) {
        *err = ""Config name not found"";
        return 0;
    }
    switch (config->type) {
        case BOOL_CONFIG:
            return setModuleBoolConfig(config->privdata, config->data.yesno.default_value, err);
        case SDS_CONFIG:
            return setModuleStringConfig(config->privdata, config->data.sds.default_value, err);
        case NUMERIC_CONFIG:
            return setModuleNumericConfig(config->privdata, config->data.numeric.default_value, err);
        case ENUM_CONFIG:
            return setModuleEnumConfig(config->privdata, config->data.enumd.default_value, err);
        default:
            serverPanic(""Config type of module config is not allowed."");
    }
    return 0;
}",756.0,776.0,1.0,4.0,21.0,29,11,23,7,0,17,3,3,2,7,,0,11,4,2,2,int
3246,69711,restoreBackupConfig,1,restoreBackupConfig,"void restoreBackupConfig (standardConfig**,sds*,int,apply_fn*,list*)",config.c,"static void restoreBackupConfig(standardConfig **set_configs, sds *old_values, int count, apply_fn *apply_fns, list *module_configs) {
    int i;
    const char *errstr = ""unknown error"";
    /* Set all backup values */
    for (i = 0; i < count; i++) {
        if (!performInterfaceSet(set_configs[i], old_values[i], &errstr))
            serverLog(LL_WARNING, ""Failed restoring failed CONFIG SET command. Error setting %s to '%s': %s"",
                      set_configs[i]->name, old_values[i], errstr);
    }
    /* Apply backup */
    if (apply_fns) {
        for (i = 0; i < count && apply_fns[i] != NULL; i++) {
            if (!apply_fns[i](&errstr))
                serverLog(LL_WARNING, ""Failed applying restored failed CONFIG SET command: %s"", errstr);
        }
    }
    if (module_configs) {
        if (!moduleConfigApplyConfig(module_configs, &errstr, NULL))
            serverLog(LL_WARNING, ""Failed applying restored failed CONFIG SET command: %s"", errstr);
    }
}",778.0,798.0,1.0,12.0,21.0,29,10,33,9,3,5,8,13,2,5,,0,2,10,5,5,void
3247,69853,configSetCommand,1,configSetCommand,void configSetCommand (client*),config.c,"void configSetCommand(client *c) {
    const char *errstr = NULL;
    const char *invalid_arg_name = NULL;
    const char *err_arg_name = NULL;
    standardConfig **set_configs; /* TODO: make this a dict for better performance */
    list *module_configs_apply;
    const char **config_names;
    sds *new_values;
    sds *old_values = NULL;
    apply_fn *apply_fns; /* TODO: make this a set for better performance */
    int config_count, i, j;
    int invalid_args = 0, deny_loading_error = 0;
    int *config_map_fns;

    /* Make sure we have an even number of arguments: conf-val pairs */
    if (c->argc & 1) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    config_count = (c->argc - 2) / 2;

    module_configs_apply = listCreate();
    set_configs = zcalloc(sizeof(standardConfig*)*config_count);
    config_names = zcalloc(sizeof(char*)*config_count);
    new_values = zmalloc(sizeof(sds*)*config_count);
    old_values = zcalloc(sizeof(sds*)*config_count);
 ...",804.0,964.0,1.0,28.0,161.0,152,20,158,28,0,41,30,32,7,28,,0,24,2,1,1,void
3248,70527,configGetCommand,1,configGetCommand,void configGetCommand (client*),config.c,"void configGetCommand(client *c) {
    int i;
    dictEntry *de;
    dictIterator *di;
    /* Create a dictionary to store the matched configs */
    dict *matches = dictCreate(&externalStringType);
    for (i = 0; i < c->argc - 2; i++) {
        robj *o = c->argv[2+i];
        sds name = o->ptr;

        /* If the string doesn't contain glob patterns, just directly
         * look up the key in the dictionary. */
        if (!strpbrk(name, ""[*?"")) {
            if (dictFind(matches, name)) continue;
            standardConfig *config = lookupConfig(name);

            if (config) {
                dictAdd(matches, name, config);
            }
            continue;
        }

        /* Otherwise, do a match against all items in the dictionary. */
        di = dictGetIterator(configs);
        
        while ((de = dictNext(di)) != NULL) {
            standardConfig *config = dictGetVal(de);
            /* Note that hidden configs require an exact match (not a pattern) */
          ...",970.0,1016.0,1.0,32.0,47.0,34,13,53,11,0,31,14,22,9,23,,0,23,2,1,1,void
3249,70700,dictListDestructor,1,dictListDestructor,"void dictListDestructor (dict*,void*)",server.c,"void dictListDestructor(dict *d, void *val)
{
    UNUSED(d);
    listRelease((list*)val);
}",253.0,257.0,1.0,4.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3250,70706,rewriteConfigSentinelOption,1,rewriteConfigSentinelOption,void rewriteConfigSentinelOption (rewriteConfigState*),sentinel.c,"void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
    dictIterator *di, *di2;
    dictEntry *de;
    sds line;

    /* sentinel unique ID. */
    line = sdscatprintf(sdsempty(), ""sentinel myid %s"", sentinel.myid);
    rewriteConfigRewriteLine(state,""sentinel myid"",line,1);

    /* sentinel deny-scripts-reconfig. */
    line = sdscatprintf(sdsempty(), ""sentinel deny-scripts-reconfig %s"",
        sentinel.deny_scripts_reconfig ? ""yes"" : ""no"");
    rewriteConfigRewriteLine(state,""sentinel deny-scripts-reconfig"",line,
        sentinel.deny_scripts_reconfig != SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG);

    /* sentinel resolve-hostnames.
     * This must be included early in the file so it is already in effect
     * when reading the file.
     */
    line = sdscatprintf(sdsempty(), ""sentinel resolve-hostnames %s"",
                        sentinel.resolve_hostnames ? ""yes"" : ""no"");
    rewriteConfigRewriteLine(state,""sentinel resolve-hostnames"",line,
                    ...",2029.0,2276.0,1.0,42.0,248.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3251,70740,rewriteConfigReleaseState,1,rewriteConfigReleaseState,void rewriteConfigReleaseState (rewriteConfigState*),config.c,"void rewriteConfigReleaseState(struct rewriteConfigState *state) {
    sdsfreesplitres(state->lines,state->numlines);
    dictRelease(state->option_to_line);
    dictRelease(state->rewritten);
    zfree(state);
}",1067.0,1072.0,1.0,1.0,6.0,4,1,5,1,3,8,1,1,0,4,,0,4,2,1,1,void
3252,70762,rewriteConfigCreateState,1,rewriteConfigCreateState,struct rewriteConfigState rewriteConfigCreateState (void),config.c,"struct rewriteConfigState *rewriteConfigCreateState(void) {
    struct rewriteConfigState *state = zmalloc(sizeof(*state));
    state->option_to_line = dictCreate(&optionToLineDictType);
    state->rewritten = dictCreate(&optionSetDictType);
    state->numlines = 0;
    state->lines = NULL;
    state->needs_signature = 1;
    state->force_write = 0;
    return state;
}",1075.0,1084.0,1.0,1.0,10.0,17,5,12,4,2,11,1,1,0,3,,0,11,2,1,1,struct rewriteConfigState
3253,70810,rewriteConfigAppendLine,1,rewriteConfigAppendLine,"void rewriteConfigAppendLine (rewriteConfigState*,sds)",config.c,"void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
    state->lines[state->numlines++] = line;
}",1087.0,1090.0,1.0,1.0,4.0,12,7,7,3,3,6,1,1,0,1,,0,6,4,2,2,void
3254,70842,rewriteConfigAddLineNumberToOption,1,rewriteConfigAddLineNumberToOption,"void rewriteConfigAddLineNumberToOption (rewriteConfigState*,sds,int)",config.c,"void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
    list *l = dictFetchValue(state->option_to_line,option);

    if (l == NULL) {
        l = listCreate();
        dictAdd(state->option_to_line,sdsdup(option),l);
    }
    listAddNodeTail(l,(void*)(long)linenum);
}",1093.0,1101.0,1.0,1.0,9.0,7,4,11,5,1,7,2,2,0,5,,0,5,6,3,3,void
3255,70879,rewriteConfigMarkAsProcessed,1,rewriteConfigMarkAsProcessed,"void rewriteConfigMarkAsProcessed (rewriteConfigState*,char*)",config.c,"void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
    sds opt = sdsnew(option);

    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
}",1107.0,1111.0,1.0,46.0,5.0,3,3,6,4,11,4,2,2,2,3,,0,3,4,2,2,void
3256,70904,rewriteConfigReadOldFile,1,rewriteConfigReadOldFile,struct rewriteConfigState rewriteConfigReadOldFile (char*),config.c,"struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
    FILE *fp = fopen(path,""r"");
    if (fp == NULL && errno != ENOENT) return NULL;

    struct redis_stat sb;
    if (fp && redis_fstat(fileno(fp),&sb) == -1) return NULL;

    int linenum = -1;
    struct rewriteConfigState *state = rewriteConfigCreateState();

    if (fp == NULL || sb.st_size == 0) return state;

    /* Load the file content */
    sds config = sdsnewlen(SDS_NOINIT,sb.st_size);
    if (fread(config,1,sb.st_size,fp) == 0) {
        sdsfree(config);
        rewriteConfigReleaseState(state);
        fclose(fp);
        return NULL;
    }

    int i, totlines;
    sds *lines = sdssplitlen(config,sdslen(config),""\n"",1,&totlines);

    /* Read the old content line by line, populate the state. */
    for (i = 0; i < totlines; i++) {
        int argc;
        sds *argv;
        sds line = sdstrim(lines[i],""\r\n\t "");
        lines[i] = NULL;

        linenum++; /* Zero based, so we init at -1 */

        /...",1118.0,1213.0,1.0,11.0,96.0,77,16,98,20,1,31,14,20,3,27,,0,17,2,1,1,struct rewriteConfigState
3257,71232,rewriteConfigRewriteLine,1,rewriteConfigRewriteLine,"int rewriteConfigRewriteLine (rewriteConfigState*,char*,sds,int)",config.c,"int rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
    sds o = sdsnew(option);
    list *l = dictFetchValue(state->option_to_line,o);

    rewriteConfigMarkAsProcessed(state,option);

    if (!l && !force && !state->force_write) {
        /* Option not used previously, and we are not forced to use it. */
        sdsfree(line);
        sdsfree(o);
        return 0;
    }

    if (l) {
        listNode *ln = listFirst(l);
        int linenum = (long) ln->value;

        /* There are still lines in the old configuration file we can reuse
         * for this option. Replace the line with the new one. */
        listDelNode(l,ln);
        if (listLength(l) == 0) dictDelete(state->option_to_line,o);
        sdsfree(state->lines[linenum]);
        state->lines[linenum] = line;
    } else {
        /* Append a new line. */
        if (state->needs_signature) {
            rewriteConfigAppendLine(state,
                sdsnew(REDIS_CONFI...",1231.0,1265.0,1.0,23.0,35.0,22,7,30,8,17,17,4,5,2,9,,0,10,8,4,4,int
3258,71350,rewriteConfigFormatMemory,1,rewriteConfigFormatMemory,"int rewriteConfigFormatMemory (char*,size_t,long long)",config.c,"int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {
    int gb = 1024*1024*1024;
    int mb = 1024*1024;
    int kb = 1024;

    if (bytes && (bytes % gb) == 0) {
        return snprintf(buf,len,""%lldgb"",bytes/gb);
    } else if (bytes && (bytes % mb) == 0) {
        return snprintf(buf,len,""%lldmb"",bytes/mb);
    } else if (bytes && (bytes % kb) == 0) {
        return snprintf(buf,len,""%lldkb"",bytes/kb);
    } else {
        return snprintf(buf,len,""%lld"",bytes);
    }
}",1269.0,1283.0,1.0,1.0,15.0,10,6,10,6,3,0,2,2,0,0,,0,0,6,3,3,int
3259,71438,rewriteConfigBytesOption,1,rewriteConfigBytesOption,"void rewriteConfigBytesOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigBytesOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    char buf[64];
    int force = value != defvalue;
    sds line;

    rewriteConfigFormatMemory(buf,sizeof(buf),value);
    line = sdscatprintf(sdsempty(),""%s %s"",option,buf);
    rewriteConfigRewriteLine(state,option,line,force);
}",1286.0,1294.0,1.0,1.0,9.0,4,3,13,7,0,4,1,1,0,4,,0,2,8,4,4,void
3260,71471,rewriteConfigPercentOption,1,rewriteConfigPercentOption,"void rewriteConfigPercentOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigPercentOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %lld%%"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1297.0,1302.0,1.0,1.0,6.0,3,2,10,6,1,3,1,1,0,3,,0,2,8,4,4,void
3261,71498,rewriteConfigYesNoOption,1,rewriteConfigYesNoOption,"void rewriteConfigYesNoOption (rewriteConfigState*,char*,int,int)",config.c,"void rewriteConfigYesNoOption(struct rewriteConfigState *state, const char *option, int value, int defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %s"",option,
        value ? ""yes"" : ""no"");

    rewriteConfigRewriteLine(state,option,line,force);
}",1305.0,1311.0,1.0,1.0,7.0,4,3,10,6,1,3,1,1,0,3,,0,2,8,4,4,void
3262,71528,rewriteConfigStringOption,1,rewriteConfigStringOption,"void rewriteConfigStringOption (rewriteConfigState*,char*,char*,char*)",config.c,"void rewriteConfigStringOption(struct rewriteConfigState *state, const char *option, char *value, const char *defvalue) {
    int force = 1;
    sds line;

    /* String options set to NULL need to be not present at all in the
     * configuration file to be set to NULL again at the next reboot. */
    if (value == NULL) {
        rewriteConfigMarkAsProcessed(state,option);
        return;
    }

    /* Set force to zero if the value is set to its default. */
    if (defvalue && strcmp(value,defvalue) == 0) force = 0;

    line = sdsnew(option);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, value, strlen(value));

    rewriteConfigRewriteLine(state,option,line,force);
}",1314.0,1333.0,1.0,1.0,20.0,8,3,21,7,2,5,3,3,0,5,,0,3,8,4,4,void
3263,71584,rewriteConfigSdsOption,1,rewriteConfigSdsOption,"void rewriteConfigSdsOption (rewriteConfigState*,char*,sds,char*)",config.c,"void rewriteConfigSdsOption(struct rewriteConfigState *state, const char *option, sds value, const char *defvalue) {
    int force = 1;
    sds line;

    /* If there is no value set, we don't want the SDS option
     * to be present in the configuration at all. */
    if (value == NULL) {
        rewriteConfigMarkAsProcessed(state, option);
        return;
    }

    /* Set force to zero if the value is set to its default. */
    if (defvalue && strcmp(value, defvalue) == 0) force = 0;

    line = sdsnew(option);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, value, sdslen(value));

    rewriteConfigRewriteLine(state, option, line, force);
}",1336.0,1355.0,1.0,1.0,20.0,8,3,21,7,1,6,3,3,0,6,,0,4,8,4,4,void
3264,71640,rewriteConfigNumericalOption,1,rewriteConfigNumericalOption,"void rewriteConfigNumericalOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigNumericalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %lld"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1358.0,1363.0,1.0,1.0,6.0,3,2,10,6,0,3,1,1,0,3,,0,2,8,4,4,void
3265,71667,rewriteConfigOctalOption,1,rewriteConfigOctalOption,"void rewriteConfigOctalOption (rewriteConfigState*,char*,long long,long long)",config.c,"void rewriteConfigOctalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %llo"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1366.0,1371.0,1.0,1.0,6.0,3,2,10,6,0,3,1,1,0,3,,0,2,8,4,4,void
3266,71694,rewriteConfigEnumOption,1,rewriteConfigEnumOption,"void rewriteConfigEnumOption (rewriteConfigState*,char*,int,standardConfig*)",config.c,"void rewriteConfigEnumOption(struct rewriteConfigState *state, const char *option, int value, standardConfig *config) {
    int multiarg = config->flags & MULTI_ARG_CONFIG;
    sds names = configEnumGetName(config->data.enumd.enum_value,value,multiarg);
    sds line = sdscatfmt(sdsempty(),""%s %s"",option,names);
    sdsfree(names);
    int force = value != config->data.enumd.default_value;

    rewriteConfigRewriteLine(state,option,line,force);
}",1376.0,1384.0,1.0,35.0,9.0,14,6,17,8,1,8,1,1,0,5,,0,6,8,4,4,void
3267,71754,rewriteConfigSaveOption,1,rewriteConfigSaveOption,"void rewriteConfigSaveOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigSaveOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int j;
    sds line;

    /* In Sentinel mode we don't need to rewrite the save parameters */
    if (server.sentinel_mode) {
        rewriteConfigMarkAsProcessed(state,name);
        return;
    }

    /* Rewrite save parameters, or an empty 'save """"' line to avoid the
     * defaults from being used.
     */
    if (!server.saveparamslen) {
        rewriteConfigRewriteLine(state,name,sdsnew(""save \""\""""),1);
    } else {
        for (j = 0; j < server.saveparamslen; j++) {
            line = sdscatprintf(sdsempty(),""save %ld %d"",
                (long) server.saveparams[j].seconds, server.saveparams[j].changes);
            rewriteConfigRewriteLine(state,name,line,1);
        }
    }

    /* Mark ""save"" as processed in case server.saveparamslen is zero. */
    rewriteConfigMarkAsProcessed(state,name);
}",1387.0,1413.0,1.0,4.0,27.0,4,3,10,4,0,4,3,3,0,4,,0,1,6,3,3,void
3268,71834,rewriteConfigUserOption,1,rewriteConfigUserOption,void rewriteConfigUserOption (rewriteConfigState*),config.c,"void rewriteConfigUserOption(struct rewriteConfigState *state) {
    /* If there is a user file defined we just mark this configuration
     * directive as processed, so that all the lines containing users
     * inside the config file gets discarded. */
    if (server.acl_filename[0] != '\0') {
        rewriteConfigMarkAsProcessed(state,""user"");
        return;
    }

    /* Otherwise scan the list of users and rewrite every line. Note that
     * in case the list here is empty, the effect will just be to comment
     * all the users directive inside the config file. */
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        sds line = sdsnew(""user "");
        line = sdscatsds(line,u->name);
        line = sdscatlen(line,"" "",1);
        robj *descr = ACLDescribeUser(u);
        line = sdscatsds(line,descr->ptr);
        decrRefCount(descr);
        rewriteConfigRewriteLine(state,""user"",line,1);
    }
   ...",1416.0,1445.0,1.0,1.0,30.0,16,6,25,8,1,15,3,3,1,13,,0,8,2,1,1,void
3269,71917,rewriteConfigDirOption,1,rewriteConfigDirOption,"void rewriteConfigDirOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigDirOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    char cwd[1024];

    if (getcwd(cwd,sizeof(cwd)) == NULL) {
        rewriteConfigMarkAsProcessed(state,name);
        return; /* no rewrite on error. */
    }
    rewriteConfigStringOption(state,name,cwd,NULL);
}",1448.0,1457.0,1.0,4.0,10.0,3,3,11,5,0,2,2,2,0,2,,0,0,6,3,3,void
3270,71948,rewriteConfigReplicaOfOption,1,rewriteConfigReplicaOfOption,"void rewriteConfigReplicaOfOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigReplicaOfOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    sds line;

    /* If this is a master, we want all the slaveof config options
     * in the file to be removed. Note that if this is a cluster instance
     * we don't want a slaveof directive inside redis.conf. */
    if (server.cluster_enabled || server.masterhost == NULL) {
        rewriteConfigMarkAsProcessed(state, name);
        return;
    }
    line = sdscatprintf(sdsempty(),""%s %s %d"", name,
        server.masterhost, server.masterport);
    rewriteConfigRewriteLine(state,name,line,1);
}",1460.0,1474.0,1.0,4.0,15.0,8,5,14,6,0,4,2,2,0,4,,0,2,6,3,3,void
3271,71994,rewriteConfigNotifyKeyspaceEventsOption,1,rewriteConfigNotifyKeyspaceEventsOption,"void rewriteConfigNotifyKeyspaceEventsOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigNotifyKeyspaceEventsOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = server.notify_keyspace_events != 0;
    sds line, flags;

    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
    line = sdsnew(name);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, flags, sdslen(flags));
    sdsfree(flags);
    rewriteConfigRewriteLine(state,name,line,force);
}",1477.0,1488.0,1.0,4.0,12.0,9,4,19,7,0,7,1,1,0,7,,0,5,6,3,3,void
3272,72047,rewriteConfigClientOutputBufferLimitOption,1,rewriteConfigClientOutputBufferLimitOption,"void rewriteConfigClientOutputBufferLimitOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigClientOutputBufferLimitOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int j;
    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
        int force = (server.client_obuf_limits[j].hard_limit_bytes !=
                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||
                    (server.client_obuf_limits[j].soft_limit_bytes !=
                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||
                    (server.client_obuf_limits[j].soft_limit_seconds !=
                    clientBufferLimitsDefaults[j].soft_limit_seconds);
        sds line;
        char hard[64], soft[64];

        rewriteConfigFormatMemory(hard,sizeof(hard),
                server.client_obuf_limits[j].hard_limit_bytes);
        rewriteConfigFormatMemory(soft,sizeof(soft),
                server.client_obuf_limits[j].soft_limit_bytes);

        char *typename = getClientTypeName(j);
        if (!strcmp(typename,""...",1491.0,1516.0,1.0,4.0,26.0,40,9,40,11,0,9,3,4,0,6,,0,6,6,3,3,void
3273,72180,rewriteConfigOOMScoreAdjValuesOption,1,rewriteConfigOOMScoreAdjValuesOption,"void rewriteConfigOOMScoreAdjValuesOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigOOMScoreAdjValuesOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = 0;
    int j;
    sds line;

    line = sdsnew(name);
    line = sdscatlen(line, "" "", 1);
    for (j = 0; j < CONFIG_OOM_COUNT; j++) {
        if (server.oom_score_adj_values[j] != configOOMScoreAdjValuesDefaults[j])
            force = 1;

        line = sdscatprintf(line, ""%d"", server.oom_score_adj_values[j]);
        if (j+1 != CONFIG_OOM_COUNT)
            line = sdscatlen(line, "" "", 1);
    }
    rewriteConfigRewriteLine(state,name,line,force);
}",1519.0,1536.0,1.0,4.0,18.0,17,7,25,8,0,6,4,6,1,5,,0,5,6,3,3,void
3274,72266,rewriteConfigBindOption,1,rewriteConfigBindOption,"void rewriteConfigBindOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigBindOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = 1;
    sds line, addresses;
    int is_default = 0;

    /* Compare server.bindaddr with CONFIG_DEFAULT_BINDADDR */
    if (server.bindaddr_count == CONFIG_DEFAULT_BINDADDR_COUNT) {
        is_default = 1;
        char *default_bindaddr[CONFIG_DEFAULT_BINDADDR_COUNT] = CONFIG_DEFAULT_BINDADDR;
        for (int j = 0; j < CONFIG_DEFAULT_BINDADDR_COUNT; j++) {
            if (strcmp(server.bindaddr[j], default_bindaddr[j]) != 0) {
                is_default = 0;
                break;
            }
        }
    }

    if (is_default) {
        rewriteConfigMarkAsProcessed(state,name);
        return;
    }

    /* Rewrite as bind <addr1> <addr2> ... <addrN> */
    if (server.bindaddr_count > 0)
        addresses = sdsjoin(server.bindaddr,server.bindaddr_count,"" "");
    else
        addresses = sdsnew(""\""\"""");
    line = sdsnew(name);
    line ...",1539.0,1573.0,1.0,4.0,35.0,23,9,33,10,0,7,7,9,0,7,,0,4,6,3,3,void
3275,72390,rewriteConfigLoadmoduleOption,1,rewriteConfigLoadmoduleOption,void rewriteConfigLoadmoduleOption (rewriteConfigState*),config.c,"void rewriteConfigLoadmoduleOption(struct rewriteConfigState *state) {
    sds line;

    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        line = sdsnew(""loadmodule "");
        line = sdscatsds(line, module->loadmod->path);
        for (int i = 0; i < module->loadmod->argc; i++) {
            line = sdscatlen(line, "" "", 1);
            line = sdscatsds(line, module->loadmod->argv[i]->ptr);
        }
        rewriteConfigRewriteLine(state,""loadmodule"",line,1);
    }
    dictReleaseIterator(di);
    /* Mark ""loadmodule"" as processed in case modules is empty. */
    rewriteConfigMarkAsProcessed(state,""loadmodule"");
}",1576.0,1594.0,1.0,1.0,19.0,18,5,24,8,1,13,3,4,2,10,,0,10,2,1,1,void
3276,72473,rewriteConfigGetContentFromState,1,rewriteConfigGetContentFromState,sds rewriteConfigGetContentFromState (rewriteConfigState*),config.c,"sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
    sds content = sdsempty();
    int j, was_empty = 0;

    for (j = 0; j < state->numlines; j++) {
        /* Every cluster of empty lines is turned into a single empty line. */
        if (sdslen(state->lines[j]) == 0) {
            if (was_empty) continue;
            was_empty = 1;
        } else {
            was_empty = 0;
        }
        content = sdscatsds(content,state->lines[j]);
        content = sdscatlen(content,""\n"",1);
    }
    return content;
}",1598.0,1614.0,1.0,1.0,17.0,13,5,16,4,2,7,5,7,3,4,,0,7,2,1,1,sds
3277,72539,rewriteConfigRemoveOrphaned,1,rewriteConfigRemoveOrphaned,void rewriteConfigRemoveOrphaned (rewriteConfigState*),config.c,"void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
    dictIterator *di = dictGetIterator(state->option_to_line);
    dictEntry *de;

    while((de = dictNext(di)) != NULL) {
        list *l = dictGetVal(de);
        sds option = dictGetKey(de);

        /* Don't blank lines about options the rewrite process
         * don't understand. */
        if (dictFind(state->rewritten,option) == NULL) {
            serverLog(LL_DEBUG,""Not rewritten option: %s"", option);
            continue;
        }

        while(listLength(l)) {
            listNode *ln = listFirst(l);
            int linenum = (long) ln->value;

            sdsfree(state->lines[linenum]);
            state->lines[linenum] = sdsempty();
            listDelNode(l,ln);
        }
    }
    dictReleaseIterator(di);
}",1624.0,1649.0,1.0,12.0,26.0,22,9,28,9,1,17,5,6,4,10,,0,13,2,1,1,void
3278,72642,getConfigDebugInfo,1,getConfigDebugInfo,sds getConfigDebugInfo (void),config.c,"sds getConfigDebugInfo(void) {
    struct rewriteConfigState *state = rewriteConfigCreateState();
    state->force_write = 1; /* Force the output */
    state->needs_signature = 0; /* Omit the rewrite signature */

    /* Iterate the configs and ""rewrite"" the ones that have 
     * the debug flag. */
    dictIterator *di = dictGetIterator(configs);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        standardConfig *config = dictGetVal(de);
        if (!(config->flags & DEBUG_CONFIG)) continue;
        config->interface.rewrite(config, config->name, state);
    }
    dictReleaseIterator(di);
    sds info = rewriteConfigGetContentFromState(state);
    rewriteConfigReleaseState(state);
    return info;
}",1653.0,1671.0,1.0,30.0,19.0,17,7,20,7,1,14,4,4,2,8,,0,11,2,1,1,sds
3279,72715,rewriteConfigOverwriteFile,1,rewriteConfigOverwriteFile,"int rewriteConfigOverwriteFile (char*,sds)",config.c,"int rewriteConfigOverwriteFile(char *configfile, sds content) {
    int fd = -1;
    int retval = -1;
    char tmp_conffile[PATH_MAX];
    const char *tmp_suffix = "".XXXXXX"";
    size_t offset = 0;
    ssize_t written_bytes = 0;
    int old_errno;

    int tmp_path_len = snprintf(tmp_conffile, sizeof(tmp_conffile), ""%s%s"", configfile, tmp_suffix);
    if (tmp_path_len <= 0 || (unsigned int)tmp_path_len >= sizeof(tmp_conffile)) {
        serverLog(LL_WARNING, ""Config file full path is too long"");
        errno = ENAMETOOLONG;
        return retval;
    }

#if defined(_GNU_SOURCE) && !defined(__HAIKU__)
    fd = mkostemp(tmp_conffile, O_CLOEXEC);
#else
    /* There's a theoretical chance here to leak the FD if a module thread forks & execv in the middle */
    fd = mkstemp(tmp_conffile);
#endif

    if (fd == -1) {
        serverLog(LL_WARNING, ""Could not create tmp config file (%s)"", strerror(errno));
        return retval;
    }

    while (offset < sdslen(content)) {
         writt...",1678.0,1735.0,1.0,8.0,58.0,39,14,50,14,1,6,10,11,1,6,,0,2,4,2,2,int
3280,73033,rewriteConfig,1,rewriteConfig,"int rewriteConfig (char*,int)",config.c,"int rewriteConfig(char *path, int force_write) {
    struct rewriteConfigState *state;
    sds newcontent;
    int retval;

    /* Step 1: read the old config into our rewrite state. */
    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
    if (force_write) state->force_write = 1;

    /* Step 2: rewrite every single option, replacing or appending it inside
     * the rewrite state. */

    /* Iterate the configs that are standard */
    dictIterator *di = dictGetIterator(configs);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        standardConfig *config = dictGetVal(de);
        /* Only rewrite the primary names */
        if (config->flags & ALIAS_CONFIG) continue;
        if (config->interface.rewrite) config->interface.rewrite(config, dictGetKey(de), state);
    }
    dictReleaseIterator(di);

    rewriteConfigUserOption(state);
    rewriteConfigLoadmoduleOption(state);

    /* Rewrite Sentinel config if in Sentinel mode. */
    if (server.sen...",1747.0,1789.0,1.0,28.0,43.0,20,8,32,11,2,20,8,9,4,15,,0,12,4,2,2,int
3281,73146,boolConfigInit,1,boolConfigInit,void boolConfigInit (standardConfig*),config.c,"static void boolConfigInit(standardConfig *config) {
    *config->data.yesno.config = config->data.yesno.default_value;
}",1823.0,1825.0,1.0,1.0,3.0,8,4,2,1,0,2,1,1,0,0,,0,2,2,1,1,void
3282,73167,boolConfigSet,1,boolConfigSet,"int boolConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int boolConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    int yn = yesnotoi(argv[0]);
    if (yn == -1) {
        *err = ""argument must be 'yes' or 'no'"";
        return 0;
    }
    if (config->data.yesno.is_valid_fn && !config->data.yesno.is_valid_fn(yn, err))
        return 0;
    int prev = config->flags & MODULE_CONFIG ? getModuleBoolConfig(config->privdata) : *(config->data.yesno.config);
    if (prev != yn) {
        if (config->flags & MODULE_CONFIG) {
            return setModuleBoolConfig(config->privdata, yn, err);
        }
        *(config->data.yesno.config) = yn;
        return 1;
    }
    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1827.0,1845.0,1.0,4.0,19.0,39,14,23,6,0,13,5,6,4,4,,0,12,8,4,4,int
3283,73296,boolConfigGet,1,boolConfigGet,sds boolConfigGet (standardConfig*),config.c,"static sds boolConfigGet(standardConfig *config) {
    if (config->flags & MODULE_CONFIG) {
        return sdsnew(getModuleBoolConfig(config->privdata) ? ""yes"" : ""no"");
    }
    return sdsnew(*config->data.yesno.config ? ""yes"" : ""no"");
}",1847.0,1852.0,1.0,24.0,6.0,10,6,3,1,0,6,2,2,1,3,,0,4,2,1,1,sds
3284,73334,boolConfigRewrite,1,boolConfigRewrite,"void boolConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void boolConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    int val = config->flags & MODULE_CONFIG ? getModuleBoolConfig(config->privdata) : *(config->data.yesno.config);
    rewriteConfigYesNoOption(state, name, val, config->data.yesno.default_value);
}",1854.0,1857.0,1.0,30.0,4.0,13,7,8,4,0,6,1,1,0,2,,0,5,6,3,3,void
3285,73377,stringConfigInit,1,stringConfigInit,void stringConfigInit (standardConfig*),config.c,"static void stringConfigInit(standardConfig *config) {
    *config->data.string.config = (config->data.string.convert_empty_to_null && !config->data.string.default_value) ? NULL : zstrdup(config->data.string.default_value);
}",1871.0,1873.0,1.0,1.0,3.0,17,7,5,2,0,5,1,1,0,1,,0,5,2,1,1,void
3286,73417,stringConfigSet,1,stringConfigSet,"int stringConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int stringConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    if (config->data.string.is_valid_fn && !config->data.string.is_valid_fn(argv[0], err))
        return 0;
    char *prev = *config->data.string.config;
    char *new = (config->data.string.convert_empty_to_null && !argv[0][0]) ? NULL : argv[0];
    if (new != prev && (new == NULL || prev == NULL || strcmp(prev, new))) {
        *config->data.string.config = new != NULL ? zstrdup(new) : NULL;
        zfree(prev);
        return 1;
    }
    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1875.0,1887.0,1.0,4.0,13.0,42,14,28,7,0,9,3,3,3,3,,0,8,8,4,4,int
3287,73539,stringConfigGet,1,stringConfigGet,sds stringConfigGet (standardConfig*),config.c,"static sds stringConfigGet(standardConfig *config) {
    return sdsnew(*config->data.string.config ? *config->data.string.config : """");
}",1889.0,1891.0,1.0,1.0,3.0,9,4,2,1,0,3,1,1,0,1,,0,2,2,1,1,sds
3288,73564,stringConfigRewrite,1,stringConfigRewrite,"void stringConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void stringConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    rewriteConfigStringOption(state, name,*(config->data.string.config), config->data.string.default_value);
}",1893.0,1895.0,1.0,1.0,3.0,7,3,4,3,0,3,1,1,0,1,,0,2,6,3,3,void
3289,73589,sdsConfigInit,1,sdsConfigInit,void sdsConfigInit (standardConfig*),config.c,"static void sdsConfigInit(standardConfig *config) {
    *config->data.sds.config = (config->data.sds.convert_empty_to_null && !config->data.sds.default_value) ? NULL : sdsnew(config->data.sds.default_value);
}",1898.0,1900.0,1.0,1.0,3.0,17,7,5,2,0,5,1,1,0,1,,0,5,2,1,1,void
3290,73629,sdsConfigSet,1,sdsConfigSet,"int sdsConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int sdsConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    if (config->data.sds.is_valid_fn && !config->data.sds.is_valid_fn(argv[0], err))
        return 0;

    sds prev = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    sds new = (config->data.string.convert_empty_to_null && (sdslen(argv[0]) == 0)) ? NULL : argv[0];

    /* if prev and new configuration are not equal, set the new one */
    if (new != prev && (new == NULL || prev == NULL || sdscmp(prev, new))) {
        /* If MODULE_CONFIG flag is set, then free temporary prev getModuleStringConfig returned.
         * Otherwise, free the actual previous config value Redis held (Same action, different reasons) */
        sdsfree(prev);

        if (config->flags & MODULE_CONFIG) {
            return setModuleStringConfig(config->privdata, new, err);
        }
        *config->data.sds.config = new != NULL ? sdsdup(new) : NUL...",1902.0,1924.0,1.0,4.0,23.0,54,14,37,7,0,19,5,6,6,8,,0,16,8,4,4,int
3291,73798,sdsConfigGet,1,sdsConfigGet,sds sdsConfigGet (standardConfig*),config.c,"static sds sdsConfigGet(standardConfig *config) {
    sds val = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    if (val) {
        if (config->flags & MODULE_CONFIG) return val;
        return sdsdup(val);
    } else {
        return sdsnew("""");
    }
}",1926.0,1934.0,1.0,30.0,9.0,13,7,8,2,0,6,3,4,1,2,,0,5,2,1,1,sds
3292,73852,sdsConfigRewrite,1,sdsConfigRewrite,"void sdsConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void sdsConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    sds val = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    rewriteConfigSdsOption(state, name, val, config->data.sds.default_value);
    if ((val) && (config->flags & MODULE_CONFIG)) sdsfree(val);
}",1936.0,1940.0,1.0,30.0,5.0,17,8,11,4,0,8,2,2,1,3,,0,6,6,3,3,void
3293,73910,enumConfigInit,1,enumConfigInit,void enumConfigInit (standardConfig*),config.c,"static void enumConfigInit(standardConfig *config) {
    *config->data.enumd.config = config->data.enumd.default_value;
}",1971.0,1973.0,1.0,1.0,3.0,8,4,2,1,0,2,1,1,0,0,,0,2,2,1,1,void
3294,73931,enumConfigSet,1,enumConfigSet,"int enumConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int enumConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    int enumval;
    int bitflags = !!(config->flags & MULTI_ARG_CONFIG);
    enumval = configEnumGetValue(config->data.enumd.enum_value, argv, argc, bitflags);

    if (enumval == INT_MIN) {
        sds enumerr = sdsnew(""argument(s) must be one of the following: "");
        configEnum *enumNode = config->data.enumd.enum_value;
        while(enumNode->name != NULL) {
            enumerr = sdscatlen(enumerr, enumNode->name,
                                strlen(enumNode->name));
            enumerr = sdscatlen(enumerr, "", "", 2);
            enumNode++;
        }
        sdsrange(enumerr,0,-3); /* Remove final "", "". */

        redis_strlcpy(loadbuf, enumerr, LOADBUF_SIZE);

        sdsfree(enumerr);
        *err = loadbuf;
        return 0;
    }
    if (config->data.enumd.is_valid_fn && !config->data.enumd.is_valid_fn(enumval, err))
        return 0;
    int prev = config->flags & MODULE_CONFI...",1975.0,2007.0,1.0,38.0,33.0,58,13,44,12,0,27,6,8,5,10,,0,23,8,4,4,int
3295,74128,enumConfigGet,1,enumConfigGet,sds enumConfigGet (standardConfig*),config.c,"static sds enumConfigGet(standardConfig *config) {
    int val = config->flags & MODULE_CONFIG ? getModuleEnumConfig(config->privdata) : *(config->data.enumd.config);
    int bitflags = !!(config->flags & MULTI_ARG_CONFIG);
    return configEnumGetName(config->data.enumd.enum_value,val,bitflags);
}",2009.0,2013.0,1.0,30.0,5.0,19,8,9,3,0,7,1,1,0,2,,0,6,2,1,1,sds
3296,74183,enumConfigRewrite,1,enumConfigRewrite,"void enumConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void enumConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    int val = config->flags & MODULE_CONFIG ? getModuleEnumConfig(config->privdata) : *(config->data.enumd.config);
    rewriteConfigEnumOption(state, name, val, config);
}",2015.0,2018.0,1.0,30.0,4.0,10,7,8,4,0,5,1,1,0,2,,0,4,6,3,3,void
3297,74220,setNumericType,1,setNumericType,"int setNumericType (standardConfig*,long long,char**)",config.c,"int setNumericType(standardConfig *config, long long val, const char **err) {
    if (config->data.numeric.numeric_type == NUMERIC_TYPE_INT) {
        *(config->data.numeric.config.i) = (int) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_UINT) {
        *(config->data.numeric.config.ui) = (unsigned int) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_LONG) {
        *(config->data.numeric.config.l) = (long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG) {
        *(config->data.numeric.config.ul) = (unsigned long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) {
        if (config->flags & MODULE_CONFIG)
            return setModuleNumericConfig(config->privdata, val, err);
        else *(config->data.numeric.config.ll) = (long long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) {
        *(config->data.numeric.config.ull) = (unsigned long...",2034.0,2059.0,1.0,28.0,26.0,11,6,4,3,2,2,2,2,1,0,,0,2,6,3,3,int
3298,74517,numericConfigInit,1,numericConfigInit,void numericConfigInit (standardConfig*),config.c,"static void numericConfigInit(standardConfig *config) {
    setNumericType(config, config->data.numeric.default_value, NULL);
}",2088.0,2090.0,1.0,1.0,3.0,3,2,3,2,0,2,1,1,0,1,,0,1,2,1,1,void
3299,74532,numericBoundaryCheck,1,numericBoundaryCheck,"int numericBoundaryCheck (standardConfig*,long long,char**)",config.c,"static int numericBoundaryCheck(standardConfig *config, long long ll, const char **err) {
    if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG ||
        config->data.numeric.numeric_type == NUMERIC_TYPE_UINT ||
        config->data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) {
        /* Boundary check for unsigned types */
        unsigned long long ull = ll;
        unsigned long long upper_bound = config->data.numeric.upper_bound;
        unsigned long long lower_bound = config->data.numeric.lower_bound;
        if (ull > upper_bound || ull < lower_bound) {
            if (config->data.numeric.flags & OCTAL_CONFIG) {
                snprintf(loadbuf, LOADBUF_SIZE,
                    ""argument must be between %llo and %llo inclusive"",
                    lower_bound,
                    upper_bound);
            } else {
                snprintf(loadbuf, LOADBUF_SIZE,
                    ""argument must be between %llu and %llu inclusive"",
                    low...",2092.0,2137.0,1.0,45.0,46.0,33,10,22,10,1,8,4,7,4,0,,0,8,6,3,3,int
3300,74745,numericParseString,1,numericParseString,"int numericParseString (standardConfig*,sds,char**,long long*)",config.c,"static int numericParseString(standardConfig *config, sds value, const char **err, long long *res) {
    /* First try to parse as memory */
    if (config->data.numeric.flags & MEMORY_CONFIG) {
        int memerr;
        *res = memtoull(value, &memerr);
        if (!memerr)
            return 1;
    }

    /* Attempt to parse as percent */
    if (config->data.numeric.flags & PERCENT_CONFIG &&
        sdslen(value) > 1 && value[sdslen(value)-1] == '%' &&
        string2ll(value, sdslen(value)-1, res) &&
        *res >= 0) {
            /* We store percentage as negative value */
            *res = -*res;
            return 1;
    }

    /* Attempt to parse as an octal number */
    if (config->data.numeric.flags & OCTAL_CONFIG) {
        char *endptr;
        errno = 0;
        *res = strtoll(value, &endptr, 8);
        if (errno == 0 && *endptr == '\0')
            return 1; /* No overflow or invalid characters */
    }

    /* Attempt a simple number (no special flags set) */
   ...",2139.0,2182.0,1.0,37.0,44.0,60,15,29,7,1,13,8,10,12,7,,0,13,8,4,4,int
3301,74972,numericConfigSet,1,numericConfigSet,"int numericConfigSet (standardConfig*,sds*,int,char**)",config.c,"static int numericConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    long long ll, prev = 0;

    if (!numericParseString(config, argv[0], err, &ll))
        return 0;

    if (!numericBoundaryCheck(config, ll, err))
        return 0;

    if (config->data.numeric.is_valid_fn && !config->data.numeric.is_valid_fn(ll, err))
        return 0;

    GET_NUMERIC_TYPE(prev)
    if (prev != ll) {
        return setNumericType(config, ll, err);
    }

    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",2184.0,2203.0,1.0,4.0,20.0,124,14,64,16,0,30,5,5,5,5,,0,29,8,4,4,int
3302,75327,numericConfigGet,1,numericConfigGet,sds numericConfigGet (standardConfig*),config.c,"static sds numericConfigGet(standardConfig *config) {
    char buf[128];

    long long value = 0;
    GET_NUMERIC_TYPE(value)

    if (config->data.numeric.flags & PERCENT_CONFIG && value < 0) {
        int len = ll2string(buf, sizeof(buf), -value);
        buf[len] = '%';
        buf[len+1] = '\0';
    }
    else if (config->data.numeric.flags & MEMORY_CONFIG) {
        ull2string(buf, sizeof(buf), value);
    } else if (config->data.numeric.flags & OCTAL_CONFIG) {
        snprintf(buf, sizeof(buf), ""%llo"", value);
    } else {
        ll2string(buf, sizeof(buf), value);
    }
    return sdsnew(buf);
}",2205.0,2224.0,1.0,4.0,20.0,121,13,56,14,0,26,2,2,1,3,,0,25,2,1,1,sds
3303,75700,numericConfigRewrite,1,numericConfigRewrite,"void numericConfigRewrite (standardConfig*,char*,rewriteConfigState*)",config.c,"static void numericConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    long long value = 0;

    GET_NUMERIC_TYPE(value)

    if (config->data.numeric.flags & PERCENT_CONFIG && value < 0) {
        rewriteConfigPercentOption(state, name, -value, config->data.numeric.default_value);
    } else if (config->data.numeric.flags & MEMORY_CONFIG) {
        rewriteConfigBytesOption(state, name, value, config->data.numeric.default_value);
    } else if (config->data.numeric.flags & OCTAL_CONFIG) {
        rewriteConfigOctalOption(state, name, value, config->data.numeric.default_value);
    } else {
        rewriteConfigNumericalOption(state, name, value, config->data.numeric.default_value);
    }
}",2226.0,2240.0,1.0,4.0,15.0,117,10,51,14,0,26,2,2,1,2,,0,25,6,3,3,void
3304,76079,isValidActiveDefrag,1,isValidActiveDefrag,"int isValidActiveDefrag (int,char**)",config.c,"static int isValidActiveDefrag(int val, const char **err) {
#ifndef HAVE_DEFRAG
    if (val) {
        *err = ""Active defragmentation cannot be enabled: it ""
               ""requires a Redis server compiled with a modified Jemalloc ""
               ""like the one shipped by default with the Redis source ""
               ""distribution"";
        return 0;
    }
#else
    UNUSED(val);
    UNUSED(err);
#endif
    return 1;
}",2329.0,2343.0,1.0,1.0,15.0,2,2,2,2,0,0,2,2,0,0,,0,0,4,2,2,int
3305,76096,isValidDBfilename,1,isValidDBfilename,"int isValidDBfilename (char*,char**)",config.c,"static int isValidDBfilename(char *val, const char **err) {
    if (!pathIsBaseName(val)) {
        *err = ""dbfilename can't be a path, just a filename"";
        return 0;
    }
    return 1;
}",2345.0,2351.0,1.0,1.0,7.0,3,3,2,2,0,1,2,2,1,1,,0,1,4,2,2,int
3306,76115,isValidAOFfilename,1,isValidAOFfilename,"int isValidAOFfilename (char*,char**)",config.c,"static int isValidAOFfilename(char *val, const char **err) {
    if (!strcmp(val, """")) {
        *err = ""appendfilename can't be empty"";
        return 0;
    }
    if (!pathIsBaseName(val)) {
        *err = ""appendfilename can't be a path, just a filename"";
        return 0;
    }
    return 1;
}",2353.0,2363.0,1.0,1.0,11.0,6,3,4,2,0,1,3,3,1,1,,0,1,4,2,2,int
3307,76146,isValidAOFdirname,1,isValidAOFdirname,"int isValidAOFdirname (char*,char**)",config.c,"static int isValidAOFdirname(char *val, const char **err) {
    if (!strcmp(val, """")) {
        *err = ""appenddirname can't be empty"";
        return 0;
    }
    if (!pathIsBaseName(val)) {
        *err = ""appenddirname can't be a path, just a dirname"";
        return 0;
    }
    return 1;
}",2365.0,2375.0,1.0,1.0,11.0,6,3,4,2,0,1,3,3,1,1,,0,1,4,2,2,int
3308,76177,isValidShutdownOnSigFlags,1,isValidShutdownOnSigFlags,"int isValidShutdownOnSigFlags (int,char**)",config.c,"static int isValidShutdownOnSigFlags(int val, const char **err) {
    /* Individual arguments are validated by createEnumConfig logic.
     * We just need to ensure valid combinations here. */
    if (val & SHUTDOWN_NOSAVE && val & SHUTDOWN_SAVE) {
        *err = ""shutdown options SAVE and NOSAVE can't be used simultaneously"";
        return 0;
    }
    return 1;
}",2377.0,2385.0,1.0,14.0,9.0,5,4,3,2,0,0,2,2,0,0,,0,0,4,2,2,int
3309,76204,isValidAnnouncedNodename,1,isValidAnnouncedNodename,"int isValidAnnouncedNodename (char*,char**)",config.c,"static int isValidAnnouncedNodename(char *val,const char **err) {
    if (!(isValidAuxString(val,sdslen(val)))) {
        *err = ""Announced human node name contained invalid character"";
	return 0;
    }
    return 1;
}",2387.0,2393.0,1.0,1.0,7.0,3,3,3,2,0,2,2,2,2,2,,0,2,4,2,2,int
3310,76225,isValidAnnouncedHostname,1,isValidAnnouncedHostname,"int isValidAnnouncedHostname (char*,char**)",config.c,"static int isValidAnnouncedHostname(char *val, const char **err) {
    if (strlen(val) >= NET_HOST_STR_LEN) {
        *err = ""Hostnames must be less than ""
            STRINGIFY(NET_HOST_STR_LEN) "" characters"";
        return 0;
    }

    int i = 0;
    char c;
    while ((c = val[i])) {
        /* We just validate the character set to make sure that everything
         * is parsed and handled correctly. */
        if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
            || (c >= '0' && c <= '9') || (c == '-') || (c == '.')))
        {
            *err = ""Hostnames may only contain alphanumeric characters, ""
                ""hyphens or dots"";
            return 0;
        }
        c = val[i++];
    }
    return 1;
}",2395.0,2417.0,1.0,23.0,23.0,27,10,18,4,0,0,4,5,0,0,,0,0,4,2,2,int
3311,76305,isValidProcTitleTemplate,1,isValidProcTitleTemplate,"int isValidProcTitleTemplate (char*,char**)",config.c,"static int isValidProcTitleTemplate(char *val, const char **err) {
    if (!validateProcTitleTemplate(val)) {
        *err = ""template format is invalid or contains unknown variables"";
        return 0;
    }
    return 1;
}",2420.0,2426.0,1.0,1.0,7.0,3,3,2,2,0,1,2,2,1,1,,0,1,4,2,2,int
3312,76324,updateLocaleCollate,1,updateLocaleCollate,int updateLocaleCollate (char**),config.c,"static int updateLocaleCollate(const char **err) {
    const char *s = setlocale(LC_COLLATE, server.locale_collate);
    if (s == NULL) {
        *err = ""Invalid locale name"";
        return 0;
    }
    return 1;
}",2428.0,2435.0,1.0,1.0,8.0,5,4,6,5,0,0,2,2,0,0,,0,0,2,1,1,int
3313,76350,updateProcTitleTemplate,1,updateProcTitleTemplate,int updateProcTitleTemplate (char**),config.c,"static int updateProcTitleTemplate(const char **err) {
    if (redisSetProcTitle(NULL) == C_ERR) {
        *err = ""failed to set process title"";
        return 0;
    }
    return 1;
}",2437.0,2443.0,1.0,35.0,7.0,4,4,2,2,0,1,2,2,1,1,,0,1,2,1,1,int
3314,76372,updateHZ,1,updateHZ,int updateHZ (char**),config.c,"static int updateHZ(const char **err) {
    UNUSED(err);
    /* Hz is more a hint from the user, so we accept values out of range
     * but cap them to reasonable values. */
    if (server.config_hz < CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
    if (server.config_hz > CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
    server.hz = server.config_hz;
    return 1;
}",2445.0,2453.0,1.0,4.0,9.0,12,5,8,2,0,0,3,3,0,0,,0,0,2,1,1,int
3315,76424,updatePort,1,updatePort,int updatePort (char**),config.c,"static int updatePort(const char **err) {
    connListener *listener = listenerByType(CONN_TYPE_SOCKET);

    serverAssert(listener != NULL);
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.port;
    listener->ct = connectionByType(CONN_TYPE_SOCKET);
    if (changeListener(listener) == C_ERR) {
        *err = ""Unable to listen on this port. Check server logs."";
        return 0;
    }

    return 1;
}",2455.0,2469.0,1.0,44.0,15.0,21,11,12,4,0,8,2,2,1,4,,0,7,2,1,1,int
3316,76498,updateJemallocBgThread,1,updateJemallocBgThread,int updateJemallocBgThread (char**),config.c,"static int updateJemallocBgThread(const char **err) {
    UNUSED(err);
    set_jemalloc_bg_thread(server.jemalloc_bg_thread);
    return 1;
}",2471.0,2475.0,1.0,4.0,5.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,int
3317,76515,updateReplBacklogSize,1,updateReplBacklogSize,int updateReplBacklogSize (char**),config.c,"static int updateReplBacklogSize(const char **err) {
    UNUSED(err);
    resizeReplicationBacklog();
    return 1;
}",2477.0,2481.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3318,76529,updateMaxmemory,1,updateMaxmemory,int updateMaxmemory (char**),config.c,"static int updateMaxmemory(const char **err) {
    UNUSED(err);
    if (server.maxmemory) {
        size_t used = zmalloc_used_memory()-freeMemoryGetNotCountedMemory();
        if (server.maxmemory < used) {
            serverLog(LL_WARNING,""WARNING: the new maxmemory value set via CONFIG SET (%llu) is smaller than the current memory usage (%zu). This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy."", server.maxmemory, used);
        }
        startEvictionTimeProc();
    }
    return 1;
}",2483.0,2493.0,1.0,4.0,11.0,10,6,9,3,0,4,3,4,0,4,,0,2,2,1,1,int
3319,76583,updateGoodSlaves,1,updateGoodSlaves,int updateGoodSlaves (char**),config.c,"static int updateGoodSlaves(const char **err) {
    UNUSED(err);
    refreshGoodSlavesCount();
    return 1;
}",2495.0,2499.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3320,76597,updateWatchdogPeriod,1,updateWatchdogPeriod,int updateWatchdogPeriod (char**),config.c,"static int updateWatchdogPeriod(const char **err) {
    UNUSED(err);
    applyWatchdogPeriod();
    return 1;
}",2501.0,2505.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3321,76611,updateAppendonly,1,updateAppendonly,int updateAppendonly (char**),config.c,"static int updateAppendonly(const char **err) {
    if (!server.aof_enabled && server.aof_state != AOF_OFF) {
        stopAppendOnly();
    } else if (server.aof_enabled && server.aof_state == AOF_OFF) {
        if (startAppendOnly() == C_ERR) {
            *err = ""Unable to turn on AOF. Check server logs."";
            return 0;
        }
    }
    return 1;
}",2507.0,2517.0,1.0,51.0,11.0,5,4,2,1,0,1,2,2,0,1,,0,0,2,1,1,int
3322,76662,updateAofAutoGCEnabled,1,updateAofAutoGCEnabled,int updateAofAutoGCEnabled (char**),config.c,"static int updateAofAutoGCEnabled(const char **err) {
    UNUSED(err);
    if (!server.aof_disable_auto_gc) {
        aofDelHistoryFiles();
    }

    return 1;
}",2519.0,2526.0,1.0,4.0,8.0,3,3,3,2,0,1,2,2,0,1,,0,0,2,1,1,int
3323,76682,updateSighandlerEnabled,1,updateSighandlerEnabled,int updateSighandlerEnabled (char**),config.c,"static int updateSighandlerEnabled(const char **err) {
    UNUSED(err);
    if (server.crashlog_enabled)
        setupSignalHandlers();
    else
        removeSignalHandlers();
    return 1;
}",2528.0,2535.0,1.0,4.0,8.0,2,2,3,2,0,1,2,2,0,1,,0,0,2,1,1,int
3324,76704,updateMaxclients,1,updateMaxclients,int updateMaxclients (char**),config.c,"static int updateMaxclients(const char **err) {
    unsigned int new_maxclients = server.maxclients;
    adjustOpenFilesLimit();
    if (server.maxclients != new_maxclients) {
        static char msg[128];
        snprintf(msg, sizeof(msg), ""The operating system is not able to handle the specified number of clients, try with %d"", server.maxclients);
        *err = msg;
        return 0;
    }
    if ((unsigned int) aeGetSetSize(server.el) <
        server.maxclients + CONFIG_FDSET_INCR)
    {
        if (aeResizeSetSize(server.el,
            server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
        {
            *err = ""The event loop API used by Redis is not able to handle the specified number of clients"";
            return 0;
        }
    }
    return 1;
}",2537.0,2557.0,1.0,28.0,21.0,22,10,14,4,0,3,4,5,2,3,,0,2,2,1,1,int
3325,76784,updateOOMScoreAdj,1,updateOOMScoreAdj,int updateOOMScoreAdj (char**),config.c,"static int updateOOMScoreAdj(const char **err) {
    if (setOOMScoreAdj(-1) == C_ERR) {
        *err = ""Failed to set current oom_score_adj. Check server logs."";
        return 0;
    }

    return 1;
}",2559.0,2566.0,1.0,30.0,8.0,5,4,1,1,0,1,2,2,1,1,,0,1,2,1,1,int
3326,76807,updateRequirePass,1,updateRequirePass,int updateRequirePass (char**),config.c,"int updateRequirePass(const char **err) {
    UNUSED(err);
    /* The old ""requirepass"" directive just translates to setting
     * a password to the default user. The only thing we do
     * additionally is to remember the cleartext password in this
     * case, for backward compatibility with Redis <= 5. */
    ACLUpdateDefaultUserPassword(server.requirepass);
    return 1;
}",2568.0,2576.0,1.0,4.0,9.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,int
3327,76824,updateAppendFsync,1,updateAppendFsync,int updateAppendFsync (char**),config.c,"int updateAppendFsync(const char **err) {
    UNUSED(err);
    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        /* Wait for all bio jobs related to AOF to drain before proceeding. This prevents a race
         * between updates to `fsynced_reploff_pending` done in the main thread and those done on the
         * worker thread. */
        bioDrainWorker(BIO_AOF_FSYNC);
    }
    return 1;
}",2578.0,2587.0,1.0,4.0,10.0,3,3,4,3,0,1,2,2,0,1,,0,0,2,1,1,int
3328,76848,applyBind,1,applyBind,int applyBind (char**),config.c,"static int applyBind(const char **err) {
    connListener *tcp_listener = listenerByType(CONN_TYPE_SOCKET);
    connListener *tls_listener = listenerByType(CONN_TYPE_TLS);

    serverAssert(tcp_listener != NULL);
    tcp_listener->bindaddr = server.bindaddr;
    tcp_listener->bindaddr_count = server.bindaddr_count;
    tcp_listener->port = server.port;
    tcp_listener->ct = connectionByType(CONN_TYPE_SOCKET);
    if (changeListener(tcp_listener) == C_ERR) {
        *err = ""Failed to bind to specified addresses."";
        if (tls_listener)
            closeListener(tls_listener); /* failed with TLS together */
        return 0;
    }

    if (server.tls_port != 0) {
        serverAssert(tls_listener != NULL);
        tls_listener->bindaddr = server.bindaddr;
        tls_listener->bindaddr_count = server.bindaddr_count;
        tls_listener->port = server.tls_port;
        tls_listener->ct = connectionByType(CONN_TYPE_TLS);
        if (changeListener(tls_listener) == C_ERR) {
       ...",2590.0,2620.0,1.0,48.0,31.0,44,11,28,5,0,18,5,7,2,10,,0,14,2,1,1,int
3329,77003,updateClusterFlags,1,updateClusterFlags,int updateClusterFlags (char**),config.c,"int updateClusterFlags(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfFlags();
    return 1;
}",2622.0,2626.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3330,77017,updateClusterAnnouncedPort,1,updateClusterAnnouncedPort,int updateClusterAnnouncedPort (char**),config.c,"static int updateClusterAnnouncedPort(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfAnnouncedPorts();
    return 1;
}",2628.0,2632.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3331,77031,updateClusterIp,1,updateClusterIp,int updateClusterIp (char**),config.c,"static int updateClusterIp(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfIp();
    return 1;
}",2634.0,2638.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3332,77045,updateClusterHostname,1,updateClusterHostname,int updateClusterHostname (char**),config.c,"int updateClusterHostname(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfHostname();
    return 1;
}",2640.0,2644.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3333,77059,updateClusterHumanNodename,1,updateClusterHumanNodename,int updateClusterHumanNodename (char**),config.c,"int updateClusterHumanNodename(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfHumanNodename();
    return 1;
}",2646.0,2650.0,1.0,4.0,5.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,int
3334,77073,applyTlsCfg,1,applyTlsCfg,int applyTlsCfg (char**),config.c,"static int applyTlsCfg(const char **err) {
    UNUSED(err);

    /* If TLS is enabled, try to configure OpenSSL. */
    if ((server.tls_port || server.tls_replication || server.tls_cluster)
         && connTypeConfigure(connectionTypeTls(), &server.tls_ctx_config, 1) == C_ERR) {
        *err = ""Unable to update TLS configuration. Check server logs."";
        return 0;
    }
    return 1;
}",2652.0,2662.0,1.0,4.0,11.0,13,9,7,2,0,2,2,2,2,2,,0,2,2,1,1,int
3335,77118,applyTLSPort,1,applyTLSPort,int applyTLSPort (char**),config.c,"static int applyTLSPort(const char **err) {
    /* Configure TLS in case it wasn't enabled */
    if (connTypeConfigure(connectionTypeTls(), &server.tls_ctx_config, 0) == C_ERR) {
        *err = ""Unable to update TLS configuration. Check server logs."";
        return 0;
    }

    connListener *listener = listenerByType(CONN_TYPE_TLS);
    serverAssert(listener != NULL);
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.tls_port;
    listener->ct = connectionByType(CONN_TYPE_TLS);
    if (changeListener(listener) == C_ERR) {
        *err = ""Unable to listen on this port. Check server logs."";
        return 0;
    }

    return 1;
}",2664.0,2683.0,1.0,77.0,20.0,27,12,14,4,0,10,3,3,3,6,,0,9,2,1,1,int
3336,77212,setConfigDirOption,1,setConfigDirOption,"int setConfigDirOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigDirOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    if (argc != 1) {
        *err = ""wrong number of arguments"";
        return 0;
    }
    if (chdir(argv[0]) == -1) {
        *err = strerror(errno);
        return 0;
    }
    return 1;
}",2685.0,2696.0,1.0,4.0,12.0,9,7,7,5,0,0,3,3,0,0,,0,0,8,4,4,int
3337,77255,getConfigDirOption,1,getConfigDirOption,sds getConfigDirOption (standardConfig*),config.c,"static sds getConfigDirOption(standardConfig *config) {
    UNUSED(config);
    char buf[1024];

    if (getcwd(buf,sizeof(buf)) == NULL)
        buf[0] = '\0';

    return sdsnew(buf);
}",2698.0,2706.0,1.0,4.0,9.0,5,5,7,3,0,1,2,2,0,1,,0,0,2,1,1,sds
3338,77283,setConfigSaveOption,1,setConfigSaveOption,"int setConfigSaveOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigSaveOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    int j;

    /* Special case: treat single arg """" as zero args indicating empty save configuration */
    if (argc == 1 && !strcasecmp(argv[0],"""")) {
        resetServerSaveParams();
        argc = 0;
    }

    /* Perform sanity check before setting the new config:
    * - Even number of args
    * - Seconds >= 1, changes >= 0 */
    if (argc & 1) {
        *err = ""Invalid save parameters"";
        return 0;
    }
    for (j = 0; j < argc; j++) {
        char *eptr;
        long val;

        val = strtoll(argv[j], &eptr, 10);
        if (eptr[0] != '\0' ||
            ((j & 1) == 0 && val < 1) ||
            ((j & 1) == 1 && val < 0)) {
            *err = ""Invalid save parameters"";
            return 0;
        }
    }
    /* Finally set the new config */
    if (!reading_config_file) {
        resetServerSaveParams();
    } else {
        /* We don't reset save p...",2708.0,2761.0,1.0,4.0,54.0,36,13,34,11,0,4,7,8,1,3,,0,1,8,4,4,int
3339,77436,getConfigSaveOption,1,getConfigSaveOption,sds getConfigSaveOption (standardConfig*),config.c,"static sds getConfigSaveOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;

    for (j = 0; j < server.saveparamslen; j++) {
        buf = sdscatprintf(buf,""%jd %d"",
                           (intmax_t)server.saveparams[j].seconds,
                           server.saveparams[j].changes);
        if (j != server.saveparamslen-1)
            buf = sdscatlen(buf,"" "",1);
    }

    return buf;
}",2763.0,2777.0,1.0,4.0,15.0,17,7,17,4,0,3,3,4,0,3,,0,3,2,1,1,sds
3340,77503,setConfigClientOutputBufferLimitOption,1,setConfigClientOutputBufferLimitOption,"int setConfigClientOutputBufferLimitOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigClientOutputBufferLimitOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    return updateClientOutputBufferLimit(argv, argc, err);
}",2779.0,2782.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3341,77522,getConfigClientOutputBufferLimitOption,1,getConfigClientOutputBufferLimitOption,sds getConfigClientOutputBufferLimitOption (standardConfig*),config.c,"static sds getConfigClientOutputBufferLimitOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;
    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
        buf = sdscatprintf(buf,""%s %llu %llu %ld"",
                           getClientTypeName(j),
                           server.client_obuf_limits[j].hard_limit_bytes,
                           server.client_obuf_limits[j].soft_limit_bytes,
                           (long) server.client_obuf_limits[j].soft_limit_seconds);
        if (j != CLIENT_TYPE_OBUF_COUNT-1)
            buf = sdscatlen(buf,"" "",1);
    }
    return buf;
}",2784.0,2798.0,1.0,4.0,15.0,18,7,18,4,0,4,3,4,0,4,,0,4,2,1,1,sds
3342,77598,setConfigOOMScoreAdjValuesOption,1,setConfigOOMScoreAdjValuesOption,"int setConfigOOMScoreAdjValuesOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigOOMScoreAdjValuesOption(standardConfig *config, sds *argv, int argc, const char **err) {
    int i;
    int values[CONFIG_OOM_COUNT];
    int change = 0;
    UNUSED(config);

    if (argc != CONFIG_OOM_COUNT) {
        *err = ""wrong number of arguments"";
        return 0;
    }

    for (i = 0; i < CONFIG_OOM_COUNT; i++) {
        char *eptr;
        long long val = strtoll(argv[i], &eptr, 10);

        if (*eptr != '\0' || val < -2000 || val > 2000) {
            if (err) *err = ""Invalid oom-score-adj-values, elements must be between -2000 and 2000."";
            return 0;
        }

        values[i] = val;
    }

    /* Verify that the values make sense. If they don't omit a warning but
     * keep the configuration, which may still be valid for privileged processes.
     */

    if (values[CONFIG_OOM_REPLICA] < values[CONFIG_OOM_MASTER] ||
        values[CONFIG_OOM_BGCHILD] < values[CONFIG_OOM_REPLICA])
    {
        serverLog(LL_WARNING,
                  ""T...",2803.0,2846.0,1.0,15.0,44.0,43,13,36,10,0,1,8,12,0,1,,0,0,8,4,4,int
3343,77768,getConfigOOMScoreAdjValuesOption,1,getConfigOOMScoreAdjValuesOption,sds getConfigOOMScoreAdjValuesOption (standardConfig*),config.c,"static sds getConfigOOMScoreAdjValuesOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;

    for (j = 0; j < CONFIG_OOM_COUNT; j++) {
        buf = sdscatprintf(buf,""%d"", server.oom_score_adj_values[j]);
        if (j != CONFIG_OOM_COUNT-1)
            buf = sdscatlen(buf,"" "",1);
    }

    return buf;
}",2848.0,2860.0,1.0,4.0,13.0,10,7,13,4,0,3,3,4,0,3,,0,3,2,1,1,sds
3344,77824,setConfigNotifyKeyspaceEventsOption,1,setConfigNotifyKeyspaceEventsOption,"int setConfigNotifyKeyspaceEventsOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigNotifyKeyspaceEventsOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    if (argc != 1) {
        *err = ""wrong number of arguments"";
        return 0;
    }
    int flags = keyspaceEventsStringToFlags(argv[0]);
    if (flags == -1) {
        *err = ""Invalid event class character. Use 'Ag$lshzxeKEtmdn'."";
        return 0;
    }
    server.notify_keyspace_events = flags;
    return 1;
}",2862.0,2875.0,1.0,4.0,14.0,12,8,10,6,0,1,3,3,0,1,,0,1,8,4,4,int
3345,77875,getConfigNotifyKeyspaceEventsOption,1,getConfigNotifyKeyspaceEventsOption,sds getConfigNotifyKeyspaceEventsOption (standardConfig*),config.c,"static sds getConfigNotifyKeyspaceEventsOption(standardConfig *config) {
    UNUSED(config);
    return keyspaceEventsFlagsToString(server.notify_keyspace_events);
}",2877.0,2880.0,1.0,4.0,4.0,2,2,3,2,0,1,1,1,0,1,,0,0,2,1,1,sds
3346,77891,setConfigBindOption,1,setConfigBindOption,"int setConfigBindOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigBindOption(standardConfig *config, sds* argv, int argc, const char **err) {
    UNUSED(config);
    int j;

    if (argc > CONFIG_BINDADDR_MAX) {
        *err = ""Too many bind addresses specified."";
        return 0;
    }

    /* A single empty argument is treated as a zero bindaddr count */
    if (argc == 1 && sdslen(argv[0]) == 0) argc = 0;

    /* Free old bind addresses */
    for (j = 0; j < server.bindaddr_count; j++) {
        zfree(server.bindaddr[j]);
    }
    for (j = 0; j < argc; j++)
        server.bindaddr[j] = zstrdup(argv[j]);
    server.bindaddr_count = argc;

    return 1;
}",2882.0,2903.0,1.0,4.0,22.0,18,9,17,6,0,2,5,5,1,2,,0,1,8,4,4,int
3347,77980,setConfigReplicaOfOption,1,setConfigReplicaOfOption,"int setConfigReplicaOfOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigReplicaOfOption(standardConfig *config, sds* argv, int argc, const char **err) {
    UNUSED(config);

    if (argc != 2) {
        *err = ""wrong number of arguments"";
        return 0;
    }

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (!strcasecmp(argv[0], ""no"") && !strcasecmp(argv[1], ""one"")) {
        return 1;
    }
    char *ptr;
    server.masterport = strtol(argv[1], &ptr, 10);
    if (server.masterport < 0 || server.masterport > 65535 || *ptr != '\0') {
        *err = ""Invalid master port"";
        return 0;
    }
    server.masterhost = sdsnew(argv[0]);
    server.repl_state = REPL_STATE_CONNECT;
    return 1;
}",2905.0,2927.0,1.0,4.0,23.0,31,12,20,8,0,2,4,4,0,2,,0,1,8,4,4,int
3348,78082,getConfigBindOption,1,getConfigBindOption,sds getConfigBindOption (standardConfig*),config.c,"static sds getConfigBindOption(standardConfig *config) {
    UNUSED(config);
    return sdsjoin(server.bindaddr,server.bindaddr_count,"" "");
}",2929.0,2932.0,1.0,4.0,4.0,3,2,4,2,0,1,1,1,0,1,,0,0,2,1,1,sds
3349,78102,getConfigReplicaOfOption,1,getConfigReplicaOfOption,sds getConfigReplicaOfOption (standardConfig*),config.c,"static sds getConfigReplicaOfOption(standardConfig *config) {
    UNUSED(config);
    char buf[256];
    if (server.masterhost)
        snprintf(buf,sizeof(buf),""%s %d"",
                 server.masterhost, server.masterport);
    else
        buf[0] = '\0';
    return sdsnew(buf);
}",2934.0,2943.0,1.0,4.0,10.0,5,3,8,3,0,1,2,2,0,1,,0,0,2,1,1,sds
3350,78140,allowProtectedAction,1,allowProtectedAction,"int allowProtectedAction (int,client*)",config.c,"int allowProtectedAction(int config, client *c) {
    return (config == PROTECTED_ACTION_ALLOWED_YES) ||
           (config == PROTECTED_ACTION_ALLOWED_LOCAL && (connIsLocal(c->conn) == 1));
}",2945.0,2948.0,1.0,22.0,4.0,6,4,3,2,3,2,1,1,0,1,,0,1,4,2,2,int
3351,78165,setConfigLatencyTrackingInfoPercentilesOutputOption,1,setConfigLatencyTrackingInfoPercentilesOutputOption,"int setConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*,sds*,int,char**)",config.c,"static int setConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    zfree(server.latency_tracking_info_percentiles);
    server.latency_tracking_info_percentiles = NULL;
    server.latency_tracking_info_percentiles_len = argc;

    /* Special case: treat single arg """" as zero args indicating empty percentile configuration */
    if (argc == 1 && sdslen(argv[0]) == 0)
        server.latency_tracking_info_percentiles_len = 0;
    else
        server.latency_tracking_info_percentiles = zmalloc(sizeof(double)*argc);

    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        double percentile;
        if (!string2d(argv[j], sdslen(argv[j]), &percentile)) {
            *err = ""Invalid latency-tracking-info-percentiles parameters"";
            goto configerr;
        }
        if (percentile > 100.0 || percentile < 0.0) {
            *err = ""latency-tracking-info-percentiles param...",2951.0,2982.0,1.0,4.0,32.0,34,12,29,8,0,5,7,7,3,5,,0,3,8,4,4,int
3352,78294,getConfigLatencyTrackingInfoPercentilesOutputOption,1,getConfigLatencyTrackingInfoPercentilesOutputOption,sds getConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*),config.c,"static sds getConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        char fbuf[128];
        size_t len = snprintf(fbuf, sizeof(fbuf), ""%f"", server.latency_tracking_info_percentiles[j]);
        len = trimDoubleString(fbuf, len);
        buf = sdscatlen(buf, fbuf, len);
        if (j != server.latency_tracking_info_percentiles_len-1)
            buf = sdscatlen(buf,"" "",1);
    }
    return buf;
}",2984.0,2996.0,1.0,4.0,13.0,15,8,23,6,0,4,3,4,0,4,,0,4,2,1,1,sds
3353,78365,rewriteConfigLatencyTrackingInfoPercentilesOutputOption,1,rewriteConfigLatencyTrackingInfoPercentilesOutputOption,"void rewriteConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*,char*,rewriteConfigState*)",config.c,"void rewriteConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    sds line = sdsnew(name);
    /* Rewrite latency-tracking-info-percentiles parameters,
     * or an empty 'latency-tracking-info-percentiles """"' line to avoid the
     * defaults from being used.
     */
    if (!server.latency_tracking_info_percentiles_len) {
        line = sdscat(line,"" \""\"""");
    } else {
        for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
            char fbuf[128];
            size_t len = snprintf(fbuf, sizeof(fbuf), "" %f"", server.latency_tracking_info_percentiles[j]);
            len = trimDoubleString(fbuf, len);
            line = sdscatlen(line, fbuf, len);
        }
    }
    rewriteConfigRewriteLine(state,name,line,1);
}",2999.0,3017.0,1.0,4.0,19.0,5,4,10,5,0,3,2,2,0,3,,0,2,6,3,3,void
3354,78440,applyClientMaxMemoryUsage,1,applyClientMaxMemoryUsage,int applyClientMaxMemoryUsage (char**),config.c,"static int applyClientMaxMemoryUsage(const char **err) {
    UNUSED(err);
    listIter li;
    listNode *ln;

    /* server.client_mem_usage_buckets is an indication that the previous config
     * was non-zero, in which case we can exit and no apply is needed. */
    if(server.maxmemory_clients !=0 && server.client_mem_usage_buckets)
        return 1;
    if (server.maxmemory_clients != 0)
        initServerClientMemUsageBuckets();

    /* When client eviction is enabled update memory buckets for all clients.
     * When disabled, clear that data structure. */
    listRewind(server.clients, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (server.maxmemory_clients == 0) {
            /* Remove client from memory usage bucket. */
            removeClientFromMemUsageBucket(c, 0);
        } else {
            /* Update each client(s) memory usage and add to appropriate bucket. */
            updateClientMemUsageAndBucket(c);
        }
...",3019.0,3048.0,1.0,4.0,30.0,18,8,16,6,0,6,6,7,1,5,,0,2,2,1,1,int
3355,96540,registerConfigValue,1,registerConfigValue,"int registerConfigValue (char*,standardConfig*,int)",config.c,"int registerConfigValue(const char *name, const standardConfig *config, int alias) {
    standardConfig *new = zmalloc(sizeof(standardConfig));
    memcpy(new, config, sizeof(standardConfig));
    if (alias) {
        new->flags |= ALIAS_CONFIG;
        new->name = config->alias;
        new->alias = config->name;
    }

    return dictAdd(configs, sdsnew(name), new) == DICT_OK;
}",3271.0,3281.0,1.0,22.0,11.0,12,5,14,6,6,9,2,2,0,3,,0,8,6,3,3,int
3356,96594,initConfigValues,1,initConfigValues,void initConfigValues (void),config.c,"void initConfigValues(void) {
    configs = dictCreate(&sdsHashDictType);
    dictExpand(configs, sizeof(static_configs) / sizeof(standardConfig));
    for (standardConfig *config = static_configs; config->name != NULL; config++) {
        if (config->interface.init) config->interface.init(config);
        /* Add the primary config to the dictionary. */
        int ret = registerConfigValue(config->name, config, 0);
        serverAssert(ret);

        /* Aliases are the same as their primary counter parts, but they
         * also have a flag indicating they are the alias. */
        if (config->alias) {
            int ret = registerConfigValue(config->alias, config, ALIAS_CONFIG);
            serverAssert(ret);
        }
    }
}",3285.0,3301.0,1.0,8.0,17.0,26,12,23,7,1,11,4,6,0,7,,0,7,2,1,1,void
3357,96696,removeConfig,1,removeConfig,void removeConfig (sds),config.c,"void removeConfig(sds name) {
    standardConfig *config = lookupConfig(name);
    if (!config) return;
    if (config->flags & MODULE_CONFIG) {
        sdsfree((sds) config->name);
        if (config->type == ENUM_CONFIG) {
            configEnum *enumNode = config->data.enumd.enum_value;
            while(enumNode->name != NULL) {
                zfree(enumNode->name);
                enumNode++;
            }
            zfree(config->data.enumd.enum_value);
        } else if (config->type == SDS_CONFIG) {
            if (config->data.sds.default_value) sdsfree((sds)config->data.sds.default_value);
        }
    }
    dictDelete(configs, name);
}",3304.0,3321.0,1.0,24.0,18.0,20,10,16,6,1,13,5,8,3,5,,0,9,2,1,1,void
3358,96797,addModuleBoolConfig,1,addModuleBoolConfig,"void addModuleBoolConfig (char*,char*,int,void*,int)",config.c,"void addModuleBoolConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    int config_dummy_address;
    standardConfig module_config = createBoolConfig(config_name, NULL, flags | MODULE_CONFIG, config_dummy_address, default_val, NULL, NULL);
    module_config.data.yesno.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3328.0,3335.0,1.0,35.0,8.0,35,6,39,11,1,5,1,1,0,3,,0,4,10,5,5,void
3359,96915,addModuleStringConfig,1,addModuleStringConfig,"void addModuleStringConfig (char*,char*,int,void*,sds)",config.c,"void addModuleStringConfig(const char *module_name, const char *name, int flags, void *privdata, sds default_val) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    sds config_dummy_address;
    standardConfig module_config = createSDSConfig(config_name, NULL, flags | MODULE_CONFIG, 0, config_dummy_address, default_val, NULL, NULL);
    module_config.data.sds.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3337.0,3344.0,1.0,35.0,8.0,37,6,41,11,1,5,1,1,0,3,,0,4,10,5,5,void
3360,97041,addModuleEnumConfig,1,addModuleEnumConfig,"void addModuleEnumConfig (char*,char*,int,void*,int,configEnum*)",config.c,"void addModuleEnumConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val, configEnum *enum_vals) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    int config_dummy_address;
    standardConfig module_config = createEnumConfig(config_name, NULL, flags | MODULE_CONFIG, enum_vals, config_dummy_address, default_val, NULL, NULL);
    module_config.data.enumd.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3346.0,3353.0,1.0,35.0,8.0,37,6,43,12,1,5,1,1,0,3,,0,4,12,6,6,void
3361,97168,addModuleNumericConfig,1,addModuleNumericConfig,"void addModuleNumericConfig (char*,char*,int,void*,long long,int,long long,long long)",config.c,"void addModuleNumericConfig(const char *module_name, const char *name, int flags, void *privdata, long long default_val, int conf_flags, long long lower, long long upper) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    long long config_dummy_address;
    standardConfig module_config = createLongLongConfig(config_name, NULL, flags | MODULE_CONFIG, lower, upper, config_dummy_address, default_val, conf_flags, NULL, NULL);
    module_config.data.numeric.config.ll = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",3355.0,3362.0,1.0,35.0,8.0,48,6,59,15,1,5,1,1,0,3,,0,4,16,8,8,void
3362,97331,configHelpCommand,1,configHelpCommand,void configHelpCommand (client*),config.c,"void configHelpCommand(client *c) {
    const char *help[] = {
""GET <pattern>"",
""    Return parameters matching the glob-like <pattern> and their values."",
""SET <directive> <value>"",
""    Set the configuration <directive> to <value>."",
""RESETSTAT"",
""    Reset statistics reported by the INFO command."",
""REWRITE"",
""    Rewrite the configuration file."",
NULL
    };

    addReplyHelp(c, help);
}",3368.0,3382.0,1.0,1.0,15.0,2,2,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
3363,97352,configResetStatCommand,1,configResetStatCommand,void configResetStatCommand (client*),config.c,"void configResetStatCommand(client *c) {
    resetServerStats();
    resetCommandTableStats(server.commands);
    resetErrorTableStats();
    addReply(c,shared.ok);
}",3388.0,3393.0,1.0,1.0,6.0,2,1,3,3,0,4,1,1,0,4,,0,0,2,1,1,void
3364,97368,configRewriteCommand,1,configRewriteCommand,void configRewriteCommand (client*),config.c,"void configRewriteCommand(client *c) {
    if (server.configfile == NULL) {
        addReplyError(c,""The server is running without a config file"");
        return;
    }
    if (rewriteConfig(server.configfile, 0) == -1) {
        /* save errno in case of being tainted. */
        int err = errno;
        serverLog(LL_WARNING,""CONFIG REWRITE failed: %s"", strerror(err));
        addReplyErrorFormat(c,""Rewriting config file: %s"", strerror(err));
    } else {
        serverLog(LL_NOTICE,""CONFIG REWRITE executed with success."");
        addReply(c,shared.ok);
    }
}",3399.0,3413.0,1.0,8.0,15.0,9,6,10,5,0,4,3,3,1,4,,0,1,2,1,1,void
3365,97491,connTypeRegister,1,connTypeRegister,int connTypeRegister (ConnectionType*),connection.c,"int connTypeRegister(ConnectionType *ct) {
    const char *typename = ct->get_type(NULL);
    ConnectionType *tmpct;
    int type;

    /* find an empty slot to store the new connection type */
    for (type = 0; type < CONN_TYPE_MAX; type++) {
        tmpct = connTypes[type];
        if (!tmpct)
            break;

        /* ignore case, we really don't care ""tls""/""TLS"" */
        if (!strcasecmp(typename, tmpct->get_type(NULL))) {
            serverLog(LL_WARNING, ""Connection types %s already registered"", typename);
            return C_ERR;
        }
    }

    serverLog(LL_VERBOSE, ""Connection type %s registered"", typename);
    connTypes[type] = ct;

    if (ct->init) {
        ct->init();
    }

    return C_OK;
}",32.0,58.0,1.0,26.0,27.0,20,8,21,7,0,7,6,7,1,5,,0,4,2,1,1,int
3366,97600,connTypeInitialize,1,connTypeInitialize,int connTypeInitialize (void),connection.c,"int connTypeInitialize(void) {
    /* currently socket connection type is necessary  */
    serverAssert(RedisRegisterConnectionTypeSocket() == C_OK);

    /* currently unix socket connection type is necessary  */
    serverAssert(RedisRegisterConnectionTypeUnix() == C_OK);

    /* may fail if without BUILD_TLS=yes */
    RedisRegisterConnectionTypeTLS();

    return C_OK;
}",60.0,71.0,1.0,4.0,12.0,10,5,0,0,0,5,1,1,0,5,,0,0,2,1,1,int
3367,97642,connectionByType,1,connectionByType,ConnectionType connectionByType (char*),connection.c,"ConnectionType *connectionByType(const char *typename) {
    ConnectionType *ct;

    for (int type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (!strcasecmp(typename, ct->get_type(NULL)))
            return ct;
    }

    serverLog(LL_WARNING, ""Missing implement of connection type %s"", typename);

    return NULL;
}",73.0,88.0,1.0,30.0,16.0,10,7,13,6,10,3,5,6,1,2,,0,2,2,1,1,ConnectionType
3368,97705,connectionTypeTcp,1,connectionTypeTcp,ConnectionType connectionTypeTcp (void),connection.c,"ConnectionType *connectionTypeTcp(void) {
    static ConnectionType *ct_tcp = NULL;

    if (ct_tcp != NULL)
        return ct_tcp;

    ct_tcp = connectionByType(CONN_TYPE_SOCKET);
    serverAssert(ct_tcp != NULL);

    return ct_tcp;
}",91.0,101.0,1.0,30.0,11.0,8,6,9,2,12,2,2,2,0,2,,0,1,2,1,1,ConnectionType
3369,97745,connectionTypeTls,1,connectionTypeTls,ConnectionType connectionTypeTls (void),connection.c,"ConnectionType *connectionTypeTls(void) {
    static ConnectionType *ct_tls = NULL;
    static int cached = 0;

    /* Unlike the TCP and Unix connections, the TLS one can be missing
     * So we need the cached pointer to handle NULL correctly too. */
    if (!cached) {
        cached = 1;
        ct_tls = connectionByType(CONN_TYPE_TLS);
    }

    return ct_tls;
}",104.0,116.0,1.0,34.0,13.0,5,2,7,3,7,1,2,2,0,1,,0,1,2,1,1,ConnectionType
3370,97773,connectionTypeUnix,1,connectionTypeUnix,ConnectionType connectionTypeUnix (void),connection.c,"ConnectionType *connectionTypeUnix(void) {
    static ConnectionType *ct_unix = NULL;

    if (ct_unix != NULL)
        return ct_unix;

    ct_unix = connectionByType(CONN_TYPE_UNIX);
    return ct_unix;
}",119.0,127.0,1.0,31.0,9.0,3,2,7,2,0,1,2,2,0,1,,0,1,2,1,1,ConnectionType
3371,97797,connectionIndexByType,1,connectionIndexByType,int connectionIndexByType (char*),connection.c,"int connectionIndexByType(const char *typename) {
    ConnectionType *ct;

    for (int type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (!strcasecmp(typename, ct->get_type(NULL)))
            return type;
    }

    return -1;
}",129.0,142.0,1.0,30.0,14.0,8,6,10,5,5,2,5,6,1,1,,0,2,2,1,1,int
3372,97842,connTypeCleanupAll,1,connTypeCleanupAll,void connTypeCleanupAll (void),connection.c,"void connTypeCleanupAll(void) {
    ConnectionType *ct;
    int type;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (ct->cleanup)
            ct->cleanup();
    }
}",144.0,156.0,1.0,26.0,13.0,7,5,8,3,0,2,5,6,0,1,,0,1,2,1,1,void
3373,97881,connTypeHasPendingData,1,connTypeHasPendingData,int connTypeHasPendingData (void),connection.c,"int connTypeHasPendingData(void) {
    ConnectionType *ct;
    int type;
    int ret = 0;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (ct && ct->has_pending_data && (ret = ct->has_pending_data())) {
            return ret;
        }
    }

    return ret;
}",159.0,172.0,1.0,26.0,14.0,10,5,12,4,1,2,3,4,1,1,,0,2,2,1,1,int
3374,97928,connTypeProcessPendingData,1,connTypeProcessPendingData,int connTypeProcessPendingData (void),connection.c,"int connTypeProcessPendingData(void) {
    ConnectionType *ct;
    int type;
    int ret = 0;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (ct && ct->process_pending_data) {
            ret += ct->process_pending_data();
        }
    }

    return ret;
}",175.0,188.0,1.0,26.0,14.0,9,6,11,4,2,2,3,4,0,1,,0,1,2,1,1,int
3375,97972,getListensInfoString,1,getListensInfoString,sds getListensInfoString (sds),connection.c,"sds getListensInfoString(sds info) {
    for (int j = 0; j < CONN_TYPE_MAX; j++) {
        connListener *listener = &server.listeners[j];
        if (listener->ct == NULL)
            continue;

        info = sdscatfmt(info, ""listener%i:name=%s"", j, listener->ct->get_type(NULL));
        for (int i = 0; i < listener->count; i++) {
            info = sdscatfmt(info, "",bind=%s"", listener->bindaddr[i]);
        }

        if (listener->port)
            info = sdscatfmt(info, "",port=%i"", listener->port);

        info = sdscatfmt(info, ""\r\n"");
    }

    return info;
}",190.0,208.0,1.0,24.0,19.0,21,7,26,6,1,11,6,8,3,5,,0,11,2,1,1,sds
3376,98100,ConnectionCallbackFunc,1,ConnectionCallbackFunc,void ConnectionCallbackFunc (connection*),connection.h,typedef void (*ConnectionCallbackFunc)(struct connection *conn);,66.0,66.0,14.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3377,98106,get_type,1,ConnectionType.get_type,char* ConnectionType.get_type (connection*),connection.h,const char *(*get_type)(struct connection *conn);,70.0,70.0,16.0,52.0,1.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,char*
3378,98111,init,1,ConnectionType.init,void ConnectionType.init (void),connection.h,void (*init)(void);,73.0,73.0,10.0,22.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3379,98116,cleanup,1,ConnectionType.cleanup,void ConnectionType.cleanup (void),connection.h,void (*cleanup)(void);,74.0,74.0,10.0,25.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3380,98121,configure,1,ConnectionType.configure,"int ConnectionType.configure (void*,int)",connection.h,"int (*configure)(void *priv, int reconfigure);",75.0,75.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3381,98127,ae_handler,1,ConnectionType.ae_handler,"void ConnectionType.ae_handler (aeEventLoop*,int,void*,int)",connection.h,"void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);",78.0,78.0,10.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
3382,98136,addr,1,ConnectionType.addr,"int ConnectionType.addr (connection*,char*,size_t,int*,int)",connection.h,"int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);",80.0,80.0,9.0,81.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,int
3383,98145,is_local,1,ConnectionType.is_local,int ConnectionType.is_local (connection*),connection.h,int (*is_local)(connection *conn);,81.0,81.0,9.0,37.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3384,98150,listen,1,ConnectionType.listen,int ConnectionType.listen (connListener*),connection.h,int (*listen)(connListener *listener);,82.0,82.0,9.0,41.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3385,98155,conn_create,1,ConnectionType.conn_create,connection* ConnectionType.conn_create (void),connection.h,connection* (*conn_create)(void);,85.0,85.0,15.0,36.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,connection*
3386,98160,conn_create_accepted,1,ConnectionType.conn_create_accepted,"connection* ConnectionType.conn_create_accepted (int,void*)",connection.h,"connection* (*conn_create_accepted)(int fd, void *priv);",86.0,86.0,15.0,59.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,connection*
3387,98166,shutdown,1,ConnectionType.shutdown,void ConnectionType.shutdown (connection*),connection.h,void (*shutdown)(struct connection *conn);,87.0,87.0,10.0,45.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3388,98171,close,1,ConnectionType.close,void ConnectionType.close (connection*),connection.h,void (*close)(struct connection *conn);,88.0,88.0,10.0,42.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3389,98176,connect,1,ConnectionType.connect,"int ConnectionType.connect (connection*,char*,int,char*,ConnectionCallbackFunc)",connection.h,"int (*connect)(struct connection *conn, const char *addr, int port, const char *source_addr, ConnectionCallbackFunc connect_handler);",91.0,91.0,9.0,136.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
3390,98185,blocking_connect,1,ConnectionType.blocking_connect,"int ConnectionType.blocking_connect (connection*,char*,int,long long)",connection.h,"int (*blocking_connect)(struct connection *conn, const char *addr, int port, long long timeout);",92.0,92.0,9.0,99.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
3391,98193,accept,1,ConnectionType.accept,"int ConnectionType.accept (connection*,ConnectionCallbackFunc)",connection.h,"int (*accept)(struct connection *conn, ConnectionCallbackFunc accept_handler);",93.0,93.0,9.0,81.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
3392,98199,write,1,ConnectionType.write,"int ConnectionType.write (connection*,void*,size_t)",connection.h,"int (*write)(struct connection *conn, const void *data, size_t data_len);",96.0,96.0,9.0,76.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
3393,98206,writev,1,ConnectionType.writev,"int ConnectionType.writev (connection*,iovec*,int)",connection.h,"int (*writev)(struct connection *conn, const struct iovec *iov, int iovcnt);",97.0,97.0,9.0,79.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
3394,98213,read,1,ConnectionType.read,"int ConnectionType.read (connection*,void*,size_t)",connection.h,"int (*read)(struct connection *conn, void *buf, size_t buf_len);",98.0,98.0,9.0,67.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
3395,98220,set_write_handler,1,ConnectionType.set_write_handler,"int ConnectionType.set_write_handler (connection*,ConnectionCallbackFunc,int)",connection.h,"int (*set_write_handler)(struct connection *conn, ConnectionCallbackFunc handler, int barrier);",99.0,99.0,9.0,98.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,int
3396,98227,set_read_handler,1,ConnectionType.set_read_handler,"int ConnectionType.set_read_handler (connection*,ConnectionCallbackFunc)",connection.h,"int (*set_read_handler)(struct connection *conn, ConnectionCallbackFunc handler);",100.0,100.0,9.0,84.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
3397,98233,get_last_error,1,ConnectionType.get_last_error,char* ConnectionType.get_last_error (connection*),connection.h,const char *(*get_last_error)(struct connection *conn);,101.0,101.0,16.0,58.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,char*
3398,98238,sync_write,1,ConnectionType.sync_write,"ssize_t ConnectionType.sync_write (connection*,char*,ssize_t,long long)",connection.h,"ssize_t (*sync_write)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",102.0,102.0,13.0,94.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ssize_t
3399,98246,sync_read,1,ConnectionType.sync_read,"ssize_t ConnectionType.sync_read (connection*,char*,ssize_t,long long)",connection.h,"ssize_t (*sync_read)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",103.0,103.0,13.0,93.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ssize_t
3400,98254,sync_readline,1,ConnectionType.sync_readline,"ssize_t ConnectionType.sync_readline (connection*,char*,ssize_t,long long)",connection.h,"ssize_t (*sync_readline)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",104.0,104.0,13.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,ssize_t
3401,98262,has_pending_data,1,ConnectionType.has_pending_data,int ConnectionType.has_pending_data (void),connection.h,int (*has_pending_data)(void);,107.0,107.0,9.0,33.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3402,98267,process_pending_data,1,ConnectionType.process_pending_data,int ConnectionType.process_pending_data (void),connection.h,int (*process_pending_data)(void);,108.0,108.0,9.0,37.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3403,98272,get_peer_cert,1,ConnectionType.get_peer_cert,sds ConnectionType.get_peer_cert (connection*),connection.h,sds (*get_peer_cert)(struct connection *conn);,111.0,111.0,9.0,49.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sds
3404,98306,connAccept,1,connAccept,"int connAccept (connection*,ConnectionCallbackFunc)",connection.h,"static inline int connAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    return conn->type->accept(conn, accept_handler);
}",159.0,161.0,1.0,1.0,3.0,2,1,3,2,1,2,1,1,0,1,,0,1,4,2,2,int
3405,98321,connConnect,1,connConnect,"int connConnect (connection*,char*,int,char*,ConnectionCallbackFunc)",connection.h,"static inline int connConnect(connection *conn, const char *addr, int port, const char *src_addr,
        ConnectionCallbackFunc connect_handler) {
    return conn->type->connect(conn, addr, port, src_addr, connect_handler);
}",172.0,175.0,1.0,1.0,4.0,2,1,6,5,2,2,1,1,0,1,,0,1,10,5,5,int
3406,98342,connBlockingConnect,1,connBlockingConnect,"int connBlockingConnect (connection*,char*,int,long long)",connection.h,"static inline int connBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {
    return conn->type->blocking_connect(conn, addr, port, timeout);
}",183.0,185.0,1.0,1.0,3.0,2,1,5,4,1,2,1,1,0,1,,0,1,8,4,4,int
3407,98361,connWrite,1,connWrite,"int connWrite (connection*,void*,size_t)",connection.h,"static inline int connWrite(connection *conn, const void *data, size_t data_len) {
    return conn->type->write(conn, data, data_len);
}",194.0,196.0,1.0,1.0,3.0,2,1,4,3,13,2,1,1,0,1,,0,1,6,3,3,int
3408,98378,connWritev,1,connWritev,"int connWritev (connection*,iovec*,int)",connection.h,"static inline int connWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    return conn->type->writev(conn, iov, iovcnt);
}",206.0,208.0,1.0,1.0,3.0,2,1,4,3,1,2,1,1,0,1,,0,1,6,3,3,int
3409,98395,connRead,1,connRead,"int connRead (connection*,void*,size_t)",connection.h,"static inline int connRead(connection *conn, void *buf, size_t buf_len) {
    int ret = conn->type->read(conn, buf, buf_len);
    return ret;
}",218.0,221.0,1.0,1.0,4.0,3,2,6,4,4,2,1,1,0,1,,0,2,6,3,3,int
3410,98416,connSetWriteHandler,1,connSetWriteHandler,"int connSetWriteHandler (connection*,ConnectionCallbackFunc)",connection.h,"static inline int connSetWriteHandler(connection *conn, ConnectionCallbackFunc func) {
    return conn->type->set_write_handler(conn, func, 0);
}",226.0,228.0,1.0,1.0,3.0,2,1,3,2,7,2,1,1,0,1,,0,1,4,2,2,int
3411,98432,connSetReadHandler,1,connSetReadHandler,"int connSetReadHandler (connection*,ConnectionCallbackFunc)",connection.h,"static inline int connSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    return conn->type->set_read_handler(conn, func);
}",233.0,235.0,1.0,1.0,3.0,2,1,3,2,12,2,1,1,0,1,,0,1,4,2,2,int
3412,98447,connSetWriteHandlerWithBarrier,1,connSetWriteHandlerWithBarrier,"int connSetWriteHandlerWithBarrier (connection*,ConnectionCallbackFunc,int)",connection.h,"static inline int connSetWriteHandlerWithBarrier(connection *conn, ConnectionCallbackFunc func, int barrier) {
    return conn->type->set_write_handler(conn, func, barrier);
}",242.0,244.0,1.0,1.0,3.0,2,1,4,3,2,2,1,1,0,1,,0,1,6,3,3,int
3413,98464,connShutdown,1,connShutdown,void connShutdown (connection*),connection.h,"static inline void connShutdown(connection *conn) {
    conn->type->shutdown(conn);
}",246.0,248.0,1.0,1.0,3.0,2,1,2,1,1,2,1,1,0,1,,0,1,2,1,1,void
3414,98476,connClose,1,connClose,void connClose (connection*),connection.h,"static inline void connClose(connection *conn) {
    conn->type->close(conn);
}",250.0,252.0,1.0,1.0,3.0,2,1,2,1,15,2,1,1,0,1,,0,1,2,1,1,void
3415,98488,connGetLastError,1,connGetLastError,const char* connGetLastError (connection*),connection.h,"static inline const char *connGetLastError(connection *conn) {
    return conn->type->get_last_error(conn);
}",257.0,259.0,1.0,1.0,3.0,2,1,2,1,19,2,1,1,0,1,,0,1,2,1,1,const char*
3416,98501,connSyncWrite,1,connSyncWrite,"ssize_t connSyncWrite (connection*,char*,ssize_t,long long)",connection.h,"static inline ssize_t connSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_write(conn, ptr, size, timeout);
}",261.0,263.0,1.0,1.0,3.0,2,1,5,4,3,2,1,1,0,1,,0,1,8,4,4,ssize_t
3417,98520,connSyncRead,1,connSyncRead,"ssize_t connSyncRead (connection*,char*,ssize_t,long long)",connection.h,"static inline ssize_t connSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_read(conn, ptr, size, timeout);
}",265.0,267.0,1.0,1.0,3.0,2,1,5,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
3418,98539,connSyncReadLine,1,connSyncReadLine,"ssize_t connSyncReadLine (connection*,char*,ssize_t,long long)",connection.h,"static inline ssize_t connSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_readline(conn, ptr, size, timeout);
}",269.0,271.0,1.0,1.0,3.0,2,1,5,4,5,2,1,1,0,1,,0,1,8,4,4,ssize_t
3419,98558,connGetType,1,connGetType,const char* connGetType (connection*),connection.h,"static inline const char *connGetType(connection *conn) {
    return conn->type->get_type(conn);
}",274.0,276.0,1.0,1.0,3.0,2,1,2,1,0,2,1,1,0,1,,0,1,2,1,1,const char*
3420,98571,connLastErrorRetryable,1,connLastErrorRetryable,int connLastErrorRetryable (connection*),connection.h,"static inline int connLastErrorRetryable(connection *conn) {
    return conn->last_errno == EINTR;
}",278.0,280.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
3421,98582,connAddr,1,connAddr,"int connAddr (connection*,char*,size_t,int*,int)",connection.h,"static inline int connAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    if (conn && conn->type->addr) {
        return conn->type->addr(conn, ip, ip_len, port, remote);
    }

    return -1;
}",284.0,290.0,1.0,1.0,7.0,6,3,8,5,3,3,2,2,1,1,,0,2,10,5,5,int
3422,98615,formatAddr,1,formatAddr,"int formatAddr (char*,size_t,char*,int)",connection.h,"static inline int formatAddr(char *buf, size_t buf_len, char *ip, int port) {
    return snprintf(buf, buf_len, strchr(ip,':') ?
           ""[%s]:%d"" : ""%s:%d"", ip, port);
}",295.0,298.0,1.0,1.0,4.0,1,1,5,4,2,0,1,1,0,0,,0,0,8,4,4,int
3423,98635,connFormatAddr,1,connFormatAddr,"int connFormatAddr (connection*,char*,size_t,int)",connection.h,"static inline int connFormatAddr(connection *conn, char *buf, size_t buf_len, int remote)
{
    char ip[CONN_ADDR_STR_LEN];
    int port;

    if (connAddr(conn, ip, sizeof(ip), &port, remote) < 0) {
        return -1;
    }

    return formatAddr(buf, buf_len, ip, port);
}",300.0,310.0,1.0,12.0,11.0,4,4,9,6,4,2,2,2,1,2,,0,1,8,4,4,int
3424,98666,connAddrPeerName,1,connAddrPeerName,"int connAddrPeerName (connection*,char*,size_t,int*)",connection.h,"static inline int connAddrPeerName(connection *conn, char *ip, size_t ip_len, int *port) {
    return connAddr(conn, ip, ip_len, port, 1);
}",312.0,314.0,1.0,1.0,3.0,0,0,4,4,6,1,1,1,0,1,,0,0,8,4,4,int
3425,98681,connAddrSockName,1,connAddrSockName,"int connAddrSockName (connection*,char*,size_t,int*)",connection.h,"static inline int connAddrSockName(connection *conn, char *ip, size_t ip_len, int *port) {
    return connAddr(conn, ip, ip_len, port, 0);
}",316.0,318.0,1.0,1.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
3426,98696,connIsLocal,1,connIsLocal,int connIsLocal (connection*),connection.h,"static inline int connIsLocal(connection *conn) {
    if (conn && conn->type->is_local) {
        return conn->type->is_local(conn);
    }

    return -1;
}",322.0,328.0,1.0,1.0,7.0,6,3,4,1,2,3,2,2,1,1,,0,2,2,1,1,int
3427,98721,connGetState,1,connGetState,int connGetState (connection*),connection.h,"static inline int connGetState(connection *conn) {
    return conn->state;
}",330.0,332.0,1.0,1.0,3.0,1,1,1,1,12,1,1,1,0,0,,0,1,2,1,1,int
3428,98730,connHasWriteHandler,1,connHasWriteHandler,int connHasWriteHandler (connection*),connection.h,"static inline int connHasWriteHandler(connection *conn) {
    return conn->write_handler != NULL;
}",335.0,337.0,1.0,1.0,3.0,2,2,2,2,4,1,1,1,0,0,,0,1,2,1,1,int
3429,98741,connHasReadHandler,1,connHasReadHandler,int connHasReadHandler (connection*),connection.h,"static inline int connHasReadHandler(connection *conn) {
    return conn->read_handler != NULL;
}",340.0,342.0,1.0,1.0,3.0,2,2,2,2,2,1,1,1,0,0,,0,1,2,1,1,int
3430,98752,connSetPrivateData,1,connSetPrivateData,"void connSetPrivateData (connection*,void*)",connection.h,"static inline void connSetPrivateData(connection *conn, void *data) {
    conn->private_data = data;
}",345.0,347.0,1.0,1.0,3.0,2,2,2,2,3,1,1,1,0,0,,0,1,4,2,2,void
3431,98763,connGetPrivateData,1,connGetPrivateData,void* connGetPrivateData (connection*),connection.h,"static inline void *connGetPrivateData(connection *conn) {
    return conn->private_data;
}",350.0,352.0,1.0,1.0,3.0,1,1,1,1,11,1,1,1,0,0,,0,1,2,1,1,void*
3432,98772,connGetInfo,1,connGetInfo,"const char* connGetInfo (connection*,char*,size_t)",connection.h,"static inline const char *connGetInfo(connection *conn, char *buf, size_t buf_len) {
    snprintf(buf, buf_len-1, ""fd=%i"", conn == NULL ? -1 : conn->fd);
    return buf;
}",359.0,362.0,1.0,1.0,4.0,5,5,6,4,3,1,1,1,0,0,,0,1,6,3,3,const char*
3433,98796,connBlock,1,connBlock,int connBlock (connection*),socket.c,"int connBlock(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetBlock(NULL, conn->fd);
}",435.0,438.0,1.0,31.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
3434,98801,connNonBlock,1,connNonBlock,int connNonBlock (connection*),socket.c,"int connNonBlock(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetNonBlock(NULL, conn->fd);
}",440.0,443.0,1.0,31.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
3435,98806,connEnableTcpNoDelay,1,connEnableTcpNoDelay,int connEnableTcpNoDelay (connection*),socket.c,"int connEnableTcpNoDelay(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetEnableTcpNoDelay(NULL, conn->fd);
}",445.0,448.0,1.0,31.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
3436,98811,connDisableTcpNoDelay,1,connDisableTcpNoDelay,int connDisableTcpNoDelay (connection*),socket.c,"int connDisableTcpNoDelay(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetDisableTcpNoDelay(NULL, conn->fd);
}",450.0,453.0,1.0,31.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3437,98816,connKeepAlive,1,connKeepAlive,"int connKeepAlive (connection*,int)",socket.c,"int connKeepAlive(connection *conn, int interval) {
    if (conn->fd == -1) return C_ERR;
    return anetKeepAlive(NULL, conn->fd, interval);
}",455.0,458.0,1.0,31.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3438,98822,connSendTimeout,1,connSendTimeout,"int connSendTimeout (connection*,long long)",socket.c,"int connSendTimeout(connection *conn, long long ms) {
    return anetSendTimeout(NULL, conn->fd, ms);
}",460.0,462.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
3439,98828,connRecvTimeout,1,connRecvTimeout,"int connRecvTimeout (connection*,long long)",socket.c,"int connRecvTimeout(connection *conn, long long ms) {
    return anetRecvTimeout(NULL, conn->fd, ms);
}",464.0,466.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
3440,98834,connGetPeerCert,1,connGetPeerCert,sds connGetPeerCert (connection*),connection.h,"static inline sds connGetPeerCert(connection *conn) {
    if (conn->type->get_peer_cert) {
        return conn->type->get_peer_cert(conn);
    }

    return NULL;
}",374.0,380.0,1.0,1.0,7.0,4,1,4,2,1,3,2,2,1,1,,0,2,2,1,1,sds
3441,98891,connCreate,1,connCreate,connection connCreate (ConnectionType*),connection.h,"static inline connection *connCreate(ConnectionType *ct) {
    return ct->conn_create();
}",404.0,406.0,1.0,1.0,3.0,1,1,1,1,3,1,1,1,0,1,,0,0,2,1,1,connection
3442,98901,connCreateAccepted,1,connCreateAccepted,"connection connCreateAccepted (ConnectionType*,int,void*)",connection.h,"static inline connection *connCreateAccepted(ConnectionType *ct, int fd, void *priv) {
    return ct->conn_create_accepted(fd, priv);
}",410.0,412.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,6,3,3,connection
3443,98915,connTypeConfigure,1,connTypeConfigure,"int connTypeConfigure (ConnectionType*,void*,int)",connection.h,"static inline int connTypeConfigure(ConnectionType *ct, void *priv, int reconfigure) {
    return ct->configure(priv, reconfigure);
}",417.0,419.0,1.0,1.0,3.0,1,1,3,3,3,1,1,1,0,1,,0,0,6,3,3,int
3444,98944,connListen,1,connListen,int connListen (connListener*),connection.h,"static inline int connListen(connListener *listener) {
    return listener->ct->listen(listener);
}",431.0,433.0,1.0,1.0,3.0,2,1,2,1,3,2,1,1,0,1,,0,1,2,1,1,int
3445,98957,connAcceptHandler,1,connAcceptHandler,aeFileProc connAcceptHandler (ConnectionType*),connection.h,"static inline aeFileProc *connAcceptHandler(ConnectionType *ct) {
    if (ct)
        return ct->accept_handler;
    return NULL;
}",436.0,440.0,1.0,1.0,5.0,1,1,3,2,1,1,2,2,0,0,,0,1,2,1,1,aeFileProc
3446,98976,RedisRegisterConnectionTypeSocket,1,RedisRegisterConnectionTypeSocket,int RedisRegisterConnectionTypeSocket (void),socket.c,"int RedisRegisterConnectionTypeSocket(void)
{
    return connTypeRegister(&CT_Socket);
}",468.0,471.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3447,98981,RedisRegisterConnectionTypeUnix,1,RedisRegisterConnectionTypeUnix,int RedisRegisterConnectionTypeUnix (void),unix.c,"int RedisRegisterConnectionTypeUnix(void)
{
    return connTypeRegister(&CT_Unix);
}",204.0,207.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3448,98986,RedisRegisterConnectionTypeTLS,1,RedisRegisterConnectionTypeTLS,int RedisRegisterConnectionTypeTLS (void),tls.c,"int RedisRegisterConnectionTypeTLS(void) {
    serverLog(LL_VERBOSE, ""Connection type %s not builtin"", CONN_TYPE_TLS);
    return C_ERR;
}",1161.0,1164.0,1.0,4.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3449,98991,connIsTLS,1,connIsTLS,int connIsTLS (connection*),connection.h,"static inline int connIsTLS(connection *conn) {
    return conn && conn->type == connectionTypeTls();
}",450.0,452.0,1.0,1.0,3.0,3,3,2,1,1,2,1,1,0,1,,0,1,2,1,1,int
3450,99011,connIncrRefs,1,connIncrRefs,void connIncrRefs (connection*),connhelpers.h,"static inline void connIncrRefs(connection *conn) {
    conn->refs++;
}",52.0,54.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
3451,99020,connDecrRefs,1,connDecrRefs,void connDecrRefs (connection*),connhelpers.h,"static inline void connDecrRefs(connection *conn) {
    conn->refs--;
}",64.0,66.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
3452,99029,connHasRefs,1,connHasRefs,int connHasRefs (connection*),connhelpers.h,"static inline int connHasRefs(connection *conn) {
    return conn->refs;
}",68.0,70.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,int
3453,99038,callHandler,1,callHandler,"int callHandler (connection*,ConnectionCallbackFunc)",connhelpers.h,"static inline int callHandler(connection *conn, ConnectionCallbackFunc handler) {
    connIncrRefs(conn);
    if (handler) handler(conn);
    connDecrRefs(conn);
    if (conn->flags & CONN_FLAG_CLOSE_SCHEDULED) {
        if (!connHasRefs(conn)) connClose(conn);
        return 0;
    }
    return 1;
}",77.0,86.0,1.0,22.0,10.0,4,4,7,2,5,5,4,5,2,4,,0,2,4,2,2,int
3454,99342,crc16,1,crc16,"uint16_t crc16 (char*,int)",crc16.c,"uint16_t crc16(const char *buf, int len) {
    int counter;
    uint16_t crc = 0;
    for (counter = 0; counter < len; counter++)
            crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
    return crc;
}",82.0,88.0,1.0,1.0,7.0,3,2,5,3,6,0,2,2,0,0,,0,0,4,2,2,uint16_t
3455,100409,crc_reflect,1,crc_reflect,"uint_fast64_t crc_reflect (uint_fast64_t,size_t)",crc64.c,"static inline uint_fast64_t crc_reflect(uint_fast64_t data, size_t data_len) {
    uint_fast64_t ret = data & 0x01;

    for (size_t i = 1; i < data_len; i++) {
        data >>= 1;
        ret = (ret << 1) | (data & 0x01);
    }

    return ret;
}",69.0,78.0,1.0,1.0,10.0,8,5,10,4,1,0,2,2,0,0,,0,0,4,2,2,uint_fast64_t
3456,100447,_crc64,1,_crc64,"uint64_t _crc64 (uint_fast64_t,void*,uint64_t)",crc64.c,"uint64_t _crc64(uint_fast64_t crc, const void *in_data, const uint64_t len) {
    const uint8_t *data = in_data;
    unsigned long long bit;

    for (uint64_t offset = 0; offset < len; offset++) {
        uint8_t c = data[offset];
        for (uint_fast8_t i = 0x01; i & 0xff; i <<= 1) {
            bit = crc & 0x8000000000000000;
            if (c & i) {
                bit = !bit;
            }

            crc <<= 1;
            if (bit) {
                crc ^= POLY;
            }
        }

        crc &= 0xffffffffffffffff;
    }

    crc = crc & 0xffffffffffffffff;
    return crc_reflect(crc, 64) ^ 0x0000000000000000;
}",88.0,111.0,1.0,23.0,24.0,15,6,23,8,0,1,5,10,0,1,,0,0,6,3,3,uint64_t
3457,100530,crc64_init,1,crc64_init,void crc64_init (void),crc64.c,"void crc64_init(void) {
    crcspeed64native_init(_crc64, crc64_table);
}",116.0,118.0,1.0,1.0,3.0,0,0,1,1,0,2,1,1,0,1,,0,1,2,1,1,void
3458,100538,crc64,1,crc64,"uint64_t crc64 (uint64_t,unsigned char*,uint64_t)",crc64.c,"uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
    return crcspeed64native(crc64_table, crc, (void *) s, l);
}",121.0,123.0,1.0,1.0,3.0,1,1,4,4,5,2,1,1,0,1,,0,1,6,3,3,uint64_t
3459,100579,crcspeed64little_init,1,crcspeed64little_init,"void crcspeed64little_init (crcfn64,uint64_t[8][256])",crcspeed.c,"void crcspeed64little_init(crcfn64 crcfn, uint64_t table[8][256]) {
    uint64_t crc;

    /* generate CRCs for all single byte sequences */
    for (int n = 0; n < 256; n++) {
        unsigned char v = n;
        table[0][n] = crcfn(0, &v, 1);
    }

    /* generate nested CRC table for future slice-by-8 lookup */
    for (int n = 0; n < 256; n++) {
        crc = table[0][n];
        for (int k = 1; k < 8; k++) {
            crc = table[0][crc & 0xff] ^ (crc >> 8);
            table[k][n] = crc;
        }
    }
}",33.0,50.0,1.0,1.0,18.0,23,7,22,5,2,0,4,5,0,0,,0,0,4,2,2,void
3460,100664,crcspeed16little_init,1,crcspeed16little_init,"void crcspeed16little_init (crcfn16,uint16_t[8][256])",crcspeed.c,"void crcspeed16little_init(crcfn16 crcfn, uint16_t table[8][256]) {
    uint16_t crc;

    /* generate CRCs for all single byte sequences */
    for (int n = 0; n < 256; n++) {
        table[0][n] = crcfn(0, &n, 1);
    }

    /* generate nested CRC table for future slice-by-8 lookup */
    for (int n = 0; n < 256; n++) {
        crc = table[0][n];
        for (int k = 1; k < 8; k++) {
            crc = table[0][(crc >> 8) & 0xff] ^ (crc << 8);
            table[k][n] = crc;
        }
    }
}",52.0,68.0,1.0,1.0,17.0,23,8,20,4,2,0,4,5,0,0,,0,0,4,2,2,void
3461,100747,rev8,1,rev8,uint64_t rev8 (uint64_t),crcspeed.c,"static inline uint64_t rev8(uint64_t a) {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(a);
#else
    uint64_t m;

    m = UINT64_C(0xff00ff00ff00ff);
    a = ((a >> 8) & m) | (a & m) << 8;
    m = UINT64_C(0xffff0000ffff);
    a = ((a >> 16) & m) | (a & m) << 16;
    return a >> 32 | a << 32;
#endif
}",71.0,83.0,1.0,1.0,13.0,17,5,14,2,6,0,1,1,0,0,,0,0,2,1,1,uint64_t
3462,100795,crcspeed64big_init,1,crcspeed64big_init,"void crcspeed64big_init (crcfn64,uint64_t[8][256])",crcspeed.c,"void crcspeed64big_init(crcfn64 fn, uint64_t big_table[8][256]) {
    /* Create the little endian table then reverse all the entries. */
    crcspeed64little_init(fn, big_table);
    for (int k = 0; k < 8; k++) {
        for (int n = 0; n < 256; n++) {
            big_table[k][n] = rev8(big_table[k][n]);
        }
    }
}",87.0,95.0,1.0,1.0,9.0,9,3,12,4,1,2,3,4,0,2,,0,1,4,2,2,void
3463,100840,crcspeed16big_init,1,crcspeed16big_init,"void crcspeed16big_init (crcfn16,uint16_t[8][256])",crcspeed.c,"void crcspeed16big_init(crcfn16 fn, uint16_t big_table[8][256]) {
    /* Create the little endian table then reverse all the entries. */
    crcspeed16little_init(fn, big_table);
    for (int k = 0; k < 8; k++) {
        for (int n = 0; n < 256; n++) {
            big_table[k][n] = rev8(big_table[k][n]);
        }
    }
}",97.0,105.0,1.0,1.0,9.0,9,3,12,4,1,2,3,4,0,2,,0,1,4,2,2,void
3464,100885,crcspeed64little,1,crcspeed64little,"uint64_t crcspeed64little (uint64_t[8][256],uint64_t,void*,size_t)",crcspeed.c,"uint64_t crcspeed64little(uint64_t little_table[8][256], uint64_t crc,
                          void *buf, size_t len) {
    unsigned char *next = buf;

    /* process individual bytes until we reach an 8-byte aligned pointer */
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = little_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    /* fast middle processing, 8 bytes (aligned!) per loop */
    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = little_table[7][crc & 0xff] ^
              little_table[6][(crc >> 8) & 0xff] ^
              little_table[5][(crc >> 16) & 0xff] ^
              little_table[4][(crc >> 24) & 0xff] ^
              little_table[3][(crc >> 32) & 0xff] ^
              little_table[2][(crc >> 40) & 0xff] ^
              little_table[1][(crc >> 48) & 0xff] ^
              little_table[0][crc >> 56];
        next += 8;
        len -= 8;
    }

    /* process remaining bytes (can't be larger than 8) */
    while ...",112.0,144.0,1.0,1.0,33.0,68,14,40,5,1,0,4,4,0,0,,0,0,8,4,4,uint64_t
3465,101045,crcspeed16little,1,crcspeed16little,"uint16_t crcspeed16little (uint16_t[8][256],uint16_t,void*,size_t)",crcspeed.c,"uint16_t crcspeed16little(uint16_t little_table[8][256], uint16_t crc,
                          void *buf, size_t len) {
    unsigned char *next = buf;

    /* process individual bytes until we reach an 8-byte aligned pointer */
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = little_table[0][((crc >> 8) ^ *next++) & 0xff] ^ (crc << 8);
        len--;
    }

    /* fast middle processing, 8 bytes (aligned!) per loop */
    while (len >= 8) {
        uint64_t n = *(uint64_t *)next;
        crc = little_table[7][(n & 0xff) ^ ((crc >> 8) & 0xff)] ^
              little_table[6][((n >> 8) & 0xff) ^ (crc & 0xff)] ^
              little_table[5][(n >> 16) & 0xff] ^
              little_table[4][(n >> 24) & 0xff] ^
              little_table[3][(n >> 32) & 0xff] ^
              little_table[2][(n >> 40) & 0xff] ^
              little_table[1][(n >> 48) & 0xff] ^
              little_table[0][n >> 56];
        next += 8;
        len -= 8;
    }

    /* process remaining bytes ...",146.0,178.0,1.0,1.0,33.0,76,15,42,6,1,0,4,4,0,0,,0,0,8,4,4,uint16_t
3466,101220,crcspeed64big,1,crcspeed64big,"uint64_t crcspeed64big (uint64_t[8][256],uint64_t,void*,size_t)",crcspeed.c,"uint64_t crcspeed64big(uint64_t big_table[8][256], uint64_t crc, void *buf,
                       size_t len) {
    unsigned char *next = buf;

    crc = rev8(crc);
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = big_table[0][(crc >> 56) ^ *next++] ^ (crc << 8);
        len--;
    }

    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = big_table[0][crc & 0xff] ^
              big_table[1][(crc >> 8) & 0xff] ^
              big_table[2][(crc >> 16) & 0xff] ^
              big_table[3][(crc >> 24) & 0xff] ^
              big_table[4][(crc >> 32) & 0xff] ^
              big_table[5][(crc >> 40) & 0xff] ^
              big_table[6][(crc >> 48) & 0xff] ^
              big_table[7][crc >> 56];
        next += 8;
        len -= 8;
    }

    while (len) {
        crc = big_table[0][(crc >> 56) ^ *next++] ^ (crc << 8);
        len--;
    }

    return rev8(crc);
}",183.0,213.0,1.0,1.0,31.0,69,15,42,5,1,2,4,4,0,2,,0,1,8,4,4,uint64_t
3467,101385,crcspeed16big,1,crcspeed16big,"uint16_t crcspeed16big (uint16_t[8][256],uint16_t,void*,size_t)",crcspeed.c,"uint16_t crcspeed16big(uint16_t big_table[8][256], uint16_t crc_in, void *buf,
                       size_t len) {
    unsigned char *next = buf;
    uint64_t crc = crc_in;

    crc = rev8(crc);
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = big_table[0][((crc >> (56 - 8)) ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    while (len >= 8) {
        uint64_t n = *(uint64_t *)next;
        crc = big_table[0][(n & 0xff) ^ ((crc >> (56 - 8)) & 0xff)] ^
              big_table[1][((n >> 8) & 0xff) ^ (crc & 0xff)] ^
              big_table[2][(n >> 16) & 0xff] ^
              big_table[3][(n >> 24) & 0xff] ^
              big_table[4][(n >> 32) & 0xff] ^
              big_table[5][(n >> 40) & 0xff] ^
              big_table[6][(n >> 48) & 0xff] ^
              big_table[7][n >> 56];
        next += 8;
        len -= 8;
    }

    while (len) {
        crc = big_table[0][((crc >> (56 - 8)) ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    return rev8(crc);
}",216.0,247.0,1.0,1.0,32.0,81,15,46,7,1,2,4,4,0,2,,0,1,8,4,4,uint16_t
3468,101575,crcspeed64native,1,crcspeed64native,"uint64_t crcspeed64native (uint64_t[8][256],uint64_t,void*,size_t)",crcspeed.c,"uint64_t crcspeed64native(uint64_t table[8][256], uint64_t crc, void *buf,
                          size_t len) {
    uint64_t n = 1;

    return *(char *)&n ? crcspeed64little(table, crc, buf, len)
                       : crcspeed64big(table, crc, buf, len);
}",253.0,259.0,1.0,1.0,7.0,5,5,10,5,1,2,1,1,0,2,,0,0,8,4,4,uint64_t
3469,101604,crcspeed16native,1,crcspeed16native,"uint16_t crcspeed16native (uint16_t[8][256],uint16_t,void*,size_t)",crcspeed.c,"uint16_t crcspeed16native(uint16_t table[8][256], uint16_t crc, void *buf,
                          size_t len) {
    uint64_t n = 1;

    return *(char *)&n ? crcspeed16little(table, crc, buf, len)
                       : crcspeed16big(table, crc, buf, len);
}",261.0,267.0,1.0,1.0,7.0,5,5,10,5,0,2,1,1,0,2,,0,0,8,4,4,uint16_t
3470,101633,crcspeed64native_init,1,crcspeed64native_init,"void crcspeed64native_init (crcfn64,uint64_t[8][256])",crcspeed.c,"void crcspeed64native_init(crcfn64 fn, uint64_t table[8][256]) {
    uint64_t n = 1;

    *(char *)&n ? crcspeed64little_init(fn, table)
                : crcspeed64big_init(fn, table);
}",270.0,275.0,1.0,1.0,6.0,5,5,6,3,1,2,1,1,0,2,,0,0,4,2,2,void
3471,101655,crcspeed16native_init,1,crcspeed16native_init,"void crcspeed16native_init (crcfn16,uint16_t[8][256])",crcspeed.c,"void crcspeed16native_init(crcfn16 fn, uint16_t table[8][256]) {
    uint64_t n = 1;

    *(char *)&n ? crcspeed16little_init(fn, table)
                : crcspeed16big_init(fn, table);
}",277.0,282.0,1.0,1.0,6.0,5,5,6,3,0,2,1,1,0,2,,0,0,4,2,2,void
3472,101686,crcfn64,1,crcfn64,"uint64_t crcfn64 (ANY,void*,const)",crcspeed.h,"typedef uint64_t (*crcfn64)(uint64_t, const void *, const uint64_t);",34.0,34.0,18.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint64_t
3473,101693,crcfn16,1,crcfn16,"uint16_t crcfn16 (ANY,void*,const)",crcspeed.h,"typedef uint16_t (*crcfn16)(uint16_t, const void *, const uint64_t);",35.0,35.0,18.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,uint16_t
3474,101805,expireIfNeeded,1,expireIfNeeded,"int expireIfNeeded (redisDb*,robj*,int)",db.c,"int expireIfNeeded(redisDb *db, robj *key, int flags) {
    if (server.lazy_expire_disabled) return 0;
    if (!keyIsExpired(db,key)) return 0;

    /* If we are running in the context of a replica, instead of
     * evicting the expired key from the database, we return ASAP:
     * the replica key expiration is controlled by the master that will
     * send us synthesized DEL operations for expired keys. The
     * exception is when write operations are performed on writable
     * replicas.
     *
     * Still we try to return the right information to the caller,
     * that is, 0 if we think the key should be still valid, 1 if
     * we think the key is expired at this time.
     *
     * When replicating commands from the master, keys are never considered
     * expired. */
    if (server.masterhost != NULL) {
        if (server.current_client && (server.current_client->flags & CLIENT_MASTER)) return 0;
        if (!(flags & EXPIRE_FORCE_DELETE_EXPIRED)) return 1;
    }

    /* ...",1775.0,1818.0,1.0,69.0,44.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,int
3475,101812,keyIsExpired,1,keyIsExpired,"int keyIsExpired (redisDb*,robj*)",db.c,"int keyIsExpired(redisDb *db, robj *key) {
    /* Don't expire anything while loading. It will be done later. */
    if (server.loading) return 0;

    mstime_t when = getExpire(db,key);
    mstime_t now;

    if (when < 0) return 0; /* No expire for this key */

    now = commandTimeSnapshot();

    /* The key expired if the current (virtual or real) time is greater
     * than the expire time of the key. */
    return now > when;
}",1730.0,1744.0,1.0,1.0,15.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,int
3476,101818,dbSetValue,1,dbSetValue,"void dbSetValue (redisDb*,robj*,robj*,int,dictEntry*)",db.c,"static void dbSetValue(redisDb *db, robj *key, robj *val, int overwrite, dictEntry *de) {
    if (!de) de = dictFind(db->dict,key->ptr);
    serverAssertWithInfo(NULL,key,de != NULL);
    robj *old = dictGetVal(de);

    val->lru = old->lru;

    if (overwrite) {
        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we
         * need to incr to retain old */
        incrRefCount(old);
        /* Although the key is not really deleted from the database, we regard
         * overwrite as two steps of unlink+add, so we still need to call the unlink
         * callback of the module. */
        moduleNotifyKeyUnlink(key,old,db->id,DB_FLAG_KEY_OVERWRITE);
        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */
        signalDeletedKeyAsReady(db,key,old->type);
        decrRefCount(old);
        /* Because of RM_StringDMA, old may be changed, so we need get old again */
        old = dictGetVal(de);
    }
    dictSetVal(db-...",245.0,274.0,1.0,4.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
3477,101827,updateLFU,1,updateLFU,void updateLFU (robj*),db.c,"void updateLFU(robj *val) {
    unsigned long counter = LFUDecrAndReturn(val);
    counter = LFULogIncr(counter);
    val->lru = (LFUGetTimeInMinutes()<<8) | counter;
}",55.0,59.0,1.0,1.0,5.0,6,4,6,2,1,3,1,1,0,3,,0,3,2,1,1,void
3478,101850,lookupKey,1,lookupKey,"robj lookupKey (redisDb*,robj*,int)",db.c,"robj *lookupKey(redisDb *db, robj *key, int flags) {
    dictEntry *de = dictFind(db->dict,key->ptr);
    robj *val = NULL;
    if (de) {
        val = dictGetVal(de);
        /* Forcing deletion of expired keys on a replica makes the replica
         * inconsistent with the master. We forbid it on readonly replicas, but
         * we have to allow it on writable replicas to make write commands
         * behave consistently.
         *
         * It's possible that the WRITE flag is set even during a readonly
         * command, since the command may trigger events that cause modules to
         * perform additional writes. */
        int is_ro_replica = server.masterhost && server.repl_slave_ro;
        int expire_flags = 0;
        if (flags & LOOKUP_WRITE && !is_ro_replica)
            expire_flags |= EXPIRE_FORCE_DELETE_EXPIRED;
        if (flags & LOOKUP_NOEXPIRE)
            expire_flags |= EXPIRE_AVOID_DELETE_EXPIRED;
        if (expireIfNeeded(db, key, expire_flags)) {
    ...",88.0,140.0,1.0,20.0,53.0,44,10,34,10,2,6,10,18,2,5,,0,5,6,3,3,robj
3479,102073,lookupKeyReadWithFlags,1,lookupKeyReadWithFlags,"robj lookupKeyReadWithFlags (redisDb*,robj*,int)",db.c,"robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
    serverAssert(!(flags & LOOKUP_WRITE));
    return lookupKey(db, key, flags);
}",151.0,154.0,1.0,4.0,4.0,7,7,4,3,8,2,1,1,0,2,,0,0,6,3,3,robj
3480,102104,lookupKeyRead,1,lookupKeyRead,"robj lookupKeyRead (redisDb*,robj*)",db.c,"robj *lookupKeyRead(redisDb *db, robj *key) {
    return lookupKeyReadWithFlags(db,key,LOOKUP_NONE);
}",158.0,160.0,1.0,41.0,3.0,0,0,2,2,17,1,1,1,0,1,,0,0,4,2,2,robj
3481,102117,lookupKeyWriteWithFlags,1,lookupKeyWriteWithFlags,"robj lookupKeyWriteWithFlags (redisDb*,robj*,int)",db.c,"robj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags) {
    return lookupKey(db, key, flags | LOOKUP_WRITE);
}",168.0,170.0,1.0,38.0,3.0,2,2,3,3,2,1,1,1,0,1,,0,0,6,3,3,robj
3482,102135,lookupKeyWrite,1,lookupKeyWrite,"robj lookupKeyWrite (redisDb*,robj*)",db.c,"robj *lookupKeyWrite(redisDb *db, robj *key) {
    return lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);
}",172.0,174.0,1.0,44.0,3.0,0,0,2,2,22,1,1,1,0,1,,0,0,4,2,2,robj
3483,102148,lookupKeyReadOrReply,1,lookupKeyReadOrReply,"robj lookupKeyReadOrReply (client*,robj*,robj*)",db.c,"robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
    robj *o = lookupKeyRead(c->db, key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",176.0,180.0,1.0,1.0,5.0,3,3,7,4,9,3,2,2,0,2,,0,2,6,3,3,robj
3484,102172,lookupKeyWriteOrReply,1,lookupKeyWriteOrReply,"robj lookupKeyWriteOrReply (client*,robj*,robj*)",db.c,"robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
    robj *o = lookupKeyWrite(c->db, key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",182.0,186.0,1.0,1.0,5.0,3,3,7,4,4,3,2,2,0,2,,0,2,6,3,3,robj
3485,102196,dbAddInternal,1,dbAddInternal,"void dbAddInternal (redisDb*,robj*,robj*,int)",db.c,"static void dbAddInternal(redisDb *db, robj *key, robj *val, int update_if_existing) {
    dictEntry *existing;
    dictEntry *de = dictAddRaw(db->dict, key->ptr, &existing);
    if (update_if_existing && existing) {
        dbSetValue(db, key, val, 1, existing);
        return;
    }
    serverAssertWithInfo(NULL, key, de != NULL);
    dictSetKey(db->dict, de, sdsdup(key->ptr));
    initObjectLRUOrLFU(val);
    dictSetVal(db->dict, de, val);
    signalKeyAsReady(db, key, val->type);
    if (server.cluster_enabled) slotToKeyAddEntry(de, db);
    notifyKeyspaceEvent(NOTIFY_NEW,""new"",key,db->id);
}",193.0,207.0,1.0,4.0,15.0,17,11,31,8,1,14,3,3,0,10,,0,6,8,4,4,void
3486,102291,dbAdd,1,dbAdd,"void dbAdd (redisDb*,robj*,robj*)",db.c,"void dbAdd(redisDb *db, robj *key, robj *val) {
    dbAddInternal(db, key, val, 0);
}",209.0,211.0,1.0,1.0,3.0,0,0,3,3,13,1,1,1,0,1,,0,0,6,3,3,void
3487,102303,dbAddRDBLoad,1,dbAddRDBLoad,"int dbAddRDBLoad (redisDb*,sds,robj*)",db.c,"int dbAddRDBLoad(redisDb *db, sds key, robj *val) {
    dictEntry *de = dictAddRaw(db->dict, key, NULL);
    if (de == NULL) return 0;
    initObjectLRUOrLFU(val);
    dictSetVal(db->dict, de, val);
    if (server.cluster_enabled) slotToKeyAddEntry(de, db);
    return 1;
}",224.0,231.0,1.0,1.0,8.0,5,4,13,6,0,6,3,3,0,4,,0,3,6,3,3,int
3488,102457,dbReplaceValue,1,dbReplaceValue,"void dbReplaceValue (redisDb*,robj*,robj*)",db.c,"void dbReplaceValue(redisDb *db, robj *key, robj *val) {
    dbSetValue(db, key, val, 0, NULL);
}",278.0,280.0,1.0,1.0,3.0,0,0,4,4,1,1,1,1,0,1,,0,0,6,3,3,void
3489,102470,setKey,1,setKey,"void setKey (client*,redisDb*,robj*,robj*,int)",db.c,"void setKey(client *c, redisDb *db, robj *key, robj *val, int flags) {
    int keyfound = 0;

    if (flags & SETKEY_ALREADY_EXIST)
        keyfound = 1;
    else if (flags & SETKEY_ADD_OR_UPDATE)
        keyfound = -1;
    else if (!(flags & SETKEY_DOESNT_EXIST))
        keyfound = (lookupKeyWrite(db,key) != NULL);

    if (!keyfound) {
        dbAdd(db,key,val);
    } else if (keyfound<0) {
        dbAddInternal(db,key,val,1);
    } else {
        dbSetValue(db,key,val,1,NULL);
    }
    incrRefCount(val);
    if (!(flags & SETKEY_KEEPTTL)) removeExpire(db,key);
    if (!(flags & SETKEY_NO_SIGNAL)) signalModifiedKey(c,db,key);
}",295.0,315.0,1.0,16.0,21.0,8,3,15,6,8,4,5,5,0,4,,0,0,10,5,5,void
3490,102576,dbRandomKey,1,dbRandomKey,robj dbRandomKey (redisDb*),db.c,"robj *dbRandomKey(redisDb *db) {
    dictEntry *de;
    int maxtries = 100;
    int allvolatile = dictSize(db->dict) == dictSize(db->expires);

    while(1) {
        sds key;
        robj *keyobj;

        de = dictGetFairRandomKey(db->dict);
        if (de == NULL) return NULL;

        key = dictGetKey(de);
        keyobj = createStringObject(key,sdslen(key));
        if (dictFind(db->expires,key)) {
            if (allvolatile && server.masterhost && --maxtries == 0) {
                /* If the DB is composed only of keys with an expire set,
                 * it could happen that all the keys are already logically
                 * expired in the slave, so the function cannot stop because
                 * expireIfNeeded() is false, nor it can stop because
                 * dictGetFairRandomKey() returns NULL (there are keys to return).
                 * To prevent the infinite loop we do some tries, but if there
                 * are the conditions for an infinite loop, e...",321.0,354.0,1.0,22.0,34.0,30,8,28,8,2,15,7,12,3,7,,0,14,2,1,1,robj
3491,102690,dbGenericDelete,1,dbGenericDelete,"int dbGenericDelete (redisDb*,robj*,int,int)",db.c,"int dbGenericDelete(redisDb *db, robj *key, int async, int flags) {
    dictEntry **plink;
    int table;
    dictEntry *de = dictTwoPhaseUnlinkFind(db->dict,key->ptr,&plink,&table);
    if (de) {
        robj *val = dictGetVal(de);
        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we
         * need to incr to retain val */
        incrRefCount(val);
        /* Tells the module that the key has been unlinked from the database. */
        moduleNotifyKeyUnlink(key,val,db->id,flags);
        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */
        signalDeletedKeyAsReady(db,key,val->type);
        /* We should call decr before freeObjAsync. If not, the refcount may be
         * greater than 1, so freeObjAsync doesn't work */
        decrRefCount(val);
        if (async) {
            /* Because of dbUnshareStringValue, the val in de may change. */
            freeObjAsync(key, dictGetVal(de), db->id);
            di...",357.0,388.0,1.0,12.0,32.0,23,7,36,10,6,21,5,8,3,12,,0,12,8,4,4,int
3492,102807,dbSyncDelete,1,dbSyncDelete,"int dbSyncDelete (redisDb*,robj*)",db.c,"int dbSyncDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, 0, DB_FLAG_KEY_DELETED);
}",391.0,393.0,1.0,39.0,3.0,1,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
3493,102823,dbAsyncDelete,1,dbAsyncDelete,"int dbAsyncDelete (redisDb*,robj*)",db.c,"int dbAsyncDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, 1, DB_FLAG_KEY_DELETED);
}",397.0,399.0,1.0,39.0,3.0,1,1,2,2,2,1,1,1,0,1,,0,0,4,2,2,int
3494,102839,dbDelete,1,dbDelete,"int dbDelete (redisDb*,robj*)",db.c,"int dbDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, server.lazyfree_lazy_server_del, DB_FLAG_KEY_DELETED);
}",403.0,405.0,1.0,69.0,3.0,2,2,3,3,11,1,1,1,0,1,,0,0,4,2,2,int
3495,102857,dbUnshareStringValue,1,dbUnshareStringValue,"robj dbUnshareStringValue (redisDb*,robj*,robj*)",db.c,"robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
    serverAssert(o->type == OBJ_STRING);
    if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
        robj *decoded = getDecodedObject(o);
        o = createRawStringObject(decoded->ptr, sdslen(decoded->ptr));
        decrRefCount(decoded);
        dbReplaceValue(db,key,o);
    }
    return o;
}",434.0,443.0,1.0,4.0,10.0,15,9,13,4,2,6,2,2,0,6,,0,3,6,3,3,robj
3496,102920,emptyDbStructure,1,emptyDbStructure,"long long emptyDbStructure (redisDb*,int,int,void)",db.c,"long long emptyDbStructure(redisDb *dbarray, int dbnum, int async,
                           void(callback)(dict*))
{
    long long removed = 0;
    int startdb, enddb;

    if (dbnum == -1) {
        startdb = 0;
        enddb = server.dbnum-1;
    } else {
        startdb = enddb = dbnum;
    }

    for (int j = startdb; j <= enddb; j++) {
        removed += dictSize(dbarray[j].dict);
        if (async) {
            emptyDbAsync(&dbarray[j]);
        } else {
            dictEmpty(dbarray[j].dict,callback);
            dictEmpty(dbarray[j].expires,callback);
        }
        /* Because all keys of database are removed, reset average ttl. */
        dbarray[j].avg_ttl = 0;
        dbarray[j].expires_cursor = 0;
    }

    return removed;
}",451.0,478.0,1.0,19.0,28.0,29,11,24,8,2,1,4,5,0,1,,0,0,8,4,4,long long
3497,103037,emptyData,1,emptyData,"long long emptyData (int,int,void)",db.c,"long long emptyData(int dbnum, int flags, void(callback)(dict*)) {
    int async = (flags & EMPTYDB_ASYNC);
    int with_functions = !(flags & EMPTYDB_NOFUNCTIONS);
    RedisModuleFlushInfoV1 fi = {REDISMODULE_FLUSHINFO_VERSION,!async,dbnum};
    long long removed = 0;

    if (dbnum < -1 || dbnum >= server.dbnum) {
        errno = EINVAL;
        return -1;
    }

    /* Fire the flushdb modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_FLUSHDB,
                          REDISMODULE_SUBEVENT_FLUSHDB_START,
                          &fi);

    /* Make sure the WATCHed keys are affected by the FLUSH* commands.
     * Note that we need to call the function while the keys are still
     * there. */
    signalFlushedDb(dbnum, async);

    /* Empty redis database structure. */
    removed = emptyDbStructure(server.db, dbnum, async, callback);

    /* Flush slots to keys map if enable cluster, we can flush entire
     * slots to keys map whatever dbnum because only support one...",495.0,538.0,1.0,25.0,44.0,32,16,29,10,4,8,5,5,0,8,,0,1,6,3,3,long long
3498,103167,initTempDb,1,initTempDb,redisDb initTempDb (void),db.c,"redisDb *initTempDb(void) {
    redisDb *tempDb = zcalloc(sizeof(redisDb)*server.dbnum);
    for (int i=0; i<server.dbnum; i++) {
        tempDb[i].dict = dictCreate(&dbDictType);
        tempDb[i].expires = dictCreate(&dbExpiresDictType);
        tempDb[i].slots_to_keys = NULL;
    }

    if (server.cluster_enabled) {
        /* Prepare temp slot to key map to be written during async diskless replication. */
        slotToKeyInit(tempDb);
    }

    return tempDb;
}",541.0,555.0,1.0,1.0,15.0,19,7,18,7,1,4,3,3,0,4,,0,3,2,1,1,redisDb
3499,103230,discardTempDb,1,discardTempDb,"void discardTempDb (redisDb*,void)",db.c,"void discardTempDb(redisDb *tempDb, void(callback)(dict*)) {
    int async = 1;

    /* Release temp DBs. */
    emptyDbStructure(tempDb, -1, async, callback);
    for (int i=0; i<server.dbnum; i++) {
        dictRelease(tempDb[i].dict);
        dictRelease(tempDb[i].expires);
    }

    if (server.cluster_enabled) {
        /* Release temp slot to key map. */
        slotToKeyDestroy(tempDb);
    }

    zfree(tempDb);
}",558.0,574.0,1.0,1.0,17.0,10,5,14,5,1,5,3,3,0,5,,0,0,4,2,2,void
3500,103281,selectDb,1,selectDb,"int selectDb (client*,int)",db.c,"int selectDb(client *c, int id) {
    if (id < 0 || id >= server.dbnum)
        return C_ERR;
    c->db = &server.db[id];
    return C_OK;
}",576.0,581.0,1.0,15.0,6.0,10,9,6,3,13,1,2,2,0,0,,0,1,4,2,2,int
3501,103317,dbTotalServerKeyCount,1,dbTotalServerKeyCount,long long dbTotalServerKeyCount (void),db.c,"long long dbTotalServerKeyCount(void) {
    long long total = 0;
    int j;
    for (j = 0; j < server.dbnum; j++) {
        total += dictSize(server.db[j].dict);
    }
    return total;
}",583.0,590.0,1.0,17.0,8.0,19,7,12,3,1,0,2,2,0,0,,0,0,2,1,1,long long
3502,103376,signalModifiedKey,1,signalModifiedKey,"void signalModifiedKey (client*,redisDb*,robj*)",db.c,"void signalModifiedKey(client *c, redisDb *db, robj *key) {
    touchWatchedKey(db,key);
    trackingInvalidateKey(c,key,1);
}",603.0,606.0,1.0,1.0,4.0,0,0,4,3,28,2,1,1,0,2,,0,0,6,3,3,void
3503,103390,signalFlushedDb,1,signalFlushedDb,"void signalFlushedDb (int,int)",db.c,"void signalFlushedDb(int dbid, int async) {
    int startdb, enddb;
    if (dbid == -1) {
        startdb = 0;
        enddb = server.dbnum-1;
    } else {
        startdb = enddb = dbid;
    }

    for (int j = startdb; j <= enddb; j++) {
        scanDatabaseForDeletedKeys(&server.db[j], NULL);
        touchAllWatchedKeysInDb(&server.db[j], NULL);
    }

    trackingInvalidateKeysOnFlush(async);

    /* Changes in this method may take place in swapMainDbWithTempDb as well,
     * where we execute similar calls, but with subtle differences as it's
     * not simply flushing db. */
}",608.0,627.0,1.0,1.0,20.0,14,8,15,7,1,3,3,3,0,3,,0,0,4,2,2,void
3504,103451,getFlushCommandFlags,1,getFlushCommandFlags,"int getFlushCommandFlags (client*,int*)",db.c,"int getFlushCommandFlags(client *c, int *flags) {
    /* Parse the optional ASYNC option. */
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""sync"")) {
        *flags = EMPTYDB_NO_FLAGS;
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""async"")) {
        *flags = EMPTYDB_ASYNC;
    } else if (c->argc == 1) {
        *flags = server.lazyfree_lazy_user_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return C_ERR;
    }
    return C_OK;
}",642.0,655.0,1.0,17.0,14.0,9,7,3,2,2,2,2,2,2,0,,0,2,4,2,2,int
3505,103549,flushAllDataAndResetRDB,1,flushAllDataAndResetRDB,void flushAllDataAndResetRDB (int),db.c,"void flushAllDataAndResetRDB(int flags) {
    server.dirty += emptyData(-1,flags,NULL);
    if (server.child_type == CHILD_TYPE_RDB) killRDBChild();
    if (server.saveparamslen > 0) {
        rdbSaveInfo rsi, *rsiptr;
        rsiptr = rdbPopulateSaveInfo(&rsi);
        rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr,RDBFLAGS_NONE);
    }

#if defined(USE_JEMALLOC)
    /* jemalloc 5 doesn't release pages back to the OS when there's no traffic.
     * for large databases, flushdb blocks for long anyway, so a bit more won't
     * harm and this way the flush and purge will be synchronous. */
    if (!(flags & EMPTYDB_ASYNC))
        jemalloc_purge();
#endif
}",658.0,674.0,1.0,29.0,17.0,10,7,9,5,2,4,3,3,0,4,,0,1,2,1,1,void
3506,103598,flushdbCommand,1,flushdbCommand,void flushdbCommand (client*),db.c,"void flushdbCommand(client *c) {
    int flags;

    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
    /* flushdb should not flush the functions */
    server.dirty += emptyData(c->db->id,flags | EMPTYDB_NOFUNCTIONS,NULL);

    /* Without the forceCommandPropagation, when DB was already empty,
     * FLUSHDB will not be replicated nor put into the AOF. */
    forceCommandPropagation(c, PROPAGATE_REPL | PROPAGATE_AOF);

    addReply(c,shared.ok);

#if defined(USE_JEMALLOC)
    /* jemalloc 5 doesn't release pages back to the OS when there's no traffic.
     * for large databases, flushdb blocks for long anyway, so a bit more won't
     * harm and this way the flush and purge will be synchronous. */
    if (!(flags & EMPTYDB_ASYNC))
        jemalloc_purge();
#endif
}",679.0,699.0,1.0,42.0,21.0,11,8,9,5,0,5,2,2,1,4,,0,2,2,1,1,void
3507,103648,flushallCommand,1,flushallCommand,void flushallCommand (client*),db.c,"void flushallCommand(client *c) {
    int flags;
    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
    /* flushall should not flush the functions */
    flushAllDataAndResetRDB(flags | EMPTYDB_NOFUNCTIONS);

    /* Without the forceCommandPropagation, when DBs were already empty,
     * FLUSHALL will not be replicated nor put into the AOF. */
    forceCommandPropagation(c, PROPAGATE_REPL | PROPAGATE_AOF);

    addReply(c,shared.ok);
}",704.0,715.0,1.0,42.0,12.0,7,6,6,3,0,4,2,2,1,4,,0,1,2,1,1,void
3508,103688,delGenericCommand,1,delGenericCommand,"void delGenericCommand (client*,int)",db.c,"void delGenericCommand(client *c, int lazy) {
    int numdel = 0, j;

    for (j = 1; j < c->argc; j++) {
        expireIfNeeded(c->db,c->argv[j],0);
        int deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :
                              dbSyncDelete(c->db,c->argv[j]);
        if (deleted) {
            signalModifiedKey(c,c->db,c->argv[j]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,
                ""del"",c->argv[j],c->db->id);
            server.dirty++;
            numdel++;
        }
    }
    addReplyLongLong(c,numdel);
}",718.0,734.0,1.0,32.0,17.0,26,8,27,6,2,17,3,4,1,6,,0,13,4,2,2,void
3509,103784,delCommand,1,delCommand,void delCommand (client*),db.c,"void delCommand(client *c) {
    delGenericCommand(c,server.lazyfree_lazy_user_del);
}",736.0,738.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
3510,103794,unlinkCommand,1,unlinkCommand,void unlinkCommand (client*),db.c,"void unlinkCommand(client *c) {
    delGenericCommand(c,1);
}",740.0,742.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3511,103802,existsCommand,1,existsCommand,void existsCommand (client*),db.c,"void existsCommand(client *c) {
    long long count = 0;
    int j;

    for (j = 1; j < c->argc; j++) {
        if (lookupKeyReadWithFlags(c->db,c->argv[j],LOOKUP_NOTOUCH)) count++;
    }
    addReplyLongLong(c,count);
}",746.0,754.0,1.0,52.0,9.0,9,6,10,3,0,5,3,4,4,2,,0,4,2,1,1,void
3512,103846,selectCommand,1,selectCommand,void selectCommand (client*),db.c,"void selectCommand(client *c) {
    int id;

    if (getIntFromObjectOrReply(c, c->argv[1], &id, NULL) != C_OK)
        return;

    if (server.cluster_enabled && id != 0) {
        addReplyError(c,""SELECT is not allowed in cluster mode"");
        return;
    }
    if (selectDb(c,id) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
    } else {
        addReply(c,shared.ok);
    }
}",756.0,771.0,1.0,61.0,16.0,9,8,10,4,0,5,4,4,3,4,,0,3,2,1,1,void
3513,103902,randomkeyCommand,1,randomkeyCommand,void randomkeyCommand (client*),db.c,"void randomkeyCommand(client *c) {
    robj *key;

    if ((key = dbRandomKey(c->db)) == NULL) {
        addReplyNull(c);
        return;
    }

    addReplyBulk(c,key);
    decrRefCount(key);
}",773.0,783.0,1.0,1.0,11.0,3,3,7,3,0,5,2,2,2,4,,0,2,2,1,1,void
3514,103926,keysCommand,1,keysCommand,void keysCommand (client*),db.c,"void keysCommand(client *c) {
    dictIterator *di;
    dictEntry *de;
    sds pattern = c->argv[1]->ptr;
    int plen = sdslen(pattern), allkeys;
    unsigned long numkeys = 0;
    void *replylen = addReplyDeferredLen(c);

    di = dictGetSafeIterator(c->db->dict);
    allkeys = (pattern[0] == '*' && plen == 1);
    robj keyobj;
    while((de = dictNext(di)) != NULL) {
        sds key = dictGetKey(de);

        if (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),0)) {
            initStaticStringObject(keyobj, key);
            if (!keyIsExpired(c->db, &keyobj)) {
                addReplyBulkCBuffer(c, key, sdslen(key));
                numkeys++;
            }
        }
        if (c->flags & CLIENT_CLOSE_ASAP)
            break;
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c,replylen,numkeys);
}",785.0,811.0,1.0,12.0,27.0,35,14,41,12,0,16,6,9,6,12,,0,13,2,1,1,void
3515,104072,objectTypeCompare,1,objectTypeCompare,"int objectTypeCompare (robj*,long long)",db.c,"int objectTypeCompare(robj *o, long long target) {
    if (o->type != OBJ_MODULE) {
        if (o->type != target) 
            return 0;
        else 
            return 1;
    }
    /* module type compare */
    long long mt = (long long)REDISMODULE_TYPE_SIGN(((moduleValue *)o->ptr)->type->id);
    if (target != -mt)
        return 0;
    else 
        return 1;
}",823.0,836.0,1.0,19.0,14.0,17,10,7,3,1,0,4,5,0,0,,0,0,4,2,2,int
3516,104138,scanCallback,1,scanCallback,"void scanCallback (void*,dictEntry*)",db.c,"void scanCallback(void *privdata, const dictEntry *de) {
    scanData *data = (scanData *)privdata;
    list *keys = data->keys;
    robj *o = data->o;
    sds val = NULL;
    sds key = NULL;
    data->sampled++;

    /* o and typename can not have values at the same time. */
    serverAssert(!((data->type != LLONG_MAX) && o));

    /* Filter an element if it isn't the type we want. */
    /* TODO: uncomment in redis 8.0
    if (!o && data->type != LLONG_MAX) {
        robj *rval = dictGetVal(de);
        if (!objectTypeCompare(rval, data->type)) return;
    }*/

    /* Filter element if it does not match the pattern. */
    sds keysds = dictGetKey(de);
    if (data->pattern) {
        if (!stringmatchlen(data->pattern, sdslen(data->pattern), keysds, sdslen(keysds), 0)) {
            return;
        }
    }

    if (o == NULL) {
        key = keysds;
    } else if (o->type == OBJ_SET) {
        key = keysds;
    } else if (o->type == OBJ_HASH) {
        key = keysds;
        val = d...",839.0,883.0,1.0,4.0,45.0,25,11,30,10,0,14,5,6,6,7,,0,11,4,2,2,void
3517,104314,parseScanCursorOrReply,1,parseScanCursorOrReply,"int parseScanCursorOrReply (client*,robj*,long unsigned*)",db.c,"int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
    char *eptr;

    /* Use strtoul() because we need an *unsigned* long, so
     * getLongLongFromObject() does not cover the whole cursor space. */
    errno = 0;
    *cursor = strtoul(o->ptr, &eptr, 10);
    if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
    {
        addReplyError(c, ""invalid cursor"");
        return C_ERR;
    }
    return C_OK;
}",889.0,902.0,1.0,15.0,14.0,14,10,9,6,1,1,2,2,0,1,,0,0,6,3,3,int
3518,104378,getObjectTypeByName,1,getObjectTypeByName,long long getObjectTypeByName (char*),db.c,"long long getObjectTypeByName(char *name) {

    for (long long i = 0; i < OBJ_TYPE_MAX; i++) {
        if (obj_type_name[i] && !strcasecmp(name, obj_type_name[i])) {
            return i;
        }
    }

    moduleType *mt = moduleTypeLookupModuleByNameIgnoreCase(name);
    if (mt != NULL) return -(REDISMODULE_TYPE_SIGN(mt->id));

    return LLONG_MAX;
}",915.0,927.0,1.0,30.0,13.0,16,13,15,6,0,3,4,5,2,1,,0,3,2,1,1,long long
3519,104443,getObjectTypeName,1,getObjectTypeName,char* getObjectTypeName (robj*),db.c,"char *getObjectTypeName(robj *o) {
    if (o == NULL) {
        return ""none"";
    }

    serverAssert(o->type >= 0 && o->type < OBJ_TYPE_MAX);

    if (o->type == OBJ_MODULE) {
        moduleValue *mv = o->ptr;
        return mv->type->name;
    } else {
        return obj_type_name[o->type];
    }
}",929.0,942.0,1.0,4.0,14.0,16,10,8,3,1,2,3,3,0,1,,0,1,2,1,1,char*
3520,104508,scanGenericCommand,1,scanGenericCommand,"void scanGenericCommand (client*,robj*,long unsigned)",db.c,"void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
    int i, j;
    listNode *node;
    long count = 10;
    sds pat = NULL;
    sds typename = NULL;
    long long type = LLONG_MAX;
    int patlen = 0, use_pattern = 0;
    dict *ht;

    /* Object must be NULL (to iterate keys names), or the type of the object
     * must be Set, Sorted Set, or Hash. */
    serverAssert(o == NULL || o->type == OBJ_SET || o->type == OBJ_HASH ||
                o->type == OBJ_ZSET);

    /* Set i to the first option argument. The previous one is the cursor. */
    i = (o == NULL) ? 2 : 3; /* Skip the key argument if needed. */

    /* Step 1: Parse options. */
    while (i < c->argc) {
        j = c->argc - i;
        if (!strcasecmp(c->argv[i]->ptr, ""count"") && j >= 2) {
            if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
                != C_OK)
            {
                return;
            }

            if (count < 1) {
                addReplyErrorObject(...",955.0,1159.0,1.0,4.0,205.0,107,24,121,28,1,32,16,29,11,19,,0,21,6,3,3,void
3521,105271,scanCommand,1,scanCommand,void scanCommand (client*),db.c,"void scanCommand(client *c) {
    unsigned long cursor;
    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
    scanGenericCommand(c,NULL,cursor);
}",1162.0,1166.0,1.0,56.0,5.0,5,5,6,3,0,3,2,2,2,2,,0,2,2,1,1,void
3522,105298,dbsizeCommand,1,dbsizeCommand,void dbsizeCommand (client*),db.c,"void dbsizeCommand(client *c) {
    addReplyLongLong(c,dictSize(c->db->dict));
}",1168.0,1170.0,1.0,23.0,3.0,11,3,4,1,0,4,1,1,0,1,,0,3,2,1,1,void
3523,105331,lastsaveCommand,1,lastsaveCommand,void lastsaveCommand (client*),db.c,"void lastsaveCommand(client *c) {
    addReplyLongLong(c,server.lastsave);
}",1172.0,1174.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
3524,105341,typeCommand,1,typeCommand,void typeCommand (client*),db.c,"void typeCommand(client *c) {
    robj *o;
    o = lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH);
    addReplyStatus(c, getObjectTypeName(o));
}",1176.0,1180.0,1.0,48.0,5.0,5,4,5,2,0,5,1,1,0,3,,0,4,2,1,1,void
3525,105367,shutdownCommand,1,shutdownCommand,void shutdownCommand (client*),db.c,"void shutdownCommand(client *c) {
    int flags = SHUTDOWN_NOFLAGS;
    int abort = 0;
    for (int i = 1; i < c->argc; i++) {
        if (!strcasecmp(c->argv[i]->ptr,""nosave"")) {
            flags |= SHUTDOWN_NOSAVE;
        } else if (!strcasecmp(c->argv[i]->ptr,""save"")) {
            flags |= SHUTDOWN_SAVE;
        } else if (!strcasecmp(c->argv[i]->ptr, ""now"")) {
            flags |= SHUTDOWN_NOW;
        } else if (!strcasecmp(c->argv[i]->ptr, ""force"")) {
            flags |= SHUTDOWN_FORCE;
        } else if (!strcasecmp(c->argv[i]->ptr, ""abort"")) {
            abort = 1;
        } else {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        }
    }
    if ((abort && flags != SHUTDOWN_NOFLAGS) ||
        (flags & SHUTDOWN_NOSAVE && flags & SHUTDOWN_SAVE))
    {
        /* Illegal combo. */
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    if (abort) {
        if (abortShutdown() == C_OK)
            addReply(c, shared.ok);
 ...",1182.0,1241.0,1.0,16.0,60.0,32,12,27,6,0,11,10,13,6,8,,0,6,2,1,1,void
3526,105632,renameGenericCommand,1,renameGenericCommand,"void renameGenericCommand (client*,int)",db.c,"void renameGenericCommand(client *c, int nx) {
    robj *o;
    long long expire;
    int samekey = 0;

    /* When source and dest key is the same, no operation is performed,
     * if the key exists, however we still return an error on unexisting key. */
    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
        return;

    if (samekey) {
        addReply(c,nx ? shared.czero : shared.ok);
        return;
    }

    incrRefCount(o);
    expire = getExpire(c->db,c->argv[1]);
    if (lookupKeyWrite(c->db,c->argv[2]) != NULL) {
        if (nx) {
            decrRefCount(o);
            addReply(c,shared.czero);
            return;
        }
        /* Overwrite: delete the old key before creating the new one
         * with the same name. */
        dbDelete(c->db,c->argv[2]);
    }
    dbAdd(c->db,c->argv[2],o);
    if (expire != -1) setExpire(c,c->db,c->argv[2],expire);
    dbDelete(c->db,c-...",1243.0,1283.0,1.0,24.0,41.0,61,10,52,8,2,40,7,8,8,17,,0,27,4,2,2,void
3527,105847,renameCommand,1,renameCommand,void renameCommand (client*),db.c,"void renameCommand(client *c) {
    renameGenericCommand(c,0);
}",1285.0,1287.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3528,105855,renamenxCommand,1,renamenxCommand,void renamenxCommand (client*),db.c,"void renamenxCommand(client *c) {
    renameGenericCommand(c,1);
}",1289.0,1291.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3529,105863,moveCommand,1,moveCommand,void moveCommand (client*),db.c,"void moveCommand(client *c) {
    robj *o;
    redisDb *src, *dst;
    int srcid, dbid;
    long long expire;

    if (server.cluster_enabled) {
        addReplyError(c,""MOVE is not allowed in cluster mode"");
        return;
    }

    /* Obtain source and target DB pointers */
    src = c->db;
    srcid = c->db->id;

    if (getIntFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK)
        return;

    if (selectDb(c,dbid) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
        return;
    }
    dst = c->db;
    selectDb(c,srcid); /* Back to the source DB */

    /* If the user is moving using as target the same
     * DB as the source DB it is probably an error. */
    if (src == dst) {
        addReplyErrorObject(c,shared.sameobjecterr);
        return;
    }

    /* Check if the element exists and get a reference */
    o = lookupKeyWrite(c->db,c->argv[1]);
    if (!o) {
        addReply(c,shared.czero);
        return;
    }
    expire = getExpire(c->db,c->a...",1293.0,1353.0,1.0,63.0,61.0,53,11,59,10,0,38,8,8,5,20,,0,23,2,1,1,void
3530,106081,copyCommand,1,copyCommand,void copyCommand (client*),db.c,"void copyCommand(client *c) {
    robj *o;
    redisDb *src, *dst;
    int srcid, dbid;
    long long expire;
    int j, replace = 0, delete = 0;

    /* Obtain source and target DB pointers 
     * Default target DB is the same as the source DB 
     * Parse the REPLACE option and targetDB option. */
    src = c->db;
    dst = c->db;
    srcid = c->db->id;
    dbid = c->db->id;
    for (j = 3; j < c->argc; j++) {
        int additional = c->argc - j - 1;
        if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr, ""db"") && additional >= 1) {
            if (getIntFromObjectOrReply(c, c->argv[j+1], &dbid, NULL) != C_OK)
                return;

            if (selectDb(c, dbid) == C_ERR) {
                addReplyError(c,""DB index is out of range"");
                return;
            }
            dst = c->db;
            selectDb(c,srcid); /* Back to the source DB */
            j++; /* Consume additional arg. */
  ...",1355.0,1455.0,1.0,73.0,101.0,71,14,87,17,0,36,19,15,4,21,,0,26,2,1,1,void
3531,106471,scanDatabaseForReadyKeys,1,scanDatabaseForReadyKeys,void scanDatabaseForReadyKeys (redisDb*),db.c,"void scanDatabaseForReadyKeys(redisDb *db) {
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(db->blocking_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        dictEntry *kde = dictFind(db->dict,key->ptr);
        if (kde) {
            robj *value = dictGetVal(kde);
            signalKeyAsReady(db, key, value->type);
        }
    }
    dictReleaseIterator(di);
}",1461.0,1473.0,1.0,1.0,13.0,10,3,17,7,3,9,3,4,1,7,,0,7,2,1,1,void
3532,106523,scanDatabaseForDeletedKeys,1,scanDatabaseForDeletedKeys,"void scanDatabaseForDeletedKeys (redisDb*,redisDb*)",db.c,"void scanDatabaseForDeletedKeys(redisDb *emptied, redisDb *replaced_with) {
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(emptied->blocking_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        int existed = 0, exists = 0;
        int original_type = -1, curr_type = -1;

        dictEntry *kde = dictFind(emptied->dict, key->ptr);
        if (kde) {
            robj *value = dictGetVal(kde);
            original_type = value->type;
            existed = 1;
        }

        if (replaced_with) {
            dictEntry *kde = dictFind(replaced_with->dict, key->ptr);
            if (kde) {
                robj *value = dictGetVal(kde);
                curr_type = value->type;
                exists = 1;
            }
        }
        /* We want to try to unblock any client using a blocking XREADGROUP */
        if ((existed && !exists) || original_type != curr_type)
            signalDeletedKeyAsReady(emptied, key, original_type);
 ...",1478.0,1506.0,1.0,1.0,29.0,29,7,38,12,4,12,6,11,1,9,,0,10,4,2,2,void
3533,106639,dbSwapDatabases,1,dbSwapDatabases,"int dbSwapDatabases (int,int)",db.c,"int dbSwapDatabases(int id1, int id2) {
    if (id1 < 0 || id1 >= server.dbnum ||
        id2 < 0 || id2 >= server.dbnum) return C_ERR;
    if (id1 == id2) return C_OK;
    redisDb aux = server.db[id1];
    redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];

    /* Swapdb should make transaction fail if there is any
     * client watching keys */
    touchAllWatchedKeysInDb(db1, db2);
    touchAllWatchedKeysInDb(db2, db1);

    /* Try to unblock any XREADGROUP clients if the key no longer exists. */
    scanDatabaseForDeletedKeys(db1, db2);
    scanDatabaseForDeletedKeys(db2, db1);

    /* Swap hash tables. Note that we don't swap blocking_keys,
     * ready_keys and watched_keys, since we want clients to
     * remain in the same DB they were. */
    db1->dict = db2->dict;
    db1->expires = db2->expires;
    db1->avg_ttl = db2->avg_ttl;
    db1->expires_cursor = db2->expires_cursor;

    db2->dict = aux.dict;
    db2->expires = aux.expires;
    db2->avg_ttl = aux.avg_ttl;
   ...",1516.0,1557.0,1.0,47.0,42.0,46,10,43,6,1,22,3,3,0,6,,0,16,4,2,2,int
3534,106782,swapMainDbWithTempDb,1,swapMainDbWithTempDb,void swapMainDbWithTempDb (redisDb*),db.c,"void swapMainDbWithTempDb(redisDb *tempDb) {
    if (server.cluster_enabled) {
        /* Swap slots_to_keys from tempdb just loaded with main db slots_to_keys. */
        clusterSlotToKeyMapping *aux = server.db->slots_to_keys;
        server.db->slots_to_keys = tempDb->slots_to_keys;
        tempDb->slots_to_keys = aux;
    }

    for (int i=0; i<server.dbnum; i++) {
        redisDb aux = server.db[i];
        redisDb *activedb = &server.db[i], *newdb = &tempDb[i];

        /* Swapping databases should make transaction fail if there is any
         * client watching keys. */
        touchAllWatchedKeysInDb(activedb, newdb);

        /* Try to unblock any XREADGROUP clients if the key no longer exists. */
        scanDatabaseForDeletedKeys(activedb, newdb);

        /* Swap hash tables. Note that we don't swap blocking_keys,
         * ready_keys and watched_keys, since clients 
         * remain in the same DB they were. */
        activedb->dict = newdb->dict;
        activedb->e...",1562.0,1608.0,1.0,1.0,47.0,47,6,40,6,1,23,3,3,0,5,,0,18,2,1,1,void
3535,106919,swapdbCommand,1,swapdbCommand,void swapdbCommand (client*),db.c,"void swapdbCommand(client *c) {
    int id1, id2;

    /* Not allowed in cluster mode: we have just DB 0 there. */
    if (server.cluster_enabled) {
        addReplyError(c,""SWAPDB is not allowed in cluster mode"");
        return;
    }

    /* Get the two DBs indexes. */
    if (getIntFromObjectOrReply(c, c->argv[1], &id1,
        ""invalid first DB index"") != C_OK)
        return;

    if (getIntFromObjectOrReply(c, c->argv[2], &id2,
        ""invalid second DB index"") != C_OK)
        return;

    /* Swap... */
    if (dbSwapDatabases(id1,id2) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
        return;
    } else {
        RedisModuleSwapDbInfo si = {REDISMODULE_SWAPDBINFO_VERSION,id1,id2};
        moduleFireServerEvent(REDISMODULE_EVENT_SWAPDB,0,&si);
        server.dirty++;
        addReply(c,shared.ok);
    }
}",1611.0,1639.0,1.0,37.0,29.0,11,7,11,4,0,7,5,5,5,5,,0,5,2,1,1,void
3536,107010,removeExpire,1,removeExpire,"int removeExpire (redisDb*,robj*)",db.c,"int removeExpire(redisDb *db, robj *key) {
    return dictDelete(db->expires,key->ptr) == DICT_OK;
}",1645.0,1647.0,1.0,47.0,3.0,3,2,2,2,2,2,1,1,0,1,,0,1,4,2,2,int
3537,107028,setExpire,1,setExpire,"void setExpire (client*,redisDb*,robj*,long long)",db.c,"void setExpire(client *c, redisDb *db, robj *key, long long when) {
    dictEntry *kde, *de;

    /* Reuse the sds from the main dict in the expire dict */
    kde = dictFind(db->dict,key->ptr);
    serverAssertWithInfo(NULL,key,kde != NULL);
    de = dictAddOrFind(db->expires,dictGetKey(kde));
    dictSetSignedIntegerVal(de,when);

    int writable_slave = server.masterhost && server.repl_slave_ro == 0;
    if (c && writable_slave && !(c->flags & CLIENT_MASTER))
        rememberSlaveKeyWithExpire(db,key);
}",1653.0,1665.0,1.0,4.0,13.0,21,13,22,9,7,9,2,2,1,6,,0,6,8,4,4,void
3538,107109,getExpire,1,getExpire,"long long getExpire (redisDb*,robj*)",db.c,"long long getExpire(redisDb *db, robj *key) {
    dictEntry *de;

    /* No expire? return ASAP */
    if (dictSize(db->expires) == 0 ||
       (de = dictFind(db->expires,key->ptr)) == NULL) return -1;

    return dictGetSignedIntegerVal(de);
}",1669.0,1677.0,1.0,8.0,9.0,15,7,8,4,11,6,2,2,5,2,,0,5,4,2,2,long long
3539,107158,deleteExpiredKeyAndPropagate,1,deleteExpiredKeyAndPropagate,"void deleteExpiredKeyAndPropagate (redisDb*,robj*)",db.c,"void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) {
    mstime_t expire_latency;
    latencyStartMonitor(expire_latency);
    dbGenericDelete(db,keyobj,server.lazyfree_lazy_expire,DB_FLAG_KEY_EXPIRED);
    latencyEndMonitor(expire_latency);
    latencyAddSampleIfNeeded(""expire-del"",expire_latency);
    notifyKeyspaceEvent(NOTIFY_EXPIRED,""expired"",keyobj,db->id);
    signalModifiedKey(NULL, db, keyobj);
    propagateDeletion(db,keyobj,server.lazyfree_lazy_expire);
    server.stat_expiredkeys++;
}",1680.0,1690.0,1.0,4.0,11.0,17,8,25,5,1,8,1,1,0,7,,0,3,4,2,2,void
3540,107248,propagateDeletion,1,propagateDeletion,"void propagateDeletion (redisDb*,robj*,int)",db.c,"void propagateDeletion(redisDb *db, robj *key, int lazy) {
    robj *argv[2];

    argv[0] = lazy ? shared.unlink : shared.del;
    argv[1] = key;
    incrRefCount(argv[0]);
    incrRefCount(argv[1]);

    /* If the master decided to expire a key we must propagate it to replicas no matter what..
     * Even if module executed a command without asking for propagation. */
    int prev_replication_allowed = server.replication_allowed;
    server.replication_allowed = 1;
    alsoPropagate(db->id,argv,2,PROPAGATE_AOF|PROPAGATE_REPL);
    server.replication_allowed = prev_replication_allowed;

    decrRefCount(argv[0]);
    decrRefCount(argv[1]);
}",1710.0,1727.0,1.0,32.0,18.0,19,6,17,7,2,6,1,1,0,5,,0,1,6,3,3,void
3541,107464,getKeysPrepareResult,1,getKeysPrepareResult,"keyReference getKeysPrepareResult (getKeysResult*,int)",db.c,"keyReference *getKeysPrepareResult(getKeysResult *result, int numkeys) {
    /* GETKEYS_RESULT_INIT initializes keys to NULL, point it to the pre-allocated stack
     * buffer here. */
    if (!result->keys) {
        serverAssert(!result->numkeys);
        result->keys = result->keysbuf;
    }

    /* Resize if necessary */
    if (numkeys > result->size) {
        if (result->keys != result->keysbuf) {
            /* We're not using a static buffer, just (re)alloc */
            result->keys = zrealloc(result->keys, numkeys * sizeof(keyReference));
        } else {
            /* We are using a static buffer, copy its contents */
            result->keys = zmalloc(numkeys * sizeof(keyReference));
            if (result->numkeys)
                memcpy(result->keys, result->keysbuf, result->numkeys * sizeof(keyReference));
        }
        result->size = numkeys;
    }

    return result->keys;
}",1830.0,1853.0,1.0,8.0,24.0,26,11,16,3,15,14,4,5,4,2,,0,13,4,2,2,keyReference
3542,107570,getAllKeySpecsFlags,1,getAllKeySpecsFlags,"int64_t getAllKeySpecsFlags (redisCommand*,int)",db.c,"int64_t getAllKeySpecsFlags(struct redisCommand *cmd, int inv) {
    int64_t flags = 0;
    for (int j = 0; j < cmd->key_specs_num; j++) {
        keySpec *spec = cmd->key_specs + j;
        flags |= inv? ~spec->flags : spec->flags;
    }
    return flags;
}",1857.0,1864.0,1.0,1.0,8.0,11,6,12,5,3,4,2,2,1,0,,0,4,4,2,2,int64_t
3543,107615,getKeysUsingKeySpecs,1,getKeysUsingKeySpecs,"int getKeysUsingKeySpecs (redisCommand*,robj**,int,int,getKeysResult*)",db.c,"int getKeysUsingKeySpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result) {
    int j, i, last, first, step;
    keyReference *keys;
    serverAssert(result->numkeys == 0); /* caller should initialize or reset it */

    for (j = 0; j < cmd->key_specs_num; j++) {
        keySpec *spec = cmd->key_specs + j;
        serverAssert(spec->begin_search_type != KSPEC_BS_INVALID);
        /* Skip specs that represent 'fake' keys */
        if ((spec->flags & CMD_KEY_NOT_KEY) && !(search_flags & GET_KEYSPEC_INCLUDE_NOT_KEYS)) {
            continue;
        }

        first = 0;
        if (spec->begin_search_type == KSPEC_BS_INDEX) {
            first = spec->bs.index.pos;
        } else if (spec->begin_search_type == KSPEC_BS_KEYWORD) {
            int start_index = spec->bs.keyword.startfrom > 0 ? spec->bs.keyword.startfrom : argc+spec->bs.keyword.startfrom;
            int end_index = spec->bs.keyword.startfrom > 0 ? argc-1: 1;
            for (i =...",1873.0,1986.0,1.0,4.0,114.0,86,21,57,15,1,20,18,26,7,3,,0,18,10,5,5,int
3544,108178,getKeysFromCommandWithSpecs,1,getKeysFromCommandWithSpecs,"int getKeysFromCommandWithSpecs (redisCommand*,robj**,int,int,getKeysResult*)",db.c,"int getKeysFromCommandWithSpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result) {
    /* The command has at least one key-spec not marked as NOT_KEY */
    int has_keyspec = (getAllKeySpecsFlags(cmd, 1) & CMD_KEY_NOT_KEY);
    /* The command has at least one key-spec marked as VARIABLE_FLAGS */
    int has_varflags = (getAllKeySpecsFlags(cmd, 0) & CMD_KEY_VARIABLE_FLAGS);

    /* We prefer key-specs if there are any, and their flags are reliable. */
    if (has_keyspec && !has_varflags) {
        int ret = getKeysUsingKeySpecs(cmd,argv,argc,search_flags,result);
        if (ret >= 0)
            return ret;
        /* If the specs returned with an error (probably an INVALID or INCOMPLETE spec),
         * fallback to the callback method. */
    }

    /* Resort to getkeys callback methods. */
    if (cmd->flags & CMD_MODULE_GETKEYS)
        return moduleGetCommandKeysViaAPI(cmd,argv,argc,result);

    /* We use native getkeys as a last resor...",2000.0,2024.0,1.0,53.0,25.0,15,7,25,8,2,7,5,6,2,4,,0,6,10,5,5,int
3545,108266,doesCommandHaveKeys,1,doesCommandHaveKeys,int doesCommandHaveKeys (redisCommand*),db.c,"int doesCommandHaveKeys(struct redisCommand *cmd) {
    return cmd->getkeys_proc ||                                 /* has getkeys_proc (non modules) */
        (cmd->flags & CMD_MODULE_GETKEYS) ||                    /* module with GETKEYS */
        (getAllKeySpecsFlags(cmd, 1) & CMD_KEY_NOT_KEY);        /* has at least one key-spec not marked as NOT_KEY */
}",2027.0,2031.0,1.0,22.0,5.0,8,4,3,1,2,3,1,1,0,1,,0,2,2,1,1,int
3546,108398,doesCommandHaveChannelsWithFlags,1,doesCommandHaveChannelsWithFlags,"int doesCommandHaveChannelsWithFlags (redisCommand*,int)",db.c,"int doesCommandHaveChannelsWithFlags(struct redisCommand *cmd, int flags) {
    /* If a module declares get channels, we are just going to assume
     * has channels. This API is allowed to return false positives. */
    if (cmd->flags & CMD_MODULE_GETCHANNELS) {
        return 1;
    }
    for (ChannelSpecs *spec = commands_with_channels; spec->proc != NULL; spec += 1) {
        if (cmd->proc == spec->proc) {
            return !!(spec->flags & flags);
        }
    }
    return 0;
}",2057.0,2069.0,1.0,21.0,13.0,13,7,9,5,1,3,4,5,2,0,,0,3,4,2,2,int
3547,108451,getChannelsFromCommand,1,getChannelsFromCommand,"int getChannelsFromCommand (redisCommand*,robj**,int,getKeysResult*)",db.c,"int getChannelsFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    /* If a module declares get channels, use that. */
    if (cmd->flags & CMD_MODULE_GETCHANNELS) {
        return moduleGetCommandChannelsViaAPI(cmd, argv, argc, result);
    }
    /* Otherwise check the channel spec table */
    for (ChannelSpecs *spec = commands_with_channels; spec != NULL; spec += 1) {
        if (cmd->proc == spec->proc) {
            int start = spec->start;
            int stop = (spec->count == -1) ? argc : start + spec->count;
            if (stop > argc) stop = argc;
            int count = 0;
            keys = getKeysPrepareResult(result, stop - start);
            for (int i = start; i < stop; i++ ) {
                keys[count].pos = i;
                keys[count++].flags = spec->flags;
            }
            result->numkeys = count;
            return count;
        }
    }
    return 0;
}",2084.0,2107.0,1.0,21.0,24.0,34,15,40,12,1,6,6,11,2,2,,0,5,8,4,4,int
3548,108578,getKeysUsingLegacyRangeSpec,1,getKeysUsingLegacyRangeSpec,"int getKeysUsingLegacyRangeSpec (redisCommand*,robj**,int,getKeysResult*)",db.c,"int getKeysUsingLegacyRangeSpec(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int j, i = 0, last, first, step;
    keyReference *keys;
    UNUSED(argv);

    if (cmd->legacy_range_key_spec.begin_search_type == KSPEC_BS_INVALID) {
        result->numkeys = 0;
        return 0;
    }

    first = cmd->legacy_range_key_spec.bs.index.pos;
    last = cmd->legacy_range_key_spec.fk.range.lastkey;
    if (last >= 0)
        last += first;
    step = cmd->legacy_range_key_spec.fk.range.keystep;

    if (last < 0) last = argc+last;

    int count = ((last - first)+1);
    keys = getKeysPrepareResult(result, count);

    for (j = first; j <= last; j += step) {
        if (j >= argc || j < first) {
            /* Modules commands, and standard commands with a not fixed number
             * of arguments (negative arity parameter) do not have dispatch
             * time arity checks, so we need to handle the case where the user
             * passed an invalid nu...",2119.0,2161.0,1.0,4.0,43.0,53,16,44,12,0,10,7,10,3,1,,0,10,8,4,4,int
3549,108758,getKeysFromCommand,1,getKeysFromCommand,"int getKeysFromCommand (redisCommand*,robj**,int,getKeysResult*)",db.c,"int getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    if (cmd->flags & CMD_MODULE_GETKEYS) {
        return moduleGetCommandKeysViaAPI(cmd,argv,argc,result);
    } else if (cmd->getkeys_proc) {
        return cmd->getkeys_proc(cmd,argv,argc,result);
    } else {
        return getKeysUsingLegacyRangeSpec(cmd,argv,argc,result);
    }
}",2174.0,2182.0,1.0,21.0,9.0,3,3,5,4,2,2,2,2,1,1,,0,1,8,4,4,int
3550,108807,getKeysFreeResult,1,getKeysFreeResult,void getKeysFreeResult (getKeysResult*),db.c,"void getKeysFreeResult(getKeysResult *result) {
    if (result && result->keys != result->keysbuf)
        zfree(result->keys);
}",2185.0,2188.0,1.0,1.0,4.0,5,3,4,1,7,4,2,2,2,1,,0,3,2,1,1,void
3551,108827,genericGetKeys,1,genericGetKeys,"int genericGetKeys (int,int,int,int,robj**,int,getKeysResult*)",db.c,"int genericGetKeys(int storeKeyOfs, int keyCountOfs, int firstKeyOfs, int keyStep,
                    robj **argv, int argc, getKeysResult *result) {
    int i, num;
    keyReference *keys;

    num = atoi(argv[keyCountOfs]->ptr);
    /* Sanity check. Don't return any key if the command is going to
     * reply with syntax error. (no input keys). */
    if (num < 1 || num > (argc - firstKeyOfs)/keyStep) {
        result->numkeys = 0;
        return 0;
    }

    int numkeys = storeKeyOfs ? num + 1 : num;
    keys = getKeysPrepareResult(result, numkeys);
    result->numkeys = numkeys;

    /* Add all key positions for argv[firstKeyOfs...n] to keys[] */
    for (i = 0; i < num; i++) {
        keys[i].pos = firstKeyOfs+(i*keyStep);
        keys[i].flags = 0;
    } 

    if (storeKeyOfs) {
        keys[num].pos = storeKeyOfs;
        keys[num].flags = 0;
    } 
    return result->numkeys;
}",2203.0,2231.0,1.0,1.0,29.0,33,12,35,11,9,4,4,4,0,1,,0,4,14,7,7,int
3552,108938,sintercardGetKeys,1,sintercardGetKeys,"int sintercardGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int sintercardGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2233.0,2236.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3553,108961,zunionInterDiffStoreGetKeys,1,zunionInterDiffStoreGetKeys,"int zunionInterDiffStoreGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int zunionInterDiffStoreGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(1, 2, 3, 1, argv, argc, result);
}",2238.0,2241.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3554,108984,zunionInterDiffGetKeys,1,zunionInterDiffGetKeys,"int zunionInterDiffGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int zunionInterDiffGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2243.0,2246.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3555,109007,evalGetKeys,1,evalGetKeys,"int evalGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2248.0,2251.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3556,109030,functionGetKeys,1,functionGetKeys,"int functionGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int functionGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2253.0,2256.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3557,109053,lmpopGetKeys,1,lmpopGetKeys,"int lmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int lmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2258.0,2261.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3558,109076,blmpopGetKeys,1,blmpopGetKeys,"int blmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int blmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2263.0,2266.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3559,109099,zmpopGetKeys,1,zmpopGetKeys,"int zmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int zmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",2268.0,2271.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3560,109122,bzmpopGetKeys,1,bzmpopGetKeys,"int bzmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int bzmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",2273.0,2276.0,1.0,4.0,4.0,1,1,5,4,0,1,1,1,0,1,,0,0,8,4,4,int
3561,109145,sortROGetKeys,1,sortROGetKeys,"int sortROGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    UNUSED(cmd);
    UNUSED(argv);
    UNUSED(argc);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* <sort-key> is always present. */
    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;
    return 1;
}",2288.0,2298.0,1.0,4.0,11.0,13,6,10,5,0,1,1,1,0,1,,0,1,8,4,4,int
3562,109203,sortGetKeys,1,sortGetKeys,"int sortGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, j, num, found_store = 0;
    keyReference *keys;
    UNUSED(cmd);

    num = 0;
    keys = getKeysPrepareResult(result, 2); /* Alloc 2 places for the worst case. */
    keys[num].pos = 1; /* <sort-key> is always present. */
    keys[num++].flags = CMD_KEY_RO | CMD_KEY_ACCESS;

    /* Search for STORE option. By default we consider options to don't
     * have arguments, so if we find an unknown option name we scan the
     * next. However there are options with 1 or 2 arguments, so we
     * provide a list here in order to skip the right number of args. */
    struct {
        char *name;
        int skip;
    } skiplist[] = {
        {""limit"", 2},
        {""get"", 1},
        {""by"", 1},
        {NULL, 0} /* End of elements. */
    };

    for (i = 2; i < argc; i++) {
        for (j = 0; skiplist[j].name != NULL; j++) {
            if (!strcasecmp(argv[i]->ptr,skiplist[j].name)) {
   ...",2309.0,2351.0,1.0,4.0,43.0,38,14,30,11,0,3,5,7,0,1,,0,3,8,4,4,int
3563,109381,migrateGetKeys,1,migrateGetKeys,"int migrateGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, j, num, first;
    keyReference *keys;
    UNUSED(cmd);

    /* Assume the obvious form. */
    first = 3;
    num = 1;

    /* But check for the extended one with the KEYS option. */
    struct {
        char* name;
        int skip;
    } skip_keywords[] = {       
        {""copy"", 0},
        {""replace"", 0},
        {""auth"", 1},
        {""auth2"", 2},
        {NULL, 0}
    };
    if (argc > 6) {
        for (i = 6; i < argc; i++) {
            if (!strcasecmp(argv[i]->ptr, ""keys"")) {
                if (sdslen(argv[3]->ptr) > 0) {
                    /* This is a syntax error. So ignore the keys and leave
                     * the syntax error to be handled by migrateCommand. */
                    num = 0; 
                } else {
                    first = i + 1;
                    num = argc - first;
                }
                break;
            }
            for (...",2354.0,2403.0,1.0,4.0,50.0,49,14,40,11,0,3,10,19,1,2,,0,3,8,4,4,int
3564,109569,georadiusGetKeys,1,georadiusGetKeys,"int georadiusGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, num;
    keyReference *keys;
    UNUSED(cmd);

    /* Check for the presence of the stored key in the command */
    int stored_key = -1;
    for (i = 5; i < argc; i++) {
        char *arg = argv[i]->ptr;
        /* For the case when user specifies both ""store"" and ""storedist"" options, the
         * second key specified would override the first key. This behavior is kept
         * the same as in georadiusCommand method.
         */
        if ((!strcasecmp(arg, ""store"") || !strcasecmp(arg, ""storedist"")) && ((i+1) < argc)) {
            stored_key = i+1;
            i++;
        }
    }
    num = 1 + (stored_key == -1 ? 0 : 1);

    /* Keys in the command come from two places:
     * argv[1] = key,
     * argv[5...n] = stored key if present
     */
    keys = getKeysPrepareResult(result, num);

    /* Add all key positions to keys[] */
    keys[0].pos = 1;
    keys[0].flags = 0...",2411.0,2446.0,1.0,4.0,36.0,38,15,30,9,0,2,4,5,0,1,,0,2,8,4,4,int
3565,109690,xreadGetKeys,1,xreadGetKeys,"int xreadGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, num = 0;
    keyReference *keys;
    UNUSED(cmd);

    /* We need to parse the options of the command in order to seek the first
     * ""STREAMS"" string which is actually the option. This is needed because
     * ""STREAMS"" could also be the name of the consumer group and even the
     * name of the stream key. */
    int streams_pos = -1;
    for (i = 1; i < argc; i++) {
        char *arg = argv[i]->ptr;
        if (!strcasecmp(arg, ""block"")) {
            i++; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""count"")) {
            i++; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""group"")) {
            i += 2; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""noack"")) {
            /* Nothing to do. */
        } else if (!strcasecmp(arg, ""streams"")) {
            streams_pos = i;
            break;
        } else {
            brea...",2452.0,2496.0,1.0,4.0,45.0,43,16,39,9,0,3,6,7,0,1,,0,3,8,4,4,int
3566,109874,setGetKeys,1,setGetKeys,"int setGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int setGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    UNUSED(cmd);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* We always know the position */
    result->numkeys = 1;

    for (int i = 3; i < argc; i++) {
        char *arg = argv[i]->ptr;
        if ((arg[0] == 'g' || arg[0] == 'G') &&
            (arg[1] == 'e' || arg[1] == 'E') &&
            (arg[2] == 't' || arg[2] == 'T') && arg[3] == '\0')
        {
            keys[0].flags = CMD_KEY_RW | CMD_KEY_ACCESS | CMD_KEY_UPDATE;
            return 1;
        }
    }

    keys[0].flags = CMD_KEY_OW | CMD_KEY_UPDATE;
    return 1;
}",2500.0,2521.0,1.0,4.0,22.0,46,11,21,7,0,2,3,4,0,1,,0,2,8,4,4,int
3567,110013,bitfieldGetKeys,1,bitfieldGetKeys,"int bitfieldGetKeys (redisCommand*,robj**,int,getKeysResult*)",db.c,"int bitfieldGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    int readonly = 1;
    UNUSED(cmd);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* We always know the position */
    result->numkeys = 1;

    for (int i = 2; i < argc; i++) {
        int remargs = argc - i - 1; /* Remaining args other than current. */
        char *arg = argv[i]->ptr;
        if (!strcasecmp(arg, ""get"") && remargs >= 2) {
            i += 2;
        } else if ((!strcasecmp(arg, ""set"") || !strcasecmp(arg, ""incrby"")) && remargs >= 3) {
            readonly = 0;
            i += 3;
            break;
        } else if (!strcasecmp(arg, ""overflow"") && remargs >= 1) {
            i += 1;
        } else {
            readonly = 0; /* Syntax error. safer to assume non-RO. */
            break;
        }
    }

    if (readonly) {
        keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;
    } else {
        keys[0].flags = CMD_KEY_RW |...",2525.0,2557.0,1.0,4.0,33.0,26,13,21,9,0,2,4,5,0,1,,0,2,8,4,4,int
3568,110231,bugReportStart,1,bugReportStart,void bugReportStart (void),debug.c,"void bugReportStart(void) {
    pthread_mutex_lock(&bug_report_start_mutex);
    if (bug_report_start == 0) {
        serverLogRaw(LL_WARNING|LL_RAW,
        ""\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n"");
        bug_report_start = 1;
    }
    pthread_mutex_unlock(&bug_report_start_mutex);
}",1166.0,1174.0,1.0,21.0,9.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
3569,110236,printCrashReport,1,printCrashReport,void printCrashReport (void),debug.c,"void printCrashReport(void) {
    /* Log INFO and CLIENT LIST */
    logServerInfo();

    /* Log the current client */
    logCurrentClient(server.current_client, ""CURRENT"");
    logCurrentClient(server.executing_client, ""EXECUTING"");

    /* Log modules info. Something we wanna do last since we fear it may crash. */
    logModulesInfo();

    /* Log debug config information, which are some values
     * which may be useful for debugging crashes. */
    logConfigDebugInfo();

    /* Run memory test in case the crash was triggered by memory corruption. */
    doFastMemoryTest();
}",2174.0,2191.0,1.0,1.0,18.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
3570,110241,bugReportEnd,1,bugReportEnd,"void bugReportEnd (int,int)",debug.c,"void bugReportEnd(int killViaSignal, int sig) {
    struct sigaction act;

    serverLogRaw(LL_WARNING|LL_RAW,
""\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n""
""       Please report the crash by opening an issue on github:\n\n""
""           http://github.com/redis/redis/issues\n\n""
""  If a Redis module was involved, please open in the module's repo instead.\n\n""
""  Suspect RAM error? Use redis-server --test-memory to verify it.\n\n""
""  Some other issues could be detected by redis-server --check-system\n""
);

    /* free(messages); Don't call free() with possibly corrupted memory. */
    if (server.daemonize && server.supervised == 0 && server.pidfile) unlink(server.pidfile);

    if (!killViaSignal) {
        /* To avoid issues with valgrind, we may wanna exit rahter than generate a signal */
        if (server.use_exit_on_panic) {
             /* Using _exit to bypass false leak reports by gcc ASAN */
             fflush(stdout);
            _exit(1);
  ...",2193.0,2225.0,1.0,17.0,33.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
3571,110247,logStackTrace,1,logStackTrace,"void logStackTrace (void*,int)",debug.c,"void logStackTrace(void *eip, int uplevel);",74.0,74.0,6.0,42.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3572,110253,xorDigest,1,xorDigest,"void xorDigest (unsigned char*,void*,size_t)",debug.c,"void xorDigest(unsigned char *digest, const void *ptr, size_t len) {
    SHA1_CTX ctx;
    unsigned char hash[20];
    int j;

    SHA1Init(&ctx);
    SHA1Update(&ctx,ptr,len);
    SHA1Final(hash,&ctx);

    for (j = 0; j < 20; j++)
        digest[j] ^= hash[j];
}",84.0,95.0,1.0,1.0,12.0,5,3,8,5,5,3,2,2,0,3,,0,0,6,3,3,void
3573,110292,xorStringObjectDigest,1,xorStringObjectDigest,"void xorStringObjectDigest (unsigned char*,robj*)",debug.c,"void xorStringObjectDigest(unsigned char *digest, robj *o) {
    o = getDecodedObject(o);
    xorDigest(digest,o->ptr,sdslen(o->ptr));
    decrRefCount(o);
}",97.0,101.0,1.0,1.0,5.0,3,2,6,2,0,4,1,1,0,4,,0,2,4,2,2,void
3574,110313,mixDigest,1,mixDigest,"void mixDigest (unsigned char*,void*,size_t)",debug.c,"void mixDigest(unsigned char *digest, const void *ptr, size_t len) {
    SHA1_CTX ctx;

    xorDigest(digest,ptr,len);
    SHA1Init(&ctx);
    SHA1Update(&ctx,digest,20);
    SHA1Final(digest,&ctx);
}",117.0,124.0,1.0,1.0,8.0,3,1,8,4,6,4,1,1,0,4,,0,0,6,3,3,void
3575,110337,mixStringObjectDigest,1,mixStringObjectDigest,"void mixStringObjectDigest (unsigned char*,robj*)",debug.c,"void mixStringObjectDigest(unsigned char *digest, robj *o) {
    o = getDecodedObject(o);
    mixDigest(digest,o->ptr,sdslen(o->ptr));
    decrRefCount(o);
}",126.0,130.0,1.0,1.0,5.0,3,2,6,2,1,4,1,1,0,4,,0,2,4,2,2,void
3576,110358,xorObjectDigest,1,xorObjectDigest,"void xorObjectDigest (redisDb*,robj*,unsigned char*,robj*)",debug.c,"void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {
    uint32_t aux = htonl(o->type);
    mixDigest(digest,&aux,sizeof(aux));
    long long expiretime = getExpire(db,keyobj);
    char buf[128];

    /* Save the key and associated value */
    if (o->type == OBJ_STRING) {
        mixStringObjectDigest(digest,o);
    } else if (o->type == OBJ_LIST) {
        listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
        listTypeEntry entry;
        while(listTypeNext(li,&entry)) {
            robj *eleobj = listTypeGet(&entry);
            mixStringObjectDigest(digest,eleobj);
            decrRefCount(eleobj);
        }
        listTypeReleaseIterator(li);
    } else if (o->type == OBJ_SET) {
        setTypeIterator *si = setTypeInitIterator(o);
        sds sdsele;
        while((sdsele = setTypeNextObject(si)) != NULL) {
            xorDigest(digest,sdsele,sdslen(sdsele));
            sdsfree(sdsele);
        }
        setTypeReleaseIterator(si);
 ...",140.0,269.0,1.0,19.0,130.0,9,7,13,6,1,4,3,3,0,4,,0,1,8,4,4,void
3577,110948,computeDatasetDigest,1,computeDatasetDigest,void computeDatasetDigest (unsigned char*),debug.c,"void computeDatasetDigest(unsigned char *final) {
    unsigned char digest[20];
    dictIterator *di = NULL;
    dictEntry *de;
    int j;
    uint32_t aux;

    memset(final,0,20); /* Start with a clean result */

    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db+j;

        if (dictSize(db->dict) == 0) continue;
        di = dictGetSafeIterator(db->dict);

        /* hash the DB id, so the same dataset moved in a different
         * DB will lead to a different digest */
        aux = htonl(j);
        mixDigest(final,&aux,sizeof(aux));

        /* Iterate this DB writing every entry */
        while((de = dictNext(di)) != NULL) {
            sds key;
            robj *keyobj, *o;

            memset(digest,0,20); /* This key-val digest */
            key = dictGetKey(de);
            keyobj = createStringObject(key,sdslen(key));

            mixDigest(digest,key,sdslen(key));

            o = dictGetVal(de);
            xorObjectDigest(db,keyobj,digest,o);
...",277.0,317.0,1.0,12.0,41.0,26,10,41,12,0,17,5,6,4,13,,0,11,2,1,1,void
3578,111074,debugCommand,1,debugCommand,void debugCommand (client*),debug.c,"void debugCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""AOF-FLUSH-SLEEP <microsec>"",
""    Server will sleep before flushing the AOF, this is used for testing."",
""ASSERT"",
""    Crash by assertion failed."",
""CHANGE-REPL-ID"",
""    Change the replication IDs of the instance."",
""    Dangerous: should be used only for testing the replication subsystem."",
""CONFIG-REWRITE-FORCE-ALL"",
""    Like CONFIG REWRITE but writes all configuration options, including"",
""    keywords not listed in original configuration file or default values."",
""CRASH-AND-RECOVER [<milliseconds>]"",
""    Hard crash and restart after a <milliseconds> delay (default 0)."",
""DIGEST"",
""    Output a hex signature representing the current DB content."",
""DIGEST-VALUE <key> [<key> ...]"",
""    Output a hex signature of the values of all the specified keys."",
""ERROR <string>"",
""    Return a Redis protocol error with <string> as message. Useful for clients"",
""   ...",390.0,1049.0,1.0,8.0,660.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
3579,114303,_serverAssert,1,_serverAssert,"void _serverAssert (char*,char*,int)",redisassert.c,"void _serverAssert(const char *estr, const char *file, int line) {
    fprintf(stderr, ""=== ASSERTION FAILED ==="");
    fprintf(stderr, ""==> %s:%d '%s' is not true"",file,line,estr);
    raise(SIGSEGV);
}",42.0,46.0,1.0,1.0,5.0,7,3,6,4,353,6,2,2,0,6,,0,0,6,3,3,void
3580,114360,_serverAssertPrintClientInfo,1,_serverAssertPrintClientInfo,void _serverAssertPrintClientInfo (client*),debug.c,"void _serverAssertPrintClientInfo(const client *c) {
    int j;
    char conninfo[CONN_INFO_LEN];

    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED CLIENT CONTEXT ==="");
    serverLog(LL_WARNING,""client->flags = %llu"", (unsigned long long) c->flags);
    serverLog(LL_WARNING,""client->conn = %s"", connGetInfo(c->conn, conninfo, sizeof(conninfo)));
    serverLog(LL_WARNING,""client->argc = %d"", c->argc);
    for (j=0; j < c->argc; j++) {
        char buf[128];
        char *arg;

        if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {
            arg = (char*) c->argv[j]->ptr;
        } else {
            snprintf(buf,sizeof(buf),""Object type: %u, encoding: %u"",
                c->argv[j]->type, c->argv[j]->encoding);
            arg = buf;
        }
        serverLog(LL_WARNING,""client->argv[%d] = \""%s\"" (refcount: %d)"",
            j, arg, c->argv[j]->refcount);
    }
}",1070.0,1093.0,1.0,18.0,24.0,47,11,28,5,1,17,3,4,5,7,,0,11,2,1,1,void
3581,114572,serverLogObjectDebugInfo,1,serverLogObjectDebugInfo,void serverLogObjectDebugInfo (robj*),debug.c,"void serverLogObjectDebugInfo(const robj *o) {
    serverLog(LL_WARNING,""Object type: %u"", o->type);
    serverLog(LL_WARNING,""Object encoding: %u"", o->encoding);
    serverLog(LL_WARNING,""Object refcount: %d"", o->refcount);
#if UNSAFE_CRASH_REPORT
    /* This code is now disabled. o->ptr may be unreliable to print. in some
     * cases a ziplist could have already been freed by realloc, but not yet
     * updated to o->ptr. in other cases the call to ziplistLen may need to
     * iterate on all the items in the list (and possibly crash again).
     * For some cases it may be ok to crash here again, but these could cause
     * invalid memory access which will bother valgrind and also possibly cause
     * random memory portion to be ""leaked"" into the logfile. */
    if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
        serverLog(LL_WARNING,""Object raw string len: %zu"", sdslen(o->ptr));
        if (sdslen(o->ptr) < 4096) {
            sds repr = sdscatrepr(sdsempty(),o->ptr,sd...",1095.0,1128.0,1.0,4.0,34.0,12,4,6,2,2,3,1,1,0,3,,0,0,2,1,1,void
3582,114640,_serverAssertPrintObject,1,_serverAssertPrintObject,void _serverAssertPrintObject (robj*),debug.c,"void _serverAssertPrintObject(const robj *o) {
    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED OBJECT CONTEXT ==="");
    serverLogObjectDebugInfo(o);
}",1130.0,1134.0,1.0,4.0,5.0,3,3,2,2,1,3,1,1,0,3,,0,0,2,1,1,void
3583,114666,_serverAssertWithInfo,1,_serverAssertWithInfo,"void _serverAssertWithInfo (client*,robj*,char*,char*,int)",debug.c,"void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
    if (c) _serverAssertPrintClientInfo(c);
    if (o) _serverAssertPrintObject(o);
    _serverAssert(estr,file,line);
}",1136.0,1140.0,1.0,1.0,5.0,0,0,7,5,45,3,3,3,0,3,,0,0,10,5,5,void
3584,114689,_serverPanic,1,_serverPanic,"void _serverPanic (char*,int,char*...)",redisassert.c,"void _serverPanic(const char *file, int line, const char *msg, ...) {
    fprintf(stderr, ""------------------------------------------------"");
    fprintf(stderr, ""!!! Software Failure. Press left mouse button to continue"");
    fprintf(stderr, ""Guru Meditation: %s #%s:%d"",msg,file,line);
    abort();
}",48.0,53.0,1.0,1.0,6.0,11,4,14,6,34,7,2,2,0,7,,0,0,6,3,3,void
3585,114808,openDirectLogFiledes,1,openDirectLogFiledes,int openDirectLogFiledes (void),debug.c,"int openDirectLogFiledes(void) {
    int log_to_stdout = server.logfile[0] == '\0';
    int fd = log_to_stdout ?
        STDOUT_FILENO :
        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
    return fd;
}",1804.0,1810.0,1.0,1.0,7.0,9,6,10,7,0,0,1,1,0,0,,0,0,2,1,1,int
3586,114841,closeDirectLogFiledes,1,closeDirectLogFiledes,void closeDirectLogFiledes (int),debug.c,"void closeDirectLogFiledes(int fd) {
    int log_to_stdout = server.logfile[0] == '\0';
    if (!log_to_stdout) close(fd);
}",1813.0,1816.0,1.0,1.0,4.0,5,5,4,3,0,0,2,2,0,0,,0,0,2,1,1,void
3587,114862,genClusterDebugString,1,genClusterDebugString,sds genClusterDebugString (sds),debug.c,"sds genClusterDebugString(sds infostring) {
    infostring = sdscatprintf(infostring, ""\r\n# Cluster info\r\n"");
    infostring = sdscatsds(infostring, genClusterInfoString()); 
    infostring = sdscatprintf(infostring, ""\n------ CLUSTER NODES OUTPUT ------\n"");
    infostring = sdscatsds(infostring, clusterGenNodesDescription(NULL, 0, 0));
    
    return infostring;
}",1857.0,1864.0,1.0,1.0,8.0,4,1,10,2,1,6,1,1,0,6,,0,6,2,1,1,sds
3588,114892,logServerInfo,1,logServerInfo,void logServerInfo (void),debug.c,"void logServerInfo(void) {
    sds infostring, clients;
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ INFO OUTPUT ------\n"");
    int all = 0, everything = 0;
    robj *argv[1];
    argv[0] = createStringObject(""all"", strlen(""all""));
    dict *section_dict = genInfoSectionDict(argv, 1, NULL, &all, &everything);
    infostring = genRedisInfoString(section_dict, all, everything);
    if (server.cluster_enabled){
        infostring = genClusterDebugString(infostring);
    }
    serverLogRaw(LL_WARNING|LL_RAW, infostring);
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ CLIENT LIST OUTPUT ------\n"");
    clients = getAllClientsInfoString(-1);
    serverLogRaw(LL_WARNING|LL_RAW, clients);
    sdsfree(infostring);
    sdsfree(clients);
    releaseInfoSectionDict(section_dict);
    decrRefCount(argv[0]);
}",1867.0,1886.0,1.0,17.0,20.0,21,7,22,8,0,13,2,2,0,13,,0,5,2,1,1,void
3589,115001,logConfigDebugInfo,1,logConfigDebugInfo,void logConfigDebugInfo (void),debug.c,"void logConfigDebugInfo(void) {
    sds configstring;
    configstring = getConfigDebugInfo();
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ CONFIG DEBUG OUTPUT ------\n"");
    serverLogRaw(LL_WARNING|LL_RAW, configstring);
    sdsfree(configstring);
}",1889.0,1895.0,1.0,17.0,7.0,5,3,3,1,0,4,1,1,0,4,,0,1,2,1,1,void
3590,115034,logModulesInfo,1,logModulesInfo,void logModulesInfo (void),debug.c,"void logModulesInfo(void) {
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ MODULES INFO OUTPUT ------\n"");
    sds infostring = modulesCollectInfo(sdsempty(), NULL, 1, 0);
    serverLogRaw(LL_WARNING|LL_RAW, infostring);
    sdsfree(infostring);
}",1898.0,1903.0,1.0,17.0,6.0,5,3,4,2,0,5,1,1,0,5,,0,2,2,1,1,void
3591,115071,logCurrentClient,1,logCurrentClient,"void logCurrentClient (client*,char*)",debug.c,"void logCurrentClient(client *cc, const char *title) {
    if (cc == NULL) return;

    sds client;
    int j;

    serverLog(LL_WARNING|LL_RAW, ""\n------ %s CLIENT INFO ------\n"", title);
    client = catClientInfoString(sdsempty(),cc);
    serverLog(LL_WARNING|LL_RAW,""%s\n"", client);
    sdsfree(client);
    serverLog(LL_WARNING|LL_RAW,""argc: '%d'\n"", cc->argc);
    for (j = 0; j < cc->argc; j++) {
        robj *decoded;
        decoded = getDecodedObject(cc->argv[j]);
        sds repr = sdscatrepr(sdsempty(),decoded->ptr, min(sdslen(decoded->ptr), 128));
        serverLog(LL_WARNING|LL_RAW,""argv[%d]: '%s'\n"", j, (char*)repr);
        if (!strcasecmp(decoded->ptr, ""auth"") || !strcasecmp(decoded->ptr, ""auth2"")) {
            sdsfree(repr);
            decrRefCount(decoded);
            break;
        }
        sdsfree(repr);
        decrRefCount(decoded);
    }
    /* Check if the first argument, usually a key, is found inside the
     * selected DB, and if so print info about the ...",1908.0,1947.0,1.0,4.0,40.0,65,14,44,11,0,29,7,8,2,23,,0,17,4,2,2,void
3592,115341,killMainThread,1,killMainThread,void killMainThread (void),debug.c,"static void killMainThread(void) {
    int err;
    if (pthread_self() != server.main_thread_id && pthread_cancel(server.main_thread_id) == 0) {
        if ((err = pthread_join(server.main_thread_id,NULL)) != 0) {
            serverLog(LL_WARNING, ""main thread can not be joined: %s"", strerror(err));
        } else {
            serverLog(LL_WARNING, ""main thread terminated"");
        }
    }
}",2019.0,2028.0,1.0,12.0,10.0,11,7,7,3,1,1,3,4,0,1,,0,0,2,1,1,void
3593,115412,killThreads,1,killThreads,void killThreads (void),debug.c,"void killThreads(void) {
    killMainThread();
    bioKillThreads();
    killIOThreads();
}",2034.0,2038.0,1.0,1.0,5.0,0,0,0,0,0,3,1,1,0,3,,0,0,2,1,1,void
3594,115420,doFastMemoryTest,1,doFastMemoryTest,void doFastMemoryTest (void),debug.c,"void doFastMemoryTest(void) {
#if defined(HAVE_PROC_MAPS)
    if (server.memcheck_enabled) {
        /* Test memory */
        serverLogRaw(LL_WARNING|LL_RAW, ""\n------ FAST MEMORY TEST ------\n"");
        killThreads();
        if (memtest_test_linux_anonymous_maps()) {
            serverLogRaw(LL_WARNING|LL_RAW,
                ""!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!\n"");
        } else {
            serverLogRaw(LL_WARNING|LL_RAW,
                ""Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.\n"");
        }
    }
#endif /* HAVE_PROC_MAPS */
}",2040.0,2055.0,1.0,1.0,16.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3595,115425,dumpX86Calls,1,dumpX86Calls,"void dumpX86Calls (void*,size_t)",debug.c,"void dumpX86Calls(void *addr, size_t len) {
    size_t j;
    unsigned char *p = addr;
    Dl_info info;
    /* Hash table to best-effort avoid printing the same symbol
     * multiple times. */
    unsigned long ht[256] = {0};

    if (len < 5) return;
    for (j = 0; j < len-4; j++) {
        if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */
        unsigned long target = (unsigned long)addr+j+5;
        uint32_t tmp;
        memcpy(&tmp, p+j+1, sizeof(tmp));
        target += tmp;
        if (dladdr((void*)target, &info) != 0 && info.dli_sname != NULL) {
            if (ht[target&0xff] != target) {
                printf(""Function at 0x%lx is %s\n"",target,info.dli_sname);
                ht[target&0xff] = target;
            }
            j += 4; /* Skip the 32 bit immediate. */
        }
    }
}",2060.0,2083.0,1.0,1.0,24.0,32,14,31,9,1,0,7,10,0,0,,0,0,4,2,2,void
3596,115534,dumpCodeAroundEIP,1,dumpCodeAroundEIP,void dumpCodeAroundEIP (void*),debug.c,"void dumpCodeAroundEIP(void *eip) {
    Dl_info info;
    if (dladdr(eip, &info) != 0) {
        serverLog(LL_WARNING|LL_RAW,
            ""\n------ DUMPING CODE AROUND EIP ------\n""
            ""Symbol: %s (base: %p)\n""
            ""Module: %s (base %p)\n""
            ""$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\n""
            ""$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\n""
            ""------\n"",
            info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,
            info.dli_saddr);
        size_t len = (long)eip - (long)info.dli_saddr;
        unsigned long sz = sysconf(_SC_PAGESIZE);
        if (len < 1<<13) { /* we don't have functions over 8k (verified) */
            /* Find the address of the next page, which is our ""safety""
             * limit when dumping. Then try to dump just 128 bytes more
             * than EIP if there is room, or stop sooner. */
            void *base = (void *)info.dli_saddr;
            unsigned long next = ((u...",2085.0,2113.0,1.0,8.0,29.0,39,13,33,9,0,3,4,7,0,3,,0,0,2,1,1,void
3597,115667,invalidFunctionWasCalled,1,invalidFunctionWasCalled,void invalidFunctionWasCalled (void),debug.c,void invalidFunctionWasCalled(void) {},2115.0,2115.0,1.0,38.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3598,115672,invalidFunctionWasCalledType,1,invalidFunctionWasCalledType,void invalidFunctionWasCalledType (void),debug.c,typedef void (*invalidFunctionWasCalledType)(void);,2117.0,2117.0,14.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3599,115677,sigsegvHandler,1,sigsegvHandler,"void sigsegvHandler (int,siginfo_t*,void*)",debug.c,"void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
    UNUSED(secret);
    UNUSED(info);

    bugReportStart();
    serverLog(LL_WARNING,
        ""Redis %s crashed by signal: %d, si_code: %d"", REDIS_VERSION, sig, info->si_code);
    if (sig == SIGSEGV || sig == SIGBUS) {
        serverLog(LL_WARNING,
        ""Accessing address: %p"", (void*)info->si_addr);
    }
    if (info->si_code == SI_USER && info->si_pid != -1) {
        serverLog(LL_WARNING, ""Killed by PID: %ld, UID: %d"", (long) info->si_pid, info->si_uid);
    }

#ifdef HAVE_BACKTRACE
    ucontext_t *uc = (ucontext_t*) secret;
    void *eip = getAndSetMcontextEip(uc, NULL);
    if (eip != NULL) {
        serverLog(LL_WARNING,
        ""Crashed running the instruction at: %p"", eip);
    }

    if (eip == info->si_addr) {
        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped
         * function pointer. In that case the call to backtrace will crash trying to access t...",2119.0,2172.0,1.0,4.0,54.0,26,10,20,7,0,6,3,3,0,6,,0,0,6,3,3,void
3600,115893,serverLogHexDump,1,serverLogHexDump,"void serverLogHexDump (int,char*,void*,size_t)",debug.c,"void serverLogHexDump(int level, char *descr, void *value, size_t len) {
    char buf[65], *b;
    unsigned char *v = value;
    char charset[] = ""0123456789abcdef"";

    serverLog(level,""%s (hexdump of %zu bytes):"", descr, len);
    b = buf;
    while(len) {
        b[0] = charset[(*v)>>4];
        b[1] = charset[(*v)&0xf];
        b[2] = '\0';
        b += 2;
        len--;
        v++;
        if (b-buf == 64 || len == 0) {
            serverLogRaw(level|LL_RAW,buf);
            b = buf;
        }
    }
    serverLogRaw(level|LL_RAW,""\n"");
}",2229.0,2249.0,1.0,4.0,21.0,30,15,30,9,1,3,3,4,0,3,,0,0,8,4,4,void
3601,116002,watchdogSignalHandler,1,watchdogSignalHandler,"void watchdogSignalHandler (int,siginfo_t*,void*)",debug.c,"void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
#ifdef HAVE_BACKTRACE
    ucontext_t *uc = (ucontext_t*) secret;
#else
    (void)secret;
#endif
    UNUSED(info);
    UNUSED(sig);

    serverLogFromHandler(LL_WARNING,""\n--- WATCHDOG TIMER EXPIRED ---"");
#ifdef HAVE_BACKTRACE
    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);
#else
    serverLogFromHandler(LL_WARNING,""Sorry: no support for backtrace()."");
#endif
    serverLogFromHandler(LL_WARNING,""--------\n"");
}",2254.0,2270.0,1.0,4.0,17.0,3,1,5,3,0,3,1,1,0,3,,0,0,6,3,3,void
3602,116039,watchdogScheduleSignal,1,watchdogScheduleSignal,void watchdogScheduleSignal (int),debug.c,"void watchdogScheduleSignal(int period) {
    struct itimerval it;

    /* Will stop the timer if period is 0. */
    it.it_value.tv_sec = period/1000;
    it.it_value.tv_usec = (period%1000)*1000;
    /* Don't automatically restart. */
    it.it_interval.tv_sec = 0;
    it.it_interval.tv_usec = 0;
    setitimer(ITIMER_REAL, &it, NULL);
}",2275.0,2285.0,1.0,1.0,11.0,16,6,9,4,2,0,1,1,0,0,,0,0,2,1,1,void
3603,116084,applyWatchdogPeriod,1,applyWatchdogPeriod,void applyWatchdogPeriod (void),debug.c,"void applyWatchdogPeriod(void) {
    struct sigaction act;

    /* Disable watchdog when period is 0 */
    if (server.watchdog_period == 0) {
        watchdogScheduleSignal(0); /* Stop the current timer. */

        /* Set the signal handler to SIG_IGN, this will also remove pending
         * signals from the queue. */
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        act.sa_handler = SIG_IGN;
        sigaction(SIGALRM, &act, NULL);
    } else {
        /* Setup the signal handler. */
        sigemptyset(&act.sa_mask);
        act.sa_flags = SA_SIGINFO;
        act.sa_sigaction = watchdogSignalHandler;
        sigaction(SIGALRM, &act, NULL);

        /* If the configured period is smaller than twice the timer period, it is
         * too short for the software watchdog to work reliably. Fix it now
         * if needed. */
        int min_period = (1000/server.hz)*2;
        if (server.watchdog_period < min_period) server.watchdog_period = min_period;
        wat...",2286.0,2313.0,1.0,1.0,28.0,9,4,8,5,2,1,2,2,0,1,,0,0,2,1,1,void
3604,116167,debugDelay,1,debugDelay,void debugDelay (int),debug.c,"void debugDelay(int usec) {
    /* Since even the shortest sleep results in context switch and system call,
     * the way we achieve short sleeps is by statistically sleeping less often. */
    if (usec < 0) usec = (rand() % -usec) == 0 ? 1: 0;
    if (usec) usleep(usec);
}",2317.0,2322.0,1.0,1.0,6.0,6,6,5,1,4,0,3,3,0,0,,0,0,2,1,1,void
3605,116215,activeDefragCycle,1,activeDefragCycle,void activeDefragCycle (void),defrag.c,"void activeDefragCycle(void) {
    /* Not implemented yet. */
}",1065.0,1067.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
3606,116220,activeDefragAlloc,1,activeDefragAlloc,void* activeDefragAlloc (void*),defrag.c,"void *activeDefragAlloc(void *ptr) {
    UNUSED(ptr);
    return NULL;
}",1069.0,1072.0,1.0,4.0,4.0,1,1,3,2,2,0,1,1,0,0,,0,0,2,1,1,void*
3607,116233,activeDefragStringOb,1,activeDefragStringOb,robj activeDefragStringOb (robj*),defrag.c,"robj *activeDefragStringOb(robj *ob) {
    UNUSED(ob);
    return NULL;
}",1074.0,1077.0,1.0,4.0,4.0,1,1,3,2,1,0,1,1,0,0,,0,0,2,1,1,robj
3608,116303,_dictExpandIfNeeded,1,_dictExpandIfNeeded,int _dictExpandIfNeeded (dict*),dict.c,"static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK;

    /* If the hash table is empty expand it to the initial size. */
    if (DICTHT_SIZE(d->ht_size_exp[0]) == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the ""safe"" threshold, we resize doubling
     * the number of buckets. */
    if (!dictTypeExpandAllowed(d))
        return DICT_OK;
    if ((dict_can_resize == DICT_RESIZE_ENABLE &&
         d->ht_used[0] >= DICTHT_SIZE(d->ht_size_exp[0])) ||
        (dict_can_resize != DICT_RESIZE_FORBID &&
         d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]) > dict_force_resize_ratio))
    {
        return dictExpand(d, d->ht_used[0] + 1);
    }
    return DICT_OK;
}",1405.0,1427.0,1.0,8.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
3609,116308,_dictNextExp,1,_dictNextExp,signed char _dictNextExp (long unsigned),dict.c,"static signed char _dictNextExp(unsigned long size)
{
    unsigned char e = DICT_HT_INITIAL_EXP;

    if (size >= LONG_MAX) return (8*sizeof(long)-1);
    while(1) {
        if (((unsigned long)1<<e) >= size)
            return e;
        e++;
    }
}",1431.0,1441.0,1.0,22.0,11.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,signed char
3610,116313,_dictInit,1,_dictInit,"int _dictInit (dict*,dictType*)",dict.c,"int _dictInit(dict *d, dictType *type)
{
    _dictReset(d, 0);
    _dictReset(d, 1);
    d->type = type;
    d->rehashidx = -1;
    d->pauserehash = 0;
    return DICT_OK;
}",198.0,206.0,1.0,11.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3611,116319,dictGetNext,1,dictGetNext,dictEntry* dictGetNext (dictEntry*),dict.c,"static dictEntry *dictGetNext(const dictEntry *de) {
    if (entryIsKey(de)) return NULL; /* there's no next */
    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->next;
    return de->next;
}",831.0,835.0,1.0,1.0,5.0,0,0,0,0,12,0,1,1,0,0,,0,0,2,1,1,dictEntry
3612,116324,dictGetNextRef,1,dictGetNextRef,dictEntry** dictGetNextRef (dictEntry*),dict.c,"static dictEntry **dictGetNextRef(dictEntry *de) {
    if (entryIsKey(de)) return NULL;
    if (entryIsNoValue(de)) return &decodeEntryNoValue(de)->next;
    return &de->next;
}",839.0,843.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,dictEntry
3613,116329,dictSetNext,1,dictSetNext,"void dictSetNext (dictEntry*,dictEntry*)",dict.c,"static void dictSetNext(dictEntry *de, dictEntry *next) {
    assert(!entryIsKey(de));
    if (entryIsNoValue(de)) {
        dictEntryNoValue *entry = decodeEntryNoValue(de);
        entry->next = next;
    } else {
        de->next = next;
    }
}",845.0,853.0,1.0,4.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3614,116338,dictSetHashFunctionSeed,1,dictSetHashFunctionSeed,void dictSetHashFunctionSeed (uint8_t*),dict.c,"void dictSetHashFunctionSeed(uint8_t *seed) {
    memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
}",95.0,97.0,1.0,1.0,3.0,1,1,3,2,0,2,1,1,0,0,,0,2,2,1,1,void
3615,116348,dictGetHashFunctionSeed,1,dictGetHashFunctionSeed,uint8_t dictGetHashFunctionSeed (void),dict.c,"uint8_t *dictGetHashFunctionSeed(void) {
    return dict_hash_function_seed;
}",99.0,101.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,2,1,1,uint8_t
3616,116355,siphash,1,siphash,"uint64_t siphash (uint8_t*,size_t,uint8_t*)",siphash.c,"uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out = (uint8_t*) &hash;
#endif
    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;
    uint64_t k0 = U8TO64_LE(k);
    uint64_t k1 = U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
    const int left = inlen & 7;
    uint64_t b = ((uint64_t)inlen) << 56;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 8) {
        m = U8TO64_LE(in);
        v3 ^= m;

        SIPROUND;

        v0 ^= m;
    }

    switch (left) {
    case 7: b |= ((uint64_t)in[6]) << 48; /* fall-thru */
    case 6: b |= ((uint64_t)in[5]) << 40; /* fall-thru */
    case 5: b |= ((uint64_t)in[4]) << 32; /* fall-thru */
    case 4: b |= ((uint64_t)in[3]) << 24; /* fall-thru */
    case 3: b |...",127.0,184.0,1.0,18.0,58.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,uint64_t
3617,116362,siphash_nocase,1,siphash_nocase,"uint64_t siphash_nocase (uint8_t*,size_t,uint8_t*)",siphash.c,"uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)
{
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out = (uint8_t*) &hash;
#endif
    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;
    uint64_t k0 = U8TO64_LE(k);
    uint64_t k1 = U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
    const int left = inlen & 7;
    uint64_t b = ((uint64_t)inlen) << 56;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 8) {
        m = U8TO64_LE_NOCASE(in);
        v3 ^= m;

        SIPROUND;

        v0 ^= m;
    }

    switch (left) {
    case 7: b |= ((uint64_t)siptlw(in[6])) << 48; /* fall-thru */
    case 6: b |= ((uint64_t)siptlw(in[5])) << 40; /* fall-thru */
    case 5: b |= ((uint64_t)siptlw(in[4])) << 32; /* fall-thru */
    case 4: b |= ((uint64_t)siptlw(...",187.0,245.0,1.0,18.0,59.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,uint64_t
3618,116369,dictGenHashFunction,1,dictGenHashFunction,"uint64_t dictGenHashFunction (void*,size_t)",dict.c,"uint64_t dictGenHashFunction(const void *key, size_t len) {
    return siphash(key,len,dict_hash_function_seed);
}",109.0,111.0,1.0,1.0,3.0,0,0,3,3,5,2,1,1,0,1,,0,1,4,2,2,uint64_t
3619,116380,dictGenCaseHashFunction,1,dictGenCaseHashFunction,"uint64_t dictGenCaseHashFunction (unsigned char*,size_t)",dict.c,"uint64_t dictGenCaseHashFunction(const unsigned char *buf, size_t len) {
    return siphash_nocase(buf,len,dict_hash_function_seed);
}",113.0,115.0,1.0,1.0,3.0,0,0,3,3,3,2,1,1,0,1,,0,1,4,2,2,uint64_t
3620,116391,entryIsKey,1,entryIsKey,int entryIsKey (dictEntry*),dict.c,"static inline int entryIsKey(const dictEntry *de) {
    return (uintptr_t)(void *)de & 1;
}",129.0,131.0,1.0,1.0,3.0,3,2,1,1,14,0,1,1,0,0,,0,0,2,1,1,int
3621,116404,entryIsNormal,1,entryIsNormal,int entryIsNormal (dictEntry*),dict.c,"static inline int entryIsNormal(const dictEntry *de) {
    return ((uintptr_t)(void *)de & ENTRY_PTR_MASK) == ENTRY_PTR_NORMAL;
}",135.0,137.0,1.0,36.0,3.0,4,3,1,1,1,0,1,1,0,0,,0,0,2,1,1,int
3622,116423,entryIsNoValue,1,entryIsNoValue,int entryIsNoValue (dictEntry*),dict.c,"static inline int entryIsNoValue(const dictEntry *de) {
    return ((uintptr_t)(void *)de & ENTRY_PTR_MASK) == ENTRY_PTR_NO_VALUE;
}",141.0,143.0,1.0,36.0,3.0,4,3,1,1,1,0,1,1,0,0,,0,0,2,1,1,int
3623,116442,createEntryNoValue,1,createEntryNoValue,"dictEntry createEntryNoValue (void*,dictEntry*)",dict.c,"static inline dictEntry *createEntryNoValue(void *key, dictEntry *next) {
    dictEntryNoValue *entry = zmalloc(sizeof(*entry));
    entry->key = key;
    entry->next = next;
    return (dictEntry *)(void *)((uintptr_t)(void *)entry | ENTRY_PTR_NO_VALUE);
}",146.0,151.0,1.0,60.0,6.0,12,6,7,3,0,3,1,1,0,1,,0,3,4,2,2,dictEntry
3624,116479,encodeMaskedPtr,1,encodeMaskedPtr,"dictEntry encodeMaskedPtr (void*,unsigned int)",dict.c,"static inline dictEntry *encodeMaskedPtr(const void *ptr, unsigned int bits) {
    assert(((uintptr_t)ptr & ENTRY_PTR_MASK) == 0);
    return (dictEntry *)(void *)((uintptr_t)ptr | bits);
}",153.0,156.0,1.0,4.0,4.0,11,7,3,2,0,1,1,1,0,1,,0,0,4,2,2,dictEntry
3625,116515,decodeMaskedPtr,1,decodeMaskedPtr,void* decodeMaskedPtr (dictEntry*),dict.c,"static inline void *decodeMaskedPtr(const dictEntry *de) {
    assert(!entryIsKey(de));
    return (void *)((uintptr_t)(void *)de & ~ENTRY_PTR_MASK);
}",158.0,161.0,1.0,4.0,4.0,11,7,3,1,5,3,1,1,0,3,,0,0,2,1,1,void*
3626,116552,decodeEntryNoValue,1,decodeEntryNoValue,dictEntryNoValue decodeEntryNoValue (dictEntry*),dict.c,"static inline dictEntryNoValue *decodeEntryNoValue(const dictEntry *de) {
    return decodeMaskedPtr(de);
}",165.0,167.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,dictEntryNoValue
3627,116560,entryHasValue,1,entryHasValue,int entryHasValue (dictEntry*),dict.c,"static inline int entryHasValue(const dictEntry *de) {
    return entryIsNormal(de);
}",170.0,172.0,1.0,1.0,3.0,0,0,1,1,26,1,1,1,0,1,,0,0,2,1,1,int
3628,116568,_dictReset,1,_dictReset,"void _dictReset (dict*,int)",dict.c,"static void _dictReset(dict *d, int htidx)
{
    d->ht_table[htidx] = NULL;
    d->ht_size_exp[htidx] = -1;
    d->ht_used[htidx] = 0;
}",177.0,182.0,1.0,1.0,6.0,10,4,7,3,2,3,1,1,0,0,,0,3,4,2,2,void
3629,116596,dictCreate,1,dictCreate,dict dictCreate (dictType*),dict.c,"dict *dictCreate(dictType *type)
{
    size_t metasize = type->dictMetadataBytes ? type->dictMetadataBytes() : 0;
    dict *d = zmalloc(sizeof(*d) + metasize);
    if (metasize) {
        memset(dictMetadata(d), 0, metasize);
    }

    _dictInit(d,type);
    return d;
}",185.0,195.0,1.0,1.0,11.0,8,6,12,3,59,4,2,2,0,4,,0,2,2,1,1,dict
3630,116667,dictResize,1,dictResize,int dictResize (dict*),dict.c,"int dictResize(dict *d)
{
    unsigned long minimal;

    if (dict_can_resize != DICT_RESIZE_ENABLE || dictIsRehashing(d)) return DICT_ERR;
    minimal = d->ht_used[0];
    if (minimal < DICT_HT_INITIAL_SIZE)
        minimal = DICT_HT_INITIAL_SIZE;
    return dictExpand(d, minimal);
}",210.0,219.0,1.0,49.0,10.0,12,8,10,4,3,4,3,3,2,1,,0,3,2,1,1,int
3631,116719,_dictExpand,1,_dictExpand,"int _dictExpand (dict*,long unsigned,int*)",dict.c,"int _dictExpand(dict *d, unsigned long size, int* malloc_failed)
{
    if (malloc_failed) *malloc_failed = 0;

    /* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */
    if (dictIsRehashing(d) || d->ht_used[0] > size)
        return DICT_ERR;

    /* the new hash table */
    dictEntry **new_ht_table;
    unsigned long new_ht_used;
    signed char new_ht_size_exp = _dictNextExp(size);

    /* Detect overflows */
    size_t newsize = 1ul<<new_ht_size_exp;
    if (newsize < size || newsize * sizeof(dictEntry*) < newsize)
        return DICT_ERR;

    /* Rehashing to the same table size is not useful. */
    if (new_ht_size_exp == d->ht_size_exp[0]) return DICT_ERR;

    /* Allocate the new hash table and initialize all pointers to NULL */
    if (malloc_failed) {
        new_ht_table = ztrycalloc(newsize*sizeof(dictEntry*));
        *malloc_failed = new_ht_table == NULL;
        if (*malloc_failed)
            return DICT_ERR;
 ...",224.0,272.0,1.0,8.0,49.0,51,13,41,9,2,13,8,9,4,2,,0,13,6,3,3,int
3632,116898,dictExpand,1,dictExpand,"int dictExpand (dict*,long unsigned)",dict.c,"int dictExpand(dict *d, unsigned long size) {
    return _dictExpand(d, size, NULL);
}",275.0,277.0,1.0,1.0,3.0,0,0,3,3,10,1,1,1,0,1,,0,0,4,2,2,int
3633,116909,dictTryExpand,1,dictTryExpand,"int dictTryExpand (dict*,long unsigned)",dict.c,"int dictTryExpand(dict *d, unsigned long size) {
    int malloc_failed;
    _dictExpand(d, size, &malloc_failed);
    return malloc_failed? DICT_ERR : DICT_OK;
}",280.0,284.0,1.0,26.0,5.0,2,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,int
3634,116930,dictRehash,1,dictRehash,"int dictRehash (dict*,int)",dict.c,"int dictRehash(dict *d, int n) {
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);
    unsigned long s1 = DICTHT_SIZE(d->ht_size_exp[1]);
    if (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) return 0;
    if (dict_can_resize == DICT_RESIZE_AVOID && 
        ((s1 > s0 && s1 / s0 < dict_force_resize_ratio) ||
         (s1 < s0 && s0 / s1 < dict_force_resize_ratio)))
    {
        return 0;
    }

    while(n-- && d->ht_used[0] != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(DICTHT_SIZE(d->ht_size_exp[0]) > (unsigned long)d->rehashidx);
        while(d->ht_table[0][d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht_table[0][d->rehashidx];
        /* Move all the keys in this bucket from ...",295.0,381.0,1.0,23.0,87.0,162,23,86,14,2,56,12,27,15,11,,0,49,4,2,2,int
3635,117464,timeInMilliseconds,1,timeInMilliseconds,long long timeInMilliseconds (void),dict.c,"long long timeInMilliseconds(void) {
    struct timeval tv;

    gettimeofday(&tv,NULL);
    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
}",383.0,388.0,1.0,1.0,6.0,7,6,4,2,2,0,1,1,0,0,,0,0,2,1,1,long long
3636,117488,dictRehashMilliseconds,1,dictRehashMilliseconds,"int dictRehashMilliseconds (dict*,int)",dict.c,"int dictRehashMilliseconds(dict *d, int ms) {
    if (d->pauserehash > 0) return 0;

    long long start = timeInMilliseconds();
    int rehashes = 0;

    while(dictRehash(d,100)) {
        rehashes += 100;
        if (timeInMilliseconds()-start > ms) break;
    }
    return rehashes;
}",393.0,404.0,1.0,1.0,12.0,7,5,8,4,2,4,5,5,3,3,,0,4,4,2,2,int
3637,117529,_dictRehashStep,1,_dictRehashStep,void _dictRehashStep (dict*),dict.c,"static void _dictRehashStep(dict *d) {
    if (d->pauserehash == 0) dictRehash(d,1);
}",414.0,416.0,1.0,1.0,3.0,2,2,2,1,6,2,2,2,1,1,,0,1,2,1,1,void
3638,117544,dictMetadata,1,dictMetadata,void* dictMetadata (dict*),dict.c,"void *dictMetadata(dict *d) {
    return &d->metadata;
}",419.0,421.0,1.0,1.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,void*
3639,117554,dictAdd,1,dictAdd,"int dictAdd (dict*,void*,void*)",dict.c,"int dictAdd(dict *d, void *key, void *val)
{
    dictEntry *entry = dictAddRaw(d,key,NULL);

    if (!entry) return DICT_ERR;
    if (!d->type->no_value) dictSetVal(d, entry, val);
    return DICT_OK;
}",424.0,431.0,1.0,23.0,8.0,5,3,9,5,38,3,3,3,1,2,,0,2,6,3,3,int
3640,117592,dictAddRaw,1,dictAddRaw,"dictEntry dictAddRaw (dict*,void*,dictEntry**)",dict.c,"dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
{
    /* Get the position for the new key or NULL if the key already exists. */
    void *position = dictFindPositionForInsert(d, key, existing);
    if (!position) return NULL;

    /* Dup the key if necessary. */
    if (d->type->keyDup) key = d->type->keyDup(d, key);

    return dictInsertAtPosition(d, key, position);
}",451.0,461.0,1.0,1.0,11.0,7,3,14,5,11,5,3,3,1,3,,0,4,6,3,3,dictEntry
3641,117634,dictInsertAtPosition,1,dictInsertAtPosition,"dictEntry dictInsertAtPosition (dict*,void*,void*)",dict.c,"dictEntry *dictInsertAtPosition(dict *d, void *key, void *position) {
    dictEntry **bucket = position; /* It's a bucket, but the API hides that. */
    dictEntry *entry;
    /* If rehashing is ongoing, we insert in table 1, otherwise in table 0.
     * Assert that the provided bucket is the right table. */
    int htidx = dictIsRehashing(d) ? 1 : 0;
    assert(bucket >= &d->ht_table[htidx][0] &&
           bucket <= &d->ht_table[htidx][DICTHT_SIZE_MASK(d->ht_size_exp[htidx])]);
    size_t metasize = dictEntryMetadataSize(d);
    if (d->type->no_value) {
        assert(!metasize); /* Entry metadata + no value not supported. */
        if (d->type->keys_are_odd && !*bucket) {
            /* We can store the key directly in the destination bucket without the
             * allocated entry.
             *
             * TODO: Add a flag 'keys_are_even' and if set, we can use this
             * optimization for these dicts too. We can set the LSB bit when
             * stored as a di...",467.0,509.0,1.0,16.0,43.0,65,19,36,7,1,16,3,4,2,5,,0,11,6,3,3,dictEntry
3642,117868,dictReplace,1,dictReplace,"int dictReplace (dict*,void*,void*)",dict.c,"int dictReplace(dict *d, void *key, void *val)
{
    dictEntry *entry, *existing;

    /* Try to add the element. If the key
     * does not exists dictAdd will succeed. */
    entry = dictAddRaw(d,key,&existing);
    if (entry) {
        dictSetVal(d, entry, val);
        return 1;
    }

    /* Set the new value and free the old one. Note that it is important
     * to do that in this order, as the value may just be exactly the same
     * as the previous one. In this context, think to reference counting,
     * you want to increment (set), and then decrement (free), and not the
     * reverse. */
    void *oldval = dictGetVal(existing);
    dictSetVal(d, existing, val);
    if (d->type->valDestructor)
        d->type->valDestructor(d, oldval);
    return 0;
}",516.0,538.0,1.0,1.0,23.0,7,3,17,6,1,7,3,3,1,5,,0,4,6,3,3,int
3643,117919,dictAddOrFind,1,dictAddOrFind,"dictEntry dictAddOrFind (dict*,void*)",dict.c,"dictEntry *dictAddOrFind(dict *d, void *key) {
    dictEntry *entry, *existing;
    entry = dictAddRaw(d,key,&existing);
    return entry ? entry : existing;
}",547.0,551.0,1.0,1.0,5.0,3,3,7,4,2,1,1,1,0,1,,0,1,4,2,2,dictEntry
3644,117939,dictGenericDelete,1,dictGenericDelete,"dictEntry dictGenericDelete (dict*,void*,int)",dict.c,"static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
    uint64_t h, idx;
    dictEntry *he, *prevHe;
    int table;

    /* dict is empty */
    if (dictSize(d) == 0) return NULL;

    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        prevHe = NULL;
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key)) {
                /* Unlink the element from the list */
                if (prevHe)
                    dictSetNext(prevHe, dictGetNext(he));
                else
                    d->ht_table[table][idx] = dictGetNext(he);
                if (!nofree) {
                    dictFreeUnlinkedEntry(d, he);
                }
                d->ht_used[table]--;
                return he;
            }
            prevHe...",556.0,591.0,1.0,8.0,36.0,57,16,61,10,2,19,10,19,6,6,,0,16,6,3,3,dictEntry
3645,118155,dictDelete,1,dictDelete,"int dictDelete (dict*,void*)",dict.c,"int dictDelete(dict *ht, const void *key) {
    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
}",595.0,597.0,1.0,41.0,3.0,1,1,2,2,32,1,1,1,0,1,,0,0,4,2,2,int
3646,118173,dictUnlink,1,dictUnlink,"dictEntry dictUnlink (dict*,void*)",dict.c,"dictEntry *dictUnlink(dict *d, const void *key) {
    return dictGenericDelete(d,key,1);
}",620.0,622.0,1.0,1.0,3.0,0,0,2,2,5,1,1,1,0,1,,0,0,4,2,2,dictEntry
3647,118184,dictFreeUnlinkedEntry,1,dictFreeUnlinkedEntry,"void dictFreeUnlinkedEntry (dict*,dictEntry*)",dict.c,"void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
    if (he == NULL) return;
    dictFreeKey(d, he);
    dictFreeVal(d, he);
    if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
}",626.0,631.0,1.0,4.0,6.0,10,3,16,3,6,9,3,3,1,5,,0,6,4,2,2,void
3648,118247,_dictClear,1,_dictClear,"int _dictClear (dict*,int,void)",dict.c,"int _dictClear(dict *d, int htidx, void(callback)(dict*)) {
    unsigned long i;

    /* Free all the elements */
    for (i = 0; i < DICTHT_SIZE(d->ht_size_exp[htidx]) && d->ht_used[htidx] > 0; i++) {
        dictEntry *he, *nextHe;

        if (callback && (i & 65535) == 0) callback(d);

        if ((he = d->ht_table[htidx][i]) == NULL) continue;
        while(he) {
            nextHe = dictGetNext(he);
            dictFreeKey(d, he);
            dictFreeVal(d, he);
            if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
            d->ht_used[htidx]--;
            he = nextHe;
        }
    }
    /* Free the table and the allocated cache structure */
    zfree(d->ht_table[htidx]);
    /* Re-initialize the table */
    _dictReset(d, htidx);
    return DICT_OK; /* never fails */
}",634.0,658.0,1.0,20.0,25.0,41,14,43,7,4,19,7,11,6,8,,0,14,6,3,3,int
3649,118406,dictRelease,1,dictRelease,void dictRelease (dict*),dict.c,"void dictRelease(dict *d)
{
    _dictClear(d,0,NULL);
    _dictClear(d,1,NULL);
    zfree(d);
}",661.0,666.0,1.0,1.0,6.0,0,0,5,2,34,3,1,1,0,3,,0,0,2,1,1,void
3650,118421,dictFind,1,dictFind,"dictEntry dictFind (dict*,void*)",dict.c,"dictEntry *dictFind(dict *d, const void *key)
{
    dictEntry *he;
    uint64_t h, idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);
    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key))
                return he;
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",668.0,688.0,1.0,8.0,21.0,51,15,50,8,65,15,7,11,6,3,,0,14,4,2,2,dictEntry
3651,118598,dictFetchValue,1,dictFetchValue,"void* dictFetchValue (dict*,void*)",dict.c,"void *dictFetchValue(dict *d, const void *key) {
    dictEntry *he;

    he = dictFind(d,key);
    return he ? dictGetVal(he) : NULL;
}",690.0,695.0,1.0,1.0,6.0,2,2,6,4,28,2,1,1,0,2,,0,1,4,2,2,void*
3652,118616,dictTwoPhaseUnlinkFind,1,dictTwoPhaseUnlinkFind,"dictEntry dictTwoPhaseUnlinkFind (dict*,void*,dictEntry***,int*)",dict.c,"dictEntry *dictTwoPhaseUnlinkFind(dict *d, const void *key, dictEntry ***plink, int *table_index) {
    uint64_t h, idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        dictEntry **ref = &d->ht_table[table][idx];
        while (ref && *ref) {
            void *de_key = dictGetKey(*ref);
            if (key == de_key || dictCompareKeys(d, key, de_key)) {
                *table_index = table;
                *plink = ref;
                dictPauseRehashing(d);
                return *ref;
            }
            ref = dictGetNextRef(*ref);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",713.0,736.0,1.0,8.0,24.0,63,19,57,10,1,16,7,11,6,3,,0,15,8,4,4,dictEntry
3653,118817,dictTwoPhaseUnlinkFree,1,dictTwoPhaseUnlinkFree,"void dictTwoPhaseUnlinkFree (dict*,dictEntry*,dictEntry**,int)",dict.c,"void dictTwoPhaseUnlinkFree(dict *d, dictEntry *he, dictEntry **plink, int table_index) {
    if (he == NULL) return;
    d->ht_used[table_index]--;
    *plink = dictGetNext(he);
    dictFreeKey(d, he);
    dictFreeVal(d, he);
    if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
    dictResumeRehashing(d);
}",738.0,746.0,1.0,4.0,9.0,17,7,22,5,1,12,3,3,1,6,,0,9,8,4,4,void
3654,118900,dictSetKey,1,dictSetKey,"void dictSetKey (dict*,dictEntry*,void*)",dict.c,"void dictSetKey(dict *d, dictEntry* de, void *key) {
    assert(!d->type->no_value);
    if (d->type->keyDup)
        de->key = d->type->keyDup(d, key);
    else
        de->key = key;
}",748.0,754.0,1.0,4.0,7.0,16,7,7,3,2,7,2,2,1,2,,0,6,6,3,3,void
3655,118958,dictSetVal,1,dictSetVal,"void dictSetVal (dict*,dictEntry*,void*)",dict.c,"void dictSetVal(dict *d, dictEntry *de, void *val) {
    assert(entryHasValue(de));
    de->v.val = d->type->valDup ? d->type->valDup(d, val) : val;
}",756.0,759.0,1.0,4.0,4.0,12,7,8,3,10,7,1,1,0,4,,0,4,6,3,3,void
3656,119003,dictSetSignedIntegerVal,1,dictSetSignedIntegerVal,"void dictSetSignedIntegerVal (dictEntry*,int64_t)",dict.c,"void dictSetSignedIntegerVal(dictEntry *de, int64_t val) {
    assert(entryHasValue(de));
    de->v.s64 = val;
}",761.0,764.0,1.0,4.0,4.0,7,7,4,2,1,4,1,1,0,3,,0,1,4,2,2,void
3657,119033,dictSetUnsignedIntegerVal,1,dictSetUnsignedIntegerVal,"void dictSetUnsignedIntegerVal (dictEntry*,uint64_t)",dict.c,"void dictSetUnsignedIntegerVal(dictEntry *de, uint64_t val) {
    assert(entryHasValue(de));
    de->v.u64 = val;
}",766.0,769.0,1.0,4.0,4.0,7,7,4,2,6,4,1,1,0,3,,0,1,4,2,2,void
3658,119063,dictSetDoubleVal,1,dictSetDoubleVal,"void dictSetDoubleVal (dictEntry*,double)",dict.c,"void dictSetDoubleVal(dictEntry *de, double val) {
    assert(entryHasValue(de));
    de->v.d = val;
}",771.0,774.0,1.0,4.0,4.0,7,7,4,2,1,4,1,1,0,3,,0,1,4,2,2,void
3659,119093,dictIncrSignedIntegerVal,1,dictIncrSignedIntegerVal,"int64_t dictIncrSignedIntegerVal (dictEntry*,int64_t)",dict.c,"int64_t dictIncrSignedIntegerVal(dictEntry *de, int64_t val) {
    assert(entryHasValue(de));
    return de->v.s64 += val;
}",776.0,779.0,1.0,4.0,4.0,7,7,4,2,0,4,1,1,0,3,,0,1,4,2,2,int64_t
3660,119124,dictIncrUnsignedIntegerVal,1,dictIncrUnsignedIntegerVal,"uint64_t dictIncrUnsignedIntegerVal (dictEntry*,uint64_t)",dict.c,"uint64_t dictIncrUnsignedIntegerVal(dictEntry *de, uint64_t val) {
    assert(entryHasValue(de));
    return de->v.u64 += val;
}",781.0,784.0,1.0,4.0,4.0,7,7,4,2,0,4,1,1,0,3,,0,1,4,2,2,uint64_t
3661,119155,dictIncrDoubleVal,1,dictIncrDoubleVal,"double dictIncrDoubleVal (dictEntry*,double)",dict.c,"double dictIncrDoubleVal(dictEntry *de, double val) {
    assert(entryHasValue(de));
    return de->v.d += val;
}",786.0,789.0,1.0,4.0,4.0,7,7,4,2,0,4,1,1,0,3,,0,1,4,2,2,double
3662,119186,dictEntryMetadata,1,dictEntryMetadata,void* dictEntryMetadata (dictEntry*),dict.c,"void *dictEntryMetadata(dictEntry *de) {
    assert(entryHasValue(de));
    return &de->metadata;
}",792.0,795.0,1.0,4.0,4.0,6,6,3,1,12,4,1,1,0,3,,0,1,2,1,1,void*
3663,119213,dictGetKey,1,dictGetKey,void* dictGetKey (dictEntry*),dict.c,"void *dictGetKey(const dictEntry *de) {
    if (entryIsKey(de)) return (void*)de;
    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->key;
    return de->key;
}",797.0,801.0,1.0,1.0,5.0,3,2,5,1,73,4,3,3,2,3,,0,3,2,1,1,void*
3664,119239,dictGetVal,1,dictGetVal,void* dictGetVal (dictEntry*),dict.c,"void *dictGetVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.val;
}",803.0,806.0,1.0,4.0,4.0,6,6,3,1,132,4,1,1,0,3,,0,1,2,1,1,void*
3665,119267,dictGetSignedIntegerVal,1,dictGetSignedIntegerVal,int64_t dictGetSignedIntegerVal (dictEntry*),dict.c,"int64_t dictGetSignedIntegerVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.s64;
}",808.0,811.0,1.0,4.0,4.0,6,6,3,1,3,4,1,1,0,3,,0,1,2,1,1,int64_t
3666,119295,dictGetUnsignedIntegerVal,1,dictGetUnsignedIntegerVal,uint64_t dictGetUnsignedIntegerVal (dictEntry*),dict.c,"uint64_t dictGetUnsignedIntegerVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.u64;
}",813.0,816.0,1.0,4.0,4.0,6,6,3,1,6,4,1,1,0,3,,0,1,2,1,1,uint64_t
3667,119323,dictGetDoubleVal,1,dictGetDoubleVal,double dictGetDoubleVal (dictEntry*),dict.c,"double dictGetDoubleVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.d;
}",818.0,821.0,1.0,4.0,4.0,6,6,3,1,1,4,1,1,0,3,,0,1,2,1,1,double
3668,119351,dictGetDoubleValPtr,1,dictGetDoubleValPtr,double* dictGetDoubleValPtr (dictEntry*),dict.c,"double *dictGetDoubleValPtr(dictEntry *de) {
    assert(entryHasValue(de));
    return &de->v.d;
}",824.0,827.0,1.0,4.0,4.0,7,7,3,1,0,4,1,1,0,3,,0,1,2,1,1,double*
3669,119476,dictMemUsage,1,dictMemUsage,size_t dictMemUsage (dict*),dict.c,"size_t dictMemUsage(const dict *d) {
    return dictSize(d) * sizeof(dictEntry) +
        dictSlots(d) * sizeof(dictEntry*);
}",857.0,860.0,1.0,11.0,4.0,29,10,10,2,8,6,1,1,0,0,,0,6,2,1,1,size_t
3670,119545,dictEntryMemUsage,1,dictEntryMemUsage,size_t dictEntryMemUsage (void),dict.c,"size_t dictEntryMemUsage(void) {
    return sizeof(dictEntry);
}",862.0,864.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,size_t
3671,119553,dictFingerprint,1,dictFingerprint,unsigned long long dictFingerprint (dict*),dict.c,"unsigned long long dictFingerprint(dict *d) {
    unsigned long long integers[6], hash = 0;
    int j;

    integers[0] = (long) d->ht_table[0];
    integers[1] = d->ht_size_exp[0];
    integers[2] = d->ht_used[0];
    integers[3] = (long) d->ht_table[1];
    integers[4] = d->ht_size_exp[1];
    integers[5] = d->ht_used[1];

    /* We hash N integers by summing every successive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result = hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in a different order will (likely) hash
     * to a different number. */
    for (j = 0; j < 6; j++) {
        hash += integers[j];
        /* For the hashing step we use Tomas Wang's 64 bit integer hash. */
        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1;
        hash = hash ^ (hash >> 24);
        hash = (hash + (hash << 3)) + (hash << 8); // hash * 265
        hash = hash ^ (hash >> 14);
        hash = (h...",872.0,902.0,1.0,1.0,31.0,57,11,42,4,0,6,2,2,0,0,,0,6,2,1,1,unsigned long long
3672,119698,dictInitIterator,1,dictInitIterator,"void dictInitIterator (dictIterator*,dict*)",dict.c,"void dictInitIterator(dictIterator *iter, dict *d)
{
    iter->d = d;
    iter->table = 0;
    iter->index = -1;
    iter->safe = 0;
    iter->entry = NULL;
    iter->nextEntry = NULL;
}",904.0,912.0,1.0,1.0,9.0,13,3,9,3,2,6,1,1,0,0,,0,6,4,2,2,void
3673,119735,dictInitSafeIterator,1,dictInitSafeIterator,"void dictInitSafeIterator (dictIterator*,dict*)",dict.c,"void dictInitSafeIterator(dictIterator *iter, dict *d)
{
    dictInitIterator(iter, d);
    iter->safe = 1;
}",914.0,918.0,1.0,1.0,5.0,2,2,3,2,0,2,1,1,0,1,,0,1,4,2,2,void
3674,119749,dictResetIterator,1,dictResetIterator,void dictResetIterator (dictIterator*),dict.c,"void dictResetIterator(dictIterator *iter)
{
    if (!(iter->index == -1 && iter->table == 0)) {
        if (iter->safe)
            dictResumeRehashing(iter->d);
        else
            assert(iter->fingerprint == dictFingerprint(iter->d));
    }
}",920.0,928.0,1.0,12.0,9.0,12,6,5,1,1,5,3,4,3,0,,0,5,2,1,1,void
3675,119808,dictGetIterator,1,dictGetIterator,dictIterator dictGetIterator (dict*),dict.c,"dictIterator *dictGetIterator(dict *d)
{
    dictIterator *iter = zmalloc(sizeof(*iter));
    dictInitIterator(iter, d);
    return iter;
}",930.0,935.0,1.0,1.0,6.0,3,3,5,2,77,2,1,1,0,2,,0,1,2,1,1,dictIterator
3676,119825,dictGetSafeIterator,1,dictGetSafeIterator,dictIterator dictGetSafeIterator (dict*),dict.c,"dictIterator *dictGetSafeIterator(dict *d) {
    dictIterator *i = dictGetIterator(d);

    i->safe = 1;
    return i;
}",937.0,942.0,1.0,1.0,6.0,3,2,4,2,36,2,1,1,0,1,,0,2,2,1,1,dictIterator
3677,119842,dictNext,1,dictNext,dictEntry dictNext (dictIterator*),dict.c,"dictEntry *dictNext(dictIterator *iter)
{
    while (1) {
        if (iter->entry == NULL) {
            if (iter->index == -1 && iter->table == 0) {
                if (iter->safe)
                    dictPauseRehashing(iter->d);
                else
                    iter->fingerprint = dictFingerprint(iter->d);
            }
            iter->index++;
            if (iter->index >= (long) DICTHT_SIZE(iter->d->ht_size_exp[iter->table])) {
                if (dictIsRehashing(iter->d) && iter->table == 0) {
                    iter->table++;
                    iter->index = 0;
                } else {
                    break;
                }
            }
            iter->entry = iter->d->ht_table[iter->table][iter->index];
        } else {
            iter->entry = iter->nextEntry;
        }
        if (iter->entry) {
            /* We need to save the 'next' here, the iterator user
             * may delete the entry we are returning. */
            iter->nextEntry = dictG...",944.0,975.0,1.0,20.0,32.0,60,12,29,2,112,28,8,20,15,1,,0,28,2,1,1,dictEntry
3678,120025,dictReleaseIterator,1,dictReleaseIterator,void dictReleaseIterator (dictIterator*),dict.c,"void dictReleaseIterator(dictIterator *iter)
{
    dictResetIterator(iter);
    zfree(iter);
}",977.0,981.0,1.0,1.0,5.0,0,0,2,1,124,2,1,1,0,2,,0,0,2,1,1,void
3679,120034,dictGetRandomKey,1,dictGetRandomKey,dictEntry dictGetRandomKey (dict*),dict.c,"dictEntry *dictGetRandomKey(dict *d)
{
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;
    if (dictIsRehashing(d)) _dictRehashStep(d);
    if (dictIsRehashing(d)) {
        unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);
        do {
            /* We are sure there are no elements in indexes from 0
             * to rehashidx-1 */
            h = d->rehashidx + (randomULong() % (dictSlots(d) - d->rehashidx));
            he = (h >= s0) ? d->ht_table[1][h - s0] : d->ht_table[0][h];
        } while(he == NULL);
    } else {
        unsigned long m = DICTHT_SIZE_MASK(d->ht_size_exp[0]);
        do {
            h = randomULong() & m;
            he = d->ht_table[0][h];
        } while(he == NULL);
    }

    /* Now we found a non empty bucket, but it is a linked
     * list and we need to get a random element from the list.
     * The only sane way to do so is counting the elements and
     * select a random index. ...",985.0,1023.0,1.0,8.0,39.0,69,15,44,8,4,18,7,8,4,3,,0,17,2,1,1,dictEntry
3680,120300,dictGetSomeKeys,1,dictGetSomeKeys,"unsigned int dictGetSomeKeys (dict*,dictEntry**,unsigned int)",dict.c,"unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {
    unsigned long j; /* internal hash table id, 0 or 1. */
    unsigned long tables; /* 1 or 2 tables? */
    unsigned long stored = 0, maxsizemask;
    unsigned long maxsteps;

    if (dictSize(d) < count) count = dictSize(d);
    maxsteps = count*10;

    /* Try to do a rehashing work proportional to 'count'. */
    for (j = 0; j < count; j++) {
        if (dictIsRehashing(d))
            _dictRehashStep(d);
        else
            break;
    }

    tables = dictIsRehashing(d) ? 2 : 1;
    maxsizemask = DICTHT_SIZE_MASK(d->ht_size_exp[0]);
    if (tables > 1 && maxsizemask < DICTHT_SIZE_MASK(d->ht_size_exp[1]))
        maxsizemask = DICTHT_SIZE_MASK(d->ht_size_exp[1]);

    /* Pick a random point inside the larger table. */
    unsigned long i = randomULong() & maxsizemask;
    unsigned long emptylen = 0; /* Continuous empty entries so far. */
    while(stored < count && maxsteps--) {
        for (j = 0;...",1047.0,1125.0,1.0,8.0,79.0,141,19,82,11,2,30,13,26,14,3,,0,29,6,3,3,unsigned int
3681,120747,dictDefragBucket,1,dictDefragBucket,"void dictDefragBucket (dict*,dictEntry**,dictDefragFunctions*)",dict.c,"static void dictDefragBucket(dict *d, dictEntry **bucketref, dictDefragFunctions *defragfns) {
    dictDefragAllocFunction *defragalloc = defragfns->defragAlloc;
    dictDefragAllocFunction *defragkey = defragfns->defragKey;
    dictDefragAllocFunction *defragval = defragfns->defragVal;
    while (bucketref && *bucketref) {
        dictEntry *de = *bucketref, *newde = NULL;
        void *newkey = defragkey ? defragkey(dictGetKey(de)) : NULL;
        void *newval = defragval ? defragval(dictGetVal(de)) : NULL;
        if (entryIsKey(de)) {
            if (newkey) *bucketref = newkey;
            assert(entryIsKey(*bucketref));
        } else if (entryIsNoValue(de)) {
            dictEntryNoValue *entry = decodeEntryNoValue(de), *newentry;
            if ((newentry = defragalloc(entry))) {
                newde = encodeMaskedPtr(newentry, ENTRY_PTR_NO_VALUE);
                entry = newentry;
            }
            if (newkey) entry->key = newkey;
        } else {
            asser...",1130.0,1162.0,1.0,12.0,33.0,31,8,35,11,1,13,6,12,2,8,,0,9,6,3,3,void
3682,120945,dictGetFairRandomKey,1,dictGetFairRandomKey,dictEntry dictGetFairRandomKey (dict*),dict.c,"dictEntry *dictGetFairRandomKey(dict *d) {
    dictEntry *entries[GETFAIR_NUM_ENTRIES];
    unsigned int count = dictGetSomeKeys(d,entries,GETFAIR_NUM_ENTRIES);
    /* Note that dictGetSomeKeys() may return zero elements in an unlucky
     * run() even if there are actually elements inside the hash table. So
     * when we get zero, we call the true dictGetRandomKey() that will always
     * yield the element if the hash table has at least one. */
    if (count == 0) return dictGetRandomKey(d);
    unsigned int idx = rand() % count;
    return entries[idx];
}",1176.0,1186.0,1.0,23.0,11.0,5,4,9,4,8,2,2,2,0,2,,0,1,2,1,1,dictEntry
3683,120978,rev,1,rev,unsigned long rev (long unsigned),dict.c,"static unsigned long rev(unsigned long v) {
    unsigned long s = CHAR_BIT * sizeof(v); // bit size; must be power of 2
    unsigned long mask = ~0UL;
    while ((s >>= 1) > 0) {
        mask ^= (mask << s);
        v = ((v >> s) & mask) | ((v << s) & ~mask);
    }
    return v;
}",1190.0,1198.0,1.0,1.0,9.0,14,9,16,4,2,0,2,2,0,0,,0,0,2,1,1,unsigned long
3684,121023,dictScan,1,dictScan,"unsigned long dictScan (dict*,long unsigned,dictScanFunction*,void*)",dict.c,"unsigned long dictScan(dict *d,
                       unsigned long v,
                       dictScanFunction *fn,
                       void *privdata)
{
    return dictScanDefrag(d, v, fn, NULL, privdata);
}",1284.0,1290.0,1.0,1.0,7.0,0,0,5,5,4,1,1,1,0,1,,0,0,8,4,4,unsigned long
3685,121038,dictScanDefrag,1,dictScanDefrag,"unsigned long dictScanDefrag (dict*,long unsigned,dictScanFunction*,dictDefragFunctions*,void*)",dict.c,"unsigned long dictScanDefrag(dict *d,
                             unsigned long v,
                             dictScanFunction *fn,
                             dictDefragFunctions *defragfns,
                             void *privdata)
{
    int htidx0, htidx1;
    const dictEntry *de, *next;
    unsigned long m0, m1;

    if (dictSize(d) == 0) return 0;

    /* This is needed in case the scan callback tries to do dictFind or alike. */
    dictPauseRehashing(d);

    if (!dictIsRehashing(d)) {
        htidx0 = 0;
        m0 = DICTHT_SIZE_MASK(d->ht_size_exp[htidx0]);

        /* Emit entries at cursor */
        if (defragfns) {
            dictDefragBucket(d, &d->ht_table[htidx0][v & m0], defragfns);
        }
        de = d->ht_table[htidx0][v & m0];
        while (de) {
            next = dictGetNext(de);
            fn(privdata, de);
            de = next;
        }

        /* Set unmasked bits so incrementing the reversed cursor
         * operates on the masked bits */
 ...",1300.0,1390.0,1.0,8.0,91.0,49,17,46,8,1,15,5,7,3,4,,0,14,10,5,5,unsigned long
3686,121448,dictTypeExpandAllowed,1,dictTypeExpandAllowed,int dictTypeExpandAllowed (dict*),dict.c,"static int dictTypeExpandAllowed(dict *d) {
    if (d->type->expandAllowed == NULL) return 1;
    return d->type->expandAllowed(
                    DICTHT_SIZE(_dictNextExp(d->ht_used[0] + 1)) * sizeof(dictEntry*),
                    (double)d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]));
}",1397.0,1402.0,1.0,20.0,6.0,33,11,10,3,0,11,2,2,1,3,,0,10,2,1,1,int
3687,121732,dictFindPositionForInsert,1,dictFindPositionForInsert,"void* dictFindPositionForInsert (dict*,void*,dictEntry**)",dict.c,"void *dictFindPositionForInsert(dict *d, const void *key, dictEntry **existing) {
    unsigned long idx, table;
    dictEntry *he;
    uint64_t hash = dictHashKey(d, key);
    if (existing) *existing = NULL;
    if (dictIsRehashing(d)) _dictRehashStep(d);

    /* Expand the hash table if needed */
    if (_dictExpandIfNeeded(d) == DICT_ERR)
        return NULL;
    for (table = 0; table <= 1; table++) {
        idx = hash & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        /* Search if this slot does not already contain the given key */
        he = d->ht_table[table][idx];
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key)) {
                if (existing) *existing = he;
                return NULL;
            }
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) break;
    }

    /* If we are in the process of rehashing the hash table, the bucket is
     * always returned in the c...",1447.0,1476.0,1.0,20.0,30.0,59,16,58,10,1,16,10,16,5,4,,0,15,6,3,3,void*
3688,121935,dictEmpty,1,dictEmpty,"void dictEmpty (dict*,void)",dict.c,"void dictEmpty(dict *d, void(callback)(dict*)) {
    _dictClear(d,0,callback);
    _dictClear(d,1,callback);
    d->rehashidx = -1;
    d->pauserehash = 0;
}",1478.0,1483.0,1.0,1.0,6.0,5,3,6,2,4,4,1,1,0,2,,0,2,4,2,2,void
3689,121960,dictSetResizeEnabled,1,dictSetResizeEnabled,void dictSetResizeEnabled (dictResizeEnable),dict.c,"void dictSetResizeEnabled(dictResizeEnable enable) {
    dict_can_resize = enable;
}",1485.0,1487.0,1.0,1.0,3.0,1,1,2,2,1,1,1,1,0,0,,0,1,2,1,1,void
3690,121968,dictGetHash,1,dictGetHash,"uint64_t dictGetHash (dict*,void*)",dict.c,"uint64_t dictGetHash(dict *d, const void *key) {
    return dictHashKey(d, key);
}",1489.0,1491.0,1.0,11.0,3.0,2,1,4,2,0,1,1,1,0,0,,0,1,4,2,2,uint64_t
3691,121986,dictFindEntryByPtrAndHash,1,dictFindEntryByPtrAndHash,"dictEntry dictFindEntryByPtrAndHash (dict*,void*,uint64_t)",dict.c,"dictEntry *dictFindEntryByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {
    dictEntry *he;
    unsigned long idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    for (table = 0; table <= 1; table++) {
        idx = hash & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        while(he) {
            if (oldptr == dictGetKey(he))
                return he;
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",1498.0,1514.0,1.0,8.0,17.0,37,14,30,7,0,10,6,10,4,2,,0,10,6,3,3,dictEntry
3692,122109,_dictGetStatsHt,1,_dictGetStatsHt,"size_t _dictGetStatsHt (char*,size_t,dict*,int,int)",dict.c,"size_t _dictGetStatsHt(char *buf, size_t bufsize, dict *d, int htidx, int full) {
    unsigned long i, slots = 0, chainlen, maxchainlen = 0;
    unsigned long totchainlen = 0;
    unsigned long clvector[DICT_STATS_VECTLEN];
    size_t l = 0;

    if (d->ht_used[htidx] == 0) {
        return snprintf(buf,bufsize,
            ""Hash table %d stats (%s):\n""
            ""No stats available for empty dictionaries\n"",
            htidx, (htidx == 0) ? ""main hash table"" : ""rehashing target"");
    }

    if (!full) {
        l += snprintf(buf+l,bufsize-l,
            ""Hash table %d stats (%s):\n""
            "" table size: %lu\n""
            "" number of elements: %lu\n"",
            htidx, (htidx == 0) ? ""main hash table"" : ""rehashing target"",
            DICTHT_SIZE(d->ht_size_exp[htidx]), d->ht_used[htidx]);

        /* Make sure there is a NULL term at the end. */
        buf[bufsize-1] = '\0';
        /* Unlike snprintf(), return the number of characters actually written. */
        retur...",1519.0,1594.0,1.0,27.0,76.0,120,18,110,14,2,19,14,16,5,1,,0,19,10,5,5,size_t
3693,122490,dictGetStats,1,dictGetStats,"void dictGetStats (char*,size_t,dict*,int)",dict.c,"void dictGetStats(char *buf, size_t bufsize, dict *d, int full) {
    size_t l;
    char *orig_buf = buf;
    size_t orig_bufsize = bufsize;

    l = _dictGetStatsHt(buf,bufsize,d,0,full);
    if (dictIsRehashing(d) && bufsize > l) {
        buf += l;
        bufsize -= l;
        _dictGetStatsHt(buf,bufsize,d,1,full);
    }
    /* Make sure there is a NULL term at the end. */
    orig_buf[orig_bufsize-1] = '\0';
}",1596.0,1609.0,1.0,8.0,14.0,13,10,23,7,0,3,2,2,1,2,,0,2,8,4,4,void
3694,122567,hashFunction,1,dictType.hashFunction,uint64_t dictType.hashFunction (void*),dict.h,uint64_t (*hashFunction)(const void *key);,52.0,52.0,14.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
3695,122572,keyDup,1,dictType.keyDup,"void* dictType.keyDup (dict*,void*)",dict.h,"void *(*keyDup)(dict *d, const void *key);",53.0,53.0,10.0,45.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void*
3696,122578,valDup,1,dictType.valDup,"void* dictType.valDup (dict*,void*)",dict.h,"void *(*valDup)(dict *d, const void *obj);",54.0,54.0,10.0,45.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void*
3697,122584,keyCompare,1,dictType.keyCompare,"int dictType.keyCompare (dict*,void*,void*)",dict.h,"int (*keyCompare)(dict *d, const void *key1, const void *key2);",55.0,55.0,9.0,66.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
3698,122591,keyDestructor,1,dictType.keyDestructor,"void dictType.keyDestructor (dict*,void*)",dict.h,"void (*keyDestructor)(dict *d, void *key);",56.0,56.0,10.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3699,122597,valDestructor,1,dictType.valDestructor,"void dictType.valDestructor (dict*,void*)",dict.h,"void (*valDestructor)(dict *d, void *obj);",57.0,57.0,10.0,45.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3700,122603,expandAllowed,1,dictType.expandAllowed,"int dictType.expandAllowed (size_t,double)",dict.h,"int (*expandAllowed)(size_t moreMem, double usedRatio);",58.0,58.0,9.0,58.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
3701,122611,dictEntryMetadataBytes,1,dictType.dictEntryMetadataBytes,size_t dictType.dictEntryMetadataBytes (dict*),dict.h,size_t (*dictEntryMetadataBytes)(dict *d);,74.0,74.0,12.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
3702,122616,dictMetadataBytes,1,dictType.dictMetadataBytes,size_t dictType.dictMetadataBytes (void),dict.h,size_t (*dictMetadataBytes)(void);,75.0,75.0,12.0,37.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
3703,122621,afterReplaceEntry,1,dictType.afterReplaceEntry,"void dictType.afterReplaceEntry (dict*,dictEntry*)",dict.h,"void (*afterReplaceEntry)(dict *d, dictEntry *entry);",78.0,78.0,10.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3704,122656,dictScanFunction,1,dictScanFunction,"void dictScanFunction (void*,dictEntry*)",dict.h,"typedef void (dictScanFunction)(void *privdata, const dictEntry *de);",114.0,114.0,14.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3705,122662,dictDefragAllocFunction,1,dictDefragAllocFunction,void* dictDefragAllocFunction (void*),dict.h,typedef void *(dictDefragAllocFunction)(void *ptr);,115.0,115.0,14.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
3706,123037,memrev16,1,memrev16,void memrev16 (void*),endianconv.c,"void memrev16(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[1];
    x[1] = t;
}",49.0,55.0,1.0,1.0,7.0,8,2,8,3,1,0,1,1,0,0,,0,0,2,1,1,void
3707,123064,memrev32,1,memrev32,void memrev32 (void*),endianconv.c,"void memrev32(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[3];
    x[3] = t;
    t = x[1];
    x[1] = x[2];
    x[2] = t;
}",59.0,68.0,1.0,1.0,10.0,15,2,14,3,5,0,1,1,0,0,,0,0,2,1,1,void
3708,123108,memrev64,1,memrev64,void memrev64 (void*),endianconv.c,"void memrev64(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[7];
    x[7] = t;
    t = x[1];
    x[1] = x[6];
    x[6] = t;
    t = x[2];
    x[2] = x[5];
    x[5] = t;
    t = x[3];
    x[3] = x[4];
    x[4] = t;
}",72.0,87.0,1.0,1.0,16.0,29,2,26,3,13,0,1,1,0,0,,0,0,2,1,1,void
3709,123186,intrev16,1,intrev16,uint16_t intrev16 (uint16_t),endianconv.c,"uint16_t intrev16(uint16_t v) {
    memrev16(&v);
    return v;
}",89.0,92.0,1.0,1.0,4.0,1,1,2,1,13,1,1,1,0,1,,0,0,2,1,1,uint16_t
3710,123196,intrev32,1,intrev32,uint32_t intrev32 (uint32_t),endianconv.c,"uint32_t intrev32(uint32_t v) {
    memrev32(&v);
    return v;
}",94.0,97.0,1.0,1.0,4.0,1,1,2,1,61,1,1,1,0,1,,0,0,2,1,1,uint32_t
3711,123206,intrev64,1,intrev64,uint64_t intrev64 (uint64_t),endianconv.c,"uint64_t intrev64(uint64_t v) {
    memrev64(&v);
    return v;
}",99.0,102.0,1.0,1.0,4.0,1,1,2,1,17,1,1,1,0,1,,0,0,2,1,1,uint64_t
3712,123284,ldbInit,1,ldbInit,void ldbInit (void),eval.c,"void ldbInit(void) {
    ldb.conn = NULL;
    ldb.active = 0;
    ldb.logs = listCreate();
    listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);
    ldb.children = listCreate();
    ldb.src = NULL;
    ldb.lines = 0;
    ldb.cbuf = sdsempty();
}",672.0,681.0,1.0,4.0,10.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
3713,123289,ldbDisable,1,ldbDisable,void ldbDisable (client*),eval.c,"void ldbDisable(client *c) {
    c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
}",712.0,714.0,1.0,18.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3714,123294,ldbEnable,1,ldbEnable,void ldbEnable (client*),eval.c,"void ldbEnable(client *c) {
    c->flags |= CLIENT_LUA_DEBUG;
    ldbFlushLog(ldb.logs);
    ldb.conn = c->conn;
    ldb.step = 1;
    ldb.bpcount = 0;
    ldb.luabp = 0;
    sdsfree(ldb.cbuf);
    ldb.cbuf = sdsempty();
    ldb.maxlen = LDB_MAX_LEN_DEFAULT;
    ldb.maxlen_hint_sent = 0;
}",696.0,707.0,1.0,16.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
3715,123299,evalGenericCommandWithDebugging,1,evalGenericCommandWithDebugging,"void evalGenericCommandWithDebugging (client*,int)",eval.c,"void evalGenericCommandWithDebugging(client *c, int evalsha) {
    if (ldbStartSession(c)) {
        evalGenericCommand(c,evalsha);
        ldbEndSession(c);
    } else {
        ldbDisable(c);
    }
}",891.0,898.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3716,123305,ldbCatStackValue,1,ldbCatStackValue,"sds ldbCatStackValue (sds,lua_State*,int)",eval.c,"sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
    return ldbCatStackValueRec(s,lua,idx,0);
}",1126.0,1128.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,sds
3717,123312,dictLuaScriptDestructor,1,dictLuaScriptDestructor,"void dictLuaScriptDestructor (dict*,void*)",eval.c,"static void dictLuaScriptDestructor(dict *d, void *val) {
    UNUSED(d);
    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
    decrRefCount(((luaScript*)val)->body);
    zfree(val);
}",50.0,55.0,1.0,4.0,6.0,4,3,6,3,0,2,2,2,0,2,,0,0,4,2,2,void
3718,123338,dictStrCaseHash,1,dictStrCaseHash,uint64_t dictStrCaseHash (void*),eval.c,"static uint64_t dictStrCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, strlen((char*)key));
}",57.0,59.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
3719,123395,sha1hex,1,sha1hex,"void sha1hex (char*,char*,size_t)",eval.c,"void sha1hex(char *digest, char *script, size_t len) {
    SHA1_CTX ctx;
    unsigned char hash[20];
    char *cset = ""0123456789abcdef"";
    int j;

    SHA1Init(&ctx);
    SHA1Update(&ctx,(unsigned char*)script,len);
    SHA1Final(hash,&ctx);

    for (j = 0; j < 20; j++) {
        digest[j*2] = cset[((hash[j]&0xF0)>>4)];
        digest[j*2+1] = cset[(hash[j]&0xF)];
    }
    digest[40] = '\0';
}",112.0,127.0,1.0,1.0,16.0,23,9,20,7,3,3,2,2,0,3,,0,0,6,3,3,void
3720,123469,luaRedisBreakpointCommand,1,luaRedisBreakpointCommand,int luaRedisBreakpointCommand (lua_State*),eval.c,"int luaRedisBreakpointCommand(lua_State *lua) {
    if (ldb.active) {
        ldb.luabp = 1;
        lua_pushboolean(lua,1);
    } else {
        lua_pushboolean(lua,0);
    }
    return 1;
}",134.0,142.0,1.0,1.0,9.0,3,2,3,2,0,4,2,2,2,0,,0,4,2,1,1,int
3721,123494,luaRedisDebugCommand,1,luaRedisDebugCommand,int luaRedisDebugCommand (lua_State*),eval.c,"int luaRedisDebugCommand(lua_State *lua) {
    if (!ldb.active) return 0;
    int argc = lua_gettop(lua);
    sds log = sdscatprintf(sdsempty(),""<debug> line %d: "", ldb.currentline);
    while(argc--) {
        log = ldbCatStackValue(log,lua,-1 - argc);
        if (argc != 0) log = sdscatlen(log,"", "",2);
    }
    ldbLog(log);
    return 0;
}",149.0,159.0,1.0,1.0,11.0,11,7,14,4,0,9,4,5,2,5,,0,8,2,1,1,int
3722,123549,luaRedisReplicateCommandsCommand,1,luaRedisReplicateCommandsCommand,int luaRedisReplicateCommandsCommand (lua_State*),eval.c,"int luaRedisReplicateCommandsCommand(lua_State *lua) {
    lua_pushboolean(lua,1);
    return 1;
}",168.0,171.0,1.0,1.0,4.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
3723,123559,scriptingInit,1,scriptingInit,void scriptingInit (int),eval.c,"void scriptingInit(int setup) {
    lua_State *lua = lua_open();

    if (setup) {
        lctx.lua_client = NULL;
        server.script_disable_deny_script = 0;
        ldbInit();
    }

    /* Initialize a dictionary we use to map SHAs to scripts.
     * This is useful for replication, as we need to replicate EVALSHA
     * as EVAL, so we need to remember the associated script. */
    lctx.lua_scripts = dictCreate(&shaScriptObjectDictType);
    lctx.lua_scripts_mem = 0;

    luaRegisterRedisAPI(lua);

    /* register debug commands */
    lua_getglobal(lua,""redis"");

    /* redis.breakpoint */
    lua_pushstring(lua,""breakpoint"");
    lua_pushcfunction(lua,luaRedisBreakpointCommand);
    lua_settable(lua,-3);

    /* redis.debug */
    lua_pushstring(lua,""debug"");
    lua_pushcfunction(lua,luaRedisDebugCommand);
    lua_settable(lua,-3);

    /* redis.replicate_commands */
    lua_pushstring(lua, ""replicate_commands"");
    lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);
...",183.0,265.0,1.0,34.0,83.0,26,7,38,8,2,23,3,3,2,6,,0,19,2,1,1,void
3724,123698,scriptingRelease,1,scriptingRelease,void scriptingRelease (int),eval.c,"void scriptingRelease(int async) {
    if (async)
        freeLuaScriptsAsync(lctx.lua_scripts);
    else
        dictRelease(lctx.lua_scripts);
    lctx.lua_scripts_mem = 0;
    lua_close(lctx.lua);
}",269.0,276.0,1.0,1.0,8.0,4,2,4,2,1,7,2,2,0,1,,0,6,2,1,1,void
3725,123725,scriptingReset,1,scriptingReset,void scriptingReset (int),eval.c,"void scriptingReset(int async) {
    scriptingRelease(async);
    scriptingInit(0);
}",278.0,281.0,1.0,1.0,4.0,0,0,1,1,0,2,1,1,0,2,,0,0,2,1,1,void
3726,123734,evalCalcFunctionName,1,evalCalcFunctionName,"void evalCalcFunctionName (int,sds,char*)",eval.c,"static void evalCalcFunctionName(int evalsha, sds script, char *out_funcname) {
    /* We obtain the script SHA1, then check if this function is already
     * defined into the Lua state */
    out_funcname[0] = 'f';
    out_funcname[1] = '_';
    if (!evalsha) {
        /* Hash the code if this is an EVAL call */
        sha1hex(out_funcname+2,script,sdslen(script));
    } else {
        /* We already have the SHA if it is an EVALSHA */
        int j;
        char *sha = script;

        /* Convert to lowercase. We don't use tolower since the function
         * managed to always show up in the profiler output consuming
         * a non trivial amount of time. */
        for (j = 0; j < 40; j++)
            out_funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?
                sha[j]+('a'-'A') : sha[j];
        out_funcname[42] = '\0';
    }
}",287.0,308.0,1.0,1.0,22.0,6,4,6,3,1,2,2,2,0,2,,0,1,6,3,3,void
3727,123812,evalExtractShebangFlags,1,evalExtractShebangFlags,"int evalExtractShebangFlags (sds,uint64_t*,ssize_t*,sds*)",eval.c,"int evalExtractShebangFlags(sds body, uint64_t *out_flags, ssize_t *out_shebang_len, sds *err) {
    ssize_t shebang_len = 0;
    uint64_t script_flags = SCRIPT_FLAG_EVAL_COMPAT_MODE;
    if (!strncmp(body, ""#!"", 2)) {
        int numparts,j;
        char *shebang_end = strchr(body, '\n');
        if (shebang_end == NULL) {
            if (err)
                *err = sdsnew(""Invalid script shebang"");
            return C_ERR;
        }
        shebang_len = shebang_end - body;
        sds shebang = sdsnewlen(body, shebang_len);
        sds *parts = sdssplitargs(shebang, &numparts);
        sdsfree(shebang);
        if (!parts || numparts == 0) {
            if (err)
                *err = sdsnew(""Invalid engine in script shebang"");
            sdsfreesplitres(parts, numparts);
            return C_ERR;
        }
        /* Verify lua interpreter was specified */
        if (strcmp(parts[0], ""#!lua"")) {
            if (err)
                *err = sdscatfmt(sdsempty(), ""Unexpected eng...",315.0,378.0,1.0,28.0,64.0,55,13,74,17,2,22,17,49,3,18,,0,14,8,4,4,int
3728,124099,evalGetCommandFlags,1,evalGetCommandFlags,"uint64_t evalGetCommandFlags (client*,uint64_t)",eval.c,"uint64_t evalGetCommandFlags(client *c, uint64_t cmd_flags) {
    char funcname[43];
    int evalsha = c->cmd->proc == evalShaCommand || c->cmd->proc == evalShaRoCommand;
    if (evalsha && sdslen(c->argv[1]->ptr) != 40)
        return cmd_flags;
    uint64_t script_flags;
    evalCalcFunctionName(evalsha, c->argv[1]->ptr, funcname);
    char *lua_cur_script = funcname + 2;
    c->cur_script = dictFind(lctx.lua_scripts, lua_cur_script);
    if (!c->cur_script) {
        if (evalsha)
            return cmd_flags;
        if (evalExtractShebangFlags(c->argv[1]->ptr, &script_flags, NULL, NULL) == C_ERR)
            return cmd_flags;
    } else {
        luaScript *l = dictGetVal(c->cur_script);
        script_flags = l->flags;
    }
    if (script_flags & SCRIPT_FLAG_EVAL_COMPAT_MODE)
        return cmd_flags;
    return scriptFlagsToCmdFlags(cmd_flags, script_flags);
}",382.0,403.0,1.0,83.0,22.0,31,14,27,9,0,14,6,8,5,5,,0,12,4,2,2,uint64_t
3729,124227,luaCreateFunction,1,luaCreateFunction,"sds luaCreateFunction (client*,robj*)",eval.c,"sds luaCreateFunction(client *c, robj *body) {
    char funcname[43];
    dictEntry *de;
    uint64_t script_flags;

    funcname[0] = 'f';
    funcname[1] = '_';
    sha1hex(funcname+2,body->ptr,sdslen(body->ptr));

    if ((de = dictFind(lctx.lua_scripts,funcname+2)) != NULL) {
        return dictGetKey(de);
    }

    /* Handle shebang header in script code */
    ssize_t shebang_len = 0;
    sds err = NULL;
    if (evalExtractShebangFlags(body->ptr, &script_flags, &shebang_len, &err) == C_ERR) {
        addReplyErrorSds(c, err);
        return NULL;
    }

    /* Note that in case of a shebang line we skip it but keep the line feed to conserve the user's line numbers */
    if (luaL_loadbuffer(lctx.lua,(char*)body->ptr + shebang_len,sdslen(body->ptr) - shebang_len,""@user_script"")) {
        if (c != NULL) {
            addReplyErrorFormat(c,
                ""Error compiling script (new function): %s"",
                lua_tostring(lctx.lua,-1));
        }
        lua_pop(lctx.lua...",422.0,470.0,1.0,81.0,49.0,56,16,58,14,1,36,5,6,7,16,,0,27,4,2,2,sds
3730,124439,evalGenericCommand,1,evalGenericCommand,"void evalGenericCommand (client*,int)",eval.c,"void evalGenericCommand(client *c, int evalsha) {
    lua_State *lua = lctx.lua;
    char funcname[43];
    long long numkeys;

    /* Get the number of arguments that are keys */
    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)
        return;
    if (numkeys > (c->argc - 3)) {
        addReplyError(c,""Number of keys can't be greater than number of args"");
        return;
    } else if (numkeys < 0) {
        addReplyError(c,""Number of keys can't be negative"");
        return;
    }

    if (c->cur_script) {
        funcname[0] = 'f', funcname[1] = '_';
        memcpy(funcname+2, dictGetKey(c->cur_script), 40);
        funcname[42] = '\0';
    } else
        evalCalcFunctionName(evalsha, c->argv[1]->ptr, funcname);

    /* Push the pcall error handler function on the stack. */
    lua_getglobal(lua, ""__redis__err__handler"");

    /* Try to lookup the Lua function */
    lua_getfield(lua, LUA_REGISTRYINDEX, funcname);
    if (lua_isnil(lua,-1)) {
        lua...",472.0,539.0,1.0,68.0,68.0,63,18,65,15,2,32,9,11,10,11,,0,26,4,2,2,void
3731,124712,evalCommand,1,evalCommand,void evalCommand (client*),eval.c,"void evalCommand(client *c) {
    /* Explicitly feed monitor here so that lua commands appear after their
     * script command. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
    if (!(c->flags & CLIENT_LUA_DEBUG))
        evalGenericCommand(c,0);
    else
        evalGenericCommandWithDebugging(c,0);
}",541.0,549.0,1.0,21.0,9.0,9,5,7,2,1,6,2,2,1,2,,0,4,2,1,1,void
3732,124753,evalRoCommand,1,evalRoCommand,void evalRoCommand (client*),eval.c,"void evalRoCommand(client *c) {
    evalCommand(c);
}",551.0,553.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3733,124760,evalShaCommand,1,evalShaCommand,void evalShaCommand (client*),eval.c,"void evalShaCommand(client *c) {
    /* Explicitly feed monitor here so that lua commands appear after their
     * script command. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
    if (sdslen(c->argv[1]->ptr) != 40) {
        /* We know that a match is not possible if the provided SHA is
         * not the right length. So we return an error ASAP, this way
         * evalGenericCommand() can be implemented without string length
         * sanity check */
        addReplyErrorObject(c, shared.noscripterr);
        return;
    }
    if (!(c->flags & CLIENT_LUA_DEBUG))
        evalGenericCommand(c,1);
    else {
        addReplyError(c,""Please use EVAL instead of EVALSHA for debugging"");
        return;
    }
}",555.0,573.0,1.0,21.0,19.0,14,7,10,3,1,9,3,3,3,4,,0,6,2,1,1,void
3734,124820,evalShaRoCommand,1,evalShaRoCommand,void evalShaRoCommand (client*),eval.c,"void evalShaRoCommand(client *c) {
    evalShaCommand(c);
}",575.0,577.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3735,124827,scriptCommand,1,scriptCommand,void scriptCommand (client*),eval.c,"void scriptCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""DEBUG (YES|SYNC|NO)"",
""    Set the debug mode for subsequent scripts executed."",
""EXISTS <sha1> [<sha1> ...]"",
""    Return information about the existence of the scripts in the script cache."",
""FLUSH [ASYNC|SYNC]"",
""    Flush the Lua scripts cache. Very dangerous on replicas."",
""    When called without the optional mode argument, the behavior is determined by the"",
""    lazyfree-lazy-user-flush configuration directive. Valid modes are:"",
""    * ASYNC: Asynchronously flush the scripts cache."",
""    * SYNC: Synchronously flush the scripts cache."",
""KILL"",
""    Kill the currently executing Lua script."",
""LOAD <script>"",
""    Load a script into the scripts cache without executing it."",
NULL
        };
        addReplyHelp(c, help);
    } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,""flush"")) {
        int async = 0;
        if (c->argc == 3 && !strcasecm...",579.0,651.0,1.0,24.0,73.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
3736,125207,evalMemory,1,evalMemory,unsigned long evalMemory (void),eval.c,"unsigned long evalMemory(void) {
    return luaMemory(lctx.lua);
}",653.0,655.0,1.0,1.0,3.0,1,1,1,1,2,3,1,1,0,1,,0,2,2,1,1,unsigned long
3737,125217,evalScriptsDict,1,evalScriptsDict,dict evalScriptsDict (void),eval.c,"dict* evalScriptsDict(void) {
    return lctx.lua_scripts;
}",657.0,659.0,1.0,1.0,3.0,1,1,1,1,3,2,1,1,0,0,,0,2,2,1,1,dict
3738,125226,evalScriptsMemory,1,evalScriptsMemory,unsigned long evalScriptsMemory (void),eval.c,"unsigned long evalScriptsMemory(void) {
    return lctx.lua_scripts_mem +
            dictMemUsage(lctx.lua_scripts) +
            dictSize(lctx.lua_scripts) * sizeof(luaScript);
}",661.0,665.0,1.0,12.0,5.0,14,6,6,2,1,11,1,1,0,1,,0,10,2,1,1,unsigned long
3739,125318,ldbFlushLog,1,ldbFlushLog,void ldbFlushLog (list*),eval.c,"void ldbFlushLog(list *log) {
    listNode *ln;

    while((ln = listFirst(log)) != NULL)
        listDelNode(log,ln);
}",684.0,689.0,1.0,16.0,6.0,3,3,4,3,0,1,2,2,1,0,,0,1,2,1,1,void
3740,125338,ldbIsEnabled,1,ldbIsEnabled,int ldbIsEnabled (void),eval.c,"int ldbIsEnabled(void){
    return ldb.active && ldb.step;
}",691.0,693.0,1.0,1.0,3.0,3,2,2,1,3,4,1,1,0,0,,0,4,2,1,1,int
3741,125433,ldbLog,1,ldbLog,void ldbLog (sds),eval.c,"void ldbLog(sds entry) {
    listAddNodeTail(ldb.logs,entry);
}",717.0,719.0,1.0,1.0,3.0,1,1,2,2,45,3,1,1,0,1,,0,2,2,1,1,void
3742,125443,ldbLogWithMaxLen,1,ldbLogWithMaxLen,void ldbLogWithMaxLen (sds),eval.c,"void ldbLogWithMaxLen(sds entry) {
    int trimmed = 0;
    if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
        sdsrange(entry,0,ldb.maxlen-1);
        entry = sdscatlen(entry,"" ..."",4);
        trimmed = 1;
    }
    ldbLog(entry);
    if (trimmed && ldb.maxlen_hint_sent == 0) {
        ldb.maxlen_hint_sent = 1;
        ldbLog(sdsnew(
        ""<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming.""));
    }
}",725.0,738.0,1.0,1.0,14.0,14,6,13,3,2,16,3,3,7,6,,0,13,2,1,1,void
3743,125500,ldbSendLogs,1,ldbSendLogs,void ldbSendLogs (void),eval.c,"void ldbSendLogs(void) {
    sds proto = sdsempty();
    proto = sdscatfmt(proto,""*%i\r\n"", (int)listLength(ldb.logs));
    while(listLength(ldb.logs)) {
        listNode *ln = listFirst(ldb.logs);
        proto = sdscatlen(proto,""+"",1);
        sdsmapchars(ln->value,""\r\n"",""  "",2);
        proto = sdscatsds(proto,ln->value);
        proto = sdscatlen(proto,""\r\n"",2);
        listDelNode(ldb.logs,ln);
    }
    if (connWrite(ldb.conn,proto,sdslen(proto)) == -1) {
        /* Avoid warning. We don't check the return value of write()
         * since the next read() will catch the I/O error and will
         * close the debugging session. */
    }
    sdsfree(proto);
}",743.0,760.0,1.0,44.0,18.0,22,6,24,3,3,28,3,3,8,10,,0,25,2,1,1,void
3744,125596,ldbStartSession,1,ldbStartSession,int ldbStartSession (client*),eval.c,"int ldbStartSession(client *c) {
    ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;
    if (ldb.forked) {
        pid_t cp = redisFork(CHILD_TYPE_LDB);
        if (cp == -1) {
            addReplyErrorFormat(c,""Fork() failed: can't run EVAL in debugging mode: %s"", strerror(errno));
            return 0;
        } else if (cp == 0) {
            /* Child. Let's ignore important signals handled by the parent. */
            struct sigaction act;
            sigemptyset(&act.sa_mask);
            act.sa_flags = 0;
            act.sa_handler = SIG_IGN;
            sigaction(SIGTERM, &act, NULL);
            sigaction(SIGINT, &act, NULL);

            /* Log the creation of the child and close the listening
             * socket to make sure if the parent crashes a reset is sent
             * to the clients. */
            serverLog(LL_NOTICE,""Redis forked for debugging eval"");
        } else {
            /* Parent */
            listAddNodeTail(ldb.children,(void*)(unsigned lon...",774.0,823.0,1.0,29.0,50.0,34,13,28,6,0,26,4,5,2,10,,0,21,2,1,1,int
3745,125803,ldbEndSession,1,ldbEndSession,void ldbEndSession (client*),eval.c,"void ldbEndSession(client *c) {
    /* Emit the remaining logs and an <endsession> mark. */
    ldbLog(sdsnew(""<endsession>""));
    ldbSendLogs();

    /* If it's a fork()ed session, we just exit. */
    if (ldb.forked) {
        writeToClient(c,0);
        serverLog(LL_NOTICE,""Lua debugging session child exiting"");
        exitFromChild(0);
    } else {
        serverLog(LL_NOTICE,
            ""Redis synchronous debugging eval session ended"");
    }

    /* Otherwise let's restore client's state. */
    connNonBlock(ldb.conn);
    connSendTimeout(ldb.conn,0);

    /* Close the client connection after sending the final EVAL reply
     * in order to signal the end of the debugging session. */
    c->flags |= CLIENT_CLOSE_AFTER_REPLY;

    /* Cleanup. */
    sdsfreesplitres(ldb.src,ldb.lines);
    ldb.lines = 0;
    ldb.active = 0;
}",827.0,854.0,1.0,8.0,28.0,14,6,10,3,0,24,2,2,2,9,,0,16,2,1,1,void
3746,125895,ldbRemoveChild,1,ldbRemoveChild,int ldbRemoveChild (pid_t),eval.c,"int ldbRemoveChild(pid_t pid) {
    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);
    if (ln) {
        listDelNode(ldb.children,ln);
        return 1;
    }
    return 0;
}",859.0,866.0,1.0,1.0,8.0,5,3,6,3,0,6,2,2,0,2,,0,5,2,1,1,int
3747,125924,ldbPendingChildren,1,ldbPendingChildren,int ldbPendingChildren (void),eval.c,"int ldbPendingChildren(void) {
    return listLength(ldb.children);
}",870.0,872.0,1.0,11.0,3.0,3,2,2,1,1,4,1,1,0,0,,0,4,2,1,1,int
3748,125940,ldbKillForkedSessions,1,ldbKillForkedSessions,void ldbKillForkedSessions (void),eval.c,"void ldbKillForkedSessions(void) {
    listIter li;
    listNode *ln;

    listRewind(ldb.children,&li);
    while((ln = listNext(&li))) {
        pid_t pid = (unsigned long) ln->value;
        serverLog(LL_NOTICE,""Killing debugging session %ld"",(long)pid);
        kill(pid,SIGKILL);
    }
    listRelease(ldb.children);
    ldb.children = listCreate();
}",875.0,887.0,1.0,8.0,13.0,14,7,12,6,0,12,2,2,1,5,,0,9,2,1,1,void
3749,126020,ldbGetSourceLine,1,ldbGetSourceLine,char* ldbGetSourceLine (int),eval.c,"char *ldbGetSourceLine(int line) {
    int idx = line-1;
    if (idx < 0 || idx >= ldb.lines) return ""<out of range source code line>"";
    return ldb.src[idx];
}",902.0,906.0,1.0,1.0,5.0,8,7,7,3,1,4,2,2,2,0,,0,4,2,1,1,char*
3750,126050,ldbIsBreakpoint,1,ldbIsBreakpoint,int ldbIsBreakpoint (int),eval.c,"int ldbIsBreakpoint(int line) {
    int j;

    for (j = 0; j < ldb.bpcount; j++)
        if (ldb.bp[j] == line) return 1;
    return 0;
}",909.0,915.0,1.0,1.0,7.0,3,3,3,2,3,2,2,2,2,0,,0,2,2,1,1,int
3751,126081,ldbAddBreakpoint,1,ldbAddBreakpoint,int ldbAddBreakpoint (int),eval.c,"int ldbAddBreakpoint(int line) {
    if (line <= 0 || line > ldb.lines) return 0;
    if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
        ldb.bp[ldb.bpcount++] = line;
        return 1;
    }
    return 0;
}",920.0,927.0,1.0,49.0,8.0,13,10,8,2,0,9,3,3,5,1,,0,9,2,1,1,int
3752,126126,ldbDelBreakpoint,1,ldbDelBreakpoint,int ldbDelBreakpoint (int),eval.c,"int ldbDelBreakpoint(int line) {
    int j;

    for (j = 0; j < ldb.bpcount; j++) {
        if (ldb.bp[j] == line) {
            ldb.bpcount--;
            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
            return 1;
        }
    }
    return 0;
}",931.0,942.0,1.0,1.0,12.0,15,8,13,3,0,12,3,4,4,0,,0,12,2,1,1,int
3753,126180,ldbReplParseCommand,1,ldbReplParseCommand,"sds ldbReplParseCommand (int*,char**)",eval.c,"sds *ldbReplParseCommand(int *argcp, char** err) {
    static char* protocol_error = ""protocol error"";
    sds *argv = NULL;
    int argc = 0;
    if (sdslen(ldb.cbuf) == 0) return NULL;

    /* Working on a copy is simpler in this case. We can modify it freely
     * for the sake of simpler parsing. */
    sds copy = sdsdup(ldb.cbuf);
    char *p = copy;

    /* This Redis protocol parser is a joke... just the simplest thing that
     * works in this context. It is also very forgiving regarding broken
     * protocol. */

    /* Seek and parse *<count>\r\n. */
    p = strchr(p,'*'); if (!p) goto protoerr;
    char *plen = p+1; /* Multi bulk len pointer. */
    p = strstr(p,""\r\n""); if (!p) goto keep_reading;
    *p = '\0'; p += 2;
    *argcp = atoi(plen);
    if (*argcp <= 0 || *argcp > 1024) goto protoerr;

    /* Parse each argument. */
    argv = zmalloc(sizeof(sds)*(*argcp));
    argc = 0;
    while(argc < *argcp) {
        /* reached the end but there should be more data to re...",947.0,998.0,1.0,1.0,52.0,62,17,64,12,1,12,21,18,4,8,,0,9,4,2,2,sds
3754,126396,ldbLogSourceLine,1,ldbLogSourceLine,void ldbLogSourceLine (int),eval.c,"void ldbLogSourceLine(int lnum) {
    char *line = ldbGetSourceLine(lnum);
    char *prefix;
    int bp = ldbIsBreakpoint(lnum);
    int current = ldb.currentline == lnum;

    if (current && bp)
        prefix = ""->#"";
    else if (current)
        prefix = ""-> "";
    else if (bp)
        prefix = ""  #"";
    else
        prefix = ""   "";
    sds thisline = sdscatprintf(sdsempty(),""%s%-3d %s"", prefix, lnum, line);
    ldbLog(thisline);
}",1001.0,1017.0,1.0,1.0,17.0,8,4,15,7,3,7,2,2,0,5,,0,6,2,1,1,void
3755,126460,ldbList,1,ldbList,"void ldbList (int,int)",eval.c,"void ldbList(int around, int context) {
    int j;

    for (j = 1; j <= ldb.lines; j++) {
        if (around != 0 && abs(around-j) > context) continue;
        ldbLogSourceLine(j);
    }
}",1024.0,1031.0,1.0,1.0,8.0,7,7,8,4,0,3,4,4,2,1,,0,2,4,2,2,void
3756,126495,ldbCatStackValueRec,1,ldbCatStackValueRec,"sds ldbCatStackValueRec (sds,lua_State*,int,int)",eval.c,"sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
    int t = lua_type(lua,idx);

    if (level++ == LDB_MAX_VALUES_DEPTH)
        return sdscat(s,""<max recursion level reached! Nested table?>"");

    switch(t) {
    case LUA_TSTRING:
        {
        size_t strl;
        char *strp = (char*)lua_tolstring(lua,idx,&strl);
        s = sdscatrepr(s,strp,strl);
        }
        break;
    case LUA_TBOOLEAN:
        s = sdscat(s,lua_toboolean(lua,idx) ? ""true"" : ""false"");
        break;
    case LUA_TNUMBER:
        s = sdscatprintf(s,""%g"",(double)lua_tonumber(lua,idx));
        break;
    case LUA_TNIL:
        s = sdscatlen(s,""nil"",3);
        break;
    case LUA_TTABLE:
        {
        int expected_index = 1; /* First index we expect in an array. */
        int is_array = 1; /* Will be set to null if check fails. */
        /* Note: we create two representations at the same time, one
         * assuming the table is an array, one assuming it is not. At the
     ...",1041.0,1122.0,1.0,19.0,82.0,48,12,98,23,0,22,15,14,2,22,,0,17,8,4,4,sds
3757,126813,ldbLogStackValue,1,ldbLogStackValue,"void ldbLogStackValue (lua_State*,char*)",eval.c,"void ldbLogStackValue(lua_State *lua, char *prefix) {
    sds s = sdsnew(prefix);
    s = ldbCatStackValue(s,lua,-1);
    ldbLogWithMaxLen(s);
}",1133.0,1137.0,1.0,1.0,5.0,3,2,6,3,4,3,1,1,0,3,,0,2,4,2,2,void
3758,126833,ldbRedisProtocolToHuman_Int,1,ldbRedisProtocolToHuman_Int,"char* ldbRedisProtocolToHuman_Int (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,reply+1,p-reply-1);
    return p+2;
}",1174.0,1178.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3759,126839,ldbRedisProtocolToHuman_Bulk,1,ldbRedisProtocolToHuman_Bulk,"char* ldbRedisProtocolToHuman_Bulk (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long bulklen;

    string2ll(reply+1,p-reply-1,&bulklen);
    if (bulklen == -1) {
        *o = sdscatlen(*o,""NULL"",4);
        return p+2;
    } else {
        *o = sdscatrepr(*o,p+2,bulklen);
        return p+2+bulklen+2;
    }
}",1180.0,1192.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3760,126845,ldbRedisProtocolToHuman_Status,1,ldbRedisProtocolToHuman_Status,"char* ldbRedisProtocolToHuman_Status (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');

    *o = sdscatrepr(*o,reply,p-reply);
    return p+2;
}",1194.0,1199.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,char*
3761,126851,ldbRedisProtocolToHuman_MultiBulk,1,ldbRedisProtocolToHuman_MultiBulk,"char* ldbRedisProtocolToHuman_MultiBulk (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    if (mbulklen == -1) {
        *o = sdscatlen(*o,""NULL"",4);
        return p;
    }
    *o = sdscatlen(*o,""["",1);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,""]"",1);
    return p;
}",1201.0,1219.0,1.0,1.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3762,126857,ldbRedisProtocolToHuman_Set,1,ldbRedisProtocolToHuman_Set,"char* ldbRedisProtocolToHuman_Set (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Set(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    *o = sdscatlen(*o,""~("",2);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,"")"",1);
    return p;
}",1221.0,1235.0,1.0,1.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3763,126863,ldbRedisProtocolToHuman_Map,1,ldbRedisProtocolToHuman_Map,"char* ldbRedisProtocolToHuman_Map (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Map(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    *o = sdscatlen(*o,""{"",1);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        *o = sdscatlen(*o,"" => "",4);
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,""}"",1);
    return p;
}",1237.0,1253.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3764,126869,ldbRedisProtocolToHuman_Null,1,ldbRedisProtocolToHuman_Null,"char* ldbRedisProtocolToHuman_Null (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Null(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,""(null)"",6);
    return p+2;
}",1255.0,1259.0,1.0,1.0,5.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3765,126875,ldbRedisProtocolToHuman_Bool,1,ldbRedisProtocolToHuman_Bool,"char* ldbRedisProtocolToHuman_Bool (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Bool(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    if (reply[1] == 't')
        *o = sdscatlen(*o,""#true"",5);
    else
        *o = sdscatlen(*o,""#false"",6);
    return p+2;
}",1261.0,1268.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3766,126881,ldbRedisProtocolToHuman_Double,1,ldbRedisProtocolToHuman_Double,"char* ldbRedisProtocolToHuman_Double (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman_Double(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,""(double) "",9);
    *o = sdscatlen(*o,reply+1,p-reply-1);
    return p+2;
}",1270.0,1275.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char*
3767,126887,ldbRedisProtocolToHuman,1,ldbRedisProtocolToHuman,"char* ldbRedisProtocolToHuman (sds*,char*)",eval.c,"char *ldbRedisProtocolToHuman(sds *o, char *reply) {
    char *p = reply;
    switch(*p) {
    case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
    case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;
    case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;
    case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
    case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
    case '~': p = ldbRedisProtocolToHuman_Set(o,reply); break;
    case '%': p = ldbRedisProtocolToHuman_Map(o,reply); break;
    case '_': p = ldbRedisProtocolToHuman_Null(o,reply); break;
    case '#': p = ldbRedisProtocolToHuman_Bool(o,reply); break;
    case ',': p = ldbRedisProtocolToHuman_Double(o,reply); break;
    }
    return p;
}",1154.0,1169.0,1.0,1.0,16.0,12,2,34,3,1,10,12,2,0,10,,0,10,4,2,2,char*
3768,127491,ldbLogRedisReply,1,ldbLogRedisReply,void ldbLogRedisReply (char*),eval.c,"void ldbLogRedisReply(char *reply) {
    sds log = sdsnew(""<reply> "");
    ldbRedisProtocolToHuman(&log,reply);
    ldbLogWithMaxLen(log);
}",1280.0,1284.0,1.0,1.0,5.0,2,2,4,2,2,3,1,1,0,3,,0,1,2,1,1,void
3769,127507,ldbPrint,1,ldbPrint,"void ldbPrint (lua_State*,char*)",eval.c,"void ldbPrint(lua_State *lua, char *varname) {
    lua_Debug ar;

    int l = 0; /* Stack level. */
    while (lua_getstack(lua,l,&ar) != 0) {
        l++;
        const char *name;
        int i = 1; /* Variable index. */
        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
            i++;
            if (strcmp(varname,name) == 0) {
                ldbLogStackValue(lua,""<value> "");
                lua_pop(lua,1);
                return;
            } else {
                lua_pop(lua,1); /* Discard the var name on the stack. */
            }
        }
    }

    /* Let's try with global vars in two selected cases */
    if (!strcmp(varname,""ARGV"") || !strcmp(varname,""KEYS"")) {
        lua_getglobal(lua, varname);
        ldbLogStackValue(lua,""<value> "");
        lua_pop(lua,1);
    } else {
        ldbLog(sdsnew(""No such variable.""));
    }
}",1289.0,1317.0,1.0,1.0,29.0,13,7,22,7,0,2,5,8,0,2,,0,0,4,2,2,void
3770,127591,ldbPrintAll,1,ldbPrintAll,void ldbPrintAll (lua_State*),eval.c,"void ldbPrintAll(lua_State *lua) {
    lua_Debug ar;
    int vars = 0;

    if (lua_getstack(lua,0,&ar) != 0) {
        const char *name;
        int i = 1; /* Variable index. */
        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
            i++;
            if (!strstr(name,""(*temporary)"")) {
                sds prefix = sdscatprintf(sdsempty(),""<value> %s = "",name);
                ldbLogStackValue(lua,prefix);
                sdsfree(prefix);
                vars++;
            }
            lua_pop(lua,1);
        }
    }

    if (vars == 0) {
        ldbLog(sdsnew(""No local variables in the current context.""));
    }
}",1321.0,1343.0,1.0,1.0,23.0,12,6,19,7,0,6,5,8,0,6,,0,3,2,1,1,void
3771,127659,ldbBreak,1,ldbBreak,"void ldbBreak (sds*,int)",eval.c,"void ldbBreak(sds *argv, int argc) {
    if (argc == 1) {
        if (ldb.bpcount == 0) {
            ldbLog(sdsnew(""No breakpoints set. Use 'b <line>' to add one.""));
            return;
        } else {
            ldbLog(sdscatfmt(sdsempty(),""%i breakpoints set:"",ldb.bpcount));
            int j;
            for (j = 0; j < ldb.bpcount; j++)
                ldbLogSourceLine(ldb.bp[j]);
        }
    } else {
        int j;
        for (j = 1; j < argc; j++) {
            char *arg = argv[j];
            long line;
            if (!string2l(arg,sdslen(arg),&line)) {
                ldbLog(sdscatfmt(sdsempty(),""Invalid argument:'%s'"",arg));
            } else {
                if (line == 0) {
                    ldb.bpcount = 0;
                    ldbLog(sdsnew(""All breakpoints removed.""));
                } else if (line > 0) {
                    if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {
                        ldbLog(sdsnew(""Too many breakpoints set.""));
                    } ...",1346.0,1385.0,1.0,39.0,40.0,3,2,2,2,0,4,3,4,2,2,,0,3,4,2,2,void
3772,127812,ldbEval,1,ldbEval,"void ldbEval (lua_State*,sds*,int)",eval.c,"void ldbEval(lua_State *lua, sds *argv, int argc) {
    /* Glue the script together if it is composed of multiple arguments. */
    sds code = sdsjoinsds(argv+1,argc-1,"" "",1);
    sds expr = sdscatsds(sdsnew(""return ""),code);

    /* Try to compile it as an expression, prepending ""return "". */
    if (luaL_loadbuffer(lua,expr,sdslen(expr),""@ldb_eval"")) {
        lua_pop(lua,1);
        /* Failed? Try as a statement. */
        if (luaL_loadbuffer(lua,code,sdslen(code),""@ldb_eval"")) {
            ldbLog(sdscatfmt(sdsempty(),""<error> %s"",lua_tostring(lua,-1)));
            lua_pop(lua,1);
            sdsfree(code);
            sdsfree(expr);
            return;
        }
    }

    /* Call it. */
    sdsfree(code);
    sdsfree(expr);
    if (lua_pcall(lua,0,1,0)) {
        ldbLog(sdscatfmt(sdsempty(),""<error> %s"",lua_tostring(lua,-1)));
        lua_pop(lua,1);
        return;
    }
    ldbLogStackValue(lua,""<retval> "");
    lua_pop(lua,1);
}",1390.0,1418.0,1.0,1.0,29.0,6,4,23,5,0,16,4,5,2,16,,0,9,6,3,3,void
3773,127902,ldbRedis,1,ldbRedis,"void ldbRedis (lua_State*,sds*,int)",eval.c,"void ldbRedis(lua_State *lua, sds *argv, int argc) {
    int j;

    if (!lua_checkstack(lua, argc + 1)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 'argc + 1' elements to the stack. On failure, return error.
         * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments
         * given by the user (without the first argument) and we also push the 'redis' global table and
         * 'redis.call' function so:
         * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/
        ldbLogRedisReply(""max lua stack reached"");
        return;
    }

    lua_getglobal(lua,""redis"");
    lua_pushstring(lua,""call"");
    lua_gettable(lua,-2);       /* Stack: redis, redis.call */
    for (j = 1; j < argc; j++)
        lua_pushlstring(lua,argv[j],sdslen(argv[j]));
    ldb.step = 1;               /* Force redis.call() to log. */
    lua_pcall(lua,argc-...",1424.0,1447.0,1.0,1.0,24.0,10,7,13,4,0,5,3,3,0,1,,0,4,6,3,3,void
3774,127970,ldbTrace,1,ldbTrace,void ldbTrace (lua_State*),eval.c,"void ldbTrace(lua_State *lua) {
    lua_Debug ar;
    int level = 0;

    while(lua_getstack(lua,level,&ar)) {
        lua_getinfo(lua,""Snl"",&ar);
        if(strstr(ar.short_src,""user_script"") != NULL) {
            ldbLog(sdscatprintf(sdsempty(),""%s %s:"",
                (level == 0) ? ""In"" : ""From"",
                ar.name ? ar.name : ""top level""));
            ldbLogSourceLine(ar.currentline);
        }
        level++;
    }
    if (level == 0) {
        ldbLog(sdsnew(""<error> Can't retrieve Lua stack.""));
    }
}",1451.0,1468.0,1.0,1.0,18.0,13,7,14,4,0,6,4,5,0,6,,0,3,2,1,1,void
3775,128033,ldbMaxlen,1,ldbMaxlen,"void ldbMaxlen (sds*,int)",eval.c,"void ldbMaxlen(sds *argv, int argc) {
    if (argc == 2) {
        int newval = atoi(argv[1]);
        ldb.maxlen_hint_sent = 1; /* User knows about this command. */
        if (newval != 0 && newval <= 60) newval = 60;
        ldb.maxlen = newval;
    }
    if (ldb.maxlen) {
        ldbLog(sdscatprintf(sdsempty(),""<value> replies are truncated at %d bytes."",(int)ldb.maxlen));
    } else {
        ldbLog(sdscatprintf(sdsempty(),""<value> replies are unlimited.""));
    }
}",1472.0,1484.0,1.0,1.0,13.0,14,8,11,4,0,11,4,5,2,3,,0,10,4,2,2,void
3776,128093,ldbRepl,1,ldbRepl,int ldbRepl (lua_State*),eval.c,"int ldbRepl(lua_State *lua) {
    sds *argv;
    int argc;
    char* err = NULL;

    /* We continue processing commands until a command that should return
     * to the Lua interpreter is found. */
    while(1) {
        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {
            char buf[1024];
            if (err) {
                luaPushError(lua, err);
                luaError(lua);
            }
            int nread = connRead(ldb.conn,buf,sizeof(buf));
            if (nread <= 0) {
                /* Make sure the script runs without user input since the
                 * client is no longer connected. */
                ldb.step = 0;
                ldb.bpcount = 0;
                return C_ERR;
            }
            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
            /* after 1M we will exit with an error
             * so that the client will not blow the memory
             */
            if (sdslen(ldb.cbuf) > 1<<20) {
                sdsfree(ldb.cbuf...",1489.0,1616.0,1.0,23.0,128.0,31,12,34,8,1,95,7,15,4,75,,0,56,2,1,1,int
3777,128624,luaLdbLineHook,1,luaLdbLineHook,"void luaLdbLineHook (lua_State*,lua_Debug*)",eval.c,"void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    lua_getstack(lua,0,ar);
    lua_getinfo(lua,""Sl"",ar);
    ldb.currentline = ar->currentline;

    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
    int timeout = 0;

    /* Events outside our script are not interesting. */
    if(strstr(ar->short_src,""user_script"") == NULL) return;

    /* Check if a timeout occurred. */
    if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {
        mstime_t elapsed = elapsedMs(rctx->start_time);
        mstime_t timelimit = server.busy_reply_threshold ?
                             server.busy_reply_threshold : 5000;
        if (elapsed >= timelimit) {
            timeout = 1;
            ldb.step = 1;
        } else {
            return; /* No timeout, ignore the COUNT event. */
        }
    }

    if (ldb.step || bp) {
        c...",1620.0,1667.0,1.0,49.0,48.0,49,12,45,12,0,37,7,10,5,13,,0,31,4,2,2,void
3778,128840,getLRUClock,1,getLRUClock,unsigned int getLRUClock (void),evict.c,"unsigned int getLRUClock(void) {
    return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
}",72.0,74.0,1.0,21.0,3.0,4,4,0,0,2,1,1,1,0,1,,0,0,2,1,1,unsigned int
3779,128859,LRU_CLOCK,1,LRU_CLOCK,unsigned int LRU_CLOCK (void),evict.c,"unsigned int LRU_CLOCK(void) {
    unsigned int lruclock;
    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {
        lruclock = server.lruclock;
    } else {
        lruclock = getLRUClock();
    }
    return lruclock;
}",80.0,88.0,1.0,26.0,9.0,5,4,4,2,3,0,2,2,0,0,,0,0,2,1,1,unsigned int
3780,128888,estimateObjectIdleTime,1,estimateObjectIdleTime,unsigned long long estimateObjectIdleTime (robj*),evict.c,"unsigned long long estimateObjectIdleTime(robj *o) {
    unsigned long long lruclock = LRU_CLOCK();
    if (lruclock >= o->lru) {
        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
    } else {
        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *
                    LRU_CLOCK_RESOLUTION;
    }
}",92.0,100.0,1.0,37.0,9.0,6,5,5,2,3,1,2,2,0,1,,0,1,2,1,1,unsigned long long
3781,128934,evictionPoolAlloc,1,evictionPoolAlloc,void evictionPoolAlloc (void),evict.c,"void evictionPoolAlloc(void) {
    struct evictionPoolEntry *ep;
    int j;

    ep = zmalloc(sizeof(*ep)*EVPOOL_SIZE);
    for (j = 0; j < EVPOOL_SIZE; j++) {
        ep[j].idle = 0;
        ep[j].key = NULL;
        ep[j].cached = sdsnewlen(NULL,EVPOOL_CACHED_SDS_SIZE);
        ep[j].dbid = 0;
    }
    EvictionPoolLRU = ep;
}",123.0,135.0,1.0,29.0,13.0,19,7,16,4,1,3,2,2,0,2,,0,3,2,1,1,void
3782,128999,evictionPoolPopulate,1,evictionPoolPopulate,"void evictionPoolPopulate (int,dict*,dict*,evictionPoolEntry*)",evict.c,"void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
    int j, k, count;
    dictEntry *samples[server.maxmemory_samples];

    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);
    for (j = 0; j < count; j++) {
        unsigned long long idle;
        sds key;
        robj *o;
        dictEntry *de;

        de = samples[j];
        key = dictGetKey(de);

        /* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */
        if (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) {
            if (sampledict != keydict) de = dictFind(keydict, key);
            o = dictGetVal(de);
        }

        /* Calculate the idle time according to the policy. This is called
         * idle just because the code initially handled LRU, but is in fact
         * just a score where an h...",146.0,241.0,1.0,39.0,96.0,43,11,45,15,1,7,9,15,0,7,,0,7,8,4,4,void
3783,129361,LFUGetTimeInMinutes,1,LFUGetTimeInMinutes,unsigned long LFUGetTimeInMinutes (void),evict.c,"unsigned long LFUGetTimeInMinutes(void) {
    return (server.unixtime/60) & 65535;
}",283.0,285.0,1.0,1.0,3.0,3,3,1,1,4,0,1,1,0,0,,0,0,2,1,1,unsigned long
3784,129374,LFUTimeElapsed,1,LFUTimeElapsed,unsigned long LFUTimeElapsed (long unsigned),evict.c,"unsigned long LFUTimeElapsed(unsigned long ldt) {
    unsigned long now = LFUGetTimeInMinutes();
    if (now >= ldt) return now-ldt;
    return 65535-ldt+now;
}",291.0,295.0,1.0,1.0,5.0,5,4,7,2,1,1,2,2,0,1,,0,1,2,1,1,unsigned long
3785,129398,LFULogIncr,1,LFULogIncr,uint8_t LFULogIncr (uint8_t),evict.c,"uint8_t LFULogIncr(uint8_t counter) {
    if (counter == 255) return 255;
    double r = (double)rand()/RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval < 0) baseval = 0;
    double p = 1.0/(baseval*server.lfu_log_factor+1);
    if (r < p) counter++;
    return counter;
}",299.0,307.0,1.0,31.0,9.0,15,10,14,6,1,0,4,4,0,0,,0,0,2,1,1,uint8_t
3786,129455,LFUDecrAndReturn,1,LFUDecrAndReturn,unsigned long LFUDecrAndReturn (robj*),evict.c,"unsigned long LFUDecrAndReturn(robj *o) {
    unsigned long ldt = o->lru >> 8;
    unsigned long counter = o->lru & 255;
    unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;
    if (num_periods)
        counter = (num_periods > counter) ? 0 : counter - num_periods;
    return counter;
}",319.0,326.0,1.0,1.0,8.0,15,9,15,5,3,1,2,2,0,1,,0,1,2,1,1,unsigned long
3787,129505,freeMemoryGetNotCountedMemory,1,freeMemoryGetNotCountedMemory,size_t freeMemoryGetNotCountedMemory (void),evict.c,"size_t freeMemoryGetNotCountedMemory(void) {
    size_t overhead = 0;

    /* Since all replicas and replication backlog share global replication
     * buffer, we think only the part of exceeding backlog size is the extra
     * separate consumption of replicas.
     *
     * Note that although the backlog is also initially incrementally grown
     * (pushing DELs consumes memory), it'll eventually stop growing and
     * remain constant in size, so even if its creation will cause some
     * eviction, it's capped, and also here to stay (no resonance effect)
     *
     * Note that, because we trim backlog incrementally in the background,
     * backlog size may exceeds our setting if slow replicas that reference
     * vast replication buffer blocks disconnect. To avoid massive eviction
     * loop, we don't count the delayed freed replication backlog into used
     * memory even if there are no replicas, i.e. we still regard this memory
     * as replicas'. */
    if ((long long)...",336.0,371.0,1.0,38.0,36.0,26,11,19,6,4,1,4,5,0,1,,0,0,2,1,1,size_t
3788,129584,getMaxmemoryState,1,getMaxmemoryState,"int getMaxmemoryState (size_t*,size_t*,size_t*,float*)",evict.c,"int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {
    size_t mem_reported, mem_used, mem_tofree;

    /* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */
    mem_reported = zmalloc_used_memory();
    if (total) *total = mem_reported;

    /* We may return ASAP if there is no need to compute the level. */
    if (!server.maxmemory) {
        if (level) *level = 0;
        return C_OK;
    }
    if (mem_reported <= server.maxmemory && !level) return C_OK;

    /* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */
    mem_used = mem_reported;
    size_t overhead = freeMemoryGetNotCountedMemory();
    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;

    /* Compute the ratio of memory usage. */
    if (level) *level = (float)mem_used / (float)server.maxmemory;

    if (mem_reported <= server.maxmemory) ret...",397.0,433.0,1.0,15.0,37.0,35,12,35,9,6,2,10,11,0,2,,0,2,8,4,4,int
3789,129716,overMaxmemoryAfterAlloc,1,overMaxmemoryAfterAlloc,int overMaxmemoryAfterAlloc (size_t),evict.c,"int overMaxmemoryAfterAlloc(size_t moremem) {
    if (!server.maxmemory) return  0; /* No limit. */

    /* Check quickly. */
    size_t mem_used = zmalloc_used_memory();
    if (mem_used + moremem <= server.maxmemory) return 0;

    size_t overhead = freeMemoryGetNotCountedMemory();
    mem_used = (mem_used > overhead) ? mem_used - overhead : 0;
    return mem_used + moremem > server.maxmemory;
}",438.0,448.0,1.0,1.0,11.0,14,8,14,4,1,2,3,3,0,2,,0,2,2,1,1,int
3790,129770,evictionTimeProc,1,evictionTimeProc,"int evictionTimeProc (aeEventLoop*,long long,void*)",evict.c,"static int evictionTimeProc(
        struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    if (performEvictions() == EVICT_RUNNING) return 0;  /* keep evicting */

    /* For EVICT_OK - things are good, no need to keep evicting.
     * For EVICT_FAIL - there is nothing left to evict.  */
    isEvictionProcRunning = 0;
    return AE_NOMORE;
}",455.0,467.0,1.0,4.0,13.0,6,4,7,4,0,2,2,2,1,1,,0,2,6,3,3,int
3791,129812,startEvictionTimeProc,1,startEvictionTimeProc,void startEvictionTimeProc (void),evict.c,"void startEvictionTimeProc(void) {
    if (!isEvictionProcRunning) {
        isEvictionProcRunning = 1;
        aeCreateTimeEvent(server.el, 0,
                evictionTimeProc, NULL, NULL);
    }
}",469.0,475.0,1.0,1.0,7.0,3,3,5,3,2,3,2,2,1,1,,0,2,2,1,1,void
3792,129832,isSafeToPerformEvictions,1,isSafeToPerformEvictions,int isSafeToPerformEvictions (void),evict.c,"static int isSafeToPerformEvictions(void) {
    /* - There must be no script in timeout condition.
     * - Nor we are loading data right now.  */
    if (isInsideYieldingLongCommand() || server.loading) return 0;

    /* By default replicas should ignore maxmemory
     * and just be masters exact copies. */
    if (server.masterhost && server.repl_slave_ignore_maxmemory) return 0;

    /* If 'evict' action is paused, for whatever reason, then return false */
    if (isPausedActionsWithUpdate(PAUSE_ACTION_EVICT)) return 0;

    return 1;
}",481.0,494.0,1.0,34.0,14.0,6,4,3,1,1,2,4,4,2,2,,0,2,2,1,1,int
3793,129869,evictionTimeLimitUs,1,evictionTimeLimitUs,unsigned long evictionTimeLimitUs (void),evict.c,"static unsigned long evictionTimeLimitUs(void) {
    serverAssert(server.maxmemory_eviction_tenacity >= 0);
    serverAssert(server.maxmemory_eviction_tenacity <= 100);

    if (server.maxmemory_eviction_tenacity <= 10) {
        /* A linear progression from 0..500us */
        return 50uL * server.maxmemory_eviction_tenacity;
    }

    if (server.maxmemory_eviction_tenacity < 100) {
        /* A 15% geometric progression, resulting in a limit of ~2 min at tenacity==99  */
        return (unsigned long)(500.0 * pow(1.15, server.maxmemory_eviction_tenacity - 10.0));
    }

    return ULONG_MAX;   /* No limit to eviction time */
}",497.0,512.0,1.0,4.0,16.0,22,10,7,2,1,2,3,3,0,2,,0,0,2,1,1,unsigned long
3794,129944,performEvictions,1,performEvictions,int performEvictions (void),evict.c,"int performEvictions(void) {
    /* Note, we don't goto update_metrics here because this check skips eviction
     * as if it wasn't triggered. it's a fake EVICT_OK. */
    if (!isSafeToPerformEvictions()) return EVICT_OK;

    int keys_freed = 0;
    size_t mem_reported, mem_tofree;
    long long mem_freed; /* May be negative */
    mstime_t latency, eviction_latency;
    long long delta;
    int slaves = listLength(server.slaves);
    int result = EVICT_FAIL;

    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK) {
        result = EVICT_OK;
        goto update_metrics;
    }

    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION) {
        result = EVICT_FAIL;  /* We need to free memory, but policy forbids. */
        goto update_metrics;
    }

    unsigned long eviction_time_limit_us = evictionTimeLimitUs();

    mem_freed = 0;

    latencyStartMonitor(latency);

    monotime evictionTimer;
    elapsedStart(&evictionTimer);

    /* Try to smoke-out bugs (se...",538.0,755.0,1.0,44.0,218.0,164,26,168,29,2,44,34,78,9,36,,0,27,2,1,1,int
3795,130781,activeExpireCycleTryExpire,1,activeExpireCycleTryExpire,"int activeExpireCycleTryExpire (redisDb*,dictEntry*,long long)",expire.c,"int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {
    long long t = dictGetSignedIntegerVal(de);
    if (now > t) {
        sds key = dictGetKey(de);
        robj *keyobj = createStringObject(key,sdslen(key));
        deleteExpiredKeyAndPropagate(db,keyobj);
        decrRefCount(keyobj);
        return 1;
    } else {
        return 0;
    }
}",54.0,65.0,1.0,1.0,12.0,4,2,12,6,2,6,2,2,0,6,,0,4,6,3,3,int
3796,130829,expireScanCallback,1,expireScanCallback,"void expireScanCallback (void*,dictEntry*)",expire.c,"void expireScanCallback(void *privdata, const dictEntry *const_de) {
    dictEntry *de = (dictEntry *)const_de;
    expireScanData *data = privdata;
    long long ttl  = dictGetSignedIntegerVal(de) - data->now;
    if (activeExpireCycleTryExpire(data->db, de, data->now)) {
        data->expired++;
        /* Propagate the DEL command */
        postExecutionUnitOperations();
    }
    if (ttl > 0) {
        /* We want the average TTL of keys yet not expired. */
        data->ttl_sum += ttl;
        data->ttl_samples++;
    }
    data->sampled++;
}",123.0,138.0,1.0,1.0,16.0,17,7,16,5,0,10,3,3,3,3,,0,9,4,2,2,void
3797,130887,activeExpireCycle,1,activeExpireCycle,void activeExpireCycle (int),expire.c,"void activeExpireCycle(int type) {
    /* Adjust the running parameters according to the configured expire
     * effort. The default effort is 1, and the maximum configurable effort
     * is 10. */
    unsigned long
    effort = server.active_expire_effort-1, /* Rescale from 0 to 9. */
    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +
                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/4*effort,
    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +
                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/4*effort,
    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +
                                  2*effort,
    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-
                                    effort;

    /* This function has some global state in order to continue the work
     * incrementally across calls. */
    static unsigned int current_db = 0; /* Next DB to test. */
    static int timel...",140.0,322.0,1.0,27.0,183.0,193,27,129,26,2,39,22,40,10,8,,0,37,2,1,1,void
3798,131464,expireSlaveKeys,1,expireSlaveKeys,void expireSlaveKeys (void),expire.c,"void expireSlaveKeys(void) {
    if (slaveKeysWithExpire == NULL ||
        dictSize(slaveKeysWithExpire) == 0) return;

    int cycles = 0, noexpire = 0;
    mstime_t start = mstime();
    while(1) {
        dictEntry *de = dictGetRandomKey(slaveKeysWithExpire);
        sds keyname = dictGetKey(de);
        uint64_t dbids = dictGetUnsignedIntegerVal(de);
        uint64_t new_dbids = 0;

        /* Check the key against every database corresponding to the
         * bits set in the value bitmap. */
        int dbid = 0;
        while(dbids && dbid < server.dbnum) {
            if ((dbids & 1) != 0) {
                redisDb *db = server.db+dbid;
                dictEntry *expire = dictFind(db->expires,keyname);
                int expired = 0;

                if (expire &&
                    activeExpireCycleTryExpire(server.db+dbid,expire,start))
                {
                    expired = 1;
                    /* Propagate the DEL (writable replicas do not propagate anythin...",363.0,421.0,1.0,8.0,59.0,50,18,50,14,0,22,14,24,13,9,,0,20,2,1,1,void
3799,131654,rememberSlaveKeyWithExpire,1,rememberSlaveKeyWithExpire,"void rememberSlaveKeyWithExpire (redisDb*,robj*)",expire.c,"void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
    if (slaveKeysWithExpire == NULL) {
        static dictType dt = {
            dictSdsHash,                /* hash function */
            NULL,                       /* key dup */
            NULL,                       /* val dup */
            dictSdsKeyCompare,          /* key compare */
            dictSdsDestructor,          /* key destructor */
            NULL,                       /* val destructor */
            NULL                        /* allow to expand */
        };
        slaveKeysWithExpire = dictCreate(&dt);
    }
    if (db->id > 63) return;

    dictEntry *de = dictAddOrFind(slaveKeysWithExpire,key->ptr);
    /* If the entry was just created, set it to a copy of the SDS string
     * representing the key: we don't want to need to take those keys
     * in sync with the main DB. The keys will be removed by expireSlaveKeys()
     * as it scans to find keys to remove. */
    if (dictGetKey(de) == key->p...",425.0,453.0,1.0,1.0,29.0,16,8,28,10,1,14,4,4,3,8,,0,11,4,2,2,void
3800,131732,getSlaveKeyWithExpireCount,1,getSlaveKeyWithExpireCount,size_t getSlaveKeyWithExpireCount (void),expire.c,"size_t getSlaveKeyWithExpireCount(void) {
    if (slaveKeysWithExpire == NULL) return 0;
    return dictSize(slaveKeysWithExpire);
}",456.0,459.0,1.0,11.0,4.0,6,4,5,2,1,6,2,2,1,0,,0,6,2,1,1,size_t
3801,131759,flushSlaveKeysWithExpireList,1,flushSlaveKeysWithExpireList,void flushSlaveKeysWithExpireList (void),expire.c,"void flushSlaveKeysWithExpireList(void) {
    if (slaveKeysWithExpire) {
        dictRelease(slaveKeysWithExpire);
        slaveKeysWithExpire = NULL;
    }
}",469.0,474.0,1.0,1.0,6.0,1,1,4,2,2,4,2,2,1,1,,0,3,2,1,1,void
3802,131772,checkAlreadyExpired,1,checkAlreadyExpired,int checkAlreadyExpired (long long),expire.c,"int checkAlreadyExpired(long long when) {
    /* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past
     * should never be executed as a DEL when load the AOF or in the context
     * of a slave instance.
     *
     * Instead we add the already expired key to the database with expire time
     * (possibly in the past) and wait for an explicit DEL from the master. */
    return (when <= commandTimeSnapshot() && !server.loading && !server.masterhost);
}",476.0,484.0,1.0,1.0,9.0,7,4,3,2,2,1,1,1,0,1,,0,0,2,1,1,int
3803,131791,parseExtendedExpireArgumentsOrReply,1,parseExtendedExpireArgumentsOrReply,"int parseExtendedExpireArgumentsOrReply (client*,int*)",expire.c,"int parseExtendedExpireArgumentsOrReply(client *c, int *flags) {
    int nx = 0, xx = 0, gt = 0, lt = 0;

    int j = 3;
    while (j < c->argc) {
        char *opt = c->argv[j]->ptr;
        if (!strcasecmp(opt,""nx"")) {
            *flags |= EXPIRE_NX;
            nx = 1;
        } else if (!strcasecmp(opt,""xx"")) {
            *flags |= EXPIRE_XX;
            xx = 1;
        } else if (!strcasecmp(opt,""gt"")) {
            *flags |= EXPIRE_GT;
            gt = 1;
        } else if (!strcasecmp(opt,""lt"")) {
            *flags |= EXPIRE_LT;
            lt = 1;
        } else {
            addReplyErrorFormat(c, ""Unsupported option %s"", opt);
            return C_ERR;
        }
        j++;
    }

    if ((nx && xx) || (nx && gt) || (nx && lt)) {
        addReplyError(c, ""NX and XX, GT or LT options at the same time are not compatible"");
        return C_ERR;
    }

    if (gt && lt) {
        addReplyError(c, ""GT and LT options at the same time are not compatible"");
        return C_E...",498.0,534.0,1.0,22.0,37.0,24,11,24,8,1,4,5,6,1,2,,0,2,4,2,2,int
3804,131959,expireGenericCommand,1,expireGenericCommand,"void expireGenericCommand (client*,long long,int)",expire.c,"void expireGenericCommand(client *c, long long basetime, int unit) {
    robj *key = c->argv[1], *param = c->argv[2];
    long long when; /* unix time in milliseconds when the key will expire. */
    long long current_expire = -1;
    int flag = 0;

    /* checking optional flags */
    if (parseExtendedExpireArgumentsOrReply(c, &flag) != C_OK) {
        return;
    }

    if (getLongLongFromObjectOrReply(c, param, &when, NULL) != C_OK)
        return;

    /* EXPIRE allows negative numbers, but we can at least detect an
     * overflow by either unit conversion or basetime addition. */
    if (unit == UNIT_SECONDS) {
        if (when > LLONG_MAX / 1000 || when < LLONG_MIN / 1000) {
            addReplyErrorExpireTime(c);
            return;
        }
        when *= 1000;
    }

    if (when > LLONG_MAX - basetime) {
        addReplyErrorExpireTime(c);
        return;
    }
    when += basetime;

    /* No key, return zero. */
    if (lookupKeyWrite(c->db,key) == NULL) {
        ad...",549.0,664.0,1.0,57.0,116.0,72,25,80,15,4,25,17,30,5,18,,0,13,6,3,3,void
3805,132333,expireCommand,1,expireCommand,void expireCommand (client*),expire.c,"void expireCommand(client *c) {
    expireGenericCommand(c,commandTimeSnapshot(),UNIT_SECONDS);
}",667.0,669.0,1.0,49.0,3.0,0,0,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
3806,132344,expireatCommand,1,expireatCommand,void expireatCommand (client*),expire.c,"void expireatCommand(client *c) {
    expireGenericCommand(c,0,UNIT_SECONDS);
}",672.0,674.0,1.0,29.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3807,132355,pexpireCommand,1,pexpireCommand,void pexpireCommand (client*),expire.c,"void pexpireCommand(client *c) {
    expireGenericCommand(c,commandTimeSnapshot(),UNIT_MILLISECONDS);
}",677.0,679.0,1.0,49.0,3.0,0,0,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
3808,132366,pexpireatCommand,1,pexpireatCommand,void pexpireatCommand (client*),expire.c,"void pexpireatCommand(client *c) {
    expireGenericCommand(c,0,UNIT_MILLISECONDS);
}",682.0,684.0,1.0,29.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3809,132377,ttlGenericCommand,1,ttlGenericCommand,"void ttlGenericCommand (client*,int,int)",expire.c,"void ttlGenericCommand(client *c, int output_ms, int output_abs) {
    long long expire, ttl = -1;

    /* If the key does not exist at all, return -2 */
    if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
        addReplyLongLong(c,-2);
        return;
    }

    /* The key exists. Return -1 if it has no expire, or the actual
     * TTL value otherwise. */
    expire = getExpire(c->db,c->argv[1]);
    if (expire != -1) {
        ttl = output_abs ? expire : expire-commandTimeSnapshot();
        if (ttl < 0) ttl = 0;
    }
    if (ttl == -1) {
        addReplyLongLong(c,-1);
    } else {
        addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
    }
}",687.0,708.0,1.0,48.0,22.0,22,10,17,5,4,9,5,6,3,5,,0,7,6,3,3,void
3810,132468,ttlCommand,1,ttlCommand,void ttlCommand (client*),expire.c,"void ttlCommand(client *c) {
    ttlGenericCommand(c, 0, 0);
}",711.0,713.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3811,132477,pttlCommand,1,pttlCommand,void pttlCommand (client*),expire.c,"void pttlCommand(client *c) {
    ttlGenericCommand(c, 1, 0);
}",716.0,718.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3812,132486,expiretimeCommand,1,expiretimeCommand,void expiretimeCommand (client*),expire.c,"void expiretimeCommand(client *c) {
    ttlGenericCommand(c, 0, 1);
}",721.0,723.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3813,132495,pexpiretimeCommand,1,pexpiretimeCommand,void pexpiretimeCommand (client*),expire.c,"void pexpiretimeCommand(client *c) {
    ttlGenericCommand(c, 1, 1);
}",726.0,728.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3814,132504,persistCommand,1,persistCommand,void persistCommand (client*),expire.c,"void persistCommand(client *c) {
    if (lookupKeyWrite(c->db,c->argv[1])) {
        if (removeExpire(c->db,c->argv[1])) {
            signalModifiedKey(c,c->db,c->argv[1]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,""persist"",c->argv[1],c->db->id);
            addReply(c,shared.cone);
            server.dirty++;
        } else {
            addReply(c,shared.czero);
        }
    } else {
        addReply(c,shared.czero);
    }
}",731.0,744.0,1.0,32.0,14.0,17,5,12,3,0,13,3,4,6,5,,0,10,2,1,1,void
3815,132581,touchCommand,1,touchCommand,void touchCommand (client*),expire.c,"void touchCommand(client *c) {
    int touched = 0;
    for (int j = 1; j < c->argc; j++)
        if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
    addReplyLongLong(c,touched);
}",747.0,752.0,1.0,1.0,6.0,4,3,6,3,0,2,2,2,1,1,,0,1,2,1,1,void
3816,132659,luaEngineLoadHook,1,luaEngineLoadHook,"void luaEngineLoadHook (lua_State*,lua_Debug*)",function_lua.c,"static void luaEngineLoadHook(lua_State *lua, lua_Debug *ar) {
    UNUSED(ar);
    loadCtx *load_ctx = luaGetFromRegistry(lua, REGISTRY_LOAD_CTX_NAME);
    serverAssert(load_ctx); /* Only supported inside script invocation */
    uint64_t duration = elapsedMs(load_ctx->start_time);
    if (duration > LOAD_TIMEOUT_MS) {
        lua_sethook(lua, luaEngineLoadHook, LUA_MASKLINE, 0);

        luaPushError(lua,""FUNCTION LOAD timeout"");
        luaError(lua);
    }
}",83.0,94.0,1.0,4.0,12.0,9,7,13,5,0,6,2,2,0,5,,0,3,4,2,2,void
3817,132718,luaEngineCreate,1,luaEngineCreate,"int luaEngineCreate (void*,functionLibInfo*,sds,sds*)",function_lua.c,"static int luaEngineCreate(void *engine_ctx, functionLibInfo *li, sds blob, sds *err) {
    int ret = C_ERR;
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;

    /* set load library globals */
    lua_getmetatable(lua, LUA_GLOBALSINDEX);
    lua_enablereadonlytable(lua, -1, 0); /* disable global protection */
    lua_getfield(lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);
    lua_setfield(lua, -2, ""__index"");
    lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1); /* enable global protection */
    lua_pop(lua, 1); /* pop the metatable */

    /* compile the code */
    if (luaL_loadbuffer(lua, blob, sdslen(blob), ""@user_function"")) {
        *err = sdscatprintf(sdsempty(), ""Error compiling function: %s"", lua_tostring(lua, -1));
        lua_pop(lua, 1); /* pops the error */
        goto done;
    }
    serverAssert(lua_isfunction(lua, -1));

    loadCtx load_ctx = {
        .li = li,
        .start_time = getMonotonicUs(),
    };
    luaSaveOnRegi...",103.0,155.0,1.0,14.0,53.0,30,11,52,14,0,13,5,3,1,11,,0,8,8,4,4,int
3818,132909,luaEngineCall,1,luaEngineCall,"void luaEngineCall (scriptRunCtx*,void*,void*,robj**,size_t,robj**,size_t)",function_lua.c,"static void luaEngineCall(scriptRunCtx *run_ctx,
                          void *engine_ctx,
                          void *compiled_function,
                          robj **keys,
                          size_t nkeys,
                          robj **args,
                          size_t nargs)
{
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;
    luaFunctionCtx *f_ctx = compiled_function;

    /* Push error handler */
    lua_pushstring(lua, REGISTRY_ERROR_HANDLER_NAME);
    lua_gettable(lua, LUA_REGISTRYINDEX);

    lua_rawgeti(lua, LUA_REGISTRYINDEX, f_ctx->lua_function_ref);

    serverAssert(lua_isfunction(lua, -1));

    luaCallFunction(run_ctx, lua, keys, nkeys, args, nargs, 0);
    lua_pop(lua, 1); /* Pop error handler */
}",160.0,182.0,1.0,24.0,23.0,10,7,20,11,0,4,1,1,0,2,,0,2,14,7,7,void
3819,132976,luaEngineGetUsedMemoy,1,luaEngineGetUsedMemoy,size_t luaEngineGetUsedMemoy (void*),function_lua.c,"static size_t luaEngineGetUsedMemoy(void *engine_ctx) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    return luaMemory(lua_engine_ctx->lua);
}",184.0,187.0,1.0,1.0,4.0,2,2,3,2,0,2,1,1,0,1,,0,1,2,1,1,size_t
3820,132990,luaEngineFunctionMemoryOverhead,1,luaEngineFunctionMemoryOverhead,size_t luaEngineFunctionMemoryOverhead (void*),function_lua.c,"static size_t luaEngineFunctionMemoryOverhead(void *compiled_function) {
    return zmalloc_size(compiled_function);
}",189.0,191.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
3821,132998,luaEngineMemoryOverhead,1,luaEngineMemoryOverhead,size_t luaEngineMemoryOverhead (void*),function_lua.c,"static size_t luaEngineMemoryOverhead(void *engine_ctx) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    return zmalloc_size(lua_engine_ctx);
}",193.0,196.0,1.0,1.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,2,1,1,size_t
3822,133010,luaEngineFreeFunction,1,luaEngineFreeFunction,"void luaEngineFreeFunction (void*,void*)",function_lua.c,"static void luaEngineFreeFunction(void *engine_ctx, void *compiled_function) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;
    luaFunctionCtx *f_ctx = compiled_function;
    lua_unref(lua, f_ctx->lua_function_ref);
    zfree(f_ctx);
}",198.0,204.0,1.0,1.0,7.0,5,2,9,5,0,3,1,1,0,1,,0,2,4,2,2,void
3823,133037,luaRegisterFunctionArgsInitialize,1,luaRegisterFunctionArgsInitialize,"void luaRegisterFunctionArgsInitialize (registerFunctionArgs*,sds,sds,luaFunctionCtx*,uint64_t)",function_lua.c,"static void luaRegisterFunctionArgsInitialize(registerFunctionArgs *register_f_args,
    sds name,
    sds desc,
    luaFunctionCtx *lua_f_ctx,
    uint64_t flags)
{
    *register_f_args = (registerFunctionArgs){
        .name = name,
        .desc = desc,
        .lua_f_ctx = lua_f_ctx,
        .f_flags = flags,
    };
}",206.0,218.0,1.0,1.0,13.0,8,4,9,6,2,0,1,1,0,0,,0,0,10,5,5,void
3824,133068,luaRegisterFunctionArgsDispose,1,luaRegisterFunctionArgsDispose,"void luaRegisterFunctionArgsDispose (lua_State*,registerFunctionArgs*)",function_lua.c,"static void luaRegisterFunctionArgsDispose(lua_State *lua, registerFunctionArgs *register_f_args) {
    sdsfree(register_f_args->name);
    if (register_f_args->desc) sdsfree(register_f_args->desc);
    lua_unref(lua, register_f_args->lua_f_ctx->lua_function_ref);
    zfree(register_f_args->lua_f_ctx);
}",220.0,225.0,1.0,1.0,6.0,6,1,6,2,1,8,2,2,1,3,,0,5,4,2,2,void
3825,133098,luaRegisterFunctionReadFlags,1,luaRegisterFunctionReadFlags,"int luaRegisterFunctionReadFlags (lua_State*,uint64_t*)",function_lua.c,"static int luaRegisterFunctionReadFlags(lua_State *lua, uint64_t *flags) {
    int j = 1;
    int ret = C_ERR;
    int f_flags = 0;
    while(1) {
        lua_pushnumber(lua,j++);
        lua_gettable(lua,-2);
        int t = lua_type(lua,-1);
        if (t == LUA_TNIL) {
            lua_pop(lua,1);
            break;
        }
        if (!lua_isstring(lua, -1)) {
            lua_pop(lua,1);
            goto done;
        }

        const char *flag_str = lua_tostring(lua, -1);
        int found = 0;
        for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
            if (!strcasecmp(flag->str, flag_str)) {
                f_flags |= flag->flag;
                found = 1;
                break;
            }
        }
        /* pops the value to continue the iteration */
        lua_pop(lua,1);
        if (!found) {
            /* flag not found */
            goto done;
        }
    }

    *flags = f_flags;
    ret = C_OK;

done:
    return ret;
}",230.0,269.0,1.0,14.0,40.0,24,7,30,11,0,0,11,13,0,0,,0,0,4,2,2,int
3826,133217,luaRegisterFunctionReadNamedArgs,1,luaRegisterFunctionReadNamedArgs,"int luaRegisterFunctionReadNamedArgs (lua_State*,registerFunctionArgs*)",function_lua.c,"static int luaRegisterFunctionReadNamedArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    char *err = NULL;
    sds name = NULL;
    sds desc = NULL;
    luaFunctionCtx *lua_f_ctx = NULL;
    uint64_t flags = 0;
    if (!lua_istable(lua, 1)) {
        err = ""calling redis.register_function with a single argument is only applicable to Lua table (representing named arguments)."";
        goto error;
    }

    /* Iterating on all the named arguments */
    lua_pushnil(lua);
    while (lua_next(lua, -2)) {
        /* Stack now: table, key, value */
        if (!lua_isstring(lua, -2)) {
            err = ""named argument key given to redis.register_function is not a string"";
            goto error;
        }
        const char *key = lua_tostring(lua, -2);
        if (!strcasecmp(key, ""function_name"")) {
            if (!(name = luaGetStringSds(lua, -1))) {
                err = ""function_name argument given to redis.register_function must be a string"";
                goto...",271.0,351.0,1.0,61.0,81.0,24,4,41,9,1,7,16,15,1,6,,0,2,4,2,2,int
3827,133453,luaRegisterFunctionReadPositionalArgs,1,luaRegisterFunctionReadPositionalArgs,"int luaRegisterFunctionReadPositionalArgs (lua_State*,registerFunctionArgs*)",function_lua.c,"static int luaRegisterFunctionReadPositionalArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    char *err = NULL;
    sds name = NULL;
    sds desc = NULL;
    luaFunctionCtx *lua_f_ctx = NULL;
    if (!(name = luaGetStringSds(lua, 1))) {
        err = ""first argument to redis.register_function must be a string"";
        goto error;
    }

    if (!lua_isfunction(lua, 2)) {
        err = ""second argument to redis.register_function must be a function"";
        goto error;
    }

    int lua_function_ref = luaL_ref(lua, LUA_REGISTRYINDEX);

    lua_f_ctx = zmalloc(sizeof(*lua_f_ctx));
    lua_f_ctx->lua_function_ref = lua_function_ref;

    luaRegisterFunctionArgsInitialize(register_f_args, name, NULL, lua_f_ctx, 0);

    return C_OK;

error:
    if (name) sdsfree(name);
    if (desc) sdsfree(desc);
    luaPushError(lua, err);
    return C_ERR;
}",353.0,382.0,1.0,11.0,30.0,16,6,30,9,0,7,7,5,1,6,,0,3,4,2,2,int
3828,133543,luaRegisterFunctionReadArgs,1,luaRegisterFunctionReadArgs,"int luaRegisterFunctionReadArgs (lua_State*,registerFunctionArgs*)",function_lua.c,"static int luaRegisterFunctionReadArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    int argc = lua_gettop(lua);
    if (argc < 1 || argc > 2) {
        luaPushError(lua, ""wrong number of arguments to redis.register_function"");
        return C_ERR;
    }

    if (argc == 1) {
        return luaRegisterFunctionReadNamedArgs(lua, register_f_args);
    } else {
        return luaRegisterFunctionReadPositionalArgs(lua, register_f_args);
    }
}",384.0,396.0,1.0,15.0,13.0,6,6,8,3,1,2,3,3,0,2,,0,0,4,2,2,int
3829,133586,luaRegisterFunction,1,luaRegisterFunction,int luaRegisterFunction (lua_State*),function_lua.c,"static int luaRegisterFunction(lua_State *lua) {
    registerFunctionArgs register_f_args = {0};

    loadCtx *load_ctx = luaGetFromRegistry(lua, REGISTRY_LOAD_CTX_NAME);
    if (!load_ctx) {
        luaPushError(lua, ""redis.register_function can only be called on FUNCTION LOAD command"");
        return luaError(lua);
    }

    if (luaRegisterFunctionReadArgs(lua, &register_f_args) != C_OK) {
        return luaError(lua);
    }

    sds err = NULL;
    if (functionLibCreateFunction(register_f_args.name, register_f_args.lua_f_ctx, load_ctx->li, register_f_args.desc, register_f_args.f_flags, &err) != C_OK) {
        luaRegisterFunctionArgsDispose(lua, &register_f_args);
        luaPushError(lua, err);
        sdsfree(err);
        return luaError(lua);
    }

    return 0;
}",398.0,420.0,1.0,48.0,23.0,15,7,23,5,0,15,4,4,7,10,,0,8,2,1,1,int
3830,133669,luaEngineInitEngine,1,luaEngineInitEngine,int luaEngineInitEngine (void),function_lua.c,"int luaEngineInitEngine(void) {
    luaEngineCtx *lua_engine_ctx = zmalloc(sizeof(*lua_engine_ctx));
    lua_engine_ctx->lua = lua_open();

    luaRegisterRedisAPI(lua_engine_ctx->lua);

    /* Register the library commands table and fields and store it to registry */
    lua_newtable(lua_engine_ctx->lua); /* load library globals */
    lua_newtable(lua_engine_ctx->lua); /* load library `redis` table */

    lua_pushstring(lua_engine_ctx->lua, ""register_function"");
    lua_pushcfunction(lua_engine_ctx->lua, luaRegisterFunction);
    lua_settable(lua_engine_ctx->lua, -3);

    luaRegisterLogFunction(lua_engine_ctx->lua);
    luaRegisterVersion(lua_engine_ctx->lua);

    luaSetErrorMetatable(lua_engine_ctx->lua);
    lua_setfield(lua_engine_ctx->lua, -2, REDIS_API_NAME);

    luaSetErrorMetatable(lua_engine_ctx->lua);
    luaSetTableProtectionRecursively(lua_engine_ctx->lua); /* protect load library globals */
    lua_setfield(lua_engine_ctx->lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);...",423.0,505.0,1.0,42.0,83.0,58,7,58,12,1,45,1,1,0,12,,0,35,2,1,1,int
3831,133937,engineFunctionDispose,1,engineFunctionDispose,"void engineFunctionDispose (dict*,void*)",functions.c,"static void engineFunctionDispose(dict *d, void *obj) {
    UNUSED(d);
    if (!obj) {
        return;
    }
    functionInfo *fi = obj;
    sdsfree(fi->name);
    if (fi->desc) {
        sdsfree(fi->desc);
    }
    engine *engine = fi->li->ei->engine;
    engine->free_function(engine->engine_ctx, fi->function);
    zfree(fi);
}",143.0,156.0,1.0,4.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3832,133943,engineStatsDispose,1,engineStatsDispose,"void engineStatsDispose (dict*,void*)",functions.c,"static void engineStatsDispose(dict *d, void *obj) {
    UNUSED(d);
    functionsLibEngineStats *stats = obj;
    zfree(stats);
}",136.0,140.0,1.0,4.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3833,133949,engineLibraryDispose,1,engineLibraryDispose,"void engineLibraryDispose (dict*,void*)",functions.c,"static void engineLibraryDispose(dict *d, void *obj) {
    UNUSED(d);
    engineLibraryFree(obj);
}",168.0,171.0,1.0,4.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3834,133955,functionsVerifyName,1,functionsVerifyName,int functionsVerifyName (sds),functions.c,"static int functionsVerifyName(sds name) {
    if (sdslen(name) == 0) {
        return C_ERR;
    }
    for (size_t i = 0 ; i < sdslen(name) ; ++i) {
        char curr_char = name[i];
        if ((curr_char >= 'a' && curr_char <= 'z') ||
            (curr_char >= 'A' && curr_char <= 'Z') ||
            (curr_char >= '0' && curr_char <= '9') ||
            (curr_char == '_'))
        {
            continue;
        }
        return C_ERR;
    }
    return C_OK;
}",875.0,891.0,1.0,15.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
3835,134037,functionMallocSize,1,functionMallocSize,size_t functionMallocSize (functionInfo*),functions.c,"static size_t functionMallocSize(functionInfo *fi) {
    return zmalloc_size(fi) + sdsZmallocSize(fi->name)
            + (fi->desc ? sdsZmallocSize(fi->desc) : 0)
            + fi->li->ei->engine->get_function_memory_overhead(fi->function);
}",125.0,129.0,1.0,1.0,5.0,12,3,6,1,2,9,1,1,0,4,,0,5,2,1,1,size_t
3836,134074,libraryMallocSize,1,libraryMallocSize,size_t libraryMallocSize (functionLibInfo*),functions.c,"static size_t libraryMallocSize(functionLibInfo *li) {
    return zmalloc_size(li) + sdsZmallocSize(li->name)
            + sdsZmallocSize(li->code);
}",131.0,134.0,1.0,1.0,4.0,4,2,3,1,2,5,1,1,0,3,,0,2,2,1,1,size_t
3837,134166,engineLibraryFree,1,engineLibraryFree,void engineLibraryFree (functionLibInfo*),functions.c,"static void engineLibraryFree(functionLibInfo* li) {
    if (!li) {
        return;
    }
    dictRelease(li->functions);
    sdsfree(li->name);
    sdsfree(li->code);
    zfree(li);
}",158.0,166.0,1.0,1.0,9.0,4,2,5,1,3,7,2,2,0,4,,0,3,2,1,1,void
3838,134204,functionsLibCtxClear,1,functionsLibCtxClear,void functionsLibCtxClear (functionsLibCtx*),functions.c,"void functionsLibCtxClear(functionsLibCtx *lib_ctx) {
    dictEmpty(lib_ctx->functions, NULL);
    dictEmpty(lib_ctx->libraries, NULL);
    dictIterator *iter = dictGetIterator(lib_ctx->engines_stats);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionsLibEngineStats *stats = dictGetVal(entry);
        stats->n_functions = 0;
        stats->n_lib = 0;
    }
    dictReleaseIterator(iter);
    curr_functions_lib_ctx->cache_memory = 0;
}",174.0,186.0,1.0,1.0,13.0,13,2,16,6,2,13,2,2,1,6,,0,10,2,1,1,void
3839,134258,functionsLibCtxClearCurrent,1,functionsLibCtxClearCurrent,void functionsLibCtxClearCurrent (int),functions.c,"void functionsLibCtxClearCurrent(int async) {
    if (async) {
        functionsLibCtx *old_l_ctx = curr_functions_lib_ctx;
        curr_functions_lib_ctx = functionsLibCtxCreate();
        freeFunctionsAsync(old_l_ctx);
    } else {
        functionsLibCtxClear(curr_functions_lib_ctx);
    }
}",188.0,196.0,1.0,1.0,9.0,2,1,5,3,2,4,2,2,0,2,,0,3,2,1,1,void
3840,134279,functionsLibCtxFree,1,functionsLibCtxFree,void functionsLibCtxFree (functionsLibCtx*),functions.c,"void functionsLibCtxFree(functionsLibCtx *functions_lib_ctx) {
    functionsLibCtxClear(functions_lib_ctx);
    dictRelease(functions_lib_ctx->functions);
    dictRelease(functions_lib_ctx->libraries);
    dictRelease(functions_lib_ctx->engines_stats);
    zfree(functions_lib_ctx);
}",199.0,205.0,1.0,1.0,7.0,3,1,5,1,4,8,1,1,0,5,,0,3,2,1,1,void
3841,134300,functionsLibCtxSwapWithCurrent,1,functionsLibCtxSwapWithCurrent,void functionsLibCtxSwapWithCurrent (functionsLibCtx*),functions.c,"void functionsLibCtxSwapWithCurrent(functionsLibCtx *new_lib_ctx) {
    functionsLibCtxFree(curr_functions_lib_ctx);
    curr_functions_lib_ctx = new_lib_ctx;
}",209.0,212.0,1.0,1.0,4.0,1,1,3,2,2,3,1,1,0,1,,0,2,2,1,1,void
3842,134310,functionsLibCtxGetCurrent,1,functionsLibCtxGetCurrent,functionsLibCtx functionsLibCtxGetCurrent (void),functions.c,"functionsLibCtx* functionsLibCtxGetCurrent(void) {
    return curr_functions_lib_ctx;
}",215.0,217.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,0,,0,1,2,1,1,functionsLibCtx
3843,134317,functionsLibCtxCreate,1,functionsLibCtxCreate,functionsLibCtx functionsLibCtxCreate (void),functions.c,"functionsLibCtx* functionsLibCtxCreate(void) {
    functionsLibCtx *ret = zmalloc(sizeof(functionsLibCtx));
    ret->libraries = dictCreate(&librariesDictType);
    ret->functions = dictCreate(&functionDictType);
    ret->engines_stats = dictCreate(&engineStatsDictType);
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        engineInfo *ei = dictGetVal(entry);
        functionsLibEngineStats *stats = zcalloc(sizeof(*stats));
        dictAdd(ret->engines_stats, ei->name, stats);
    }
    dictReleaseIterator(iter);
    ret->cache_memory = 0;
    return ret;
}",220.0,235.0,1.0,1.0,16.0,22,5,24,11,4,20,2,2,1,10,,0,18,2,1,1,functionsLibCtx
3844,134393,functionLibCreateFunction,1,functionLibCreateFunction,"int functionLibCreateFunction (sds,void*,functionLibInfo*,sds,uint64_t,sds*)",functions.c,"int functionLibCreateFunction(sds name, void *function, functionLibInfo *li, sds desc, uint64_t f_flags, sds *err) {
    if (functionsVerifyName(name) != C_OK) {
        *err = sdsnew(""Library names can only contain letters, numbers, or underscores(_) and must be at least one character long"");
        return C_ERR;
    }

    if (dictFetchValue(li->functions, name)) {
        *err = sdsnew(""Function already exists in the library"");
        return C_ERR;
    }

    functionInfo *fi = zmalloc(sizeof(*fi));
    *fi = (functionInfo) {
        .name = name,
        .function = function,
        .li = li,
        .desc = desc,
        .f_flags = f_flags,
    };

    int res = dictAdd(li->functions, fi->name, fi);
    serverAssert(res == DICT_OK);

    return C_OK;
}",246.0,270.0,1.0,37.0,25.0,28,12,23,8,1,10,3,3,3,7,,0,9,12,6,6,int
3845,134502,engineLibraryCreate,1,engineLibraryCreate,"functionLibInfo engineLibraryCreate (sds,engineInfo*,sds)",functions.c,"static functionLibInfo* engineLibraryCreate(sds name, engineInfo *ei, sds code) {
    functionLibInfo *li = zmalloc(sizeof(*li));
    *li = (functionLibInfo) {
        .name = sdsdup(name),
        .functions = dictCreate(&libraryFunctionDictType),
        .ei = ei,
        .code = sdsdup(code),
    };
    return li;
}",272.0,281.0,1.0,1.0,10.0,12,6,12,6,1,5,1,1,0,4,,0,5,6,3,3,functionLibInfo
3846,134544,libraryUnlink,1,libraryUnlink,"void libraryUnlink (functionsLibCtx*,functionLibInfo*)",functions.c,"static void libraryUnlink(functionsLibCtx *lib_ctx, functionLibInfo* li) {
    dictIterator *iter = dictGetIterator(li->functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionInfo *fi = dictGetVal(entry);
        int ret = dictDelete(lib_ctx->functions, fi->name);
        serverAssert(ret == DICT_OK);
        lib_ctx->cache_memory -= functionMallocSize(fi);
    }
    dictReleaseIterator(iter);
    entry = dictUnlink(lib_ctx->libraries, li->name);
    dictSetVal(lib_ctx->libraries, entry, NULL);
    dictFreeUnlinkedEntry(lib_ctx->libraries, entry);
    lib_ctx->cache_memory -= libraryMallocSize(li);

    /* update stats */
    functionsLibEngineStats *stats = dictFetchValue(lib_ctx->engines_stats, li->ei->name);
    serverAssert(stats);
    stats->n_lib--;
    stats->n_functions -= dictSize(li->functions);
}",283.0,303.0,1.0,8.0,21.0,42,11,35,8,2,29,2,2,1,13,,0,22,4,2,2,void
3847,134687,libraryLink,1,libraryLink,"void libraryLink (functionsLibCtx*,functionLibInfo*)",functions.c,"static void libraryLink(functionsLibCtx *lib_ctx, functionLibInfo* li) {
    dictIterator *iter = dictGetIterator(li->functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionInfo *fi = dictGetVal(entry);
        dictAdd(lib_ctx->functions, fi->name, fi);
        lib_ctx->cache_memory += functionMallocSize(fi);
    }
    dictReleaseIterator(iter);

    dictAdd(lib_ctx->libraries, li->name, li);
    lib_ctx->cache_memory += libraryMallocSize(li);

    /* update stats */
    functionsLibEngineStats *stats = dictFetchValue(lib_ctx->engines_stats, li->ei->name);
    serverAssert(stats);
    stats->n_lib++;
    stats->n_functions += dictSize(li->functions);
}",305.0,323.0,1.0,4.0,19.0,33,10,29,7,4,24,2,2,1,10,,0,18,4,2,2,void
3848,134800,libraryJoin,1,libraryJoin,"int libraryJoin (functionsLibCtx*,functionsLibCtx*,int,sds*)",functions.c,"static int libraryJoin(functionsLibCtx *functions_lib_ctx_dst, functionsLibCtx *functions_lib_ctx_src, int replace, sds *err) {
    int ret = C_ERR;
    dictIterator *iter = NULL;
    /* Stores the libraries we need to replace in case a revert is required.
     * Only initialized when needed */
    list *old_libraries_list = NULL;
    dictEntry *entry = NULL;
    iter = dictGetIterator(functions_lib_ctx_src->libraries);
    while ((entry = dictNext(iter))) {
        functionLibInfo *li = dictGetVal(entry);
        functionLibInfo *old_li = dictFetchValue(functions_lib_ctx_dst->libraries, li->name);
        if (old_li) {
            if (!replace) {
                /* library already exists, failed the restore. */
                *err = sdscatfmt(sdsempty(), ""Library %s already exists"", li->name);
                goto done;
            } else {
                if (!old_libraries_list) {
                    old_libraries_list = listCreate();
                    listSetFreeMethod(old_li...",331.0,403.0,1.0,14.0,73.0,43,6,76,13,0,40,13,16,7,26,,0,29,8,4,4,int
3849,135043,functionsRegisterEngine,1,functionsRegisterEngine,"int functionsRegisterEngine (char*,engine*)",functions.c,"int functionsRegisterEngine(const char *engine_name, engine *engine) {
    sds engine_name_sds = sdsnew(engine_name);
    if (dictFetchValue(engines, engine_name_sds)) {
        serverLog(LL_WARNING, ""Same engine was registered twice"");
        sdsfree(engine_name_sds);
        return C_ERR;
    }

    client *c = createClient(NULL);
    c->flags |= (CLIENT_DENY_BLOCKING | CLIENT_SCRIPT);
    engineInfo *ei = zmalloc(sizeof(*ei));
    *ei = (engineInfo ) { .name = engine_name_sds, .engine = engine, .c = c,};

    dictAdd(engines, engine_name_sds, ei);

    engine_cache_memory += zmalloc_size(ei) + sdsZmallocSize(ei->name) +
            zmalloc_size(engine) +
            engine->get_engine_memory_overhead(engine->engine_ctx);

    return C_OK;
}",409.0,429.0,1.0,8.0,21.0,27,14,27,10,1,17,2,2,2,11,,0,10,4,2,2,int
3850,135157,functionStatsCommand,1,functionStatsCommand,void functionStatsCommand (client*),functions.c,"void functionStatsCommand(client *c) {
    if (scriptIsRunning() && scriptIsEval()) {
        addReplyErrorObject(c, shared.slowevalerr);
        return;
    }

    addReplyMapLen(c, 2);

    addReplyBulkCString(c, ""running_script"");
    if (!scriptIsRunning()) {
        addReplyNull(c);
    } else {
        addReplyMapLen(c, 3);
        addReplyBulkCString(c, ""name"");
        addReplyBulkCString(c, scriptCurrFunction());
        addReplyBulkCString(c, ""command"");
        client *script_client = scriptGetCaller();
        addReplyArrayLen(c, script_client->argc);
        for (int i = 0 ; i < script_client->argc ; ++i) {
            addReplyBulkCBuffer(c, script_client->argv[i]->ptr, sdslen(script_client->argv[i]->ptr));
        }
        addReplyBulkCString(c, ""duration_ms"");
        addReplyLongLong(c, scriptRunDuration());
    }

    addReplyBulkCString(c, ""engines"");
    addReplyMapLen(c, dictSize(engines));
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry ...",434.0,474.0,1.0,22.0,41.0,18,7,31,9,0,32,4,4,4,20,,0,19,2,1,1,void
3851,135320,functionListReplyFlags,1,functionListReplyFlags,"void functionListReplyFlags (client*,functionInfo*)",functions.c,"static void functionListReplyFlags(client *c, functionInfo *fi) {
    /* First count the number of flags we have */
    int flagcount = 0;
    for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
        if (fi->f_flags & flag->flag) {
            ++flagcount;
        }
    }

    addReplySetLen(c, flagcount);

    for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
        if (fi->f_flags & flag->flag) {
            addReplyStatus(c, flag->str);
        }
    }
}",476.0,492.0,1.0,1.0,17.0,13,4,16,5,1,4,5,7,2,2,,0,2,4,2,2,void
3852,135382,functionListCommand,1,functionListCommand,void functionListCommand (client*),functions.c,"void functionListCommand(client *c) {
    int with_code = 0;
    sds library_name = NULL;
    for (int i = 2 ; i < c->argc ; ++i) {
        robj *next_arg = c->argv[i];
        if (!with_code && !strcasecmp(next_arg->ptr, ""withcode"")) {
            with_code = 1;
            continue;
        }
        if (!library_name && !strcasecmp(next_arg->ptr, ""libraryname"")) {
            if (i >= c->argc - 1) {
                addReplyError(c, ""library name argument was not given"");
                return;
            }
            library_name = c->argv[++i]->ptr;
            continue;
        }
        addReplyErrorSds(c, sdscatfmt(sdsempty(), ""Unknown argument %s"", next_arg->ptr));
        return;
    }
    size_t reply_len = 0;
    void *len_ptr = NULL;
    if (library_name) {
        len_ptr = addReplyDeferredLen(c);
    } else {
        /* If no pattern is asked we know the reply len and we can just set it */
        addReplyArrayLen(c, dictSize(curr_functions_lib_ctx->libraries));
   ...",508.0,581.0,1.0,28.0,74.0,65,11,89,15,0,61,16,24,10,38,,0,40,2,1,1,void
3853,135707,functionDeleteCommand,1,functionDeleteCommand,void functionDeleteCommand (client*),functions.c,"void functionDeleteCommand(client *c) {
    robj *function_name = c->argv[2];
    functionLibInfo *li = dictFetchValue(curr_functions_lib_ctx->libraries, function_name->ptr);
    if (!li) {
        addReplyError(c, ""Library not found"");
        return;
    }

    libraryUnlink(curr_functions_lib_ctx, li);
    engineLibraryFree(li);
    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReply(c, shared.ok);
}",586.0,600.0,1.0,1.0,15.0,10,6,13,6,0,9,2,2,0,5,,0,5,2,1,1,void
3854,135752,functionKillCommand,1,functionKillCommand,void functionKillCommand (client*),functions.c,"void functionKillCommand(client *c) {
    scriptKill(c, 0);
}",603.0,605.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3855,135760,fcallGetCommandFlags,1,fcallGetCommandFlags,"uint64_t fcallGetCommandFlags (client*,uint64_t)",functions.c,"uint64_t fcallGetCommandFlags(client *c, uint64_t cmd_flags) {
    robj *function_name = c->argv[1];
    c->cur_script = dictFind(curr_functions_lib_ctx->functions, function_name->ptr);
    if (!c->cur_script)
        return cmd_flags;
    functionInfo *fi = dictGetVal(c->cur_script);
    uint64_t script_flags = fi->f_flags;
    return scriptFlagsToCmdFlags(cmd_flags, script_flags);
}",609.0,617.0,1.0,1.0,9.0,13,4,13,6,1,10,2,2,1,3,,0,9,4,2,2,uint64_t
3856,135810,fcallCommandGeneric,1,fcallCommandGeneric,"void fcallCommandGeneric (client*,int)",functions.c,"static void fcallCommandGeneric(client *c, int ro) {
    /* Functions need to be fed to monitors before the commands they execute. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);

    robj *function_name = c->argv[1];
    dictEntry *de = c->cur_script;
    if (!de)
        de = dictFind(curr_functions_lib_ctx->functions, function_name->ptr);
    if (!de) {
        addReplyError(c, ""Function not found"");
        return;
    }
    functionInfo *fi = dictGetVal(de);
    engine *engine = fi->li->ei->engine;

    long long numkeys;
    /* Get the number of arguments that are keys */
    if (getLongLongFromObject(c->argv[2], &numkeys) != C_OK) {
        addReplyError(c, ""Bad number of keys provided"");
        return;
    }
    if (numkeys > (c->argc - 3)) {
        addReplyError(c, ""Number of keys can't be greater than number of args"");
        return;
    } else if (numkeys < 0) {
        addReplyError(c, ""Number of keys can't be negative"");
        return;
 ...",619.0,656.0,1.0,55.0,38.0,47,10,42,10,2,28,6,6,7,10,,0,22,4,2,2,void
3857,135986,fcallCommand,1,fcallCommand,void fcallCommand (client*),functions.c,"void fcallCommand(client *c) {
    fcallCommandGeneric(c, 0);
}",661.0,663.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3858,135994,fcallroCommand,1,fcallroCommand,void fcallroCommand (client*),functions.c,"void fcallroCommand(client *c) {
    fcallCommandGeneric(c, 1);
}",668.0,670.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3859,136002,functionDumpCommand,1,functionDumpCommand,void functionDumpCommand (client*),functions.c,"void functionDumpCommand(client *c) {
    unsigned char buf[2];
    uint64_t crc;
    rio payload;
    rioInitWithBuffer(&payload, sdsempty());

    rdbSaveFunctions(&payload);

    /* RDB version */
    buf[0] = RDB_VERSION & 0xff;
    buf[1] = (RDB_VERSION >> 8) & 0xff;
    payload.io.buffer.ptr = sdscatlen(payload.io.buffer.ptr, buf, 2);

    /* CRC64 */
    crc = crc64(0, (unsigned char*) payload.io.buffer.ptr,
                sdslen(payload.io.buffer.ptr));
    memrev64ifbe(&crc);
    payload.io.buffer.ptr = sdscatlen(payload.io.buffer.ptr, &crc, 8);

    addReplyBulkSds(c, payload.io.buffer.ptr);
}",690.0,710.0,1.0,13.0,21.0,37,7,17,4,0,9,1,1,0,9,,0,5,2,1,1,void
3860,136111,functionRestoreCommand,1,functionRestoreCommand,void functionRestoreCommand (client*),functions.c,"void functionRestoreCommand(client *c) {
    if (c->argc > 4) {
        addReplySubcommandSyntaxError(c);
        return;
    }

    restorePolicy restore_replicy = restorePolicy_Append; /* default policy: APPEND */
    sds data = c->argv[2]->ptr;
    size_t data_len = sdslen(data);
    rio payload;
    sds err = NULL;

    if (c->argc == 4) {
        const char *restore_policy_str = c->argv[3]->ptr;
        if (!strcasecmp(restore_policy_str, ""append"")) {
            restore_replicy = restorePolicy_Append;
        } else if (!strcasecmp(restore_policy_str, ""replace"")) {
            restore_replicy = restorePolicy_Replace;
        } else if (!strcasecmp(restore_policy_str, ""flush"")) {
            restore_replicy = restorePolicy_Flush;
        } else {
            addReplyError(c, ""Wrong restore policy given, value should be either FLUSH, APPEND or REPLACE."");
            return;
        }
    }

    uint16_t rdbver;
    if (verifyDumpPayload((unsigned char*)data, data_len, &rdbver) ...",722.0,802.0,1.0,70.0,81.0,45,13,49,14,0,19,18,21,5,15,,0,13,2,1,1,void
3861,136358,functionFlushCommand,1,functionFlushCommand,void functionFlushCommand (client*),functions.c,"void functionFlushCommand(client *c) {
    if (c->argc > 3) {
        addReplySubcommandSyntaxError(c);
        return;
    }
    int async = 0;
    if (c->argc == 3 && !strcasecmp(c->argv[2]->ptr,""sync"")) {
        async = 0;
    } else if (c->argc == 3 && !strcasecmp(c->argv[2]->ptr,""async"")) {
        async = 1;
    } else if (c->argc == 2) {
        async = server.lazyfree_lazy_user_flush ? 1 : 0;
    } else {
        addReplyError(c,""FUNCTION FLUSH only supports SYNC|ASYNC option"");
        return;
    }

    functionsLibCtxClearCurrent(async);

    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReply(c,shared.ok);
}",805.0,828.0,1.0,1.0,24.0,14,9,10,4,0,6,3,3,3,3,,0,3,2,1,1,void
3862,136455,functionHelpCommand,1,functionHelpCommand,void functionHelpCommand (client*),functions.c,"void functionHelpCommand(client *c) {
    const char *help[] = {
""LOAD [REPLACE] <FUNCTION CODE>"",
""    Create a new library with the given library name and code."",
""DELETE <LIBRARY NAME>"",
""    Delete the given library."",
""LIST [LIBRARYNAME PATTERN] [WITHCODE]"",
""    Return general information on all the libraries:"",
""    * Library name"",
""    * The engine used to run the Library"",
""    * Library description"",
""    * Functions list"",
""    * Library code (if WITHCODE is given)"",
""    It also possible to get only function that matches a pattern using LIBRARYNAME argument."",
""STATS"",
""    Return information about the current function running:"",
""    * Function name"",
""    * Command used to run the function"",
""    * Duration in MS that the function is running"",
""    If no function is running, return nil"",
""    In addition, returns a list of available engines."",
""KILL"",
""    Kill the current running function."",
""FLUSH [ASYNC|SYNC]"",
""    Delete all the libraries."",
""    When called with...",831.0,872.0,1.0,1.0,42.0,2,2,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
3863,136579,functionExtractLibMetaData,1,functionExtractLibMetaData,"int functionExtractLibMetaData (sds,functionsLibMataData*,sds*)",functions.c,"int functionExtractLibMetaData(sds payload, functionsLibMataData *md, sds *err) {
    sds name = NULL;
    sds desc = NULL;
    sds engine = NULL;
    sds code = NULL;
    if (strncmp(payload, ""#!"", 2) != 0) {
        *err = sdsnew(""Missing library metadata"");
        return C_ERR;
    }
    char *shebang_end = strchr(payload, '\n');
    if (shebang_end == NULL) {
        *err = sdsnew(""Invalid library metadata"");
        return C_ERR;
    }
    size_t shebang_len = shebang_end - payload;
    sds shebang = sdsnewlen(payload, shebang_len);
    int numparts;
    sds *parts = sdssplitargs(shebang, &numparts);
    sdsfree(shebang);
    if (!parts || numparts == 0) {
        *err = sdsnew(""Invalid library metadata"");
        sdsfreesplitres(parts, numparts);
        return C_ERR;
    }
    engine = sdsdup(parts[0]);
    sdsrange(engine, 2, -1);
    for (int i = 1 ; i < numparts ; ++i) {
        sds part = parts[i];
        if (strncasecmp(part, ""name="", 5) == 0) {
            if (name) {...",893.0,954.0,1.0,15.0,62.0,49,12,69,15,1,27,16,15,0,24,,0,17,6,3,3,int
3864,136815,functionFreeLibMetaData,1,functionFreeLibMetaData,void functionFreeLibMetaData (functionsLibMataData*),functions.c,"void functionFreeLibMetaData(functionsLibMataData *md) {
    if (md->code) sdsfree(md->code);
    if (md->name) sdsfree(md->name);
    if (md->engine) sdsfree(md->engine);
}",956.0,960.0,1.0,1.0,5.0,6,1,6,1,2,9,4,4,3,3,,0,6,2,1,1,void
3865,136847,functionsCreateWithLibraryCtx,1,functionsCreateWithLibraryCtx,"sds functionsCreateWithLibraryCtx (sds,int,sds*,functionsLibCtx*)",functions.c,"sds functionsCreateWithLibraryCtx(sds code, int replace, sds* err, functionsLibCtx *lib_ctx) {
    dictIterator *iter = NULL;
    dictEntry *entry = NULL;
    functionLibInfo *new_li = NULL;
    functionLibInfo *old_li = NULL;
    functionsLibMataData md = {0};
    if (functionExtractLibMetaData(code, &md, err) != C_OK) {
        return NULL;
    }

    if (functionsVerifyName(md.name)) {
        *err = sdsnew(""Library names can only contain letters, numbers, or underscores(_) and must be at least one character long"");
        goto error;
    }

    engineInfo *ei = dictFetchValue(engines, md.engine);
    if (!ei) {
        *err = sdscatfmt(sdsempty(), ""Engine '%S' not found"", md.engine);
        goto error;
    }
    engine *engine = ei->engine;

    old_li = dictFetchValue(lib_ctx->libraries, md.name);
    if (old_li && !replace) {
        old_li = NULL;
        *err = sdscatfmt(sdsempty(), ""Library '%S' already exists"", md.name);
        goto error;
    }

    if (old_li) {
     ...",964.0,1038.0,1.0,54.0,75.0,61,12,80,15,2,47,20,15,13,27,,0,38,8,4,4,sds
3866,137107,functionLoadCommand,1,functionLoadCommand,void functionLoadCommand (client*),functions.c,"void functionLoadCommand(client *c) {
    int replace = 0;
    int argc_pos = 2;
    while (argc_pos < c->argc - 1) {
        robj *next_arg = c->argv[argc_pos++];
        if (!strcasecmp(next_arg->ptr, ""replace"")) {
            replace = 1;
            continue;
        }
        addReplyErrorFormat(c, ""Unknown option given: %s"", (char*)next_arg->ptr);
        return;
    }

    if (argc_pos >= c->argc) {
        addReplyError(c, ""Function code is missing"");
        return;
    }

    robj *code = c->argv[argc_pos];
    sds err = NULL;
    sds library_name = NULL;
    if (!(library_name = functionsCreateWithLibraryCtx(code->ptr, replace, &err, curr_functions_lib_ctx)))
    {
        addReplyErrorSds(c, err);
        return;
    }
    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReplyBulkSds(c, library_name);
}",1045.0,1075.0,1.0,1.0,31.0,27,11,31,10,0,10,6,6,4,5,,0,6,2,1,1,void
3867,137210,functionsMemory,1,functionsMemory,unsigned long functionsMemory (void),functions.c,"unsigned long functionsMemory(void) {
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry = NULL;
    size_t engines_nemory = 0;
    while ((entry = dictNext(iter))) {
        engineInfo *ei = dictGetVal(entry);
        engine *engine = ei->engine;
        engines_nemory += engine->get_used_memory(engine->engine_ctx);
    }
    dictReleaseIterator(iter);

    return engines_nemory;
}",1078.0,1090.0,1.0,1.0,13.0,10,3,16,7,1,8,2,2,1,5,,0,6,2,1,1,unsigned long
3868,137258,functionsMemoryOverhead,1,functionsMemoryOverhead,unsigned long functionsMemoryOverhead (void),functions.c,"unsigned long functionsMemoryOverhead(void) {
    size_t memory_overhead = dictMemUsage(engines);
    memory_overhead += dictMemUsage(curr_functions_lib_ctx->functions);
    memory_overhead += sizeof(functionsLibCtx);
    memory_overhead += curr_functions_lib_ctx->cache_memory;
    memory_overhead += engine_cache_memory;

    return memory_overhead;
}",1093.0,1101.0,1.0,1.0,9.0,8,4,11,5,1,8,1,1,0,2,,0,7,2,1,1,unsigned long
3869,137288,functionsNum,1,functionsNum,unsigned long functionsNum (void),functions.c,"unsigned long functionsNum(void) {
    return dictSize(curr_functions_lib_ctx->functions);
}",1104.0,1106.0,1.0,11.0,3.0,8,3,3,1,1,6,1,1,0,0,,0,6,2,1,1,unsigned long
3870,137314,functionsLibNum,1,functionsLibNum,unsigned long functionsLibNum (void),functions.c,"unsigned long functionsLibNum(void) {
    return dictSize(curr_functions_lib_ctx->libraries);
}",1108.0,1110.0,1.0,11.0,3.0,8,3,3,1,1,6,1,1,0,0,,0,6,2,1,1,unsigned long
3871,137340,functionsLibGet,1,functionsLibGet,dict functionsLibGet (void),functions.c,"dict* functionsLibGet(void) {
    return curr_functions_lib_ctx->libraries;
}",1112.0,1114.0,1.0,1.0,3.0,1,1,1,1,2,2,1,1,0,0,,0,2,2,1,1,dict
3872,137349,functionsLibCtxfunctionsLen,1,functionsLibCtxfunctionsLen,size_t functionsLibCtxfunctionsLen (functionsLibCtx*),functions.c,"size_t functionsLibCtxfunctionsLen(functionsLibCtx *functions_ctx) {
    return dictSize(functions_ctx->functions);
}",1116.0,1118.0,1.0,11.0,3.0,8,3,3,1,3,3,1,1,0,0,,0,3,2,1,1,size_t
3873,137375,functionsInit,1,functionsInit,int functionsInit (void),functions.c,"int functionsInit(void) {
    engines = dictCreate(&engineDictType);

    if (luaEngineInitEngine() != C_OK) {
        return C_ERR;
    }

    /* Must be initialized after engines initialization */
    curr_functions_lib_ctx = functionsLibCtxCreate();

    return C_OK;
}",1122.0,1133.0,1.0,33.0,12.0,5,4,3,3,1,6,2,2,1,3,,0,6,2,1,1,int
3874,137419,create,1,engine.create,"int engine.create (void*,functionLibInfo*,sds,sds*)",functions.h,"int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);",58.0,58.0,9.0,76.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
3875,137427,call,1,engine.call,"void engine.call (scriptRunCtx*,void*,void*,robj**,size_t,robj**,size_t)",server.c,"void call(client *c, int flags) {
    long long dirty;
    uint64_t client_old_flags = c->flags;
    struct redisCommand *real_cmd = c->realcmd;
    client *prev_client = server.executing_client;
    server.executing_client = c;

    /* When call() is issued during loading the AOF we don't want commands called
     * from module, exec or LUA to go into the slowlog or to populate statistics. */
    int update_command_stats = !isAOFLoadingContext();

    /* We want to be aware of a client which is making a first time attempt to execute this command
     * and a client which is reprocessing command again (after being unblocked).
     * Blocked clients can be blocked in different places and not always it means the call() function has been
     * called. For example this is required for avoiding double logging to monitors.*/
    int reprocessing_command = flags & CMD_CALL_REPROCESSING;

    /* Initialization: clear the flags that must be set by the command on
     * demand, and initializ...",3475.0,3694.0,1.0,32.0,220.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
3876,137438,get_used_memory,1,engine.get_used_memory,size_t engine.get_used_memory (void*),functions.h,size_t (*get_used_memory)(void *engine_ctx);,69.0,69.0,12.0,47.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
3877,137443,get_function_memory_overhead,1,engine.get_function_memory_overhead,size_t engine.get_function_memory_overhead (void*),functions.h,size_t (*get_function_memory_overhead)(void *compiled_function);,74.0,74.0,12.0,67.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
3878,137448,get_engine_memory_overhead,1,engine.get_engine_memory_overhead,size_t engine.get_engine_memory_overhead (void*),functions.h,size_t (*get_engine_memory_overhead)(void *engine_ctx);,77.0,77.0,12.0,58.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
3879,137453,free_function,1,engine.free_function,"void engine.free_function (void*,void*)",functions.h,"void (*free_function)(void *engine_ctx, void *compiled_function);",80.0,80.0,10.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3880,137584,zzlFirstInRange,1,zzlFirstInRange,"unsigned char* zzlFirstInRange (unsigned char*,zrangespec*)",t_zset.c,"unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;
    double score;

    /* If everything is out of range, return early. */
    if (!zzlIsInRange(zl,range)) return NULL;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueGteMin(score,range)) {
            /* Check if score <= max. */
            if (zslValueLteMax(score,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        eptr = lpNext(zl,sptr);
    }

    return NULL;
}",858.0,882.0,1.0,8.0,25.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,unsigned char*
3881,137590,zslValueLteMax,1,zslValueLteMax,"int zslValueLteMax (double,zrangespec*)",t_zset.c,"int zslValueLteMax(double value, zrangespec *spec) {
    return spec->maxex ? (value < spec->max) : (value <= spec->max);
}",310.0,312.0,1.0,1.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int
3882,137596,geoArrayCreate,1,geoArrayCreate,geoArray geoArrayCreate (void),geo.c,"geoArray *geoArrayCreate(void) {
    geoArray *ga = zmalloc(sizeof(*ga));
    /* It gets allocated on first geoArrayAppend() call. */
    ga->array = NULL;
    ga->buckets = 0;
    ga->used = 0;
    return ga;
}",54.0,61.0,1.0,1.0,8.0,9,4,7,2,1,4,1,1,0,1,,0,4,2,1,1,geoArray
3883,137625,geoArrayAppend,1,geoArrayAppend,"geoPoint geoArrayAppend (geoArray*,double*,double,double,char*)",geo.c,"geoPoint *geoArrayAppend(geoArray *ga, double *xy, double dist,
                         double score, char *member)
{
    if (ga->used == ga->buckets) {
        ga->buckets = (ga->buckets == 0) ? 8 : ga->buckets*2;
        ga->array = zrealloc(ga->array,sizeof(geoPoint)*ga->buckets);
    }
    geoPoint *gp = ga->array+ga->used;
    gp->longitude = xy[0];
    gp->latitude = xy[1];
    gp->dist = dist;
    gp->member = member;
    gp->score = score;
    ga->used++;
    return gp;
}",64.0,79.0,1.0,1.0,16.0,34,9,24,7,1,17,2,2,2,1,,0,17,10,5,5,geoPoint
3884,137718,geoArrayFree,1,geoArrayFree,void geoArrayFree (geoArray*),geo.c,"void geoArrayFree(geoArray *ga) {
    size_t i;
    for (i = 0; i < ga->used; i++) sdsfree(ga->array[i].member);
    zfree(ga->array);
    zfree(ga);
}",82.0,87.0,1.0,1.0,6.0,4,3,5,2,2,4,2,2,1,2,,0,2,2,1,1,void
3885,137750,decodeGeohash,1,decodeGeohash,"int decodeGeohash (double,double*)",geo.c,"int decodeGeohash(double bits, double *xy) {
    GeoHashBits hash = { .bits = (uint64_t)bits, .step = GEO_STEP_MAX };
    return geohashDecodeToLongLatWGS84(hash, xy);
}",92.0,95.0,1.0,57.0,4.0,5,3,6,4,4,1,1,1,0,1,,0,0,4,2,2,int
3886,137776,extractLongLatOrReply,1,extractLongLatOrReply,"int extractLongLatOrReply (client*,robj**,double*)",geo.c,"int extractLongLatOrReply(client *c, robj **argv, double *xy) {
    int i;
    for (i = 0; i < 2; i++) {
        if (getDoubleFromObjectOrReply(c, argv[i], xy + i, NULL) !=
            C_OK) {
            return C_ERR;
        }
    }
    if (xy[0] < GEO_LONG_MIN || xy[0] > GEO_LONG_MAX ||
        xy[1] < GEO_LAT_MIN  || xy[1] > GEO_LAT_MAX) {
        addReplyErrorFormat(c,
            ""-ERR invalid longitude,latitude pair %f,%f\r\n"",xy[0],xy[1]);
        return C_ERR;
    }
    return C_OK;
}",100.0,115.0,1.0,12.0,16.0,22,8,15,5,2,2,4,5,1,2,,0,1,6,3,3,int
3887,137868,longLatFromMember,1,longLatFromMember,"int longLatFromMember (robj*,robj*,double*)",geo.c,"int longLatFromMember(robj *zobj, robj *member, double *xy) {
    double score = 0;

    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
    if (!decodeGeohash(score, xy)) return C_ERR;
    return C_OK;
}",120.0,126.0,1.0,48.0,7.0,8,6,6,4,0,2,3,3,2,2,,0,2,6,3,3,int
3888,137913,extractUnitOrReply,1,extractUnitOrReply,"double extractUnitOrReply (client*,robj*)",geo.c,"double extractUnitOrReply(client *c, robj *unit) {
    char *u = unit->ptr;

    if (!strcasecmp(u, ""m"")) {
        return 1;
    } else if (!strcasecmp(u, ""km"")) {
        return 1000;
    } else if (!strcasecmp(u, ""ft"")) {
        return 0.3048;
    } else if (!strcasecmp(u, ""mi"")) {
        return 1609.34;
    } else {
        addReplyError(c,
            ""unsupported unit provided. please use M, KM, FT, MI"");
        return -1;
    }
}",134.0,150.0,1.0,1.0,17.0,3,3,3,2,3,0,2,2,0,0,,0,0,4,2,2,double
3889,137971,extractDistanceOrReply,1,extractDistanceOrReply,"int extractDistanceOrReply (client*,robj**,double*,double*)",geo.c,"int extractDistanceOrReply(client *c, robj **argv,
                              double *conversion, double *radius) {
    double distance;
    if (getDoubleFromObjectOrReply(c, argv[0], &distance,
                                   ""need numeric radius"") != C_OK) {
        return C_ERR;
    }

    if (distance < 0) {
        addReplyError(c,""radius cannot be negative"");
        return C_ERR;
    }
    if (radius) *radius = distance;

    double to_meters = extractUnitOrReply(c,argv[1]);
    if (to_meters < 0) {
        return C_ERR;
    }

    if (conversion) *conversion = to_meters;
    return C_OK;
}",156.0,177.0,1.0,61.0,22.0,14,7,15,6,1,3,6,6,1,3,,0,2,8,4,4,int
3890,138048,extractBoxOrReply,1,extractBoxOrReply,"int extractBoxOrReply (client*,robj**,double*,double*,double*)",geo.c,"int extractBoxOrReply(client *c, robj **argv, double *conversion,
                         double *width, double *height) {
    double h, w;
    if ((getDoubleFromObjectOrReply(c, argv[0], &w, ""need numeric width"") != C_OK) ||
        (getDoubleFromObjectOrReply(c, argv[1], &h, ""need numeric height"") != C_OK)) {
        return C_ERR;
    }

    if (h < 0 || w < 0) {
        addReplyError(c, ""height or width cannot be negative"");
        return C_ERR;
    }
    if (height) *height = h;
    if (width) *width = w;

    double to_meters = extractUnitOrReply(c,argv[2]);
    if (to_meters < 0) {
        return C_ERR;
    }

    if (conversion) *conversion = to_meters;
    return C_OK;
}",183.0,205.0,1.0,77.0,23.0,22,8,22,8,0,4,7,7,2,4,,0,3,10,5,5,int
3891,138151,addReplyDoubleDistance,1,addReplyDoubleDistance,"void addReplyDoubleDistance (client*,double)",geo.c,"void addReplyDoubleDistance(client *c, double d) {
    char dbuf[128];
    const int dlen = fixedpoint_d2string(dbuf, sizeof(dbuf), d, 4);
    addReplyBulkCBuffer(c, dbuf, dlen);
}",212.0,216.0,1.0,1.0,5.0,2,2,7,4,1,2,1,1,0,2,,0,1,4,2,2,void
3892,138171,geoWithinShape,1,geoWithinShape,"int geoWithinShape (GeoShape*,double,double*,double*)",geo.c,"int geoWithinShape(GeoShape *shape, double score, double *xy, double *distance) {
    if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */
    /* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in
     * reverse order: longitude first, latitude later. */
    if (shape->type == CIRCULAR_TYPE) {
        if (!geohashGetDistanceIfInRadiusWGS84(shape->xy[0], shape->xy[1], xy[0], xy[1],
                                               shape->t.radius*shape->conversion, distance))
            return C_ERR;
    } else if (shape->type == RECTANGLE_TYPE) {
        if (!geohashGetDistanceIfInRectangle(shape->t.r.width * shape->conversion,
                                             shape->t.r.height * shape->conversion,
                                             shape->xy[0], shape->xy[1], xy[0], xy[1], distance))
            return C_ERR;
    }
    return C_OK;
}",232.0,247.0,1.0,41.0,16.0,16,7,10,4,1,7,4,5,7,2,,0,7,8,4,4,int
3893,138297,geoGetPointsInRange,1,geoGetPointsInRange,"int geoGetPointsInRange (robj*,double,double,GeoShape*,geoArray*,long unsigned)",geo.c,"int geoGetPointsInRange(robj *zobj, double min, double max, GeoShape *shape, geoArray *ga, unsigned long limit) {
    /* minex 0 = include min in range; maxex 1 = exclude max in range */
    /* That's: min <= val < max */
    zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };
    size_t origincount = ga->used;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr = NULL;
        unsigned int vlen = 0;
        long long vlong = 0;
        double score = 0;

        if ((eptr = zzlFirstInRange(zl, &range)) == NULL) {
            /* Nothing exists starting at our min.  No results. */
            return 0;
        }

        sptr = lpNext(zl, eptr);
        while (eptr) {
            double xy[2];
            double distance = 0;
            score = zzlGetScore(sptr);

            /* If we fell out of range, break. */
            if (!zslValueLteMax(score, &range))
   ...",261.0,323.0,1.0,26.0,63.0,41,10,58,21,1,14,9,15,5,10,,0,12,12,6,6,int
3894,138569,scoresOfGeoHashBox,1,scoresOfGeoHashBox,"void scoresOfGeoHashBox (GeoHashBits,GeoHashFix52Bits*,GeoHashFix52Bits*)",geo.c,"void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) {
    /* We want to compute the sorted set scores that will include all the
     * elements inside the specified Geohash 'hash', which has as many
     * bits as specified by hash.step * 2.
     *
     * So if step is, for example, 3, and the hash value in binary
     * is 101010, since our score is 52 bits we want every element which
     * is in binary: 101010?????????????????????????????????????????????
     * Where ? can be 0 or 1.
     *
     * To get the min score we just use the initial hash value left
     * shifted enough to get the 52 bit value. Later we increment the
     * 6 bit prefix (see the hash.bits++ statement), and get the new
     * prefix: 101011, which we align again to 52 bits to get the maximum
     * value (which is excluded from the search). So we get everything
     * between the two following scores (represented in binary):
     *
     * 1010100000000000000000000000000...",328.0,352.0,1.0,1.0,25.0,6,4,5,3,1,3,1,1,0,2,,0,3,6,3,3,void
3895,138590,membersOfGeoHashBox,1,membersOfGeoHashBox,"int membersOfGeoHashBox (robj*,GeoHashBits,geoArray*,GeoShape*,long unsigned)",geo.c,"int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, GeoShape *shape, unsigned long limit) {
    GeoHashFix52Bits min, max;

    scoresOfGeoHashBox(hash,&min,&max);
    return geoGetPointsInRange(zobj, min, max, shape, ga, limit);
}",357.0,362.0,1.0,1.0,6.0,2,1,9,7,1,2,1,1,0,2,,0,0,10,5,5,int
3896,138615,membersOfAllNeighbors,1,membersOfAllNeighbors,"int membersOfAllNeighbors (robj*,GeoHashRadius*,GeoShape*,geoArray*,long unsigned)",geo.c,"int membersOfAllNeighbors(robj *zobj, const GeoHashRadius *n, GeoShape *shape, geoArray *ga, unsigned long limit) {
    GeoHashBits neighbors[9];
    unsigned int i, count = 0, last_processed = 0;
    int debugmsg = 0;

    neighbors[0] = n->hash;
    neighbors[1] = n->neighbors.north;
    neighbors[2] = n->neighbors.south;
    neighbors[3] = n->neighbors.east;
    neighbors[4] = n->neighbors.west;
    neighbors[5] = n->neighbors.north_east;
    neighbors[6] = n->neighbors.north_west;
    neighbors[7] = n->neighbors.south_east;
    neighbors[8] = n->neighbors.south_west;

    /* For each neighbor (*and* our own hashbox), get all the matching
     * members and add them to the potential result list. */
    for (i = 0; i < sizeof(neighbors) / sizeof(*neighbors); i++) {
        if (HASHISZERO(neighbors[i])) {
            if (debugmsg) D(""neighbors[%d] is zero"",i);
            continue;
        }

        /* Debugging info. */
        if (debugmsg) {
            GeoHashRange long_range,...",365.0,421.0,1.0,12.0,57.0,95,15,120,23,1,18,11,16,2,3,,0,15,10,5,5,int
3897,139073,sort_gp_asc,1,sort_gp_asc,"int sort_gp_asc (void*,void*)",geo.c,"static int sort_gp_asc(const void *a, const void *b) {
    const struct geoPoint *gpa = a, *gpb = b;
    /* We can't do adist - bdist because they are doubles and
     * the comparator returns an int. */
    if (gpa->dist > gpb->dist)
        return 1;
    else if (gpa->dist == gpb->dist)
        return 0;
    else
        return -1;
}",424.0,434.0,1.0,1.0,11.0,5,3,6,4,1,2,2,2,2,0,,0,2,4,2,2,int
3898,139116,sort_gp_desc,1,sort_gp_desc,"int sort_gp_desc (void*,void*)",geo.c,"static int sort_gp_desc(const void *a, const void *b) {
    return -sort_gp_asc(a, b);
}",436.0,438.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
3899,139127,geoaddCommand,1,geoaddCommand,void geoaddCommand (client*),geo.c,"void geoaddCommand(client *c) {
    int xx = 0, nx = 0, longidx = 2;
    int i;

    /* Parse options. At the end 'longidx' is set to the argument position
     * of the longitude of the first element. */
    while (longidx < c->argc) {
        char *opt = c->argv[longidx]->ptr;
        if (!strcasecmp(opt,""nx"")) nx = 1;
        else if (!strcasecmp(opt,""xx"")) xx = 1;
        else if (!strcasecmp(opt,""ch"")) { /* Handle in zaddCommand. */ }
        else break;
        longidx++;
    }

    if ((c->argc - longidx) % 3 || (xx && nx)) {
        /* Need an odd number of arguments if we got this far... */
            addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Set up the vector for calling ZADD. */
    int elements = (c->argc - longidx) / 3;
    int argc = longidx+elements*2; /* ZADD key [CH] [NX|XX] score ele ... */
    robj **argv = zcalloc(argc*sizeof(robj*));
    argv[0] = createRawStringObject(""zadd"",4);
    for (i = 1; i < longidx; i++) {
        argv[i] =...",445.0,503.0,1.0,68.0,59.0,67,18,72,16,0,19,8,12,4,12,,0,12,2,1,1,void
3900,139389,georadiusGeneric,1,georadiusGeneric,"void georadiusGeneric (client*,int,int)",geo.c,"void georadiusGeneric(client *c, int srcKeyIndex, int flags) {
    robj *storekey = NULL;
    int storedist = 0; /* 0 for STORE, 1 for STOREDIST. */

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[srcKeyIndex]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Find long/lat to use for radius or box search based on inquiry type */
    int base_args;
    GeoShape shape = {0};
    if (flags & RADIUS_COORDS) {
        /* GEORADIUS or GEORADIUS_RO */
        base_args = 6;
        shape.type = CIRCULAR_TYPE;
        if (extractLongLatOrReply(c, c->argv + 2, shape.xy) == C_ERR) return;
        if (extractDistanceOrReply(c, c->argv+base_args-2, &shape.conversion, &shape.t.radius) != C_OK) return;
    } else if ((flags & RADIUS_MEMBER) && !zobj) {
        /* We don't have a source key, but we need to proceed with argument
         * parsing, so we know which reply to use depending on the STORE flag. */
        base_args = 5;
    } else if (flags & RA...",523.0,844.0,1.0,27.0,322.0,137,23,152,32,6,54,29,51,12,26,,0,35,6,3,3,void
3901,140434,sort_gp_callback,1,georadiusGeneric.sort_gp_callback,"int georadiusGeneric.sort_gp_callback (void*,void*)",geo.c,"int (*sort_gp_callback)(const void *a, const void *b) = NULL;",741.0,741.0,13.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
3902,140793,georadiusCommand,1,georadiusCommand,void georadiusCommand (client*),geo.c,"void georadiusCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_COORDS);
}",847.0,849.0,1.0,27.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3903,140806,georadiusbymemberCommand,1,georadiusbymemberCommand,void georadiusbymemberCommand (client*),geo.c,"void georadiusbymemberCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_MEMBER);
}",852.0,854.0,1.0,27.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3904,140819,georadiusroCommand,1,georadiusroCommand,void georadiusroCommand (client*),geo.c,"void georadiusroCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_COORDS|RADIUS_NOSTORE);
}",857.0,859.0,1.0,27.0,3.0,3,2,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3905,140838,georadiusbymemberroCommand,1,georadiusbymemberroCommand,void georadiusbymemberroCommand (client*),geo.c,"void georadiusbymemberroCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_MEMBER|RADIUS_NOSTORE);
}",862.0,864.0,1.0,27.0,3.0,3,2,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3906,140857,geosearchCommand,1,geosearchCommand,void geosearchCommand (client*),geo.c,"void geosearchCommand(client *c) {
    georadiusGeneric(c, 1, GEOSEARCH);
}",866.0,868.0,1.0,27.0,3.0,1,1,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3907,140870,geosearchstoreCommand,1,geosearchstoreCommand,void geosearchstoreCommand (client*),geo.c,"void geosearchstoreCommand(client *c) {
    georadiusGeneric(c, 2, GEOSEARCH|GEOSEARCHSTORE);
}",870.0,872.0,1.0,27.0,3.0,3,2,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
3908,140889,geohashCommand,1,geohashCommand,void geohashCommand (client*),geo.c,"void geohashCommand(client *c) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Geohash elements one after the other, using a null bulk reply for
     * missing elements. */
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(c);
        } else {
            /* The internal format we use for geocoding is a bit different
             * than the standard, since we use as initial latitude range
             * -85,85, while the normal geohashing algorithm uses -90,90.
             * So we have to decode our position and re-encode using the
             * standard ranges in order to output a valid geohash string. */

            /* Decode... */
            double xy[2];
            if (!...",878.0,934.0,1.0,27.0,57.0,18,10,17,5,0,10,4,5,4,5,,0,8,2,1,1,void
3909,141081,geoposCommand,1,geoposCommand,void geoposCommand (client*),geo.c,"void geoposCommand(client *c) {
    int j;

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Report elements one after the other, using a null bulk reply for
     * missing elements. */
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNullArray(c);
        } else {
            /* Decode... */
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNullArray(c);
                continue;
            }
            addReplyArrayLen(c,2);
            addReplyHumanLongDouble(c,xy[0]);
            addReplyHumanLongDouble(c,xy[1]);
        }
    }
}",940.0,966.0,1.0,27.0,27.0,17,10,16,4,0,10,4,5,4,5,,0,8,2,1,1,void
3910,141177,geodistCommand,1,geodistCommand,void geodistCommand (client*),geo.c,"void geodistCommand(client *c) {
    double to_meter = 1;

    /* Check if there is the unit to extract, otherwise assume meters. */
    if (c->argc == 5) {
        to_meter = extractUnitOrReply(c,c->argv[4]);
        if (to_meter < 0) return;
    } else if (c->argc > 5) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Look up the requested zset */
    robj *zobj = NULL;
    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.null[c->resp]))
        == NULL || checkType(c, zobj, OBJ_ZSET)) return;

    /* Get the scores. We need both otherwise NULL is returned. */
    double score1, score2, xyxy[4];
    if (zsetScore(zobj, c->argv[2]->ptr, &score1) == C_ERR ||
        zsetScore(zobj, c->argv[3]->ptr, &score2) == C_ERR)
    {
        addReplyNull(c);
        return;
    }

    /* Decode & compute the distance. */
    if (!decodeGeohash(score1,xyxy) || !decodeGeohash(score2,xyxy+2))
        addReplyNull(c);
    else
        addReplyDoubleDistance(c,
...",973.0,1005.0,1.0,38.0,33.0,33,11,28,8,0,15,6,7,11,9,,0,13,2,1,1,void
3911,141357,interleave64,1,interleave64,"uint64_t interleave64 (uint32_t,uint32_t)",geohash.c,"static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                 0x0000FFFF0000FFFFULL};
    static const unsigned int S[] = {1, 2, 4, 8, 16};

    uint64_t x = xlo;
    uint64_t y = ylo;

    x = (x | (x << S[4])) & B[4];
    y = (y | (y << S[4])) & B[4];

    x = (x | (x << S[3])) & B[3];
    y = (y | (y << S[3])) & B[3];

    x = (x | (x << S[2])) & B[2];
    y = (y | (y << S[2])) & B[2];

    x = (x | (x << S[1])) & B[1];
    y = (y | (y << S[1])) & B[1];

    x = (x | (x << S[0])) & B[0];
    y = (y | (y << S[0])) & B[0];

    return x | (y << 1);
}",52.0,77.0,1.0,1.0,26.0,68,6,58,6,1,0,1,1,0,0,,0,0,4,2,2,uint64_t
3912,141525,deinterleave64,1,deinterleave64,uint64_t deinterleave64 (uint64_t),geohash.c,"static inline uint64_t deinterleave64(uint64_t interleaved) {
    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                 0x0000FFFF0000FFFFULL, 0x00000000FFFFFFFFULL};
    static const unsigned int S[] = {0, 1, 2, 4, 8, 16};

    uint64_t x = interleaved;
    uint64_t y = interleaved >> 1;

    x = (x | (x >> S[0])) & B[0];
    y = (y | (y >> S[0])) & B[0];

    x = (x | (x >> S[1])) & B[1];
    y = (y | (y >> S[1])) & B[1];

    x = (x | (x >> S[2])) & B[2];
    y = (y | (y >> S[2])) & B[2];

    x = (x | (x >> S[3])) & B[3];
    y = (y | (y >> S[3])) & B[3];

    x = (x | (x >> S[4])) & B[4];
    y = (y | (y >> S[4])) & B[4];

    x = (x | (x >> S[5])) & B[5];
    y = (y | (y >> S[5])) & B[5];

    return x | (y << 32);
}",82.0,110.0,1.0,1.0,29.0,81,7,68,5,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
3913,141722,geohashGetCoordRange,1,geohashGetCoordRange,"void geohashGetCoordRange (GeoHashRange*,GeoHashRange*)",geohash.c,"void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {
    /* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */
    /* We can't geocode at the north/south pole. */
    long_range->max = GEO_LONG_MAX;
    long_range->min = GEO_LONG_MIN;
    lat_range->max = GEO_LAT_MAX;
    lat_range->min = GEO_LAT_MIN;
}",112.0,119.0,1.0,22.0,8.0,10,3,4,2,4,4,1,1,0,0,,0,4,4,2,2,void
3914,141758,geohashEncode,1,geohashEncode,"int geohashEncode (GeoHashRange*,GeoHashRange*,double,double,uint8_t,GeoHashBits*)",geohash.c,"int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
                  double longitude, double latitude, uint8_t step,
                  GeoHashBits *hash) {
    /* Check basic arguments sanity. */
    if (hash == NULL || step > 32 || step == 0 ||
        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) return 0;

    /* Return an error when trying to index outside the supported
     * constraints. */
    if (longitude > GEO_LONG_MAX || longitude < GEO_LONG_MIN ||
        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) return 0;

    hash->bits = 0;
    hash->step = step;

    if (latitude < lat_range->min || latitude > lat_range->max ||
        longitude < long_range->min || longitude > long_range->max) {
        return 0;
    }

    double lat_offset =
        (latitude - lat_range->min) / (lat_range->max - lat_range->min);
    double long_offset =
        (longitude - long_range->min) / (long_range->max - long_range->min);

    /* convert to fix...",121.0,151.0,1.0,8.0,31.0,69,15,46,9,3,14,4,4,4,1,,0,14,12,6,6,int
3915,141938,geohashEncodeType,1,geohashEncodeType,"int geohashEncodeType (double,double,uint8_t,GeoHashBits*)",geohash.c,"int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {
    GeoHashRange r[2] = {{0}};
    geohashGetCoordRange(&r[0], &r[1]);
    return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
}",153.0,157.0,1.0,1.0,5.0,11,4,9,5,1,2,1,1,0,2,,0,0,8,4,4,int
3916,141975,geohashEncodeWGS84,1,geohashEncodeWGS84,"int geohashEncodeWGS84 (double,double,uint8_t,GeoHashBits*)",geohash.c,"int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
                       GeoHashBits *hash) {
    return geohashEncodeType(longitude, latitude, step, hash);
}",159.0,162.0,1.0,1.0,4.0,0,0,4,4,1,1,1,1,0,1,,0,0,8,4,4,int
3917,141989,geohashDecode,1,geohashDecode,"int geohashDecode (GeoHashRange,GeoHashRange,GeoHashBits,GeoHashArea*)",geohash.c,"int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
                   const GeoHashBits hash, GeoHashArea *area) {
    if (HASHISZERO(hash) || NULL == area || RANGEISZERO(lat_range) ||
        RANGEISZERO(long_range)) {
        return 0;
    }

    area->hash = hash;
    uint8_t step = hash.step;
    uint64_t hash_sep = deinterleave64(hash.bits); /* hash = [LAT][LONG] */

    double lat_scale = lat_range.max - lat_range.min;
    double long_scale = long_range.max - long_range.min;

    uint32_t ilato = hash_sep;       /* get lat part of deinterleaved hash */
    uint32_t ilono = hash_sep >> 32; /* shift over to get long part of hash */

    /* divide by 2**step.
     * Then, for 0-1 coordinate, multiply times scale and add
       to the min to get the absolute coordinate. */
    area->latitude.min =
        lat_range.min + (ilato * 1.0 / (1ull << step)) * lat_scale;
    area->latitude.max =
        lat_range.min + ((ilato + 1) * 1.0 / (1ull << step)) * la...",164.0,194.0,1.0,8.0,31.0,74,13,47,11,8,22,2,2,6,1,,0,22,8,4,4,int
3918,142173,geohashDecodeType,1,geohashDecodeType,"int geohashDecodeType (GeoHashBits,GeoHashArea*)",geohash.c,"int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {
    GeoHashRange r[2] = {{0}};
    geohashGetCoordRange(&r[0], &r[1]);
    return geohashDecode(r[0], r[1], hash, area);
}",196.0,200.0,1.0,1.0,5.0,9,4,7,3,2,2,1,1,0,2,,0,0,4,2,2,int
3919,142204,geohashDecodeWGS84,1,geohashDecodeWGS84,"int geohashDecodeWGS84 (GeoHashBits,GeoHashArea*)",geohash.c,"int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {
    return geohashDecodeType(hash, area);
}",202.0,204.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
3920,142214,geohashDecodeAreaToLongLat,1,geohashDecodeAreaToLongLat,"int geohashDecodeAreaToLongLat (GeoHashArea*,double*)",geohash.c,"int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {
    if (!xy) return 0;
    xy[0] = (area->longitude.min + area->longitude.max) / 2;
    if (xy[0] > GEO_LONG_MAX) xy[0] = GEO_LONG_MAX;
    if (xy[0] < GEO_LONG_MIN) xy[0] = GEO_LONG_MIN;
    xy[1] = (area->latitude.min + area->latitude.max) / 2;
    if (xy[1] > GEO_LAT_MAX) xy[1] = GEO_LAT_MAX;
    if (xy[1] < GEO_LAT_MIN) xy[1] = GEO_LAT_MIN;
    return 1;
}",206.0,215.0,1.0,16.0,10.0,37,10,15,2,1,4,6,6,0,0,,0,4,4,2,2,int
3921,142330,geohashDecodeToLongLatType,1,geohashDecodeToLongLatType,"int geohashDecodeToLongLatType (GeoHashBits,double*)",geohash.c,"int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {
    GeoHashArea area = {{0}};
    if (!xy || !geohashDecodeType(hash, &area))
        return 0;
    return geohashDecodeAreaToLongLat(&area, xy);
}",217.0,222.0,1.0,1.0,6.0,8,5,6,3,1,2,2,2,1,2,,0,1,4,2,2,int
3922,142359,geohashDecodeToLongLatWGS84,1,geohashDecodeToLongLatWGS84,"int geohashDecodeToLongLatWGS84 (GeoHashBits,double*)",geohash.c,"int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {
    return geohashDecodeToLongLatType(hash, xy);
}",224.0,226.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
3923,142369,geohash_move_x,1,geohash_move_x,"void geohash_move_x (GeoHashBits*,int8_t)",geohash.c,"static void geohash_move_x(GeoHashBits *hash, int8_t d) {
    if (d == 0)
        return;

    uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
    uint64_t y = hash->bits & 0x5555555555555555ULL;

    uint64_t zz = 0x5555555555555555ULL >> (64 - hash->step * 2);

    if (d > 0) {
        x = x + (zz + 1);
    } else {
        x = x | zz;
        x = x - (zz + 1);
    }

    x &= (0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2));
    hash->bits = (x | y);
}",228.0,246.0,1.0,1.0,19.0,23,10,16,5,8,5,3,3,0,0,,0,5,4,2,2,void
3924,142453,geohash_move_y,1,geohash_move_y,"void geohash_move_y (GeoHashBits*,int8_t)",geohash.c,"static void geohash_move_y(GeoHashBits *hash, int8_t d) {
    if (d == 0)
        return;

    uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
    uint64_t y = hash->bits & 0x5555555555555555ULL;

    uint64_t zz = 0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2);
    if (d > 0) {
        y = y + (zz + 1);
    } else {
        y = y | zz;
        y = y - (zz + 1);
    }
    y &= (0x5555555555555555ULL >> (64 - hash->step * 2));
    hash->bits = (x | y);
}",248.0,264.0,1.0,1.0,17.0,23,10,16,5,8,5,3,3,0,0,,0,5,4,2,2,void
3925,142537,geohashNeighbors,1,geohashNeighbors,"void geohashNeighbors (GeoHashBits*,GeoHashNeighbors*)",geohash.c,"void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
    neighbors->east = *hash;
    neighbors->west = *hash;
    neighbors->north = *hash;
    neighbors->south = *hash;
    neighbors->south_east = *hash;
    neighbors->south_west = *hash;
    neighbors->north_east = *hash;
    neighbors->north_west = *hash;

    geohash_move_x(&neighbors->east, 1);
    geohash_move_y(&neighbors->east, 0);

    geohash_move_x(&neighbors->west, -1);
    geohash_move_y(&neighbors->west, 0);

    geohash_move_x(&neighbors->south, 0);
    geohash_move_y(&neighbors->south, -1);

    geohash_move_x(&neighbors->north, 0);
    geohash_move_y(&neighbors->north, 1);

    geohash_move_x(&neighbors->north_west, -1);
    geohash_move_y(&neighbors->north_west, 1);

    geohash_move_x(&neighbors->north_east, 1);
    geohash_move_y(&neighbors->north_east, 1);

    geohash_move_x(&neighbors->south_east, 1);
    geohash_move_y(&neighbors->south_east, -1);

    geohash_move_x(&neighbors->sout...",266.0,299.0,1.0,1.0,34.0,62,5,32,2,2,40,1,1,0,16,,0,24,4,2,2,void
3926,142869,deg_rad,1,deg_rad,double deg_rad (double),geohash_helper.c,static inline double deg_rad(double ang) { return ang * D_R; },57.0,57.0,1.0,56.0,1.0,2,2,2,2,8,0,1,1,0,0,,0,0,2,1,1,double
3927,142882,rad_deg,1,rad_deg,double rad_deg (double),geohash_helper.c,static inline double rad_deg(double ang) { return ang / D_R; },58.0,58.0,1.0,56.0,1.0,2,1,2,2,3,0,1,1,0,0,,0,0,2,1,1,double
3928,142895,geohashEstimateStepsByRadius,1,geohashEstimateStepsByRadius,"uint8_t geohashEstimateStepsByRadius (double,double)",geohash_helper.c,"uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
    if (range_meters == 0) return 26;
    int step = 1;
    while (range_meters < MERCATOR_MAX) {
        range_meters *= 2;
        step++;
    }
    step -= 2; /* Make sure range is included in most of the base cases. */

    /* Wider range towards the poles... Note: it is possible to do better
     * than this approximation by computing the distance between meridians
     * at this latitude, but this does the trick for now. */
    if (lat > 66 || lat < -66) {
        step--;
        if (lat > 80 || lat < -80) step--;
    }

    /* Frame to valid range. */
    if (step < 1) step = 1;
    if (step > 26) step = 26;
    return step;
}",62.0,83.0,1.0,1.0,22.0,20,10,18,4,1,1,7,8,1,0,,0,1,4,2,2,uint8_t
3929,142967,geohashBoundingBox,1,geohashBoundingBox,"int geohashBoundingBox (GeoShape*,double*)",geohash_helper.c,"int geohashBoundingBox(GeoShape *shape, double *bounds) {
    if (!bounds) return 0;
    double longitude = shape->xy[0];
    double latitude = shape->xy[1];
    double height = shape->conversion * (shape->type == CIRCULAR_TYPE ? shape->t.radius : shape->t.r.height/2);
    double width = shape->conversion * (shape->type == CIRCULAR_TYPE ? shape->t.radius : shape->t.r.width/2);

    const double lat_delta = rad_deg(height/EARTH_RADIUS_IN_METERS);
    const double long_delta_top = rad_deg(width/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude+lat_delta)));
    const double long_delta_bottom = rad_deg(width/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude-lat_delta)));
    /* The directions of the northern and southern hemispheres
     * are opposite, so we choice different points as min/max long/lat */
    int southern_hemisphere = latitude < 0 ? 1 : 0;
    bounds[0] = southern_hemisphere ? longitude-long_delta_bottom : longitude-long_delta_top;
    bounds[2] = southern_hemisphere ? longitude+l...",98.0,116.0,1.0,56.0,19.0,60,12,48,11,1,18,2,2,0,5,,0,18,4,2,2,int
3930,143135,geohashCalculateAreasByShapeWGS84,1,geohashCalculateAreasByShapeWGS84,GeoHashRadius geohashCalculateAreasByShapeWGS84 (GeoShape*),geohash_helper.c,"GeoHashRadius geohashCalculateAreasByShapeWGS84(GeoShape *shape) {
    GeoHashRange long_range, lat_range;
    GeoHashRadius radius;
    GeoHashBits hash;
    GeoHashNeighbors neighbors;
    GeoHashArea area;
    double min_lon, max_lon, min_lat, max_lat;
    int steps;

    geohashBoundingBox(shape, shape->bounds);
    min_lon = shape->bounds[0];
    min_lat = shape->bounds[1];
    max_lon = shape->bounds[2];
    max_lat = shape->bounds[3];

    double longitude = shape->xy[0];
    double latitude = shape->xy[1];
    /* radius_meters is calculated differently in different search types:
     * 1) CIRCULAR_TYPE, just use radius.
     * 2) RECTANGLE_TYPE, we use sqrt((width/2)^2 + (height/2)^2) to
     * calculate the distance from the center point to the corner */
    double radius_meters = shape->type == CIRCULAR_TYPE ? shape->t.radius :
            sqrt((shape->t.r.width/2)*(shape->t.r.width/2) + (shape->t.r.height/2)*(shape->t.r.height/2));
    radius_meters *= shape->conversion;
...",121.0,211.0,1.0,42.0,91.0,192,16,136,20,1,78,11,15,8,13,,0,66,2,1,1,GeoHashRadius
3931,143685,geohashAlign52Bits,1,geohashAlign52Bits,GeoHashFix52Bits geohashAlign52Bits (GeoHashBits),geohash_helper.c,"GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {
    uint64_t bits = hash.bits;
    bits <<= (52 - hash.step * 2);
    return bits;
}",213.0,217.0,1.0,1.0,5.0,5,4,5,2,3,2,1,1,0,0,,0,2,2,1,1,GeoHashFix52Bits
3932,143707,geohashGetLatDistance,1,geohashGetLatDistance,"double geohashGetLatDistance (double,double)",geohash_helper.c,"double geohashGetLatDistance(double lat1d, double lat2d) {
    return EARTH_RADIUS_IN_METERS * fabs(deg_rad(lat2d) - deg_rad(lat1d));
}",224.0,226.0,1.0,1.0,3.0,2,2,3,3,2,3,1,1,0,2,,0,1,4,2,2,double
3933,143722,geohashGetDistance,1,geohashGetDistance,"double geohashGetDistance (double,double,double,double)",geohash_helper.c,"double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
    double lat1r, lon1r, lat2r, lon2r, u, v, a;
    lon1r = deg_rad(lon1d);
    lon2r = deg_rad(lon2d);
    v = sin((lon2r - lon1r) / 2);
    /* if v == 0 we can avoid doing expensive math when lons are practically the same */
    if (v == 0.0)
        return geohashGetLatDistance(lat1d, lat2d);
    lat1r = deg_rad(lat1d);
    lat2r = deg_rad(lat2d);
    u = sin((lat2r - lat1r) / 2);
    a = u * u + cos(lat1r) * cos(lat2r) * v * v;
    return 2.0 * EARTH_RADIUS_IN_METERS * asin(sqrt(a));
}",229.0,242.0,1.0,1.0,14.0,19,6,26,12,3,6,2,2,0,5,,0,5,8,4,4,double
3934,143801,geohashGetDistanceIfInRadius,1,geohashGetDistanceIfInRadius,"int geohashGetDistanceIfInRadius (double,double,double,double,double,double*)",geohash_helper.c,"int geohashGetDistanceIfInRadius(double x1, double y1,
                                 double x2, double y2, double radius,
                                 double *distance) {
    *distance = geohashGetDistance(x1, y1, x2, y2);
    if (*distance > radius) return 0;
    return 1;
}",244.0,250.0,1.0,1.0,7.0,4,3,7,6,1,1,2,2,0,1,,0,1,12,6,6,int
3935,143829,geohashGetDistanceIfInRadiusWGS84,1,geohashGetDistanceIfInRadiusWGS84,"int geohashGetDistanceIfInRadiusWGS84 (double,double,double,double,double,double*)",geohash_helper.c,"int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
                                      double y2, double radius,
                                      double *distance) {
    return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
}",252.0,256.0,1.0,1.0,5.0,0,0,6,6,1,1,1,1,0,1,,0,0,12,6,6,int
3936,143847,geohashGetDistanceIfInRectangle,1,geohashGetDistanceIfInRectangle,"int geohashGetDistanceIfInRectangle (double,double,double,double,double,double,double*)",geohash_helper.c,"int geohashGetDistanceIfInRectangle(double width_m, double height_m, double x1, double y1,
                                    double x2, double y2, double *distance) {
    /* latitude distance is less expensive to compute than longitude distance
     * so we check first for the latitude condition */
    double lat_distance = geohashGetLatDistance(y2, y1);
    if (lat_distance > height_m/2) {
        return 0;
    }
    double lon_distance = geohashGetDistance(x2, y2, x1, y2);
    if (lon_distance > width_m/2) {
        return 0;
    }
    *distance = geohashGetDistance(x1, y1, x2, y2);
    return 1;
}",266.0,280.0,1.0,1.0,15.0,8,4,17,9,0,3,3,3,0,3,,0,3,14,7,7,int
3937,144007,MurmurHash64A,1,MurmurHash64A,"uint64_t MurmurHash64A (void*,int,unsigned int)",hyperloglog.c,"uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
    const uint64_t m = 0xc6a4a7935bd1e995;
    const int r = 47;
    uint64_t h = seed ^ (len * m);
    const uint8_t *data = (const uint8_t *)key;
    const uint8_t *end = data + (len-(len&7));

    while(data != end) {
        uint64_t k;

#if (BYTE_ORDER == LITTLE_ENDIAN)
    #ifdef USE_ALIGNED_ACCESS
        memcpy(&k,data,sizeof(uint64_t));
    #else
        k = *((uint64_t*)data);
    #endif
#else
        k = (uint64_t) data[0];
        k |= (uint64_t) data[1] << 8;
        k |= (uint64_t) data[2] << 16;
        k |= (uint64_t) data[3] << 24;
        k |= (uint64_t) data[4] << 32;
        k |= (uint64_t) data[5] << 40;
        k |= (uint64_t) data[6] << 48;
        k |= (uint64_t) data[7] << 56;
#endif

        k *= m;
        k ^= k >> r;
        k *= m;
        h ^= k;
        h *= m;
        data += 8;
    }

    switch(len & 7) {
    case 7: h ^= (uint64_t)data[6] << 48; /* fall-thru */
    case 6: h ^...",397.0,447.0,1.0,19.0,51.0,66,13,68,9,1,0,3,3,0,0,,0,0,6,3,3,uint64_t
3938,144240,hllPatLen,1,hllPatLen,"int hllPatLen (unsigned char*,size_t,long*)",hyperloglog.c,"int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
    uint64_t hash, bit, index;
    int count;

    /* Count the number of zeroes starting from bit HLL_REGISTERS
     * (that is a power of two corresponding to the first bit we don't use
     * as index). The max run can be 64-P+1 = Q+1 bits.
     *
     * Note that the final ""1"" ending the sequence of zeroes must be
     * included in the count, so if we find ""001"" the count is 3, and
     * the smallest count possible is no zeroes at all, just a 1 bit
     * at the first position, that is a count of 1.
     *
     * This may sound like inefficient, but actually in the average case
     * there are high probabilities to find a 1 after a few iterations. */
    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);
    index = hash & HLL_P_MASK; /* Register index. */
    hash >>= HLL_P; /* Remove bits used to address the register. */
    hash |= ((uint64_t)1<<HLL_Q); /* Make sure the loop terminates
                          ...",452.0,480.0,1.0,19.0,29.0,16,8,16,7,2,1,2,2,0,1,,0,1,6,3,3,int
3939,144310,hllDenseSet,1,hllDenseSet,"int hllDenseSet (uint8_t*,long,uint8_t)",hyperloglog.c,"int hllDenseSet(uint8_t *registers, long index, uint8_t count) {
    uint8_t oldcount;

    HLL_DENSE_GET_REGISTER(oldcount,registers,index);
    if (count > oldcount) {
        HLL_DENSE_SET_REGISTER(registers,index,count);
        return 1;
    } else {
        return 0;
    }
}",494.0,504.0,1.0,4.0,11.0,50,13,51,13,3,0,2,2,0,0,,0,0,6,3,3,int
3940,144487,hllDenseAdd,1,hllDenseAdd,"int hllDenseAdd (uint8_t*,unsigned char*,size_t)",hyperloglog.c,"int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
    long index;
    uint8_t count = hllPatLen(ele,elesize,&index);
    /* Update the register if this element produced a longer run of zeroes. */
    return hllDenseSet(registers,index,count);
}",512.0,517.0,1.0,1.0,6.0,2,2,7,5,2,2,1,1,0,2,,0,1,6,3,3,int
3941,144508,hllDenseRegHisto,1,hllDenseRegHisto,"void hllDenseRegHisto (uint8_t*,int*)",hyperloglog.c,"void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
    int j;

    /* Redis default is to use 16384 registers 6 bits each. The code works
     * with other values by modifying the defines, but for our target value
     * we take a faster path with unrolled loops. */
    if (HLL_REGISTERS == 16384 && HLL_BITS == 6) {
        uint8_t *r = registers;
        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,
                      r10, r11, r12, r13, r14, r15;
        for (j = 0; j < 1024; j++) {
            /* Handle 16 registers per iteration. */
            r0 = r[0] & 63;
            r1 = (r[0] >> 6 | r[1] << 2) & 63;
            r2 = (r[1] >> 4 | r[2] << 4) & 63;
            r3 = (r[2] >> 2) & 63;
            r4 = r[3] & 63;
            r5 = (r[3] >> 6 | r[4] << 2) & 63;
            r6 = (r[4] >> 4 | r[5] << 4) & 63;
            r7 = (r[5] >> 2) & 63;
            r8 = r[6] & 63;
            r9 = (r[6] >> 6 | r[7] << 2) & 63;
            r10 = (r[7] >> 4 | r[8] << 4) & 63...",520.0,575.0,1.0,8.0,56.0,124,11,77,20,1,0,3,4,0,0,,0,0,4,2,2,void
3942,144905,hllSparseToDense,1,hllSparseToDense,int hllSparseToDense (robj*),hyperloglog.c,"int hllSparseToDense(robj *o) {
    sds sparse = o->ptr, dense;
    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
    int idx = 0, runlen, regval;
    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);

    /* If the representation is already the right one return ASAP. */
    hdr = (struct hllhdr*) sparse;
    if (hdr->encoding == HLL_DENSE) return C_OK;

    /* Create a string of the right size filled with zero bytes.
     * Note that the cached cardinality is set to 0 as a side effect
     * that is exactly the cardinality of an empty HLL. */
    dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
    hdr = (struct hllhdr*) dense;
    *hdr = *oldhdr; /* This will copy the magic and cached cardinality. */
    hdr->encoding = HLL_DENSE;

    /* Now read the sparse representation and set non-zero registers
     * accordingly. */
    p += HLL_HDR_SIZE;
    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
   ...",585.0,638.0,1.0,25.0,54.0,45,16,38,11,3,6,5,6,1,4,,0,4,2,1,1,int
3943,145237,hllSparseSet,1,hllSparseSet,"int hllSparseSet (robj*,long,uint8_t)",hyperloglog.c,"int hllSparseSet(robj *o, long index, uint8_t count) {
    struct hllhdr *hdr;
    uint8_t oldcount, *sparse, *end, *p, *prev, *next;
    long first, span;
    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;

    /* If the count is too big to be representable by the sparse representation
     * switch to dense representation. */
    if (count > HLL_SPARSE_VAL_MAX_VALUE) goto promote;

    /* When updating a sparse representation, sometimes we may need to enlarge the
     * buffer for up to 3 bytes in the worst case (XZERO split into XZERO-VAL-XZERO),
     * and the following code does the enlarge job.
     * Actually, we use a greedy strategy, enlarge more than 3 bytes to avoid the need
     * for future reallocates on incremental growth. But we do not allocate more than
     * 'server.hll_sparse_max_bytes' bytes for the sparse representation.
     * If the available size of hyperloglog sds string is not enough for the increment
     * we need, we promote the hypreloglog to ...",655.0,907.0,1.0,16.0,253.0,235,28,209,34,2,16,34,45,4,14,,0,10,6,3,3,int
3944,146271,hllSparseAdd,1,hllSparseAdd,"int hllSparseAdd (robj*,unsigned char*,size_t)",hyperloglog.c,"int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
    long index;
    uint8_t count = hllPatLen(ele,elesize,&index);
    /* Update the register if this element produced a longer run of zeroes. */
    return hllSparseSet(o,index,count);
}",915.0,920.0,1.0,1.0,6.0,2,2,7,5,1,2,1,1,0,2,,0,1,6,3,3,int
3945,146292,hllSparseRegHisto,1,hllSparseRegHisto,"void hllSparseRegHisto (uint8_t*,int,int*,int*)",hyperloglog.c,"void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto) {
    int idx = 0, runlen, regval;
    uint8_t *end = sparse+sparselen, *p = sparse;

    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
            reghisto[0] += runlen;
            p++;
        } else if (HLL_SPARSE_IS_XZERO(p)) {
            runlen = HLL_SPARSE_XZERO_LEN(p);
            idx += runlen;
            reghisto[0] += runlen;
            p += 2;
        } else {
            runlen = HLL_SPARSE_VAL_LEN(p);
            regval = HLL_SPARSE_VAL_VALUE(p);
            idx += runlen;
            reghisto[regval] += runlen;
            p++;
        }
    }
    if (idx != HLL_REGISTERS && invalid) *invalid = 1;
}",923.0,947.0,1.0,12.0,25.0,21,12,21,8,0,0,4,5,0,0,,0,0,8,4,4,void
3946,146446,hllRawRegHisto,1,hllRawRegHisto,"void hllRawRegHisto (uint8_t*,int*)",hyperloglog.c,"void hllRawRegHisto(uint8_t *registers, int* reghisto) {
    uint64_t *word = (uint64_t*) registers;
    uint8_t *bytes;
    int j;

    for (j = 0; j < HLL_REGISTERS/8; j++) {
        if (*word == 0) {
            reghisto[0] += 8;
        } else {
            bytes = (uint8_t*) word;
            reghisto[bytes[0]]++;
            reghisto[bytes[1]]++;
            reghisto[bytes[2]]++;
            reghisto[bytes[3]]++;
            reghisto[bytes[4]]++;
            reghisto[bytes[5]]++;
            reghisto[bytes[6]]++;
            reghisto[bytes[7]]++;
        }
        word++;
    }
}",957.0,978.0,1.0,20.0,22.0,11,10,7,4,0,0,3,4,0,0,,0,0,4,2,2,void
3947,146545,hllSigma,1,hllSigma,double hllSigma (double),hyperloglog.c,"double hllSigma(double x) {
    if (x == 1.) return INFINITY;
    double zPrime;
    double y = 1;
    double z = x;
    do {
        x *= x;
        zPrime = z;
        z += x * y;
        y += y;
    } while(zPrime != z);
    return z;
}",983.0,995.0,1.0,1.0,13.0,9,6,17,5,1,0,3,3,0,0,,0,0,2,1,1,double
3948,146587,hllTau,1,hllTau,double hllTau (double),hyperloglog.c,"double hllTau(double x) {
    if (x == 0. || x == 1.) return 0.;
    double zPrime;
    double y = 1.0;
    double z = 1 - x;
    do {
        x = sqrt(x);
        zPrime = z;
        y *= 0.5;
        z -= pow(1 - x, 2)*y;
    } while(zPrime != z);
    return z / 3;
}",1000.0,1012.0,1.0,1.0,13.0,14,9,16,4,1,0,3,3,0,0,,0,0,2,1,1,double
3949,146642,hllCount,1,hllCount,"uint64_t hllCount (hllhdr*,int*)",hyperloglog.c,"uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
    double m = HLL_REGISTERS;
    double E;
    int j;
    /* Note that reghisto size could be just HLL_Q+2, because HLL_Q+1 is
     * the maximum frequency of the ""000...1"" sequence the hash function is
     * able to return. However it is slow to check for sanity of the
     * input: instead we history array at a safe size: overflows will
     * just write data to wrong, but correctly allocated, places. */
    int reghisto[64] = {0};

    /* Compute register histogram */
    if (hdr->encoding == HLL_DENSE) {
        hllDenseRegHisto(hdr->registers,reghisto);
    } else if (hdr->encoding == HLL_SPARSE) {
        hllSparseRegHisto(hdr->registers,
                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);
    } else if (hdr->encoding == HLL_RAW) {
        hllRawRegHisto(hdr->registers,reghisto);
    } else {
        serverPanic(""Unknown HyperLogLog encoding in hllCount()"");
    }

    /* Estimate cardinality from re...",1025.0,1060.0,1.0,15.0,36.0,31,14,25,6,4,5,3,3,1,3,,0,3,4,2,2,uint64_t
3950,146801,hllAdd,1,hllAdd,"int hllAdd (robj*,unsigned char*,size_t)",hyperloglog.c,"int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
    struct hllhdr *hdr = o->ptr;
    switch(hdr->encoding) {
    case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);
    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
    default: return -1; /* Invalid representation. */
    }
}",1063.0,1070.0,1.0,9.0,8.0,5,3,9,4,2,4,2,2,1,2,,0,2,6,3,3,int
3951,146843,hllMerge,1,hllMerge,"int hllMerge (uint8_t*,robj*)",hyperloglog.c,"int hllMerge(uint8_t *max, robj *hll) {
    struct hllhdr *hdr = hll->ptr;
    int i;

    if (hdr->encoding == HLL_DENSE) {
        uint8_t val;

        for (i = 0; i < HLL_REGISTERS; i++) {
            HLL_DENSE_GET_REGISTER(val,hdr->registers,i);
            if (val > max[i]) max[i] = val;
        }
    } else {
        uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
        long runlen, regval;

        p += HLL_HDR_SIZE;
        i = 0;
        while(p < end) {
            if (HLL_SPARSE_IS_ZERO(p)) {
                runlen = HLL_SPARSE_ZERO_LEN(p);
                i += runlen;
                p++;
            } else if (HLL_SPARSE_IS_XZERO(p)) {
                runlen = HLL_SPARSE_XZERO_LEN(p);
                i += runlen;
                p += 2;
            } else {
                runlen = HLL_SPARSE_VAL_LEN(p);
                regval = HLL_SPARSE_VAL_VALUE(p);
                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
                while(runlen--) {
    ...",1080.0,1120.0,1.0,25.0,41.0,35,15,33,12,2,3,4,7,1,0,,0,3,4,2,2,int
3952,147141,createHLLObject,1,createHLLObject,robj createHLLObject (void),hyperloglog.c,"robj *createHLLObject(void) {
    robj *o;
    struct hllhdr *hdr;
    sds s;
    uint8_t *p;
    int sparselen = HLL_HDR_SIZE +
                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
                     HLL_SPARSE_XZERO_MAX_LEN)*2);
    int aux;

    /* Populate the sparse representation with as many XZERO opcodes as
     * needed to represent all the registers. */
    aux = HLL_REGISTERS;
    s = sdsnewlen(NULL,sparselen);
    p = (uint8_t*)s + HLL_HDR_SIZE;
    while(aux) {
        int xzero = HLL_SPARSE_XZERO_MAX_LEN;
        if (xzero > aux) xzero = aux;
        HLL_SPARSE_XZERO_SET(p,xzero);
        p += 2;
        aux -= xzero;
    }
    serverAssert((p-(uint8_t*)s) == sparselen);

    /* Create the actual object. */
    o = createObject(OBJ_STRING,s);
    hdr = o->ptr;
    memcpy(hdr->magic,""HYLL"",4);
    hdr->encoding = HLL_SPARSE;
    return o;
}",1126.0,1156.0,1.0,20.0,31.0,43,20,36,11,3,5,3,4,0,3,,0,4,2,1,1,robj
3953,147298,isHLLObjectOrReply,1,isHLLObjectOrReply,"int isHLLObjectOrReply (client*,robj*)",hyperloglog.c,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    if (checkType(c,o,OBJ_STRING))
        return C_ERR; /* Error already sent. */

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    return C_OK;

invalid:
    addReplyError(c,""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value."");
    return C_ERR;
}",1161.0,1189.0,1.0,22.0,29.0,40,17,18,4,3,10,12,7,9,4,,0,9,4,2,2,int
3954,147435,pfaddCommand,1,pfaddCommand,void pfaddCommand (client*),hyperloglog.c,"void pfaddCommand(client *c) {
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    struct hllhdr *hdr;
    int updated = 0, j;

    if (o == NULL) {
        /* Create the key with a string value of the exact length to
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */
        o = createHLLObject();
        dbAdd(c->db,c->argv[1],o);
        updated++;
    } else {
        if (isHLLObjectOrReply(c,o) != C_OK) return;
        o = dbUnshareStringValue(c->db,c->argv[1],o);
    }
    /* Perform the low level ADD operation for every element. */
    for (j = 2; j < c->argc; j++) {
        int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,
                               sdslen(c->argv[j]->ptr));
        switch(retval) {
        case 1:
            updated++;
            break;
        case -1:
            addReplyError(c,invalid_hll_err);
            return;
        }
    }
    hdr = o->ptr;
    if (u...",1192.0,1229.0,1.0,39.0,38.0,42,12,40,10,0,22,6,6,1,9,,0,17,2,1,1,void
3955,147614,pfcountCommand,1,pfcountCommand,void pfcountCommand (client*),hyperloglog.c,"void pfcountCommand(client *c) {
    robj *o;
    struct hllhdr *hdr;
    uint64_t card;

    /* Case 1: multi-key keys, cardinality of the union.
     *
     * When multiple keys are specified, PFCOUNT actually computes
     * the cardinality of the merge of the N HLLs specified. */
    if (c->argc > 2) {
        uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;
        int j;

        /* Compute an HLL with M[i] = MAX(M[i]_j). */
        memset(max,0,sizeof(max));
        hdr = (struct hllhdr*) max;
        hdr->encoding = HLL_RAW; /* Special internal-only encoding. */
        registers = max + HLL_HDR_SIZE;
        for (j = 1; j < c->argc; j++) {
            /* Check type and size. */
            robj *o = lookupKeyRead(c->db,c->argv[j]);
            if (o == NULL) continue; /* Assume empty HLL for non existing var.*/
            if (isHLLObjectOrReply(c,o) != C_OK) return;

            /* Merge with this HLL with our 'max' HLL by setting max[i]
             * to MAX(max[i],hl...",1232.0,1325.0,1.0,20.0,94.0,27,12,34,10,0,16,8,14,4,8,,0,13,2,1,1,void
3956,147992,pfmergeCommand,1,pfmergeCommand,void pfmergeCommand (client*),hyperloglog.c,"void pfmergeCommand(client *c) {
    uint8_t max[HLL_REGISTERS];
    struct hllhdr *hdr;
    int j;
    int use_dense = 0; /* Use dense representation as target? */

    /* Compute an HLL with M[i] = MAX(M[i]_j).
     * We store the maximum into the max array of registers. We'll write
     * it to the target variable later. */
    memset(max,0,sizeof(max));
    for (j = 1; j < c->argc; j++) {
        /* Check type and size. */
        robj *o = lookupKeyRead(c->db,c->argv[j]);
        if (o == NULL) continue; /* Assume empty HLL for non existing var. */
        if (isHLLObjectOrReply(c,o) != C_OK) return;

        /* If at least one involved HLL is dense, use the dense representation
         * as target ASAP to save time and avoid the conversion step. */
        hdr = o->ptr;
        if (hdr->encoding == HLL_DENSE) use_dense = 1;

        /* Merge with this HLL with our 'max' HLL by setting max[i]
         * to MAX(max[i],hll[i]). */
        if (hllMerge(max,o) == C_ERR) {
        ...",1328.0,1399.0,1.0,16.0,72.0,57,12,62,10,0,31,15,17,6,14,,0,23,2,1,1,void
3957,148250,pfselftestCommand,1,pfselftestCommand,void pfselftestCommand (client*),hyperloglog.c,"void pfselftestCommand(client *c) {
    unsigned int j, i;
    sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
    struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
    robj *o = NULL;
    uint8_t bytecounters[HLL_REGISTERS];

    /* Test 1: access registers.
     * The test is conceived to test that the different counters of our data
     * structure are accessible and that setting their values both result in
     * the correct value to be retained and not affect adjacent values. */
    for (j = 0; j < HLL_TEST_CYCLES; j++) {
        /* Set the HLL counters and an array of unsigned byes of the
         * same size to the same set of random values. */
        for (i = 0; i < HLL_REGISTERS; i++) {
            unsigned int r = rand() & HLL_REGISTER_MAX;

            bytecounters[i] = r;
            HLL_DENSE_SET_REGISTER(hdr->registers,i,r);
        }
        /* Check that we are able to retrieve the same values. */
        for (i = 0; i < HLL_REGISTERS; i++) {
            u...",1407.0,1507.0,1.0,37.0,101.0,143,25,132,29,0,21,18,29,3,14,,0,12,2,1,1,void
3958,148748,pfdebugCommand,1,pfdebugCommand,void pfdebugCommand (client*),hyperloglog.c,"void pfdebugCommand(client *c) {
    char *cmd = c->argv[1]->ptr;
    struct hllhdr *hdr;
    robj *o;
    int j;

    o = lookupKeyWrite(c->db,c->argv[2]);
    if (o == NULL) {
        addReplyError(c,""The specified key does not exist"");
        return;
    }
    if (isHLLObjectOrReply(c,o) != C_OK) return;
    o = dbUnshareStringValue(c->db,c->argv[2],o);
    hdr = o->ptr;

    /* PFDEBUG GETREG <key> */
    if (!strcasecmp(cmd,""getreg"")) {
        if (c->argc != 3) goto arityerr;

        if (hdr->encoding == HLL_SPARSE) {
            if (hllSparseToDense(o) == C_ERR) {
                addReplyError(c,invalid_hll_err);
                return;
            }
            server.dirty++; /* Force propagation on encoding change. */
        }

        hdr = o->ptr;
        addReplyArrayLen(c,HLL_REGISTERS);
        for (j = 0; j < HLL_REGISTERS; j++) {
            uint8_t val;

            HLL_DENSE_GET_REGISTER(val,hdr->registers,j);
            addReplyLongLong(c,val);
        }
    ...",1516.0,1617.0,1.0,35.0,102.0,55,19,54,16,0,19,9,13,4,9,,0,14,2,1,1,void
3959,149262,_intsetValueEncoding,1,_intsetValueEncoding,uint8_t _intsetValueEncoding (int64_t),intset.c,"static uint8_t _intsetValueEncoding(int64_t v) {
    if (v < INT32_MIN || v > INT32_MAX)
        return INTSET_ENC_INT64;
    else if (v < INT16_MIN || v > INT16_MAX)
        return INTSET_ENC_INT32;
    else
        return INTSET_ENC_INT16;
}",46.0,53.0,1.0,15.0,8.0,4,4,5,4,4,0,2,2,0,0,,0,0,2,1,1,uint8_t
3960,149304,_intsetGetEncoded,1,_intsetGetEncoded,"int64_t _intsetGetEncoded (intset*,int,uint8_t)",intset.c,"static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
    int64_t v64;
    int32_t v32;
    int16_t v16;

    if (enc == INTSET_ENC_INT64) {
        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));
        memrev64ifbe(&v64);
        return v64;
    } else if (enc == INTSET_ENC_INT32) {
        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));
        memrev32ifbe(&v32);
        return v32;
    } else {
        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));
        memrev16ifbe(&v16);
        return v16;
    }
}",56.0,74.0,1.0,15.0,19.0,9,6,9,5,1,2,2,2,0,1,,0,1,6,3,3,int64_t
3961,149397,_intsetGet,1,_intsetGet,"int64_t _intsetGet (intset*,int)",intset.c,"static int64_t _intsetGet(intset *is, int pos) {
    return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));
}",77.0,79.0,1.0,36.0,3.0,2,1,4,2,7,4,1,1,0,2,,0,3,4,2,2,int64_t
3962,149416,_intsetSet,1,_intsetSet,"void _intsetSet (intset*,int,int64_t)",intset.c,"static void _intsetSet(intset *is, int pos, int64_t value) {
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        ((int64_t*)is->contents)[pos] = value;
        memrev64ifbe(((int64_t*)is->contents)+pos);
    } else if (encoding == INTSET_ENC_INT32) {
        ((int32_t*)is->contents)[pos] = value;
        memrev32ifbe(((int32_t*)is->contents)+pos);
    } else {
        ((int16_t*)is->contents)[pos] = value;
        memrev16ifbe(((int16_t*)is->contents)+pos);
    }
}",82.0,95.0,1.0,24.0,14.0,12,7,10,5,2,6,2,2,0,2,,0,5,6,3,3,void
3963,149512,intsetNew,1,intsetNew,intset intsetNew (void),intset.c,"intset *intsetNew(void) {
    intset *is = zmalloc(sizeof(intset));
    is->encoding = intrev32ifbe(INTSET_ENC_INT16);
    is->length = 0;
    return is;
}",98.0,103.0,1.0,19.0,6.0,7,3,6,3,2,4,1,1,0,2,,0,4,2,1,1,intset
3964,149539,intsetResize,1,intsetResize,"intset intsetResize (intset*,uint32_t)",intset.c,"static intset *intsetResize(intset *is, uint32_t len) {
    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);
    assert(size <= SIZE_MAX - sizeof(intset));
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}",106.0,111.0,1.0,34.0,6.0,15,11,12,5,2,5,1,1,0,3,,0,4,4,2,2,intset
3965,149590,intsetSearch,1,intsetSearch,"uint8_t intsetSearch (intset*,int64_t,uint32_t*)",intset.c,"static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
    int64_t cur = -1;

    /* The value can never be found when the set is empty */
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        /* Check for the case where we know we cannot find the value,
         * but do know the insert position. */
        if (value > _intsetGet(is,max)) {
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is,0)) {
            if (pos) *pos = 0;
            return 0;
        }
    }

    while(max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is,mid);
        if (value > cur) {
            min = mid+1;
        } else if (value < cur) {
            max = mid-1;
        } else {
            break;
        }
    }

    if (value == cur) {
        if (pos) *pos =...",117.0,156.0,1.0,23.0,40.0,27,11,27,7,2,7,7,10,3,3,,0,7,6,3,3,uint8_t
3966,149762,intsetUpgradeAndAdd,1,intsetUpgradeAndAdd,"intset intsetUpgradeAndAdd (intset*,int64_t)",intset.c,"static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    int prepend = value < 0 ? 1 : 0;

    /* First set new encoding and resize */
    is->encoding = intrev32ifbe(newenc);
    is = intsetResize(is,intrev32ifbe(is->length)+1);

    /* Upgrade back-to-front so we don't overwrite values.
     * Note that the ""prepend"" variable is used to make sure we have an empty
     * space at either the beginning or the end of the intset. */
    while(length--)
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));

    /* Set the value at the beginning or the end. */
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is->length),value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}",159.0,182.0,1.0,21.0,24.0,22,6,25,6,1,19,3,3,0,9,,0,18,4,2,2,intset
3967,149881,intsetMoveTail,1,intsetMoveTail,"void intsetMoveTail (intset*,uint32_t,uint32_t)",intset.c,"static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
    void *src, *dst;
    uint32_t bytes = intrev32ifbe(is->length)-from;
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        src = (int64_t*)is->contents+from;
        dst = (int64_t*)is->contents+to;
        bytes *= sizeof(int64_t);
    } else if (encoding == INTSET_ENC_INT32) {
        src = (int32_t*)is->contents+from;
        dst = (int32_t*)is->contents+to;
        bytes *= sizeof(int32_t);
    } else {
        src = (int16_t*)is->contents+from;
        dst = (int16_t*)is->contents+to;
        bytes *= sizeof(int16_t);
    }
    memmove(dst,src,bytes);
}",184.0,203.0,1.0,21.0,20.0,19,8,20,8,1,8,2,2,0,2,,0,8,6,3,3,void
3968,150006,intsetAdd,1,intsetAdd,"intset intsetAdd (intset*,int64_t,uint8_t*)",intset.c,"intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 1;

    /* Upgrade encoding if necessary. If we need to upgrade, we know that
     * this value should be either appended (if > 0) or prepended (if < 0),
     * because it lies outside the range of existing values. */
    if (valenc > intrev32ifbe(is->encoding)) {
        /* This always succeeds, so we don't need to curry *success. */
        return intsetUpgradeAndAdd(is,value);
    } else {
        /* Abort if the value is already present in the set.
         * This call will populate ""pos"" with the right position to insert
         * the value when it cannot be found. */
        if (intsetSearch(is,value,&pos)) {
            if (success) *success = 0;
            return is;
        }

        is = intsetResize(is,intrev32ifbe(is->length)+1);
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }

...",206.0,233.0,1.0,17.0,28.0,11,5,16,5,1,11,3,3,3,6,,0,9,6,3,3,intset
3969,150117,intsetRemove,1,intsetRemove,"intset intsetRemove (intset*,int64_t,int*)",intset.c,"intset *intsetRemove(intset *is, int64_t value, int *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 0;

    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {
        uint32_t len = intrev32ifbe(is->length);

        /* We know we can delete */
        if (success) *success = 1;

        /* Overwrite value with tail and update length */
        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
        is = intsetResize(is,len-1);
        is->length = intrev32ifbe(len-1);
    }
    return is;
}",236.0,253.0,1.0,18.0,18.0,21,9,26,6,0,12,5,7,4,7,,0,11,6,3,3,intset
3970,150207,intsetFind,1,intsetFind,"uint8_t intsetFind (intset*,int64_t)",intset.c,"uint8_t intsetFind(intset *is, int64_t value) {
    uint8_t valenc = _intsetValueEncoding(value);
    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);
}",256.0,259.0,1.0,21.0,4.0,5,4,8,4,0,5,1,1,0,3,,0,3,4,2,2,uint8_t
3971,150235,intsetRandom,1,intsetRandom,int64_t intsetRandom (intset*),intset.c,"int64_t intsetRandom(intset *is) {
    uint32_t len = intrev32ifbe(is->length);
    assert(len); /* avoid division by zero on corrupt intset payload. */
    return _intsetGet(is,rand()%len);
}",262.0,266.0,1.0,19.0,5.0,8,7,7,2,0,5,1,1,0,3,,0,3,2,1,1,int64_t
3972,150273,intsetMax,1,intsetMax,int64_t intsetMax (intset*),intset.c,"int64_t intsetMax(intset *is) {
    uint32_t len = intrev32ifbe(is->length);
    return _intsetGet(is, len - 1);
}",269.0,272.0,1.0,19.0,4.0,4,3,5,2,0,4,1,1,0,2,,0,3,2,1,1,int64_t
3973,150296,intsetMin,1,intsetMin,int64_t intsetMin (intset*),intset.c,"int64_t intsetMin(intset *is) {
    return _intsetGet(is, 0);
}",275.0,277.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int64_t
3974,150305,intsetGet,1,intsetGet,"uint8_t intsetGet (intset*,uint32_t,int64_t*)",intset.c,"uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
    if (pos < intrev32ifbe(is->length)) {
        *value = _intsetGet(is,pos);
        return 1;
    }
    return 0;
}",281.0,287.0,1.0,14.0,7.0,5,4,6,3,1,4,2,2,3,2,,0,4,6,3,3,uint8_t
3975,150335,intsetLen,1,intsetLen,uint32_t intsetLen (intset*),intset.c,"uint32_t intsetLen(const intset *is) {
    return intrev32ifbe(is->length);
}",290.0,292.0,1.0,11.0,3.0,2,1,2,1,1,3,1,1,0,1,,0,2,2,1,1,uint32_t
3976,150350,intsetBlobLen,1,intsetBlobLen,size_t intsetBlobLen (intset*),intset.c,"size_t intsetBlobLen(intset *is) {
    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
}",295.0,297.0,1.0,34.0,3.0,8,5,5,2,0,6,1,1,0,2,,0,4,2,1,1,size_t
3977,150380,intsetValidateIntegrity,1,intsetValidateIntegrity,"int intsetValidateIntegrity (unsigned char*,size_t,int)",intset.c,"int intsetValidateIntegrity(const unsigned char *p, size_t size, int deep) {
    intset *is = (intset *)p;
    /* check that we can actually read the header. */
    if (size < sizeof(*is))
        return 0;

    uint32_t encoding = intrev32ifbe(is->encoding);

    size_t record_size;
    if (encoding == INTSET_ENC_INT64) {
        record_size = INTSET_ENC_INT64;
    } else if (encoding == INTSET_ENC_INT32) {
        record_size = INTSET_ENC_INT32;
    } else if (encoding == INTSET_ENC_INT16){
        record_size = INTSET_ENC_INT16;
    } else {
        return 0;
    }

    /* check that the size matches (all records are inside the buffer). */
    uint32_t count = intrev32ifbe(is->length);
    if (sizeof(*is) + count*record_size != size)
        return 0;

    /* check that the set is not empty. */
    if (count==0)
        return 0;

    if (!deep)
        return 1;

    /* check that there are no dup or out of order records. */
    int64_t prev = _intsetGet(is,0);
    for (uint32_t...",302.0,343.0,1.0,24.0,42.0,28,12,32,11,0,8,8,9,0,4,,0,8,6,3,3,int
3978,150629,dictStringKeyCompare,1,dictStringKeyCompare,"int dictStringKeyCompare (dict*,void*,void*)",latency.c,"int dictStringKeyCompare(dict *d, const void *key1, const void *key2) {
    UNUSED(d);
    return strcmp(key1,key2) == 0;
}",40.0,43.0,1.0,4.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,int
3979,150648,dictStringHash,1,dictStringHash,uint64_t dictStringHash (void*),latency.c,"uint64_t dictStringHash(const void *key) {
    return dictGenHashFunction(key, strlen(key));
}",45.0,47.0,1.0,1.0,3.0,0,0,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
3980,150658,dictVanillaFree,1,dictVanillaFree,"void dictVanillaFree (dict*,void*)",server.c,"void dictVanillaFree(dict *d, void *val)
{
    UNUSED(d);
    zfree(val);
}",247.0,251.0,1.0,4.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
3981,150675,THPGetAnonHugePagesSize,1,THPGetAnonHugePagesSize,int THPGetAnonHugePagesSize (void),latency.c,"int THPGetAnonHugePagesSize(void) {
    return zmalloc_get_smap_bytes_by_field(""AnonHugePages:"",-1);
}",66.0,68.0,1.0,1.0,3.0,1,1,0,0,1,1,1,1,0,1,,0,0,2,1,1,int
3982,150685,latencyMonitorInit,1,latencyMonitorInit,void latencyMonitorInit (void),latency.c,"void latencyMonitorInit(void) {
    server.latency_events = dictCreate(&latencyTimeSeriesDictType);
}",75.0,77.0,1.0,1.0,3.0,3,3,2,2,1,2,1,1,0,1,,0,2,2,1,1,void
3983,150697,latencyAddSample,1,latencyAddSample,"void latencyAddSample (char*,mstime_t)",latency.c,"void latencyAddSample(const char *event, mstime_t latency) {
    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
    time_t now = time(NULL);
    int prev;

    /* Create the time series if it does not exist. */
    if (ts == NULL) {
        ts = zmalloc(sizeof(*ts));
        ts->idx = 0;
        ts->max = 0;
        memset(ts->samples,0,sizeof(ts->samples));
        dictAdd(server.latency_events,zstrdup(event),ts);
    }

    if (latency > ts->max) ts->max = latency;

    /* If the previous sample is in the same second, we update our old sample
     * if this latency is > of the old one, or just return. */
    prev = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;
    if (ts->samples[prev].time == now) {
        if (latency > ts->samples[prev].latency)
            ts->samples[prev].latency = latency;
        return;
    }

    ts->samples[ts->idx].time = now;
    ts->samples[ts->idx].latency = latency;

    ts->idx++;
    if (ts->idx == LATENCY_TS_LEN) ...",83.0,113.0,1.0,22.0,31.0,52,12,40,7,14,21,6,7,4,4,,0,20,4,2,2,void
3984,150853,latencyResetEvent,1,latencyResetEvent,int latencyResetEvent (char*),latency.c,"int latencyResetEvent(char *event_to_reset) {
    dictIterator *di;
    dictEntry *de;
    int resets = 0;

    di = dictGetSafeIterator(server.latency_events);
    while((de = dictNext(di)) != NULL) {
        char *event = dictGetKey(de);

        if (event_to_reset == NULL || strcasecmp(event,event_to_reset) == 0) {
            dictDelete(server.latency_events, event);
            resets++;
        }
    }
    dictReleaseIterator(di);
    return resets;
}",120.0,136.0,1.0,1.0,17.0,11,6,17,7,0,5,3,4,1,5,,0,3,2,1,1,int
3985,150905,analyzeLatencyForEvent,1,analyzeLatencyForEvent,"void analyzeLatencyForEvent (char*,latencyStats*)",latency.c,"void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
    int j;
    uint64_t sum;

    ls->all_time_high = ts ? ts->max : 0;
    ls->avg = 0;
    ls->min = 0;
    ls->max = 0;
    ls->mad = 0;
    ls->samples = 0;
    ls->period = 0;
    if (!ts) return;

    /* First pass, populate everything but the MAD. */
    sum = 0;
    for (j = 0; j < LATENCY_TS_LEN; j++) {
        if (ts->samples[j].time == 0) continue;
        ls->samples++;
        if (ls->samples == 1) {
            ls->min = ls->max = ts->samples[j].latency;
        } else {
            if (ls->min > ts->samples[j].latency)
                ls->min = ts->samples[j].latency;
            if (ls->max < ts->samples[j].latency)
                ls->max = ts->samples[j].latency;
        }
        sum += ts->samples[j].latency;

        /* Track the oldest event time in ls->period. */
        if (ls->period == 0 || ts->samples[j].time <...",145.0,199.0,1.0,20.0,55.0,90,15,61,8,1,34,14,18,9,1,,0,34,4,2,2,void
3986,151215,createLatencyReport,1,createLatencyReport,sds createLatencyReport (void),latency.c,"sds createLatencyReport(void) {
    sds report = sdsempty();
    int advise_better_vm = 0;       /* Better virtual machines. */
    int advise_slowlog_enabled = 0; /* Enable slowlog. */
    int advise_slowlog_tuning = 0;  /* Reconfigure slowlog. */
    int advise_slowlog_inspect = 0; /* Check your slowlog. */
    int advise_disk_contention = 0; /* Try to lower disk contention. */
    int advise_scheduler = 0;       /* Intrinsic latency. */
    int advise_data_writeback = 0;  /* data=writeback. */
    int advise_no_appendfsync = 0;  /* don't fsync during rewrites. */
    int advise_local_disk = 0;      /* Avoid remote disks. */
    int advise_ssd = 0;             /* Use an SSD drive. */
    int advise_write_load_info = 0; /* Print info about AOF and write load. */
    int advise_hz = 0;              /* Use higher HZ. */
    int advise_large_objects = 0;   /* Deletion of large objects. */
    int advise_mass_eviction = 0;   /* Avoid mass eviction of keys. */
    int advise_relax_fsync...",202.0,457.0,1.0,8.0,256.0,125,17,123,27,0,20,22,39,2,14,,0,18,2,1,1,sds
3987,151901,fillCommandCDF,1,fillCommandCDF,"void fillCommandCDF (client*,hdr_histogram*)",latency.c,"void fillCommandCDF(client *c, struct hdr_histogram* histogram) {
    addReplyMapLen(c,2);
    addReplyBulkCString(c,""calls"");
    addReplyLongLong(c,(long long) histogram->total_count);
    addReplyBulkCString(c,""histogram_usec"");
    void *replylen = addReplyDeferredLen(c);
    int samples = 0;
    struct hdr_iter iter;
    hdr_iter_log_init(&iter,histogram,1024,2);
    int64_t previous_count = 0;
    while (hdr_iter_next(&iter)) {
        const int64_t micros = iter.highest_equivalent_value / 1000;
        const int64_t cumulative_count = iter.cumulative_count;
        if(cumulative_count > previous_count){
            addReplyLongLong(c,(long long) micros);
            addReplyLongLong(c,(long long) cumulative_count);
            samples++;
        }
        previous_count = cumulative_count;
    }
    setDeferredMapLen(c,replylen,samples);
}",468.0,489.0,1.0,1.0,22.0,17,8,28,8,3,8,3,4,0,8,,0,1,4,2,2,void
3988,151986,latencyAllCommandsFillCDF,1,latencyAllCommandsFillCDF,"void latencyAllCommandsFillCDF (client*,dict*,int*)",latency.c,"void latencyAllCommandsFillCDF(client *c, dict *commands, int *command_with_data) {
    dictIterator *di = dictGetSafeIterator(commands);
    dictEntry *de;
    struct redisCommand *cmd;

    while((de = dictNext(di)) != NULL) {
        cmd = (struct redisCommand *) dictGetVal(de);
        if (cmd->latency_histogram) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            fillCommandCDF(c, cmd->latency_histogram);
            (*command_with_data)++;
        }

        if (cmd->subcommands) {
            latencyAllCommandsFillCDF(c, cmd->subcommands_dict, command_with_data);
        }
    }
    dictReleaseIterator(di);
}",493.0,511.0,1.0,1.0,19.0,13,6,19,7,0,13,4,6,3,7,,0,10,6,3,3,void
3989,152049,latencySpecificCommandsFillCDF,1,latencySpecificCommandsFillCDF,void latencySpecificCommandsFillCDF (client*),latency.c,"void latencySpecificCommandsFillCDF(client *c) {
    void *replylen = addReplyDeferredLen(c);
    int command_with_data = 0;
    for (int j = 2; j < c->argc; j++){
        struct redisCommand *cmd = lookupCommandBySds(c->argv[j]->ptr);
        /* If the command does not exist we skip the reply */
        if (cmd == NULL) {
            continue;
        }

        if (cmd->latency_histogram) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            fillCommandCDF(c, cmd->latency_histogram);
            command_with_data++;
        }

        if (cmd->subcommands_dict) {
            dictEntry *de;
            dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);

            while ((de = dictNext(di)) != NULL) {
                struct redisCommand *sub = dictGetVal(de);
                if (sub->latency_histogram) {
                    addReplyBulkCBuffer(c, sub->fullname, sdslen(sub->fullname));
                    fillCommandCDF(c, sub->latency_...",515.0,547.0,1.0,1.0,33.0,26,7,37,9,0,25,8,15,5,13,,0,19,2,1,1,void
3990,152168,latencyCommandReplyWithSamples,1,latencyCommandReplyWithSamples,"void latencyCommandReplyWithSamples (client*,latencyTimeSeries*)",latency.c,"void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
    void *replylen = addReplyDeferredLen(c);
    int samples = 0, j;

    for (j = 0; j < LATENCY_TS_LEN; j++) {
        int i = (ts->idx + j) % LATENCY_TS_LEN;

        if (ts->samples[i].time == 0) continue;
        addReplyArrayLen(c,2);
        addReplyLongLong(c,ts->samples[i].time);
        addReplyLongLong(c,ts->samples[i].latency);
        samples++;
    }
    setDeferredArrayLen(c,replylen,samples);
}",551.0,565.0,1.0,20.0,15.0,19,9,21,6,0,9,4,4,1,5,,0,5,4,2,2,void
3991,152248,latencyCommandReplyWithLatestEvents,1,latencyCommandReplyWithLatestEvents,void latencyCommandReplyWithLatestEvents (client*),latency.c,"void latencyCommandReplyWithLatestEvents(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c,dictSize(server.latency_events));
    di = dictGetIterator(server.latency_events);
    while((de = dictNext(di)) != NULL) {
        char *event = dictGetKey(de);
        struct latencyTimeSeries *ts = dictGetVal(de);
        int last = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;

        addReplyArrayLen(c,4);
        addReplyBulkCString(c,event);
        addReplyLongLong(c,ts->samples[last].time);
        addReplyLongLong(c,ts->samples[last].latency);
        addReplyLongLong(c,ts->max);
    }
    dictReleaseIterator(di);
}",569.0,587.0,1.0,23.0,19.0,26,8,27,8,0,15,2,2,1,11,,0,8,2,1,1,void
3992,152348,latencyCommandGenSparkeline,1,latencyCommandGenSparkeline,"sds latencyCommandGenSparkeline (char*,latencyTimeSeries*)",latency.c,"sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
    int j;
    struct sequence *seq = createSparklineSequence();
    sds graph = sdsempty();
    uint32_t min = 0, max = 0;

    for (j = 0; j < LATENCY_TS_LEN; j++) {
        int i = (ts->idx + j) % LATENCY_TS_LEN;
        int elapsed;
        char buf[64];

        if (ts->samples[i].time == 0) continue;
        /* Update min and max. */
        if (seq->length == 0) {
            min = max = ts->samples[i].latency;
        } else {
            if (ts->samples[i].latency > max) max = ts->samples[i].latency;
            if (ts->samples[i].latency < min) min = ts->samples[i].latency;
        }
        /* Use as label the number of seconds / minutes / hours / days
         * ago the event happened. */
        elapsed = time(NULL) - ts->samples[i].time;
        if (elapsed < 60)
            snprintf(buf,sizeof(buf),""%ds"",elapsed);
        else if (elapsed < 3600)
            snprintf(buf,sizeof(buf),""%dm"",ela...",590.0,632.0,1.0,20.0,43.0,40,11,43,11,0,14,7,9,2,7,,0,12,4,2,2,sds
3993,152604,latencyCommand,1,latencyCommand,void latencyCommand (client*),latency.c,"void latencyCommand(client *c) {
    struct latencyTimeSeries *ts;

    if (!strcasecmp(c->argv[1]->ptr,""history"") && c->argc == 3) {
        /* LATENCY HISTORY <event> */
        ts = dictFetchValue(server.latency_events,c->argv[2]->ptr);
        if (ts == NULL) {
            addReplyArrayLen(c,0);
        } else {
            latencyCommandReplyWithSamples(c,ts);
        }
    } else if (!strcasecmp(c->argv[1]->ptr,""graph"") && c->argc == 3) {
        /* LATENCY GRAPH <event> */
        sds graph;
        dictEntry *de;
        char *event;

        de = dictFind(server.latency_events,c->argv[2]->ptr);
        if (de == NULL) goto nodataerr;
        ts = dictGetVal(de);
        event = dictGetKey(de);

        graph = latencyCommandGenSparkeline(event,ts);
        addReplyVerbatim(c,graph,sdslen(graph),""txt"");
        sdsfree(graph);
    } else if (!strcasecmp(c->argv[1]->ptr,""latest"") && c->argc == 2) {
        /* LATENCY LATEST */
        latencyCommandReplyWithLatestEvents(c);
 ...",643.0,727.0,1.0,1.0,85.0,17,8,10,4,0,7,3,4,2,3,,0,5,2,1,1,void
3994,152945,durationAddSample,1,durationAddSample,"void durationAddSample (int,monotime)",latency.c,"void durationAddSample(int type, monotime duration) {
    if (type >= EL_DURATION_TYPE_NUM) {
        return;
    }
    durationStats* ds = &server.duration_stats[type];
    ds->cnt++;
    ds->sum += duration;
    if (duration > ds->max) {
        ds->max = duration;
    }
}",729.0,739.0,1.0,1.0,11.0,13,9,12,5,3,4,3,3,1,0,,0,4,4,2,2,void
3995,153073,lazyfreeFreeObject,1,lazyfreeFreeObject,void lazyfreeFreeObject (void[]*),lazyfree.c,"void lazyfreeFreeObject(void *args[]) {
    robj *o = (robj *) args[0];
    decrRefCount(o);
    atomicDecr(lazyfree_objects,1);
    atomicIncr(lazyfreed_objects,1);
}",11.0,16.0,1.0,1.0,6.0,3,3,5,4,0,3,1,1,0,1,,0,2,2,1,1,void
3996,153094,lazyfreeFreeDatabase,1,lazyfreeFreeDatabase,void lazyfreeFreeDatabase (void[]*),lazyfree.c,"void lazyfreeFreeDatabase(void *args[]) {
    dict *ht1 = (dict *) args[0];
    dict *ht2 = (dict *) args[1];

    size_t numkeys = dictSize(ht1);
    dictRelease(ht1);
    dictRelease(ht2);
    atomicDecr(lazyfree_objects,numkeys);
    atomicIncr(lazyfreed_objects,numkeys);
}",21.0,30.0,1.0,21.0,10.0,12,5,14,6,0,6,1,1,0,2,,0,4,2,1,1,void
3997,153142,lazyFreeTrackingTable,1,lazyFreeTrackingTable,void lazyFreeTrackingTable (void[]*),lazyfree.c,"void lazyFreeTrackingTable(void *args[]) {
    rax *rt = args[0];
    size_t len = rt->numele;
    freeTrackingRadixTree(rt);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",33.0,39.0,1.0,1.0,7.0,4,3,9,5,0,4,1,1,0,1,,0,3,2,1,1,void
3998,153167,lazyFreeLuaScripts,1,lazyFreeLuaScripts,void lazyFreeLuaScripts (void[]*),lazyfree.c,"void lazyFreeLuaScripts(void *args[]) {
    dict *lua_scripts = args[0];
    long long len = dictSize(lua_scripts);
    dictRelease(lua_scripts);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",42.0,48.0,1.0,20.0,7.0,8,4,11,5,0,5,1,1,0,1,,0,4,2,1,1,void
3999,153203,lazyFreeFunctionsCtx,1,lazyFreeFunctionsCtx,void lazyFreeFunctionsCtx (void[]*),lazyfree.c,"void lazyFreeFunctionsCtx(void *args[]) {
    functionsLibCtx *functions_lib_ctx = args[0];
    size_t len = functionsLibCtxfunctionsLen(functions_lib_ctx);
    functionsLibCtxFree(functions_lib_ctx);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",51.0,57.0,1.0,1.0,7.0,3,2,9,5,0,4,1,1,0,2,,0,3,2,1,1,void
4000,153227,lazyFreeReplicationBacklogRefMem,1,lazyFreeReplicationBacklogRefMem,void lazyFreeReplicationBacklogRefMem (void[]*),lazyfree.c,"void lazyFreeReplicationBacklogRefMem(void *args[]) {
    list *blocks = args[0];
    rax *index = args[1];
    long long len = listLength(blocks);
    len += raxSize(index);
    listRelease(blocks);
    raxFree(index);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",60.0,69.0,1.0,20.0,10.0,7,4,15,6,0,6,1,1,0,3,,0,3,2,1,1,void
4001,153267,lazyfreeGetPendingObjectsCount,1,lazyfreeGetPendingObjectsCount,size_t lazyfreeGetPendingObjectsCount (void),lazyfree.c,"size_t lazyfreeGetPendingObjectsCount(void) {
    size_t aux;
    atomicGet(lazyfree_objects,aux);
    return aux;
}",72.0,76.0,1.0,1.0,5.0,0,0,3,2,1,1,1,1,0,0,,0,1,2,1,1,size_t
4002,153278,lazyfreeGetFreedObjectsCount,1,lazyfreeGetFreedObjectsCount,size_t lazyfreeGetFreedObjectsCount (void),lazyfree.c,"size_t lazyfreeGetFreedObjectsCount(void) {
    size_t aux;
    atomicGet(lazyfreed_objects,aux);
    return aux;
}",79.0,83.0,1.0,1.0,5.0,0,0,3,2,1,1,1,1,0,0,,0,1,2,1,1,size_t
4003,153289,lazyfreeResetStats,1,lazyfreeResetStats,void lazyfreeResetStats (void),lazyfree.c,"void lazyfreeResetStats(void) {
    atomicSet(lazyfreed_objects,0);
}",85.0,87.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,0,,0,1,2,1,1,void
4004,153297,lazyfreeGetFreeEffort,1,lazyfreeGetFreeEffort,"size_t lazyfreeGetFreeEffort (robj*,robj*,int)",lazyfree.c,"size_t lazyfreeGetFreeEffort(robj *key, robj *obj, int dbid) {
    if (obj->type == OBJ_LIST && obj->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = obj->ptr;
        return ql->len;
    } else if (obj->type == OBJ_SET && obj->encoding == OBJ_ENCODING_HT) {
        dict *ht = obj->ptr;
        return dictSize(ht);
    } else if (obj->type == OBJ_ZSET && obj->encoding == OBJ_ENCODING_SKIPLIST){
        zset *zs = obj->ptr;
        return zs->zsl->length;
    } else if (obj->type == OBJ_HASH && obj->encoding == OBJ_ENCODING_HT) {
        dict *ht = obj->ptr;
        return dictSize(ht);
    } else if (obj->type == OBJ_STREAM) {
        size_t effort = 0;
        stream *s = obj->ptr;

        /* Make a best effort estimate to maintain constant runtime. Every macro
         * node in the Stream is one allocation. */
        effort += s->rax->numnodes;

        /* Every consumer group is an allocation and so are the entries in its
         * PEL. We use size of the first g...",104.0,149.0,1.0,21.0,46.0,8,4,5,2,1,1,2,2,0,0,,0,1,6,3,3,size_t
4005,153565,freeObjAsync,1,freeObjAsync,"void freeObjAsync (robj*,robj*,int)",lazyfree.c,"void freeObjAsync(robj *key, robj *obj, int dbid) {
    size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid);
    /* Note that if the object is shared, to reclaim it now it is not
     * possible. This rarely happens, however sometimes the implementation
     * of parts of the Redis core may call incrRefCount() to protect
     * objects, and then call dbDelete(). */
    if (free_effort > LAZYFREE_THRESHOLD && obj->refcount == 1) {
        atomicIncr(lazyfree_objects,1);
        bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj);
    } else {
        decrRefCount(obj);
    }
}",159.0,171.0,1.0,22.0,13.0,5,5,8,5,1,3,2,2,0,2,,0,2,6,3,3,void
4006,153603,emptyDbAsync,1,emptyDbAsync,void emptyDbAsync (redisDb*),lazyfree.c,"void emptyDbAsync(redisDb *db) {
    dict *oldht1 = db->dict, *oldht2 = db->expires;
    db->dict = dictCreate(&dbDictType);
    db->expires = dictCreate(&dbExpiresDictType);
    atomicIncr(lazyfree_objects,dictSize(oldht1));
    bioCreateLazyFreeJob(lazyfreeFreeDatabase,2,oldht1,oldht2);
}",176.0,182.0,1.0,32.0,7.0,15,5,14,6,1,10,1,1,0,3,,0,9,2,1,1,void
4007,153655,freeTrackingRadixTreeAsync,1,freeTrackingRadixTreeAsync,void freeTrackingRadixTreeAsync (rax*),lazyfree.c,"void freeTrackingRadixTreeAsync(rax *tracking) {
    /* Because this rax has only keys and no values so we use numnodes. */
    if (tracking->numnodes > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,tracking->numele);
        bioCreateLazyFreeJob(lazyFreeTrackingTable,1,tracking);
    } else {
        freeTrackingRadixTree(tracking);
    }
}",186.0,194.0,1.0,29.0,9.0,3,2,4,2,0,4,2,2,1,1,,0,3,2,1,1,void
4008,153682,freeLuaScriptsAsync,1,freeLuaScriptsAsync,void freeLuaScriptsAsync (dict*),lazyfree.c,"void freeLuaScriptsAsync(dict *lua_scripts) {
    if (dictSize(lua_scripts) > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,dictSize(lua_scripts));
        bioCreateLazyFreeJob(lazyFreeLuaScripts,1,lua_scripts);
    } else {
        dictRelease(lua_scripts);
    }
}",197.0,204.0,1.0,8.0,8.0,11,4,8,2,1,6,2,2,2,1,,0,5,2,1,1,void
4009,153731,freeFunctionsAsync,1,freeFunctionsAsync,void freeFunctionsAsync (functionsLibCtx*),lazyfree.c,"void freeFunctionsAsync(functionsLibCtx *functions_lib_ctx) {
    if (functionsLibCtxfunctionsLen(functions_lib_ctx) > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,functionsLibCtxfunctionsLen(functions_lib_ctx));
        bioCreateLazyFreeJob(lazyFreeFunctionsCtx,1,functions_lib_ctx);
    } else {
        functionsLibCtxFree(functions_lib_ctx);
    }
}",207.0,214.0,1.0,57.0,8.0,1,1,4,2,1,4,2,2,1,3,,0,2,2,1,1,void
4010,153756,freeReplicationBacklogRefMemAsync,1,freeReplicationBacklogRefMemAsync,"void freeReplicationBacklogRefMemAsync (list*,rax*)",lazyfree.c,"void freeReplicationBacklogRefMemAsync(list *blocks, rax *index) {
    if (listLength(blocks) > LAZYFREE_THRESHOLD ||
        raxSize(index) > LAZYFREE_THRESHOLD)
    {
        atomicIncr(lazyfree_objects,listLength(blocks)+raxSize(index));
        bioCreateLazyFreeJob(lazyFreeReplicationBacklogRefMem,2,blocks,index);
    } else {
        listRelease(blocks);
        raxFree(index);
    }
}",217.0,227.0,1.0,8.0,11.0,6,4,9,3,1,6,2,2,2,3,,0,4,4,2,2,void
4011,153836,lpAssertValidEntry,1,lpAssertValidEntry,"void lpAssertValidEntry (unsigned char*,size_t,unsigned char*)",listpack.c,"static inline void lpAssertValidEntry(unsigned char* lp, size_t lpbytes, unsigned char *p) {
    assert(lpValidateNext(lp, &p, lpbytes));
}",1341.0,1343.0,1.0,4.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,void
4012,153843,lpSafeToAdd,1,lpSafeToAdd,"int lpSafeToAdd (unsigned char*,size_t)",listpack.c,"int lpSafeToAdd(unsigned char* lp, size_t add) {
    size_t len = lp? lpGetTotalBytes(lp): 0;
    if (len + add > LISTPACK_MAX_SAFETY_SIZE)
        return 0;
    return 1;
}",145.0,150.0,1.0,21.0,6.0,16,7,9,3,0,0,2,2,0,0,,0,0,4,2,2,int
4013,153900,lpStringToInt64,1,lpStringToInt64,"int lpStringToInt64 (char*,long unsigned,int64_t*)",listpack.c,"int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {
    const char *p = s;
    unsigned long plen = 0;
    int negative = 0;
    uint64_t v;

    /* Abort if length indicates this cannot possibly be an int */
    if (slen == 0 || slen >= LONG_STR_SIZE)
        return 0;

    /* Special case: first and only digit is 0. */
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }

    if (p[0] == '-') {
        negative = 1;
        p++; plen++;

        /* Abort on only a negative sign. */
        if (plen == slen)
            return 0;
    }

    /* First digit should be 1-9, otherwise the string should just be 0. */
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else {
        return 0;
    }

    while (plen < slen && p[0] >= '0' && p[0] <= '9') {
        if (v > (UINT64_MAX / 10)) /* Overflow. */
            return 0;
        v *= 10;

        if (v > (UINT64_MAX - (p[0]-'0'))) /...",176.0,235.0,1.0,29.0,60.0,57,18,46,10,1,0,14,20,0,0,,0,0,6,3,3,int
4014,154110,lpNew,1,lpNew,unsigned char* lpNew (size_t),listpack.c,"unsigned char *lpNew(size_t capacity) {
    unsigned char *lp = lp_malloc(capacity > LP_HDR_SIZE+1 ? capacity : LP_HDR_SIZE+1);
    if (lp == NULL) return NULL;
    lpSetTotalBytes(lp,LP_HDR_SIZE+1);
    lpSetNumElements(lp,0);
    lp[LP_HDR_SIZE] = LP_EOF;
    return lp;
}",242.0,249.0,1.0,24.0,8.0,34,8,17,3,5,1,2,2,0,1,,0,1,2,1,1,unsigned char*
4015,154221,lpFree,1,lpFree,void lpFree (unsigned char*),listpack.c,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}",252.0,254.0,1.0,4.0,3.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void
4016,154230,lpShrinkToFit,1,lpShrinkToFit,unsigned char* lpShrinkToFit (unsigned char*),listpack.c,"unsigned char* lpShrinkToFit(unsigned char *lp) {
    size_t size = lpGetTotalBytes(lp);
    if (size < lp_malloc_size(lp)) {
        return lp_realloc(lp, size);
    } else {
        return lp;
    }
}",257.0,264.0,1.0,18.0,8.0,13,5,13,3,3,2,2,2,1,2,,0,1,2,1,1,unsigned char*
4017,154289,lpEncodeIntegerGetType,1,lpEncodeIntegerGetType,"void lpEncodeIntegerGetType (int64_t,unsigned char*,uint64_t*)",listpack.c,"static inline void lpEncodeIntegerGetType(int64_t v, unsigned char *intenc, uint64_t *enclen) {
    if (v >= 0 && v <= 127) {
        /* Single byte 0-127 integer. */
        intenc[0] = v;
        *enclen = 1;
    } else if (v >= -4096 && v <= 4095) {
        /* 13 bit integer. */
        if (v < 0) v = ((int64_t)1<<13)+v;
        intenc[0] = (v>>8)|LP_ENCODING_13BIT_INT;
        intenc[1] = v&0xff;
        *enclen = 2;
    } else if (v >= -32768 && v <= 32767) {
        /* 16 bit integer. */
        if (v < 0) v = ((int64_t)1<<16)+v;
        intenc[0] = LP_ENCODING_16BIT_INT;
        intenc[1] = v&0xff;
        intenc[2] = v>>8;
        *enclen = 3;
    } else if (v >= -8388608 && v <= 8388607) {
        /* 24 bit integer. */
        if (v < 0) v = ((int64_t)1<<24)+v;
        intenc[0] = LP_ENCODING_24BIT_INT;
        intenc[1] = v&0xff;
        intenc[2] = (v>>8)&0xff;
        intenc[3] = v>>16;
        *enclen = 4;
    } else if (v >= -2147483648 && v <= 2147483647) {
        /*...",267.0,316.0,1.0,27.0,50.0,7,6,5,3,3,0,2,2,0,0,,0,0,6,3,3,void
4018,154627,lpEncodeGetType,1,lpEncodeGetType,"int lpEncodeGetType (unsigned char*,uint32_t,unsigned char*,uint64_t*)",listpack.c,"static inline int lpEncodeGetType(unsigned char *ele, uint32_t size, unsigned char *intenc, uint64_t *enclen) {
    int64_t v;
    if (lpStringToInt64((const char*)ele, size, &v)) {
        lpEncodeIntegerGetType(v, intenc, enclen);
        return LP_ENCODING_INT;
    } else {
        if (size < 64) *enclen = 1+size;
        else if (size < 4096) *enclen = 2+size;
        else *enclen = 5+(uint64_t)size;
        return LP_ENCODING_STRING;
    }
}",329.0,340.0,1.0,15.0,12.0,2,2,6,5,1,2,2,2,1,2,,0,1,8,4,4,int
4019,154693,lpEncodeBacklen,1,lpEncodeBacklen,"unsigned long lpEncodeBacklen (unsigned char*,uint64_t)",listpack.c,"static inline unsigned long lpEncodeBacklen(unsigned char *buf, uint64_t l) {
    if (l <= 127) {
        if (buf) buf[0] = l;
        return 1;
    } else if (l < 16383) {
        if (buf) {
            buf[0] = l>>7;
            buf[1] = (l&127)|128;
        }
        return 2;
    } else if (l < 2097151) {
        if (buf) {
            buf[0] = l>>14;
            buf[1] = ((l>>7)&127)|128;
            buf[2] = (l&127)|128;
        }
        return 3;
    } else if (l < 268435455) {
        if (buf) {
            buf[0] = l>>21;
            buf[1] = ((l>>14)&127)|128;
            buf[2] = ((l>>7)&127)|128;
            buf[3] = (l&127)|128;
        }
        return 4;
    } else {
        if (buf) {
            buf[0] = l>>28;
            buf[1] = ((l>>21)&127)|128;
            buf[2] = ((l>>14)&127)|128;
            buf[3] = ((l>>7)&127)|128;
            buf[4] = (l&127)|128;
        }
        return 5;
    }
}",347.0,382.0,1.0,1.0,36.0,3,3,4,2,7,0,3,4,0,0,,0,0,4,2,2,unsigned long
4020,154887,lpDecodeBacklen,1,lpDecodeBacklen,uint64_t lpDecodeBacklen (unsigned char*),listpack.c,"static inline uint64_t lpDecodeBacklen(unsigned char *p) {
    uint64_t val = 0;
    uint64_t shift = 0;
    do {
        val |= (uint64_t)(p[0] & 127) << shift;
        if (!(p[0] & 128)) break;
        shift += 7;
        p--;
        if (shift > 28) return UINT64_MAX;
    } while(1);
    return val;
}",386.0,397.0,1.0,1.0,12.0,11,8,11,4,2,0,5,6,0,0,,0,0,2,1,1,uint64_t
4021,154936,lpEncodeString,1,lpEncodeString,"void lpEncodeString (unsigned char*,unsigned char*,uint32_t)",listpack.c,"static inline void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
    if (len < 64) {
        buf[0] = len | LP_ENCODING_6BIT_STR;
        memcpy(buf+1,s,len);
    } else if (len < 4096) {
        buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
        buf[1] = len & 0xff;
        memcpy(buf+2,s,len);
    } else {
        buf[0] = LP_ENCODING_32BIT_STR;
        buf[1] = len & 0xff;
        buf[2] = (len >> 8) & 0xff;
        buf[3] = (len >> 16) & 0xff;
        buf[4] = (len >> 24) & 0xff;
        memcpy(buf+5,s,len);
    }
}",403.0,419.0,1.0,23.0,17.0,5,5,6,3,0,0,2,2,0,0,,0,0,6,3,3,void
4022,155043,lpCurrentEncodedSizeUnsafe,1,lpCurrentEncodedSizeUnsafe,uint32_t lpCurrentEncodedSizeUnsafe (unsigned char*),listpack.c,"static inline uint32_t lpCurrentEncodedSizeUnsafe(unsigned char *p) {
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 4;
    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 5;
    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 9;
    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5+LP_ENCODING_32BIT_STR_LEN(p);
    if (p[0] == LP_EOF) return 1;
    return 0;
}",428.0,440.0,1.0,8.0,13.0,59,6,29,1,4,0,11,11,0,0,,0,0,2,1,1,uint32_t
4023,155260,lpCurrentEncodedSizeBytes,1,lpCurrentEncodedSizeBytes,uint32_t lpCurrentEncodedSizeBytes (unsigned char*),listpack.c,"static inline uint32_t lpCurrentEncodedSizeBytes(unsigned char *p) {
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1;
    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2;
    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5;
    if (p[0] == LP_EOF) return 1;
    return 0;
}",446.0,458.0,1.0,8.0,13.0,38,3,19,1,2,0,11,11,0,0,,0,0,2,1,1,uint32_t
4024,155422,lpSkip,1,lpSkip,unsigned char* lpSkip (unsigned char*),listpack.c,"unsigned char *lpSkip(unsigned char *p) {
    unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p);
    entrylen += lpEncodeBacklen(NULL,entrylen);
    p += entrylen;
    return p;
}",464.0,469.0,1.0,1.0,6.0,3,2,8,3,4,2,1,1,0,2,,0,1,2,1,1,unsigned char*
4025,155442,lpNext,1,lpNext,"unsigned char* lpNext (unsigned char*,unsigned char*)",listpack.c,"unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
    assert(p);
    p = lpSkip(p);
    if (p[0] == LP_EOF) return NULL;
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",474.0,480.0,1.0,4.0,7.0,7,7,10,3,43,4,2,2,0,4,,0,2,4,2,2,unsigned char*
4026,155485,lpPrev,1,lpPrev,"unsigned char* lpPrev (unsigned char*,unsigned char*)",listpack.c,"unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
    assert(p);
    if (p-lp == LP_HDR_SIZE) return NULL;
    p--; /* Seek the first backlen byte of the last element. */
    uint64_t prevlen = lpDecodeBacklen(p);
    prevlen += lpEncodeBacklen(NULL,prevlen);
    p -= prevlen-1; /* Seek the first byte of the previous entry. */
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",485.0,494.0,1.0,4.0,10.0,11,10,17,4,4,5,2,2,0,5,,0,2,4,2,2,unsigned char*
4027,155541,lpFirst,1,lpFirst,unsigned char* lpFirst (unsigned char*),listpack.c,"unsigned char *lpFirst(unsigned char *lp) {
    unsigned char *p = lp + LP_HDR_SIZE; /* Skip the header. */
    if (p[0] == LP_EOF) return NULL;
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",498.0,503.0,1.0,28.0,6.0,4,4,8,3,16,2,2,2,0,2,,0,1,2,1,1,unsigned char*
4028,155572,lpLast,1,lpLast,unsigned char* lpLast (unsigned char*),listpack.c,"unsigned char *lpLast(unsigned char *lp) {
    unsigned char *p = lp+lpGetTotalBytes(lp)-1; /* Seek EOF element. */
    return lpPrev(lp,p); /* Will return NULL if EOF is the only element. */
}",507.0,510.0,1.0,26.0,4.0,14,6,9,2,0,1,1,1,0,1,,0,0,2,1,1,unsigned char*
4029,155618,lpLength,1,lpLength,unsigned long lpLength (unsigned char*),listpack.c,"unsigned long lpLength(unsigned char *lp) {
    uint32_t numele = lpGetNumElements(lp);
    if (numele != LP_HDR_NUMELE_UNKNOWN) return numele;

    /* Too many elements inside the listpack. We need to scan in order
     * to get the total number. */
    uint32_t count = 0;
    unsigned char *p = lpFirst(lp);
    while(p) {
        count++;
        p = lpNext(lp,p);
    }

    /* If the count is again within range of the header numele field,
     * set it. */
    if (count < LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count);
    return count;
}",517.0,534.0,1.0,22.0,18.0,19,9,24,5,14,2,4,4,0,2,,0,2,2,1,1,unsigned long
4030,155702,lpGetWithSize,1,lpGetWithSize,"unsigned char* lpGetWithSize (unsigned char*,int64_t*,unsigned char*,uint64_t*)",listpack.c,"static inline unsigned char *lpGetWithSize(unsigned char *p, int64_t *count, unsigned char *intbuf, uint64_t *entry_size) {
    int64_t val;
    uint64_t uval, negstart, negmax;

    assert(p); /* assertion for valgrind (avoid NPD) */
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
        negstart = UINT64_MAX; /* 7 bit ints are always positive. */
        negmax = 0;
        uval = p[0] & 0x7f;
        if (entry_size) *entry_size = LP_ENCODING_7BIT_UINT_ENTRY_SIZE;
    } else if (LP_ENCODING_IS_6BIT_STR(p[0])) {
        *count = LP_ENCODING_6BIT_STR_LEN(p);
        if (entry_size) *entry_size = 1 + *count + lpEncodeBacklen(NULL, *count + 1);
        return p+1;
    } else if (LP_ENCODING_IS_13BIT_INT(p[0])) {
        uval = ((p[0]&0x1f)<<8) | p[1];
        negstart = (uint64_t)1<<12;
        negmax = 8191;
        if (entry_size) *entry_size = LP_ENCODING_13BIT_INT_ENTRY_SIZE;
    } else if (LP_ENCODING_IS_16BIT_INT(p[0])) {
        uval = (uint64_t)p[1] |
               (uint64_t)p[2]<...",572.0,660.0,1.0,4.0,89.0,26,12,25,9,2,2,5,6,0,2,,0,1,8,4,4,unsigned char*
4031,156324,lpGet,1,lpGet,"unsigned char* lpGet (unsigned char*,int64_t*,unsigned char*)",listpack.c,"unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {
    return lpGetWithSize(p, count, intbuf, NULL);
}",662.0,664.0,1.0,1.0,3.0,0,0,4,4,6,1,1,1,0,1,,0,0,6,3,3,unsigned char*
4032,156337,lpGetValue,1,lpGetValue,"unsigned char* lpGetValue (unsigned char*,unsigned int*,long long*)",listpack.c,"unsigned char *lpGetValue(unsigned char *p, unsigned int *slen, long long *lval) {
    unsigned char *vstr;
    int64_t ele_len;

    vstr = lpGet(p, &ele_len, NULL);
    if (vstr) {
        *slen = ele_len;
    } else {
        *lval = ele_len;
    }
    return vstr;
}",671.0,682.0,1.0,1.0,12.0,4,3,8,5,21,1,2,2,0,1,,0,1,6,3,3,unsigned char*
4033,156368,lpFind,1,lpFind,"unsigned char* lpFind (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned int)",listpack.c,"unsigned char *lpFind(unsigned char *lp, unsigned char *p, unsigned char *s, 
                      uint32_t slen, unsigned int skip) {
    int skipcnt = 0;
    unsigned char vencoding = 0;
    unsigned char *value;
    int64_t ll, vll;
    uint64_t entry_size = 123456789; /* initialized to avoid warning. */
    uint32_t lp_bytes = lpBytes(lp);

    assert(p);
    while (p) {
        if (skipcnt == 0) {
            value = lpGetWithSize(p, &ll, NULL, &entry_size);
            if (value) {
                /* check the value doesn't reach outside the listpack before accessing it */
                assert(p >= lp + LP_HDR_SIZE && p + entry_size < lp + lp_bytes);
                if (slen == ll && memcmp(value, s, slen) == 0) {
                    return p;
                }
            } else {
                /* Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is s...",686.0,750.0,1.0,4.0,65.0,32,13,39,12,2,5,8,15,0,5,,0,2,10,5,5,unsigned char*
4034,156581,lpInsert,1,lpInsert,"unsigned char* lpInsert (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)",listpack.c,"unsigned char *lpInsert(unsigned char *lp, unsigned char *elestr, unsigned char *eleint,
                        uint32_t size, unsigned char *p, int where, unsigned char **newp)
{
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
    unsigned char backlen[LP_MAX_BACKLEN_SIZE];

    uint64_t enclen; /* The length of the encoded element. */
    int delete = (elestr == NULL && eleint == NULL);

    /* when deletion, it is conceptually replacing the element with a
     * zero-length element. So whatever we get passed as 'where', set
     * it to LP_REPLACE. */
    if (delete) where = LP_REPLACE;

    /* If we need to insert after the current element, we just jump to the
     * next element (that could be the EOF one) and handle the case of
     * inserting before. So the function will actually deal with just two
     * cases: LP_BEFORE and LP_REPLACE. */
    if (where == LP_AFTER) {
        p = lpSkip(p);
        where = LP_BEFORE;
        ASSERT_INTEGRITY(lp, p);
    }

    /* Store ...",780.0,927.0,1.0,25.0,148.0,142,23,152,22,6,10,19,27,3,10,,0,7,14,7,7,unsigned char*
4035,157167,lpInsertString,1,lpInsertString,"unsigned char* lpInsertString (unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)",listpack.c,"unsigned char *lpInsertString(unsigned char *lp, unsigned char *s, uint32_t slen,
                              unsigned char *p, int where, unsigned char **newp)
{
    return lpInsert(lp, s, NULL, slen, p, where, newp);
}",930.0,934.0,1.0,1.0,5.0,0,0,7,7,1,1,1,1,0,1,,0,0,12,6,6,unsigned char*
4036,157186,lpInsertInteger,1,lpInsertInteger,"unsigned char* lpInsertInteger (unsigned char*,long long,unsigned char*,int,unsigned char**)",listpack.c,"unsigned char *lpInsertInteger(unsigned char *lp, long long lval, unsigned char *p, int where, unsigned char **newp) {
    uint64_t enclen; /* The length of the encoded element. */
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];

    lpEncodeIntegerGetType(lval, intenc, &enclen);
    return lpInsert(lp, NULL, intenc, enclen, p, where, newp);
}",938.0,944.0,1.0,25.0,7.0,1,1,10,8,3,2,1,1,0,2,,0,0,10,5,5,unsigned char*
4037,157211,lpPrepend,1,lpPrepend,"unsigned char* lpPrepend (unsigned char*,unsigned char*,uint32_t)",listpack.c,"unsigned char *lpPrepend(unsigned char *lp, unsigned char *s, uint32_t slen) {
    unsigned char *p = lpFirst(lp);
    if (!p) return lpAppend(lp, s, slen);
    return lpInsert(lp, s, NULL, slen, p, LP_BEFORE, NULL);
}",947.0,951.0,1.0,42.0,5.0,2,2,12,5,2,3,2,2,0,3,,0,1,6,3,3,unsigned char*
4038,157243,lpPrependInteger,1,lpPrependInteger,"unsigned char* lpPrependInteger (unsigned char*,long long)",listpack.c,"unsigned char *lpPrependInteger(unsigned char *lp, long long lval) {
    unsigned char *p = lpFirst(lp);
    if (!p) return lpAppendInteger(lp, lval);
    return lpInsertInteger(lp, lval, p, LP_BEFORE, NULL);
}",954.0,958.0,1.0,40.0,5.0,2,2,9,4,0,3,2,2,0,3,,0,1,4,2,2,unsigned char*
4039,157271,lpAppend,1,lpAppend,"unsigned char* lpAppend (unsigned char*,unsigned char*,uint32_t)",listpack.c,"unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
    uint64_t listpack_bytes = lpGetTotalBytes(lp);
    unsigned char *eofptr = lp + listpack_bytes - 1;
    return lpInsert(lp,ele,NULL,size,eofptr,LP_BEFORE,NULL);
}",963.0,967.0,1.0,30.0,5.0,15,6,15,6,5,1,1,1,0,1,,0,0,6,3,3,unsigned char*
4040,157330,lpAppendInteger,1,lpAppendInteger,"unsigned char* lpAppendInteger (unsigned char*,long long)",listpack.c,"unsigned char *lpAppendInteger(unsigned char *lp, long long lval) {
    uint64_t listpack_bytes = lpGetTotalBytes(lp);
    unsigned char *eofptr = lp + listpack_bytes - 1;
    return lpInsertInteger(lp, lval, eofptr, LP_BEFORE, NULL);
}",970.0,974.0,1.0,30.0,5.0,15,6,13,5,2,1,1,1,0,1,,0,0,4,2,2,unsigned char*
4041,157386,lpReplace,1,lpReplace,"unsigned char* lpReplace (unsigned char*,unsigned char**,unsigned char*,uint32_t)",listpack.c,"unsigned char *lpReplace(unsigned char *lp, unsigned char **p, unsigned char *s, uint32_t slen) {
    return lpInsert(lp, s, NULL, slen, *p, LP_REPLACE, p);
}",979.0,981.0,1.0,43.0,3.0,1,1,6,5,1,1,1,1,0,1,,0,0,8,4,4,unsigned char*
4042,157406,lpReplaceInteger,1,lpReplaceInteger,"unsigned char* lpReplaceInteger (unsigned char*,unsigned char**,long long)",listpack.c,"unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **p, long long lval) {
    return lpInsertInteger(lp, lval, *p, LP_REPLACE, p);
}",987.0,989.0,1.0,41.0,3.0,1,1,4,3,3,1,1,1,0,1,,0,0,6,3,3,unsigned char*
4043,157423,lpDelete,1,lpDelete,"unsigned char* lpDelete (unsigned char*,unsigned char*,unsigned char**)",listpack.c,"unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
    return lpInsert(lp,NULL,NULL,0,p,LP_REPLACE,newp);
}",995.0,997.0,1.0,37.0,3.0,0,0,5,4,2,1,1,1,0,1,,0,0,6,3,3,unsigned char*
4044,157441,lpDeleteRangeWithEntry,1,lpDeleteRangeWithEntry,"unsigned char* lpDeleteRangeWithEntry (unsigned char*,unsigned char**,long unsigned)",listpack.c,"unsigned char *lpDeleteRangeWithEntry(unsigned char *lp, unsigned char **p, unsigned long num) {
    size_t bytes = lpBytes(lp);
    unsigned long deleted = 0;
    unsigned char *eofptr = lp + bytes - 1;
    unsigned char *first, *tail;
    first = tail = *p;

    if (num == 0) return lp;  /* Nothing to delete, return ASAP. */

    /* Find the next entry to the last entry that needs to be deleted.
     * lpLength may be unreliable due to corrupt data, so we cannot
     * treat 'num' as the number of elements to be deleted. */
    while (num--) {
        deleted++;
        tail = lpSkip(tail);
        if (tail[0] == LP_EOF) break;
        lpAssertValidEntry(lp, bytes, tail);
    }

    /* Store the offset of the element 'first', so that we can obtain its
     * address again after a reallocation. */
    unsigned long poff = first-lp;

    /* Move tail to the front of the listpack */
    memmove(first, tail, eofptr - tail + 1);
    lpSetTotalBytes(lp, bytes - (tail - first));
    uint...",1000.0,1036.0,1.0,23.0,37.0,66,13,65,12,3,4,7,7,0,4,,0,3,6,3,3,unsigned char*
4045,157652,lpDeleteRange,1,lpDeleteRange,"unsigned char* lpDeleteRange (unsigned char*,long,long unsigned)",listpack.c,"unsigned char *lpDeleteRange(unsigned char *lp, long index, unsigned long num) {
    unsigned char *p;
    uint32_t numele = lpGetNumElements(lp);

    if (num == 0) return lp; /* Nothing to delete, return ASAP. */
    if ((p = lpSeek(lp, index)) == NULL) return lp;

    /* If we know we're gonna delete beyond the end of the listpack, we can just move
     * the EOF marker, and there's no need to iterate through the entries,
     * but if we can't be sure how many entries there are, we rather avoid calling lpLength
     * since that means an additional iteration on all elements.
     *
     * Note that index could overflow, but we use the value after seek, so when we
     * use it no overflow happens. */
    if (numele != LP_HDR_NUMELE_UNKNOWN && index < 0) index = (long)numele + index;
    if (numele != LP_HDR_NUMELE_UNKNOWN && (numele - (unsigned long)index) <= num) {
        p[0] = LP_EOF;
        lpSetTotalBytes(lp, p - lp + 1);
        lpSetNumElements(lp, index);
        lp = ...",1039.0,1064.0,1.0,22.0,26.0,53,14,45,7,3,2,5,5,1,2,,0,2,6,3,3,unsigned char*
4046,157831,lpBatchDelete,1,lpBatchDelete,"unsigned char* lpBatchDelete (unsigned char*,unsigned char**,long unsigned)",listpack.c,"unsigned char *lpBatchDelete(unsigned char *lp, unsigned char **ps, unsigned long count) {
    if (count == 0) return lp;
    unsigned char *dst = ps[0];
    size_t total_bytes = lpGetTotalBytes(lp);
    unsigned char *lp_end = lp + total_bytes; /* After the EOF element. */
    assert(lp_end[-1] == LP_EOF);
    /*
     * ----+--------+-----------+--------+---------+-----+---+
     * ... | Delete | Keep      | Delete | Keep    | ... |EOF|
     * ... |xxxxxxxx|           |xxxxxxxx|         | ... |   |
     * ----+--------+-----------+--------+---------+-----+---+
     *     ^        ^           ^                            ^
     *     |        |           |                            |
     *     ps[i]    |           ps[i+1]                      |
     *     skip     keep_start  keep_end                     lp_end
     *
     * The loop memmoves the bytes between keep_start and keep_end to dst.
     */
    for (unsigned long i = 0; i < count; i++) {
        unsigned char *skip = ps[i...",1069.0,1113.0,1.0,25.0,45.0,92,20,73,15,1,6,7,9,0,6,,0,1,6,3,3,unsigned char*
4047,158134,lpMerge,1,lpMerge,"unsigned char* lpMerge (unsigned char**,unsigned char**)",listpack.c,"unsigned char *lpMerge(unsigned char **first, unsigned char **second) {
    /* If any params are null, we can't merge, so NULL. */
    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
        return NULL;

    /* Can't merge same list into itself. */
    if (*first == *second)
        return NULL;

    size_t first_bytes = lpBytes(*first);
    unsigned long first_len = lpLength(*first);

    size_t second_bytes = lpBytes(*second);
    unsigned long second_len = lpLength(*second);

    int append;
    unsigned char *source, *target;
    size_t target_bytes, source_bytes;
    /* Pick the largest listpack so we can resize easily in-place.
     * We must also track if we are now appending or prepending to
     * the target listpack. */
    if (first_bytes >= second_bytes) {
        /* retain first, append second to first. */
        target = *first;
        target_bytes = first_bytes;
        source = *second;
        source_bytes = second_bytes;
        append ...",1130.0,1210.0,1.0,82.0,81.0,75,15,78,16,1,7,6,6,0,7,,0,5,4,2,2,unsigned char*
4048,158434,lpDup,1,lpDup,unsigned char* lpDup (unsigned char*),listpack.c,"unsigned char *lpDup(unsigned char *lp) {
    size_t lpbytes = lpBytes(lp);
    unsigned char *newlp = lp_malloc(lpbytes);
    memcpy(newlp, lp, lpbytes);
    return newlp;
}",1212.0,1217.0,1.0,27.0,6.0,2,1,10,4,0,2,1,1,0,2,,0,2,2,1,1,unsigned char*
4049,158459,lpBytes,1,lpBytes,size_t lpBytes (unsigned char*),listpack.c,"size_t lpBytes(unsigned char *lp) {
    return lpGetTotalBytes(lp);
}",1220.0,1222.0,1.0,11.0,3.0,11,3,5,1,19,0,1,1,0,0,,0,0,2,1,1,size_t
4050,158495,lpEstimateBytesRepeatedInteger,1,lpEstimateBytesRepeatedInteger,"size_t lpEstimateBytesRepeatedInteger (long long,long unsigned)",listpack.c,"size_t lpEstimateBytesRepeatedInteger(long long lval, unsigned long rep) {
    uint64_t enclen;
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
    lpEncodeIntegerGetType(lval, intenc, &enclen);
    unsigned long backlen = lpEncodeBacklen(NULL, enclen);
    return LP_HDR_SIZE + (enclen + backlen) * rep + 1;
}",1225.0,1231.0,1.0,25.0,7.0,6,4,9,6,0,2,1,1,0,2,,0,1,4,2,2,size_t
4051,158526,lpSeek,1,lpSeek,"unsigned char* lpSeek (unsigned char*,long)",listpack.c,"unsigned char *lpSeek(unsigned char *lp, long index) {
    int forward = 1; /* Seek forward by default. */

    /* We want to seek from left to right or the other way around
     * depending on the listpack length and the element position.
     * However if the listpack length cannot be obtained in constant time,
     * we always seek from left to right. */
    uint32_t numele = lpGetNumElements(lp);
    if (numele != LP_HDR_NUMELE_UNKNOWN) {
        if (index < 0) index = (long)numele+index;
        if (index < 0) return NULL; /* Index still < 0 means out of range. */
        if (index >= (long)numele) return NULL; /* Out of range the other side. */
        /* We want to scan right-to-left if the element we are looking for
         * is past the half of the listpack. */
        if (index > (long)numele/2) {
            forward = 0;
            /* Right to left scanning always expects a negative index. Convert
             * our index to negative form. */
            index -= numele...",1238.0,1280.0,1.0,22.0,43.0,25,14,31,7,13,2,8,13,0,2,,0,2,4,2,2,unsigned char*
4052,158663,lpValidateFirst,1,lpValidateFirst,unsigned char* lpValidateFirst (unsigned char*),listpack.c,"unsigned char *lpValidateFirst(unsigned char *lp) {
    unsigned char *p = lp + LP_HDR_SIZE; /* Skip the header. */
    if (p[0] == LP_EOF) return NULL;
    return p;
}",1283.0,1287.0,1.0,28.0,5.0,4,4,5,3,0,0,2,2,0,0,,0,0,2,1,1,unsigned char*
4053,158689,lpValidateNext,1,lpValidateNext,"int lpValidateNext (unsigned char*,unsigned char**,size_t)",listpack.c,"int lpValidateNext(unsigned char *lp, unsigned char **pp, size_t lpbytes) {
#define OUT_OF_RANGE(p) ( \
        (p) < lp + LP_HDR_SIZE || \
        (p) > lp + lpbytes - 1)
    unsigned char *p = *pp;
    if (!p)
        return 0;

    /* Before accessing p, make sure it's valid. */
    if (OUT_OF_RANGE(p))
        return 0;

    if (*p == LP_EOF) {
        *pp = NULL;
        return 1;
    }

    /* check that we can read the encoded size */
    uint32_t lenbytes = lpCurrentEncodedSizeBytes(p);
    if (!lenbytes)
        return 0;

    /* make sure the encoded entry length doesn't reach outside the edge of the listpack */
    if (OUT_OF_RANGE(p + lenbytes))
        return 0;

    /* get the entry length and encoded backlen. */
    unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p);
    unsigned long encodedBacklen = lpEncodeBacklen(NULL,entrylen);
    entrylen += encodedBacklen;

    /* make sure the entry doesn't reach outside the edge of the listpack */
    if (OUT_OF_RANGE(p ...",1292.0,1338.0,1.0,8.0,47.0,41,11,45,9,1,4,8,8,0,4,,0,4,6,3,3,int
4054,158862,lpValidateIntegrity,1,lpValidateIntegrity,"int lpValidateIntegrity (unsigned char*,size_t,int,listpackValidateEntryCB,void*)",listpack.c,"int lpValidateIntegrity(unsigned char *lp, size_t size, int deep, 
                        listpackValidateEntryCB entry_cb, void *cb_userdata) {
    /* Check that we can actually read the header. (and EOF) */
    if (size < LP_HDR_SIZE + 1)
        return 0;

    /* Check that the encoded size in the header must match the allocated size. */
    size_t bytes = lpGetTotalBytes(lp);
    if (bytes != size)
        return 0;

    /* The last byte must be the terminator. */
    if (lp[size-1] != LP_EOF)
        return 0;

    if (!deep)
        return 1;

    /* Validate the individual entries. */
    uint32_t count = 0;
    uint32_t numele = lpGetNumElements(lp);
    unsigned char *p = lp + LP_HDR_SIZE;
    while(p && p[0] != LP_EOF) {
        unsigned char *prev = p;

        /* Validate this entry and move to the next entry in advance
         * to avoid callback crash due to corrupt listpack. */
        if (!lpValidateNext(lp, &p, bytes))
            return 0;

        /* Optionally ...",1348.0,1394.0,1.0,15.0,47.0,43,12,38,11,2,1,10,12,1,1,,0,1,10,5,5,int
4055,159036,lpCompare,1,lpCompare,"unsigned int lpCompare (unsigned char*,unsigned char*,uint32_t)",listpack.c,"unsigned int lpCompare(unsigned char *p, unsigned char *s, uint32_t slen) {
    unsigned char *value;
    int64_t sz;
    if (p[0] == LP_EOF) return 0;

    value = lpGet(p, &sz, NULL);
    if (value) {
        return (slen == sz) && memcmp(value,s,slen) == 0;
    } else {
        /* We use lpStringToInt64() to get an integer representation of the
         * string 's' and compare it to 'sval', it's much faster than convert
         * integer to string and comparing. */
        int64_t sval;
        if (lpStringToInt64((const char*)s, slen, &sval))
            return sz == sval;
    }

    return 0;
}",1398.0,1416.0,1.0,16.0,19.0,7,5,11,6,1,1,3,3,0,1,,0,1,6,3,3,unsigned int
4056,159095,uintCompare,1,uintCompare,"int uintCompare (void*,void*)",ziplist.c,"int uintCompare(const void *a, const void *b) {
    return (*(unsigned int *) a - *(unsigned int *) b);
}",1583.0,1585.0,1.0,1.0,3.0,5,3,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
4057,159111,lpSaveValue,1,lpSaveValue,"void lpSaveValue (unsigned char*,unsigned int,int64_t,listpackEntry*)",listpack.c,"static inline void lpSaveValue(unsigned char *val, unsigned int len, int64_t lval, listpackEntry *dest) {
    dest->sval = val;
    dest->slen = len;
    dest->lval = lval;
}",1424.0,1428.0,1.0,1.0,5.0,6,2,6,4,5,3,1,1,0,0,,0,3,8,4,4,void
4058,159134,lpRandomPair,1,lpRandomPair,"void lpRandomPair (unsigned char*,long unsigned,listpackEntry*,listpackEntry*)",listpack.c,"void lpRandomPair(unsigned char *lp, unsigned long total_count, listpackEntry *key, listpackEntry *val) {
    unsigned char *p;

    /* Avoid div by zero on corrupt listpack */
    assert(total_count);

    /* Generate even numbers, because listpack saved K-V pair */
    int r = (rand() % total_count) * 2;
    assert((p = lpSeek(lp, r)));
    key->sval = lpGetValue(p, &(key->slen), &(key->lval));

    if (!val)
        return;
    assert((p = lpNext(lp, p)));
    val->sval = lpGetValue(p, &(val->slen), &(val->lval));
}",1434.0,1449.0,1.0,4.0,16.0,30,10,19,6,0,13,2,2,0,7,,0,10,8,4,4,void
4059,159235,lpRandomEntries,1,lpRandomEntries,"void lpRandomEntries (unsigned char*,unsigned int,listpackEntry*)",listpack.c,"void lpRandomEntries(unsigned char *lp, unsigned int count, listpackEntry *entries) {
    struct pick {
        unsigned int index;
        unsigned int order;
    } *picks = lp_malloc(count * sizeof(struct pick));
    unsigned int total_size = lpLength(lp);
    assert(total_size);
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = rand() % total_size;
        picks[i].order = i;
    }

    /* Sort by index. */
    qsort(picks, count, sizeof(struct pick), uintCompare);

    /* Iterate over listpack in index order and store the values in the entries
     * array respecting the original order. */
    unsigned char *p = lpFirst(lp);
    unsigned int j = 0; /* index in listpack */
    for (unsigned int i = 0; i < count; i++) {
        /* Advance listpack pointer to until we reach 'index' listpack. */
        while (j < picks[i].index) {
            p = lpNext(lp, p);
            j++;
        }
        int storeorder = picks[i].order;
        unsigned int len = 0;
  ...",1454.0,1486.0,1.0,15.0,33.0,37,13,48,15,1,8,4,5,0,8,,0,5,6,3,3,void
4060,159381,lpRandomPairs,1,lpRandomPairs,"void lpRandomPairs (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)",listpack.c,"void lpRandomPairs(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    unsigned char *p, *key, *value;
    unsigned int klen = 0, vlen = 0;
    long long klval = 0, vlval = 0;

    /* Notice: the index member must be first due to the use in uintCompare */
    typedef struct {
        unsigned int index;
        unsigned int order;
    } rand_pick;
    rand_pick *picks = lp_malloc(sizeof(rand_pick)*count);
    unsigned int total_size = lpLength(lp)/2;

    /* Avoid div by zero on corrupt listpack */
    assert(total_size);

    /* create a pool of random indexes (some may be duplicate). */
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = (rand() % total_size) * 2; /* Generate even indexes */
        /* keep track of the order we picked them */
        picks[i].order = i;
    }

    /* sort by indexes. */
    qsort(picks, count, sizeof(rand_pick), uintCompare);

    /* fetch the elements form the listpack into a output array re...",1492.0,1537.0,1.0,23.0,46.0,57,17,69,19,0,12,5,8,0,12,,0,7,8,4,4,void
4061,159590,lpRandomPairsUnique,1,lpRandomPairsUnique,"unsigned int lpRandomPairsUnique (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)",listpack.c,"unsigned int lpRandomPairsUnique(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    unsigned char *p, *key;
    unsigned int klen = 0;
    long long klval = 0;
    unsigned int total_size = lpLength(lp)/2;
    unsigned int index = 0;
    if (count > total_size)
        count = total_size;

    p = lpFirst(lp);
    unsigned int picked = 0, remaining = count;
    while (picked < count && p) {
        assert((p = lpNextRandom(lp, p, &index, remaining, 1)));
        key = lpGetValue(p, &klen, &klval);
        lpSaveValue(key, klen, klval, &keys[picked]);
        assert((p = lpNext(lp, p)));
        index++;
        if (vals) {
            key = lpGetValue(p, &klen, &klval);
            lpSaveValue(key, klen, klval, &vals[picked]);
        }
        p = lpNext(lp, p);
        remaining--;
        picked++;
        index++;
    }
    return picked;
}",1545.0,1572.0,1.0,8.0,28.0,38,13,52,12,2,11,4,5,0,11,,0,7,8,4,4,unsigned int
4062,159736,lpNextRandom,1,lpNextRandom,"unsigned char* lpNextRandom (unsigned char*,unsigned char*,unsigned int*,unsigned int,int)",listpack.c,"unsigned char *lpNextRandom(unsigned char *lp, unsigned char *p, unsigned int *index,
                            unsigned int remaining, int even_only)
{
    /* To only iterate once, every time we try to pick a member, the probability
     * we pick it is the quotient of the count left we want to pick and the
     * count still we haven't visited. This way, we could make every member be
     * equally likely to be picked. */
    unsigned int i = *index;
    unsigned int total_size = lpLength(lp);
    while (i < total_size && p != NULL) {
        if (even_only && i % 2 != 0) {
            p = lpNext(lp, p);
            i++;
            continue;
        }

        /* Do we pick this element? */
        unsigned int available = total_size - i;
        if (even_only) available /= 2;
        double randomDouble = ((double)rand()) / RAND_MAX;
        double threshold = ((double)remaining) / available;
        if (randomDouble <= threshold) {
            *index = i;
            return p;...",1598.0,1629.0,1.0,1.0,32.0,25,12,34,12,4,3,6,8,0,3,,0,3,10,5,5,unsigned char*
4063,159829,lpRepr,1,lpRepr,void lpRepr (unsigned char*),listpack.c,"void lpRepr(unsigned char *lp) {
    unsigned char *p, *vstr;
    int64_t vlen;
    unsigned char intbuf[LP_INTBUF_SIZE];
    int index = 0;

    printf(""{total bytes %zu} {num entries %lu}\n"", lpBytes(lp), lpLength(lp));
        
    p = lpFirst(lp);
    while(p) {
        uint32_t encoded_size_bytes = lpCurrentEncodedSizeBytes(p);
        uint32_t encoded_size = lpCurrentEncodedSizeUnsafe(p);
        unsigned long back_len = lpEncodeBacklen(NULL, encoded_size);
        printf(
            ""{\n""
                ""\taddr: 0x%08lx,\n""
                ""\tindex: %2d,\n""
                ""\toffset: %1lu,\n""
                ""\thdr+entrylen+backlen: %2lu,\n""
                ""\thdrlen: %3u,\n""
                ""\tbacklen: %2lu,\n""
                ""\tpayload: %1u\n"",
            (long unsigned)p,
            index,
            (unsigned long) (p-lp),
            encoded_size + back_len,
            encoded_size_bytes,
            back_len,
            encoded_size - encoded_size_bytes);
      ...",1632.0,1680.0,1.0,25.0,49.0,20,10,40,12,1,8,5,9,0,8,,0,6,2,1,1,void
4064,160159,listpackValidateEntryCB,1,listpackValidateEntryCB,"int listpackValidateEntryCB (unsigned char*,unsigned int,void*)",listpack.h,"typedef int (*listpackValidateEntryCB)(unsigned char *p, unsigned int head_count, void *userdata);",87.0,87.0,13.0,97.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
4065,160261,is_leap_year,1,is_leap_year,int is_leap_year (time_t),localtime.c,"static int is_leap_year(time_t year) {
    if (year % 4) return 0;         /* A year not divisible by 4 is not leap. */
    else if (year % 100) return 1;  /* If div by 4 and not 100 is surely leap. */
    else if (year % 400) return 0;  /* If div by 100 *and* not by 400 is not leap. */
    else return 1;                  /* If div by 100 and 400 is leap. */
}",52.0,57.0,1.0,1.0,6.0,1,1,1,1,2,0,2,2,0,0,,0,0,2,1,1,int
4066,160295,nolocks_localtime,1,nolocks_localtime,"void nolocks_localtime (tm*,time_t,time_t,int)",localtime.c,"void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {
    const time_t secs_min = 60;
    const time_t secs_hour = 3600;
    const time_t secs_day = 3600*24;

    t -= tz;                            /* Adjust for timezone. */
    t += 3600*dst;                      /* Adjust for daylight time. */
    time_t days = t / secs_day;         /* Days passed since epoch. */
    time_t seconds = t % secs_day;      /* Remaining seconds. */

    tmp->tm_isdst = dst;
    tmp->tm_hour = seconds / secs_hour;
    tmp->tm_min = (seconds % secs_hour) / secs_min;
    tmp->tm_sec = (seconds % secs_hour) % secs_min;

    /* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure
     * where sunday = 0, so to calculate the day of the week we have to add 4
     * and take the modulo by 7. */
    tmp->tm_wday = (days+4)%7;

    /* Calculate the current year. */
    tmp->tm_year = 1970;
    while(1) {
        /* Leap years have one day more. */
        time_t days_this_ye...",59.0,104.0,1.0,1.0,46.0,59,13,52,11,0,2,5,5,0,2,,0,1,8,4,4,void
4067,160481,reqresReset,1,reqresReset,"void reqresReset (client*,int)",logreqres.c,"void reqresReset(client *c, int free_buf) {
    UNUSED(c);
    UNUSED(free_buf);
}",296.0,299.0,1.0,4.0,4.0,2,1,4,2,0,0,1,1,0,0,,0,0,4,2,2,void
4068,160499,reqresSaveClientReplyOffset,1,reqresSaveClientReplyOffset,void reqresSaveClientReplyOffset (client*),logreqres.c,"inline void reqresSaveClientReplyOffset(client *c) {
    UNUSED(c);
}",301.0,303.0,1.0,4.0,3.0,1,1,2,1,2,0,1,1,0,0,,0,0,2,1,1,void
4069,160510,reqresAppendRequest,1,reqresAppendRequest,size_t reqresAppendRequest (client*),logreqres.c,"inline size_t reqresAppendRequest(client *c) {
    UNUSED(c);
    return 0;
}",305.0,308.0,1.0,4.0,4.0,1,1,2,1,1,0,1,1,0,0,,0,0,2,1,1,size_t
4070,160523,reqresAppendResponse,1,reqresAppendResponse,size_t reqresAppendResponse (client*),logreqres.c,"inline size_t reqresAppendResponse(client *c) {
    UNUSED(c);
    return 0;
}",310.0,313.0,1.0,4.0,4.0,1,1,2,1,2,0,1,1,0,0,,0,0,2,1,1,size_t
4071,160547,lolwut5Command,1,lolwut5Command,void lolwut5Command (client*),lolwut5.c,"void lolwut5Command(client *c) {
    long cols = 66;
    long squares_per_row = 8;
    long squares_per_col = 12;

    /* Parse the optional arguments if any. */
    if (c->argc > 1 &&
        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
        return;

    if (c->argc > 2 &&
        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK)
        return;

    if (c->argc > 3 &&
        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK)
        return;

    /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
     * so we have maximum number of columns, rows, and output resolution. */
    if (cols < 1) cols = 1;
    if (cols > 1000) cols = 1000;
    if (squares_per_row < 1) squares_per_row = 1;
    if (squares_per_row > 200) squares_per_row = 200;
    if (squares_per_col < 1) squares_per_col = 1;
    if (squares_per_col > 200) squares_per_col = 200;

    /* Generate some computer art and reply. */
    lwCanvas *ca...",140.0,177.0,1.0,61.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4072,160552,lolwut6Command,1,lolwut6Command,void lolwut6Command (client*),lolwut6.c,"void lolwut6Command(client *c) {
    long cols = 80;
    long rows = 20;

    /* Parse the optional arguments if any. */
    if (c->argc > 1 &&
        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
        return;

    if (c->argc > 2 &&
        getLongFromObjectOrReply(c,c->argv[2],&rows,NULL) != C_OK)
        return;

    /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
     * so we have maximum number of columns, rows, and output resolution. */
    if (cols < 1) cols = 1;
    if (cols > 1000) cols = 1000;
    if (rows < 1) rows = 1;
    if (rows > 1000) rows = 1000;

    /* Generate the city skyline and reply. */
    lwCanvas *canvas = lwCreateCanvas(cols,rows,3);
    generateSkyline(canvas);
    sds rendered = renderCanvas(canvas);
    rendered = sdscat(rendered,
        ""\nDedicated to the 8 bit game developers of past and present.\n""
        ""Original 8 bit image from Plaguemon by hikikomori. Redis ver. "");
    rendered = sdscat(rendered...",169.0,201.0,1.0,61.0,33.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4073,160557,lolwutUnstableCommand,1,lolwutUnstableCommand,void lolwutUnstableCommand (client*),lolwut.c,"void lolwutUnstableCommand(client *c) {
    sds rendered = sdsnew(""Redis ver. "");
    rendered = sdscat(rendered,REDIS_VERSION);
    rendered = sdscatlen(rendered,""\n"",1);
    addReplyVerbatim(c,rendered,sdslen(rendered),""txt"");
    sdsfree(rendered);
}",45.0,51.0,1.0,31.0,7.0,3,1,9,2,0,6,1,1,0,6,,0,4,2,1,1,void
4074,160588,lolwutCommand,1,lolwutCommand,void lolwutCommand (client*),lolwut.c,"void lolwutCommand(client *c) {
    char *v = REDIS_VERSION;
    char verstr[64];

    if (c->argc >= 3 && !strcasecmp(c->argv[1]->ptr,""version"")) {
        long ver;
        if (getLongFromObjectOrReply(c,c->argv[2],&ver,NULL) != C_OK) return;
        snprintf(verstr,sizeof(verstr),""%u.0.0"",(unsigned int)ver);
        v = verstr;

        /* Adjust argv/argc to filter the ""VERSION ..."" option, since the
         * specific LOLWUT version implementations don't know about it
         * and expect their arguments. */
        c->argv += 2;
        c->argc -= 2;
    }

    if ((v[0] == '5' && v[1] == '.' && v[2] != '9') ||
        (v[0] == '4' && v[1] == '.' && v[2] == '9'))
        lolwut5Command(c);
    else if ((v[0] == '6' && v[1] == '.' && v[2] != '9') ||
             (v[0] == '5' && v[1] == '.' && v[2] == '9'))
        lolwut6Command(c);
    else
        lolwutUnstableCommand(c);

    /* Fix back argc/argv in case of VERSION argument. */
    if (v == verstr) {
        c->argv -= 2...",54.0,85.0,1.0,14.0,32.0,41,14,25,5,0,9,5,6,4,2,,0,8,2,1,1,void
4075,160756,lwCreateCanvas,1,lwCreateCanvas,"lwCanvas lwCreateCanvas (int,int,int)",lolwut.c,"lwCanvas *lwCreateCanvas(int width, int height, int bgcolor) {
    lwCanvas *canvas = zmalloc(sizeof(*canvas));
    canvas->width = width;
    canvas->height = height;
    canvas->pixels = zmalloc((size_t)width*height);
    memset(canvas->pixels,bgcolor,(size_t)width*height);
    return canvas;
}",93.0,100.0,1.0,1.0,8.0,14,6,14,4,1,6,1,1,0,2,,0,6,6,3,3,lwCanvas
4076,160802,lwFreeCanvas,1,lwFreeCanvas,void lwFreeCanvas (lwCanvas*),lolwut.c,"void lwFreeCanvas(lwCanvas *canvas) {
    zfree(canvas->pixels);
    zfree(canvas);
}",103.0,106.0,1.0,1.0,4.0,1,1,2,1,0,3,1,1,0,2,,0,1,2,1,1,void
4077,160813,lwDrawPixel,1,lwDrawPixel,"void lwDrawPixel (lwCanvas*,int,int,int)",lolwut.c,"void lwDrawPixel(lwCanvas *canvas, int x, int y, int color) {
    if (x < 0 || x >= canvas->width ||
        y < 0 || y >= canvas->height) return;
    canvas->pixels[x+y*canvas->width] = color;
}",112.0,116.0,1.0,1.0,5.0,15,8,11,4,2,4,2,2,2,0,,0,4,8,4,4,void
4078,160856,lwGetPixel,1,lwGetPixel,"int lwGetPixel (lwCanvas*,int,int)",lolwut.c,"int lwGetPixel(lwCanvas *canvas, int x, int y) {
    if (x < 0 || x >= canvas->width ||
        y < 0 || y >= canvas->height) return 0;
    return canvas->pixels[x+y*canvas->width];
}",119.0,123.0,1.0,1.0,5.0,14,7,10,3,9,4,2,2,2,0,,0,4,6,3,3,int
4079,160898,lwDrawLine,1,lwDrawLine,"void lwDrawLine (lwCanvas*,int,int,int,int,int)",lolwut.c,"void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
    int dx = abs(x2-x1);
    int dy = abs(y2-y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx-dy, e2;

    while(1) {
        lwDrawPixel(canvas,x1,y1,color);
        if (x1 == x2 && y1 == y2) break;
        e2 = err*2;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}",126.0,146.0,1.0,1.0,21.0,26,11,37,12,0,1,6,8,0,1,,0,0,12,6,6,void
4080,160995,lwDrawSquare,1,lwDrawSquare,"void lwDrawSquare (lwCanvas*,int,int,float,float,int)",lolwut.c,"void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle, int color) {
    int px[4], py[4];

    /* Adjust the desired size according to the fact that the square inscribed
     * into a circle of radius 1 has the side of length SQRT(2). This way
     * size becomes a simple multiplication factor we can use with our
     * coordinates to magnify them. */
    size /= 1.4142135623;
    size = round(size);

    /* Compute the four points. */
    float k = M_PI/4 + angle;
    for (int j = 0; j < 4; j++) {
        px[j] = round(sin(k) * size + x);
        py[j] = round(cos(k) * size + y);
        k += M_PI/2;
    }

    /* Draw the square. */
    for (int j = 0; j < 4; j++)
        lwDrawLine(canvas,px[j],py[j],px[(j+1)%4],py[(j+1)%4],color);
}",167.0,188.0,1.0,1.0,22.0,19,8,22,9,1,0,3,3,0,0,,0,0,12,6,6,void
4081,161165,lwTranslatePixelsGroup,1,lwTranslatePixelsGroup,"void lwTranslatePixelsGroup (int,char*)",lolwut5.c,"void lwTranslatePixelsGroup(int byte, char *output) {
    int code = 0x2800 + byte;
    /* Convert to unicode. This is in the U0800-UFFFF range, so we need to
     * emit it like this in three bytes:
     * 1110xxxx 10xxxxxx 10xxxxxx. */
    output[0] = 0xE0 | (code >> 12);          /* 1110-xxxx */
    output[1] = 0x80 | ((code >> 6) & 0x3F);  /* 10-xxxxxx */
    output[2] = 0x80 | (code & 0x3F);         /* 10-xxxxxx */
}",54.0,62.0,1.0,1.0,9.0,15,6,8,3,1,0,1,1,0,0,,0,0,4,2,2,void
4082,161206,lwDrawSchotter,1,lwDrawSchotter,"lwCanvas lwDrawSchotter (int,int,int)",lolwut5.c,"lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_col) {
    /* Calculate the canvas size. */
    int canvas_width = console_cols*2;
    int padding = canvas_width > 4 ? 2 : 0;
    float square_side = (float)(canvas_width-padding*2) / squares_per_row;
    int canvas_height = square_side * squares_per_col + padding*2;
    lwCanvas *canvas = lwCreateCanvas(canvas_width, canvas_height, 0);

    for (int y = 0; y < squares_per_col; y++) {
        for (int x = 0; x < squares_per_row; x++) {
            int sx = x * square_side + square_side/2 + padding;
            int sy = y * square_side + square_side/2 + padding;
            /* Rotate and translate randomly as we go down to lower
             * rows. */
            float angle = 0;
            if (y > 1) {
                float r1 = (float)rand() / (float) RAND_MAX / squares_per_col * y;
                float r2 = (float)rand() / (float) RAND_MAX / squares_per_col * y;
                float r3 = (float)ra...",71.0,102.0,1.0,1.0,32.0,65,12,65,17,0,2,7,19,0,2,,0,1,6,3,3,lwCanvas
4083,161409,renderCanvas,1,renderCanvas,sds renderCanvas (lwCanvas*),lolwut6.c,"static sds renderCanvas(lwCanvas *canvas) {
    sds text = sdsempty();
    for (int y = 0; y < canvas->height; y++) {
        for (int x = 0; x < canvas->width; x++) {
            int color = lwGetPixel(canvas,x,y);
            char *ce; /* Color escape sequence. */

            /* Note that we set both the foreground and background color.
             * This way we are able to get a more consistent result among
             * different terminals implementations. */
            switch(color) {
            case 0: ce = ""0;30;40m""; break;    /* Black */
            case 1: ce = ""0;90;100m""; break;   /* Gray 1 */
            case 2: ce = ""0;37;47m""; break;    /* Gray 2 */
            case 3: ce = ""0;97;107m""; break;   /* White */
            default: ce = ""0;30;40m""; break;   /* Just for safety. */
            }
            text = sdscatprintf(text,""\033[%s \033[0m"",ce);
        }
        if (y != canvas->height-1) text = sdscatlen(text,""\n"",1);
    }
    return text;
}",47.0,69.0,1.0,1.0,23.0,31,7,50,6,0,15,12,30,11,12,,0,14,2,1,1,sds
4084,161876,generateSkyscraper,1,generateSkyscraper,"void generateSkyscraper (lwCanvas*,skyscraper*)",lolwut6.c,"void generateSkyscraper(lwCanvas *canvas, struct skyscraper *si) {
    int starty = canvas->height-1;
    int endy = starty - si->height + 1;
    for (int y = starty; y >= endy; y--) {
        for (int x = si->xoff; x < si->xoff+si->width; x++) {
            /* The roof is four pixels less wide. */
            if (y == endy && (x <= si->xoff+1 || x >= si->xoff+si->width-2))
                continue;
            int color = si->color;
            /* Alter the color if this is a place where we want to
             * draw a window. We check that we are in the inner part of the
             * skyscraper, so that windows are far from the borders. */
            if (si->windows &&
                x > si->xoff+1 &&
                x < si->xoff+si->width-2 &&
                y > endy+1 &&
                y < starty-1)
            {
                /* Calculate the x,y position relative to the start of
                 * the window area. */
                int relx = x - (si->xoff+1);
      ...",82.0,120.0,1.0,1.0,39.0,64,13,53,9,2,17,9,24,10,2,,0,16,4,2,2,void
4085,162062,generateSkyline,1,generateSkyline,void generateSkyline (lwCanvas*),lolwut6.c,"void generateSkyline(lwCanvas *canvas) {
    struct skyscraper si;

    /* First draw the background skyscraper without windows, using the
     * two different grays. We use two passes to make sure that the lighter
     * ones are always in the background. */
    for (int color = 2; color >= 1; color--) {
        si.color = color;
        for (int offset = -10; offset < canvas->width;) {
            offset += rand() % 8;
            si.xoff = offset;
            si.width = 10 + rand()%9;
            if (color == 2)
                si.height = canvas->height/2 + rand()%canvas->height/2;
            else
                si.height = canvas->height/2 + rand()%canvas->height/3;
            si.windows = 0;
            generateSkyscraper(canvas, &si);
            if (color == 2)
                offset += si.width/2;
            else
                offset += si.width+1;
        }
    }

    /* Now draw the foreground skyscraper with the windows. */
    si.color = 0;
    for (int offset = -...",123.0,160.0,1.0,1.0,38.0,66,12,40,4,0,23,7,13,3,2,,0,21,2,1,1,void
4086,162412,lzf_compress,1,lzf_compress,"size_t lzf_compress (void*,size_t,void*,size_t)",lzf_c.c,"size_t
lzf_compress (const void *const in_data, size_t in_len,
	      void *out_data, size_t out_len
#if LZF_STATE_ARG
              , LZF_STATE htab
#endif
              )
{
#if !LZF_STATE_ARG
  LZF_STATE htab;
#endif
  const u8 *ip = (const u8 *)in_data;
        u8 *op = (u8 *)out_data;
  const u8 *in_end  = ip + in_len;
        u8 *out_end = op + out_len;
  const u8 *ref;

  /* off requires a type wide enough to hold a general pointer difference.
   * ISO C doesn't have that (size_t might not be enough and ptrdiff_t only
   * works for differences within a single object). We also assume that no
   * no bit pattern traps. Since the only platform that is both non-POSIX
   * and fails to support both assumptions is windows 64 bit, we make a
   * special workaround for it.
   */
#if defined (WIN32) && defined (_M_X64)
  unsigned _int64 off; /* workaround for missing POSIX compliance */
#else
  size_t off;
#endif
  unsigned int hval;
  int lit;

  if (!in_len || !out_len)
    return 0...",108.0,301.0,1.0,4.0,194.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,size_t
4087,162420,lzf_decompress,1,lzf_decompress,"size_t lzf_decompress (void*,size_t,void*,size_t)",lzf_d.c,"size_t
lzf_decompress (const void *const in_data,  size_t in_len,
                void             *out_data, size_t out_len)
{
  u8 const *ip = (const u8 *)in_data;
  u8       *op = (u8 *)out_data;
  u8 const *const in_end  = ip + in_len;
  u8       *const out_end = op + out_len;

  while (ip < in_end)
    {
      unsigned int ctrl;
      ctrl = *ip++;

      if (ctrl < (1 << 5)) /* literal run */
        {
          ctrl++;

          if (op + ctrl > out_end)
            {
              SET_ERRNO (E2BIG);
              return 0;
            }

#if CHECK_INPUT
          if (ip + ctrl > in_end)
            {
              SET_ERRNO (EINVAL);
              return 0;
            }
#endif

#ifdef lzf_movsb
          lzf_movsb (op, ip, ctrl);
#else
          switch (ctrl)
            {
              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
              case 28: *op++ = *ip++; case 27: *op++ = *ip++; case 26: *op++ = *ip++; case 25:...",59.0,188.0,1.0,14.0,130.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,size_t
4088,163872,memtest_progress_start,1,memtest_progress_start,"void memtest_progress_start (char*,int)",memtest.c,"void memtest_progress_start(char *title, int pass) {
    int j;

    printf(""\x1b[H\x1b[2J"");    /* Cursor home, clear screen. */
    /* Fill with dots. */
    for (j = 0; j < ws.ws_col*(ws.ws_row-2); j++) printf(""."");
    printf(""Please keep the test running several minutes per GB of memory.\n"");
    printf(""Also check http://www.memtest86.com/ and http://pyropus.ca/software/memtester/"");
    printf(""\x1b[H\x1b[2K"");          /* Cursor home, clear current line.  */
    printf(""%s [%d]\n"", title, pass); /* Print title. */
    progress_printed = 0;
    progress_full = (size_t)ws.ws_col*(ws.ws_row-3);
    fflush(stdout);
}",73.0,86.0,1.0,1.0,14.0,13,6,11,7,5,6,2,2,2,0,,0,6,4,2,2,void
4089,163929,memtest_progress_end,1,memtest_progress_end,void memtest_progress_end (void),memtest.c,"void memtest_progress_end(void) {
    printf(""\x1b[H\x1b[2J"");    /* Cursor home, clear screen. */
}",88.0,90.0,1.0,1.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
4090,163936,memtest_progress_step,1,memtest_progress_step,"void memtest_progress_step (size_t,size_t,char)",memtest.c,"void memtest_progress_step(size_t curr, size_t size, char c) {
    size_t chars = ((unsigned long long)curr*progress_full)/size, j;

    for (j = 0; j < chars-progress_printed; j++) printf(""%c"",c);
    progress_printed = chars;
    fflush(stdout);
}",92.0,98.0,1.0,1.0,7.0,8,6,11,7,5,3,2,2,1,0,,0,3,6,3,3,void
4091,163974,memtest_addressing,1,memtest_addressing,"int memtest_addressing (long unsigned*,size_t,int)",memtest.c,"int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
    unsigned long words = bytes/sizeof(unsigned long);
    unsigned long j, *p;

    /* Fill */
    p = l;
    for (j = 0; j < words; j++) {
        *p = (unsigned long)p;
        p++;
        if ((j & 0xffff) == 0 && interactive)
            memtest_progress_step(j,words*2,'A');
    }
    /* Test */
    p = l;
    for (j = 0; j < words; j++) {
        if (*p != (unsigned long)p) {
            if (interactive) {
                printf(""\n*** MEMORY ADDRESSING ERROR: %p contains %lu\n"",
                    (void*) p, *p);
                exit(1);
            }
            return 1;
        }
        p++;
        if ((j & 0xffff) == 0 && interactive)
            memtest_progress_step(j+words,words*2,'A');
    }
    return 0;
}",103.0,131.0,1.0,1.0,29.0,28,13,31,7,2,2,7,12,0,2,,0,0,6,3,3,int
4092,164084,memtest_fill_random,1,memtest_fill_random,"void memtest_fill_random (long unsigned*,size_t,int)",memtest.c,"void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
    unsigned long step = 4096/sizeof(unsigned long);
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long iwords = words/step;  /* words per iteration */
    unsigned long off, w, *l1, *l2;
    uint64_t rseed = UINT64_C(0xd13133de9afdb566); /* Just a random seed. */
    uint64_t rout = 0;

    assert((bytes & 4095) == 0);
    for (off = 0; off < step; off++) {
        l1 = l+off;
        l2 = l1+words;
        for (w = 0; w < iwords; w++) {
            xorshift64star_next();
            *l1 = *l2 = (unsigned long) rout;
            l1 += step;
            l2 += step;
            if ((w & 0xffff) == 0 && interactive)
                memtest_progress_step(w+iwords*off,words,'R');
        }
    }
}",148.0,169.0,1.0,12.0,22.0,38,14,44,13,2,1,4,7,0,1,,0,0,6,3,3,void
4093,164222,memtest_fill_value,1,memtest_fill_value,"void memtest_fill_value (long unsigned*,size_t,long unsigned,long unsigned,char,int)",memtest.c,"void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
                        unsigned long v2, char sym, int interactive)
{
    unsigned long step = 4096/sizeof(unsigned long);
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long iwords = words/step;  /* words per iteration */
    unsigned long off, w, *l1, *l2, v;

    assert((bytes & 4095) == 0);
    for (off = 0; off < step; off++) {
        l1 = l+off;
        l2 = l1+words;
        v = (off & 1) ? v2 : v1;
        for (w = 0; w < iwords; w++) {
#ifdef MEMTEST_32BIT
            *l1 = *l2 = ((unsigned long)     v) |
                        (((unsigned long)    v) << 16);
#else
            *l1 = *l2 = ((unsigned long)     v) |
                        (((unsigned long)    v) << 16) |
                        (((unsigned long)    v) << 32) |
                        (((unsigned long)    v) << 48);
#endif
            l1 += step;
            l2 += step;
            if ((w & 0xffff) == 0 && inte...",173.0,202.0,1.0,1.0,30.0,43,15,42,15,4,1,4,7,0,1,,0,0,12,6,6,void
4094,164355,memtest_compare,1,memtest_compare,"int memtest_compare (long unsigned*,size_t,int)",memtest.c,"int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long w, *l1, *l2;

    assert((bytes & 4095) == 0);
    l1 = l;
    l2 = l1+words;
    for (w = 0; w < words; w++) {
        if (*l1 != *l2) {
            if (interactive) {
                printf(""\n*** MEMORY ERROR DETECTED: %p != %p (%lu vs %lu)\n"",
                    (void*)l1, (void*)l2, *l1, *l2);
                exit(1);
            }
            return 1;
        }
        l1 ++;
        l2 ++;
        if ((w & 0xffff) == 0 && interactive)
            memtest_progress_step(w,words,'=');
    }
    return 0;
}",204.0,226.0,1.0,1.0,23.0,23,12,25,8,1,1,5,9,0,1,,0,0,6,3,3,int
4095,164444,memtest_compare_times,1,memtest_compare_times,"int memtest_compare_times (long unsigned*,size_t,int,int,int)",memtest.c,"int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
                          int interactive)
{
    int j;
    int errors = 0;

    for (j = 0; j < times; j++) {
        if (interactive) memtest_progress_start(""Compare"",pass);
        errors += memtest_compare(m,bytes,interactive);
        if (interactive) memtest_progress_end();
    }
    return errors;
}",228.0,240.0,1.0,1.0,13.0,4,3,12,7,12,3,4,6,0,3,,0,0,10,5,5,int
4096,164487,memtest_test,1,memtest_test,"int memtest_test (long unsigned*,size_t,int,int)",memtest.c,"int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
    int pass = 0;
    int errors = 0;

    while (pass != passes) {
        pass++;

        if (interactive) memtest_progress_start(""Addressing test"",pass);
        errors += memtest_addressing(m,bytes,interactive);
        if (interactive) memtest_progress_end();

        if (interactive) memtest_progress_start(""Random fill"",pass);
        memtest_fill_random(m,bytes,interactive);
        if (interactive) memtest_progress_end();
        errors += memtest_compare_times(m,bytes,pass,4,interactive);

        if (interactive) memtest_progress_start(""Solid fill"",pass);
        memtest_fill_value(m,bytes,0,(unsigned long)-1,'S',interactive);
        if (interactive) memtest_progress_end();
        errors += memtest_compare_times(m,bytes,pass,4,interactive);

        if (interactive) memtest_progress_start(""Checkerboard fill"",pass);
        memtest_fill_value(m,bytes,ULONG_ONEZERO,ULONG_ZEROONE,'C',interactiv...",247.0,274.0,1.0,35.0,28.0,10,6,46,6,1,15,10,18,0,15,,0,0,8,4,4,int
4097,164607,memtest_preserving_test,1,memtest_preserving_test,"int memtest_preserving_test (long unsigned*,size_t,int)",memtest.c,"int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
    unsigned long backup[MEMTEST_BACKUP_WORDS];
    unsigned long *p = m;
    unsigned long *end = (unsigned long*) (((unsigned char*)m)+(bytes-MEMTEST_DECACHE_SIZE));
    size_t left = bytes;
    int errors = 0;

    if (bytes & 4095) return 0; /* Can't test across 4k page boundaries. */
    if (bytes < 4096*2) return 0; /* Can't test a single page. */

    while(left) {
        /* If we have to test a single final page, go back a single page
         * so that we can test two pages, since the code can't test a single
         * page but at least two. */
        if (left == 4096) {
            left += 4096;
            p -= 4096/sizeof(unsigned long);
        }

        int pass = 0;
        size_t len = (left > sizeof(backup)) ? sizeof(backup) : left;

        /* Always test an even number of pages. */
        if (len/4096 % 2) len -= 4096;

        memcpy(backup,p,len); /* Backup. */
        while(pass != p...",292.0,345.0,1.0,25.0,54.0,50,19,74,11,0,13,10,19,0,13,,0,0,6,3,3,int
4098,164869,memtest_alloc_and_test,1,memtest_alloc_and_test,"void memtest_alloc_and_test (size_t,int)",memtest.c,"void memtest_alloc_and_test(size_t megabytes, int passes) {
    size_t bytes = megabytes*1024*1024;
    unsigned long *m = malloc(bytes);

    if (m == NULL) {
        fprintf(stderr,""Unable to allocate %zu megabytes: %s"",
            megabytes, strerror(errno));
        exit(1);
    }
    memtest_test(m,bytes,passes,1);
    free(m);
}",348.0,359.0,1.0,1.0,12.0,5,3,13,7,1,1,2,2,0,1,,0,0,4,2,2,void
4099,164908,memtest,1,memtest,"void memtest (size_t,int)",memtest.c,"void memtest(size_t megabytes, int passes) {
#if !defined(__HAIKU__)
    if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
        ws.ws_col = 80;
        ws.ws_row = 20;
    }
#else
    ws.ws_col = 80;
    ws.ws_row = 20;
#endif
    memtest_alloc_and_test(megabytes,passes);
    printf(""\nYour memory passed this test.\n"");
    printf(""Please if you are still in doubt use the following two tools:\n"");
    printf(""1) memtest86: http://www.memtest86.com/\n"");
    printf(""2) memtester: http://pyropus.ca/software/memtester/\n"");
    exit(0);
}",361.0,377.0,1.0,1.0,17.0,7,5,6,4,0,4,2,2,1,1,,0,3,4,2,2,void
4100,165061,RedisModuleCmdFunc,1,RedisModuleCmdFunc,"int RedisModuleCmdFunc (RedisModuleCtx*,void**,int)",module.c,"typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);",232.0,232.0,13.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
4101,165068,RedisModuleAuthCallback,1,RedisModuleAuthCallback,"int RedisModuleAuthCallback (RedisModuleCtx*,void*,void*,robj**)",module.c,"typedef int (*RedisModuleAuthCallback)(RedisModuleCtx *ctx, void *username, void *password, RedisModuleString **err);",233.0,233.0,13.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
4102,165076,RedisModuleDisconnectFunc,1,RedisModuleDisconnectFunc,"void RedisModuleDisconnectFunc (RedisModuleCtx*,RedisModuleBlockedClient*)",module.c,"typedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);",234.0,234.0,14.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4103,165104,free_privdata,1,RedisModuleBlockedClient.free_privdata,"void RedisModuleBlockedClient.free_privdata (RedisModuleCtx*,void*)",module.c,"void (*free_privdata)(RedisModuleCtx*,void*);",271.0,271.0,10.0,48.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
4104,165142,RedisModuleNotificationFunc,1,RedisModuleNotificationFunc,"int RedisModuleNotificationFunc (RedisModuleCtx*,int,char*,robj*)",module.c,"typedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);",311.0,311.0,13.0,94.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
4105,165150,RedisModulePostNotificationJobFunc,1,RedisModulePostNotificationJobFunc,"void RedisModulePostNotificationJobFunc (RedisModuleCtx*,void*)",module.c,"typedef void (*RedisModulePostNotificationJobFunc) (RedisModuleCtx *ctx, void *pd);",314.0,314.0,14.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4106,165166,free_pd,1,RedisModulePostExecUnitJob.free_pd,void RedisModulePostExecUnitJob.free_pd (void*),module.c,void (*free_pd)(void*);,335.0,335.0,10.0,26.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4107,165188,RedisModuleCommandFilterFunc,1,RedisModuleCommandFilterFunc,void RedisModuleCommandFilterFunc (RedisModuleCommandFilterCtx*),module.c,typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);,362.0,362.0,14.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4108,165199,RedisModuleForkDoneHandler,1,RedisModuleForkDoneHandler,"void RedisModuleForkDoneHandler (int,int,void*)",module.c,"typedef void (*RedisModuleForkDoneHandler) (int exitcode, int bysignal, void *user_data);",376.0,376.0,14.0,88.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
4109,165234,RedisModuleConfigGetStringFunc,1,RedisModuleConfigGetStringFunc,"robj* RedisModuleConfigGetStringFunc (char*,void*)",module.c,"typedef RedisModuleString * (*RedisModuleConfigGetStringFunc)(const char *name, void *privdata);",443.0,443.0,27.0,95.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,robj*
4110,165240,RedisModuleConfigGetNumericFunc,1,RedisModuleConfigGetNumericFunc,"long long RedisModuleConfigGetNumericFunc (char*,void*)",module.c,"typedef long long (*RedisModuleConfigGetNumericFunc)(const char *name, void *privdata);",444.0,444.0,19.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,long long
4111,165246,RedisModuleConfigGetBoolFunc,1,RedisModuleConfigGetBoolFunc,"int RedisModuleConfigGetBoolFunc (char*,void*)",module.c,"typedef int (*RedisModuleConfigGetBoolFunc)(const char *name, void *privdata);",445.0,445.0,13.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
4112,165252,RedisModuleConfigGetEnumFunc,1,RedisModuleConfigGetEnumFunc,"int RedisModuleConfigGetEnumFunc (char*,void*)",module.c,"typedef int (*RedisModuleConfigGetEnumFunc)(const char *name, void *privdata);",446.0,446.0,13.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
4113,165258,RedisModuleConfigSetStringFunc,1,RedisModuleConfigSetStringFunc,"int RedisModuleConfigSetStringFunc (char*,robj*,void*,robj**)",module.c,"typedef int (*RedisModuleConfigSetStringFunc)(const char *name, RedisModuleString *val, void *privdata, RedisModuleString **err);",448.0,448.0,13.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
4114,165266,RedisModuleConfigSetNumericFunc,1,RedisModuleConfigSetNumericFunc,"int RedisModuleConfigSetNumericFunc (char*,long long,void*,robj**)",module.c,"typedef int (*RedisModuleConfigSetNumericFunc)(const char *name, long long val, void *privdata, RedisModuleString **err);",449.0,449.0,13.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
4115,165274,RedisModuleConfigSetBoolFunc,1,RedisModuleConfigSetBoolFunc,"int RedisModuleConfigSetBoolFunc (char*,int,void*,robj**)",module.c,"typedef int (*RedisModuleConfigSetBoolFunc)(const char *name, int val, void *privdata, RedisModuleString **err);",450.0,450.0,13.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
4116,165282,RedisModuleConfigSetEnumFunc,1,RedisModuleConfigSetEnumFunc,"int RedisModuleConfigSetEnumFunc (char*,int,void*,robj**)",module.c,"typedef int (*RedisModuleConfigSetEnumFunc)(const char *name, int val, void *privdata, RedisModuleString **err);",451.0,451.0,13.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
4117,165290,RedisModuleConfigApplyFunc,1,RedisModuleConfigApplyFunc,"int RedisModuleConfigApplyFunc (RedisModuleCtx*,void*,robj**)",module.c,"typedef int (*RedisModuleConfigApplyFunc)(RedisModuleCtx *ctx, void *privdata, RedisModuleString **err);",453.0,453.0,13.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
4118,165322,RM_FreeCallReply,1,RM_FreeCallReply,void RM_FreeCallReply (RedisModuleCallReply*),module.c,"void RM_FreeCallReply(RedisModuleCallReply *reply) {
    /* This is a wrapper for the recursive free reply function. This is needed
     * in order to have the first level function to return on nested replies,
     * but only if called by the module API. */

    RedisModuleCtx *ctx = NULL;
    if(callReplyType(reply) == REDISMODULE_REPLY_PROMISE) {
        RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
        ctx = promise->ctx;
        freeRedisModuleAsyncRMCallPromise(promise);
    } else {
        ctx = callReplyGetPrivateData(reply);
    }

    freeCallReply(reply);
    if (ctx) {
        autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);
    }
}",5812.0,5830.0,1.0,31.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4119,165327,RM_CloseKey,1,RM_CloseKey,void RM_CloseKey (RedisModuleKey*),module.c,"void RM_CloseKey(RedisModuleKey *key) {
    if (key == NULL) return;
    moduleCloseKey(key);
    autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);
    zfree(key);
}",4058.0,4063.0,1.0,29.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4120,165332,autoMemoryCollect,1,autoMemoryCollect,void autoMemoryCollect (RedisModuleCtx*),module.c,"void autoMemoryCollect(RedisModuleCtx *ctx) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
    /* Clear the AUTO_MEMORY flag from the context, otherwise the functions
     * we call to free the resources, will try to scan the auto release
     * queue to mark the entries as freed. */
    ctx->flags &= ~REDISMODULE_CTX_AUTO_MEMORY;
    int j;
    for (j = 0; j < ctx->amqueue_used; j++) {
        void *ptr = ctx->amqueue[j].ptr;
        switch(ctx->amqueue[j].type) {
        case REDISMODULE_AM_STRING: decrRefCount(ptr); break;
        case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;
        case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;
        case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;
        case REDISMODULE_AM_INFO: RM_FreeServerInfo(NULL,ptr); break;
        }
    }
    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
    zfree(ctx->amqueue);
    ctx->amqueue = NULL;
    ctx->amqueue_len = 0;
    ctx->amqueue_used = 0;
}",2492.0,2514.0,1.0,23.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4121,165337,moduleCreateArgvFromUserFormat,1,moduleCreateArgvFromUserFormat,"robj** moduleCreateArgvFromUserFormat (char*,char*,int*,int*,va_list)",module.c,"robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {
    int argc = 0, argv_size, j;
    robj **argv = NULL;

    /* As a first guess to avoid useless reallocations, size argv to
     * hold one argument for each char specifier in 'fmt'. */
    argv_size = strlen(fmt)+1; /* +1 because of the command name. */
    argv = zrealloc(argv,sizeof(robj*)*argv_size);

    /* Build the arguments vector based on the format specifier. */
    argv[0] = createStringObject(cmdname,strlen(cmdname));
    argc++;

    /* Create the client and dispatch the command. */
    const char *p = fmt;
    while(*p) {
        if (*p == 'c') {
            char *cstr = va_arg(ap,char*);
            argv[argc++] = createStringObject(cstr,strlen(cstr));
        } else if (*p == 's') {
            robj *obj = va_arg(ap,void*);
            if (obj->refcount == OBJ_STATIC_REFCOUNT)
                obj = createStringObject(obj->ptr,sdslen(obj->ptr));
        ...",6014.0,6100.0,1.0,33.0,87.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,robj
4122,165346,RM_ZsetRangeStop,1,RM_ZsetRangeStop,void RM_ZsetRangeStop (RedisModuleKey*),module.c,"void RM_ZsetRangeStop(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return;
    /* Free resources if needed. */
    if (key->u.zset.type == REDISMODULE_ZSET_RANGE_LEX)
        zslFreeLexRange(&key->u.zset.lrs);
    /* Setup sensible values so that misused iteration API calls when an
     * iterator is not active will result into something more sensible
     * than crashing. */
    zsetKeyReset(key);
}",4795.0,4804.0,1.0,43.0,10.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
4123,165351,zsetKeyReset,1,zsetKeyReset,void zsetKeyReset (RedisModuleKey*),module.c,"void zsetKeyReset(RedisModuleKey *key) {
    key->u.zset.type = REDISMODULE_ZSET_RANGE_NONE;
    key->u.zset.current = NULL;
    key->u.zset.er = 1;
}",4788.0,4792.0,1.0,23.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4124,165356,moduleInitKeyTypeSpecific,1,moduleInitKeyTypeSpecific,void moduleInitKeyTypeSpecific (RedisModuleKey*),module.c,"static void moduleInitKeyTypeSpecific(RedisModuleKey *key) {
    switch (key->value->type) {
    case OBJ_ZSET: zsetKeyReset(key); break;
    case OBJ_STREAM: key->u.stream.signalready = 0; break;
    }
}",3964.0,3969.0,1.0,9.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
4125,165361,RM_FreeDict,1,RM_FreeDict,"void RM_FreeDict (RedisModuleCtx*,RedisModuleDict*)",module.c,"void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);
    raxFree(d->rax);
    zfree(d);
}",9886.0,9890.0,1.0,41.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4126,165367,RM_FreeServerInfo,1,RM_FreeServerInfo,"void RM_FreeServerInfo (RedisModuleCtx*,RedisModuleServerInfoData*)",module.c,"void RM_FreeServerInfo(RedisModuleCtx *ctx, RedisModuleServerInfoData *data) {
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_INFO,data);
    raxFreeWithCallback(data->rax, (void(*)(void*))sdsfree);
    zfree(data);
}",10342.0,10346.0,1.0,41.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4127,165373,moduleValidateCommandInfo,1,moduleValidateCommandInfo,int moduleValidateCommandInfo (RedisModuleCommandInfo*),module.c,"static int moduleValidateCommandInfo(const RedisModuleCommandInfo *info) {
    const RedisModuleCommandInfoVersion *version = info->version;
    if (!version) {
        serverLog(LL_WARNING, ""Invalid command info: version missing"");
        return 0;
    }

    /* No validation for the fields summary, complexity, since, tips (strings or
     * NULL) and arity (any integer). */

    /* History: If since is set, changes must also be set. */
    if (info->history) {
        for (size_t j = 0;
             moduleCmdHistoryEntryAt(version, info->history, j)->since;
             j++)
        {
            if (!moduleCmdHistoryEntryAt(version, info->history, j)->changes) {
                serverLog(LL_WARNING, ""Invalid command info: history[%zd].changes missing"", j);
                return 0;
            }
        }
    }

    /* Key specs. */
    if (info->key_specs) {
        for (size_t j = 0;
             moduleCmdKeySpecAt(version, info->key_specs, j)->begin_search_type;
             ...",1953.0,2047.0,1.0,8.0,95.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4128,165378,moduleConvertKeySpecsFlags,1,moduleConvertKeySpecsFlags,"int64_t moduleConvertKeySpecsFlags (int64_t,int)",module.c,"static int64_t moduleConvertKeySpecsFlags(int64_t flags, int from_api) {
    int64_t out = 0;
    int64_t map[][2] = {
        {REDISMODULE_CMD_KEY_RO, CMD_KEY_RO},
        {REDISMODULE_CMD_KEY_RW, CMD_KEY_RW},
        {REDISMODULE_CMD_KEY_OW, CMD_KEY_OW},
        {REDISMODULE_CMD_KEY_RM, CMD_KEY_RM},
        {REDISMODULE_CMD_KEY_ACCESS, CMD_KEY_ACCESS},
        {REDISMODULE_CMD_KEY_INSERT, CMD_KEY_INSERT},
        {REDISMODULE_CMD_KEY_UPDATE, CMD_KEY_UPDATE},
        {REDISMODULE_CMD_KEY_DELETE, CMD_KEY_DELETE},
        {REDISMODULE_CMD_KEY_NOT_KEY, CMD_KEY_NOT_KEY},
        {REDISMODULE_CMD_KEY_INCOMPLETE, CMD_KEY_INCOMPLETE},
        {REDISMODULE_CMD_KEY_VARIABLE_FLAGS, CMD_KEY_VARIABLE_FLAGS},
        {0,0}};

    int from_idx = from_api ? 0 : 1, to_idx = !from_idx;
    for (int i=0; map[i][0]; i++)
        if (flags & map[i][from_idx]) out |= map[i][to_idx];
    return out;
}",2051.0,2071.0,1.0,9.0,21.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int64_t
4129,165384,moduleValidateCommandArgs,1,moduleValidateCommandArgs,"int moduleValidateCommandArgs (RedisModuleCommandArg*,RedisModuleCommandInfoVersion*)",module.c,"static int moduleValidateCommandArgs(RedisModuleCommandArg *args,
                                     const RedisModuleCommandInfoVersion *version) {
    if (args == NULL) return 1; /* Missing args is OK. */
    for (size_t j = 0; moduleCmdArgAt(version, args, j)->name != NULL; j++) {
        RedisModuleCommandArg *arg = moduleCmdArgAt(version, args, j);
        int arg_type_error = 0;
        moduleConvertArgType(arg->type, &arg_type_error);
        if (arg_type_error) {
            serverLog(LL_WARNING,
                      ""Invalid command info: Argument \""%s\"": Undefined type %d"",
                      arg->name, arg->type);
            return 0;
        }
        if (arg->type == REDISMODULE_ARG_TYPE_PURE_TOKEN && !arg->token) {
            serverLog(LL_WARNING,
                      ""Invalid command info: Argument \""%s\"": ""
                      ""token required when type is PURE_TOKEN"", args[j].name);
            return 0;
        }

        if (arg->type == REDISMODULE_ARG_...",2075.0,2142.0,1.0,12.0,68.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
4130,165392,moduleConvertArgType,1,moduleConvertArgType,"redisCommandArgType moduleConvertArgType (RedisModuleCommandArgType,int*)",module.c,"static redisCommandArgType moduleConvertArgType(RedisModuleCommandArgType type, int *error) {
    if (error) *error = 0;
    switch (type) {
    case REDISMODULE_ARG_TYPE_STRING: return ARG_TYPE_STRING;
    case REDISMODULE_ARG_TYPE_INTEGER: return ARG_TYPE_INTEGER;
    case REDISMODULE_ARG_TYPE_DOUBLE: return ARG_TYPE_DOUBLE;
    case REDISMODULE_ARG_TYPE_KEY: return ARG_TYPE_KEY;
    case REDISMODULE_ARG_TYPE_PATTERN: return ARG_TYPE_PATTERN;
    case REDISMODULE_ARG_TYPE_UNIX_TIME: return ARG_TYPE_UNIX_TIME;
    case REDISMODULE_ARG_TYPE_PURE_TOKEN: return ARG_TYPE_PURE_TOKEN;
    case REDISMODULE_ARG_TYPE_ONEOF: return ARG_TYPE_ONEOF;
    case REDISMODULE_ARG_TYPE_BLOCK: return ARG_TYPE_BLOCK;
    default:
        if (error) *error = 1;
        return -1;
    }
}",2172.0,2188.0,1.0,1.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,redisCommandArgType
4131,165398,moduleConvertArgFlags,1,moduleConvertArgFlags,int moduleConvertArgFlags (int),module.c,"static int moduleConvertArgFlags(int flags) {
    int realflags = 0;
    if (flags & REDISMODULE_CMD_ARG_OPTIONAL) realflags |= CMD_ARG_OPTIONAL;
    if (flags & REDISMODULE_CMD_ARG_MULTIPLE) realflags |= CMD_ARG_MULTIPLE;
    if (flags & REDISMODULE_CMD_ARG_MULTIPLE_TOKEN) realflags |= CMD_ARG_MULTIPLE_TOKEN;
    return realflags;
}",2190.0,2196.0,1.0,16.0,7.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4132,165403,moduleCreateContext,1,moduleCreateContext,"void moduleCreateContext (RedisModuleCtx*,RedisModule*,int)",module.c,"void moduleCreateContext(RedisModuleCtx *out_ctx, RedisModule *module, int ctx_flags) {
    memset(out_ctx, 0 ,sizeof(RedisModuleCtx));
    out_ctx->getapifuncptr = (void*)(unsigned long)&RM_GetApi;
    out_ctx->module = module;
    out_ctx->flags = ctx_flags;
    if (ctx_flags & REDISMODULE_CTX_TEMP_CLIENT)
        out_ctx->client = moduleAllocTempClient();
    else if (ctx_flags & REDISMODULE_CTX_NEW_CLIENT)
        out_ctx->client = createClient(NULL);

    /* Calculate the initial yield time for long blocked contexts.
     * in loading we depend on the server hz, but in other cases we also wait
     * for busy_reply_threshold.
     * Note that in theory we could have started processing BUSY_MODULE_YIELD_EVENTS
     * sooner, and only delay the processing for clients till the busy_reply_threshold,
     * but this carries some overheads of frequently marking clients with BLOCKED_POSTPONE
     * and releasing them, i.e. if modules only block for short periods. */
    if (server.loa...",875.0,907.0,1.0,20.0,33.0,0,0,0,0,21,0,1,1,0,0,,0,0,6,3,3,void
4133,165410,RM_Alloc,1,RM_Alloc,void* RM_Alloc (size_t),module.c,"void *RM_Alloc(size_t bytes) {
    /* Use 'zmalloc_usable()' instead of 'zmalloc()' to allow the compiler
     * to recognize the additional memory size, which means that modules can
     * use the memory reported by 'RM_MallocUsableSize()' safely. In theory this
     * isn't really needed since this API can't be inlined (not even for embedded
     * modules like TLS (we use function pointers for module APIs), and the API doesn't
     * have the malloc_size attribute, but it's hard to predict how smart future compilers
     * will be, so better safe than sorry. */
    return zmalloc_usable(bytes,NULL);
}",520.0,529.0,1.0,1.0,10.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void*
4134,165419,RM_TryAlloc,1,RM_TryAlloc,void* RM_TryAlloc (size_t),module.c,"void *RM_TryAlloc(size_t bytes) {
    return ztrymalloc_usable(bytes,NULL);
}",533.0,535.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void*
4135,165428,RM_Calloc,1,RM_Calloc,"void* RM_Calloc (size_t,size_t)",module.c,"void *RM_Calloc(size_t nmemb, size_t size) {
    return zcalloc_usable(nmemb*size,NULL);
}",541.0,543.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void*
4136,165440,RM_Realloc,1,RM_Realloc,"void* RM_Realloc (void*,size_t)",module.c,"void* RM_Realloc(void *ptr, size_t bytes) {
    return zrealloc_usable(ptr,bytes,NULL);
}",546.0,548.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,4,2,2,void*
4137,165451,RM_Free,1,RM_Free,void RM_Free (void*),module.c,"void RM_Free(void *ptr) {
    zfree(ptr);
}",553.0,555.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
4138,165458,RM_Strdup,1,RM_Strdup,char* RM_Strdup (char*),module.c,"char *RM_Strdup(const char *str) {
    return zstrdup(str);
}",558.0,560.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,char*
4139,165466,poolAllocRelease,1,poolAllocRelease,void poolAllocRelease (RedisModuleCtx*),module.c,"void poolAllocRelease(RedisModuleCtx *ctx) {
    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;

    while(head != NULL) {
        next = head->next;
        zfree(head);
        head = next;
    }
    ctx->pa_head = NULL;
}",567.0,576.0,1.0,1.0,10.0,8,3,11,4,1,4,2,2,0,1,,0,3,2,1,1,void
4140,165498,RM_PoolAlloc,1,RM_PoolAlloc,"void* RM_PoolAlloc (RedisModuleCtx*,size_t)",module.c,"void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
    if (bytes == 0) return NULL;
    RedisModulePoolAllocBlock *b = ctx->pa_head;
    size_t left = b ? b->size - b->used : 0;

    /* Fix alignment. */
    if (left >= bytes) {
        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;
        while (bytes < alignment && alignment/2 >= bytes) alignment /= 2;
        if (b->used % alignment)
            b->used += alignment - (b->used % alignment);
        left = (b->used > b->size) ? 0 : b->size - b->used;
    }

    /* Create a new block if needed. */
    if (left < bytes) {
        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;
        if (blocksize < bytes) blocksize = bytes;
        b = zmalloc(sizeof(*b) + blocksize);
        b->size = blocksize;
        b->used = 0;
        b->next = ctx->pa_head;
        ctx->pa_head = b;
    }

    char *retval = b->memory + b->used;
    b->used += bytes;
    return retval;
}",590.0,618.0,1.0,27.0,29.0,54,16,50,9,0,19,7,10,1,1,,0,19,4,2,2,void*
4141,165659,moduleAllocTempClient,1,moduleAllocTempClient,client moduleAllocTempClient (void),module.c,"client *moduleAllocTempClient(void) {
    client *c = NULL;

    if (moduleTempClientCount > 0) {
        c = moduleTempClients[--moduleTempClientCount];
        if (moduleTempClientCount < moduleTempClientMinCount)
            moduleTempClientMinCount = moduleTempClientCount;
    } else {
        c = createClient(NULL);
        c->flags |= CLIENT_MODULE;
        c->user = NULL; /* Root user */
    }
    return c;
}",624.0,637.0,1.0,20.0,14.0,7,5,11,5,3,7,3,4,3,0,,0,7,2,1,1,client
4142,165709,freeRedisModuleAsyncRMCallPromise,1,freeRedisModuleAsyncRMCallPromise,void freeRedisModuleAsyncRMCallPromise (RedisModuleAsyncRMCallPromise*),module.c,"static void freeRedisModuleAsyncRMCallPromise(RedisModuleAsyncRMCallPromise *promise) {
    if (--promise->ref_count > 0) {
        return;
    }
    /* When the promise is finally freed it can not have a client attached to it.
     * Either releasing the client or RM_CallReplyPromiseAbort would have removed it. */
    serverAssert(!promise->c);
    zfree(promise);
}",639.0,647.0,1.0,4.0,9.0,11,8,4,1,1,5,2,2,1,2,,0,3,2,1,1,void
4143,165746,moduleReleaseTempClient,1,moduleReleaseTempClient,void moduleReleaseTempClient (client*),module.c,"void moduleReleaseTempClient(client *c) {
    if (moduleTempClientCount == moduleTempClientCap) {
        moduleTempClientCap = moduleTempClientCap ? moduleTempClientCap*2 : 32;
        moduleTempClients = zrealloc(moduleTempClients, sizeof(c)*moduleTempClientCap);
    }
    clearClientConnectionState(c);
    listEmpty(c->reply);
    c->reply_bytes = 0;
    c->duration = 0;
    resetClient(c);
    c->bufpos = 0;
    c->flags = CLIENT_MODULE;
    c->user = NULL; /* Root user */
    c->cmd = c->lastcmd = c->realcmd = NULL;
    if (c->bstate.async_rm_call_handle) {
        RedisModuleAsyncRMCallPromise *promise = c->bstate.async_rm_call_handle;
        promise->c = NULL; /* Remove the client from the promise so it will no longer be possible to abort it. */
        freeRedisModuleAsyncRMCallPromise(promise);
        c->bstate.async_rm_call_handle = NULL;
    }
    moduleTempClients[moduleTempClientCount++] = c;
}",649.0,670.0,1.0,15.0,22.0,38,10,33,6,7,28,3,3,3,5,,0,24,2,1,1,void
4144,165857,moduleCreateEmptyKey,1,moduleCreateEmptyKey,"int moduleCreateEmptyKey (RedisModuleKey*,int)",module.c,"int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
    robj *obj;

    /* The key must be open for writing and non existing to proceed. */
    if (!(key->mode & REDISMODULE_WRITE) || key->value)
        return REDISMODULE_ERR;

    switch(type) {
    case REDISMODULE_KEYTYPE_LIST:
        obj = createListListpackObject();
        break;
    case REDISMODULE_KEYTYPE_ZSET:
        obj = createZsetListpackObject();
        break;
    case REDISMODULE_KEYTYPE_HASH:
        obj = createHashObject();
        break;
    case REDISMODULE_KEYTYPE_STREAM:
        obj = createStreamObject();
        break;
    default: return REDISMODULE_ERR;
    }
    dbAdd(key->db,key->key,obj);
    key->value = obj;
    moduleInitKeyTypeSpecific(key);
    return REDISMODULE_OK;
}",684.0,710.0,1.0,22.0,27.0,14,6,13,3,5,11,7,3,2,6,,0,9,4,2,2,int
4145,165943,moduleFreeKeyIterator,1,moduleFreeKeyIterator,void moduleFreeKeyIterator (RedisModuleKey*),module.c,"static void moduleFreeKeyIterator(RedisModuleKey *key) {
    serverAssert(key->iter != NULL);
    switch (key->value->type) {
    case OBJ_LIST: listTypeReleaseIterator(key->iter); break;
    case OBJ_STREAM:
        streamIteratorStop(key->iter);
        zfree(key->iter);
        break;
    default: serverAssert(0); /* No key->iter for other types. */
    }
    key->iter = NULL;
}",713.0,724.0,1.0,4.0,12.0,17,7,8,2,7,11,4,2,1,5,,0,6,2,1,1,void
4146,166016,moduleFreeListIterator,1,moduleFreeListIterator,void moduleFreeListIterator (void*),module.c,"static void moduleFreeListIterator(void *data) {
    RedisModuleKey *key = (RedisModuleKey*)data;
    serverAssert(key->value->type == OBJ_LIST);
    if (key->iter) moduleFreeKeyIterator(key);
}",728.0,732.0,1.0,4.0,5.0,10,7,5,2,0,4,2,2,1,2,,0,2,2,1,1,void
4147,166054,moduleDelKeyIfEmpty,1,moduleDelKeyIfEmpty,int moduleDelKeyIfEmpty (RedisModuleKey*),module.c,"int moduleDelKeyIfEmpty(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) return 0;
    int isempty;
    robj *o = key->value;

    switch(o->type) {
    case OBJ_LIST: isempty = listTypeLength(o) == 0; break;
    case OBJ_SET: isempty = setTypeSize(o) == 0; break;
    case OBJ_ZSET: isempty = zsetLength(o) == 0; break;
    case OBJ_HASH: isempty = hashTypeLength(o) == 0; break;
    case OBJ_STREAM: isempty = streamLength(o) == 0; break;
    default: isempty = 0;
    }

    if (isempty) {
        if (key->iter) moduleFreeKeyIterator(key);
        dbDelete(key->db,key->key);
        key->value = NULL;
        return 1;
    } else {
        return 0;
    }
}",744.0,766.0,1.0,22.0,23.0,26,7,24,4,7,14,10,6,3,7,,0,12,2,1,1,int
4148,166178,RM_GetApi,1,RM_GetApi,"int RM_GetApi (char*,void**)",module.c,"int RM_GetApi(const char *funcname, void **targetPtrPtr) {
    /* Lookup the requested module API and store the function pointer into the
     * target pointer. The function returns REDISMODULE_ERR if there is no such
     * named API, otherwise REDISMODULE_OK.
     *
     * This function is not meant to be used by modules developer, it is only
     * used implicitly by including redismodule.h. */
    dictEntry *he = dictFind(server.moduleapi, funcname);
    if (!he) return REDISMODULE_ERR;
    *targetPtrPtr = dictGetVal(he);
    return REDISMODULE_OK;
}",778.0,789.0,1.0,20.0,12.0,5,4,6,4,0,2,2,2,0,2,,0,2,4,2,2,int
4149,166209,modulePostExecutionUnitOperations,1,modulePostExecutionUnitOperations,void modulePostExecutionUnitOperations (void),module.c,"void modulePostExecutionUnitOperations(void) {
    if (server.execution_nesting)
        return;

    if (server.busy_module_yield_flags) {
        blockingOperationEnds();
        server.busy_module_yield_flags = BUSY_MODULE_YIELD_NONE;
        if (server.current_client)
            unprotectClient(server.current_client);
        unblockPostponedClients();
    }
}",791.0,802.0,1.0,41.0,12.0,6,2,5,1,1,3,4,5,0,3,,0,0,2,1,1,void
4150,166243,moduleFreeContext,1,moduleFreeContext,void moduleFreeContext (RedisModuleCtx*),module.c,"void moduleFreeContext(RedisModuleCtx *ctx) {
    /* See comment in moduleCreateContext */
    if (!(ctx->flags & (REDISMODULE_CTX_THREAD_SAFE|REDISMODULE_CTX_COMMAND))) {
        exitExecutionUnit();
        postExecutionUnitOperations();
    }
    autoMemoryCollect(ctx);
    poolAllocRelease(ctx);
    if (ctx->postponed_arrays) {
        zfree(ctx->postponed_arrays);
        ctx->postponed_arrays_count = 0;
        serverLog(LL_WARNING,
            ""API misuse detected in module %s: ""
            ""RedisModule_ReplyWith*(REDISMODULE_POSTPONED_LEN) ""
            ""not matched by the same number of RedisModule_SetReply*Len() ""
            ""calls."",
            ctx->module->name);
    }
    /* If this context has a temp client, we return it back to the pool.
     * If this context created a new client (e.g detached context), we free it.
     * If the client is assigned manually, e.g ctx->client = someClientInstance,
     * none of these flags will be set and we do not attempt to free i...",805.0,831.0,1.0,24.0,27.0,19,8,10,2,26,14,4,4,3,7,,0,7,2,1,1,void
4151,166341,moduleParseReply,1,moduleParseReply,"CallReply moduleParseReply (client*,RedisModuleCtx*)",module.c,"static CallReply *moduleParseReply(client *c, RedisModuleCtx *ctx) {
    /* Convert the result of the Redis command into a module reply. */
    sds proto = sdsnewlen(c->buf,c->bufpos);
    c->bufpos = 0;
    while(listLength(c->reply)) {
        clientReplyBlock *o = listNodeValue(listFirst(c->reply));

        proto = sdscatlen(proto,o->buf,o->used);
        listDelNode(c->reply,listFirst(c->reply));
    }
    CallReply *reply = callReplyCreate(proto, c->deferred_reply_errors, ctx);
    c->deferred_reply_errors = NULL; /* now the responsibility of the reply object. */
    return reply;
}",833.0,846.0,1.0,10.0,14.0,23,2,22,6,1,17,2,2,2,4,,0,16,4,2,2,CallReply
4152,166426,moduleCallCommandUnblockedHandler,1,moduleCallCommandUnblockedHandler,void moduleCallCommandUnblockedHandler (client*),module.c,"void moduleCallCommandUnblockedHandler(client *c) {
    RedisModuleCtx ctx;
    RedisModuleAsyncRMCallPromise *promise = c->bstate.async_rm_call_handle;
    serverAssert(promise);
    RedisModule *module = promise->module;
    if (!promise->on_unblocked) {
        moduleReleaseTempClient(c);
        return; /* module did not set any unblock callback. */
    }
    moduleCreateContext(&ctx, module, REDISMODULE_CTX_TEMP_CLIENT);
    selectDb(ctx.client, c->db->id);

    CallReply *reply = moduleParseReply(c, NULL);
    module->in_call++;
    promise->on_unblocked(&ctx, reply, promise->private_data);
    module->in_call--;

    moduleFreeContext(&ctx);
    moduleReleaseTempClient(c);
}",848.0,867.0,1.0,4.0,20.0,25,12,23,6,1,16,2,2,1,7,,0,10,2,1,1,void
4153,166628,RedisModuleCommandDispatcher,1,RedisModuleCommandDispatcher,void RedisModuleCommandDispatcher (client*),module.c,"void RedisModuleCommandDispatcher(client *c) {
    RedisModuleCommand *cp = c->cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_COMMAND);

    ctx.client = c;
    cp->func(&ctx,(void**)c->argv,c->argc);
    moduleFreeContext(&ctx);

    /* In some cases processMultibulkBuffer uses sdsMakeRoomFor to
     * expand the query buffer, and in order to avoid a big object copy
     * the query buffer SDS may be used directly as the SDS string backing
     * the client argument vectors: sometimes this will result in the SDS
     * string having unused space at the end. Later if a module takes ownership
     * of the RedisString, such space will be wasted forever. Inside the
     * Redis core this is not a problem because tryObjectEncoding() is called
     * before storing strings in the key space. Here we need to do it
     * for the module. */
    for (int i = 0; i < c->argc; i++) {
        /* Only do the work if the module took ownership of...",911.0,935.0,1.0,42.0,25.0,23,9,18,4,0,12,3,4,2,3,,0,9,2,1,1,void
4154,166707,moduleGetCommandKeysViaAPI,1,moduleGetCommandKeysViaAPI,"int moduleGetCommandKeysViaAPI (redisCommand*,robj**,int,getKeysResult*)",module.c,"int moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    RedisModuleCommand *cp = cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_KEYS_POS_REQUEST);

    /* Initialize getKeysResult */
    getKeysPrepareResult(result, MAX_KEYS_BUFFER);
    ctx.keys_result = result;

    cp->func(&ctx,(void**)argv,argc);
    /* We currently always use the array allocated by RM_KeyAtPos() and don't try
     * to optimize for the pre-allocated buffer.
     */
    moduleFreeContext(&ctx);
    return result->numkeys;
}",946.0,961.0,1.0,42.0,16.0,12,6,13,6,2,8,1,1,0,3,,0,5,8,4,4,int
4155,166760,moduleGetCommandChannelsViaAPI,1,moduleGetCommandChannelsViaAPI,"int moduleGetCommandChannelsViaAPI (redisCommand*,robj**,int,getKeysResult*)",module.c,"int moduleGetCommandChannelsViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    RedisModuleCommand *cp = cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_CHANNELS_POS_REQUEST);

    /* Initialize getKeysResult */
    getKeysPrepareResult(result, MAX_KEYS_BUFFER);
    ctx.keys_result = result;

    cp->func(&ctx,(void**)argv,argc);
    /* We currently always use the array allocated by RM_RM_ChannelAtPosWithFlags() and don't try
     * to optimize for the pre-allocated buffer. */
    moduleFreeContext(&ctx);
    return result->numkeys;
}",966.0,980.0,1.0,42.0,15.0,12,6,13,6,1,8,1,1,0,3,,0,5,8,4,4,int
4156,166813,RM_IsKeysPositionRequest,1,RM_IsKeysPositionRequest,int RM_IsKeysPositionRequest (RedisModuleCtx*),module.c,"int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
}",993.0,995.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4157,166830,RM_KeyAtPosWithFlags,1,RM_KeyAtPosWithFlags,"void RM_KeyAtPosWithFlags (RedisModuleCtx*,int,int)",module.c,"void RM_KeyAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags) {
    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) || !ctx->keys_result) return;
    if (pos <= 0) return;

    getKeysResult *res = ctx->keys_result;

    /* Check overflow */
    if (res->numkeys == res->size) {
        int newsize = res->size + (res->size > 8192 ? 8192 : res->size);
        getKeysPrepareResult(res, newsize);
    }

    res->keys[res->numkeys].pos = pos;
    res->keys[res->numkeys].flags = moduleConvertKeySpecsFlags(flags, 1);
    res->numkeys++;
}",1017.0,1032.0,1.0,23.0,16.0,32,14,20,5,1,15,4,4,4,2,,0,14,6,3,3,void
4158,166924,RM_KeyAtPos,1,RM_KeyAtPos,"void RM_KeyAtPos (RedisModuleCtx*,int)",module.c,"void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
    /* Default flags require full access */
    int flags = moduleConvertKeySpecsFlags(CMD_KEY_FULL_ACCESS, 0);
    RM_KeyAtPosWithFlags(ctx, pos, flags);
}",1037.0,1041.0,1.0,43.0,5.0,6,3,4,3,0,2,1,1,0,2,,0,1,4,2,2,void
4159,166952,RM_IsChannelsPositionRequest,1,RM_IsChannelsPositionRequest,int RM_IsChannelsPositionRequest (RedisModuleCtx*),module.c,"int RM_IsChannelsPositionRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_CHANNELS_POS_REQUEST) != 0;
}",1046.0,1048.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4160,166969,RM_ChannelAtPosWithFlags,1,RM_ChannelAtPosWithFlags,"void RM_ChannelAtPosWithFlags (RedisModuleCtx*,int,int)",module.c,"void RM_ChannelAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags) {
    if (!(ctx->flags & REDISMODULE_CTX_CHANNELS_POS_REQUEST) || !ctx->keys_result) return;
    if (pos <= 0) return;

    getKeysResult *res = ctx->keys_result;

    /* Check overflow */
    if (res->numkeys == res->size) {
        int newsize = res->size + (res->size > 8192 ? 8192 : res->size);
        getKeysPrepareResult(res, newsize);
    }

    int new_flags = 0;
    if (flags & REDISMODULE_CMD_CHANNEL_SUBSCRIBE) new_flags |= CMD_CHANNEL_SUBSCRIBE;
    if (flags & REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE) new_flags |= CMD_CHANNEL_UNSUBSCRIBE;
    if (flags & REDISMODULE_CMD_CHANNEL_PUBLISH) new_flags |= CMD_CHANNEL_PUBLISH;
    if (flags & REDISMODULE_CMD_CHANNEL_PATTERN) new_flags |= CMD_CHANNEL_PATTERN;

    res->keys[res->numkeys].pos = pos;
    res->keys[res->numkeys].flags = new_flags;
    res->numkeys++;
}",1076.0,1097.0,1.0,23.0,22.0,45,14,29,6,0,14,8,8,4,1,,0,13,6,3,3,void
4161,167129,isCommandNameValid,1,isCommandNameValid,int isCommandNameValid (char*),module.c,"int isCommandNameValid(const char *name) {
    const char *block_chars = "" \r\n|@=,"";

    if (strpbrk(name, block_chars))
        return 0;
    return 1;
}",1111.0,1117.0,1.0,1.0,7.0,1,1,3,2,2,0,2,2,0,0,,0,0,2,1,1,int
4162,167147,commandFlagsFromString,1,commandFlagsFromString,int64_t commandFlagsFromString (char*),module.c,"int64_t commandFlagsFromString(char *s) {
    int count, j;
    int64_t flags = 0;
    sds *tokens = sdssplitlen(s,strlen(s),"" "",1,&count);
    for (j = 0; j < count; j++) {
        char *t = tokens[j];
        if (!strcasecmp(t,""write"")) flags |= CMD_WRITE;
        else if (!strcasecmp(t,""readonly"")) flags |= CMD_READONLY;
        else if (!strcasecmp(t,""admin"")) flags |= CMD_ADMIN;
        else if (!strcasecmp(t,""deny-oom"")) flags |= CMD_DENYOOM;
        else if (!strcasecmp(t,""deny-script"")) flags |= CMD_NOSCRIPT;
        else if (!strcasecmp(t,""allow-loading"")) flags |= CMD_LOADING;
        else if (!strcasecmp(t,""pubsub"")) flags |= CMD_PUBSUB;
        else if (!strcasecmp(t,""random"")) { /* Deprecated. Silently ignore. */ }
        else if (!strcasecmp(t,""blocking"")) flags |= CMD_BLOCKING;
        else if (!strcasecmp(t,""allow-stale"")) flags |= CMD_STALE;
        else if (!strcasecmp(t,""no-monitor"")) flags |= CMD_SKIP_MONITOR;
        else if (!strcasecmp(t,""no-slowlog"")) flags ...",1123.0,1154.0,1.0,45.0,32.0,11,8,18,6,2,2,4,5,0,2,,0,1,2,1,1,int64_t
4163,167493,moduleCreateCommandProxy,1,moduleCreateCommandProxy,"RedisModuleCommand* moduleCreateCommandProxy (RedisModule*,sds,sds,RedisModuleCmdFunc,int64_t,int,int,int)",module.c,"RedisModuleCommand *moduleCreateCommandProxy(struct RedisModule *module, sds declared_name, sds fullname, RedisModuleCmdFunc cmdfunc, int64_t flags, int firstkey, int lastkey, int keystep) {
    struct redisCommand *rediscmd;
    RedisModuleCommand *cp;

    /* Create a command ""proxy"", which is a structure that is referenced
     * in the command table, so that the generic command that works as
     * binding between modules and Redis, can know what function to call
     * and what the module is. */
    cp = zcalloc(sizeof(*cp));
    cp->module = module;
    cp->func = cmdfunc;
    cp->rediscmd = zcalloc(sizeof(*rediscmd));
    cp->rediscmd->declared_name = declared_name; /* SDS for module commands */
    cp->rediscmd->fullname = fullname;
    cp->rediscmd->group = COMMAND_GROUP_MODULE;
    cp->rediscmd->proc = RedisModuleCommandDispatcher;
    cp->rediscmd->flags = flags | CMD_MODULE;
    cp->rediscmd->module_cmd = cp;
    if (firstkey != 0) {
        cp->rediscmd->key_specs_num =...",1287.0,1327.0,1.0,34.0,41.0,0,0,0,0,2,0,1,1,0,0,,0,0,16,8,8,RedisModuleCommand
4164,167505,RM_CreateCommand,1,RM_CreateCommand,"int RM_CreateCommand (RedisModuleCtx*,char*,RedisModuleCmdFunc,char*,int,int,int)",module.c,"int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
    if (!ctx->module->onload)
        return REDISMODULE_ERR;
    int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
    if (flags == -1) return REDISMODULE_ERR;
    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
        return REDISMODULE_ERR;

    /* Check if the command name is valid. */
    if (!isCommandNameValid(name))
        return REDISMODULE_ERR;

    /* Check if the command name is busy. */
    if (lookupCommandByCString(name) != NULL)
        return REDISMODULE_ERR;

    sds declared_name = sdsnew(name);
    RedisModuleCommand *cp = moduleCreateCommandProxy(ctx->module, declared_name, sdsdup(declared_name), cmdfunc, flags, firstkey, lastkey, keystep);
    cp->rediscmd->arity = cmdfunc ? -1 : -2; /* Default value, can be changed later via dedicated API */

    serverAssert(dictAdd(serve...",1254.0,1278.0,1.0,15.0,25.0,40,14,31,12,0,19,6,6,3,13,,0,15,14,7,7,int
4165,167969,RM_GetCommand,1,RM_GetCommand,"RedisModuleCommand RM_GetCommand (RedisModuleCtx*,char*)",module.c,"RedisModuleCommand *RM_GetCommand(RedisModuleCtx *ctx, const char *name) {
    struct redisCommand *cmd = lookupCommandByCString(name);

    if (!cmd || !(cmd->flags & CMD_MODULE))
        return NULL;

    RedisModuleCommand *cp = cmd->module_cmd;
    if (cp->module != ctx->module)
        return NULL;

    return cp;
}",1338.0,1349.0,1.0,31.0,12.0,12,7,11,5,0,5,3,3,3,1,,0,5,4,2,2,RedisModuleCommand
4166,168016,RM_CreateSubcommand,1,RM_CreateSubcommand,"int RM_CreateSubcommand (RedisModuleCommand*,char*,RedisModuleCmdFunc,char*,int,int,int)",module.c,"int RM_CreateSubcommand(RedisModuleCommand *parent, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
    if (!parent->module->onload)
        return REDISMODULE_ERR;
    int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
    if (flags == -1) return REDISMODULE_ERR;
    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
        return REDISMODULE_ERR;

    struct redisCommand *parent_cmd = parent->rediscmd;

    if (parent_cmd->parent)
        return REDISMODULE_ERR; /* We don't allow more than one level of subcommands */

    RedisModuleCommand *parent_cp = parent_cmd->module_cmd;
    if (parent_cp->func)
        return REDISMODULE_ERR; /* A parent command should be a pure container of subcommands */

    /* Check if the command name is valid. */
    if (!isCommandNameValid(name))
        return REDISMODULE_ERR;

    /* Check if the command name is busy within the parent command. */
    sds...",1378.0,1412.0,1.0,15.0,35.0,32,12,37,15,0,18,8,8,6,8,,0,16,14,7,7,int
4167,168177,moduleCmdHistoryEntryAt,1,moduleCmdHistoryEntryAt,"RedisModuleCommandHistoryEntry moduleCmdHistoryEntryAt (RedisModuleCommandInfoVersion*,RedisModuleCommandHistoryEntry*,int)",module.c,"static RedisModuleCommandHistoryEntry *
moduleCmdHistoryEntryAt(const RedisModuleCommandInfoVersion *version,
                        RedisModuleCommandHistoryEntry *entries, int index) {
    off_t offset = index * version->sizeof_historyentry;
    return (RedisModuleCommandHistoryEntry *)((char *)(entries) + offset);
}",1416.0,1421.0,1.0,1.0,6.0,6,5,5,4,2,1,1,1,0,0,,0,1,6,3,3,RedisModuleCommandHistoryEntry
4168,168200,moduleCmdKeySpecAt,1,moduleCmdKeySpecAt,"RedisModuleCommandKeySpec moduleCmdKeySpecAt (RedisModuleCommandInfoVersion*,RedisModuleCommandKeySpec*,int)",module.c,"static RedisModuleCommandKeySpec *
moduleCmdKeySpecAt(const RedisModuleCommandInfoVersion *version,
                   RedisModuleCommandKeySpec *keyspecs, int index) {
    off_t offset = index * version->sizeof_keyspec;
    return (RedisModuleCommandKeySpec *)((char *)(keyspecs) + offset);
}",1422.0,1427.0,1.0,1.0,6.0,6,5,5,4,2,1,1,1,0,0,,0,1,6,3,3,RedisModuleCommandKeySpec
4169,168223,moduleCmdArgAt,1,moduleCmdArgAt,"RedisModuleCommandArg moduleCmdArgAt (RedisModuleCommandInfoVersion*,RedisModuleCommandArg*,int)",module.c,"static RedisModuleCommandArg *
moduleCmdArgAt(const RedisModuleCommandInfoVersion *version,
               const RedisModuleCommandArg *args, int index) {
    off_t offset = index * version->sizeof_arg;
    return (RedisModuleCommandArg *)((char *)(args) + offset);
}",1428.0,1433.0,1.0,1.0,6.0,6,5,5,4,2,1,1,1,0,0,,0,1,6,3,3,RedisModuleCommandArg
4170,168246,populateArgsStructure,1,populateArgsStructure,int populateArgsStructure (redisCommandArg*),module.c,"int populateArgsStructure(struct redisCommandArg *args) {
    if (!args)
        return 0;
    int count = 0;
    while (args->name) {
        serverAssert(count < INT_MAX);
        args->num_args = populateArgsStructure(args->subargs);
        count++;
        args++;
    }
    return count;
}",1437.0,1448.0,1.0,8.0,12.0,13,9,10,3,1,4,3,3,1,1,,0,3,2,1,1,int
4171,168296,matchAclCategoryFlag,1,matchAclCategoryFlag,"int matchAclCategoryFlag (char*,int64_t*)",module.c,"int matchAclCategoryFlag(char *flag, int64_t *acl_categories_flags) {
    uint64_t this_flag = ACLGetCommandCategoryFlagByName(flag);
    if (this_flag) {
        *acl_categories_flags |= (int64_t) this_flag;
        return 1;
    }
    return 0; /* Unrecognized */
}",1455.0,1462.0,1.0,1.0,8.0,3,3,5,3,1,1,2,2,0,1,,0,1,4,2,2,int
4172,168320,categoryFlagsFromString,1,categoryFlagsFromString,int64_t categoryFlagsFromString (char*),module.c,"int64_t categoryFlagsFromString(char *aclflags) {
    int count, j;
    int64_t acl_categories_flags = 0;
    sds *tokens = sdssplitlen(aclflags,strlen(aclflags),"" "",1,&count);
    for (j = 0; j < count; j++) {
        char *t = tokens[j];
        if (!matchAclCategoryFlag(t, &acl_categories_flags)) {
            serverLog(LL_WARNING,""Unrecognized categories flag %s on module load"", t);
            break;
        }
    }
    sdsfreesplitres(tokens,count);
    if (j != count) return -1; /* Some token not processed correctly. */
    return acl_categories_flags;
}",1469.0,1483.0,1.0,12.0,15.0,14,9,20,7,1,4,5,5,1,4,,0,2,2,1,1,int64_t
4173,168399,RM_SetCommandACLCategories,1,RM_SetCommandACLCategories,"int RM_SetCommandACLCategories (RedisModuleCommand*,char*)",module.c,"int RM_SetCommandACLCategories(RedisModuleCommand *command, const char *aclflags) {
    if (!command || !command->module || !command->module->onload) return REDISMODULE_ERR;
    int64_t categories_flags = aclflags ? categoryFlagsFromString((char*)aclflags) : 0;
    if (categories_flags == -1) return REDISMODULE_ERR;
    struct redisCommand *rcmd = command->rediscmd;
    rcmd->acl_categories = categories_flags; /* ACL categories flags for module command */
    command->module->num_commands_with_acl_categories++;
    return REDISMODULE_OK;
}",1497.0,1505.0,1.0,73.0,9.0,20,9,12,4,0,6,3,3,2,1,,0,6,4,2,2,int
4174,168466,RM_SetCommandInfo,1,RM_SetCommandInfo,"int RM_SetCommandInfo (RedisModuleCommand*,RedisModuleCommandInfo*)",module.c,"int RM_SetCommandInfo(RedisModuleCommand *command, const RedisModuleCommandInfo *info) {
    if (!moduleValidateCommandInfo(info)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    struct redisCommand *cmd = command->rediscmd;

    /* Check if any info has already been set. Overwriting info involves freeing
     * the old info, which is not implemented. */
    if (cmd->summary || cmd->complexity || cmd->since || cmd->history ||
        cmd->tips || cmd->args ||
        !(cmd->key_specs_num == 0 ||
          /* Allow key spec populated from legacy (first,last,step) to exist. */
          (cmd->key_specs_num == 1 &&
           cmd->key_specs[0].begin_search_type == KSPEC_BS_INDEX &&
           cmd->key_specs[0].find_keys_type == KSPEC_FK_RANGE))) {
        errno = EEXIST;
        return REDISMODULE_ERR;
    }

    if (info->summary) cmd->summary = zstrdup(info->summary);
    if (info->complexity) cmd->complexity = zstrdup(info->complexity);
    if (info->since) cmd-...",1808.0,1945.0,1.0,15.0,138.0,282,18,186,31,0,112,26,30,25,27,,0,105,4,2,2,int
4175,169258,isPowerOfTwo,1,isPowerOfTwo,int isPowerOfTwo (uint64_t),module.c,"static inline int isPowerOfTwo(uint64_t v) {
    return v && !(v & (v - 1));
}",1948.0,1950.0,1.0,1.0,3.0,4,4,3,1,0,0,1,1,0,0,,0,0,2,1,1,int
4176,170144,moduleCopyCommandArgs,1,moduleCopyCommandArgs,"struct redisCommandArg moduleCopyCommandArgs (RedisModuleCommandArg*,RedisModuleCommandInfoVersion*)",module.c,"static struct redisCommandArg *moduleCopyCommandArgs(RedisModuleCommandArg *args,
                                                     const RedisModuleCommandInfoVersion *version) {
    size_t count = 0;
    while (moduleCmdArgAt(version, args, count)->name) count++;
    serverAssert(count < SIZE_MAX / sizeof(struct redisCommandArg));
    struct redisCommandArg *realargs = zcalloc((count+1) * sizeof(redisCommandArg));

    for (size_t j = 0; j < count; j++) {
        RedisModuleCommandArg *arg = moduleCmdArgAt(version, args, j);
        realargs[j].name = zstrdup(arg->name);
        realargs[j].type = moduleConvertArgType(arg->type, NULL);
        if (arg->type == REDISMODULE_ARG_TYPE_KEY)
            realargs[j].key_spec_index = arg->key_spec_index;
        else
            realargs[j].key_spec_index = -1;
        if (arg->token) realargs[j].token = zstrdup(arg->token);
        if (arg->summary) realargs[j].summary = zstrdup(arg->summary);
        if (arg->since) realargs[j].since...",2146.0,2170.0,1.0,4.0,25.0,64,14,58,10,1,29,10,17,8,12,,0,28,4,2,2,struct redisCommandArg
4177,170483,moduleGetHandleByName,1,moduleGetHandleByName,void* moduleGetHandleByName (char*),module.c,"void *moduleGetHandleByName(char *modulename) {
    return dictFetchValue(modules,modulename);
}",2199.0,2201.0,1.0,1.0,3.0,0,0,2,2,1,2,1,1,0,1,,0,1,2,1,1,void*
4178,170492,moduleIsModuleCommand,1,moduleIsModuleCommand,"int moduleIsModuleCommand (void*,redisCommand*)",module.c,"int moduleIsModuleCommand(void *module_handle, struct redisCommand *cmd) {
    if (cmd->proc != RedisModuleCommandDispatcher)
        return 0;
    if (module_handle == NULL)
        return 0;
    RedisModuleCommand *cp = cmd->module_cmd;
    return (cp->module == module_handle);
}",2204.0,2211.0,1.0,1.0,8.0,7,4,7,4,1,3,3,3,1,0,,0,3,4,2,2,int
4179,170526,moduleListConfigMatch,1,moduleListConfigMatch,"int moduleListConfigMatch (void*,void*)",module.c,"int moduleListConfigMatch(void *config, void *name) {
    return strcasecmp(((ModuleConfig *) config)->name, (char *) name) == 0;
}",2217.0,2219.0,1.0,1.0,3.0,4,3,2,2,0,0,1,1,0,0,,0,0,4,2,2,int
4180,170544,moduleListFree,1,moduleListFree,void moduleListFree (void*),module.c,"void moduleListFree(void *config) {
    ModuleConfig *module_config = (ModuleConfig *) config;
    sdsfree(module_config->name);
    zfree(config);
}",2221.0,2225.0,1.0,1.0,5.0,3,3,4,2,0,3,1,1,0,2,,0,1,2,1,1,void
4181,170561,RM_SetModuleAttribs,1,RM_SetModuleAttribs,"void RM_SetModuleAttribs (RedisModuleCtx*,char*,int,int)",module.c,"void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
    /* Called by RM_Init() to setup the `ctx->module` structure.
     *
     * This is an internal function, Redis modules developers don't need
     * to use it. */
    RedisModule *module;

    if (ctx->module != NULL) return;
    module = zmalloc(sizeof(*module));
    module->name = sdsnew(name);
    module->ver = ver;
    module->apiver = apiver;
    module->types = listCreate();
    module->usedby = listCreate();
    module->using = listCreate();
    module->filters = listCreate();
    module->module_configs = listCreate();
    listSetMatchMethod(module->module_configs, moduleListConfigMatch);
    listSetFreeMethod(module->module_configs, moduleListFree);
    module->in_call = 0;
    module->configs_initialized = 0;
    module->in_hook = 0;
    module->options = 0;
    module->info_cb = 0;
    module->defrag_cb = 0;
    module->loadmod = NULL;
    module->num_commands_with_acl_categories = 0;...",2227.0,2256.0,1.0,4.0,30.0,49,5,31,6,0,30,2,2,1,7,,0,30,8,4,4,void
4182,170701,RM_IsModuleNameBusy,1,RM_IsModuleNameBusy,int RM_IsModuleNameBusy (char*),module.c,"int RM_IsModuleNameBusy(const char *name) {
    sds modulename = sdsnew(name);
    dictEntry *de = dictFind(modules,modulename);
    sdsfree(modulename);
    return de != NULL;
}",2260.0,2265.0,1.0,1.0,6.0,3,2,8,5,0,4,1,1,0,3,,0,3,2,1,1,int
4183,170723,RM_Milliseconds,1,RM_Milliseconds,mstime_t RM_Milliseconds (void),module.c,"mstime_t RM_Milliseconds(void) {
    return mstime();
}",2268.0,2270.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,mstime_t
4184,170730,RM_MonotonicMicroseconds,1,RM_MonotonicMicroseconds,uint64_t RM_MonotonicMicroseconds (void),module.c,"uint64_t RM_MonotonicMicroseconds(void) {
    return getMonotonicUs();
}",2273.0,2275.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
4185,170737,RM_Microseconds,1,RM_Microseconds,ustime_t RM_Microseconds (void),module.c,"ustime_t RM_Microseconds(void) {
    return ustime();
}",2278.0,2280.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,ustime_t
4186,170744,RM_CachedMicroseconds,1,RM_CachedMicroseconds,ustime_t RM_CachedMicroseconds (void),module.c,"ustime_t RM_CachedMicroseconds(void) {
    return server.ustime;
}",2288.0,2290.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,ustime_t
4187,170753,RM_BlockedClientMeasureTimeStart,1,RM_BlockedClientMeasureTimeStart,int RM_BlockedClientMeasureTimeStart (RedisModuleBlockedClient*),module.c,"int RM_BlockedClientMeasureTimeStart(RedisModuleBlockedClient *bc) {
    elapsedStart(&(bc->background_timer));
    return REDISMODULE_OK;
}",2298.0,2301.0,1.0,11.0,4.0,2,2,1,1,0,2,1,1,0,1,,0,1,2,1,1,int
4188,170767,RM_BlockedClientMeasureTimeEnd,1,RM_BlockedClientMeasureTimeEnd,int RM_BlockedClientMeasureTimeEnd (RedisModuleBlockedClient*),module.c,"int RM_BlockedClientMeasureTimeEnd(RedisModuleBlockedClient *bc) {
    // If the counter is 0 then we haven't called RM_BlockedClientMeasureTimeStart
    if (!bc->background_timer)
        return REDISMODULE_ERR;
    bc->background_duration += elapsedUs(bc->background_timer);
    return REDISMODULE_OK;
}",2308.0,2314.0,1.0,15.0,7.0,5,3,3,1,0,4,2,2,1,1,,0,3,2,1,1,int
4189,170794,RM_Yield,1,RM_Yield,"void RM_Yield (RedisModuleCtx*,int,char*)",module.c,"void RM_Yield(RedisModuleCtx *ctx, int flags, const char *busy_reply) {
    static int yield_nesting = 0;
    /* Avoid nested calls to RM_Yield */
    if (yield_nesting)
        return;
    yield_nesting++;

    long long now = getMonotonicUs();
    if (now >= ctx->next_yield_time) {
        /* In loading mode, there's no need to handle busy_module_yield_reply,
         * and busy_module_yield_flags, since redis is anyway rejecting all
         * commands with -LOADING. */
        if (server.loading) {
            /* Let redis process events */
            processEventsWhileBlocked();
        } else {
            const char *prev_busy_module_yield_reply = server.busy_module_yield_reply;
            server.busy_module_yield_reply = busy_reply;
            /* start the blocking operation if not already started. */
            if (!server.busy_module_yield_flags) {
                server.busy_module_yield_flags = BUSY_MODULE_YIELD_EVENTS;
                blockingOperationStarts();
    ...",2337.0,2379.0,1.0,49.0,43.0,12,8,11,4,0,4,4,5,1,2,,0,3,6,3,3,void
4190,170913,RM_SetModuleOptions,1,RM_SetModuleOptions,"void RM_SetModuleOptions (RedisModuleCtx*,int)",module.c,"void RM_SetModuleOptions(RedisModuleCtx *ctx, int options) {
    ctx->module->options = options;
}",2404.0,2406.0,1.0,1.0,3.0,3,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
4191,170926,RM_SignalModifiedKey,1,RM_SignalModifiedKey,"int RM_SignalModifiedKey (RedisModuleCtx*,robj*)",module.c,"int RM_SignalModifiedKey(RedisModuleCtx *ctx, RedisModuleString *keyname) {
    signalModifiedKey(ctx->client,ctx->client->db,keyname);
    return REDISMODULE_OK;
}",2415.0,2418.0,1.0,46.0,4.0,3,1,3,2,0,3,1,1,0,1,,0,2,4,2,2,int
4192,170946,RM_AutoMemory,1,RM_AutoMemory,void RM_AutoMemory (RedisModuleCtx*),module.c,"void RM_AutoMemory(RedisModuleCtx *ctx) {
    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
}",2439.0,2441.0,1.0,18.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
4193,170960,autoMemoryAdd,1,autoMemoryAdd,"void autoMemoryAdd (RedisModuleCtx*,int,void*)",module.c,"void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
    if (ctx->amqueue_used == ctx->amqueue_len) {
        ctx->amqueue_len *= 2;
        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;
        ctx->amqueue = zrealloc(ctx->amqueue,sizeof(struct AutoMemEntry)*ctx->amqueue_len);
    }
    ctx->amqueue[ctx->amqueue_used].type = type;
    ctx->amqueue[ctx->amqueue_used].ptr = ptr;
    ctx->amqueue_used++;
}",2444.0,2454.0,1.0,23.0,11.0,31,13,17,4,20,15,4,5,4,1,,0,15,6,3,3,void
4194,171046,autoMemoryFreed,1,autoMemoryFreed,"int autoMemoryFreed (RedisModuleCtx*,int,void*)",module.c,"int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;

    int count = (ctx->amqueue_used+1)/2;
    for (int j = 0; j < count; j++) {
        for (int side = 0; side < 2; side++) {
            /* For side = 0 check right side of the array, for
             * side = 1 check the left side instead (zig-zag scanning). */
            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;
            if (ctx->amqueue[i].type == type &&
                ctx->amqueue[i].ptr == ptr)
            {
                ctx->amqueue[i].type = REDISMODULE_AM_FREED;

                /* Switch the freed element and the last element, to avoid growing
                 * the queue unnecessarily if we allocate/free in a loop */
                if (i != ctx->amqueue_used-1) {
                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];
                }

                /* Reduce the size of the queue because we either moved...",2461.0,2489.0,1.0,23.0,29.0,43,16,28,7,2,11,6,12,4,0,,0,11,6,3,3,int
4195,171306,RM_CreateString,1,RM_CreateString,"robj RM_CreateString (RedisModuleCtx*,char*,size_t)",module.c,"RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
    RedisModuleString *o = createStringObject(ptr,len);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",2530.0,2534.0,1.0,17.0,5.0,2,2,8,5,9,2,2,2,0,2,,0,1,6,3,3,robj
4196,171334,RM_CreateStringPrintf,1,RM_CreateStringPrintf,"robj RM_CreateStringPrintf (RedisModuleCtx*,char*...)",module.c,"RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {
    sds s = sdsempty();

    va_list ap;
    va_start(ap, fmt);
    s = sdscatvprintf(s, fmt, ap);
    va_end(ap);

    RedisModuleString *o = createObject(OBJ_STRING, s);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);

    return o;
}",2544.0,2556.0,1.0,17.0,13.0,4,2,15,6,0,4,2,2,0,4,,0,3,4,2,2,robj
4197,171377,RM_CreateStringFromLongLong,1,RM_CreateStringFromLongLong,"robj RM_CreateStringFromLongLong (RedisModuleCtx*,long long)",module.c,"RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {
    char buf[LONG_STR_SIZE];
    size_t len = ll2string(buf,sizeof(buf),ll);
    return RM_CreateString(ctx,buf,len);
}",2567.0,2571.0,1.0,17.0,5.0,2,2,7,4,0,2,1,1,0,2,,0,1,4,2,2,robj
4198,171397,RM_CreateStringFromULongLong,1,RM_CreateStringFromULongLong,"robj RM_CreateStringFromULongLong (RedisModuleCtx*,long long unsigned)",module.c,"RedisModuleString *RM_CreateStringFromULongLong(RedisModuleCtx *ctx, unsigned long long ull) {
    char buf[LONG_STR_SIZE];
    size_t len = ull2string(buf,sizeof(buf),ull);
    return RM_CreateString(ctx,buf,len);
}",2581.0,2585.0,1.0,17.0,5.0,2,2,7,4,0,2,1,1,0,2,,0,1,4,2,2,robj
4199,171417,RM_CreateStringFromDouble,1,RM_CreateStringFromDouble,"robj RM_CreateStringFromDouble (RedisModuleCtx*,double)",module.c,"RedisModuleString *RM_CreateStringFromDouble(RedisModuleCtx *ctx, double d) {
    char buf[MAX_D2STRING_CHARS];
    size_t len = d2string(buf,sizeof(buf),d);
    return RM_CreateString(ctx,buf,len);
}",2592.0,2596.0,1.0,17.0,5.0,2,2,7,4,0,2,1,1,0,2,,0,1,4,2,2,robj
4200,171437,RM_CreateStringFromLongDouble,1,RM_CreateStringFromLongDouble,"robj RM_CreateStringFromLongDouble (RedisModuleCtx*,long double,int)",module.c,"RedisModuleString *RM_CreateStringFromLongDouble(RedisModuleCtx *ctx, long double ld, int humanfriendly) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    size_t len = ld2string(buf,sizeof(buf),ld,
        (humanfriendly ? LD_STR_HUMAN : LD_STR_AUTO));
    return RM_CreateString(ctx,buf,len);
}",2606.0,2611.0,1.0,17.0,6.0,3,3,10,7,0,2,1,1,0,2,,0,1,6,3,3,robj
4201,171462,RM_CreateStringFromString,1,RM_CreateStringFromString,"robj RM_CreateStringFromString (RedisModuleCtx*,robj*)",module.c,"RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
    RedisModuleString *o = dupStringObject(str);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",2621.0,2625.0,1.0,17.0,5.0,2,2,7,4,1,2,2,2,0,2,,0,1,4,2,2,robj
4202,171488,RM_CreateStringFromStreamID,1,RM_CreateStringFromStreamID,"robj RM_CreateStringFromStreamID (RedisModuleCtx*,RedisModuleStreamID*)",module.c,"RedisModuleString *RM_CreateStringFromStreamID(RedisModuleCtx *ctx, const RedisModuleStreamID *id) {
    streamID streamid = {id->ms, id->seq};
    RedisModuleString *o = createObjectFromStreamID(&streamid);
    if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, o);
    return o;
}",2632.0,2637.0,1.0,17.0,6.0,7,5,10,5,0,4,2,2,0,2,,0,3,4,2,2,robj
4203,171525,RM_FreeString,1,RM_FreeString,"void RM_FreeString (RedisModuleCtx*,robj*)",module.c,"void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
    decrRefCount(str);
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
}",2651.0,2654.0,1.0,40.0,4.0,1,1,5,3,0,2,2,2,0,2,,0,0,4,2,2,void
4204,171544,RM_RetainString,1,RM_RetainString,"void RM_RetainString (RedisModuleCtx*,robj*)",module.c,"void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
    if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {
        /* Increment the string reference counting only if we can't
         * just remove the object from the list of objects that should
         * be reclaimed. Why we do that, instead of just incrementing
         * the refcount in any case, and let the automatic FreeString()
         * call at the end to bring the refcount back at the desired
         * value? Because this way we ensure that the object refcount
         * value is 1 (instead of going to 2 to be dropped later to 1)
         * after the call to this function. This is needed for functions
         * like RedisModule_StringAppendBuffer() to work. */
        incrRefCount(str);
    }
}",2688.0,2701.0,1.0,42.0,14.0,3,3,5,3,0,2,2,2,1,2,,0,1,4,2,2,void
4205,171565,RM_HoldString,1,RM_HoldString,"robj RM_HoldString (RedisModuleCtx*,robj*)",module.c,"RedisModuleString* RM_HoldString(RedisModuleCtx *ctx, RedisModuleString *str) {
    if (str->refcount == OBJ_STATIC_REFCOUNT) {
        return RM_CreateStringFromString(ctx, str);
    }

    incrRefCount(str);
    if (ctx != NULL) {
        /*
         * Put the str in the auto memory management of the ctx.
         * It might already be there, in this case, the ref count will
         * be 2 and we will decrease the ref count twice and free the
         * object in the auto memory free function.
         *
         * Why we can not do the same trick of just remove the object
         * from the auto memory (like in RM_RetainString)?
         * This code shows the issue:
         *
         * RM_AutoMemory(ctx);
         * str1 = RM_CreateString(ctx, ""test"", 4);
         * str2 = RM_HoldString(ctx, str1);
         * RM_FreeString(str1);
         * RM_FreeString(str2);
         *
         * If after the RM_HoldString we would just remove the string from
         * the auto memory, th...",2730.0,2767.0,1.0,17.0,38.0,4,4,10,4,0,3,3,3,0,3,,0,0,4,2,2,robj
4206,171601,RM_StringPtrLen,1,RM_StringPtrLen,"const char* RM_StringPtrLen (robj*,size_t*)",module.c,"const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
    if (str == NULL) {
        const char *errmsg = ""(NULL string reply referenced in module)"";
        if (len) *len = strlen(errmsg);
        return errmsg;
    }
    if (len) *len = sdslen(str->ptr);
    return str->ptr;
}",2772.0,2780.0,1.0,34.0,9.0,8,4,11,4,0,1,4,5,0,1,,0,1,4,2,2,const char*
4207,171640,RM_StringToLongLong,1,RM_StringToLongLong,"int RM_StringToLongLong (robj*,long long*)",module.c,"int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
    return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :
                                                     REDISMODULE_ERR;
}",2790.0,2793.0,1.0,30.0,4.0,3,2,3,2,0,2,1,1,0,2,,0,1,4,2,2,int
4208,171663,RM_StringToULongLong,1,RM_StringToULongLong,"int RM_StringToULongLong (robj*,long long unsigned*)",module.c,"int RM_StringToULongLong(const RedisModuleString *str, unsigned long long *ull) {
    return string2ull(str->ptr,ull) ? REDISMODULE_OK : REDISMODULE_ERR;
}",2799.0,2801.0,1.0,31.0,3.0,2,2,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4209,171682,RM_StringToDouble,1,RM_StringToDouble,"int RM_StringToDouble (robj*,double*)",module.c,"int RM_StringToDouble(const RedisModuleString *str, double *d) {
    int retval = getDoubleFromObject(str,d);
    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
}",2806.0,2809.0,1.0,28.0,4.0,3,3,4,3,0,1,1,1,0,1,,0,1,4,2,2,int
4210,171707,RM_StringToLongDouble,1,RM_StringToLongDouble,"int RM_StringToLongDouble (robj*,long double*)",module.c,"int RM_StringToLongDouble(const RedisModuleString *str, long double *ld) {
    int retval = string2ld(str->ptr,sdslen(str->ptr),ld);
    return retval ? REDISMODULE_OK : REDISMODULE_ERR;
}",2814.0,2817.0,1.0,32.0,4.0,4,3,5,3,0,2,1,1,0,2,,0,2,4,2,2,int
4211,171734,RM_StringToStreamID,1,RM_StringToStreamID,"int RM_StringToStreamID (robj*,RedisModuleStreamID*)",module.c,"int RM_StringToStreamID(const RedisModuleString *str, RedisModuleStreamID *id) {
    streamID streamid;
    if (streamParseID(str, &streamid) == C_OK) {
        id->ms = streamid.ms;
        id->seq = streamid.seq;
        return REDISMODULE_OK;
    } else {
        return REDISMODULE_ERR;
    }
}",2824.0,2833.0,1.0,30.0,10.0,8,5,6,3,0,5,2,2,1,1,,0,5,4,2,2,int
4212,171775,RM_StringCompare,1,RM_StringCompare,"int RM_StringCompare (robj*,robj*)",module.c,"int RM_StringCompare(const RedisModuleString *a, const RedisModuleString *b) {
    return compareStringObjects(a,b);
}",2838.0,2840.0,1.0,27.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4213,171785,moduleAssertUnsharedString,1,moduleAssertUnsharedString,robj moduleAssertUnsharedString (robj*),module.c,"RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
    if (str->refcount != 1) {
        serverLog(LL_WARNING,
            ""Module attempted to use an in-place string modify operation ""
            ""with a string referenced multiple times. Please check the code ""
            ""for API usage correctness."");
        return NULL;
    }
    if (str->encoding == OBJ_ENCODING_EMBSTR) {
        /* Note: here we ""leak"" the additional allocation that was
         * used in order to store the embedded string in the object. */
        str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));
        str->encoding = OBJ_ENCODING_RAW;
    } else if (str->encoding == OBJ_ENCODING_INT) {
        /* Convert the string from integer to raw encoding. */
        str->ptr = sdsfromlonglong((long)str->ptr);
        str->encoding = OBJ_ENCODING_RAW;
    }
    return str;
}",2844.0,2863.0,1.0,17.0,20.0,13,7,9,3,1,3,3,3,0,3,,0,2,2,1,1,robj
4214,171875,RM_StringAppendBuffer,1,RM_StringAppendBuffer,"int RM_StringAppendBuffer (RedisModuleCtx*,robj*,char*,size_t)",module.c,"int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
    UNUSED(ctx);
    str = moduleAssertUnsharedString(str);
    if (str == NULL) return REDISMODULE_ERR;
    str->ptr = sdscatlen(str->ptr,buf,len);
    return REDISMODULE_OK;
}",2868.0,2874.0,1.0,47.0,7.0,6,4,10,5,0,2,2,2,0,2,,0,2,8,4,4,int
4215,171916,RM_TrimStringAllocation,1,RM_TrimStringAllocation,void RM_TrimStringAllocation (robj*),module.c,"void RM_TrimStringAllocation(RedisModuleString *str) {
    if (!str) return;
    trimStringObjectIfNeeded(str, 1);
}",2899.0,2902.0,1.0,29.0,4.0,1,1,2,1,0,1,2,2,0,1,,0,0,2,1,1,void
4216,171929,RM_WrongArity,1,RM_WrongArity,int RM_WrongArity (RedisModuleCtx*),module.c,"int RM_WrongArity(RedisModuleCtx *ctx) {
    addReplyErrorArity(ctx->client);
    return REDISMODULE_OK;
}",2935.0,2938.0,1.0,11.0,4.0,1,1,1,1,0,2,1,1,0,1,,0,1,2,1,1,int
4217,171942,moduleGetReplyClient,1,moduleGetReplyClient,client moduleGetReplyClient (RedisModuleCtx*),module.c,"client *moduleGetReplyClient(RedisModuleCtx *ctx) {
    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {
        if (ctx->blocked_client)
            return ctx->blocked_client->reply_client;
        else
            return NULL;
    } else {
        /* If this is a non thread safe context, just return the client
         * that is running the command if any. This may be NULL as well
         * in the case of contexts that are not executed with associated
         * clients, like timer contexts. */
        return ctx->client;
    }
}",2954.0,2967.0,1.0,21.0,14.0,6,3,3,1,19,3,3,4,2,0,,0,3,2,1,1,client
4218,171979,RM_ReplyWithLongLong,1,RM_ReplyWithLongLong,"int RM_ReplyWithLongLong (RedisModuleCtx*,long long)",module.c,"int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyLongLong(c,ll);
    return REDISMODULE_OK;
}",2971.0,2976.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4219,172006,RM_ReplyWithError,1,RM_ReplyWithError,"int RM_ReplyWithError (RedisModuleCtx*,char*)",module.c,"int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyErrorFormat(c,""-%s"",err);
    return REDISMODULE_OK;
}",2992.0,2997.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4220,172034,RM_ReplyWithErrorFormat,1,RM_ReplyWithErrorFormat,"int RM_ReplyWithErrorFormat (RedisModuleCtx*,char*...)",module.c,"int RM_ReplyWithErrorFormat(RedisModuleCtx *ctx, const char *fmt, ...) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;

    int len = strlen(fmt) + 2; /* 1 for the \0 and 1 for the hyphen */
    char *hyphenfmt = zmalloc(len);
    snprintf(hyphenfmt, len, ""-%s"", fmt);

    va_list ap;
    va_start(ap, fmt);
    addReplyErrorFormatInternal(c, 0, hyphenfmt, ap);
    va_end(ap);

    zfree(hyphenfmt);

    return REDISMODULE_OK;
}",3013.0,3029.0,1.0,26.0,17.0,5,3,18,7,0,4,2,2,0,4,,0,2,4,2,2,int
4221,172088,RM_ReplyWithSimpleString,1,RM_ReplyWithSimpleString,"int RM_ReplyWithSimpleString (RedisModuleCtx*,char*)",module.c,"int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyProto(c,""+"",1);
    addReplyProto(c,msg,strlen(msg));
    addReplyProto(c,""\r\n"",2);
    return REDISMODULE_OK;
}",3036.0,3043.0,1.0,26.0,8.0,2,2,9,4,0,4,2,2,0,4,,0,1,4,2,2,int
4222,172125,moduleReplyWithCollection,1,moduleReplyWithCollection,"int moduleReplyWithCollection (RedisModuleCtx*,long,int)",module.c,"int moduleReplyWithCollection(RedisModuleCtx *ctx, long len, int type) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    if (len == REDISMODULE_POSTPONED_LEN) {
        ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*
                (ctx->postponed_arrays_count+1));
        ctx->postponed_arrays[ctx->postponed_arrays_count] =
            addReplyDeferredLen(c);
        ctx->postponed_arrays_count++;
    } else if (len == 0) {
        switch (type) {
        case COLLECTION_REPLY_ARRAY:
            addReply(c, shared.emptyarray);
            break;
        case COLLECTION_REPLY_MAP:
            addReply(c, shared.emptymap[c->resp]);
            break;
        case COLLECTION_REPLY_SET:
            addReply(c, shared.emptyset[c->resp]);
            break;
        case COLLECTION_REPLY_ATTRIBUTE:
            addReplyAttributeLen(c,len);
            break;
        default:
            serverPanic(""Invalid module empty reply ...",3050.0,3094.0,1.0,26.0,45.0,17,9,13,5,4,9,3,3,0,3,,0,9,6,3,3,int
4223,172301,RM_ReplyWithArray,1,RM_ReplyWithArray,"int RM_ReplyWithArray (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_ARRAY);
}",3105.0,3107.0,1.0,47.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4224,172314,RM_ReplyWithMap,1,RM_ReplyWithMap,"int RM_ReplyWithMap (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithMap(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_MAP);
}",3122.0,3124.0,1.0,47.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4225,172327,RM_ReplyWithSet,1,RM_ReplyWithSet,"int RM_ReplyWithSet (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithSet(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_SET);
}",3139.0,3141.0,1.0,47.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4226,172340,RM_ReplyWithAttribute,1,RM_ReplyWithAttribute,"int RM_ReplyWithAttribute (RedisModuleCtx*,long)",module.c,"int RM_ReplyWithAttribute(RedisModuleCtx *ctx, long len) {
    if (ctx->client->resp == 2) return REDISMODULE_ERR;
 
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_ATTRIBUTE);
}",3155.0,3159.0,1.0,39.0,5.0,3,2,3,2,0,2,2,2,1,1,,0,1,4,2,2,int
4227,172366,RM_ReplyWithNullArray,1,RM_ReplyWithNullArray,int RM_ReplyWithNullArray (RedisModuleCtx*),module.c,"int RM_ReplyWithNullArray(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyNullArray(c);
    return REDISMODULE_OK;
}",3169.0,3174.0,1.0,26.0,6.0,2,2,5,3,0,2,2,2,0,2,,0,1,2,1,1,int
4228,172391,RM_ReplyWithEmptyArray,1,RM_ReplyWithEmptyArray,int RM_ReplyWithEmptyArray (RedisModuleCtx*),module.c,"int RM_ReplyWithEmptyArray(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReply(c,shared.emptyarray);
    return REDISMODULE_OK;
}",3179.0,3184.0,1.0,26.0,6.0,3,3,6,4,0,2,2,2,0,2,,0,1,2,1,1,int
4229,172419,moduleReplySetCollectionLength,1,moduleReplySetCollectionLength,"void moduleReplySetCollectionLength (RedisModuleCtx*,long,int)",module.c,"void moduleReplySetCollectionLength(RedisModuleCtx *ctx, long len, int type) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return;
    if (ctx->postponed_arrays_count == 0) {
        serverLog(LL_WARNING,
            ""API misuse detected in module %s: ""
            ""RedisModule_ReplySet*Length() called without previous ""
            ""RedisModule_ReplyWith*(ctx,REDISMODULE_POSTPONED_LEN) ""
            ""call."", ctx->module->name);
            return;
    }
    ctx->postponed_arrays_count--;
    switch(type) {
    case COLLECTION_REPLY_ARRAY:
        setDeferredArrayLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_MAP:
        setDeferredMapLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_SET:
        setDeferredSetLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_ATTRIBUTE:
        setDeferredAttributeLen(...",3186.0,3218.0,1.0,8.0,33.0,29,9,30,6,4,22,9,5,2,8,,0,15,6,3,3,void
4230,172561,RM_ReplySetArrayLength,1,RM_ReplySetArrayLength,"void RM_ReplySetArrayLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_ARRAY);
}",3246.0,3248.0,1.0,45.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
4231,172573,RM_ReplySetMapLength,1,RM_ReplySetMapLength,"void RM_ReplySetMapLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetMapLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_MAP);
}",3254.0,3256.0,1.0,45.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
4232,172585,RM_ReplySetSetLength,1,RM_ReplySetSetLength,"void RM_ReplySetSetLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetSetLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_SET);
}",3260.0,3262.0,1.0,45.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
4233,172597,RM_ReplySetAttributeLength,1,RM_ReplySetAttributeLength,"void RM_ReplySetAttributeLength (RedisModuleCtx*,long)",module.c,"void RM_ReplySetAttributeLength(RedisModuleCtx *ctx, long len) {
    if (ctx->client->resp == 2) return;
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_ATTRIBUTE);
}",3268.0,3271.0,1.0,45.0,4.0,3,2,3,2,0,2,2,2,1,1,,0,1,4,2,2,void
4234,172619,RM_ReplyWithStringBuffer,1,RM_ReplyWithStringBuffer,"int RM_ReplyWithStringBuffer (RedisModuleCtx*,char*,size_t)",module.c,"int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulkCBuffer(c,(char*)buf,len);
    return REDISMODULE_OK;
}",3276.0,3281.0,1.0,26.0,6.0,3,3,7,5,0,2,2,2,0,2,,0,1,6,3,3,int
4235,172650,RM_ReplyWithCString,1,RM_ReplyWithCString,"int RM_ReplyWithCString (RedisModuleCtx*,char*)",module.c,"int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulkCString(c,(char*)buf);
    return REDISMODULE_OK;
}",3287.0,3292.0,1.0,26.0,6.0,3,3,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4236,172679,RM_ReplyWithString,1,RM_ReplyWithString,"int RM_ReplyWithString (RedisModuleCtx*,robj*)",module.c,"int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulk(c,str);
    return REDISMODULE_OK;
}",3297.0,3302.0,1.0,44.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4237,172706,RM_ReplyWithEmptyString,1,RM_ReplyWithEmptyString,int RM_ReplyWithEmptyString (RedisModuleCtx*),module.c,"int RM_ReplyWithEmptyString(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReply(c,shared.emptybulk);
    return REDISMODULE_OK;
}",3307.0,3312.0,1.0,26.0,6.0,3,3,6,4,0,2,2,2,0,2,,0,1,2,1,1,int
4238,172734,RM_ReplyWithVerbatimStringType,1,RM_ReplyWithVerbatimStringType,"int RM_ReplyWithVerbatimStringType (RedisModuleCtx*,char*,size_t,char*)",module.c,"int RM_ReplyWithVerbatimStringType(RedisModuleCtx *ctx, const char *buf, size_t len, const char *ext) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyVerbatim(c, buf, len, ext);
    return REDISMODULE_OK;
}",3318.0,3323.0,1.0,26.0,6.0,2,2,8,6,1,2,2,2,0,2,,0,1,8,4,4,int
4239,172765,RM_ReplyWithVerbatimString,1,RM_ReplyWithVerbatimString,"int RM_ReplyWithVerbatimString (RedisModuleCtx*,char*,size_t)",module.c,"int RM_ReplyWithVerbatimString(RedisModuleCtx *ctx, const char *buf, size_t len) {
	return RM_ReplyWithVerbatimStringType(ctx, buf, len, ""txt"");
}",3329.0,3331.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
4240,172778,RM_ReplyWithNull,1,RM_ReplyWithNull,int RM_ReplyWithNull (RedisModuleCtx*),module.c,"int RM_ReplyWithNull(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyNull(c);
    return REDISMODULE_OK;
}",3336.0,3341.0,1.0,26.0,6.0,2,2,5,3,0,2,2,2,0,2,,0,1,2,1,1,int
4241,172803,RM_ReplyWithBool,1,RM_ReplyWithBool,"int RM_ReplyWithBool (RedisModuleCtx*,int)",module.c,"int RM_ReplyWithBool(RedisModuleCtx *ctx, int b) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBool(c,b);
    return REDISMODULE_OK;
}",3350.0,3355.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4242,172830,RM_ReplyWithCallReply,1,RM_ReplyWithCallReply,"int RM_ReplyWithCallReply (RedisModuleCtx*,RedisModuleCallReply*)",module.c,"int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    if (c->resp == 2 && callReplyIsResp3(reply)) {
        /* The reply is in RESP3 format and the client is RESP2,
         * so it isn't possible to send this reply to the client. */
        return REDISMODULE_ERR;
    }
    size_t proto_len;
    const char *proto = callReplyGetProto(reply, &proto_len);
    addReplyProto(c, proto, proto_len);
    /* Propagate the error list from that reply to the other client, to do some
     * post error reply handling, like statistics.
     * Note that if the original reply had an array with errors, and the module
     * replied with just a portion of the original reply, and not the entire
     * reply, the errors are currently not propagated and the errors stats
     * will not get propagated. */
    list *errors = callReplyDeferredErrorList(reply);
    if (errors)
        deferredAft...",3370.0,3391.0,1.0,26.0,22.0,8,5,17,7,0,7,4,4,2,6,,0,5,4,2,2,int
4243,172891,RM_ReplyWithDouble,1,RM_ReplyWithDouble,"int RM_ReplyWithDouble (RedisModuleCtx*,double)",module.c,"int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyDouble(c,d);
    return REDISMODULE_OK;
}",3405.0,3410.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4244,172918,RM_ReplyWithBigNumber,1,RM_ReplyWithBigNumber,"int RM_ReplyWithBigNumber (RedisModuleCtx*,char*,size_t)",module.c,"int RM_ReplyWithBigNumber(RedisModuleCtx *ctx, const char *bignum, size_t len) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBigNum(c, bignum, len);
    return REDISMODULE_OK;
}",3420.0,3425.0,1.0,26.0,6.0,2,2,7,5,0,2,2,2,0,2,,0,1,6,3,3,int
4245,172947,RM_ReplyWithLongDouble,1,RM_ReplyWithLongDouble,"int RM_ReplyWithLongDouble (RedisModuleCtx*,long double)",module.c,"int RM_ReplyWithLongDouble(RedisModuleCtx *ctx, long double ld) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyHumanLongDouble(c, ld);
    return REDISMODULE_OK;
}",3435.0,3440.0,1.0,26.0,6.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,int
4246,172974,RM_Replicate,1,RM_Replicate,"int RM_Replicate (RedisModuleCtx*,char*,char*...)",module.c,"int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    struct redisCommand *cmd;
    robj **argv = NULL;
    int argc = 0, flags = 0, j;
    va_list ap;

    cmd = lookupCommandByCString((char*)cmdname);
    if (!cmd) return REDISMODULE_ERR;

    /* Create the client and dispatch the command. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    va_end(ap);
    if (argv == NULL) return REDISMODULE_ERR;

    /* Select the propagation target. Usually is AOF + replicas, however
     * the caller can exclude one or the other using the ""A"" or ""R""
     * modifiers. */
    int target = 0;
    if (!(flags & REDISMODULE_ARGV_NO_AOF)) target |= PROPAGATE_AOF;
    if (!(flags & REDISMODULE_ARGV_NO_REPLICAS)) target |= PROPAGATE_REPL;

    alsoPropagate(ctx->client->db->id,argv,argc,target);

    /* Release the argv. */
    for (j = 0; j < argc; j++) decrRefCount(argv[j]);
    zfree(argv);
    server.dirty++;
    re...",3483.0,3512.0,1.0,21.0,30.0,24,11,32,12,0,5,6,6,0,4,,0,3,6,3,3,int
4247,173103,RM_ReplicateVerbatim,1,RM_ReplicateVerbatim,int RM_ReplicateVerbatim (RedisModuleCtx*),module.c,"int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
    alsoPropagate(ctx->client->db->id,
        ctx->client->argv,ctx->client->argc,
        PROPAGATE_AOF|PROPAGATE_REPL);
    server.dirty++;
    return REDISMODULE_OK;
}",3525.0,3531.0,1.0,8.0,7.0,10,4,4,2,0,4,1,1,0,1,,0,3,2,1,1,int
4248,173141,RM_GetClientId,1,RM_GetClientId,unsigned long long RM_GetClientId (RedisModuleCtx*),module.c,"unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {
    if (ctx->client == NULL) return 0;
    return ctx->client->id;
}",3556.0,3559.0,1.0,1.0,4.0,4,2,3,2,0,2,2,2,1,0,,0,2,2,1,1,unsigned long long
4249,173161,RM_GetClientUserNameById,1,RM_GetClientUserNameById,"robj RM_GetClientUserNameById (RedisModuleCtx*,uint64_t)",module.c,"RedisModuleString *RM_GetClientUserNameById(RedisModuleCtx *ctx, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL) {
        errno = ENOENT;
        return NULL;
    }
    
    if (client->user == NULL) {
        errno = ENOTSUP;
        return NULL;
    }

    sds name = sdsnew(client->user->name);
    robj *str = createObject(OBJ_STRING, name);
    autoMemoryAdd(ctx, REDISMODULE_AM_STRING, str);
    return str;
}",3565.0,3581.0,1.0,17.0,17.0,10,3,19,9,0,6,3,3,1,4,,0,5,4,2,2,robj
4250,173219,modulePopulateClientInfoStructure,1,modulePopulateClientInfoStructure,"int modulePopulateClientInfoStructure (void*,client*,int)",module.c,"int modulePopulateClientInfoStructure(void *ci, client *client, int structver) {
    if (structver != 1) return REDISMODULE_ERR;

    RedisModuleClientInfoV1 *ci1 = ci;
    memset(ci1,0,sizeof(*ci1));
    ci1->version = structver;
    if (client->flags & CLIENT_MULTI)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_MULTI;
    if (client->flags & CLIENT_PUBSUB)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_PUBSUB;
    if (client->flags & CLIENT_UNIX_SOCKET)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET;
    if (client->flags & CLIENT_TRACKING)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_TRACKING;
    if (client->flags & CLIENT_BLOCKED)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_BLOCKED;
    if (client->conn->type == connectionTypeTls())
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_SSL;

    int port;
    connAddrPeerName(client->conn,ci1->addr,sizeof(ci1->addr),&port);
    ci1->port = port;
    ci1->db = client->db->id;
    ci1->id = client->id;...",3589.0,3614.0,1.0,31.0,26.0,50,9,29,5,2,11,8,8,7,2,,0,10,6,3,3,int
4251,173407,modulePopulateReplicationInfoStructure,1,modulePopulateReplicationInfoStructure,"int modulePopulateReplicationInfoStructure (void*,int)",module.c,"int modulePopulateReplicationInfoStructure(void *ri, int structver) {
    if (structver != 1) return REDISMODULE_ERR;

    RedisModuleReplicationInfoV1 *ri1 = ri;
    memset(ri1,0,sizeof(*ri1));
    ri1->version = structver;
    ri1->master = server.masterhost==NULL;
    ri1->masterhost = server.masterhost? server.masterhost: """";
    ri1->masterport = server.masterport;
    ri1->replid1 = server.replid;
    ri1->replid2 = server.replid2;
    ri1->repl1_offset = server.master_repl_offset;
    ri1->repl2_offset = server.second_replid_offset;
    return REDISMODULE_OK;
}",3621.0,3635.0,1.0,31.0,15.0,30,8,23,5,0,0,2,2,0,0,,0,0,4,2,2,int
4252,173497,RM_GetClientInfoById,1,RM_GetClientInfoById,"int RM_GetClientInfoById (void*,uint64_t)",module.c,"int RM_GetClientInfoById(void *ci, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL) return REDISMODULE_ERR;
    if (ci == NULL) return REDISMODULE_OK;

    /* Fill the info structure if passed. */
    uint64_t structver = ((uint64_t*)ci)[0];
    return modulePopulateClientInfoStructure(ci,client,structver);
}",3679.0,3687.0,1.0,31.0,9.0,6,4,11,5,0,2,3,3,0,2,,0,1,4,2,2,int
4253,173539,RM_GetClientNameById,1,RM_GetClientNameById,"robj RM_GetClientNameById (RedisModuleCtx*,uint64_t)",module.c,"RedisModuleString *RM_GetClientNameById(RedisModuleCtx *ctx, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL || client->name == NULL) return NULL;
    robj *name = client->name;
    incrRefCount(name);
    autoMemoryAdd(ctx, REDISMODULE_AM_STRING, name);
    return name;
}",3693.0,3700.0,1.0,17.0,8.0,7,4,13,5,0,5,2,2,1,3,,0,3,4,2,2,robj
4254,173579,RM_SetClientNameById,1,RM_SetClientNameById,"int RM_SetClientNameById (uint64_t,robj*)",module.c,"int RM_SetClientNameById(uint64_t id, RedisModuleString *name) {
    client *client = lookupClientByID(id);
    if (client == NULL) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    if (clientSetName(client, name, NULL) == C_ERR) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",3710.0,3721.0,1.0,38.0,12.0,6,3,11,7,0,2,3,3,1,2,,0,2,4,2,2,int
4255,173624,RM_PublishMessage,1,RM_PublishMessage,"int RM_PublishMessage (RedisModuleCtx*,robj*,robj*)",module.c,"int RM_PublishMessage(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {
    UNUSED(ctx);
    return pubsubPublishMessageAndPropagateToCluster(channel, message, 0);
}",3724.0,3727.0,1.0,43.0,4.0,1,1,4,3,0,1,1,1,0,1,,0,0,6,3,3,int
4256,173642,RM_PublishMessageShard,1,RM_PublishMessageShard,"int RM_PublishMessageShard (RedisModuleCtx*,robj*,robj*)",module.c,"int RM_PublishMessageShard(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {
    UNUSED(ctx);
    return pubsubPublishMessageAndPropagateToCluster(channel, message, 1);
}",3730.0,3733.0,1.0,48.0,4.0,1,1,4,3,0,1,1,1,0,1,,0,0,6,3,3,int
4257,173660,RM_GetSelectedDb,1,RM_GetSelectedDb,int RM_GetSelectedDb (RedisModuleCtx*),module.c,"int RM_GetSelectedDb(RedisModuleCtx *ctx) {
    return ctx->client->db->id;
}",3736.0,3738.0,1.0,1.0,3.0,3,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4258,173673,RM_GetContextFlags,1,RM_GetContextFlags,int RM_GetContextFlags (RedisModuleCtx*),module.c,"int RM_GetContextFlags(RedisModuleCtx *ctx) {
    int flags = 0;

    /* Client specific flags */
    if (ctx) {
        if (ctx->client) {
            if (ctx->client->flags & CLIENT_DENY_BLOCKING)
                flags |= REDISMODULE_CTX_FLAGS_DENY_BLOCKING;
            /* Module command received from MASTER, is replicated. */
            if (ctx->client->flags & CLIENT_MASTER)
                flags |= REDISMODULE_CTX_FLAGS_REPLICATED;
            if (ctx->client->resp == 3) {
                flags |= REDISMODULE_CTX_FLAGS_RESP3;
            }
        }

        /* For DIRTY flags, we need the blocked client if used */
        client *c = ctx->blocked_client ? ctx->blocked_client->client : ctx->client;
        if (c && (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC))) {
            flags |= REDISMODULE_CTX_FLAGS_MULTI_DIRTY;
        }
    }

    if (scriptIsRunning())
        flags |= REDISMODULE_CTX_FLAGS_LUA;

    if (server.in_exec)
        flags |= REDISMODULE_CTX_FLAGS_MULTI...",3810.0,3899.0,1.0,37.0,90.0,73,15,52,7,0,11,21,30,7,3,,0,11,2,1,1,int
4259,174102,RM_AvoidReplicaTraffic,1,RM_AvoidReplicaTraffic,int RM_AvoidReplicaTraffic (void),module.c,"int RM_AvoidReplicaTraffic(void) {
    return !!(isPausedActionsWithUpdate(PAUSE_ACTION_REPLICA));
}",3921.0,3923.0,1.0,40.0,3.0,3,2,0,0,0,1,1,1,0,1,,0,0,2,1,1,int
4260,174116,RM_SelectDb,1,RM_SelectDb,"int RM_SelectDb (RedisModuleCtx*,int)",module.c,"int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
    int retval = selectDb(ctx->client,newid);
    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
}",3935.0,3938.0,1.0,22.0,4.0,4,4,4,3,0,2,1,1,0,1,,0,2,4,2,2,int
4261,174143,RM_KeyExists,1,RM_KeyExists,"int RM_KeyExists (RedisModuleCtx*,robj*)",module.c,"int RM_KeyExists(RedisModuleCtx *ctx, robj *keyname) {
    robj *value = lookupKeyReadWithFlags(ctx->client->db, keyname, LOOKUP_NOTOUCH);
    return (value != NULL);
}",3946.0,3949.0,1.0,67.0,4.0,5,4,5,4,0,2,1,1,0,1,,0,2,4,2,2,int
4262,174168,moduleInitKey,1,moduleInitKey,"void moduleInitKey (RedisModuleKey*,RedisModuleCtx*,robj*,robj*,int)",module.c,"static void moduleInitKey(RedisModuleKey *kp, RedisModuleCtx *ctx, robj *keyname, robj *value, int mode){
    kp->ctx = ctx;
    kp->db = ctx->client->db;
    kp->key = keyname;
    incrRefCount(keyname);
    kp->value = value;
    kp->iter = NULL;
    kp->mode = mode;
    if (kp->value) moduleInitKeyTypeSpecific(kp);
}",3952.0,3961.0,1.0,1.0,10.0,15,2,15,6,2,10,2,2,1,2,,0,8,10,5,5,void
4263,174253,RM_OpenKey,1,RM_OpenKey,"RedisModuleKey RM_OpenKey (RedisModuleCtx*,robj*,int)",module.c,"RedisModuleKey *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
    RedisModuleKey *kp;
    robj *value;
    int flags = 0;
    flags |= (mode & REDISMODULE_OPEN_KEY_NOTOUCH? LOOKUP_NOTOUCH: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NONOTIFY? LOOKUP_NONOTIFY: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOSTATS? LOOKUP_NOSTATS: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOEXPIRE? LOOKUP_NOEXPIRE: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOEFFECTS? LOOKUP_NOEFFECTS: 0);

    if (mode & REDISMODULE_WRITE) {
        value = lookupKeyWriteWithFlags(ctx->client->db,keyname, flags);
    } else {
        value = lookupKeyReadWithFlags(ctx->client->db,keyname, flags);
        if (value == NULL) {
            return NULL;
        }
    }

    /* Setup the key handle. */
    kp = zmalloc(sizeof(*kp));
    moduleInitKey(kp, ctx, keyname, value, mode);
    autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);
    return kp;
}",3992.0,4016.0,1.0,21.0,25.0,35,8,26,6,0,5,2,2,0,4,,0,3,6,3,3,RedisModuleKey
4264,174416,RM_GetOpenKeyModesAll,1,RM_GetOpenKeyModesAll,int RM_GetOpenKeyModesAll (void),module.c,"int RM_GetOpenKeyModesAll(void) {
    return _REDISMODULE_OPEN_KEY_ALL;
}",4031.0,4033.0,1.0,11.0,3.0,13,2,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4265,174451,moduleCloseKey,1,moduleCloseKey,void moduleCloseKey (RedisModuleKey*),module.c,"static void moduleCloseKey(RedisModuleKey *key) {
    int signal = SHOULD_SIGNAL_MODIFIED_KEYS(key->ctx);
    if ((key->mode & REDISMODULE_WRITE) && signal)
        signalModifiedKey(key->ctx->client,key->db,key->key);
    if (key->value) {
        if (key->iter) moduleFreeKeyIterator(key);
        switch (key->value->type) {
        case OBJ_ZSET:
            RM_ZsetRangeStop(key);
            break;
        case OBJ_STREAM:
            if (key->u.stream.signalready)
                /* One or more RM_StreamAdd() have been done. */
                signalKeyAsReady(key->db, key->key, OBJ_STREAM);
            break;
        }
    }
    serverAssert(key->iter == NULL);
    decrRefCount(key->key);
}",4036.0,4055.0,1.0,17.0,20.0,35,12,20,3,2,21,8,10,5,6,,0,15,2,1,1,void
4266,174603,RM_KeyType,1,RM_KeyType,int RM_KeyType (RedisModuleKey*),module.c,"int RM_KeyType(RedisModuleKey *key) {
    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
    /* We map between defines so that we are free to change the internal
     * defines as desired. */
    switch(key->value->type) {
    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
    case OBJ_STREAM: return REDISMODULE_KEYTYPE_STREAM;
    default: return REDISMODULE_KEYTYPE_EMPTY;
    }
}",4067.0,4081.0,1.0,51.0,15.0,6,3,5,2,2,2,3,3,2,0,,0,2,2,1,1,int
4267,174691,RM_ValueLength,1,RM_ValueLength,size_t RM_ValueLength (RedisModuleKey*),module.c,"size_t RM_ValueLength(RedisModuleKey *key) {
    if (key == NULL || key->value == NULL) return 0;
    switch(key->value->type) {
    case OBJ_STRING: return stringObjectLen(key->value);
    case OBJ_LIST: return listTypeLength(key->value);
    case OBJ_SET: return setTypeSize(key->value);
    case OBJ_ZSET: return zsetLength(key->value);
    case OBJ_HASH: return hashTypeLength(key->value);
    case OBJ_STREAM: return streamLength(key->value);
    default: return 0;
    }
}",4088.0,4099.0,1.0,9.0,12.0,12,3,11,2,0,14,3,3,2,6,,0,8,2,1,1,size_t
4268,174773,RM_DeleteKey,1,RM_DeleteKey,int RM_DeleteKey (RedisModuleKey*),module.c,"int RM_DeleteKey(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value) {
        dbDelete(key->db,key->key);
        key->value = NULL;
    }
    return REDISMODULE_OK;
}",4105.0,4112.0,1.0,22.0,8.0,9,5,6,2,2,6,3,3,2,1,,0,5,2,1,1,int
4269,174815,RM_UnlinkKey,1,RM_UnlinkKey,int RM_UnlinkKey (RedisModuleKey*),module.c,"int RM_UnlinkKey(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value) {
        dbAsyncDelete(key->db,key->key);
        key->value = NULL;
    }
    return REDISMODULE_OK;
}",4119.0,4126.0,1.0,22.0,8.0,9,5,6,2,0,6,3,3,2,1,,0,5,2,1,1,int
4270,174857,RM_GetExpire,1,RM_GetExpire,mstime_t RM_GetExpire (RedisModuleKey*),module.c,"mstime_t RM_GetExpire(RedisModuleKey *key) {
    mstime_t expire = getExpire(key->db,key->key);
    if (expire == -1 || key->value == NULL)
        return REDISMODULE_NO_EXPIRE;
    expire -= commandTimeSnapshot();
    return expire >= 0 ? expire : 0;
}",4131.0,4137.0,1.0,15.0,7.0,12,8,9,3,0,5,2,2,1,2,,0,4,2,1,1,mstime_t
4271,174899,RM_SetExpire,1,RM_SetExpire,"int RM_SetExpire (RedisModuleKey*,mstime_t)",module.c,"int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL || (expire < 0 && expire != REDISMODULE_NO_EXPIRE))
        return REDISMODULE_ERR;
    if (expire != REDISMODULE_NO_EXPIRE) {
        expire += commandTimeSnapshot();
        setExpire(key->ctx->client,key->db,key->key,expire);
    } else {
        removeExpire(key->db,key->key);
    }
    return REDISMODULE_OK;
}",4148.0,4158.0,1.0,22.0,11.0,19,11,11,3,0,7,3,3,2,2,,0,5,4,2,2,int
4272,174975,RM_GetAbsExpire,1,RM_GetAbsExpire,mstime_t RM_GetAbsExpire (RedisModuleKey*),module.c,"mstime_t RM_GetAbsExpire(RedisModuleKey *key) {
    mstime_t expire = getExpire(key->db,key->key);
    if (expire == -1 || key->value == NULL)
        return REDISMODULE_NO_EXPIRE;
    return expire;
}",4163.0,4168.0,1.0,15.0,6.0,9,5,7,3,0,4,2,2,1,1,,0,4,2,1,1,mstime_t
4273,175009,RM_SetAbsExpire,1,RM_SetAbsExpire,"int RM_SetAbsExpire (RedisModuleKey*,mstime_t)",module.c,"int RM_SetAbsExpire(RedisModuleKey *key, mstime_t expire) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL || (expire < 0 && expire != REDISMODULE_NO_EXPIRE))
        return REDISMODULE_ERR;
    if (expire != REDISMODULE_NO_EXPIRE) {
        setExpire(key->ctx->client,key->db,key->key,expire);
    } else {
        removeExpire(key->db,key->key);
    }
    return REDISMODULE_OK;
}",4179.0,4188.0,1.0,22.0,10.0,18,10,10,3,0,6,3,3,2,1,,0,5,4,2,2,int
4274,175082,RM_ResetDataset,1,RM_ResetDataset,"void RM_ResetDataset (int,int)",module.c,"void RM_ResetDataset(int restart_aof, int async) {
    if (restart_aof && server.aof_state != AOF_OFF) stopAppendOnly();
    flushAllDataAndResetRDB((async? EMPTYDB_ASYNC: EMPTYDB_NO_FLAGS) | EMPTYDB_NOFUNCTIONS);
    if (server.aof_enabled && restart_aof) restartAOFAfterSYNC();
}",4194.0,4198.0,1.0,43.0,5.0,9,6,5,3,0,3,3,3,0,3,,0,0,4,2,2,void
4275,175125,RM_DbSize,1,RM_DbSize,unsigned long long RM_DbSize (RedisModuleCtx*),module.c,"unsigned long long RM_DbSize(RedisModuleCtx *ctx) {
    return dictSize(ctx->client->db->dict);
}",4201.0,4203.0,1.0,11.0,3.0,14,3,3,1,0,3,1,1,0,0,,0,3,2,1,1,unsigned long long
4276,175163,RM_RandomKey,1,RM_RandomKey,robj RM_RandomKey (RedisModuleCtx*),module.c,"RedisModuleString *RM_RandomKey(RedisModuleCtx *ctx) {
    robj *key = dbRandomKey(ctx->client->db);
    autoMemoryAdd(ctx,REDISMODULE_AM_STRING,key);
    return key;
}",4206.0,4210.0,1.0,17.0,5.0,3,2,5,2,0,3,1,1,0,2,,0,2,2,1,1,robj
4277,175185,RM_GetKeyNameFromOptCtx,1,RM_GetKeyNameFromOptCtx,robj RM_GetKeyNameFromOptCtx (RedisModuleKeyOptCtx*),module.c,"const RedisModuleString *RM_GetKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->from_key;
}",4213.0,4215.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
4278,175194,RM_GetToKeyNameFromOptCtx,1,RM_GetToKeyNameFromOptCtx,robj RM_GetToKeyNameFromOptCtx (RedisModuleKeyOptCtx*),module.c,"const RedisModuleString *RM_GetToKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->to_key;
}",4218.0,4220.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
4279,175203,RM_GetDbIdFromOptCtx,1,RM_GetDbIdFromOptCtx,int RM_GetDbIdFromOptCtx (RedisModuleKeyOptCtx*),module.c,"int RM_GetDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->from_dbid;
}",4223.0,4225.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4280,175212,RM_GetToDbIdFromOptCtx,1,RM_GetToDbIdFromOptCtx,int RM_GetToDbIdFromOptCtx (RedisModuleKeyOptCtx*),module.c,"int RM_GetToDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->to_dbid;
}",4228.0,4230.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4281,175221,RM_StringSet,1,RM_StringSet,"int RM_StringSet (RedisModuleKey*,robj*)",module.c,"int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
    RM_DeleteKey(key);
    setKey(key->ctx->client,key->db,key->key,str,SETKEY_NO_SIGNAL);
    key->value = str;
    return REDISMODULE_OK;
}",4241.0,4247.0,1.0,38.0,7.0,12,6,9,2,0,8,2,2,2,2,,0,6,4,2,2,int
4282,175274,RM_StringDMA,1,RM_StringDMA,"char* RM_StringDMA (RedisModuleKey*,size_t*,int)",module.c,"char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
    /* We need to return *some* pointer for empty keys, we just return
     * a string literal pointer, that is the advantage to be mapped into
     * a read only memory page, so the module will segfault if a write
     * attempt is performed. */
    char *emptystring = ""<dma-empty-string>"";
    if (key->value == NULL) {
        *len = 0;
        return emptystring;
    }

    if (key->value->type != OBJ_STRING) return NULL;

    /* For write access, and even for read access if the object is encoded,
     * we unshare the string (that has the side effect of decoding it). */
    if ((mode & REDISMODULE_WRITE) || key->value->encoding != OBJ_ENCODING_RAW)
        key->value = dbUnshareStringValue(key->db, key->key, key->value);

    *len = sdslen(key->value->ptr);
    return key->value->ptr;
}",4278.0,4298.0,1.0,28.0,21.0,25,8,16,5,0,11,4,4,3,2,,0,11,6,3,3,char*
4283,175359,RM_StringTruncate,1,RM_StringTruncate,"int RM_StringTruncate (RedisModuleKey*,size_t)",module.c,"int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;
    if (newlen > 512*1024*1024) return REDISMODULE_ERR;

    /* Empty key and new len set to 0. Just return REDISMODULE_OK without
     * doing anything. */
    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;

    if (key->value == NULL) {
        /* Empty key: create it with the new size. */
        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));
        setKey(key->ctx->client,key->db,key->key,o,SETKEY_NO_SIGNAL);
        key->value = o;
        decrRefCount(o);
    } else {
        /* Unshare and resize. */
        key->value = dbUnshareStringValue(key->db, key->key, key->value);
        size_t curlen = sdslen(key->value->ptr);
        if (newlen > curlen) {
            key->value->ptr = sdsgrowzero(key->value->ptr,newlen);
        } else if (newlen < cu...",4312.0,4341.0,1.0,22.0,30.0,25,10,19,4,0,13,6,6,5,4,,0,11,4,2,2,int
4284,175558,moduleListIteratorSeek,1,moduleListIteratorSeek,"int moduleListIteratorSeek (RedisModuleKey*,long,int)",module.c,"int moduleListIteratorSeek(RedisModuleKey *key, long index, int mode) {
    if (!key) {
        errno = EINVAL;
        return 0;
    } else if (!key->value || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return 0;
    } if (!(key->mode & mode)) {
        errno = EBADF;
        return 0;
    }

    long length = listTypeLength(key->value);
    if (index < -length || index >= length) {
        errno = EDOM; /* Invalid index */
        return 0;
    }

    if (key->iter == NULL) {
        /* No existing iterator. Create one. */
        key->iter = listTypeInitIterator(key->value, index, LIST_TAIL);
        serverAssert(key->iter != NULL);
        serverAssert(listTypeNext(key->iter, &key->u.list.entry));
        key->u.list.index = index;
        return 1;
    }

    /* There's an existing iterator. Make sure the requested index has the same
     * sign as the iterator's index. */
    if      (index < 0 && key->u.list.index >= 0) index += length;
    else if (index...",4375.0,4417.0,1.0,50.0,43.0,79,18,44,10,4,26,8,8,5,8,,0,20,6,3,3,int
4285,175843,RM_ListPush,1,RM_ListPush,"int RM_ListPush (RedisModuleKey*,int,robj*)",module.c,"int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
    if (!key || !ele) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key->value != NULL && key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }

    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;
    if (key->iter) moduleFreeKeyIterator(key);
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
    listTypeTryConversionAppend(key->value, &ele, 0, 0, moduleFreeListIterator, key);
    listTypePush(key->value, ele,
        (where == REDISMODULE_LIST_HEAD) ? LIST_HEAD : LIST_TAIL);
    return REDISMODULE_OK;
}",4430.0,4450.0,1.0,48.0,21.0,26,11,21,7,0,12,7,7,6,4,,0,8,6,3,3,int
4286,175994,RM_ListPop,1,RM_ListPop,"robj RM_ListPop (RedisModuleKey*,int)",module.c,"RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
    if (!key) {
        errno = EINVAL;
        return NULL;
    } else if (key->value == NULL || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return NULL;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return NULL;
    }
    if (key->iter) moduleFreeKeyIterator(key);
    robj *ele = listTypePop(key->value,
        (where == REDISMODULE_LIST_HEAD) ? LIST_HEAD : LIST_TAIL);
    robj *decoded = getDecodedObject(ele);
    decrRefCount(ele);
    if (!moduleDelKeyIfEmpty(key))
        listTypeTryConversion(key->value, LIST_CONV_SHRINKING, moduleFreeListIterator, key);
    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);
    return decoded;
}",4464.0,4484.0,1.0,17.0,21.0,11,5,19,8,0,11,4,4,2,7,,0,7,4,2,2,robj
4287,176107,RM_ListGet,1,RM_ListGet,"robj RM_ListGet (RedisModuleKey*,long)",module.c,"RedisModuleString *RM_ListGet(RedisModuleKey *key, long index) {
    if (moduleListIteratorSeek(key, index, REDISMODULE_READ)) {
        robj *elem = listTypeGet(&key->u.list.entry);
        robj *decoded = getDecodedObject(elem);
        decrRefCount(elem);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, decoded);
        return decoded;
    } else {
        return NULL;
    }
}",4503.0,4513.0,1.0,17.0,11.0,8,5,10,4,0,7,2,2,1,5,,0,5,4,2,2,robj
4288,176156,RM_ListSet,1,RM_ListSet,"int RM_ListSet (RedisModuleKey*,long,robj*)",module.c,"int RM_ListSet(RedisModuleKey *key, long index, RedisModuleString *value) {
    if (!value) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    if (!key->value || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    }
    listTypeTryConversionAppend(key->value, &value, 0, 0, moduleFreeListIterator, key);
    if (moduleListIteratorSeek(key, index, REDISMODULE_WRITE)) {
        listTypeReplace(&key->u.list.entry, value);
        /* A note in quicklist.c forbids use of iterator after insert, so
         * probably also after replace. */
        moduleFreeKeyIterator(key);
        return REDISMODULE_OK;
    } else {
        return REDISMODULE_ERR;
    }
}",4530.0,4549.0,1.0,48.0,20.0,16,8,15,6,0,8,4,4,3,4,,0,5,6,3,3,int
4289,176239,RM_ListInsert,1,RM_ListInsert,"int RM_ListInsert (RedisModuleKey*,long,robj*)",module.c,"int RM_ListInsert(RedisModuleKey *key, long index, RedisModuleString *value) {
    if (!value) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key != NULL && key->value == NULL &&
               (index == 0 || index == -1)) {
        /* Insert in empty key => push. */
        return RM_ListPush(key, REDISMODULE_LIST_TAIL, value);
    } else if (key != NULL && key->value != NULL &&
               key->value->type == OBJ_LIST &&
               (index == (long)listTypeLength(key->value) || index == -1)) {
        /* Insert after the last element => push tail. */
        return RM_ListPush(key, REDISMODULE_LIST_TAIL, value);
    } else if (key != NULL && key->value != NULL &&
               key->value->type == OBJ_LIST &&
               (index == 0 || index == -(long)listTypeLength(key->value) - 1)) {
        /* Insert before the first element => push head. */
        return RM_ListPush(key, REDISMODULE_LIST_HEAD, value);
    }
    listTypeTryConversionAppend(ke...",4566.0,4595.0,1.0,51.0,30.0,12,8,14,6,0,6,3,3,1,4,,0,3,6,3,3,int
4290,176432,RM_ListDelete,1,RM_ListDelete,"int RM_ListDelete (RedisModuleKey*,long)",module.c,"int RM_ListDelete(RedisModuleKey *key, long index) {
    if (moduleListIteratorSeek(key, index, REDISMODULE_WRITE)) {
        listTypeDelete(key->iter, &key->u.list.entry);
        if (moduleDelKeyIfEmpty(key)) return REDISMODULE_OK;
        listTypeTryConversion(key->value, LIST_CONV_SHRINKING, moduleFreeListIterator, key);
        if (!key->iter) return REDISMODULE_OK; /* Return ASAP if iterator has been freed */
        if (listTypeNext(key->iter, &key->u.list.entry)) {
            /* After delete entry at position 'index', we need to update
             * 'key->u.list.index' according to the following cases:
             * 1) [1, 2, 3] => dir: forward, index: 0  => [2, 3] => index: still 0
             * 2) [1, 2, 3] => dir: forward, index: -3 => [2, 3] => index: -2
             * 3) [1, 2, 3] => dir: reverse, index: 2  => [1, 2] => index: 1
             * 4) [1, 2, 3] => dir: reverse, index: -1 => [1, 2] => index: still -1 */
            listTypeIterator *li = key->iter;
      ...",4608.0,4635.0,1.0,43.0,28.0,28,10,18,5,0,15,6,11,7,5,,0,13,4,2,2,int
4291,176567,moduleZsetAddFlagsToCoreFlags,1,moduleZsetAddFlagsToCoreFlags,int moduleZsetAddFlagsToCoreFlags (int),module.c,"int moduleZsetAddFlagsToCoreFlags(int flags) {
    int retflags = 0;
    if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_IN_XX;
    if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_IN_NX;
    if (flags & REDISMODULE_ZADD_GT) retflags |= ZADD_IN_GT;
    if (flags & REDISMODULE_ZADD_LT) retflags |= ZADD_IN_LT;
    return retflags;
}",4645.0,4652.0,1.0,16.0,8.0,13,3,10,2,2,0,5,5,0,0,,0,0,2,1,1,int
4292,176642,moduleZsetAddFlagsFromCoreFlags,1,moduleZsetAddFlagsFromCoreFlags,int moduleZsetAddFlagsFromCoreFlags (int),module.c,"int moduleZsetAddFlagsFromCoreFlags(int flags) {
    int retflags = 0;
    if (flags & ZADD_OUT_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
    if (flags & ZADD_OUT_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
    if (flags & ZADD_OUT_NOP) retflags |= REDISMODULE_ZADD_NOP;
    return retflags;
}",4655.0,4661.0,1.0,16.0,7.0,10,3,8,2,2,0,4,4,0,0,,0,0,2,1,1,int
4293,176701,RM_ZsetAdd,1,RM_ZsetAdd,"int RM_ZsetAdd (RedisModuleKey*,double,robj*,int*)",module.c,"int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
    int in_flags = 0, out_flags = 0;
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
    if (flagsptr) in_flags = moduleZsetAddFlagsToCoreFlags(*flagsptr);
    if (zsetAdd(key->value,score,ele->ptr,in_flags,&out_flags,NULL) == 0) {
        if (flagsptr) *flagsptr = 0;
        moduleDelKeyIfEmpty(key);
        return REDISMODULE_ERR;
    }
    if (flagsptr) *flagsptr = moduleZsetAddFlagsFromCoreFlags(out_flags);
    return REDISMODULE_OK;
}",4695.0,4708.0,1.0,50.0,14.0,23,10,23,7,0,10,8,9,6,5,,0,8,8,4,4,int
4294,176813,RM_ZsetIncrby,1,RM_ZsetIncrby,"int RM_ZsetIncrby (RedisModuleKey*,double,robj*,int*,double*)",module.c,"int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
    int in_flags = 0, out_flags = 0;
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
    if (flagsptr) in_flags = moduleZsetAddFlagsToCoreFlags(*flagsptr);
    in_flags |= ZADD_IN_INCR;
    if (zsetAdd(key->value,score,ele->ptr,in_flags,&out_flags,newscore) == 0) {
        if (flagsptr) *flagsptr = 0;
        moduleDelKeyIfEmpty(key);
        return REDISMODULE_ERR;
    }
    if (flagsptr) *flagsptr = moduleZsetAddFlagsFromCoreFlags(out_flags);
    return REDISMODULE_OK;
}",4723.0,4737.0,1.0,53.0,15.0,24,10,24,8,0,10,8,9,6,5,,0,8,10,5,5,int
4295,176933,RM_ZsetRem,1,RM_ZsetRem,"int RM_ZsetRem (RedisModuleKey*,robj*,int*)",module.c,"int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value != NULL && zsetDel(key->value,ele->ptr)) {
        if (deleted) *deleted = 1;
        moduleDelKeyIfEmpty(key);
    } else {
        if (deleted) *deleted = 0;
    }
    return REDISMODULE_OK;
}",4757.0,4767.0,1.0,36.0,11.0,16,8,10,4,0,7,5,6,6,2,,0,6,6,3,3,int
4296,177012,RM_ZsetScore,1,RM_ZsetScore,"int RM_ZsetScore (RedisModuleKey*,robj*,double*)",module.c,"int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
    if (key->value == NULL) return REDISMODULE_ERR;
    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;
    return REDISMODULE_OK;
}",4777.0,4782.0,1.0,38.0,6.0,9,4,6,4,0,4,4,4,4,1,,0,4,6,3,3,int
4297,177148,RM_ZsetRangeEndReached,1,RM_ZsetRangeEndReached,int RM_ZsetRangeEndReached (RedisModuleKey*),module.c,"int RM_ZsetRangeEndReached(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 1;
    return key->u.zset.er;
}",4807.0,4810.0,1.0,43.0,4.0,9,5,3,1,0,3,2,2,2,0,,0,3,2,1,1,int
4298,177179,zsetInitScoreRange,1,zsetInitScoreRange,"int zsetInitScoreRange (RedisModuleKey*,double,double,int,int,int)",module.c,"int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;

    RM_ZsetRangeStop(key);
    key->u.zset.type = REDISMODULE_ZSET_RANGE_SCORE;
    key->u.zset.er = 0;

    /* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */
    zrangespec *zrs = &key->u.zset.rs;
    zrs->min = min;
    zrs->max = max;
    zrs->minex = minex;
    zrs->maxex = maxex;

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        key->u.zset.current = first ? zzlFirstInRange(key->value->ptr,zrs) :
                                      zzlLastInRange(key->value->ptr,zrs);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = key->value->ptr;
        zskiplist *zsl = zs->zsl;
        key->u.zset.current = first ? zslFirstInRange(zsl,zrs) :
                                      zslLastI...",4818.0,4846.0,1.0,43.0,29.0,47,9,25,8,2,18,4,4,4,3,,0,17,12,6,6,int
4299,177374,RM_ZsetFirstInScoreRange,1,RM_ZsetFirstInScoreRange,"int RM_ZsetFirstInScoreRange (RedisModuleKey*,double,double,int,int)",module.c,"int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
    return zsetInitScoreRange(key,min,max,minex,maxex,1);
}",4863.0,4865.0,1.0,1.0,3.0,0,0,5,5,0,1,1,1,0,1,,0,0,10,5,5,int
4300,177391,RM_ZsetLastInScoreRange,1,RM_ZsetLastInScoreRange,"int RM_ZsetLastInScoreRange (RedisModuleKey*,double,double,int,int)",module.c,"int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
    return zsetInitScoreRange(key,min,max,minex,maxex,0);
}",4869.0,4871.0,1.0,1.0,3.0,0,0,5,5,0,1,1,1,0,1,,0,0,10,5,5,int
4301,177408,zsetInitLexRange,1,zsetInitLexRange,"int zsetInitLexRange (RedisModuleKey*,robj*,robj*,int)",module.c,"int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;

    RM_ZsetRangeStop(key);
    key->u.zset.er = 0;

    /* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */
    zlexrangespec *zlrs = &key->u.zset.lrs;
    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;

    /* Set the range type to lex only after successfully parsing the range,
     * otherwise we don't want the zlexrangespec to be freed. */
    key->u.zset.type = REDISMODULE_ZSET_RANGE_LEX;

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        key->u.zset.current = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :
                                      zzlLastInLexRange(key->value->ptr,zlrs);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = key->value->ptr;
     ...",4882.0,4911.0,1.0,42.0,30.0,41,10,20,6,2,15,5,5,5,4,,0,14,8,4,4,int
4302,177596,RM_ZsetFirstInLexRange,1,RM_ZsetFirstInLexRange,"int RM_ZsetFirstInLexRange (RedisModuleKey*,robj*,robj*)",module.c,"int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
    return zsetInitLexRange(key,min,max,1);
}",4925.0,4927.0,1.0,48.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
4303,177609,RM_ZsetLastInLexRange,1,RM_ZsetLastInLexRange,"int RM_ZsetLastInLexRange (RedisModuleKey*,robj*,robj*)",module.c,"int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
    return zsetInitLexRange(key,min,max,0);
}",4931.0,4933.0,1.0,47.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,int
4304,177622,RM_ZsetRangeCurrentElement,1,RM_ZsetRangeCurrentElement,"robj RM_ZsetRangeCurrentElement (RedisModuleKey*,double*)",module.c,"RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
    RedisModuleString *str;

    if (!key->value || key->value->type != OBJ_ZSET) return NULL;
    if (key->u.zset.current == NULL) return NULL;
    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr, *sptr;
        eptr = key->u.zset.current;
        sds ele = lpGetObject(eptr);
        if (score) {
            sptr = lpNext(key->value->ptr,eptr);
            *score = zzlGetScore(sptr);
        }
        str = createObject(OBJ_STRING,ele);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zskiplistNode *ln = key->u.zset.current;
        if (score) *score = ln->score;
        str = createStringObject(ln->ele,sdslen(ln->ele));
    } else {
        serverPanic(""Unsupported zset encoding"");
    }
    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);
    return str;
}",4938.0,4961.0,1.0,17.0,24.0,25,8,22,7,0,12,5,6,4,5,,0,11,4,2,2,robj
4305,177773,RM_ZsetRangeNext,1,RM_ZsetRangeNext,int RM_ZsetRangeNext (RedisModuleKey*),module.c,"int RM_ZsetRangeNext(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 0;
    if (!key->u.zset.type || !key->u.zset.current) return 0; /* No active iterator. */

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = key->value->ptr;
        unsigned char *eptr = key->u.zset.current;
        unsigned char *next;
        next = lpNext(zl,eptr); /* Skip element. */
        if (next) next = lpNext(zl,next); /* Skip score. */
        if (next == NULL) {
            key->u.zset.er = 1;
            return 0;
        } else {
            /* Are we still within the range? */
            if (key->u.zset.type == REDISMODULE_ZSET_RANGE_SCORE) {
                /* Fetch the next element score for the
                 * range check. */
                unsigned char *saved_next = next;
                next = lpNext(zl,next); /* Skip next element. */
                double score = zzlGetScore(next); /* Obtain the next score. */
       ...",4966.0,5025.0,1.0,43.0,60.0,32,7,19,5,0,10,6,8,5,2,,0,10,2,1,1,int
4306,178133,RM_ZsetRangePrev,1,RM_ZsetRangePrev,int RM_ZsetRangePrev (RedisModuleKey*),module.c,"int RM_ZsetRangePrev(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 0;
    if (!key->u.zset.type || !key->u.zset.current) return 0; /* No active iterator. */

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = key->value->ptr;
        unsigned char *eptr = key->u.zset.current;
        unsigned char *prev;
        prev = lpPrev(zl,eptr); /* Go back to previous score. */
        if (prev) prev = lpPrev(zl,prev); /* Back to previous ele. */
        if (prev == NULL) {
            key->u.zset.er = 1;
            return 0;
        } else {
            /* Are we still within the range? */
            if (key->u.zset.type == REDISMODULE_ZSET_RANGE_SCORE) {
                /* Fetch the previous element score for the
                 * range check. */
                unsigned char *saved_prev = prev;
                prev = lpNext(zl,prev); /* Skip element to get the score.*/
                double score = zzlGetScore(prev)...",5030.0,5089.0,1.0,43.0,60.0,32,7,19,5,0,10,6,8,5,2,,0,10,2,1,1,int
4307,178489,RM_HashSet,1,RM_HashSet,"int RM_HashSet (RedisModuleKey*,int...)",module.c,"int RM_HashSet(RedisModuleKey *key, int flags, ...) {
    va_list ap;
    if (!key || (flags & ~(REDISMODULE_HASH_NX |
                           REDISMODULE_HASH_XX |
                           REDISMODULE_HASH_CFIELDS |
                           REDISMODULE_HASH_COUNT_ALL))) {
        errno = EINVAL;
        return 0;
    } else if (key->value && key->value->type != OBJ_HASH) {
        errno = ENOTSUP;
        return 0;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return 0;
    }
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);

    int count = 0;
    va_start(ap, flags);
    while(1) {
        RedisModuleString *field, *value;
        /* Get the field and value objects. */
        if (flags & REDISMODULE_HASH_CFIELDS) {
            char *cfield = va_arg(ap,char*);
            if (cfield == NULL) break;
            field = createRawStringObject(cfield,strlen(cfield));
        } else {
            field = va_arg(a...",5164.0,5237.0,1.0,27.0,74.0,65,14,58,15,0,15,17,28,1,10,,0,8,4,2,2,int
4308,178811,RM_HashGet,1,RM_HashGet,"int RM_HashGet (RedisModuleKey*,int...)",module.c,"int RM_HashGet(RedisModuleKey *key, int flags, ...) {
    va_list ap;
    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;

    va_start(ap, flags);
    while(1) {
        RedisModuleString *field, **valueptr;
        int *existsptr;
        /* Get the field object and the value pointer to pointer. */
        if (flags & REDISMODULE_HASH_CFIELDS) {
            char *cfield = va_arg(ap,char*);
            if (cfield == NULL) break;
            field = createRawStringObject(cfield,strlen(cfield));
        } else {
            field = va_arg(ap,RedisModuleString*);
            if (field == NULL) break;
        }

        /* Query the hash for existence or value object. */
        if (flags & REDISMODULE_HASH_EXISTS) {
            existsptr = va_arg(ap,int*);
            if (key->value)
                *existsptr = hashTypeExists(key->value,field->ptr);
            else
                *existsptr = 0;
        } else {
            valueptr = va_arg(ap,RedisModuleSt...",5280.0,5326.0,1.0,42.0,47.0,18,8,18,7,0,7,9,15,3,3,,0,6,4,2,2,int
4309,178979,RM_StreamAdd,1,RM_StreamAdd,"int RM_StreamAdd (RedisModuleKey*,int,RedisModuleStreamID*,robj**,long)",module.c,"int RM_StreamAdd(RedisModuleKey *key, int flags, RedisModuleStreamID *id, RedisModuleString **argv, long numfields) {
    /* Validate args */
    if (!key || (numfields != 0 && !argv) || /* invalid key or argv */
        (flags & ~(REDISMODULE_STREAM_ADD_AUTOID)) || /* invalid flags */
        (!(flags & REDISMODULE_STREAM_ADD_AUTOID) && !id)) { /* id required */
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key->value && key->value->type != OBJ_STREAM) {
        errno = ENOTSUP; /* wrong type */
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF; /* key not open for writing */
        return REDISMODULE_ERR;
    } else if (!(flags & REDISMODULE_STREAM_ADD_AUTOID) &&
               id->ms == 0 && id->seq == 0) {
        errno = EDOM; /* ID out of range */
        return REDISMODULE_ERR;
    }

    /* Create key if necessary */
    int created = 0;
    if (key->value == NULL) {
        moduleCreateEmptyKey...",5369.0,5428.0,1.0,74.0,60.0,58,13,45,15,0,16,9,10,4,3,,0,14,10,5,5,int
4310,179248,RM_StreamDelete,1,RM_StreamDelete,"int RM_StreamDelete (RedisModuleKey*,RedisModuleStreamID*)",module.c,"int RM_StreamDelete(RedisModuleKey *key, RedisModuleStreamID *id) {
    if (!key || !id) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP; /* wrong type */
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE) ||
               key->iter != NULL) {
        errno = EBADF; /* key not opened for writing or iterator started */
        return REDISMODULE_ERR;
    }
    stream *s = key->value->ptr;
    streamID streamid = {id->ms, id->seq};
    if (streamDeleteItem(s, &streamid)) {
        return REDISMODULE_OK;
    } else {
        errno = ENOENT; /* no entry with this id */
        return REDISMODULE_ERR;
    }
}",5448.0,5468.0,1.0,15.0,21.0,12,6,11,6,0,4,3,3,1,1,,0,4,4,2,2,int
4311,179357,RM_StreamIteratorStart,1,RM_StreamIteratorStart,"int RM_StreamIteratorStart (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleStreamID*)",module.c,"int RM_StreamIteratorStart(RedisModuleKey *key, int flags, RedisModuleStreamID *start, RedisModuleStreamID *end) {
    /* check args */
    if (!key ||
        (flags & ~(REDISMODULE_STREAM_ITERATOR_EXCLUSIVE |
                   REDISMODULE_STREAM_ITERATOR_REVERSE))) {
        errno = EINVAL; /* key missing or invalid flags */
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR; /* not a stream */
    } else if (key->iter) {
        errno = EBADF; /* iterator already started */
        return REDISMODULE_ERR;
    }

    /* define range for streamIteratorStart() */
    streamID lower, upper;
    if (start) lower = (streamID){start->ms, start->seq};
    if (end)   upper = (streamID){end->ms,   end->seq};
    if (flags & REDISMODULE_STREAM_ITERATOR_EXCLUSIVE) {
        if ((start && streamIncrID(&lower) != C_OK) ||
            (end   && streamDecrID(&upper) != C_OK)) {
            errno...",5519.0,5556.0,1.0,19.0,38.0,57,17,39,13,0,13,6,7,2,4,,0,12,8,4,4,int
4312,179576,RM_StreamIteratorStop,1,RM_StreamIteratorStop,int RM_StreamIteratorStop (RedisModuleKey*),module.c,"int RM_StreamIteratorStop(RedisModuleKey *key) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }
    streamIteratorStop(key->iter);
    zfree(key->iter);
    key->iter = NULL;
    return REDISMODULE_OK;
}",5570.0,5585.0,1.0,15.0,16.0,6,3,7,4,0,5,2,2,0,2,,0,3,2,1,1,int
4313,179649,RM_StreamIteratorNextID,1,RM_StreamIteratorNextID,"int RM_StreamIteratorNextID (RedisModuleKey*,RedisModuleStreamID*,long*)",module.c,"int RM_StreamIteratorNextID(RedisModuleKey *key, RedisModuleStreamID *id, long *numfields) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    int64_t *num_ptr = &key->u.stream.numfieldsleft;
    streamID *streamid_ptr = &key->u.stream.currentid;
    if (streamIteratorGetID(si, streamid_ptr, num_ptr)) {
        if (id) {
            id->ms = streamid_ptr->ms;
            id->seq = streamid_ptr->seq;
        }
        if (numfields) *numfields = *num_ptr;
        return REDISMODULE_OK;
    } else {
        /* No entry found. */
        key->u.stream.currentid.ms = 0; /* for RM_StreamIteratorDelete() */
        key->u.stream.currentid.seq = 0;
        key->u.stream.numfieldsleft = 0; /* for RM_StreamIteratorNextField...",5612.0,5641.0,1.0,15.0,30.0,23,6,20,8,0,8,5,7,1,1,,0,8,6,3,3,int
4314,179810,RM_StreamIteratorNextField,1,RM_StreamIteratorNextField,"int RM_StreamIteratorNextField (RedisModuleKey*,robj**,robj**)",module.c,"int RM_StreamIteratorNextField(RedisModuleKey *key, RedisModuleString **field_ptr, RedisModuleString **value_ptr) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    } else if (key->u.stream.numfieldsleft <= 0) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    unsigned char *field, *value;
    int64_t field_len, value_len;
    streamIteratorGetField(si, &field, &value, &field_len, &value_len);
    if (field_ptr) {
        *field_ptr = createRawStringObject((char *)field, field_len);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, *field_ptr);
    }
    if (value_ptr) {
        *value_ptr = createRawStringObject((char *)value, value_len);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, *val...",5668.0,5696.0,1.0,52.0,29.0,22,8,23,10,0,9,4,4,0,5,,0,6,6,3,3,int
4315,179960,RM_StreamIteratorDelete,1,RM_StreamIteratorDelete,int RM_StreamIteratorDelete (RedisModuleKey*),module.c,"int RM_StreamIteratorDelete(RedisModuleKey *key) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE) || !key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    } else if (key->u.stream.currentid.ms == 0 &&
               key->u.stream.currentid.seq == 0) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    streamIteratorRemoveEntry(si, &key->u.stream.currentid);
    key->u.stream.currentid.ms = 0; /* Make sure repeated Delete() fails */
    key->u.stream.currentid.seq = 0;
    key->u.stream.numfieldsleft = 0; /* Make sure NextField() fails */
    return REDISMODULE_OK;
}",5711.0,5732.0,1.0,15.0,22.0,22,5,10,4,0,6,2,2,0,1,,0,5,2,1,1,int
4316,180112,RM_StreamTrimByLength,1,RM_StreamTrimByLength,"long long RM_StreamTrimByLength (RedisModuleKey*,int,long long)",module.c,"long long RM_StreamTrimByLength(RedisModuleKey *key, int flags, long long length) {
    if (!key || (flags & ~(REDISMODULE_STREAM_TRIM_APPROX)) || length < 0) {
        errno = EINVAL;
        return -1;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return -1;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return -1;
    }
    int approx = flags & REDISMODULE_STREAM_TRIM_APPROX ? 1 : 0;
    return streamTrimByLength((stream *)key->value->ptr, length, approx);
}",5749.0,5762.0,1.0,27.0,14.0,16,11,10,6,0,2,2,2,0,1,,0,1,6,3,3,long long
4317,180210,RM_StreamTrimByID,1,RM_StreamTrimByID,"long long RM_StreamTrimByID (RedisModuleKey*,int,RedisModuleStreamID*)",module.c,"long long RM_StreamTrimByID(RedisModuleKey *key, int flags, RedisModuleStreamID *id) {
    if (!key || (flags & ~(REDISMODULE_STREAM_TRIM_APPROX)) || !id) {
        errno = EINVAL;
        return -1;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return -1;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return -1;
    }
    int approx = flags & REDISMODULE_STREAM_TRIM_APPROX ? 1 : 0;
    streamID minid = (streamID){id->ms, id->seq};
    return streamTrimByID((stream *)key->value->ptr, minid, approx);
}",5779.0,5793.0,1.0,27.0,15.0,21,11,13,7,0,4,2,2,0,1,,0,3,6,3,3,long long
4318,180319,moduleParseCallReply_Int,1,moduleParseCallReply_Int,void moduleParseCallReply_Int (RedisModuleCallReply*),module.c,void moduleParseCallReply_Int(RedisModuleCallReply *reply);,5802.0,5802.0,6.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4319,180324,moduleParseCallReply_BulkString,1,moduleParseCallReply_BulkString,void moduleParseCallReply_BulkString (RedisModuleCallReply*),module.c,void moduleParseCallReply_BulkString(RedisModuleCallReply *reply);,5803.0,5803.0,6.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4320,180329,moduleParseCallReply_SimpleString,1,moduleParseCallReply_SimpleString,void moduleParseCallReply_SimpleString (RedisModuleCallReply*),module.c,void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);,5804.0,5804.0,6.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4321,180334,moduleParseCallReply_Array,1,moduleParseCallReply_Array,void moduleParseCallReply_Array (RedisModuleCallReply*),module.c,void moduleParseCallReply_Array(RedisModuleCallReply *reply);,5805.0,5805.0,6.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4322,180385,RM_CallReplyType,1,RM_CallReplyType,int RM_CallReplyType (RedisModuleCallReply*),module.c,"int RM_CallReplyType(RedisModuleCallReply *reply) {
    return callReplyType(reply);
}",5848.0,5850.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
4323,180393,RM_CallReplyLength,1,RM_CallReplyLength,size_t RM_CallReplyLength (RedisModuleCallReply*),module.c,"size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
    return callReplyGetLen(reply);
}",5853.0,5855.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
4324,180401,RM_CallReplyArrayElement,1,RM_CallReplyArrayElement,"RedisModuleCallReply RM_CallReplyArrayElement (RedisModuleCallReply*,size_t)",module.c,"RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
    return callReplyGetArrayElement(reply, idx);
}",5859.0,5861.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,RedisModuleCallReply
4325,180411,RM_CallReplyInteger,1,RM_CallReplyInteger,long long RM_CallReplyInteger (RedisModuleCallReply*),module.c,"long long RM_CallReplyInteger(RedisModuleCallReply *reply) {
    return callReplyGetLongLong(reply);
}",5864.0,5866.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,long long
4326,180419,RM_CallReplyDouble,1,RM_CallReplyDouble,double RM_CallReplyDouble (RedisModuleCallReply*),module.c,"double RM_CallReplyDouble(RedisModuleCallReply *reply) {
    return callReplyGetDouble(reply);
}",5869.0,5871.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,double
4327,180427,RM_CallReplyBigNumber,1,RM_CallReplyBigNumber,"const char* RM_CallReplyBigNumber (RedisModuleCallReply*,size_t*)",module.c,"const char *RM_CallReplyBigNumber(RedisModuleCallReply *reply, size_t *len) {
    return callReplyGetBigNumber(reply, len);
}",5874.0,5876.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,const char*
4328,180437,RM_CallReplyVerbatim,1,RM_CallReplyVerbatim,"const char* RM_CallReplyVerbatim (RedisModuleCallReply*,size_t*,char**)",module.c,"const char *RM_CallReplyVerbatim(RedisModuleCallReply *reply, size_t *len, const char **format) {
    return callReplyGetVerbatim(reply, len, format);
}",5880.0,5882.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,const char*
4329,180449,RM_CallReplyBool,1,RM_CallReplyBool,int RM_CallReplyBool (RedisModuleCallReply*),module.c,"int RM_CallReplyBool(RedisModuleCallReply *reply) {
    return callReplyGetBool(reply);
}",5885.0,5887.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
4330,180457,RM_CallReplySetElement,1,RM_CallReplySetElement,"RedisModuleCallReply RM_CallReplySetElement (RedisModuleCallReply*,size_t)",module.c,"RedisModuleCallReply *RM_CallReplySetElement(RedisModuleCallReply *reply, size_t idx) {
    return callReplyGetSetElement(reply, idx);
}",5891.0,5893.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,RedisModuleCallReply
4331,180467,RM_CallReplyMapElement,1,RM_CallReplyMapElement,"int RM_CallReplyMapElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)",module.c,"int RM_CallReplyMapElement(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) {
    if (callReplyGetMapElement(reply, idx, key, val) == C_OK){
        return REDISMODULE_OK;
    }
    return REDISMODULE_ERR;
}",5903.0,5908.0,1.0,56.0,6.0,1,1,4,4,0,1,2,2,1,1,,0,1,8,4,4,int
4332,180494,RM_CallReplyAttribute,1,RM_CallReplyAttribute,RedisModuleCallReply RM_CallReplyAttribute (RedisModuleCallReply*),module.c,"RedisModuleCallReply *RM_CallReplyAttribute(RedisModuleCallReply *reply) {
    return callReplyGetAttribute(reply);
}",5911.0,5913.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,RedisModuleCallReply
4333,180502,RM_CallReplyAttributeElement,1,RM_CallReplyAttributeElement,"int RM_CallReplyAttributeElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)",module.c,"int RM_CallReplyAttributeElement(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) {
    if (callReplyGetAttributeElement(reply, idx, key, val) == C_OK){
        return REDISMODULE_OK;
    }
    return REDISMODULE_ERR;
}",5923.0,5928.0,1.0,62.0,6.0,1,1,4,4,0,1,2,2,1,1,,0,1,8,4,4,int
4334,180529,RM_CallReplyPromiseSetUnblockHandler,1,RM_CallReplyPromiseSetUnblockHandler,"void RM_CallReplyPromiseSetUnblockHandler (RedisModuleCallReply*,RedisModuleOnUnblocked,void*)",module.c,"void RM_CallReplyPromiseSetUnblockHandler(RedisModuleCallReply *reply, RedisModuleOnUnblocked on_unblock, void *private_data) {
    RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
    promise->on_unblocked = on_unblock;
    promise->private_data = private_data;
}",5932.0,5936.0,1.0,1.0,5.0,5,2,6,4,0,3,1,1,0,1,,0,3,6,3,3,void
4335,180551,RM_CallReplyPromiseAbort,1,RM_CallReplyPromiseAbort,"int RM_CallReplyPromiseAbort (RedisModuleCallReply*,void**)",module.c,"int RM_CallReplyPromiseAbort(RedisModuleCallReply *reply, void **private_data) {
    RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
    if (!promise->c) return REDISMODULE_ERR; /* Promise can not be aborted, either already aborted or already finished. */
    if (!(promise->c->flags & CLIENT_BLOCKED)) return REDISMODULE_ERR; /* Client is not blocked anymore, can not abort it. */

    /* Client is still blocked, remove it from any blocking state and release it. */
    if (private_data) *private_data = promise->private_data;
    promise->private_data = NULL;
    promise->on_unblocked = NULL;
    unblockClient(promise->c, 0);
    moduleReleaseTempClient(promise->c);
    return REDISMODULE_OK;
}",5949.0,5961.0,1.0,28.0,13.0,17,6,13,4,0,10,4,4,2,3,,0,8,4,2,2,int
4336,180622,RM_CallReplyStringPtr,1,RM_CallReplyStringPtr,"const char* RM_CallReplyStringPtr (RedisModuleCallReply*,size_t*)",module.c,"const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
    size_t private_len;
    if (!len) len = &private_len;
    return callReplyGetString(reply, len);
}",5964.0,5968.0,1.0,1.0,5.0,3,3,5,3,0,1,2,2,0,1,,0,0,4,2,2,const char*
4337,180641,RM_CreateStringFromCallReply,1,RM_CreateStringFromCallReply,robj RM_CreateStringFromCallReply (RedisModuleCallReply*),module.c,"RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
    RedisModuleCtx* ctx = callReplyGetPrivateData(reply);
    size_t len;
    const char *str;
    switch(callReplyType(reply)) {
        case REDISMODULE_REPLY_STRING:
        case REDISMODULE_REPLY_ERROR:
            str = callReplyGetString(reply, &len);
            return RM_CreateString(ctx, str, len);
        case REDISMODULE_REPLY_INTEGER: {
            char buf[64];
            int len = ll2string(buf,sizeof(buf),callReplyGetLongLong(reply));
            return RM_CreateString(ctx ,buf,len);
            }
        default:
            return NULL;
    }
}",5972.0,5989.0,1.0,17.0,18.0,5,3,17,6,0,7,2,2,1,7,,0,5,2,1,1,robj
4338,180699,RM_SetContextUser,1,RM_SetContextUser,"void RM_SetContextUser (RedisModuleCtx*,RedisModuleUser*)",module.c,"void RM_SetContextUser(RedisModuleCtx *ctx, const RedisModuleUser *user) {
    ctx->user = user;
}",5992.0,5994.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
4339,181178,RM_Call,1,RM_Call,"RedisModuleCallReply RM_Call (RedisModuleCtx*,char*,char*...)",module.c,"RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    client *c = NULL;
    robj **argv = NULL;
    int argc = 0, flags = 0;
    va_list ap;
    RedisModuleCallReply *reply = NULL;
    int replicate = 0; /* Replicate this command? */
    int error_as_call_replies = 0; /* return errors as RedisModuleCallReply object */
    uint64_t cmd_flags;

    /* Handle arguments. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    replicate = flags & REDISMODULE_ARGV_REPLICATE;
    error_as_call_replies = flags & REDISMODULE_ARGV_CALL_REPLIES_AS_ERRORS;
    va_end(ap);

    c = moduleAllocTempClient();

    if (!(flags & REDISMODULE_ARGV_ALLOW_BLOCK)) {
        /* We do not want to allow block, the module do not expect it */
        c->flags |= CLIENT_DENY_BLOCKING;
    }
    c->db = ctx->client->db;
    c->argv = argv;
    /* We have to assign argv_len, which is equal to argc in that case (RM_Call)
 ...",6206.0,6509.0,1.0,24.0,304.0,291,23,283,44,0,101,65,104,13,51,,0,94,6,3,3,RedisModuleCallReply
4340,182341,RM_CallReplyProto,1,RM_CallReplyProto,"const char* RM_CallReplyProto (RedisModuleCallReply*,size_t*)",module.c,"const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
    return callReplyGetProto(reply, len);
}",6513.0,6515.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,const char*
4341,182355,moduleTypeEncodeId,1,moduleTypeEncodeId,"uint64_t moduleTypeEncodeId (char*,int)",module.c,"uint64_t moduleTypeEncodeId(const char *name, int encver) {
    /* We use 64 symbols so that we can map each character into 6 bits
     * of the final output. */
    const char *cset = ModuleTypeNameCharSet;
    if (strlen(name) != 9) return 0;
    if (encver < 0 || encver > 1023) return 0;

    uint64_t id = 0;
    for (int j = 0; j < 9; j++) {
        char *p = strchr(cset,name[j]);
        if (!p) return 0;
        unsigned long pos = p-cset;
        id = (id << 6) | pos;
    }
    id = (id << 10) | encver;
    return id;
}",6555.0,6571.0,1.0,1.0,17.0,19,10,23,8,3,1,5,6,0,0,,0,1,4,2,2,uint64_t
4342,182436,moduleTypeLookupModuleByNameInternal,1,moduleTypeLookupModuleByNameInternal,"moduleType moduleTypeLookupModuleByNameInternal (char*,int)",module.c,"moduleType *moduleTypeLookupModuleByNameInternal(const char *name, int ignore_case) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *mt = ln->value;
            if ((!ignore_case && memcmp(name,mt->name,sizeof(mt->name)) == 0)
                || (ignore_case && !strcasecmp(name, mt->name)))
            {
                dictReleaseIterator(di);
                return mt;
            }
        }
    }
    dictReleaseIterator(di);
    return NULL;
}",6576.0,6598.0,1.0,1.0,23.0,20,9,24,10,2,10,4,7,2,7,,0,7,4,2,2,moduleType
4343,182515,moduleTypeLookupModuleByName,1,moduleTypeLookupModuleByName,moduleType moduleTypeLookupModuleByName (char*),module.c,"moduleType *moduleTypeLookupModuleByName(const char *name) {
    return moduleTypeLookupModuleByNameInternal(name, 0);
}",6600.0,6602.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,moduleType
4344,182524,moduleTypeLookupModuleByNameIgnoreCase,1,moduleTypeLookupModuleByNameIgnoreCase,moduleType moduleTypeLookupModuleByNameIgnoreCase (char*),module.c,"moduleType *moduleTypeLookupModuleByNameIgnoreCase(const char *name) {
    return moduleTypeLookupModuleByNameInternal(name, 1);
}",6605.0,6607.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,moduleType
4345,182533,moduleTypeLookupModuleByID,1,moduleTypeLookupModuleByID,moduleType moduleTypeLookupModuleByID (uint64_t),module.c,"moduleType *moduleTypeLookupModuleByID(uint64_t id) {
    static struct {
        uint64_t id;
        moduleType *mt;
    } cache[MODULE_LOOKUP_CACHE_SIZE];

    /* Search in cache to start. */
    int j;
    for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)
        if (cache[j].id == id) return cache[j].mt;

    /* Slow module by module lookup. */
    moduleType *mt = NULL;
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL && mt == NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *this_mt = ln->value;
            /* Compare only the 54 bit module identifier and not the
             * encoding version. */
            if (this_mt->id >> 10 == id >> 10) {
                mt = this_mt;
                break;
            }
        }
    }
    dictReleaseIt...",6614.0,6654.0,1.0,12.0,41.0,32,10,36,12,0,9,7,9,2,6,,0,7,2,1,1,moduleType
4346,182665,moduleTypeNameByID,1,moduleTypeNameByID,"void moduleTypeNameByID (char*,uint64_t)",module.c,"void moduleTypeNameByID(char *name, uint64_t moduleid) {
    const char *cset = ModuleTypeNameCharSet;

    name[9] = '\0';
    char *p = name+8;
    moduleid >>= 10;
    for (int j = 0; j < 9; j++) {
        *p-- = cset[moduleid & 63];
        moduleid >>= 6;
    }
}",6660.0,6670.0,1.0,1.0,11.0,12,7,12,6,0,1,2,2,0,0,,0,1,4,2,2,void
4347,182713,moduleTypeModuleName,1,moduleTypeModuleName,const char* moduleTypeModuleName (moduleType*),module.c,"const char *moduleTypeModuleName(moduleType *mt) {
    if (!mt || !mt->module) return NULL;
    return mt->module->name;
}",6673.0,6676.0,1.0,1.0,4.0,6,3,4,2,0,0,2,2,0,0,,0,0,2,1,1,const char*
4348,182735,moduleNameFromCommand,1,moduleNameFromCommand,const char* moduleNameFromCommand (redisCommand*),module.c,"const char *moduleNameFromCommand(struct redisCommand *cmd) {
    serverAssert(cmd->proc == RedisModuleCommandDispatcher);

    RedisModuleCommand *cp = cmd->module_cmd;
    return cp->module->name;
}",6679.0,6684.0,1.0,4.0,6.0,10,7,4,2,1,4,1,1,0,1,,0,3,2,1,1,const char*
4349,182770,moduleTypeDupOrReply,1,moduleTypeDupOrReply,"robj moduleTypeDupOrReply (client*,robj*,robj*,int,robj*)",module.c,"robj *moduleTypeDupOrReply(client *c, robj *fromkey, robj *tokey, int todb, robj *value) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;
    if (!mt->copy && !mt->copy2) {
        addReplyError(c, ""not supported for this module key"");
        return NULL;
    }
    void *newval = NULL;
    if (mt->copy2 != NULL) {
        RedisModuleKeyOptCtx ctx = {fromkey, tokey, c->db->id, todb};
        newval = mt->copy2(&ctx, mv->value);
    } else {
        newval = mt->copy(fromkey, tokey, mv->value);
    }
     
    if (!newval) {
        addReplyError(c, ""module key failed to copy"");
        return NULL;
    }
    return createModuleObject(mt, newval);
}",6689.0,6709.0,1.0,1.0,21.0,21,7,26,10,1,6,4,4,0,3,,0,3,10,5,5,robj
4350,182867,RM_CreateDataType,1,RM_CreateDataType,"moduleType RM_CreateDataType (RedisModuleCtx*,char*,int,void*)",module.c,"moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
    if (!ctx->module->onload)
        return NULL;
    uint64_t id = moduleTypeEncodeId(name,encver);
    if (id == 0) return NULL;
    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;

    long typemethods_version = ((long*)typemethods_ptr)[0];
    if (typemethods_version == 0) return NULL;

    struct typemethods {
        uint64_t version;
        moduleTypeLoadFunc rdb_load;
        moduleTypeSaveFunc rdb_save;
        moduleTypeRewriteFunc aof_rewrite;
        moduleTypeMemUsageFunc mem_usage;
        moduleTypeDigestFunc digest;
        moduleTypeFreeFunc free;
        struct {
            moduleTypeAuxLoadFunc aux_load;
            moduleTypeAuxSaveFunc aux_save;
            int aux_save_triggers;
        } v2;
        struct {
            moduleTypeFreeEffortFunc free_effort;
            moduleTypeUnlinkFunc unlink;
            moduleTypeCopyFunc copy;
      ...",6832.0,6904.0,1.0,1.0,73.0,99,11,68,9,0,7,9,9,2,4,,0,6,8,4,4,moduleType
4351,183142,RM_ModuleTypeSetValue,1,RM_ModuleTypeSetValue,"int RM_ModuleTypeSetValue (RedisModuleKey*,moduleType*,void*)",module.c,"int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
    RM_DeleteKey(key);
    robj *o = createModuleObject(mt,value);
    setKey(key->ctx->client,key->db,key->key,o,SETKEY_NO_SIGNAL);
    decrRefCount(o);
    key->value = o;
    return REDISMODULE_OK;
}",6910.0,6918.0,1.0,22.0,9.0,13,6,13,4,0,10,2,2,2,4,,0,7,6,3,3,int
4352,183204,RM_ModuleTypeGetType,1,RM_ModuleTypeGetType,moduleType RM_ModuleTypeGetType (RedisModuleKey*),module.c,"moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
    if (key == NULL ||
        key->value == NULL ||
        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
    moduleValue *mv = key->value->ptr;
    return mv->type;
}",6925.0,6931.0,1.0,27.0,7.0,10,5,9,3,0,4,2,2,2,1,,0,4,2,1,1,moduleType
4353,183241,RM_ModuleTypeGetValue,1,RM_ModuleTypeGetValue,void* RM_ModuleTypeGetValue (RedisModuleKey*),module.c,"void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
    if (key == NULL ||
        key->value == NULL ||
        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
    moduleValue *mv = key->value->ptr;
    return mv->value;
}",6939.0,6945.0,1.0,27.0,7.0,10,5,9,3,0,4,2,2,2,1,,0,4,2,1,1,void*
4354,183278,moduleRDBLoadError,1,moduleRDBLoadError,void moduleRDBLoadError (RedisModuleIO*),module.c,"void moduleRDBLoadError(RedisModuleIO *io) {
    if (io->type->module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS) {
        io->error = 1;
        return;
    }
    serverPanic(
        ""Error loading data from RDB (short read or EOF). ""
        ""Read performed by module '%s' about type '%s' ""
        ""after reading '%llu' bytes of a value ""
        ""for key named: '%s'."",
        io->type->module->name,
        io->type->name,
        (unsigned long long)io->bytes,
        io->key? (char*)io->key->ptr: ""(null)"");
}",6954.0,6968.0,1.0,36.0,15.0,20,7,7,1,4,8,2,2,1,1,,0,7,2,1,1,void
4355,183341,moduleAllDatatypesHandleErrors,1,moduleAllDatatypesHandleErrors,int moduleAllDatatypesHandleErrors (void),module.c,"int moduleAllDatatypesHandleErrors(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (listLength(module->types) &&
            !(module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS))
        {
            dictReleaseIterator(di);
            return 0;
        }
    }
    dictReleaseIterator(di);
    return 1;
}",6973.0,6988.0,1.0,12.0,16.0,12,7,12,5,1,9,3,4,4,5,,0,7,2,1,1,int
4356,183396,moduleAllModulesHandleReplAsyncLoad,1,moduleAllModulesHandleReplAsyncLoad,int moduleAllModulesHandleReplAsyncLoad (void),module.c,"int moduleAllModulesHandleReplAsyncLoad(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!(module->options & REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD)) {
            dictReleaseIterator(di);
            return 0;
        }
    }
    dictReleaseIterator(di);
    return 1;
}",6993.0,7006.0,1.0,32.0,14.0,8,6,10,5,0,7,3,4,2,5,,0,5,2,1,1,int
4357,183440,RM_IsIOError,1,RM_IsIOError,int RM_IsIOError (RedisModuleIO*),module.c,"int RM_IsIOError(RedisModuleIO *io) {
    return io->error;
}",7011.0,7013.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4358,183449,flushRedisModuleIOBuffer,1,flushRedisModuleIOBuffer,int flushRedisModuleIOBuffer (RedisModuleIO*),module.c,"static int flushRedisModuleIOBuffer(RedisModuleIO *io) {
    if (!io->pre_flush_buffer) return 0;

    /* We have data that must be flushed before saving the current data.
     * Lets flush it. */
    sds pre_flush_buffer = io->pre_flush_buffer;
    io->pre_flush_buffer = NULL;
    ssize_t retval = rdbWriteRaw(io->rio, pre_flush_buffer, sdslen(pre_flush_buffer));
    sdsfree(pre_flush_buffer);
    if (retval >= 0) io->bytes += retval;
    return retval;
}",7015.0,7026.0,1.0,1.0,12.0,11,5,14,4,5,8,3,3,1,3,,0,7,2,1,1,int
4359,183497,RM_SaveUnsigned,1,RM_SaveUnsigned,"void RM_SaveUnsigned (RedisModuleIO*,uint64_t)",module.c,"void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveLen(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7031.0,7046.0,1.0,37.0,16.0,17,5,14,3,1,9,8,5,2,3,,0,9,4,2,2,void
4360,183565,RM_LoadUnsigned,1,RM_LoadUnsigned,uint64_t RM_LoadUnsigned (RedisModuleIO*),module.c,"uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;
    uint64_t value;
    int retval = rdbLoadLenByRef(io->rio, NULL, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",7051.0,7063.0,1.0,18.0,13.0,9,6,12,5,1,6,6,4,1,3,,0,5,2,1,1,uint64_t
4361,183618,RM_SaveSigned,1,RM_SaveSigned,"void RM_SaveSigned (RedisModuleIO*,int64_t)",module.c,"void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
    union {uint64_t u; int64_t i;} conv;
    conv.i = value;
    RM_SaveUnsigned(io,conv.u);
}",7066.0,7070.0,1.0,1.0,5.0,3,2,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
4362,183635,RM_LoadSigned,1,RM_LoadSigned,int64_t RM_LoadSigned (RedisModuleIO*),module.c,"int64_t RM_LoadSigned(RedisModuleIO *io) {
    union {uint64_t u; int64_t i;} conv;
    conv.u = RM_LoadUnsigned(io);
    return conv.i;
}",7073.0,7077.0,1.0,1.0,5.0,3,2,3,2,0,1,1,1,0,1,,0,1,2,1,1,int64_t
4363,183651,RM_SaveString,1,RM_SaveString,"void RM_SaveString (RedisModuleIO*,robj*)",module.c,"void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveStringObject(io->rio, s);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7085.0,7100.0,1.0,38.0,16.0,17,5,14,3,0,9,8,5,2,3,,0,9,4,2,2,void
4364,183719,RM_SaveStringBuffer,1,RM_SaveStringBuffer,"void RM_SaveStringBuffer (RedisModuleIO*,char*,size_t)",module.c,"void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7104.0,7119.0,1.0,41.0,16.0,18,6,15,4,1,9,8,5,2,3,,0,9,6,3,3,void
4365,183791,moduleLoadString,1,moduleLoadString,"void* moduleLoadString (RedisModuleIO*,int,size_t*)",module.c,"void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
    if (io->error) return NULL;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;
    void *s = rdbGenericLoadStringObject(io->rio,
              plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
    if (s == NULL) goto loaderr;
    return s;

loaderr:
    moduleRDBLoadError(io);
    return NULL;
}",7122.0,7134.0,1.0,18.0,13.0,9,6,15,6,2,6,6,4,1,3,,0,5,6,3,3,void*
4366,183852,RM_LoadString,1,RM_LoadString,robj RM_LoadString (RedisModuleIO*),module.c,"RedisModuleString *RM_LoadString(RedisModuleIO *io) {
    return moduleLoadString(io,0,NULL);
}",7145.0,7147.0,1.0,17.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,robj
4367,183862,RM_LoadStringBuffer,1,RM_LoadStringBuffer,"char* RM_LoadStringBuffer (RedisModuleIO*,size_t*)",module.c,"char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
    return moduleLoadString(io,1,lenptr);
}",7156.0,7158.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,char*
4368,183873,RM_SaveDouble,1,RM_SaveDouble,"void RM_SaveDouble (RedisModuleIO*,double)",module.c,"void RM_SaveDouble(RedisModuleIO *io, double value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveBinaryDoubleValue(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7163.0,7178.0,1.0,37.0,16.0,17,5,14,3,0,9,8,5,2,3,,0,9,4,2,2,void
4369,183941,RM_LoadDouble,1,RM_LoadDouble,double RM_LoadDouble (RedisModuleIO*),module.c,"double RM_LoadDouble(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;
    double value;
    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",7182.0,7194.0,1.0,18.0,13.0,9,6,11,5,0,6,6,4,1,3,,0,5,2,1,1,double
4370,183993,RM_SaveFloat,1,RM_SaveFloat,"void RM_SaveFloat (RedisModuleIO*,float)",module.c,"void RM_SaveFloat(RedisModuleIO *io, float value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveBinaryFloatValue(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",7199.0,7214.0,1.0,37.0,16.0,17,5,14,3,0,9,8,5,2,3,,0,9,4,2,2,void
4371,184061,RM_LoadFloat,1,RM_LoadFloat,float RM_LoadFloat (RedisModuleIO*),module.c,"float RM_LoadFloat(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;
    float value;
    int retval = rdbLoadBinaryFloatValue(io->rio, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",7218.0,7230.0,1.0,18.0,13.0,9,6,11,5,0,6,6,4,1,3,,0,5,2,1,1,float
4372,184113,RM_SaveLongDouble,1,RM_SaveLongDouble,"void RM_SaveLongDouble (RedisModuleIO*,long double)",module.c,"void RM_SaveLongDouble(RedisModuleIO *io, long double value) {
    if (io->error) return;
    char buf[MAX_LONG_DOUBLE_CHARS];
    /* Long double has different number of bits in different platforms, so we
     * save it as a string type. */
    size_t len = ld2string(buf,sizeof(buf),value,LD_STR_HEX);
    RM_SaveStringBuffer(io,buf,len);
}",7235.0,7242.0,1.0,13.0,8.0,3,3,9,5,0,3,2,2,1,2,,0,2,4,2,2,void
4373,184139,RM_LoadLongDouble,1,RM_LoadLongDouble,long double RM_LoadLongDouble (RedisModuleIO*),module.c,"long double RM_LoadLongDouble(RedisModuleIO *io) {
    if (io->error) return 0;
    long double value;
    size_t len;
    char* str = RM_LoadStringBuffer(io,&len);
    if (!str) return 0;
    string2ld(str,len,&value);
    RM_Free(str);
    return value;
}",7246.0,7255.0,1.0,1.0,10.0,5,4,10,4,0,4,3,3,1,3,,0,2,2,1,1,long double
4374,184175,rdbSaveModulesAux,1,rdbSaveModulesAux,"ssize_t rdbSaveModulesAux (rio*,int)",module.c,"ssize_t rdbSaveModulesAux(rio *rdb, int when) {
    size_t total_written = 0;
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *mt = ln->value;
            if ((!mt->aux_save && !mt->aux_save2) || !(mt->aux_save_triggers & when))
                continue;
            ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
            if (ret==-1) {
                dictReleaseIterator(di);
                return -1;
            }
            total_written += ret;
        }
    }

    dictReleaseIterator(di);
    return total_written;
}",7259.0,7285.0,1.0,1.0,27.0,25,11,28,12,2,11,6,10,2,8,,0,8,4,2,2,ssize_t
4375,184269,RM_DigestAddStringBuffer,1,RM_DigestAddStringBuffer,"void RM_DigestAddStringBuffer (RedisModuleDigest*,char*,size_t)",module.c,"void RM_DigestAddStringBuffer(RedisModuleDigest *md, const char *ele, size_t len) {
    mixDigest(md->o,ele,len);
}",7329.0,7331.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,1,,0,1,6,3,3,void
4376,184282,RM_DigestAddLongLong,1,RM_DigestAddLongLong,"void RM_DigestAddLongLong (RedisModuleDigest*,long long)",module.c,"void RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {
    char buf[LONG_STR_SIZE];
    size_t len = ll2string(buf,sizeof(buf),ll);
    mixDigest(md->o,buf,len);
}",7335.0,7339.0,1.0,13.0,5.0,3,3,7,4,0,3,1,1,0,2,,0,2,4,2,2,void
4377,184303,RM_DigestEndSequence,1,RM_DigestEndSequence,void RM_DigestEndSequence (RedisModuleDigest*),module.c,"void RM_DigestEndSequence(RedisModuleDigest *md) {
    xorDigest(md->x,md->o,sizeof(md->o));
    memset(md->o,0,sizeof(md->o));
}",7342.0,7345.0,1.0,1.0,4.0,7,2,5,1,0,6,1,1,0,1,,0,5,2,1,1,void
4378,184328,RM_LoadDataTypeFromStringEncver,1,RM_LoadDataTypeFromStringEncver,"void* RM_LoadDataTypeFromStringEncver (robj*,moduleType*,int)",module.c,"void *RM_LoadDataTypeFromStringEncver(const RedisModuleString *str, const moduleType *mt, int encver) {
    rio payload;
    RedisModuleIO io;
    void *ret;

    rioInitWithBuffer(&payload, str->ptr);
    moduleInitIOContext(io,(moduleType *)mt,&payload,NULL,-1);

    /* All RM_Save*() calls always write a version 2 compatible format, so we
     * need to make sure we read the same.
     */
    ret = mt->rdb_load(&io,encver);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    return ret;
}",7361.0,7378.0,1.0,44.0,18.0,29,6,26,7,1,14,2,2,1,3,,0,11,6,3,3,void*
4379,184423,RM_LoadDataTypeFromString,1,RM_LoadDataTypeFromString,"void* RM_LoadDataTypeFromString (robj*,moduleType*)",module.c,"void *RM_LoadDataTypeFromString(const RedisModuleString *str, const moduleType *mt) {
    return RM_LoadDataTypeFromStringEncver(str, mt, 0);
}",7383.0,7385.0,1.0,38.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void*
4380,184434,RM_SaveDataTypeToString,1,RM_SaveDataTypeToString,"robj RM_SaveDataTypeToString (RedisModuleCtx*,void*,moduleType*)",module.c,"RedisModuleString *RM_SaveDataTypeToString(RedisModuleCtx *ctx, void *data, const moduleType *mt) {
    rio payload;
    RedisModuleIO io;

    rioInitWithBuffer(&payload,sdsempty());
    moduleInitIOContext(io,(moduleType *)mt,&payload,NULL,-1);
    mt->rdb_save(&io,data);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    if (io.error) {
        return NULL;
    } else {
        robj *str = createObject(OBJ_STRING,payload.io.buffer.ptr);
        if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,str);
        return str;
    }
}",7394.0,7412.0,1.0,17.0,19.0,28,6,25,5,0,16,3,3,2,4,,0,13,6,3,3,robj
4381,184558,RM_GetKeyNameFromDigest,1,RM_GetKeyNameFromDigest,robj RM_GetKeyNameFromDigest (RedisModuleDigest*),module.c,"const RedisModuleString *RM_GetKeyNameFromDigest(RedisModuleDigest *dig) {
    return dig->key;
}",7415.0,7417.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
4382,184567,RM_GetDbIdFromDigest,1,RM_GetDbIdFromDigest,int RM_GetDbIdFromDigest (RedisModuleDigest*),module.c,"int RM_GetDbIdFromDigest(RedisModuleDigest *dig) {
    return dig->dbid;
}",7420.0,7422.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4383,184576,RM_EmitAOF,1,RM_EmitAOF,"void RM_EmitAOF (RedisModuleIO*,char*,char*...)",module.c,"void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
    if (io->error) return;
    struct redisCommand *cmd;
    robj **argv = NULL;
    int argc = 0, flags = 0, j;
    va_list ap;

    cmd = lookupCommandByCString((char*)cmdname);
    if (!cmd) {
        serverLog(LL_WARNING,
            ""Fatal: AOF method for module data type '%s' tried to ""
            ""emit unknown command '%s'"",
            io->type->name, cmdname);
        io->error = 1;
        errno = EINVAL;
        return;
    }

    /* Emit the arguments into the AOF in Redis protocol format. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    va_end(ap);
    if (argv == NULL) {
        serverLog(LL_WARNING,
            ""Fatal: AOF method for module data type '%s' tried to ""
            ""call RedisModule_EmitAOF() with wrong format specifiers '%s'"",
            io->type->name, fmt);
        io->error = 1;
        errno = EINVAL;
        return;
...",7432.0,7476.0,1.0,8.0,45.0,45,11,46,13,0,19,7,8,7,8,,0,15,6,3,3,void
4384,184759,RM_GetContextFromIO,1,RM_GetContextFromIO,RedisModuleCtx RM_GetContextFromIO (RedisModuleIO*),module.c,"RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
    if (io->ctx) return io->ctx; /* Can't have more than one... */
    io->ctx = zmalloc(sizeof(RedisModuleCtx));
    moduleCreateContext(io->ctx, io->type->module, REDISMODULE_CTX_NONE);
    return io->ctx;
}",7482.0,7487.0,1.0,51.0,6.0,9,3,7,2,0,8,2,2,1,2,,0,7,2,1,1,RedisModuleCtx
4385,184796,RM_GetKeyNameFromIO,1,RM_GetKeyNameFromIO,robj RM_GetKeyNameFromIO (RedisModuleIO*),module.c,"const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
    return io->key;
}",7492.0,7494.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
4386,184805,RM_GetKeyNameFromModuleKey,1,RM_GetKeyNameFromModuleKey,robj RM_GetKeyNameFromModuleKey (RedisModuleKey*),module.c,"const RedisModuleString *RM_GetKeyNameFromModuleKey(RedisModuleKey *key) {
    return key ? key->key : NULL;
}",7497.0,7499.0,1.0,6.0,3.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,robj
4387,184817,RM_GetDbIdFromModuleKey,1,RM_GetDbIdFromModuleKey,int RM_GetDbIdFromModuleKey (RedisModuleKey*),module.c,"int RM_GetDbIdFromModuleKey(RedisModuleKey *key) {
    return key ? key->db->id : -1;
}",7502.0,7504.0,1.0,1.0,3.0,4,3,2,1,0,1,1,1,0,0,,0,1,2,1,1,int
4388,184832,RM_GetDbIdFromIO,1,RM_GetDbIdFromIO,int RM_GetDbIdFromIO (RedisModuleIO*),module.c,"int RM_GetDbIdFromIO(RedisModuleIO *io) {
    return io->dbid;
}",7509.0,7511.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4389,184841,moduleLogRaw,1,moduleLogRaw,"void moduleLogRaw (RedisModule*,char*,char*,va_list)",module.c,"void moduleLogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {
    char msg[LOG_MAX_LEN];
    size_t name_len;
    int level;

    if (!strcasecmp(levelstr,""debug"")) level = LL_DEBUG;
    else if (!strcasecmp(levelstr,""verbose"")) level = LL_VERBOSE;
    else if (!strcasecmp(levelstr,""notice"")) level = LL_NOTICE;
    else if (!strcasecmp(levelstr,""warning"")) level = LL_WARNING;
    else level = LL_VERBOSE; /* Default. */

    if (level < server.verbosity) return;

    name_len = snprintf(msg, sizeof(msg),""<%s> "", module? module->name: ""module"");
    vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
    serverLogRaw(level,msg);
}",7523.0,7539.0,1.0,13.0,17.0,11,9,17,8,2,2,3,3,0,1,,0,1,8,4,4,void
4390,184943,RM_Log,1,RM_Log,"void RM_Log (RedisModuleCtx*,char*,char*...)",module.c,"void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    moduleLogRaw(ctx? ctx->module: NULL,levelstr,fmt,ap);
    va_end(ap);
}",7559.0,7564.0,1.0,1.0,6.0,2,2,9,5,0,2,1,1,0,1,,0,1,6,3,3,void
4391,184966,RM_LogIOError,1,RM_LogIOError,"void RM_LogIOError (RedisModuleIO*,char*,char*...)",module.c,"void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    moduleLogRaw(io->type->module,levelstr,fmt,ap);
    va_end(ap);
}",7571.0,7576.0,1.0,1.0,6.0,2,1,7,4,0,2,1,1,0,1,,0,1,6,3,3,void
4392,184988,RM__Assert,1,RM__Assert,"void RM__Assert (char*,char*,int)",module.c,"void RM__Assert(const char *estr, const char *file, int line) {
    _serverAssert(estr, file, line);
}",7586.0,7588.0,1.0,1.0,3.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
4393,184999,RM_LatencyAddSample,1,RM_LatencyAddSample,"void RM_LatencyAddSample (char*,mstime_t)",module.c,"void RM_LatencyAddSample(const char *event, mstime_t latency) {
    if (latency >= server.latency_monitor_threshold)
        latencyAddSample(event, latency);
}",7593.0,7596.0,1.0,1.0,4.0,2,2,4,3,0,1,2,2,0,1,,0,0,4,2,2,void
4394,185015,unblockClientFromModule,1,unblockClientFromModule,void unblockClientFromModule (client*),module.c,"void unblockClientFromModule(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Call the disconnection callback if any. Note that
     * bc->disconnect_callback is set to NULL if the client gets disconnected
     * by the module itself or because of a timeout, so the callback will NOT
     * get called if this is not an actual disconnection event. */
    if (bc->disconnect_callback) {
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_NONE);
        ctx.blocked_privdata = bc->privdata;
        ctx.client = bc->client;
        bc->disconnect_callback(&ctx,bc);
        moduleFreeContext(&ctx);
    }

    /* If we made it here and client is still blocked it means that the command
     * timed-out, client was killed or disconnected and disconnect_callback was
     * not implemented (or it was, but RM_UnblockClient was not called from
     * within it, as it should).
     * We must call moduleUnblockClient in or...",7617.0,7652.0,1.0,46.0,36.0,21,6,18,4,0,14,3,3,3,3,,0,11,2,1,1,void
4395,185084,moduleBlockClient,1,moduleBlockClient,"RedisModuleBlockedClient moduleBlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleAuthCallback,RedisModuleCmdFunc,void,long long,robj**,int,void*,int)",module.c,"RedisModuleBlockedClient *moduleBlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                            RedisModuleAuthCallback auth_reply_callback,
                                            RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                            long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata,
                                            int flags) {
    client *c = ctx->client;
    int islua = scriptIsRunning();
    int ismulti = server.in_exec;

    c->bstate.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    ctx->module->blocked_clients++;

    /* We need to handle the invalid operation of calling modules blocking
     * commands from Lua or MULTI. We actually create an already aborted
     * (client set to NULL) blocked client handle, and actually reply ...",7674.0,7739.0,1.0,66.0,66.0,75,11,62,17,4,34,5,6,1,7,,0,32,20,10,10,RedisModuleBlockedClient
4396,185378,RM_RegisterAuthCallback,1,RM_RegisterAuthCallback,"void RM_RegisterAuthCallback (RedisModuleCtx*,RedisModuleAuthCallback)",module.c,"void RM_RegisterAuthCallback(RedisModuleCtx *ctx, RedisModuleAuthCallback cb) {
    RedisModuleAuthCtx *auth_ctx = zmalloc(sizeof(RedisModuleAuthCtx));
    auth_ctx->module = ctx->module;
    auth_ctx->auth_cb = cb;
    listAddNodeHead(moduleAuthCallbacks, auth_ctx);
}",7794.0,7799.0,1.0,1.0,6.0,7,3,8,5,0,6,1,1,0,2,,0,5,4,2,2,void
4397,185405,moduleInvokeFreePrivDataCallback,1,moduleInvokeFreePrivDataCallback,"void moduleInvokeFreePrivDataCallback (client*,RedisModuleBlockedClient*)",module.c,"void moduleInvokeFreePrivDataCallback(client *c, RedisModuleBlockedClient *bc) {
    if (bc->privdata && bc->free_privdata) {
        RedisModuleCtx ctx;
        int ctx_flags = c == NULL ? REDISMODULE_CTX_BLOCKED_DISCONNECTED : REDISMODULE_CTX_NONE;
        moduleCreateContext(&ctx, bc->module, ctx_flags);
        ctx.blocked_privdata = bc->privdata;
        ctx.client = bc->client;
        bc->free_privdata(&ctx,bc->privdata);
        moduleFreeContext(&ctx);
    }
}",7802.0,7812.0,1.0,36.0,11.0,19,8,16,5,1,10,2,2,1,3,,0,7,4,2,2,void
4398,185469,moduleUnregisterAuthCBs,1,moduleUnregisterAuthCBs,void moduleUnregisterAuthCBs (RedisModule*),module.c,"void moduleUnregisterAuthCBs(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(moduleAuthCallbacks, &li);
    while ((ln = listNext(&li))) {
        RedisModuleAuthCtx *ctx = listNodeValue(ln);
        if (ctx->module == module) {
            listDelNode(moduleAuthCallbacks, ln);
            zfree(ctx);
        }
    }
}",7815.0,7826.0,1.0,34.0,12.0,7,4,12,5,3,8,3,4,2,4,,0,5,2,1,1,void
4399,185508,attemptNextAuthCb,1,attemptNextAuthCb,"int attemptNextAuthCb (client*,robj*,robj*,robj**)",module.c,"int attemptNextAuthCb(client *c, robj *username, robj *password, robj **err) {
    int handle_next_callback = c->module_auth_ctx == NULL;
    RedisModuleAuthCtx *cur_auth_ctx = NULL;
    listNode *ln;
    listIter li;
    listRewind(moduleAuthCallbacks, &li);
    int result = REDISMODULE_AUTH_NOT_HANDLED;
    while((ln = listNext(&li))) {
        cur_auth_ctx = listNodeValue(ln);
        /* Skip over the previously attempted auth contexts. */
        if (!handle_next_callback) {
            handle_next_callback = cur_auth_ctx == c->module_auth_ctx;
            continue;
        }
        /* Remove the module auth complete flag before we attempt the next cb. */
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, cur_auth_ctx->module, REDISMODULE_CTX_NONE);
        ctx.client = c;
        *err = NULL;
        c->module_auth_ctx = cur_auth_ctx;
        result = cur_auth_ctx->auth_cb(&ctx, username, password, err);
        mo...",7830.0,7857.0,1.0,17.0,28.0,30,9,35,12,1,13,6,6,1,4,,0,10,8,4,4,int
4400,185625,attemptBlockedAuthReplyCallback,1,attemptBlockedAuthReplyCallback,"int attemptBlockedAuthReplyCallback (client*,robj*,robj*,robj**)",module.c,"int attemptBlockedAuthReplyCallback(client *c, robj *username, robj *password, robj **err) {
    int result = REDISMODULE_AUTH_NOT_HANDLED;
    if (!c->module_blocked_client) return result;
    RedisModuleBlockedClient *bc = (RedisModuleBlockedClient *) c->module_blocked_client;
    bc->client = c;
    if (bc->auth_reply_cb) {
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_REPLY);
        ctx.blocked_privdata = bc->privdata;
        ctx.blocked_ready_key = NULL;
        ctx.client = bc->client;
        ctx.blocked_client = bc;
        result = bc->auth_reply_cb(&ctx, username, password, err);
        moduleFreeContext(&ctx);
    }
    moduleInvokeFreePrivDataCallback(c, bc);
    c->module_blocked_client = NULL;
    c->lastcmd->microseconds += bc->background_duration;
    bc->module->blocked_clients--;
    zfree(bc);
    return result;
}",7864.0,7885.0,1.0,17.0,22.0,35,9,34,8,1,20,3,3,2,4,,0,16,8,4,4,int
4401,185742,checkModuleAuthentication,1,checkModuleAuthentication,"int checkModuleAuthentication (client*,robj*,robj*,robj**)",module.c,"int checkModuleAuthentication(client *c, robj *username, robj *password, robj **err) {
    if (!listLength(moduleAuthCallbacks)) return AUTH_NOT_HANDLED;
    int result = attemptBlockedAuthReplyCallback(c, username, password, err);
    if (result == REDISMODULE_AUTH_NOT_HANDLED) {
        result = attemptNextAuthCb(c, username, password, err);
    }
    if (c->flags & CLIENT_BLOCKED) {
        /* Modules are expected to return REDISMODULE_AUTH_HANDLED when blocking clients. */
        serverAssert(result == REDISMODULE_AUTH_HANDLED);
        return AUTH_BLOCKED;
    }
    c->module_auth_ctx = NULL;
    if (result == REDISMODULE_AUTH_NOT_HANDLED) {
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        return AUTH_NOT_HANDLED;
    }
    if (c->flags & CLIENT_MODULE_AUTH_HAS_RESULT) {
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        if (c->authenticated) return AUTH_OK;
    }
    return AUTH_ERR;
}",7897.0,7918.0,1.0,9.0,22.0,26,11,27,11,1,12,7,8,6,3,,0,11,8,4,4,int
4402,185866,moduleTryServeClientBlockedOnKey,1,moduleTryServeClientBlockedOnKey,"int moduleTryServeClientBlockedOnKey (client*,robj*)",module.c,"int moduleTryServeClientBlockedOnKey(client *c, robj *key) {
    int served = 0;
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Protect against re-processing: don't serve clients that are already
     * in the unblocking list for any reason (including RM_UnblockClient()
     * explicit call). See #6798. */
    if (bc->unblocked) return 0;

    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_REPLY);
    ctx.blocked_ready_key = key;
    ctx.blocked_privdata = bc->privdata;
    ctx.client = bc->client;
    ctx.blocked_client = bc;
    if (bc->reply_callback(&ctx,(void**)c->argv,c->argc) == REDISMODULE_OK)
        served = 1;
    moduleFreeContext(&ctx);
    return served;
}",7927.0,7946.0,1.0,42.0,20.0,26,7,21,5,0,14,3,3,4,2,,0,12,4,2,2,int
4403,185955,RM_BlockClient,1,RM_BlockClient,"RedisModuleBlockedClient RM_BlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long)",module.c,"RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                         RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                         long long timeout_ms) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, NULL,0,NULL,0);
}",7987.0,7991.0,1.0,1.0,5.0,0,0,8,6,0,1,1,1,0,1,,0,0,10,5,5,RedisModuleBlockedClient
4404,185976,RM_BlockClientOnAuth,1,RM_BlockClientOnAuth,"RedisModuleBlockedClient RM_BlockClientOnAuth (RedisModuleCtx*,RedisModuleAuthCallback,void)",module.c,"RedisModuleBlockedClient *RM_BlockClientOnAuth(RedisModuleCtx *ctx, RedisModuleAuthCallback reply_callback,
                                               void (*free_privdata)(RedisModuleCtx*,void*)) {
    if (!clientHasModuleAuthInProgress(ctx->client)) {
        addReplyError(ctx->client, ""Module blocking client on auth when not currently undergoing module authentication"");
        return NULL;
    }
    RedisModuleBlockedClient *bc = moduleBlockClient(ctx,NULL,reply_callback,NULL,free_privdata,0, NULL,0,NULL,0);
    if (ctx->client->flags & CLIENT_BLOCKED) {
        ctx->client->flags |= CLIENT_PENDING_COMMAND;
    }
    return bc;
}",7997.0,8008.0,1.0,9.0,12.0,14,6,16,5,0,7,3,3,3,2,,0,6,6,3,3,RedisModuleBlockedClient
4405,186045,RM_BlockClientGetPrivateData,1,RM_BlockClientGetPrivateData,void* RM_BlockClientGetPrivateData (RedisModuleBlockedClient*),module.c,"void *RM_BlockClientGetPrivateData(RedisModuleBlockedClient *blocked_client) {
    return blocked_client->privdata;
}",8011.0,8013.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void*
4406,186054,RM_BlockClientSetPrivateData,1,RM_BlockClientSetPrivateData,"void RM_BlockClientSetPrivateData (RedisModuleBlockedClient*,void*)",module.c,"void RM_BlockClientSetPrivateData(RedisModuleBlockedClient *blocked_client, void *private_data) {
    blocked_client->privdata = private_data;
}",8016.0,8018.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
4407,186065,RM_BlockClientOnKeys,1,RM_BlockClientOnKeys,"RedisModuleBlockedClient RM_BlockClientOnKeys (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,robj**,int,void*)",module.c,"RedisModuleBlockedClient *RM_BlockClientOnKeys(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                               RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                               long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, keys,numkeys,privdata,0);
}",8078.0,8082.0,1.0,69.0,5.0,0,0,9,9,0,1,1,1,0,1,,0,0,16,8,8,RedisModuleBlockedClient
4408,186089,RM_BlockClientOnKeysWithFlags,1,RM_BlockClientOnKeysWithFlags,"RedisModuleBlockedClient RM_BlockClientOnKeysWithFlags (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,robj**,int,void*,int)",module.c,"RedisModuleBlockedClient *RM_BlockClientOnKeysWithFlags(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                                        RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                                        long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata,
                                                        int flags) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, keys,numkeys,privdata,flags);
}",8093.0,8098.0,1.0,78.0,6.0,0,0,10,10,0,1,1,1,0,1,,0,0,18,9,9,RedisModuleBlockedClient
4409,186114,RM_SignalKeyAsReady,1,RM_SignalKeyAsReady,"void RM_SignalKeyAsReady (RedisModuleCtx*,robj*)",module.c,"void RM_SignalKeyAsReady(RedisModuleCtx *ctx, RedisModuleString *key) {
    signalKeyAsReady(ctx->client->db, key, OBJ_MODULE);
}",8103.0,8105.0,1.0,46.0,3.0,2,1,2,2,0,2,1,1,0,1,,0,1,4,2,2,void
4410,186130,moduleUnblockClientByHandle,1,moduleUnblockClientByHandle,"int moduleUnblockClientByHandle (RedisModuleBlockedClient*,void*)",module.c,"int moduleUnblockClientByHandle(RedisModuleBlockedClient *bc, void *privdata) {
    pthread_mutex_lock(&moduleUnblockedClientsMutex);
    if (!bc->blocked_on_keys) bc->privdata = privdata;
    bc->unblocked = 1;
    if (listLength(moduleUnblockedClients) == 0) {
        if (write(server.module_pipe[1],""A"",1) != 1) {
            /* Ignore the error, this is best-effort. */
        }
    }
    listAddNodeTail(moduleUnblockedClients,bc);
    pthread_mutex_unlock(&moduleUnblockedClientsMutex);
    return REDISMODULE_OK;
}",8108.0,8120.0,1.0,8.0,13.0,13,8,11,5,2,10,4,5,4,1,,0,9,4,2,2,int
4411,186187,moduleUnblockClient,1,moduleUnblockClient,void moduleUnblockClient (client*),module.c,"void moduleUnblockClient(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    moduleUnblockClientByHandle(bc,NULL);
}",8124.0,8127.0,1.0,1.0,4.0,3,3,4,3,1,2,1,1,0,1,,0,1,2,1,1,void
4412,186203,moduleClientIsBlockedOnKeys,1,moduleClientIsBlockedOnKeys,int moduleClientIsBlockedOnKeys (client*),module.c,"int moduleClientIsBlockedOnKeys(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    return bc->blocked_on_keys;
}",8131.0,8134.0,1.0,1.0,4.0,4,3,3,2,1,2,1,1,0,0,,0,2,2,1,1,int
4413,186220,RM_UnblockClient,1,RM_UnblockClient,"int RM_UnblockClient (RedisModuleBlockedClient*,void*)",module.c,"int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
    if (bc->blocked_on_keys) {
        /* In theory the user should always pass the timeout handler as an
         * argument, but better to be safe than sorry. */
        if (bc->timeout_callback == NULL) return REDISMODULE_ERR;
        if (bc->unblocked) return REDISMODULE_OK;
        if (bc->client) moduleBlockedClientTimedOut(bc->client);
    }
    moduleUnblockClientByHandle(bc,privdata);
    return REDISMODULE_OK;
}",8155.0,8165.0,1.0,49.0,11.0,6,2,8,3,1,7,5,8,4,2,,0,5,4,2,2,int
4414,186267,RM_AbortBlock,1,RM_AbortBlock,int RM_AbortBlock (RedisModuleBlockedClient*),module.c,"int RM_AbortBlock(RedisModuleBlockedClient *bc) {
    bc->reply_callback = NULL;
    bc->disconnect_callback = NULL;
    bc->auth_reply_cb = NULL;
    return RM_UnblockClient(bc,NULL);
}",8169.0,8174.0,1.0,1.0,6.0,6,2,8,2,0,4,1,1,0,1,,0,3,2,1,1,int
4415,186291,RM_SetDisconnectCallback,1,RM_SetDisconnectCallback,"void RM_SetDisconnectCallback (RedisModuleBlockedClient*,RedisModuleDisconnectFunc)",module.c,"void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
    bc->disconnect_callback = callback;
}",8192.0,8194.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
4416,186302,moduleHandleBlockedClients,1,moduleHandleBlockedClients,void moduleHandleBlockedClients (void),module.c,"void moduleHandleBlockedClients(void) {
    listNode *ln;
    RedisModuleBlockedClient *bc;

    pthread_mutex_lock(&moduleUnblockedClientsMutex);
    while (listLength(moduleUnblockedClients)) {
        ln = listFirst(moduleUnblockedClients);
        bc = ln->value;
        client *c = bc->client;
        listDelNode(moduleUnblockedClients,ln);
        pthread_mutex_unlock(&moduleUnblockedClientsMutex);

        /* Release the lock during the loop, as long as we don't
         * touch the shared list. */

        /* Call the reply callback if the client is valid and we have
         * any callback. However the callback is not called if the client
         * was blocked on keys (RM_BlockClientOnKeys()), because we already
         * called such callback in moduleTryServeClientBlockedOnKey() when
         * the key was signaled as ready. */
        long long prev_error_replies = server.stat_total_error_replies;
        uint64_t reply_us = 0;
        if (c && !bc->blocked_on_keys && b...",8204.0,8298.0,1.0,11.0,95.0,85,11,81,11,1,54,9,17,12,13,,0,43,2,1,1,void
4417,186584,moduleBlockedClientMayTimeout,1,moduleBlockedClientMayTimeout,int moduleBlockedClientMayTimeout (client*),module.c,"int moduleBlockedClientMayTimeout(client *c) {
    if (c->bstate.btype != BLOCKED_MODULE)
        return 1;

    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    return (bc && bc->timeout_callback != NULL);
}",8303.0,8309.0,1.0,1.0,7.0,9,5,7,4,0,3,2,2,1,0,,0,3,2,1,1,int
4418,186616,moduleBlockedClientTimedOut,1,moduleBlockedClientTimedOut,void moduleBlockedClientTimedOut (client*),module.c,"void moduleBlockedClientTimedOut(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Protect against re-processing: don't serve clients that are already
     * in the unblocking list for any reason (including RM_UnblockClient()
     * explicit call). See #6798. */
    if (bc->unblocked) return;

    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_TIMEOUT);
    ctx.client = bc->client;
    ctx.blocked_client = bc;
    ctx.blocked_privdata = bc->privdata;
    long long prev_error_replies = server.stat_total_error_replies;
    bc->timeout_callback(&ctx,(void**)c->argv,c->argc);
    moduleFreeContext(&ctx);
    updateStatsOnUnblock(c, bc->background_duration, 0, server.stat_total_error_replies != prev_error_replies);

    /* For timeout events, we do not want to call the disconnect callback,
     * because the blocked client will be automatically disconnected in
     * this case, and the user can still hook using...",8315.0,8337.0,1.0,42.0,23.0,28,7,24,6,1,16,2,2,1,3,,0,13,2,1,1,void
4419,186705,RM_IsBlockedReplyRequest,1,RM_IsBlockedReplyRequest,int RM_IsBlockedReplyRequest (RedisModuleCtx*),module.c,"int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;
}",8341.0,8343.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4420,186722,RM_IsBlockedTimeoutRequest,1,RM_IsBlockedTimeoutRequest,int RM_IsBlockedTimeoutRequest (RedisModuleCtx*),module.c,"int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
}",8347.0,8349.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4421,186739,RM_GetBlockedClientPrivateData,1,RM_GetBlockedClientPrivateData,void* RM_GetBlockedClientPrivateData (RedisModuleCtx*),module.c,"void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
    return ctx->blocked_privdata;
}",8352.0,8354.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void*
4422,186748,RM_GetBlockedClientReadyKey,1,RM_GetBlockedClientReadyKey,robj RM_GetBlockedClientReadyKey (RedisModuleCtx*),module.c,"RedisModuleString *RM_GetBlockedClientReadyKey(RedisModuleCtx *ctx) {
    return ctx->blocked_ready_key;
}",8358.0,8360.0,1.0,17.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
4423,186757,RM_GetBlockedClientHandle,1,RM_GetBlockedClientHandle,RedisModuleBlockedClient RM_GetBlockedClientHandle (RedisModuleCtx*),module.c,"RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
    return ctx->blocked_client;
}",8366.0,8368.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,RedisModuleBlockedClient
4424,186766,RM_BlockedClientDisconnected,1,RM_BlockedClientDisconnected,int RM_BlockedClientDisconnected (RedisModuleCtx*),module.c,"int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
}",8373.0,8375.0,1.0,25.0,3.0,4,4,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4425,186783,RM_GetThreadSafeContext,1,RM_GetThreadSafeContext,RedisModuleCtx RM_GetThreadSafeContext (RedisModuleBlockedClient*),module.c,"RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
    RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));
    RedisModule *module = bc ? bc->module : NULL;
    int flags = REDISMODULE_CTX_THREAD_SAFE;

    /* Creating a new client object is costly. To avoid that, we have an
     * internal pool of client objects. In blockClient(), a client object is
     * assigned to bc->thread_safe_ctx_client to be used for the thread safe
     * context.
     * For detached thread safe contexts, we create a new client object.
     * Otherwise, as this function can be called from different threads, we
     * would need to synchronize access to internal pool of client objects.
     * Assuming creating detached context is rare and not that performance
     * critical, we avoid synchronizing access to the client pool by creating
     * a new client */
    if (!bc) flags |= REDISMODULE_CTX_NEW_CLIENT;
    moduleCreateContext(ctx, module, flags);
    /* Even when the context is associate...",8401.0,8432.0,1.0,16.0,32.0,28,7,25,5,0,14,4,5,1,3,,0,12,2,1,1,RedisModuleCtx
4426,186878,RM_GetDetachedThreadSafeContext,1,RM_GetDetachedThreadSafeContext,RedisModuleCtx RM_GetDetachedThreadSafeContext (RedisModuleCtx*),module.c,"RedisModuleCtx *RM_GetDetachedThreadSafeContext(RedisModuleCtx *ctx) {
    RedisModuleCtx *new_ctx = zmalloc(sizeof(*new_ctx));
    /* We create a new client object for the detached context.
     * See RM_GetThreadSafeContext() for more information */
    moduleCreateContext(new_ctx, ctx->module,
                        REDISMODULE_CTX_THREAD_SAFE|REDISMODULE_CTX_NEW_CLIENT);
    return new_ctx;
}",8439.0,8446.0,1.0,24.0,8.0,7,6,5,2,0,3,1,1,0,2,,0,2,2,1,1,RedisModuleCtx
4427,186908,RM_FreeThreadSafeContext,1,RM_FreeThreadSafeContext,void RM_FreeThreadSafeContext (RedisModuleCtx*),module.c,"void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
    moduleFreeContext(ctx);
    zfree(ctx);
}",8449.0,8452.0,1.0,1.0,4.0,0,0,2,1,0,2,1,1,0,2,,0,0,2,1,1,void
4428,186917,moduleGILAfterLock,1,moduleGILAfterLock,void moduleGILAfterLock (void),module.c,"void moduleGILAfterLock(void) {
    /* We should never get here if we already inside a module
     * code block which already opened a context. */
    serverAssert(server.execution_nesting == 0);
    /* Bump up the nesting level to prevent immediate propagation
     * of possible RM_Call from th thread */
    enterExecutionUnit(1, 0);
}",8454.0,8461.0,1.0,4.0,8.0,6,6,1,1,2,2,1,1,0,2,,0,0,2,1,1,void
4429,186943,RM_ThreadSafeContextLock,1,RM_ThreadSafeContextLock,void RM_ThreadSafeContextLock (RedisModuleCtx*),module.c,"void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
    UNUSED(ctx);
    moduleAcquireGIL();
    moduleGILAfterLock();
}",8466.0,8470.0,1.0,4.0,5.0,1,1,2,1,0,2,1,1,0,2,,0,0,2,1,1,void
4430,186956,RM_ThreadSafeContextTryLock,1,RM_ThreadSafeContextTryLock,int RM_ThreadSafeContextTryLock (RedisModuleCtx*),module.c,"int RM_ThreadSafeContextTryLock(RedisModuleCtx *ctx) {
    UNUSED(ctx);

    int res = moduleTryAcquireGIL();
    if(res != 0) {
        errno = res;
        return REDISMODULE_ERR;
    }
    moduleGILAfterLock();
    return REDISMODULE_OK;
}",8478.0,8488.0,1.0,4.0,11.0,4,3,6,3,0,2,2,2,0,2,,0,1,2,1,1,int
4431,186988,moduleGILBeforeUnlock,1,moduleGILBeforeUnlock,void moduleGILBeforeUnlock (void),module.c,"void moduleGILBeforeUnlock(void) {
    /* We should never get here if we already inside a module
     * code block which already opened a context, except
     * the bump-up from moduleGILAcquired. */
    serverAssert(server.execution_nesting == 1);
    /* Restore nesting level and propagate pending commands
     * (because it's unclear when thread safe contexts are
     * released we have to propagate here). */
    exitExecutionUnit();
    postExecutionUnitOperations();
}",8490.0,8500.0,1.0,4.0,11.0,6,6,1,1,1,3,1,1,0,3,,0,0,2,1,1,void
4432,187013,RM_ThreadSafeContextUnlock,1,RM_ThreadSafeContextUnlock,void RM_ThreadSafeContextUnlock (RedisModuleCtx*),module.c,"void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
    UNUSED(ctx);
    moduleGILBeforeUnlock();
    moduleReleaseGIL();
}",8503.0,8507.0,1.0,4.0,5.0,1,1,2,1,0,2,1,1,0,2,,0,0,2,1,1,void
4433,187026,moduleAcquireGIL,1,moduleAcquireGIL,void moduleAcquireGIL (void),module.c,"void moduleAcquireGIL(void) {
    pthread_mutex_lock(&moduleGIL);
}",8509.0,8511.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
4434,187034,moduleTryAcquireGIL,1,moduleTryAcquireGIL,int moduleTryAcquireGIL (void),module.c,"int moduleTryAcquireGIL(void) {
    return pthread_mutex_trylock(&moduleGIL);
}",8513.0,8515.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,int
4435,187043,moduleReleaseGIL,1,moduleReleaseGIL,void moduleReleaseGIL (void),module.c,"void moduleReleaseGIL(void) {
    pthread_mutex_unlock(&moduleGIL);
}",8517.0,8519.0,1.0,1.0,3.0,1,1,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
4436,187051,RM_SubscribeToKeyspaceEvents,1,RM_SubscribeToKeyspaceEvents,"int RM_SubscribeToKeyspaceEvents (RedisModuleCtx*,int,RedisModuleNotificationFunc)",module.c,"int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {
    RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));
    sub->module = ctx->module;
    sub->event_mask = types;
    sub->notify_callback = callback;
    sub->active = 0;

    listAddNodeTail(moduleKeyspaceSubscribers, sub);
    return REDISMODULE_OK;
}",8594.0,8603.0,1.0,11.0,10.0,12,4,11,5,0,8,1,1,0,2,,0,7,6,3,3,int
4437,187094,firePostExecutionUnitJobs,1,firePostExecutionUnitJobs,void firePostExecutionUnitJobs (void),module.c,"void firePostExecutionUnitJobs(void) {
    /* Avoid propagation of commands.
     * In that way, postExecutionUnitOperations will prevent
     * recursive calls to firePostExecutionUnitJobs.
     * This is a special case where we need to increase 'execution_nesting'
     * but we do not want to update the cached time */
    enterExecutionUnit(0, 0);
    while (listLength(modulePostExecUnitJobs) > 0) {
        listNode *ln = listFirst(modulePostExecUnitJobs);
        RedisModulePostExecUnitJob *job = listNodeValue(ln);
        listDelNode(modulePostExecUnitJobs, ln);

        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, job->module, REDISMODULE_CTX_TEMP_CLIENT);
        selectDb(ctx.client, job->dbid);

        job->callback(&ctx, job->pd);
        if (job->free_pd) job->free_pd(job->pd);

        moduleFreeContext(&ctx);
        zfree(job);
    }
    exitExecutionUnit();
}",8605.0,8628.0,1.0,11.0,24.0,18,6,22,4,1,22,3,4,3,8,,0,14,2,1,1,void
4438,187179,RM_AddPostNotificationJob,1,RM_AddPostNotificationJob,"int RM_AddPostNotificationJob (RedisModuleCtx*,RedisModulePostNotificationJobFunc,void*,void)",module.c,"int RM_AddPostNotificationJob(RedisModuleCtx *ctx, RedisModulePostNotificationJobFunc callback, void *privdata, void (*free_privdata)(void*)) {
    if (server.loading|| (server.masterhost && server.repl_slave_ro)) {
        return REDISMODULE_ERR;
    }
    RedisModulePostExecUnitJob *job = zmalloc(sizeof(*job));
    job->module = ctx->module;
    job->callback = callback;
    job->pd = privdata;
    job->free_pd = free_privdata;
    job->dbid = ctx->client->db->id;

    listAddNodeTail(modulePostExecUnitJobs, job);
    return REDISMODULE_OK;
}",8647.0,8660.0,1.0,15.0,14.0,22,7,17,7,0,9,2,2,0,2,,0,8,8,4,4,int
4439,187251,RM_GetNotifyKeyspaceEvents,1,RM_GetNotifyKeyspaceEvents,int RM_GetNotifyKeyspaceEvents (void),module.c,"int RM_GetNotifyKeyspaceEvents(void) {
    return server.notify_keyspace_events;
}",8664.0,8666.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
4440,187260,RM_NotifyKeyspaceEvent,1,RM_NotifyKeyspaceEvent,"int RM_NotifyKeyspaceEvent (RedisModuleCtx*,int,char*,robj*)",module.c,"int RM_NotifyKeyspaceEvent(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key) {
    if (!ctx || !ctx->client)
        return REDISMODULE_ERR;
    notifyKeyspaceEvent(type, (char *)event, key, ctx->client->db->id);
    return REDISMODULE_OK;
}",8669.0,8674.0,1.0,77.0,6.0,8,4,6,4,0,3,2,2,1,1,,0,2,8,4,4,int
4441,187298,moduleNotifyKeyspaceEvent,1,moduleNotifyKeyspaceEvent,"void moduleNotifyKeyspaceEvent (int,char*,robj*,int)",module.c,"void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
    /* Don't do anything if there aren't any subscribers */
    if (listLength(moduleKeyspaceSubscribers) == 0) return;

    /* Ugly hack to handle modules which use write commands from within
     * notify_callback, which they should NOT do!
     * Modules should use RedisModules_AddPostNotificationJob instead.
     *
     * Anyway, we want any propagated commands from within notify_callback
     * to be propagated inside a MULTI/EXEC together with the original
     * command that caused the KSN.
     * Note that it's only relevant for KSNs which are not generated from within
     * call(), for example active-expiry and eviction (because anyway
     * execution_nesting is incremented from within call())
     *
     * In order to do that we increment the execution_nesting counter, thus
     * preventing postExecutionUnitOperations (from within moduleFreeContext)
     * from propagating commands from C...",8679.0,8732.0,1.0,8.0,54.0,36,13,27,10,1,20,4,5,7,7,,0,14,8,4,4,void
4442,187426,moduleUnsubscribeNotifications,1,moduleUnsubscribeNotifications,void moduleUnsubscribeNotifications (RedisModule*),module.c,"void moduleUnsubscribeNotifications(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(moduleKeyspaceSubscribers,&li);
    while((ln = listNext(&li))) {
        RedisModuleKeyspaceSubscriber *sub = ln->value;
        if (sub->module == module) {
            listDelNode(moduleKeyspaceSubscribers, ln);
            zfree(sub);
        }
    }
}",8735.0,8746.0,1.0,1.0,12.0,7,4,11,5,1,8,3,4,2,4,,0,5,2,1,1,void
4443,187462,RedisModuleClusterMessageReceiver,1,RedisModuleClusterMessageReceiver,"void RedisModuleClusterMessageReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)",module.c,"typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);",8753.0,8753.0,14.0,151.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
4444,187554,RM_RegisterClusterMessageReceiver,1,RM_RegisterClusterMessageReceiver,"void RM_RegisterClusterMessageReceiver (RedisModuleCtx*,uint8_t,RedisModuleClusterMessageReceiver)",module.c,"void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
    if (!server.cluster_enabled) return;

    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
    moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
    while(r) {
        if (r->module_id == module_id) {
            /* Found! Set or delete. */
            if (callback) {
                r->callback = callback;
            } else {
                /* Delete the receiver entry if the user is setting
                 * it to NULL. Just unlink the receiver node from the
                 * linked list. */
                if (prev)
                    prev->next = r->next;
                else
                    clusterReceivers[type]->next = r->next;
                zfree(r);
            }
            return;
        }
        prev = r;
        r = r->next;
    }

    /* Not found, let's add it. */
    if (callback) {
        r = zmalloc(si...",8796.0,8831.0,1.0,1.0,36.0,30,8,33,9,0,14,6,9,1,2,,0,14,6,3,3,void
4445,187678,RM_SendClusterMessage,1,RM_SendClusterMessage,"int RM_SendClusterMessage (RedisModuleCtx*,char*,uint8_t,char*,uint32_t)",module.c,"int RM_SendClusterMessage(RedisModuleCtx *ctx, const char *target_id, uint8_t type, const char *msg, uint32_t len) {
    if (!server.cluster_enabled) return REDISMODULE_ERR;
    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
    if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)
        return REDISMODULE_OK;
    else
        return REDISMODULE_ERR;
}",8840.0,8847.0,1.0,40.0,8.0,6,5,8,7,0,3,3,3,1,2,,0,3,10,5,5,int
4446,187729,RM_GetClusterNodesList,1,RM_GetClusterNodesList,"char** RM_GetClusterNodesList (RedisModuleCtx*,size_t*)",module.c,"char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
    UNUSED(ctx);

    if (!server.cluster_enabled) return NULL;
    size_t count = dictSize(server.cluster->nodes);
    char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
    dictIterator *di = dictGetIterator(server.cluster->nodes);
    dictEntry *de;
    int j = 0;
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;
        ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);
        memcpy(ids[j],node->name,REDISMODULE_NODE_ID_LEN);
        j++;
    }
    *numnodes = j;
    ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need
                    * to also get the count argument. */
    dictReleaseIterator(di);
    return ids;
}",8871.0,8892.0,1.0,4.0,22.0,37,13,32,10,0,8,5,5,2,6,,0,7,4,2,2,char**
4447,187863,RM_FreeClusterNodesList,1,RM_FreeClusterNodesList,void RM_FreeClusterNodesList (char**),module.c,"void RM_FreeClusterNodesList(char **ids) {
    if (ids == NULL) return;
    for (int j = 0; ids[j]; j++) zfree(ids[j]);
    zfree(ids);
}",8895.0,8899.0,1.0,1.0,5.0,3,3,6,3,0,1,3,3,0,1,,0,0,2,1,1,void
4448,187891,RM_GetMyClusterID,1,RM_GetMyClusterID,const char* RM_GetMyClusterID (void),module.c,"const char *RM_GetMyClusterID(void) {
    if (!server.cluster_enabled) return NULL;
    return server.cluster->myself->name;
}",8903.0,8906.0,1.0,1.0,4.0,5,3,3,2,0,0,2,2,0,0,,0,0,2,1,1,const char*
4449,187912,RM_GetClusterSize,1,RM_GetClusterSize,size_t RM_GetClusterSize (void),module.c,"size_t RM_GetClusterSize(void) {
    if (!server.cluster_enabled) return 0;
    return dictSize(server.cluster->nodes);
}",8912.0,8915.0,1.0,11.0,4.0,13,5,4,1,0,0,2,2,0,0,,0,0,2,1,1,size_t
4450,187952,RM_GetClusterNodeInfo,1,RM_GetClusterNodeInfo,"int RM_GetClusterNodeInfo (RedisModuleCtx*,char*,char*,char*,int*,int*)",module.c,"int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {
    UNUSED(ctx);

    clusterNode *node = clusterLookupNode(id, strlen(id));
    if (node == NULL ||
        node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
    {
        return REDISMODULE_ERR;
    }

    if (ip) redis_strlcpy(ip,node->ip,NET_IP_STR_LEN);

    if (master_id) {
        /* If the information is not available, the function will set the
         * field to zero bytes, so that when the field can't be populated the
         * function kinda remains predictable. */
        if (node->flags & CLUSTER_NODE_SLAVE && node->slaveof)
            memcpy(master_id,node->slaveof->name,REDISMODULE_NODE_ID_LEN);
        else
            memset(master_id,0,REDISMODULE_NODE_ID_LEN);
    }
    if (port) *port = getNodeDefaultClientPort(node);

    /* As usually we have to remap flags for modules, in order to ensure
     * we can provide binary compatibility. */
...",8937.0,8972.0,1.0,4.0,36.0,42,10,33,8,0,14,13,20,9,3,,0,13,12,6,6,int
4451,188162,RM_SetClusterFlags,1,RM_SetClusterFlags,"void RM_SetClusterFlags (RedisModuleCtx*,uint64_t)",module.c,"void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {
    UNUSED(ctx);
    if (flags & REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)
        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;
    if (flags & REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)
        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;
}",8992.0,8998.0,1.0,4.0,7.0,9,4,6,3,0,0,3,3,0,0,,0,0,4,2,2,void
4452,188216,RedisModuleTimerProc,1,RedisModuleTimerProc,"void RedisModuleTimerProc (RedisModuleCtx*,void*)",module.c,"typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);",9022.0,9022.0,14.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4453,188228,moduleTimerHandler,1,moduleTimerHandler,"int moduleTimerHandler (aeEventLoop*,long long,void*)",module.c,"int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* To start let's try to fire all the timers already expired. */
    raxIterator ri;
    raxStart(&ri,Timers);
    uint64_t now = ustime();
    long long next_period = 0;
    while(1) {
        raxSeek(&ri,""^"",NULL,0);
        if (!raxNext(&ri)) break;
        uint64_t expiretime;
        memcpy(&expiretime,ri.key,sizeof(expiretime));
        expiretime = ntohu64(expiretime);
        if (now >= expiretime) {
            RedisModuleTimer *timer = ri.data;
            RedisModuleCtx ctx;
            moduleCreateContext(&ctx,timer->module,REDISMODULE_CTX_TEMP_CLIENT);
            selectDb(ctx.client, timer->dbid);
            timer->callback(&ctx,timer->data);
            moduleFreeContext(&ctx);
            raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);
            zfree(timer);
        } else {
            /* We call us...",9034.0,9080.0,1.0,4.0,47.0,32,11,41,11,0,24,7,8,3,12,,0,16,6,3,3,int
4454,188395,RM_CreateTimer,1,RM_CreateTimer,"RedisModuleTimerID RM_CreateTimer (RedisModuleCtx*,mstime_t,RedisModuleTimerProc,void*)",module.c,"RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {
    RedisModuleTimer *timer = zmalloc(sizeof(*timer));
    timer->module = ctx->module;
    timer->callback = callback;
    timer->data = data;
    timer->dbid = ctx->client ? ctx->client->db->id : 0;
    uint64_t expiretime = ustime()+period*1000;
    uint64_t key;

    while(1) {
        key = htonu64(expiretime);
        if (raxFind(Timers, (unsigned char*)&key,sizeof(key)) == raxNotFound) {
            raxInsert(Timers,(unsigned char*)&key,sizeof(key),timer,NULL);
            break;
        } else {
            expiretime++;
        }
    }

    /* We need to install the main event loop timer if it's not already
     * installed, or we may need to refresh its period if we just installed
     * a timer that will expire sooner than any other else (i.e. the timer
     * we just installed is the first timer in the Timers rax). */
    if (aeTimer != -1) {
        raxIt...",9094.0,9137.0,1.0,14.0,44.0,45,13,45,13,0,27,7,8,5,11,,0,21,8,4,4,RedisModuleTimerID
4455,188551,RM_StopTimer,1,RM_StopTimer,"int RM_StopTimer (RedisModuleCtx*,RedisModuleTimerID,void**)",module.c,"int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
    if (timer == raxNotFound || timer->module != ctx->module)
        return REDISMODULE_ERR;
    if (data) *data = timer->data;
    raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);
    zfree(timer);
    return REDISMODULE_OK;
}",9143.0,9151.0,1.0,15.0,9.0,15,9,16,7,0,8,3,3,2,3,,0,6,6,3,3,int
4456,188610,RM_GetTimerInfo,1,RM_GetTimerInfo,"int RM_GetTimerInfo (RedisModuleCtx*,RedisModuleTimerID,uint64_t*,void**)",module.c,"int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
    if (timer == raxNotFound || timer->module != ctx->module)
        return REDISMODULE_ERR;
    if (remaining) {
        int64_t rem = ntohu64(id)-ustime();
        if (rem < 0) rem = 0;
        *remaining = rem/1000; /* Scale to milliseconds. */
    }
    if (data) *data = timer->data;
    return REDISMODULE_OK;
}",9159.0,9170.0,1.0,15.0,12.0,19,12,19,8,0,7,5,6,2,3,,0,7,8,4,4,int
4457,188686,moduleHoldsTimer,1,moduleHoldsTimer,int moduleHoldsTimer (RedisModule*),module.c,"int moduleHoldsTimer(struct RedisModule *module) {
    raxIterator iter;
    int found = 0;
    raxStart(&iter,Timers);
    raxSeek(&iter,""^"",NULL,0);
    while (raxNext(&iter)) {
        RedisModuleTimer *timer = iter.data;
        if (timer->module == module) {
            found = 1;
            break;
        }
    }
    raxStop(&iter);
    return found;
}",9174.0,9188.0,1.0,1.0,15.0,10,5,13,6,0,7,4,4,2,4,,0,4,2,1,1,int
4458,188747,eventLoopToAeMask,1,eventLoopToAeMask,int eventLoopToAeMask (int),module.c,"static int eventLoopToAeMask(int mask) {
    int aeMask = 0;
    if (mask & REDISMODULE_EVENTLOOP_READABLE)
        aeMask |= AE_READABLE;
    if (mask & REDISMODULE_EVENTLOOP_WRITABLE)
        aeMask |= AE_WRITABLE;
    return aeMask;
}",9208.0,9215.0,1.0,15.0,8.0,3,2,6,2,2,0,3,3,0,0,,0,0,2,1,1,int
4459,188782,eventLoopFromAeMask,1,eventLoopFromAeMask,int eventLoopFromAeMask (int),module.c,"static int eventLoopFromAeMask(int ae_mask) {
    int mask = 0;
    if (ae_mask & AE_READABLE)
        mask |= REDISMODULE_EVENTLOOP_READABLE;
    if (ae_mask & AE_WRITABLE)
        mask |= REDISMODULE_EVENTLOOP_WRITABLE;
    return mask;
}",9217.0,9224.0,1.0,18.0,8.0,3,2,6,2,2,0,3,3,0,0,,0,0,2,1,1,int
4460,188817,eventLoopCbReadable,1,eventLoopCbReadable,"void eventLoopCbReadable (aeEventLoop*,int,void*,int)",module.c,"static void eventLoopCbReadable(struct aeEventLoop *ae, int fd, void *user_data, int ae_mask) {
    UNUSED(ae);
    EventLoopData *data = user_data;
    data->rFunc(fd, data->user_data, eventLoopFromAeMask(ae_mask));
}",9226.0,9230.0,1.0,4.0,5.0,4,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
4461,188845,eventLoopCbWritable,1,eventLoopCbWritable,"void eventLoopCbWritable (aeEventLoop*,int,void*,int)",module.c,"static void eventLoopCbWritable(struct aeEventLoop *ae, int fd, void *user_data, int ae_mask) {
    UNUSED(ae);
    EventLoopData *data = user_data;
    data->wFunc(fd, data->user_data, eventLoopFromAeMask(ae_mask));
}",9232.0,9236.0,1.0,4.0,5.0,4,3,8,5,0,3,1,1,0,1,,0,2,8,4,4,void
4462,188873,RM_EventLoopAdd,1,RM_EventLoopAdd,"int RM_EventLoopAdd (int,int,RedisModuleEventLoopFunc,void*)",module.c,"int RM_EventLoopAdd(int fd, int mask, RedisModuleEventLoopFunc func, void *user_data) {
    if (fd < 0 || fd >= aeGetSetSize(server.el)) {
        errno = ERANGE;
        return REDISMODULE_ERR;
    }

    if (!func || mask & ~(REDISMODULE_EVENTLOOP_READABLE |
                          REDISMODULE_EVENTLOOP_WRITABLE)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* We are going to register stub callbacks to 'ae' for two reasons:
     *
     * - ""ae"" callback signature is different from RedisModuleEventLoopCallback,
     *   that will be handled it in our stub callbacks.
     * - We need to remap 'mask' value to provide binary compatibility.
     *
     * For the stub callbacks, saving user 'callback' and 'user_data' in an
     * EventLoopData object and passing it to ae, later, we'll extract
     * 'callback' and 'user_data' from that.
     */
    EventLoopData *data = aeGetFileClientData(server.el, fd);
    if (!data)
        data = zcalloc(sizeof(*data));

...",9263.0,9311.0,1.0,15.0,49.0,33,14,36,11,0,10,9,10,3,7,,0,9,8,4,4,int
4463,189028,RM_EventLoopDel,1,RM_EventLoopDel,"int RM_EventLoopDel (int,int)",module.c,"int RM_EventLoopDel(int fd, int mask) {
    if (fd < 0 || fd >= aeGetSetSize(server.el)) {
        errno = ERANGE;
        return REDISMODULE_ERR;
    }

    if (mask & ~(REDISMODULE_EVENTLOOP_READABLE |
                 REDISMODULE_EVENTLOOP_WRITABLE)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* After deleting the event, if fd does not have any registered event
     * anymore, we can free the EventLoopData object. */
    EventLoopData *data = aeGetFileClientData(server.el, fd);
    aeDeleteFileEvent(server.el, fd, eventLoopToAeMask(mask));
    if (aeGetFileEvents(server.el, fd) == AE_NONE)
        zfree(data);

    errno = 0;
    return REDISMODULE_OK;
}",9327.0,9348.0,1.0,15.0,22.0,15,9,18,7,0,6,4,4,2,6,,0,4,4,2,2,int
4464,189107,RM_EventLoopAddOneShot,1,RM_EventLoopAddOneShot,"int RM_EventLoopAddOneShot (RedisModuleEventLoopOneShotFunc,void*)",module.c,"int RM_EventLoopAddOneShot(RedisModuleEventLoopOneShotFunc func, void *user_data) {
    if (!func) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    EventLoopOneShot *oneshot = zmalloc(sizeof(*oneshot));
    oneshot->func = func;
    oneshot->user_data = user_data;

    pthread_mutex_lock(&moduleEventLoopMutex);
    if (!moduleEventLoopOneShots) moduleEventLoopOneShots = listCreate();
    listAddNodeTail(moduleEventLoopOneShots, oneshot);
    pthread_mutex_unlock(&moduleEventLoopMutex);

    if (write(server.module_pipe[1],""A"",1) != 1) {
        /* Pipe is non-blocking, write() may fail if it's full. */
    }

    errno = 0;
    return REDISMODULE_OK;
}",9354.0,9375.0,1.0,15.0,22.0,17,9,17,8,0,10,4,4,1,3,,0,9,4,2,2,int
4465,189176,eventLoopHandleOneShotEvents,1,eventLoopHandleOneShotEvents,void eventLoopHandleOneShotEvents (void),module.c,"static void eventLoopHandleOneShotEvents(void) {
    pthread_mutex_lock(&moduleEventLoopMutex);
    if (moduleEventLoopOneShots) {
        while (listLength(moduleEventLoopOneShots)) {
            listNode *ln = listFirst(moduleEventLoopOneShots);
            EventLoopOneShot *oneshot = ln->value;
            listDelNode(moduleEventLoopOneShots, ln);
            /* Unlock mutex before the callback. Another oneshot event can be
             * added in the callback, it will need to lock the mutex. */
            pthread_mutex_unlock(&moduleEventLoopMutex);
            oneshot->func(oneshot->user_data);
            zfree(oneshot);
            /* Lock again for the next iteration */
            pthread_mutex_lock(&moduleEventLoopMutex);
        }
    }
    pthread_mutex_unlock(&moduleEventLoopMutex);
}",9379.0,9396.0,1.0,15.0,18.0,11,3,17,4,1,17,3,4,4,2,,0,15,2,1,1,void
4466,189231,moduleNotifyUserChanged,1,moduleNotifyUserChanged,void moduleNotifyUserChanged (client*),module.c,"void moduleNotifyUserChanged(client *c) {
    if (c->auth_callback) {
        c->auth_callback(c->id, c->auth_callback_privdata);

        /* The callback will fire exactly once, even if the user remains
         * the same. It is expected to completely clean up the state
         * so all references are cleared here. */
        c->auth_callback = NULL;
        c->auth_callback_privdata = NULL;
        c->auth_module = NULL;
    }
}",9410.0,9421.0,1.0,1.0,12.0,10,2,10,2,5,7,2,2,1,0,,0,7,2,1,1,void
4467,189266,revokeClientAuthentication,1,revokeClientAuthentication,void revokeClientAuthentication (client*),module.c,"void revokeClientAuthentication(client *c) {
    /* Freeing the client would result in moduleNotifyUserChanged() to be
     * called later, however since we use revokeClientAuthentication() also
     * in moduleFreeAuthenticatedClients() to implement module unloading, we
     * do this action ASAP: this way if the module is unloaded, when the client
     * is eventually freed we don't rely on the module to still exist. */
    moduleNotifyUserChanged(c);

    c->user = DefaultUser;
    c->authenticated = 0;
    /* We will write replies to this client later, so we can't close it
     * directly even if async. */
    if (c == server.current_client) {
        c->flags |= CLIENT_CLOSE_AFTER_COMMAND;
    } else {
        freeClientAsync(c);
    }
}",9423.0,9440.0,1.0,20.0,18.0,8,5,7,3,2,4,2,2,0,1,,0,3,2,1,1,void
4468,189303,moduleFreeAuthenticatedClients,1,moduleFreeAuthenticatedClients,void moduleFreeAuthenticatedClients (RedisModule*),module.c,"static void moduleFreeAuthenticatedClients(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (!c->auth_module) continue;

        RedisModule *auth_module = (RedisModule *) c->auth_module;
        if (auth_module == module) {
            revokeClientAuthentication(c);
        }
    }
}",9445.0,9458.0,1.0,20.0,14.0,13,8,14,7,1,6,5,6,2,3,,0,4,2,1,1,void
4469,189356,RM_CreateModuleUser,1,RM_CreateModuleUser,RedisModuleUser RM_CreateModuleUser (char*),module.c,"RedisModuleUser *RM_CreateModuleUser(const char *name) {
    RedisModuleUser *new_user = zmalloc(sizeof(RedisModuleUser));
    new_user->user = ACLCreateUnlinkedUser();
    new_user->free_user = 1;

    /* Free the previous temporarily assigned name to assign the new one */
    sdsfree(new_user->user->name);
    new_user->user->name = sdsnew(name);
    return new_user;
}",9480.0,9489.0,1.0,1.0,10.0,11,3,8,3,0,8,1,1,0,4,,0,7,2,1,1,RedisModuleUser
4470,189393,RM_FreeModuleUser,1,RM_FreeModuleUser,int RM_FreeModuleUser (RedisModuleUser*),module.c,"int RM_FreeModuleUser(RedisModuleUser *user) {
    if (user->free_user)
        ACLFreeUserAndKillClients(user->user);
    zfree(user);
    return REDISMODULE_OK;
}",9493.0,9498.0,1.0,11.0,6.0,2,1,3,1,0,4,2,2,1,2,,0,2,2,1,1,int
4471,189413,RM_SetModuleUserACL,1,RM_SetModuleUserACL,"int RM_SetModuleUserACL (RedisModuleUser*,char*)",module.c,"int RM_SetModuleUserACL(RedisModuleUser *user, const char* acl) {
    return ACLSetUser(user->user, acl, -1);
}",9507.0,9509.0,1.0,1.0,3.0,2,2,2,2,0,2,1,1,0,1,,0,1,4,2,2,int
4472,189427,RM_SetModuleUserACLString,1,RM_SetModuleUserACLString,"int RM_SetModuleUserACLString (RedisModuleCtx*,RedisModuleUser*,char*,robj**)",module.c,"int RM_SetModuleUserACLString(RedisModuleCtx *ctx, RedisModuleUser *user, const char *acl, RedisModuleString **error) {
    serverAssert(user != NULL);

    int argc;
    sds *argv = sdssplitargs(acl, &argc);

    sds err = ACLStringSetUser(user->user, NULL, argv, argc);

    sdsfreesplitres(argv, argc);

    if (err) {
        if (error) {
            *error = createObject(OBJ_STRING, err);
            if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, *error);
        } else {
            sdsfree(err);
        }

        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",9518.0,9540.0,1.0,91.0,23.0,13,9,20,8,0,7,4,7,0,6,,0,4,8,4,4,int
4473,189510,RM_GetModuleUserACLString,1,RM_GetModuleUserACLString,robj RM_GetModuleUserACLString (RedisModuleUser*),module.c,"RedisModuleString *RM_GetModuleUserACLString(RedisModuleUser *user) {
    serverAssert(user != NULL);

    return ACLDescribeUser(user->user);
}",9545.0,9549.0,1.0,17.0,5.0,6,6,3,2,0,3,1,1,0,2,,0,1,2,1,1,robj
4474,189536,RM_GetCurrentUserName,1,RM_GetCurrentUserName,robj RM_GetCurrentUserName (RedisModuleCtx*),module.c,"RedisModuleString *RM_GetCurrentUserName(RedisModuleCtx *ctx) {
    return RM_CreateString(ctx,ctx->client->user->name,sdslen(ctx->client->user->name));
}",9557.0,9559.0,1.0,17.0,3.0,6,1,3,1,0,4,1,1,0,2,,0,3,2,1,1,robj
4475,189559,RM_GetModuleUserFromUserName,1,RM_GetModuleUserFromUserName,RedisModuleUser RM_GetModuleUserFromUserName (robj*),module.c,"RedisModuleUser *RM_GetModuleUserFromUserName(RedisModuleString *name) {
    /* First, verify that the user exist */
    user *acl_user = ACLGetUserByName(name->ptr, sdslen(name->ptr));
    if (acl_user == NULL) {
        return NULL;
    }

    RedisModuleUser *new_user = zmalloc(sizeof(RedisModuleUser));
    new_user->user = acl_user;
    new_user->free_user = 0;
    return new_user;
}",9572.0,9583.0,1.0,46.0,12.0,10,4,12,5,0,5,2,2,0,3,,0,5,2,1,1,RedisModuleUser
4476,189600,RM_ACLCheckCommandPermissions,1,RM_ACLCheckCommandPermissions,"int RM_ACLCheckCommandPermissions (RedisModuleUser*,robj**,int)",module.c,"int RM_ACLCheckCommandPermissions(RedisModuleUser *user, RedisModuleString **argv, int argc) {
    int keyidxptr;
    struct redisCommand *cmd;

    /* Find command */
    if ((cmd = lookupCommand(argv, argc)) == NULL) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }

    if (ACLCheckAllUserCommandPerm(user->user, cmd, argv, argc, &keyidxptr) != ACL_OK) {
        errno = EACCES;
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",9593.0,9609.0,1.0,57.0,17.0,7,5,13,9,0,3,3,3,3,2,,0,3,6,3,3,int
4477,189651,RM_ACLCheckKeyPermissions,1,RM_ACLCheckKeyPermissions,"int RM_ACLCheckKeyPermissions (RedisModuleUser*,robj*,int)",module.c,"int RM_ACLCheckKeyPermissions(RedisModuleUser *user, RedisModuleString *key, int flags) {
    const int allow_mask = (REDISMODULE_CMD_KEY_ACCESS
        | REDISMODULE_CMD_KEY_INSERT
        | REDISMODULE_CMD_KEY_DELETE
        | REDISMODULE_CMD_KEY_UPDATE);

    if ((flags & allow_mask) != flags) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    int keyspec_flags = moduleConvertKeySpecsFlags(flags, 0);
    if (ACLUserCheckKeyPerm(user->user, key->ptr, sdslen(key->ptr), keyspec_flags) != ACL_OK) {
        errno = EACCES;
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",9626.0,9644.0,1.0,53.0,19.0,17,6,14,8,0,4,3,3,3,3,,0,4,6,3,3,int
4478,189733,RM_ACLCheckChannelPermissions,1,RM_ACLCheckChannelPermissions,"int RM_ACLCheckChannelPermissions (RedisModuleUser*,robj*,int)",module.c,"int RM_ACLCheckChannelPermissions(RedisModuleUser *user, RedisModuleString *ch, int flags) {
    const int allow_mask = (REDISMODULE_CMD_CHANNEL_PUBLISH
        | REDISMODULE_CMD_CHANNEL_SUBSCRIBE
        | REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE
        | REDISMODULE_CMD_CHANNEL_PATTERN);

    if ((flags & allow_mask) != flags) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* Unsubscribe permissions are currently always allowed. */
    if (flags & REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE){
        return REDISMODULE_OK;
    }

    int is_pattern = flags & REDISMODULE_CMD_CHANNEL_PATTERN;
    if (ACLUserCheckChannelPerm(user->user, ch->ptr, is_pattern) != ACL_OK)
        return REDISMODULE_ERR;

    return REDISMODULE_OK;
}",9656.0,9677.0,1.0,57.0,22.0,19,6,12,7,0,2,4,4,2,1,,0,2,6,3,3,int
4479,189825,moduleGetACLLogEntryReason,1,moduleGetACLLogEntryReason,int moduleGetACLLogEntryReason (RedisModuleACLLogEntryReason),module.c,"int moduleGetACLLogEntryReason(RedisModuleACLLogEntryReason reason) {
    int acl_reason = 0;
    switch (reason) {
        case REDISMODULE_ACL_LOG_AUTH: acl_reason = ACL_DENIED_AUTH; break;
        case REDISMODULE_ACL_LOG_KEY: acl_reason = ACL_DENIED_KEY; break;
        case REDISMODULE_ACL_LOG_CHANNEL: acl_reason = ACL_DENIED_CHANNEL; break;
        case REDISMODULE_ACL_LOG_CMD: acl_reason = ACL_DENIED_CMD; break;
        default: break;
    }
    return acl_reason;
}",9680.0,9690.0,1.0,52.0,11.0,5,1,11,6,2,0,7,2,0,0,,0,0,2,1,1,int
4480,189873,RM_ACLAddLogEntry,1,RM_ACLAddLogEntry,"int RM_ACLAddLogEntry (RedisModuleCtx*,RedisModuleUser*,robj*,RedisModuleACLLogEntryReason)",module.c,"int RM_ACLAddLogEntry(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) {
    int acl_reason = moduleGetACLLogEntryReason(reason);
    if (!acl_reason) return REDISMODULE_ERR;
    addACLLogEntry(ctx->client, acl_reason, ACL_LOG_CTX_MODULE, -1, user->user->name, sdsdup(object->ptr));
    return REDISMODULE_OK;
}",9696.0,9701.0,1.0,66.0,6.0,7,4,7,5,0,5,2,2,0,3,,0,4,8,4,4,int
4481,189917,RM_ACLAddLogEntryByUserName,1,RM_ACLAddLogEntryByUserName,"int RM_ACLAddLogEntryByUserName (RedisModuleCtx*,robj*,robj*,RedisModuleACLLogEntryReason)",module.c,"int RM_ACLAddLogEntryByUserName(RedisModuleCtx *ctx, RedisModuleString *username, RedisModuleString *object, RedisModuleACLLogEntryReason reason) {
    int acl_reason = moduleGetACLLogEntryReason(reason);
    if (!acl_reason) return REDISMODULE_ERR;
    addACLLogEntry(ctx->client, acl_reason, ACL_LOG_CTX_MODULE, -1, username->ptr, sdsdup(object->ptr));
    return REDISMODULE_OK;
}",9707.0,9712.0,1.0,53.0,6.0,6,4,7,5,0,4,2,2,0,3,,0,3,8,4,4,int
4482,189959,authenticateClientWithUser,1,authenticateClientWithUser,"int authenticateClientWithUser (RedisModuleCtx*,user*,RedisModuleUserChangedFunc,void*,uint64_t*)",module.c,"static int authenticateClientWithUser(RedisModuleCtx *ctx, user *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    if (user->flags & USER_FLAG_DISABLED) {
        return REDISMODULE_ERR;
    }

    /* Avoid settings which are meaningless and will be lost */
    if (!ctx->client || (ctx->client->flags & CLIENT_MODULE)) {
        return REDISMODULE_ERR;
    }

    moduleNotifyUserChanged(ctx->client);

    ctx->client->user = user;
    ctx->client->authenticated = 1;

    if (clientHasModuleAuthInProgress(ctx->client)) {
        ctx->client->flags |= CLIENT_MODULE_AUTH_HAS_RESULT;
    }

    if (callback) {
        ctx->client->auth_callback = callback;
        ctx->client->auth_callback_privdata = privdata;
        ctx->client->auth_module = ctx->module;
    }

    if (client_id) {
        *client_id = ctx->client->id;
    }

    return REDISMODULE_OK;
}",9734.0,9764.0,1.0,22.0,31.0,38,8,21,6,2,15,6,6,5,1,,0,14,10,5,5,int
4483,190089,RM_AuthenticateClientWithUser,1,RM_AuthenticateClientWithUser,"int RM_AuthenticateClientWithUser (RedisModuleCtx*,RedisModuleUser*,RedisModuleUserChangedFunc,void*,uint64_t*)",module.c,"int RM_AuthenticateClientWithUser(RedisModuleCtx *ctx, RedisModuleUser *module_user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    return authenticateClientWithUser(ctx, module_user->user, callback, privdata, client_id);
}",9772.0,9774.0,1.0,1.0,3.0,1,1,5,5,0,2,1,1,0,1,,0,1,10,5,5,int
4484,190107,RM_AuthenticateClientWithACLUser,1,RM_AuthenticateClientWithACLUser,"int RM_AuthenticateClientWithACLUser (RedisModuleCtx*,char*,size_t,RedisModuleUserChangedFunc,void*,uint64_t*)",module.c,"int RM_AuthenticateClientWithACLUser(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    user *acl_user = ACLGetUserByName(name, len);

    if (!acl_user) {
        return REDISMODULE_ERR;
    }
    return authenticateClientWithUser(ctx, acl_user, callback, privdata, client_id);
}",9781.0,9788.0,1.0,15.0,8.0,2,2,9,7,0,2,2,2,0,2,,0,1,12,6,6,int
4485,190138,RM_DeauthenticateAndCloseClient,1,RM_DeauthenticateAndCloseClient,"int RM_DeauthenticateAndCloseClient (RedisModuleCtx*,uint64_t)",module.c,"int RM_DeauthenticateAndCloseClient(RedisModuleCtx *ctx, uint64_t client_id) {
    UNUSED(ctx);
    client *c = lookupClientByID(client_id);
    if (c == NULL) return REDISMODULE_ERR;

    /* Revoke also marks client to be closed ASAP */
    revokeClientAuthentication(c);
    return REDISMODULE_OK;
}",9802.0,9810.0,1.0,4.0,9.0,3,3,7,4,0,2,2,2,0,2,,0,1,4,2,2,int
4486,190170,RM_RedactClientCommandArgument,1,RM_RedactClientCommandArgument,"int RM_RedactClientCommandArgument (RedisModuleCtx*,int)",module.c,"int RM_RedactClientCommandArgument(RedisModuleCtx *ctx, int pos) {
    if (!ctx || !ctx->client || pos <= 0 || ctx->client->argc <= pos) {
        return REDISMODULE_ERR;
    }
    redactClientCommandArgument(ctx->client, pos);
    return REDISMODULE_OK;
}",9822.0,9828.0,1.0,15.0,7.0,11,4,7,2,0,4,2,2,2,1,,0,3,4,2,2,int
4487,190210,RM_GetClientCertificate,1,RM_GetClientCertificate,"robj RM_GetClientCertificate (RedisModuleCtx*,uint64_t)",module.c,"RedisModuleString *RM_GetClientCertificate(RedisModuleCtx *ctx, uint64_t client_id) {
    client *c = lookupClientByID(client_id);
    if (c == NULL) return NULL;

    sds cert = connGetPeerCert(c->conn);
    if (!cert) return NULL;

    RedisModuleString *s = createObject(OBJ_STRING, cert);
    if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, s);

    return s;
}",9842.0,9853.0,1.0,17.0,12.0,7,5,16,6,0,5,4,4,0,4,,0,4,4,2,2,robj
4488,190262,RM_CreateDict,1,RM_CreateDict,RedisModuleDict RM_CreateDict (RedisModuleCtx*),module.c,"RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
    struct RedisModuleDict *d = zmalloc(sizeof(*d));
    d->rax = raxNew();
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
    return d;
}",9876.0,9881.0,1.0,39.0,6.0,6,5,8,3,0,4,2,2,0,3,,0,3,2,1,1,RedisModuleDict
4489,190315,RM_DictSize,1,RM_DictSize,uint64_t RM_DictSize (RedisModuleDict*),module.c,"uint64_t RM_DictSize(RedisModuleDict *d) {
    return raxSize(d->rax);
}",9893.0,9895.0,1.0,1.0,3.0,1,1,1,1,0,2,1,1,0,1,,0,1,2,1,1,uint64_t
4490,190325,RM_DictSetC,1,RM_DictSetC,"int RM_DictSetC (RedisModuleDict*,void*,size_t,void*)",module.c,"int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
    int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);
    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
}",9901.0,9904.0,1.0,27.0,4.0,4,4,7,6,1,2,1,1,0,1,,0,2,8,4,4,int
4491,190355,RM_DictReplaceC,1,RM_DictReplaceC,"int RM_DictReplaceC (RedisModuleDict*,void*,size_t,void*)",module.c,"int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
    int retval = raxInsert(d->rax,key,keylen,ptr,NULL);
    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
}",9908.0,9911.0,1.0,27.0,4.0,4,4,7,6,1,2,1,1,0,1,,0,2,8,4,4,int
4492,190385,RM_DictSet,1,RM_DictSet,"int RM_DictSet (RedisModuleDict*,robj*,void*)",module.c,"int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
    return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);
}",9914.0,9916.0,1.0,35.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
4493,190403,RM_DictReplace,1,RM_DictReplace,"int RM_DictReplace (RedisModuleDict*,robj*,void*)",module.c,"int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
    return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);
}",9919.0,9921.0,1.0,39.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
4494,190421,RM_DictGetC,1,RM_DictGetC,"void* RM_DictGetC (RedisModuleDict*,void*,size_t,int*)",module.c,"void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
    void *res = raxFind(d->rax,key,keylen);
    if (nokey) *nokey = (res == raxNotFound);
    return (res == raxNotFound) ? NULL : res;
}",9928.0,9932.0,1.0,1.0,5.0,7,5,12,7,1,2,2,2,0,1,,0,2,8,4,4,void*
4495,190454,RM_DictGet,1,RM_DictGet,"void* RM_DictGet (RedisModuleDict*,robj*,int*)",module.c,"void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
    return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);
}",9935.0,9937.0,1.0,37.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,void*
4496,190472,RM_DictDelC,1,RM_DictDelC,"int RM_DictDelC (RedisModuleDict*,void*,size_t,void*)",module.c,"int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
    int retval = raxRemove(d->rax,key,keylen,oldval);
    return retval ? REDISMODULE_OK : REDISMODULE_ERR;
}",9946.0,9949.0,1.0,20.0,4.0,3,3,6,5,1,2,1,1,0,1,,0,2,8,4,4,int
4497,190499,RM_DictDel,1,RM_DictDel,"int RM_DictDel (RedisModuleDict*,robj*,void*)",module.c,"int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
    return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);
}",9952.0,9954.0,1.0,35.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
4498,190517,RM_DictIteratorStartC,1,RM_DictIteratorStartC,"RedisModuleDictIter RM_DictIteratorStartC (RedisModuleDict*,char*,void*,size_t)",module.c,"RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {
    RedisModuleDictIter *di = zmalloc(sizeof(*di));
    di->dict = d;
    raxStart(&di->ri,d->rax);
    raxSeek(&di->ri,op,key,keylen);
    return di;
}",9976.0,9982.0,1.0,1.0,7.0,10,5,11,5,1,7,1,1,0,3,,0,5,8,4,4,RedisModuleDictIter
4499,190555,RM_DictIteratorStart,1,RM_DictIteratorStart,"RedisModuleDictIter RM_DictIteratorStart (RedisModuleDict*,char*,robj*)",module.c,"RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
    return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));
}",9986.0,9988.0,1.0,78.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,RedisModuleDictIter
4500,190573,RM_DictIteratorStop,1,RM_DictIteratorStop,void RM_DictIteratorStop (RedisModuleDictIter*),module.c,"void RM_DictIteratorStop(RedisModuleDictIter *di) {
    raxStop(&di->ri);
    zfree(di);
}",9992.0,9995.0,1.0,1.0,4.0,2,2,2,1,0,3,1,1,0,2,,0,1,2,1,1,void
4501,190585,RM_DictIteratorReseekC,1,RM_DictIteratorReseekC,"int RM_DictIteratorReseekC (RedisModuleDictIter*,char*,void*,size_t)",module.c,"int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
    return raxSeek(&di->ri,op,key,keylen);
}",10004.0,10006.0,1.0,1.0,3.0,2,2,4,4,1,2,1,1,0,1,,0,1,8,4,4,int
4502,190602,RM_DictIteratorReseek,1,RM_DictIteratorReseek,"int RM_DictIteratorReseek (RedisModuleDictIter*,char*,robj*)",module.c,"int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
    return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));
}",10010.0,10012.0,1.0,67.0,3.0,2,1,4,3,0,2,1,1,0,2,,0,1,6,3,3,int
4503,190620,RM_DictNextC,1,RM_DictNextC,"void* RM_DictNextC (RedisModuleDictIter*,size_t*,void**)",module.c,"void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
    if (!raxNext(&di->ri)) return NULL;
    if (keylen) *keylen = di->ri.key_len;
    if (dataptr) *dataptr = di->ri.data;
    return di->ri.key;
}",10039.0,10044.0,1.0,1.0,6.0,13,6,9,4,1,5,4,4,2,1,,0,5,6,3,3,void*
4504,190665,RM_DictPrevC,1,RM_DictPrevC,"void* RM_DictPrevC (RedisModuleDictIter*,size_t*,void**)",module.c,"void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
    if (!raxPrev(&di->ri)) return NULL;
    if (keylen) *keylen = di->ri.key_len;
    if (dataptr) *dataptr = di->ri.data;
    return di->ri.key;
}",10049.0,10054.0,1.0,1.0,6.0,13,6,9,4,1,5,4,4,2,1,,0,5,6,3,3,void*
4505,190710,RM_DictNext,1,RM_DictNext,"robj RM_DictNext (RedisModuleCtx*,RedisModuleDictIter*,void**)",module.c,"RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
    size_t keylen;
    void *key = RM_DictNextC(di,&keylen,dataptr);
    if (key == NULL) return NULL;
    return RM_CreateString(ctx,key,keylen);
}",10063.0,10068.0,1.0,17.0,6.0,3,3,10,6,0,2,2,2,0,2,,0,1,6,3,3,robj
4506,190738,RM_DictPrev,1,RM_DictPrev,"robj RM_DictPrev (RedisModuleCtx*,RedisModuleDictIter*,void**)",module.c,"RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
    size_t keylen;
    void *key = RM_DictPrevC(di,&keylen,dataptr);
    if (key == NULL) return NULL;
    return RM_CreateString(ctx,key,keylen);
}",10073.0,10078.0,1.0,17.0,6.0,3,3,10,6,0,2,2,2,0,2,,0,1,6,3,3,robj
4507,190766,RM_DictCompareC,1,RM_DictCompareC,"int RM_DictCompareC (RedisModuleDictIter*,char*,void*,size_t)",module.c,"int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
    int res = raxCompare(&di->ri,op,key,keylen);
    return res ? REDISMODULE_OK : REDISMODULE_ERR;
}",10092.0,10096.0,1.0,32.0,5.0,6,4,7,5,0,4,2,2,2,2,,0,4,8,4,4,int
4508,190805,RM_DictCompare,1,RM_DictCompare,"int RM_DictCompare (RedisModuleDictIter*,char*,robj*)",module.c,"int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
    int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));
    return res ? REDISMODULE_OK : REDISMODULE_ERR;
}",10100.0,10104.0,1.0,60.0,5.0,8,4,7,4,0,5,2,2,2,3,,0,5,6,3,3,int
4509,190848,RM_InfoEndDictField,1,RM_InfoEndDictField,int RM_InfoEndDictField (RedisModuleInfoCtx*),module.c,"int RM_InfoEndDictField(RedisModuleInfoCtx *ctx) {
    if (!ctx->in_dict_field)
        return REDISMODULE_ERR;
    /* trim the last ',' if found. */
    if (ctx->info[sdslen(ctx->info)-1]==',')
        sdsIncrLen(ctx->info, -1);
    ctx->info = sdscat(ctx->info, ""\r\n"");
    ctx->in_dict_field = 0;
    return REDISMODULE_OK;
}",10169.0,10178.0,1.0,15.0,10.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
4510,190853,RM_InfoAddSection,1,RM_InfoAddSection,"int RM_InfoAddSection (RedisModuleInfoCtx*,char*)",module.c,"int RM_InfoAddSection(RedisModuleInfoCtx *ctx, const char *name) {
    sds full_name = sdsdup(ctx->module->name);
    if (name != NULL && strlen(name) > 0)
        full_name = sdscatfmt(full_name, ""_%s"", name);

    /* Implicitly end dicts, instead of returning an error which is likely un checked. */
    if (ctx->in_dict_field)
        RM_InfoEndDictField(ctx);

    /* proceed only if:
     * 1) no section was requested (emit all)
     * 2) the module name was requested (emit all)
     * 3) this specific section was requested. */
    if (ctx->requested_sections) {
        if ((!full_name || !dictFind(ctx->requested_sections, full_name)) &&
            (!dictFind(ctx->requested_sections, ctx->module->name)))
        {
            sdsfree(full_name);
            ctx->in_section = 0;
            return REDISMODULE_ERR;
        }
    }
    if (ctx->sections++) ctx->info = sdscat(ctx->info,""\r\n"");
    ctx->info = sdscatfmt(ctx->info, ""# %S\r\n"", full_name);
    ctx->in_section = 1;
    ...",10119.0,10146.0,1.0,19.0,28.0,30,8,26,4,0,22,6,7,8,9,,0,19,4,2,2,int
4511,190965,RM_InfoBeginDictField,1,RM_InfoBeginDictField,"int RM_InfoBeginDictField (RedisModuleInfoCtx*,char*)",module.c,"int RM_InfoBeginDictField(RedisModuleInfoCtx *ctx, const char *name) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    /* Implicitly end dicts, instead of returning an error which is likely un checked. */
    if (ctx->in_dict_field)
        RM_InfoEndDictField(ctx);
    char *tmpmodname, *tmpname;
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:"",
        getSafeInfoString(ctx->module->name, strlen(ctx->module->name), &tmpmodname),
        getSafeInfoString(name, strlen(name), &tmpname));
    if (tmpmodname != NULL) zfree(tmpmodname);
    if (tmpname != NULL) zfree(tmpname);
    ctx->in_dict_field = 1;
    return REDISMODULE_OK;
}",10151.0,10166.0,1.0,15.0,16.0,16,5,18,5,0,13,5,5,2,6,,0,10,4,2,2,int
4512,191095,RM_InfoAddFieldString,1,RM_InfoAddFieldString,"int RM_InfoAddFieldString (RedisModuleInfoCtx*,char*,robj*)",module.c,"int RM_InfoAddFieldString(RedisModuleInfoCtx *ctx, const char *field, RedisModuleString *value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%S,"",
            field,
            (sds)value->ptr);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%S\r\n"",
        ctx->module->name,
        field,
        (sds)value->ptr);
    return REDISMODULE_OK;
}",10183.0,10199.0,1.0,70.0,17.0,15,4,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
4513,191160,RM_InfoAddFieldCString,1,RM_InfoAddFieldCString,"int RM_InfoAddFieldCString (RedisModuleInfoCtx*,char*,char*)",module.c,"int RM_InfoAddFieldCString(RedisModuleInfoCtx *ctx, const char *field, const char *value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%s,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%s\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10202.0,10218.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
4514,191217,RM_InfoAddFieldDouble,1,RM_InfoAddFieldDouble,"int RM_InfoAddFieldDouble (RedisModuleInfoCtx*,char*,double)",module.c,"int RM_InfoAddFieldDouble(RedisModuleInfoCtx *ctx, const char *field, double value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatprintf(ctx->info,
            ""%s=%.17g,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatprintf(ctx->info,
        ""%s_%s:%.17g\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10221.0,10237.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
4515,191274,RM_InfoAddFieldLongLong,1,RM_InfoAddFieldLongLong,"int RM_InfoAddFieldLongLong (RedisModuleInfoCtx*,char*,long long)",module.c,"int RM_InfoAddFieldLongLong(RedisModuleInfoCtx *ctx, const char *field, long long value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%I,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%I\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10240.0,10256.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
4516,191331,RM_InfoAddFieldULongLong,1,RM_InfoAddFieldULongLong,"int RM_InfoAddFieldULongLong (RedisModuleInfoCtx*,char*,long long unsigned)",module.c,"int RM_InfoAddFieldULongLong(RedisModuleInfoCtx *ctx, const char *field, unsigned long long value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%U,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%U\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",10259.0,10275.0,1.0,15.0,17.0,11,3,11,3,0,9,3,3,2,2,,0,9,6,3,3,int
4517,191388,RM_RegisterInfoFunc,1,RM_RegisterInfoFunc,"int RM_RegisterInfoFunc (RedisModuleCtx*,RedisModuleInfoFunc)",module.c,"int RM_RegisterInfoFunc(RedisModuleCtx *ctx, RedisModuleInfoFunc cb) {
    ctx->module->info_cb = cb;
    return REDISMODULE_OK;
}",10279.0,10282.0,1.0,11.0,4.0,3,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,int
4518,191405,modulesCollectInfo,1,modulesCollectInfo,"sds modulesCollectInfo (sds,dict*,int,int)",module.c,"sds modulesCollectInfo(sds info, dict *sections_dict, int for_crash_report, int sections) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!module->info_cb)
            continue;
        RedisModuleInfoCtx info_ctx = {module, sections_dict, info, sections, 0, 0};
        module->info_cb(&info_ctx, for_crash_report);
        /* Implicitly end dicts (no way to handle errors, and we must add the newline). */
        if (info_ctx.in_dict_field)
            RM_InfoEndDictField(&info_ctx);
        info = info_ctx.info;
        sections = info_ctx.sections;
    }
    dictReleaseIterator(di);
    return info;
}",10284.0,10302.0,1.0,1.0,19.0,16,7,24,10,2,11,5,6,3,5,,0,9,8,4,4,sds
4519,191478,RM_GetServerInfo,1,RM_GetServerInfo,"RedisModuleServerInfoData RM_GetServerInfo (RedisModuleCtx*,char*)",module.c,"RedisModuleServerInfoData *RM_GetServerInfo(RedisModuleCtx *ctx, const char *section) {
    struct RedisModuleServerInfoData *d = zmalloc(sizeof(*d));
    d->rax = raxNew();
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_INFO,d);
    int all = 0, everything = 0;
    robj *argv[1];
    argv[0] = section ? createStringObject(section, strlen(section)) : NULL;
    dict *section_dict = genInfoSectionDict(argv, section ? 1 : 0, NULL, &all, &everything);
    sds info = genRedisInfoString(section_dict, all, everything);
    int totlines, i;
    sds *lines = sdssplitlen(info, sdslen(info), ""\r\n"", 2, &totlines);
    for(i=0; i<totlines; i++) {
        sds line = lines[i];
        if (line[0]=='#') continue;
        char *sep = strchr(line, ':');
        if (!sep) continue;
        unsigned char *key = (unsigned char*)line;
        size_t keylen = (intptr_t)sep-(intptr_t)line;
        sds val = sdsnewlen(sep+1,sdslen(line)-((intptr_t)sep-(intptr_t)line)-1);
        if (!raxTryInsert(d-...",10310.0,10337.0,1.0,39.0,28.0,43,14,61,17,0,18,9,10,2,16,,0,12,4,2,2,RedisModuleServerInfoData
4520,191689,RM_ServerInfoGetField,1,RM_ServerInfoGetField,"robj RM_ServerInfoGetField (RedisModuleCtx*,RedisModuleServerInfoData*,char*)",module.c,"RedisModuleString *RM_ServerInfoGetField(RedisModuleCtx *ctx, RedisModuleServerInfoData *data, const char* field) {
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) return NULL;
    RedisModuleString *o = createStringObject(val,sdslen(val));
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",10352.0,10358.0,1.0,17.0,7.0,6,5,15,7,0,5,3,3,0,4,,0,4,6,3,3,robj
4521,191737,RM_ServerInfoGetFieldC,1,RM_ServerInfoGetFieldC,"const char* RM_ServerInfoGetFieldC (RedisModuleServerInfoData*,char*)",module.c,"const char *RM_ServerInfoGetFieldC(RedisModuleServerInfoData *data, const char* field) {
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) return NULL;
    return val;
}",10361.0,10365.0,1.0,1.0,5.0,4,4,8,5,0,2,2,2,0,1,,0,2,4,2,2,const char*
4522,191764,RM_ServerInfoGetFieldSigned,1,RM_ServerInfoGetFieldSigned,"long long RM_ServerInfoGetFieldSigned (RedisModuleServerInfoData*,char*,int*)",module.c,"long long RM_ServerInfoGetFieldSigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    long long ll;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2ll(val,sdslen(val),&ll)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return ll;
}",10370.0,10383.0,1.0,32.0,14.0,12,7,16,6,0,4,6,8,2,3,,0,4,6,3,3,long long
4523,191831,RM_ServerInfoGetFieldUnsigned,1,RM_ServerInfoGetFieldUnsigned,"unsigned long long RM_ServerInfoGetFieldUnsigned (RedisModuleServerInfoData*,char*,int*)",module.c,"unsigned long long RM_ServerInfoGetFieldUnsigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    unsigned long long ll;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2ull(val,&ll)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return ll;
}",10388.0,10401.0,1.0,32.0,14.0,12,7,15,6,0,3,6,8,1,2,,0,3,6,3,3,unsigned long long
4524,191896,RM_ServerInfoGetFieldDouble,1,RM_ServerInfoGetFieldDouble,"double RM_ServerInfoGetFieldDouble (RedisModuleServerInfoData*,char*,int*)",module.c,"double RM_ServerInfoGetFieldDouble(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    double dbl;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2d(val,sdslen(val),&dbl)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return dbl;
}",10406.0,10419.0,1.0,32.0,14.0,12,7,16,6,0,4,6,8,2,3,,0,4,6,3,3,double
4525,191963,RM_GetRandomBytes,1,RM_GetRandomBytes,"void RM_GetRandomBytes (unsigned char*,size_t)",module.c,"void RM_GetRandomBytes(unsigned char *dst, size_t len) {
    getRandomBytes(dst,len);
}",10429.0,10431.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
4526,191972,RM_GetRandomHexChars,1,RM_GetRandomHexChars,"void RM_GetRandomHexChars (char*,size_t)",module.c,"void RM_GetRandomHexChars(char *dst, size_t len) {
    getRandomHexChars(dst,len);
}",10436.0,10438.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
4527,191981,RM_ExportSharedAPI,1,RM_ExportSharedAPI,"int RM_ExportSharedAPI (RedisModuleCtx*,char*,void*)",module.c,"int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
    RedisModuleSharedAPI *sapi = zmalloc(sizeof(*sapi));
    sapi->module = ctx->module;
    sapi->func = func;
    if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
        zfree(sapi);
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",10456.0,10465.0,1.0,59.0,10.0,11,7,10,5,0,6,2,2,1,3,,0,5,6,3,3,int
4528,192031,RM_GetSharedAPI,1,RM_GetSharedAPI,"void* RM_GetSharedAPI (RedisModuleCtx*,char*)",module.c,"void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
    dictEntry *de = dictFind(server.sharedapi, apiname);
    if (de == NULL) return NULL;
    RedisModuleSharedAPI *sapi = dictGetVal(de);
    if (listSearchKey(sapi->module->usedby,ctx->module) == NULL) {
        listAddNodeTail(sapi->module->usedby,ctx->module);
        listAddNodeTail(ctx->module->using,sapi->module);
    }
    return sapi->func;
}",10500.0,10509.0,1.0,1.0,10.0,15,4,16,6,0,12,3,3,3,5,,0,10,4,2,2,void*
4529,192092,moduleUnregisterSharedAPI,1,moduleUnregisterSharedAPI,int moduleUnregisterSharedAPI (RedisModule*),module.c,"int moduleUnregisterSharedAPI(RedisModule *module) {
    int count = 0;
    dictIterator *di = dictGetSafeIterator(server.sharedapi);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        const char *apiname = dictGetKey(de);
        RedisModuleSharedAPI *sapi = dictGetVal(de);
        if (sapi->module == module) {
            dictDelete(server.sharedapi,apiname);
            zfree(sapi);
            count++;
        }
    }
    dictReleaseIterator(di);
    return count;
}",10517.0,10532.0,1.0,1.0,16.0,11,6,18,8,2,8,3,4,2,7,,0,5,2,1,1,int
4530,192147,moduleUnregisterUsedAPI,1,moduleUnregisterUsedAPI,int moduleUnregisterUsedAPI (RedisModule*),module.c,"int moduleUnregisterUsedAPI(RedisModule *module) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(module->using,&li);
    while((ln = listNext(&li))) {
        RedisModule *used = ln->value;
        listNode *ln = listSearchKey(used->usedby,module);
        if (ln) {
            listDelNode(used->usedby,ln);
            count++;
        }
    }
    return count;
}",10538.0,10553.0,1.0,1.0,16.0,11,4,15,5,2,8,3,4,1,4,,0,6,2,1,1,int
4531,192197,moduleUnregisterFilters,1,moduleUnregisterFilters,int moduleUnregisterFilters (RedisModule*),module.c,"int moduleUnregisterFilters(RedisModule *module) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(module->filters,&li);
    while((ln = listNext(&li))) {
        RedisModuleCommandFilter *filter = ln->value;
        listNode *ln = listSearchKey(moduleCommandFilters,filter);
        if (ln) {
            listDelNode(moduleCommandFilters,ln);
            count++;
        }
        zfree(filter);
    }
    return count;
}",10559.0,10575.0,1.0,1.0,17.0,9,4,16,6,1,9,3,4,1,5,,0,6,2,1,1,int
4532,192245,RM_RegisterCommandFilter,1,RM_RegisterCommandFilter,"RedisModuleCommandFilter RM_RegisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilterFunc,int)",module.c,"RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {
    RedisModuleCommandFilter *filter = zmalloc(sizeof(*filter));
    filter->module = ctx->module;
    filter->callback = callback;
    filter->flags = flags;

    listAddNodeTail(moduleCommandFilters, filter);
    listAddNodeTail(ctx->module->filters, filter);
    return filter;
}",10632.0,10641.0,1.0,1.0,10.0,12,4,13,5,0,9,1,1,0,3,,0,7,6,3,3,RedisModuleCommandFilter
4533,192288,RM_UnregisterCommandFilter,1,RM_UnregisterCommandFilter,"int RM_UnregisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilter*)",module.c,"int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {
    listNode *ln;

    /* A module can only remove its own filters */
    if (filter->module != ctx->module) return REDISMODULE_ERR;

    ln = listSearchKey(moduleCommandFilters,filter);
    if (!ln) return REDISMODULE_ERR;
    listDelNode(moduleCommandFilters,ln);

    ln = listSearchKey(ctx->module->filters,filter);
    if (!ln) return REDISMODULE_ERR;    /* Shouldn't happen */
    listDelNode(ctx->module->filters,ln);

    zfree(filter);

    return REDISMODULE_OK;
}",10645.0,10662.0,1.0,46.0,18.0,11,4,15,4,0,11,4,4,2,5,,0,8,4,2,2,int
4534,192354,moduleCallCommandFilters,1,moduleCallCommandFilters,void moduleCallCommandFilters (client*),module.c,"void moduleCallCommandFilters(client *c) {
    if (listLength(moduleCommandFilters) == 0) return;

    listIter li;
    listNode *ln;
    listRewind(moduleCommandFilters,&li);

    RedisModuleCommandFilterCtx filter = {
        .argv = c->argv,
        .argv_len = c->argv_len,
        .argc = c->argc,
        .c = c
    };

    while((ln = listNext(&li))) {
        RedisModuleCommandFilter *f = ln->value;

        /* Skip filter if REDISMODULE_CMDFILTER_NOSELF is set and module is
         * currently processing a command.
         */
        if ((f->flags & REDISMODULE_CMDFILTER_NOSELF) && f->module->in_call) continue;

        /* Call filter */
        f->callback(&filter);
    }

    c->argv = filter.argv;
    c->argv_len = filter.argv_len;
    c->argc = filter.argc;
}",10664.0,10693.0,1.0,8.0,30.0,33,9,27,9,3,19,5,5,6,2,,0,18,2,1,1,void
4535,192460,RM_CommandFilterArgsCount,1,RM_CommandFilterArgsCount,int RM_CommandFilterArgsCount (RedisModuleCommandFilterCtx*),module.c,"int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
{
    return fctx->argc;
}",10698.0,10701.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4536,192469,RM_CommandFilterArgGet,1,RM_CommandFilterArgGet,"robj RM_CommandFilterArgGet (RedisModuleCommandFilterCtx*,int)",module.c,"RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
{
    if (pos < 0 || pos >= fctx->argc) return NULL;
    return fctx->argv[pos];
}",10706.0,10710.0,1.0,17.0,5.0,6,5,6,3,0,2,2,2,1,0,,0,2,4,2,2,robj
4537,192494,RM_CommandFilterArgInsert,1,RM_CommandFilterArgInsert,"int RM_CommandFilterArgInsert (RedisModuleCommandFilterCtx*,int,robj*)",module.c,"int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
{
    int i;

    if (pos < 0 || pos > fctx->argc) return REDISMODULE_ERR;

    if (fctx->argv_len < fctx->argc+1) {
        fctx->argv_len = fctx->argc+1;
        fctx->argv = zrealloc(fctx->argv, fctx->argv_len*sizeof(RedisModuleString *));
    }
    for (i = fctx->argc; i > pos; i--) {
        fctx->argv[i] = fctx->argv[i-1];
    }
    fctx->argv[pos] = arg;
    fctx->argc++;

    return REDISMODULE_OK;
}",10717.0,10734.0,1.0,74.0,18.0,32,11,23,5,0,14,4,4,3,1,,0,14,6,3,3,int
4538,192592,RM_CommandFilterArgReplace,1,RM_CommandFilterArgReplace,"int RM_CommandFilterArgReplace (RedisModuleCommandFilterCtx*,int,robj*)",module.c,"int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
{
    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;

    decrRefCount(fctx->argv[pos]);
    fctx->argv[pos] = arg;

    return REDISMODULE_OK;
}",10741.0,10749.0,1.0,75.0,9.0,9,6,8,3,0,4,2,2,1,1,,0,3,6,3,3,int
4539,192631,RM_CommandFilterArgDelete,1,RM_CommandFilterArgDelete,"int RM_CommandFilterArgDelete (RedisModuleCommandFilterCtx*,int)",module.c,"int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
{
    int i;
    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;

    decrRefCount(fctx->argv[pos]);
    for (i = pos; i < fctx->argc-1; i++) {
        fctx->argv[i] = fctx->argv[i+1];
    }
    fctx->argc--;

    return REDISMODULE_OK;
}",10754.0,10766.0,1.0,45.0,13.0,18,9,14,3,0,7,3,3,2,1,,0,6,4,2,2,int
4540,192695,RM_CommandFilterGetClientId,1,RM_CommandFilterGetClientId,unsigned long long RM_CommandFilterGetClientId (RedisModuleCommandFilterCtx*),module.c,"unsigned long long RM_CommandFilterGetClientId(RedisModuleCommandFilterCtx *fctx) {
    return fctx->c->id;
}",10769.0,10771.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned long long
4541,192706,RM_MallocSize,1,RM_MallocSize,size_t RM_MallocSize (void*),module.c,"size_t RM_MallocSize(void* ptr) {
    return zmalloc_size(ptr);
}",10779.0,10781.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
4542,192714,RM_MallocUsableSize,1,RM_MallocUsableSize,size_t RM_MallocUsableSize (void*),module.c,"size_t RM_MallocUsableSize(void *ptr) {
    /* It is safe to use 'zmalloc_usable_size()' to manipulate additional
     * memory space, as we guarantee that the compiler can recognize this
     * after 'RM_Alloc', 'RM_TryAlloc', 'RM_Realloc', or 'RM_Calloc'. */
    return zmalloc_usable_size(ptr);
}",10785.0,10790.0,1.0,1.0,6.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,size_t
4543,192722,RM_MallocSizeString,1,RM_MallocSizeString,size_t RM_MallocSizeString (robj*),module.c,"size_t RM_MallocSizeString(RedisModuleString* str) {
    serverAssert(str->type == OBJ_STRING);
    return sizeof(*str) + getStringObjectSdsUsedMemory(str);
}",10794.0,10797.0,1.0,27.0,4.0,9,9,3,1,0,2,1,1,0,2,,0,0,2,1,1,size_t
4544,192752,RM_MallocSizeDict,1,RM_MallocSizeDict,size_t RM_MallocSizeDict (RedisModuleDict*),module.c,"size_t RM_MallocSizeDict(RedisModuleDict* dict) {
    size_t size = sizeof(RedisModuleDict) + sizeof(rax);
    size += dict->rax->numnodes * sizeof(raxNode);
    /* For more info about this weird line, see streamRadixTreeMemoryUsage */
    size += dict->rax->numnodes * sizeof(long)*30;
    return size;
}",10803.0,10809.0,1.0,1.0,7.0,15,6,10,6,0,2,1,1,0,0,,0,2,2,1,1,size_t
4545,192789,RM_GetUsedMemoryRatio,1,RM_GetUsedMemoryRatio,float RM_GetUsedMemoryRatio (void),module.c,"float RM_GetUsedMemoryRatio(void){
    float level;
    getMaxmemoryState(NULL, NULL, NULL, &level);
    return level;
}",10819.0,10823.0,1.0,1.0,5.0,1,1,5,2,0,1,1,1,0,1,,0,0,2,1,1,float
4546,192803,RedisModuleScanCB,1,RedisModuleScanCB,"void RedisModuleScanCB (RedisModuleCtx*,robj*,RedisModuleKey*,void*)",module.c,"typedef void (*RedisModuleScanCB)(RedisModuleCtx *ctx, RedisModuleString *keyname, RedisModuleKey *key, void *privdata);",10829.0,10829.0,14.0,55.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
4547,192820,moduleScanCallback,1,moduleScanCallback,"void moduleScanCallback (void*,dictEntry*)",module.c,"static void moduleScanCallback(void *privdata, const dictEntry *de) {
    ScanCBData *data = privdata;
    sds key = dictGetKey(de);
    robj* val = dictGetVal(de);
    RedisModuleString *keyname = createObject(OBJ_STRING,sdsdup(key));

    /* Setup the key handle. */
    RedisModuleKey kp = {0};
    moduleInitKey(&kp, data->ctx, keyname, val, REDISMODULE_READ);

    data->fn(data->ctx, keyname, &kp, data->user_data);

    moduleCloseKey(&kp);
    decrRefCount(keyname);
}",10841.0,10855.0,1.0,4.0,15.0,14,5,20,7,0,11,1,1,0,7,,0,8,4,2,2,void
4548,192885,RM_ScanCursorCreate,1,RM_ScanCursorCreate,RedisModuleScanCursor RM_ScanCursorCreate (void),module.c,"RedisModuleScanCursor *RM_ScanCursorCreate(void) {
    RedisModuleScanCursor* cursor = zmalloc(sizeof(*cursor));
    cursor->cursor = 0;
    cursor->done = 0;
    return cursor;
}",10858.0,10863.0,1.0,1.0,6.0,7,4,5,1,0,3,1,1,0,1,,0,3,2,1,1,RedisModuleScanCursor
4549,192909,RM_ScanCursorRestart,1,RM_ScanCursorRestart,void RM_ScanCursorRestart (RedisModuleScanCursor*),module.c,"void RM_ScanCursorRestart(RedisModuleScanCursor *cursor) {
    cursor->cursor = 0;
    cursor->done = 0;
}",10866.0,10869.0,1.0,1.0,4.0,4,2,2,1,0,2,1,1,0,0,,0,2,2,1,1,void
4550,192924,RM_ScanCursorDestroy,1,RM_ScanCursorDestroy,void RM_ScanCursorDestroy (RedisModuleScanCursor*),module.c,"void RM_ScanCursorDestroy(RedisModuleScanCursor *cursor) {
    zfree(cursor);
}",10872.0,10874.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
4551,192931,RM_Scan,1,RM_Scan,"int RM_Scan (RedisModuleCtx*,RedisModuleScanCursor*,RedisModuleScanCB,void*)",module.c,"int RM_Scan(RedisModuleCtx *ctx, RedisModuleScanCursor *cursor, RedisModuleScanCB fn, void *privdata) {
    if (cursor->done) {
        errno = ENOENT;
        return 0;
    }
    int ret = 1;
    ScanCBData data = { ctx, privdata, fn };
    cursor->cursor = dictScan(ctx->client->db->dict, cursor->cursor, moduleScanCallback, &data);
    if (cursor->cursor == 0) {
        cursor->done = 1;
        ret = 0;
    }
    errno = 0;
    return ret;
}",10932.0,10946.0,1.0,1.0,15.0,18,5,17,8,0,7,3,3,2,1,,0,7,8,4,4,int
4552,192998,RedisModuleScanKeyCB,1,RedisModuleScanKeyCB,"void RedisModuleScanKeyCB (RedisModuleKey*,robj*,robj*,void*)",module.c,"typedef void (*RedisModuleScanKeyCB)(RedisModuleKey *key, RedisModuleString *field, RedisModuleString *value, void *privdata);",10948.0,10948.0,14.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
4553,193011,moduleScanKeyCallback,1,moduleScanKeyCallback,"void moduleScanKeyCallback (void*,dictEntry*)",module.c,"static void moduleScanKeyCallback(void *privdata, const dictEntry *de) {
    ScanKeyCBData *data = privdata;
    sds key = dictGetKey(de);
    robj *o = data->key->value;
    robj *field = createStringObject(key, sdslen(key));
    robj *value = NULL;
    if (o->type == OBJ_SET) {
        value = NULL;
    } else if (o->type == OBJ_HASH) {
        sds val = dictGetVal(de);
        value = createStringObject(val, sdslen(val));
    } else if (o->type == OBJ_ZSET) {
        double *val = (double*)dictGetVal(de);
        value = createStringObjectFromLongDouble(*val, 0);
    }

    data->fn(data->key, field, value, data->user_data);
    decrRefCount(field);
    if (value) decrRefCount(value);
}",10955.0,10974.0,1.0,19.0,20.0,13,3,22,8,0,9,3,3,0,5,,0,7,4,2,2,void
4554,193122,RM_ScanKey,1,RM_ScanKey,"int RM_ScanKey (RedisModuleKey*,RedisModuleScanCursor*,RedisModuleScanKeyCB,void*)",module.c,"int RM_ScanKey(RedisModuleKey *key, RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, void *privdata) {
    if (key == NULL || key->value == NULL) {
        errno = EINVAL;
        return 0;
    }
    dict *ht = NULL;
    robj *o = key->value;
    if (o->type == OBJ_SET) {
        if (o->encoding == OBJ_ENCODING_HT)
            ht = o->ptr;
    } else if (o->type == OBJ_HASH) {
        if (o->encoding == OBJ_ENCODING_HT)
            ht = o->ptr;
    } else if (o->type == OBJ_ZSET) {
        if (o->encoding == OBJ_ENCODING_SKIPLIST)
            ht = ((zset *)o->ptr)->dict;
    } else {
        errno = EINVAL;
        return 0;
    }
    if (cursor->done) {
        errno = ENOENT;
        return 0;
    }
    int ret = 1;
    if (ht) {
        ScanKeyCBData data = { key, privdata, fn };
        cursor->cursor = dictScan(ht, cursor->cursor, moduleScanKeyCallback, &data);
        if (cursor->cursor == 0) {
            cursor->done = 1;
            ret = 0;
        }
    } else if (...",11024.0,11094.0,1.0,19.0,71.0,29,6,32,12,0,8,7,9,3,1,,0,8,8,4,4,int
4555,193464,RM_Fork,1,RM_Fork,"int RM_Fork (RedisModuleForkDoneHandler,void*)",module.c,"int RM_Fork(RedisModuleForkDoneHandler cb, void *user_data) {
    pid_t childpid;

    if ((childpid = redisFork(CHILD_TYPE_MODULE)) == 0) {
        /* Child */
        redisSetProcTitle(""redis-module-fork"");
    } else if (childpid == -1) {
        serverLog(LL_WARNING,""Can't fork for module: %s"", strerror(errno));
    } else {
        /* Parent */
        moduleForkInfo.done_handler = cb;
        moduleForkInfo.done_handler_user_data = user_data;
        serverLog(LL_VERBOSE, ""Module fork started pid: %ld "", (long) childpid);
    }
    return childpid;
}",11112.0,11127.0,1.0,30.0,16.0,2,2,2,1,0,2,2,2,1,2,,0,1,4,2,2,int
4556,193546,RM_SendChildHeartbeat,1,RM_SendChildHeartbeat,void RM_SendChildHeartbeat (double),module.c,"void RM_SendChildHeartbeat(double progress) {
    sendChildInfoGeneric(CHILD_INFO_TYPE_CURRENT_INFO, 0, progress, ""Module fork"");
}",11133.0,11135.0,1.0,1.0,3.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,void
4557,193556,RM_ExitFromChild,1,RM_ExitFromChild,int RM_ExitFromChild (int),module.c,"int RM_ExitFromChild(int retcode) {
    sendChildCowInfo(CHILD_INFO_TYPE_MODULE_COW_SIZE, ""Module fork"");
    exitFromChild(retcode);
    return REDISMODULE_OK;
}",11140.0,11144.0,1.0,11.0,5.0,0,0,2,2,0,2,1,1,0,2,,0,0,2,1,1,int
4558,193570,TerminateModuleForkChild,1,TerminateModuleForkChild,"int TerminateModuleForkChild (int,int)",module.c,"int TerminateModuleForkChild(int child_pid, int wait) {
    /* Module child should be active and pid should match. */
    if (server.child_type != CHILD_TYPE_MODULE ||
        server.child_pid != child_pid) return C_ERR;

    int statloc;
    serverLog(LL_VERBOSE,""Killing running module fork child: %ld"",
        (long) server.child_pid);
    if (kill(server.child_pid,SIGUSR1) != -1 && wait) {
        while(waitpid(server.child_pid, &statloc, 0) !=
              server.child_pid);
    }
    /* Reset the buffer accumulating changes while the child saves. */
    resetChildState();
    moduleForkInfo.done_handler = NULL;
    moduleForkInfo.done_handler_user_data = NULL;
    return C_OK;
}",11149.0,11166.0,1.0,29.0,18.0,23,10,15,7,1,6,4,5,0,2,,0,4,4,2,2,int
4559,193659,RM_KillForkChild,1,RM_KillForkChild,int RM_KillForkChild (int),module.c,"int RM_KillForkChild(int child_pid) {
    /* Kill module child, wait for child exit. */
    if (TerminateModuleForkChild(child_pid,1) == C_OK)
        return REDISMODULE_OK;
    else
        return REDISMODULE_ERR;
}",11170.0,11176.0,1.0,49.0,7.0,1,1,1,1,0,1,2,2,1,1,,0,1,2,1,1,int
4560,193683,ModuleForkDoneHandler,1,ModuleForkDoneHandler,"void ModuleForkDoneHandler (int,int)",module.c,"void ModuleForkDoneHandler(int exitcode, int bysignal) {
    serverLog(LL_NOTICE,
        ""Module fork exited pid: %ld, retcode: %d, bysignal: %d"",
        (long) server.child_pid, exitcode, bysignal);
    if (moduleForkInfo.done_handler) {
        moduleForkInfo.done_handler(exitcode, bysignal,
            moduleForkInfo.done_handler_user_data);
    }

    moduleForkInfo.done_handler = NULL;
    moduleForkInfo.done_handler_user_data = NULL;
}",11178.0,11189.0,1.0,4.0,12.0,12,5,13,5,0,11,2,2,2,1,,0,10,4,2,2,void
4561,193786,RM_SubscribeToServerEvent,1,RM_SubscribeToServerEvent,"int RM_SubscribeToServerEvent (RedisModuleCtx*,RedisModuleEvent,RedisModuleEventCallback)",module.c,"int RM_SubscribeToServerEvent(RedisModuleCtx *ctx, RedisModuleEvent event, RedisModuleEventCallback callback) {
    RedisModuleEventListener *el;

    /* Protect in case of calls from contexts without a module reference. */
    if (ctx->module == NULL) return REDISMODULE_ERR;
    if (event.id >= _REDISMODULE_EVENT_NEXT) return REDISMODULE_ERR;
    if (event.dataver > moduleEventVersions[event.id]) return REDISMODULE_ERR; /* Module compiled with a newer redismodule.h than we support */

    /* Search an event matching this module and event ID. */
    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);
    while((ln = listNext(&li))) {
        el = ln->value;
        if (el->module == ctx->module && el->event.id == event.id)
            break; /* Matching event found. */
    }

    /* Modify or remove the event listener if we already had one. */
    if (ln) {
        if (callback == NULL) {
            listDelNode(RedisModule_EventListeners,ln);
            ...",11511.0,11547.0,1.0,36.0,37.0,32,11,32,9,0,23,9,10,10,6,,0,19,6,3,3,int
4562,193925,RM_IsSubEventSupported,1,RM_IsSubEventSupported,"int RM_IsSubEventSupported (RedisModuleEvent,int64_t)",module.c,"int RM_IsSubEventSupported(RedisModuleEvent event, int64_t subevent) {
    switch (event.id) {
    case REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED:
        return subevent < _REDISMODULE_EVENT_REPLROLECHANGED_NEXT;
    case REDISMODULE_EVENT_PERSISTENCE:
        return subevent < _REDISMODULE_SUBEVENT_PERSISTENCE_NEXT;
    case REDISMODULE_EVENT_FLUSHDB:
        return subevent < _REDISMODULE_SUBEVENT_FLUSHDB_NEXT;
    case REDISMODULE_EVENT_LOADING:
        return subevent < _REDISMODULE_SUBEVENT_LOADING_NEXT;
    case REDISMODULE_EVENT_CLIENT_CHANGE:
        return subevent < _REDISMODULE_SUBEVENT_CLIENT_CHANGE_NEXT;
    case REDISMODULE_EVENT_SHUTDOWN:
        return subevent < _REDISMODULE_SUBEVENT_SHUTDOWN_NEXT;
    case REDISMODULE_EVENT_REPLICA_CHANGE:
        return subevent < _REDISMODULE_EVENT_REPLROLECHANGED_NEXT;
    case REDISMODULE_EVENT_MASTER_LINK_CHANGE:
        return subevent < _REDISMODULE_SUBEVENT_MASTER_NEXT;
    case REDISMODULE_EVENT_CRON_LOOP:
        return...",11553.0,11593.0,1.0,9.0,41.0,18,2,18,2,0,1,3,2,1,0,,0,1,4,2,2,int
4563,194116,moduleFireServerEvent,1,moduleFireServerEvent,"void moduleFireServerEvent (uint64_t,int,void*)",module.c,"void moduleFireServerEvent(uint64_t eid, int subid, void *data) {
    /* Fast path to return ASAP if there is nothing to do, avoiding to
     * setup the iterator and so forth: we want this call to be extremely
     * cheap if there are no registered modules. */
    if (listLength(RedisModule_EventListeners) == 0) return;

    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);
    while((ln = listNext(&li))) {
        RedisModuleEventListener *el = ln->value;
        if (el->event.id == eid) {
            RedisModuleCtx ctx;
            if (eid == REDISMODULE_EVENT_CLIENT_CHANGE) {
                /* In the case of client changes, we're pushing the real client
                 * so the event handler can mutate it if needed. For example,
                 * to change its authentication state in a way that does not
                 * depend on specific commands executed later.
                 */
                moduleCreateContext(&ctx,el->module,REDISMODUL...",11609.0,11689.0,1.0,8.0,81.0,43,12,35,13,28,20,7,14,5,7,,0,14,6,3,3,void
4564,194489,moduleUnsubscribeAllServerEvents,1,moduleUnsubscribeAllServerEvents,void moduleUnsubscribeAllServerEvents (RedisModule*),module.c,"void moduleUnsubscribeAllServerEvents(RedisModule *module) {
    RedisModuleEventListener *el;
    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);

    while((ln = listNext(&li))) {
        el = ln->value;
        if (el->module == module) {
            listDelNode(RedisModule_EventListeners,ln);
            zfree(el);
        }
    }
}",11693.0,11706.0,1.0,1.0,14.0,7,4,11,5,1,8,3,4,2,4,,0,5,2,1,1,void
4565,194525,processModuleLoadingProgressEvent,1,processModuleLoadingProgressEvent,void processModuleLoadingProgressEvent (int),module.c,"void processModuleLoadingProgressEvent(int is_aof) {
    long long now = server.ustime;
    static long long next_event = 0;
    if (now >= next_event) {
        /* Fire the loading progress modules end event. */
        int progress = -1;
        if (server.loading_total_bytes)
            progress = (server.loading_loaded_bytes<<10) / server.loading_total_bytes;
        RedisModuleLoadingProgressV1 fi = {REDISMODULE_LOADING_PROGRESS_VERSION,
                                     server.hz,
                                     progress};
        moduleFireServerEvent(REDISMODULE_EVENT_LOADING_PROGRESS,
                              is_aof?
                                REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF:
                                REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB,
                              &fi);
        /* decide when the next event should fire. */
        next_event = now + 1000000 / server.hz;
    }
}",11708.0,11727.0,1.0,43.0,20.0,21,10,18,6,2,1,3,4,0,1,,0,0,2,1,1,void
4566,194600,moduleNotifyKeyUnlink,1,moduleNotifyKeyUnlink,"void moduleNotifyKeyUnlink (robj*,robj*,int,int)",module.c,"void moduleNotifyKeyUnlink(robj *key, robj *val, int dbid, int flags) {
    server.lazy_expire_disabled++;
    int subevent = REDISMODULE_SUBEVENT_KEY_DELETED;
    if (flags & DB_FLAG_KEY_EXPIRED) {
        subevent = REDISMODULE_SUBEVENT_KEY_EXPIRED;
    } else if (flags & DB_FLAG_KEY_EVICTED) {
        subevent = REDISMODULE_SUBEVENT_KEY_EVICTED;
    } else if (flags & DB_FLAG_KEY_OVERWRITE) {
        subevent = REDISMODULE_SUBEVENT_KEY_OVERWRITTEN;
    }
    KeyInfo info = {dbid, key, val, REDISMODULE_READ};
    moduleFireServerEvent(REDISMODULE_EVENT_KEY, subevent, &info);

    if (val->type == OBJ_MODULE) {
        moduleValue *mv = val->ptr;
        moduleType *mt = mv->type;
        /* We prefer to use the enhanced version. */
        if (mt->unlink2 != NULL) {
            RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
            mt->unlink2(&ctx,mv->value);
        } else if (mt->unlink != NULL) {
            mt->unlink(key,mv->value);
        }
    }
    server.lazy_exp...",11731.0,11756.0,1.0,19.0,26.0,26,12,25,11,1,3,4,5,0,1,,0,2,8,4,4,void
4567,194750,moduleGetFreeEffort,1,moduleGetFreeEffort,"size_t moduleGetFreeEffort (robj*,robj*,int)",module.c,"size_t moduleGetFreeEffort(robj *key, robj *val, int dbid) {
    moduleValue *mv = val->ptr;
    moduleType *mt = mv->type;
    size_t effort = 1;
    /* We prefer to use the enhanced version. */
    if (mt->free_effort2 != NULL) {
        RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
        effort = mt->free_effort2(&ctx,mv->value);
    } else if (mt->free_effort != NULL) {
        effort = mt->free_effort(key,mv->value);
    }  

    return effort;
}",11761.0,11774.0,1.0,1.0,14.0,14,6,16,8,1,2,2,2,0,0,,0,2,6,3,3,size_t
4568,194821,moduleGetMemUsage,1,moduleGetMemUsage,"size_t moduleGetMemUsage (robj*,robj*,size_t,int)",module.c,"size_t moduleGetMemUsage(robj *key, robj *val, size_t sample_size, int dbid) {
    moduleValue *mv = val->ptr;
    moduleType *mt = mv->type;
    size_t size = 0;
    /* We prefer to use the enhanced version. */
    if (mt->mem_usage2 != NULL) {
        RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
        size = mt->mem_usage2(&ctx, mv->value, sample_size);
    } else if (mt->mem_usage != NULL) {
        size = mt->mem_usage(mv->value);
    } 

    return size;
}",11778.0,11791.0,1.0,1.0,14.0,14,6,17,9,0,2,2,2,0,0,,0,2,8,4,4,size_t
4569,194893,dictCStringKeyHash,1,dictCStringKeyHash,uint64_t dictCStringKeyHash (void*),module.c,"uint64_t dictCStringKeyHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
}",11800.0,11802.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
4570,194907,dictCStringKeyCompare,1,dictCStringKeyCompare,"int dictCStringKeyCompare (dict*,void*,void*)",module.c,"int dictCStringKeyCompare(dict *d, const void *key1, const void *key2) {
    UNUSED(d);
    return strcmp(key1,key2) == 0;
}",11804.0,11807.0,1.0,4.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,int
4571,194937,moduleRegisterApi,1,moduleRegisterApi,"int moduleRegisterApi (char*,void*)",module.c,"int moduleRegisterApi(const char *funcname, void *funcptr) {
    return dictAdd(server.moduleapi, (char*)funcname, funcptr);
}",11819.0,11821.0,1.0,1.0,3.0,2,2,3,3,0,1,1,1,0,1,,0,0,4,2,2,int
4572,194952,moduleRegisterCoreAPI,1,moduleRegisterCoreAPI,void moduleRegisterCoreAPI (void),module.c,"void moduleRegisterCoreAPI(void) {
    server.moduleapi = dictCreate(&moduleAPIDictType);
    server.sharedapi = dictCreate(&moduleAPIDictType);
    REGISTER_API(Alloc);
    REGISTER_API(TryAlloc);
    REGISTER_API(Calloc);
    REGISTER_API(Realloc);
    REGISTER_API(Free);
    REGISTER_API(Strdup);
    REGISTER_API(CreateCommand);
    REGISTER_API(GetCommand);
    REGISTER_API(CreateSubcommand);
    REGISTER_API(SetCommandInfo);
    REGISTER_API(SetCommandACLCategories);
    REGISTER_API(SetModuleAttribs);
    REGISTER_API(IsModuleNameBusy);
    REGISTER_API(WrongArity);
    REGISTER_API(ReplyWithLongLong);
    REGISTER_API(ReplyWithError);
    REGISTER_API(ReplyWithErrorFormat);
    REGISTER_API(ReplyWithSimpleString);
    REGISTER_API(ReplyWithArray);
    REGISTER_API(ReplyWithMap);
    REGISTER_API(ReplyWithSet);
    REGISTER_API(ReplyWithAttribute);
    REGISTER_API(ReplyWithNullArray);
    REGISTER_API(ReplyWithEmptyArray);
    REGISTER_API(ReplySetArrayLength);
    REGISTER_A...",13494.0,13849.0,1.0,4.0,356.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
4573,194957,moduleInitModulesSystemLast,1,moduleInitModulesSystemLast,void moduleInitModulesSystemLast (void),module.c,"void moduleInitModulesSystemLast(void) {
}",11833.0,11834.0,1.0,1.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
4574,194973,moduleInitModulesSystem,1,moduleInitModulesSystem,void moduleInitModulesSystem (void),module.c,"void moduleInitModulesSystem(void) {
    moduleUnblockedClients = listCreate();
    server.loadmodule_queue = listCreate();
    server.module_configs_queue = dictCreate(&sdsKeyValueHashDictType);
    modules = dictCreate(&modulesDictType);
    moduleAuthCallbacks = listCreate();

    /* Set up the keyspace notification subscriber list and static client */
    moduleKeyspaceSubscribers = listCreate();

    modulePostExecUnitJobs = listCreate();

    /* Set up filter list */
    moduleCommandFilters = listCreate();

    moduleRegisterCoreAPI();

    /* Create a pipe for module threads to be able to wake up the redis main thread.
     * Make the pipe non blocking. This is just a best effort aware mechanism
     * and we do not want to block not in the read nor in the write half.
     * Enable close-on-exec flag on pipes in case of the fork-exec system calls in
     * sentinels or redis servers. */
    if (anetPipe(server.module_pipe, O_CLOEXEC|O_NONBLOCK, O_CLOEXEC|O_NONBLOCK) == -1) {...",11847.0,11887.0,1.0,8.0,41.0,32,15,22,16,0,26,2,2,1,14,,0,23,2,1,1,void
4575,195079,modulesCron,1,modulesCron,void modulesCron (void),module.c,"void modulesCron(void) {
    /* Check number of temporary clients in the pool and free the unused ones
     * since the last cron. moduleTempClientMinCount tracks minimum count of
     * clients in the pool since the last cron. This is the number of clients
     * that we didn't use for the last cron period. */

    /* Limit the max client count to be freed at once to avoid latency spikes.*/
    int iteration = 50;
    /* We are freeing clients if we have more than 8 unused clients. Keeping
     * small amount of clients to avoid client allocation costs if temporary
     * clients are required after some idle period. */
    const unsigned int min_client = 8;
    while (iteration > 0 && moduleTempClientCount > 0 && moduleTempClientMinCount > min_client) {
        client *c = moduleTempClients[--moduleTempClientCount];
        freeClient(c);
        iteration--;
        moduleTempClientMinCount--;
    }
    moduleTempClientMinCount = moduleTempClientCount;

    /* Shrink moduleTempCli...",11889.0,11914.0,1.0,1.0,26.0,21,9,22,8,1,16,3,3,5,2,,0,15,2,1,1,void
4576,195143,moduleLoadQueueEntryFree,1,moduleLoadQueueEntryFree,void moduleLoadQueueEntryFree (moduleLoadQueueEntry*),module.c,"void moduleLoadQueueEntryFree(struct moduleLoadQueueEntry *loadmod) {
    if (!loadmod) return;
    sdsfree(loadmod->path);
    for (int i = 0; i < loadmod->argc; i++) {
        decrRefCount(loadmod->argv[i]);
    }
    zfree(loadmod->argv);
    zfree(loadmod);
}",11916.0,11924.0,1.0,1.0,9.0,8,5,9,2,2,8,3,3,1,4,,0,4,2,1,1,void
4577,195183,moduleRemoveConfigs,1,moduleRemoveConfigs,void moduleRemoveConfigs (RedisModule*),module.c,"void moduleRemoveConfigs(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(module->module_configs, &li);
    while ((ln = listNext(&li))) {
        ModuleConfig *config = listNodeValue(ln);
        sds module_name = sdsnew(module->name);
        sds full_name = sdscat(sdscat(module_name, "".""), config->name); /* ModuleName.ModuleConfig */
        removeConfig(full_name);
        sdsfree(full_name);
    }
}",11927.0,11938.0,1.0,31.0,12.0,10,3,14,6,2,11,2,2,1,7,,0,8,2,1,1,void
4578,195233,moduleLoadFromQueue,1,moduleLoadFromQueue,void moduleLoadFromQueue (void),module.c,"void moduleLoadFromQueue(void) {
    listIter li;
    listNode *ln;

    listRewind(server.loadmodule_queue,&li);
    while((ln = listNext(&li))) {
        struct moduleLoadQueueEntry *loadmod = ln->value;
        if (moduleLoad(loadmod->path,(void **)loadmod->argv,loadmod->argc, 0)
            == C_ERR)
        {
            serverLog(LL_WARNING,
                ""Can't load module from %s: server aborting"",
                loadmod->path);
            exit(1);
        }
        moduleLoadQueueEntryFree(loadmod);
        listDelNode(server.loadmodule_queue, ln);
    }
    if (dictSize(server.module_configs_queue)) {
        serverLog(LL_WARNING, ""Module Configuration detected without loadmodule directive or no ApplyConfig call: aborting"");
        exit(1);
    }
}",11949.0,11971.0,1.0,15.0,23.0,28,11,18,4,0,12,4,5,5,7,,0,7,2,1,1,void
4579,195351,moduleFreeModuleStructure,1,moduleFreeModuleStructure,void moduleFreeModuleStructure (RedisModule*),module.c,"void moduleFreeModuleStructure(struct RedisModule *module) {
    listRelease(module->types);
    listRelease(module->filters);
    listRelease(module->usedby);
    listRelease(module->using);
    listRelease(module->module_configs);
    sdsfree(module->name);
    moduleLoadQueueEntryFree(module->loadmod);
    zfree(module);
}",11973.0,11982.0,1.0,1.0,10.0,7,1,8,1,2,15,1,1,0,8,,0,7,2,1,1,void
4580,195386,moduleFreeArgs,1,moduleFreeArgs,"void moduleFreeArgs (redisCommandArg*,int)",module.c,"void moduleFreeArgs(struct redisCommandArg *args, int num_args) {
    for (int j = 0; j < num_args; j++) {
        zfree((char *)args[j].name);
        zfree((char *)args[j].token);
        zfree((char *)args[j].summary);
        zfree((char *)args[j].since);
        zfree((char *)args[j].deprecated_since);
        zfree((char *)args[j].display_text);

        if (args[j].subargs) {
            moduleFreeArgs(args[j].subargs, args[j].num_args);
        }
    }
    zfree(args);
}",11984.0,11998.0,1.0,1.0,15.0,26,5,22,3,1,7,3,4,0,7,,0,0,4,2,2,void
4581,195472,moduleFreeCommand,1,moduleFreeCommand,"int moduleFreeCommand (RedisModule*,redisCommand*)",module.c,"int moduleFreeCommand(struct RedisModule *module, struct redisCommand *cmd) {
    if (cmd->proc != RedisModuleCommandDispatcher)
        return C_ERR;

    RedisModuleCommand *cp = cmd->module_cmd;
    if (cp->module != module)
        return C_ERR;

    /* Free everything except cmd->fullname and cmd itself. */
    for (int j = 0; j < cmd->key_specs_num; j++) {
        if (cmd->key_specs[j].notes)
            zfree((char *)cmd->key_specs[j].notes);
        if (cmd->key_specs[j].begin_search_type == KSPEC_BS_KEYWORD)
            zfree((char *)cmd->key_specs[j].bs.keyword.keyword);
    }
    zfree(cmd->key_specs);
    for (int j = 0; cmd->tips && cmd->tips[j]; j++)
        zfree((char *)cmd->tips[j]);
    zfree(cmd->tips);
    for (int j = 0; cmd->history && cmd->history[j].since; j++) {
        zfree((char *)cmd->history[j].since);
        zfree((char *)cmd->history[j].changes);
    }
    zfree(cmd->history);
    zfree((char *)cmd->summary);
    zfree((char *)cmd->since);
    zfree(...",12006.0,12058.0,1.0,15.0,53.0,82,13,60,9,1,56,13,17,12,23,,0,36,4,2,2,int
4582,195770,moduleUnregisterCommands,1,moduleUnregisterCommands,void moduleUnregisterCommands (RedisModule*),module.c,"void moduleUnregisterCommands(struct RedisModule *module) {
    /* Unregister all the commands registered by this module. */
    dictIterator *di = dictGetSafeIterator(server.commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (moduleFreeCommand(module, cmd) != C_OK) continue;

        serverAssert(dictDelete(server.commands, cmd->fullname) == DICT_OK);
        serverAssert(dictDelete(server.orig_commands, cmd->fullname) == DICT_OK);
        sdsfree((sds)cmd->declared_name);
        sdsfree(cmd->fullname);
        zfree(cmd);
    }
    dictReleaseIterator(di);
}",12060.0,12075.0,1.0,46.0,16.0,23,9,17,6,2,16,4,4,2,12,,0,8,2,1,1,void
4583,195864,parseLoadexArguments,1,parseLoadexArguments,"int parseLoadexArguments (robj***,int*)",module.c,"int parseLoadexArguments(RedisModuleString ***module_argv, int *module_argc) {
    int args_specified = 0;
    RedisModuleString **argv = *module_argv;
    int argc = *module_argc;
    for (int i = 0; i < argc; i++) {
        char *arg_val = argv[i]->ptr;
        if (!strcasecmp(arg_val, ""CONFIG"")) {
            if (i + 2 >= argc) {
                serverLog(LL_NOTICE, ""CONFIG specified without name value pair"");
                return REDISMODULE_ERR;
            }
            sds name = sdsdup(argv[i + 1]->ptr);
            sds value = sdsdup(argv[i + 2]->ptr);
            if (!dictReplace(server.module_configs_queue, name, value)) sdsfree(name);
            i += 2;
        } else if (!strcasecmp(arg_val, ""ARGS"")) {
            args_specified = 1;
            i++;
            if (i >= argc) {
                *module_argv = NULL;
                *module_argc = 0;
            } else {
                *module_argv = argv + i;
                *module_argc = argc - i;
            }
   ...",12080.0,12116.0,1.0,25.0,37.0,32,11,30,11,0,5,6,11,1,5,,0,3,4,2,2,int
4584,196059,moduleLoad,1,moduleLoad,"int moduleLoad (char*,void**,int,int)",module.c,"int moduleLoad(const char *path, void **module_argv, int module_argc, int is_loadex) {
    int (*onload)(void *, void **, int);
    void *handle;

    struct stat st;
    if (stat(path, &st) == 0) {
        /* This check is best effort */
        if (!(st.st_mode & (S_IXUSR  | S_IXGRP | S_IXOTH))) {
            serverLog(LL_WARNING, ""Module %s failed to load: It does not have execute permissions."", path);
            return C_ERR;
        }
    }

    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
    if (handle == NULL) {
        serverLog(LL_WARNING, ""Module %s failed to load: %s"", path, dlerror());
        return C_ERR;
    }
    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,""RedisModule_OnLoad"");
    if (onload == NULL) {
        dlclose(handle);
        serverLog(LL_WARNING,
            ""Module %s does not export RedisModule_OnLoad() ""
            ""symbol. Module not loaded."",path);
        return C_ERR;
    }
    RedisModuleCtx ctx;
    moduleCreateContext(&...",12120.0,12211.0,1.0,12.0,92.0,121,18,87,20,1,53,12,14,5,26,,0,30,8,4,4,int
4585,196065,onload,1,moduleLoad.onload,"int moduleLoad.onload (void*,void**,int)",module.c,"int (*onload)(void *, void **, int);",12121.0,12121.0,9.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
4586,196526,moduleUnload,1,moduleUnload,"int moduleUnload (sds,char**)",module.c,"int moduleUnload(sds name, const char **errmsg) {
    struct RedisModule *module = dictFetchValue(modules,name);

    if (module == NULL) {
        *errmsg = ""no such module with that name"";
        return C_ERR;
    } else if (listLength(module->types)) {
        *errmsg = ""the module exports one or more module-side data ""
                  ""types, can't unload"";
        return C_ERR;
    } else if (listLength(module->usedby)) {
        *errmsg = ""the module exports APIs used by other modules. ""
                  ""Please unload them first and try again"";
        return C_ERR;
    } else if (module->blocked_clients) {
        *errmsg = ""the module has blocked clients. ""
                  ""Please wait for them to be unblocked and try again"";
        return C_ERR;
    } else if (moduleHoldsTimer(module)) {
        *errmsg = ""the module holds timer that is not fired. ""
                  ""Please stop the timer or wait until it fires."";
        return C_ERR;
    }

    /* Give module a c...",12216.0,12290.0,1.0,15.0,75.0,38,11,44,12,1,27,6,8,1,19,,0,9,4,2,2,int
4587,196627,onunload,1,moduleUnload.onunload,int moduleUnload.onunload (void*),module.c,int (*onunload)(void *);,12241.0,12241.0,9.0,27.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4588,196810,modulePipeReadable,1,modulePipeReadable,"void modulePipeReadable (aeEventLoop*,int,void*,int)",module.c,"void modulePipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);
    UNUSED(privdata);

    char buf[128];
    while (read(fd, buf, sizeof(buf)) == sizeof(buf));

    /* Handle event loop events if pipe was written from event loop API */
    eventLoopHandleOneShotEvents();
}",12292.0,12303.0,1.0,4.0,12.0,7,3,12,5,0,1,2,2,0,1,,0,0,8,4,4,void
4589,196853,addReplyLoadedModules,1,addReplyLoadedModules,void addReplyLoadedModules (client*),module.c,"void addReplyLoadedModules(client *c) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    addReplyArrayLen(c,dictSize(modules));
    while ((de = dictNext(di)) != NULL) {
        sds name = dictGetKey(de);
        struct RedisModule *module = dictGetVal(de);
        sds path = module->loadmod->path;
        addReplyMapLen(c,4);
        addReplyBulkCString(c,""name"");
        addReplyBulkCBuffer(c,name,sdslen(name));
        addReplyBulkCString(c,""ver"");
        addReplyLongLong(c,module->ver);
        addReplyBulkCString(c,""path"");
        addReplyBulkCBuffer(c,path,sdslen(path));
        addReplyBulkCString(c,""args"");
        addReplyArrayLen(c,module->loadmod->argc);
        for (int i = 0; i < module->loadmod->argc; i++) {
            addReplyBulk(c,module->loadmod->argv[i]);
        }
    }
    dictReleaseIterator(di);
}",12307.0,12330.0,1.0,23.0,24.0,23,6,37,9,1,29,3,4,2,18,,0,17,2,1,1,void
4590,196970,genModulesInfoStringRenderModulesList,1,genModulesInfoStringRenderModulesList,sds genModulesInfoStringRenderModulesList (list*),module.c,"sds genModulesInfoStringRenderModulesList(list *l) {
    listIter li;
    listNode *ln;
    listRewind(l,&li);
    sds output = sdsnew(""["");
    while((ln = listNext(&li))) {
        RedisModule *module = ln->value;
        output = sdscat(output,module->name);
        if (ln != listLast(l))
            output = sdscat(output,""|"");
    }
    output = sdscat(output,""]"");
    return output;
}",12334.0,12347.0,1.0,18.0,14.0,12,4,18,5,2,9,3,4,2,6,,0,8,2,1,1,sds
4591,197028,genModulesInfoStringRenderModuleOptions,1,genModulesInfoStringRenderModuleOptions,sds genModulesInfoStringRenderModuleOptions (RedisModule*),module.c,"sds genModulesInfoStringRenderModuleOptions(struct RedisModule *module) {
    sds output = sdsnew(""["");
    if (module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS)
        output = sdscat(output,""handle-io-errors|"");
    if (module->options & REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD)
        output = sdscat(output,""handle-repl-async-load|"");
    if (module->options & REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED)
        output = sdscat(output,""no-implicit-signal-modified|"");
    output = sdstrim(output,""|"");
    output = sdscat(output,""]"");
    return output;
}",12350.0,12361.0,1.0,26.0,12.0,15,4,15,2,1,9,4,4,3,6,,0,9,2,1,1,sds
4592,197098,genModulesInfoString,1,genModulesInfoString,sds genModulesInfoString (sds),module.c,"sds genModulesInfoString(sds info) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        sds name = dictGetKey(de);
        struct RedisModule *module = dictGetVal(de);

        sds usedby = genModulesInfoStringRenderModulesList(module->usedby);
        sds using = genModulesInfoStringRenderModulesList(module->using);
        sds options = genModulesInfoStringRenderModuleOptions(module);
        info = sdscatfmt(info,
            ""module:name=%S,ver=%i,api=%i,filters=%i,""
            ""usedby=%S,using=%S,options=%S\r\n"",
                name, module->ver, module->apiver,
                (int)listLength(module->filters), usedby, using, options);
        sdsfree(usedby);
        sdsfree(using);
        sdsfree(options);
    }
    dictReleaseIterator(di);
    return info;
}",12369.0,12391.0,1.0,21.0,23.0,17,4,30,10,1,19,2,2,1,12,,0,15,2,1,1,sds
4593,197183,isModuleConfigNameRegistered,1,isModuleConfigNameRegistered,"int isModuleConfigNameRegistered (RedisModule*,sds)",module.c,"int isModuleConfigNameRegistered(RedisModule *module, sds name) {
    listNode *match = listSearchKey(module->module_configs, (void *) name);
    return match != NULL;
}",12398.0,12401.0,1.0,1.0,4.0,4,4,5,4,1,2,1,1,0,1,,0,2,4,2,2,int
4594,197203,moduleVerifyConfigFlags,1,moduleVerifyConfigFlags,"int moduleVerifyConfigFlags (unsigned int,configType)",module.c,"int moduleVerifyConfigFlags(unsigned int flags, configType type) {
    if ((flags & ~(REDISMODULE_CONFIG_DEFAULT
                    | REDISMODULE_CONFIG_IMMUTABLE
                    | REDISMODULE_CONFIG_SENSITIVE
                    | REDISMODULE_CONFIG_HIDDEN
                    | REDISMODULE_CONFIG_PROTECTED
                    | REDISMODULE_CONFIG_DENY_LOADING
                    | REDISMODULE_CONFIG_BITFLAGS
                    | REDISMODULE_CONFIG_MEMORY))) {
        serverLogRaw(LL_WARNING, ""Invalid flag(s) for configuration"");
        return REDISMODULE_ERR;
    }
    if (type != NUMERIC_CONFIG && flags & REDISMODULE_CONFIG_MEMORY) {
        serverLogRaw(LL_WARNING, ""Numeric flag provided for non-numeric configuration."");
        return REDISMODULE_ERR;
    }
    if (type != ENUM_CONFIG && flags & REDISMODULE_CONFIG_BITFLAGS) {
        serverLogRaw(LL_WARNING, ""Enum flag provided for non-enum configuration."");
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",12404.0,12425.0,1.0,19.0,22.0,24,6,7,4,1,3,4,4,0,3,,0,0,4,2,2,int
4595,197316,moduleVerifyConfigName,1,moduleVerifyConfigName,int moduleVerifyConfigName (sds),module.c,"int moduleVerifyConfigName(sds name) {
    if (sdslen(name) == 0) {
        serverLogRaw(LL_WARNING, ""Module config names cannot be an empty string."");
        return REDISMODULE_ERR;
    }
    for (size_t i = 0 ; i < sdslen(name) ; ++i) {
        char curr_char = name[i];
        if ((curr_char >= 'a' && curr_char <= 'z') ||
            (curr_char >= 'A' && curr_char <= 'Z') ||
            (curr_char >= '0' && curr_char <= '9') ||
            (curr_char == '_') || (curr_char == '-'))
        {
            continue;
        }
        serverLog(LL_WARNING, ""Invalid character %c in Module Config name %s."", curr_char, name);
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",12427.0,12445.0,1.0,21.0,19.0,23,10,18,4,1,4,5,5,2,4,,0,2,2,1,1,int
4596,197422,propagateErrorString,1,propagateErrorString,"void propagateErrorString (robj*,char**)",module.c,"static void propagateErrorString(RedisModuleString *err_in, const char **err) {
    if (err_in) {
        redis_strlcpy(configerr, err_in->ptr, CONFIG_ERR_SIZE);
        decrRefCount(err_in);
        *err = configerr;
    }
}",12451.0,12457.0,1.0,33.0,7.0,3,3,6,3,5,4,2,2,0,2,,0,2,4,2,2,void
4597,197445,setModuleBoolConfig,1,setModuleBoolConfig,"int setModuleBoolConfig (ModuleConfig*,int,char**)",module.c,"int setModuleBoolConfig(ModuleConfig *config, int val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_bool(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12459.0,12464.0,1.0,4.0,6.0,9,6,11,6,2,3,1,1,0,1,,0,2,6,3,3,int
4598,197488,setModuleStringConfig,1,setModuleStringConfig,"int setModuleStringConfig (ModuleConfig*,sds,char**)",module.c,"int setModuleStringConfig(ModuleConfig *config, sds strval, const char **err) {
    RedisModuleString *error = NULL;
    RedisModuleString *new = createStringObject(strval, sdslen(strval));
    int return_code = config->set_fn.set_string(config->name, new, config->privdata, &error);
    propagateErrorString(error, err);
    decrRefCount(new);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12466.0,12473.0,1.0,4.0,8.0,10,6,15,7,2,6,1,1,0,4,,0,4,6,3,3,int
4599,197542,setModuleEnumConfig,1,setModuleEnumConfig,"int setModuleEnumConfig (ModuleConfig*,int,char**)",module.c,"int setModuleEnumConfig(ModuleConfig *config, int val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_enum(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12475.0,12480.0,1.0,4.0,6.0,9,6,11,6,2,3,1,1,0,1,,0,2,6,3,3,int
4600,197585,setModuleNumericConfig,1,setModuleNumericConfig,"int setModuleNumericConfig (ModuleConfig*,long long,char**)",module.c,"int setModuleNumericConfig(ModuleConfig *config, long long val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_numeric(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",12482.0,12487.0,1.0,4.0,6.0,9,6,11,6,1,3,1,1,0,1,,0,2,6,3,3,int
4601,197628,getModuleBoolConfig,1,getModuleBoolConfig,int getModuleBoolConfig (ModuleConfig*),module.c,"int getModuleBoolConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_bool(module_config->name, module_config->privdata);
}",12491.0,12493.0,1.0,1.0,3.0,4,2,3,1,3,2,1,1,0,0,,0,2,2,1,1,int
4602,197646,getModuleStringConfig,1,getModuleStringConfig,sds getModuleStringConfig (ModuleConfig*),module.c,"sds getModuleStringConfig(ModuleConfig *module_config) {
    RedisModuleString *val = module_config->get_fn.get_string(module_config->name, module_config->privdata);
    return val ? sdsdup(val->ptr) : NULL;
}",12495.0,12498.0,1.0,4.0,4.0,7,4,7,3,3,3,1,1,0,1,,0,2,2,1,1,sds
4603,197676,getModuleEnumConfig,1,getModuleEnumConfig,int getModuleEnumConfig (ModuleConfig*),module.c,"int getModuleEnumConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_enum(module_config->name, module_config->privdata);
}",12500.0,12502.0,1.0,1.0,3.0,4,2,3,1,3,2,1,1,0,0,,0,2,2,1,1,int
4604,197694,getModuleNumericConfig,1,getModuleNumericConfig,long long getModuleNumericConfig (ModuleConfig*),module.c,"long long getModuleNumericConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_numeric(module_config->name, module_config->privdata);
}",12504.0,12506.0,1.0,1.0,3.0,4,2,3,1,3,2,1,1,0,0,,0,2,2,1,1,long long
4605,197712,loadModuleConfigs,1,loadModuleConfigs,int loadModuleConfigs (RedisModule*),module.c,"int loadModuleConfigs(RedisModule *module) {
    listIter li;
    listNode *ln;
    const char *err = NULL;
    listRewind(module->module_configs, &li);
    while ((ln = listNext(&li))) {
        ModuleConfig *module_config = listNodeValue(ln);
        sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module->name, module_config->name);
        dictEntry *config_argument = dictFind(server.module_configs_queue, config_name);
        if (config_argument) {
            if (!performModuleConfigSetFromName(dictGetKey(config_argument), dictGetVal(config_argument), &err)) {
                serverLog(LL_WARNING, ""Issue during loading of configuration %s : %s"", (sds) dictGetKey(config_argument), err);
                sdsfree(config_name);
                dictEmpty(server.module_configs_queue, NULL);
                return REDISMODULE_ERR;
            }
        } else {
            if (!performModuleConfigSetDefaultFromName(config_name, &err)) {
                serverLog(LL_WARNING, ""Issue att...",12510.0,12539.0,1.0,38.0,30.0,22,8,29,9,1,19,4,7,4,14,,0,13,2,1,1,int
4606,197870,addModuleConfigApply,1,addModuleConfigApply,"void addModuleConfigApply (list*,ModuleConfig*)",module.c,"void addModuleConfigApply(list *module_configs, ModuleConfig *module_config) {
    if (!module_config->apply_fn) return;
    listIter li;
    listNode *ln;
    ModuleConfig *pending_apply;
    listRewind(module_configs, &li);
    while ((ln = listNext(&li))) {
        pending_apply = listNodeValue(ln);
        if (pending_apply->apply_fn == module_config->apply_fn && pending_apply->privdata == module_config->privdata) {
            return;
        }
    }
    listAddNodeTail(module_configs, module_config);
}",12542.0,12555.0,1.0,24.0,14.0,14,6,14,5,0,9,4,5,6,3,,0,7,4,2,2,void
4607,197926,moduleConfigApplyConfig,1,moduleConfigApplyConfig,"int moduleConfigApplyConfig (list*,char**,char**)",module.c,"int moduleConfigApplyConfig(list *module_configs, const char **err, const char **err_arg_name) {
    if (!listLength(module_configs)) return 1;
    listIter li;
    listNode *ln;
    ModuleConfig *module_config;
    RedisModuleString *error = NULL;
    RedisModuleCtx ctx;

    listRewind(module_configs, &li);
    while ((ln = listNext(&li))) {
        module_config = listNodeValue(ln);
        moduleCreateContext(&ctx, module_config->module, REDISMODULE_CTX_NONE);
        if (module_config->apply_fn(&ctx, module_config->privdata, &error)) {
            if (err_arg_name) *err_arg_name = module_config->name;
            propagateErrorString(error, err);
            moduleFreeContext(&ctx);
            return 0;
        }
        moduleFreeContext(&ctx);
    }
    return 1;
}",12558.0,12579.0,1.0,9.0,22.0,19,5,24,9,2,12,5,8,4,6,,0,7,6,3,3,int
4608,198017,createModuleConfig,1,createModuleConfig,"ModuleConfig createModuleConfig (sds,RedisModuleConfigApplyFunc,void*,RedisModule*)",module.c,"ModuleConfig *createModuleConfig(sds name, RedisModuleConfigApplyFunc apply_fn, void *privdata, RedisModule *module) {
    ModuleConfig *new_config = zmalloc(sizeof(ModuleConfig));
    new_config->name = sdsdup(name);
    new_config->apply_fn = apply_fn;
    new_config->privdata = privdata;
    new_config->module = module;
    return new_config;
}",12586.0,12593.0,1.0,1.0,8.0,10,3,11,6,4,6,1,1,0,2,,0,6,8,4,4,ModuleConfig
4609,198054,moduleConfigValidityCheck,1,moduleConfigValidityCheck,"int moduleConfigValidityCheck (RedisModule*,sds,unsigned int,configType)",module.c,"int moduleConfigValidityCheck(RedisModule *module, sds name, unsigned int flags, configType type) {
    if (!module->onload) {
        errno = EBUSY;
        return REDISMODULE_ERR;
    }
    if (moduleVerifyConfigFlags(flags, type) || moduleVerifyConfigName(name)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    if (isModuleConfigNameRegistered(module, name)) {
        serverLog(LL_WARNING, ""Configuration by the name: %s already registered"", name);
        errno = EALREADY;
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",12595.0,12610.0,1.0,15.0,16.0,9,7,14,9,4,5,4,4,4,4,,0,4,8,4,4,int
4610,198125,maskModuleConfigFlags,1,maskModuleConfigFlags,unsigned int maskModuleConfigFlags (unsigned int),module.c,"unsigned int maskModuleConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_DEFAULT) new_flags |= MODIFIABLE_CONFIG;
    if (flags & REDISMODULE_CONFIG_IMMUTABLE) new_flags |= IMMUTABLE_CONFIG;
    if (flags & REDISMODULE_CONFIG_HIDDEN) new_flags |= HIDDEN_CONFIG;
    if (flags & REDISMODULE_CONFIG_PROTECTED) new_flags |= PROTECTED_CONFIG;
    if (flags & REDISMODULE_CONFIG_DENY_LOADING) new_flags |= DENY_LOADING_CONFIG;
    return new_flags;
}",12612.0,12620.0,1.0,16.0,9.0,14,3,12,2,4,0,6,6,0,0,,0,0,2,1,1,unsigned int
4611,198212,maskModuleNumericConfigFlags,1,maskModuleNumericConfigFlags,unsigned int maskModuleNumericConfigFlags (unsigned int),module.c,"unsigned int maskModuleNumericConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_MEMORY) new_flags |= MEMORY_CONFIG;
    return new_flags;
}",12622.0,12626.0,1.0,16.0,5.0,4,3,4,2,1,0,2,2,0,0,,0,0,2,1,1,unsigned int
4612,198239,maskModuleEnumConfigFlags,1,maskModuleEnumConfigFlags,unsigned int maskModuleEnumConfigFlags (unsigned int),module.c,"unsigned int maskModuleEnumConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_BITFLAGS) new_flags |= MULTI_ARG_CONFIG;
    return new_flags;
}",12628.0,12632.0,1.0,16.0,5.0,4,3,4,2,1,0,2,2,0,0,,0,0,2,1,1,unsigned int
4613,198266,RM_RegisterStringConfig,1,RM_RegisterStringConfig,"int RM_RegisterStringConfig (RedisModuleCtx*,char*,char*,unsigned int,RedisModuleConfigGetStringFunc,RedisModuleConfigSetStringFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterStringConfig(RedisModuleCtx *ctx, const char *name, const char *default_val, unsigned int flags, RedisModuleConfigGetStringFunc getfn, RedisModuleConfigSetStringFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, NUMERIC_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_string = getfn;
    new_config->set_fn.set_string = setfn;
    listAddNodeTail(module->module_configs, new_config);
    flags = maskModuleConfigFlags(flags);
    addModuleStringConfig(module->name, name, flags, new_config, default_val ? sdsnew(default_val) : NULL);
    return REDISMODULE_OK;
}",12709.0,12724.0,1.0,15.0,16.0,14,4,30,13,0,12,2,2,1,9,,0,8,16,8,8,int
4614,198351,RM_RegisterBoolConfig,1,RM_RegisterBoolConfig,"int RM_RegisterBoolConfig (RedisModuleCtx*,char*,int,unsigned int,RedisModuleConfigGetBoolFunc,RedisModuleConfigSetBoolFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterBoolConfig(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, RedisModuleConfigGetBoolFunc getfn, RedisModuleConfigSetBoolFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, BOOL_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_bool = getfn;
    new_config->set_fn.set_bool = setfn;
    listAddNodeTail(module->module_configs, new_config);
    flags = maskModuleConfigFlags(flags);
    addModuleBoolConfig(module->name, name, flags, new_config, default_val);
    return REDISMODULE_OK;
}",12729.0,12744.0,1.0,15.0,16.0,13,3,28,12,0,11,2,2,1,8,,0,7,16,8,8,int
4615,198432,RM_RegisterEnumConfig,1,RM_RegisterEnumConfig,"int RM_RegisterEnumConfig (RedisModuleCtx*,char*,int,unsigned int,char**,int*,int,RedisModuleConfigGetEnumFunc,RedisModuleConfigSetEnumFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterEnumConfig(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, const char **enum_values, const int *int_values, int num_enum_vals, RedisModuleConfigGetEnumFunc getfn, RedisModuleConfigSetEnumFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, ENUM_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_enum = getfn;
    new_config->set_fn.set_enum = setfn;
    configEnum *enum_vals = zmalloc((num_enum_vals + 1) * sizeof(configEnum));
    for (int i = 0; i < num_enum_vals; i++) {
        enum_vals[i].name = zstrdup(enum_values[i]);
        enum_vals[i].val = int_values[i];
    }
    enum_vals[num_enum_vals].name = NULL;
    enum_vals...",12775.0,12797.0,1.0,15.0,23.0,34,9,49,19,0,14,3,3,1,11,,0,10,22,11,11,int
4616,198575,RM_RegisterNumericConfig,1,RM_RegisterNumericConfig,"int RM_RegisterNumericConfig (RedisModuleCtx*,char*,long long,unsigned int,long long,long long,RedisModuleConfigGetNumericFunc,RedisModuleConfigSetNumericFunc,RedisModuleConfigApplyFunc,void*)",module.c,"int RM_RegisterNumericConfig(RedisModuleCtx *ctx, const char *name, long long default_val, unsigned int flags, long long min, long long max, RedisModuleConfigGetNumericFunc getfn, RedisModuleConfigSetNumericFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, NUMERIC_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_numeric = getfn;
    new_config->set_fn.set_numeric = setfn;
    listAddNodeTail(module->module_configs, new_config);
    unsigned int numeric_flags = maskModuleNumericConfigFlags(flags);
    flags = maskModuleConfigFlags(flags);
    addModuleNumericConfig(module->name, name, flags, new_config, default_val, numeric_flags, min, max);
    return REDISMODUL...",12803.0,12819.0,1.0,15.0,17.0,14,3,33,15,0,12,2,2,1,9,,0,8,20,10,10,int
4617,198666,RM_LoadConfigs,1,RM_LoadConfigs,int RM_LoadConfigs (RedisModuleCtx*),module.c,"int RM_LoadConfigs(RedisModuleCtx *ctx) {
    if (!ctx || !ctx->module || !ctx->module->onload) {
        return REDISMODULE_ERR;
    }
    RedisModule *module = ctx->module;
    /* Load configs from conf file or arguments from loadex */
    if (loadModuleConfigs(module)) return REDISMODULE_ERR;
    return REDISMODULE_OK;
}",12826.0,12834.0,1.0,15.0,9.0,10,4,6,2,0,4,3,3,3,1,,0,4,2,1,1,int
4618,198715,RM_RdbStreamCreateFromFile,1,RM_RdbStreamCreateFromFile,RedisModuleRdbStream RM_RdbStreamCreateFromFile (char*),module.c,"RedisModuleRdbStream *RM_RdbStreamCreateFromFile(const char *filename) {
    RedisModuleRdbStream *stream = zmalloc(sizeof(*stream));
    stream->type = REDISMODULE_RDB_STREAM_FILE;
    stream->data.filename = zstrdup(filename);
    return stream;
}",12855.0,12860.0,1.0,19.0,6.0,8,5,6,2,0,4,1,1,0,2,,0,4,2,1,1,RedisModuleRdbStream
4619,198744,RM_RdbStreamFree,1,RM_RdbStreamFree,void RM_RdbStreamFree (RedisModuleRdbStream*),module.c,"void RM_RdbStreamFree(RedisModuleRdbStream *stream) {
    switch (stream->type) {
    case REDISMODULE_RDB_STREAM_FILE:
        zfree(stream->data.filename);
        break;
    default:
        serverAssert(0);
        break;
    }
    zfree(stream);
}",12863.0,12873.0,1.0,9.0,11.0,7,6,3,1,0,5,4,2,1,3,,0,2,2,1,1,void
4620,198784,RM_RdbLoad,1,RM_RdbLoad,"int RM_RdbLoad (RedisModuleCtx*,RedisModuleRdbStream*,int)",module.c,"int RM_RdbLoad(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) {
    UNUSED(ctx);

    if (!stream || flags != 0) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* Not allowed on replicas. */
    if (server.masterhost != NULL) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    }

    /* Drop replicas if exist. */
    disconnectSlaves();
    freeReplicationBacklog();

    if (server.aof_state != AOF_OFF) stopAppendOnly();

    /* Kill existing RDB fork as it is saving outdated data. Also killing it
     * will prevent COW memory issue. */
    if (server.child_type == CHILD_TYPE_RDB) killRDBChild();

    emptyData(-1,EMPTYDB_NO_FLAGS,NULL);

    /* rdbLoad() can go back to the networking and process network events. If
     * RM_RdbLoad() is called inside a command callback, we don't want to
     * process the current client. Otherwise, we may free the client or try to
     * process next message while we are already in the command callba...",12889.0,12934.0,1.0,4.0,46.0,33,12,28,11,0,12,9,9,0,10,,0,3,6,3,3,int
4621,198942,RM_RdbSave,1,RM_RdbSave,"int RM_RdbSave (RedisModuleCtx*,RedisModuleRdbStream*,int)",module.c,"int RM_RdbSave(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) {
    UNUSED(ctx);

    if (!stream || flags != 0) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    serverAssert(stream->type == REDISMODULE_RDB_STREAM_FILE);

    if (rdbSaveToFile(stream->data.filename) != C_OK) {
        return REDISMODULE_ERR;
    }

    errno = 0;
    return REDISMODULE_OK;
}",12949.0,12965.0,1.0,4.0,17.0,15,11,9,5,0,4,3,3,2,2,,0,3,6,3,3,int
4622,199011,moduleCommand,1,moduleCommand,void moduleCommand (client*),module.c,"void moduleCommand(client *c) {
    char *subcmd = c->argv[1]->ptr;

    if (c->argc == 2 && !strcasecmp(subcmd,""help"")) {
        const char *help[] = {
""LIST"",
""    Return a list of loaded modules."",
""LOAD <path> [<arg> ...]"",
""    Load a module library from <path>, passing to it any optional arguments."",
""LOADEX <path> [[CONFIG NAME VALUE] [CONFIG NAME VALUE]] [ARGS ...]"",
""    Load a module library from <path>, while passing it module configurations and optional arguments."",
""UNLOAD <name>"",
""    Unload a module."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(subcmd,""load"") && c->argc >= 3) {
        robj **argv = NULL;
        int argc = 0;

        if (c->argc > 3) {
            argc = c->argc - 3;
            argv = &c->argv[3];
        }

        if (moduleLoad(c->argv[2]->ptr,(void **)argv,argc, 0) == C_OK)
            addReply(c,shared.ok);
        else
            addReplyError(c,
                ""Error loading the extension. Please check the ...",12974.0,13038.0,1.0,65.0,65.0,10,7,8,4,0,3,2,2,1,1,,0,2,2,1,1,void
4623,199319,moduleCount,1,moduleCount,size_t moduleCount (void),module.c,"size_t moduleCount(void) {
    return dictSize(modules);
}",13041.0,13043.0,1.0,11.0,3.0,5,3,3,1,5,5,1,1,0,0,,0,5,2,1,1,size_t
4624,199339,RM_SetLRU,1,RM_SetLRU,"int RM_SetLRU (RedisModuleKey*,mstime_t)",module.c,"int RM_SetLRU(RedisModuleKey *key, mstime_t lru_idle) {
    if (!key->value)
        return REDISMODULE_ERR;
    if (objectSetLRUOrLFU(key->value, -1, lru_idle, lru_idle>=0 ? LRU_CLOCK() : 0, 1))
        return REDISMODULE_OK;
    return REDISMODULE_ERR;
}",13052.0,13058.0,1.0,15.0,7.0,6,5,4,2,0,4,3,3,4,2,,0,4,4,2,2,int
4625,199379,RM_GetLRU,1,RM_GetLRU,"int RM_GetLRU (RedisModuleKey*,mstime_t*)",module.c,"int RM_GetLRU(RedisModuleKey *key, mstime_t *lru_idle) {
    *lru_idle = -1;
    if (!key->value)
        return REDISMODULE_ERR;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU)
        return REDISMODULE_OK;
    *lru_idle = estimateObjectIdleTime(key->value);
    return REDISMODULE_OK;
}",13064.0,13072.0,1.0,15.0,9.0,11,8,5,3,0,3,3,3,1,1,,0,3,4,2,2,int
4626,199426,RM_SetLFU,1,RM_SetLFU,"int RM_SetLFU (RedisModuleKey*,long long)",module.c,"int RM_SetLFU(RedisModuleKey *key, long long lfu_freq) {
    if (!key->value)
        return REDISMODULE_ERR;
    if (objectSetLRUOrLFU(key->value, lfu_freq, -1, 0, 1))
        return REDISMODULE_OK;
    return REDISMODULE_ERR;
}",13079.0,13085.0,1.0,15.0,7.0,4,3,3,2,0,3,3,3,3,1,,0,3,4,2,2,int
4627,199461,RM_GetLFU,1,RM_GetLFU,"int RM_GetLFU (RedisModuleKey*,long long*)",module.c,"int RM_GetLFU(RedisModuleKey *key, long long *lfu_freq) {
    *lfu_freq = -1;
    if (!key->value)
        return REDISMODULE_ERR;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU)
        *lfu_freq = LFUDecrAndReturn(key->value);
    return REDISMODULE_OK;
}",13090.0,13097.0,1.0,15.0,8.0,11,8,5,3,0,3,3,3,1,1,,0,3,4,2,2,int
4628,199504,RM_GetModuleOptionsAll,1,RM_GetModuleOptionsAll,int RM_GetModuleOptionsAll (void),module.c,"int RM_GetModuleOptionsAll(void) {
    return _REDISMODULE_OPTIONS_FLAGS_NEXT - 1;
}",13116.0,13118.0,1.0,11.0,3.0,2,2,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4629,199517,RM_GetContextFlagsAll,1,RM_GetContextFlagsAll,int RM_GetContextFlagsAll (void),module.c,"int RM_GetContextFlagsAll(void) {
    return _REDISMODULE_CTX_FLAGS_NEXT - 1;
}",13133.0,13135.0,1.0,11.0,3.0,2,2,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4630,199530,RM_GetKeyspaceNotificationFlagsAll,1,RM_GetKeyspaceNotificationFlagsAll,int RM_GetKeyspaceNotificationFlagsAll (void),module.c,"int RM_GetKeyspaceNotificationFlagsAll(void) {
    return _REDISMODULE_NOTIFY_NEXT - 1;
}",13150.0,13152.0,1.0,11.0,3.0,2,2,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4631,199543,RM_GetServerVersion,1,RM_GetServerVersion,int RM_GetServerVersion (void),module.c,"int RM_GetServerVersion(void) {
    return REDIS_VERSION_NUM;
}",13158.0,13160.0,1.0,11.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4632,199552,RM_GetTypeMethodVersion,1,RM_GetTypeMethodVersion,int RM_GetTypeMethodVersion (void),module.c,"int RM_GetTypeMethodVersion(void) {
    return REDISMODULE_TYPE_METHOD_VERSION;
}",13167.0,13169.0,1.0,11.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
4633,199561,RM_ModuleTypeReplaceValue,1,RM_ModuleTypeReplaceValue,"int RM_ModuleTypeReplaceValue (RedisModuleKey*,moduleType*,void*,void**)",module.c,"int RM_ModuleTypeReplaceValue(RedisModuleKey *key, moduleType *mt, void *new_value, void **old_value) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter)
        return REDISMODULE_ERR;
    if (!key->value || key->value->type != OBJ_MODULE)
        return REDISMODULE_ERR;

    moduleValue *mv = key->value->ptr;
    if (mv->type != mt)
        return REDISMODULE_ERR;

    if (old_value)
        *old_value = mv->value;
    mv->value = new_value;

    return REDISMODULE_OK;
}",13188.0,13203.0,1.0,22.0,16.0,22,8,13,5,0,8,5,5,5,0,,0,8,8,4,4,int
4634,199646,RM_GetCommandKeysWithFlags,1,RM_GetCommandKeysWithFlags,"int* RM_GetCommandKeysWithFlags (RedisModuleCtx*,robj**,int,int*,int**)",module.c,"int *RM_GetCommandKeysWithFlags(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys, int **out_flags) {
    UNUSED(ctx);
    struct redisCommand *cmd;
    int *res = NULL;

    /* Find command */
    if ((cmd = lookupCommand(argv,argc)) == NULL) {
        errno = ENOENT;
        return NULL;
    }

    /* Bail out if command has no keys */
    if (!doesCommandHaveKeys(cmd)) {
        errno = 0;
        return NULL;
    }

    if ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) {
        errno = EINVAL;
        return NULL;
    }

    getKeysResult result = GETKEYS_RESULT_INIT;
    getKeysFromCommand(cmd, argv, argc, &result);

    *num_keys = result.numkeys;
    if (!result.numkeys) {
        errno = 0;
        getKeysFreeResult(&result);
        return NULL;
    }

    /* The return value here expects an array of key positions */
    unsigned long int size = sizeof(int) * result.numkeys;
    res = zmalloc(size);
    if (out_flags)
        *out_fla...",13225.0,13269.0,1.0,53.0,45.0,50,18,55,15,1,16,8,9,7,7,,0,14,10,5,5,int*
4635,199816,RM_GetCommandKeys,1,RM_GetCommandKeys,"int* RM_GetCommandKeys (RedisModuleCtx*,robj**,int,int*)",module.c,"int *RM_GetCommandKeys(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys) {
    return RM_GetCommandKeysWithFlags(ctx, argv, argc, num_keys, NULL);
}",13272.0,13274.0,1.0,44.0,3.0,0,0,5,5,0,1,1,1,0,1,,0,0,8,4,4,int*
4636,199831,RM_GetCurrentCommandName,1,RM_GetCurrentCommandName,const char* RM_GetCurrentCommandName (RedisModuleCtx*),module.c,"const char *RM_GetCurrentCommandName(RedisModuleCtx *ctx) {
    if (!ctx || !ctx->client || !ctx->client->cmd)
        return NULL;

    return (const char*)ctx->client->cmd->fullname;
}",13277.0,13282.0,1.0,1.0,6.0,12,4,5,2,0,3,2,2,2,0,,0,3,2,1,1,const char*
4637,199870,RM_RegisterDefragFunc,1,RM_RegisterDefragFunc,"int RM_RegisterDefragFunc (RedisModuleCtx*,RedisModuleDefragFunc)",module.c,"int RM_RegisterDefragFunc(RedisModuleCtx *ctx, RedisModuleDefragFunc cb) {
    ctx->module->defrag_cb = cb;
    return REDISMODULE_OK;
}",13301.0,13304.0,1.0,11.0,4.0,3,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,int
4638,199887,RM_DefragShouldStop,1,RM_DefragShouldStop,int RM_DefragShouldStop (RedisModuleDefragCtx*),module.c,"int RM_DefragShouldStop(RedisModuleDefragCtx *ctx) {
    return (ctx->endtime != 0 && ctx->endtime < ustime());
}",13320.0,13322.0,1.0,1.0,3.0,5,4,2,1,0,3,1,1,0,1,,0,2,2,1,1,int
4639,199904,RM_DefragCursorSet,1,RM_DefragCursorSet,"int RM_DefragCursorSet (RedisModuleDefragCtx*,long unsigned)",module.c,"int RM_DefragCursorSet(RedisModuleDefragCtx *ctx, unsigned long cursor) {
    if (!ctx->cursor)
        return REDISMODULE_ERR;

    *ctx->cursor = cursor;
    return REDISMODULE_OK;
}",13346.0,13352.0,1.0,15.0,7.0,5,4,3,2,0,2,2,2,1,0,,0,2,4,2,2,int
4640,199930,RM_DefragCursorGet,1,RM_DefragCursorGet,"int RM_DefragCursorGet (RedisModuleDefragCtx*,long unsigned*)",module.c,"int RM_DefragCursorGet(RedisModuleDefragCtx *ctx, unsigned long *cursor) {
    if (!ctx->cursor)
        return REDISMODULE_ERR;

    *cursor = *ctx->cursor;
    return REDISMODULE_OK;
}",13360.0,13366.0,1.0,15.0,7.0,6,4,3,2,0,2,2,2,1,0,,0,2,4,2,2,int
4641,199957,RM_DefragAlloc,1,RM_DefragAlloc,"void* RM_DefragAlloc (RedisModuleDefragCtx*,void*)",module.c,"void *RM_DefragAlloc(RedisModuleDefragCtx *ctx, void *ptr) {
    UNUSED(ctx);
    return activeDefragAlloc(ptr);
}",13379.0,13382.0,1.0,4.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void*
4642,199972,RM_DefragRedisModuleString,1,RM_DefragRedisModuleString,"robj RM_DefragRedisModuleString (RedisModuleDefragCtx*,robj*)",module.c,"RedisModuleString *RM_DefragRedisModuleString(RedisModuleDefragCtx *ctx, RedisModuleString *str) {
    UNUSED(ctx);
    return activeDefragStringOb(str);
}",13394.0,13397.0,1.0,17.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,robj
4643,199987,moduleLateDefrag,1,moduleLateDefrag,"int moduleLateDefrag (robj*,robj*,long unsigned*,long long,int)",module.c,"int moduleLateDefrag(robj *key, robj *value, unsigned long *cursor, long long endtime, int dbid) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;

    RedisModuleDefragCtx defrag_ctx = { endtime, cursor, key, dbid};

    /* Invoke callback. Note that the callback may be missing if the key has been
     * replaced with a different type since our last visit.
     */
    int ret = 0;
    if (mt->defrag)
        ret = mt->defrag(&defrag_ctx, key, &mv->value);

    if (!ret) {
        *cursor = 0;    /* No more work to do */
        return 0;
    }

    return 1;
}",13405.0,13424.0,1.0,1.0,20.0,16,6,18,9,0,2,3,3,0,0,,0,2,10,5,5,int
4644,200050,moduleDefragValue,1,moduleDefragValue,"int moduleDefragValue (robj*,robj*,int)",module.c,"int moduleDefragValue(robj *key, robj *value, int dbid) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;

    /* Try to defrag moduleValue itself regardless of whether or not
     * defrag callbacks are provided.
     */
    moduleValue *newmv = activeDefragAlloc(mv);
    if (newmv) {
        value->ptr = mv = newmv;
    }

    if (!mt->defrag)
        return 1;

    /* Use free_effort to determine complexity of module value, and if
     * necessary schedule it for defragLater instead of quick immediate
     * defrag.
     */
    size_t effort = moduleGetFreeEffort(key, value, dbid);
    if (!effort)
        effort = SIZE_MAX;
    if (effort > server.active_defrag_max_scan_fields) {
        return 0;  /* Defrag later */
    }

    RedisModuleDefragCtx defrag_ctx = { 0, NULL, key, dbid };
    mt->defrag(&defrag_ctx, key, &mv->value);
    return 1;
}",13432.0,13461.0,1.0,1.0,30.0,21,7,28,11,0,4,5,5,0,2,,0,4,6,3,3,int
4645,200136,moduleDefragGlobals,1,moduleDefragGlobals,void moduleDefragGlobals (void),module.c,"void moduleDefragGlobals(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!module->defrag_cb)
            continue;
        RedisModuleDefragCtx defrag_ctx = { 0, NULL, NULL, -1};
        module->defrag_cb(&defrag_ctx);
    }
    dictReleaseIterator(di);
}",13464.0,13476.0,1.0,1.0,13.0,11,7,14,6,0,7,4,4,2,4,,0,6,2,1,1,void
4646,200184,RM_GetKeyNameFromDefragCtx,1,RM_GetKeyNameFromDefragCtx,robj RM_GetKeyNameFromDefragCtx (RedisModuleDefragCtx*),module.c,"const RedisModuleString *RM_GetKeyNameFromDefragCtx(RedisModuleDefragCtx *ctx) {
    return ctx->key;
}",13481.0,13483.0,1.0,6.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,robj
4647,200193,RM_GetDbIdFromDefragCtx,1,RM_GetDbIdFromDefragCtx,int RM_GetDbIdFromDefragCtx (RedisModuleDefragCtx*),module.c,"int RM_GetDbIdFromDefragCtx(RedisModuleDefragCtx *ctx) {
    return ctx->dbid;
}",13488.0,13490.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
4648,203405,RevokeCommand_RedisCommand,1,RevokeCommand_RedisCommand,"int RevokeCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int RevokeCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (global_auth_client_id) {
        RedisModule_DeauthenticateAndCloseClient(ctx, global_auth_client_id);
        return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
    } else {
        return RedisModule_ReplyWithError(ctx, ""Global user currently not used"");    
    }
}",44.0,54.0,1.0,4.0,11.0,2,1,8,4,0,4,2,2,1,2,,0,2,6,3,3,int
4649,203440,ResetCommand_RedisCommand,1,ResetCommand_RedisCommand,"int ResetCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int ResetCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModule_FreeModuleUser(global);
    global = RedisModule_CreateModuleUser(""global"");
    RedisModule_SetModuleUserACL(global, ""allcommands"");
    RedisModule_SetModuleUserACL(global, ""allkeys"");
    RedisModule_SetModuleUserACL(global, ""on"");

    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",58.0,69.0,1.0,4.0,12.0,3,2,10,4,0,11,1,1,0,6,,0,6,6,3,3,int
4650,203478,HelloACL_UserChanged,1,HelloACL_UserChanged,"void HelloACL_UserChanged (uint64_t,void*)",modules\helloacl.c,"void HelloACL_UserChanged(uint64_t client_id, void *privdata) {
    REDISMODULE_NOT_USED(privdata);
    REDISMODULE_NOT_USED(client_id);
    global_auth_client_id = 0;
}",73.0,77.0,1.0,4.0,5.0,3,2,5,3,0,1,1,1,0,0,,0,1,4,2,2,void
4651,203499,AuthGlobalCommand_RedisCommand,1,AuthGlobalCommand_RedisCommand,"int AuthGlobalCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int AuthGlobalCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (global_auth_client_id) {
        return RedisModule_ReplyWithError(ctx, ""Global user currently used"");    
    }

    RedisModule_AuthenticateClientWithUser(ctx, global, HelloACL_UserChanged, NULL, &global_auth_client_id);

    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",81.0,92.0,1.0,4.0,12.0,3,2,11,6,0,6,2,2,1,3,,0,3,6,3,3,int
4652,203536,HelloACL_Reply,1,HelloACL_Reply,"int HelloACL_Reply (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int HelloACL_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    size_t length;

    RedisModuleString *user_string = RedisModule_GetBlockedClientPrivateData(ctx);
    const char *name = RedisModule_StringPtrLen(user_string, &length);

    if (RedisModule_AuthenticateClientWithACLUser(ctx, name, length, NULL, NULL, NULL) == 
            REDISMODULE_ERR) {
        return RedisModule_ReplyWithError(ctx, ""Invalid Username or password"");    
    }
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",97.0,110.0,1.0,4.0,14.0,6,4,17,7,0,5,2,2,1,5,,0,3,6,3,3,int
4653,203589,HelloACL_Timeout,1,HelloACL_Timeout,"int HelloACL_Timeout (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int HelloACL_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx, ""Request timedout"");
}",113.0,117.0,1.0,4.0,5.0,2,1,5,3,0,1,1,1,0,1,,0,0,6,3,3,int
4654,203612,HelloACL_FreeData,1,HelloACL_FreeData,"void HelloACL_FreeData (RedisModuleCtx*,void*)",modules\helloacl.c,"void HelloACL_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_FreeString(NULL, privdata);
}",120.0,123.0,1.0,4.0,4.0,1,1,4,3,0,1,1,1,0,1,,0,0,4,2,2,void
4655,203627,HelloACL_ThreadMain,1,HelloACL_ThreadMain,void* HelloACL_ThreadMain (void*),modules\helloacl.c,"void *HelloACL_ThreadMain(void *args) {
    void **targs = args;
    RedisModuleBlockedClient *bc = targs[0];
    RedisModuleString *user = targs[1];
    RedisModule_Free(targs);

    RedisModule_UnblockClient(bc,user);
    return NULL;
}",126.0,134.0,1.0,1.0,9.0,5,2,10,5,0,2,1,1,0,2,,0,0,2,1,1,void*
4656,203655,AuthAsyncCommand_RedisCommand,1,AuthAsyncCommand_RedisCommand,"int AuthAsyncCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloacl.c,"int AuthAsyncCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    pthread_t tid;
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx, HelloACL_Reply, HelloACL_Timeout, HelloACL_FreeData, TIMEOUT_TIME);
    

    void **targs = RedisModule_Alloc(sizeof(void*)*2);
    targs[0] = bc;
    targs[1] = RedisModule_CreateStringFromString(NULL, argv[1]);

    if (pthread_create(&tid, NULL, HelloACL_ThreadMain, targs) != 0) {
        RedisModule_AbortBlock(bc);
        return RedisModule_ReplyWithError(ctx, ""-ERR Can't start thread"");
    }

    return REDISMODULE_OK;
}",138.0,155.0,1.0,117.0,18.0,12,6,16,8,0,6,3,3,0,6,,0,3,6,3,3,int
4657,203724,RedisModule_OnLoad,1,RedisModule_OnLoad,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx,""helloworld"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    /* Log the list of parameters passing loading the module. */
    for (int j = 0; j < argc; j++) {
        const char *s = RedisModule_StringPtrLen(argv[j],NULL);
        printf(""Module loaded with ARGV[%d] = %s\n"", j, s);
    }

    if (RedisModule_CreateCommand(ctx,""hello.simple"",
        HelloSimple_RedisCommand,""readonly"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.native"",
        HelloPushNative_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.call"",
        HelloPushCall_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.call2"",
     ...",545.0,621.0,1.0,44.0,77.0,9,3,14,5,0,14,6,6,5,9,,0,11,6,3,3,int
4658,203867,HelloBlock_Reply,1,HelloBlock_Reply,"int HelloBlock_Reply (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModuleString *keyname = RedisModule_GetBlockedClientReadyKey(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,keyname,REDISMODULE_READ);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_MODULE ||
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        RedisModule_CloseKey(key);
        return REDISMODULE_ERR;
    }

    /* In case the key is able to serve our blocked client, let's directly
     * use our original command implementation to make this example simpler. */
    RedisModule_CloseKey(key);
    return HelloTypeRange_RedisCommand(ctx,argv,argc-1);
}",199.0,217.0,1.0,4.0,19.0,4,3,8,4,0,2,1,1,0,2,,0,1,6,3,3,int
4659,203896,HelloBlock_Timeout,1,HelloBlock_Timeout,"int HelloBlock_Timeout (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx,""Request timedout"");
}",220.0,224.0,1.0,4.0,5.0,2,1,5,3,0,1,1,1,0,1,,0,0,6,3,3,int
4660,203919,HelloBlock_FreeData,1,HelloBlock_FreeData,"void HelloBlock_FreeData (RedisModuleCtx*,void*)",modules\hellotype.c,"void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_Free(privdata);
}",227.0,230.0,1.0,4.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void
4661,203933,HelloBlock_ThreadMain,1,HelloBlock_ThreadMain,void* HelloBlock_ThreadMain (void*),modules\helloblock.c,"void *HelloBlock_ThreadMain(void *arg) {
    void **targ = arg;
    RedisModuleBlockedClient *bc = targ[0];
    long long delay = (unsigned long)targ[1];
    RedisModule_Free(targ);

    sleep(delay);
    int *r = RedisModule_Alloc(sizeof(int));
    *r = rand();
    RedisModule_UnblockClient(bc,r);
    return NULL;
}",63.0,74.0,1.0,1.0,12.0,10,5,14,7,0,3,1,1,0,3,,0,1,2,1,1,void*
4662,203975,HelloBlock_Disconnected,1,HelloBlock_Disconnected,"void HelloBlock_Disconnected (RedisModuleCtx*,RedisModuleBlockedClient*)",modules\helloblock.c,"void HelloBlock_Disconnected(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc) {
    RedisModule_Log(ctx,""warning"",""Blocked client %p disconnected!"",
        (void*)bc);

    /* Here you should cleanup your state / threads, and if possible
     * call RedisModule_UnblockClient(), or notify the thread that will
     * call the function ASAP. */
}",84.0,91.0,1.0,1.0,8.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,void
4663,203988,HelloBlock_RedisCommand,1,HelloBlock_RedisCommand,"int HelloBlock_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloblock.c,"int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    long long delay;
    long long timeout;

    if (RedisModule_StringToLongLong(argv[1],&delay) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    if (RedisModule_StringToLongLong(argv[2],&timeout) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    pthread_t tid;
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,HelloBlock_Reply,HelloBlock_Timeout,HelloBlock_FreeData,timeout);

    /* Here we set a disconnection handler, however since this module will
     * block in sleep() in a thread, there is not much we can do in the
     * callback, so this is just to show you the API. */
    RedisModule_SetDisconnectCallback(bc,HelloBlock_Disconnected);

    /* Now that we setup a blocking client, we need to pass the control
     * to the thr...",96.0,129.0,1.0,56.0,34.0,19,7,23,10,0,10,5,5,2,10,,0,4,6,3,3,int
4664,204092,HelloKeys_ThreadMain,1,HelloKeys_ThreadMain,void* HelloKeys_ThreadMain (void*),modules\helloblock.c,"void *HelloKeys_ThreadMain(void *arg) {
    RedisModuleBlockedClient *bc = arg;
    RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bc);
    long long cursor = 0;
    size_t replylen = 0;

    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    do {
        RedisModule_ThreadSafeContextLock(ctx);
        RedisModuleCallReply *reply = RedisModule_Call(ctx,
            ""SCAN"",""l"",(long long)cursor);
        RedisModule_ThreadSafeContextUnlock(ctx);

        RedisModuleCallReply *cr_cursor =
            RedisModule_CallReplyArrayElement(reply,0);
        RedisModuleCallReply *cr_keys =
            RedisModule_CallReplyArrayElement(reply,1);

        RedisModuleString *s = RedisModule_CreateStringFromCallReply(cr_cursor);
        RedisModule_StringToLongLong(s,&cursor);
        RedisModule_FreeString(ctx,s);

        size_t items = RedisModule_CallReplyLength(cr_keys);
        for (size_t j = 0; j < items; j++) {
            RedisModuleCallReply *ele =
                ...",138.0,174.0,1.0,35.0,37.0,17,7,41,13,0,17,3,4,0,17,,0,7,2,1,1,void*
4665,204203,HelloKeys_RedisCommand,1,HelloKeys_RedisCommand,"int HelloKeys_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloblock.c,"int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    if (argc != 1) return RedisModule_WrongArity(ctx);

    pthread_t tid;

    /* Note that when blocking the client we do not set any callback: no
     * timeout is possible since we passed '0', nor we need a reply callback
     * because we'll use the thread safe context to accumulate a reply. */
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);

    /* Now that we setup a blocking client, we need to pass the control
     * to the thread. However we need to pass arguments to the thread:
     * the reference to the blocked client handle. */
    if (pthread_create(&tid,NULL,HelloKeys_ThreadMain,bc) != 0) {
        RedisModule_AbortBlock(bc);
        return RedisModule_ReplyWithError(ctx,""-ERR Can't start thread"");
    }
    return REDISMODULE_OK;
}",180.0,199.0,1.0,4.0,20.0,5,4,14,6,0,4,3,3,0,4,,0,1,6,3,3,int
4666,204345,PingallCommand_RedisCommand,1,PingallCommand_RedisCommand,"int PingallCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellocluster.c,"int PingallCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PING,""Hey"",3);
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",43.0,49.0,1.0,4.0,7.0,2,1,7,4,0,2,1,1,0,2,,0,0,6,3,3,int
4667,204376,ListCommand_RedisCommand,1,ListCommand_RedisCommand,"int ListCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellocluster.c,"int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    size_t numnodes;
    char **ids = RedisModule_GetClusterNodesList(ctx,&numnodes);
    if (ids == NULL) {
        return RedisModule_ReplyWithError(ctx,""Cluster not enabled"");
    }

    RedisModule_ReplyWithArray(ctx,numnodes);
    for (size_t j = 0; j < numnodes; j++) {
        int port;
        RedisModule_GetClusterNodeInfo(ctx,ids[j],NULL,NULL,&port,NULL);
        RedisModule_ReplyWithArray(ctx,2);
        RedisModule_ReplyWithStringBuffer(ctx,ids[j],REDISMODULE_NODE_ID_LEN);
        RedisModule_ReplyWithLongLong(ctx,port);
    }
    RedisModule_FreeClusterNodesList(ids);
    return REDISMODULE_OK;
}",52.0,72.0,1.0,4.0,21.0,10,6,29,8,0,8,3,3,0,8,,0,1,6,3,3,int
4668,204458,PingReceiver,1,PingReceiver,"void PingReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)",modules\hellocluster.c,"void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    RedisModule_Log(ctx,""notice"",""PING (type %d) RECEIVED from %.*s: '%.*s'"",
        type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
    RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PONG,""Ohi!"",4);
    RedisModuleCallReply *reply = RedisModule_Call(ctx, ""INCR"", ""c"", ""pings_received"");
    RedisModule_FreeCallReply(reply);
}",75.0,81.0,1.0,13.0,7.0,2,2,10,7,0,4,1,1,0,4,,0,1,10,5,5,void
4669,204498,PongReceiver,1,PongReceiver,"void PongReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)",modules\hellocluster.c,"void PongReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    RedisModule_Log(ctx,""notice"",""PONG (type %d) RECEIVED from %.*s: '%.*s'"",
        type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
}",84.0,87.0,1.0,13.0,4.0,1,1,5,5,0,1,1,1,0,1,,0,0,10,5,5,void
4670,204631,cmd_SET,1,cmd_SET,"int cmd_SET (RedisModuleCtx*,RedisModuleString**,int)",modules\hellodict.c,"int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    RedisModule_DictSet(Keyspace,argv[1],argv[2]);
    /* We need to keep a reference to the value stored at the key, otherwise
     * it would be freed when this callback returns. */
    RedisModule_RetainString(NULL,argv[2]);
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",47.0,54.0,1.0,1.0,8.0,4,2,8,5,0,5,2,2,0,4,,0,1,6,3,3,int
4671,204663,cmd_GET,1,cmd_GET,"int cmd_GET (RedisModuleCtx*,RedisModuleString**,int)",modules\hellodict.c,"int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    RedisModuleString *val = RedisModule_DictGet(Keyspace,argv[1],NULL);
    if (val == NULL) {
        return RedisModule_ReplyWithNull(ctx);
    } else {
        return RedisModule_ReplyWithString(ctx, val);
    }
}",60.0,68.0,1.0,1.0,9.0,4,4,9,6,0,4,3,3,0,3,,0,2,6,3,3,int
4672,204701,cmd_KEYRANGE,1,cmd_KEYRANGE,"int cmd_KEYRANGE (RedisModuleCtx*,RedisModuleString**,int)",modules\hellodict.c,"int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    /* Parse the count argument. */
    long long count;
    if (RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    /* Seek the iterator. */
    RedisModuleDictIter *iter = RedisModule_DictIteratorStart(
        Keyspace, "">="", argv[1]);

    /* Reply with the matching items. */
    char *key;
    size_t keylen;
    long long replylen = 0; /* Keep track of the emitted array len. */
    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    while((key = RedisModule_DictNextC(iter,&keylen,NULL)) != NULL) {
        if (replylen >= count) break;
        if (RedisModule_DictCompare(iter,""<="",argv[2]) == REDISMODULE_ERR)
            break;
        RedisModule_ReplyWithStringBuffer(ctx,key,keylen);
        replylen++;
    }
    RedisModule_ReplySetArrayLength(...",74.0,104.0,1.0,56.0,31.0,15,8,26,10,0,11,8,8,3,10,,0,5,6,3,3,int
4673,204912,clientChangeCallback,1,clientChangeCallback,"void clientChangeCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)",modules\hellohook.c,"void clientChangeCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)
{
    REDISMODULE_NOT_USED(ctx);
    REDISMODULE_NOT_USED(e);

    RedisModuleClientInfo *ci = data;
    printf(""Client %s event for client #%llu %s:%d\n"",
        (sub == REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED) ?
            ""connection"" : ""disconnection"",
        (unsigned long long)ci->id,ci->addr,ci->port);
}",40.0,50.0,1.0,4.0,11.0,9,5,10,5,0,0,1,1,0,0,,0,0,8,4,4,void
4674,204959,flushdbCallback,1,flushdbCallback,"void flushdbCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)",modules\hellohook.c,"void flushdbCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)
{
    REDISMODULE_NOT_USED(ctx);
    REDISMODULE_NOT_USED(e);

    RedisModuleFlushInfo *fi = data;
    if (sub == REDISMODULE_SUBEVENT_FLUSHDB_START) {
        if (fi->dbnum != -1) {
            RedisModuleCallReply *reply;
            reply = RedisModule_Call(ctx,""DBSIZE"","""");
            long long numkeys = RedisModule_CallReplyInteger(reply);
            printf(""FLUSHDB event of database %d started (%lld keys in DB)\n"",
                fi->dbnum, numkeys);
            RedisModule_FreeCallReply(reply);
        } else {
            printf(""FLUSHALL event started\n"");
        }
    } else {
        if (fi->dbnum != -1) {
            printf(""FLUSHDB event of database %d ended\n"",fi->dbnum);
        } else {
            printf(""FLUSHALL event ended\n"");
        }
    }
}",52.0,76.0,1.0,4.0,25.0,10,6,15,7,0,3,3,4,0,3,,0,2,8,4,4,void
4675,205106,timerHandler,1,timerHandler,"void timerHandler (RedisModuleCtx*,void*)",modules\hellotimer.c,"void timerHandler(RedisModuleCtx *ctx, void *data) {
    REDISMODULE_NOT_USED(ctx);
    printf(""Fired %s!\n"", (char *)data);
    RedisModule_Free(data);
}",40.0,44.0,1.0,4.0,5.0,2,1,4,2,0,1,1,1,0,1,,0,0,4,2,2,void
4676,205125,TimerCommand_RedisCommand,1,TimerCommand_RedisCommand,"int TimerCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotimer.c,"int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    for (int j = 0; j < 10; j++) {
        int delay = rand() % 5000;
        char *buf = RedisModule_Alloc(256);
        snprintf(buf,256,""After %d"", delay);
        RedisModuleTimerID tid = RedisModule_CreateTimer(ctx,delay,timerHandler,buf);
        REDISMODULE_NOT_USED(tid);
    }
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",47.0,59.0,1.0,4.0,13.0,9,4,17,7,0,3,2,2,0,3,,0,2,6,3,3,int
4677,205274,createHelloTypeObject,1,createHelloTypeObject,struct HelloTypeObject createHelloTypeObject (void),modules\hellotype.c,"struct HelloTypeObject *createHelloTypeObject(void) {
    struct HelloTypeObject *o;
    o = RedisModule_Alloc(sizeof(*o));
    o->head = NULL;
    o->len = 0;
    return o;
}",63.0,69.0,1.0,1.0,7.0,7,4,6,2,2,3,1,1,0,1,,0,3,2,1,1,struct HelloTypeObject
4678,205298,HelloTypeInsert,1,HelloTypeInsert,"void HelloTypeInsert (HelloTypeObject*,int64_t)",modules\hellotype.c,"void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {
    struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;

    while(next && next->value < ele) {
        prev = next;
        next = next->next;
    }
    newnode = RedisModule_Alloc(sizeof(*newnode));
    newnode->value = ele;
    newnode->next = next;
    if (prev) {
        prev->next = newnode;
    } else {
        o->head = newnode;
    }
    o->len++;
}",71.0,87.0,1.0,1.0,17.0,20,7,21,6,2,8,3,3,1,1,,0,8,4,2,2,void
4679,205367,HelloTypeReleaseObject,1,HelloTypeReleaseObject,void HelloTypeReleaseObject (HelloTypeObject*),modules\hellotype.c,"void HelloTypeReleaseObject(struct HelloTypeObject *o) {
    struct HelloTypeNode *cur, *next;
    cur = o->head;
    while(cur) {
        next = cur->next;
        RedisModule_Free(cur);
        cur = next;
    }
    RedisModule_Free(o);
}",89.0,98.0,1.0,1.0,10.0,5,2,9,3,1,4,2,2,0,2,,0,2,2,1,1,void
4680,205394,HelloTypeInsert_RedisCommand,1,HelloTypeInsert_RedisCommand,"int HelloTypeInsert_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 3) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long value;
    if ((RedisModule_StringToLongLong(argv[2],&value) != REDISMODULE_OK)) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid value: must be a signed 64 bit integer"");
    }

    /* Create an empty value object if the key is currently empty. */
    struct HelloTypeObject *hto;
    if (type == REDISMODULE_KEYTYPE_EMPTY) {
        hto = createHelloTypeObject();
        RedisModule_ModuleTypeSetValue(key,Hel...",103.0,137.0,1.0,8.0,35.0,17,9,27,8,0,17,5,5,3,14,,0,8,6,3,3,int
4681,205510,HelloTypeRange_RedisCommand,1,HelloTypeRange_RedisCommand,"int HelloTypeRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long first, count;
    if (RedisModule_StringToLongLong(argv[2],&first) != REDISMODULE_OK ||
        RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK ||
        first < 0 || count < 0)
    {
        return RedisModule_ReplyWithError(ctx,
            ""ERR invalid first or count parameters"");
    }

    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
    struct HelloTypeNode *node = hto ? hto->he...",140.0,173.0,1.0,8.0,34.0,33,14,36,12,1,17,5,5,4,13,,0,10,6,3,3,int
4682,205655,HelloTypeLen_RedisCommand,1,HelloTypeLen_RedisCommand,"int HelloTypeLen_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 2) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
    RedisModule_ReplyWithLongLong(ctx,hto ? hto->len : 0);
    return REDISMODULE_OK;
}",176.0,192.0,1.0,8.0,17.0,13,8,17,7,0,10,3,3,2,8,,0,6,6,3,3,int
4683,205835,HelloTypeBRange_RedisCommand,1,HelloTypeBRange_RedisCommand,"int HelloTypeBRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\hellotype.c,"int HelloTypeBRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 5) return RedisModule_WrongArity(ctx);
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Parse the timeout before even trying to serve the client synchronously,
     * so that we always fail ASAP on syntax errors. */
    long long timeout;
    if (RedisModule_StringToLongLong(argv[4],&timeout) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,
            ""ERR invalid timeout parameter"");
    }

    /* Can we serve the reply synchronously? */
    if (type != REDISMODULE_KEYTYPE_EMPTY) {
        retu...",235.0,264.0,1.0,8.0,30.0,17,9,24,8,0,12,5,5,3,11,,0,6,6,3,3,int
4684,205945,HelloTypeRdbLoad,1,HelloTypeRdbLoad,"void* HelloTypeRdbLoad (RedisModuleIO*,int)",modules\hellotype.c,"void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
    if (encver != 0) {
        /* RedisModule_Log(""warning"",""Can't load data with version %d"", encver);*/
        return NULL;
    }
    uint64_t elements = RedisModule_LoadUnsigned(rdb);
    struct HelloTypeObject *hto = createHelloTypeObject();
    while(elements--) {
        int64_t ele = RedisModule_LoadSigned(rdb);
        HelloTypeInsert(hto,ele);
    }
    return hto;
}",268.0,280.0,1.0,1.0,13.0,5,3,11,6,0,4,3,3,0,4,,0,3,4,2,2,void*
4685,205981,HelloTypeRdbSave,1,HelloTypeRdbSave,"void HelloTypeRdbSave (RedisModuleIO*,void*)",modules\hellotype.c,"void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    RedisModule_SaveUnsigned(rdb,hto->len);
    while(node) {
        RedisModule_SaveSigned(rdb,node->value);
        node = node->next;
    }
}",282.0,290.0,1.0,1.0,9.0,7,2,11,4,0,6,2,2,0,2,,0,4,4,2,2,void
4686,206015,HelloTypeAofRewrite,1,HelloTypeAofRewrite,"void HelloTypeAofRewrite (RedisModuleIO*,RedisModuleString*,void*)",modules\hellotype.c,"void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    while(node) {
        RedisModule_EmitAOF(aof,""HELLOTYPE.INSERT"",""sl"",key,node->value);
        node = node->next;
    }
}",292.0,299.0,1.0,1.0,8.0,6,2,10,5,0,4,2,2,0,1,,0,3,6,3,3,void
4687,206048,HelloTypeMemUsage,1,HelloTypeMemUsage,size_t HelloTypeMemUsage (void*),modules\hellotype.c,"size_t HelloTypeMemUsage(const void *value) {
    const struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    return sizeof(*hto) + sizeof(*node)*hto->len;
}",303.0,307.0,1.0,1.0,5.0,10,6,7,3,0,2,1,1,0,0,,0,2,2,1,1,size_t
4688,206075,HelloTypeFree,1,HelloTypeFree,void HelloTypeFree (void*),modules\hellotype.c,"void HelloTypeFree(void *value) {
    HelloTypeReleaseObject(value);
}",309.0,311.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
4689,206082,HelloTypeDigest,1,HelloTypeDigest,"void HelloTypeDigest (RedisModuleDigest*,void*)",modules\hellotype.c,"void HelloTypeDigest(RedisModuleDigest *md, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    while(node) {
        RedisModule_DigestAddLongLong(md,node->value);
        node = node->next;
    }
    RedisModule_DigestEndSequence(md);
}",313.0,321.0,1.0,1.0,9.0,6,2,10,4,0,5,2,2,0,2,,0,3,4,2,2,void
4690,206291,HelloSimple_RedisCommand,1,HelloSimple_RedisCommand,"int HelloSimple_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    RedisModule_ReplyWithLongLong(ctx,RedisModule_GetSelectedDb(ctx));
    return REDISMODULE_OK;
}",48.0,53.0,1.0,4.0,6.0,2,1,6,3,0,2,1,1,0,2,,0,1,6,3,3,int
4691,206318,HelloPushNative_RedisCommand,1,HelloPushNative_RedisCommand,"int HelloPushNative_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    RedisModule_ListPush(key,REDISMODULE_LIST_TAIL,argv[2]);
    size_t newlen = RedisModule_ValueLength(key);
    RedisModule_CloseKey(key);
    RedisModule_ReplyWithLongLong(ctx,newlen);
    return REDISMODULE_OK;
}",61.0,73.0,1.0,8.0,13.0,8,5,12,5,0,6,2,2,0,6,,0,2,6,3,3,int
4692,206374,HelloPushCall_RedisCommand,1,HelloPushCall_RedisCommand,"int HelloPushCall_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""RPUSH"",""ss"",argv[1],argv[2]);
    long long len = RedisModule_CallReplyInteger(reply);
    RedisModule_FreeCallReply(reply);
    RedisModule_ReplyWithLongLong(ctx,len);
    return REDISMODULE_OK;
}",80.0,91.0,1.0,11.0,12.0,5,3,11,5,0,5,2,2,0,5,,0,2,6,3,3,int
4693,206416,HelloPushCall2_RedisCommand,1,HelloPushCall2_RedisCommand,"int HelloPushCall2_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""RPUSH"",""ss"",argv[1],argv[2]);
    RedisModule_ReplyWithCallReply(ctx,reply);
    RedisModule_FreeCallReply(reply);
    return REDISMODULE_OK;
}",96.0,106.0,1.0,11.0,11.0,4,3,9,4,0,4,2,2,0,4,,0,1,6,3,3,int
4694,206453,HelloListSumLen_RedisCommand,1,HelloListSumLen_RedisCommand,"int HelloListSumLen_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""LRANGE"",""sll"",argv[1],(long long)0,(long long)-1);
    size_t strlen = 0;
    size_t items = RedisModule_CallReplyLength(reply);
    size_t j;
    for (j = 0; j < items; j++) {
        RedisModuleCallReply *ele = RedisModule_CallReplyArrayElement(reply,j);
        strlen += RedisModule_CallReplyLength(ele);
    }
    RedisModule_FreeCallReply(reply);
    RedisModule_ReplyWithLongLong(ctx,strlen);
    return REDISMODULE_OK;
}",111.0,128.0,1.0,11.0,18.0,12,7,19,8,0,7,3,3,0,7,,0,3,6,3,3,int
4695,206525,HelloListSplice_RedisCommand,1,HelloListSplice_RedisCommand,"int HelloListSplice_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
        REDISMODULE_READ|REDISMODULE_WRITE);

    /* Src and dst key must be empty or lists. */
    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
    {
        RedisModule_CloseKey(srckey);
        RedisModule_CloseKey(dstkey);
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long count;
    if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
        (count < 0)) {
        RedisModule_Cl...",134.0,175.0,1.0,8.0,42.0,28,12,36,9,0,21,7,7,5,21,,0,9,6,3,3,int
4696,206687,HelloListSpliceAuto_RedisCommand,1,HelloListSpliceAuto_RedisCommand,"int HelloListSpliceAuto_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    RedisModule_AutoMemory(ctx);

    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
        REDISMODULE_READ|REDISMODULE_WRITE);

    /* Src and dst key must be empty or lists. */
    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long count;
    if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
        (count < 0))
    {
        return RedisModule_ReplyWithError(ctx,""ERR inval...",179.0,216.0,1.0,8.0,38.0,28,12,29,9,0,15,7,7,5,15,,0,9,6,3,3,int
4697,206836,HelloRandArray_RedisCommand,1,HelloRandArray_RedisCommand,"int HelloRandArray_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    long long count;
    if (RedisModule_StringToLongLong(argv[1],&count) != REDISMODULE_OK ||
        count < 0)
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");

    /* To reply with an array, we call RedisModule_ReplyWithArray() followed
     * by other ""count"" calls to other reply functions in order to generate
     * the elements of the array. */
    RedisModule_ReplyWithArray(ctx,count);
    while(count--) RedisModule_ReplyWithLongLong(ctx,rand());
    return REDISMODULE_OK;
}",221.0,234.0,1.0,56.0,14.0,7,6,9,4,0,4,4,4,1,4,,0,1,6,3,3,int
4698,206885,HelloRepl1_RedisCommand,1,HelloRepl1_RedisCommand,"int HelloRepl1_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    RedisModule_AutoMemory(ctx);

    /* This will be replicated *after* the two INCR statements, since
     * the Call() replication has precedence, so the actual replication
     * stream will be:
     *
     * MULTI
     * INCR foo
     * INCR bar
     * ECHO c foo
     * EXEC
     */
    RedisModule_Replicate(ctx,""ECHO"",""c"",""foo"");

    /* Using the ""!"" modifier we replicate the command if it
     * modified the dataset in some way. */
    RedisModule_Call(ctx,""INCR"",""c!"",""foo"");
    RedisModule_Call(ctx,""INCR"",""c!"",""bar"");

    RedisModule_ReplyWithLongLong(ctx,0);

    return REDISMODULE_OK;
}",240.0,266.0,1.0,4.0,27.0,2,1,9,3,0,5,1,1,0,5,,0,0,6,3,3,int
4699,206928,HelloRepl2_RedisCommand,1,HelloRepl2_RedisCommand,"int HelloRepl2_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_LIST)
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);

    size_t listlen = RedisModule_ValueLength(key);
    long long sum = 0;

    /* Rotate and increment. */
    while(listlen--) {
        RedisModuleString *ele = RedisModule_ListPop(key,REDISMODULE_LIST_TAIL);
        long long val;
        if (RedisModule_StringToLongLong(ele,&val) != REDISMODULE_OK) val = 0;
        val++;
        sum += val;
        RedisModuleString *newele = RedisModule_CreateStringFromLongLong(ctx,val);
        RedisModule_ListPush(key,REDISMODULE_LIST_HEAD,newele);
    }
    RedisModule_ReplyWithLongLong(...",278.0,304.0,1.0,8.0,27.0,17,9,28,9,0,12,5,6,2,12,,0,6,6,3,3,int
4700,207039,HelloToggleCase_RedisCommand,1,HelloToggleCase_RedisCommand,"int HelloToggleCase_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    int keytype = RedisModule_KeyType(key);
    if (keytype != REDISMODULE_KEYTYPE_STRING &&
        keytype != REDISMODULE_KEYTYPE_EMPTY)
    {
        RedisModule_CloseKey(key);
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    if (keytype == REDISMODULE_KEYTYPE_STRING) {
        size_t len, j;
        char *s = RedisModule_StringDMA(key,&len,REDISMODULE_WRITE);
        for (j = 0; j < len; j++) {
            if (isupper(s[j])) {
                s[j] = tolower(s[j]);
            } else {
                s[j] = toupper(s[j]);
            }
        }
    }

    RedisModule_CloseKey(key);
    RedisModule_ReplyWithSimpleString(ctx,""OK"");
    RedisModule_ReplicateVerbatim(ctx);
    return REDISMODU...",314.0,344.0,1.0,8.0,31.0,20,9,27,8,0,9,6,9,0,9,,0,3,6,3,3,int
4701,207166,HelloMoreExpire_RedisCommand,1,HelloMoreExpire_RedisCommand,"int HelloMoreExpire_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    if (argc != 3) return RedisModule_WrongArity(ctx);

    mstime_t addms, expire;

    if (RedisModule_StringToLongLong(argv[2],&addms) != REDISMODULE_OK)
        return RedisModule_ReplyWithError(ctx,""ERR invalid expire time"");

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    expire = RedisModule_GetExpire(key);
    if (expire != REDISMODULE_NO_EXPIRE) {
        expire += addms;
        RedisModule_SetExpire(key,expire);
    }
    return RedisModule_ReplyWithSimpleString(ctx,""OK"");
}",350.0,367.0,1.0,56.0,18.0,13,8,17,6,0,8,4,4,1,8,,0,3,6,3,3,int
4702,207242,HelloZsumRange_RedisCommand,1,HelloZsumRange_RedisCommand,"int HelloZsumRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    double score_start, score_end;
    if (argc != 4) return RedisModule_WrongArity(ctx);

    if (RedisModule_StringToDouble(argv[2],&score_start) != REDISMODULE_OK ||
        RedisModule_StringToDouble(argv[3],&score_end) != REDISMODULE_OK)
    {
        return RedisModule_ReplyWithError(ctx,""ERR invalid range"");
    }

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    double scoresum_a = 0;
    double scoresum_b = 0;

    RedisModule_ZsetFirstInScoreRange(key,score_start,score_end,0,0);
    while(!RedisModule_ZsetRangeEndReached(key)) {
        double score;
        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
        RedisModule_FreeString(ctx,ele);
       ...",375.0,421.0,1.0,60.0,47.0,24,9,46,10,0,23,6,6,5,23,,0,8,6,3,3,int
4703,207400,HelloLexRange_RedisCommand,1,HelloLexRange_RedisCommand,"int HelloLexRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 6) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    if (RedisModule_ZsetFirstInLexRange(key,argv[2],argv[3]) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""invalid range"");
    }

    int arraylen = 0;
    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    while(!RedisModule_ZsetRangeEndReached(key)) {
        double score;
        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
        RedisModule_ReplyWithString(ctx,ele);
        RedisModule_FreeString(ctx,ele);
        RedisModule_ZsetRangeNext(key);
    ...",430.0,459.0,1.0,8.0,30.0,16,9,28,7,0,16,5,5,3,16,,0,5,6,3,3,int
4704,207512,HelloHCopy_RedisCommand,1,HelloHCopy_RedisCommand,"int HelloHCopy_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_HASH &&
        type != REDISMODULE_KEYTYPE_EMPTY)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Get the old field value. */
    RedisModuleString *oldval;
    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);
    if (oldval) {
        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);
    }
    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);
    return REDISMODULE_OK;
}",468.0,489.0,1.0,8.0,22.0,14,7,23,7,0,8,4,4,0,8,,0,2,6,3,3,int
4705,207606,HelloLeftPad_RedisCommand,1,HelloLeftPad_RedisCommand,"int HelloLeftPad_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)",modules\helloworld.c,"int HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    long long padlen;

    if (argc != 4) return RedisModule_WrongArity(ctx);

    if ((RedisModule_StringToLongLong(argv[2],&padlen) != REDISMODULE_OK) ||
        (padlen< 0)) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid padding length"");
    }
    size_t strlen, chlen;
    const char *str = RedisModule_StringPtrLen(argv[1], &strlen);
    const char *ch = RedisModule_StringPtrLen(argv[3], &chlen);

    /* If the string is already larger than the target len, just return
     * the string itself. */
    if (strlen >= (size_t)padlen)
        return RedisModule_ReplyWithString(ctx,argv[1]);

    /* Padding must be a single character in this simple implementation. */
    if (chlen != 1)
        return RedisModule_ReplyWithError(ctx,
            ""ERR padding must be a single char"");

    /* Here we use our pool al...",509.0,541.0,1.0,58.0,33.0,23,10,36,10,0,10,6,6,1,10,,0,4,6,3,3,int
4706,208091,getMonotonicUs,1,getMonotonicUs,monotime getMonotonicUs (void),monotonic.c,monotime (*getMonotonicUs)(void) = NULL;,12.0,12.0,10.0,39.0,1.0,0,0,0,0,24,0,1,1,0,0,,0,0,2,1,1,monotime
4707,208102,getMonotonicUs_posix,1,getMonotonicUs_posix,monotime getMonotonicUs_posix (void),monotonic.c,"static monotime getMonotonicUs_posix(void) {
    /* clock_gettime() is specified in POSIX.1b (1993).  Even so, some systems
     * did not support this until much later.  CLOCK_MONOTONIC is technically
     * optional and may not be supported - but it appears to be universal.
     * If this is not supported, provide a system-specific alternate version.  */
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ((uint64_t)ts.tv_sec) * 1000000 + ts.tv_nsec / 1000;
}",133.0,141.0,1.0,1.0,9.0,7,6,4,2,0,0,1,1,0,0,,0,0,2,1,1,monotime
4708,208126,monotonicInit_posix,1,monotonicInit_posix,void monotonicInit_posix (void),monotonic.c,"static void monotonicInit_posix(void) {
    /* Ensure that CLOCK_MONOTONIC is supported.  This should be supported
     * on any reasonably current OS.  If the assertion below fails, provide
     * an appropriate alternate implementation.  */
    struct timespec ts;
    int rc = clock_gettime(CLOCK_MONOTONIC, &ts);
    assert(rc == 0);

    snprintf(monotonic_info_string, sizeof(monotonic_info_string),
            ""POSIX clock_gettime"");
    getMonotonicUs = getMonotonicUs_posix;
}",143.0,154.0,1.0,1.0,12.0,5,4,7,5,1,2,1,1,0,0,,0,2,2,1,1,void
4709,208151,monotonicInit,1,monotonicInit,const char* monotonicInit (void),monotonic.c,"const char * monotonicInit(void) {
    #if defined(USE_PROCESSOR_CLOCK) && defined(__x86_64__) && defined(__linux__)
    if (getMonotonicUs == NULL) monotonicInit_x86linux();
    #endif

    #if defined(USE_PROCESSOR_CLOCK) && defined(__aarch64__)
    if (getMonotonicUs == NULL) monotonicInit_aarch64();
    #endif

    if (getMonotonicUs == NULL) monotonicInit_posix();

    return monotonic_info_string;
}",158.0,170.0,1.0,1.0,13.0,1,1,3,3,2,2,2,2,0,1,,0,1,2,1,1,const char*
4710,208164,monotonicInfoString,1,monotonicInfoString,const char* monotonicInfoString (void),monotonic.c,"const char *monotonicInfoString(void) {
    return monotonic_info_string;
}",172.0,174.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,0,,0,1,2,1,1,const char*
4711,208171,monotonicGetType,1,monotonicGetType,monotonic_clock_type monotonicGetType (void),monotonic.c,"monotonic_clock_type monotonicGetType(void) {
    if (getMonotonicUs == getMonotonicUs_posix)
        return MONOTONIC_CLOCK_POSIX;
    return MONOTONIC_CLOCK_HW;
}",176.0,180.0,1.0,1.0,5.0,1,1,3,3,0,0,2,2,0,0,,0,0,2,1,1,monotonic_clock_type
4712,208221,elapsedStart,1,elapsedStart,void elapsedStart (monotime*),monotonic.h,"static inline void elapsedStart(monotime *start_time) {
    *start_time = getMonotonicUs();
}",49.0,51.0,1.0,1.0,3.0,2,2,1,1,4,1,1,1,0,1,,0,1,2,1,1,void
4713,208230,elapsedUs,1,elapsedUs,uint64_t elapsedUs (monotime),monotonic.h,"static inline uint64_t elapsedUs(monotime start_time) {
    return getMonotonicUs() - start_time;
}",53.0,55.0,1.0,1.0,3.0,1,1,1,1,7,1,1,1,0,1,,0,0,2,1,1,uint64_t
4714,208239,elapsedMs,1,elapsedMs,uint64_t elapsedMs (monotime),monotonic.h,"static inline uint64_t elapsedMs(monotime start_time) {
    return elapsedUs(start_time) / 1000;
}",57.0,59.0,1.0,1.0,3.0,1,1,1,1,5,1,1,1,0,1,,0,0,2,1,1,uint64_t
4715,208271,init_genrand64,1,init_genrand64,void init_genrand64 (long long unsigned),mt19937-64.c,"void init_genrand64(unsigned long long seed)
{
    mt[0] = seed;
    for (mti=1; mti<NN; mti++)
        mt[mti] =  (6364136223846793005ULL * (mt[mti-1] ^ (mt[mti-1] >> 62)) + mti);
}",73.0,78.0,1.0,20.0,6.0,4,3,4,3,4,3,2,2,1,0,,0,3,2,1,1,void
4716,208314,init_by_array64,1,init_by_array64,"void init_by_array64 (long long unsigned[],long long unsigned)",mt19937-64.c,"void init_by_array64(unsigned long long init_key[],
                     unsigned long long key_length)
{
    unsigned long long i, j, k;
    init_genrand64(19650218ULL);
    i=1; j=0;
    k = (NN>key_length ? NN : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 62)) * 3935559000370003845ULL))
          + init_key[j] + j; /* non linear */
        i++; j++;
        if (i>=NN) { mt[0] = mt[NN-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=NN-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 62)) * 2862933555777941757ULL))
          - i; /* non linear */
        i++;
        if (i>=NN) { mt[0] = mt[NN-1]; i=1; }
    }

    mt[0] = 1ULL << 63; /* MSB is 1; assuring non-zero initial array */
}",83.0,105.0,1.0,9.0,23.0,53,12,43,6,0,14,6,9,0,1,,0,13,4,2,2,void
4717,208477,genrand64_int64,1,genrand64_int64,unsigned long long genrand64_int64 (void),mt19937-64.c,"unsigned long long genrand64_int64(void)
{
    int i;
    unsigned long long x;
    static unsigned long long mag01[2]={0ULL, MATRIX_A};

    if (mti >= NN) { /* generate NN words at one time */

        /* if init_genrand64() has not been called, */
        /* a default initial seed is used     */
        if (mti == NN+1)
            init_genrand64(5489ULL);

        for (i=0;i<NN-MM;i++) {
            x = (mt[i]&UM)|(mt[i+1]&LM);
            mt[i] = mt[i+MM] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
        }
        for (;i<NN-1;i++) {
            x = (mt[i]&UM)|(mt[i+1]&LM);
            mt[i] = mt[i+(MM-NN)] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
        }
        x = (mt[NN-1]&UM)|(mt[0]&LM);
        mt[NN-1] = mt[MM-1] ^ (x>>1) ^ mag01[(int)(x&1ULL)];

        mti = 0;
    }

    x = mt[mti++];

    x ^= (x >> 29) & 0x5555555555555555ULL;
    x ^= (x << 17) & 0x71D67FFFEDA60000ULL;
    x ^= (x << 37) & 0xFFF7EEE000000000ULL;
    x ^= (x >> 43);

    return x;
}",108.0,143.0,1.0,46.0,36.0,74,15,51,5,7,18,5,8,2,1,,0,17,2,1,1,unsigned long long
4718,208712,genrand64_int63,1,genrand64_int63,long long genrand64_int63 (void),mt19937-64.c,"long long genrand64_int63(void)
{
    return (long long)(genrand64_int64() >> 1);
}",146.0,149.0,1.0,1.0,4.0,2,2,0,0,0,1,1,1,0,1,,0,0,2,1,1,long long
4719,208723,genrand64_real1,1,genrand64_real1,double genrand64_real1 (void),mt19937-64.c,"double genrand64_real1(void)
{
    return (genrand64_int64() >> 11) * (1.0/9007199254740991.0);
}",152.0,155.0,1.0,1.0,4.0,3,3,0,0,0,1,1,1,0,1,,0,0,2,1,1,double
4720,208736,genrand64_real2,1,genrand64_real2,double genrand64_real2 (void),mt19937-64.c,"double genrand64_real2(void)
{
    return (genrand64_int64() >> 11) * (1.0/9007199254740992.0);
}",158.0,161.0,1.0,1.0,4.0,3,3,0,0,0,1,1,1,0,1,,0,0,2,1,1,double
4721,208749,genrand64_real3,1,genrand64_real3,double genrand64_real3 (void),mt19937-64.c,"double genrand64_real3(void)
{
    return ((genrand64_int64() >> 12) + 0.5) * (1.0/4503599627370496.0);
}",164.0,167.0,1.0,1.0,4.0,4,4,0,0,0,1,1,1,0,1,,0,0,2,1,1,double
4722,208805,genrand64_real4,1,genrand64_real4,double genrand64_real4 (void),mt19937-64.h,double genrand64_real4(void);,85.0,85.0,8.0,28.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,double
4723,208817,initClientMultiState,1,initClientMultiState,void initClientMultiState (client*),multi.c,"void initClientMultiState(client *c) {
    c->mstate.commands = NULL;
    c->mstate.count = 0;
    c->mstate.cmd_flags = 0;
    c->mstate.cmd_inv_flags = 0;
    c->mstate.argv_len_sums = 0;
    c->mstate.alloc_count = 0;
}",35.0,42.0,1.0,1.0,8.0,18,3,7,2,2,6,1,1,0,0,,0,6,2,1,1,void
4724,208864,freeClientMultiState,1,freeClientMultiState,void freeClientMultiState (client*),multi.c,"void freeClientMultiState(client *c) {
    int j;

    for (j = 0; j < c->mstate.count; j++) {
        int i;
        multiCmd *mc = c->mstate.commands+j;

        for (i = 0; i < mc->argc; i++)
            decrRefCount(mc->argv[i]);
        zfree(mc->argv);
    }
    zfree(c->mstate.commands);
}",45.0,57.0,1.0,1.0,13.0,14,5,11,4,2,7,3,4,2,2,,0,5,2,1,1,void
4725,208924,queueMultiCommand,1,queueMultiCommand,"void queueMultiCommand (client*,uint64_t)",multi.c,"void queueMultiCommand(client *c, uint64_t cmd_flags) {
    multiCmd *mc;

    /* No sense to waste memory if the transaction is already aborted.
     * this is useful in case client sends these in a pipeline, or doesn't
     * bother to read previous responses and didn't notice the multi was already
     * aborted. */
    if (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC))
        return;
    if (c->mstate.count == 0) {
        /* If a client is using multi/exec, assuming it is used to execute at least
         * two commands. Hence, creating by default size of 2. */
        c->mstate.commands = zmalloc(sizeof(multiCmd)*2);
        c->mstate.alloc_count = 2;
    }
    if (c->mstate.count == c->mstate.alloc_count) {
        c->mstate.alloc_count = c->mstate.alloc_count < INT_MAX/2 ? c->mstate.alloc_count*2 : INT_MAX;
        c->mstate.commands = zrealloc(c->mstate.commands, sizeof(multiCmd)*(c->mstate.alloc_count));
    }
    mc = c->mstate.commands+c->mstate.count;
    mc->cmd = c...",60.0,96.0,1.0,20.0,37.0,83,16,41,7,2,34,4,4,4,2,,0,34,4,2,2,void
4726,209131,discardTransaction,1,discardTransaction,void discardTransaction (client*),multi.c,"void discardTransaction(client *c) {
    freeClientMultiState(c);
    initClientMultiState(c);
    c->flags &= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);
    unwatchAllKeys(c);
}",98.0,103.0,1.0,18.0,6.0,7,4,4,1,7,4,1,1,0,3,,0,1,2,1,1,void
4727,209164,flagTransaction,1,flagTransaction,void flagTransaction (client*),multi.c,"void flagTransaction(client *c) {
    if (c->flags & CLIENT_MULTI)
        c->flags |= CLIENT_DIRTY_EXEC;
}",107.0,110.0,1.0,19.0,4.0,5,3,2,1,2,2,2,2,1,0,,0,2,2,1,1,void
4728,209189,multiCommand,1,multiCommand,void multiCommand (client*),multi.c,"void multiCommand(client *c) {
    if (c->flags & CLIENT_MULTI) {
        addReplyError(c,""MULTI calls can not be nested"");
        return;
    }
    c->flags |= CLIENT_MULTI;

    addReply(c,shared.ok);
}",112.0,120.0,1.0,19.0,9.0,6,4,5,2,0,4,2,2,1,2,,0,2,2,1,1,void
4729,209223,discardCommand,1,discardCommand,void discardCommand (client*),multi.c,"void discardCommand(client *c) {
    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,""DISCARD without MULTI"");
        return;
    }
    discardTransaction(c);
    addReply(c,shared.ok);
}",122.0,129.0,1.0,21.0,8.0,5,5,5,2,0,4,2,2,1,3,,0,1,2,1,1,void
4730,209251,execCommandAbort,1,execCommandAbort,"void execCommandAbort (client*,sds)",multi.c,"void execCommandAbort(client *c, sds error) {
    discardTransaction(c);

    if (error[0] == '-') error++;
    addReplyErrorFormat(c, ""-EXECABORT Transaction discarded because of: %s"", error);

    /* Send EXEC to clients waiting data from MONITOR. We did send a MULTI
     * already, and didn't send any of the queued commands, now we'll just send
     * EXEC so it is clear that the transaction is over. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
}",136.0,146.0,1.0,1.0,11.0,8,5,10,3,2,6,2,2,0,3,,0,3,4,2,2,void
4731,209288,execCommand,1,execCommand,void execCommand (client*),multi.c,"void execCommand(client *c) {
    int j;
    robj **orig_argv;
    int orig_argc, orig_argv_len;
    struct redisCommand *orig_cmd;

    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,""EXEC without MULTI"");
        return;
    }

    /* EXEC with expired watched key is disallowed*/
    if (isWatchedKeyExpired(c)) {
        c->flags |= (CLIENT_DIRTY_CAS);
    }

    /* Check if we need to abort the EXEC because:
     * 1) Some WATCHed key was touched.
     * 2) There was a previous error while queueing commands.
     * A failed EXEC in the first case returns a multi bulk nil object
     * (technically it is not an error but a special behavior), while
     * in the second an EXECABORT error is returned. */
    if (c->flags & (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) {
        if (c->flags & CLIENT_DIRTY_EXEC) {
            addReplyErrorObject(c, shared.execaborterr);
        } else {
            addReply(c, shared.nullarray[c->resp]);
        }

        discardTransaction(c);...",148.0,256.0,1.0,21.0,109.0,110,12,81,13,0,45,13,13,5,10,,0,37,2,1,1,void
4732,209716,watchedKeyLinkToClients,1,watchedKeyLinkToClients,"void watchedKeyLinkToClients (list*,watchedKey*)",multi.c,"static inline void watchedKeyLinkToClients(list *clients, watchedKey *wk) {
    wk->node.value = clients; /* Point the value back to the list */
    listLinkNodeTail(clients, &wk->node); /* Link the embedded node */
}",283.0,286.0,1.0,1.0,4.0,5,4,4,2,1,3,1,1,0,1,,0,2,4,2,2,void
4733,209735,watchedKeyGetClients,1,watchedKeyGetClients,list watchedKeyGetClients (watchedKey*),multi.c,"static inline list *watchedKeyGetClients(watchedKey *wk) {
    return listNodeValue(&wk->node); /* embedded node->value points back to the list */
}",289.0,291.0,1.0,11.0,3.0,5,2,2,1,1,2,1,1,0,0,,0,2,2,1,1,list
4734,209753,watchedKeyGetClientNode,1,watchedKeyGetClientNode,listNode watchedKeyGetClientNode (watchedKey*),multi.c,"static inline listNode *watchedKeyGetClientNode(watchedKey *wk) {
    return &wk->node;
}",295.0,297.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,listNode
4735,209763,watchForKey,1,watchForKey,"void watchForKey (client*,robj*)",multi.c,"void watchForKey(client *c, robj *key) {
    list *clients = NULL;
    listIter li;
    listNode *ln;
    watchedKey *wk;

    /* Check if we are already watching for this key */
    listRewind(c->watched_keys,&li);
    while((ln = listNext(&li))) {
        wk = listNodeValue(ln);
        if (wk->db == c->db && equalStringObjects(key,wk->key))
            return; /* Key already watched */
    }
    /* This key is not already watched in this DB. Let's add it */
    clients = dictFetchValue(c->db->watched_keys,key);
    if (!clients) {
        clients = listCreate();
        dictAdd(c->db->watched_keys,key,clients);
        incrRefCount(key);
    }
    /* Add the new key to the list of keys watched by this client */
    wk = zmalloc(sizeof(*wk));
    wk->key = key;
    wk->client = c;
    wk->db = c->db;
    wk->expired = keyIsExpired(c->db, key);
    incrRefCount(key);
    listAddNodeTail(c->watched_keys, wk);
    watchedKeyLinkToClients(clients, wk);
}",300.0,329.0,1.0,13.0,30.0,33,8,38,7,0,26,4,5,5,12,,0,20,4,2,2,void
4736,209881,unwatchAllKeys,1,unwatchAllKeys,void unwatchAllKeys (client*),multi.c,"void unwatchAllKeys(client *c) {
    listIter li;
    listNode *ln;

    if (listLength(c->watched_keys) == 0) return;
    listRewind(c->watched_keys,&li);
    while((ln = listNext(&li))) {
        list *clients;
        watchedKey *wk;

        /* Remove the client's wk from the list of clients watching the key. */
        wk = listNodeValue(ln);
        clients = watchedKeyGetClients(wk);
        serverAssertWithInfo(c,NULL,clients != NULL);
        listUnlinkNode(clients, watchedKeyGetClientNode(wk));
        /* Kill the entry at all if this was the only client */
        if (listLength(clients) == 0)
            dictDelete(wk->db->watched_keys, wk->key);
        /* Remove this watched key from the client->watched list */
        listDelNode(c->watched_keys,ln);
        decrRefCount(wk->key);
        zfree(wk);
    }
}",333.0,356.0,1.0,8.0,24.0,23,9,27,6,5,19,4,5,4,10,,0,12,2,1,1,void
4737,209984,isWatchedKeyExpired,1,isWatchedKeyExpired,int isWatchedKeyExpired (client*),multi.c,"int isWatchedKeyExpired(client *c) {
    listIter li;
    listNode *ln;
    watchedKey *wk;
    if (listLength(c->watched_keys) == 0) return 0;
    listRewind(c->watched_keys,&li);
    while ((ln = listNext(&li))) {
        wk = listNodeValue(ln);
        if (wk->expired) continue; /* was expired when WATCH was called */
        if (keyIsExpired(wk->db, wk->key)) return 1;
    }

    return 0;
}",360.0,373.0,1.0,8.0,14.0,13,4,12,4,1,10,6,7,7,3,,0,9,2,1,1,int
4738,210048,touchWatchedKey,1,touchWatchedKey,"void touchWatchedKey (redisDb*,robj*)",multi.c,"void touchWatchedKey(redisDb *db, robj *key) {
    list *clients;
    listIter li;
    listNode *ln;

    if (dictSize(db->watched_keys) == 0) return;
    clients = dictFetchValue(db->watched_keys, key);
    if (!clients) return;

    /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
    /* Check if we are already watching for this key */
    listRewind(clients,&li);
    while((ln = listNext(&li))) {
        watchedKey *wk = redis_member2struct(watchedKey, node, ln);
        client *c = wk->client;

        if (wk->expired) {
            /* The key was already expired when WATCH was called. */
            if (db == wk->db &&
                equalStringObjects(key, wk->key) &&
                dictFind(db->dict, key->ptr) == NULL)
            {
                /* Already expired key is deleted, so logically no change. Clear
                 * the flag. Deleted keys are not flagged as expired. */
                wk->expired = 0;
                goto skip_client;
        ...",377.0,416.0,1.0,8.0,40.0,34,11,31,10,1,17,9,9,10,6,,0,15,4,2,2,void
4739,210176,touchAllWatchedKeysInDb,1,touchAllWatchedKeysInDb,"void touchAllWatchedKeysInDb (redisDb*,redisDb*)",multi.c,"void touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with) {
    listIter li;
    listNode *ln;
    dictEntry *de;

    if (dictSize(emptied->watched_keys) == 0) return;

    dictIterator *di = dictGetSafeIterator(emptied->watched_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        int exists_in_emptied = dictFind(emptied->dict, key->ptr) != NULL;
        if (exists_in_emptied ||
            (replaced_with && dictFind(replaced_with->dict, key->ptr)))
        {
            list *clients = dictGetVal(de);
            if (!clients) continue;
            listRewind(clients,&li);
            while((ln = listNext(&li))) {
                watchedKey *wk = redis_member2struct(watchedKey, node, ln);
                if (wk->expired) {
                    if (!replaced_with || !dictFind(replaced_with->dict, key->ptr)) {
                        /* Expired key now deleted. No logical change. Clear the
                         * flag. Deleted ke...",425.0,468.0,1.0,8.0,44.0,43,13,41,14,4,21,10,20,10,10,,0,19,4,2,2,void
4740,210358,watchCommand,1,watchCommand,void watchCommand (client*),multi.c,"void watchCommand(client *c) {
    int j;

    if (c->flags & CLIENT_MULTI) {
        addReplyError(c,""WATCH inside MULTI is not allowed"");
        return;
    }
    /* No point in watching if the client is already dirty. */
    if (c->flags & CLIENT_DIRTY_CAS) {
        addReply(c,shared.ok);
        return;
    }
    for (j = 1; j < c->argc; j++)
        watchForKey(c,c->argv[j]);
    addReply(c,shared.ok);
}",470.0,485.0,1.0,19.0,16.0,11,6,10,3,0,6,4,4,3,3,,0,3,2,1,1,void
4741,210420,unwatchCommand,1,unwatchCommand,void unwatchCommand (client*),multi.c,"void unwatchCommand(client *c) {
    unwatchAllKeys(c);
    c->flags &= (~CLIENT_DIRTY_CAS);
    addReply(c,shared.ok);
}",487.0,491.0,1.0,18.0,5.0,4,4,4,2,0,3,1,1,0,2,,0,1,2,1,1,void
4742,210442,multiStateMemOverhead,1,multiStateMemOverhead,size_t multiStateMemOverhead (client*),multi.c,"size_t multiStateMemOverhead(client *c) {
    size_t mem = c->mstate.argv_len_sums;
    /* Add watched keys overhead, Note: this doesn't take into account the watched keys themselves, because they aren't managed per-client. */
    mem += listLength(c->watched_keys) * (sizeof(listNode) + sizeof(watchedKey));
    /* Reserved memory for queued multi commands. */
    mem += c->mstate.alloc_count * sizeof(multiCmd);
    return mem;
}",493.0,500.0,1.0,11.0,8.0,16,7,11,5,1,4,1,1,0,0,,0,4,2,1,1,size_t
4743,210508,setProtocolError,1,setProtocolError,"void setProtocolError (char*,client*)",networking.c,"static void setProtocolError(const char *errstr, client *c) {
    if (server.verbosity <= LL_VERBOSE || c->flags & CLIENT_MASTER) {
        sds client = catClientInfoString(sdsempty(),c);

        /* Sample some protocol to given an idea about what was inside. */
        char buf[256];
        if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {
            snprintf(buf,sizeof(buf),""Query buffer during protocol error: '%s'"", c->querybuf+c->qb_pos);
        } else {
            snprintf(buf,sizeof(buf),""Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'"", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2);
        }

        /* Remove non printable chars. */
        char *p = buf;
        while (*p != '\0') {
            if (!isprint(*p)) *p = '.';
            p++;
        }

        /* Log all the client and protocol info. */
        int loglevel = (c->fla...",2213.0,2240.0,1.0,28.0,28.0,0,0,0,0,8,0,1,1,0,0,,0,0,4,2,2,void
4744,210514,pauseClientsByClient,1,pauseClientsByClient,"void pauseClientsByClient (mstime_t,int)",networking.c,"static void pauseClientsByClient(mstime_t endTime, int isPauseClientAll) {
    uint32_t actions;
    pause_event *p = &server.client_pause_per_purpose[PAUSE_BY_CLIENT_COMMAND];

    if (isPauseClientAll)
        actions = PAUSE_ACTIONS_CLIENT_ALL_SET;
    else {
        actions = PAUSE_ACTIONS_CLIENT_WRITE_SET;
        /* If currently configured most restrictive client pause, then keep it */
        if (p->paused_actions & PAUSE_ACTION_CLIENT_ALL)
            actions = PAUSE_ACTIONS_CLIENT_ALL_SET;
    }
    
    pauseActions(PAUSE_BY_CLIENT_COMMAND, endTime, actions);
}",4015.0,4029.0,1.0,18.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
4745,210520,postponeClientRead,1,postponeClientRead,int postponeClientRead (client*),networking.c,"int postponeClientRead(client *c) {
    if (server.io_threads_active &&
        server.io_threads_do_reads &&
        !ProcessingEventsWhileBlocked &&
        !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_BLOCKED)) &&
        io_threads_op == IO_THREADS_OP_IDLE)
    {
        listAddNodeHead(server.clients_pending_read,c);
        c->pending_read_list_node = listFirst(server.clients_pending_read);
        return 1;
    } else {
        return 0;
    }
}",4416.0,4429.0,1.0,22.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4746,210525,getClientSockname,1,getClientSockname,char* getClientSockname (client*),networking.c,"char *getClientSockname(client *c) {
    char sockname[NET_ADDR_STR_LEN] = {0};

    if (c->sockname == NULL) {
        genClientAddrString(c,sockname,sizeof(sockname),0);
        c->sockname = sdsnew(sockname);
    }
    return c->sockname;
}",2760.0,2768.0,1.0,18.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,char*
4747,210534,sdsZmallocSize,1,sdsZmallocSize,size_t sdsZmallocSize (sds),networking.c,"size_t sdsZmallocSize(sds s) {
    void *sh = sdsAllocPtr(s);
    return zmalloc_size(sh);
}",49.0,52.0,1.0,1.0,4.0,1,1,3,2,10,2,1,1,0,2,,0,1,2,1,1,size_t
4748,210547,getStringObjectSdsUsedMemory,1,getStringObjectSdsUsedMemory,size_t getStringObjectSdsUsedMemory (robj*),networking.c,"size_t getStringObjectSdsUsedMemory(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    switch(o->encoding) {
    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
    default: return 0; /* Just integer encoding for now. */
    }
}",56.0,63.0,1.0,4.0,8.0,10,8,9,3,2,3,2,2,0,3,,0,0,2,1,1,size_t
4749,210601,getStringObjectLen,1,getStringObjectLen,size_t getStringObjectLen (robj*),networking.c,"size_t getStringObjectLen(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    switch(o->encoding) {
    case OBJ_ENCODING_RAW: return sdslen(o->ptr);
    case OBJ_ENCODING_EMBSTR: return sdslen(o->ptr);
    default: return 0; /* Just integer encoding for now. */
    }
}",67.0,74.0,1.0,4.0,8.0,9,6,8,2,2,3,2,2,0,3,,0,0,2,1,1,size_t
4750,210654,dupClientReplyValue,1,dupClientReplyValue,void* dupClientReplyValue (void*),networking.c,"void *dupClientReplyValue(void *o) {
    clientReplyBlock *old = o;
    clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
    memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
    return buf;
}",77.0,82.0,1.0,1.0,6.0,8,4,10,4,0,3,1,1,0,1,,0,3,2,1,1,void*
4751,210684,freeClientReplyValue,1,freeClientReplyValue,void freeClientReplyValue (void*),networking.c,"void freeClientReplyValue(void *o) {
    zfree(o);
}",84.0,86.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
4752,210691,linkClient,1,linkClient,void linkClient (client*),networking.c,"void linkClient(client *c) {
    listAddNodeTail(server.clients,c);
    /* Note that we remember the linked list node where the client is stored,
     * this way removing the client in unlinkClient() will not require
     * a linear scan, but just a constant time operation. */
    c->client_list_node = listLast(server.clients);
    uint64_t id = htonu64(c->id);
    raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
}",90.0,98.0,1.0,26.0,9.0,13,6,13,4,1,6,1,1,0,3,,0,4,2,1,1,void
4753,210739,clientSetDefaultAuth,1,clientSetDefaultAuth,void clientSetDefaultAuth (client*),networking.c,"static void clientSetDefaultAuth(client *c) {
    /* If the default user does not require authentication, the user is
     * directly authenticated. */
    c->user = DefaultUser;
    c->authenticated = (c->user->flags & USER_FLAG_NOPASS) &&
                       !(c->user->flags & USER_FLAG_DISABLED);
}",102.0,108.0,1.0,41.0,7.0,14,6,5,2,2,4,1,1,0,0,,0,4,2,1,1,void
4754,210777,authRequired,1,authRequired,int authRequired (client*),networking.c,"int authRequired(client *c) {
    /* Check if the user is authenticated. This check is skipped in case
     * the default user is flagged as ""nopass"" and is active. */
    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||
                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&
                        !c->authenticated;
    return auth_required;
}",110.0,117.0,1.0,48.0,8.0,12,7,5,3,1,1,1,1,0,0,,0,1,2,1,1,int
4755,210812,createClient,1,createClient,client createClient (connection*),redis-benchmark.c,"static client createClient(char *cmd, size_t len, client from, int thread_id) {
    int j;
    int is_cluster_client = (config.cluster_mode && thread_id >= 0);
    client c = zmalloc(sizeof(struct _client));

    const char *ip = NULL;
    int port = 0;
    c->cluster_node = NULL;
    if (config.hostsocket == NULL || is_cluster_client) {
        if (!is_cluster_client) {
            ip = config.conn_info.hostip;
            port = config.conn_info.hostport;
        } else {
            int node_idx = 0;
            if (config.num_threads < config.cluster_node_count)
                node_idx = config.liveclients % config.cluster_node_count;
            else
                node_idx = thread_id % config.cluster_node_count;
            clusterNode *node = config.cluster_nodes[node_idx];
            assert(node != NULL);
            ip = (const char *) node->ip;
            port = node->port;
            c->cluster_node = node;
        }
        c->context = redisConnectNonBlock(ip,port...",663.0,850.0,1.0,26.0,188.0,170,7,131,9,7,97,4,5,0,18,,0,87,8,4,4,client
4756,211285,installClientWriteHandler,1,installClientWriteHandler,void installClientWriteHandler (client*),networking.c,"void installClientWriteHandler(client *c) {
    int ae_barrier = 0;
    /* For the fsync=always policy, we want that a given FD is never
     * served for reading and writing in the same event loop iteration,
     * so that in the middle of receiving the query, and serving it
     * to the client, we'll call beforeSleep() that will do the
     * actual fsync of AOF to disk. the write barrier ensures that. */
    if (server.aof_state == AOF_ON &&
        server.aof_fsync == AOF_FSYNC_ALWAYS)
    {
        ae_barrier = 1;
    }
    if (connSetWriteHandlerWithBarrier(c->conn, sendReplyToClient, ae_barrier) == C_ERR) {
        freeClientAsync(c);
    }
}",220.0,235.0,1.0,28.0,16.0,10,6,8,4,2,3,3,3,2,2,,0,2,2,1,1,void
4757,211329,putClientInPendingWriteQueue,1,putClientInPendingWriteQueue,void putClientInPendingWriteQueue (client*),networking.c,"void putClientInPendingWriteQueue(client *c) {
    /* Schedule the client to write the output buffers to the socket only
     * if not already done and, for slaves, if the slave can actually receive
     * writes at this stage. */
    if (!(c->flags & CLIENT_PENDING_WRITE) &&
        (c->replstate == REPL_STATE_NONE ||
         (c->replstate == SLAVE_STATE_ONLINE && !c->repl_start_cmd_stream_on_ack)))
    {
        /* Here instead of installing the write handler, we just flag the
         * client and put it into a list of clients that have something
         * to write to the socket. This way before re-entering the event
         * loop, we can try to directly write to the client sockets avoiding
         * a system call. We'll only really install the write handler if
         * we'll not be able to write the whole reply at once. */
        c->flags |= CLIENT_PENDING_WRITE;
        listLinkNodeHead(server.clients_pending_write, &c->clients_pending_write_node);
    }
}",244.0,261.0,1.0,21.0,18.0,18,9,8,3,3,7,2,2,4,1,,0,6,2,1,1,void
4758,211382,prepareClientToWrite,1,prepareClientToWrite,int prepareClientToWrite (client*),networking.c,"int prepareClientToWrite(client *c) {
    /* If it's the Lua client we always return ok without installing any
     * handler since there is no socket at all. */
    if (c->flags & (CLIENT_SCRIPT|CLIENT_MODULE)) return C_OK;

    /* If CLIENT_CLOSE_ASAP flag is set, we need not write anything. */
    if (c->flags & CLIENT_CLOSE_ASAP) return C_ERR;

    /* CLIENT REPLY OFF / SKIP handling: don't send replies.
     * CLIENT_PUSHING handling: disables the reply silencing flags. */
    if ((c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) &&
        !(c->flags & CLIENT_PUSHING)) return C_ERR;

    /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
     * is set. */
    if ((c->flags & CLIENT_MASTER) &&
        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;

    if (!c->conn) return C_ERR; /* Fake client for AOF loading. */

    /* Schedule the client to write the output buffers to the socket, unless
     * it should already be setup to do so (it has already ...",285.0,317.0,1.0,20.0,33.0,35,8,10,2,7,9,7,7,8,2,,0,8,2,1,1,int
4759,211512,_addReplyToBuffer,1,_addReplyToBuffer,"size_t _addReplyToBuffer (client*,char*,size_t)",networking.c,"size_t _addReplyToBuffer(client *c, const char *s, size_t len) {
    size_t available = c->buf_usable_size - c->bufpos;

    /* If there already are entries in the reply list, we cannot
     * add anything more to the static buffer. */
    if (listLength(c->reply) > 0) return 0;

    size_t reply_len = len > available ? available : len;
    memcpy(c->buf+c->bufpos,s,reply_len);
    c->bufpos+=reply_len;
    /* We update the buffer peak after appending the reply to the buffer */
    if(c->buf_peak < (size_t)c->bufpos)
        c->buf_peak = (size_t)c->bufpos;
    return reply_len;
}",330.0,344.0,1.0,8.0,15.0,24,9,21,5,1,11,3,3,4,0,,0,11,6,3,3,size_t
4760,211591,_addReplyProtoToList,1,_addReplyProtoToList,"void _addReplyProtoToList (client*,list*,char*,size_t)",networking.c,"void _addReplyProtoToList(client *c, list *reply_list, const char *s, size_t len) {
    listNode *ln = listLast(reply_list);
    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;

    /* Note that 'tail' may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used, it sets a dummy node to NULL just
     * to fill it later, when the size of the bulk length is set. */

    /* Append to tail string when possible. */
    if (tail) {
        /* Copy the part we can fit into the tail, and leave the rest for a
         * new node */
        size_t avail = tail->size - tail->used;
        size_t copy = avail >= len? len: avail;
        memcpy(tail->buf + tail->used, s, copy);
        tail->used += copy;
        s += copy;
        len -= copy;
    }
    if (len) {
        /* Create a new node, make sure it is allocated to at
         * least PROTO_REPLY_CHUNK_BYTES */
        size_t usable_size;
        size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPL...",348.0,382.0,1.0,19.0,35.0,38,12,48,12,2,15,3,3,0,3,,0,13,8,4,4,void
4761,211725,cmdHasPushAsReply,1,cmdHasPushAsReply,int cmdHasPushAsReply (redisCommand*),networking.c,"int cmdHasPushAsReply(struct redisCommand *cmd) {
    if (!cmd) return 0;
    return cmd->proc == subscribeCommand  || cmd->proc == unsubscribeCommand ||
           cmd->proc == psubscribeCommand || cmd->proc == punsubscribeCommand ||
           cmd->proc == ssubscribeCommand || cmd->proc == sunsubscribeCommand;
}",387.0,392.0,1.0,1.0,6.0,18,4,13,7,1,6,2,2,0,0,,0,6,2,1,1,int
4762,211772,_addReplyToBufferOrList,1,_addReplyToBufferOrList,"void _addReplyToBufferOrList (client*,char*,size_t)",networking.c,"void _addReplyToBufferOrList(client *c, const char *s, size_t len) {
    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;

    /* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the
     * replication link that caused a reply to be generated we'll simply disconnect it.
     * Note this is the simplest way to check a command added a response. Replication links are used to write data but
     * not for responses, so we should normally never get here on a replica client. */
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        sds cmdname = c->lastcmd ? c->lastcmd->fullname : NULL;
        logInvalidUseAndFreeClientAsync(c, ""Replica generated a reply to command '%s'"",
                                        cmdname ? cmdname : ""<unknown>"");
        return;
    }

    /* We call it here because this function may affect the reply
     * buffer offset (see function comment) */
    reqresSaveClientReplyOffset(c);

    /* If we...",394.0,426.0,1.0,19.0,33.0,28,12,31,7,3,12,5,5,4,7,,0,8,6,3,3,void
4763,211882,addReply,1,addReply,"void addReply (client*,robj*)",networking.c,"void addReply(client *c, robj *obj) {
    if (prepareClientToWrite(c) != C_OK) return;

    if (sdsEncodedObject(obj)) {
        _addReplyToBufferOrList(c,obj->ptr,sdslen(obj->ptr));
    } else if (obj->encoding == OBJ_ENCODING_INT) {
        /* For integer encoded strings we just convert it into a string
         * using our optimized function, and attach the resulting string
         * to the output buffer. */
        char buf[32];
        size_t len = ll2string(buf,sizeof(buf),(long)obj->ptr);
        _addReplyToBufferOrList(c,buf,len);
    } else {
        serverPanic(""Wrong obj->encoding in addReply()"");
    }
}",434.0,449.0,1.0,35.0,16.0,8,4,7,2,87,3,3,3,1,3,,0,2,4,2,2,void
4764,211960,addReplySds,1,addReplySds,"void addReplySds (client*,sds)",networking.c,"void addReplySds(client *c, sds s) {
    if (prepareClientToWrite(c) != C_OK) {
        /* The caller expects the sds to be free'd. */
        sdsfree(s);
        return;
    }
    _addReplyToBufferOrList(c,s,sdslen(s));
    sdsfree(s);
}",453.0,461.0,1.0,35.0,9.0,1,1,6,2,2,5,2,2,1,5,,0,2,4,2,2,void
4765,211984,addReplyProto,1,addReplyProto,"void addReplyProto (client*,char*,size_t)",networking.c,"void addReplyProto(client *c, const char *s, size_t len) {
    if (prepareClientToWrite(c) != C_OK) return;
    _addReplyToBufferOrList(c,s,len);
}",471.0,474.0,1.0,35.0,4.0,1,1,4,3,21,2,2,2,1,2,,0,1,6,3,3,void
4766,212004,addReplyErrorLength,1,addReplyErrorLength,"void addReplyErrorLength (client*,char*,size_t)",networking.c,"void addReplyErrorLength(client *c, const char *s, size_t len) {
    /* If the string already starts with ""-..."" then the error code
     * is provided by the caller. Otherwise we use ""-ERR"". */
    if (!len || s[0] != '-') addReplyProto(c,""-ERR "",5);
    addReplyProto(c,s,len);
    addReplyProto(c,""\r\n"",2);
}",485.0,491.0,1.0,1.0,7.0,4,4,7,3,3,3,2,2,0,3,,0,0,6,3,3,void
4767,212033,afterErrorReply,1,afterErrorReply,"void afterErrorReply (client*,char*,size_t,int)",networking.c,"void afterErrorReply(client *c, const char *s, size_t len, int flags) {
    /* Module clients fall into two categories:
     * Calls to RM_Call, in which case the error isn't being returned to a client, so should not be counted.
     * Module thread safe context calls to RM_ReplyWithError, which will be added to a real client by the main thread later. */
    if (c->flags & CLIENT_MODULE) {
        if (!c->deferred_reply_errors) {
            c->deferred_reply_errors = listCreate();
            listSetFreeMethod(c->deferred_reply_errors, (void (*)(void*))sdsfree);
        }
        listAddNodeTail(c->deferred_reply_errors, sdsnewlen(s, len));
        return;
    }

    if (!(flags & ERR_REPLY_FLAG_NO_STATS_UPDATE)) {
        /* Increment the global error counter */
        server.stat_total_error_replies++;
        /* Increment the error stats
         * If the string already starts with ""-..."" then the error prefix
         * is provided by the caller ( we limit the search to 32 cha...",496.0,587.0,1.0,19.0,92.0,71,17,57,16,6,19,10,16,4,8,,0,14,8,4,4,void
4768,212351,addReplyErrorObject,1,addReplyErrorObject,"void addReplyErrorObject (client*,robj*)",networking.c,"void addReplyErrorObject(client *c, robj *err) {
    addReply(c, err);
    afterErrorReply(c, err->ptr, sdslen(err->ptr)-2, 0); /* Ignore trailing \r\n */
}",591.0,594.0,1.0,1.0,4.0,3,2,5,2,26,3,1,1,0,3,,0,1,4,2,2,void
4769,212372,addReplyOrErrorObject,1,addReplyOrErrorObject,"void addReplyOrErrorObject (client*,robj*)",networking.c,"void addReplyOrErrorObject(client *c, robj *reply) {
    serverAssert(sdsEncodedObject(reply));
    sds rep = reply->ptr;
    if (sdslen(rep) > 1 && rep[0] == '-') {
        addReplyErrorObject(c, reply);
    } else {
        addReply(c, reply);
    }
}",601.0,609.0,1.0,4.0,9.0,15,11,8,3,3,3,2,2,1,3,,0,1,4,2,2,void
4770,212428,addReplyError,1,addReplyError,"void addReplyError (client*,char*)",networking.c,"void addReplyError(client *c, const char *err) {
    addReplyErrorLength(c,err,strlen(err));
    afterErrorReply(c,err,strlen(err),0);
}",612.0,615.0,1.0,1.0,4.0,0,0,6,2,129,2,1,1,0,2,,0,0,4,2,2,void
4771,212445,addReplyErrorSdsEx,1,addReplyErrorSdsEx,"void addReplyErrorSdsEx (client*,sds,int)",networking.c,"void addReplyErrorSdsEx(client *c, sds err, int flags) {
    addReplyErrorLength(c,err,sdslen(err));
    afterErrorReply(c,err,sdslen(err),flags);
    sdsfree(err);
}",620.0,624.0,1.0,1.0,5.0,0,0,8,3,2,5,1,1,0,5,,0,2,6,3,3,void
4772,212465,addReplyErrorSds,1,addReplyErrorSds,"void addReplyErrorSds (client*,sds)",networking.c,"void addReplyErrorSds(client *c, sds err) {
    addReplyErrorSdsEx(c, err, 0);
}",628.0,630.0,1.0,1.0,3.0,0,0,2,2,5,1,1,1,0,1,,0,0,4,2,2,void
4773,212475,addReplyErrorSdsSafe,1,addReplyErrorSdsSafe,"void addReplyErrorSdsSafe (client*,sds)",networking.c,"void addReplyErrorSdsSafe(client *c, sds err) {
    err = sdsmapchars(err, ""\r\n"", ""  "",  2);
    addReplyErrorSdsEx(c, err, 0);
}",634.0,637.0,1.0,1.0,4.0,1,1,4,2,0,2,1,1,0,2,,0,1,4,2,2,void
4774,212492,addReplyErrorFormatInternal,1,addReplyErrorFormatInternal,"void addReplyErrorFormatInternal (client*,int,char*,va_list)",networking.c,"void addReplyErrorFormatInternal(client *c, int flags, const char *fmt, va_list ap) {
    va_list cpy;
    va_copy(cpy,ap);
    sds s = sdscatvprintf(sdsempty(),fmt,cpy);
    va_end(cpy);
    /* Trim any newlines at the end (ones will be added by addReplyErrorLength) */
    s = sdstrim(s, ""\r\n"");
    /* Make sure there are no newlines in the middle of the string, otherwise
     * invalid protocol is emitted. */
    s = sdsmapchars(s, ""\r\n"", ""  "",  2);
    addReplyErrorLength(c,s,sdslen(s));
    afterErrorReply(c,s,sdslen(s),flags);
    sdsfree(s);
}",641.0,654.0,1.0,1.0,14.0,3,1,18,6,3,9,1,1,0,9,,0,6,8,4,4,void
4775,212538,addReplyErrorFormatEx,1,addReplyErrorFormatEx,"void addReplyErrorFormatEx (client*,int,char*...)",networking.c,"void addReplyErrorFormatEx(client *c, int flags, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    addReplyErrorFormatInternal(c, flags, fmt, ap);
    va_end(ap);
}",656.0,661.0,1.0,1.0,6.0,0,0,7,4,0,1,1,1,0,1,,0,0,6,3,3,void
4776,212556,addReplyErrorFormat,1,addReplyErrorFormat,"void addReplyErrorFormat (client*,char*...)",networking.c,"void addReplyErrorFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    addReplyErrorFormatInternal(c, 0, fmt, ap);
    va_end(ap);
}",665.0,670.0,1.0,1.0,6.0,0,0,6,3,29,1,1,1,0,1,,0,0,4,2,2,void
4777,212573,addReplyErrorArity,1,addReplyErrorArity,void addReplyErrorArity (client*),networking.c,"void addReplyErrorArity(client *c) {
    addReplyErrorFormat(c, ""wrong number of arguments for '%s' command"",
                        c->cmd->fullname);
}",672.0,675.0,1.0,1.0,4.0,2,1,2,1,5,2,1,1,0,1,,0,1,2,1,1,void
4778,212586,addReplyErrorExpireTime,1,addReplyErrorExpireTime,void addReplyErrorExpireTime (client*),networking.c,"void addReplyErrorExpireTime(client *c) {
    addReplyErrorFormat(c, ""invalid expire time in '%s' command"",
                        c->cmd->fullname);
}",677.0,680.0,1.0,1.0,4.0,2,1,2,1,2,2,1,1,0,1,,0,1,2,1,1,void
4779,212599,addReplyStatusLength,1,addReplyStatusLength,"void addReplyStatusLength (client*,char*,size_t)",networking.c,"void addReplyStatusLength(client *c, const char *s, size_t len) {
    addReplyProto(c,""+"",1);
    addReplyProto(c,s,len);
    addReplyProto(c,""\r\n"",2);
}",682.0,686.0,1.0,1.0,5.0,0,0,5,3,2,3,1,1,0,3,,0,0,6,3,3,void
4780,212618,addReplyStatus,1,addReplyStatus,"void addReplyStatus (client*,char*)",networking.c,"void addReplyStatus(client *c, const char *status) {
    addReplyStatusLength(c,status,strlen(status));
}",688.0,690.0,1.0,1.0,3.0,0,0,3,2,6,1,1,1,0,1,,0,0,4,2,2,void
4781,212629,addReplyStatusFormat,1,addReplyStatusFormat,"void addReplyStatusFormat (client*,char*...)",networking.c,"void addReplyStatusFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    sds s = sdscatvprintf(sdsempty(),fmt,ap);
    va_end(ap);
    addReplyStatusLength(c,s,sdslen(s));
    sdsfree(s);
}",692.0,699.0,1.0,1.0,8.0,1,1,10,4,2,5,1,1,0,5,,0,3,4,2,2,void
4782,212655,trimReplyUnusedTailSpace,1,trimReplyUnusedTailSpace,void trimReplyUnusedTailSpace (client*),networking.c,"void trimReplyUnusedTailSpace(client *c) {
    listNode *ln = listLast(c->reply);
    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;

    /* Note that 'tail' may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used */
    if (!tail) return;

    /* We only try to trim the space is relatively high (more than a 1/4 of the
     * allocation), otherwise there's a high chance realloc will NOP.
     * Also, to avoid large memmove which happens as part of realloc, we only do
     * that if the used part is small.  */
    if (tail->size - tail->used > tail->size / 4 &&
        tail->used < PROTO_REPLY_CHUNK_BYTES)
    {
        size_t usable_size;
        size_t old_size = tail->size;
        tail = zrealloc_usable(tail, tail->used + sizeof(clientReplyBlock), &usable_size);
        /* take over the allocation's internal fragmentation (at least for
         * memory usage tracking) */
        tail->size = usable_size - sizeof(clientReplyBlock);
      ...",704.0,728.0,1.0,19.0,25.0,37,13,30,7,1,15,3,3,4,1,,0,15,2,1,1,void
4783,212763,addReplyDeferredLen,1,addReplyDeferredLen,void* addReplyDeferredLen (client*),networking.c,"void *addReplyDeferredLen(client *c) {
    /* Note that we install the write event here even if the object is not
     * ready to be sent, since we are sure that before returning to the
     * event loop setDeferredAggregateLen() will be called. */
    if (prepareClientToWrite(c) != C_OK) return NULL;

    /* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the
     * replication link that caused a reply to be generated we'll simply disconnect it.
     * Note this is the simplest way to check a command added a response. Replication links are used to write data but
     * not for responses, so we should normally never get here on a replica client. */
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        sds cmdname = c->lastcmd ? c->lastcmd->fullname : NULL;
        logInvalidUseAndFreeClientAsync(c, ""Replica generated a reply to command '%s'"",
                                        cmdname ? cmdname : ""<unknown>"");
    ...",732.0,756.0,1.0,35.0,25.0,12,5,17,3,17,11,3,3,2,6,,0,7,2,1,1,void*
4784,212828,setDeferredReply,1,setDeferredReply,"void setDeferredReply (client*,void*,char*,size_t)",networking.c,"void setDeferredReply(client *c, void *node, const char *s, size_t length) {
    listNode *ln = (listNode*)node;
    clientReplyBlock *next, *prev;

    /* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addReplyDeferredLen() */
    if (node == NULL) return;
    serverAssert(!listNodeValue(ln));

    /* Normally we fill this dummy NULL node, added by addReplyDeferredLen(),
     * with a new buffer structure containing the protocol needed to specify
     * the length of the array following. However sometimes there might be room
     * in the previous/next node so we can instead remove this NULL node, and
     * suffix/prefix our data in the node immediately before/after it, in order
     * to save a write(2) syscall later. Conditions needed to do it:
     *
     * - The prev node is non-NULL and has space in it or
     * - The next node is non-NULL,
     * - It has enough room already allocated
     * - And not too large (avoid large memmov...",758.0,815.0,1.0,4.0,58.0,61,18,52,9,5,27,6,8,11,3,,0,24,8,4,4,void
4785,213067,setDeferredAggregateLen,1,setDeferredAggregateLen,"void setDeferredAggregateLen (client*,void*,long,char)",networking.c,"void setDeferredAggregateLen(client *c, void *node, long length, char prefix) {
    serverAssert(length >= 0);

    /* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addReplyDeferredLen() */
    if (node == NULL) return;

    /* Things like *2\r\n, %3\r\n or ~4\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */
    const size_t hdr_len = OBJ_SHARED_HDR_STRLEN(length);
    const int opt_hdr = length < OBJ_SHARED_BULKHDR_LEN;
    if (prefix == '*' && opt_hdr) {
        setDeferredReply(c, node, shared.mbulkhdr[length]->ptr, hdr_len);
        return;
    }
    if (prefix == '%' && opt_hdr) {
        setDeferredReply(c, node, shared.maphdr[length]->ptr, hdr_len);
        return;
    }
    if (prefix == '~' && opt_hdr) {
        setDeferredReply(c, node, shared.sethdr[length]->ptr, hdr_len);
        return;
    }

    char lenstr[128];
    siz...",818.0,846.0,1.0,4.0,29.0,28,13,38,10,5,5,5,5,0,5,,0,0,8,4,4,void
4786,213190,setDeferredArrayLen,1,setDeferredArrayLen,"void setDeferredArrayLen (client*,void*,long)",networking.c,"void setDeferredArrayLen(client *c, void *node, long length) {
    setDeferredAggregateLen(c,node,length,'*');
}",848.0,850.0,1.0,1.0,3.0,0,0,3,3,11,1,1,1,0,1,,0,0,6,3,3,void
4787,213202,setDeferredMapLen,1,setDeferredMapLen,"void setDeferredMapLen (client*,void*,long)",networking.c,"void setDeferredMapLen(client *c, void *node, long length) {
    int prefix = c->resp == 2 ? '*' : '%';
    if (c->resp == 2) length *= 2;
    setDeferredAggregateLen(c,node,length,prefix);
}",852.0,856.0,1.0,1.0,5.0,7,5,8,4,6,3,2,2,1,1,,0,2,6,3,3,void
4788,213235,setDeferredSetLen,1,setDeferredSetLen,"void setDeferredSetLen (client*,void*,long)",networking.c,"void setDeferredSetLen(client *c, void *node, long length) {
    int prefix = c->resp == 2 ? '*' : '~';
    setDeferredAggregateLen(c,node,length,prefix);
}",858.0,861.0,1.0,1.0,4.0,4,4,6,4,2,2,1,1,0,1,,0,1,6,3,3,void
4789,213258,setDeferredAttributeLen,1,setDeferredAttributeLen,"void setDeferredAttributeLen (client*,void*,long)",networking.c,"void setDeferredAttributeLen(client *c, void *node, long length) {
    serverAssert(c->resp >= 3);
    setDeferredAggregateLen(c,node,length,'|');
}",863.0,866.0,1.0,4.0,4.0,6,6,4,3,1,3,1,1,0,2,,0,1,6,3,3,void
4790,213288,setDeferredPushLen,1,setDeferredPushLen,"void setDeferredPushLen (client*,void*,long)",networking.c,"void setDeferredPushLen(client *c, void *node, long length) {
    serverAssert(c->resp >= 3);
    setDeferredAggregateLen(c,node,length,'>');
}",868.0,871.0,1.0,4.0,4.0,6,6,4,3,0,3,1,1,0,2,,0,1,6,3,3,void
4791,213318,addReplyDouble,1,addReplyDouble,"void addReplyDouble (client*,double)",networking.c,"void addReplyDouble(client *c, double d) {
    if (c->resp == 3) {
        char dbuf[MAX_D2STRING_CHARS+3];
        dbuf[0] = ',';
        const int dlen = d2string(dbuf+1,sizeof(dbuf)-1,d);
        dbuf[dlen+1] = '\r';
        dbuf[dlen+2] = '\n';
        dbuf[dlen+3] = '\0';
        addReplyProto(c,dbuf,dlen+3);
    } else {
        char dbuf[MAX_LONG_DOUBLE_CHARS+32];
        /* In order to prepend the string length before the formatted number,
         * but still avoid an extra memcpy of the whole number, we reserve space
         * for maximum header `$0000\r\n`, print double, add the resp header in
         * front of it, and then send the buffer with the right `start` offset. */
        const int dlen = d2string(dbuf+7,sizeof(dbuf)-7,d);
        int digits = digits10(dlen);
        int start = 4 - digits;
        serverAssert(start >= 0);
        dbuf[start] = '$';

        /* Convert `dlen` to string, putting it's digits after '$' and before the
            * formatted doub...",874.0,907.0,1.0,18.0,34.0,18,7,15,4,9,3,2,2,1,2,,0,2,4,2,2,void
4792,213497,addReplyBigNum,1,addReplyBigNum,"void addReplyBigNum (client*,char*,size_t)",networking.c,"void addReplyBigNum(client *c, const char* num, size_t len) {
    if (c->resp == 2) {
        addReplyBulkCBuffer(c, num, len);
    } else {
        addReplyProto(c,""("",1);
        addReplyProto(c,num,len);
        addReplyProto(c,""\r\n"",2);
    }
}",909.0,917.0,1.0,1.0,9.0,2,2,4,3,1,2,2,2,1,1,,0,1,6,3,3,void
4793,213529,addReplyHumanLongDouble,1,addReplyHumanLongDouble,"void addReplyHumanLongDouble (client*,long double)",networking.c,"void addReplyHumanLongDouble(client *c, long double d) {
    if (c->resp == 2) {
        robj *o = createStringObjectFromLongDouble(d,1);
        addReplyBulk(c,o);
        decrRefCount(o);
    } else {
        char buf[MAX_LONG_DOUBLE_CHARS];
        int len = ld2string(buf,sizeof(buf),d,LD_STR_HUMAN);
        addReplyProto(c,"","",1);
        addReplyProto(c,buf,len);
        addReplyProto(c,""\r\n"",2);
    }
}",922.0,934.0,1.0,17.0,13.0,3,3,6,3,3,4,2,2,1,3,,0,2,4,2,2,void
4794,213577,addReplyLongLongWithPrefix,1,addReplyLongLongWithPrefix,"void addReplyLongLongWithPrefix (client*,long long,char)",networking.c,"void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {
    char buf[128];
    int len;

    /* Things like $3\r\n or *2\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */
    const int opt_hdr = ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0;
    const size_t hdr_len = OBJ_SHARED_HDR_STRLEN(ll);
    if (prefix == '*' && opt_hdr) {
        addReplyProto(c,shared.mbulkhdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '$' && opt_hdr) {
        addReplyProto(c,shared.bulkhdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '%' && opt_hdr) {
        addReplyProto(c,shared.maphdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '~' && opt_hdr) {
        addReplyProto(c,shared.sethdr[ll]->ptr,hdr_len);
        return;
    }

    buf[0] = prefix;
    len = ll2string(buf+1,sizeof(buf)-1,ll);
    buf[len+1] = '\r';
    buf[len+2] = '\n';
    addRep...",938.0,966.0,1.0,29.0,29.0,25,12,25,8,4,3,2,2,0,3,,0,1,6,3,3,void
4795,213724,addReplyLongLong,1,addReplyLongLong,"void addReplyLongLong (client*,long long)",networking.c,"void addReplyLongLong(client *c, long long ll) {
    if (ll == 0)
        addReply(c,shared.czero);
    else if (ll == 1)
        addReply(c,shared.cone);
    else
        addReplyLongLongWithPrefix(c,ll,':');
}",968.0,975.0,1.0,1.0,8.0,2,2,3,3,74,1,2,2,0,1,,0,0,4,2,2,void
4796,213758,addReplyAggregateLen,1,addReplyAggregateLen,"void addReplyAggregateLen (client*,long,int)",networking.c,"void addReplyAggregateLen(client *c, long length, int prefix) {
    serverAssert(length >= 0);
    addReplyLongLongWithPrefix(c,length,prefix);
}",977.0,980.0,1.0,4.0,4.0,5,5,4,3,5,2,1,1,0,2,,0,0,6,3,3,void
4797,213785,addReplyArrayLen,1,addReplyArrayLen,"void addReplyArrayLen (client*,long)",networking.c,"void addReplyArrayLen(client *c, long length) {
    addReplyAggregateLen(c,length,'*');
}",982.0,984.0,1.0,1.0,3.0,0,0,2,2,60,1,1,1,0,1,,0,0,4,2,2,void
4798,213795,addReplyMapLen,1,addReplyMapLen,"void addReplyMapLen (client*,long)",networking.c,"void addReplyMapLen(client *c, long length) {
    int prefix = c->resp == 2 ? '*' : '%';
    if (c->resp == 2) length *= 2;
    addReplyAggregateLen(c,length,prefix);
}",986.0,990.0,1.0,1.0,5.0,7,5,7,3,32,3,2,2,1,1,,0,2,4,2,2,void
4799,213826,addReplySetLen,1,addReplySetLen,"void addReplySetLen (client*,long)",networking.c,"void addReplySetLen(client *c, long length) {
    int prefix = c->resp == 2 ? '*' : '~';
    addReplyAggregateLen(c,length,prefix);
}",992.0,995.0,1.0,1.0,4.0,4,4,5,3,7,2,1,1,0,1,,0,1,4,2,2,void
4800,213847,addReplyAttributeLen,1,addReplyAttributeLen,"void addReplyAttributeLen (client*,long)",networking.c,"void addReplyAttributeLen(client *c, long length) {
    serverAssert(c->resp >= 3);
    addReplyAggregateLen(c,length,'|');
}",997.0,1000.0,1.0,4.0,4.0,6,6,3,2,0,3,1,1,0,2,,0,1,4,2,2,void
4801,213875,addReplyPushLen,1,addReplyPushLen,"void addReplyPushLen (client*,long)",networking.c,"void addReplyPushLen(client *c, long length) {
    serverAssert(c->resp >= 3);
    serverAssertWithInfo(c, NULL, c->flags & CLIENT_PUSHING);
    addReplyAggregateLen(c,length,'>');
}",1002.0,1006.0,1.0,4.0,5.0,13,8,8,3,2,5,1,1,0,3,,0,2,4,2,2,void
4802,213927,addReplyNull,1,addReplyNull,void addReplyNull (client*),networking.c,"void addReplyNull(client *c) {
    if (c->resp == 2) {
        addReplyProto(c,""$-1\r\n"",5);
    } else {
        addReplyProto(c,""_\r\n"",3);
    }
}",1008.0,1014.0,1.0,1.0,7.0,2,2,2,1,15,2,2,2,1,1,,0,1,2,1,1,void
4803,213949,addReplyBool,1,addReplyBool,"void addReplyBool (client*,int)",networking.c,"void addReplyBool(client *c, int b) {
    if (c->resp == 2) {
        addReply(c, b ? shared.cone : shared.czero);
    } else {
        addReplyProto(c, b ? ""#t\r\n"" : ""#f\r\n"",4);
    }
}",1016.0,1022.0,1.0,1.0,7.0,5,4,5,3,1,2,2,2,1,1,,0,1,4,2,2,void
4804,213981,addReplyNullArray,1,addReplyNullArray,void addReplyNullArray (client*),networking.c,"void addReplyNullArray(client *c) {
    if (c->resp == 2) {
        addReplyProto(c,""*-1\r\n"",5);
    } else {
        addReplyProto(c,""_\r\n"",3);
    }
}",1028.0,1034.0,1.0,1.0,7.0,2,2,2,1,7,2,2,2,1,1,,0,1,2,1,1,void
4805,214003,addReplyBulkLen,1,addReplyBulkLen,"void addReplyBulkLen (client*,robj*)",networking.c,"void addReplyBulkLen(client *c, robj *obj) {
    size_t len = stringObjectLen(obj);

    addReplyLongLongWithPrefix(c,len,'$');
}",1037.0,1041.0,1.0,1.0,5.0,1,1,4,3,1,2,1,1,0,2,,0,1,4,2,2,void
4806,214018,addReplyBulk,1,addReplyBulk,"void addReplyBulk (client*,robj*)",networking.c,"void addReplyBulk(client *c, robj *obj) {
    addReplyBulkLen(c,obj);
    addReply(c,obj);
    addReplyProto(c,""\r\n"",2);
}",1044.0,1048.0,1.0,1.0,5.0,0,0,5,2,18,3,1,1,0,3,,0,0,4,2,2,void
4807,214034,addReplyBulkCBuffer,1,addReplyBulkCBuffer,"void addReplyBulkCBuffer (client*,void*,size_t)",networking.c,"void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
    addReplyLongLongWithPrefix(c,len,'$');
    addReplyProto(c,p,len);
    addReplyProto(c,""\r\n"",2);
}",1051.0,1055.0,1.0,1.0,5.0,0,0,6,3,49,3,1,1,0,3,,0,0,6,3,3,void
4808,214053,addReplyBulkSds,1,addReplyBulkSds,"void addReplyBulkSds (client*,sds)",networking.c,"void addReplyBulkSds(client *c, sds s)  {
    addReplyLongLongWithPrefix(c,sdslen(s),'$');
    addReplySds(c,s);
    addReplyProto(c,""\r\n"",2);
}",1058.0,1062.0,1.0,1.0,5.0,0,0,5,2,12,4,1,1,0,4,,0,1,4,2,2,void
4809,214071,setDeferredReplyBulkSds,1,setDeferredReplyBulkSds,"void setDeferredReplyBulkSds (client*,void*,sds)",networking.c,"void setDeferredReplyBulkSds(client *c, void *node, sds s) {
    sds reply = sdscatprintf(sdsempty(), ""$%d\r\n%s\r\n"", (unsigned)sdslen(s), s);
    setDeferredReply(c, node, reply, sdslen(reply));
    sdsfree(reply);
    sdsfree(s);
}",1065.0,1070.0,1.0,1.0,6.0,2,2,9,4,1,7,1,1,0,7,,0,4,6,3,3,void
4810,214099,addReplyBulkCString,1,addReplyBulkCString,"void addReplyBulkCString (client*,char*)",networking.c,"void addReplyBulkCString(client *c, const char *s) {
    if (s == NULL) {
        addReplyNull(c);
    } else {
        addReplyBulkCBuffer(c,s,strlen(s));
    }
}",1073.0,1079.0,1.0,1.0,7.0,1,1,3,3,211,1,2,2,0,1,,0,0,4,2,2,void
4811,214119,addReplyBulkLongLong,1,addReplyBulkLongLong,"void addReplyBulkLongLong (client*,long long)",networking.c,"void addReplyBulkLongLong(client *c, long long ll) {
    char buf[64];
    int len;

    len = ll2string(buf,64,ll);
    addReplyBulkCBuffer(c,buf,len);
}",1082.0,1088.0,1.0,1.0,7.0,1,1,6,4,49,2,1,1,0,2,,0,1,4,2,2,void
4812,214137,addReplyVerbatim,1,addReplyVerbatim,"void addReplyVerbatim (client*,char*,size_t,char*)",networking.c,"void addReplyVerbatim(client *c, const char *s, size_t len, const char *ext) {
    if (c->resp == 2) {
        addReplyBulkCBuffer(c,s,len);
    } else {
        char buf[32];
        size_t preflen = snprintf(buf,sizeof(buf),""=%zu\r\nxxx:"",len+4);
        char *p = buf+preflen-4;
        for (int i = 0; i < 3; i++) {
            if (*ext == '\0') {
                p[i] = ' ';
            } else {
                p[i] = *ext++;
            }
        }
        addReplyProto(c,buf,preflen);
        addReplyProto(c,s,len);
        addReplyProto(c,""\r\n"",2);
    }
}",1099.0,1117.0,1.0,1.0,19.0,2,2,4,3,3,2,2,2,1,1,,0,1,8,4,4,void
4813,214222,addReplyHelp,1,addReplyHelp,"void addReplyHelp (client*,char**)",networking.c,"void addReplyHelp(client *c, const char **help) {
    sds cmd = sdsnew((char*) c->argv[0]->ptr);
    void *blenp = addReplyDeferredLen(c);
    int blen = 0;

    sdstoupper(cmd);
    addReplyStatusFormat(c,
        ""%s <subcommand> [<arg> [value] [opt] ...]. Subcommands are:"",cmd);
    sdsfree(cmd);

    while (help[blen]) addReplyStatus(c,help[blen++]);

    addReplyStatus(c,""HELP"");
    addReplyStatus(c,""    Print this help."");

    blen += 1;  /* Account for the header. */
    blen += 2;  /* Account for the footer. */
    setDeferredArrayLen(c,blenp,blen);
}",1123.0,1141.0,1.0,1.0,19.0,10,5,18,5,12,9,2,2,0,8,,0,3,4,2,2,void
4814,214284,addReplySubcommandSyntaxError,1,addReplySubcommandSyntaxError,void addReplySubcommandSyntaxError (client*),networking.c,"void addReplySubcommandSyntaxError(client *c) {
    sds cmd = sdsnew((char*) c->argv[0]->ptr);
    sdstoupper(cmd);
    addReplyErrorFormat(c,
        ""unknown subcommand or wrong number of arguments for '%.128s'. Try %s HELP."",
        (char*)c->argv[1]->ptr,cmd);
    sdsfree(cmd);
}",1146.0,1153.0,1.0,1.0,8.0,9,4,7,2,2,6,1,1,0,4,,0,3,2,1,1,void
4815,214319,AddReplyFromClient,1,AddReplyFromClient,"void AddReplyFromClient (client*,client*)",networking.c,"void AddReplyFromClient(client *dst, client *src) {
    /* If the source client contains a partial response due to client output
     * buffer limits, propagate that to the dest rather than copy a partial
     * reply. We don't wanna run the risk of copying partial response in case
     * for some reason the output limits don't reach the same decision (maybe
     * they changed) */
    if (src->flags & CLIENT_CLOSE_ASAP) {
        sds client = catClientInfoString(sdsempty(),dst);
        freeClientAsync(dst);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
        return;
    }

    /* First add the static buffer (either into the static buffer or reply list) */
    addReplyProto(dst,src->buf, src->bufpos);

    /* We need to check with prepareClientToWrite again (after addReplyProto)
     * since addReplyProto may have changed something (like CLIENT_CLOSE_ASAP) */
    if (prepareClientToW...",1157.0,1198.0,1.0,21.0,42.0,30,8,27,5,1,27,6,6,6,11,,0,19,4,2,2,void
4816,214453,deferredAfterErrorReply,1,deferredAfterErrorReply,"void deferredAfterErrorReply (client*,list*)",networking.c,"void deferredAfterErrorReply(client *c, list *errors) {
    listIter li;
    listNode *ln;
    listRewind(errors,&li);
    while((ln = listNext(&li))) {
        sds err = ln->value;
        afterErrorReply(c, err, sdslen(err), 0);
    }
}",1202.0,1210.0,1.0,1.0,9.0,5,3,9,5,2,5,2,2,1,4,,0,3,4,2,2,void
4817,214484,copyReplicaOutputBuffer,1,copyReplicaOutputBuffer,"void copyReplicaOutputBuffer (client*,client*)",networking.c,"void copyReplicaOutputBuffer(client *dst, client *src) {
    serverAssert(src->bufpos == 0 && listLength(src->reply) == 0);

    if (src->ref_repl_buf_node == NULL) return;
    dst->ref_repl_buf_node = src->ref_repl_buf_node;
    dst->ref_block_pos = src->ref_block_pos;
    ((replBufBlock *)listNodeValue(dst->ref_repl_buf_node))->refcount++;
}",1214.0,1221.0,1.0,4.0,8.0,24,9,10,3,1,10,2,2,1,1,,0,9,4,2,2,void
4818,214553,clientHasPendingReplies,1,clientHasPendingReplies,int clientHasPendingReplies (client*),networking.c,"int clientHasPendingReplies(client *c) {
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        /* Replicas use global shared replication buffer instead of
         * private output buffer. */
        serverAssert(c->bufpos == 0 && listLength(c->reply) == 0);
        if (c->ref_repl_buf_node == NULL) return 0;

        /* If the last replication buffer block content is totally sent,
         * we have nothing to send. */
        listNode *ln = listLast(server.repl_buffer_blocks);
        replBufBlock *tail = listNodeValue(ln);
        if (ln == c->ref_repl_buf_node &&
            c->ref_block_pos == tail->used) return 0;

        return 1;
    } else {
        return c->bufpos || listLength(c->reply);
    }
}",1225.0,1243.0,1.0,28.0,19.0,25,9,15,5,11,9,4,6,5,2,,0,8,2,1,1,int
4819,214659,clientAcceptHandler,1,clientAcceptHandler,void clientAcceptHandler (connection*),networking.c,"void clientAcceptHandler(connection *conn) {
    client *c = connGetPrivateData(conn);

    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_WARNING,
                  ""Error accepting a client connection: %s (addr=%s laddr=%s)"",
                  connGetLastError(conn), getClientPeerId(c), getClientSockname(c));
        freeClientAsync(c);
        return;
    }

    /* If the server is running in protected mode (the default) and there
     * is no password set, nor a specific interface is bound, we don't accept
     * requests from non loopback interfaces. Instead we try to explain the
     * user what to do to fix it if needed. */
    if (server.protected_mode &&
        DefaultUser->flags & USER_FLAG_NOPASS)
    {
        if (connIsLocal(conn) != 1) {
            char *err =
                ""-DENIED Redis is running in protected mode because protected ""
                ""mode is enabled and no password is set for the default user. ""
                ""In this m...",1245.0,1297.0,1.0,8.0,53.0,19,11,20,6,0,12,5,8,4,11,,0,8,2,1,1,void
4820,214758,acceptCommonHandler,1,acceptCommonHandler,"void acceptCommonHandler (connection*,int,char*)",networking.c,"void acceptCommonHandler(connection *conn, int flags, char *ip) {
    client *c;
    UNUSED(ip);

    if (connGetState(conn) != CONN_STATE_ACCEPTING) {
        char addr[NET_ADDR_STR_LEN] = {0};
        char laddr[NET_ADDR_STR_LEN] = {0};
        connFormatAddr(conn, addr, sizeof(addr), 1);
        connFormatAddr(conn, laddr, sizeof(addr), 0);
        serverLog(LL_VERBOSE,
                  ""Accepted client connection in error state: %s (addr=%s laddr=%s)"",
                  connGetLastError(conn), addr, laddr);
        connClose(conn);
        return;
    }

    /* Limit the number of connections we take at the same time.
     *
     * Admission control will happen before a client is created and connAccept()
     * called, because we don't want to even start transport-level negotiation
     * if rejected. */
    if (listLength(server.clients) + getClusterConnectionsCount()
        >= server.maxclients)
    {
        char *err;
        if (server.cluster_enabled)
            err = ""...",1299.0,1373.0,1.0,4.0,75.0,41,14,53,11,2,24,8,11,6,23,,0,13,6,3,3,void
4821,214978,freeClientOriginalArgv,1,freeClientOriginalArgv,void freeClientOriginalArgv (client*),networking.c,"void freeClientOriginalArgv(client *c) {
    /* We didn't rewrite this client */
    if (!c->original_argv) return;

    for (int j = 0; j < c->original_argc; j++)
        decrRefCount(c->original_argv[j]);
    zfree(c->original_argv);
    c->original_argv = NULL;
    c->original_argc = 0;
}",1375.0,1384.0,1.0,1.0,10.0,10,4,8,3,2,6,3,3,2,1,,0,5,2,1,1,void
4822,215076,disconnectSlaves,1,disconnectSlaves,void disconnectSlaves (void),networking.c,"void disconnectSlaves(void) {
    listIter li;
    listNode *ln;
    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        freeClient((client*)ln->value);
    }
}",1401.0,1408.0,1.0,1.0,8.0,6,5,5,3,4,4,2,2,1,3,,0,2,2,1,1,void
4823,215102,anyOtherSlaveWaitRdb,1,anyOtherSlaveWaitRdb,int anyOtherSlaveWaitRdb (client*),networking.c,"int anyOtherSlaveWaitRdb(client *except_me) {
    listIter li;
    listNode *ln;

    listRewind(server.slaves, &li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (slave != except_me &&
            slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END)
        {
            return 1;
        }
    }
    return 0;
}",1413.0,1427.0,1.0,32.0,15.0,10,7,9,5,1,4,3,4,2,2,,0,3,2,1,1,int
4824,215145,unlinkClient,1,unlinkClient,void unlinkClient (client*),networking.c,"void unlinkClient(client *c) {
    listNode *ln;

    /* If this is marked as current client unset it. */
    if (server.current_client == c) server.current_client = NULL;

    /* Certain operations must be done only if the client has an active connection.
     * If the client was already unlinked or if it's a ""fake client"" the
     * conn is already set to NULL. */
    if (c->conn) {
        /* Remove from the list of active clients. */
        if (c->client_list_node) {
            uint64_t id = htonu64(c->id);
            raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);
            listDelNode(server.clients,c->client_list_node);
            c->client_list_node = NULL;
        }

        /* Check if this is a replica waiting for diskless replication (rdb pipe),
         * in which case it needs to be cleaned from that list */
        if (c->flags & CLIENT_SLAVE &&
            c->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&
            server.rdb_pipe_conns)
   ...",1432.0,1498.0,1.0,26.0,67.0,91,18,61,7,3,38,13,20,9,14,,0,26,2,1,1,void
4825,215442,clearClientConnectionState,1,clearClientConnectionState,void clearClientConnectionState (client*),networking.c,"void clearClientConnectionState(client *c) {
    listNode *ln;

    /* MONITOR clients are also marked with CLIENT_SLAVE, we need to
     * distinguish between the two.
     */
    if (c->flags & CLIENT_MONITOR) {
        ln = listSearchKey(server.monitors,c);
        serverAssert(ln != NULL);
        listDelNode(server.monitors,ln);

        c->flags &= ~(CLIENT_MONITOR|CLIENT_SLAVE);
    }

    serverAssert(!(c->flags &(CLIENT_SLAVE|CLIENT_MASTER)));

    if (c->flags & CLIENT_TRACKING) disableTracking(c);
    selectDb(c,0);
#ifdef LOG_REQ_RES
    c->resp = server.client_default_resp;
#else
    c->resp = 2;
#endif

    clientSetDefaultAuth(c);
    moduleNotifyUserChanged(c);
    discardTransaction(c);

    pubsubUnsubscribeAllChannels(c,0);
    pubsubUnsubscribeShardAllChannels(c, 0);
    pubsubUnsubscribeAllPatterns(c,0);

    if (c->name) {
        decrRefCount(c->name);
        c->name = NULL;
    }

    /* Note: lib_name and lib_ver are not reset since they still
     * repres...",1501.0,1544.0,1.0,19.0,44.0,50,13,25,4,2,22,4,4,3,13,,0,10,2,1,1,void
4826,215624,freeClient,1,freeClient,void freeClient (client*),redis-benchmark.c,"static void freeClient(client c) {
    aeEventLoop *el = CLIENT_GET_EVENTLOOP(c);
    listNode *ln;
    aeDeleteFileEvent(el,c->context->fd,AE_WRITABLE);
    aeDeleteFileEvent(el,c->context->fd,AE_READABLE);
    if (c->thread_id >= 0) {
        int requests_finished = 0;
        atomicGet(config.requests_finished, requests_finished);
        if (requests_finished >= config.requests) {
            aeStop(el);
        }
    }
    redisFree(c->context);
    sdsfree(c->obuf);
    zfree(c->randptr);
    zfree(c->stagptr);
    zfree(c);
    if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
    config.liveclients--;
    ln = listSearchKey(config.clients,c);
    assert(ln != NULL);
    listDelNode(config.clients,ln);
    if (config.num_threads) pthread_mutex_unlock(&(config.liveclients_mutex));
}",371.0,394.0,1.0,22.0,24.0,130,19,95,5,22,95,21,30,21,49,,0,52,2,1,1,void
4827,216142,freeClientAsync,1,freeClientAsync,void freeClientAsync (client*),networking.c,"void freeClientAsync(client *c) {
    /* We need to handle concurrent access to the server.clients_to_close list
     * only in the freeClientAsync() function, since it's the only function that
     * may access the list while Redis uses I/O threads. All the other accesses
     * are in the context of the main thread while the other threads are
     * idle. */
    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_SCRIPT) return;
    c->flags |= CLIENT_CLOSE_ASAP;
    if (server.io_threads_num == 1) {
        /* no need to bother with locking if there's just one thread (the main thread) */
        listAddNodeTail(server.clients_to_close,c);
        return;
    }
    static pthread_mutex_t async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&async_free_queue_mutex);
    listAddNodeTail(server.clients_to_close,c);
    pthread_mutex_unlock(&async_free_queue_mutex);
}",1707.0,1724.0,1.0,19.0,18.0,16,8,12,4,15,5,3,3,2,2,,0,3,2,1,1,void
4828,216206,logInvalidUseAndFreeClientAsync,1,logInvalidUseAndFreeClientAsync,"void logInvalidUseAndFreeClientAsync (client*,char*...)",networking.c,"void logInvalidUseAndFreeClientAsync(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    sds info = sdscatvprintf(sdsempty(), fmt, ap);
    va_end(ap);

    sds client = catClientInfoString(sdsempty(), c);
    serverLog(LL_WARNING, ""%s, disconnecting it: %s"", info, client);

    sdsfree(info);
    sdsfree(client);
    freeClientAsync(c);
}",1728.0,1740.0,1.0,4.0,13.0,5,4,14,6,2,8,1,1,0,8,,0,4,4,2,2,void
4829,216257,beforeNextClient,1,beforeNextClient,int beforeNextClient (client*),networking.c,"int beforeNextClient(client *c) {
    /* Notice, this code is also called from 'processUnblockedClients'.
     * But in case of a module blocked client (see RM_Call 'K' flag) we do not reach this code path.
     * So whenever we change the code here we need to consider if we need this change on module
     * blocked client as well */

    /* Skip the client processing if we're in an IO thread, in that case we'll perform
       this operation later (this function is called again) in the fan-in stage of the threading mechanism */
    if (io_threads_op != IO_THREADS_OP_IDLE)
        return C_OK;
    /* Handle async frees */
    /* Note: this doesn't make the server.clients_to_close list redundant because of
     * cases where we want an async free of a client other than myself. For example
     * in ACL modifications we disconnect clients authenticated to non-existent
     * users (see ACL LOAD). */
    if (c && (c->flags & CLIENT_CLOSE_ASAP)) {
        freeClient(c);
        return C_...",1748.0,1768.0,1.0,25.0,21.0,6,6,4,2,3,2,3,3,1,1,,0,1,2,1,1,int
4830,216297,freeClientsInAsyncFreeQueue,1,freeClientsInAsyncFreeQueue,int freeClientsInAsyncFreeQueue (void),networking.c,"int freeClientsInAsyncFreeQueue(void) {
    int freed = 0;
    listIter li;
    listNode *ln;

    listRewind(server.clients_to_close,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);

        if (c->flags & CLIENT_PROTECTED) continue;

        c->flags &= ~CLIENT_CLOSE_ASAP;
        freeClient(c);
        listDelNode(server.clients_to_close,ln);
        freed++;
    }
    return freed;
}",1772.0,1789.0,1.0,20.0,18.0,16,9,16,6,2,7,4,4,2,4,,0,4,2,1,1,int
4831,216365,lookupClientByID,1,lookupClientByID,client lookupClientByID (uint64_t),networking.c,"client *lookupClientByID(uint64_t id) {
    id = htonu64(id);
    client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
    return (c == raxNotFound) ? NULL : c;
}",1794.0,1798.0,1.0,9.0,5.0,8,7,11,5,7,2,1,1,0,2,,0,2,2,1,1,client
4832,216397,_writevToClient,1,_writevToClient,"int _writevToClient (client*,ssize_t*)",networking.c,"static int _writevToClient(client *c, ssize_t *nwritten) {
    int iovcnt = 0;
    int iovmax = min(IOV_MAX, c->conn->iovcnt);
    struct iovec iov[iovmax];
    size_t iov_bytes_len = 0;
    /* If the static reply buffer is not empty, 
     * add it to the iov array for writev() as well. */
    if (c->bufpos > 0) {
        iov[iovcnt].iov_base = c->buf + c->sentlen;
        iov[iovcnt].iov_len = c->bufpos - c->sentlen;
        iov_bytes_len += iov[iovcnt++].iov_len;
    }
    /* The first node of reply list might be incomplete from the last call,
     * thus it needs to be calibrated to get the actual data address and length. */
    size_t offset = c->bufpos > 0 ? 0 : c->sentlen;
    listIter iter;
    listNode *next;
    clientReplyBlock *o;
    listRewind(c->reply, &iter);
    while ((next = listNext(&iter)) && iovcnt < iovmax && iov_bytes_len < NET_MAX_WRITES_PER_EVENT) {
        o = listNodeValue(next);
        if (o->used == 0) { /* empty node, just release it and skip. */
    ...",1805.0,1871.0,1.0,17.0,67.0,113,20,93,13,1,43,12,13,6,7,,0,39,4,2,2,int
4833,216730,_writeToClient,1,_writeToClient,"int _writeToClient (client*,ssize_t*)",networking.c,"int _writeToClient(client *c, ssize_t *nwritten) {
    *nwritten = 0;
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        serverAssert(c->bufpos == 0 && listLength(c->reply) == 0);

        replBufBlock *o = listNodeValue(c->ref_repl_buf_node);
        serverAssert(o->used >= c->ref_block_pos);
        /* Send current block if it is not fully sent. */
        if (o->used > c->ref_block_pos) {
            *nwritten = connWrite(c->conn, o->buf+c->ref_block_pos,
                                  o->used-c->ref_block_pos);
            if (*nwritten <= 0) return C_ERR;
            c->ref_block_pos += *nwritten;
        }

        /* If we fully sent the object on head, go to the next one. */
        listNode *next = listNextNode(c->ref_repl_buf_node);
        if (next && c->ref_block_pos == o->used) {
            o->refcount--;
            ((replBufBlock *)(listNodeValue(next)))->refcount++;
            c->ref_repl_buf_node = next;
            c->ref_block_pos = 0;
            incre...",1878.0,1929.0,1.0,28.0,52.0,76,19,42,5,1,34,8,14,9,7,,0,30,4,2,2,int
4834,217044,writeToClient,1,writeToClient,"int writeToClient (client*,int)",networking.c,"int writeToClient(client *c, int handler_installed) {
    /* Update total number of writes on server */
    atomicIncr(server.stat_total_writes_processed, 1);

    ssize_t nwritten = 0, totwritten = 0;

    while(clientHasPendingReplies(c)) {
        int ret = _writeToClient(c, &nwritten);
        if (ret == C_ERR) break;
        totwritten += nwritten;
        /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver.
         *
         * Moreover, we also send as much as possible if the client is
         * a slave or a monitor (other...",1939.0,2011.0,1.0,19.0,73.0,54,20,37,9,6,21,15,19,9,13,,0,15,4,2,2,int
4835,217271,sendReplyToClient,1,sendReplyToClient,void sendReplyToClient (connection*),networking.c,"void sendReplyToClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    writeToClient(c,1);
}",2014.0,2017.0,1.0,1.0,4.0,1,1,3,2,0,2,1,1,0,2,,0,1,2,1,1,void
4836,217284,handleClientsWithPendingWrites,1,handleClientsWithPendingWrites,int handleClientsWithPendingWrites (void),networking.c,"int handleClientsWithPendingWrites(void) {
    listIter li;
    listNode *ln;
    int processed = listLength(server.clients_pending_write);

    listRewind(server.clients_pending_write,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        c->flags &= ~CLIENT_PENDING_WRITE;
        listUnlinkNode(server.clients_pending_write,ln);

        /* If a client is protected, don't do anything,
         * that may trigger write error or recreate handler. */
        if (c->flags & CLIENT_PROTECTED) continue;

        /* Don't write to clients that are going to be closed anyway. */
        if (c->flags & CLIENT_CLOSE_ASAP) continue;

        /* Try to write buffers to the client socket. */
        if (writeToClient(c,0) == C_ERR) continue;

        /* If after the synchronous writes above we still have data to
         * output to the client, we need to install the writable handler. */
        if (clientHasPendingReplies(c)) {
            installClientWriteHandl...",2023.0,2051.0,1.0,20.0,29.0,22,9,19,5,2,10,9,10,5,6,,0,7,2,1,1,int
4837,217384,resetClient,1,resetClient,void resetClient (client*),redis-benchmark.c,"static void resetClient(client c) {
    aeEventLoop *el = CLIENT_GET_EVENTLOOP(c);
    aeDeleteFileEvent(el,c->context->fd,AE_WRITABLE);
    aeDeleteFileEvent(el,c->context->fd,AE_READABLE);
    aeCreateFileEvent(el,c->context->fd,AE_WRITABLE,writeHandler,c);
    c->written = 0;
    c->pending = config.pipeline;
}",406.0,413.0,1.0,22.0,8.0,59,14,28,4,7,23,5,5,4,3,,0,20,2,1,1,void
4838,217565,protectClient,1,protectClient,void protectClient (client*),networking.c,"void protectClient(client *c) {
    c->flags |= CLIENT_PROTECTED;
    if (c->conn) {
        connSetReadHandler(c->conn,NULL);
        connSetWriteHandler(c->conn,NULL);
    }
}",2109.0,2115.0,1.0,16.0,7.0,5,2,6,2,2,6,2,2,1,2,,0,4,2,1,1,void
4839,217594,unprotectClient,1,unprotectClient,void unprotectClient (client*),networking.c,"void unprotectClient(client *c) {
    if (c->flags & CLIENT_PROTECTED) {
        c->flags &= ~CLIENT_PROTECTED;
        if (c->conn) {
            connSetReadHandler(c->conn,readQueryFromClient);
            if (clientHasPendingReplies(c)) putClientInPendingWriteQueue(c);
        }
    }
}",2118.0,2126.0,1.0,19.0,9.0,8,4,7,2,3,7,4,7,3,3,,0,5,2,1,1,void
4840,217636,processInlineBuffer,1,processInlineBuffer,int processInlineBuffer (client*),networking.c,"int processInlineBuffer(client *c) {
    char *newline;
    int argc, j, linefeed_chars = 1;
    sds *argv, aux;
    size_t querylen;

    /* Search for end of line */
    newline = strchr(c->querybuf+c->qb_pos,'\n');

    /* Nothing to do without a \r\n */
    if (newline == NULL) {
        if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
            addReplyError(c,""Protocol error: too big inline request"");
            setProtocolError(""too big inline request"",c);
        }
        return C_ERR;
    }

    /* Handle the \r\n case. */
    if (newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
        newline--, linefeed_chars++;

    /* Split the input buffer up to the \r\n */
    querylen = newline-(c->querybuf+c->qb_pos);
    aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
    argv = sdssplitargs(aux,&argc);
    sdsfree(aux);
    if (argv == NULL) {
        addReplyError(c,""Protocol error: unbalanced quotes in request"");
        setProtocolError(""unbalanced qu...",2135.0,2207.0,1.0,44.0,73.0,80,22,67,11,1,41,10,12,8,17,,0,30,2,1,1,int
4841,218104,processMultibulkBuffer,1,processMultibulkBuffer,int processMultibulkBuffer (client*),networking.c,"int processMultibulkBuffer(client *c) {
    char *newline = NULL;
    int ok;
    long long ll;

    if (c->multibulklen == 0) {
        /* The client should have been reset */
        serverAssertWithInfo(c,NULL,c->argc == 0);

        /* Multi bulk length cannot be read without a \r\n */
        newline = strchr(c->querybuf+c->qb_pos,'\r');
        if (newline == NULL) {
            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
                addReplyError(c,""Protocol error: too big mbulk count string"");
                setProtocolError(""too big mbulk count string"",c);
            }
            return C_ERR;
        }

        /* Buffer should also contain \n */
        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
            return C_ERR;

        /* We know for sure there is a whole line since newline != NULL,
         * so go ahead and find out the multi bulk length. */
        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_po...",2253.0,2413.0,1.0,8.0,161.0,185,25,122,8,0,92,23,49,33,26,,0,77,2,1,1,int
4842,218931,commandProcessed,1,commandProcessed,void commandProcessed (client*),networking.c,"void commandProcessed(client *c) {
    /* If client is blocked(including paused), just return avoid reset and replicate.
     *
     * 1. Don't reset the client structure for blocked clients, so that the reply
     *    callback will still be able to access the client argv and argc fields.
     *    The client will be reset in unblockClient().
     * 2. Don't update replication offset or propagate commands to replicas,
     *    since we have not applied the command. */
    if (c->flags & CLIENT_BLOCKED) return;

    reqresAppendResponse(c);
    resetClient(c);

    long long prev_offset = c->reploff;
    if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
        /* Update the applied replication offset of our master. */
        c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;
    }

    /* If the client is a master we need to compute the difference
     * between the applied offset before and after processing the buffer,
     * to understand how much of th...",2420.0,2452.0,1.0,19.0,33.0,31,9,21,3,1,17,5,6,4,4,,0,14,2,1,1,void
4843,219032,processCommandAndResetClient,1,processCommandAndResetClient,int processCommandAndResetClient (client*),networking.c,"int processCommandAndResetClient(client *c) {
    int deadclient = 0;
    client *old_client = server.current_client;
    server.current_client = c;
    if (processCommand(c) == C_OK) {
        commandProcessed(c);
        /* Update the client's memory to include output buffer growth following the
         * processed command. */
        updateClientMemUsageAndBucket(c);
    }

    if (server.current_client == NULL) deadclient = 1;
    /*
     * Restore the old client, this is needed because when a script
     * times out, we will get into this code from processEventsWhileBlocked.
     * Which will cause to set the server.current_client. If not restored
     * we will return 1 to our caller which will falsely indicate the client
     * is dead and will stop reading from its buffer.
     */
    server.current_client = old_client;
    /* performEvictions may flush slave output buffers. This may
     * result in a slave, that may be the active client, to be
     * freed. */
    return ...",2462.0,2486.0,1.0,29.0,25.0,13,5,14,5,1,3,3,3,1,3,,0,1,2,1,1,int
4844,219089,processPendingCommandAndInputBuffer,1,processPendingCommandAndInputBuffer,int processPendingCommandAndInputBuffer (client*),networking.c,"int processPendingCommandAndInputBuffer(client *c) {
    /* Notice, this code is also called from 'processUnblockedClients'.
     * But in case of a module blocked client (see RM_Call 'K' flag) we do not reach this code path.
     * So whenever we change the code here we need to consider if we need this change on module
     * blocked client as well */
    if (c->flags & CLIENT_PENDING_COMMAND) {
        c->flags &= ~CLIENT_PENDING_COMMAND;
        if (processCommandAndResetClient(c) == C_ERR) {
            return C_ERR;
        }
    }

    /* Now process client if it has more data in it's buffer.
     *
     * Note: when a master client steps into this function,
     * it can always satisfy this condition, because its querybuf
     * contains data not applied. */
    if (c->querybuf && sdslen(c->querybuf) > 0) {
        return processInputBuffer(c);
    }
    return C_OK;
}",2492.0,2513.0,1.0,19.0,22.0,13,8,6,1,2,7,4,5,5,3,,0,6,2,1,1,int
4845,219148,processInputBuffer,1,processInputBuffer,int processInputBuffer (client*),networking.c,"int processInputBuffer(client *c) {
    /* Keep processing while there is something in the input buffer */
    while(c->qb_pos < sdslen(c->querybuf)) {
        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;

        /* Don't process more buffers from clients that have already pending
         * commands to execute in c->argv. */
        if (c->flags & CLIENT_PENDING_COMMAND) break;

        /* Don't process input from the master while there is a busy script
         * condition on the slave. We want just to accumulate the replication
         * stream (instead of replying -BUSY like we do with other clients) and
         * later resume the processing. */
        if (isInsideYieldingLongCommand() && c->flags & CLIENT_MASTER) break;

        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
         * written to the client. Make sure to not let the reply grow after
         * this flag has been set (...",2520.0,2614.0,1.0,23.0,95.0,44,13,23,2,2,25,19,26,16,6,,0,22,2,1,1,int
4846,219429,readQueryFromClient,1,readQueryFromClient,void readQueryFromClient (connection*),networking.c,"void readQueryFromClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    int nread, big_arg = 0;
    size_t qblen, readlen;

    /* Check if we want to read from the client later when exiting from
     * the event loop. This is the case if threaded I/O is enabled. */
    if (postponeClientRead(c)) return;

    /* Update total number of reads on server */
    atomicIncr(server.stat_total_reads_processed, 1);

    readlen = PROTO_IOBUF_LEN;
    /* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */
    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
        && c->bulklen >= PROTO_M...",2616.0,2718.0,1.0,14.0,103.0,96,18,77,12,1,48,14,17,17,21,,0,42,2,1,1,void
4847,219858,genClientAddrString,1,genClientAddrString,"void genClientAddrString (client*,char*,size_t,int)",networking.c,"void genClientAddrString(client *client, char *addr,
                         size_t addr_len, int remote) {
    if (client->flags & CLIENT_UNIX_SOCKET) {
        /* Unix socket client. */
        snprintf(addr,addr_len,""%s:0"",server.unixsocket);
    } else {
        /* TCP client. */
        connFormatAddr(client->conn,addr,addr_len,remote);
    }
}",2731.0,2740.0,1.0,24.0,10.0,4,4,4,4,1,1,2,2,1,0,,0,1,8,4,4,void
4848,219893,getClientPeerId,1,getClientPeerId,char* getClientPeerId (client*),networking.c,"char *getClientPeerId(client *c) {
    char peerid[NET_ADDR_STR_LEN] = {0};

    if (c->peerid == NULL) {
        genClientAddrString(c,peerid,sizeof(peerid),1);
        c->peerid = sdsnew(peerid);
    }
    return c->peerid;
}",2746.0,2754.0,1.0,16.0,9.0,8,5,9,3,4,5,2,2,1,2,,0,4,2,1,1,char*
4849,219959,catClientInfoString,1,catClientInfoString,"sds catClientInfoString (sds,client*)",networking.c,"sds catClientInfoString(sds s, client *client) {
    char flags[17], events[3], conninfo[CONN_INFO_LEN], *p;

    p = flags;
    if (client->flags & CLIENT_SLAVE) {
        if (client->flags & CLIENT_MONITOR)
            *p++ = 'O';
        else
            *p++ = 'S';
    }
    if (client->flags & CLIENT_MASTER) *p++ = 'M';
    if (client->flags & CLIENT_PUBSUB) *p++ = 'P';
    if (client->flags & CLIENT_MULTI) *p++ = 'x';
    if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
    if (client->flags & CLIENT_TRACKING) *p++ = 't';
    if (client->flags & CLIENT_TRACKING_BROKEN_REDIR) *p++ = 'R';
    if (client->flags & CLIENT_TRACKING_BCAST) *p++ = 'B';
    if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
    if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
    if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
    if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
    if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
    if (client->flags & CLIENT_READONLY) *p++ = 'r';
    i...",2772.0,2851.0,1.0,40.0,80.0,238,16,112,13,10,72,23,26,23,9,,0,72,4,2,2,sds
4850,220615,getAllClientsInfoString,1,getAllClientsInfoString,sds getAllClientsInfoString (int),networking.c,"sds getAllClientsInfoString(int type) {
    listNode *ln;
    listIter li;
    client *client;
    sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));
    sdsclear(o);
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client = listNodeValue(ln);
        if (type != -1 && getClientType(client) != type) continue;
        o = catClientInfoString(o,client);
        o = sdscatlen(o,""\n"",1);
    }
    return o;
}",2853.0,2867.0,1.0,37.0,15.0,18,8,22,8,1,8,4,4,2,7,,0,6,2,1,1,sds
4851,220690,validateClientAttr,1,validateClientAttr,int validateClientAttr (char*),networking.c,"int validateClientAttr(const char *val) {
    /* Check if the charset is ok. We need to do this otherwise
     * CLIENT LIST format will break. You should always be able to
     * split by space to get the different fields. */
    while (*val) {
        if (*val < '!' || *val > '~') { /* ASCII is assumed. */
            return C_ERR;
        }
        val++;
    }
    return C_OK;
}",2870.0,2881.0,1.0,19.0,12.0,8,6,4,1,2,0,3,4,0,0,,0,0,2,1,1,int
4852,220721,validateClientName,1,validateClientName,"int validateClientName (robj*,char**)",networking.c,"int validateClientName(robj *name, const char **err) {
    const char *err_msg = ""Client names cannot contain spaces, newlines or special characters."";
    int len = (name != NULL) ? sdslen(name->ptr) : 0;
    /* We allow setting the client name to an empty string. */
    if (len == 0)
        return C_OK;
    if (validateClientAttr(name->ptr) == C_ERR) {
        if (err) *err = err_msg;
        return C_ERR;
    }
    return C_OK;
}",2884.0,2895.0,1.0,15.0,12.0,12,7,10,5,1,2,4,5,1,2,,0,2,4,2,2,int
4853,220779,clientSetName,1,clientSetName,"int clientSetName (client*,robj*,char**)",networking.c,"int clientSetName(client *c, robj *name, const char **err) {
    if (validateClientName(name, err) == C_ERR) {
        return C_ERR;
    }
    int len = (name != NULL) ? sdslen(name->ptr) : 0;
    /* Setting the client name to an empty string actually removes
     * the current name. */
    if (len == 0) {
        if (c->name) decrRefCount(c->name);
        c->name = NULL;
        return C_OK;
    }
    if (c->name) decrRefCount(c->name);
    c->name = name;
    incrRefCount(name);
    return C_OK;
}",2898.0,2914.0,1.0,41.0,17.0,16,6,16,5,3,11,5,6,3,5,,0,8,6,3,3,int
4854,220856,clientSetNameOrReply,1,clientSetNameOrReply,"int clientSetNameOrReply (client*,robj*)",networking.c,"int clientSetNameOrReply(client *c, robj *name) {
    const char *err = NULL;
    int result = clientSetName(c, name, &err);
    if (result == C_ERR) {
        addReplyError(c, err);
    }
    return result;
}",2925.0,2932.0,1.0,18.0,8.0,5,4,10,5,0,2,2,2,0,2,,0,1,4,2,2,int
4855,220887,clientSetinfoCommand,1,clientSetinfoCommand,void clientSetinfoCommand (client*),networking.c,"void clientSetinfoCommand(client *c) {
    sds attr = c->argv[2]->ptr;
    robj *valob = c->argv[3];
    sds val = valob->ptr;
    robj **destvar = NULL;
    if (!strcasecmp(attr,""lib-name"")) {
        destvar = &c->lib_name;
    } else if (!strcasecmp(attr,""lib-ver"")) {
        destvar = &c->lib_ver;
    } else {
        addReplyErrorFormat(c,""Unrecognized option '%s'"", attr);
        return;
    }

    if (validateClientAttr(val)==C_ERR) {
        addReplyErrorFormat(c,
            ""%s cannot contain spaces, newlines or special characters."", attr);
        return;
    }
    if (*destvar) decrRefCount(*destvar);
    if (sdslen(val)) {
        *destvar = valob;
        incrRefCount(valob);
    } else
        *destvar = NULL;
    addReply(c,shared.ok);
}",2935.0,2961.0,1.0,33.0,27.0,21,9,22,7,0,9,5,5,2,6,,0,5,2,1,1,void
4856,220995,resetCommand,1,resetCommand,void resetCommand (client*),networking.c,"void resetCommand(client *c) {
    /* MONITOR clients are also marked with CLIENT_SLAVE, we need to
     * distinguish between the two.
     */
    uint64_t flags = c->flags;
    if (flags & CLIENT_MONITOR) flags &= ~(CLIENT_MONITOR|CLIENT_SLAVE);

    if (flags & (CLIENT_SLAVE|CLIENT_MASTER|CLIENT_MODULE)) {
        addReplyError(c,""can only reset normal client connections"");
        return;
    }

    clearClientConnectionState(c);
    addReplyStatus(c,""RESET"");
}",2965.0,2979.0,1.0,16.0,15.0,14,6,8,2,0,4,3,3,0,3,,0,1,2,1,1,void
4857,221059,quitCommand,1,quitCommand,void quitCommand (client*),networking.c,"void quitCommand(client *c) {
    addReply(c,shared.ok);
    c->flags |= CLIENT_CLOSE_AFTER_REPLY;
}",2982.0,2985.0,1.0,16.0,4.0,3,3,3,2,0,2,1,1,0,1,,0,1,2,1,1,void
4858,221078,clientCommand,1,clientCommand,void clientCommand (client*),networking.c,"void clientCommand(client *c) {
    listNode *ln;
    listIter li;

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CACHING (YES|NO)"",
""    Enable/disable tracking of the keys for next command in OPTIN/OPTOUT modes."",
""GETREDIR"",
""    Return the client ID we are redirecting to when tracking is enabled."",
""GETNAME"",
""    Return the name of the current connection."",
""ID"",
""    Return the ID of the current connection."",
""INFO"",
""    Return information about the current client connection."",
""KILL <ip:port>"",
""    Kill connection made from <ip:port>."",
""KILL <option> <value> [<option> <value> [...]]"",
""    Kill connections. Options are:"",
""    * ADDR (<ip:port>|<unixsocket>:0)"",
""      Kill connections made from the specified address"",
""    * LADDR (<ip:port>|<unixsocket>:0)"",
""      Kill connections made to specified local address"",
""    * TYPE (NORMAL|MASTER|REPLICA|PUBSUB)"",
""      Kill connections by type."",
""    * USER <username>"",
""   ...",2987.0,3527.0,1.0,26.0,541.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
4859,223423,helloCommand,1,helloCommand,void helloCommand (client*),networking.c,"void helloCommand(client *c) {
    long long ver = 0;
    int next_arg = 1;

    if (c->argc >= 2) {
        if (getLongLongFromObjectOrReply(c, c->argv[next_arg++], &ver,
            ""Protocol version is not an integer or out of range"") != C_OK) {
            return;
        }

        if (ver < 2 || ver > 3) {
            addReplyError(c,""-NOPROTO unsupported protocol version"");
            return;
        }
    }

    robj *username = NULL;
    robj *password = NULL;
    robj *clientname = NULL;
    for (int j = next_arg; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        const char *opt = c->argv[j]->ptr;
        if (!strcasecmp(opt,""AUTH"") && moreargs >= 2) {
            redactClientCommandArgument(c, j+1);
            redactClientCommandArgument(c, j+2);
            username = c->argv[j+1];
            password = c->argv[j+2];
            j += 2;
        } else if (!strcasecmp(opt,""SETNAME"") && moreargs) {
            clientname = c->argv[j+1];
            con...",3530.0,3626.0,1.0,69.0,97.0,62,18,88,15,0,35,15,21,5,24,,0,13,2,1,1,void
4860,223760,securityWarningCommand,1,securityWarningCommand,void securityWarningCommand (client*),networking.c,"void securityWarningCommand(client *c) {
    static time_t logged_time = 0;
    time_t now = time(NULL);

    if (llabs(now-logged_time) > 60) {
        char ip[NET_IP_STR_LEN];
        int port;
        if (connAddrPeerName(c->conn, ip, sizeof(ip), &port) == -1) {
            serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."");
        } else {
            serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection from %s:%d aborted."", ip, port);
        }
        logged_time = now;
    }
    freeClientAsync(c);
}",3637.0,3652.0,1.0,16.0,16.0,13,11,13,7,1,4,3,4,2,3,,0,2,2,1,1,void
4861,223843,retainOriginalCommandVector,1,retainOriginalCommandVector,void retainOriginalCommandVector (client*),networking.c,"static void retainOriginalCommandVector(client *c) {
    /* We already rewrote this command, so don't rewrite it again */
    if (c->original_argv) return;
    c->original_argc = c->argc;
    c->original_argv = zmalloc(sizeof(robj*)*(c->argc));
    for (int j = 0; j < c->argc; j++) {
        c->original_argv[j] = c->argv[j];
        incrRefCount(c->argv[j]);
    }
}",3656.0,3665.0,1.0,1.0,10.0,19,6,15,3,3,11,3,3,2,2,,0,10,2,1,1,void
4862,223903,redactClientCommandArgument,1,redactClientCommandArgument,"void redactClientCommandArgument (client*,int)",networking.c,"void redactClientCommandArgument(client *c, int argc) {
    retainOriginalCommandVector(c);
    if (c->original_argv[argc] == shared.redacted) {
        /* This argument has already been redacted */
        return;
    }
    decrRefCount(c->original_argv[argc]);
    c->original_argv[argc] = shared.redacted;
}",3670.0,3678.0,1.0,1.0,9.0,10,5,9,3,6,5,2,2,1,2,,0,3,4,2,2,void
4863,223938,rewriteClientCommandVector,1,rewriteClientCommandVector,"void rewriteClientCommandVector (client*,int...)",networking.c,"void rewriteClientCommandVector(client *c, int argc, ...) {
    va_list ap;
    int j;
    robj **argv; /* The new argument vector */

    argv = zmalloc(sizeof(robj*)*argc);
    va_start(ap,argc);
    for (j = 0; j < argc; j++) {
        robj *a;

        a = va_arg(ap, robj*);
        argv[j] = a;
        incrRefCount(a);
    }
    replaceClientCommandVector(c, argc, argv);
    va_end(ap);
}",3683.0,3699.0,1.0,1.0,17.0,7,5,16,7,8,3,2,2,0,3,,0,1,4,2,2,void
4864,223983,replaceClientCommandVector,1,replaceClientCommandVector,"void replaceClientCommandVector (client*,int,robj**)",networking.c,"void replaceClientCommandVector(client *c, int argc, robj **argv) {
    int j;
    retainOriginalCommandVector(c);
    freeClientArgv(c);
    c->argv = argv;
    c->argc = argc;
    c->argv_len_sum = 0;
    for (j = 0; j < c->argc; j++)
        if (c->argv[j])
            c->argv_len_sum += getStringObjectLen(c->argv[j]);
    c->cmd = lookupCommandOrOriginal(c->argv,c->argc);
    serverAssertWithInfo(c,NULL,c->cmd != NULL);
}",3702.0,3714.0,1.0,4.0,13.0,19,8,19,5,4,12,2,2,1,4,,0,9,6,3,3,void
4865,224072,rewriteClientCommandArgument,1,rewriteClientCommandArgument,"void rewriteClientCommandArgument (client*,int,robj*)",networking.c,"void rewriteClientCommandArgument(client *c, int i, robj *newval) {
    robj *oldval;
    retainOriginalCommandVector(c);

    /* We need to handle both extending beyond argc (just update it and
     * initialize the new element) or beyond argv_len (realloc is needed).
     */
    if (i >= c->argc) {
        if (i >= c->argv_len) {
            c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));
            c->argv_len = i+1;
        }
        c->argc = i+1;
        c->argv[i] = NULL;
    }
    oldval = c->argv[i];
    if (oldval) c->argv_len_sum -= getStringObjectLen(oldval);
    if (newval) c->argv_len_sum += getStringObjectLen(newval);
    c->argv[i] = newval;
    incrRefCount(newval);
    if (oldval) decrRefCount(oldval);

    /* If this is the command name make sure to fix c->cmd. */
    if (i == 0) {
        c->cmd = lookupCommandOrOriginal(c->argv,c->argc);
        serverAssertWithInfo(c,NULL,c->cmd != NULL);
    }
}",3727.0,3754.0,1.0,8.0,28.0,40,15,41,6,4,23,7,8,2,8,,0,17,6,3,3,void
4866,224208,getClientOutputBufferMemoryUsage,1,getClientOutputBufferMemoryUsage,size_t getClientOutputBufferMemoryUsage (client*),networking.c,"size_t getClientOutputBufferMemoryUsage(client *c) {
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        size_t repl_buf_size = 0;
        size_t repl_node_num = 0;
        size_t repl_node_size = sizeof(listNode) + sizeof(replBufBlock);
        if (c->ref_repl_buf_node) {
            replBufBlock *last = listNodeValue(listLast(server.repl_buffer_blocks));
            replBufBlock *cur = listNodeValue(c->ref_repl_buf_node);
            repl_buf_size = last->repl_offset + last->size - cur->repl_offset;
            repl_node_num = last->id - cur->id + 1;
        }
        return repl_buf_size + (repl_node_size*repl_node_num);
    } else { 
        size_t list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
        return c->reply_bytes + (list_item_size*listLength(c->reply));
    }
}",3762.0,3778.0,1.0,28.0,17.0,29,8,22,9,3,9,3,4,2,1,,0,9,2,1,1,size_t
4867,224324,getClientMemoryUsage,1,getClientMemoryUsage,"size_t getClientMemoryUsage (client*,size_t*)",networking.c,"size_t getClientMemoryUsage(client *c, size_t *output_buffer_mem_usage) {
    size_t mem = getClientOutputBufferMemoryUsage(c);
    if (output_buffer_mem_usage != NULL)
        *output_buffer_mem_usage = mem;
    mem += sdsZmallocSize(c->querybuf);
    mem += zmalloc_size(c);
    mem += c->buf_usable_size;
    /* For efficiency (less work keeping track of the argv memory), it doesn't include the used memory
     * i.e. unused sds space and internal fragmentation, just the string length. but this is enough to
     * spot problematic clients. */
    mem += c->argv_len_sum + sizeof(robj*)*c->argc;
    mem += multiStateMemOverhead(c);

    /* Add memory overhead of pubsub channels and patterns. Note: this is just the overhead of the robj pointers
     * to the strings themselves because they aren't stored per client. */
    mem += pubsubMemOverhead(c);

    /* Add memory overhead of the tracking prefixes, this is an underestimation so we don't need to traverse the entire rax */
    if (...",3783.0,3805.0,1.0,1.0,23.0,25,8,26,6,2,11,3,3,1,5,,0,7,4,2,2,size_t
4868,224399,getClientType,1,getClientType,int getClientType (client*),networking.c,"int getClientType(client *c) {
    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
    /* Even though MONITOR clients are marked as replicas, we
     * want the expose them as normal clients. */
    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
        return CLIENT_TYPE_SLAVE;
    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
    return CLIENT_TYPE_NORMAL;
}",3816.0,3824.0,1.0,19.0,9.0,14,5,4,1,17,4,4,4,4,0,,0,4,2,1,1,int
4869,224464,getClientTypeByName,1,getClientTypeByName,int getClientTypeByName (char*),networking.c,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""replica"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}",3826.0,3833.0,1.0,43.0,8.0,1,1,1,1,1,0,2,2,0,0,,0,0,2,1,1,int
4870,224532,getClientTypeName,1,getClientTypeName,char* getClientTypeName (int),networking.c,"char *getClientTypeName(int class) {
    switch(class) {
    case CLIENT_TYPE_NORMAL: return ""normal"";
    case CLIENT_TYPE_SLAVE:  return ""slave"";
    case CLIENT_TYPE_PUBSUB: return ""pubsub"";
    case CLIENT_TYPE_MASTER: return ""master"";
    default:                       return NULL;
    }
}",3835.0,3843.0,1.0,9.0,9.0,0,0,2,2,2,0,2,2,0,0,,0,0,2,1,1,char*
4871,224567,checkClientOutputBufferLimits,1,checkClientOutputBufferLimits,int checkClientOutputBufferLimits (client*),networking.c,"int checkClientOutputBufferLimits(client *c) {
    int soft = 0, hard = 0, class;
    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);

    class = getClientType(c);
    /* For the purpose of output buffer limiting, masters are handled
     * like normal clients. */
    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;

    /* Note that it doesn't make sense to set the replica clients output buffer
     * limit lower than the repl-backlog-size config (partial sync will succeed
     * and then replica will get disconnected).
     * Such a configuration is ignored (the size of repl-backlog-size will be used).
     * This doesn't have memory consumption implications since the replica client
     * will share the backlog buffers memory. */
    size_t hard_limit_bytes = server.client_obuf_limits[class].hard_limit_bytes;
    if (class == CLIENT_TYPE_SLAVE && hard_limit_bytes &&
        (long long)hard_limit_bytes < server.repl_backlog_size)
        hard_limit_bytes...",3851.0,3897.0,1.0,17.0,47.0,40,10,35,7,1,4,7,8,1,2,,0,4,2,1,1,int
4872,224729,closeClientOnOutputBufferLimitReached,1,closeClientOnOutputBufferLimitReached,"int closeClientOnOutputBufferLimitReached (client*,int)",networking.c,"int closeClientOnOutputBufferLimitReached(client *c, int async) {
    if (!c->conn) return 0; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    /* Note that c->reply_bytes is irrelevant for replica clients
     * (they use the global repl buffers). */
    if ((c->reply_bytes == 0 && getClientType(c) != CLIENT_TYPE_SLAVE) ||
        c->flags & CLIENT_CLOSE_ASAP) return 0;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        if (async) {
            freeClientAsync(c);
            serverLog(LL_WARNING,
                      ""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."",
                      client);
        } else {
            freeClient(c);
            serverLog(LL_WARNING,
                      ""Client %s closed for overcoming of output buffer limits."",
                      client);
        }
        sdsfree(client);
        return  1;
    }
...",3910.0,3935.0,1.0,4.0,26.0,22,17,14,5,4,12,5,6,5,8,,0,8,4,2,2,int
4873,224854,flushSlavesOutputBuffers,1,flushSlavesOutputBuffers,void flushSlavesOutputBuffers (void),networking.c,"void flushSlavesOutputBuffers(void) {
    listIter li;
    listNode *ln;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = listNodeValue(ln);
        int can_receive_writes = connHasWriteHandler(slave->conn) ||
                                 (slave->flags & CLIENT_PENDING_WRITE);

        /* We don't want to send the pending data to the replica in a few
         * cases:
         *
         * 1. For some reason there is neither the write handler installed
         *    nor the client is flagged as to have pending writes: for some
         *    reason this replica may not be set to receive data. This is
         *    just for the sake of defensive programming.
         *
         * 2. The put_online_on_ack flag is true. To know why we don't want
         *    to send data to the replica in this case, please grep for the
         *    flag for this flag.
         *
         * 3. Obviously if the slave is not ONLINE.
         */
        if ...",3941.0,3974.0,1.0,24.0,34.0,24,10,16,5,1,11,3,4,5,5,,0,9,2,1,1,void
4874,224933,updatePausedActions,1,updatePausedActions,void updatePausedActions (void),networking.c,"void updatePausedActions(void) {
    uint32_t prev_paused_actions = server.paused_actions;
    server.paused_actions = 0;

    for (int i = 0; i < NUM_PAUSE_PURPOSES; i++) {
        pause_event *p = &(server.client_pause_per_purpose[i]);
        if (p->end > server.mstime)
            server.paused_actions |= p->paused_actions;
        else {
            p->paused_actions = 0;
            p->end = 0;
        }
    }

    /* If the pause type is less restrictive than before, we unblock all clients
     * so they are reprocessed (may get re-paused). */
    uint32_t mask_cli = (PAUSE_ACTION_CLIENT_WRITE|PAUSE_ACTION_CLIENT_ALL);
    if ((server.paused_actions & mask_cli) < (prev_paused_actions & mask_cli)) {
        unblockPostponedClients();
    }
}",3978.0,3998.0,1.0,25.0,21.0,23,10,18,6,4,3,4,5,1,1,,0,2,2,1,1,void
4875,225024,unblockPostponedClients,1,unblockPostponedClients,void unblockPostponedClients (void),networking.c,"void unblockPostponedClients(void) {
    listNode *ln;
    listIter li;
    listRewind(server.postponed_clients, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        unblockClient(c, 1);
    }
}",4002.0,4010.0,1.0,20.0,9.0,7,5,9,5,2,4,2,2,1,3,,0,2,2,1,1,void
4876,225151,pauseActions,1,pauseActions,"void pauseActions (pause_purpose,mstime_t,uint32_t)",networking.c,"void pauseActions(pause_purpose purpose, mstime_t end, uint32_t actions) {
    /* Manage pause type and end time per pause purpose. */
    server.client_pause_per_purpose[purpose].paused_actions = actions;

    /* If currently configured end time bigger than new one, then keep it */
    if (server.client_pause_per_purpose[purpose].end < end)
        server.client_pause_per_purpose[purpose].end = end;

    updatePausedActions();

    /* We allow write commands that were queued
     * up before and after to execute. We need
     * to track this state so that we don't assert
     * in propagateNow(). */
    if (server.in_exec) {
        server.client_pause_in_transaction = 1;
    }
}",4044.0,4061.0,1.0,1.0,18.0,15,4,11,4,2,1,3,3,0,1,,0,0,6,3,3,void
4877,225198,unpauseActions,1,unpauseActions,void unpauseActions (pause_purpose),networking.c,"void unpauseActions(pause_purpose purpose) {
    server.client_pause_per_purpose[purpose].end = 0;
    server.client_pause_per_purpose[purpose].paused_actions = 0;
    updatePausedActions();
}",4064.0,4068.0,1.0,1.0,5.0,8,3,4,2,2,1,1,1,0,1,,0,0,2,1,1,void
4878,225222,isPausedActions,1,isPausedActions,uint32_t isPausedActions (uint32_t),networking.c,"uint32_t isPausedActions(uint32_t actions_bitmask) {
    return (server.paused_actions & actions_bitmask);
}",4071.0,4073.0,1.0,1.0,3.0,2,2,2,2,4,0,1,1,0,0,,0,0,2,1,1,uint32_t
4879,225233,isPausedActionsWithUpdate,1,isPausedActionsWithUpdate,uint32_t isPausedActionsWithUpdate (uint32_t),networking.c,"uint32_t isPausedActionsWithUpdate(uint32_t actions_bitmask) {
    if (!(server.paused_actions & actions_bitmask)) return 0;
    updatePausedActions();
    return (server.paused_actions & actions_bitmask);
}",4076.0,4080.0,1.0,1.0,5.0,5,3,4,2,5,1,2,2,0,1,,0,0,2,1,1,uint32_t
4880,225255,processEventsWhileBlocked,1,processEventsWhileBlocked,void processEventsWhileBlocked (void),networking.c,"void processEventsWhileBlocked(void) {
    int iterations = 4; /* See the function top-comment. */

    /* Update our cached time since it is used to create and update the last
     * interaction time with clients and for other important things. */
    updateCachedTime(0);

    /* For the few commands that are allowed during busy scripts, we rather
     * provide a fresher time than the one from when the script started (they
     * still won't get it from the call due to execution_nesting. For commands
     * during loading this doesn't matter. */
    mstime_t prev_cmd_time_snapshot = server.cmd_time_snapshot;
    server.cmd_time_snapshot = server.mstime;

    /* Note: when we are processing events while blocked (for instance during
     * busy Lua scripts), we set a global flag. When such flag is set, we
     * avoid handling the read part of clients using threaded I/O.
     * See https://github.com/redis/redis/issues/6988 for more info.
     * Note that there could be cases of nes...",4094.0,4134.0,1.0,12.0,41.0,33,14,21,7,5,7,4,4,0,4,,0,4,2,1,1,void
4881,225387,getIOPendingCount,1,getIOPendingCount,unsigned long getIOPendingCount (int),networking.c,"static inline unsigned long getIOPendingCount(int i) {
    unsigned long count = 0;
    atomicGetWithSync(io_threads_pending[i].value, count);
    return count;
}",4163.0,4167.0,1.0,1.0,5.0,3,3,5,3,3,1,1,1,0,0,,0,1,2,1,1,unsigned long
4882,225405,setIOPendingCount,1,setIOPendingCount,"void setIOPendingCount (int,long unsigned)",networking.c,"static inline void setIOPendingCount(int i, unsigned long count) {
    atomicSetWithSync(io_threads_pending[i].value, count);
}",4169.0,4171.0,1.0,1.0,3.0,2,2,3,3,4,1,1,1,0,0,,0,1,4,2,2,void
4883,225418,IOThreadMain,1,IOThreadMain,void* IOThreadMain (void*),networking.c,"void *IOThreadMain(void *myid) {
    /* The ID is the thread number (from 0 to server.io_threads_num-1), and is
     * used by the thread to just manipulate a single sub-array of clients. */
    long id = (unsigned long)myid;
    char thdname[16];

    snprintf(thdname, sizeof(thdname), ""io_thd_%ld"", id);
    redis_set_thread_title(thdname);
    redisSetCpuAffinity(server.server_cpulist);
    makeThreadKillable();

    while(1) {
        /* Wait for start */
        for (int j = 0; j < 1000000; j++) {
            if (getIOPendingCount(id) != 0) break;
        }

        /* Give the main thread a chance to stop this thread. */
        if (getIOPendingCount(id) == 0) {
            pthread_mutex_lock(&io_threads_mutex[id]);
            pthread_mutex_unlock(&io_threads_mutex[id]);
            continue;
        }

        serverAssert(getIOPendingCount(id) != 0);

        /* Process: note that the main thread will never touch our list
         * before we drop the pending count to 0. */
...",4173.0,4217.0,1.0,4.0,45.0,25,13,28,11,0,17,9,14,4,11,,0,9,2,1,1,void*
4884,225561,initThreadedIO,1,initThreadedIO,void initThreadedIO (void),networking.c,"void initThreadedIO(void) {
    server.io_threads_active = 0; /* We start with threads not active. */

    /* Indicate that io-threads are currently idle */
    io_threads_op = IO_THREADS_OP_IDLE;

    /* Don't spawn any thread if the user selected a single thread:
     * we'll handle I/O directly from the main thread. */
    if (server.io_threads_num == 1) return;

    if (server.io_threads_num > IO_THREADS_MAX_NUM) {
        serverLog(LL_WARNING,""Fatal: too many I/O threads configured. ""
                             ""The maximum number is %d."", IO_THREADS_MAX_NUM);
        exit(1);
    }

    /* Spawn and initialize the I/O threads. */
    for (int i = 0; i < server.io_threads_num; i++) {
        /* Things we do for all the threads including the main thread. */
        io_threads_list[i] = listCreate();
        if (i == 0) continue; /* Thread 0 is the main thread. */

        /* Things we do only for the additional threads. */
        pthread_t tid;
        pthread_mutex_init(&io_...",4220.0,4253.0,1.0,20.0,34.0,29,10,24,8,1,9,7,8,0,4,,0,6,2,1,1,void
4885,225693,killIOThreads,1,killIOThreads,void killIOThreads (void),networking.c,"void killIOThreads(void) {
    int err, j;
    for (j = 0; j < server.io_threads_num; j++) {
        if (io_threads[j] == pthread_self()) continue;
        if (io_threads[j] && pthread_cancel(io_threads[j]) == 0) {
            if ((err = pthread_join(io_threads[j],NULL)) != 0) {
                serverLog(LL_WARNING,
                    ""IO thread(tid:%lu) can not be joined: %s"",
                        (unsigned long)io_threads[j], strerror(err));
            } else {
                serverLog(LL_WARNING,
                    ""IO thread(tid:%lu) terminated"",(unsigned long)io_threads[j]);
            }
        }
    }
}",4255.0,4270.0,1.0,16.0,16.0,17,9,17,5,1,6,6,9,4,1,,0,5,2,1,1,void
4886,225794,startThreadedIO,1,startThreadedIO,void startThreadedIO (void),networking.c,"void startThreadedIO(void) {
    serverAssert(server.io_threads_active == 0);
    for (int j = 1; j < server.io_threads_num; j++)
        pthread_mutex_unlock(&io_threads_mutex[j]);
    server.io_threads_active = 1;
}",4272.0,4277.0,1.0,4.0,6.0,11,8,5,2,1,1,2,2,0,1,,0,0,2,1,1,void
4887,225840,stopThreadedIO,1,stopThreadedIO,void stopThreadedIO (void),networking.c,"void stopThreadedIO(void) {
    /* We may have still clients with pending reads when this function
     * is called: handle them before stopping the threads. */
    handleClientsWithPendingReadsUsingThreads();
    serverAssert(server.io_threads_active == 1);
    for (int j = 1; j < server.io_threads_num; j++)
        pthread_mutex_lock(&io_threads_mutex[j]);
    server.io_threads_active = 0;
}",4279.0,4287.0,1.0,4.0,9.0,11,8,5,2,1,2,2,2,0,2,,0,0,2,1,1,void
4888,225887,stopThreadedIOIfNeeded,1,stopThreadedIOIfNeeded,int stopThreadedIOIfNeeded (void),networking.c,"int stopThreadedIOIfNeeded(void) {
    int pending = listLength(server.clients_pending_write);

    /* Return ASAP if IO threads are disabled (single threaded mode). */
    if (server.io_threads_num == 1) return 1;

    if (pending < (server.io_threads_num*2)) {
        if (server.io_threads_active) stopThreadedIO();
        return 1;
    } else {
        return 0;
    }
}",4298.0,4310.0,1.0,18.0,13.0,10,6,7,2,2,1,4,5,0,1,,0,0,2,1,1,int
4889,225935,handleClientsWithPendingWritesUsingThreads,1,handleClientsWithPendingWritesUsingThreads,int handleClientsWithPendingWritesUsingThreads (void),networking.c,"int handleClientsWithPendingWritesUsingThreads(void) {
    int processed = listLength(server.clients_pending_write);
    if (processed == 0) return 0; /* Return ASAP if there are no clients. */

    /* If I/O threads are disabled or we have few clients to serve, don't
     * use I/O threads, but the boring synchronous code. */
    if (server.io_threads_num == 1 || stopThreadedIOIfNeeded()) {
        return handleClientsWithPendingWrites();
    }

    /* Start threads if needed. */
    if (!server.io_threads_active) startThreadedIO();

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_write,&li);
    int item_id = 0;
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        c->flags &= ~CLIENT_PENDING_WRITE;

        /* Remove clients from the list of pending writes since
         * they are going to be closed ASAP. */
        if (c->flags & CLIENT_CLOSE_ASAP) {
            listUn...",4318.0,4410.0,1.0,20.0,93.0,67,16,71,12,1,33,18,20,7,20,,0,19,2,1,1,int
4890,226292,handleClientsWithPendingReadsUsingThreads,1,handleClientsWithPendingReadsUsingThreads,int handleClientsWithPendingReadsUsingThreads (void),networking.c,"int handleClientsWithPendingReadsUsingThreads(void) {
    if (!server.io_threads_active || !server.io_threads_do_reads) return 0;
    int processed = listLength(server.clients_pending_read);
    if (processed == 0) return 0;

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_read,&li);
    int item_id = 0;
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        int target_id = item_id % server.io_threads_num;
        listAddNodeTail(io_threads_list[target_id],c);
        item_id++;
    }

    /* Give the start condition to the waiting threads, by setting the
     * start condition atomic var. */
    io_threads_op = IO_THREADS_OP_READ;
    for (int j = 1; j < server.io_threads_num; j++) {
        int count = listLength(io_threads_list[j]);
        setIOPendingCount(j, count);
    }

    /* Also use the main thread to process a slice of clients. */
    listRewind(io_threads_list[...",4443.0,4523.0,1.0,20.0,81.0,75,20,69,13,3,29,16,18,6,15,,0,19,2,1,1,int
4891,226583,getClientEvictionLimit,1,getClientEvictionLimit,size_t getClientEvictionLimit (void),networking.c,"size_t getClientEvictionLimit(void) {
    size_t maxmemory_clients_actual = SIZE_MAX;

    /* Handle percentage of maxmemory*/
    if (server.maxmemory_clients < 0 && server.maxmemory > 0) {
        unsigned long long maxmemory_clients_bytes = (unsigned long long)((double)server.maxmemory * -(double) server.maxmemory_clients / 100);
        if (maxmemory_clients_bytes <= SIZE_MAX)
            maxmemory_clients_actual = maxmemory_clients_bytes;
    }
    else if (server.maxmemory_clients > 0)
        maxmemory_clients_actual = server.maxmemory_clients;
    else
        return 0;

    /* Don't allow a too small maxmemory-clients to avoid cases where we can't communicate
     * at all with the server because of bad configuration */
    if (maxmemory_clients_actual < 1024*128)
        maxmemory_clients_actual = 1024*128;

    return maxmemory_clients_actual;
}",4527.0,4547.0,1.0,1.0,21.0,21,10,14,4,1,0,4,5,0,0,,0,0,2,1,1,size_t
4892,226664,evictClients,1,evictClients,void evictClients (void),networking.c,"void evictClients(void) {
    if (!server.client_mem_usage_buckets)
        return;
    /* Start eviction from topmost bucket (largest clients) */
    int curr_bucket = CLIENT_MEM_USAGE_BUCKETS-1;
    listIter bucket_iter;
    listRewind(server.client_mem_usage_buckets[curr_bucket].clients, &bucket_iter);
    size_t client_eviction_limit = getClientEvictionLimit();
    if (client_eviction_limit == 0)
        return;
    while (server.stat_clients_type_memory[CLIENT_TYPE_NORMAL] +
           server.stat_clients_type_memory[CLIENT_TYPE_PUBSUB] >= client_eviction_limit) {
        listNode *ln = listNext(&bucket_iter);
        if (ln) {
            client *c = ln->value;
            sds ci = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE, ""Evicting client: %s"", ci);
            freeClient(c);
            sdsfree(ci);
            server.stat_evictedclients++;
        } else {
            curr_bucket--;
            if (curr_bucket < 0) {
                serverLog(LL_WA...",4549.0,4578.0,1.0,22.0,30.0,28,13,22,7,2,9,5,6,0,8,,0,5,2,1,1,void
4893,226821,keyspaceEventsStringToFlags,1,keyspaceEventsStringToFlags,int keyspaceEventsStringToFlags (char*),notify.c,"int keyspaceEventsStringToFlags(char *classes) {
    char *p = classes;
    int c, flags = 0;

    while((c = *p++) != '\0') {
        switch(c) {
        case 'A': flags |= NOTIFY_ALL; break;
        case 'g': flags |= NOTIFY_GENERIC; break;
        case '$': flags |= NOTIFY_STRING; break;
        case 'l': flags |= NOTIFY_LIST; break;
        case 's': flags |= NOTIFY_SET; break;
        case 'h': flags |= NOTIFY_HASH; break;
        case 'z': flags |= NOTIFY_ZSET; break;
        case 'x': flags |= NOTIFY_EXPIRED; break;
        case 'e': flags |= NOTIFY_EVICTED; break;
        case 'K': flags |= NOTIFY_KEYSPACE; break;
        case 'E': flags |= NOTIFY_KEYEVENT; break;
        case 't': flags |= NOTIFY_STREAM; break;
        case 'm': flags |= NOTIFY_KEY_MISS; break;
        case 'd': flags |= NOTIFY_MODULE; break;
        case 'n': flags |= NOTIFY_NEW; break;
        default: return -1;
        }
    }
    return flags;
}",40.0,65.0,1.0,27.0,26.0,40,7,22,4,1,0,18,4,0,0,,0,0,2,1,1,int
4894,227039,keyspaceEventsFlagsToString,1,keyspaceEventsFlagsToString,sds keyspaceEventsFlagsToString (int),notify.c,"sds keyspaceEventsFlagsToString(int flags) {
    sds res;

    res = sdsempty();
    if ((flags & NOTIFY_ALL) == NOTIFY_ALL) {
        res = sdscatlen(res,""A"",1);
    } else {
        if (flags & NOTIFY_GENERIC) res = sdscatlen(res,""g"",1);
        if (flags & NOTIFY_STRING) res = sdscatlen(res,""$"",1);
        if (flags & NOTIFY_LIST) res = sdscatlen(res,""l"",1);
        if (flags & NOTIFY_SET) res = sdscatlen(res,""s"",1);
        if (flags & NOTIFY_HASH) res = sdscatlen(res,""h"",1);
        if (flags & NOTIFY_ZSET) res = sdscatlen(res,""z"",1);
        if (flags & NOTIFY_EXPIRED) res = sdscatlen(res,""x"",1);
        if (flags & NOTIFY_EVICTED) res = sdscatlen(res,""e"",1);
        if (flags & NOTIFY_STREAM) res = sdscatlen(res,""t"",1);
        if (flags & NOTIFY_MODULE) res = sdscatlen(res,""d"",1);
        if (flags & NOTIFY_NEW) res = sdscatlen(res,""n"",1);
    }
    if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,""K"",1);
    if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,""E"",1);
    if (f...",71.0,94.0,1.0,17.0,24.0,51,5,14,2,2,5,5,5,0,5,,0,5,2,1,1,sds
4895,227355,notifyKeyspaceEvent,1,notifyKeyspaceEvent,"void notifyKeyspaceEvent (int,char*,robj*,int)",notify.c,"void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
    sds chan;
    robj *chanobj, *eventobj;
    int len = -1;
    char buf[24];

    /* If any modules are interested in events, notify the module system now.
     * This bypasses the notifications configuration, but the module engine
     * will only call event subscribers if the event type matches the types
     * they are interested in. */
     moduleNotifyKeyspaceEvent(type, event, key, dbid);

    /* If notifications for this class of events are off, return ASAP. */
    if (!(server.notify_keyspace_events & type)) return;

    eventobj = createStringObject(event,strlen(event));

    /* __keyspace@<db>__:<key> <event> notifications. */
    if (server.notify_keyspace_events & NOTIFY_KEYSPACE) {
        chan = sdsnewlen(""__keyspace@"",11);
        len = ll2string(buf,sizeof(buf),dbid);
        chan = sdscatlen(chan, buf, len);
        chan = sdscatlen(chan, ""__:"", 3);
        chan = sdscatsds(chan, key->ptr);
  ...",104.0,145.0,1.0,40.0,42.0,30,9,52,10,34,19,5,6,0,19,,0,13,8,4,4,void
4896,227525,createObject,1,createObject,"robj createObject (int,void*)",object.c,"robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o->type = type;
    o->encoding = OBJ_ENCODING_RAW;
    o->ptr = ptr;
    o->refcount = 1;
    o->lru = 0;
    return o;
}",43.0,51.0,1.0,18.0,9.0,13,4,10,3,30,1,1,1,0,1,,0,1,4,2,2,robj
4897,227567,initObjectLRUOrLFU,1,initObjectLRUOrLFU,void initObjectLRUOrLFU (robj*),object.c,"void initObjectLRUOrLFU(robj *o) {
    if (o->refcount == OBJ_SHARED_REFCOUNT)
        return;
    /* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes() << 8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }
    return;
}",53.0,64.0,1.0,23.0,12.0,9,7,4,3,2,1,3,3,0,1,,0,1,2,1,1,void
4898,227612,makeObjectShared,1,makeObjectShared,robj makeObjectShared (robj*),object.c,"robj *makeObjectShared(robj *o) {
    serverAssert(o->refcount == 1);
    o->refcount = OBJ_SHARED_REFCOUNT;
    return o;
}",77.0,81.0,1.0,4.0,5.0,8,7,4,2,0,1,1,1,0,1,,0,0,2,1,1,robj
4899,227644,createRawStringObject,1,createRawStringObject,"robj createRawStringObject (char*,size_t)",object.c,"robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}",85.0,87.0,1.0,24.0,3.0,0,0,2,2,8,2,1,1,0,2,,0,1,4,2,2,robj
4900,227658,createEmbeddedStringObject,1,createEmbeddedStringObject,"robj createEmbeddedStringObject (char*,size_t)",object.c,"robj *createEmbeddedStringObject(const char *ptr, size_t len) {
    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
    struct sdshdr8 *sh = (void*)(o+1);

    o->type = OBJ_STRING;
    o->encoding = OBJ_ENCODING_EMBSTR;
    o->ptr = sh+1;
    o->refcount = 1;
    o->lru = 0;

    sh->len = len;
    sh->alloc = len;
    sh->flags = SDS_TYPE_8;
    if (ptr == SDS_NOINIT)
        sh->buf[len] = '\0';
    else if (ptr) {
        memcpy(sh->buf,ptr,len);
        sh->buf[len] = '\0';
    } else {
        memset(sh->buf,0,len+1);
    }
    return o;
}",92.0,114.0,1.0,14.0,23.0,30,7,22,7,4,5,2,2,0,1,,0,5,4,2,2,robj
4901,227775,createStringObject,1,createStringObject,"robj createStringObject (char*,size_t)",object.c,"robj *createStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}",123.0,128.0,1.0,15.0,6.0,1,1,3,2,22,1,2,2,0,1,,0,0,4,2,2,robj
4902,227798,tryCreateRawStringObject,1,tryCreateRawStringObject,"robj tryCreateRawStringObject (char*,size_t)",object.c,"robj *tryCreateRawStringObject(const char *ptr, size_t len) {
    sds str = sdstrynewlen(ptr,len);
    if (!str) return NULL;
    return createObject(OBJ_STRING, str);
}",131.0,135.0,1.0,24.0,5.0,2,2,6,4,0,2,2,2,0,2,,0,1,4,2,2,robj
4903,227822,tryCreateStringObject,1,tryCreateStringObject,"robj tryCreateStringObject (char*,size_t)",object.c,"robj *tryCreateStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return tryCreateRawStringObject(ptr,len);
}",138.0,143.0,1.0,15.0,6.0,1,1,3,2,0,1,2,2,0,1,,0,0,4,2,2,robj
4904,227845,createStringObjectFromLongLongWithOptions,1,createStringObjectFromLongLongWithOptions,"robj createStringObjectFromLongLongWithOptions (long long,int)",object.c,"robj *createStringObjectFromLongLongWithOptions(long long value, int flag) {
    robj *o;

    if (value >= 0 && value < OBJ_SHARED_INTEGERS && flag == LL2STROBJ_AUTO) {
        o = shared.integers[value];
    } else {
        if ((value >= LONG_MIN && value <= LONG_MAX) && flag != LL2STROBJ_NO_INT_ENC) {
            o = createObject(OBJ_STRING, NULL);
            o->encoding = OBJ_ENCODING_INT;
            o->ptr = (void*)((long)value);
        } else {
            char buf[LONG_STR_SIZE];
            int len = ll2string(buf, sizeof(buf), value);
            o = createStringObject(buf, len);
        }
    }
    return o;
}",149.0,166.0,1.0,30.0,18.0,8,7,7,4,3,0,2,2,0,0,,0,0,4,2,2,robj
4905,227934,createStringObjectFromLongLong,1,createStringObjectFromLongLong,robj createStringObjectFromLongLong (long long),object.c,"robj *createStringObjectFromLongLong(long long value) {
    return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);
}",170.0,172.0,1.0,60.0,3.0,0,0,1,1,8,1,1,1,0,1,,0,0,2,1,1,robj
4906,227945,createStringObjectFromLongLongForValue,1,createStringObjectFromLongLongForValue,robj createStringObjectFromLongLongForValue (long long),object.c,"robj *createStringObjectFromLongLongForValue(long long value) {
    if (server.maxmemory == 0 || !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) {
        /* If the maxmemory policy permits, we can still return shared integers */
        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);
    } else {
        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_SHARED);
    }
}",179.0,186.0,1.0,61.0,8.0,9,7,3,2,0,1,2,2,0,1,,0,0,2,1,1,robj
4907,227986,createStringObjectFromLongLongWithSds,1,createStringObjectFromLongLongWithSds,robj createStringObjectFromLongLongWithSds (long long),object.c,"robj *createStringObjectFromLongLongWithSds(long long value) {
    return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_INT_ENC);
}",190.0,192.0,1.0,60.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,robj
4908,227997,createStringObjectFromLongDouble,1,createStringObjectFromLongDouble,"robj createStringObjectFromLongDouble (long double,int)",object.c,"robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    int len = ld2string(buf,sizeof(buf),value,humanfriendly? LD_STR_HUMAN: LD_STR_AUTO);
    return createStringObject(buf,len);
}",200.0,204.0,1.0,13.0,5.0,3,3,9,6,1,2,1,1,0,2,,0,1,4,2,2,robj
4909,228020,dupStringObject,1,dupStringObject,robj dupStringObject (robj*),object.c,"robj *dupStringObject(const robj *o) {
    robj *d;

    serverAssert(o->type == OBJ_STRING);

    switch(o->encoding) {
    case OBJ_ENCODING_RAW:
        return createRawStringObject(o->ptr,sdslen(o->ptr));
    case OBJ_ENCODING_EMBSTR:
        return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
    case OBJ_ENCODING_INT:
        d = createObject(OBJ_STRING, NULL);
        d->encoding = OBJ_ENCODING_INT;
        d->ptr = o->ptr;
        return d;
    default:
        serverPanic(""Wrong encoding."");
        break;
    }
}",214.0,233.0,1.0,4.0,20.0,18,7,12,3,2,7,3,2,0,7,,0,3,2,1,1,robj
4910,228112,createQuicklistObject,1,createQuicklistObject,robj createQuicklistObject (void),object.c,"robj *createQuicklistObject(void) {
    quicklist *l = quicklistCreate();
    robj *o = createObject(OBJ_LIST,l);
    o->encoding = OBJ_ENCODING_QUICKLIST;
    return o;
}",235.0,240.0,1.0,27.0,6.0,4,2,5,2,0,2,1,1,0,2,,0,2,2,1,1,robj
4911,228138,createListListpackObject,1,createListListpackObject,robj createListListpackObject (void),object.c,"robj *createListListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_LIST,lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",242.0,247.0,1.0,27.0,6.0,4,2,5,2,3,2,1,1,0,2,,0,2,2,1,1,robj
4912,228165,createSetObject,1,createSetObject,robj createSetObject (void),object.c,"robj *createSetObject(void) {
    dict *d = dictCreate(&setDictType);
    robj *o = createObject(OBJ_SET,d);
    o->encoding = OBJ_ENCODING_HT;
    return o;
}",249.0,254.0,1.0,27.0,6.0,5,3,6,3,0,2,1,1,0,2,,0,2,2,1,1,robj
4913,228193,createIntsetObject,1,createIntsetObject,robj createIntsetObject (void),object.c,"robj *createIntsetObject(void) {
    intset *is = intsetNew();
    robj *o = createObject(OBJ_SET,is);
    o->encoding = OBJ_ENCODING_INTSET;
    return o;
}",256.0,261.0,1.0,27.0,6.0,4,2,5,2,1,2,1,1,0,2,,0,2,2,1,1,robj
4914,228219,createSetListpackObject,1,createSetListpackObject,robj createSetListpackObject (void),object.c,"robj *createSetListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_SET, lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",263.0,268.0,1.0,27.0,6.0,4,2,5,2,0,2,1,1,0,2,,0,2,2,1,1,robj
4915,228246,createHashObject,1,createHashObject,robj createHashObject (void),object.c,"robj *createHashObject(void) {
    unsigned char *zl = lpNew(0);
    robj *o = createObject(OBJ_HASH, zl);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",270.0,275.0,1.0,27.0,6.0,4,2,5,2,1,2,1,1,0,2,,0,2,2,1,1,robj
4916,228273,createZsetObject,1,createZsetObject,robj createZsetObject (void),object.c,"robj *createZsetObject(void) {
    zset *zs = zmalloc(sizeof(*zs));
    robj *o;

    zs->dict = dictCreate(&zsetDictType);
    zs->zsl = zslCreate();
    o = createObject(OBJ_ZSET,zs);
    o->encoding = OBJ_ENCODING_SKIPLIST;
    return o;
}",277.0,286.0,1.0,21.0,10.0,11,5,9,3,2,6,1,1,0,4,,0,6,2,1,1,robj
4917,228314,createZsetListpackObject,1,createZsetListpackObject,robj createZsetListpackObject (void),object.c,"robj *createZsetListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_ZSET,lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",288.0,293.0,1.0,27.0,6.0,4,2,5,2,2,2,1,1,0,2,,0,2,2,1,1,robj
4918,228341,createStreamObject,1,createStreamObject,robj createStreamObject (void),object.c,"robj *createStreamObject(void) {
    stream *s = streamNew();
    robj *o = createObject(OBJ_STREAM,s);
    o->encoding = OBJ_ENCODING_STREAM;
    return o;
}",295.0,300.0,1.0,27.0,6.0,4,2,5,2,2,2,1,1,0,2,,0,2,2,1,1,robj
4919,228367,createModuleObject,1,createModuleObject,"robj createModuleObject (moduleType*,void*)",object.c,"robj *createModuleObject(moduleType *mt, void *value) {
    moduleValue *mv = zmalloc(sizeof(*mv));
    mv->type = mt;
    mv->value = value;
    return createObject(OBJ_MODULE,mv);
}",302.0,307.0,1.0,24.0,6.0,7,4,7,3,2,4,1,1,0,2,,0,3,4,2,2,robj
4920,228396,freeStringObject,1,freeStringObject,void freeStringObject (robj*),object.c,"void freeStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        sdsfree(o->ptr);
    }
}",309.0,313.0,1.0,23.0,5.0,3,2,2,1,1,1,2,2,0,1,,0,0,2,1,1,void
4921,228414,freeListObject,1,freeListObject,void freeListObject (robj*),object.c,"void freeListObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistRelease(o->ptr);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        lpFree(o->ptr);
    } else {
        serverPanic(""Unknown list encoding type"");
    }
}",315.0,323.0,1.0,23.0,9.0,3,2,2,1,1,1,2,2,0,1,,0,0,2,1,1,void
4922,228457,freeSetObject,1,freeSetObject,void freeSetObject (robj*),object.c,"void freeSetObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_INTSET:
    case OBJ_ENCODING_LISTPACK:
        zfree(o->ptr);
        break;
    default:
        serverPanic(""Unknown set encoding type"");
    }
}",325.0,337.0,1.0,9.0,13.0,5,3,3,1,2,3,4,2,0,3,,0,0,2,1,1,void
4923,228500,freeZsetObject,1,freeZsetObject,void freeZsetObject (robj*),object.c,"void freeZsetObject(robj *o) {
    zset *zs;
    switch (o->encoding) {
    case OBJ_ENCODING_SKIPLIST:
        zs = o->ptr;
        dictRelease(zs->dict);
        zslFree(zs->zsl);
        zfree(zs);
        break;
    case OBJ_ENCODING_LISTPACK:
        zfree(o->ptr);
        break;
    default:
        serverPanic(""Unknown sorted set encoding"");
    }
}",339.0,354.0,1.0,9.0,16.0,7,3,7,2,1,7,4,2,0,5,,0,2,2,1,1,void
4924,228549,freeHashObject,1,freeHashObject,void freeHashObject (robj*),object.c,"void freeHashObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_LISTPACK:
        lpFree(o->ptr);
        break;
    default:
        serverPanic(""Unknown hash encoding type"");
        break;
    }
}",356.0,368.0,1.0,9.0,13.0,5,3,3,1,1,3,5,2,0,3,,0,0,2,1,1,void
4925,228589,freeModuleObject,1,freeModuleObject,void freeModuleObject (robj*),object.c,"void freeModuleObject(robj *o) {
    moduleValue *mv = o->ptr;
    mv->type->free(mv->value);
    zfree(mv);
}",370.0,374.0,1.0,1.0,5.0,5,2,5,2,1,3,1,1,0,1,,0,2,2,1,1,void
4926,228611,freeStreamObject,1,freeStreamObject,void freeStreamObject (robj*),object.c,"void freeStreamObject(robj *o) {
    freeStream(o->ptr);
}",376.0,378.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
4927,228620,incrRefCount,1,incrRefCount,void incrRefCount (robj*),object.c,"void incrRefCount(robj *o) {
    if (o->refcount < OBJ_FIRST_SPECIAL_REFCOUNT) {
        o->refcount++;
    } else {
        if (o->refcount == OBJ_SHARED_REFCOUNT) {
            /* Nothing to do: this refcount is immutable. */
        } else if (o->refcount == OBJ_STATIC_REFCOUNT) {
            serverPanic(""You tried to retain an object allocated in the stack"");
        }
    }
}",380.0,390.0,1.0,22.0,11.0,5,4,3,2,40,0,2,2,0,0,,0,0,2,1,1,void
4928,228672,decrRefCount,1,decrRefCount,void decrRefCount (robj*),object.c,"void decrRefCount(robj *o) {
    if (o->refcount == 1) {
        switch(o->type) {
        case OBJ_STRING: freeStringObject(o); break;
        case OBJ_LIST: freeListObject(o); break;
        case OBJ_SET: freeSetObject(o); break;
        case OBJ_ZSET: freeZsetObject(o); break;
        case OBJ_HASH: freeHashObject(o); break;
        case OBJ_MODULE: freeModuleObject(o); break;
        case OBJ_STREAM: freeStreamObject(o); break;
        default: serverPanic(""Unknown object type""); break;
        }
        zfree(o);
    } else {
        if (o->refcount <= 0) serverPanic(""decrRefCount against refcount <= 0"");
        if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
    }
}",392.0,409.0,1.0,13.0,18.0,4,3,10,1,109,9,11,4,0,9,,0,0,2,1,1,void
4929,228780,dismissSds,1,dismissSds,void dismissSds (sds),object.c,"void dismissSds(sds s) {
    dismissMemory(sdsAllocPtr(s), sdsAllocSize(s));
}",412.0,414.0,1.0,1.0,3.0,0,0,2,1,5,3,1,1,0,3,,0,2,2,1,1,void
4930,228790,dismissStringObject,1,dismissStringObject,void dismissStringObject (robj*),object.c,"void dismissStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        dismissSds(o->ptr);
    }
}",417.0,421.0,1.0,23.0,5.0,3,2,2,1,0,1,2,2,0,1,,0,0,2,1,1,void
4931,228808,dismissListObject,1,dismissListObject,"void dismissListObject (robj*,size_t)",object.c,"void dismissListObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        serverAssert(ql->len != 0);
        /* We iterate all nodes only when average node size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / ql->len >= server.page_size) {
            quicklistNode *node = ql->head;
            while (node) {
                if (quicklistNodeIsCompressed(node)) {
                    dismissMemory(node->entry, ((quicklistLZF*)node->entry)->sz);
                } else {
                    dismissMemory(node->entry, node->sz);
                }
                node = node->next;
            }
        }
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        dismissMemory(o->ptr, lpBytes((unsigned char*)o->ptr));
    } else {
        serverPanic(""Unknown list encoding type"");
    }
}",424.0,446.0,1.0,23.0,23.0,24,11,16,5,0,9,5,11,2,2,,0,7,4,2,2,void
4932,228933,dismissSetObject,1,dismissSetObject,"void dismissSetObject (robj*,size_t)",object.c,"void dismissSetObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *set = o->ptr;
        serverAssert(dictSize(set) != 0);
        /* We iterate all nodes only when average member size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / dictSize(set) >= server.page_size) {
            dictEntry *de;
            dictIterator *di = dictGetIterator(set);
            while ((de = dictNext(di)) != NULL) {
                dismissSds(dictGetKey(de));
            }
            dictReleaseIterator(di);
        }

        /* Dismiss hash table memory. */
        dismissMemory(set->ht_table[0], DICTHT_SIZE(set->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(set->ht_table[1], DICTHT_SIZE(set->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_INTSET) {
        dismissMemory(o->ptr, intsetBlobLen((intset*)o->ptr));
    } else if (o->encoding =...",449.0,474.0,1.0,23.0,26.0,55,17,27,8,0,20,4,7,3,8,,0,15,4,2,2,void
4933,229143,dismissZsetObject,1,dismissZsetObject,"void dismissZsetObject (robj*,size_t)",object.c,"void dismissZsetObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = o->ptr;
        zskiplist *zsl = zs->zsl;
        serverAssert(zsl->length != 0);
        /* We iterate all nodes only when average member size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / zsl->length >= server.page_size) {
            zskiplistNode *zn = zsl->tail;
            while (zn != NULL) {
                dismissSds(zn->ele);
                zn = zn->backward;
            }
        }

        /* Dismiss hash table memory. */
        dict *d = zs->dict;
        dismissMemory(d->ht_table[0], DICTHT_SIZE(d->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(d->ht_table[1], DICTHT_SIZE(d->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        dismissMemory(o->ptr, lpBytes((unsigned char*)o->ptr));
    } else {
        serverPanic...",477.0,501.0,1.0,23.0,25.0,54,16,28,9,0,19,4,7,1,4,,0,15,4,2,2,void
4934,229326,dismissHashObject,1,dismissHashObject,"void dismissHashObject (robj*,size_t)",object.c,"void dismissHashObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *d = o->ptr;
        serverAssert(dictSize(d) != 0);
        /* We iterate all fields only when average field/value size is bigger than
         * a page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / dictSize(d) >= server.page_size) {
            dictEntry *de;
            dictIterator *di = dictGetIterator(d);
            while ((de = dictNext(di)) != NULL) {
                /* Only dismiss values memory since the field size
                 * usually is small. */
                dismissSds(dictGetVal(de));
            }
            dictReleaseIterator(di);
        }

        /* Dismiss hash table memory. */
        dismissMemory(d->ht_table[0], DICTHT_SIZE(d->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(d->ht_table[1], DICTHT_SIZE(d->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_LIS...",504.0,529.0,1.0,23.0,26.0,55,17,27,8,0,20,4,7,3,8,,0,15,4,2,2,void
4935,229515,dismissStreamObject,1,dismissStreamObject,"void dismissStreamObject (robj*,size_t)",object.c,"void dismissStreamObject(robj *o, size_t size_hint) {
    stream *s = o->ptr;
    rax *rax = s->rax;
    if (raxSize(rax) == 0) return;

    /* Iterate only on stream entries, although size_hint may include serialized
     * consumer groups info, but usually, stream entries take up most of
     * the space. */
    if (size_hint / raxSize(rax) >= server.page_size) {
        raxIterator ri;
        raxStart(&ri,rax);
        raxSeek(&ri,""^"",NULL,0);
        while (raxNext(&ri)) {
            dismissMemory(ri.data, lpBytes(ri.data));
        }
        raxStop(&ri);
    }
}",532.0,549.0,1.0,1.0,18.0,14,7,16,7,0,11,4,5,3,8,,0,7,4,2,2,void
4936,229577,dismissObject,1,dismissObject,"void dismissObject (robj*,size_t)",object.c,"void dismissObject(robj *o, size_t size_hint) {
    /* madvise(MADV_DONTNEED) may not work if Transparent Huge Pages is enabled. */
    if (server.thp_enabled) return;

    /* Currently we use zmadvise_dontneed only when we use jemalloc with Linux.
     * so we avoid these pointless loops when they're not going to do anything. */
#if defined(USE_JEMALLOC) && defined(__linux__)
    if (o->refcount != 1) return;
    switch(o->type) {
        case OBJ_STRING: dismissStringObject(o); break;
        case OBJ_LIST: dismissListObject(o, size_hint); break;
        case OBJ_SET: dismissSetObject(o, size_hint); break;
        case OBJ_ZSET: dismissZsetObject(o, size_hint); break;
        case OBJ_HASH: dismissHashObject(o, size_hint); break;
        case OBJ_STREAM: dismissStreamObject(o, size_hint); break;
        default: break;
    }
#else
    UNUSED(o); UNUSED(size_hint);
#endif
}",564.0,584.0,1.0,4.0,21.0,3,2,5,3,3,0,2,2,0,0,,0,0,4,2,2,void
4937,229601,decrRefCountVoid,1,decrRefCountVoid,void decrRefCountVoid (void*),object.c,"void decrRefCountVoid(void *o) {
    decrRefCount(o);
}",589.0,591.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
4938,229608,checkType,1,checkType,"int checkType (client*,robj*,int)",object.c,"int checkType(client *c, robj *o, int type) {
    /* A NULL is considered an empty key */
    if (o && o->type != type) {
        addReplyErrorObject(c,shared.wrongtypeerr);
        return 1;
    }
    return 0;
}",593.0,600.0,1.0,1.0,8.0,4,4,5,4,29,1,2,2,0,1,,0,0,6,3,3,int
4939,229633,isSdsRepresentableAsLongLong,1,isSdsRepresentableAsLongLong,"int isSdsRepresentableAsLongLong (sds,long long*)",object.c,"int isSdsRepresentableAsLongLong(sds s, long long *llval) {
    return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
}",602.0,604.0,1.0,42.0,3.0,2,2,3,2,0,2,1,1,0,2,,0,1,4,2,2,int
4940,229653,isObjectRepresentableAsLongLong,1,isObjectRepresentableAsLongLong,"int isObjectRepresentableAsLongLong (robj*,long long*)",object.c,"int isObjectRepresentableAsLongLong(robj *o, long long *llval) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    if (o->encoding == OBJ_ENCODING_INT) {
        if (llval) *llval = (long) o->ptr;
        return C_OK;
    } else {
        return isSdsRepresentableAsLongLong(o->ptr,llval);
    }
}",606.0,614.0,1.0,4.0,9.0,12,8,9,3,0,1,3,4,0,1,,0,0,4,2,2,int
4941,229713,trimStringObjectIfNeeded,1,trimStringObjectIfNeeded,"void trimStringObjectIfNeeded (robj*,int)",object.c,"void trimStringObjectIfNeeded(robj *o, int trim_small_values) {
    if (o->encoding != OBJ_ENCODING_RAW) return;
    /* A string may have free space in the following cases:
     * 1. When an arg len is greater than PROTO_MBULK_BIG_ARG the query buffer may be used directly as the SDS string.
     * 2. When utilizing the argument caching mechanism in Lua. 
     * 3. When calling from RM_TrimStringAllocation (trim_small_values is true). */
    size_t len = sdslen(o->ptr);
    if (len >= PROTO_MBULK_BIG_ARG ||
        trim_small_values||
        (server.executing_client && server.executing_client->flags & CLIENT_SCRIPT && len < LUA_CMD_OBJCACHE_MAX_LEN)) {
        if (sdsavail(o->ptr) > len/10) {
            o->ptr = sdsRemoveFreeSpace(o->ptr, 0);
        }
    }
}",618.0,632.0,1.0,23.0,15.0,22,13,12,4,3,3,4,5,1,3,,0,3,4,2,2,void
4942,229788,tryObjectEncodingEx,1,tryObjectEncodingEx,"robj tryObjectEncodingEx (robj*,int)",object.c,"robj *tryObjectEncodingEx(robj *o, int try_trim) {
    long value;
    sds s = o->ptr;
    size_t len;

    /* Make sure this is a string object, the only type we encode
     * in this function. Other types use encoded memory efficient
     * representations but are handled by the commands implementing
     * the type. */
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);

    /* We try some specialized encoding only for objects that are
     * RAW or EMBSTR encoded, in other words objects that are still
     * in represented by an actually array of chars. */
    if (!sdsEncodedObject(o)) return o;

    /* It's not safe to encode shared objects: shared objects can be shared
     * everywhere in the ""object space"" of Redis and may end in places where
     * they are not handled. We handle them only as values in the keyspace. */
     if (o->refcount > 1) return o;

    /* Check if we can represent this string as a long integer.
     * Note that we are sure that a string larger th...",635.0,705.0,1.0,4.0,71.0,39,20,37,9,2,8,8,10,1,8,,0,4,4,2,2,robj
4943,229991,tryObjectEncoding,1,tryObjectEncoding,robj tryObjectEncoding (robj*),object.c,"robj *tryObjectEncoding(robj *o) {
    return tryObjectEncodingEx(o, 1);
}",707.0,709.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,robj
4944,230000,getDecodedObject,1,getDecodedObject,robj getDecodedObject (robj*),object.c,"robj *getDecodedObject(robj *o) {
    robj *dec;

    if (sdsEncodedObject(o)) {
        incrRefCount(o);
        return o;
    }
    if (o->type == OBJ_STRING && o->encoding == OBJ_ENCODING_INT) {
        char buf[32];

        ll2string(buf,32,(long)o->ptr);
        dec = createStringObject(buf,strlen(buf));
        return dec;
    } else {
        serverPanic(""Unknown encoding type"");
    }
}",713.0,729.0,1.0,8.0,17.0,13,6,13,3,17,3,3,3,0,3,,0,1,2,1,1,robj
4945,230070,compareStringObjectsWithFlags,1,compareStringObjectsWithFlags,"int compareStringObjectsWithFlags (robj*,robj*,int)",object.c,"int compareStringObjectsWithFlags(const robj *a, const robj *b, int flags) {
    serverAssertWithInfo(NULL,a,a->type == OBJ_STRING && b->type == OBJ_STRING);
    char bufa[128], bufb[128], *astr, *bstr;
    size_t alen, blen, minlen;

    if (a == b) return 0;
    if (sdsEncodedObject(a)) {
        astr = a->ptr;
        alen = sdslen(astr);
    } else {
        alen = ll2string(bufa,sizeof(bufa),(long) a->ptr);
        astr = bufa;
    }
    if (sdsEncodedObject(b)) {
        bstr = b->ptr;
        blen = sdslen(bstr);
    } else {
        blen = ll2string(bufb,sizeof(bufb),(long) b->ptr);
        bstr = bufb;
    }
    if (flags & REDIS_COMPARE_COLL) {
        return strcoll(astr,bstr);
    } else {
        int cmp;

        minlen = (alen < blen) ? alen : blen;
        cmp = memcmp(astr,bstr,minlen);
        if (cmp == 0) return alen-blen;
        return cmp;
    }
}",742.0,772.0,1.0,4.0,31.0,28,11,25,8,2,3,5,5,0,3,,0,2,6,3,3,int
4946,230242,compareStringObjects,1,compareStringObjects,"int compareStringObjects (robj*,robj*)",object.c,"int compareStringObjects(const robj *a, const robj *b) {
    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
}",775.0,777.0,1.0,45.0,3.0,1,1,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
4947,230257,collateStringObjects,1,collateStringObjects,"int collateStringObjects (robj*,robj*)",object.c,"int collateStringObjects(const robj *a, const robj *b) {
    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
}",780.0,782.0,1.0,45.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
4948,230272,equalStringObjects,1,equalStringObjects,"int equalStringObjects (robj*,robj*)",object.c,"int equalStringObjects(robj *a, robj *b) {
    if (a->encoding == OBJ_ENCODING_INT &&
        b->encoding == OBJ_ENCODING_INT){
        /* If both strings are integer encoded just check if the stored
         * long is the same. */
        return a->ptr == b->ptr;
    } else {
        return compareStringObjects(a,b) == 0;
    }
}",788.0,797.0,1.0,23.0,10.0,8,3,4,2,2,0,2,2,0,0,,0,0,4,2,2,int
4949,230311,stringObjectLen,1,stringObjectLen,size_t stringObjectLen (robj*),object.c,"size_t stringObjectLen(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    if (sdsEncodedObject(o)) {
        return sdslen(o->ptr);
    } else {
        return sdigits10((long)o->ptr);
    }
}",799.0,806.0,1.0,4.0,8.0,12,7,9,2,5,2,2,2,0,2,,0,0,2,1,1,size_t
4950,230368,getDoubleFromObject,1,getDoubleFromObject,"int getDoubleFromObject (robj*,double*)",object.c,"int getDoubleFromObject(const robj *o, double *target) {
    double value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (!string2d(o->ptr, sdslen(o->ptr), &value))
                return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    *target = value;
    return C_OK;
}",808.0,826.0,1.0,8.0,19.0,4,3,5,4,2,0,2,2,0,0,,0,0,4,2,2,int
4951,230477,getDoubleFromObjectOrReply,1,getDoubleFromObjectOrReply,"int getDoubleFromObjectOrReply (client*,robj*,double*,char*)",object.c,"int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {
    double value;
    if (getDoubleFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not a valid float"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",828.0,840.0,1.0,42.0,13.0,7,6,8,6,6,2,3,4,1,2,,0,1,8,4,4,int
4952,230524,getLongDoubleFromObject,1,getLongDoubleFromObject,"int getLongDoubleFromObject (robj*,long double*)",object.c,"int getLongDoubleFromObject(robj *o, long double *target) {
    long double value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (!string2ld(o->ptr, sdslen(o->ptr), &value))
                return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    *target = value;
    return C_OK;
}",842.0,860.0,1.0,8.0,19.0,4,3,5,4,1,0,2,2,0,0,,0,0,4,2,2,int
4953,230633,getLongDoubleFromObjectOrReply,1,getLongDoubleFromObjectOrReply,"int getLongDoubleFromObjectOrReply (client*,robj*,long double*,char*)",object.c,"int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {
    long double value;
    if (getLongDoubleFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not a valid float"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",862.0,874.0,1.0,46.0,13.0,7,6,8,6,0,2,3,4,1,2,,0,1,8,4,4,int
4954,230680,getLongLongFromObject,1,getLongLongFromObject,"int getLongLongFromObject (robj*,long long*)",object.c,"int getLongLongFromObject(robj *o, long long *target) {
    long long value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (string2ll(o->ptr,sdslen(o->ptr),&value) == 0) return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    if (target) *target = value;
    return C_OK;
}",876.0,893.0,1.0,8.0,18.0,4,3,6,4,4,0,3,3,0,0,,0,0,4,2,2,int
4955,230793,getLongLongFromObjectOrReply,1,getLongLongFromObjectOrReply,"int getLongLongFromObjectOrReply (client*,robj*,long long*,char*)",object.c,"int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {
    long long value;
    if (getLongLongFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not an integer or out of range"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",895.0,907.0,1.0,44.0,13.0,7,6,8,6,13,2,3,4,1,2,,0,1,8,4,4,int
4956,230840,getLongFromObjectOrReply,1,getLongFromObjectOrReply,"int getLongFromObjectOrReply (client*,robj*,long*,char*)",object.c,"int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
    long long value;

    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
    if (value < LONG_MIN || value > LONG_MAX) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is out of range"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",909.0,923.0,1.0,59.0,15.0,11,9,14,8,13,2,4,5,1,2,,0,1,8,4,4,int
4957,230903,getRangeLongFromObjectOrReply,1,getRangeLongFromObjectOrReply,"int getRangeLongFromObjectOrReply (client*,robj*,long,long,long*,char*)",object.c,"int getRangeLongFromObjectOrReply(client *c, robj *o, long min, long max, long *target, const char *msg) {
    if (getLongFromObjectOrReply(c, o, target, msg) != C_OK) return C_ERR;
    if (*target < min || *target > max) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyErrorFormat(c,""value is out of range, value must between %ld and %ld"", min, max);
        }
        return C_ERR;
    }
    return C_OK;
}",925.0,936.0,1.0,55.0,12.0,10,7,12,7,8,2,4,5,1,2,,0,1,12,6,6,int
4958,230966,getPositiveLongFromObjectOrReply,1,getPositiveLongFromObjectOrReply,"int getPositiveLongFromObjectOrReply (client*,robj*,long*,char*)",object.c,"int getPositiveLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
    if (msg) {
        return getRangeLongFromObjectOrReply(c, o, 0, LONG_MAX, target, msg);
    } else {
        return getRangeLongFromObjectOrReply(c, o, 0, LONG_MAX, target, ""value is out of range, must be positive"");
    }
}",938.0,944.0,1.0,1.0,7.0,0,0,6,5,3,1,2,2,0,1,,0,0,8,4,4,int
4959,230995,getIntFromObjectOrReply,1,getIntFromObjectOrReply,"int getIntFromObjectOrReply (client*,robj*,int*,char*)",object.c,"int getIntFromObjectOrReply(client *c, robj *o, int *target, const char *msg) {
    long value;

    if (getRangeLongFromObjectOrReply(c, o, INT_MIN, INT_MAX, &value, msg) != C_OK)
        return C_ERR;

    *target = value;
    return C_OK;
}",946.0,954.0,1.0,78.0,9.0,5,5,8,7,4,1,2,2,1,1,,0,1,8,4,4,int
4960,231031,strEncoding,1,strEncoding,char* strEncoding (int),object.c,"char *strEncoding(int encoding) {
    switch(encoding) {
    case OBJ_ENCODING_RAW: return ""raw"";
    case OBJ_ENCODING_INT: return ""int"";
    case OBJ_ENCODING_HT: return ""hashtable"";
    case OBJ_ENCODING_QUICKLIST: return ""quicklist"";
    case OBJ_ENCODING_LISTPACK: return ""listpack"";
    case OBJ_ENCODING_INTSET: return ""intset"";
    case OBJ_ENCODING_SKIPLIST: return ""skiplist"";
    case OBJ_ENCODING_EMBSTR: return ""embstr"";
    case OBJ_ENCODING_STREAM: return ""stream"";
    default: return ""unknown"";
    }
}",956.0,969.0,1.0,9.0,14.0,0,0,1,1,0,0,2,2,0,0,,0,0,2,1,1,char*
4961,231096,streamRadixTreeMemoryUsage,1,streamRadixTreeMemoryUsage,size_t streamRadixTreeMemoryUsage (rax*),object.c,"size_t streamRadixTreeMemoryUsage(rax *rax) {
    size_t size = sizeof(*rax);
    size = rax->numele * sizeof(streamID);
    size += rax->numnodes * sizeof(raxNode);
    /* Add a fixed overhead due to the aux data pointer, children, ... */
    size += rax->numnodes * sizeof(long)*30;
    return size;
}",988.0,995.0,1.0,1.0,8.0,16,6,12,5,0,3,1,1,0,0,,0,3,2,1,1,size_t
4962,231135,objectComputeSize,1,objectComputeSize,"size_t objectComputeSize (robj*,robj*,size_t,int)",object.c,"size_t objectComputeSize(robj *key, robj *o, size_t sample_size, int dbid) {
    sds ele, ele2;
    dict *d;
    dictIterator *di;
    struct dictEntry *de;
    size_t asize = 0, elesize = 0, samples = 0;

    if (o->type == OBJ_STRING) {
        if(o->encoding == OBJ_ENCODING_INT) {
            asize = sizeof(*o);
        } else if(o->encoding == OBJ_ENCODING_RAW) {
            asize = sdsZmallocSize(o->ptr)+sizeof(*o);
        } else if(o->encoding == OBJ_ENCODING_EMBSTR) {
            asize = zmalloc_size((void *)o);
        } else {
            serverPanic(""Unknown string encoding"");
        }
    } else if (o->type == OBJ_LIST) {
        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
            quicklist *ql = o->ptr;
            quicklistNode *node = ql->head;
            asize = sizeof(*o)+sizeof(quicklist);
            do {
                elesize += sizeof(quicklistNode)+zmalloc_size(node->entry);
                samples++;
            } while ((node = node->next) && samples...",1002.0,1161.0,1.0,19.0,160.0,10,5,8,4,0,0,3,4,0,0,,0,0,8,4,4,size_t
4963,232146,freeMemoryOverheadData,1,freeMemoryOverheadData,void freeMemoryOverheadData (redisMemOverhead*),object.c,"void freeMemoryOverheadData(struct redisMemOverhead *mh) {
    zfree(mh->db);
    zfree(mh);
}",1164.0,1167.0,1.0,1.0,4.0,1,1,2,1,2,2,1,1,0,2,,0,0,2,1,1,void
4964,232157,getMemoryOverheadData,1,getMemoryOverheadData,struct redisMemOverhead getMemoryOverheadData (void),object.c,"struct redisMemOverhead *getMemoryOverheadData(void) {
    int j;
    size_t mem_total = 0;
    size_t mem = 0;
    size_t zmalloc_used = zmalloc_used_memory();
    struct redisMemOverhead *mh = zcalloc(sizeof(*mh));

    mh->total_allocated = zmalloc_used;
    mh->startup_allocated = server.initial_memory_usage;
    mh->peak_allocated = server.stat_peak_memory;
    mh->total_frag =
        (float)server.cron_malloc_stats.process_rss / server.cron_malloc_stats.zmalloc_used;
    mh->total_frag_bytes =
        server.cron_malloc_stats.process_rss - server.cron_malloc_stats.zmalloc_used;
    mh->allocator_frag =
        (float)server.cron_malloc_stats.allocator_active / server.cron_malloc_stats.allocator_allocated;
    mh->allocator_frag_bytes =
        server.cron_malloc_stats.allocator_active - server.cron_malloc_stats.allocator_allocated;
    mh->allocator_rss =
        (float)server.cron_malloc_stats.allocator_resident / server.cron_malloc_stats.allocator_active;
    mh->allocator_...",1172.0,1287.0,1.0,8.0,116.0,266,19,159,12,2,69,8,8,1,9,,0,67,2,1,1,struct redisMemOverhead
4965,232829,inputCatSds,1,inputCatSds,"void inputCatSds (void*,char*)",object.c,"void inputCatSds(void *result, const char *str) {
    /* result is actually a (sds *), so re-cast it here */
    sds *info = (sds *)result;
    *info = sdscat(*info, str);
}",1291.0,1295.0,1.0,1.0,5.0,5,3,5,3,0,1,1,1,0,1,,0,1,4,2,2,void
4966,232848,getMemoryDoctorReport,1,getMemoryDoctorReport,sds getMemoryDoctorReport (void),object.c,"sds getMemoryDoctorReport(void) {
    int empty = 0;          /* Instance is empty or almost empty. */
    int big_peak = 0;       /* Memory peak is much larger than used mem. */
    int high_frag = 0;      /* High fragmentation. */
    int high_alloc_frag = 0;/* High allocator fragmentation. */
    int high_proc_rss = 0;  /* High process rss overhead. */
    int high_alloc_rss = 0; /* High rss overhead. */
    int big_slave_buf = 0;  /* Slave buffers are too big. */
    int big_client_buf = 0; /* Client buffers are too big. */
    int many_scripts = 0;   /* Script cache has too many scripts. */
    int num_reports = 0;
    struct redisMemOverhead *mh = getMemoryOverheadData();

    if (mh->total_allocated < (1024*1024*5)) {
        empty = 1;
        num_reports++;
    } else {
        /* Peak is > 150% of current used memory? */
        if (((float)mh->peak_allocated / mh->total_allocated) > 1.5) {
            big_peak = 1;
            num_reports++;
        }

        /* Fragment...",1299.0,1409.0,1.0,25.0,111.0,19,6,18,12,0,4,3,3,1,3,,0,3,2,1,1,sds
4967,233203,objectSetLRUOrLFU,1,objectSetLRUOrLFU,"int objectSetLRUOrLFU (robj*,long long,long long,long long,int)",object.c,"int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
                       long long lru_clock, int lru_multiplier) {
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        if (lfu_freq >= 0) {
            serverAssert(lfu_freq <= 255);
            val->lru = (LFUGetTimeInMinutes()<<8) | lfu_freq;
            return 1;
        }
    } else if (lru_idle >= 0) {
        /* Provided LRU idle time is in seconds. Scale
         * according to the LRU clock resolution this Redis
         * instance was compiled with (normally 1000 ms, so the
         * below statement will expand to lru_idle*1000/1000. */
        lru_idle = lru_idle*lru_multiplier/LRU_CLOCK_RESOLUTION;
        long lru_abs = lru_clock - lru_idle; /* Absolute access time. */
        /* If the LRU field underflows (since lru_clock is a wrapping clock),
         * we need to make it positive again. This be handled by the unwrapping
         * code in estimateObjectIdleTime. I.e. imagine a day wh...",1416.0,1442.0,1.0,34.0,27.0,13,12,5,3,3,2,3,4,0,2,,0,1,10,5,5,int
4968,233300,objectCommandLookup,1,objectCommandLookup,"robj objectCommandLookup (client*,robj*)",object.c,"robj *objectCommandLookup(client *c, robj *key) {
    return lookupKeyReadWithFlags(c->db,key,LOOKUP_NOTOUCH|LOOKUP_NONOTIFY);
}",1448.0,1450.0,1.0,44.0,3.0,4,3,2,2,1,2,1,1,0,1,,0,1,4,2,2,robj
4969,233323,objectCommandLookupOrReply,1,objectCommandLookupOrReply,"robj objectCommandLookupOrReply (client*,robj*,robj*)",object.c,"robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
    robj *o = objectCommandLookup(c,key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",1452.0,1456.0,1.0,1.0,5.0,2,2,7,4,0,2,2,2,0,2,,0,1,6,3,3,robj
4970,233345,objectCommand,1,objectCommand,void objectCommand (client*),object.c,"void objectCommand(client *c) {
    robj *o;

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""ENCODING <key>"",
""    Return the kind of internal representation used in order to store the value"",
""    associated with a <key>."",
""FREQ <key>"",
""    Return the access frequency index of the <key>. The returned integer is"",
""    proportional to the logarithm of the recent access frequency of the key."",
""IDLETIME <key>"",
""    Return the idle time of the <key>, that is the approximated number of"",
""    seconds elapsed since the last access to the key."",
""REFCOUNT <key>"",
""    Return the number of references of the value associated with the specified"",
""    <key>."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""refcount"") && c->argc == 3) {
        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.null[c->resp]))
                == NULL) return;
        addReplyLongLong(c,o->refcount);
    } else...",1460.0,1511.0,1.0,38.0,52.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
4971,233609,memoryCommand,1,memoryCommand,void memoryCommand (client*),object.c,"void memoryCommand(client *c) {
    if (!strcasecmp(c->argv[1]->ptr,""help"") && c->argc == 2) {
        const char *help[] = {
""DOCTOR"",
""    Return memory problems reports."",
""MALLOC-STATS"",
""    Return internal statistics report from the memory allocator."",
""PURGE"",
""    Attempt to purge dirty pages for reclamation by the allocator."",
""STATS"",
""    Return information about the memory usage of the server."",
""USAGE <key> [SAMPLES <count>]"",
""    Return memory in bytes used by <key> and its value. Nested values are"",
""    sampled up to <count> times (default: 5, 0 means sample all)."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""usage"") && c->argc >= 3) {
        dictEntry *de;
        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;
        for (int j = 3; j < c->argc; j++) {
            if (!strcasecmp(c->argv[j]->ptr,""samples"") &&
                j+1 < c->argc)
            {
                if (getLongLongFromObjectOrReply(c,c->argv[j+...",1517.0,1688.0,1.0,28.0,172.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
4972,234272,med3,1,med3,"char* med3 (char*,char*,char*,int)",pqsort.c,"static inline char *
med3(char *a, char *b, char *c,
    int (*cmp) (const void *, const void *))
{

	return cmp(a, b) < 0 ?
	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
}",88.0,96.0,1.0,1.0,9.0,0,0,0,0,4,0,1,1,0,0,,0,0,8,4,4,char*
4973,234280,swapfunc,1,swapfunc,"void swapfunc (char*,char*,ANY,int)",pqsort.c,"static inline void
swapfunc(char *a, char *b, size_t n, int swaptype)
{

	if (swaptype <= 1)
		swapcode(long, a, b, n)
	else
		swapcode(char, a, b, n)
}",68.0,76.0,1.0,2.0,9.0,0,0,0,0,6,0,1,1,0,0,,0,0,8,4,4,void
4974,234438,_pqsort,1,_pqsort,"void _pqsort (void*,size_t,size_t,int,void*,void*)",pqsort.c,"static void
_pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), void *lrange, void *rrange)
{
	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
	size_t d, r;
	int swaptype, cmp_result;

loop:	SWAPINIT(a, es);
	if (n < 7) {
		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
			     pl -= es)
				swap(pl, pl - es);
		return;
	}
	pm = (char *) a + (n / 2) * es;
	if (n > 7) {
		pl = (char *) a;
		pn = (char *) a + (n - 1) * es;
		if (n > 40) {
			d = (n / 8) * es;
			pl = med3(pl, pl + d, pl + 2 * d, cmp);
			pm = med3(pm - d, pm, pm + d, cmp);
			pn = med3(pn - 2 * d, pn - d, pn, cmp);
		}
		pm = med3(pl, pm, pn, cmp);
	}
	swap(a, pm);
	pa = pb = (char *) a + es;

	pc = pd = (char *) a + (n - 1) * es;
	for (;;) {
		while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0) {
			if (cmp_result == 0) {
				swap(pa, pb);
				pa += es;
			}
			pb += es;
		}
		while (pb <= pc && (cmp_result = cmp(pc, a)) >...",98.0,177.0,1.0,6.0,80.0,202,20,232,25,1,10,17,26,0,10,,0,4,12,6,6,void
4975,235138,pqsort,1,pqsort,"void pqsort (void*,size_t,size_t,int,size_t,size_t)",pqsort.c,"void
pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
{
    _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
                       ((unsigned char*)a)+((rrange+1)*es)-1);
}",179.0,185.0,1.0,1.0,7.0,8,4,10,6,1,1,1,1,0,1,,0,0,12,6,6,void
4976,235197,clientPubSubChannels,1,pubsubtype.clientPubSubChannels,dict* pubsubtype.clientPubSubChannels (client*),pubsub.c,dict *(*clientPubSubChannels)(client*);,37.0,37.0,10.0,42.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,dict*
4977,235202,subscriptionCount,1,pubsubtype.subscriptionCount,int pubsubtype.subscriptionCount (client*),pubsub.c,int (*subscriptionCount)(client*);,38.0,38.0,9.0,37.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
4978,235212,clientSubscriptionsCount,1,clientSubscriptionsCount,int clientSubscriptionsCount (client*),pubsub.c,"int clientSubscriptionsCount(client *c) {
    return dictSize(c->pubsub_channels) + dictSize(c->pubsub_patterns);
}",221.0,223.0,1.0,11.0,3.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
4979,235217,clientShardSubscriptionsCount,1,clientShardSubscriptionsCount,int clientShardSubscriptionsCount (client*),pubsub.c,"int clientShardSubscriptionsCount(client *c) {
    return dictSize(c->pubsubshard_channels);
}",226.0,228.0,1.0,11.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
4980,235222,getClientPubSubChannels,1,getClientPubSubChannels,dict* getClientPubSubChannels (client*),pubsub.c,"dict* getClientPubSubChannels(client *c) {
    return c->pubsub_channels;
}",230.0,232.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,dict
4981,235227,getClientPubSubShardChannels,1,getClientPubSubShardChannels,dict* getClientPubSubShardChannels (client*),pubsub.c,"dict* getClientPubSubShardChannels(client *c) {
    return c->pubsubshard_channels;
}",234.0,236.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,dict
4982,235232,channelList,1,channelList,"void channelList (client*,sds,dict*)",pubsub.c,"void channelList(client *c, sds pat, dict *pubsub_channels) {
    dictIterator *di = dictGetIterator(pubsub_channels);
    dictEntry *de;
    long mblen = 0;
    void *replylen;

    replylen = addReplyDeferredLen(c);
    while((de = dictNext(di)) != NULL) {
        robj *cobj = dictGetKey(de);
        sds channel = cobj->ptr;

        if (!pat || stringmatchlen(pat, sdslen(pat),
                                   channel, sdslen(channel),0))
        {
            addReplyBulk(c,cobj);
            mblen++;
        }
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c,replylen,mblen);
}",680.0,700.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
4983,235327,addReplyPubsubMessage,1,addReplyPubsubMessage,"void addReplyPubsubMessage (client*,robj*,robj*,robj*)",pubsub.c,"void addReplyPubsubMessage(client *c, robj *channel, robj *msg, robj *message_bulk) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,message_bulk);
    addReplyBulk(c,channel);
    if (msg) addReplyBulk(c,msg);
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",107.0,118.0,1.0,16.0,12.0,14,9,15,6,1,8,4,4,1,4,,0,4,8,4,4,void
4984,235401,addReplyPubsubPatMessage,1,addReplyPubsubPatMessage,"void addReplyPubsubPatMessage (client*,robj*,robj*,robj*)",pubsub.c,"void addReplyPubsubPatMessage(client *c, robj *pat, robj *channel, robj *msg) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[4]);
    else
        addReplyPushLen(c,4);
    addReply(c,shared.pmessagebulk);
    addReplyBulk(c,pat);
    addReplyBulk(c,channel);
    addReplyBulk(c,msg);
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",123.0,135.0,1.0,16.0,13.0,15,9,16,6,1,9,3,3,1,5,,0,4,8,4,4,void
4985,235477,addReplyPubsubSubscribed,1,addReplyPubsubSubscribed,"void addReplyPubsubSubscribed (client*,robj*,pubsubtype)",pubsub.c,"void addReplyPubsubSubscribed(client *c, robj *channel, pubsubtype type) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,*type.subscribeMsg);
    addReplyBulk(c,channel);
    addReplyLongLong(c,type.subscriptionCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",138.0,149.0,1.0,16.0,12.0,17,10,15,5,1,10,3,3,1,5,,0,6,6,3,3,void
4986,235554,addReplyPubsubUnsubscribed,1,addReplyPubsubUnsubscribed,"void addReplyPubsubUnsubscribed (client*,robj*,pubsubtype)",pubsub.c,"void addReplyPubsubUnsubscribed(client *c, robj *channel, pubsubtype type) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c, *type.unsubscribeMsg);
    if (channel)
        addReplyBulk(c,channel);
    else
        addReplyNull(c);
    addReplyLongLong(c,type.subscriptionCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",155.0,169.0,1.0,16.0,15.0,17,10,16,5,3,10,4,4,1,5,,0,6,6,3,3,void
4987,235638,addReplyPubsubPatSubscribed,1,addReplyPubsubPatSubscribed,"void addReplyPubsubPatSubscribed (client*,robj*)",pubsub.c,"void addReplyPubsubPatSubscribed(client *c, robj *pattern) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,shared.psubscribebulk);
    addReplyBulk(c,pattern);
    addReplyLongLong(c,clientSubscriptionsCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",172.0,183.0,1.0,16.0,12.0,15,9,14,4,1,9,3,3,1,5,,0,5,4,2,2,void
4988,235710,addReplyPubsubPatUnsubscribed,1,addReplyPubsubPatUnsubscribed,"void addReplyPubsubPatUnsubscribed (client*,robj*)",pubsub.c,"void addReplyPubsubPatUnsubscribed(client *c, robj *pattern) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,shared.punsubscribebulk);
    if (pattern)
        addReplyBulk(c,pattern);
    else
        addReplyNull(c);
    addReplyLongLong(c,clientSubscriptionsCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",189.0,203.0,1.0,16.0,15.0,15,9,15,4,2,9,4,4,1,5,,0,5,4,2,2,void
4989,235789,serverPubsubSubscriptionCount,1,serverPubsubSubscriptionCount,int serverPubsubSubscriptionCount (void),pubsub.c,"int serverPubsubSubscriptionCount(void) {
    return dictSize(server.pubsub_channels) + dictSize(server.pubsub_patterns);
}",210.0,212.0,1.0,11.0,3.0,17,4,6,1,0,0,1,1,0,0,,0,0,2,1,1,int
4990,235836,serverPubsubShardSubscriptionCount,1,serverPubsubShardSubscriptionCount,int serverPubsubShardSubscriptionCount (void),pubsub.c,"int serverPubsubShardSubscriptionCount(void) {
    return dictSize(server.pubsubshard_channels);
}",215.0,217.0,1.0,11.0,3.0,8,4,3,1,0,0,1,1,0,0,,0,0,2,1,1,int
4991,235953,clientTotalPubSubSubscriptionCount,1,clientTotalPubSubSubscriptionCount,int clientTotalPubSubSubscriptionCount (client*),pubsub.c,"int clientTotalPubSubSubscriptionCount(client *c) {
    return clientSubscriptionsCount(c) + clientShardSubscriptionsCount(c);
}",240.0,242.0,1.0,1.0,3.0,1,1,2,1,4,2,1,1,0,2,,0,0,2,1,1,int
4992,235964,pubsubSubscribeChannel,1,pubsubSubscribeChannel,"int pubsubSubscribeChannel (client*,robj*,pubsubtype)",pubsub.c,"int pubsubSubscribeChannel(client *c, robj *channel, pubsubtype type) {
    dictEntry *de;
    list *clients = NULL;
    int retval = 0;

    /* Add the channel to the client -> channels hash table */
    if (dictAdd(type.clientPubSubChannels(c),channel,NULL) == DICT_OK) {
        retval = 1;
        incrRefCount(channel);
        /* Add the client to the channel -> list of clients hash table */
        de = dictFind(*type.serverPubSubChannels, channel);
        if (de == NULL) {
            clients = listCreate();
            dictAdd(*type.serverPubSubChannels, channel, clients);
            incrRefCount(channel);
        } else {
            clients = dictGetVal(de);
        }
        listAddNodeTail(clients,c);
    }
    /* Notify the client */
    addReplyPubsubSubscribed(c,channel,type);
    return retval;
}",246.0,269.0,1.0,62.0,24.0,12,4,25,7,1,11,3,4,2,9,,0,6,6,3,3,int
4993,236039,pubsubUnsubscribeChannel,1,pubsubUnsubscribeChannel,"int pubsubUnsubscribeChannel (client*,robj*,int,pubsubtype)",pubsub.c,"int pubsubUnsubscribeChannel(client *c, robj *channel, int notify, pubsubtype type) {
    dictEntry *de;
    list *clients;
    listNode *ln;
    int retval = 0;

    /* Remove the channel from the client -> channels hash table */
    incrRefCount(channel); /* channel may be just a pointer to the same object
                            we have in the hash tables. Protect it... */
    if (dictDelete(type.clientPubSubChannels(c),channel) == DICT_OK) {
        retval = 1;
        /* Remove the client from the channel -> clients list hash table */
        de = dictFind(*type.serverPubSubChannels, channel);
        serverAssertWithInfo(c,NULL,de != NULL);
        clients = dictGetVal(de);
        ln = listSearchKey(clients,c);
        serverAssertWithInfo(c,NULL,ln != NULL);
        listDelNode(clients,ln);
        if (listLength(clients) == 0) {
            /* Free the list and associated hash entry at all if this was
             * the latest client, so that it will be possible to abus...",273.0,309.0,1.0,60.0,37.0,27,11,41,10,1,17,5,8,4,13,,0,9,8,4,4,int
4994,236172,pubsubShardUnsubscribeAllClients,1,pubsubShardUnsubscribeAllClients,void pubsubShardUnsubscribeAllClients (robj*),pubsub.c,"void pubsubShardUnsubscribeAllClients(robj *channel) {
    int retval;
    dictEntry *de = dictFind(server.pubsubshard_channels, channel);
    serverAssertWithInfo(NULL,channel,de != NULL);
    list *clients = dictGetVal(de);
    if (listLength(clients) > 0) {
        /* For each client subscribed to the channel, unsubscribe it. */
        listIter li;
        listNode *ln;
        listRewind(clients, &li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = listNodeValue(ln);
            retval = dictDelete(c->pubsubshard_channels, channel);
            serverAssertWithInfo(c,channel,retval == DICT_OK);
            addReplyPubsubUnsubscribed(c, channel, pubSubShardType);
            /* If the client has no other pubsub subscription,
             * move out of pubsub mode. */
            if (clientTotalPubSubSubscriptionCount(c) == 0) {
                c->flags &= ~CLIENT_PUBSUB;
            }
        }
    }
    /* Delete the channel from server pubsubshard chann...",311.0,339.0,1.0,4.0,29.0,35,13,44,10,1,18,4,7,3,13,,0,11,2,1,1,void
4995,236325,pubsubSubscribePattern,1,pubsubSubscribePattern,"int pubsubSubscribePattern (client*,robj*)",pubsub.c,"int pubsubSubscribePattern(client *c, robj *pattern) {
    dictEntry *de;
    list *clients;
    int retval = 0;

    if (dictAdd(c->pubsub_patterns, pattern, NULL) == DICT_OK) {
        retval = 1;
        incrRefCount(pattern);
        /* Add the client to the pattern -> list of clients hash table */
        de = dictFind(server.pubsub_patterns,pattern);
        if (de == NULL) {
            clients = listCreate();
            dictAdd(server.pubsub_patterns,pattern,clients);
            incrRefCount(pattern);
        } else {
            clients = dictGetVal(de);
        }
        listAddNodeTail(clients,c);
    }
    /* Notify the client */
    addReplyPubsubPatSubscribed(c,pattern);
    return retval;
}",343.0,365.0,1.0,54.0,23.0,9,4,21,7,0,9,3,4,2,8,,0,4,4,2,2,int
4996,236391,pubsubUnsubscribePattern,1,pubsubUnsubscribePattern,"int pubsubUnsubscribePattern (client*,robj*,int)",pubsub.c,"int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
    dictEntry *de;
    list *clients;
    listNode *ln;
    int retval = 0;

    incrRefCount(pattern); /* Protect the object. May be the same we remove */
    if (dictDelete(c->pubsub_patterns, pattern) == DICT_OK) {
        retval = 1;
        /* Remove the client from the pattern -> clients list hash table */
        de = dictFind(server.pubsub_patterns,pattern);
        serverAssertWithInfo(c,NULL,de != NULL);
        clients = dictGetVal(de);
        ln = listSearchKey(clients,c);
        serverAssertWithInfo(c,NULL,ln != NULL);
        listDelNode(clients,ln);
        if (listLength(clients) == 0) {
            /* Free the list and associated hash entry at all if this was
             * the latest client. */
            dictDelete(server.pubsub_patterns,pattern);
        }
    }
    /* Notify the client */
    if (notify) addReplyPubsubPatUnsubscribed(c,pattern);
    decrRefCount(pattern);
    return retval;
}",369.0,395.0,1.0,51.0,27.0,21,9,36,9,1,13,4,5,3,11,,0,6,6,3,3,int
4997,236505,pubsubUnsubscribeAllChannelsInternal,1,pubsubUnsubscribeAllChannelsInternal,"int pubsubUnsubscribeAllChannelsInternal (client*,int,pubsubtype)",pubsub.c,"int pubsubUnsubscribeAllChannelsInternal(client *c, int notify, pubsubtype type) {
    int count = 0;
    if (dictSize(type.clientPubSubChannels(c)) > 0) {
        dictIterator *di = dictGetSafeIterator(type.clientPubSubChannels(c));
        dictEntry *de;

        while((de = dictNext(di)) != NULL) {
            robj *channel = dictGetKey(de);

            count += pubsubUnsubscribeChannel(c,channel,notify,type);
        }
        dictReleaseIterator(di);
    }
    /* We were subscribed to nothing? Still reply to the client. */
    if (notify && count == 0) {
        addReplyPubsubUnsubscribed(c,NULL,type);
    }
    return count;
}",399.0,417.0,1.0,8.0,19.0,18,10,27,8,2,7,4,5,1,7,,0,4,6,3,3,int
4998,236591,pubsubUnsubscribeAllChannels,1,pubsubUnsubscribeAllChannels,"int pubsubUnsubscribeAllChannels (client*,int)",pubsub.c,"int pubsubUnsubscribeAllChannels(client *c, int notify) {
    int count = pubsubUnsubscribeAllChannelsInternal(c,notify,pubSubType);
    return count;
}",422.0,425.0,1.0,1.0,4.0,1,1,5,4,3,2,1,1,0,1,,0,2,4,2,2,int
4999,236606,pubsubUnsubscribeShardAllChannels,1,pubsubUnsubscribeShardAllChannels,"int pubsubUnsubscribeShardAllChannels (client*,int)",pubsub.c,"int pubsubUnsubscribeShardAllChannels(client *c, int notify) {
    int count = pubsubUnsubscribeAllChannelsInternal(c, notify, pubSubShardType);
    return count;
}",430.0,433.0,1.0,1.0,4.0,1,1,5,4,3,2,1,1,0,1,,0,2,4,2,2,int
5000,236621,pubsubUnsubscribeShardChannels,1,pubsubUnsubscribeShardChannels,"void pubsubUnsubscribeShardChannels (robj**,unsigned int)",pubsub.c,"void pubsubUnsubscribeShardChannels(robj **channels, unsigned int count) {
    for (unsigned int j = 0; j < count; j++) {
        /* Remove the channel from server and from the clients
         * subscribed to it as well as notify them. */
        pubsubShardUnsubscribeAllClients(channels[j]);
    }
}",438.0,444.0,1.0,1.0,7.0,3,3,5,3,0,1,2,2,0,1,,0,0,4,2,2,void
5001,236643,pubsubUnsubscribeAllPatterns,1,pubsubUnsubscribeAllPatterns,"int pubsubUnsubscribeAllPatterns (client*,int)",pubsub.c,"int pubsubUnsubscribeAllPatterns(client *c, int notify) {
    int count = 0;

    if (dictSize(c->pubsub_patterns) > 0) {
        dictIterator *di = dictGetSafeIterator(c->pubsub_patterns);
        dictEntry *de;

        while ((de = dictNext(di)) != NULL) {
            robj *pattern = dictGetKey(de);
            count += pubsubUnsubscribePattern(c, pattern, notify);
        }
        dictReleaseIterator(di);
    }

    /* We were subscribed to nothing? Still reply to the client. */
    if (notify && count == 0) addReplyPubsubPatUnsubscribed(c,NULL);
    return count;
}",448.0,465.0,1.0,8.0,18.0,18,9,21,7,3,10,4,5,4,6,,0,7,4,2,2,int
5002,236718,pubsubPublishMessageInternal,1,pubsubPublishMessageInternal,"int pubsubPublishMessageInternal (robj*,robj*,pubsubtype)",pubsub.c,"int pubsubPublishMessageInternal(robj *channel, robj *message, pubsubtype type) {
    int receivers = 0;
    dictEntry *de;
    dictIterator *di;
    listNode *ln;
    listIter li;

    /* Send to clients listening for that channel */
    de = dictFind(*type.serverPubSubChannels, channel);
    if (de) {
        list *list = dictGetVal(de);
        listNode *ln;
        listIter li;

        listRewind(list,&li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = ln->value;
            addReplyPubsubMessage(c,channel,message,*type.messageBulk);
            updateClientMemUsageAndBucket(c);
            receivers++;
        }
    }

    if (type.shard) {
        /* Shard pubsub ignores patterns. */
        return receivers;
    }

    /* Send to clients listening to matching channels */
    di = dictGetIterator(server.pubsub_patterns);
    if (di) {
        channel = getDecodedObject(channel);
        while((de = dictNext(di)) != NULL) {
            robj *pattern = ...",470.0,522.0,1.0,28.0,53.0,36,9,55,14,1,25,9,14,7,20,,0,17,6,3,3,int
5003,236881,pubsubPublishMessage,1,pubsubPublishMessage,"int pubsubPublishMessage (robj*,robj*,int)",pubsub.c,"int pubsubPublishMessage(robj *channel, robj *message, int sharded) {
    return pubsubPublishMessageInternal(channel, message, sharded? pubSubShardType : pubSubType);
}",525.0,527.0,1.0,1.0,3.0,1,1,5,5,3,3,1,1,0,1,,0,2,6,3,3,int
5004,236896,subscribeCommand,1,subscribeCommand,void subscribeCommand (client*),pubsub.c,"void subscribeCommand(client *c) {
    int j;
    if ((c->flags & CLIENT_DENY_BLOCKING) && !(c->flags & CLIENT_MULTI)) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe.
         *
         * Notice that we have a special treatment for multi because of
         * backward compatibility
         */
        addReplyError(c, ""SUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }
    for (j = 1; j < c->argc; j++)
        pubsubSubscribeChannel(c,c->argv[j],pubSubType);
    c->flags |= CLIENT_PUBSUB;
}",534.0,550.0,1.0,20.0,17.0,13,7,7,2,0,5,3,3,3,1,,0,4,2,1,1,void
5005,236957,unsubscribeCommand,1,unsubscribeCommand,void unsubscribeCommand (client*),pubsub.c,"void unsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeAllChannels(c,1);
    } else {
        int j;

        for (j = 1; j < c->argc; j++)
            pubsubUnsubscribeChannel(c,c->argv[j],1,pubSubType);
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",553.0,563.0,1.0,65.0,11.0,6,4,4,1,0,4,3,3,2,2,,0,3,2,1,1,void
5006,237012,psubscribeCommand,1,psubscribeCommand,void psubscribeCommand (client*),pubsub.c,"void psubscribeCommand(client *c) {
    int j;
    if ((c->flags & CLIENT_DENY_BLOCKING) && !(c->flags & CLIENT_MULTI)) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe.
         *
         * Notice that we have a special treatment for multi because of
         * backward compatibility
         */
        addReplyError(c, ""PSUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }

    for (j = 1; j < c->argc; j++)
        pubsubSubscribePattern(c,c->argv[j]);
    c->flags |= CLIENT_PUBSUB;
}",566.0,583.0,1.0,20.0,18.0,13,7,7,2,0,5,3,3,3,1,,0,4,2,1,1,void
5007,237072,punsubscribeCommand,1,punsubscribeCommand,void punsubscribeCommand (client*),pubsub.c,"void punsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeAllPatterns(c,1);
    } else {
        int j;

        for (j = 1; j < c->argc; j++)
            pubsubUnsubscribePattern(c,c->argv[j],1);
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",586.0,596.0,1.0,65.0,11.0,6,4,4,1,0,4,3,3,2,2,,0,3,2,1,1,void
5008,237126,pubsubPublishMessageAndPropagateToCluster,1,pubsubPublishMessageAndPropagateToCluster,"int pubsubPublishMessageAndPropagateToCluster (robj*,robj*,int)",pubsub.c,"int pubsubPublishMessageAndPropagateToCluster(robj *channel, robj *message, int sharded) {
    int receivers = pubsubPublishMessage(channel, message, sharded);
    if (server.cluster_enabled)
        clusterPropagatePublish(channel, message, sharded);
    return receivers;
}",600.0,605.0,1.0,1.0,6.0,2,2,9,5,4,2,2,2,0,2,,0,1,6,3,3,int
5009,237151,publishCommand,1,publishCommand,void publishCommand (client*),pubsub.c,"void publishCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelPublishCommand(c);
        return;
    }

    int receivers = pubsubPublishMessageAndPropagateToCluster(c->argv[1],c->argv[2],0);
    if (!server.cluster_enabled)
        forceCommandPropagation(c,PROPAGATE_REPL);
    addReplyLongLong(c,receivers);
}",608.0,618.0,1.0,34.0,11.0,8,5,9,3,0,6,3,3,0,4,,0,3,2,1,1,void
5010,237193,pubsubCommand,1,pubsubCommand,void pubsubCommand (client*),pubsub.c,"void pubsubCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CHANNELS [<pattern>]"",
""    Return the currently active channels matching a <pattern> (default: '*')."",
""NUMPAT"",
""    Return number of subscriptions to patterns."",
""NUMSUB [<channel> ...]"",
""    Return the number of subscribers for the specified channels, excluding"",
""    pattern subscriptions(default: no channels)."",
""SHARDCHANNELS [<pattern>]"",
""    Return the currently active shard level channels matching a <pattern> (default: '*')."",
""SHARDNUMSUB [<shardchannel> ...]"",
""    Return the number of subscribers for the specified shard level channel(s)"",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""channels"") &&
        (c->argc == 2 || c->argc == 3))
    {
        /* PUBSUB CHANNELS [<pattern>] */
        sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
        channelList(c, pat, server.pubsub_channels);
    }...",621.0,678.0,1.0,35.0,58.0,9,7,6,3,0,3,2,2,2,1,,0,2,2,1,1,void
5011,237590,spublishCommand,1,spublishCommand,void spublishCommand (client*),pubsub.c,"void spublishCommand(client *c) {
    int receivers = pubsubPublishMessageAndPropagateToCluster(c->argv[1],c->argv[2],1);
    if (!server.cluster_enabled)
        forceCommandPropagation(c,PROPAGATE_REPL);
    addReplyLongLong(c,receivers);
}",703.0,708.0,1.0,34.0,6.0,7,5,7,3,0,5,2,2,0,3,,0,3,2,1,1,void
5012,237624,ssubscribeCommand,1,ssubscribeCommand,void ssubscribeCommand (client*),pubsub.c,"void ssubscribeCommand(client *c) {
    if (c->flags & CLIENT_DENY_BLOCKING) {
        /* A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe. */
        addReplyError(c, ""SSUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }

    for (int j = 1; j < c->argc; j++) {
        /* A channel is only considered to be added, if a
         * subscriber exists for it. And if a subscriber
         * already exists the slotToChannel doesn't needs
         * to be incremented. */
        if (server.cluster_enabled &
            (dictFind(*pubSubShardType.serverPubSubChannels, c->argv[j]) == NULL)) {
            slotToChannelAdd(c->argv[j]->ptr);
        }
        pubsubSubscribeChannel(c, c->argv[j], pubSubShardType);
    }
    c->flags |= CLIENT_PUBSUB;
}",711.0,731.0,1.0,19.0,21.0,20,9,17,5,0,13,4,5,6,4,,0,10,2,1,1,void
5013,237701,sunsubscribeCommand,1,sunsubscribeCommand,void sunsubscribeCommand (client*),pubsub.c,"void sunsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeShardAllChannels(c, 1);
    } else {
        for (int j = 1; j < c->argc; j++) {
            pubsubUnsubscribeChannel(c, c->argv[j], 1, pubSubShardType);
        }
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",735.0,744.0,1.0,65.0,10.0,6,4,4,1,0,4,3,3,2,2,,0,3,2,1,1,void
5014,237757,pubsubMemOverhead,1,pubsubMemOverhead,size_t pubsubMemOverhead (client*),pubsub.c,"size_t pubsubMemOverhead(client *c) {
    /* PubSub patterns */
    size_t mem = dictMemUsage(c->pubsub_patterns);
    /* Global PubSub channels */
    mem += dictMemUsage(c->pubsub_channels);
    /* Sharded PubSub channels */
    mem += dictMemUsage(c->pubsubshard_channels);
    return mem;
}",746.0,754.0,1.0,1.0,9.0,6,3,7,2,1,6,1,1,0,3,,0,4,2,1,1,size_t
5015,237831,quicklistisSetPackedThreshold,1,quicklistisSetPackedThreshold,int quicklistisSetPackedThreshold (size_t),quicklist.c,"int quicklistisSetPackedThreshold(size_t sz) {
    /* Don't allow threshold to be set above or even slightly below 4GB */
    if (sz > (1ull<<32) - (1<<20)) {
        return 0;
    } else if (sz == 0) { /* 0 means restore threshold */
        sz = (1 << 30);
    }
    packed_threshold = sz;
    return 1;
}",57.0,66.0,1.0,1.0,10.0,5,4,3,2,0,1,2,2,0,0,,0,1,2,1,1,int
5016,237866,_quicklistBookmarkFindByName,1,_quicklistBookmarkFindByName,"quicklistBookmark* _quicklistBookmarkFindByName (quicklist*,char*)",quicklist.c,"quicklistBookmark *_quicklistBookmarkFindByName(quicklist *ql, const char *name) {
    unsigned i;
    for (i=0; i<ql->bookmark_count; i++) {
        if (!strcmp(ql->bookmarks[i].name, name)) {
            return &ql->bookmarks[i];
        }
    }
    return NULL;
}",1698.0,1706.0,1.0,1.0,9.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,quicklistBookmark
5017,237872,_quicklistBookmarkFindByNode,1,_quicklistBookmarkFindByNode,"quicklistBookmark* _quicklistBookmarkFindByNode (quicklist*,quicklistNode*)",quicklist.c,"quicklistBookmark *_quicklistBookmarkFindByNode(quicklist *ql, quicklistNode *node) {
    unsigned i;
    for (i=0; i<ql->bookmark_count; i++) {
        if (ql->bookmarks[i].node == node) {
            return &ql->bookmarks[i];
        }
    }
    return NULL;
}",1708.0,1716.0,1.0,1.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,quicklistBookmark
5018,237878,_quicklistBookmarkDelete,1,_quicklistBookmarkDelete,"void _quicklistBookmarkDelete (quicklist*,quicklistBookmark*)",quicklist.c,"void _quicklistBookmarkDelete(quicklist *ql, quicklistBookmark *bm) {
    int index = bm - ql->bookmarks;
    zfree(bm->name);
    ql->bookmark_count--;
    memmove(bm, bm+1, (ql->bookmark_count - index)* sizeof(*bm));
    /* NOTE: We do not shrink (realloc) the quicklist yet (to avoid resonance,
     * it may be re-used later (a call to realloc may NOP). */
}",1718.0,1725.0,1.0,1.0,8.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,void
5019,237884,quicklistCreate,1,quicklistCreate,quicklist quicklistCreate (void),quicklist.c,"quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    quicklist = zmalloc(sizeof(*quicklist));
    quicklist->head = quicklist->tail = NULL;
    quicklist->len = 0;
    quicklist->count = 0;
    quicklist->compress = 0;
    quicklist->fill = -2;
    quicklist->bookmark_count = 0;
    return quicklist;
}",128.0,139.0,1.0,1.0,12.0,18,5,11,2,3,8,1,1,0,1,,0,8,2,1,1,quicklist
5020,237933,quicklistSetCompressDepth,1,quicklistSetCompressDepth,"void quicklistSetCompressDepth (quicklist*,int)",quicklist.c,"void quicklistSetCompressDepth(quicklist *quicklist, int compress) {
    if (compress > COMPRESS_MAX) {
        compress = COMPRESS_MAX;
    } else if (compress < 0) {
        compress = 0;
    }
    quicklist->compress = compress;
}",142.0,149.0,1.0,19.0,8.0,8,5,6,3,1,1,2,2,0,0,,0,1,4,2,2,void
5021,237974,quicklistSetFill,1,quicklistSetFill,"void quicklistSetFill (quicklist*,int)",quicklist.c,"void quicklistSetFill(quicklist *quicklist, int fill) {
    if (fill > FILL_MAX) {
        fill = FILL_MAX;
    } else if (fill < -5) {
        fill = -5;
    }
    quicklist->fill = fill;
}",152.0,159.0,1.0,15.0,8.0,10,5,6,3,1,1,2,2,0,0,,0,1,4,2,2,void
5022,238021,quicklistSetOptions,1,quicklistSetOptions,"void quicklistSetOptions (quicklist*,int,int)",quicklist.c,"void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
    quicklistSetFill(quicklist, fill);
    quicklistSetCompressDepth(quicklist, depth);
}",161.0,164.0,1.0,1.0,4.0,0,0,4,3,2,2,1,1,0,2,,0,0,6,3,3,void
5023,238034,quicklistNew,1,quicklistNew,"quicklist quicklistNew (int,int)",quicklist.c,"quicklist *quicklistNew(int fill, int compress) {
    quicklist *quicklist = quicklistCreate();
    quicklistSetOptions(quicklist, fill, compress);
    return quicklist;
}",167.0,171.0,1.0,1.0,5.0,1,1,5,3,1,2,1,1,0,2,,0,1,4,2,2,quicklist
5024,238050,quicklistCreateNode,1,quicklistCreateNode,quicklistNode quicklistCreateNode (void),quicklist.c,"REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
    quicklistNode *node;
    node = zmalloc(sizeof(*node));
    node->entry = NULL;
    node->count = 0;
    node->sz = 0;
    node->next = node->prev = NULL;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    node->container = QUICKLIST_NODE_CONTAINER_PACKED;
    node->recompress = 0;
    node->dont_compress = 0;
    return node;
}",173.0,185.0,1.0,12.0,13.0,21,4,14,2,6,10,1,1,0,1,,0,10,2,1,1,quicklistNode
5025,238112,quicklistCount,1,quicklistCount,unsigned long quicklistCount (quicklist*),quicklist.c,unsigned long quicklistCount(const quicklist *ql) { return ql->count; },188.0,188.0,1.0,71.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned long
5026,238121,quicklistRelease,1,quicklistRelease,void quicklistRelease (quicklist*),quicklist.c,"void quicklistRelease(quicklist *quicklist) {
    unsigned long len;
    quicklistNode *current, *next;

    current = quicklist->head;
    len = quicklist->len;
    while (len--) {
        next = current->next;

        zfree(current->entry);
        quicklist->count -= current->count;

        zfree(current);

        quicklist->len--;
        current = next;
    }
    quicklistBookmarksClear(quicklist);
    zfree(quicklist);
}",191.0,210.0,1.0,1.0,20.0,14,4,16,4,2,11,2,2,0,4,,0,7,2,1,1,void
5027,238172,__quicklistCompressNode,1,__quicklistCompressNode,int __quicklistCompressNode (quicklistNode*),quicklist.c,"REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
#ifdef REDIS_TEST
    node->attempted_compress = 1;
#endif
    if (node->dont_compress) return 0;

    /* validate that the node is neither
     * tail nor head (it has prev and next)*/
    assert(node->prev && node->next);

    node->recompress = 0;
    /* Don't bother compressing small values */
    if (node->sz < MIN_COMPRESS_BYTES)
        return 0;

    quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);

    /* Cancel if compression fails or doesn't compress small enough */
    if (((lzf->sz = lzf_compress(node->entry, node->sz, lzf->compressed,
                                 node->sz)) == 0) ||
        lzf->sz + MIN_COMPRESS_IMPROVE >= node->sz) {
        /* lzf_compress aborts/rejects compression if value not compressible. */
        zfree(lzf);
        return 0;
    }
    lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
    zfree(node->entry);
    node->entry = (unsigned char *)lzf;
    node->encoding = QUICKLI...",215.0,245.0,1.0,12.0,31.0,40,14,24,2,10,23,4,4,10,6,,0,20,2,1,1,int
5028,238299,__quicklistDecompressNode,1,__quicklistDecompressNode,int __quicklistDecompressNode (quicklistNode*),quicklist.c,"REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
#ifdef REDIS_TEST
    node->attempted_compress = 0;
#endif
    node->recompress = 0;

    void *decompressed = zmalloc(node->sz);
    quicklistLZF *lzf = (quicklistLZF *)node->entry;
    if (lzf_decompress(lzf->compressed, lzf->sz, decompressed, node->sz) == 0) {
        /* Someone requested decompress, but we can't decompress.  Not good. */
        zfree(decompressed);
        return 0;
    }
    zfree(lzf);
    node->entry = decompressed;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    return 1;
}",257.0,274.0,1.0,12.0,18.0,15,4,14,3,7,12,2,2,4,4,,0,10,2,1,1,int
5029,238359,quicklistGetLzf,1,quicklistGetLzf,"size_t quicklistGetLzf (quicklistNode*,void**)",quicklist.c,"size_t quicklistGetLzf(const quicklistNode *node, void **data) {
    quicklistLZF *lzf = (quicklistLZF *)node->entry;
    *data = lzf->compressed;
    return lzf->sz;
}",296.0,300.0,1.0,1.0,5.0,7,4,5,3,0,3,1,1,0,0,,0,3,4,2,2,size_t
5030,238383,__quicklistCompress,1,__quicklistCompress,"void __quicklistCompress (quicklist*,quicklistNode*)",quicklist.c,"REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
                                      quicklistNode *node) {
    if (quicklist->len == 0) return;

    /* The head and tail should never be compressed (we should not attempt to recompress them) */
    assert(quicklist->head->recompress == 0 && quicklist->tail->recompress == 0);

    /* If length is less than our compress depth (from both sides),
     * we can't compress anything. */
    if (!quicklistAllowsCompression(quicklist) ||
        quicklist->len < (unsigned int)(quicklist->compress * 2))
        return;

#if 0
    /* Optimized cases for small depth counts */
    if (quicklist->compress == 1) {
        quicklistNode *h = quicklist->head, *t = quicklist->tail;
        quicklistDecompressNode(h);
        quicklistDecompressNode(t);
        if (h != node && t != node)
            quicklistCompressNode(node);
        return;
    } else if (quicklist->compress == 2) {
        quicklistNode *h = quicklist->head, *hn...",308.0,379.0,1.0,12.0,72.0,59,14,49,6,6,23,7,9,6,6,,0,17,4,2,2,void
5031,238600,__quicklistInsertNode,1,__quicklistInsertNode,"void __quicklistInsertNode (quicklist*,quicklistNode*,quicklistNode*,int)",quicklist.c,"REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    if (after) {
        new_node->prev = old_node;
        if (old_node) {
            new_node->next = old_node->next;
            if (old_node->next)
                old_node->next->prev = new_node;
            old_node->next = new_node;
        }
        if (quicklist->tail == old_node)
            quicklist->tail = new_node;
    } else {
        new_node->next = old_node;
        if (old_node) {
            new_node->prev = old_node->prev;
            if (old_node->prev)
                old_node->prev->next = new_node;
            old_node->prev = new_node;
        }
        if (quicklist->head == old_node)
            quicklist->head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail. */
    if (quicklist->len == 0) {
        quickli...",400.0,436.0,1.0,12.0,37.0,31,5,37,4,4,20,7,11,3,4,,0,16,8,4,4,void
5032,238786,_quicklistInsertNodeBefore,1,_quicklistInsertNodeBefore,"void _quicklistInsertNodeBefore (quicklist*,quicklistNode*,quicklistNode*)",quicklist.c,"REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 0);
}",439.0,443.0,1.0,12.0,5.0,0,0,3,3,0,1,1,1,0,1,,0,0,6,3,3,void
5033,238798,_quicklistInsertNodeAfter,1,_quicklistInsertNodeAfter,"void _quicklistInsertNodeAfter (quicklist*,quicklistNode*,quicklistNode*)",quicklist.c,"REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                            quicklistNode *old_node,
                                            quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 1);
}",445.0,449.0,1.0,12.0,5.0,0,0,3,3,3,1,1,1,0,1,,0,0,6,3,3,void
5034,238810,quicklistNodeLimit,1,quicklistNodeLimit,"void quicklistNodeLimit (int,size_t*,unsigned int*)",quicklist.c,"void quicklistNodeLimit(int fill, size_t *size, unsigned int *count) {
    *size = SIZE_MAX;
    *count = UINT_MAX;

    if (fill >= 0) {
        /* Ensure that one node have at least one entry */
        *count = (fill == 0) ? 1 : fill;
    } else {
        size_t offset = (-fill) - 1;
        size_t max_level = sizeof(optimization_level) / sizeof(*optimization_level);
        if (offset >= max_level) offset = max_level - 1;
        *size = optimization_level[offset];
    }
}",455.0,468.0,1.0,1.0,14.0,9,5,8,5,2,0,2,2,0,0,,0,0,6,3,3,void
5035,238873,quicklistNodeExceedsLimit,1,quicklistNodeExceedsLimit,"int quicklistNodeExceedsLimit (int,size_t,unsigned int)",quicklist.c,"int quicklistNodeExceedsLimit(int fill, size_t new_sz, unsigned int new_count) {
    size_t sz_limit;
    unsigned int count_limit;
    quicklistNodeLimit(fill, &sz_limit, &count_limit);

    if (likely(sz_limit != SIZE_MAX)) {
        return new_sz > sz_limit;
    } else if (count_limit != UINT_MAX) {
        /* when we reach here we know that the limit is a size limit (which is
         * safe, see comments next to optimization_level and SIZE_SAFETY_LIMIT) */
        if (!sizeMeetsSafetyLimit(new_sz)) return 1;
        return new_count > count_limit;
    }

    redis_unreachable();
}",474.0,489.0,1.0,8.0,16.0,4,3,7,5,3,1,2,2,0,1,,0,0,6,3,3,int
5036,238924,_quicklistNodeAllowInsert,1,_quicklistNodeAllowInsert,"int _quicklistNodeAllowInsert (quicklistNode*,int,size_t)",quicklist.c,"REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
                                           const int fill, const size_t sz) {
    if (unlikely(!node))
        return 0;

    if (unlikely(QL_NODE_IS_PLAIN(node) || isLargeElement(sz)))
        return 0;

    /* Estimate how many bytes will be added to the listpack by this one entry.
     * We prefer an overestimation, which would at worse lead to a few bytes
     * below the lowest limit of 4k (see optimization_level).
     * Note: No need to check for overflow below since both `node->sz` and
     * `sz` are to be less than 1GB after the plain/large element check above. */
    size_t new_sz = node->sz + sz + SIZE_ESTIMATE_OVERHEAD;
    if (unlikely(quicklistNodeExceedsLimit(fill, new_sz, node->count + 1)))
        return 0;
    return 1;
}",491.0,508.0,1.0,12.0,18.0,12,7,11,5,5,5,4,4,4,1,,0,5,6,3,3,int
5037,238984,_quicklistNodeAllowMerge,1,_quicklistNodeAllowMerge,"int _quicklistNodeAllowMerge (quicklistNode*,quicklistNode*,int)",quicklist.c,"REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,
                                          const quicklistNode *b,
                                          const int fill) {
    if (!a || !b)
        return 0;

    if (unlikely(QL_NODE_IS_PLAIN(a) || QL_NODE_IS_PLAIN(b)))
        return 0;

    /* approximate merged listpack size (- 7 to remove one listpack
     * header/trailer, see LP_HDR_SIZE and LP_EOF) */
    unsigned int merge_sz = a->sz + b->sz - 7;
    if (unlikely(quicklistNodeExceedsLimit(fill, merge_sz, a->count + b->count)))
        return 0;
    return 1;
}",510.0,525.0,1.0,12.0,16.0,16,7,11,4,4,7,4,4,5,1,,0,7,6,3,3,int
5038,239047,__quicklistCreatePlainNode,1,__quicklistCreatePlainNode,"quicklistNode __quicklistCreatePlainNode (void*,size_t)",quicklist.c,"static quicklistNode* __quicklistCreatePlainNode(void *value, size_t sz) {
    quicklistNode *new_node = quicklistCreateNode();
    new_node->entry = zmalloc(sz);
    new_node->container = QUICKLIST_NODE_CONTAINER_PLAIN;
    memcpy(new_node->entry, value, sz);
    new_node->sz = sz;
    new_node->count++;
    return new_node;
}",532.0,540.0,1.0,26.0,9.0,10,3,11,3,1,7,1,1,0,2,,0,7,4,2,2,quicklistNode
5039,239087,__quicklistInsertPlainNode,1,__quicklistInsertPlainNode,"void __quicklistInsertPlainNode (quicklist*,quicklistNode*,void*,size_t,int)",quicklist.c,"static void __quicklistInsertPlainNode(quicklist *quicklist, quicklistNode *old_node,
                                       void *value, size_t sz, int after) {
    __quicklistInsertNode(quicklist, old_node, __quicklistCreatePlainNode(value, sz), after);
    quicklist->count++;
}",542.0,546.0,1.0,1.0,5.0,2,2,6,5,4,3,1,1,0,2,,0,2,10,5,5,void
5040,239107,quicklistPushHead,1,quicklistPushHead,"int quicklistPushHead (quicklist*,void*,size_t)",quicklist.c,"int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist->head;

    if (unlikely(isLargeElement(sz))) {
        __quicklistInsertPlainNode(quicklist, quicklist->head, value, sz, 0);
        return 1;
    }

    if (likely(
            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
        quicklist->head->entry = lpPrepend(quicklist->head->entry, value, sz);
        quicklistNodeUpdateSz(quicklist->head);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->entry = lpPrepend(lpNew(0), value, sz);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
    }
    quicklist->count++;
    quicklist->head->count++;
    return (orig_head != quicklist->head);
}",552.0,574.0,1.0,8.0,23.0,24,5,22,5,2,17,3,3,4,4,,0,16,6,3,3,int
5041,239234,quicklistPushTail,1,quicklistPushTail,"int quicklistPushTail (quicklist*,void*,size_t)",quicklist.c,"int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist->tail;
    if (unlikely(isLargeElement(sz))) {
        __quicklistInsertPlainNode(quicklist, quicklist->tail, value, sz, 1);
        return 1;
    }

    if (likely(
            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {
        quicklist->tail->entry = lpAppend(quicklist->tail->entry, value, sz);
        quicklistNodeUpdateSz(quicklist->tail);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->entry = lpAppend(lpNew(0), value, sz);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    }
    quicklist->count++;
    quicklist->tail->count++;
    return (orig_tail != quicklist->tail);
}",580.0,601.0,1.0,8.0,22.0,24,5,22,5,1,17,3,3,4,4,,0,16,6,3,3,int
5042,239361,quicklistAppendListpack,1,quicklistAppendListpack,"void quicklistAppendListpack (quicklist*,unsigned char*)",quicklist.c,"void quicklistAppendListpack(quicklist *quicklist, unsigned char *zl) {
    quicklistNode *node = quicklistCreateNode();

    node->entry = zl;
    node->count = lpLength(node->entry);
    node->sz = lpBytes(zl);

    _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    quicklist->count += node->count;
}",606.0,615.0,1.0,1.0,10.0,12,3,12,3,1,11,1,1,0,4,,0,10,4,2,2,void
5043,239403,quicklistAppendPlainNode,1,quicklistAppendPlainNode,"void quicklistAppendPlainNode (quicklist*,unsigned char*,size_t)",quicklist.c,"void quicklistAppendPlainNode(quicklist *quicklist, unsigned char *data, size_t sz) {
    quicklistNode *node = quicklistCreateNode();

    node->entry = data;
    node->count = 1;
    node->sz = sz;
    node->container = QUICKLIST_NODE_CONTAINER_PLAIN;

    _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    quicklist->count += node->count;
}",621.0,631.0,1.0,22.0,11.0,13,3,12,4,0,9,1,1,0,2,,0,8,6,3,3,void
5044,239449,__quicklistDelNode,1,__quicklistDelNode,"void __quicklistDelNode (quicklist*,quicklistNode*)",quicklist.c,"REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
                                     quicklistNode *node) {
    /* Update the bookmark if any */
    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);
    if (bm) {
        bm->node = node->next;
        /* if the bookmark was to the last node, delete it. */
        if (!bm->node)
            _quicklistBookmarkDelete(quicklist, bm);
    }

    if (node->next)
        node->next->prev = node->prev;
    if (node->prev)
        node->prev->next = node->next;

    if (node == quicklist->tail) {
        quicklist->tail = node->prev;
    }

    if (node == quicklist->head) {
        quicklist->head = node->next;
    }

    /* Update len first, so in __quicklistCompress we know exactly len */
    quicklist->len--;
    quicklist->count -= node->count;

    /* If we deleted a node within our compress depth, we
     * now have compressed nodes needing to be decompressed. */
    __quicklistCompress(quicklist, NULL)...",641.0,675.0,1.0,12.0,35.0,32,6,30,4,4,24,7,8,5,5,,0,20,4,2,2,void
5045,239556,quicklistDelIndex,1,quicklistDelIndex,"int quicklistDelIndex (quicklist*,quicklistNode*,unsigned char**)",quicklist.c,"REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
                                   unsigned char **p) {
    int gone = 0;

    if (unlikely(QL_NODE_IS_PLAIN(node))) {
        __quicklistDelNode(quicklist, node);
        return 1;
    }
    node->entry = lpDelete(node->entry, *p, p);
    node->count--;
    if (node->count == 0) {
        gone = 1;
        __quicklistDelNode(quicklist, node);
    } else {
        quicklistNodeUpdateSz(node);
    }
    quicklist->count--;
    /* If we deleted the node, the original node is no longer valid */
    return gone ? 1 : 0;
}",685.0,704.0,1.0,12.0,20.0,15,6,15,4,4,9,3,3,2,3,,0,7,6,3,3,int
5046,239634,quicklistDelEntry,1,quicklistDelEntry,"void quicklistDelEntry (quicklistIter*,quicklistEntry*)",quicklist.c,"void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
    quicklistNode *prev = entry->node->prev;
    quicklistNode *next = entry->node->next;
    int deleted_node = quicklistDelIndex((quicklist *)entry->quicklist,
                                         entry->node, &entry->zi);

    /* after delete, the zi is now invalid for any future usage. */
    iter->zi = NULL;

    /* If current node is deleted, we must update iterator node and offset. */
    if (deleted_node) {
        if (iter->direction == AL_START_HEAD) {
            iter->current = next;
            iter->offset = 0;
        } else if (iter->direction == AL_START_TAIL) {
            iter->current = prev;
            iter->offset = -1;
        }
    }
    /* else if (!deleted_node), no changes needed.
     * we already reset iter->zi above, and the existing iter->offset
     * doesn't move again because:
     *   - [1, 2, 3] => delete offset 1 => [1, 3]: next element still offset 1
     *   - [1, 2, 3] =...",710.0,737.0,1.0,31.0,28.0,20,5,15,6,0,10,3,4,1,1,,0,10,4,2,2,void
5047,239721,quicklistReplaceEntry,1,quicklistReplaceEntry,"void quicklistReplaceEntry (quicklistIter*,quicklistEntry*,void*,size_t)",quicklist.c,"void quicklistReplaceEntry(quicklistIter *iter, quicklistEntry *entry,
                           void *data, size_t sz)
{
    quicklist* quicklist = iter->quicklist;

    if (likely(!QL_NODE_IS_PLAIN(entry->node) && !isLargeElement(sz))) {
        entry->node->entry = lpReplace(entry->node->entry, &entry->zi, data, sz);
        quicklistNodeUpdateSz(entry->node);
        /* quicklistNext() and quicklistGetIteratorEntryAtIdx() provide an uncompressed node */
        quicklistCompress(quicklist, entry->node);
    } else if (QL_NODE_IS_PLAIN(entry->node)) {
        if (isLargeElement(sz)) {
            zfree(entry->node->entry);
            entry->node->entry = zmalloc(sz);
            entry->node->sz = sz;
            memcpy(entry->node->entry, data, sz);
            quicklistCompress(quicklist, entry->node);
        } else {
            quicklistInsertAfter(iter, entry, data, sz);
            __quicklistDelNode(quicklist, entry->node);
        }
    } else {
        entry->node->don...",740.0,778.0,1.0,8.0,39.0,36,7,26,7,1,21,2,2,2,4,,0,19,8,4,4,void
5048,240110,quicklistReplaceAtIndex,1,quicklistReplaceAtIndex,"int quicklistReplaceAtIndex (quicklist*,long,void*,size_t)",quicklist.c,"int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,
                            size_t sz) {
    quicklistEntry entry;
    quicklistIter *iter = quicklistGetIteratorEntryAtIdx(quicklist, index, &entry);
    if (likely(iter)) {
        quicklistReplaceEntry(iter, &entry, data, sz);
        quicklistReleaseIterator(iter);
        return 1;
    } else {
        return 0;
    }
}",784.0,795.0,1.0,8.0,12.0,3,2,11,6,1,3,2,2,0,3,,0,1,8,4,4,int
5049,240147,_quicklistListpackMerge,1,_quicklistListpackMerge,"quicklistNode _quicklistListpackMerge (quicklist*,quicklistNode*,quicklistNode*)",quicklist.c,"REDIS_STATIC quicklistNode *_quicklistListpackMerge(quicklist *quicklist,
                                                    quicklistNode *a,
                                                    quicklistNode *b) {
    D(""Requested merge (a,b) (%u, %u)"", a->count, b->count);

    quicklistDecompressNode(a);
    quicklistDecompressNode(b);
    if ((lpMerge(&a->entry, &b->entry))) {
        /* We merged listpacks! Now remove the unused quicklistNode. */
        quicklistNode *keep = NULL, *nokeep = NULL;
        if (!a->entry) {
            nokeep = a;
            keep = b;
        } else if (!b->entry) {
            nokeep = b;
            keep = a;
        }
        keep->count = lpLength(keep->entry);
        quicklistNodeUpdateSz(keep);

        nokeep->count = 0;
        __quicklistDelNode(quicklist, nokeep);
        quicklistCompress(quicklist, keep);
        return keep;
    } else {
        /* else, the merge returned NULL and nothing changed. */
        return NULL;
    }
}",810.0,838.0,1.0,12.0,29.0,28,6,36,6,4,20,3,4,4,8,,0,15,6,3,3,quicklistNode
5050,240300,_quicklistMergeNodes,1,_quicklistMergeNodes,"void _quicklistMergeNodes (quicklist*,quicklistNode*)",quicklist.c,"REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
                                       quicklistNode *center) {
    int fill = quicklist->fill;
    quicklistNode *prev, *prev_prev, *next, *next_next, *target;
    prev = prev_prev = next = next_next = target = NULL;

    if (center->prev) {
        prev = center->prev;
        if (center->prev->prev)
            prev_prev = center->prev->prev;
    }

    if (center->next) {
        next = center->next;
        if (center->next->next)
            next_next = center->next->next;
    }

    /* Try to merge prev_prev and prev */
    if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {
        _quicklistListpackMerge(quicklist, prev_prev, prev);
        prev_prev = prev = NULL; /* they could have moved, invalidate them. */
    }

    /* Try to merge next and next_next */
    if (_quicklistNodeAllowMerge(next, next_next, fill)) {
        _quicklistListpackMerge(quicklist, next, next_next);
        next = next_next = NULL; /*...",848.0,891.0,1.0,12.0,44.0,33,2,53,9,0,21,9,11,10,8,,0,18,4,2,2,void
5051,240444,_quicklistSplitNode,1,_quicklistSplitNode,"quicklistNode _quicklistSplitNode (quicklistNode*,int,int)",quicklist.c,"REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
                                                int after) {
    size_t zl_sz = node->sz;

    quicklistNode *new_node = quicklistCreateNode();
    new_node->entry = zmalloc(zl_sz);

    /* Copy original listpack so we can split it */
    memcpy(new_node->entry, node->entry, zl_sz);

    /* Need positive offset for calculating extent below. */
    if (offset < 0) offset = node->count + offset;

    /* Ranges to be trimmed: -1 here means ""continue deleting until the list ends"" */
    int orig_start = after ? offset + 1 : 0;
    int orig_extent = after ? -1 : offset;
    int new_start = after ? 0 : offset;
    int new_extent = after ? offset + 1 : -1;

    D(""After %d (%d); ranges: [%d, %d], [%d, %d]"", after, offset, orig_start,
      orig_extent, new_start, new_extent);

    node->entry = lpDeleteRange(node->entry, orig_start, orig_extent);
    node->count = lpLength(node->entry);
    quicklistNodeUpdate...",912.0,944.0,1.0,12.0,33.0,41,6,43,9,0,25,2,2,0,8,,0,25,6,3,3,quicklistNode
5052,240587,_quicklistInsert,1,_quicklistInsert,"void _quicklistInsert (quicklistIter*,quicklistEntry*,void*,size_t,int)",quicklist.c,"REDIS_STATIC void _quicklistInsert(quicklistIter *iter, quicklistEntry *entry,
                                   void *value, const size_t sz, int after)
{
    quicklist *quicklist = iter->quicklist;
    int full = 0, at_tail = 0, at_head = 0, avail_next = 0, avail_prev = 0;
    int fill = quicklist->fill;
    quicklistNode *node = entry->node;
    quicklistNode *new_node = NULL;

    if (!node) {
        /* we have no reference node, so let's create only node in the list */
        D(""No node given!"");
        if (unlikely(isLargeElement(sz))) {
            __quicklistInsertPlainNode(quicklist, quicklist->tail, value, sz, after);
            return;
        }
        new_node = quicklistCreateNode();
        new_node->entry = lpPrepend(lpNew(0), value, sz);
        __quicklistInsertNode(quicklist, NULL, new_node, after);
        new_node->count++;
        quicklist->count++;
        return;
    }

    /* Populate accounting flags for easier boolean checks later */
    if (!_quickl...",950.0,1081.0,1.0,12.0,132.0,82,10,94,16,2,44,11,15,14,13,,0,39,10,5,5,void
5053,241419,quicklistInsertBefore,1,quicklistInsertBefore,"void quicklistInsertBefore (quicklistIter*,quicklistEntry*,void*,size_t)",quicklist.c,"void quicklistInsertBefore(quicklistIter *iter, quicklistEntry *entry,
                           void *value, const size_t sz)
{
    _quicklistInsert(iter, entry, value, sz, 0);
}",1083.0,1087.0,1.0,1.0,5.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
5054,241433,quicklistInsertAfter,1,quicklistInsertAfter,"void quicklistInsertAfter (quicklistIter*,quicklistEntry*,void*,size_t)",quicklist.c,"void quicklistInsertAfter(quicklistIter *iter, quicklistEntry *entry,
                          void *value, const size_t sz)
{
    _quicklistInsert(iter, entry, value, sz, 1);
}",1089.0,1093.0,1.0,1.0,5.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,void
5055,241447,quicklistDelRange,1,quicklistDelRange,"int quicklistDelRange (quicklist*,long,long)",quicklist.c,"int quicklistDelRange(quicklist *quicklist, const long start,
                      const long count) {
    if (count <= 0)
        return 0;

    unsigned long extent = count; /* range is inclusive of start position */

    if (start >= 0 && extent > (quicklist->count - start)) {
        /* if requesting delete more elements than exist, limit to list size. */
        extent = quicklist->count - start;
    } else if (start < 0 && extent > (unsigned long)(-start)) {
        /* else, if at negative offset, limit max size to rest of list. */
        extent = -start; /* c.f. LREM -29 29; just delete until end. */
    }

    quicklistIter *iter = quicklistGetIteratorAtIdx(quicklist, AL_START_TAIL, start);
    if (!iter)
        return 0;

    D(""Quicklist delete request for start %ld, count %ld, extent: %ld"", start,
      count, extent);
    quicklistNode *node = iter->current;
    long offset = iter->offset;
    quicklistReleaseIterator(iter);

    /* iterate over next nodes until every...",1101.0,1184.0,1.0,63.0,84.0,32,11,39,10,0,11,7,9,3,3,,0,9,6,3,3,int
5056,241743,quicklistCompare,1,quicklistCompare,"int quicklistCompare (quicklistEntry*,unsigned char*,size_t)",quicklist.c,"int quicklistCompare(quicklistEntry* entry, unsigned char *p2, const size_t p2_len) {
    if (unlikely(QL_NODE_IS_PLAIN(entry->node))) {
        return ((entry->sz == p2_len) && (memcmp(entry->value, p2, p2_len) == 0));
    }
    return lpCompare(entry->zi, p2, p2_len);
}",1187.0,1192.0,1.0,8.0,6.0,9,3,9,3,0,5,2,2,1,1,,0,4,6,3,3,int
5057,241783,quicklistGetIterator,1,quicklistGetIterator,"quicklistIter quicklistGetIterator (quicklist*,int)",quicklist.c,"quicklistIter *quicklistGetIterator(quicklist *quicklist, int direction) {
    quicklistIter *iter;

    iter = zmalloc(sizeof(*iter));

    if (direction == AL_START_HEAD) {
        iter->current = quicklist->head;
        iter->offset = 0;
    } else if (direction == AL_START_TAIL) {
        iter->current = quicklist->tail;
        iter->offset = -1;
    }

    iter->direction = direction;
    iter->quicklist = quicklist;

    iter->zi = NULL;

    return iter;
}",1196.0,1215.0,1.0,21.0,20.0,15,5,13,4,1,7,2,2,0,1,,0,7,4,2,2,quicklistIter
5058,241854,quicklistGetIteratorAtIdx,1,quicklistGetIteratorAtIdx,"quicklistIter quicklistGetIteratorAtIdx (quicklist*,int,long long)",quicklist.c,"quicklistIter *quicklistGetIteratorAtIdx(quicklist *quicklist,
                                         const int direction,
                                         const long long idx)
{
    quicklistNode *n;
    unsigned long long accum = 0;
    unsigned long long index;
    int forward = idx < 0 ? 0 : 1; /* < 0 -> reverse, 0+ -> forward */

    index = forward ? idx : (-idx) - 1;
    if (index >= quicklist->count)
        return NULL;

    /* Seek in the other direction if that way is shorter. */
    int seek_forward = forward;
    unsigned long long seek_index = index;
    if (index > (quicklist->count - 1) / 2) {
        seek_forward = !forward;
        seek_index = quicklist->count - 1 - index;
    }

    n = seek_forward ? quicklist->head : quicklist->tail;
    while (likely(n)) {
        if ((accum + n->count) > seek_index) {
            break;
        } else {
            D(""Skipping over (%p) %u at accum %lld"", (void *)n, n->count,
              accum);
            accum ...",1219.0,1273.0,1.0,11.0,55.0,42,12,48,11,3,11,9,9,3,1,,0,11,6,3,3,quicklistIter
5059,242026,quicklistReleaseIterator,1,quicklistReleaseIterator,void quicklistReleaseIterator (quicklistIter*),quicklist.c,"void quicklistReleaseIterator(quicklistIter *iter) {
    if (!iter) return;
    if (iter->current)
        quicklistCompress(iter->quicklist, iter->current);

    zfree(iter);
}",1277.0,1283.0,1.0,8.0,7.0,14,4,11,1,3,12,3,3,1,3,,0,9,2,1,1,void
5060,242090,quicklistNext,1,quicklistNext,"int quicklistNext (quicklistIter*,quicklistEntry*)",quicklist.c,"int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
    initEntry(entry);

    if (!iter) {
        D(""Returning because no iter!"");
        return 0;
    }

    entry->quicklist = iter->quicklist;
    entry->node = iter->current;

    if (!iter->current) {
        D(""Returning because current node is NULL"");
        return 0;
    }

    unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;
    int offset_update = 0;

    int plain = QL_NODE_IS_PLAIN(iter->current);
    if (!iter->zi) {
        /* If !zi, use current index. */
        quicklistDecompressNodeForUse(iter->current);
        if (unlikely(plain))
            iter->zi = iter->current->entry;
        else
            iter->zi = lpSeek(iter->current->entry, iter->offset);
    } else if (unlikely(plain)) {
        iter->zi = NULL;
    } else {
        /* else, use existing iterator offset and get prev/next as necessary. */
        if (iter->direction == AL_START_HEAD) {
            nextFn = lpNext;
 ...",1306.0,1380.0,1.0,4.0,75.0,70,7,49,6,2,37,7,9,3,2,,0,36,4,2,2,int
5061,242163,nextFn,1,quicklistNext.nextFn,"unsigned char* quicklistNext.nextFn (unsigned char*,unsigned char*)",quicklist.c,"unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;",1322.0,1322.0,19.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,unsigned char*
5062,242501,quicklistSetDirection,1,quicklistSetDirection,"void quicklistSetDirection (quicklistIter*,int)",quicklist.c,"void quicklistSetDirection(quicklistIter *iter, int direction) {
    iter->direction = direction;
}",1383.0,1385.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
5063,242512,quicklistDup,1,quicklistDup,quicklist quicklistDup (quicklist*),quicklist.c,"quicklist *quicklistDup(quicklist *orig) {
    quicklist *copy;

    copy = quicklistNew(orig->fill, orig->compress);

    for (quicklistNode *current = orig->head; current;
         current = current->next) {
        quicklistNode *node = quicklistCreateNode();

        if (current->encoding == QUICKLIST_NODE_ENCODING_LZF) {
            quicklistLZF *lzf = (quicklistLZF *)current->entry;
            size_t lzf_sz = sizeof(*lzf) + lzf->sz;
            node->entry = zmalloc(lzf_sz);
            memcpy(node->entry, current->entry, lzf_sz);
        } else if (current->encoding == QUICKLIST_NODE_ENCODING_RAW) {
            node->entry = zmalloc(current->sz);
            memcpy(node->entry, current->entry, current->sz);
        }

        node->count = current->count;
        copy->count += node->count;
        node->sz = current->sz;
        node->encoding = current->encoding;
        node->container = current->container;

        _quicklistInsertNodeAfter(copy, copy->tail, node);
    }...",1393.0,1423.0,1.0,33.0,31.0,36,8,32,6,0,17,3,4,0,4,,0,16,2,1,1,quicklist
5064,242659,quicklistGetIteratorEntryAtIdx,1,quicklistGetIteratorEntryAtIdx,"quicklistIter quicklistGetIteratorEntryAtIdx (quicklist*,long long,quicklistEntry*)",quicklist.c,"quicklistIter *quicklistGetIteratorEntryAtIdx(quicklist *quicklist, const long long idx,
                                              quicklistEntry *entry)
{
    quicklistIter *iter = quicklistGetIteratorAtIdx(quicklist, AL_START_TAIL, idx);
    if (!iter) return NULL;
    assert(quicklistNext(iter, entry));
    return iter;
}",1433.0,1440.0,1.0,63.0,8.0,6,6,8,5,1,3,2,2,0,3,,0,1,6,3,3,quicklistIter
5065,242699,quicklistRotatePlain,1,quicklistRotatePlain,void quicklistRotatePlain (quicklist*),quicklist.c,"static void quicklistRotatePlain(quicklist *quicklist) {
    quicklistNode *new_head = quicklist->tail;
    quicklistNode *new_tail = quicklist->tail->prev;
    quicklist->head->prev = new_head;
    new_tail->next = NULL;
    new_head->next = quicklist->head;
    new_head->prev = NULL;
    quicklist->head = new_head;
    quicklist->tail = new_tail;
}",1442.0,1451.0,1.0,1.0,10.0,19,2,16,4,1,9,1,1,0,0,,0,9,2,1,1,void
5066,242752,quicklistRotate,1,quicklistRotate,void quicklistRotate (quicklist*),quicklist.c,"void quicklistRotate(quicklist *quicklist) {
    if (quicklist->count <= 1)
        return;

    if (unlikely(QL_NODE_IS_PLAIN(quicklist->tail))) {
        quicklistRotatePlain(quicklist);
        return;
    }

    /* First, get the tail entry */
    unsigned char *p = lpSeek(quicklist->tail->entry, -1);
    unsigned char *value, *tmp;
    long long longval;
    unsigned int sz;
    char longstr[32] = {0};
    tmp = lpGetValue(p, &sz, &longval);

    /* If value found is NULL, then lpGet populated longval instead */
    if (!tmp) {
        /* Write the longval as a string so we can re-add it */
        sz = ll2string(longstr, sizeof(longstr), longval);
        value = (unsigned char *)longstr;
    } else if (quicklist->len == 1) {
        /* Copy buffer since there could be a memory overlap when move
         * entity from tail to head in the same listpack. */
        value = zmalloc(sz);
        memcpy(value, tmp, sz);
    } else {
        value = tmp;
    }

    /* Add tail entry...",1454.0,1499.0,1.0,8.0,46.0,31,12,31,7,0,14,6,6,3,8,,0,10,2,1,1,void
5067,242886,quicklistPopCustom,1,quicklistPopCustom,"int quicklistPopCustom (quicklist*,int,unsigned char**,size_t*,long long*,void*)",quicklist.c,"int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
                       size_t *sz, long long *sval,
                       void *(*saver)(unsigned char *data, size_t sz)) {
    unsigned char *p;
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;

    if (quicklist->count == 0)
        return 0;

    if (data)
        *data = NULL;
    if (sz)
        *sz = 0;
    if (sval)
        *sval = -123456789;

    quicklistNode *node;
    if (where == QUICKLIST_HEAD && quicklist->head) {
        node = quicklist->head;
    } else if (where == QUICKLIST_TAIL && quicklist->tail) {
        node = quicklist->tail;
    } else {
        return 0;
    }

    /* The head and tail should never be compressed */
    assert(node->encoding != QUICKLIST_NODE_ENCODING_LZF);

    if (unlikely(QL_NODE_IS_PLAIN(node))) {
        if (data)
            *data = saver(node->entry, node->sz);
        if (sz)
         ...",1510.0,1565.0,1.0,24.0,56.0,43,12,44,12,1,14,12,16,3,5,,0,11,12,6,6,int
5068,243095,_quicklistSaver,1,_quicklistSaver,"void* _quicklistSaver (unsigned char*,size_t)",quicklist.c,"REDIS_STATIC void *_quicklistSaver(unsigned char *data, size_t sz) {
    unsigned char *vstr;
    if (data) {
        vstr = zmalloc(sz);
        memcpy(vstr, data, sz);
        return vstr;
    }
    return NULL;
}",1568.0,1576.0,1.0,12.0,9.0,1,1,8,4,0,1,2,2,0,1,,0,1,4,2,2,void*
5069,243117,quicklistPop,1,quicklistPop,"int quicklistPop (quicklist*,int,unsigned char**,size_t*,long long*)",quicklist.c,"int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
                 size_t *sz, long long *slong) {
    unsigned char *vstr = NULL;
    size_t vlen = 0;
    long long vlong = 0;
    if (quicklist->count == 0)
        return 0;
    int ret = quicklistPopCustom(quicklist, where, &vstr, &vlen, &vlong,
                                 _quicklistSaver);
    if (data)
        *data = vstr;
    if (slong)
        *slong = vlong;
    if (sz)
        *sz = vlen;
    return ret;
}",1581.0,1597.0,1.0,1.0,17.0,15,5,21,10,0,2,5,5,1,1,,0,2,10,5,5,int
5070,243183,quicklistPush,1,quicklistPush,"void quicklistPush (quicklist*,void*,size_t,int)",quicklist.c,"void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                   int where) {
    /* The head and tail should never be compressed (we don't attempt to decompress them) */
    if (quicklist->head)
        assert(quicklist->head->encoding != QUICKLIST_NODE_ENCODING_LZF);
    if (quicklist->tail)
        assert(quicklist->tail->encoding != QUICKLIST_NODE_ENCODING_LZF);

    if (where == QUICKLIST_HEAD) {
        quicklistPushHead(quicklist, value, sz);
    } else if (where == QUICKLIST_TAIL) {
        quicklistPushTail(quicklist, value, sz);
    }
}",1600.0,1613.0,1.0,8.0,14.0,17,7,8,4,0,7,4,4,2,3,,0,4,8,4,4,void
5071,243266,quicklistRepr,1,quicklistRepr,"void quicklistRepr (unsigned char*,int)",quicklist.c,"void quicklistRepr(unsigned char *ql, int full) {
    int i = 0;
    quicklist *quicklist  = (struct quicklist*) ql;
    printf(""{count : %ld}\n"", quicklist->count);
    printf(""{len : %ld}\n"", quicklist->len);
    printf(""{fill : %d}\n"", quicklist->fill);
    printf(""{compress : %d}\n"", quicklist->compress);
    printf(""{bookmark_count : %d}\n"", quicklist->bookmark_count);
    quicklistNode* node = quicklist->head;

    while(node != NULL) {
        printf(""{quicklist node(%d)\n"", i++);
        printf(""{container : %s, encoding: %s, size: %zu, count: %d, recompress: %d, attempted_compress: %d}\n"",
               QL_NODE_IS_PLAIN(node) ? ""PLAIN"": ""PACKED"",
               (node->encoding == QUICKLIST_NODE_ENCODING_RAW) ? ""RAW"": ""LZF"",
               node->sz,
               node->count,
               node->recompress,
               node->attempted_compress);

        if (full) {
            quicklistDecompressNode(node);
            if (node->container == QUICKLIST_NODE_CONTAINER_P...",1616.0,1651.0,1.0,15.0,36.0,34,8,34,6,0,21,4,7,1,3,,0,18,4,2,2,void
5072,243443,quicklistBookmarkCreate,1,quicklistBookmarkCreate,"int quicklistBookmarkCreate (quicklist**,char*,quicklistNode*)",quicklist.c,"int quicklistBookmarkCreate(quicklist **ql_ref, const char *name, quicklistNode *node) {
    quicklist *ql = *ql_ref;
    if (ql->bookmark_count >= QL_MAX_BM)
        return 0;
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (bm) {
        bm->node = node;
        return 1;
    }
    ql = zrealloc(ql, sizeof(quicklist) + (ql->bookmark_count+1) * sizeof(quicklistBookmark));
    *ql_ref = ql;
    ql->bookmarks[ql->bookmark_count].node = node;
    ql->bookmarks[ql->bookmark_count].name = zstrdup(name);
    ql->bookmark_count++;
    return 1;
}",1661.0,1676.0,1.0,30.0,16.0,30,12,24,8,0,11,3,3,1,3,,0,11,6,3,3,int
5073,243534,quicklistBookmarkFind,1,quicklistBookmarkFind,"quicklistNode quicklistBookmarkFind (quicklist*,char*)",quicklist.c,"quicklistNode *quicklistBookmarkFind(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm) return NULL;
    return bm->node;
}",1681.0,1685.0,1.0,1.0,5.0,3,3,6,4,0,2,2,2,0,1,,0,2,4,2,2,quicklistNode
5074,243556,quicklistBookmarkDelete,1,quicklistBookmarkDelete,"int quicklistBookmarkDelete (quicklist*,char*)",quicklist.c,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}",1690.0,1696.0,1.0,1.0,7.0,2,2,6,3,0,2,2,2,0,2,,0,1,4,2,2,int
5075,243696,quicklistBookmarksClear,1,quicklistBookmarksClear,void quicklistBookmarksClear (quicklist*),quicklist.c,"void quicklistBookmarksClear(quicklist *ql) {
    while (ql->bookmark_count)
        zfree(ql->bookmarks[--ql->bookmark_count].name);
    /* NOTE: We do not shrink (realloc) the quick list. main use case for this
     * function is just before releasing the allocation. */
}",1727.0,1732.0,1.0,1.0,6.0,1,1,1,1,1,1,2,2,1,0,,0,1,2,1,1,void
5076,244069,next,1,next,void next (void),rand.c,"static void next(void) {
    uint32_t p[2], q[2], r[2], carry0, carry1;

    MUL(a[0], x[0], p);
    ADDEQU(p[0], c, carry0);
    ADDEQU(p[1], carry0, carry1);
    MUL(a[0], x[1], q);
    ADDEQU(p[1], q[0], carry0);
    MUL(a[1], x[0], r);
    x[2] = LOW(carry0 + carry1 + CARRY(p[1], r[0]) + q[1] + r[1] +
            a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
    x[1] = LOW(p[1] + r[0]);
    x[0] = LOW(p[0]);
}",80.0,93.0,1.0,4.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5077,244074,redisLrand48,1,redisLrand48,int32_t redisLrand48 (void),rand.c,"int32_t redisLrand48(void) {
    next();
    return (((int32_t)x[2] << (N - 1)) + (x[1] >> 1));
}",71.0,74.0,1.0,31.0,4.0,7,6,2,1,0,3,1,1,0,1,,0,2,2,1,1,int32_t
5078,244098,redisSrand48,1,redisSrand48,void redisSrand48 (int32_t),rand.c,"void redisSrand48(int32_t seedval) {
    SEED(X0, LOW(seedval), HIGH(seedval));
}",76.0,78.0,1.0,4.0,3.0,36,10,9,4,0,7,1,1,0,0,,0,7,2,1,1,void
5079,244753,raxDebugShowNode,1,raxDebugShowNode,"void raxDebugShowNode (char*,raxNode*)",rax.c,"void raxDebugShowNode(const char *msg, raxNode *n) {
    if (raxDebugMsg == 0) return;
    printf(""%s: %p [%.*s] key:%u size:%u children:"",
        msg, (void*)n, (int)n->size, (char*)n->data, n->iskey, n->size);
    int numcld = n->iscompr ? 1 : n->size;
    raxNode **cldptr = raxNodeLastChildPtr(n) - (numcld-1);
    while(numcld--) {
        raxNode *child;
        memcpy(&child,cldptr,sizeof(child));
        cldptr++;
        printf(""%p "", (void*)child);
    }
    printf(""\n"");
    fflush(stdout);
}",1872.0,1886.0,1.0,23.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5080,244763,raxSetDebugMsg,1,raxSetDebugMsg,void raxSetDebugMsg (int),rax.c,"void raxSetDebugMsg(int onoff) {
    raxDebugMsg = onoff;
}",81.0,83.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
5081,244771,raxStackInit,1,raxStackInit,void raxStackInit (raxStack*),rax.c,"static inline void raxStackInit(raxStack *ts) {
    ts->stack = ts->static_items;
    ts->items = 0;
    ts->maxitems = RAX_STACK_STATIC_ITEMS;
    ts->oom = 0;
}",94.0,99.0,1.0,19.0,6.0,9,2,5,1,2,5,1,1,0,0,,0,5,2,1,1,void
5082,244800,raxStackPush,1,raxStackPush,"int raxStackPush (raxStack*,void*)",rax.c,"static inline int raxStackPush(raxStack *ts, void *ptr) {
    if (ts->items == ts->maxitems) {
        if (ts->stack == ts->static_items) {
            ts->stack = rax_malloc(sizeof(void*)*ts->maxitems*2);
            if (ts->stack == NULL) {
                ts->stack = ts->static_items;
                ts->oom = 1;
                errno = ENOMEM;
                return 0;
            }
            memcpy(ts->stack,ts->static_items,sizeof(void*)*ts->maxitems);
        } else {
            void **newalloc = rax_realloc(ts->stack,sizeof(void*)*ts->maxitems*2);
            if (newalloc == NULL) {
                ts->oom = 1;
                errno = ENOMEM;
                return 0;
            }
            ts->stack = newalloc;
        }
        ts->maxitems *= 2;
    }
    ts->stack[ts->items] = ptr;
    ts->items++;
    return 1;
}",102.0,127.0,1.0,24.0,26.0,33,8,23,6,4,18,4,7,5,1,,0,18,4,2,2,int
5083,244935,raxStackPop,1,raxStackPop,void* raxStackPop (raxStack*),rax.c,"static inline void *raxStackPop(raxStack *ts) {
    if (ts->items == 0) return NULL;
    ts->items--;
    return ts->stack[ts->items];
}",131.0,135.0,1.0,1.0,5.0,7,4,5,2,4,4,2,2,1,0,,0,4,2,1,1,void*
5084,244961,raxStackPeek,1,raxStackPeek,void* raxStackPeek (raxStack*),rax.c,"static inline void *raxStackPeek(raxStack *ts) {
    if (ts->items == 0) return NULL;
    return ts->stack[ts->items-1];
}",139.0,142.0,1.0,1.0,4.0,6,4,4,2,1,3,2,2,1,0,,0,3,2,1,1,void*
5085,244985,raxStackFree,1,raxStackFree,void raxStackFree (raxStack*),rax.c,"static inline void raxStackFree(raxStack *ts) {
    if (ts->stack != ts->static_items) rax_free(ts->stack);
}",145.0,147.0,1.0,39.0,3.0,4,2,3,1,4,4,2,2,2,1,,0,3,2,1,1,void
5086,245005,raxNewNode,1,raxNewNode,"raxNode raxNewNode (size_t,int)",rax.c,"raxNode *raxNewNode(size_t children, int datafield) {
    size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+
                      sizeof(raxNode*)*children;
    if (datafield) nodesize += sizeof(void*);
    raxNode *node = rax_malloc(nodesize);
    if (node == NULL) return NULL;
    node->iskey = 0;
    node->isnull = 0;
    node->iscompr = 0;
    node->size = children;
    return node;
}",188.0,199.0,1.0,47.0,12.0,27,10,24,7,4,5,3,3,0,1,,0,5,4,2,2,raxNode
5087,245084,raxNew,1,raxNew,rax raxNew (void),rax.c,"rax *raxNew(void) {
    rax *rax = rax_malloc(sizeof(*rax));
    if (rax == NULL) return NULL;
    rax->numele = 0;
    rax->numnodes = 1;
    rax->head = raxNewNode(0,0);
    if (rax->head == NULL) {
        rax_free(rax);
        return NULL;
    } else {
        return rax;
    }
}",203.0,215.0,1.0,15.0,13.0,12,5,12,2,16,7,3,3,1,3,,0,6,2,1,1,rax
5088,245139,raxReallocForData,1,raxReallocForData,"raxNode raxReallocForData (raxNode*,void*)",rax.c,"raxNode *raxReallocForData(raxNode *n, void *data) {
    if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */
    size_t curlen = raxNodeCurrentLength(n);
    return rax_realloc(n,curlen+sizeof(void*));
}",219.0,223.0,1.0,20.0,5.0,31,12,21,6,2,7,2,2,0,1,,0,6,4,2,2,raxNode
5089,245215,raxSetData,1,raxSetData,"void raxSetData (raxNode*,void*)",rax.c,"void raxSetData(raxNode *n, void *data) {
    n->iskey = 1;
    if (data != NULL) {
        n->isnull = 0;
        void **ndata = (void**)
            ((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
        memcpy(ndata,&data,sizeof(data));
    } else {
        n->isnull = 1;
    }
}",226.0,236.0,1.0,22.0,11.0,40,14,24,6,6,8,2,2,0,0,,0,8,4,2,2,void
5090,245312,raxGetData,1,raxGetData,void* raxGetData (raxNode*),rax.c,"void *raxGetData(raxNode *n) {
    if (n->isnull) return NULL;
    void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
    void *data;
    memcpy(&data,ndata,sizeof(data));
    return data;
}",239.0,245.0,1.0,36.0,7.0,36,13,23,6,14,7,2,2,1,0,,0,7,2,1,1,void*
5091,245396,raxAddChild,1,raxAddChild,"raxNode raxAddChild (raxNode*,unsigned char,raxNode**,raxNode***)",rax.c,"raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {
    assert(n->iscompr == 0);

    size_t curlen = raxNodeCurrentLength(n);
    n->size++;
    size_t newlen = raxNodeCurrentLength(n);
    n->size--; /* For now restore the original size. We'll update it only on
                  success at the end. */

    /* Alloc the new child we will link to 'n'. */
    raxNode *child = raxNewNode(0,0);
    if (child == NULL) return NULL;

    /* Make space in the original node. */
    raxNode *newn = rax_realloc(n,newlen);
    if (newn == NULL) {
        rax_free(child);
        return NULL;
    }
    n = newn;

    /* After the reallocation, we have up to 8/16 (depending on the system
     * pointer size, and the required node padding) bytes at the end, that is,
     * the additional char in the 'data' section, plus one pointer to the new
     * child, plus the padding needed in order to store addresses into aligned
     * locations.
     *
     * So...",256.0,387.0,1.0,20.0,132.0,174,20,131,16,0,37,8,8,4,3,,0,36,8,4,4,raxNode
5092,245816,raxCompressNode,1,raxCompressNode,"raxNode raxCompressNode (raxNode*,unsigned char*,size_t,raxNode**)",rax.c,"raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {
    assert(n->size == 0 && n->iscompr == 0);
    void *data = NULL; /* Initialized only to avoid warnings. */
    size_t newsize;

    debugf(""Compress node: %.*s\n"", (int)len,s);

    /* Allocate the child to link to this node. */
    *child = raxNewNode(0,0);
    if (*child == NULL) return NULL;

    /* Make space in the parent node. */
    newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);
    if (n->iskey) {
        data = raxGetData(n); /* To restore it later. */
        if (!n->isnull) newsize += sizeof(void*);
    }
    raxNode *newn = rax_realloc(n,newsize);
    if (newn == NULL) {
        rax_free(*child);
        return NULL;
    }
    n = newn;

    n->iscompr = 1;
    n->size = len;
    memcpy(n->data,s,len);
    if (n->iskey) raxSetData(n,data);
    raxNode **childfield = raxNodeLastChildPtr(n);
    memcpy(childfield,child,sizeof(*child));
    return n;
}",397.0,428.0,1.0,4.0,32.0,82,15,65,11,1,21,6,7,3,5,,0,19,8,4,4,raxNode
5093,246032,raxLowWalk,1,raxLowWalk,"size_t raxLowWalk (rax*,unsigned char*,size_t,raxNode**,raxNode***,int*,raxStack*)",rax.c,"static inline size_t raxLowWalk(rax *rax, unsigned char *s, size_t len, raxNode **stopnode, raxNode ***plink, int *splitpos, raxStack *ts) {
    raxNode *h = rax->head;
    raxNode **parentlink = &rax->head;

    size_t i = 0; /* Position in the string. */
    size_t j = 0; /* Position in the node children (or bytes if compressed).*/
    while(h->size && i < len) {
        debugnode(""Lookup current node"",h);
        unsigned char *v = h->data;

        if (h->iscompr) {
            for (j = 0; j < h->size && i < len; j++, i++) {
                if (v[j] != s[i]) break;
            }
            if (j != h->size) break;
        } else {
            /* Even when h->size is large, linear scan provides good
             * performances compared to other approaches that are in theory
             * more sounding, like performing a binary search. */
            for (j = 0; j < h->size; j++) {
                if (v[j] == s[i]) break;
            }
            if (j == h->size) break;
      ...",459.0,500.0,1.0,8.0,42.0,54,14,55,14,4,13,13,21,6,1,,0,12,14,7,7,size_t
5094,246246,raxGenericInsert,1,raxGenericInsert,"int raxGenericInsert (rax*,unsigned char*,size_t,void*,void**,int)",rax.c,"int raxGenericInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old, int overwrite) {
    size_t i;
    int j = 0; /* Split position. If raxLowWalk() stops in a compressed
                  node, the index 'j' represents the char we stopped within the
                  compressed node, that is, the position where to split the
                  node for insertion. */
    raxNode *h, **parentlink;

    debugf(""### Insert %.*s with value %p\n"", (int)len, s, data);
    i = raxLowWalk(rax,s,len,&h,&parentlink,&j,NULL);

    /* If i == len we walked following the whole string. If we are not
     * in the middle of a compressed node, the string is either already
     * inserted or this middle node is currently not a key, but can represent
     * our key. We have just to reallocate the node and make space for the
     * data pointer. */
    if (i == len && (!h->iscompr || j == 0 /* not in the middle if j is 0 */)) {
        debugf(""### Insert: node representing key exists\n""...",509.0,900.0,1.0,4.0,392.0,326,23,266,30,2,80,26,48,12,18,,0,71,12,6,6,int
5095,247762,raxInsert,1,raxInsert,"int raxInsert (rax*,unsigned char*,size_t,void*,void**)",rax.c,"int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
    return raxGenericInsert(rax,s,len,data,old,1);
}",904.0,906.0,1.0,1.0,3.0,0,0,5,5,13,1,1,1,0,1,,0,0,10,5,5,int
5096,247779,raxTryInsert,1,raxTryInsert,"int raxTryInsert (rax*,unsigned char*,size_t,void*,void**)",rax.c,"int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
    return raxGenericInsert(rax,s,len,data,old,0);
}",911.0,913.0,1.0,1.0,3.0,0,0,5,5,3,1,1,1,0,1,,0,0,10,5,5,int
5097,247796,raxFind,1,raxFind,"void* raxFind (rax*,unsigned char*,size_t)",rax.c,"void *raxFind(rax *rax, unsigned char *s, size_t len) {
    raxNode *h;

    debugf(""### Lookup: %.*s\n"", (int)len, s);
    int splitpos = 0;
    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
        return raxNotFound;
    return raxGetData(h);
}",918.0,927.0,1.0,4.0,10.0,12,7,16,8,15,5,2,2,2,2,,0,4,6,3,3,void*
5098,247844,raxFindParentLink,1,raxFindParentLink,"raxNode raxFindParentLink (raxNode*,raxNode*)",rax.c,"raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
    raxNode **cp = raxNodeFirstChildPtr(parent);
    raxNode *c;
    while(1) {
        memcpy(&c,cp,sizeof(c));
        if (c == child) break;
        cp++;
    }
    return cp;
}",934.0,943.0,1.0,19.0,10.0,19,11,15,5,1,3,4,4,0,0,,0,3,4,2,2,raxNode
5099,247902,raxRemoveChild,1,raxRemoveChild,"raxNode raxRemoveChild (raxNode*,raxNode*)",rax.c,"raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
    debugnode(""raxRemoveChild before"", parent);
    /* If parent is a compressed node (having a single child, as for definition
     * of the data structure), the removal of the child consists into turning
     * it into a normal node without children. */
    if (parent->iscompr) {
        void *data = NULL;
        if (parent->iskey) data = raxGetData(parent);
        parent->isnull = 0;
        parent->iscompr = 0;
        parent->size = 0;
        if (parent->iskey) raxSetData(parent,data);
        debugnode(""raxRemoveChild after"", parent);
        return parent;
    }

    /* Otherwise we need to scan for the child pointer and memmove()
     * accordingly.
     *
     * 1. To start we seek the first element in both the children
     *    pointers and edge bytes in the node. */
    raxNode **cp = raxNodeFirstChildPtr(parent);
    raxNode **c = cp;
    unsigned char *e = parent->data;

    /* 2. Search the child pointer to...",949.0,1018.0,1.0,4.0,70.0,100,16,81,14,1,26,9,11,3,3,,0,25,4,2,2,raxNode
5100,248168,raxRemove,1,raxRemove,"int raxRemove (rax*,unsigned char*,size_t,void**)",rax.c,"int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {
    raxNode *h;
    raxStack ts;

    debugf(""### Delete: %.*s\n"", (int)len, s);
    raxStackInit(&ts);
    int splitpos = 0;
    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,&ts);
    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey) {
        raxStackFree(&ts);
        return 0;
    }
    if (old) *old = raxGetData(h);
    h->iskey = 0;
    rax->numele--;

    /* If this node has no children, the deletion needs to reclaim the
     * no longer used nodes. This is an iterative process that needs to
     * walk the three upward, deleting all the nodes with just one child
     * that are not keys, until the head of the rax is reached or the first
     * node with more than one child is found. */

    int trycompress = 0; /* Will be set to 1 if we should try to optimize the
                            tree resulting from the deletion. */

    if (h->size == 0) {
        debugf(""Key deleted in node withou...",1022.0,1219.0,1.0,4.0,198.0,270,23,197,22,11,76,27,51,22,14,,0,70,8,4,4,int
5101,248882,raxRecursiveFree,1,raxRecursiveFree,"void raxRecursiveFree (rax*,raxNode*,void)",rax.c,"void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
    debugnode(""free traversing"",n);
    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeLastChildPtr(n);
    while(numchildren--) {
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        raxRecursiveFree(rax,child,free_callback);
        cp--;
    }
    debugnode(""free depth-first"",n);
    if (free_callback && n->iskey && !n->isnull)
        free_callback(raxGetData(n));
    rax_free(n);
    rax->numnodes--;
}",1223.0,1238.0,1.0,4.0,16.0,55,14,37,8,1,15,3,3,2,2,,0,13,6,3,3,void
5102,249016,raxFreeWithCallback,1,raxFreeWithCallback,"void raxFreeWithCallback (rax*,void)",rax.c,"void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {
    raxRecursiveFree(rax,rax->head,free_callback);
    assert(rax->numnodes == 0);
    rax_free(rax);
}",1242.0,1246.0,1.0,4.0,5.0,3,2,5,2,3,4,1,1,0,2,,0,2,4,2,2,void
5103,249038,raxFree,1,raxFree,void raxFree (rax*),rax.c,"void raxFree(rax *rax) {
    raxFreeWithCallback(rax,NULL);
}",1249.0,1251.0,1.0,1.0,3.0,0,0,2,2,5,1,1,1,0,1,,0,0,2,1,1,void
5104,249046,raxStart,1,raxStart,"void raxStart (raxIterator*,rax*)",rax.c,"void raxStart(raxIterator *it, rax *rt) {
    it->flags = RAX_ITER_EOF; /* No crash if the iterator is not seeked. */
    it->rt = rt;
    it->key_len = 0;
    it->key = it->key_static_string;
    it->key_max = RAX_ITER_STATIC_LEN;
    it->data = NULL;
    it->node_cb = NULL;
    raxStackInit(&it->stack);
}",1258.0,1267.0,1.0,16.0,10.0,18,4,12,3,19,10,1,1,0,1,,0,9,4,2,2,void
5105,249100,raxIteratorAddChars,1,raxIteratorAddChars,"int raxIteratorAddChars (raxIterator*,unsigned char*,size_t)",rax.c,"int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
    if (len == 0) return 1;
    if (it->key_max < it->key_len+len) {
        unsigned char *old = (it->key == it->key_static_string) ? NULL :
                                                                  it->key;
        size_t new_max = (it->key_len+len)*2;
        it->key = rax_realloc(old,new_max);
        if (it->key == NULL) {
            it->key = (!old) ? it->key_static_string : old;
            errno = ENOMEM;
            return 0;
        }
        if (old == NULL) memcpy(it->key,it->key_static_string,it->key_len);
        it->key_max = new_max;
    }
    /* Use memmove since there could be an overlap between 's' and
     * it->key when we use the current key in order to re-seek. */
    memmove(it->key+it->key_len,s,len);
    it->key_len += len;
    return 1;
}",1272.0,1292.0,1.0,18.0,21.0,36,9,36,8,4,18,5,7,3,1,,0,18,6,3,3,int
5106,249219,raxIteratorDelChars,1,raxIteratorDelChars,"void raxIteratorDelChars (raxIterator*,size_t)",rax.c,"void raxIteratorDelChars(raxIterator *it, size_t count) {
    it->key_len -= count;
}",1296.0,1298.0,1.0,1.0,3.0,2,2,2,2,2,1,1,1,0,0,,0,1,4,2,2,void
5107,249230,raxIteratorNextStep,1,raxIteratorNextStep,"int raxIteratorNextStep (raxIterator*,int)",rax.c,"int raxIteratorNextStep(raxIterator *it, int noup) {
    if (it->flags & RAX_ITER_EOF) {
        return 1;
    } else if (it->flags & RAX_ITER_JUST_SEEKED) {
        it->flags &= ~RAX_ITER_JUST_SEEKED;
        return 1;
    }

    /* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */
    size_t orig_key_len = it->key_len;
    size_t orig_stack_items = it->stack.items;
    raxNode *orig_node = it->node;

    while(1) {
        int children = it->node->iscompr ? 1 : it->node->size;
        if (!noup && children) {
            debugf(""GO DEEPER\n"");
            /* Seek the lexicographically smaller key in this subtree, which
             * is the first one found always going towards the first child
             * of every successive node. */
            if (!raxStackPush(&it->stack,it->node)) return 0;
            raxNode **cp = raxNodeFirstChildPtr(it->node);
            if (!raxIteratorAddChars(it,...",1314.0,1410.0,1.0,20.0,97.0,67,14,38,8,1,28,8,17,12,3,,0,28,4,2,2,int
5108,249717,raxSeekGreatest,1,raxSeekGreatest,int raxSeekGreatest (raxIterator*),rax.c,"int raxSeekGreatest(raxIterator *it) {
    while(it->node->size) {
        if (it->node->iscompr) {
            if (!raxIteratorAddChars(it,it->node->data,
                it->node->size)) return 0;
        } else {
            if (!raxIteratorAddChars(it,it->node->data+it->node->size-1,1))
                return 0;
        }
        raxNode **cp = raxNodeLastChildPtr(it->node);
        if (!raxStackPush(&it->stack,it->node)) return 0;
        memcpy(&it->node,cp,sizeof(it->node));
    }
    return 1;
}",1415.0,1429.0,1.0,23.0,15.0,67,13,30,4,2,20,5,9,8,2,,0,20,2,1,1,int
5109,249897,raxIteratorPrevStep,1,raxIteratorPrevStep,"int raxIteratorPrevStep (raxIterator*,int)",rax.c,"int raxIteratorPrevStep(raxIterator *it, int noup) {
    if (it->flags & RAX_ITER_EOF) {
        return 1;
    } else if (it->flags & RAX_ITER_JUST_SEEKED) {
        it->flags &= ~RAX_ITER_JUST_SEEKED;
        return 1;
    }

    /* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */
    size_t orig_key_len = it->key_len;
    size_t orig_stack_items = it->stack.items;
    raxNode *orig_node = it->node;

    while(1) {
        int old_noup = noup;

        /* Already on head? Can't go up, iteration finished. */
        if (!noup && it->node == it->rt->head) {
            it->flags |= RAX_ITER_EOF;
            it->stack.items = orig_stack_items;
            it->key_len = orig_key_len;
            it->node = orig_node;
            return 1;
        }

        unsigned char prevchild = it->key[it->key_len-1];
        if (!noup) {
            it->node = raxStackPop(&it->stack);
        } else {
       ...",1434.0,1505.0,1.0,20.0,72.0,131,23,74,12,1,44,14,33,13,6,,0,43,4,2,2,int
5110,250272,raxSeek,1,raxSeek,"int raxSeek (raxIterator*,char*,unsigned char*,size_t)",rax.c,"int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {
    int eq = 0, lt = 0, gt = 0, first = 0, last = 0;

    it->stack.items = 0; /* Just resetting. Initialized by raxStart(). */
    it->flags |= RAX_ITER_JUST_SEEKED;
    it->flags &= ~RAX_ITER_EOF;
    it->key_len = 0;
    it->node = NULL;

    /* Set flags according to the operator used to perform the seek. */
    if (op[0] == '>') {
        gt = 1;
        if (op[1] == '=') eq = 1;
    } else if (op[0] == '<') {
        lt = 1;
        if (op[1] == '=') eq = 1;
    } else if (op[0] == '=') {
        eq = 1;
    } else if (op[0] == '^') {
        first = 1;
    } else if (op[0] == '$') {
        last = 1;
    } else {
        errno = 0;
        return 0; /* Error. */
    }

    /* If there are no elements, set the EOF condition immediately and
     * return. */
    if (it->rt->numele == 0) {
        it->flags |= RAX_ITER_EOF;
        return 1;
    }

    if (first) {
        /* Seeking the first key gre...",1511.0,1670.0,1.0,17.0,160.0,63,11,48,12,22,25,10,13,6,5,,0,25,8,4,4,int
5111,250858,raxNext,1,raxNext,int raxNext (raxIterator*),rax.c,"int raxNext(raxIterator *it) {
    if (!raxIteratorNextStep(it,0)) {
        errno = ENOMEM;
        return 0;
    }
    if (it->flags & RAX_ITER_EOF) {
        errno = 0;
        return 0;
    }
    return 1;
}",1675.0,1685.0,1.0,20.0,11.0,6,5,5,3,18,2,3,3,2,1,,0,2,2,1,1,int
5112,250892,raxPrev,1,raxPrev,int raxPrev (raxIterator*),rax.c,"int raxPrev(raxIterator *it) {
    if (!raxIteratorPrevStep(it,0)) {
        errno = ENOMEM;
        return 0;
    }
    if (it->flags & RAX_ITER_EOF) {
        errno = 0;
        return 0;
    }
    return 1;
}",1690.0,1700.0,1.0,20.0,11.0,6,5,5,3,2,2,3,3,2,1,,0,2,2,1,1,int
5113,250926,raxRandomWalk,1,raxRandomWalk,"int raxRandomWalk (raxIterator*,size_t)",rax.c,"int raxRandomWalk(raxIterator *it, size_t steps) {
    if (it->rt->numele == 0) {
        it->flags |= RAX_ITER_EOF;
        return 0;
    }

    if (steps == 0) {
        size_t fle = 1+floor(log(it->rt->numele));
        fle *= 2;
        steps = 1 + rand() % fle;
    }

    raxNode *n = it->node;
    while(steps > 0 || !n->iskey) {
        int numchildren = n->iscompr ? 1 : n->size;
        int r = rand() % (numchildren+(n != it->rt->head));

        if (r == numchildren) {
            /* Go up to parent. */
            n = raxStackPop(&it->stack);
            int todel = n->iscompr ? n->size : 1;
            raxIteratorDelChars(it,todel);
        } else {
            /* Select a random child. */
            if (n->iscompr) {
                if (!raxIteratorAddChars(it,n->data,n->size)) return 0;
            } else {
                if (!raxIteratorAddChars(it,n->data+r,1)) return 0;
            }
            raxNode **cp = raxNodeFirstChildPtr(n)+r;
            if (!raxStackPush...",1714.0,1752.0,1.0,21.0,39.0,45,14,34,7,0,18,6,8,3,3,,0,17,4,2,2,int
5114,251154,raxCompare,1,raxCompare,"int raxCompare (raxIterator*,char*,unsigned char*,size_t)",rax.c,"int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len) {
    int eq = 0, lt = 0, gt = 0;

    if (op[0] == '=' || op[1] == '=') eq = 1;
    if (op[0] == '>') gt = 1;
    else if (op[0] == '<') lt = 1;
    else if (op[1] != '=') return 0; /* Syntax error. */

    size_t minlen = key_len < iter->key_len ? key_len : iter->key_len;
    int cmp = memcmp(iter->key,key,minlen);

    /* Handle == */
    if (lt == 0 && gt == 0) return cmp == 0 && key_len == iter->key_len;

    /* Handle >, >=, <, <= */
    if (cmp == 0) {
        /* Same prefix: longer wins. */
        if (eq && key_len == iter->key_len) return 1;
        else if (lt) return iter->key_len < key_len;
        else if (gt) return iter->key_len > key_len;
        else return 0; /* Avoid warning, just 'eq' is handled before. */
    } else if (cmp > 0) {
        return gt ? 1 : 0;
    } else /* (cmp < 0) */ {
        return lt ? 1 : 0;
    }
}",1757.0,1783.0,1.0,1.0,27.0,30,8,26,9,2,5,6,7,1,0,,0,5,8,4,4,int
5115,251325,raxStop,1,raxStop,void raxStop (raxIterator*),rax.c,"void raxStop(raxIterator *it) {
    if (it->key != it->key_static_string) rax_free(it->key);
    raxStackFree(&it->stack);
}",1786.0,1789.0,1.0,42.0,4.0,6,3,4,1,32,6,2,2,2,2,,0,4,2,1,1,void
5116,251350,raxEOF,1,raxEOF,int raxEOF (raxIterator*),rax.c,"int raxEOF(raxIterator *it) {
    return it->flags & RAX_ITER_EOF;
}",1795.0,1797.0,1.0,23.0,3.0,3,3,1,1,3,1,1,1,0,0,,0,1,2,1,1,int
5117,251365,raxSize,1,raxSize,uint64_t raxSize (rax*),rax.c,"uint64_t raxSize(rax *rax) {
    return rax->numele;
}",1800.0,1802.0,1.0,1.0,3.0,1,1,1,1,16,1,1,1,0,0,,0,1,2,1,1,uint64_t
5118,251374,raxRecursiveShow,1,raxRecursiveShow,"void raxRecursiveShow (int,int,raxNode*)",rax.c,"void raxRecursiveShow(int level, int lpad, raxNode *n) {
    char s = n->iscompr ? '""' : '[';
    char e = n->iscompr ? '""' : ']';

    int numchars = printf(""%c%.*s%c"", s, n->size, n->data, e);
    if (n->iskey) {
        numchars += printf(""=%p"",raxGetData(n));
    }

    int numchildren = n->iscompr ? 1 : n->size;
    /* Note that 7 and 4 magic constants are the string length
     * of "" `-(x) "" and "" -> "" respectively. */
    if (level) {
        lpad += (numchildren > 1) ? 7 : 4;
        if (numchildren == 1) lpad += numchars;
    }
    raxNode **cp = raxNodeFirstChildPtr(n);
    for (int i = 0; i < numchildren; i++) {
        char *branch = "" `-(%c) "";
        if (numchildren > 1) {
            printf(""\n"");
            for (int j = 0; j < lpad; j++) putchar(' ');
            printf(branch,n->data[i]);
        } else {
            printf("" -> "");
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        raxRecursiveShow(level+1,lpad,child);
        cp+...",1832.0,1863.0,1.0,19.0,32.0,47,16,47,13,1,12,7,11,1,1,,0,11,6,3,3,void
5119,251547,raxShow,1,raxShow,void raxShow (rax*),rax.c,"void raxShow(rax *rax) {
    raxRecursiveShow(0,0,rax->head);
    putchar('\n');
}",1866.0,1869.0,1.0,1.0,4.0,1,1,1,1,0,2,1,1,0,1,,0,1,2,1,1,void
5120,251707,raxTouch,1,raxTouch,unsigned long raxTouch (raxNode*),rax.c,"unsigned long raxTouch(raxNode *n) {
    debugf(""Touching %p\n"", (void*)n);
    unsigned long sum = 0;
    if (n->iskey) {
        sum += (unsigned long)raxGetData(n);
    }

    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeFirstChildPtr(n);
    int count = 0;
    for (int i = 0; i < numchildren; i++) {
        if (numchildren > 1) {
            sum += (long)n->data[i];
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        if (child == (void*)0x65d1760) count++;
        if (count > 1) exit(1);
        sum += raxTouch(child);
        cp++;
    }
    return sum;
}",1905.0,1927.0,1.0,4.0,23.0,39,16,33,8,0,8,6,9,1,1,,0,7,2,1,1,unsigned long
5121,251870,raxNodeCallback,1,raxNodeCallback,int raxNodeCallback (raxNode**),rax.h,typedef int (*raxNodeCallback)(raxNode **noderef);,165.0,165.0,13.0,49.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5122,252072,rdbCheckError,1,rdbCheckError,void rdbCheckError (char*...),redis-check-rdb.c,"void rdbCheckError(const char *fmt, ...) {
    char msg[1024];
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    printf(""--- RDB ERROR DETECTED ---\n"");
    printf(""[offset %llu] %s\n"",
        (unsigned long long) (rdbstate.rio ?
            rdbstate.rio->processed_bytes : 0), msg);
    printf(""[additional info] While doing: %s\n"",
        rdb_check_doing_string[rdbstate.doing]);
    if (rdbstate.key)
        printf(""[additional info] Reading key '%s'\n"",
            (char*)rdbstate.key->ptr);
    if (rdbstate.key_type != -1)
        printf(""[additional info] Reading type %d (%s)\n"",
            rdbstate.key_type,
            ((unsigned)rdbstate.key_type <
             sizeof(rdb_type_string)/sizeof(char*)) ?
                rdb_type_string[rdbstate.key_type] : ""unknown"");
    rdbShowGenericInfo();
}",113.0,137.0,1.0,1.0,25.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
5123,252077,rdbCheckSetError,1,rdbCheckSetError,void rdbCheckSetError (char*...),redis-check-rdb.c,"void rdbCheckSetError(const char *fmt, ...) {
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(rdbstate.error, sizeof(rdbstate.error), fmt, ap);
    va_end(ap);
    rdbstate.error_set = 1;
}",155.0,162.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5124,252082,rdbReportError,1,rdbReportError,"void rdbReportError (int,int,char*...)",rdb.c,"void rdbReportError(int corruption_error, int linenum, char *reason, ...) {
    va_list ap;
    char msg[1024];
    int len;

    len = snprintf(msg,sizeof(msg),
        ""Internal error in RDB reading offset %llu, function at rdb.c:%d -> "",
        (unsigned long long)server.loading_loaded_bytes, linenum);
    va_start(ap,reason);
    vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
    va_end(ap);

    if (isRestoreContext()) {
        /* If we're in the context of a RESTORE command, just propagate the error. */
        /* log in VERBOSE, and return (don't exit). */
        serverLog(LL_VERBOSE, ""%s"", msg);
        return;
    } else if (rdbCheckMode) {
        /* If we're inside the rdb checker, let it handle the error. */
        rdbCheckError(""%s"",msg);
    } else if (rdbFileBeingLoaded) {
        /* If we're loading an rdb file form disk, run rdb check (and exit) */
        serverLog(LL_WARNING, ""%s"", msg);
        char *argv[2] = {"""",rdbFileBeingLoaded};
        if (anetIsFifo(ar...",67.0,108.0,1.0,8.0,42.0,20,12,21,8,4,2,2,2,0,2,,0,0,6,3,3,void
5125,252280,rdbWriteRaw,1,rdbWriteRaw,"ssize_t rdbWriteRaw (rio*,void*,size_t)",rdb.c,"ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len) {
    if (rdb && rioWrite(rdb,p,len) == 0)
        return -1;
    return len;
}",110.0,114.0,1.0,1.0,5.0,3,3,5,3,15,1,2,2,1,1,,0,1,6,3,3,ssize_t
5126,252302,rdbSaveType,1,rdbSaveType,"int rdbSaveType (rio*,unsigned char)",rdb.c,"int rdbSaveType(rio *rdb, unsigned char type) {
    return rdbWriteRaw(rdb,&type,1);
}",116.0,118.0,1.0,1.0,3.0,1,1,2,2,16,1,1,1,0,1,,0,0,4,2,2,int
5127,252314,rdbLoadType,1,rdbLoadType,int rdbLoadType (rio*),rdb.c,"int rdbLoadType(rio *rdb) {
    unsigned char type;
    if (rioRead(rdb,&type,1) == 0) return -1;
    return type;
}",123.0,127.0,1.0,1.0,5.0,3,3,3,2,4,1,2,2,1,1,,0,1,2,1,1,int
5128,252334,rdbLoadTime,1,rdbLoadTime,time_t rdbLoadTime (rio*),rdb.c,"time_t rdbLoadTime(rio *rdb) {
    int32_t t32;
    if (rioRead(rdb,&t32,4) == 0) return -1;
    return (time_t)t32;
}",134.0,138.0,1.0,1.0,5.0,4,4,3,2,2,1,2,2,1,1,,0,1,2,1,1,time_t
5129,252356,rdbSaveMillisecondTime,1,rdbSaveMillisecondTime,"int rdbSaveMillisecondTime (rio*,long long)",rdb.c,"int rdbSaveMillisecondTime(rio *rdb, long long t) {
    int64_t t64 = (int64_t) t;
    memrev64ifbe(&t64); /* Store in little endian. */
    return rdbWriteRaw(rdb,&t64,8);
}",140.0,144.0,1.0,4.0,5.0,5,3,6,3,4,2,1,1,0,2,,0,0,4,2,2,int
5130,252381,rdbLoadMillisecondTime,1,rdbLoadMillisecondTime,"long long rdbLoadMillisecondTime (rio*,int)",rdb.c,"long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {
    int64_t t64;
    if (rioRead(rdb,&t64,8) == 0) return LLONG_MAX;
    if (rdbver >= 9) /* Check the top comment of this function. */
        memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */
    return (long long)t64;
}",161.0,167.0,1.0,8.0,7.0,6,4,7,4,0,2,3,3,1,2,,0,1,4,2,2,long long
5131,252415,rdbSaveLen,1,rdbSaveLen,"int rdbSaveLen (rio*,uint64_t)",rdb.c,"int rdbSaveLen(rio *rdb, uint64_t len) {
    unsigned char buf[2];
    size_t nwritten;

    if (len < (1<<6)) {
        /* Save a 6 bit len */
        buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        nwritten = 1;
    } else if (len < (1<<14)) {
        /* Save a 14 bit len */
        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
        buf[1] = len&0xFF;
        if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
        nwritten = 2;
    } else if (len <= UINT32_MAX) {
        /* Save a 32 bit len */
        buf[0] = RDB_32BITLEN;
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        uint32_t len32 = htonl(len);
        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
        nwritten = 1+4;
    } else {
        /* Save a 64 bit len */
        buf[0] = RDB_64BITLEN;
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        len = htonu64(len);
        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
        nwritten = 1+8;
    }
    ...",172.0,203.0,1.0,29.0,32.0,11,8,7,4,20,1,3,4,1,1,,0,1,4,2,2,int
5132,252601,rdbLoadLenByRef,1,rdbLoadLenByRef,"int rdbLoadLenByRef (rio*,int*,uint64_t*)",rdb.c,"int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
    unsigned char buf[2];
    int type;

    if (isencoded) *isencoded = 0;
    if (rioRead(rdb,buf,1) == 0) return -1;
    type = (buf[0]&0xC0)>>6;
    if (type == RDB_ENCVAL) {
        /* Read a 6 bit encoding type. */
        if (isencoded) *isencoded = 1;
        *lenptr = buf[0]&0x3F;
    } else if (type == RDB_6BITLEN) {
        /* Read a 6 bit len. */
        *lenptr = buf[0]&0x3F;
    } else if (type == RDB_14BITLEN) {
        /* Read a 14 bit len. */
        if (rioRead(rdb,buf+1,1) == 0) return -1;
        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
    } else if (buf[0] == RDB_32BITLEN) {
        /* Read a 32 bit len. */
        uint32_t len;
        if (rioRead(rdb,&len,4) == 0) return -1;
        *lenptr = ntohl(len);
    } else if (buf[0] == RDB_64BITLEN) {
        /* Read a 64 bit len. */
        uint64_t len;
        if (rioRead(rdb,&len,8) == 0) return -1;
        *lenptr = ntohu64(len);
    } else {
       ...",215.0,249.0,1.0,16.0,35.0,15,7,11,5,3,1,5,6,1,1,,0,1,6,3,3,int
5133,252787,rdbLoadLen,1,rdbLoadLen,"uint64_t rdbLoadLen (rio*,int*)",rdb.c,"uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
    uint64_t len;

    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
    return len;
}",255.0,260.0,1.0,58.0,6.0,3,3,5,4,8,1,2,2,1,1,,0,1,4,2,2,uint64_t
5134,252810,rdbEncodeInteger,1,rdbEncodeInteger,"int rdbEncodeInteger (long long,unsigned char*)",rdb.c,"int rdbEncodeInteger(long long value, unsigned char *enc) {
    if (value >= -(1<<7) && value <= (1<<7)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
        enc[1] = value&0xFF;
        return 2;
    } else if (value >= -(1<<15) && value <= (1<<15)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
        enc[1] = value&0xFF;
        enc[2] = (value>>8)&0xFF;
        return 3;
    } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
        enc[1] = value&0xFF;
        enc[2] = (value>>8)&0xFF;
        enc[3] = (value>>16)&0xFF;
        enc[4] = (value>>24)&0xFF;
        return 5;
    } else {
        return 0;
    }
}",266.0,286.0,1.0,18.0,21.0,14,10,5,2,2,0,2,2,0,0,,0,0,4,2,2,int
5135,252978,rdbLoadIntegerObject,1,rdbLoadIntegerObject,"void* rdbLoadIntegerObject (rio*,int,int,size_t*)",rdb.c,"void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    int encode = flags & RDB_LOAD_ENC;
    unsigned char enc[4];
    long long val;

    if (enctype == RDB_ENC_INT8) {
        if (rioRead(rdb,enc,1) == 0) return NULL;
        val = (signed char)enc[0];
    } else if (enctype == RDB_ENC_INT16) {
        uint16_t v;
        if (rioRead(rdb,enc,2) == 0) return NULL;
        v = ((uint32_t)enc[0])|
            ((uint32_t)enc[1]<<8);
        val = (int16_t)v;
    } else if (enctype == RDB_ENC_INT32) {
        uint32_t v;
        if (rioRead(rdb,enc,4) == 0) return NULL;
        v = ((uint32_t)enc[0])|
            ((uint32_t)enc[1]<<8)|
            ((uint32_t)enc[2]<<16)|
            ((uint32_t)enc[3]<<24);
        val = (int32_t)v;
    } else {
        rdbReportCorruptRDB(""Unknown RDB integer encoding type %d"",enctype);
        return NULL; /* Never reached. */
    }
    if (plain |...",291.0,331.0,1.0,24.0,41.0,21,10,30,14,1,4,5,7,1,4,,0,4,8,4,4,void*
5136,253199,rdbTryIntegerEncoding,1,rdbTryIntegerEncoding,"int rdbTryIntegerEncoding (char*,size_t,unsigned char*)",rdb.c,"int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
    long long value;
    if (string2ll(s, len, &value)) {
        return rdbEncodeInteger(value, enc);
    } else {
        return 0;
    }
}",336.0,343.0,1.0,1.0,8.0,1,1,5,4,1,2,2,2,1,2,,0,1,6,3,3,int
5137,253222,rdbSaveLzfBlob,1,rdbSaveLzfBlob,"ssize_t rdbSaveLzfBlob (rio*,void*,size_t,size_t)",rdb.c,"ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
                       size_t original_len) {
    unsigned char byte;
    ssize_t n, nwritten = 0;

    /* Data compressed! Let's save it on disk */
    byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
    if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
    nwritten += n;

    return nwritten;

writeerr:
    return -1;
}",345.0,368.0,1.0,12.0,24.0,22,7,24,7,1,4,9,5,4,4,,0,4,8,4,4,ssize_t
5138,253312,rdbSaveLzfStringObject,1,rdbSaveLzfStringObject,"ssize_t rdbSaveLzfStringObject (rio*,unsigned char*,size_t)",rdb.c,"ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
    size_t comprlen, outlen;
    void *out;

    /* We require at least four bytes compression for this to be worth it */
    if (len <= 4) return 0;
    outlen = len-4;
    if ((out = zmalloc(outlen+1)) == NULL) return 0;
    comprlen = lzf_compress(s, len, out, outlen);
    if (comprlen == 0) {
        zfree(out);
        return 0;
    }
    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
    zfree(out);
    return nwritten;
}",370.0,386.0,1.0,1.0,17.0,9,5,20,8,1,5,4,4,1,5,,0,3,6,3,3,ssize_t
5139,253374,rdbLoadLzfStringObject,1,rdbLoadLzfStringObject,"void* rdbLoadLzfStringObject (rio*,int,size_t*)",rdb.c,"void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    uint64_t len, clen;
    unsigned char *c = NULL;
    char *val = NULL;

    if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
    if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
    if ((c = ztrymalloc(clen)) == NULL) {
        serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbLoadLzfStringObject failed allocating %llu bytes"", (unsigned long long)clen);
        goto err;
    }

    /* Allocate our target according to the uncompressed size. */
    if (plain) {
        val = ztrymalloc(len);
    } else {
        val = sdstrynewlen(SDS_NOINIT,len);
    }
    if (!val) {
        serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbLoadLzfStringObject failed allocating %llu bytes"", (unsigned long long)len);
        goto err;
    }

    if (lenptr) *lenptr = len;

    /* Load the compressed representation ...",391.0,438.0,1.0,24.0,48.0,61,13,64,12,1,12,15,11,5,12,,0,6,6,3,3,void*
5140,253642,rdbSaveRawString,1,rdbSaveRawString,"ssize_t rdbSaveRawString (rio*,unsigned char*,size_t)",rdb.c,"ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
    int enclen;
    ssize_t n, nwritten = 0;

    /* Try integer encoding */
    if (len <= 11) {
        unsigned char buf[5];
        if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
            return enclen;
        }
    }

    /* Try LZF compression - under 20 bytes it's unable to compress even
     * aaaaaaaaaaaaaaaaaa so skip it */
    if (server.rdb_compression && len > 20) {
        n = rdbSaveLzfStringObject(rdb,s,len);
        if (n == -1) return -1;
        if (n > 0) return n;
        /* Return value of 0 means data can't be compressed, save the old way */
    }

    /* Store verbatim */
    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
    nwritten += n;
    if (len > 0) {
        if (rdbWriteRaw(rdb,s,len) == -1) return -1;
        nwritten += len;
    }
    return nwritten;
}",442.0,472.0,1.0,1.0,31.0,26,9,31,8,5,5,10,16,4,5,,0,5,6,3,3,ssize_t
5141,253756,rdbSaveLongLongAsStringObject,1,rdbSaveLongLongAsStringObject,"ssize_t rdbSaveLongLongAsStringObject (rio*,long long)",rdb.c,"ssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {
    unsigned char buf[32];
    ssize_t n, nwritten = 0;
    int enclen = rdbEncodeInteger(value,buf);
    if (enclen > 0) {
        return rdbWriteRaw(rdb,buf,enclen);
    } else {
        /* Encode as string */
        enclen = ll2string((char*)buf,32,value);
        serverAssert(enclen < 32);
        if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
        nwritten += n;
        if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
        nwritten += n;
    }
    return nwritten;
}",475.0,491.0,1.0,8.0,17.0,3,2,9,5,1,2,2,2,0,2,,0,1,4,2,2,ssize_t
5142,253845,rdbSaveStringObject,1,rdbSaveStringObject,"ssize_t rdbSaveStringObject (rio*,robj*)",rdb.c,"ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {
    /* Avoid to decode the object, then encode it again, if the
     * object is already integer encoded. */
    if (obj->encoding == OBJ_ENCODING_INT) {
        return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);
    } else {
        serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
        return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
    }
}",494.0,503.0,1.0,25.0,10.0,4,3,3,2,3,1,2,2,0,1,,0,0,4,2,2,ssize_t
5143,253908,rdbGenericLoadStringObject,1,rdbGenericLoadStringObject,"void* rdbGenericLoadStringObject (rio*,int,size_t*)",rdb.c,"void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    int isencoded;
    unsigned long long len;

    len = rdbLoadLen(rdb,&isencoded);
    if (len == RDB_LENERR) return NULL;

    if (isencoded) {
        switch(len) {
        case RDB_ENC_INT8:
        case RDB_ENC_INT16:
        case RDB_ENC_INT32:
            return rdbLoadIntegerObject(rdb,len,flags,lenptr);
        case RDB_ENC_LZF:
            return rdbLoadLzfStringObject(rdb,flags,lenptr);
        default:
            rdbReportCorruptRDB(""Unknown RDB string encoding type %llu"",len);
            return NULL;
        }
    }

    if (plain || sds) {
        void *buf = plain ? ztrymalloc(len) : sdstrynewlen(SDS_NOINIT,len);
        if (!buf) {
            serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbGenericLoadStringObject failed allocating %llu bytes"", len);
            return NULL;
        }
        if (lenptr) *le...",518.0,568.0,1.0,24.0,51.0,36,13,51,12,5,9,9,15,1,9,,0,4,6,3,3,void*
5144,254188,rdbLoadStringObject,1,rdbLoadStringObject,robj rdbLoadStringObject (rio*),rdb.c,"robj *rdbLoadStringObject(rio *rdb) {
    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
}",570.0,572.0,1.0,42.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,2,1,1,robj
5145,254200,rdbLoadEncodedStringObject,1,rdbLoadEncodedStringObject,robj rdbLoadEncodedStringObject (rio*),rdb.c,"robj *rdbLoadEncodedStringObject(rio *rdb) {
    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
}",574.0,576.0,1.0,42.0,3.0,1,1,2,2,1,1,1,1,0,1,,0,0,2,1,1,robj
5146,254214,rdbSaveDoubleValue,1,rdbSaveDoubleValue,"int rdbSaveDoubleValue (rio*,double)",rdb.c,"int rdbSaveDoubleValue(rio *rdb, double val) {
    unsigned char buf[128];
    int len;

    if (isnan(val)) {
        buf[0] = 253;
        len = 1;
    } else if (!isfinite(val)) {
        len = 1;
        buf[0] = (val < 0) ? 255 : 254;
    } else {
        long long lvalue;
        /* Integer printing function is much faster, check if we can safely use it. */
        if (double2ll(val, &lvalue))
            ll2string((char*)buf+1,sizeof(buf)-1,lvalue);
        else {
            const int dlen = fpconv_dtoa(val, (char*)buf+1);
            buf[dlen+1] = '\0';
        }
        buf[0] = strlen((char*)buf+1);
        len = buf[0]+1;
    }
    return rdbWriteRaw(rdb,buf,len);
}",586.0,609.0,1.0,1.0,24.0,3,2,6,4,0,1,2,2,0,1,,0,0,4,2,2,int
5147,254315,rdbLoadDoubleValue,1,rdbLoadDoubleValue,"int rdbLoadDoubleValue (rio*,double*)",rdb.c,"int rdbLoadDoubleValue(rio *rdb, double *val) {
    char buf[256];
    unsigned char len;

    if (rioRead(rdb,&len,1) == 0) return -1;
    switch(len) {
    case 255: *val = R_NegInf; return 0;
    case 254: *val = R_PosInf; return 0;
    case 253: *val = R_Nan; return 0;
    default:
        if (rioRead(rdb,buf,len) == 0) return -1;
        buf[len] = '\0';
        if (sscanf(buf, ""%lg"", val)!=1) return -1;
        return 0;
    }
}",612.0,627.0,1.0,1.0,16.0,15,7,16,7,0,2,5,7,2,2,,0,2,4,2,2,int
5148,254392,rdbSaveBinaryDoubleValue,1,rdbSaveBinaryDoubleValue,"int rdbSaveBinaryDoubleValue (rio*,double)",rdb.c,"int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
    memrev64ifbe(&val);
    return rdbWriteRaw(rdb,&val,sizeof(val));
}",634.0,637.0,1.0,4.0,4.0,4,2,5,2,1,2,1,1,0,2,,0,0,4,2,2,int
5149,254412,rdbLoadBinaryDoubleValue,1,rdbLoadBinaryDoubleValue,"int rdbLoadBinaryDoubleValue (rio*,double*)",rdb.c,"int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
    memrev64ifbe(val);
    return 0;
}",641.0,645.0,1.0,4.0,5.0,4,4,5,2,1,2,2,2,1,2,,0,1,4,2,2,int
5150,254438,rdbSaveBinaryFloatValue,1,rdbSaveBinaryFloatValue,"int rdbSaveBinaryFloatValue (rio*,float)",rdb.c,"int rdbSaveBinaryFloatValue(rio *rdb, float val) {
    memrev32ifbe(&val);
    return rdbWriteRaw(rdb,&val,sizeof(val));
}",648.0,651.0,1.0,4.0,4.0,4,2,5,2,1,2,1,1,0,2,,0,0,4,2,2,int
5151,254458,rdbLoadBinaryFloatValue,1,rdbLoadBinaryFloatValue,"int rdbLoadBinaryFloatValue (rio*,float*)",rdb.c,"int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
    memrev32ifbe(val);
    return 0;
}",654.0,658.0,1.0,4.0,5.0,4,4,5,2,1,2,2,2,1,2,,0,1,4,2,2,int
5152,254484,rdbSaveObjectType,1,rdbSaveObjectType,"int rdbSaveObjectType (rio*,robj*)",rdb.c,"int rdbSaveObjectType(rio *rdb, robj *o) {
    switch (o->type) {
    case OBJ_STRING:
        return rdbSaveType(rdb,RDB_TYPE_STRING);
    case OBJ_LIST:
        if (o->encoding == OBJ_ENCODING_QUICKLIST || o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb, RDB_TYPE_LIST_QUICKLIST_2);
        else
            serverPanic(""Unknown list encoding"");
    case OBJ_SET:
        if (o->encoding == OBJ_ENCODING_INTSET)
            return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
        else if (o->encoding == OBJ_ENCODING_HT)
            return rdbSaveType(rdb,RDB_TYPE_SET);
        else if (o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb,RDB_TYPE_SET_LISTPACK);
        else
            serverPanic(""Unknown set encoding"");
    case OBJ_ZSET:
        if (o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb,RDB_TYPE_ZSET_LISTPACK);
        else if (o->encoding == OBJ_ENCODING_SKIPLIST)
            return rdbSaveType(rdb,RDB_TYP...",661.0,701.0,1.0,9.0,41.0,14,5,13,2,2,8,6,10,0,8,,0,0,4,2,2,int
5153,254729,rdbLoadObjectType,1,rdbLoadObjectType,int rdbLoadObjectType (rio*),rdb.c,"int rdbLoadObjectType(rio *rdb) {
    int type;
    if ((type = rdbLoadType(rdb)) == -1) return -1;
    if (!rdbIsObjectType(type)) return -1;
    return type;
}",705.0,710.0,1.0,9.0,6.0,13,8,8,2,1,1,3,3,1,1,,0,1,2,1,1,int
5154,254773,rdbSaveStreamPEL,1,rdbSaveStreamPEL,"ssize_t rdbSaveStreamPEL (rio*,rax*,int)",rdb.c,"ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
    ssize_t n, nwritten = 0;

    /* Number of entries in the PEL. */
    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
    nwritten += n;

    /* Save each entry. */
    raxIterator ri;
    raxStart(&ri,pel);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        /* We store IDs in raw form as 128 big big endian numbers, like
         * they are inside the radix tree key. */
        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        if (nacks) {
            streamNACK *nack = ri.data;
            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {
                raxStop(&ri);
                return -1;
            }
            nwritten += n;
            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {
                raxStop(&ri);
                return -1;
            }
            n...",719.0,758.0,1.0,1.0,40.0,34,8,35,9,1,16,7,13,9,12,,0,10,6,3,3,ssize_t
5155,254897,rdbSaveStreamConsumers,1,rdbSaveStreamConsumers,"size_t rdbSaveStreamConsumers (rio*,streamCG*)",rdb.c,"size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
    ssize_t n, nwritten = 0;

    /* Number of consumers in this consumer group. */
    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
    nwritten += n;

    /* Save each consumer. */
    raxIterator ri;
    raxStart(&ri,cg->consumers);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        streamConsumer *consumer = ri.data;

        /* Consumer name. */
        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Seen time. */
        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Active time. */
        if ((n = rdbSaveMillisecondTime(rdb,consumer->active_time)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Consumer PEL, without t...",763.0,810.0,1.0,1.0,48.0,43,7,40,7,0,22,7,11,13,14,,0,15,4,2,2,size_t
5156,255044,rdbSaveObject,1,rdbSaveObject,"ssize_t rdbSaveObject (rio*,robj*,robj*,int)",rdb.c,"ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key, int dbid) {
    ssize_t n = 0, nwritten = 0;

    if (o->type == OBJ_STRING) {
        /* Save a string value */
        if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
        nwritten += n;
    } else if (o->type == OBJ_LIST) {
        /* Save a list value */
        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
            quicklist *ql = o->ptr;
            quicklistNode *node = ql->head;

            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
            nwritten += n;

            while(node) {
                if ((n = rdbSaveLen(rdb,node->container)) == -1) return -1;
                nwritten += n;

                if (quicklistNodeIsCompressed(node)) {
                    void *data;
                    size_t compress_len = quicklistGetLzf(node, &data);
                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
                    nwritten += n;
                } else {
  ...",814.0,1110.0,1.0,19.0,297.0,9,5,9,4,3,1,3,4,1,1,,0,1,8,4,4,ssize_t
5157,256451,rdbSavedObjectLen,1,rdbSavedObjectLen,"size_t rdbSavedObjectLen (robj*,robj*,int)",rdb.c,"size_t rdbSavedObjectLen(robj *o, robj *key, int dbid) {
    ssize_t len = rdbSaveObject(NULL,o,key,dbid);
    serverAssertWithInfo(NULL,o,len != -1);
    return len;
}",1116.0,1120.0,1.0,4.0,5.0,7,7,11,5,0,2,1,1,0,2,,0,1,6,3,3,size_t
5158,256489,rdbSaveKeyValuePair,1,rdbSaveKeyValuePair,"int rdbSaveKeyValuePair (rio*,robj*,robj*,long long,int)",rdb.c,"int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, int dbid) {
    int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
    int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;

    /* Save the expire time */
    if (expiretime != -1) {
        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
    }

    /* Save the LRU info. */
    if (savelru) {
        uint64_t idletime = estimateObjectIdleTime(val);
        idletime /= 1000; /* Using seconds is enough and requires less space.*/
        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
        if (rdbSaveLen(rdb,idletime) == -1) return -1;
    }

    /* Save the LFU info. */
    if (savelfu) {
        uint8_t buf[1];
        buf[0] = LFUDecrAndReturn(val);
        /* We can encode this in exactly two bytes: the opcode and an 8
         * bit counter, since the frequency is logarithmic with a 0-255 range...",1125.0,1165.0,1.0,44.0,41.0,43,9,31,10,1,12,14,20,9,12,,0,11,10,5,5,int
5159,256668,rdbSaveAuxField,1,rdbSaveAuxField,"ssize_t rdbSaveAuxField (rio*,void*,size_t,void*,size_t)",rdb.c,"ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
    ssize_t ret, len = 0;
    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
    len += ret;
    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
    len += ret;
    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
    len += ret;
    return len;
}",1168.0,1177.0,1.0,31.0,10.0,16,4,18,7,2,3,4,4,3,3,,0,3,10,5,5,ssize_t
5160,256736,rdbSaveAuxFieldStrStr,1,rdbSaveAuxFieldStrStr,"ssize_t rdbSaveAuxFieldStrStr (rio*,char*,char*)",rdb.c,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}",1181.0,1183.0,1.0,1.0,3.0,0,0,5,3,2,1,1,1,0,1,,0,0,6,3,3,ssize_t
5161,256752,rdbSaveAuxFieldStrInt,1,rdbSaveAuxFieldStrInt,"ssize_t rdbSaveAuxFieldStrInt (rio*,char*,long long)",rdb.c,"ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {
    char buf[LONG_STR_SIZE];
    int vlen = ll2string(buf,sizeof(buf),val);
    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
}",1186.0,1190.0,1.0,13.0,5.0,2,2,9,5,6,2,1,1,0,2,,0,1,6,3,3,ssize_t
5162,256776,rdbSaveInfoAuxFields,1,rdbSaveInfoAuxFields,"int rdbSaveInfoAuxFields (rio*,int,rdbSaveInfo*)",rdb.c,"int rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
    int aof_base = (rdbflags & RDBFLAGS_AOF_PREAMBLE) != 0;

    /* Add a few fields about the state when the RDB was created. */
    if (rdbSaveAuxFieldStrStr(rdb,""redis-ver"",REDIS_VERSION) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""redis-bits"",redis_bits) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""ctime"",time(NULL)) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""used-mem"",zmalloc_used_memory()) == -1) return -1;

    /* Handle saving options that generate aux fields. */
    if (rsi) {
        if (rdbSaveAuxFieldStrInt(rdb,""repl-stream-db"",rsi->repl_stream_db)
            == -1) return -1;
        if (rdbSaveAuxFieldStrStr(rdb,""repl-id"",server.replid)
            == -1) return -1;
        if (rdbSaveAuxFieldStrInt(rdb,""repl-offset"",server.master_repl_offset)
            == -1) return -1;
    }
    if (rdbSaveAuxFieldStrInt(rdb, ""aof-bas...",1193.0,1214.0,1.0,31.0,22.0,35,10,19,8,1,10,10,13,10,9,,0,10,6,3,3,int
5163,256915,rdbSaveSingleModuleAux,1,rdbSaveSingleModuleAux,"ssize_t rdbSaveSingleModuleAux (rio*,int,moduleType*)",rdb.c,"ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
    /* Save a module-specific aux value. */
    RedisModuleIO io;
    int retval = 0;
    moduleInitIOContext(io,mt,rdb,NULL,-1);

    /* We save the AUX field header in a temporary buffer so we can support aux_save2 API.
     * If aux_save2 is used the buffer will be flushed at the first time the module will perform
     * a write operation to the RDB and will be ignored is case there was no writes. */
    rio aux_save_headers_rio;
    rioInitWithBuffer(&aux_save_headers_rio, sdsempty());

    if (rdbSaveType(&aux_save_headers_rio, RDB_OPCODE_MODULE_AUX) == -1) goto error;

    /* Write the ""module"" identifier as prefix, so that we'll be able
     * to call the right module during loading. */
    if (rdbSaveLen(&aux_save_headers_rio,mt->id) == -1) goto error;

    /* write the 'when' so that we can provide it on loading. add a UINT opcode
     * for backwards compatibility, everything after the MT needs to be pref...",1216.0,1277.0,1.0,4.0,62.0,68,11,47,7,1,32,14,11,7,12,,0,26,6,3,3,ssize_t
5164,257200,rdbSaveFunctions,1,rdbSaveFunctions,ssize_t rdbSaveFunctions (rio*),rdb.c,"ssize_t rdbSaveFunctions(rio *rdb) {
    dict *functions = functionsLibGet();
    dictIterator *iter = dictGetIterator(functions);
    dictEntry *entry = NULL;
    ssize_t written = 0;
    ssize_t ret;
    while ((entry = dictNext(iter))) {
        if ((ret = rdbSaveType(rdb, RDB_OPCODE_FUNCTION2)) < 0) goto werr;
        written += ret;
        functionLibInfo *li = dictGetVal(entry);
        if ((ret = rdbSaveRawString(rdb, (unsigned char *) li->code, sdslen(li->code))) < 0) goto werr;
        written += ret;
    }
    dictReleaseIterator(iter);
    return written;

werr:
    dictReleaseIterator(iter);
    return -1;
}",1279.0,1298.0,1.0,36.0,20.0,16,6,23,8,2,11,6,6,6,9,,0,9,2,1,1,ssize_t
5165,257280,rdbSaveDb,1,rdbSaveDb,"ssize_t rdbSaveDb (rio*,int,int,long*)",rdb.c,"ssize_t rdbSaveDb(rio *rdb, int dbid, int rdbflags, long *key_counter) {
    dictIterator *di;
    dictEntry *de;
    ssize_t written = 0;
    ssize_t res;
    static long long info_updated_time = 0;
    char *pname = (rdbflags & RDBFLAGS_AOF_PREAMBLE) ? ""AOF rewrite"" :  ""RDB"";

    redisDb *db = server.db + dbid;
    dict *d = db->dict;
    if (dictSize(d) == 0) return 0;
    di = dictGetSafeIterator(d);

    /* Write the SELECT DB opcode */
    if ((res = rdbSaveType(rdb,RDB_OPCODE_SELECTDB)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb, dbid)) < 0) goto werr;
    written += res;

    /* Write the RESIZE DB opcode. */
    uint64_t db_size, expires_size;
    db_size = dictSize(db->dict);
    expires_size = dictSize(db->expires);
    if ((res = rdbSaveType(rdb,RDB_OPCODE_RESIZEDB)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb,db_size)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb,expires_size)) < 0) goto werr;
    writte...",1300.0,1366.0,1.0,30.0,67.0,86,18,91,25,1,25,18,17,9,16,,0,21,8,4,4,ssize_t
5166,257597,rdbSaveRio,1,rdbSaveRio,"int rdbSaveRio (int,rio*,int*,int,rdbSaveInfo*)",rdb.c,"int rdbSaveRio(int req, rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) {
    char magic[10];
    uint64_t cksum;
    long key_counter = 0;
    int j;

    if (server.rdb_checksum)
        rdb->update_cksum = rioGenericUpdateChecksum;
    snprintf(magic,sizeof(magic),""REDIS%04d"",RDB_VERSION);
    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
    if (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == -1) goto werr;
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA) && rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;

    /* save functions */
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_FUNCTIONS) && rdbSaveFunctions(rdb) == -1) goto werr;

    /* save all databases, skip this if we're in functions-only mode */
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA)) {
        for (j = 0; j < server.dbnum; j++) {
            if (rdbSaveDb(rdb, j, rdbflags, &key_counter) == -1) goto werr;
        }
    }

    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA) && rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFT...",1376.0,1414.0,1.0,45.0,39.0,49,13,35,12,2,9,21,16,8,9,,0,8,10,5,5,int
5167,257797,rdbSaveRioWithEOFMark,1,rdbSaveRioWithEOFMark,"int rdbSaveRioWithEOFMark (int,rio*,int*,rdbSaveInfo*)",rdb.c,"int rdbSaveRioWithEOFMark(int req, rio *rdb, int *error, rdbSaveInfo *rsi) {
    char eofmark[RDB_EOF_MARK_SIZE];

    startSaving(RDBFLAGS_REPLICATION);
    getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
    if (error) *error = 0;
    if (rioWrite(rdb,""$EOF:"",5) == 0) goto werr;
    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
    if (rioWrite(rdb,""\r\n"",2) == 0) goto werr;
    if (rdbSaveRio(req,rdb,error,RDBFLAGS_NONE,rsi) == C_ERR) goto werr;
    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
    stopSaving(1);
    return C_OK;

werr: /* Write error. */
    /* Set 'error' only if not already set by rdbSaveRio() call. */
    if (error && *error == 0) *error = errno;
    stopSaving(0);
    return C_ERR;
}",1424.0,1443.0,1.0,17.0,20.0,15,6,17,6,1,9,13,8,5,9,,0,5,8,4,4,int
5168,257906,rdbSaveInternal,1,rdbSaveInternal,"int rdbSaveInternal (int,char*,rdbSaveInfo*,int)",rdb.c,"static int rdbSaveInternal(int req, const char *filename, rdbSaveInfo *rsi, int rdbflags) {
    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
    rio rdb;
    int error = 0;
    int saved_errno;
    char *err_op;    /* For a detailed log */

    FILE *fp = fopen(filename,""w"");
    if (!fp) {
        saved_errno = errno;
        char *str_err = strerror(errno);
        char *cwdp = getcwd(cwd,MAXPATHLEN);
        serverLog(LL_WARNING,
            ""Failed opening the temp RDB file %s (in server root dir %s) ""
            ""for saving: %s"",
            filename,
            cwdp ? cwdp : ""unknown"",
            str_err);
        errno = saved_errno;
        return C_ERR;
    }

    rioInitWithFile(&rdb,fp);

    if (server.rdb_save_incremental_fsync) {
        rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);
        if (!(rdbflags & RDBFLAGS_KEEP_CACHE)) rioSetReclaimCache(&rdb,1);
    }

    if (rdbSaveRio(req,&rdb,&error,rdbflags,rsi) == C_ERR) {
        errno = er...",1445.0,1497.0,1.0,8.0,53.0,46,12,54,16,2,8,14,11,2,8,,0,2,8,4,4,int
5169,258144,rdbSaveToFile,1,rdbSaveToFile,int rdbSaveToFile (char*),rdb.c,"int rdbSaveToFile(const char *filename) {
    startSaving(RDBFLAGS_NONE);

    if (rdbSaveInternal(SLAVE_REQ_NONE,filename,NULL,RDBFLAGS_NONE) != C_OK) {
        int saved_errno = errno;
        stopSaving(0);
        errno = saved_errno;
        return C_ERR;
    }

    stopSaving(1);
    return C_OK;
}",1501.0,1513.0,1.0,16.0,13.0,4,3,6,4,1,4,2,2,1,4,,0,1,2,1,1,int
5170,258188,rdbSave,1,rdbSave,"int rdbSave (int,char*,rdbSaveInfo*,int)",rdb.c,"int rdbSave(int req, char *filename, rdbSaveInfo *rsi, int rdbflags) {
    char tmpfile[256];
    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */

    startSaving(RDBFLAGS_NONE);
    snprintf(tmpfile,256,""temp-%d.rdb"", (int) getpid());

    if (rdbSaveInternal(req,tmpfile,rsi,rdbflags) != C_OK) {
        stopSaving(0);
        return C_ERR;
    }
    
    /* Use RENAME to make sure the DB file is changed atomically only
     * if the generate DB file is ok. */
    if (rename(tmpfile,filename) == -1) {
        char *str_err = strerror(errno);
        char *cwdp = getcwd(cwd,MAXPATHLEN);
        serverLog(LL_WARNING,
            ""Error moving temp DB file %s on the final ""
            ""destination %s (in server root dir %s): %s"",
            tmpfile,
            filename,
            cwdp ? cwdp : ""unknown"",
            str_err);
        unlink(tmpfile);
        stopSaving(0);
        return C_ERR;
    }
    if (fsyncFileDir(filename) != 0) {
        serverLog...",1516.0,1557.0,1.0,16.0,42.0,26,9,27,12,3,10,4,4,2,10,,0,2,8,4,4,int
5171,258355,rdbSaveBackground,1,rdbSaveBackground,"int rdbSaveBackground (int,char*,rdbSaveInfo*,int)",rdb.c,"int rdbSaveBackground(int req, char *filename, rdbSaveInfo *rsi, int rdbflags) {
    pid_t childpid;

    if (hasActiveChildProcess()) return C_ERR;
    server.stat_rdb_saves++;

    server.dirty_before_bgsave = server.dirty;
    server.lastbgsave_try = time(NULL);

    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {
        int retval;

        /* Child */
        redisSetProcTitle(""redis-rdb-bgsave"");
        redisSetCpuAffinity(server.bgsave_cpulist);
        retval = rdbSave(req, filename,rsi,rdbflags);
        if (retval == C_OK) {
            sendChildCowInfo(CHILD_INFO_TYPE_RDB_COW_SIZE, ""RDB"");
        }
        exitFromChild((retval == C_OK) ? 0 : 1);
    } else {
        /* Parent */
        if (childpid == -1) {
            server.lastbgsave_status = C_ERR;
            serverLog(LL_WARNING,""Can't save in background: fork: %s"",
                strerror(errno));
            return C_ERR;
        }
        serverLog(LL_NOTICE,""Background saving started by pid %ld"",(long) ...",1559.0,1593.0,1.0,40.0,35.0,15,6,15,9,1,7,4,5,2,7,,0,3,8,4,4,int
5172,258515,rdbRemoveTempFile,1,rdbRemoveTempFile,"void rdbRemoveTempFile (pid_t,int)",rdb.c,"void rdbRemoveTempFile(pid_t childpid, int from_signal) {
    char tmpfile[256];
    char pid[32];

    /* Generate temp rdb file name using async-signal safe functions. */
    ll2string(pid, sizeof(pid), childpid);
    redis_strlcpy(tmpfile, ""temp-"", sizeof(tmpfile));
    redis_strlcat(tmpfile, pid, sizeof(tmpfile));
    redis_strlcat(tmpfile, "".rdb"", sizeof(tmpfile));

    if (from_signal) {
        /* bg_unlink is not async-signal-safe, but in this case we don't really
         * need to close the fd, it'll be released when the process exists. */
        int fd = open(tmpfile, O_RDONLY|O_NONBLOCK);
        UNUSED(fd);
        unlink(tmpfile);
    } else {
        bg_unlink(tmpfile);
    }
}",1599.0,1618.0,1.0,8.0,20.0,7,4,18,7,1,4,2,2,0,4,,0,0,4,2,2,void
5173,258566,rdbLoadCheckModuleValue,1,rdbLoadCheckModuleValue,"robj rdbLoadCheckModuleValue (rio*,char*)",rdb.c,"robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
    uint64_t opcode;
    while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
        if (opcode == RDB_MODULE_OPCODE_SINT ||
            opcode == RDB_MODULE_OPCODE_UINT)
        {
            uint64_t len;
            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
                rdbReportCorruptRDB(
                    ""Error reading integer from module %s value"", modulename);
            }
        } else if (opcode == RDB_MODULE_OPCODE_STRING) {
            robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
            if (o == NULL) {
                rdbReportCorruptRDB(
                    ""Error reading string from module %s value"", modulename);
            }
            decrRefCount(o);
        } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
            float val;
            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
                rdbReportCorruptRDB(
                    ""Error reading fl...",1624.0,1657.0,1.0,45.0,34.0,8,6,9,5,0,4,4,7,2,4,,0,2,4,2,2,robj
5174,258703,_ziplistPairsEntryConvertAndValidate,1,_ziplistPairsEntryConvertAndValidate,"int _ziplistPairsEntryConvertAndValidate (unsigned char*,unsigned int,void*)",rdb.c,"static int _ziplistPairsEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    unsigned char *str;
    unsigned int slen;
    long long vll;

    struct {
        long count;
        dict *fields;
        unsigned char **lp;
    } *data = userdata;

    if (data->fields == NULL) {
        data->fields = dictCreate(&hashDictType);
        dictExpand(data->fields, head_count/2);
    }

    if (!ziplistGet(p, &str, &slen, &vll))
        return 0;

    /* Even records are field names, add to dict and check that's not a dup */
    if (((data->count) & 1) == 0) {
        sds field = str? sdsnewlen(str, slen): sdsfromlonglong(vll);
        if (dictAdd(data->fields, field, NULL) != DICT_OK) {
            /* Duplicate, return an error */
            sdsfree(field);
            return 0;
        }
    }

    if (str) {
        *(data->lp) = lpAppend(*(data->lp), (unsigned char*)str, slen);
    } else {
        *(data->lp) = lpAppendInteger(*(data->lp), vll);
...",1662.0,1699.0,1.0,50.0,38.0,27,12,28,10,0,8,6,7,2,8,,0,6,6,3,3,int
5175,258822,ziplistPairsConvertAndValidateIntegrity,1,ziplistPairsConvertAndValidateIntegrity,"int ziplistPairsConvertAndValidateIntegrity (unsigned char*,size_t,unsigned char**)",rdb.c,"int ziplistPairsConvertAndValidateIntegrity(unsigned char *zl, size_t size, unsigned char **lp) {
    /* Keep track of the field names to locate duplicate ones */
    struct {
        long count;
        dict *fields; /* Initialisation at the first callback. */
        unsigned char **lp;
    } data = {0, NULL, lp};

    int ret = ziplistValidateIntegrity(zl, size, 1, _ziplistPairsEntryConvertAndValidate, &data);

    /* make sure we have an even number of records. */
    if (data.count & 1)
        ret = 0;

    if (data.fields) dictRelease(data.fields);
    return ret;
}",1705.0,1721.0,1.0,1.0,17.0,9,5,12,6,0,2,3,3,0,2,,0,1,6,3,3,int
5176,258867,_ziplistEntryConvertAndValidate,1,_ziplistEntryConvertAndValidate,"int _ziplistEntryConvertAndValidate (unsigned char*,unsigned int,void*)",rdb.c,"static int _ziplistEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    UNUSED(head_count);
    unsigned char *str;
    unsigned int slen;
    long long vll;
    unsigned char **lp = (unsigned char**)userdata;

    if (!ziplistGet(p, &str, &slen, &vll)) return 0;

    if (str)
        *lp = lpAppend(*lp, (unsigned char*)str, slen);
    else
        *lp = lpAppendInteger(*lp, vll);

    return 1;
}",1725.0,1740.0,1.0,4.0,16.0,11,5,13,7,0,2,3,3,1,2,,0,2,6,3,3,int
5177,258926,_listZiplistEntryConvertAndValidate,1,_listZiplistEntryConvertAndValidate,"int _listZiplistEntryConvertAndValidate (unsigned char*,unsigned int,void*)",rdb.c,"static int _listZiplistEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    UNUSED(head_count);
    unsigned char *str;
    unsigned int slen;
    long long vll;
    char longstr[32] = {0};
    quicklist *ql = (quicklist*)userdata;

    if (!ziplistGet(p, &str, &slen, &vll)) return 0;
    if (!str) {
        /* Write the longval as a string so we can re-add it */
        slen = ll2string(longstr, sizeof(longstr), vll);
        str = (unsigned char *)longstr;
    }
    quicklistPushTail(ql, str, slen);
    return 1;
}",1744.0,1760.0,1.0,4.0,17.0,14,6,19,8,0,3,3,3,1,3,,0,2,6,3,3,int
5178,258988,_lpEntryValidation,1,_lpEntryValidation,"int _lpEntryValidation (unsigned char*,unsigned int,void*)",rdb.c,"static int _lpEntryValidation(unsigned char *p, unsigned int head_count, void *userdata) {
    struct {
        int pairs;
        long count;
        dict *fields;
    } *data = userdata;

    if (data->fields == NULL) {
        data->fields = dictCreate(&hashDictType);
        dictExpand(data->fields, data->pairs ? head_count/2 : head_count);
    }

    /* If we're checking pairs, then even records are field names. Otherwise
     * we're checking all elements. Add to dict and check that's not a dup */
    if (!data->pairs || ((data->count) & 1) == 0) {
        unsigned char *str;
        int64_t slen;
        unsigned char buf[LP_INTBUF_SIZE];

        str = lpGet(p, &slen, buf);
        sds field = sdsnewlen(str, slen);
        if (dictAdd(data->fields, field, NULL) != DICT_OK) {
            /* Duplicate, return an error */
            sdsfree(field);
            return 0;
        }
    }

    (data->count)++;
    return 1;
}",1763.0,1793.0,1.0,26.0,31.0,23,11,24,10,0,6,4,5,1,6,,0,4,6,3,3,int
5179,259077,lpValidateIntegrityAndDups,1,lpValidateIntegrityAndDups,"int lpValidateIntegrityAndDups (unsigned char*,size_t,int,int)",rdb.c,"int lpValidateIntegrityAndDups(unsigned char *lp, size_t size, int deep, int pairs) {
    if (!deep)
        return lpValidateIntegrity(lp, size, 0, NULL, NULL);

    /* Keep track of the field names to locate duplicate ones */
    struct {
        int pairs;
        long count;
        dict *fields; /* Initialisation at the first callback. */
    } data = {pairs, 0, NULL};

    int ret = lpValidateIntegrity(lp, size, 1, _lpEntryValidation, &data);

    /* make sure we have an even number of records. */
    if (pairs && data.count & 1)
        ret = 0;

    if (data.fields) dictRelease(data.fields);
    return ret;
}",1800.0,1819.0,1.0,1.0,20.0,11,7,18,7,0,3,4,4,0,3,,0,1,8,4,4,int
5180,259136,rdbLoadObject,1,rdbLoadObject,"robj rdbLoadObject (int,rio*,sds,int,int*)",rdb.c,"robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error) {
    robj *o = NULL, *ele, *dec;
    uint64_t len;
    unsigned int i;

    /* Set default error of load object, it will be set to 0 on success. */
    if (error) *error = RDB_LOAD_ERR_OTHER;

    int deep_integrity_validation = server.sanitize_dump_payload == SANITIZE_DUMP_YES;
    if (server.sanitize_dump_payload == SANITIZE_DUMP_CLIENTS) {
        /* Skip sanitization when loading (an RDB), or getting a RESTORE command
         * from either the master or a client using an ACL user with the skip-sanitize-payload flag. */
        int skip = server.loading ||
            (server.current_client && (server.current_client->flags & CLIENT_MASTER));
        if (!skip && server.current_client && server.current_client->user)
            skip = !!(server.current_client->user->flags & USER_FLAG_SANITIZE_PAYLOAD_SKIP);
        deep_integrity_validation = !skip;
    }

    if (rdbtype == RDB_TYPE_STRING) {
        /* R...",1825.0,2854.0,1.0,24.0,1030.0,41,10,31,8,3,2,8,10,1,2,,0,2,10,5,5,robj
5181,262680,startLoading,1,startLoading,"void startLoading (size_t,int,int)",rdb.c,"void startLoading(size_t size, int rdbflags, int async) {
    /* Load the DB */
    server.loading = 1;
    if (async == 1) server.async_loading = 1;
    server.loading_start_time = time(NULL);
    server.loading_loaded_bytes = 0;
    server.loading_total_bytes = size;
    server.loading_rdb_used_mem = 0;
    server.rdb_last_load_keys_expired = 0;
    server.rdb_last_load_keys_loaded = 0;
    blockingOperationStarts();

    /* Fire the loading modules start event. */
    int subevent;
    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)
        subevent = REDISMODULE_SUBEVENT_LOADING_AOF_START;
    else if(rdbflags & RDBFLAGS_REPLICATION)
        subevent = REDISMODULE_SUBEVENT_LOADING_REPL_START;
    else
        subevent = REDISMODULE_SUBEVENT_LOADING_RDB_START;
    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,subevent,NULL);
}",2858.0,2879.0,1.0,19.0,22.0,20,5,15,6,3,2,3,3,0,2,,0,0,6,3,3,void
5182,262778,startLoadingFile,1,startLoadingFile,"void startLoadingFile (size_t,char*,int)",rdb.c,"void startLoadingFile(size_t size, char* filename, int rdbflags) {
    rdbFileBeingLoaded = filename;
    startLoading(size, rdbflags, 0);
}",2884.0,2887.0,1.0,1.0,4.0,1,1,4,4,2,2,1,1,0,1,,0,1,6,3,3,void
5183,262792,loadingAbsProgress,1,loadingAbsProgress,void loadingAbsProgress (off_t),rdb.c,"void loadingAbsProgress(off_t pos) {
    server.loading_loaded_bytes = pos;
    if (server.stat_peak_memory < zmalloc_used_memory())
        server.stat_peak_memory = zmalloc_used_memory();
}",2890.0,2894.0,1.0,1.0,5.0,6,3,4,2,1,2,2,2,1,2,,0,2,2,1,1,void
5184,262814,loadingIncrProgress,1,loadingIncrProgress,void loadingIncrProgress (off_t),rdb.c,"void loadingIncrProgress(off_t size) {
    server.loading_loaded_bytes += size;
    if (server.stat_peak_memory < zmalloc_used_memory())
        server.stat_peak_memory = zmalloc_used_memory();
}",2897.0,2901.0,1.0,1.0,5.0,6,4,4,2,2,2,2,2,1,2,,0,2,2,1,1,void
5185,262836,updateLoadingFileName,1,updateLoadingFileName,void updateLoadingFileName (char*),rdb.c,"void updateLoadingFileName(char* filename) {
    rdbFileBeingLoaded = filename;
}",2904.0,2906.0,1.0,1.0,3.0,1,1,2,2,2,1,1,1,0,0,,0,1,2,1,1,void
5186,262844,stopLoading,1,stopLoading,void stopLoading (int),rdb.c,"void stopLoading(int success) {
    server.loading = 0;
    server.async_loading = 0;
    blockingOperationEnds();
    rdbFileBeingLoaded = NULL;

    /* Fire the loading modules end event. */
    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,
                          success?
                            REDISMODULE_SUBEVENT_LOADING_ENDED:
                            REDISMODULE_SUBEVENT_LOADING_FAILED,
                           NULL);
}",2909.0,2921.0,1.0,26.0,13.0,6,3,6,4,6,3,1,1,0,2,,0,1,2,1,1,void
5187,262876,startSaving,1,startSaving,void startSaving (int),rdb.c,"void startSaving(int rdbflags) {
    /* Fire the persistence modules start event. */
    int subevent;
    if (rdbflags & RDBFLAGS_AOF_PREAMBLE && getpid() != server.pid)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;
    else if (rdbflags & RDBFLAGS_AOF_PREAMBLE)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START;
    else if (getpid()!=server.pid)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;
    else
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;
    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,NULL);
}",2923.0,2935.0,1.0,19.0,13.0,6,6,5,4,3,1,2,2,0,1,,0,0,2,1,1,void
5188,262945,stopSaving,1,stopSaving,void stopSaving (int),rdb.c,"void stopSaving(int success) {
    /* Fire the persistence modules end event. */
    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,
                          success?
                            REDISMODULE_SUBEVENT_PERSISTENCE_ENDED:
                            REDISMODULE_SUBEVENT_PERSISTENCE_FAILED,
                          NULL);
}",2937.0,2944.0,1.0,26.0,8.0,1,1,2,2,8,1,1,1,0,1,,0,0,2,1,1,void
5189,262963,rdbLoadProgressCallback,1,rdbLoadProgressCallback,"void rdbLoadProgressCallback (rio*,void*,size_t)",rdb.c,"void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
    if (server.rdb_checksum)
        rioGenericUpdateChecksum(r, buf, len);
    if (server.loading_process_events_interval_bytes &&
        (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
    {
        if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
            replicationSendNewlineToMaster();
        loadingAbsProgress(r->processed_bytes);
        processEventsWhileBlocked();
        processModuleLoadingProgressEvent(0);
    }
    if (server.repl_state == REPL_STATE_TRANSFER && rioCheckType(r) == RIO_TYPE_CONN) {
        atomicIncr(server.stat_net_repl_input_bytes, len);
    }
}",2948.0,2963.0,1.0,71.0,16.0,22,8,19,5,0,6,5,6,1,6,,0,1,6,3,3,void
5190,263042,rdbFunctionLoad,1,rdbFunctionLoad,"int rdbFunctionLoad (rio*,int,functionsLibCtx*,int,sds*)",rdb.c,"int rdbFunctionLoad(rio *rdb, int ver, functionsLibCtx* lib_ctx, int rdbflags, sds *err) {
    UNUSED(ver);
    sds error = NULL;
    sds final_payload = NULL;
    int res = C_ERR;
    if (!(final_payload = rdbGenericLoadStringObject(rdb, RDB_LOAD_SDS, NULL))) {
        error = sdsnew(""Failed loading library payload"");
        goto done;
    }

    if (lib_ctx) {
        sds library_name = NULL;
        if (!(library_name = functionsCreateWithLibraryCtx(final_payload, rdbflags & RDBFLAGS_ALLOW_DUP, &error, lib_ctx))) {
            if (!error) {
                error = sdsnew(""Failed creating the library"");
            }
            goto done;
        }
        sdsfree(library_name);
    }

    res = C_OK;

done:
    if (final_payload) sdsfree(final_payload);
    if (error) {
        if (err) {
            *err = error;
        } else {
            serverLog(LL_WARNING, ""Failed creating function, %s"", error);
            sdsfree(error);
        }
    }
    return res;
}",2972.0,3006.0,1.0,4.0,35.0,20,8,30,10,1,6,10,12,2,6,,0,4,10,5,5,int
5191,263171,rdbLoadRio,1,rdbLoadRio,"int rdbLoadRio (rio*,int,rdbSaveInfo*)",rdb.c,"int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
    functionsLibCtx* functions_lib_ctx = functionsLibCtxGetCurrent();
    rdbLoadingCtx loading_ctx = { .dbarray = server.db, .functions_lib_ctx = functions_lib_ctx };
    int retval = rdbLoadRioWithLoadingCtx(rdb,rdbflags,rsi,&loading_ctx);
    return retval;
}",3010.0,3015.0,1.0,1.0,6.0,8,4,12,8,1,2,1,1,0,2,,0,2,6,3,3,int
5192,263207,rdbLoadRioWithLoadingCtx,1,rdbLoadRioWithLoadingCtx,"int rdbLoadRioWithLoadingCtx (rio*,int,rdbSaveInfo*,rdbLoadingCtx*)",rdb.c,"int rdbLoadRioWithLoadingCtx(rio *rdb, int rdbflags, rdbSaveInfo *rsi, rdbLoadingCtx *rdb_loading_ctx) {
    uint64_t dbid = 0;
    int type, rdbver;
    redisDb *db = rdb_loading_ctx->dbarray+0;
    char buf[1024];
    int error;
    long long empty_keys_skipped = 0;

    rdb->update_cksum = rdbLoadProgressCallback;
    rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
    if (rioRead(rdb,buf,9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf,""REDIS"",5) != 0) {
        serverLog(LL_WARNING,""Wrong signature trying to load DB from file"");
        return C_ERR;
    }
    rdbver = atoi(buf+5);
    if (rdbver < 1 || rdbver > RDB_VERSION) {
        serverLog(LL_WARNING,""Can't handle RDB format version %d"",rdbver);
        return C_ERR;
    }

    /* Key-specific attributes, set by opcodes before the key type. */
    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
    long long lru_clock = LRU_CLOCK();

    while(1) {
        sds k...",3023.0,3367.0,1.0,8.0,345.0,86,19,69,20,2,21,24,34,5,19,,0,11,8,4,4,int
5193,264874,rdbLoad,1,rdbLoad,"int rdbLoad (char*,rdbSaveInfo*,int)",rdb.c,"int rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {
    FILE *fp;
    rio rdb;
    int retval;
    struct stat sb;
    int rdb_fd;

    fp = fopen(filename, ""r"");
    if (fp == NULL) {
        if (errno == ENOENT) return RDB_NOT_EXIST;

        serverLog(LL_WARNING,""Fatal error: can't open the RDB file %s for reading: %s"", filename, strerror(errno));
        return RDB_FAILED;
    }

    if (fstat(fileno(fp), &sb) == -1)
        sb.st_size = 0;

    startLoadingFile(sb.st_size, filename, rdbflags);
    rioInitWithFile(&rdb,fp);

    retval = rdbLoadRio(&rdb,rdbflags,rsi);

    fclose(fp);
    stopLoading(retval==C_OK);
    /* Reclaim the cache backed by rdb */
    if (retval == C_OK && !(rdbflags & RDBFLAGS_KEEP_CACHE)) {
        /* TODO: maybe we could combine the fopen and open into one in the future */
        rdb_fd = open(filename, O_RDONLY);
        if (rdb_fd > 0) bioCreateCloseJob(rdb_fd, 0, 1);
    }
    return (retval==C_OK) ? RDB_OK : RDB_FAILED;
}",3376.0,3408.0,1.0,36.0,33.0,25,12,31,13,1,6,6,8,0,6,,0,1,6,3,3,int
5194,265013,backgroundSaveDoneHandlerDisk,1,backgroundSaveDoneHandlerDisk,"void backgroundSaveDoneHandlerDisk (int,int)",rdb.c,"static void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        serverLog(LL_NOTICE,
            ""Background saving terminated with success"");
        server.dirty = server.dirty - server.dirty_before_bgsave;
        server.lastsave = time(NULL);
        server.lastbgsave_status = C_OK;
    } else if (!bysignal && exitcode != 0) {
        serverLog(LL_WARNING, ""Background saving error"");
        server.lastbgsave_status = C_ERR;
    } else {
        mstime_t latency;

        serverLog(LL_WARNING,
            ""Background saving terminated by signal %d"", bysignal);
        latencyStartMonitor(latency);
        rdbRemoveTempFile(server.child_pid, 0);
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded(""rdb-unlink-temp-file"",latency);
        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
         * triggering an error condition. */
        if (bysignal != SIGUSR1)
            server.lastbgsave_...",3412.0,3436.0,1.0,8.0,25.0,15,8,9,4,1,1,2,2,0,1,,0,0,4,2,2,void
5195,265192,backgroundSaveDoneHandlerSocket,1,backgroundSaveDoneHandlerSocket,"void backgroundSaveDoneHandlerSocket (int,int)",rdb.c,"static void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        serverLog(LL_NOTICE,
            ""Background RDB transfer terminated with success"");
    } else if (!bysignal && exitcode != 0) {
        serverLog(LL_WARNING, ""Background transfer error"");
    } else {
        serverLog(LL_WARNING,
            ""Background transfer terminated by signal %d"", bysignal);
    }
    if (server.rdb_child_exit_pipe!=-1)
        close(server.rdb_child_exit_pipe);
    aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);
    close(server.rdb_pipe_read);
    server.rdb_child_exit_pipe = -1;
    server.rdb_pipe_read = -1;
    zfree(server.rdb_pipe_conns);
    server.rdb_pipe_conns = NULL;
    server.rdb_pipe_numconns = 0;
    server.rdb_pipe_numconns_writing = 0;
    zfree(server.rdb_pipe_buff);
    server.rdb_pipe_buff = NULL;
    server.rdb_pipe_bufflen = 0;
}",3441.0,3464.0,1.0,8.0,24.0,31,9,19,4,1,4,3,3,0,4,,0,0,4,2,2,void
5196,265344,backgroundSaveDoneHandler,1,backgroundSaveDoneHandler,"void backgroundSaveDoneHandler (int,int)",rdb.c,"void backgroundSaveDoneHandler(int exitcode, int bysignal) {
    int type = server.rdb_child_type;
    switch(server.rdb_child_type) {
    case RDB_CHILD_TYPE_DISK:
        backgroundSaveDoneHandlerDisk(exitcode,bysignal);
        break;
    case RDB_CHILD_TYPE_SOCKET:
        backgroundSaveDoneHandlerSocket(exitcode,bysignal);
        break;
    default:
        serverPanic(""Unknown RDB child type."");
        break;
    }

    server.rdb_child_type = RDB_CHILD_TYPE_NONE;
    server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
    server.rdb_save_time_start = -1;
    /* Possibly there are slaves waiting for a BGSAVE in order to be served
     * (the first stage of SYNC is a bulk transfer of dump.rdb) */
    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, type);
}",3467.0,3487.0,1.0,9.0,21.0,18,9,15,5,0,4,5,2,0,4,,0,0,4,2,2,void
5197,265426,killRDBChild,1,killRDBChild,void killRDBChild (void),rdb.c,"void killRDBChild(void) {
    kill(server.child_pid, SIGUSR1);
    /* Because we are not using here waitpid (like we have in killAppendOnlyChild
     * and TerminateModuleForkChild), all the cleanup operations is done by
     * checkChildrenDone, that later will find that the process killed.
     * This includes:
     * - resetChildState
     * - rdbRemoveTempFile */
}",3492.0,3500.0,1.0,1.0,9.0,1,1,2,2,6,0,1,1,0,0,,0,0,2,1,1,void
5198,265436,rdbSaveToSlavesSockets,1,rdbSaveToSlavesSockets,"int rdbSaveToSlavesSockets (int,rdbSaveInfo*)",rdb.c,"int rdbSaveToSlavesSockets(int req, rdbSaveInfo *rsi) {
    listNode *ln;
    listIter li;
    pid_t childpid;
    int pipefds[2], rdb_pipe_write, safe_to_exit_pipe;

    if (hasActiveChildProcess()) return C_ERR;

    /* Even if the previous fork child exited, don't start a new one until we
     * drained the pipe. */
    if (server.rdb_pipe_conns) return C_ERR;

    /* Before to fork, create a pipe that is used to transfer the rdb bytes to
     * the parent, we can't let it write directly to the sockets, since in case
     * of TLS we must let the parent handle a continuous TLS state when the
     * child terminates and parent takes over. */
    if (anetPipe(pipefds, O_NONBLOCK, 0) == -1) return C_ERR;
    server.rdb_pipe_read = pipefds[0]; /* read end */
    rdb_pipe_write = pipefds[1]; /* write end */

    /* create another pipe that is used by the parent to signal to the child
     * that it can exit. */
    if (anetPipe(pipefds, 0, 0) == -1) {
        close(rdb_pipe_write);
  ...",3504.0,3619.0,1.0,40.0,116.0,67,14,57,17,1,21,12,16,8,17,,0,13,4,2,2,int
5199,265869,saveCommand,1,saveCommand,void saveCommand (client*),rdb.c,"void saveCommand(client *c) {
    if (server.child_type == CHILD_TYPE_RDB) {
        addReplyError(c,""Background save already in progress"");
        return;
    }

    server.stat_rdb_saves++;

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);
    if (rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr,RDBFLAGS_NONE) == C_OK) {
        addReply(c,shared.ok);
    } else {
        addReplyErrorObject(c,shared.err);
    }
}",3621.0,3636.0,1.0,29.0,16.0,9,5,9,5,0,4,3,3,1,4,,0,2,2,1,1,void
5200,265927,bgsaveCommand,1,bgsaveCommand,void bgsaveCommand (client*),rdb.c,"void bgsaveCommand(client *c) {
    int schedule = 0;

    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite
     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */
    if (c->argc > 1) {
        if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""schedule"")) {
            schedule = 1;
        } else {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        }
    }

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);

    if (server.child_type == CHILD_TYPE_RDB) {
        addReplyError(c,""Background save already in progress"");
    } else if (hasActiveChildProcess() || server.in_exec) {
        if (schedule || server.in_exec) {
            server.rdb_bgsave_scheduled = 1;
            addReplyStatus(c,""Background saving scheduled"");
        } else {
            addReplyError(c,
            ""Another child process is active (AOF?): can't BGSAVE right now. ""
            ""Use BGSAVE SCHEDULE in order...",3639.0,3673.0,1.0,29.0,35.0,15,9,9,5,0,5,4,5,3,2,,0,4,2,1,1,void
5201,266049,rdbPopulateSaveInfo,1,rdbPopulateSaveInfo,rdbSaveInfo rdbPopulateSaveInfo (rdbSaveInfo*),rdb.c,"rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
    rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
    *rsi = rsi_init;

    /* If the instance is a master, we can populate the replication info
     * only when repl_backlog is not NULL. If the repl_backlog is NULL,
     * it means that the instance isn't in any replication chains. In this
     * scenario the replication info is useless, because when a slave
     * connects to us, the NULL repl_backlog will trigger a full
     * synchronization, at the same time we will use a new replid and clear
     * replid2. */
    if (!server.masterhost && server.repl_backlog) {
        /* Note that when server.slaveseldb is -1, it means that this master
         * didn't apply any write commands after a full synchronization.
         * So we can let repl_stream_db be 0, this allows a restarted slave
         * to reload replication ID/offset, it's safe because the next write
         * command must generate a SELECT statement. */
        rsi->...",3684.0,3722.0,1.0,27.0,39.0,29,10,18,4,5,3,4,4,0,0,,0,3,2,1,1,rdbSaveInfo
5202,266559,redisGitSHA1,1,redisGitSHA1,char* redisGitSHA1 (void),release.c,"char *redisGitSHA1(void) {
    return REDIS_GIT_SHA1;
}",40.0,42.0,1.0,1.0,3.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,char*
5203,266564,redisGitDirty,1,redisGitDirty,char* redisGitDirty (void),release.c,"char *redisGitDirty(void) {
    return REDIS_GIT_DIRTY;
}",44.0,46.0,1.0,1.0,3.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,char*
5204,266569,writeHandler,1,writeHandler,"void writeHandler (aeEventLoop*,int,void*,int)",redis-benchmark.c,"static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    client c = privdata;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);

    /* Initialize request when nothing was written. */
    if (c->written == 0) {
        /* Enforce upper bound to number of requests. */
        int requests_issued = 0;
        atomicGetIncr(config.requests_issued, requests_issued, config.pipeline);
        if (requests_issued >= config.requests) {
            return;
        }

        /* Really initialize: randomize keys and set start time. */
        if (config.randomkeys) randomizeClientKey(c);
        if (config.cluster_mode && c->staglen > 0) setClusterKeyHashTag(c);
        atomicGet(config.slots_last_update, c->slots_last_update);
        c->start = ustime();
        c->latency = -1;
    }
    const ssize_t buflen = sdslen(c->obuf);
    const ssize_t writeLen = buflen-c->written;
    if (writeLen > 0) {
        void *ptr = c->obuf+c->written;
        while(1) {
         ...",593.0,640.0,1.0,4.0,48.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
5205,266577,createMissingClients,1,createMissingClients,void createMissingClients (client),redis-benchmark.c,"static void createMissingClients(client c) {
    int n = 0;
    while(config.liveclients < config.numclients) {
        int thread_id = -1;
        if (config.num_threads)
            thread_id = config.liveclients % config.num_threads;
        createClient(NULL,0,c,thread_id);

        /* Listen backlog is quite limited on most systems */
        if (++n > 64) {
            usleep(50000);
            n = 0;
        }
    }
}",852.0,866.0,1.0,1.0,15.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
5206,266582,createBenchmarkThread,1,createBenchmarkThread,benchmarkThread* createBenchmarkThread (int),redis-benchmark.c,"static benchmarkThread *createBenchmarkThread(int index) {
    benchmarkThread *thread = zmalloc(sizeof(*thread));
    if (thread == NULL) return NULL;
    thread->index = index;
    thread->el = aeCreateEventLoop(1024*10);
    aeCreateTimeEvent(thread->el,1,showThroughput,(void *)thread,NULL);
    return thread;
}",1024.0,1031.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,benchmarkThread
5207,266587,freeBenchmarkThread,1,freeBenchmarkThread,void freeBenchmarkThread (benchmarkThread*),redis-benchmark.c,"static void freeBenchmarkThread(benchmarkThread *thread) {
    if (thread->el) aeDeleteEventLoop(thread->el);
    zfree(thread);
}",1033.0,1036.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5208,266592,freeBenchmarkThreads,1,freeBenchmarkThreads,void freeBenchmarkThreads (void),redis-benchmark.c,"static void freeBenchmarkThreads(void) {
    int i = 0;
    for (; i < config.num_threads; i++) {
        benchmarkThread *thread = config.threads[i];
        if (thread) freeBenchmarkThread(thread);
    }
    zfree(config.threads);
    config.threads = NULL;
}",1038.0,1046.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
5209,266597,execBenchmarkThread,1,execBenchmarkThread,void* execBenchmarkThread (void*),redis-benchmark.c,"static void *execBenchmarkThread(void *ptr) {
    benchmarkThread *thread = (benchmarkThread *) ptr;
    aeMain(thread->el);
    return NULL;
}",1048.0,1052.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
5210,266608,getRedisConfig,1,getRedisConfig,"redisConfig* getRedisConfig (char*,int,char*)",redis-benchmark.c,"static redisConfig *getRedisConfig(const char *ip, int port,
                                   const char *hostsocket)
{
    redisConfig *cfg = zcalloc(sizeof(*cfg));
    if (!cfg) return NULL;
    redisContext *c = NULL;
    redisReply *reply = NULL, *sub_reply = NULL;
    c = getRedisContext(ip, port, hostsocket);
    if (c == NULL) {
        freeRedisConfig(cfg);
        exit(1);
    }
    redisAppendCommand(c, ""CONFIG GET %s"", ""save"");
    redisAppendCommand(c, ""CONFIG GET %s"", ""appendonly"");
    int abort_test = 0;
    int i = 0;
    void *r = NULL;
    for (; i < 2; i++) {
        int res = redisGetReply(c, &r);
        if (reply) freeReplyObject(reply);
        reply = res == REDIS_OK ? ((redisReply *) r) : NULL;
        if (res != REDIS_OK || !r) goto fail;
        if (reply->type == REDIS_REPLY_ERROR) {
            goto fail;
        }
        if (reply->type != REDIS_REPLY_ARRAY || reply->elements < 2) goto fail;
        sub_reply = reply->element[1];
        char *value ...",313.0,364.0,1.0,1.0,52.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,redisConfig
5211,266615,getRedisContext,1,getRedisContext,"redisContext* getRedisContext (char*,int,char*)",redis-benchmark.c,"static redisContext *getRedisContext(const char *ip, int port,
                                     const char *hostsocket)
{
    redisContext *ctx = NULL;
    redisReply *reply =  NULL;
    if (hostsocket == NULL)
        ctx = redisConnect(ip, port);
    else
        ctx = redisConnectUnix(hostsocket);
    if (ctx == NULL || ctx->err) {
        fprintf(stderr,""Could not connect to Redis at "");
        char *err = (ctx != NULL ? ctx->errstr : """");
        if (hostsocket == NULL)
            fprintf(stderr,""%s:%d: %s\n"",ip,port,err);
        else
            fprintf(stderr,""%s: %s\n"",hostsocket,err);
        goto cleanup;
    }
    if (config.tls==1) {
        const char *err = NULL;
        if (cliSecureConnection(ctx, config.sslconfig, &err) == REDIS_ERR && err) {
            fprintf(stderr, ""Could not negotiate a TLS connection: %s\n"", err);
            goto cleanup;
        }
    }
    if (config.conn_info.auth == NULL)
        return ctx;
    if (config.conn_info.user == NULL)
...",256.0,309.0,1.0,1.0,54.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,redisContext
5212,266622,freeRedisConfig,1,freeRedisConfig,void freeRedisConfig (redisConfig*),redis-benchmark.c,"static void freeRedisConfig(redisConfig *cfg) {
    if (cfg->save) sdsfree(cfg->save);
    if (cfg->appendonly) sdsfree(cfg->appendonly);
    zfree(cfg);
}",365.0,369.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
5213,266627,fetchClusterSlotsConfiguration,1,fetchClusterSlotsConfiguration,int fetchClusterSlotsConfiguration (client),redis-benchmark.c,"static int fetchClusterSlotsConfiguration(client c) {
    UNUSED(c);
    int success = 1, is_fetching_slots = 0, last_update = 0;
    size_t i;
    atomicGet(config.slots_last_update, last_update);
    if (c->slots_last_update < last_update) {
        c->slots_last_update = last_update;
        return -1;
    }
    redisReply *reply = NULL;
    atomicGetIncr(config.is_fetching_slots, is_fetching_slots, 1);
    if (is_fetching_slots) return -1; //TODO: use other codes || errno ?
    atomicSet(config.is_fetching_slots, 1);
    fprintf(stderr,
            ""WARNING: Cluster slots configuration changed, fetching new one...\n"");
    const char *errmsg = ""Failed to update cluster slots configuration"";
    static dictType dtype = {
        dictSdsHash,               /* hash function */
        NULL,                      /* key dup */
        NULL,                      /* val dup */
        dictSdsKeyCompare,         /* key compare */
        NULL,                      /* key destructor */
 ...",1289.0,1377.0,1.0,4.0,89.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5214,266632,updateClusterSlotsConfiguration,1,updateClusterSlotsConfiguration,void updateClusterSlotsConfiguration (void),redis-benchmark.c,"static void updateClusterSlotsConfiguration(void) {
    pthread_mutex_lock(&config.is_updating_slots_mutex);
    atomicSet(config.is_updating_slots, 1);
    int i;
    for (i = 0; i < config.cluster_node_count; i++) {
        clusterNode *node = config.cluster_nodes[i];
        if (node->updated_slots != NULL) {
            int *oldslots = node->slots;
            node->slots = node->updated_slots;
            node->slots_count = node->updated_slots_count;
            node->current_slot_index = 0;
            node->updated_slots = NULL;
            node->updated_slots_count = 0;
            zfree(oldslots);
        }
    }
    atomicSet(config.is_updating_slots, 0);
    atomicIncr(config.slots_last_update, 1);
    pthread_mutex_unlock(&config.is_updating_slots_mutex);
}",1380.0,1399.0,1.0,1.0,20.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5215,266637,showThroughput,1,showThroughput,"int showThroughput (aeEventLoop*,long long,void*)",redis-benchmark.c,"int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    benchmarkThread *thread = (benchmarkThread *)clientData;
    int liveclients = 0;
    int requests_finished = 0;
    int previous_requests_finished = 0;
    long long current_tick = mstime();
    atomicGet(config.liveclients, liveclients);
    atomicGet(config.requests_finished, requests_finished);
    atomicGet(config.previous_requests_finished, previous_requests_finished);

    if (liveclients == 0 && requests_finished != config.requests) {
        fprintf(stderr,""All clients disconnected... aborting.\n"");
        exit(1);
    }
    if (config.num_threads && requests_finished >= config.requests) {
        aeStop(eventLoop);
        return AE_NOMORE;
    }
    if (config.csv) return SHOW_THROUGHPUT_INTERVAL;
    /* only first thread output throughput */
    if (thread != NULL && thread->index != 0) {
        return SHOW_THROUGHPUT_INTERVAL;
    }
    if (co...",1675.0,1717.0,1.0,4.0,43.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5216,266644,benchmarkVersion,1,benchmarkVersion,sds benchmarkVersion (void),redis-benchmark.c,"static sds benchmarkVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",208.0,220.0,1.0,45.0,13.0,4,1,10,2,0,8,3,4,2,8,,0,8,2,1,1,sds
5217,266688,dictSdsHash,1,dictSdsHash,uint64_t dictSdsHash (void*),server.c,"uint64_t dictSdsHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
}",310.0,312.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
5218,266693,dictSdsKeyCompare,1,dictSdsKeyCompare,"int dictSdsKeyCompare (dict*,void*,void*)",server.c,"int dictSdsKeyCompare(dict *d, const void *key1,
        const void *key2)
{
    int l1,l2;
    UNUSED(d);

    l1 = sdslen((sds)key1);
    l2 = sdslen((sds)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",259.0,269.0,1.0,4.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
5219,266700,ustime,1,ustime,long long ustime (void),server.c,"long long ustime(void) {
    struct timeval tv;
    long long ust;

    gettimeofday(&tv, NULL);
    ust = ((long long)tv.tv_sec)*1000000;
    ust += tv.tv_usec;
    return ust;
}",192.0,200.0,1.0,1.0,9.0,7,6,7,3,30,0,1,1,0,0,,0,0,2,1,1,long long
5220,266727,mstime,1,mstime,long long mstime (void),server.c,"mstime_t mstime(void) {
    return ustime()/1000;
}",203.0,205.0,1.0,1.0,3.0,1,1,0,0,125,1,1,1,0,1,,0,0,2,1,1,mstime_t
5221,267399,freeAllClients,1,freeAllClients,void freeAllClients (void),redis-benchmark.c,"static void freeAllClients(void) {
    listNode *ln = config.clients->head, *next;

    while(ln) {
        next = ln->next;
        freeClient(ln->value);
        ln = next;
    }
}",396.0,404.0,1.0,1.0,9.0,7,3,8,3,1,5,2,2,0,1,,0,4,2,1,1,void
5222,267501,randomizeClientKey,1,randomizeClientKey,void randomizeClientKey (client),redis-benchmark.c,"static void randomizeClientKey(client c) {
    size_t i;

    for (i = 0; i < c->randlen; i++) {
        char *p = c->randptr[i]+11;
        size_t r = 0;
        if (config.randomkeys_keyspacelen != 0)
            r = random() % config.randomkeys_keyspacelen;
        size_t j;

        for (j = 0; j < 12; j++) {
            *p = '0'+r%10;
            r/=10;
            p--;
        }
    }
}",415.0,431.0,1.0,1.0,17.0,21,11,16,6,0,4,4,6,2,0,,0,4,2,1,1,void
5223,267573,setClusterKeyHashTag,1,setClusterKeyHashTag,void setClusterKeyHashTag (client),redis-benchmark.c,"static void setClusterKeyHashTag(client c) {
    assert(c->thread_id >= 0);
    clusterNode *node = c->cluster_node;
    assert(node);
    assert(node->current_slot_index < node->slots_count);
    int is_updating_slots = 0;
    atomicGet(config.is_updating_slots, is_updating_slots);
    /* If updateClusterSlotsConfiguration is updating the slots array,
     * call updateClusterSlotsConfiguration is order to block the thread
     * since the mutex is locked. When the slots will be updated by the
     * thread that's actually performing the update, the execution of
     * updateClusterSlotsConfiguration won't actually do anything, since
     * the updated_slots_count array will be already NULL. */
    if (is_updating_slots) updateClusterSlotsConfiguration();
    int slot = node->slots[node->current_slot_index];
    const char *tag = crc16_slot_table[slot];
    int taglen = strlen(tag);
    size_t i;
    for (i = 0; i < c->staglen; i++) {
        char *p = c->stagptr[i] + 1;
        p[...",433.0,457.0,1.0,1.0,25.0,36,9,32,10,0,7,3,3,0,1,,0,6,2,1,1,void
5224,267689,clientDone,1,clientDone,void clientDone (client),redis-benchmark.c,"static void clientDone(client c) {
    int requests_finished = 0;
    atomicGet(config.requests_finished, requests_finished);
    if (requests_finished >= config.requests) {
        freeClient(c);
        if (!config.num_threads && config.el) aeStop(config.el);
        return;
    }
    if (config.keepalive) {
        resetClient(c);
    } else {
        if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
        config.liveclients--;
        createMissingClients(c);
        config.liveclients++;
        if (config.num_threads)
            pthread_mutex_unlock(&(config.liveclients_mutex));
        freeClient(c);
    }
}",459.0,478.0,1.0,1.0,20.0,10,5,11,3,0,15,4,5,8,3,,0,12,2,1,1,void
5225,267768,readHandler,1,readHandler,"void readHandler (aeEventLoop*,int,void*,int)",redis-benchmark.c,"static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    client c = privdata;
    void *reply = NULL;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);

    /* Calculate latency only for the first read event. This means that the
     * server already sent the reply and we need to parse it. Parsing overhead
     * is not part of the latency, so calculate it only once, here. */
    if (c->latency < 0) c->latency = ustime()-(c->start);

    if (redisBufferRead(c->context) != REDIS_OK) {
        fprintf(stderr,""Error: %s\n"",c->context->errstr);
        exit(1);
    } else {
        while(c->pending) {
            if (redisGetReply(c->context,&reply) != REDIS_OK) {
                fprintf(stderr,""Error: %s\n"",c->context->errstr);
                exit(1);
            }
            if (reply != NULL) {
                if (reply == (void*)REDIS_REPLY_ERROR) {
                    fprintf(stderr,""Unexpected error reply, exiting...\n"");
                    exit(1);
    ...",480.0,591.0,1.0,4.0,112.0,15,6,17,9,0,1,3,3,0,1,,0,1,8,4,4,void
5226,269390,showLatencyReport,1,showLatencyReport,void showLatencyReport (void),redis-benchmark.c,"static void showLatencyReport(void) {

    const float reqpersec = (float)config.requests_finished/((float)config.totlatency/1000.0f);
    const float p0 = ((float) hdr_min(config.latency_histogram))/1000.0f;
    const float p50 = hdr_value_at_percentile(config.latency_histogram, 50.0 )/1000.0f;
    const float p95 = hdr_value_at_percentile(config.latency_histogram, 95.0 )/1000.0f;
    const float p99 = hdr_value_at_percentile(config.latency_histogram, 99.0 )/1000.0f;
    const float p100 = ((float) hdr_max(config.latency_histogram))/1000.0f;
    const float avg = hdr_mean(config.latency_histogram)/1000.0f;

    if (!config.quiet && !config.csv) {
        printf(""%*s\r"", config.last_printed_bytes, "" ""); // ensure there is a clean line
        printf(""====== %s ======\n"", config.title);
        printf(""  %d requests completed in %.2f seconds\n"", config.requests_finished,
            (float)config.totlatency/1000);
        printf(""  %d parallel clients\n"", config.numclients);
        ...",868.0,959.0,1.0,1.0,92.0,105,17,95,19,1,59,12,26,10,1,,0,58,2,1,1,void
5227,269832,initBenchmarkThreads,1,initBenchmarkThreads,void initBenchmarkThreads (void),redis-benchmark.c,"static void initBenchmarkThreads(void) {
    int i;
    if (config.threads) freeBenchmarkThreads();
    config.threads = zmalloc(config.num_threads * sizeof(benchmarkThread*));
    for (i = 0; i < config.num_threads; i++) {
        benchmarkThread *thread = createBenchmarkThread(i);
        config.threads[i] = thread;
    }
}",961.0,969.0,1.0,1.0,9.0,13,6,12,4,2,13,3,3,4,3,,0,12,2,1,1,void
5228,269880,startBenchmarkThreads,1,startBenchmarkThreads,void startBenchmarkThreads (void),redis-benchmark.c,"static void startBenchmarkThreads(void) {
    int i;
    for (i = 0; i < config.num_threads; i++) {
        benchmarkThread *t = config.threads[i];
        if (pthread_create(&(t->thread), NULL, execBenchmarkThread, t)){
            fprintf(stderr, ""FATAL: Failed to start thread %d.\n"", i);
            exit(1);
        }
    }
    for (i = 0; i < config.num_threads; i++)
        pthread_join(config.threads[i]->thread, NULL);
}",971.0,982.0,1.0,1.0,12.0,11,6,15,6,1,7,4,5,5,0,,0,7,2,1,1,void
5229,269944,benchmark,1,benchmark,"void benchmark (char*,char*,int)",redis-benchmark.c,"static void benchmark(const char *title, char *cmd, int len) {
    client c;

    config.title = title;
    config.requests_issued = 0;
    config.requests_finished = 0;
    config.previous_requests_finished = 0;
    config.last_printed_bytes = 0;
    hdr_init(
        CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,  // Minimum value
        CONFIG_LATENCY_HISTOGRAM_MAX_VALUE,  // Maximum value
        config.precision,  // Number of significant figures
        &config.latency_histogram);  // Pointer to initialise
    hdr_init(
        CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,  // Minimum value
        CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE,  // Maximum value
        config.precision,  // Number of significant figures
        &config.current_sec_latency_histogram);  // Pointer to initialise

    if (config.num_threads) initBenchmarkThreads();

    int thread_id = config.num_threads > 0 ? 0 : -1;
    c = createClient(cmd,len,NULL,thread_id);
    createMissingClients(c);

    config.start = mstime(...",984.0,1020.0,1.0,8.0,37.0,37,8,29,7,22,51,6,6,10,9,,0,45,6,3,3,void
5230,270430,freeClusterNodes,1,freeClusterNodes,void freeClusterNodes (void),redis-benchmark.c,"static void freeClusterNodes(void) {
    int i = 0;
    for (; i < config.cluster_node_count; i++) {
        clusterNode *n = config.cluster_nodes[i];
        if (n) freeClusterNode(n);
    }
    zfree(config.cluster_nodes);
    config.cluster_nodes = NULL;
}",1099.0,1107.0,1.0,1.0,9.0,9,4,11,4,1,10,3,4,2,2,,0,8,2,1,1,void
5231,270471,addClusterNode,1,addClusterNode,clusterNode addClusterNode (clusterNode*),redis-benchmark.c,"static clusterNode **addClusterNode(clusterNode *node) {
    int count = config.cluster_node_count + 1;
    config.cluster_nodes = zrealloc(config.cluster_nodes,
                                    count * sizeof(*node));
    if (!config.cluster_nodes) return NULL;
    config.cluster_nodes[config.cluster_node_count++] = node;
    return config.cluster_nodes;
}",1109.0,1116.0,1.0,1.0,8.0,17,9,12,4,1,15,2,2,2,1,,0,15,2,1,1,clusterNode
5232,270519,fetchClusterConfiguration,1,fetchClusterConfiguration,int fetchClusterConfiguration (void),redis-benchmark.c,"static int fetchClusterConfiguration(void) {
    int success = 1;
    redisContext *ctx = NULL;
    redisReply *reply =  NULL;
    ctx = getRedisContext(config.conn_info.hostip, config.conn_info.hostport, config.hostsocket);
    if (ctx == NULL) {
        exit(1);
    }
    clusterNode *firstNode = createClusterNode((char *) config.conn_info.hostip,
                                               config.conn_info.hostport);
    if (!firstNode) {success = 0; goto cleanup;}
    reply = redisCommand(ctx, ""CLUSTER NODES"");
    success = (reply != NULL);
    if (!success) goto cleanup;
    success = (reply->type != REDIS_REPLY_ERROR);
    if (!success) {
        if (config.hostsocket == NULL) {
            fprintf(stderr, ""Cluster node %s:%d replied with error:\n%s\n"",
                    config.conn_info.hostip, config.conn_info.hostport, reply->str);
        } else {
            fprintf(stderr, ""Cluster node %s replied with error:\n%s\n"",
                    config.hostsocket, reply->st...",1121.0,1285.0,1.0,1.0,165.0,156,20,185,30,1,42,46,73,7,9,,0,41,2,1,1,int
5233,271756,genBenchmarkRandomData,1,genBenchmarkRandomData,"void genBenchmarkRandomData (char*,int)",redis-benchmark.c,"static void genBenchmarkRandomData(char *data, int count) {
    static uint32_t state = 1234;
    int i = 0;

    while (count--) {
        state = (state*1103515245+12345);
        data[i++] = '0'+((state>>16)&63);
    }
}",1402.0,1410.0,1.0,1.0,9.0,12,8,8,4,1,0,2,2,0,0,,0,0,4,2,2,void
5234,271793,parseOptions,1,parseOptions,"int parseOptions (int,char**)",redis-cli.c,"static int parseOptions(int argc, char **argv) {
    int i;

    for (i = 1; i < argc; i++) {
        int lastarg = i==argc-1;

        if (!strcmp(argv[i],""-h"") && !lastarg) {
            sdsfree(config.conn_info.hostip);
            config.conn_info.hostip = sdsnew(argv[++i]);
        } else if (!strcmp(argv[i],""-h"") && lastarg) {
            usage(0);
        } else if (!strcmp(argv[i],""--help"")) {
            usage(0);
        } else if (!strcmp(argv[i],""-x"")) {
            config.stdin_lastarg = 1;
        } else if (!strcmp(argv[i], ""-X"") && !lastarg) {
            config.stdin_tag_arg = 1;
            config.stdin_tag_name = argv[++i];
        } else if (!strcmp(argv[i],""-p"") && !lastarg) {
            config.conn_info.hostport = atoi(argv[++i]);
            if (config.conn_info.hostport < 0 || config.conn_info.hostport > 65535) {
                fprintf(stderr, ""Invalid server port.\n"");
                exit(1);
            }
        } else if (!strcmp(argv[i],""-s"") && !last...",2638.0,2969.0,1.0,28.0,332.0,14,8,19,7,1,2,5,7,0,0,,0,2,4,2,2,int
5235,272914,test_is_selected,1,test_is_selected,int test_is_selected (char*),redis-benchmark.c,"int test_is_selected(const char *name) {
    char buf[256];
    int l = strlen(name);

    if (config.tests == NULL) return 1;
    buf[0] = ',';
    memcpy(buf+1,name,l);
    buf[l+1] = ',';
    buf[l+2] = '\0';
    return strstr(config.tests,buf) != NULL;
}",1721.0,1731.0,1.0,1.0,11.0,14,6,15,5,31,4,2,2,2,0,,0,4,2,1,1,int
5236,272967,main,1,main,"int main (int,char**)",server.c,"int main(int argc, char **argv) {
    struct timeval tv;
    int j;
    char config_from_stdin = 0;

#ifdef REDIS_TEST
    if (argc >= 3 && !strcasecmp(argv[1], ""test"")) {
        int flags = 0;
        for (j = 3; j < argc; j++) {
            char *arg = argv[j];
            if (!strcasecmp(arg, ""--accurate"")) flags |= REDIS_TEST_ACCURATE;
            else if (!strcasecmp(arg, ""--large-memory"")) flags |= REDIS_TEST_LARGE_MEMORY;
            else if (!strcasecmp(arg, ""--valgrind"")) flags |= REDIS_TEST_VALGRIND;
        }

        if (!strcasecmp(argv[2], ""all"")) {
            int numtests = sizeof(redisTests)/sizeof(struct redisTest);
            for (j = 0; j < numtests; j++) {
                redisTests[j].failed = (redisTests[j].proc(argc,argv,flags) != 0);
            }

            /* Report tests result */
            int failed_num = 0;
            for (j = 0; j < numtests; j++) {
                if (redisTests[j].failed) {
                    failed_num++;
                  ...",7036.0,7365.0,1.0,4.0,330.0,249,22,318,23,0,237,49,94,70,83,,0,202,4,2,2,int
5237,274155,consumeNewline,1,consumeNewline,int consumeNewline (char*),redis-check-aof.c,"int consumeNewline(char *buf) {
    if (strncmp(buf,""\r\n"",2) != 0) {
        ERROR(""Expected \\r\\n, got: %02x%02x"",buf[0],buf[1]);
        return 0;
    }
    line += 1;
    return 1;
}",63.0,70.0,1.0,8.0,8.0,7,5,10,5,2,4,2,2,0,0,,0,4,2,1,1,int
5238,274199,readLong,1,readLong,"int readLong (FILE*,char,long*)",redis-check-aof.c,"int readLong(FILE *fp, char prefix, long *target) {
    char buf[128], *eptr;
    epos = ftello(fp);
    if (fgets(buf,sizeof(buf),fp) == NULL) {
        return 0;
    }
    if (buf[0] != prefix) {
        ERROR(""Expected prefix '%c', got: '%c'"",prefix,buf[0]);
        return 0;
    }
    *target = strtol(buf+1,&eptr,10);
    return consumeNewline(eptr);
}",72.0,84.0,1.0,8.0,13.0,13,9,20,9,2,5,3,3,0,1,,0,4,6,3,3,int
5239,274267,readBytes,1,readBytes,"int readBytes (FILE*,char*,long)",redis-check-aof.c,"int readBytes(FILE *fp, char *target, long length) {
    long real;
    epos = ftello(fp);
    real = fread(target,1,length,fp);
    if (real != length) {
        ERROR(""Expected to read %ld bytes, got %ld bytes"",length,real);
        return 0;
    }
    return 1;
}",86.0,95.0,1.0,8.0,10.0,6,4,16,7,1,4,2,2,0,0,,0,4,6,3,3,int
5240,274315,readString,1,readString,"int readString (FILE*,char**)",redis-check-aof.c,"int readString(FILE *fp, char** target) {
    long len;
    *target = NULL;
    if (!readLong(fp,'$',&len)) {
        return 0;
    }

    if (len < 0 || len > LONG_MAX - 2) {
        ERROR(""Expected to read string of %ld bytes, which is not in the suitable range"",len);
        return 0;
    }

    /* Increase length to also consume \r\n */
    len += 2;
    *target = (char*)zmalloc(len);
    if (!readBytes(fp,*target,len)) {
        zfree(*target);
        *target = NULL;
        return 0;
    }
    if (!consumeNewline(*target+len-2)) {
        zfree(*target);
        *target = NULL;
        return 0;
    }
    (*target)[len-2] = '\0';
    return 1;
}",97.0,124.0,1.0,8.0,28.0,31,13,30,8,1,9,5,5,3,6,,0,7,4,2,2,int
5241,274424,readArgc,1,readArgc,"int readArgc (FILE*,long*)",redis-check-aof.c,"int readArgc(FILE *fp, long *target) {
    return readLong(fp,'*',target);
}",126.0,128.0,1.0,1.0,3.0,0,0,2,2,1,1,1,1,0,1,,0,0,4,2,2,int
5242,274435,processRESP,1,processRESP,"int processRESP (FILE*,char*,int*)",redis-check-aof.c,"int processRESP(FILE *fp, char *filename, int *out_multi) {
    long argc;
    char *str;

    if (!readArgc(fp, &argc)) return 0;

    for (int i = 0; i < argc; i++) {
        if (!readString(fp, &str)) return 0;
        if (i == 0) {
            if (strcasecmp(str, ""multi"") == 0) {
                if ((*out_multi)++) {
                    ERROR(""Unexpected MULTI in AOF %s"", filename);
                    zfree(str);
                    return 0;
                }
            } else if (strcasecmp(str, ""exec"") == 0) {
                if (--(*out_multi)) {
                    ERROR(""Unexpected EXEC in AOF %s"", filename);
                    zfree(str);
                    return 0;
                }
            }
        }
        zfree(str);
    }

    return 1;
}",137.0,164.0,1.0,20.0,28.0,13,9,19,9,0,7,7,14,2,4,,0,5,6,3,3,int
5243,274555,processAnnotations,1,processAnnotations,"int processAnnotations (FILE*,char*,int)",redis-check-aof.c,"int processAnnotations(FILE *fp, char *filename, int last_file) {
    char buf[AOF_ANNOTATION_LINE_MAX_LEN];

    epos = ftello(fp);
    if (fgets(buf, sizeof(buf), fp) == NULL) {
        printf(""Failed to read annotations from AOF %s, aborting...\n"", filename);
        exit(1);
    }

    if (to_timestamp && strncmp(buf, ""#TS:"", 4) == 0) {
        char *endptr;
        errno = 0;
        time_t ts = strtol(buf+4, &endptr, 10);
        if (errno != 0 || *endptr != '\r') {
            printf(""Invalid timestamp annotation\n"");
            exit(1);
        }
        if (ts <= to_timestamp) return 1;
        if (epos == 0) {
            printf(""AOF %s has nothing before timestamp %ld, ""
                    ""aborting...\n"", filename, to_timestamp);
            exit(1);
        }
        if (!last_file) {
            printf(""Failed to truncate AOF %s to timestamp %ld to offset %ld because it is not the last file.\n"",
                filename, to_timestamp, (long int)epos);
            pri...",175.0,215.0,1.0,13.0,41.0,19,13,28,10,1,9,8,13,4,0,,0,9,6,3,3,int
5244,274673,checkSingleAof,1,checkSingleAof,"int checkSingleAof (char*,char*,int,int,int)",redis-check-aof.c,"int checkSingleAof(char *aof_filename, char *aof_filepath, int last_file, int fix, int preamble) {
    off_t pos = 0, diff;
    int multi = 0;
    char buf[2];

    FILE *fp = fopen(aof_filepath, ""r+"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s, aborting...\n"", aof_filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp),&sb) == -1) {
        printf(""Cannot stat file: %s, aborting...\n"", aof_filename);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        return AOF_CHECK_EMPTY;
    }

    if (preamble) {
        char *argv[2] = {NULL, aof_filepath};
        if (redis_check_rdb_main(2, argv, fp) == C_ERR) {
            printf(""RDB preamble of AOF file is not sane, aborting.\n"");
            exit(1);
        } else {
            printf(""RDB preamble is OK, proceeding with AOF tail...\n"");
        }
    }

    while(1) {
        if (!multi) pos = ftello(fp);
        if (fgets(buf, sizeo...",222.0,330.0,1.0,11.0,109.0,49,15,79,22,3,11,22,37,5,2,,0,11,10,5,5,int
5245,275022,fileIsRDB,1,fileIsRDB,int fileIsRDB (char*),redis-check-aof.c,"int fileIsRDB(char *filepath) {
    FILE *fp = fopen(filepath, ""r"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s\n"", filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        printf(""Cannot stat file: %s\n"", filepath);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        fclose(fp);
        return 0;
    }

    if (size >= 8) {    /* There must be at least room for the RDB header. */
        char sig[5];
        int rdb_file = fread(sig, sizeof(sig), 1, fp) == 1 &&
                            memcmp(sig, ""REDIS"", sizeof(sig)) == 0;
        if (rdb_file) {
            fclose(fp);
            return 1;
        } 
    }

    fclose(fp);
    return 0;
}",336.0,367.0,1.0,11.0,32.0,15,8,23,8,1,0,6,7,0,0,,0,0,2,1,1,int
5246,275114,fileIsManifest,1,fileIsManifest,int fileIsManifest (char*),redis-check-aof.c,"int fileIsManifest(char *filepath) {
    int is_manifest = 0;
    FILE *fp = fopen(filepath, ""r"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s\n"", filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        printf(""Cannot stat file: %s\n"", filepath);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        fclose(fp);
        return 0;
    }

    char buf[MANIFEST_MAX_LINE+1];
    while (1) {
        if (fgets(buf, MANIFEST_MAX_LINE+1, fp) == NULL) {
            if (feof(fp)) {
                break;
            } else {
                printf(""Cannot read file: %s\n"", filepath);
                exit(1);
            }
        }

        /* Skip comments lines */
        if (buf[0] == '#') {
            continue;
        } else if (!memcmp(buf, ""file"", strlen(""file""))) {
            is_manifest = 1;
        }
    }

    fclose(fp);
    return is_manifest;
}",371.0,412.0,1.0,11.0,42.0,13,7,21,8,1,0,10,12,0,0,,0,0,2,1,1,int
5247,275227,getInputFileType,1,getInputFileType,input_file_type getInputFileType (char*),redis-check-aof.c,"input_file_type getInputFileType(char *filepath) {
    if (fileIsManifest(filepath)) {
        return AOF_MULTI_PART;
    } else if (fileIsRDB(filepath)) {
        return AOF_RDB_PREAMBLE;
    } else {
        return AOF_RESP;
    }
}",422.0,430.0,1.0,1.0,9.0,0,0,2,2,1,1,2,2,1,1,,0,1,2,1,1,input_file_type
5248,275250,printAofStyle,1,printAofStyle,"void printAofStyle (int,char*,char*)",redis-check-aof.c,"void printAofStyle(int ret, char *aofFileName, char *aofType) {
    if (ret == AOF_CHECK_OK) {
        printf(""%s %s is valid\n"", aofType, aofFileName);
    } else if (ret == AOF_CHECK_EMPTY) {
        printf(""%s %s is empty\n"", aofType, aofFileName);
    } else if (ret == AOF_CHECK_TIMESTAMP_TRUNCATED) {
        printf(""Successfully truncated AOF %s to timestamp %ld\n"",
            aofFileName, to_timestamp);
    } else if (ret == AOF_CHECK_TRUNCATED) {
        printf(""Successfully truncated AOF %s\n"", aofFileName);
    }
}",432.0,443.0,1.0,15.0,12.0,1,1,3,3,3,0,2,2,0,0,,0,0,6,3,3,void
5249,275306,checkMultiPartAof,1,checkMultiPartAof,"void checkMultiPartAof (char*,char*,int)",redis-check-aof.c,"void checkMultiPartAof(char *dirpath, char *manifest_filepath, int fix) {
    int total_num = 0, aof_num = 0, last_file;
    int ret;

    printf(""Start checking Multi Part AOF\n"");
    aofManifest *am = aofLoadManifestFromFile(manifest_filepath);

    if (am->base_aof_info) total_num++;
    if (am->incr_aof_list) total_num += listLength(am->incr_aof_list);

    if (am->base_aof_info) {
        sds aof_filename = am->base_aof_info->file_name;
        sds aof_filepath = makePath(dirpath, aof_filename);
        last_file = ++aof_num == total_num;
        int aof_preable = fileIsRDB(aof_filepath);

        printf(""Start to check BASE AOF (%s format).\n"", aof_preable ? ""RDB"":""RESP"");
        ret = checkSingleAof(aof_filename, aof_filepath, last_file, fix, aof_preable);
        printAofStyle(ret, aof_filename, (char *)""BASE AOF"");
        sdsfree(aof_filepath);
    }

    if (listLength(am->incr_aof_list)) {
        listNode *ln;
        listIter li;

        printf(""Start to check INCR ...",456.0,497.0,1.0,40.0,42.0,42,10,57,15,1,24,6,7,6,13,,0,18,6,3,3,void
5250,275485,checkOldStyleAof,1,checkOldStyleAof,"void checkOldStyleAof (char*,int,int)",redis-check-aof.c,"void checkOldStyleAof(char *filepath, int fix, int preamble) {
    printf(""Start checking Old-Style AOF\n"");
    int ret = checkSingleAof(filepath, filepath, 1, fix, preamble);
    printAofStyle(ret, filepath, (char *)""AOF"");
}",502.0,506.0,1.0,1.0,5.0,2,2,7,4,2,2,1,1,0,2,,0,1,6,3,3,void
5251,275509,redis_check_aof_main,1,redis_check_aof_main,"int redis_check_aof_main (int,char**)",redis-check-aof.c,"int redis_check_aof_main(int argc, char **argv) {
    char *filepath;
    char temp_filepath[PATH_MAX + 1];
    char *dirpath;
    int fix = 0;

    if (argc < 2) {
        goto invalid_args;
    } else if (argc == 2) {
        filepath = argv[1];
    } else if (argc == 3) {
        if (!strcmp(argv[1], ""--fix"")) {
            filepath = argv[2];
            fix = 1;
        } else {
            goto invalid_args;
        }
    } else if (argc == 4) {
        if (!strcmp(argv[1], ""--truncate-to-timestamp"")) {
            char *endptr;
            errno = 0;
            to_timestamp = strtol(argv[2], &endptr, 10);
            if (errno != 0 || *endptr != '\0') {
                printf(""Invalid timestamp, aborting...\n"");
                exit(1);
            }
            filepath = argv[3];
        } else {
            goto invalid_args;
        }
    } else {
        goto invalid_args;
    }

    /* In the glibc implementation dirname may modify their argument. */
    memcpy(temp_fi...",508.0,566.0,1.0,1.0,59.0,6,4,21,10,0,4,7,3,0,4,,0,1,4,2,2,int
5252,275688,createSharedObjects,1,createSharedObjects,void createSharedObjects (void),server.c,"void createSharedObjects(void) {
    int j;

    /* Shared command responses */
    shared.ok = createObject(OBJ_STRING,sdsnew(""+OK\r\n""));
    shared.emptybulk = createObject(OBJ_STRING,sdsnew(""$0\r\n\r\n""));
    shared.czero = createObject(OBJ_STRING,sdsnew("":0\r\n""));
    shared.cone = createObject(OBJ_STRING,sdsnew("":1\r\n""));
    shared.emptyarray = createObject(OBJ_STRING,sdsnew(""*0\r\n""));
    shared.pong = createObject(OBJ_STRING,sdsnew(""+PONG\r\n""));
    shared.queued = createObject(OBJ_STRING,sdsnew(""+QUEUED\r\n""));
    shared.emptyscan = createObject(OBJ_STRING,sdsnew(""*2\r\n$1\r\n0\r\n*0\r\n""));
    shared.space = createObject(OBJ_STRING,sdsnew("" ""));
    shared.plus = createObject(OBJ_STRING,sdsnew(""+""));

    /* Shared command error responses */
    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(
        ""-WRONGTYPE Operation against a key holding the wrong kind of value\r\n""));
    shared.err = createObject(OBJ_STRING,sdsnew(""-ERR\r\n""));
    shared.nokeyerr = c...",1824.0,1988.0,1.0,29.0,165.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
5253,275759,rdbShowGenericInfo,1,rdbShowGenericInfo,void rdbShowGenericInfo (void),redis-check-rdb.c,"void rdbShowGenericInfo(void) {
    printf(""[info] %lu keys read\n"", rdbstate.keys);
    printf(""[info] %lu expires\n"", rdbstate.expires);
    printf(""[info] %lu already expired\n"", rdbstate.already_expired);
}",105.0,109.0,1.0,1.0,5.0,3,1,3,1,1,3,1,1,0,0,,0,3,2,1,1,void
5254,275867,rdbCheckInfo,1,rdbCheckInfo,void rdbCheckInfo (char*...),redis-check-rdb.c,"void rdbCheckInfo(const char *fmt, ...) {
    char msg[1024];
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    printf(""[offset %llu] %s\n"",
        (unsigned long long) (rdbstate.rio ?
            rdbstate.rio->processed_bytes : 0), msg);
}",140.0,151.0,1.0,1.0,12.0,6,5,10,4,3,2,1,1,0,0,,0,2,2,1,1,void
5255,275926,rdbCheckHandleCrash,1,rdbCheckHandleCrash,"void rdbCheckHandleCrash (int,siginfo_t*,void*)",redis-check-rdb.c,"void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {
    UNUSED(sig);
    UNUSED(info);
    UNUSED(secret);

    rdbCheckError(""Server crash checking the specified RDB file!"");
    exit(1);
}",167.0,174.0,1.0,4.0,8.0,3,1,6,3,0,1,1,1,0,1,,0,0,6,3,3,void
5256,275955,rdbCheckSetupSignals,1,rdbCheckSetupSignals,void rdbCheckSetupSignals (void),redis-check-rdb.c,"void rdbCheckSetupSignals(void) {
    struct sigaction act;

    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = rdbCheckHandleCrash;
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
}",176.0,187.0,1.0,1.0,12.0,13,4,21,10,1,0,1,1,0,0,,0,0,2,1,1,void
5257,276005,redis_check_rdb,1,redis_check_rdb,"int redis_check_rdb (char*,FILE*)",redis-check-rdb.c,"int redis_check_rdb(char *rdbfilename, FILE *fp) {
    uint64_t dbid;
    int selected_dbid = -1;
    int type, rdbver;
    char buf[1024];
    long long expiretime, now = mstime();
    static rio rdb; /* Pointed by global struct riostate. */
    struct stat sb;

    int closefile = (fp == NULL);
    if (fp == NULL && (fp = fopen(rdbfilename,""r"")) == NULL) return 1;

    if (fstat(fileno(fp), &sb) == -1)
        sb.st_size = 0;

    startLoadingFile(sb.st_size, rdbfilename, RDBFLAGS_NONE);
    rioInitWithFile(&rdb,fp);
    rdbstate.rio = &rdb;
    rdb.update_cksum = rdbLoadProgressCallback;
    if (rioRead(&rdb,buf,9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf,""REDIS"",5) != 0) {
        rdbCheckError(""Wrong signature trying to load DB from file"");
        goto err;
    }
    rdbver = atoi(buf+5);
    if (rdbver < 1 || rdbver > RDB_VERSION) {
        rdbCheckError(""Can't handle RDB format version %d"",rdbver);
        goto err;
    }

    expiretime = -1;
    while(1) {
...",193.0,386.0,1.0,46.0,194.0,93,16,83,19,1,33,29,30,7,19,,0,22,4,2,2,int
5258,276769,checkRdbVersion,1,checkRdbVersion,sds checkRdbVersion (void),redis-check-rdb.c,"static sds checkRdbVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",388.0,400.0,1.0,45.0,13.0,4,1,10,2,0,8,3,4,2,8,,0,8,2,1,1,sds
5259,276813,redis_check_rdb_main,1,redis_check_rdb_main,"int redis_check_rdb_main (int,char**,FILE*)",redis-check-rdb.c,"int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
    struct timeval tv;

    if (argc != 2 && fp == NULL) {
        fprintf(stderr, ""Usage: %s <rdb-file-name>\n"", argv[0]);
        exit(1);
    } else if (!strcmp(argv[1],""-v"") || !strcmp(argv[1], ""--version"")) {
        sds version = checkRdbVersion();
        printf(""redis-check-rdb %s\n"", version);
        sdsfree(version);
        exit(0);
    }

    gettimeofday(&tv, NULL);
    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());

    /* In order to call the loading functions we need to create the shared
     * integer objects, however since this function may be called from
     * an already initialized Redis instance, check if we really need to. */
    if (shared.integers[0] == NULL)
        createSharedObjects();
    server.loading_process_events_interval_bytes = 0;
    server.sanitize_dump_payload = SANITIZE_DUMP_YES;
    rdbCheckMode = 1;
    rdbCheckInfo(""Checking RDB file %s"", argv[1]);
   ...",414.0,447.0,1.0,35.0,34.0,26,13,22,10,1,8,5,5,0,7,,0,2,6,3,3,int
5260,277087,dictSdsDestructor,1,dictSdsDestructor,"void dictSdsDestructor (dict*,void*)",server.c,"void dictSdsDestructor(dict *d, void *val)
{
    UNUSED(d);
    sdsfree(val);
}",287.0,291.0,1.0,4.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5261,277120,createClusterManagerCommand,1,createClusterManagerCommand,"int createClusterManagerCommand (char*,int,char**)",redis-cli.c,"static int createClusterManagerCommand(char *cmdname, int argc, char **argv) {
    clusterManagerCommand *cmd = &config.cluster_manager_command;
    cmd->name = cmdname;
    cmd->argc = argc;
    cmd->argv = argc ? argv : NULL;
    if (isColorTerm()) cmd->flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;

    if (config.stdin_lastarg) {
        char **new_argv = zmalloc(sizeof(char*) * (cmd->argc+1));
        memcpy(new_argv, cmd->argv, sizeof(char*) * cmd->argc);

        cmd->stdin_arg = readArgFromStdin();
        new_argv[cmd->argc++] = cmd->stdin_arg;
        cmd->argv = new_argv;
    } else if (config.stdin_tag_arg) {
        int i = 0, tag_match = 0;
        cmd->stdin_arg = readArgFromStdin();

        for (; i < argc; i++) {
            if (strcmp(argv[i], config.stdin_tag_name) != 0) continue;

            tag_match = 1;
            cmd->argv[i] = (char *)cmd->stdin_arg;
            break;
        }

        if (!tag_match) {
            sdsfree(cmd->stdin_arg);
            fprintf...",3777.0,3811.0,1.0,37.0,35.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5262,277208,usage,1,usage,void usage (int),server.c,"void usage(void) {
    fprintf(stderr,""Usage: ./redis-server [/path/to/redis.conf] [options] [-]\n"");
    fprintf(stderr,""       ./redis-server - (read config from stdin)\n"");
    fprintf(stderr,""       ./redis-server -v or --version\n"");
    fprintf(stderr,""       ./redis-server -h or --help\n"");
    fprintf(stderr,""       ./redis-server --test-memory <megabytes>\n"");
    fprintf(stderr,""       ./redis-server --check-system\n"");
    fprintf(stderr,""\n"");
    fprintf(stderr,""Examples:\n"");
    fprintf(stderr,""       ./redis-server (run the server with default conf)\n"");
    fprintf(stderr,""       echo 'maxmemory 128mb' | ./redis-server -\n"");
    fprintf(stderr,""       ./redis-server /etc/redis/6379.conf\n"");
    fprintf(stderr,""       ./redis-server --port 7777\n"");
    fprintf(stderr,""       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\n"");
    fprintf(stderr,""       ./redis-server /etc/myredis.conf --loglevel verbose -\n"");
    fprintf(stderr,""       ./redis-server /etc/...",6391.0,6410.0,1.0,1.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5263,277213,slaveMode,1,slaveMode,void slaveMode (int),redis-cli.c,"static void slaveMode(int send_sync) {
    static char eofmark[RDB_EOF_MARK_SIZE];
    static char lastbytes[RDB_EOF_MARK_SIZE];
    static int usemark = 0;
    static int out_full_mode;
    unsigned long long payload = sendSync(context, send_sync, eofmark, &out_full_mode);
    char buf[1024];
    int original_output = config.output;
    char *info = out_full_mode ? ""Full resync"" : ""Partial resync"";

    if (out_full_mode == 1 && payload == 0) {
        /* SYNC with EOF marker or PSYNC +FULLRESYNC with EOF marker. */
        payload = ULLONG_MAX;
        memset(lastbytes,0,RDB_EOF_MARK_SIZE);
        usemark = 1;
        fprintf(stderr, ""%s with master, discarding ""
                        ""bytes of bulk transfer until EOF marker...\n"", info);
    } else if (out_full_mode == 1 && payload != 0) {
        /* SYNC without EOF marker or PSYNC +FULLRESYNC. */
        fprintf(stderr, ""%s with master, discarding %llu ""
                        ""bytes of bulk transfer...\n"", info, payload);
...",8501.0,8565.0,1.0,24.0,65.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5264,277228,cliConnect,1,cliConnect,int cliConnect (int),redis-cli.c,"static int cliConnect(int flags) {
    if (context == NULL || flags & CC_FORCE) {
        if (context != NULL) {
            redisFree(context);
            config.dbnum = 0;
            config.in_multi = 0;
            cliRefreshPrompt();
        }

        /* Do not use hostsocket when we got redirected in cluster mode */
        if (config.hostsocket == NULL ||
            (config.cluster_mode && config.cluster_reissue_command)) {
            context = redisConnect(config.conn_info.hostip,config.conn_info.hostport);
        } else {
            context = redisConnectUnix(config.hostsocket);
        }

        if (!context->err && config.tls) {
            const char *err = NULL;
            if (cliSecureConnection(context, config.sslconfig, &err) == REDIS_ERR && err) {
                fprintf(stderr, ""Could not negotiate a TLS connection: %s\n"", err);
                redisFree(context);
                context = NULL;
                return REDIS_ERR;
            }
        }

   ...",1654.0,1724.0,1.0,35.0,71.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,int
5265,277233,getInfoField,1,getInfoField,"char* getInfoField (char*,char*)",redis-cli.c,"static char *getInfoField(char *info, char *field) {
    char *p = strstr(info,field);
    char *n1, *n2;
    char *result;

    if (!p) return NULL;
    p += strlen(field)+1;
    n1 = strchr(p,'\r');
    n2 = strchr(p,',');
    if (n2 && n2 < n1) n1 = n2;
    result = zmalloc(sizeof(char)*(n1-p)+1);
    memcpy(result,p,(n1-p));
    result[n1-p] = '\0';
    return result;
}",9313.0,9327.0,1.0,1.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
5266,277239,getLongInfoField,1,getLongInfoField,"long getLongInfoField (char*,char*)",redis-cli.c,"static long getLongInfoField(char *info, char *field) {
    char *value = getInfoField(info,field);
    long l;

    if (!value) return LONG_MIN;
    l = strtol(value,NULL,10);
    zfree(value);
    return l;
}",9331.0,9339.0,1.0,1.0,9.0,0,0,0,0,9,0,1,1,0,0,,0,0,4,2,2,long
5267,277245,redis_strlcpy,1,redis_strlcpy,"size_t redis_strlcpy (char*,char*,size_t)",strl.c,"size_t
redis_strlcpy(char *dst, const char *src, size_t dsize)
{
    const char *osrc = src;
    size_t nleft = dsize;

    /* Copy as many bytes as will fit. */
    if (nleft != 0) {
        while (--nleft != 0) {
            if ((*dst++ = *src++) == '\0')
                break;
        }
    }

    /* Not enough room in dst, add NUL and traverse rest of src. */
    if (nleft == 0) {
        if (dsize != 0)
            *dst = '\0';        /* NUL-terminate dst */
        while (*src++)
            ;
    }

    return(src - osrc - 1); /* count does not include NUL */
}",23.0,46.0,1.0,1.0,24.0,0,0,0,0,12,0,1,1,0,0,,0,0,6,3,3,size_t
5268,277252,cliPushHandler,1,cliPushHandler,"void cliPushHandler (void*,void*)",redis-cli.c,"static void cliPushHandler(void *privdata, void *reply) {
    UNUSED(privdata);
    sds out;

    if (config.output == OUTPUT_STANDARD && isInvalidateReply(reply)) {
        out = cliFormatInvalidateTTY(reply);
    } else {
        out = cliFormatReply(reply, config.output, 0);
    }

    fwrite(out, sdslen(out), 1, stdout);

    freeReplyObject(reply);
    sdsfree(out);
}",2217.0,2231.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5269,277300,cliRefreshPrompt,1,cliRefreshPrompt,void cliRefreshPrompt (void),redis-cli.c,"static void cliRefreshPrompt(void) {
    if (config.eval_ldb) return;

    sds prompt = sdsempty();
    if (config.hostsocket != NULL) {
        prompt = sdscatfmt(prompt,""redis %s"",config.hostsocket);
    } else {
        char addr[256];
        formatAddr(addr, sizeof(addr), config.conn_info.hostip, config.conn_info.hostport);
        prompt = sdscatlen(prompt,addr,strlen(addr));
    }

    /* Add [dbnum] if needed */
    if (config.dbnum != 0)
        prompt = sdscatfmt(prompt,""[%i]"",config.dbnum);

    /* Add TX if in transaction state*/
    if (config.in_multi)  
        prompt = sdscatlen(prompt,""(TX)"",4);

    if (config.pubsub_mode)
        prompt = sdscatfmt(prompt,""(subscribed mode)"");

    /* Copy the prompt in the static buffer. */
    prompt = sdscatlen(prompt,""> "",2);
    snprintf(config.prompt,sizeof(config.prompt),""%s"",prompt);
    sdsfree(prompt);
}",320.0,347.0,1.0,1.0,28.0,18,4,23,3,5,25,6,6,10,7,,0,24,2,1,1,void
5270,277408,getDotfilePath,1,getDotfilePath,"sds getDotfilePath (char*,char*)",redis-cli.c,"static sds getDotfilePath(char *envoverride, char *dotfilename) {
    char *path = NULL;
    sds dotPath = NULL;

    /* Check the env for a dotfile override. */
    path = getenv(envoverride);
    if (path != NULL && *path != '\0') {
        if (!strcmp(""/dev/null"", path)) {
            return NULL;
        }

        /* If the env is set, return it. */
        dotPath = sdsnew(path);
    } else {
        char *home = getenv(""HOME"");
        if (home != NULL && *home != '\0') {
            /* If no override is set use $HOME/<dotfilename>. */
            dotPath = sdscatprintf(sdsempty(), ""%s/%s"", home, dotfilename);
        }
    }
    return dotPath;
}",357.0,378.0,1.0,1.0,22.0,9,5,14,4,2,1,3,4,0,1,,0,1,4,2,2,sds
5271,277575,cliVersion,1,cliVersion,sds cliVersion (void),redis-cli.c,"static sds cliVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",427.0,439.0,1.0,45.0,13.0,4,1,10,2,1,8,3,4,2,8,,0,8,2,1,1,sds
5272,277619,cliLegacyIntegrateHelp,1,cliLegacyIntegrateHelp,void cliLegacyIntegrateHelp (void),redis-cli.c,"static void cliLegacyIntegrateHelp(void) {
    if (cliConnect(CC_QUIET) == REDIS_ERR) return;

    redisReply *reply = redisCommand(context, ""COMMAND"");
    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;

    /* Scan the array reported by COMMAND and fill only the entries that
     * don't already match what we have. */
    for (size_t j = 0; j < reply->elements; j++) {
        redisReply *entry = reply->element[j];
        if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
            entry->element[0]->type != REDIS_REPLY_STRING ||
            entry->element[1]->type != REDIS_REPLY_INTEGER ||
            entry->element[3]->type != REDIS_REPLY_INTEGER) return;
        char *cmdname = entry->element[0]->str;
        int i;

        for (i = 0; i < helpEntriesLen; i++) {
            helpEntry *he = helpEntries+i;
            if (!strcasecmp(he->argv[0],cmdname))
                break;
        }
        if (i != helpEntriesLen) continue;

        helpEntries...",447.0,500.0,1.0,19.0,54.0,117,17,72,18,1,38,13,19,4,8,,0,37,2,1,1,void
5273,277960,sdscat_orempty,1,sdscat_orempty,"sds sdscat_orempty (sds,char*)",redis-cli.c,"static sds sdscat_orempty(sds params, const char *value) {
    if (value[0] == '\0') {
        return sdscat(params, ""\""\"""");
    }
    return sdscat(params, value);
}",503.0,508.0,1.0,1.0,6.0,2,2,4,2,2,2,2,2,0,2,,0,0,4,2,2,sds
5274,277981,makeHint,1,makeHint,"sds makeHint (char**,int,int,commandDocs)",redis-cli.c,"static sds makeHint(char **inputargv, int inputargc, int cmdlen, struct commandDocs docs) {
    sds hint;

    if (docs.args) {
        /* Remove arguments from the returned hint to show only the
         * ones the user did not yet type. */
        clearMatchedArgs(docs.args, docs.numargs);
        hint = sdsempty();
        int matchedWords = 0;
        if (inputargv && inputargc)
            matchedWords = matchArgs(inputargv + cmdlen, inputargc - cmdlen, docs.args, docs.numargs);
        if (matchedWords == inputargc - cmdlen) {
            hint = addHintForArguments(hint, docs.args, docs.numargs, "" "");
        }
        return hint;
    }

    /* If arg specs are not available, show the hint string until the user types something. */
    if (inputargc <= cmdlen) {
        hint = sdsnew(docs.params);
    } else {
        hint = sdsempty();
    }
    return hint;
}",1441.0,1465.0,1.0,1.0,25.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,sds
5275,277989,cliAddCommandDocArg,1,cliAddCommandDocArg,"void cliAddCommandDocArg (cliCommandArg*,redisReply*)",redis-cli.c,"static void cliAddCommandDocArg(cliCommandArg *cmdArg, redisReply *argMap) {
    if (argMap->type != REDIS_REPLY_MAP && argMap->type != REDIS_REPLY_ARRAY) {
        return;
    }

    for (size_t i = 0; i < argMap->elements; i += 2) {
        assert(argMap->element[i]->type == REDIS_REPLY_STRING);
        char *key = argMap->element[i]->str;
        if (!strcmp(key, ""name"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->name = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""display_text"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->display_text = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""token"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->token = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""type"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY...",520.0,580.0,1.0,37.0,61.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5276,277995,cliMakeCommandDocArgs,1,cliMakeCommandDocArgs,"void cliMakeCommandDocArgs (redisReply*,cliCommandArg*)",redis-cli.c,"static void cliMakeCommandDocArgs(redisReply *arguments, cliCommandArg *result) {
    for (size_t j = 0; j < arguments->elements; j++) {
        cliAddCommandDocArg(&result[j], arguments->element[j]);
    }
}",514.0,518.0,1.0,1.0,5.0,7,5,7,3,0,1,2,2,0,1,,0,0,4,2,2,void
5277,278481,cliFillInCommandHelpEntry,1,cliFillInCommandHelpEntry,"void cliFillInCommandHelpEntry (helpEntry*,char*,char*)",redis-cli.c,"static void cliFillInCommandHelpEntry(helpEntry *help, char *cmdname, char *subcommandname) {
    help->argc = subcommandname ? 2 : 1;
    help->argv = zmalloc(sizeof(sds) * help->argc);
    help->argv[0] = sdsnew(cmdname);
    sdstoupper(help->argv[0]);
    if (subcommandname) {
        /* Subcommand name may be two words separated by a pipe character. */
        char *pipe = strchr(subcommandname, '|');
        if (pipe != NULL) {
            help->argv[1] = sdsnew(pipe + 1);
        } else {
            help->argv[1] = sdsnew(subcommandname);
        }
        sdstoupper(help->argv[1]);
    }
    sds fullname = sdsnew(help->argv[0]);
    if (subcommandname) {
        fullname = sdscat(fullname, "" "");
        fullname = sdscat(fullname, help->argv[1]);
    }
    help->full = fullname;
    help->type = CLI_HELP_COMMAND;

    help->docs.name = help->full;
    help->docs.params = NULL;
    help->docs.args = NULL;
    help->docs.numargs = 0;
    help->docs.since = NULL;
}",583.0,611.0,1.0,17.0,29.0,48,9,36,7,2,25,4,5,0,8,,0,23,6,3,3,void
5278,278636,cliInitCommandHelpEntry,1,cliInitCommandHelpEntry,"helpEntry cliInitCommandHelpEntry (char*,char*,helpEntry*,redisReply*,dict*)",redis-cli.c,"static helpEntry *cliInitCommandHelpEntry(char *cmdname, char *subcommandname,
                                          helpEntry *next, redisReply *specs,
                                          dict *groups) {
    helpEntry *help = next++;
    cliFillInCommandHelpEntry(help, cmdname, subcommandname);

    assert(specs->type == REDIS_REPLY_MAP || specs->type == REDIS_REPLY_ARRAY);
    for (size_t j = 0; j < specs->elements; j += 2) {
        assert(specs->element[j]->type == REDIS_REPLY_STRING);
        char *key = specs->element[j]->str;
        if (!strcmp(key, ""summary"")) {
            redisReply *reply = specs->element[j + 1];
            assert(reply->type == REDIS_REPLY_STRING);
            help->docs.summary = sdsnew(reply->str);
        } else if (!strcmp(key, ""since"")) {
            redisReply *reply = specs->element[j + 1];
            assert(reply->type == REDIS_REPLY_STRING);
            help->docs.since = sdsnew(reply->str);
        } else if (!strcmp(key, ""group""))...",619.0,665.0,1.0,48.0,47.0,29,10,27,11,1,3,3,4,0,2,,0,2,10,5,5,helpEntry
5279,278985,cliCountCommands,1,cliCountCommands,size_t cliCountCommands (redisReply*),redis-cli.c,"static size_t cliCountCommands(redisReply* commandTable) {
    size_t numCommands = commandTable->elements / 2;

    /* The command docs table maps command names to a map of their specs. */    
    for (size_t i = 0; i < commandTable->elements; i += 2) {
        assert(commandTable->element[i]->type == REDIS_REPLY_STRING);  /* Command name. */
        assert(commandTable->element[i + 1]->type == REDIS_REPLY_MAP ||
               commandTable->element[i + 1]->type == REDIS_REPLY_ARRAY);
        redisReply *map = commandTable->element[i + 1];
        for (size_t j = 0; j < map->elements; j += 2) {
            assert(map->element[j]->type == REDIS_REPLY_STRING);
            char *key = map->element[j]->str;
            if (!strcmp(key, ""subcommands"")) {
                redisReply *subcommands = map->element[j + 1];
                assert(subcommands->type == REDIS_REPLY_MAP || subcommands->type == REDIS_REPLY_ARRAY);
                numCommands += subcommands->elements / 2;
           ...",668.0,688.0,1.0,1.0,21.0,49,10,37,10,1,0,4,7,0,0,,0,0,2,1,1,size_t
5280,279129,helpEntryCompare,1,helpEntryCompare,"int helpEntryCompare (void*,void*)",redis-cli.c,"int helpEntryCompare(const void *entry1, const void *entry2) {
    helpEntry *i1 = (helpEntry *)entry1;
    helpEntry *i2 = (helpEntry *)entry2;
    return strcmp(i1->full, i2->full);
}",691.0,695.0,1.0,1.0,5.0,6,3,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
5281,279155,cliInitGroupHelpEntries,1,cliInitGroupHelpEntries,void cliInitGroupHelpEntries (dict*),redis-cli.c,"void cliInitGroupHelpEntries(dict *groups) {
    dictIterator *iter = dictGetIterator(groups);
    dictEntry *entry;
    helpEntry tmp;

    int numGroups = dictSize(groups);
    int pos = helpEntriesLen;
    helpEntriesLen += numGroups;
    helpEntries = zrealloc(helpEntries, sizeof(helpEntry)*helpEntriesLen);

    for (entry = dictNext(iter); entry != NULL; entry = dictNext(iter)) {
        tmp.argc = 1;
        tmp.argv = zmalloc(sizeof(sds));
        tmp.argv[0] = sdscatprintf(sdsempty(),""@%s"",(char *)dictGetKey(entry));
        tmp.full = tmp.argv[0];
        tmp.type = CLI_HELP_GROUP;
        tmp.docs.name = NULL;
        tmp.docs.params = NULL;
        tmp.docs.args = NULL;
        tmp.docs.numargs = 0;
        tmp.docs.summary = NULL;
        tmp.docs.since = NULL;
        tmp.docs.group = NULL;
        helpEntries[pos++] = tmp;
    }
    dictReleaseIterator(iter);
}",701.0,727.0,1.0,20.0,27.0,53,11,43,11,2,30,2,2,0,8,,0,29,2,1,1,void
5282,279311,cliInitCommandHelpEntries,1,cliInitCommandHelpEntries,"void cliInitCommandHelpEntries (redisReply*,dict*)",redis-cli.c,"void cliInitCommandHelpEntries(redisReply *commandTable, dict *groups) {
    helpEntry *next = helpEntries;
    for (size_t i = 0; i < commandTable->elements; i += 2) {
        assert(commandTable->element[i]->type == REDIS_REPLY_STRING);
        char *cmdname = commandTable->element[i]->str;

        assert(commandTable->element[i + 1]->type == REDIS_REPLY_MAP ||
               commandTable->element[i + 1]->type == REDIS_REPLY_ARRAY);
        redisReply *cmdspecs = commandTable->element[i + 1];
        next = cliInitCommandHelpEntry(cmdname, NULL, next, cmdspecs, groups);
    }
}",730.0,741.0,1.0,1.0,12.0,28,7,26,11,1,2,2,2,0,1,,0,2,4,2,2,void
5283,279398,versionIsSupported,1,versionIsSupported,"int versionIsSupported (sds,sds)",redis-cli.c,"static int versionIsSupported(sds version, sds since) {
    int i;
    char *versionPos = version;
    char *sincePos = since;
    if (!since) {
        return 1;
    }

    for (i = 0; i != 3; i++) {
        int versionPart = atoi(versionPos);
        int sincePart = atoi(sincePos);
        if (versionPart > sincePart) {
            return 1;
        } else if (sincePart > versionPart) {
            return 0;
        }
        versionPos = strchr(versionPos, '.');
        sincePos = strchr(sincePos, '.');
        if (!versionPos || !sincePos)
            return 0;
        versionPos++;
        sincePos++;
    }
    return 0;
}",745.0,769.0,1.0,1.0,25.0,15,6,21,7,4,0,5,7,0,0,,0,0,4,2,2,int
5284,279481,removeUnsupportedArgs,1,removeUnsupportedArgs,"void removeUnsupportedArgs (cliCommandArg*,int*,sds)",redis-cli.c,"static void removeUnsupportedArgs(struct cliCommandArg *args, int *numargs, sds version) {
    int i = 0, j;
    while (i != *numargs) {
        if (versionIsSupported(version, args[i].since)) {
            if (args[i].subargs) {
                removeUnsupportedArgs(args[i].subargs, &args[i].numsubargs, version);
            }
            i++;
            continue;
        }
        for (j = i; j != *numargs; j++) {
            args[j] = args[j + 1];
        }
        (*numargs)--;
    }
}",771.0,786.0,1.0,1.0,16.0,22,9,23,5,1,1,6,9,1,1,,0,1,6,3,3,void
5285,279555,cliLegacyInitCommandHelpEntry,1,cliLegacyInitCommandHelpEntry,"helpEntry cliLegacyInitCommandHelpEntry (char*,char*,helpEntry*,commandDocs*,dict*,sds)",redis-cli.c,"static helpEntry *cliLegacyInitCommandHelpEntry(char *cmdname, char *subcommandname,
                                                helpEntry *next, struct commandDocs *command,
                                                dict *groups, sds version) {
    helpEntry *help = next++;
    cliFillInCommandHelpEntry(help, cmdname, subcommandname);
    
    help->docs.summary = sdsnew(command->summary);
    help->docs.since = sdsnew(command->since);
    help->docs.group = sdsnew(command->group);
    sds group = sdsdup(help->docs.group);
    if (dictAdd(groups, group, NULL) != DICT_OK) {
        sdsfree(group);
    }

    if (command->args != NULL) {
        help->docs.args = command->args;
        help->docs.numargs = command->numargs;
        if (version)
            removeUnsupportedArgs(help->docs.args, &help->docs.numargs, version);
        help->docs.params = makeHint(NULL, 0, 0, help->docs);
    }

    if (command->subcommands != NULL) {
        for (size_t i = 0; command->subcom...",788.0,820.0,1.0,40.0,33.0,57,9,52,10,1,31,7,11,6,10,,0,28,12,6,6,helpEntry
5286,279744,cliLegacyInitCommandHelpEntries,1,cliLegacyInitCommandHelpEntries,"int cliLegacyInitCommandHelpEntries (commandDocs*,dict*,sds)",redis-cli.c,"int cliLegacyInitCommandHelpEntries(struct commandDocs *commands, dict *groups, sds version) {
    helpEntry *next = helpEntries;
    for (size_t i = 0; commands[i].name != NULL; i++) {
        if (!version || versionIsSupported(version, commands[i].since)) {
            next = cliLegacyInitCommandHelpEntry(commands[i].name, NULL, next, &commands[i], groups, version);
        }
    }
    return next - helpEntries;
}",822.0,830.0,1.0,1.0,9.0,15,8,21,7,1,4,3,4,1,2,,0,4,6,3,3,int
5287,279803,cliLegacyCountCommands,1,cliLegacyCountCommands,"size_t cliLegacyCountCommands (commandDocs*,sds)",redis-cli.c,"static size_t cliLegacyCountCommands(struct commandDocs *commands, sds version) {
    int numCommands = 0;
    for (size_t i = 0; commands[i].name != NULL; i++) {
        if (version && !versionIsSupported(version, commands[i].since)) {
            continue;
        }
        numCommands++;
        if (commands[i].subcommands != NULL) {
            numCommands += cliLegacyCountCommands(commands[i].subcommands, version);
        }
    }
    return numCommands;
}",835.0,847.0,1.0,1.0,13.0,16,8,18,5,1,1,5,6,1,1,,0,1,4,2,2,size_t
5288,279864,cliGetServerVersion,1,cliGetServerVersion,sds cliGetServerVersion (void),redis-cli.c,"static sds cliGetServerVersion(void) {
    static const char *key = ""\nredis_version:"";
    redisReply *serverInfo = NULL;
    char *pos;

    if (config.server_version != NULL) {
        return config.server_version;
    }

    if (!context) return NULL;
    serverInfo = redisCommand(context, ""INFO SERVER"");
    if (serverInfo == NULL || serverInfo->type == REDIS_REPLY_ERROR) {
        freeReplyObject(serverInfo);
        return sdsempty();
    }

    assert(serverInfo->type == REDIS_REPLY_STRING || serverInfo->type == REDIS_REPLY_VERB);
    sds info = serverInfo->str;

    /* Finds the first appearance of ""redis_version"" in the INFO SERVER reply. */
    pos = strstr(info, key);
    if (pos) {
        pos += strlen(key);
        char *end = strchr(pos, '\r');
        if (end) {
            sds version = sdsnewlen(pos, end - pos);
            freeReplyObject(serverInfo);
            config.server_version = version;
            return version;
        }
    }
    freeReplyObject(serv...",852.0,885.0,1.0,1.0,34.0,25,9,40,12,1,8,6,7,2,2,,0,7,2,1,1,sds
5289,279975,cliLegacyInitHelp,1,cliLegacyInitHelp,void cliLegacyInitHelp (dict*),redis-cli.c,"static void cliLegacyInitHelp(dict *groups) {
    sds serverVersion = cliGetServerVersion();
    
    /* Scan the commandDocs array and fill in the entries */
    helpEntriesLen = cliLegacyCountCommands(redisCommandTable, serverVersion);
    helpEntries = zmalloc(sizeof(helpEntry)*helpEntriesLen);

    helpEntriesLen = cliLegacyInitCommandHelpEntries(redisCommandTable, groups, serverVersion);
    cliInitGroupHelpEntries(groups);

    qsort(helpEntries, helpEntriesLen, sizeof(helpEntry), helpEntryCompare);
    dictRelease(groups);
}",887.0,899.0,1.0,1.0,13.0,7,3,16,6,2,14,1,1,0,6,,0,12,2,1,1,void
5290,280012,cliInitHelp,1,cliInitHelp,void cliInitHelp (void),redis-cli.c,"static void cliInitHelp(void) {
    /* Dict type for a set of strings, used to collect names of command groups. */
    dictType groupsdt = {
        dictSdsHash,                /* hash function */
        NULL,                       /* key dup */
        NULL,                       /* val dup */
        dictSdsKeyCompare,          /* key compare */
        dictSdsDestructor,          /* key destructor */
        NULL,                       /* val destructor */
        NULL                        /* allow to expand */
    };
    redisReply *commandTable;
    dict *groups;

    if (cliConnect(CC_QUIET) == REDIS_ERR) {
        /* Can not connect to the server, but we still want to provide
         * help, generate it only from the static cli_commands.c data instead. */
        groups = dictCreate(&groupsdt);
        cliLegacyInitHelp(groups);
        return;
    }
    commandTable = redisCommand(context, ""COMMAND DOCS"");
    if (commandTable == NULL || commandTable->type == REDIS_REPLY...",904.0,949.0,1.0,19.0,46.0,25,11,38,12,4,19,4,4,1,12,,0,13,2,1,1,void
5291,280120,cliOutputCommandHelp,1,cliOutputCommandHelp,"void cliOutputCommandHelp (commandDocs*,int)",redis-cli.c,"static void cliOutputCommandHelp(struct commandDocs *help, int group) {
    printf(""\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n"", help->name, help->params);
    printf(""  \x1b[33msummary:\x1b[0m %s\r\n"", help->summary);
    if (help->since != NULL) {
        printf(""  \x1b[33msince:\x1b[0m %s\r\n"", help->since);
    }
    if (group) {
        printf(""  \x1b[33mgroup:\x1b[0m %s\r\n"", help->group);
    }
}",952.0,961.0,1.0,1.0,10.0,7,2,8,3,1,6,3,3,1,0,,0,6,4,2,2,void
5292,280159,cliOutputGenericHelp,1,cliOutputGenericHelp,void cliOutputGenericHelp (void),redis-cli.c,"static void cliOutputGenericHelp(void) {
    sds version = cliVersion();
    printf(
        ""redis-cli %s\n""
        ""To get help about Redis commands type:\n""
        ""      \""help @<group>\"" to get a list of commands in <group>\n""
        ""      \""help <command>\"" for help on <command>\n""
        ""      \""help <tab>\"" to get a list of possible help topics\n""
        ""      \""quit\"" to exit\n""
        ""\n""
        ""To set redis-cli preferences:\n""
        ""      \"":set hints\"" enable online hints\n""
        ""      \"":set nohints\"" disable online hints\n""
        ""Set your preferences in ~/.redisclirc\n"",
        version
    );
    sdsfree(version);
}",964.0,981.0,1.0,1.0,18.0,1,1,3,1,1,2,1,1,0,2,,0,1,2,1,1,void
5293,280173,cliOutputHelp,1,cliOutputHelp,"void cliOutputHelp (int,char**)",redis-cli.c,"static void cliOutputHelp(int argc, char **argv) {
    int i, j;
    char *group = NULL;
    helpEntry *entry;
    struct commandDocs *help;

    if (argc == 0) {
        cliOutputGenericHelp();
        return;
    } else if (argc > 0 && argv[0][0] == '@') {
        group = argv[0]+1;
    }

    if (helpEntries == NULL) {
        /* Initialize the help using the results of the COMMAND command.
         * In case we are using redis-cli help XXX, we need to init it. */
        cliInitHelp();
    }

    assert(argc > 0);
    for (i = 0; i < helpEntriesLen; i++) {
        entry = &helpEntries[i];
        if (entry->type != CLI_HELP_COMMAND) continue;

        help = &entry->docs;
        if (group == NULL) {
            /* Compare all arguments */
            if (argc <= entry->argc) {
                for (j = 0; j < argc; j++) {
                    if (strcasecmp(argv[j],entry->argv[j]) != 0) break;
                }
                if (j == argc) {
                    cliOutputCommand...",984.0,1024.0,1.0,27.0,41.0,24,9,29,10,1,10,12,24,5,3,,0,7,4,2,2,void
5294,280320,completionCallback,1,completionCallback,"void completionCallback (char*,linenoiseCompletions*)",redis-cli.c,"static void completionCallback(const char *buf, linenoiseCompletions *lc) {
    size_t startpos = 0;
    int mask;
    int i;
    size_t matchlen;
    sds tmp;

    if (strncasecmp(buf,""help "",5) == 0) {
        startpos = 5;
        while (isspace(buf[startpos])) startpos++;
        mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
    } else {
        mask = CLI_HELP_COMMAND;
    }

    for (i = 0; i < helpEntriesLen; i++) {
        if (!(helpEntries[i].type & mask)) continue;

        matchlen = strlen(buf+startpos);
        if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
            tmp = sdsnewlen(buf,startpos);
            tmp = sdscat(tmp,helpEntries[i].full);
            linenoiseAddCompletion(lc,tmp);
            sdsfree(tmp);
        }
    }
}",1027.0,1053.0,1.0,15.0,27.0,22,9,30,9,0,7,7,9,3,3,,0,6,4,2,2,void
5295,280429,addHintForArgument,1,addHintForArgument,"sds addHintForArgument (sds,cliCommandArg*)",redis-cli.c,"static sds addHintForArgument(sds hint, cliCommandArg *arg) {
    if (arg->matched_all) {
        return hint;
    }

    /* Surround an optional arg with brackets, unless it's partially matched. */
    if ((arg->flags & CMD_ARG_OPTIONAL) && !arg->matched) {
        hint = sdscat(hint, ""["");
    }

    /* Start with the token, if present and not matched. */
    if (arg->token != NULL && !arg->matched_token) {
        hint = sdscat_orempty(hint, arg->token);
        if (arg->type != ARG_TYPE_PURE_TOKEN) {
            hint = sdscat(hint, "" "");
        }
    }

    /* Add the body of the syntax string. */
    switch (arg->type) {
     case ARG_TYPE_ONEOF:
        if (arg->matched == 0) {
            hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, ""|"");
        } else {
            int i;
            for (i = 0; i < arg->numsubargs; i++) {
                if (arg->subargs[i].matched != 0) {
                    hint = addHintForArgument(hint, &arg->subargs[i]);
          ...",1176.0,1230.0,1.0,22.0,55.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,sds
5296,280435,addSeparator,1,addSeparator,"sds addSeparator (sds,size_t*,char*,int)",redis-cli.c,"static sds addSeparator(sds str, size_t *len, char *separator, int is_last) {
    if (sdslen(str) > *len && !is_last) {
        str = sdscat(str, separator);
        *len = sdslen(str);
    }
    return str;
}",1061.0,1067.0,1.0,1.0,7.0,7,5,9,4,3,3,2,2,1,3,,0,3,8,4,4,sds
5297,280465,clearMatchedArgs,1,clearMatchedArgs,"void clearMatchedArgs (cliCommandArg*,int)",redis-cli.c,"static void clearMatchedArgs(cliCommandArg *args, int numargs) {
    for (int i = 0; i != numargs; ++i) {
        args[i].matched = 0;
        args[i].matched_token = 0;
        args[i].matched_name = 0;
        args[i].matched_all = 0;
        if (args[i].subargs) {
            clearMatchedArgs(args[i].subargs, args[i].numsubargs);
        }
    }
}",1070.0,1080.0,1.0,1.0,11.0,20,4,17,3,1,0,3,4,0,0,,0,0,4,2,2,void
5298,280529,addHintForArguments,1,addHintForArguments,"sds addHintForArguments (sds,cliCommandArg*,int,char*)",redis-cli.c,"static sds addHintForArguments(sds hint, cliCommandArg *args, int numargs, char *separator) {
    int i, j, incomplete;
    size_t len=sdslen(hint);
    for (i = 0; i < numargs; i++) {
        if (!(args[i].flags & CMD_ARG_OPTIONAL)) {
            hint = addHintForArgument(hint, &args[i]);
            hint = addSeparator(hint, &len, separator, i == numargs-1);
            continue;
        }

        /* The rule is that successive ""optional"" arguments can appear in any order.
         * But if they are followed by a required argument, no more of those optional arguments
         * can appear after that.
         * 
         * This code handles all successive optional args together. This lets us show the
         * completion of the currently-incomplete optional arg first, if there is one.
         */
        for (j = i, incomplete = -1; j < numargs; j++) {
            if (!(args[j].flags & CMD_ARG_OPTIONAL)) break;
            if (args[j].matched != 0 && args[j].matched_all == 0) {
...",1085.0,1127.0,1.0,30.0,43.0,56,15,61,8,2,7,11,21,0,7,,0,7,8,4,4,sds
5299,280715,addHintForRepeatedArgument,1,addHintForRepeatedArgument,"sds addHintForRepeatedArgument (sds,cliCommandArg*)",redis-cli.c,"static sds addHintForRepeatedArgument(sds hint, cliCommandArg *arg) {
    if (!(arg->flags & CMD_ARG_MULTIPLE)) {
        return hint;
    }

    /* The repeating part is always shown at the end of the argument's hint,
     * so we can safely clear its matched flags before printing it.
     */
    clearMatchedArgs(arg, 1);
        
    if (hint[0] != '\0') {
        hint = sdscat(hint, "" "");
    }
    hint = sdscat(hint, ""["");

    if (arg->flags & CMD_ARG_MULTIPLE_TOKEN) {
        hint = sdscat_orempty(hint, arg->token);
        if (arg->type != ARG_TYPE_PURE_TOKEN) {
            hint = sdscat(hint, "" "");
        }
    }

    switch (arg->type) {
     case ARG_TYPE_ONEOF:
        hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, ""|"");
        break;

    case ARG_TYPE_BLOCK:
        hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, "" "");
        break;

    case ARG_TYPE_PURE_TOKEN:
        break;

    default:
        hint = sdscat_orempty(hint, arg->di...",1132.0,1173.0,1.0,23.0,42.0,29,8,36,5,0,21,10,7,4,9,,0,20,4,2,2,sds
5300,281039,matchArg,1,matchArg,"int matchArg (char**,int,cliCommandArg*)",redis-cli.c,"static int matchArg(char **nextword, int numwords, cliCommandArg *arg) {
    int matchedWords = 0;
    int matchedOnce = matchArgOnce(nextword, numwords, arg);
    if (!(arg->flags & CMD_ARG_MULTIPLE)) {
        return matchedOnce;
    }

    /* Found one match; now match a ""multiple"" argument as many times as possible. */
    matchedWords += matchedOnce;
    while (arg->matched_all && matchedWords < numwords) {
        clearMatchedArgs(arg, 1);
        if (arg->token != NULL && !(arg->flags & CMD_ARG_MULTIPLE_TOKEN)) {
            /* The token only appears the first time; the rest of the times,
             * pretend we saw it so we don't hint it.
             */
            matchedOnce = matchNoTokenArg(nextword + matchedWords, numwords - matchedWords, arg);
            if (arg->matched) {
                arg->matched_token = 1;
            }
        } else {
            matchedOnce = matchArgOnce(nextword + matchedWords, numwords - matchedWords, arg);
        }
        matchedWor...",1341.0,1367.0,1.0,23.0,27.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,int
5301,281046,matchArgs,1,matchArgs,"int matchArgs (char**,int,cliCommandArg*,int)",redis-cli.c,"static int matchArgs(char **words, int numwords, cliCommandArg *args, int numargs) {
    int nextword, nextarg, matchedWords;
    for (nextword = 0, nextarg = 0; nextword != numwords && nextarg != numargs; ++nextarg) {
        /* Optional args can occur in any order. Collect a range of consecutive optional args
         * and try to match them as a group against the next input words.
         */
        if (args[nextarg].flags & CMD_ARG_OPTIONAL) {
            int lastoptional;
            for (lastoptional = nextarg; lastoptional < numargs; lastoptional++) {
                if (!(args[lastoptional].flags & CMD_ARG_OPTIONAL)) break;
            }
            matchedWords = matchOptionalArgs(&words[nextword], numwords - nextword, &args[nextarg], lastoptional - nextarg);
            nextarg = lastoptional - 1;
        } else {
            matchedWords = matchArg(&words[nextword], numwords - nextword, &args[nextarg]);
            if (matchedWords == 0) {
                /* Couldn't mat...",1410.0,1434.0,1.0,34.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
5302,281054,matchNoTokenArg,1,matchNoTokenArg,"int matchNoTokenArg (char**,int,cliCommandArg*)",redis-cli.c,"static int matchNoTokenArg(char **nextword, int numwords, cliCommandArg *arg) {
    int i;
    switch (arg->type) {
    case ARG_TYPE_BLOCK: {
        arg->matched += matchArgs(nextword, numwords, arg->subargs, arg->numsubargs);

        /* All the subargs must be matched for the block to match. */
        arg->matched_all = 1;
        for (i = 0; i < arg->numsubargs; i++) {
            if (arg->subargs[i].matched_all == 0) {
                arg->matched_all = 0;
            }
        }
        break;
    }
    case ARG_TYPE_ONEOF: {
        for (i = 0; i < arg->numsubargs; i++) {
            if (matchArg(nextword, numwords, &arg->subargs[i])) {
                arg->matched += arg->subargs[i].matched;
                arg->matched_all = arg->subargs[i].matched_all;
                break;
            }
        }
        break;
    }

    case ARG_TYPE_INTEGER:
    case ARG_TYPE_UNIX_TIME: {
        long long value;
        if (sscanf(*nextword, ""%lld"", &value)) {
            arg->matc...",1236.0,1298.0,1.0,1.0,63.0,55,9,45,10,1,26,14,16,6,2,,0,25,6,3,3,int
5303,281272,matchToken,1,matchToken,"int matchToken (char**,cliCommandArg*)",redis-cli.c,"static int matchToken(char **nextword, cliCommandArg *arg) {
    if (strcasecmp(arg->token, nextword[0]) != 0) {
        return 0;
    }
    arg->matched_token = 1;
    arg->matched = 1;
    return 1;
}",1301.0,1308.0,1.0,1.0,8.0,7,4,4,2,1,3,2,2,1,0,,0,3,4,2,2,int
5304,281303,matchArgOnce,1,matchArgOnce,"int matchArgOnce (char**,int,cliCommandArg*)",redis-cli.c,"static int matchArgOnce(char **nextword, int numwords, cliCommandArg *arg) {
    /* First match the token, if present. */
    if (arg->token != NULL) {
        if (!matchToken(nextword, arg)) {
            return 0;
        }
        if (arg->type == ARG_TYPE_PURE_TOKEN) {
            arg->matched_all = 1;
            return 1;
        }
        if (numwords == 1) {
            return 1;
        }
        nextword++;
        numwords--;
    }

    /* Then match the rest of the argument. */
    if (!matchNoTokenArg(nextword, numwords, arg)) {
        return 0;
    }
    return arg->matched;
}",1314.0,1336.0,1.0,1.0,23.0,12,7,14,5,0,6,6,9,4,2,,0,6,6,3,3,int
5305,281470,matchOneOptionalArg,1,matchOneOptionalArg,"int matchOneOptionalArg (char**,int,cliCommandArg*,int,int*)",redis-cli.c,"static int matchOneOptionalArg(char **words, int numwords, cliCommandArg *args, int numargs, int *matchedarg) {
    for (int nextword = 0, nextarg = 0; nextword != numwords && nextarg != numargs; ++nextarg) {
        if (args[nextarg].matched) {
            /* Already matched this arg. */
            continue;
        }

        int matchedWords = matchArg(&words[nextword], numwords - nextword, &args[nextarg]);
        if (matchedWords != 0) {
            *matchedarg = nextarg;
            return matchedWords;
        }
    }
    return 0;
}",1372.0,1386.0,1.0,1.0,15.0,16,8,19,8,1,1,5,6,0,1,,0,1,10,5,5,int
5306,281535,matchOptionalArgs,1,matchOptionalArgs,"int matchOptionalArgs (char**,int,cliCommandArg*,int)",redis-cli.c,"static int matchOptionalArgs(char **words, int numwords, cliCommandArg *args, int numargs) {
    int nextword = 0;
    int matchedarg = -1, lastmatchedarg = -1;
    while (nextword != numwords) {
        int matchedWords = matchOneOptionalArg(&words[nextword], numwords - nextword, args, numargs, &matchedarg);
        if (matchedWords == 0) {
            break;
        }
        /* Successfully matched an optional arg; mark any previous match as completed
         * so it won't be partially hinted.
         */
        if (lastmatchedarg != -1) {
            args[lastmatchedarg].matched_all = 1;
        }
        lastmatchedarg = matchedarg;
        nextword += matchedWords;
    }
    return nextword;
}",1389.0,1407.0,1.0,1.0,19.0,19,9,22,8,0,1,5,6,0,1,,0,1,8,4,4,int
5307,281810,findHelpEntry,1,findHelpEntry,"helpEntry findHelpEntry (int,char**)",redis-cli.c,"static helpEntry* findHelpEntry(int argc, char **argv) {
    helpEntry *entry = NULL;
    int i, rawargc, matchlen = 0;
    sds *rawargv;

    for (i = 0; i < helpEntriesLen; i++) {
        if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;

        rawargv = helpEntries[i].argv;
        rawargc = helpEntries[i].argc;
        if (rawargc <= argc) {
            int j;
            for (j = 0; j < rawargc; j++) {
                if (strcasecmp(rawargv[j],argv[j])) {
                    break;
                }
            }
            if (j == rawargc && rawargc > matchlen) {
                matchlen = rawargc;
                entry = &helpEntries[i];
            }
        }
    }
    return entry;
}",1468.0,1492.0,1.0,36.0,25.0,26,11,33,11,1,5,9,16,2,0,,0,5,4,2,2,helpEntry
5308,281912,getHintForInput,1,getHintForInput,sds getHintForInput (char*),redis-cli.c,"static sds getHintForInput(const char *charinput) {
    sds hint = NULL;
    int inputargc, inputlen = strlen(charinput);
    sds *inputargv = sdssplitargs(charinput, &inputargc);
    int endspace = inputlen && isspace(charinput[inputlen-1]);

    /* Don't match the last word until the user has typed a space after it. */
    int matchargc = endspace ? inputargc : inputargc - 1;

    helpEntry *entry = findHelpEntry(matchargc, inputargv);
    if (entry) {
       hint = makeHint(inputargv, matchargc, entry->argc, entry->docs);
    }
    sdsfreesplitres(inputargv, inputargc);
    return hint;
}",1495.0,1510.0,1.0,1.0,16.0,15,7,27,9,3,6,2,2,0,4,,0,5,2,1,1,sds
5309,281979,hintsCallback,1,hintsCallback,"char* hintsCallback (char*,int*,int*)",redis-cli.c,"static char *hintsCallback(const char *buf, int *color, int *bold) {
    if (!pref.hints) return NULL;

    sds hint = getHintForInput(buf);
    if (hint == NULL) {
        return NULL;
    }

    *color = 90;
    *bold = 0;

    /* Add an initial space if needed. */
    int len = strlen(buf);
    int endspace = len && isspace(buf[len-1]);
    if (!endspace) {
        sds newhint = sdsnewlen("" "",1);
        newhint = sdscatsds(newhint,hint);
        sdsfree(hint);
        hint = newhint;
    }

    return hint;
}",1513.0,1535.0,1.0,1.0,23.0,17,8,24,9,0,6,4,4,2,4,,0,5,6,3,3,char*
5310,282052,freeHintsCallback,1,freeHintsCallback,void freeHintsCallback (void*),redis-cli.c,"static void freeHintsCallback(void *ptr) {
    sdsfree(ptr);
}",1537.0,1539.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
5311,282059,cliRestoreTTY,1,cliRestoreTTY,void cliRestoreTTY (void),redis-cli.c,"void cliRestoreTTY(void) {
    if (orig_termios_saved)
        tcsetattr(STDIN_FILENO, TCSANOW, &orig_termios);
}",1546.0,1549.0,1.0,1.0,4.0,1,1,4,4,1,2,2,2,1,0,,0,2,2,1,1,void
5312,282072,cliPressAnyKeyTTY,1,cliPressAnyKeyTTY,void cliPressAnyKeyTTY (void),redis-cli.c,"static void cliPressAnyKeyTTY(void) {
    if (!isatty(STDIN_FILENO)) return;
    if (!orig_termios_saved) {
        if (tcgetattr(STDIN_FILENO, &orig_termios) == -1) return;
        atexit(cliRestoreTTY);
        orig_termios_saved = 1;
    }
    struct termios mode = orig_termios;
    mode.c_lflag &= ~(ECHO | ICANON); /* echoing off, canonical off */
    tcsetattr(STDIN_FILENO, TCSANOW, &mode);
}",1552.0,1562.0,1.0,1.0,11.0,11,8,13,7,1,4,4,5,2,0,,0,4,2,1,1,void
5313,282119,cliAuth,1,cliAuth,"int cliAuth (redisContext*,char*,char*)",redis-cli.c,"static int cliAuth(redisContext *ctx, char *user, char *auth) {
    redisReply *reply;
    if (auth == NULL) return REDIS_OK;

    if (user == NULL)
        reply = redisCommand(ctx,""AUTH %s"",auth);
    else
        reply = redisCommand(ctx,""AUTH %s %s"",user,auth);

    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr, ""AUTH failed: %s\n"", reply->str);
    }
    freeReplyObject(reply);
    return result;
}",1569.0,1590.0,1.0,1.0,22.0,9,3,22,10,0,0,5,5,0,0,,0,0,6,3,3,int
5314,282188,cliSelect,1,cliSelect,int cliSelect (void),redis-cli.c,"static int cliSelect(void) {
    redisReply *reply;
    if (config.conn_info.input_dbnum == config.dbnum) return REDIS_OK;

    reply = redisCommand(context,""SELECT %d"",config.conn_info.input_dbnum);
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr,""SELECT %d failed: %s\n"",config.conn_info.input_dbnum,reply->str);
    } else {
        config.dbnum = config.conn_info.input_dbnum;
        cliRefreshPrompt();
    }
    freeReplyObject(reply);
    return result;
}",1593.0,1613.0,1.0,1.0,21.0,15,4,21,9,0,8,4,4,4,0,,0,8,2,1,1,int
5315,282268,cliSwitchProto,1,cliSwitchProto,int cliSwitchProto (void),redis-cli.c,"static int cliSwitchProto(void) {
    redisReply *reply;
    if (!config.resp3 || config.resp2) return REDIS_OK;

    reply = redisCommand(context,""HELLO 3"");
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr,""HELLO 3 failed: %s\n"",reply->str);
        if (config.resp3 == 1) {
            result = REDIS_ERR;
        } else if (config.resp3 == 2) {
            result = REDIS_OK;
        }
    }

    /* Retrieve server version string for later use. */
    for (size_t i = 0; i < reply->elements; i += 2) {
        assert(reply->element[i]->type == REDIS_REPLY_STRING);
        char *key = reply->element[i]->str;
        if (!strcmp(key, ""version"")) {
            assert(reply->element[i + 1]->type == REDIS_REPLY_STRING);
            config.server_version = sdsnew(reply->element[i + 1]->str);
        }
    }
    freeReplyObject(reply);
    config.c...",1616.0,1648.0,1.0,1.0,33.0,38,9,37,12,0,11,7,9,6,1,,0,11,2,1,1,int
5316,282648,cliSendAsking,1,cliSendAsking,int cliSendAsking (void),redis-cli.c,"static int cliSendAsking(void) {
    redisReply *reply;

    config.cluster_send_asking = 0;
    if (context == NULL) {
        return REDIS_ERR;
    }
    reply = redisCommand(context,""ASKING"");
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }
    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr,""ASKING failed: %s\n"",reply->str);
    }
    freeReplyObject(reply);
    return result;
}",1728.0,1747.0,1.0,1.0,20.0,10,4,20,9,1,2,4,4,0,0,,0,2,2,1,1,int
5317,282705,cliPrintContextError,1,cliPrintContextError,void cliPrintContextError (void),redis-cli.c,"static void cliPrintContextError(void) {
    if (context == NULL) return;
    fprintf(stderr,""Error: %s\n"",context->errstr);
}",1749.0,1752.0,1.0,1.0,4.0,2,2,4,3,8,0,2,2,0,0,,0,0,2,1,1,void
5318,282722,isInvalidateReply,1,isInvalidateReply,int isInvalidateReply (redisReply*),redis-cli.c,"static int isInvalidateReply(redisReply *reply) {
    return reply->type == REDIS_REPLY_PUSH && reply->elements == 2 &&
        reply->element[0]->type == REDIS_REPLY_STRING &&
        !strncmp(reply->element[0]->str, ""invalidate"", 10) &&
        reply->element[1]->type == REDIS_REPLY_ARRAY;
}",1754.0,1759.0,1.0,1.0,6.0,20,5,8,4,0,0,1,1,0,0,,0,0,2,1,1,int
5319,282771,cliFormatInvalidateTTY,1,cliFormatInvalidateTTY,sds cliFormatInvalidateTTY (redisReply*),redis-cli.c,"static sds cliFormatInvalidateTTY(redisReply *r) {
    sds out = sdsnew(""-> invalidate: "");

    for (size_t i = 0; i < r->element[1]->elements; i++) {
        redisReply *key = r->element[1]->element[i];
        assert(key->type == REDIS_REPLY_STRING);

        out = sdscatfmt(out, ""'%s'"", key->str, key->len);
        if (i < r->element[1]->elements - 1)
            out = sdscatlen(out, "", "", 2);
    }

    return sdscatlen(out, ""\n"", 1);
}",1764.0,1777.0,1.0,1.0,14.0,22,6,18,5,0,4,3,4,0,4,,0,3,2,1,1,sds
5320,282852,cliIsMultilineValueTTY,1,cliIsMultilineValueTTY,int cliIsMultilineValueTTY (redisReply*),redis-cli.c,"static int cliIsMultilineValueTTY(redisReply *r) {
    switch (r->type) {
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
        if (r->elements == 0) return 0;
        if (r->elements > 1) return 1;
        return cliIsMultilineValueTTY(r->element[0]);
    case REDIS_REPLY_MAP:
        if (r->elements == 0) return 0;
        if (r->elements > 2) return 1;
        return cliIsMultilineValueTTY(r->element[1]);
    default:
        return 0;
    }
}",1780.0,1795.0,1.0,1.0,16.0,13,4,11,5,0,0,6,10,0,0,,0,0,2,1,1,int
5321,282923,cliFormatReplyTTY,1,cliFormatReplyTTY,"sds cliFormatReplyTTY (redisReply*,char*)",redis-cli.c,"static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
    sds out = sdsempty();
    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscatprintf(out,""(error) %s\n"", r->str);
    break;
    case REDIS_REPLY_STATUS:
        out = sdscat(out,r->str);
        out = sdscat(out,""\n"");
    break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""(integer) %lld\n"",r->integer);
    break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""(double) %s\n"",r->str);
    break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        /* If you are producing output for the standard output we want
        * a more interesting output with quoted characters and so forth,
        * unless it's a verbatim string type. */
        if (r->type == REDIS_REPLY_STRING) {
            out = sdscatrepr(out,r->str,r->len);
            out = sdscat(out,""\n"");
        } else {
            out = sdscatlen(out,r->str,r->len);
            out = sdscat(out,""\n"");
       ...",1797.0,1913.0,1.0,1.0,117.0,27,4,49,15,0,11,13,9,0,11,,0,11,4,2,2,sds
5322,283342,isPubsubPush,1,isPubsubPush,int isPubsubPush (redisReply*),redis-cli.c,"int isPubsubPush(redisReply *r) {
    if (r == NULL ||
        r->type != (config.current_resp3 ? REDIS_REPLY_PUSH : REDIS_REPLY_ARRAY) ||
        r->elements < 3 ||
        r->element[0]->type != REDIS_REPLY_STRING)
    {
        return 0;
    }
    char *str = r->element[0]->str;
    size_t len = r->element[0]->len;
    /* Check if it is [p|s][un]subscribe or [p|s]message, but even simpler, we
     * just check that it ends with ""message"" or ""subscribe"". */
    return ((len >= strlen(""message"") &&
             !strcmp(str + len - strlen(""message""), ""message"")) ||
            (len >= strlen(""subscribe"") &&
             !strcmp(str + len - strlen(""subscribe""), ""subscribe"")));
}",1916.0,1932.0,1.0,1.0,17.0,33,14,19,8,1,2,2,2,2,0,,0,2,2,1,1,int
5323,283431,isColorTerm,1,isColorTerm,int isColorTerm (void),redis-cli.c,"int isColorTerm(void) {
    char *t = getenv(""TERM"");
    return t != NULL && strstr(t,""xterm"") != NULL;
}",1934.0,1937.0,1.0,1.0,4.0,4,3,5,2,2,0,1,1,0,0,,0,0,2,1,1,int
5324,283451,sdscatcolor,1,sdscatcolor,"sds sdscatcolor (sds,char*,size_t,char*)",redis-cli.c,"sds sdscatcolor(sds o, char *s, size_t len, char *color) {
    if (!isColorTerm()) return sdscatlen(o,s,len);

    int bold = strstr(color,""bold"") != NULL;
    int ccode = 37; /* Defaults to white. */
    if (strstr(color,""red"")) ccode = 31;
    else if (strstr(color,""green"")) ccode = 32;
    else if (strstr(color,""yellow"")) ccode = 33;
    else if (strstr(color,""blue"")) ccode = 34;
    else if (strstr(color,""magenta"")) ccode = 35;
    else if (strstr(color,""cyan"")) ccode = 36;
    else if (strstr(color,""white"")) ccode = 37;

    o = sdscatfmt(o,""\033[%i;%i;49m"",bold,ccode);
    o = sdscatlen(o,s,len);
    o = sdscat(o,""\033[0m"");
    return o;
}",1941.0,1958.0,1.0,1.0,18.0,8,3,20,7,1,5,3,3,1,5,,0,4,8,4,4,sds
5325,283568,sdsCatColorizedLdbReply,1,sdsCatColorizedLdbReply,"sds sdsCatColorizedLdbReply (sds,char*,size_t)",redis-cli.c,"sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
    char *color = ""white"";

    if (strstr(s,""<debug>"")) color = ""bold"";
    if (strstr(s,""<redis>"")) color = ""green"";
    if (strstr(s,""<reply>"")) color = ""cyan"";
    if (strstr(s,""<error>"")) color = ""red"";
    if (strstr(s,""<hint>"")) color = ""bold"";
    if (strstr(s,""<value>"") || strstr(s,""<retval>"")) color = ""magenta"";
    if (len > 4 && isdigit(s[3])) {
        if (s[1] == '>') color = ""yellow""; /* Current line. */
        else if (s[2] == '#') color = ""bold""; /* Break point. */
    }
    return sdscatcolor(o,s,len,color);
}",1962.0,1976.0,1.0,1.0,15.0,14,6,22,4,0,1,9,10,0,1,,0,0,6,3,3,sds
5326,283669,cliFormatReplyRaw,1,cliFormatReplyRaw,sds cliFormatReplyRaw (redisReply*),redis-cli.c,"static sds cliFormatReplyRaw(redisReply *r) {
    sds out = sdsempty(), tmp;
    size_t i;

    switch (r->type) {
    case REDIS_REPLY_NIL:
        /* Nothing... */
        break;
    case REDIS_REPLY_ERROR:
        out = sdscatlen(out,r->str,r->len);
        out = sdscatlen(out,""\n"",1);
        break;
    case REDIS_REPLY_STATUS:
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {
            /* The Lua debugger replies with arrays of simple (status)
             * strings. We colorize the output for more fun if this
             * is a debugging session. */

            /* Detect the end of a debugging session. */
            if (strstr(r->str,""<endsession>"") == r->str) {
                config.enable_ldb_on_eval = 0;
                config.eval_ldb = 0;
                config.eval_ldb_end = 1; /* Signal the caller session ended. */
                config.output = OUTPUT_STANDARD;
                cliRefreshPrompt...",1978.0,2049.0,1.0,32.0,72.0,55,10,81,18,1,33,16,17,2,19,,0,29,2,1,1,sds
5327,283949,cliFormatReplyCSV,1,cliFormatReplyCSV,sds cliFormatReplyCSV (redisReply*),redis-cli.c,"static sds cliFormatReplyCSV(redisReply *r) {
    unsigned int i;

    sds out = sdsempty();
    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscat(out,""ERROR,"");
        out = sdscatrepr(out,r->str,strlen(r->str));
    break;
    case REDIS_REPLY_STATUS:
        out = sdscatrepr(out,r->str,r->len);
    break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""%lld"",r->integer);
    break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""%s"",r->str);
        break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        out = sdscatrepr(out,r->str,r->len);
    break;
    case REDIS_REPLY_NIL:
        out = sdscat(out,""NULL"");
    break;
    case REDIS_REPLY_BOOL:
        out = sdscat(out,r->integer ? ""true"" : ""false"");
    break;
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
    case REDIS_REPLY_MAP: /* CSV has no map type, just output flat list. */
        for (i = 0; i < r->elements; i++) {
        ...",2051.0,2095.0,1.0,1.0,45.0,32,7,57,17,0,13,12,7,0,13,,0,12,2,1,1,sds
5328,284119,jsonStringOutput,1,jsonStringOutput,"sds jsonStringOutput (sds,char*,int,int)",redis-cli.c,"static sds jsonStringOutput(sds out, const char *p, int len, int mode) {
    if (mode == OUTPUT_JSON) {
        return escapeJsonString(out, p, len);
    } else if (mode == OUTPUT_QUOTED_JSON) {
        /* Need to double-quote backslashes */
        sds tmp = sdscatrepr(sdsempty(), p, len);
        int tmplen = sdslen(tmp);
        char *n = tmp;
        while (tmplen--) {
            if (*n == '\\') out = sdscatlen(out, ""\\\\"", 2);
            else out = sdscatlen(out, n, 1);
            n++;
        }

        sdsfree(tmp);
        return out;
    } else {
        assert(0);
    }
}",2099.0,2118.0,1.0,16.0,20.0,1,1,4,4,3,1,2,2,0,1,,0,0,8,4,4,sds
5329,284198,cliFormatReplyJson,1,cliFormatReplyJson,"sds cliFormatReplyJson (sds,redisReply*,int)",redis-cli.c,"static sds cliFormatReplyJson(sds out, redisReply *r, int mode) {
    unsigned int i;

    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscat(out,""error:"");
        out = jsonStringOutput(out,r->str,strlen(r->str),mode);
        break;
    case REDIS_REPLY_STATUS:
        out = jsonStringOutput(out,r->str,r->len,mode);
        break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""%lld"",r->integer);
        break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""%s"",r->str);
        break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        out = jsonStringOutput(out,r->str,r->len,mode);
        break;
    case REDIS_REPLY_NIL:
        out = sdscat(out,""null"");
        break;
    case REDIS_REPLY_BOOL:
        out = sdscat(out,r->integer ? ""true"" : ""false"");
        break;
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
        out = sdscat(out,""["");
        for (i = 0; i < r->elements; i++ ) {
 ...",2120.0,2189.0,1.0,1.0,70.0,61,10,93,18,0,15,16,15,0,15,,0,15,6,3,3,sds
5330,284497,cliFormatReply,1,cliFormatReply,"sds cliFormatReply (redisReply*,int,int)",redis-cli.c,"static sds cliFormatReply(redisReply *reply, int mode, int verbatim) {
    sds out;

    if (verbatim) {
        out = cliFormatReplyRaw(reply);
    }  else if (mode == OUTPUT_STANDARD) {
        out = cliFormatReplyTTY(reply, """");
    } else if (mode == OUTPUT_RAW) {
        out = cliFormatReplyRaw(reply);
        out = sdscatsds(out, config.cmd_delim);
    } else if (mode == OUTPUT_CSV) {
        out = cliFormatReplyCSV(reply);
        out = sdscatlen(out, ""\n"", 1);
    } else if (mode == OUTPUT_JSON || mode == OUTPUT_QUOTED_JSON) {
        out = cliFormatReplyJson(sdsempty(), reply, mode);
        out = sdscatlen(out, ""\n"", 1);
    } else {
        fprintf(stderr, ""Error:  Unknown output encoding %d\n"", mode);
        exit(1);
    }

    return out;
}",2192.0,2214.0,1.0,24.0,23.0,1,1,4,3,2,1,2,2,0,1,,0,1,6,3,3,sds
5331,284651,cliReadReply,1,cliReadReply,int cliReadReply (int),redis-cli.c,"static int cliReadReply(int output_raw_strings) {
    void *_reply;
    redisReply *reply;
    sds out = NULL;
    int output = 1;

    if (config.last_reply) {
        freeReplyObject(config.last_reply);
        config.last_reply = NULL;
    }

    if (redisGetReply(context,&_reply) != REDIS_OK) {
        if (config.blocking_state_aborted) {
            config.blocking_state_aborted = 0;
            config.monitor_mode = 0;
            config.pubsub_mode = 0;
            return cliConnect(CC_FORCE);
        }

        if (config.shutdown) {
            redisFree(context);
            context = NULL;
            return REDIS_OK;
        }
        if (config.interactive) {
            /* Filter cases where we should reconnect */
            if (context->err == REDIS_ERR_IO &&
                (errno == ECONNRESET || errno == EPIPE))
                return REDIS_ERR;
            if (context->err == REDIS_ERR_EOF)
                return REDIS_ERR;
        }
        cliPrintContextError(...",2233.0,2320.0,1.0,30.0,88.0,81,13,77,20,4,50,12,21,12,8,,0,44,2,1,1,int
5332,284965,cliWaitForMessagesOrStdin,1,cliWaitForMessagesOrStdin,void cliWaitForMessagesOrStdin (void),redis-cli.c,"static void cliWaitForMessagesOrStdin(void) {
    int show_info = config.output != OUTPUT_RAW && (isatty(STDOUT_FILENO) ||
                                                    getenv(""FAKETTY""));
    int use_color = show_info && isColorTerm();
    cliPressAnyKeyTTY();
    while (config.pubsub_mode) {
        /* First check if there are any buffered replies. */
        redisReply *reply;
        do {
            if (redisGetReplyFromReader(context, (void **)&reply) != REDIS_OK) {
                cliPrintContextError();
                exit(1);
            }
            if (reply) {
                sds out = cliFormatReply(reply, config.output, 0);
                fwrite(out,sdslen(out),1,stdout);
                fflush(stdout);
                sdsfree(out);
            }
        } while(reply);

        /* Wait for input, either on the Redis socket or on stdin. */
        struct timeval tv;
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(context->fd, &readfds);
     ...",2323.0,2385.0,1.0,37.0,63.0,32,10,41,13,1,21,12,25,5,9,,0,15,2,1,1,void
5333,285158,cliSendCommand,1,cliSendCommand,"int cliSendCommand (int,char**,long)",redis-cli.c,"static int cliSendCommand(int argc, char **argv, long repeat) {
    char *command = argv[0];
    size_t *argvlen;
    int j, output_raw;

    if (context == NULL) return REDIS_ERR;

    output_raw = 0;
    if (!strcasecmp(command,""info"") ||
        !strcasecmp(command,""lolwut"") ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""htstats"")) ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""htstats-key"")) ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""client-eviction"")) ||
        (argc >= 2 && !strcasecmp(command,""memory"") &&
                      (!strcasecmp(argv[1],""malloc-stats"") ||
                       !strcasecmp(argv[1],""doctor""))) ||
        (argc == 2 && !strcasecmp(command,""cluster"") &&
                      (!strcasecmp(argv[1],""nodes"") ||
                       !strcasecmp(argv[1],""info""))) ||
        (argc >= 2 && !st...",2387.0,2591.0,1.0,24.0,205.0,184,19,126,18,1,60,30,65,27,12,,0,52,6,3,3,int
5334,286004,reconnectingRedisCommand,1,reconnectingRedisCommand,"redisReply reconnectingRedisCommand (redisContext*,char*...)",redis-cli.c,"static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
    redisReply *reply = NULL;
    int tries = 0;
    va_list ap;

    assert(!c->err);
    while(reply == NULL) {
        while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {
            printf(""\r\x1b[0K""); /* Cursor to left edge + clear line. */
            printf(""Reconnecting... %d\r"", ++tries);
            fflush(stdout);

            redisFree(c);
            c = redisConnect(config.conn_info.hostip,config.conn_info.hostport);
            if (!c->err && config.tls) {
                const char *err = NULL;
                if (cliSecureConnection(c, config.sslconfig, &err) == REDIS_ERR && err) {
                    fprintf(stderr, ""TLS Error: %s\n"", err);
                    exit(1);
                }
            }
            usleep(1000000);
        }

        va_start(ap,fmt);
        reply = redisvCommand(c,fmt,ap);
        va_end(ap);

        if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ER...",2594.0,2632.0,1.0,1.0,39.0,32,10,42,14,3,9,6,13,5,1,,0,9,4,2,2,redisReply
5335,288272,parseEnv,1,parseEnv,void parseEnv (void),redis-cli.c,"static void parseEnv(void) {
    /* Set auth from env, but do not overwrite CLI arguments if passed */
    char *auth = getenv(REDIS_CLI_AUTH_ENV);
    if (auth != NULL && config.conn_info.auth == NULL) {
        config.conn_info.auth = auth;
    }

    char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
    if (cluster_yes != NULL && !strcmp(cluster_yes, ""1"")) {
        config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
    }
}",2971.0,2982.0,1.0,24.0,12.0,16,7,12,4,0,6,3,3,2,0,,0,6,2,1,1,void
5336,288373,confirmWithYes,1,confirmWithYes,"int confirmWithYes (char*,int)",redis-cli.c,"static int confirmWithYes(char *msg, int ignore_force) {
    /* if --cluster-yes option is set and ignore_force is false,
     * do not prompt for an answer */
    if (!ignore_force &&
        (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES)) {
        return 1;
    }

    printf(""%s (type 'yes' to accept): "", msg);
    fflush(stdout);
    char buf[4];
    int nread = read(fileno(stdin),buf,4);
    buf[3] = '\0';
    return (nread != 0 && !strcmp(""yes"", buf));
}",3130.0,3144.0,1.0,48.0,15.0,12,8,10,7,3,2,2,2,2,0,,0,2,4,2,2,int
5337,288425,issueCommandRepeat,1,issueCommandRepeat,"int issueCommandRepeat (int,char**,long)",redis-cli.c,"static int issueCommandRepeat(int argc, char **argv, long repeat) {
    /* In Lua debugging mode, we want to pass the ""help"" to Redis to get
     * it's own HELP message, rather than handle it by the CLI, see ldbRepl.
     *
     * For the normal Redis HELP, we can process it without a connection. */
    if (!config.eval_ldb &&
        (!strcasecmp(argv[0],""help"") || !strcasecmp(argv[0],""?"")))
    {
        cliOutputHelp(--argc, ++argv);
        return REDIS_OK;
    }

    while (1) {
        if (config.cluster_reissue_command || context == NULL ||
            context->err == REDIS_ERR_IO || context->err == REDIS_ERR_EOF)
        {
            if (cliConnect(CC_FORCE) != REDIS_OK) {
                cliPrintContextError();
                config.cluster_reissue_command = 0;
                return REDIS_ERR;
            }
        }
        config.cluster_reissue_command = 0;
        if (config.cluster_send_asking) {
            if (cliSendAsking() != REDIS_OK) {
                cliPri...",3146.0,3189.0,1.0,27.0,44.0,32,12,31,10,1,21,11,17,13,7,,0,17,6,3,3,int
5338,288548,issueCommand,1,issueCommand,"int issueCommand (int,char**)",redis-cli.c,"static int issueCommand(int argc, char **argv) {
    return issueCommandRepeat(argc, argv, config.repeat);
}",3191.0,3193.0,1.0,1.0,3.0,1,1,3,3,2,3,1,1,0,1,,0,2,4,2,2,int
5339,288561,cliSplitArgs,1,cliSplitArgs,"sds cliSplitArgs (char*,int*)",redis-cli.c,"static sds *cliSplitArgs(char *line, int *argc) {
    if (config.eval_ldb && (strstr(line,""eval "") == line ||
                            strstr(line,""e "") == line))
    {
        sds *argv = sds_malloc(sizeof(sds)*2);
        *argc = 2;
        int len = strlen(line);
        int elen = line[1] == ' ' ? 2 : 5; /* ""e "" or ""eval ""? */
        argv[0] = sdsnewlen(line,elen-1);
        argv[1] = sdsnewlen(line+elen,len-elen);
        return argv;
    } else {
        return sdssplitargs(line,argc);
    }
}",3201.0,3215.0,1.0,1.0,15.0,22,12,21,7,0,5,2,2,2,3,,0,5,4,2,2,sds
5340,288640,cliSetPreferences,1,cliSetPreferences,"void cliSetPreferences (char**,int,int)",redis-cli.c,"void cliSetPreferences(char **argv, int argc, int interactive) {
    if (!strcasecmp(argv[0],"":set"") && argc >= 2) {
        if (!strcasecmp(argv[1],""hints"")) pref.hints = 1;
        else if (!strcasecmp(argv[1],""nohints"")) pref.hints = 0;
        else {
            printf(""%sunknown redis-cli preference '%s'\n"",
                interactive ? """" : "".redisclirc: "",
                argv[1]);
        }
    } else {
        printf(""%sunknown redis-cli internal command '%s'\n"",
            interactive ? """" : "".redisclirc: "",
            argv[0]);
    }
}",3220.0,3234.0,1.0,1.0,15.0,8,6,4,3,1,2,3,4,0,0,,0,2,6,3,3,void
5341,288709,cliLoadPreferences,1,cliLoadPreferences,void cliLoadPreferences (void),redis-cli.c,"void cliLoadPreferences(void) {
    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
    if (rcfile == NULL) return;
    FILE *fp = fopen(rcfile,""r"");
    char buf[1024];

    if (fp) {
        while(fgets(buf,sizeof(buf),fp) != NULL) {
            sds *argv;
            int argc;

            argv = sdssplitargs(buf,&argc);
            if (argc > 0) cliSetPreferences(argv,argc,0);
            sdsfreesplitres(argv,argc);
        }
        fclose(fp);
    }
    sdsfree(rcfile);
}",3237.0,3255.0,1.0,32.0,19.0,8,6,20,6,1,5,5,8,0,5,,0,2,2,1,1,void
5342,288773,isSensitiveCommand,1,isSensitiveCommand,"int isSensitiveCommand (int,char**)",redis-cli.c,"static int isSensitiveCommand(int argc, char **argv) {
    if (!strcasecmp(argv[0],""auth"")) {
        return 1;
    } else if (argc > 1 &&
        !strcasecmp(argv[0],""acl"") &&
        !strcasecmp(argv[1],""setuser""))
    {
        return 1;
    } else if (argc > 2 &&
        !strcasecmp(argv[0],""config"") &&
        !strcasecmp(argv[1],""set"")) {
            for (int j = 2; j < argc; j = j+2) {
                if (!strcasecmp(argv[j],""masterauth"") ||
		    !strcasecmp(argv[j],""masteruser"") ||
		    !strcasecmp(argv[j],""requirepass"")) {
                    return 1;
                }
            }
            return 0;
    /* HELLO [protover [AUTH username password] [SETNAME clientname]] */
    } else if (argc > 4 && !strcasecmp(argv[0],""hello"")) {
        for (int j = 2; j < argc; j++) {
            int moreargs = argc - 1 - j;
            if (!strcasecmp(argv[j],""AUTH"") && moreargs >= 2) {
                return 1;
            } else if (!strcasecmp(argv[j],""SETNAME"") && moreargs) {
...",3264.0,3310.0,1.0,1.0,47.0,2,2,1,1,0,0,2,2,0,0,,0,0,4,2,2,int
5343,289018,repl,1,repl,void repl (void),redis-cli.c,"static void repl(void) {
    sds historyfile = NULL;
    int history = 0;
    char *line;
    int argc;
    sds *argv;

    /* There is no need to initialize redis HELP when we are in lua debugger mode.
     * It has its own HELP and commands (COMMAND or COMMAND DOCS will fail and got nothing).
     * We will initialize the redis HELP after the Lua debugging session ended.*/
    if ((!config.eval_ldb) && isatty(fileno(stdin))) {
        /* Initialize the help using the results of the COMMAND command. */
        cliInitHelp();
    }

    config.interactive = 1;
    linenoiseSetMultiLine(1);
    linenoiseSetCompletionCallback(completionCallback);
    linenoiseSetHintsCallback(hintsCallback);
    linenoiseSetFreeHintsCallback(freeHintsCallback);

    /* Only use history and load the rc file when stdin is a tty. */
    if (isatty(fileno(stdin))) {
        historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
        //keep in-memory history always regardless i...",3312.0,3458.0,1.0,37.0,147.0,20,8,22,8,0,18,11,17,7,6,,0,14,2,1,1,void
5344,289473,noninteractive,1,noninteractive,"int noninteractive (int,char**)",redis-cli.c,"static int noninteractive(int argc, char **argv) {
    int retval = 0;
    sds *sds_args = getSdsArrayFromArgv(argc, argv, config.quoted_input);

    if (!sds_args) {
        printf(""Invalid quoted string\n"");
        return 1;
    }

    if (config.stdin_lastarg) {
        sds_args = sds_realloc(sds_args, (argc + 1) * sizeof(sds));
        sds_args[argc] = readArgFromStdin();
        argc++;
    } else if (config.stdin_tag_arg) {
        int i = 0, tag_match = 0;

        for (; i < argc; i++) {
            if (strcmp(config.stdin_tag_name, sds_args[i]) != 0) continue;

            tag_match = 1;
            sdsfree(sds_args[i]);
            sds_args[i] = readArgFromStdin();
            break;
        }

        if (!tag_match) {
            sdsfreesplitres(sds_args, argc);
            fprintf(stderr, ""Using -X option but stdin tag not match.\n"");
            return 1;
        }
    }

    retval = issueCommand(argc, sds_args);
    sdsfreesplitres(sds_args, argc);
    while (config...",3460.0,3502.0,1.0,1.0,43.0,17,11,24,8,0,13,5,6,5,7,,0,11,4,2,2,int
5345,289613,evalMode,1,evalMode,"int evalMode (int,char**)",redis-cli.c,"static int evalMode(int argc, char **argv) {
    sds script = NULL;
    FILE *fp;
    char buf[1024];
    size_t nread;
    char **argv2;
    int j, got_comma, keys;
    int retval = REDIS_OK;

    while(1) {
        if (config.eval_ldb) {
            printf(
            ""Lua debugging session started, please use:\n""
            ""quit    -- End the session.\n""
            ""restart -- Restart the script in debug mode again.\n""
            ""help    -- Show Lua script debugging commands.\n\n""
            );
        }

        sdsfree(script);
        script = sdsempty();
        got_comma = 0;
        keys = 0;

        /* Load the script from the file, as an sds string. */
        fp = fopen(config.eval,""r"");
        if (!fp) {
            fprintf(stderr,
                ""Can't open file '%s': %s\n"", config.eval, strerror(errno));
            exit(1);
        }
        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
            script = sdscatlen(script,buf,nread);
        }
     ...",3508.0,3589.0,1.0,27.0,82.0,56,14,64,20,0,24,14,26,6,10,,0,22,4,2,2,int
5346,289936,clusterManagerCommandProc,1,clusterManagerCommandProc,"int clusterManagerCommandProc (int,char**)",redis-cli.c,"typedef int clusterManagerCommandProc(int argc, char **argv);",3675.0,3675.0,13.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5347,289942,clusterManagerOnReplyError,1,clusterManagerOnReplyError,"int clusterManagerOnReplyError (redisReply*,clusterManagerNode*,int)",redis-cli.c,"typedef int (*clusterManagerOnReplyError)(redisReply *reply,
    clusterManagerNode *n, int bulk_idx);",3676.0,3677.0,13.0,40.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5348,289949,clusterManagerNewNode,1,clusterManagerNewNode,"clusterManagerNode* clusterManagerNewNode (char*,int,int)",redis-cli.c,"static clusterManagerNode *clusterManagerNewNode(char *ip, int port, int bus_port) {
    clusterManagerNode *node = zmalloc(sizeof(*node));
    node->context = NULL;
    node->name = NULL;
    node->ip = ip;
    node->port = port;
    /* We don't need to know the bus_port, at this point this value may be wrong.
     * If it is used, it will be corrected in clusterManagerLoadInfoFromNode. */
    node->bus_port = bus_port ? bus_port : port + CLUSTER_MANAGER_PORT_INCR;
    node->current_epoch = 0;
    node->ping_sent = 0;
    node->ping_recv = 0;
    node->flags = 0;
    node->flags_str = NULL;
    node->replicate = NULL;
    node->dirty = 0;
    node->friends = NULL;
    node->migrating = NULL;
    node->importing = NULL;
    node->migrating_count = 0;
    node->importing_count = 0;
    node->replicas_count = 0;
    node->weight = 1.0f;
    node->balance = 0;
    clusterManagerNodeResetSlots(node);
    return node;
}",3948.0,3974.0,1.0,50.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,clusterManagerNode
5349,289956,clusterManagerNodeByName,1,clusterManagerNodeByName,clusterManagerNode* clusterManagerNodeByName (char*),redis-cli.c,"static clusterManagerNode *clusterManagerNodeByName(const char *name) {
    if (cluster_manager.nodes == NULL) return NULL;
    clusterManagerNode *found = NULL;
    sds lcname = sdsempty();
    lcname = sdscpy(lcname, name);
    sdstolower(lcname);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->name && !sdscmp(n->name, lcname)) {
            found = n;
            break;
        }
    }
    sdsfree(lcname);
    return found;
}",4097.0,4115.0,1.0,1.0,19.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,clusterManagerNode
5350,289961,clusterManagerNodeByAbbreviatedName,1,clusterManagerNodeByAbbreviatedName,clusterManagerNode* clusterManagerNodeByAbbreviatedName (char*),redis-cli.c,"static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
{
    if (cluster_manager.nodes == NULL) return NULL;
    clusterManagerNode *found = NULL;
    sds lcname = sdsempty();
    lcname = sdscpy(lcname, name);
    sdstolower(lcname);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->name &&
            strstr(n->name, lcname) == n->name) {
            found = n;
            break;
        }
    }
    sdsfree(lcname);
    return found;
}",4121.0,4141.0,1.0,1.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,clusterManagerNode
5351,289966,clusterManagerNodeResetSlots,1,clusterManagerNodeResetSlots,void clusterManagerNodeResetSlots (clusterManagerNode*),redis-cli.c,"static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
    memset(node->slots, 0, sizeof(node->slots));
    node->slots_count = 0;
}",4143.0,4146.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5352,289971,clusterManagerNodeIsCluster,1,clusterManagerNodeIsCluster,"int clusterManagerNodeIsCluster (clusterManagerNode*,char**)",redis-cli.c,"static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
    redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
    if (info == NULL) return 0;
    int is_cluster = (int) getLongInfoField(info->str, ""cluster_enabled"");
    freeReplyObject(info);
    return is_cluster;
}",4166.0,4172.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5353,289977,clusterManagerPrintNotClusterNodeError,1,clusterManagerPrintNotClusterNodeError,"void clusterManagerPrintNotClusterNodeError (clusterManagerNode*,char*)",redis-cli.c,"static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
                                                   char *err)
{
    char *msg = (err ? err : ""is not configured as a cluster node."");
    clusterManagerLogErr(""[ERR] Node %s:%d %s\n"", node->ip, node->port, msg);
}",6821.0,6826.0,1.0,4.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5354,289983,clusterManagerNodeLoadInfo,1,clusterManagerNodeLoadInfo,"int clusterManagerNodeLoadInfo (clusterManagerNode*,int,char**)",redis-cli.c,"static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
                                      char **err)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    int success = 1;
    *err = NULL;
    if (!clusterManagerCheckRedisReply(node, reply, err)) {
        success = 0;
        goto cleanup;
    }
    int getfriends = (opts & CLUSTER_MANAGER_OPT_GETFRIENDS);
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *name = NULL, *addr = NULL, *flags = NULL, *master_id = NULL,
             *ping_sent = NULL, *ping_recv = NULL, *config_epoch = NULL,
             *link_status = NULL;
        UNUSED(link_status);
        int i = 0;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            switch(i++){
            case 0: name = token; break;
          ...",5318.0,5488.0,1.0,24.0,171.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5355,289990,clusterManagerLoadInfoFromNode,1,clusterManagerLoadInfoFromNode,int clusterManagerLoadInfoFromNode (clusterManagerNode*),redis-cli.c,"static int clusterManagerLoadInfoFromNode(clusterManagerNode *node) {
    if (node->context == NULL && !clusterManagerNodeConnect(node)) {
        freeClusterManagerNode(node);
        return 0;
    }
    char *e = NULL;
    if (!clusterManagerNodeIsCluster(node, &e)) {
        clusterManagerPrintNotClusterNodeError(node, e);
        if (e) zfree(e);
        freeClusterManagerNode(node);
        return 0;
    }
    e = NULL;
    if (!clusterManagerNodeLoadInfo(node, CLUSTER_MANAGER_OPT_GETFRIENDS, &e)) {
        if (e) {
            CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, e);
            zfree(e);
        }
        freeClusterManagerNode(node);
        return 0;
    }
    listIter li;
    listNode *ln;
    if (cluster_manager.nodes != NULL) {
        listRewind(cluster_manager.nodes, &li);
        while ((ln = listNext(&li)) != NULL)
            freeClusterManagerNode((clusterManagerNode *) ln->value);
        listRelease(cluster_manager.nodes);
    }
    cluster_manager.nodes = lis...",5494.0,5570.0,1.0,42.0,77.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5356,289995,clusterManagerNodeIsEmpty,1,clusterManagerNodeIsEmpty,"int clusterManagerNodeIsEmpty (clusterManagerNode*,char**)",redis-cli.c,"static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
    redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
    int is_empty = 1;
    if (info == NULL) return 0;
    if (strstr(info->str, ""db0:"") != NULL) {
        is_empty = 0;
        goto result;
    }
    freeReplyObject(info);
    info = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER INFO"");
    if (err != NULL) *err = NULL;
    if (!clusterManagerCheckRedisReply(node, info, err)) {
        is_empty = 0;
        goto result;
    }
    long known_nodes = getLongInfoField(info->str, ""cluster_known_nodes"");
    is_empty = (known_nodes == 1);
result:
    freeReplyObject(info);
    return is_empty;
}",4176.0,4196.0,1.0,11.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5357,290001,clusterManagerGetAntiAffinityScore,1,clusterManagerGetAntiAffinityScore,"int clusterManagerGetAntiAffinityScore (clusterManagerNodeArray*,int,clusterManagerNode***,int*)",redis-cli.c,"static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
    int ip_count, clusterManagerNode ***offending, int *offending_len)
{
    int score = 0, i, j;
    int node_len = cluster_manager.nodes->len;
    clusterManagerNode **offending_p = NULL;
    if (offending != NULL) {
        *offending = zcalloc(node_len * sizeof(clusterManagerNode*));
        offending_p = *offending;
    }
    /* For each set of nodes in the same host, split by
     * related nodes (masters and slaves which are involved in
     * replication of each other) */
    for (i = 0; i < ip_count; i++) {
        clusterManagerNodeArray *node_array = &(ipnodes[i]);
        dict *related = dictCreate(&clusterManagerDictType);
        char *ip = NULL;
        for (j = 0; j < node_array->len; j++) {
            clusterManagerNode *node = node_array->nodes[j];
            if (node == NULL) continue;
            if (!ip) ip = node->ip;
            sds types;
            /* We always use the Master ...",4227.0,4296.0,1.0,1.0,70.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5358,290009,clusterManagerOptimizeAntiAffinity,1,clusterManagerOptimizeAntiAffinity,"void clusterManagerOptimizeAntiAffinity (clusterManagerNodeArray*,int)",redis-cli.c,"static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
    int ip_count)
{
    clusterManagerNode **offenders = NULL;
    int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
                                                   NULL, NULL);
    if (score == 0) goto cleanup;
    clusterManagerLogInfo("">>> Trying to optimize slaves allocation ""
                          ""for anti-affinity\n"");
    int node_len = cluster_manager.nodes->len;
    int maxiter = 500 * node_len; // Effort is proportional to cluster size...
    srand(time(NULL));
    while (maxiter > 0) {
        int offending_len = 0;
        if (offenders != NULL) {
            zfree(offenders);
            offenders = NULL;
        }
        score = clusterManagerGetAntiAffinityScore(ipnodes,
                                                   ip_count,
                                                   &offenders,
                                                   &offending_len);
    ...",4298.0,4374.0,1.0,4.0,77.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5359,290015,clusterManagerNodeInfo,1,clusterManagerNodeInfo,"sds clusterManagerNodeInfo (clusterManagerNode*,int)",redis-cli.c,"static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
    sds info = sdsempty();
    sds spaces = sdsempty();
    int i;
    for (i = 0; i < indent; i++) spaces = sdscat(spaces, "" "");
    if (indent) info = sdscat(info, spaces);
    int is_master = !(node->flags & CLUSTER_MANAGER_FLAG_SLAVE);
    char *role = (is_master ? ""M"" : ""S"");
    sds slots = NULL;
    if (node->dirty && node->replicate != NULL)
        info = sdscatfmt(info, ""S: %S %s:%u"", node->name, node->ip, node->port);
    else {
        slots = clusterManagerNodeSlotsString(node);
        sds flags = clusterManagerNodeFlagString(node);
        info = sdscatfmt(info, ""%s: %S %s:%u\n""
                               ""%s   slots:%S (%u slots) ""
                               ""%S"",
                               role, node->name, node->ip, node->port, spaces,
                               slots, node->slots_count, flags);
        sdsfree(slots);
        sdsfree(flags);
    }
    if (node->replicate != N...",4531.0,4560.0,1.0,36.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
5360,290021,clusterManagerShowNodes,1,clusterManagerShowNodes,void clusterManagerShowNodes (void),redis-cli.c,"static void clusterManagerShowNodes(void) {
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        sds info = clusterManagerNodeInfo(node, 0);
        printf(""%s\n"", (char *) info);
        sdsfree(info);
    }
}",4562.0,4572.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5361,290026,clusterManagerShowClusterInfo,1,clusterManagerShowClusterInfo,void clusterManagerShowClusterInfo (void),redis-cli.c,"static void clusterManagerShowClusterInfo(void) {
    int masters = 0;
    int keys = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        if (!(node->flags & CLUSTER_MANAGER_FLAG_SLAVE)) {
            if (!node->name) continue;
            int replicas = 0;
            int dbsize = -1;
            char name[9];
            memcpy(name, node->name, 8);
            name[8] = '\0';
            listIter ri;
            listNode *rn;
            listRewind(cluster_manager.nodes, &ri);
            while ((rn = listNext(&ri)) != NULL) {
                clusterManagerNode *n = rn->value;
                if (n == node || !(n->flags & CLUSTER_MANAGER_FLAG_SLAVE))
                    continue;
                if (n->replicate && !strcmp(n->replicate, node->name))
                    replicas++;
            }
            redisReply *reply = CLUSTER_MANAGER_COMMAND(node,...",4574.0,4621.0,1.0,28.0,48.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5362,290031,clusterManagerFlushNodeConfig,1,clusterManagerFlushNodeConfig,"int clusterManagerFlushNodeConfig (clusterManagerNode*,char**)",redis-cli.c,"static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
    if (!node->dirty) return 0;
    redisReply *reply = NULL;
    int is_err = 0, success = 1;
    if (err != NULL) *err = NULL;
    if (node->replicate != NULL) {
        reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER REPLICATE %s"",
                                        node->replicate);
        if (reply == NULL || (is_err = (reply->type == REDIS_REPLY_ERROR))) {
            if (is_err && err != NULL) {
                *err = zmalloc((reply->len + 1) * sizeof(char));
                redis_strlcpy(*err, reply->str, (reply->len + 1));
            }
            success = 0;
            /* If the cluster did not already joined it is possible that
             * the slave does not know the master node yet. So on errors
             * we return ASAP leaving the dirty flag set, to flush the
             * config later. */
            goto cleanup;
        }
    } else {
        int added = clusterManagerAd...",5227.0,5255.0,1.0,16.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5363,290037,clusterManagerWaitForClusterJoin,1,clusterManagerWaitForClusterJoin,void clusterManagerWaitForClusterJoin (void),redis-cli.c,"static void clusterManagerWaitForClusterJoin(void) {
    printf(""Waiting for the cluster to join\n"");
    int counter = 0,
        check_after = CLUSTER_JOIN_CHECK_AFTER +
                      (int)(listLength(cluster_manager.nodes) * 0.15f);
    while(!clusterManagerIsConfigConsistent()) {
        printf(""."");
        fflush(stdout);
        sleep(1);
        if (++counter > check_after) {
            dict *status = clusterManagerGetLinkStatus();
            dictIterator *iter = NULL;
            if (status != NULL && dictSize(status) > 0) {
                printf(""\n"");
                clusterManagerLogErr(""Warning: %d node(s) may ""
                                     ""be unreachable\n"", dictSize(status));
                iter = dictGetIterator(status);
                dictEntry *entry;
                while ((entry = dictNext(iter)) != NULL) {
                    sds nodeaddr = (sds) dictGetKey(entry);
                    char *node_ip = NULL;
                    int node_port ...",5258.0,5311.0,1.0,22.0,54.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5364,290042,clusterManagerCheckCluster,1,clusterManagerCheckCluster,int clusterManagerCheckCluster (int),redis-cli.c,"static int clusterManagerCheckCluster(int quiet) {
    listNode *ln = listFirst(cluster_manager.nodes);
    if (!ln) return 0;
    clusterManagerNode *node = ln->value;
    clusterManagerLogInfo("">>> Performing Cluster Check (using node %s:%d)\n"",
                          node->ip, node->port);
    int result = 1, consistent = 0;
    int do_fix = config.cluster_manager_command.flags &
                 CLUSTER_MANAGER_CMD_FLAG_FIX;
    if (!quiet) clusterManagerShowNodes();
    consistent = clusterManagerIsConfigConsistent();
    if (!consistent) {
        sds err = sdsnew(""[ERR] Nodes don't agree about configuration!"");
        clusterManagerOnError(err);
        result = 0;
    } else {
        clusterManagerLogOk(""[OK] All nodes agree about slots ""
                            ""configuration.\n"");
    }
    /* Check open slots */
    clusterManagerLogInfo("">>> Check for open slots...\n"");
    listIter li;
    listRewind(cluster_manager.nodes, &li);
    int i;
    dict *open_slots ...",6495.0,6657.0,1.0,19.0,163.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5365,290047,clusterManagerLog,1,clusterManagerLog,"void clusterManagerLog (int,char*...)",redis-cli.c,"static void clusterManagerLog(int level, const char* fmt, ...) {
    int use_colors =
        (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COLOR);
    if (use_colors) {
        printf(""\033["");
        switch (level) {
        case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
        case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
        case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
        case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
        default: printf(LOG_COLOR_RESET); break;
        }
    }
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    va_end(ap);
    if (use_colors) printf(""\033["" LOG_COLOR_RESET);
}",6742.0,6760.0,1.0,48.0,19.0,0,0,0,0,31,0,1,1,0,0,,0,0,4,2,2,void
5366,290053,clusterManagerIsConfigConsistent,1,clusterManagerIsConfigConsistent,int clusterManagerIsConfigConsistent (void),redis-cli.c,"static int clusterManagerIsConfigConsistent(void) {
    if (cluster_manager.nodes == NULL) return 0;
    int consistent = (listLength(cluster_manager.nodes) <= 1);
    // If the Cluster has only one node, it's always consistent
    if (consistent) return 1;
    sds first_cfg = NULL;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        sds cfg = clusterManagerGetConfigSignature(node);
        if (cfg == NULL) {
            consistent = 0;
            break;
        }
        if (first_cfg == NULL) first_cfg = cfg;
        else {
            consistent = !sdscmp(first_cfg, cfg);
            sdsfree(cfg);
            if (!consistent) break;
        }
    }
    if (first_cfg != NULL) sdsfree(first_cfg);
    return consistent;
}",5684.0,5709.0,1.0,22.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5367,290058,clusterManagerGetLinkStatus,1,clusterManagerGetLinkStatus,dict* clusterManagerGetLinkStatus (void),redis-cli.c,"static dict *clusterManagerGetLinkStatus(void) {
    if (cluster_manager.nodes == NULL) return NULL;
    dict *status = dictCreate(&clusterManagerLinkDictType);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        list *links = clusterManagerGetDisconnectedLinks(node);
        if (links) {
            listIter lli;
            listNode *lln;
            listRewind(links, &lli);
            while ((lln = listNext(&lli)) != NULL) {
                clusterManagerLink *link = lln->value;
                list *from = NULL;
                dictEntry *entry = dictFind(status, link->node_addr);
                if (entry) from = dictGetVal(entry);
                else {
                    from = listCreate();
                    dictAdd(status, sdsdup(link->node_addr), from);
                }
                sds myaddr = sdsempty();
                myaddr = sdscatfmt(m...",5758.0,5791.0,1.0,1.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,dict
5368,290063,clusterManagerOnError,1,clusterManagerOnError,void clusterManagerOnError (sds),redis-cli.c,"static void clusterManagerOnError(sds err) {
    if (cluster_manager.errors == NULL)
        cluster_manager.errors = listCreate();
    listAddNodeTail(cluster_manager.errors, err);
    clusterManagerLogErr(""%s\n"", (char *) err);
}",5794.0,5799.0,1.0,4.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5369,290068,clusterManagerNodeArrayInit,1,clusterManagerNodeArrayInit,"void clusterManagerNodeArrayInit (clusterManagerNodeArray*,int)",redis-cli.c,"static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
                                        int alloc_len)
{
    array->nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
    array->alloc = array->nodes;
    array->len = alloc_len;
    array->count = 0;
}",6762.0,6769.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5370,290074,clusterManagerNodeArrayReset,1,clusterManagerNodeArrayReset,void clusterManagerNodeArrayReset (clusterManagerNodeArray*),redis-cli.c,"static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
    if (array->nodes > array->alloc) {
        array->len = array->nodes - array->alloc;
        array->nodes = array->alloc;
        array->count = 0;
        int i = 0;
        for(; i < array->len; i++) {
            if (array->nodes[i] != NULL) array->count++;
        }
    }
}",6773.0,6783.0,1.0,1.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5371,290079,clusterManagerNodeArrayShift,1,clusterManagerNodeArrayShift,"void clusterManagerNodeArrayShift (clusterManagerNodeArray*,clusterManagerNode**)",redis-cli.c,"static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
                                         clusterManagerNode **nodeptr)
{
    assert(array->len > 0);
    /* If the first node to be shifted is not NULL, decrement count. */
    if (*array->nodes != NULL) array->count--;
    /* Store the first node to be shifted into 'nodeptr'. */
    *nodeptr = *array->nodes;
    /* Shift the nodes array and decrement length. */
    array->nodes++;
    array->len--;
}",6786.0,6797.0,1.0,1.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5372,290085,clusterManagerNodeArrayAdd,1,clusterManagerNodeArrayAdd,"void clusterManagerNodeArrayAdd (clusterManagerNodeArray*,clusterManagerNode*)",redis-cli.c,"static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
                                       clusterManagerNode *node)
{
    assert(array->len > 0);
    assert(node != NULL);
    assert(array->count < array->len);
    array->nodes[array->count++] = node;
}",6799.0,6806.0,1.0,1.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5373,290091,clusterManagerCommandCreate,1,clusterManagerCommandCreate,"int clusterManagerCommandCreate (int,char**)",redis-cli.c,"static int clusterManagerCommandCreate(int argc, char **argv) {
    int i, j, success = 1;
    cluster_manager.nodes = listCreate();
    for (i = 0; i < argc; i++) {
        char *addr = argv[i];
        char *ip = NULL;
        int port = 0;
        if (!parseClusterNodeAddress(addr, &ip, &port, NULL)) {
            fprintf(stderr, ""Invalid address format: %s\n"", addr);
            return 0;
        }

        clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
        if (!clusterManagerNodeConnect(node)) {
            freeClusterManagerNode(node);
            return 0;
        }
        char *err = NULL;
        if (!clusterManagerNodeIsCluster(node, &err)) {
            clusterManagerPrintNotClusterNodeError(node, err);
            if (err) zfree(err);
            freeClusterManagerNode(node);
            return 0;
        }
        err = NULL;
        if (!clusterManagerNodeLoadInfo(node, 0, &err)) {
            if (err) {
                CLUSTER_MANAGER_PRINT_REPLY_...",6849.0,7140.0,1.0,16.0,292.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5374,290097,clusterManagerCommandAddNode,1,clusterManagerCommandAddNode,"int clusterManagerCommandAddNode (int,char**)",redis-cli.c,"static int clusterManagerCommandAddNode(int argc, char **argv) {
    int success = 1;
    redisReply *reply = NULL;
    redisReply *function_restore_reply = NULL;
    redisReply *function_list_reply = NULL;
    char *ref_ip = NULL, *ip = NULL;
    int ref_port = 0, port = 0;
    if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))
        goto invalid_args;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))
        goto invalid_args;
    clusterManagerLogInfo("">>> Adding node %s:%d to cluster %s:%d\n"", ip, port,
                          ref_ip, ref_port);
    // Check the existing cluster
    clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port, 0);
    if (!clusterManagerLoadInfoFromNode(refnode)) return 0;
    if (!clusterManagerCheckCluster(0)) return 0;

    /* If --cluster-master-id was specified, try to resolve it now so that we
     * abort before starting with the node configuration. */
    clusterManagerNode *master_node = NULL;
   ...",7142.0,7295.0,1.0,4.0,154.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5375,290103,clusterManagerCommandDeleteNode,1,clusterManagerCommandDeleteNode,"int clusterManagerCommandDeleteNode (int,char**)",redis-cli.c,"static int clusterManagerCommandDeleteNode(int argc, char **argv) {
    UNUSED(argc);
    int success = 1;
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    char *node_id = argv[1];
    clusterManagerLogInfo("">>> Removing node %s from cluster %s:%d\n"",
                          node_id, ip, port);
    clusterManagerNode *ref_node = clusterManagerNewNode(ip, port, 0);
    clusterManagerNode *node = NULL;

    // Load cluster information
    if (!clusterManagerLoadInfoFromNode(ref_node)) return 0;

    // Check if the node exists and is not empty
    node = clusterManagerNodeByName(node_id);
    if (node == NULL) {
        clusterManagerLogErr(""[ERR] No such node ID %s\n"", node_id);
        return 0;
    }
    if (node->slots_count != 0) {
        clusterManagerLogErr(""[ERR] Node %s:%d is not empty! Reshard data ""
                             ""away and try again.\n"", node->ip, node->port);
        return 0;
    }

  ...",7297.0,7362.0,1.0,4.0,66.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5376,290109,clusterManagerCommandInfo,1,clusterManagerCommandInfo,"int clusterManagerCommandInfo (int,char**)",redis-cli.c,"static int clusterManagerCommandInfo(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    clusterManagerShowClusterInfo();
    return 1;
invalid_args:
    fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
    return 0;
}",7364.0,7375.0,1.0,20.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5377,290115,clusterManagerCommandCheck,1,clusterManagerCommandCheck,"int clusterManagerCommandCheck (int,char**)",redis-cli.c,"static int clusterManagerCommandCheck(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    clusterManagerShowClusterInfo();
    return clusterManagerCheckCluster(0);
invalid_args:
    fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
    return 0;
}",7377.0,7388.0,1.0,20.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5378,290121,clusterManagerCommandFix,1,clusterManagerCommandFix,"int clusterManagerCommandFix (int,char**)",redis-cli.c,"static int clusterManagerCommandFix(int argc, char **argv) {
    config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
    return clusterManagerCommandCheck(argc, argv);
}",7390.0,7393.0,1.0,44.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5379,290127,clusterManagerCommandReshard,1,clusterManagerCommandReshard,"int clusterManagerCommandReshard (int,char**)",redis-cli.c,"static int clusterManagerCommandReshard(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    clusterManagerCheckCluster(0);
    if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
        fflush(stdout);
        fprintf(stderr,
                ""*** Please fix your cluster problems before resharding\n"");
        return 0;
    }
    int slots = config.cluster_manager_command.slots;
    if (!slots) {
        while (slots <= 0 || slots > CLUSTER_MANAGER_SLOTS) {
            printf(""How many slots do you want to move (from 1 to %d)? "",
                   CLUSTER_MANAGER_SLOTS);
            fflush(stdout);
            char buf[6];
            int nread = read(fileno(stdin),buf,6);
            if (nread <= 0) continue;
            int last_idx = nread - 1;...",7395.0,7580.0,1.0,34.0,186.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5380,290133,clusterManagerCommandRebalance,1,clusterManagerCommandRebalance,"int clusterManagerCommandRebalance (int,char**)",redis-cli.c,"static int clusterManagerCommandRebalance(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    clusterManagerNode **weightedNodes = NULL;
    list *involved = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    int result = 1, i;
    if (config.cluster_manager_command.weight != NULL) {
        for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {
            char *name = config.cluster_manager_command.weight[i];
            char *p = strchr(name, '=');
            if (p == NULL) {
                clusterManagerLogErr(""*** invalid input %s\n"", name);
                result = 0;
                goto cleanup;
            }
            *p = '\0';
            float w = atof(++p);
            clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);
            if (n == NULL) {
                ...",7582.0,7775.0,1.0,16.0,194.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5381,290139,clusterManagerCommandSetTimeout,1,clusterManagerCommandSetTimeout,"int clusterManagerCommandSetTimeout (int,char**)",redis-cli.c,"static int clusterManagerCommandSetTimeout(int argc, char **argv) {
    UNUSED(argc);
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    int timeout = atoi(argv[1]);
    if (timeout < 100) {
        fprintf(stderr, ""Setting a node timeout of less than 100 ""
                ""milliseconds is a bad idea.\n"");
        return 0;
    }
    // Load cluster information
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    int ok_count = 0, err_count = 0;

    clusterManagerLogInfo("">>> Reconfiguring node timeout in every ""
                          ""cluster node...\n"");
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        char *err = NULL;
        redisReply *reply = CLUSTER_MANAGER_COMMAND(n, ""CONFIG %s %s %d"",
                     ...",7777.0,7833.0,1.0,4.0,57.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5382,290145,clusterManagerCommandImport,1,clusterManagerCommandImport,"int clusterManagerCommandImport (int,char**)",redis-cli.c,"static int clusterManagerCommandImport(int argc, char **argv) {
    int success = 1;
    int port = 0, src_port = 0;
    char *ip = NULL, *src_ip = NULL;
    char *invalid_args_msg = NULL;
    sds cmdfmt = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) {
        invalid_args_msg = CLUSTER_MANAGER_INVALID_HOST_ARG;
        goto invalid_args;
    }
    if (config.cluster_manager_command.from == NULL) {
        invalid_args_msg = ""[ERR] Option '--cluster-from' is required for ""
                           ""subcommand 'import'.\n"";
        goto invalid_args;
    }
    char *src_host[] = {config.cluster_manager_command.from};
    if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {
        invalid_args_msg = ""[ERR] Invalid --cluster-from host. You need to ""
                           ""pass a valid address (ie. 120.0.0.1:7000).\n"";
        goto invalid_args;
    }
    clusterManagerLogInfo("">>> Importing data from %s:%d to cluster %s:%d\n"",
                ...",7835.0,7988.0,1.0,27.0,154.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5383,290151,clusterManagerCommandCall,1,clusterManagerCommandCall,"int clusterManagerCommandCall (int,char**)",redis-cli.c,"static int clusterManagerCommandCall(int argc, char **argv) {
    int port = 0, i;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(refnode)) return 0;
    argc--;
    argv++;
    size_t *argvlen = zmalloc(argc*sizeof(size_t));
    clusterManagerLogInfo("">>> Calling"");
    for (i = 0; i < argc; i++) {
        argvlen[i] = strlen(argv[i]);
        printf("" %s"", argv[i]);
    }
    printf(""\n"");
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if ((config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_MASTERS_ONLY)
              && (n->replicate != NULL)) continue;  // continue if node is slave
        if ((config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_SLAVES_ONLY)
              &...",7990.0,8032.0,1.0,4.0,43.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5384,290157,clusterManagerCommandHelp,1,clusterManagerCommandHelp,"int clusterManagerCommandHelp (int,char**)",redis-cli.c,"static int clusterManagerCommandHelp(int argc, char **argv) {
    UNUSED(argc);
    UNUSED(argv);
    int commands_count = sizeof(clusterManagerCommands) /
                         sizeof(clusterManagerCommandDef);
    int i = 0, j;
    fprintf(stdout, ""Cluster Manager Commands:\n"");
    int padding = 15;
    for (; i < commands_count; i++) {
        clusterManagerCommandDef *def = &(clusterManagerCommands[i]);
        int namelen = strlen(def->name), padlen = padding - namelen;
        fprintf(stdout, ""  %s"", def->name);
        for (j = 0; j < padlen; j++) fprintf(stdout, "" "");
        fprintf(stdout, ""%s\n"", (def->args ? def->args : """"));
        if (def->options != NULL) {
            int optslen = strlen(def->options);
            char *p = def->options, *eos = p + optslen;
            char *comma = NULL;
            while ((comma = strchr(p, ',')) != NULL) {
                int deflen = (int)(comma - p);
                char buf[255];
                memcpy(buf, p, deflen);
  ...",8098.0,8151.0,1.0,4.0,54.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5385,290163,clusterManagerCommandBackup,1,clusterManagerCommandBackup,"int clusterManagerCommandBackup (int,char**)",redis-cli.c,"static int clusterManagerCommandBackup(int argc, char **argv) {
    UNUSED(argc);
    int success = 1, port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(refnode)) return 0;
    int no_issues = clusterManagerCheckCluster(0);
    int cluster_errors_count = (no_issues ? 0 :
                                listLength(cluster_manager.errors));
    config.cluster_manager_command.backup_dir = argv[1];
    /* TODO: check if backup_dir is a valid directory. */
    sds json = sdsnew(""[\n"");
    int first_node = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        if (!first_node) first_node = 1;
        else json = sdscat(json, "",\n"");
        clusterManagerNode *node = ln->value;
        sds node_json = clusterManagerNodeGetJSON(node, cluster_errors...",8034.0,8096.0,1.0,4.0,63.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5386,290276,getRDB,1,getRDB,void getRDB (clusterManagerNode*),redis-cli.c,"static void getRDB(clusterManagerNode *node) {
    int fd;
    redisContext *s;
    char *filename;
    if (node != NULL) {
        assert(node->context);
        s = node->context;
        filename = clusterManagerGetNodeRDBFilename(node);
    } else {
        s = context;
        filename = config.rdb_filename;
    }
    static char eofmark[RDB_EOF_MARK_SIZE];
    static char lastbytes[RDB_EOF_MARK_SIZE];
    static int usemark = 0;
    unsigned long long payload = sendSync(s, 1, eofmark, NULL);
    char buf[4096];

    if (payload == 0) {
        payload = ULLONG_MAX;
        memset(lastbytes,0,RDB_EOF_MARK_SIZE);
        usemark = 1;
        fprintf(stderr,""SYNC sent to master, writing bytes of bulk transfer ""
                ""until EOF marker to '%s'\n"", filename);
    } else {
        fprintf(stderr,""SYNC sent to master, writing %llu bytes to '%s'\n"",
            payload, filename);
    }

    int write_to_stdout = !strcmp(filename,""-"");
    /* Write to file. */
    if (write_...",8573.0,8665.0,1.0,24.0,93.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5387,290443,validateClusterManagerCommand,1,validateClusterManagerCommand,clusterManagerCommandProc validateClusterManagerCommand (void),redis-cli.c,"static clusterManagerCommandProc *validateClusterManagerCommand(void) {
    int i, commands_count = sizeof(clusterManagerCommands) /
                            sizeof(clusterManagerCommandDef);
    clusterManagerCommandProc *proc = NULL;
    char *cmdname = config.cluster_manager_command.name;
    int argc = config.cluster_manager_command.argc;
    for (i = 0; i < commands_count; i++) {
        clusterManagerCommandDef cmddef = clusterManagerCommands[i];
        if (!strcmp(cmddef.name, cmdname)) {
            if ((cmddef.arity > 0 && argc != cmddef.arity) ||
                (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
                fprintf(stderr, ""[ERR] Wrong number of arguments for ""
                                ""specified --cluster sub command\n"");
                return NULL;
            }
            proc = cmddef.proc;
        }
    }
    if (!proc) fprintf(stderr, ""Unknown --cluster subcommand\n"");
    return proc;
}",3813.0,3833.0,1.0,1.0,21.0,33,13,30,11,0,12,5,8,5,0,,0,12,2,1,1,clusterManagerCommandProc
5388,290549,parseClusterNodeAddress,1,parseClusterNodeAddress,"int parseClusterNodeAddress (char*,char**,int*,int*)",redis-cli.c,"static int parseClusterNodeAddress(char *addr, char **ip_ptr, int *port_ptr,
                                   int *bus_port_ptr)
{
    /* ip:port[@bus_port] */
    char *c = strrchr(addr, '@');
    if (c != NULL) {
        *c = '\0';
        if (bus_port_ptr != NULL)
            *bus_port_ptr = atoi(c + 1);
    }
    c = strrchr(addr, ':');
    if (c != NULL) {
        *c = '\0';
        *ip_ptr = addr;
        *port_ptr = atoi(++c);
    } else return 0;
    return 1;
}",3835.0,3852.0,1.0,1.0,18.0,17,5,18,6,1,0,4,5,0,0,,0,0,8,4,4,int
5389,290614,getClusterHostFromCmdArgs,1,getClusterHostFromCmdArgs,"int getClusterHostFromCmdArgs (int,char**,char**,int*)",redis-cli.c,"static int getClusterHostFromCmdArgs(int argc, char **argv,
                                     char **ip_ptr, int *port_ptr) {
    int port = 0;
    char *ip = NULL;
    if (argc == 1) {
        char *addr = argv[0];
        if (!parseClusterNodeAddress(addr, &ip, &port, NULL)) return 0;
    } else {
        ip = argv[0];
        port = atoi(argv[1]);
    }
    if (!ip || !port) return 0;
    else {
        *ip_ptr = ip;
        *port_ptr = port;
    }
    return 1;
}",3860.0,3877.0,1.0,1.0,18.0,11,6,12,6,0,1,4,5,1,1,,0,1,8,4,4,int
5390,290687,freeClusterManagerNodeFlags,1,freeClusterManagerNodeFlags,void freeClusterManagerNodeFlags (list*),redis-cli.c,"static void freeClusterManagerNodeFlags(list *flags) {
    listIter li;
    listNode *ln;
    listRewind(flags, &li);
    while ((ln = listNext(&li)) != NULL) {
        sds flag = ln->value;
        sdsfree(flag);
    }
    listRelease(flags);
}",3879.0,3888.0,1.0,1.0,10.0,6,4,9,5,1,5,2,2,1,4,,0,2,2,1,1,void
5391,290717,freeClusterManagerNode,1,freeClusterManagerNode,void freeClusterManagerNode (clusterManagerNode*),redis-cli.c,"static void freeClusterManagerNode(clusterManagerNode *node) {
    if (node->context != NULL) redisFree(node->context);
    if (node->friends != NULL) {
        listIter li;
        listNode *ln;
        listRewind(node->friends,&li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerNode *fn = ln->value;
            freeClusterManagerNode(fn);
        }
        listRelease(node->friends);
        node->friends = NULL;
    }
    if (node->name != NULL) sdsfree(node->name);
    if (node->replicate != NULL) sdsfree(node->replicate);
    if ((node->flags & CLUSTER_MANAGER_FLAG_FRIEND) && node->ip)
        sdsfree(node->ip);
    int i;
    if (node->migrating != NULL) {
        for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
        zfree(node->migrating);
    }
    if (node->importing != NULL) {
        for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
        zfree(node->importing);
    }
    if (node->flags_str !=...",3890.0,3921.0,1.0,23.0,32.0,44,8,43,6,1,33,12,15,12,10,,0,24,2,1,1,void
5392,290892,freeClusterManager,1,freeClusterManager,void freeClusterManager (void),redis-cli.c,"static void freeClusterManager(void) {
    listIter li;
    listNode *ln;
    if (cluster_manager.nodes != NULL) {
        listRewind(cluster_manager.nodes,&li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerNode *n = ln->value;
            freeClusterManagerNode(n);
        }
        listRelease(cluster_manager.nodes);
        cluster_manager.nodes = NULL;
    }
    if (cluster_manager.errors != NULL) {
        listRewind(cluster_manager.errors,&li);
        while ((ln = listNext(&li)) != NULL) {
            sds err = ln->value;
            sdsfree(err);
        }
        listRelease(cluster_manager.errors);
        cluster_manager.errors = NULL;
    }
    if (clusterManagerUncoveredSlots != NULL)
        dictRelease(clusterManagerUncoveredSlots);
}",3923.0,3946.0,1.0,1.0,24.0,25,5,29,7,1,29,6,8,7,9,,0,22,2,1,1,void
5393,291109,clusterManagerGetNodeRDBFilename,1,clusterManagerGetNodeRDBFilename,sds clusterManagerGetNodeRDBFilename (clusterManagerNode*),redis-cli.c,"static sds clusterManagerGetNodeRDBFilename(clusterManagerNode *node) {
    assert(config.cluster_manager_command.backup_dir);
    sds filename = sdsnew(config.cluster_manager_command.backup_dir);
    if (filename[sdslen(filename) - 1] != '/')
        filename = sdscat(filename, ""/"");
    filename = sdscatprintf(filename, ""redis-node-%s-%d-%s.rdb"", node->ip,
                            node->port, node->name);
    return filename;
}",3976.0,3984.0,1.0,1.0,9.0,13,6,13,3,0,11,2,2,1,4,,0,11,2,1,1,sds
5394,291160,clusterManagerCheckRedisReply,1,clusterManagerCheckRedisReply,"int clusterManagerCheckRedisReply (clusterManagerNode*,redisReply*,char**)",redis-cli.c,"static int clusterManagerCheckRedisReply(clusterManagerNode *n,
                                         redisReply *r, char **err)
{
    int is_err = 0;
    if (!r || (is_err = (r->type == REDIS_REPLY_ERROR))) {
        if (is_err) {
            if (err != NULL) {
                *err = zmalloc((r->len + 1) * sizeof(char));
                redis_strlcpy(*err, r->str,(r->len + 1));
            } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
        }
        return 0;
    }
    return 1;
}",3990.0,4004.0,1.0,19.0,15.0,17,10,14,6,15,2,4,7,0,2,,0,1,6,3,3,int
5395,291238,clusterManagerStartTransaction,1,clusterManagerStartTransaction,int clusterManagerStartTransaction (clusterManagerNode*),redis-cli.c,"static int clusterManagerStartTransaction(clusterManagerNode *node) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""MULTI"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4007.0,4012.0,1.0,24.0,6.0,3,2,10,4,1,2,2,2,0,1,,0,2,2,1,1,int
5396,291269,clusterManagerExecTransaction,1,clusterManagerExecTransaction,"int clusterManagerExecTransaction (clusterManagerNode*,clusterManagerOnReplyError)",redis-cli.c,"static int clusterManagerExecTransaction(clusterManagerNode *node,
                                         clusterManagerOnReplyError onerror)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""EXEC"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (success) {
        if (reply->type != REDIS_REPLY_ARRAY) {
            success = 0;
            goto cleanup;
        }
        size_t i;
        for (i = 0; i < reply->elements; i++) {
            redisReply *r = reply->element[i];
            char *err = NULL;
            success = clusterManagerCheckRedisReply(node, r, &err);
            if (!success && onerror) success = onerror(r, node, i);
            if (err) {
                if (!success)
                    CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
                zfree(err);
            }
            if (!success) break;
        }
    }
cleanup:
    if (reply) freeReplyObject(reply);
    return success;
}",4015.0,4042.0,1.0,24.0,28.0,22,8,41,9,1,7,11,20,0,4,,0,5,4,2,2,int
5397,291389,clusterManagerNodeConnect,1,clusterManagerNodeConnect,int clusterManagerNodeConnect (clusterManagerNode*),redis-cli.c,"static int clusterManagerNodeConnect(clusterManagerNode *node) {
    if (node->context) redisFree(node->context);
    node->context = redisConnect(node->ip, node->port);
    if (!node->context->err && config.tls) {
        const char *err = NULL;
        if (cliSecureConnection(node->context, config.sslconfig, &err) == REDIS_ERR && err) {
            fprintf(stderr,""TLS Error: %s\n"", err);
            redisFree(node->context);
            node->context = NULL;
            return 0;
        }
    }
    if (node->context->err) {
        fprintf(stderr,""Could not connect to Redis at "");
        fprintf(stderr,""%s:%d: %s\n"", node->ip, node->port,
                node->context->errstr);
        redisFree(node->context);
        node->context = NULL;
        return 0;
    }
    /* Set aggressive KEEP_ALIVE socket option in the Redis context socket
     * in order to prevent timeouts caused by the execution of long
     * commands. At the same time this improves the detection of real
     ...",4044.0,4081.0,1.0,43.0,38.0,43,8,44,8,0,30,9,13,13,3,,0,29,2,1,1,int
5398,291575,clusterManagerRemoveNodeFromList,1,clusterManagerRemoveNodeFromList,"void clusterManagerRemoveNodeFromList (list*,clusterManagerNode*)",redis-cli.c,"static void clusterManagerRemoveNodeFromList(list *nodelist,
                                             clusterManagerNode *node) {
    listIter li;
    listNode *ln;
    listRewind(nodelist, &li);
    while ((ln = listNext(&li)) != NULL) {
        if (node == ln->value) {
            listDelNode(nodelist, ln);
            break;
        }
    }
}",4083.0,4094.0,1.0,1.0,12.0,6,5,9,5,4,4,4,4,2,3,,0,2,4,2,2,void
5399,291773,clusterManagerGetNodeRedisInfo,1,clusterManagerGetNodeRedisInfo,"redisReply clusterManagerGetNodeRedisInfo (clusterManagerNode*,char**)",redis-cli.c,"static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
                                                  char **err)
{
    redisReply *info = CLUSTER_MANAGER_COMMAND(node, ""INFO"");
    if (err != NULL) *err = NULL;
    if (info == NULL) return NULL;
    if (info->type == REDIS_REPLY_ERROR) {
        if (err != NULL) {
            *err = zmalloc((info->len + 1) * sizeof(char));
            redis_strlcpy(*err, info->str,(info->len + 1));
        }
        freeReplyObject(info);
        return  NULL;
    }
    return info;
}",4149.0,4164.0,1.0,23.0,16.0,19,8,23,6,0,3,5,6,0,2,,0,2,4,2,2,redisReply
5400,292561,clusterManagerNodeFlagString,1,clusterManagerNodeFlagString,sds clusterManagerNodeFlagString (clusterManagerNode*),redis-cli.c,"static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
    sds flags = sdsempty();
    if (!node->flags_str) return flags;
    int empty = 1;
    listIter li;
    listNode *ln;
    listRewind(node->flags_str, &li);
    while ((ln = listNext(&li)) != NULL) {
        sds flag = ln->value;
        if (strcmp(flag, ""myself"") == 0) continue;
        if (!empty) flags = sdscat(flags, "","");
        flags = sdscatfmt(flags, ""%S"", flag);
        empty = 0;
    }
    return flags;
}",4377.0,4392.0,1.0,1.0,16.0,16,6,20,7,1,8,6,7,2,5,,0,7,2,1,1,sds
5401,292633,clusterManagerNodeSlotsString,1,clusterManagerNodeSlotsString,sds clusterManagerNodeSlotsString (clusterManagerNode*),redis-cli.c,"static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
    sds slots = sdsempty();
    int first_range_idx = -1, last_slot_idx = -1, i;
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        int has_slot = node->slots[i];
        if (has_slot) {
            if (first_range_idx == -1) {
                if (sdslen(slots)) slots = sdscat(slots, "","");
                first_range_idx = i;
                slots = sdscatfmt(slots, ""[%u"", i);
            }
            last_slot_idx = i;
        } else {
            if (last_slot_idx >= 0) {
                if (first_range_idx == last_slot_idx)
                    slots = sdscat(slots, ""]"");
                else slots = sdscatfmt(slots, ""-%u]"", last_slot_idx);
            }
            last_slot_idx = -1;
            first_range_idx = -1;
        }
    }
    if (last_slot_idx >= 0) {
        if (first_range_idx == last_slot_idx) slots = sdscat(slots, ""]"");
        else slots = sdscatfmt(slots, ""-%u]"", last_slot_idx);
    }
 ...",4395.0,4422.0,1.0,20.0,28.0,19,7,26,6,2,6,7,14,1,5,,0,6,2,1,1,sds
5402,292762,clusterManagerNodeGetJSON,1,clusterManagerNodeGetJSON,"sds clusterManagerNodeGetJSON (clusterManagerNode*,long unsigned)",redis-cli.c,"static sds clusterManagerNodeGetJSON(clusterManagerNode *node,
                                     unsigned long error_count)
{
    sds json = sdsempty();
    sds replicate = sdsempty();
    if (node->replicate)
        replicate = sdscatprintf(replicate, ""\""%s\"""", node->replicate);
    else
        replicate = sdscat(replicate, ""null"");
    sds slots = clusterManagerNodeSlotsString(node);
    sds flags = clusterManagerNodeFlagString(node);
    char *p = slots;
    while ((p = strchr(p, '-')) != NULL)
        *(p++) = ',';
    json = sdscatprintf(json,
        ""  {\n""
        ""    \""name\"": \""%s\"",\n""
        ""    \""host\"": \""%s\"",\n""
        ""    \""port\"": %d,\n""
        ""    \""replicate\"": %s,\n""
        ""    \""slots\"": [%s],\n""
        ""    \""slots_count\"": %d,\n""
        ""    \""flags\"": \""%s\"",\n""
        ""    \""current_epoch\"": %llu"",
        node->name,
        node->ip,
        node->port,
        replicate,
        slots,
        node->slots_count,
        flags,
        (u...",4424.0,4496.0,1.0,1.0,73.0,64,9,89,14,0,42,14,28,11,25,,0,37,4,2,2,sds
5403,293046,clusterManagerKeyHashSlot,1,clusterManagerKeyHashSlot,"unsigned int clusterManagerKeyHashSlot (char*,int)",redis-cli.c,"static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) & 0x3FFF;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) & 0x3FFF;
}",4509.0,4528.0,1.0,1.0,20.0,17,7,21,4,0,3,5,5,0,3,,0,0,4,2,2,unsigned int
5404,293587,clusterManagerAddSlots,1,clusterManagerAddSlots,"int clusterManagerAddSlots (clusterManagerNode*,char**)",redis-cli.c,"static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
{
    redisReply *reply = NULL;
    void *_reply = NULL;
    int success = 1;
    /* First two args are used for the command itself. */
    int argc = node->slots_count + 2;
    sds *argv = zmalloc(argc * sizeof(*argv));
    size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
    argv[0] = ""CLUSTER"";
    argv[1] = ""ADDSLOTS"";
    argvlen[0] = 7;
    argvlen[1] = 8;
    *err = NULL;
    int i, argv_idx = 2;
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        if (argv_idx >= argc) break;
        if (node->slots[i]) {
            argv[argv_idx] = sdsfromlonglong((long long) i);
            argvlen[argv_idx] = sdslen(argv[argv_idx]);
            argv_idx++;
        }
    }
    if (argv_idx == 2) {
        success = 0;
        goto cleanup;
    }
    redisAppendCommandArgv(node->context,argc,(const char**)argv,argvlen);
    if (redisGetReply(node->context, &_reply) != REDIS_OK) {
        success = 0;
        got...",4624.0,4666.0,1.0,20.0,43.0,52,14,61,12,0,11,12,12,2,7,,0,9,4,2,2,int
5405,293780,clusterManagerGetSlotOwner,1,clusterManagerGetSlotOwner,"clusterManagerNode clusterManagerGetSlotOwner (clusterManagerNode*,int,char**)",redis-cli.c,"static clusterManagerNode *clusterManagerGetSlotOwner(clusterManagerNode *n,
                                                      int slot, char **err)
{
    assert(slot >= 0 && slot < CLUSTER_MANAGER_SLOTS);
    clusterManagerNode *owner = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(n, ""CLUSTER SLOTS"");
    if (clusterManagerCheckRedisReply(n, reply, err)) {
        assert(reply->type == REDIS_REPLY_ARRAY);
        size_t i;
        for (i = 0; i < reply->elements; i++) {
            redisReply *r = reply->element[i];
            assert(r->type == REDIS_REPLY_ARRAY && r->elements >= 3);
            int from, to;
            from = r->element[0]->integer;
            to = r->element[1]->integer;
            if (slot < from || slot > to) continue;
            redisReply *nr =  r->element[2];
            assert(nr->type == REDIS_REPLY_ARRAY && nr->elements >= 2);
            char *name = NULL;
            if (nr->elements >= 3)
                name =  nr->element[2]->str;
 ...",4672.0,4715.0,1.0,31.0,44.0,47,10,47,13,2,3,10,17,1,2,,0,3,6,3,3,clusterManagerNode
5406,294018,clusterManagerSetSlot,1,clusterManagerSetSlot,"int clusterManagerSetSlot (clusterManagerNode*,clusterManagerNode*,int,char*,char**)",redis-cli.c,"static int clusterManagerSetSlot(clusterManagerNode *node1,
                                 clusterManagerNode *node2,
                                 int slot, const char *status, char **err) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, ""CLUSTER ""
                                                ""SETSLOT %d %s %s"",
                                                slot, status,
                                                (char *) node2->name);
    if (err != NULL) *err = NULL;
    if (!reply) {
        if (err) *err = zstrdup(""CLUSTER SETSLOT failed to run"");
        return 0;
    }
    int success = 1;
    if (reply->type == REDIS_REPLY_ERROR) {
        success = 0;
        if (err != NULL) {
            *err = zmalloc((reply->len + 1) * sizeof(char));
            redis_strlcpy(*err, reply->str,(reply->len + 1));
        } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply->str);
        goto cleanup;
    }
cleanup:
    freeReplyObject(reply);
    return success;
}",4718.0,4742.0,1.0,24.0,25.0,25,10,27,10,11,5,7,8,0,3,,0,4,10,5,5,int
5407,294136,clusterManagerClearSlotStatus,1,clusterManagerClearSlotStatus,"int clusterManagerClearSlotStatus (clusterManagerNode*,int)",redis-cli.c,"static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER SETSLOT %d %s"", slot, ""STABLE"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4744.0,4750.0,1.0,24.0,7.0,3,2,11,5,3,2,2,2,0,1,,0,2,4,2,2,int
5408,294169,clusterManagerDelSlot,1,clusterManagerDelSlot,"int clusterManagerDelSlot (clusterManagerNode*,int,int)",redis-cli.c,"static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
                                 int ignore_unassigned_err)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER DELSLOTS %d"", slot);
    char *err = NULL;
    int success = clusterManagerCheckRedisReply(node, reply, &err);
    if (!success && reply && reply->type == REDIS_REPLY_ERROR &&
        ignore_unassigned_err)
    {
        char *get_owner_err = NULL;
        clusterManagerNode *assigned_to =
            clusterManagerGetSlotOwner(node, slot, &get_owner_err);
        if (!assigned_to) {
            if (get_owner_err == NULL) success = 1;
            else {
                CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, get_owner_err);
                zfree(get_owner_err);
            }
        }
    }
    if (!success && err != NULL) {
        CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
        zfree(err);
    }
    if (reply) freeReplyObject(reply);
    return success;
}",4752.0,4779.0,1.0,24.0,28.0,22,7,37,10,3,7,6,9,0,4,,0,5,6,3,3,int
5409,294287,clusterManagerAddSlot,1,clusterManagerAddSlot,"int clusterManagerAddSlot (clusterManagerNode*,int)",redis-cli.c,"static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER ADDSLOTS %d"", slot);
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4781.0,4787.0,1.0,24.0,7.0,3,2,11,5,1,2,2,2,0,1,,0,2,4,2,2,int
5410,294319,clusterManagerCountKeysInSlot,1,clusterManagerCountKeysInSlot,"signed int clusterManagerCountKeysInSlot (clusterManagerNode*,int)",redis-cli.c,"static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
                                                int slot)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER COUNTKEYSINSLOT %d"", slot);
    int count = -1;
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
    if (reply) freeReplyObject(reply);
    return count;
}",4789.0,4799.0,1.0,24.0,11.0,10,5,17,7,1,2,3,3,0,1,,0,2,4,2,2,signed int
5411,294370,clusterManagerBumpEpoch,1,clusterManagerBumpEpoch,int clusterManagerBumpEpoch (clusterManagerNode*),redis-cli.c,"static int clusterManagerBumpEpoch(clusterManagerNode *node) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER BUMPEPOCH"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",4801.0,4806.0,1.0,24.0,6.0,3,2,10,4,1,2,2,2,0,1,,0,2,2,1,1,int
5412,294400,clusterManagerOnSetOwnerErr,1,clusterManagerOnSetOwnerErr,"int clusterManagerOnSetOwnerErr (redisReply*,clusterManagerNode*,int)",redis-cli.c,"static int clusterManagerOnSetOwnerErr(redisReply *reply,
    clusterManagerNode *n, int bulk_idx)
{
    UNUSED(reply);
    UNUSED(n);
    /* Only raise error when ADDSLOTS fail (bulk_idx == 1). */
    return (bulk_idx != 1);
}",4811.0,4818.0,1.0,4.0,8.0,3,2,5,3,0,0,1,1,0,0,,0,0,6,3,3,int
5413,294423,clusterManagerSetSlotOwner,1,clusterManagerSetSlotOwner,"int clusterManagerSetSlotOwner (clusterManagerNode*,int,int)",redis-cli.c,"static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
                                      int slot,
                                      int do_clear)
{
    int success = clusterManagerStartTransaction(owner);
    if (!success) return 0;
    /* Ensure the slot is not already assigned. */
    clusterManagerDelSlot(owner, slot, 1);
    /* Add the slot and bump epoch. */
    clusterManagerAddSlot(owner, slot);
    if (do_clear) clusterManagerClearSlotStatus(owner, slot);
    clusterManagerBumpEpoch(owner);
    success = clusterManagerExecTransaction(owner, clusterManagerOnSetOwnerErr);
    return success;
}",4820.0,4834.0,1.0,1.0,15.0,3,2,14,4,5,6,3,3,0,6,,0,2,6,3,3,int
5414,294463,clusterManagerCompareKeysValues,1,clusterManagerCompareKeysValues,"int clusterManagerCompareKeysValues (clusterManagerNode*,clusterManagerNode*,redisReply*,list*)",redis-cli.c,"static int clusterManagerCompareKeysValues(clusterManagerNode *n1,
                                          clusterManagerNode *n2,
                                          redisReply *keys_reply,
                                          list *diffs)
{
    size_t i, argc = keys_reply->elements + 2;
    static const char *hash_zero = ""0000000000000000000000000000000000000000"";
    char **argv = zcalloc(argc * sizeof(char *));
    size_t  *argv_len = zcalloc(argc * sizeof(size_t));
    argv[0] = ""DEBUG"";
    argv_len[0] = 5;
    argv[1] = ""DIGEST-VALUE"";
    argv_len[1] = 12;
    for (i = 0; i < keys_reply->elements; i++) {
        redisReply *entry = keys_reply->element[i];
        int idx = i + 2;
        argv[idx] = entry->str;
        argv_len[idx] = entry->len;
    }
    int success = 0;
    void *_reply1 = NULL, *_reply2 = NULL;
    redisReply *r1 = NULL, *r2 = NULL;
    redisAppendCommandArgv(n1->context,argc, (const char**)argv,argv_len);
    success = (redisGetReply(n1->co...",4841.0,4898.0,1.0,8.0,58.0,102,14,111,24,1,15,16,14,0,7,,0,10,8,4,4,int
5415,294813,clusterManagerMigrateKeysInReply,1,clusterManagerMigrateKeysInReply,"redisReply clusterManagerMigrateKeysInReply (clusterManagerNode*,clusterManagerNode*,redisReply*,int,int,char*)",redis-cli.c,"static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
                                                    clusterManagerNode *target,
                                                    redisReply *reply,
                                                    int replace, int timeout,
                                                    char *dots)
{
    redisReply *migrate_reply = NULL;
    char **argv = NULL;
    size_t *argv_len = NULL;
    int c = (replace ? 8 : 7);
    if (config.conn_info.auth) c += 2;
    if (config.conn_info.user) c += 1;
    size_t argc = c + reply->elements;
    size_t i, offset = 6; // Keys Offset
    argv = zcalloc(argc * sizeof(char *));
    argv_len = zcalloc(argc * sizeof(size_t));
    char portstr[255];
    char timeoutstr[255];
    snprintf(portstr, 10, ""%d"", target->port);
    snprintf(timeoutstr, 10, ""%d"", timeout);
    argv[0] = ""MIGRATE"";
    argv_len[0] = 7;
    argv[1] = target->ip;
    argv_len[1] = strlen(target->ip);
 ...",4903.0,4983.0,1.0,1.0,81.0,121,15,119,25,2,26,12,13,8,5,,0,24,12,6,6,redisReply
5416,295230,clusterManagerMigrateKeysInSlot,1,clusterManagerMigrateKeysInSlot,"int clusterManagerMigrateKeysInSlot (clusterManagerNode*,clusterManagerNode*,int,int,int,int,char**)",redis-cli.c,"static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
                                           clusterManagerNode *target,
                                           int slot, int timeout,
                                           int pipeline, int verbose,
                                           char **err)
{
    int success = 1;
    int do_fix = config.cluster_manager_command.flags &
                 CLUSTER_MANAGER_CMD_FLAG_FIX;
    int do_replace = config.cluster_manager_command.flags &
                     CLUSTER_MANAGER_CMD_FLAG_REPLACE;
    while (1) {
        char *dots = NULL;
        redisReply *reply = NULL, *migrate_reply = NULL;
        reply = CLUSTER_MANAGER_COMMAND(source, ""CLUSTER ""
                                        ""GETKEYSINSLOT %d %d"", slot,
                                        pipeline);
        success = (reply != NULL);
        if (!success) return 0;
        if (reply->type == REDIS_REPLY_ERROR) {
            success = 0;
    ...",4986.0,5141.0,1.0,17.0,156.0,108,16,150,28,1,45,34,86,2,27,,0,27,14,7,7,int
5417,295740,clusterManagerMoveSlot,1,clusterManagerMoveSlot,"int clusterManagerMoveSlot (clusterManagerNode*,clusterManagerNode*,int,int,char**)",redis-cli.c,"static int clusterManagerMoveSlot(clusterManagerNode *source,
                                  clusterManagerNode *target,
                                  int slot, int opts,  char**err)
{
    if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) {
        printf(""Moving slot %d from %s:%d to %s:%d: "", slot, source->ip,
               source->port, target->ip, target->port);
        fflush(stdout);
    }
    if (err != NULL) *err = NULL;
    int pipeline = config.cluster_manager_command.pipeline,
        timeout = config.cluster_manager_command.timeout,
        print_dots = (opts & CLUSTER_MANAGER_OPT_VERBOSE),
        option_cold = (opts & CLUSTER_MANAGER_OPT_COLD),
        success = 1;
    if (!option_cold) {
        success = clusterManagerSetSlot(target, source, slot,
                                        ""importing"", err);
        if (!success) return 0;
        success = clusterManagerSetSlot(source, target, slot,
                                        ""migrating"", err);
        if (...",5152.0,5223.0,1.0,17.0,72.0,69,13,87,18,3,23,18,27,2,9,,0,21,10,5,5,int
5418,297561,clusterManagerSlotCompare,1,clusterManagerSlotCompare,"int clusterManagerSlotCompare (void*,void*)",redis-cli.c,"int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
    const char **i1 = (const char **)slot1;
    const char **i2 = (const char **)slot2;
    return strcmp(*i1, *i2);
}",5573.0,5577.0,1.0,1.0,5.0,6,3,6,4,0,0,1,1,0,0,,0,0,4,2,2,int
5419,297585,clusterManagerSlotCountCompareDesc,1,clusterManagerSlotCountCompareDesc,"int clusterManagerSlotCountCompareDesc (void*,void*)",redis-cli.c,"int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
    clusterManagerNode *node2 = *((clusterManagerNode **) n2);
    return node2->slots_count - node1->slots_count;
}",5579.0,5583.0,1.0,1.0,5.0,9,5,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
5420,297613,clusterManagerCompareNodeBalance,1,clusterManagerCompareNodeBalance,"int clusterManagerCompareNodeBalance (void*,void*)",redis-cli.c,"int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
    clusterManagerNode *node2 = *((clusterManagerNode **) n2);
    return node1->balance - node2->balance;
}",5585.0,5589.0,1.0,1.0,5.0,9,5,6,4,0,2,1,1,0,0,,0,2,4,2,2,int
5421,297641,clusterManagerGetConfigSignature,1,clusterManagerGetConfigSignature,sds clusterManagerGetConfigSignature (clusterManagerNode*),redis-cli.c,"static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
    sds signature = NULL;
    int node_count = 0, i = 0, name_len = 0;
    char **node_configs = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    if (reply == NULL || reply->type == REDIS_REPLY_ERROR)
        goto cleanup;
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        i = 0;
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *nodename = NULL;
        int tot_size = 0;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            if (i == 0) {
                nodename = token;
                tot_size = (p - token);
                name_len = tot_size++; // Make room for ':' in tot_size
            }
            if (++i == 8) break;
        }
        if (i != 8) continue;
        if (nodename == NULL) continue;
        int re...",5591.0,5682.0,1.0,24.0,92.0,118,18,153,24,0,9,29,52,0,8,,0,7,2,1,1,sds
5422,298182,clusterManagerGetDisconnectedLinks,1,clusterManagerGetDisconnectedLinks,list clusterManagerGetDisconnectedLinks (clusterManagerNode*),redis-cli.c,"static list *clusterManagerGetDisconnectedLinks(clusterManagerNode *node) {
    list *links = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    if (!clusterManagerCheckRedisReply(node, reply, NULL)) goto cleanup;
    links = listCreate();
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        int i = 0;
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *nodename = NULL, *addr = NULL, *flags = NULL, *link_status = NULL;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            if (i == 0) nodename = token;
            else if (i == 1) addr = token;
            else if (i == 2) flags = token;
            else if (i == 7) link_status = token;
            else if (i == 8) break;
            i++;
        }
        if (i == 7) link_status = line;
        if (nodename == NULL || addr == NULL || flags == NUL...",5711.0,5753.0,1.0,24.0,43.0,57,10,77,16,0,11,13,17,1,6,,0,10,2,1,1,list
5423,298598,clusterManagerGetCoveredSlots,1,clusterManagerGetCoveredSlots,int clusterManagerGetCoveredSlots (char*),redis-cli.c,"static int clusterManagerGetCoveredSlots(char *all_slots) {
    if (cluster_manager.nodes == NULL) return 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    int totslots = 0, i;
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
            if (node->slots[i] && !all_slots[i]) {
                all_slots[i] = 1;
                totslots++;
            }
        }
    }
    return totslots;
}",5804.0,5820.0,1.0,24.0,17.0,20,11,20,8,0,8,5,8,4,2,,0,7,2,1,1,int
5424,298674,clusterManagerPrintSlotsList,1,clusterManagerPrintSlotsList,void clusterManagerPrintSlotsList (list*),redis-cli.c,"static void clusterManagerPrintSlotsList(list *slots) {
    clusterManagerNode n = {0};
    listIter li;
    listNode *ln;
    listRewind(slots, &li);
    while ((ln = listNext(&li)) != NULL) {
        int slot = atoi(ln->value);
        if (slot >= 0 && slot < CLUSTER_MANAGER_SLOTS)
            n.slots[slot] = 1;
    }
    sds nodeslist = clusterManagerNodeSlotsString(&n);
    printf(""%s\n"", nodeslist);
    sdsfree(nodeslist);
}",5822.0,5835.0,1.0,32.0,14.0,16,10,16,7,3,6,3,4,1,4,,0,4,2,1,1,void
5425,298735,clusterManagerGetNodeWithMostKeysInSlot,1,clusterManagerGetNodeWithMostKeysInSlot,"clusterManagerNode clusterManagerGetNodeWithMostKeysInSlot (list*,int,char**)",redis-cli.c,"static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
                                                                    int slot,
                                                                    char **err)
{
    clusterManagerNode *node = NULL;
    int numkeys = 0;
    listIter li;
    listNode *ln;
    listRewind(nodes, &li);
    if (err) *err = NULL;
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
            continue;
        redisReply *r =
            CLUSTER_MANAGER_COMMAND(n, ""CLUSTER COUNTKEYSINSLOT %d"", slot);
        int success = clusterManagerCheckRedisReply(n, r, err);
        if (success) {
            if (r->integer > numkeys || node == NULL) {
                numkeys = r->integer;
                node = n;
            }
        }
        if (r != NULL) freeReplyObject(r);
        /* If the reply contains errors */
        if (!succ...",5839.0,5872.0,1.0,23.0,34.0,34,12,48,11,3,10,11,17,3,4,,0,8,6,3,3,clusterManagerNode
5426,298876,clusterManagerNodeWithLeastReplicas,1,clusterManagerNodeWithLeastReplicas,clusterManagerNode clusterManagerNodeWithLeastReplicas (void),redis-cli.c,"static clusterManagerNode *clusterManagerNodeWithLeastReplicas(void) {
    clusterManagerNode *node = NULL;
    int lowest_count = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        if (node == NULL || n->replicas_count < lowest_count) {
            node = n;
            lowest_count = n->replicas_count;
        }
    }
    return node;
}",5878.0,5893.0,1.0,23.0,16.0,19,10,20,7,0,8,5,6,3,2,,0,7,2,1,1,clusterManagerNode
5427,298945,clusterManagerNodeMasterRandom,1,clusterManagerNodeMasterRandom,clusterManagerNode clusterManagerNodeMasterRandom (void),redis-cli.c,"static clusterManagerNode *clusterManagerNodeMasterRandom(void) {
    int master_count = 0;
    int idx;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        master_count++;
    }

    assert(master_count > 0);
    srand(time(NULL));
    idx = rand() % master_count;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        if (!idx--) {
            return n;
        }
    }
    /* Can not be reached */
    assert(0);
}",5897.0,5922.0,1.0,23.0,26.0,27,12,24,7,1,12,8,9,4,4,,0,10,2,1,1,clusterManagerNode
5428,299046,clusterManagerFixSlotsCoverage,1,clusterManagerFixSlotsCoverage,int clusterManagerFixSlotsCoverage (char*),redis-cli.c,"static int clusterManagerFixSlotsCoverage(char *all_slots) {
    int force_fix = config.cluster_manager_command.flags &
                    CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS;

    if (cluster_manager.unreachable_masters > 0 && !force_fix) {
        clusterManagerLogWarn(""*** Fixing slots coverage with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\n"", cluster_manager.unreachable_masters);
        exit(1);
    }

    int i, fixed = 0;
    list *none = NULL, *single = NULL, *multi = NULL;
    clusterManagerLogInfo("">>> Fixing slots coverage...\n"");
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        int covered = all_slots[i];
        if (!covered) {
            sds slot = sdsfromlonglong...",5924.0,6121.0,1.0,20.0,198.0,160,18,215,31,0,95,51,114,26,57,,0,72,2,1,1,int
5429,299769,clusterManagerFixOpenSlot,1,clusterManagerFixOpenSlot,int clusterManagerFixOpenSlot (int),redis-cli.c,"static int clusterManagerFixOpenSlot(int slot) {
    int force_fix = config.cluster_manager_command.flags &
                    CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS;

    if (cluster_manager.unreachable_masters > 0 && !force_fix) {
        clusterManagerLogWarn(""*** Fixing open slots with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\n"", cluster_manager.unreachable_masters);
        exit(1);
    }

    clusterManagerLogInfo("">>> Fixing open slot %d\n"", slot);
    /* Try to obtain the current slot owner, according to the current
     * nodes configuration. */
    int success = 1;
    list *owners = listCreate();    /* List of nodes claiming some ownership.
                                       ...",6126.0,6456.0,1.0,20.0,331.0,155,14,207,25,0,96,43,65,18,45,,0,72,2,1,1,int
5430,301077,clusterManagerFixMultipleSlotOwners,1,clusterManagerFixMultipleSlotOwners,"int clusterManagerFixMultipleSlotOwners (int,list*)",redis-cli.c,"static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
    clusterManagerLogInfo("">>> Fixing multiple owners for slot %d...\n"", slot);
    int success = 0;
    assert(listLength(owners) > 1);
    clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
                                                                        slot,
                                                                        NULL);
    if (!owner) owner = listFirst(owners)->value;
    clusterManagerLogInfo("">>> Setting slot %d owner: %s:%d\n"",
                          slot, owner->ip, owner->port);
    /* Set the slot owner. */
    if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    /* Update configuration in all the other master nodes by assigning the slot
     * itself to the new owner, and by eventually migrating keys if the node
     * has keys for the slot. */
    while ((ln = ...",6458.0,6493.0,1.0,4.0,36.0,34,12,49,11,0,18,14,17,4,10,,0,14,4,2,2,int
5431,301931,clusterNodeForResharding,1,clusterNodeForResharding,"clusterManagerNode clusterNodeForResharding (char*,clusterManagerNode*,int*)",redis-cli.c,"static clusterManagerNode *clusterNodeForResharding(char *id,
                                                    clusterManagerNode *target,
                                                    int *raise_err)
{
    clusterManagerNode *node = NULL;
    const char *invalid_node_msg = ""*** The specified node (%s) is not known ""
                                   ""or not a master, please retry.\n"";
    node = clusterManagerNodeByName(id);
    *raise_err = 0;
    if (!node || node->flags & CLUSTER_MANAGER_FLAG_SLAVE) {
        clusterManagerLogErr(invalid_node_msg, id);
        *raise_err = 1;
        return NULL;
    } else if (target != NULL) {
        if (!strcmp(node->name, target->name)) {
            clusterManagerLogErr( ""*** It is not possible to use ""
                                  ""the target node as ""
                                  ""source node.\n"");
            return NULL;
        }
    }
    return node;
}",6659.0,6681.0,1.0,31.0,23.0,12,7,13,5,0,3,2,2,1,2,,0,2,6,3,3,clusterManagerNode
5432,302006,clusterManagerComputeReshardTable,1,clusterManagerComputeReshardTable,"list clusterManagerComputeReshardTable (list*,int)",redis-cli.c,"static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
    list *moved = listCreate();
    int src_count = listLength(sources), i = 0, tot_slots = 0, j;
    clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
    listIter li;
    listNode *ln;
    listRewind(sources, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        tot_slots += node->slots_count;
        sorted[i++] = node;
    }
    qsort(sorted, src_count, sizeof(clusterManagerNode *),
          clusterManagerSlotCountCompareDesc);
    for (i = 0; i < src_count; i++) {
        clusterManagerNode *node = sorted[i];
        float n = ((float) numslots / tot_slots * node->slots_count);
        if (i == 0) n = ceil(n);
        else n = floor(n);
        int max = (int) n, count = 0;
        for (j = 0; j < CLUSTER_MANAGER_SLOTS; j++) {
            int slot = node->slots[j];
            if (!slot) continue;
            if (count >= max || (int)...",6683.0,6716.0,1.0,20.0,34.0,54,17,62,18,0,15,9,13,2,7,,0,12,4,2,2,list
5433,302204,clusterManagerShowReshardTable,1,clusterManagerShowReshardTable,void clusterManagerShowReshardTable (list*),redis-cli.c,"static void clusterManagerShowReshardTable(list *table) {
    listIter li;
    listNode *ln;
    listRewind(table, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerReshardTableItem *item = ln->value;
        clusterManagerNode *n = item->source;
        printf(""    Moving slot %d from %s\n"", item->slot, (char *) n->name);
    }
}",6718.0,6727.0,1.0,1.0,10.0,11,5,11,6,0,6,2,2,1,2,,0,5,2,1,1,void
5434,302246,clusterManagerReleaseReshardTable,1,clusterManagerReleaseReshardTable,void clusterManagerReleaseReshardTable (list*),redis-cli.c,"static void clusterManagerReleaseReshardTable(list *table) {
    if (table != NULL) {
        listIter li;
        listNode *ln;
        listRewind(table, &li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerReshardTableItem *item = ln->value;
            zfree(item);
        }
        listRelease(table);
    }
}",6729.0,6740.0,1.0,1.0,12.0,7,4,11,5,0,5,3,4,1,4,,0,2,2,1,1,void
5435,302534,clusterManagerPrintNotEmptyNodeError,1,clusterManagerPrintNotEmptyNodeError,"void clusterManagerPrintNotEmptyNodeError (clusterManagerNode*,char*)",redis-cli.c,"static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
                                                 char *err)
{
    char *msg;
    if (err) msg = err;
    else {
        msg = ""is not empty. Either the node already knows other ""
              ""nodes (check with CLUSTER NODES) or contains some ""
              ""key in database 0."";
    }
    clusterManagerLogErr(""[ERR] Node %s:%d %s\n"", node->ip, node->port, msg);
}",6808.0,6819.0,1.0,4.0,12.0,3,2,6,3,0,3,2,2,0,1,,0,2,4,2,2,void
5436,302589,clusterManagerMode,1,clusterManagerMode,void clusterManagerMode (clusterManagerCommandProc*),redis-cli.c,"static void clusterManagerMode(clusterManagerCommandProc *proc) {
    int argc = config.cluster_manager_command.argc;
    char **argv = config.cluster_manager_command.argv;
    cluster_manager.nodes = NULL;
    int success = proc(argc, argv);

    /* Initialized in createClusterManagerCommand. */
    if (config.stdin_lastarg) {
        zfree(config.cluster_manager_command.argv);
        sdsfree(config.cluster_manager_command.stdin_arg);
    } else if (config.stdin_tag_arg) {
        sdsfree(config.cluster_manager_command.stdin_arg);
    }
    freeClusterManager();

    exit(success ? 0 : 1);
}",6829.0,6845.0,1.0,1.0,17.0,15,3,13,6,0,15,2,2,2,3,,0,12,2,1,1,void
5437,308177,latencyModePrint,1,latencyModePrint,"void latencyModePrint (long long,long long,double,long long)",redis-cli.c,"static void latencyModePrint(long long min, long long max, double avg, long long count) {
    if (config.output == OUTPUT_STANDARD) {
        printf(""min: %lld, max: %lld, avg: %.2f (%lld samples)"",
                min, max, avg, count);
        fflush(stdout);
    } else if (config.output == OUTPUT_CSV) {
        printf(""%lld,%lld,%.2f,%lld\n"", min, max, avg, count);
    } else if (config.output == OUTPUT_RAW) {
        printf(""%lld %lld %.2f %lld\n"", min, max, avg, count);
    } else if (config.output == OUTPUT_JSON) {
        printf(""{\""min\"": %lld, \""max\"": %lld, \""avg\"": %.2f, \""count\"": %lld}\n"", min, max, avg, count);
    }
}",8157.0,8169.0,1.0,25.0,13.0,2,2,6,6,1,2,2,2,2,0,,0,2,8,4,4,void
5438,308253,latencyMode,1,latencyMode,void latencyMode (void),redis-cli.c,"static void latencyMode(void) {
    redisReply *reply;
    long long start, latency, min = 0, max = 0, tot = 0, count = 0;
    long long history_interval =
        config.interval ? config.interval/1000 :
                          LATENCY_HISTORY_DEFAULT_INTERVAL;
    double avg;
    long long history_start = mstime();

    /* Set a default for the interval in case of --latency option
     * with --raw, --csv or when it is redirected to non tty. */
    if (config.interval == 0) {
        config.interval = 1000;
    } else {
        config.interval /= 1000; /* We need to convert to milliseconds. */
    }

    if (!context) exit(1);
    while(1) {
        start = mstime();
        reply = reconnectingRedisCommand(context,""PING"");
        if (reply == NULL) {
            fprintf(stderr,""\nI/O error\n"");
            exit(1);
        }
        latency = mstime()-start;
        freeReplyObject(reply);
        count++;
        if (count == 1) {
            min = max = tot = latency;
      ...",8173.0,8231.0,1.0,26.0,59.0,42,12,42,14,0,20,8,12,7,8,,0,18,2,1,1,void
5439,308485,showLatencyDistSamples,1,showLatencyDistSamples,"void showLatencyDistSamples (distsamples*,long long)",redis-cli.c,"void showLatencyDistSamples(struct distsamples *samples, long long tot) {
    int j;

     /* We convert samples into an index inside the palette
     * proportional to the percentage a given bucket represents.
     * This way intensity of the different parts of the spectrum
     * don't change relative to the number of requests, which avoids to
     * pollute the visualization with non-latency related info. */
    printf(""\033[38;5;0m""); /* Set foreground color to black. */
    for (j = 0; ; j++) {
        int coloridx =
            ceil((double) samples[j].count / tot * (spectrum_palette_size-1));
        int color = spectrum_palette[coloridx];
        printf(""\033[48;5;%dm%c"", (int)color, samples[j].character);
        samples[j].count = 0;
        if (samples[j].max == 0) break; /* Last sample. */
    }
    printf(""\033[0m\n"");
    fflush(stdout);
}",8257.0,8276.0,1.0,1.0,20.0,20,9,18,8,1,2,4,4,0,0,,0,2,4,2,2,void
5440,308556,showLatencyDistLegend,1,showLatencyDistLegend,void showLatencyDistLegend (void),redis-cli.c,"void showLatencyDistLegend(void) {
    int j;

    printf(""---------------------------------------------\n"");
    printf("". - * #          .01 .125 .25 .5 milliseconds\n"");
    printf(""1,2,3,...,9      from 1 to 9     milliseconds\n"");
    printf(""A,B,C,D,E        10,20,30,40,50  milliseconds\n"");
    printf(""F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n"");
    printf(""K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\n"");
    printf(""From 0 to 100%%: "");
    for (j = 0; j < spectrum_palette_size; j++) {
        printf(""\033[48;5;%dm "", spectrum_palette[j]);
    }
    printf(""\033[0m\n"");
    printf(""---------------------------------------------\n"");
}",8280.0,8295.0,1.0,1.0,16.0,3,3,5,3,1,2,2,2,1,0,,0,2,2,1,1,void
5441,308596,latencyDistMode,1,latencyDistMode,void latencyDistMode (void),redis-cli.c,"static void latencyDistMode(void) {
    redisReply *reply;
    long long start, latency, count = 0;
    long long history_interval =
        config.interval ? config.interval/1000 :
                          LATENCY_DIST_DEFAULT_INTERVAL;
    long long history_start = ustime();
    int j, outputs = 0;

    struct distsamples samples[] = {
        /* We use a mostly logarithmic scale, with certain linear intervals
         * which are more interesting than others, like 1-10 milliseconds
         * range. */
        {10,0,'.'},         /* 0.01 ms */
        {125,0,'-'},        /* 0.125 ms */
        {250,0,'*'},        /* 0.25 ms */
        {500,0,'#'},        /* 0.5 ms */
        {1000,0,'1'},       /* 1 ms */
        {2000,0,'2'},       /* 2 ms */
        {3000,0,'3'},       /* 3 ms */
        {4000,0,'4'},       /* 4 ms */
        {5000,0,'5'},       /* 5 ms */
        {6000,0,'6'},       /* 6 ms */
        {7000,0,'7'},       /* 7 ms */
        {8000,0,'8'},       /* 8 ms */
     ...",8297.0,8373.0,1.0,26.0,77.0,70,16,35,13,0,12,9,15,1,8,,0,10,2,1,1,void
5442,308863,sendReplconf,1,sendReplconf,"int sendReplconf (char*,char*)",redis-cli.c,"int sendReplconf(const char* arg1, const char* arg2) {
    int res = 1;
    fprintf(stderr, ""sending REPLCONF %s %s\n"", arg1, arg2);
    redisReply *reply = redisCommand(context, ""REPLCONF %s %s"", arg1, arg2);

    /* Handle any error conditions */
    if(reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if(reply->type == REDIS_REPLY_ERROR) {
        /* non fatal, old versions may not support it */
        fprintf(stderr, ""REPLCONF %s error: %s\n"", arg1, reply->str);
        res = 0;
    }
    freeReplyObject(reply);
    return res;
}",8381.0,8397.0,1.0,1.0,17.0,3,2,13,7,2,0,2,2,0,0,,0,0,4,2,2,int
5443,308919,sendCapa,1,sendCapa,void sendCapa (void),redis-cli.c,"void sendCapa(void) {
    sendReplconf(""capa"", ""eof"");
}",8399.0,8401.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,void
5444,308927,sendRdbOnly,1,sendRdbOnly,void sendRdbOnly (void),redis-cli.c,"void sendRdbOnly(void) {
    sendReplconf(""rdb-only"", ""1"");
}",8403.0,8405.0,1.0,1.0,3.0,0,0,0,0,0,1,1,1,0,1,,0,0,2,1,1,void
5445,308935,readConn,1,readConn,"ssize_t readConn (redisContext*,char*,size_t)",redis-cli.c,"static ssize_t readConn(redisContext *c, char *buf, size_t len)
{
    return c->funcs->read(c, buf, len);
}",8410.0,8413.0,1.0,1.0,4.0,2,1,4,3,2,0,1,1,0,0,,0,0,6,3,3,ssize_t
5446,308952,sendSync,1,sendSync,"unsigned long long sendSync (redisContext*,int,char*,int*)",redis-cli.c,"unsigned long long sendSync(redisContext *c, int send_sync, char *out_eof, int *out_full_mode) {
    /* To start we need to send the SYNC command and return the payload.
     * The hiredis client lib does not understand this part of the protocol
     * and we don't want to mess with its buffers, so everything is performed
     * using direct low-level I/O. */
    char buf[4096], *p;
    ssize_t nread;

    if (out_full_mode) *out_full_mode = 1;

    if (send_sync) {
        /* Send the SYNC command. */
        if (cliWriteConn(c, ""SYNC\r\n"", 6) != 6) {
            fprintf(stderr,""Error writing to master\n"");
            exit(1);
        }
    } else {
        /* We have written the command into c->obuf before. */
        if (cliWriteConn(c, """", 0) != 0) {
            fprintf(stderr,""Error writing to master\n"");
            exit(1);
        }
    }

    /* Read $<payload>\r\n, making sure to read just up to ""\n"" */
    p = buf;
    while(1) {
        nread = readConn(c,p,1);
        ...",8425.0,8499.0,1.0,57.0,75.0,51,14,55,10,0,3,23,36,1,3,,0,3,8,4,4,unsigned long long
5447,309719,pipeMode,1,pipeMode,void pipeMode (void),redis-cli.c,"static void pipeMode(void) {
    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
    char obuf[1024*16]; /* Output buffer */
    char aneterr[ANET_ERR_LEN];
    redisReply *reply;
    int eof = 0; /* True once we consumed all the standard input. */
    int done = 0;
    char magic[20]; /* Special reply we recognize. */
    time_t last_read_time = time(NULL);

    srand(time(NULL));

    /* Use non blocking I/O. */
    if (anetNonBlock(aneterr,context->fd) == ANET_ERR) {
        fprintf(stderr, ""Can't set the socket in non blocking mode: %s\n"",
            aneterr);
        exit(1);
    }

    context->flags &= ~REDIS_BLOCK;

    /* Transfer raw protocol and read replies from the server at the same
     * time. */
    while(!done) {
        int mask = AE_READABLE;

        if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
        mask = aeWait(context->fd,mask,1000);

        /* Handle the readable state: we can read replies from the server. */
        if (mask & AE_READ...",8672.0,8824.0,1.0,17.0,153.0,82,22,105,29,0,9,27,81,5,3,,0,9,2,1,1,void
5448,310156,sendScan,1,sendScan,redisReply sendScan (long long unsigned*),redis-cli.c,"static redisReply *sendScan(unsigned long long *it) {
    redisReply *reply;

    if (config.pattern)
        reply = redisCommand(context, ""SCAN %llu MATCH %b COUNT %d"",
            *it, config.pattern, sdslen(config.pattern), config.count);
    else
        reply = redisCommand(context,""SCAN %llu"",*it);

    /* Handle any error conditions */
    if(reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if(reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr, ""SCAN error: %s\n"", reply->str);
        exit(1);
    } else if(reply->type != REDIS_REPLY_ARRAY) {
        fprintf(stderr, ""Non ARRAY response from SCAN!\n"");
        exit(1);
    } else if(reply->elements != 2) {
        fprintf(stderr, ""Invalid element count from SCAN!\n"");
        exit(1);
    }

    /* Validate our types are correct */
    assert(reply->element[0]->type == REDIS_REPLY_STRING);
    assert(reply->element[1]->type == REDIS_REPLY_ARRAY);

    /* Update iterator */
    *it...",8830.0,8862.0,1.0,1.0,33.0,20,6,18,8,3,9,3,3,2,1,,0,9,2,1,1,redisReply
5449,310283,getDbSize,1,getDbSize,int getDbSize (void),redis-cli.c,"static int getDbSize(void) {
    redisReply *reply;
    int size;

    reply = redisCommand(context, ""DBSIZE"");

    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if (reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr, ""Couldn't determine DBSIZE: %s\n"", reply->str);
        exit(1);
    } else if (reply->type != REDIS_REPLY_INTEGER) {
        fprintf(stderr, ""Non INTEGER response from DBSIZE!\n"");
        exit(1);
    }

    /* Grab the number of keys and free our reply */
    size = reply->integer;
    freeReplyObject(reply);

    return size;
}",8864.0,8886.0,1.0,1.0,23.0,4,3,9,5,2,0,2,2,0,0,,0,0,2,1,1,int
5450,310403,typeinfo_add,1,typeinfo_add,"typeinfo typeinfo_add (dict*,char*,typeinfo*)",redis-cli.c,"static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
    typeinfo *info = zmalloc(sizeof(typeinfo));
    *info = *type_template;
    info->name = sdsnew(name);
    dictAdd(types, info->name, info);
    return info;
}",8906.0,8912.0,1.0,1.0,7.0,8,4,10,5,6,6,1,1,0,3,,0,5,6,3,3,typeinfo
5451,310435,type_free,1,type_free,"void type_free (dict*,void*)",redis-cli.c,"void type_free(dict *d, void* val) {
    typeinfo *info = val;
    UNUSED(d);
    if (info->biggest_key)
        sdsfree(info->biggest_key);
    sdsfree(info->name);
    zfree(info);
}",8914.0,8921.0,1.0,4.0,8.0,5,3,8,3,0,6,2,2,1,3,,0,3,4,2,2,void
5452,310477,getKeyTypes,1,getKeyTypes,"void getKeyTypes (dict*,redisReply*,typeinfo**)",redis-cli.c,"static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
    redisReply *reply;
    unsigned int i;

    /* Pipeline TYPE commands */
    for(i=0;i<keys->elements;i++) {
        const char* argv[] = {""TYPE"", keys->element[i]->str};
        size_t lens[] = {4, keys->element[i]->len};
        redisAppendCommandArgv(context, 2, argv, lens);
    }

    /* Retrieve types */
    for(i=0;i<keys->elements;i++) {
        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
            fprintf(stderr, ""Error getting type for key '%s' (%d: %s)\n"",
                keys->element[i]->str, context->err, context->errstr);
            exit(1);
        } else if(reply->type != REDIS_REPLY_STATUS) {
            if(reply->type == REDIS_REPLY_ERROR) {
                fprintf(stderr, ""TYPE returned an error: %s\n"", reply->str);
            } else {
                fprintf(stderr,
                    ""Invalid reply type (%d) for TYPE on key '%s'!\n"",
                    reply->typ...",8933.0,8972.0,1.0,1.0,40.0,31,8,38,14,1,4,5,7,0,4,,0,3,6,3,3,void
5453,310659,getKeySizes,1,getKeySizes,"void getKeySizes (redisReply*,typeinfo**,long long unsigned*,int,unsigned)",redis-cli.c,"static void getKeySizes(redisReply *keys, typeinfo **types,
                        unsigned long long *sizes, int memkeys,
                        unsigned memkeys_samples)
{
    redisReply *reply;
    unsigned int i;

    /* Pipeline size commands */
    for(i=0;i<keys->elements;i++) {
        /* Skip keys that disappeared between SCAN and TYPE (or unknown types when not in memkeys mode) */
        if(!types[i] || (!types[i]->sizecmd && !memkeys))
            continue;

        if (!memkeys) {
            const char* argv[] = {types[i]->sizecmd, keys->element[i]->str};
            size_t lens[] = {strlen(types[i]->sizecmd), keys->element[i]->len};
            redisAppendCommandArgv(context, 2, argv, lens);
        } else if (memkeys_samples==0) {
            const char* argv[] = {""MEMORY"", ""USAGE"", keys->element[i]->str};
            size_t lens[] = {6, 5, keys->element[i]->len};
            redisAppendCommandArgv(context, 3, argv, lens);
        } else {
            sds samplesst...",8974.0,9031.0,1.0,1.0,58.0,47,11,41,11,1,0,9,11,0,0,,0,0,10,5,5,void
5454,310932,longStatLoopModeStop,1,longStatLoopModeStop,void longStatLoopModeStop (int),redis-cli.c,"static void longStatLoopModeStop(int s) {
    UNUSED(s);
    force_cancel_loop = 1;
}",9033.0,9036.0,1.0,4.0,4.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
5455,310946,findBigKeys,1,findBigKeys,"void findBigKeys (int,unsigned)",redis-cli.c,"static void findBigKeys(int memkeys, unsigned memkeys_samples) {
    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0, scan_loops = 0;
    redisReply *reply, *keys;
    unsigned int arrsize=0, i;
    dictIterator *di;
    dictEntry *de;
    typeinfo **types = NULL;
    double pct;

    dict *types_dict = dictCreate(&typeinfoDictType);
    typeinfo_add(types_dict, ""string"", &type_string);
    typeinfo_add(types_dict, ""list"", &type_list);
    typeinfo_add(types_dict, ""set"", &type_set);
    typeinfo_add(types_dict, ""hash"", &type_hash);
    typeinfo_add(types_dict, ""zset"", &type_zset);
    typeinfo_add(types_dict, ""stream"", &type_stream);

    signal(SIGINT, longStatLoopModeStop);
    /* Total keys pre scanning */
    total_keys = getDbSize();

    /* Status message */
    printf(""\n# Scanning the entire keyspace to find biggest keys as well as\n"");
    printf(""# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"");
    printf(""# per 100 SCAN comma...",9038.0,9173.0,1.0,1.0,136.0,124,20,145,32,0,65,18,35,10,27,,0,51,4,2,2,void
5456,311409,getKeyFreqs,1,getKeyFreqs,"void getKeyFreqs (redisReply*,long long unsigned*)",redis-cli.c,"static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
    redisReply *reply;
    unsigned int i;

    /* Pipeline OBJECT freq commands */
    for(i=0;i<keys->elements;i++) {
        const char* argv[] = {""OBJECT"", ""FREQ"", keys->element[i]->str};
        size_t lens[] = {6, 4, keys->element[i]->len};
        redisAppendCommandArgv(context, 3, argv, lens);
    }

    /* Retrieve freqs */
    for(i=0;i<keys->elements;i++) {
        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
            sds keyname = sdscatrepr(sdsempty(), keys->element[i]->str, keys->element[i]->len);
            fprintf(stderr, ""Error getting freq for key '%s' (%d: %s)\n"",
                keyname, context->err, context->errstr);
            sdsfree(keyname);
            exit(1);
        } else if(reply->type != REDIS_REPLY_INTEGER) {
            if(reply->type == REDIS_REPLY_ERROR) {
                fprintf(stderr, ""Error: %s\n"", reply->str);
                exit(1);
            } else {
 ...",9175.0,9209.0,1.0,1.0,35.0,28,8,29,9,1,3,4,5,0,3,,0,2,4,2,2,void
5457,311584,findHotKeys,1,findHotKeys,void findHotKeys (void),redis-cli.c,"static void findHotKeys(void) {
    redisReply *keys, *reply;
    unsigned long long counters[HOTKEYS_SAMPLE] = {0};
    sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
    unsigned long long sampled = 0, total_keys, *freqs = NULL, it = 0, scan_loops = 0;
    unsigned int arrsize = 0, i, k;
    double pct;

    signal(SIGINT, longStatLoopModeStop);
    /* Total keys pre scanning */
    total_keys = getDbSize();

    /* Status message */
    printf(""\n# Scanning the entire keyspace to find hot keys as well as\n"");
    printf(""# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"");
    printf(""# per 100 SCAN commands (not usually needed).\n\n"");

    /* SCAN loop */
    do {
        /* Calculate approximate percentage completion */
        pct = 100 * (double)sampled/total_keys;

        /* Grab some keys and point to the keys array */
        reply = sendScan(&it);
        scan_loops++;
        keys  = reply->element[1];

        /* Reallocate our freqs array if we need to */
 ...",9212.0,9304.0,1.0,32.0,93.0,78,22,89,19,0,15,15,28,4,9,,0,11,2,1,1,void
5458,312011,bytesToHuman,1,bytesToHuman,"void bytesToHuman (char*,size_t,long long)",server.c,"void bytesToHuman(char *s, size_t size, unsigned long long n) {
    double d;

    if (n < 1024) {
        /* Bytes */
        snprintf(s,size,""%lluB"",n);
    } else if (n < (1024*1024)) {
        d = (double)n/(1024);
        snprintf(s,size,""%.2fK"",d);
    } else if (n < (1024LL*1024*1024)) {
        d = (double)n/(1024*1024);
        snprintf(s,size,""%.2fM"",d);
    } else if (n < (1024LL*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024);
        snprintf(s,size,""%.2fG"",d);
    } else if (n < (1024LL*1024*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024*1024);
        snprintf(s,size,""%.2fT"",d);
    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024*1024*1024);
        snprintf(s,size,""%.2fP"",d);
    } else {
        /* Let's hope we never need this */
        snprintf(s,size,""%lluB"",n);
    }
}",5255.0,5280.0,1.0,1.0,26.0,7,5,9,3,9,0,3,3,0,0,,0,0,6,3,3,void
5459,312120,statMode,1,statMode,void statMode (void),redis-cli.c,"static void statMode(void) {
    redisReply *reply;
    long aux, requests = 0;
    int i = 0;

    while(1) {
        char buf[64];
        int j;

        reply = reconnectingRedisCommand(context,""INFO"");
        if (reply == NULL) {
            fprintf(stderr, ""\nI/O error\n"");
            exit(1);
        } else if (reply->type == REDIS_REPLY_ERROR) {
            fprintf(stderr, ""ERROR: %s\n"", reply->str);
            exit(1);
        }

        if ((i++ % 20) == 0) {
            printf(
""------- data ------ --------------------- load -------------------- - child -\n""
""keys       mem      clients blocked requests            connections          \n"");
        }

        /* Keys */
        aux = 0;
        for (j = 0; j < 20; j++) {
            long k;

            snprintf(buf,sizeof(buf),""db%d:keys"",j);
            k = getLongInfoField(reply->str,buf);
            if (k == LONG_MIN) continue;
            aux += k;
        }
        snprintf(buf,sizeof(buf),""%ld"",aux);
        pr...",9367.0,9454.0,1.0,1.0,88.0,42,12,69,12,0,13,13,13,0,11,,0,10,2,1,1,void
5460,312377,scanMode,1,scanMode,void scanMode (void),redis-cli.c,"static void scanMode(void) {
    redisReply *reply;
    unsigned long long cur = 0;
    signal(SIGINT, longStatLoopModeStop);
    do {
        reply = sendScan(&cur);
        for (unsigned int j = 0; j < reply->element[1]->elements; j++) {
            if (config.output == OUTPUT_STANDARD) {
                sds out = sdscatrepr(sdsempty(), reply->element[1]->element[j]->str,
                                     reply->element[1]->element[j]->len);
                printf(""%s\n"", out);
                sdsfree(out);
            } else {
                printf(""%s\n"", reply->element[1]->element[j]->str);
            }
        }
        freeReplyObject(reply);
        if (config.interval) usleep(config.interval);
    } while(force_cancel_loop == 0 && cur != 0);

    exit(0);
}",9460.0,9481.0,1.0,33.0,22.0,26,9,20,7,0,11,5,9,5,4,,0,10,2,1,1,void
5461,312491,powerLawRand,1,powerLawRand,"long long powerLawRand (long long,long long,double)",redis-cli.c,"long long powerLawRand(long long min, long long max, double alpha) {
    double pl, r;

    max += 1;
    r = ((double)rand()) / RAND_MAX;
    pl = pow(
        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),
        (1.0/(alpha+1)));
    return (max-1-(long long)pl)+min;
}",9493.0,9502.0,1.0,1.0,10.0,17,7,15,6,1,0,1,1,0,0,,0,0,6,3,3,long long
5462,312547,LRUTestGenKey,1,LRUTestGenKey,"void LRUTestGenKey (char*,size_t)",redis-cli.c,"void LRUTestGenKey(char *buf, size_t buflen) {
    snprintf(buf, buflen, ""lru:%lld"",
        powerLawRand(1, config.lru_test_sample_size, 6.2));
}",9506.0,9509.0,1.0,1.0,4.0,1,1,3,3,2,3,1,1,0,1,,0,2,4,2,2,void
5463,312563,LRUTestMode,1,LRUTestMode,void LRUTestMode (void),redis-cli.c,"static void LRUTestMode(void) {
    redisReply *reply;
    char key[128];
    long long start_cycle;
    int j;

    srand(time(NULL)^getpid());
    while(1) {
        /* Perform cycles of 1 second with 50% writes and 50% reads.
         * We use pipelining batching writes / reads N times per cycle in order
         * to fill the target instance easily. */
        start_cycle = mstime();
        long long hits = 0, misses = 0;
        while(mstime() - start_cycle < LRU_CYCLE_PERIOD) {
            /* Write cycle. */
            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
                char val[6];
                val[5] = '\0';
                for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');
                LRUTestGenKey(key,sizeof(key));
                redisAppendCommand(context, ""SET %s %s"",key,val);
            }
            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)
                redisGetReply(context, (void**)&reply);

            /* Read cycle. */
        ...",9513.0,9572.0,1.0,39.0,60.0,37,14,47,14,0,4,14,32,1,4,,0,2,2,1,1,void
5464,312772,compute_something_fast,1,compute_something_fast,unsigned long compute_something_fast (void),redis-cli.c,"unsigned long compute_something_fast(void) {
    unsigned char s[256], i, j, t;
    int count = 1000, k;
    unsigned long output = 0;

    for (k = 0; k < 256; k++) s[k] = k;

    i = 0;
    j = 0;
    while(count--) {
        i++;
        j = j + s[i];
        t = s[i];
        s[i] = s[j];
        s[j] = t;
        output += s[(s[i]+s[j])&255];
    }
    return output;
}",9585.0,9603.0,1.0,1.0,19.0,24,8,29,7,1,0,3,3,0,0,,0,0,2,1,1,unsigned long
5465,312856,sigIntHandler,1,sigIntHandler,void sigIntHandler (int),redis-cli.c,"static void sigIntHandler(int s) {
    UNUSED(s);

    if (config.monitor_mode || config.pubsub_mode) {
        close(context->fd);
        context->fd = REDIS_INVALID_FD;
        config.blocking_state_aborted = 1;
    } else {
        exit(1);
    }
}",9605.0,9615.0,1.0,4.0,11.0,9,5,8,4,0,6,2,2,4,0,,0,6,2,1,1,void
5466,312894,intrinsicLatencyMode,1,intrinsicLatencyMode,void intrinsicLatencyMode (void),redis-cli.c,"static void intrinsicLatencyMode(void) {
    long long test_end, run_time, max_latency = 0, runs = 0;

    run_time = (long long)config.intrinsic_latency_duration * 1000000;
    test_end = ustime() + run_time;
    signal(SIGINT, longStatLoopModeStop);

    while(1) {
        long long start, end, latency;

        start = ustime();
        compute_something_fast();
        end = ustime();
        latency = end-start;
        runs++;
        if (latency <= 0) continue;

        /* Reporting */
        if (latency > max_latency) {
            max_latency = latency;
            printf(""Max latency so far: %lld microseconds.\n"", max_latency);
        }

        double avg_us = (double)run_time/runs;
        double avg_ns = avg_us * 1e3;
        if (force_cancel_loop || end > test_end) {
            printf(""\n%lld total runs ""
                ""(avg latency: ""
                ""%.4f microseconds / %.2f nanoseconds per run).\n"",
                runs, avg_us, avg_ns);
            printf(""Wor...",9617.0,9652.0,1.0,1.0,36.0,24,11,32,12,0,7,6,8,1,4,,0,6,2,1,1,void
5467,312996,askPassword,1,askPassword,sds askPassword (char*),redis-cli.c,"static sds askPassword(const char *msg) {
    linenoiseMaskModeEnable();
    sds auth = linenoise(msg);
    linenoiseMaskModeDisable();
    return auth;
}",9654.0,9659.0,1.0,1.0,6.0,1,1,3,2,0,0,1,1,0,0,,0,0,2,1,1,sds
5468,313010,testHint,1,testHint,void testHint (char*),redis-cli.c,"void testHint(const char *input) {
    cliInitHelp();

    sds hint = getHintForInput(input);
    printf(""%s\n"", hint);
    exit(0);
}",9662.0,9668.0,1.0,1.0,7.0,1,1,3,2,0,2,1,1,0,2,,0,1,2,1,1,void
5469,313026,readHintSuiteLine,1,readHintSuiteLine,"sds readHintSuiteLine (char[],size_t,FILE*)",redis-cli.c,"sds readHintSuiteLine(char buf[], size_t size, FILE *fp) {
    while (fgets(buf, size, fp) != NULL) {
        if (buf[0] != '#') {
            sds input = sdsnew(buf);

            /* Strip newline. */
            input = sdstrim(input, ""\n"");
            return input;
        }
    }
    return NULL;
}",9670.0,9681.0,1.0,1.0,12.0,5,3,11,5,1,2,3,4,0,2,,0,2,6,3,3,sds
5470,313062,testHintSuite,1,testHintSuite,void testHintSuite (char*),redis-cli.c,"void testHintSuite(char *filename) {
    FILE *fp;
    char buf[256];
    sds line, input, expected, hint;
    int pass=0, fail=0;
    int argc;
    char **argv;

    fp = fopen(filename, ""r"");
    if (!fp) {
        fprintf(stderr,
            ""Can't open file '%s': %s\n"", filename, strerror(errno));
        exit(-1);
    }

    cliInitHelp();

    while (1) {
        line = readHintSuiteLine(buf, sizeof(buf), fp);
        if (line == NULL) break;
        argv = sdssplitargs(line, &argc);
        sdsfree(line);
        if (argc == 0) {
            sdsfreesplitres(argv, argc);
            continue;
        }

        if (argc == 1) {
            fprintf(stderr,
                ""Missing expected hint for input '%s'\n"", argv[0]);
            exit(-1);
        }
        input = argv[0];
        expected = argv[1];
        hint = getHintForInput(input);
        if (config.verbose) {
            printf(""Input: '%s', Expected: '%s', Hint: '%s'\n"", input, expected, hint);
        }

      ...",9684.0,9743.0,1.0,1.0,60.0,37,16,61,15,0,15,11,15,4,13,,0,8,2,1,1,void
5471,314289,RedisModuleEventLoopFunc,1,RedisModuleEventLoopFunc,"void RedisModuleEventLoopFunc (int,void*,int)",redismodule.h,"typedef void (*RedisModuleEventLoopFunc)(int fd, void *user_data, int mask);",476.0,476.0,14.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5472,314296,RedisModuleEventLoopOneShotFunc,1,RedisModuleEventLoopOneShotFunc,void RedisModuleEventLoopOneShotFunc (void*),redismodule.h,typedef void (*RedisModuleEventLoopOneShotFunc)(void *user_data);,477.0,477.0,14.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5473,314307,RedisModuleEventCallback,1,RedisModuleEventCallback,"void RedisModuleEventCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)",redismodule.h,"typedef void (*RedisModuleEventCallback)(struct RedisModuleCtx *ctx, RedisModuleEvent eid, uint64_t subevent, void *data);",510.0,510.0,14.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
5474,314537,RedisModuleInfoFunc,1,RedisModuleInfoFunc,"void RedisModuleInfoFunc (RedisModuleInfoCtx*,int)",redismodule.h,"typedef void (*RedisModuleInfoFunc)(RedisModuleInfoCtx *ctx, int for_crash_report);",834.0,834.0,14.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5475,314543,RedisModuleDefragFunc,1,RedisModuleDefragFunc,void RedisModuleDefragFunc (RedisModuleDefragCtx*),redismodule.h,typedef void (*RedisModuleDefragFunc)(RedisModuleDefragCtx *ctx);,835.0,835.0,14.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5476,314548,RedisModuleUserChangedFunc,1,RedisModuleUserChangedFunc,"void RedisModuleUserChangedFunc (uint64_t,void*)",redismodule.h,"typedef void (*RedisModuleUserChangedFunc) (uint64_t client_id, void *privdata);",836.0,836.0,14.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5477,314611,RedisModuleTypeLoadFunc,1,RedisModuleTypeLoadFunc,"void* RedisModuleTypeLoadFunc (RedisModuleIO*,int)",redismodule.h,"typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);",890.0,890.0,14.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5478,314617,RedisModuleTypeSaveFunc,1,RedisModuleTypeSaveFunc,"void RedisModuleTypeSaveFunc (RedisModuleIO*,void*)",redismodule.h,"typedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);",891.0,891.0,14.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5479,314623,RedisModuleTypeAuxLoadFunc,1,RedisModuleTypeAuxLoadFunc,"int RedisModuleTypeAuxLoadFunc (RedisModuleIO*,int,int)",redismodule.h,"typedef int (*RedisModuleTypeAuxLoadFunc)(RedisModuleIO *rdb, int encver, int when);",892.0,892.0,13.0,83.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5480,314630,RedisModuleTypeAuxSaveFunc,1,RedisModuleTypeAuxSaveFunc,"void RedisModuleTypeAuxSaveFunc (RedisModuleIO*,int)",redismodule.h,"typedef void (*RedisModuleTypeAuxSaveFunc)(RedisModuleIO *rdb, int when);",893.0,893.0,14.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5481,314636,RedisModuleTypeRewriteFunc,1,RedisModuleTypeRewriteFunc,"void RedisModuleTypeRewriteFunc (RedisModuleIO*,RedisModuleString*,void*)",redismodule.h,"typedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);",894.0,894.0,14.0,99.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5482,314643,RedisModuleTypeMemUsageFunc,1,RedisModuleTypeMemUsageFunc,size_t RedisModuleTypeMemUsageFunc (void*),redismodule.h,typedef size_t (*RedisModuleTypeMemUsageFunc)(const void *value);,895.0,895.0,16.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
5483,314648,RedisModuleTypeMemUsageFunc2,1,RedisModuleTypeMemUsageFunc2,"size_t RedisModuleTypeMemUsageFunc2 (RedisModuleKeyOptCtx*,void*,size_t)",redismodule.h,"typedef size_t (*RedisModuleTypeMemUsageFunc2)(RedisModuleKeyOptCtx *ctx, const void *value, size_t sample_size);",896.0,896.0,16.0,112.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,size_t
5484,314655,RedisModuleTypeDigestFunc,1,RedisModuleTypeDigestFunc,"void RedisModuleTypeDigestFunc (RedisModuleDigest*,void*)",redismodule.h,"typedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);",897.0,897.0,14.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5485,314661,RedisModuleTypeFreeFunc,1,RedisModuleTypeFreeFunc,void RedisModuleTypeFreeFunc (void*),redismodule.h,typedef void (*RedisModuleTypeFreeFunc)(void *value);,898.0,898.0,14.0,52.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5486,314666,RedisModuleTypeFreeEffortFunc,1,RedisModuleTypeFreeEffortFunc,"size_t RedisModuleTypeFreeEffortFunc (RedisModuleString*,void*)",redismodule.h,"typedef size_t (*RedisModuleTypeFreeEffortFunc)(RedisModuleString *key, const void *value);",899.0,899.0,16.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,size_t
5487,314672,RedisModuleTypeFreeEffortFunc2,1,RedisModuleTypeFreeEffortFunc2,"size_t RedisModuleTypeFreeEffortFunc2 (RedisModuleKeyOptCtx*,void*)",redismodule.h,"typedef size_t (*RedisModuleTypeFreeEffortFunc2)(RedisModuleKeyOptCtx *ctx, const void *value);",900.0,900.0,16.0,94.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,size_t
5488,314678,RedisModuleTypeUnlinkFunc,1,RedisModuleTypeUnlinkFunc,"void RedisModuleTypeUnlinkFunc (RedisModuleString*,void*)",redismodule.h,"typedef void (*RedisModuleTypeUnlinkFunc)(RedisModuleString *key, const void *value);",901.0,901.0,14.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5489,314684,RedisModuleTypeUnlinkFunc2,1,RedisModuleTypeUnlinkFunc2,"void RedisModuleTypeUnlinkFunc2 (RedisModuleKeyOptCtx*,void*)",redismodule.h,"typedef void (*RedisModuleTypeUnlinkFunc2)(RedisModuleKeyOptCtx *ctx, const void *value);",902.0,902.0,14.0,88.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5490,314690,RedisModuleTypeCopyFunc,1,RedisModuleTypeCopyFunc,"void* RedisModuleTypeCopyFunc (RedisModuleString*,RedisModuleString*,void*)",redismodule.h,"typedef void *(*RedisModuleTypeCopyFunc)(RedisModuleString *fromkey, RedisModuleString *tokey, const void *value);",903.0,903.0,14.0,113.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void*
5491,314697,RedisModuleTypeCopyFunc2,1,RedisModuleTypeCopyFunc2,"void* RedisModuleTypeCopyFunc2 (RedisModuleKeyOptCtx*,void*)",redismodule.h,"typedef void *(*RedisModuleTypeCopyFunc2)(RedisModuleKeyOptCtx *ctx, const void *value);",904.0,904.0,14.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5492,314703,RedisModuleTypeDefragFunc,1,RedisModuleTypeDefragFunc,"int RedisModuleTypeDefragFunc (RedisModuleDefragCtx*,RedisModuleString*,void**)",redismodule.h,"typedef int (*RedisModuleTypeDefragFunc)(RedisModuleDefragCtx *ctx, RedisModuleString *key, void **value);",905.0,905.0,13.0,105.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5493,314852,RedisModule_Alloc,1,RedisModule_Alloc,void* RedisModule_Alloc (size_t),redismodule.h,void * (*RedisModule_Alloc)(size_t bytes) REDISMODULE_ATTR;,959.0,959.0,22.0,57.0,1.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,void*
5494,314857,RedisModule_TryAlloc,1,RedisModule_TryAlloc,void* RedisModule_TryAlloc (size_t),redismodule.h,void * (*RedisModule_TryAlloc)(size_t bytes) REDISMODULE_ATTR;,960.0,960.0,22.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
5495,314862,RedisModule_Realloc,1,RedisModule_Realloc,"void* RedisModule_Realloc (void*,size_t)",redismodule.h,"void * (*RedisModule_Realloc)(void *ptr, size_t bytes) REDISMODULE_ATTR;",961.0,961.0,22.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5496,314868,RedisModule_Free,1,RedisModule_Free,void RedisModule_Free (void*),redismodule.h,void (*RedisModule_Free)(void *ptr) REDISMODULE_ATTR;,962.0,962.0,22.0,51.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
5497,314873,RedisModule_Calloc,1,RedisModule_Calloc,"void* RedisModule_Calloc (size_t,size_t)",redismodule.h,"void * (*RedisModule_Calloc)(size_t nmemb, size_t size) REDISMODULE_ATTR;",963.0,963.0,22.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5498,314879,RedisModule_Strdup,1,RedisModule_Strdup,char* RedisModule_Strdup (char*),redismodule.h,char * (*RedisModule_Strdup)(const char *str) REDISMODULE_ATTR;,964.0,964.0,22.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
5499,314884,RedisModule_GetApi,1,RedisModule_GetApi,"int RedisModule_GetApi (char*,void*)",redismodule.h,"int (*RedisModule_GetApi)(const char *, void *) REDISMODULE_ATTR;",965.0,965.0,21.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5500,314890,RedisModule_CreateCommand,1,RedisModule_CreateCommand,"int RedisModule_CreateCommand (RedisModuleCtx*,char*,RedisModuleCmdFunc,char*,int,int,int)",redismodule.h,"int (*RedisModule_CreateCommand)(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) REDISMODULE_ATTR;",966.0,966.0,21.0,177.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,14,7,7,int
5501,314901,RedisModule_GetCommand,1,RedisModule_GetCommand,"RedisModuleCommand* RedisModule_GetCommand (RedisModuleCtx*,char*)",redismodule.h,"RedisModuleCommand *(*RedisModule_GetCommand)(RedisModuleCtx *ctx, const char *name) REDISMODULE_ATTR;",967.0,967.0,36.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleCommand*
5502,314907,RedisModule_CreateSubcommand,1,RedisModule_CreateSubcommand,"int RedisModule_CreateSubcommand (RedisModuleCommand*,char*,RedisModuleCmdFunc,char*,int,int,int)",redismodule.h,"int (*RedisModule_CreateSubcommand)(RedisModuleCommand *parent, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) REDISMODULE_ATTR;",968.0,968.0,21.0,187.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,14,7,7,int
5503,314918,RedisModule_SetCommandInfo,1,RedisModule_SetCommandInfo,"int RedisModule_SetCommandInfo (RedisModuleCommand*,RedisModuleCommandInfo*)",redismodule.h,"int (*RedisModule_SetCommandInfo)(RedisModuleCommand *command, const RedisModuleCommandInfo *info) REDISMODULE_ATTR;",969.0,969.0,21.0,114.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5504,314924,RedisModule_SetCommandACLCategories,1,RedisModule_SetCommandACLCategories,"int RedisModule_SetCommandACLCategories (RedisModuleCommand*,char*)",redismodule.h,"int (*RedisModule_SetCommandACLCategories)(RedisModuleCommand *command, const char *ctgrsflags) REDISMODULE_ATTR;",970.0,970.0,21.0,111.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5505,314930,RedisModule_SetModuleAttribs,1,RedisModule_SetModuleAttribs,"void RedisModule_SetModuleAttribs (RedisModuleCtx*,char*,int,int)",redismodule.h,"void (*RedisModule_SetModuleAttribs)(RedisModuleCtx *ctx, const char *name, int ver, int apiver) REDISMODULE_ATTR;",971.0,971.0,22.0,112.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
5506,314938,RedisModule_IsModuleNameBusy,1,RedisModule_IsModuleNameBusy,int RedisModule_IsModuleNameBusy (char*),redismodule.h,int (*RedisModule_IsModuleNameBusy)(const char *name) REDISMODULE_ATTR;,972.0,972.0,21.0,69.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5507,314943,RedisModule_WrongArity,1,RedisModule_WrongArity,int RedisModule_WrongArity (RedisModuleCtx*),redismodule.h,int (*RedisModule_WrongArity)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,973.0,973.0,21.0,66.0,1.0,0,0,0,0,24,0,1,1,0,0,,0,0,2,1,1,int
5508,314948,RedisModule_ReplyWithLongLong,1,RedisModule_ReplyWithLongLong,"int RedisModule_ReplyWithLongLong (RedisModuleCtx*,long long)",redismodule.h,"int (*RedisModule_ReplyWithLongLong)(RedisModuleCtx *ctx, long long ll) REDISMODULE_ATTR;",974.0,974.0,21.0,87.0,1.0,0,0,0,0,14,0,1,1,0,0,,0,0,4,2,2,int
5509,314954,RedisModule_GetSelectedDb,1,RedisModule_GetSelectedDb,int RedisModule_GetSelectedDb (RedisModuleCtx*),redismodule.h,int (*RedisModule_GetSelectedDb)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,975.0,975.0,21.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
5510,314959,RedisModule_SelectDb,1,RedisModule_SelectDb,"int RedisModule_SelectDb (RedisModuleCtx*,int)",redismodule.h,"int (*RedisModule_SelectDb)(RedisModuleCtx *ctx, int newid) REDISMODULE_ATTR;",976.0,976.0,21.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5511,314965,RedisModule_KeyExists,1,RedisModule_KeyExists,"int RedisModule_KeyExists (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"int (*RedisModule_KeyExists)(RedisModuleCtx *ctx, RedisModuleString *keyname) REDISMODULE_ATTR;",977.0,977.0,21.0,93.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5512,314971,RedisModule_OpenKey,1,RedisModule_OpenKey,"RedisModuleKey* RedisModule_OpenKey (RedisModuleCtx*,RedisModuleString*,int)",redismodule.h,"RedisModuleKey * (*RedisModule_OpenKey)(RedisModuleCtx *ctx, RedisModuleString *keyname, int mode) REDISMODULE_ATTR;",978.0,978.0,32.0,114.0,1.0,0,0,0,0,15,0,1,1,0,0,,0,0,6,3,3,RedisModuleKey*
5513,314978,RedisModule_GetOpenKeyModesAll,1,RedisModule_GetOpenKeyModesAll,int RedisModule_GetOpenKeyModesAll (void),redismodule.h,int (*RedisModule_GetOpenKeyModesAll)(void) REDISMODULE_ATTR;,979.0,979.0,21.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5514,314983,RedisModule_CloseKey,1,RedisModule_CloseKey,void RedisModule_CloseKey (RedisModuleKey*),redismodule.h,void (*RedisModule_CloseKey)(RedisModuleKey *kp) REDISMODULE_ATTR;,980.0,980.0,22.0,64.0,1.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
5515,314988,RedisModule_KeyType,1,RedisModule_KeyType,int RedisModule_KeyType (RedisModuleKey*),redismodule.h,int (*RedisModule_KeyType)(RedisModuleKey *kp) REDISMODULE_ATTR;,981.0,981.0,21.0,62.0,1.0,0,0,0,0,17,0,1,1,0,0,,0,0,2,1,1,int
5516,314993,RedisModule_ValueLength,1,RedisModule_ValueLength,size_t RedisModule_ValueLength (RedisModuleKey*),redismodule.h,size_t (*RedisModule_ValueLength)(RedisModuleKey *kp) REDISMODULE_ATTR;,982.0,982.0,24.0,69.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,size_t
5517,314998,RedisModule_ListPush,1,RedisModule_ListPush,"int RedisModule_ListPush (RedisModuleKey*,int,RedisModuleString*)",redismodule.h,"int (*RedisModule_ListPush)(RedisModuleKey *kp, int where, RedisModuleString *ele) REDISMODULE_ATTR;",983.0,983.0,21.0,98.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,int
5518,315005,RedisModule_ListPop,1,RedisModule_ListPop,"RedisModuleString* RedisModule_ListPop (RedisModuleKey*,int)",redismodule.h,"RedisModuleString * (*RedisModule_ListPop)(RedisModuleKey *key, int where) REDISMODULE_ATTR;",984.0,984.0,35.0,90.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5519,315011,RedisModule_ListGet,1,RedisModule_ListGet,"RedisModuleString* RedisModule_ListGet (RedisModuleKey*,long)",redismodule.h,"RedisModuleString * (*RedisModule_ListGet)(RedisModuleKey *key, long index) REDISMODULE_ATTR;",985.0,985.0,35.0,91.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5520,315017,RedisModule_ListSet,1,RedisModule_ListSet,"int RedisModule_ListSet (RedisModuleKey*,long,RedisModuleString*)",redismodule.h,"int (*RedisModule_ListSet)(RedisModuleKey *key, long index, RedisModuleString *value) REDISMODULE_ATTR;",986.0,986.0,21.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5521,315024,RedisModule_ListInsert,1,RedisModule_ListInsert,"int RedisModule_ListInsert (RedisModuleKey*,long,RedisModuleString*)",redismodule.h,"int (*RedisModule_ListInsert)(RedisModuleKey *key, long index, RedisModuleString *value) REDISMODULE_ATTR;",987.0,987.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5522,315031,RedisModule_ListDelete,1,RedisModule_ListDelete,"int RedisModule_ListDelete (RedisModuleKey*,long)",redismodule.h,"int (*RedisModule_ListDelete)(RedisModuleKey *key, long index) REDISMODULE_ATTR;",988.0,988.0,21.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5523,315037,RedisModule_Call,1,RedisModule_Call,"RedisModuleCallReply* RedisModule_Call (RedisModuleCtx*,char*,char*...)",redismodule.h,"RedisModuleCallReply * (*RedisModule_Call)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",989.0,989.0,38.0,122.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,6,3,3,RedisModuleCallReply*
5524,315044,RedisModule_CallReplyProto,1,RedisModule_CallReplyProto,"char* RedisModule_CallReplyProto (RedisModuleCallReply*,size_t*)",redismodule.h,"const char * (*RedisModule_CallReplyProto)(RedisModuleCallReply *reply, size_t *len) REDISMODULE_ATTR;",990.0,990.0,28.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
5525,315050,RedisModule_FreeCallReply,1,RedisModule_FreeCallReply,void RedisModule_FreeCallReply (RedisModuleCallReply*),redismodule.h,void (*RedisModule_FreeCallReply)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,991.0,991.0,22.0,78.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
5526,315055,RedisModule_CallReplyType,1,RedisModule_CallReplyType,int RedisModule_CallReplyType (RedisModuleCallReply*),redismodule.h,int (*RedisModule_CallReplyType)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,992.0,992.0,21.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5527,315060,RedisModule_CallReplyInteger,1,RedisModule_CallReplyInteger,long long RedisModule_CallReplyInteger (RedisModuleCallReply*),redismodule.h,long long (*RedisModule_CallReplyInteger)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,993.0,993.0,27.0,86.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,long long
5528,315065,RedisModule_CallReplyDouble,1,RedisModule_CallReplyDouble,double RedisModule_CallReplyDouble (RedisModuleCallReply*),redismodule.h,double (*RedisModule_CallReplyDouble)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,994.0,994.0,24.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,double
5529,315070,RedisModule_CallReplyBool,1,RedisModule_CallReplyBool,int RedisModule_CallReplyBool (RedisModuleCallReply*),redismodule.h,int (*RedisModule_CallReplyBool)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,995.0,995.0,21.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5530,315075,RedisModule_CallReplyBigNumber,1,RedisModule_CallReplyBigNumber,"char* RedisModule_CallReplyBigNumber (RedisModuleCallReply*,size_t*)",redismodule.h,"const char* (*RedisModule_CallReplyBigNumber)(RedisModuleCallReply *reply, size_t *len) REDISMODULE_ATTR;",996.0,996.0,27.0,103.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
5531,315081,RedisModule_CallReplyVerbatim,1,RedisModule_CallReplyVerbatim,"char* RedisModule_CallReplyVerbatim (RedisModuleCallReply*,size_t*,char**)",redismodule.h,"const char* (*RedisModule_CallReplyVerbatim)(RedisModuleCallReply *reply, size_t *len, const char **format) REDISMODULE_ATTR;",997.0,997.0,27.0,123.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,char*
5532,315088,RedisModule_CallReplySetElement,1,RedisModule_CallReplySetElement,"RedisModuleCallReply* RedisModule_CallReplySetElement (RedisModuleCallReply*,size_t)",redismodule.h,"RedisModuleCallReply * (*RedisModule_CallReplySetElement)(RedisModuleCallReply *reply, size_t idx) REDISMODULE_ATTR;",998.0,998.0,38.0,114.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleCallReply*
5533,315094,RedisModule_CallReplyMapElement,1,RedisModule_CallReplyMapElement,"int RedisModule_CallReplyMapElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)",redismodule.h,"int (*RedisModule_CallReplyMapElement)(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) REDISMODULE_ATTR;",999.0,999.0,21.0,151.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5534,315102,RedisModule_CallReplyAttributeElement,1,RedisModule_CallReplyAttributeElement,"int RedisModule_CallReplyAttributeElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)",redismodule.h,"int (*RedisModule_CallReplyAttributeElement)(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) REDISMODULE_ATTR;",1000.0,1000.0,21.0,157.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5535,315110,RedisModule_CallReplyPromiseSetUnblockHandler,1,RedisModule_CallReplyPromiseSetUnblockHandler,"void RedisModule_CallReplyPromiseSetUnblockHandler (RedisModuleCallReply*,RedisModuleOnUnblocked,void*)",redismodule.h,"void (*RedisModule_CallReplyPromiseSetUnblockHandler)(RedisModuleCallReply *reply, RedisModuleOnUnblocked on_unblock, void *private_data) REDISMODULE_ATTR;",1001.0,1001.0,22.0,153.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5536,315117,RedisModule_CallReplyPromiseAbort,1,RedisModule_CallReplyPromiseAbort,"int RedisModule_CallReplyPromiseAbort (RedisModuleCallReply*,void**)",redismodule.h,"int (*RedisModule_CallReplyPromiseAbort)(RedisModuleCallReply *reply, void **private_data) REDISMODULE_ATTR;",1002.0,1002.0,21.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5537,315123,RedisModule_CallReplyAttribute,1,RedisModule_CallReplyAttribute,RedisModuleCallReply* RedisModule_CallReplyAttribute (RedisModuleCallReply*),redismodule.h,RedisModuleCallReply * (*RedisModule_CallReplyAttribute)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,1003.0,1003.0,38.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleCallReply*
5538,315128,RedisModule_CallReplyLength,1,RedisModule_CallReplyLength,size_t RedisModule_CallReplyLength (RedisModuleCallReply*),redismodule.h,size_t (*RedisModule_CallReplyLength)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,1004.0,1004.0,24.0,82.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,size_t
5539,315133,RedisModule_CallReplyArrayElement,1,RedisModule_CallReplyArrayElement,"RedisModuleCallReply* RedisModule_CallReplyArrayElement (RedisModuleCallReply*,size_t)",redismodule.h,"RedisModuleCallReply * (*RedisModule_CallReplyArrayElement)(RedisModuleCallReply *reply, size_t idx) REDISMODULE_ATTR;",1005.0,1005.0,38.0,116.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,RedisModuleCallReply*
5540,315139,RedisModule_CreateString,1,RedisModule_CreateString,"RedisModuleString* RedisModule_CreateString (RedisModuleCtx*,char*,size_t)",redismodule.h,"RedisModuleString * (*RedisModule_CreateString)(RedisModuleCtx *ctx, const char *ptr, size_t len) REDISMODULE_ATTR;",1006.0,1006.0,35.0,113.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleString*
5541,315146,RedisModule_CreateStringFromLongLong,1,RedisModule_CreateStringFromLongLong,"RedisModuleString* RedisModule_CreateStringFromLongLong (RedisModuleCtx*,long long)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromLongLong)(RedisModuleCtx *ctx, long long ll) REDISMODULE_ATTR;",1007.0,1007.0,35.0,110.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5542,315152,RedisModule_CreateStringFromULongLong,1,RedisModule_CreateStringFromULongLong,"RedisModuleString* RedisModule_CreateStringFromULongLong (RedisModuleCtx*,long long unsigned)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromULongLong)(RedisModuleCtx *ctx, unsigned long long ull) REDISMODULE_ATTR;",1008.0,1008.0,35.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5543,315158,RedisModule_CreateStringFromDouble,1,RedisModule_CreateStringFromDouble,"RedisModuleString* RedisModule_CreateStringFromDouble (RedisModuleCtx*,double)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromDouble)(RedisModuleCtx *ctx, double d) REDISMODULE_ATTR;",1009.0,1009.0,35.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5544,315164,RedisModule_CreateStringFromLongDouble,1,RedisModule_CreateStringFromLongDouble,"RedisModuleString* RedisModule_CreateStringFromLongDouble (RedisModuleCtx*,long double,int)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromLongDouble)(RedisModuleCtx *ctx, long double ld, int humanfriendly) REDISMODULE_ATTR;",1010.0,1010.0,35.0,133.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleString*
5545,315171,RedisModule_CreateStringFromString,1,RedisModule_CreateStringFromString,"RedisModuleString* RedisModule_CreateStringFromString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromString)(RedisModuleCtx *ctx, const RedisModuleString *str) REDISMODULE_ATTR;",1011.0,1011.0,35.0,124.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5546,315177,RedisModule_CreateStringFromStreamID,1,RedisModule_CreateStringFromStreamID,"RedisModuleString* RedisModule_CreateStringFromStreamID (RedisModuleCtx*,RedisModuleStreamID*)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringFromStreamID)(RedisModuleCtx *ctx, const RedisModuleStreamID *id) REDISMODULE_ATTR;",1012.0,1012.0,35.0,127.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5547,315183,RedisModule_CreateStringPrintf,1,RedisModule_CreateStringPrintf,"RedisModuleString* RedisModule_CreateStringPrintf (RedisModuleCtx*,char*...)",redismodule.h,"RedisModuleString * (*RedisModule_CreateStringPrintf)(RedisModuleCtx *ctx, const char *fmt, ...) REDISMODULE_ATTR_PRINTF(2,3) REDISMODULE_ATTR;",1013.0,1013.0,35.0,112.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5548,315189,RedisModule_FreeString,1,RedisModule_FreeString,"void RedisModule_FreeString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"void (*RedisModule_FreeString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1014.0,1014.0,22.0,91.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,void
5549,315195,RedisModule_StringPtrLen,1,RedisModule_StringPtrLen,"char* RedisModule_StringPtrLen (RedisModuleString*,size_t*)",redismodule.h,"const char * (*RedisModule_StringPtrLen)(const RedisModuleString *str, size_t *len) REDISMODULE_ATTR;",1015.0,1015.0,28.0,99.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,char*
5550,315201,RedisModule_ReplyWithError,1,RedisModule_ReplyWithError,"int RedisModule_ReplyWithError (RedisModuleCtx*,char*)",redismodule.h,"int (*RedisModule_ReplyWithError)(RedisModuleCtx *ctx, const char *err) REDISMODULE_ATTR;",1016.0,1016.0,21.0,87.0,1.0,0,0,0,0,31,0,1,1,0,0,,0,0,4,2,2,int
5551,315207,RedisModule_ReplyWithErrorFormat,1,RedisModule_ReplyWithErrorFormat,"int RedisModule_ReplyWithErrorFormat (RedisModuleCtx*,char*...)",redismodule.h,"int (*RedisModule_ReplyWithErrorFormat)(RedisModuleCtx *ctx, const char *fmt, ...) REDISMODULE_ATTR;",1017.0,1017.0,21.0,98.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5552,315213,RedisModule_ReplyWithSimpleString,1,RedisModule_ReplyWithSimpleString,"int RedisModule_ReplyWithSimpleString (RedisModuleCtx*,char*)",redismodule.h,"int (*RedisModule_ReplyWithSimpleString)(RedisModuleCtx *ctx, const char *msg) REDISMODULE_ATTR;",1018.0,1018.0,21.0,94.0,1.0,0,0,0,0,11,0,1,1,0,0,,0,0,4,2,2,int
5553,315219,RedisModule_ReplyWithArray,1,RedisModule_ReplyWithArray,"int RedisModule_ReplyWithArray (RedisModuleCtx*,long)",redismodule.h,"int (*RedisModule_ReplyWithArray)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1019.0,1019.0,21.0,80.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,4,2,2,int
5554,315225,RedisModule_ReplyWithMap,1,RedisModule_ReplyWithMap,"int RedisModule_ReplyWithMap (RedisModuleCtx*,long)",redismodule.h,"int (*RedisModule_ReplyWithMap)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1020.0,1020.0,21.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5555,315231,RedisModule_ReplyWithSet,1,RedisModule_ReplyWithSet,"int RedisModule_ReplyWithSet (RedisModuleCtx*,long)",redismodule.h,"int (*RedisModule_ReplyWithSet)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1021.0,1021.0,21.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5556,315237,RedisModule_ReplyWithAttribute,1,RedisModule_ReplyWithAttribute,"int RedisModule_ReplyWithAttribute (RedisModuleCtx*,long)",redismodule.h,"int (*RedisModule_ReplyWithAttribute)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1022.0,1022.0,21.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5557,315243,RedisModule_ReplyWithNullArray,1,RedisModule_ReplyWithNullArray,int RedisModule_ReplyWithNullArray (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplyWithNullArray)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1023.0,1023.0,21.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5558,315248,RedisModule_ReplyWithEmptyArray,1,RedisModule_ReplyWithEmptyArray,int RedisModule_ReplyWithEmptyArray (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplyWithEmptyArray)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1024.0,1024.0,21.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5559,315253,RedisModule_ReplySetArrayLength,1,RedisModule_ReplySetArrayLength,"void RedisModule_ReplySetArrayLength (RedisModuleCtx*,long)",redismodule.h,"void (*RedisModule_ReplySetArrayLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1025.0,1025.0,22.0,86.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,void
5560,315259,RedisModule_ReplySetMapLength,1,RedisModule_ReplySetMapLength,"void RedisModule_ReplySetMapLength (RedisModuleCtx*,long)",redismodule.h,"void (*RedisModule_ReplySetMapLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1026.0,1026.0,22.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5561,315265,RedisModule_ReplySetSetLength,1,RedisModule_ReplySetSetLength,"void RedisModule_ReplySetSetLength (RedisModuleCtx*,long)",redismodule.h,"void (*RedisModule_ReplySetSetLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1027.0,1027.0,22.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5562,315271,RedisModule_ReplySetAttributeLength,1,RedisModule_ReplySetAttributeLength,"void RedisModule_ReplySetAttributeLength (RedisModuleCtx*,long)",redismodule.h,"void (*RedisModule_ReplySetAttributeLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1028.0,1028.0,22.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5563,315277,RedisModule_ReplySetPushLength,1,RedisModule_ReplySetPushLength,"void RedisModule_ReplySetPushLength (RedisModuleCtx*,long)",redismodule.h,"void (*RedisModule_ReplySetPushLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",1029.0,1029.0,22.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5564,315283,RedisModule_ReplyWithStringBuffer,1,RedisModule_ReplyWithStringBuffer,"int RedisModule_ReplyWithStringBuffer (RedisModuleCtx*,char*,size_t)",redismodule.h,"int (*RedisModule_ReplyWithStringBuffer)(RedisModuleCtx *ctx, const char *buf, size_t len) REDISMODULE_ATTR;",1030.0,1030.0,21.0,106.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,int
5565,315290,RedisModule_ReplyWithCString,1,RedisModule_ReplyWithCString,"int RedisModule_ReplyWithCString (RedisModuleCtx*,char*)",redismodule.h,"int (*RedisModule_ReplyWithCString)(RedisModuleCtx *ctx, const char *buf) REDISMODULE_ATTR;",1031.0,1031.0,21.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5566,315296,RedisModule_ReplyWithString,1,RedisModule_ReplyWithString,"int RedisModule_ReplyWithString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"int (*RedisModule_ReplyWithString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1032.0,1032.0,21.0,95.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
5567,315302,RedisModule_ReplyWithEmptyString,1,RedisModule_ReplyWithEmptyString,int RedisModule_ReplyWithEmptyString (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplyWithEmptyString)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1033.0,1033.0,21.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5568,315307,RedisModule_ReplyWithVerbatimString,1,RedisModule_ReplyWithVerbatimString,"int RedisModule_ReplyWithVerbatimString (RedisModuleCtx*,char*,size_t)",redismodule.h,"int (*RedisModule_ReplyWithVerbatimString)(RedisModuleCtx *ctx, const char *buf, size_t len) REDISMODULE_ATTR;",1034.0,1034.0,21.0,108.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5569,315314,RedisModule_ReplyWithVerbatimStringType,1,RedisModule_ReplyWithVerbatimStringType,"int RedisModule_ReplyWithVerbatimStringType (RedisModuleCtx*,char*,size_t,char*)",redismodule.h,"int (*RedisModule_ReplyWithVerbatimStringType)(RedisModuleCtx *ctx, const char *buf, size_t len, const char *ext) REDISMODULE_ATTR;",1035.0,1035.0,21.0,129.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5570,315322,RedisModule_ReplyWithNull,1,RedisModule_ReplyWithNull,int RedisModule_ReplyWithNull (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplyWithNull)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1036.0,1036.0,21.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
5571,315327,RedisModule_ReplyWithBool,1,RedisModule_ReplyWithBool,"int RedisModule_ReplyWithBool (RedisModuleCtx*,int)",redismodule.h,"int (*RedisModule_ReplyWithBool)(RedisModuleCtx *ctx, int b) REDISMODULE_ATTR;",1037.0,1037.0,21.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5572,315333,RedisModule_ReplyWithLongDouble,1,RedisModule_ReplyWithLongDouble,"int RedisModule_ReplyWithLongDouble (RedisModuleCtx*,long double)",redismodule.h,"int (*RedisModule_ReplyWithLongDouble)(RedisModuleCtx *ctx, long double d) REDISMODULE_ATTR;",1038.0,1038.0,21.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5573,315339,RedisModule_ReplyWithDouble,1,RedisModule_ReplyWithDouble,"int RedisModule_ReplyWithDouble (RedisModuleCtx*,double)",redismodule.h,"int (*RedisModule_ReplyWithDouble)(RedisModuleCtx *ctx, double d) REDISMODULE_ATTR;",1039.0,1039.0,21.0,81.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
5574,315345,RedisModule_ReplyWithBigNumber,1,RedisModule_ReplyWithBigNumber,"int RedisModule_ReplyWithBigNumber (RedisModuleCtx*,char*,size_t)",redismodule.h,"int (*RedisModule_ReplyWithBigNumber)(RedisModuleCtx *ctx, const char *bignum, size_t len) REDISMODULE_ATTR;",1040.0,1040.0,21.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5575,315352,RedisModule_ReplyWithCallReply,1,RedisModule_ReplyWithCallReply,"int RedisModule_ReplyWithCallReply (RedisModuleCtx*,RedisModuleCallReply*)",redismodule.h,"int (*RedisModule_ReplyWithCallReply)(RedisModuleCtx *ctx, RedisModuleCallReply *reply) REDISMODULE_ATTR;",1041.0,1041.0,21.0,103.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
5576,315358,RedisModule_StringToLongLong,1,RedisModule_StringToLongLong,"int RedisModule_StringToLongLong (RedisModuleString*,long long*)",redismodule.h,"int (*RedisModule_StringToLongLong)(const RedisModuleString *str, long long *ll) REDISMODULE_ATTR;",1042.0,1042.0,21.0,96.0,1.0,0,0,0,0,14,0,1,1,0,0,,0,0,4,2,2,int
5577,315364,RedisModule_StringToULongLong,1,RedisModule_StringToULongLong,"int RedisModule_StringToULongLong (RedisModuleString*,long long unsigned*)",redismodule.h,"int (*RedisModule_StringToULongLong)(const RedisModuleString *str, unsigned long long *ull) REDISMODULE_ATTR;",1043.0,1043.0,21.0,107.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5578,315370,RedisModule_StringToDouble,1,RedisModule_StringToDouble,"int RedisModule_StringToDouble (RedisModuleString*,double*)",redismodule.h,"int (*RedisModule_StringToDouble)(const RedisModuleString *str, double *d) REDISMODULE_ATTR;",1044.0,1044.0,21.0,90.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
5579,315376,RedisModule_StringToLongDouble,1,RedisModule_StringToLongDouble,"int RedisModule_StringToLongDouble (RedisModuleString*,long double*)",redismodule.h,"int (*RedisModule_StringToLongDouble)(const RedisModuleString *str, long double *d) REDISMODULE_ATTR;",1045.0,1045.0,21.0,99.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5580,315382,RedisModule_StringToStreamID,1,RedisModule_StringToStreamID,"int RedisModule_StringToStreamID (RedisModuleString*,RedisModuleStreamID*)",redismodule.h,"int (*RedisModule_StringToStreamID)(const RedisModuleString *str, RedisModuleStreamID *id) REDISMODULE_ATTR;",1046.0,1046.0,21.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5581,315388,RedisModule_AutoMemory,1,RedisModule_AutoMemory,void RedisModule_AutoMemory (RedisModuleCtx*),redismodule.h,void (*RedisModule_AutoMemory)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1047.0,1047.0,22.0,67.0,1.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
5582,315393,RedisModule_Replicate,1,RedisModule_Replicate,"int RedisModule_Replicate (RedisModuleCtx*,char*,char*...)",redismodule.h,"int (*RedisModule_Replicate)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",1048.0,1048.0,21.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
5583,315400,RedisModule_ReplicateVerbatim,1,RedisModule_ReplicateVerbatim,int RedisModule_ReplicateVerbatim (RedisModuleCtx*),redismodule.h,int (*RedisModule_ReplicateVerbatim)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1049.0,1049.0,21.0,73.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
5584,315405,RedisModule_CallReplyStringPtr,1,RedisModule_CallReplyStringPtr,"char* RedisModule_CallReplyStringPtr (RedisModuleCallReply*,size_t*)",redismodule.h,"const char * (*RedisModule_CallReplyStringPtr)(RedisModuleCallReply *reply, size_t *len) REDISMODULE_ATTR;",1050.0,1050.0,28.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
5585,315411,RedisModule_CreateStringFromCallReply,1,RedisModule_CreateStringFromCallReply,RedisModuleString* RedisModule_CreateStringFromCallReply (RedisModuleCallReply*),redismodule.h,RedisModuleString * (*RedisModule_CreateStringFromCallReply)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,1051.0,1051.0,35.0,105.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5586,315416,RedisModule_DeleteKey,1,RedisModule_DeleteKey,int RedisModule_DeleteKey (RedisModuleKey*),redismodule.h,int (*RedisModule_DeleteKey)(RedisModuleKey *key) REDISMODULE_ATTR;,1052.0,1052.0,21.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5587,315421,RedisModule_UnlinkKey,1,RedisModule_UnlinkKey,int RedisModule_UnlinkKey (RedisModuleKey*),redismodule.h,int (*RedisModule_UnlinkKey)(RedisModuleKey *key) REDISMODULE_ATTR;,1053.0,1053.0,21.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5588,315426,RedisModule_StringSet,1,RedisModule_StringSet,"int RedisModule_StringSet (RedisModuleKey*,RedisModuleString*)",redismodule.h,"int (*RedisModule_StringSet)(RedisModuleKey *key, RedisModuleString *str) REDISMODULE_ATTR;",1054.0,1054.0,21.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5589,315432,RedisModule_StringDMA,1,RedisModule_StringDMA,"char* RedisModule_StringDMA (RedisModuleKey*,size_t*,int)",redismodule.h,"char * (*RedisModule_StringDMA)(RedisModuleKey *key, size_t *len, int mode) REDISMODULE_ATTR;",1055.0,1055.0,22.0,91.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,char*
5590,315439,RedisModule_StringTruncate,1,RedisModule_StringTruncate,"int RedisModule_StringTruncate (RedisModuleKey*,size_t)",redismodule.h,"int (*RedisModule_StringTruncate)(RedisModuleKey *key, size_t newlen) REDISMODULE_ATTR;",1056.0,1056.0,21.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5591,315445,RedisModule_GetExpire,1,RedisModule_GetExpire,mstime_t RedisModule_GetExpire (RedisModuleKey*),redismodule.h,mstime_t (*RedisModule_GetExpire)(RedisModuleKey *key) REDISMODULE_ATTR;,1057.0,1057.0,26.0,70.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,mstime_t
5592,315450,RedisModule_SetExpire,1,RedisModule_SetExpire,"int RedisModule_SetExpire (RedisModuleKey*,mstime_t)",redismodule.h,"int (*RedisModule_SetExpire)(RedisModuleKey *key, mstime_t expire) REDISMODULE_ATTR;",1058.0,1058.0,21.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
5593,315456,RedisModule_GetAbsExpire,1,RedisModule_GetAbsExpire,mstime_t RedisModule_GetAbsExpire (RedisModuleKey*),redismodule.h,mstime_t (*RedisModule_GetAbsExpire)(RedisModuleKey *key) REDISMODULE_ATTR;,1059.0,1059.0,26.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,mstime_t
5594,315461,RedisModule_SetAbsExpire,1,RedisModule_SetAbsExpire,"int RedisModule_SetAbsExpire (RedisModuleKey*,mstime_t)",redismodule.h,"int (*RedisModule_SetAbsExpire)(RedisModuleKey *key, mstime_t expire) REDISMODULE_ATTR;",1060.0,1060.0,21.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5595,315467,RedisModule_ResetDataset,1,RedisModule_ResetDataset,"void RedisModule_ResetDataset (int,int)",redismodule.h,"void (*RedisModule_ResetDataset)(int restart_aof, int async) REDISMODULE_ATTR;",1061.0,1061.0,22.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5596,315473,RedisModule_DbSize,1,RedisModule_DbSize,long long unsigned RedisModule_DbSize (RedisModuleCtx*),redismodule.h,unsigned long long (*RedisModule_DbSize)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1062.0,1062.0,36.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,long long unsigned
5597,315478,RedisModule_RandomKey,1,RedisModule_RandomKey,RedisModuleString* RedisModule_RandomKey (RedisModuleCtx*),redismodule.h,RedisModuleString * (*RedisModule_RandomKey)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1063.0,1063.0,35.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5598,315483,RedisModule_ZsetAdd,1,RedisModule_ZsetAdd,"int RedisModule_ZsetAdd (RedisModuleKey*,double,RedisModuleString*,int*)",redismodule.h,"int (*RedisModule_ZsetAdd)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) REDISMODULE_ATTR;",1064.0,1064.0,21.0,116.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5599,315491,RedisModule_ZsetIncrby,1,RedisModule_ZsetIncrby,"int RedisModule_ZsetIncrby (RedisModuleKey*,double,RedisModuleString*,int*,double*)",redismodule.h,"int (*RedisModule_ZsetIncrby)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) REDISMODULE_ATTR;",1065.0,1065.0,21.0,137.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
5600,315500,RedisModule_ZsetScore,1,RedisModule_ZsetScore,"int RedisModule_ZsetScore (RedisModuleKey*,RedisModuleString*,double*)",redismodule.h,"int (*RedisModule_ZsetScore)(RedisModuleKey *key, RedisModuleString *ele, double *score) REDISMODULE_ATTR;",1066.0,1066.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5601,315507,RedisModule_ZsetRem,1,RedisModule_ZsetRem,"int RedisModule_ZsetRem (RedisModuleKey*,RedisModuleString*,int*)",redismodule.h,"int (*RedisModule_ZsetRem)(RedisModuleKey *key, RedisModuleString *ele, int *deleted) REDISMODULE_ATTR;",1067.0,1067.0,21.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5602,315514,RedisModule_ZsetRangeStop,1,RedisModule_ZsetRangeStop,void RedisModule_ZsetRangeStop (RedisModuleKey*),redismodule.h,void (*RedisModule_ZsetRangeStop)(RedisModuleKey *key) REDISMODULE_ATTR;,1068.0,1068.0,22.0,70.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
5603,315519,RedisModule_ZsetFirstInScoreRange,1,RedisModule_ZsetFirstInScoreRange,"int RedisModule_ZsetFirstInScoreRange (RedisModuleKey*,double,double,int,int)",redismodule.h,"int (*RedisModule_ZsetFirstInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex) REDISMODULE_ATTR;",1069.0,1069.0,21.0,123.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
5604,315528,RedisModule_ZsetLastInScoreRange,1,RedisModule_ZsetLastInScoreRange,"int RedisModule_ZsetLastInScoreRange (RedisModuleKey*,double,double,int,int)",redismodule.h,"int (*RedisModule_ZsetLastInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex) REDISMODULE_ATTR;",1070.0,1070.0,21.0,122.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
5605,315537,RedisModule_ZsetFirstInLexRange,1,RedisModule_ZsetFirstInLexRange,"int RedisModule_ZsetFirstInLexRange (RedisModuleKey*,RedisModuleString*,RedisModuleString*)",redismodule.h,"int (*RedisModule_ZsetFirstInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) REDISMODULE_ATTR;",1071.0,1071.0,21.0,123.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
5606,315544,RedisModule_ZsetLastInLexRange,1,RedisModule_ZsetLastInLexRange,"int RedisModule_ZsetLastInLexRange (RedisModuleKey*,RedisModuleString*,RedisModuleString*)",redismodule.h,"int (*RedisModule_ZsetLastInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) REDISMODULE_ATTR;",1072.0,1072.0,21.0,122.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5607,315551,RedisModule_ZsetRangeCurrentElement,1,RedisModule_ZsetRangeCurrentElement,"RedisModuleString* RedisModule_ZsetRangeCurrentElement (RedisModuleKey*,double*)",redismodule.h,"RedisModuleString * (*RedisModule_ZsetRangeCurrentElement)(RedisModuleKey *key, double *score) REDISMODULE_ATTR;",1073.0,1073.0,35.0,110.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5608,315557,RedisModule_ZsetRangeNext,1,RedisModule_ZsetRangeNext,int RedisModule_ZsetRangeNext (RedisModuleKey*),redismodule.h,int (*RedisModule_ZsetRangeNext)(RedisModuleKey *key) REDISMODULE_ATTR;,1074.0,1074.0,21.0,69.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
5609,315562,RedisModule_ZsetRangePrev,1,RedisModule_ZsetRangePrev,int RedisModule_ZsetRangePrev (RedisModuleKey*),redismodule.h,int (*RedisModule_ZsetRangePrev)(RedisModuleKey *key) REDISMODULE_ATTR;,1075.0,1075.0,21.0,69.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
5610,315567,RedisModule_ZsetRangeEndReached,1,RedisModule_ZsetRangeEndReached,int RedisModule_ZsetRangeEndReached (RedisModuleKey*),redismodule.h,int (*RedisModule_ZsetRangeEndReached)(RedisModuleKey *key) REDISMODULE_ATTR;,1076.0,1076.0,21.0,75.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
5611,315572,RedisModule_HashSet,1,RedisModule_HashSet,"int RedisModule_HashSet (RedisModuleKey*,int...)",redismodule.h,"int (*RedisModule_HashSet)(RedisModuleKey *key, int flags, ...) REDISMODULE_ATTR;",1077.0,1077.0,21.0,79.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
5612,315578,RedisModule_HashGet,1,RedisModule_HashGet,"int RedisModule_HashGet (RedisModuleKey*,int...)",redismodule.h,"int (*RedisModule_HashGet)(RedisModuleKey *key, int flags, ...) REDISMODULE_ATTR;",1078.0,1078.0,21.0,79.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
5613,315584,RedisModule_StreamAdd,1,RedisModule_StreamAdd,"int RedisModule_StreamAdd (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleString**,int64_t)",redismodule.h,"int (*RedisModule_StreamAdd)(RedisModuleKey *key, int flags, RedisModuleStreamID *id, RedisModuleString **argv, int64_t numfields) REDISMODULE_ATTR;",1079.0,1079.0,21.0,146.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
5614,315593,RedisModule_StreamDelete,1,RedisModule_StreamDelete,"int RedisModule_StreamDelete (RedisModuleKey*,RedisModuleStreamID*)",redismodule.h,"int (*RedisModule_StreamDelete)(RedisModuleKey *key, RedisModuleStreamID *id) REDISMODULE_ATTR;",1080.0,1080.0,21.0,93.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5615,315599,RedisModule_StreamIteratorStart,1,RedisModule_StreamIteratorStart,"int RedisModule_StreamIteratorStart (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleStreamID*)",redismodule.h,"int (*RedisModule_StreamIteratorStart)(RedisModuleKey *key, int flags, RedisModuleStreamID *startid, RedisModuleStreamID *endid) REDISMODULE_ATTR;",1081.0,1081.0,21.0,144.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5616,315607,RedisModule_StreamIteratorStop,1,RedisModule_StreamIteratorStop,int RedisModule_StreamIteratorStop (RedisModuleKey*),redismodule.h,int (*RedisModule_StreamIteratorStop)(RedisModuleKey *key) REDISMODULE_ATTR;,1082.0,1082.0,21.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5617,315612,RedisModule_StreamIteratorNextID,1,RedisModule_StreamIteratorNextID,"int RedisModule_StreamIteratorNextID (RedisModuleKey*,RedisModuleStreamID*,long*)",redismodule.h,"int (*RedisModule_StreamIteratorNextID)(RedisModuleKey *key, RedisModuleStreamID *id, long *numfields) REDISMODULE_ATTR;",1083.0,1083.0,21.0,118.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5618,315619,RedisModule_StreamIteratorNextField,1,RedisModule_StreamIteratorNextField,"int RedisModule_StreamIteratorNextField (RedisModuleKey*,RedisModuleString**,RedisModuleString**)",redismodule.h,"int (*RedisModule_StreamIteratorNextField)(RedisModuleKey *key, RedisModuleString **field_ptr, RedisModuleString **value_ptr) REDISMODULE_ATTR;",1084.0,1084.0,21.0,141.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5619,315626,RedisModule_StreamIteratorDelete,1,RedisModule_StreamIteratorDelete,int RedisModule_StreamIteratorDelete (RedisModuleKey*),redismodule.h,int (*RedisModule_StreamIteratorDelete)(RedisModuleKey *key) REDISMODULE_ATTR;,1085.0,1085.0,21.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5620,315631,RedisModule_StreamTrimByLength,1,RedisModule_StreamTrimByLength,"long long RedisModule_StreamTrimByLength (RedisModuleKey*,int,long long)",redismodule.h,"long long (*RedisModule_StreamTrimByLength)(RedisModuleKey *key, int flags, long long length) REDISMODULE_ATTR;",1086.0,1086.0,27.0,109.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,long long
5621,315638,RedisModule_StreamTrimByID,1,RedisModule_StreamTrimByID,"long long RedisModule_StreamTrimByID (RedisModuleKey*,int,RedisModuleStreamID*)",redismodule.h,"long long (*RedisModule_StreamTrimByID)(RedisModuleKey *key, int flags, RedisModuleStreamID *id) REDISMODULE_ATTR;",1087.0,1087.0,27.0,112.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,long long
5622,315645,RedisModule_IsKeysPositionRequest,1,RedisModule_IsKeysPositionRequest,int RedisModule_IsKeysPositionRequest (RedisModuleCtx*),redismodule.h,int (*RedisModule_IsKeysPositionRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1088.0,1088.0,21.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5623,315650,RedisModule_KeyAtPos,1,RedisModule_KeyAtPos,"void RedisModule_KeyAtPos (RedisModuleCtx*,int)",redismodule.h,"void (*RedisModule_KeyAtPos)(RedisModuleCtx *ctx, int pos) REDISMODULE_ATTR;",1089.0,1089.0,22.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5624,315656,RedisModule_KeyAtPosWithFlags,1,RedisModule_KeyAtPosWithFlags,"void RedisModule_KeyAtPosWithFlags (RedisModuleCtx*,int,int)",redismodule.h,"void (*RedisModule_KeyAtPosWithFlags)(RedisModuleCtx *ctx, int pos, int flags) REDISMODULE_ATTR;",1090.0,1090.0,22.0,94.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5625,315663,RedisModule_IsChannelsPositionRequest,1,RedisModule_IsChannelsPositionRequest,int RedisModule_IsChannelsPositionRequest (RedisModuleCtx*),redismodule.h,int (*RedisModule_IsChannelsPositionRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1091.0,1091.0,21.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5626,315668,RedisModule_ChannelAtPosWithFlags,1,RedisModule_ChannelAtPosWithFlags,"void RedisModule_ChannelAtPosWithFlags (RedisModuleCtx*,int,int)",redismodule.h,"void (*RedisModule_ChannelAtPosWithFlags)(RedisModuleCtx *ctx, int pos, int flags) REDISMODULE_ATTR;",1092.0,1092.0,22.0,98.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5627,315675,RedisModule_GetClientId,1,RedisModule_GetClientId,long long unsigned RedisModule_GetClientId (RedisModuleCtx*),redismodule.h,unsigned long long (*RedisModule_GetClientId)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1093.0,1093.0,36.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,long long unsigned
5628,315680,RedisModule_GetClientUserNameById,1,RedisModule_GetClientUserNameById,"RedisModuleString* RedisModule_GetClientUserNameById (RedisModuleCtx*,uint64_t)",redismodule.h,"RedisModuleString * (*RedisModule_GetClientUserNameById)(RedisModuleCtx *ctx, uint64_t id) REDISMODULE_ATTR;",1094.0,1094.0,35.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5629,315686,RedisModule_GetClientInfoById,1,RedisModule_GetClientInfoById,"int RedisModule_GetClientInfoById (void*,uint64_t)",redismodule.h,"int (*RedisModule_GetClientInfoById)(void *ci, uint64_t id) REDISMODULE_ATTR;",1095.0,1095.0,21.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5630,315692,RedisModule_GetClientNameById,1,RedisModule_GetClientNameById,"RedisModuleString* RedisModule_GetClientNameById (RedisModuleCtx*,uint64_t)",redismodule.h,"RedisModuleString * (*RedisModule_GetClientNameById)(RedisModuleCtx *ctx, uint64_t id) REDISMODULE_ATTR;",1096.0,1096.0,35.0,102.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5631,315698,RedisModule_SetClientNameById,1,RedisModule_SetClientNameById,"int RedisModule_SetClientNameById (uint64_t,RedisModuleString*)",redismodule.h,"int (*RedisModule_SetClientNameById)(uint64_t id, RedisModuleString *name) REDISMODULE_ATTR;",1097.0,1097.0,21.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5632,315704,RedisModule_PublishMessage,1,RedisModule_PublishMessage,"int RedisModule_PublishMessage (RedisModuleCtx*,RedisModuleString*,RedisModuleString*)",redismodule.h,"int (*RedisModule_PublishMessage)(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) REDISMODULE_ATTR;",1098.0,1098.0,21.0,126.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5633,315711,RedisModule_PublishMessageShard,1,RedisModule_PublishMessageShard,"int RedisModule_PublishMessageShard (RedisModuleCtx*,RedisModuleString*,RedisModuleString*)",redismodule.h,"int (*RedisModule_PublishMessageShard)(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) REDISMODULE_ATTR;",1099.0,1099.0,21.0,131.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5634,315718,RedisModule_GetContextFlags,1,RedisModule_GetContextFlags,int RedisModule_GetContextFlags (RedisModuleCtx*),redismodule.h,int (*RedisModule_GetContextFlags)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1100.0,1100.0,21.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5635,315723,RedisModule_AvoidReplicaTraffic,1,RedisModule_AvoidReplicaTraffic,int RedisModule_AvoidReplicaTraffic (void),redismodule.h,int (*RedisModule_AvoidReplicaTraffic)(void) REDISMODULE_ATTR;,1101.0,1101.0,21.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5636,315728,RedisModule_PoolAlloc,1,RedisModule_PoolAlloc,"void* RedisModule_PoolAlloc (RedisModuleCtx*,size_t)",redismodule.h,"void * (*RedisModule_PoolAlloc)(RedisModuleCtx *ctx, size_t bytes) REDISMODULE_ATTR;",1102.0,1102.0,22.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void*
5637,315734,RedisModule_CreateDataType,1,RedisModule_CreateDataType,"RedisModuleType* RedisModule_CreateDataType (RedisModuleCtx*,char*,int,RedisModuleTypeMethods*)",redismodule.h,"RedisModuleType * (*RedisModule_CreateDataType)(RedisModuleCtx *ctx, const char *name, int encver, RedisModuleTypeMethods *typemethods) REDISMODULE_ATTR;",1103.0,1103.0,33.0,151.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,RedisModuleType*
5638,315742,RedisModule_ModuleTypeSetValue,1,RedisModule_ModuleTypeSetValue,"int RedisModule_ModuleTypeSetValue (RedisModuleKey*,RedisModuleType*,void*)",redismodule.h,"int (*RedisModule_ModuleTypeSetValue)(RedisModuleKey *key, RedisModuleType *mt, void *value) REDISMODULE_ATTR;",1104.0,1104.0,21.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
5639,315749,RedisModule_ModuleTypeReplaceValue,1,RedisModule_ModuleTypeReplaceValue,"int RedisModule_ModuleTypeReplaceValue (RedisModuleKey*,RedisModuleType*,void*,void**)",redismodule.h,"int (*RedisModule_ModuleTypeReplaceValue)(RedisModuleKey *key, RedisModuleType *mt, void *new_value, void **old_value) REDISMODULE_ATTR;",1105.0,1105.0,21.0,134.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5640,315757,RedisModule_ModuleTypeGetType,1,RedisModule_ModuleTypeGetType,RedisModuleType* RedisModule_ModuleTypeGetType (RedisModuleKey*),redismodule.h,RedisModuleType * (*RedisModule_ModuleTypeGetType)(RedisModuleKey *key) REDISMODULE_ATTR;,1106.0,1106.0,33.0,87.0,1.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,RedisModuleType*
5641,315762,RedisModule_ModuleTypeGetValue,1,RedisModule_ModuleTypeGetValue,void* RedisModule_ModuleTypeGetValue (RedisModuleKey*),redismodule.h,void * (*RedisModule_ModuleTypeGetValue)(RedisModuleKey *key) REDISMODULE_ATTR;,1107.0,1107.0,22.0,77.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void*
5642,315767,RedisModule_IsIOError,1,RedisModule_IsIOError,int RedisModule_IsIOError (RedisModuleIO*),redismodule.h,int (*RedisModule_IsIOError)(RedisModuleIO *io) REDISMODULE_ATTR;,1108.0,1108.0,21.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5643,315772,RedisModule_SetModuleOptions,1,RedisModule_SetModuleOptions,"void RedisModule_SetModuleOptions (RedisModuleCtx*,int)",redismodule.h,"void (*RedisModule_SetModuleOptions)(RedisModuleCtx *ctx, int options) REDISMODULE_ATTR;",1109.0,1109.0,22.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5644,315778,RedisModule_SignalModifiedKey,1,RedisModule_SignalModifiedKey,"int RedisModule_SignalModifiedKey (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"int (*RedisModule_SignalModifiedKey)(RedisModuleCtx *ctx, RedisModuleString *keyname) REDISMODULE_ATTR;",1110.0,1110.0,21.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5645,315784,RedisModule_SaveUnsigned,1,RedisModule_SaveUnsigned,"void RedisModule_SaveUnsigned (RedisModuleIO*,uint64_t)",redismodule.h,"void (*RedisModule_SaveUnsigned)(RedisModuleIO *io, uint64_t value) REDISMODULE_ATTR;",1111.0,1111.0,22.0,83.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5646,315790,RedisModule_LoadUnsigned,1,RedisModule_LoadUnsigned,uint64_t RedisModule_LoadUnsigned (RedisModuleIO*),redismodule.h,uint64_t (*RedisModule_LoadUnsigned)(RedisModuleIO *io) REDISMODULE_ATTR;,1112.0,1112.0,26.0,71.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
5647,315795,RedisModule_SaveSigned,1,RedisModule_SaveSigned,"void RedisModule_SaveSigned (RedisModuleIO*,int64_t)",redismodule.h,"void (*RedisModule_SaveSigned)(RedisModuleIO *io, int64_t value) REDISMODULE_ATTR;",1113.0,1113.0,22.0,80.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5648,315801,RedisModule_LoadSigned,1,RedisModule_LoadSigned,int64_t RedisModule_LoadSigned (RedisModuleIO*),redismodule.h,int64_t (*RedisModule_LoadSigned)(RedisModuleIO *io) REDISMODULE_ATTR;,1114.0,1114.0,25.0,68.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int64_t
5649,315806,RedisModule_EmitAOF,1,RedisModule_EmitAOF,"void RedisModule_EmitAOF (RedisModuleIO*,char*,char*...)",redismodule.h,"void (*RedisModule_EmitAOF)(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",1115.0,1115.0,22.0,105.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
5650,315813,RedisModule_SaveString,1,RedisModule_SaveString,"void RedisModule_SaveString (RedisModuleIO*,RedisModuleString*)",redismodule.h,"void (*RedisModule_SaveString)(RedisModuleIO *io, RedisModuleString *s) REDISMODULE_ATTR;",1116.0,1116.0,22.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5651,315819,RedisModule_SaveStringBuffer,1,RedisModule_SaveStringBuffer,"void RedisModule_SaveStringBuffer (RedisModuleIO*,char*,size_t)",redismodule.h,"void (*RedisModule_SaveStringBuffer)(RedisModuleIO *io, const char *str, size_t len) REDISMODULE_ATTR;",1117.0,1117.0,22.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5652,315826,RedisModule_LoadString,1,RedisModule_LoadString,RedisModuleString* RedisModule_LoadString (RedisModuleIO*),redismodule.h,RedisModuleString * (*RedisModule_LoadString)(RedisModuleIO *io) REDISMODULE_ATTR;,1118.0,1118.0,35.0,80.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5653,315831,RedisModule_LoadStringBuffer,1,RedisModule_LoadStringBuffer,"char* RedisModule_LoadStringBuffer (RedisModuleIO*,size_t*)",redismodule.h,"char * (*RedisModule_LoadStringBuffer)(RedisModuleIO *io, size_t *lenptr) REDISMODULE_ATTR;",1119.0,1119.0,22.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
5654,315837,RedisModule_SaveDouble,1,RedisModule_SaveDouble,"void RedisModule_SaveDouble (RedisModuleIO*,double)",redismodule.h,"void (*RedisModule_SaveDouble)(RedisModuleIO *io, double value) REDISMODULE_ATTR;",1120.0,1120.0,22.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5655,315843,RedisModule_LoadDouble,1,RedisModule_LoadDouble,double RedisModule_LoadDouble (RedisModuleIO*),redismodule.h,double (*RedisModule_LoadDouble)(RedisModuleIO *io) REDISMODULE_ATTR;,1121.0,1121.0,24.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,double
5656,315848,RedisModule_SaveFloat,1,RedisModule_SaveFloat,"void RedisModule_SaveFloat (RedisModuleIO*,float)",redismodule.h,"void (*RedisModule_SaveFloat)(RedisModuleIO *io, float value) REDISMODULE_ATTR;",1122.0,1122.0,22.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5657,315854,RedisModule_LoadFloat,1,RedisModule_LoadFloat,float RedisModule_LoadFloat (RedisModuleIO*),redismodule.h,float (*RedisModule_LoadFloat)(RedisModuleIO *io) REDISMODULE_ATTR;,1123.0,1123.0,23.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,float
5658,315859,RedisModule_SaveLongDouble,1,RedisModule_SaveLongDouble,"void RedisModule_SaveLongDouble (RedisModuleIO*,long double)",redismodule.h,"void (*RedisModule_SaveLongDouble)(RedisModuleIO *io, long double value) REDISMODULE_ATTR;",1124.0,1124.0,22.0,88.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5659,315865,RedisModule_LoadLongDouble,1,RedisModule_LoadLongDouble,long double RedisModule_LoadLongDouble (RedisModuleIO*),redismodule.h,long double (*RedisModule_LoadLongDouble)(RedisModuleIO *io) REDISMODULE_ATTR;,1125.0,1125.0,29.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,long double
5660,315870,RedisModule_LoadDataTypeFromString,1,RedisModule_LoadDataTypeFromString,"void* RedisModule_LoadDataTypeFromString (RedisModuleString*,RedisModuleType*)",redismodule.h,"void * (*RedisModule_LoadDataTypeFromString)(const RedisModuleString *str, const RedisModuleType *mt) REDISMODULE_ATTR;",1126.0,1126.0,22.0,117.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5661,315876,RedisModule_LoadDataTypeFromStringEncver,1,RedisModule_LoadDataTypeFromStringEncver,"void* RedisModule_LoadDataTypeFromStringEncver (RedisModuleString*,RedisModuleType*,int)",redismodule.h,"void * (*RedisModule_LoadDataTypeFromStringEncver)(const RedisModuleString *str, const RedisModuleType *mt, int encver) REDISMODULE_ATTR;",1127.0,1127.0,22.0,135.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void*
5662,315883,RedisModule_SaveDataTypeToString,1,RedisModule_SaveDataTypeToString,"RedisModuleString* RedisModule_SaveDataTypeToString (RedisModuleCtx*,void*,RedisModuleType*)",redismodule.h,"RedisModuleString * (*RedisModule_SaveDataTypeToString)(RedisModuleCtx *ctx, void *data, const RedisModuleType *mt) REDISMODULE_ATTR;",1128.0,1128.0,35.0,131.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleString*
5663,315890,RedisModule_Log,1,RedisModule_Log,"void RedisModule_Log (RedisModuleCtx*,char*,char*...)",redismodule.h,"void (*RedisModule_Log)(RedisModuleCtx *ctx, const char *level, const char *fmt, ...) REDISMODULE_ATTR REDISMODULE_ATTR_PRINTF(3,4);",1129.0,1129.0,22.0,101.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
5664,315897,RedisModule_LogIOError,1,RedisModule_LogIOError,"void RedisModule_LogIOError (RedisModuleIO*,char*,char*...)",redismodule.h,"void (*RedisModule_LogIOError)(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) REDISMODULE_ATTR REDISMODULE_ATTR_PRINTF(3,4);",1130.0,1130.0,22.0,109.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5665,315904,RedisModule__Assert,1,RedisModule__Assert,"void RedisModule__Assert (char*,char*,int)",redismodule.h,"void (*RedisModule__Assert)(const char *estr, const char *file, int line) REDISMODULE_ATTR;",1131.0,1131.0,22.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5666,315911,RedisModule_LatencyAddSample,1,RedisModule_LatencyAddSample,"void RedisModule_LatencyAddSample (char*,mstime_t)",redismodule.h,"void (*RedisModule_LatencyAddSample)(const char *event, mstime_t latency) REDISMODULE_ATTR;",1132.0,1132.0,22.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5667,315917,RedisModule_StringAppendBuffer,1,RedisModule_StringAppendBuffer,"int RedisModule_StringAppendBuffer (RedisModuleCtx*,RedisModuleString*,char*,size_t)",redismodule.h,"int (*RedisModule_StringAppendBuffer)(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) REDISMODULE_ATTR;",1133.0,1133.0,21.0,127.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5668,315925,RedisModule_TrimStringAllocation,1,RedisModule_TrimStringAllocation,void RedisModule_TrimStringAllocation (RedisModuleString*),redismodule.h,void (*RedisModule_TrimStringAllocation)(RedisModuleString *str) REDISMODULE_ATTR;,1134.0,1134.0,22.0,80.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5669,315930,RedisModule_RetainString,1,RedisModule_RetainString,"void RedisModule_RetainString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"void (*RedisModule_RetainString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1135.0,1135.0,22.0,93.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5670,315936,RedisModule_HoldString,1,RedisModule_HoldString,"RedisModuleString* RedisModule_HoldString (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"RedisModuleString * (*RedisModule_HoldString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1136.0,1136.0,35.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5671,315942,RedisModule_StringCompare,1,RedisModule_StringCompare,"int RedisModule_StringCompare (RedisModuleString*,RedisModuleString*)",redismodule.h,"int (*RedisModule_StringCompare)(const RedisModuleString *a, const RedisModuleString *b) REDISMODULE_ATTR;",1137.0,1137.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5672,315948,RedisModule_GetContextFromIO,1,RedisModule_GetContextFromIO,RedisModuleCtx* RedisModule_GetContextFromIO (RedisModuleIO*),redismodule.h,RedisModuleCtx * (*RedisModule_GetContextFromIO)(RedisModuleIO *io) REDISMODULE_ATTR;,1138.0,1138.0,32.0,83.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleCtx*
5673,315953,RedisModule_GetKeyNameFromIO,1,RedisModule_GetKeyNameFromIO,RedisModuleString* RedisModule_GetKeyNameFromIO (RedisModuleIO*),redismodule.h,const RedisModuleString * (*RedisModule_GetKeyNameFromIO)(RedisModuleIO *io) REDISMODULE_ATTR;,1139.0,1139.0,41.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5674,315958,RedisModule_GetKeyNameFromModuleKey,1,RedisModule_GetKeyNameFromModuleKey,RedisModuleString* RedisModule_GetKeyNameFromModuleKey (RedisModuleKey*),redismodule.h,const RedisModuleString * (*RedisModule_GetKeyNameFromModuleKey)(RedisModuleKey *key) REDISMODULE_ATTR;,1140.0,1140.0,41.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5675,315963,RedisModule_GetDbIdFromModuleKey,1,RedisModule_GetDbIdFromModuleKey,int RedisModule_GetDbIdFromModuleKey (RedisModuleKey*),redismodule.h,int (*RedisModule_GetDbIdFromModuleKey)(RedisModuleKey *key) REDISMODULE_ATTR;,1141.0,1141.0,21.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5676,315968,RedisModule_GetDbIdFromIO,1,RedisModule_GetDbIdFromIO,int RedisModule_GetDbIdFromIO (RedisModuleIO*),redismodule.h,int (*RedisModule_GetDbIdFromIO)(RedisModuleIO *io) REDISMODULE_ATTR;,1142.0,1142.0,21.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5677,315973,RedisModule_GetDbIdFromOptCtx,1,RedisModule_GetDbIdFromOptCtx,int RedisModule_GetDbIdFromOptCtx (RedisModuleKeyOptCtx*),redismodule.h,int (*RedisModule_GetDbIdFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,1143.0,1143.0,21.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5678,315978,RedisModule_GetToDbIdFromOptCtx,1,RedisModule_GetToDbIdFromOptCtx,int RedisModule_GetToDbIdFromOptCtx (RedisModuleKeyOptCtx*),redismodule.h,int (*RedisModule_GetToDbIdFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,1144.0,1144.0,21.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5679,315983,RedisModule_GetKeyNameFromOptCtx,1,RedisModule_GetKeyNameFromOptCtx,RedisModuleString* RedisModule_GetKeyNameFromOptCtx (RedisModuleKeyOptCtx*),redismodule.h,const RedisModuleString * (*RedisModule_GetKeyNameFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,1145.0,1145.0,41.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5680,315988,RedisModule_GetToKeyNameFromOptCtx,1,RedisModule_GetToKeyNameFromOptCtx,RedisModuleString* RedisModule_GetToKeyNameFromOptCtx (RedisModuleKeyOptCtx*),redismodule.h,const RedisModuleString * (*RedisModule_GetToKeyNameFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,1146.0,1146.0,41.0,106.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5681,315993,RedisModule_Milliseconds,1,RedisModule_Milliseconds,mstime_t RedisModule_Milliseconds (void),redismodule.h,mstime_t (*RedisModule_Milliseconds)(void) REDISMODULE_ATTR;,1147.0,1147.0,26.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,mstime_t
5682,315998,RedisModule_MonotonicMicroseconds,1,RedisModule_MonotonicMicroseconds,uint64_t RedisModule_MonotonicMicroseconds (void),redismodule.h,uint64_t (*RedisModule_MonotonicMicroseconds)(void) REDISMODULE_ATTR;,1148.0,1148.0,26.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
5683,316003,RedisModule_Microseconds,1,RedisModule_Microseconds,ustime_t RedisModule_Microseconds (void),redismodule.h,ustime_t (*RedisModule_Microseconds)(void) REDISMODULE_ATTR;,1149.0,1149.0,26.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ustime_t
5684,316008,RedisModule_CachedMicroseconds,1,RedisModule_CachedMicroseconds,ustime_t RedisModule_CachedMicroseconds (void),redismodule.h,ustime_t (*RedisModule_CachedMicroseconds)(void) REDISMODULE_ATTR;,1150.0,1150.0,26.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,ustime_t
5685,316013,RedisModule_DigestAddStringBuffer,1,RedisModule_DigestAddStringBuffer,"void RedisModule_DigestAddStringBuffer (RedisModuleDigest*,char*,size_t)",redismodule.h,"void (*RedisModule_DigestAddStringBuffer)(RedisModuleDigest *md, const char *ele, size_t len) REDISMODULE_ATTR;",1151.0,1151.0,22.0,109.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5686,316020,RedisModule_DigestAddLongLong,1,RedisModule_DigestAddLongLong,"void RedisModule_DigestAddLongLong (RedisModuleDigest*,long long)",redismodule.h,"void (*RedisModule_DigestAddLongLong)(RedisModuleDigest *md, long long ele) REDISMODULE_ATTR;",1152.0,1152.0,22.0,91.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5687,316026,RedisModule_DigestEndSequence,1,RedisModule_DigestEndSequence,void RedisModule_DigestEndSequence (RedisModuleDigest*),redismodule.h,void (*RedisModule_DigestEndSequence)(RedisModuleDigest *md) REDISMODULE_ATTR;,1153.0,1153.0,22.0,76.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5688,316031,RedisModule_GetDbIdFromDigest,1,RedisModule_GetDbIdFromDigest,int RedisModule_GetDbIdFromDigest (RedisModuleDigest*),redismodule.h,int (*RedisModule_GetDbIdFromDigest)(RedisModuleDigest *dig) REDISMODULE_ATTR;,1154.0,1154.0,21.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5689,316036,RedisModule_GetKeyNameFromDigest,1,RedisModule_GetKeyNameFromDigest,RedisModuleString* RedisModule_GetKeyNameFromDigest (RedisModuleDigest*),redismodule.h,const RedisModuleString * (*RedisModule_GetKeyNameFromDigest)(RedisModuleDigest *dig) REDISMODULE_ATTR;,1155.0,1155.0,41.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5690,316041,RedisModule_CreateDict,1,RedisModule_CreateDict,RedisModuleDict* RedisModule_CreateDict (RedisModuleCtx*),redismodule.h,RedisModuleDict * (*RedisModule_CreateDict)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1156.0,1156.0,33.0,80.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleDict*
5691,316046,RedisModule_FreeDict,1,RedisModule_FreeDict,"void RedisModule_FreeDict (RedisModuleCtx*,RedisModuleDict*)",redismodule.h,"void (*RedisModule_FreeDict)(RedisModuleCtx *ctx, RedisModuleDict *d) REDISMODULE_ATTR;",1157.0,1157.0,22.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5692,316052,RedisModule_DictSize,1,RedisModule_DictSize,uint64_t RedisModule_DictSize (RedisModuleDict*),redismodule.h,uint64_t (*RedisModule_DictSize)(RedisModuleDict *d) REDISMODULE_ATTR;,1158.0,1158.0,26.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,uint64_t
5693,316057,RedisModule_DictSetC,1,RedisModule_DictSetC,"int RedisModule_DictSetC (RedisModuleDict*,void*,size_t,void*)",redismodule.h,"int (*RedisModule_DictSetC)(RedisModuleDict *d, void *key, size_t keylen, void *ptr) REDISMODULE_ATTR;",1159.0,1159.0,21.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5694,316065,RedisModule_DictReplaceC,1,RedisModule_DictReplaceC,"int RedisModule_DictReplaceC (RedisModuleDict*,void*,size_t,void*)",redismodule.h,"int (*RedisModule_DictReplaceC)(RedisModuleDict *d, void *key, size_t keylen, void *ptr) REDISMODULE_ATTR;",1160.0,1160.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5695,316073,RedisModule_DictSet,1,RedisModule_DictSet,"int RedisModule_DictSet (RedisModuleDict*,RedisModuleString*,void*)",redismodule.h,"int (*RedisModule_DictSet)(RedisModuleDict *d, RedisModuleString *key, void *ptr) REDISMODULE_ATTR;",1161.0,1161.0,21.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
5696,316080,RedisModule_DictReplace,1,RedisModule_DictReplace,"int RedisModule_DictReplace (RedisModuleDict*,RedisModuleString*,void*)",redismodule.h,"int (*RedisModule_DictReplace)(RedisModuleDict *d, RedisModuleString *key, void *ptr) REDISMODULE_ATTR;",1162.0,1162.0,21.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5697,316087,RedisModule_DictGetC,1,RedisModule_DictGetC,"void* RedisModule_DictGetC (RedisModuleDict*,void*,size_t,int*)",redismodule.h,"void * (*RedisModule_DictGetC)(RedisModuleDict *d, void *key, size_t keylen, int *nokey) REDISMODULE_ATTR;",1163.0,1163.0,22.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void*
5698,316095,RedisModule_DictGet,1,RedisModule_DictGet,"void* RedisModule_DictGet (RedisModuleDict*,RedisModuleString*,int*)",redismodule.h,"void * (*RedisModule_DictGet)(RedisModuleDict *d, RedisModuleString *key, int *nokey) REDISMODULE_ATTR;",1164.0,1164.0,22.0,101.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void*
5699,316102,RedisModule_DictDelC,1,RedisModule_DictDelC,"int RedisModule_DictDelC (RedisModuleDict*,void*,size_t,void*)",redismodule.h,"int (*RedisModule_DictDelC)(RedisModuleDict *d, void *key, size_t keylen, void *oldval) REDISMODULE_ATTR;",1165.0,1165.0,21.0,103.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5700,316110,RedisModule_DictDel,1,RedisModule_DictDel,"int RedisModule_DictDel (RedisModuleDict*,RedisModuleString*,void*)",redismodule.h,"int (*RedisModule_DictDel)(RedisModuleDict *d, RedisModuleString *key, void *oldval) REDISMODULE_ATTR;",1166.0,1166.0,21.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5701,316117,RedisModule_DictIteratorStartC,1,RedisModule_DictIteratorStartC,"RedisModuleDictIter* RedisModule_DictIteratorStartC (RedisModuleDict*,char*,void*,size_t)",redismodule.h,"RedisModuleDictIter * (*RedisModule_DictIteratorStartC)(RedisModuleDict *d, const char *op, void *key, size_t keylen) REDISMODULE_ATTR;",1167.0,1167.0,37.0,133.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,RedisModuleDictIter*
5702,316125,RedisModule_DictIteratorStart,1,RedisModule_DictIteratorStart,"RedisModuleDictIter* RedisModule_DictIteratorStart (RedisModuleDict*,char*,RedisModuleString*)",redismodule.h,"RedisModuleDictIter * (*RedisModule_DictIteratorStart)(RedisModuleDict *d, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",1168.0,1168.0,37.0,130.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,RedisModuleDictIter*
5703,316132,RedisModule_DictIteratorStop,1,RedisModule_DictIteratorStop,void RedisModule_DictIteratorStop (RedisModuleDictIter*),redismodule.h,void (*RedisModule_DictIteratorStop)(RedisModuleDictIter *di) REDISMODULE_ATTR;,1169.0,1169.0,22.0,77.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5704,316137,RedisModule_DictIteratorReseekC,1,RedisModule_DictIteratorReseekC,"int RedisModule_DictIteratorReseekC (RedisModuleDictIter*,char*,void*,size_t)",redismodule.h,"int (*RedisModule_DictIteratorReseekC)(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) REDISMODULE_ATTR;",1170.0,1170.0,21.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5705,316145,RedisModule_DictIteratorReseek,1,RedisModule_DictIteratorReseek,"int RedisModule_DictIteratorReseek (RedisModuleDictIter*,char*,RedisModuleString*)",redismodule.h,"int (*RedisModule_DictIteratorReseek)(RedisModuleDictIter *di, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",1171.0,1171.0,21.0,118.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5706,316152,RedisModule_DictNextC,1,RedisModule_DictNextC,"void* RedisModule_DictNextC (RedisModuleDictIter*,size_t*,void**)",redismodule.h,"void * (*RedisModule_DictNextC)(RedisModuleDictIter *di, size_t *keylen, void **dataptr) REDISMODULE_ATTR;",1172.0,1172.0,22.0,104.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void*
5707,316159,RedisModule_DictPrevC,1,RedisModule_DictPrevC,"void* RedisModule_DictPrevC (RedisModuleDictIter*,size_t*,void**)",redismodule.h,"void * (*RedisModule_DictPrevC)(RedisModuleDictIter *di, size_t *keylen, void **dataptr) REDISMODULE_ATTR;",1173.0,1173.0,22.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void*
5708,316166,RedisModule_DictNext,1,RedisModule_DictNext,"RedisModuleString* RedisModule_DictNext (RedisModuleCtx*,RedisModuleDictIter*,void**)",redismodule.h,"RedisModuleString * (*RedisModule_DictNext)(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) REDISMODULE_ATTR;",1174.0,1174.0,35.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleString*
5709,316173,RedisModule_DictPrev,1,RedisModule_DictPrev,"RedisModuleString* RedisModule_DictPrev (RedisModuleCtx*,RedisModuleDictIter*,void**)",redismodule.h,"RedisModuleString * (*RedisModule_DictPrev)(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) REDISMODULE_ATTR;",1175.0,1175.0,35.0,121.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleString*
5710,316180,RedisModule_DictCompareC,1,RedisModule_DictCompareC,"int RedisModule_DictCompareC (RedisModuleDictIter*,char*,void*,size_t)",redismodule.h,"int (*RedisModule_DictCompareC)(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) REDISMODULE_ATTR;",1176.0,1176.0,21.0,114.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5711,316188,RedisModule_DictCompare,1,RedisModule_DictCompare,"int RedisModule_DictCompare (RedisModuleDictIter*,char*,RedisModuleString*)",redismodule.h,"int (*RedisModule_DictCompare)(RedisModuleDictIter *di, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",1177.0,1177.0,21.0,111.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
5712,316195,RedisModule_RegisterInfoFunc,1,RedisModule_RegisterInfoFunc,"int RedisModule_RegisterInfoFunc (RedisModuleCtx*,RedisModuleInfoFunc)",redismodule.h,"int (*RedisModule_RegisterInfoFunc)(RedisModuleCtx *ctx, RedisModuleInfoFunc cb) REDISMODULE_ATTR;",1178.0,1178.0,21.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5713,316201,RedisModule_RegisterAuthCallback,1,RedisModule_RegisterAuthCallback,"void RedisModule_RegisterAuthCallback (RedisModuleCtx*,RedisModuleAuthCallback)",redismodule.h,"void (*RedisModule_RegisterAuthCallback)(RedisModuleCtx *ctx, RedisModuleAuthCallback cb) REDISMODULE_ATTR;",1179.0,1179.0,22.0,105.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5714,316207,RedisModule_InfoAddSection,1,RedisModule_InfoAddSection,"int RedisModule_InfoAddSection (RedisModuleInfoCtx*,char*)",redismodule.h,"int (*RedisModule_InfoAddSection)(RedisModuleInfoCtx *ctx, const char *name) REDISMODULE_ATTR;",1180.0,1180.0,21.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5715,316213,RedisModule_InfoBeginDictField,1,RedisModule_InfoBeginDictField,"int RedisModule_InfoBeginDictField (RedisModuleInfoCtx*,char*)",redismodule.h,"int (*RedisModule_InfoBeginDictField)(RedisModuleInfoCtx *ctx, const char *name) REDISMODULE_ATTR;",1181.0,1181.0,21.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5716,316219,RedisModule_InfoEndDictField,1,RedisModule_InfoEndDictField,int RedisModule_InfoEndDictField (RedisModuleInfoCtx*),redismodule.h,int (*RedisModule_InfoEndDictField)(RedisModuleInfoCtx *ctx) REDISMODULE_ATTR;,1182.0,1182.0,21.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5717,316224,RedisModule_InfoAddFieldString,1,RedisModule_InfoAddFieldString,"int RedisModule_InfoAddFieldString (RedisModuleInfoCtx*,char*,RedisModuleString*)",redismodule.h,"int (*RedisModule_InfoAddFieldString)(RedisModuleInfoCtx *ctx, const char *field, RedisModuleString *value) REDISMODULE_ATTR;",1183.0,1183.0,21.0,123.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5718,316231,RedisModule_InfoAddFieldCString,1,RedisModule_InfoAddFieldCString,"int RedisModule_InfoAddFieldCString (RedisModuleInfoCtx*,char*,char*)",redismodule.h,"int (*RedisModule_InfoAddFieldCString)(RedisModuleInfoCtx *ctx, const char *field,const  char *value) REDISMODULE_ATTR;",1184.0,1184.0,21.0,117.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5719,316238,RedisModule_InfoAddFieldDouble,1,RedisModule_InfoAddFieldDouble,"int RedisModule_InfoAddFieldDouble (RedisModuleInfoCtx*,char*,double)",redismodule.h,"int (*RedisModule_InfoAddFieldDouble)(RedisModuleInfoCtx *ctx, const char *field, double value) REDISMODULE_ATTR;",1185.0,1185.0,21.0,111.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5720,316245,RedisModule_InfoAddFieldLongLong,1,RedisModule_InfoAddFieldLongLong,"int RedisModule_InfoAddFieldLongLong (RedisModuleInfoCtx*,char*,long long)",redismodule.h,"int (*RedisModule_InfoAddFieldLongLong)(RedisModuleInfoCtx *ctx, const char *field, long long value) REDISMODULE_ATTR;",1186.0,1186.0,21.0,116.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5721,316252,RedisModule_InfoAddFieldULongLong,1,RedisModule_InfoAddFieldULongLong,"int RedisModule_InfoAddFieldULongLong (RedisModuleInfoCtx*,char*,long long unsigned)",redismodule.h,"int (*RedisModule_InfoAddFieldULongLong)(RedisModuleInfoCtx *ctx, const char *field, unsigned long long value) REDISMODULE_ATTR;",1187.0,1187.0,21.0,126.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5722,316259,RedisModule_GetServerInfo,1,RedisModule_GetServerInfo,"RedisModuleServerInfoData* RedisModule_GetServerInfo (RedisModuleCtx*,char*)",redismodule.h,"RedisModuleServerInfoData * (*RedisModule_GetServerInfo)(RedisModuleCtx *ctx, const char *section) REDISMODULE_ATTR;",1188.0,1188.0,43.0,114.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleServerInfoData*
5723,316265,RedisModule_FreeServerInfo,1,RedisModule_FreeServerInfo,"void RedisModule_FreeServerInfo (RedisModuleCtx*,RedisModuleServerInfoData*)",redismodule.h,"void (*RedisModule_FreeServerInfo)(RedisModuleCtx *ctx, RedisModuleServerInfoData *data) REDISMODULE_ATTR;",1189.0,1189.0,22.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5724,316271,RedisModule_ServerInfoGetField,1,RedisModule_ServerInfoGetField,"RedisModuleString* RedisModule_ServerInfoGetField (RedisModuleCtx*,RedisModuleServerInfoData*,char*)",redismodule.h,"RedisModuleString * (*RedisModule_ServerInfoGetField)(RedisModuleCtx *ctx, RedisModuleServerInfoData *data, const char* field) REDISMODULE_ATTR;",1190.0,1190.0,35.0,142.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleString*
5725,316278,RedisModule_ServerInfoGetFieldC,1,RedisModule_ServerInfoGetFieldC,"char* RedisModule_ServerInfoGetFieldC (RedisModuleServerInfoData*,char*)",redismodule.h,"const char * (*RedisModule_ServerInfoGetFieldC)(RedisModuleServerInfoData *data, const char* field) REDISMODULE_ATTR;",1191.0,1191.0,28.0,115.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,char*
5726,316284,RedisModule_ServerInfoGetFieldSigned,1,RedisModule_ServerInfoGetFieldSigned,"long long RedisModule_ServerInfoGetFieldSigned (RedisModuleServerInfoData*,char*,int*)",redismodule.h,"long long (*RedisModule_ServerInfoGetFieldSigned)(RedisModuleServerInfoData *data, const char* field, int *out_err) REDISMODULE_ATTR;",1192.0,1192.0,27.0,131.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,long long
5727,316291,RedisModule_ServerInfoGetFieldUnsigned,1,RedisModule_ServerInfoGetFieldUnsigned,"long long unsigned RedisModule_ServerInfoGetFieldUnsigned (RedisModuleServerInfoData*,char*,int*)",redismodule.h,"unsigned long long (*RedisModule_ServerInfoGetFieldUnsigned)(RedisModuleServerInfoData *data, const char* field, int *out_err) REDISMODULE_ATTR;",1193.0,1193.0,36.0,142.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,long long unsigned
5728,316298,RedisModule_ServerInfoGetFieldDouble,1,RedisModule_ServerInfoGetFieldDouble,"double RedisModule_ServerInfoGetFieldDouble (RedisModuleServerInfoData*,char*,int*)",redismodule.h,"double (*RedisModule_ServerInfoGetFieldDouble)(RedisModuleServerInfoData *data, const char* field, int *out_err) REDISMODULE_ATTR;",1194.0,1194.0,24.0,128.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,double
5729,316305,RedisModule_SubscribeToServerEvent,1,RedisModule_SubscribeToServerEvent,"int RedisModule_SubscribeToServerEvent (RedisModuleCtx*,RedisModuleEvent,RedisModuleEventCallback)",redismodule.h,"int (*RedisModule_SubscribeToServerEvent)(RedisModuleCtx *ctx, RedisModuleEvent event, RedisModuleEventCallback callback) REDISMODULE_ATTR;",1195.0,1195.0,21.0,137.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5730,316312,RedisModule_SetLRU,1,RedisModule_SetLRU,"int RedisModule_SetLRU (RedisModuleKey*,mstime_t)",redismodule.h,"int (*RedisModule_SetLRU)(RedisModuleKey *key, mstime_t lru_idle) REDISMODULE_ATTR;",1196.0,1196.0,21.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5731,316318,RedisModule_GetLRU,1,RedisModule_GetLRU,"int RedisModule_GetLRU (RedisModuleKey*,mstime_t*)",redismodule.h,"int (*RedisModule_GetLRU)(RedisModuleKey *key, mstime_t *lru_idle) REDISMODULE_ATTR;",1197.0,1197.0,21.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5732,316324,RedisModule_SetLFU,1,RedisModule_SetLFU,"int RedisModule_SetLFU (RedisModuleKey*,long long)",redismodule.h,"int (*RedisModule_SetLFU)(RedisModuleKey *key, long long lfu_freq) REDISMODULE_ATTR;",1198.0,1198.0,21.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5733,316330,RedisModule_GetLFU,1,RedisModule_GetLFU,"int RedisModule_GetLFU (RedisModuleKey*,long long*)",redismodule.h,"int (*RedisModule_GetLFU)(RedisModuleKey *key, long long *lfu_freq) REDISMODULE_ATTR;",1199.0,1199.0,21.0,83.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5734,316336,RedisModule_BlockClientOnKeys,1,RedisModule_BlockClientOnKeys,"RedisModuleBlockedClient* RedisModule_BlockClientOnKeys (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,RedisModuleString**,int,void*)",redismodule.h,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnKeys)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) REDISMODULE_ATTR;",1200.0,1200.0,42.0,291.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,16,8,8,RedisModuleBlockedClient*
5735,316348,RedisModule_BlockClientOnKeysWithFlags,1,RedisModule_BlockClientOnKeysWithFlags,"RedisModuleBlockedClient* RedisModule_BlockClientOnKeysWithFlags (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,RedisModuleString**,int,void*,int)",redismodule.h,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnKeysWithFlags)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata, int flags) REDISMODULE_ATTR;",1201.0,1201.0,42.0,311.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,18,9,9,RedisModuleBlockedClient*
5736,316361,RedisModule_SignalKeyAsReady,1,RedisModule_SignalKeyAsReady,"void RedisModule_SignalKeyAsReady (RedisModuleCtx*,RedisModuleString*)",redismodule.h,"void (*RedisModule_SignalKeyAsReady)(RedisModuleCtx *ctx, RedisModuleString *key) REDISMODULE_ATTR;",1202.0,1202.0,22.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5737,316367,RedisModule_GetBlockedClientReadyKey,1,RedisModule_GetBlockedClientReadyKey,RedisModuleString* RedisModule_GetBlockedClientReadyKey (RedisModuleCtx*),redismodule.h,RedisModuleString * (*RedisModule_GetBlockedClientReadyKey)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1203.0,1203.0,35.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5738,316372,RedisModule_ScanCursorCreate,1,RedisModule_ScanCursorCreate,RedisModuleScanCursor* RedisModule_ScanCursorCreate (void),redismodule.h,RedisModuleScanCursor * (*RedisModule_ScanCursorCreate)(void) REDISMODULE_ATTR;,1204.0,1204.0,39.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleScanCursor*
5739,316377,RedisModule_ScanCursorRestart,1,RedisModule_ScanCursorRestart,void RedisModule_ScanCursorRestart (RedisModuleScanCursor*),redismodule.h,void (*RedisModule_ScanCursorRestart)(RedisModuleScanCursor *cursor) REDISMODULE_ATTR;,1205.0,1205.0,22.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5740,316382,RedisModule_ScanCursorDestroy,1,RedisModule_ScanCursorDestroy,void RedisModule_ScanCursorDestroy (RedisModuleScanCursor*),redismodule.h,void (*RedisModule_ScanCursorDestroy)(RedisModuleScanCursor *cursor) REDISMODULE_ATTR;,1206.0,1206.0,22.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5741,316387,RedisModule_Scan,1,RedisModule_Scan,"int RedisModule_Scan (RedisModuleCtx*,RedisModuleScanCursor*,RedisModuleScanCB,void*)",redismodule.h,"int (*RedisModule_Scan)(RedisModuleCtx *ctx, RedisModuleScanCursor *cursor, RedisModuleScanCB fn, void *privdata) REDISMODULE_ATTR;",1207.0,1207.0,21.0,129.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5742,316395,RedisModule_ScanKey,1,RedisModule_ScanKey,"int RedisModule_ScanKey (RedisModuleKey*,RedisModuleScanCursor*,RedisModuleScanKeyCB,void*)",redismodule.h,"int (*RedisModule_ScanKey)(RedisModuleKey *key, RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, void *privdata) REDISMODULE_ATTR;",1208.0,1208.0,21.0,135.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5743,316403,RedisModule_GetContextFlagsAll,1,RedisModule_GetContextFlagsAll,int RedisModule_GetContextFlagsAll (void),redismodule.h,int (*RedisModule_GetContextFlagsAll)(void) REDISMODULE_ATTR;,1209.0,1209.0,21.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5744,316408,RedisModule_GetModuleOptionsAll,1,RedisModule_GetModuleOptionsAll,int RedisModule_GetModuleOptionsAll (void),redismodule.h,int (*RedisModule_GetModuleOptionsAll)(void) REDISMODULE_ATTR;,1210.0,1210.0,21.0,60.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5745,316413,RedisModule_GetKeyspaceNotificationFlagsAll,1,RedisModule_GetKeyspaceNotificationFlagsAll,int RedisModule_GetKeyspaceNotificationFlagsAll (void),redismodule.h,int (*RedisModule_GetKeyspaceNotificationFlagsAll)(void) REDISMODULE_ATTR;,1211.0,1211.0,21.0,72.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5746,316418,RedisModule_IsSubEventSupported,1,RedisModule_IsSubEventSupported,"int RedisModule_IsSubEventSupported (RedisModuleEvent,uint64_t)",redismodule.h,"int (*RedisModule_IsSubEventSupported)(RedisModuleEvent event, uint64_t subevent) REDISMODULE_ATTR;",1212.0,1212.0,21.0,97.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5747,316424,RedisModule_GetServerVersion,1,RedisModule_GetServerVersion,int RedisModule_GetServerVersion (void),redismodule.h,int (*RedisModule_GetServerVersion)(void) REDISMODULE_ATTR;,1213.0,1213.0,21.0,57.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5748,316429,RedisModule_GetTypeMethodVersion,1,RedisModule_GetTypeMethodVersion,int RedisModule_GetTypeMethodVersion (void),redismodule.h,int (*RedisModule_GetTypeMethodVersion)(void) REDISMODULE_ATTR;,1214.0,1214.0,21.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5749,316434,RedisModule_Yield,1,RedisModule_Yield,"void RedisModule_Yield (RedisModuleCtx*,int,char*)",redismodule.h,"void (*RedisModule_Yield)(RedisModuleCtx *ctx, int flags, const char *busy_reply) REDISMODULE_ATTR;",1215.0,1215.0,22.0,97.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5750,316441,RedisModule_BlockClient,1,RedisModule_BlockClient,"RedisModuleBlockedClient* RedisModule_BlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long)",redismodule.h,"RedisModuleBlockedClient * (*RedisModule_BlockClient)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) REDISMODULE_ATTR;",1216.0,1216.0,42.0,230.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,10,5,5,RedisModuleBlockedClient*
5751,316450,RedisModule_BlockClientGetPrivateData,1,RedisModule_BlockClientGetPrivateData,void* RedisModule_BlockClientGetPrivateData (RedisModuleBlockedClient*),redismodule.h,void * (*RedisModule_BlockClientGetPrivateData)(RedisModuleBlockedClient *blocked_client) REDISMODULE_ATTR;,1217.0,1217.0,22.0,105.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void*
5752,316455,RedisModule_BlockClientSetPrivateData,1,RedisModule_BlockClientSetPrivateData,"void RedisModule_BlockClientSetPrivateData (RedisModuleBlockedClient*,void*)",redismodule.h,"void (*RedisModule_BlockClientSetPrivateData)(RedisModuleBlockedClient *blocked_client, void *private_data) REDISMODULE_ATTR;",1218.0,1218.0,22.0,123.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5753,316461,RedisModule_BlockClientOnAuth,1,RedisModule_BlockClientOnAuth,"RedisModuleBlockedClient* RedisModule_BlockClientOnAuth (RedisModuleCtx*,RedisModuleAuthCallback,void)",redismodule.h,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnAuth)(RedisModuleCtx *ctx, RedisModuleAuthCallback reply_callback, void (*free_privdata)(RedisModuleCtx*,void*)) REDISMODULE_ATTR;",1219.0,1219.0,42.0,182.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleBlockedClient*
5754,316468,RedisModule_UnblockClient,1,RedisModule_UnblockClient,"int RedisModule_UnblockClient (RedisModuleBlockedClient*,void*)",redismodule.h,"int (*RedisModule_UnblockClient)(RedisModuleBlockedClient *bc, void *privdata) REDISMODULE_ATTR;",1220.0,1220.0,21.0,94.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,int
5755,316474,RedisModule_IsBlockedReplyRequest,1,RedisModule_IsBlockedReplyRequest,int RedisModule_IsBlockedReplyRequest (RedisModuleCtx*),redismodule.h,int (*RedisModule_IsBlockedReplyRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1221.0,1221.0,21.0,77.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5756,316479,RedisModule_IsBlockedTimeoutRequest,1,RedisModule_IsBlockedTimeoutRequest,int RedisModule_IsBlockedTimeoutRequest (RedisModuleCtx*),redismodule.h,int (*RedisModule_IsBlockedTimeoutRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1222.0,1222.0,21.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5757,316484,RedisModule_GetBlockedClientPrivateData,1,RedisModule_GetBlockedClientPrivateData,void* RedisModule_GetBlockedClientPrivateData (RedisModuleCtx*),redismodule.h,void * (*RedisModule_GetBlockedClientPrivateData)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1223.0,1223.0,22.0,86.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void*
5758,316489,RedisModule_GetBlockedClientHandle,1,RedisModule_GetBlockedClientHandle,RedisModuleBlockedClient* RedisModule_GetBlockedClientHandle (RedisModuleCtx*),redismodule.h,RedisModuleBlockedClient * (*RedisModule_GetBlockedClientHandle)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1224.0,1224.0,42.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleBlockedClient*
5759,316494,RedisModule_AbortBlock,1,RedisModule_AbortBlock,int RedisModule_AbortBlock (RedisModuleBlockedClient*),redismodule.h,int (*RedisModule_AbortBlock)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,1225.0,1225.0,21.0,75.0,1.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,int
5760,316499,RedisModule_BlockedClientMeasureTimeStart,1,RedisModule_BlockedClientMeasureTimeStart,int RedisModule_BlockedClientMeasureTimeStart (RedisModuleBlockedClient*),redismodule.h,int (*RedisModule_BlockedClientMeasureTimeStart)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,1226.0,1226.0,21.0,94.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5761,316504,RedisModule_BlockedClientMeasureTimeEnd,1,RedisModule_BlockedClientMeasureTimeEnd,int RedisModule_BlockedClientMeasureTimeEnd (RedisModuleBlockedClient*),redismodule.h,int (*RedisModule_BlockedClientMeasureTimeEnd)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,1227.0,1227.0,21.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5762,316509,RedisModule_GetThreadSafeContext,1,RedisModule_GetThreadSafeContext,RedisModuleCtx* RedisModule_GetThreadSafeContext (RedisModuleBlockedClient*),redismodule.h,RedisModuleCtx * (*RedisModule_GetThreadSafeContext)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,1228.0,1228.0,32.0,98.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,RedisModuleCtx*
5763,316514,RedisModule_GetDetachedThreadSafeContext,1,RedisModule_GetDetachedThreadSafeContext,RedisModuleCtx* RedisModule_GetDetachedThreadSafeContext (RedisModuleCtx*),redismodule.h,RedisModuleCtx * (*RedisModule_GetDetachedThreadSafeContext)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1229.0,1229.0,32.0,97.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleCtx*
5764,316519,RedisModule_FreeThreadSafeContext,1,RedisModule_FreeThreadSafeContext,void RedisModule_FreeThreadSafeContext (RedisModuleCtx*),redismodule.h,void (*RedisModule_FreeThreadSafeContext)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1230.0,1230.0,22.0,78.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5765,316524,RedisModule_ThreadSafeContextLock,1,RedisModule_ThreadSafeContextLock,void RedisModule_ThreadSafeContextLock (RedisModuleCtx*),redismodule.h,void (*RedisModule_ThreadSafeContextLock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1231.0,1231.0,22.0,78.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5766,316529,RedisModule_ThreadSafeContextTryLock,1,RedisModule_ThreadSafeContextTryLock,int RedisModule_ThreadSafeContextTryLock (RedisModuleCtx*),redismodule.h,int (*RedisModule_ThreadSafeContextTryLock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1232.0,1232.0,21.0,80.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5767,316534,RedisModule_ThreadSafeContextUnlock,1,RedisModule_ThreadSafeContextUnlock,void RedisModule_ThreadSafeContextUnlock (RedisModuleCtx*),redismodule.h,void (*RedisModule_ThreadSafeContextUnlock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1233.0,1233.0,22.0,80.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5768,316539,RedisModule_SubscribeToKeyspaceEvents,1,RedisModule_SubscribeToKeyspaceEvents,"int RedisModule_SubscribeToKeyspaceEvents (RedisModuleCtx*,int,RedisModuleNotificationFunc)",redismodule.h,"int (*RedisModule_SubscribeToKeyspaceEvents)(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc cb) REDISMODULE_ATTR;",1234.0,1234.0,21.0,124.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5769,316546,RedisModule_AddPostNotificationJob,1,RedisModule_AddPostNotificationJob,"int RedisModule_AddPostNotificationJob (RedisModuleCtx*,RedisModulePostNotificationJobFunc,void*,void)",redismodule.h,"int (*RedisModule_AddPostNotificationJob)(RedisModuleCtx *ctx, RedisModulePostNotificationJobFunc callback, void *pd, void (*free_pd)(void*)) REDISMODULE_ATTR;",1235.0,1235.0,21.0,157.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5770,316554,RedisModule_NotifyKeyspaceEvent,1,RedisModule_NotifyKeyspaceEvent,"int RedisModule_NotifyKeyspaceEvent (RedisModuleCtx*,int,char*,RedisModuleString*)",redismodule.h,"int (*RedisModule_NotifyKeyspaceEvent)(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key) REDISMODULE_ATTR;",1236.0,1236.0,21.0,128.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5771,316562,RedisModule_GetNotifyKeyspaceEvents,1,RedisModule_GetNotifyKeyspaceEvents,int RedisModule_GetNotifyKeyspaceEvents (void),redismodule.h,int (*RedisModule_GetNotifyKeyspaceEvents)(void) REDISMODULE_ATTR;,1237.0,1237.0,21.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5772,316567,RedisModule_BlockedClientDisconnected,1,RedisModule_BlockedClientDisconnected,int RedisModule_BlockedClientDisconnected (RedisModuleCtx*),redismodule.h,int (*RedisModule_BlockedClientDisconnected)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1238.0,1238.0,21.0,81.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5773,316572,RedisModule_RegisterClusterMessageReceiver,1,RedisModule_RegisterClusterMessageReceiver,"void RedisModule_RegisterClusterMessageReceiver (RedisModuleCtx*,uint8_t,RedisModuleClusterMessageReceiver)",redismodule.h,"void (*RedisModule_RegisterClusterMessageReceiver)(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) REDISMODULE_ATTR;",1239.0,1239.0,22.0,145.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
5774,316579,RedisModule_SendClusterMessage,1,RedisModule_SendClusterMessage,"int RedisModule_SendClusterMessage (RedisModuleCtx*,char*,uint8_t,char*,uint32_t)",redismodule.h,"int (*RedisModule_SendClusterMessage)(RedisModuleCtx *ctx, const char *target_id, uint8_t type, const char *msg, uint32_t len) REDISMODULE_ATTR;",1240.0,1240.0,21.0,142.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,int
5775,316588,RedisModule_GetClusterNodeInfo,1,RedisModule_GetClusterNodeInfo,"int RedisModule_GetClusterNodeInfo (RedisModuleCtx*,char*,char*,char*,int*,int*)",redismodule.h,"int (*RedisModule_GetClusterNodeInfo)(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) REDISMODULE_ATTR;",1241.0,1241.0,21.0,140.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
5776,316598,RedisModule_GetClusterNodesList,1,RedisModule_GetClusterNodesList,"char** RedisModule_GetClusterNodesList (RedisModuleCtx*,size_t*)",redismodule.h,"char ** (*RedisModule_GetClusterNodesList)(RedisModuleCtx *ctx, size_t *numnodes) REDISMODULE_ATTR;",1242.0,1242.0,22.0,97.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,char**
5777,316604,RedisModule_FreeClusterNodesList,1,RedisModule_FreeClusterNodesList,void RedisModule_FreeClusterNodesList (char**),redismodule.h,void (*RedisModule_FreeClusterNodesList)(char **ids) REDISMODULE_ATTR;,1243.0,1243.0,22.0,68.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5778,316609,RedisModule_CreateTimer,1,RedisModule_CreateTimer,"RedisModuleTimerID RedisModule_CreateTimer (RedisModuleCtx*,mstime_t,RedisModuleTimerProc,void*)",redismodule.h,"RedisModuleTimerID (*RedisModule_CreateTimer)(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) REDISMODULE_ATTR;",1244.0,1244.0,36.0,142.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,RedisModuleTimerID
5779,316617,RedisModule_StopTimer,1,RedisModule_StopTimer,"int RedisModule_StopTimer (RedisModuleCtx*,RedisModuleTimerID,void**)",redismodule.h,"int (*RedisModule_StopTimer)(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) REDISMODULE_ATTR;",1245.0,1245.0,21.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5780,316624,RedisModule_GetTimerInfo,1,RedisModule_GetTimerInfo,"int RedisModule_GetTimerInfo (RedisModuleCtx*,RedisModuleTimerID,uint64_t*,void**)",redismodule.h,"int (*RedisModule_GetTimerInfo)(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) REDISMODULE_ATTR;",1246.0,1246.0,21.0,125.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5781,316632,RedisModule_GetMyClusterID,1,RedisModule_GetMyClusterID,char* RedisModule_GetMyClusterID (void),redismodule.h,const char * (*RedisModule_GetMyClusterID)(void) REDISMODULE_ATTR;,1247.0,1247.0,28.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
5782,316637,RedisModule_GetClusterSize,1,RedisModule_GetClusterSize,size_t RedisModule_GetClusterSize (void),redismodule.h,size_t (*RedisModule_GetClusterSize)(void) REDISMODULE_ATTR;,1248.0,1248.0,24.0,58.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
5783,316642,RedisModule_GetRandomBytes,1,RedisModule_GetRandomBytes,"void RedisModule_GetRandomBytes (unsigned char*,size_t)",redismodule.h,"void (*RedisModule_GetRandomBytes)(unsigned char *dst, size_t len) REDISMODULE_ATTR;",1249.0,1249.0,22.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5784,316648,RedisModule_GetRandomHexChars,1,RedisModule_GetRandomHexChars,"void RedisModule_GetRandomHexChars (char*,size_t)",redismodule.h,"void (*RedisModule_GetRandomHexChars)(char *dst, size_t len) REDISMODULE_ATTR;",1250.0,1250.0,22.0,76.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5785,316654,RedisModule_SetDisconnectCallback,1,RedisModule_SetDisconnectCallback,"void RedisModule_SetDisconnectCallback (RedisModuleBlockedClient*,RedisModuleDisconnectFunc)",redismodule.h,"void (*RedisModule_SetDisconnectCallback)(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) REDISMODULE_ATTR;",1251.0,1251.0,22.0,123.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
5786,316660,RedisModule_SetClusterFlags,1,RedisModule_SetClusterFlags,"void RedisModule_SetClusterFlags (RedisModuleCtx*,uint64_t)",redismodule.h,"void (*RedisModule_SetClusterFlags)(RedisModuleCtx *ctx, uint64_t flags) REDISMODULE_ATTR;",1252.0,1252.0,22.0,88.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5787,316666,RedisModule_ExportSharedAPI,1,RedisModule_ExportSharedAPI,"int RedisModule_ExportSharedAPI (RedisModuleCtx*,char*,void*)",redismodule.h,"int (*RedisModule_ExportSharedAPI)(RedisModuleCtx *ctx, const char *apiname, void *func) REDISMODULE_ATTR;",1253.0,1253.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5788,316673,RedisModule_GetSharedAPI,1,RedisModule_GetSharedAPI,"void* RedisModule_GetSharedAPI (RedisModuleCtx*,char*)",redismodule.h,"void * (*RedisModule_GetSharedAPI)(RedisModuleCtx *ctx, const char *apiname) REDISMODULE_ATTR;",1254.0,1254.0,22.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5789,316679,RedisModule_RegisterCommandFilter,1,RedisModule_RegisterCommandFilter,"RedisModuleCommandFilter* RedisModule_RegisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilterFunc,int)",redismodule.h,"RedisModuleCommandFilter * (*RedisModule_RegisterCommandFilter)(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc cb, int flags) REDISMODULE_ATTR;",1255.0,1255.0,42.0,144.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,RedisModuleCommandFilter*
5790,316686,RedisModule_UnregisterCommandFilter,1,RedisModule_UnregisterCommandFilter,"int RedisModule_UnregisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilter*)",redismodule.h,"int (*RedisModule_UnregisterCommandFilter)(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) REDISMODULE_ATTR;",1256.0,1256.0,21.0,113.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5791,316692,RedisModule_CommandFilterArgsCount,1,RedisModule_CommandFilterArgsCount,int RedisModule_CommandFilterArgsCount (RedisModuleCommandFilterCtx*),redismodule.h,int (*RedisModule_CommandFilterArgsCount)(RedisModuleCommandFilterCtx *fctx) REDISMODULE_ATTR;,1257.0,1257.0,21.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5792,316697,RedisModule_CommandFilterArgGet,1,RedisModule_CommandFilterArgGet,"RedisModuleString* RedisModule_CommandFilterArgGet (RedisModuleCommandFilterCtx*,int)",redismodule.h,"RedisModuleString * (*RedisModule_CommandFilterArgGet)(RedisModuleCommandFilterCtx *fctx, int pos) REDISMODULE_ATTR;",1258.0,1258.0,35.0,114.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5793,316703,RedisModule_CommandFilterArgInsert,1,RedisModule_CommandFilterArgInsert,"int RedisModule_CommandFilterArgInsert (RedisModuleCommandFilterCtx*,int,RedisModuleString*)",redismodule.h,"int (*RedisModule_CommandFilterArgInsert)(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg) REDISMODULE_ATTR;",1259.0,1259.0,21.0,125.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5794,316710,RedisModule_CommandFilterArgReplace,1,RedisModule_CommandFilterArgReplace,"int RedisModule_CommandFilterArgReplace (RedisModuleCommandFilterCtx*,int,RedisModuleString*)",redismodule.h,"int (*RedisModule_CommandFilterArgReplace)(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg) REDISMODULE_ATTR;",1260.0,1260.0,21.0,126.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5795,316717,RedisModule_CommandFilterArgDelete,1,RedisModule_CommandFilterArgDelete,"int RedisModule_CommandFilterArgDelete (RedisModuleCommandFilterCtx*,int)",redismodule.h,"int (*RedisModule_CommandFilterArgDelete)(RedisModuleCommandFilterCtx *fctx, int pos) REDISMODULE_ATTR;",1261.0,1261.0,21.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5796,316723,RedisModule_CommandFilterGetClientId,1,RedisModule_CommandFilterGetClientId,long long unsigned RedisModule_CommandFilterGetClientId (RedisModuleCommandFilterCtx*),redismodule.h,unsigned long long (*RedisModule_CommandFilterGetClientId)(RedisModuleCommandFilterCtx *fctx) REDISMODULE_ATTR;,1262.0,1262.0,36.0,109.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,long long unsigned
5797,316728,RedisModule_Fork,1,RedisModule_Fork,"int RedisModule_Fork (RedisModuleForkDoneHandler,void*)",redismodule.h,"int (*RedisModule_Fork)(RedisModuleForkDoneHandler cb, void *user_data) REDISMODULE_ATTR;",1263.0,1263.0,21.0,87.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5798,316734,RedisModule_SendChildHeartbeat,1,RedisModule_SendChildHeartbeat,void RedisModule_SendChildHeartbeat (double),redismodule.h,void (*RedisModule_SendChildHeartbeat)(double progress) REDISMODULE_ATTR;,1264.0,1264.0,22.0,71.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5799,316739,RedisModule_ExitFromChild,1,RedisModule_ExitFromChild,int RedisModule_ExitFromChild (int),redismodule.h,int (*RedisModule_ExitFromChild)(int retcode) REDISMODULE_ATTR;,1265.0,1265.0,21.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5800,316744,RedisModule_KillForkChild,1,RedisModule_KillForkChild,int RedisModule_KillForkChild (int),redismodule.h,int (*RedisModule_KillForkChild)(int child_pid) REDISMODULE_ATTR;,1266.0,1266.0,21.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5801,316749,RedisModule_GetUsedMemoryRatio,1,RedisModule_GetUsedMemoryRatio,float RedisModule_GetUsedMemoryRatio (void),redismodule.h,float (*RedisModule_GetUsedMemoryRatio)(void) REDISMODULE_ATTR;,1267.0,1267.0,23.0,61.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,float
5802,316754,RedisModule_MallocSize,1,RedisModule_MallocSize,size_t RedisModule_MallocSize (void*),redismodule.h,size_t (*RedisModule_MallocSize)(void* ptr) REDISMODULE_ATTR;,1268.0,1268.0,24.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
5803,316759,RedisModule_MallocUsableSize,1,RedisModule_MallocUsableSize,size_t RedisModule_MallocUsableSize (void*),redismodule.h,size_t (*RedisModule_MallocUsableSize)(void *ptr) REDISMODULE_ATTR;,1269.0,1269.0,24.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
5804,316764,RedisModule_MallocSizeString,1,RedisModule_MallocSizeString,size_t RedisModule_MallocSizeString (RedisModuleString*),redismodule.h,size_t (*RedisModule_MallocSizeString)(RedisModuleString* str) REDISMODULE_ATTR;,1270.0,1270.0,24.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
5805,316769,RedisModule_MallocSizeDict,1,RedisModule_MallocSizeDict,size_t RedisModule_MallocSizeDict (RedisModuleDict*),redismodule.h,size_t (*RedisModule_MallocSizeDict)(RedisModuleDict* dict) REDISMODULE_ATTR;,1271.0,1271.0,24.0,75.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
5806,316774,RedisModule_CreateModuleUser,1,RedisModule_CreateModuleUser,RedisModuleUser* RedisModule_CreateModuleUser (char*),redismodule.h,RedisModuleUser * (*RedisModule_CreateModuleUser)(const char *name) REDISMODULE_ATTR;,1272.0,1272.0,33.0,83.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,RedisModuleUser*
5807,316779,RedisModule_FreeModuleUser,1,RedisModule_FreeModuleUser,void RedisModule_FreeModuleUser (RedisModuleUser*),redismodule.h,void (*RedisModule_FreeModuleUser)(RedisModuleUser *user) REDISMODULE_ATTR;,1273.0,1273.0,22.0,73.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5808,316784,RedisModule_SetContextUser,1,RedisModule_SetContextUser,"void RedisModule_SetContextUser (RedisModuleCtx*,RedisModuleUser*)",redismodule.h,"void (*RedisModule_SetContextUser)(RedisModuleCtx *ctx, const RedisModuleUser *user) REDISMODULE_ATTR;",1274.0,1274.0,22.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
5809,316790,RedisModule_SetModuleUserACL,1,RedisModule_SetModuleUserACL,"int RedisModule_SetModuleUserACL (RedisModuleUser*,char*)",redismodule.h,"int (*RedisModule_SetModuleUserACL)(RedisModuleUser *user, const char* acl) REDISMODULE_ATTR;",1275.0,1275.0,21.0,91.0,1.0,0,0,0,0,6,0,1,1,0,0,,0,0,4,2,2,int
5810,316796,RedisModule_SetModuleUserACLString,1,RedisModule_SetModuleUserACLString,"int RedisModule_SetModuleUserACLString (RedisModuleCtx*,RedisModuleUser*,char*,RedisModuleString**)",redismodule.h,"int (*RedisModule_SetModuleUserACLString)(RedisModuleCtx * ctx, RedisModuleUser *user, const char* acl, RedisModuleString **error) REDISMODULE_ATTR;",1276.0,1276.0,21.0,146.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5811,316804,RedisModule_GetModuleUserACLString,1,RedisModule_GetModuleUserACLString,RedisModuleString* RedisModule_GetModuleUserACLString (RedisModuleUser*),redismodule.h,RedisModuleString * (*RedisModule_GetModuleUserACLString)(RedisModuleUser *user) REDISMODULE_ATTR;,1277.0,1277.0,35.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5812,316809,RedisModule_GetCurrentUserName,1,RedisModule_GetCurrentUserName,RedisModuleString* RedisModule_GetCurrentUserName (RedisModuleCtx*),redismodule.h,RedisModuleString * (*RedisModule_GetCurrentUserName)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1278.0,1278.0,35.0,90.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5813,316814,RedisModule_GetModuleUserFromUserName,1,RedisModule_GetModuleUserFromUserName,RedisModuleUser* RedisModule_GetModuleUserFromUserName (RedisModuleString*),redismodule.h,RedisModuleUser * (*RedisModule_GetModuleUserFromUserName)(RedisModuleString *name) REDISMODULE_ATTR;,1279.0,1279.0,33.0,99.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleUser*
5814,316819,RedisModule_ACLCheckCommandPermissions,1,RedisModule_ACLCheckCommandPermissions,"int RedisModule_ACLCheckCommandPermissions (RedisModuleUser*,RedisModuleString**,int)",redismodule.h,"int (*RedisModule_ACLCheckCommandPermissions)(RedisModuleUser *user, RedisModuleString **argv, int argc) REDISMODULE_ATTR;",1280.0,1280.0,21.0,120.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5815,316826,RedisModule_ACLCheckKeyPermissions,1,RedisModule_ACLCheckKeyPermissions,"int RedisModule_ACLCheckKeyPermissions (RedisModuleUser*,RedisModuleString*,int)",redismodule.h,"int (*RedisModule_ACLCheckKeyPermissions)(RedisModuleUser *user, RedisModuleString *key, int flags) REDISMODULE_ATTR;",1281.0,1281.0,21.0,115.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5816,316833,RedisModule_ACLCheckChannelPermissions,1,RedisModule_ACLCheckChannelPermissions,"int RedisModule_ACLCheckChannelPermissions (RedisModuleUser*,RedisModuleString*,int)",redismodule.h,"int (*RedisModule_ACLCheckChannelPermissions)(RedisModuleUser *user, RedisModuleString *ch, int literal) REDISMODULE_ATTR;",1282.0,1282.0,21.0,120.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5817,316840,RedisModule_ACLAddLogEntry,1,RedisModule_ACLAddLogEntry,"void RedisModule_ACLAddLogEntry (RedisModuleCtx*,RedisModuleUser*,RedisModuleString*,RedisModuleACLLogEntryReason)",redismodule.h,"void (*RedisModule_ACLAddLogEntry)(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) REDISMODULE_ATTR;",1283.0,1283.0,22.0,158.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
5818,316848,RedisModule_ACLAddLogEntryByUserName,1,RedisModule_ACLAddLogEntryByUserName,"void RedisModule_ACLAddLogEntryByUserName (RedisModuleCtx*,RedisModuleString*,RedisModuleString*,RedisModuleACLLogEntryReason)",redismodule.h,"void (*RedisModule_ACLAddLogEntryByUserName)(RedisModuleCtx *ctx, RedisModuleString *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) REDISMODULE_ATTR;",1284.0,1284.0,22.0,170.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
5819,316856,RedisModule_AuthenticateClientWithACLUser,1,RedisModule_AuthenticateClientWithACLUser,"int RedisModule_AuthenticateClientWithACLUser (RedisModuleCtx*,char*,size_t,RedisModuleUserChangedFunc,void*,uint64_t*)",redismodule.h,"int (*RedisModule_AuthenticateClientWithACLUser)(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) REDISMODULE_ATTR;",1285.0,1285.0,21.0,189.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
5820,316866,RedisModule_AuthenticateClientWithUser,1,RedisModule_AuthenticateClientWithUser,"int RedisModule_AuthenticateClientWithUser (RedisModuleCtx*,RedisModuleUser*,RedisModuleUserChangedFunc,void*,uint64_t*)",redismodule.h,"int (*RedisModule_AuthenticateClientWithUser)(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) REDISMODULE_ATTR;",1286.0,1286.0,21.0,179.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
5821,316875,RedisModule_DeauthenticateAndCloseClient,1,RedisModule_DeauthenticateAndCloseClient,"int RedisModule_DeauthenticateAndCloseClient (RedisModuleCtx*,uint64_t)",redismodule.h,"int (*RedisModule_DeauthenticateAndCloseClient)(RedisModuleCtx *ctx, uint64_t client_id) REDISMODULE_ATTR;",1287.0,1287.0,21.0,104.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
5822,316881,RedisModule_RedactClientCommandArgument,1,RedisModule_RedactClientCommandArgument,"int RedisModule_RedactClientCommandArgument (RedisModuleCtx*,int)",redismodule.h,"int (*RedisModule_RedactClientCommandArgument)(RedisModuleCtx *ctx, int pos) REDISMODULE_ATTR;",1288.0,1288.0,21.0,92.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5823,316887,RedisModule_GetClientCertificate,1,RedisModule_GetClientCertificate,"RedisModuleString* RedisModule_GetClientCertificate (RedisModuleCtx*,uint64_t)",redismodule.h,"RedisModuleString * (*RedisModule_GetClientCertificate)(RedisModuleCtx *ctx, uint64_t id) REDISMODULE_ATTR;",1289.0,1289.0,35.0,105.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5824,316893,RedisModule_GetCommandKeys,1,RedisModule_GetCommandKeys,"int* RedisModule_GetCommandKeys (RedisModuleCtx*,RedisModuleString**,int,int*)",redismodule.h,"int *(*RedisModule_GetCommandKeys)(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys) REDISMODULE_ATTR;",1290.0,1290.0,21.0,122.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int*
5825,316901,RedisModule_GetCommandKeysWithFlags,1,RedisModule_GetCommandKeysWithFlags,"int* RedisModule_GetCommandKeysWithFlags (RedisModuleCtx*,RedisModuleString**,int,int*,int**)",redismodule.h,"int *(*RedisModule_GetCommandKeysWithFlags)(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys, int **out_flags) REDISMODULE_ATTR;",1291.0,1291.0,21.0,148.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int*
5826,316910,RedisModule_GetCurrentCommandName,1,RedisModule_GetCurrentCommandName,char* RedisModule_GetCurrentCommandName (RedisModuleCtx*),redismodule.h,const char *(*RedisModule_GetCurrentCommandName)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1292.0,1292.0,28.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
5827,316915,RedisModule_RegisterDefragFunc,1,RedisModule_RegisterDefragFunc,"int RedisModule_RegisterDefragFunc (RedisModuleCtx*,RedisModuleDefragFunc)",redismodule.h,"int (*RedisModule_RegisterDefragFunc)(RedisModuleCtx *ctx, RedisModuleDefragFunc func) REDISMODULE_ATTR;",1293.0,1293.0,21.0,102.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5828,316921,RedisModule_DefragAlloc,1,RedisModule_DefragAlloc,"void* RedisModule_DefragAlloc (RedisModuleDefragCtx*,void*)",redismodule.h,"void *(*RedisModule_DefragAlloc)(RedisModuleDefragCtx *ctx, void *ptr) REDISMODULE_ATTR;",1294.0,1294.0,22.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
5829,316927,RedisModule_DefragRedisModuleString,1,RedisModule_DefragRedisModuleString,"RedisModuleString* RedisModule_DefragRedisModuleString (RedisModuleDefragCtx*,RedisModuleString*)",redismodule.h,"RedisModuleString *(*RedisModule_DefragRedisModuleString)(RedisModuleDefragCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",1295.0,1295.0,35.0,124.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,RedisModuleString*
5830,316933,RedisModule_DefragShouldStop,1,RedisModule_DefragShouldStop,int RedisModule_DefragShouldStop (RedisModuleDefragCtx*),redismodule.h,int (*RedisModule_DefragShouldStop)(RedisModuleDefragCtx *ctx) REDISMODULE_ATTR;,1296.0,1296.0,21.0,78.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5831,316938,RedisModule_DefragCursorSet,1,RedisModule_DefragCursorSet,"int RedisModule_DefragCursorSet (RedisModuleDefragCtx*,long unsigned)",redismodule.h,"int (*RedisModule_DefragCursorSet)(RedisModuleDefragCtx *ctx, unsigned long cursor) REDISMODULE_ATTR;",1297.0,1297.0,21.0,99.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5832,316944,RedisModule_DefragCursorGet,1,RedisModule_DefragCursorGet,"int RedisModule_DefragCursorGet (RedisModuleDefragCtx*,long unsigned*)",redismodule.h,"int (*RedisModule_DefragCursorGet)(RedisModuleDefragCtx *ctx, unsigned long *cursor) REDISMODULE_ATTR;",1298.0,1298.0,21.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5833,316950,RedisModule_GetDbIdFromDefragCtx,1,RedisModule_GetDbIdFromDefragCtx,int RedisModule_GetDbIdFromDefragCtx (RedisModuleDefragCtx*),redismodule.h,int (*RedisModule_GetDbIdFromDefragCtx)(RedisModuleDefragCtx *ctx) REDISMODULE_ATTR;,1299.0,1299.0,21.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5834,316955,RedisModule_GetKeyNameFromDefragCtx,1,RedisModule_GetKeyNameFromDefragCtx,RedisModuleString* RedisModule_GetKeyNameFromDefragCtx (RedisModuleDefragCtx*),redismodule.h,const RedisModuleString * (*RedisModule_GetKeyNameFromDefragCtx)(RedisModuleDefragCtx *ctx) REDISMODULE_ATTR;,1300.0,1300.0,41.0,107.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleString*
5835,316960,RedisModule_EventLoopAdd,1,RedisModule_EventLoopAdd,"int RedisModule_EventLoopAdd (int,int,RedisModuleEventLoopFunc,void*)",redismodule.h,"int (*RedisModule_EventLoopAdd)(int fd, int mask, RedisModuleEventLoopFunc func, void *user_data) REDISMODULE_ATTR;",1301.0,1301.0,21.0,113.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
5836,316968,RedisModule_EventLoopDel,1,RedisModule_EventLoopDel,"int RedisModule_EventLoopDel (int,int)",redismodule.h,"int (*RedisModule_EventLoopDel)(int fd, int mask) REDISMODULE_ATTR;",1302.0,1302.0,21.0,65.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5837,316974,RedisModule_EventLoopAddOneShot,1,RedisModule_EventLoopAddOneShot,"int RedisModule_EventLoopAddOneShot (RedisModuleEventLoopOneShotFunc,void*)",redismodule.h,"int (*RedisModule_EventLoopAddOneShot)(RedisModuleEventLoopOneShotFunc func, void *user_data) REDISMODULE_ATTR;",1303.0,1303.0,21.0,109.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
5838,316980,RedisModule_RegisterBoolConfig,1,RedisModule_RegisterBoolConfig,"int RedisModule_RegisterBoolConfig (RedisModuleCtx*,char*,int,unsigned int,RedisModuleConfigGetBoolFunc,RedisModuleConfigSetBoolFunc,RedisModuleConfigApplyFunc,void*)",redismodule.h,"int (*RedisModule_RegisterBoolConfig)(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, RedisModuleConfigGetBoolFunc getfn, RedisModuleConfigSetBoolFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",1304.0,1304.0,21.0,253.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,16,8,8,int
5839,316992,RedisModule_RegisterNumericConfig,1,RedisModule_RegisterNumericConfig,"int RedisModule_RegisterNumericConfig (RedisModuleCtx*,char*,long long,unsigned int,long long,long long,RedisModuleConfigGetNumericFunc,RedisModuleConfigSetNumericFunc,RedisModuleConfigApplyFunc,void*)",redismodule.h,"int (*RedisModule_RegisterNumericConfig)(RedisModuleCtx *ctx, const char *name, long long default_val, unsigned int flags, long long min, long long max, RedisModuleConfigGetNumericFunc getfn, RedisModuleConfigSetNumericFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",1305.0,1305.0,21.0,298.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,20,10,10,int
5840,317006,RedisModule_RegisterStringConfig,1,RedisModule_RegisterStringConfig,"int RedisModule_RegisterStringConfig (RedisModuleCtx*,char*,char*,unsigned int,RedisModuleConfigGetStringFunc,RedisModuleConfigSetStringFunc,RedisModuleConfigApplyFunc,void*)",redismodule.h,"int (*RedisModule_RegisterStringConfig)(RedisModuleCtx *ctx, const char *name, const char *default_val, unsigned int flags, RedisModuleConfigGetStringFunc getfn, RedisModuleConfigSetStringFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",1306.0,1306.0,21.0,267.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,16,8,8,int
5841,317018,RedisModule_RegisterEnumConfig,1,RedisModule_RegisterEnumConfig,"int RedisModule_RegisterEnumConfig (RedisModuleCtx*,char*,int,unsigned int,char**,int*,int,RedisModuleConfigGetEnumFunc,RedisModuleConfigSetEnumFunc,RedisModuleConfigApplyFunc,void*)",redismodule.h,"int (*RedisModule_RegisterEnumConfig)(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, const char **enum_values, const int *int_values, int num_enum_vals, RedisModuleConfigGetEnumFunc getfn, RedisModuleConfigSetEnumFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",1307.0,1307.0,21.0,321.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,22,11,11,int
5842,317033,RedisModule_LoadConfigs,1,RedisModule_LoadConfigs,int RedisModule_LoadConfigs (RedisModuleCtx*),redismodule.h,int (*RedisModule_LoadConfigs)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,1308.0,1308.0,21.0,67.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
5843,317038,RedisModule_RdbStreamCreateFromFile,1,RedisModule_RdbStreamCreateFromFile,RedisModuleRdbStream* RedisModule_RdbStreamCreateFromFile (char*),redismodule.h,RedisModuleRdbStream *(*RedisModule_RdbStreamCreateFromFile)(const char *filename) REDISMODULE_ATTR;,1309.0,1309.0,38.0,98.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,RedisModuleRdbStream*
5844,317043,RedisModule_RdbStreamFree,1,RedisModule_RdbStreamFree,void RedisModule_RdbStreamFree (RedisModuleRdbStream*),redismodule.h,void (*RedisModule_RdbStreamFree)(RedisModuleRdbStream *stream) REDISMODULE_ATTR;,1310.0,1310.0,22.0,79.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
5845,317048,RedisModule_RdbLoad,1,RedisModule_RdbLoad,"int RedisModule_RdbLoad (RedisModuleCtx*,RedisModuleRdbStream*,int)",redismodule.h,"int (*RedisModule_RdbLoad)(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) REDISMODULE_ATTR;",1311.0,1311.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5846,317055,RedisModule_RdbSave,1,RedisModule_RdbSave,"int RedisModule_RdbSave (RedisModuleCtx*,RedisModuleRdbStream*,int)",redismodule.h,"int (*RedisModule_RdbSave)(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) REDISMODULE_ATTR;",1312.0,1312.0,21.0,104.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
5847,317062,RedisModule_Init,1,RedisModule_Init,"int RedisModule_Init (RedisModuleCtx*,char*,int,int)",redismodule.h,"static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
    void *getapifuncptr = ((void**)ctx)[0];
    RedisModule_GetApi = (int (*)(const char *, void *)) (unsigned long)getapifuncptr;
    REDISMODULE_GET_API(Alloc);
    REDISMODULE_GET_API(TryAlloc);
    REDISMODULE_GET_API(Calloc);
    REDISMODULE_GET_API(Free);
    REDISMODULE_GET_API(Realloc);
    REDISMODULE_GET_API(Strdup);
    REDISMODULE_GET_API(CreateCommand);
    REDISMODULE_GET_API(GetCommand);
    REDISMODULE_GET_API(CreateSubcommand);
    REDISMODULE_GET_API(SetCommandInfo);
    REDISMODULE_GET_API(SetCommandACLCategories);
    REDISMODULE_GET_API(SetModuleAttribs);
    REDISMODULE_GET_API(IsModuleNameBusy);
    REDISMODULE_GET_API(WrongArity);
    REDISMODULE_GET_API(ReplyWithLongLong);
    REDISMODULE_GET_API(ReplyWithError);
    REDISMODULE_GET_API(ReplyWithErrorFormat);
    REDISMODULE_GET_API(ReplyWithSimpleString);
    REDISMODULE_GET_API(ReplyWithArray);
    REDISMODULE_GET_API...",1318.0,1678.0,1.0,4.0,361.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
5848,319963,redisBuildIdRaw,1,redisBuildIdRaw,const char* redisBuildIdRaw (void),release.c,"const char *redisBuildIdRaw(void) {
    return REDIS_BUILD_ID_RAW;
}",48.0,50.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,const char*
5849,319970,redisBuildId,1,redisBuildId,uint64_t redisBuildId (void),release.c,"uint64_t redisBuildId(void) {
    char *buildid = REDIS_BUILD_ID_RAW;

    return crc64(0,(unsigned char*)buildid,strlen(buildid));
}",52.0,56.0,1.0,1.0,5.0,2,2,4,2,2,1,1,1,0,1,,0,0,2,1,1,uint64_t
5850,319987,redisBuildIdString,1,redisBuildIdString,char* redisBuildIdString (void),release.c,"char *redisBuildIdString(void) {
    static char buf[32];
    static int cached = 0;
    if (!cached) {
        snprintf(buf,sizeof(buf),""%llx"",(unsigned long long) redisBuildId());
        cached = 1;
    }
    return buf;
}",61.0,69.0,1.0,1.0,9.0,5,4,6,2,1,1,2,2,0,1,,0,0,2,1,1,char*
5851,320043,replicationDiscardCachedMaster,1,replicationDiscardCachedMaster,void replicationDiscardCachedMaster (void),replication.c,"void replicationDiscardCachedMaster(void) {
    if (server.cached_master == NULL) return;

    serverLog(LL_NOTICE,""Discarding previously cached master state."");
    server.cached_master->flags &= ~CLIENT_MASTER;
    freeClient(server.cached_master);
    server.cached_master = NULL;
}",3377.0,3384.0,1.0,4.0,8.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,void
5852,320048,replicationResurrectCachedMaster,1,replicationResurrectCachedMaster,void replicationResurrectCachedMaster (connection*),replication.c,"void replicationResurrectCachedMaster(connection *conn) {
    server.master = server.cached_master;
    server.cached_master = NULL;
    server.master->conn = conn;
    connSetPrivateData(server.master->conn, server.master);
    server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master->authenticated = 1;
    server.master->lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;
    server.repl_down_since = 0;

    /* Fire the master link modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,
                          NULL);

    /* Re-add to the list of clients. */
    linkClient(server.master);
    if (connSetReadHandler(server.master->conn, readQueryFromClient)) {
        serverLog(LL_WARNING,""Error resurrecting the cached master, impossible to add the readable handler: %s"", strerror(errno));
        freeClientAsync(server.master); /* C...",3392.0,3423.0,1.0,30.0,32.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5853,320053,replicationSendAck,1,replicationSendAck,void replicationSendAck (void),replication.c,"void replicationSendAck(void) {
    client *c = server.master;

    if (c != NULL) {
        int send_fack = server.fsynced_reploff != -1;
        c->flags |= CLIENT_MASTER_FORCE_REPLY;
        addReplyArrayLen(c,send_fack ? 5 : 3);
        addReplyBulkCString(c,""REPLCONF"");
        addReplyBulkCString(c,""ACK"");
        addReplyBulkLongLong(c,c->reploff);
        if (send_fack) {
            addReplyBulkCString(c,""FACK"");
            addReplyBulkLongLong(c,server.fsynced_reploff);
        }
        c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
    }
}",3260.0,3276.0,1.0,20.0,17.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
5854,320058,replicaPutOnline,1,replicaPutOnline,int replicaPutOnline (client*),replication.c,"int replicaPutOnline(client *slave) {
    if (slave->flags & CLIENT_REPL_RDBONLY) {
        slave->replstate = SLAVE_STATE_RDB_TRANSMITTED;
        /* The client asked for RDB only so we should close it ASAP */
        serverLog(LL_NOTICE,
                  ""RDB transfer completed, rdb only replica (%s) should be disconnected asap"",
                  replicationGetSlaveName(slave));
        return 0;
    }
    slave->replstate = SLAVE_STATE_ONLINE;
    slave->repl_ack_time = server.unixtime; /* Prevent false timeout. */

    refreshGoodSlavesCount();
    /* Fire the replica change modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,
                          REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,
                          NULL);
    serverLog(LL_NOTICE,""Synchronization with replica %s succeeded"",
        replicationGetSlaveName(slave));
    return 1;
}",1292.0,1312.0,1.0,23.0,21.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
5855,320063,replicaStartCommandStream,1,replicaStartCommandStream,void replicaStartCommandStream (client*),replication.c,"void replicaStartCommandStream(client *slave) {
    serverAssert(!(slave->flags & CLIENT_REPL_RDBONLY));
    slave->repl_start_cmd_stream_on_ack = 0;

    putClientInPendingWriteQueue(slave);
}",1325.0,1330.0,1.0,4.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5856,320068,cancelReplicationHandshake,1,cancelReplicationHandshake,int cancelReplicationHandshake (int),replication.c,"int cancelReplicationHandshake(int reconnect) {
    if (server.repl_state == REPL_STATE_TRANSFER) {
        replicationAbortSyncTransfer();
        server.repl_state = REPL_STATE_CONNECT;
    } else if (server.repl_state == REPL_STATE_CONNECTING ||
               slaveIsInHandshakeState())
    {
        undoConnectWithMaster();
        server.repl_state = REPL_STATE_CONNECT;
    } else {
        return 0;
    }

    if (!reconnect)
        return 1;

    /* try to re-connect without waiting for replicationCron, this is needed
     * for the ""diskless loading short read"" test. */
    serverLog(LL_NOTICE,""Reconnecting to MASTER %s:%d after failure"",
        server.masterhost, server.masterport);
    connectWithMaster();

    return 1;
}",2977.0,3000.0,1.0,4.0,24.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,int
5857,320077,connTypeOfReplication,1,connTypeOfReplication,ConnectionType connTypeOfReplication (void),replication.c,"static ConnectionType *connTypeOfReplication(void) {
    if (server.tls_replication) {
        return connectionTypeTls();
    }

    return connectionTypeTcp();
}",58.0,64.0,1.0,1.0,7.0,1,1,1,1,1,2,2,2,0,2,,0,0,2,1,1,ConnectionType
5858,320091,replicationGetSlaveName,1,replicationGetSlaveName,char* replicationGetSlaveName (client*),replication.c,"char *replicationGetSlaveName(client *c) {
    static char buf[NET_HOST_PORT_STR_LEN];
    char ip[NET_IP_STR_LEN];

    ip[0] = '\0';
    buf[0] = '\0';
    if (c->slave_addr ||
        connAddrPeerName(c->conn,ip,sizeof(ip),NULL) != -1)
    {
        char *addr = c->slave_addr ? c->slave_addr : ip;
        if (c->slave_listening_port)
            formatAddr(buf,sizeof(buf),addr,c->slave_listening_port);
        else
            snprintf(buf,sizeof(buf),""%s:<unknown-replica-port>"",addr);
    } else {
        snprintf(buf,sizeof(buf),""client id #%llu"",
            (unsigned long long) c->id);
    }
    return buf;
}",70.0,89.0,1.0,20.0,20.0,17,8,17,5,9,8,3,4,4,2,,0,7,2,1,1,char*
5859,320171,bg_unlink,1,bg_unlink,int bg_unlink (char*),replication.c,"int bg_unlink(const char *filename) {
    int fd = open(filename,O_RDONLY|O_NONBLOCK);
    if (fd == -1) {
        /* Can't open the file? Fall back to unlinking in the main thread. */
        return unlink(filename);
    } else {
        /* The following unlink() removes the name but doesn't free the
         * file contents because a process still has it open. */
        int retval = unlink(filename);
        if (retval == -1) {
            /* If we got an unlink error, we just return it, closing the
             * new reference we have to the file. */
            int old_errno = errno;
            close(fd);  /* This would overwrite our errno. So we saved it. */
            errno = old_errno;
            return -1;
        }
        bioCreateCloseJob(fd, 0, 0);
        return 0; /* Success. */
    }
}",97.0,117.0,1.0,1.0,21.0,4,4,6,4,9,0,2,2,0,0,,0,0,2,1,1,int
5860,320224,createReplicationBacklog,1,createReplicationBacklog,void createReplicationBacklog (void),replication.c,"void createReplicationBacklog(void) {
    serverAssert(server.repl_backlog == NULL);
    server.repl_backlog = zmalloc(sizeof(replBacklog));
    server.repl_backlog->ref_repl_buf_node = NULL;
    server.repl_backlog->unindexed_count = 0;
    server.repl_backlog->blocks_index = raxNew();
    server.repl_backlog->histlen = 0;
    /* We don't have any data inside our buffer, but virtually the first
     * byte we have is the next byte that will be generated for the
     * replication stream. */
    server.repl_backlog->offset = server.master_repl_offset+1;
}",121.0,132.0,1.0,4.0,12.0,26,10,11,3,3,3,1,1,0,3,,0,2,2,1,1,void
5861,320293,resizeReplicationBacklog,1,resizeReplicationBacklog,void resizeReplicationBacklog (void),replication.c,"void resizeReplicationBacklog(void) {
    if (server.repl_backlog_size < CONFIG_REPL_BACKLOG_MIN_SIZE)
        server.repl_backlog_size = CONFIG_REPL_BACKLOG_MIN_SIZE;
    if (server.repl_backlog)
        incrementalTrimReplicationBacklog(REPL_BACKLOG_TRIM_BLOCKS_PER_CALL);
}",139.0,144.0,1.0,35.0,6.0,7,4,3,1,1,1,3,3,0,1,,0,0,2,1,1,void
5862,320327,freeReplicationBacklog,1,freeReplicationBacklog,void freeReplicationBacklog (void),replication.c,"void freeReplicationBacklog(void) {
    serverAssert(listLength(server.slaves) == 0);
    if (server.repl_backlog == NULL) return;

    /* Decrease the start buffer node reference count. */
    if (server.repl_backlog->ref_repl_buf_node) {
        replBufBlock *o = listNodeValue(
            server.repl_backlog->ref_repl_buf_node);
        serverAssert(o->refcount == 1); /* Last reference. */
        o->refcount--;
    }

    /* Replication buffer blocks are completely released when we free the
     * backlog, since the backlog is released only when there are no replicas
     * and the backlog keeps the last reference of all blocks. */
    freeReplicationBacklogRefMemAsync(server.repl_buffer_blocks,
                            server.repl_backlog->blocks_index);
    resetReplicationBuffer();
    zfree(server.repl_backlog);
    server.repl_backlog = NULL;
}",146.0,166.0,1.0,4.0,21.0,31,9,14,3,3,7,3,3,0,5,,0,2,2,1,1,void
5863,320425,createReplicationBacklogIndex,1,createReplicationBacklogIndex,void createReplicationBacklogIndex (listNode*),replication.c,"void createReplicationBacklogIndex(listNode *ln) {
    server.repl_backlog->unindexed_count++;
    if (server.repl_backlog->unindexed_count >= REPL_BACKLOG_INDEX_PER_BLOCKS) {
        replBufBlock *o = listNodeValue(ln);
        uint64_t encoded_offset = htonu64(o->repl_offset);
        raxInsert(server.repl_backlog->blocks_index,
                  (unsigned char*)&encoded_offset, sizeof(uint64_t),
                  ln, NULL);
        server.repl_backlog->unindexed_count = 0;
    }
}",171.0,181.0,1.0,48.0,11.0,19,8,14,6,2,5,2,2,0,2,,0,4,2,1,1,void
5864,320489,rebaseReplicationBuffer,1,rebaseReplicationBuffer,void rebaseReplicationBuffer (long long),replication.c,"void rebaseReplicationBuffer(long long base_repl_offset) {
    raxFree(server.repl_backlog->blocks_index);
    server.repl_backlog->blocks_index = raxNew();
    server.repl_backlog->unindexed_count = 0;

    listIter li;
    listNode *ln;
    listRewind(server.repl_buffer_blocks, &li);
    while ((ln = listNext(&li))) {
        replBufBlock *o = listNodeValue(ln);
        o->repl_offset += base_repl_offset;
        createReplicationBacklogIndex(ln);
    }
}",185.0,198.0,1.0,26.0,14.0,16,5,13,5,0,7,2,2,1,5,,0,4,2,1,1,void
5865,320545,resetReplicationBuffer,1,resetReplicationBuffer,void resetReplicationBuffer (void),replication.c,"void resetReplicationBuffer(void) {
    server.repl_buffer_mem = 0;
    server.repl_buffer_blocks = listCreate();
    listSetFreeMethod(server.repl_buffer_blocks, (void (*)(void*))zfree);
}",200.0,204.0,1.0,4.0,5.0,9,4,5,2,2,1,1,1,0,1,,0,1,2,1,1,void
5866,320574,canFeedReplicaReplBuffer,1,canFeedReplicaReplBuffer,int canFeedReplicaReplBuffer (client*),replication.c,"int canFeedReplicaReplBuffer(client *replica) {
    /* Don't feed replicas that only want the RDB. */
    if (replica->flags & CLIENT_REPL_RDBONLY) return 0;

    /* Don't feed replicas that are still waiting for BGSAVE to start. */
    if (replica->replstate == SLAVE_STATE_WAIT_BGSAVE_START) return 0;

    return 1;
}",206.0,214.0,1.0,25.0,9.0,5,4,2,1,2,2,3,3,2,0,,0,2,2,1,1,int
5867,320605,prepareReplicasToWrite,1,prepareReplicasToWrite,int prepareReplicasToWrite (void),replication.c,"int prepareReplicasToWrite(void) {
    listIter li;
    listNode *ln;
    int prepared = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (!canFeedReplicaReplBuffer(slave)) continue;
        if (prepareClientToWrite(slave) == C_ERR) continue;
        prepared++;
    }

    return prepared;
}",220.0,234.0,1.0,43.0,15.0,11,8,11,5,2,5,6,6,3,4,,0,4,2,1,1,int
5868,320655,feedReplicationBufferWithObject,1,feedReplicationBufferWithObject,void feedReplicationBufferWithObject (robj*),replication.c,"void feedReplicationBufferWithObject(robj *o) {
    char llstr[LONG_STR_SIZE];
    void *p;
    size_t len;

    if (o->encoding == OBJ_ENCODING_INT) {
        len = ll2string(llstr,sizeof(llstr),(long)o->ptr);
        p = llstr;
    } else {
        len = sdslen(o->ptr);
        p = o->ptr;
    }
    feedReplicationBuffer(p,len);
}",238.0,251.0,1.0,15.0,14.0,7,5,9,4,2,2,2,2,0,2,,0,1,2,1,1,void
5869,320702,incrementalTrimReplicationBacklog,1,incrementalTrimReplicationBacklog,void incrementalTrimReplicationBacklog (size_t),replication.c,"void incrementalTrimReplicationBacklog(size_t max_blocks) {
    serverAssert(server.repl_backlog != NULL);

    size_t trimmed_blocks = 0;
    while (server.repl_backlog->histlen > server.repl_backlog_size &&
           trimmed_blocks < max_blocks)
    {
        /* We never trim backlog to less than one block. */
        if (listLength(server.repl_buffer_blocks) <= 1) break;

        /* Replicas increment the refcount of the first replication buffer block
         * they refer to, in that case, we don't trim the backlog even if
         * backlog_histlen exceeds backlog_size. This implicitly makes backlog
         * bigger than our setting, but makes the master accept partial resync as
         * much as possible. So that backlog must be the last reference of
         * replication buffer blocks. */
        listNode *first = listFirst(server.repl_buffer_blocks);
        serverAssert(first == server.repl_backlog->ref_repl_buf_node);
        replBufBlock *fo = listNodeValue(first);
  ...",258.0,311.0,1.0,4.0,54.0,96,20,53,11,5,20,8,8,2,7,,0,14,2,1,1,void
5870,320975,freeReplicaReferencedReplBuffer,1,freeReplicaReferencedReplBuffer,void freeReplicaReferencedReplBuffer (client*),replication.c,"void freeReplicaReferencedReplBuffer(client *replica) {
    if (replica->ref_repl_buf_node != NULL) {
        /* Decrease the start buffer node reference count. */
        replBufBlock *o = listNodeValue(replica->ref_repl_buf_node);
        serverAssert(o->refcount > 0);
        o->refcount--;
        incrementalTrimReplicationBacklog(REPL_BACKLOG_TRIM_BLOCKS_PER_CALL);
    }
    replica->ref_repl_buf_node = NULL;
    replica->ref_block_pos = 0;
}",314.0,324.0,1.0,26.0,11.0,18,9,10,3,1,9,2,2,1,2,,0,7,2,1,1,void
5871,321036,feedReplicationBuffer,1,feedReplicationBuffer,"void feedReplicationBuffer (char*,size_t)",replication.c,"void feedReplicationBuffer(char *s, size_t len) {
    static long long repl_block_id = 0;

    if (server.repl_backlog == NULL) return;

    while(len > 0) {
        size_t start_pos = 0; /* The position of referenced block to start sending. */
        listNode *start_node = NULL; /* Replica/backlog starts referenced node. */
        int add_new_block = 0; /* Create new block if current block is total used. */
        listNode *ln = listLast(server.repl_buffer_blocks);
        replBufBlock *tail = ln ? listNodeValue(ln) : NULL;

        /* Append to tail string when possible. */
        if (tail && tail->size > tail->used) {
            start_node = listLast(server.repl_buffer_blocks);
            start_pos = tail->used;
            /* Copy the part we can fit into the tail, and leave the rest for a
             * new node */
            size_t avail = tail->size - tail->used;
            size_t copy = (avail >= len) ? len : avail;
            memcpy(tail->buf + tail->used, s, copy)...",331.0,429.0,1.0,23.0,99.0,146,22,128,19,5,32,13,25,5,9,,0,26,4,2,2,void
5872,321483,replicationFeedSlaves,1,replicationFeedSlaves,"void replicationFeedSlaves (list*,int,robj**,int)",replication.c,"void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
    int j, len;
    char llstr[LONG_STR_SIZE];

    /* In case we propagate a command that doesn't touch keys (PING, REPLCONF) we
     * pass dbid=-1 that indicate there is no need to replicate `select` command. */
    serverAssert(dictid == -1 || (dictid >= 0 && dictid < server.dbnum));

    /* If the instance is not a top level master, return ASAP: we'll just proxy
     * the stream of data we receive from our master instead, in order to
     * propagate *identical* replication stream. In this way this slave can
     * advertise the same replication ID as the master (since it shares the
     * master replication history and has the same backlog and offsets). */
    if (server.masterhost != NULL) return;

    /* If there aren't slaves, and there is no backlog buffer to populate,
     * we can return ASAP. */
    if (server.repl_backlog == NULL && listLength(slaves) == 0) {
        /* We increment the repl...",437.0,518.0,1.0,15.0,82.0,79,20,60,12,3,14,7,9,1,12,,0,5,8,4,4,void
5873,321749,showLatestBacklog,1,showLatestBacklog,void showLatestBacklog (void),replication.c,"void showLatestBacklog(void) {
    if (server.repl_backlog == NULL) return;
    if (listLength(server.repl_buffer_blocks) == 0) return;

    size_t dumplen = 256;
    if (server.repl_backlog->histlen < (long long)dumplen)
        dumplen = server.repl_backlog->histlen;

    sds dump = sdsempty();
    listNode *node = listLast(server.repl_buffer_blocks);
    while(dumplen) {
        if (node == NULL) break;
        replBufBlock *o = listNodeValue(node);
        size_t thislen = o->used >= dumplen ? dumplen : o->used;
        sds head = sdscatrepr(sdsempty(), o->buf+o->used-thislen, thislen);
        sds tmp = sdscatsds(head, dump);
        sdsfree(dump);
        dump = tmp;
        dumplen -= thislen;
        node = listPrevNode(node);
    }

    /* Finally log such bytes: this is vital debugging info to
     * understand what happened. */
    serverLog(LL_NOTICE,""Latest backlog is: '%s'"", dump);
    sdsfree(dump);
}",524.0,550.0,1.0,8.0,27.0,40,12,43,9,1,13,7,7,0,7,,0,10,2,1,1,void
5874,321905,replicationFeedStreamFromMasterStream,1,replicationFeedStreamFromMasterStream,"void replicationFeedStreamFromMasterStream (char*,size_t)",replication.c,"void replicationFeedStreamFromMasterStream(char *buf, size_t buflen) {
    /* Debugging: this is handy to see the stream sent from master
     * to slaves. Disabled with if(0). */
    if (0) {
        printf(""%zu:"",buflen);
        for (size_t j = 0; j < buflen; j++) {
            printf(""%c"", isprint(buf[j]) ? buf[j] : '.');
        }
        printf(""\n"");
    }

    /* There must be replication backlog if having attached slaves. */
    if (listLength(server.slaves)) serverAssert(server.repl_backlog != NULL);
    if (server.repl_backlog) {
        /* Must install write handler for all replicas first before feeding
         * replication stream. */
        prepareReplicasToWrite();
        feedReplicationBuffer(buf,buflen);
    }
}",555.0,574.0,1.0,8.0,20.0,15,10,15,5,1,3,5,6,0,3,,0,0,4,2,2,void
5875,321981,replicationFeedMonitors,1,replicationFeedMonitors,"void replicationFeedMonitors (client*,list*,int,robj**,int)",replication.c,"void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
    /* Fast path to return if the monitors list is empty or the server is in loading. */
    if (monitors == NULL || listLength(monitors) == 0 || server.loading) return;
    listNode *ln;
    listIter li;
    int j;
    sds cmdrepr = sdsnew(""+"");
    robj *cmdobj;
    struct timeval tv;

    gettimeofday(&tv,NULL);
    cmdrepr = sdscatprintf(cmdrepr,""%ld.%06ld "",(long)tv.tv_sec,(long)tv.tv_usec);
    if (c->flags & CLIENT_SCRIPT) {
        cmdrepr = sdscatprintf(cmdrepr,""[%d lua] "",dictid);
    } else if (c->flags & CLIENT_UNIX_SOCKET) {
        cmdrepr = sdscatprintf(cmdrepr,""[%d unix:%s] "",dictid,server.unixsocket);
    } else {
        cmdrepr = sdscatprintf(cmdrepr,""[%d %s] "",dictid,getClientPeerId(c));
    }

    for (j = 0; j < argc; j++) {
        if (argv[j]->encoding == OBJ_ENCODING_INT) {
            cmdrepr = sdscatprintf(cmdrepr, ""\""%ld\"""", (long)argv[j]->ptr);
        } else {
 ...",576.0,615.0,1.0,28.0,40.0,36,13,42,14,4,14,7,9,3,11,,0,11,10,5,5,void
5876,322188,addReplyReplicationBacklog,1,addReplyReplicationBacklog,"long long addReplyReplicationBacklog (client*,long long)",replication.c,"long long addReplyReplicationBacklog(client *c, long long offset) {
    long long skip;

    serverLog(LL_DEBUG, ""[PSYNC] Replica request offset: %lld"", offset);

    if (server.repl_backlog->histlen == 0) {
        serverLog(LL_DEBUG, ""[PSYNC] Backlog history len is zero"");
        return 0;
    }

    serverLog(LL_DEBUG, ""[PSYNC] Backlog size: %lld"",
             server.repl_backlog_size);
    serverLog(LL_DEBUG, ""[PSYNC] First byte: %lld"",
             server.repl_backlog->offset);
    serverLog(LL_DEBUG, ""[PSYNC] History len: %lld"",
             server.repl_backlog->histlen);

    /* Compute the amount of bytes we need to discard. */
    skip = offset - server.repl_backlog->offset;
    serverLog(LL_DEBUG, ""[PSYNC] Skipping: %lld"", skip);

    /* Iterate recorded blocks, quickly search the approximate node. */
    listNode *node = NULL;
    if (raxSize(server.repl_backlog->blocks_index) > 0) {
        uint64_t encoded_offset = htonu64(offset);
        raxIterator ri;
        raxS...",619.0,684.0,1.0,4.0,66.0,77,18,58,10,1,26,7,8,4,16,,0,13,4,2,2,long long
5877,322527,getPsyncInitialOffset,1,getPsyncInitialOffset,long long getPsyncInitialOffset (void),replication.c,"long long getPsyncInitialOffset(void) {
    return server.master_repl_offset;
}",690.0,692.0,1.0,1.0,3.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,long long
5878,322536,replicationSetupSlaveForFullResync,1,replicationSetupSlaveForFullResync,"int replicationSetupSlaveForFullResync (client*,long long)",replication.c,"int replicationSetupSlaveForFullResync(client *slave, long long offset) {
    char buf[128];
    int buflen;

    slave->psync_initial_offset = offset;
    slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
    /* We are going to accumulate the incremental changes for this
     * slave as well. Set slaveseldb to -1 in order to force to re-emit
     * a SELECT statement in the replication stream. */
    server.slaveseldb = -1;

    /* Don't send this reply to slaves that approached us with
     * the old SYNC command. */
    if (!(slave->flags & CLIENT_PRE_PSYNC)) {
        buflen = snprintf(buf,sizeof(buf),""+FULLRESYNC %s %lld\r\n"",
                          server.replid,offset);
        if (connWrite(slave->conn,buf,buflen) != buflen) {
            freeClientAsync(slave);
            return C_ERR;
        }
    }
    return C_OK;
}",710.0,732.0,1.0,23.0,23.0,17,9,15,5,3,6,3,4,3,2,,0,5,4,2,2,int
5879,322606,masterTryPartialResynchronization,1,masterTryPartialResynchronization,"int masterTryPartialResynchronization (client*,long long)",replication.c,"int masterTryPartialResynchronization(client *c, long long psync_offset) {
    long long psync_len;
    char *master_replid = c->argv[1]->ptr;
    char buf[128];
    int buflen;

    /* Is the replication ID of this master the same advertised by the wannabe
     * slave via PSYNC? If the replication ID changed this master has a
     * different replication history, and there is no way to continue.
     *
     * Note that there are two potentially valid replication IDs: the ID1
     * and the ID2. The ID2 however is only valid up to a specific offset. */
    if (strcasecmp(master_replid, server.replid) &&
        (strcasecmp(master_replid, server.replid2) ||
         psync_offset > server.second_replid_offset))
    {
        /* Replid ""?"" is used by slaves that want to force a full resync. */
        if (master_replid[0] != '?') {
            if (strcasecmp(master_replid, server.replid) &&
                strcasecmp(master_replid, server.replid2))
            {
                server...",739.0,835.0,1.0,16.0,97.0,64,15,55,8,1,20,10,12,3,13,,0,12,4,2,2,int
5880,322938,startBgsaveForReplication,1,startBgsaveForReplication,"int startBgsaveForReplication (int,int)",replication.c,"int startBgsaveForReplication(int mincapa, int req) {
    int retval;
    int socket_target = 0;
    listIter li;
    listNode *ln;

    /* We use a socket target if slave can handle the EOF marker and we're configured to do diskless syncs.
     * Note that in case we're creating a ""filtered"" RDB (functions-only, for example) we also force socket replication
     * to avoid overwriting the snapshot RDB file with filtered data. */
    socket_target = (server.repl_diskless_sync || req & SLAVE_REQ_RDB_MASK) && (mincapa & SLAVE_CAPA_EOF);
    /* `SYNC` should have failed with error if we don't support socket and require a filter, assert this here */
    serverAssert(socket_target || !(req & SLAVE_REQ_RDB_MASK));

    serverLog(LL_NOTICE,""Starting BGSAVE for SYNC with target: %s"",
        socket_target ? ""replicas sockets"" : ""disk"");

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);
    /* Only do rdbSave* when rsiptr is not NULL,
     * otherwise slave will miss rep...",855.0,933.0,1.0,56.0,79.0,66,19,49,12,1,22,12,21,5,13,,0,14,4,2,2,int
5881,323232,syncCommand,1,syncCommand,void syncCommand (client*),replication.c,"void syncCommand(client *c) {
    /* ignore SYNC if already slave or in monitor mode */
    if (c->flags & CLIENT_SLAVE) return;

    /* Check if this is a failover request to a replica with the same replid and
     * become a master if so. */
    if (c->argc > 3 && !strcasecmp(c->argv[0]->ptr,""psync"") && 
        !strcasecmp(c->argv[3]->ptr,""failover""))
    {
        serverLog(LL_NOTICE, ""Failover request received for replid %s."",
            (unsigned char *)c->argv[1]->ptr);
        if (!server.masterhost) {
            addReplyError(c, ""PSYNC FAILOVER can't be sent to a master."");
            return;
        }

        if (!strcasecmp(c->argv[1]->ptr,server.replid)) {
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,
                ""MASTER MODE enabled (failover request from '%s')"",client);
            sdsfree(client);
        } else {
            addReplyError(c, ""PSYNC FAILOVER replid must match ...",936.0,1128.0,1.0,19.0,193.0,130,18,77,10,0,54,20,29,22,29,,0,33,2,1,1,void
5882,323892,replconfCommand,1,replconfCommand,void replconfCommand (client*),replication.c,"void replconfCommand(client *c) {
    int j;

    if ((c->argc % 2) == 0) {
        /* Number of arguments must be odd to make sure that every
         * option has a corresponding value. */
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Process every option-value pair. */
    for (j = 1; j < c->argc; j+=2) {
        if (!strcasecmp(c->argv[j]->ptr,""listening-port"")) {
            long port;

            if ((getLongFromObjectOrReply(c,c->argv[j+1],
                    &port,NULL) != C_OK))
                return;
            c->slave_listening_port = port;
        } else if (!strcasecmp(c->argv[j]->ptr,""ip-address"")) {
            sds addr = c->argv[j+1]->ptr;
            if (sdslen(addr) < NET_HOST_STR_LEN) {
                if (c->slave_addr) sdsfree(c->slave_addr);
                c->slave_addr = sdsdup(addr);
            } else {
                addReplyErrorFormat(c,""REPLCONF ip-address provided by ""
                    ""replica instance is too ...",1165.0,1280.0,1.0,35.0,116.0,19,11,17,5,0,8,5,8,5,3,,0,6,2,1,1,void
5883,324567,removeRDBUsedToSyncReplicas,1,removeRDBUsedToSyncReplicas,void removeRDBUsedToSyncReplicas (void),replication.c,"void removeRDBUsedToSyncReplicas(void) {
    /* If the feature is disabled, return ASAP but also clear the
     * RDBGeneratedByReplication flag in case it was set. Otherwise if the
     * feature was enabled, but gets disabled later with CONFIG SET, the
     * flag may remain set to one: then next time the feature is re-enabled
     * via CONFIG SET we have it set even if no RDB was generated
     * because of replication recently. */
    if (!server.rdb_del_sync_files) {
        RDBGeneratedByReplication = 0;
        return;
    }

    if (allPersistenceDisabled() && RDBGeneratedByReplication) {
        client *slave;
        listNode *ln;
        listIter li;

        int delrdb = 1;
        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
                slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END ||
                slave->replstate == SLAVE_STATE_SEND_BULK...",1337.0,1377.0,1.0,36.0,41.0,29,12,20,7,1,12,8,13,6,5,,0,9,2,1,1,void
5884,324681,closeRepldbfd,1,closeRepldbfd,void closeRepldbfd (client*),replication.c,"void closeRepldbfd(client *myself) {
    listNode *ln;
    listIter li;
    int reclaim = 1;
    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (slave != myself && slave->replstate == SLAVE_STATE_SEND_BULK) {
            reclaim = 0;
            break;
        }
    }

    if (reclaim) {
        bioCreateCloseJob(myself->repldbfd, 0, 1);
    } else {
        close(myself->repldbfd);
    }
    myself->repldbfd = -1;
}",1381.0,1400.0,1.0,51.0,20.0,16,8,14,6,1,7,5,5,2,3,,0,5,2,1,1,void
5885,324749,sendBulkToSlave,1,sendBulkToSlave,void sendBulkToSlave (connection*),replication.c,"void sendBulkToSlave(connection *conn) {
    client *slave = connGetPrivateData(conn);
    char buf[PROTO_IOBUF_LEN];
    ssize_t nwritten, buflen;

    /* Before sending the RDB file, we send the preamble as configured by the
     * replication process. Currently the preamble is just the bulk count of
     * the file in the form ""$<length>\r\n"". */
    if (slave->replpreamble) {
        nwritten = connWrite(conn,slave->replpreamble,sdslen(slave->replpreamble));
        if (nwritten == -1) {
            serverLog(LL_WARNING,
                ""Write error sending RDB preamble to replica: %s"",
                connGetLastError(conn));
            freeClient(slave);
            return;
        }
        atomicIncr(server.stat_net_repl_output_bytes, nwritten);
        sdsrange(slave->replpreamble,nwritten,-1);
        if (sdslen(slave->replpreamble) == 0) {
            sdsfree(slave->replpreamble);
            slave->replpreamble = NULL;
            /* fall through sending data. */
      ...",1402.0,1458.0,1.0,13.0,57.0,44,13,51,10,0,35,9,13,8,21,,0,23,2,1,1,void
5886,324968,rdbPipeWriteHandlerConnRemoved,1,rdbPipeWriteHandlerConnRemoved,void rdbPipeWriteHandlerConnRemoved (connection*),replication.c,"void rdbPipeWriteHandlerConnRemoved(struct connection *conn) {
    if (!connHasWriteHandler(conn))
        return;
    connSetWriteHandler(conn, NULL);
    client *slave = connGetPrivateData(conn);
    slave->repl_last_partial_write = 0;
    server.rdb_pipe_numconns_writing--;
    /* if there are no more writes for now for this conn, or write error: */
    if (server.rdb_pipe_numconns_writing == 0) {
        if (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,NULL) == AE_ERR) {
            serverPanic(""Unrecoverable error creating server.rdb_pipe_read file event."");
        }
    }
}",1462.0,1475.0,1.0,63.0,14.0,13,8,12,5,2,6,4,5,2,5,,0,4,2,1,1,void
5887,325030,rdbPipeWriteHandler,1,rdbPipeWriteHandler,void rdbPipeWriteHandler (connection*),replication.c,"void rdbPipeWriteHandler(struct connection *conn) {
    serverAssert(server.rdb_pipe_bufflen>0);
    client *slave = connGetPrivateData(conn);
    ssize_t nwritten;
    if ((nwritten = connWrite(conn, server.rdb_pipe_buff + slave->repldboff,
                              server.rdb_pipe_bufflen - slave->repldboff)) == -1)
    {
        if (connGetState(conn) == CONN_STATE_CONNECTED)
            return; /* equivalent to EAGAIN */
        serverLog(LL_WARNING,""Write error sending DB to replica: %s"",
            connGetLastError(conn));
        freeClient(slave);
        return;
    } else {
        slave->repldboff += nwritten;
        atomicIncr(server.stat_net_repl_output_bytes, nwritten);
        if (slave->repldboff < server.rdb_pipe_bufflen) {
            slave->repl_last_partial_write = server.unixtime;
            return; /* more data to write.. */
        }
    }
    rdbPipeWriteHandlerConnRemoved(conn);
}",1479.0,1501.0,1.0,4.0,23.0,20,14,15,5,0,10,3,4,4,8,,0,6,2,1,1,void
5888,325143,rdbPipeReadHandler,1,rdbPipeReadHandler,"void rdbPipeReadHandler (aeEventLoop*,int,void*,int)",replication.c,"void rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask) {
    UNUSED(mask);
    UNUSED(clientData);
    UNUSED(eventLoop);
    int i;
    if (!server.rdb_pipe_buff)
        server.rdb_pipe_buff = zmalloc(PROTO_IOBUF_LEN);
    serverAssert(server.rdb_pipe_numconns_writing==0);

    while (1) {
        server.rdb_pipe_bufflen = read(fd, server.rdb_pipe_buff, PROTO_IOBUF_LEN);
        if (server.rdb_pipe_bufflen < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
                return;
            serverLog(LL_WARNING,""Diskless rdb transfer, read error sending DB to replicas: %s"", strerror(errno));
            for (i=0; i < server.rdb_pipe_numconns; i++) {
                connection *conn = server.rdb_pipe_conns[i];
                if (!conn)
                    continue;
                client *slave = connGetPrivateData(conn);
                freeClient(slave);
                server.rdb_pipe_conns[i] = NULL;
            }
            k...",1504.0,1596.0,1.0,4.0,93.0,97,17,84,16,0,20,22,43,2,18,,0,8,8,4,4,void
5889,325550,updateSlavesWaitingBgsave,1,updateSlavesWaitingBgsave,"void updateSlavesWaitingBgsave (int,int)",replication.c,"void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
    listNode *ln;
    listIter li;

    /* Note: there's a chance we got here from within the REPLCONF ACK command
     * so we must avoid using freeClient, otherwise we'll crash on our way up. */

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
            struct redis_stat buf;

            if (bgsaveerr != C_OK) {
                freeClientAsync(slave);
                serverLog(LL_WARNING,""SYNC failed. BGSAVE child returned an error"");
                continue;
            }

            /* If this was an RDB on disk save, we have to prepare to send
             * the RDB from disk to the slave socket. Otherwise if this was
             * already an RDB -> Slaves socket transfer, used in the case of
             * diskless replication, our work is trivial, we can just put
             * the slave online....",1604.0,1684.0,1.0,32.0,81.0,19,9,16,6,1,11,8,14,3,8,,0,6,4,2,2,void
5890,325757,changeReplicationId,1,changeReplicationId,void changeReplicationId (void),replication.c,"void changeReplicationId(void) {
    getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
    server.replid[CONFIG_RUN_ID_SIZE] = '\0';
}",1690.0,1693.0,1.0,36.0,4.0,4,3,2,1,4,1,1,1,0,1,,0,0,2,1,1,void
5891,325778,clearReplicationId2,1,clearReplicationId2,void clearReplicationId2 (void),replication.c,"void clearReplicationId2(void) {
    memset(server.replid2,'0',sizeof(server.replid));
    server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
    server.second_replid_offset = -1;
}",1698.0,1702.0,1.0,19.0,5.0,9,5,4,1,4,0,1,1,0,0,,0,0,2,1,1,void
5892,325807,shiftReplicationId,1,shiftReplicationId,void shiftReplicationId (void),replication.c,"void shiftReplicationId(void) {
    memcpy(server.replid2,server.replid,sizeof(server.replid));
    /* We set the second replid offset to the master offset + 1, since
     * the slave will ask for the first byte it has not yet received, so
     * we need to add one to the offset: for example if, as a slave, we are
     * sure we have the same history as the master for 50 bytes, after we
     * are turned into a master, we can accept a PSYNC request with offset
     * 51, since the slave asking has the same history up to the 50th
     * byte, and is asking for the new bytes starting at offset 51. */
    server.second_replid_offset = server.master_repl_offset+1;
    changeReplicationId();
    serverLog(LL_NOTICE,""Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s"", server.replid2, server.second_replid_offset, server.replid);
}",1709.0,1721.0,1.0,4.0,13.0,14,6,9,1,1,2,1,1,0,2,,0,0,2,1,1,void
5893,325860,slaveIsInHandshakeState,1,slaveIsInHandshakeState,int slaveIsInHandshakeState (void),replication.c,"int slaveIsInHandshakeState(void) {
    return server.repl_state >= REPL_STATE_RECEIVE_PING_REPLY &&
           server.repl_state <= REPL_STATE_RECEIVE_PSYNC_REPLY;
}",1727.0,1730.0,1.0,1.0,4.0,5,4,4,3,1,0,1,1,0,0,,0,0,2,1,1,int
5894,325877,replicationSendNewlineToMaster,1,replicationSendNewlineToMaster,void replicationSendNewlineToMaster (void),replication.c,"void replicationSendNewlineToMaster(void) {
    static time_t newline_sent;
    if (time(NULL) != newline_sent) {
        newline_sent = time(NULL);
        /* Pinging back in this stage is best-effort. */
        if (server.repl_transfer_s) connWrite(server.repl_transfer_s, ""\n"", 1);
    }
}",1740.0,1747.0,1.0,1.0,8.0,4,3,6,3,2,1,3,4,0,1,,0,0,2,1,1,void
5895,325904,replicationEmptyDbCallback,1,replicationEmptyDbCallback,void replicationEmptyDbCallback (dict*),replication.c,"void replicationEmptyDbCallback(dict *d) {
    UNUSED(d);
    if (server.repl_state == REPL_STATE_TRANSFER)
        replicationSendNewlineToMaster();
}",1752.0,1756.0,1.0,4.0,5.0,3,3,4,3,0,1,2,2,0,1,,0,0,2,1,1,void
5896,325923,replicationCreateMasterClient,1,replicationCreateMasterClient,"void replicationCreateMasterClient (connection*,int)",replication.c,"void replicationCreateMasterClient(connection *conn, int dbid) {
    server.master = createClient(conn);
    if (conn)
        connSetReadHandler(server.master->conn, readQueryFromClient);

    /**
     * Important note:
     * The CLIENT_DENY_BLOCKING flag is not, and should not, be set here.
     * For commands like BLPOP, it makes no sense to block the master
     * connection, and such blocking attempt will probably cause deadlock and
     * break the replication. We consider such a thing as a bug because
     * commands as BLPOP should never be sent on the replication link.
     * A possible use-case for blocking the replication link is if a module wants
     * to pass the execution to a background thread and unblock after the
     * execution is done. This is the reason why we allow blocking the replication
     * connection. */
    server.master->flags |= CLIENT_MASTER;

    server.master->authenticated = 1;
    server.master->reploff = server.master_initial_offset;
    serve...",1761.0,1790.0,1.0,28.0,30.0,37,8,21,5,2,3,4,4,0,3,,0,1,4,2,2,void
5897,326035,restartAOFAfterSYNC,1,restartAOFAfterSYNC,void restartAOFAfterSYNC (void),replication.c,"void restartAOFAfterSYNC(void) {
    unsigned int tries, max_tries = 10;
    for (tries = 0; tries < max_tries; ++tries) {
        if (startAppendOnly() == C_OK) break;
        serverLog(LL_WARNING,
            ""Failed enabling the AOF after successful master synchronization! ""
            ""Trying it again in one second."");
        sleep(1);
    }
    if (tries == max_tries) {
        serverLog(LL_WARNING,
            ""FATAL: this replica instance finished the synchronization with ""
            ""its master, but the AOF can't be turned on. Exiting now."");
        exit(1);
    }
}",1796.0,1811.0,1.0,33.0,16.0,11,5,8,3,3,3,5,5,1,3,,0,1,2,1,1,void
5898,326109,useDisklessLoad,1,useDisklessLoad,int useDisklessLoad (void),replication.c,"static int useDisklessLoad(void) {
    /* compute boolean decision to use diskless load */
    int enabled = server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB ||
           (server.repl_diskless_load == REPL_DISKLESS_LOAD_WHEN_DB_EMPTY && dbTotalServerKeyCount()==0);

    if (enabled) {
        /* Check all modules handle read errors, otherwise it's not safe to use diskless load. */
        if (!moduleAllDatatypesHandleErrors()) {
            serverLog(LL_NOTICE,
                ""Skipping diskless-load because there are modules that don't handle read errors."");
            enabled = 0;
        }
        /* Check all modules handle async replication, otherwise it's not safe to use diskless load. */
        else if (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB && !moduleAllModulesHandleReplAsyncLoad()) {
            serverLog(LL_NOTICE,
                ""Skipping diskless-load because there are modules that are not aware of async replication."");
            enabled = 0;
...",1813.0,1833.0,1.0,47.0,21.0,13,8,7,2,2,3,3,4,1,3,,0,2,2,1,1,int
5899,326201,disklessLoadInitTempDb,1,disklessLoadInitTempDb,redisDb disklessLoadInitTempDb (void),replication.c,"redisDb *disklessLoadInitTempDb(void) {
    return initTempDb();
}",1838.0,1840.0,1.0,1.0,3.0,0,0,0,0,1,1,1,1,0,1,,0,0,2,1,1,redisDb
5900,326208,disklessLoadDiscardTempDb,1,disklessLoadDiscardTempDb,void disklessLoadDiscardTempDb (redisDb*),replication.c,"void disklessLoadDiscardTempDb(redisDb *tempDb) {
    discardTempDb(tempDb, replicationEmptyDbCallback);
}",1844.0,1846.0,1.0,1.0,3.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void
5901,326216,replicationAttachToNewMaster,1,replicationAttachToNewMaster,void replicationAttachToNewMaster (void),replication.c,"void replicationAttachToNewMaster(void) { 
    /* Replica starts to apply data from new master, we must discard the cached
     * master structure. */
    serverAssert(server.master == NULL);
    replicationDiscardCachedMaster();

    disconnectSlaves(); /* Force our replicas to resync with us as well. */
    freeReplicationBacklog(); /* Don't allow our chained replicas to PSYNC. */
}",1852.0,1860.0,1.0,4.0,9.0,6,6,2,2,1,4,1,1,0,4,,0,0,2,1,1,void
5902,326242,readSyncBulkPayload,1,readSyncBulkPayload,void readSyncBulkPayload (connection*),replication.c,"void readSyncBulkPayload(connection *conn) {
    char buf[PROTO_IOBUF_LEN];
    ssize_t nread, readlen, nwritten;
    int use_diskless_load = useDisklessLoad();
    redisDb *diskless_load_tempDb = NULL;
    functionsLibCtx* temp_functions_lib_ctx = NULL;
    int empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :
                                                        EMPTYDB_NO_FLAGS;
    off_t left;

    /* Static vars used to hold the EOF mark, and the last bytes received
     * from the server: when they match, we reached the end of the transfer. */
    static char eofmark[CONFIG_RUN_ID_SIZE];
    static char lastbytes[CONFIG_RUN_ID_SIZE];
    static int usemark = 0;

    /* If repl_transfer_size == -1 we still have to read the bulk length
     * from the master reply. */
    if (server.repl_transfer_size == -1) {
        nread = connSyncReadLine(conn,buf,1024,server.repl_syncio_timeout*1000);
        if (nread == -1) {
            serverLog(LL_WARNING,
             ...",1864.0,2296.0,1.0,13.0,433.0,191,24,165,26,0,55,38,64,2,54,,0,10,2,1,1,void
5903,327613,receiveSynchronousResponse,1,receiveSynchronousResponse,char* receiveSynchronousResponse (connection*),replication.c,"char *receiveSynchronousResponse(connection *conn) {
    char buf[256];
    /* Read the reply from the server. */
    if (connSyncReadLine(conn,buf,sizeof(buf),server.repl_syncio_timeout*1000) == -1)
    {
        serverLog(LL_WARNING, ""Failed to read response from the server: %s"", connGetLastError(conn));
        return NULL;
    }
    server.repl_transfer_lastio = server.unixtime;
    return sdsnew(buf);
}",2298.0,2308.0,1.0,8.0,11.0,11,8,10,4,6,4,2,2,1,4,,0,2,2,1,1,char*
5904,327666,sendCommandRaw,1,sendCommandRaw,"char* sendCommandRaw (connection*,sds)",replication.c,"char* sendCommandRaw(connection *conn, sds cmd) {
    if (connSyncWrite(conn,cmd,sdslen(cmd),server.repl_syncio_timeout*1000) == -1) {
        return sdscatprintf(sdsempty(),""-Writing to master: %s"",
                connGetLastError(conn));
    }
    return NULL;
}",2311.0,2317.0,1.0,1.0,7.0,4,4,6,4,2,5,2,2,2,5,,0,4,4,2,2,char*
5905,327695,sendCommand,1,sendCommand,char* sendCommand (connection*...),replication.c,"char *sendCommand(connection *conn, ...) {
    va_list ap;
    sds cmd = sdsempty();
    sds cmdargs = sdsempty();
    size_t argslen = 0;
    char *arg;

    /* Create the command to send to the master, we use redis binary
     * protocol to make sure correct arguments are sent. This function
     * is not safe for all binary data. */
    va_start(ap,conn);
    while(1) {
        arg = va_arg(ap, char*);
        if (arg == NULL) break;
        cmdargs = sdscatprintf(cmdargs,""$%zu\r\n%s\r\n"",strlen(arg),arg);
        argslen++;
    }

    cmd = sdscatprintf(cmd,""*%zu\r\n"",argslen);
    cmd = sdscatsds(cmd,cmdargs);
    sdsfree(cmdargs);

    va_end(ap);
    char* err = sendCommandRaw(conn, cmd);
    sdsfree(cmd);
    if(err)
        return err;
    return NULL;
}",2328.0,2356.0,1.0,1.0,29.0,9,3,27,8,5,8,5,5,0,8,,0,6,2,1,1,char*
5906,327767,sendCommandArgv,1,sendCommandArgv,"char* sendCommandArgv (connection*,int,char**,size_t*)",replication.c,"char *sendCommandArgv(connection *conn, int argc, char **argv, size_t *argv_lens) {
    sds cmd = sdsempty();
    char *arg;
    int i;

    /* Create the command to send to the master. */
    cmd = sdscatfmt(cmd,""*%i\r\n"",argc);
    for (i=0; i<argc; i++) {
        int len;
        arg = argv[i];
        len = argv_lens ? argv_lens[i] : strlen(arg);
        cmd = sdscatfmt(cmd,""$%i\r\n"",len);
        cmd = sdscatlen(cmd,arg,len);
        cmd = sdscatlen(cmd,""\r\n"",2);
    }
    char* err = sendCommandRaw(conn, cmd);
    sdsfree(cmd);
    if (err)
        return err;
    return NULL;
}",2367.0,2387.0,1.0,1.0,21.0,13,4,31,10,1,7,3,3,0,7,,0,6,8,4,4,char*
5907,327846,slaveTryPartialResynchronization,1,slaveTryPartialResynchronization,"int slaveTryPartialResynchronization (connection*,int)",replication.c,"int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    char *psync_replid;
    char psync_offset[32];
    sds reply;

    /* Writing half */
    if (!read_reply) {
        /* Initially set master_initial_offset to -1 to mark the current
         * master replid and offset as not valid. Later if we'll be able to do
         * a FULL resync using the PSYNC command we'll set the offset at the
         * right value, so that this information will be propagated to the
         * client structure representing the master into server.master. */
        server.master_initial_offset = -1;

        if (server.cached_master) {
            psync_replid = server.cached_master->replid;
            snprintf(psync_offset,sizeof(psync_offset),""%lld"", server.cached_master->reploff+1);
            serverLog(LL_NOTICE,""Trying a partial resynchronization (request %s:%s)."", psync_replid, psync_offset);
        } else {
            serverLog(LL_NOTICE,""Partial resynchronization not po...",2443.0,2610.0,1.0,12.0,168.0,99,16,98,13,2,23,18,30,1,23,,0,3,4,2,2,int
5908,328444,syncWithMaster,1,syncWithMaster,void syncWithMaster (connection*),replication.c,"void syncWithMaster(connection *conn) {
    char tmpfile[256], *err = NULL;
    int dfd = -1, maxtries = 5;
    int psync_result;

    /* If this event fired after the user turned the instance into a master
     * with SLAVEOF NO ONE we must just return ASAP. */
    if (server.repl_state == REPL_STATE_NONE) {
        connClose(conn);
        return;
    }

    /* Check for errors in the socket: after a non blocking connect() we
     * may find that the socket is in error state. */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_WARNING,""Error condition on socket for SYNC: %s"",
                connGetLastError(conn));
        goto error;
    }

    /* Send a PING to check the master is able to reply without errors. */
    if (server.repl_state == REPL_STATE_CONNECTING) {
        serverLog(LL_NOTICE,""Non blocking connect for SYNC fired the event."");
        /* Delete the writable event so that the readable event remains
         * registered and we can wait ...",2614.0,2925.0,1.0,8.0,312.0,228,18,230,32,0,55,71,80,5,55,,0,23,2,1,1,void
5909,329505,connectWithMaster,1,connectWithMaster,int connectWithMaster (void),replication.c,"int connectWithMaster(void) {
    server.repl_transfer_s = connCreate(connTypeOfReplication());
    if (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,
                server.bind_source_addr, syncWithMaster) == C_ERR) {
        serverLog(LL_WARNING,""Unable to connect to MASTER: %s"",
                connGetLastError(server.repl_transfer_s));
        connClose(server.repl_transfer_s);
        server.repl_transfer_s = NULL;
        return C_ERR;
    }


    server.repl_transfer_lastio = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTING;
    serverLog(LL_NOTICE,""MASTER <-> REPLICA sync started"");
    return C_OK;
}",2927.0,2943.0,1.0,60.0,17.0,24,6,15,3,3,7,2,2,1,7,,0,4,2,1,1,int
5910,329607,undoConnectWithMaster,1,undoConnectWithMaster,void undoConnectWithMaster (void),replication.c,"void undoConnectWithMaster(void) {
    connClose(server.repl_transfer_s);
    server.repl_transfer_s = NULL;
}",2949.0,2952.0,1.0,1.0,4.0,3,2,3,2,1,1,1,1,0,1,,0,0,2,1,1,void
5911,329621,replicationAbortSyncTransfer,1,replicationAbortSyncTransfer,void replicationAbortSyncTransfer (void),replication.c,"void replicationAbortSyncTransfer(void) {
    serverAssert(server.repl_state == REPL_STATE_TRANSFER);
    undoConnectWithMaster();
    if (server.repl_transfer_fd!=-1) {
        close(server.repl_transfer_fd);
        bg_unlink(server.repl_transfer_tmpfile);
        zfree(server.repl_transfer_tmpfile);
        server.repl_transfer_tmpfile = NULL;
        server.repl_transfer_fd = -1;
    }
}",2957.0,2967.0,1.0,4.0,11.0,17,9,9,3,0,4,2,2,0,4,,0,0,2,1,1,void
5912,329748,replicationSetMaster,1,replicationSetMaster,"void replicationSetMaster (char*,int)",replication.c,"void replicationSetMaster(char *ip, int port) {
    int was_master = server.masterhost == NULL;

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) {
        freeClient(server.master);
    }
    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */

    /* Setting masterhost only after the call to freeClient since it calls
     * replicationHandleMasterDisconnection which can trigger a re-connect
     * directly from within that call. */
    server.masterhost = sdsnew(ip);
    server.masterport = port;

    /* Update oom_score_adj */
    setOOMScoreAdj(-1);

    /* Here we don't disconnect with replicas, since they may hopefully be able
     * to partially resync with us. We will disconnect with replicas and force
     * them to resync with us when changing replid on partially resync with new
     * master, or finishing transferring RDB and preparing loading DB on full
     * sync with new master. */

    cancelReplicationHandsh...",3003.0,3051.0,1.0,26.0,49.0,22,6,22,7,4,12,4,4,0,12,,0,1,4,2,2,void
5913,329855,replicationUnsetMaster,1,replicationUnsetMaster,void replicationUnsetMaster (void),replication.c,"void replicationUnsetMaster(void) {
    if (server.masterhost == NULL) return; /* Nothing to do. */

    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    /* Clear masterhost first, since the freeClient calls
     * replicationHandleMasterDisconnection which can attempt to re-connect. */
    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) freeClient(server.master);
    replicationDiscardCachedMaster();
    cancelReplicationHandshake(0);
    /* When a slave is turned into a master, the current replication ID
     * (that was inherited from the master at synchronization time) is
     * used as secondary ID up to the current offset, and a new replication
     * ID is created to continue with a new replication history. */
    shiftRepli...",3054.0,3108.0,1.0,30.0,55.0,24,5,19,4,5,10,5,5,0,10,,0,0,2,1,1,void
5914,329954,replicationHandleMasterDisconnection,1,replicationHandleMasterDisconnection,void replicationHandleMasterDisconnection (void),replication.c,"void replicationHandleMasterDisconnection(void) {
    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    server.master = NULL;
    server.repl_state = REPL_STATE_CONNECT;
    server.repl_down_since = server.unixtime;
    /* We lost connection with our master, don't disconnect slaves yet,
     * maybe we'll be able to PSYNC with our master later. We'll disconnect
     * the slaves only if we'll have to do a full resync with our master. */

    /* Try to re-connect immediately rather than wait for replicationCron
     * waiting 1 second may risk backlog being recycled. */
    if (server.masterhost) {
        serverLog(LL_NOTICE,""Reconnecting to MASTER %s:%d"",
            server.masterhost, server.masterport);
        connectWithMaster();
    }
}",3112.0,3133.0,1.0,30.0,22.0,15,5,13,4,2,3,3,3,0,3,,0,0,2,1,1,void
5915,330021,replicaofCommand,1,replicaofCommand,void replicaofCommand (client*),replication.c,"void replicaofCommand(client *c) {
    /* SLAVEOF is not allowed in cluster mode as replication is automatically
     * configured using the current address of the master node. */
    if (server.cluster_enabled) {
        addReplyError(c,""REPLICAOF not allowed in cluster mode."");
        return;
    }

    if (server.failover_state != NO_FAILOVER) {
        addReplyError(c,""REPLICAOF not allowed while failing over."");
        return;
    }

    /* The special host/port combination ""NO"" ""ONE"" turns the instance
     * into a master. Otherwise the new master address is set. */
    if (!strcasecmp(c->argv[1]->ptr,""no"") &&
        !strcasecmp(c->argv[2]->ptr,""one"")) {
        if (server.masterhost) {
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,""MASTER MODE enabled (user request from '%s')"",
                client);
            sdsfree(client);
        }
    } else {
        long port;

        if (c->f...",3135.0,3194.0,1.0,12.0,60.0,18,9,15,5,0,10,5,6,2,8,,0,4,2,1,1,void
5916,330233,roleCommand,1,roleCommand,void roleCommand (client*),replication.c,"void roleCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelRoleCommand(c);
        return;
    }

    if (server.masterhost == NULL) {
        listIter li;
        listNode *ln;
        void *mbcount;
        int slaves = 0;

        addReplyArrayLen(c,3);
        addReplyBulkCBuffer(c,""master"",6);
        addReplyLongLong(c,server.master_repl_offset);
        mbcount = addReplyDeferredLen(c);
        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            char ip[NET_IP_STR_LEN], *slaveaddr = slave->slave_addr;

            if (!slaveaddr) {
                if (connAddrPeerName(slave->conn,ip,sizeof(ip),NULL) == -1)
                    continue;
                slaveaddr = ip;
            }
            if (slave->replstate != SLAVE_STATE_ONLINE) continue;
            addReplyArrayLen(c,3);
            addReplyBulkCString(c,slaveaddr);
            addReplyBulkLongLong(c,slave->slave_listening_port);
 ...",3199.0,3255.0,1.0,20.0,57.0,25,10,38,10,0,19,9,15,4,13,,0,9,2,1,1,void
5917,330514,replicationCacheMaster,1,replicationCacheMaster,void replicationCacheMaster (client*),replication.c,"void replicationCacheMaster(client *c) {
    serverAssert(server.master != NULL && server.cached_master == NULL);
    serverLog(LL_NOTICE,""Caching the disconnected master state."");

    /* Unlink the client from the server structures. */
    unlinkClient(c);

    /* Reset the master client so that's ready to accept new commands:
     * we want to discard the non processed query buffers and non processed
     * offsets, including pending transactions, already populated arguments,
     * pending outputs to the master. */
    sdsclear(server.master->querybuf);
    server.master->qb_pos = 0;
    server.master->repl_applied = 0;
    server.master->read_reploff = server.master->reploff;
    if (c->flags & CLIENT_MULTI) discardTransaction(c);
    listEmpty(c->reply);
    c->sentlen = 0;
    c->reply_bytes = 0;
    c->bufpos = 0;
    resetClient(c);

    /* Save the master. Server.master will be set to null later by
     * replicationHandleMasterDisconnection(). */
    server.cached_master ...",3298.0,3339.0,1.0,4.0,42.0,46,13,28,3,1,21,4,4,3,10,,0,11,2,1,1,void
5918,330664,replicationCacheMasterUsingMyself,1,replicationCacheMasterUsingMyself,void replicationCacheMasterUsingMyself (void),replication.c,"void replicationCacheMasterUsingMyself(void) {
    serverLog(LL_NOTICE,
        ""Before turning into a replica, using my own master parameters ""
        ""to synthesize a cached master: I may be able to synchronize with ""
        ""the new master with just a partial transfer."");

    /* This will be used to populate the field server.master->reploff
     * by replicationCreateMasterClient(). We'll later set the created
     * master as server.cached_master, so the replica will use such
     * offset for PSYNC. */
    server.master_initial_offset = server.master_repl_offset;

    /* The master client we create can be set to any DBID, because
     * the new master will start its replication stream with SELECT. */
    replicationCreateMasterClient(NULL,-1);

    /* Use our own ID / offset. */
    memcpy(server.master->replid, server.replid, sizeof(server.replid));

    /* Set as cached master. */
    unlinkClient(server.master);
    server.cached_master = server.master;
    server.master ...",3350.0,3373.0,1.0,4.0,24.0,18,7,12,2,1,3,1,1,0,3,,0,0,2,1,1,void
5919,330940,refreshGoodSlavesCount,1,refreshGoodSlavesCount,void refreshGoodSlavesCount (void),replication.c,"void refreshGoodSlavesCount(void) {
    listIter li;
    listNode *ln;
    int good = 0;

    if (!server.repl_min_slaves_to_write ||
        !server.repl_min_slaves_max_lag) return;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        time_t lag = server.unixtime - slave->repl_ack_time;

        if (slave->replstate == SLAVE_STATE_ONLINE &&
            lag <= server.repl_min_slaves_max_lag) good++;
    }
    server.repl_good_slaves_count = good;
}",3430.0,3447.0,1.0,32.0,18.0,24,11,18,6,4,5,4,5,2,2,,0,4,2,1,1,void
5920,331014,checkGoodReplicasStatus,1,checkGoodReplicasStatus,int checkGoodReplicasStatus (void),replication.c,"int checkGoodReplicasStatus(void) {
    return server.masterhost || /* not a primary status should be OK */
           !server.repl_min_slaves_max_lag || /* Min slave max lag not configured */
           !server.repl_min_slaves_to_write || /* Min slave to write not configured */
           server.repl_good_slaves_count >= server.repl_min_slaves_to_write; /* check if we have enough slaves */
}",3450.0,3455.0,1.0,1.0,6.0,11,4,5,1,4,0,1,1,0,0,,0,0,2,1,1,int
5921,331041,replicationRequestAckFromSlaves,1,replicationRequestAckFromSlaves,void replicationRequestAckFromSlaves (void),replication.c,"void replicationRequestAckFromSlaves(void) {
    server.get_ack_from_slaves = 1;
}",3487.0,3489.0,1.0,1.0,3.0,2,2,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
5922,331051,replicationCountAcksByOffset,1,replicationCountAcksByOffset,int replicationCountAcksByOffset (long long),replication.c,"int replicationCountAcksByOffset(long long offset) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        if (slave->repl_ack_off >= offset) count++;
    }
    return count;
}",3493.0,3506.0,1.0,32.0,14.0,12,7,12,6,1,5,5,6,3,2,,0,4,2,1,1,int
5923,331102,replicationCountAOFAcksByOffset,1,replicationCountAOFAcksByOffset,int replicationCountAOFAcksByOffset (long long),replication.c,"int replicationCountAOFAcksByOffset(long long offset) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        if (slave->repl_aof_off >= offset) count++;
    }
    return count;
}",3510.0,3523.0,1.0,32.0,14.0,12,7,12,6,1,5,5,6,3,2,,0,4,2,1,1,int
5924,331153,waitCommand,1,waitCommand,void waitCommand (client*),replication.c,"void waitCommand(client *c) {
    mstime_t timeout;
    long numreplicas, ackreplicas;
    long long offset = c->woff;

    if (server.masterhost) {
        addReplyError(c,""WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated."");
        return;
    }

    /* Argument parsing. */
    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
        return;
    if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
        != C_OK) return;

    /* First try without blocking at all. */
    ackreplicas = replicationCountAcksByOffset(c->woff);
    if (ackreplicas >= numreplicas || c->flags & CLIENT_DENY_BLOCKING) {
        addReplyLongLong(c,ackreplicas);
        return;
    }

    /* Otherwise block the client and put it into our list of clients
     * waiting for ack from slaves. */
    blockForReplica...",3527.0,3557.0,1.0,68.0,31.0,18,10,22,7,0,12,5,5,5,7,,0,8,2,1,1,void
5925,331243,waitaofCommand,1,waitaofCommand,void waitaofCommand (client*),replication.c,"void waitaofCommand(client *c) {
    mstime_t timeout;
    long numreplicas, numlocal, ackreplicas, acklocal;

    /* Argument parsing. */
    if (getRangeLongFromObjectOrReply(c,c->argv[1],0,1,&numlocal,NULL) != C_OK)
        return;
    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&numreplicas,NULL) != C_OK)
        return;
    if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_MILLISECONDS) != C_OK)
        return;

    if (server.masterhost) {
        addReplyError(c,""WAITAOF cannot be used with replica instances. Please also note that writes to replicas are just local and are not propagated."");
        return;
    }
    if (numlocal && !server.aof_enabled) {
        addReplyError(c, ""WAITAOF cannot be used when numlocal is set but appendonly is disabled."");
        return;
    }

    /* First try without blocking at all. */
    ackreplicas = replicationCountAOFAcksByOffset(c->woff);
    acklocal = server.fsynced_reploff >= c->woff;
    if ((ackreplicas >= numreplic...",3561.0,3599.0,1.0,74.0,39.0,30,12,36,8,0,18,7,7,7,11,,0,11,2,1,1,void
5926,331382,unblockClientWaitingReplicas,1,unblockClientWaitingReplicas,void unblockClientWaitingReplicas (client*),replication.c,"void unblockClientWaitingReplicas(client *c) {
    listNode *ln = listSearchKey(server.clients_waiting_acks,c);
    serverAssert(ln != NULL);
    listDelNode(server.clients_waiting_acks,ln);
    updateStatsOnUnblock(c, 0, 0, 0);
}",3605.0,3610.0,1.0,4.0,6.0,8,7,8,4,0,4,1,1,0,4,,0,1,2,1,1,void
5927,331421,processClientsWaitingReplicas,1,processClientsWaitingReplicas,void processClientsWaitingReplicas (void),replication.c,"void processClientsWaitingReplicas(void) {
    long long last_offset = 0;
    long long last_aof_offset = 0;
    int last_numreplicas = 0;
    int last_aof_numreplicas = 0;

    listIter li;
    listNode *ln;

    listRewind(server.clients_waiting_acks,&li);
    while((ln = listNext(&li))) {
        int numlocal = 0;
        int numreplicas = 0;

        client *c = ln->value;
        int is_wait_aof = c->bstate.btype == BLOCKED_WAITAOF;

        if (is_wait_aof && c->bstate.numlocal && !server.aof_enabled) {
            addReplyError(c, ""WAITAOF cannot be used when numlocal is set but appendonly is disabled."");
            unblockClient(c, 1);
            continue;
        }

        /* Every time we find a client that is satisfied for a given
         * offset and number of replicas, we remember it so the next client
         * may be unblocked without calling replicationCountAcksByOffset()
         * or calling replicationCountAOFAcksByOffset()
         * if the requested offset ...",3614.0,3685.0,1.0,1.0,72.0,41,9,41,12,1,15,9,13,5,8,,0,8,2,1,1,void
5928,331650,replicationGetSlaveOffset,1,replicationGetSlaveOffset,long long replicationGetSlaveOffset (void),replication.c,"long long replicationGetSlaveOffset(void) {
    long long offset = 0;

    if (server.masterhost != NULL) {
        if (server.master) {
            offset = server.master->reploff;
        } else if (server.cached_master) {
            offset = server.cached_master->reploff;
        }
    }
    /* offset may be -1 when the master does not support it at all, however
     * this function is designed to return an offset that can express the
     * amount of data processed by the master, so we return a positive
     * integer. */
    if (offset < 0) offset = 0;
    return offset;
}",3689.0,3705.0,1.0,1.0,17.0,9,5,9,3,4,0,4,5,0,0,,0,0,2,1,1,long long
5929,331702,replicationCron,1,replicationCron,void replicationCron (void),replication.c,"void replicationCron(void) {
    static long long replication_cron_loops = 0;

    /* Check failover status first, to see if we need to start
     * handling the failover. */
    updateFailoverStatus();

    /* Non blocking connection timeout? */
    if (server.masterhost &&
        (server.repl_state == REPL_STATE_CONNECTING ||
         slaveIsInHandshakeState()) &&
         (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
    {
        serverLog(LL_WARNING,""Timeout connecting to the MASTER..."");
        cancelReplicationHandshake(1);
    }

    /* Bulk transfer I/O timeout? */
    if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER &&
        (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
    {
        serverLog(LL_WARNING,""Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."");
        cancelReplicationHandshake(1);
    }

    /* Timed out master wh...",3710.0,3905.0,1.0,8.0,196.0,176,24,102,16,1,45,23,37,9,32,,0,19,2,1,1,void
5930,332301,shouldStartChildReplication,1,shouldStartChildReplication,"int shouldStartChildReplication (int*,int*)",replication.c,"int shouldStartChildReplication(int *mincapa_out, int *req_out) {
    /* We should start a BGSAVE good for replication if we have slaves in
     * WAIT_BGSAVE_START state.
     *
     * In case of diskless replication, we make sure to wait the specified
     * number of seconds (according to configuration) so that other slaves
     * have the time to arrive before we start streaming. */
    if (!hasActiveChildProcess()) {
        time_t idle, max_idle = 0;
        int slaves_waiting = 0;
        int mincapa;
        int req;
        int first = 1;
        listNode *ln;
        listIter li;

        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
                if (first) {
                    /* Get first slave's requirements */
                    req = slave->slave_req;
                } else if (req != slave->slave_req) {
                    /* Skip sl...",3907.0,3957.0,1.0,36.0,51.0,43,15,40,12,1,9,9,23,3,3,,0,8,4,2,2,int
5931,332452,replicationStartPendingFork,1,replicationStartPendingFork,void replicationStartPendingFork (void),replication.c,"void replicationStartPendingFork(void) {
    int mincapa = -1;
    int req = -1;

    if (shouldStartChildReplication(&mincapa, &req)) {
        /* Start the BGSAVE. The called function may start a
         * BGSAVE with socket target or disk target depending on the
         * configuration and slaves capabilities and requirements. */
        startBgsaveForReplication(mincapa, req);
    }
}",3959.0,3969.0,1.0,1.0,11.0,6,3,6,2,2,2,2,2,1,2,,0,1,2,1,1,void
5932,332477,findReplica,1,findReplica,"client findReplica (char*,int)",replication.c,"static client *findReplica(char *host, int port) {
    listIter li;
    listNode *ln;
    client *replica;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        replica = ln->value;
        char ip[NET_IP_STR_LEN], *replicaip = replica->slave_addr;

        if (!replicaip) {
            if (connAddrPeerName(replica->conn, ip, sizeof(ip), NULL) == -1)
                continue;
            replicaip = ip;
        }

        if (!strcasecmp(host, replicaip) &&
                (port == replica->slave_listening_port))
            return replica;
    }

    return NULL;
}",3972.0,3994.0,1.0,16.0,23.0,18,9,21,9,2,7,6,9,4,3,,0,6,4,2,2,client
5933,332548,getFailoverStateString,1,getFailoverStateString,const char* getFailoverStateString (void),replication.c,"const char *getFailoverStateString(void) {
    switch(server.failover_state) {
        case NO_FAILOVER: return ""no-failover"";
        case FAILOVER_IN_PROGRESS: return ""failover-in-progress"";
        case FAILOVER_WAIT_FOR_SYNC: return ""waiting-for-sync"";
        default: return ""unknown"";
    }
}",3996.0,4003.0,1.0,1.0,8.0,1,1,4,4,1,0,2,2,0,0,,0,0,2,1,1,const char*
5934,332573,clearFailoverState,1,clearFailoverState,void clearFailoverState (void),replication.c,"void clearFailoverState(void) {
    server.failover_end_time = 0;
    server.force_failover = 0;
    zfree(server.target_replica_host);
    server.target_replica_host = NULL;
    server.target_replica_port = 0;
    server.failover_state = NO_FAILOVER;
    unpauseActions(PAUSE_DURING_FAILOVER);
}",4008.0,4016.0,1.0,1.0,9.0,11,2,9,4,2,2,1,1,0,2,,0,0,2,1,1,void
5935,332609,abortFailover,1,abortFailover,void abortFailover (char*),replication.c,"void abortFailover(const char *err) {
    if (server.failover_state == NO_FAILOVER) return;

    if (server.target_replica_host) {
        serverLog(LL_NOTICE,""FAILOVER to %s:%d aborted: %s"",
            server.target_replica_host,server.target_replica_port,err);  
    } else {
        serverLog(LL_NOTICE,""FAILOVER to any replica aborted: %s"",err);  
    }
    if (server.failover_state == FAILOVER_IN_PROGRESS) {
        replicationUnsetMaster();
    }
    clearFailoverState();
}",4019.0,4032.0,1.0,8.0,14.0,10,4,9,4,2,3,4,4,0,3,,0,0,2,1,1,void
5936,332682,failoverCommand,1,failoverCommand,void failoverCommand (client*),replication.c,"void failoverCommand(client *c) {
    if (server.cluster_enabled) {
        addReplyError(c,""FAILOVER not allowed in cluster mode. ""
                        ""Use CLUSTER FAILOVER command instead."");
        return;
    }
    
    /* Handle special case for abort */
    if ((c->argc == 2) && !strcasecmp(c->argv[1]->ptr,""abort"")) {
        if (server.failover_state == NO_FAILOVER) {
            addReplyError(c, ""No failover in progress."");
            return;
        }

        abortFailover(""Failover manually aborted"");
        addReply(c,shared.ok);
        return;
    }

    long timeout_in_ms = 0;
    int force_flag = 0;
    long port = 0;
    char *host = NULL;

    /* Parse the command for syntax and arguments. */
    for (int j = 1; j < c->argc; j++) {
        if (!strcasecmp(c->argv[j]->ptr,""timeout"") && (j + 1 < c->argc) &&
            timeout_in_ms == 0)
        {
            if (getLongFromObjectOrReply(c,c->argv[j + 1],
                        &timeout_in_ms,NULL) != C_OK)...",4061.0,4168.0,1.0,48.0,108.0,73,17,71,15,0,25,16,24,8,18,,0,11,2,1,1,void
5937,333085,updateFailoverStatus,1,updateFailoverStatus,void updateFailoverStatus (void),replication.c,"void updateFailoverStatus(void) {
    if (server.failover_state != FAILOVER_WAIT_FOR_SYNC) return;
    mstime_t now = server.mstime;

    /* Check if failover operation has timed out */
    if (server.failover_end_time && server.failover_end_time <= now) {
        if (server.force_failover) {
            serverLog(LL_NOTICE,
                ""FAILOVER to %s:%d time out exceeded, failing over."",
                server.target_replica_host, server.target_replica_port);
            server.failover_state = FAILOVER_IN_PROGRESS;
            /* If timeout has expired force a failover if requested. */
            replicationSetMaster(server.target_replica_host,
                server.target_replica_port);
            return;
        } else {
            /* Force was not requested, so timeout. */
            abortFailover(""Replica never caught up before timeout"");
            return;
        }
    }

    /* Check to see if the replica has caught up so failover can start */
    client *replica...",4177.0,4239.0,1.0,12.0,63.0,36,9,31,6,2,6,6,7,1,5,,0,2,2,1,1,void
5938,333309,parseBulk,1,parseBulk,"int parseBulk (ReplyParser*,void*)",resp_parser.c,"static int parseBulk(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long bulklen;
    parser->curr_location = p + 2; /* for \r\n */

    string2ll(proto+1,p-proto-1,&bulklen);
    if (bulklen == -1) {
        parser->callbacks.null_bulk_string_callback(p_ctx, proto, parser->curr_location - proto);
    } else {
        const char *str = parser->curr_location;
        parser->curr_location += bulklen;
        parser->curr_location += 2; /* for \r\n */
        parser->callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser->curr_location - proto);
    }

    return C_OK;
}",61.0,78.0,1.0,11.0,18.0,17,8,16,5,1,6,2,2,0,2,,0,4,4,2,2,int
5939,333404,parseSimpleString,1,parseSimpleString,"int parseSimpleString (ReplyParser*,void*)",resp_parser.c,"static int parseSimpleString(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",80.0,86.0,1.0,11.0,7.0,14,5,14,4,1,5,1,1,0,1,,0,4,4,2,2,int
5940,333456,parseError,1,parseError,"int parseError (ReplyParser*,void*)",resp_parser.c,"static int parseError(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; // for \r\n
    parser->callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",88.0,94.0,1.0,11.0,7.0,14,5,14,4,1,5,1,1,0,1,,0,4,4,2,2,int
5941,333508,parseLong,1,parseLong,"int parseLong (ReplyParser*,void*)",resp_parser.c,"static int parseLong(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    long long val;
    string2ll(proto+1,p-proto-1,&val);
    parser->callbacks.long_callback(p_ctx, val, proto, parser->curr_location - proto);
    return C_OK;
}",96.0,104.0,1.0,11.0,9.0,15,6,16,5,1,6,1,1,0,2,,0,4,4,2,2,int
5942,333565,parseAttributes,1,parseAttributes,"int parseAttributes (ReplyParser*,void*)",resp_parser.c,"static int parseAttributes(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.attribute_callback(parser, p_ctx, len, proto);
    return C_OK;
}",106.0,115.0,1.0,11.0,10.0,13,7,16,5,1,5,1,1,0,2,,0,3,4,2,2,int
5943,333619,parseVerbatimString,1,parseVerbatimString,"int parseVerbatimString (ReplyParser*,void*)",resp_parser.c,"static int parseVerbatimString(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long bulklen;
    parser->curr_location = p + 2; /* for \r\n */
    string2ll(proto+1,p-proto-1,&bulklen);
    const char *format = parser->curr_location;
    parser->curr_location += bulklen;
    parser->curr_location += 2; /* for \r\n */
    parser->callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser->curr_location - proto);
    return C_OK;
}",117.0,128.0,1.0,11.0,12.0,23,7,23,6,1,9,1,1,0,2,,0,7,4,2,2,int
5944,333698,parseBigNumber,1,parseBigNumber,"int parseBigNumber (ReplyParser*,void*)",resp_parser.c,"static int parseBigNumber(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",130.0,136.0,1.0,11.0,7.0,14,5,14,4,1,5,1,1,0,1,,0,4,4,2,2,int
5945,333750,parseNull,1,parseNull,"int parseNull (ReplyParser*,void*)",resp_parser.c,"static int parseNull(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.null_callback(p_ctx, proto, parser->curr_location - proto);
    return C_OK;
}",138.0,144.0,1.0,11.0,7.0,11,5,11,4,1,5,1,1,0,1,,0,4,4,2,2,int
5946,333794,parseDouble,1,parseDouble,"int parseDouble (ReplyParser*,void*)",resp_parser.c,"static int parseDouble(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    char buf[MAX_LONG_DOUBLE_CHARS+1];
    size_t len = p-proto-1;
    double d;
    if (len <= MAX_LONG_DOUBLE_CHARS) {
        memcpy(buf,proto+1,len);
        buf[len] = '\0';
        d = strtod(buf,NULL); /* We expect a valid representation. */
    } else {
        d = 0;
    }
    parser->callbacks.double_callback(p_ctx, d, proto, parser->curr_location - proto);
    return C_OK;
}",146.0,162.0,1.0,13.0,17.0,20,8,24,8,1,5,2,2,0,1,,0,4,4,2,2,int
5947,333879,parseBool,1,parseBool,"int parseBool (ReplyParser*,void*)",resp_parser.c,"static int parseBool(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.bool_callback(p_ctx, proto[1] == 't', proto, parser->curr_location - proto);
    return C_OK;
}",164.0,170.0,1.0,11.0,7.0,13,7,12,4,1,5,1,1,0,1,,0,4,4,2,2,int
5948,333928,parseArray,1,parseArray,"int parseArray (ReplyParser*,void*)",resp_parser.c,"static int parseArray(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    if (len == -1) {
        parser->callbacks.null_array_callback(p_ctx, proto, parser->curr_location - proto);
    } else {
        parser->callbacks.array_callback(parser, p_ctx, len, proto);
    }
    return C_OK;
}",172.0,185.0,1.0,11.0,14.0,17,9,17,5,1,6,2,2,0,2,,0,4,4,2,2,int
5949,334003,parseSet,1,parseSet,"int parseSet (ReplyParser*,void*)",resp_parser.c,"static int parseSet(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.set_callback(parser, p_ctx, len, proto);
    return C_OK;
}",187.0,196.0,1.0,11.0,10.0,13,7,16,5,1,5,1,1,0,2,,0,3,4,2,2,int
5950,334057,parseMap,1,parseMap,"int parseMap (ReplyParser*,void*)",resp_parser.c,"static int parseMap(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.map_callback(parser, p_ctx, len, proto);
    return C_OK;
}",198.0,207.0,1.0,11.0,10.0,13,7,16,5,1,5,1,1,0,2,,0,3,4,2,2,int
5951,334111,parseReply,1,parseReply,"int parseReply (ReplyParser*,void*)",resp_parser.c,"int parseReply(ReplyParser *parser, void *p_ctx) {
    switch (parser->curr_location[0]) {
        case '$': return parseBulk(parser, p_ctx);
        case '+': return parseSimpleString(parser, p_ctx);
        case '-': return parseError(parser, p_ctx);
        case ':': return parseLong(parser, p_ctx);
        case '*': return parseArray(parser, p_ctx);
        case '~': return parseSet(parser, p_ctx);
        case '%': return parseMap(parser, p_ctx);
        case '#': return parseBool(parser, p_ctx);
        case ',': return parseDouble(parser, p_ctx);
        case '_': return parseNull(parser, p_ctx);
        case '(': return parseBigNumber(parser, p_ctx);
        case '=': return parseVerbatimString(parser, p_ctx);
        case '|': return parseAttributes(parser, p_ctx);
        default: if (parser->callbacks.error) parser->callbacks.error(p_ctx);
    }
    return C_ERR;
}",210.0,228.0,1.0,11.0,19.0,7,4,30,2,4,17,3,4,2,14,,0,3,4,2,2,int
5952,334232,null_array_callback,1,ReplyParserCallbacks.null_array_callback,"void ReplyParserCallbacks.null_array_callback (void*,char*,size_t)",resp_parser.h,"void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);",39.0,39.0,10.0,79.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
5953,334239,null_bulk_string_callback,1,ReplyParserCallbacks.null_bulk_string_callback,"void ReplyParserCallbacks.null_bulk_string_callback (void*,char*,size_t)",resp_parser.h,"void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);",42.0,42.0,10.0,85.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
5954,334246,bulk_string_callback,1,ReplyParserCallbacks.bulk_string_callback,"void ReplyParserCallbacks.bulk_string_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*bulk_string_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",45.0,45.0,10.0,109.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
5955,334255,error_callback,1,ReplyParserCallbacks.error_callback,"void ReplyParserCallbacks.error_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",48.0,48.0,10.0,103.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
5956,334264,simple_str_callback,1,ReplyParserCallbacks.simple_str_callback,"void ReplyParserCallbacks.simple_str_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",51.0,51.0,10.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
5957,334273,long_callback,1,ReplyParserCallbacks.long_callback,"void ReplyParserCallbacks.long_callback (void*,long long,char*,size_t)",resp_parser.h,"void (*long_callback)(void *ctx, long long val, const char *proto, size_t proto_len);",54.0,54.0,10.0,88.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
5958,334281,array_callback,1,ReplyParserCallbacks.array_callback,"void ReplyParserCallbacks.array_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*array_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",57.0,57.0,10.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
5959,334289,set_callback,1,ReplyParserCallbacks.set_callback,"void ReplyParserCallbacks.set_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*set_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",60.0,60.0,10.0,94.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
5960,334297,map_callback,1,ReplyParserCallbacks.map_callback,"void ReplyParserCallbacks.map_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*map_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",63.0,63.0,10.0,94.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
5961,334305,bool_callback,1,ReplyParserCallbacks.bool_callback,"void ReplyParserCallbacks.bool_callback (void*,int,char*,size_t)",resp_parser.h,"void (*bool_callback)(void *ctx, int val, const char *proto, size_t proto_len);",66.0,66.0,10.0,82.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
5962,334313,double_callback,1,ReplyParserCallbacks.double_callback,"void ReplyParserCallbacks.double_callback (void*,double,char*,size_t)",resp_parser.h,"void (*double_callback)(void *ctx, double val, const char *proto, size_t proto_len);",69.0,69.0,10.0,87.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
5963,334321,big_number_callback,1,ReplyParserCallbacks.big_number_callback,"void ReplyParserCallbacks.big_number_callback (void*,char*,size_t,char*,size_t)",resp_parser.h,"void (*big_number_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",72.0,72.0,10.0,108.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
5964,334330,verbatim_string_callback,1,ReplyParserCallbacks.verbatim_string_callback,"void ReplyParserCallbacks.verbatim_string_callback (void*,char*,char*,size_t,char*,size_t)",resp_parser.h,"void (*verbatim_string_callback)(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len);",75.0,75.0,10.0,133.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,void
5965,334340,attribute_callback,1,ReplyParserCallbacks.attribute_callback,"void ReplyParserCallbacks.attribute_callback (ReplyParser*,void*,size_t,char*)",resp_parser.h,"void (*attribute_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",78.0,78.0,10.0,100.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
5966,334348,null_callback,1,ReplyParserCallbacks.null_callback,"void ReplyParserCallbacks.null_callback (void*,char*,size_t)",resp_parser.h,"void (*null_callback)(void *ctx, const char *proto, size_t proto_len);",81.0,81.0,10.0,73.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
5967,334355,error,1,ReplyParserCallbacks.error,void ReplyParserCallbacks.error (void*),resp_parser.h,void (*error)(void *ctx);,83.0,83.0,10.0,28.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
5968,334395,rioBufferWrite,1,rioBufferWrite,"size_t rioBufferWrite (rio*,void*,size_t)",rio.c,"static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
    r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
    r->io.buffer.pos += len;
    return 1;
}",62.0,66.0,1.0,1.0,5.0,12,5,6,3,0,1,1,1,0,1,,0,1,6,3,3,size_t
5969,334433,rioBufferRead,1,rioBufferRead,"size_t rioBufferRead (rio*,void*,size_t)",rio.c,"static size_t rioBufferRead(rio *r, void *buf, size_t len) {
    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len)
        return 0; /* not enough buffer to return len bytes. */
    memcpy(buf,r->io.buffer.ptr+r->io.buffer.pos,len);
    r->io.buffer.pos += len;
    return 1;
}",69.0,75.0,1.0,1.0,7.0,19,6,9,3,0,1,2,2,1,1,,0,1,6,3,3,size_t
5970,334491,rioBufferTell,1,rioBufferTell,off_t rioBufferTell (rio*),rio.c,"static off_t rioBufferTell(rio *r) {
    return r->io.buffer.pos;
}",78.0,80.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,off_t
5971,334504,rioBufferFlush,1,rioBufferFlush,int rioBufferFlush (rio*),rio.c,"static int rioBufferFlush(rio *r) {
    UNUSED(r);
    return 1; /* Nothing to do, our write just appends to the buffer. */
}",84.0,87.0,1.0,4.0,4.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,int
5972,334534,rioInitWithBuffer,1,rioInitWithBuffer,"void rioInitWithBuffer (rio*,sds)",rio.c,"void rioInitWithBuffer(rio *r, sds s) {
    *r = rioBufferIO;
    r->io.buffer.ptr = s;
    r->io.buffer.pos = 0;
}",102.0,106.0,1.0,1.0,5.0,10,4,5,3,8,1,1,1,0,0,,0,1,4,2,2,void
5973,334562,rioFileWrite,1,rioFileWrite,"size_t rioFileWrite (rio*,void*,size_t)",rio.c,"static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
    if (!r->io.file.autosync) return fwrite(buf,len,1,r->io.file.fp);

    size_t nwritten = 0;
    /* Incrementally write data to the file, avoid a single write larger than
     * the autosync threshold (so that the kernel's buffer cache never has too
     * many dirty pages at once). */
    while (len != nwritten) {
        serverAssert(r->io.file.autosync > r->io.file.buffered);
        size_t nalign = (size_t)(r->io.file.autosync - r->io.file.buffered);
        size_t towrite = nalign > len-nwritten ? len-nwritten : nalign;

        if (fwrite((char*)buf+nwritten,towrite,1,r->io.file.fp) == 0) return 0;
        nwritten += towrite;
        r->io.file.buffered += towrite;

        if (r->io.file.buffered >= r->io.file.autosync) {
            fflush(r->io.file.fp);

            size_t processed = r->processed_bytes + nwritten;
            serverAssert(processed % r->io.file.autosync == 0);
            serverAssert(r...",111.0,168.0,1.0,8.0,58.0,95,17,42,7,0,4,7,13,0,4,,0,0,6,3,3,size_t
5974,334835,rioFileRead,1,rioFileRead,"size_t rioFileRead (rio*,void*,size_t)",rio.c,"static size_t rioFileRead(rio *r, void *buf, size_t len) {
    return fread(buf,len,1,r->io.file.fp);
}",171.0,173.0,1.0,1.0,3.0,3,2,3,3,0,0,1,1,0,0,,0,0,6,3,3,size_t
5975,334854,rioFileTell,1,rioFileTell,off_t rioFileTell (rio*),rio.c,"static off_t rioFileTell(rio *r) {
    return ftello(r->io.file.fp);
}",176.0,178.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,off_t
5976,334868,rioFileFlush,1,rioFileFlush,int rioFileFlush (rio*),rio.c,"static int rioFileFlush(rio *r) {
    return (fflush(r->io.file.fp) == 0) ? 1 : 0;
}",182.0,184.0,1.0,1.0,3.0,5,4,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
5977,334904,rioInitWithFile,1,rioInitWithFile,"void rioInitWithFile (rio*,FILE*)",rio.c,"void rioInitWithFile(rio *r, FILE *fp) {
    *r = rioFileIO;
    r->io.file.fp = fp;
    r->io.file.buffered = 0;
    r->io.file.autosync = 0;
    r->io.file.reclaim_cache = 0;
}",199.0,205.0,1.0,1.0,7.0,18,4,7,3,3,1,1,1,0,0,,0,1,4,2,2,void
5978,334950,rioConnWrite,1,rioConnWrite,"size_t rioConnWrite (rio*,void*,size_t)",rio.c,"static size_t rioConnWrite(rio *r, const void *buf, size_t len) {
    UNUSED(r);
    UNUSED(buf);
    UNUSED(len);
    return 0; /* Error, this target does not yet support writing. */
}",213.0,218.0,1.0,4.0,6.0,3,1,6,3,1,0,1,1,0,0,,0,0,6,3,3,size_t
5979,334977,rioConnRead,1,rioConnRead,"size_t rioConnRead (rio*,void*,size_t)",rio.c,"static size_t rioConnRead(rio *r, void *buf, size_t len) {
    size_t avail = sdslen(r->io.conn.buf)-r->io.conn.pos;

    /* If the buffer is too small for the entire request: realloc. */
    if (sdslen(r->io.conn.buf) + sdsavail(r->io.conn.buf) < len)
        r->io.conn.buf = sdsMakeRoomFor(r->io.conn.buf, len - sdslen(r->io.conn.buf));

    /* If the remaining unused buffer is not large enough: memmove so that we
     * can read the rest. */
    if (len > avail && sdsavail(r->io.conn.buf) < len - avail) {
        sdsrange(r->io.conn.buf, r->io.conn.pos, -1);
        r->io.conn.pos = 0;
    }

    /* Make sure the caller didn't request to read past the limit.
     * If they didn't we'll buffer till the limit, if they did, we'll
     * return an error. */
    if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {
        errno = EOVERFLOW;
        return 0;
    }

    /* If we don't already have all the data in the sds, read more */
    while (len ...",221.0,273.0,1.0,32.0,53.0,145,15,66,10,0,14,8,11,5,14,,0,12,6,3,3,size_t
5980,335376,rioConnTell,1,rioConnTell,off_t rioConnTell (rio*),rio.c,"static off_t rioConnTell(rio *r) {
    return r->io.conn.read_so_far;
}",276.0,278.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,off_t
5981,335389,rioConnFlush,1,rioConnFlush,int rioConnFlush (rio*),rio.c,"static int rioConnFlush(rio *r) {
    /* Our flush is implemented by the write method, that recognizes a
     * buffer set to NULL with a count of zero as a flush request. */
    return rioConnWrite(r,NULL,0);
}",282.0,286.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
5982,335416,rioInitWithConn,1,rioInitWithConn,"void rioInitWithConn (rio*,connection*,size_t)",rio.c,"void rioInitWithConn(rio *r, connection *conn, size_t read_limit) {
    *r = rioConnIO;
    r->io.conn.conn = conn;
    r->io.conn.pos = 0;
    r->io.conn.read_limit = read_limit;
    r->io.conn.read_so_far = 0;
    r->io.conn.buf = sdsnewlen(NULL, PROTO_IOBUF_LEN);
    sdsclear(r->io.conn.buf);
}",303.0,311.0,1.0,37.0,9.0,26,5,11,5,1,3,1,1,0,2,,0,2,6,3,3,void
5983,335486,rioFreeConn,1,rioFreeConn,"void rioFreeConn (rio*,sds*)",rio.c,"void rioFreeConn(rio *r, sds *remaining) {
    if (remaining && (size_t)r->io.conn.pos < sdslen(r->io.conn.buf)) {
        if (r->io.conn.pos > 0) sdsrange(r->io.conn.buf, r->io.conn.pos, -1);
        *remaining = r->io.conn.buf;
    } else {
        sdsfree(r->io.conn.buf);
        if (remaining) *remaining = NULL;
    }
    r->io.conn.buf = NULL;
}",315.0,324.0,1.0,1.0,10.0,29,9,10,3,2,2,3,4,1,2,,0,1,4,2,2,void
5984,335578,rioFdWrite,1,rioFdWrite,"size_t rioFdWrite (rio*,void*,size_t)",rio.c,"static size_t rioFdWrite(rio *r, const void *buf, size_t len) {
    ssize_t retval;
    unsigned char *p = (unsigned char*) buf;
    int doflush = (buf == NULL && len == 0);

    /* For small writes, we rather keep the data in user-space buffer, and flush
     * it only when it grows. however for larger writes, we prefer to flush
     * any pre-existing buffer, and write the new one directly without reallocs
     * and memory copying. */
    if (len > PROTO_IOBUF_LEN) {
        /* First, flush any pre-existing buffered data. */
        if (sdslen(r->io.fd.buf)) {
            if (rioFdWrite(r, NULL, 0) == 0)
                return 0;
        }
        /* Write the new data, keeping 'p' and 'len' from the input. */
    } else {
        if (len) {
            r->io.fd.buf = sdscatlen(r->io.fd.buf,buf,len);
            if (sdslen(r->io.fd.buf) > PROTO_IOBUF_LEN)
                doflush = 1;
            if (!doflush)
                return 1;
        }
        /* Flushing the buffered da...",337.0,384.0,1.0,14.0,48.0,38,14,33,12,1,2,9,16,1,2,,0,1,6,3,3,size_t
5985,335778,rioFdRead,1,rioFdRead,"size_t rioFdRead (rio*,void*,size_t)",rio.c,"static size_t rioFdRead(rio *r, void *buf, size_t len) {
    UNUSED(r);
    UNUSED(buf);
    UNUSED(len);
    return 0; /* Error, this target does not support reading. */
}",387.0,392.0,1.0,4.0,6.0,3,1,6,3,0,0,1,1,0,0,,0,0,6,3,3,size_t
5986,335805,rioFdTell,1,rioFdTell,off_t rioFdTell (rio*),rio.c,"static off_t rioFdTell(rio *r) {
    return r->io.fd.pos;
}",395.0,397.0,1.0,1.0,3.0,3,2,1,1,0,0,1,1,0,0,,0,0,2,1,1,off_t
5987,335818,rioFdFlush,1,rioFdFlush,int rioFdFlush (rio*),rio.c,"static int rioFdFlush(rio *r) {
    /* Our flush is implemented by the write method, that recognizes a
     * buffer set to NULL with a count of zero as a flush request. */
    return rioFdWrite(r,NULL,0);
}",401.0,405.0,1.0,1.0,5.0,0,0,2,2,0,1,1,1,0,1,,0,0,2,1,1,int
5988,335845,rioInitWithFd,1,rioInitWithFd,"void rioInitWithFd (rio*,int)",rio.c,"void rioInitWithFd(rio *r, int fd) {
    *r = rioFdIO;
    r->io.fd.fd = fd;
    r->io.fd.pos = 0;
    r->io.fd.buf = sdsempty();
}",420.0,425.0,1.0,1.0,6.0,14,4,6,3,1,2,1,1,0,1,,0,2,4,2,2,void
5989,335882,rioFreeFd,1,rioFreeFd,void rioFreeFd (rio*),rio.c,"void rioFreeFd(rio *r) {
    sdsfree(r->io.fd.buf);
}",428.0,430.0,1.0,1.0,3.0,3,2,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
5990,335895,rioGenericUpdateChecksum,1,rioGenericUpdateChecksum,"void rioGenericUpdateChecksum (rio*,void*,size_t)",rio.c,"void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
    r->cksum = crc64(r->cksum,buf,len);
}",436.0,438.0,1.0,1.0,3.0,3,2,4,3,1,1,1,1,0,1,,0,1,6,3,3,void
5991,335912,rioSetAutoSync,1,rioSetAutoSync,"void rioSetAutoSync (rio*,off_t)",rio.c,"void rioSetAutoSync(rio *r, off_t bytes) {
    if(r->write != rioFileIO.write) return;
    r->io.file.autosync = bytes;
}",448.0,451.0,1.0,1.0,4.0,7,4,4,3,1,1,2,2,1,0,,0,1,4,2,2,void
5992,335937,rioSetReclaimCache,1,rioSetReclaimCache,"void rioSetReclaimCache (rio*,int)",rio.c,"void rioSetReclaimCache(rio *r, int enabled) {
    r->io.file.reclaim_cache = enabled;
}",458.0,460.0,1.0,1.0,3.0,4,3,2,2,1,0,1,1,0,0,,0,0,4,2,2,void
5993,335952,rioCheckType,1,rioCheckType,uint8_t rioCheckType (rio*),rio.c,"uint8_t rioCheckType(rio *r) {
    if (r->read == rioFileRead) {
        return RIO_TYPE_FILE;
    } else if (r->read == rioBufferRead) {
        return RIO_TYPE_BUFFER;
    } else if (r->read == rioConnRead) {
        return RIO_TYPE_CONN;
    } else {
        /* r->read == rioFdRead */
        return RIO_TYPE_FD;
    }
}",463.0,474.0,1.0,15.0,12.0,3,3,1,1,1,0,2,2,0,0,,0,0,2,1,1,uint8_t
5994,336008,rioWriteBulkCount,1,rioWriteBulkCount,"size_t rioWriteBulkCount (rio*,char,long)",rio.c,"size_t rioWriteBulkCount(rio *r, char prefix, long count) {
    char cbuf[128];
    int clen;

    cbuf[0] = prefix;
    clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
    cbuf[clen++] = '\r';
    cbuf[clen++] = '\n';
    if (rioWrite(r,cbuf,clen) == 0) return 0;
    return clen;
}",482.0,492.0,1.0,1.0,11.0,14,7,14,5,14,2,2,2,1,2,,0,2,6,3,3,size_t
5995,336059,rioWriteBulkString,1,rioWriteBulkString,"size_t rioWriteBulkString (rio*,char*,size_t)",rio.c,"size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {
    size_t nwritten;

    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) return 0;
    if (len > 0 && rioWrite(r,buf,len) == 0) return 0;
    if (rioWrite(r,""\r\n"",2) == 0) return 0;
    return nwritten+len+2;
}",495.0,502.0,1.0,1.0,8.0,8,5,10,4,42,3,4,4,3,3,,0,3,6,3,3,size_t
5996,336109,rioWriteBulkLongLong,1,rioWriteBulkLongLong,"size_t rioWriteBulkLongLong (rio*,long long)",rio.c,"size_t rioWriteBulkLongLong(rio *r, long long l) {
    char lbuf[32];
    unsigned int llen;

    llen = ll2string(lbuf,sizeof(lbuf),l);
    return rioWriteBulkString(r,lbuf,llen);
}",505.0,511.0,1.0,1.0,7.0,2,2,7,4,10,2,1,1,0,2,,0,1,4,2,2,size_t
5997,336129,rioWriteBulkDouble,1,rioWriteBulkDouble,"size_t rioWriteBulkDouble (rio*,double)",rio.c,"size_t rioWriteBulkDouble(rio *r, double d) {
    char dbuf[128];
    unsigned int dlen;
    dlen = fpconv_dtoa(d, dbuf);
    dbuf[dlen] = '\0';
    return rioWriteBulkString(r,dbuf,dlen);
}",514.0,520.0,1.0,1.0,7.0,3,2,8,4,1,1,1,1,0,1,,0,0,4,2,2,size_t
5998,336166,read,1,_rio.read,"size_t _rio.read (_rio*,void*,size_t)",rio.h,"size_t (*read)(struct _rio *, void *buf, size_t len);",52.0,52.0,12.0,56.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,size_t
5999,336173,write,1,_rio.write,"size_t _rio.write (_rio*,void*,size_t)",rio.h,"size_t (*write)(struct _rio *, const void *buf, size_t len);",53.0,53.0,12.0,63.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,size_t
6000,336180,tell,1,_rio.tell,off_t _rio.tell (_rio*),rio.h,off_t (*tell)(struct _rio *);,54.0,54.0,11.0,32.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,off_t
6001,336185,flush,1,_rio.flush,int _rio.flush (_rio*),rio.h,int (*flush)(struct _rio *);,55.0,55.0,9.0,31.0,1.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
6002,336190,update_cksum,1,_rio.update_cksum,"void _rio.update_cksum (_rio*,void*,size_t)",rio.h,"void (*update_cksum)(struct _rio *, const void *buf, size_t len);",61.0,61.0,10.0,68.0,1.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
6003,336227,rioWrite,1,rioWrite,"size_t rioWrite (rio*,void*,size_t)",rio.h,"static inline size_t rioWrite(rio *r, const void *buf, size_t len) {
    if (r->flags & RIO_FLAG_WRITE_ERROR) return 0;
    while (len) {
        size_t bytes_to_write = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_write);
        if (r->write(r,buf,bytes_to_write) == 0) {
            r->flags |= RIO_FLAG_WRITE_ERROR;
            return 0;
        }
        buf = (char*)buf + bytes_to_write;
        len -= bytes_to_write;
        r->processed_bytes += bytes_to_write;
    }
    return 1;
}",109.0,123.0,1.0,19.0,15.0,22,12,25,4,15,2,5,7,1,2,,0,1,6,3,3,size_t
6004,336318,rioRead,1,rioRead,"size_t rioRead (rio*,void*,size_t)",rio.h,"static inline size_t rioRead(rio *r, void *buf, size_t len) {
    if (r->flags & RIO_FLAG_READ_ERROR) return 0;
    while (len) {
        size_t bytes_to_read = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
        if (r->read(r,buf,bytes_to_read) == 0) {
            r->flags |= RIO_FLAG_READ_ERROR;
            return 0;
        }
        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_read);
        buf = (char*)buf + bytes_to_read;
        len -= bytes_to_read;
        r->processed_bytes += bytes_to_read;
    }
    return 1;
}",125.0,139.0,1.0,19.0,15.0,22,12,25,4,15,2,5,7,1,2,,0,1,6,3,3,size_t
6005,336409,rioTell,1,rioTell,off_t rioTell (rio*),rio.h,"static inline off_t rioTell(rio *r) {
    return r->tell(r);
}",141.0,143.0,1.0,1.0,3.0,1,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,off_t
6006,336420,rioFlush,1,rioFlush,int rioFlush (rio*),rio.h,"static inline int rioFlush(rio *r) {
    return r->flush(r);
}",145.0,147.0,1.0,1.0,3.0,1,1,2,1,1,1,1,1,0,1,,0,0,2,1,1,int
6007,336431,rioGetReadError,1,rioGetReadError,int rioGetReadError (rio*),rio.h,"static inline int rioGetReadError(rio *r) {
    return (r->flags & RIO_FLAG_READ_ERROR) != 0;
}",152.0,154.0,1.0,23.0,3.0,4,4,1,1,2,0,1,1,0,0,,0,0,2,1,1,int
6008,336448,rioGetWriteError,1,rioGetWriteError,int rioGetWriteError (rio*),rio.h,"static inline int rioGetWriteError(rio *r) {
    return (r->flags & RIO_FLAG_WRITE_ERROR) != 0;
}",157.0,159.0,1.0,23.0,3.0,4,4,1,1,0,0,1,1,0,0,,0,0,2,1,1,int
6009,336465,rioClearErrors,1,rioClearErrors,void rioClearErrors (rio*),rio.h,"static inline void rioClearErrors(rio *r) {
    r->flags &= ~(RIO_FLAG_READ_ERROR|RIO_FLAG_WRITE_ERROR);
}",161.0,163.0,1.0,18.0,3.0,5,4,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
6010,336672,exitScriptTimedoutMode,1,exitScriptTimedoutMode,void exitScriptTimedoutMode (scriptRunCtx*),script.c,"static void exitScriptTimedoutMode(scriptRunCtx *run_ctx) {
    serverAssert(run_ctx == curr_run_ctx);
    serverAssert(scriptIsTimedout());
    run_ctx->flags &= ~SCRIPT_TIMEDOUT;
    blockingOperationEnds();
    /* if we are a replica and we have an active master, set it for continue processing */
    if (server.masterhost && server.master) queueClientForReprocessing(server.master);
}",46.0,53.0,1.0,4.0,8.0,16,10,6,3,1,8,2,2,0,6,,0,2,2,1,1,void
6011,336732,enterScriptTimedoutMode,1,enterScriptTimedoutMode,void enterScriptTimedoutMode (scriptRunCtx*),script.c,"static void enterScriptTimedoutMode(scriptRunCtx *run_ctx) {
    serverAssert(run_ctx == curr_run_ctx);
    serverAssert(!scriptIsTimedout());
    /* Mark script as timedout */
    run_ctx->flags |= SCRIPT_TIMEDOUT;
    blockingOperationStarts();
}",55.0,61.0,1.0,4.0,7.0,13,8,3,2,1,7,1,1,0,5,,0,2,2,1,1,void
6012,336780,scriptIsTimedout,1,scriptIsTimedout,int scriptIsTimedout (void),script.c,"int scriptIsTimedout(void) {
    return scriptIsRunning() && (curr_run_ctx->flags & SCRIPT_TIMEDOUT);
}",63.0,65.0,1.0,55.0,3.0,4,4,1,1,7,3,1,1,0,1,,0,2,2,1,1,int
6013,336797,scriptGetClient,1,scriptGetClient,client scriptGetClient (void),script.c,"client* scriptGetClient(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->c;
}",67.0,70.0,1.0,4.0,4.0,5,5,1,1,0,5,1,1,0,3,,0,2,2,1,1,client
6014,336821,scriptGetCaller,1,scriptGetCaller,client scriptGetCaller (void),script.c,"client* scriptGetCaller(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->original_client;
}",72.0,75.0,1.0,4.0,4.0,5,5,1,1,0,5,1,1,0,3,,0,2,2,1,1,client
6015,336845,scriptInterrupt,1,scriptInterrupt,int scriptInterrupt (scriptRunCtx*),script.c,"int scriptInterrupt(scriptRunCtx *run_ctx) {
    if (run_ctx->flags & SCRIPT_TIMEDOUT) {
        /* script already timedout
           we just need to precess some events and return */
        processEventsWhileBlocked();
        return (run_ctx->flags & SCRIPT_KILLED) ? SCRIPT_KILL : SCRIPT_CONTINUE;
    }

    long long elapsed = elapsedMs(run_ctx->start_time);
    if (elapsed < server.busy_reply_threshold) {
        return SCRIPT_CONTINUE;
    }

    serverLog(LL_WARNING,
            ""Slow script detected: still in execution after %lld milliseconds. ""
                    ""You can try killing the script using the %s command. Script name is: %s."",
            elapsed, (run_ctx->flags & SCRIPT_EVAL_MODE) ? ""SCRIPT KILL"" : ""FUNCTION KILL"", run_ctx->funcname);

    enterScriptTimedoutMode(run_ctx);
    /* Once the script timeouts we reenter the event loop to permit others
     * some commands execution. For this reason
     * we need to mask the client executing the script from the ev...",80.0,109.0,1.0,25.0,30.0,24,7,13,3,1,13,3,3,1,6,,0,8,2,1,1,int
6016,336953,scriptFlagsToCmdFlags,1,scriptFlagsToCmdFlags,"uint64_t scriptFlagsToCmdFlags (uint64_t,uint64_t)",script.c,"uint64_t scriptFlagsToCmdFlags(uint64_t cmd_flags, uint64_t script_flags) {
    /* If the script declared flags, clear the ones from the command and use the ones it declared.*/
    cmd_flags &= ~(CMD_STALE | CMD_DENYOOM | CMD_WRITE);

    /* NO_WRITES implies ALLOW_OOM */
    if (!(script_flags & (SCRIPT_FLAG_ALLOW_OOM | SCRIPT_FLAG_NO_WRITES)))
        cmd_flags |= CMD_DENYOOM;
    if (!(script_flags & SCRIPT_FLAG_NO_WRITES))
        cmd_flags |= CMD_WRITE;
    if (script_flags & SCRIPT_FLAG_ALLOW_STALE)
        cmd_flags |= CMD_STALE;

    /* In addition the MAY_REPLICATE flag is set for these commands, but
     * if we have flags we know if it's gonna do any writes or not. */
    cmd_flags &= ~CMD_MAY_REPLICATE;

    return cmd_flags;
}",111.0,128.0,1.0,19.0,18.0,21,5,9,2,2,0,4,4,0,0,,0,0,4,2,2,uint64_t
6017,337045,scriptPrepareForRun,1,scriptPrepareForRun,"int scriptPrepareForRun (scriptRunCtx*,client*,client*,char*,uint64_t,int)",script.c,"int scriptPrepareForRun(scriptRunCtx *run_ctx, client *engine_client, client *caller, const char *funcname, uint64_t script_flags, int ro) {
    serverAssert(!curr_run_ctx);
    int client_allow_oom = !!(caller->flags & CLIENT_ALLOW_OOM);

    int running_stale = server.masterhost &&
            server.repl_state != REPL_STATE_CONNECTED &&
            server.repl_serve_stale_data == 0;
    int obey_client = mustObeyClient(caller);

    if (!(script_flags & SCRIPT_FLAG_EVAL_COMPAT_MODE)) {
        if ((script_flags & SCRIPT_FLAG_NO_CLUSTER) && server.cluster_enabled) {
            addReplyError(caller, ""Can not run script on cluster, 'no-cluster' flag is set."");
            return C_ERR;
        }

        if (running_stale && !(script_flags & SCRIPT_FLAG_ALLOW_STALE)) {
            addReplyError(caller, ""-MASTERDOWN Link with MASTER is down, ""
                             ""replica-serve-stale-data is set to 'no' ""
                             ""and 'allow-stale' flag is not set on th...",131.0,249.0,1.0,4.0,119.0,117,16,68,16,2,32,15,30,2,13,,0,23,12,6,6,int
6018,337474,scriptResetRun,1,scriptResetRun,void scriptResetRun (scriptRunCtx*),script.c,"void scriptResetRun(scriptRunCtx *run_ctx) {
    serverAssert(curr_run_ctx);

    /* After the script done, remove the MULTI state. */
    run_ctx->c->flags &= ~CLIENT_MULTI;

    if (scriptIsTimedout()) {
        exitScriptTimedoutMode(run_ctx);
        /* Restore the client that was protected when the script timeout
         * was detected. */
        unprotectClient(run_ctx->original_client);
    }

    preventCommandPropagation(run_ctx->original_client);

    /*  unset curr_run_ctx so we will know there is no running script */
    curr_run_ctx = NULL;
}",252.0,269.0,1.0,4.0,18.0,11,8,8,3,2,11,2,2,1,5,,0,7,2,1,1,void
6019,337522,scriptIsRunning,1,scriptIsRunning,int scriptIsRunning (void),script.c,"int scriptIsRunning(void) {
    return curr_run_ctx != NULL;
}",272.0,274.0,1.0,1.0,3.0,1,1,2,2,17,1,1,1,0,0,,0,1,2,1,1,int
6020,337531,scriptCurrFunction,1,scriptCurrFunction,const char* scriptCurrFunction (void),script.c,"const char* scriptCurrFunction(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->funcname;
}",276.0,279.0,1.0,4.0,4.0,5,5,1,1,0,5,1,1,0,3,,0,2,2,1,1,const char*
6021,337555,scriptIsEval,1,scriptIsEval,int scriptIsEval (void),script.c,"int scriptIsEval(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->flags & SCRIPT_EVAL_MODE;
}",281.0,284.0,1.0,4.0,4.0,7,7,1,1,1,5,1,1,0,3,,0,2,2,1,1,int
6022,337585,scriptKill,1,scriptKill,"void scriptKill (client*,int)",script.c,"void scriptKill(client *c, int is_eval) {
    if (!curr_run_ctx) {
        addReplyError(c, ""-NOTBUSY No scripts in execution right now."");
        return;
    }
    if (mustObeyClient(curr_run_ctx->original_client)) {
        addReplyError(c,
                ""-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed."");
        return;
    }
    if (curr_run_ctx->flags & SCRIPT_WRITE_DIRTY) {
        addReplyError(c,
                ""-UNKILLABLE Sorry the script already executed write ""
                        ""commands against the dataset. You can either wait the ""
                        ""script termination or kill the server in a hard way ""
                        ""using the SHUTDOWN NOSAVE command."");
        return;
    }
    if (is_eval && !(curr_run_ctx->flags & SCRIPT_EVAL_MODE)) {
        /* Kill a function with 'SCRIPT KILL' is not allow */
        addReplyErrorObject(c, shared.slowscripterr);
        return;
    }
    if...",287.0,317.0,1.0,30.0,31.0,20,6,17,4,1,18,6,6,10,7,,0,12,4,2,2,void
6023,337678,scriptVerifyCommandArity,1,scriptVerifyCommandArity,"int scriptVerifyCommandArity (redisCommand*,int,sds*)",script.c,"static int scriptVerifyCommandArity(struct redisCommand *cmd, int argc, sds *err) {
    if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity))) {
        if (cmd)
            *err = sdsnew(""Wrong number of args calling Redis command from script"");
        else
            *err = sdsnew(""Unknown Redis command called from script"");
        return C_ERR;
    }
    return C_OK;
}",319.0,328.0,1.0,15.0,10.0,14,10,8,3,1,4,3,4,3,1,,0,4,6,3,3,int
6024,337732,scriptVerifyACL,1,scriptVerifyACL,"int scriptVerifyACL (client*,sds*)",script.c,"static int scriptVerifyACL(client *c, sds *err) {
    /* Check the ACLs. */
    int acl_errpos;
    int acl_retval = ACLCheckAllPerm(c, &acl_errpos);
    if (acl_retval != ACL_OK) {
        addACLLogEntry(c,acl_retval,ACL_LOG_CTX_LUA,acl_errpos,NULL,NULL);
        sds msg = getAclErrorMessage(acl_retval, c->user, c->cmd, c->argv[acl_errpos]->ptr, 0);
        *err = sdscatsds(sdsnew(""ACL failure in script: ""), msg);
        sdsfree(msg);
        return C_ERR;
    }
    return C_OK;
}",330.0,342.0,1.0,22.0,13.0,12,7,18,6,1,9,2,2,0,6,,0,7,4,2,2,int
6025,337799,scriptVerifyWriteCommandAllow,1,scriptVerifyWriteCommandAllow,"int scriptVerifyWriteCommandAllow (scriptRunCtx*,char**)",script.c,"static int scriptVerifyWriteCommandAllow(scriptRunCtx *run_ctx, char **err) {

    /* A write command, on an RO command or an RO script is rejected ASAP.
     * Note: For scripts, we consider may-replicate commands as write commands.
     * This also makes it possible to allow read-only scripts to be run during
     * CLIENT PAUSE WRITE. */
    if (run_ctx->flags & SCRIPT_READ_ONLY &&
        (run_ctx->c->cmd->flags & (CMD_WRITE|CMD_MAY_REPLICATE)))
    {
        *err = sdsnew(""Write commands are not allowed from read-only scripts."");
        return C_ERR;
    }

    /* The other checks below are on the server state and are only relevant for
     *  write commands, return if this is not a write command. */
    if (!(run_ctx->c->cmd->flags & CMD_WRITE))
        return C_OK;

    /* If the script already made a modification to the dataset, we can't
     * fail it on unpredictable error state. */
    if ((run_ctx->flags & SCRIPT_WRITE_DIRTY))
        return C_OK;

    /* Write commands...",344.0,394.0,1.0,25.0,51.0,45,11,16,5,1,12,7,7,7,7,,0,12,4,2,2,int
6026,337953,scriptVerifyOOM,1,scriptVerifyOOM,"int scriptVerifyOOM (scriptRunCtx*,char**)",script.c,"static int scriptVerifyOOM(scriptRunCtx *run_ctx, char **err) {
    if (run_ctx->flags & SCRIPT_ALLOW_OOM) {
        /* Allow running any command even if OOM reached */
        return C_OK;
    }

    /* If we reached the memory limit configured via maxmemory, commands that
     * could enlarge the memory usage are not allowed, but only if this is the
     * first write in the context of this script, otherwise we can't stop
     * in the middle. */

    if (server.maxmemory &&                            /* Maxmemory is actually enabled. */
        !mustObeyClient(run_ctx->original_client) &&   /* Don't care about mem for replicas or AOF. */
        !(run_ctx->flags & SCRIPT_WRITE_DIRTY) &&      /* Script had no side effects so far. */
        server.pre_command_oom_state &&                /* Detected OOM when script start. */
        (run_ctx->c->cmd->flags & CMD_DENYOOM))
    {
        *err = sdsdup(shared.oomerr->ptr);
        return C_ERR;
    }

    return C_OK;
}",396.0,418.0,1.0,25.0,23.0,25,9,8,4,1,6,3,3,5,2,,0,6,4,2,2,int
6027,338032,scriptVerifyClusterState,1,scriptVerifyClusterState,"int scriptVerifyClusterState (scriptRunCtx*,client*,client*,sds*)",script.c,"static int scriptVerifyClusterState(scriptRunCtx *run_ctx, client *c, client *original_c, sds *err) {
    if (!server.cluster_enabled || mustObeyClient(original_c)) {
        return C_OK;
    }
    /* If this is a Redis Cluster node, we need to make sure the script is not
     * trying to access non-local keys, with the exception of commands
     * received from our master or when loading the AOF back in memory. */
    int error_code;
    /* Duplicate relevant flags in the script client. */
    c->flags &= ~(CLIENT_READONLY | CLIENT_ASKING);
    c->flags |= original_c->flags & (CLIENT_READONLY | CLIENT_ASKING);
    int hashslot = -1;
    if (getNodeByQuery(c, c->cmd, c->argv, c->argc, &hashslot, &error_code) != server.cluster->myself) {
        if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
            *err = sdsnew(
                    ""Script attempted to execute a write command while the ""
                            ""cluster is down and readonly"");
        } else if (error_cod...",420.0,460.0,1.0,15.0,41.0,40,15,20,7,1,12,6,8,7,3,,0,12,8,4,4,int
6028,338208,scriptSetResp,1,scriptSetResp,"int scriptSetResp (scriptRunCtx*,int)",script.c,"int scriptSetResp(scriptRunCtx *run_ctx, int resp) {
    if (resp != 2 && resp != 3) {
        return C_ERR;
    }

    run_ctx->c->resp = resp;
    return C_OK;
}",463.0,470.0,1.0,15.0,8.0,7,5,4,2,1,1,2,2,0,0,,0,1,4,2,2,int
6029,338239,scriptSetRepl,1,scriptSetRepl,"int scriptSetRepl (scriptRunCtx*,int)",script.c,"int scriptSetRepl(scriptRunCtx *run_ctx, int repl) {
    if ((repl & ~(PROPAGATE_AOF | PROPAGATE_REPL)) != 0) {
        return C_ERR;
    }
    run_ctx->repl_flags = repl;
    return C_OK;
}",474.0,480.0,1.0,18.0,7.0,7,7,3,2,1,1,2,2,0,0,,0,1,4,2,2,int
6030,338273,scriptVerifyAllowStale,1,scriptVerifyAllowStale,"int scriptVerifyAllowStale (client*,sds*)",script.c,"static int scriptVerifyAllowStale(client *c, sds *err) {
    if (!server.masterhost) {
        /* Not a replica, stale is irrelevant */
        return C_OK;
    }

    if (server.repl_state == REPL_STATE_CONNECTED) {
        /* Connected to replica, stale is irrelevant */
        return C_OK;
    }

    if (server.repl_serve_stale_data == 1) {
        /* Disconnected from replica but allow to serve data */
        return C_OK;
    }

    if (c->cmd->flags & CMD_STALE) {
        /* Command is allow while stale */
        return C_OK;
    }

    /* On stale replica, can not run the command */
    *err = sdsnew(""Can not execute the command on a stale replica"");
    return C_ERR;
}",482.0,506.0,1.0,15.0,25.0,13,9,6,4,1,2,5,5,1,1,,0,2,4,2,2,int
6031,338338,scriptCall,1,scriptCall,"void scriptCall (scriptRunCtx*,sds*)",script.c,"void scriptCall(scriptRunCtx *run_ctx, sds *err) {
    client *c = run_ctx->c;

    /* Setup our fake client for command execution */
    c->user = run_ctx->original_client->user;

    /* Process module hooks */
    moduleCallCommandFilters(c);

    struct redisCommand *cmd = lookupCommand(c->argv, c->argc);
    c->cmd = c->lastcmd = c->realcmd = cmd;
    if (scriptVerifyCommandArity(cmd, c->argc, err) != C_OK) {
        goto error;
    }

    /* There are commands that are not allowed inside scripts. */
    if (!server.script_disable_deny_script && (cmd->flags & CMD_NOSCRIPT)) {
        *err = sdsnew(""This Redis command is not allowed from script"");
        goto error;
    }

    if (scriptVerifyAllowStale(c, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyACL(c, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyWriteCommandAllow(run_ctx, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyOOM(run_ctx, err) != C_OK) {
        goto error;
    }...",513.0,573.0,1.0,55.0,61.0,54,14,44,6,1,29,18,11,12,13,,0,25,4,2,2,void
6032,338573,scriptRunDuration,1,scriptRunDuration,long long scriptRunDuration (void),script.c,"long long scriptRunDuration(void) {
    serverAssert(scriptIsRunning());
    return elapsedMs(curr_run_ctx->start_time);
}",575.0,578.0,1.0,4.0,4.0,5,5,1,1,0,6,1,1,0,4,,0,2,2,1,1,long long
6033,338814,redis_math_random,1,redis_math_random,int redis_math_random (lua_State*),script_lua.c,"static int redis_math_random (lua_State *L) {
  /* the `%' avoids the (rare) case of r==1, and is needed also because on
     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
                                (lua_Number)REDIS_LRAND48_MAX;
  switch (lua_gettop(L)) {  /* check number of arguments */
    case 0: {  /* no arguments */
      lua_pushnumber(L, r);  /* Number between 0 and 1 */
      break;
    }
    case 1: {  /* only upper limit */
      int u = luaL_checkint(L, 1);
      luaL_argcheck(L, 1<=u, 1, ""interval is empty"");
      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
      break;
    }
    case 2: {  /* lower and upper limits */
      int l = luaL_checkint(L, 1);
      int u = luaL_checkint(L, 2);
      luaL_argcheck(L, l<=u, 2, ""interval is empty"");
      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
      break;
    }
    default: return ...",1522.0,1548.0,1.0,45.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6034,338819,redis_math_randomseed,1,redis_math_randomseed,int redis_math_randomseed (lua_State*),script_lua.c,"static int redis_math_randomseed (lua_State *L) {
  redisSrand48(luaL_checkint(L, 1));
  return 0;
}",1550.0,1553.0,1.0,1.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6035,338824,redisProtocolToLuaType_Int,1,redisProtocolToLuaType_Int,"void redisProtocolToLuaType_Int (void*,long long,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_Int(void *ctx, long long val, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushnumber(lua,(lua_Number)val);
}",238.0,252.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6036,338832,redisProtocolToLuaType_BulkString,1,redisProtocolToLuaType_BulkString,"void redisProtocolToLuaType_BulkString (void*,char*,size_t,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_BulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushlstring(lua,str,len);
}",286.0,300.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6037,338841,redisProtocolToLuaType_NullBulkString,1,redisProtocolToLuaType_NullBulkString,"void redisProtocolToLuaType_NullBulkString (void*,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_NullBulkString(void *ctx, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushboolean(lua,0);
}",254.0,268.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6038,338848,redisProtocolToLuaType_NullArray,1,redisProtocolToLuaType_NullArray,"void redisProtocolToLuaType_NullArray (void*,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_NullArray(void *ctx, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }
    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushboolean(lua,0);
}",270.0,283.0,1.0,4.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6039,338855,redisProtocolToLuaType_Status,1,redisProtocolToLuaType_Status,"void redisProtocolToLuaType_Status (void*,char*,size_t,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_Status(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""ok"");
    lua_pushlstring(lua,str,len);
    lua_settable(lua,-3);
}",302.0,319.0,1.0,4.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6040,338864,redisProtocolToLuaType_Error,1,redisProtocolToLuaType_Error,"void redisProtocolToLuaType_Error (void*,char*,size_t,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_Error(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    sds err_msg = sdscatlen(sdsnew(""-""), str, len);
    luaPushErrorBuff(lua,err_msg);
    /* push a field indicate to ignore updating the stats on this error
     * because it was already updated when executing the command. */
    lua_pushstring(lua,""ignore_error_stats_update"");
    lua_pushboolean(lua, 1);
    lua_settable(lua,-3);
}",321.0,341.0,1.0,4.0,21.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6041,338873,redisProtocolToLuaType_Array,1,redisProtocolToLuaType_Array,"void redisProtocolToLuaType_Array (ReplyParser*,void*,size_t,char*)",script_lua.c,"static void redisProtocolToLuaType_Array(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);

    lua_State *lua = ctx;
    if (lua){
        if (!lua_checkstack(lua, 2)) {
            /* Increase the Lua stack if needed, to make sure there is enough room
             * to push elements to the stack. On failure, exit with panic. */
            serverPanic(""lua stack limit reach when parsing redis.call reply"");
        }
        lua_newtable(lua);
    }
    for (size_t j = 0; j < len; j++) {
        if (lua) lua_pushnumber(lua,j+1);
        parseReply(parser,lua);
        if (lua) lua_settable(lua,-3);
    }
}",395.0,412.0,1.0,4.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6042,338881,redisProtocolToLuaType_Map,1,redisProtocolToLuaType_Map,"void redisProtocolToLuaType_Map (ReplyParser*,void*,size_t,char*)",script_lua.c,"static void redisProtocolToLuaType_Map(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);
    lua_State *lua = ctx;
    if (lua) {
        if (!lua_checkstack(lua, 3)) {
            /* Increase the Lua stack if needed, to make sure there is enough room
             * to push elements to the stack. On failure, exit with panic. */
            serverPanic(""lua stack limit reach when parsing redis.call reply"");
        }
        lua_newtable(lua);
        lua_pushstring(lua, ""map"");
        lua_newtable(lua);
    }
    for (size_t j = 0; j < len; j++) {
        parseReply(parser,lua);
        parseReply(parser,lua);
        if (lua) lua_settable(lua,-3);
    }
    if (lua) lua_settable(lua,-3);
}",343.0,362.0,1.0,4.0,20.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6043,338889,redisProtocolToLuaType_Set,1,redisProtocolToLuaType_Set,"void redisProtocolToLuaType_Set (ReplyParser*,void*,size_t,char*)",script_lua.c,"static void redisProtocolToLuaType_Set(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);

    lua_State *lua = ctx;
    if (lua) {
        if (!lua_checkstack(lua, 3)) {
            /* Increase the Lua stack if needed, to make sure there is enough room
             * to push elements to the stack. On failure, exit with panic. */
            serverPanic(""lua stack limit reach when parsing redis.call reply"");
        }
        lua_newtable(lua);
        lua_pushstring(lua, ""set"");
        lua_newtable(lua);
    }
    for (size_t j = 0; j < len; j++) {
        parseReply(parser,lua);
        if (lua) {
            if (!lua_checkstack(lua, 1)) {
                /* Increase the Lua stack if needed, to make sure there is enough room
                 * to push elements to the stack. On failure, exit with panic.
                 * Notice that here we need to check the stack again because the recursive
                 * call to redisProtocolToLuaType...",364.0,393.0,1.0,4.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6044,338897,redisProtocolToLuaType_Null,1,redisProtocolToLuaType_Null,"void redisProtocolToLuaType_Null (void*,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_Null(void *ctx, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushnil(lua);
}",474.0,488.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6045,338904,redisProtocolToLuaType_Bool,1,redisProtocolToLuaType_Bool,"void redisProtocolToLuaType_Bool (void*,int,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_Bool(void *ctx, int val, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushboolean(lua,val);
}",490.0,504.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6046,338912,redisProtocolToLuaType_Double,1,redisProtocolToLuaType_Double,"void redisProtocolToLuaType_Double (void*,double,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_Double(void *ctx, double d, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""double"");
    lua_pushnumber(lua,d);
    lua_settable(lua,-3);
}",506.0,523.0,1.0,4.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6047,338920,redisProtocolToLuaType_BigNumber,1,redisProtocolToLuaType_BigNumber,"void redisProtocolToLuaType_BigNumber (void*,char*,size_t,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_BigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""big_number"");
    lua_pushlstring(lua,str,len);
    lua_settable(lua,-3);
}",455.0,472.0,1.0,4.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6048,338929,redisProtocolToLuaType_VerbatimString,1,redisProtocolToLuaType_VerbatimString,"void redisProtocolToLuaType_VerbatimString (void*,char*,char*,size_t,char*,size_t)",script_lua.c,"static void redisProtocolToLuaType_VerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 5)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""verbatim_string"");
    lua_newtable(lua);
    lua_pushstring(lua,""string"");
    lua_pushlstring(lua,str,len);
    lua_settable(lua,-3);
    lua_pushstring(lua,""format"");
    lua_pushlstring(lua,format,3);
    lua_settable(lua,-3);
    lua_settable(lua,-3);
}",430.0,453.0,1.0,4.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,void
6049,338939,redisProtocolToLuaType_Attribute,1,redisProtocolToLuaType_Attribute,"void redisProtocolToLuaType_Attribute (ReplyParser*,void*,size_t,char*)",script_lua.c,"static void redisProtocolToLuaType_Attribute(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);

    /* Parse the attribute reply.
     * Currently, we do not expose the attribute to the Lua script so
     * we just need to continue parsing and ignore it (the NULL ensures that the
     * reply will be ignored). */
    for (size_t j = 0; j < len; j++) {
        parseReply(parser,NULL);
        parseReply(parser,NULL);
    }

    /* Parse the reply itself. */
    parseReply(parser,ctx);
}",414.0,428.0,1.0,4.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6050,338947,luaReplyToRedisReply,1,luaReplyToRedisReply,"void luaReplyToRedisReply (client*,client*,lua_State*)",script_lua.c,"static void luaReplyToRedisReply(client *c, client* script_client, lua_State *lua) {
    int t = lua_type(lua,-1);

    if (!lua_checkstack(lua, 4)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 4 elements to the stack. On failure, return error.
         * Notice that we need, in the worst case, 4 elements because returning a map might
         * require push 4 elements to the Lua stack.*/
        addReplyErrorFormat(c, ""reached lua stack limit"");
        lua_pop(lua,1); /* pop the element from the stack */
        return;
    }

    switch(t) {
    case LUA_TSTRING:
        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
        break;
    case LUA_TBOOLEAN:
        if (script_client->resp == 2)
            addReply(c,lua_toboolean(lua,-1) ? shared.cone :
                                               shared.null[c->resp]);
        else
            addReplyBool(c,lua_toboolean(lua,-1));
        break;
    c...",597.0,781.0,1.0,68.0,185.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6051,338954,luaSaveOnRegistry,1,luaSaveOnRegistry,"void luaSaveOnRegistry (lua_State*,char*,void*)",script_lua.c,"void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr) {
    lua_pushstring(lua, name);
    if (ptr) {
        lua_pushlightuserdata(lua, ptr);
    } else {
        lua_pushnil(lua);
    }
    lua_settable(lua, LUA_REGISTRYINDEX);
}",159.0,167.0,1.0,1.0,9.0,0,0,7,4,5,0,2,2,0,0,,0,0,6,3,3,void
6052,338977,luaGetFromRegistry,1,luaGetFromRegistry,"void* luaGetFromRegistry (lua_State*,char*)",script_lua.c,"void* luaGetFromRegistry(lua_State* lua, const char* name) {
    lua_pushstring(lua, name);
    lua_gettable(lua, LUA_REGISTRYINDEX);

    if (lua_isnil(lua, -1)) {
        lua_pop(lua, 1); /* pops the value */
        return NULL;
    }
    /* must be light user data */
    serverAssert(lua_islightuserdata(lua, -1));

    void* ptr = (void*) lua_topointer(lua, -1);
    serverAssert(ptr);

    /* pops the value */
    lua_pop(lua, 1);

    return ptr;
}",172.0,190.0,1.0,4.0,19.0,13,6,14,5,8,2,2,2,0,2,,0,0,4,2,2,void*
6053,339114,redisProtocolToLuaType,1,redisProtocolToLuaType,"void redisProtocolToLuaType (lua_State*,char*)",script_lua.c,"static void redisProtocolToLuaType(lua_State *lua, char* reply) {
    ReplyParser parser = {.curr_location = reply, .callbacks = DefaultLuaTypeParserCallbacks};

    parseReply(&parser, lua);
}",232.0,236.0,1.0,1.0,5.0,5,3,7,6,1,2,1,1,0,1,,0,1,4,2,2,void
6054,339988,luaPushErrorBuff,1,luaPushErrorBuff,"void luaPushErrorBuff (lua_State*,sds)",script_lua.c,"void luaPushErrorBuff(lua_State *lua, sds err_buffer) {
    sds msg;
    sds error_code;

    /* If debugging is active and in step mode, log errors resulting from
     * Redis commands. */
    if (ldbIsEnabled()) {
        ldbLog(sdscatprintf(sdsempty(),""<error> %s"",err_buffer));
    }

    /* There are two possible formats for the received `error` string:
     * 1) ""-CODE msg"": in this case we remove the leading '-' since we don't store it as part of the lua error format.
     * 2) ""msg"": in this case we prepend a generic 'ERR' code since all error statuses need some error code.
     * We support format (1) so this function can reuse the error messages used in other places in redis.
     * We support format (2) so it'll be easy to pass descriptive errors to this function without worrying about format.
     */
    if (err_buffer[0] == '-') {
        /* derive error code from the message */
        char *err_msg = strstr(err_buffer, "" "");
        if (!err_msg) {
            msg = sd...",532.0,576.0,1.0,1.0,45.0,10,6,21,6,2,11,4,5,1,11,,0,7,4,2,2,void
6055,340088,luaPushError,1,luaPushError,"void luaPushError (lua_State*,char*)",script_lua.c,"void luaPushError(lua_State *lua, const char *error) {
    luaPushErrorBuff(lua, sdsnew(error));
}",578.0,580.0,1.0,1.0,3.0,0,0,2,2,24,2,1,1,0,2,,0,1,4,2,2,void
6056,340098,luaError,1,luaError,int luaError (lua_State*),script_lua.c,"int luaError(lua_State *lua) {
    return lua_error(lua);
}",586.0,588.0,1.0,1.0,3.0,0,0,1,1,19,0,1,1,0,0,,0,0,2,1,1,int
6057,340648,freeLuaRedisArgv,1,freeLuaRedisArgv,"void freeLuaRedisArgv (robj**,int,int)",script_lua.c,"void freeLuaRedisArgv(robj **argv, int argc, int argv_len) {
    int j;
    for (j = 0; j < argc; j++) {
        robj *o = argv[j];

        /* Try to cache the object in the lua_args_cached_objects array.
         * The object must be small, SDS-encoded, and with refcount = 1
         * (we must be the only owner) for us to cache it. */
        if (j < LUA_CMD_OBJCACHE_SIZE &&
            o->refcount == 1 &&
            (o->encoding == OBJ_ENCODING_RAW ||
             o->encoding == OBJ_ENCODING_EMBSTR) &&
            sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)
        {
            sds s = o->ptr;
            if (lua_args_cached_objects[j]) decrRefCount(lua_args_cached_objects[j]);
            lua_args_cached_objects[j] = o;
            lua_args_cached_objects_len[j] = sdsalloc(s);
        } else {
            decrRefCount(o);
        }
    }
    if (argv != lua_argv || argv_len != lua_argv_size) {
        /* The command changed argv, scrap the cache and start over. */
        zfr...",858.0,886.0,1.0,16.0,29.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
6058,340673,luaArgsToRedisArgv,1,luaArgsToRedisArgv,"robj luaArgsToRedisArgv (lua_State*,int*,int*)",script_lua.c,"static robj **luaArgsToRedisArgv(lua_State *lua, int *argc, int *argv_len) {
    int j;
    /* Require at least one argument */
    *argc = lua_gettop(lua);
    if (*argc == 0) {
        luaPushError(lua, ""Please specify at least one argument for this redis lib call"");
        return NULL;
    }

    /* Build the arguments vector (reuse a cached argv from last call) */
    if (lua_argv_size < *argc) {
        lua_argv = zrealloc(lua_argv,sizeof(robj*)* *argc);
        lua_argv_size = *argc;
    }
    *argv_len = lua_argv_size;

    for (j = 0; j < *argc; j++) {
        char *obj_s;
        size_t obj_len;
        char dbuf[64];

        if (lua_type(lua,j+1) == LUA_TNUMBER) {
            /* We can't use lua_tolstring() for number -> string conversion
             * since Lua uses a format specifier that loses precision. */
            lua_Number num = lua_tonumber(lua,j+1);
            obj_len = fpconv_dtoa((double)num, dbuf);
            dbuf[obj_len] = '\0';
            obj_s = db...",796.0,856.0,1.0,16.0,61.0,44,13,62,16,2,19,7,9,3,5,,0,15,6,3,3,robj
6059,340972,luaRedisGenericCommand,1,luaRedisGenericCommand,"int luaRedisGenericCommand (lua_State*,int)",script_lua.c,"static int luaRedisGenericCommand(lua_State *lua, int raise_error) {
    int j;
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    sds err = NULL;
    client* c = rctx->c;
    sds reply;

    c->argv = luaArgsToRedisArgv(lua, &c->argc, &c->argv_len);
    if (c->argv == NULL) {
        return raise_error ? luaError(lua) : 1;
    }

    static int inuse = 0;   /* Recursive calls detection. */

    /* By using Lua debug hooks it is possible to trigger a recursive call
     * to luaRedisGenericCommand(), which normally should never happen.
     * To make this function reentrant is futile and makes it slower, but
     * we should at least detect such a misuse, and abort. */
    if (inuse) {
        char *recursion_warning =
                ""luaRedisGenericCommand() recursive call detected. ""
                ""Are you doing funny stuff with Lua debug hooks?"";
        serverLog(LL_WARNING,""%s"",re...",888.0,992.0,1.0,49.0,105.0,71,18,75,12,2,44,14,15,9,20,,0,30,4,2,2,int
6060,341343,luaRedisPcall,1,luaRedisPcall,int luaRedisPcall (lua_State*),script_lua.c,"static int luaRedisPcall(lua_State *lua) {
    int argc = lua_gettop(lua);
    lua_pushboolean(lua, 1); /* result place holder */
    lua_insert(lua, 1);
    if (lua_pcall(lua, argc - 1, LUA_MULTRET, 0)) {
        /* Error */
        lua_remove(lua, 1); /* remove the result place holder, now we have room for at least one element */
        if (lua_istable(lua, -1)) {
            lua_getfield(lua, -1, ""err"");
            if (lua_isstring(lua, -1)) {
                lua_replace(lua, -2); /* replace the error message with the table */
            }
        }
        lua_pushboolean(lua, 0); /* push result */
        lua_insert(lua, 1);
    }
    return lua_gettop(lua);

}",1003.0,1021.0,1.0,1.0,19.0,6,3,15,3,0,0,4,7,0,0,,0,0,2,1,1,int
6061,341401,luaRedisCallCommand,1,luaRedisCallCommand,int luaRedisCallCommand (lua_State*),script_lua.c,"static int luaRedisCallCommand(lua_State *lua) {
    return luaRedisGenericCommand(lua,1);
}",1024.0,1026.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
6062,341410,luaRedisPCallCommand,1,luaRedisPCallCommand,int luaRedisPCallCommand (lua_State*),script_lua.c,"static int luaRedisPCallCommand(lua_State *lua) {
    return luaRedisGenericCommand(lua,0);
}",1029.0,1031.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
6063,341419,luaRedisSha1hexCommand,1,luaRedisSha1hexCommand,int luaRedisSha1hexCommand (lua_State*),script_lua.c,"static int luaRedisSha1hexCommand(lua_State *lua) {
    int argc = lua_gettop(lua);
    char digest[41];
    size_t len;
    char *s;

    if (argc != 1) {
        luaPushError(lua, ""wrong number of arguments"");
        return luaError(lua);
    }

    s = (char*)lua_tolstring(lua,1,&len);
    sha1hex(digest,s,len);
    lua_pushstring(lua,digest);
    return 1;
}",1035.0,1050.0,1.0,1.0,16.0,5,4,13,5,0,3,2,2,0,3,,0,0,2,1,1,int
6064,341461,luaRedisReturnSingleFieldTable,1,luaRedisReturnSingleFieldTable,"int luaRedisReturnSingleFieldTable (lua_State*,char*)",script_lua.c,"static int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
        luaPushError(lua, ""wrong number or type of arguments"");
        return 1;
    }

    lua_newtable(lua);
    lua_pushstring(lua, field);
    lua_pushvalue(lua, -3);
    lua_settable(lua, -3);
    return 1;
}",1059.0,1070.0,1.0,1.0,12.0,6,3,9,3,1,1,2,2,0,1,,0,0,4,2,2,int
6065,341500,luaRedisErrorReplyCommand,1,luaRedisErrorReplyCommand,int luaRedisErrorReplyCommand (lua_State*),script_lua.c,"static int luaRedisErrorReplyCommand(lua_State *lua) {
    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
        luaPushError(lua, ""wrong number or type of arguments"");
        return 1;
    }

    /* add '-' if not exists */
    const char *err = lua_tostring(lua, -1);
    sds err_buff = NULL;
    if (err[0] != '-') {
        err_buff = sdscatfmt(sdsempty(), ""-%s"", err);
    } else {
        err_buff = sdsnew(err);
    }
    luaPushErrorBuff(lua, err_buff);
    return 1;
}",1073.0,1089.0,1.0,1.0,17.0,10,5,13,5,0,4,3,3,0,4,,0,2,2,1,1,int
6066,341558,luaRedisStatusReplyCommand,1,luaRedisStatusReplyCommand,int luaRedisStatusReplyCommand (lua_State*),script_lua.c,"static int luaRedisStatusReplyCommand(lua_State *lua) {
    return luaRedisReturnSingleFieldTable(lua,""ok"");
}",1092.0,1094.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
6067,341567,luaRedisSetReplCommand,1,luaRedisSetReplCommand,int luaRedisSetReplCommand (lua_State*),script_lua.c,"static int luaRedisSetReplCommand(lua_State *lua) {
    int flags, argc = lua_gettop(lua);

    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */

    if (argc != 1) {
        luaPushError(lua, ""redis.set_repl() requires one argument."");
         return luaError(lua);
    }

    flags = lua_tonumber(lua,-1);
    if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {
        luaPushError(lua, ""Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE."");
        return luaError(lua);
    }

    scriptSetRepl(rctx, flags);
    return 0;
}",1100.0,1119.0,1.0,49.0,20.0,13,10,16,4,0,7,3,3,0,7,,0,1,2,1,1,int
6068,341643,luaRedisAclCheckCmdPermissionsCommand,1,luaRedisAclCheckCmdPermissionsCommand,int luaRedisAclCheckCmdPermissionsCommand (lua_State*),script_lua.c,"static int luaRedisAclCheckCmdPermissionsCommand(lua_State *lua) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    int raise_error = 0;

    int argc, argv_len;
    robj **argv = luaArgsToRedisArgv(lua, &argc, &argv_len);

    /* Require at least one argument */
    if (argv == NULL) return luaError(lua);

    /* Find command */
    struct redisCommand *cmd;
    if ((cmd = lookupCommand(argv, argc)) == NULL) {
        luaPushError(lua, ""Invalid command passed to redis.acl_check_cmd()"");
        raise_error = 1;
    } else {
        int keyidxptr;
        if (ACLCheckAllUserCommandPerm(rctx->original_client->user, cmd, argv, argc, &keyidxptr) != ACL_OK) {
            lua_pushboolean(lua, 0);
        } else {
            lua_pushboolean(lua, 1);
        }
    }

    freeLuaRedisArgv(argv, argc, argv_len);
    if (raise_error)
        return luaError(lua);
    else
        return 1;
}",1124.0,1154.0,1.0,49.0,31.0,13,7,23,8,0,8,4,4,1,8,,0,3,2,1,1,int
6069,341752,luaLogCommand,1,luaLogCommand,int luaLogCommand (lua_State*),script_lua.c,"static int luaLogCommand(lua_State *lua) {
    int j, argc = lua_gettop(lua);
    int level;
    sds log;

    if (argc < 2) {
        luaPushError(lua, ""redis.log() requires two arguments or more."");
        return luaError(lua);
    } else if (!lua_isnumber(lua,-argc)) {
        luaPushError(lua, ""First argument must be a number (log level)."");
        return luaError(lua);
    }
    level = lua_tonumber(lua,-argc);
    if (level < LL_DEBUG || level > LL_WARNING) {
        luaPushError(lua, ""Invalid debug level."");
        return luaError(lua);
    }
    if (level < server.verbosity) return 0;

    /* Glue together all the arguments */
    log = sdsempty();
    for (j = 1; j < argc; j++) {
        size_t len;
        char *s;

        s = (char*)lua_tolstring(lua,(-argc)+j,&len);
        if (s) {
            if (j != 1) log = sdscatlen(log,"" "",1);
            log = sdscatlen(log,s,len);
        }
    }
    serverLogRaw(level,log);
    sdsfree(log);
    return 0;
}",1158.0,1192.0,1.0,16.0,35.0,20,10,34,8,0,9,7,10,0,9,,0,3,2,1,1,int
6070,341880,luaSetResp,1,luaSetResp,int luaSetResp (lua_State*),script_lua.c,"static int luaSetResp(lua_State *lua) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    int argc = lua_gettop(lua);

    if (argc != 1) {
        luaPushError(lua, ""redis.setresp() requires one argument."");
        return luaError(lua);
    }

    int resp = lua_tonumber(lua,-argc);
    if (resp != 2 && resp != 3) {
        luaPushError(lua, ""RESP version must be 2 or 3."");
        return luaError(lua);
    }
    scriptSetResp(rctx, resp);
    return 0;
}",1195.0,1212.0,1.0,49.0,18.0,12,8,18,4,0,7,3,3,0,7,,0,1,2,1,1,int
6071,341951,luaLoadLib,1,luaLoadLib,"void luaLoadLib (lua_State*,char*,lua_CFunction)",script_lua.c,"static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
  lua_pushcfunction(lua, luafunc);
  lua_pushstring(lua, libname);
  lua_call(lua, 1, 0);
}",1218.0,1222.0,1.0,1.0,5.0,0,0,5,3,9,0,1,1,0,0,,0,0,6,3,3,void
6072,341969,luaopen_cjson,1,luaopen_cjson,int luaopen_cjson (lua_State*),script_lua.c,int (luaopen_cjson) (lua_State *L);,1224.0,1224.0,16.0,45.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6073,341975,luaopen_struct,1,luaopen_struct,int luaopen_struct (lua_State*),script_lua.c,int (luaopen_struct) (lua_State *L);,1225.0,1225.0,16.0,46.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6074,341981,luaopen_cmsgpack,1,luaopen_cmsgpack,int luaopen_cmsgpack (lua_State*),script_lua.c,int (luaopen_cmsgpack) (lua_State *L);,1226.0,1226.0,16.0,48.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6075,341987,luaopen_bit,1,luaopen_bit,int luaopen_bit (lua_State*),script_lua.c,int (luaopen_bit) (lua_State *L);,1227.0,1227.0,16.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6076,341992,luaLoadLibraries,1,luaLoadLibraries,void luaLoadLibraries (lua_State*),script_lua.c,"static void luaLoadLibraries(lua_State *lua) {
    luaLoadLib(lua, """", luaopen_base);
    luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);
    luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);
    luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);
    luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);
    luaLoadLib(lua, ""cjson"", luaopen_cjson);
    luaLoadLib(lua, ""struct"", luaopen_struct);
    luaLoadLib(lua, ""cmsgpack"", luaopen_cmsgpack);
    luaLoadLib(lua, ""bit"", luaopen_bit);

#if 0 /* Stuff that we don't load currently, for sandboxing concerns. */
    luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
    luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
#endif
}",1229.0,1244.0,1.0,1.0,16.0,0,0,22,14,1,9,1,1,0,9,,0,0,2,1,1,void
6077,342033,luaGetStringSds,1,luaGetStringSds,"sds luaGetStringSds (lua_State*,int)",script_lua.c,"sds luaGetStringSds(lua_State *lua, int index) {
    if (!lua_isstring(lua, index)) {
        return NULL;
    }

    size_t len;
    const char *str = lua_tolstring(lua, index, &len);
    sds str_sds = sdsnewlen(str, len);
    return str_sds;
}",1248.0,1257.0,1.0,1.0,10.0,4,3,11,6,2,1,2,2,0,1,,0,1,4,2,2,sds
6078,342064,luaProtectedTableError,1,luaProtectedTableError,int luaProtectedTableError (lua_State*),script_lua.c,"static int luaProtectedTableError(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 2) {
        serverLog(LL_WARNING, ""malicious code trying to call luaProtectedTableError with wrong arguments"");
        luaL_error(lua, ""Wrong number of arguments to luaProtectedTableError"");
    }
    if (!lua_isstring(lua, -1) && !lua_isnumber(lua, -1)) {
        luaL_error(lua, ""Second argument to luaProtectedTableError must be a string or number"");
    }
    const char *variable_name = lua_tostring(lua, -1);
    luaL_error(lua, ""Script attempted to access nonexistent global variable '%s'"", variable_name);
    return 0;
}",1259.0,1271.0,1.0,8.0,13.0,12,8,12,4,0,1,3,3,0,1,,0,0,2,1,1,int
6079,342129,luaSetErrorMetatable,1,luaSetErrorMetatable,void luaSetErrorMetatable (lua_State*),script_lua.c,"void luaSetErrorMetatable(lua_State *lua) {
    lua_newtable(lua); /* push metatable */
    lua_pushcfunction(lua, luaProtectedTableError); /* push get error handler */
    lua_setfield(lua, -2, ""__index"");
    lua_setmetatable(lua, -2);
}",1280.0,1285.0,1.0,1.0,6.0,2,1,4,1,4,0,1,1,0,0,,0,0,2,1,1,void
6080,342148,luaNewIndexAllowList,1,luaNewIndexAllowList,int luaNewIndexAllowList (lua_State*),script_lua.c,"static int luaNewIndexAllowList(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 3) {
        serverLog(LL_WARNING, ""malicious code trying to call luaNewIndexAllowList with wrong arguments"");
        luaL_error(lua, ""Wrong number of arguments to luaNewIndexAllowList"");
    }
    if (!lua_istable(lua, -3)) {
        luaL_error(lua, ""first argument to luaNewIndexAllowList must be a table"");
    }
    if (!lua_isstring(lua, -2) && !lua_isnumber(lua, -2)) {
        luaL_error(lua, ""Second argument to luaNewIndexAllowList must be a string or number"");
    }
    const char *variable_name = lua_tostring(lua, -2);
    /* check if the key is in our allow list */

    char ***allow_l = allow_lists;
    for (; *allow_l ; ++allow_l){
        char **c = *allow_l;
        for (; *c ; ++c) {
            if (strcmp(*c, variable_name) == 0) {
                break;
            }
        }
        if (*c) {
            break;
        }
    }
    if (!*allow_l) {
        /* Search the...",1287.0,1330.0,1.0,8.0,44.0,33,10,30,8,0,4,15,20,0,2,,0,2,2,1,1,int
6081,342311,luaSetAllowListProtection,1,luaSetAllowListProtection,void luaSetAllowListProtection (lua_State*),script_lua.c,"void luaSetAllowListProtection(lua_State *lua) {
    lua_newtable(lua); /* push metatable */
    lua_pushcfunction(lua, luaNewIndexAllowList); /* push get error handler */
    lua_setfield(lua, -2, ""__newindex"");
    lua_setmetatable(lua, -2);
}",1338.0,1343.0,1.0,1.0,6.0,2,1,4,1,1,0,1,1,0,0,,0,0,2,1,1,void
6082,342330,luaSetTableProtectionRecursively,1,luaSetTableProtectionRecursively,void luaSetTableProtectionRecursively (lua_State*),script_lua.c,"void luaSetTableProtectionRecursively(lua_State *lua) {
    /* This protect us from a loop in case we already visited the table
     * For example, globals has '_G' key which is pointing back to globals. */
    if (lua_isreadonlytable(lua, -1)) {
        return;
    }

    /* protect the current table */
    lua_enablereadonlytable(lua, -1, 1);

    lua_checkstack(lua, 2);
    lua_pushnil(lua); /* Use nil to start iteration. */
    while (lua_next(lua,-2)) {
        /* Stack now: table, key, value */
        if (lua_istable(lua, -1)) {
            luaSetTableProtectionRecursively(lua);
        }
        lua_pop(lua, 1);
    }

    /* protect the metatable if exists */
    if (lua_getmetatable(lua, -1)) {
        luaSetTableProtectionRecursively(lua);
        lua_pop(lua, 1); /* pop the metatable */
    }
}",1348.0,1373.0,1.0,1.0,26.0,5,1,11,1,3,0,5,6,0,0,,0,0,2,1,1,void
6083,342380,luaRegisterVersion,1,luaRegisterVersion,void luaRegisterVersion (lua_State*),script_lua.c,"void luaRegisterVersion(lua_State* lua) {
    lua_pushstring(lua,""REDIS_VERSION_NUM"");
    lua_pushnumber(lua,REDIS_VERSION_NUM);
    lua_settable(lua,-3);

    lua_pushstring(lua,""REDIS_VERSION"");
    lua_pushstring(lua,REDIS_VERSION);
    lua_settable(lua,-3);
}",1375.0,1383.0,1.0,23.0,9.0,2,1,6,1,2,0,1,1,0,0,,0,0,2,1,1,void
6084,342409,luaRegisterLogFunction,1,luaRegisterLogFunction,void luaRegisterLogFunction (lua_State*),script_lua.c,"void luaRegisterLogFunction(lua_State* lua) {
    /* redis.log and log levels. */
    lua_pushstring(lua,""log"");
    lua_pushcfunction(lua,luaLogCommand);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_DEBUG"");
    lua_pushnumber(lua,LL_DEBUG);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_VERBOSE"");
    lua_pushnumber(lua,LL_VERBOSE);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_NOTICE"");
    lua_pushnumber(lua,LL_NOTICE);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_WARNING"");
    lua_pushnumber(lua,LL_WARNING);
    lua_settable(lua,-3);
}",1385.0,1406.0,1.0,23.0,22.0,5,1,15,1,2,0,1,1,0,0,,0,0,2,1,1,void
6085,342472,luaRegisterRedisAPI,1,luaRegisterRedisAPI,void luaRegisterRedisAPI (lua_State*),script_lua.c,"void luaRegisterRedisAPI(lua_State* lua) {
    lua_pushvalue(lua, LUA_GLOBALSINDEX);
    luaSetAllowListProtection(lua);
    lua_pop(lua, 1);

    luaLoadLibraries(lua);

    lua_pushcfunction(lua,luaRedisPcall);
    lua_setglobal(lua, ""pcall"");

    /* Register the redis commands table and fields */
    lua_newtable(lua);

    /* redis.call */
    lua_pushstring(lua,""call"");
    lua_pushcfunction(lua,luaRedisCallCommand);
    lua_settable(lua,-3);

    /* redis.pcall */
    lua_pushstring(lua,""pcall"");
    lua_pushcfunction(lua,luaRedisPCallCommand);
    lua_settable(lua,-3);

    luaRegisterLogFunction(lua);

    luaRegisterVersion(lua);

    /* redis.setresp */
    lua_pushstring(lua,""setresp"");
    lua_pushcfunction(lua,luaSetResp);
    lua_settable(lua,-3);

    /* redis.sha1hex */
    lua_pushstring(lua, ""sha1hex"");
    lua_pushcfunction(lua, luaRedisSha1hexCommand);
    lua_settable(lua, -3);

    /* redis.error_reply and redis.status_reply */
    lua_pushstring(lua, ""error_r...",1408.0,1498.0,1.0,23.0,91.0,16,2,60,4,2,4,1,1,0,4,,0,0,2,1,1,void
6086,342674,luaCreateArray,1,luaCreateArray,"void luaCreateArray (lua_State*,robj**,int)",script_lua.c,"static void luaCreateArray(lua_State *lua, robj **elev, int elec) {
    int j;

    lua_newtable(lua);
    for (j = 0; j < elec; j++) {
        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
        lua_rawseti(lua,-2,j+1);
    }
}",1502.0,1510.0,1.0,1.0,9.0,9,7,11,4,2,1,2,2,0,1,,0,0,6,3,3,void
6087,342826,luaMaskCountHook,1,luaMaskCountHook,"void luaMaskCountHook (lua_State*,lua_Debug*)",script_lua.c,"static void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
    UNUSED(ar);
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    if (scriptInterrupt(rctx) == SCRIPT_KILL) {
        serverLog(LL_NOTICE,""Lua script killed by user with SCRIPT KILL."");

        /*
         * Set the hook to invoke all the time so the user
         * will not be able to catch the error with pcall and invoke
         * pcall again which will prevent the script from ever been killed
         */
        lua_sethook(lua, luaMaskCountHook, LUA_MASKLINE, 0);

        luaPushError(lua,""Script killed by user with SCRIPT KILL..."");
        luaError(lua);
    }
}",1556.0,1573.0,1.0,4.0,18.0,10,9,12,5,0,6,2,2,1,6,,0,2,4,2,2,void
6088,342897,luaErrorInformationDiscard,1,luaErrorInformationDiscard,void luaErrorInformationDiscard (errorInfo*),script_lua.c,"void luaErrorInformationDiscard(errorInfo *err_info) {
    if (err_info->msg) sdsfree(err_info->msg);
    if (err_info->source) sdsfree(err_info->source);
    if (err_info->line) sdsfree(err_info->line);
}",1575.0,1579.0,1.0,1.0,5.0,6,1,6,1,1,9,4,4,3,3,,0,6,2,1,1,void
6089,342929,luaExtractErrorInformation,1,luaExtractErrorInformation,"void luaExtractErrorInformation (lua_State*,errorInfo*)",script_lua.c,"void luaExtractErrorInformation(lua_State *lua, errorInfo *err_info) {
    if (lua_isstring(lua, -1)) {
        err_info->msg = sdscatfmt(sdsempty(), ""ERR %s"", lua_tostring(lua, -1));
        err_info->line = NULL;
        err_info->source = NULL;
        err_info->ignore_err_stats_update = 0;
        return;
    }

    lua_getfield(lua, -1, ""err"");
    if (lua_isstring(lua, -1)) {
        err_info->msg = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""source"");
    if (lua_isstring(lua, -1)) {
        err_info->source = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""line"");
    if (lua_isstring(lua, -1)) {
        err_info->line = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""ignore_error_stats_update"");
    if (lua_isboolean(lua, -1)) {
        err_info->ignore_err_stats_update = lua_toboolean(lua, -1);
    }
    lua_pop(lua, 1);
}",1581.0,1613.0,1.0,1.0,33.0,30,3,28,3,1,13,6,6,0,5,,0,13,4,2,2,void
6090,343059,luaCallFunction,1,luaCallFunction,"void luaCallFunction (scriptRunCtx*,lua_State*,robj**,size_t,robj**,size_t,int)",script_lua.c,"void luaCallFunction(scriptRunCtx* run_ctx, lua_State *lua, robj** keys, size_t nkeys, robj** args, size_t nargs, int debug_enabled) {
    client* c = run_ctx->original_client;
    int delhook = 0;

    /* We must set it before we set the Lua hook, theoretically the
     * Lua hook might be called wheneven we run any Lua instruction
     * such as 'luaSetGlobalArray' and we want the run_ctx to be available
     * each time the Lua hook is invoked. */
    luaSaveOnRegistry(lua, REGISTRY_RUN_CTX_NAME, run_ctx);

    if (server.busy_reply_threshold > 0 && !debug_enabled) {
        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
        delhook = 1;
    } else if (debug_enabled) {
        lua_sethook(lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
        delhook = 1;
    }

    /* Populate the argv and keys table accordingly to the arguments that
     * EVAL received. */
    luaCreateArray(lua,keys,nkeys);
    /* On eval, keys and arguments are globals. */
    if (run_ct...",1615.0,1718.0,1.0,27.0,104.0,30,11,52,17,2,10,10,13,3,5,,0,5,14,7,7,void
6091,343344,luaMemory,1,luaMemory,unsigned long luaMemory (lua_State*),script_lua.c,"unsigned long luaMemory(lua_State *lua) {
    return lua_gc(lua, LUA_GCCOUNT, 0) * 1024LL;
}",1720.0,1722.0,1.0,1.0,3.0,1,1,2,2,2,0,1,1,0,0,,0,0,2,1,1,unsigned long
6092,343388,luaRegisterGlobalProtectionFunction,1,luaRegisterGlobalProtectionFunction,void luaRegisterGlobalProtectionFunction (lua_State*),script_lua.h,void luaRegisterGlobalProtectionFunction(lua_State *lua);,70.0,70.0,6.0,56.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6093,343508,sdsHdrSize,1,sdsHdrSize,int sdsHdrSize (char),sds.c,"static inline int sdsHdrSize(char type) {
    switch(type&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}",45.0,59.0,1.0,16.0,15.0,6,2,6,6,8,0,2,2,0,0,,0,0,2,1,1,int
6094,343557,sdsReqType,1,sdsReqType,char sdsReqType (size_t),sds.c,"static inline char sdsReqType(size_t string_size) {
    if (string_size < 1<<5)
        return SDS_TYPE_5;
    if (string_size < 1<<8)
        return SDS_TYPE_8;
    if (string_size < 1<<16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size < 1ll<<32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}",61.0,75.0,1.0,15.0,15.0,8,2,4,1,3,0,5,5,0,0,,0,0,2,1,1,char
6095,343610,sdsTypeMaxSize,1,sdsTypeMaxSize,size_t sdsTypeMaxSize (char),sds.c,"static inline size_t sdsTypeMaxSize(char type) {
    if (type == SDS_TYPE_5)
        return (1<<5) - 1;
    if (type == SDS_TYPE_8)
        return (1<<8) - 1;
    if (type == SDS_TYPE_16)
        return (1<<16) - 1;
#if (LONG_MAX == LLONG_MAX)
    if (type == SDS_TYPE_32)
        return (1ll<<32) - 1;
#endif
    return -1; /* this is equivalent to the max SDS_TYPE_64 or SDS_TYPE_32 */
}",77.0,89.0,1.0,16.0,13.0,13,4,4,1,4,0,5,5,0,0,,0,0,2,1,1,size_t
6096,343670,_sdsnewlen,1,_sdsnewlen,"sds _sdsnewlen (void*,size_t,int)",sds.c,"sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {
    void *sh;
    sds s;
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    int hdrlen = sdsHdrSize(type);
    unsigned char *fp; /* flags pointer. */
    size_t usable;

    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */
    sh = trymalloc?
        s_trymalloc_usable(hdrlen+initlen+1, &usable) :
        s_malloc_usable(hdrlen+initlen+1, &usable);
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        memset(sh, 0, hdrlen+initlen+1);
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    usable = usable-hdrlen-1;
    if (usable > sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    switch(type) {
        case SDS_TYPE_5: {
            *fp = type | (initlen << S...",104.0,167.0,1.0,16.0,64.0,78,15,89,19,2,15,12,7,2,6,,0,15,6,3,3,sds
6097,343962,sdsnewlen,1,sdsnewlen,"sds sdsnewlen (void*,size_t)",sds.c,"sds sdsnewlen(const void *init, size_t initlen) {
    return _sdsnewlen(init, initlen, 0);
}",169.0,171.0,1.0,1.0,3.0,0,0,2,2,61,1,1,1,0,1,,0,0,4,2,2,sds
6098,343973,sdstrynewlen,1,sdstrynewlen,"sds sdstrynewlen (void*,size_t)",sds.c,"sds sdstrynewlen(const void *init, size_t initlen) {
    return _sdsnewlen(init, initlen, 1);
}",173.0,175.0,1.0,1.0,3.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,sds
6099,343984,sdsempty,1,sdsempty,sds sdsempty (void),sds.c,"sds sdsempty(void) {
    return sdsnewlen("""",0);
}",179.0,181.0,1.0,1.0,3.0,0,0,0,0,165,1,1,1,0,1,,0,0,2,1,1,sds
6100,343993,sdsnew,1,sdsnew,sds sdsnew (char*),sds.c,"sds sdsnew(const char *init) {
    size_t initlen = (init == NULL) ? 0 : strlen(init);
    return sdsnewlen(init, initlen);
}",184.0,187.0,1.0,1.0,4.0,3,3,6,3,177,1,1,1,0,1,,0,0,2,1,1,sds
6101,344012,sdsdup,1,sdsdup,sds sdsdup (sds),sds.c,"sds sdsdup(const sds s) {
    return sdsnewlen(s, sdslen(s));
}",190.0,192.0,1.0,1.0,3.0,0,0,2,1,49,2,1,1,0,2,,0,1,2,1,1,sds
6102,344022,sdsfree,1,sdsfree,void sdsfree (sds),sds.c,"void sdsfree(sds s) {
    if (s == NULL) return;
    s_free((char*)s-sdsHdrSize(s[-1]));
}",195.0,198.0,1.0,4.0,4.0,5,5,4,2,343,2,2,2,0,2,,0,1,2,1,1,void
6103,344045,sdsupdatelen,1,sdsupdatelen,void sdsupdatelen (sds),sds.c,"void sdsupdatelen(sds s) {
    size_t reallen = strlen(s);
    sdssetlen(s, reallen);
}",214.0,217.0,1.0,1.0,4.0,1,1,4,2,1,1,1,1,0,1,,0,0,2,1,1,void
6104,344058,sdsclear,1,sdsclear,void sdsclear (sds),sds.c,"void sdsclear(sds s) {
    sdssetlen(s, 0);
    s[0] = '\0';
}",223.0,226.0,1.0,1.0,4.0,2,2,2,1,7,1,1,1,0,1,,0,0,2,1,1,void
6105,344071,_sdsMakeRoomFor,1,_sdsMakeRoomFor,"sds _sdsMakeRoomFor (sds,size_t,int)",sds.c,"sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {
    void *sh, *newsh;
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;
    size_t usable;

    /* Return ASAP if there is enough space left. */
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s-sdsHdrSize(oldtype);
    reqlen = newlen = (len+addlen);
    assert(newlen > len);   /* Catch size_t overflow */
    if (greedy == 1) {
        if (newlen < SDS_MAX_PREALLOC)
            newlen *= 2;
        else
            newlen += SDS_MAX_PREALLOC;
    }

    type = sdsReqType(newlen);

    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;

    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */
    if (ol...",240.0,291.0,1.0,33.0,52.0,39,14,53,14,2,9,8,10,1,9,,0,8,6,3,3,sds
6106,344291,sdsMakeRoomFor,1,sdsMakeRoomFor,"sds sdsMakeRoomFor (sds,size_t)",sds.c,"sds sdsMakeRoomFor(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 1);
}",295.0,297.0,1.0,1.0,3.0,0,0,2,2,11,1,1,1,0,1,,0,0,4,2,2,sds
6107,344302,sdsMakeRoomForNonGreedy,1,sdsMakeRoomForNonGreedy,"sds sdsMakeRoomForNonGreedy (sds,size_t)",sds.c,"sds sdsMakeRoomForNonGreedy(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 0);
}",300.0,302.0,1.0,1.0,3.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,sds
6108,344313,sdsRemoveFreeSpace,1,sdsRemoveFreeSpace,"sds sdsRemoveFreeSpace (sds,int)",sds.c,"sds sdsRemoveFreeSpace(sds s, int would_regrow) {
    return sdsResize(s, sdslen(s), would_regrow);
}",310.0,312.0,1.0,1.0,3.0,0,0,3,2,2,2,1,1,0,2,,0,1,4,2,2,sds
6109,344325,sdsResize,1,sdsResize,"sds sdsResize (sds,size_t,int)",sds.c,"sds sdsResize(sds s, size_t size, int would_regrow) {
    void *sh, *newsh;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
    size_t len = sdslen(s);
    sh = (char*)s-oldhdrlen;

    /* Return ASAP if the size is already good. */
    if (sdsalloc(s) == size) return s;

    /* Truncate len if needed. */
    if (size < len) len = size;

    /* Check what would be the minimum SDS header that is just good enough to
     * fit this string. */
    type = sdsReqType(size);
    if (would_regrow) {
        /* Don't use type 5, it is not good for strings that are expected to grow back. */
        if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    }
    hdrlen = sdsHdrSize(type);

    /* If the type is the same, or can hold the size in it with low overhead
     * (larger than SDS_TYPE_8), we just realloc(), letting the allocator
     * to do the copy only if really needed. Otherwise if the change is
     * huge, we manually reallocate the string ...",323.0,377.0,1.0,33.0,55.0,38,14,54,14,2,8,7,9,1,8,,0,6,6,3,3,sds
6110,344522,sdsAllocSize,1,sdsAllocSize,size_t sdsAllocSize (sds),sds.c,"size_t sdsAllocSize(sds s) {
    size_t alloc = sdsalloc(s);
    return sdsHdrSize(s[-1])+alloc+1;
}",386.0,389.0,1.0,1.0,4.0,5,4,4,2,2,2,1,1,0,2,,0,1,2,1,1,size_t
6111,344542,sdsAllocPtr,1,sdsAllocPtr,void* sdsAllocPtr (sds),sds.c,"void *sdsAllocPtr(sds s) {
    return (void*) (s-sdsHdrSize(s[-1]));
}",393.0,395.0,1.0,1.0,3.0,4,4,2,1,2,1,1,1,0,1,,0,0,2,1,1,void*
6112,344557,sdsIncrLen,1,sdsIncrLen,"void sdsIncrLen (sds,ssize_t)",sds.c,"void sdsIncrLen(sds s, ssize_t incr) {
    unsigned char flags = s[-1];
    size_t len;
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            unsigned char *fp = ((unsigned char*)s)-1;
            unsigned char oldlen = SDS_TYPE_5_LEN(flags);
            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));
            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);
            len = oldlen+incr;
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
            len = (sh->len += incr);
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
            len = (sh->len += incr);
            break;
        }
        case SDS_TYPE_32: {
         ...",420.0,459.0,1.0,17.0,40.0,110,19,79,15,4,16,7,2,0,0,,0,16,4,2,2,void
6113,344861,sdsgrowzero,1,sdsgrowzero,"sds sdsgrowzero (sds,size_t)",sds.c,"sds sdsgrowzero(sds s, size_t len) {
    size_t curlen = sdslen(s);

    if (len <= curlen) return s;
    s = sdsMakeRoomFor(s,len-curlen);
    if (s == NULL) return NULL;

    /* Make sure added region doesn't contain garbage */
    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
    sdssetlen(s, len);
    return s;
}",466.0,477.0,1.0,1.0,12.0,8,5,19,4,0,3,3,3,0,3,,0,2,4,2,2,sds
6114,344908,sdscatlen,1,sdscatlen,"sds sdscatlen (sds,void*,size_t)",sds.c,"sds sdscatlen(sds s, const void *t, size_t len) {
    size_t curlen = sdslen(s);

    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    memcpy(s+curlen, t, len);
    sdssetlen(s, curlen+len);
    s[curlen+len] = '\0';
    return s;
}",484.0,493.0,1.0,1.0,10.0,8,4,19,5,131,3,2,2,0,3,,0,2,6,3,3,sds
6115,344952,sdscat,1,sdscat,"sds sdscat (sds,char*)",sds.c,"sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}",499.0,501.0,1.0,1.0,3.0,0,0,3,2,108,1,1,1,0,1,,0,0,4,2,2,sds
6116,344964,sdscatsds,1,sdscatsds,"sds sdscatsds (sds,sds)",sds.c,"sds sdscatsds(sds s, const sds t) {
    return sdscatlen(s, t, sdslen(t));
}",507.0,509.0,1.0,1.0,3.0,0,0,3,2,28,2,1,1,0,2,,0,1,4,2,2,sds
6117,344976,sdscpylen,1,sdscpylen,"sds sdscpylen (sds,char*,size_t)",sds.c,"sds sdscpylen(sds s, const char *t, size_t len) {
    if (sdsalloc(s) < len) {
        s = sdsMakeRoomFor(s,len-sdslen(s));
        if (s == NULL) return NULL;
    }
    memcpy(s, t, len);
    s[len] = '\0';
    sdssetlen(s, len);
    return s;
}",513.0,522.0,1.0,1.0,10.0,6,5,17,4,1,4,3,4,1,4,,0,3,6,3,3,sds
6118,345018,sdscpy,1,sdscpy,"sds sdscpy (sds,char*)",sds.c,"sds sdscpy(sds s, const char *t) {
    return sdscpylen(s, t, strlen(t));
}",526.0,528.0,1.0,1.0,3.0,0,0,3,2,3,1,1,1,0,1,,0,0,4,2,2,sds
6119,345030,sdsfromlonglong,1,sdsfromlonglong,sds sdsfromlonglong (long long),sds.c,"sds sdsfromlonglong(long long value) {
    char buf[LONG_STR_SIZE];
    int len = ll2string(buf,sizeof(buf),value);

    return sdsnewlen(buf,len);
}",534.0,539.0,1.0,13.0,6.0,2,2,6,3,9,2,1,1,0,2,,0,1,2,1,1,sds
6120,345048,sdscatvprintf,1,sdscatvprintf,"sds sdscatvprintf (sds,char*,va_list)",sds.c,"sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
    va_list cpy;
    char staticbuf[1024], *buf = staticbuf, *t;
    size_t buflen = strlen(fmt)*2;
    int bufstrlen;

    /* We try to start using a static buffer for speed.
     * If not possible we revert to heap allocation. */
    if (buflen > sizeof(staticbuf)) {
        buf = s_malloc(buflen);
        if (buf == NULL) return NULL;
    } else {
        buflen = sizeof(staticbuf);
    }

    /* Alloc enough space for buffer and \0 after failing to
     * fit the string in the current buffer size. */
    while(1) {
        va_copy(cpy,ap);
        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);
        va_end(cpy);
        if (bufstrlen < 0) {
            if (buf != staticbuf) s_free(buf);
            return NULL;
        }
        if (((size_t)bufstrlen) >= buflen) {
            if (buf != staticbuf) s_free(buf);
            buflen = ((size_t)bufstrlen) + 1;
            buf = s_malloc(buflen);
            if (buf == NULL) re...",542.0,581.0,1.0,14.0,40.0,20,10,44,10,6,6,12,19,0,6,,0,3,6,3,3,sds
6121,345181,sdscatprintf,1,sdscatprintf,"sds sdscatprintf (sds,char*...)",sds.c,"sds sdscatprintf(sds s, const char *fmt, ...) {
    va_list ap;
    char *t;
    va_start(ap, fmt);
    t = sdscatvprintf(s,fmt,ap);
    va_end(ap);
    return t;
}",599.0,606.0,1.0,1.0,8.0,1,1,8,4,125,1,1,1,0,1,,0,1,4,2,2,sds
6122,345202,sdscatfmt,1,sdscatfmt,"sds sdscatfmt (sds,char*...)",sds.c,"sds sdscatfmt(sds s, char const *fmt, ...) {
    size_t initlen = sdslen(s);
    const char *f = fmt;
    long i;
    va_list ap;

    /* To avoid continuous reallocations, let's start with a buffer that
     * can hold at least two times the format string itself. It's not the
     * best heuristic but seems to work in practice. */
    s = sdsMakeRoomFor(s, strlen(fmt)*2);
    va_start(ap,fmt);
    f = fmt;    /* Next format specifier byte to process. */
    i = initlen; /* Position of the next byte to write to dest str. */
    while(*f) {
        char next, *str;
        size_t l;
        long long num;
        unsigned long long unum;

        /* Make sure there is always space for at least 1 char. */
        if (sdsavail(s)==0) {
            s = sdsMakeRoomFor(s,1);
        }

        switch(*f) {
        case '%':
            next = *(f+1);
            if (next == '\0') break;
            f++;
            switch(next) {
            case 's':
            case 'S':
               ...",624.0,717.0,1.0,29.0,94.0,44,11,87,12,87,18,16,24,4,18,,0,13,4,2,2,sds
6123,345431,sdstrim,1,sdstrim,"sds sdstrim (sds,char*)",sds.c,"sds sdstrim(sds s, const char *cset) {
    char *end, *sp, *ep;
    size_t len;

    sp = s;
    ep = end = s+sdslen(s)-1;
    while(sp <= end && strchr(cset, *sp)) sp++;
    while(ep > sp && strchr(cset, *ep)) ep--;
    len = (ep-sp)+1;
    if (s != sp) memmove(s, sp, len);
    s[len] = '\0';
    sdssetlen(s,len);
    return s;
}",733.0,746.0,1.0,1.0,14.0,17,9,27,6,10,2,4,4,0,2,,0,1,4,2,2,sds
6124,345502,sdssubstr,1,sdssubstr,"void sdssubstr (sds,size_t,size_t)",sds.c,"void sdssubstr(sds s, size_t start, size_t len) {
    /* Clamp out of range input */
    size_t oldlen = sdslen(s);
    if (start >= oldlen) start = len = 0;
    if (len > oldlen-start) len = oldlen-start;

    /* Move the data */
    if (len) memmove(s, s+start, len);
    s[len] = 0;
    sdssetlen(s,len);
}",751.0,761.0,1.0,1.0,11.0,11,6,21,4,1,2,4,4,0,2,,0,1,6,3,3,void
6125,345553,sdsrange,1,sdsrange,"void sdsrange (sds,ssize_t,ssize_t)",sds.c,"void sdsrange(sds s, ssize_t start, ssize_t end) {
    size_t newlen, len = sdslen(s);
    if (len == 0) return;
    if (start < 0)
        start = len + start;
    if (end < 0)
        end = len + end;
    newlen = (start > end) ? 0 : (end-start)+1;
    sdssubstr(s, start, newlen);
}",784.0,793.0,1.0,1.0,10.0,13,7,19,5,18,2,4,4,0,2,,0,1,6,3,3,void
6126,345608,sdstolower,1,sdstolower,void sdstolower (sds),sds.c,"void sdstolower(sds s) {
    size_t len = sdslen(s), j;

    for (j = 0; j < len; j++) s[j] = tolower(s[j]);
}",796.0,800.0,1.0,1.0,5.0,3,2,5,3,4,1,2,2,0,1,,0,1,2,1,1,void
6127,345637,sdstoupper,1,sdstoupper,void sdstoupper (sds),sds.c,"void sdstoupper(sds s) {
    size_t len = sdslen(s), j;

    for (j = 0; j < len; j++) s[j] = toupper(s[j]);
}",803.0,807.0,1.0,1.0,5.0,3,2,5,3,6,1,2,2,0,1,,0,1,2,1,1,void
6128,345666,sdscmp,1,sdscmp,"int sdscmp (sds,sds)",sds.c,"int sdscmp(const sds s1, const sds s2) {
    size_t l1, l2, minlen;
    int cmp;

    l1 = sdslen(s1);
    l2 = sdslen(s2);
    minlen = (l1 < l2) ? l1 : l2;
    cmp = memcmp(s1,s2,minlen);
    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
    return cmp;
}",820.0,830.0,1.0,1.0,11.0,12,6,19,6,11,2,2,2,0,2,,0,2,4,2,2,int
6129,345718,sdssplitlen,1,sdssplitlen,"sds sdssplitlen (char*,ssize_t,char*,int,int*)",sds.c,"sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {
    int elements = 0, slots = 5;
    long start = 0, j;
    sds *tokens;

    if (seplen < 1 || len <= 0) {
        *count = 0;
        return NULL;
    }
    tokens = s_malloc(sizeof(sds)*slots);
    if (tokens == NULL) return NULL;

    for (j = 0; j < (len-(seplen-1)); j++) {
        /* make sure there is room for the next element and the final one */
        if (slots < elements+2) {
            sds *newtokens;

            slots *= 2;
            newtokens = s_realloc(tokens,sizeof(sds)*slots);
            if (newtokens == NULL) goto cleanup;
            tokens = newtokens;
        }
        /* search the separator */
        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
            tokens[elements] = sdsnewlen(s+start,j-start);
            if (tokens[elements] == NULL) goto cleanup;
            elements++;
            start = j+seplen;
            j = j+seplen-1;...",848.0,894.0,1.0,13.0,47.0,58,14,71,14,16,5,13,16,0,5,,0,4,10,5,5,sds
6130,345927,sdsfreesplitres,1,sdsfreesplitres,"void sdsfreesplitres (sds*,int)",sds.c,"void sdsfreesplitres(sds *tokens, int count) {
    if (!tokens) return;
    while(count--)
        sdsfree(tokens[count]);
    s_free(tokens);
}",897.0,902.0,1.0,4.0,6.0,2,2,3,2,74,1,3,3,0,1,,0,0,4,2,2,void
6131,345949,sdscatrepr,1,sdscatrepr,"sds sdscatrepr (sds,char*,size_t)",sds.c,"sds sdscatrepr(sds s, const char *p, size_t len) {
    s = sdsMakeRoomFor(s, len + 2);
    s = sdscatlen(s,""\"""",1);
    while(len--) {
        switch(*p) {
        case '\\':
        case '""':
            s = sdscatprintf(s,""\\%c"",*p);
            break;
        case '\n': s = sdscatlen(s,""\\n"",2); break;
        case '\r': s = sdscatlen(s,""\\r"",2); break;
        case '\t': s = sdscatlen(s,""\\t"",2); break;
        case '\a': s = sdscatlen(s,""\\a"",2); break;
        case '\b': s = sdscatlen(s,""\\b"",2); break;
        default:
            if (isprint(*p))
                s = sdscatlen(s, p, 1);
            else
                s = sdscatprintf(s,""\\x%02x"",(unsigned char)*p);
            break;
        }
        p++;
    }
    return sdscatlen(s,""\"""",1);
}",910.0,934.0,1.0,1.0,25.0,15,5,26,3,16,10,11,7,0,10,,0,9,6,3,3,sds
6132,346065,sdsneedsrepr,1,sdsneedsrepr,int sdsneedsrepr (sds),sds.c,"int sdsneedsrepr(const sds s) {
    size_t len = sdslen(s);
    const char *p = s;

    while (len--) {
        if (*p == '\\' || *p == '""' || *p == '\n' || *p == '\r' ||
            *p == '\t' || *p == '\a' || *p == '\b' || !isprint(*p) || isspace(*p)) return 1;
        p++;
    }

    return 0;
}",943.0,954.0,1.0,1.0,12.0,29,7,15,3,1,1,3,4,0,1,,0,1,2,1,1,int
6133,346134,is_hex_digit,1,is_hex_digit,int is_hex_digit (char),sds.c,"int is_hex_digit(char c) {
    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
           (c >= 'A' && c <= 'F');
}",958.0,961.0,1.0,1.0,4.0,11,4,6,1,2,0,1,1,0,0,,0,0,2,1,1,int
6134,346163,hex_digit_to_int,1,hex_digit_to_int,int hex_digit_to_int (char),sds.c,"int hex_digit_to_int(char c) {
    switch(c) {
    case '0': return 0;
    case '1': return 1;
    case '2': return 2;
    case '3': return 3;
    case '4': return 4;
    case '5': return 5;
    case '6': return 6;
    case '7': return 7;
    case '8': return 8;
    case '9': return 9;
    case 'a': case 'A': return 10;
    case 'b': case 'B': return 11;
    case 'c': case 'C': return 12;
    case 'd': case 'D': return 13;
    case 'e': case 'E': return 14;
    case 'f': case 'F': return 15;
    default: return 0;
    }
}",965.0,985.0,1.0,1.0,21.0,0,0,1,1,2,0,2,2,0,0,,0,0,2,1,1,int
6135,346250,sdssplitargs,1,sdssplitargs,"sds sdssplitargs (char*,int*)",sds.c,"sds *sdssplitargs(const char *line, int *argc) {
    const char *p = line;
    char *current = NULL;
    char **vector = NULL;

    *argc = 0;
    while(1) {
        /* skip blanks */
        while(*p && isspace(*p)) p++;
        if (*p) {
            /* get a token */
            int inq=0;  /* set to 1 if we are in ""quotes"" */
            int insq=0; /* set to 1 if we are in 'single quotes' */
            int done=0;

            if (current == NULL) current = sdsempty();
            while(!done) {
                if (inq) {
                    if (*p == '\\' && *(p+1) == 'x' &&
                                             is_hex_digit(*(p+2)) &&
                                             is_hex_digit(*(p+3)))
                    {
                        unsigned char byte;

                        byte = (hex_digit_to_int(*(p+2))*16)+
                                hex_digit_to_int(*(p+3));
                        current = sdscatlen(current,(char*)&byte,1);
                 ...",1006.0,1114.0,1.0,21.0,109.0,55,14,47,11,16,9,11,27,2,9,,0,7,4,2,2,sds
6136,346651,sdsmapchars,1,sdsmapchars,"sds sdsmapchars (sds,char*,char*,size_t)",sds.c,"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
    size_t j, i, l = sdslen(s);

    for (j = 0; j < l; j++) {
        for (i = 0; i < setlen; i++) {
            if (s[j] == from[i]) {
                s[j] = to[i];
                break;
            }
        }
    }
    return s;
}",1125.0,1137.0,1.0,1.0,13.0,11,4,17,7,5,1,5,7,0,1,,0,1,8,4,4,sds
6137,346707,sdsjoin,1,sdsjoin,"sds sdsjoin (char**,int,char*)",sds.c,"sds sdsjoin(char **argv, int argc, char *sep) {
    sds join = sdsempty();
    int j;

    for (j = 0; j < argc; j++) {
        join = sdscat(join, argv[j]);
        if (j != argc-1) join = sdscat(join,sep);
    }
    return join;
}",1141.0,1150.0,1.0,1.0,10.0,8,5,14,5,2,3,3,4,0,3,,0,3,6,3,3,sds
6138,346751,sdsjoinsds,1,sdsjoinsds,"sds sdsjoinsds (sds*,int,char*,size_t)",sds.c,"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
    sds join = sdsempty();
    int j;

    for (j = 0; j < argc; j++) {
        join = sdscatsds(join, argv[j]);
        if (j != argc-1) join = sdscatlen(join,sep,seplen);
    }
    return join;
}",1153.0,1162.0,1.0,1.0,10.0,8,5,15,6,1,3,3,4,0,3,,0,3,8,4,4,sds
6139,346797,sds_malloc,1,sds_malloc,void* sds_malloc (size_t),sds.c,void *sds_malloc(size_t size) { return s_malloc(size); },1169.0,1169.0,1.0,39.0,1.0,0,0,1,1,2,1,1,1,0,1,,0,0,2,1,1,void*
6140,346807,sds_realloc,1,sds_realloc,"void* sds_realloc (void*,size_t)",sds.c,"void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }",1170.0,1170.0,1.0,51.0,1.0,0,0,2,2,2,1,1,1,0,1,,0,0,4,2,2,void*
6141,346819,sds_free,1,sds_free,void sds_free (void*),sds.c,void sds_free(void *ptr) { s_free(ptr); },1171.0,1171.0,1.0,27.0,1.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
6142,346828,sdstemplate,1,sdstemplate,"sds sdstemplate (char*,sdstemplate_callback_t,void*)",sds.c,"sds sdstemplate(const char *template, sdstemplate_callback_t cb_func, void *cb_arg)
{
    sds res = sdsempty();
    const char *p = template;

    while (*p) {
        /* Find next variable, copy everything until there */
        const char *sv = strchr(p, '{');
        if (!sv) {
            /* Not found: copy till rest of template and stop */
            res = sdscat(res, p);
            break;
        } else if (sv > p) {
            /* Found: copy anything up to the beginning of the variable */
            res = sdscatlen(res, p, sv - p);
        }

        /* Skip into variable name, handle premature end or quoting */
        sv++;
        if (!*sv) goto error;       /* Premature end of template */
        if (*sv == '{') {
            /* Quoted '{' */
            p = sv + 1;
            res = sdscat(res, ""{"");
            continue;
        }

        /* Find end of variable name, handle premature end of template */
        const char *ev = strchr(sv, '}');
        if (!ev) got...",1179.0,1228.0,1.0,1.0,50.0,23,7,38,9,1,8,12,12,0,8,,0,5,6,3,3,sds
6143,347015,sdslen,1,sdslen,size_t sdslen (sds),sds.h,"static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}",87.0,102.0,1.0,17.0,16.0,21,9,17,6,383,0,2,2,0,0,,0,0,2,1,1,size_t
6144,347111,sdsavail,1,sdsavail,size_t sdsavail (sds),sds.h,"static inline size_t sdsavail(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            return 0;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            return sh->alloc - sh->len;
        }
    }
    return 0;
}",104.0,128.0,1.0,17.0,25.0,32,8,27,11,14,8,2,2,0,0,,0,8,2,1,1,size_t
6145,347239,sdssetlen,1,sdssetlen,"void sdssetlen (sds,size_t)",sds.h,"static inline void sdssetlen(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len = newlen;
            break;
    }
}",130.0,152.0,1.0,17.0,23.0,31,11,23,8,12,0,7,2,0,0,,0,0,4,2,2,void
6146,347357,sdsinclen,1,sdsinclen,"void sdsinclen (sds,size_t)",sds.h,"static inline void sdsinclen(sds s, size_t inc) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len += inc;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len += inc;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len += inc;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len += inc;
            break;
    }
}",154.0,177.0,1.0,17.0,24.0,34,14,27,9,5,0,7,2,0,0,,0,0,4,2,2,void
6147,347486,sdsalloc,1,sdsalloc,size_t sdsalloc (sds),sds.h,"static inline size_t sdsalloc(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->alloc;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->alloc;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->alloc;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->alloc;
    }
    return 0;
}",180.0,195.0,1.0,17.0,16.0,21,9,17,6,7,0,2,2,0,0,,0,0,2,1,1,size_t
6148,347582,sdssetalloc,1,sdssetalloc,"void sdssetalloc (sds,size_t)",sds.h,"static inline void sdssetalloc(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            /* Nothing to do, this type has no total allocation info. */
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->alloc = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->alloc = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->alloc = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->alloc = newlen;
            break;
    }
}",197.0,216.0,1.0,17.0,20.0,24,8,19,7,2,0,7,2,0,0,,0,0,4,2,2,void
6149,347875,sdstemplate_callback_t,1,sdstemplate_callback_t,"sds sdstemplate_callback_t (sds,void*)",sds.h,"typedef sds (*sdstemplate_callback_t)(const sds variable, void *arg);",263.0,263.0,13.0,68.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
6150,348152,redisAeReadEvent,1,redisAeReadEvent,"void redisAeReadEvent (aeEventLoop*,int,void*,int)",sentinel.c,"static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
    ((void)el); ((void)fd); ((void)mask);

    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAsyncHandleRead(e->context);
}",304.0,309.0,1.0,1.0,6.0,6,3,6,5,0,1,1,1,0,0,,0,1,8,4,4,void
6151,348179,redisAeWriteEvent,1,redisAeWriteEvent,"void redisAeWriteEvent (aeEventLoop*,int,void*,int)",sentinel.c,"static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
    ((void)el); ((void)fd); ((void)mask);

    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAsyncHandleWrite(e->context);
}",311.0,316.0,1.0,1.0,6.0,6,3,6,5,0,1,1,1,0,0,,0,1,8,4,4,void
6152,348206,redisAeAddRead,1,redisAeAddRead,void redisAeAddRead (void*),sentinel.c,"static void redisAeAddRead(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (!e->reading) {
        e->reading = 1;
        aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);
    }
}",318.0,325.0,1.0,37.0,8.0,9,4,9,3,0,5,2,2,1,1,,0,4,2,1,1,void
6153,348244,redisAeDelRead,1,redisAeDelRead,void redisAeDelRead (void*),sentinel.c,"static void redisAeDelRead(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (e->reading) {
        e->reading = 0;
        aeDeleteFileEvent(loop,e->fd,AE_READABLE);
    }
}",327.0,334.0,1.0,37.0,8.0,8,3,8,3,1,5,2,2,1,1,,0,4,2,1,1,void
6154,348279,redisAeAddWrite,1,redisAeAddWrite,void redisAeAddWrite (void*),sentinel.c,"static void redisAeAddWrite(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (!e->writing) {
        e->writing = 1;
        aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);
    }
}",336.0,343.0,1.0,37.0,8.0,9,4,9,3,0,5,2,2,1,1,,0,4,2,1,1,void
6155,348317,redisAeDelWrite,1,redisAeDelWrite,void redisAeDelWrite (void*),sentinel.c,"static void redisAeDelWrite(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (e->writing) {
        e->writing = 0;
        aeDeleteFileEvent(loop,e->fd,AE_WRITABLE);
    }
}",345.0,352.0,1.0,37.0,8.0,8,3,8,3,1,5,2,2,1,1,,0,4,2,1,1,void
6156,348352,redisAeCleanup,1,redisAeCleanup,void redisAeCleanup (void*),sentinel.c,"static void redisAeCleanup(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAeDelRead(privdata);
    redisAeDelWrite(privdata);
    zfree(e);
}",354.0,359.0,1.0,1.0,6.0,2,2,5,2,0,3,1,1,0,3,,0,0,2,1,1,void
6157,348369,redisAeAttach,1,redisAeAttach,"int redisAeAttach (aeEventLoop*,redisAsyncContext*)",sentinel.c,"static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
    redisContext *c = &(ac->c);
    redisAeEvents *e;

    /* Nothing should be attached when something is already attached */
    if (ac->ev.data != NULL)
        return C_ERR;

    /* Create container for context and r/w events */
    e = (redisAeEvents*)zmalloc(sizeof(*e));
    e->context = ac;
    e->loop = loop;
    e->fd = c->fd;
    e->reading = e->writing = 0;

    /* Register functions to start/stop listening for events */
    ac->ev.addRead = redisAeAddRead;
    ac->ev.delRead = redisAeDelRead;
    ac->ev.addWrite = redisAeAddWrite;
    ac->ev.delWrite = redisAeDelWrite;
    ac->ev.cleanup = redisAeCleanup;
    ac->ev.data = e;

    return C_OK;
}",361.0,385.0,1.0,15.0,25.0,40,9,21,5,0,6,2,2,0,1,,0,6,4,2,2,int
6158,348477,sentinelLinkEstablishedCallback,1,sentinelLinkEstablishedCallback,"void sentinelLinkEstablishedCallback (redisAsyncContext*,int)",sentinel.c,"void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
    if (status != C_OK) instanceLinkConnectionError(c);
}",1252.0,1254.0,1.0,18.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6159,348483,sentinelDisconnectCallback,1,sentinelDisconnectCallback,"void sentinelDisconnectCallback (redisAsyncContext*,int)",sentinel.c,"void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
    UNUSED(status);
    instanceLinkConnectionError(c);
}",1256.0,1259.0,1.0,4.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6160,348489,sentinelReceiveHelloMessages,1,sentinelReceiveHelloMessages,"void sentinelReceiveHelloMessages (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    redisReply *r;
    UNUSED(c);

    if (!reply || !ri) return;
    r = reply;

    /* Update the last activity in the pubsub channel. Note that since we
     * receive our messages as well this timestamp can be used to detect
     * if the link is probably disconnected even if it seems otherwise. */
    ri->link->pc_last_activity = mstime();

    /* Sanity check in the reply we expect, so that the code that follows
     * can avoid to check for details.
     * Note: Reply type is PUSH in resp3. Normally, sentinel will not use
     * resp3 but this is required for testing (see logreqres.c). */
    if ((r->type != REDIS_REPLY_ARRAY && r->type != REDIS_REPLY_PUSH) ||
        r->elements != 3 ||
        r->element[0]->type != REDIS_REPLY_STRING ||
        r->element[1]->type != REDIS_REPLY_STRING ||
        r->element[2]->type != REDIS_REPLY_STRING ||
     ...",2976.0,3004.0,1.0,4.0,29.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6161,348496,sentinelGetMasterByName,1,sentinelGetMasterByName,sentinelRedisInstance* sentinelGetMasterByName (char*),sentinel.c,"sentinelRedisInstance *sentinelGetMasterByName(char *name) {
    sentinelRedisInstance *ri;
    sds sdsname = sdsnew(name);

    ri = dictFetchValue(sentinel.masters,sdsname);
    sdsfree(sdsname);
    return ri;
}",1512.0,1519.0,1.0,1.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sentinelRedisInstance
6162,348501,sentinelGetSubjectiveLeader,1,sentinelGetSubjectiveLeader,char* sentinelGetSubjectiveLeader (sentinelRedisInstance*),sentinel.c,char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);,393.0,393.0,6.0,64.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
6163,348506,sentinelGetObjectiveLeader,1,sentinelGetObjectiveLeader,char* sentinelGetObjectiveLeader (sentinelRedisInstance*),sentinel.c,char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);,394.0,394.0,6.0,63.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
6164,348511,instanceLinkConnectionError,1,instanceLinkConnectionError,void instanceLinkConnectionError (redisAsyncContext*),sentinel.c,"void instanceLinkConnectionError(const redisAsyncContext *c) {
    instanceLink *link = c->data;
    int pubsub;

    if (!link) return;

    pubsub = (link->pc == c);
    if (pubsub)
        link->pc = NULL;
    else
        link->cc = NULL;
    link->disconnected = 1;
}",1236.0,1248.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6165,348516,sentinelRedisInstanceTypeStr,1,sentinelRedisInstanceTypeStr,char* sentinelRedisInstanceTypeStr (sentinelRedisInstance*),sentinel.c,"const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {
    if (ri->flags & SRI_MASTER) return ""master"";
    else if (ri->flags & SRI_SLAVE) return ""slave"";
    else if (ri->flags & SRI_SENTINEL) return ""sentinel"";
    else return ""unknown"";
}",1434.0,1439.0,1.0,20.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,const char*
6166,348521,sentinelAbortFailover,1,sentinelAbortFailover,void sentinelAbortFailover (sentinelRedisInstance*),sentinel.c,"void sentinelAbortFailover(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
    serverAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);

    ri->flags &= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
    ri->failover_state_change_time = mstime();
    if (ri->promoted_slave) {
        ri->promoted_slave->flags &= ~SRI_PROMOTED;
        ri->promoted_slave = NULL;
    }
}",5360.0,5371.0,1.0,4.0,12.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,void
6167,348526,sentinelEvent,1,sentinelEvent,"void sentinelEvent (int,char*,sentinelRedisInstance*,char*...)",sentinel.c,"void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                   const char *fmt, ...) {
    va_list ap;
    char msg[LOG_MAX_LEN];
    robj *channel, *payload;

    /* Handle %@ */
    if (fmt[0] == '%' && fmt[1] == '@') {
        sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ?
                                         NULL : ri->master;

        if (master) {
            snprintf(msg, sizeof(msg), ""%s %s %s %d @ %s %s %d"",
                sentinelRedisInstanceTypeStr(ri),
                ri->name, announceSentinelAddr(ri->addr), ri->addr->port,
                master->name, announceSentinelAddr(master->addr), master->addr->port);
        } else {
            snprintf(msg, sizeof(msg), ""%s %s %s %d"",
                sentinelRedisInstanceTypeStr(ri),
                ri->name, announceSentinelAddr(ri->addr), ri->addr->port);
        }
        fmt += 2;
    } else {
        msg[0] = '\0';
    }

    /* Use vsprintf for the rest of the formatting if any...",669.0,724.0,1.0,13.0,56.0,0,0,0,0,37,0,1,1,0,0,,0,0,8,4,4,void
6168,348534,sentinelSelectSlave,1,sentinelSelectSlave,sentinelRedisInstance* sentinelSelectSlave (sentinelRedisInstance*),sentinel.c,"sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance **instance =
        zmalloc(sizeof(instance[0])*dictSize(master->slaves));
    sentinelRedisInstance *selected = NULL;
    int instances = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t max_master_down_time = 0;

    if (master->flags & SRI_S_DOWN)
        max_master_down_time += mstime() - master->s_down_since_time;
    max_master_down_time += master->down_after_period * 10;

    di = dictGetIterator(master->slaves);

    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);
        mstime_t info_validity_time;

        if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        if (slave->link->disconnected) continue;
        if (mstime() - slave->link->last_avail_time > sentinel_ping_period*5) continue;
        if (slave->slave_priority == 0) continue;

        /* If the master is in SDOWN state we get INFO for slaves every secon...",5062.0,5105.0,1.0,36.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sentinelRedisInstance
6169,348539,sentinelScheduleScriptExecution,1,sentinelScheduleScriptExecution,void sentinelScheduleScriptExecution (char*...),sentinel.c,"void sentinelScheduleScriptExecution(char *path, ...) {
    va_list ap;
    char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
    int argc = 1;
    sentinelScriptJob *sj;

    va_start(ap, path);
    while(argc < SENTINEL_SCRIPT_MAX_ARGS) {
        argv[argc] = va_arg(ap,char*);
        if (!argv[argc]) break;
        argv[argc] = sdsnew(argv[argc]); /* Copy the string. */
        argc++;
    }
    va_end(ap);
    argv[0] = sdsnew(path);

    sj = zmalloc(sizeof(*sj));
    sj->flags = SENTINEL_SCRIPT_NONE;
    sj->retry_num = 0;
    sj->argv = zmalloc(sizeof(char*)*(argc+1));
    sj->start_time = 0;
    sj->pid = 0;
    memcpy(sj->argv,argv,sizeof(char*)*(argc+1));

    listAddNodeTail(sentinel.scripts_queue,sj);

    /* Remove the oldest non running script if we already hit the limit. */
    if (listLength(sentinel.scripts_queue) > SENTINEL_SCRIPT_MAX_QUEUE) {
        listNode *ln;
        listIter li;

        listRewind(sentinel.scripts_queue,&li);
        while ((ln = listNext(&li)) != NU...",754.0,798.0,1.0,15.0,45.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6170,348544,sentinelStartFailover,1,sentinelStartFailover,void sentinelStartFailover (sentinelRedisInstance*),sentinel.c,"void sentinelStartFailover(sentinelRedisInstance *master) {
    serverAssert(master->flags & SRI_MASTER);

    master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
    master->flags |= SRI_FAILOVER_IN_PROGRESS;
    master->failover_epoch = ++sentinel.current_epoch;
    sentinelEvent(LL_WARNING,""+new-epoch"",master,""%llu"",
        (unsigned long long) sentinel.current_epoch);
    sentinelEvent(LL_WARNING,""+try-failover"",master,""%@"");
    master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
    master->failover_state_change_time = mstime();
}",4948.0,4959.0,1.0,4.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6171,348549,sentinelDiscardReplyCallback,1,sentinelDiscardReplyCallback,"void sentinelDiscardReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    instanceLink *link = c->data;
    UNUSED(reply);
    UNUSED(privdata);

    if (link) link->pending_commands--;
}",2785.0,2791.0,1.0,4.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6172,348556,sentinelSendSlaveOf,1,sentinelSendSlaveOf,"int sentinelSendSlaveOf (sentinelRedisInstance*,sentinelAddr*)",sentinel.c,"int sentinelSendSlaveOf(sentinelRedisInstance *ri, const sentinelAddr *addr) {
    char portstr[32];
    const char *host;
    int retval;

    /* If host is NULL we send SLAVEOF NO ONE that will turn the instance
    * into a master. */
    if (!addr) {
        host = ""NO"";
        memcpy(portstr,""ONE"",4);
    } else {
        host = announceSentinelAddr(addr);
        ll2string(portstr,sizeof(portstr),addr->port);
    }

    /* In order to send SLAVEOF in a safe way, we send a transaction performing
     * the following tasks:
     * 1) Reconfigure the instance according to the specified host/port params.
     * 2) Rewrite the configuration.
     * 3) Disconnect all clients (but this one sending the command) in order
     *    to trigger the ask-master-on-reconnection protocol for connected
     *    clients.
     *
     * Note that we don't check the replies returned by commands, since we
     * will observe instead the effects in the next INFO output. */
    retval = redisAsyncC...",4880.0,4945.0,1.0,18.0,66.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
6173,348562,sentinelVoteLeader,1,sentinelVoteLeader,"char* sentinelVoteLeader (sentinelRedisInstance*,uint64_t,char*,uint64_t*)",sentinel.c,"char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
    if (req_epoch > sentinel.current_epoch) {
        sentinel.current_epoch = req_epoch;
        sentinelFlushConfig();
        sentinelEvent(LL_WARNING,""+new-epoch"",master,""%llu"",
            (unsigned long long) sentinel.current_epoch);
    }

    if (master->leader_epoch < req_epoch && sentinel.current_epoch <= req_epoch)
    {
        sdsfree(master->leader);
        master->leader = sdsnew(req_runid);
        master->leader_epoch = sentinel.current_epoch;
        sentinelFlushConfig();
        sentinelEvent(LL_WARNING,""+vote-for-leader"",master,""%s %llu"",
            master->leader, (unsigned long long) master->leader_epoch);
        /* If we did not voted for ourselves, set the master failover start
         * time to now, in order to force a delay before we can start a
         * failover for the same master. */
        if (strcasecmp(master->leader,sentinel....",4749.0,4774.0,1.0,22.0,26.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,char*
6174,348570,sentinelFlushConfig,1,sentinelFlushConfig,int sentinelFlushConfig (void),sentinel.c,"int sentinelFlushConfig(void) {
    int saved_hz = server.hz;
    int rewrite_status;

    server.hz = CONFIG_DEFAULT_HZ;
    rewrite_status = rewriteConfig(server.configfile, 0);
    server.hz = saved_hz;

    if (rewrite_status == -1) {
        serverLog(LL_WARNING,""WARNING: Sentinel was not able to save the new configuration on disk!!!: %s"", strerror(errno));
        return C_ERR;
    } else {
        serverLog(LL_NOTICE,""Sentinel new configuration saved on disk"");
        return C_OK;
    }
}",2282.0,2297.0,1.0,16.0,16.0,0,0,0,0,7,0,1,1,0,0,,0,0,2,1,1,int
6175,348575,sentinelGenerateInitialMonitorEvents,1,sentinelGenerateInitialMonitorEvents,void sentinelGenerateInitialMonitorEvents (void),sentinel.c,"void sentinelGenerateInitialMonitorEvents(void) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        sentinelEvent(LL_WARNING,""+monitor"",ri,""%@ quorum %d"",ri->quorum);
    }
    dictReleaseIterator(di);
}",730.0,740.0,1.0,22.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6176,348580,sentinelSendPing,1,sentinelSendPing,int sentinelSendPing (sentinelRedisInstance*),sentinel.c,"int sentinelSendPing(sentinelRedisInstance *ri) {
    int retval = redisAsyncCommand(ri->link->cc,
        sentinelPingReplyCallback, ri, ""%s"",
        sentinelInstanceMapCommand(ri,""PING""));
    if (retval == C_OK) {
        ri->link->pending_commands++;
        ri->link->last_ping_time = mstime();
        /* We update the active ping time only if we received the pong for
         * the previous ping, otherwise we are technically waiting since the
         * first ping that did not receive a reply. */
        if (ri->link->act_ping_time == 0)
            ri->link->act_ping_time = ri->link->last_ping_time;
        return 1;
    } else {
        return 0;
    }
}",3096.0,3112.0,1.0,18.0,17.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
6177,348585,sentinelForceHelloUpdateForMaster,1,sentinelForceHelloUpdateForMaster,int sentinelForceHelloUpdateForMaster (sentinelRedisInstance*),sentinel.c,"int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
    if (!(master->flags & SRI_MASTER)) return C_ERR;
    if (master->last_pub_time >= (sentinel_publish_period+1))
        master->last_pub_time -= (sentinel_publish_period+1);
    sentinelForceHelloUpdateDictOfRedisInstances(master->sentinels);
    sentinelForceHelloUpdateDictOfRedisInstances(master->slaves);
    return C_OK;
}",3082.0,3089.0,1.0,26.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
6178,348590,getSentinelRedisInstanceByAddrAndRunID,1,getSentinelRedisInstanceByAddrAndRunID,"sentinelRedisInstance* getSentinelRedisInstanceByAddrAndRunID (dict*,char*,int,char*)",sentinel.c,"sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *addr, int port, char *runid) {
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *instance = NULL;
    sentinelAddr *ri_addr = NULL;

    serverAssert(addr || runid);   /* User must pass at least one search param. */
    if (addr != NULL) {
        /* Try to resolve addr. If hostnames are used, we're accepting an ri_addr
         * that contains an hostname only and can still be matched based on that.
         */
        ri_addr = createSentinelAddr(addr,port,1);
        if (!ri_addr) return NULL;
    }
    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (runid && !ri->runid) continue;
        if ((runid == NULL || strcmp(ri->runid, runid) == 0) &&
            (addr == NULL || sentinelAddrOrHostnameEqual(ri->addr, ri_addr)))
        {
            instance = ri;
            break;
        }
    ...",1478.0,1509.0,1.0,4.0,32.0,0,0,0,0,3,0,1,1,0,0,,0,0,8,4,4,sentinelRedisInstance
6179,348598,sentinelSimFailureCrash,1,sentinelSimFailureCrash,void sentinelSimFailureCrash (void),sentinel.c,"void sentinelSimFailureCrash(void) {
    serverLog(LL_WARNING,
        ""Sentinel CRASH because of SENTINEL simulate-failure"");
    exit(99);
}",4738.0,4742.0,1.0,4.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
6180,348603,releaseSentinelRedisInstance,1,releaseSentinelRedisInstance,void releaseSentinelRedisInstance (sentinelRedisInstance*),sentinel.c,"void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
    /* Release all its slaves or sentinels if any. */
    dictRelease(ri->sentinels);
    dictRelease(ri->slaves);

    /* Disconnect the instance. */
    releaseInstanceLink(ri->link,ri);

    /* Free other resources. */
    sdsfree(ri->name);
    sdsfree(ri->runid);
    sdsfree(ri->notification_script);
    sdsfree(ri->client_reconfig_script);
    sdsfree(ri->slave_master_host);
    sdsfree(ri->leader);
    sdsfree(ri->auth_pass);
    sdsfree(ri->auth_user);
    sdsfree(ri->info);
    releaseSentinelAddr(ri->addr);
    dictRelease(ri->renamed_commands);

    /* Clear state into the master if needed. */
    if ((ri->flags & SRI_SLAVE) && (ri->flags & SRI_PROMOTED) && ri->master)
        ri->master->promoted_slave = NULL;

    zfree(ri);
}",1381.0,1407.0,1.0,21.0,27.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6181,348608,dictInstancesValDestructor,1,dictInstancesValDestructor,"void dictInstancesValDestructor (dict*,void*)",sentinel.c,"void dictInstancesValDestructor (dict *d, void *obj) {
    UNUSED(d);
    releaseSentinelRedisInstance(obj);
}",416.0,419.0,1.0,4.0,4.0,1,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void
6182,348655,sentinelSetCommand,1,sentinelSetCommand,void sentinelSetCommand (client*),sentinel.c,"void sentinelSetCommand(client *c) {
    sentinelRedisInstance *ri;
    int j, changes = 0;
    int badarg = 0; /* Bad argument position for error reporting. */
    char *option;
    int redacted;

    if ((ri = sentinelGetMasterByNameOrReplyError(c,c->argv[2]))
        == NULL) return;

    /* Process option - value pairs. */
    for (j = 3; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        option = c->argv[j]->ptr;
        long long ll;
        int old_j = j; /* Used to know what to log as an event. */
        redacted = 0;

        if (!strcasecmp(option,""down-after-milliseconds"") && moreargs > 0) {
            /* down-after-milliseconds <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            ri->down_after_period = ll;
            sentinelPropagateDownAfterPeriod(ri);
            changes++;
        } else if (!strc...",4345.0,4517.0,1.0,48.0,173.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6183,348660,sentinelConfigGetCommand,1,sentinelConfigGetCommand,void sentinelConfigGetCommand (client*),sentinel.c,"void sentinelConfigGetCommand(client *c) {
    char *pattern;
    void *replylen = addReplyDeferredLen(c);
    int matches = 0;
    /* Create a dictionary to store the input configs,to avoid adding duplicate twice */
    dict *d = dictCreate(&externalStringType);
    for (int i = 3; i < c->argc; i++) {
        pattern = c->argv[i]->ptr;
        /* If the string doesn't contain glob patterns and available in dictionary, don't look further, just continue. */
        if (!strpbrk(pattern, ""[*?"") && dictFind(d, pattern)) continue;
        /* we want to print all the matched patterns and avoid printing duplicates twice */
        if (stringmatch(pattern,""resolve-hostnames"",1) && !dictFind(d, ""resolve-hostnames"")) {
            addReplyBulkCString(c,""resolve-hostnames"");
            addReplyBulkCString(c,sentinel.resolve_hostnames ? ""yes"" : ""no"");
            dictAdd(d, ""resolve-hostnames"", NULL);
            matches++;
        }
        if (stringmatch(pattern, ""announce-hostnames"", 1) &...",3328.0,3384.0,1.0,1.0,57.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6184,348665,sentinelConfigSetCommand,1,sentinelConfigSetCommand,void sentinelConfigSetCommand (client*),sentinel.c,"void sentinelConfigSetCommand(client *c) {
    long long numval;
    int drop_conns = 0;
    char *option;
    robj *val;
    char *options[] = {
        ""announce-ip"",
        ""sentinel-user"",
        ""sentinel-pass"",
        ""resolve-hostnames"",
        ""announce-port"",
        ""announce-hostnames"",
        ""loglevel"",
        NULL};
    static dict *options_dict = NULL;
    if (!options_dict) {
        options_dict = dictCreate(&stringSetDictType);
        populateDict(options_dict, options);
    }
    dict *set_configs = dictCreate(&stringSetDictType);

    /* Validate arguments are valid */
    for (int i = 3; i < c->argc; i++) {
        option = c->argv[i]->ptr;

        /* Validate option is valid */
        if (dictFind(options_dict, option) == NULL) {
            addReplyErrorFormat(c, ""Invalid argument '%s' to SENTINEL CONFIG SET"", option);
            goto exit;
        }

        /* Check duplicates */
        if (dictFind(set_configs, option) != NULL) {
            addR...",3201.0,3325.0,1.0,8.0,125.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6185,348683,initSentinelConfig,1,initSentinelConfig,void initSentinelConfig (void),sentinel.c,"void initSentinelConfig(void) {
    server.port = REDIS_SENTINEL_PORT;
    server.protected_mode = 0; /* Sentinel must be exposed. */
}",482.0,485.0,1.0,18.0,4.0,4,2,2,1,0,0,1,1,0,0,,0,0,2,1,1,void
6186,348700,freeSentinelLoadQueueEntry,1,freeSentinelLoadQueueEntry,void freeSentinelLoadQueueEntry (void*),sentinel.c,"void freeSentinelLoadQueueEntry(void *item) {
    struct sentinelLoadQueueEntry *entry = item;
    sdsfreesplitres(entry->argv,entry->argc);
    sdsfree(entry->line);
    zfree(entry);
}",1773.0,1778.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6187,348705,initSentinel,1,initSentinel,void initSentinel (void),sentinel.c,"void initSentinel(void) {
    /* Initialize various data structures. */
    sentinel.current_epoch = 0;
    sentinel.masters = dictCreate(&instancesDictType);
    sentinel.tilt = 0;
    sentinel.tilt_start_time = 0;
    sentinel.previous_time = mstime();
    sentinel.running_scripts = 0;
    sentinel.scripts_queue = listCreate();
    sentinel.announce_ip = NULL;
    sentinel.announce_port = 0;
    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
    sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
    sentinel.sentinel_auth_pass = NULL;
    sentinel.sentinel_auth_user = NULL;
    sentinel.resolve_hostnames = SENTINEL_DEFAULT_RESOLVE_HOSTNAMES;
    sentinel.announce_hostnames = SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES;
    memset(sentinel.myid,0,sizeof(sentinel.myid));
    server.sentinel_config = NULL;
}",490.0,509.0,1.0,32.0,20.0,36,4,23,4,0,38,1,1,0,3,,0,38,2,1,1,void
6188,348809,sentinelCheckConfigFile,1,sentinelCheckConfigFile,void sentinelCheckConfigFile (void),sentinel.c,"void sentinelCheckConfigFile(void) {
    if (server.configfile == NULL) {
        serverLog(LL_WARNING,
            ""Sentinel needs config file on disk to save state. Exiting..."");
        exit(1);
    } else if (access(server.configfile,W_OK) == -1) {
        serverLog(LL_WARNING,
            ""Sentinel config file %s is not writable: %s. Exiting..."",
            server.configfile,strerror(errno));
        exit(1);
    }
}",513.0,524.0,1.0,8.0,12.0,5,4,3,2,0,1,2,2,0,1,,0,0,2,1,1,void
6189,348878,sentinelIsRunning,1,sentinelIsRunning,void sentinelIsRunning (void),sentinel.c,"void sentinelIsRunning(void) {
    int j;

    /* If this Sentinel has yet no ID set in the configuration file, we
     * pick a random one and persist the config on disk. From now on this
     * will be this Sentinel ID across restarts. */
    for (j = 0; j < CONFIG_RUN_ID_SIZE; j++)
        if (sentinel.myid[j] != 0) break;

    if (j == CONFIG_RUN_ID_SIZE) {
        /* Pick ID and persist the config. */
        getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);
        sentinelFlushConfig();
    }

    /* Log its ID to make debugging of issues simpler. */
    serverLog(LL_NOTICE,""Sentinel ID is %s"", sentinel.myid);

    /* We want to generate a +monitor event for every configured master
     * at startup. */
    sentinelGenerateInitialMonitorEvents();
}",528.0,549.0,1.0,20.0,22.0,8,5,6,3,0,8,3,3,0,4,,0,4,2,1,1,void
6190,348943,createSentinelAddr,1,createSentinelAddr,"sentinelAddr createSentinelAddr (char*,int,int)",sentinel.c,"sentinelAddr *createSentinelAddr(char *hostname, int port, int is_accept_unresolved) {
    char ip[NET_IP_STR_LEN];
    sentinelAddr *sa;

    if (port < 0 || port > 65535) {
        errno = EINVAL;
        return NULL;
    }
    if (anetResolve(NULL,hostname,ip,sizeof(ip),
                    sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR) {
        serverLog(LL_WARNING, ""Failed to resolve hostname '%s'"", hostname);
        if (sentinel.resolve_hostnames && is_accept_unresolved) {
            ip[0] = '\0';
        }
        else {
            errno = ENOENT;
            return NULL;
        }
    }
    sa = zmalloc(sizeof(*sa));
    sa->hostname = sdsnew(hostname);
    sa->ip = sdsnew(ip);
    sa->port = port;
    return sa;
}",558.0,582.0,1.0,12.0,25.0,26,15,24,10,4,12,4,5,5,5,,0,11,6,3,3,sentinelAddr
6191,349054,dupSentinelAddr,1,dupSentinelAddr,sentinelAddr dupSentinelAddr (sentinelAddr*),sentinel.c,"sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
    sentinelAddr *sa;

    sa = zmalloc(sizeof(*sa));
    sa->hostname = sdsnew(src->hostname);
    sa->ip = sdsnew(src->ip);
    sa->port = src->port;
    return sa;
}",585.0,593.0,1.0,1.0,9.0,12,4,9,2,4,9,1,1,0,3,,0,9,2,1,1,sentinelAddr
6192,349091,releaseSentinelAddr,1,releaseSentinelAddr,void releaseSentinelAddr (sentinelAddr*),sentinel.c,"void releaseSentinelAddr(sentinelAddr *sa) {
    sdsfree(sa->hostname);
    sdsfree(sa->ip);
    zfree(sa);
}",596.0,600.0,1.0,1.0,5.0,2,1,3,1,7,5,1,1,0,3,,0,2,2,1,1,void
6193,349106,sentinelAddrOrHostnameEqual,1,sentinelAddrOrHostnameEqual,"int sentinelAddrOrHostnameEqual (sentinelAddr*,sentinelAddr*)",sentinel.c,"int sentinelAddrOrHostnameEqual(sentinelAddr *a, sentinelAddr *b) {
    return a->port == b->port &&
            (!strcmp(a->ip, b->ip)  ||
            !strcasecmp(a->hostname, b->hostname));
}",605.0,609.0,1.0,1.0,5.0,11,5,6,2,2,6,1,1,0,0,,0,6,4,2,2,int
6194,349138,sentinelAddrEqualsHostname,1,sentinelAddrEqualsHostname,"int sentinelAddrEqualsHostname (sentinelAddr*,char*)",sentinel.c,"int sentinelAddrEqualsHostname(sentinelAddr *a, char *hostname) {
    char ip[NET_IP_STR_LEN];

    /* Try resolve the hostname and compare it to the address */
    if (anetResolve(NULL, hostname, ip, sizeof(ip),
                    sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR) {

        /* If failed resolve then compare based on hostnames. That is our best effort as
         * long as the server is unavailable for some reason. It is fine since Redis 
         * instance cannot have multiple hostnames for a given setup */
        return !strcasecmp(sentinel.resolve_hostnames ? a->hostname : a->ip, hostname);
    }
    /* Compare based on address */
    return !strcasecmp(a->ip, ip);
}",612.0,626.0,1.0,12.0,15.0,13,8,11,5,3,8,2,2,3,1,,0,8,4,2,2,int
6195,349191,announceSentinelAddr,1,announceSentinelAddr,const char* announceSentinelAddr (sentinelAddr*),sentinel.c,"const char *announceSentinelAddr(const sentinelAddr *a) {
    return sentinel.announce_hostnames ? a->hostname : a->ip;
}",628.0,630.0,1.0,1.0,3.0,4,3,3,2,10,4,1,1,0,0,,0,4,2,1,1,const char*
6196,349207,announceSentinelAddrAndPort,1,announceSentinelAddrAndPort,sds announceSentinelAddrAndPort (sentinelAddr*),sentinel.c,"sds announceSentinelAddrAndPort(const sentinelAddr *a) {
    const char *addr = announceSentinelAddr(a);
    if (strchr(addr, ':') != NULL)
        return sdscatprintf(sdsempty(), ""[%s]:%d"", addr, a->port);
    else
        return sdscatprintf(sdsempty(), ""%s:%d"", addr, a->port);
}",635.0,641.0,1.0,1.0,7.0,3,3,6,3,2,4,2,2,0,3,,0,3,2,1,1,sds
6197,349508,sentinelReleaseScriptJob,1,sentinelReleaseScriptJob,void sentinelReleaseScriptJob (sentinelScriptJob*),sentinel.c,"void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
    int j = 0;

    while(sj->argv[j]) sdsfree(sj->argv[j++]);
    zfree(sj->argv);
    zfree(sj);
}",745.0,751.0,1.0,1.0,7.0,4,3,5,2,0,4,2,2,1,2,,0,2,2,1,1,void
6198,349715,sentinelGetScriptListNodeByPid,1,sentinelGetScriptListNodeByPid,listNode sentinelGetScriptListNodeByPid (pid_t),sentinel.c,"listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
    listNode *ln;
    listIter li;

    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;

        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid)
            return ln;
    }
    return NULL;
}",802.0,814.0,1.0,25.0,13.0,12,8,12,6,1,7,3,4,3,2,,0,6,2,1,1,listNode
6199,349762,sentinelRunPendingScripts,1,sentinelRunPendingScripts,void sentinelRunPendingScripts (void),sentinel.c,"void sentinelRunPendingScripts(void) {
    listNode *ln;
    listIter li;
    mstime_t now = mstime();

    /* Find jobs that are not running and run them, from the top to the
     * tail of the queue, so we run older jobs first. */
    listRewind(sentinel.scripts_queue,&li);
    while (sentinel.running_scripts < SENTINEL_SCRIPT_MAX_RUNNING &&
           (ln = listNext(&li)) != NULL)
    {
        sentinelScriptJob *sj = ln->value;
        pid_t pid;

        /* Skip if already running. */
        if (sj->flags & SENTINEL_SCRIPT_RUNNING) continue;

        /* Skip if it's a retry, but not enough time has elapsed. */
        if (sj->start_time && sj->start_time > now) continue;

        sj->flags |= SENTINEL_SCRIPT_RUNNING;
        sj->start_time = mstime();
        sj->retry_num++;
        pid = fork();

        if (pid == -1) {
            /* Parent (fork error).
             * We report fork errors as signal 99, in order to unify the
             * reporting with other kind of err...",818.0,863.0,1.0,38.0,46.0,31,14,22,7,1,19,7,8,6,5,,0,17,2,1,1,void
6200,349918,sentinelScriptRetryDelay,1,sentinelScriptRetryDelay,mstime_t sentinelScriptRetryDelay (int),sentinel.c,"mstime_t sentinelScriptRetryDelay(int retry_num) {
    mstime_t delay = sentinel_script_retry_delay;

    while (retry_num-- > 1) delay *= 2;
    return delay;
}",872.0,877.0,1.0,1.0,6.0,3,3,4,3,1,1,2,2,0,0,,0,1,2,1,1,mstime_t
6201,349937,sentinelCollectTerminatedScripts,1,sentinelCollectTerminatedScripts,void sentinelCollectTerminatedScripts (void),sentinel.c,"void sentinelCollectTerminatedScripts(void) {
    int statloc;
    pid_t pid;

    while ((pid = waitpid(-1, &statloc, WNOHANG)) > 0) {
        int exitcode = WEXITSTATUS(statloc);
        int bysignal = 0;
        listNode *ln;
        sentinelScriptJob *sj;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
        sentinelEvent(LL_DEBUG,""-script-child"",NULL,""%ld %d %d"",
            (long)pid, exitcode, bysignal);

        ln = sentinelGetScriptListNodeByPid(pid);
        if (ln == NULL) {
            serverLog(LL_WARNING,""waitpid() returned a pid (%ld) we can't find in our scripts execution queue!"", (long)pid);
            continue;
        }
        sj = ln->value;

        /* If the script was terminated by a signal or returns an
         * exit code of ""1"" (that means: please retry), we reschedule it
         * if the max number of retries is not already reached. */
        if ((bysignal || exitcode == 1) &&
            sj->retry_num != SENTINEL_SCRIPT_MAX_RETRY)...",883.0,926.0,1.0,22.0,44.0,31,16,29,10,1,13,6,8,1,5,,0,11,2,1,1,void
6202,350095,sentinelKillTimedoutScripts,1,sentinelKillTimedoutScripts,void sentinelKillTimedoutScripts (void),sentinel.c,"void sentinelKillTimedoutScripts(void) {
    listNode *ln;
    listIter li;
    mstime_t now = mstime();

    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;

        if (sj->flags & SENTINEL_SCRIPT_RUNNING &&
            (now - sj->start_time) > sentinel_script_max_runtime)
        {
            sentinelEvent(LL_WARNING,""-script-timeout"",NULL,""%s %ld"",
                sj->argv[0], (long)sj->pid);
            kill(sj->pid,SIGKILL);
        }
    }
}",930.0,947.0,1.0,24.0,18.0,19,11,17,8,1,13,3,4,4,4,,0,11,2,1,1,void
6203,350166,sentinelPendingScriptsCommand,1,sentinelPendingScriptsCommand,void sentinelPendingScriptsCommand (client*),sentinel.c,"void sentinelPendingScriptsCommand(client *c) {
    listNode *ln;
    listIter li;

    addReplyArrayLen(c,listLength(sentinel.scripts_queue));
    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;
        int j = 0;

        addReplyMapLen(c,5);

        addReplyBulkCString(c,""argv"");
        while (sj->argv[j]) j++;
        addReplyArrayLen(c,j);
        j = 0;
        while (sj->argv[j]) addReplyBulkCString(c,sj->argv[j++]);

        addReplyBulkCString(c,""flags"");
        addReplyBulkCString(c,
            (sj->flags & SENTINEL_SCRIPT_RUNNING) ? ""running"" : ""scheduled"");

        addReplyBulkCString(c,""pid"");
        addReplyBulkLongLong(c,sj->pid);

        if (sj->flags & SENTINEL_SCRIPT_RUNNING) {
            addReplyBulkCString(c,""run-time"");
            addReplyBulkLongLong(c,mstime() - sj->start_time);
        } else {
            mstime_t delay = sj->start_time ? (sj->start_time-mstime()) : 0;
   ...",950.0,988.0,1.0,23.0,39.0,25,9,33,7,0,29,5,8,4,15,,0,16,2,1,1,void
6204,350323,sentinelCallClientReconfScript,1,sentinelCallClientReconfScript,"void sentinelCallClientReconfScript (sentinelRedisInstance*,int,char*,sentinelAddr*,sentinelAddr*)",sentinel.c,"void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
    char fromport[32], toport[32];

    if (master->client_reconfig_script == NULL) return;
    ll2string(fromport,sizeof(fromport),from->port);
    ll2string(toport,sizeof(toport),to->port);
    sentinelScheduleScriptExecution(master->client_reconfig_script,
        master->name,
        (role == SENTINEL_LEADER) ? ""leader"" : ""observer"",
        state, announceSentinelAddr(from), fromport,
        announceSentinelAddr(to), toport, NULL);
}",1002.0,1013.0,1.0,17.0,12.0,11,5,17,8,2,10,2,2,1,5,,0,7,10,5,5,void
6205,350381,createInstanceLink,1,createInstanceLink,instanceLink createInstanceLink (void),sentinel.c,"instanceLink *createInstanceLink(void) {
    instanceLink *link = zmalloc(sizeof(*link));

    link->refcount = 1;
    link->disconnected = 1;
    link->pending_commands = 0;
    link->cc = NULL;
    link->pc = NULL;
    link->cc_conn_time = 0;
    link->pc_conn_time = 0;
    link->last_reconn_time = 0;
    link->pc_last_activity = 0;
    /* We set the act_ping_time to ""now"" even if we actually don't have yet
     * a connection with the node, nor we sent a ping.
     * This is useful to detect a timeout in case we'll not be able to connect
     * with the node at all. */
    link->act_ping_time = mstime();
    link->last_ping_time = 0;
    link->last_avail_time = mstime();
    link->last_pong_time = mstime();
    return link;
}",1018.0,1039.0,1.0,1.0,22.0,29,4,18,2,1,17,1,1,0,4,,0,17,2,1,1,instanceLink
6206,350460,instanceLinkCloseConnection,1,instanceLinkCloseConnection,"void instanceLinkCloseConnection (instanceLink*,redisAsyncContext*)",sentinel.c,"void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
    if (c == NULL) return;

    if (link->cc == c) {
        link->cc = NULL;
        link->pending_commands = 0;
    }
    if (link->pc == c) link->pc = NULL;
    c->data = NULL;
    link->disconnected = 1;
    redisAsyncFree(c);
}",1042.0,1053.0,1.0,1.0,12.0,15,3,15,3,14,6,4,4,2,0,,0,6,4,2,2,void
6207,350513,releaseInstanceLink,1,releaseInstanceLink,"instanceLink releaseInstanceLink (instanceLink*,sentinelRedisInstance*)",sentinel.c,"instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
{
    serverAssert(link->refcount > 0);
    link->refcount--;
    if (link->refcount != 0) {
        if (ri && ri->link->cc) {
            /* This instance may have pending callbacks in the hiredis async
             * context, having as 'privdata' the instance that we are going to
             * free. Let's rewrite the callback list, directly exploiting
             * hiredis internal data structures, in order to bind them with
             * a callback that will ignore the reply at all. */
            redisCallback *cb;
            redisCallbackList *callbacks = &link->cc->replies;

            cb = callbacks->head;
            while(cb) {
                if (cb->privdata == ri) {
                    cb->fn = sentinelDiscardReplyCallback;
                    cb->privdata = NULL; /* Not strictly needed. */
                }
                cb = cb->next;
            }
        }
        return link; /* ...",1063.0,1093.0,1.0,4.0,31.0,29,12,25,6,1,11,5,11,2,4,,0,7,4,2,2,instanceLink
6208,350613,sentinelTryConnectionSharing,1,sentinelTryConnectionSharing,int sentinelTryConnectionSharing (sentinelRedisInstance*),sentinel.c,"int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_SENTINEL);
    dictIterator *di;
    dictEntry *de;

    if (ri->runid == NULL) return C_ERR; /* No way to identify it. */
    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *master = dictGetVal(de), *match;
        /* We want to share with the same physical Sentinel referenced
         * in other masters, so skip our master. */
        if (master == ri->master) continue;
        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
                                                       NULL,0,ri->runid);
        if (match == NULL) continue; /* No match. */
        if (match == ri) continue; /* Should never happen but... safer. */

        /* We identified a matching Sentinel, great! Let's free our link
         * and use the one of the matching S...",1107.0,1136.0,1.0,4.0,30.0,34,14,28,7,1,20,10,10,4,8,,0,16,2,1,1,int
6209,350748,dropInstanceConnections,1,dropInstanceConnections,void dropInstanceConnections (sentinelRedisInstance*),sentinel.c,"void dropInstanceConnections(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    /* Disconnect with the master. */
    instanceLinkCloseConnection(ri->link, ri->link->cc);
    instanceLinkCloseConnection(ri->link, ri->link->pc);
    
    /* Disconnect with all replicas. */
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *repl_ri;
    di = dictGetIterator(ri->slaves);
    while ((de = dictNext(di)) != NULL) {
        repl_ri = dictGetVal(de);
        instanceLinkCloseConnection(repl_ri->link, repl_ri->link->cc);
        instanceLinkCloseConnection(repl_ri->link, repl_ri->link->pc);
    }
    dictReleaseIterator(di);
}",1139.0,1157.0,1.0,4.0,19.0,24,9,17,5,0,19,2,2,1,9,,0,13,2,1,1,void
6210,350832,sentinelDropConnections,1,sentinelDropConnections,int sentinelDropConnections (void),sentinel.c,"int sentinelDropConnections(void) {
    dictIterator *di;
    dictEntry *de;
    int dropped = 0;

    di = dictGetIterator(sentinel.masters);
    while ((de = dictNext(di)) != NULL) {
        dictIterator *sdi;
        dictEntry *sde;

        sentinelRedisInstance *ri = dictGetVal(de);
        sdi = dictGetIterator(ri->sentinels);
        while ((sde = dictNext(sdi)) != NULL) {
            sentinelRedisInstance *si = dictGetVal(sde);
            if (!si->link->disconnected) {
                instanceLinkCloseConnection(si->link, si->link->pc);
                instanceLinkCloseConnection(si->link, si->link->cc);
                dropped++;
            }
        }
        dictReleaseIterator(sdi);
    }
    dictReleaseIterator(di);

    return dropped;
}",1161.0,1186.0,1.0,1.0,26.0,21,6,24,9,0,18,4,7,3,10,,0,14,2,1,1,int
6211,350917,sentinelUpdateSentinelAddressInAllMasters,1,sentinelUpdateSentinelAddressInAllMasters,int sentinelUpdateSentinelAddressInAllMasters (sentinelRedisInstance*),sentinel.c,"int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_SENTINEL);
    dictIterator *di;
    dictEntry *de;
    int reconfigured = 0;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *master = dictGetVal(de), *match;
        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
                                                       NULL,0,ri->runid);
        /* If there is no match, this master does not know about this
         * Sentinel, try with the next one. */
        if (match == NULL) continue;

        /* Disconnect the old links if connected. */
        if (match->link->cc != NULL)
            instanceLinkCloseConnection(match->link,match->link->cc);
        if (match->link->pc != NULL)
            instanceLinkCloseConnection(match->link,match->link->pc);

        if (match == ri) continue; /* Address already updated for it. */

        /* Updat...",1194.0,1228.0,1.0,4.0,35.0,35,12,34,8,1,25,9,11,3,11,,0,19,2,1,1,int
6212,351129,createSentinelRedisInstance,1,createSentinelRedisInstance,"sentinelRedisInstance createSentinelRedisInstance (char*,int,char*,int,int,sentinelRedisInstance*)",sentinel.c,"sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
    sentinelRedisInstance *ri;
    sentinelAddr *addr;
    dict *table = NULL;
    sds sdsname;

    serverAssert(flags & (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
    serverAssert((flags & SRI_MASTER) || master != NULL);

    /* Check address validity. */
    addr = createSentinelAddr(hostname,port,1);
    if (addr == NULL) return NULL;

    /* For slaves use ip/host:port as name. */
    if (flags & SRI_SLAVE)
        sdsname = announceSentinelAddrAndPort(addr);
    else
        sdsname = sdsnew(name);

    /* Make sure the entry is not duplicated. This may happen when the same
     * name for a master is used multiple times inside the configuration or
     * if we try to add multiple times a slave or sentinel with same ip/port
     * to a master. */
    if (flags & SRI_MASTER) table = sentinel.masters;
    else if (flags & SRI_SLAVE) table = ...",1285.0,1375.0,1.0,4.0,91.0,133,16,98,17,4,73,5,5,1,18,,0,68,12,6,6,sentinelRedisInstance
6213,351654,sentinelRedisInstanceLookupSlave,1,sentinelRedisInstanceLookupSlave,"sentinelRedisInstance sentinelRedisInstanceLookupSlave (sentinelRedisInstance*,char*,int)",sentinel.c,"sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
                sentinelRedisInstance *ri, char *slave_addr, int port)
{
    sds key;
    sentinelRedisInstance *slave;
    sentinelAddr *addr;

    serverAssert(ri->flags & SRI_MASTER);

    /* We need to handle a slave_addr that is potentially a hostname.
     * If that is the case, depending on configuration we either resolve
     * it and use the IP address or fail.
     */
    addr = createSentinelAddr(slave_addr, port, 0);
    if (!addr) return NULL;
    key = announceSentinelAddrAndPort(addr);
    releaseSentinelAddr(addr);

    slave = dictFetchValue(ri->slaves,key);
    sdsfree(key);
    return slave;
}",1410.0,1431.0,1.0,4.0,22.0,12,9,14,7,1,8,2,2,0,6,,0,5,6,3,3,sentinelRedisInstance
6214,351765,removeMatchingSentinelFromMaster,1,removeMatchingSentinelFromMaster,"int removeMatchingSentinelFromMaster (sentinelRedisInstance*,char*)",sentinel.c,"int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
    dictIterator *di;
    dictEntry *de;
    int removed = 0;

    if (runid == NULL) return 0;

    di = dictGetSafeIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->runid && strcmp(ri->runid,runid) == 0) {
            dictDelete(master->sentinels,ri->name);
            removed++;
        }
    }
    dictReleaseIterator(di);
    return removed;
}",1452.0,1470.0,1.0,1.0,19.0,14,6,18,7,1,10,4,5,3,5,,0,8,4,2,2,int
6215,351966,sentinelResetMaster,1,sentinelResetMaster,"void sentinelResetMaster (sentinelRedisInstance*,int)",sentinel.c,"void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
    serverAssert(ri->flags & SRI_MASTER);
    dictRelease(ri->slaves);
    ri->slaves = dictCreate(&instancesDictType);
    if (!(flags & SENTINEL_RESET_NO_SENTINELS)) {
        dictRelease(ri->sentinels);
        ri->sentinels = dictCreate(&instancesDictType);
    }
    instanceLinkCloseConnection(ri->link,ri->link->cc);
    instanceLinkCloseConnection(ri->link,ri->link->pc);
    ri->flags &= SRI_MASTER;
    if (ri->leader) {
        sdsfree(ri->leader);
        ri->leader = NULL;
    }
    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
    ri->failover_state_change_time = 0;
    ri->failover_start_time = 0; /* We can failover again ASAP. */
    ri->promoted_slave = NULL;
    sdsfree(ri->runid);
    sdsfree(ri->slave_master_host);
    ri->runid = NULL;
    ri->slave_master_host = NULL;
    ri->link->act_ping_time = mstime();
    ri->link->last_ping_time = 0;
    ri->link->last_avail_time = mstime();
    ri->link->...",1533.0,1564.0,1.0,4.0,32.0,63,10,36,4,2,44,4,4,1,15,,0,35,4,2,2,void
6216,352163,sentinelResetMastersByPattern,1,sentinelResetMastersByPattern,"int sentinelResetMastersByPattern (char*,int)",sentinel.c,"int sentinelResetMastersByPattern(char *pattern, int flags) {
    dictIterator *di;
    dictEntry *de;
    int reset = 0;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->name) {
            if (stringmatch(pattern,ri->name,0)) {
                sentinelResetMaster(ri,flags);
                reset++;
            }
        }
    }
    dictReleaseIterator(di);
    return reset;
}",1568.0,1586.0,1.0,1.0,19.0,9,5,16,8,0,10,4,7,4,6,,0,8,4,2,2,int
6217,352216,sentinelResetMasterAndChangeAddress,1,sentinelResetMasterAndChangeAddress,"int sentinelResetMasterAndChangeAddress (sentinelRedisInstance*,char*,int)",sentinel.c,"int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *hostname, int port) {
    sentinelAddr *oldaddr, *newaddr;
    sentinelAddr **slaves = NULL;
    int numslaves = 0, j;
    dictIterator *di;
    dictEntry *de;

    newaddr = createSentinelAddr(hostname,port,0);
    if (newaddr == NULL) return C_ERR;

    /* There can be only 0 or 1 slave that has the newaddr.
     * and It can add old master 1 more slave. 
     * so It allocates dictSize(master->slaves) + 1          */
    slaves = zmalloc(sizeof(sentinelAddr*)*(dictSize(master->slaves) + 1));
    
    /* Don't include the one having the address we are switching to. */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (sentinelAddrOrHostnameEqual(slave->addr,newaddr)) continue;
        slaves[numslaves++] = dupSentinelAddr(slave->addr);
    }
    dictReleaseIterator(di);

    /* If we are switching to a diff...",1595.0,1650.0,1.0,32.0,56.0,52,13,55,13,2,30,8,9,5,17,,0,23,6,3,3,int
6218,352420,sentinelRedisInstanceNoDownFor,1,sentinelRedisInstanceNoDownFor,"int sentinelRedisInstanceNoDownFor (sentinelRedisInstance*,mstime_t)",sentinel.c,"int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
    mstime_t most_recent;

    most_recent = ri->s_down_since_time;
    if (ri->o_down_since_time > most_recent)
        most_recent = ri->o_down_since_time;
    return most_recent == 0 || (mstime() - most_recent) > ms;
}",1654.0,1661.0,1.0,1.0,8.0,10,6,9,3,1,4,2,2,1,1,,0,3,4,2,2,int
6219,352454,sentinelGetCurrentMasterAddress,1,sentinelGetCurrentMasterAddress,sentinelAddr sentinelGetCurrentMasterAddress (sentinelRedisInstance*),sentinel.c,"sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
    /* If we are failing over the master, and the state is already
     * SENTINEL_FAILOVER_STATE_RECONF_SLAVES or greater, it means that we
     * already have the new configuration epoch in the master, and the
     * slave acknowledged the configuration switch. Advertise the new
     * address. */
    if ((master->flags & SRI_FAILOVER_IN_PROGRESS) &&
        master->promoted_slave &&
        master->failover_state >= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
    {
        return master->promoted_slave->addr;
    } else {
        return master->addr;
    }
}",1665.0,1679.0,1.0,25.0,15.0,10,5,4,1,1,4,2,2,3,0,,0,4,2,1,1,sentinelAddr
6220,352494,sentinelPropagateDownAfterPeriod,1,sentinelPropagateDownAfterPeriod,void sentinelPropagateDownAfterPeriod (sentinelRedisInstance*),sentinel.c,"void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int j;
    dict *d[] = {master->slaves, master->sentinels, NULL};

    for (j = 0; d[j]; j++) {
        di = dictGetIterator(d[j]);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);
            ri->down_after_period = master->down_after_period;
        }
        dictReleaseIterator(di);
    }
}",1683.0,1697.0,1.0,1.0,15.0,14,5,18,7,0,8,3,4,1,4,,0,7,2,1,1,void
6221,352552,sentinelInstanceMapCommand,1,sentinelInstanceMapCommand,"char* sentinelInstanceMapCommand (sentinelRedisInstance*,char*)",sentinel.c,"char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
    sds sc = sdsnew(command);
    if (ri->master) ri = ri->master;
    char *retval = dictFetchValue(ri->renamed_commands, sc);
    sdsfree(sc);
    return retval ? retval : command;
}",1706.0,1712.0,1.0,1.0,7.0,7,3,12,4,5,6,2,2,1,3,,0,5,4,2,2,char*
6222,352588,sentinelCheckCreateInstanceErrors,1,sentinelCheckCreateInstanceErrors,const char* sentinelCheckCreateInstanceErrors (int),sentinel.c,"const char *sentinelCheckCreateInstanceErrors(int role) {
    switch(errno) {
    case EBUSY:
        switch (role) {
        case SRI_MASTER:
            return ""Duplicate master name."";
        case SRI_SLAVE:
            return ""Duplicate hostname and port for replica."";
        case SRI_SENTINEL:
            return ""Duplicate runid for sentinel."";
        default:
            serverAssert(0);
            break;
        }
        break;
    case ENOENT:
        return ""Can't resolve instance hostname."";
    case EINVAL:
        return ""Invalid port number."";
    default:
        return ""Unknown Error for creating instances."";
    }
}",1718.0,1740.0,1.0,13.0,23.0,7,5,5,5,1,1,5,4,0,1,,0,0,2,1,1,const char*
6223,352654,initializeSentinelConfig,1,initializeSentinelConfig,void initializeSentinelConfig (void),sentinel.c,"void initializeSentinelConfig(void) {
    server.sentinel_config = zmalloc(sizeof(struct sentinelConfig));
    server.sentinel_config->monitor_cfg = listCreate();
    server.sentinel_config->pre_monitor_cfg = listCreate();
    server.sentinel_config->post_monitor_cfg = listCreate();
    listSetFreeMethod(server.sentinel_config->monitor_cfg,freeSentinelLoadQueueEntry);
    listSetFreeMethod(server.sentinel_config->pre_monitor_cfg,freeSentinelLoadQueueEntry);
    listSetFreeMethod(server.sentinel_config->post_monitor_cfg,freeSentinelLoadQueueEntry);
}",1743.0,1751.0,1.0,4.0,9.0,30,4,17,3,1,4,1,1,0,4,,0,4,2,1,1,void
6224,352738,freeSentinelConfig,1,freeSentinelConfig,void freeSentinelConfig (void),sentinel.c,"void freeSentinelConfig(void) {
    /* release these three config queues since we will not use it anymore */
    listRelease(server.sentinel_config->pre_monitor_cfg);
    listRelease(server.sentinel_config->monitor_cfg);
    listRelease(server.sentinel_config->post_monitor_cfg);
    zfree(server.sentinel_config);
    server.sentinel_config = NULL;
}",1754.0,1761.0,1.0,1.0,8.0,9,3,6,2,1,4,1,1,0,4,,0,0,2,1,1,void
6225,352770,searchPreMonitorCfgName,1,searchPreMonitorCfgName,int searchPreMonitorCfgName (char*),sentinel.c,"int searchPreMonitorCfgName(const char *name) {
    for (unsigned int i = 0; i < sizeof(preMonitorCfgName)/sizeof(preMonitorCfgName[0]); i++) {
        if (!strcasecmp(preMonitorCfgName[i],name)) return 1;
    }
    return 0;
}",1765.0,1770.0,1.0,1.0,6.0,8,6,7,3,0,3,3,4,3,0,,0,3,2,1,1,int
6226,352827,queueSentinelConfig,1,queueSentinelConfig,"void queueSentinelConfig (sds*,int,int,sds)",sentinel.c,"void queueSentinelConfig(sds *argv, int argc, int linenum, sds line) {
    int i;
    struct sentinelLoadQueueEntry *entry;

    /* initialize sentinel_config for the first call */
    if (server.sentinel_config == NULL) initializeSentinelConfig();

    entry = zmalloc(sizeof(struct sentinelLoadQueueEntry));
    entry->argv = zmalloc(sizeof(char*)*argc);
    entry->argc = argc;
    entry->linenum = linenum;
    entry->line = sdsdup(line);
    for (i = 0; i < argc; i++) {
        entry->argv[i] = sdsdup(argv[i]);
    }
    /*  Separate config lines with pre monitor config, monitor config and
     *  post monitor config, in order to parsing config dependencies
     *  correctly. */
    if (!strcasecmp(argv[0],""monitor"")) {
        listAddNodeTail(server.sentinel_config->monitor_cfg,entry);
    } else if (searchPreMonitorCfgName(argv[0])) {
        listAddNodeTail(server.sentinel_config->pre_monitor_cfg,entry);
    } else{
        listAddNodeTail(server.sentinel_config->post_monitor_cf...",1783.0,1808.0,1.0,1.0,26.0,24,9,23,10,0,11,4,4,0,6,,0,9,8,4,4,void
6227,352935,loadSentinelConfigFromQueue,1,loadSentinelConfigFromQueue,void loadSentinelConfigFromQueue (void),sentinel.c,"void loadSentinelConfigFromQueue(void) {
    const char *err = NULL;
    listIter li;
    listNode *ln;
    int linenum = 0;
    sds line = NULL;
    unsigned int j;

    /* if there is no sentinel_config entry, we can return immediately */
    if (server.sentinel_config == NULL) return;

    list *sentinel_configs[3] = {
        server.sentinel_config->pre_monitor_cfg,
        server.sentinel_config->monitor_cfg,
        server.sentinel_config->post_monitor_cfg
    };
    /* loading from pre monitor config queue first to avoid dependency issues
     * loading from monitor config queue
     * loading from the post monitor config queue */
    for (j = 0; j < sizeof(sentinel_configs) / sizeof(sentinel_configs[0]); j++) {
        listRewind(sentinel_configs[j],&li);
        while((ln = listNext(&li))) {
            struct sentinelLoadQueueEntry *entry = ln->value;
            err = sentinelHandleConfiguration(entry->argv,entry->argc);
            if (err) {
                linenum = en...",1812.0,1855.0,1.0,8.0,44.0,32,10,37,11,0,9,6,8,1,4,,0,7,2,1,1,void
6228,353064,sentinelHandleConfiguration,1,sentinelHandleConfiguration,"const char* sentinelHandleConfiguration (char**,int)",sentinel.c,"const char *sentinelHandleConfiguration(char **argv, int argc) {

    sentinelRedisInstance *ri;

    if (!strcasecmp(argv[0],""monitor"") && argc == 5) {
        /* monitor <name> <host> <port> <quorum> */
        int quorum = atoi(argv[4]);

        if (quorum <= 0) return ""Quorum must be 1 or greater."";
        if (createSentinelRedisInstance(argv[1],SRI_MASTER,argv[2],
                                        atoi(argv[3]),quorum,NULL) == NULL)
        {
            return sentinelCheckCreateInstanceErrors(SRI_MASTER);
        }
    } else if (!strcasecmp(argv[0],""down-after-milliseconds"") && argc == 3) {
        /* down-after-milliseconds <name> <milliseconds> */
        ri = sentinelGetMasterByName(argv[1]);
        if (!ri) return ""No such master with specified name."";
        ri->down_after_period = atoi(argv[2]);
        if (ri->down_after_period <= 0)
            return ""negative or zero time parameter."";
        sentinelPropagateDownAfterPeriod(ri);
    } else if (!strcasecm...",1857.0,2022.0,1.0,48.0,166.0,13,7,12,4,1,2,4,6,1,2,,0,1,4,2,2,const char*
6229,354771,sentinelFlushConfigAndReply,1,sentinelFlushConfigAndReply,void sentinelFlushConfigAndReply (client*),sentinel.c,"static void sentinelFlushConfigAndReply(client *c) {
    if (sentinelFlushConfig() == C_ERR)
        addReplyError(c, ""Failed to save config file. Check server logs."");
    else
        addReply(c, shared.ok);
}",2302.0,2307.0,1.0,33.0,6.0,2,2,1,1,0,2,2,2,1,2,,0,1,2,1,1,void
6230,354794,sentinelSendAuthIfNeeded,1,sentinelSendAuthIfNeeded,"void sentinelSendAuthIfNeeded (sentinelRedisInstance*,redisAsyncContext*)",sentinel.c,"void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
    char *auth_pass = NULL;
    char *auth_user = NULL;

    if (ri->flags & SRI_MASTER) {
        auth_pass = ri->auth_pass;
        auth_user = ri->auth_user;
    } else if (ri->flags & SRI_SLAVE) {
        auth_pass = ri->master->auth_pass;
        auth_user = ri->master->auth_user;
    } else if (ri->flags & SRI_SENTINEL) {
        /* If sentinel_auth_user is NULL, AUTH will use default user
           with sentinel_auth_pass to authenticate */
        if (sentinel.sentinel_auth_pass) {
            auth_pass = sentinel.sentinel_auth_pass;
            auth_user = sentinel.sentinel_auth_user;
        } else {
            /* Compatibility with old configs. requirepass is used
             * for both incoming and outgoing authentication. */
            auth_pass = server.requirepass;
            auth_user = NULL;
        }
    }

    if (auth_pass && auth_user == NULL) {
        if (redisAsyncCommand(c,...",2323.0,2358.0,1.0,20.0,36.0,15,7,18,6,0,5,4,5,2,1,,0,5,4,2,2,void
6231,354951,sentinelSetClientName,1,sentinelSetClientName,"void sentinelSetClientName (sentinelRedisInstance*,redisAsyncContext*,char*)",sentinel.c,"void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
    char name[64];

    snprintf(name,sizeof(name),""sentinel-%.8s-%s"",sentinel.myid,type);
    if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri,
        ""%s SETNAME %s"",
        sentinelInstanceMapCommand(ri,""CLIENT""),
        name) == C_OK)
    {
        ri->link->pending_commands++;
    }
}",2366.0,2377.0,1.0,17.0,12.0,6,5,10,6,0,4,2,2,1,1,,0,4,6,3,3,void
6232,354989,instanceLinkNegotiateTLS,1,instanceLinkNegotiateTLS,int instanceLinkNegotiateTLS (redisAsyncContext*),sentinel.c,"static int instanceLinkNegotiateTLS(redisAsyncContext *context) {
#if USE_OPENSSL == 1 /* BUILD_YES */
    if (!redis_tls_ctx) return C_ERR;
    SSL *ssl = SSL_new(redis_tls_client_ctx ? redis_tls_client_ctx : redis_tls_ctx);
    if (!ssl) return C_ERR;

    if (redisInitiateSSL(&context->c, ssl) == REDIS_ERR) {
        SSL_free(ssl);
        return C_ERR;
    }
#else
    UNUSED(context);
#endif
    return C_OK;
}",2379.0,2393.0,1.0,4.0,15.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,int
6233,355004,sentinelReconnectInstance,1,sentinelReconnectInstance,void sentinelReconnectInstance (sentinelRedisInstance*),sentinel.c,"void sentinelReconnectInstance(sentinelRedisInstance *ri) {

    if (ri->link->disconnected == 0) return;
    if (ri->addr->port == 0) return; /* port == 0 means invalid address. */
    instanceLink *link = ri->link;
    mstime_t now = mstime();

    if (now - ri->link->last_reconn_time < sentinel_ping_period) return;
    ri->link->last_reconn_time = now;

    /* Commands connection. */
    if (link->cc == NULL) {

        /* It might be that the instance is disconnected because it wasn't available earlier when the instance
         * allocated, say during failover, and therefore we failed to resolve its ip.
         * Another scenario is that the instance restarted with new ip, and we should resolve its new ip based on
         * its hostname */
        if (sentinel.resolve_hostnames) {
            sentinelAddr *tryResolveAddr = createSentinelAddr(ri->addr->hostname, ri->addr->port, 0);
            if (tryResolveAddr != NULL) {
                releaseSentinelAddr(ri->addr);
       ...",2398.0,2493.0,1.0,26.0,96.0,79,13,46,8,1,40,13,20,18,7,,0,35,2,1,1,void
6234,355487,sentinelMasterLooksSane,1,sentinelMasterLooksSane,int sentinelMasterLooksSane (sentinelRedisInstance*),sentinel.c,"int sentinelMasterLooksSane(sentinelRedisInstance *master) {
    return
        master->flags & SRI_MASTER &&
        master->role_reported == SRI_MASTER &&
        (master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
        (mstime() - master->info_refresh) < sentinel_info_period*2;
}",2502.0,2508.0,1.0,24.0,7.0,19,9,5,2,1,6,1,1,0,1,,0,5,2,1,1,int
6235,355540,sentinelRefreshInstanceInfo,1,sentinelRefreshInstanceInfo,"void sentinelRefreshInstanceInfo (sentinelRedisInstance*,char*)",sentinel.c,"void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
    sds *lines;
    int numlines, j;
    int role = 0;

    /* cache full INFO output for instance */
    sdsfree(ri->info);
    ri->info = sdsnew(info);

    /* The following fields must be reset to a given value in the case they
     * are not found at all in the INFO output. */
    ri->master_link_down_time = 0;

    /* Process line by line. */
    lines = sdssplitlen(info,strlen(info),""\r\n"",2,&numlines);
    for (j = 0; j < numlines; j++) {
        sentinelRedisInstance *slave;
        sds l = lines[j];

        /* run_id:<40 hex chars>*/
        if (sdslen(l) >= 47 && !memcmp(l,""run_id:"",7)) {
            if (ri->runid == NULL) {
                ri->runid = sdsnewlen(l+7,40);
            } else {
                if (strncmp(ri->runid,l+7,40) != 0) {
                    sentinelEvent(LL_NOTICE,""+reboot"",ri,""%@"");

                    if (ri->flags & SRI_MASTER && ri->master_reboot_down_after_period ...",2511.0,2766.0,1.0,34.0,256.0,255,23,165,16,1,110,38,85,50,43,,0,95,4,2,2,void
6236,356632,sentinelInfoReplyCallback,1,sentinelInfoReplyCallback,"void sentinelInfoReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* INFO reply type is verbatim in resp3. Normally, sentinel will not use
     * resp3 but this is required for testing (see logreqres.c). */
    if (r->type == REDIS_REPLY_STRING || r->type == REDIS_REPLY_VERB)
        sentinelRefreshInstanceInfo(ri,r->str);
}",2768.0,2781.0,1.0,1.0,14.0,15,6,15,8,0,2,3,3,0,1,,0,1,6,3,3,void
6237,356715,sentinelPingReplyCallback,1,sentinelPingReplyCallback,"void sentinelPingReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    if (r->type == REDIS_REPLY_STATUS ||
        r->type == REDIS_REPLY_ERROR) {
        /* Update the ""instance available"" field only if this is an
         * acceptable reply. */
        if (strncmp(r->str,""PONG"",4) == 0 ||
            strncmp(r->str,""LOADING"",7) == 0 ||
            strncmp(r->str,""MASTERDOWN"",10) == 0)
        {
            link->last_avail_time = mstime();
            link->act_ping_time = 0; /* Flag the pong as received. */

            if (ri->flags & SRI_MASTER_REBOOT && strncmp(r->str,""PONG"",4) == 0)
                ri->flags &= ~SRI_MASTER_REBOOT;

        } else {
            /* Send a SCRIPT KILL command if the instance appears to be
             * down because of a busy script. */
            if (str...",2793.0,2835.0,1.0,28.0,43.0,37,10,22,8,0,8,5,8,1,2,,0,8,6,3,3,void
6238,356900,sentinelPublishReplyCallback,1,sentinelPublishReplyCallback,"void sentinelPublishReplyCallback (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* Only update pub_time if we actually published our message. Otherwise
     * we'll retry again in 100 milliseconds. */
    if (r->type != REDIS_REPLY_ERROR)
        ri->last_pub_time = mstime();
}",2839.0,2852.0,1.0,1.0,14.0,13,6,12,7,0,3,3,3,0,1,,0,3,6,3,3,void
6239,356945,sentinelProcessHelloMessage,1,sentinelProcessHelloMessage,"void sentinelProcessHelloMessage (char*,int)",sentinel.c,"void sentinelProcessHelloMessage(char *hello, int hello_len) {
    /* Format is composed of 8 tokens:
     * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,
     * 5=master_ip,6=master_port,7=master_config_epoch. */
    int numtokens, port, removed, master_port;
    uint64_t current_epoch, master_config_epoch;
    char **token = sdssplitlen(hello, hello_len, "","", 1, &numtokens);
    sentinelRedisInstance *si, *master;

    if (numtokens == 8) {
        /* Obtain a reference to the master this hello message is about */
        master = sentinelGetMasterByName(token[4]);
        if (!master) goto cleanup; /* Unknown master, skip the message. */

        /* First, try to see if we already have this sentinel. */
        port = atoi(token[1]);
        master_port = atoi(token[6]);
        si = getSentinelRedisInstanceByAddrAndRunID(
                        master->sentinels,token[0],port,token[2]);
        current_epoch = strtoull(token[3],NULL,10);
        master_config_epoch = strto...",2859.0,2971.0,1.0,30.0,113.0,62,14,81,14,1,42,13,29,6,23,,0,29,4,2,2,void
6240,357417,sentinelSendHello,1,sentinelSendHello,int sentinelSendHello (sentinelRedisInstance*),sentinel.c,"int sentinelSendHello(sentinelRedisInstance *ri) {
    char ip[NET_IP_STR_LEN];
    char payload[NET_IP_STR_LEN+1024];
    int retval;
    char *announce_ip;
    int announce_port;
    sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ? ri : ri->master;
    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);

    if (ri->link->disconnected) return C_ERR;

    /* Use the specified announce address if specified, otherwise try to
     * obtain our own IP address. */
    if (sentinel.announce_ip) {
        announce_ip = sentinel.announce_ip;
    } else {
        if (anetFdToString(ri->link->cc->c.fd,ip,sizeof(ip),NULL,0) == -1)
            return C_ERR;
        announce_ip = ip;
    }
    if (sentinel.announce_port) announce_port = sentinel.announce_port;
    else if (server.tls_replication && server.tls_port) announce_port = server.tls_port;
    else announce_port = server.port;

    /* Format and send the Hello message. */
    snprintf(payload,sizeof(payload),
...",3017.0,3057.0,1.0,12.0,41.0,32,11,30,8,1,23,5,5,5,3,,0,22,2,1,1,int
6241,357602,sentinelForceHelloUpdateDictOfRedisInstances,1,sentinelForceHelloUpdateDictOfRedisInstances,void sentinelForceHelloUpdateDictOfRedisInstances (dict*),sentinel.c,"void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->last_pub_time >= (sentinel_publish_period+1))
            ri->last_pub_time -= (sentinel_publish_period+1);
    }
    dictReleaseIterator(di);
}",3061.0,3072.0,1.0,1.0,12.0,10,6,12,6,0,8,3,4,3,4,,0,7,2,1,1,void
6242,357760,sentinelSendPeriodicCommands,1,sentinelSendPeriodicCommands,void sentinelSendPeriodicCommands (sentinelRedisInstance*),sentinel.c,"void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
    mstime_t now = mstime();
    mstime_t info_period, ping_period;
    int retval;

    /* Return ASAP if we have already a PING or INFO already pending, or
     * in the case the instance is not properly connected. */
    if (ri->link->disconnected) return;

    /* For INFO, PING, PUBLISH that are not critical commands to send we
     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't
     * want to use a lot of memory just because a link is not working
     * properly (note that anyway there is a redundant protection about this,
     * that is, the link will be disconnected and reconnected if a long
     * timeout condition is detected. */
    if (ri->link->pending_commands >=
        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) return;

    /* If this is a slave of a master in O_DOWN condition we start sending
     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD
     * period. In ...",3116.0,3178.0,1.0,8.0,63.0,58,15,36,7,1,22,9,10,14,4,,0,20,2,1,1,void
6243,357944,populateDict,1,populateDict,"void populateDict (dict*,char**)",sentinel.c,"static void populateDict(dict *options_dict, char **options) {
    for (int i=0; options[i]; i++) {
        sds option = sdsnew(options[i]);
        if (dictAdd(options_dict, option, NULL)==DICT_ERR)
            sdsfree(option);
    }
}",3181.0,3187.0,1.0,49.0,7.0,5,3,10,5,0,3,3,4,1,3,,0,2,4,2,2,void
6244,357981,getLogLevel,1,getLogLevel,const char* getLogLevel (void),sentinel.c,"const char* getLogLevel(void) {
   switch (server.verbosity) {
    case LL_DEBUG: return ""debug"";
    case LL_VERBOSE: return ""verbose"";
    case LL_NOTICE: return ""notice"";
    case LL_WARNING: return ""warning"";
    case LL_NOTHING: return ""nothing"";
    }
    return ""unknown"";
}",3189.0,3198.0,1.0,9.0,10.0,1,1,1,1,0,0,2,2,0,0,,0,0,2,1,1,const char*
6245,358908,sentinelFailoverStateStr,1,sentinelFailoverStateStr,const char* sentinelFailoverStateStr (int),sentinel.c,"const char *sentinelFailoverStateStr(int state) {
    switch(state) {
    case SENTINEL_FAILOVER_STATE_NONE: return ""none"";
    case SENTINEL_FAILOVER_STATE_WAIT_START: return ""wait_start"";
    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return ""select_slave"";
    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return ""send_slaveof_noone"";
    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return ""wait_promotion"";
    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return ""reconf_slaves"";
    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return ""update_config"";
    default: return ""unknown"";
    }
}",3386.0,3397.0,1.0,9.0,12.0,0,0,1,1,1,0,2,2,0,0,,0,0,2,1,1,const char*
6246,358961,addReplySentinelRedisInstance,1,addReplySentinelRedisInstance,"void addReplySentinelRedisInstance (client*,sentinelRedisInstance*)",sentinel.c,"void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
    char *flags = sdsempty();
    void *mbl;
    int fields = 0;

    mbl = addReplyDeferredLen(c);

    addReplyBulkCString(c,""name"");
    addReplyBulkCString(c,ri->name);
    fields++;

    addReplyBulkCString(c,""ip"");
    addReplyBulkCString(c,announceSentinelAddr(ri->addr));
    fields++;

    addReplyBulkCString(c,""port"");
    addReplyBulkLongLong(c,ri->addr->port);
    fields++;

    addReplyBulkCString(c,""runid"");
    addReplyBulkCString(c,ri->runid ? ri->runid : """");
    fields++;

    addReplyBulkCString(c,""flags"");
    if (ri->flags & SRI_S_DOWN) flags = sdscat(flags,""s_down,"");
    if (ri->flags & SRI_O_DOWN) flags = sdscat(flags,""o_down,"");
    if (ri->flags & SRI_MASTER) flags = sdscat(flags,""master,"");
    if (ri->flags & SRI_SLAVE) flags = sdscat(flags,""slave,"");
    if (ri->flags & SRI_SENTINEL) flags = sdscat(flags,""sentinel,"");
    if (ri->link->disconnected) flags = sdscat(flags,""disconnect...",3400.0,3595.0,1.0,20.0,196.0,203,14,213,5,1,168,26,28,25,101,,0,95,4,2,2,void
6247,359783,sentinelSetDebugConfigParameters,1,sentinelSetDebugConfigParameters,void sentinelSetDebugConfigParameters (client*),sentinel.c,"void sentinelSetDebugConfigParameters(client *c){
    int j;
    int badarg = 0; /* Bad argument position for error reporting. */
    char *option;

    /* Process option - value pairs. */
    for (j = 2; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        option = c->argv[j]->ptr;
        long long ll;

        if (!strcasecmp(option,""info-period"") && moreargs > 0) {
            /* info-period <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            sentinel_info_period = ll;

        } else if (!strcasecmp(option,""ping-period"") && moreargs > 0) {
            /* ping-period <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            sentinel_ping_period = ll;

        } else if ...",3597.0,3740.0,1.0,48.0,144.0,31,16,28,9,0,9,5,7,2,3,,0,7,2,1,1,void
6248,360412,addReplySentinelDebugInfo,1,addReplySentinelDebugInfo,void addReplySentinelDebugInfo (client*),sentinel.c,"void addReplySentinelDebugInfo(client *c) {
    void *mbl;
    int fields = 0;

    mbl = addReplyDeferredLen(c);

    addReplyBulkCString(c,""INFO-PERIOD"");
    addReplyBulkLongLong(c,sentinel_info_period);
    fields++;

    addReplyBulkCString(c,""PING-PERIOD"");
    addReplyBulkLongLong(c,sentinel_ping_period);
    fields++;

    addReplyBulkCString(c,""ASK-PERIOD"");
    addReplyBulkLongLong(c,sentinel_ask_period);
    fields++;

    addReplyBulkCString(c,""PUBLISH-PERIOD"");
    addReplyBulkLongLong(c,sentinel_publish_period);
    fields++;

    addReplyBulkCString(c,""DEFAULT-DOWN-AFTER"");
    addReplyBulkLongLong(c,sentinel_default_down_after);
    fields++;

    addReplyBulkCString(c,""DEFAULT-FAILOVER-TIMEOUT"");
    addReplyBulkLongLong(c,sentinel_default_failover_timeout);
    fields++;

    addReplyBulkCString(c,""TILT-TRIGGER"");
    addReplyBulkLongLong(c,sentinel_tilt_trigger);
    fields++;

    addReplyBulkCString(c,""TILT-PERIOD"");
    addReplyBulkLongLong(c,sentinel_tilt_peri...",3742.0,3801.0,1.0,1.0,60.0,15,2,58,16,0,41,1,1,0,28,,0,14,2,1,1,void
6249,360534,addReplyDictOfRedisInstances,1,addReplyDictOfRedisInstances,"void addReplyDictOfRedisInstances (client*,dict*)",sentinel.c,"void addReplyDictOfRedisInstances(client *c, dict *instances) {
    dictIterator *di;
    dictEntry *de;
    long slaves = 0;
    void *replylen = addReplyDeferredLen(c);

    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        /* don't announce unannounced replicas */
        if (ri->flags & SRI_SLAVE && !ri->replica_announced) continue;
        addReplySentinelRedisInstance(c,ri);
        slaves++;
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c, replylen, slaves);
}",3805.0,3822.0,1.0,24.0,18.0,13,8,19,8,0,9,4,4,3,7,,0,6,4,2,2,void
6250,360596,sentinelGetMasterByNameOrReplyError,1,sentinelGetMasterByNameOrReplyError,"sentinelRedisInstance sentinelGetMasterByNameOrReplyError (client*,robj*)",sentinel.c,"sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
                        robj *name)
{
    sentinelRedisInstance *ri;

    ri = dictFetchValue(sentinel.masters,name->ptr);
    if (!ri) {
        addReplyError(c,""No such master with that name"");
        return NULL;
    }
    return ri;
}",3827.0,3838.0,1.0,1.0,12.0,4,4,7,5,0,4,2,2,0,2,,0,3,4,2,2,sentinelRedisInstance
6251,360623,sentinelIsQuorumReachable,1,sentinelIsQuorumReachable,"int sentinelIsQuorumReachable (sentinelRedisInstance*,int*)",sentinel.c,"int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
    dictIterator *di;
    dictEntry *de;
    int usable = 1; /* Number of usable Sentinels. Init to 1 to count myself. */
    int result = SENTINEL_ISQR_OK;
    int voters = dictSize(master->sentinels)+1; /* Known Sentinels + myself. */

    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        usable++;
    }
    dictReleaseIterator(di);

    if (usable < (int)master->quorum) result |= SENTINEL_ISQR_NOQUORUM;
    if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
    if (usableptr) *usableptr = usable;
    return result;
}",3843.0,3863.0,1.0,17.0,21.0,33,13,26,9,0,10,7,7,3,4,,0,9,4,2,2,int
6252,360748,sentinelCommand,1,sentinelCommand,void sentinelCommand (client*),sentinel.c,"void sentinelCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CKQUORUM <master-name>"",
""    Check if the current Sentinel configuration is able to reach the quorum"",
""    needed to failover a master and the majority needed to authorize the"",
""    failover."",
""CONFIG SET param value [param value ...]"",
""    Set a global Sentinel configuration parameter."",
""CONFIG GET <param> [param param param ...]"",
""    Get global Sentinel configuration parameter."",
""DEBUG [<param> <value> ...]"",
""    Show a list of configurable time parameters and their values (milliseconds)."",
""    Or update current configurable parameters values (one or more)."",
""GET-MASTER-ADDR-BY-NAME <master-name>"",
""    Return the ip and port number of the master with that name."",
""FAILOVER <master-name>"",
""    Manually failover a master node without asking for agreement from other"",
""    Sentinels"",
""FLUSHCONFIG"",
""    Force Sentinel to rewrite its configura...",3865.0,4241.0,1.0,44.0,377.0,9,7,7,3,0,4,2,2,2,2,,0,2,2,1,1,void
6253,362296,addInfoSectionsToDict,1,addInfoSectionsToDict,"void addInfoSectionsToDict (dict*,char**)",server.c,"void addInfoSectionsToDict(dict *section_dict, char **sections) {
    while (*sections) {
        sds section = sdsnew(*sections);
        if (dictAdd(section_dict, section, NULL)==DICT_ERR)
            sdsfree(section);
        sections++;
    }
}",5395.0,5402.0,1.0,50.0,8.0,0,0,0,0,3,0,1,1,0,0,,0,0,4,2,2,void
6254,362302,sentinelInfoCommand,1,sentinelInfoCommand,void sentinelInfoCommand (client*),sentinel.c,"void sentinelInfoCommand(client *c) {
    char *sentinel_sections[] = {""server"", ""clients"", ""cpu"", ""stats"", ""sentinel"", NULL};
    int sec_all = 0, sec_everything = 0;
    static dict *cached_all_info_sections = NULL;

    /* Get requested section list. */
    dict *sections_dict = genInfoSectionDict(c->argv+1, c->argc-1, sentinel_sections, &sec_all, &sec_everything);

    /* Purge unsupported sections from the requested ones. */
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(sections_dict);
    while((de = dictNext(di)) != NULL) {
        int i;
        sds sec = dictGetKey(de);
        for (i=0; sentinel_sections[i]; i++)
            if (!strcasecmp(sentinel_sections[i], sec))
                break;
        /* section not found? remove it */
        if (!sentinel_sections[i])
            dictDelete(sections_dict, sec);
    }
    dictReleaseIterator(di);

    /* Insert explicit all sections (don't pass these vars to genRedisInfoString) */
    if (sec_all || sec_every...",4246.0,4323.0,1.0,12.0,78.0,86,17,87,17,1,57,11,18,5,23,,0,50,2,1,1,void
6255,362638,sentinelRoleCommand,1,sentinelRoleCommand,void sentinelRoleCommand (client*),sentinel.c,"void sentinelRoleCommand(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c,2);
    addReplyBulkCBuffer(c,""sentinel"",8);
    addReplyArrayLen(c,dictSize(sentinel.masters));

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        addReplyBulkCString(c,ri->name);
    }
    dictReleaseIterator(di);
}",4327.0,4342.0,1.0,23.0,16.0,14,6,16,6,1,17,2,2,1,8,,0,12,2,1,1,void
6256,363437,sentinelPublishCommand,1,sentinelPublishCommand,void sentinelPublishCommand (client*),sentinel.c,"void sentinelPublishCommand(client *c) {
    if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
        addReplyError(c, ""Only HELLO messages are accepted by Sentinel instances."");
        return;
    }
    sentinelProcessHelloMessage(c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
    addReplyLongLong(c,1);
}",4525.0,4532.0,1.0,31.0,8.0,9,2,5,1,1,7,2,2,1,4,,0,4,2,1,1,void
6257,363478,sentinelCheckSubjectivelyDown,1,sentinelCheckSubjectivelyDown,void sentinelCheckSubjectivelyDown (sentinelRedisInstance*),sentinel.c,"void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
    mstime_t elapsed = 0;

    if (ri->link->act_ping_time)
        elapsed = mstime() - ri->link->act_ping_time;
    else if (ri->link->disconnected)
        elapsed = mstime() - ri->link->last_avail_time;

    /* Check if we are in need for a reconnection of one of the
     * links, because we are detecting low activity.
     *
     * 1) Check if the command link seems connected, was connected not less
     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a
     *    pending ping for more than half the timeout. */
    if (ri->link->cc &&
        (mstime() - ri->link->cc_conn_time) >
        sentinel_min_link_reconnect_period &&
        ri->link->act_ping_time != 0 && /* There is a pending ping... */
        /* The pending ping is delayed, and we did not receive
         * error replies as well. */
        (mstime() - ri->link->act_ping_time) > (ri->down_after_period/2) &&
        (mstime() - ri->link->l...",4537.0,4603.0,1.0,21.0,67.0,85,13,35,5,1,43,6,7,31,12,,0,40,2,1,1,void
6258,363752,sentinelCheckObjectivelyDown,1,sentinelCheckObjectivelyDown,void sentinelCheckObjectivelyDown (sentinelRedisInstance*),sentinel.c,"void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    unsigned int quorum = 0, odown = 0;

    if (master->flags & SRI_S_DOWN) {
        /* Is down for enough sentinels? */
        quorum = 1; /* the current sentinel. */
        /* Count all the other sentinels. */
        di = dictGetIterator(master->sentinels);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);

            if (ri->flags & SRI_MASTER_DOWN) quorum++;
        }
        dictReleaseIterator(di);
        if (quorum >= master->quorum) odown = 1;
    }

    /* Set the flag accordingly to the outcome. */
    if (odown) {
        if ((master->flags & SRI_O_DOWN) == 0) {
            sentinelEvent(LL_WARNING,""+odown"",master,""%@ #quorum %d/%d"",
                quorum, master->quorum);
            master->flags |= SRI_O_DOWN;
            master->o_down_since_time = mstime();
        }
    } else {
        if (master->fla...",4611.0,4644.0,1.0,24.0,34.0,27,8,24,7,1,14,7,12,5,6,,0,12,2,1,1,void
6259,363896,sentinelReceiveIsMasterDownReply,1,sentinelReceiveIsMasterDownReply,"void sentinelReceiveIsMasterDownReply (redisAsyncContext*,void*,void*)",sentinel.c,"void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* Ignore every error or unexpected reply.
     * Note that if the command returns an error for any reason we'll
     * end clearing the SRI_MASTER_DOWN flag for timeout anyway. */
    if (r->type == REDIS_REPLY_ARRAY && r->elements == 3 &&
        r->element[0]->type == REDIS_REPLY_INTEGER &&
        r->element[1]->type == REDIS_REPLY_STRING &&
        r->element[2]->type == REDIS_REPLY_INTEGER)
    {
        ri->last_master_down_reply_time = mstime();
        if (r->element[0]->integer == 1) {
            ri->flags |= SRI_MASTER_DOWN;
        } else {
            ri->flags &= ~SRI_MASTER_DOWN;
        }
        if (strcmp(r->element[1]->str,""*"")) {
            /* If the runid in the reply is not ""*"" the Sentinel act...",4648.0,4684.0,1.0,25.0,37.0,68,14,33,10,0,12,6,10,1,4,,0,10,6,3,3,void
6260,364099,sentinelAskMasterStateToOtherSentinels,1,sentinelAskMasterStateToOtherSentinels,"void sentinelAskMasterStateToOtherSentinels (sentinelRedisInstance*,int)",sentinel.c,"void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        mstime_t elapsed = mstime() - ri->last_master_down_reply_time;
        char port[32];
        int retval;

        /* If the master state from other sentinel is too old, we clear it. */
        if (elapsed > sentinel_ask_period*5) {
            ri->flags &= ~SRI_MASTER_DOWN;
            sdsfree(ri->leader);
            ri->leader = NULL;
        }

        /* Only ask if master is down to other sentinels if:
         *
         * 1) We believe it is down, or there is a failover in progress.
         * 2) Sentinel is connected.
         * 3) We did not receive the info within SENTINEL_ASK_PERIOD ms. */
        if ((master->flags & SRI_S_DOWN) == 0) continue;
        if (ri->link->disconnected) continue;
        i...",4691.0,4733.0,1.0,26.0,43.0,45,17,35,11,2,29,10,12,7,10,,0,26,4,2,2,void
6261,364404,sentinelLeaderIncr,1,sentinelLeaderIncr,"int sentinelLeaderIncr (dict*,char*)",sentinel.c,"int sentinelLeaderIncr(dict *counters, char *runid) {
    dictEntry *existing, *de;
    uint64_t oldval;

    de = dictAddRaw(counters,runid,&existing);
    if (existing) {
        oldval = dictGetUnsignedIntegerVal(existing);
        dictSetUnsignedIntegerVal(existing,oldval+1);
        return oldval+1;
    } else {
        serverAssert(de != NULL);
        dictSetUnsignedIntegerVal(de,1);
        return 1;
    }
}",4783.0,4797.0,1.0,8.0,15.0,5,3,10,5,2,3,2,2,0,3,,0,2,4,2,2,int
6262,364459,sentinelGetLeader,1,sentinelGetLeader,"char* sentinelGetLeader (sentinelRedisInstance*,uint64_t)",sentinel.c,"char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
    dict *counters;
    dictIterator *di;
    dictEntry *de;
    unsigned int voters = 0, voters_quorum;
    char *myvote;
    char *winner = NULL;
    uint64_t leader_epoch;
    uint64_t max_votes = 0;

    serverAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
    counters = dictCreate(&leaderVotesDictType);

    voters = dictSize(master->sentinels)+1; /* All the other sentinels and me.*/

    /* Count other sentinels votes */
    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->leader != NULL && ri->leader_epoch == sentinel.current_epoch)
            sentinelLeaderIncr(counters,ri->leader);
    }
    dictReleaseIterator(di);

    /* Check what's the winner. For the winner to win, it needs two conditions:
     * 1) Absolute majority between voters (50% + 1).
     * 2) And anyway at least master->...",4805.0,4868.0,1.0,4.0,64.0,62,20,73,16,1,29,9,12,7,17,,0,23,4,2,2,char*
6263,364982,sentinelStartFailoverIfNeeded,1,sentinelStartFailoverIfNeeded,int sentinelStartFailoverIfNeeded (sentinelRedisInstance*),sentinel.c,"int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
    /* We can't failover if the master is not in O_DOWN state. */
    if (!(master->flags & SRI_O_DOWN)) return 0;

    /* Failover already in progress? */
    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return 0;

    /* Last failover attempt started too little time ago? */
    if (mstime() - master->failover_start_time <
        master->failover_timeout*2)
    {
        if (master->failover_delay_logged != master->failover_start_time) {
            time_t clock = (master->failover_start_time +
                            master->failover_timeout*2) / 1000;
            char ctimebuf[26];

            ctime_r(&clock,ctimebuf);
            ctimebuf[24] = '\0'; /* Remove newline. */
            master->failover_delay_logged = master->failover_start_time;
            serverLog(LL_NOTICE,
                ""Next failover delay: I will not start a failover before %s"",
                ctimebuf);
        }
        return 0;...",4972.0,5000.0,1.0,26.0,29.0,30,14,17,4,1,13,5,6,7,3,,0,11,2,1,1,int
6264,365092,compareSlavesForPromotion,1,compareSlavesForPromotion,"int compareSlavesForPromotion (void*,void*)",sentinel.c,"int compareSlavesForPromotion(const void *a, const void *b) {
    sentinelRedisInstance **sa = (sentinelRedisInstance **)a,
                          **sb = (sentinelRedisInstance **)b;
    char *sa_runid, *sb_runid;

    if ((*sa)->slave_priority != (*sb)->slave_priority)
        return (*sa)->slave_priority - (*sb)->slave_priority;

    /* If priority is the same, select the slave with greater replication
     * offset (processed more data from the master). */
    if ((*sa)->slave_repl_offset > (*sb)->slave_repl_offset) {
        return -1; /* a < b */
    } else if ((*sa)->slave_repl_offset < (*sb)->slave_repl_offset) {
        return 1; /* a > b */
    }

    /* If the replication offset is the same select the slave with that has
     * the lexicographically smaller runid. Note that we try to handle runid
     * == NULL as there are old Redis versions that don't publish runid in
     * INFO. A NULL runid is considered bigger than any other runid. */
    sa_runid = (*sa)->runid;
...",5034.0,5060.0,1.0,1.0,27.0,29,10,20,7,0,0,4,4,0,0,,0,0,4,2,2,int
6265,365416,sentinelFailoverWaitStart,1,sentinelFailoverWaitStart,void sentinelFailoverWaitStart (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
    char *leader;
    int isleader;

    /* Check if we are the leader for the failover epoch. */
    leader = sentinelGetLeader(ri, ri->failover_epoch);
    isleader = leader && strcasecmp(leader,sentinel.myid) == 0;
    sdsfree(leader);

    /* If I'm not the leader, and it is not a forced failover via
     * SENTINEL FAILOVER, then I can't continue with the failover. */
    if (!isleader && !(ri->flags & SRI_FORCE_FAILOVER)) {
        mstime_t election_timeout = sentinel_election_timeout;

        /* The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT
         * and the configured failover timeout. */
        if (election_timeout > ri->failover_timeout)
            election_timeout = ri->failover_timeout;
        /* Abort the failover if I'm not the leader after some time. */
        if (mstime() - ri->failover_start_time > election_timeout) {
            sentinelEvent(LL_WARNING,""-failover-abort-not-electe...",5108.0,5139.0,1.0,35.0,32.0,27,10,25,6,1,21,5,7,6,9,,0,15,2,1,1,void
6266,365531,sentinelFailoverSelectSlave,1,sentinelFailoverSelectSlave,void sentinelFailoverSelectSlave (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
    sentinelRedisInstance *slave = sentinelSelectSlave(ri);

    /* We don't handle the timeout in this state as the function aborts
     * the failover or go forward in the next state. */
    if (slave == NULL) {
        sentinelEvent(LL_WARNING,""-failover-abort-no-good-slave"",ri,""%@"");
        sentinelAbortFailover(ri);
    } else {
        sentinelEvent(LL_WARNING,""+selected-slave"",slave,""%@"");
        slave->flags |= SRI_PROMOTED;
        ri->promoted_slave = slave;
        ri->failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
        ri->failover_state_change_time = mstime();
        sentinelEvent(LL_NOTICE,""+failover-state-send-slaveof-noone"",
            slave, ""%@"");
    }
}",5141.0,5158.0,1.0,22.0,18.0,2,2,6,3,1,3,2,2,0,3,,0,1,2,1,1,void
6267,365597,sentinelFailoverSendSlaveOfNoOne,1,sentinelFailoverSendSlaveOfNoOne,void sentinelFailoverSendSlaveOfNoOne (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
    int retval;

    /* We can't send the command to the promoted slave if it is now
     * disconnected. Retry again and again with this state until the timeout
     * is reached, then abort the failover. */
    if (ri->promoted_slave->link->disconnected) {
        if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
            sentinelEvent(LL_WARNING,""-failover-abort-slave-timeout"",ri,""%@"");
            sentinelAbortFailover(ri);
        }
        return;
    }

    /* Send SLAVEOF NO ONE command to turn the slave into a master.
     * We actually register a generic callback for this command as we don't
     * really care about the reply. We check if it worked indirectly observing
     * if INFO returns a different role (master instead of slave). */
    retval = sentinelSendSlaveOf(ri->promoted_slave,NULL);
    if (retval != C_OK) return;
    sentinelEvent(LL_NOTICE, ""+failover-state-wait-promo...",5160.0,5184.0,1.0,26.0,25.0,15,5,12,3,1,13,4,5,4,6,,0,10,2,1,1,void
6268,365669,sentinelFailoverWaitPromotion,1,sentinelFailoverWaitPromotion,void sentinelFailoverWaitPromotion (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
    /* Just handle the timeout. Switching to the next state is handled
     * by the function parsing the INFO command of the promoted slave. */
    if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
        sentinelEvent(LL_WARNING,""-failover-abort-slave-timeout"",ri,""%@"");
        sentinelAbortFailover(ri);
    }
}",5188.0,5195.0,1.0,22.0,8.0,4,3,4,1,1,5,2,2,3,3,,0,3,2,1,1,void
6269,365694,sentinelFailoverDetectEnd,1,sentinelFailoverDetectEnd,void sentinelFailoverDetectEnd (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
    int not_reconfigured = 0, timeout = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t elapsed = mstime() - master->failover_state_change_time;

    /* We can't consider failover finished if the promoted slave is
     * not reachable. */
    if (master->promoted_slave == NULL ||
        master->promoted_slave->flags & SRI_S_DOWN) return;

    /* The failover terminates once all the reachable slaves are properly
     * configured. */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
        if (slave->flags & SRI_S_DOWN) continue;
        not_reconfigured++;
    }
    dictReleaseIterator(di);

    /* Force end of failover on timeout. */
    if (elapsed > master->failover_timeout) {
        not_reconfigured = 0;
        timeout = 1;
        sentinelEvent(LL...",5197.0,5256.0,1.0,40.0,60.0,55,11,44,9,1,28,16,21,9,14,,0,23,2,1,1,void
6270,365925,sentinelFailoverReconfNextSlave,1,sentinelFailoverReconfNextSlave,void sentinelFailoverReconfNextSlave (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int in_progress = 0;

    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & (SRI_RECONF_SENT|SRI_RECONF_INPROG))
            in_progress++;
    }
    dictReleaseIterator(di);

    di = dictGetIterator(master->slaves);
    while(in_progress < master->parallel_syncs &&
          (de = dictNext(di)) != NULL)
    {
        sentinelRedisInstance *slave = dictGetVal(de);
        int retval;

        /* Skip the promoted slave, and already configured slaves. */
        if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;

        /* If too much time elapsed without the slave moving forward to
         * the next state, consider it reconfigured even if it is not.
         * Sentinels will detect the slave as misconfigured and fix its
         * configuration l...",5260.0,5315.0,1.0,28.0,56.0,53,13,39,8,1,29,12,15,11,14,,0,24,2,1,1,void
6271,366134,sentinelFailoverSwitchToPromotedSlave,1,sentinelFailoverSwitchToPromotedSlave,void sentinelFailoverSwitchToPromotedSlave (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance *ref = master->promoted_slave ?
                                 master->promoted_slave : master;

    sentinelEvent(LL_WARNING,""+switch-master"",master,""%s %s %d %s %d"",
        master->name, announceSentinelAddr(master->addr), master->addr->port,
        announceSentinelAddr(ref->addr), ref->addr->port);

    sentinelResetMasterAndChangeAddress(master,ref->addr->hostname,ref->addr->port);
}",5320.0,5329.0,1.0,18.0,10.0,15,3,13,2,1,13,1,1,0,4,,0,11,2,1,1,void
6272,366190,sentinelFailoverStateMachine,1,sentinelFailoverStateMachine,void sentinelFailoverStateMachine (sentinelRedisInstance*),sentinel.c,"void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;

    switch(ri->failover_state) {
        case SENTINEL_FAILOVER_STATE_WAIT_START:
            sentinelFailoverWaitStart(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
            sentinelFailoverSelectSlave(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
            sentinelFailoverSendSlaveOfNoOne(ri);
            break;
        case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
            sentinelFailoverWaitPromotion(ri);
            break;
        case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
            sentinelFailoverReconfNextSlave(ri);
            break;
    }
}",5331.0,5353.0,1.0,4.0,23.0,12,8,8,1,1,9,8,3,2,6,,0,3,2,1,1,void
6273,366361,sentinelHandleRedisInstance,1,sentinelHandleRedisInstance,void sentinelHandleRedisInstance (sentinelRedisInstance*),sentinel.c,"void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
    /* ========== MONITORING HALF ============ */
    /* Every kind of instance */
    sentinelReconnectInstance(ri);
    sentinelSendPeriodicCommands(ri);

    /* ============== ACTING HALF ============= */
    /* We don't proceed with the acting half if we are in TILT mode.
     * TILT happens when we find something odd with the time, like a
     * sudden change in the clock. */
    if (sentinel.tilt) {
        if (mstime()-sentinel.tilt_start_time < sentinel_tilt_period) return;
        sentinel.tilt = 0;
        sentinelEvent(LL_WARNING,""-tilt"",NULL,""#tilt mode exited"");
    }

    /* Every kind of instance */
    sentinelCheckSubjectivelyDown(ri);

    /* Masters and slaves */
    if (ri->flags & (SRI_MASTER|SRI_SLAVE)) {
        /* Nothing so far. */
    }

    /* Only masters */
    if (ri->flags & SRI_MASTER) {
        sentinelCheckObjectivelyDown(ri);
        if (sentinelStartFailoverIfNeeded(ri))
            sen...",5379.0,5411.0,1.0,22.0,33.0,15,8,15,4,1,19,6,8,9,10,,0,11,2,1,1,void
6274,366447,sentinelHandleDictOfRedisInstances,1,sentinelHandleDictOfRedisInstances,void sentinelHandleDictOfRedisInstances (dict*),sentinel.c,"void sentinelHandleDictOfRedisInstances(dict *instances) {
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *switch_to_promoted = NULL;

    /* There are a number of things we need to perform against every master. */
    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        sentinelHandleRedisInstance(ri);
        if (ri->flags & SRI_MASTER) {
            sentinelHandleDictOfRedisInstances(ri->slaves);
            sentinelHandleDictOfRedisInstances(ri->sentinels);
            if (ri->failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) {
                switch_to_promoted = ri;
            }
        }
    }
    if (switch_to_promoted)
        sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
    dictReleaseIterator(di);
}",5415.0,5437.0,1.0,24.0,23.0,13,6,19,6,1,10,5,8,3,6,,0,7,2,1,1,void
6275,366515,sentinelCheckTiltCondition,1,sentinelCheckTiltCondition,void sentinelCheckTiltCondition (void),sentinel.c,"void sentinelCheckTiltCondition(void) {
    mstime_t now = mstime();
    mstime_t delta = now - sentinel.previous_time;

    if (delta < 0 || delta > sentinel_tilt_trigger) {
        sentinel.tilt = 1;
        sentinel.tilt_start_time = mstime();
        sentinelEvent(LL_WARNING,""+tilt"",NULL,""#tilt mode entered"");
    }
    sentinel.previous_time = mstime();
}",5458.0,5468.0,1.0,22.0,11.0,13,6,11,5,1,13,2,2,1,4,,0,12,2,1,1,void
6276,366563,sentinelTimer,1,sentinelTimer,void sentinelTimer (void),sentinel.c,"void sentinelTimer(void) {
    sentinelCheckTiltCondition();
    sentinelHandleDictOfRedisInstances(sentinel.masters);
    sentinelRunPendingScripts();
    sentinelCollectTerminatedScripts();
    sentinelKillTimedoutScripts();

    /* We continuously change the frequency of the Redis ""timer interrupt""
     * in order to desynchronize every Sentinel from every other.
     * This non-determinism avoids that Sentinels started at the same time
     * exactly continue to stay synchronized asking to be voted at the
     * same time again and again (resulting in nobody likely winning the
     * election because of split brain voting). */
    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
}",5470.0,5484.0,1.0,16.0,15.0,5,4,2,2,1,7,1,1,0,5,,0,2,2,1,1,void
6277,366678,isShutdownInitiated,1,isShutdownInitiated,int isShutdownInitiated (void),server.c,"static inline int isShutdownInitiated(void) {
    return server.shutdown_mstime != 0;
}",4265.0,4267.0,1.0,1.0,3.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,int
6278,366683,isReadyToShutdown,1,isReadyToShutdown,int isReadyToShutdown (void),server.c,"int isReadyToShutdown(void) {
    if (listLength(server.slaves) == 0) return 1;  /* No replicas. */

    listIter li;
    listNode *ln;
    listRewind(server.slaves, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *replica = listNodeValue(ln);
        if (replica->repl_ack_off != server.master_repl_offset) return 0;
    }
    return 1;
}",4272.0,4283.0,1.0,8.0,12.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
6279,366688,finishShutdown,1,finishShutdown,int finishShutdown (void),server.c,"int finishShutdown(void) {

    int save = server.shutdown_flags & SHUTDOWN_SAVE;
    int nosave = server.shutdown_flags & SHUTDOWN_NOSAVE;
    int force = server.shutdown_flags & SHUTDOWN_FORCE;

    /* Log a warning for each replica that is lagging. */
    listIter replicas_iter;
    listNode *replicas_list_node;
    int num_replicas = 0, num_lagging_replicas = 0;
    listRewind(server.slaves, &replicas_iter);
    while ((replicas_list_node = listNext(&replicas_iter)) != NULL) {
        client *replica = listNodeValue(replicas_list_node);
        num_replicas++;
        if (replica->repl_ack_off != server.master_repl_offset) {
            num_lagging_replicas++;
            long lag = replica->replstate == SLAVE_STATE_ONLINE ?
                time(NULL) - replica->repl_ack_time : 0;
            serverLog(LL_NOTICE,
                      ""Lagging replica %s reported offset %lld behind master, lag=%ld, state=%s."",
                      replicationGetSlaveName(replica),
             ...",4313.0,4460.0,1.0,39.0,148.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
6280,366693,replstateToString,1,replstateToString,char* replstateToString (int),server.c,"const char *replstateToString(int replstate) {
    switch (replstate) {
    case SLAVE_STATE_WAIT_BGSAVE_START:
    case SLAVE_STATE_WAIT_BGSAVE_END:
        return ""wait_bgsave"";
    case SLAVE_STATE_SEND_BULK:
        return ""send_bulk"";
    case SLAVE_STATE_ONLINE:
        return ""online"";
    default:
        return """";
    }
}",5298.0,5310.0,1.0,9.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,const char*
6281,366706,serverLogRaw,1,serverLogRaw,"void serverLogRaw (int,char*)",server.c,"void serverLogRaw(int level, const char *msg) {
    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
    const char *c = "".-*#"";
    FILE *fp;
    char buf[64];
    int rawmode = (level & LL_RAW);
    int log_to_stdout = server.logfile[0] == '\0';

    level &= 0xff; /* clear flags */
    if (level < server.verbosity) return;

    fp = log_to_stdout ? stdout : fopen(server.logfile,""a"");
    if (!fp) return;

    if (rawmode) {
        fprintf(fp,""%s"",msg);
    } else {
        int off;
        struct timeval tv;
        int role_char;
        pid_t pid = getpid();

        gettimeofday(&tv,NULL);
        struct tm tm;
        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);
        off = strftime(buf,sizeof(buf),""%d %b %Y %H:%M:%S."",&tm);
        snprintf(buf+off,sizeof(buf)-off,""%03d"",(int)tv.tv_usec/1000);
        if (server.sentinel_mode) {
            role_char = 'X'; /* Sentinel. */
        } else if (pid != server.pid) {
  ...",106.0,147.0,1.0,27.0,42.0,19,10,28,13,20,8,6,6,4,0,,0,8,4,2,2,void
6282,366891,_serverLog,1,_serverLog,"void _serverLog (int,char*...)",server.c,"void _serverLog(int level, const char *fmt, ...) {
    va_list ap;
    char msg[LOG_MAX_LEN];

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    serverLogRaw(level,msg);
}",152.0,161.0,1.0,13.0,10.0,1,1,9,4,362,1,1,1,0,1,,0,0,4,2,2,void
6283,366913,serverLogFromHandler,1,serverLogFromHandler,"void serverLogFromHandler (int,char*)",server.c,"void serverLogFromHandler(int level, const char *msg) {
    int fd;
    int log_to_stdout = server.logfile[0] == '\0';
    char buf[64];

    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
        return;
    fd = log_to_stdout ? STDOUT_FILENO :
                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
    if (fd == -1) return;
    ll2string(buf,sizeof(buf),getpid());
    if (write(fd,buf,strlen(buf)) == -1) goto err;
    if (write(fd,"":signal-handler ("",17) == -1) goto err;
    ll2string(buf,sizeof(buf),time(NULL));
    if (write(fd,buf,strlen(buf)) == -1) goto err;
    if (write(fd,"") "",2) == -1) goto err;
    if (write(fd,msg,strlen(msg)) == -1) goto err;
    if (write(fd,""\n"",1) == -1) goto err;
err:
    if (!log_to_stdout) close(fd);
}",169.0,189.0,1.0,1.0,21.0,32,13,33,11,6,10,16,10,4,2,,0,8,4,2,2,void
6284,367086,commandTimeSnapshot,1,commandTimeSnapshot,mstime_t commandTimeSnapshot (void),server.c,"mstime_t commandTimeSnapshot(void) {
    /* When we are in the middle of a command execution, we want to use a
     * reference time that does not change: in that case we just use the
     * cached time, that we update before each call in the call() function.
     * This way we avoid that commands such as RPOPLPUSH or similar, that
     * may re-open the same key multiple times, can invalidate an already
     * open object in a next call, if the next call will see the key expired,
     * while the first did not.
     * This is specifically important in the context of scripts, where we
     * pretend that time freezes. This way a key can expire only the first time
     * it is accessed and not in the middle of the script execution, making
     * propagation to slaves / AOF consistent. See issue #1525 for more info.
     * Note that we cannot use the cached server.mstime because it can change
     * in processEventsWhileBlocked etc. */
    return server.cmd_time_snapshot;
}",212.0,227.0,1.0,1.0,16.0,1,1,1,1,13,2,1,1,0,0,,0,2,2,1,1,mstime_t
6285,367095,exitFromChild,1,exitFromChild,void exitFromChild (int),server.c,"void exitFromChild(int retcode) {
#ifdef COVERAGE_TEST
    exit(retcode);
#else
    _exit(retcode);
#endif
}",233.0,239.0,1.0,1.0,7.0,0,0,1,1,7,0,1,1,0,0,,0,0,2,1,1,void
6286,367173,dictSdsKeyCaseCompare,1,dictSdsKeyCaseCompare,"int dictSdsKeyCaseCompare (dict*,void*,void*)",server.c,"int dictSdsKeyCaseCompare(dict *d, const void *key1,
        const void *key2)
{
    UNUSED(d);
    return strcasecmp(key1, key2) == 0;
}",273.0,278.0,1.0,4.0,6.0,2,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,int
6287,367192,dictObjectDestructor,1,dictObjectDestructor,"void dictObjectDestructor (dict*,void*)",server.c,"void dictObjectDestructor(dict *d, void *val)
{
    UNUSED(d);
    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
    decrRefCount(val);
}",280.0,285.0,1.0,4.0,6.0,2,2,5,3,0,1,2,2,0,1,,0,0,4,2,2,void
6288,367226,dictSdsDup,1,dictSdsDup,"void* dictSdsDup (dict*,void*)",server.c,"void *dictSdsDup(dict *d, const void *key) {
    UNUSED(d);
    return sdsdup((const sds) key);
}",293.0,296.0,1.0,4.0,4.0,2,1,3,2,0,1,1,1,0,1,,0,0,4,2,2,void*
6289,367243,dictObjKeyCompare,1,dictObjKeyCompare,"int dictObjKeyCompare (dict*,void*,void*)",server.c,"int dictObjKeyCompare(dict *d, const void *key1,
        const void *key2)
{
    const robj *o1 = key1, *o2 = key2;
    return dictSdsKeyCompare(d, o1->ptr,o2->ptr);
}",298.0,303.0,1.0,1.0,6.0,4,2,7,5,0,1,1,1,0,1,,0,0,6,3,3,int
6290,367267,dictObjHash,1,dictObjHash,uint64_t dictObjHash (void*),server.c,"uint64_t dictObjHash(const void *key) {
    const robj *o = key;
    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
}",305.0,308.0,1.0,1.0,4.0,4,3,4,2,0,2,1,1,0,2,,0,1,2,1,1,uint64_t
6291,367301,dictSdsCaseHash,1,dictSdsCaseHash,uint64_t dictSdsCaseHash (void*),server.c,"uint64_t dictSdsCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));
}",314.0,316.0,1.0,1.0,3.0,2,1,2,1,0,2,1,1,0,2,,0,1,2,1,1,uint64_t
6292,367315,dictCStrHash,1,dictCStrHash,uint64_t dictCStrHash (void*),server.c,"uint64_t dictCStrHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
}",319.0,321.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
6293,367329,dictCStrCaseHash,1,dictCStrCaseHash,uint64_t dictCStrCaseHash (void*),server.c,"uint64_t dictCStrCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, strlen((char*)key));
}",324.0,326.0,1.0,1.0,3.0,2,1,2,1,0,1,1,1,0,1,,0,0,2,1,1,uint64_t
6294,367343,dictCStrKeyCompare,1,dictCStrKeyCompare,"int dictCStrKeyCompare (dict*,void*,void*)",server.c,"int dictCStrKeyCompare(dict *d, const void *key1, const void *key2) {
    int l1,l2;
    UNUSED(d);

    l1 = strlen((char*)key1);
    l2 = strlen((char*)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",329.0,337.0,1.0,4.0,9.0,7,4,11,5,0,0,2,2,0,0,,0,0,6,3,3,int
6295,367384,dictCStrKeyCaseCompare,1,dictCStrKeyCaseCompare,"int dictCStrKeyCaseCompare (dict*,void*,void*)",server.c,"int dictCStrKeyCaseCompare(dict *d, const void *key1, const void *key2) {
    UNUSED(d);
    return strcasecmp(key1, key2) == 0;
}",340.0,343.0,1.0,4.0,4.0,2,2,4,3,0,0,1,1,0,0,,0,0,6,3,3,int
6296,367403,dictEncObjKeyCompare,1,dictEncObjKeyCompare,"int dictEncObjKeyCompare (dict*,void*,void*)",server.c,"int dictEncObjKeyCompare(dict *d, const void *key1, const void *key2)
{
    robj *o1 = (robj*) key1, *o2 = (robj*) key2;
    int cmp;

    if (o1->encoding == OBJ_ENCODING_INT &&
        o2->encoding == OBJ_ENCODING_INT)
            return o1->ptr == o2->ptr;

    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without
     * good reasons, because it would incrRefCount() the object, which
     * is invalid. So we check to make sure dictFind() works with static
     * objects as well. */
    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);
    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);
    cmp = dictSdsKeyCompare(d,o1->ptr,o2->ptr);
    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);
    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);
    return cmp;
}",345.0,364.0,1.0,24.0,20.0,29,7,27,7,0,5,6,6,0,5,,0,3,6,3,3,int
6297,367516,dictEncObjHash,1,dictEncObjHash,uint64_t dictEncObjHash (void*),server.c,"uint64_t dictEncObjHash(const void *key) {
    robj *o = (robj*) key;

    if (sdsEncodedObject(o)) {
        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
    } else if (o->encoding == OBJ_ENCODING_INT) {
        char buf[32];
        int len;

        len = ll2string(buf,32,(long)o->ptr);
        return dictGenHashFunction((unsigned char*)buf, len);
    } else {
        serverPanic(""Unknown string encoding"");
    }
}",366.0,380.0,1.0,8.0,15.0,10,5,7,2,0,2,2,2,0,2,,0,1,2,1,1,uint64_t
6298,367593,dictExpandAllowed,1,dictExpandAllowed,"int dictExpandAllowed (size_t,double)",server.c,"int dictExpandAllowed(size_t moreMem, double usedRatio) {
    if (usedRatio <= HASHTABLE_MAX_LOAD_FACTOR) {
        return !overMaxmemoryAfterAlloc(moreMem);
    } else {
        return 1;
    }
}",388.0,394.0,1.0,21.0,7.0,2,2,2,2,0,1,2,2,0,1,,0,0,4,2,2,int
6299,367614,dbDictEntryMetadataSize,1,dbDictEntryMetadataSize,size_t dbDictEntryMetadataSize (dict*),server.c,"size_t dbDictEntryMetadataSize(dict *d) {
    UNUSED(d);
    /* NOTICE: this also affects overhead_ht_slot_to_keys in getMemoryOverheadData.
     * If we ever add non-cluster related data here, that code must be modified too. */
    return server.cluster_enabled ? sizeof(clusterDictEntryMetadata) : 0;
}",399.0,404.0,1.0,4.0,6.0,4,4,4,3,0,2,1,1,0,0,,0,2,2,1,1,size_t
6300,367633,dbDictMetadataSize,1,dbDictMetadataSize,size_t dbDictMetadataSize (void),server.c,"size_t dbDictMetadataSize(void) {
    return server.cluster_enabled ? sizeof(clusterDictMetadata) : 0;
}",409.0,411.0,1.0,1.0,3.0,3,3,2,2,0,2,1,1,0,0,,0,2,2,1,1,size_t
6301,367646,dbDictAfterReplaceEntry,1,dbDictAfterReplaceEntry,"void dbDictAfterReplaceEntry (dict*,dictEntry*)",server.c,"void dbDictAfterReplaceEntry(dict *d, dictEntry *de) {
    if (server.cluster_enabled) slotToKeyReplaceEntry(d, de);
}",413.0,415.0,1.0,1.0,3.0,1,1,3,3,0,3,2,2,2,1,,0,2,4,2,2,void
6302,367843,htNeedsResize,1,htNeedsResize,int htNeedsResize (dict*),server.c,"int htNeedsResize(dict *dict) {
    long long size, used;

    size = dictSlots(dict);
    used = dictSize(dict);
    return (size > DICT_HT_INITIAL_SIZE &&
            (used*100/size < HASHTABLE_MIN_FILL));
}",593.0,600.0,1.0,11.0,8.0,32,14,13,3,3,6,1,1,0,0,,0,6,2,1,1,int
6303,367928,tryResizeHashTables,1,tryResizeHashTables,void tryResizeHashTables (int),server.c,"void tryResizeHashTables(int dbid) {
    if (htNeedsResize(server.db[dbid].dict))
        dictResize(server.db[dbid].dict);
    if (htNeedsResize(server.db[dbid].expires))
        dictResize(server.db[dbid].expires);
}",604.0,609.0,1.0,1.0,6.0,12,2,8,2,1,12,3,3,6,4,,0,10,2,1,1,void
6304,367969,incrementallyRehash,1,incrementallyRehash,int incrementallyRehash (int),server.c,"int incrementallyRehash(int dbid) {
    /* Keys dictionary */
    if (dictIsRehashing(server.db[dbid].dict)) {
        dictRehashMilliseconds(server.db[dbid].dict,1);
        return 1; /* already used our millisecond for this loop... */
    }
    /* Expires */
    if (dictIsRehashing(server.db[dbid].expires)) {
        dictRehashMilliseconds(server.db[dbid].expires,1);
        return 1; /* already used our millisecond for this loop... */
    }
    return 0;
}",618.0,630.0,1.0,8.0,13.0,24,5,12,2,1,14,3,3,8,2,,0,12,2,1,1,int
6305,368044,updateDictResizePolicy,1,updateDictResizePolicy,void updateDictResizePolicy (void),server.c,"void updateDictResizePolicy(void) {
    if (server.in_fork_child != CHILD_TYPE_NONE)
        dictSetResizeEnabled(DICT_RESIZE_FORBID);
    else if (hasActiveChildProcess())
        dictSetResizeEnabled(DICT_RESIZE_AVOID);
    else
        dictSetResizeEnabled(DICT_RESIZE_ENABLE);
}",638.0,645.0,1.0,32.0,8.0,2,2,2,2,3,3,2,2,2,1,,0,2,2,1,1,void
6306,368071,strChildType,1,strChildType,const char* strChildType (int),server.c,"const char *strChildType(int type) {
    switch(type) {
        case CHILD_TYPE_RDB: return ""RDB"";
        case CHILD_TYPE_AOF: return ""AOF"";
        case CHILD_TYPE_LDB: return ""LDB"";
        case CHILD_TYPE_MODULE: return ""MODULE"";
        default: return ""Unknown"";
    }
}",647.0,655.0,1.0,13.0,9.0,0,0,1,1,1,0,2,2,0,0,,0,0,2,1,1,const char*
6307,368106,hasActiveChildProcess,1,hasActiveChildProcess,int hasActiveChildProcess (void),server.c,"int hasActiveChildProcess(void) {
    return server.child_pid != -1;
}",659.0,661.0,1.0,1.0,3.0,3,3,1,1,13,2,1,1,0,0,,0,2,2,1,1,int
6308,368118,resetChildState,1,resetChildState,void resetChildState (void),server.c,"void resetChildState(void) {
    server.child_type = CHILD_TYPE_NONE;
    server.child_pid = -1;
    server.stat_current_cow_peak = 0;
    server.stat_current_cow_bytes = 0;
    server.stat_current_cow_updated = 0;
    server.stat_current_save_keys_processed = 0;
    server.stat_module_progress = 0;
    server.stat_current_save_keys_total = 0;
    updateDictResizePolicy();
    closeChildInfoPipe();
    moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,
                          REDISMODULE_SUBEVENT_FORK_CHILD_DIED,
                          NULL);
}",663.0,677.0,1.0,24.0,15.0,17,3,9,2,2,19,1,1,0,3,,0,16,2,1,1,void
6309,368176,isMutuallyExclusiveChildType,1,isMutuallyExclusiveChildType,int isMutuallyExclusiveChildType (int),server.c,"int isMutuallyExclusiveChildType(int type) {
    return type == CHILD_TYPE_RDB || type == CHILD_TYPE_AOF || type == CHILD_TYPE_MODULE;
}",680.0,682.0,1.0,19.0,3.0,5,2,3,1,1,0,1,1,0,0,,0,0,2,1,1,int
6310,368199,isInsideYieldingLongCommand,1,isInsideYieldingLongCommand,int isInsideYieldingLongCommand (void),server.c,"int isInsideYieldingLongCommand(void) {
    return scriptIsTimedout() || server.busy_module_yield_flags;
}",685.0,687.0,1.0,1.0,3.0,2,2,1,1,5,3,1,1,0,1,,0,2,2,1,1,int
6311,368210,allPersistenceDisabled,1,allPersistenceDisabled,int allPersistenceDisabled (void),server.c,"int allPersistenceDisabled(void) {
    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;
}",691.0,693.0,1.0,60.0,3.0,5,3,2,1,1,4,1,1,0,0,,0,4,2,1,1,int
6312,368229,trackInstantaneousMetric,1,trackInstantaneousMetric,"void trackInstantaneousMetric (int,long long,long long,long long)",server.c,"void trackInstantaneousMetric(int metric, long long current_value, long long current_base, long long factor) {
    if (server.inst_metric[metric].last_sample_base > 0) {
        long long base = current_base - server.inst_metric[metric].last_sample_base;
        long long value = current_value - server.inst_metric[metric].last_sample_value;
        long long avg = base > 0 ? (value * factor / base) : 0;
        server.inst_metric[metric].samples[server.inst_metric[metric].idx] = avg;
        server.inst_metric[metric].idx++;
        server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
    }
    server.inst_metric[metric].last_sample_base = current_base;
    server.inst_metric[metric].last_sample_value = current_value;
}",704.0,715.0,1.0,42.0,12.0,42,9,30,8,7,9,2,2,1,0,,0,9,8,4,4,void
6313,368339,getInstantaneousMetric,1,getInstantaneousMetric,long long getInstantaneousMetric (int),server.c,"long long getInstantaneousMetric(int metric) {
    int j;
    long long sum = 0;

    for (j = 0; j < STATS_METRIC_SAMPLES; j++)
        sum += server.inst_metric[metric].samples[j];
    return sum / STATS_METRIC_SAMPLES;
}",718.0,725.0,1.0,20.0,8.0,4,3,4,2,7,0,2,2,0,0,,0,0,2,1,1,long long
6314,368378,clientsCronResizeQueryBuffer,1,clientsCronResizeQueryBuffer,int clientsCronResizeQueryBuffer (client*),server.c,"int clientsCronResizeQueryBuffer(client *c) {
    size_t querybuf_size = sdsalloc(c->querybuf);
    time_t idletime = server.unixtime - c->lastinteraction;

    /* Only resize the query buffer if the buffer is actually wasting at least a
     * few kbytes */
    if (sdsavail(c->querybuf) > 1024*4) {
        /* There are two conditions to resize the query buffer: */
        if (idletime > 2) {
            /* 1) Query is idle for a long time. */
            c->querybuf = sdsRemoveFreeSpace(c->querybuf, 1);
        } else if (querybuf_size > PROTO_RESIZE_THRESHOLD && querybuf_size/2 > c->querybuf_peak) {
            /* 2) Query buffer is too big for latest peak and is larger than
             *    resize threshold. Trim excess space but only up to a limit,
             *    not below the recent peak and current c->querybuf (which will
             *    be soon get used). If we're in the middle of a bulk then make
             *    sure not to resize to less than the bulk length. */
   ...",731.0,762.0,1.0,35.0,32.0,29,11,16,4,1,18,4,5,5,4,,0,18,2,1,1,int
6315,368536,clientsCronResizeOutputBuffer,1,clientsCronResizeOutputBuffer,"int clientsCronResizeOutputBuffer (client*,mstime_t)",server.c,"int clientsCronResizeOutputBuffer(client *c, mstime_t now_ms) {

    size_t new_buffer_size = 0;
    char *oldbuf = NULL;
    const size_t buffer_target_shrink_size = c->buf_usable_size/2;
    const size_t buffer_target_expand_size = c->buf_usable_size*2;

    /* in case the resizing is disabled return immediately */
    if(!server.reply_buffer_resizing_enabled)
        return 0;

    if (buffer_target_shrink_size >= PROTO_REPLY_MIN_BYTES &&
        c->buf_peak < buffer_target_shrink_size )
    {
        new_buffer_size = max(PROTO_REPLY_MIN_BYTES,c->buf_peak+1);
        server.stat_reply_buffer_shrinks++;
    } else if (buffer_target_expand_size < PROTO_REPLY_CHUNK_BYTES*2 &&
        c->buf_peak == c->buf_usable_size)
    {
        new_buffer_size = min(PROTO_REPLY_CHUNK_BYTES,buffer_target_expand_size);
        server.stat_reply_buffer_expands++;
    }

    serverAssertWithInfo(c, NULL, (!new_buffer_size) || (new_buffer_size >= (size_t)c->bufpos));

    /* reset the peak value eac...",771.0,813.0,1.0,37.0,43.0,52,19,40,8,1,26,5,5,8,3,,0,24,4,2,2,int
6316,368745,clientsCronTrackExpansiveClients,1,clientsCronTrackExpansiveClients,"int clientsCronTrackExpansiveClients (client*,int)",server.c,"int clientsCronTrackExpansiveClients(client *c, int time_idx) {
    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum +
	              (c->argv ? zmalloc_size(c->argv) : 0);
    size_t out_usage = getClientOutputBufferMemoryUsage(c);

    /* Track the biggest values observed so far in this slot. */
    if (in_usage > ClientsPeakMemInput[time_idx]) ClientsPeakMemInput[time_idx] = in_usage;
    if (out_usage > ClientsPeakMemOutput[time_idx]) ClientsPeakMemOutput[time_idx] = out_usage;

    return 0; /* This function never terminates the client. */
}",831.0,841.0,1.0,1.0,11.0,17,6,19,6,1,11,3,3,2,3,,0,11,4,2,2,int
6317,368803,getMemUsageBucket,1,getMemUsageBucket,clientMemUsageBucket getMemUsageBucket (size_t),server.c,"static inline clientMemUsageBucket *getMemUsageBucket(size_t mem) {
    int size_in_bits = 8*(int)sizeof(mem);
    int clz = mem > 0 ? __builtin_clzl(mem) : size_in_bits;
    int bucket_idx = size_in_bits - clz;
    if (bucket_idx > CLIENT_MEM_USAGE_BUCKET_MAX_LOG)
        bucket_idx = CLIENT_MEM_USAGE_BUCKET_MAX_LOG;
    else if (bucket_idx < CLIENT_MEM_USAGE_BUCKET_MIN_LOG)
        bucket_idx = CLIENT_MEM_USAGE_BUCKET_MIN_LOG;
    bucket_idx -= CLIENT_MEM_USAGE_BUCKET_MIN_LOG;
    return &server.client_mem_usage_buckets[bucket_idx];
}",850.0,860.0,1.0,21.0,11.0,15,11,14,5,1,2,2,2,0,0,,0,2,2,1,1,clientMemUsageBucket
6318,368871,updateClientMemoryUsage,1,updateClientMemoryUsage,void updateClientMemoryUsage (client*),server.c,"void updateClientMemoryUsage(client *c) {
    size_t mem = getClientMemoryUsage(c, NULL);
    int type = getClientType(c);
    /* Now that we have the memory used by the client, remove the old
     * value from the old category, and add it back. */
    server.stat_clients_type_memory[c->last_memory_type] -= c->last_memory_usage;
    server.stat_clients_type_memory[type] += mem;
    /* Remember what we added and where, to remove it next time. */
    c->last_memory_type = type;
    c->last_memory_usage = mem;
}",874.0,884.0,1.0,1.0,11.0,14,6,15,5,2,10,1,1,0,2,,0,10,2,1,1,void
6319,368915,clientEvictionAllowed,1,clientEvictionAllowed,int clientEvictionAllowed (client*),server.c,"int clientEvictionAllowed(client *c) {
    if (server.maxmemory_clients == 0 || c->flags & CLIENT_NO_EVICT) {
        return 0;
    }
    int type = getClientType(c);
    return (type == CLIENT_TYPE_NORMAL || type == CLIENT_TYPE_PUBSUB);
}",886.0,892.0,1.0,52.0,7.0,10,7,6,3,1,4,2,2,3,1,,0,4,2,1,1,int
6320,368956,removeClientFromMemUsageBucket,1,removeClientFromMemUsageBucket,"void removeClientFromMemUsageBucket (client*,int)",server.c,"void removeClientFromMemUsageBucket(client *c, int allow_eviction) {
    if (c->mem_usage_bucket) {
        c->mem_usage_bucket->mem_usage_sum -= c->last_memory_usage;
        /* If this client can't be evicted then remove it from the mem usage
         * buckets */
        if (!allow_eviction) {
            listDelNode(c->mem_usage_bucket->clients, c->mem_usage_bucket_node);
            c->mem_usage_bucket = NULL;
            c->mem_usage_bucket_node = NULL;
        }
    }
}",899.0,910.0,1.0,1.0,12.0,13,4,10,3,2,8,3,4,1,1,,0,7,4,2,2,void
6321,368999,updateClientMemUsageAndBucket,1,updateClientMemUsageAndBucket,int updateClientMemUsageAndBucket (client*),server.c,"int updateClientMemUsageAndBucket(client *c) {
    serverAssert(io_threads_op == IO_THREADS_OP_IDLE);
    int allow_eviction = clientEvictionAllowed(c);
    removeClientFromMemUsageBucket(c, allow_eviction);

    if (!allow_eviction) {
        return 0;
    }

    /* Update client memory usage. */
    updateClientMemoryUsage(c);

    /* Update the client in the mem usage buckets */
    clientMemUsageBucket *bucket = getMemUsageBucket(c->last_memory_usage);
    bucket->mem_usage_sum += c->last_memory_usage;
    if (bucket != c->mem_usage_bucket) {
        if (c->mem_usage_bucket)
            listDelNode(c->mem_usage_bucket->clients,
                        c->mem_usage_bucket_node);
        c->mem_usage_bucket = bucket;
        listAddNodeTail(bucket->clients, c);
        c->mem_usage_bucket_node = listLast(bucket->clients);
    }
    return 1;
}",928.0,952.0,1.0,4.0,25.0,26,10,23,4,9,19,4,5,2,7,,0,14,2,1,1,int
6322,369097,getExpansiveClientsInfo,1,getExpansiveClientsInfo,"void getExpansiveClientsInfo (size_t*,size_t*)",server.c,"void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
    size_t i = 0, o = 0;
    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {
        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];
        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];
    }
    *in_usage = i;
    *out_usage = o;
}",956.0,964.0,1.0,24.0,9.0,16,5,20,7,1,4,4,6,2,0,,0,4,4,2,2,void
6323,369157,clientsCron,1,clientsCron,void clientsCron (void),server.c,"void clientsCron(void) {
    /* Try to process at least numclients/server.hz of clients
     * per call. Since normally (if there are no big latency events) this
     * function is called server.hz times per second, in the average case we
     * process all the clients in 1 second. */
    int numclients = listLength(server.clients);
    int iterations = numclients/server.hz;
    mstime_t now = mstime();

    /* Process at least a few clients while we are at it, even if we need
     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract
     * of processing each client once per second. */
    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)
        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?
                     numclients : CLIENTS_CRON_MIN_ITERATIONS;


    int curr_peak_mem_usage_slot = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;
    /* Always zero the next sample, so that when we switch to that second, we'll
     * only register samples that are gr...",982.0,1045.0,1.0,21.0,64.0,35,12,39,10,1,30,14,15,10,9,,0,28,2,1,1,void
6324,369313,databasesCron,1,databasesCron,void databasesCron (void),server.c,"void databasesCron(void) {
    /* Expire keys by random sampling. Not required for slaves
     * as master will synthesize DELs for us. */
    if (server.active_expire_enabled) {
        if (iAmMaster()) {
            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
        } else {
            expireSlaveKeys();
        }
    }

    /* Defrag keys gradually. */
    activeDefragCycle();

    /* Perform hash tables rehashing if needed, but only if there are no
     * other processes saving the DB on disk. Otherwise rehashing is bad
     * as will cause a lot of copy-on-write of memory pages. */
    if (!hasActiveChildProcess()) {
        /* We use global counters so if we stop the computation at a given
         * DB we'll be able to start from the successive in the next
         * cron loop iteration. */
        static unsigned int resize_db = 0;
        static unsigned int rehash_db = 0;
        int dbs_per_call = CRON_DBS_PER_CALL;
        int j;

        /* Don't test more DBs than w...",1050.0,1101.0,1.0,30.0,52.0,18,7,21,6,1,16,10,18,8,6,,0,13,2,1,1,void
6325,369418,updateCachedTimeWithUs,1,updateCachedTimeWithUs,"void updateCachedTimeWithUs (int,long long)",server.c,"static inline void updateCachedTimeWithUs(int update_daylight_info, const long long ustime) {
    server.ustime = ustime;
    server.mstime = server.ustime / 1000;
    time_t unixtime = server.mstime / 1000;
    atomicSet(server.unixtime, unixtime);

    /* To get information about daylight saving time, we need to call
     * localtime_r and cache the result. However calling localtime_r in this
     * context is safe since we will never fork() while here, in the main
     * thread. The logging function will call a thread safe version of
     * localtime that has no locks. */
    if (update_daylight_info) {
        struct tm tm;
        time_t ut = server.unixtime;
        localtime_r(&ut,&tm);
        server.daylight_active = tm.tm_isdst;
    }
}",1103.0,1120.0,1.0,1.0,18.0,17,4,15,6,2,14,2,2,0,0,,0,14,4,2,2,void
6326,369473,updateCachedTime,1,updateCachedTime,void updateCachedTime (int),server.c,"void updateCachedTime(int update_daylight_info) {
    const long long us = ustime();
    updateCachedTimeWithUs(update_daylight_info, us);
}",1132.0,1135.0,1.0,1.0,4.0,1,1,3,2,4,2,1,1,0,2,,0,1,2,1,1,void
6327,369485,enterExecutionUnit,1,enterExecutionUnit,"void enterExecutionUnit (int,long long)",server.c,"void enterExecutionUnit(int update_cached_time, long long us) {
    if (server.execution_nesting++ == 0 && update_cached_time) {
        if (us == 0) {
            us = ustime();
        }
        updateCachedTimeWithUs(0, us);
        server.cmd_time_snapshot = server.mstime;
    }
}",1143.0,1151.0,1.0,1.0,9.0,9,5,7,3,3,8,3,4,2,2,,0,7,4,2,2,void
6328,369519,exitExecutionUnit,1,exitExecutionUnit,void exitExecutionUnit (void),server.c,"void exitExecutionUnit(void) {
    --server.execution_nesting;
}",1153.0,1155.0,1.0,1.0,3.0,2,2,1,1,4,2,1,1,0,0,,0,2,2,1,1,void
6329,369528,checkChildrenDone,1,checkChildrenDone,void checkChildrenDone (void),server.c,"void checkChildrenDone(void) {
    int statloc = 0;
    pid_t pid;

    if ((pid = waitpid(-1, &statloc, WNOHANG)) != 0) {
        int exitcode = WIFEXITED(statloc) ? WEXITSTATUS(statloc) : -1;
        int bysignal = 0;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);

        /* sigKillChildHandler catches the signal and calls exit(), but we
         * must make sure not to flag lastbgsave_status, etc incorrectly.
         * We could directly terminate the child process via SIGUSR1
         * without handling it */
        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {
            bysignal = SIGUSR1;
            exitcode = 1;
        }

        if (pid == -1) {
            serverLog(LL_WARNING,""waitpid() returned an error: %s. ""
                ""child_type: %s, child_pid = %d"",
                strerror(errno),
                strChildType(server.child_type),
                (int) server.child_pid);
        } else if (pid == server.child_pid) {
            if (server...",1157.0,1206.0,1.0,24.0,50.0,21,10,20,8,1,9,5,8,0,3,,0,7,2,1,1,void
6330,369726,cronUpdateMemoryStats,1,cronUpdateMemoryStats,void cronUpdateMemoryStats (void),server.c,"void cronUpdateMemoryStats(void) {
    /* Record the max memory used since the server was started. */
    if (zmalloc_used_memory() > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used_memory();

    run_with_period(100) {
        /* Sample the RSS and other metrics here since this is a relatively slow call.
         * We must sample the zmalloc_used at the same time we take the rss, otherwise
         * the frag ratio calculate may be off (ratio of two samples at different times) */
        server.cron_malloc_stats.process_rss = zmalloc_get_rss();
        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();
        /* Sampling the allocator info can be slow too.
         * The fragmentation ratio it'll show is potentially more accurate
         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc
         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */
        zmalloc_get_allocator_...",1209.0,1241.0,1.0,4.0,33.0,55,10,21,2,2,44,2,2,3,6,,0,43,2,1,1,void
6331,369865,serverCron,1,serverCron,"int serverCron (aeEventLoop*,long long,void*)",server.c,"int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    int j;
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* Software watchdog: deliver the SIGALRM that will reach the signal
     * handler if we don't return here fast enough. */
    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);

    server.hz = server.config_hz;
    /* Adapt the server.hz value to the number of configured clients. If we have
     * many clients, we want to call serverCron() with an higher frequency. */
    if (server.dynamic_hz) {
        while (listLength(server.clients) / server.hz >
               MAX_CLIENTS_PER_CLOCK_TICK)
        {
            server.hz *= 2;
            if (server.hz > CONFIG_MAX_HZ) {
                server.hz = CONFIG_MAX_HZ;
                break;
            }
        }
    }

    /* for debug purposes: skip actual cron work if pause_cron is on */
    if (server.pause_cron) return 1000/server.hz;

    mono...",1262.0,1529.0,1.0,4.0,268.0,287,25,160,22,0,229,27,40,88,43,,0,200,6,3,3,int
6332,371022,blockingOperationStarts,1,blockingOperationStarts,void blockingOperationStarts (void),server.c,"void blockingOperationStarts(void) {
    if(!server.blocking_op_nesting++){
        updateCachedTime(0);
        server.blocked_last_cron = server.mstime;
    }
}",1532.0,1537.0,1.0,1.0,6.0,6,4,3,1,2,7,2,2,2,1,,0,6,2,1,1,void
6333,371043,blockingOperationEnds,1,blockingOperationEnds,void blockingOperationEnds (void),server.c,"void blockingOperationEnds(void) {
    if(!(--server.blocking_op_nesting)){
        server.blocked_last_cron = 0;
    }
}",1539.0,1543.0,1.0,1.0,5.0,5,4,2,1,3,4,2,2,2,0,,0,4,2,1,1,void
6334,371060,whileBlockedCron,1,whileBlockedCron,void whileBlockedCron (void),server.c,"void whileBlockedCron(void) {
    /* Here we may want to perform some cron jobs (normally done server.hz times
     * per second). */

    /* Since this function depends on a call to blockingOperationStarts, let's
     * make sure it was done. */
    serverAssert(server.blocked_last_cron);

    /* In case we where called too soon, leave right away. This way one time
     * jobs after the loop below don't need an if. and we don't bother to start
     * latency monitor if this function is called too often. */
    if (server.blocked_last_cron >= server.mstime)
        return;

    mstime_t latency;
    latencyStartMonitor(latency);

    /* In some cases we may be called with big intervals, so we may need to do
     * extra work here. This is because some of the functions in serverCron rely
     * on the fact that it is performed every 10 ms or so. For instance, if
     * activeDefragCycle needs to utilize 25% cpu, it will utilize 2.5ms, so we
     * need to call it multiple times. */
 ...",1550.0,1601.0,1.0,4.0,52.0,41,15,30,3,1,46,6,7,15,8,,0,41,2,1,1,void
6335,371224,sendGetackToReplicas,1,sendGetackToReplicas,void sendGetackToReplicas (void),server.c,"static void sendGetackToReplicas(void) {
    robj *argv[3];
    argv[0] = shared.replconf;
    argv[1] = shared.getack;
    argv[2] = shared.special_asterick; /* Not used argument. */
    replicationFeedSlaves(server.slaves, -1, argv, 3);
}",1603.0,1609.0,1.0,1.0,7.0,11,4,8,3,2,9,1,1,0,1,,0,8,2,1,1,void
6336,371260,beforeSleep,1,beforeSleep,void beforeSleep (aeEventLoop*),server.c,"void beforeSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);

    size_t zmalloc_used = zmalloc_used_memory();
    if (zmalloc_used > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used;

    /* Just call a subset of vital functions in case we are re-entering
     * the event loop from processEventsWhileBlocked(). Note that in this
     * case we keep track of the number of events we are processing, since
     * processEventsWhileBlocked() wants to stop ASAP if there are no longer
     * events to handle. */
    if (ProcessingEventsWhileBlocked) {
        uint64_t processed = 0;
        processed += handleClientsWithPendingReadsUsingThreads();
        processed += connTypeProcessPendingData();
        if (server.aof_state == AOF_ON || server.aof_state == AOF_WAIT_REWRITE)
            flushAppendOnlyFile(0);
        processed += handleClientsWithPendingWrites();
        processed += freeClientsInAsyncFreeQueue();
        server.events_processed_while_b...",1627.0,1782.0,1.0,4.0,156.0,88,19,64,17,0,99,15,17,35,38,,0,73,2,1,1,void
6337,371587,afterSleep,1,afterSleep,void afterSleep (aeEventLoop*),server.c,"void afterSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);
    /********************* WARNING ********************
     * Do NOT add anything above moduleAcquireGIL !!! *
     ***************************** ********************/
    if (!ProcessingEventsWhileBlocked) {
        /* Acquire the modules GIL so that their threads won't touch anything. */
        if (moduleCount()) {
            mstime_t latency;
            latencyStartMonitor(latency);

            moduleAcquireGIL();
            moduleFireServerEvent(REDISMODULE_EVENT_EVENTLOOP,
                                  REDISMODULE_SUBEVENT_EVENTLOOP_AFTER_SLEEP,
                                  NULL);
            latencyEndMonitor(latency);
            latencyAddSampleIfNeeded(""module-acquire-GIL"",latency);
        }
        /* Set the eventloop start time. */
        server.el_start = getMonotonicUs();
        /* Set the eventloop command count at start. */
        server.el_cmd_cnt_start = server.stat_numcomman...",1787.0,1820.0,1.0,4.0,34.0,21,7,23,5,0,28,4,5,3,8,,0,24,2,1,1,void
6338,372664,initServerClientMemUsageBuckets,1,initServerClientMemUsageBuckets,void initServerClientMemUsageBuckets (void),server.c,"void initServerClientMemUsageBuckets(void) {
    if (server.client_mem_usage_buckets)
        return;
    server.client_mem_usage_buckets = zmalloc(sizeof(clientMemUsageBucket)*CLIENT_MEM_USAGE_BUCKETS);
    for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++) {
        server.client_mem_usage_buckets[j].mem_usage_sum = 0;
        server.client_mem_usage_buckets[j].clients = listCreate();
    }
}",1990.0,1998.0,1.0,75.0,9.0,19,8,9,3,2,10,3,3,2,2,,0,10,2,1,1,void
6339,372726,freeServerClientMemUsageBuckets,1,freeServerClientMemUsageBuckets,void freeServerClientMemUsageBuckets (void),server.c,"void freeServerClientMemUsageBuckets(void) {
    if (!server.client_mem_usage_buckets)
        return;
    for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++)
        listRelease(server.client_mem_usage_buckets[j].clients);
    zfree(server.client_mem_usage_buckets);
    server.client_mem_usage_buckets = NULL;
}",2000.0,2007.0,1.0,24.0,8.0,9,6,6,3,1,7,3,3,2,1,,0,6,2,1,1,void
6340,372772,initServerConfig,1,initServerConfig,void initServerConfig (void),server.c,"void initServerConfig(void) {
    int j;
    char *default_bindaddr[CONFIG_DEFAULT_BINDADDR_COUNT] = CONFIG_DEFAULT_BINDADDR;

    initConfigValues();
    updateCachedTime(1);
    server.cmd_time_snapshot = server.mstime;
    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);
    server.runid[CONFIG_RUN_ID_SIZE] = '\0';
    changeReplicationId();
    clearReplicationId2();
    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get
                                      updated later after loading the config.
                                      This value may be used before the server
                                      is initialized. */
    server.timezone = getTimeZone(); /* Initialized by tzset(). */
    server.configfile = NULL;
    server.executable = NULL;
    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
    server.bindaddr_count = CONFIG_DEFAULT_BINDADDR_COUNT;
    for (j = 0; j < CONFIG_DEFAULT_BINDADDR_COUNT; j++)
        server.bindaddr[j] = zstr...",2009.0,2130.0,1.0,27.0,122.0,183,12,111,15,0,181,4,4,0,16,,0,171,2,1,1,void
6341,373314,restartServer,1,restartServer,"int restartServer (int,mstime_t)",server.c,"int restartServer(int flags, mstime_t delay) {
    int j;

    /* Check if we still have accesses to the executable that started this
     * server instance. */
    if (access(server.executable,X_OK) == -1) {
        serverLog(LL_WARNING,""Can't restart: this process has no ""
                             ""permissions to execute %s"", server.executable);
        return C_ERR;
    }

    /* Config rewriting. */
    if (flags & RESTART_SERVER_CONFIG_REWRITE &&
        server.configfile &&
        rewriteConfig(server.configfile, 0) == -1)
    {
        serverLog(LL_WARNING,""Can't restart: configuration rewrite process ""
                             ""failed: %s"", strerror(errno));
        return C_ERR;
    }

    /* Perform a proper shutdown. We don't wait for lagging replicas though. */
    if (flags & RESTART_SERVER_GRACEFULLY &&
        prepareForShutdown(SHUTDOWN_NOW) != C_OK)
    {
        serverLog(LL_WARNING,""Can't restart: error preparing for shutdown"");
        return C_ERR;
    ...",2149.0,2196.0,1.0,8.0,48.0,45,13,25,8,0,34,7,8,10,7,,0,30,4,2,2,int
6342,373510,setOOMScoreAdj,1,setOOMScoreAdj,int setOOMScoreAdj (int),server.c,"int setOOMScoreAdj(int process_class) {
    if (process_class == -1)
        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);

    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);

#ifdef HAVE_PROC_OOM_SCORE_ADJ
    /* The following statics are used to indicate Redis has changed the process's oom score.
     * And to save the original score so we can restore it later if needed.
     * We need this so when we disabled oom-score-adj (also during configuration rollback
     * when another configuration parameter was invalid and causes a rollback after
     * applying a new oom-score) we can return to the oom-score value from before our
     * adjustments. */
    static int oom_score_adjusted_by_redis = 0;
    static int oom_score_adj_base = 0;

    int fd;
    int val;
    char buf[64];

    if (server.oom_score_adj != OOM_SCORE_ADJ_NO) {
        if (!oom_score_adjusted_by_redis) {
            oom_score_adjusted_by_redis = 1;
          ...",2205.0,2267.0,1.0,45.0,63.0,13,11,5,2,4,3,2,2,0,1,,0,2,2,1,1,int
6343,373558,adjustOpenFilesLimit,1,adjustOpenFilesLimit,void adjustOpenFilesLimit (void),server.c,"void adjustOpenFilesLimit(void) {
    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;
    struct rlimit limit;

    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {
        serverLog(LL_WARNING,""Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly."",
            strerror(errno));
        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;
    } else {
        rlim_t oldlimit = limit.rlim_cur;

        /* Set the max number of files if the current limit is not enough
         * for our needs. */
        if (oldlimit < maxfiles) {
            rlim_t bestlimit;
            int setrlimit_error = 0;

            /* Try to set the file limit to match 'maxfiles' or at least
             * to the higher value supported less than maxfiles. */
            bestlimit = maxfiles;
            while(bestlimit > oldlimit) {
                rlim_t decr_step = 16;

                limit.rlim_cur = bestlimit;
                limit.r...",2277.0,2353.0,1.0,40.0,77.0,12,9,7,5,2,7,2,2,0,1,,0,6,2,1,1,void
6344,373833,checkTcpBacklogSettings,1,checkTcpBacklogSettings,void checkTcpBacklogSettings (void),server.c,"void checkTcpBacklogSettings(void) {
#if defined(HAVE_PROC_SOMAXCONN)
    FILE *fp = fopen(""/proc/sys/net/core/somaxconn"",""r"");
    char buf[1024];
    if (!fp) return;
    if (fgets(buf,sizeof(buf),fp) != NULL) {
        int somaxconn = atoi(buf);
        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {
            serverLog(LL_WARNING,""WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d."", server.tcp_backlog, somaxconn);
        }
    }
    fclose(fp);
#elif defined(HAVE_SYSCTL_KIPC_SOMAXCONN)
    int somaxconn, mib[3];
    size_t len = sizeof(int);

    mib[0] = CTL_KERN;
    mib[1] = KERN_IPC;
    mib[2] = KIPC_SOMAXCONN;

    if (sysctl(mib, 3, &somaxconn, &len, NULL, 0) == 0) {
        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {
            serverLog(LL_WARNING,""WARNING: The TCP backlog setting of %d cannot be enforced because kern.ipc.somaxconn is set to the lower value of %d."", server...",2357.0,2399.0,1.0,1.0,43.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6345,373838,closeListener,1,closeListener,void closeListener (connListener*),server.c,"void closeListener(connListener *sfd) {
    int j;

    for (j = 0; j < sfd->count; j++) {
        if (sfd->fd[j] == -1) continue;

        aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);
        close(sfd->fd[j]);
    }

    sfd->count = 0;
}",2401.0,2412.0,1.0,49.0,12.0,14,7,11,3,4,8,4,4,2,1,,0,7,2,1,1,void
6346,373891,createSocketAcceptHandler,1,createSocketAcceptHandler,"int createSocketAcceptHandler (connListener*,aeFileProc*)",server.c,"int createSocketAcceptHandler(connListener *sfd, aeFileProc *accept_handler) {
    int j;

    for (j = 0; j < sfd->count; j++) {
        if (aeCreateFileEvent(server.el, sfd->fd[j], AE_READABLE, accept_handler,sfd) == AE_ERR) {
            /* Rollback */
            for (j = j-1; j >= 0; j--) aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);
            return C_ERR;
        }
    }
    return C_OK;
}",2416.0,2427.0,1.0,53.0,12.0,12,9,11,4,3,5,4,7,5,1,,0,5,4,2,2,int
6347,373965,listenToPort,1,listenToPort,int listenToPort (connListener*),server.c,"int listenToPort(connListener *sfd) {
    int j;
    int port = sfd->port;
    char **bindaddr = sfd->bindaddr;

    /* If we have no bind address, we don't listen on a TCP socket */
    if (sfd->bindaddr_count == 0) return C_OK;

    for (j = 0; j < sfd->bindaddr_count; j++) {
        char* addr = bindaddr[j];
        int optional = *addr == '-';
        if (optional) addr++;
        if (strchr(addr,':')) {
            /* Bind IPv6 address. */
            sfd->fd[sfd->count] = anetTcp6Server(server.neterr,port,addr,server.tcp_backlog);
        } else {
            /* Bind IPv4 address. */
            sfd->fd[sfd->count] = anetTcpServer(server.neterr,port,addr,server.tcp_backlog);
        }
        if (sfd->fd[sfd->count] == ANET_ERR) {
            int net_errno = errno;
            serverLog(LL_WARNING,
                ""Warning: Could not create server TCP listening socket %s:%d: %s"",
                addr, port, server.neterr);
            if (net_errno == EADDRNOTAVAIL && optional...",2448.0,2489.0,1.0,41.0,42.0,57,13,55,16,1,33,11,17,6,6,,0,28,2,1,1,int
6348,374188,resetServerStats,1,resetServerStats,void resetServerStats (void),server.c,"void resetServerStats(void) {
    int j;

    server.stat_numcommands = 0;
    server.stat_numconnections = 0;
    server.stat_expiredkeys = 0;
    server.stat_expired_stale_perc = 0;
    server.stat_expired_time_cap_reached_count = 0;
    server.stat_expire_cycle_time_used = 0;
    server.stat_evictedkeys = 0;
    server.stat_evictedclients = 0;
    server.stat_total_eviction_exceeded_time = 0;
    server.stat_last_eviction_exceeded_time = 0;
    server.stat_keyspace_misses = 0;
    server.stat_keyspace_hits = 0;
    server.stat_active_defrag_hits = 0;
    server.stat_active_defrag_misses = 0;
    server.stat_active_defrag_key_hits = 0;
    server.stat_active_defrag_key_misses = 0;
    server.stat_active_defrag_scanned = 0;
    server.stat_total_active_defrag_time = 0;
    server.stat_last_active_defrag_time = 0;
    server.stat_fork_time = 0;
    server.stat_fork_rate = 0;
    server.stat_total_forks = 0;
    server.stat_rejected_conn = 0;
    server.stat_sync_full = 0;
    server...",2494.0,2550.0,1.0,20.0,57.0,106,6,59,4,2,96,2,2,0,1,,0,95,2,1,1,void
6349,374481,makeThreadKillable,1,makeThreadKillable,void makeThreadKillable (void),server.c,"void makeThreadKillable(void) {
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
}",2555.0,2558.0,1.0,1.0,4.0,0,0,4,3,2,0,1,1,0,0,,0,0,2,1,1,void
6350,374492,initServer,1,initServer,void initServer (void),server.c,"void initServer(void) {
    int j;

    signal(SIGHUP, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);
    setupSignalHandlers();
    makeThreadKillable();

    if (server.syslog_enabled) {
        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
            server.syslog_facility);
    }

    /* Initialization after setting defaults from the config system. */
    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;
    server.fsynced_reploff = server.aof_enabled ? 0 : -1;
    server.hz = server.config_hz;
    server.pid = getpid();
    server.in_fork_child = CHILD_TYPE_NONE;
    server.main_thread_id = pthread_self();
    server.current_client = NULL;
    server.errors = raxNew();
    server.execution_nesting = 0;
    server.clients = listCreate();
    server.clients_index = raxNew();
    server.clients_to_close = listCreate();
    server.slaves = listCreate();
    server.monitors = listCreate();
    server.clients_pending_write = listCreate();
    server.clients_pendin...",2560.0,2753.0,1.0,44.0,194.0,333,19,187,19,0,329,10,10,22,54,,0,307,2,1,1,void
6351,375458,initListeners,1,initListeners,void initListeners (void),server.c,"void initListeners(void) {
    /* Setup listeners from server config for TCP/TLS/Unix */
    int conn_index;
    connListener *listener;
    if (server.port != 0) {
        conn_index = connectionIndexByType(CONN_TYPE_SOCKET);
        if (conn_index < 0)
            serverPanic(""Failed finding connection listener of %s"", CONN_TYPE_SOCKET);
        listener = &server.listeners[conn_index];
        listener->bindaddr = server.bindaddr;
        listener->bindaddr_count = server.bindaddr_count;
        listener->port = server.port;
        listener->ct = connectionByType(CONN_TYPE_SOCKET);
    }

    if (server.tls_port || server.tls_replication || server.tls_cluster) {
        ConnectionType *ct_tls = connectionTypeTls();
        if (!ct_tls) {
            serverLog(LL_WARNING, ""Failed finding TLS support."");
            exit(1);
        }
        if (connTypeConfigure(ct_tls, &server.tls_ctx_config, 1) == C_ERR) {
            serverLog(LL_WARNING, ""Failed to configure TLS. Check logs ...",2755.0,2825.0,1.0,43.0,71.0,106,14,69,7,0,83,16,23,20,19,,0,75,2,1,1,void
6352,375862,InitServerLast,1,InitServerLast,void InitServerLast (void),server.c,"void InitServerLast(void) {
    bioInit();
    initThreadedIO();
    set_jemalloc_bg_thread(server.jemalloc_bg_thread);
    server.initial_memory_usage = zmalloc_used_memory();
}",2832.0,2837.0,1.0,1.0,6.0,3,2,2,1,0,8,1,1,0,4,,0,5,2,1,1,void
6353,375878,populateCommandLegacyRangeSpec,1,populateCommandLegacyRangeSpec,void populateCommandLegacyRangeSpec (redisCommand*),server.c,"void populateCommandLegacyRangeSpec(struct redisCommand *c) {
    memset(&c->legacy_range_key_spec, 0, sizeof(c->legacy_range_key_spec));

    /* Set the movablekeys flag if we have a GETKEYS flag for modules.
     * Note that for native redis commands, we always have keyspecs,
     * with enough information to rely on for movablekeys. */
    if (c->flags & CMD_MODULE_GETKEYS)
        c->flags |= CMD_MOVABLE_KEYS;

    /* no key-specs, no keys, exit. */
    if (c->key_specs_num == 0) {
        return;
    }

    if (c->key_specs_num == 1 &&
        c->key_specs[0].begin_search_type == KSPEC_BS_INDEX &&
        c->key_specs[0].find_keys_type == KSPEC_FK_RANGE)
    {
        /* Quick win, exactly one range spec. */
        c->legacy_range_key_spec = c->key_specs[0];
        /* If it has the incomplete flag, set the movablekeys flag on the command. */
        if (c->key_specs[0].flags & CMD_KEY_INCOMPLETE)
            c->flags |= CMD_MOVABLE_KEYS;
        return;
    }

    int firstke...",2869.0,2942.0,1.0,19.0,74.0,158,21,82,9,2,35,13,16,12,2,,0,33,2,1,1,void
6354,376319,catSubCommandFullname,1,catSubCommandFullname,"sds catSubCommandFullname (char*,char*)",server.c,"sds catSubCommandFullname(const char *parent_name, const char *sub_name) {
    return sdscatfmt(sdsempty(), ""%s|%s"", parent_name, sub_name);
}",2944.0,2946.0,1.0,1.0,3.0,0,0,2,2,2,2,1,1,0,2,,0,1,4,2,2,sds
6355,376331,commandAddSubcommand,1,commandAddSubcommand,"void commandAddSubcommand (redisCommand*,redisCommand*,char*)",server.c,"void commandAddSubcommand(struct redisCommand *parent, struct redisCommand *subcommand, const char *declared_name) {
    if (!parent->subcommands_dict)
        parent->subcommands_dict = dictCreate(&commandTableDictType);

    subcommand->parent = parent; /* Assign the parent command */
    subcommand->id = ACLGetCommandID(subcommand->fullname); /* Assign the ID used for ACL. */

    serverAssert(dictAdd(parent->subcommands_dict, sdsnew(declared_name), subcommand) == DICT_OK);
}",2948.0,2956.0,1.0,4.0,9.0,16,9,10,4,2,12,2,2,1,5,,0,10,6,3,3,void
6356,376386,setImplicitACLCategories,1,setImplicitACLCategories,void setImplicitACLCategories (redisCommand*),server.c,"void setImplicitACLCategories(struct redisCommand *c) {
    if (c->flags & CMD_WRITE)
        c->acl_categories |= ACL_CATEGORY_WRITE;
    /* Exclude scripting commands from the RO category. */
    if (c->flags & CMD_READONLY && !(c->acl_categories & ACL_CATEGORY_SCRIPTING))
        c->acl_categories |= ACL_CATEGORY_READ;
    if (c->flags & CMD_ADMIN)
        c->acl_categories |= ACL_CATEGORY_ADMIN|ACL_CATEGORY_DANGEROUS;
    if (c->flags & CMD_PUBSUB)
        c->acl_categories |= ACL_CATEGORY_PUBSUB;
    if (c->flags & CMD_FAST)
        c->acl_categories |= ACL_CATEGORY_FAST;
    if (c->flags & CMD_BLOCKING)
        c->acl_categories |= ACL_CATEGORY_BLOCKING;

    /* If it's not @fast is @slow in this binary world. */
    if (!(c->acl_categories & ACL_CATEGORY_FAST))
        c->acl_categories |= ACL_CATEGORY_SLOW;
}",2960.0,2978.0,1.0,19.0,19.0,43,6,15,1,1,15,8,8,8,0,,0,15,2,1,1,void
6357,376549,populateCommandStructure,1,populateCommandStructure,int populateCommandStructure (redisCommand*),server.c,"int populateCommandStructure(struct redisCommand *c) {
    /* If the command marks with CMD_SENTINEL, it exists in sentinel. */
    if (!(c->flags & CMD_SENTINEL) && server.sentinel_mode)
        return C_ERR;

    /* If the command marks with CMD_ONLY_SENTINEL, it only exists in sentinel. */
    if (c->flags & CMD_ONLY_SENTINEL && !server.sentinel_mode)
        return C_ERR;

    /* Translate the command string flags description into an actual
     * set of flags. */
    setImplicitACLCategories(c);

    /* We start with an unallocated histogram and only allocate memory when a command
     * has been issued for the first time */
    c->latency_histogram = NULL;

    /* Handle the legacy range spec and the ""movablekeys"" flag (must be done after populating all key specs). */
    populateCommandLegacyRangeSpec(c);

    /* Assign the ID used for ACL. */
    c->id = ACLGetCommandID(c->fullname);

    /* Handle subcommands */
    if (c->subcommands) {
        for (int j = 0; c->subcomman...",2984.0,3021.0,1.0,21.0,38.0,34,11,24,5,1,21,7,9,8,5,,0,18,2,1,1,int
6358,376676,populateCommandTable,1,populateCommandTable,void populateCommandTable (void),server.c,"void populateCommandTable(void) {
    int j;
    struct redisCommand *c;

    for (j = 0;; j++) {
        c = redisCommandTable + j;
        if (c->declared_name == NULL)
            break;

        int retval1, retval2;

        c->fullname = sdsnew(c->declared_name);
        if (populateCommandStructure(c) == C_ERR)
            continue;

        retval1 = dictAdd(server.commands, sdsdup(c->fullname), c);
        /* Populate an additional dictionary that will be unaffected
         * by rename-command statements in redis.conf. */
        retval2 = dictAdd(server.orig_commands, sdsdup(c->fullname), c);
        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
    }
}",3027.0,3048.0,1.0,43.0,22.0,24,12,20,7,1,17,6,6,2,7,,0,16,2,1,1,void
6359,376766,resetCommandTableStats,1,resetCommandTableStats,void resetCommandTableStats (dict*),server.c,"void resetCommandTableStats(dict* commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;

    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        c = (struct redisCommand *) dictGetVal(de);
        c->microseconds = 0;
        c->calls = 0;
        c->rejected_calls = 0;
        c->failed_calls = 0;
        if(c->latency_histogram) {
            hdr_close(c->latency_histogram);
            c->latency_histogram = NULL;
        }
        if (c->subcommands_dict)
            resetCommandTableStats(c->subcommands_dict);
    }
    dictReleaseIterator(di);
}",3050.0,3070.0,1.0,1.0,21.0,19,4,18,5,1,13,4,6,3,4,,0,12,2,1,1,void
6360,376837,resetErrorTableStats,1,resetErrorTableStats,void resetErrorTableStats (void),server.c,"void resetErrorTableStats(void) {
    raxFreeWithCallback(server.errors, zfree);
    server.errors = raxNew();
}",3072.0,3075.0,1.0,1.0,4.0,3,2,3,2,1,6,1,1,0,2,,0,5,2,1,1,void
6361,376852,redisOpArrayAppend,1,redisOpArrayAppend,"int redisOpArrayAppend (redisOpArray*,int,robj**,int,int)",server.c,"int redisOpArrayAppend(redisOpArray *oa, int dbid, robj **argv, int argc, int target) {
    redisOp *op;
    int prev_capacity = oa->capacity;

    if (oa->numops == 0) {
        oa->capacity = 16;
    } else if (oa->numops >= oa->capacity) {
        oa->capacity *= 2;
    }

    if (prev_capacity != oa->capacity)
        oa->ops = zrealloc(oa->ops,sizeof(redisOp)*oa->capacity);
    op = oa->ops+oa->numops;
    op->dbid = dbid;
    op->argv = argv;
    op->argc = argc;
    op->target = target;
    oa->numops++;
    return oa->numops;
}",3079.0,3098.0,1.0,1.0,20.0,29,8,23,8,1,16,3,3,2,1,,0,16,10,5,5,int
6362,376954,redisOpArrayFree,1,redisOpArrayFree,void redisOpArrayFree (redisOpArray*),server.c,"void redisOpArrayFree(redisOpArray *oa) {
    while(oa->numops) {
        int j;
        redisOp *op;

        oa->numops--;
        op = oa->ops+oa->numops;
        for (j = 0; j < op->argc; j++)
            decrRefCount(op->argv[j]);
        zfree(op->argv);
    }
    /* no need to free the actual op array, we reuse the memory for future commands */
    serverAssert(!oa->numops);
}",3100.0,3113.0,1.0,4.0,14.0,19,10,11,3,1,10,3,4,2,2,,0,8,2,1,1,void
6363,377022,isContainerCommandBySds,1,isContainerCommandBySds,int isContainerCommandBySds (sds),server.c,"int isContainerCommandBySds(sds s) {
    struct redisCommand *base_cmd = dictFetchValue(server.commands, s);
    int has_subcommands = base_cmd && base_cmd->subcommands_dict;
    return has_subcommands;
}",3117.0,3121.0,1.0,1.0,5.0,5,4,7,4,1,4,1,1,0,1,,0,4,2,1,1,int
6364,377045,lookupSubcommand,1,lookupSubcommand,"struct redisCommand lookupSubcommand (redisCommand*,sds)",server.c,"struct redisCommand *lookupSubcommand(struct redisCommand *container, sds sub_name) {
    return dictFetchValue(container->subcommands_dict, sub_name);
}",3123.0,3125.0,1.0,1.0,3.0,1,1,2,2,1,2,1,1,0,1,,0,1,4,2,2,struct redisCommand
6365,377057,lookupCommandLogic,1,lookupCommandLogic,"struct redisCommand lookupCommandLogic (dict*,robj**,int,int)",server.c,"struct redisCommand *lookupCommandLogic(dict *commands, robj **argv, int argc, int strict) {
    struct redisCommand *base_cmd = dictFetchValue(commands, argv[0]->ptr);
    int has_subcommands = base_cmd && base_cmd->subcommands_dict;
    if (argc == 1 || !has_subcommands) {
        if (strict && argc != 1)
            return NULL;
        /* Note: It is possible that base_cmd->proc==NULL (e.g. CONFIG) */
        return base_cmd;
    } else { /* argc > 1 && has_subcommands */
        if (strict && argc != 2)
            return NULL;
        /* Note: Currently we support just one level of subcommands */
        return lookupSubcommand(base_cmd, argv[1]->ptr);
    }
}",3135.0,3149.0,1.0,1.0,15.0,11,8,12,7,4,2,3,4,0,1,,0,2,8,4,4,struct redisCommand
6366,377121,lookupCommand,1,lookupCommand,"struct redisCommand lookupCommand (robj**,int)",server.c,"struct redisCommand *lookupCommand(robj **argv, int argc) {
    return lookupCommandLogic(server.commands,argv,argc,0);
}",3151.0,3153.0,1.0,1.0,3.0,1,1,3,3,8,3,1,1,0,1,,0,2,4,2,2,struct redisCommand
6367,377135,lookupCommandBySdsLogic,1,lookupCommandBySdsLogic,"struct redisCommand lookupCommandBySdsLogic (dict*,sds)",server.c,"struct redisCommand *lookupCommandBySdsLogic(dict *commands, sds s) {
    int argc, j;
    sds *strings = sdssplitlen(s,sdslen(s),""|"",1,&argc);
    if (strings == NULL)
        return NULL;
    if (argc < 1 || argc > 2) {
        /* Currently we support just one level of subcommands */
        sdsfreesplitres(strings,argc);
        return NULL;
    }

    serverAssert(argc > 0); /* Avoid warning `-Wmaybe-uninitialized` in lookupCommandLogic() */
    robj objects[argc];
    robj *argv[argc];
    for (j = 0; j < argc; j++) {
        initStaticStringObject(objects[j],strings[j]);
        argv[j] = &objects[j];
    }

    struct redisCommand *cmd = lookupCommandLogic(commands,argv,argc,1);
    sdsfreesplitres(strings,argc);
    return cmd;
}",3155.0,3177.0,1.0,4.0,23.0,34,13,42,10,3,6,4,4,0,6,,0,3,4,2,2,struct redisCommand
6368,377268,lookupCommandBySds,1,lookupCommandBySds,struct redisCommand lookupCommandBySds (sds),server.c,"struct redisCommand *lookupCommandBySds(sds s) {
    return lookupCommandBySdsLogic(server.commands,s);
}",3179.0,3181.0,1.0,1.0,3.0,1,1,2,2,1,3,1,1,0,1,,0,2,2,1,1,struct redisCommand
6369,377279,lookupCommandByCStringLogic,1,lookupCommandByCStringLogic,"struct redisCommand lookupCommandByCStringLogic (dict*,char*)",server.c,"struct redisCommand *lookupCommandByCStringLogic(dict *commands, const char *s) {
    struct redisCommand *cmd;
    sds name = sdsnew(s);

    cmd = lookupCommandBySdsLogic(commands,name);
    sdsfree(name);
    return cmd;
}",3183.0,3190.0,1.0,1.0,8.0,2,1,7,4,1,3,1,1,0,3,,0,2,4,2,2,struct redisCommand
6370,377300,lookupCommandByCString,1,lookupCommandByCString,struct redisCommand lookupCommandByCString (char*),server.c,"struct redisCommand *lookupCommandByCString(const char *s) {
    return lookupCommandByCStringLogic(server.commands,s);
}",3192.0,3194.0,1.0,1.0,3.0,1,1,2,2,4,3,1,1,0,1,,0,2,2,1,1,struct redisCommand
6371,377311,lookupCommandOrOriginal,1,lookupCommandOrOriginal,"struct redisCommand lookupCommandOrOriginal (robj**,int)",server.c,"struct redisCommand *lookupCommandOrOriginal(robj **argv ,int argc) {
    struct redisCommand *cmd = lookupCommandLogic(server.commands, argv, argc, 0);

    if (!cmd) cmd = lookupCommandLogic(server.orig_commands, argv, argc, 0);
    return cmd;
}",3203.0,3208.0,1.0,1.0,6.0,5,3,10,4,2,6,2,2,0,2,,0,6,4,2,2,struct redisCommand
6372,377342,mustObeyClient,1,mustObeyClient,int mustObeyClient (client*),server.c,"int mustObeyClient(client *c) {
    return c->id == CLIENT_ID_AOF || c->flags & CLIENT_MASTER;
}",3211.0,3213.0,1.0,20.0,3.0,6,5,3,2,12,2,1,1,0,0,,0,2,2,1,1,int
6373,377365,shouldPropagate,1,shouldPropagate,int shouldPropagate (int),server.c,"static int shouldPropagate(int target) {
    if (!server.replication_allowed || target == PROPAGATE_NONE || server.loading)
        return 0;

    if (target & PROPAGATE_AOF) {
        if (server.aof_state != AOF_OFF)
            return 1;
    }
    if (target & PROPAGATE_REPL) {
        if (server.masterhost == NULL && (server.repl_backlog || listLength(server.slaves) != 0))
            return 1;
    }

    return 0;
}",3215.0,3229.0,1.0,49.0,15.0,19,8,11,3,2,14,6,8,14,0,,0,14,2,1,1,int
6374,377441,propagateNow,1,propagateNow,"void propagateNow (int,robj**,int,int)",server.c,"static void propagateNow(int dbid, robj **argv, int argc, int target) {
    if (!shouldPropagate(target))
        return;

    /* This needs to be unreachable since the dataset should be fixed during
     * replica pause (otherwise data may be lost during a failover) */
    serverAssert(!(isPausedActions(PAUSE_ACTION_REPLICA) &&
                   (!server.client_pause_in_transaction)));

    if (server.aof_state != AOF_OFF && target & PROPAGATE_AOF)
        feedAppendOnlyFile(dbid,argv,argc);
    if (target & PROPAGATE_REPL)
        replicationFeedSlaves(server.slaves,dbid,argv,argc);
}",3246.0,3259.0,1.0,4.0,14.0,16,10,12,5,3,11,4,4,3,5,,0,7,8,4,4,void
6375,377511,alsoPropagate,1,alsoPropagate,"void alsoPropagate (int,robj**,int,int)",server.c,"void alsoPropagate(int dbid, robj **argv, int argc, int target) {
    robj **argvcopy;
    int j;

    if (!shouldPropagate(target))
        return;

    argvcopy = zmalloc(sizeof(robj*)*argc);
    for (j = 0; j < argc; j++) {
        argvcopy[j] = argv[j];
        incrRefCount(argv[j]);
    }
    redisOpArrayAppend(&server.also_propagate,dbid,argvcopy,argc,target);
}",3272.0,3285.0,1.0,1.0,14.0,12,8,18,8,7,6,3,3,1,4,,0,4,8,4,4,void
6376,377565,forceCommandPropagation,1,forceCommandPropagation,"void forceCommandPropagation (client*,int)",server.c,"void forceCommandPropagation(client *c, int flags) {
    serverAssert(c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE));
    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
}",3290.0,3294.0,1.0,4.0,5.0,16,8,5,2,4,4,3,3,0,1,,0,3,4,2,2,void
6377,377629,preventCommandPropagation,1,preventCommandPropagation,void preventCommandPropagation (client*),server.c,"void preventCommandPropagation(client *c) {
    c->flags |= CLIENT_PREVENT_PROP;
}",3299.0,3301.0,1.0,16.0,3.0,4,3,1,1,2,1,1,1,0,0,,0,1,2,1,1,void
6378,377647,preventCommandAOF,1,preventCommandAOF,void preventCommandAOF (client*),server.c,"void preventCommandAOF(client *c) {
    c->flags |= CLIENT_PREVENT_AOF_PROP;
}",3304.0,3306.0,1.0,16.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
6379,377661,preventCommandReplication,1,preventCommandReplication,void preventCommandReplication (client*),server.c,"void preventCommandReplication(client *c) {
    c->flags |= CLIENT_PREVENT_REPL_PROP;
}",3309.0,3311.0,1.0,16.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
6380,377675,slowlogPushCurrentCommand,1,slowlogPushCurrentCommand,"void slowlogPushCurrentCommand (client*,redisCommand*,ustime_t)",server.c,"void slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration) {
    /* Some commands may contain sensitive data that should not be available in the slowlog. */
    if (cmd->flags & CMD_SKIP_SLOWLOG)
        return;

    /* If command argument vector was rewritten, use the original
     * arguments. */
    robj **argv = c->original_argv ? c->original_argv : c->argv;
    int argc = c->original_argv ? c->original_argc : c->argc;
    slowlogPushEntryIfNeeded(c,argv,argc,duration);
}",3314.0,3324.0,1.0,21.0,11.0,13,5,13,5,1,8,2,2,1,1,,0,7,6,3,3,void
6381,377725,updateCommandLatencyHistogram,1,updateCommandLatencyHistogram,"void updateCommandLatencyHistogram (hdr_histogram**,int64_t)",server.c,"void updateCommandLatencyHistogram(struct hdr_histogram **latency_histogram, int64_t duration_hist){
    if (duration_hist < LATENCY_HISTOGRAM_MIN_VALUE)
        duration_hist=LATENCY_HISTOGRAM_MIN_VALUE;
    if (duration_hist>LATENCY_HISTOGRAM_MAX_VALUE)
        duration_hist=LATENCY_HISTOGRAM_MAX_VALUE;
    if (*latency_histogram==NULL)
        hdr_init(LATENCY_HISTOGRAM_MIN_VALUE,LATENCY_HISTOGRAM_MAX_VALUE,LATENCY_HISTOGRAM_PRECISION,latency_histogram);
    hdr_record_value(*latency_histogram,duration_hist);
}",3329.0,3337.0,1.0,24.0,9.0,7,5,9,3,1,0,4,4,0,0,,0,0,4,2,2,void
6382,377776,propagatePendingCommands,1,propagatePendingCommands,void propagatePendingCommands (void),server.c,"static void propagatePendingCommands(void) {
    if (server.also_propagate.numops == 0)
        return;

    int j;
    redisOp *rop;

    /* If we got here it means we have finished an execution-unit.
     * If that unit has caused propagation of multiple commands, they
     * should be propagated as a transaction */
    int transaction = server.also_propagate.numops > 1;

    /* In case a command that may modify random keys was run *directly*
     * (i.e. not from within a script, MULTI/EXEC, RM_Call, etc.) we want
     * to avoid using a transaction (much like active-expire) */
    if (server.current_client &&
        server.current_client->cmd &&
        server.current_client->cmd->flags & CMD_TOUCHES_ARBITRARY_KEYS)
    {
        transaction = 0;
    }

    if (transaction) {
        /* We use dbid=-1 to indicate we do not want to replicate SELECT.
         * It'll be inserted together with the next command (inside the MULTI) */
        propagateNow(-1,&shared.multi,1,PROPAGATE...",3342.0,3382.0,1.0,44.0,41.0,47,17,24,5,1,31,6,6,10,5,,0,26,2,1,1,void
6383,377929,postExecutionUnitOperations,1,postExecutionUnitOperations,void postExecutionUnitOperations (void),server.c,"void postExecutionUnitOperations(void) {
    if (server.execution_nesting)
        return;

    firePostExecutionUnitJobs();

    /* If we are at the top-most call() and not inside a an active module
     * context (e.g. within a module timer) we can propagate what we accumulated. */
    propagatePendingCommands();

    /* Module subsystem post-execution-unit logic */
    modulePostExecutionUnitOperations();
}",3398.0,3410.0,1.0,1.0,13.0,1,1,1,1,6,5,2,2,2,3,,0,2,2,1,1,void
6384,377943,incrCommandStatsOnError,1,incrCommandStatsOnError,"int incrCommandStatsOnError (redisCommand*,int)",server.c,"int incrCommandStatsOnError(struct redisCommand *cmd, int flags) {
    /* hold the prev error count captured on the last command execution */
    static long long prev_err_count = 0;
    int res = 0;
    if (cmd) {
        if ((server.stat_total_error_replies - prev_err_count) > 0) {
            if (flags & ERROR_COMMAND_REJECTED) {
                cmd->rejected_calls++;
                res = 1;
            } else if (flags & ERROR_COMMAND_FAILED) {
                cmd->failed_calls++;
                res = 1;
            }
        }
    }
    prev_err_count = server.stat_total_error_replies;
    return res;
}",3421.0,3438.0,1.0,24.0,18.0,12,8,11,5,1,5,4,7,2,0,,0,5,4,2,2,int
6385,378861,rejectCommand,1,rejectCommand,"void rejectCommand (client*,robj*)",server.c,"void rejectCommand(client *c, robj *reply) {
    flagTransaction(c);
    c->duration = 0;
    if (c->cmd) c->cmd->rejected_calls++;
    if (c->cmd && c->cmd->proc == execCommand) {
        execCommandAbort(c, reply->ptr);
    } else {
        /* using addReplyError* rather than addReply so that the error can be logged. */
        addReplyErrorObject(c, reply);
    }
}",3702.0,3712.0,1.0,1.0,11.0,12,5,9,3,7,7,3,3,3,2,,0,5,4,2,2,void
6386,378908,rejectCommandSds,1,rejectCommandSds,"void rejectCommandSds (client*,sds)",server.c,"void rejectCommandSds(client *c, sds s) {
    flagTransaction(c);
    c->duration = 0;
    if (c->cmd) c->cmd->rejected_calls++;
    if (c->cmd && c->cmd->proc == execCommand) {
        execCommandAbort(c, s);
        sdsfree(s);
    } else {
        /* The following frees 's'. */
        addReplyErrorSds(c, s);
    }
}",3714.0,3725.0,1.0,1.0,12.0,11,5,10,3,3,8,3,3,3,3,,0,5,4,2,2,void
6387,378955,rejectCommandFormat,1,rejectCommandFormat,"void rejectCommandFormat (client*,char*...)",server.c,"void rejectCommandFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    sds s = sdscatvprintf(sdsempty(),fmt,ap);
    va_end(ap);
    /* Make sure there are no newlines in the string, otherwise invalid protocol
     * is emitted (The args come from the user, they may contain any character). */
    sdsmapchars(s, ""\r\n"", ""  "",  2);
    rejectCommandSds(c, s);
}",3727.0,3736.0,1.0,1.0,10.0,1,1,9,4,6,4,1,1,0,4,,0,2,4,2,2,void
6388,378982,afterCommand,1,afterCommand,void afterCommand (client*),server.c,"void afterCommand(client *c) {
    UNUSED(c);
    /* Should be done before trackingHandlePendingKeyInvalidations so that we
     * reply to client before invalidating cache (makes more sense) */
    postExecutionUnitOperations();

    /* Flush pending tracking invalidations. */
    trackingHandlePendingKeyInvalidations();

    /* Flush other pending push messages. only when we are not in nested call.
     * So the messages are not interleaved with transaction response. */
    if (!server.execution_nesting)
        listJoin(c->reply, server.pending_push_messages);
}",3739.0,3752.0,1.0,4.0,14.0,5,4,5,2,0,8,2,2,2,3,,0,5,2,1,1,void
6389,379008,commandCheckExistence,1,commandCheckExistence,"int commandCheckExistence (client*,sds*)",server.c,"int commandCheckExistence(client *c, sds *err) {
    if (c->cmd)
        return 1;
    if (!err)
        return 0;
    if (isContainerCommandBySds(c->argv[0]->ptr)) {
        /* If we can't find the command but argv[0] by itself is a command
         * it means we're dealing with an invalid subcommand. Print Help. */
        sds cmd = sdsnew((char *)c->argv[0]->ptr);
        sdstoupper(cmd);
        *err = sdsnew(NULL);
        *err = sdscatprintf(*err, ""unknown subcommand '%.128s'. Try %s HELP."",
                            (char *)c->argv[1]->ptr, cmd);
        sdsfree(cmd);
    } else {
        sds args = sdsempty();
        int i;
        for (i=1; i < c->argc && sdslen(args) < 128; i++)
            args = sdscatprintf(args, ""'%.*s' "", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
        *err = sdsnew(NULL);
        *err = sdscatprintf(*err, ""unknown command '%.128s', with args beginning with: %s"",
                            (char*)c->argv[0]->ptr, args);
        sdsfree(arg...",3756.0,3784.0,1.0,1.0,29.0,20,6,14,4,2,11,4,4,3,7,,0,8,4,2,2,int
6390,379152,commandCheckArity,1,commandCheckArity,"int commandCheckArity (client*,sds*)",server.c,"int commandCheckArity(client *c, sds *err) {
    if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
        (c->argc < -c->cmd->arity))
    {
        if (err) {
            *err = sdsnew(NULL);
            *err = sdscatprintf(*err, ""wrong number of arguments for '%s' command"", c->cmd->fullname);
        }
        return 0;
    }

    return 1;
}",3788.0,3800.0,1.0,1.0,13.0,21,9,11,3,2,8,3,4,5,2,,0,8,4,2,2,int
6391,379212,getCommandFlags,1,getCommandFlags,uint64_t getCommandFlags (client*),server.c,"uint64_t getCommandFlags(client *c) {
    uint64_t cmd_flags = c->cmd->flags;

    if (c->cmd->proc == fcallCommand || c->cmd->proc == fcallroCommand) {
        cmd_flags = fcallGetCommandFlags(c, cmd_flags);
    } else if (c->cmd->proc == evalCommand || c->cmd->proc == evalRoCommand ||
               c->cmd->proc == evalShaCommand || c->cmd->proc == evalShaRoCommand)
    {
        cmd_flags = evalGetCommandFlags(c, cmd_flags);
    }

    return cmd_flags;
}",3805.0,3817.0,1.0,1.0,13.0,11,4,10,4,3,4,2,2,2,1,,0,4,2,1,1,uint64_t
6392,379289,processCommand,1,processCommand,int processCommand (client*),server.c,"int processCommand(client *c) {
    if (!scriptIsTimedout()) {
        /* Both EXEC and scripts call call() directly so there should be
         * no way in_exec or scriptIsRunning() is 1.
         * That is unless lua_timedout, in which case client may run
         * some commands. */
        serverAssert(!server.in_exec);
        serverAssert(!scriptIsRunning());
    }

    /* in case we are starting to ProcessCommand and we already have a command we assume
     * this is a reprocessing of this command, so we do not want to perform some of the actions again. */
    int client_reprocessing_command = c->cmd ? 1 : 0;

    /* only run command filter if not reprocessing command */
    if (!client_reprocessing_command) {
        moduleCallCommandFilters(c);
        reqresAppendRequest(c);
    }

    /* Handle possible security attacks. */
    if (!strcasecmp(c->argv[0]->ptr,""host:"") || !strcasecmp(c->argv[0]->ptr,""post"")) {
        securityWarningCommand(c);
        return C_ERR;
    }
...",3827.0,4168.0,1.0,8.0,342.0,406,19,239,38,1,193,37,53,94,54,,0,159,2,1,1,int
6393,380657,incrementErrorCount,1,incrementErrorCount,"void incrementErrorCount (char*,size_t)",server.c,"void incrementErrorCount(const char *fullerr, size_t namelen) {
    struct redisError *error = raxFind(server.errors,(unsigned char*)fullerr,namelen);
    if (error == raxNotFound) {
        error = zmalloc(sizeof(*error));
        error->count = 0;
        raxInsert(server.errors,(unsigned char*)fullerr,namelen,error,NULL);
    }
    error->count++;
}",4172.0,4180.0,1.0,1.0,9.0,13,8,15,6,1,9,2,2,0,3,,0,8,4,2,2,void
6394,380704,closeListeningSockets,1,closeListeningSockets,void closeListeningSockets (int),server.c,"void closeListeningSockets(int unlink_unix_socket) {
    int j;

    for (int i = 0; i < CONN_TYPE_MAX; i++) {
        connListener *listener = &server.listeners[i];
        if (listener->ct == NULL)
            continue;

        for (j = 0; j < listener->count; j++) close(listener->fd[j]);
    }

    if (server.cluster_enabled)
        for (j = 0; j < server.clistener.count; j++) close(server.clistener.fd[j]);
    if (unlink_unix_socket && server.unixsocket) {
        serverLog(LL_NOTICE,""Removing the unix socket file."");
        if (unlink(server.unixsocket) != 0)
            serverLog(LL_WARNING,""Error removing the unix socket file: %s"",strerror(errno));
    }
}",4186.0,4204.0,1.0,24.0,19.0,26,10,20,7,1,18,9,12,10,2,,0,16,2,1,1,void
6395,380839,prepareForShutdown,1,prepareForShutdown,int prepareForShutdown (int),server.c,"int prepareForShutdown(int flags) {
    if (isShutdownInitiated()) return C_ERR;

    /* When SHUTDOWN is called while the server is loading a dataset in
     * memory we need to make sure no attempt is performed to save
     * the dataset on shutdown (otherwise it could overwrite the current DB
     * with half-read data).
     *
     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */
    if (server.loading || server.sentinel_mode)
        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;

    server.shutdown_flags = flags;

    serverLog(LL_NOTICE,""User requested shutdown..."");
    if (server.supervised_mode == SUPERVISED_SYSTEMD)
        redisCommunicateSystemd(""STOPPING=1\n"");

    /* If we have any replicas, let them catch up the replication offset before
     * we shut down, to avoid data loss. */
    if (!(flags & SHUTDOWN_NOW) &&
        server.shutdown_timeout != 0 &&
        !isReadyToShutdown())
    {
        server.shutdown_mstime = server.mstime + s...",4229.0,4263.0,1.0,38.0,35.0,41,15,16,4,4,29,6,7,11,9,,0,23,2,1,1,int
6396,381063,cancelShutdown,1,cancelShutdown,void cancelShutdown (void),server.c,"static void cancelShutdown(void) {
    server.shutdown_asap = 0;
    server.shutdown_flags = 0;
    server.shutdown_mstime = 0;
    server.last_sig_received = 0;
    replyToClientsBlockedOnShutdown();
    unpauseActions(PAUSE_DURING_SHUTDOWN);
}",4285.0,4292.0,1.0,1.0,8.0,8,2,5,2,1,10,1,1,0,2,,0,8,2,1,1,void
6397,381091,abortShutdown,1,abortShutdown,int abortShutdown (void),server.c,"int abortShutdown(void) {
    if (isShutdownInitiated()) {
        cancelShutdown();
    } else if (server.shutdown_asap) {
        /* Signal handler has requested shutdown, but it hasn't been initiated
         * yet. Just clear the flag. */
        server.shutdown_asap = 0;
    } else {
        /* Shutdown neither initiated nor requested. */
        return C_ERR;
    }
    serverLog(LL_NOTICE, ""Shutdown manually aborted."");
    return C_OK;
}",4295.0,4308.0,1.0,15.0,14.0,3,3,1,1,1,5,2,2,1,3,,0,3,2,1,1,int
6398,381760,writeCommandsDeniedByDiskError,1,writeCommandsDeniedByDiskError,int writeCommandsDeniedByDiskError (void),server.c,"int writeCommandsDeniedByDiskError(void) {
    if (server.stop_writes_on_bgsave_err &&
        server.saveparamslen > 0 &&
        server.lastbgsave_status == C_ERR)
    {
        return DISK_ERROR_TYPE_RDB;
    } else if (server.aof_state != AOF_OFF) {
        if (server.aof_last_write_status == C_ERR) {
            return DISK_ERROR_TYPE_AOF;
        }
        /* AOF fsync error. */
        int aof_bio_fsync_status;
        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);
        if (aof_bio_fsync_status == C_ERR) {
            atomicGet(server.aof_bio_fsync_errno,server.aof_last_write_errno);
            return DISK_ERROR_TYPE_AOF;
        }
    }

    return DISK_ERROR_TYPE_NONE;
}",4475.0,4495.0,1.0,36.0,21.0,8,5,3,1,4,6,2,2,6,0,,0,6,2,1,1,int
6399,381843,writeCommandsGetDiskErrorMessage,1,writeCommandsGetDiskErrorMessage,sds writeCommandsGetDiskErrorMessage (int),server.c,"sds writeCommandsGetDiskErrorMessage(int error_code) {
    sds ret = NULL;
    if (error_code == DISK_ERROR_TYPE_RDB) {
        ret = sdsdup(shared.bgsaveerr->ptr);
    } else {
        ret = sdscatfmt(sdsempty(),
                ""-MISCONF Errors writing to the AOF file: %s\r\n"",
                strerror(server.aof_last_write_errno));
    }
    return ret;
}",4497.0,4507.0,1.0,22.0,11.0,5,4,6,4,2,3,2,2,0,1,,0,3,2,1,1,sds
6400,381880,pingCommand,1,pingCommand,void pingCommand (client*),server.c,"void pingCommand(client *c) {
    /* The command takes zero or one arguments. */
    if (c->argc > 2) {
        addReplyErrorArity(c);
        return;
    }

    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {
        addReply(c,shared.mbulkhdr[2]);
        addReplyBulkCBuffer(c,""pong"",4);
        if (c->argc == 1)
            addReplyBulkCBuffer(c,"""",0);
        else
            addReplyBulk(c,c->argv[1]);
    } else {
        if (c->argc == 1)
            addReply(c,shared.pong);
        else
            addReplyBulk(c,c->argv[1]);
    }
}",4511.0,4531.0,1.0,19.0,21.0,12,8,9,2,0,10,4,5,4,4,,0,6,2,1,1,void
6401,381966,echoCommand,1,echoCommand,void echoCommand (client*),server.c,"void echoCommand(client *c) {
    addReplyBulk(c,c->argv[1]);
}",4533.0,4535.0,1.0,1.0,3.0,2,2,2,1,0,2,1,1,0,1,,0,1,2,1,1,void
6402,381978,timeCommand,1,timeCommand,void timeCommand (client*),server.c,"void timeCommand(client *c) {
    addReplyArrayLen(c,2);
    addReplyBulkLongLong(c, server.unixtime);
    addReplyBulkLongLong(c, server.ustime-((long long)server.unixtime)*1000000);
}",4537.0,4541.0,1.0,1.0,5.0,6,4,6,2,0,9,1,1,0,3,,0,6,2,1,1,void
6403,382008,addReplyCommandFlags,1,addReplyCommandFlags,"void addReplyCommandFlags (client*,uint64_t,replyFlagNames*)",server.c,"void addReplyCommandFlags(client *c, uint64_t flags, replyFlagNames *replyFlags) {
    int count = 0, j=0;
    /* Count them so we don't have to use deferred reply. */
    while (replyFlags[j].name) {
        if (flags & replyFlags[j].flag)
            count++;
        j++;
    }

    addReplySetLen(c, count);
    j = 0;
    while (replyFlags[j].name) {
        if (flags & replyFlags[j].flag)
            addReplyStatus(c, replyFlags[j].name);
        j++;
    }
}",4549.0,4565.0,1.0,1.0,17.0,18,5,21,5,4,2,5,7,0,2,,0,0,6,3,3,void
6404,382074,addReplyFlagsForCommand,1,addReplyFlagsForCommand,"void addReplyFlagsForCommand (client*,redisCommand*)",server.c,"void addReplyFlagsForCommand(client *c, struct redisCommand *cmd) {
    replyFlagNames flagNames[] = {
        {CMD_WRITE,             ""write""},
        {CMD_READONLY,          ""readonly""},
        {CMD_DENYOOM,           ""denyoom""},
        {CMD_MODULE,            ""module""},
        {CMD_ADMIN,             ""admin""},
        {CMD_PUBSUB,            ""pubsub""},
        {CMD_NOSCRIPT,          ""noscript""},
        {CMD_BLOCKING,          ""blocking""},
        {CMD_LOADING,           ""loading""},
        {CMD_STALE,             ""stale""},
        {CMD_SKIP_MONITOR,      ""skip_monitor""},
        {CMD_SKIP_SLOWLOG,      ""skip_slowlog""},
        {CMD_ASKING,            ""asking""},
        {CMD_FAST,              ""fast""},
        {CMD_NO_AUTH,           ""no_auth""},
        /* {CMD_MAY_REPLICATE,     ""may_replicate""},, Hidden on purpose */
        /* {CMD_SENTINEL,          ""sentinel""}, Hidden on purpose */
        /* {CMD_ONLY_SENTINEL,     ""only_sentinel""}, Hidden on purpose */
        {CMD_NO...",4567.0,4597.0,1.0,9.0,31.0,44,4,5,4,0,2,1,1,0,1,,0,1,4,2,2,void
6405,382233,addReplyDocFlagsForCommand,1,addReplyDocFlagsForCommand,"void addReplyDocFlagsForCommand (client*,redisCommand*)",server.c,"void addReplyDocFlagsForCommand(client *c, struct redisCommand *cmd) {
    replyFlagNames docFlagNames[] = {
        {CMD_DOC_DEPRECATED,         ""deprecated""},
        {CMD_DOC_SYSCMD,             ""syscmd""},
        {0,NULL}
    };
    addReplyCommandFlags(c, cmd->doc_flags, docFlagNames);
}",4599.0,4606.0,1.0,9.0,8.0,8,4,5,4,1,2,1,1,0,1,,0,1,4,2,2,void
6406,382266,addReplyFlagsForKeyArgs,1,addReplyFlagsForKeyArgs,"void addReplyFlagsForKeyArgs (client*,uint64_t)",server.c,"void addReplyFlagsForKeyArgs(client *c, uint64_t flags) {
    replyFlagNames docFlagNames[] = {
        {CMD_KEY_RO,              ""RO""},
        {CMD_KEY_RW,              ""RW""},
        {CMD_KEY_OW,              ""OW""},
        {CMD_KEY_RM,              ""RM""},
        {CMD_KEY_ACCESS,          ""access""},
        {CMD_KEY_UPDATE,          ""update""},
        {CMD_KEY_INSERT,          ""insert""},
        {CMD_KEY_DELETE,          ""delete""},
        {CMD_KEY_NOT_KEY,         ""not_key""},
        {CMD_KEY_INCOMPLETE,      ""incomplete""},
        {CMD_KEY_VARIABLE_FLAGS,  ""variable_flags""},
        {0,NULL}
    };
    addReplyCommandFlags(c, flags, docFlagNames);
}",4608.0,4624.0,1.0,9.0,17.0,25,3,5,4,1,1,1,1,0,1,,0,0,4,2,2,void
6407,382373,addReplyFlagsForArg,1,addReplyFlagsForArg,"void addReplyFlagsForArg (client*,uint64_t)",server.c,"void addReplyFlagsForArg(client *c, uint64_t flags) {
    replyFlagNames argFlagNames[] = {
        {CMD_ARG_OPTIONAL,          ""optional""},
        {CMD_ARG_MULTIPLE,          ""multiple""},
        {CMD_ARG_MULTIPLE_TOKEN,    ""multiple_token""},
        {0,NULL}
    };
    addReplyCommandFlags(c, flags, argFlagNames);
}",4639.0,4647.0,1.0,9.0,9.0,9,3,5,4,1,1,1,1,0,1,,0,0,4,2,2,void
6408,382411,addReplyCommandArgList,1,addReplyCommandArgList,"void addReplyCommandArgList (client*,redisCommandArg*,int)",server.c,"void addReplyCommandArgList(client *c, struct redisCommandArg *args, int num_args) {
    addReplyArrayLen(c, num_args);
    for (int j = 0; j<num_args; j++) {
        /* Count our reply len so we don't have to use deferred reply. */
        int has_display_text = 1;
        long maplen = 2;
        if (args[j].key_spec_index != -1) maplen++;
        if (args[j].token) maplen++;
        if (args[j].summary) maplen++;
        if (args[j].since) maplen++;
        if (args[j].deprecated_since) maplen++;
        if (args[j].flags) maplen++;
        if (args[j].type == ARG_TYPE_ONEOF || args[j].type == ARG_TYPE_BLOCK) {
            has_display_text = 0;
            maplen++;
        }
        if (has_display_text) maplen++;
        addReplyMapLen(c, maplen);

        addReplyBulkCString(c, ""name"");
        addReplyBulkCString(c, args[j].name);

        addReplyBulkCString(c, ""type"");
        addReplyBulkCString(c, ARG_TYPE_STR[args[j].type]);

        if (has_display_text) {
            a...",4649.0,4707.0,1.0,1.0,59.0,83,10,103,9,1,22,18,34,0,21,,0,1,6,3,3,void
6409,382711,addReplyCommandHistory,1,addReplyCommandHistory,"void addReplyCommandHistory (client*,redisCommand*)",server.c,"void addReplyCommandHistory(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->num_history);
    for (int j = 0; j<cmd->num_history; j++) {
        addReplyArrayLen(c, 2);
        addReplyBulkCString(c, cmd->history[j].since);
        addReplyBulkCString(c, cmd->history[j].changes);
    }
}",4745.0,4752.0,1.0,1.0,8.0,10,5,12,3,1,8,2,2,1,4,,0,4,4,2,2,void
6410,382757,addReplyCommandTips,1,addReplyCommandTips,"void addReplyCommandTips (client*,redisCommand*)",server.c,"void addReplyCommandTips(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->num_tips);
    for (int j = 0; j<cmd->num_tips; j++) {
        addReplyBulkCString(c, cmd->tips[j]);
    }
}",4754.0,4759.0,1.0,1.0,6.0,6,4,8,3,0,5,2,2,1,2,,0,3,4,2,2,void
6411,382789,addReplyCommandKeySpecs,1,addReplyCommandKeySpecs,"void addReplyCommandKeySpecs (client*,redisCommand*)",server.c,"void addReplyCommandKeySpecs(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->key_specs_num);
    for (int i = 0; i < cmd->key_specs_num; i++) {
        int maplen = 3;
        if (cmd->key_specs[i].notes) maplen++;

        addReplyMapLen(c, maplen);

        if (cmd->key_specs[i].notes) {
            addReplyBulkCString(c, ""notes"");
            addReplyBulkCString(c,cmd->key_specs[i].notes);
        }

        addReplyBulkCString(c, ""flags"");
        addReplyFlagsForKeyArgs(c,cmd->key_specs[i].flags);

        addReplyBulkCString(c, ""begin_search"");
        switch (cmd->key_specs[i].begin_search_type) {
            case KSPEC_BS_UNKNOWN:
                addReplyMapLen(c, 2);
                addReplyBulkCString(c, ""type"");
                addReplyBulkCString(c, ""unknown"");

                addReplyBulkCString(c, ""spec"");
                addReplyMapLen(c, 0);
                break;
            case KSPEC_BS_INDEX:
                addReplyMapLen(c, 2);
              ...",4761.0,4855.0,1.0,16.0,95.0,77,7,103,10,0,77,12,10,5,58,,0,19,4,2,2,void
6412,383173,addReplyCommandSubCommands,1,addReplyCommandSubCommands,"void addReplyCommandSubCommands (client*,redisCommand*,void,int)",server.c,"void addReplyCommandSubCommands(client *c, struct redisCommand *cmd, void (*reply_function)(client*, struct redisCommand*), int use_map) {
    if (!cmd->subcommands_dict) {
        addReplySetLen(c, 0);
        return;
    }

    if (use_map)
        addReplyMapLen(c, dictSize(cmd->subcommands_dict));
    else
        addReplyArrayLen(c, dictSize(cmd->subcommands_dict));
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);
    while((de = dictNext(di)) != NULL) {
        struct redisCommand *sub = (struct redisCommand *)dictGetVal(de);
        if (use_map)
            addReplyBulkCBuffer(c, sub->fullname, sdslen(sub->fullname));
        reply_function(c, sub);
    }
    dictReleaseIterator(di);
}",4858.0,4877.0,1.0,26.0,20.0,18,7,21,7,1,15,5,6,2,8,,0,11,8,4,4,void
6413,383280,addReplyCommandInfo,1,addReplyCommandInfo,"void addReplyCommandInfo (client*,redisCommand*)",server.c,"void addReplyCommandInfo(client *c, struct redisCommand *cmd) {
    if (!cmd) {
        addReplyNull(c);
    } else {
        int firstkey = 0, lastkey = 0, keystep = 0;
        if (cmd->legacy_range_key_spec.begin_search_type != KSPEC_BS_INVALID) {
            firstkey = cmd->legacy_range_key_spec.bs.index.pos;
            lastkey = cmd->legacy_range_key_spec.fk.range.lastkey;
            if (lastkey >= 0)
                lastkey += firstkey;
            keystep = cmd->legacy_range_key_spec.fk.range.keystep;
        }

        addReplyArrayLen(c, 10);
        addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
        addReplyLongLong(c, cmd->arity);
        addReplyFlagsForCommand(c, cmd);
        addReplyLongLong(c, firstkey);
        addReplyLongLong(c, lastkey);
        addReplyLongLong(c, keystep);
        addReplyCommandCategories(c, cmd);
        addReplyCommandTips(c, cmd);
        addReplyCommandKeySpecs(c, cmd);
        addReplyCommandSubCommands(c, cmd, addRepl...",4880.0,4905.0,1.0,1.0,26.0,1,1,2,2,2,1,2,2,0,1,,0,0,4,2,2,void
6414,383399,addReplyCommandDocs,1,addReplyCommandDocs,"void addReplyCommandDocs (client*,redisCommand*)",server.c,"void addReplyCommandDocs(client *c, struct redisCommand *cmd) {
    /* Count our reply len so we don't have to use deferred reply. */
    long maplen = 1;
    if (cmd->summary) maplen++;
    if (cmd->since) maplen++;
    if (cmd->flags & CMD_MODULE) maplen++;
    if (cmd->complexity) maplen++;
    if (cmd->doc_flags) maplen++;
    if (cmd->deprecated_since) maplen++;
    if (cmd->replaced_by) maplen++;
    if (cmd->history) maplen++;
#ifdef LOG_REQ_RES
    if (cmd->reply_schema) maplen++;
#endif
    if (cmd->args) maplen++;
    if (cmd->subcommands_dict) maplen++;
    addReplyMapLen(c, maplen);

    if (cmd->summary) {
        addReplyBulkCString(c, ""summary"");
        addReplyBulkCString(c, cmd->summary);
    }
    if (cmd->since) {
        addReplyBulkCString(c, ""since"");
        addReplyBulkCString(c, cmd->since);
    }

    /* Always have the group, for module commands the group is always ""module"". */
    addReplyBulkCString(c, ""group"");
    addReplyBulkCString(c, commandGroupSt...",4908.0,4977.0,1.0,21.0,70.0,43,5,67,3,1,53,21,21,20,25,,0,30,4,2,2,void
6415,383631,getKeysSubcommandImpl,1,getKeysSubcommandImpl,"void getKeysSubcommandImpl (client*,int)",server.c,"void getKeysSubcommandImpl(client *c, int with_flags) {
    struct redisCommand *cmd = lookupCommand(c->argv+2,c->argc-2);
    getKeysResult result = GETKEYS_RESULT_INIT;
    int j;

    if (!cmd) {
        addReplyError(c,""Invalid command specified"");
        return;
    } else if (!doesCommandHaveKeys(cmd)) {
        addReplyError(c,""The command has no key arguments"");
        return;
    } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||
               ((c->argc-2) < -cmd->arity))
    {
        addReplyError(c,""Invalid number of arguments specified for command"");
        return;
    }

    if (!getKeysFromCommandWithSpecs(cmd,c->argv+2,c->argc-2,GET_KEYSPEC_DEFAULT,&result)) {
        if (cmd->flags & CMD_NO_MANDATORY_KEYS) {
            addReplyArrayLen(c,0);
        } else {
            addReplyError(c,""Invalid arguments specified for command"");
        }
    } else {
        addReplyArrayLen(c,result.numkeys);
        for (j = 0; j < result.numkeys; j++) {
            i...",4980.0,5017.0,1.0,27.0,38.0,20,9,14,4,2,10,4,5,4,5,,0,7,4,2,2,void
6416,383825,commandGetKeysAndFlagsCommand,1,commandGetKeysAndFlagsCommand,void commandGetKeysAndFlagsCommand (client*),server.c,"void commandGetKeysAndFlagsCommand(client *c) {
    getKeysSubcommandImpl(c, 1);
}",5020.0,5022.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
6417,383833,getKeysSubcommand,1,getKeysSubcommand,void getKeysSubcommand (client*),server.c,"void getKeysSubcommand(client *c) {
    getKeysSubcommandImpl(c, 0);
}",5025.0,5027.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,void
6418,383841,commandCommand,1,commandCommand,void commandCommand (client*),server.c,"void commandCommand(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c, dictSize(server.commands));
    di = dictGetIterator(server.commands);
    while ((de = dictNext(di)) != NULL) {
        addReplyCommandInfo(c, dictGetVal(de));
    }
    dictReleaseIterator(di);
}",5030.0,5040.0,1.0,24.0,11.0,12,6,12,5,0,14,2,2,1,6,,0,11,2,1,1,void
6419,383890,commandCountCommand,1,commandCountCommand,void commandCountCommand (client*),server.c,"void commandCountCommand(client *c) {
    addReplyLongLong(c, dictSize(server.commands));
}",5043.0,5045.0,1.0,24.0,3.0,8,4,4,2,0,7,1,1,0,1,,0,6,2,1,1,void
6420,383933,shouldFilterFromCommandList,1,shouldFilterFromCommandList,"int shouldFilterFromCommandList (redisCommand*,commandListFilter*)",server.c,"int shouldFilterFromCommandList(struct redisCommand *cmd, commandListFilter *filter) {
    switch (filter->type) {
        case (COMMAND_LIST_FILTER_MODULE):
            if (!filter->cache.valid) {
                filter->cache.u.module_handle = moduleGetHandleByName(filter->arg);
                filter->cache.valid = 1;
            }
            return !moduleIsModuleCommand(filter->cache.u.module_handle, cmd);
        case (COMMAND_LIST_FILTER_ACLCAT): {
            if (!filter->cache.valid) {
                filter->cache.u.aclcat = ACLGetCommandCategoryFlagByName(filter->arg);
                filter->cache.valid = 1;
            }
            uint64_t cat = filter->cache.u.aclcat;
            if (cat == 0)
                return 1; /* Invalid ACL category */
            return (!(cmd->acl_categories & cat));
            break;
        }
        case (COMMAND_LIST_FILTER_PATTERN):
            return !stringmatchlen(filter->arg, sdslen(filter->arg), cmd->fullname, sdslen(cmd->full...",5065.0,5089.0,1.0,12.0,25.0,42,7,24,6,1,16,6,8,1,7,,0,13,4,2,2,int
6421,384071,commandListWithFilter,1,commandListWithFilter,"void commandListWithFilter (client*,dict*,commandListFilter,int*)",server.c,"void commandListWithFilter(client *c, dict *commands, commandListFilter filter, int *numcmds) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (!shouldFilterFromCommandList(cmd,&filter)) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            (*numcmds)++;
        }

        if (cmd->subcommands_dict) {
            commandListWithFilter(c, cmd->subcommands_dict, filter, numcmds);
        }
    }
    dictReleaseIterator(di);
}",5092.0,5108.0,1.0,1.0,17.0,12,7,19,8,1,11,4,6,3,7,,0,9,8,4,4,void
6422,384131,commandListWithoutFilter,1,commandListWithoutFilter,"void commandListWithoutFilter (client*,dict*,int*)",server.c,"void commandListWithoutFilter(client *c, dict *commands, int *numcmds) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
        (*numcmds)++;

        if (cmd->subcommands_dict) {
            commandListWithoutFilter(c, cmd->subcommands_dict, numcmds);
        }
    }
    dictReleaseIterator(di);
}",5111.0,5125.0,1.0,1.0,15.0,10,5,16,7,0,10,3,4,2,6,,0,8,6,3,3,void
6423,384182,commandListCommand,1,commandListCommand,void commandListCommand (client*),server.c,"void commandListCommand(client *c) {

    /* Parse options. */
    int i = 2, got_filter = 0;
    commandListFilter filter = {0};
    for (; i < c->argc; i++) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (!strcasecmp(opt,""filterby"") && moreargs == 2) {
            char *filtertype = c->argv[i+1]->ptr;
            if (!strcasecmp(filtertype,""module"")) {
                filter.type = COMMAND_LIST_FILTER_MODULE;
            } else if (!strcasecmp(filtertype,""aclcat"")) {
                filter.type = COMMAND_LIST_FILTER_ACLCAT;
            } else if (!strcasecmp(filtertype,""pattern"")) {
                filter.type = COMMAND_LIST_FILTER_PATTERN;
            } else {
                addReplyErrorObject(c,shared.syntaxerr);
                return;
            }
            got_filter = 1;
            filter.arg = c->argv[i+2]->ptr;
            i += 2;
        } else {
            addReplyErrorObject(c,shared...",5128.0,5167.0,1.0,1.0,40.0,37,13,35,11,0,12,5,8,1,3,,0,10,2,1,1,void
6424,384357,commandInfoCommand,1,commandInfoCommand,void commandInfoCommand (client*),server.c,"void commandInfoCommand(client *c) {
    int i;

    if (c->argc == 2) {
        dictIterator *di;
        dictEntry *de;
        addReplyArrayLen(c, dictSize(server.commands));
        di = dictGetIterator(server.commands);
        while ((de = dictNext(di)) != NULL) {
            addReplyCommandInfo(c, dictGetVal(de));
        }
        dictReleaseIterator(di);
    } else {
        addReplyArrayLen(c, c->argc-2);
        for (i = 2; i < c->argc; i++) {
            addReplyCommandInfo(c, lookupCommandBySds(c->argv[i]->ptr));
        }
    }
}",5170.0,5188.0,1.0,28.0,19.0,14,7,13,5,0,15,3,4,2,6,,0,12,2,1,1,void
6425,384446,commandDocsCommand,1,commandDocsCommand,void commandDocsCommand (client*),server.c,"void commandDocsCommand(client *c) {
    int i;
    if (c->argc == 2) {
        /* Reply with an array of all commands */
        dictIterator *di;
        dictEntry *de;
        addReplyMapLen(c, dictSize(server.commands));
        di = dictGetIterator(server.commands);
        while ((de = dictNext(di)) != NULL) {
            struct redisCommand *cmd = dictGetVal(de);
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            addReplyCommandDocs(c, cmd);
        }
        dictReleaseIterator(di);
    } else {
        /* Reply with an array of the requested commands (if we find them) */
        int numcmds = 0;
        void *replylen = addReplyDeferredLen(c);
        for (i = 2; i < c->argc; i++) {
            struct redisCommand *cmd = lookupCommandBySds(c->argv[i]->ptr);
            if (!cmd)
                continue;
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            addReplyCommandDocs(c, cmd);
            numcmds++;...",5191.0,5219.0,1.0,26.0,29.0,17,7,18,6,0,19,3,4,2,8,,0,15,2,1,1,void
6426,384574,commandGetKeysCommand,1,commandGetKeysCommand,void commandGetKeysCommand (client*),server.c,"void commandGetKeysCommand(client *c) {
    getKeysSubcommand(c);
}",5222.0,5224.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
6427,384581,commandHelpCommand,1,commandHelpCommand,void commandHelpCommand (client*),server.c,"void commandHelpCommand(client *c) {
    const char *help[] = {
""(no subcommand)"",
""    Return details about all Redis commands."",
""COUNT"",
""    Return the total number of commands in this Redis server."",
""LIST"",
""    Return a list of all commands in this Redis server."",
""INFO [<command-name> ...]"",
""    Return details about multiple Redis commands."",
""    If no command names are given, documentation details for all"",
""    commands are returned."",
""DOCS [<command-name> ...]"",
""    Return documentation details about multiple Redis commands."",
""    If no command names are given, documentation details for all"",
""    commands are returned."",
""GETKEYS <full-command>"",
""    Return the keys from a full Redis command."",
""GETKEYSANDFLAGS <full-command>"",
""    Return the keys and the access flags from a full Redis command."",
NULL
    };

    addReplyHelp(c, help);
}",5227.0,5251.0,1.0,1.0,25.0,2,2,4,3,0,1,1,1,0,1,,0,0,2,1,1,void
6428,384782,fillPercentileDistributionLatencies,1,fillPercentileDistributionLatencies,"sds fillPercentileDistributionLatencies (sds,char*,hdr_histogram*)",server.c,"sds fillPercentileDistributionLatencies(sds info, const char* histogram_name, struct hdr_histogram* histogram) {
    info = sdscatfmt(info,""latency_percentiles_usec_%s:"",histogram_name);
    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        char fbuf[128];
        size_t len = snprintf(fbuf, sizeof(fbuf), ""%f"", server.latency_tracking_info_percentiles[j]);
        trimDoubleString(fbuf, len);
        info = sdscatprintf(info,""p%s=%.3f"", fbuf,
            ((double)hdr_value_at_percentile(histogram,server.latency_tracking_info_percentiles[j]))/1000.0f);
        if (j != server.latency_tracking_info_percentiles_len-1)
            info = sdscatlen(info,"","",1);
        }
    info = sdscatprintf(info,""\r\n"");
    return info;
}",5283.0,5296.0,1.0,1.0,14.0,18,9,26,7,1,13,3,4,4,5,,0,12,6,3,3,sds
6429,384906,getSafeInfoString,1,getSafeInfoString,"const char* getSafeInfoString (char*,size_t,char**)",server.c,"const char *getSafeInfoString(const char *s, size_t len, char **tmp) {
    *tmp = NULL;
    if (mempbrk(s, len, unsafe_info_chars,sizeof(unsafe_info_chars)-1)
        == NULL) return s;
    char *new = *tmp = zmalloc(len + 1);
    memcpy(new, s, len);
    new[len] = '\0';
    return memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,
                       sizeof(unsafe_info_chars)-1);
}",5320.0,5329.0,1.0,1.0,10.0,13,7,21,7,5,8,2,2,3,3,,0,7,6,3,3,const char*
6430,384960,genRedisInfoStringCommandStats,1,genRedisInfoStringCommandStats,"sds genRedisInfoStringCommandStats (sds,dict*)",server.c,"sds genRedisInfoStringCommandStats(sds info, dict *commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;
    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        char *tmpsafe;
        c = (struct redisCommand *) dictGetVal(de);
        if (c->calls || c->failed_calls || c->rejected_calls) {
            info = sdscatprintf(info,
                ""cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f""
                "",rejected_calls=%lld,failed_calls=%lld\r\n"",
                getSafeInfoString(c->fullname, sdslen(c->fullname), &tmpsafe), c->calls, c->microseconds,
                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls),
                c->rejected_calls, c->failed_calls);
            if (tmpsafe != NULL) zfree(tmpsafe);
        }
        if (c->subcommands_dict) {
            info = genRedisInfoStringCommandStats(info, c->subcommands_dict);
        }
    }
    dictReleaseIterator(di);

    return info;
}",5331.0,5355.0,1.0,1.0,25.0,29,9,31,7,1,22,5,9,5,8,,0,20,4,2,2,sds
6431,385067,genRedisInfoStringACLStats,1,genRedisInfoStringACLStats,sds genRedisInfoStringACLStats (sds),server.c,"sds genRedisInfoStringACLStats(sds info) {
    info = sdscatprintf(info,
         ""acl_access_denied_auth:%lld\r\n""
         ""acl_access_denied_cmd:%lld\r\n""
         ""acl_access_denied_key:%lld\r\n""
         ""acl_access_denied_channel:%lld\r\n"",
         server.acl_info.user_auth_failures,
         server.acl_info.invalid_cmd_accesses,
         server.acl_info.invalid_key_accesses,
         server.acl_info.invalid_channel_accesses);
    return info;
}",5358.0,5369.0,1.0,1.0,12.0,9,2,7,2,1,9,1,1,0,1,,0,9,2,1,1,sds
6432,385099,genRedisInfoStringLatencyStats,1,genRedisInfoStringLatencyStats,"sds genRedisInfoStringLatencyStats (sds,dict*)",server.c,"sds genRedisInfoStringLatencyStats(sds info, dict *commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;
    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        char *tmpsafe;
        c = (struct redisCommand *) dictGetVal(de);
        if (c->latency_histogram) {
            info = fillPercentileDistributionLatencies(info,
                getSafeInfoString(c->fullname, sdslen(c->fullname), &tmpsafe),
                c->latency_histogram);
            if (tmpsafe != NULL) zfree(tmpsafe);
        }
        if (c->subcommands_dict) {
            info = genRedisInfoStringLatencyStats(info, c->subcommands_dict);
        }
    }
    dictReleaseIterator(di);

    return info;
}",5371.0,5392.0,1.0,1.0,22.0,15,5,23,7,1,14,5,9,3,8,,0,12,4,2,2,sds
6433,385206,releaseInfoSectionDict,1,releaseInfoSectionDict,void releaseInfoSectionDict (dict*),server.c,"void releaseInfoSectionDict(dict *sec) {
    if (sec != cached_default_info_sections)
        dictRelease(sec);
}",5407.0,5410.0,1.0,1.0,4.0,1,1,3,2,5,2,2,2,1,1,,0,1,2,1,1,void
6434,385218,genInfoSectionDict,1,genInfoSectionDict,"dict genInfoSectionDict (robj**,int,char**,int*,int*)",server.c,"dict *genInfoSectionDict(robj **argv, int argc, char **defaults, int *out_all, int *out_everything) {
    char *default_sections[] = {
        ""server"", ""clients"", ""memory"", ""persistence"", ""stats"", ""replication"",
        ""cpu"", ""module_list"", ""errorstats"", ""cluster"", ""keyspace"", NULL};
    if (!defaults)
        defaults = default_sections;

    if (argc == 0) {
        /* In this case we know the dict is not gonna be modified, so we cache
         * it as an optimization for a common case. */
        if (cached_default_info_sections)
            return cached_default_info_sections;
        cached_default_info_sections = dictCreate(&stringSetDictType);
        dictExpand(cached_default_info_sections, 16);
        addInfoSectionsToDict(cached_default_info_sections, defaults);
        return cached_default_info_sections;
    }

    dict *section_dict = dictCreate(&stringSetDictType);
    dictExpand(section_dict, min(argc,16));
    for (int i = 0; i < argc; i++) {
        if (!strcasec...",5417.0,5452.0,1.0,29.0,36.0,16,9,28,9,4,14,6,8,1,6,,0,10,10,5,5,dict
6435,385386,genRedisInfoString,1,genRedisInfoString,"sds genRedisInfoString (dict*,int,int)",server.c,"sds genRedisInfoString(dict *section_dict, int all_sections, int everything) {
    sds info = sdsempty();
    time_t uptime = server.unixtime-server.stat_starttime;
    int j;
    int sections = 0;
    if (everything) all_sections = 1;

    /* Server */
    if (all_sections || (dictFind(section_dict,""server"") != NULL)) {
        static int call_uname = 1;
        static struct utsname name;
        char *mode;
        char *supervised;

        if (server.cluster_enabled) mode = ""cluster"";
        else if (server.sentinel_mode) mode = ""sentinel"";
        else mode = ""standalone"";

        if (server.supervised) {
            if (server.supervised_mode == SUPERVISED_UPSTART) supervised = ""upstart"";
            else if (server.supervised_mode == SUPERVISED_SYSTEMD) supervised = ""systemd"";
            else supervised = ""unknown"";
        } else {
            supervised = ""no"";
        }

        if (sections++) info = sdscat(info,""\r\n"");

        if (call_uname) {
            /* Uname...",5457.0,6261.0,1.0,42.0,805.0,663,21,613,73,4,592,61,121,64,125,,0,576,6,3,3,sds
6436,387730,infoCommand,1,infoCommand,void infoCommand (client*),server.c,"void infoCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelInfoCommand(c);
        return;
    }
    int all_sections = 0;
    int everything = 0;
    dict *sections_dict = genInfoSectionDict(c->argv+1, c->argc-1, NULL, &all_sections, &everything);
    sds info = genRedisInfoString(sections_dict, all_sections, everything);
    addReplyVerbatim(c,info,sdslen(info),""txt"");
    sdsfree(info);
    releaseInfoSectionDict(sections_dict);
    return;
}",6264.0,6277.0,1.0,1.0,14.0,11,6,19,7,0,11,2,2,2,7,,0,7,2,1,1,void
6437,387788,monitorCommand,1,monitorCommand,void monitorCommand (client*),server.c,"void monitorCommand(client *c) {
    if (c->flags & CLIENT_DENY_BLOCKING) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expects a reply per command and so can't execute MONITOR. */
        addReplyError(c, ""MONITOR isn't allowed for DENY BLOCKING client"");
        return;
    }

    /* ignore MONITOR if already slave or in monitor mode */
    if (c->flags & CLIENT_SLAVE) return;

    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
    listAddNodeTail(server.monitors,c);
    addReply(c,shared.ok);
}",6279.0,6294.0,1.0,19.0,16.0,12,5,8,3,0,10,3,3,2,3,,0,7,2,1,1,void
6438,387845,checkIgnoreWarning,1,checkIgnoreWarning,int checkIgnoreWarning (char*),server.c,"int checkIgnoreWarning(const char *warning) {
    int argc, j;
    sds *argv = sdssplitargs(server.ignore_warnings, &argc);
    if (argv == NULL)
        return 0;

    for (j = 0; j < argc; j++) {
        char *flag = argv[j];
        if (!strcasecmp(flag, warning))
            break;
    }
    sdsfreesplitres(argv,argc);
    return j < argc;
}",6298.0,6311.0,1.0,1.0,14.0,10,7,17,7,0,4,5,5,0,2,,0,3,2,1,1,int
6439,387899,createPidFile,1,createPidFile,void createPidFile (void),server.c,"void createPidFile(void) {
    /* If pidfile requested, but no pidfile defined, use
     * default pidfile path */
    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);

    /* Try to write the pid file in a best-effort way. */
    FILE *fp = fopen(server.pidfile,""w"");
    if (fp) {
        fprintf(fp,""%d\n"",(int)getpid());
        fclose(fp);
    } else {
        serverLog(LL_WARNING, ""Failed to write PID file: %s"", strerror(errno));
    }
}",6348.0,6361.0,1.0,50.0,14.0,7,4,7,2,0,7,3,3,2,1,,0,7,2,1,1,void
6440,387959,daemonize,1,daemonize,void daemonize (void),server.c,"void daemonize(void) {
    int fd;

    if (fork() != 0) exit(0); /* parent exits */
    setsid(); /* create a new session */

    /* Every output goes to /dev/null. If Redis is daemonized but
     * the 'logfile' is set to 'stdout' in the configuration file
     * it will not log at all. */
    if ((fd = open(""/dev/null"", O_RDWR, 0)) != -1) {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
        if (fd > STDERR_FILENO) close(fd);
    }
}",6363.0,6378.0,1.0,1.0,16.0,5,4,11,5,0,0,4,5,0,0,,0,0,2,1,1,void
6441,388000,version,1,version,void version (void),server.c,"void version(void) {
    printf(""Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n"",
        REDIS_VERSION,
        redisGitSHA1(),
        atoi(redisGitDirty()) > 0,
        ZMALLOC_LIB,
        sizeof(long) == 4 ? 32 : 64,
        (unsigned long long) redisBuildId());
    exit(0);
}",6380.0,6389.0,1.0,8.0,10.0,5,5,1,1,0,3,1,1,0,3,,0,0,2,1,1,void
6442,388088,redisAsciiArt,1,redisAsciiArt,void redisAsciiArt (void),server.c,"void redisAsciiArt(void) {
#include ""asciilogo.h""
    char *buf = zmalloc(1024*16);
    char *mode;

    if (server.cluster_enabled) mode = ""cluster"";
    else if (server.sentinel_mode) mode = ""sentinel"";
    else mode = ""standalone"";

    /* Show the ASCII logo if: log file is stdout AND stdout is a
     * tty AND syslog logging is disabled. Also show logo if the user
     * forced us to do so via redis.conf. */
    int show_logo = ((!server.syslog_enabled &&
                      server.logfile[0] == '\0' &&
                      isatty(fileno(stdout))) ||
                     server.always_show_logo);

    if (!show_logo) {
        serverLog(LL_NOTICE,
            ""Running mode=%s, port=%d."",
            mode, server.port ? server.port : server.tls_port
        );
    } else {
        snprintf(buf,1024*16,ascii_logo,
            REDIS_VERSION,
            redisGitSHA1(),
            strtol(redisGitDirty(),NULL,10) > 0,
            (sizeof(long) == 8) ? ""64"" : ""32"",
            mo...",6412.0,6446.0,1.0,27.0,35.0,23,11,16,6,0,19,3,3,2,3,,0,17,2,1,1,void
6443,388236,listenerByType,1,listenerByType,connListener listenerByType (char*),server.c,"connListener *listenerByType(const char *typename) {
    int conn_index;

    conn_index = connectionIndexByType(typename);
    if (conn_index < 0)
        return NULL;

    return &server.listeners[conn_index];
}",6449.0,6457.0,1.0,1.0,9.0,5,5,6,4,4,3,2,2,0,1,,0,3,2,1,1,connListener
6444,388260,changeListener,1,changeListener,int changeListener (connListener*),server.c,"int changeListener(connListener *listener) {
    /* Close old servers */
    closeListener(listener);

    /* Just close the server if port disabled */
    if (listener->port == 0) {
        if (server.set_proc_title) redisSetProcTitle(NULL);
        return C_OK;
    }

    /* Re-create listener */
    if (connListen(listener) != C_OK) {
        return C_ERR;
    }

    /* Create event handlers */
    if (createSocketAcceptHandler(listener, listener->ct->accept_handler) != C_OK) {
        serverPanic(""Unrecoverable error creating %s accept handler."", listener->ct->get_type(NULL));
    }

    if (server.set_proc_title) redisSetProcTitle(NULL);

    return C_OK;
}",6460.0,6483.0,1.0,15.0,24.0,12,6,11,3,4,13,6,7,8,6,,0,9,2,1,1,int
6445,388337,sigShutdownHandler,1,sigShutdownHandler,void sigShutdownHandler (int),server.c,"static void sigShutdownHandler(int sig) {
    char *msg;

    switch (sig) {
    case SIGINT:
        msg = ""Received SIGINT scheduling shutdown..."";
        break;
    case SIGTERM:
        msg = ""Received SIGTERM scheduling shutdown..."";
        break;
    default:
        msg = ""Received shutdown signal, scheduling shutdown..."";
    };

    /* SIGINT is often delivered via Ctrl+C in an interactive session.
     * If we receive the signal the second time, we interpret this as
     * the user really wanting to quit ASAP without waiting to persist
     * on disk and without waiting for lagging replicas. */
    if (server.shutdown_asap && sig == SIGINT) {
        serverLogFromHandler(LL_WARNING, ""You insist... exiting now."");
        rdbRemoveTempFile(getpid(), 1);
        exit(1); /* Exit with an error since this was not a clean shutdown. */
    } else if (server.loading) {
        msg = ""Received shutdown signal during loading, scheduling shutdown."";
    }

    serverLogFromHandler...",6485.0,6514.0,1.0,29.0,30.0,10,4,13,5,0,9,5,3,2,3,,0,6,2,1,1,void
6446,388406,setupSignalHandlers,1,setupSignalHandlers,void setupSignalHandlers (void),server.c,"void setupSignalHandlers(void) {
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = sigShutdownHandler;
    sigaction(SIGTERM, &act, NULL);
    sigaction(SIGINT, &act, NULL);

    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = sigsegvHandler;
    if(server.crashlog_enabled) {
        sigaction(SIGSEGV, &act, NULL);
        sigaction(SIGBUS, &act, NULL);
        sigaction(SIGFPE, &act, NULL);
        sigaction(SIGILL, &act, NULL);
        sigaction(SIGABRT, &act, NULL);
    }
    return;
}",6516.0,6538.0,1.0,1.0,23.0,22,4,32,14,2,2,2,2,2,0,,0,2,2,1,1,void
6447,388487,removeSignalHandlers,1,removeSignalHandlers,void removeSignalHandlers (void),server.c,"void removeSignalHandlers(void) {
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND;
    act.sa_handler = SIG_DFL;
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
}",6540.0,6550.0,1.0,1.0,11.0,12,4,21,10,2,0,1,1,0,0,,0,0,2,1,1,void
6448,388535,sigKillChildHandler,1,sigKillChildHandler,void sigKillChildHandler (int),server.c,"static void sigKillChildHandler(int sig) {
    UNUSED(sig);
    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;
    serverLogFromHandler(level, ""Received SIGUSR1 in child, exiting now."");
    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);
}",6556.0,6561.0,1.0,4.0,6.0,5,5,5,3,0,4,1,1,0,2,,0,2,2,1,1,void
6449,388570,setupChildSignalHandlers,1,setupChildSignalHandlers,void setupChildSignalHandlers (void),server.c,"void setupChildSignalHandlers(void) {
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = sigKillChildHandler;
    sigaction(SIGUSR1, &act, NULL);
}",6563.0,6572.0,1.0,1.0,10.0,7,3,6,3,1,0,1,1,0,0,,0,0,2,1,1,void
6450,388596,closeChildUnusedResourceAfterFork,1,closeChildUnusedResourceAfterFork,void closeChildUnusedResourceAfterFork (void),server.c,"void closeChildUnusedResourceAfterFork(void) {
    closeListeningSockets(0);
    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)
        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */

    /* Clear server.pidfile, this is the parent pidfile which should not
     * be touched (or deleted) by the child (on exit / crash) */
    zfree(server.pidfile);
    server.pidfile = NULL;
}",6578.0,6587.0,1.0,1.0,10.0,9,5,6,2,1,12,2,2,4,2,,0,10,2,1,1,void
6451,388628,redisFork,1,redisFork,int redisFork (int),server.c,"int redisFork(int purpose) {
    if (isMutuallyExclusiveChildType(purpose)) {
        if (hasActiveChildProcess()) {
            errno = EEXIST;
            return -1;
        }

        openChildInfoPipe();
    }

    int childpid;
    long long start = ustime();
    if ((childpid = fork()) == 0) {
        /* Child.
         *
         * The order of setting things up follows some reasoning:
         * Setup signal handlers first because a signal could fire at any time.
         * Adjust OOM score before everything else to assist the OOM killer if
         * memory resources are low.
         */
        server.in_fork_child = purpose;
        setupChildSignalHandlers();
        setOOMScoreAdj(CONFIG_OOM_BGCHILD);
        updateDictResizePolicy();
        dismissMemoryInChild();
        closeChildUnusedResourceAfterFork();
        /* Close the reading part, so that if the parent crashes, the child will
         * get a write error and exit. */
        if (server.child_info_pipe[0] !...",6590.0,6658.0,1.0,23.0,69.0,13,6,10,6,5,15,5,7,4,9,,0,9,2,1,1,int
6452,388821,sendChildCowInfo,1,sendChildCowInfo,"void sendChildCowInfo (childInfoType,char*)",server.c,"void sendChildCowInfo(childInfoType info_type, char *pname) {
    sendChildInfoGeneric(info_type, 0, -1, pname);
}",6660.0,6662.0,1.0,1.0,3.0,1,1,2,2,4,1,1,1,0,1,,0,0,4,2,2,void
6453,388833,sendChildInfo,1,sendChildInfo,"void sendChildInfo (childInfoType,size_t,char*)",server.c,"void sendChildInfo(childInfoType info_type, size_t keys, char *pname) {
    sendChildInfoGeneric(info_type, keys, -1, pname);
}",6664.0,6666.0,1.0,1.0,3.0,1,1,3,3,2,1,1,1,0,1,,0,0,6,3,3,void
6454,388846,dismissMemory,1,dismissMemory,"void dismissMemory (void*,size_t)",server.c,"void dismissMemory(void* ptr, size_t size_hint) {
    if (ptr == NULL) return;

    /* madvise(MADV_DONTNEED) can not release pages if the size of memory
     * is too small, we try to release only for the memory which the size
     * is more than half of page size. */
    if (size_hint && size_hint <= server.page_size/2) return;

    zmadvise_dontneed(ptr);
}",6677.0,6686.0,1.0,1.0,10.0,5,5,6,4,12,3,3,3,2,1,,0,2,4,2,2,void
6455,388872,dismissClientMemory,1,dismissClientMemory,void dismissClientMemory (client*),server.c,"void dismissClientMemory(client *c) {
    /* Dismiss client query buffer and static reply buffer. */
    dismissMemory(c->buf, c->buf_usable_size);
    dismissSds(c->querybuf);
    /* Dismiss argv array only if we estimate it contains a big buffer. */
    if (c->argc && c->argv_len_sum/c->argc >= server.page_size) {
        for (int i = 0; i < c->argc; i++) {
            dismissObject(c->argv[i], 0);
        }
    }
    if (c->argc) dismissMemory(c->argv, c->argc*sizeof(robj*));

    /* Dismiss the reply array only if the average buffer size is bigger
     * than a page. */
    if (listLength(c->reply) &&
        c->reply_bytes/listLength(c->reply) >= server.page_size)
    {
        listIter li;
        listNode *ln;
        listRewind(c->reply, &li);
        while ((ln = listNext(&li))) {
            clientReplyBlock *bulk = listNodeValue(ln);
            /* Default bulk size is 16k, actually it has extra data, maybe it
             * occupies 20k according to jemalloc bin size if ...",6689.0,6716.0,1.0,8.0,28.0,38,11,32,7,0,30,7,11,15,7,,0,24,2,1,1,void
6456,389004,dismissMemoryInChild,1,dismissMemoryInChild,void dismissMemoryInChild (void),server.c,"void dismissMemoryInChild(void) {
    /* madvise(MADV_DONTNEED) may not work if Transparent Huge Pages is enabled. */
    if (server.thp_enabled) return;

    /* Currently we use zmadvise_dontneed only when we use jemalloc with Linux.
     * so we avoid these pointless loops when they're not going to do anything. */
#if defined(USE_JEMALLOC) && defined(__linux__)
    listIter li;
    listNode *ln;

    /* Dismiss replication buffer. We don't need to separately dismiss replication
     * backlog and replica' output buffer, because they just reference the global
     * replication buffer but don't cost real memory. */
    listRewind(server.repl_buffer_blocks, &li);
    while((ln = listNext(&li))) {
        replBufBlock *o = listNodeValue(ln);
        dismissMemory(o, o->size);
    }

    /* Dismiss all clients memory. */
    listRewind(server.clients, &li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        dismissClientMemory(c);
    }
#endif
}",6722.0,6748.0,1.0,1.0,27.0,1,1,1,1,1,2,2,2,2,0,,0,2,2,1,1,void
6457,389021,checkForSentinelMode,1,checkForSentinelMode,"int checkForSentinelMode (int,char**,char*)",server.c,"int checkForSentinelMode(int argc, char **argv, char *exec_name) {
    if (strstr(exec_name,""redis-sentinel"") != NULL) return 1;

    for (int j = 1; j < argc; j++)
        if (!strcmp(argv[j],""--sentinel"")) return 1;
    return 0;
}",6754.0,6760.0,1.0,1.0,7.0,3,3,5,4,0,0,3,3,0,0,,0,0,6,3,3,int
6458,389060,loadDataFromDisk,1,loadDataFromDisk,void loadDataFromDisk (void),server.c,"void loadDataFromDisk(void) {
    long long start = ustime();
    if (server.aof_state == AOF_ON) {
        int ret = loadAppendOnlyFiles(server.aof_manifest);
        if (ret == AOF_FAILED || ret == AOF_OPEN_ERR)
            exit(1);
        if (ret != AOF_NOT_EXIST)
            serverLog(LL_NOTICE, ""DB loaded from append only file: %.3f seconds"", (float)(ustime()-start)/1000000);
    } else {
        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
        int rsi_is_valid = 0;
        errno = 0; /* Prevent a stale value from affecting error checking */
        int rdb_flags = RDBFLAGS_NONE;
        if (iAmMaster()) {
            /* Master may delete expired keys when loading, we should
             * propagate expire to replication backlog. */
            createReplicationBacklog();
            rdb_flags |= RDBFLAGS_FEED_REPL;
        }
        int rdb_load_ret = rdbLoad(server.rdb_filename, &rsi, rdb_flags);
        if (rdb_load_ret == RDB_OK) {
            serverLog(LL_NOTICE,""DB loaded f...",6763.0,6832.0,1.0,28.0,70.0,15,10,9,3,0,10,4,6,2,4,,0,9,2,1,1,void
6459,389375,redisOutOfMemoryHandler,1,redisOutOfMemoryHandler,void redisOutOfMemoryHandler (size_t),server.c,"void redisOutOfMemoryHandler(size_t allocation_size) {
    serverLog(LL_WARNING,""Out Of Memory allocating %zu bytes!"",
        allocation_size);
    serverPanic(""Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"",
        allocation_size);
}",6834.0,6839.0,1.0,4.0,6.0,4,4,3,2,0,4,1,1,0,2,,0,2,2,1,1,void
6460,389408,redisProcTitleGetVariable,1,redisProcTitleGetVariable,"sds redisProcTitleGetVariable (sds,void*)",server.c,"static sds redisProcTitleGetVariable(const sds varname, void *arg)
{
    if (!strcmp(varname, ""title"")) {
        return sdsnew(arg);
    } else if (!strcmp(varname, ""listen-addr"")) {
        if (server.port || server.tls_port)
            return sdscatprintf(sdsempty(), ""%s:%u"",
                                server.bindaddr_count ? server.bindaddr[0] : ""*"",
                                server.port ? server.port : server.tls_port);
        else
            return sdscatprintf(sdsempty(), ""unixsocket:%s"", server.unixsocket);
    } else if (!strcmp(varname, ""server-mode"")) {
        if (server.cluster_enabled) return sdsnew(""[cluster]"");
        else if (server.sentinel_mode) return sdsnew(""[sentinel]"");
        else return sdsempty();
    } else if (!strcmp(varname, ""config-file"")) {
        return sdsnew(server.configfile ? server.configfile : ""-"");
    } else if (!strcmp(varname, ""port"")) {
        return sdscatprintf(sdsempty(), ""%u"", server.port);
    } else if (!strcmp(varn...",6844.0,6869.0,1.0,1.0,26.0,1,1,2,2,0,1,2,2,0,1,,0,0,4,2,2,sds
6461,389568,expandProcTitleTemplate,1,expandProcTitleTemplate,"sds expandProcTitleTemplate (char*,char*)",server.c,"static sds expandProcTitleTemplate(const char *template, const char *title) {
    sds res = sdstemplate(template, redisProcTitleGetVariable, (void *) title);
    if (!res)
        return NULL;
    return sdstrim(res, "" "");
}",6873.0,6878.0,1.0,1.0,6.0,3,3,6,4,1,2,2,2,0,2,,0,1,4,2,2,sds
6462,389593,validateProcTitleTemplate,1,validateProcTitleTemplate,int validateProcTitleTemplate (char*),server.c,"int validateProcTitleTemplate(const char *template) {
    int ok = 1;
    sds res = expandProcTitleTemplate(template, """");
    if (!res)
        return 0;
    if (sdslen(res) == 0) ok = 0;
    sdsfree(res);
    return ok;
}",6880.0,6888.0,1.0,1.0,9.0,5,3,8,3,1,3,3,3,1,3,,0,2,2,1,1,int
6463,389627,redisSetProcTitle,1,redisSetProcTitle,int redisSetProcTitle (char*),server.c,"int redisSetProcTitle(char *title) {
#ifdef USE_SETPROCTITLE
    if (!title) title = server.exec_argv[0];
    sds proc_title = expandProcTitleTemplate(server.proc_title_template, title);
    if (!proc_title) return C_ERR;  /* Not likely, proc_title_template is validated */

    setproctitle(""%s"", proc_title);
    sdsfree(proc_title);
#else
    UNUSED(title);
#endif

    return C_OK;
}",6890.0,6903.0,1.0,4.0,14.0,1,1,2,1,7,0,1,1,0,0,,0,0,2,1,1,int
6464,389642,redisSetCpuAffinity,1,redisSetCpuAffinity,void redisSetCpuAffinity (char*),server.c,"void redisSetCpuAffinity(const char *cpulist) {
#ifdef USE_SETCPUAFFINITY
    setcpuaffinity(cpulist);
#else
    UNUSED(cpulist);
#endif
}",6905.0,6911.0,1.0,4.0,7.0,1,1,2,1,4,0,1,1,0,0,,0,0,2,1,1,void
6465,389653,redisCommunicateSystemd,1,redisCommunicateSystemd,int redisCommunicateSystemd (char*),server.c,"int redisCommunicateSystemd(const char *sd_notify_msg) {
#ifdef HAVE_LIBSYSTEMD
    int ret = sd_notify(0, sd_notify_msg);

    if (ret == 0)
        serverLog(LL_WARNING, ""systemd supervision error: NOTIFY_SOCKET not found!"");
    else if (ret < 0)
        serverLog(LL_WARNING, ""systemd supervision error: sd_notify: %d"", ret);
    return ret;
#else
    UNUSED(sd_notify_msg);
    return 0;
#endif
}",6915.0,6928.0,1.0,4.0,14.0,1,1,2,1,3,0,1,1,0,0,,0,0,2,1,1,int
6466,389666,redisSupervisedUpstart,1,redisSupervisedUpstart,int redisSupervisedUpstart (void),server.c,"static int redisSupervisedUpstart(void) {
    const char *upstart_job = getenv(""UPSTART_JOB"");

    if (!upstart_job) {
        serverLog(LL_WARNING,
                ""upstart supervision requested, but UPSTART_JOB not found!"");
        return 0;
    }

    serverLog(LL_NOTICE, ""supervised by upstart, will stop to signal readiness."");
    raise(SIGSTOP);
    unsetenv(""UPSTART_JOB"");
    return 1;
}",6931.0,6944.0,1.0,8.0,14.0,8,5,5,3,1,6,2,2,0,2,,0,4,2,1,1,int
6467,389724,redisSupervisedSystemd,1,redisSupervisedSystemd,int redisSupervisedSystemd (void),server.c,"static int redisSupervisedSystemd(void) {
#ifndef HAVE_LIBSYSTEMD
    serverLog(LL_WARNING,
            ""systemd supervision requested or auto-detected, but Redis is compiled without libsystemd support!"");
    return 0;
#else
    if (redisCommunicateSystemd(""STATUS=Redis is loading...\n"") <= 0)
        return 0;
    serverLog(LL_NOTICE,
        ""Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit."");
    return 1;
#endif
}",6947.0,6959.0,1.0,4.0,13.0,3,3,1,1,1,3,1,1,0,1,,0,2,2,1,1,int
6468,389749,redisIsSupervised,1,redisIsSupervised,int redisIsSupervised (int),server.c,"int redisIsSupervised(int mode) {
    int ret = 0;

    if (mode == SUPERVISED_AUTODETECT) {
        if (getenv(""UPSTART_JOB"")) {
            serverLog(LL_VERBOSE, ""Upstart supervision detected."");
            mode = SUPERVISED_UPSTART;
        } else if (getenv(""NOTIFY_SOCKET"")) {
            serverLog(LL_VERBOSE, ""Systemd supervision detected."");
            mode = SUPERVISED_SYSTEMD;
        }
    }

    switch (mode) {
        case SUPERVISED_UPSTART:
            ret = redisSupervisedUpstart();
            break;
        case SUPERVISED_SYSTEMD:
            ret = redisSupervisedSystemd();
            break;
        default:
            break;
    }

    if (ret)
        server.supervised_mode = mode;

    return ret;
}",6961.0,6989.0,1.0,16.0,29.0,10,5,11,3,0,7,8,6,0,3,,0,6,2,1,1,int
6469,389852,iAmMaster,1,iAmMaster,int iAmMaster (void),server.c,"int iAmMaster(void) {
    return ((!server.cluster_enabled && server.masterhost == NULL) ||
            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));
}",6991.0,6994.0,1.0,39.0,4.0,14,7,6,2,2,10,1,1,0,0,,0,10,2,1,1,int
6470,391017,moduleTypeLoadFunc,1,moduleTypeLoadFunc,"void* moduleTypeLoadFunc (RedisModuleIO*,int)",server.h,"typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);",737.0,737.0,14.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
6471,391023,moduleTypeSaveFunc,1,moduleTypeSaveFunc,"void moduleTypeSaveFunc (RedisModuleIO*,void*)",server.h,"typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);",738.0,738.0,14.0,73.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6472,391029,moduleTypeAuxLoadFunc,1,moduleTypeAuxLoadFunc,"int moduleTypeAuxLoadFunc (RedisModuleIO*,int,int)",server.h,"typedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);",739.0,739.0,13.0,85.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
6473,391036,moduleTypeAuxSaveFunc,1,moduleTypeAuxSaveFunc,"void moduleTypeAuxSaveFunc (RedisModuleIO*,int)",server.h,"typedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);",740.0,740.0,14.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6474,391042,moduleTypeRewriteFunc,1,moduleTypeRewriteFunc,"void moduleTypeRewriteFunc (RedisModuleIO*,redisObject*,void*)",server.h,"typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);",741.0,741.0,14.0,101.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6475,391049,moduleTypeDigestFunc,1,moduleTypeDigestFunc,"void moduleTypeDigestFunc (RedisModuleDigest*,void*)",server.h,"typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);",742.0,742.0,14.0,83.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6476,391055,moduleTypeMemUsageFunc,1,moduleTypeMemUsageFunc,size_t moduleTypeMemUsageFunc (void*),server.h,typedef size_t (*moduleTypeMemUsageFunc)(const void *value);,743.0,743.0,16.0,59.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,size_t
6477,391060,moduleTypeFreeFunc,1,moduleTypeFreeFunc,void moduleTypeFreeFunc (void*),server.h,typedef void (*moduleTypeFreeFunc)(void *value);,744.0,744.0,14.0,47.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6478,391065,moduleTypeFreeEffortFunc,1,moduleTypeFreeEffortFunc,"size_t moduleTypeFreeEffortFunc (redisObject*,void*)",server.h,"typedef size_t (*moduleTypeFreeEffortFunc)(struct redisObject *key, const void *value);",745.0,745.0,16.0,86.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,size_t
6479,391071,moduleTypeUnlinkFunc,1,moduleTypeUnlinkFunc,"void moduleTypeUnlinkFunc (redisObject*,void*)",server.h,"typedef void (*moduleTypeUnlinkFunc)(struct redisObject *key, void *value);",746.0,746.0,14.0,74.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6480,391077,moduleTypeCopyFunc,1,moduleTypeCopyFunc,"void* moduleTypeCopyFunc (redisObject*,redisObject*,void*)",server.h,"typedef void *(*moduleTypeCopyFunc)(struct redisObject *fromkey, struct redisObject *tokey, const void *value);",747.0,747.0,14.0,110.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void*
6481,391084,moduleTypeDefragFunc,1,moduleTypeDefragFunc,"int moduleTypeDefragFunc (RedisModuleDefragCtx*,redisObject*,void**)",server.h,"typedef int (*moduleTypeDefragFunc)(struct RedisModuleDefragCtx *ctx, struct redisObject *key, void **value);",748.0,748.0,13.0,108.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
6482,391091,moduleTypeMemUsageFunc2,1,moduleTypeMemUsageFunc2,"size_t moduleTypeMemUsageFunc2 (RedisModuleKeyOptCtx*,void*,size_t)",server.h,"typedef size_t (*moduleTypeMemUsageFunc2)(struct RedisModuleKeyOptCtx *ctx, const void *value, size_t sample_size);",749.0,749.0,16.0,114.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,size_t
6483,391098,moduleTypeFreeFunc2,1,moduleTypeFreeFunc2,"void moduleTypeFreeFunc2 (RedisModuleKeyOptCtx*,void*)",server.h,"typedef void (*moduleTypeFreeFunc2)(struct RedisModuleKeyOptCtx *ctx, void *value);",750.0,750.0,14.0,82.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6484,391104,moduleTypeFreeEffortFunc2,1,moduleTypeFreeEffortFunc2,"size_t moduleTypeFreeEffortFunc2 (RedisModuleKeyOptCtx*,void*)",server.h,"typedef size_t (*moduleTypeFreeEffortFunc2)(struct RedisModuleKeyOptCtx *ctx, const void *value);",751.0,751.0,16.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,size_t
6485,391110,moduleTypeUnlinkFunc2,1,moduleTypeUnlinkFunc2,"void moduleTypeUnlinkFunc2 (RedisModuleKeyOptCtx*,void*)",server.h,"typedef void (*moduleTypeUnlinkFunc2)(struct RedisModuleKeyOptCtx *ctx, void *value);",752.0,752.0,14.0,84.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6486,391116,moduleTypeCopyFunc2,1,moduleTypeCopyFunc2,"void* moduleTypeCopyFunc2 (RedisModuleKeyOptCtx*,void*)",server.h,"typedef void *(*moduleTypeCopyFunc2)(struct RedisModuleKeyOptCtx *ctx, const void *value);",753.0,753.0,14.0,89.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void*
6487,391122,moduleTypeAuthCallback,1,moduleTypeAuthCallback,"int moduleTypeAuthCallback (RedisModuleCtx*,void*,void*,char**)",server.h,"typedef int (*moduleTypeAuthCallback)(struct RedisModuleCtx *ctx, void *username, void *password, const char **err);",754.0,754.0,13.0,115.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
6488,392334,redisCommandProc,1,redisCommandProc,void redisCommandProc (client*),server.h,typedef void redisCommandProc(client *c);,2215.0,2215.0,14.0,40.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6489,392339,redisGetKeysProc,1,redisGetKeysProc,"int redisGetKeysProc (redisCommand*,robj**,int,getKeysResult*)",server.h,"typedef int redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",2216.0,2216.0,13.0,100.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
6490,392769,getRandomHexChars,1,getRandomHexChars,"void getRandomHexChars (char*,size_t)",util.c,"void getRandomHexChars(char *p, size_t len) {
    char *charset = ""0123456789abcdef"";
    size_t j;

    getRandomBytes((unsigned char*)p,len);
    for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];
}",928.0,934.0,1.0,1.0,7.0,0,0,0,0,7,0,1,1,0,0,,0,0,4,2,2,void
6491,392775,getRandomBytes,1,getRandomBytes,"void getRandomBytes (unsigned char*,size_t)",util.c,"void getRandomBytes(unsigned char *p, size_t len) {
    /* Global state. */
    static int seed_initialized = 0;
    static unsigned char seed[64]; /* 512 bit internal block size. */
    static uint64_t counter = 0; /* The counter we hash with the seed. */

    if (!seed_initialized) {
        /* Initialize a seed and use SHA1 in counter mode, where we hash
         * the same seed with a progressive counter. For the goals of this
         * function we just need non-colliding strings, there are no
         * cryptographic security needs. */
        FILE *fp = fopen(""/dev/urandom"",""r"");
        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {
            /* Revert to a weaker seed, and in this case reseed again
             * at every call.*/
            for (unsigned int j = 0; j < sizeof(seed); j++) {
                struct timeval tv;
                gettimeofday(&tv,NULL);
                pid_t pid = getpid();
                seed[j] = tv.tv_sec ^ tv.tv_usec ^ pid ^ (long...",860.0,922.0,1.0,29.0,63.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6492,393179,addListRangeReply,1,addListRangeReply,"void addListRangeReply (client*,robj*,long,long,int)",t_list.c,"void addListRangeReply(client *c, robj *o, long start, long end, int reverse) {
    long rangelen, llen = listTypeLength(o);

    /* Convert negative indexes. */
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;

    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        addReply(c,shared.emptyarray);
        return;
    }
    if (end >= llen) end = llen-1;
    rangelen = (end-start)+1;

    int from = reverse ? end : start;
    if (o->encoding == OBJ_ENCODING_QUICKLIST)
        addListQuicklistRangeReply(c, o, from, rangelen, reverse);
    else if (o->encoding == OBJ_ENCODING_LISTPACK)
        addListListpackRangeReply(c, o, from, rangelen, reverse);
    else
        serverPanic(""Unknown list encoding"");
}",727.0,751.0,1.0,23.0,25.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
6493,393219,getClientSockName,1,getClientSockName,char* getClientSockName (client*),server.h,char *getClientSockName(client *client);,2602.0,2602.0,6.0,39.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,char*
6494,393499,enableTracking,1,enableTracking,"void enableTracking (client*,uint64_t,uint64_t,robj**,size_t)",tracking.c,"void enableTracking(client *c, uint64_t redirect_to, uint64_t options, robj **prefix, size_t numprefix) {
    if (!(c->flags & CLIENT_TRACKING)) server.tracking_clients++;
    c->flags |= CLIENT_TRACKING;
    c->flags &= ~(CLIENT_TRACKING_BROKEN_REDIR|CLIENT_TRACKING_BCAST|
                  CLIENT_TRACKING_OPTIN|CLIENT_TRACKING_OPTOUT|
                  CLIENT_TRACKING_NOLOOP);
    c->client_tracking_redirection = redirect_to;

    /* This may be the first client we ever enable. Create the tracking
     * table if it does not exist. */
    if (TrackingTable == NULL) {
        TrackingTable = raxNew();
        PrefixTable = raxNew();
        TrackingChannelName = createStringObject(""__redis__:invalidate"",20);
    }

    /* For broadcasting, set the list of prefixes in the client. */
    if (options & CLIENT_TRACKING_BCAST) {
        c->flags |= CLIENT_TRACKING_BCAST;
        if (numprefix == 0) enableBcastTrackingForPrefix(c,"""",0);
        for (size_t j = 0; j < numprefix; j++) {
  ...",180.0,209.0,1.0,21.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6495,393508,disableTracking,1,disableTracking,void disableTracking (client*),tracking.c,"void disableTracking(client *c) {
    /* If this client is in broadcasting mode, we need to unsubscribe it
     * from all the prefixes it is registered to. */
    if (c->flags & CLIENT_TRACKING_BCAST) {
        raxIterator ri;
        raxStart(&ri,c->client_tracking_prefixes);
        raxSeek(&ri,""^"",NULL,0);
        while(raxNext(&ri)) {
            bcastState *bs = raxFind(PrefixTable,ri.key,ri.key_len);
            serverAssert(bs != raxNotFound);
            raxRemove(bs->clients,(unsigned char*)&c,sizeof(c),NULL);
            /* Was it the last client? Remove the prefix from the
             * table. */
            if (raxSize(bs->clients) == 0) {
                raxFree(bs->clients);
                raxFree(bs->keys);
                zfree(bs);
                raxRemove(PrefixTable,ri.key,ri.key_len,NULL);
            }
        }
        raxStop(&ri);
        raxFree(c->client_tracking_prefixes);
        c->client_tracking_prefixes = NULL;
    }

    /* Clear flags and adjust...",67.0,100.0,1.0,19.0,34.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
6496,393513,trackingRememberKeys,1,trackingRememberKeys,"void trackingRememberKeys (client*,client*)",tracking.c,"void trackingRememberKeys(client *tracking, client *executing) {
    /* Return if we are in optin/out mode and the right CACHING command
     * was/wasn't given in order to modify the default behavior. */
    uint64_t optin = tracking->flags & CLIENT_TRACKING_OPTIN;
    uint64_t optout = tracking->flags & CLIENT_TRACKING_OPTOUT;
    uint64_t caching_given = tracking->flags & CLIENT_TRACKING_CACHING;
    if ((optin && !caching_given) || (optout && caching_given)) return;

    getKeysResult result = GETKEYS_RESULT_INIT;
    int numkeys = getKeysFromCommand(executing->cmd,executing->argv,executing->argc,&result);
    if (!numkeys) {
        getKeysFreeResult(&result);
        return;
    }
    /* Shard channels are treated as special keys for client
     * library to rely on `COMMAND` command to discover the node
     * to connect to. These channels doesn't need to be tracked. */
    if (executing->cmd->flags & CMD_PUBSUB) {
        return;
    }

    keyReference *keys = result.keys;
...",217.0,254.0,1.0,39.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6497,393519,trackingInvalidateKey,1,trackingInvalidateKey,"void trackingInvalidateKey (client*,robj*,int)",tracking.c,"void trackingInvalidateKey(client *c, robj *keyobj, int bcast) {
    if (TrackingTable == NULL) return;

    unsigned char *key = (unsigned char*)keyobj->ptr;
    size_t keylen = sdslen(keyobj->ptr);

    if (bcast && raxSize(PrefixTable) > 0)
        trackingRememberKeyToBroadcast(c,(char *)key,keylen);

    rax *ids = raxFind(TrackingTable,key,keylen);
    if (ids == raxNotFound) return;

    raxIterator ri;
    raxStart(&ri,ids);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        uint64_t id;
        memcpy(&id,ri.key,sizeof(id));
        client *target = lookupClientByID(id);
        /* Note that if the client is in BCAST mode, we don't want to
         * send invalidation messages that were pending in the case
         * previously the client was not in BCAST mode. This can happen if
         * TRACKING is enabled normally, and then the client switches to
         * BCAST mode. */
        if (target == NULL ||
            !(target->flags & CLIENT_TRACKING)||
       ...",366.0,422.0,1.0,30.0,57.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
6498,393526,trackingScheduleKeyInvalidation,1,trackingScheduleKeyInvalidation,"void trackingScheduleKeyInvalidation (uint64_t,robj*)",server.h,"void trackingScheduleKeyInvalidation(uint64_t client_id, robj *keyobj);",2672.0,2672.0,6.0,70.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6499,393532,trackingHandlePendingKeyInvalidations,1,trackingHandlePendingKeyInvalidations,void trackingHandlePendingKeyInvalidations (void),tracking.c,"void trackingHandlePendingKeyInvalidations(void) {
    if (!listLength(server.tracking_pending_keys)) return;

    /* Flush pending invalidation messages only when we are not in nested call.
     * So the messages are not interleaved with transaction response. */
    if (server.execution_nesting) return;

    listNode *ln;
    listIter li;

    listRewind(server.tracking_pending_keys,&li);
    while ((ln = listNext(&li)) != NULL) {
        robj *key = listNodeValue(ln);
        /* current_client maybe freed, so we need to send invalidation
         * message only when current_client is still alive */
        if (server.current_client != NULL) {
            if (key != NULL) {
                sendTrackingMessage(server.current_client,(char *)key->ptr,sdslen(key->ptr),0);
            } else {
                sendTrackingMessage(server.current_client,shared.null[server.current_client->resp]->ptr,
                    sdslen(shared.null[server.current_client->resp]->ptr),1);
            }...",424.0,450.0,1.0,9.0,27.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
6500,393537,trackingInvalidateKeysOnFlush,1,trackingInvalidateKeysOnFlush,void trackingInvalidateKeysOnFlush (int),tracking.c,"void trackingInvalidateKeysOnFlush(int async) {
    if (server.tracking_clients) {
        listNode *ln;
        listIter li;
        listRewind(server.clients,&li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = listNodeValue(ln);
            if (c->flags & CLIENT_TRACKING) {
                if (c == server.current_client) {
                    /* We use a special NULL to indicate that we should send null */
                    listAddNodeTail(server.tracking_pending_keys,NULL);
                } else {
                    sendTrackingMessage(c,shared.null[c->resp]->ptr,sdslen(shared.null[c->resp]->ptr),1);
                }
            }
        }
    }

    /* In case of FLUSHALL, reclaim all the memory used by tracking. */
    if (TrackingTable) {
        if (async) {
            freeTrackingRadixTreeAsync(TrackingTable);
        } else {
            freeTrackingRadixTree(TrackingTable);
        }
        TrackingTable = raxNew();
        TrackingTableTot...",468.0,496.0,1.0,24.0,29.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
6501,393542,freeTrackingRadixTree,1,freeTrackingRadixTree,void freeTrackingRadixTree (rax*),tracking.c,"void freeTrackingRadixTree(rax *rt) {
    raxFreeWithCallback(rt,freeTrackingRadixTreeCallback);
}",463.0,465.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6502,393552,trackingLimitUsedSlots,1,trackingLimitUsedSlots,void trackingLimitUsedSlots (void),tracking.c,"void trackingLimitUsedSlots(void) {
    static unsigned int timeout_counter = 0;
    if (TrackingTable == NULL) return;
    if (server.tracking_table_max_keys == 0) return; /* No limits set. */
    size_t max_keys = server.tracking_table_max_keys;
    if (raxSize(TrackingTable) <= max_keys) {
        timeout_counter = 0;
        return; /* Limit not reached. */
    }

    /* We have to invalidate a few keys to reach the limit again. The effort
     * we do here is proportional to the number of times we entered this
     * function and found that we are still over the limit. */
    int effort = 100 * (timeout_counter+1);

    /* We just remove one key after another by using a random walk. */
    raxIterator ri;
    raxStart(&ri,TrackingTable);
    while(effort > 0) {
        effort--;
        raxSeek(&ri,""^"",NULL,0);
        raxRandomWalk(&ri,0);
        if (raxEOF(&ri)) break;
        robj *keyobj = createStringObject((char*)ri.key,ri.key_len);
        trackingInvalidateKey(NULL,key...",508.0,545.0,1.0,1.0,38.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,void
6503,393557,trackingGetTotalItems,1,trackingGetTotalItems,uint64_t trackingGetTotalItems (void),tracking.c,"uint64_t trackingGetTotalItems(void) {
    return TrackingTableTotalItems;
}",648.0,650.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
6504,393562,trackingGetTotalKeys,1,trackingGetTotalKeys,uint64_t trackingGetTotalKeys (void),tracking.c,"uint64_t trackingGetTotalKeys(void) {
    if (TrackingTable == NULL) return 0;
    return raxSize(TrackingTable);
}",652.0,655.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
6505,393567,trackingGetTotalPrefixes,1,trackingGetTotalPrefixes,uint64_t trackingGetTotalPrefixes (void),tracking.c,"uint64_t trackingGetTotalPrefixes(void) {
    if (PrefixTable == NULL) return 0;
    return raxSize(PrefixTable);
}",657.0,660.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
6506,393572,trackingBroadcastInvalidationMessages,1,trackingBroadcastInvalidationMessages,void trackingBroadcastInvalidationMessages (void),tracking.c,"void trackingBroadcastInvalidationMessages(void) {
    raxIterator ri, ri2;

    /* Return ASAP if there is nothing to do here. */
    if (TrackingTable == NULL || !server.tracking_clients) return;

    raxStart(&ri,PrefixTable);
    raxSeek(&ri,""^"",NULL,0);

    /* For each prefix... */
    while(raxNext(&ri)) {
        bcastState *bs = ri.data;

        if (raxSize(bs->keys)) {
            /* Generate the common protocol for all the clients that are
             * not using the NOLOOP option. */
            sds proto = trackingBuildBroadcastReply(NULL,bs->keys);

            /* Send this array of keys to every client in the list. */
            raxStart(&ri2,bs->clients);
            raxSeek(&ri2,""^"",NULL,0);
            while(raxNext(&ri2)) {
                client *c;
                memcpy(&c,ri2.key,sizeof(c));
                if (c->flags & CLIENT_TRACKING_NOLOOP) {
                    /* This client may have certain keys excluded. */
                    sds adhoc = trackingB...",598.0,644.0,1.0,31.0,47.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6507,393577,checkPrefixCollisionsOrReply,1,checkPrefixCollisionsOrReply,"int checkPrefixCollisionsOrReply (client*,robj**,size_t)",tracking.c,"int checkPrefixCollisionsOrReply(client *c, robj **prefixes, size_t numprefix) {
    for (size_t i = 0; i < numprefix; i++) {
        /* Check input list has no overlap with existing prefixes. */
        if (c->client_tracking_prefixes) {
            raxIterator ri;
            raxStart(&ri,c->client_tracking_prefixes);
            raxSeek(&ri,""^"",NULL,0);
            while(raxNext(&ri)) {
                if (stringCheckPrefix(ri.key,ri.key_len,
                    prefixes[i]->ptr,sdslen(prefixes[i]->ptr))) 
                {
                    sds collision = sdsnewlen(ri.key,ri.key_len);
                    addReplyErrorFormat(c,
                        ""Prefix '%s' overlaps with an existing prefix '%s'. ""
                        ""Prefixes for a single client must not overlap."",
                        (unsigned char *)prefixes[i]->ptr,
                        (unsigned char *)collision);
                    sdsfree(collision);
                    raxStop(&ri);
                 ...",112.0,151.0,1.0,1.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
6508,393584,listTypePush,1,listTypePush,"void listTypePush (robj*,robj*,int)",t_list.c,"void listTypePush(robj *subject, robj *value, int where) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;
        if (value->encoding == OBJ_ENCODING_INT) {
            char buf[32];
            ll2string(buf, 32, (long)value->ptr);
            quicklistPush(subject->ptr, buf, strlen(buf), pos);
        } else {
            quicklistPush(subject->ptr, value->ptr, sdslen(value->ptr), pos);
        }
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        if (value->encoding == OBJ_ENCODING_INT) {
            subject->ptr = (where == LIST_HEAD) ?
                lpPrependInteger(subject->ptr, (long)value->ptr) :
                lpAppendInteger(subject->ptr, (long)value->ptr);
        } else {
            subject->ptr = (where == LIST_HEAD) ?
                lpPrepend(subject->ptr, value->ptr, sdslen(value->ptr)) :
                lpAppend(subject->ptr, value->ptr, sdslen(value->ptr));
      ...",166.0,189.0,1.0,29.0,24.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,void
6509,393591,listTypePop,1,listTypePop,"robj* listTypePop (robj*,int)",t_list.c,"robj *listTypePop(robj *subject, int where) {
    robj *value = NULL;

    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        long long vlong;
        int ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;
        if (quicklistPopCustom(subject->ptr, ql_where, (unsigned char **)&value,
                               NULL, &vlong, listPopSaver)) {
            if (!value)
                value = createStringObjectFromLongLong(vlong);
        }
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p;
        unsigned char *vstr;
        int64_t vlen;
        unsigned char intbuf[LP_INTBUF_SIZE];

        p = (where == LIST_HEAD) ? lpFirst(subject->ptr) : lpLast(subject->ptr);
        if (p) {
            vstr = lpGet(p, &vlen, intbuf);
            value = createStringObject((char*)vstr, vlen);
            subject->ptr = lpDelete(subject->ptr, p, NULL);
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
    retu...",195.0,222.0,1.0,29.0,28.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,robj
6510,393597,listTypeLength,1,listTypeLength,long unsigned listTypeLength (robj*),t_list.c,"unsigned long listTypeLength(const robj *subject) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistCount(subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        return lpLength(subject->ptr);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",224.0,232.0,1.0,29.0,9.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,unsigned long
6511,393602,listTypeInitIterator,1,listTypeInitIterator,"listTypeIterator* listTypeInitIterator (robj*,long,unsigned char)",t_list.c,"listTypeIterator *listTypeInitIterator(robj *subject, long index,
                                       unsigned char direction) {
    listTypeIterator *li = zmalloc(sizeof(listTypeIterator));
    li->subject = subject;
    li->encoding = subject->encoding;
    li->direction = direction;
    li->iter = NULL;
    /* LIST_HEAD means start at TAIL and move *towards* head.
     * LIST_TAIL means start at HEAD and move *towards* tail. */
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        int iter_direction = direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
        li->iter = quicklistGetIteratorAtIdx(li->subject->ptr,
                                             iter_direction, index);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        li->lpi = lpSeek(subject->ptr, index);
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return li;
}",235.0,254.0,1.0,24.0,20.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,listTypeIterator
6512,393609,listTypeReleaseIterator,1,listTypeReleaseIterator,void listTypeReleaseIterator (listTypeIterator*),t_list.c,"void listTypeReleaseIterator(listTypeIterator *li) {
    if (li->encoding == OBJ_ENCODING_QUICKLIST)
        quicklistReleaseIterator(li->iter);
    zfree(li);
}",275.0,279.0,1.0,24.0,5.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,void
6513,393614,listTypeSetIteratorDirection,1,listTypeSetIteratorDirection,"void listTypeSetIteratorDirection (listTypeIterator*,listTypeEntry*,unsigned char)",t_list.c,"void listTypeSetIteratorDirection(listTypeIterator *li, listTypeEntry *entry, unsigned char direction) {
    if (li->direction == direction) return;

    li->direction = direction;
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        int dir = direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
        quicklistSetDirection(li->iter, dir);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = li->subject->ptr;
        /* Note that the iterator for listpack always points to the next of the current entry,
         * so we need to update position of the iterator depending on the direction. */
        li->lpi = (direction == LIST_TAIL) ? lpNext(lp, entry->lpe) : lpPrev(lp, entry->lpe);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",257.0,272.0,1.0,24.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
6514,393621,listTypeNext,1,listTypeNext,"int listTypeNext (listTypeIterator*,listTypeEntry*)",t_list.c,"int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {
    /* Protect from converting when iterating */
    serverAssert(li->subject->encoding == li->encoding);

    entry->li = li;
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistNext(li->iter, &entry->entry);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        entry->lpe = li->lpi;
        if (entry->lpe != NULL) {
            li->lpi = (li->direction == LIST_TAIL) ?
                lpNext(li->subject->ptr,li->lpi) : lpPrev(li->subject->ptr,li->lpi);
            return 1;
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return 0;
}",284.0,302.0,1.0,4.0,19.0,0,0,0,0,5,0,1,1,0,0,,0,0,4,2,2,int
6515,393627,listTypeGet,1,listTypeGet,robj* listTypeGet (listTypeEntry*),t_list.c,"robj *listTypeGet(listTypeEntry *entry) {
    unsigned char *vstr;
    size_t vlen;
    long long lval;

    vstr = listTypeGetValue(entry, &vlen, &lval);
    if (vstr) 
        return createStringObject((char *)vstr, vlen);
    else
        return createStringObjectFromLongLong(lval);
}",328.0,338.0,1.0,1.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,robj
6516,393632,listTypeGetValue,1,listTypeGetValue,"unsigned char* listTypeGetValue (listTypeEntry*,size_t*,long long*)",t_list.c,"unsigned char *listTypeGetValue(listTypeEntry *entry, size_t *vlen, long long *lval) {
    unsigned char *vstr = NULL;
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        if (entry->entry.value) {
            vstr = entry->entry.value;
            *vlen = entry->entry.sz;
        } else {
            *lval = entry->entry.longval;
        }
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned int slen;
        vstr = lpGetValue(entry->lpe, &slen, lval);
        *vlen = slen;
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return vstr;
}",308.0,325.0,1.0,31.0,18.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,unsigned char*
6517,393639,listTypeInsert,1,listTypeInsert,"void listTypeInsert (listTypeEntry*,robj*,int)",t_list.c,"void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
    robj *subject = entry->li->subject;
    value = getDecodedObject(value);
    sds str = value->ptr;
    size_t len = sdslen(str);

    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        if (where == LIST_TAIL) {
            quicklistInsertAfter(entry->li->iter, &entry->entry, str, len);
        } else if (where == LIST_HEAD) {
            quicklistInsertBefore(entry->li->iter, &entry->entry, str, len);
        }
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        int lpw = (where == LIST_TAIL) ? LP_AFTER : LP_BEFORE;
        subject->ptr = lpInsertString(subject->ptr, (unsigned char *)str,
                                      len, entry->lpe, lpw, &entry->lpe);
    } else {
        serverPanic(""Unknown list encoding"");
    }
    decrRefCount(value);
}",340.0,360.0,1.0,31.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
6518,393646,listTypeReplace,1,listTypeReplace,"void listTypeReplace (listTypeEntry*,robj*)",t_list.c,"void listTypeReplace(listTypeEntry *entry, robj *value) {
    robj *subject = entry->li->subject;
    value = getDecodedObject(value);
    sds str = value->ptr;
    size_t len = sdslen(str);

    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistReplaceEntry(entry->li->iter, &entry->entry, str, len);
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        subject->ptr = lpReplace(subject->ptr, &entry->lpe, (unsigned char *)str, len);
    } else {
        serverPanic(""Unknown list encoding"");
    }

    decrRefCount(value);
}",363.0,378.0,1.0,31.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6519,393652,listTypeEqual,1,listTypeEqual,"int listTypeEqual (listTypeEntry*,robj*)",t_list.c,"int listTypeEqual(listTypeEntry *entry, robj *o) {
    serverAssertWithInfo(NULL,o,sdsEncodedObject(o));
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistCompare(&entry->entry,o->ptr,sdslen(o->ptr));
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        return lpCompare(entry->lpe,o->ptr,sdslen(o->ptr));
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",408.0,417.0,1.0,4.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
6520,393658,listTypeDelete,1,listTypeDelete,"void listTypeDelete (listTypeIterator*,listTypeEntry*)",t_list.c,"void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistDelEntry(iter->iter, &entry->entry);
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p = entry->lpe;
        iter->subject->ptr = lpDelete(iter->subject->ptr,p,&p);

        /* Update position of the iterator depending on the direction */
        if (iter->direction == LIST_TAIL)
            iter->lpi = p;
        else {
            if (p) {
                iter->lpi = lpPrev(iter->subject->ptr,p);
            } else {
                /* We deleted the last element, so we need to set the
                 * iterator to the last element. */
                iter->lpi = lpLast(iter->subject->ptr);
            }
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",420.0,442.0,1.0,31.0,23.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6521,393664,listTypeDup,1,listTypeDup,robj* listTypeDup (robj*),t_list.c,"robj *listTypeDup(robj *o) {
    robj *lobj;

    serverAssert(o->type == OBJ_LIST);

    switch (o->encoding) {
        case OBJ_ENCODING_LISTPACK:
            lobj = createObject(OBJ_LIST, lpDup(o->ptr));
            break;
        case OBJ_ENCODING_QUICKLIST:
            lobj = createObject(OBJ_LIST, quicklistDup(o->ptr));
            break;
        default:
            serverPanic(""Unknown list encoding"");
            break;
    }
    lobj->encoding = o->encoding;
    return lobj;
}",449.0,467.0,1.0,4.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
6522,393669,listTypeDelRange,1,listTypeDelRange,"void listTypeDelRange (robj*,long,long)",t_list.c,"void listTypeDelRange(robj *subject, long start, long count) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistDelRange(subject->ptr, start, count);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        subject->ptr = lpDeleteRange(subject->ptr, start, count);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",470.0,478.0,1.0,29.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
6523,393676,popGenericCommand,1,popGenericCommand,"void popGenericCommand (client*,int)",t_list.c,"void popGenericCommand(client *c, int where) {
    int hascount = (c->argc == 3);
    long count = 0;
    robj *value;

    if (c->argc > 3) {
        addReplyErrorArity(c);
        return;
    } else if (hascount) {
        /* Parse the optional count argument. */
        if (getPositiveLongFromObjectOrReply(c,c->argv[2],&count,NULL) != C_OK) 
            return;
    }

    robj *o = lookupKeyWriteOrReply(c, c->argv[1], hascount ? shared.nullarray[c->resp]: shared.null[c->resp]);
    if (o == NULL || checkType(c, o, OBJ_LIST))
        return;

    if (hascount && !count) {
        /* Fast exit path. */
        addReply(c,shared.emptyarray);
        return;
    }

    if (!count) {
        /* Pop a single element. This is POP's original behavior that replies
         * with a bulk string. */
        value = listTypePop(o,where);
        serverAssert(value != NULL);
        addReplyBulk(c,value);
        decrRefCount(value);
        listElementsRemoved(c,c->argv[1],where,o,1,1,NULL);...",780.0,825.0,1.0,74.0,46.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6524,393682,listElementsRemoved,1,listElementsRemoved,"void listElementsRemoved (client*,robj*,int,robj*,long,int,int*)",t_list.c,"void listElementsRemoved(client *c, robj *key, int where, robj *o, long count, int signal, int *deleted) {
    char *event = (where == LIST_HEAD) ? ""lpop"" : ""rpop"";

    notifyKeyspaceEvent(NOTIFY_LIST, event, key, c->db->id);
    if (listTypeLength(o) == 0) {
        if (deleted) *deleted = 1;

        dbDelete(c->db, key);
        notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", key, c->db->id);
    } else {
        listTypeTryConversion(o, LIST_CONV_SHRINKING, NULL, NULL);
        if (deleted) *deleted = 0;
    }
    if (signal) signalModifiedKey(c, c->db, key);
    server.dirty += count;
}",759.0,774.0,1.0,28.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,14,7,7,void
6525,393698,beforeConvertCB,1,beforeConvertCB,void beforeConvertCB (void*),server.h,typedef void (*beforeConvertCB)(void *data);,2707.0,2707.0,14.0,43.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6526,393703,listTypeTryConversion,1,listTypeTryConversion,"void listTypeTryConversion (robj*,list_conv_type,beforeConvertCB,void*)",t_list.c,"void listTypeTryConversion(robj *o, list_conv_type lct, beforeConvertCB fn, void *data) {
    listTypeTryConversionRaw(o, lct, NULL, 0, 0, fn, data);
}",149.0,151.0,1.0,1.0,3.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,void
6527,393711,listTypeTryConversionAppend,1,listTypeTryConversionAppend,"void listTypeTryConversionAppend (robj*,robj**,int,int,beforeConvertCB,void*)",t_list.c,"void listTypeTryConversionAppend(robj *o, robj **argv, int start, int end,
                                 beforeConvertCB fn, void *data)
{
    listTypeTryConversionRaw(o, LIST_CONV_GROWING, argv, start, end, fn, data);
}",155.0,159.0,1.0,1.0,5.0,0,0,0,0,5,0,1,1,0,0,,0,0,12,6,6,void
6528,394099,syncWrite,1,syncWrite,"ssize_t syncWrite (int,char*,ssize_t,long long)",syncio.c,"ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nwritten, ret = size;
    long long start = mstime();
    long long remaining = timeout;

    while(1) {
        long long wait = (remaining > SYNCIO__RESOLUTION) ?
                          remaining : SYNCIO__RESOLUTION;
        long long elapsed;

        /* Optimistically try to write before checking if the file descriptor
         * is actually writable. At worst we get EAGAIN. */
        nwritten = write(fd,ptr,size);
        if (nwritten == -1) {
            if (errno != EAGAIN) return -1;
        } else {
            ptr += nwritten;
            size -= nwritten;
        }
        if (size == 0) return ret;

        /* Wait */
        aeWait(fd,AE_WRITABLE,wait);
        elapsed = mstime() - start;
        if (elapsed >= timeout) {
            errno = ETIMEDOUT;
            return -1;
        }
        remaining = timeout - elapsed;
    }
}",49.0,79.0,1.0,38.0,31.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ssize_t
6529,394107,syncRead,1,syncRead,"ssize_t syncRead (int,char*,ssize_t,long long)",syncio.c,"ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nread, totread = 0;
    long long start = mstime();
    long long remaining = timeout;

    if (size == 0) return 0;
    while(1) {
        long long wait = (remaining > SYNCIO__RESOLUTION) ?
                          remaining : SYNCIO__RESOLUTION;
        long long elapsed;

        /* Optimistically try to read before checking if the file descriptor
         * is actually readable. At worst we get EAGAIN. */
        nread = read(fd,ptr,size);
        if (nread == 0) return -1; /* short read. */
        if (nread == -1) {
            if (errno != EAGAIN) return -1;
        } else {
            ptr += nread;
            size -= nread;
            totread += nread;
        }
        if (size == 0) return totread;

        /* Wait */
        aeWait(fd,AE_READABLE,wait);
        elapsed = mstime() - start;
        if (elapsed >= timeout) {
            errno = ETIMEDOUT;
            return -1;
        }
...",85.0,118.0,1.0,38.0,34.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ssize_t
6530,394115,syncReadLine,1,syncReadLine,"ssize_t syncReadLine (int,char*,ssize_t,long long)",syncio.c,"ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nread = 0;

    size--;
    while(size) {
        char c;

        if (syncRead(fd,&c,1,timeout) == -1) return -1;
        if (c == '\n') {
            *ptr = '\0';
            if (nread && *(ptr-1) == '\r') *(ptr-1) = '\0';
            return nread;
        } else {
            *ptr++ = c;
            *ptr = '\0';
            nread++;
        }
        size--;
    }
    return nread;
}",125.0,145.0,1.0,1.0,21.0,0,0,0,0,2,0,1,1,0,0,,0,0,8,4,4,ssize_t
6531,394285,feedReplicationBacklog,1,feedReplicationBacklog,"void feedReplicationBacklog (void*,size_t)",server.h,"void feedReplicationBacklog(void *ptr, size_t len);",2818.0,2818.0,6.0,50.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6532,394759,zslCreate,1,zslCreate,zskiplist* zslCreate (void),t_zset.c,"zskiplist *zslCreate(void) {
    int j;
    zskiplist *zsl;

    zsl = zmalloc(sizeof(*zsl));
    zsl->level = 1;
    zsl->length = 0;
    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
        zsl->header->level[j].forward = NULL;
        zsl->header->level[j].span = 0;
    }
    zsl->header->backward = NULL;
    zsl->tail = NULL;
    return zsl;
}",82.0,97.0,1.0,32.0,16.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,zskiplist
6533,394764,zslFree,1,zslFree,void zslFree (zskiplist*),t_zset.c,"void zslFree(zskiplist *zsl) {
    zskiplistNode *node = zsl->header->level[0].forward, *next;

    zfree(zsl->header);
    while(node) {
        next = node->level[0].forward;
        zslFreeNode(node);
        node = next;
    }
    zfree(zsl);
}",108.0,118.0,1.0,1.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6534,394769,zslInsert,1,zslInsert,"zskiplistNode* zslInsert (zskiplist*,double,sds)",t_zset.c,"zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    /* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside o...",135.0,190.0,1.0,26.0,56.0,0,0,0,0,3,0,1,1,0,0,,0,0,6,3,3,zskiplistNode
6535,394776,zzlInsert,1,zzlInsert,"unsigned char* zzlInsert (unsigned char*,sds,double)",t_zset.c,"unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;
    double s;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);
        s = zzlGetScore(sptr);

        if (s > score) {
            /* First element with score larger than score for element to be
             * inserted. This means we should take its spot in the list to
             * maintain ordering. */
            zl = zzlInsertAt(zl,eptr,ele,score);
            break;
        } else if (s == score) {
            /* Ensure lexicographical ordering for elements. */
            if (zzlCompareElements(eptr,(unsigned char*)ele,sdslen(ele)) > 0) {
                zl = zzlInsertAt(zl,eptr,ele,score);
                break;
            }
        }

        /* Move to next element. */
        eptr = lpNext(zl,sptr);
    }

    /* Push on tail of list when it was not yet inserted. */
    if (eptr == NULL)
        zl = zzlInsert...",1059.0,1090.0,1.0,8.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,unsigned char*
6536,394783,zslDelete,1,zslDelete,"int zslDelete (zskiplist*,double,sds,zskiplistNode**)",t_zset.c,"int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    /* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. */
    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    return 0; /* not found */
}",222.0,249.0,1.0,26.0,28.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
6537,394791,zslFirstInRange,1,zslFirstInRange,"zskiplistNode* zslFirstInRange (zskiplist*,zrangespec*)",t_zset.c,"zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *OUT* of range. */
        while (x->level[i].forward &&
            !zslValueGteMin(x->level[i].forward->score,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so the next node cannot be NULL. */
    x = x->level[0].forward;
    serverAssert(x != NULL);

    /* Check if score <= max. */
    if (!zslValueLteMax(x->score,range)) return NULL;
    return x;
}",333.0,355.0,1.0,4.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,zskiplistNode
6538,394797,zslLastInRange,1,zslLastInRange,"zskiplistNode* zslLastInRange (zskiplist*,zrangespec*)",t_zset.c,"zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *IN* range. */
        while (x->level[i].forward &&
            zslValueLteMax(x->level[i].forward->score,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so this node cannot be NULL. */
    serverAssert(x != NULL);

    /* Check if score >= min. */
    if (!zslValueGteMin(x->score,range)) return NULL;
    return x;
}",359.0,380.0,1.0,4.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,zskiplistNode
6539,394803,zzlGetScore,1,zzlGetScore,double zzlGetScore (unsigned char*),t_zset.c,"double zzlGetScore(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    double score;

    serverAssert(sptr != NULL);
    vstr = lpGetValue(sptr,&vlen,&vlong);

    if (vstr) {
        score = zzlStrtod(vstr,vlen);
    } else {
        score = vlong;
    }

    return score;
}",733.0,749.0,1.0,4.0,17.0,0,0,0,0,10,0,1,1,0,0,,0,0,2,1,1,double
6540,394808,zzlNext,1,zzlNext,"void zzlNext (unsigned char*,unsigned char**,unsigned char**)",t_zset.c,"void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
    unsigned char *_eptr, *_sptr;
    serverAssert(*eptr != NULL && *sptr != NULL);

    _eptr = lpNext(zl,*sptr);
    if (_eptr != NULL) {
        _sptr = lpNext(zl,_eptr);
        serverAssert(_sptr != NULL);
    } else {
        /* No next entry. */
        _sptr = NULL;
    }

    *eptr = _eptr;
    *sptr = _sptr;
}",794.0,809.0,1.0,4.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,6,3,3,void
6541,394815,zzlPrev,1,zzlPrev,"void zzlPrev (unsigned char*,unsigned char**,unsigned char**)",t_zset.c,"void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
    unsigned char *_eptr, *_sptr;
    serverAssert(*eptr != NULL && *sptr != NULL);

    _sptr = lpPrev(zl,*eptr);
    if (_sptr != NULL) {
        _eptr = lpPrev(zl,_sptr);
        serverAssert(_eptr != NULL);
    } else {
        /* No previous entry. */
        _eptr = NULL;
    }

    *eptr = _eptr;
    *sptr = _sptr;
}",813.0,828.0,1.0,4.0,16.0,0,0,0,0,5,0,1,1,0,0,,0,0,6,3,3,void
6542,394828,zzlLastInRange,1,zzlLastInRange,"unsigned char* zzlLastInRange (unsigned char*,zrangespec*)",t_zset.c,"unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *eptr = lpSeek(zl,-2), *sptr;
    double score;

    /* If everything is out of range, return early. */
    if (!zzlIsInRange(zl,range)) return NULL;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueLteMax(score,range)) {
            /* Check if score >= min. */
            if (zslValueGteMin(score,range))
                return eptr;
            return NULL;
        }

        /* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */
        sptr = lpPrev(zl,eptr);
        if (sptr != NULL)
            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);
        else
            eptr = NULL;
    }

    return NULL;
}",886.0,915.0,1.0,8.0,30.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,unsigned char*
6543,394834,zsetLength,1,zsetLength,long unsigned zsetLength (robj*),t_zset.c,"unsigned long zsetLength(const robj *zobj) {
    unsigned long length = 0;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        length = zzlLength(zobj->ptr);
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        length = ((const zset*)zobj->ptr)->zsl->length;
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return length;
}",1157.0,1167.0,1.0,26.0,11.0,0,0,0,0,9,0,1,1,0,0,,0,0,2,1,1,unsigned long
6544,394839,zsetConvert,1,zsetConvert,"void zsetConvert (robj*,int)",t_zset.c,"void zsetConvert(robj *zobj, int encoding) {
    zsetConvertAndExpand(zobj, encoding, zsetLength(zobj));
}",1202.0,1204.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6545,394845,zsetConvertToListpackIfNeeded,1,zsetConvertToListpackIfNeeded,"void zsetConvertToListpackIfNeeded (robj*,size_t,size_t)",t_zset.c,"void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;
    zset *zset = zobj->ptr;

    if (zset->zsl->length <= server.zset_max_listpack_entries &&
        maxelelen <= server.zset_max_listpack_value &&
        lpSafeToAdd(NULL, totelelen))
    {
        zsetConvert(zobj,OBJ_ENCODING_LISTPACK);
    }
}",1285.0,1295.0,1.0,26.0,11.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
6546,394852,zsetScore,1,zsetScore,"int zsetScore (robj*,sds,double*)",t_zset.c,"int zsetScore(robj *zobj, sds member, double *score) {
    if (!zobj || !member) return C_ERR;

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        dictEntry *de = dictFind(zs->dict, member);
        if (de == NULL) return C_ERR;
        *score = *(double*)dictGetVal(de);
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return C_OK;
}",1301.0,1315.0,1.0,33.0,15.0,0,0,0,0,6,0,1,1,0,0,,0,0,6,3,3,int
6547,394859,zslGetRank,1,zslGetRank,"long unsigned zslGetRank (zskiplist*,double,sds)",t_zset.c,"unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    unsigned long rank = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                sdscmp(x->level[i].forward->ele,ele) <= 0))) {
            rank += x->level[i].span;
            x = x->level[i].forward;
        }

        /* x might be equal to zsl->header, so test if obj is non-NULL */
        if (x->ele && x->score == score && sdscmp(x->ele,ele) == 0) {
            return rank;
        }
    }
    return 0;
}",478.0,499.0,1.0,1.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,unsigned long
6548,394866,zsetAdd,1,zsetAdd,"int zsetAdd (robj*,double,sds,int,int*,double*)",t_zset.c,"int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {
    /* Turn options into simple to check vars. */
    int incr = (in_flags & ZADD_IN_INCR) != 0;
    int nx = (in_flags & ZADD_IN_NX) != 0;
    int xx = (in_flags & ZADD_IN_XX) != 0;
    int gt = (in_flags & ZADD_IN_GT) != 0;
    int lt = (in_flags & ZADD_IN_LT) != 0;
    *out_flags = 0; /* We'll return our response flags. */
    double curscore;

    /* NaN as input is an error regardless of all the other parameters. */
    if (isnan(score)) {
        *out_flags = ZADD_OUT_NAN;
        return 0;
    }

    /* Update the sorted set according to its encoding. */
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr;

        if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
            /* NX? Return, same element already exists. */
            if (nx) {
                *out_flags |= ZADD_OUT_NOP;
                return 1;
            }

            /* Prepa...",1362.0,1492.0,1.0,27.0,131.0,0,0,0,0,5,0,1,1,0,0,,0,0,12,6,6,int
6549,394876,zsetRank,1,zsetRank,"long zsetRank (robj*,sds,int,double*)",t_zset.c,"long zsetRank(robj *zobj, sds ele, int reverse, double *output_score) {
    unsigned long llen;
    unsigned long rank;

    llen = zsetLength(zobj);

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;

        eptr = lpSeek(zl,0);
        serverAssert(eptr != NULL);
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        rank = 1;
        while(eptr != NULL) {
            if (lpCompare(eptr,(unsigned char*)ele,sdslen(ele)))
                break;
            rank++;
            zzlNext(zl,&eptr,&sptr);
        }

        if (eptr != NULL) {
            if (output_score) 
                *output_score = zzlGetScore(sptr);
            if (reverse)
                return llen-rank;
            else
                return rank-1;
        } else {
            return -1;
        }
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        zskiplist *zsl = z...",1557.0,1614.0,1.0,26.0,58.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,long
6550,394884,zsetDel,1,zsetDel,"int zsetDel (robj*,sds)",t_zset.c,"int zsetDel(robj *zobj, sds ele) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr;

        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {
            zobj->ptr = zzlDelete(zobj->ptr,eptr);
            return 1;
        }
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        if (zsetRemoveFromSkiplist(zs, ele)) {
            if (htNeedsResize(zs->dict)) dictResize(zs->dict);
            return 1;
        }
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return 0; /* No such element found. */
}",1526.0,1544.0,1.0,26.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
6551,394890,zsetDup,1,zsetDup,robj* zsetDup (robj*),t_zset.c,"robj *zsetDup(robj *o) {
    robj *zobj;
    zset *zs;
    zset *new_zs;

    serverAssert(o->type == OBJ_ZSET);

    /* Create a new sorted set object that have the same encoding as the original object's encoding */
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        size_t sz = lpBytes(zl);
        unsigned char *new_zl = zmalloc(sz);
        memcpy(new_zl, zl, sz);
        zobj = createObject(OBJ_ZSET, new_zl);
        zobj->encoding = OBJ_ENCODING_LISTPACK;
    } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
        zobj = createZsetObject();
        zs = o->ptr;
        new_zs = zobj->ptr;
        dictExpand(new_zs->dict,dictSize(zs->dict));
        zskiplist *zsl = zs->zsl;
        zskiplistNode *ln;
        sds ele;
        long llen = zsetLength(o);

        /* We copy the skiplist elements from the greatest to the
         * smallest (that's trivial since the elements are already ordered in
         * the skiplist): this improves t...",1621.0,1664.0,1.0,4.0,44.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
6552,394895,genericZpopCommand,1,genericZpopCommand,"void genericZpopCommand (client*,robj**,int,int,int,long,int,int,int*)",t_zset.c,"void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey,
                        long count, int use_nested_array, int reply_nil_when_empty, int *deleted) {
    int idx;
    robj *key = NULL;
    robj *zobj = NULL;
    sds ele;
    double score;

    if (deleted) *deleted = 0;

    /* Check type and break on the first error, otherwise identify candidate. */
    idx = 0;
    while (idx < keyc) {
        key = keyv[idx++];
        zobj = lookupKeyWrite(c->db,key);
        if (!zobj) continue;
        if (checkType(c,zobj,OBJ_ZSET)) return;
        break;
    }

    /* No candidate for zpopping, return empty. */
    if (!zobj) {
        if (reply_nil_when_empty) {
            addReplyNullArray(c);
        } else {
            addReply(c,shared.emptyarray);
        }
        return;
    }

    if (count == 0) {
        /* ZPOPMIN/ZPOPMAX with count 0. */
        addReply(c, shared.emptyarray);
        return;
    }

    long result_count = 0;

    /* When count ...",3891.0,4025.0,1.0,29.0,135.0,0,0,0,0,2,0,1,1,0,0,,0,0,18,9,9,void
6553,394908,lpGetObject,1,lpGetObject,sds lpGetObject (unsigned char*),t_zset.c,"sds lpGetObject(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;

    serverAssert(sptr != NULL);
    vstr = lpGetValue(sptr,&vlen,&vlong);

    if (vstr) {
        return sdsnewlen((char*)vstr,vlen);
    } else {
        return sdsfromlonglong(vlong);
    }
}",752.0,765.0,1.0,4.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,sds
6554,394913,zslValueGteMin,1,zslValueGteMin,"int zslValueGteMin (double,zrangespec*)",t_zset.c,"int zslValueGteMin(double value, zrangespec *spec) {
    return spec->minex ? (value > spec->min) : (value >= spec->min);
}",306.0,308.0,1.0,1.0,3.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
6555,394925,zslFreeLexRange,1,zslFreeLexRange,void zslFreeLexRange (zlexrangespec*),t_zset.c,"void zslFreeLexRange(zlexrangespec *spec) {
    if (spec->min != shared.minstring &&
        spec->min != shared.maxstring) sdsfree(spec->min);
    if (spec->max != shared.minstring &&
        spec->max != shared.maxstring) sdsfree(spec->max);
}",602.0,607.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6556,394930,zslParseLexRange,1,zslParseLexRange,"int zslParseLexRange (robj*,robj*,zlexrangespec*)",t_zset.c,"int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
    /* The range can't be valid if objects are integer encoded.
     * Every item must start with ( or [. */
    if (min->encoding == OBJ_ENCODING_INT ||
        max->encoding == OBJ_ENCODING_INT) return C_ERR;

    spec->min = spec->max = NULL;
    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
        zslFreeLexRange(spec);
        return C_ERR;
    } else {
        return C_OK;
    }
}",614.0,628.0,1.0,25.0,15.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int
6557,394937,zzlFirstInLexRange,1,zzlFirstInLexRange,"unsigned char* zzlFirstInLexRange (unsigned char*,zlexrangespec*)",t_zset.c,"unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;

    /* If everything is out of range, return early. */
    if (!zzlIsInLexRange(zl,range)) return NULL;

    while (eptr != NULL) {
        if (zzlLexValueGteMin(eptr,range)) {
            /* Check if score <= max. */
            if (zzlLexValueLteMax(eptr,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        sptr = lpNext(zl,eptr); /* This element score. Skip it. */
        serverAssert(sptr != NULL);
        eptr = lpNext(zl,sptr); /* Next element. */
    }

    return NULL;
}",956.0,977.0,1.0,8.0,22.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,unsigned char*
6558,394943,zzlLastInLexRange,1,zzlLastInLexRange,"unsigned char* zzlLastInLexRange (unsigned char*,zlexrangespec*)",t_zset.c,"unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *eptr = lpSeek(zl,-2), *sptr;

    /* If everything is out of range, return early. */
    if (!zzlIsInLexRange(zl,range)) return NULL;

    while (eptr != NULL) {
        if (zzlLexValueLteMax(eptr,range)) {
            /* Check if score >= min. */
            if (zzlLexValueGteMin(eptr,range))
                return eptr;
            return NULL;
        }

        /* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */
        sptr = lpPrev(zl,eptr);
        if (sptr != NULL)
            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);
        else
            eptr = NULL;
    }

    return NULL;
}",981.0,1005.0,1.0,12.0,25.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,unsigned char*
6559,394949,zslFirstInLexRange,1,zslFirstInLexRange,"zskiplistNode* zslFirstInLexRange (zskiplist*,zlexrangespec*)",t_zset.c,"zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInLexRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *OUT* of range. */
        while (x->level[i].forward &&
            !zslLexValueGteMin(x->level[i].forward->ele,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so the next node cannot be NULL. */
    x = x->level[0].forward;
    serverAssert(x != NULL);

    /* Check if score <= max. */
    if (!zslLexValueLteMax(x->ele,range)) return NULL;
    return x;
}",671.0,693.0,1.0,4.0,23.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,zskiplistNode
6560,394955,zslLastInLexRange,1,zslLastInLexRange,"zskiplistNode* zslLastInLexRange (zskiplist*,zlexrangespec*)",t_zset.c,"zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInLexRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *IN* range. */
        while (x->level[i].forward &&
            zslLexValueLteMax(x->level[i].forward->ele,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so this node cannot be NULL. */
    serverAssert(x != NULL);

    /* Check if score >= min. */
    if (!zslLexValueGteMin(x->ele,range)) return NULL;
    return x;
}",697.0,718.0,1.0,4.0,22.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,zskiplistNode
6561,394961,zzlLexValueGteMin,1,zzlLexValueGteMin,"int zzlLexValueGteMin (unsigned char*,zlexrangespec*)",t_zset.c,"int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
    sds value = lpGetObject(p);
    int res = zslLexValueGteMin(value,spec);
    sdsfree(value);
    return res;
}",917.0,922.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
6562,394967,zzlLexValueLteMax,1,zzlLexValueLteMax,"int zzlLexValueLteMax (unsigned char*,zlexrangespec*)",t_zset.c,"int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
    sds value = lpGetObject(p);
    int res = zslLexValueLteMax(value,spec);
    sdsfree(value);
    return res;
}",924.0,929.0,1.0,1.0,6.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
6563,394973,zslLexValueGteMin,1,zslLexValueGteMin,"int zslLexValueGteMin (sds,zlexrangespec*)",t_zset.c,"int zslLexValueGteMin(sds value, zlexrangespec *spec) {
    return spec->minex ?
        (sdscmplex(value,spec->min) > 0) :
        (sdscmplex(value,spec->min) >= 0);
}",640.0,644.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
6564,394979,zslLexValueLteMax,1,zslLexValueLteMax,"int zslLexValueLteMax (sds,zlexrangespec*)",t_zset.c,"int zslLexValueLteMax(sds value, zlexrangespec *spec) {
    return spec->maxex ?
        (sdscmplex(value,spec->max) < 0) :
        (sdscmplex(value,spec->max) <= 0);
}",646.0,650.0,1.0,1.0,5.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
6565,395080,startCommandExecution,1,startCommandExecution,void startCommandExecution (void),server.h,void startCommandExecution(void);,3033.0,3033.0,6.0,32.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6566,395334,setTypeCreate,1,setTypeCreate,"robj* setTypeCreate (sds,size_t)",t_set.c,"robj *setTypeCreate(sds value, size_t size_hint) {
    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK && size_hint <= server.set_max_intset_entries)
        return createIntsetObject();
    if (size_hint <= server.set_max_listpack_entries)
        return createSetListpackObject();

    /* We may oversize the set by using the hint if the hint is not accurate,
     * but we will assume this is acceptable to maximize performance. */
    robj *o = createSetObject();
    dictExpand(o->ptr, size_hint);
    return o;
}",46.0,57.0,1.0,52.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,robj
6567,395340,setTypeAdd,1,setTypeAdd,"int setTypeAdd (robj*,sds)",t_set.c,"int setTypeAdd(robj *subject, sds value) {
    return setTypeAddAux(subject, value, sdslen(value), 0, 1);
}",115.0,117.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
6568,395346,setTypeAddAux,1,setTypeAddAux,"int setTypeAddAux (robj*,char*,size_t,int64_t,int)",t_set.c,"int setTypeAddAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (set->encoding == OBJ_ENCODING_INTSET) {
            uint8_t success = 0;
            set->ptr = intsetAdd(set->ptr, llval, &success);
            if (success) maybeConvertIntset(set);
            return success;
        }
        /* Convert int to string. */
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    serverAssert(str);
    if (set->encoding == OBJ_ENCODING_HT) {
        /* Avoid duping the string if it is an sds string. */
        sds sdsval = str_is_sds ? (sds)str : sdsnewlen(str, len);
        dict *ht = set->ptr;
        void *position = dictFindPositionForInsert(ht, sdsval, NULL);
        if (position) {
            /* Key doesn't already exist in the set. Add it but dup the key. */
            if (sdsval == str) sdsval = sdsdup(sdsval);
            dictInsertAtPositio...",125.0,229.0,1.0,16.0,105.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
6569,395355,setTypeRemove,1,setTypeRemove,"int setTypeRemove (robj*,sds)",t_set.c,"int setTypeRemove(robj *setobj, sds value) {
    return setTypeRemoveAux(setobj, value, sdslen(value), 0, 1);
}",233.0,235.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
6570,395361,setTypeRemoveAux,1,setTypeRemoveAux,"int setTypeRemoveAux (robj*,char*,size_t,int64_t,int)",t_set.c,"int setTypeRemoveAux(robj *setobj, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (setobj->encoding == OBJ_ENCODING_INTSET) {
            int success;
            setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
            return success;
        }
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    if (setobj->encoding == OBJ_ENCODING_HT) {
        sds sdsval = str_is_sds ? (sds)str : sdsnewlen(str, len);
        int deleted = (dictDelete(setobj->ptr, sdsval) == DICT_OK);
        if (deleted && htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
        if (sdsval != str) sdsfree(sdsval); /* free temp copy */
        return deleted;
    } else if (setobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = setobj->ptr;
        unsigned char *p = lpFirst(lp);
        if (p == NULL) return 0;
        p = lpFind(lp, p, (unsigned char*)st...",243.0,283.0,1.0,16.0,41.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,int
6571,395370,setTypeIsMember,1,setTypeIsMember,"int setTypeIsMember (robj*,sds)",t_set.c,"int setTypeIsMember(robj *subject, sds value) {
    return setTypeIsMemberAux(subject, value, sdslen(value), 0, 1);
}",287.0,289.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,int
6572,395376,setTypeIsMemberAux,1,setTypeIsMemberAux,"int setTypeIsMemberAux (robj*,char*,size_t,int64_t,int)",t_set.c,"int setTypeIsMemberAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (set->encoding == OBJ_ENCODING_INTSET)
            return intsetFind(set->ptr, llval);
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    if (set->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = set->ptr;
        unsigned char *p = lpFirst(lp);
        return p && lpFind(lp, p, (unsigned char*)str, len, 0);
    } else if (set->encoding == OBJ_ENCODING_INTSET) {
        long long llval;
        return string2ll(str, len, &llval) && intsetFind(set->ptr, llval);
    } else if (set->encoding == OBJ_ENCODING_HT && str_is_sds) {
        return dictFind(set->ptr, (sds)str) != NULL;
    } else if (set->encoding == OBJ_ENCODING_HT) {
        sds sdsval = sdsnewlen(str, len);
        int result = dictFind(set->ptr, sdsval) != NULL;
        sdsfree(sdsval);
        retur...",297.0,324.0,1.0,16.0,28.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,int
6573,395385,setTypeInitIterator,1,setTypeInitIterator,setTypeIterator* setTypeInitIterator (robj*),t_set.c,"setTypeIterator *setTypeInitIterator(robj *subject) {
    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
    si->subject = subject;
    si->encoding = subject->encoding;
    if (si->encoding == OBJ_ENCODING_HT) {
        si->di = dictGetIterator(subject->ptr);
    } else if (si->encoding == OBJ_ENCODING_INTSET) {
        si->ii = 0;
    } else if (si->encoding == OBJ_ENCODING_LISTPACK) {
        si->lpi = NULL;
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return si;
}",326.0,340.0,1.0,24.0,15.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,setTypeIterator
6574,395390,setTypeReleaseIterator,1,setTypeReleaseIterator,void setTypeReleaseIterator (setTypeIterator*),t_set.c,"void setTypeReleaseIterator(setTypeIterator *si) {
    if (si->encoding == OBJ_ENCODING_HT)
        dictReleaseIterator(si->di);
    zfree(si);
}",342.0,346.0,1.0,24.0,5.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
6575,395395,setTypeNext,1,setTypeNext,"int setTypeNext (setTypeIterator*,char**,size_t*,int64_t*)",t_set.c,"int setTypeNext(setTypeIterator *si, char **str, size_t *len, int64_t *llele) {
    if (si->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictNext(si->di);
        if (de == NULL) return -1;
        *str = dictGetKey(de);
        *len = sdslen(*str);
        *llele = -123456789; /* Not needed. Defensive. */
    } else if (si->encoding == OBJ_ENCODING_INTSET) {
        if (!intsetGet(si->subject->ptr,si->ii++,llele))
            return -1;
        *str = NULL;
    } else if (si->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = si->subject->ptr;
        unsigned char *lpi = si->lpi;
        if (lpi == NULL) {
            lpi = lpFirst(lp);
        } else {
            lpi = lpNext(lp, lpi);
        }
        if (lpi == NULL) return -1;
        si->lpi = lpi;
        unsigned int l;
        *str = (char *)lpGetValue(lpi, &l, (long long *)llele);
        *len = (size_t)l;
    } else {
        serverPanic(""Wrong set encoding in setTypeNext"");
    }
    return si-...",369.0,397.0,1.0,24.0,29.0,0,0,0,0,5,0,1,1,0,0,,0,0,8,4,4,int
6576,395403,setTypeNextObject,1,setTypeNextObject,sds setTypeNextObject (setTypeIterator*),t_set.c,"sds setTypeNextObject(setTypeIterator *si) {
    int64_t intele;
    char *str;
    size_t len;

    if (setTypeNext(si, &str, &len, &intele) == -1) return NULL;
    if (str != NULL) return sdsnewlen(str, len);
    return sdsfromlonglong(intele);
}",406.0,414.0,1.0,1.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,sds
6577,395408,setTypeRandomElement,1,setTypeRandomElement,"int setTypeRandomElement (robj*,char**,size_t*,int64_t*)",t_set.c,"int setTypeRandomElement(robj *setobj, char **str, size_t *len, int64_t *llele) {
    if (setobj->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictGetFairRandomKey(setobj->ptr);
        *str = dictGetKey(de);
        *len = sdslen(*str);
        *llele = -123456789; /* Not needed. Defensive. */
    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
        *llele = intsetRandom(setobj->ptr);
        *str = NULL; /* Not needed. Defensive. */
    } else if (setobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = setobj->ptr;
        int r = rand() % lpLength(lp);
        unsigned char *p = lpSeek(lp, r);
        unsigned int l;
        *str = (char *)lpGetValue(p, &l, (long long *)llele);
        *len = (size_t)l;
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return setobj->encoding;
}",429.0,449.0,1.0,28.0,21.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
6578,395416,setTypeSize,1,setTypeSize,long unsigned setTypeSize (robj*),t_set.c,"unsigned long setTypeSize(const robj *subject) {
    if (subject->encoding == OBJ_ENCODING_HT) {
        return dictSize((const dict*)subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        return intsetLen((const intset*)subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        return lpLength((unsigned char *)subject->ptr);
    } else {
        serverPanic(""Unknown set encoding"");
    }
}",480.0,490.0,1.0,29.0,11.0,0,0,0,0,14,0,1,1,0,0,,0,0,2,1,1,unsigned long
6579,395421,setTypeConvert,1,setTypeConvert,"void setTypeConvert (robj*,int)",t_set.c,"void setTypeConvert(robj *setobj, int enc) {
    setTypeConvertAndExpand(setobj, enc, setTypeSize(setobj), 1);
}",495.0,497.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6580,395427,setTypeConvertAndExpand,1,setTypeConvertAndExpand,"int setTypeConvertAndExpand (robj*,int,long unsigned,int)",t_set.c,"int setTypeConvertAndExpand(robj *setobj, int enc, unsigned long cap, int panic) {
    setTypeIterator *si;
    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
                             setobj->encoding != enc);

    if (enc == OBJ_ENCODING_HT) {
        dict *d = dictCreate(&setDictType);
        sds element;

        /* Presize the dict to avoid rehashing */
        if (panic) {
            dictExpand(d, cap);
        } else if (dictTryExpand(d, cap) != DICT_OK) {
            dictRelease(d);
            return C_ERR;
        }

        /* To add the elements we extract integers and create redis objects */
        si = setTypeInitIterator(setobj);
        while ((element = setTypeNextObject(si)) != NULL) {
            serverAssert(dictAdd(d,element,NULL) == DICT_OK);
        }
        setTypeReleaseIterator(si);

        freeSetObject(setobj); /* frees the internals but not setobj itself */
        setobj->encoding = OBJ_ENCODING_HT;
        setobj->ptr = d;
    } el...",503.0,559.0,1.0,4.0,57.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
6581,395435,setTypeDup,1,setTypeDup,robj* setTypeDup (robj*),t_set.c,"robj *setTypeDup(robj *o) {
    robj *set;
    setTypeIterator *si;

    serverAssert(o->type == OBJ_SET);

    /* Create a new set object that have the same encoding as the original object's encoding */
    if (o->encoding == OBJ_ENCODING_INTSET) {
        intset *is = o->ptr;
        size_t size = intsetBlobLen(is);
        intset *newis = zmalloc(size);
        memcpy(newis,is,size);
        set = createObject(OBJ_SET, newis);
        set->encoding = OBJ_ENCODING_INTSET;
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = o->ptr;
        size_t sz = lpBytes(lp);
        unsigned char *new_lp = zmalloc(sz);
        memcpy(new_lp, lp, sz);
        set = createObject(OBJ_SET, new_lp);
        set->encoding = OBJ_ENCODING_LISTPACK;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        set = createSetObject();
        dict *d = o->ptr;
        dictExpand(set->ptr, dictSize(d));
        si = setTypeInitIterator(o);
        char *str;
        size_t len...",566.0,603.0,1.0,4.0,38.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
6582,395440,hashTypeConvert,1,hashTypeConvert,"void hashTypeConvert (robj*,int)",t_hash.c,"void hashTypeConvert(robj *o, int enc) {
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        hashTypeConvertListpack(o, enc);
    } else if (o->encoding == OBJ_ENCODING_HT) {
        serverPanic(""Not implemented"");
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",495.0,503.0,1.0,23.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6583,395446,hashTypeTryConversion,1,hashTypeTryConversion,"void hashTypeTryConversion (robj*,robj**,int,int)",t_hash.c,"void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
    int i;
    size_t sum = 0;

    if (o->encoding != OBJ_ENCODING_LISTPACK) return;

    /* We guess that most of the values in the input are unique, so
     * if there are enough arguments we create a pre-sized hash, which
     * might over allocate memory if there are duplicates. */
    size_t new_fields = (end - start + 1) / 2;
    if (new_fields > server.hash_max_listpack_entries) {
        hashTypeConvert(o, OBJ_ENCODING_HT);
        dictExpand(o->ptr, new_fields);
        return;
    }

    for (i = start; i <= end; i++) {
        if (!sdsEncodedObject(argv[i]))
            continue;
        size_t len = sdslen(argv[i]->ptr);
        if (len > server.hash_max_listpack_value) {
            hashTypeConvert(o, OBJ_ENCODING_HT);
            return;
        }
        sum += len;
    }
    if (!lpSafeToAdd(o->ptr, sum))
        hashTypeConvert(o, OBJ_ENCODING_HT);
}",40.0,68.0,1.0,23.0,29.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,void
6584,395454,hashTypeExists,1,hashTypeExists,"int hashTypeExists (robj*,sds)",t_hash.c,"int hashTypeExists(robj *o, sds field) {
    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;
}",171.0,177.0,1.0,61.0,7.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,int
6585,395460,hashTypeDelete,1,hashTypeDelete,"int hashTypeDelete (robj*,sds)",t_hash.c,"int hashTypeDelete(robj *o, sds field) {
    int deleted = 0;

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl, *fptr;

        zl = o->ptr;
        fptr = lpFirst(zl);
        if (fptr != NULL) {
            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
            if (fptr != NULL) {
                /* Delete both of the key and the value. */
                zl = lpDeleteRangeWithEntry(zl,&fptr,2);
                o->ptr = zl;
                deleted = 1;
            }
        }
    } else if (o->encoding == OBJ_ENCODING_HT) {
        if (dictDelete((dict*)o->ptr, field) == C_OK) {
            deleted = 1;

            /* Always check if the dictionary needs a resize after a delete. */
            if (htNeedsResize(o->ptr)) dictResize(o->ptr);
        }

    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return deleted;
}",275.0,304.0,1.0,23.0,30.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
6586,395466,hashTypeLength,1,hashTypeLength,long unsigned hashTypeLength (robj*),t_hash.c,"unsigned long hashTypeLength(const robj *o) {
    unsigned long length = ULONG_MAX;

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        length = lpLength(o->ptr) / 2;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        length = dictSize((const dict*)o->ptr);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return length;
}",307.0,318.0,1.0,23.0,12.0,0,0,0,0,5,0,1,1,0,0,,0,0,2,1,1,unsigned long
6587,395471,hashTypeInitIterator,1,hashTypeInitIterator,hashTypeIterator* hashTypeInitIterator (robj*),t_hash.c,"hashTypeIterator *hashTypeInitIterator(robj *subject) {
    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));
    hi->subject = subject;
    hi->encoding = subject->encoding;

    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        hi->fptr = NULL;
        hi->vptr = NULL;
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        hi->di = dictGetIterator(subject->ptr);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return hi;
}",320.0,334.0,1.0,24.0,15.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,hashTypeIterator
6588,395476,hashTypeReleaseIterator,1,hashTypeReleaseIterator,void hashTypeReleaseIterator (hashTypeIterator*),t_hash.c,"void hashTypeReleaseIterator(hashTypeIterator *hi) {
    if (hi->encoding == OBJ_ENCODING_HT)
        dictReleaseIterator(hi->di);
    zfree(hi);
}",336.0,340.0,1.0,24.0,5.0,0,0,0,0,6,0,1,1,0,0,,0,0,2,1,1,void
6589,395481,hashTypeNext,1,hashTypeNext,int hashTypeNext (hashTypeIterator*),t_hash.c,"int hashTypeNext(hashTypeIterator *hi) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl;
        unsigned char *fptr, *vptr;

        zl = hi->subject->ptr;
        fptr = hi->fptr;
        vptr = hi->vptr;

        if (fptr == NULL) {
            /* Initialize cursor */
            serverAssert(vptr == NULL);
            fptr = lpFirst(zl);
        } else {
            /* Advance cursor */
            serverAssert(vptr != NULL);
            fptr = lpNext(zl, vptr);
        }
        if (fptr == NULL) return C_ERR;

        /* Grab pointer to the value (fptr points to the field) */
        vptr = lpNext(zl, fptr);
        serverAssert(vptr != NULL);

        /* fptr, vptr now point to the first or next pair */
        hi->fptr = fptr;
        hi->vptr = vptr;
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return C_OK;
}",344.0,377.0,1.0,24.0,34.0,0,0,0,0,4,0,1,1,0,0,,0,0,2,1,1,int
6590,395486,hashTypeCurrentFromListpack,1,hashTypeCurrentFromListpack,"void hashTypeCurrentFromListpack (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)",t_hash.c,"void hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,
                                 unsigned char **vstr,
                                 unsigned int *vlen,
                                 long long *vll)
{
    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);

    if (what & OBJ_HASH_KEY) {
        *vstr = lpGetValue(hi->fptr, vlen, vll);
    } else {
        *vstr = lpGetValue(hi->vptr, vlen, vll);
    }
}",381.0,393.0,1.0,4.0,13.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
6591,395495,hashTypeCurrentFromHashTable,1,hashTypeCurrentFromHashTable,"sds hashTypeCurrentFromHashTable (hashTypeIterator*,int)",t_hash.c,"sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {
    serverAssert(hi->encoding == OBJ_ENCODING_HT);

    if (what & OBJ_HASH_KEY) {
        return dictGetKey(hi->de);
    } else {
        return dictGetVal(hi->de);
    }
}",398.0,406.0,1.0,4.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,sds
6592,395501,hashTypeCurrentObject,1,hashTypeCurrentObject,"void hashTypeCurrentObject (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)",t_hash.c,"void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        *vstr = NULL;
        hashTypeCurrentFromListpack(hi, what, vstr, vlen, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds ele = hashTypeCurrentFromHashTable(hi, what);
        *vstr = (unsigned char*) ele;
        *vlen = sdslen(ele);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",418.0,429.0,1.0,24.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6593,395510,hashTypeCurrentObjectNewSds,1,hashTypeCurrentObjectNewSds,"sds hashTypeCurrentObjectNewSds (hashTypeIterator*,int)",t_hash.c,"sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vll;

    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
    if (vstr) return sdsnewlen(vstr,vlen);
    return sdsfromlonglong(vll);
}",433.0,441.0,1.0,1.0,9.0,0,0,0,0,2,0,1,1,0,0,,0,0,4,2,2,sds
6594,395516,hashTypeLookupWriteOrCreate,1,hashTypeLookupWriteOrCreate,"robj* hashTypeLookupWriteOrCreate (client*,robj*)",t_hash.c,"robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {
    robj *o = lookupKeyWrite(c->db,key);
    if (checkType(c,o,OBJ_HASH)) return NULL;

    if (o == NULL) {
        o = createHashObject();
        dbAdd(c->db,key,o);
    }
    return o;
}",443.0,452.0,1.0,22.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,robj
6595,395522,hashTypeGetValueObject,1,hashTypeGetValueObject,"robj* hashTypeGetValueObject (robj*,sds)",t_hash.c,"robj *hashTypeGetValueObject(robj *o, sds field) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vll;

    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;
    if (vstr) return createStringObject((char*)vstr,vlen);
    else return createStringObjectFromLongLong(vll);
}",144.0,152.0,1.0,54.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,robj
6596,395528,hashTypeSet,1,hashTypeSet,"int hashTypeSet (robj*,sds,sds,int)",t_hash.c,"int hashTypeSet(robj *o, sds field, sds value, int flags) {
    int update = 0;

    /* Check if the field is too long for listpack, and convert before adding the item.
     * This is needed for HINCRBY* case since in other commands this is handled early by
     * hashTypeTryConversion, so this check will be a NOP. */
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)
            hashTypeConvert(o, OBJ_ENCODING_HT);
    }
    
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl, *fptr, *vptr;

        zl = o->ptr;
        fptr = lpFirst(zl);
        if (fptr != NULL) {
            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
            if (fptr != NULL) {
                /* Grab pointer to the value (fptr points to the field) */
                vptr = lpNext(zl, fptr);
                serverAssert(vptr != NULL);
                update...",200.0,271.0,1.0,23.0,72.0,0,0,0,0,1,0,1,1,0,0,,0,0,8,4,4,int
6597,395536,hashTypeDup,1,hashTypeDup,robj* hashTypeDup (robj*),t_hash.c,"robj *hashTypeDup(robj *o) {
    robj *hobj;
    hashTypeIterator *hi;

    serverAssert(o->type == OBJ_HASH);

    if(o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        size_t sz = lpBytes(zl);
        unsigned char *new_zl = zmalloc(sz);
        memcpy(new_zl, zl, sz);
        hobj = createObject(OBJ_HASH, new_zl);
        hobj->encoding = OBJ_ENCODING_LISTPACK;
    } else if(o->encoding == OBJ_ENCODING_HT){
        dict *d = dictCreate(&hashDictType);
        dictExpand(d, dictSize((const dict*)o->ptr));

        hi = hashTypeInitIterator(o);
        while (hashTypeNext(hi) != C_ERR) {
            sds field, value;
            sds newfield, newvalue;
            /* Extract a field-value pair from an original hash object.*/
            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);
            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);
            newfield = sdsdup(field);
            newvalue = sdsdup(value);

            /...",510.0,548.0,1.0,4.0,39.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
6598,396501,getTimeoutFromObjectOrReply,1,getTimeoutFromObjectOrReply,"int getTimeoutFromObjectOrReply (client*,robj*,mstime_t*,int)",timeout.c,"int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {
    long long tval;
    long double ftval;
    mstime_t now = commandTimeSnapshot();

    if (unit == UNIT_SECONDS) {
        if (getLongDoubleFromObjectOrReply(c,object,&ftval,
            ""timeout is not a float or out of range"") != C_OK)
            return C_ERR;

        ftval *= 1000.0;  /* seconds => millisec */
        if (ftval > LLONG_MAX) {
            addReplyError(c, ""timeout is out of range"");
            return C_ERR;
        }
        tval = (long long) ceill(ftval);
    } else {
        if (getLongLongFromObjectOrReply(c,object,&tval,
            ""timeout is not an integer or out of range"") != C_OK)
            return C_ERR;
    }

    if (tval < 0) {
        addReplyError(c,""timeout is negative"");
        return C_ERR;
    }

    if (tval > 0) {
        if  (tval > LLONG_MAX - now) {
            addReplyError(c,""timeout is out of range""); /* 'tval+now' would overflow */
         ...",165.0,202.0,1.0,16.0,38.0,0,0,0,0,4,0,1,1,0,0,,0,0,8,4,4,int
6599,396595,addClientToTimeoutTable,1,addClientToTimeoutTable,void addClientToTimeoutTable (client*),timeout.c,"void addClientToTimeoutTable(client *c) {
    if (c->bstate.timeout == 0) return;
    uint64_t timeout = c->bstate.timeout;
    unsigned char buf[CLIENT_ST_KEYLEN];
    encodeTimeoutKey(buf,timeout,c);
    if (raxTryInsert(server.clients_timeout_table,buf,sizeof(buf),NULL,NULL))
        c->flags |= CLIENT_IN_TO_TABLE;
}",115.0,122.0,1.0,22.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6600,396600,removeClientFromTimeoutTable,1,removeClientFromTimeoutTable,void removeClientFromTimeoutTable (client*),timeout.c,"void removeClientFromTimeoutTable(client *c) {
    if (!(c->flags & CLIENT_IN_TO_TABLE)) return;
    c->flags &= ~CLIENT_IN_TO_TABLE;
    uint64_t timeout = c->bstate.timeout;
    unsigned char buf[CLIENT_ST_KEYLEN];
    encodeTimeoutKey(buf,timeout,c);
    raxRemove(server.clients_timeout_table,buf,sizeof(buf),NULL);
}",126.0,133.0,1.0,21.0,8.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6601,396605,handleBlockedClientsTimeout,1,handleBlockedClientsTimeout,void handleBlockedClientsTimeout (void),timeout.c,"void handleBlockedClientsTimeout(void) {
    if (raxSize(server.clients_timeout_table) == 0) return;
    uint64_t now = mstime();
    raxIterator ri;
    raxStart(&ri,server.clients_timeout_table);
    raxSeek(&ri,""^"",NULL,0);

    while(raxNext(&ri)) {
        uint64_t timeout;
        client *c;
        decodeTimeoutKey(ri.key,&timeout,&c);
        if (timeout >= now) break; /* All the timeouts are in the future. */
        c->flags &= ~CLIENT_IN_TO_TABLE;
        checkBlockedClientTimeout(c,now);
        raxRemove(server.clients_timeout_table,ri.key,ri.key_len,NULL);
        raxSeek(&ri,""^"",NULL,0);
    }
    raxStop(&ri);
}",137.0,155.0,1.0,21.0,19.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6602,396610,clientsCronHandleTimeout,1,clientsCronHandleTimeout,"int clientsCronHandleTimeout (client*,mstime_t)",timeout.c,"int clientsCronHandleTimeout(client *c, mstime_t now_ms) {
    time_t now = now_ms/1000;

    if (server.maxidletime &&
        /* This handles the idle clients connection timeout if set. */
        !(c->flags & CLIENT_SLAVE) &&   /* No timeout for slaves and monitors */
        !mustObeyClient(c) &&         /* No timeout for masters and AOF */
        !(c->flags & CLIENT_BLOCKED) && /* No timeout for BLPOP */
        !(c->flags & CLIENT_PUBSUB) &&  /* No timeout for Pub/Sub clients */
        (now - c->lastinteraction > server.maxidletime))
    {
        serverLog(LL_VERBOSE,""Closing idle client"");
        freeClient(c);
        return 1;
    } else if (c->flags & CLIENT_BLOCKED) {
        /* Cluster: handle unblock & redirect of clients blocked
         * into keys no longer served by this server. */
        if (server.cluster_enabled) {
            if (clusterRedirectBlockedClientIfNeeded(c))
                unblockClientOnError(c, NULL);
        }
    }
    return 0;
}",56.0,79.0,1.0,21.0,24.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
6603,396794,setCommand,1,setCommand,void setCommand (client*),t_string.c,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",295.0,306.0,1.0,15.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6604,396799,setnxCommand,1,setnxCommand,void setnxCommand (client*),t_string.c,"void setnxCommand(client *c) {
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
}",308.0,311.0,1.0,24.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6605,396804,setexCommand,1,setexCommand,void setexCommand (client*),t_string.c,"void setexCommand(client *c) {
    c->argv[3] = tryObjectEncoding(c->argv[3]);
    setGenericCommand(c,OBJ_EX,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
}",313.0,316.0,1.0,24.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6606,396809,psetexCommand,1,psetexCommand,void psetexCommand (client*),t_string.c,"void psetexCommand(client *c) {
    c->argv[3] = tryObjectEncoding(c->argv[3]);
    setGenericCommand(c,OBJ_PX,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
}",318.0,321.0,1.0,24.0,4.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6607,396814,getCommand,1,getCommand,void getCommand (client*),t_string.c,"void getCommand(client *c) {
    getGenericCommand(c);
}",337.0,339.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6608,396819,getexCommand,1,getexCommand,void getexCommand (client*),t_string.c,"void getexCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_GET) != C_OK) {
        return;
    }

    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)
        return;

    if (checkType(c,o,OBJ_STRING)) {
        return;
    }

    /* Validate the expiration time value first */
    long long milliseconds = 0;
    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {
        return;
    }

    /* We need to do this before we expire the key or delete it */
    addReplyBulk(c,o);

    /* This command is never propagated as is. It is either propagated as PEXPIRE[AT],DEL,UNLINK or PERSIST.
     * This why it doesn't need special handling in feedAppendOnlyFile to convert relative expire time to absolute one. */
    if (((flags & OBJ_PXAT) || (flags & OBJ_EXAT)) && checkAlreadyExpir...",361.0,418.0,1.0,15.0,58.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6609,396824,getdelCommand,1,getdelCommand,void getdelCommand (client*),t_string.c,"void getdelCommand(client *c) {
    if (getGenericCommand(c) == C_ERR) return;
    if (dbSyncDelete(c->db, c->argv[1])) {
        /* Propagate as DEL command */
        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
        signalModifiedKey(c, c->db, c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", c->argv[1], c->db->id);
        server.dirty++;
    }
}",420.0,429.0,1.0,32.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6610,396864,setrangeCommand,1,setrangeCommand,void setrangeCommand (client*),t_string.c,"void setrangeCommand(client *c) {
    robj *o;
    long offset;
    sds value = c->argv[3]->ptr;

    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)
        return;

    if (offset < 0) {
        addReplyError(c,""offset is out of range"");
        return;
    }

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (o == NULL) {
        /* Return 0 when setting nothing on a non-existing string */
        if (sdslen(value) == 0) {
            addReply(c,shared.czero);
            return;
        }

        /* Return when the resulting string exceeds allowed size */
        if (checkStringLength(c,offset,sdslen(value)) != C_OK)
            return;

        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));
        dbAdd(c->db,c->argv[1],o);
    } else {
        size_t olen;

        /* Key exists, check type */
        if (checkType(c,o,OBJ_STRING))
            return;

        /* Return existing string length when setting nothing */
        olen = stringO...",442.0,500.0,1.0,63.0,59.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6611,396869,getrangeCommand,1,getrangeCommand,void getrangeCommand (client*),t_string.c,"void getrangeCommand(client *c) {
    robj *o;
    long long start, end;
    char *str, llbuf[32];
    size_t strlen;

    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
        return;
    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
        return;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;

    if (o->encoding == OBJ_ENCODING_INT) {
        str = llbuf;
        strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);
    } else {
        str = o->ptr;
        strlen = sdslen(str);
    }

    /* Convert negative indexes */
    if (start < 0 && end < 0 && start > end) {
        addReply(c,shared.emptybulk);
        return;
    }
    if (start < 0) start = strlen+start;
    if (end < 0) end = strlen+end;
    if (start < 0) start = 0;
    if (end < 0) end = 0;
    if ((unsigned long long)end >= strlen) end = strlen-1;

    /* Precondition: end >= 0 && end < strlen, so t...",502.0,541.0,1.0,66.0,40.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6612,396874,incrCommand,1,incrCommand,void incrCommand (client*),t_string.c,"void incrCommand(client *c) {
    incrDecrCommand(c,1);
}",637.0,639.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6613,396879,decrCommand,1,decrCommand,void decrCommand (client*),t_string.c,"void decrCommand(client *c) {
    incrDecrCommand(c,-1);
}",641.0,643.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6614,396884,incrbyCommand,1,incrbyCommand,void incrbyCommand (client*),t_string.c,"void incrbyCommand(client *c) {
    long long incr;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
    incrDecrCommand(c,incr);
}",645.0,650.0,1.0,68.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6615,396889,decrbyCommand,1,decrbyCommand,void decrbyCommand (client*),t_string.c,"void decrbyCommand(client *c) {
    long long incr;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
    /* Overflow check: negating LLONG_MIN will cause an overflow */
    if (incr == LLONG_MIN) {
        addReplyError(c, ""decrement would overflow"");
        return;
    }
    incrDecrCommand(c,-incr);
}",652.0,662.0,1.0,68.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6616,396894,incrbyfloatCommand,1,incrbyfloatCommand,void incrbyfloatCommand (client*),t_string.c,"void incrbyfloatCommand(client *c) {
    long double incr, value;
    robj *o, *new;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return;
    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
        return;

    value += incr;
    if (isnan(value) || isinf(value)) {
        addReplyError(c,""increment would produce NaN or Infinity"");
        return;
    }
    new = createStringObjectFromLongDouble(value,1);
    if (o)
        dbReplaceValue(c->db,c->argv[1],new);
    else
        dbAdd(c->db,c->argv[1],new);
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,""incrbyfloat"",c->argv[1],c->db->id);
    server.dirty++;
    addReplyBulk(c,new);

    /* Always replicate INCRBYFLOAT as a SET command with the final value
     * in order to make sure that differences in float precision or formatting
     * will not create differences in replicas ...",664.0,695.0,1.0,22.0,32.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6617,396954,slowlogCommand,1,slowlogCommand,void slowlogCommand (client*),slowlog.c,"void slowlogCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""GET [<count>]"",
""    Return top <count> entries from the slowlog (default: 10, -1 mean all)."",
""    Entries are made of:"",
""    id, timestamp, time in microseconds, arguments array, client IP and port,"",
""    client name"",
""LEN"",
""    Return the length of the slowlog."",
""RESET"",
""    Reset the slowlog."",
NULL
        };
        addReplyHelp(c, help);
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""reset"")) {
        slowlogReset();
        addReply(c,shared.ok);
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""len"")) {
        addReplyLongLong(c,listLength(server.slowlog));
    } else if ((c->argc == 2 || c->argc == 3) &&
               !strcasecmp(c->argv[1]->ptr,""get""))
    {
        long count = 10;
        listIter li;
        listNode *ln;
        slowlogEntry *se;

        if (c->argc == 3) {
            /* Consume count arg. */...",142.0,206.0,1.0,27.0,65.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6618,396979,lpushCommand,1,lpushCommand,void lpushCommand (client*),t_list.c,"void lpushCommand(client *c) {
    pushGenericCommand(c,LIST_HEAD,0);
}",515.0,517.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6619,396984,rpushCommand,1,rpushCommand,void rpushCommand (client*),t_list.c,"void rpushCommand(client *c) {
    pushGenericCommand(c,LIST_TAIL,0);
}",520.0,522.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6620,396989,lpushxCommand,1,lpushxCommand,void lpushxCommand (client*),t_list.c,"void lpushxCommand(client *c) {
    pushGenericCommand(c,LIST_HEAD,1);
}",525.0,527.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6621,396994,rpushxCommand,1,rpushxCommand,void rpushxCommand (client*),t_list.c,"void rpushxCommand(client *c) {
    pushGenericCommand(c,LIST_TAIL,1);
}",530.0,532.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6622,396999,linsertCommand,1,linsertCommand,void linsertCommand (client*),t_list.c,"void linsertCommand(client *c) {
    int where;
    robj *subject;
    listTypeIterator *iter;
    listTypeEntry entry;
    int inserted = 0;

    if (strcasecmp(c->argv[2]->ptr,""after"") == 0) {
        where = LIST_TAIL;
    } else if (strcasecmp(c->argv[2]->ptr,""before"") == 0) {
        where = LIST_HEAD;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,subject,OBJ_LIST)) return;

    /* We're not sure if this value can be inserted yet, but we cannot
     * convert the list inside the iterator. We don't want to loop over
     * the list twice (once to see if the value can be inserted and once
     * to do the actual insert), so we assume this value can be inserted
     * and convert the listpack to a regular list if necessary. */
    listTypeTryConversionAppend(subject,c->argv,4,4,NULL,NULL);

    /* Seek pivot from head to tail */
    iter = list...",535.0,584.0,1.0,16.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6623,397004,lpopCommand,1,lpopCommand,void lpopCommand (client*),t_list.c,"void lpopCommand(client *c) {
    popGenericCommand(c,LIST_HEAD);
}",869.0,871.0,1.0,24.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6624,397009,rpopCommand,1,rpopCommand,void rpopCommand (client*),t_list.c,"void rpopCommand(client *c) {
    popGenericCommand(c,LIST_TAIL);
}",874.0,876.0,1.0,24.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6625,397014,lmpopCommand,1,lmpopCommand,void lmpopCommand (client*),t_list.c,"void lmpopCommand(client *c) {
    lmpopGenericCommand(c, 1, 0);
}",1381.0,1383.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6626,397019,llenCommand,1,llenCommand,void llenCommand (client*),t_list.c,"void llenCommand(client *c) {
    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
    addReplyLongLong(c,listTypeLength(o));
}",587.0,591.0,1.0,35.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6627,397024,lindexCommand,1,lindexCommand,void lindexCommand (client*),t_list.c,"void lindexCommand(client *c) {
    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]);
    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
    long index;

    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
        return;

    listTypeIterator *iter = listTypeInitIterator(o,index,LIST_TAIL);
    listTypeEntry entry;
    unsigned char *vstr;
    size_t vlen;
    long long lval;

    if (listTypeNext(iter,&entry)) {
        vstr = listTypeGetValue(&entry,&vlen,&lval);
        if (vstr) {
            addReplyBulkCBuffer(c, vstr, vlen);
        } else {
            addReplyBulkLongLong(c, lval);
        }
    } else {
        addReplyNull(c);
    }

    listTypeReleaseIterator(iter);
}",594.0,620.0,1.0,35.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6628,397029,lrangeCommand,1,lrangeCommand,void lrangeCommand (client*),t_list.c,"void lrangeCommand(client *c) {
    robj *o;
    long start, end;

    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray)) == NULL
         || checkType(c,o,OBJ_LIST)) return;

    addListRangeReply(c,o,start,end,0);
}",879.0,890.0,1.0,66.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6629,397034,ltrimCommand,1,ltrimCommand,void ltrimCommand (client*),t_list.c,"void ltrimCommand(client *c) {
    robj *o;
    long start, end, llen, ltrim, rtrim;

    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
        checkType(c,o,OBJ_LIST)) return;
    llen = listTypeLength(o);

    /* convert negative indexes */
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;

    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        /* Out of range start or start > end result in empty list */
        ltrim = llen;
        rtrim = 0;
    } else {
        if (end >= llen) end = llen-1;
        ltrim = start;
        rtrim = llen-end-1;
    }

    /* Remove list elements to perform the trim */
    if (o->encoding == OBJ_E...",893.0,942.0,1.0,66.0,50.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6630,397044,lsetCommand,1,lsetCommand,void lsetCommand (client*),t_list.c,"void lsetCommand(client *c) {
    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
    long index;
    robj *value = c->argv[3];

    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
        return;

    listTypeTryConversionAppend(o,c->argv,3,3,NULL,NULL);
    if (listTypeReplaceAtIndex(o,index,value)) {
        addReply(c,shared.ok);
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_LIST,""lset"",c->argv[1],c->db->id);
        server.dirty++;

        /* We might replace a big item with a small one or vice versa, but we've
         * already handled the growing case in listTypeTryConversionAppend()
         * above, so here we just need to try the conversion for shrinking. */
        listTypeTryConversion(o,LIST_CONV_SHRINKING,NULL,NULL);
    } else {
        addReplyErrorObject(c,shared.outofrangeerr);
    }
}",623.0,646.0,1.0,35.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6631,397049,saddCommand,1,saddCommand,void saddCommand (client*),t_set.c,"void saddCommand(client *c) {
    robj *set;
    int j, added = 0;

    set = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,set,OBJ_SET)) return;
    
    if (set == NULL) {
        set = setTypeCreate(c->argv[2]->ptr, c->argc - 2);
        dbAdd(c->db,c->argv[1],set);
    } else {
        setTypeMaybeConvert(set, c->argc - 2);
    }

    for (j = 2; j < c->argc; j++) {
        if (setTypeAdd(set,c->argv[j]->ptr)) added++;
    }
    if (added) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_SET,""sadd"",c->argv[1],c->db->id);
    }
    server.dirty += added;
    addReplyLongLong(c,added);
}",605.0,628.0,1.0,24.0,24.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6632,397054,sremCommand,1,sremCommand,void sremCommand (client*),t_set.c,"void sremCommand(client *c) {
    robj *set;
    int j, deleted = 0, keyremoved = 0;

    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,set,OBJ_SET)) return;

    for (j = 2; j < c->argc; j++) {
        if (setTypeRemove(set,c->argv[j]->ptr)) {
            deleted++;
            if (setTypeSize(set) == 0) {
                dbDelete(c->db,c->argv[1]);
                keyremoved = 1;
                break;
            }
        }
    }
    if (deleted) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_SET,""srem"",c->argv[1],c->db->id);
        if (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",c->argv[1],
                                c->db->id);
        server.dirty += deleted;
    }
    addReplyLongLong(c,deleted);
}",630.0,656.0,1.0,24.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6633,397059,smoveCommand,1,smoveCommand,void smoveCommand (client*),t_set.c,"void smoveCommand(client *c) {
    robj *srcset, *dstset, *ele;
    srcset = lookupKeyWrite(c->db,c->argv[1]);
    dstset = lookupKeyWrite(c->db,c->argv[2]);
    ele = c->argv[3];

    /* If the source key does not exist return 0 */
    if (srcset == NULL) {
        addReply(c,shared.czero);
        return;
    }

    /* If the source key has the wrong type, or the destination key
     * is set and has the wrong type, return with an error. */
    if (checkType(c,srcset,OBJ_SET) ||
        checkType(c,dstset,OBJ_SET)) return;

    /* If srcset and dstset are equal, SMOVE is a no-op */
    if (srcset == dstset) {
        addReply(c,setTypeIsMember(srcset,ele->ptr) ?
            shared.cone : shared.czero);
        return;
    }

    /* If the element cannot be removed from the src set, return 0. */
    if (!setTypeRemove(srcset,ele->ptr)) {
        addReply(c,shared.czero);
        return;
    }
    notifyKeyspaceEvent(NOTIFY_SET,""srem"",c->argv[1],c->db->id);

    /* Remove the src se...",658.0,711.0,1.0,27.0,54.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6634,397064,sismemberCommand,1,sismemberCommand,void sismemberCommand (client*),t_set.c,"void sismemberCommand(client *c) {
    robj *set;

    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,set,OBJ_SET)) return;

    if (setTypeIsMember(set,c->argv[2]->ptr))
        addReply(c,shared.cone);
    else
        addReply(c,shared.czero);
}",713.0,723.0,1.0,24.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6635,397069,smismemberCommand,1,smismemberCommand,void smismemberCommand (client*),t_set.c,"void smismemberCommand(client *c) {
    robj *set;
    int j;

    /* Don't abort when the key cannot be found. Non-existing keys are empty
     * sets, where SMISMEMBER should respond with a series of zeros. */
    set = lookupKeyRead(c->db,c->argv[1]);
    if (set && checkType(c,set,OBJ_SET)) return;

    addReplyArrayLen(c,c->argc - 2);

    for (j = 2; j < c->argc; j++) {
        if (set && setTypeIsMember(set,c->argv[j]->ptr))
            addReply(c,shared.cone);
        else
            addReply(c,shared.czero);
    }
}",725.0,742.0,1.0,31.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6636,397074,scardCommand,1,scardCommand,void scardCommand (client*),t_set.c,"void scardCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_SET)) return;

    addReplyLongLong(c,setTypeSize(o));
}",744.0,751.0,1.0,22.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6637,397079,spopCommand,1,spopCommand,void spopCommand (client*),t_set.c,"void spopCommand(client *c) {
    robj *set, *ele;

    if (c->argc == 3) {
        spopWithCountCommand(c);
        return;
    } else if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set */
    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))
         == NULL || checkType(c,set,OBJ_SET)) return;

    /* Pop a random element from the set */
    ele = setTypePopRandom(set);

    notifyKeyspaceEvent(NOTIFY_SET,""spop"",c->argv[1],c->db->id);

    /* Replicate/AOF this command as an SREM operation */
    rewriteClientCommandVector(c,3,shared.srem,c->argv[1],ele);

    /* Add the element to the reply */
    addReplyBulk(c, ele);
    decrRefCount(ele);

    /* Delete the set if it's empty */
    if (setTypeSize(set) == 0) {
        dbDelete(c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",c->argv[1],c->db->id);
    }

...",968.0,1005.0,1.0,36.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6638,397084,srandmemberCommand,1,srandmemberCommand,void srandmemberCommand (client*),t_set.c,"void srandmemberCommand(client *c) {
    robj *set;
    char *str;
    size_t len;
    int64_t llele;

    if (c->argc == 3) {
        srandmemberWithCountCommand(c);
        return;
    } else if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Handle variant without <count> argument. Reply with simple bulk string */
    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))
        == NULL || checkType(c,set,OBJ_SET)) return;

    setTypeRandomElement(set, &str, &len, &llele);
    if (str == NULL) {
        addReplyBulkLongLong(c,llele);
    } else {
        addReplyBulkCBuffer(c, str, len);
    }
}",1225.0,1249.0,1.0,35.0,25.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6639,397089,sinterCommand,1,sinterCommand,void sinterCommand (client*),t_set.c,"void sinterCommand(client *c) {
    sinterGenericCommand(c, c->argv+1,  c->argc-1, NULL, 0, 0);
}",1441.0,1443.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6640,397094,sinterCardCommand,1,sinterCardCommand,void sinterCardCommand (client*),t_set.c,"void sinterCardCommand(client *c) {
    long j;
    long numkeys = 0; /* Number of keys. */
    long limit = 0;   /* 0 means not limit. */

    if (getRangeLongFromObjectOrReply(c, c->argv[1], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;
    if (numkeys > (c->argc - 2)) {
        addReplyError(c, ""Number of keys can't be greater than number of args"");
        return;
    }

    for (j = 2 + numkeys; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->argc - 1) - j;

        if (!strcasecmp(opt, ""LIMIT"") && moreargs) {
            j++;
            if (getPositiveLongFromObjectOrReply(c, c->argv[j], &limit,
                                                 ""LIMIT can't be negative"") != C_OK)
                return;
        } else {
            addReplyErrorObject(c, shared.syntaxerr);
            return;
        }
    }

    sinterGenericCommand(c, c->argv+2, numkeys, NULL, 1, l...",1446.0,1475.0,1.0,87.0,30.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6641,397099,sinterstoreCommand,1,sinterstoreCommand,void sinterstoreCommand (client*),t_set.c,"void sinterstoreCommand(client *c) {
    sinterGenericCommand(c, c->argv+2, c->argc-2, c->argv[1], 0, 0);
}",1478.0,1480.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6642,397104,sunionCommand,1,sunionCommand,void sunionCommand (client*),t_set.c,"void sunionCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
}",1653.0,1655.0,1.0,56.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6643,397109,sunionstoreCommand,1,sunionstoreCommand,void sunionstoreCommand (client*),t_set.c,"void sunionstoreCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
}",1658.0,1660.0,1.0,62.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6644,397114,sdiffCommand,1,sdiffCommand,void sdiffCommand (client*),t_set.c,"void sdiffCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
}",1663.0,1665.0,1.0,56.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6645,397119,sdiffstoreCommand,1,sdiffstoreCommand,void sdiffstoreCommand (client*),t_set.c,"void sdiffstoreCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
}",1668.0,1670.0,1.0,62.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6646,397124,sscanCommand,1,sscanCommand,void sscanCommand (client*),t_set.c,"void sscanCommand(client *c) {
    robj *set;
    unsigned long cursor;

    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
        checkType(c,set,OBJ_SET)) return;
    scanGenericCommand(c,set,cursor);
}",1672.0,1680.0,1.0,56.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6647,397144,sortCommand,1,sortCommand,void sortCommand (client*),sort.c,"void sortCommand(client *c) {
    sortCommandGeneric(c, 0);
}",617.0,619.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6648,397149,sortroCommand,1,sortroCommand,void sortroCommand (client*),sort.c,"void sortroCommand(client *c) {
    sortCommandGeneric(c, 1);
}",613.0,615.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6649,397154,lremCommand,1,lremCommand,void lremCommand (client*),t_list.c,"void lremCommand(client *c) {
    robj *subject, *obj;
    obj = c->argv[3];
    long toremove;
    long removed = 0;

    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))
        return;

    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;

    listTypeIterator *li;
    if (toremove < 0) {
        toremove = -toremove;
        li = listTypeInitIterator(subject,-1,LIST_HEAD);
    } else {
        li = listTypeInitIterator(subject,0,LIST_TAIL);
    }

    listTypeEntry entry;
    while (listTypeNext(li,&entry)) {
        if (listTypeEqual(&entry,obj)) {
            listTypeDelete(li, &entry);
            server.dirty++;
            removed++;
            if (toremove && removed == toremove) break;
        }
    }
    listTypeReleaseIterator(li);

    if (removed) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_LIST,""lrem"",c->argv[1],c->db->id);
    ...",1057.0,1101.0,1.0,69.0,45.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6650,397159,lposCommand,1,lposCommand,void lposCommand (client*),t_list.c,"void lposCommand(client *c) {
    robj *o, *ele;
    ele = c->argv[2];
    int direction = LIST_TAIL;
    long rank = 1, count = -1, maxlen = 0; /* Count -1: option not given. */

    /* Parse the optional arguments. */
    for (int j = 3; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->argc-1)-j;

        if (!strcasecmp(opt,""RANK"") && moreargs) {
            j++;
            if (getRangeLongFromObjectOrReply(c, c->argv[j], -LONG_MAX, LONG_MAX, &rank, NULL) != C_OK)
                return;
            if (rank == 0) {
                addReplyError(c,""RANK can't be zero: use 1 to start from ""
                                ""the first match, 2 from the second ... ""
                                ""or use negative to start from the end of the list"");
                return;
            }
        } else if (!strcasecmp(opt,""COUNT"") && moreargs) {
            j++;
            if (getPositiveLongFromObjectOrReply(c, c->argv[j], &count,
              ""...",961.0,1054.0,1.0,20.0,94.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6651,397164,rpoplpushCommand,1,rpoplpushCommand,void rpoplpushCommand (client*),t_list.c,"void rpoplpushCommand(client *c) {
    lmoveGenericCommand(c, LIST_TAIL, LIST_HEAD);
}",1199.0,1201.0,1.0,27.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6652,397169,lmoveCommand,1,lmoveCommand,void lmoveCommand (client*),t_list.c,"void lmoveCommand(client *c) {
    int wherefrom, whereto;
    if (getListPositionFromObjectOrReply(c,c->argv[3],&wherefrom)
        != C_OK) return;
    if (getListPositionFromObjectOrReply(c,c->argv[4],&whereto)
        != C_OK) return;
    lmoveGenericCommand(c, wherefrom, whereto);
}",1175.0,1182.0,1.0,11.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6653,397179,mgetCommand,1,mgetCommand,void mgetCommand (client*),t_string.c,"void mgetCommand(client *c) {
    int j;

    addReplyArrayLen(c,c->argc-1);
    for (j = 1; j < c->argc; j++) {
        robj *o = lookupKeyRead(c->db,c->argv[j]);
        if (o == NULL) {
            addReplyNull(c);
        } else {
            if (o->type != OBJ_STRING) {
                addReplyNull(c);
            } else {
                addReplyBulk(c,o);
            }
        }
    }
}",543.0,559.0,1.0,27.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6654,397209,getsetCommand,1,getsetCommand,void getsetCommand (client*),t_string.c,"void getsetCommand(client *c) {
    if (getGenericCommand(c) == C_ERR) return;
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setKey(c,c->db,c->argv[1],c->argv[2],0);
    notifyKeyspaceEvent(NOTIFY_STRING,""set"",c->argv[1],c->db->id);
    server.dirty++;

    /* Propagate as SET command */
    rewriteClientCommandArgument(c,0,shared.set);
}",431.0,440.0,1.0,32.0,10.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6655,397259,msetCommand,1,msetCommand,void msetCommand (client*),t_string.c,"void msetCommand(client *c) {
    msetGenericCommand(c,0);
}",593.0,595.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6656,397264,msetnxCommand,1,msetnxCommand,void msetnxCommand (client*),t_string.c,"void msetnxCommand(client *c) {
    msetGenericCommand(c,1);
}",597.0,599.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6657,397269,zaddCommand,1,zaddCommand,void zaddCommand (client*),t_zset.c,"void zaddCommand(client *c) {
    zaddGenericCommand(c,ZADD_IN_NONE);
}",1837.0,1839.0,1.0,25.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6658,397274,zincrbyCommand,1,zincrbyCommand,void zincrbyCommand (client*),t_zset.c,"void zincrbyCommand(client *c) {
    zaddGenericCommand(c,ZADD_IN_INCR);
}",1841.0,1843.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6659,397279,zrangeCommand,1,zrangeCommand,void zrangeCommand (client*),t_zset.c,"void zrangeCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);
}",3185.0,3189.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6660,397284,zrangebyscoreCommand,1,zrangebyscoreCommand,void zrangebyscoreCommand (client*),t_zset.c,"void zrangebyscoreCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_FORWARD);
}",3313.0,3317.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6661,397289,zrevrangebyscoreCommand,1,zrevrangebyscoreCommand,void zrevrangebyscoreCommand (client*),t_zset.c,"void zrevrangebyscoreCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_REVERSE);
}",3320.0,3324.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6662,397294,zrangebylexCommand,1,zrangebylexCommand,void zrangebylexCommand (client*),t_zset.c,"void zrangebylexCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_FORWARD);
}",3594.0,3598.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6663,397299,zrevrangebylexCommand,1,zrevrangebylexCommand,void zrevrangebylexCommand (client*),t_zset.c,"void zrevrangebylexCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_REVERSE);
}",3601.0,3605.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6664,397304,zcountCommand,1,zcountCommand,void zcountCommand (client*),t_zset.c,"void zcountCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    zrangespec range;
    unsigned long count = 0;

    /* Parse the range arguments */
    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
        addReplyError(c,""min or max is not a float"");
        return;
    }

    /* Lookup the sorted set */
    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
        checkType(c, zobj, OBJ_ZSET)) return;

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        double score;

        /* Use the first element in range as the starting point */
        eptr = zzlFirstInRange(zl,&range);

        /* No ""first"" element */
        if (eptr == NULL) {
            addReply(c, shared.czero);
            return;
        }

        /* First element is in range */
        sptr = lpNext(zl,eptr);
        score = zzlGetScore(sptr);
        serverAssertWithInfo(c,zobj,zslValueL...",3326.0,3401.0,1.0,55.0,76.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6665,397309,zlexcountCommand,1,zlexcountCommand,void zlexcountCommand (client*),t_zset.c,"void zlexcountCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    zlexrangespec range;
    unsigned long count = 0;

    /* Parse the range arguments */
    if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {
        addReplyError(c,""min or max not valid string range item"");
        return;
    }

    /* Lookup the sorted set */
    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
        checkType(c, zobj, OBJ_ZSET))
    {
        zslFreeLexRange(&range);
        return;
    }

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;

        /* Use the first element in range as the starting point */
        eptr = zzlFirstInLexRange(zl,&range);

        /* No ""first"" element */
        if (eptr == NULL) {
            zslFreeLexRange(&range);
            addReply(c, shared.czero);
            return;
        }

        /* First element is in range */
        sptr = lpNe...",3403.0,3480.0,1.0,58.0,78.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6666,397314,zrevrangeCommand,1,zrevrangeCommand,void zrevrangeCommand (client*),t_zset.c,"void zrevrangeCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_RANK, ZRANGE_DIRECTION_REVERSE);
}",3192.0,3196.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6667,397319,zcardCommand,1,zcardCommand,void zcardCommand (client*),t_zset.c,"void zcardCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;

    if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
        checkType(c,zobj,OBJ_ZSET)) return;

    addReplyLongLong(c,zsetLength(zobj));
}",3765.0,3773.0,1.0,25.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6668,397324,zremCommand,1,zremCommand,void zremCommand (client*),t_zset.c,"void zremCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    int deleted = 0, keyremoved = 0, j;

    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
        checkType(c,zobj,OBJ_ZSET)) return;

    for (j = 2; j < c->argc; j++) {
        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
        if (zsetLength(zobj) == 0) {
            dbDelete(c->db,key);
            keyremoved = 1;
            break;
        }
    }

    if (deleted) {
        notifyKeyspaceEvent(NOTIFY_ZSET,""zrem"",key,c->db->id);
        if (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",key,c->db->id);
        signalModifiedKey(c,c->db,key);
        server.dirty += deleted;
    }
    addReplyLongLong(c,deleted);
}",1845.0,1870.0,1.0,25.0,26.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6669,397329,zscoreCommand,1,zscoreCommand,void zscoreCommand (client*),t_zset.c,"void zscoreCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    double score;

    if ((zobj = lookupKeyReadOrReply(c,key,shared.null[c->resp])) == NULL ||
        checkType(c,zobj,OBJ_ZSET)) return;

    if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
        addReplyNull(c);
    } else {
        addReplyDouble(c,score);
    }
}",3775.0,3788.0,1.0,25.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6670,397334,zmscoreCommand,1,zmscoreCommand,void zmscoreCommand (client*),t_zset.c,"void zmscoreCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    double score;
    zobj = lookupKeyRead(c->db,key);
    if (checkType(c,zobj,OBJ_ZSET)) return;

    addReplyArrayLen(c,c->argc - 2);
    for (int j = 2; j < c->argc; j++) {
        /* Treat a missing set the same way as an empty set */
        if (zobj == NULL || zsetScore(zobj,c->argv[j]->ptr,&score) == C_ERR) {
            addReplyNull(c);
        } else {
            addReplyDouble(c,score);
        }
    }
}",3790.0,3806.0,1.0,25.0,17.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6671,397339,zremrangebyscoreCommand,1,zremrangebyscoreCommand,void zremrangebyscoreCommand (client*),t_zset.c,"void zremrangebyscoreCommand(client *c) {
    zremrangeGenericCommand(c,ZRANGE_SCORE);
}",1991.0,1993.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6672,397344,zremrangebylexCommand,1,zremrangebylexCommand,void zremrangebylexCommand (client*),t_zset.c,"void zremrangebylexCommand(client *c) {
    zremrangeGenericCommand(c,ZRANGE_LEX);
}",1995.0,1997.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6673,397349,zpopminCommand,1,zpopminCommand,void zpopminCommand (client*),t_zset.c,"void zpopminCommand(client *c) {
    zpopMinMaxCommand(c, ZSET_MIN);
}",4046.0,4048.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6674,397354,zpopmaxCommand,1,zpopmaxCommand,void zpopmaxCommand (client*),t_zset.c,"void zpopmaxCommand(client *c) {
    zpopMinMaxCommand(c, ZSET_MAX);
}",4051.0,4053.0,1.0,25.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6675,397359,zmpopCommand,1,zmpopCommand,void zmpopCommand (client*),t_zset.c,"void zmpopCommand(client *c) {
    zmpopGenericCommand(c, 1, 0);
}",4453.0,4455.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6676,397364,bzpopminCommand,1,bzpopminCommand,void bzpopminCommand (client*),t_zset.c,"void bzpopminCommand(client *c) {
    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MIN, c->argc-1, -1, 0, 0);
}",4122.0,4124.0,1.0,56.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6677,397369,bzpopmaxCommand,1,bzpopmaxCommand,void bzpopmaxCommand (client*),t_zset.c,"void bzpopmaxCommand(client *c) {
    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MAX, c->argc-1, -1, 0, 0);
}",4127.0,4129.0,1.0,56.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6678,397374,bzmpopCommand,1,bzmpopCommand,void bzmpopCommand (client*),t_zset.c,"void bzmpopCommand(client *c) {
    zmpopGenericCommand(c, 2, 1);
}",4458.0,4460.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6679,397379,zrandmemberCommand,1,zrandmemberCommand,void zrandmemberCommand (client*),t_zset.c,"void zrandmemberCommand(client *c) {
    long l;
    int withscores = 0;
    robj *zset;
    listpackEntry ele;

    if (c->argc >= 3) {
        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,""withscores""))) {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        } else if (c->argc == 4) {
            withscores = 1;
            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {
                addReplyError(c,""value is out of range"");
                return;
            }
        }
        zrandmemberWithCountCommand(c, l, withscores);
        return;
    }

    /* Handle variant without <count> argument. Reply with simple bulk string */
    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||
        checkType(c,zset,OBJ_ZSET)) {
        return;
    }

    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);
    zsetRep...",4363.0,4393.0,1.0,86.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6680,397399,blpopCommand,1,blpopCommand,void blpopCommand (client*),t_list.c,"void blpopCommand(client *c) {
    blockingPopGenericCommand(c,c->argv+1,c->argc-2,LIST_HEAD,c->argc-1,-1);
}",1278.0,1280.0,1.0,52.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6681,397404,brpopCommand,1,brpopCommand,void brpopCommand (client*),t_list.c,"void brpopCommand(client *c) {
    blockingPopGenericCommand(c,c->argv+1,c->argc-2,LIST_TAIL,c->argc-1,-1);
}",1283.0,1285.0,1.0,52.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6682,397409,blmpopCommand,1,blmpopCommand,void blmpopCommand (client*),t_list.c,"void blmpopCommand(client *c) {
    lmpopGenericCommand(c, 2, 1);
}",1386.0,1388.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6683,397414,brpoplpushCommand,1,brpoplpushCommand,void brpoplpushCommand (client*),t_list.c,"void brpoplpushCommand(client *c) {
    mstime_t timeout;
    if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_SECONDS)
        != C_OK) return;
    blmoveGenericCommand(c, LIST_TAIL, LIST_HEAD, timeout);
}",1322.0,1327.0,1.0,58.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6684,397419,blmoveCommand,1,blmoveCommand,void blmoveCommand (client*),t_list.c,"void blmoveCommand(client *c) {
    mstime_t timeout;
    int wherefrom, whereto;
    if (getListPositionFromObjectOrReply(c,c->argv[3],&wherefrom)
        != C_OK) return;
    if (getListPositionFromObjectOrReply(c,c->argv[4],&whereto)
        != C_OK) return;
    if (getTimeoutFromObjectOrReply(c,c->argv[5],&timeout,UNIT_SECONDS)
        != C_OK) return;
    blmoveGenericCommand(c,wherefrom,whereto,timeout);
}",1309.0,1319.0,1.0,11.0,11.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6685,397424,appendCommand,1,appendCommand,void appendCommand (client*),t_string.c,"void appendCommand(client *c) {
    size_t totlen;
    robj *o, *append;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (o == NULL) {
        /* Create the key */
        c->argv[2] = tryObjectEncoding(c->argv[2]);
        dbAdd(c->db,c->argv[1],c->argv[2]);
        incrRefCount(c->argv[2]);
        totlen = stringObjectLen(c->argv[2]);
    } else {
        /* Key exists, check type */
        if (checkType(c,o,OBJ_STRING))
            return;

        /* ""append"" is an argument, so always an sds */
        append = c->argv[2];
        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)
            return;

        /* Append the value */
        o = dbUnshareStringValue(c->db,c->argv[1],o);
        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
        totlen = sdslen(o->ptr);
    }
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,""append"",c->argv[1],c->db->id);
    server.dirty++;
    addReplyLongLong(c,totlen);
}",697.0,727.0,1.0,26.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6686,397429,strlenCommand,1,strlenCommand,void strlenCommand (client*),t_string.c,"void strlenCommand(client *c) {
    robj *o;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;
    addReplyLongLong(c,stringObjectLen(o));
}",729.0,734.0,1.0,22.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6687,397434,zrankCommand,1,zrankCommand,void zrankCommand (client*),t_zset.c,"void zrankCommand(client *c) {
    zrankGenericCommand(c, 0);
}",3852.0,3854.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6688,397439,zrevrankCommand,1,zrevrankCommand,void zrevrankCommand (client*),t_zset.c,"void zrevrankCommand(client *c) {
    zrankGenericCommand(c, 1);
}",3856.0,3858.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6689,397444,hsetCommand,1,hsetCommand,void hsetCommand (client*),t_hash.c,"void hsetCommand(client *c) {
    int i, created = 0;
    robj *o;

    if ((c->argc % 2) == 1) {
        addReplyErrorArity(c);
        return;
    }

    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    hashTypeTryConversion(o,c->argv,2,c->argc-1);

    for (i = 2; i < c->argc; i += 2)
        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);

    /* HMSET (deprecated) and HSET return value is different. */
    char *cmdname = c->argv[0]->ptr;
    if (cmdname[1] == 's' || cmdname[1] == 'S') {
        /* HSET */
        addReplyLongLong(c, created);
    } else {
        /* HMSET */
        addReply(c, shared.ok);
    }
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_HASH,""hset"",c->argv[1],c->db->id);
    server.dirty += (c->argc - 2)/2;
}",606.0,633.0,1.0,68.0,28.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6690,397449,hsetnxCommand,1,hsetnxCommand,void hsetnxCommand (client*),t_hash.c,"void hsetnxCommand(client *c) {
    robj *o;
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;

    if (hashTypeExists(o, c->argv[2]->ptr)) {
        addReply(c, shared.czero);
    } else {
        hashTypeTryConversion(o,c->argv,2,3);
        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);
        addReply(c, shared.cone);
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_HASH,""hset"",c->argv[1],c->db->id);
        server.dirty++;
    }
}",590.0,604.0,1.0,54.0,15.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6691,397454,hgetCommand,1,hgetCommand,void hgetCommand (client*),t_hash.c,"void hgetCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    addHashFieldToReply(c, o, c->argv[2]->ptr);
}",743.0,750.0,1.0,22.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6692,397459,hmgetCommand,1,hmgetCommand,void hmgetCommand (client*),t_hash.c,"void hmgetCommand(client *c) {
    robj *o;
    int i;

    /* Don't abort when the key cannot be found. Non-existing keys are empty
     * hashes, where HMGET should respond with a series of null bulks. */
    o = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c,o,OBJ_HASH)) return;

    addReplyArrayLen(c, c->argc-2);
    for (i = 2; i < c->argc; i++) {
        addHashFieldToReply(c, o, c->argv[i]->ptr);
    }
}",752.0,765.0,1.0,22.0,14.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6693,397464,hdelCommand,1,hdelCommand,void hdelCommand (client*),t_hash.c,"void hdelCommand(client *c) {
    robj *o;
    int j, deleted = 0, keyremoved = 0;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    for (j = 2; j < c->argc; j++) {
        if (hashTypeDelete(o,c->argv[j]->ptr)) {
            deleted++;
            if (hashTypeLength(o) == 0) {
                dbDelete(c->db,c->argv[1]);
                keyremoved = 1;
                break;
            }
        }
    }
    if (deleted) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_HASH,""hdel"",c->argv[1],c->db->id);
        if (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",c->argv[1],
                                c->db->id);
        server.dirty += deleted;
    }
    addReplyLongLong(c,deleted);
}",767.0,793.0,1.0,22.0,27.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6694,397469,hlenCommand,1,hlenCommand,void hlenCommand (client*),t_hash.c,"void hlenCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    addReplyLongLong(c,hashTypeLength(o));
}",795.0,802.0,1.0,22.0,8.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6695,397474,hstrlenCommand,1,hstrlenCommand,void hstrlenCommand (client*),t_hash.c,"void hstrlenCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;
    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));
}",804.0,810.0,1.0,22.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6696,397479,zremrangebyrankCommand,1,zremrangebyrankCommand,void zremrangebyrankCommand (client*),t_zset.c,"void zremrangebyrankCommand(client *c) {
    zremrangeGenericCommand(c,ZRANGE_RANK);
}",1987.0,1989.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6697,397484,zunionstoreCommand,1,zunionstoreCommand,void zunionstoreCommand (client*),t_zset.c,"void zunionstoreCommand(client *c) {
    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_UNION, 0);
}",2863.0,2865.0,1.0,52.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6698,397489,zinterstoreCommand,1,zinterstoreCommand,void zinterstoreCommand (client*),t_zset.c,"void zinterstoreCommand(client *c) {
    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_INTER, 0);
}",2868.0,2870.0,1.0,52.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6699,397494,zdiffstoreCommand,1,zdiffstoreCommand,void zdiffstoreCommand (client*),t_zset.c,"void zdiffstoreCommand(client *c) {
    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_DIFF, 0);
}",2873.0,2875.0,1.0,52.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6700,397499,zunionCommand,1,zunionCommand,void zunionCommand (client*),t_zset.c,"void zunionCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_UNION, 0);
}",2878.0,2880.0,1.0,46.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6701,397504,zinterCommand,1,zinterCommand,void zinterCommand (client*),t_zset.c,"void zinterCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 0);
}",2883.0,2885.0,1.0,46.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6702,397509,zinterCardCommand,1,zinterCardCommand,void zinterCardCommand (client*),t_zset.c,"void zinterCardCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 1);
}",2888.0,2890.0,1.0,46.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6703,397514,zrangestoreCommand,1,zrangestoreCommand,void zrangestoreCommand (client*),t_zset.c,"void zrangestoreCommand (client *c) {
    robj *dstkey = c->argv[1];
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_INTERNAL);
    zrangeResultHandlerDestinationKeySet(&handler, dstkey);
    zrangeGenericCommand(&handler, 2, 1, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);
}",3176.0,3182.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6704,397519,zdiffCommand,1,zdiffCommand,void zdiffCommand (client*),t_zset.c,"void zdiffCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_DIFF, 0);
}",2893.0,2895.0,1.0,46.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6705,397524,zscanCommand,1,zscanCommand,void zscanCommand (client*),t_zset.c,"void zscanCommand(client *c) {
    robj *o;
    unsigned long cursor;

    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
        checkType(c,o,OBJ_ZSET)) return;
    scanGenericCommand(c,o,cursor);
}",3860.0,3868.0,1.0,56.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6706,397529,hkeysCommand,1,hkeysCommand,void hkeysCommand (client*),t_hash.c,"void hkeysCommand(client *c) {
    genericHgetallCommand(c,OBJ_HASH_KEY);
}",869.0,871.0,1.0,28.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6707,397534,hvalsCommand,1,hvalsCommand,void hvalsCommand (client*),t_hash.c,"void hvalsCommand(client *c) {
    genericHgetallCommand(c,OBJ_HASH_VALUE);
}",873.0,875.0,1.0,28.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6708,397539,hgetallCommand,1,hgetallCommand,void hgetallCommand (client*),t_hash.c,"void hgetallCommand(client *c) {
    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);
}",877.0,879.0,1.0,28.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6709,397544,hexistsCommand,1,hexistsCommand,void hexistsCommand (client*),t_hash.c,"void hexistsCommand(client *c) {
    robj *o;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);
}",881.0,887.0,1.0,22.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6710,397549,hscanCommand,1,hscanCommand,void hscanCommand (client*),t_hash.c,"void hscanCommand(client *c) {
    robj *o;
    unsigned long cursor;

    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;
    scanGenericCommand(c,o,cursor);
}",889.0,897.0,1.0,56.0,9.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6711,397554,hrandfieldCommand,1,hrandfieldCommand,void hrandfieldCommand (client*),t_hash.c,"void hrandfieldCommand(client *c) {
    long l;
    int withvalues = 0;
    robj *hash;
    listpackEntry ele;

    if (c->argc >= 3) {
        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,""withvalues""))) {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        } else if (c->argc == 4) {
            withvalues = 1;
            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {
                addReplyError(c,""value is out of range"");
                return;
            }
        }
        hrandfieldWithCountCommand(c, l, withvalues);
        return;
    }

    /* Handle variant without <count> argument. Reply with simple bulk string */
    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||
        checkType(c,hash,OBJ_HASH)) {
        return;
    }

    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);
    hashRep...",1133.0,1163.0,1.0,86.0,31.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6712,397584,hincrbyCommand,1,hincrbyCommand,void hincrbyCommand (client*),t_hash.c,"void hincrbyCommand(client *c) {
    long long value, incr, oldvalue;
    robj *o;
    sds new;
    unsigned char *vstr;
    unsigned int vlen;

    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {
        if (vstr) {
            if (string2ll((char*)vstr,vlen,&value) == 0) {
                addReplyError(c,""hash value is not an integer"");
                return;
            }
        } /* Else hashTypeGetValue() already stored it into &value */
    } else {
        value = 0;
    }

    oldvalue = value;
    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
        addReplyError(c,""increment or decrement would overflow"");
        return;
    }
    value += incr;
    new = sdsfromlonglong(value);
    hashTypeSet(o,c->argv[2]->ptr,...",635.0,668.0,1.0,65.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6713,397589,hincrbyfloatCommand,1,hincrbyfloatCommand,void hincrbyfloatCommand (client*),t_hash.c,"void hincrbyfloatCommand(client *c) {
    long double value, incr;
    long long ll;
    robj *o;
    sds new;
    unsigned char *vstr;
    unsigned int vlen;

    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
    if (isnan(incr) || isinf(incr)) {
        addReplyError(c,""value is NaN or Infinity"");
        return;
    }
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {
        if (vstr) {
            if (string2ld((char*)vstr,vlen,&value) == 0) {
                addReplyError(c,""hash value is not a float"");
                return;
            }
        } else {
            value = (long double)ll;
        }
    } else {
        value = 0;
    }

    value += incr;
    if (isnan(value) || isinf(value)) {
        addReplyError(c,""increment would produce NaN or Infinity"");
        return;
    }

    char buf[MAX_LONG_DOUBLE_CHARS];
    int len = ld2string(buf,si...",670.0,720.0,1.0,67.0,51.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6714,397921,xaddCommand,1,xaddCommand,void xaddCommand (client*),t_stream.c,"void xaddCommand(client *c) {
    /* Parse options. */
    streamAddTrimArgs parsed_args;
    int idpos = streamParseAddOrTrimArgsOrReply(c, &parsed_args, 1);
    if (idpos < 0)
        return; /* streamParseAddOrTrimArgsOrReply already replied. */
    int field_pos = idpos+1; /* The ID is always one argument before the first field */

    /* Check arity. */
    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {
        addReplyErrorArity(c);
        return;
    }

    /* Return ASAP if minimal ID (0-0) was given so we avoid possibly creating
     * a new stream and have streamAppendItem fail, leaving an empty key in the
     * database. */
    if (parsed_args.id_given && parsed_args.seq_given &&
        parsed_args.id.ms == 0 && parsed_args.id.seq == 0)
    {
        addReplyError(c,""The ID specified in XADD must be greater than 0-0"");
        return;
    }

    /* Lookup the stream at key. */
    robj *o;
    stream *s;
    if ((o = streamTypeLookupWriteOrCreate(c,...",1997.0,2084.0,1.0,84.0,88.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6715,397926,xrangeCommand,1,xrangeCommand,void xrangeCommand (client*),t_stream.c,"void xrangeCommand(client *c) {
    xrangeGenericCommand(c,0);
}",2147.0,2149.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6716,397931,xrevrangeCommand,1,xrevrangeCommand,void xrevrangeCommand (client*),t_stream.c,"void xrevrangeCommand(client *c) {
    xrangeGenericCommand(c,1);
}",2152.0,2154.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6717,397936,xlenCommand,1,xlenCommand,void xlenCommand (client*),t_stream.c,"void xlenCommand(client *c) {
    robj *o;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    stream *s = o->ptr;
    addReplyLongLong(c,s->length);
}",2157.0,2163.0,1.0,25.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6718,397941,xreadCommand,1,xreadCommand,void xreadCommand (client*),t_stream.c,"void xreadCommand(client *c) {
    long long timeout = -1; /* -1 means, no BLOCK argument given. */
    long long count = 0;
    int streams_count = 0;
    int streams_arg = 0;
    int noack = 0;          /* True if NOACK option was specified. */
    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
    streamID *ids = static_ids;
    streamCG **groups = NULL;
    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */
    robj *groupname = NULL;
    robj *consumername = NULL;

    /* Parse arguments. */
    for (int i = 1; i < c->argc; i++) {
        int moreargs = c->argc-i-1;
        char *o = c->argv[i]->ptr;
        if (!strcasecmp(o,""BLOCK"") && moreargs) {
            if (c->flags & CLIENT_SCRIPT) {
                /*
                 * Although the CLIENT_DENY_BLOCKING flag should protect from blocking the client
                 * on Lua/MULTI/RM_Call we want special treatment for Lua to keep backward compatibility.
                 * There is no sense to u...",2173.0,2444.0,1.0,24.0,272.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6719,397946,xgroupCommand,1,xgroupCommand,void xgroupCommand (client*),t_stream.c,"void xgroupCommand(client *c) {
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */
    int mkstream = 0;
    long long entries_read = SCG_INVALID_ENTRIES_READ;
    robj *o;

    /* Everything but the ""HELP"" option requires a key and group name. */
    if (c->argc >= 4) {
        /* Parse optional arguments for CREATE and SETID */
        int i = 5;
        int create_subcmd = !strcasecmp(opt,""CREATE"");
        int setid_subcmd = !strcasecmp(opt,""SETID"");
        while (i < c->argc) {
            if (create_subcmd && !strcasecmp(c->argv[i]->ptr,""MKSTREAM"")) {
                mkstream = 1;
                i++;
            } else if ((create_subcmd || setid_subcmd) && !strcasecmp(c->argv[i]->ptr,""ENTRIESREAD"") && i + 1 < c->argc) {
                if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_read,NULL) != C_OK)
                    return;
                if (entries_read < 0 && entries_read != SCG_I...",2574.0,2735.0,1.0,29.0,162.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6720,397951,xsetidCommand,1,xsetidCommand,void xsetidCommand (client*),t_stream.c,"void xsetidCommand(client *c) {
    streamID id, max_xdel_id = {0, 0};
    long long entries_added = -1;

    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0,NULL) != C_OK)
        return;

    int i = 3;
    while (i < c->argc) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (!strcasecmp(opt,""ENTRIESADDED"") && moreargs) {
            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_added,NULL) != C_OK) {
                return;
            } else if (entries_added < 0) {
                addReplyError(c,""entries_added must be positive"");
                return;
            }
            i += 2;
        } else if (!strcasecmp(opt,""MAXDELETEDID"") && moreargs) {
            if (streamParseStrictIDOrReply(c,c->argv[i+1],&max_xdel_id,0,NULL) != C_OK) {
                return;
            } else if (streamCompareID(&id,&max_xdel_id) < 0) {
                addReplyError(c,""The ID specified in XSETID i...",2741.0,2810.0,1.0,63.0,70.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6721,397956,xackCommand,1,xackCommand,void xackCommand (client*),t_stream.c,"void xackCommand(client *c) {
    streamCG *group = NULL;
    robj *o = lookupKeyRead(c->db,c->argv[1]);
    if (o) {
        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */
        group = streamLookupCG(o->ptr,c->argv[2]->ptr);
    }

    /* No key or group? Nothing to ack. */
    if (o == NULL || group == NULL) {
        addReply(c,shared.czero);
        return;
    }

    /* Start parsing the IDs, so that we abort ASAP if there is a syntax
     * error: the return value of this command cannot be an error in case
     * the client successfully acknowledged some messages, so it should be
     * executed in a ""all or nothing"" fashion. */
    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
    streamID *ids = static_ids;
    int id_count = c->argc-3;
    if (id_count > STREAMID_STATIC_VECTOR_LEN)
        ids = zmalloc(sizeof(streamID)*id_count);
    for (int j = 3; j < c->argc; j++) {
        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-3],0,NULL) != C_OK) goto clean...",2820.0,2867.0,1.0,26.0,48.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6722,397961,xpendingCommand,1,xpendingCommand,void xpendingCommand (client*),t_stream.c,"void xpendingCommand(client *c) {
    int justinfo = c->argc == 3; /* Without the range just outputs general
                                    information about the PEL. */
    robj *key = c->argv[1];
    robj *groupname = c->argv[2];
    robj *consumername = NULL;
    streamID startid, endid;
    long long count = 0;
    long long minidle = 0;
    int startex = 0, endex = 0;

    /* Start and stop, and the consumer, can be omitted. Also the IDLE modifier. */
    if (c->argc != 3 && (c->argc < 6 || c->argc > 9)) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Parse start/end/count arguments ASAP if needed, in order to report
     * syntax errors before any other error. */
    if (c->argc >= 6) {
        int startidx = 3; /* Without IDLE */

        if (!strcasecmp(c->argv[3]->ptr, ""IDLE"")) {
            if (getLongLongFromObjectOrReply(c, c->argv[4], &minidle, NULL) == C_ERR)
                return;
            if (c->argc < 8) {
                /*...",2878.0,3051.0,1.0,79.0,174.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6723,397966,xclaimCommand,1,xclaimCommand,void xclaimCommand (client*),t_stream.c,"void xclaimCommand(client *c) {
    streamCG *group = NULL;
    robj *o = lookupKeyRead(c->db,c->argv[1]);
    long long minidle; /* Minimum idle time argument. */
    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */
    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */
    int force = 0;
    int justid = 0;

    if (o) {
        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */
        group = streamLookupCG(o->ptr,c->argv[2]->ptr);
    }

    /* No key or group? Send an error given that the group creation
     * is mandatory. */
    if (o == NULL || group == NULL) {
        addReplyErrorFormat(c,""-NOGROUP No such key '%s' or ""
                              ""consumer group '%s'"", (char*)c->argv[1]->ptr,
                              (char*)c->argv[2]->ptr);
        return;
    }

    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,
        ""Invalid min-idle-time argument for XCLAIM"")
        != C_OK) return;
    if (minid...",3119.0,3320.0,1.0,26.0,202.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6724,397971,xautoclaimCommand,1,xautoclaimCommand,void xautoclaimCommand (client*),t_stream.c,"void xautoclaimCommand(client *c) {
    streamCG *group = NULL;
    robj *o = lookupKeyRead(c->db,c->argv[1]);
    long long minidle; /* Minimum idle time argument, in milliseconds. */
    long count = 100; /* Maximum entries to claim. */
    const unsigned attempts_factor = 10;
    streamID startid;
    int startex;
    int justid = 0;

    /* Parse idle/start/end/count arguments ASAP if needed, in order to report
     * syntax errors before any other error. */
    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,""Invalid min-idle-time argument for XAUTOCLAIM"") != C_OK)
        return;
    if (minidle < 0) minidle = 0;

    if (streamParseIntervalIDOrReply(c,c->argv[5],&startid,&startex,0) != C_OK)
        return;
    if (startex && streamIncrID(&startid) != C_OK) {
        addReplyError(c,""invalid start ID for the interval"");
        return;
    }

    int j = 6; /* options start at argv[6] */
    while(j < c->argc) {
        int moreargs = (c->argc-1) - j; /* Number of addi...",3338.0,3510.0,1.0,111.0,173.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6725,397976,xinfoCommand,1,xinfoCommand,void xinfoCommand (client*),t_stream.c,"void xinfoCommand(client *c) {
    stream *s = NULL;
    char *opt;
    robj *key;

    /* HELP is special. Handle it ASAP. */
    if (!strcasecmp(c->argv[1]->ptr,""HELP"")) {
        const char *help[] = {
""CONSUMERS <key> <groupname>"",
""    Show consumers of <groupname>."",
""GROUPS <key>"",
""    Show the stream consumer groups."",
""STREAM <key> [FULL [COUNT <count>]"",
""    Show information about the stream."",
NULL
        };
        addReplyHelp(c, help);
        return;
    }

    /* With the exception of HELP handled before any other sub commands, all
     * the ones are in the form of ""<subcommand> <key>"". */
    opt = c->argv[1]->ptr;
    key = c->argv[2];

    /* Lookup the key now, this is common for all the subcommands but HELP. */
    robj *o = lookupKeyReadOrReply(c,key,shared.nokeyerr);
    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
    s = o->ptr;

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CONSUMERS"") && c->argc == 4) {
        /* XINFO ...",3845.0,3946.0,1.0,35.0,102.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6726,397981,xdelCommand,1,xdelCommand,void xdelCommand (client*),t_stream.c,"void xdelCommand(client *c) {
    robj *o;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    stream *s = o->ptr;

    /* We need to sanity check the IDs passed to start. Even if not
     * a big issue, it is not great that the command is only partially
     * executed because at some point an invalid ID is parsed. */
    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
    streamID *ids = static_ids;
    int id_count = c->argc-2;
    if (id_count > STREAMID_STATIC_VECTOR_LEN)
        ids = zmalloc(sizeof(streamID)*id_count);
    for (int j = 2; j < c->argc; j++) {
        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-2],0,NULL) != C_OK) goto cleanup;
    }

    /* Actually apply the command. */
    int deleted = 0;
    int first_entry = 0;
    for (int j = 2; j < c->argc; j++) {
        streamID *id = &ids[j-2];
        if (streamDeleteItem(s,id)) {
            /* We want to know if the first entry in the s...",3517.0,3574.0,1.0,25.0,58.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6727,397986,xtrimCommand,1,xtrimCommand,void xtrimCommand (client*),t_stream.c,"void xtrimCommand(client *c) {
    robj *o;

    /* Argument parsing. */
    streamAddTrimArgs parsed_args;
    if (streamParseAddOrTrimArgsOrReply(c, &parsed_args, 0) < 0)
        return; /* streamParseAddOrTrimArgsOrReply already replied. */

    /* If the key does not exist, we are ok returning zero, that is, the
     * number of elements removed from the stream. */
    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    stream *s = o->ptr;

    /* Perform the trimming. */
    int64_t deleted = streamTrim(s, &parsed_args);
    if (deleted) {
        notifyKeyspaceEvent(NOTIFY_STREAM,""xtrim"",c->argv[1],c->db->id);
        if (parsed_args.approx_trim) {
            /* In case our trimming was limited (by LIMIT or by ~) we must
             * re-write the relevant trim argument to make sure there will be
             * no inconsistencies in AOF loading or in the replica.
             * It's enough to check only args->a...",3599.0,3632.0,1.0,25.0,34.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6728,398001,lcsCommand,1,lcsCommand,void lcsCommand (client*),t_string.c,"void lcsCommand(client *c) {
    uint32_t i, j;
    long long minmatchlen = 0;
    sds a = NULL, b = NULL;
    int getlen = 0, getidx = 0, withmatchlen = 0;
    robj *obja = NULL, *objb = NULL;

    obja = lookupKeyRead(c->db,c->argv[1]);
    objb = lookupKeyRead(c->db,c->argv[2]);
    if ((obja && obja->type != OBJ_STRING) ||
        (objb && objb->type != OBJ_STRING))
    {
        addReplyError(c,
            ""The specified keys must contain string values"");
        /* Don't cleanup the objects, we need to do that
         * only after calling getDecodedObject(). */
        obja = NULL;
        objb = NULL;
        goto cleanup;
    }
    obja = obja ? getDecodedObject(obja) : createStringObject("""",0);
    objb = objb ? getDecodedObject(objb) : createStringObject("""",0);
    a = obja->ptr;
    b = objb->ptr;

    for (j = 3; j < (uint32_t)c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->argc-1) - j;

        if (!strcasecmp(opt,""IDX"")) {
            ...",737.0,950.0,1.0,31.0,214.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6729,398232,SHA1Transform,1,SHA1Transform,"void SHA1Transform (uint32_t[5],unsigned char[64])",sha1.c,"void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
{
    uint32_t a, b, c, d, e;
    typedef union {
        unsigned char c[64];
        uint32_t l[16];
    } CHAR64LONG16;
#ifdef SHA1HANDSOFF
    CHAR64LONG16 block[1];  /* use array to appear as a pointer */
    memcpy(block, buffer, 64);
#else
    /* The following had better never be used because it causes the
     * pointer-to-const buffer to be cast into a pointer to non-const.
     * And the result is written through.  I threw a ""const"" in, hoping
     * this will cause a diagnostic.
     */
    CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
#endif
    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,...",56.0,112.0,1.0,4.0,57.0,4102,12,1785,8,2,0,1,1,0,0,,0,0,4,2,2,void
6730,407283,SHA1Init,1,SHA1Init,void SHA1Init (SHA1_CTX*),sha1.c,"void SHA1Init(SHA1_CTX* context)
{
    /* SHA1 initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
    context->count[0] = context->count[1] = 0;
}",117.0,126.0,1.0,1.0,10.0,21,3,7,1,3,7,1,1,0,0,,0,7,2,1,1,void
6731,407336,SHA1Update,1,SHA1Update,"void SHA1Update (SHA1_CTX*,unsigned char*,uint32_t)",sha1.c,"void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
{
    uint32_t i, j;

    j = context->count[0];
    if ((context->count[0] += len << 3) < j)
        context->count[1]++;
    context->count[1] += (len>>29);
    j = (j >> 3) & 63;
    if ((j + len) > 63) {
        memcpy(&context->buffer[j], data, (i = 64-j));
        SHA1Transform(context->state, context->buffer);
        for ( ; i + 63 < len; i += 64) {
            SHA1Transform(context->state, &data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&context->buffer[j], &data[i], len - i);
}",139.0,158.0,1.0,1.0,20.0,39,13,31,5,6,11,4,5,1,2,,0,9,6,3,3,void
6732,407455,SHA1Final,1,SHA1Final,"void SHA1Final (unsigned char[20],SHA1_CTX*)",sha1.c,"void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
{
    unsigned i;
    unsigned char finalcount[8];
    unsigned char c;

#if 0	/* untested ""improvement"" by DHR */
    /* Convert context->count to a sequence of bytes
     * in finalcount.  Second element first, but
     * big-endian order within element.
     * But we do it all backwards.
     */
    unsigned char *fcp = &finalcount[8];

    for (i = 0; i < 2; i++)
       {
        uint32_t t = context->count[i];
        int j;

        for (j = 0; j < 4; t >>= 8, j++)
	          *--fcp = (unsigned char) t;
    }
#else
    for (i = 0; i < 8; i++) {
        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
    }
#endif
    c = 0200;
    SHA1Update(context, &c, 1);
    while ((context->count[0] & 504) != 448) {
	c = 0000;
        SHA1Update(context, &c, 1);
    }
    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
   ...",166.0,208.0,1.0,1.0,43.0,39,15,27,5,3,6,4,4,1,3,,0,3,4,2,2,void
6733,407701,sha256_transform,1,sha256_transform,"void sha256_transform (SHA256_CTX*,BYTE[])",sha256.c,"void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for (i = 0, j = 0; i < 16; ++i, j += 4) {
        m[i] = ((WORD) data[j + 0] << 24) |
               ((WORD) data[j + 1] << 16) |
               ((WORD) data[j + 2] << 8) |
               ((WORD) data[j + 3]);
    }

	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];

	for (i = 0; i < 64; ++i) {
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
		t2 = EP0(a) + MAJ(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}",44.0,88.0,1.0,9.0,45.0,131,15,103,16,2,17,4,4,0,0,,0,17,4,2,2,void
6734,408154,sha256_init,1,sha256_init,void sha256_init (SHA256_CTX*),sha256.c,"void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}",90.0,102.0,1.0,1.0,13.0,28,3,10,1,1,10,1,1,0,0,,0,10,2,1,1,void
6735,408225,sha256_update,1,sha256_update,"void sha256_update (SHA256_CTX*,BYTE[],size_t)",sha256.c,"void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
	WORD i;

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			sha256_transform(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
}",104.0,117.0,1.0,1.0,14.0,16,7,13,4,1,8,3,4,1,1,,0,7,6,3,3,void
6736,408281,sha256_final,1,sha256_final,"void sha256_final (SHA256_CTX*,BYTE[])",sha256.c,"void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
	WORD i;

	i = ctx->datalen;

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	sha256_transform(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]     ...",119.0,163.0,1.0,1.0,45.0,126,11,60,3,1,31,4,5,1,1,,0,30,4,2,2,void
6737,408672,siptlw,1,siptlw,int siptlw (int),siphash.c,"int siptlw(int c) {
    if (c >= 'A' && c <= 'Z') {
        return c+('a'-'A');
    } else {
        return c;
    }
}",50.0,56.0,1.0,1.0,7.0,5,5,3,1,0,0,2,2,0,0,,0,0,2,1,1,int
6738,410458,slowlogCreateEntry,1,slowlogCreateEntry,"slowlogEntry slowlogCreateEntry (client*,robj**,int,long long)",slowlog.c,"slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {
    slowlogEntry *se = zmalloc(sizeof(*se));
    int j, slargc = argc;

    if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
    se->argc = slargc;
    se->argv = zmalloc(sizeof(robj*)*slargc);
    for (j = 0; j < slargc; j++) {
        /* Logging too many arguments is a useless memory waste, so we stop
         * at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify
         * how many remaining arguments there were in the original command. */
        if (slargc != argc && j == slargc-1) {
            se->argv[j] = createObject(OBJ_STRING,
                sdscatprintf(sdsempty(),""... (%d more arguments)"",
                argc-slargc+1));
        } else {
            /* Trim too long strings as well... */
            if (argv[j]->type == OBJ_STRING &&
                sdsEncodedObject(argv[j]) &&
                sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)
     ...",48.0,94.0,1.0,17.0,47.0,39,16,34,9,1,19,4,5,0,9,,0,19,8,4,4,slowlogEntry
6739,410706,slowlogFreeEntry,1,slowlogFreeEntry,void slowlogFreeEntry (void*),slowlog.c,"void slowlogFreeEntry(void *septr) {
    slowlogEntry *se = septr;
    int j;

    for (j = 0; j < se->argc; j++)
        decrRefCount(se->argv[j]);
    zfree(se->argv);
    sdsfree(se->peerid);
    sdsfree(se->cname);
    zfree(se);
}",100.0,110.0,1.0,1.0,11.0,7,3,9,3,0,8,2,2,1,4,,0,4,2,1,1,void
6740,410748,slowlogInit,1,slowlogInit,void slowlogInit (void),slowlog.c,"void slowlogInit(void) {
    server.slowlog = listCreate();
    server.slowlog_entry_id = 0;
    listSetFreeMethod(server.slowlog,slowlogFreeEntry);
}",114.0,118.0,1.0,4.0,5.0,8,3,4,1,1,1,1,1,0,1,,0,1,2,1,1,void
6741,410776,slowlogPushEntryIfNeeded,1,slowlogPushEntryIfNeeded,"void slowlogPushEntryIfNeeded (client*,robj**,int,long long)",slowlog.c,"void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
    if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */
    if (duration >= server.slowlog_log_slower_than)
        listAddNodeHead(server.slowlog,
                        slowlogCreateEntry(c,argv,argc,duration));

    /* Remove old entries if needed. */
    while (listLength(server.slowlog) > server.slowlog_max_len)
        listDelNode(server.slowlog,listLast(server.slowlog));
}",123.0,132.0,1.0,11.0,10.0,10,5,11,5,1,2,4,4,0,2,,0,1,8,4,4,void
6742,410837,slowlogReset,1,slowlogReset,void slowlogReset (void),slowlog.c,"void slowlogReset(void) {
    while (listLength(server.slowlog) > 0)
        listDelNode(server.slowlog,listLast(server.slowlog));
}",135.0,138.0,1.0,11.0,4.0,4,3,2,1,0,0,2,2,0,0,,0,0,2,1,1,void
6743,411198,connCreateSocket,1,connCreateSocket,connection connCreateSocket (void),socket.c,"static connection *connCreateSocket(void) {
    connection *conn = zcalloc(sizeof(connection));
    conn->type = &CT_Socket;
    conn->fd = -1;
    conn->iovcnt = IOV_MAX;

    return conn;
}",77.0,84.0,1.0,1.0,8.0,10,5,8,4,1,5,1,1,0,1,,0,5,2,1,1,connection
6744,411228,connCreateAcceptedSocket,1,connCreateAcceptedSocket,"connection connCreateAcceptedSocket (int,void*)",socket.c,"static connection *connCreateAcceptedSocket(int fd, void *priv) {
    UNUSED(priv);
    connection *conn = connCreateSocket();
    conn->fd = fd;
    conn->state = CONN_STATE_ACCEPTING;
    return conn;
}",96.0,102.0,1.0,4.0,7.0,6,3,8,4,1,3,1,1,0,1,,0,3,4,2,2,connection
6745,411256,connSocketConnect,1,connSocketConnect,"int connSocketConnect (connection*,char*,int,char*,ConnectionCallbackFunc)",socket.c,"static int connSocketConnect(connection *conn, const char *addr, int port, const char *src_addr,
        ConnectionCallbackFunc connect_handler) {
    int fd = anetTcpNonBlockBestEffortBindConnect(NULL,addr,port,src_addr);
    if (fd == -1) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = errno;
        return C_ERR;
    }

    conn->fd = fd;
    conn->state = CONN_STATE_CONNECTING;

    conn->conn_handler = connect_handler;
    aeCreateFileEvent(server.el, conn->fd, AE_WRITABLE,
            conn->type->ae_handler, conn);

    return C_OK;
}",104.0,121.0,1.0,15.0,18.0,18,5,20,11,0,9,2,2,0,2,,0,8,10,5,5,int
6746,411329,connSocketShutdown,1,connSocketShutdown,void connSocketShutdown (connection*),socket.c,"static void connSocketShutdown(connection *conn) {
    if (conn->fd == -1) return;

    shutdown(conn->fd, SHUT_RDWR);
}",129.0,133.0,1.0,1.0,5.0,4,3,3,2,0,2,2,2,1,0,,0,2,2,1,1,void
6747,411348,connSocketClose,1,connSocketClose,void connSocketClose (connection*),socket.c,"static void connSocketClose(connection *conn) {
    if (conn->fd != -1) {
        aeDeleteFileEvent(server.el,conn->fd, AE_READABLE | AE_WRITABLE);
        close(conn->fd);
        conn->fd = -1;
    }

    /* If called from within a handler, schedule the close but
     * keep the connection until the handler returns.
     */
    if (connHasRefs(conn)) {
        conn->flags |= CONN_FLAG_CLOSE_SCHEDULED;
        return;
    }

    zfree(conn);
}",136.0,152.0,1.0,46.0,17.0,12,7,8,2,0,8,3,3,2,3,,0,6,2,1,1,void
6748,411401,connSocketWrite,1,connSocketWrite,"int connSocketWrite (connection*,void*,size_t)",socket.c,"static int connSocketWrite(connection *conn, const void *data, size_t data_len) {
    int ret = write(conn->fd, data, data_len);
    if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",154.0,167.0,1.0,1.0,14.0,13,6,16,9,0,4,3,4,1,0,,0,4,6,3,3,int
6749,411449,connSocketWritev,1,connSocketWritev,"int connSocketWritev (connection*,iovec*,int)",socket.c,"static int connSocketWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    int ret = writev(conn->fd, iov, iovcnt);
    if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",169.0,182.0,1.0,1.0,14.0,13,6,16,9,0,4,3,4,1,0,,0,4,6,3,3,int
6750,411497,connSocketRead,1,connSocketRead,"int connSocketRead (connection*,void*,size_t)",socket.c,"static int connSocketRead(connection *conn, void *buf, size_t buf_len) {
    int ret = read(conn->fd, buf, buf_len);
    if (!ret) {
        conn->state = CONN_STATE_CLOSED;
    } else if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",184.0,199.0,1.0,1.0,16.0,5,3,8,5,0,2,2,2,0,0,,0,2,6,3,3,int
6751,411556,connSocketAccept,1,connSocketAccept,"int connSocketAccept (connection*,ConnectionCallbackFunc)",socket.c,"static int connSocketAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    int ret = C_OK;

    if (conn->state != CONN_STATE_ACCEPTING) return C_ERR;
    conn->state = CONN_STATE_CONNECTED;

    connIncrRefs(conn);
    if (!callHandler(conn, accept_handler)) ret = C_ERR;
    connDecrRefs(conn);

    return ret;
}",201.0,212.0,1.0,14.0,12.0,9,5,11,5,0,5,3,3,2,3,,0,3,4,2,2,int
6752,411603,connSocketSetWriteHandler,1,connSocketSetWriteHandler,"int connSocketSetWriteHandler (connection*,ConnectionCallbackFunc,int)",socket.c,"static int connSocketSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {
    if (func == conn->write_handler) return C_OK;

    conn->write_handler = func;
    if (barrier)
        conn->flags |= CONN_FLAG_WRITE_BARRIER;
    else
        conn->flags &= ~CONN_FLAG_WRITE_BARRIER;
    if (!conn->write_handler)
        aeDeleteFileEvent(server.el,conn->fd,AE_WRITABLE);
    else
        if (aeCreateFileEvent(server.el,conn->fd,AE_WRITABLE,
                    conn->type->ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
}",222.0,236.0,1.0,44.0,15.0,10,6,9,4,0,6,4,4,2,1,,0,5,6,3,3,int
6753,411700,connSocketSetReadHandler,1,connSocketSetReadHandler,"int connSocketSetReadHandler (connection*,ConnectionCallbackFunc)",socket.c,"static int connSocketSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    if (func == conn->read_handler) return C_OK;

    conn->read_handler = func;
    if (!conn->read_handler)
        aeDeleteFileEvent(server.el,conn->fd,AE_READABLE);
    else
        if (aeCreateFileEvent(server.el,conn->fd,
                    AE_READABLE,conn->type->ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
}",241.0,251.0,1.0,43.0,11.0,8,5,7,3,0,5,3,3,2,1,,0,4,4,2,2,int
6754,411772,connSocketGetLastError,1,connSocketGetLastError,const char* connSocketGetLastError (connection*),socket.c,"static const char *connSocketGetLastError(connection *conn) {
    return strerror(conn->last_errno);
}",253.0,255.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,const char*
6755,411782,connSocketEventHandler,1,connSocketEventHandler,"void connSocketEventHandler (aeEventLoop*,int,void*,int)",socket.c,"static void connSocketEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask)
{
    UNUSED(el);
    UNUSED(fd);
    connection *conn = clientData;

    if (conn->state == CONN_STATE_CONNECTING &&
            (mask & AE_WRITABLE) && conn->conn_handler) {

        int conn_error = anetGetError(conn->fd);
        if (conn_error) {
            conn->last_errno = conn_error;
            conn->state = CONN_STATE_ERROR;
        } else {
            conn->state = CONN_STATE_CONNECTED;
        }

        if (!conn->write_handler) aeDeleteFileEvent(server.el,conn->fd,AE_WRITABLE);

        if (!callHandler(conn, conn->conn_handler)) return;
        conn->conn_handler = NULL;
    }

    /* Normally we execute the readable event first, and the writable
     * event later. This is useful as sometimes we may be able
     * to serve the reply of a query immediately after processing the
     * query.
     *
     * However if WRITE_BARRIER is set in the mask, our application is
    ...",257.0,309.0,1.0,4.0,53.0,44,9,43,13,0,21,11,17,11,6,,0,20,8,4,4,void
6756,411957,connSocketAcceptHandler,1,connSocketAcceptHandler,"void connSocketAcceptHandler (aeEventLoop*,int,void*,int)",socket.c,"static void connSocketAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) {
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    ""Accepting client connection: %s"", server.neterr);
            return;
        }
        serverLog(LL_VERBOSE,""Accepted %s:%d"", cip, cport);
        acceptCommonHandler(connCreateAcceptedSocket(cfd, NULL),0,cip);
    }
}",311.0,329.0,1.0,26.0,19.0,19,11,25,12,0,5,4,7,0,5,,0,2,8,4,4,void
6757,412069,connSocketAddr,1,connSocketAddr,"int connSocketAddr (connection*,char*,size_t,int*,int)",socket.c,"static int connSocketAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    if (anetFdToString(conn->fd, ip, ip_len, port, remote) == 0)
        return C_OK;

    conn->last_errno = errno;
    return C_ERR;
}",331.0,337.0,1.0,15.0,7.0,5,4,7,6,1,3,2,2,2,1,,0,3,10,5,5,int
6758,412104,connSocketIsLocal,1,connSocketIsLocal,int connSocketIsLocal (connection*),socket.c,"static int connSocketIsLocal(connection *conn) {
    char cip[NET_IP_STR_LEN + 1] = { 0 };

    if (connSocketAddr(conn, cip, sizeof(cip) - 1, NULL, 1) == C_ERR)
        return -1;

    return !strncmp(cip, ""127."", 4) || !strcmp(cip, ""::1"");
}",339.0,346.0,1.0,13.0,8.0,10,8,7,3,0,1,2,2,1,1,,0,1,2,1,1,int
6759,412144,connSocketListen,1,connSocketListen,int connSocketListen (connListener*),socket.c,"static int connSocketListen(connListener *listener) {
    return listenToPort(listener);
}",348.0,350.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,int
6760,412152,connSocketBlockingConnect,1,connSocketBlockingConnect,"int connSocketBlockingConnect (connection*,char*,int,long long)",socket.c,"static int connSocketBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {
    int fd = anetTcpNonBlockConnect(NULL,addr,port);
    if (fd == -1) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = errno;
        return C_ERR;
    }

    if ((aeWait(fd, AE_WRITABLE, timeout) & AE_WRITABLE) == 0) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = ETIMEDOUT;
    }

    conn->fd = fd;
    conn->state = CONN_STATE_CONNECTED;
    return C_OK;
}",352.0,368.0,1.0,15.0,17.0,18,5,19,10,0,8,3,3,1,2,,0,8,8,4,4,int
6761,412226,connSocketSyncWrite,1,connSocketSyncWrite,"ssize_t connSocketSyncWrite (connection*,char*,ssize_t,long long)",socket.c,"static ssize_t connSocketSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncWrite(conn->fd, ptr, size, timeout);
}",374.0,376.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
6762,412242,connSocketSyncRead,1,connSocketSyncRead,"ssize_t connSocketSyncRead (connection*,char*,ssize_t,long long)",socket.c,"static ssize_t connSocketSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncRead(conn->fd, ptr, size, timeout);
}",378.0,380.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
6763,412258,connSocketSyncReadLine,1,connSocketSyncReadLine,"ssize_t connSocketSyncReadLine (connection*,char*,ssize_t,long long)",socket.c,"static ssize_t connSocketSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncReadLine(conn->fd, ptr, size, timeout);
}",382.0,384.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
6764,412274,connSocketGetType,1,connSocketGetType,const char* connSocketGetType (connection*),socket.c,"static const char *connSocketGetType(connection *conn) {
    (void) conn;

    return CONN_TYPE_SOCKET;
}",386.0,390.0,1.0,11.0,5.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,const char*
6765,412573,zslGetElementByRank,1,zslGetElementByRank,"zskiplistNode* zslGetElementByRank (zskiplist*,long unsigned)",t_zset.c,"zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
    zskiplistNode *x;
    unsigned long traversed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward && (traversed + x->level[i].span) <= rank)
        {
            traversed += x->level[i].span;
            x = x->level[i].forward;
        }
        if (traversed == rank) {
            return x;
        }
    }
    return NULL;
}",502.0,519.0,1.0,1.0,18.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,zskiplistNode
6766,412579,createSortOperation,1,createSortOperation,"redisSortOperation createSortOperation (int,robj*)",sort.c,"redisSortOperation *createSortOperation(int type, robj *pattern) {
    redisSortOperation *so = zmalloc(sizeof(*so));
    so->type = type;
    so->pattern = pattern;
    return so;
}",38.0,43.0,1.0,1.0,6.0,7,4,7,3,0,1,1,1,0,1,,0,1,4,2,2,redisSortOperation
6767,412604,lookupKeyByPattern,1,lookupKeyByPattern,"robj lookupKeyByPattern (redisDb*,robj*,robj*)",sort.c,"robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
    char *p, *f, *k;
    sds spat, ssub;
    robj *keyobj, *fieldobj = NULL, *o;
    int prefixlen, sublen, postfixlen, fieldlen;

    /* If the pattern is ""#"" return the substitution object itself in order
     * to implement the ""SORT ... GET #"" feature. */
    spat = pattern->ptr;
    if (spat[0] == '#' && spat[1] == '\0') {
        incrRefCount(subst);
        return subst;
    }

    /* The substitution object may be specially encoded. If so we create
     * a decoded object on the fly. Otherwise getDecodedObject will just
     * increment the ref count, that we'll decrement later. */
    subst = getDecodedObject(subst);
    ssub = subst->ptr;

    /* If we can't find '*' in the pattern we return NULL as to GET a
     * fixed key does not make sense. */
    p = strchr(spat,'*');
    if (!p) {
        decrRefCount(subst);
        return NULL;
    }

    /* Find out if we're dealing with a hash dereference. */
  ...",61.0,133.0,1.0,23.0,73.0,50,11,76,16,1,15,11,10,0,15,,0,8,6,3,3,robj
6768,412834,sortCompare,1,sortCompare,"int sortCompare (void*,void*)",sort.c,"int sortCompare(const void *s1, const void *s2) {
    const redisSortObject *so1 = s1, *so2 = s2;
    int cmp;

    if (!server.sort_alpha) {
        /* Numeric sorting. Here it's trivial as we precomputed scores */
        if (so1->u.score > so2->u.score) {
            cmp = 1;
        } else if (so1->u.score < so2->u.score) {
            cmp = -1;
        } else {
            /* Objects have the same score, but we don't want the comparison
             * to be undefined, so we compare objects lexicographically.
             * This way the result of SORT is deterministic. */
            cmp = compareStringObjects(so1->obj,so2->obj);
        }
    } else {
        /* Alphanumeric sorting */
        if (server.sort_bypattern) {
            if (!so1->u.cmpobj || !so2->u.cmpobj) {
                /* At least one compare object is NULL */
                if (so1->u.cmpobj == so2->u.cmpobj)
                    cmp = 0;
                else if (so1->u.cmpobj == NULL)
                    c...",138.0,185.0,1.0,1.0,48.0,13,7,11,6,0,0,3,4,0,0,,0,0,4,2,2,int
6769,413033,sortCommandGeneric,1,sortCommandGeneric,"void sortCommandGeneric (client*,int)",sort.c,"void sortCommandGeneric(client *c, int readonly) {
    list *operations;
    unsigned int outputlen = 0;
    int desc = 0, alpha = 0;
    long limit_start = 0, limit_count = -1, start, end;
    int j, dontsort = 0, vectorlen;
    int getop = 0; /* GET operation counter */
    int int_conversion_error = 0;
    int syntax_error = 0;
    robj *sortval, *sortby = NULL, *storekey = NULL;
    redisSortObject *vector; /* Resulting vector to sort */
    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */
    /* Create a list of operations to perform for every sorted element.
     * Operations can be GET */
    operations = listCreate();
    listSetFreeMethod(operations,zfree);
    j = 2; /* options start at argv[2] */

    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);

    /* The SORT command has an SQL-alike syntax, parse it */
    while(j < c->argc) {
        int ...",189.0,610.0,1.0,4.0,422.0,208,26,203,29,0,38,31,46,4,27,,0,23,4,2,2,void
6770,414862,createSparklineSequence,1,createSparklineSequence,struct sequence createSparklineSequence (void),sparkline.c,"struct sequence *createSparklineSequence(void) {
    struct sequence *seq = zmalloc(sizeof(*seq));
    seq->length = 0;
    seq->labels = 0;
    seq->samples = NULL;
    seq->min = 0.0f;
    seq->max = 0.0f;
    return seq;
}",57.0,65.0,1.0,1.0,9.0,13,4,9,2,1,6,1,1,0,1,,0,6,2,1,1,struct sequence
6771,414901,sparklineSequenceAddSample,1,sparklineSequenceAddSample,"void sparklineSequenceAddSample (sequence*,double,char*)",sparkline.c,"void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {
    label = (label == NULL || label[0] == '\0') ? NULL : zstrdup(label);
    if (seq->length == 0) {
        seq->min = seq->max = value;
    } else {
        if (value < seq->min) seq->min = value;
        else if (value > seq->max) seq->max = value;
    }
    seq->samples = zrealloc(seq->samples,sizeof(struct sample)*(seq->length+1));
    seq->samples[seq->length].value = value;
    seq->samples[seq->length].label = label;
    seq->length++;
    if (label) seq->labels++;
}",68.0,81.0,1.0,1.0,14.0,33,11,23,5,1,14,3,3,1,2,,0,14,6,3,3,void
6772,415016,freeSparklineSequence,1,freeSparklineSequence,void freeSparklineSequence (sequence*),sparkline.c,"void freeSparklineSequence(struct sequence *seq) {
    int j;

    for (j = 0; j < seq->length; j++)
        zfree(seq->samples[j].label);
    zfree(seq->samples);
    zfree(seq);
}",84.0,91.0,1.0,1.0,8.0,4,3,5,2,1,4,2,2,1,2,,0,2,2,1,1,void
6773,415048,sparklineRenderRange,1,sparklineRenderRange,"sds sparklineRenderRange (sds,sequence*,int,int,int,int)",sparkline.c,"sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {
    int j;
    double relmax = seq->max - seq->min;
    int steps = charset_len*rows;
    int row = 0;
    char *chars = zmalloc(len);
    int loop = 1;
    int opt_fill = flags & SPARKLINE_FILL;
    int opt_log = flags & SPARKLINE_LOG_SCALE;

    if (opt_log) {
        relmax = log(relmax+1);
    } else if (relmax == 0) {
        relmax = 1;
    }

    while(loop) {
        loop = 0;
        memset(chars,' ',len);
        for (j = 0; j < len; j++) {
            struct sample *s = &seq->samples[j+offset];
            double relval = s->value - seq->min;
            int step;

            if (opt_log) relval = log(relval+1);
            step = (int) (relval*steps)/relmax;
            if (step < 0) step = 0;
            if (step >= steps) step = steps-1;

            if (row < rows) {
                /* Print the character needed to create the sparkline */
                int charidx...",100.0,165.0,1.0,27.0,66.0,56,15,72,21,1,14,10,23,1,4,,0,13,12,6,6,sds
6774,415332,sparklineRender,1,sparklineRender,"sds sparklineRender (sds,sequence*,int,int,int)",sparkline.c,"sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {
    int j;

    for (j = 0; j < seq->length; j += columns) {
        int sublen = (seq->length-j) < columns ? (seq->length-j) : columns;

        if (j != 0) output = sdscatlen(output,""\n"",1);
        output = sparklineRenderRange(output, seq, rows, j, sublen, flags);
    }
    return output;
}",168.0,178.0,1.0,1.0,11.0,13,6,21,7,1,5,3,4,1,2,,0,5,10,5,5,sds
6775,415521,streamNew,1,streamNew,stream* streamNew (void),t_stream.c,"stream *streamNew(void) {
    stream *s = zmalloc(sizeof(*s));
    s->rax = raxNew();
    s->length = 0;
    s->first_id.ms = 0;
    s->first_id.seq = 0;
    s->last_id.ms = 0;
    s->last_id.seq = 0;
    s->max_deleted_entry_id.seq = 0;
    s->max_deleted_entry_id.ms = 0;
    s->entries_added = 0;
    s->cgroups = NULL; /* Created on demand to save memory when not used. */
    return s;
}",67.0,80.0,1.0,1.0,14.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,stream
6776,415526,freeStream,1,freeStream,void freeStream (stream*),t_stream.c,"void freeStream(stream *s) {
    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);
    if (s->cgroups)
        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);
    zfree(s);
}",83.0,88.0,1.0,1.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6777,415531,streamLength,1,streamLength,long unsigned streamLength (robj*),t_stream.c,"unsigned long streamLength(const robj *subject) {
    stream *s = subject->ptr;
    return s->length;
}",91.0,94.0,1.0,1.0,4.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,unsigned long
6778,415536,streamReplyWithRange,1,streamReplyWithRange,"size_t streamReplyWithRange (client*,stream*,streamID*,streamID*,size_t,int,streamCG*,streamConsumer*,int,streamPropInfo*)",t_stream.c,"size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {
    void *arraylen_ptr = NULL;
    size_t arraylen = 0;
    streamIterator si;
    int64_t numfields;
    streamID id;
    int propagate_last_id = 0;
    int noack = flags & STREAM_RWR_NOACK;

    /* If the client is asking for some history, we serve it using a
     * different function, so that we return entries *solely* from its
     * own PEL. This ensures each consumer will always and only see
     * the history of messages delivered to it and not yet confirmed
     * as delivered. */
    if (group && (flags & STREAM_RWR_HISTORY)) {
        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
                                                   consumer);
    }

    if (!(flags & STREAM_RWR_RAWENTRIES))
        arraylen_ptr = addReplyDeferredLen(c);
    streamIteratorStart(&si,s,start,end,re...",1679.0,1796.0,1.0,24.0,118.0,0,0,0,0,2,0,1,1,0,0,,0,0,20,10,10,size_t
6779,415550,streamIteratorStart,1,streamIteratorStart,"void streamIteratorStart (streamIterator*,stream*,streamID*,streamID*,int)",t_stream.c,"void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {
    /* Initialize the iterator and translates the iteration start/stop
     * elements into a 128 big big-endian number. */
    if (start) {
        streamEncodeID(si->start_key,start);
    } else {
        si->start_key[0] = 0;
        si->start_key[1] = 0;
    }

    if (end) {
        streamEncodeID(si->end_key,end);
    } else {
        si->end_key[0] = UINT64_MAX;
        si->end_key[1] = UINT64_MAX;
    }

    /* Seek the correct node in the radix tree. */
    raxStart(&si->ri,s->rax);
    if (!rev) {
        if (start && (start->ms || start->seq)) {
            raxSeek(&si->ri,""<="",(unsigned char*)si->start_key,
                    sizeof(si->start_key));
            if (raxEOF(&si->ri)) raxSeek(&si->ri,""^"",NULL,0);
        } else {
            raxSeek(&si->ri,""^"",NULL,0);
        }
    } else {
        if (end && (end->ms || end->seq)) {
            raxSeek(&si->ri,""<="",(unsign...",1063.0,1104.0,1.0,1.0,42.0,0,0,0,0,4,0,1,1,0,0,,0,0,10,5,5,void
6780,415559,streamIteratorGetID,1,streamIteratorGetID,"int streamIteratorGetID (streamIterator*,streamID*,int64_t*)",t_stream.c,"int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
    while(1) { /* Will stop when element > stop_key or end of radix tree. */
        /* If the current listpack is set to NULL, this is the start of the
         * iteration or the previous listpack was completely iterated.
         * Go to the next node. */
        if (si->lp == NULL || si->lp_ele == NULL) {
            if (!si->rev && !raxNext(&si->ri)) return 0;
            else if (si->rev && !raxPrev(&si->ri)) return 0;
            serverAssert(si->ri.key_len == sizeof(streamID));
            /* Get the master ID. */
            streamDecodeID(si->ri.key,&si->master_id);
            /* Get the master fields count. */
            si->lp = si->ri.data;
            si->lp_ele = lpFirst(si->lp);           /* Seek items count */
            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */
            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */
            si->master_fi...",1109.0,1247.0,1.0,12.0,139.0,0,0,0,0,4,0,1,1,0,0,,0,0,6,3,3,int
6781,415566,streamIteratorGetField,1,streamIteratorGetField,"void streamIteratorGetField (streamIterator*,unsigned char**,unsigned char**,int64_t*,int64_t*)",t_stream.c,"void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {
    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);
        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);
    } else {
        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);
        si->lp_ele = lpNext(si->lp,si->lp_ele);
    }
    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);
    si->lp_ele = lpNext(si->lp,si->lp_ele);
}",1255.0,1265.0,1.0,26.0,11.0,0,0,0,0,2,0,1,1,0,0,,0,0,10,5,5,void
6782,415575,streamIteratorRemoveEntry,1,streamIteratorRemoveEntry,"void streamIteratorRemoveEntry (streamIterator*,streamID*)",t_stream.c,"void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
    unsigned char *lp = si->lp;
    int64_t aux;

    /* We do not really delete the entry here. Instead we mark it as
     * deleted by flagging it, and also incrementing the count of the
     * deleted entries in the listpack header.
     *
     * We start flagging: */
    int64_t flags = lpGetInteger(si->lp_flags);
    flags |= STREAM_ITEM_FLAG_DELETED;
    lp = lpReplaceInteger(lp,&si->lp_flags,flags);

    /* Change the valid/deleted entries count in the master entry. */
    unsigned char *p = lpFirst(lp);
    aux = lpGetInteger(p);

    if (aux == 1) {
        /* If this is the last element in the listpack, we can remove the whole
         * node. */
        lpFree(lp);
        raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);
    } else {
        /* In the base case we alter the counters of valid/deleted entries. */
        lp = lpReplaceInteger(lp,&p,aux-1);
        p = lpNext(lp,p); /* Seek del...",1277.0,1328.0,1.0,20.0,52.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6783,415581,streamIteratorStop,1,streamIteratorStop,void streamIteratorStop (streamIterator*),t_stream.c,"void streamIteratorStop(streamIterator *si) {
    raxStop(&si->ri);
}",1333.0,1335.0,1.0,1.0,3.0,0,0,0,0,11,0,1,1,0,0,,0,0,2,1,1,void
6784,415586,streamLookupCG,1,streamLookupCG,"streamCG* streamLookupCG (stream*,sds)",t_stream.c,"streamCG *streamLookupCG(stream *s, sds groupname) {
    if (s->cgroups == NULL) return NULL;
    streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,
                           sdslen(groupname));
    return (cg == raxNotFound) ? NULL : cg;
}",2505.0,2510.0,1.0,1.0,6.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,streamCG
6785,415592,streamLookupConsumer,1,streamLookupConsumer,"streamConsumer* streamLookupConsumer (streamCG*,sds)",t_stream.c,"streamConsumer *streamLookupConsumer(streamCG *cg, sds name) {
    if (cg == NULL) return NULL;
    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,
                                       sdslen(name));
    if (consumer == raxNotFound) return NULL;
    return consumer;
}",2537.0,2543.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,streamConsumer
6786,415598,streamCreateConsumer,1,streamCreateConsumer,"streamConsumer* streamCreateConsumer (streamCG*,sds,robj*,int,int)",t_stream.c,"streamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags) {
    if (cg == NULL) return NULL;
    int notify = !(flags & SCC_NO_NOTIFY);
    int dirty = !(flags & SCC_NO_DIRTIFY);
    streamConsumer *consumer = zmalloc(sizeof(*consumer));
    int success = raxTryInsert(cg->consumers,(unsigned char*)name,
                               sdslen(name),consumer,NULL);
    if (!success) {
        zfree(consumer);
        return NULL;
    }
    consumer->name = sdsdup(name);
    consumer->pel = raxNew();
    consumer->active_time = -1;
    consumer->seen_time = commandTimeSnapshot();
    if (dirty) server.dirty++;
    if (notify) notifyKeyspaceEvent(NOTIFY_STREAM,""xgroup-createconsumer"",key,dbid);
    return consumer;
}",2516.0,2534.0,1.0,27.0,19.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,streamConsumer
6787,415607,streamCreateCG,1,streamCreateCG,"streamCG* streamCreateCG (stream*,char*,size_t,streamID*,long long)",t_stream.c,"streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {
    if (s->cgroups == NULL) s->cgroups = raxNew();
    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)
        return NULL;

    streamCG *cg = zmalloc(sizeof(*cg));
    cg->pel = raxNew();
    cg->consumers = raxNew();
    cg->last_id = *id;
    cg->entries_read = entries_read;
    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);
    return cg;
}",2482.0,2494.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,streamCG
6788,415616,streamCreateNACK,1,streamCreateNACK,streamNACK* streamCreateNACK (streamConsumer*),t_stream.c,"streamNACK *streamCreateNACK(streamConsumer *consumer) {
    streamNACK *nack = zmalloc(sizeof(*nack));
    nack->delivery_time = commandTimeSnapshot();
    nack->delivery_count = 1;
    nack->consumer = consumer;
    return nack;
}",2453.0,2459.0,1.0,1.0,7.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,streamNACK
6789,415621,streamDecodeID,1,streamDecodeID,"void streamDecodeID (void*,streamID*)",t_stream.c,"void streamDecodeID(void *buf, streamID *id) {
    uint64_t e[2];
    memcpy(e,buf,sizeof(e));
    id->ms = ntohu64(e[0]);
    id->seq = ntohu64(e[1]);
}",373.0,378.0,1.0,13.0,6.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,void
6790,415627,streamCompareID,1,streamCompareID,"int streamCompareID (streamID*,streamID*)",t_stream.c,"int streamCompareID(streamID *a, streamID *b) {
    if (a->ms > b->ms) return 1;
    else if (a->ms < b->ms) return -1;
    /* The ms part is the same. Check the sequence part. */
    else if (a->seq > b->seq) return 1;
    else if (a->seq < b->seq) return -1;
    /* Everything is the same: IDs are equal. */
    return 0;
}",381.0,389.0,1.0,1.0,9.0,0,0,0,0,4,0,1,1,0,0,,0,0,4,2,2,int
6791,415633,streamFreeNACK,1,streamFreeNACK,void streamFreeNACK (streamNACK*),t_stream.c,"void streamFreeNACK(streamNACK *na) {
    zfree(na);
}",2462.0,2464.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,void
6792,415638,streamIncrID,1,streamIncrID,int streamIncrID (streamID*),t_stream.c,"int streamIncrID(streamID *id) {
    int ret = C_OK;
    if (id->seq == UINT64_MAX) {
        if (id->ms == UINT64_MAX) {
            /* Special case where 'id' is the last possible streamID... */
            id->ms = id->seq = 0;
            ret = C_ERR;
        } else {
            id->ms++;
            id->seq = 0;
        }
    } else {
        id->seq++;
    }
    return ret;
}",99.0,114.0,1.0,14.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
6793,415643,streamDecrID,1,streamDecrID,int streamDecrID (streamID*),t_stream.c,"int streamDecrID(streamID *id) {
    int ret = C_OK;
    if (id->seq == 0) {
        if (id->ms == 0) {
            /* Special case where 'id' is the first possible streamID... */
            id->ms = id->seq = UINT64_MAX;
            ret = C_ERR;
        } else {
            id->ms--;
            id->seq = UINT64_MAX;
        }
    } else {
        id->seq--;
    }
    return ret;
}",119.0,134.0,1.0,14.0,16.0,0,0,0,0,2,0,1,1,0,0,,0,0,2,1,1,int
6794,415648,streamPropagateConsumerCreation,1,streamPropagateConsumerCreation,"void streamPropagateConsumerCreation (client*,robj*,robj*,sds)",t_stream.c,"void streamPropagateConsumerCreation(client *c, robj *key, robj *groupname, sds consumername) {
    robj *argv[5];
    argv[0] = shared.xgroup;
    argv[1] = shared.createconsumer;
    argv[2] = key;
    argv[3] = groupname;
    argv[4] = createObject(OBJ_STRING,sdsdup(consumername));

    alsoPropagate(c->db->id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);

    decrRefCount(argv[4]);
}",1614.0,1625.0,1.0,27.0,12.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6795,415656,streamDup,1,streamDup,robj* streamDup (robj*),t_stream.c,"robj *streamDup(robj *o) {
    robj *sobj;

    serverAssert(o->type == OBJ_STREAM);

    switch (o->encoding) {
        case OBJ_ENCODING_STREAM:
            sobj = createStreamObject();
            break;
        default:
            serverPanic(""Wrong encoding."");
            break;
    }

    stream *s;
    stream *new_s;
    s = o->ptr;
    new_s = sobj->ptr;

    raxIterator ri;
    uint64_t rax_key[2];
    raxStart(&ri, s->rax);
    raxSeek(&ri, ""^"", NULL, 0);
    size_t lp_bytes = 0;      /* Total bytes in the listpack. */
    unsigned char *lp = NULL; /* listpack pointer. */
    /* Get a reference to the listpack node. */
    while (raxNext(&ri)) {
        lp = ri.data;
        lp_bytes = lpBytes(lp);
        unsigned char *new_lp = zmalloc(lp_bytes);
        memcpy(new_lp, lp, lp_bytes);
        memcpy(rax_key, ri.key, sizeof(rax_key));
        raxInsert(new_s->rax, (unsigned char *)&rax_key, sizeof(rax_key),
                  new_lp, NULL);
    }
    new_s->length = s->le...",156.0,258.0,1.0,4.0,103.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,robj
6796,415661,streamValidateListpackIntegrity,1,streamValidateListpackIntegrity,"int streamValidateListpackIntegrity (unsigned char*,size_t,int)",t_stream.c,"int streamValidateListpackIntegrity(unsigned char *lp, size_t size, int deep) {
    int valid_record;
    unsigned char *p, *next;

    /* Since we don't want to run validation of all records twice, we'll
     * run the listpack validation of just the header and do the rest here. */
    if (!lpValidateIntegrity(lp, size, 0, NULL, NULL))
        return 0;

    /* In non-deep mode we just validated the listpack header (encoded size) */
    if (!deep) return 1;

    next = p = lpValidateFirst(lp);
    if (!lpValidateNext(lp, &next, size)) return 0;
    if (!p) return 0;

    /* entry count */
    int64_t entry_count = lpGetIntegerIfValid(p, &valid_record);
    if (!valid_record) return 0;
    p = next; if (!lpValidateNext(lp, &next, size)) return 0;

    /* deleted */
    int64_t deleted_count = lpGetIntegerIfValid(p, &valid_record);
    if (!valid_record) return 0;
    p = next; if (!lpValidateNext(lp, &next, size)) return 0;

    /* num-of-fields */
    int64_t master_fields = lpGetI...",3951.0,4038.0,1.0,22.0,88.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
6797,415668,streamParseID,1,streamParseID,"int streamParseID (robj*,streamID*)",t_stream.c,"int streamParseID(const robj *o, streamID *id) {
    return streamGenericParseIDOrReply(NULL,o,id,0,0,NULL);
}",1936.0,1938.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
6798,415674,createObjectFromStreamID,1,createObjectFromStreamID,robj* createObjectFromStreamID (streamID*),t_stream.c,"robj *createObjectFromStreamID(streamID *id) {
    return createObject(OBJ_STRING, createStreamIDString(id));
}",1405.0,1407.0,1.0,24.0,3.0,0,0,0,0,3,0,1,1,0,0,,0,0,2,1,1,robj
6799,415679,streamAppendItem,1,streamAppendItem,"int streamAppendItem (stream*,robj**,int64_t,streamID*,streamID*,int)",t_stream.c,"int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given) {

    /* Generate the new entry ID. */
    streamID id;
    if (use_id) {
        if (seq_given) {
            id = *use_id;
        } else {
            /* The automatically generated sequence can be either zero (new
             * timestamps) or the incremented sequence of the last ID. In the
             * latter case, we need to prevent an overflow/advancing forward
             * in time. */
            if (s->last_id.ms == use_id->ms) {
                if (s->last_id.seq == UINT64_MAX) {
                    errno = EDOM;
                    return C_ERR;
                }
                id = s->last_id;
                id.seq++;
            } else {
                id = *use_id;
            }
        }
    } else {
        streamNextID(&s->last_id,&id);
    }

    /* Check that the new ID is greater than the last entry ID
     * or return an error. Automatical...",427.0,670.0,1.0,27.0,244.0,0,0,0,0,1,0,1,1,0,0,,0,0,12,6,6,int
6800,415689,streamDeleteItem,1,streamDeleteItem,"int streamDeleteItem (stream*,streamID*)",t_stream.c,"int streamDeleteItem(stream *s, streamID *id) {
    int deleted = 0;
    streamIterator si;
    streamIteratorStart(&si,s,id,id,0);
    streamID myid;
    int64_t numfields;
    if (streamIteratorGetID(&si,&myid,&numfields)) {
        streamIteratorRemoveEntry(&si,&myid);
        deleted = 1;
    }
    streamIteratorStop(&si);
    return deleted;
}",1353.0,1365.0,1.0,1.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
6801,415695,streamGetEdgeID,1,streamGetEdgeID,"void streamGetEdgeID (stream*,int,int,streamID*)",t_stream.c,"void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)
{
    streamIterator si;
    int64_t numfields;
    streamIteratorStart(&si,s,NULL,NULL,!first);
    si.skip_tombstones = skip_tombstones;
    int found = streamIteratorGetID(&si,edge_id,&numfields);
    if (!found) {
        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
        *edge_id = first ? max_id : min_id;
    }
    streamIteratorStop(&si);
}",394.0,406.0,1.0,1.0,13.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6802,415703,streamEstimateDistanceFromFirstEverEntry,1,streamEstimateDistanceFromFirstEverEntry,"long long streamEstimateDistanceFromFirstEverEntry (stream*,streamID*)",t_stream.c,"long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id) {
    /* The counter of any ID in an empty, never-before-used stream is 0. */
    if (!s->entries_added) {
        return 0;
    }

    /* In the empty stream, if the ID is smaller or equal to the last ID,
     * it can set to the current added_entries value. */
    if (!s->length && streamCompareID(id,&s->last_id) < 1) {
        return s->entries_added;
    }

    int cmp_last = streamCompareID(id,&s->last_id);
    if (cmp_last == 0) {
        /* Return the exact counter of the last entry in the stream. */
        return s->entries_added;
    } else if (cmp_last > 0) {
        /* The counter of a future ID is unknown. */
        return SCG_INVALID_ENTRIES_READ;
    }

    int cmp_id_first = streamCompareID(id,&s->first_id);
    int cmp_xdel_first = streamCompareID(&s->max_deleted_entry_id,&s->first_id);
    if (streamIDEqZero(&s->max_deleted_entry_id) || cmp_xdel_first < 0) {
        /* There's definitely n...",1512.0,1549.0,1.0,15.0,38.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,long long
6803,415709,streamTrimByLength,1,streamTrimByLength,"int64_t streamTrimByLength (stream*,long long,int)",t_stream.c,"int64_t streamTrimByLength(stream *s, long long maxlen, int approx) {
    streamAddTrimArgs args = {
        .trim_strategy = TRIM_STRATEGY_MAXLEN,
        .approx_trim = approx,
        .limit = approx ? 100 * server.stream_node_max_entries : 0,
        .maxlen = maxlen
    };
    return streamTrim(s, &args);
}",881.0,889.0,1.0,25.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int64_t
6804,415716,streamTrimByID,1,streamTrimByID,"int64_t streamTrimByID (stream*,streamID,int)",t_stream.c,"int64_t streamTrimByID(stream *s, streamID minid, int approx) {
    streamAddTrimArgs args = {
        .trim_strategy = TRIM_STRATEGY_MINID,
        .approx_trim = approx,
        .limit = approx ? 100 * server.stream_node_max_entries : 0,
        .minid = minid
    };
    return streamTrim(s, &args);
}",892.0,900.0,1.0,25.0,9.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,int64_t
6805,415792,redis_strlcat,1,redis_strlcat,"size_t redis_strlcat (char*,char*,size_t)",strl.c,"size_t
redis_strlcat(char *dst, const char *src, size_t dsize)
{
    const char *odst = dst;
    const char *osrc = src;
    size_t n = dsize;
    size_t dlen;

    /* Find the end of dst and adjust bytes left but don't go past end. */
    while (n-- != 0 && *dst != '\0')
        dst++;
    dlen = dst - odst;
    n = dsize - dlen;

    if (n-- == 0)
        return(dlen + strlen(src));
    while (*src != '\0') {
        if (n != 0) {
            *dst++ = *src;
            n--;
        }
        src++;
    }
    *dst = '\0';

    return(dlen + (src - osrc));    /* count does not include NUL */
}",55.0,81.0,1.0,1.0,27.0,28,9,27,7,2,0,5,6,0,0,,0,0,6,3,3,size_t
6806,416212,check_fn,1,check.check_fn,int check.check_fn (sds*),syscheck.c,int (*check_fn)(sds*);,337.0,337.0,9.0,25.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
6807,416231,syscheck,1,syscheck,int syscheck (void),syscheck.c,"int syscheck(void) {
    check *cur_check = checks;
    int ret = 1;
    sds err_msg = NULL;
    while (cur_check->check_fn) {
        int res = cur_check->check_fn(&err_msg);
        printf(""[%s]..."", cur_check->name);
        if (res == 0) {
            printf(""skipped\n"");
        } else if (res == 1) {
            printf(""OK\n"");
        } else {
            printf(""WARNING:\n"");
            printf(""%s\n"", err_msg);
            sdsfree(err_msg);
            ret = 0;
        }
        cur_check++;
    }

    return ret;
}",354.0,375.0,1.0,1.0,22.0,10,5,13,6,0,2,3,4,0,0,,0,2,2,1,1,int
6808,416446,hashTypeGetFromListpack,1,hashTypeGetFromListpack,"int hashTypeGetFromListpack (robj*,sds,unsigned char**,unsigned int*,long long*)",t_hash.c,"int hashTypeGetFromListpack(robj *o, sds field,
                            unsigned char **vstr,
                            unsigned int *vlen,
                            long long *vll)
{
    unsigned char *zl, *fptr = NULL, *vptr = NULL;

    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    zl = o->ptr;
    fptr = lpFirst(zl);
    if (fptr != NULL) {
        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
        if (fptr != NULL) {
            /* Grab pointer to the value (fptr points to the field) */
            vptr = lpNext(zl, fptr);
            serverAssert(vptr != NULL);
        }
    }

    if (vptr != NULL) {
        *vstr = lpGetValue(vptr, vlen, vll);
        return 0;
    }

    return -1;
}",72.0,98.0,1.0,4.0,27.0,25,10,29,9,1,7,4,5,0,7,,0,5,10,5,5,int
6809,416550,hashTypeGetFromHashTable,1,hashTypeGetFromHashTable,"sds hashTypeGetFromHashTable (robj*,sds)",t_hash.c,"sds hashTypeGetFromHashTable(robj *o, sds field) {
    dictEntry *de;

    serverAssert(o->encoding == OBJ_ENCODING_HT);

    de = dictFind(o->ptr, field);
    if (de == NULL) return NULL;
    return dictGetVal(de);
}",103.0,111.0,1.0,4.0,9.0,9,7,8,4,0,3,2,2,0,3,,0,1,4,2,2,sds
6810,416592,hashTypeGetValue,1,hashTypeGetValue,"int hashTypeGetValue (robj*,sds,unsigned char**,unsigned int*,long long*)",t_hash.c,"int hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        *vstr = NULL;
        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)
            return C_OK;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        sds value;
        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {
            *vstr = (unsigned char*) value;
            *vlen = sdslen(value);
            return C_OK;
        }
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return C_ERR;
}",122.0,138.0,1.0,23.0,17.0,6,5,8,6,2,1,3,4,1,1,,0,1,10,5,5,int
6811,416720,hashTypeGetValueLength,1,hashTypeGetValueLength,"size_t hashTypeGetValueLength (robj*,sds)",t_hash.c,"size_t hashTypeGetValueLength(robj *o, sds field) {
    size_t len = 0;
    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)
        len = vstr ? vlen : sdigits10(vll);

    return len;
}",157.0,167.0,1.0,58.0,11.0,10,4,17,9,0,2,2,2,1,2,,0,2,4,2,2,size_t
6812,417756,hashTypeConvertListpack,1,hashTypeConvertListpack,"void hashTypeConvertListpack (robj*,int)",t_hash.c,"void hashTypeConvertListpack(robj *o, int enc) {
    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    if (enc == OBJ_ENCODING_LISTPACK) {
        /* Nothing to do... */

    } else if (enc == OBJ_ENCODING_HT) {
        hashTypeIterator *hi;
        dict *dict;
        int ret;

        hi = hashTypeInitIterator(o);
        dict = dictCreate(&hashDictType);

        /* Presize the dict to avoid rehashing */
        dictExpand(dict,hashTypeLength(o));

        while (hashTypeNext(hi) != C_ERR) {
            sds key, value;

            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
            ret = dictAdd(dict, key, value);
            if (ret != DICT_OK) {
                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */
                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */
                serverLogHexDump(LL_WARNING,""listpack with dup elements dump"",
                    o->ptr,...",455.0,493.0,1.0,4.0,39.0,7,6,2,2,0,1,2,2,0,1,,0,0,4,2,2,void
6813,418130,hashSdsFromListpackEntry,1,hashSdsFromListpackEntry,sds hashSdsFromListpackEntry (listpackEntry*),t_hash.c,"sds hashSdsFromListpackEntry(listpackEntry *e) {
    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);
}",551.0,553.0,1.0,1.0,3.0,5,2,4,1,0,6,1,1,0,2,,0,4,2,1,1,sds
6814,418151,hashReplyFromListpackEntry,1,hashReplyFromListpackEntry,"void hashReplyFromListpackEntry (client*,listpackEntry*)",t_hash.c,"void hashReplyFromListpackEntry(client *c, listpackEntry *e) {
    if (e->sval)
        addReplyBulkCBuffer(c, e->sval, e->slen);
    else
        addReplyBulkLongLong(c, e->lval);
}",556.0,561.0,1.0,1.0,6.0,3,1,4,2,0,4,2,2,1,1,,0,3,4,2,2,void
6815,418177,hashTypeRandomElement,1,hashTypeRandomElement,"void hashTypeRandomElement (robj*,long unsigned,listpackEntry*,listpackEntry*)",t_hash.c,"void hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {
    if (hashobj->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);
        sds s = dictGetKey(de);
        key->sval = (unsigned char*)s;
        key->slen = sdslen(s);
        if (val) {
            sds s = dictGetVal(de);
            val->sval = (unsigned char*)s;
            val->slen = sdslen(s);
        }
    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {
        lpRandomPair(hashobj->ptr, hashsize, key, val);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",567.0,583.0,1.0,29.0,17.0,16,4,16,5,0,9,3,4,0,5,,0,9,8,4,4,void
6816,418905,addHashFieldToReply,1,addHashFieldToReply,"void addHashFieldToReply (client*,robj*,sds)",t_hash.c,"static void addHashFieldToReply(client *c, robj *o, sds field) {
    if (o == NULL) {
        addReplyNull(c);
        return;
    }

    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {
        if (vstr) {
            addReplyBulkCBuffer(c, vstr, vlen);
        } else {
            addReplyBulkLongLong(c, vll);
        }
    } else {
        addReplyNull(c);
    }
}",722.0,741.0,1.0,58.0,20.0,8,3,18,9,0,3,4,5,1,3,,0,1,6,3,3,void
6817,419281,addHashIteratorCursorToReply,1,addHashIteratorCursorToReply,"void addHashIteratorCursorToReply (client*,hashTypeIterator*,int)",t_hash.c,"static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);
        if (vstr)
            addReplyBulkCBuffer(c, vstr, vlen);
        else
            addReplyBulkLongLong(c, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds value = hashTypeCurrentFromHashTable(hi, what);
        addReplyBulkCBuffer(c, value, sdslen(value));
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",812.0,829.0,1.0,24.0,18.0,8,4,16,9,4,3,3,4,1,2,,0,1,6,3,3,void
6818,419362,genericHgetallCommand,1,genericHgetallCommand,"void genericHgetallCommand (client*,int)",t_hash.c,"void genericHgetallCommand(client *c, int flags) {
    robj *o;
    hashTypeIterator *hi;
    int length, count = 0;

    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?
        shared.emptymap[c->resp] : shared.emptyarray;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))
        == NULL || checkType(c,o,OBJ_HASH)) return;

    /* We return a map if the user requested keys and values, like in the
     * HGETALL case. Otherwise to use a flat array makes more sense. */
    length = hashTypeLength(o);
    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {
        addReplyMapLen(c, length);
    } else {
        addReplyArrayLen(c, length);
    }

    hi = hashTypeInitIterator(o);
    while (hashTypeNext(hi) != C_ERR) {
        if (flags & OBJ_HASH_KEY) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);
            count++;
        }
        if (flags & OBJ_HASH_VALUE) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);
     ...",831.0,867.0,1.0,31.0,37.0,35,16,37,9,0,12,7,9,4,10,,0,7,4,2,2,void
6819,419658,hrandfieldReplyWithListpack,1,hrandfieldReplyWithListpack,"void hrandfieldReplyWithListpack (client*,unsigned int,listpackEntry*,listpackEntry*)",t_hash.c,"static void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    for (unsigned long i = 0; i < count; i++) {
        if (vals && c->resp > 2)
            addReplyArrayLen(c,2);
        if (keys[i].sval)
            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);
        else
            addReplyBulkLongLong(c, keys[i].lval);
        if (vals) {
            if (vals[i].sval)
                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);
            else
                addReplyBulkLongLong(c, vals[i].lval);
        }
    }
}",899.0,914.0,1.0,1.0,16.0,17,7,21,5,1,4,6,11,1,3,,0,1,8,4,4,void
6820,419749,hrandfieldWithCountCommand,1,hrandfieldWithCountCommand,"void hrandfieldWithCountCommand (client*,long,int)",t_hash.c,"void hrandfieldWithCountCommand(client *c, long l, int withvalues) {
    unsigned long count, size;
    int uniq = 1;
    robj *hash;

    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))
        == NULL || checkType(c,hash,OBJ_HASH)) return;
    size = hashTypeLength(hash);

    if(l >= 0) {
        count = (unsigned long) l;
    } else {
        count = -l;
        uniq = 0;
    }

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. This case is the only one that also needs to return the
     * elements in random order. */
    if (!uniq || count == 1) {
        if (withvalues && c->resp == 2)
            addReplyArrayLen(c, count*2);
  ...",926.0,1130.0,1.0,36.0,205.0,100,24,141,21,0,63,26,53,12,54,,0,35,6,3,3,void
6821,420556,listTypeTryConvertListpack,1,listTypeTryConvertListpack,"void listTypeTryConvertListpack (robj*,robj**,int,int,beforeConvertCB,void*)",t_list.c,"static void listTypeTryConvertListpack(robj *o, robj **argv, int start, int end,
                                       beforeConvertCB fn, void *data)
{
    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    size_t add_bytes = 0;
    size_t add_length = 0;

    if (argv) {
        for (int i = start; i <= end; i++) {
            if (!sdsEncodedObject(argv[i]))
                continue;
            add_bytes += sdslen(argv[i]->ptr);
        }
        add_length = end - start + 1;
    }

    if (quicklistNodeExceedsLimit(server.list_max_listpack_size,
            lpBytes(o->ptr) + add_bytes, lpLength(o->ptr) + add_length))
    {
        /* Invoke callback before conversion. */
        if (fn) fn(data);

        quicklist *ql = quicklistCreate();
        quicklistSetOptions(ql, server.list_max_listpack_size, server.list_compress_depth);

        /* Append listpack to quicklist if it's not empty, otherwise release it. */
        if (lpLength(o->ptr))
            quicklistAppendLi...",42.0,76.0,1.0,4.0,35.0,39,15,37,11,0,9,8,12,4,9,,0,5,12,6,6,void
6822,420710,listTypeTryConvertQuicklist,1,listTypeTryConvertQuicklist,"void listTypeTryConvertQuicklist (robj*,int,beforeConvertCB,void*)",t_list.c,"static void listTypeTryConvertQuicklist(robj *o, int shrinking, beforeConvertCB fn, void *data) {
    serverAssert(o->encoding == OBJ_ENCODING_QUICKLIST);

    size_t sz_limit;
    unsigned int count_limit;
    quicklist *ql = o->ptr;

    /* A quicklist can be converted to listpack only if it has only one packed node. */
    if (ql->len != 1 || ql->head->container != QUICKLIST_NODE_CONTAINER_PACKED)
        return;

    /* Check the length or size of the quicklist is below the limit. */
    quicklistNodeLimit(server.list_max_listpack_size, &sz_limit, &count_limit);
    if (shrinking) {
        sz_limit /= 2;
        count_limit /= 2;
    }
    if (ql->head->sz > sz_limit || ql->count > count_limit) return;

    /* Invoke callback before conversion. */
    if (fn) fn(data);

    /* Extract the listpack from the unique quicklist node,
     * then reset it and release the quicklist. */
    o->ptr = ql->head->entry;
    ql->head->entry = NULL;
    quicklistRelease(ql);
    o->encoding ...",87.0,115.0,1.0,4.0,29.0,34,13,23,9,1,9,5,5,4,3,,0,6,8,4,4,void
6823,420825,listTypeTryConversionRaw,1,listTypeTryConversionRaw,"void listTypeTryConversionRaw (robj*,list_conv_type,robj**,int,int,beforeConvertCB,void*)",t_list.c,"static void listTypeTryConversionRaw(robj *o, list_conv_type lct,
                                     robj **argv, int start, int end,
                                     beforeConvertCB fn, void *data)
{
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        if (lct == LIST_CONV_GROWING) return; /* Growing has nothing to do with quicklist */
        listTypeTryConvertQuicklist(o, lct == LIST_CONV_SHRINKING, fn, data);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        if (lct == LIST_CONV_SHRINKING) return; /* Shrinking has nothing to do with listpack */
        listTypeTryConvertListpack(o, argv, start, end, fn, data);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",132.0,145.0,1.0,23.0,14.0,4,2,8,6,0,1,3,4,0,1,,0,0,14,7,7,void
6824,421090,listPopSaver,1,listPopSaver,"void* listPopSaver (unsigned char*,size_t)",t_list.c,"void *listPopSaver(unsigned char *data, size_t sz) {
    return createStringObject((char*)data,sz);
}",191.0,193.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,void*
6825,421974,listTypeReplaceAtIndex,1,listTypeReplaceAtIndex,"int listTypeReplaceAtIndex (robj*,int,robj*)",t_list.c,"int listTypeReplaceAtIndex(robj *o, int index, robj *value) {
    value = getDecodedObject(value);
    sds vstr = value->ptr;
    size_t vlen = sdslen(vstr);
    int replaced = 0;

    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        replaced = quicklistReplaceAtIndex(ql, index, vstr, vlen);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p = lpSeek(o->ptr,index);
        if (p) {
            o->ptr = lpReplace(o->ptr, &p, (unsigned char *)vstr, vlen);
            replaced = 1;
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }

    decrRefCount(value);
    return replaced;
}",384.0,405.0,1.0,23.0,22.0,10,3,17,7,0,4,2,2,0,4,,0,3,6,3,3,int
6826,422410,pushGenericCommand,1,pushGenericCommand,"void pushGenericCommand (client*,int,int)",t_list.c,"void pushGenericCommand(client *c, int where, int xx) {
    int j;

    robj *lobj = lookupKeyWrite(c->db, c->argv[1]);
    if (checkType(c,lobj,OBJ_LIST)) return;
    if (!lobj) {
        if (xx) {
            addReply(c, shared.czero);
            return;
        }

        lobj = createListListpackObject();
        dbAdd(c->db,c->argv[1],lobj);
    }

    listTypeTryConversionAppend(lobj,c->argv,2,c->argc-1,NULL,NULL);
    for (j = 2; j < c->argc; j++) {
        listTypePush(lobj,c->argv[j],where);
        server.dirty++;
    }

    addReplyLongLong(c, listTypeLength(lobj));

    char *event = (where == LIST_HEAD) ? ""lpush"" : ""rpush"";
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
}",486.0,512.0,1.0,25.0,27.0,31,11,36,9,0,23,5,6,2,11,,0,16,6,3,3,void
6827,423019,listPopRangeAndReplyWithKey,1,listPopRangeAndReplyWithKey,"void listPopRangeAndReplyWithKey (client*,robj*,robj*,int,long,int,int*)",t_list.c,"void listPopRangeAndReplyWithKey(client *c, robj *o, robj *key, int where, long count, int signal, int *deleted) {
    long llen = listTypeLength(o);
    long rangelen = (count > llen) ? llen : count;
    long rangestart = (where == LIST_HEAD) ? 0 : -rangelen;
    long rangeend = (where == LIST_HEAD) ? rangelen - 1 : -1;
    int reverse = (where == LIST_HEAD) ? 0 : 1;

    /* We return key-name just once, and an array of elements */
    addReplyArrayLen(c, 2);
    addReplyBulk(c, key);
    addListRangeReply(c, o, rangestart, rangeend, reverse);

    /* Pop these elements. */
    listTypeDelRange(o, rangestart, rangelen);
    /* Maintain the notifications and dirty. */
    listElementsRemoved(c, key, where, o, rangelen, signal, deleted);
}",659.0,675.0,1.0,32.0,17.0,16,6,33,12,2,6,1,1,0,6,,0,1,14,7,7,void
6828,423105,addListQuicklistRangeReply,1,addListQuicklistRangeReply,"void addListQuicklistRangeReply (client*,robj*,int,int,int)",t_list.c,"void addListQuicklistRangeReply(client *c, robj *o, int from, int rangelen, int reverse) {
    /* Return the result in form of a multi-bulk reply */
    addReplyArrayLen(c,rangelen);

    int direction = reverse ? AL_START_TAIL : AL_START_HEAD;
    quicklistIter *iter = quicklistGetIteratorAtIdx(o->ptr, direction, from);
    while(rangelen--) {
        quicklistEntry qe;
        serverAssert(quicklistNext(iter, &qe)); /* fail on corrupt data */
        if (qe.value) {
            addReplyBulkCBuffer(c,qe.value,qe.sz);
        } else {
            addReplyBulkLongLong(c,qe.longval);
        }
    }
    quicklistReleaseIterator(iter);
}",680.0,696.0,1.0,30.0,17.0,13,9,16,8,0,9,3,4,1,6,,0,4,10,5,5,void
6829,423181,addListListpackRangeReply,1,addListListpackRangeReply,"void addListListpackRangeReply (client*,robj*,int,int,int)",t_list.c,"void addListListpackRangeReply(client *c, robj *o, int from, int rangelen, int reverse) {
    unsigned char *p = lpSeek(o->ptr, from);
    unsigned char *vstr;
    unsigned int vlen;
    long long lval;

    /* Return the result in form of a multi-bulk reply */
    addReplyArrayLen(c,rangelen);

    while(rangelen--) {
        serverAssert(p); /* fail on corrupt data */
        vstr = lpGetValue(p, &vlen, &lval);
        if (vstr) {
            addReplyBulkCBuffer(c,vstr,vlen);
        } else {
            addReplyBulkLongLong(c,lval);
        }
        p = reverse ? lpPrev(o->ptr,p) : lpNext(o->ptr,p);
    }
}",701.0,720.0,1.0,8.0,20.0,14,8,22,9,0,7,3,4,0,7,,0,4,10,5,5,void
6830,423694,mpopGenericCommand,1,mpopGenericCommand,"void mpopGenericCommand (client*,robj**,int,int,long)",t_list.c,"void mpopGenericCommand(client *c, robj **keys, int numkeys, int where, long count) {
    int j;
    robj *o;
    robj *key;

    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db, key);

        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c, o, OBJ_LIST)) return;

        long llen = listTypeLength(o);
        /* Empty list, move to next key. */
        if (llen == 0) continue;

        /* Pop a range of elements in a nested arrays way. */
        listPopRangeAndReplyWithKey(c, o, key, where, count, 1, NULL);

        /* Replicate it as [LR]POP COUNT. */
        robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);
        rewriteClientCommandVector(c, 3,
                                   (where == LIST_HEAD) ? shared.lpop : shared.rpop,
                                   key, count_obj);
        decrRefCount(count_obj);
        return;
    }

    /* Look like we ...",834.0,866.0,1.0,28.0,33.0,16,8,35,12,0,9,7,8,1,8,,0,5,10,5,5,void
6831,424749,lmoveHandlePush,1,lmoveHandlePush,"void lmoveHandlePush (client*,robj*,robj*,robj*,int)",t_list.c,"void lmoveHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value,
                     int where) {
    /* Create the list if the key does not exist */
    if (!dstobj) {
        dstobj = createListListpackObject();
        dbAdd(c->db,dstkey,dstobj);
    }
    signalModifiedKey(c,c->db,dstkey);
    listTypeTryConversionAppend(dstobj,&value,0,0,NULL,NULL);
    listTypePush(dstobj,value,where);
    notifyKeyspaceEvent(NOTIFY_LIST,
                        where == LIST_HEAD ? ""lpush"" : ""rpush"",
                        dstkey,
                        c->db->id);
    /* Always send the pushed value to the client. */
    addReplyBulk(c,value);
}",1103.0,1119.0,1.0,24.0,17.0,10,7,20,6,0,10,2,2,0,7,,0,4,10,5,5,void
6832,424812,getListPositionFromObjectOrReply,1,getListPositionFromObjectOrReply,"int getListPositionFromObjectOrReply (client*,robj*,int*)",t_list.c,"int getListPositionFromObjectOrReply(client *c, robj *arg, int *position) {
    if (strcasecmp(arg->ptr,""right"") == 0) {
        *position = LIST_TAIL;
    } else if (strcasecmp(arg->ptr,""left"") == 0) {
        *position = LIST_HEAD;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return C_ERR;
    }
    return C_OK;
}",1121.0,1131.0,1.0,20.0,11.0,4,4,2,2,1,0,2,2,0,0,,0,0,6,3,3,int
6833,424867,getStringObjectFromListPosition,1,getStringObjectFromListPosition,robj getStringObjectFromListPosition (int),t_list.c,"robj *getStringObjectFromListPosition(int position) {
    if (position == LIST_HEAD) {
        return shared.left;
    } else {
        // LIST_TAIL
        return shared.right;
    }
}",1133.0,1140.0,1.0,20.0,8.0,2,2,2,2,0,0,2,2,0,0,,0,0,2,1,1,robj
6834,424889,lmoveGenericCommand,1,lmoveGenericCommand,"void lmoveGenericCommand (client*,int,int)",t_list.c,"void lmoveGenericCommand(client *c, int wherefrom, int whereto) {
    robj *sobj, *value;
    if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))
        == NULL || checkType(c,sobj,OBJ_LIST)) return;

    if (listTypeLength(sobj) == 0) {
        /* This may only happen after loading very old RDB files. Recent
         * versions of Redis delete keys of empty lists. */
        addReplyNull(c);
    } else {
        robj *dobj = lookupKeyWrite(c->db,c->argv[2]);
        robj *touchedkey = c->argv[1];

        if (checkType(c,dobj,OBJ_LIST)) return;
        value = listTypePop(sobj,wherefrom);
        serverAssert(value); /* assertion for valgrind (avoid NPD) */
        lmoveHandlePush(c,c->argv[2],dobj,value,whereto);
        listElementsRemoved(c,touchedkey,wherefrom,sobj,1,1,NULL);

        /* listTypePop returns an object with its refcount incremented */
        decrRefCount(value);

        if (c->cmd->proc == blmoveCommand) {
            rewriteClientCommandVect...",1142.0,1172.0,1.0,36.0,31.0,9,6,10,4,0,6,3,3,5,4,,0,5,6,3,3,void
6835,425123,blockingPopGenericCommand,1,blockingPopGenericCommand,"void blockingPopGenericCommand (client*,robj**,int,int,int,long)",t_list.c,"void blockingPopGenericCommand(client *c, robj **keys, int numkeys, int where, int timeout_idx, long count) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;

    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;

    /* Traverse all input keys, we take action only based on one key. */
    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db, key);

        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c, o, OBJ_LIST)) return;

        long llen = listTypeLength(o);
        /* Empty list, move to next key. */
        if (llen == 0) continue;

        if (count != -1) {
            /* BLMPOP, non empty list, like a normal [LR]POP with count option.
             * The difference here we pop a range of elements in a nested arrays way. */
            listPopRangeAndReplyWithKey(c, o, key, where, count, 1, NULL);

            /* Replicat...",1212.0,1275.0,1.0,68.0,64.0,35,16,67,16,1,21,10,12,4,18,,0,9,12,6,6,void
6836,425382,blmoveGenericCommand,1,blmoveGenericCommand,"void blmoveGenericCommand (client*,int,int,mstime_t)",t_list.c,"void blmoveGenericCommand(client *c, int wherefrom, int whereto, mstime_t timeout) {
    robj *key = lookupKeyWrite(c->db, c->argv[1]);
    if (checkType(c,key,OBJ_LIST)) return;

    if (key == NULL) {
        if (c->flags & CLIENT_DENY_BLOCKING) {
            /* Blocking against an empty list when blocking is not allowed
             * returns immediately. */
            addReplyNull(c);
        } else {
            /* The list is empty and the client blocks. */
            blockForKeys(c,BLOCKED_LIST,c->argv + 1,1,timeout,0);
        }
    } else {
        /* The list exists and has elements, so
         * the regular lmoveCommand is executed. */
        serverAssertWithInfo(c,key,listTypeLength(key) > 0);
        lmoveGenericCommand(c,wherefrom,whereto);
    }
}",1287.0,1306.0,1.0,24.0,20.0,8,6,9,3,0,6,4,5,2,3,,0,5,8,4,4,void
6837,425567,lmpopGenericCommand,1,lmpopGenericCommand,"void lmpopGenericCommand (client*,int,int)",t_list.c,"void lmpopGenericCommand(client *c, int numkeys_idx, int is_block) {
    long j;
    long numkeys = 0;      /* Number of keys. */
    int where = 0;         /* HEAD for LEFT, TAIL for RIGHT. */
    long count = -1;       /* Reply will consist of up to count elements, depending on the list's length. */

    /* Parse the numkeys. */
    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;

    /* Parse the where. where_idx: the index of where in the c->argv. */
    long where_idx = numkeys_idx + numkeys + 1;
    if (where_idx >= c->argc) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    if (getListPositionFromObjectOrReply(c, c->argv[where_idx], &where) != C_OK)
        return;

    /* Parse the optional arguments. */
    for (j = where_idx + 1; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->arg...",1333.0,1378.0,1.0,87.0,46.0,46,15,47,12,0,13,9,12,8,5,,0,11,6,3,3,void
6838,425787,sunionDiffGenericCommand,1,sunionDiffGenericCommand,"void sunionDiffGenericCommand (client*,robj**,int,robj*,int)",t_set.c,"void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                              robj *dstkey, int op) {
    robj **sets = zmalloc(sizeof(robj*)*setnum);
    setTypeIterator *si;
    robj *dstset = NULL;
    char *str;
    size_t len;
    int64_t llval;
    int encoding;
    int j, cardinality = 0;
    int diff_algo = 1;
    int sameset = 0; 

    for (j = 0; j < setnum; j++) {
        robj *setobj = lookupKeyRead(c->db, setkeys[j]);
        if (!setobj) {
            sets[j] = NULL;
            continue;
        }
        if (checkType(c,setobj,OBJ_SET)) {
            zfree(sets);
            return;
        }
        sets[j] = setobj;
        if (j > 0 && sets[0] == sets[j]) {
            sameset = 1; 
        }
    }

    /* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M) where N is the size of the element first set
     * and M the total number of sets.
     *
     * Algorithm 2 is O(N) where N is the total number of elements in all
     ...",1482.0,1650.0,1.0,31.0,169.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,void
6839,425839,setTypeMaybeConvert,1,setTypeMaybeConvert,"void setTypeMaybeConvert (robj*,size_t)",t_set.c,"void setTypeMaybeConvert(robj *set, size_t size_hint) {
    if ((set->encoding == OBJ_ENCODING_LISTPACK && size_hint > server.set_max_listpack_entries)
        || (set->encoding == OBJ_ENCODING_INTSET && size_hint > server.set_max_intset_entries))
    {
        setTypeConvertAndExpand(set, OBJ_ENCODING_HT, size_hint, 1);
    }
}",61.0,67.0,1.0,26.0,7.0,11,6,8,3,0,1,2,2,0,1,,0,0,4,2,2,void
6840,425881,intsetMaxEntries,1,intsetMaxEntries,size_t intsetMaxEntries (void),t_set.c,"static size_t intsetMaxEntries(void) {
    size_t max_entries = server.set_max_intset_entries;
    /* limit to 1G entries due to intset internals. */
    if (max_entries >= 1<<30) max_entries = 1<<30;
    return max_entries;
}",70.0,75.0,1.0,1.0,6.0,6,4,5,2,2,0,2,2,0,0,,0,0,2,1,1,size_t
6841,425906,maybeConvertIntset,1,maybeConvertIntset,void maybeConvertIntset (robj*),t_set.c,"static void maybeConvertIntset(robj *subject) {
    serverAssert(subject->encoding == OBJ_ENCODING_INTSET);
    if (intsetLen(subject->ptr) > intsetMaxEntries())
        setTypeConvert(subject,OBJ_ENCODING_HT);
}",78.0,82.0,1.0,4.0,5.0,8,7,3,1,0,4,2,2,2,4,,0,2,2,1,1,void
6842,425942,maybeConvertToIntset,1,maybeConvertToIntset,void maybeConvertToIntset (robj*),t_set.c,"static void maybeConvertToIntset(robj *set) {
    if (set->encoding == OBJ_ENCODING_INTSET) return; /* already intset */
    if (setTypeSize(set) > intsetMaxEntries()) return; /* can't use intset */
    intset *is = intsetNew();
    char *str;
    size_t len;
    int64_t llval;
    setTypeIterator *si = setTypeInitIterator(set);
    while (setTypeNext(si, &str, &len, &llval) != -1) {
        if (str) {
            /* If the element is returned as a string, we may be able to convert
             * it to integer. This happens for OBJ_ENCODING_HT. */
            serverAssert(string2ll(str, len, (long long *)&llval));
        }
        uint8_t success = 0;
        is = intsetAdd(is, llval, &success);
        serverAssert(success);
    }
    setTypeReleaseIterator(si);
    freeSetObject(set); /* frees the internals but not robj itself */
    set->ptr = is;
    set->encoding = OBJ_ENCODING_INTSET;
}",87.0,109.0,1.0,25.0,23.0,27,11,25,7,0,11,5,6,3,11,,0,6,2,1,1,void
6843,427392,setTypePopRandom,1,setTypePopRandom,robj setTypePopRandom (robj*),t_set.c,"robj *setTypePopRandom(robj *set) {
    robj *obj;
    if (set->encoding == OBJ_ENCODING_LISTPACK) {
        /* Find random and delete it without re-seeking the listpack. */
        unsigned int i = 0;
        unsigned char *p = lpNextRandom(set->ptr, lpFirst(set->ptr), &i, 1, 0);
        unsigned int len = 0; /* initialize to silence warning */
        long long llele = 0; /* initialize to silence warning */
        char *str = (char *)lpGetValue(p, &len, &llele);
        if (str)
            obj = createStringObject(str, len);
        else
            obj = createStringObjectFromLongLong(llele);
        set->ptr = lpDelete(set->ptr, p, NULL);
    } else {
        char *str;
        size_t len = 0;
        int64_t llele = 0;
        int encoding = setTypeRandomElement(set, &str, &len, &llele);
        if (str)
            obj = createStringObject(str, len);
        else
            obj = createStringObjectFromLongLong(llele);
        setTypeRemoveAux(set, str, len, llele, encoding ...",452.0,478.0,1.0,25.0,27.0,17,5,21,8,0,5,3,4,0,5,,0,5,2,1,1,robj
6844,428719,spopWithCountCommand,1,spopWithCountCommand,void spopWithCountCommand (client*),t_set.c,"void spopWithCountCommand(client *c) {
    long l;
    unsigned long count, size;
    robj *set;

    /* Get the count argument */
    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
    count = (unsigned long) l;

    /* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set. Otherwise, return nil */
    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))
        == NULL || checkType(c,set,OBJ_SET)) return;

    /* If count is zero, serve an empty set ASAP to avoid special
     * cases later. */
    if (count == 0) {
        addReply(c,shared.emptyset[c->resp]);
        return;
    }

    size = setTypeSize(set);

    /* Generate an SPOP keyspace notification */
    notifyKeyspaceEvent(NOTIFY_SET,""spop"",c->argv[1],c->db->id);
    server.dirty += (count >= size) ? size : count;

    /* CASE 1:
     * The number of requested elements is greater than or equal to
     * the number of elements inside the ...",761.0,966.0,1.0,66.0,206.0,118,22,134,24,0,48,12,21,6,29,,0,31,2,1,1,void
6845,429649,srandmemberWithCountCommand,1,srandmemberWithCountCommand,void srandmemberWithCountCommand (client*),t_set.c,"void srandmemberWithCountCommand(client *c) {
    long l;
    unsigned long count, size;
    int uniq = 1;
    robj *set;
    char *str;
    size_t len;
    int64_t llele;

    dict *d;

    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
    if (l >= 0) {
        count = (unsigned long) l;
    } else {
        /* A negative count means: return the same elements multiple times
         * (i.e. don't remove the extracted element after every extraction). */
        count = -l;
        uniq = 0;
    }

    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))
        == NULL || checkType(c,set,OBJ_SET)) return;
    size = setTypeSize(set);

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time...",1020.0,1222.0,1.0,82.0,203.0,120,26,153,25,0,50,27,53,10,44,,0,27,2,1,1,void
6846,430333,qsortCompareSetsByCardinality,1,qsortCompareSetsByCardinality,"int qsortCompareSetsByCardinality (void*,void*)",t_set.c,"int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
    return 0;
}",1251.0,1255.0,1.0,1.0,5.0,11,5,4,2,0,4,3,3,4,4,,0,4,4,2,2,int
6847,430372,qsortCompareSetsByRevCardinality,1,qsortCompareSetsByRevCardinality,"int qsortCompareSetsByRevCardinality (void*,void*)",t_set.c,"int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
    unsigned long first = o1 ? setTypeSize(o1) : 0;
    unsigned long second = o2 ? setTypeSize(o2) : 0;

    if (first < second) return 1;
    if (first > second) return -1;
    return 0;
}",1259.0,1267.0,1.0,1.0,9.0,13,7,14,6,0,2,3,3,0,2,,0,2,4,2,2,int
6848,430425,sinterGenericCommand,1,sinterGenericCommand,"void sinterGenericCommand (client*,robj**,long unsigned,robj*,int,long unsigned)",t_set.c,"void sinterGenericCommand(client *c, robj **setkeys,
                          unsigned long setnum, robj *dstkey,
                          int cardinality_only, unsigned long limit) {
    robj **sets = zmalloc(sizeof(robj*)*setnum);
    setTypeIterator *si;
    robj *dstset = NULL;
    char *str;
    size_t len;
    int64_t intobj;
    void *replylen = NULL;
    unsigned long j, cardinality = 0;
    int encoding, empty = 0;

    for (j = 0; j < setnum; j++) {
        robj *setobj = lookupKeyRead(c->db, setkeys[j]);
        if (!setobj) {
            /* A NULL is considered an empty set */
            empty += 1;
            sets[j] = NULL;
            continue;
        }
        if (checkType(c,setobj,OBJ_SET)) {
            zfree(sets);
            return;
        }
        sets[j] = setobj;
    }

    /* Set intersection with an empty set always results in an empty set.
     * Return ASAP if there is an empty set. */
    if (empty > 0) {
        zfree(sets);
        if (dstkey) ...",1277.0,1438.0,1.0,31.0,162.0,53,18,78,23,0,20,21,34,5,16,,0,12,12,6,6,void
6849,431845,streamFreeCG,1,streamFreeCG,void streamFreeCG (streamCG*),t_stream.c,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}",2497.0,2501.0,1.0,1.0,5.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
6850,431855,streamReplyWithRangeFromConsumerPEL,1,streamReplyWithRangeFromConsumerPEL,"size_t streamReplyWithRangeFromConsumerPEL (client*,stream*,streamID*,streamID*,size_t,streamConsumer*)",t_stream.c,"size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {
    raxIterator ri;
    unsigned char startkey[sizeof(streamID)];
    unsigned char endkey[sizeof(streamID)];
    streamEncodeID(startkey,start);
    if (end) streamEncodeID(endkey,end);

    size_t arraylen = 0;
    void *arraylen_ptr = addReplyDeferredLen(c);
    raxStart(&ri,consumer->pel);
    raxSeek(&ri,"">="",startkey,sizeof(startkey));
    while(raxNext(&ri) && (!count || arraylen < count)) {
        if (end && memcmp(ri.key,end,ri.key_len) > 0) break;
        streamID thisid;
        streamDecodeID(ri.key,&thisid);
        if (streamReplyWithRange(c,s,&thisid,&thisid,1,0,NULL,NULL,
                                 STREAM_RWR_RAWENTRIES,NULL) == 0)
        {
            /* Note that we may have a not acknowledged entry in the PEL
             * about a message that's no longer here because was removed
             * by the user by other mea...",1811.0,1846.0,1.0,33.0,36.0,0,0,0,0,0,0,1,1,0,0,,0,0,12,6,6,size_t
6851,431865,streamParseStrictIDOrReply,1,streamParseStrictIDOrReply,"int streamParseStrictIDOrReply (client*,robj*,streamID*,uint64_t,int*)",t_stream.c,"int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given) {
    return streamGenericParseIDOrReply(c,o,id,missing_seq,1,seq_given);
}",1949.0,1951.0,1.0,1.0,3.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
6852,431874,streamParseIDOrReply,1,streamParseIDOrReply,"int streamParseIDOrReply (client*,robj*,streamID*,uint64_t)",t_stream.c,"int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
    return streamGenericParseIDOrReply(c,o,id,missing_seq,0,NULL);
}",1942.0,1944.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,int
6853,432117,streamNextID,1,streamNextID,"void streamNextID (streamID*,streamID*)",t_stream.c,"void streamNextID(streamID *last_id, streamID *new_id) {
    uint64_t ms = commandTimeSnapshot();
    if (ms > last_id->ms) {
        new_id->ms = ms;
        new_id->seq = 0;
    } else {
        *new_id = *last_id;
        streamIncrID(new_id);
    }
}",140.0,149.0,1.0,1.0,10.0,7,3,6,3,0,4,2,2,1,1,,0,4,4,2,2,void
6854,432586,lpGetIntegerIfValid,1,lpGetIntegerIfValid,"int64_t lpGetIntegerIfValid (unsigned char*,int*)",t_stream.c,"static inline int64_t lpGetIntegerIfValid(unsigned char *ele, int *valid) {
    int64_t v;
    unsigned char *e = lpGet(ele,&v,NULL);
    if (e == NULL) {
        if (valid)
            *valid = 1;
        return v;
    }
    /* The following code path should never be used for how listpacks work:
     * they should always be able to store an int64_t value in integer
     * encoded form. However the implementation may change. */
    long long ll;
    int ret = string2ll((char*)e,v,&ll);
    if (valid)
        *valid = ret;
    else
        serverAssert(ret != 0);
    v = ll;
    return v;
}",266.0,285.0,1.0,8.0,20.0,11,5,19,7,9,2,4,5,0,2,,0,2,4,2,2,int64_t
6855,432656,lpGetEdgeStreamID,1,lpGetEdgeStreamID,"int lpGetEdgeStreamID (unsigned char*,int,streamID*,streamID*)",t_stream.c,"int lpGetEdgeStreamID(unsigned char *lp, int first, streamID *master_id, streamID *edge_id)
{
   if (lp == NULL)
       return 0;

   unsigned char *lp_ele;

   /* We need to seek either the first or the last entry depending
    * on the direction of the iteration. */
   if (first) {
       /* Get the master fields count. */
       lp_ele = lpFirst(lp);        /* Seek items count */
       lp_ele = lpNext(lp, lp_ele); /* Seek deleted count. */
       lp_ele = lpNext(lp, lp_ele); /* Seek num fields. */
       int64_t master_fields_count = lpGetInteger(lp_ele);
       lp_ele = lpNext(lp, lp_ele); /* Seek first field. */

       /* If we are iterating in normal order, skip the master fields
        * to seek the first actual entry. */
       for (int64_t i = 0; i < master_fields_count; i++)
           lp_ele = lpNext(lp, lp_ele);

       /* If we are going forward, skip the previous entry's
        * lp-count field (or in case of the master entry, the zero
        * term field) */
    ...",291.0,346.0,1.0,37.0,56.0,20,6,44,9,0,12,5,7,0,10,,0,10,8,4,4,int
6856,432802,streamLogListpackContent,1,streamLogListpackContent,void streamLogListpackContent (unsigned char*),t_stream.c,"void streamLogListpackContent(unsigned char *lp) {
    unsigned char *p = lpFirst(lp);
    while(p) {
        unsigned char buf[LP_INTBUF_SIZE];
        int64_t v;
        unsigned char *ele = lpGet(p,&v,buf);
        serverLog(LL_WARNING,""- [%d] '%.*s'"", (int)v, (int)v, ele);
        p = lpNext(lp,p);
    }
}",350.0,359.0,1.0,26.0,10.0,9,6,14,6,0,4,2,2,0,4,,0,3,2,1,1,void
6857,432855,streamEncodeID,1,streamEncodeID,"void streamEncodeID (void*,streamID*)",t_stream.c,"void streamEncodeID(void *buf, streamID *id) {
    uint64_t e[2];
    e[0] = htonu64(id->ms);
    e[1] = htonu64(id->seq);
    memcpy(buf,e,sizeof(e));
}",363.0,368.0,1.0,11.0,6.0,9,4,9,3,0,6,1,1,0,2,,0,6,4,2,2,void
6858,433807,streamTrim,1,streamTrim,"int64_t streamTrim (stream*,streamAddTrimArgs*)",t_stream.c,"int64_t streamTrim(stream *s, streamAddTrimArgs *args) {
    size_t maxlen = args->maxlen;
    streamID *id = &args->minid;
    int approx = args->approx_trim;
    int64_t limit = args->limit;
    int trim_strategy = args->trim_strategy;

    if (trim_strategy == TRIM_STRATEGY_NONE)
        return 0;

    raxIterator ri;
    raxStart(&ri,s->rax);
    raxSeek(&ri,""^"",NULL,0);

    int64_t deleted = 0;
    while (raxNext(&ri)) {
        if (trim_strategy == TRIM_STRATEGY_MAXLEN && s->length <= maxlen)
            break;

        unsigned char *lp = ri.data, *p = lpFirst(lp);
        int64_t entries = lpGetInteger(p);

        /* Check if we exceeded the amount of work we could do */
        if (limit && (deleted + entries) > limit)
            break;

        /* Check if we can remove the whole node. */
        int remove_node;
        streamID master_id = {0}; /* For MINID */
        if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
            remove_node = s->length - entries >= maxlen;...",719.0,878.0,1.0,25.0,160.0,122,21,172,27,0,56,24,38,3,29,,0,49,4,2,2,int64_t
6859,434448,streamParseAddOrTrimArgsOrReply,1,streamParseAddOrTrimArgsOrReply,"int streamParseAddOrTrimArgsOrReply (client*,streamAddTrimArgs*,int)",t_stream.c,"static int streamParseAddOrTrimArgsOrReply(client *c, streamAddTrimArgs *args, int xadd) {
    /* Initialize arguments to defaults */
    memset(args, 0, sizeof(*args));

    /* Parse options. */
    int i = 2; /* This is the first argument position where we could
                  find an option, or the ID. */
    int limit_given = 0;
    for (; i < c->argc; i++) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (xadd && opt[0] == '*' && opt[1] == '\0') {
            /* This is just a fast path for the common case of auto-ID
             * creation. */
            break;
        } else if (!strcasecmp(opt,""maxlen"") && moreargs) {
            if (args->trim_strategy != TRIM_STRATEGY_NONE) {
                addReplyError(c,""syntax error, MAXLEN and MINID options at the same time are not compatible"");
                return -1;
            }
            args->approx_trim = 0;
            char *next = c->argv...",908.0,1040.0,1.0,39.0,133.0,32,11,24,7,0,10,7,7,5,3,,0,8,6,3,3,int
6860,436153,streamEntryExists,1,streamEntryExists,"int streamEntryExists (stream*,streamID*)",t_stream.c,"int streamEntryExists(stream *s, streamID *id) {
    streamIterator si;
    streamIteratorStart(&si,s,id,id,0);
    streamID myid;
    int64_t numfields;
    int found = streamIteratorGetID(&si,&myid,&numfields);
    streamIteratorStop(&si);
    if (!found)
        return 0;
    serverAssert(streamCompareID(id,&myid) == 0);
    return 1;
}",1338.0,1349.0,1.0,4.0,12.0,13,8,12,6,0,5,2,2,0,5,,0,1,4,2,2,int
6861,436251,streamLastValidID,1,streamLastValidID,"void streamLastValidID (stream*,streamID*)",t_stream.c,"void streamLastValidID(stream *s, streamID *maxid)
{
    streamIterator si;
    streamIteratorStart(&si,s,NULL,NULL,1);
    int64_t numfields;
    if (!streamIteratorGetID(&si,maxid,&numfields) && s->length)
        serverPanic(""Corrupt stream, length is %llu, but no max id"", (unsigned long long)s->length);
    streamIteratorStop(&si);
}",1368.0,1376.0,1.0,8.0,9.0,10,6,10,5,0,6,2,2,2,4,,0,3,4,2,2,void
6862,436295,createStreamIDString,1,createStreamIDString,sds createStreamIDString (streamID*),t_stream.c,"sds createStreamIDString(streamID *id) {
    /* Optimization: pre-allocate a big enough buffer to avoid reallocs. */
    sds str = sdsnewlen(SDS_NOINIT, STREAM_ID_STR_LEN);
    sdssetlen(str, 0);
    return sdscatfmt(str,""%U-%U"", id->ms,id->seq);
}",1385.0,1390.0,1.0,36.0,6.0,3,2,6,3,2,5,1,1,0,3,,0,3,2,1,1,sds
6863,436321,addReplyStreamID,1,addReplyStreamID,"void addReplyStreamID (client*,streamID*)",t_stream.c,"void addReplyStreamID(client *c, streamID *id) {
    addReplyBulkSds(c,createStreamIDString(id));
}",1395.0,1397.0,1.0,1.0,3.0,0,0,2,2,3,2,1,1,0,2,,0,1,4,2,2,void
6864,436331,setDeferredReplyStreamID,1,setDeferredReplyStreamID,"void setDeferredReplyStreamID (client*,void*,streamID*)",t_stream.c,"void setDeferredReplyStreamID(client *c, void *dr, streamID *id) {
    setDeferredReplyBulkSds(c, dr, createStreamIDString(id));
}",1399.0,1401.0,1.0,1.0,3.0,0,0,3,3,0,2,1,1,0,2,,0,1,6,3,3,void
6865,436355,streamIDEqZero,1,streamIDEqZero,int streamIDEqZero (streamID*),t_stream.c,"int streamIDEqZero(streamID *id) {
    return !(id->ms || id->seq);
}",1410.0,1412.0,1.0,1.0,3.0,4,3,2,1,1,2,1,1,0,0,,0,2,2,1,1,int
6866,436369,streamRangeHasTombstones,1,streamRangeHasTombstones,"int streamRangeHasTombstones (stream*,streamID*,streamID*)",t_stream.c,"int streamRangeHasTombstones(stream *s, streamID *start, streamID *end) {
    streamID start_id, end_id;

    if (!s->length || streamIDEqZero(&s->max_deleted_entry_id)) {
        /* The stream is empty or has no tombstones. */
        return 0;
    }

    if (streamCompareID(&s->first_id,&s->max_deleted_entry_id) > 0) {
        /* The latest tombstone is before the first entry. */
        return 0;
    }

    if (start) {
        start_id = *start;
    } else {
        start_id.ms = 0;
        start_id.seq = 0;
    }

    if (end) {
        end_id = *end;
    } else {
        end_id.ms = UINT64_MAX;
        end_id.seq = UINT64_MAX;
    }

    if (streamCompareID(&start_id,&s->max_deleted_entry_id) <= 0 &&
        streamCompareID(&s->max_deleted_entry_id,&end_id) <= 0)
    {
        /* start_id <= max_deleted_entry_id <= end_id: The range does include a tombstone. */
        return 1;
    }

    /* The range doesn't includes a tombstone. */
    return 0;
}",1419.0,1455.0,1.0,1.0,37.0,23,9,14,5,0,10,6,6,10,4,,0,10,6,3,3,int
6867,436470,streamReplyWithCGLag,1,streamReplyWithCGLag,"void streamReplyWithCGLag (client*,stream*,streamCG*)",t_stream.c,"void streamReplyWithCGLag(client *c, stream *s, streamCG *cg) {
    int valid = 0;
    long long lag = 0;

    if (!s->entries_added) {
        /* The lag of a newly-initialized stream is 0. */
        lag = 0;
        valid = 1;
    } else if (cg->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&cg->last_id,NULL)) {
        /* No fragmentation ahead means that the group's logical reads counter
         * is valid for performing the lag calculation. */
        lag = (long long)s->entries_added - cg->entries_read;
        valid = 1;
    } else {
        /* Attempt to retrieve the group's last ID logical read counter. */
        long long entries_read = streamEstimateDistanceFromFirstEverEntry(s,&cg->last_id);
        if (entries_read != SCG_INVALID_ENTRIES_READ) {
            /* A valid counter was obtained. */
            lag = (long long)s->entries_added - entries_read;
            valid = 1;
        }
    }

    if (valid) {
        addReplyLongLong(c,lag);...",1460.0,1488.0,1.0,35.0,29.0,6,3,8,4,0,2,3,3,1,1,,0,1,6,3,3,void
6868,436703,streamPropagateXCLAIM,1,streamPropagateXCLAIM,"void streamPropagateXCLAIM (client*,robj*,streamCG*,robj*,robj*,streamNACK*)",t_stream.c,"void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {
    /* We need to generate an XCLAIM that will work in a idempotent fashion:
     *
     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
     *        RETRYCOUNT <count> FORCE JUSTID LASTID <id>.
     *
     * Note that JUSTID is useful in order to avoid that XCLAIM will do
     * useless work in the slave side, trying to fetch the stream item. */
    robj *argv[14];
    argv[0] = shared.xclaim;
    argv[1] = key;
    argv[2] = groupname;
    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));
    argv[4] = shared.integers[0];
    argv[5] = id;
    argv[6] = shared.time;
    argv[7] = createStringObjectFromLongLong(nack->delivery_time);
    argv[8] = shared.retrycount;
    argv[9] = createStringObjectFromLongLong(nack->delivery_count);
    argv[10] = shared.force;
    argv[11] = shared.justid;
    argv[12] = shared.lasti...",1554.0,1584.0,1.0,36.0,31.0,51,6,35,8,0,16,1,1,0,10,,0,11,12,6,6,void
6869,436852,streamPropagateGroupID,1,streamPropagateGroupID,"void streamPropagateGroupID (client*,robj*,streamCG*,robj*)",t_stream.c,"void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {
    robj *argv[7];
    argv[0] = shared.xgroup;
    argv[1] = shared.setid;
    argv[2] = key;
    argv[3] = groupname;
    argv[4] = createObjectFromStreamID(&group->last_id);
    argv[5] = shared.entriesread;
    argv[6] = createStringObjectFromLongLong(group->entries_read);

    alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);

    decrRefCount(argv[4]);
    decrRefCount(argv[6]);
}",1592.0,1606.0,1.0,35.0,15.0,25,6,18,6,0,8,1,1,0,5,,0,5,8,4,4,void
6870,437505,streamTypeLookupWriteOrCreate,1,streamTypeLookupWriteOrCreate,"robj streamTypeLookupWriteOrCreate (client*,robj*,int)",t_stream.c,"robj *streamTypeLookupWriteOrCreate(client *c, robj *key, int no_create) {
    robj *o = lookupKeyWrite(c->db,key);
    if (checkType(c,o,OBJ_STREAM)) return NULL;
    if (o == NULL) {
        if (no_create) {
            addReplyNull(c);
            return NULL;
        }
        o = createStreamObject();
        dbAdd(c->db,key,o);
    }
    return o;
}",1854.0,1866.0,1.0,22.0,13.0,5,3,16,5,0,7,4,5,1,5,,0,5,6,3,3,robj
6871,437553,streamGenericParseIDOrReply,1,streamGenericParseIDOrReply,"int streamGenericParseIDOrReply (client*,robj*,streamID*,uint64_t,int,int*)",t_stream.c,"int streamGenericParseIDOrReply(client *c, const robj *o, streamID *id, uint64_t missing_seq, int strict, int *seq_given) {
    char buf[128];
    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;
    memcpy(buf,o->ptr,sdslen(o->ptr)+1);

    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\0')
        goto invalid;

    if (seq_given != NULL) {
        *seq_given = 1;
    }

    /* Handle the ""-"" and ""+"" special cases. */
    if (buf[0] == '-' && buf[1] == '\0') {
        id->ms = 0;
        id->seq = 0;
        return C_OK;
    } else if (buf[0] == '+' && buf[1] == '\0') {
        id->ms = UINT64_MAX;
        id->seq = UINT64_MAX;
        return C_OK;
    }

    /* Parse <ms>-<seq> form. */
    unsigned long long ms, seq;
    char *dot = strchr(buf,'-');
    if (dot) *dot = '\0';
    if (string2ull(buf,&ms) == 0) goto invalid;
    if (dot) {
        size_t seqlen = strlen(dot+1);
        if (seq_given != NULL && seqlen == 1 && *(dot + 1) == '*') {
            /* Handl...",1885.0,1933.0,1.0,15.0,49.0,50,14,37,11,0,8,13,11,2,4,,0,6,12,6,6,int
6872,437822,streamParseIntervalIDOrReply,1,streamParseIntervalIDOrReply,"int streamParseIntervalIDOrReply (client*,robj*,streamID*,int*,uint64_t)",t_stream.c,"int streamParseIntervalIDOrReply(client *c, robj *o, streamID *id, int *exclude, uint64_t missing_seq) {
    char *p = o->ptr;
    size_t len = sdslen(p);
    int invalid = 0;
    
    if (exclude != NULL) *exclude = (len > 1 && p[0] == '(');
    if (exclude != NULL && *exclude) {
        robj *t = createStringObject(p+1,len-1);
        invalid = (streamParseStrictIDOrReply(c,t,id,missing_seq,NULL) == C_ERR);
        decrRefCount(t);
    } else 
        invalid = (streamParseIDOrReply(c,o,id,missing_seq) == C_ERR);
    if (invalid)
        return C_ERR;
    return C_OK;
}",1959.0,1974.0,1.0,74.0,16.0,21,11,24,10,2,4,4,4,0,4,,0,3,10,5,5,int
6873,437922,streamRewriteApproxSpecifier,1,streamRewriteApproxSpecifier,"void streamRewriteApproxSpecifier (client*,int)",t_stream.c,"void streamRewriteApproxSpecifier(client *c, int idx) {
    rewriteClientCommandArgument(c,idx,shared.special_equals);
}",1976.0,1978.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
6874,437934,streamRewriteTrimArgument,1,streamRewriteTrimArgument,"void streamRewriteTrimArgument (client*,stream*,int,int)",t_stream.c,"void streamRewriteTrimArgument(client *c, stream *s, int trim_strategy, int idx) {
    robj *arg;
    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
        arg = createStringObjectFromLongLong(s->length);
    } else {
        streamID first_id;
        streamGetEdgeID(s,1,0,&first_id);
        arg = createObjectFromStreamID(&first_id);
    }

    rewriteClientCommandArgument(c,idx,arg);
    decrRefCount(arg);
}",1982.0,1994.0,1.0,25.0,13.0,3,3,7,5,0,4,2,2,0,3,,0,2,8,4,4,void
6875,438303,xrangeGenericCommand,1,xrangeGenericCommand,"void xrangeGenericCommand (client*,int)",t_stream.c,"void xrangeGenericCommand(client *c, int rev) {
    robj *o;
    stream *s;
    streamID startid, endid;
    long long count = -1;
    robj *startarg = rev ? c->argv[3] : c->argv[2];
    robj *endarg = rev ? c->argv[2] : c->argv[3];
    int startex = 0, endex = 0;
    
    /* Parse start and end IDs. */
    if (streamParseIntervalIDOrReply(c,startarg,&startid,&startex,0) != C_OK)
        return;
    if (startex && streamIncrID(&startid) != C_OK) {
        addReplyError(c,""invalid start ID for the interval"");
        return;
    }
    if (streamParseIntervalIDOrReply(c,endarg,&endid,&endex,UINT64_MAX) != C_OK)
        return;
    if (endex && streamDecrID(&endid) != C_OK) {
        addReplyError(c,""invalid end ID for the interval"");
        return;
    }

    /* Parse the COUNT option if any. */
    if (c->argc > 4) {
        for (int j = 4; j < c->argc; j++) {
            int additional = c->argc-j-1;
            if (strcasecmp(c->argv[j]->ptr,""COUNT"") == 0 && additional >= 1) {
   ...",2093.0,2144.0,1.0,72.0,52.0,60,17,55,16,0,20,12,21,12,10,,0,17,4,2,2,void
6876,439621,streamFreeConsumer,1,streamFreeConsumer,void streamFreeConsumer (streamConsumer*),t_stream.c,"void streamFreeConsumer(streamConsumer *sc) {
    raxFree(sc->pel); /* No value free callback: the PEL entries are shared
                         between the consumer and the main stream PEL. */
    sdsfree(sc->name);
    zfree(sc);
}",2471.0,2476.0,1.0,1.0,6.0,2,1,3,1,1,5,1,1,0,3,,0,2,2,1,1,void
6877,439910,streamDelConsumer,1,streamDelConsumer,"void streamDelConsumer (streamCG*,streamConsumer*)",t_stream.c,"void streamDelConsumer(streamCG *cg, streamConsumer *consumer) {
    /* Iterate all the consumer pending messages, deleting every corresponding
     * entry from the global entry. */
    raxIterator ri;
    raxStart(&ri,consumer->pel);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        streamNACK *nack = ri.data;
        raxRemove(cg->pel,ri.key,ri.key_len,NULL);
        streamFreeNACK(nack);
    }
    raxStop(&ri);

    /* Deallocate the consumer. */
    raxRemove(cg->consumers,(unsigned char*)consumer->name,
              sdslen(consumer->name),NULL);
    streamFreeConsumer(consumer);
}",2546.0,2563.0,1.0,1.0,18.0,14,5,18,5,0,17,2,2,1,9,,0,10,4,2,2,void
6878,443682,xinfoReplyWithStreamInfo,1,xinfoReplyWithStreamInfo,"void xinfoReplyWithStreamInfo (client*,stream*)",t_stream.c,"void xinfoReplyWithStreamInfo(client *c, stream *s) {
    int full = 1;
    long long count = 10; /* Default COUNT is 10 so we don't block the server */
    robj **optv = c->argv + 3; /* Options start after XINFO STREAM <key> */
    int optc = c->argc - 3;

    /* Parse options. */
    if (optc == 0) {
        full = 0;
    } else {
        /* Valid options are [FULL] or [FULL COUNT <count>] */
        if (optc != 1 && optc != 3) {
            addReplySubcommandSyntaxError(c);
            return;
        }

        /* First option must be ""FULL"" */
        if (strcasecmp(optv[0]->ptr,""full"")) {
            addReplySubcommandSyntaxError(c);
            return;
        }

        if (optc == 3) {
            /* First option must be ""FULL"" */
            if (strcasecmp(optv[1]->ptr,""count"")) {
                addReplySubcommandSyntaxError(c);
                return;
            }
            if (getLongLongFromObjectOrReply(c,optv[2],&count,NULL) == C_ERR)
                return;
     ...",3636.0,3839.0,1.0,71.0,204.0,44,10,63,11,0,40,5,7,0,25,,0,19,4,2,2,void
6879,445129,getGenericCommand,1,getGenericCommand,int getGenericCommand (client*),t_string.c,"int getGenericCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)
        return C_OK;

    if (checkType(c,o,OBJ_STRING)) {
        return C_ERR;
    }

    addReplyBulk(c,o);
    return C_OK;
}",323.0,335.0,1.0,15.0,13.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,int
6880,445134,checkStringLength,1,checkStringLength,"int checkStringLength (client*,long long,long long)",t_string.c,"static int checkStringLength(client *c, long long size, long long append) {
    if (mustObeyClient(c))
        return C_OK;
    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */
    long long total = (uint64_t)size + append;
    /* Test configured max-bulk-len represending a limit of the biggest string object,
     * and also test for overflow. */
    if (total > server.proto_max_bulk_len || total < size || total < append) {
        addReplyError(c,""string exceeds maximum allowed size (proto-max-bulk-len)"");
        return C_ERR;
    }
    return C_OK;
}",40.0,52.0,1.0,15.0,13.0,10,8,11,5,0,2,3,3,1,2,,0,1,6,3,3,int
6881,445184,getExpireMillisecondsOrReply,1,getExpireMillisecondsOrReply,"int getExpireMillisecondsOrReply (client*,robj*,int,int,long long*)",t_string.c,"static int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {
    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);
    if (ret != C_OK) {
        return ret;
    }

    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {
        /* Negative value provided or multiplication is gonna overflow. */
        addReplyErrorExpireTime(c);
        return C_ERR;
    }

    if (unit == UNIT_SECONDS) *milliseconds *= 1000;

    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {
        *milliseconds += commandTimeSnapshot();
    }

    if (*milliseconds <= 0) {
        /* Overflow detected. */
        addReplyErrorExpireTime(c);
        return C_ERR;
    }

    return C_OK;
}",164.0,189.0,1.0,15.0,26.0,0,0,0,0,1,0,1,1,0,0,,0,0,10,5,5,int
6882,445193,setGenericCommand,1,setGenericCommand,"void setGenericCommand (client*,int,robj*,robj*,robj*,int,robj*,robj*)",t_string.c,"void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
    long long milliseconds = 0; /* initialized to avoid any harmness warning */
    int found = 0;
    int setkey_flags = 0;

    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {
        return;
    }

    if (flags & OBJ_SET_GET) {
        if (getGenericCommand(c) == C_ERR) return;
    }

    found = (lookupKeyWrite(c->db,key) != NULL);

    if ((flags & OBJ_SET_NX && found) ||
        (flags & OBJ_SET_XX && !found))
    {
        if (!(flags & OBJ_SET_GET)) {
            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);
        }
        return;
    }

    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */
    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;
    setkey_flags |= found ? SETKEY_ALR...",84.0,150.0,1.0,89.0,67.0,100,20,89,20,0,26,13,18,3,15,,0,16,16,8,8,void
6883,445648,parseExtendedStringArgumentsOrReply,1,parseExtendedStringArgumentsOrReply,"int parseExtendedStringArgumentsOrReply (client*,int*,int*,robj**,int)",t_string.c,"int parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {

    int j = command_type == COMMAND_GET ? 2 : 3;
    for (; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];

        if ((opt[0] == 'n' || opt[0] == 'N') &&
            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\0' &&
            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))
        {
            *flags |= OBJ_SET_NX;
        } else if ((opt[0] == 'x' || opt[0] == 'X') &&
                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\0' &&
                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))
        {
            *flags |= OBJ_SET_XX;
        } else if ((opt[0] == 'g' || opt[0] == 'G') &&
                   (opt[1] == 'e' || opt[1] == 'E') &&
                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\0' &&
                   (command_type == COMMAND_SET))
...",209.0,291.0,1.0,28.0,83.0,40,14,21,7,0,4,3,4,1,0,,0,4,10,5,5,int
6884,447700,msetGenericCommand,1,msetGenericCommand,"void msetGenericCommand (client*,int)",t_string.c,"void msetGenericCommand(client *c, int nx) {
    int j;

    if ((c->argc % 2) == 0) {
        addReplyErrorArity(c);
        return;
    }

    /* Handle the NX flag. The MSETNX semantic is to return zero and don't
     * set anything if at least one key already exists. */
    if (nx) {
        for (j = 1; j < c->argc; j += 2) {
            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
                addReply(c, shared.czero);
                return;
            }
        }
    }

    int setkey_flags = nx ? SETKEY_DOESNT_EXIST : 0;
    for (j = 1; j < c->argc; j += 2) {
        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);
        notifyKeyspaceEvent(NOTIFY_STRING,""set"",c->argv[j],c->db->id);
        /* In MSETNX, It could be that we're overriding the same key, we can't be sure it doesn't exist. */
        if (nx)
            setkey_flags = SETKEY_ADD_OR_UPDATE;
    }
    server.dirty += (c->argc-1)/2;
    ad...",561.0,591.0,1.0,28.0,31.0,43,14,39,7,0,20,7,11,6,7,,0,15,4,2,2,void
6885,447874,incrDecrCommand,1,incrDecrCommand,"void incrDecrCommand (client*,long long)",t_string.c,"void incrDecrCommand(client *c, long long incr) {
    long long value, oldvalue;
    robj *o, *new;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return;
    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;

    oldvalue = value;
    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
        addReplyError(c,""increment or decrement would overflow"");
        return;
    }
    value += incr;

    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
        value >= LONG_MIN && value <= LONG_MAX)
    {
        new = o;
        o->ptr = (void*)((long)value);
    } else {
        new = createStringObjectFromLongLongForValue(value);
        if (o) {
            dbReplaceValue(c->db,c->argv[1],new);
        } else {
            dbAdd(c->db,c->argv[1],new);
        }
    }
    signalModifiedKey(c...",601.0,635.0,1.0,22.0,35.0,50,18,45,12,0,13,5,5,2,7,,0,9,4,2,2,void
6886,449362,zsetConvertAndExpand,1,zsetConvertAndExpand,"void zsetConvertAndExpand (robj*,int,long unsigned)",t_zset.c,"void zsetConvertAndExpand(robj *zobj, int encoding, unsigned long cap) {
    zset *zs;
    zskiplistNode *node, *next;
    sds ele;
    double score;

    if (zobj->encoding == encoding) return;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        if (encoding != OBJ_ENCODING_SKIPLIST)
            serverPanic(""Unknown target encoding"");

        zs = zmalloc(sizeof(*zs));
        zs->dict = dictCreate(&zsetDictType);
        zs->zsl = zslCreate();

        /* Presize the dict to avoid rehashing */
        dictExpand(zs->dict, cap);

        eptr = lpSeek(zl,0);
        if (eptr != NULL) {
            sptr = lpNext(zl,eptr);
            serverAssertWithInfo(NULL,zobj,sptr != NULL);
        }

        while (eptr != NULL) {
            score = zzlGetScore(sptr);
            vstr = lpGetValue(eptr,&vlen,&vlong);
            i...",1207.0,1280.0,1.0,26.0,74.0,0,0,0,0,1,0,1,1,0,0,,0,0,6,3,3,void
6887,449369,zslCreateNode,1,zslCreateNode,"zskiplistNode zslCreateNode (int,double,sds)",t_zset.c,"zskiplistNode *zslCreateNode(int level, double score, sds ele) {
    zskiplistNode *zn =
        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
    zn->score = score;
    zn->ele = ele;
    return zn;
}",73.0,79.0,1.0,1.0,7.0,10,6,9,5,0,3,1,1,0,1,,0,3,6,3,3,zskiplistNode
6888,449482,zslFreeNode,1,zslFreeNode,void zslFreeNode (zskiplistNode*),t_zset.c,"void zslFreeNode(zskiplistNode *node) {
    sdsfree(node->ele);
    zfree(node);
}",102.0,105.0,1.0,1.0,4.0,1,1,2,1,4,3,1,1,0,2,,0,1,2,1,1,void
6889,449534,zslRandomLevel,1,zslRandomLevel,int zslRandomLevel (void),t_zset.c,"int zslRandomLevel(void) {
    static const int threshold = ZSKIPLIST_P*RAND_MAX;
    int level = 1;
    while (random() < threshold)
        level += 1;
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}",124.0,130.0,1.0,33.0,7.0,6,4,6,3,0,0,2,2,0,0,,0,0,2,1,1,int
6890,449924,zslDeleteNode,1,zslDeleteNode,"void zslDeleteNode (zskiplist*,zskiplistNode*,zskiplistNode**)",t_zset.c,"void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    for (i = 0; i < zsl->level; i++) {
        if (update[i]->level[i].forward == x) {
            update[i]->level[i].span += x->level[i].span - 1;
            update[i]->level[i].forward = x->level[i].forward;
        } else {
            update[i]->level[i].span -= 1;
        }
    }
    if (x->level[0].forward) {
        x->level[0].forward->backward = x->backward;
    } else {
        zsl->tail = x->backward;
    }
    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
        zsl->level--;
    zsl->length--;
}",194.0,212.0,1.0,1.0,19.0,46,11,25,5,4,10,5,6,5,0,,0,10,6,3,3,void
6891,450206,zslUpdateScore,1,zslUpdateScore,"zskiplistNode zslUpdateScore (zskiplist*,double,sds,double)",t_zset.c,"zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    /* We need to seek to element to update to start: this is useful anyway,
     * we'll have to update or remove it. */
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < curscore ||
                    (x->level[i].forward->score == curscore &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    /* Jump to our element: note that this function assumes that the
     * element with the matching score exists. */
    x = x->level[0].forward;
    serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);

    /* If the node, after the score update, would be still exactly
     * at the same position, we can just update the score w...",262.0,304.0,1.0,26.0,43.0,70,15,51,9,0,23,4,5,9,6,,0,19,8,4,4,zskiplistNode
6892,450443,zslIsInRange,1,zslIsInRange,"int zslIsInRange (zskiplist*,zrangespec*)",t_zset.c,"int zslIsInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;

    /* Test for ranges that will always be empty. */
    if (range->min > range->max ||
            (range->min == range->max && (range->minex || range->maxex)))
        return 0;
    x = zsl->tail;
    if (x == NULL || !zslValueGteMin(x->score,range))
        return 0;
    x = zsl->header->level[0].forward;
    if (x == NULL || !zslValueLteMax(x->score,range))
        return 0;
    return 1;
}",315.0,329.0,1.0,1.0,15.0,26,9,18,4,0,12,4,4,10,2,,0,12,4,2,2,int
6893,450719,zslDeleteRangeByScore,1,zslDeleteRangeByScore,"unsigned long zslDeleteRangeByScore (zskiplist*,zrangespec*,dict*)",t_zset.c,"unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long removed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            !zslValueGteMin(x->level[i].forward->score, range))
                x = x->level[i].forward;
        update[i] = x;
    }

    /* Current node is the last with score < or <= min. */
    x = x->level[0].forward;

    /* Delete nodes while in range. */
    while (x && zslValueLteMax(x->score, range)) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x); /* Here is where x->ele is actually released. */
        removed++;
        x = next;
    }
    return removed;
}",387.0,413.0,1.0,26.0,27.0,31,9,31,8,0,13,4,5,5,5,,0,10,6,3,3,unsigned long
6894,450834,zslDeleteRangeByLex,1,zslDeleteRangeByLex,"unsigned long zslDeleteRangeByLex (zskiplist*,zlexrangespec*,dict*)",t_zset.c,"unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long removed = 0;
    int i;


    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            !zslLexValueGteMin(x->level[i].forward->ele,range))
                x = x->level[i].forward;
        update[i] = x;
    }

    /* Current node is the last with score < or <= min. */
    x = x->level[0].forward;

    /* Delete nodes while in range. */
    while (x && zslLexValueLteMax(x->ele,range)) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x); /* Here is where x->ele is actually released. */
        removed++;
        x = next;
    }
    return removed;
}",415.0,442.0,1.0,26.0,28.0,31,9,31,8,0,13,4,5,5,5,,0,10,6,3,3,unsigned long
6895,450949,zslDeleteRangeByRank,1,zslDeleteRangeByRank,"unsigned long zslDeleteRangeByRank (zskiplist*,unsigned int,unsigned int,dict*)",t_zset.c,"unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long traversed = 0, removed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward && (traversed + x->level[i].span) < start) {
            traversed += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    traversed++;
    x = x->level[0].forward;
    while (x && traversed <= end) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x);
        removed++;
        traversed++;
        x = next;
    }
    return removed;
}",446.0,472.0,1.0,26.0,27.0,42,12,41,10,0,12,4,5,2,3,,0,9,8,4,4,unsigned long
6896,451281,zslParseRange,1,zslParseRange,"int zslParseRange (robj*,robj*,zrangespec*)",t_zset.c,"static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
    char *eptr;
    spec->minex = spec->maxex = 0;

    /* Parse the min-max interval. If one of the values is prefixed
     * by the ""("" character, it's considered ""open"". For instance
     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */
    if (min->encoding == OBJ_ENCODING_INT) {
        spec->min = (long)min->ptr;
    } else {
        if (((char*)min->ptr)[0] == '(') {
            spec->min = strtod((char*)min->ptr+1,&eptr);
            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
            spec->minex = 1;
        } else {
            spec->min = strtod((char*)min->ptr,&eptr);
            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
        }
    }
    if (max->encoding == OBJ_ENCODING_INT) {
        spec->max = (long)max->ptr;
    } else {
        if (((char*)max->ptr)[0] == '(') {
            spec->max = strto...",522.0,556.0,1.0,25.0,35.0,16,4,8,3,0,4,3,3,0,0,,0,4,6,3,3,int
6897,451498,zslParseLexRangeItem,1,zslParseLexRangeItem,"int zslParseLexRangeItem (robj*,sds*,int*)",t_zset.c,"int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
    char *c = item->ptr;

    switch(c[0]) {
    case '+':
        if (c[1] != '\0') return C_ERR;
        *ex = 1;
        *dest = shared.maxstring;
        return C_OK;
    case '-':
        if (c[1] != '\0') return C_ERR;
        *ex = 1;
        *dest = shared.minstring;
        return C_OK;
    case '(':
        *ex = 1;
        *dest = sdsnewlen(c+1,sdslen(c)-1);
        return C_OK;
    case '[':
        *ex = 0;
        *dest = sdsnewlen(c+1,sdslen(c)-1);
        return C_OK;
    default:
        return C_ERR;
    }
}",573.0,598.0,1.0,33.0,26.0,32,9,19,5,0,4,4,6,0,4,,0,4,6,3,3,int
6898,451751,sdscmplex,1,sdscmplex,"int sdscmplex (sds,sds)",t_zset.c,"int sdscmplex(sds a, sds b) {
    if (a == b) return 0;
    if (a == shared.minstring || b == shared.maxstring) return -1;
    if (a == shared.maxstring || b == shared.minstring) return 1;
    return sdscmp(a,b);
}",633.0,638.0,1.0,1.0,6.0,12,4,12,3,2,1,4,4,0,1,,0,0,4,2,2,int
6899,451849,zslIsInLexRange,1,zslIsInLexRange,"int zslIsInLexRange (zskiplist*,zlexrangespec*)",t_zset.c,"int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;

    /* Test for ranges that will always be empty. */
    int cmp = sdscmplex(range->min,range->max);
    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
        return 0;
    x = zsl->tail;
    if (x == NULL || !zslLexValueGteMin(x->ele,range))
        return 0;
    x = zsl->header->level[0].forward;
    if (x == NULL || !zslLexValueLteMax(x->ele,range))
        return 0;
    return 1;
}",653.0,667.0,1.0,1.0,15.0,25,9,19,5,0,11,4,4,6,3,,0,11,4,2,2,int
6900,452127,zzlStrtod,1,zzlStrtod,"double zzlStrtod (unsigned char*,unsigned int)",t_zset.c,"double zzlStrtod(unsigned char *vstr, unsigned int vlen) {
    char buf[128];
    if (vlen > sizeof(buf) - 1)
        vlen = sizeof(buf) - 1;
    memcpy(buf,vstr,vlen);
    buf[vlen] = '\0';
    return strtod(buf,NULL);
 }",724.0,731.0,1.0,2.0,8.0,8,5,11,4,1,0,2,2,0,0,,0,0,4,2,2,double
6901,452255,zzlCompareElements,1,zzlCompareElements,"int zzlCompareElements (unsigned char*,unsigned char*,unsigned int)",t_zset.c,"int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    unsigned char vbuf[32];
    int minlen, cmp;

    vstr = lpGetValue(eptr,&vlen,&vlong);
    if (vstr == NULL) {
        /* Store string representation of long long in buf. */
        vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
        vstr = vbuf;
    }

    minlen = (vlen < clen) ? vlen : clen;
    cmp = memcmp(vstr,cstr,minlen);
    if (cmp == 0) return vlen-clen;
    return cmp;
}",768.0,786.0,1.0,1.0,19.0,14,8,25,10,0,2,3,3,0,2,,0,2,6,3,3,int
6902,452318,zzlLength,1,zzlLength,unsigned int zzlLength (unsigned char*),t_zset.c,"unsigned int zzlLength(unsigned char *zl) {
    return lpLength(zl)/2;
}",788.0,790.0,1.0,1.0,3.0,1,1,1,1,1,1,1,1,0,1,,0,0,2,1,1,unsigned int
6903,452480,zzlIsInRange,1,zzlIsInRange,"int zzlIsInRange (unsigned char*,zrangespec*)",t_zset.c,"int zzlIsInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *p;
    double score;

    /* Test for ranges that will always be empty. */
    if (range->min > range->max ||
            (range->min == range->max && (range->minex || range->maxex)))
        return 0;

    p = lpSeek(zl,-1); /* Last score. */
    if (p == NULL) return 0; /* Empty sorted set */
    score = zzlGetScore(p);
    if (!zslValueGteMin(score,range))
        return 0;

    p = lpSeek(zl,1); /* First score. */
    serverAssert(p != NULL);
    score = zzlGetScore(p);
    if (!zslValueLteMax(score,range))
        return 0;

    return 1;
}",832.0,854.0,1.0,4.0,23.0,24,13,22,5,0,13,5,5,8,7,,0,12,4,2,2,int
6904,452794,zzlIsInLexRange,1,zzlIsInLexRange,"int zzlIsInLexRange (unsigned char*,zlexrangespec*)",t_zset.c,"int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *p;

    /* Test for ranges that will always be empty. */
    int cmp = sdscmplex(range->min,range->max);
    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
        return 0;

    p = lpSeek(zl,-2); /* Last element. */
    if (p == NULL) return 0;
    if (!zzlLexValueGteMin(p,range))
        return 0;

    p = lpSeek(zl,0); /* First element. */
    serverAssert(p != NULL);
    if (!zzlLexValueLteMax(p,range))
        return 0;

    return 1;
}",933.0,952.0,1.0,4.0,20.0,21,13,19,5,0,10,5,5,4,6,,0,9,4,2,2,int
6905,453028,zzlFind,1,zzlFind,"unsigned char* zzlFind (unsigned char*,sds,double*)",t_zset.c,"unsigned char *zzlFind(unsigned char *lp, sds ele, double *score) {
    unsigned char *eptr, *sptr;

    if ((eptr = lpFirst(lp)) == NULL) return NULL;
    eptr = lpFind(lp, eptr, (unsigned char*)ele, sdslen(ele), 1);
    if (eptr) {
        sptr = lpNext(lp,eptr);
        serverAssert(sptr != NULL);

        /* Matching element, pull out score. */
        if (score != NULL) *score = zzlGetScore(sptr);
        return eptr;
    }

    return NULL;
}",1007.0,1022.0,1.0,8.0,16.0,13,8,21,6,0,6,4,5,1,6,,0,5,6,3,3,unsigned char*
6906,453096,zzlDelete,1,zzlDelete,"unsigned char* zzlDelete (unsigned char*,unsigned char*)",t_zset.c,"unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
    return lpDeleteRangeWithEntry(zl,&eptr,2);
}",1026.0,1028.0,1.0,1.0,3.0,1,1,2,2,0,1,1,1,0,1,,0,0,4,2,2,unsigned char*
6907,453108,zzlInsertAt,1,zzlInsertAt,"unsigned char* zzlInsertAt (unsigned char*,unsigned char*,sds,double)",t_zset.c,"unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
    unsigned char *sptr;
    char scorebuf[MAX_D2STRING_CHARS];
    int scorelen = 0;
    long long lscore;
    int score_is_long = double2ll(score, &lscore);
    if (!score_is_long)
        scorelen = d2string(scorebuf,sizeof(scorebuf),score);
    if (eptr == NULL) {
        zl = lpAppend(zl,(unsigned char*)ele,sdslen(ele));
        if (score_is_long)
            zl = lpAppendInteger(zl,lscore);
        else
            zl = lpAppend(zl,(unsigned char*)scorebuf,scorelen);
    } else {
        /* Insert member before the element 'eptr'. */
        zl = lpInsertString(zl,(unsigned char*)ele,sdslen(ele),eptr,LP_BEFORE,&sptr);

        /* Insert score after the member. */
        if (score_is_long)
            zl = lpInsertInteger(zl,lscore,sptr,LP_AFTER,NULL);
        else
            zl = lpInsertString(zl,(unsigned char*)scorebuf,scorelen,sptr,LP_AFTER,NULL);
    }
    return zl;
}",1030.0,1055.0,1.0,18.0,26.0,10,6,20,9,0,5,4,5,0,5,,0,5,8,4,4,unsigned char*
6908,453323,zzlDeleteRangeByScore,1,zzlDeleteRangeByScore,"unsigned char* zzlDeleteRangeByScore (unsigned char*,zrangespec*,long unsigned*)",t_zset.c,"unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {
    unsigned char *eptr, *sptr;
    double score;
    unsigned long num = 0;

    if (deleted != NULL) *deleted = 0;

    eptr = zzlFirstInRange(zl,range);
    if (eptr == NULL) return zl;

    /* When the tail of the listpack is deleted, eptr will be NULL. */
    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {
        score = zzlGetScore(sptr);
        if (zslValueLteMax(score,range)) {
            /* Delete both the element and the score. */
            zl = lpDeleteRangeWithEntry(zl,&eptr,2);
            num++;
        } else {
            /* No longer in range. */
            break;
        }
    }

    if (deleted != NULL) *deleted = num;
    return zl;
}",1092.0,1117.0,1.0,1.0,26.0,16,7,28,8,1,5,6,7,2,5,,0,5,6,3,3,unsigned char*
6909,453401,zzlDeleteRangeByLex,1,zzlDeleteRangeByLex,"unsigned char* zzlDeleteRangeByLex (unsigned char*,zlexrangespec*,long unsigned*)",t_zset.c,"unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {
    unsigned char *eptr, *sptr;
    unsigned long num = 0;

    if (deleted != NULL) *deleted = 0;

    eptr = zzlFirstInLexRange(zl,range);
    if (eptr == NULL) return zl;

    /* When the tail of the listpack is deleted, eptr will be NULL. */
    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {
        if (zzlLexValueLteMax(eptr,range)) {
            /* Delete both the element and the score. */
            zl = lpDeleteRangeWithEntry(zl,&eptr,2);
            num++;
        } else {
            /* No longer in range. */
            break;
        }
    }

    if (deleted != NULL) *deleted = num;
    return zl;
}",1119.0,1142.0,1.0,1.0,24.0,15,7,26,7,1,4,6,7,2,4,,0,4,6,3,3,unsigned char*
6910,453474,zzlDeleteRangeByRank,1,zzlDeleteRangeByRank,"unsigned char* zzlDeleteRangeByRank (unsigned char*,unsigned int,unsigned int,long unsigned*)",t_zset.c,"unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {
    unsigned int num = (end-start)+1;
    if (deleted) *deleted = num;
    zl = lpDeleteRange(zl,2*(start-1),2*num);
    return zl;
}",1146.0,1151.0,1.0,1.0,6.0,9,5,11,5,1,1,2,2,0,1,,0,1,8,4,4,unsigned char*
6911,453569,zsetTypeCreate,1,zsetTypeCreate,"robj zsetTypeCreate (size_t,size_t)",t_zset.c,"robj *zsetTypeCreate(size_t size_hint, size_t val_len_hint) {
    if (size_hint <= server.zset_max_listpack_entries &&
        val_len_hint <= server.zset_max_listpack_value)
    {
        return createZsetListpackObject();
    }

    robj *zobj = createZsetObject();
    zset *zs = zobj->ptr;
    dictExpand(zs->dict, size_hint);
    return zobj;
}",1176.0,1187.0,1.0,1.0,12.0,9,5,10,5,2,4,2,2,0,3,,0,2,4,2,2,robj
6912,453607,zsetTypeMaybeConvert,1,zsetTypeMaybeConvert,"void zsetTypeMaybeConvert (robj*,size_t)",t_zset.c,"void zsetTypeMaybeConvert(robj *zobj, size_t size_hint) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK &&
        size_hint > server.zset_max_listpack_entries)
    {
        zsetConvertAndExpand(zobj, OBJ_ENCODING_SKIPLIST, size_hint);
    }
}",1191.0,1197.0,1.0,26.0,7.0,5,5,5,3,0,1,2,2,0,1,,0,0,4,2,2,void
6913,454618,zsetRemoveFromSkiplist,1,zsetRemoveFromSkiplist,"int zsetRemoveFromSkiplist (zset*,sds)",t_zset.c,"static int zsetRemoveFromSkiplist(zset *zs, sds ele) {
    dictEntry *de;
    double score;

    de = dictUnlink(zs->dict,ele);
    if (de != NULL) {
        /* Get the score in order to delete from the skiplist later. */
        score = *(double*)dictGetVal(de);

        /* Delete from the hash table and later from the skiplist.
         * Note that the order is important: deleting from the skiplist
         * actually releases the SDS string representing the element,
         * which is shared between the skiplist and the hash table, so
         * we need to delete from the skiplist as the final step. */
        dictFreeUnlinkedEntry(zs->dict,de);

        /* Delete from skiplist. */
        int retval = zslDelete(zs->zsl,score,ele,NULL);
        serverAssert(retval);

        return 1;
    }

    return 0;
}",1498.0,1522.0,1.0,8.0,25.0,13,8,16,6,0,8,2,2,0,5,,0,6,4,2,2,int
6914,455181,zsetSdsFromListpackEntry,1,zsetSdsFromListpackEntry,sds zsetSdsFromListpackEntry (listpackEntry*),t_zset.c,"sds zsetSdsFromListpackEntry(listpackEntry *e) {
    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);
}",1667.0,1669.0,1.0,1.0,3.0,5,2,4,1,0,6,1,1,0,2,,0,4,2,1,1,sds
6915,455202,zsetReplyFromListpackEntry,1,zsetReplyFromListpackEntry,"void zsetReplyFromListpackEntry (client*,listpackEntry*)",t_zset.c,"void zsetReplyFromListpackEntry(client *c, listpackEntry *e) {
    if (e->sval)
        addReplyBulkCBuffer(c, e->sval, e->slen);
    else
        addReplyBulkLongLong(c, e->lval);
}",1672.0,1677.0,1.0,1.0,6.0,3,1,4,2,0,4,2,2,1,1,,0,3,4,2,2,void
6916,455228,zsetTypeRandomElement,1,zsetTypeRandomElement,"void zsetTypeRandomElement (robj*,long unsigned,listpackEntry*,double*)",t_zset.c,"void zsetTypeRandomElement(robj *zsetobj, unsigned long zsetsize, listpackEntry *key, double *score) {
    if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zsetobj->ptr;
        dictEntry *de = dictGetFairRandomKey(zs->dict);
        sds s = dictGetKey(de);
        key->sval = (unsigned char*)s;
        key->slen = sdslen(s);
        if (score)
            *score = *(double*)dictGetVal(de);
    } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {
        listpackEntry val;
        lpRandomPair(zsetobj->ptr, zsetsize, key, &val);
        if (score) {
            if (val.sval) {
                *score = zzlStrtod(val.sval,val.slen);
            } else {
                *score = (double)val.lval;
            }
        }
    } else {
        serverPanic(""Unknown zset encoding"");
    }
}",1684.0,1706.0,1.0,29.0,23.0,16,5,14,6,0,7,3,4,0,4,,0,7,8,4,4,void
6917,455345,zaddGenericCommand,1,zaddGenericCommand,"void zaddGenericCommand (client*,int)",t_zset.c,"void zaddGenericCommand(client *c, int flags) {
    static char *nanerr = ""resulting score is not a number (NaN)"";
    robj *key = c->argv[1];
    robj *zobj;
    sds ele;
    double score = 0, *scores = NULL;
    int j, elements, ch = 0;
    int scoreidx = 0;
    /* The following vars are used in order to track what the command actually
     * did during the execution, to reply to the client and to trigger the
     * notification of keyspace change. */
    int added = 0;      /* Number of new elements added. */
    int updated = 0;    /* Number of elements with updated score. */
    int processed = 0;  /* Number of elements processed, may remain zero with
                           options like XX. */

    /* Parse options. At the end 'scoreidx' is set to the argument position
     * of the score of the first score-element pair. */
    scoreidx = 2;
    while(scoreidx < c->argc) {
        char *opt = c->argv[scoreidx]->ptr;
        if (!strcasecmp(opt,""nx"")) flags |= ZADD_IN_NX;
  ...",1713.0,1835.0,1.0,44.0,123.0,114,23,124,28,0,28,24,28,4,17,,0,18,4,2,2,void
6918,456036,zremrangeGenericCommand,1,zremrangeGenericCommand,"void zremrangeGenericCommand (client*,zrange_type)",t_zset.c,"void zremrangeGenericCommand(client *c, zrange_type rangetype) {
    robj *key = c->argv[1];
    robj *zobj;
    int keyremoved = 0;
    unsigned long deleted = 0;
    zrangespec range;
    zlexrangespec lexrange;
    long start, end, llen;
    char *notify_type = NULL;

    /* Step 1: Parse the range. */
    if (rangetype == ZRANGE_RANK) {
        notify_type = ""zremrangebyrank"";
        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||
            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))
            return;
    } else if (rangetype == ZRANGE_SCORE) {
        notify_type = ""zremrangebyscore"";
        if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
            addReplyError(c,""min or max is not a float"");
            return;
        }
    } else if (rangetype == ZRANGE_LEX) {
        notify_type = ""zremrangebylex"";
        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {
            addReplyError(c,""min or max not valid...",1880.0,1985.0,1.0,67.0,106.0,71,15,88,19,0,23,21,25,7,16,,0,16,4,2,2,void
6919,456600,zuiInitIterator,1,zuiInitIterator,void zuiInitIterator (zsetopsrc*),t_zset.c,"void zuiInitIterator(zsetopsrc *op) {
    if (op->subject == NULL)
        return;

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            it->is.is = op->subject->ptr;
            it->is.ii = 0;
        } else if (op->encoding == OBJ_ENCODING_HT) {
            it->ht.dict = op->subject->ptr;
            it->ht.di = dictGetIterator(op->subject->ptr);
            it->ht.de = dictNext(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            it->lp.lp = op->subject->ptr;
            it->lp.p = lpFirst(it->lp.lp);
        } else {
            serverPanic(""Unknown set encoding"");
        }
    } else if (op->type == OBJ_ZSET) {
        /* Sorted sets are traversed in reverse order to optimize for
         * the insertion of the elements in a new list as in
         * ZDIFF/ZINTER/ZUNION */
        iterzset *it = &op->iter.zset;
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
      ...",2062.0,2102.0,1.0,20.0,41.0,18,5,9,3,4,5,4,5,3,0,,0,5,2,1,1,void
6920,456905,zuiClearIterator,1,zuiClearIterator,void zuiClearIterator (zsetopsrc*),t_zset.c,"void zuiClearIterator(zsetopsrc *op) {
    if (op->subject == NULL)
        return;

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            UNUSED(it); /* skip */
        } else if (op->encoding == OBJ_ENCODING_HT) {
            dictReleaseIterator(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            UNUSED(it);
        } else {
            serverPanic(""Unknown set encoding"");
        }
    } else if (op->type == OBJ_ZSET) {
        iterzset *it = &op->iter.zset;
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            UNUSED(it); /* skip */
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            UNUSED(it); /* skip */
        } else {
            serverPanic(""Unknown sorted set encoding"");
        }
    } else {
        serverPanic(""Unsupported type"");
    }
}",2104.0,2131.0,1.0,20.0,28.0,11,6,8,3,6,4,4,5,3,0,,0,4,2,1,1,void
6921,457067,zuiDiscardDirtyValue,1,zuiDiscardDirtyValue,void zuiDiscardDirtyValue (zsetopval*),t_zset.c,"void zuiDiscardDirtyValue(zsetopval *val) {
    if (val->flags & OPVAL_DIRTY_SDS) {
        sdsfree(val->ele);
        val->ele = NULL;
        val->flags &= ~OPVAL_DIRTY_SDS;
    }
}",2133.0,2139.0,1.0,21.0,7.0,7,4,5,2,2,5,2,2,1,1,,0,4,2,1,1,void
6922,457098,zuiLength,1,zuiLength,unsigned long zuiLength (zsetopsrc*),t_zset.c,"unsigned long zuiLength(zsetopsrc *op) {
    if (op->subject == NULL)
        return 0;

    if (op->type == OBJ_SET) {
        return setTypeSize(op->subject);
    } else if (op->type == OBJ_ZSET) {
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            return zzlLength(op->subject->ptr);
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            zset *zs = op->subject->ptr;
            return zs->zsl->length;
        } else {
            serverPanic(""Unknown sorted set encoding"");
        }
    } else {
        serverPanic(""Unsupported type"");
    }
}",2141.0,2159.0,1.0,20.0,19.0,5,2,4,2,7,4,3,3,2,1,,0,3,2,1,1,unsigned long
6923,457198,zuiNext,1,zuiNext,"int zuiNext (zsetopsrc*,zsetopval*)",t_zset.c,"int zuiNext(zsetopsrc *op, zsetopval *val) {
    if (op->subject == NULL)
        return 0;

    zuiDiscardDirtyValue(val);

    memset(val,0,sizeof(zsetopval));

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            int64_t ell;

            if (!intsetGet(it->is.is,it->is.ii,&ell))
                return 0;
            val->ell = ell;
            val->score = 1.0;

            /* Move to next element. */
            it->is.ii++;
        } else if (op->encoding == OBJ_ENCODING_HT) {
            if (it->ht.de == NULL)
                return 0;
            val->ele = dictGetKey(it->ht.de);
            val->score = 1.0;

            /* Move to next element. */
            it->ht.de = dictNext(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            if (it->lp.p == NULL)
                return 0;
            val->estr = lpGetValue(it->lp.p, &val->elen, &val->ell);
            val->sc...",2164.0,2229.0,1.0,20.0,66.0,24,8,16,6,5,9,5,8,4,2,,0,8,4,2,2,int
6924,457576,zuiLongLongFromValue,1,zuiLongLongFromValue,int zuiLongLongFromValue (zsetopval*),t_zset.c,"int zuiLongLongFromValue(zsetopval *val) {
    if (!(val->flags & OPVAL_DIRTY_LL)) {
        val->flags |= OPVAL_DIRTY_LL;

        if (val->ele != NULL) {
            if (string2ll(val->ele,sdslen(val->ele),&val->ell))
                val->flags |= OPVAL_VALID_LL;
        } else if (val->estr != NULL) {
            if (string2ll((char*)val->estr,val->elen,&val->ell))
                val->flags |= OPVAL_VALID_LL;
        } else {
            /* The long long was already set, flag as valid. */
            val->flags |= OPVAL_VALID_LL;
        }
    }
    return val->flags & OPVAL_VALID_LL;
}",2231.0,2247.0,1.0,23.0,17.0,13,5,9,2,0,10,4,7,7,2,,0,10,2,1,1,int
6925,457674,zuiSdsFromValue,1,zuiSdsFromValue,sds zuiSdsFromValue (zsetopval*),t_zset.c,"sds zuiSdsFromValue(zsetopval *val) {
    if (val->ele == NULL) {
        if (val->estr != NULL) {
            val->ele = sdsnewlen((char*)val->estr,val->elen);
        } else {
            val->ele = sdsfromlonglong(val->ell);
        }
        val->flags |= OPVAL_DIRTY_SDS;
    }
    return val->ele;
}",2249.0,2259.0,1.0,22.0,11.0,11,5,9,2,0,8,3,4,2,1,,0,8,2,1,1,sds
6926,457727,zuiNewSdsFromValue,1,zuiNewSdsFromValue,sds zuiNewSdsFromValue (zsetopval*),t_zset.c,"sds zuiNewSdsFromValue(zsetopval *val) {
    if (val->flags & OPVAL_DIRTY_SDS) {
        /* We have already one to return! */
        sds ele = val->ele;
        val->flags &= ~OPVAL_DIRTY_SDS;
        val->ele = NULL;
        return ele;
    } else if (val->ele) {
        return sdsdup(val->ele);
    } else if (val->estr) {
        return sdsnewlen((char*)val->estr,val->elen);
    } else {
        return sdsfromlonglong(val->ell);
    }
}",2263.0,2277.0,1.0,21.0,15.0,8,4,7,3,4,4,2,2,1,0,,0,4,2,1,1,sds
6927,457798,zuiBufferFromValue,1,zuiBufferFromValue,int zuiBufferFromValue (zsetopval*),t_zset.c,"int zuiBufferFromValue(zsetopval *val) {
    if (val->estr == NULL) {
        if (val->ele != NULL) {
            val->elen = sdslen(val->ele);
            val->estr = (unsigned char*)val->ele;
        } else {
            val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
            val->estr = val->_buf;
        }
    }
    return 1;
}",2279.0,2290.0,1.0,1.0,12.0,11,5,8,2,0,7,3,4,2,1,,0,7,2,1,1,int
6928,457862,zuiFind,1,zuiFind,"int zuiFind (zsetopsrc*,zsetopval*,double*)",t_zset.c,"int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
    if (op->subject == NULL)
        return 0;

    if (op->type == OBJ_SET) {
        char *str = val->ele ? val->ele : (char *)val->estr;
        size_t len = val->ele ? sdslen(val->ele) : val->elen;
        if (setTypeIsMemberAux(op->subject, str, len, val->ell, val->ele != NULL)) {
            *score = 1.0;
            return 1;
        } else {
            return 0;
        }
    } else if (op->type == OBJ_ZSET) {
        zuiSdsFromValue(val);

        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
                /* Score is already set by zzlFind. */
                return 1;
            } else {
                return 0;
            }
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            zset *zs = op->subject->ptr;
            dictEntry *de;
            if ((de = dictFind(zs->dict,val->ele)) != NULL) {
                *score = *(dou...",2294.0,2332.0,1.0,20.0,39.0,21,7,18,6,1,13,4,5,6,2,,0,13,6,3,3,int
6929,458051,zuiCompareByCardinality,1,zuiCompareByCardinality,"int zuiCompareByCardinality (void*,void*)",t_zset.c,"int zuiCompareByCardinality(const void *s1, const void *s2) {
    unsigned long first = zuiLength((zsetopsrc*)s1);
    unsigned long second = zuiLength((zsetopsrc*)s2);
    if (first > second) return 1;
    if (first < second) return -1;
    return 0;
}",2334.0,2340.0,1.0,1.0,7.0,7,5,8,4,1,2,3,3,0,2,,0,2,4,2,2,int
6930,458088,zuiCompareByRevCardinality,1,zuiCompareByRevCardinality,"int zuiCompareByRevCardinality (void*,void*)",t_zset.c,"static int zuiCompareByRevCardinality(const void *s1, const void *s2) {
    return zuiCompareByCardinality(s1, s2) * -1;
}",2342.0,2344.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,1,,0,0,4,2,2,int
6931,458101,zunionInterAggregate,1,zunionInterAggregate,"void zunionInterAggregate (double*,double,int)",t_zset.c,"inline static void zunionInterAggregate(double *target, double val, int aggregate) {
    if (aggregate == REDIS_AGGR_SUM) {
        *target = *target + val;
        /* The result of adding two doubles is NaN when one variable
         * is +inf and the other is -inf. When these numbers are added,
         * we maintain the convention of the result being 0.0. */
        if (isnan(*target)) *target = 0.0;
    } else if (aggregate == REDIS_AGGR_MIN) {
        *target = val < *target ? val : *target;
    } else if (aggregate == REDIS_AGGR_MAX) {
        *target = val > *target ? val : *target;
    } else {
        /* safety net */
        serverPanic(""Unknown ZUNION/INTER aggregate type"");
    }
}",2351.0,2366.0,1.0,21.0,16.0,8,4,6,3,1,0,3,4,0,0,,0,0,6,3,3,void
6932,458181,zsetDictGetMaxElementLength,1,zsetDictGetMaxElementLength,"size_t zsetDictGetMaxElementLength (dict*,size_t*)",t_zset.c,"static size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {
    dictIterator *di;
    dictEntry *de;
    size_t maxelelen = 0;

    di = dictGetIterator(d);

    while((de = dictNext(di)) != NULL) {
        sds ele = dictGetKey(de);
        if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);
        if (totallen)
            (*totallen) += sdslen(ele);
    }

    dictReleaseIterator(di);

    return maxelelen;
}",2368.0,2385.0,1.0,1.0,18.0,9,5,17,7,1,7,4,6,2,7,,0,5,4,2,2,size_t
6933,458232,zdiffAlgorithm1,1,zdiffAlgorithm1,"void zdiffAlgorithm1 (zsetopsrc*,long,zset*,size_t*,size_t*)",t_zset.c,"static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* DIFF Algorithm 1:
     *
     * We perform the diff by iterating all the elements of the first set,
     * and only adding it to the target set if the element does not exist
     * into all the other sets.
     *
     * This way we perform at max N*M operations, where N is the size of
     * the first set, and M the number of sets.
     *
     * There is also a O(K*log(K)) cost for adding the resulting elements
     * to the target set, where K is the final size of the target set.
     *
     * The final complexity of this algorithm is O(N*M + K*log(K)). */
    int j;
    zsetopval zval;
    zskiplistNode *znode;
    sds tmp;

    /* With algorithm 1 it is better to order the sets to subtract
     * by decreasing size, so that we are more likely to find
     * duplicated elements ASAP. */
    qsort(src+1,setnum-1,sizeof(zsetopsrc),zuiCompareByRevCardinality);

    m...",2387.0,2439.0,1.0,1.0,53.0,41,15,37,12,1,15,7,12,3,10,,0,11,10,5,5,void
6934,458368,zdiffAlgorithm2,1,zdiffAlgorithm2,"void zdiffAlgorithm2 (zsetopsrc*,long,zset*,size_t*,size_t*)",t_zset.c,"static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* DIFF Algorithm 2:
     *
     * Add all the elements of the first set to the auxiliary set.
     * Then remove all the elements of all the next sets from it.
     *

     * This is O(L + (N-K)log(N)) where L is the sum of all the elements in every
     * set, N is the size of the first set, and K is the size of the result set.
     *
     * Note that from the (L-N) dict searches, (N-K) got to the zsetRemoveFromSkiplist
     * which costs log(N)
     *
     * There is also a O(K) cost at the end for finding the largest element
     * size, but this doesn't change the algorithm complexity since K < L, and
     * O(2L) is the same as O(L). */
    int j;
    int cardinality = 0;
    zsetopval zval;
    zskiplistNode *znode;
    sds tmp;

    for (j = 0; j < setnum; j++) {
        if (zuiLength(&src[j]) == 0) continue;

        memset(&zval, 0, sizeof(zval));
        zui...",2442.0,2497.0,1.0,1.0,56.0,32,10,33,10,0,17,11,15,4,10,,0,13,10,5,5,void
6935,458506,zsetChooseDiffAlgorithm,1,zsetChooseDiffAlgorithm,"int zsetChooseDiffAlgorithm (zsetopsrc*,long)",t_zset.c,"static int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {
    int j;

    /* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M + K*log(K)) where N is the size of the
     * first set, M the total number of sets, and K is the size of the
     * result set.
     *
     * Algorithm 2 is O(L + (N-K)log(N)) where L is the total number of elements
     * in all the sets, N is the size of the first set, and K is the size of the
     * result set.
     *
     * We compute what is the best bet with the current input here. */
    long long algo_one_work = 0;
    long long algo_two_work = 0;

    for (j = 0; j < setnum; j++) {
        /* If any other set is equal to the first set, there is nothing to be
         * done, since we would remove all elements anyway. */
        if (j > 0 && src[0].subject == src[j].subject) {
            return 0;
        }

        algo_one_work += zuiLength(&src[0]);
        algo_two_work += zuiLength(&src[j]);
    }

    /* Algorithm ...",2499.0,2531.0,1.0,1.0,33.0,20,12,17,5,1,2,3,4,0,2,,0,0,4,2,2,int
6936,458575,zdiff,1,zdiff,"void zdiff (zsetopsrc*,long,zset*,size_t*,size_t*)",t_zset.c,"static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* Skip everything if the smallest input is empty. */
    if (zuiLength(&src[0]) > 0) {
        int diff_algo = zsetChooseDiffAlgorithm(src, setnum);
        if (diff_algo == 1) {
            zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);
        } else if (diff_algo == 2) {
            zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);
        } else if (diff_algo != 0) {
            serverPanic(""Unknown algorithm"");
        }
    }
}",2533.0,2545.0,1.0,12.0,13.0,5,5,10,6,0,3,3,4,1,3,,0,2,10,5,5,void
6937,458649,zunionInterDiffGenericCommand,1,zunionInterDiffGenericCommand,"void zunionInterDiffGenericCommand (client*,robj*,int,int,int)",t_zset.c,"void zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op,
                                   int cardinality_only) {
    int i, j;
    long setnum;
    int aggregate = REDIS_AGGR_SUM;
    zsetopsrc *src;
    zsetopval zval;
    sds tmp;
    size_t maxelelen = 0, totelelen = 0;
    robj *dstobj = NULL;
    zset *dstzset = NULL;
    zskiplistNode *znode;
    int withscores = 0;
    unsigned long cardinality = 0;
    long limit = 0; /* Stop searching after reaching the limit. 0 means unlimited. */

    /* expect setnum input keys to be given */
    if ((getLongFromObjectOrReply(c, c->argv[numkeysIndex], &setnum, NULL) != C_OK))
        return;

    if (setnum < 1) {
        addReplyErrorFormat(c,
            ""at least 1 input key is needed for '%s' command"", c->cmd->fullname);
        return;
    }

    /* test if the expected number of keys would overflow */
    if (setnum > (c->argc-(numkeysIndex+1))) {
        addReplyErrorObject(c,shared.syntaxerr);
    ...",2569.0,2860.0,1.0,20.0,292.0,136,22,136,26,0,39,25,58,10,23,,0,24,10,5,5,void
6938,459913,zrangeResultBeginFunction,1,zrangeResultBeginFunction,"void zrangeResultBeginFunction (zrange_result_handler*,long)",t_zset.c,"typedef void (*zrangeResultBeginFunction)(zrange_result_handler *c, long length);",2910.0,2910.0,14.0,80.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6939,459919,zrangeResultFinalizeFunction,1,zrangeResultFinalizeFunction,"void zrangeResultFinalizeFunction (zrange_result_handler*,size_t)",t_zset.c,"typedef void (*zrangeResultFinalizeFunction)(
    zrange_result_handler *c, size_t result_count);",2911.0,2912.0,14.0,50.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,4,2,2,void
6940,459925,zrangeResultEmitCBufferFunction,1,zrangeResultEmitCBufferFunction,"void zrangeResultEmitCBufferFunction (zrange_result_handler*,void*,size_t,double)",t_zset.c,"typedef void (*zrangeResultEmitCBufferFunction)(
    zrange_result_handler *c, const void *p, size_t len, double score);",2913.0,2914.0,14.0,70.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,8,4,4,void
6941,459933,zrangeResultEmitLongLongFunction,1,zrangeResultEmitLongLongFunction,"void zrangeResultEmitLongLongFunction (zrange_result_handler*,long long,double)",t_zset.c,"typedef void (*zrangeResultEmitLongLongFunction)(
    zrange_result_handler *c, long long ll, double score);",2915.0,2916.0,14.0,57.0,2.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,void
6942,459940,zrangeGenericCommand,1,zrangeGenericCommand,"void zrangeGenericCommand (zrange_result_handler*,int,int,zrange_type,zrange_direction)",t_zset.c,"void zrangeGenericCommand(zrange_result_handler *handler, int argc_start, int store,
                          zrange_type rangetype, zrange_direction direction)
{
    client *c = handler->client;
    robj *key = c->argv[argc_start];
    robj *zobj;
    zrangespec range;
    zlexrangespec lexrange;
    int minidx = argc_start + 1;
    int maxidx = argc_start + 2;

    /* Options common to all */
    long opt_start = 0;
    long opt_end = 0;
    int opt_withscores = 0;
    long opt_offset = 0;
    long opt_limit = -1;

    /* Step 1: Skip the <src> <min> <max> args and parse remaining optional arguments. */
    for (int j=argc_start + 3; j < c->argc; j++) {
        int leftargs = c->argc-j-1;
        if (!store && !strcasecmp(c->argv[j]->ptr,""withscores"")) {
            opt_withscores = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""limit"") && leftargs >= 2) {
            if ((getLongFromObjectOrReply(c, c->argv[j+1], &opt_offset, NULL) != C_OK) ||
                (getLongFromObj...",3617.0,3763.0,1.0,81.0,147.0,0,0,0,0,0,0,1,1,0,0,,0,0,10,5,5,void
6943,459961,zrangeResultBeginClient,1,zrangeResultBeginClient,"void zrangeResultBeginClient (zrange_result_handler*,long)",t_zset.c,"static void zrangeResultBeginClient(zrange_result_handler *handler, long length) {
    if (length > 0) {
        /* In case of WITHSCORES, respond with a single array in RESP2, and
        * nested arrays in RESP3. We can't use a map response type since the
        * client library needs to know to respect the order. */
        if (handler->withscores && (handler->client->resp == 2)) {
            length *= 2;
        }
        addReplyArrayLen(handler->client, length);
        handler->userdata = NULL;
        return;
    }
    handler->userdata = addReplyDeferredLen(handler->client);
}",2942.0,2955.0,1.0,1.0,14.0,13,6,10,3,0,8,3,4,2,2,,0,7,4,2,2,void
6944,460007,zrangeResultEmitCBufferToClient,1,zrangeResultEmitCBufferToClient,"void zrangeResultEmitCBufferToClient (zrange_result_handler*,void*,size_t,double)",t_zset.c,"static void zrangeResultEmitCBufferToClient(zrange_result_handler *handler,
    const void *value, size_t value_length_in_bytes, double score)
{
    if (handler->should_emit_array_length) {
        addReplyArrayLen(handler->client, 2);
    }

    addReplyBulkCBuffer(handler->client, value, value_length_in_bytes);

    if (handler->withscores) {
        addReplyDouble(handler->client, score);
    }
}",2957.0,2969.0,1.0,1.0,13.0,5,1,8,4,0,8,3,3,2,3,,0,5,8,4,4,void
6945,460041,zrangeResultEmitLongLongToClient,1,zrangeResultEmitLongLongToClient,"void zrangeResultEmitLongLongToClient (zrange_result_handler*,long long,double)",t_zset.c,"static void zrangeResultEmitLongLongToClient(zrange_result_handler *handler,
    long long value, double score)
{
    if (handler->should_emit_array_length) {
        addReplyArrayLen(handler->client, 2);
    }

    addReplyBulkLongLong(handler->client, value);

    if (handler->withscores) {
        addReplyDouble(handler->client, score);
    }
}",2971.0,2983.0,1.0,1.0,13.0,5,1,7,3,0,8,3,3,2,3,,0,5,6,3,3,void
6946,460073,zrangeResultFinalizeClient,1,zrangeResultFinalizeClient,"void zrangeResultFinalizeClient (zrange_result_handler*,size_t)",t_zset.c,"static void zrangeResultFinalizeClient(zrange_result_handler *handler,
    size_t result_count)
{
    /* If the reply size was know at start there's nothing left to do */
    if (!handler->userdata)
        return;
    /* In case of WITHSCORES, respond with a single array in RESP2, and
     * nested arrays in RESP3. We can't use a map response type since the
     * client library needs to know to respect the order. */
    if (handler->withscores && (handler->client->resp == 2)) {
        result_count *= 2;
    }

    setDeferredArrayLen(handler->client, handler->userdata, result_count);
}",2985.0,2999.0,1.0,1.0,15.0,10,5,7,2,0,6,3,3,3,1,,0,5,4,2,2,void
6947,460110,zrangeResultBeginStore,1,zrangeResultBeginStore,"void zrangeResultBeginStore (zrange_result_handler*,long)",t_zset.c,"static void zrangeResultBeginStore(zrange_result_handler *handler, long length)
{
    handler->dstobj = zsetTypeCreate(length, 0);
}",3002.0,3005.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,1,,0,2,4,2,2,void
6948,460123,zrangeResultEmitCBufferForStore,1,zrangeResultEmitCBufferForStore,"void zrangeResultEmitCBufferForStore (zrange_result_handler*,void*,size_t,double)",t_zset.c,"static void zrangeResultEmitCBufferForStore(zrange_result_handler *handler,
    const void *value, size_t value_length_in_bytes, double score)
{
    double newscore;
    int retflags = 0;
    sds ele = sdsnewlen(value, value_length_in_bytes);
    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);
    sdsfree(ele);
    serverAssert(retval);
}",3007.0,3016.0,1.0,54.0,10.0,10,7,13,8,0,5,1,1,0,4,,0,3,8,4,4,void
6949,460175,zrangeResultEmitLongLongForStore,1,zrangeResultEmitLongLongForStore,"void zrangeResultEmitLongLongForStore (zrange_result_handler*,long long,double)",t_zset.c,"static void zrangeResultEmitLongLongForStore(zrange_result_handler *handler,
    long long value, double score)
{
    double newscore;
    int retflags = 0;
    sds ele = sdsfromlonglong(value);
    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);
    sdsfree(ele);
    serverAssert(retval);
}",3018.0,3027.0,1.0,54.0,10.0,10,7,12,7,0,5,1,1,0,4,,0,3,6,3,3,void
6950,460225,zrangeResultFinalizeStore,1,zrangeResultFinalizeStore,"void zrangeResultFinalizeStore (zrange_result_handler*,size_t)",t_zset.c,"static void zrangeResultFinalizeStore(zrange_result_handler *handler, size_t result_count)
{
    if (result_count) {
        setKey(handler->client, handler->client->db, handler->dstkey, handler->dstobj, 0);
        addReplyLongLong(handler->client, result_count);
        notifyKeyspaceEvent(NOTIFY_ZSET, ""zrangestore"", handler->dstkey, handler->client->db->id);
        server.dirty++;
    } else {
        addReply(handler->client, shared.czero);
        if (dbDelete(handler->client->db, handler->dstkey)) {
            signalModifiedKey(handler->client, handler->client->db, handler->dstkey);
            notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", handler->dstkey, handler->client->db->id);
            server.dirty++;
        }
    }
    decrRefCount(handler->dstobj);
}",3029.0,3045.0,1.0,28.0,17.0,14,4,11,3,0,12,2,2,0,4,,0,8,4,2,2,void
6951,460333,zrangeResultHandlerInit,1,zrangeResultHandlerInit,"void zrangeResultHandlerInit (zrange_result_handler*,client*,zrange_consumer_type)",t_zset.c,"static void zrangeResultHandlerInit(zrange_result_handler *handler,
    client *client, zrange_consumer_type type)
{
    memset(handler, 0, sizeof(*handler));

    handler->client = client;

    switch (type) {
    case ZRANGE_CONSUMER_TYPE_CLIENT:
        handler->beginResultEmission = zrangeResultBeginClient;
        handler->finalizeResultEmission = zrangeResultFinalizeClient;
        handler->emitResultFromCBuffer = zrangeResultEmitCBufferToClient;
        handler->emitResultFromLongLong = zrangeResultEmitLongLongToClient;
        break;

    case ZRANGE_CONSUMER_TYPE_INTERNAL:
        handler->beginResultEmission = zrangeResultBeginStore;
        handler->finalizeResultEmission = zrangeResultFinalizeStore;
        handler->emitResultFromCBuffer = zrangeResultEmitCBufferForStore;
        handler->emitResultFromLongLong = zrangeResultEmitLongLongForStore;
        break;
    }
}",3048.0,3070.0,1.0,1.0,23.0,20,4,15,5,0,9,4,2,0,0,,0,9,6,3,3,void
6952,460400,zrangeResultHandlerScoreEmissionEnable,1,zrangeResultHandlerScoreEmissionEnable,void zrangeResultHandlerScoreEmissionEnable (zrange_result_handler*),t_zset.c,"static void zrangeResultHandlerScoreEmissionEnable(zrange_result_handler *handler) {
    handler->withscores = 1;
    handler->should_emit_array_length = (handler->client->resp > 2);
}",3072.0,3075.0,1.0,1.0,4.0,7,3,3,1,0,3,1,1,0,0,,0,3,2,1,1,void
6953,460421,zrangeResultHandlerDestinationKeySet,1,zrangeResultHandlerDestinationKeySet,"void zrangeResultHandlerDestinationKeySet (zrange_result_handler*,robj*)",t_zset.c,"static void zrangeResultHandlerDestinationKeySet (zrange_result_handler *handler,
    robj *dstkey)
{
    handler->dstkey = dstkey;
}",3077.0,3081.0,1.0,1.0,5.0,2,2,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
6954,460432,genericZrangebyrankCommand,1,genericZrangebyrankCommand,"void genericZrangebyrankCommand (zrange_result_handler*,robj*,long,long,int,int)",t_zset.c,"void genericZrangebyrankCommand(zrange_result_handler *handler,
    robj *zobj, long start, long end, int withscores, int reverse) {

    client *c = handler->client;
    long llen;
    long rangelen;
    size_t result_cardinality;

    /* Sanitize indexes. */
    llen = zsetLength(zobj);
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;


    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        handler->beginResultEmission(handler, 0);
        handler->finalizeResultEmission(handler, 0);
        return;
    }
    if (end >= llen) end = llen-1;
    rangelen = (end-start)+1;
    result_cardinality = rangelen;

    handler->beginResultEmission(handler, rangelen);
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char ...",3084.0,3173.0,1.0,26.0,90.0,56,19,80,18,0,14,12,20,0,8,,0,11,12,6,6,void
6955,460890,genericZrangebyscoreCommand,1,genericZrangebyscoreCommand,"void genericZrangebyscoreCommand (zrange_result_handler*,zrangespec*,robj*,long,long,int)",t_zset.c,"void genericZrangebyscoreCommand(zrange_result_handler *handler,
    zrangespec *range, robj *zobj, long offset, long limit, 
    int reverse) {
    unsigned long rangelen = 0;

    handler->beginResultEmission(handler, -1);

    /* For invalid offset, return directly. */
    if (offset > 0 && offset >= (long)zsetLength(zobj)) {
        handler->finalizeResultEmission(handler, 0);
        return;
    }

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        /* If reversed, get the last node in range as starting point. */
        if (reverse) {
            eptr = zzlLastInRange(zl,range);
        } else {
            eptr = zzlFirstInRange(zl,range);
        }

        /* Get score pointer for the first element. */
        if (eptr)
            sptr = lpNext(zl,eptr);

        /* If there is an offset, just traverse the numbe...",3199.0,3310.0,1.0,26.0,112.0,31,12,50,15,0,12,13,27,2,8,,0,10,12,6,6,void
6956,461752,genericZrangebylexCommand,1,genericZrangebylexCommand,"void genericZrangebylexCommand (zrange_result_handler*,zlexrangespec*,robj*,int,long,long,int)",t_zset.c,"void genericZrangebylexCommand(zrange_result_handler *handler,
    zlexrangespec *range, robj *zobj, int withscores, long offset, long limit,
    int reverse)
{
    unsigned long rangelen = 0;

    handler->beginResultEmission(handler, -1);

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        /* If reversed, get the last node in range as starting point. */
        if (reverse) {
            eptr = zzlLastInLexRange(zl,range);
        } else {
            eptr = zzlFirstInLexRange(zl,range);
        }

        /* Get score pointer for the first element. */
        if (eptr)
            sptr = lpNext(zl,eptr);

        /* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */
        while (eptr && offset--) {
            if (reverse) {
   ...",3483.0,3591.0,1.0,26.0,109.0,27,9,47,16,0,10,13,29,1,7,,0,8,14,7,7,void
6957,462785,zrankGenericCommand,1,zrankGenericCommand,"void zrankGenericCommand (client*,int)",t_zset.c,"void zrankGenericCommand(client *c, int reverse) {
    robj *key = c->argv[1];
    robj *ele = c->argv[2];
    robj *zobj;
    robj* reply;
    long rank;
    int opt_withscore = 0;
    double score;

    if (c->argc > 4) {
        addReplyErrorArity(c);
        return;
    }
    if (c->argc > 3) {
        if (!strcasecmp(c->argv[3]->ptr, ""withscore"")) {
            opt_withscore = 1;
        } else {
            addReplyErrorObject(c, shared.syntaxerr);
            return;
        }
    }
    reply = opt_withscore ? shared.nullarray[c->resp] : shared.null[c->resp];
    if ((zobj = lookupKeyReadOrReply(c, key, reply)) == NULL || checkType(c, zobj, OBJ_ZSET)) {
        return;
    }
    serverAssertWithInfo(c, ele, sdsEncodedObject(ele));
    rank = zsetRank(zobj, ele->ptr, reverse, opt_withscore ? &score : NULL);
    if (rank >= 0) {
        if (opt_withscore) {
            addReplyArrayLen(c, 2);
        }
        addReplyLongLong(c, rank);
        if (opt_withscore) {
            ...",3808.0,3850.0,1.0,83.0,43.0,41,14,44,11,0,15,8,11,5,8,,0,10,4,2,2,void
6958,463548,zpopMinMaxCommand,1,zpopMinMaxCommand,"void zpopMinMaxCommand (client*,int)",t_zset.c,"void zpopMinMaxCommand(client *c, int where) {
    if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    long count = -1; /* -1 for plain single pop. */
    if (c->argc == 3 && getPositiveLongFromObjectOrReply(c, c->argv[2], &count, NULL) != C_OK)
        return;

    /* Respond with a single (flat) array in RESP2 or if count is -1
     * (returning a single element). In RESP3, when count > 0 use nested array. */
    int use_nested_array = (c->resp > 2 && count != -1);

    genericZpopCommand(c, &c->argv[1], 1, where, 0, count, use_nested_array, 0, NULL);
}",4028.0,4043.0,1.0,89.0,16.0,21,10,18,6,0,8,3,3,4,3,,0,6,4,2,2,void
6959,463643,blockingGenericZpopCommand,1,blockingGenericZpopCommand,"void blockingGenericZpopCommand (client*,robj**,int,int,int,long,int,int)",t_zset.c,"void blockingGenericZpopCommand(client *c, robj **keys, int numkeys, int where,
                                int timeout_idx, long count, int use_nested_array, int reply_nil_when_empty) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;

    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;

    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db,key);
        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c,o,OBJ_ZSET)) return;

        long llen = zsetLength(o);
        /* Empty zset, move to next key. */
        if (llen == 0) continue;

        /* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */
        genericZpopCommand(c, &key, 1, where, 1, count, use_nested_array, reply_nil_when_empty, NULL);

        if (count == -1) {
            /* Replicate it as ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */
            rewriteCli...",4068.0,4119.0,1.0,68.0,52.0,23,12,40,16,1,11,10,12,4,8,,0,7,16,8,8,void
6960,463871,zrandmemberReplyWithListpack,1,zrandmemberReplyWithListpack,"void zrandmemberReplyWithListpack (client*,unsigned int,listpackEntry*,listpackEntry*)",t_zset.c,"static void zrandmemberReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    for (unsigned long i = 0; i < count; i++) {
        if (vals && c->resp > 2)
            addReplyArrayLen(c,2);
        if (keys[i].sval)
            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);
        else
            addReplyBulkLongLong(c, keys[i].lval);
        if (vals) {
            if (vals[i].sval) {
                addReplyDouble(c, zzlStrtod(vals[i].sval,vals[i].slen));
            } else
                addReplyDouble(c, vals[i].lval);
        }
    }
}",4131.0,4146.0,1.0,1.0,16.0,17,7,21,5,1,5,6,11,1,4,,0,2,8,4,4,void
6961,463963,zrandmemberWithCountCommand,1,zrandmemberWithCountCommand,"void zrandmemberWithCountCommand (client*,long,int)",t_zset.c,"void zrandmemberWithCountCommand(client *c, long l, int withscores) {
    unsigned long count, size;
    int uniq = 1;
    robj *zsetobj;

    if ((zsetobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptyarray))
        == NULL || checkType(c, zsetobj, OBJ_ZSET)) return;
    size = zsetLength(zsetobj);

    if(l >= 0) {
        count = (unsigned long) l;
    } else {
        count = -l;
        uniq = 0;
    }

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. This case is the only one that also needs to return the
     * elements in random order. */
    if (!uniq || count == 1) {
        if (withscores && c->resp == 2)
            addReplyArrayLen(c,...",4158.0,4360.0,1.0,41.0,203.0,113,24,141,21,0,67,26,53,12,52,,0,37,6,3,3,void
6962,464759,zmpopGenericCommand,1,zmpopGenericCommand,"void zmpopGenericCommand (client*,int,int)",t_zset.c,"void zmpopGenericCommand(client *c, int numkeys_idx, int is_block) {
    long j;
    long numkeys = 0;      /* Number of keys. */
    int where = 0;         /* ZSET_MIN or ZSET_MAX. */
    long count = -1;       /* Reply will consist of up to count elements, depending on the zset's length. */

    /* Parse the numkeys. */
    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;

    /* Parse the where. where_idx: the index of where in the c->argv. */
    long where_idx = numkeys_idx + numkeys + 1;
    if (where_idx >= c->argc) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    if (!strcasecmp(c->argv[where_idx]->ptr, ""MIN"")) {
        where = ZSET_MIN;
    } else if (!strcasecmp(c->argv[where_idx]->ptr, ""MAX"")) {
        where = ZSET_MAX;
    } else {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }

    /* ...",4399.0,4450.0,1.0,87.0,52.0,47,15,46,12,0,12,9,12,7,4,,0,10,6,3,3,void
6963,465022,checkBlockedClientTimeout,1,checkBlockedClientTimeout,"int checkBlockedClientTimeout (client*,mstime_t)",timeout.c,"int checkBlockedClientTimeout(client *c, mstime_t now) {
    if (c->flags & CLIENT_BLOCKED &&
        c->bstate.timeout != 0
        && c->bstate.timeout < now)
    {
        /* Handle blocking operation specific timeout. */
        unblockClientOnTimeout(c);
        return 1;
    } else {
        return 0;
    }
}",39.0,50.0,1.0,19.0,12.0,11,7,5,2,0,4,2,2,3,1,,0,3,4,2,2,int
6964,465176,encodeTimeoutKey,1,encodeTimeoutKey,"void encodeTimeoutKey (unsigned char*,uint64_t,client*)",timeout.c,"void encodeTimeoutKey(unsigned char *buf, uint64_t timeout, client *c) {
    timeout = htonu64(timeout);
    memcpy(buf,&timeout,sizeof(timeout));
    memcpy(buf+8,&c,sizeof(c));
    if (sizeof(c) == 4) memset(buf+12,0,4); /* Zero padding for 32bit target. */
}",97.0,102.0,1.0,14.0,6.0,9,5,11,3,0,1,2,2,0,1,,0,1,6,3,3,void
6965,465216,decodeTimeoutKey,1,decodeTimeoutKey,"void decodeTimeoutKey (unsigned char*,uint64_t*,client**)",timeout.c,"void decodeTimeoutKey(unsigned char *buf, uint64_t *toptr, client **cptr) {
    memcpy(toptr,buf,sizeof(*toptr));
    *toptr = ntohu64(*toptr);
    memcpy(cptr,buf+8,sizeof(*cptr));
}",106.0,110.0,1.0,13.0,5.0,9,4,9,3,0,1,1,1,0,1,,0,1,6,3,3,void
6966,465806,stringCheckPrefix,1,stringCheckPrefix,"int stringCheckPrefix (unsigned char*,size_t,unsigned char*,size_t)",tracking.c,"static int stringCheckPrefix(unsigned char *s1, size_t s1_len, unsigned char *s2, size_t s2_len) {
    size_t min_length = s1_len < s2_len ? s1_len : s2_len;
    return memcmp(s1,s2,min_length) == 0;   
}",102.0,105.0,1.0,1.0,4.0,4,4,8,5,0,0,1,1,0,0,,0,0,8,4,4,int
6967,465985,enableBcastTrackingForPrefix,1,enableBcastTrackingForPrefix,"void enableBcastTrackingForPrefix (client*,char*,size_t)",tracking.c,"void enableBcastTrackingForPrefix(client *c, char *prefix, size_t plen) {
    bcastState *bs = raxFind(PrefixTable,(unsigned char*)prefix,plen);
    /* If this is the first client subscribing to such prefix, create
     * the prefix in the table. */
    if (bs == raxNotFound) {
        bs = zmalloc(sizeof(*bs));
        bs->keys = raxNew();
        bs->clients = raxNew();
        raxInsert(PrefixTable,(unsigned char*)prefix,plen,bs,NULL);
    }
    if (raxTryInsert(bs->clients,(unsigned char*)&c,sizeof(c),NULL,NULL)) {
        if (c->client_tracking_prefixes == NULL)
            c->client_tracking_prefixes = raxNew();
        raxInsert(c->client_tracking_prefixes,
                  (unsigned char*)prefix,plen,NULL,NULL);
    }
}",155.0,171.0,1.0,1.0,17.0,21,7,28,7,0,16,4,5,3,8,,0,14,6,3,3,void
6968,466433,sendTrackingMessage,1,sendTrackingMessage,"void sendTrackingMessage (client*,char*,size_t,int)",tracking.c,"void sendTrackingMessage(client *c, char *keyname, size_t keylen, int proto) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;

    int using_redirection = 0;
    if (c->client_tracking_redirection) {
        client *redir = lookupClientByID(c->client_tracking_redirection);
        if (!redir) {
            c->flags |= CLIENT_TRACKING_BROKEN_REDIR;
            /* We need to signal to the original connection that we
             * are unable to send invalidation messages to the redirected
             * connection, because the client no longer exist. */
            if (c->resp > 2) {
                addReplyPushLen(c,2);
                addReplyBulkCBuffer(c,""tracking-redir-broken"",21);
                addReplyLongLong(c,c->client_tracking_redirection);
            }
            if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
            return;
        }
        if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
        c = redir;
    ...",268.0,324.0,1.0,16.0,57.0,40,7,34,7,0,21,9,15,3,8,,0,14,8,4,4,void
6969,466662,trackingRememberKeyToBroadcast,1,trackingRememberKeyToBroadcast,"void trackingRememberKeyToBroadcast (client*,char*,size_t)",tracking.c,"void trackingRememberKeyToBroadcast(client *c, char *keyname, size_t keylen) {
    raxIterator ri;
    raxStart(&ri,PrefixTable);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        if (ri.key_len > keylen) continue;
        if (ri.key_len != 0 && memcmp(ri.key,keyname,ri.key_len) != 0)
            continue;
        bcastState *bs = ri.data;
        /* We insert the client pointer as associated value in the radix
         * tree. This way we know who was the client that did the last
         * change to the key, and can avoid sending the notification in the
         * case the client is in NOLOOP mode. */
        raxInsert(bs->keys,(unsigned char*)keyname,keylen,c,NULL);
    }
    raxStop(&ri);
}",332.0,348.0,1.0,1.0,17.0,16,8,19,7,0,12,6,6,5,5,,0,8,6,3,3,void
6970,467035,freeTrackingRadixTreeCallback,1,freeTrackingRadixTreeCallback,void freeTrackingRadixTreeCallback (void*),tracking.c,"void freeTrackingRadixTreeCallback(void *rt) {
    raxFree(rt);
}",459.0,461.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,1,,0,0,2,1,1,void
6971,467262,trackingBuildBroadcastReply,1,trackingBuildBroadcastReply,"sds trackingBuildBroadcastReply (client*,rax*)",tracking.c,"sds trackingBuildBroadcastReply(client *c, rax *keys) {
    raxIterator ri;
    uint64_t count;

    if (c == NULL) {
        count = raxSize(keys);
    } else {
        count = 0;
        raxStart(&ri,keys);
        raxSeek(&ri,""^"",NULL,0);
        while(raxNext(&ri)) {
            if (ri.data != c) count++;
        }
        raxStop(&ri);

        if (count == 0) return NULL;
    }

    /* Create the array reply with the list of keys once, then send
    * it to all the clients subscribed to this prefix. */
    char buf[32];
    size_t len = ll2string(buf,sizeof(buf),count);
    sds proto = sdsempty();
    proto = sdsMakeRoomFor(proto,count*15);
    proto = sdscatlen(proto,""*"",1);
    proto = sdscatlen(proto,buf,len);
    proto = sdscatlen(proto,""\r\n"",2);
    raxStart(&ri,keys);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        if (c && ri.data == c) continue;
        len = ll2string(buf,sizeof(buf),ri.key_len);
        proto = sdscatlen(proto,""$"",1);
        proto = ...",553.0,593.0,1.0,1.0,41.0,27,7,48,8,0,21,5,5,2,17,,0,18,4,2,2,sds
6972,467610,connUnixGetType,1,connUnixGetType,const char* connUnixGetType (connection*),unix.c,"static const char *connUnixGetType(connection *conn) {
    UNUSED(conn);

    return CONN_TYPE_UNIX;
}",32.0,36.0,1.0,4.0,5.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,const char*
6973,467625,connUnixEventHandler,1,connUnixEventHandler,"void connUnixEventHandler (aeEventLoop*,int,void*,int)",unix.c,"static void connUnixEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask) {
    connectionTypeTcp()->ae_handler(el, fd, clientData, mask);
}",38.0,40.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,2,,0,1,8,4,4,void
6974,467641,connUnixAddr,1,connUnixAddr,"int connUnixAddr (connection*,char*,size_t,int*,int)",unix.c,"static int connUnixAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    return connectionTypeTcp()->addr(conn, ip, ip_len, port, remote);
}",42.0,44.0,1.0,1.0,3.0,1,1,5,5,0,2,1,1,0,2,,0,1,10,5,5,int
6975,467660,connUnixIsLocal,1,connUnixIsLocal,int connUnixIsLocal (connection*),unix.c,"static int connUnixIsLocal(connection *conn) {
    UNUSED(conn);

    return 1; /* Unix socket is always local connection */
}",46.0,50.0,1.0,4.0,5.0,1,1,2,1,0,0,1,1,0,0,,0,0,2,1,1,int
6976,467673,connUnixListen,1,connUnixListen,int connUnixListen (connListener*),unix.c,"static int connUnixListen(connListener *listener) {
    int fd;
    mode_t *perm = (mode_t *)listener->priv;

    if (listener->bindaddr_count == 0)
        return C_OK;

    /* currently listener->bindaddr_count is always 1, we still use a loop here in case Redis supports multi Unix socket in the future */
    for (int j = 0; j < listener->bindaddr_count; j++) {
        char *addr = listener->bindaddr[j];

        unlink(addr); /* don't care if this fails */
        fd = anetUnixServer(server.neterr, addr, *perm, server.tcp_backlog);
        if (fd == ANET_ERR) {
            serverLog(LL_WARNING, ""Failed opening Unix socket: %s"", server.neterr);
            exit(1);
        }
        anetNonBlock(NULL, fd);
        anetCloexec(fd);
        listener->fd[listener->count++] = fd;
    }

    return C_OK;
}",52.0,75.0,1.0,15.0,24.0,26,11,24,7,0,10,4,5,2,4,,0,7,2,1,1,int
6977,467784,connCreateUnix,1,connCreateUnix,connection connCreateUnix (void),unix.c,"static connection *connCreateUnix(void) {
    connection *conn = zcalloc(sizeof(connection));
    conn->type = &CT_Unix;
    conn->fd = -1;
    conn->iovcnt = IOV_MAX;

    return conn;
}",77.0,84.0,1.0,1.0,8.0,10,5,8,4,1,5,1,1,0,1,,0,5,2,1,1,connection
6978,467814,connCreateAcceptedUnix,1,connCreateAcceptedUnix,"connection connCreateAcceptedUnix (int,void*)",unix.c,"static connection *connCreateAcceptedUnix(int fd, void *priv) {
    UNUSED(priv);
    connection *conn = connCreateUnix();
    conn->fd = fd;
    conn->state = CONN_STATE_ACCEPTING;
    return conn;
}",86.0,92.0,1.0,4.0,7.0,6,3,8,4,1,3,1,1,0,1,,0,3,4,2,2,connection
6979,467842,connUnixAcceptHandler,1,connUnixAcceptHandler,"void connUnixAcceptHandler (aeEventLoop*,int,void*,int)",unix.c,"static void connUnixAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cfd, max = MAX_ACCEPTS_PER_CALL;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) {
        cfd = anetUnixAccept(server.neterr, fd);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    ""Accepting client connection: %s"", server.neterr);
            return;
        }
        serverLog(LL_VERBOSE,""Accepted connection to %s"", server.unixsocket);
        acceptCommonHandler(connCreateAcceptedUnix(cfd, NULL),CLIENT_UNIX_SOCKET,NULL);
    }
}",94.0,111.0,1.0,19.0,18.0,19,10,21,10,0,5,4,7,0,5,,0,2,8,4,4,void
6980,467952,connUnixShutdown,1,connUnixShutdown,void connUnixShutdown (connection*),unix.c,"static void connUnixShutdown(connection *conn) {
    connectionTypeTcp()->shutdown(conn);
}",113.0,115.0,1.0,1.0,3.0,1,1,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
6981,467962,connUnixClose,1,connUnixClose,void connUnixClose (connection*),unix.c,"static void connUnixClose(connection *conn) {
    connectionTypeTcp()->close(conn);
}",117.0,119.0,1.0,1.0,3.0,1,1,1,1,0,2,1,1,0,2,,0,1,2,1,1,void
6982,467972,connUnixAccept,1,connUnixAccept,"int connUnixAccept (connection*,ConnectionCallbackFunc)",unix.c,"static int connUnixAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    return connectionTypeTcp()->accept(conn, accept_handler);
}",121.0,123.0,1.0,1.0,3.0,1,1,2,2,0,2,1,1,0,2,,0,1,4,2,2,int
6983,467985,connUnixWrite,1,connUnixWrite,"int connUnixWrite (connection*,void*,size_t)",unix.c,"static int connUnixWrite(connection *conn, const void *data, size_t data_len) {
    return connectionTypeTcp()->write(conn, data, data_len);
}",125.0,127.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
6984,468000,connUnixWritev,1,connUnixWritev,"int connUnixWritev (connection*,iovec*,int)",unix.c,"static int connUnixWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    return connectionTypeTcp()->writev(conn, iov, iovcnt);
}",129.0,131.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
6985,468015,connUnixRead,1,connUnixRead,"int connUnixRead (connection*,void*,size_t)",unix.c,"static int connUnixRead(connection *conn, void *buf, size_t buf_len) {
    return connectionTypeTcp()->read(conn, buf, buf_len);
}",133.0,135.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
6986,468030,connUnixSetWriteHandler,1,connUnixSetWriteHandler,"int connUnixSetWriteHandler (connection*,ConnectionCallbackFunc,int)",unix.c,"static int connUnixSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {
    return connectionTypeTcp()->set_write_handler(conn, func, barrier);
}",137.0,139.0,1.0,1.0,3.0,1,1,3,3,0,2,1,1,0,2,,0,1,6,3,3,int
6987,468045,connUnixSetReadHandler,1,connUnixSetReadHandler,"int connUnixSetReadHandler (connection*,ConnectionCallbackFunc)",unix.c,"static int connUnixSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    return connectionTypeTcp()->set_read_handler(conn, func);
}",141.0,143.0,1.0,1.0,3.0,1,1,2,2,0,2,1,1,0,2,,0,1,4,2,2,int
6988,468058,connUnixGetLastError,1,connUnixGetLastError,const char* connUnixGetLastError (connection*),unix.c,"static const char *connUnixGetLastError(connection *conn) {
    return strerror(conn->last_errno);
}",145.0,147.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,const char*
6989,468068,connUnixSyncWrite,1,connUnixSyncWrite,"ssize_t connUnixSyncWrite (connection*,char*,ssize_t,long long)",unix.c,"static ssize_t connUnixSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncWrite(conn->fd, ptr, size, timeout);
}",149.0,151.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
6990,468084,connUnixSyncRead,1,connUnixSyncRead,"ssize_t connUnixSyncRead (connection*,char*,ssize_t,long long)",unix.c,"static ssize_t connUnixSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncRead(conn->fd, ptr, size, timeout);
}",153.0,155.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
6991,468100,connUnixSyncReadLine,1,connUnixSyncReadLine,"ssize_t connUnixSyncReadLine (connection*,char*,ssize_t,long long)",unix.c,"static ssize_t connUnixSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncReadLine(conn->fd, ptr, size, timeout);
}",157.0,159.0,1.0,1.0,3.0,1,1,4,4,0,2,1,1,0,1,,0,1,8,4,4,ssize_t
6992,468290,stringmatchlen_impl,1,stringmatchlen_impl,"int stringmatchlen_impl (char*,int,char*,int,int,int*)",util.c,"static int stringmatchlen_impl(const char *pattern, int patternLen,
        const char *string, int stringLen, int nocase, int *skipLongerMatches)
{
    while(patternLen && stringLen) {
        switch(pattern[0]) {
        case '*':
            while (patternLen && pattern[1] == '*') {
                pattern++;
                patternLen--;
            }
            if (patternLen == 1)
                return 1; /* match */
            while(stringLen) {
                if (stringmatchlen_impl(pattern+1, patternLen-1,
                            string, stringLen, nocase, skipLongerMatches))
                    return 1; /* match */
                if (*skipLongerMatches)
                    return 0; /* no match */
                string++;
                stringLen--;
            }
            /* There was no match for the rest of the pattern starting
             * from anywhere in the rest of the string. If there were
             * any '*' earlier in the pattern, we can termin...",56.0,187.0,1.0,1.0,132.0,61,12,60,8,1,0,25,58,0,0,,0,0,12,6,6,int
6993,468675,stringmatchlen,1,stringmatchlen,"int stringmatchlen (char*,int,char*,int,int)",util.c,"int stringmatchlen(const char *pattern, int patternLen,
        const char *string, int stringLen, int nocase) {
    int skipLongerMatches = 0;
    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);
}",189.0,193.0,1.0,1.0,5.0,2,2,7,6,9,1,1,1,0,1,,0,0,10,5,5,int
6994,468697,stringmatch,1,stringmatch,"int stringmatch (char*,char*,int)",util.c,"int stringmatch(const char *pattern, const char *string, int nocase) {
    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);
}",195.0,197.0,1.0,1.0,3.0,0,0,5,3,2,1,1,1,0,1,,0,0,6,3,3,int
6995,468713,stringmatchlen_fuzz_test,1,stringmatchlen_fuzz_test,int stringmatchlen_fuzz_test (void),util.c,"int stringmatchlen_fuzz_test(void) {
    char str[32];
    char pat[32];
    int cycles = 10000000;
    int total_matches = 0;
    while(cycles--) {
        int strlen = rand() % sizeof(str);
        int patlen = rand() % sizeof(pat);
        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;
        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;
        total_matches += stringmatchlen(pat, patlen, str, strlen, 0);
    }
    return total_matches;
}",200.0,213.0,1.0,1.0,14.0,14,6,19,7,0,1,4,6,0,1,,0,0,2,1,1,int
6996,468792,memtoull,1,memtoull,"unsigned long long memtoull (char*,int*)",util.c,"unsigned long long memtoull(const char *p, int *err) {
    const char *u;
    char buf[128];
    long mul; /* unit multiplier */
    unsigned long long val;
    unsigned int digits;

    if (err) *err = 0;

    /* Search the first non digit character. */
    u = p;
    if (*u == '-') {
        if (err) *err = 1;
        return 0;
    }
    while(*u && isdigit(*u)) u++;
    if (*u == '\0' || !strcasecmp(u,""b"")) {
        mul = 1;
    } else if (!strcasecmp(u,""k"")) {
        mul = 1000;
    } else if (!strcasecmp(u,""kb"")) {
        mul = 1024;
    } else if (!strcasecmp(u,""m"")) {
        mul = 1000*1000;
    } else if (!strcasecmp(u,""mb"")) {
        mul = 1024*1024;
    } else if (!strcasecmp(u,""g"")) {
        mul = 1000L*1000*1000;
    } else if (!strcasecmp(u,""gb"")) {
        mul = 1024L*1024*1024;
    } else {
        if (err) *err = 1;
        return 0;
    }

    /* Copy the digits into a buffer, we'll use strtoll() to convert
     * the digit (without the unit) into a number. */...",223.0,276.0,1.0,1.0,54.0,35,13,36,10,3,0,10,13,0,0,,0,0,4,2,2,unsigned long long
6997,469007,mempbrk,1,mempbrk,"const char* mempbrk (char*,size_t,char*,size_t)",util.c,"const char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen) {
    for (size_t j = 0; j < len; j++) {
        for (size_t n = 0; n < charslen; n++)
            if (s[j] == chars[n]) return &s[j];
    }

    return NULL;
}",281.0,288.0,1.0,1.0,8.0,4,2,7,5,1,0,3,4,0,0,,0,0,8,4,4,const char*
6998,469054,memmapchars,1,memmapchars,"char* memmapchars (char*,size_t,char*,char*,size_t)",util.c,"char *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen) {
    for (size_t j = 0; j < len; j++) {
        for (size_t i = 0; i < setlen; i++) {
            if (s[j] == from[i]) {
                s[j] = to[i];
                break;
            }
        }
    }
    return s;
}",293.0,303.0,1.0,1.0,11.0,10,4,15,7,1,0,5,7,0,0,,0,0,10,5,5,char*
6999,469106,digits10,1,digits10,uint32_t digits10 (uint64_t),util.c,"uint32_t digits10(uint64_t v) {
    if (v < 10) return 1;
    if (v < 100) return 2;
    if (v < 1000) return 3;
    if (v < 1000000000000UL) {
        if (v < 100000000UL) {
            if (v < 1000000) {
                if (v < 10000) return 4;
                return 5 + (v >= 100000);
            }
            return 7 + (v >= 10000000UL);
        }
        if (v < 10000000000UL) {
            return 9 + (v >= 1000000000UL);
        }
        return 11 + (v >= 100000000000UL);
    }
    return 12 + digits10(v / 1000000000000UL);
}",307.0,325.0,1.0,1.0,19.0,18,4,13,1,3,0,9,16,0,0,,0,0,2,1,1,uint32_t
7000,469190,sdigits10,1,sdigits10,uint32_t sdigits10 (int64_t),util.c,"uint32_t sdigits10(int64_t v) {
    if (v < 0) {
        /* Abs value of LLONG_MIN requires special handling. */
        uint64_t uv = (v != LLONG_MIN) ?
                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;
        return digits10(uv)+1; /* +1 for the minus. */
    } else {
        return digits10(v);
    }
}",328.0,337.0,1.0,1.0,10.0,8,7,8,5,1,1,2,2,0,1,,0,0,2,1,1,uint32_t
7001,469225,ll2string,1,ll2string,"int ll2string (char*,size_t,long long)",util.c,"int ll2string(char *dst, size_t dstlen, long long svalue) {
    unsigned long long value;
    int negative = 0;

    /* The ull2string function with 64bit unsigned integers for simplicity, so
     * we convert the number here and remember if it is negative. */
    if (svalue < 0) {
        if (svalue != LLONG_MIN) {
            value = -svalue;
        } else {
            value = ((unsigned long long) LLONG_MAX)+1;
        }
        if (dstlen < 2)
            goto err;
        negative = 1;
        dst[0] = '-';
        dst++;
        dstlen--;
    } else {
        value = svalue;
    }

    /* Converts the unsigned long long value to string*/
    int length = ull2string(dst, dstlen, value);
    if (length == 0) return 0;
    return length + negative;

err:
    /* force add Null termination */
    if (dstlen > 0)
        dst[0] = '\0';
    return 0;
}",342.0,374.0,1.0,1.0,33.0,17,10,20,7,33,1,7,8,0,1,,0,1,6,3,3,int
7002,469314,ull2string,1,ull2string,"int ull2string (char*,size_t,long long unsigned)",util.c,"int ull2string(char *dst, size_t dstlen, unsigned long long value) {
    static const char digits[201] =
        ""0001020304050607080910111213141516171819""
        ""2021222324252627282930313233343536373839""
        ""4041424344454647484950515253545556575859""
        ""6061626364656667686970717273747576777879""
        ""8081828384858687888990919293949596979899"";

    /* Check length. */
    uint32_t length = digits10(value);
    if (length >= dstlen) goto err;;

    /* Null term. */
    uint32_t next = length - 1;
    dst[next + 1] = '\0';
    while (value >= 100) {
        int const i = (value % 100) * 2;
        value /= 100;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
        next -= 2;
    }

    /* Handle last 1-2 digits. */
    if (value < 10) {
        dst[next] = '0' + (uint32_t) value;
    } else {
        int i = (uint32_t) value * 2;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
    }
    return length;
err:
    /* force add N...",384.0,421.0,1.0,1.0,38.0,30,12,29,7,3,1,6,5,0,1,,0,1,6,3,3,int
7003,469443,string2ll,1,string2ll,"int string2ll (char*,size_t,long long*)",util.c,"int string2ll(const char *s, size_t slen, long long *value) {
    const char *p = s;
    size_t plen = 0;
    int negative = 0;
    unsigned long long v;

    /* A string of zero length or excessive length is not a valid number. */
    if (plen == slen || slen >= LONG_STR_SIZE)
        return 0;

    /* Special case: first and only digit is 0. */
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }

    /* Handle negative numbers: just set a flag and continue like if it
     * was a positive number. Later convert into negative. */
    if (p[0] == '-') {
        negative = 1;
        p++; plen++;

        /* Abort on only a negative sign. */
        if (plen == slen)
            return 0;
    }

    /* First digit should be 1-9, otherwise the string should just be 0. */
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else {
        return 0;
    }

    /* Parse all the other digits, checking for over...",435.0,499.0,1.0,32.0,65.0,58,19,47,10,23,0,14,20,0,0,,0,0,6,3,3,int
7004,469654,string2ull,1,string2ull,"int string2ull (char*,long long unsigned*)",util.c,"int string2ull(const char *s, unsigned long long *value) {
    long long ll;
    if (string2ll(s,strlen(s),&ll)) {
        if (ll < 0) return 0; /* Negative values are out of range. */
        *value = ll;
        return 1;
    }
    errno = 0;
    char *endptr = NULL;
    *value = strtoull(s,&endptr,10);
    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0'))
        return 0; /* strtoull() failed. */
    return 1; /* Conversion done! */
}",506.0,519.0,1.0,1.0,14.0,19,9,18,8,3,1,4,5,1,1,,0,1,4,2,2,int
7005,469721,string2l,1,string2l,"int string2l (char*,size_t,long*)",util.c,"int string2l(const char *s, size_t slen, long *lval) {
    long long llval;

    if (!string2ll(s,slen,&llval))
        return 0;

    if (llval < LONG_MIN || llval > LONG_MAX)
        return 0;

    *lval = (long)llval;
    return 1;
}",524.0,535.0,1.0,1.0,12.0,8,8,9,6,1,1,3,3,1,1,,0,1,6,3,3,int
7006,469758,string2ld,1,string2ld,"int string2ld (char*,size_t,long double*)",util.c,"int string2ld(const char *s, size_t slen, long double *dp) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    long double value;
    char *eptr;

    if (slen == 0 || slen >= sizeof(buf)) return 0;
    memcpy(buf,s,slen);
    buf[slen] = '\0';

    errno = 0;
    value = strtold(buf, &eptr);
    if (isspace(buf[0]) || eptr[0] != '\0' ||
        (size_t)(eptr-buf) != slen ||
        (errno == ERANGE &&
            (value == HUGE_VAL || value == -HUGE_VAL || fpclassify(value) == FP_ZERO)) ||
        errno == EINVAL ||
        isnan(value))
        return 0;

    if (dp) *dp = value;
    return 1;
}",544.0,565.0,1.0,13.0,22.0,30,12,31,11,2,0,4,4,0,0,,0,0,6,3,3,int
7007,469853,string2d,1,string2d,"int string2d (char*,size_t,double*)",util.c,"int string2d(const char *s, size_t slen, double *dp) {
    errno = 0;
    char *eptr;
    *dp = strtod(s, &eptr);
    if (slen == 0 ||
        isspace(((const char*)s)[0]) ||
        (size_t)(eptr-(char*)s) != slen ||
        (errno == ERANGE &&
            (*dp == HUGE_VAL || *dp == -HUGE_VAL || fpclassify(*dp) == FP_ZERO)) ||
        isnan(*dp))
        return 0;
    return 1;
}",574.0,586.0,1.0,1.0,13.0,26,11,18,8,2,0,2,2,0,0,,0,0,6,3,3,int
7008,469921,double2ll,1,double2ll,"int double2ll (double,long long*)",util.c,"int double2ll(double d, long long *out) {
#if (DBL_MANT_DIG >= 52) && (DBL_MANT_DIG <= 63) && (LLONG_MAX == 0x7fffffffffffffffLL)
    /* Check if the float is in a safe range to be casted into a
     * long long. We are assuming that long long is 64 bit here.
     * Also we are assuming that there are no implementations around where
     * double has precision < 52 bit.
     *
     * Under this assumptions we test if a double is inside a range
     * where casting to long long is safe. Then using two castings we
     * make sure the decimal part is zero. If all this is true we can use
     * integer without precision loss.
     *
     * Note that numbers above 2^52 and below 2^63 use all the fraction bits as real part,
     * and the exponent bits are positive, which means the ""decimal"" part must be 0.
     * i.e. all double values in that range are representable as a long without precision loss,
     * but not all long values in that range can be represented as a double.
     * we ...",590.0,616.0,1.0,1.0,27.0,0,0,0,0,1,0,1,1,0,0,,0,0,4,2,2,int
7009,469929,d2string,1,d2string,"int d2string (char*,size_t,double)",util.c,"int d2string(char *buf, size_t len, double value) {
    if (isnan(value)) {
        /* Libc in some systems will format nan in a different way,
         * like nan, -nan, NAN, nan(char-sequence).
         * So we normalize it and create a single nan form in an explicit way. */
        len = snprintf(buf,len,""nan"");
    } else if (isinf(value)) {
        /* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */
        if (value < 0)
            len = snprintf(buf,len,""-inf"");
        else
            len = snprintf(buf,len,""inf"");
    } else if (value == 0) {
        /* See: http://en.wikipedia.org/wiki/Signed_zero, ""Comparisons"". */
        if (1.0/value < 0)
            len = snprintf(buf,len,""-0"");
        else
            len = snprintf(buf,len,""0"");
    } else {
        long long lvalue;
        /* Integer printing function is much faster, check if we can safely use it. */
        if (double2ll(value, ...",623.0,654.0,1.0,1.0,32.0,1,1,5,3,3,0,2,2,0,0,,0,0,6,3,3,int
7010,470028,fixedpoint_d2string,1,fixedpoint_d2string,"int fixedpoint_d2string (char*,size_t,double,int)",util.c,"int fixedpoint_d2string(char *dst, size_t dstlen, double dvalue, int fractional_digits) {
    if (fractional_digits < 1 || fractional_digits > 17)
        goto err;
    /* min size of 2 ( due to 0. ) + n fractional_digitits + \0 */
    if ((int)dstlen < (fractional_digits+3))
        goto err;
    if (dvalue == 0) {
        dst[0] = '0';
        dst[1] = '.';
        memset(dst + 2, '0', fractional_digits);
        dst[fractional_digits+2] = '\0';
        return fractional_digits + 2;
    }
    /* scale and round */
    static double powers_of_ten[] = {1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0,
    10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,
    10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0,
    100000000000000000.0 };
    long long svalue = llrint(dvalue * powers_of_ten[fractional_digits]);
    unsigned long long value;
    /* write sign */
    int negative = 0;
    if (svalue < 0) {
        if (...",676.0,765.0,1.0,1.0,90.0,77,19,75,15,1,1,17,16,0,1,,0,1,8,4,4,int
7011,470339,trimDoubleString,1,trimDoubleString,"int trimDoubleString (char*,size_t)",util.c,"int trimDoubleString(char *buf, size_t len) {
    if (strchr(buf,'.') != NULL) {
        char *p = buf+len-1;
        while(*p == '0') {
            p--;
            len--;
        }
        if (*p == '.') len--;
    }
    buf[len] = '\0';
    return len;
}",768.0,779.0,1.0,1.0,12.0,13,8,13,4,2,0,4,6,0,0,,0,0,4,2,2,int
7012,470385,ld2string,1,ld2string,"int ld2string (char*,size_t,long double,ld2string_mode)",util.c,"int ld2string(char *buf, size_t len, long double value, ld2string_mode mode) {
    size_t l = 0;

    if (isinf(value)) {
        /* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */
        if (len < 5) goto err; /* No room. 5 is ""-inf\0"" */
        if (value > 0) {
            memcpy(buf,""inf"",3);
            l = 3;
        } else {
            memcpy(buf,""-inf"",4);
            l = 4;
        }
    } else if (isnan(value)) {
        /* Libc in some systems will format nan in a different way,
         * like nan, -nan, NAN, nan(char-sequence).
         * So we normalize it and create a single nan form in an explicit way. */
        if (len < 4) goto err; /* No room. 4 is ""nan\0"" */
        memcpy(buf, ""nan"", 3);
        l = 3;
    } else {
        switch (mode) {
        case LD_STR_AUTO:
            l = snprintf(buf,len,""%.17Lg"",value);
            if (l+1 > len) goto err;; /* No room. */
           ...",790.0,853.0,1.0,1.0,64.0,9,4,11,4,3,0,6,7,0,0,,0,0,8,4,4,int
7013,470828,getAbsolutePath,1,getAbsolutePath,sds getAbsolutePath (char*),util.c,"sds getAbsolutePath(char *filename) {
    char cwd[1024];
    sds abspath;
    sds relpath = sdsnew(filename);

    relpath = sdstrim(relpath,"" \r\n\t"");
    if (relpath[0] == '/') return relpath; /* Path is already absolute. */

    /* If path is relative, join cwd and relative path. */
    if (getcwd(cwd,sizeof(cwd)) == NULL) {
        sdsfree(relpath);
        return NULL;
    }
    abspath = sdsnew(cwd);
    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')
        abspath = sdscat(abspath,""/"");

    /* At this point we have the current path always ending with ""/"", and
     * the trimmed relative path. Try to normalize the obvious case of
     * trailing ../ elements at the start of the path.
     *
     * For every ""../"" we find in the filename, we remove it and also remove
     * the last element of the cwd, unless the current cwd is ""/"". */
    while (sdslen(relpath) >= 3 &&
           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')
    {
        sdsrange...",943.0,986.0,1.0,1.0,44.0,35,14,38,7,0,14,7,10,4,14,,0,10,2,1,1,sds
7014,470962,getTimeZone,1,getTimeZone,long getTimeZone (void),util.c,"long getTimeZone(void) {
#if defined(__linux__) || defined(__sun)
    return timezone;
#else
    struct timeval tv;
    struct timezone tz;

    gettimeofday(&tv, &tz);

    return tz.tz_minuteswest * 60L;
#endif
}",992.0,1003.0,1.0,1.0,12.0,4,3,3,2,1,0,1,1,0,0,,0,0,2,1,1,long
7015,470980,pathIsBaseName,1,pathIsBaseName,int pathIsBaseName (char*),util.c,"int pathIsBaseName(char *path) {
    return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
}",1009.0,1011.0,1.0,1.0,3.0,3,2,4,2,3,0,1,1,0,0,,0,0,2,1,1,int
7016,470997,fileExist,1,fileExist,int fileExist (char*),util.c,"int fileExist(char *filename) {
    struct stat statbuf;
    return stat(filename, &statbuf) == 0 && S_ISREG(statbuf.st_mode);
}",1013.0,1016.0,1.0,1.0,4.0,4,4,3,2,2,0,1,1,0,0,,0,0,2,1,1,int
7017,471015,dirExists,1,dirExists,int dirExists (char*),util.c,"int dirExists(char *dname) {
    struct stat statbuf;
    return stat(dname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode);
}",1018.0,1021.0,1.0,1.0,4.0,4,4,3,2,2,0,1,1,0,0,,0,0,2,1,1,int
7018,471033,dirCreateIfMissing,1,dirCreateIfMissing,int dirCreateIfMissing (char*),util.c,"int dirCreateIfMissing(char *dname) {
    if (mkdir(dname, 0755) != 0) {
        if (errno != EEXIST) {
            return -1;
        } else if (!dirExists(dname)) {
            errno = ENOTDIR;
            return -1;
        }
    }
    return 0;
}",1023.0,1033.0,1.0,1.0,11.0,3,2,3,3,3,0,3,4,0,0,,0,0,2,1,1,int
7019,471068,dirRemove,1,dirRemove,int dirRemove (char*),util.c,"int dirRemove(char *dname) {
    DIR *dir;
    struct stat stat_entry;
    struct dirent *entry;
    char full_path[PATH_MAX + 1];

    if ((dir = opendir(dname)) == NULL) {
        return -1;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ""."") || !strcmp(entry->d_name, "".."")) continue;

        snprintf(full_path, sizeof(full_path), ""%s/%s"", dname, entry->d_name);

        int fd = open(full_path, O_RDONLY|O_NONBLOCK);
        if (fd == -1) {
            closedir(dir);
            return -1;
        }

        if (fstat(fd, &stat_entry) == -1) {
            close(fd);
            closedir(dir);
            return -1;
        }
        close(fd);

        if (S_ISDIR(stat_entry.st_mode) != 0) {
            if (dirRemove(full_path) == -1) {
                return -1;
            }
            continue;
        }

        if (unlink(full_path) != 0) {
            closedir(dir);
            return -1;
        }
    }

    if (rmdir(dname) != 0) {...",1035.0,1083.0,1.0,1.0,49.0,30,11,30,9,0,0,12,17,0,0,,0,0,2,1,1,int
7020,471203,makePath,1,makePath,"sds makePath (char*,char*)",util.c,"sds makePath(char *path, char *filename) {
    return sdscatfmt(sdsempty(), ""%s/%s"", path, filename);
}",1085.0,1087.0,1.0,1.0,3.0,0,0,2,2,15,2,1,1,0,2,,0,1,4,2,2,sds
7021,471215,fsyncFileDir,1,fsyncFileDir,int fsyncFileDir (char*),util.c,"int fsyncFileDir(const char *filename) {
#ifdef _AIX
    /* AIX is unable to fsync a directory */
    return 0;
#endif
    char temp_filename[PATH_MAX + 1];
    char *dname;
    int dir_fd;

    if (strlen(filename) > PATH_MAX) {
        errno = ENAMETOOLONG;
        return -1;
    }

    /* In the glibc implementation dirname may modify their argument. */
    memcpy(temp_filename, filename, strlen(filename) + 1);
    dname = dirname(temp_filename);

    dir_fd = open(dname, O_RDONLY);
    if (dir_fd == -1) {
        /* Some OSs don't allow us to open directories at all, just
         * ignore the error in that case */
        if (errno == EISDIR) {
            return 0;
        }
        return -1;
    }
    /* Some OSs don't allow us to fsync directories at all, so we can ignore
     * those errors. */
    if (redis_fsync(dir_fd) == -1 && !(errno == EBADF || errno == EINVAL)) {
        int save_errno = errno;
        close(dir_fd);
        errno = save_errno;
        return -1;
  ...",1097.0,1135.0,1.0,8.0,39.0,20,8,27,12,4,0,5,6,0,0,,0,0,2,1,1,int
7022,471302,reclaimFilePageCache,1,reclaimFilePageCache,"int reclaimFilePageCache (int,size_t,size_t)",util.c,"int reclaimFilePageCache(int fd, size_t offset, size_t length) {
#ifdef HAVE_FADVISE
    int ret = posix_fadvise(fd, offset, length, POSIX_FADV_DONTNEED);
    if (ret) return -1;
    return 0;
#else
    UNUSED(fd);
    UNUSED(offset);
    UNUSED(length);
    return 0;
#endif
}",1138.0,1149.0,1.0,4.0,12.0,3,1,6,3,2,0,1,1,0,0,,0,0,6,3,3,int
7023,471592,ziplistSafeToAdd,1,ziplistSafeToAdd,"int ziplistSafeToAdd (unsigned char*,size_t)",ziplist.c,"int ziplistSafeToAdd(unsigned char* zl, size_t add) {
    size_t len = zl? ziplistBlobLen(zl): 0;
    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)
        return 0;
    return 1;
}",273.0,278.0,1.0,20.0,6.0,5,5,5,3,0,1,2,2,0,1,,0,1,4,2,2,int
7024,471630,zipEncodingLenSize,1,zipEncodingLenSize,unsigned int zipEncodingLenSize (unsigned char),ziplist.c,"static inline unsigned int zipEncodingLenSize(unsigned char encoding) {
    if (encoding == ZIP_INT_16B || encoding == ZIP_INT_32B ||
        encoding == ZIP_INT_24B || encoding == ZIP_INT_64B ||
        encoding == ZIP_INT_8B)
        return 1;
    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
        return 1;
    if (encoding == ZIP_STR_06B)
        return 1;
    if (encoding == ZIP_STR_14B)
        return 2;
    if (encoding == ZIP_STR_32B)
        return 5;
    return ZIP_ENCODING_SIZE_INVALID;
}",321.0,335.0,1.0,20.0,15.0,26,7,10,1,1,0,6,6,0,0,,0,0,2,1,1,unsigned int
7025,471736,zipIntSize,1,zipIntSize,unsigned int zipIntSize (unsigned char),ziplist.c,"static inline unsigned int zipIntSize(unsigned char encoding) {
    switch(encoding) {
    case ZIP_INT_8B:  return 1;
    case ZIP_INT_16B: return 2;
    case ZIP_INT_24B: return 3;
    case ZIP_INT_32B: return 4;
    case ZIP_INT_64B: return 8;
    }
    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
        return 0; /* 4 bit immediate */
    /* bad encoding, covered by a previous call to ZIP_ASSERT_ENCODING */
    redis_unreachable();
    return 0;
}",342.0,355.0,1.0,9.0,14.0,11,5,3,1,2,0,3,3,0,0,,0,0,2,1,1,unsigned int
7026,471810,zipStoreEntryEncoding,1,zipStoreEntryEncoding,"unsigned int zipStoreEntryEncoding (unsigned char*,unsigned char,unsigned int)",ziplist.c,"unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
    unsigned char len = 1, buf[5];

    if (ZIP_IS_STR(encoding)) {
        /* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */
        if (rawlen <= 0x3f) {
            if (!p) return len;
            buf[0] = ZIP_STR_06B | rawlen;
        } else if (rawlen <= 0x3fff) {
            len += 1;
            if (!p) return len;
            buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);
            buf[1] = rawlen & 0xff;
        } else {
            len += 4;
            if (!p) return len;
            buf[0] = ZIP_STR_32B;
            buf[1] = (rawlen >> 24) & 0xff;
            buf[2] = (rawlen >> 16) & 0xff;
            buf[3] = (rawlen >> 8) & 0xff;
            buf[4] = rawlen & 0xff;
        }
    } else {
        /* Implies integer encoding, so length is always 1. */
        if (!p) return len;
        buf[0] = enco...",369.0,401.0,1.0,8.0,33.0,9,8,12,5,4,0,4,7,0,0,,0,0,6,3,3,unsigned int
7027,471965,zipStorePrevEntryLengthLarge,1,zipStorePrevEntryLengthLarge,"int zipStorePrevEntryLengthLarge (unsigned char*,unsigned int)",ziplist.c,"int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
    uint32_t u32;
    if (p != NULL) {
        p[0] = ZIP_BIG_PREVLEN;
        u32 = len;
        memcpy(p+1,&u32,sizeof(u32));
        memrev32ifbe(p+1);
    }
    return 1 + sizeof(uint32_t);
}",444.0,453.0,1.0,15.0,10.0,10,6,10,5,1,1,2,2,0,1,,0,0,4,2,2,int
7028,472006,zipStorePrevEntryLength,1,zipStorePrevEntryLength,"unsigned int zipStorePrevEntryLength (unsigned char*,unsigned int)",ziplist.c,"unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    if (p == NULL) {
        return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        if (len < ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}",457.0,468.0,1.0,22.0,12.0,5,5,4,4,8,0,2,2,0,0,,0,0,4,2,2,unsigned int
7029,472051,zipPrevLenByteDiff,1,zipPrevLenByteDiff,"int zipPrevLenByteDiff (unsigned char*,unsigned int)",ziplist.c,"int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
    unsigned int prevlensize;
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    return zipStorePrevEntryLength(NULL, len) - prevlensize;
}",514.0,518.0,1.0,4.0,5.0,5,4,8,4,2,1,1,1,0,1,,0,0,4,2,2,int
7030,472086,zipTryEncoding,1,zipTryEncoding,"int zipTryEncoding (unsigned char*,unsigned int,long long*,unsigned char*)",ziplist.c,"int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
    long long value;

    if (entrylen >= 32 || entrylen == 0) return 0;
    if (string2ll((char*)entry,entrylen,&value)) {
        /* Great, the string can be encoded. Check what's the smallest
         * of our encoding types that can hold this value. */
        if (value >= 0 && value <= 12) {
            *encoding = ZIP_INT_IMM_MIN+value;
        } else if (value >= INT8_MIN && value <= INT8_MAX) {
            *encoding = ZIP_INT_8B;
        } else if (value >= INT16_MIN && value <= INT16_MAX) {
            *encoding = ZIP_INT_16B;
        } else if (value >= INT24_MIN && value <= INT24_MAX) {
            *encoding = ZIP_INT_24B;
        } else if (value >= INT32_MIN && value <= INT32_MAX) {
            *encoding = ZIP_INT_32B;
        } else {
            *encoding = ZIP_INT_64B;
        }
        *v = value;
        return 1;
    }
    return 0;
}",522.0,546.0,1.0,24.0,25.0,13,10,11,5,2,1,4,5,1,1,,0,1,8,4,4,int
7031,472239,zipSaveInteger,1,zipSaveInteger,"void zipSaveInteger (unsigned char*,int64_t,unsigned char)",ziplist.c,"void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
    int16_t i16;
    int32_t i32;
    int64_t i64;
    if (encoding == ZIP_INT_8B) {
        ((int8_t*)p)[0] = (int8_t)value;
    } else if (encoding == ZIP_INT_16B) {
        i16 = value;
        memcpy(p,&i16,sizeof(i16));
        memrev16ifbe(p);
    } else if (encoding == ZIP_INT_24B) {
        i32 = ((uint64_t)value)<<8;
        memrev32ifbe(&i32);
        memcpy(p,((uint8_t*)&i32)+1,sizeof(i32)-sizeof(uint8_t));
    } else if (encoding == ZIP_INT_32B) {
        i32 = value;
        memcpy(p,&i32,sizeof(i32));
        memrev32ifbe(p);
    } else if (encoding == ZIP_INT_64B) {
        i64 = value;
        memcpy(p,&i64,sizeof(i64));
        memrev64ifbe(p);
    } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
        /* Nothing to do, the value is stored in the encoding itself. */
    } else {
        assert(NULL);
    }
}",549.0,576.0,1.0,20.0,28.0,5,4,3,3,0,0,2,2,0,0,,0,0,6,3,3,void
7032,472418,zipLoadInteger,1,zipLoadInteger,"int64_t zipLoadInteger (unsigned char*,unsigned char)",ziplist.c,"int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
    int16_t i16;
    int32_t i32;
    int64_t i64, ret = 0;
    if (encoding == ZIP_INT_8B) {
        ret = ((int8_t*)p)[0];
    } else if (encoding == ZIP_INT_16B) {
        memcpy(&i16,p,sizeof(i16));
        memrev16ifbe(&i16);
        ret = i16;
    } else if (encoding == ZIP_INT_32B) {
        memcpy(&i32,p,sizeof(i32));
        memrev32ifbe(&i32);
        ret = i32;
    } else if (encoding == ZIP_INT_24B) {
        i32 = 0;
        memcpy(((uint8_t*)&i32)+1,p,sizeof(i32)-sizeof(uint8_t));
        memrev32ifbe(&i32);
        ret = i32>>8;
    } else if (encoding == ZIP_INT_64B) {
        memcpy(&i64,p,sizeof(i64));
        memrev64ifbe(&i64);
        ret = i64;
    } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
        ret = (encoding & ZIP_INT_IMM_MASK)-1;
    } else {
        assert(NULL);
    }
    return ret;
}",579.0,608.0,1.0,20.0,30.0,5,4,5,3,0,0,2,2,0,0,,0,0,4,2,2,int64_t
7033,472616,zipEntry,1,zipEntry,"void zipEntry (unsigned char*,zlentry*)",ziplist.c,"static inline void zipEntry(unsigned char *p, zlentry *e) {
    ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
    ZIP_ENTRY_ENCODING(p + e->prevrawlensize, e->encoding);
    ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
    assert(e->lensize != 0); /* check that encoding was valid. */
    e->headersize = e->prevrawlensize + e->lensize;
    e->p = p;
}",616.0,623.0,1.0,4.0,8.0,149,17,71,2,7,56,1,1,0,1,,0,55,4,2,2,void
7034,473044,zipEntrySafe,1,zipEntrySafe,"int zipEntrySafe (unsigned char*,size_t,unsigned char*,zlentry*,int)",ziplist.c,"static inline int zipEntrySafe(unsigned char* zl, size_t zlbytes, unsigned char *p, zlentry *e, int validate_prevlen) {
    unsigned char *zlfirst = zl + ZIPLIST_HEADER_SIZE;
    unsigned char *zllast = zl + zlbytes - ZIPLIST_END_SIZE;
#define OUT_OF_RANGE(p) (unlikely((p) < zlfirst || (p) > zllast))

    /* If there's no possibility for the header to reach outside the ziplist,
     * take the fast path. (max lensize and prevrawlensize are both 5 bytes) */
    if (p >= zlfirst && p + 10 < zllast) {
        ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
        ZIP_ENTRY_ENCODING(p + e->prevrawlensize, e->encoding);
        ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
        e->headersize = e->prevrawlensize + e->lensize;
        e->p = p;
        /* We didn't call ZIP_ASSERT_ENCODING, so we check lensize was set to 0. */
        if (unlikely(e->lensize == 0))
            return 0;
        /* Make sure the entry doesn't reach outside the edge ...",629.0,689.0,1.0,34.0,61.0,373,17,210,10,8,134,11,14,20,1,,0,134,10,5,5,int
7035,474127,zipRawEntryLengthSafe,1,zipRawEntryLengthSafe,"unsigned int zipRawEntryLengthSafe (unsigned char*,size_t,unsigned char*)",ziplist.c,"static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &e, 0));
    return e.headersize + e.len;
}",692.0,696.0,1.0,4.0,5.0,8,7,6,4,1,4,1,1,0,2,,0,2,6,3,3,unsigned int
7036,474163,zipRawEntryLength,1,zipRawEntryLength,unsigned int zipRawEntryLength (unsigned char*),ziplist.c,"static inline unsigned int zipRawEntryLength(unsigned char *p) {
    zlentry e;
    zipEntry(p, &e);
    return e.headersize + e.len;
}",699.0,703.0,1.0,1.0,5.0,4,3,4,2,1,3,1,1,0,1,,0,2,2,1,1,unsigned int
7037,474181,zipAssertValidEntry,1,zipAssertValidEntry,"void zipAssertValidEntry (unsigned char*,size_t,unsigned char*)",ziplist.c,"static inline void zipAssertValidEntry(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &e, 1));
}",706.0,709.0,1.0,4.0,4.0,5,5,4,4,2,2,1,1,0,2,,0,0,6,3,3,void
7038,474209,ziplistNew,1,ziplistNew,unsigned char* ziplistNew (void),ziplist.c,"unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    unsigned char *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    ZIPLIST_LENGTH(zl) = 0;
    zl[bytes-1] = ZIP_END;
    return zl;
}",712.0,720.0,1.0,25.0,9.0,29,8,21,5,0,3,1,1,0,3,,0,3,2,1,1,unsigned char*
7039,474295,ziplistResize,1,ziplistResize,"unsigned char* ziplistResize (unsigned char*,size_t)",ziplist.c,"unsigned char *ziplistResize(unsigned char *zl, size_t len) {
    assert(len < UINT32_MAX);
    zl = zrealloc(zl,len);
    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
    zl[len-1] = ZIP_END;
    return zl;
}",723.0,729.0,1.0,4.0,7.0,12,9,12,3,3,3,1,1,0,3,,0,2,4,2,2,unsigned char*
7040,474346,__ziplistCascadeUpdate,1,__ziplistCascadeUpdate,"unsigned char* __ziplistCascadeUpdate (unsigned char*,unsigned char*)",ziplist.c,"unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    zlentry cur;
    size_t prevlen, prevlensize, prevoffset; /* Informat of the last changed entry. */
    size_t firstentrylen; /* Used to handle insert at head. */
    size_t rawlen, curlen = intrev32ifbe(ZIPLIST_BYTES(zl));
    size_t extra = 0, cnt = 0, offset;
    size_t delta = 4; /* Extra bytes needed to update a entry's prevlen (5-1). */
    unsigned char *tail = zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl));

    /* Empty ziplist */
    if (p[0] == ZIP_END) return zl;

    zipEntry(p, &cur); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    firstentrylen = prevlen = cur.headersize + cur.len;
    prevlensize = zipStorePrevEntryLength(NULL, prevlen);
    prevoffset = p - zl;
    p += prevlen;

    /* Iterate ziplist to find out how many extra bytes do we need to update it. */
    while (p[0] != ZIP_END) {
        assert(zipEntrySafe(zl, curlen,...",751.0,847.0,1.0,28.0,97.0,106,20,115,16,3,30,13,17,4,14,,0,23,4,2,2,unsigned char*
7041,474727,__ziplistDelete,1,__ziplistDelete,"unsigned char* __ziplistDelete (unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
    unsigned int i, totlen, deleted = 0;
    size_t offset;
    int nextdiff = 0;
    zlentry first, tail;
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));

    zipEntry(p, &first); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    for (i = 0; p[0] != ZIP_END && i < num; i++) {
        p += zipRawEntryLengthSafe(zl, zlbytes, p);
        deleted++;
    }

    assert(p >= first.p);
    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */
    if (totlen > 0) {
        uint32_t set_tail;
        if (p[0] != ZIP_END) {
            /* Storing `prevrawlen` in this entry may increase or decrease the
             * number of bytes required compare to the current `prevrawlen`.
             * There always is room to store this, because it was previously
             * stored by an entry that is now being deleted. */
            ne...",850.0,923.0,1.0,21.0,74.0,104,23,90,16,2,26,6,10,2,17,,0,17,6,3,3,unsigned char*
7042,475064,__ziplistInsert,1,__ziplistInsert,"unsigned char* __ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, newlen;
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */
    zlentry tail;

    /* Find out prevlen for the entry that is inserted. */
    if (p[0] != ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } else {
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
        }
    }

    /* See if the entry can be encoded */
    if (zipTryEncoding(s,slen,&value,&encoding)) {
        /* 'encoding' is set to the appropriate int...",926.0,1023.0,1.0,20.0,98.0,120,22,121,18,2,22,9,11,3,20,,0,14,8,4,4,unsigned char*
7043,475531,ziplistMerge,1,ziplistMerge,"unsigned char* ziplistMerge (unsigned char**,unsigned char**)",ziplist.c,"unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
    /* If any params are null, we can't merge, so NULL. */
    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
        return NULL;

    /* Can't merge same list into itself. */
    if (*first == *second)
        return NULL;

    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));

    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));

    int append;
    unsigned char *source, *target;
    size_t target_bytes, source_bytes;
    /* Pick the largest ziplist so we can resize easily in-place.
     * We must also track if we are now appending or prepending to
     * the target ziplist. */
    if (first_len >= second_len) {
        /* retain first, append second to first. */
        target = *first;
        target_bytes = first_bytes;
        sourc...",1040.0,1141.0,1.0,25.0,102.0,116,14,96,21,0,13,6,6,0,13,,0,11,4,2,2,unsigned char*
7044,475922,ziplistPush,1,ziplistPush,"unsigned char* ziplistPush (unsigned char*,unsigned char*,unsigned int,int)",ziplist.c,"unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
    unsigned char *p;
    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
    return __ziplistInsert(zl,p,s,slen);
}",1143.0,1147.0,1.0,18.0,5.0,13,9,14,8,0,2,1,1,0,2,,0,1,8,4,4,unsigned char*
7045,475970,ziplistIndex,1,ziplistIndex,"unsigned char* ziplistIndex (unsigned char*,int)",ziplist.c,"unsigned char *ziplistIndex(unsigned char *zl, int index) {
    unsigned char *p;
    unsigned int prevlensize, prevlen = 0;
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
    if (index < 0) {
        index = (-index)-1;
        p = ZIPLIST_ENTRY_TAIL(zl);
        if (p[0] != ZIP_END) {
            /* No need for ""safe"" check: when going backwards, we know the header
             * we're parsing is in the range, we just need to assert (below) that
             * the size we take doesn't cause p to go outside the allocation. */
            ZIP_DECODE_PREVLENSIZE(p, prevlensize);
            assert(p + prevlensize < zl + zlbytes - ZIPLIST_END_SIZE);
            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            while (prevlen > 0 && index--) {
                p -= prevlen;
                assert(p >= zl + ZIPLIST_HEADER_SIZE && p < zl + zlbytes - ZIPLIST_END_SIZE);
                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            }
        }
    } else {
        p ...",1152.0,1186.0,1.0,21.0,35.0,88,23,69,10,4,5,5,8,0,5,,0,2,4,2,2,unsigned char*
7046,476295,ziplistNext,1,ziplistNext,"unsigned char* ziplistNext (unsigned char*,unsigned char*)",ziplist.c,"unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
    ((void) zl);
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));

    /* ""p"" could be equal to ZIP_END, caused by ziplistDelete,
     * and we should return NULL. Otherwise, we should return NULL
     * when the *next* element is ZIP_END (there is no next entry). */
    if (p[0] == ZIP_END) {
        return NULL;
    }

    p += zipRawEntryLength(p);
    if (p[0] == ZIP_END) {
        return NULL;
    }

    zipAssertValidEntry(zl, zlbytes, p);
    return p;
}",1194.0,1212.0,1.0,21.0,19.0,9,6,13,4,5,3,3,3,0,3,,0,1,4,2,2,unsigned char*
7047,476346,ziplistPrev,1,ziplistPrev,"unsigned char* ziplistPrev (unsigned char*,unsigned char*)",ziplist.c,"unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
    unsigned int prevlensize, prevlen = 0;

    /* Iterating backwards from ZIP_END should return the tail. When ""p"" is
     * equal to the first element of the list, we're already at the head,
     * and should return NULL. */
    if (p[0] == ZIP_END) {
        p = ZIPLIST_ENTRY_TAIL(zl);
        return (p[0] == ZIP_END) ? NULL : p;
    } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
        return NULL;
    } else {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
        assert(prevlen > 0);
        p-=prevlen;
        size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
        zipAssertValidEntry(zl, zlbytes, p);
        return p;
    }
}",1215.0,1234.0,1.0,16.0,20.0,12,8,10,5,0,1,2,2,0,1,,0,1,4,2,2,unsigned char*
7048,476510,ziplistGet,1,ziplistGet,"unsigned int ziplistGet (unsigned char*,unsigned char**,unsigned int*,long long*)",ziplist.c,"unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {
    zlentry entry;
    if (p == NULL || p[0] == ZIP_END) return 0;
    if (sstr) *sstr = NULL;

    zipEntry(p, &entry); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    if (ZIP_IS_STR(entry.encoding)) {
        if (sstr) {
            *slen = entry.len;
            *sstr = p+entry.headersize;
        }
    } else {
        if (sval) {
            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
        }
    }
    return 1;
}",1240.0,1257.0,1.0,29.0,18.0,18,10,16,5,9,5,5,6,2,1,,0,4,8,4,4,unsigned int
7049,476595,ziplistInsert,1,ziplistInsert,"unsigned char* ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl,p,s,slen);
}",1260.0,1262.0,1.0,1.0,3.0,0,0,4,4,0,1,1,1,0,1,,0,0,8,4,4,unsigned char*
7050,476609,ziplistDelete,1,ziplistDelete,"unsigned char* ziplistDelete (unsigned char*,unsigned char**)",ziplist.c,"unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p-zl;
    zl = __ziplistDelete(zl,*p,1);

    /* Store pointer to current element in p, because ziplistDelete will
     * do a realloc which might result in a different ""zl""-pointer.
     * When the delete direction is back to front, we might delete the last
     * entry and end up with ""p"" pointing to ZIP_END, so check this. */
    *p = zl+offset;
    return zl;
}",1267.0,1277.0,1.0,1.0,11.0,8,4,10,3,0,1,1,1,0,1,,0,1,4,2,2,unsigned char*
7051,476637,ziplistDeleteRange,1,ziplistDeleteRange,"unsigned char* ziplistDeleteRange (unsigned char*,int,unsigned int)",ziplist.c,"unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
    unsigned char *p = ziplistIndex(zl,index);
    return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
}",1280.0,1283.0,1.0,1.0,4.0,3,3,9,5,0,2,1,1,0,2,,0,1,6,3,3,unsigned char*
7052,476660,ziplistReplace,1,ziplistReplace,"unsigned char* ziplistReplace (unsigned char*,unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned char *ziplistReplace(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {

    /* get metadata of the current entry */
    zlentry entry;
    zipEntry(p, &entry);

    /* compute length of entry to store, excluding prevlen */
    unsigned int reqlen;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. */
    if (zipTryEncoding(s,slen,&value,&encoding)) {
        reqlen = zipIntSize(encoding); /* encoding is set */
    } else {
        reqlen = slen; /* encoding == 0 */
    }
    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

    if (reqlen == entry.lensize + entry.len) {
        /* Simply overwrite the element. */
        p += entry.prevrawlensize;
        p += zipStoreEntryEncoding(p,encoding,slen);
        if (ZIP_IS_STR(encoding)) {
            memcpy(p,s,slen);
        } else {
            zipSaveInteger(p,value,encoding);
        }
    } else {
        /* Fallback. */
        zl = ziplistDelete...",1287.0,1319.0,1.0,12.0,33.0,16,8,29,9,0,8,4,5,3,5,,0,5,8,4,4,unsigned char*
7053,476765,ziplistCompare,1,ziplistCompare,"unsigned int ziplistCompare (unsigned char*,unsigned char*,unsigned int)",ziplist.c,"unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
    zlentry entry;
    unsigned char sencoding;
    long long zval, sval;
    if (p[0] == ZIP_END) return 0;

    zipEntry(p, &entry); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    if (ZIP_IS_STR(entry.encoding)) {
        /* Raw compare */
        if (entry.len == slen) {
            return memcmp(p+entry.headersize,sstr,slen) == 0;
        } else {
            return 0;
        }
    } else {
        /* Try to compare encoded values. Don't compare encoding because
         * different implementations may encoded integers differently. */
        if (zipTryEncoding(sstr,slen,&sval,&sencoding)) {
          zval = zipLoadInteger(p+entry.headersize,entry.encoding);
          return zval == sval;
        }
    }
    return 0;
}",1323.0,1346.0,1.0,16.0,24.0,12,7,11,4,0,5,4,5,3,1,,0,4,6,3,3,unsigned int
7054,476855,ziplistFind,1,ziplistFind,"unsigned char* ziplistFind (unsigned char*,unsigned char*,unsigned char*,unsigned int,unsigned int)",ziplist.c,"unsigned char *ziplistFind(unsigned char *zl, unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
    int skipcnt = 0;
    unsigned char vencoding = 0;
    long long vll = 0;
    size_t zlbytes = ziplistBlobLen(zl);

    while (p[0] != ZIP_END) {
        struct zlentry e;
        unsigned char *q;

        assert(zipEntrySafe(zl, zlbytes, p, &e, 1));
        q = p + e.prevrawlensize + e.lensize;

        if (skipcnt == 0) {
            /* Compare current entry with specified entry */
            if (ZIP_IS_STR(e.encoding)) {
                if (e.len == vlen && memcmp(q, vstr, vlen) == 0) {
                    return p;
                }
            } else {
                /* Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is set to the integer value. */
                if (vencoding == 0) {
                    if (!zipTryEncoding(vs...",1350.0,1407.0,1.0,19.0,58.0,29,14,29,12,0,9,5,11,3,3,,0,7,10,5,5,unsigned char*
7055,477029,ziplistLen,1,ziplistLen,unsigned int ziplistLen (unsigned char*),ziplist.c,"unsigned int ziplistLen(unsigned char *zl) {
    unsigned int len = 0;
    if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
        len = intrev16ifbe(ZIPLIST_LENGTH(zl));
    } else {
        unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
        size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
        while (*p != ZIP_END) {
            p += zipRawEntryLengthSafe(zl, zlbytes, p);
            len++;
        }

        /* Re-store length if small enough */
        if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
    }
    return len;
}",1410.0,1426.0,1.0,8.0,17.0,13,7,8,4,2,2,2,2,1,2,,0,2,2,1,1,unsigned int
7056,477135,ziplistBlobLen,1,ziplistBlobLen,size_t ziplistBlobLen (unsigned char*),ziplist.c,"size_t ziplistBlobLen(unsigned char *zl) {
    return intrev32ifbe(ZIPLIST_BYTES(zl));
}",1429.0,1431.0,1.0,11.0,3.0,2,2,1,1,3,1,1,1,0,1,,0,0,2,1,1,size_t
7057,477148,ziplistRepr,1,ziplistRepr,void ziplistRepr (unsigned char*),ziplist.c,"void ziplistRepr(unsigned char *zl) {
    unsigned char *p;
    int index = 0;
    zlentry entry;
    size_t zlbytes = ziplistBlobLen(zl);

    printf(
        ""{total bytes %u} ""
        ""{num entries %u}\n""
        ""{tail offset %u}\n"",
        intrev32ifbe(ZIPLIST_BYTES(zl)),
        intrev16ifbe(ZIPLIST_LENGTH(zl)),
        intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
    p = ZIPLIST_ENTRY_HEAD(zl);
    while(*p != ZIP_END) {
        assert(zipEntrySafe(zl, zlbytes, p, &entry, 1));
        printf(
            ""{\n""
                ""\taddr 0x%08lx,\n""
                ""\tindex %2d,\n""
                ""\toffset %5lu,\n""
                ""\thdr+entry len: %5u,\n""
                ""\thdr len%2u,\n""
                ""\tprevrawlen: %5u,\n""
                ""\tprevrawlensize: %2u,\n""
                ""\tpayload %5u\n"",
            (long unsigned)p,
            index,
            (unsigned long) (p-zl),
            entry.headersize+entry.len,
            entry.headersize,
            entry.prevraw...",1433.0,1490.0,1.0,8.0,58.0,54,20,44,9,0,19,6,13,5,6,,0,14,2,1,1,void
7058,477376,ziplistValidateIntegrity,1,ziplistValidateIntegrity,"int ziplistValidateIntegrity (unsigned char*,size_t,int,ziplistValidateEntryCB,void*)",ziplist.c,"int ziplistValidateIntegrity(unsigned char *zl, size_t size, int deep,
    ziplistValidateEntryCB entry_cb, void *cb_userdata) {
    /* check that we can actually read the header. (and ZIP_END) */
    if (size < ZIPLIST_HEADER_SIZE + ZIPLIST_END_SIZE)
        return 0;

    /* check that the encoded size in the header must match the allocated size. */
    size_t bytes = intrev32ifbe(ZIPLIST_BYTES(zl));
    if (bytes != size)
        return 0;

    /* the last byte must be the terminator. */
    if (zl[size - ZIPLIST_END_SIZE] != ZIP_END)
        return 0;

    /* make sure the tail offset isn't reaching outside the allocation. */
    if (intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) > size - ZIPLIST_END_SIZE)
        return 0;

    if (!deep)
        return 1;

    unsigned int count = 0;
    unsigned int header_count = intrev16ifbe(ZIPLIST_LENGTH(zl));
    unsigned char *p = ZIPLIST_ENTRY_HEAD(zl);
    unsigned char *prev = NULL;
    size_t prev_raw_size = 0;
    while(*p != ZIP_END) {
   ...",1495.0,1556.0,1.0,15.0,62.0,71,17,63,17,1,10,13,16,4,5,,0,10,10,5,5,int
7059,477621,ziplistRandomPair,1,ziplistRandomPair,"void ziplistRandomPair (unsigned char*,long unsigned,ziplistEntry*,ziplistEntry*)",ziplist.c,"void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val) {
    int ret;
    unsigned char *p;

    /* Avoid div by zero on corrupt ziplist */
    assert(total_count);

    /* Generate even numbers, because ziplist saved K-V pair */
    int r = (rand() % total_count) * 2;
    p = ziplistIndex(zl, r);
    ret = ziplistGet(p, &key->sval, &key->slen, &key->lval);
    assert(ret != 0);

    if (!val)
        return;
    p = ziplistNext(zl, p);
    ret = ziplistGet(p, &val->sval, &val->slen, &val->lval);
    assert(ret != 0);
}",1562.0,1580.0,1.0,4.0,19.0,34,11,23,7,0,13,2,2,0,7,,0,10,8,4,4,void
7060,477749,ziplistSaveValue,1,ziplistSaveValue,"void ziplistSaveValue (unsigned char*,unsigned int,long long,ziplistEntry*)",ziplist.c,"static inline void ziplistSaveValue(unsigned char *val, unsigned int len, long long lval, ziplistEntry *dest) {
    dest->sval = val;
    dest->slen = len;
    dest->lval = lval;
}",1588.0,1592.0,1.0,1.0,5.0,6,2,6,4,4,3,1,1,0,0,,0,3,8,4,4,void
7061,477772,ziplistRandomPairs,1,ziplistRandomPairs,"void ziplistRandomPairs (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)",ziplist.c,"void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {
    unsigned char *p, *key, *value;
    unsigned int klen = 0, vlen = 0;
    long long klval = 0, vlval = 0;

    /* Notice: the index member must be first due to the use in uintCompare */
    typedef struct {
        unsigned int index;
        unsigned int order;
    } rand_pick;
    rand_pick *picks = zmalloc(sizeof(rand_pick)*count);
    unsigned int total_size = ziplistLen(zl)/2;

    /* Avoid div by zero on corrupt ziplist */
    assert(total_size);

    /* create a pool of random indexes (some may be duplicate). */
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = (rand() % total_size) * 2; /* Generate even indexes */
        /* keep track of the order we picked them */
        picks[i].order = i;
    }

    /* sort by indexes. */
    qsort(picks, count, sizeof(rand_pick), uintCompare);

    /* fetch the elements form the ziplist into a output array r...",1598.0,1642.0,1.0,4.0,45.0,57,17,67,18,0,12,5,8,1,12,,0,6,8,4,4,void
7062,477975,ziplistRandomPairsUnique,1,ziplistRandomPairsUnique,"unsigned int ziplistRandomPairsUnique (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)",ziplist.c,"unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {
    unsigned char *p, *key;
    unsigned int klen = 0;
    long long klval = 0;
    unsigned int total_size = ziplistLen(zl)/2;
    unsigned int index = 0;
    if (count > total_size)
        count = total_size;

    /* To only iterate once, every time we try to pick a member, the probability
     * we pick it is the quotient of the count left we want to pick and the
     * count still we haven't visited in the dict, this way, we could make every
     * member be equally picked.*/
    p = ziplistIndex(zl, 0);
    unsigned int picked = 0, remaining = count;
    while (picked < count && p) {
        double randomDouble = ((double)rand()) / RAND_MAX;
        double threshold = ((double)remaining) / (total_size - index);
        if (randomDouble <= threshold) {
            assert(ziplistGet(p, &key, &klen, &klval));
            ziplistSaveValue(key, klen, klval, &keys[p...",1650.0,1687.0,1.0,12.0,38.0,47,15,56,15,0,11,5,8,0,11,,0,4,8,4,4,unsigned int
7063,478286,ziplistValidateEntryCB,1,ziplistValidateEntryCB,"int ziplistValidateEntryCB (unsigned char*,unsigned int,void*)",ziplist.h,"typedef int (*ziplistValidateEntryCB)(unsigned char* p, unsigned int head_count, void* userdata);",62.0,62.0,13.0,96.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,6,3,3,int
7064,478345,zipmapNew,1,zipmapNew,unsigned char* zipmapNew (void),zipmap.c,"unsigned char *zipmapNew(void) {
    unsigned char *zm = zmalloc(2);

    zm[0] = 0; /* Length */
    zm[1] = ZIPMAP_END;
    return zm;
}",96.0,102.0,1.0,12.0,7.0,5,2,4,1,0,1,1,1,0,1,,0,1,2,1,1,unsigned char*
7065,478369,zipmapDecodeLength,1,zipmapDecodeLength,unsigned int zipmapDecodeLength (unsigned char*),zipmap.c,"static unsigned int zipmapDecodeLength(unsigned char *p) {
    unsigned int len = *p;

    if (len < ZIPMAP_BIGLEN) return len;
    memcpy(&len,p+1,sizeof(unsigned int));
    memrev32ifbe(&len);
    return len;
}",105.0,112.0,1.0,14.0,8.0,8,6,10,3,9,1,2,2,0,1,,0,0,2,1,1,unsigned int
7066,478405,zipmapGetEncodedLengthSize,1,zipmapGetEncodedLengthSize,unsigned int zipmapGetEncodedLengthSize (unsigned char*),zipmap.c,"static unsigned int zipmapGetEncodedLengthSize(unsigned char *p) {
    return (*p < ZIPMAP_BIGLEN) ? 1: 5;
}",114.0,116.0,1.0,17.0,3.0,3,3,1,1,2,0,1,1,0,0,,0,0,2,1,1,unsigned int
7067,478420,zipmapEncodeLength,1,zipmapEncodeLength,"unsigned int zipmapEncodeLength (unsigned char*,unsigned int)",zipmap.c,"static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {
    if (p == NULL) {
        return ZIPMAP_LEN_BYTES(len);
    } else {
        if (len < ZIPMAP_BIGLEN) {
            p[0] = len;
            return 1;
        } else {
            p[0] = ZIPMAP_BIGLEN;
            memcpy(p+1,&len,sizeof(len));
            memrev32ifbe(p+1);
            return 1+sizeof(len);
        }
    }
}",120.0,134.0,1.0,15.0,15.0,5,5,5,4,6,0,2,2,0,0,,0,0,4,2,2,unsigned int
7068,478488,zipmapLookupRaw,1,zipmapLookupRaw,"unsigned char* zipmapLookupRaw (unsigned char*,unsigned char*,unsigned int,unsigned int*)",zipmap.c,"static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {
    unsigned char *p = zm+1, *k = NULL;
    unsigned int l,llen;

    while(*p != ZIPMAP_END) {
        unsigned char free;

        /* Match or skip the key */
        l = zipmapDecodeLength(p);
        llen = zipmapEncodeLength(NULL,l);
        if (key != NULL && k == NULL && l == klen && !memcmp(p+llen,key,l)) {
            /* Only return when the user doesn't care
             * for the total length of the zipmap. */
            if (totlen != NULL) {
                k = p;
            } else {
                return p;
            }
        }
        p += llen+l;
        /* Skip the value as well */
        l = zipmapDecodeLength(p);
        p += zipmapEncodeLength(NULL,l);
        free = p[0];
        p += l+1+free; /* +1 to skip the free byte */
    }
    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1;
    return k;
}",142.0,170.0,1.0,16.0,29.0,32,11,43,10,5,4,5,8,0,4,,0,3,8,4,4,unsigned char*
7069,478602,zipmapRequiredLength,1,zipmapRequiredLength,"unsigned long zipmapRequiredLength (unsigned int,unsigned int)",zipmap.c,"static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {
    unsigned int l;

    l = klen+vlen+3;
    if (klen >= ZIPMAP_BIGLEN) l += 4;
    if (vlen >= ZIPMAP_BIGLEN) l += 4;
    return l;
}",172.0,179.0,1.0,16.0,8.0,7,4,8,3,1,0,3,3,0,0,,0,0,4,2,2,unsigned long
7070,478638,zipmapRawKeyLength,1,zipmapRawKeyLength,unsigned int zipmapRawKeyLength (unsigned char*),zipmap.c,"static unsigned int zipmapRawKeyLength(unsigned char *p) {
    unsigned int l = zipmapDecodeLength(p);
    return zipmapEncodeLength(NULL,l) + l;
}",182.0,185.0,1.0,1.0,4.0,2,2,5,3,3,2,1,1,0,2,,0,1,2,1,1,unsigned int
7071,478654,zipmapRawValueLength,1,zipmapRawValueLength,unsigned int zipmapRawValueLength (unsigned char*),zipmap.c,"static unsigned int zipmapRawValueLength(unsigned char *p) {
    unsigned int l = zipmapDecodeLength(p);
    unsigned int used;

    used = zipmapEncodeLength(NULL,l);
    used += p[used] + 1 + l;
    return used;
}",189.0,196.0,1.0,1.0,8.0,6,4,10,4,2,2,1,1,0,2,,0,2,2,1,1,unsigned int
7072,478681,zipmapRawEntryLength,1,zipmapRawEntryLength,unsigned int zipmapRawEntryLength (unsigned char*),zipmap.c,"static unsigned int zipmapRawEntryLength(unsigned char *p) {
    unsigned int l = zipmapRawKeyLength(p);
    return l + zipmapRawValueLength(p+l);
}",201.0,204.0,1.0,1.0,4.0,3,2,5,2,1,2,1,1,0,2,,0,1,2,1,1,unsigned int
7073,478698,zipmapResize,1,zipmapResize,"unsigned char* zipmapResize (unsigned char*,unsigned int)",zipmap.c,"static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
    zm = zrealloc(zm, len);
    zm[len-1] = ZIPMAP_END;
    return zm;
}",206.0,210.0,1.0,16.0,5.0,4,3,6,2,3,1,1,1,0,1,,0,1,4,2,2,unsigned char*
7074,478720,zipmapSet,1,zipmapSet,"unsigned char* zipmapSet (unsigned char*,unsigned char*,unsigned int,unsigned char*,unsigned int,int*)",zipmap.c,"unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {
    unsigned int zmlen, offset;
    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);
    unsigned int empty, vempty;
    unsigned char *p;

    freelen = reqlen;
    if (update) *update = 0;
    p = zipmapLookupRaw(zm,key,klen,&zmlen);
    if (p == NULL) {
        /* Key not found: enlarge */
        zm = zipmapResize(zm, zmlen+reqlen);
        p = zm+zmlen-1;
        zmlen = zmlen+reqlen;

        /* Increase zipmap length (this is an insert) */
        if (zm[0] < ZIPMAP_BIGLEN) zm[0]++;
    } else {
        /* Key found. Is there enough space for the new value? */
        /* Compute the total length: */
        if (update) *update = 1;
        freelen = zipmapRawEntryLength(p);
        if (freelen < reqlen) {
            /* Store the offset of this key within the current zipmap, so
             * it can be resized. Then, move the ...",215.0,281.0,1.0,20.0,67.0,39,12,66,14,0,6,5,6,0,6,,0,4,12,6,6,unsigned char*
7075,478938,zipmapDel,1,zipmapDel,"unsigned char* zipmapDel (unsigned char*,unsigned char*,unsigned int,int*)",zipmap.c,"unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {
    unsigned int zmlen, freelen;
    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);
    if (p) {
        freelen = zipmapRawEntryLength(p);
        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));
        zm = zipmapResize(zm, zmlen-freelen);

        /* Decrease zipmap length */
        if (zm[0] < ZIPMAP_BIGLEN) zm[0]--;

        if (deleted) *deleted = 1;
    } else {
        if (deleted) *deleted = 0;
    }
    return zm;
}",285.0,301.0,1.0,20.0,17.0,16,8,24,7,0,3,4,6,0,3,,0,3,8,4,4,unsigned char*
7076,479016,zipmapRewind,1,zipmapRewind,unsigned char* zipmapRewind (unsigned char*),zipmap.c,"unsigned char *zipmapRewind(unsigned char *zm) {
    return zm+1;
}",304.0,306.0,1.0,1.0,3.0,1,1,1,1,0,0,1,1,0,0,,0,0,2,1,1,unsigned char*
7077,479025,zipmapNext,1,zipmapNext,"unsigned char* zipmapNext (unsigned char*,unsigned char**,unsigned int*,unsigned char**,unsigned int*)",zipmap.c,"unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {
    if (zm[0] == ZIPMAP_END) return NULL;
    if (key) {
        *key = zm;
        *klen = zipmapDecodeLength(zm);
        *key += ZIPMAP_LEN_BYTES(*klen);
    }
    zm += zipmapRawKeyLength(zm);
    if (value) {
        *value = zm+1;
        *vlen = zipmapDecodeLength(zm);
        *value += ZIPMAP_LEN_BYTES(*vlen);
    }
    zm += zipmapRawValueLength(zm);
    return zm;
}",319.0,334.0,1.0,17.0,16.0,29,9,25,7,0,4,4,4,0,4,,0,2,10,5,5,unsigned char*
7078,479115,zipmapGet,1,zipmapGet,"int zipmapGet (unsigned char*,unsigned char*,unsigned int,unsigned char**,unsigned int*)",zipmap.c,"int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {
    unsigned char *p;

    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;
    p += zipmapRawKeyLength(p);
    *vlen = zipmapDecodeLength(p);
    *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
    return 1;
}",338.0,346.0,1.0,17.0,9.0,15,8,15,8,0,3,2,2,1,3,,0,2,10,5,5,int
7079,479170,zipmapExists,1,zipmapExists,"int zipmapExists (unsigned char*,unsigned char*,unsigned int)",zipmap.c,"int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {
    return zipmapLookupRaw(zm,key,klen,NULL) != NULL;
}",349.0,351.0,1.0,1.0,3.0,1,1,5,4,0,1,1,1,0,1,,0,0,6,3,3,int
7080,479185,zipmapLen,1,zipmapLen,unsigned int zipmapLen (unsigned char*),zipmap.c,"unsigned int zipmapLen(unsigned char *zm) {
    unsigned int len = 0;
    if (zm[0] < ZIPMAP_BIGLEN) {
        len = zm[0];
    } else {
        unsigned char *p = zipmapRewind(zm);
        while((p = zipmapNext(p,NULL,NULL,NULL,NULL)) != NULL) len++;

        /* Re-store length if small enough */
        if (len < ZIPMAP_BIGLEN) zm[0] = len;
    }
    return len;
}",354.0,366.0,1.0,16.0,13.0,5,3,5,2,0,0,2,2,0,0,,0,0,2,1,1,unsigned int
7081,479242,zipmapBlobLen,1,zipmapBlobLen,size_t zipmapBlobLen (unsigned char*),zipmap.c,"size_t zipmapBlobLen(unsigned char *zm) {
    unsigned int totlen;
    zipmapLookupRaw(zm,NULL,0,&totlen);
    return totlen;
}",371.0,375.0,1.0,1.0,5.0,1,1,4,3,0,1,1,1,0,1,,0,0,2,1,1,size_t
7082,479256,zipmapValidateIntegrity,1,zipmapValidateIntegrity,"int zipmapValidateIntegrity (unsigned char*,size_t,int)",zipmap.c,"int zipmapValidateIntegrity(unsigned char *zm, size_t size, int deep) {
#define OUT_OF_RANGE(p) ( \
        (p) < zm + 2 || \
        (p) > zm + size - 1)
    unsigned int l, s, e;

    /* check that we can actually read the header (or ZIPMAP_END). */
    if (size < 2)
        return 0;

    /* the last byte must be the terminator. */
    if (zm[size-1] != ZIPMAP_END)
        return 0;

    if (!deep)
        return 1;

    unsigned int count = 0;
    unsigned char *p = zm + 1; /* skip the count */
    while(*p != ZIPMAP_END) {
        /* read the field name length encoding type */
        s = zipmapGetEncodedLengthSize(p);
        /* make sure the entry length doesn't reach outside the edge of the zipmap */
        if (OUT_OF_RANGE(p+s))
            return 0;

        /* read the field name length */
        l = zipmapDecodeLength(p);
        p += s; /* skip the encoded field size */
        p += l; /* skip the field */

        /* make sure the entry doesn't reach outside the edge...",380.0,442.0,1.0,22.0,63.0,57,14,58,8,0,4,11,15,0,4,,0,4,6,3,3,int
7083,479527,zipmapRepr,1,zipmapRepr,void zipmapRepr (unsigned char*),zipmap.h,void zipmapRepr(unsigned char *p);,47.0,47.0,6.0,33.0,1.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,void
7084,479604,zlibc_free,1,zlibc_free,void zlibc_free (void*),zmalloc.c,"void zlibc_free(void *ptr) {
    free(ptr);
}",49.0,51.0,1.0,1.0,3.0,0,0,1,1,0,0,1,1,0,0,,0,0,2,1,1,void
7085,479615,zmalloc_default_oom,1,zmalloc_default_oom,void zmalloc_default_oom (size_t),zmalloc.c,"static void zmalloc_default_oom(size_t size) {
    fprintf(stderr, ""zmalloc: Out of memory trying to allocate %zu bytes\n"",
        size);
    fflush(stderr);
    abort();
}",96.0,101.0,1.0,1.0,6.0,0,0,3,2,0,0,1,1,0,0,,0,0,2,1,1,void
7086,479627,zmalloc_oom_handler,1,zmalloc_oom_handler,void zmalloc_oom_handler (ANY),zmalloc.c,static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;,103.0,103.0,13.0,64.0,1.0,0,0,0,0,8,0,1,1,0,0,,0,0,2,1,1,void
7087,479635,ztrymalloc_usable_internal,1,ztrymalloc_usable_internal,"void* ztrymalloc_usable_internal (size_t,size_t*)",zmalloc.c,"static inline void *ztrymalloc_usable_internal(size_t size, size_t *usable) {
    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) return NULL;
    void *ptr = malloc(MALLOC_MIN_SIZE(size)+PREFIX_SIZE);

    if (!ptr) return NULL;
#ifdef HAVE_MALLOC_SIZE
    size = zmalloc_size(ptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *usable = size;
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    if (usable) *usable = size;
    return (char*)ptr+PREFIX_SIZE;
#endif
}",114.0,131.0,1.0,23.0,18.0,19,10,21,8,4,1,4,4,0,0,,0,1,4,2,2,void*
7088,479705,ztrymalloc_usable,1,ztrymalloc_usable,"void* ztrymalloc_usable (size_t,size_t*)",zmalloc.c,"void *ztrymalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrymalloc_usable_internal(size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",133.0,141.0,1.0,1.0,9.0,5,3,8,4,3,1,2,2,0,1,,0,1,4,2,2,void*
7089,479731,zmalloc,1,zmalloc,void* zmalloc (size_t),zmalloc.c,"void *zmalloc(size_t size) {
    void *ptr = ztrymalloc_usable_internal(size, NULL);
    if (!ptr) zmalloc_oom_handler(size);
    return ptr;
}",144.0,148.0,1.0,1.0,5.0,2,2,6,3,196,2,2,2,0,2,,0,1,2,1,1,void*
7090,479750,ztrymalloc,1,ztrymalloc,void* ztrymalloc (size_t),zmalloc.c,"void *ztrymalloc(size_t size) {
    void *ptr = ztrymalloc_usable_internal(size, NULL);
    return ptr;
}",151.0,154.0,1.0,1.0,4.0,1,1,4,3,3,1,1,1,0,1,,0,1,2,1,1,void*
7091,479763,zmalloc_usable,1,zmalloc_usable,"void* zmalloc_usable (size_t,size_t*)",zmalloc.c,"void *zmalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrymalloc_usable_internal(size, &usable_size);
    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",158.0,167.0,1.0,1.0,10.0,6,4,10,4,10,2,3,3,0,2,,0,1,4,2,2,void*
7092,479795,ztrycalloc_usable_internal,1,ztrycalloc_usable_internal,"void* ztrycalloc_usable_internal (size_t,size_t*)",zmalloc.c,"static inline void *ztrycalloc_usable_internal(size_t size, size_t *usable) {
    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) return NULL;
    void *ptr = calloc(1, MALLOC_MIN_SIZE(size)+PREFIX_SIZE);
    if (ptr == NULL) return NULL;

#ifdef HAVE_MALLOC_SIZE
    size = zmalloc_size(ptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *usable = size;
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    if (usable) *usable = size;
    return (char*)ptr+PREFIX_SIZE;
#endif
}",190.0,207.0,1.0,26.0,18.0,19,10,22,8,5,1,4,4,0,0,,0,1,4,2,2,void*
7093,479867,ztrycalloc_usable,1,ztrycalloc_usable,"void* ztrycalloc_usable (size_t,size_t*)",zmalloc.c,"void *ztrycalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrycalloc_usable_internal(size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",209.0,217.0,1.0,1.0,9.0,5,3,8,4,0,1,2,2,0,1,,0,1,4,2,2,void*
7094,479893,zcalloc_num,1,zcalloc_num,"void* zcalloc_num (size_t,size_t)",zmalloc.c,"void *zcalloc_num(size_t num, size_t size) {
    /* Ensure that the arguments to calloc(), when multiplied, do not wrap.
     * Division operations are susceptible to divide-by-zero errors so we also check it. */
    if ((size == 0) || (num > SIZE_MAX/size)) {
        zmalloc_oom_handler(SIZE_MAX);
        return NULL;
    }
    void *ptr = ztrycalloc_usable_internal(num*size, NULL);
    if (!ptr) zmalloc_oom_handler(num*size);
    return ptr;
}",221.0,231.0,1.0,1.0,11.0,8,7,14,5,0,3,3,3,0,3,,0,1,4,2,2,void*
7095,479932,zcalloc,1,zcalloc,void* zcalloc (size_t),zmalloc.c,"void *zcalloc(size_t size) {
    void *ptr = ztrycalloc_usable_internal(size, NULL);
    if (!ptr) zmalloc_oom_handler(size);
    return ptr;
}",234.0,238.0,1.0,1.0,5.0,2,2,6,3,26,2,2,2,0,2,,0,1,2,1,1,void*
7096,479951,ztrycalloc,1,ztrycalloc,void* ztrycalloc (size_t),zmalloc.c,"void *ztrycalloc(size_t size) {
    void *ptr = ztrycalloc_usable_internal(size, NULL);
    return ptr;
}",241.0,244.0,1.0,1.0,4.0,1,1,4,3,1,1,1,1,0,1,,0,1,2,1,1,void*
7097,479964,zcalloc_usable,1,zcalloc_usable,"void* zcalloc_usable (size_t,size_t*)",zmalloc.c,"void *zcalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrycalloc_usable_internal(size, &usable_size);
    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",248.0,257.0,1.0,1.0,10.0,6,4,10,4,1,2,3,3,0,2,,0,1,4,2,2,void*
7098,479996,ztryrealloc_usable_internal,1,ztryrealloc_usable_internal,"void* ztryrealloc_usable_internal (void*,size_t,size_t*)",zmalloc.c,"static inline void *ztryrealloc_usable_internal(void *ptr, size_t size, size_t *usable) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
#endif
    size_t oldsize;
    void *newptr;

    /* not allocating anything, just redirect to free. */
    if (size == 0 && ptr != NULL) {
        zfree(ptr);
        if (usable) *usable = 0;
        return NULL;
    }
    /* Not freeing anything, just redirect to malloc. */
    if (ptr == NULL)
        return ztrymalloc_usable(size, usable);

    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) {
        zfree(ptr);
        if (usable) *usable = 0;
        return NULL;
    }

#ifdef HAVE_MALLOC_SIZE
    oldsize = zmalloc_size(ptr);
    newptr = realloc(ptr,size);
    if (newptr == NULL) {
        if (usable) *usable = 0;
        return NULL;
    }

    update_zmalloc_stat_free(oldsize);
    size = zmalloc_size(newptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *u...",261.0,313.0,1.0,25.0,53.0,31,11,44,10,3,5,9,12,0,3,,0,2,6,3,3,void*
7099,480127,ztryrealloc_usable,1,ztryrealloc_usable,"void* ztryrealloc_usable (void*,size_t,size_t*)",zmalloc.c,"void *ztryrealloc_usable(void *ptr, size_t size, size_t *usable) {
    size_t usable_size = 0;
    ptr = ztryrealloc_usable_internal(ptr, size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",315.0,323.0,1.0,1.0,9.0,5,3,9,4,1,1,2,2,0,1,,0,1,6,3,3,void*
7100,480154,zrealloc,1,zrealloc,"void* zrealloc (void*,size_t)",zmalloc.c,"void *zrealloc(void *ptr, size_t size) {
    ptr = ztryrealloc_usable_internal(ptr, size, NULL);
    if (!ptr && size != 0) zmalloc_oom_handler(size);
    return ptr;
}",326.0,330.0,1.0,1.0,5.0,4,4,8,3,45,2,2,2,0,2,,0,1,4,2,2,void*
7101,480178,ztryrealloc,1,ztryrealloc,"void* ztryrealloc (void*,size_t)",zmalloc.c,"void *ztryrealloc(void *ptr, size_t size) {
    ptr = ztryrealloc_usable_internal(ptr, size, NULL);
    return ptr;
}",333.0,336.0,1.0,1.0,4.0,1,1,5,3,0,1,1,1,0,1,,0,1,4,2,2,void*
7102,480192,zrealloc_usable,1,zrealloc_usable,"void* zrealloc_usable (void*,size_t,size_t*)",zmalloc.c,"void *zrealloc_usable(void *ptr, size_t size, size_t *usable) {
    size_t usable_size = 0;
    ptr = ztryrealloc_usable(ptr, size, &usable_size);
    if (!ptr && size != 0) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",340.0,349.0,1.0,1.0,10.0,8,6,12,4,7,2,3,3,0,2,,0,1,6,3,3,void*
7103,480229,zmalloc_size,1,zmalloc_size,size_t zmalloc_size (void*),zmalloc.c,"size_t zmalloc_size(void *ptr) {
    void *realptr = (char*)ptr-PREFIX_SIZE;
    size_t size = *((size_t*)realptr);
    return size+PREFIX_SIZE;
}",355.0,359.0,1.0,31.0,5.0,9,6,7,4,12,0,1,1,0,0,,0,0,2,1,1,size_t
7104,480259,zmalloc_usable_size,1,zmalloc_usable_size,size_t zmalloc_usable_size (void*),zmalloc.c,"size_t zmalloc_usable_size(void *ptr) {
    return zmalloc_size(ptr)-PREFIX_SIZE;
}",360.0,362.0,1.0,29.0,3.0,2,2,2,2,3,1,1,1,0,1,,0,0,2,1,1,size_t
7105,480272,zfree,1,zfree,void zfree (void*),zmalloc.c,"void zfree(void *ptr) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char*)ptr-PREFIX_SIZE;
    oldsize = *((size_t*)realptr);
    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
    free(realptr);
#endif
}",365.0,381.0,1.0,25.0,17.0,10,7,11,6,309,1,2,2,0,0,,0,1,2,1,1,void
7106,480311,zfree_usable,1,zfree_usable,"void zfree_usable (void*,size_t*)",zmalloc.c,"void zfree_usable(void *ptr, size_t *usable) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(*usable = zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char*)ptr-PREFIX_SIZE;
    *usable = oldsize = *((size_t*)realptr);
    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
    free(realptr);
#endif
}",384.0,400.0,1.0,25.0,17.0,12,7,12,7,0,1,2,2,0,0,,0,1,4,2,2,void
7107,480354,zstrdup,1,zstrdup,char* zstrdup (char*),zmalloc.c,"char *zstrdup(const char *s) {
    size_t l = strlen(s)+1;
    char *p = zmalloc(l);

    memcpy(p,s,l);
    return p;
}",402.0,408.0,1.0,1.0,7.0,3,2,8,3,28,1,1,1,0,1,,0,1,2,1,1,char*
7108,480377,zmalloc_used_memory,1,zmalloc_used_memory,size_t zmalloc_used_memory (void),zmalloc.c,"size_t zmalloc_used_memory(void) {
    size_t um;
    atomicGet(used_memory,um);
    return um;
}",410.0,414.0,1.0,1.0,5.0,0,0,3,2,20,1,1,1,0,0,,0,1,2,1,1,size_t
7109,480388,zmalloc_set_oom_handler,1,zmalloc_set_oom_handler,void zmalloc_set_oom_handler (void),zmalloc.c,"void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
    zmalloc_oom_handler = oom_handler;
}",416.0,418.0,1.0,1.0,3.0,1,1,2,2,0,0,1,1,0,0,,0,0,2,1,1,void
7110,480396,zmadvise_dontneed,1,zmadvise_dontneed,void zmadvise_dontneed (void*),zmalloc.c,"void zmadvise_dontneed(void *ptr) {
#if defined(USE_JEMALLOC) && defined(__linux__)
    static size_t page_size = 0;
    if (page_size == 0) page_size = sysconf(_SC_PAGESIZE);
    size_t page_size_mask = page_size - 1;

    size_t real_size = zmalloc_size(ptr);
    if (real_size < page_size) return;

    /* We need to align the pointer upwards according to page size, because
     * the memory address is increased upwards and we only can free memory
     * based on page. */
    char *aligned_ptr = (char *)(((size_t)ptr+page_size_mask) & ~page_size_mask);
    real_size -= (aligned_ptr-(char*)ptr);
    if (real_size >= page_size) {
        madvise((void *)aligned_ptr, real_size&~page_size_mask, MADV_DONTNEED);
    }
#else
    (void)(ptr);
#endif
}",423.0,443.0,1.0,1.0,21.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,void
7111,480404,get_proc_stat_ll,1,get_proc_stat_ll,"int get_proc_stat_ll (int,long long*)",zmalloc.c,"int get_proc_stat_ll(int i, long long *res) {
#if defined(HAVE_PROC_STAT)
    char buf[4096];
    int fd, l;
    char *p, *x;

    if ((fd = open(""/proc/self/stat"",O_RDONLY)) == -1) return 0;
    if ((l = read(fd,buf,sizeof(buf)-1)) <= 0) {
        close(fd);
        return 0;
    }
    close(fd);
    buf[l] = '\0';
    if (buf[l-1] == '\n') buf[l-1] = '\0';

    /* Skip pid and process name (surrounded with parentheses) */
    p = strrchr(buf, ')');
    if (!p) return 0;
    p++;
    while (*p == ' ') p++;
    if (*p == '\0') return 0;
    i -= 3;
    if (i < 0) return 0;

    while (p && i--) {
        p = strchr(p, ' ');
        if (p) p++;
        else return 0;
    }
    x = strchr(p,' ');
    if (x) *x = '\0';

    *res = strtoll(p,&x,10);
    if (*x != '\0') return 0;
    return 1;
#else
    UNUSED(i);
    UNUSED(res);
    return 0;
#endif
}",462.0,502.0,1.0,4.0,41.0,2,1,4,2,0,0,1,1,0,0,,0,0,4,2,2,int
7112,480424,zmalloc_get_rss,1,zmalloc_get_rss,size_t zmalloc_get_rss (void),zmalloc.c,"size_t zmalloc_get_rss(void) {
    /* If we can't get the RSS in an OS-specific way for this system just
     * return the memory usage we estimated in zmalloc()..
     *
     * Fragmentation will appear to be always 1 (no fragmentation)
     * of course... */
    return zmalloc_used_memory();
}",618.0,625.0,1.0,1.0,8.0,0,0,0,0,1,1,1,1,0,1,,0,0,2,1,1,size_t
7113,480431,zmalloc_get_allocator_info,1,zmalloc_get_allocator_info,"int zmalloc_get_allocator_info (size_t*,size_t*,size_t*)",zmalloc.c,"int zmalloc_get_allocator_info(size_t *allocated,
                               size_t *active,
                               size_t *resident) {
    *allocated = *resident = *active = 0;
    return 1;
}",674.0,679.0,1.0,1.0,6.0,6,2,3,3,1,0,1,1,0,0,,0,0,6,3,3,int
7114,480450,set_jemalloc_bg_thread,1,set_jemalloc_bg_thread,void set_jemalloc_bg_thread (int),zmalloc.c,"void set_jemalloc_bg_thread(int enable) {
    ((void)(enable));
}",681.0,683.0,1.0,1.0,3.0,1,1,1,1,2,0,1,1,0,0,,0,0,2,1,1,void
7115,480458,jemalloc_purge,1,jemalloc_purge,int jemalloc_purge (void),zmalloc.c,"int jemalloc_purge(void) {
    return 0;
}",685.0,687.0,1.0,1.0,3.0,0,0,0,0,0,0,1,1,0,0,,0,0,2,1,1,int
7116,480465,zmalloc_get_smap_bytes_by_field,1,zmalloc_get_smap_bytes_by_field,"size_t zmalloc_get_smap_bytes_by_field (char*,long)",zmalloc.c,"size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
#if defined(__APPLE__)
    struct proc_regioninfo pri;
    if (pid == -1) pid = getpid();
    if (proc_pidinfo(pid, PROC_PIDREGIONINFO, 0, &pri,
                     PROC_PIDREGIONINFO_SIZE) == PROC_PIDREGIONINFO_SIZE)
    {
        int pagesize = getpagesize();
        if (!strcmp(field, ""Private_Dirty:"")) {
            return (size_t)pri.pri_pages_dirtied * pagesize;
        } else if (!strcmp(field, ""Rss:"")) {
            return (size_t)pri.pri_pages_resident * pagesize;
        } else if (!strcmp(field, ""AnonHugePages:"")) {
            return 0;
        }
    }
    return 0;
#endif
    ((void) field);
    ((void) pid);
    return 0;
}",745.0,766.0,1.0,1.0,22.0,2,1,2,2,2,0,1,1,0,0,,0,0,4,2,2,size_t
7117,480479,zmalloc_get_private_dirty,1,zmalloc_get_private_dirty,size_t zmalloc_get_private_dirty (long),zmalloc.c,"size_t zmalloc_get_private_dirty(long pid) {
    return zmalloc_get_smap_bytes_by_field(""Private_Dirty:"",pid);
}",774.0,776.0,1.0,1.0,3.0,0,0,1,1,1,1,1,1,0,1,,0,0,2,1,1,size_t
7118,480488,zmalloc_get_memory_size,1,zmalloc_get_memory_size,size_t zmalloc_get_memory_size (void),zmalloc.c,"size_t zmalloc_get_memory_size(void) {
#if defined(__unix__) || defined(__unix) || defined(unix) || \
    (defined(__APPLE__) && defined(__MACH__))
#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))
    int mib[2];
    mib[0] = CTL_HW;
#if defined(HW_MEMSIZE)
    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */
#elif defined(HW_PHYSMEM64)
    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */
#endif
    int64_t size = 0;               /* 64-bit */
    size_t len = sizeof(size);
    if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)
        return (size_t)size;
    return 0L;          /* Failed? */

#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)
    /* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */
    return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);

#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))
    /* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */
    i...",791.0,832.0,1.0,1.0,42.0,0,0,0,0,1,0,1,1,0,0,,0,0,2,1,1,size_t
7119,31,ACLCategoryItem,4,ACLCategoryItem,,acl.c,"struct ACLCategoryItem {
    const char *name;
    uint64_t flag;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7120,188,ACLUserFlag,4,ACLUserFlag,,acl.c,"struct ACLUserFlag {
    const char *name;
    uint64_t flag;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7121,233,ACLSelectorFlags,4,ACLSelectorFlags,,acl.c,"struct ACLSelectorFlags {
    const char *name;
    uint64_t flag;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7122,264,aclSelector,4,aclSelector,,acl.c,"typedef struct {
    uint32_t flags; /* See SELECTOR_FLAG_* */
    /* The bit in allowed_commands is set if this user has the right to
     * execute this command.
     *
     * If the bit for a given command is NOT set and the command has
     * allowed first-args, Redis will also check allowed_firstargs in order to
     * understand if the command can be executed. */
    uint64_t allowed_commands[USER_COMMAND_BITS_COUNT/64];
    /* allowed_firstargs is used by ACL rules to block access to a command unless a
     * specific argv[1] is given.
     *
     * For each command ID (corresponding to the command bit set in allowed_commands),
     * This array points to an array of SDS strings, terminated by a NULL pointer,
     * with all the first-args that are allowed for this command. When no first-arg
     * matching is used, the field is just set to NULL to avoid allocating
     * USER_COMMAND_BITS_COUNT pointers. */
    sds **allowed_firstargs;
    list *patterns;  /* A list of allow...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7123,611,keyPattern,4,keyPattern,,acl.c,"typedef struct {
    int flags; /* The CMD_KEYS_* flags for this key pattern */
    sds pattern; /* The pattern to match keys against */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7124,5421,aclKeyResultCache,4,aclKeyResultCache,,acl.c,"typedef struct {
    int keys_init;
    getKeysResult keys;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7125,8188,ACLLogEntry,4,ACLLogEntry,,acl.c,"typedef struct ACLLogEntry {
    uint64_t count;     /* Number of times this happened recently. */
    int reason;         /* Reason for denying the command. ACL_DENIED_*. */
    int context;        /* Toplevel, Lua or MULTI/EXEC? ACL_LOG_CTX_*. */
    sds object;         /* The key name or command name. */
    sds username;       /* User the client is authenticated with. */
    mstime_t ctime;     /* Milliseconds time of last update to this entry. */
    sds cinfo;          /* Client info (last client if updated). */
    long long entry_id;         /* The pair (entry_id, timestamp_created) is a unique identifier of this entry 
                                  * in case the node dies and is restarted, it can detect that if it's a new series. */
    mstime_t timestamp_created; /* UNIX time in milliseconds at the time of this entry's creation. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7126,8198,ACLLogEntry,4,ACLLogEntry,,acl.c,"typedef struct ACLLogEntry {
    uint64_t count;     /* Number of times this happened recently. */
    int reason;         /* Reason for denying the command. ACL_DENIED_*. */
    int context;        /* Toplevel, Lua or MULTI/EXEC? ACL_LOG_CTX_*. */
    sds object;         /* The key name or command name. */
    sds username;       /* User the client is authenticated with. */
    mstime_t ctime;     /* Milliseconds time of last update to this entry. */
    sds cinfo;          /* Client info (last client if updated). */
    long long entry_id;         /* The pair (entry_id, timestamp_created) is a unique identifier of this entry 
                                  * in case the node dies and is restarted, it can detect that if it's a new series. */
    mstime_t timestamp_created; /* UNIX time in milliseconds at the time of this entry's creation. */
} ACLLogEntry;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7127,11712,listNode,4,listNode,,adlist.h,"typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7128,11713,listNode,4,listNode.listNode,,adlist.h,struct listNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7129,11715,listNode,4,listNode.listNode,,adlist.h,struct listNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7130,11718,listNode,4,listNode,,adlist.h,"typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7131,11719,listIter,4,listIter,,adlist.h,"typedef struct listIter {
    listNode *next;
    int direction;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7132,11722,listIter,4,listIter,,adlist.h,"typedef struct listIter {
    listNode *next;
    int direction;
} listIter;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7133,11723,list,4,list,,adlist.h,"typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7134,11743,list,4,list,,adlist.h,"typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7135,13488,aeEventLoop,4,aeEventLoop,,ae.h,struct aeEventLoop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7136,13515,aeFileEvent,4,aeFileEvent,,ae.h,"typedef struct aeFileEvent {
    int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */
    aeFileProc *rfileProc;
    aeFileProc *wfileProc;
    void *clientData;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7137,13520,aeFileEvent,4,aeFileEvent,,ae.h,"typedef struct aeFileEvent {
    int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */
    aeFileProc *rfileProc;
    aeFileProc *wfileProc;
    void *clientData;
} aeFileEvent;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7138,13521,aeTimeEvent,4,aeTimeEvent,,ae.h,"typedef struct aeTimeEvent {
    long long id; /* time event identifier. */
    monotime when;
    aeTimeProc *timeProc;
    aeEventFinalizerProc *finalizerProc;
    void *clientData;
    struct aeTimeEvent *prev;
    struct aeTimeEvent *next;
    int refcount; /* refcount to prevent timer events from being
  		   * freed in recursive time event calls. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7139,13527,aeTimeEvent,4,aeTimeEvent.aeTimeEvent,,ae.h,struct aeTimeEvent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7140,13529,aeTimeEvent,4,aeTimeEvent.aeTimeEvent,,ae.h,struct aeTimeEvent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7141,13532,aeTimeEvent,4,aeTimeEvent,,ae.h,"typedef struct aeTimeEvent {
    long long id; /* time event identifier. */
    monotime when;
    aeTimeProc *timeProc;
    aeEventFinalizerProc *finalizerProc;
    void *clientData;
    struct aeTimeEvent *prev;
    struct aeTimeEvent *next;
    int refcount; /* refcount to prevent timer events from being
  		   * freed in recursive time event calls. */
} aeTimeEvent;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7142,13533,aeFiredEvent,4,aeFiredEvent,,ae.h,"typedef struct aeFiredEvent {
    int fd;
    int mask;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7143,13536,aeFiredEvent,4,aeFiredEvent,,ae.h,"typedef struct aeFiredEvent {
    int fd;
    int mask;
} aeFiredEvent;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7144,13537,aeEventLoop,4,aeEventLoop,,ae.h,"typedef struct aeEventLoop {
    int maxfd;   /* highest file descriptor currently registered */
    int setsize; /* max number of file descriptors tracked */
    long long timeEventNextId;
    aeFileEvent *events; /* Registered events */
    aeFiredEvent *fired; /* Fired events */
    aeTimeEvent *timeEventHead;
    int stop;
    void *apidata; /* This is used for polling API specific data */
    aeBeforeSleepProc *beforesleep;
    aeBeforeSleepProc *aftersleep;
    int flags;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7145,13549,aeEventLoop,4,aeEventLoop,,ae.h,"typedef struct aeEventLoop {
    int maxfd;   /* highest file descriptor currently registered */
    int setsize; /* max number of file descriptors tracked */
    long long timeEventNextId;
    aeFileEvent *events; /* Registered events */
    aeFiredEvent *fired; /* Fired events */
    aeTimeEvent *timeEventHead;
    int stop;
    void *apidata; /* This is used for polling API specific data */
    aeBeforeSleepProc *beforesleep;
    aeBeforeSleepProc *aftersleep;
    int flags;
} aeEventLoop;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7146,13667,aeApiState,4,aeApiState,,ae_epoll.c,"typedef struct aeApiState {
    int epfd;
    struct epoll_event *events;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7147,13669,epoll_event,4,aeApiState.epoll_event,,ae_epoll.c,struct epoll_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7148,13671,aeApiState,4,aeApiState,,ae_epoll.c,"typedef struct aeApiState {
    int epfd;
    struct epoll_event *events;
} aeApiState;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7149,14161,aeApiState,4,aeApiState,,ae_evport.c,"typedef struct aeApiState {
    int     portfd;                             /* event port */
    uint_t  npending;                           /* # of pending fds */
    int     pending_fds[MAX_EVENT_BATCHSZ];     /* pending fds */
    int     pending_masks[MAX_EVENT_BATCHSZ];   /* pending fds' masks */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7150,14178,aeApiState,4,aeApiState,,ae_evport.c,"typedef struct aeApiState {
    int     portfd;                             /* event port */
    uint_t  npending;                           /* # of pending fds */
    int     pending_fds[MAX_EVENT_BATCHSZ];     /* pending fds */
    int     pending_masks[MAX_EVENT_BATCHSZ];   /* pending fds' masks */
} aeApiState;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7151,14876,aeApiState,4,aeApiState,,ae_kqueue.c,"typedef struct aeApiState {
    int kqfd;
    struct kevent *events;

    /* Events mask for merge read and write event.
     * To reduce memory consumption, we use 2 bits to store the mask
     * of an event, so that 1 byte will store the mask of 4 events. */
    char *eventsMask; 
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7152,14878,kevent,4,aeApiState.kevent,,ae_kqueue.c,struct kevent,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7153,14881,aeApiState,4,aeApiState,,ae_kqueue.c,"typedef struct aeApiState {
    int kqfd;
    struct kevent *events;

    /* Events mask for merge read and write event.
     * To reduce memory consumption, we use 2 bits to store the mask
     * of an event, so that 1 byte will store the mask of 4 events. */
    char *eventsMask; 
} aeApiState;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7154,15519,aeApiState,4,aeApiState,,ae_select.c,"typedef struct aeApiState {
    fd_set rfds, wfds;
    /* We need to have a copy of the fd sets as it's not safe to reuse
     * FD sets after select(). */
    fd_set _rfds, _wfds;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7155,15524,aeApiState,4,aeApiState,,ae_select.c,"typedef struct aeApiState {
    fd_set rfds, wfds;
    /* We need to have a copy of the fd sets as it's not safe to reuse
     * FD sets after select(). */
    fd_set _rfds, _wfds;
} aeApiState;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7156,28102,bio_job,4,bio_job,,bio.c,"typedef union bio_job {
    struct {
        int type; /* Job-type tag. This needs to appear as the first element in all union members. */
    } header;

    /* Job specific arguments.*/
    struct {
        int type;
        int fd; /* Fd for file based background jobs */
        long long offset; /* A job-specific offset, if applicable */
        unsigned need_fsync:1; /* A flag to indicate that a fsync is required before
                                * the file is closed. */
        unsigned need_reclaim_cache:1; /* A flag to indicate that reclaim cache is required before
                                * the file is closed. */
    } fd_args;

    struct {
        int type;
        lazy_free_fn *free_fn; /* Function that will free the provided arguments */
        void *free_args[]; /* List of arguments to be passed to the free function */
    } free_args;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7157,28103,bio_job.header,4,bio_job.header,,bio.c,"struct {
        int type; /* Job-type tag. This needs to appear as the first element in all union members. */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7158,28106,bio_job.fd_args,4,bio_job.fd_args,,bio.c,"struct {
        int type;
        int fd; /* Fd for file based background jobs */
        long long offset; /* A job-specific offset, if applicable */
        unsigned need_fsync:1; /* A flag to indicate that a fsync is required before
                                * the file is closed. */
        unsigned need_reclaim_cache:1; /* A flag to indicate that reclaim cache is required before
                                * the file is closed. */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7159,28113,bio_job.free_args,4,bio_job.free_args,,bio.c,"struct {
        int type;
        lazy_free_fn *free_fn; /* Function that will free the provided arguments */
        void *free_args[]; /* List of arguments to be passed to the free function */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7160,28123,bio_job,4,bio_job,,bio.c,"typedef union bio_job {
    struct {
        int type; /* Job-type tag. This needs to appear as the first element in all union members. */
    } header;

    /* Job specific arguments.*/
    struct {
        int type;
        int fd; /* Fd for file based background jobs */
        long long offset; /* A job-specific offset, if applicable */
        unsigned need_fsync:1; /* A flag to indicate that a fsync is required before
                                * the file is closed. */
        unsigned need_reclaim_cache:1; /* A flag to indicate that reclaim cache is required before
                                * the file is closed. */
    } fd_args;

    struct {
        int type;
        lazy_free_fn *free_fn; /* Function that will free the provided arguments */
        void *free_args[]; /* List of arguments to be passed to the free function */
    } free_args;
} bio_job;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7161,29148,anonymous_enum_0,4,anonymous_enum_0,,bio.h,"enum {
    BIO_CLOSE_FILE = 0, /* Deferred close(2) syscall. */
    BIO_AOF_FSYNC,      /* Deferred AOF fsync. */
    BIO_LAZY_FREE,      /* Deferred objects freeing. */
    BIO_CLOSE_AOF,      /* Deferred close for AOF files. */
    BIO_NUM_OPS
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7162,33122,bitfieldOp,4,bitfieldOp,,bitops.c,"struct bitfieldOp {
    uint64_t offset;    /* Bitfield offset. */
    int64_t i64;        /* Increment amount (INCRBY) or SET value */
    int opcode;         /* Operation id. */
    int owtype;         /* Overflow type to use. */
    int bits;           /* Integer bitfield bits width. */
    int sign;           /* True if signed, otherwise unsigned op. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7163,36205,CallReply,4,CallReply,,call_reply.c,"struct CallReply {
    void *private_data;
    sds original_proto; /* Available only for root reply. */
    const char *proto;
    size_t proto_len;
    int type;       /* REPLY_... */
    int flags;      /* REPLY_FLAG... */
    size_t len;     /* Length of a string, or the number elements in an array. */
    union {
        const char *str; /* String pointer for string and error replies. This
                          * does not need to be freed, always points inside
                          * a reply->proto buffer of the reply object or, in
                          * case of array elements, of parent reply objects. */
        struct {
            const char *str;
            const char *format;
        } verbatim_str;  /* Reply value for verbatim string */
        long long ll;    /* Reply value for integer reply. */
        double d;        /* Reply value for double reply. */
        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribut...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7164,36213,CallReply.val,4,CallReply.val,,call_reply.c,"union {
        const char *str; /* String pointer for string and error replies. This
                          * does not need to be freed, always points inside
                          * a reply->proto buffer of the reply object or, in
                          * case of array elements, of parent reply objects. */
        struct {
            const char *str;
            const char *format;
        } verbatim_str;  /* Reply value for verbatim string */
        long long ll;    /* Reply value for integer reply. */
        double d;        /* Reply value for double reply. */
        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7165,36215,CallReply.val.verbatim_str,4,CallReply.val.verbatim_str,,call_reply.c,"struct {
            const char *str;
            const char *format;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7166,36221,CallReply,4,CallReply.val.CallReply,,call_reply.c,struct CallReply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7167,36225,CallReply,4,CallReply.CallReply,,call_reply.c,struct CallReply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7168,37865,CallReply,4,CallReply,,call_reply.h,typedef struct CallReply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7169,37866,CallReply,4,CallReply,,call_reply.h,typedef struct CallReply CallReply;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7170,38006,child_info_data,4,child_info_data,,childinfo.c,"typedef struct {
    size_t keys;
    size_t cow;
    monotime cow_updated;
    double progress;
    childInfoType information_type; /* Type of information */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7171,38558,cliCommandArg,4,cliCommandArg,,cli_commands.h,"typedef struct cliCommandArg {
    char *name;
    redisCommandArgType type;
    char *token;
    char *since;
    int flags;
    int numsubargs;
    struct cliCommandArg *subargs;
    const char *display_text;

    /*
     * For use at runtime.
     * Fields used to keep track of input word matches for command-line hinting.
     */
    int matched;  /* How many input words have been matched by this argument? */
    int matched_token;  /* Has the token been matched? */
    int matched_name;  /* Has the name been matched? */
    int matched_all;  /* Has the whole argument been consumed (no hint needed)? */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7172,38565,cliCommandArg,4,cliCommandArg.cliCommandArg,,cli_commands.h,struct cliCommandArg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7173,38572,cliCommandArg,4,cliCommandArg,,cli_commands.h,"typedef struct cliCommandArg {
    char *name;
    redisCommandArgType type;
    char *token;
    char *since;
    int flags;
    int numsubargs;
    struct cliCommandArg *subargs;
    const char *display_text;

    /*
     * For use at runtime.
     * Fields used to keep track of input word matches for command-line hinting.
     */
    int matched;  /* How many input words have been matched by this argument? */
    int matched_token;  /* Has the token been matched? */
    int matched_name;  /* Has the name been matched? */
    int matched_all;  /* Has the whole argument been consumed (no hint needed)? */
} cliCommandArg;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7174,38573,commandDocs,4,commandDocs,,cli_commands.h,"struct commandDocs {
    char *name;
    char *summary;
    char *group;
    char *since;
    int numargs;
    cliCommandArg *args; /* An array of the command arguments. */
    struct commandDocs *subcommands;
    char *params; /* A string describing the syntax of the command arguments. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7175,38580,commandDocs,4,commandDocs.commandDocs,,cli_commands.h,struct commandDocs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7176,38583,commandDocs,4,commandDocs,,cli_commands.h,extern struct commandDocs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7177,39446,cliSSLconfig,4,cliSSLconfig,,cli_common.h,"typedef struct cliSSLconfig {
    /* Requested SNI, or NULL */
    char *sni;
    /* CA Certificate file, or NULL */
    char *cacert;
    /* Directory where trusted CA certificates are stored, or NULL */
    char *cacertdir;
    /* Skip server certificate verification. */
    int skip_cert_verify;
    /* Client certificate to authenticate with, or NULL */
    char *cert;
    /* Private key file to authenticate with, or NULL */
    char *key;
    /* Preferred cipher list, or NULL (applies only to <= TLSv1.2) */
    char* ciphers;
    /* Preferred ciphersuites list, or NULL (applies only to TLSv1.3) */
    char* ciphersuites;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7178,39455,cliSSLconfig,4,cliSSLconfig,,cli_common.h,"typedef struct cliSSLconfig {
    /* Requested SNI, or NULL */
    char *sni;
    /* CA Certificate file, or NULL */
    char *cacert;
    /* Directory where trusted CA certificates are stored, or NULL */
    char *cacertdir;
    /* Skip server certificate verification. */
    int skip_cert_verify;
    /* Client certificate to authenticate with, or NULL */
    char *cert;
    /* Private key file to authenticate with, or NULL */
    char *key;
    /* Preferred cipher list, or NULL (applies only to <= TLSv1.2) */
    char* ciphers;
    /* Preferred ciphersuites list, or NULL (applies only to TLSv1.3) */
    char* ciphersuites;
} cliSSLconfig;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7179,39456,cliConnInfo,4,cliConnInfo,,cli_common.h,"typedef struct cliConnInfo {
    char *hostip;
    int hostport;
    int input_dbnum;
    char *auth;
    char *user;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7180,39462,cliConnInfo,4,cliConnInfo,,cli_common.h,"typedef struct cliConnInfo {
    char *hostip;
    int hostport;
    int input_dbnum;
    char *auth;
    char *user;
} cliConnInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7181,39988,auxFieldHandler,4,auxFieldHandler,,cluster.c,"typedef struct {
    char *field;
    aux_value_setter *setter;
    aux_value_getter *getter;
    aux_value_present *isPresent;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7182,39994,auxFieldIndex,4,auxFieldIndex,,cluster.c,"typedef enum {
    af_shard_id,
    af_human_nodename,
    af_tcp_port,
    af_tls_port,
    af_count,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7183,40440,clusterMsgSendBlock,4,clusterMsgSendBlock,,cluster.c,"typedef struct {
    size_t totlen; /* Total length of this block including the message */
    int refcount;  /* Number of cluster link send msg queues containing the message */
    clusterMsg msg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7184,57169,redisNodeFlags,4,redisNodeFlags,,cluster.c,"struct redisNodeFlags {
    uint16_t flag;
    char *name;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7185,57172,redisNodeFlags,4,redisNodeFlags,,cluster.c,static struct redisNodeFlags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7186,63290,migrateCachedSocket,4,migrateCachedSocket,,cluster.c,"typedef struct migrateCachedSocket {
    connection *conn;
    long last_dbid;
    time_t last_use_time;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7187,63294,migrateCachedSocket,4,migrateCachedSocket,,cluster.c,"typedef struct migrateCachedSocket {
    connection *conn;
    long last_dbid;
    time_t last_use_time;
} migrateCachedSocket;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7188,66719,clusterNode,4,clusterNode,,cluster.h,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7189,66720,clusterLink,4,clusterLink,,cluster.h,"typedef struct clusterLink {
    mstime_t ctime;             /* Link creation time */
    connection *conn;           /* Connection to remote node */
    list *send_msg_queue;        /* List of messages to be sent */
    size_t head_msg_send_offset; /* Number of bytes already sent of message at head of queue */
    unsigned long long send_msg_queue_mem; /* Memory in bytes used by message queue */
    char *rcvbuf;               /* Packet reception buffer */
    size_t rcvbuf_len;          /* Used size of rcvbuf */
    size_t rcvbuf_alloc;        /* Allocated size of rcvbuf */
    struct clusterNode *node;   /* Node related to this link. Initialized to NULL when unknown */
    int inbound;                /* 1 if this link is an inbound link accepted from the related node */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7190,66729,clusterNode,4,clusterLink.clusterNode,,cluster.h,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7191,66732,clusterLink,4,clusterLink,,cluster.h,"typedef struct clusterLink {
    mstime_t ctime;             /* Link creation time */
    connection *conn;           /* Connection to remote node */
    list *send_msg_queue;        /* List of messages to be sent */
    size_t head_msg_send_offset; /* Number of bytes already sent of message at head of queue */
    unsigned long long send_msg_queue_mem; /* Memory in bytes used by message queue */
    char *rcvbuf;               /* Packet reception buffer */
    size_t rcvbuf_len;          /* Used size of rcvbuf */
    size_t rcvbuf_alloc;        /* Allocated size of rcvbuf */
    struct clusterNode *node;   /* Node related to this link. Initialized to NULL when unknown */
    int inbound;                /* 1 if this link is an inbound link accepted from the related node */
} clusterLink;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7192,66733,clusterNodeFailReport,4,clusterNodeFailReport,,cluster.h,"typedef struct clusterNodeFailReport {
    struct clusterNode *node;  /* Node reporting the failure condition. */
    mstime_t time;             /* Time of the last report from this node. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7193,66734,clusterNode,4,clusterNodeFailReport.clusterNode,,cluster.h,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7194,66737,clusterNodeFailReport,4,clusterNodeFailReport,,cluster.h,"typedef struct clusterNodeFailReport {
    struct clusterNode *node;  /* Node reporting the failure condition. */
    mstime_t time;             /* Time of the last report from this node. */
} clusterNodeFailReport;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7195,66738,clusterNode,4,clusterNode,,cluster.h,"typedef struct clusterNode {
    mstime_t ctime; /* Node object creation time. */
    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
    char shard_id[CLUSTER_NAMELEN]; /* shard id, hex string, sha1-size */
    int flags;      /* CLUSTER_NODE_... */
    uint64_t configEpoch; /* Last configEpoch observed for this node */
    unsigned char slots[CLUSTER_SLOTS/8]; /* slots handled by this node */
    uint16_t *slot_info_pairs; /* Slots info represented as (start/end) pair (consecutive index). */
    int slot_info_pairs_count; /* Used number of slots in slot_info_pairs */
    int numslots;   /* Number of slots handled by this node */
    int numslaves;  /* Number of slave nodes, if this is a master */
    struct clusterNode **slaves; /* pointers to slave nodes */
    struct clusterNode *slaveof; /* pointer to the master node. Note that it
                                    may be NULL even if the node is a slave
                                    if we don't have t...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7196,66749,clusterNode,4,clusterNode.clusterNode,,cluster.h,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7197,66751,clusterNode,4,clusterNode.clusterNode,,cluster.h,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7198,66791,clusterNode,4,clusterNode,,cluster.h,"typedef struct clusterNode {
    mstime_t ctime; /* Node object creation time. */
    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
    char shard_id[CLUSTER_NAMELEN]; /* shard id, hex string, sha1-size */
    int flags;      /* CLUSTER_NODE_... */
    uint64_t configEpoch; /* Last configEpoch observed for this node */
    unsigned char slots[CLUSTER_SLOTS/8]; /* slots handled by this node */
    uint16_t *slot_info_pairs; /* Slots info represented as (start/end) pair (consecutive index). */
    int slot_info_pairs_count; /* Used number of slots in slot_info_pairs */
    int numslots;   /* Number of slots handled by this node */
    int numslaves;  /* Number of slave nodes, if this is a master */
    struct clusterNode **slaves; /* pointers to slave nodes */
    struct clusterNode *slaveof; /* pointer to the master node. Note that it
                                    may be NULL even if the node is a slave
                                    if we don't have t...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7199,66792,slotToKeys,4,slotToKeys,,cluster.h,"typedef struct slotToKeys {
    uint64_t count;             /* Number of keys in the slot. */
    dictEntry *head;            /* The first key-value entry in the slot. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7200,66795,slotToKeys,4,slotToKeys,,cluster.h,"typedef struct slotToKeys {
    uint64_t count;             /* Number of keys in the slot. */
    dictEntry *head;            /* The first key-value entry in the slot. */
} slotToKeys;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7201,66796,clusterSlotToKeyMapping,4,clusterSlotToKeyMapping,,cluster.h,"struct clusterSlotToKeyMapping {
    slotToKeys by_slot[CLUSTER_SLOTS];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7202,66806,clusterDictEntryMetadata,4,clusterDictEntryMetadata,,cluster.h,"typedef struct clusterDictEntryMetadata {
    dictEntry *prev;            /* Prev entry with key in the same slot */
    dictEntry *next;            /* Next entry with key in the same slot */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7203,66809,clusterDictEntryMetadata,4,clusterDictEntryMetadata,,cluster.h,"typedef struct clusterDictEntryMetadata {
    dictEntry *prev;            /* Prev entry with key in the same slot */
    dictEntry *next;            /* Next entry with key in the same slot */
} clusterDictEntryMetadata;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7204,66810,clusterDictMetadata,4,clusterDictMetadata,,cluster.h,"typedef struct {
    redisDb *db;                /* A link back to the db this dict belongs to */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7205,66813,clusterState,4,clusterState,,cluster.h,"typedef struct clusterState {
    clusterNode *myself;  /* This node */
    uint64_t currentEpoch;
    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */
    int size;             /* Num of master nodes with at least one slot */
    dict *nodes;          /* Hash table of name -> clusterNode structures */
    dict *shards;         /* Hash table of shard_id -> list (of nodes) structures */
    dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */
    clusterNode *migrating_slots_to[CLUSTER_SLOTS];
    clusterNode *importing_slots_from[CLUSTER_SLOTS];
    clusterNode *slots[CLUSTER_SLOTS];
    rax *slots_to_channels;
    /* The following fields are used to take the slave state on elections. */
    mstime_t failover_auth_time; /* Time of previous or next election. */
    int failover_auth_count;    /* Number of votes received so far. */
    int failover_auth_sent;     /* True if we already asked for votes. */
    int failover_auth_rank;     /* This slave rank for...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7206,66872,clusterState,4,clusterState,,cluster.h,"typedef struct clusterState {
    clusterNode *myself;  /* This node */
    uint64_t currentEpoch;
    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */
    int size;             /* Num of master nodes with at least one slot */
    dict *nodes;          /* Hash table of name -> clusterNode structures */
    dict *shards;         /* Hash table of shard_id -> list (of nodes) structures */
    dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */
    clusterNode *migrating_slots_to[CLUSTER_SLOTS];
    clusterNode *importing_slots_from[CLUSTER_SLOTS];
    clusterNode *slots[CLUSTER_SLOTS];
    rax *slots_to_channels;
    /* The following fields are used to take the slave state on elections. */
    mstime_t failover_auth_time; /* Time of previous or next election. */
    int failover_auth_count;    /* Number of votes received so far. */
    int failover_auth_sent;     /* True if we already asked for votes. */
    int failover_auth_rank;     /* This slave rank for...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7207,66873,clusterMsgDataGossip,4,clusterMsgDataGossip,,cluster.h,"typedef struct {
    char nodename[CLUSTER_NAMELEN];
    uint32_t ping_sent;
    uint32_t pong_received;
    char ip[NET_IP_STR_LEN];  /* IP address last time it was seen */
    uint16_t port;              /* primary port last time it was seen */
    uint16_t cport;             /* cluster port last time it was seen */
    uint16_t flags;             /* node->flags copy */
    uint16_t pport;             /* secondary port last time it was seen */
    uint16_t notused1;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7208,66894,clusterMsgDataFail,4,clusterMsgDataFail,,cluster.h,"typedef struct {
    char nodename[CLUSTER_NAMELEN];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7209,66905,clusterMsgDataPublish,4,clusterMsgDataPublish,,cluster.h,"typedef struct {
    uint32_t channel_len;
    uint32_t message_len;
    unsigned char bulk_data[8]; /* 8 bytes just as placeholder. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7210,66916,clusterMsgDataUpdate,4,clusterMsgDataUpdate,,cluster.h,"typedef struct {
    uint64_t configEpoch; /* Config epoch of the specified instance. */
    char nodename[CLUSTER_NAMELEN]; /* Name of the slots owner. */
    unsigned char slots[CLUSTER_SLOTS/8]; /* Slots bitmap. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7211,66935,clusterMsgModule,4,clusterMsgModule,,cluster.h,"typedef struct {
    uint64_t module_id;     /* ID of the sender module. */
    uint32_t len;           /* ID of the sender module. */
    uint8_t type;           /* Type from 0 to 255. */
    unsigned char bulk_data[3]; /* 3 bytes just as placeholder. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7212,66947,clusterMsgPingtypes,4,clusterMsgPingtypes,,cluster.h,"typedef enum {
    CLUSTERMSG_EXT_TYPE_HOSTNAME,
    CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME,
    CLUSTERMSG_EXT_TYPE_FORGOTTEN_NODE,
    CLUSTERMSG_EXT_TYPE_SHARDID,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7213,66953,clusterMsgPingExtHostname,4,clusterMsgPingExtHostname,,cluster.h,"typedef struct {
    char hostname[1]; /* The announced hostname, ends with \0. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7214,66962,clusterMsgPingExtHumanNodename,4,clusterMsgPingExtHumanNodename,,cluster.h,"typedef struct {
    char human_nodename[1]; /* The announced nodename, ends with \0. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7215,66971,clusterMsgPingExtForgottenNode,4,clusterMsgPingExtForgottenNode,,cluster.h,"typedef struct {
    char name[CLUSTER_NAMELEN]; /* Node name. */
    uint64_t ttl; /* Remaining time to blacklist the node, in seconds. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7216,66984,clusterMsgPingExtShardId,4,clusterMsgPingExtShardId,,cluster.h,"typedef struct {
    char shard_id[CLUSTER_NAMELEN]; /* The shard_id, 40 bytes fixed. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7217,66995,clusterMsgPingExt,4,clusterMsgPingExt,,cluster.h,"typedef struct {
    uint32_t length; /* Total length of this extension message (including this header) */
    uint16_t type; /* Type of this extension message (see clusterMsgPingExtTypes) */
    uint16_t unused; /* 16 bits of padding to make this structure 8 byte aligned. */
    union {
        clusterMsgPingExtHostname hostname;
	clusterMsgPingExtHumanNodename human_nodename;
        clusterMsgPingExtForgottenNode forgotten_node;
        clusterMsgPingExtShardId shard_id;
    } ext[]; /* Actual extension information, formatted so that the data is 8 
              * byte aligned, regardless of its content. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7218,66999,clusterMsgPingExt.ext,4,clusterMsgPingExt.ext,,cluster.h,"union {
        clusterMsgPingExtHostname hostname;
	clusterMsgPingExtHumanNodename human_nodename;
        clusterMsgPingExtForgottenNode forgotten_node;
        clusterMsgPingExtShardId shard_id;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7219,67011,clusterMsgData,4,clusterMsgData,,cluster.h,"union clusterMsgData {
    /* PING, MEET and PONG */
    struct {
        /* Array of N clusterMsgDataGossip structures */
        clusterMsgDataGossip gossip[1];
        /* Extension data that can optionally be sent for ping/meet/pong
         * messages. We can't explicitly define them here though, since
         * the gossip array isn't the real length of the gossip data. */
    } ping;

    /* FAIL */
    struct {
        clusterMsgDataFail about;
    } fail;

    /* PUBLISH */
    struct {
        clusterMsgDataPublish msg;
    } publish;

    /* UPDATE */
    struct {
        clusterMsgDataUpdate nodecfg;
    } update;

    /* MODULE */
    struct {
        clusterMsgModule msg;
    } module;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7220,67012,clusterMsgData.ping,4,clusterMsgData.ping,,cluster.h,"struct {
        /* Array of N clusterMsgDataGossip structures */
        clusterMsgDataGossip gossip[1];
        /* Extension data that can optionally be sent for ping/meet/pong
         * messages. We can't explicitly define them here though, since
         * the gossip array isn't the real length of the gossip data. */
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7221,67021,clusterMsgData.fail,4,clusterMsgData.fail,,cluster.h,"struct {
        clusterMsgDataFail about;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7222,67024,clusterMsgData.publish,4,clusterMsgData.publish,,cluster.h,"struct {
        clusterMsgDataPublish msg;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7223,67027,clusterMsgData.update,4,clusterMsgData.update,,cluster.h,"struct {
        clusterMsgDataUpdate nodecfg;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7224,67030,clusterMsgData.module,4,clusterMsgData.module,,cluster.h,"struct {
        clusterMsgModule msg;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7225,67033,clusterMsg,4,clusterMsg,,cluster.h,"typedef struct {
    char sig[4];        /* Signature ""RCmb"" (Redis Cluster message bus). */
    uint32_t totlen;    /* Total length of this message */
    uint16_t ver;       /* Protocol version, currently set to 1. */
    uint16_t port;      /* Primary port number (TCP or TLS). */
    uint16_t type;      /* Message type */
    uint16_t count;     /* Only used for some kind of messages. */
    uint64_t currentEpoch;  /* The epoch accordingly to the sending node. */
    uint64_t configEpoch;   /* The config epoch if it's a master, or the last
                               epoch advertised by its master if it is a
                               slave. */
    uint64_t offset;    /* Master replication offset if node is a master or
                           processed replication offset if node is a slave. */
    char sender[CLUSTER_NAMELEN]; /* Name of the sender node */
    unsigned char myslots[CLUSTER_SLOTS/8];
    char slaveof[CLUSTER_NAMELEN];
    char myip[NET_IP_STR_LEN];    /*...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7226,67054,clusterMsgData,4,clusterMsg.clusterMsgData,,cluster.h,union clusterMsgData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7227,67310,redisCommandArgType,4,redisCommandArgType,,commands.h,"typedef enum {
    ARG_TYPE_STRING,
    ARG_TYPE_INTEGER,
    ARG_TYPE_DOUBLE,
    ARG_TYPE_KEY, /* A string, but represents a keyname */
    ARG_TYPE_PATTERN,
    ARG_TYPE_UNIX_TIME,
    ARG_TYPE_PURE_TOKEN,
    ARG_TYPE_ONEOF, /* Has subargs */
    ARG_TYPE_BLOCK /* Has subargs */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7228,67321,redisCommandArg,4,redisCommandArg,,commands.h,"typedef struct redisCommandArg {
    const char *name;
    redisCommandArgType type;
    int key_spec_index;
    const char *token;
    const char *summary;
    const char *since;
    int flags;
    const char *deprecated_since;
    int num_args;
    struct redisCommandArg *subargs;
    const char *display_text;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7229,67331,redisCommandArg,4,redisCommandArg.redisCommandArg,,commands.h,struct redisCommandArg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7230,67334,redisCommandArg,4,redisCommandArg,,commands.h,"typedef struct redisCommandArg {
    const char *name;
    redisCommandArgType type;
    int key_spec_index;
    const char *token;
    const char *summary;
    const char *since;
    int flags;
    const char *deprecated_since;
    int num_args;
    struct redisCommandArg *subargs;
    const char *display_text;
} redisCommandArg;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7231,67365,deprecatedConfig,4,deprecatedConfig,,config.c,"typedef struct deprecatedConfig {
    const char *name;
    const int argc_min;
    const int argc_max;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7232,67369,deprecatedConfig,4,deprecatedConfig,,config.c,"typedef struct deprecatedConfig {
    const char *name;
    const int argc_min;
    const int argc_max;
} deprecatedConfig;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7233,67809,boolConfigData,4,boolConfigData,,config.c,"typedef struct boolConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7234,67818,boolConfigData,4,boolConfigData,,config.c,"typedef struct boolConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
} boolConfigData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7235,67819,stringConfigData,4,stringConfigData,,config.c,"typedef struct stringConfigData {
    char **config; /* Pointer to the server config this value is stored in. */
    const char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(char* val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty strings should
                                  be stored as a NULL value. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7236,67829,stringConfigData,4,stringConfigData,,config.c,"typedef struct stringConfigData {
    char **config; /* Pointer to the server config this value is stored in. */
    const char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(char* val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty strings should
                                  be stored as a NULL value. */
} stringConfigData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7237,67830,sdsConfigData,4,sdsConfigData,,config.c,"typedef struct sdsConfigData {
    sds *config; /* Pointer to the server config this value is stored in. */
    char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(sds val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty SDS strings should
                                  be stored as a NULL value. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7238,67840,sdsConfigData,4,sdsConfigData,,config.c,"typedef struct sdsConfigData {
    sds *config; /* Pointer to the server config this value is stored in. */
    char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(sds val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty SDS strings should
                                  be stored as a NULL value. */
} sdsConfigData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7239,67841,enumConfigData,4,enumConfigData,,config.c,"typedef struct enumConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    configEnum *enum_value; /* The underlying enum type this data represents */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7240,67851,enumConfigData,4,enumConfigData,,config.c,"typedef struct enumConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    configEnum *enum_value; /* The underlying enum type this data represents */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
} enumConfigData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7241,67852,numericType,4,numericType,,config.c,"typedef enum numericType {
    NUMERIC_TYPE_INT,
    NUMERIC_TYPE_UINT,
    NUMERIC_TYPE_LONG,
    NUMERIC_TYPE_ULONG,
    NUMERIC_TYPE_LONG_LONG,
    NUMERIC_TYPE_ULONG_LONG,
    NUMERIC_TYPE_SIZE_T,
    NUMERIC_TYPE_SSIZE_T,
    NUMERIC_TYPE_OFF_T,
    NUMERIC_TYPE_TIME_T,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7242,67863,numericType,4,numericType,,config.c,"typedef enum numericType {
    NUMERIC_TYPE_INT,
    NUMERIC_TYPE_UINT,
    NUMERIC_TYPE_LONG,
    NUMERIC_TYPE_ULONG,
    NUMERIC_TYPE_LONG_LONG,
    NUMERIC_TYPE_ULONG_LONG,
    NUMERIC_TYPE_SIZE_T,
    NUMERIC_TYPE_SSIZE_T,
    NUMERIC_TYPE_OFF_T,
    NUMERIC_TYPE_TIME_T,
} numericType;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7243,67864,numericConfigData,4,numericConfigData,,config.c,"typedef struct numericConfigData {
    union {
        int *i;
        unsigned int *ui;
        long *l;
        unsigned long *ul;
        long long *ll;
        unsigned long long *ull;
        size_t *st;
        ssize_t *sst;
        off_t *ot;
        time_t *tt;
    } config; /* The pointer to the numeric config this value is stored in */
    unsigned int flags;
    numericType numeric_type; /* An enum indicating the type of this value */
    long long lower_bound; /* The lower bound of this numeric value */
    long long upper_bound; /* The upper bound of this numeric value */
    long long default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(long long val, const char **err); /* Optional function to check validity of new value (generic doc above) */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7244,67865,numericConfigData.config,4,numericConfigData.config,,config.c,"union {
        int *i;
        unsigned int *ui;
        long *l;
        unsigned long *ul;
        long long *ll;
        unsigned long long *ull;
        size_t *st;
        ssize_t *sst;
        off_t *ot;
        time_t *tt;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7245,67888,numericConfigData,4,numericConfigData,,config.c,"typedef struct numericConfigData {
    union {
        int *i;
        unsigned int *ui;
        long *l;
        unsigned long *ul;
        long long *ll;
        unsigned long long *ull;
        size_t *st;
        ssize_t *sst;
        off_t *ot;
        time_t *tt;
    } config; /* The pointer to the numeric config this value is stored in */
    unsigned int flags;
    numericType numeric_type; /* An enum indicating the type of this value */
    long long lower_bound; /* The lower bound of this numeric value */
    long long upper_bound; /* The upper bound of this numeric value */
    long long default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(long long val, const char **err); /* Optional function to check validity of new value (generic doc above) */
} numericConfigData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7246,67889,typeData,4,typeData,,config.c,"typedef union typeData {
    boolConfigData yesno;
    stringConfigData string;
    sdsConfigData sds;
    enumConfigData enumd;
    numericConfigData numeric;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7247,67895,typeData,4,typeData,,config.c,"typedef union typeData {
    boolConfigData yesno;
    stringConfigData string;
    sdsConfigData sds;
    enumConfigData enumd;
    numericConfigData numeric;
} typeData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7248,67896,standardConfig,4,standardConfig,,config.c,typedef struct standardConfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7249,67897,standardConfig,4,standardConfig,,config.c,typedef struct standardConfig standardConfig;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7250,67903,typeInterface,4,typeInterface,,config.c,"typedef struct typeInterface {
    /* Called on server start, to init the server with default value */
    void (*init)(standardConfig *config);
    /* Called on server startup and CONFIG SET, returns 1 on success,
     * 2 meaning no actual change done, 0 on error and can set a verbose err
     * string */
    int (*set)(standardConfig *config, sds *argv, int argc, const char **err);
    /* Optional: called after `set()` to apply the config change. Used only in
     * the context of CONFIG SET. Returns 1 on success, 0 on failure.
     * Optionally set err to a static error string. */
    apply_fn apply;
    /* Called on CONFIG GET, returns sds to be used in reply */
    sds (*get)(standardConfig *config);
    /* Called on CONFIG REWRITE, required to rewrite the config state */
    void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7251,67930,typeInterface,4,typeInterface,,config.c,"typedef struct typeInterface {
    /* Called on server start, to init the server with default value */
    void (*init)(standardConfig *config);
    /* Called on server startup and CONFIG SET, returns 1 on success,
     * 2 meaning no actual change done, 0 on error and can set a verbose err
     * string */
    int (*set)(standardConfig *config, sds *argv, int argc, const char **err);
    /* Optional: called after `set()` to apply the config change. Used only in
     * the context of CONFIG SET. Returns 1 on success, 0 on failure.
     * Optionally set err to a static error string. */
    apply_fn apply;
    /* Called on CONFIG GET, returns sds to be used in reply */
    sds (*get)(standardConfig *config);
    /* Called on CONFIG REWRITE, required to rewrite the config state */
    void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);
} typeInterface;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7252,67931,standardConfig,4,standardConfig,,config.c,"struct standardConfig {
    const char *name; /* The user visible name of this config */
    const char *alias; /* An alias that can also be used for this config */
    unsigned int flags; /* Flags for this specific config */
    typeInterface interface; /* The function pointers that define the type interface */
    typeData data; /* The type specific data exposed used by the interface */
    configType type; /* The type of config this is. */
    void *privdata; /* privdata for this config, for module configs this is a ModuleConfig struct */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7253,70733,rewriteConfigState,4,rewriteConfigState,,config.c,"struct rewriteConfigState {
    dict *option_to_line; /* Option -> list of config file lines map */
    dict *rewritten;      /* Dictionary of already processed options */
    int numlines;         /* Number of lines in current config */
    sds *lines;           /* Current lines as an array of sds strings */
    int needs_signature;  /* True if we need to append the rewrite
                             signature. */
    int force_write;      /* True if we want all keywords to be force
                             written. Currently only used for testing
                             and debug information. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7254,98080,aeEventLoop,4,aeEventLoop,,connection.h,struct aeEventLoop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7255,98081,connection,4,connection,,connection.h,typedef struct connection,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7256,98082,connection,4,connection,,connection.h,typedef struct connection connection;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7257,98083,connListener,4,connListener,,connection.h,typedef struct connListener,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7258,98084,connListener,4,connListener,,connection.h,typedef struct connListener connListener;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7259,98085,ConnectionState,4,ConnectionState,,connection.h,"typedef enum {
    CONN_STATE_NONE = 0,
    CONN_STATE_CONNECTING,
    CONN_STATE_ACCEPTING,
    CONN_STATE_CONNECTED,
    CONN_STATE_CLOSED,
    CONN_STATE_ERROR
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7260,98105,ConnectionType,4,ConnectionType,,connection.h,"typedef struct ConnectionType {
    /* connection type */
    const char *(*get_type)(struct connection *conn);

    /* connection type initialize & finalize & configure */
    void (*init)(void); /* auto-call during register */
    void (*cleanup)(void);
    int (*configure)(void *priv, int reconfigure);

    /* ae & accept & listen & error & address handler */
    void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);
    aeFileProc *accept_handler;
    int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);
    int (*is_local)(connection *conn);
    int (*listen)(connListener *listener);

    /* create/shutdown/close connection */
    connection* (*conn_create)(void);
    connection* (*conn_create_accepted)(int fd, void *priv);
    void (*shutdown)(struct connection *conn);
    void (*close)(struct connection *conn);

    /* connect & accept */
    int (*connect)(struct connection *conn, const char *addr, int port, const char *sourc...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7261,98277,ConnectionType,4,ConnectionType,,connection.h,"typedef struct ConnectionType {
    /* connection type */
    const char *(*get_type)(struct connection *conn);

    /* connection type initialize & finalize & configure */
    void (*init)(void); /* auto-call during register */
    void (*cleanup)(void);
    int (*configure)(void *priv, int reconfigure);

    /* ae & accept & listen & error & address handler */
    void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);
    aeFileProc *accept_handler;
    int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);
    int (*is_local)(connection *conn);
    int (*listen)(connListener *listener);

    /* create/shutdown/close connection */
    connection* (*conn_create)(void);
    connection* (*conn_create_accepted)(int fd, void *priv);
    void (*shutdown)(struct connection *conn);
    void (*close)(struct connection *conn);

    /* connect & accept */
    int (*connect)(struct connection *conn, const char *addr, int port, const char *sourc...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7262,98278,connection,4,connection,,connection.h,"struct connection {
    ConnectionType *type;
    ConnectionState state;
    int last_errno;
    int fd;
    short int flags;
    short int refs;
    unsigned short int iovcnt;
    void *private_data;
    ConnectionCallbackFunc conn_handler;
    ConnectionCallbackFunc write_handler;
    ConnectionCallbackFunc read_handler;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7263,98290,connListener,4,connListener,,connection.h,"struct connListener {
    int fd[CONFIG_BINDADDR_MAX];
    int count;
    char **bindaddr;
    int bindaddr_count;
    int port;
    ConnectionType *ct;
    void *priv; /* used by connection type specified data */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7264,104065,scanData,4,scanData,,db.c,"typedef struct {
    list *keys;   /* elements that collect from dict */
    robj *o;      /* o must be a hash/set/zset object, NULL means current db */
    long long type; /* the particular type when scan the db */
    sds pattern;  /* pattern string, NULL means no pattern */
    long sampled; /* cumulative number of keys sampled */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7265,108295,ChannelSpecs,4,ChannelSpecs,,db.c,"typedef struct ChannelSpecs {
    redisCommandProc *proc; /* Command procedure to match against */
    uint64_t flags;         /* CMD_CHANNEL_* flags for this command */
    int start;              /* The initial position of the first channel */
    int count;              /* The number of channels, or -1 if all remaining
                             * arguments are channels. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7266,108300,ChannelSpecs,4,ChannelSpecs,,db.c,"typedef struct ChannelSpecs {
    redisCommandProc *proc; /* Command procedure to match against */
    uint64_t flags;         /* CMD_CHANNEL_* flags for this command */
    int start;              /* The initial position of the first channel */
    int count;              /* The number of channels, or -1 if all remaining
                             * arguments are channels. */
} ChannelSpecs;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7267,116283,dictEntry,4,dictEntry,,dict.c,"struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;     /* Next entry in the same hash bucket. */
    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as returned
                                 * by dictType's dictEntryMetadataBytes(). */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7268,116285,dictEntry.v,4,dictEntry.v,,dict.c,"union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7269,116291,dictEntry,4,dictEntry.dictEntry,,dict.c,struct dictEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7270,116299,dictEntryNoValue,4,dictEntryNoValue,,dict.c,"typedef struct {
    void *key;
    dictEntry *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7271,122562,dictEntry,4,dictEntry,,dict.h,typedef struct dictEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7272,122563,dictEntry,4,dictEntry,,dict.h,typedef struct dictEntry dictEntry;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7273,122564,dict,4,dict,,dict.h,typedef struct dict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7274,122565,dict,4,dict,,dict.h,typedef struct dict dict;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7275,122566,dictType,4,dictType,,dict.h,"typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(dict *d, const void *key);
    void *(*valDup)(dict *d, const void *obj);
    int (*keyCompare)(dict *d, const void *key1, const void *key2);
    void (*keyDestructor)(dict *d, void *key);
    void (*valDestructor)(dict *d, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
    /* Flags */
    /* The 'no_value' flag, if set, indicates that values are not used, i.e. the
     * dict is a set. When this flag is set, it's not possible to access the
     * value of a dictEntry and it's also impossible to use dictSetKey(). Entry
     * metadata can also not be used. */
    unsigned int no_value:1;
    /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1
     * enables one more optimization: to store a key without an allocated
     * dictEntry. */
    unsigned int keys_are_odd:1;
    /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7276,122627,dictType,4,dictType,,dict.h,"typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(dict *d, const void *key);
    void *(*valDup)(dict *d, const void *obj);
    int (*keyCompare)(dict *d, const void *key1, const void *key2);
    void (*keyDestructor)(dict *d, void *key);
    void (*valDestructor)(dict *d, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
    /* Flags */
    /* The 'no_value' flag, if set, indicates that values are not used, i.e. the
     * dict is a set. When this flag is set, it's not possible to access the
     * value of a dictEntry and it's also impossible to use dictSetKey(). Entry
     * metadata can also not be used. */
    unsigned int no_value:1;
    /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1
     * enables one more optimization: to store a key without an allocated
     * dictEntry. */
    unsigned int keys_are_odd:1;
    /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7277,122628,dict,4,dict,,dict.h,"struct dict {
    dictType *type;

    dictEntry **ht_table[2];
    unsigned long ht_used[2];

    long rehashidx; /* rehashing not in progress if rehashidx == -1 */

    /* Keep small vars at end for optimal (minimal) struct padding */
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
    signed char ht_size_exp[2]; /* exponent of size. (size = 1<<exp) */

    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as defined
                                 * by dictType's dictEntryBytes. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7278,122647,dictIterator,4,dictIterator,,dict.h,"typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    unsigned long long fingerprint;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7279,122655,dictIterator,4,dictIterator,,dict.h,"typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    unsigned long long fingerprint;
} dictIterator;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7280,122667,dictDefragFunctions,4,dictDefragFunctions,,dict.h,"typedef struct {
    dictDefragAllocFunction *defragAlloc; /* Used for entries etc. */
    dictDefragAllocFunction *defragKey;   /* Defrag-realloc keys (optional) */
    dictDefragAllocFunction *defragVal;   /* Defrag-realloc values (optional) */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7281,122672,dictResizeEnable,4,dictResizeEnable,,dict.h,"typedef enum {
    DICT_RESIZE_ENABLE,
    DICT_RESIZE_AVOID,
    DICT_RESIZE_FORBID,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7282,123363,luaCtx,4,luaCtx,,eval.c,"struct luaCtx {
    lua_State *lua; /* The Lua interpreter. We use just one for all clients */
    client *lua_client;   /* The ""fake client"" to query Redis from Lua */
    dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */
    unsigned long long lua_scripts_mem;  /* Cached scripts' memory + oh */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7283,123369,ldbState,4,ldbState,,eval.c,"struct ldbState {
    connection *conn; /* Connection of the debugging client. */
    int active; /* Are we debugging EVAL right now? */
    int forked; /* Is this a fork()ed debugging session? */
    list *logs; /* List of messages to send to the client. */
    list *traces; /* Messages about Redis commands executed since last stop.*/
    list *children; /* All forked debugging sessions pids. */
    int bp[LDB_BREAKPOINTS_MAX]; /* An array of breakpoints line numbers. */
    int bpcount; /* Number of valid entries inside bp. */
    int step;   /* Stop at next line regardless of breakpoints. */
    int luabp;  /* Stop at next line because redis.breakpoint() was called. */
    sds *src;   /* Lua script source code split by line. */
    int lines;  /* Number of lines in 'src'. */
    int currentline;    /* Current line number. */
    sds cbuf;   /* Debugger client command buffer. */
    size_t maxlen;  /* Max var dump / reply length. */
    int maxlen_hint_sent; /* Did we already hint...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7284,128833,evictionPoolEntry,4,evictionPoolEntry,,evict.c,"struct evictionPoolEntry {
    unsigned long long idle;    /* Object idle time (inverse frequency for LFU) */
    sds key;                    /* Key name. */
    sds cached;                 /* Cached SDS object for key name. */
    int dbid;                   /* Key DB number. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7285,128838,evictionPoolEntry,4,evictionPoolEntry,,evict.c,static struct evictionPoolEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7286,130821,expireScanData,4,expireScanData,,expire.c,"typedef struct {
    redisDb *db;
    long long now;
    unsigned long sampled; /* num keys checked */
    unsigned long expired; /* num keys expired */
    long long ttl_sum; /* sum of ttl for key with ttl not yet expired */
    int ttl_samples; /* num keys with ttl not yet expired */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7287,132643,luaEngineCtx,4,luaEngineCtx,,function_lua.c,"typedef struct luaEngineCtx {
    lua_State *lua;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7288,132645,luaEngineCtx,4,luaEngineCtx,,function_lua.c,"typedef struct luaEngineCtx {
    lua_State *lua;
} luaEngineCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7289,132646,luaFunctionCtx,4,luaFunctionCtx,,function_lua.c,"typedef struct luaFunctionCtx {
    /* Special ID that allows getting the Lua function object from the Lua registry */
    int lua_function_ref;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7290,132648,luaFunctionCtx,4,luaFunctionCtx,,function_lua.c,"typedef struct luaFunctionCtx {
    /* Special ID that allows getting the Lua function object from the Lua registry */
    int lua_function_ref;
} luaFunctionCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7291,132649,loadCtx,4,loadCtx,,function_lua.c,"typedef struct loadCtx {
    functionLibInfo *li;
    monotime start_time;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7292,132652,loadCtx,4,loadCtx,,function_lua.c,"typedef struct loadCtx {
    functionLibInfo *li;
    monotime start_time;
} loadCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7293,132653,registerFunctionArgs,4,registerFunctionArgs,,function_lua.c,"typedef struct registerFunctionArgs {
    sds name;
    sds desc;
    luaFunctionCtx *lua_f_ctx;
    uint64_t f_flags;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7294,132658,registerFunctionArgs,4,registerFunctionArgs,,function_lua.c,"typedef struct registerFunctionArgs {
    sds name;
    sds desc;
    luaFunctionCtx *lua_f_ctx;
    uint64_t f_flags;
} registerFunctionArgs;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7295,133928,restorePolicy,4,restorePolicy,,functions.c,"typedef enum {
    restorePolicy_Flush, restorePolicy_Append, restorePolicy_Replace
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7296,133960,functionsLibEngineStats,4,functionsLibEngineStats,,functions.c,"typedef struct functionsLibEngineStats {
    size_t n_lib;
    size_t n_functions;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7297,133963,functionsLibEngineStats,4,functionsLibEngineStats,,functions.c,"typedef struct functionsLibEngineStats {
    size_t n_lib;
    size_t n_functions;
} functionsLibEngineStats;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7298,133964,functionsLibCtx,4,functionsLibCtx,,functions.c,"struct functionsLibCtx {
    dict *libraries;     /* Library name -> Library object */
    dict *functions;     /* Function name -> Function object that can be used to run the function */
    size_t cache_memory; /* Overhead memory (structs, dictionaries, ..) used by all the functions */
    dict *engines_stats; /* Per engine statistics */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7299,133969,functionsLibMataData,4,functionsLibMataData,,functions.c,"typedef struct functionsLibMataData {
    sds engine;
    sds name;
    sds code;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7300,133973,functionsLibMataData,4,functionsLibMataData,,functions.c,"typedef struct functionsLibMataData {
    sds engine;
    sds name;
    sds code;
} functionsLibMataData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7301,137415,functionLibInfo,4,functionLibInfo,,functions.h,typedef struct functionLibInfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7302,137416,functionLibInfo,4,functionLibInfo,,functions.h,typedef struct functionLibInfo functionLibInfo;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7303,137417,engine,4,engine,,functions.h,"typedef struct engine {
    /* engine specific context */
    void *engine_ctx;

    /* Create function callback, get the engine_ctx, and function code.
     * returns NULL on error and set sds to be the error message */
    int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);

    /* Invoking a function, r_ctx is an opaque object (from engine POV).
     * The r_ctx should be used by the engine to interaction with Redis,
     * such interaction could be running commands, set resp, or set
     * replication mode
     */
    void (*call)(scriptRunCtx *r_ctx, void *engine_ctx, void *compiled_function,
            robj **keys, size_t nkeys, robj **args, size_t nargs);

    /* get current used memory by the engine */
    size_t (*get_used_memory)(void *engine_ctx);

    /* Return memory overhead for a given function,
     * such memory is not counted as engine memory but as general
     * structs memory that hold different information */
    size_t (*get_function_mem...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7304,137459,engine,4,engine,,functions.h,"typedef struct engine {
    /* engine specific context */
    void *engine_ctx;

    /* Create function callback, get the engine_ctx, and function code.
     * returns NULL on error and set sds to be the error message */
    int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);

    /* Invoking a function, r_ctx is an opaque object (from engine POV).
     * The r_ctx should be used by the engine to interaction with Redis,
     * such interaction could be running commands, set resp, or set
     * replication mode
     */
    void (*call)(scriptRunCtx *r_ctx, void *engine_ctx, void *compiled_function,
            robj **keys, size_t nkeys, robj **args, size_t nargs);

    /* get current used memory by the engine */
    size_t (*get_used_memory)(void *engine_ctx);

    /* Return memory overhead for a given function,
     * such memory is not counted as engine memory but as general
     * structs memory that hold different information */
    size_t (*get_function_mem...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7305,137460,engineInfo,4,engineInfo,,functions.h,"typedef struct engineInfo {
    sds name;       /* Name of the engine */
    engine *engine; /* engine callbacks that allows to interact with the engine */
    client *c;      /* Client that is used to run commands */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7306,137464,engineInfo,4,engineInfo,,functions.h,"typedef struct engineInfo {
    sds name;       /* Name of the engine */
    engine *engine; /* engine callbacks that allows to interact with the engine */
    client *c;      /* Client that is used to run commands */
} engineInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7307,137465,functionInfo,4,functionInfo,,functions.h,"typedef struct functionInfo {
    sds name;            /* Function name */
    void *function;      /* Opaque object that set by the function's engine and allow it
                            to run the function, usually it's the function compiled code. */
    functionLibInfo* li; /* Pointer to the library created the function */
    sds desc;            /* Function description */
    uint64_t f_flags;    /* Function flags */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7308,137471,functionInfo,4,functionInfo,,functions.h,"typedef struct functionInfo {
    sds name;            /* Function name */
    void *function;      /* Opaque object that set by the function's engine and allow it
                            to run the function, usually it's the function compiled code. */
    functionLibInfo* li; /* Pointer to the library created the function */
    sds desc;            /* Function description */
    uint64_t f_flags;    /* Function flags */
} functionInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7309,137472,functionLibInfo,4,functionLibInfo,,functions.h,"struct functionLibInfo {
    sds name;        /* Library name */
    dict *functions; /* Functions dictionary */
    engineInfo *ei;  /* Pointer to the function engine */
    sds code;        /* Library code */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7310,141337,geoPoint,4,geoPoint,,geo.h,"typedef struct geoPoint {
    double longitude;
    double latitude;
    double dist;
    double score;
    char *member;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7311,141343,geoPoint,4,geoPoint,,geo.h,"typedef struct geoPoint {
    double longitude;
    double latitude;
    double dist;
    double score;
    char *member;
} geoPoint;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7312,141344,geoArray,4,geoArray,,geo.h,"typedef struct geoArray {
    struct geoPoint *array;
    size_t buckets;
    size_t used;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7313,141345,geoPoint,4,geoArray.geoPoint,,geo.h,struct geoPoint,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7314,141349,geoArray,4,geoArray,,geo.h,"typedef struct geoArray {
    struct geoPoint *array;
    size_t buckets;
    size_t used;
} geoArray;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7315,142702,GeoDirection,4,GeoDirection,,geohash.h,"typedef enum {
    GEOHASH_NORTH = 0,
    GEOHASH_EAST,
    GEOHASH_WEST,
    GEOHASH_SOUTH,
    GEOHASH_SOUTH_WEST,
    GEOHASH_SOUTH_EAST,
    GEOHASH_NORT_WEST,
    GEOHASH_NORT_EAST
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7316,142719,GeoHashBits,4,GeoHashBits,,geohash.h,"typedef struct {
    uint64_t bits;
    uint8_t step;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7317,142723,GeoHashRange,4,GeoHashRange,,geohash.h,"typedef struct {
    double min;
    double max;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7318,142727,GeoHashArea,4,GeoHashArea,,geohash.h,"typedef struct {
    GeoHashBits hash;
    GeoHashRange longitude;
    GeoHashRange latitude;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7319,142732,GeoHashNeighbors,4,GeoHashNeighbors,,geohash.h,"typedef struct {
    GeoHashBits north;
    GeoHashBits east;
    GeoHashBits west;
    GeoHashBits south;
    GeoHashBits north_east;
    GeoHashBits south_east;
    GeoHashBits north_west;
    GeoHashBits south_west;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7320,142742,GeoShape,4,GeoShape,,geohash.h,"typedef struct {
    int type; /* search type */
    double xy[2]; /* search center point, xy[0]: lon, xy[1]: lat */
    double conversion; /* km: 1000 */
    double bounds[4]; /* bounds[0]: min_lon, bounds[1]: min_lat
                       * bounds[2]: max_lon, bounds[3]: max_lat */
    union {
        /* CIRCULAR_TYPE */
        double radius;
        /* RECTANGLE_TYPE */
        struct {
            double height;
            double width;
        } r;
    } t;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7321,142747,GeoShape.t,4,GeoShape.t,,geohash.h,"union {
        /* CIRCULAR_TYPE */
        double radius;
        /* RECTANGLE_TYPE */
        struct {
            double height;
            double width;
        } r;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7322,142749,GeoShape.t.r,4,GeoShape.t.r,,geohash.h,"struct {
            double height;
            double width;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7323,143907,GeoHashFix52Bits,4,GeoHashFix52Bits,,geohash_helper.h,typedef uint64_t GeoHashFix52Bits;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7324,143908,GeoHashVarBits,4,GeoHashVarBits,,geohash_helper.h,typedef uint64_t GeoHashVarBits;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7325,143909,GeoHashRadius,4,GeoHashRadius,,geohash_helper.h,"typedef struct {
    GeoHashBits hash;
    GeoHashArea area;
    GeoHashNeighbors neighbors;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7326,143986,hllhdr,4,hllhdr,,hyperloglog.c,"struct hllhdr {
    char magic[4];      /* ""HYLL"" */
    uint8_t encoding;   /* HLL_DENSE or HLL_SPARSE. */
    uint8_t notused[3]; /* Reserved for future use, must be zero. */
    uint8_t card[8];    /* Cached cardinality, little endian. */
    uint8_t registers[]; /* Data bytes. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7327,150546,intset,4,intset,,intset.h,"typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7328,150555,intset,4,intset,,intset.h,"typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7329,152992,latencySample,4,latencySample,,latency.h,"struct latencySample {
    int32_t time; /* We don't use time_t to force 4 bytes usage everywhere. */
    uint32_t latency; /* Latency in milliseconds. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7330,152995,latencyTimeSeries,4,latencyTimeSeries,,latency.h,"struct latencyTimeSeries {
    int idx; /* Index of the next sample to store. */
    uint32_t max; /* Max latency observed for this event. */
    struct latencySample samples[LATENCY_TS_LEN]; /* Latest history. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7331,152998,latencySample,4,latencyTimeSeries.latencySample,,latency.h,struct latencySample,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7332,153008,latencyStats,4,latencyStats,,latency.h,"struct latencyStats {
    uint32_t all_time_high; /* Absolute max observed since latest reset. */
    uint32_t avg;           /* Average of current samples. */
    uint32_t min;           /* Min of current samples. */
    uint32_t max;           /* Max of current samples. */
    uint32_t mad;           /* Mean absolute deviation. */
    uint32_t samples;       /* Number of non-zero samples. */
    time_t period;          /* Number of seconds since first event and now. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7333,153027,durationStats,4,durationStats,,latency.h,"typedef struct durationStats {
    unsigned long long cnt;
    unsigned long long sum;
    unsigned long long max;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7334,153031,durationStats,4,durationStats,,latency.h,"typedef struct durationStats {
    unsigned long long cnt;
    unsigned long long sum;
    unsigned long long max;
} durationStats;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7335,153032,DurationType,4,DurationType,,latency.h,"typedef enum {
    EL_DURATION_TYPE_EL = 0, // cumulative time duration metric of the whole eventloop
    EL_DURATION_TYPE_CMD,    // cumulative time duration metric of executing commands
    EL_DURATION_TYPE_AOF,    // cumulative time duration metric of flushing AOF in eventloop
    EL_DURATION_TYPE_CRON,   // cumulative time duration metric of cron (serverCron and beforeSleep, but excluding IO and AOF)
    EL_DURATION_TYPE_NUM
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7336,159973,listpackEntry,4,listpackEntry,,listpack.h,"typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    uint32_t slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7337,161100,lwCanvas,4,lwCanvas,,lolwut.h,"typedef struct lwCanvas {
    int width;
    int height;
    char *pixels;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7338,161104,lwCanvas,4,lwCanvas,,lolwut.h,"typedef struct lwCanvas {
    int width;
    int height;
    char *pixels;
} lwCanvas;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7339,161870,skyscraper,4,skyscraper,,lolwut6.c,"struct skyscraper {
    int xoff;       /* X offset. */
    int width;      /* Pixels width. */
    int height;     /* Pixels height. */
    int windows;    /* Draw windows if true. */
    int color;      /* Color of the skyscraper. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7340,162447,u8,4,u8,,lzfP.h,typedef unsigned char u8;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7341,162448,LZF_HSLOT,4,LZF_HSLOT,,lzfP.h,typedef const u8 *LZF_HSLOT;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7342,162449,LZF_STATE,4,LZF_STATE,,lzfP.h,typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7343,163868,winsize,4,winsize,,memtest.c,static struct winsize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7344,164978,RedisModuleInfoCtx,4,RedisModuleInfoCtx,,module.c,"struct RedisModuleInfoCtx {
    struct RedisModule *module;
    dict *requested_sections;
    sds info;           /* info string we collected so far */
    int sections;       /* number of sections we collected so far */
    int in_section;     /* indication if we're in an active section or not */
    int in_dict_field;  /* indication that we're currently appending to a dict */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7345,164979,RedisModule,4,RedisModuleInfoCtx.RedisModule,,module.c,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7346,164986,RedisModuleSharedAPI,4,RedisModuleSharedAPI,,module.c,"struct RedisModuleSharedAPI {
    void *func;
    RedisModule *module;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7347,164989,RedisModuleSharedAPI,4,RedisModuleSharedAPI,,module.c,typedef struct RedisModuleSharedAPI,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7348,164990,RedisModuleSharedAPI,4,RedisModuleSharedAPI,,module.c,typedef struct RedisModuleSharedAPI RedisModuleSharedAPI;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7349,164992,AutoMemEntry,4,AutoMemEntry,,module.c,"struct AutoMemEntry {
    void *ptr;
    int type;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7350,164995,RedisModulePoolAllocBlock,4,RedisModulePoolAllocBlock,,module.c,"typedef struct RedisModulePoolAllocBlock {
    uint32_t size;
    uint32_t used;
    struct RedisModulePoolAllocBlock *next;
    char memory[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7351,164998,RedisModulePoolAllocBlock,4,RedisModulePoolAllocBlock.RedisModulePoolAllocBlock,,module.c,struct RedisModulePoolAllocBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7352,165006,RedisModulePoolAllocBlock,4,RedisModulePoolAllocBlock,,module.c,"typedef struct RedisModulePoolAllocBlock {
    uint32_t size;
    uint32_t used;
    struct RedisModulePoolAllocBlock *next;
    char memory[];
} RedisModulePoolAllocBlock;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7353,165007,RedisModuleBlockedClient,4,RedisModuleBlockedClient,,module.c,struct RedisModuleBlockedClient,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7354,165008,RedisModuleUser,4,RedisModuleUser,,module.c,struct RedisModuleUser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7355,165009,RedisModuleCtx,4,RedisModuleCtx,,module.c,"struct RedisModuleCtx {
    void *getapifuncptr;            /* NOTE: Must be the first field. */
    struct RedisModule *module;     /* Module reference. */
    client *client;                 /* Client calling a command. */
    struct RedisModuleBlockedClient *blocked_client; /* Blocked client for
                                                        thread safe context. */
    struct AutoMemEntry *amqueue;   /* Auto memory queue of objects to free. */
    int amqueue_len;                /* Number of slots in amqueue. */
    int amqueue_used;               /* Number of used slots in amqueue. */
    int flags;                      /* REDISMODULE_CTX_... flags. */
    void **postponed_arrays;        /* To set with RM_ReplySetArrayLength(). */
    int postponed_arrays_count;     /* Number of entries in postponed_arrays. */
    void *blocked_privdata;         /* Privdata set when unblocking a client. */
    RedisModuleString *blocked_ready_key; /* Key ready when the reply callback
  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7356,165011,RedisModule,4,RedisModuleCtx.RedisModule,,module.c,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7357,165014,RedisModuleBlockedClient,4,RedisModuleCtx.RedisModuleBlockedClient,,module.c,struct RedisModuleBlockedClient,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7358,165016,AutoMemEntry,4,RedisModuleCtx.AutoMemEntry,,module.c,struct AutoMemEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7359,165026,RedisModulePoolAllocBlock,4,RedisModuleCtx.RedisModulePoolAllocBlock,,module.c,struct RedisModulePoolAllocBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7360,165029,RedisModuleUser,4,RedisModuleCtx.RedisModuleUser,,module.c,const struct RedisModuleUser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7361,165031,RedisModuleCtx,4,RedisModuleCtx,,module.c,typedef struct RedisModuleCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7362,165032,RedisModuleCtx,4,RedisModuleCtx,,module.c,typedef struct RedisModuleCtx RedisModuleCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7363,165033,RedisModuleKey,4,RedisModuleKey,,module.c,"struct RedisModuleKey {
    RedisModuleCtx *ctx;
    redisDb *db;
    robj *key;      /* Key name object. */
    robj *value;    /* Value object, or NULL if the key was not found. */
    void *iter;     /* Iterator. */
    int mode;       /* Opening mode. */

    union {
        struct {
            /* List, use only if value->type == OBJ_LIST */
            listTypeEntry entry;   /* Current entry in iteration. */
            long index;            /* Current 0-based index in iteration. */
        } list;
        struct {
            /* Zset iterator, use only if value->type == OBJ_ZSET */
            uint32_t type;         /* REDISMODULE_ZSET_RANGE_* */
            zrangespec rs;         /* Score range. */
            zlexrangespec lrs;     /* Lex range. */
            uint32_t start;        /* Start pos for positional ranges. */
            uint32_t end;          /* End pos for positional ranges. */
            void *current;         /* Zset iterator current node. */
            i...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7364,165040,RedisModuleKey.u,4,RedisModuleKey.u,,module.c,"union {
        struct {
            /* List, use only if value->type == OBJ_LIST */
            listTypeEntry entry;   /* Current entry in iteration. */
            long index;            /* Current 0-based index in iteration. */
        } list;
        struct {
            /* Zset iterator, use only if value->type == OBJ_ZSET */
            uint32_t type;         /* REDISMODULE_ZSET_RANGE_* */
            zrangespec rs;         /* Score range. */
            zlexrangespec lrs;     /* Lex range. */
            uint32_t start;        /* Start pos for positional ranges. */
            uint32_t end;          /* End pos for positional ranges. */
            void *current;         /* Zset iterator current node. */
            int er;                /* Zset iterator end reached flag
                                       (true if end was reached). */
        } zset;
        struct {
            /* Stream, use only if value->type == OBJ_STREAM */
            streamID currentid;    /* Curr...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7365,165041,RedisModuleKey.u.list,4,RedisModuleKey.u.list,,module.c,"struct {
            /* List, use only if value->type == OBJ_LIST */
            listTypeEntry entry;   /* Current entry in iteration. */
            long index;            /* Current 0-based index in iteration. */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7366,165045,RedisModuleKey.u.zset,4,RedisModuleKey.u.zset,,module.c,"struct {
            /* Zset iterator, use only if value->type == OBJ_ZSET */
            uint32_t type;         /* REDISMODULE_ZSET_RANGE_* */
            zrangespec rs;         /* Score range. */
            zlexrangespec lrs;     /* Lex range. */
            uint32_t start;        /* Start pos for positional ranges. */
            uint32_t end;          /* End pos for positional ranges. */
            void *current;         /* Zset iterator current node. */
            int er;                /* Zset iterator end reached flag
                                       (true if end was reached). */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7367,165054,RedisModuleKey.u.stream,4,RedisModuleKey.u.stream,,module.c,"struct {
            /* Stream, use only if value->type == OBJ_STREAM */
            streamID currentid;    /* Current entry while iterating. */
            int64_t numfieldsleft; /* Fields left to fetch for current entry. */
            int signalready;       /* Flag that signalKeyAsReady() is needed. */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7368,165060,RedisModuleBlockedClient,4,RedisModuleBlockedClient,,module.c,struct RedisModuleBlockedClient,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7369,165082,RedisModuleCommand,4,RedisModuleCommand,,module.c,"struct RedisModuleCommand {
    struct RedisModule *module;
    RedisModuleCmdFunc func;
    struct redisCommand *rediscmd;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7370,165083,RedisModule,4,RedisModuleCommand.RedisModule,,module.c,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7371,165086,redisCommand,4,RedisModuleCommand.redisCommand,,module.c,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7372,165088,RedisModuleCommand,4,RedisModuleCommand,,module.c,typedef struct RedisModuleCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7373,165089,RedisModuleCommand,4,RedisModuleCommand,,module.c,typedef struct RedisModuleCommand RedisModuleCommand;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7374,165090,CallReply,4,CallReply,,module.c,typedef struct CallReply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7375,165091,RedisModuleCallReply,4,RedisModuleCallReply,,module.c,typedef struct CallReply RedisModuleCallReply;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7376,165092,RedisModuleAuthCtx,4,RedisModuleAuthCtx,,module.c,"typedef struct RedisModuleAuthCtx {
    struct RedisModule *module;
    RedisModuleAuthCallback auth_cb;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7377,165093,RedisModule,4,RedisModuleAuthCtx.RedisModule,,module.c,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7378,165096,RedisModuleAuthCtx,4,RedisModuleAuthCtx,,module.c,"typedef struct RedisModuleAuthCtx {
    struct RedisModule *module;
    RedisModuleAuthCallback auth_cb;
} RedisModuleAuthCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7379,165097,RedisModuleBlockedClient,4,RedisModuleBlockedClient,,module.c,"typedef struct RedisModuleBlockedClient {
    client *client;  /* Pointer to the blocked client. or NULL if the client
                        was destroyed during the life of this object. */
    RedisModule *module;    /* Module blocking the client. */
    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/
    RedisModuleAuthCallback auth_reply_cb; /* Reply callback on completing blocking
                                                    module authentication. */
    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */
    RedisModuleDisconnectFunc disconnect_callback; /* Called on disconnection.*/
    void (*free_privdata)(RedisModuleCtx*,void*);/* privdata cleanup callback.*/
    void *privdata;     /* Module private data that may be used by the reply
                           or timeout callback. It is set via the
                           RedisModule_UnblockClient() API. */
    client *thread_safe_ctx_client; /* Fake client to be u...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7380,165118,RedisModuleBlockedClient,4,RedisModuleBlockedClient,,module.c,"typedef struct RedisModuleBlockedClient {
    client *client;  /* Pointer to the blocked client. or NULL if the client
                        was destroyed during the life of this object. */
    RedisModule *module;    /* Module blocking the client. */
    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/
    RedisModuleAuthCallback auth_reply_cb; /* Reply callback on completing blocking
                                                    module authentication. */
    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */
    RedisModuleDisconnectFunc disconnect_callback; /* Called on disconnection.*/
    void (*free_privdata)(RedisModuleCtx*,void*);/* privdata cleanup callback.*/
    void *privdata;     /* Module private data that may be used by the reply
                           or timeout callback. It is set via the
                           RedisModule_UnblockClient() API. */
    client *thread_safe_ctx_client; /* Fake client to be u...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7381,165156,RedisModuleKeyspaceSubscriber,4,RedisModuleKeyspaceSubscriber,,module.c,"typedef struct RedisModuleKeyspaceSubscriber {
    /* The module subscribed to the event */
    RedisModule *module;
    /* Notification callback in the module*/
    RedisModuleNotificationFunc notify_callback;
    /* A bit mask of the events the module is interested in */
    int event_mask;
    /* Active flag set on entry, to avoid reentrant subscribers
     * calling themselves */
    int active;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7382,165161,RedisModuleKeyspaceSubscriber,4,RedisModuleKeyspaceSubscriber,,module.c,"typedef struct RedisModuleKeyspaceSubscriber {
    /* The module subscribed to the event */
    RedisModule *module;
    /* Notification callback in the module*/
    RedisModuleNotificationFunc notify_callback;
    /* A bit mask of the events the module is interested in */
    int event_mask;
    /* Active flag set on entry, to avoid reentrant subscribers
     * calling themselves */
    int active;
} RedisModuleKeyspaceSubscriber;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7383,165162,RedisModulePostExecUnitJob,4,RedisModulePostExecUnitJob,,module.c,"typedef struct RedisModulePostExecUnitJob {
    /* The module subscribed to the event */
    RedisModule *module;
    RedisModulePostNotificationJobFunc callback;
    void *pd;
    void (*free_pd)(void*);
    int dbid;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7384,165172,RedisModulePostExecUnitJob,4,RedisModulePostExecUnitJob,,module.c,"typedef struct RedisModulePostExecUnitJob {
    /* The module subscribed to the event */
    RedisModule *module;
    RedisModulePostNotificationJobFunc callback;
    void *pd;
    void (*free_pd)(void*);
    int dbid;
} RedisModulePostExecUnitJob;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7385,165175,RedisModuleDict,4,RedisModuleDict,,module.c,"typedef struct RedisModuleDict {
    rax *rax;                       /* The radix tree. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7386,165177,RedisModuleDict,4,RedisModuleDict,,module.c,"typedef struct RedisModuleDict {
    rax *rax;                       /* The radix tree. */
} RedisModuleDict;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7387,165178,RedisModuleDictIter,4,RedisModuleDictIter,,module.c,"typedef struct RedisModuleDictIter {
    RedisModuleDict *dict;
    raxIterator ri;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7388,165181,RedisModuleDictIter,4,RedisModuleDictIter,,module.c,"typedef struct RedisModuleDictIter {
    RedisModuleDict *dict;
    raxIterator ri;
} RedisModuleDictIter;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7389,165182,RedisModuleCommandFilterCtx,4,RedisModuleCommandFilterCtx,,module.c,"typedef struct RedisModuleCommandFilterCtx {
    RedisModuleString **argv;
    int argv_len;
    int argc;
    client *c;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7390,165187,RedisModuleCommandFilterCtx,4,RedisModuleCommandFilterCtx,,module.c,"typedef struct RedisModuleCommandFilterCtx {
    RedisModuleString **argv;
    int argv_len;
    int argc;
    client *c;
} RedisModuleCommandFilterCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7391,165193,RedisModuleCommandFilter,4,RedisModuleCommandFilter,,module.c,"typedef struct RedisModuleCommandFilter {
    /* The module that registered the filter */
    RedisModule *module;
    /* Filter callback function */
    RedisModuleCommandFilterFunc callback;
    /* REDISMODULE_CMDFILTER_* flags */
    int flags;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7392,165197,RedisModuleCommandFilter,4,RedisModuleCommandFilter,,module.c,"typedef struct RedisModuleCommandFilter {
    /* The module that registered the filter */
    RedisModule *module;
    /* Filter callback function */
    RedisModuleCommandFilterFunc callback;
    /* REDISMODULE_CMDFILTER_* flags */
    int flags;
} RedisModuleCommandFilter;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7393,165206,RedisModuleForkInfo,4,RedisModuleForkInfo,,module.c,"static struct RedisModuleForkInfo {
    RedisModuleForkDoneHandler done_handler;
    void* done_handler_user_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7394,165214,RedisModuleServerInfoData,4,RedisModuleServerInfoData,,module.c,"typedef struct RedisModuleServerInfoData {
    rax *rax;                       /* parsed info data. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7395,165216,RedisModuleServerInfoData,4,RedisModuleServerInfoData,,module.c,"typedef struct RedisModuleServerInfoData {
    rax *rax;                       /* parsed info data. */
} RedisModuleServerInfoData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7396,165217,RedisModuleEventListener,4,RedisModuleEventListener,,module.c,"typedef struct RedisModuleEventListener {
    RedisModule *module;
    RedisModuleEvent event;
    RedisModuleEventCallback callback;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7397,165221,RedisModuleEventListener,4,RedisModuleEventListener,,module.c,"typedef struct RedisModuleEventListener {
    RedisModule *module;
    RedisModuleEvent event;
    RedisModuleEventCallback callback;
} RedisModuleEventListener;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7398,165223,RedisModuleUser,4,RedisModuleUser,,module.c,"typedef struct RedisModuleUser {
    user *user; /* Reference to the real redis user */
    int free_user; /* Indicates that user should also be freed when this object is freed */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7399,165226,RedisModuleUser,4,RedisModuleUser,,module.c,"typedef struct RedisModuleUser {
    user *user; /* Reference to the real redis user */
    int free_user; /* Indicates that user should also be freed when this object is freed */
} RedisModuleUser;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7400,165227,RedisModuleKeyOptCtx,4,RedisModuleKeyOptCtx,,module.c,"typedef struct RedisModuleKeyOptCtx {
    struct redisObject *from_key, *to_key; /* Optional name of key processed, NULL when unknown. 
                                              In most cases, only 'from_key' is valid, but in callbacks 
                                              such as `copy2`, both 'from_key' and 'to_key' are valid. */
    int from_dbid, to_dbid;                /* The dbid of the key being processed, -1 when unknown.
                                              In most cases, only 'from_dbid' is valid, but in callbacks such 
                                              as `copy2`, 'from_dbid' and 'to_dbid' are both valid. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7401,165228,redisObject,4,RedisModuleKeyOptCtx.redisObject,,module.c,struct redisObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7402,165233,RedisModuleKeyOptCtx,4,RedisModuleKeyOptCtx,,module.c,"typedef struct RedisModuleKeyOptCtx {
    struct redisObject *from_key, *to_key; /* Optional name of key processed, NULL when unknown. 
                                              In most cases, only 'from_key' is valid, but in callbacks 
                                              such as `copy2`, both 'from_key' and 'to_key' are valid. */
    int from_dbid, to_dbid;                /* The dbid of the key being processed, -1 when unknown.
                                              In most cases, only 'from_dbid' is valid, but in callbacks such 
                                              as `copy2`, 'from_dbid' and 'to_dbid' are both valid. */
} RedisModuleKeyOptCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7403,165297,ModuleConfig,4,ModuleConfig,,module.c,"struct ModuleConfig {
    sds name; /* Name of config without the module name appended to the front */
    void *privdata; /* Optional data passed into the module config callbacks */
    union get_fn { /* The get callback specified by the module */
        RedisModuleConfigGetStringFunc get_string;
        RedisModuleConfigGetNumericFunc get_numeric;
        RedisModuleConfigGetBoolFunc get_bool;
        RedisModuleConfigGetEnumFunc get_enum;
    } get_fn;
    union set_fn { /* The set callback specified by the module */
        RedisModuleConfigSetStringFunc set_string;
        RedisModuleConfigSetNumericFunc set_numeric;
        RedisModuleConfigSetBoolFunc set_bool;
        RedisModuleConfigSetEnumFunc set_enum;
    } set_fn;
    RedisModuleConfigApplyFunc apply_fn;
    RedisModule *module;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7404,165300,get_fn,4,ModuleConfig.get_fn,,module.c,"union get_fn { /* The get callback specified by the module */
        RedisModuleConfigGetStringFunc get_string;
        RedisModuleConfigGetNumericFunc get_numeric;
        RedisModuleConfigGetBoolFunc get_bool;
        RedisModuleConfigGetEnumFunc get_enum;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7405,165306,set_fn,4,ModuleConfig.set_fn,,module.c,"union set_fn { /* The set callback specified by the module */
        RedisModuleConfigSetStringFunc set_string;
        RedisModuleConfigSetNumericFunc set_numeric;
        RedisModuleConfigSetBoolFunc set_bool;
        RedisModuleConfigSetEnumFunc set_enum;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7406,165314,RedisModuleAsyncRMCallPromise,4,RedisModuleAsyncRMCallPromise,,module.c,"typedef struct RedisModuleAsyncRMCallPromise{
    size_t ref_count;
    void *private_data;
    RedisModule *module;
    RedisModuleOnUnblocked on_unblocked;
    client *c;
    RedisModuleCtx *ctx;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7407,165321,RedisModuleAsyncRMCallPromise,4,RedisModuleAsyncRMCallPromise,,module.c,"typedef struct RedisModuleAsyncRMCallPromise{
    size_t ref_count;
    void *private_data;
    RedisModule *module;
    RedisModuleOnUnblocked on_unblocked;
    client *c;
    RedisModuleCtx *ctx;
} RedisModuleAsyncRMCallPromise;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7408,165390,redisCommandArg,4,redisCommandArg,,module.c,static struct redisCommandArg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7409,187471,moduleClusterReceiver,4,moduleClusterReceiver,,module.c,"typedef struct moduleClusterReceiver {
    uint64_t module_id;
    RedisModuleClusterMessageReceiver callback;
    struct RedisModule *module;
    struct moduleClusterReceiver *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7410,187474,RedisModule,4,moduleClusterReceiver.RedisModule,,module.c,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7411,187476,moduleClusterReceiver,4,moduleClusterReceiver.moduleClusterReceiver,,module.c,struct moduleClusterReceiver,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7412,187478,moduleClusterReceiver,4,moduleClusterReceiver,,module.c,"typedef struct moduleClusterReceiver {
    uint64_t module_id;
    RedisModuleClusterMessageReceiver callback;
    struct RedisModule *module;
    struct moduleClusterReceiver *next;
} moduleClusterReceiver;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7413,187479,moduleClusterNodeInfo,4,moduleClusterNodeInfo,,module.c,"typedef struct moduleClusterNodeInfo {
    int flags;
    char ip[NET_IP_STR_LEN];
    int port;
    char master_id[40]; /* Only if flags & REDISMODULE_NODE_MASTER is true. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7414,187494,mdouleClusterNodeInfo,4,mdouleClusterNodeInfo,,module.c,"typedef struct moduleClusterNodeInfo {
    int flags;
    char ip[NET_IP_STR_LEN];
    int port;
    char master_id[40]; /* Only if flags & REDISMODULE_NODE_MASTER is true. */
} mdouleClusterNodeInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7415,188222,RedisModuleTimer,4,RedisModuleTimer,,module.c,"typedef struct RedisModuleTimer {
    RedisModule *module;                /* Module reference. */
    RedisModuleTimerProc callback;      /* The callback to invoke on expire. */
    void *data;                         /* Private data for the callback. */
    int dbid;                           /* Database number selected by the original client. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7416,188227,RedisModuleTimer,4,RedisModuleTimer,,module.c,"typedef struct RedisModuleTimer {
    RedisModule *module;                /* Module reference. */
    RedisModuleTimerProc callback;      /* The callback to invoke on expire. */
    void *data;                         /* Private data for the callback. */
    int dbid;                           /* Database number selected by the original client. */
} RedisModuleTimer;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7417,188733,EventLoopData,4,EventLoopData,,module.c,"typedef struct EventLoopData {
    RedisModuleEventLoopFunc rFunc;
    RedisModuleEventLoopFunc wFunc;
    void *user_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7418,188737,EventLoopData,4,EventLoopData,,module.c,"typedef struct EventLoopData {
    RedisModuleEventLoopFunc rFunc;
    RedisModuleEventLoopFunc wFunc;
    void *user_data;
} EventLoopData;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7419,188738,EventLoopOneShot,4,EventLoopOneShot,,module.c,"typedef struct EventLoopOneShot {
    RedisModuleEventLoopOneShotFunc func;
    void *user_data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7420,188741,EventLoopOneShot,4,EventLoopOneShot,,module.c,"typedef struct EventLoopOneShot {
    RedisModuleEventLoopOneShotFunc func;
    void *user_data;
} EventLoopOneShot;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7421,192811,ScanCBData,4,ScanCBData,,module.c,"typedef struct {
    RedisModuleCtx *ctx;
    void* user_data;
    RedisModuleScanCB fn;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7422,192816,RedisModuleScanCursor,4,RedisModuleScanCursor,,module.c,"typedef struct RedisModuleScanCursor{
    unsigned long cursor;
    int done;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7423,192819,RedisModuleScanCursor,4,RedisModuleScanCursor,,module.c,"typedef struct RedisModuleScanCursor{
    unsigned long cursor;
    int done;
}RedisModuleScanCursor;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7424,193006,ScanKeyCBData,4,ScanKeyCBData,,module.c,"typedef struct {
    RedisModuleKey *key;
    void* user_data;
    RedisModuleScanKeyCB fn;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7425,194110,KeyInfo,4,KeyInfo,,module.c,"typedef struct KeyInfo {
    int32_t dbnum;
    RedisModuleString *key;
    robj *value;
    int mode;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7426,194115,KeyInfo,4,KeyInfo,,module.c,"typedef struct KeyInfo {
    int32_t dbnum;
    RedisModuleString *key;
    robj *value;
    int mode;
} KeyInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7427,198709,RedisModuleRdbStream,4,RedisModuleRdbStream,,module.c,"typedef struct RedisModuleRdbStream {
    int type;

    union {
        char *filename;
    } data;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7428,198711,RedisModuleRdbStream.data,4,RedisModuleRdbStream.data,,module.c,"union {
        char *filename;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7429,198714,RedisModuleRdbStream,4,RedisModuleRdbStream,,module.c,"typedef struct RedisModuleRdbStream {
    int type;

    union {
        char *filename;
    } data;
} RedisModuleRdbStream;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7430,199864,RedisModuleDefragCtx,4,RedisModuleDefragCtx,,module.c,"struct RedisModuleDefragCtx {
    long long int endtime;
    unsigned long *cursor;
    struct redisObject *key; /* Optional name of key processed, NULL when unknown. */
    int dbid;                /* The dbid of the key being processed, -1 when unknown. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7431,199867,redisObject,4,RedisModuleDefragCtx.redisObject,,module.c,struct redisObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7432,205266,HelloTypeNode,4,HelloTypeNode,,modules\hellotype.c,"struct HelloTypeNode {
    int64_t value;
    struct HelloTypeNode *next;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7433,205268,HelloTypeNode,4,HelloTypeNode.HelloTypeNode,,modules\hellotype.c,struct HelloTypeNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7434,205270,HelloTypeObject,4,HelloTypeObject,,modules\hellotype.c,"struct HelloTypeObject {
    struct HelloTypeNode *head;
    size_t len; /* Number of elements added. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7435,205271,HelloTypeNode,4,HelloTypeObject.HelloTypeNode,,modules\hellotype.c,struct HelloTypeNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7436,208196,monotime,4,monotime,,monotonic.h,typedef uint64_t monotime;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7437,208202,monotonic_clock_type,4,monotonic_clock_type,,monotonic.h,"typedef enum monotonic_clock_type {
    MONOTONIC_CLOCK_POSIX,
    MONOTONIC_CLOCK_HW,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7438,208205,monotonic_clock_type,4,monotonic_clock_type,,monotonic.h,"typedef enum monotonic_clock_type {
    MONOTONIC_CLOCK_POSIX,
    MONOTONIC_CLOCK_HW,
} monotonic_clock_type;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7439,209709,watchedKey,4,watchedKey,,multi.c,"typedef struct watchedKey {
    listNode node;
    robj *key;
    redisDb *db;
    client *client;
    unsigned expired:1; /* Flag that we're watching an already expired key. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7440,209715,watchedKey,4,watchedKey,,multi.c,"typedef struct watchedKey {
    listNode node;
    robj *key;
    redisDb *db;
    client *client;
    unsigned expired:1; /* Flag that we're watching an already expired key. */
} watchedKey;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7441,225363,threads_pending,4,threads_pending,,networking.c,"typedef struct __attribute__((aligned(CACHE_LINE_SIZE))) threads_pending {
    redisAtomic unsigned long value;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7442,225365,threads_pending,4,threads_pending,,networking.c,"typedef struct __attribute__((aligned(CACHE_LINE_SIZE))) threads_pending {
    redisAtomic unsigned long value;
} threads_pending;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7443,235195,pubsubtype,4,pubsubtype,,pubsub.c,"typedef struct pubsubtype {
    int shard;
    dict *(*clientPubSubChannels)(client*);
    int (*subscriptionCount)(client*);
    dict **serverPubSubChannels;
    robj **subscribeMsg;
    robj **unsubscribeMsg;
    robj **messageBulk;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7444,235211,pubsubtype,4,pubsubtype,,pubsub.c,"typedef struct pubsubtype {
    int shard;
    dict *(*clientPubSubChannels)(client*);
    int (*subscriptionCount)(client*);
    dict **serverPubSubChannels;
    robj **subscribeMsg;
    robj **unsubscribeMsg;
    robj **messageBulk;
}pubsubtype;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7445,243723,quicklistNode,4,quicklistNode,,quicklist.h,"typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *entry;
    size_t sz;             /* entry size in bytes */
    unsigned int count : 16;     /* count of items in listpack */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* PLAIN==1 or PACKED==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */
    unsigned int extra : 9; /* more bits to steal for future usage */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7446,243724,quicklistNode,4,quicklistNode.quicklistNode,,quicklist.h,struct quicklistNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7447,243726,quicklistNode,4,quicklistNode.quicklistNode,,quicklist.h,struct quicklistNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7448,243737,quicklistNode,4,quicklistNode,,quicklist.h,"typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *entry;
    size_t sz;             /* entry size in bytes */
    unsigned int count : 16;     /* count of items in listpack */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* PLAIN==1 or PACKED==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */
    unsigned int extra : 9; /* more bits to steal for future usage */
} quicklistNode;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7449,243738,quicklistLZF,4,quicklistLZF,,quicklist.h,"typedef struct quicklistLZF {
    size_t sz; /* LZF size in bytes*/
    char compressed[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7450,243746,quicklistLZF,4,quicklistLZF,,quicklist.h,"typedef struct quicklistLZF {
    size_t sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7451,243747,quicklistBookmark,4,quicklistBookmark,,quicklist.h,"typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7452,243750,quicklistBookmark,4,quicklistBookmark,,quicklist.h,"typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
} quicklistBookmark;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7453,243751,quicklist,4,quicklist,,quicklist.h,"typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all listpacks */
    unsigned long len;          /* number of quicklistNodes */
    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7454,243765,quicklist,4,quicklist,,quicklist.h,"typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all listpacks */
    unsigned long len;          /* number of quicklistNodes */
    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7455,243766,quicklistIter,4,quicklistIter,,quicklist.h,"typedef struct quicklistIter {
    quicklist *quicklist;
    quicklistNode *current;
    unsigned char *zi; /* points to the current element */
    long offset; /* offset in current listpack */
    int direction;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7456,243772,quicklistIter,4,quicklistIter,,quicklist.h,"typedef struct quicklistIter {
    quicklist *quicklist;
    quicklistNode *current;
    unsigned char *zi; /* points to the current element */
    long offset; /* offset in current listpack */
    int direction;
} quicklistIter;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7457,243773,quicklistEntry,4,quicklistEntry,,quicklist.h,"typedef struct quicklistEntry {
    const quicklist *quicklist;
    quicklistNode *node;
    unsigned char *zi;
    unsigned char *value;
    long long longval;
    size_t sz;
    int offset;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7458,243781,quicklistEntry,4,quicklistEntry,,quicklist.h,"typedef struct quicklistEntry {
    const quicklist *quicklist;
    quicklistNode *node;
    unsigned char *zi;
    unsigned char *value;
    long long longval;
    size_t sz;
    int offset;
} quicklistEntry;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7459,251838,raxNode,4,raxNode,,rax.h,"typedef struct raxNode {
    uint32_t iskey:1;     /* Does this node contain a key? */
    uint32_t isnull:1;    /* Associated value is NULL (don't store it). */
    uint32_t iscompr:1;   /* Node is compressed. */
    uint32_t size:29;     /* Number of children, or compressed string len. */
    /* Data layout is as follows:
     *
     * If node is not compressed we have 'size' bytes, one for each children
     * character, and 'size' raxNode pointers, point to each child node.
     * Note how the character is not stored in the children but in the
     * edge of the parents:
     *
     * [header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?)
     *
     * if node is compressed (iscompr bit is 1) the node has 1 children.
     * In that case the 'size' bytes of the string stored immediately at
     * the start of the data section, represent a sequence of successive
     * nodes linked one after the other, for which only the last one in
     * the sequence is actually represented as...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7460,251849,raxNode,4,raxNode,,rax.h,"typedef struct raxNode {
    uint32_t iskey:1;     /* Does this node contain a key? */
    uint32_t isnull:1;    /* Associated value is NULL (don't store it). */
    uint32_t iscompr:1;   /* Node is compressed. */
    uint32_t size:29;     /* Number of children, or compressed string len. */
    /* Data layout is as follows:
     *
     * If node is not compressed we have 'size' bytes, one for each children
     * character, and 'size' raxNode pointers, point to each child node.
     * Note how the character is not stored in the children but in the
     * edge of the parents:
     *
     * [header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?)
     *
     * if node is compressed (iscompr bit is 1) the node has 1 children.
     * In that case the 'size' bytes of the string stored immediately at
     * the start of the data section, represent a sequence of successive
     * nodes linked one after the other, for which only the last one in
     * the sequence is actually represented as...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7461,251850,rax,4,rax,,rax.h,"typedef struct rax {
    raxNode *head;
    uint64_t numele;
    uint64_t numnodes;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7462,251854,rax,4,rax,,rax.h,"typedef struct rax {
    raxNode *head;
    uint64_t numele;
    uint64_t numnodes;
} rax;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7463,251855,raxStack,4,raxStack,,rax.h,"typedef struct raxStack {
    void **stack; /* Points to static_items or an heap allocated array. */
    size_t items, maxitems; /* Number of items contained and total space. */
    /* Up to RAXSTACK_STACK_ITEMS items we avoid to allocate on the heap
     * and use this static array of pointers instead. */
    void *static_items[RAX_STACK_STATIC_ITEMS];
    int oom; /* True if pushing into this stack failed for OOM at some point. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7464,251869,raxStack,4,raxStack,,rax.h,"typedef struct raxStack {
    void **stack; /* Points to static_items or an heap allocated array. */
    size_t items, maxitems; /* Number of items contained and total space. */
    /* Up to RAXSTACK_STACK_ITEMS items we avoid to allocate on the heap
     * and use this static array of pointers instead. */
    void *static_items[RAX_STACK_STATIC_ITEMS];
    int oom; /* True if pushing into this stack failed for OOM at some point. */
} raxStack;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7465,251875,raxIterator,4,raxIterator,,rax.h,"typedef struct raxIterator {
    int flags;
    rax *rt;                /* Radix tree we are iterating. */
    unsigned char *key;     /* The current string. */
    void *data;             /* Data associated to this key. */
    size_t key_len;         /* Current key length. */
    size_t key_max;         /* Max key len the current key buffer can hold. */
    unsigned char key_static_string[RAX_ITER_STATIC_LEN];
    raxNode *node;          /* Current node. Only for unsafe iteration. */
    raxStack stack;         /* Stack used for unsafe iteration. */
    raxNodeCallback node_cb; /* Optional node callback. Normally set to NULL. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7466,251894,raxIterator,4,raxIterator,,rax.h,"typedef struct raxIterator {
    int flags;
    rax *rt;                /* Radix tree we are iterating. */
    unsigned char *key;     /* The current string. */
    void *data;             /* Data associated to this key. */
    size_t key_len;         /* Current key length. */
    size_t key_max;         /* Max key len the current key buffer can hold. */
    unsigned char key_static_string[RAX_ITER_STATIC_LEN];
    raxNode *node;          /* Current node. Only for unsafe iteration. */
    raxStack stack;         /* Stack used for unsafe iteration. */
    raxNodeCallback node_cb; /* Optional node callback. Normally set to NULL. */
} raxIterator;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7467,266454,benchmarkThread,4,benchmarkThread,,redis-benchmark.c,struct benchmarkThread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7468,266455,clusterNode,4,clusterNode,,redis-benchmark.c,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7469,266456,redisConfig,4,redisConfig,,redis-benchmark.c,struct redisConfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7470,266457,config,4,config,,redis-benchmark.c,"static struct config {
    aeEventLoop *el;
    cliConnInfo conn_info;
    const char *hostsocket;
    int tls;
    struct cliSSLconfig sslconfig;
    int numclients;
    redisAtomic int liveclients;
    int requests;
    redisAtomic int requests_issued;
    redisAtomic int requests_finished;
    redisAtomic int previous_requests_finished;
    int last_printed_bytes;
    long long previous_tick;
    int keysize;
    int datasize;
    int randomkeys;
    int randomkeys_keyspacelen;
    int keepalive;
    int pipeline;
    long long start;
    long long totlatency;
    const char *title;
    list *clients;
    int quiet;
    int csv;
    int loop;
    int idlemode;
    sds input_dbnumstr;
    char *tests;
    int stdinarg; /* get last arg from stdin. (-x option) */
    int precision;
    int num_threads;
    struct benchmarkThread **threads;
    int cluster_mode;
    int cluster_node_count;
    struct clusterNode **cluster_nodes;
    struct redisConfig *redis_config;
    struct hdr_hi...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7471,266462,cliSSLconfig,4,config.cliSSLconfig,,redis-benchmark.c,struct cliSSLconfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7472,266491,benchmarkThread,4,config.benchmarkThread,,redis-benchmark.c,struct benchmarkThread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7473,266495,clusterNode,4,config.clusterNode,,redis-benchmark.c,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7474,266497,redisConfig,4,config.redisConfig,,redis-benchmark.c,struct redisConfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7475,266499,hdr_histogram,4,config.hdr_histogram,,redis-benchmark.c,struct hdr_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7476,266501,hdr_histogram,4,config.hdr_histogram,,redis-benchmark.c,struct hdr_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7477,266511,_client,4,_client,,redis-benchmark.c,"typedef struct _client {
    redisContext *context;
    sds obuf;
    char **randptr;         /* Pointers to :rand: strings inside the command buf */
    size_t randlen;         /* Number of pointers in client->randptr */
    size_t randfree;        /* Number of unused pointers in client->randptr */
    char **stagptr;         /* Pointers to slot hashtags (cluster mode only) */
    size_t staglen;         /* Number of pointers in client->stagptr */
    size_t stagfree;        /* Number of unused pointers in client->stagptr */
    size_t written;         /* Bytes of 'obuf' already written */
    long long start;        /* Start time of a request */
    long long latency;      /* Request latency */
    int pending;            /* Number of pending requests (replies to consume) */
    int prefix_pending;     /* If non-zero, number of pending prefix commands. Commands
                               such as auth and select are prefixed to the pipeline of
                               ben...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7478,266527,clusterNode,4,_client.clusterNode,,redis-benchmark.c,struct clusterNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7479,266530,client,4,client,,redis-benchmark.c,"typedef struct _client {
    redisContext *context;
    sds obuf;
    char **randptr;         /* Pointers to :rand: strings inside the command buf */
    size_t randlen;         /* Number of pointers in client->randptr */
    size_t randfree;        /* Number of unused pointers in client->randptr */
    char **stagptr;         /* Pointers to slot hashtags (cluster mode only) */
    size_t staglen;         /* Number of pointers in client->stagptr */
    size_t stagfree;        /* Number of unused pointers in client->stagptr */
    size_t written;         /* Bytes of 'obuf' already written */
    long long start;        /* Start time of a request */
    long long latency;      /* Request latency */
    int pending;            /* Number of pending requests (replies to consume) */
    int prefix_pending;     /* If non-zero, number of pending prefix commands. Commands
                               such as auth and select are prefixed to the pipeline of
                               ben...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7480,266531,benchmarkThread,4,benchmarkThread,,redis-benchmark.c,"typedef struct benchmarkThread {
    int index;
    pthread_t thread;
    aeEventLoop *el;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7481,266535,benchmarkThread,4,benchmarkThread,,redis-benchmark.c,"typedef struct benchmarkThread {
    int index;
    pthread_t thread;
    aeEventLoop *el;
} benchmarkThread;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7482,266536,clusterNode,4,clusterNode,,redis-benchmark.c,"typedef struct clusterNode {
    char *ip;
    int port;
    sds name;
    int flags;
    sds replicate;  /* Master ID if node is a slave */
    int *slots;
    int slots_count;
    int current_slot_index;
    int *updated_slots;         /* Used by updateClusterSlotsConfiguration */
    int updated_slots_count;    /* Used by updateClusterSlotsConfiguration */
    int replicas_count;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    struct redisConfig *redis_config;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7483,266552,redisConfig,4,clusterNode.redisConfig,,redis-benchmark.c,struct redisConfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7484,266554,clusterNode,4,clusterNode,,redis-benchmark.c,"typedef struct clusterNode {
    char *ip;
    int port;
    sds name;
    int flags;
    sds replicate;  /* Master ID if node is a slave */
    int *slots;
    int slots_count;
    int current_slot_index;
    int *updated_slots;         /* Used by updateClusterSlotsConfiguration */
    int updated_slots_count;    /* Used by updateClusterSlotsConfiguration */
    int replicas_count;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    struct redisConfig *redis_config;
} clusterNode;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7485,266555,redisConfig,4,redisConfig,,redis-benchmark.c,"typedef struct redisConfig {
    sds save;
    sds appendonly;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7486,266558,redisConfig,4,redisConfig,,redis-benchmark.c,"typedef struct redisConfig {
    sds save;
    sds appendonly;
} redisConfig;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7487,274123,input_file_type,4,input_file_type,,redis-check-aof.c,"typedef enum {
    AOF_RESP,
    AOF_RDB_PREAMBLE,
    AOF_MULTI_PART,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7488,275704,rdbstate,4,rdbstate,,redis-check-rdb.c,"struct {
    rio *rio;
    robj *key;                      /* Current key we are reading. */
    int key_type;                   /* Current key type if != -1. */
    unsigned long keys;             /* Number of keys processed. */
    unsigned long expires;          /* Number of keys with an expire. */
    unsigned long already_expired;  /* Number of keys already expired. */
    int doing;                      /* The state while reading the RDB. */
    int error_set;                  /* True if error is populated. */
    char error[1024];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7489,277073,termios,4,termios,,redis-cli.c,static struct termios,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7490,277099,clusterManagerCommand,4,clusterManagerCommand,,redis-cli.c,"typedef struct clusterManagerCommand {
    char *name;
    int argc;
    char **argv;
    sds stdin_arg; /* arg from stdin. (-X option) */
    int flags;
    int replicas;
    char *from;
    char *to;
    char **weight;
    int weight_argc;
    char *master_id;
    int slots;
    int timeout;
    int pipeline;
    float threshold;
    char *backup_dir;
    char *from_user;
    char *from_pass;
    int from_askpass;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7491,277119,clusterManagerCommand,4,clusterManagerCommand,,redis-cli.c,"typedef struct clusterManagerCommand {
    char *name;
    int argc;
    char **argv;
    sds stdin_arg; /* arg from stdin. (-X option) */
    int flags;
    int replicas;
    char *from;
    char *to;
    char **weight;
    int weight_argc;
    char *master_id;
    int slots;
    int timeout;
    int pipeline;
    float threshold;
    char *backup_dir;
    char *from_user;
    char *from_pass;
    int from_askpass;
} clusterManagerCommand;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7492,277128,config,4,config,,redis-cli.c,"static struct config {
    cliConnInfo conn_info;
    char *hostsocket;
    int tls;
    cliSSLconfig sslconfig;
    long repeat;
    long interval;
    int dbnum; /* db num currently selected */
    int interactive;
    int shutdown;
    int monitor_mode;
    int pubsub_mode;
    int blocking_state_aborted; /* used to abort monitor_mode and pubsub_mode. */
    int latency_mode;
    int latency_dist_mode;
    int latency_history;
    int lru_test_mode;
    long long lru_test_sample_size;
    int cluster_mode;
    int cluster_reissue_command;
    int cluster_send_asking;
    int slave_mode;
    int pipe_mode;
    int pipe_timeout;
    int getrdb_mode;
    int get_functions_rdb_mode;
    int stat_mode;
    int scan_mode;
    int count;
    int intrinsic_latency_mode;
    int intrinsic_latency_duration;
    sds pattern;
    char *rdb_filename;
    int bigkeys;
    int memkeys;
    unsigned memkeys_samples;
    int hotkeys;
    int stdin_lastarg; /* get last arg from stdin. (-x option) ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7493,277201,pref,4,pref,,redis-cli.c,"static struct pref {
    int hints;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7494,277559,helpEntry,4,helpEntry,,redis-cli.c,"typedef struct {
    int type;
    int argc;
    sds *argv;
    sds full;

    /* Only used for help on commands */
    struct commandDocs docs;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7495,277564,commandDocs,4,helpEntry.commandDocs,,redis-cli.c,struct commandDocs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7496,289857,clusterManager,4,clusterManager,,redis-cli.c,"static struct clusterManager {
    list *nodes;    /* List of nodes in the configuration. */
    list *errors;
    int unreachable_masters;    /* Masters we are not able to reach. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7497,289866,clusterManagerNode,4,clusterManagerNode,,redis-cli.c,"typedef struct clusterManagerNode {
    redisContext *context;
    sds name;
    char *ip;
    int port;
    int bus_port; /* cluster-port */
    uint64_t current_epoch;
    time_t ping_sent;
    time_t ping_recv;
    int flags;
    list *flags_str; /* Flags string representations */
    sds replicate;  /* Master ID if node is a slave */
    int dirty;      /* Node has changes that can be flushed */
    uint8_t slots[CLUSTER_MANAGER_SLOTS];
    int slots_count;
    int replicas_count;
    list *friends;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    float weight;   /* Weight used by rebalance */
...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7498,289897,clusterManagerNode,4,clusterManagerNode,,redis-cli.c,"typedef struct clusterManagerNode {
    redisContext *context;
    sds name;
    char *ip;
    int port;
    int bus_port; /* cluster-port */
    uint64_t current_epoch;
    time_t ping_sent;
    time_t ping_recv;
    int flags;
    list *flags_str; /* Flags string representations */
    sds replicate;  /* Master ID if node is a slave */
    int dirty;      /* Node has changes that can be flushed */
    uint8_t slots[CLUSTER_MANAGER_SLOTS];
    int slots_count;
    int replicas_count;
    list *friends;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    float weight;   /* Weight used by rebalance */
...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7499,289898,clusterManagerNodeArray,4,clusterManagerNodeArray,,redis-cli.c,"typedef struct clusterManagerNodeArray {
    clusterManagerNode **nodes; /* Actual nodes array */
    clusterManagerNode **alloc; /* Pointer to the allocated memory */
    int len;                    /* Actual length of the array */
    int count;                  /* Non-NULL nodes count */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7500,289903,clusterManagerNodeArray,4,clusterManagerNodeArray,,redis-cli.c,"typedef struct clusterManagerNodeArray {
    clusterManagerNode **nodes; /* Actual nodes array */
    clusterManagerNode **alloc; /* Pointer to the allocated memory */
    int len;                    /* Actual length of the array */
    int count;                  /* Non-NULL nodes count */
} clusterManagerNodeArray;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7501,289904,clusterManagerReshardTableItem,4,clusterManagerReshardTableItem,,redis-cli.c,"typedef struct clusterManagerReshardTableItem {
    clusterManagerNode *source;
    int slot;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7502,289907,clusterManagerReshardTableItem,4,clusterManagerReshardTableItem,,redis-cli.c,"typedef struct clusterManagerReshardTableItem {
    clusterManagerNode *source;
    int slot;
} clusterManagerReshardTableItem;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7503,289908,clusterManagerLink,4,clusterManagerLink,,redis-cli.c,"typedef struct clusterManagerLink {
    sds node_name;
    sds node_addr;
    int connected;
    int handshaking;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7504,289913,clusterManagerLink,4,clusterManagerLink,,redis-cli.c,"typedef struct clusterManagerLink {
    sds node_name;
    sds node_addr;
    int connected;
    int handshaking;
} clusterManagerLink;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7505,290169,clusterManagerCommandDef,4,clusterManagerCommandDef,,redis-cli.c,"typedef struct clusterManagerCommandDef {
    char *name;
    clusterManagerCommandProc *proc;
    int arity;
    char *args;
    char *options;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7506,290175,clusterManagerCommandDef,4,clusterManagerCommandDef,,redis-cli.c,"typedef struct clusterManagerCommandDef {
    char *name;
    clusterManagerCommandProc *proc;
    int arity;
    char *args;
    char *options;
} clusterManagerCommandDef;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7507,290265,clusterManagerOptionDef,4,clusterManagerOptionDef,,redis-cli.c,"typedef struct clusterManagerOptionDef {
    char *name;
    char *desc;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7508,290268,clusterManagerOptionDef,4,clusterManagerOptionDef,,redis-cli.c,"typedef struct clusterManagerOptionDef {
    char *name;
    char *desc;
} clusterManagerOptionDef;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7509,308481,distsamples,4,distsamples,,redis-cli.c,"struct distsamples {
    long long max;   /* Max latency to fit into this interval (usec). */
    long long count; /* Number of samples in this interval. */
    int character;   /* Associated character in visualization. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7510,310345,typeinfo,4,typeinfo,,redis-cli.c,"typedef struct {
    char *name;
    char *sizecmd;
    char *sizeunit;
    unsigned long long biggest;
    unsigned long long count;
    unsigned long long totalsize;
    sds biggest_key;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7511,314157,RedisModuleString,4,RedisModuleString,,redismodule.h,typedef struct RedisModuleString,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7512,314158,RedisModuleString,4,RedisModuleString,,redismodule.h,typedef struct RedisModuleString RedisModuleString;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7513,314159,RedisModuleKey,4,RedisModuleKey,,redismodule.h,typedef struct RedisModuleKey,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7514,314160,RedisModuleKey,4,RedisModuleKey,,redismodule.h,typedef struct RedisModuleKey RedisModuleKey;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7515,314161,mstime_t,4,mstime_t,,redismodule.h,typedef long long mstime_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7516,314162,ustime_t,4,ustime_t,,redismodule.h,typedef long long ustime_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7517,314163,RedisModuleStreamID,4,RedisModuleStreamID,,redismodule.h,"typedef struct RedisModuleStreamID {
    uint64_t ms;
    uint64_t seq;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7518,314166,RedisModuleStreamID,4,RedisModuleStreamID,,redismodule.h,"typedef struct RedisModuleStreamID {
    uint64_t ms;
    uint64_t seq;
} RedisModuleStreamID;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7519,314167,RedisModuleTimerID,4,RedisModuleTimerID,,redismodule.h,typedef uint64_t RedisModuleTimerID;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7520,314168,RedisModuleCommandArgType,4,RedisModuleCommandArgType,,redismodule.h,"typedef enum {
    REDISMODULE_ARG_TYPE_STRING,
    REDISMODULE_ARG_TYPE_INTEGER,
    REDISMODULE_ARG_TYPE_DOUBLE,
    REDISMODULE_ARG_TYPE_KEY, /* A string, but represents a keyname */
    REDISMODULE_ARG_TYPE_PATTERN,
    REDISMODULE_ARG_TYPE_UNIX_TIME,
    REDISMODULE_ARG_TYPE_PURE_TOKEN,
    REDISMODULE_ARG_TYPE_ONEOF, /* Must have sub-arguments */
    REDISMODULE_ARG_TYPE_BLOCK /* Must have sub-arguments */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7521,314179,RedisModuleKeySpecBeginSearchType,4,RedisModuleKeySpecBeginSearchType,,redismodule.h,"typedef enum {
    REDISMODULE_KSPEC_BS_INVALID = 0, /* Must be zero. An implicitly value of
                                       * zero is provided when the field is
                                       * absent in a struct literal. */
    REDISMODULE_KSPEC_BS_UNKNOWN,
    REDISMODULE_KSPEC_BS_INDEX,
    REDISMODULE_KSPEC_BS_KEYWORD
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7522,314192,RedisModuleKeySpecFindKeysType,4,RedisModuleKeySpecFindKeysType,,redismodule.h,"typedef enum {
    REDISMODULE_KSPEC_FK_OMITTED = 0, /* Used when the field is absent in a
                                       * struct literal. Don't use this value
                                       * explicitly. */
    REDISMODULE_KSPEC_FK_UNKNOWN,
    REDISMODULE_KSPEC_FK_RANGE,
    REDISMODULE_KSPEC_FK_KEYNUM
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7523,314205,RedisModuleCommandArg,4,RedisModuleCommandArg,,redismodule.h,"typedef struct RedisModuleCommandArg {
    const char *name;
    RedisModuleCommandArgType type;
    int key_spec_index;       /* If type is KEY, this is a zero-based index of
                               * the key_spec in the command. For other types,
                               * you may specify -1. */
    const char *token;        /* If type is PURE_TOKEN, this is the token. */
    const char *summary;
    const char *since;
    int flags;                /* The REDISMODULE_CMD_ARG_* macros. */
    const char *deprecated_since;
    struct RedisModuleCommandArg *subargs;
    const char *display_text;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7524,314214,RedisModuleCommandArg,4,RedisModuleCommandArg.RedisModuleCommandArg,,redismodule.h,struct RedisModuleCommandArg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7525,314217,RedisModuleCommandArg,4,RedisModuleCommandArg,,redismodule.h,"typedef struct RedisModuleCommandArg {
    const char *name;
    RedisModuleCommandArgType type;
    int key_spec_index;       /* If type is KEY, this is a zero-based index of
                               * the key_spec in the command. For other types,
                               * you may specify -1. */
    const char *token;        /* If type is PURE_TOKEN, this is the token. */
    const char *summary;
    const char *since;
    int flags;                /* The REDISMODULE_CMD_ARG_* macros. */
    const char *deprecated_since;
    struct RedisModuleCommandArg *subargs;
    const char *display_text;
} RedisModuleCommandArg;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7526,314218,RedisModuleCommandHistoryEntry,4,RedisModuleCommandHistoryEntry,,redismodule.h,"typedef struct {
    const char *since;
    const char *changes;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7527,314222,RedisModuleCommandKeySpec,4,RedisModuleCommandKeySpec,,redismodule.h,"typedef struct {
    const char *notes;
    uint64_t flags; /* REDISMODULE_CMD_KEY_* macros. */
    RedisModuleKeySpecBeginSearchType begin_search_type;
    union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    } bs;
    RedisModuleKeySpecFindKeysType find_keys_type;
    union {
        struct {
            /* Index of the last key relative to the result of the begin search
             * step. Can be negative, in which case it's not relative. -1
             * indicating till the last argument, -2 one before the la...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7528,314226,RedisModuleCommandKeySpec.bs,4,RedisModuleCommandKeySpec.bs,,redismodule.h,"union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7529,314227,RedisModuleCommandKeySpec.bs.index,4,RedisModuleCommandKeySpec.bs.index,,redismodule.h,"struct {
            /* The index from which we start the search for keys */
            int pos;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7530,314230,RedisModuleCommandKeySpec.bs.keyword,4,RedisModuleCommandKeySpec.bs.keyword,,redismodule.h,"struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7531,314236,RedisModuleCommandKeySpec.fk,4,RedisModuleCommandKeySpec.fk,,redismodule.h,"union {
        struct {
            /* Index of the last key relative to the result of the begin search
             * step. Can be negative, in which case it's not relative. -1
             * indicating till the last argument, -2 one before the last and so
             * on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to
             * find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0
             * and 1 mean no limit. 2 means 1/2 of the remaining args, 3 means
             * 1/3, and so on. */
            int limit;
        } range;
        struct {
            /* Index of the argument containing the number of keys to come
             * relative to the result of the begin search step */
            int keynumidx;
            /* Index of the fist key. (Usually it's just after keynumidx, in
             * which case it should be set to keynumidx +...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7532,314237,RedisModuleCommandKeySpec.fk.range,4,RedisModuleCommandKeySpec.fk.range,,redismodule.h,"struct {
            /* Index of the last key relative to the result of the begin search
             * step. Can be negative, in which case it's not relative. -1
             * indicating till the last argument, -2 one before the last and so
             * on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to
             * find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0
             * and 1 mean no limit. 2 means 1/2 of the remaining args, 3 means
             * 1/3, and so on. */
            int limit;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7533,314242,RedisModuleCommandKeySpec.fk.keynum,4,RedisModuleCommandKeySpec.fk.keynum,,redismodule.h,"struct {
            /* Index of the argument containing the number of keys to come
             * relative to the result of the begin search step */
            int keynumidx;
            /* Index of the fist key. (Usually it's just after keynumidx, in
             * which case it should be set to keynumidx + 1.) */
            int firstkey;
            /* How many args should we skip after finding a key, in order to
             * find the next one, relative to the result of the begin search
             * step. */
            int keystep;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7534,314249,RedisModuleCommandInfoVersion,4,RedisModuleCommandInfoVersion,,redismodule.h,"typedef struct {
    int version;
    size_t sizeof_historyentry;
    size_t sizeof_keyspec;
    size_t sizeof_arg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7535,314278,RedisModuleCommandInfo,4,RedisModuleCommandInfo,,redismodule.h,"typedef struct {
    /* Always set version to REDISMODULE_COMMAND_INFO_VERSION */
    const RedisModuleCommandInfoVersion *version;
    /* Version 1 fields (added in Redis 7.0.0) */
    const char *summary;          /* Summary of the command */
    const char *complexity;       /* Complexity description */
    const char *since;            /* Debut module version of the command */
    RedisModuleCommandHistoryEntry *history; /* History */
    /* A string of space-separated tips meant for clients/proxies regarding this
     * command */
    const char *tips;
    /* Number of arguments, it is possible to use -N to say >= N */
    int arity;
    RedisModuleCommandKeySpec *key_specs;
    RedisModuleCommandArg *args;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7536,314301,RedisModuleEvent,4,RedisModuleEvent,,redismodule.h,"typedef struct RedisModuleEvent {
    uint64_t id;        /* REDISMODULE_EVENT_... defines. */
    uint64_t dataver;   /* Version of the structure we pass as 'data'. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7537,314304,RedisModuleEvent,4,RedisModuleEvent,,redismodule.h,"typedef struct RedisModuleEvent {
    uint64_t id;        /* REDISMODULE_EVENT_... defines. */
    uint64_t dataver;   /* Version of the structure we pass as 'data'. */
} RedisModuleEvent;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7538,314305,RedisModuleCtx,4,RedisModuleCtx,,redismodule.h,struct RedisModuleCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7539,314306,RedisModuleDefragCtx,4,RedisModuleDefragCtx,,redismodule.h,struct RedisModuleDefragCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7540,314459,RedisModuleClientInfo,4,RedisModuleClientInfo,,redismodule.h,"typedef struct RedisModuleClientInfo {
    uint64_t version;       /* Version of this structure for ABI compat. */
    uint64_t flags;         /* REDISMODULE_CLIENTINFO_FLAG_* */
    uint64_t id;            /* Client ID. */
    char addr[46];          /* IPv4 or IPv6 address. */
    uint16_t port;          /* TCP port. */
    uint16_t db;            /* Selected DB. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7541,314472,RedisModuleClientInfoV1,4,RedisModuleClientInfoV1,,redismodule.h,"typedef struct RedisModuleClientInfo {
    uint64_t version;       /* Version of this structure for ABI compat. */
    uint64_t flags;         /* REDISMODULE_CLIENTINFO_FLAG_* */
    uint64_t id;            /* Client ID. */
    char addr[46];          /* IPv4 or IPv6 address. */
    uint16_t port;          /* TCP port. */
    uint16_t db;            /* Selected DB. */
} RedisModuleClientInfoV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7542,314473,RedisModuleReplicationInfo,4,RedisModuleReplicationInfo,,redismodule.h,"typedef struct RedisModuleReplicationInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int master;             /* true if master, false if replica */
    char *masterhost;       /* master instance hostname for NOW_REPLICA */
    int masterport;         /* master instance port for NOW_REPLICA */
    char *replid1;          /* Main replication ID */
    char *replid2;          /* Secondary replication ID */
    uint64_t repl1_offset;  /* Main replication offset */
    uint64_t repl2_offset;  /* Offset of replid2 validity */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7543,314482,RedisModuleReplicationInfoV1,4,RedisModuleReplicationInfoV1,,redismodule.h,"typedef struct RedisModuleReplicationInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int master;             /* true if master, false if replica */
    char *masterhost;       /* master instance hostname for NOW_REPLICA */
    int masterport;         /* master instance port for NOW_REPLICA */
    char *replid1;          /* Main replication ID */
    char *replid2;          /* Secondary replication ID */
    uint64_t repl1_offset;  /* Main replication offset */
    uint64_t repl2_offset;  /* Offset of replid2 validity */
} RedisModuleReplicationInfoV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7544,314483,RedisModuleFlushInfo,4,RedisModuleFlushInfo,,redismodule.h,"typedef struct RedisModuleFlushInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t sync;           /* Synchronous or threaded flush?. */
    int32_t dbnum;          /* Flushed database number, -1 for ALL. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7545,314487,RedisModuleFlushInfoV1,4,RedisModuleFlushInfoV1,,redismodule.h,"typedef struct RedisModuleFlushInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t sync;           /* Synchronous or threaded flush?. */
    int32_t dbnum;          /* Flushed database number, -1 for ALL. */
} RedisModuleFlushInfoV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7546,314488,RedisModuleModuleChange,4,RedisModuleModuleChange,,redismodule.h,"typedef struct RedisModuleModuleChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    const char* module_name;/* Name of module loaded or unloaded. */
    int32_t module_version; /* Module version. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7547,314492,RedisModuleModuleChangeV1,4,RedisModuleModuleChangeV1,,redismodule.h,"typedef struct RedisModuleModuleChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    const char* module_name;/* Name of module loaded or unloaded. */
    int32_t module_version; /* Module version. */
} RedisModuleModuleChangeV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7548,314493,RedisModuleConfigChange,4,RedisModuleConfigChange,,redismodule.h,"typedef struct RedisModuleConfigChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    uint32_t num_changes;   /* how many redis config options were changed */
    const char **config_names; /* the config names that were changed */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7549,314497,RedisModuleConfigChangeV1,4,RedisModuleConfigChangeV1,,redismodule.h,"typedef struct RedisModuleConfigChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    uint32_t num_changes;   /* how many redis config options were changed */
    const char **config_names; /* the config names that were changed */
} RedisModuleConfigChangeV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7550,314498,RedisModuleCronLoopInfo,4,RedisModuleCronLoopInfo,,redismodule.h,"typedef struct RedisModuleCronLoopInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7551,314501,RedisModuleCronLoopV1,4,RedisModuleCronLoopV1,,redismodule.h,"typedef struct RedisModuleCronLoopInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
} RedisModuleCronLoopV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7552,314502,RedisModuleLoadingProgressInfo,4,RedisModuleLoadingProgressInfo,,redismodule.h,"typedef struct RedisModuleLoadingProgressInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
    int32_t progress;       /* Approximate progress between 0 and 1024, or -1
                             * if unknown. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7553,314506,RedisModuleLoadingProgressV1,4,RedisModuleLoadingProgressV1,,redismodule.h,"typedef struct RedisModuleLoadingProgressInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
    int32_t progress;       /* Approximate progress between 0 and 1024, or -1
                             * if unknown. */
} RedisModuleLoadingProgressV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7554,314507,RedisModuleSwapDbInfo,4,RedisModuleSwapDbInfo,,redismodule.h,"typedef struct RedisModuleSwapDbInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t dbnum_first;    /* Swap Db first dbnum */
    int32_t dbnum_second;   /* Swap Db second dbnum */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7555,314511,RedisModuleSwapDbInfoV1,4,RedisModuleSwapDbInfoV1,,redismodule.h,"typedef struct RedisModuleSwapDbInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t dbnum_first;    /* Swap Db first dbnum */
    int32_t dbnum_second;   /* Swap Db second dbnum */
} RedisModuleSwapDbInfoV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7556,314512,RedisModuleKeyInfo,4,RedisModuleKeyInfo,,redismodule.h,"typedef struct RedisModuleKeyInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    RedisModuleKey *key;    /* Opened key. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7557,314515,RedisModuleKeyInfoV1,4,RedisModuleKeyInfoV1,,redismodule.h,"typedef struct RedisModuleKeyInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    RedisModuleKey *key;    /* Opened key. */
} RedisModuleKeyInfoV1;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7558,314516,RedisModuleACLLogEntryReason,4,RedisModuleACLLogEntryReason,,redismodule.h,"typedef enum {
    REDISMODULE_ACL_LOG_AUTH = 0, /* Authentication failure */
    REDISMODULE_ACL_LOG_CMD, /* Command authorization failure */
    REDISMODULE_ACL_LOG_KEY, /* Key authorization failure */
    REDISMODULE_ACL_LOG_CHANNEL /* Channel authorization failure */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7559,314529,RedisModuleIO,4,RedisModuleIO,,redismodule.h,typedef struct RedisModuleIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7560,314530,RedisModuleIO,4,RedisModuleIO,,redismodule.h,typedef struct RedisModuleIO RedisModuleIO;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7561,314531,RedisModuleDigest,4,RedisModuleDigest,,redismodule.h,typedef struct RedisModuleDigest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7562,314532,RedisModuleDigest,4,RedisModuleDigest,,redismodule.h,typedef struct RedisModuleDigest RedisModuleDigest;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7563,314533,RedisModuleInfoCtx,4,RedisModuleInfoCtx,,redismodule.h,typedef struct RedisModuleInfoCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7564,314534,RedisModuleInfoCtx,4,RedisModuleInfoCtx,,redismodule.h,typedef struct RedisModuleInfoCtx RedisModuleInfoCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7565,314535,RedisModuleDefragCtx,4,RedisModuleDefragCtx,,redismodule.h,typedef struct RedisModuleDefragCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7566,314536,RedisModuleDefragCtx,4,RedisModuleDefragCtx,,redismodule.h,typedef struct RedisModuleDefragCtx RedisModuleDefragCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7567,314554,RedisModuleCtx,4,RedisModuleCtx,,redismodule.h,typedef struct RedisModuleCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7568,314555,RedisModuleCtx,4,RedisModuleCtx,,redismodule.h,typedef struct RedisModuleCtx RedisModuleCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7569,314556,RedisModuleCommand,4,RedisModuleCommand,,redismodule.h,typedef struct RedisModuleCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7570,314557,RedisModuleCommand,4,RedisModuleCommand,,redismodule.h,typedef struct RedisModuleCommand RedisModuleCommand;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7571,314558,RedisModuleCallReply,4,RedisModuleCallReply,,redismodule.h,typedef struct RedisModuleCallReply,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7572,314559,RedisModuleCallReply,4,RedisModuleCallReply,,redismodule.h,typedef struct RedisModuleCallReply RedisModuleCallReply;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7573,314560,RedisModuleType,4,RedisModuleType,,redismodule.h,typedef struct RedisModuleType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7574,314561,RedisModuleType,4,RedisModuleType,,redismodule.h,typedef struct RedisModuleType RedisModuleType;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7575,314562,RedisModuleBlockedClient,4,RedisModuleBlockedClient,,redismodule.h,typedef struct RedisModuleBlockedClient,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7576,314563,RedisModuleBlockedClient,4,RedisModuleBlockedClient,,redismodule.h,typedef struct RedisModuleBlockedClient RedisModuleBlockedClient;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7577,314564,RedisModuleClusterInfo,4,RedisModuleClusterInfo,,redismodule.h,typedef struct RedisModuleClusterInfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7578,314565,RedisModuleClusterInfo,4,RedisModuleClusterInfo,,redismodule.h,typedef struct RedisModuleClusterInfo RedisModuleClusterInfo;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7579,314566,RedisModuleDict,4,RedisModuleDict,,redismodule.h,typedef struct RedisModuleDict,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7580,314567,RedisModuleDict,4,RedisModuleDict,,redismodule.h,typedef struct RedisModuleDict RedisModuleDict;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7581,314568,RedisModuleDictIter,4,RedisModuleDictIter,,redismodule.h,typedef struct RedisModuleDictIter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7582,314569,RedisModuleDictIter,4,RedisModuleDictIter,,redismodule.h,typedef struct RedisModuleDictIter RedisModuleDictIter;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7583,314570,RedisModuleCommandFilterCtx,4,RedisModuleCommandFilterCtx,,redismodule.h,typedef struct RedisModuleCommandFilterCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7584,314571,RedisModuleCommandFilterCtx,4,RedisModuleCommandFilterCtx,,redismodule.h,typedef struct RedisModuleCommandFilterCtx RedisModuleCommandFilterCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7585,314572,RedisModuleCommandFilter,4,RedisModuleCommandFilter,,redismodule.h,typedef struct RedisModuleCommandFilter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7586,314573,RedisModuleCommandFilter,4,RedisModuleCommandFilter,,redismodule.h,typedef struct RedisModuleCommandFilter RedisModuleCommandFilter;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7587,314574,RedisModuleServerInfoData,4,RedisModuleServerInfoData,,redismodule.h,typedef struct RedisModuleServerInfoData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7588,314575,RedisModuleServerInfoData,4,RedisModuleServerInfoData,,redismodule.h,typedef struct RedisModuleServerInfoData RedisModuleServerInfoData;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7589,314576,RedisModuleScanCursor,4,RedisModuleScanCursor,,redismodule.h,typedef struct RedisModuleScanCursor,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7590,314577,RedisModuleScanCursor,4,RedisModuleScanCursor,,redismodule.h,typedef struct RedisModuleScanCursor RedisModuleScanCursor;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7591,314578,RedisModuleUser,4,RedisModuleUser,,redismodule.h,typedef struct RedisModuleUser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7592,314579,RedisModuleUser,4,RedisModuleUser,,redismodule.h,typedef struct RedisModuleUser RedisModuleUser;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7593,314580,RedisModuleKeyOptCtx,4,RedisModuleKeyOptCtx,,redismodule.h,typedef struct RedisModuleKeyOptCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7594,314581,RedisModuleKeyOptCtx,4,RedisModuleKeyOptCtx,,redismodule.h,typedef struct RedisModuleKeyOptCtx RedisModuleKeyOptCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7595,314582,RedisModuleRdbStream,4,RedisModuleRdbStream,,redismodule.h,typedef struct RedisModuleRdbStream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7596,314583,RedisModuleRdbStream,4,RedisModuleRdbStream,,redismodule.h,typedef struct RedisModuleRdbStream RedisModuleRdbStream;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7597,314831,RedisModuleTypeMethods,4,RedisModuleTypeMethods,,redismodule.h,"typedef struct RedisModuleTypeMethods {
    uint64_t version;
    RedisModuleTypeLoadFunc rdb_load;
    RedisModuleTypeSaveFunc rdb_save;
    RedisModuleTypeRewriteFunc aof_rewrite;
    RedisModuleTypeMemUsageFunc mem_usage;
    RedisModuleTypeDigestFunc digest;
    RedisModuleTypeFreeFunc free;
    RedisModuleTypeAuxLoadFunc aux_load;
    RedisModuleTypeAuxSaveFunc aux_save;
    int aux_save_triggers;
    RedisModuleTypeFreeEffortFunc free_effort;
    RedisModuleTypeUnlinkFunc unlink;
    RedisModuleTypeCopyFunc copy;
    RedisModuleTypeDefragFunc defrag;
    RedisModuleTypeMemUsageFunc2 mem_usage2;
    RedisModuleTypeFreeEffortFunc2 free_effort2;
    RedisModuleTypeUnlinkFunc2 unlink2;
    RedisModuleTypeCopyFunc2 copy2;
    RedisModuleTypeAuxSaveFunc aux_save2;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7598,314851,RedisModuleTypeMethods,4,RedisModuleTypeMethods,,redismodule.h,"typedef struct RedisModuleTypeMethods {
    uint64_t version;
    RedisModuleTypeLoadFunc rdb_load;
    RedisModuleTypeSaveFunc rdb_save;
    RedisModuleTypeRewriteFunc aof_rewrite;
    RedisModuleTypeMemUsageFunc mem_usage;
    RedisModuleTypeDigestFunc digest;
    RedisModuleTypeFreeFunc free;
    RedisModuleTypeAuxLoadFunc aux_load;
    RedisModuleTypeAuxSaveFunc aux_save;
    int aux_save_triggers;
    RedisModuleTypeFreeEffortFunc free_effort;
    RedisModuleTypeUnlinkFunc unlink;
    RedisModuleTypeCopyFunc copy;
    RedisModuleTypeDefragFunc defrag;
    RedisModuleTypeMemUsageFunc2 mem_usage2;
    RedisModuleTypeFreeEffortFunc2 free_effort2;
    RedisModuleTypeUnlinkFunc2 unlink2;
    RedisModuleTypeCopyFunc2 copy2;
    RedisModuleTypeAuxSaveFunc aux_save2;
} RedisModuleTypeMethods;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7599,334229,ReplyParser,4,ReplyParser,,resp_parser.h,typedef struct ReplyParser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7600,334230,ReplyParser,4,ReplyParser,,resp_parser.h,typedef struct ReplyParser ReplyParser;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7601,334231,ReplyParserCallbacks,4,ReplyParserCallbacks,,resp_parser.h,"typedef struct ReplyParserCallbacks {
    /* Called when the parser reaches an empty mbulk ('*-1') */
    void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches an empty bulk ('$-1') (bulk len is -1) */
    void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches a bulk ('$'), which is passed as 'str' along with its length 'len' */
    void (*bulk_string_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches an error ('-'), which is passed as 'str' along with its length 'len' */
    void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches a simple string ('+'), which is passed as 'str' along with its length 'len' */
    void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, s...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7602,334360,ReplyParserCallbacks,4,ReplyParserCallbacks,,resp_parser.h,"typedef struct ReplyParserCallbacks {
    /* Called when the parser reaches an empty mbulk ('*-1') */
    void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches an empty bulk ('$-1') (bulk len is -1) */
    void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches a bulk ('$'), which is passed as 'str' along with its length 'len' */
    void (*bulk_string_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches an error ('-'), which is passed as 'str' along with its length 'len' */
    void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches a simple string ('+'), which is passed as 'str' along with its length 'len' */
    void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, s...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7603,334361,ReplyParser,4,ReplyParser,,resp_parser.h,"struct ReplyParser {
    /* The current location in the reply buffer, needs to be set to the beginning of the reply */
    const char *curr_location;
    ReplyParserCallbacks callbacks;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7604,336165,_rio,4,_rio,,rio.h,"struct _rio {
    /* Backend functions.
     * Since this functions do not tolerate short writes or reads the return
     * value is simplified to: zero on error, non zero on complete success. */
    size_t (*read)(struct _rio *, void *buf, size_t len);
    size_t (*write)(struct _rio *, const void *buf, size_t len);
    off_t (*tell)(struct _rio *);
    int (*flush)(struct _rio *);
    /* The update_cksum method if not NULL is used to compute the checksum of
     * all the data that was read or written so far. The method should be
     * designed so that can be called with the current checksum, and the buf
     * and len fields pointing to the new block of data to add to the checksum
     * computation. */
    void (*update_cksum)(struct _rio *, const void *buf, size_t len);

    /* The current checksum and flags (see RIO_FLAG_*) */
    uint64_t cksum, flags;

    /* number of bytes read or written */
    size_t processed_bytes;

    /* maximum single read or write chunk size */
  ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7605,336201,_rio.io,4,_rio.io,,rio.h,"union {
        /* In-memory buffer target. */
        struct {
            sds ptr;
            off_t pos;
        } buffer;
        /* Stdio file pointer target. */
        struct {
            FILE *fp;
            off_t buffered; /* Bytes written since last fsync. */
            off_t autosync; /* fsync after 'autosync' bytes written. */
            unsigned reclaim_cache:1; /* A flag to indicate reclaim cache after fsync */
        } file;
        /* Connection object (used to read from socket) */
        struct {
            connection *conn;   /* Connection */
            off_t pos;    /* pos in buf that was returned */
            sds buf;      /* buffered data */
            size_t read_limit;  /* don't allow to buffer/read more than that */
            size_t read_so_far; /* amount of data read from the rio (not buffered) */
        } conn;
        /* FD target (used to write to pipe). */
        struct {
            int fd;       /* File descriptor. */
            off_t p...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7606,336202,_rio.io.buffer,4,_rio.io.buffer,,rio.h,"struct {
            sds ptr;
            off_t pos;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7607,336206,_rio.io.file,4,_rio.io.file,,rio.h,"struct {
            FILE *fp;
            off_t buffered; /* Bytes written since last fsync. */
            off_t autosync; /* fsync after 'autosync' bytes written. */
            unsigned reclaim_cache:1; /* A flag to indicate reclaim cache after fsync */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7608,336212,_rio.io.conn,4,_rio.io.conn,,rio.h,"struct {
            connection *conn;   /* Connection */
            off_t pos;    /* pos in buf that was returned */
            sds buf;      /* buffered data */
            size_t read_limit;  /* don't allow to buffer/read more than that */
            size_t read_so_far; /* amount of data read from the rio (not buffered) */
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7609,336219,_rio.io.fd,4,_rio.io.fd,,rio.h,"struct {
            int fd;       /* File descriptor. */
            off_t pos;
            sds buf;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7610,336225,_rio,4,_rio,,rio.h,typedef struct _rio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7611,336226,rio,4,rio,,rio.h,typedef struct _rio rio;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7612,336548,redisObject,4,redisObject,,rio.h,struct redisObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7613,338603,scriptRunCtx,4,scriptRunCtx,,script.h,typedef struct scriptRunCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7614,338604,scriptRunCtx,4,scriptRunCtx,,script.h,typedef struct scriptRunCtx scriptRunCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7615,338605,scriptRunCtx,4,scriptRunCtx,,script.h,"struct scriptRunCtx {
    const char *funcname;
    client *c;
    client *original_client;
    int flags;
    int repl_flags;
    monotime start_time;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7616,338612,scriptFlag,4,scriptFlag,,script.h,"typedef struct scriptFlag {
    uint64_t flag;
    const char *str;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7617,338615,scriptFlag,4,scriptFlag,,script.h,"typedef struct scriptFlag {
    uint64_t flag;
    const char *str;
} scriptFlag;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7618,343371,errorInfo,4,errorInfo,,script_lua.h,"typedef struct errorInfo {
    sds msg;
    sds source;
    sds line;
    int ignore_err_stats_update;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7619,343376,errorInfo,4,errorInfo,,script_lua.h,"typedef struct errorInfo {
    sds msg;
    sds source;
    sds line;
    int ignore_err_stats_update;
}errorInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7620,346966,sds,4,sds,,sds.h,typedef char *sds;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7621,346967,sdshdr5,4,sdshdr5,,sds.h,"struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7622,346975,sdshdr8,4,sdshdr8,,sds.h,"struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7623,346985,sdshdr16,4,sdshdr16,,sds.h,"struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7624,346995,sdshdr32,4,sdshdr32,,sds.h,"struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7625,347005,sdshdr64,4,sdshdr64,,sds.h,"struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7626,347978,sentinelAddr,4,sentinelAddr,,sentinel.c,"typedef struct sentinelAddr {
    char *hostname;         /* Hostname OR address, as specified */
    char *ip;               /* Always a resolved address */
    int port;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7627,347982,sentinelAddr,4,sentinelAddr,,sentinel.c,"typedef struct sentinelAddr {
    char *hostname;         /* Hostname OR address, as specified */
    char *ip;               /* Always a resolved address */
    int port;
} sentinelAddr;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7628,348045,instanceLink,4,instanceLink,,sentinel.c,"typedef struct instanceLink {
    int refcount;          /* Number of sentinelRedisInstance owners. */
    int disconnected;      /* Non-zero if we need to reconnect cc or pc. */
    int pending_commands;  /* Number of commands sent waiting for a reply. */
    redisAsyncContext *cc; /* Hiredis context for commands. */
    redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */
    mstime_t cc_conn_time; /* cc connection time. */
    mstime_t pc_conn_time; /* pc connection time. */
    mstime_t pc_last_activity; /* Last time we received any message. */
    mstime_t last_avail_time; /* Last time the instance replied to ping with
                                 a reply we consider valid. */
    mstime_t act_ping_time;   /* Time at which the last pending ping (no pong
                                 received after it) was sent. This field is
                                 set to 0 when a pong is received, and set again
                                 to the current time if the ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7629,348059,instanceLink,4,instanceLink,,sentinel.c,"typedef struct instanceLink {
    int refcount;          /* Number of sentinelRedisInstance owners. */
    int disconnected;      /* Non-zero if we need to reconnect cc or pc. */
    int pending_commands;  /* Number of commands sent waiting for a reply. */
    redisAsyncContext *cc; /* Hiredis context for commands. */
    redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */
    mstime_t cc_conn_time; /* cc connection time. */
    mstime_t pc_conn_time; /* pc connection time. */
    mstime_t pc_last_activity; /* Last time we received any message. */
    mstime_t last_avail_time; /* Last time the instance replied to ping with
                                 a reply we consider valid. */
    mstime_t act_ping_time;   /* Time at which the last pending ping (no pong
                                 received after it) was sent. This field is
                                 set to 0 when a pong is received, and set again
                                 to the current time if the ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7630,348060,sentinelRedisInstance,4,sentinelRedisInstance,,sentinel.c,"typedef struct sentinelRedisInstance {
    int flags;      /* See SRI_... defines */
    char *name;     /* Master name from the point of view of this sentinel. */
    char *runid;    /* Run ID of this instance, or unique ID if is a Sentinel.*/
    uint64_t config_epoch;  /* Configuration epoch. */
    sentinelAddr *addr; /* Master host. */
    instanceLink *link; /* Link to the instance, may be shared for Sentinels. */
    mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */
    mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time
                                 we received a hello from this Sentinel
                                 via Pub/Sub. */
    mstime_t last_master_down_reply_time; /* Time of last reply to
                                             SENTINEL is-master-down command. */
    mstime_t s_down_since_time; /* Subjectively down since time. */
    mstime_t o_down_since_time; /* Objectively down since time. */
    mstime_t down_a...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7631,348090,sentinelRedisInstance,4,sentinelRedisInstance.sentinelRedisInstance,,sentinel.c,struct sentinelRedisInstance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7632,348104,sentinelRedisInstance,4,sentinelRedisInstance.sentinelRedisInstance,,sentinel.c,struct sentinelRedisInstance,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7633,348109,sentinelRedisInstance,4,sentinelRedisInstance,,sentinel.c,"typedef struct sentinelRedisInstance {
    int flags;      /* See SRI_... defines */
    char *name;     /* Master name from the point of view of this sentinel. */
    char *runid;    /* Run ID of this instance, or unique ID if is a Sentinel.*/
    uint64_t config_epoch;  /* Configuration epoch. */
    sentinelAddr *addr; /* Master host. */
    instanceLink *link; /* Link to the instance, may be shared for Sentinels. */
    mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */
    mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time
                                 we received a hello from this Sentinel
                                 via Pub/Sub. */
    mstime_t last_master_down_reply_time; /* Time of last reply to
                                             SENTINEL is-master-down command. */
    mstime_t s_down_since_time; /* Subjectively down since time. */
    mstime_t o_down_since_time; /* Objectively down since time. */
    mstime_t down_a...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7634,348110,sentinelState,4,sentinelState,,sentinel.c,"struct sentinelState {
    char myid[CONFIG_RUN_ID_SIZE+1]; /* This sentinel ID. */
    uint64_t current_epoch;         /* Current epoch. */
    dict *masters;      /* Dictionary of master sentinelRedisInstances.
                           Key is the instance name, value is the
                           sentinelRedisInstance structure pointer. */
    int tilt;           /* Are we in TILT mode? */
    int running_scripts;    /* Number of scripts in execution right now. */
    mstime_t tilt_start_time;       /* When TITL started. */
    mstime_t previous_time;         /* Last time we ran the time handler. */
    list *scripts_queue;            /* Queue of user scripts to execute. */
    char *announce_ip;  /* IP addr that is gossiped to other sentinels if
                           not NULL. */
    int announce_port;  /* Port that is gossiped to other sentinels if
                           non zero. */
    unsigned long simfailure_flags; /* Failures simulation. */
    int deny_scrip...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7635,348138,sentinelScriptJob,4,sentinelScriptJob,,sentinel.c,"typedef struct sentinelScriptJob {
    int flags;              /* Script job flags: SENTINEL_SCRIPT_* */
    int retry_num;          /* Number of times we tried to execute it. */
    char **argv;            /* Arguments to call the script. */
    mstime_t start_time;    /* Script execution time if the script is running,
                               otherwise 0 if we are allowed to retry the
                               execution at any time. If the script is not
                               running and it's not 0, it means: do not run
                               before the specified time. */
    pid_t pid;              /* Script execution pid. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7636,348144,sentinelScriptJob,4,sentinelScriptJob,,sentinel.c,"typedef struct sentinelScriptJob {
    int flags;              /* Script job flags: SENTINEL_SCRIPT_* */
    int retry_num;          /* Number of times we tried to execute it. */
    char **argv;            /* Arguments to call the script. */
    mstime_t start_time;    /* Script execution time if the script is running,
                               otherwise 0 if we are allowed to retry the
                               execution at any time. If the script is not
                               running and it's not 0, it means: do not run
                               before the specified time. */
    pid_t pid;              /* Script execution pid. */
} sentinelScriptJob;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7637,348145,redisAeEvents,4,redisAeEvents,,sentinel.c,"typedef struct redisAeEvents {
    redisAsyncContext *context;
    aeEventLoop *loop;
    int fd;
    int reading, writing;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7638,348151,redisAeEvents,4,redisAeEvents,,sentinel.c,"typedef struct redisAeEvents {
    redisAsyncContext *context;
    aeEventLoop *loop;
    int fd;
    int reading, writing;
} redisAeEvents;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7639,364401,sentinelLeader,4,sentinelLeader,,sentinel.c,"struct sentinelLeader {
    char *runid;
    unsigned long votes;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7640,366670,sharedObjectsStruct,4,sharedObjectsStruct,,server.c,struct sharedObjectsStruct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7641,366676,redisServer,4,redisServer,,server.c,struct redisServer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7642,376673,redisCommand,4,redisCommand,,server.c,extern struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7643,382004,replyFlagNames,4,replyFlagNames,,server.c,"typedef struct replyFlagNames {
    uint64_t flag;
    const char *name;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7644,382007,replyFlagNames,4,replyFlagNames,,server.c,"typedef struct replyFlagNames {
    uint64_t flag;
    const char *name;
} replyFlagNames;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7645,383917,commandListFilterType,4,commandListFilterType,,server.c,"typedef enum {
    COMMAND_LIST_FILTER_MODULE,
    COMMAND_LIST_FILTER_ACLCAT,
    COMMAND_LIST_FILTER_PATTERN,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7646,383922,commandListFilter,4,commandListFilter,,server.c,"typedef struct {
    commandListFilterType type;
    sds arg;
    struct {
        int valid;
        union {
            uint64_t aclcat;
            void *module_handle;
        } u;
    } cache;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7647,383925,commandListFilter.cache,4,commandListFilter.cache,,server.c,"struct {
        int valid;
        union {
            uint64_t aclcat;
            void *module_handle;
        } u;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7648,383927,commandListFilter.cache.u,4,commandListFilter.cache.u,,server.c,"union {
            uint64_t aclcat;
            void *module_handle;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7649,390924,mstime_t,4,mstime_t,,server.h,typedef long long mstime_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7650,390925,ustime_t,4,ustime_t,,server.h,typedef long long ustime_t;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7651,390926,redisObject,4,redisObject,,server.h,typedef struct redisObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7652,390927,robj,4,robj,,server.h,typedef struct redisObject robj;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7653,390928,hdr_histogram,4,hdr_histogram,,server.h,struct hdr_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7654,390934,blocking_type,4,blocking_type,,server.h,"typedef enum blocking_type {
    BLOCKED_NONE,    /* Not blocked, no CLIENT_BLOCKED flag set. */
    BLOCKED_LIST,    /* BLPOP & co. */
    BLOCKED_WAIT,    /* WAIT for synchronous replication. */
    BLOCKED_WAITAOF, /* WAITAOF for AOF file fsync. */
    BLOCKED_MODULE,  /* Blocked by a loadable module. */
    BLOCKED_STREAM,  /* XREAD. */
    BLOCKED_ZSET,    /* BZPOP et al. */
    BLOCKED_POSTPONE, /* Blocked by processCommand, re-try processing later. */
    BLOCKED_SHUTDOWN, /* SHUTDOWN. */
    BLOCKED_NUM,      /* Number of blocked states. */
    BLOCKED_END       /* End of enumeration */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7655,390946,blocking_type,4,blocking_type,,server.h,"typedef enum blocking_type {
    BLOCKED_NONE,    /* Not blocked, no CLIENT_BLOCKED flag set. */
    BLOCKED_LIST,    /* BLPOP & co. */
    BLOCKED_WAIT,    /* WAIT for synchronous replication. */
    BLOCKED_WAITAOF, /* WAITAOF for AOF file fsync. */
    BLOCKED_MODULE,  /* Blocked by a loadable module. */
    BLOCKED_STREAM,  /* XREAD. */
    BLOCKED_ZSET,    /* BZPOP et al. */
    BLOCKED_POSTPONE, /* Blocked by processCommand, re-try processing later. */
    BLOCKED_SHUTDOWN, /* SHUTDOWN. */
    BLOCKED_NUM,      /* Number of blocked states. */
    BLOCKED_END       /* End of enumeration */
} blocking_type;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7656,390947,repl_state,4,repl_state,,server.h,"typedef enum {
    REPL_STATE_NONE = 0,            /* No active replication */
    REPL_STATE_CONNECT,             /* Must connect to master */
    REPL_STATE_CONNECTING,          /* Connecting to master */
    /* --- Handshake states, must be ordered --- */
    REPL_STATE_RECEIVE_PING_REPLY,  /* Wait for PING reply */
    REPL_STATE_SEND_HANDSHAKE,      /* Send handshake sequence to master */
    REPL_STATE_RECEIVE_AUTH_REPLY,  /* Wait for AUTH reply */
    REPL_STATE_RECEIVE_PORT_REPLY,  /* Wait for REPLCONF reply */
    REPL_STATE_RECEIVE_IP_REPLY,    /* Wait for REPLCONF reply */
    REPL_STATE_RECEIVE_CAPA_REPLY,  /* Wait for REPLCONF reply */
    REPL_STATE_SEND_PSYNC,          /* Send PSYNC */
    REPL_STATE_RECEIVE_PSYNC_REPLY, /* Wait for PSYNC reply */
    /* --- End of handshake states --- */
    REPL_STATE_TRANSFER,        /* Receiving .rdb from master */
    REPL_STATE_CONNECTED,       /* Connected to master */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7657,390969,failover_state,4,failover_state,,server.h,"typedef enum {
    NO_FAILOVER = 0,        /* No failover in progress */
    FAILOVER_WAIT_FOR_SYNC, /* Waiting for target replica to catch up */
    FAILOVER_IN_PROGRESS    /* Waiting for target replica to accept
                             * PSYNC FAILOVER request. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7658,390981,pause_purpose,4,pause_purpose,,server.h,"typedef enum {
    PAUSE_BY_CLIENT_COMMAND = 0,
    PAUSE_DURING_SHUTDOWN,
    PAUSE_DURING_FAILOVER,
    NUM_PAUSE_PURPOSES /* This value is the number of purposes above. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7659,390994,pause_event,4,pause_event,,server.h,"typedef struct {
    uint32_t paused_actions; /* Bitmask of actions */
    mstime_t end;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7660,390998,cluster_endpoint_type,4,cluster_endpoint_type,,server.h,"typedef enum {
    CLUSTER_ENDPOINT_TYPE_IP = 0,          /* Show IP address */
    CLUSTER_ENDPOINT_TYPE_HOSTNAME,        /* Show hostname */
    CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT /* Show NULL or empty */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7661,391010,RedisModule,4,RedisModule,,server.h,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7662,391011,RedisModuleIO,4,RedisModuleIO,,server.h,struct RedisModuleIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7663,391012,RedisModuleDigest,4,RedisModuleDigest,,server.h,struct RedisModuleDigest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7664,391013,RedisModuleCtx,4,RedisModuleCtx,,server.h,struct RedisModuleCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7665,391014,moduleLoadQueueEntry,4,moduleLoadQueueEntry,,server.h,struct moduleLoadQueueEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7666,391015,RedisModuleKeyOptCtx,4,RedisModuleKeyOptCtx,,server.h,struct RedisModuleKeyOptCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7667,391016,RedisModuleCommand,4,RedisModuleCommand,,server.h,struct RedisModuleCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7668,391130,RedisModuleType,4,RedisModuleType,,server.h,"typedef struct RedisModuleType {
    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
    struct RedisModule *module;
    moduleTypeLoadFunc rdb_load;
    moduleTypeSaveFunc rdb_save;
    moduleTypeRewriteFunc aof_rewrite;
    moduleTypeMemUsageFunc mem_usage;
    moduleTypeDigestFunc digest;
    moduleTypeFreeFunc free;
    moduleTypeFreeEffortFunc free_effort;
    moduleTypeUnlinkFunc unlink;
    moduleTypeCopyFunc copy;
    moduleTypeDefragFunc defrag;
    moduleTypeAuxLoadFunc aux_load;
    moduleTypeAuxSaveFunc aux_save;
    moduleTypeMemUsageFunc2 mem_usage2;
    moduleTypeFreeEffortFunc2 free_effort2;
    moduleTypeUnlinkFunc2 unlink2;
    moduleTypeCopyFunc2 copy2;
    moduleTypeAuxSaveFunc aux_save2;
    int aux_save_triggers;
    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7669,391132,RedisModule,4,RedisModuleType.RedisModule,,server.h,struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7670,391159,moduleType,4,moduleType,,server.h,"typedef struct RedisModuleType {
    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
    struct RedisModule *module;
    moduleTypeLoadFunc rdb_load;
    moduleTypeSaveFunc rdb_save;
    moduleTypeRewriteFunc aof_rewrite;
    moduleTypeMemUsageFunc mem_usage;
    moduleTypeDigestFunc digest;
    moduleTypeFreeFunc free;
    moduleTypeFreeEffortFunc free_effort;
    moduleTypeUnlinkFunc unlink;
    moduleTypeCopyFunc copy;
    moduleTypeDefragFunc defrag;
    moduleTypeAuxLoadFunc aux_load;
    moduleTypeAuxSaveFunc aux_save;
    moduleTypeMemUsageFunc2 mem_usage2;
    moduleTypeFreeEffortFunc2 free_effort2;
    moduleTypeUnlinkFunc2 unlink2;
    moduleTypeCopyFunc2 copy2;
    moduleTypeAuxSaveFunc aux_save2;
    int aux_save_triggers;
    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
} moduleType;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7671,391160,moduleValue,4,moduleValue,,server.h,"typedef struct moduleValue {
    moduleType *type;
    void *value;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7672,391163,moduleValue,4,moduleValue,,server.h,"typedef struct moduleValue {
    moduleType *type;
    void *value;
} moduleValue;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7673,391164,RedisModule,4,RedisModule,,server.h,"struct RedisModule {
    void *handle;   /* Module dlopen() handle. */
    char *name;     /* Module name. */
    int ver;        /* Module version. We use just progressive integers. */
    int apiver;     /* Module API version as requested during initialization.*/
    list *types;    /* Module data types. */
    list *usedby;   /* List of modules using APIs from this one. */
    list *using;    /* List of modules we use some APIs of. */
    list *filters;  /* List of filters the module has registered. */
    list *module_configs; /* List of configurations the module has registered */
    int configs_initialized; /* Have the module configurations been initialized? */
    int in_call;    /* RM_Call() nesting level */
    int in_hook;    /* Hooks callback nesting level for this module (0 or 1). */
    int options;    /* Module options and capabilities. */
    int blocked_clients;         /* Count of RedisModuleBlockedClient in this module. */
    RedisModuleInfoFunc info_cb; /* Callba...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7674,391181,moduleLoadQueueEntry,4,RedisModule.moduleLoadQueueEntry,,server.h,struct moduleLoadQueueEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7675,391185,RedisModule,4,RedisModule,,server.h,typedef struct RedisModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7676,391186,RedisModule,4,RedisModule,,server.h,typedef struct RedisModule RedisModule;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7677,391187,RedisModuleIO,4,RedisModuleIO,,server.h,"struct RedisModuleIO {
    size_t bytes;       /* Bytes read / written so far. */
    rio *rio;           /* Rio stream. */
    moduleType *type;   /* Module type doing the operation. */
    int error;          /* True if error condition happened. */
    struct RedisModuleCtx *ctx; /* Optional context, see RM_GetContextFromIO()*/
    struct redisObject *key;    /* Optional name of key processed */
    int dbid;            /* The dbid of the key being processed, -1 when unknown. */
    sds pre_flush_buffer; /* A buffer that should be flushed before next write operation
                           * See rdbSaveSingleModuleAux for more details */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7678,391192,RedisModuleCtx,4,RedisModuleIO.RedisModuleCtx,,server.h,struct RedisModuleCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7679,391194,redisObject,4,RedisModuleIO.redisObject,,server.h,struct redisObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7680,391198,RedisModuleDigest,4,RedisModuleDigest,,server.h,"struct RedisModuleDigest {
    unsigned char o[20];    /* Ordered elements. */
    unsigned char x[20];    /* Xored elements. */
    struct redisObject *key; /* Optional name of key processed */
    int dbid;                /* The dbid of the key being processed */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7681,391201,redisObject,4,RedisModuleDigest.redisObject,,server.h,struct redisObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7682,391212,redisObject,4,redisObject,,server.h,"struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7683,391223,evictionPoolEntry,4,evictionPoolEntry,,server.h,struct evictionPoolEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7684,391224,clientReplyBlock,4,clientReplyBlock,,server.h,"typedef struct clientReplyBlock {
    size_t size, used;
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7685,391233,clientReplyBlock,4,clientReplyBlock,,server.h,"typedef struct clientReplyBlock {
    size_t size, used;
    char buf[];
} clientReplyBlock;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7686,391234,replBufBlock,4,replBufBlock,,server.h,"typedef struct replBufBlock {
    int refcount;           /* Number of replicas or repl backlog using. */
    long long id;           /* The unique incremental number. */
    long long repl_offset;  /* Start replication offset of the block. */
    size_t size, used;
    char buf[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7687,391246,replBufBlock,4,replBufBlock,,server.h,"typedef struct replBufBlock {
    int refcount;           /* Number of replicas or repl backlog using. */
    long long id;           /* The unique incremental number. */
    long long repl_offset;  /* Start replication offset of the block. */
    size_t size, used;
    char buf[];
} replBufBlock;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7688,391247,clusterSlotToKeyMapping,4,clusterSlotToKeyMapping,,server.h,typedef struct clusterSlotToKeyMapping,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7689,391248,clusterSlotToKeyMapping,4,clusterSlotToKeyMapping,,server.h,typedef struct clusterSlotToKeyMapping clusterSlotToKeyMapping;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7690,391249,redisDb,4,redisDb,,server.h,"typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *blocking_keys_unblock_on_nokey;   /* Keys with clients waiting for
                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).
                                             * This is a subset of blocking_keys*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
    clusterSlotToKeyMapping *slots_to_keys; /* Array...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7691,391261,redisDb,4,redisDb,,server.h,"typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *blocking_keys_unblock_on_nokey;   /* Keys with clients waiting for
                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).
                                             * This is a subset of blocking_keys*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
    clusterSlotToKeyMapping *slots_to_keys; /* Array...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7692,391262,functionsLibCtx,4,functionsLibCtx,,server.h,typedef struct functionsLibCtx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7693,391263,functionsLibCtx,4,functionsLibCtx,,server.h,typedef struct functionsLibCtx functionsLibCtx;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7694,391264,rdbLoadingCtx,4,rdbLoadingCtx,,server.h,"typedef struct rdbLoadingCtx {
    redisDb* dbarray;
    functionsLibCtx* functions_lib_ctx;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7695,391267,rdbLoadingCtx,4,rdbLoadingCtx,,server.h,"typedef struct rdbLoadingCtx {
    redisDb* dbarray;
    functionsLibCtx* functions_lib_ctx;
}rdbLoadingCtx;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7696,391268,multiCmd,4,multiCmd,,server.h,"typedef struct multiCmd {
    robj **argv;
    int argv_len;
    int argc;
    struct redisCommand *cmd;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7697,391272,redisCommand,4,multiCmd.redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7698,391274,multiCmd,4,multiCmd,,server.h,"typedef struct multiCmd {
    robj **argv;
    int argv_len;
    int argc;
    struct redisCommand *cmd;
} multiCmd;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7699,391275,multiState,4,multiState,,server.h,"typedef struct multiState {
    multiCmd *commands;     /* Array of MULTI commands */
    int count;              /* Total number of MULTI commands */
    int cmd_flags;          /* The accumulated command flags OR-ed together.
                               So if at least a command has a given flag, it
                               will be set in this field. */
    int cmd_inv_flags;      /* Same as cmd_flags, OR-ing the ~flags. so that it
                               is possible to know if all the commands have a
                               certain flag. */
    size_t argv_len_sums;    /* mem used by all commands arguments */
    int alloc_count;         /* total number of multiCmd struct memory reserved. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7700,391282,multiState,4,multiState,,server.h,"typedef struct multiState {
    multiCmd *commands;     /* Array of MULTI commands */
    int count;              /* Total number of MULTI commands */
    int cmd_flags;          /* The accumulated command flags OR-ed together.
                               So if at least a command has a given flag, it
                               will be set in this field. */
    int cmd_inv_flags;      /* Same as cmd_flags, OR-ing the ~flags. so that it
                               is possible to know if all the commands have a
                               certain flag. */
    size_t argv_len_sums;    /* mem used by all commands arguments */
    int alloc_count;         /* total number of multiCmd struct memory reserved. */
} multiState;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7701,391283,blockingState,4,blockingState,,server.h,"typedef struct blockingState {
    /* Generic fields. */
    blocking_type btype;                  /* Type of blocking op if CLIENT_BLOCKED. */
    mstime_t timeout;           /* Blocking operation timeout. If UNIX current time
                                 * is > timeout then the operation timed out. */
    int unblock_on_nokey;       /* Whether to unblock the client when at least one of the keys
                                   is deleted or does not exist anymore */
    /* BLOCKED_LIST, BLOCKED_ZSET and BLOCKED_STREAM or any other Keys related blocking */
    dict *keys;                 /* The keys we are blocked on */

    /* BLOCKED_WAIT and BLOCKED_WAITAOF */
    int numreplicas;        /* Number of replicas we are waiting for ACK. */
    int numlocal;           /* Indication if WAITAOF is waiting for local fsync. */
    long long reploffset;   /* Replication offset to reach. */

    /* BLOCKED_MODULE */
    void *module_blocked_handle; /* RedisModuleBlockedClient structu...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7702,391293,blockingState,4,blockingState,,server.h,"typedef struct blockingState {
    /* Generic fields. */
    blocking_type btype;                  /* Type of blocking op if CLIENT_BLOCKED. */
    mstime_t timeout;           /* Blocking operation timeout. If UNIX current time
                                 * is > timeout then the operation timed out. */
    int unblock_on_nokey;       /* Whether to unblock the client when at least one of the keys
                                   is deleted or does not exist anymore */
    /* BLOCKED_LIST, BLOCKED_ZSET and BLOCKED_STREAM or any other Keys related blocking */
    dict *keys;                 /* The keys we are blocked on */

    /* BLOCKED_WAIT and BLOCKED_WAITAOF */
    int numreplicas;        /* Number of replicas we are waiting for ACK. */
    int numlocal;           /* Indication if WAITAOF is waiting for local fsync. */
    long long reploffset;   /* Replication offset to reach. */

    /* BLOCKED_MODULE */
    void *module_blocked_handle; /* RedisModuleBlockedClient structu...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7703,391294,readyList,4,readyList,,server.h,"typedef struct readyList {
    redisDb *db;
    robj *key;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7704,391297,readyList,4,readyList,,server.h,"typedef struct readyList {
    redisDb *db;
    robj *key;
} readyList;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7705,391298,user,4,user,,server.h,"typedef struct {
    sds name;       /* The username as an SDS string. */
    uint32_t flags; /* See USER_FLAG_* */
    list *passwords; /* A list of SDS valid passwords for this user. */
    list *selectors; /* A list of selectors this user validates commands
                        against. This list will always contain at least
                        one selector for backwards compatibility. */
    robj *acl_string; /* cached string represent of ACLs */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7706,391305,replBacklog,4,replBacklog,,server.h,"typedef struct replBacklog {
    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,
                                  * see the definition of replBufBlock. */
    size_t unindexed_count;      /* The count from last creating index block. */
    rax *blocks_index;           /* The index of recorded blocks of replication
                                  * buffer for quickly searching replication
                                  * offset on partial resynchronization. */
    long long histlen;           /* Backlog actual data length */
    long long offset;            /* Replication ""master offset"" of first
                                  * byte in the replication backlog buffer.*/
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7707,391311,replBacklog,4,replBacklog,,server.h,"typedef struct replBacklog {
    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,
                                  * see the definition of replBufBlock. */
    size_t unindexed_count;      /* The count from last creating index block. */
    rax *blocks_index;           /* The index of recorded blocks of replication
                                  * buffer for quickly searching replication
                                  * offset on partial resynchronization. */
    long long histlen;           /* Backlog actual data length */
    long long offset;            /* Replication ""master offset"" of first
                                  * byte in the replication backlog buffer.*/
} replBacklog;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7708,391312,clientMemUsageBucket,4,clientMemUsageBucket,,server.h,"typedef struct {
    list *clients;
    size_t mem_usage_sum;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7709,391316,client,4,client,,server.h,"typedef struct client {
    uint64_t id;            /* Client incremental unique ID. */
    uint64_t flags;         /* Client flags: CLIENT_* macros. */
    connection *conn;
    int resp;               /* RESP protocol version. Can be 2 or 3. */
    redisDb *db;            /* Pointer to currently SELECTed DB. */
    robj *name;             /* As set by CLIENT SETNAME. */
    robj *lib_name;         /* The client library name as set by CLIENT SETINFO. */
    robj *lib_ver;          /* The client library version as set by CLIENT SETINFO. */
    sds querybuf;           /* Buffer we use to accumulate client queries. */
    size_t qb_pos;          /* The position we have read in querybuf. */
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
    int argc;               /* Num of arguments of current command. */
    robj **argv;            /* Arguments of current command. */
    int argv_len;           /* Size of argv array (may be more than argc) */
    int ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7710,391334,redisCommand,4,client.redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7711,391337,redisCommand,4,client.redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7712,391415,client,4,client,,server.h,"typedef struct client {
    uint64_t id;            /* Client incremental unique ID. */
    uint64_t flags;         /* Client flags: CLIENT_* macros. */
    connection *conn;
    int resp;               /* RESP protocol version. Can be 2 or 3. */
    redisDb *db;            /* Pointer to currently SELECTed DB. */
    robj *name;             /* As set by CLIENT SETNAME. */
    robj *lib_name;         /* The client library name as set by CLIENT SETINFO. */
    robj *lib_ver;          /* The client library version as set by CLIENT SETINFO. */
    sds querybuf;           /* Buffer we use to accumulate client queries. */
    size_t qb_pos;          /* The position we have read in querybuf. */
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
    int argc;               /* Num of arguments of current command. */
    robj **argv;            /* Arguments of current command. */
    int argv_len;           /* Size of argv array (may be more than argc) */
    int ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7713,391416,aclInfo,4,aclInfo,,server.h,"typedef struct aclInfo {
    long long user_auth_failures; /* Auth failure counts on user level */
    long long invalid_cmd_accesses; /* Invalid command accesses that user doesn't have permission to */
    long long invalid_key_accesses; /* Invalid key accesses that user doesn't have permission to */
    long long invalid_channel_accesses; /* Invalid channel accesses that user doesn't have permission to */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7714,391421,aclInfo,4,aclInfo,,server.h,"typedef struct aclInfo {
    long long user_auth_failures; /* Auth failure counts on user level */
    long long invalid_cmd_accesses; /* Invalid command accesses that user doesn't have permission to */
    long long invalid_key_accesses; /* Invalid key accesses that user doesn't have permission to */
    long long invalid_channel_accesses; /* Invalid channel accesses that user doesn't have permission to */
} aclInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7715,391422,saveparam,4,saveparam,,server.h,"struct saveparam {
    time_t seconds;
    int changes;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7716,391425,moduleLoadQueueEntry,4,moduleLoadQueueEntry,,server.h,"struct moduleLoadQueueEntry {
    sds path;
    int argc;
    robj **argv;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7717,391429,sentinelLoadQueueEntry,4,sentinelLoadQueueEntry,,server.h,"struct sentinelLoadQueueEntry {
    int argc;
    sds *argv;
    int linenum;
    sds line;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7718,391434,sentinelConfig,4,sentinelConfig,,server.h,"struct sentinelConfig {
    list *pre_monitor_cfg;
    list *monitor_cfg;
    list *post_monitor_cfg;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7719,391438,sharedObjectsStruct,4,sharedObjectsStruct,,server.h,"struct sharedObjectsStruct {
    robj *ok, *err, *emptybulk, *czero, *cone, *pong, *space,
    *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],
    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
    *outofrangeerr, *noscripterr, *loadingerr,
    *slowevalerr, *slowscripterr, *slowmoduleerr, *bgsaveerr,
    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,
    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,
    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,
    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,
    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  
    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, 
    *time, *pxat, *absttl, *retrycount, *force, *justid, *entriesread,
    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,
    *getack, *special_asterick, *special_equals, *default_username, *redact...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7720,391568,zskiplistNode,4,zskiplistNode,,server.h,"typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7721,391571,zskiplistNode,4,zskiplistNode.zskiplistNode,,server.h,struct zskiplistNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7722,391573,zskiplistLevel,4,zskiplistNode.zskiplistLevel,,server.h,"struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7723,391574,zskiplistNode,4,zskiplistNode.zskiplistLevel.zskiplistNode,,server.h,struct zskiplistNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7724,391583,zskiplistNode,4,zskiplistNode,,server.h,"typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7725,391584,zskiplist,4,zskiplist,,server.h,"typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7726,391585,zskiplistNode,4,zskiplist.zskiplistNode,,server.h,struct zskiplistNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7727,391590,zskiplist,4,zskiplist,,server.h,"typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7728,391591,zset,4,zset,,server.h,"typedef struct zset {
    dict *dict;
    zskiplist *zsl;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7729,391594,zset,4,zset,,server.h,"typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7730,391595,clientBufferLimitsConfig,4,clientBufferLimitsConfig,,server.h,"typedef struct clientBufferLimitsConfig {
    unsigned long long hard_limit_bytes;
    unsigned long long soft_limit_bytes;
    time_t soft_limit_seconds;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7731,391599,clientBufferLimitsConfig,4,clientBufferLimitsConfig,,server.h,"typedef struct clientBufferLimitsConfig {
    unsigned long long hard_limit_bytes;
    unsigned long long soft_limit_bytes;
    time_t soft_limit_seconds;
} clientBufferLimitsConfig;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7732,391605,redisOp,4,redisOp,,server.h,"typedef struct redisOp {
    robj **argv;
    int argc, dbid, target;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7733,391610,redisOp,4,redisOp,,server.h,"typedef struct redisOp {
    robj **argv;
    int argc, dbid, target;
} redisOp;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7734,391611,redisOpArray,4,redisOpArray,,server.h,"typedef struct redisOpArray {
    redisOp *ops;
    int numops;
    int capacity;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7735,391615,redisOpArray,4,redisOpArray,,server.h,"typedef struct redisOpArray {
    redisOp *ops;
    int numops;
    int capacity;
} redisOpArray;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7736,391616,redisMemOverhead,4,redisMemOverhead,,server.h,"struct redisMemOverhead {
    size_t peak_allocated;
    size_t total_allocated;
    size_t startup_allocated;
    size_t repl_backlog;
    size_t clients_slaves;
    size_t clients_normal;
    size_t cluster_links;
    size_t aof_buffer;
    size_t lua_caches;
    size_t functions_caches;
    size_t overhead_total;
    size_t dataset;
    size_t total_keys;
    size_t bytes_per_key;
    float dataset_perc;
    float peak_perc;
    float total_frag;
    ssize_t total_frag_bytes;
    float allocator_frag;
    ssize_t allocator_frag_bytes;
    float allocator_rss;
    ssize_t allocator_rss_bytes;
    float rss_extra;
    size_t rss_extra_bytes;
    size_t num_dbs;
    struct {
        size_t dbid;
        size_t overhead_ht_main;
        size_t overhead_ht_expires;
        size_t overhead_ht_slot_to_keys;
    } *db;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7737,391642,redisMemOverhead.db,4,redisMemOverhead.db,,server.h,"struct {
        size_t dbid;
        size_t overhead_ht_main;
        size_t overhead_ht_expires;
        size_t overhead_ht_slot_to_keys;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7738,391648,replicationErrorBehavior,4,replicationErrorBehavior,,server.h,"typedef enum {
    PROPAGATION_ERR_BEHAVIOR_IGNORE = 0,
    PROPAGATION_ERR_BEHAVIOR_PANIC,
    PROPAGATION_ERR_BEHAVIOR_PANIC_ON_REPLICAS
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7739,391660,rdbSaveInfo,4,rdbSaveInfo,,server.h,"typedef struct rdbSaveInfo {
    /* Used saving and loading. */
    int repl_stream_db;  /* DB to select in server.master client. */

    /* Used only loading. */
    int repl_id_is_set;  /* True if repl_id field is set. */
    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */
    long long repl_offset;                  /* Replication offset. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7740,391675,rdbSaveInfo,4,rdbSaveInfo,,server.h,"typedef struct rdbSaveInfo {
    /* Used saving and loading. */
    int repl_stream_db;  /* DB to select in server.master client. */

    /* Used only loading. */
    int repl_id_is_set;  /* True if repl_id field is set. */
    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */
    long long repl_offset;                  /* Replication offset. */
} rdbSaveInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7741,391676,malloc_stats,4,malloc_stats,,server.h,"struct malloc_stats {
    size_t zmalloc_used;
    size_t process_rss;
    size_t allocator_allocated;
    size_t allocator_active;
    size_t allocator_resident;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7742,391682,redisTLSContextConfig,4,redisTLSContextConfig,,server.h,"typedef struct redisTLSContextConfig {
    char *cert_file;                /* Server side and optionally client side cert file name */
    char *key_file;                 /* Private key filename for cert_file */
    char *key_file_pass;            /* Optional password for key_file */
    char *client_cert_file;         /* Certificate to use as a client; if none, use cert_file */
    char *client_key_file;          /* Private key filename for client_cert_file */
    char *client_key_file_pass;     /* Optional password for client_key_file */
    char *dh_params_file;
    char *ca_cert_file;
    char *ca_cert_dir;
    char *protocols;
    char *ciphers;
    char *ciphersuites;
    int prefer_server_ciphers;
    int session_caching;
    int session_cache_size;
    int session_cache_timeout;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7743,391699,redisTLSContextConfig,4,redisTLSContextConfig,,server.h,"typedef struct redisTLSContextConfig {
    char *cert_file;                /* Server side and optionally client side cert file name */
    char *key_file;                 /* Private key filename for cert_file */
    char *key_file_pass;            /* Optional password for key_file */
    char *client_cert_file;         /* Certificate to use as a client; if none, use cert_file */
    char *client_key_file;          /* Private key filename for client_cert_file */
    char *client_key_file_pass;     /* Optional password for client_key_file */
    char *dh_params_file;
    char *ca_cert_file;
    char *ca_cert_dir;
    char *protocols;
    char *ciphers;
    char *ciphersuites;
    int prefer_server_ciphers;
    int session_caching;
    int session_cache_size;
    int session_cache_timeout;
} redisTLSContextConfig;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7744,391700,aof_file_type,4,aof_file_type,,server.h,"typedef enum {
    AOF_FILE_TYPE_BASE  = 'b', /* BASE file */
    AOF_FILE_TYPE_HIST  = 'h', /* HISTORY file */
    AOF_FILE_TYPE_INCR  = 'i', /* INCR file */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7745,391718,aofInfo,4,aofInfo,,server.h,"typedef struct {
    sds           file_name;  /* file name */
    long long     file_seq;   /* file sequence */
    aof_file_type file_type;  /* file type */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7746,391723,aofManifest,4,aofManifest,,server.h,"typedef struct {
    aofInfo     *base_aof_info;       /* BASE file information. NULL if there is no BASE file. */
    list        *incr_aof_list;       /* INCR AOFs list. We may have multiple INCR AOF when rewrite fails. */
    list        *history_aof_list;    /* HISTORY AOF list. When the AOFRW success, The aofInfo contained in
                                         `base_aof_info` and `incr_aof_list` will be moved to this list. We
                                         will delete these AOF files when AOFRW finish. */
    long long   curr_base_file_seq;   /* The sequence number used by the current BASE file. */
    long long   curr_incr_file_seq;   /* The sequence number used by the current INCR file. */
    int         dirty;                /* 1 Indicates that the aofManifest in the memory is inconsistent with
                                         disk, we need to persist it immediately. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7747,391731,childInfoType,4,childInfoType,,server.h,"typedef enum childInfoType {
    CHILD_INFO_TYPE_CURRENT_INFO,
    CHILD_INFO_TYPE_AOF_COW_SIZE,
    CHILD_INFO_TYPE_RDB_COW_SIZE,
    CHILD_INFO_TYPE_MODULE_COW_SIZE
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7748,391736,childInfoType,4,childInfoType,,server.h,"typedef enum childInfoType {
    CHILD_INFO_TYPE_CURRENT_INFO,
    CHILD_INFO_TYPE_AOF_COW_SIZE,
    CHILD_INFO_TYPE_RDB_COW_SIZE,
    CHILD_INFO_TYPE_MODULE_COW_SIZE
} childInfoType;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7749,391737,redisServer,4,redisServer,,server.h,"struct redisServer {
    /* General */
    pid_t pid;                  /* Main process pid. */
    pthread_t main_thread_id;         /* Main thread id */
    char *configfile;           /* Absolute config file path, or NULL */
    char *executable;           /* Absolute executable file path. */
    char **exec_argv;           /* Executable argv vector (copy). */
    int dynamic_hz;             /* Change hz value depending on # of clients. */
    int config_hz;              /* Configured HZ value. May be different than
                                   the actual 'hz' field value if dynamic-hz
                                   is enabled. */
    mode_t umask;               /* The umask value of the process on startup */
    int hz;                     /* serverCron() calls frequency in hertz */
    int in_fork_child;          /* indication that this is a fork child */
    redisDb *db;
    dict *commands;             /* Command table */
    dict *orig_commands;        /* Command tab...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7750,391862,malloc_stats,4,redisServer.malloc_stats,,server.h,struct malloc_stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7751,391886,redisServer.inst_metric,4,redisServer.inst_metric,,server.h,"struct {
        long long last_sample_base;  /* The divisor of last sample window */
        long long last_sample_value; /* The dividend of last sample window */
        long long samples[STATS_METRIC_SAMPLES];
        int idx;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7752,391974,saveparam,4,redisServer.saveparam,,server.h,struct saveparam,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7753,392118,clusterState,4,redisServer.clusterState,,server.h,struct clusterState,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7754,392162,sentinelConfig,4,redisServer.sentinelConfig,,server.h,struct sentinelConfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7755,392239,keyReference,4,keyReference,,server.h,"typedef struct {
    int pos; /* The position of the key within the client array */
    int flags; /* The flags associated with the key access, see
                  CMD_KEY_* for more information */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7756,392243,getKeysResult,4,getKeysResult,,server.h,"typedef struct {
    keyReference keysbuf[MAX_KEYS_BUFFER];       /* Pre-allocated buffer, to save heap allocations */
    keyReference *keys;                          /* Key indices array, points to keysbuf or heap */
    int numkeys;                        /* Number of key indices return */
    int size;                           /* Available array size */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7757,392257,kspec_bs_type,4,kspec_bs_type,,server.h,"typedef enum {
    KSPEC_BS_INVALID = 0, /* Must be 0 */
    KSPEC_BS_UNKNOWN,
    KSPEC_BS_INDEX,
    KSPEC_BS_KEYWORD
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7758,392270,kspec_fk_type,4,kspec_fk_type,,server.h,"typedef enum {
    KSPEC_FK_INVALID = 0, /* Must be 0 */
    KSPEC_FK_UNKNOWN,
    KSPEC_FK_RANGE,
    KSPEC_FK_KEYNUM
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7759,392283,keySpec,4,keySpec,,server.h,"typedef struct {
    /* Declarative data */
    const char *notes;
    uint64_t flags;
    kspec_bs_type begin_search_type;
    union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    } bs;
    kspec_fk_type find_keys_type;
    union {
        /* NOTE: Indices in this struct are relative to the result of the begin_search step!
         * These are: range.lastkey, keynum.keynumidx, keynum.firstkey */
        struct {
            /* Index of the last key.
             * Can be negative, in which case it's not relative. ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7760,392287,keySpec.bs,4,keySpec.bs,,server.h,"union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7761,392288,keySpec.bs.index,4,keySpec.bs.index,,server.h,"struct {
            /* The index from which we start the search for keys */
            int pos;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7762,392291,keySpec.bs.keyword,4,keySpec.bs.keyword,,server.h,"struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7763,392297,keySpec.fk,4,keySpec.fk,,server.h,"union {
        /* NOTE: Indices in this struct are relative to the result of the begin_search step!
         * These are: range.lastkey, keynum.keynumidx, keynum.firstkey */
        struct {
            /* Index of the last key.
             * Can be negative, in which case it's not relative. -1 indicating till the last argument,
             * -2 one before the last and so on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0 and 1 mean no limit.
             * 2 means 1/2 of the remaining args, 3 means 1/3, and so on. */
            int limit;
        } range;
        struct {
            /* Index of the argument containing the number of keys to come */
            int keynumidx;
            /* Index of the fist key (Usually it's just after keynumidx, in
             * which case it should be set to k...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7764,392298,keySpec.fk.range,4,keySpec.fk.range,,server.h,"struct {
            /* Index of the last key.
             * Can be negative, in which case it's not relative. -1 indicating till the last argument,
             * -2 one before the last and so on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0 and 1 mean no limit.
             * 2 means 1/2 of the remaining args, 3 means 1/3, and so on. */
            int limit;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7765,392303,keySpec.fk.keynum,4,keySpec.fk.keynum,,server.h,"struct {
            /* Index of the argument containing the number of keys to come */
            int keynumidx;
            /* Index of the fist key (Usually it's just after keynumidx, in
             * which case it should be set to keynumidx+1). */
            int firstkey;
            /* How many args should we skip after finding a key, in order to find the next one. */
            int keystep;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7766,392310,commandHistory,4,commandHistory,,server.h,"typedef struct {
    const char *since;
    const char *changes;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7767,392314,redisCommandGroup,4,redisCommandGroup,,server.h,"typedef enum {
    COMMAND_GROUP_GENERIC,
    COMMAND_GROUP_STRING,
    COMMAND_GROUP_LIST,
    COMMAND_GROUP_SET,
    COMMAND_GROUP_SORTED_SET,
    COMMAND_GROUP_HASH,
    COMMAND_GROUP_PUBSUB,
    COMMAND_GROUP_TRANSACTIONS,
    COMMAND_GROUP_CONNECTION,
    COMMAND_GROUP_SERVER,
    COMMAND_GROUP_SCRIPTING,
    COMMAND_GROUP_HYPERLOGLOG,
    COMMAND_GROUP_CLUSTER,
    COMMAND_GROUP_SENTINEL,
    COMMAND_GROUP_GEO,
    COMMAND_GROUP_STREAM,
    COMMAND_GROUP_BITMAP,
    COMMAND_GROUP_MODULE,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7768,392347,redisCommand,4,redisCommand,,server.h,"struct redisCommand {
    /* Declarative data */
    const char *declared_name; /* A string representing the command declared_name.
                                * It is a const char * for native commands and SDS for module commands. */
    const char *summary; /* Summary of the command (optional). */
    const char *complexity; /* Complexity description (optional). */
    const char *since; /* Debut version of the command (optional). */
    int doc_flags; /* Flags for documentation (see CMD_DOC_*). */
    const char *replaced_by; /* In case the command is deprecated, this is the successor command. */
    const char *deprecated_since; /* In case the command is deprecated, when did it happen? */
    redisCommandGroup group; /* Command group */
    commandHistory *history; /* History of the command */
    int num_history;
    const char **tips; /* An array of strings that are meant to be tips for clients/proxies regarding this command */
    int num_tips;
    redisCommandProc *proc;...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7769,392368,redisCommand,4,redisCommand.redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7770,392370,redisCommandArg,4,redisCommand.redisCommandArg,,server.h,struct redisCommandArg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7771,392372,jsonObject,4,redisCommand.jsonObject,,server.h,struct jsonObject,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7772,392380,hdr_histogram,4,redisCommand.hdr_histogram,,server.h,struct hdr_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7773,392384,redisCommand,4,redisCommand.redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7774,392386,RedisModuleCommand,4,redisCommand.RedisModuleCommand,,server.h,struct RedisModuleCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7775,392388,redisError,4,redisError,,server.h,"struct redisError {
    long long count;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7776,392390,redisFunctionSym,4,redisFunctionSym,,server.h,"struct redisFunctionSym {
    char *name;
    unsigned long pointer;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7777,392393,_redisSortObject,4,_redisSortObject,,server.h,"typedef struct _redisSortObject {
    robj *obj;
    union {
        double score;
        robj *cmpobj;
    } u;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7778,392395,_redisSortObject.u,4,_redisSortObject.u,,server.h,"union {
        double score;
        robj *cmpobj;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7779,392399,redisSortObject,4,redisSortObject,,server.h,"typedef struct _redisSortObject {
    robj *obj;
    union {
        double score;
        robj *cmpobj;
    } u;
} redisSortObject;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7780,392400,_redisSortOperation,4,_redisSortOperation,,server.h,"typedef struct _redisSortOperation {
    int type;
    robj *pattern;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7781,392403,redisSortOperation,4,redisSortOperation,,server.h,"typedef struct _redisSortOperation {
    int type;
    robj *pattern;
} redisSortOperation;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7782,392404,listTypeIterator,4,listTypeIterator,,server.h,"typedef struct {
    robj *subject;
    unsigned char encoding;
    unsigned char direction; /* Iteration direction */

    unsigned char *lpi; /* listpack iterator */
    quicklistIter *iter; /* quicklist iterator */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7783,392411,listTypeEntry,4,listTypeEntry,,server.h,"typedef struct {
    listTypeIterator *li;
    unsigned char *lpe; /* Entry in listpack */
    quicklistEntry entry; /* Entry in quicklist */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7784,392416,setTypeIterator,4,setTypeIterator,,server.h,"typedef struct {
    robj *subject;
    int encoding;
    int ii; /* intset iterator */
    dictIterator *di;
    unsigned char *lpi; /* listpack iterator */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7785,392423,hashTypeIterator,4,hashTypeIterator,,server.h,"typedef struct {
    robj *subject;
    int encoding;

    unsigned char *fptr, *vptr;

    dictIterator *di;
    dictEntry *de;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7786,392432,redisServer,4,redisServer,,server.h,extern struct redisServer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7787,392434,sharedObjectsStruct,4,sharedObjectsStruct,,server.h,extern struct sharedObjectsStruct,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7788,393693,list_conv_type,4,list_conv_type,,server.h,"typedef enum {
    LIST_CONV_AUTO,
    LIST_CONV_GROWING,
    LIST_CONV_SHRINKING,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7789,394554,AuthResult,4,AuthResult,,server.h,"typedef enum {
    AUTH_OK = 0,
    AUTH_ERR,
    AUTH_NOT_HANDLED,
    AUTH_BLOCKED
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7790,394747,zrangespec,4,zrangespec,,server.h,"typedef struct {
    double min, max;
    int minex, maxex; /* are min or max exclusive? */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7791,394753,zlexrangespec,4,zlexrangespec,,server.h,"typedef struct {
    sds min, max;     /* May be set to shared.(minstring|maxstring) */
    int minex, maxex; /* are min or max exclusive? */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7792,395054,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7793,395056,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7794,395058,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7795,395060,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7796,395062,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7797,395064,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7798,395066,redisCommand,4,redisCommand,,server.h,struct redisCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7799,395279,redisMemOverhead,4,redisMemOverhead,,server.h,struct redisMemOverhead,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7800,395620,configEnum,4,configEnum,,server.h,"typedef struct configEnum {
    char *name;
    int val;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7801,395623,configEnum,4,configEnum,,server.h,"typedef struct configEnum {
    char *name;
    int val;
} configEnum;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7802,395624,configType,4,configType,,server.h,"typedef enum {
    BOOL_CONFIG,
    NUMERIC_CONFIG,
    STRING_CONFIG,
    SDS_CONFIG,
    ENUM_CONFIG,
    SPECIAL_CONFIG,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7803,395650,rewriteConfigState,4,rewriteConfigState,,server.h,struct rewriteConfigState,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7804,395702,ModuleConfig,4,ModuleConfig,,server.h,typedef struct ModuleConfig,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7805,395703,ModuleConfig,4,ModuleConfig,,server.h,typedef struct ModuleConfig ModuleConfig;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7806,396454,luaScript,4,luaScript,,server.h,"typedef struct luaScript {
    uint64_t flags;
    robj *body;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7807,396457,luaScript,4,luaScript,,server.h,"typedef struct luaScript {
    uint64_t flags;
    robj *body;
} luaScript;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7808,407583,SHA1_CTX,4,SHA1_CTX,,sha1.h,"typedef struct {
    uint32_t state[5];
    uint32_t count[2];
    unsigned char buffer[64];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7809,408623,BYTE,4,BYTE,,sha256.h,typedef uint8_t BYTE;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7810,408624,WORD,4,WORD,,sha256.h,typedef uint32_t WORD;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7811,408625,SHA256_CTX,4,SHA256_CTX,,sha256.h,"typedef struct {
	BYTE data[64];
	WORD datalen;
	unsigned long long bitlen;
	WORD state[8];
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7812,411166,slowlogEntry,4,slowlogEntry,,slowlog.h,"typedef struct slowlogEntry {
    robj **argv;
    int argc;
    long long id;       /* Unique entry identifier. */
    long long duration; /* Time spent by the query, in microseconds. */
    time_t time;        /* Unix time at which the query was executed. */
    sds cname;          /* Client name. */
    sds peerid;         /* Client network address. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7813,411174,slowlogEntry,4,slowlogEntry,,slowlog.h,"typedef struct slowlogEntry {
    robj **argv;
    int argc;
    long long id;       /* Unique entry identifier. */
    long long duration; /* Time spent by the query, in microseconds. */
    time_t time;        /* Unix time at which the query was executed. */
    sds cname;          /* Client name. */
    sds peerid;         /* Client network address. */
} slowlogEntry;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7814,415400,sample,4,sample,,sparkline.h,"struct sample {
    double value;
    char *label;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7815,415403,sequence,4,sequence,,sparkline.h,"struct sequence {
    int length;
    int labels;
    struct sample *samples;
    double min, max;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7816,415406,sample,4,sequence.sample,,sparkline.h,struct sample,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7817,415410,sequence,4,sequence,,sparkline.h,struct sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7818,415452,streamID,4,streamID,,stream.h,"typedef struct streamID {
    uint64_t ms;        /* Unix time in milliseconds. */
    uint64_t seq;       /* Sequence number. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7819,415455,streamID,4,streamID,,stream.h,"typedef struct streamID {
    uint64_t ms;        /* Unix time in milliseconds. */
    uint64_t seq;       /* Sequence number. */
} streamID;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7820,415456,stream,4,stream,,stream.h,"typedef struct stream {
    rax *rax;               /* The radix tree holding the stream. */
    uint64_t length;        /* Current number of elements inside this stream. */
    streamID last_id;       /* Zero if there are yet no items. */
    streamID first_id;      /* The first non-tombstone entry, zero if empty. */
    streamID max_deleted_entry_id;  /* The maximal ID that was deleted. */
    uint64_t entries_added; /* All time count of elements added. */
    rax *cgroups;           /* Consumer groups dictionary: name -> streamCG */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7821,415464,stream,4,stream,,stream.h,"typedef struct stream {
    rax *rax;               /* The radix tree holding the stream. */
    uint64_t length;        /* Current number of elements inside this stream. */
    streamID last_id;       /* Zero if there are yet no items. */
    streamID first_id;      /* The first non-tombstone entry, zero if empty. */
    streamID max_deleted_entry_id;  /* The maximal ID that was deleted. */
    uint64_t entries_added; /* All time count of elements added. */
    rax *cgroups;           /* Consumer groups dictionary: name -> streamCG */
} stream;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7822,415465,streamIterator,4,streamIterator,,stream.h,"typedef struct streamIterator {
    stream *stream;         /* The stream we are iterating. */
    streamID master_id;     /* ID of the master entry at listpack head. */
    uint64_t master_fields_count;       /* Master entries # of fields. */
    unsigned char *master_fields_start; /* Master entries start in listpack. */
    unsigned char *master_fields_ptr;   /* Master field to emit next. */
    int entry_flags;                    /* Flags of entry we are emitting. */
    int rev;                /* True if iterating end to start (reverse). */
    int skip_tombstones;    /* True if not emitting tombstone entries. */
    uint64_t start_key[2];  /* Start key as 128 bit big endian. */
    uint64_t end_key[2];    /* End key as 128 bit big endian. */
    raxIterator ri;         /* Rax iterator. */
    unsigned char *lp;      /* Current listpack. */
    unsigned char *lp_ele;  /* Current listpack cursor. */
    unsigned char *lp_flags; /* Current entry flags pointer. */
    /* Buffers us...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7823,415498,streamIterator,4,streamIterator,,stream.h,"typedef struct streamIterator {
    stream *stream;         /* The stream we are iterating. */
    streamID master_id;     /* ID of the master entry at listpack head. */
    uint64_t master_fields_count;       /* Master entries # of fields. */
    unsigned char *master_fields_start; /* Master entries start in listpack. */
    unsigned char *master_fields_ptr;   /* Master field to emit next. */
    int entry_flags;                    /* Flags of entry we are emitting. */
    int rev;                /* True if iterating end to start (reverse). */
    int skip_tombstones;    /* True if not emitting tombstone entries. */
    uint64_t start_key[2];  /* Start key as 128 bit big endian. */
    uint64_t end_key[2];    /* End key as 128 bit big endian. */
    raxIterator ri;         /* Rax iterator. */
    unsigned char *lp;      /* Current listpack. */
    unsigned char *lp_ele;  /* Current listpack cursor. */
    unsigned char *lp_flags; /* Current entry flags pointer. */
    /* Buffers us...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7824,415499,streamCG,4,streamCG,,stream.h,"typedef struct streamCG {
    streamID last_id;       /* Last delivered (not acknowledged) ID for this
                               group. Consumers that will just ask for more
                               messages will served with IDs > than this. */
    long long entries_read; /* In a perfect world (CG starts at 0-0, no dels, no
                               XGROUP SETID, ...), this is the total number of
                               group reads. In the real world, the reasoning behind
                               this value is detailed at the top comment of
                               streamEstimateDistanceFromFirstEverEntry(). */
    rax *pel;               /* Pending entries list. This is a radix tree that
                               has every message delivered to consumers (without
                               the NOACK option) that was yet not acknowledged
                               as processed. The key of the radix tree is the
                          ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7825,415504,streamCG,4,streamCG,,stream.h,"typedef struct streamCG {
    streamID last_id;       /* Last delivered (not acknowledged) ID for this
                               group. Consumers that will just ask for more
                               messages will served with IDs > than this. */
    long long entries_read; /* In a perfect world (CG starts at 0-0, no dels, no
                               XGROUP SETID, ...), this is the total number of
                               group reads. In the real world, the reasoning behind
                               this value is detailed at the top comment of
                               streamEstimateDistanceFromFirstEverEntry(). */
    rax *pel;               /* Pending entries list. This is a radix tree that
                               has every message delivered to consumers (without
                               the NOACK option) that was yet not acknowledged
                               as processed. The key of the radix tree is the
                          ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7826,415505,streamConsumer,4,streamConsumer,,stream.h,"typedef struct streamConsumer {
    mstime_t seen_time;         /* Last time this consumer tried to perform an action (attempted reading/claiming). */
    mstime_t active_time;       /* Last time this consumer was active (successful reading/claiming). */
    sds name;                   /* Consumer name. This is how the consumer
                                   will be identified in the consumer group
                                   protocol. Case sensitive. */
    rax *pel;                   /* Consumer specific pending entries list: all
                                   the pending messages delivered to this
                                   consumer not yet acknowledged. Keys are
                                   big endian message IDs, while values are
                                   the same streamNACK structure referenced
                                   in the ""pel"" of the consumer group structure
                                   itself, so the value is shared. ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7827,415510,streamConsumer,4,streamConsumer,,stream.h,"typedef struct streamConsumer {
    mstime_t seen_time;         /* Last time this consumer tried to perform an action (attempted reading/claiming). */
    mstime_t active_time;       /* Last time this consumer was active (successful reading/claiming). */
    sds name;                   /* Consumer name. This is how the consumer
                                   will be identified in the consumer group
                                   protocol. Case sensitive. */
    rax *pel;                   /* Consumer specific pending entries list: all
                                   the pending messages delivered to this
                                   consumer not yet acknowledged. Keys are
                                   big endian message IDs, while values are
                                   the same streamNACK structure referenced
                                   in the ""pel"" of the consumer group structure
                                   itself, so the value is shared. ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7828,415511,streamNACK,4,streamNACK,,stream.h,"typedef struct streamNACK {
    mstime_t delivery_time;     /* Last time this message was delivered. */
    uint64_t delivery_count;    /* Number of times this message was delivered.*/
    streamConsumer *consumer;   /* The consumer this message was delivered to
                                   in the last delivery. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7829,415515,streamNACK,4,streamNACK,,stream.h,"typedef struct streamNACK {
    mstime_t delivery_time;     /* Last time this message was delivered. */
    uint64_t delivery_count;    /* Number of times this message was delivered.*/
    streamConsumer *consumer;   /* The consumer this message was delivered to
                                   in the last delivery. */
} streamNACK;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7830,415516,streamPropInfo,4,streamPropInfo,,stream.h,"typedef struct streamPropInfo {
    robj *keyname;
    robj *groupname;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7831,415519,streamPropInfo,4,streamPropInfo,,stream.h,"typedef struct streamPropInfo {
    robj *keyname;
    robj *groupname;
} streamPropInfo;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7832,415520,client,4,client,,stream.h,struct client,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7833,416210,check,4,check,,syscheck.c,"typedef struct {
    const char *name;
    int (*check_fn)(sds*);
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7834,433795,streamAddTrimArgs,4,streamAddTrimArgs,,t_stream.c,"typedef struct {
    /* XADD options */
    streamID id; /* User-provided ID, for XADD only. */
    int id_given; /* Was an ID different than ""*"" specified? for XADD only. */
    int seq_given; /* Was an ID different than ""ms-*"" specified? for XADD only. */
    int no_mkstream; /* if set to 1 do not create new stream */

    /* XADD + XTRIM common options */
    int trim_strategy; /* TRIM_STRATEGY_* */
    int trim_strategy_arg_idx; /* Index of the count in MAXLEN/MINID, for rewriting. */
    int approx_trim; /* If 1 only delete whole radix tree nodes, so
                      * the trim argument is not applied verbatim. */
    long long limit; /* Maximum amount of entries to trim. If 0, no limitation
                      * on the amount of trimming work is enforced. */
    /* TRIM_STRATEGY_MAXLEN options */
    long long maxlen; /* After trimming, leave stream at this length . */
    /* TRIM_STRATEGY_MINID options */
    streamID minid; /* Trim by ID (No stream entries with ID < '...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7835,456023,zrange_type,4,zrange_type,,t_zset.c,"typedef enum {
    ZRANGE_AUTO = 0,
    ZRANGE_RANK,
    ZRANGE_SCORE,
    ZRANGE_LEX,
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7836,456547,zsetopsrc,4,zsetopsrc,,t_zset.c,"typedef struct {
    robj *subject;
    int type; /* Set, sorted set */
    int encoding;
    double weight;

    union {
        /* Set iterators. */
        union _iterset {
            struct {
                intset *is;
                int ii;
            } is;
            struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            } ht;
            struct {
                unsigned char *lp;
                unsigned char *p;
            } lp;
        } set;

        /* Sorted set iterators. */
        union _iterzset {
            struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            } zl;
            struct {
                zset *zs;
                zskiplistNode *node;
            } sl;
        } zset;
    } iter;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7837,456552,zsetopsrc.iter,4,zsetopsrc.iter,,t_zset.c,"union {
        /* Set iterators. */
        union _iterset {
            struct {
                intset *is;
                int ii;
            } is;
            struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            } ht;
            struct {
                unsigned char *lp;
                unsigned char *p;
            } lp;
        } set;

        /* Sorted set iterators. */
        union _iterzset {
            struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            } zl;
            struct {
                zset *zs;
                zskiplistNode *node;
            } sl;
        } zset;
    }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7838,456553,_iterset,4,zsetopsrc.iter._iterset,,t_zset.c,"union _iterset {
            struct {
                intset *is;
                int ii;
            } is;
            struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            } ht;
            struct {
                unsigned char *lp;
                unsigned char *p;
            } lp;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7839,456554,zsetopsrc.iter._iterset.is,4,zsetopsrc.iter._iterset.is,,t_zset.c,"struct {
                intset *is;
                int ii;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7840,456558,zsetopsrc.iter._iterset.ht,4,zsetopsrc.iter._iterset.ht,,t_zset.c,"struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7841,456563,zsetopsrc.iter._iterset.lp,4,zsetopsrc.iter._iterset.lp,,t_zset.c,"struct {
                unsigned char *lp;
                unsigned char *p;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7842,456568,_iterzset,4,zsetopsrc.iter._iterzset,,t_zset.c,"union _iterzset {
            struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            } zl;
            struct {
                zset *zs;
                zskiplistNode *node;
            } sl;
        }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7843,456569,zsetopsrc.iter._iterzset.zl,4,zsetopsrc.iter._iterzset.zl,,t_zset.c,"struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7844,456574,zsetopsrc.iter._iterzset.sl,4,zsetopsrc.iter._iterzset.sl,,t_zset.c,"struct {
                zset *zs;
                zskiplistNode *node;
            }",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7845,456581,zsetopval,4,zsetopval,,t_zset.c,"typedef struct {
    int flags;
    unsigned char _buf[32]; /* Private buffer. */
    sds ele;
    unsigned char *estr;
    unsigned int elen;
    long long ell;
    double score;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7846,456596,_iterset,4,_iterset,,t_zset.c,typedef union _iterset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7847,456597,iterset,4,iterset,,t_zset.c,typedef union _iterset iterset;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7848,456598,_iterzset,4,_iterzset,,t_zset.c,typedef union _iterzset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7849,456599,iterzset,4,iterzset,,t_zset.c,typedef union _iterzset iterzset;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7850,459888,zrange_direction,4,zrange_direction,,t_zset.c,"typedef enum {
    ZRANGE_DIRECTION_AUTO = 0,
    ZRANGE_DIRECTION_FORWARD,
    ZRANGE_DIRECTION_REVERSE
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7851,459900,zrange_consumer_type,4,zrange_consumer_type,,t_zset.c,"typedef enum {
    ZRANGE_CONSUMER_TYPE_CLIENT = 0,
    ZRANGE_CONSUMER_TYPE_INTERNAL
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7852,459911,zrange_result_handler,4,zrange_result_handler,,t_zset.c,typedef struct zrange_result_handler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7853,459912,zrange_result_handler,4,zrange_result_handler,,t_zset.c,typedef struct zrange_result_handler zrange_result_handler;,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7854,459949,zrange_result_handler,4,zrange_result_handler,,t_zset.c,"struct zrange_result_handler {
    zrange_consumer_type                 type;
    client                              *client;
    robj                                *dstkey;
    robj                                *dstobj;
    void                                *userdata;
    int                                  withscores;
    int                                  should_emit_array_length;
    zrangeResultBeginFunction            beginResultEmission;
    zrangeResultFinalizeFunction         finalizeResultEmission;
    zrangeResultEmitCBufferFunction      emitResultFromCBuffer;
    zrangeResultEmitLongLongFunction     emitResultFromLongLong;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7855,465630,bcastState,4,bcastState,,tracking.c,"typedef struct bcastState {
    rax *keys;      /* Keys modified in the current event loop cycle. */
    rax *clients;   /* Clients subscribed to the notification events for this
                       prefix. */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7856,465633,bcastState,4,bcastState,,tracking.c,"typedef struct bcastState {
    rax *keys;      /* Keys modified in the current event loop cycle. */
    rax *clients;   /* Clients subscribed to the notification events for this
                       prefix. */
} bcastState;",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7857,471338,ld2string_mode,4,ld2string_mode,,util.h,"typedef enum {
    LD_STR_AUTO,     /* %.17Lg */
    LD_STR_HUMAN,    /* %.17Lf + Trimming of trailing zeros */
    LD_STR_HEX       /* %La */
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7858,471621,zlentry,4,zlentry,,ziplist.c,"typedef struct zlentry {
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
    unsigned int prevrawlen;     /* Previous entry len. */
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
    unsigned int headersize;     /* prevrawlensize + lensize. */
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
         ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7859,471629,zlentry,4,zlentry,,ziplist.c,"typedef struct zlentry {
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
    unsigned int prevrawlen;     /* Previous entry len. */
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
    unsigned int headersize;     /* prevrawlensize + lensize. */
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
         ...",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7860,478176,ziplistEntry,4,ziplistEntry,,ziplist.h,"typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    unsigned int slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
}",-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7861,38584,redisCommandTable,2,cli_commands.h.redisCommandTable,,cli_commands.h,commandDocs[] redisCommandTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7862,39550,myself,2,cluster.c.myself,,cluster.c,clusterNode* myself,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,138,0,1,1,0,0,,0,0,0,0,0,
7863,39923,clusterNodesDictType,2,cluster.c.clusterNodesDictType,,cluster.c,dictType clusterNodesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7864,39934,clusterNodesBlackListDictType,2,cluster.c.clusterNodesBlackListDictType,,cluster.c,dictType clusterNodesBlackListDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7865,39959,clusterSdsToListType,2,cluster.c.clusterSdsToListType,,cluster.c,dictType clusterSdsToListType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7866,39993,auxFieldHandler,2,cluster.c.auxFieldHandler,,cluster.c,struct auxFieldHandler,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7867,40000,auxFieldIndex,2,cluster.c.auxFieldIndex,,cluster.c,enum auxFieldIndex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7868,40001,auxFieldHandlers,2,cluster.c.auxFieldHandlers,,cluster.c,auxFieldHandler[] auxFieldHandlers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
7869,40444,clusterMsgSendBlock,2,cluster.c.clusterMsgSendBlock,,cluster.c,struct clusterMsgSendBlock,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7870,57173,redisNodeFlagsTable,2,cluster.c.redisNodeFlagsTable,,cluster.c,redisNodeFlags[] redisNodeFlagsTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7871,66812,clusterDictMetadata,2,cluster.h.clusterDictMetadata,,cluster.h,struct clusterDictMetadata,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7872,66893,clusterMsgDataGossip,2,cluster.h.clusterMsgDataGossip,,cluster.h,struct clusterMsgDataGossip,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7873,66904,clusterMsgDataFail,2,cluster.h.clusterMsgDataFail,,cluster.h,struct clusterMsgDataFail,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7874,66915,clusterMsgDataPublish,2,cluster.h.clusterMsgDataPublish,,cluster.h,struct clusterMsgDataPublish,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7875,66934,clusterMsgDataUpdate,2,cluster.h.clusterMsgDataUpdate,,cluster.h,struct clusterMsgDataUpdate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7876,66946,clusterMsgModule,2,cluster.h.clusterMsgModule,,cluster.h,struct clusterMsgModule,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7877,66952,clusterMsgPingtypes,2,cluster.h.clusterMsgPingtypes,,cluster.h,enum clusterMsgPingtypes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7878,66961,clusterMsgPingExtHostname,2,cluster.h.clusterMsgPingExtHostname,,cluster.h,struct clusterMsgPingExtHostname,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7879,66970,clusterMsgPingExtHumanNodename,2,cluster.h.clusterMsgPingExtHumanNodename,,cluster.h,struct clusterMsgPingExtHumanNodename,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7880,66982,clusterMsgPingExtForgottenNode,2,cluster.h.clusterMsgPingExtForgottenNode,,cluster.h,struct clusterMsgPingExtForgottenNode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7881,66994,clusterMsgPingExtShardId,2,cluster.h.clusterMsgPingExtShardId,,cluster.h,struct clusterMsgPingExtShardId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7882,67010,clusterMsgPingExt,2,cluster.h.clusterMsgPingExt,,cluster.h,struct clusterMsgPingExt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7883,67082,clusterMsg,2,cluster.h.clusterMsg,,cluster.h,struct clusterMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7884,67320,redisCommandArgType,2,commands.h.redisCommandArgType,,commands.h,enum redisCommandArgType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7885,67370,maxmemory_policy_enum,2,config.c.maxmemory_policy_enum,,config.c,configEnum[] maxmemory_policy_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7886,67461,syslog_facility_enum,2,config.c.syslog_facility_enum,,config.c,configEnum[] syslog_facility_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7887,67495,loglevel_enum,2,config.c.loglevel_enum,,config.c,configEnum[] loglevel_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7888,67527,supervised_mode_enum,2,config.c.supervised_mode_enum,,config.c,configEnum[] supervised_mode_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7889,67554,aof_fsync_enum,2,config.c.aof_fsync_enum,,config.c,configEnum[] aof_fsync_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7890,67576,shutdown_on_sig_enum,2,config.c.shutdown_on_sig_enum,,config.c,configEnum[] shutdown_on_sig_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7891,67606,repl_diskless_load_enum,2,config.c.repl_diskless_load_enum,,config.c,configEnum[] repl_diskless_load_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7892,67628,tls_auth_clients_enum,2,config.c.tls_auth_clients_enum,,config.c,configEnum[] tls_auth_clients_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7893,67650,oom_score_adj_enum,2,config.c.oom_score_adj_enum,,config.c,configEnum[] oom_score_adj_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7894,67677,acl_pubsub_default_enum,2,config.c.acl_pubsub_default_enum,,config.c,configEnum[] acl_pubsub_default_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7895,67694,sanitize_dump_payload_enum,2,config.c.sanitize_dump_payload_enum,,config.c,configEnum[] sanitize_dump_payload_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7896,67716,protected_action_enum,2,config.c.protected_action_enum,,config.c,configEnum[] protected_action_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7897,67738,cluster_preferred_endpoint_type_enum,2,config.c.cluster_preferred_endpoint_type_enum,,config.c,configEnum[] cluster_preferred_endpoint_type_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7898,67754,propagation_error_behavior_enum,2,config.c.propagation_error_behavior_enum,,config.c,configEnum[] propagation_error_behavior_enum,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7899,67770,clientBufferLimitsDefaults,2,config.c.clientBufferLimitsDefaults,,config.c,clientBufferLimitsConfig[3] clientBufferLimitsDefaults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7900,67802,configOOMScoreAdjValuesDefaults,2,config.c.configOOMScoreAdjValuesDefaults,,config.c,int[3] configOOMScoreAdjValuesDefaults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7901,67939,configs,2,config.c.configs,,config.c,dict* configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
7902,68516,reading_config_file,2,config.c.reading_config_file,,config.c,static int reading_config_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7903,70711,optionToLineDictType,2,config.c.optionToLineDictType,,config.c,dictType optionToLineDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7904,70722,optionSetDictType,2,config.c.optionSetDictType,,config.c,dictType optionSetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7905,73141,loadbuf,2,config.c.loadbuf,,config.c,char[256] loadbuf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
7906,78522,static_configs,2,config.c.static_configs,,config.c,standardConfig[] static_configs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7907,97486,connTypes,2,connection.c.connTypes,,connection.c,ConnectionType*[8] connTypes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7908,98099,ConnectionState,2,connection.h.ConnectionState,,connection.h,enum ConnectionState,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7909,99082,crc16tab,2,server.h.crc16tab,,server.h,ANY crc16tab,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7910,99387,crc16_slot_table,2,crc16_slottable.h.crc16_slot_table,,crc16_slottable.h,char[] crc16_slot_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7911,100403,crc64_table,2,crc64.c.crc64_table,,crc64.c,static uint64_t[8][256] crc64_table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7912,104071,scanData,2,db.c.scanData,,db.c,struct scanData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7913,104367,obj_type_name,2,db.c.obj_type_name,,db.c,char*[7] obj_type_name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7914,108301,commands_with_channels,2,db.c.commands_with_channels,,db.c,ChannelSpecs[] commands_with_channels,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7915,110223,bug_report_start,2,debug.c.bug_report_start,,debug.c,static int bug_report_start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7916,110227,bug_report_start_mutex,2,debug.c.bug_report_start_mutex,,debug.c,pthread_mutex_t bug_report_start_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7917,116275,dict_can_resize,2,dict.c.dict_can_resize,,dict.c,dictResizeEnable dict_can_resize,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
7918,116279,dict_force_resize_ratio,2,dict.c.dict_force_resize_ratio,,dict.c,static unsigned int dict_force_resize_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7919,116302,dictEntryNoValue,2,dict.c.dictEntryNoValue,,dict.c,struct dictEntryNoValue,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7920,116335,dict_hash_function_seed,2,dict.c.dict_hash_function_seed,,dict.c,static uint8_t[16] dict_hash_function_seed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7921,122671,dictDefragFunctions,2,dict.h.dictDefragFunctions,,dict.h,struct dictDefragFunctions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7922,122676,dictResizeEnable,2,dict.h.dictResizeEnable,,dict.h,enum dictResizeEnable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7923,123352,shaScriptObjectDictType,2,eval.c.shaScriptObjectDictType,,eval.c,dictType shaScriptObjectDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7924,123368,lctx,2,eval.c.lctx,,eval.c,struct luaCtx lctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,31,0,1,1,0,0,,0,0,0,0,0,
7925,123394,ldb,2,eval.c.ldb,,eval.c,struct ldbState ldb,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,87,0,1,1,0,0,,0,0,0,0,0,
7926,128839,EvictionPoolLRU,2,evict.c.EvictionPoolLRU,,evict.c,struct evictionPoolEntry* EvictionPoolLRU,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7927,129766,isEvictionProcRunning,2,evict.c.isEvictionProcRunning,,evict.c,static int isEvictionProcRunning,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
7928,130828,expireScanData,2,expire.c.expireScanData,,expire.c,struct expireScanData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7929,131460,slaveKeysWithExpire,2,expire.c.slaveKeysWithExpire,,expire.c,dict* slaveKeysWithExpire,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
7930,133932,restorePolicy,2,functions.c.restorePolicy,,functions.c,enum restorePolicy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7931,133933,engine_cache_memory,2,functions.c.engine_cache_memory,,functions.c,size_t engine_cache_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7932,133974,engineDictType,2,functions.c.engineDictType,,functions.c,dictType engineDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7933,133985,functionDictType,2,functions.c.functionDictType,,functions.c,dictType functionDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7934,133996,engineStatsDictType,2,functions.c.engineStatsDictType,,functions.c,dictType engineStatsDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7935,134007,libraryFunctionDictType,2,functions.c.libraryFunctionDictType,,functions.c,dictType libraryFunctionDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7936,134018,librariesDictType,2,functions.c.librariesDictType,,functions.c,dictType librariesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7937,134029,engines,2,functions.c.engines,,functions.c,dict* engines,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
7938,134033,curr_functions_lib_ctx,2,functions.c.curr_functions_lib_ctx,,functions.c,functionsLibCtx* curr_functions_lib_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
7939,142718,GeoDirection,2,geohash.h.GeoDirection,,geohash.h,enum GeoDirection,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7940,142722,GeoHashBits,2,geohash.h.GeoHashBits,,geohash.h,struct GeoHashBits,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7941,142726,GeoHashRange,2,geohash.h.GeoHashRange,,geohash.h,struct GeoHashRange,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7942,142731,GeoHashArea,2,geohash.h.GeoHashArea,,geohash.h,struct GeoHashArea,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7943,142741,GeoHashNeighbors,2,geohash.h.GeoHashNeighbors,,geohash.h,struct GeoHashNeighbors,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7944,142762,GeoShape,2,geohash.h.GeoShape,,geohash.h,struct GeoShape,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7945,142852,DEG_TO_RAD,2,geohash_helper.c.DEG_TO_RAD,,geohash_helper.c,const double DEG_TO_RAD,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7946,142856,EARTH_RADIUS_IN_METERS,2,geohash_helper.c.EARTH_RADIUS_IN_METERS,,geohash_helper.c,const double EARTH_RADIUS_IN_METERS,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7947,142860,MERCATOR_MAX,2,geohash_helper.c.MERCATOR_MAX,,geohash_helper.c,const double MERCATOR_MAX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7948,142864,MERCATOR_MIN,2,geohash_helper.c.MERCATOR_MIN,,geohash_helper.c,const double MERCATOR_MIN,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7949,143913,GeoHashRadius,2,geohash_helper.h.GeoHashRadius,,geohash_helper.h,struct GeoHashRadius,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7950,144003,invalid_hll_err,2,hyperloglog.c.invalid_hll_err,,hyperloglog.c,static char* invalid_hll_err,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7951,150664,latencyTimeSeriesDictType,2,latency.c.latencyTimeSeriesDictType,,latency.c,dictType latencyTimeSeriesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7952,153045,DurationType,2,latency.h.DurationType,,latency.h,enum DurationType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7953,153065,lazyfree_objects,2,server.h.lazyfree_objects,,server.h,size_t lazyfree_objects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
7954,153069,lazyfreed_objects,2,server.h.lazyfreed_objects,,server.h,size_t lazyfreed_objects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
7955,159977,listpackEntry,2,listpack.h.listpackEntry,,listpack.h,struct listpackEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7956,163869,ws,2,memtest.c.ws,,memtest.c,struct winsize ws,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7957,163870,progress_printed,2,memtest.c.progress_printed,,memtest.c,size_t progress_printed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7958,163871,progress_full,2,memtest.c.progress_full,,memtest.c,size_t progress_full,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7959,164991,modules,2,module.c.modules,,module.c,dict* modules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
7960,165119,moduleAuthCallbacks,2,module.c.moduleAuthCallbacks,,module.c,list* moduleAuthCallbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7961,165120,moduleUnblockedClientsMutex,2,module.c.moduleUnblockedClientsMutex,,module.c,pthread_mutex_t moduleUnblockedClientsMutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
7962,165124,moduleUnblockedClients,2,module.c.moduleUnblockedClients,,module.c,list* moduleUnblockedClients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
7963,165125,moduleTempClients,2,module.c.moduleTempClients,,module.c,client** moduleTempClients,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7964,165126,moduleTempClientCap,2,module.c.moduleTempClientCap,,module.c,size_t moduleTempClientCap,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
7965,165130,moduleTempClientCount,2,module.c.moduleTempClientCount,,module.c,size_t moduleTempClientCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
7966,165134,moduleTempClientMinCount,2,module.c.moduleTempClientMinCount,,module.c,size_t moduleTempClientMinCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7967,165138,moduleGIL,2,module.c.moduleGIL,,module.c,pthread_mutex_t moduleGIL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
7968,165173,moduleKeyspaceSubscribers,2,module.c.moduleKeyspaceSubscribers,,module.c,list* moduleKeyspaceSubscribers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7969,165174,modulePostExecUnitJobs,2,module.c.modulePostExecUnitJobs,,module.c,list* modulePostExecUnitJobs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7970,165198,moduleCommandFilters,2,module.c.moduleCommandFilters,,module.c,list* moduleCommandFilters,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
7971,165209,moduleForkInfo,2,module.c.moduleForkInfo,,module.c,struct RedisModuleForkInfo moduleForkInfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
7972,165222,RedisModule_EventListeners,2,module.c.RedisModule_EventListeners,,module.c,list* RedisModule_EventListeners,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
7973,165391,moduleCopyCommandArgs,2,module.c.moduleCopyCommandArgs,,module.c,struct redisCommandArg* moduleCopyCommandArgs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7974,182351,ModuleTypeNameCharSet,2,module.c.ModuleTypeNameCharSet,,module.c,const char* ModuleTypeNameCharSet,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7975,187495,clusterReceivers,2,module.c.clusterReceivers,,module.c,moduleClusterReceiver*[] clusterReceivers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7976,188210,Timers,2,module.c.Timers,,module.c,rax* Timers,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
7977,188211,aeTimer,2,module.c.aeTimer,,module.c,long long aeTimer,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7978,188742,moduleEventLoopOneShots,2,module.c.moduleEventLoopOneShots,,module.c,list* moduleEventLoopOneShots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
7979,188743,moduleEventLoopMutex,2,module.c.moduleEventLoopMutex,,module.c,pthread_mutex_t moduleEventLoopMutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
7980,192815,ScanCBData,2,module.c.ScanCBData,,module.c,struct ScanCBData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7981,193010,ScanKeyCBData,2,module.c.ScanKeyCBData,,module.c,struct ScanKeyCBData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7982,193738,moduleEventVersions,2,module.c.moduleEventVersions,,module.c,static uint64_t[] moduleEventVersions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7983,194926,moduleAPIDictType,2,module.c.moduleAPIDictType,,module.c,dictType moduleAPIDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
7984,194962,sdsKeyValueHashDictType,2,module.c.sdsKeyValueHashDictType,,module.c,dictType sdsKeyValueHashDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
7985,197417,configerr,2,module.c.configerr,,module.c,char[256] configerr,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7986,203400,global,2,modules\helloacl.c.global,,modules\helloacl.c,RedisModuleUser* global,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
7987,203401,global_auth_client_id,2,modules\helloacl.c.global_auth_client_id,,modules\helloacl.c,uint64_t global_auth_client_id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
7988,204630,Keyspace,2,modules\hellodict.c.Keyspace,,modules\hellodict.c,RedisModuleDict* Keyspace,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7989,205265,HelloType,2,modules\hellotype.c.HelloType,,modules\hellotype.c,RedisModuleType* HelloType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7990,208099,monotonic_info_string,2,monotonic.h.monotonic_info_string,,monotonic.h,char[32] monotonic_info_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
7991,208258,mt,2,mt19937-64.c.mt,,mt19937-64.c,unsigned longlongint[312] mt,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,27,0,1,1,0,0,,0,0,0,0,0,
7992,208263,mti,2,mt19937-64.c.mti,,mt19937-64.c,static int mti,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
7993,210530,ProcessingEventsWhileBlocked,2,networking.c.ProcessingEventsWhileBlocked,,networking.c,int ProcessingEventsWhileBlocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
7994,225366,io_threads,2,networking.c.io_threads,,networking.c,pthread_t[128] io_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
7995,225371,io_threads_mutex,2,networking.c.io_threads_mutex,,networking.c,pthread_mutex_t[128] io_threads_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
7996,225376,io_threads_pending,2,networking.c.io_threads_pending,,networking.c,threads_pending[128] io_threads_pending,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
7997,225381,io_threads_op,2,networking.c.io_threads_op,,networking.c,int io_threads_op,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
7998,225382,io_threads_list,2,networking.c.io_threads_list,,networking.c,list*[128] io_threads_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
7999,235239,pubSubType,2,pubsub.c.pubSubType,,pubsub.c,pubsubtype pubSubType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8000,235283,pubSubShardType,2,pubsub.c.pubSubShardType,,pubsub.c,pubsubtype pubSubShardType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8001,237816,optimization_level,2,quicklist.c.optimization_level,,quicklist.c,ANY optimization_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8002,237825,packed_threshold,2,quicklist.c.packed_threshold,,quicklist.c,size_t packed_threshold,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8003,244037,x,2,rand.c.x,,rand.c,static uint32_t[3] x,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8004,244038,a,2,rand.c.a,,rand.c,static uint32_t[3] a,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8005,244039,c,2,rand.c.c,,rand.c,uint32_t c,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8006,244747,raxNotFound,2,rax.c.raxNotFound,,rax.c,void* raxNotFound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8007,244759,raxDebugMsg,2,rax.c.raxDebugMsg,,rax.c,static int raxDebugMsg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8008,251895,raxNotFound,2,rax.h.raxNotFound,,rax.h,extern void* raxNotFound,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8009,252067,rdbFileBeingLoaded,2,rdb.c.rdbFileBeingLoaded,,rdb.c,char* rdbFileBeingLoaded,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8010,252071,rdbCheckMode,2,rdb.c.rdbCheckMode,,rdb.c,extern int rdbCheckMode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8011,266510,config,2,redis-benchmark.c.config,,redis-benchmark.c,struct config config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,161,0,1,1,0,0,,0,0,0,0,0,
8012,274127,input_file_type,2,redis-check-aof.c.input_file_type,,redis-check-aof.c,enum input_file_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8013,274143,error,2,redis-check-aof.c.error,,redis-check-aof.c,char[1044] error,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
8014,274146,epos,2,redis-check-aof.c.epos,,redis-check-aof.c,off_t epos,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
8015,274147,line,2,redis-check-aof.c.line,,redis-check-aof.c,static long long line,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8016,274151,to_timestamp,2,redis-check-aof.c.to_timestamp,,redis-check-aof.c,time_t to_timestamp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8017,275700,rdbCheckMode,2,redis-check-rdb.c.rdbCheckMode,,redis-check-rdb.c,int rdbCheckMode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8018,275720,rdbstate,2,redis-check-rdb.c.rdbstate,,redis-check-rdb.c,struct rdbstate,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
8019,275721,rdb_check_doing_string,2,redis-check-rdb.c.rdb_check_doing_string,,redis-check-rdb.c,char*[] rdb_check_doing_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8020,275735,rdb_type_string,2,redis-check-rdb.c.rdb_type_string,,redis-check-rdb.c,char*[] rdb_type_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8021,277019,spectrum_palette_color_size,2,redis-cli.c.spectrum_palette_color_size,,redis-cli.c,int spectrum_palette_color_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8022,277023,spectrum_palette_color,2,redis-cli.c.spectrum_palette_color,,redis-cli.c,int[] spectrum_palette_color,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8023,277046,spectrum_palette_mono_size,2,redis-cli.c.spectrum_palette_mono_size,,redis-cli.c,int spectrum_palette_mono_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8024,277050,spectrum_palette_mono,2,redis-cli.c.spectrum_palette_mono,,redis-cli.c,int[] spectrum_palette_mono,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8025,277067,spectrum_palette,2,redis-cli.c.spectrum_palette,,redis-cli.c,int* spectrum_palette,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8026,277068,spectrum_palette_size,2,redis-cli.c.spectrum_palette_size,,redis-cli.c,int spectrum_palette_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8027,277069,orig_termios_saved,2,redis-cli.c.orig_termios_saved,,redis-cli.c,static int orig_termios_saved,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8028,277074,orig_termios,2,redis-cli.c.orig_termios,,redis-cli.c,struct termios orig_termios,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8029,277200,config,2,redis-cli.c.config,,redis-cli.c,struct config config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,172,0,1,1,0,0,,0,0,0,0,0,
8030,277203,pref,2,redis-cli.c.pref,,redis-cli.c,struct pref pref,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8031,277204,force_cancel_loop,2,redis-cli.c.force_cancel_loop,,redis-cli.c,volatile sig_atomic_t force_cancel_loop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8032,277566,helpEntry,2,redis-cli.c.helpEntry,,redis-cli.c,struct helpEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
8033,277567,helpEntries,2,redis-cli.c.helpEntries,,redis-cli.c,helpEntry* helpEntries,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
8034,277571,helpEntriesLen,2,redis-cli.c.helpEntriesLen,,redis-cli.c,static int helpEntriesLen,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
8035,289861,cluster_manager,2,redis-cli.c.cluster_manager,,redis-cli.c,struct clusterManager cluster_manager,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,24,0,1,1,0,0,,0,0,0,0,0,
8036,289862,clusterManagerUncoveredSlots,2,redis-cli.c.clusterManagerUncoveredSlots,,redis-cli.c,dict* clusterManagerUncoveredSlots,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
8037,289914,clusterManagerDictType,2,redis-cli.c.clusterManagerDictType,,redis-cli.c,dictType clusterManagerDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8038,289925,clusterManagerLinkDictType,2,redis-cli.c.clusterManagerLinkDictType,,redis-cli.c,dictType clusterManagerLinkDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8039,290176,clusterManagerCommands,2,redis-cli.c.clusterManagerCommands,,redis-cli.c,clusterManagerCommandDef[] clusterManagerCommands,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8040,290269,clusterManagerOptions,2,redis-cli.c.clusterManagerOptions,,redis-cli.c,clusterManagerOptionDef[] clusterManagerOptions,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8041,310353,typeinfo,2,redis-cli.c.typeinfo,,redis-cli.c,struct typeinfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8042,310354,type_string,2,redis-cli.c.type_string,,redis-cli.c,typeinfo type_string,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8043,310361,type_list,2,redis-cli.c.type_list,,redis-cli.c,typeinfo type_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8044,310368,type_set,2,redis-cli.c.type_set,,redis-cli.c,typeinfo type_set,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8045,310375,type_hash,2,redis-cli.c.type_hash,,redis-cli.c,typeinfo type_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8046,310382,type_zset,2,redis-cli.c.type_zset,,redis-cli.c,typeinfo type_zset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8047,310389,type_stream,2,redis-cli.c.type_stream,,redis-cli.c,typeinfo type_stream,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8048,310396,type_other,2,redis-cli.c.type_other,,redis-cli.c,typeinfo type_other,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8049,310466,typeinfoDictType,2,redis-cli.c.typeinfoDictType,,redis-cli.c,dictType typeinfoDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8050,314178,RedisModuleCommandArgType,2,redismodule.h.RedisModuleCommandArgType,,redismodule.h,enum RedisModuleCommandArgType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8051,314191,RedisModuleKeySpecBeginSearchType,2,redismodule.h.RedisModuleKeySpecBeginSearchType,,redismodule.h,enum RedisModuleKeySpecBeginSearchType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8052,314204,RedisModuleKeySpecFindKeysType,2,redismodule.h.RedisModuleKeySpecFindKeysType,,redismodule.h,enum RedisModuleKeySpecFindKeysType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8053,314221,RedisModuleCommandHistoryEntry,2,redismodule.h.RedisModuleCommandHistoryEntry,,redismodule.h,struct RedisModuleCommandHistoryEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8054,314248,RedisModuleCommandKeySpec,2,redismodule.h.RedisModuleCommandKeySpec,,redismodule.h,struct RedisModuleCommandKeySpec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8055,314254,RedisModuleCommandInfoVersion,2,redismodule.h.RedisModuleCommandInfoVersion,,redismodule.h,struct RedisModuleCommandInfoVersion,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8056,314255,RedisModule_CurrentCommandInfoVersion,2,redismodule.h.RedisModule_CurrentCommandInfoVersion,,redismodule.h,const RedisModuleCommandInfoVersion RedisModule_CurrentCommandInfoVersion,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8057,314288,RedisModuleCommandInfo,2,redismodule.h.RedisModuleCommandInfo,,redismodule.h,struct RedisModuleCommandInfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8058,314315,RedisModuleEvent_ReplicationRoleChanged,2,redismodule.h.RedisModuleEvent_ReplicationRoleChanged,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ReplicationRoleChanged,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8059,314316,RedisModuleEvent_Persistence,2,redismodule.h.RedisModuleEvent_Persistence,,redismodule.h,const RedisModuleEvent RedisModuleEvent_Persistence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8060,314317,RedisModuleEvent_FlushDB,2,redismodule.h.RedisModuleEvent_FlushDB,,redismodule.h,const RedisModuleEvent RedisModuleEvent_FlushDB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8061,314318,RedisModuleEvent_Loading,2,redismodule.h.RedisModuleEvent_Loading,,redismodule.h,const RedisModuleEvent RedisModuleEvent_Loading,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8062,314319,RedisModuleEvent_ClientChange,2,redismodule.h.RedisModuleEvent_ClientChange,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ClientChange,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8063,314320,RedisModuleEvent_Shutdown,2,redismodule.h.RedisModuleEvent_Shutdown,,redismodule.h,const RedisModuleEvent RedisModuleEvent_Shutdown,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8064,314321,RedisModuleEvent_ReplicaChange,2,redismodule.h.RedisModuleEvent_ReplicaChange,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ReplicaChange,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8065,314322,RedisModuleEvent_CronLoop,2,redismodule.h.RedisModuleEvent_CronLoop,,redismodule.h,const RedisModuleEvent RedisModuleEvent_CronLoop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8066,314323,RedisModuleEvent_MasterLinkChange,2,redismodule.h.RedisModuleEvent_MasterLinkChange,,redismodule.h,const RedisModuleEvent RedisModuleEvent_MasterLinkChange,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8067,314324,RedisModuleEvent_ModuleChange,2,redismodule.h.RedisModuleEvent_ModuleChange,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ModuleChange,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8068,314325,RedisModuleEvent_LoadingProgress,2,redismodule.h.RedisModuleEvent_LoadingProgress,,redismodule.h,const RedisModuleEvent RedisModuleEvent_LoadingProgress,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8069,314326,RedisModuleEvent_SwapDB,2,redismodule.h.RedisModuleEvent_SwapDB,,redismodule.h,const RedisModuleEvent RedisModuleEvent_SwapDB,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8070,314327,RedisModuleEvent_ReplBackup,2,redismodule.h.RedisModuleEvent_ReplBackup,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ReplBackup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8071,314328,RedisModuleEvent_ReplAsyncLoad,2,redismodule.h.RedisModuleEvent_ReplAsyncLoad,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ReplAsyncLoad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8072,314329,RedisModuleEvent_ForkChild,2,redismodule.h.RedisModuleEvent_ForkChild,,redismodule.h,const RedisModuleEvent RedisModuleEvent_ForkChild,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8073,314330,RedisModuleEvent_EventLoop,2,redismodule.h.RedisModuleEvent_EventLoop,,redismodule.h,const RedisModuleEvent RedisModuleEvent_EventLoop,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8074,314331,RedisModuleEvent_Config,2,redismodule.h.RedisModuleEvent_Config,,redismodule.h,const RedisModuleEvent RedisModuleEvent_Config,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8075,314332,RedisModuleEvent_Key,2,redismodule.h.RedisModuleEvent_Key,,redismodule.h,const RedisModuleEvent RedisModuleEvent_Key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8076,314528,RedisModuleACLLogEntryReason,2,redismodule.h.RedisModuleACLLogEntryReason,,redismodule.h,enum RedisModuleACLLogEntryReason,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8077,320073,RDBGeneratedByReplication,2,replication.c.RDBGeneratedByReplication,,replication.c,int RDBGeneratedByReplication,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8078,334517,rioBufferIO,2,rio.c.rioBufferIO,,rio.c,const rio rioBufferIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8079,334887,rioFileIO,2,rio.c.rioFileIO,,rio.c,const rio rioFileIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8080,335399,rioConnIO,2,rio.c.rioConnIO,,rio.c,const rio rioConnIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8081,335828,rioFdIO,2,rio.c.rioFdIO,,rio.c,const rio rioFdIO,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8082,336590,scripts_flags_def,2,script.c.scripts_flags_def,,script.c,scriptFlag[] scripts_flags_def,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8083,336668,curr_run_ctx,2,script.c.curr_run_ctx,,script.c,scriptRunCtx* curr_run_ctx,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
8084,338616,scripts_flags_def,2,script.h.scripts_flags_def,,script.h,scriptFlag[] scripts_flags_def,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8085,338734,libraries_allow_list,2,script_lua.c.libraries_allow_list,,script_lua.c,char*[] libraries_allow_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8086,338746,redis_api_allow_list,2,script_lua.c.redis_api_allow_list,,script_lua.c,char*[] redis_api_allow_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8087,338753,lua_builtins_allow_list,2,script_lua.c.lua_builtins_allow_list,,script_lua.c,char*[] lua_builtins_allow_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8088,338784,lua_builtins_not_documented_allow_list,2,script_lua.c.lua_builtins_not_documented_allow_list,,script_lua.c,char*[] lua_builtins_not_documented_allow_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8089,338790,lua_builtins_removed_after_initialization_allow_list,2,script_lua.c.lua_builtins_removed_after_initialization_allow_list,,script_lua.c,char*[] lua_builtins_removed_after_initialization_allow_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8090,338796,allow_lists,2,script_lua.c.allow_lists,,script_lua.c,char**[] allow_lists,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8091,338806,deny_list,2,script_lua.c.deny_list,,script_lua.c,char*[] deny_list,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8092,339046,DefaultLuaTypeParserCallbacks,2,script_lua.c.DefaultLuaTypeParserCallbacks,,script_lua.c,const ReplyParserCallbacks DefaultLuaTypeParserCallbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8093,340655,lua_argv,2,script_lua.c.lua_argv,,script_lua.c,robj** lua_argv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8094,340659,lua_argv_size,2,script_lua.c.lua_argv_size,,script_lua.c,static int lua_argv_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8095,340663,lua_args_cached_objects,2,script_lua.c.lua_args_cached_objects,,script_lua.c,redisObject*[32] lua_args_cached_objects,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8096,340668,lua_args_cached_objects_len,2,script_lua.c.lua_args_cached_objects_len,,script_lua.c,static size_t[32] lua_args_cached_objects_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8097,343504,SDS_NOINIT,2,sds.c.SDS_NOINIT,,sds.c,const char* SDS_NOINIT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8098,346965,SDS_NOINIT,2,sds.h.SDS_NOINIT,,sds.h,extern const char* SDS_NOINIT,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8099,347977,environ,2,sentinel.c.environ,,sentinel.c,extern char** environ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8100,347983,sentinel_info_period,2,sentinel.c.sentinel_info_period,,sentinel.c,mstime_t sentinel_info_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8101,347987,sentinel_ping_period,2,sentinel.c.sentinel_ping_period,,sentinel.c,mstime_t sentinel_ping_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8102,347993,sentinel_ask_period,2,sentinel.c.sentinel_ask_period,,sentinel.c,mstime_t sentinel_ask_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8103,347997,sentinel_publish_period,2,sentinel.c.sentinel_publish_period,,sentinel.c,mstime_t sentinel_publish_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8104,348001,sentinel_default_down_after,2,sentinel.c.sentinel_default_down_after,,sentinel.c,mstime_t sentinel_default_down_after,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8105,348005,sentinel_tilt_trigger,2,sentinel.c.sentinel_tilt_trigger,,sentinel.c,mstime_t sentinel_tilt_trigger,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8106,348009,sentinel_tilt_period,2,sentinel.c.sentinel_tilt_period,,sentinel.c,mstime_t sentinel_tilt_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8107,348017,sentinel_slave_reconf_timeout,2,sentinel.c.sentinel_slave_reconf_timeout,,sentinel.c,mstime_t sentinel_slave_reconf_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8108,348021,sentinel_min_link_reconnect_period,2,sentinel.c.sentinel_min_link_reconnect_period,,sentinel.c,mstime_t sentinel_min_link_reconnect_period,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8109,348025,sentinel_election_timeout,2,sentinel.c.sentinel_election_timeout,,sentinel.c,mstime_t sentinel_election_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8110,348029,sentinel_script_max_runtime,2,sentinel.c.sentinel_script_max_runtime,,sentinel.c,mstime_t sentinel_script_max_runtime,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8111,348033,sentinel_script_retry_delay,2,sentinel.c.sentinel_script_retry_delay,,sentinel.c,mstime_t sentinel_script_retry_delay,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8112,348037,sentinel_default_failover_timeout,2,sentinel.c.sentinel_default_failover_timeout,,sentinel.c,mstime_t sentinel_default_failover_timeout,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8113,348137,sentinel,2,sentinel.c.sentinel,,sentinel.c,struct sentinelState sentinel,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,79,0,1,1,0,0,,0,0,0,0,0,
8114,348622,instancesDictType,2,sentinel.c.instancesDictType,,sentinel.c,dictType instancesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8115,348633,leaderVotesDictType,2,sentinel.c.leaderVotesDictType,,sentinel.c,dictType leaderVotesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8116,348644,renamedCommandsDictType,2,sentinel.c.renamedCommandsDictType,,sentinel.c,dictType renamedCommandsDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8117,348670,preMonitorCfgName,2,sentinel.c.preMonitorCfgName,,sentinel.c,char[] preMonitorCfgName,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8118,366671,shared,2,server.c.shared,,server.c,struct sharedObjectsStruct shared,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
8119,366672,R_Zero,2,server.c.R_Zero,,server.c,double R_Zero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8120,366673,R_PosInf,2,server.c.R_PosInf,,server.c,double R_PosInf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8121,366674,R_NegInf,2,server.c.R_NegInf,,server.c,double R_NegInf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8122,366675,R_Nan,2,server.c.R_Nan,,server.c,double R_Nan,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8123,366677,server,2,server.c.server,,server.c,struct redisServer server,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,950,0,1,1,0,0,,0,0,0,0,0,
8124,367660,objectKeyPointerValueDictType,2,server.c.objectKeyPointerValueDictType,,server.c,dictType objectKeyPointerValueDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8125,367671,objectKeyHeapPointerValueDictType,2,server.c.objectKeyHeapPointerValueDictType,,server.c,dictType objectKeyHeapPointerValueDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8126,367682,setDictType,2,server.c.setDictType,,server.c,dictType setDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8127,367699,zsetDictType,2,server.c.zsetDictType,,server.c,dictType zsetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8128,367710,dbDictType,2,server.c.dbDictType,,server.c,dictType dbDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8129,367733,dbExpiresDictType,2,server.c.dbExpiresDictType,,server.c,dictType dbExpiresDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8130,367744,commandTableDictType,2,server.c.commandTableDictType,,server.c,dictType commandTableDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8131,367755,hashDictType,2,server.c.hashDictType,,server.c,dictType hashDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8132,367766,sdsReplyDictType,2,server.c.sdsReplyDictType,,server.c,dictType sdsReplyDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8133,367777,keylistDictType,2,server.c.keylistDictType,,server.c,dictType keylistDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8134,367788,modulesDictType,2,server.c.modulesDictType,,server.c,dictType modulesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8135,367799,migrateCacheDictType,2,server.c.migrateCacheDictType,,server.c,dictType migrateCacheDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8136,367810,stringSetDictType,2,server.c.stringSetDictType,,server.c,dictType stringSetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8137,367821,externalStringType,2,server.c.externalStringType,,server.c,dictType externalStringType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8138,367832,sdsHashDictType,2,server.c.sdsHashDictType,,server.c,dictType sdsHashDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8139,368735,ClientsPeakMemInput,2,server.c.ClientsPeakMemInput,,server.c,size_t[8] ClientsPeakMemInput,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8140,368740,ClientsPeakMemOutput,2,server.c.ClientsPeakMemOutput,,server.c,size_t[8] ClientsPeakMemOutput,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8141,371259,ProcessingEventsWhileBlocked,2,server.c.ProcessingEventsWhileBlocked,,server.c,extern int ProcessingEventsWhileBlocked,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8142,373313,environ,2,server.c.environ,,server.c,extern char** environ,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8143,376674,redisCommandTable,2,server.c.redisCommandTable,,server.c,redisCommand[] redisCommandTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8144,382360,ARG_TYPE_STR,2,server.c.ARG_TYPE_STR,,server.c,char[] ARG_TYPE_STR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8145,383921,commandListFilterType,2,server.c.commandListFilterType,,server.c,enum commandListFilterType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8146,383932,commandListFilter,2,server.c.commandListFilter,,server.c,struct commandListFilter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8147,384898,unsafe_info_chars,2,server.c.unsafe_info_chars,,server.c,char[] unsafe_info_chars,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8148,384902,unsafe_info_chars_substs,2,server.c.unsafe_info_chars_substs,,server.c,char[] unsafe_info_chars_substs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8149,385202,cached_default_info_sections,2,server.c.cached_default_info_sections,,server.c,dict* cached_default_info_sections,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8150,390929,configOOMScoreAdjValuesDefaults,2,server.h.configOOMScoreAdjValuesDefaults,,server.h,int[3] configOOMScoreAdjValuesDefaults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8151,390993,pause_purpose,2,server.h.pause_purpose,,server.h,enum pause_purpose,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8152,390997,pause_event,2,server.h.pause_event,,server.h,struct pause_event,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8153,391009,cluster_endpoint_type,2,server.h.cluster_endpoint_type,,server.h,enum cluster_endpoint_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8154,391315,clientMemUsageBucket,2,server.h.clientMemUsageBucket,,server.h,struct clientMemUsageBucket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8155,391600,clientBufferLimitsDefaults,2,server.h.clientBufferLimitsDefaults,,server.h,clientBufferLimitsConfig[3] clientBufferLimitsDefaults,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8156,391659,replicationErrorBehavior,2,server.h.replicationErrorBehavior,,server.h,enum replicationErrorBehavior,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8157,391717,aof_file_type,2,server.h.aof_file_type,,server.h,enum aof_file_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8158,391722,aofInfo,2,server.h.aofInfo,,server.h,struct aofInfo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8159,391730,aofManifest,2,server.h.aofManifest,,server.h,struct aofManifest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8160,392242,keyReference,2,server.h.keyReference,,server.h,struct keyReference,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8161,392256,getKeysResult,2,server.h.getKeysResult,,server.h,struct getKeysResult,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8162,392269,kspec_bs_type,2,server.h.kspec_bs_type,,server.h,enum kspec_bs_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8163,392282,kspec_fk_type,2,server.h.kspec_fk_type,,server.h,enum kspec_fk_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8164,392309,keySpec,2,server.h.keySpec,,server.h,struct keySpec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8165,392313,commandHistory,2,server.h.commandHistory,,server.h,struct commandHistory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8166,392333,redisCommandGroup,2,server.h.redisCommandGroup,,server.h,enum redisCommandGroup,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8167,392410,listTypeIterator,2,server.h.listTypeIterator,,server.h,struct listTypeIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8168,392415,listTypeEntry,2,server.h.listTypeEntry,,server.h,struct listTypeEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8169,392422,setTypeIterator,2,server.h.setTypeIterator,,server.h,struct setTypeIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8170,392430,hashTypeIterator,2,server.h.hashTypeIterator,,server.h,struct hashTypeIterator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8171,392431,io_threads_op,2,server.h.io_threads_op,,server.h,extern int io_threads_op,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8172,392433,server,2,server.h.server,,server.h,struct redisServer server,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8173,392435,shared,2,server.h.shared,,server.h,struct sharedObjectsStruct shared,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8174,392436,objectKeyPointerValueDictType,2,server.h.objectKeyPointerValueDictType,,server.h,dictType objectKeyPointerValueDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8175,392437,objectKeyHeapPointerValueDictType,2,server.h.objectKeyHeapPointerValueDictType,,server.h,dictType objectKeyHeapPointerValueDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8176,392438,setDictType,2,server.h.setDictType,,server.h,dictType setDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8177,392439,BenchmarkDictType,2,server.h.BenchmarkDictType,,server.h,dictType BenchmarkDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8178,392440,zsetDictType,2,server.h.zsetDictType,,server.h,dictType zsetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8179,392441,dbDictType,2,server.h.dbDictType,,server.h,dictType dbDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8180,392442,R_Zero,2,server.h.R_Zero,,server.h,extern double R_Zero,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8181,392443,R_PosInf,2,server.h.R_PosInf,,server.h,extern double R_PosInf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8182,392444,R_NegInf,2,server.h.R_NegInf,,server.h,extern double R_NegInf,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8183,392445,R_Nan,2,server.h.R_Nan,,server.h,extern double R_Nan,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8184,392446,hashDictType,2,server.h.hashDictType,,server.h,dictType hashDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8185,392447,stringSetDictType,2,server.h.stringSetDictType,,server.h,dictType stringSetDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8186,392448,externalStringType,2,server.h.externalStringType,,server.h,dictType externalStringType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8187,392449,sdsHashDictType,2,server.h.sdsHashDictType,,server.h,dictType sdsHashDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8188,392450,dbExpiresDictType,2,server.h.dbExpiresDictType,,server.h,dictType dbExpiresDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8189,392451,modulesDictType,2,server.h.modulesDictType,,server.h,dictType modulesDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8190,392452,sdsReplyDictType,2,server.h.sdsReplyDictType,,server.h,dictType sdsReplyDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8191,392453,modules,2,server.h.modules,,server.h,dict* modules,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8192,393697,list_conv_type,2,server.h.list_conv_type,,server.h,enum list_conv_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8193,394547,Users,2,server.h.Users,,server.h,rax* Users,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8194,394548,DefaultUser,2,server.h.DefaultUser,,server.h,user* DefaultUser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8195,394566,AuthResult,2,server.h.AuthResult,,server.h,enum AuthResult,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8196,394752,zrangespec,2,server.h.zrangespec,,server.h,struct zrangespec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8197,394758,zlexrangespec,2,server.h.zlexrangespec,,server.h,struct zlexrangespec,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8198,395055,lookupSubcommand,2,server.h.lookupSubcommand,,server.h,struct redisCommand* lookupSubcommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8199,395057,lookupCommand,2,server.h.lookupCommand,,server.h,struct redisCommand* lookupCommand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8200,395059,lookupCommandBySdsLogic,2,server.h.lookupCommandBySdsLogic,,server.h,struct redisCommand* lookupCommandBySdsLogic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8201,395061,lookupCommandBySds,2,server.h.lookupCommandBySds,,server.h,struct redisCommand* lookupCommandBySds,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8202,395063,lookupCommandByCStringLogic,2,server.h.lookupCommandByCStringLogic,,server.h,struct redisCommand* lookupCommandByCStringLogic,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8203,395065,lookupCommandByCString,2,server.h.lookupCommandByCString,,server.h,struct redisCommand* lookupCommandByCString,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8204,395067,lookupCommandOrOriginal,2,server.h.lookupCommandOrOriginal,,server.h,struct redisCommand* lookupCommandOrOriginal,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8205,395280,getMemoryOverheadData,2,server.h.getMemoryOverheadData,,server.h,struct redisMemOverhead* getMemoryOverheadData,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8206,395631,configType,2,server.h.configType,,server.h,enum configType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8207,407597,SHA1_CTX,2,sha1.h.SHA1_CTX,,sha1.h,struct SHA1_CTX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8208,407633,k,2,sha256.c.k,,sha256.c,ANY k,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8209,408638,SHA256_CTX,2,sha256.h.SHA256_CTX,,sha256.h,struct SHA256_CTX,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8210,411197,CT_Socket,2,socket.c.CT_Socket,,socket.c,ConnectionType CT_Socket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8211,412286,CT_Socket,2,socket.c.CT_Socket,,socket.c,ConnectionType CT_Socket,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8212,414843,charset,2,sparkline.c.charset,,sparkline.c,char[] charset,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8213,414847,charset_fill,2,sparkline.c.charset_fill,,sparkline.c,char[] charset_fill,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8214,414851,charset_len,2,sparkline.c.charset_len,,sparkline.c,static int charset_len,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8215,414858,label_margin_top,2,sparkline.c.label_margin_top,,sparkline.c,static int label_margin_top,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8216,415411,createSparklineSequence,2,sparkline.h.createSparklineSequence,,sparkline.h,struct sequence* createSparklineSequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8217,416217,check,2,syscheck.c.check,,syscheck.c,struct check,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8218,416218,checks,2,syscheck.c.checks,,syscheck.c,check[] checks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8219,433806,streamAddTrimArgs,2,t_stream.c.streamAddTrimArgs,,t_stream.c,struct streamAddTrimArgs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8220,456035,zrange_type,2,t_zset.c.zrange_type,,t_zset.c,enum zrange_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8221,456580,zsetopsrc,2,t_zset.c.zsetopsrc,,t_zset.c,struct zsetopsrc,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8222,456595,zsetopval,2,t_zset.c.zsetopval,,t_zset.c,struct zsetopval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8223,458638,setAccumulatorDictType,2,t_zset.c.setAccumulatorDictType,,t_zset.c,dictType setAccumulatorDictType,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8224,459899,zrange_direction,2,t_zset.c.zrange_direction,,t_zset.c,enum zrange_direction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8225,459910,zrange_consumer_type,2,t_zset.c.zrange_consumer_type,,t_zset.c,enum zrange_consumer_type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8226,465009,__failed_tests,2,testhelp.h.__failed_tests,,testhelp.h,extern int __failed_tests,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8227,465010,__test_num,2,testhelp.h.__test_num,,testhelp.h,extern int __test_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8228,465617,TrackingTable,2,tracking.c.TrackingTable,,tracking.c,rax* TrackingTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8229,465621,PrefixTable,2,tracking.c.PrefixTable,,tracking.c,rax* PrefixTable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8230,465625,TrackingTableTotalItems,2,tracking.c.TrackingTableTotalItems,,tracking.c,uint64_t TrackingTableTotalItems,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8231,465629,TrackingChannelName,2,tracking.c.TrackingChannelName,,tracking.c,robj* TrackingChannelName,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8232,467609,CT_Unix,2,unix.c.CT_Unix,,unix.c,ConnectionType CT_Unix,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8233,468116,CT_Unix,2,unix.c.CT_Unix,,unix.c,ConnectionType CT_Unix,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8234,471342,ld2string_mode,2,util.h.ld2string_mode,,util.h,enum ld2string_mode,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8235,478180,ziplistEntry,2,ziplist.h.ziplistEntry,,ziplist.h,struct ziplistEntry,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8236,479611,used_memory,2,zmalloc.c.used_memory,,zmalloc.c,size_t used_memory,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8237,15,Users,2,acl.c.Users,,acl.c,rax* Users,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
8238,16,DefaultUser,2,acl.c.DefaultUser,,acl.c,user* DefaultUser,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8239,17,UsersToLoad,2,acl.c.UsersToLoad,,acl.c,list* UsersToLoad,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
8240,18,ACLLog,2,acl.c.ACLLog,,acl.c,list* ACLLog,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8241,19,ACLLogEntryCount,2,acl.c.ACLLogEntryCount,,acl.c,long long ACLLogEntryCount,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8242,23,commandId,2,acl.c.commandId,,acl.c,rax* commandId,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
8243,27,nextid,2,acl.c.nextid,,acl.c,static long unsigned nextid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
8244,34,ACLCommandCategories,2,acl.c.ACLCommandCategories,,acl.c,ACLCategoryItem[] ACLCommandCategories,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
8245,191,ACLUserFlags,2,acl.c.ACLUserFlags,,acl.c,ACLUserFlag[] ACLUserFlags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8246,236,ACLSelectorFlags,2,acl.c.ACLSelectorFlags,,acl.c,ACLSelectorFlags[] ACLSelectorFlags,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8247,281,aclSelector,2,acl.c.aclSelector,,acl.c,struct aclSelector,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8248,614,keyPattern,2,acl.c.keyPattern,,acl.c,struct keyPattern,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8249,5424,aclKeyResultCache,2,acl.c.aclKeyResultCache,,acl.c,struct aclKeyResultCache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8250,14157,evport_debug,2,ae_evport.c.evport_debug,,ae_evport.c,static int evport_debug,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8251,28004,ascii_logo,2,asciilogo.h.ascii_logo,,asciilogo.h,const char* ascii_logo,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
8252,28030,bio_worker_title,2,bio.c.bio_worker_title,,bio.c,char*[] bio_worker_title,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
8253,28037,bio_job_to_worker,2,bio.c.bio_job_to_worker,,bio.c,unsigned int[] bio_job_to_worker,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8254,28057,bio_threads,2,bio.c.bio_threads,,bio.c,static pthread_t[] bio_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
8255,28067,bio_mutex,2,bio.c.bio_mutex,,bio.c,static pthread_mutex_t[] bio_mutex,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
8256,28077,bio_newjob_cond,2,bio.c.bio_newjob_cond,,bio.c,static pthread_cond_t[] bio_newjob_cond,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8257,28087,bio_jobs,2,bio.c.bio_jobs,,bio.c,list*[] bio_jobs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
8258,28097,bio_jobs_counter,2,bio.c.bio_jobs_counter,,bio.c,unsigned longint[4] bio_jobs_counter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
8259,37156,DefaultParserCallbacks,2,call_reply.c.DefaultParserCallbacks,,call_reply.c,const ReplyParserCallbacks DefaultParserCallbacks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
8260,38012,child_info_data,2,childinfo.c.child_info_data,,childinfo.c,struct child_info_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,0,0,1,1,0,0,,0,0,0,0,0,
