12,TYPE_DECL,,acl.c:<global>,NAMESPACE_BLOCK,<global>,1,acl.c,acl.c:<global>,,false,1,<global>,5
31,TYPE_DECL,ACLCommandCategories,,,"struct ACLCategoryItem {
    const char *name;
    uint64_t flag;
}",1,acl.c,ACLCategoryItem,,false,62,ACLCategoryItem,11
188,TYPE_DECL,ACLUserFlags,,,"struct ACLUserFlag {
    const char *name;
    uint64_t flag;
}",1,acl.c,ACLUserFlag,,false,90,ACLUserFlag,14
233,TYPE_DECL,ACLSelectorFlags,,,"struct ACLSelectorFlags {
    const char *name;
    uint64_t flag;
}",1,acl.c,ACLSelectorFlags,,false,103,ACLSelectorFlags,17
264,TYPE_DECL,aclSelector,,,"typedef struct {
    uint32_t flags; /* See SELECTOR_FLAG_* */
    /* The bit in allowed_commands is set if this user has the right to
     * execute this command.
     *
     * If the bit for a given command is NOT set and the command has
     * allowed first-args, Redis will also check allowed_firstargs in order to
     * understand if the command can be executed. */
    uint64_t allowed_commands[USER_COMMAND_BITS_COUNT/64];
    /* allowed_firstargs is used by ACL rules to block access to a command unless a
     * specific argv[1] is given.
     *
     * For each command ID (corresponding to the command bit set in allowed_commands),
     * This array points to an array of SDS strings, terminated by a NULL pointer,
     * with all the first-args that are allowed for this command. When no first-arg
     * matching is used, the field is just set to NULL to avoid allocating
     * USER_COMMAND_BITS_COUNT pointers. */
    sds **allowed_firstargs;
    list *patterns;  /* A list of allow...",1,acl.c,aclSelector,,false,115,aclSelector,20
611,TYPE_DECL,keyPattern,,,"typedef struct {
    int flags; /* The CMD_KEYS_* flags for this key pattern */
    sds pattern; /* The pattern to match keys against */
}",1,acl.c,keyPattern,,false,261,keyPattern,36
5421,TYPE_DECL,aclKeyResultCache,,,"typedef struct {
    int keys_init;
    getKeysResult keys;
}",1,acl.c,aclKeyResultCache,,false,1634,aclKeyResultCache,91
8188,TYPE_DECL,ACLLogEntry,,,"typedef struct ACLLogEntry {
    uint64_t count;     /* Number of times this happened recently. */
    int reason;         /* Reason for denying the command. ACL_DENIED_*. */
    int context;        /* Toplevel, Lua or MULTI/EXEC? ACL_LOG_CTX_*. */
    sds object;         /* The key name or command name. */
    sds username;       /* User the client is authenticated with. */
    mstime_t ctime;     /* Milliseconds time of last update to this entry. */
    sds cinfo;          /* Client info (last client if updated). */
    long long entry_id;         /* The pair (entry_id, timestamp_created) is a unique identifier of this entry 
                                  * in case the node dies and is restarted, it can detect that if it's a new series. */
    mstime_t timestamp_created; /* UNIX time in milliseconds at the time of this entry's creation. */
}",1,acl.c,ACLLogEntry,,false,2501,ACLLogEntry,109
8198,TYPE_DECL,ACLLogEntry,,,"typedef struct ACLLogEntry {
    uint64_t count;     /* Number of times this happened recently. */
    int reason;         /* Reason for denying the command. ACL_DENIED_*. */
    int context;        /* Toplevel, Lua or MULTI/EXEC? ACL_LOG_CTX_*. */
    sds object;         /* The key name or command name. */
    sds username;       /* User the client is authenticated with. */
    mstime_t ctime;     /* Milliseconds time of last update to this entry. */
    sds cinfo;          /* Client info (last client if updated). */
    long long entry_id;         /* The pair (entry_id, timestamp_created) is a unique identifier of this entry 
                                  * in case the node dies and is restarted, it can detect that if it's a new series. */
    mstime_t timestamp_created; /* UNIX time in milliseconds at the time of this entry's creation. */
} ACLLogEntry;",3,acl.c,ACLLogEntry,,false,2512,ACLLogEntry,110
10644,TYPE_DECL,,adlist.c:<global>,NAMESPACE_BLOCK,<global>,1,adlist.c,adlist.c:<global>,,false,1,<global>,4
11709,TYPE_DECL,,adlist.h:<global>,NAMESPACE_BLOCK,<global>,1,adlist.h,adlist.h:<global>,,false,1,<global>,1
11712,TYPE_DECL,listNode,,,"typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
}",1,adlist.h,listNode,,false,36,listNode,1
11713,TYPE_DECL,prev,,,struct listNode,5,adlist.h,listNode.listNode,,false,37,listNode,1
11715,TYPE_DECL,next,,,struct listNode,5,adlist.h,listNode.listNode,,false,38,listNode,3
11718,TYPE_DECL,listNode,,,"typedef struct listNode {
    struct listNode *prev;
    struct listNode *next;
    void *value;
} listNode;",3,adlist.h,listNode,,false,40,listNode,2
11719,TYPE_DECL,listIter,,,"typedef struct listIter {
    listNode *next;
    int direction;
}",1,adlist.h,listIter,,false,42,listIter,3
11722,TYPE_DECL,listIter,,,"typedef struct listIter {
    listNode *next;
    int direction;
} listIter;",3,adlist.h,listIter,,false,45,listIter,4
11723,TYPE_DECL,list,,,"typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
}",1,adlist.h,list,,false,47,list,5
11743,TYPE_DECL,list,,,"typedef struct list {
    listNode *head;
    listNode *tail;
    void *(*dup)(void *ptr);
    void (*free)(void *ptr);
    int (*match)(void *ptr, void *key);
    unsigned long len;
} list;",3,adlist.h,list,,false,54,list,6
11908,TYPE_DECL,,ae.c:<global>,NAMESPACE_BLOCK,<global>,1,ae.c,ae.c:<global>,,false,1,<global>,19
13485,TYPE_DECL,,ae.h:<global>,NAMESPACE_BLOCK,<global>,1,ae.h,ae.h:<global>,,false,1,<global>,2
13488,TYPE_DECL,,,,struct aeEventLoop,1,ae.h,aeEventLoop,,false,63,aeEventLoop,1
13515,TYPE_DECL,aeFileEvent,,,"typedef struct aeFileEvent {
    int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */
    aeFileProc *rfileProc;
    aeFileProc *wfileProc;
    void *clientData;
}",1,ae.h,aeFileEvent,,false,72,aeFileEvent,6
13520,TYPE_DECL,aeFileEvent,,,"typedef struct aeFileEvent {
    int mask; /* one of AE_(READABLE|WRITABLE|BARRIER) */
    aeFileProc *rfileProc;
    aeFileProc *wfileProc;
    void *clientData;
} aeFileEvent;",3,ae.h,aeFileEvent,,false,77,aeFileEvent,7
13521,TYPE_DECL,aeTimeEvent,,,"typedef struct aeTimeEvent {
    long long id; /* time event identifier. */
    monotime when;
    aeTimeProc *timeProc;
    aeEventFinalizerProc *finalizerProc;
    void *clientData;
    struct aeTimeEvent *prev;
    struct aeTimeEvent *next;
    int refcount; /* refcount to prevent timer events from being
  		   * freed in recursive time event calls. */
}",1,ae.h,aeTimeEvent,,false,80,aeTimeEvent,8
13527,TYPE_DECL,prev,,,struct aeTimeEvent,5,ae.h,aeTimeEvent.aeTimeEvent,,false,86,aeTimeEvent,6
13529,TYPE_DECL,next,,,struct aeTimeEvent,5,ae.h,aeTimeEvent.aeTimeEvent,,false,87,aeTimeEvent,8
13532,TYPE_DECL,aeTimeEvent,,,"typedef struct aeTimeEvent {
    long long id; /* time event identifier. */
    monotime when;
    aeTimeProc *timeProc;
    aeEventFinalizerProc *finalizerProc;
    void *clientData;
    struct aeTimeEvent *prev;
    struct aeTimeEvent *next;
    int refcount; /* refcount to prevent timer events from being
  		   * freed in recursive time event calls. */
} aeTimeEvent;",3,ae.h,aeTimeEvent,,false,90,aeTimeEvent,9
13533,TYPE_DECL,aeFiredEvent,,,"typedef struct aeFiredEvent {
    int fd;
    int mask;
}",1,ae.h,aeFiredEvent,,false,93,aeFiredEvent,10
13536,TYPE_DECL,aeFiredEvent,,,"typedef struct aeFiredEvent {
    int fd;
    int mask;
} aeFiredEvent;",3,ae.h,aeFiredEvent,,false,96,aeFiredEvent,11
13537,TYPE_DECL,aeEventLoop,,,"typedef struct aeEventLoop {
    int maxfd;   /* highest file descriptor currently registered */
    int setsize; /* max number of file descriptors tracked */
    long long timeEventNextId;
    aeFileEvent *events; /* Registered events */
    aeFiredEvent *fired; /* Fired events */
    aeTimeEvent *timeEventHead;
    int stop;
    void *apidata; /* This is used for polling API specific data */
    aeBeforeSleepProc *beforesleep;
    aeBeforeSleepProc *aftersleep;
    int flags;
}",1,ae.h,aeEventLoop,,false,99,aeEventLoop,12
13549,TYPE_DECL,aeEventLoop,,,"typedef struct aeEventLoop {
    int maxfd;   /* highest file descriptor currently registered */
    int setsize; /* max number of file descriptors tracked */
    long long timeEventNextId;
    aeFileEvent *events; /* Registered events */
    aeFiredEvent *fired; /* Fired events */
    aeTimeEvent *timeEventHead;
    int stop;
    void *apidata; /* This is used for polling API specific data */
    aeBeforeSleepProc *beforesleep;
    aeBeforeSleepProc *aftersleep;
    int flags;
} aeEventLoop;",3,ae.h,aeEventLoop,,false,111,aeEventLoop,13
13664,TYPE_DECL,,ae_epoll.c:<global>,NAMESPACE_BLOCK,<global>,1,ae_epoll.c,ae_epoll.c:<global>,,false,1,<global>,2
13667,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    int epfd;
    struct epoll_event *events;
}",1,ae_epoll.c,aeApiState,,false,34,aeApiState,1
13669,TYPE_DECL,events,,,struct epoll_event,5,ae_epoll.c,aeApiState.epoll_event,,false,36,epoll_event,2
13671,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    int epfd;
    struct epoll_event *events;
} aeApiState;",3,ae_epoll.c,aeApiState,,false,37,aeApiState,2
14154,TYPE_DECL,,ae_evport.c:<global>,NAMESPACE_BLOCK,<global>,1,ae_evport.c,ae_evport.c:<global>,,false,1,<global>,7
14161,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    int     portfd;                             /* event port */
    uint_t  npending;                           /* # of pending fds */
    int     pending_fds[MAX_EVENT_BATCHSZ];     /* pending fds */
    int     pending_masks[MAX_EVENT_BATCHSZ];   /* pending fds' masks */
}",1,ae_evport.c,aeApiState,,false,67,aeApiState,3
14178,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    int     portfd;                             /* event port */
    uint_t  npending;                           /* # of pending fds */
    int     pending_fds[MAX_EVENT_BATCHSZ];     /* pending fds */
    int     pending_masks[MAX_EVENT_BATCHSZ];   /* pending fds' masks */
} aeApiState;",3,ae_evport.c,aeApiState,,false,72,aeApiState,4
14873,TYPE_DECL,,ae_kqueue.c:<global>,NAMESPACE_BLOCK,<global>,1,ae_kqueue.c,ae_kqueue.c:<global>,,false,1,<global>,4
14876,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    int kqfd;
    struct kevent *events;

    /* Events mask for merge read and write event.
     * To reduce memory consumption, we use 2 bits to store the mask
     * of an event, so that 1 byte will store the mask of 4 events. */
    char *eventsMask; 
}",1,ae_kqueue.c,aeApiState,,false,36,aeApiState,1
14878,TYPE_DECL,events,,,struct kevent,5,ae_kqueue.c,aeApiState.kevent,,false,38,kevent,2
14881,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    int kqfd;
    struct kevent *events;

    /* Events mask for merge read and write event.
     * To reduce memory consumption, we use 2 bits to store the mask
     * of an event, so that 1 byte will store the mask of 4 events. */
    char *eventsMask; 
} aeApiState;",3,ae_kqueue.c,aeApiState,,false,44,aeApiState,2
15516,TYPE_DECL,,ae_select.c:<global>,NAMESPACE_BLOCK,<global>,1,ae_select.c,ae_select.c:<global>,,false,1,<global>,3
15519,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    fd_set rfds, wfds;
    /* We need to have a copy of the fd sets as it's not safe to reuse
     * FD sets after select(). */
    fd_set _rfds, _wfds;
}",1,ae_select.c,aeApiState,,false,35,aeApiState,1
15524,TYPE_DECL,aeApiState,,,"typedef struct aeApiState {
    fd_set rfds, wfds;
    /* We need to have a copy of the fd sets as it's not safe to reuse
     * FD sets after select(). */
    fd_set _rfds, _wfds;
} aeApiState;",3,ae_select.c,aeApiState,,false,40,aeApiState,2
15875,TYPE_DECL,,anet.c:<global>,NAMESPACE_BLOCK,<global>,1,anet.c,anet.c:<global>,,false,1,<global>,20
17937,TYPE_DECL,,anet.h:<global>,NAMESPACE_BLOCK,<global>,1,anet.h,anet.h:<global>,,false,1,<global>,2
18120,TYPE_DECL,,aof.c:<global>,NAMESPACE_BLOCK,<global>,1,aof.c,aof.c:<global>,,false,1,<global>,13
28001,TYPE_DECL,,asciilogo.h:<global>,NAMESPACE_BLOCK,<global>,1,asciilogo.h,asciilogo.h:<global>,,false,1,<global>,1
28018,TYPE_DECL,,atomicvar.h:<global>,NAMESPACE_BLOCK,<global>,1,atomicvar.h,atomicvar.h:<global>,,false,1,<global>,5
28027,TYPE_DECL,,bio.c:<global>,NAMESPACE_BLOCK,<global>,1,bio.c,bio.c:<global>,,false,1,<global>,3
28102,TYPE_DECL,bio_job,,,"typedef union bio_job {
    struct {
        int type; /* Job-type tag. This needs to appear as the first element in all union members. */
    } header;

    /* Job specific arguments.*/
    struct {
        int type;
        int fd; /* Fd for file based background jobs */
        long long offset; /* A job-specific offset, if applicable */
        unsigned need_fsync:1; /* A flag to indicate that a fsync is required before
                                * the file is closed. */
        unsigned need_reclaim_cache:1; /* A flag to indicate that reclaim cache is required before
                                * the file is closed. */
    } fd_args;

    struct {
        int type;
        lazy_free_fn *free_fn; /* Function that will free the provided arguments */
        void *free_args[]; /* List of arguments to be passed to the free function */
    } free_args;
}",1,bio.c,bio_job,,false,89,bio_job,15
28103,TYPE_DECL,header,,,"struct {
        int type; /* Job-type tag. This needs to appear as the first element in all union members. */
    }",5,bio.c,bio_job.header,,false,90,bio_job.header,1
28106,TYPE_DECL,fd_args,,,"struct {
        int type;
        int fd; /* Fd for file based background jobs */
        long long offset; /* A job-specific offset, if applicable */
        unsigned need_fsync:1; /* A flag to indicate that a fsync is required before
                                * the file is closed. */
        unsigned need_reclaim_cache:1; /* A flag to indicate that reclaim cache is required before
                                * the file is closed. */
    }",5,bio.c,bio_job.fd_args,,false,95,bio_job.fd_args,3
28113,TYPE_DECL,free_args,,,"struct {
        int type;
        lazy_free_fn *free_fn; /* Function that will free the provided arguments */
        void *free_args[]; /* List of arguments to be passed to the free function */
    }",5,bio.c,bio_job.free_args,,false,105,bio_job.free_args,5
28123,TYPE_DECL,bio_job,,,"typedef union bio_job {
    struct {
        int type; /* Job-type tag. This needs to appear as the first element in all union members. */
    } header;

    /* Job specific arguments.*/
    struct {
        int type;
        int fd; /* Fd for file based background jobs */
        long long offset; /* A job-specific offset, if applicable */
        unsigned need_fsync:1; /* A flag to indicate that a fsync is required before
                                * the file is closed. */
        unsigned need_reclaim_cache:1; /* A flag to indicate that reclaim cache is required before
                                * the file is closed. */
    } fd_args;

    struct {
        int type;
        lazy_free_fn *free_fn; /* Function that will free the provided arguments */
        void *free_args[]; /* List of arguments to be passed to the free function */
    } free_args;
} bio_job;",3,bio.c,bio_job,,false,110,bio_job,16
29093,TYPE_DECL,,bio.h:<global>,NAMESPACE_BLOCK,<global>,1,bio.h,bio.h:<global>,,false,1,<global>,1
29148,TYPE_DECL,,,,"enum {
    BIO_CLOSE_FILE = 0, /* Deferred close(2) syscall. */
    BIO_AOF_FSYNC,      /* Deferred AOF fsync. */
    BIO_LAZY_FREE,      /* Deferred objects freeing. */
    BIO_CLOSE_AOF,      /* Deferred close for AOF files. */
    BIO_NUM_OPS
}",1,bio.h,anonymous_enum_0,,false,46,anonymous_enum_0,10
29165,TYPE_DECL,,bitops.c:<global>,NAMESPACE_BLOCK,<global>,1,bitops.c,bitops.c:<global>,,false,1,<global>,2
33122,TYPE_DECL,,,,"struct bitfieldOp {
    uint64_t offset;    /* Bitfield offset. */
    int64_t i64;        /* Increment amount (INCRBY) or SET value */
    int opcode;         /* Operation id. */
    int owtype;         /* Overflow type to use. */
    int bits;           /* Integer bitfield bits width. */
    int sign;           /* True if signed, otherwise unsigned op. */
}",1,bitops.c,bitfieldOp,,false,1018,bitfieldOp,19
34037,TYPE_DECL,,blocked.c:<global>,NAMESPACE_BLOCK,<global>,1,blocked.c,blocked.c:<global>,,false,1,<global>,5
36202,TYPE_DECL,,call_reply.c:<global>,NAMESPACE_BLOCK,<global>,1,call_reply.c,call_reply.c:<global>,,false,1,<global>,3
36205,TYPE_DECL,,,,"struct CallReply {
    void *private_data;
    sds original_proto; /* Available only for root reply. */
    const char *proto;
    size_t proto_len;
    int type;       /* REPLY_... */
    int flags;      /* REPLY_FLAG... */
    size_t len;     /* Length of a string, or the number elements in an array. */
    union {
        const char *str; /* String pointer for string and error replies. This
                          * does not need to be freed, always points inside
                          * a reply->proto buffer of the reply object or, in
                          * case of array elements, of parent reply objects. */
        struct {
            const char *str;
            const char *format;
        } verbatim_str;  /* Reply value for verbatim string */
        long long ll;    /* Reply value for integer reply. */
        double d;        /* Reply value for double reply. */
        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribut...",1,call_reply.c,CallReply,,false,42,CallReply,1
36213,TYPE_DECL,val,,,"union {
        const char *str; /* String pointer for string and error replies. This
                          * does not need to be freed, always points inside
                          * a reply->proto buffer of the reply object or, in
                          * case of array elements, of parent reply objects. */
        struct {
            const char *str;
            const char *format;
        } verbatim_str;  /* Reply value for verbatim string */
        long long ll;    /* Reply value for integer reply. */
        double d;        /* Reply value for double reply. */
        struct CallReply *array; /* Array of sub-reply elements. used for set, array, map, and attribute */
    }",5,call_reply.c,CallReply.val,,false,50,CallReply.val,8
36215,TYPE_DECL,verbatim_str,,,"struct {
            const char *str;
            const char *format;
        }",9,call_reply.c,CallReply.val.verbatim_str,,false,55,CallReply.val.verbatim_str,2
36221,TYPE_DECL,array,,,struct CallReply,9,call_reply.c,CallReply.val.CallReply,,false,61,CallReply,6
36225,TYPE_DECL,attribute,,,struct CallReply,5,call_reply.c,CallReply.CallReply,,false,64,CallReply,11
37862,TYPE_DECL,,call_reply.h:<global>,NAMESPACE_BLOCK,<global>,1,call_reply.h,call_reply.h:<global>,,false,1,<global>,2
37865,TYPE_DECL,CallReply,,,typedef struct CallReply,1,call_reply.h,CallReply,,false,35,CallReply,1
37866,TYPE_DECL,CallReply,,,typedef struct CallReply CallReply;,26,call_reply.h,CallReply,,false,35,CallReply,2
38003,TYPE_DECL,,childinfo.c:<global>,NAMESPACE_BLOCK,<global>,1,childinfo.c,childinfo.c:<global>,,false,1,<global>,4
38006,TYPE_DECL,child_info_data,,,"typedef struct {
    size_t keys;
    size_t cow;
    monotime cow_updated;
    double progress;
    childInfoType information_type; /* Type of information */
}",1,childinfo.c,child_info_data,,false,34,child_info_data,1
38546,TYPE_DECL,,cli_commands.c:<global>,NAMESPACE_BLOCK,<global>,1,cli_commands.c,cli_commands.c:<global>,,false,1,<global>,4
38555,TYPE_DECL,,cli_commands.h:<global>,NAMESPACE_BLOCK,<global>,1,cli_commands.h,cli_commands.h:<global>,,false,1,<global>,3
38558,TYPE_DECL,cliCommandArg,,,"typedef struct cliCommandArg {
    char *name;
    redisCommandArgType type;
    char *token;
    char *since;
    int flags;
    int numsubargs;
    struct cliCommandArg *subargs;
    const char *display_text;

    /*
     * For use at runtime.
     * Fields used to keep track of input word matches for command-line hinting.
     */
    int matched;  /* How many input words have been matched by this argument? */
    int matched_token;  /* Has the token been matched? */
    int matched_name;  /* Has the name been matched? */
    int matched_all;  /* Has the whole argument been consumed (no hint needed)? */
}",1,cli_commands.h,cliCommandArg,,false,12,cliCommandArg,1
38565,TYPE_DECL,subargs,,,struct cliCommandArg,5,cli_commands.h,cliCommandArg.cliCommandArg,,false,19,cliCommandArg,7
38572,TYPE_DECL,cliCommandArg,,,"typedef struct cliCommandArg {
    char *name;
    redisCommandArgType type;
    char *token;
    char *since;
    int flags;
    int numsubargs;
    struct cliCommandArg *subargs;
    const char *display_text;

    /*
     * For use at runtime.
     * Fields used to keep track of input word matches for command-line hinting.
     */
    int matched;  /* How many input words have been matched by this argument? */
    int matched_token;  /* Has the token been matched? */
    int matched_name;  /* Has the name been matched? */
    int matched_all;  /* Has the whole argument been consumed (no hint needed)? */
} cliCommandArg;",3,cli_commands.h,cliCommandArg,,false,30,cliCommandArg,2
38573,TYPE_DECL,,,,"struct commandDocs {
    char *name;
    char *summary;
    char *group;
    char *since;
    int numargs;
    cliCommandArg *args; /* An array of the command arguments. */
    struct commandDocs *subcommands;
    char *params; /* A string describing the syntax of the command arguments. */
}",1,cli_commands.h,commandDocs,,false,33,commandDocs,3
38580,TYPE_DECL,subcommands,,,struct commandDocs,5,cli_commands.h,commandDocs.commandDocs,,false,40,commandDocs,7
38583,TYPE_DECL,redisCommandTable,,,extern struct commandDocs,1,cli_commands.h,commandDocs,,false,44,commandDocs,4
38618,TYPE_DECL,,cli_common.c:<global>,NAMESPACE_BLOCK,<global>,1,cli_common.c,cli_common.c:<global>,,false,1,<global>,16
39443,TYPE_DECL,,cli_common.h:<global>,NAMESPACE_BLOCK,<global>,1,cli_common.h,cli_common.h:<global>,,false,1,<global>,3
39446,TYPE_DECL,cliSSLconfig,,,"typedef struct cliSSLconfig {
    /* Requested SNI, or NULL */
    char *sni;
    /* CA Certificate file, or NULL */
    char *cacert;
    /* Directory where trusted CA certificates are stored, or NULL */
    char *cacertdir;
    /* Skip server certificate verification. */
    int skip_cert_verify;
    /* Client certificate to authenticate with, or NULL */
    char *cert;
    /* Private key file to authenticate with, or NULL */
    char *key;
    /* Preferred cipher list, or NULL (applies only to <= TLSv1.2) */
    char* ciphers;
    /* Preferred ciphersuites list, or NULL (applies only to TLSv1.3) */
    char* ciphersuites;
}",1,cli_common.h,cliSSLconfig,,false,7,cliSSLconfig,1
39455,TYPE_DECL,cliSSLconfig,,,"typedef struct cliSSLconfig {
    /* Requested SNI, or NULL */
    char *sni;
    /* CA Certificate file, or NULL */
    char *cacert;
    /* Directory where trusted CA certificates are stored, or NULL */
    char *cacertdir;
    /* Skip server certificate verification. */
    int skip_cert_verify;
    /* Client certificate to authenticate with, or NULL */
    char *cert;
    /* Private key file to authenticate with, or NULL */
    char *key;
    /* Preferred cipher list, or NULL (applies only to <= TLSv1.2) */
    char* ciphers;
    /* Preferred ciphersuites list, or NULL (applies only to TLSv1.3) */
    char* ciphersuites;
} cliSSLconfig;",3,cli_common.h,cliSSLconfig,,false,24,cliSSLconfig,2
39456,TYPE_DECL,cliConnInfo,,,"typedef struct cliConnInfo {
    char *hostip;
    int hostport;
    int input_dbnum;
    char *auth;
    char *user;
}",1,cli_common.h,cliConnInfo,,false,28,cliConnInfo,3
39462,TYPE_DECL,cliConnInfo,,,"typedef struct cliConnInfo {
    char *hostip;
    int hostport;
    int input_dbnum;
    char *auth;
    char *user;
} cliConnInfo;",3,cli_common.h,cliConnInfo,,false,34,cliConnInfo,4
39547,TYPE_DECL,,cluster.c:<global>,NAMESPACE_BLOCK,<global>,1,cluster.c,cluster.c:<global>,,false,1,<global>,14
39988,TYPE_DECL,auxFieldHandler,,,"typedef struct {
    char *field;
    aux_value_setter *setter;
    aux_value_getter *getter;
    aux_value_present *isPresent;
}",1,cluster.c,auxFieldHandler,,false,197,auxFieldHandler,71
39994,TYPE_DECL,,,,"typedef enum {
    af_shard_id,
    af_human_nodename,
    af_tcp_port,
    af_tls_port,
    af_count,
}",1,cluster.c,auxFieldIndex,,false,205,auxFieldIndex,73
40440,TYPE_DECL,clusterMsgSendBlock,,,"typedef struct {
    size_t totlen; /* Total length of this block including the message */
    int refcount;  /* Number of cluster link send msg queues containing the message */
    clusterMsg msg;
}",1,cluster.c,clusterMsgSendBlock,,false,322,clusterMsgSendBlock,91
57169,TYPE_DECL,,,,"struct redisNodeFlags {
    uint16_t flag;
    char *name;
}",1,cluster.c,redisNodeFlags,,false,5168,redisNodeFlags,214
57172,TYPE_DECL,redisNodeFlagsTable,,,static struct redisNodeFlags,1,cluster.c,redisNodeFlags,,false,5173,redisNodeFlags,215
63290,TYPE_DECL,migrateCachedSocket,,,"typedef struct migrateCachedSocket {
    connection *conn;
    long last_dbid;
    time_t last_use_time;
}",1,cluster.c,migrateCachedSocket,,false,6685,migrateCachedSocket,245
63294,TYPE_DECL,migrateCachedSocket,,,"typedef struct migrateCachedSocket {
    connection *conn;
    long last_dbid;
    time_t last_use_time;
} migrateCachedSocket;",3,cluster.c,migrateCachedSocket,,false,6689,migrateCachedSocket,246
66716,TYPE_DECL,,cluster.h:<global>,NAMESPACE_BLOCK,<global>,1,cluster.h,cluster.h:<global>,,false,1,<global>,1
66719,TYPE_DECL,,,,struct clusterNode,1,cluster.h,clusterNode,,false,32,clusterNode,1
66720,TYPE_DECL,clusterLink,,,"typedef struct clusterLink {
    mstime_t ctime;             /* Link creation time */
    connection *conn;           /* Connection to remote node */
    list *send_msg_queue;        /* List of messages to be sent */
    size_t head_msg_send_offset; /* Number of bytes already sent of message at head of queue */
    unsigned long long send_msg_queue_mem; /* Memory in bytes used by message queue */
    char *rcvbuf;               /* Packet reception buffer */
    size_t rcvbuf_len;          /* Used size of rcvbuf */
    size_t rcvbuf_alloc;        /* Allocated size of rcvbuf */
    struct clusterNode *node;   /* Node related to this link. Initialized to NULL when unknown */
    int inbound;                /* 1 if this link is an inbound link accepted from the related node */
}",1,cluster.h,clusterLink,,false,35,clusterLink,2
66729,TYPE_DECL,node,,,struct clusterNode,5,cluster.h,clusterLink.clusterNode,,false,44,clusterNode,9
66732,TYPE_DECL,clusterLink,,,"typedef struct clusterLink {
    mstime_t ctime;             /* Link creation time */
    connection *conn;           /* Connection to remote node */
    list *send_msg_queue;        /* List of messages to be sent */
    size_t head_msg_send_offset; /* Number of bytes already sent of message at head of queue */
    unsigned long long send_msg_queue_mem; /* Memory in bytes used by message queue */
    char *rcvbuf;               /* Packet reception buffer */
    size_t rcvbuf_len;          /* Used size of rcvbuf */
    size_t rcvbuf_alloc;        /* Allocated size of rcvbuf */
    struct clusterNode *node;   /* Node related to this link. Initialized to NULL when unknown */
    int inbound;                /* 1 if this link is an inbound link accepted from the related node */
} clusterLink;",3,cluster.h,clusterLink,,false,46,clusterLink,3
66733,TYPE_DECL,clusterNodeFailReport,,,"typedef struct clusterNodeFailReport {
    struct clusterNode *node;  /* Node reporting the failure condition. */
    mstime_t time;             /* Time of the last report from this node. */
}",1,cluster.h,clusterNodeFailReport,,false,112,clusterNodeFailReport,4
66734,TYPE_DECL,node,,,struct clusterNode,5,cluster.h,clusterNodeFailReport.clusterNode,,false,113,clusterNode,1
66737,TYPE_DECL,clusterNodeFailReport,,,"typedef struct clusterNodeFailReport {
    struct clusterNode *node;  /* Node reporting the failure condition. */
    mstime_t time;             /* Time of the last report from this node. */
} clusterNodeFailReport;",3,cluster.h,clusterNodeFailReport,,false,115,clusterNodeFailReport,5
66738,TYPE_DECL,clusterNode,,,"typedef struct clusterNode {
    mstime_t ctime; /* Node object creation time. */
    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
    char shard_id[CLUSTER_NAMELEN]; /* shard id, hex string, sha1-size */
    int flags;      /* CLUSTER_NODE_... */
    uint64_t configEpoch; /* Last configEpoch observed for this node */
    unsigned char slots[CLUSTER_SLOTS/8]; /* slots handled by this node */
    uint16_t *slot_info_pairs; /* Slots info represented as (start/end) pair (consecutive index). */
    int slot_info_pairs_count; /* Used number of slots in slot_info_pairs */
    int numslots;   /* Number of slots handled by this node */
    int numslaves;  /* Number of slave nodes, if this is a master */
    struct clusterNode **slaves; /* pointers to slave nodes */
    struct clusterNode *slaveof; /* pointer to the master node. Note that it
                                    may be NULL even if the node is a slave
                                    if we don't have t...",1,cluster.h,clusterNode,,false,117,clusterNode,6
66749,TYPE_DECL,slaves,,,struct clusterNode,5,cluster.h,clusterNode.clusterNode,,false,128,clusterNode,11
66751,TYPE_DECL,slaveof,,,struct clusterNode,5,cluster.h,clusterNode.clusterNode,,false,129,clusterNode,13
66791,TYPE_DECL,clusterNode,,,"typedef struct clusterNode {
    mstime_t ctime; /* Node object creation time. */
    char name[CLUSTER_NAMELEN]; /* Node name, hex string, sha1-size */
    char shard_id[CLUSTER_NAMELEN]; /* shard id, hex string, sha1-size */
    int flags;      /* CLUSTER_NODE_... */
    uint64_t configEpoch; /* Last configEpoch observed for this node */
    unsigned char slots[CLUSTER_SLOTS/8]; /* slots handled by this node */
    uint16_t *slot_info_pairs; /* Slots info represented as (start/end) pair (consecutive index). */
    int slot_info_pairs_count; /* Used number of slots in slot_info_pairs */
    int numslots;   /* Number of slots handled by this node */
    int numslaves;  /* Number of slave nodes, if this is a master */
    struct clusterNode **slaves; /* pointers to slave nodes */
    struct clusterNode *slaveof; /* pointer to the master node. Note that it
                                    may be NULL even if the node is a slave
                                    if we don't have t...",3,cluster.h,clusterNode,,false,151,clusterNode,7
66792,TYPE_DECL,slotToKeys,,,"typedef struct slotToKeys {
    uint64_t count;             /* Number of keys in the slot. */
    dictEntry *head;            /* The first key-value entry in the slot. */
}",1,cluster.h,slotToKeys,,false,155,slotToKeys,8
66795,TYPE_DECL,slotToKeys,,,"typedef struct slotToKeys {
    uint64_t count;             /* Number of keys in the slot. */
    dictEntry *head;            /* The first key-value entry in the slot. */
} slotToKeys;",3,cluster.h,slotToKeys,,false,158,slotToKeys,9
66796,TYPE_DECL,,,,"struct clusterSlotToKeyMapping {
    slotToKeys by_slot[CLUSTER_SLOTS];
}",1,cluster.h,clusterSlotToKeyMapping,,false,161,clusterSlotToKeyMapping,10
66806,TYPE_DECL,clusterDictEntryMetadata,,,"typedef struct clusterDictEntryMetadata {
    dictEntry *prev;            /* Prev entry with key in the same slot */
    dictEntry *next;            /* Next entry with key in the same slot */
}",1,cluster.h,clusterDictEntryMetadata,,false,167,clusterDictEntryMetadata,11
66809,TYPE_DECL,clusterDictEntryMetadata,,,"typedef struct clusterDictEntryMetadata {
    dictEntry *prev;            /* Prev entry with key in the same slot */
    dictEntry *next;            /* Next entry with key in the same slot */
} clusterDictEntryMetadata;",3,cluster.h,clusterDictEntryMetadata,,false,170,clusterDictEntryMetadata,12
66810,TYPE_DECL,clusterDictMetadata,,,"typedef struct {
    redisDb *db;                /* A link back to the db this dict belongs to */
}",1,cluster.h,clusterDictMetadata,,false,172,clusterDictMetadata,13
66813,TYPE_DECL,clusterState,,,"typedef struct clusterState {
    clusterNode *myself;  /* This node */
    uint64_t currentEpoch;
    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */
    int size;             /* Num of master nodes with at least one slot */
    dict *nodes;          /* Hash table of name -> clusterNode structures */
    dict *shards;         /* Hash table of shard_id -> list (of nodes) structures */
    dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */
    clusterNode *migrating_slots_to[CLUSTER_SLOTS];
    clusterNode *importing_slots_from[CLUSTER_SLOTS];
    clusterNode *slots[CLUSTER_SLOTS];
    rax *slots_to_channels;
    /* The following fields are used to take the slave state on elections. */
    mstime_t failover_auth_time; /* Time of previous or next election. */
    int failover_auth_count;    /* Number of votes received so far. */
    int failover_auth_sent;     /* True if we already asked for votes. */
    int failover_auth_rank;     /* This slave rank for...",1,cluster.h,clusterState,,false,176,clusterState,15
66872,TYPE_DECL,clusterState,,,"typedef struct clusterState {
    clusterNode *myself;  /* This node */
    uint64_t currentEpoch;
    int state;            /* CLUSTER_OK, CLUSTER_FAIL, ... */
    int size;             /* Num of master nodes with at least one slot */
    dict *nodes;          /* Hash table of name -> clusterNode structures */
    dict *shards;         /* Hash table of shard_id -> list (of nodes) structures */
    dict *nodes_black_list; /* Nodes we don't re-add for a few seconds. */
    clusterNode *migrating_slots_to[CLUSTER_SLOTS];
    clusterNode *importing_slots_from[CLUSTER_SLOTS];
    clusterNode *slots[CLUSTER_SLOTS];
    rax *slots_to_channels;
    /* The following fields are used to take the slave state on elections. */
    mstime_t failover_auth_time; /* Time of previous or next election. */
    int failover_auth_count;    /* Number of votes received so far. */
    int failover_auth_sent;     /* True if we already asked for votes. */
    int failover_auth_rank;     /* This slave rank for...",3,cluster.h,clusterState,,false,223,clusterState,16
66873,TYPE_DECL,clusterMsgDataGossip,,,"typedef struct {
    char nodename[CLUSTER_NAMELEN];
    uint32_t ping_sent;
    uint32_t pong_received;
    char ip[NET_IP_STR_LEN];  /* IP address last time it was seen */
    uint16_t port;              /* primary port last time it was seen */
    uint16_t cport;             /* cluster port last time it was seen */
    uint16_t flags;             /* node->flags copy */
    uint16_t pport;             /* secondary port last time it was seen */
    uint16_t notused1;
}",1,cluster.h,clusterMsgDataGossip,,false,230,clusterMsgDataGossip,17
66894,TYPE_DECL,clusterMsgDataFail,,,"typedef struct {
    char nodename[CLUSTER_NAMELEN];
}",1,cluster.h,clusterMsgDataFail,,false,242,clusterMsgDataFail,19
66905,TYPE_DECL,clusterMsgDataPublish,,,"typedef struct {
    uint32_t channel_len;
    uint32_t message_len;
    unsigned char bulk_data[8]; /* 8 bytes just as placeholder. */
}",1,cluster.h,clusterMsgDataPublish,,false,246,clusterMsgDataPublish,21
66916,TYPE_DECL,clusterMsgDataUpdate,,,"typedef struct {
    uint64_t configEpoch; /* Config epoch of the specified instance. */
    char nodename[CLUSTER_NAMELEN]; /* Name of the slots owner. */
    unsigned char slots[CLUSTER_SLOTS/8]; /* Slots bitmap. */
}",1,cluster.h,clusterMsgDataUpdate,,false,252,clusterMsgDataUpdate,23
66935,TYPE_DECL,clusterMsgModule,,,"typedef struct {
    uint64_t module_id;     /* ID of the sender module. */
    uint32_t len;           /* ID of the sender module. */
    uint8_t type;           /* Type from 0 to 255. */
    unsigned char bulk_data[3]; /* 3 bytes just as placeholder. */
}",1,cluster.h,clusterMsgModule,,false,258,clusterMsgModule,25
66947,TYPE_DECL,,,,"typedef enum {
    CLUSTERMSG_EXT_TYPE_HOSTNAME,
    CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME,
    CLUSTERMSG_EXT_TYPE_FORGOTTEN_NODE,
    CLUSTERMSG_EXT_TYPE_SHARDID,
}",1,cluster.h,clusterMsgPingtypes,,false,268,clusterMsgPingtypes,27
66953,TYPE_DECL,clusterMsgPingExtHostname,,,"typedef struct {
    char hostname[1]; /* The announced hostname, ends with \0. */
}",1,cluster.h,clusterMsgPingExtHostname,,false,278,clusterMsgPingExtHostname,29
66962,TYPE_DECL,clusterMsgPingExtHumanNodename,,,"typedef struct {
    char human_nodename[1]; /* The announced nodename, ends with \0. */
}",1,cluster.h,clusterMsgPingExtHumanNodename,,false,282,clusterMsgPingExtHumanNodename,31
66971,TYPE_DECL,clusterMsgPingExtForgottenNode,,,"typedef struct {
    char name[CLUSTER_NAMELEN]; /* Node name. */
    uint64_t ttl; /* Remaining time to blacklist the node, in seconds. */
}",1,cluster.h,clusterMsgPingExtForgottenNode,,false,286,clusterMsgPingExtForgottenNode,33
66984,TYPE_DECL,clusterMsgPingExtShardId,,,"typedef struct {
    char shard_id[CLUSTER_NAMELEN]; /* The shard_id, 40 bytes fixed. */
}",1,cluster.h,clusterMsgPingExtShardId,,false,293,clusterMsgPingExtShardId,36
66995,TYPE_DECL,clusterMsgPingExt,,,"typedef struct {
    uint32_t length; /* Total length of this extension message (including this header) */
    uint16_t type; /* Type of this extension message (see clusterMsgPingExtTypes) */
    uint16_t unused; /* 16 bits of padding to make this structure 8 byte aligned. */
    union {
        clusterMsgPingExtHostname hostname;
	clusterMsgPingExtHumanNodename human_nodename;
        clusterMsgPingExtForgottenNode forgotten_node;
        clusterMsgPingExtShardId shard_id;
    } ext[]; /* Actual extension information, formatted so that the data is 8 
              * byte aligned, regardless of its content. */
}",1,cluster.h,clusterMsgPingExt,,false,297,clusterMsgPingExt,38
66999,TYPE_DECL,ext,,,"union {
        clusterMsgPingExtHostname hostname;
	clusterMsgPingExtHumanNodename human_nodename;
        clusterMsgPingExtForgottenNode forgotten_node;
        clusterMsgPingExtShardId shard_id;
    }",5,cluster.h,clusterMsgPingExt.ext,,false,301,clusterMsgPingExt.ext,4
67011,TYPE_DECL,,,,"union clusterMsgData {
    /* PING, MEET and PONG */
    struct {
        /* Array of N clusterMsgDataGossip structures */
        clusterMsgDataGossip gossip[1];
        /* Extension data that can optionally be sent for ping/meet/pong
         * messages. We can't explicitly define them here though, since
         * the gossip array isn't the real length of the gossip data. */
    } ping;

    /* FAIL */
    struct {
        clusterMsgDataFail about;
    } fail;

    /* PUBLISH */
    struct {
        clusterMsgDataPublish msg;
    } publish;

    /* UPDATE */
    struct {
        clusterMsgDataUpdate nodecfg;
    } update;

    /* MODULE */
    struct {
        clusterMsgModule msg;
    } module;
}",1,cluster.h,clusterMsgData,,false,310,clusterMsgData,40
67012,TYPE_DECL,ping,,,"struct {
        /* Array of N clusterMsgDataGossip structures */
        clusterMsgDataGossip gossip[1];
        /* Extension data that can optionally be sent for ping/meet/pong
         * messages. We can't explicitly define them here though, since
         * the gossip array isn't the real length of the gossip data. */
    }",5,cluster.h,clusterMsgData.ping,,false,312,clusterMsgData.ping,1
67021,TYPE_DECL,fail,,,"struct {
        clusterMsgDataFail about;
    }",5,cluster.h,clusterMsgData.fail,,false,321,clusterMsgData.fail,3
67024,TYPE_DECL,publish,,,"struct {
        clusterMsgDataPublish msg;
    }",5,cluster.h,clusterMsgData.publish,,false,326,clusterMsgData.publish,5
67027,TYPE_DECL,update,,,"struct {
        clusterMsgDataUpdate nodecfg;
    }",5,cluster.h,clusterMsgData.update,,false,331,clusterMsgData.update,7
67030,TYPE_DECL,module,,,"struct {
        clusterMsgModule msg;
    }",5,cluster.h,clusterMsgData.module,,false,336,clusterMsgData.module,9
67033,TYPE_DECL,clusterMsg,,,"typedef struct {
    char sig[4];        /* Signature ""RCmb"" (Redis Cluster message bus). */
    uint32_t totlen;    /* Total length of this message */
    uint16_t ver;       /* Protocol version, currently set to 1. */
    uint16_t port;      /* Primary port number (TCP or TLS). */
    uint16_t type;      /* Message type */
    uint16_t count;     /* Only used for some kind of messages. */
    uint64_t currentEpoch;  /* The epoch accordingly to the sending node. */
    uint64_t configEpoch;   /* The config epoch if it's a master, or the last
                               epoch advertised by its master if it is a
                               slave. */
    uint64_t offset;    /* Master replication offset if node is a master or
                           processed replication offset if node is a slave. */
    char sender[CLUSTER_NAMELEN]; /* Name of the sender node */
    unsigned char myslots[CLUSTER_SLOTS/8];
    char slaveof[CLUSTER_NAMELEN];
    char myip[NET_IP_STR_LEN];    /*...",1,cluster.h,clusterMsg,,false,343,clusterMsg,41
67054,TYPE_DECL,data,,,union clusterMsgData,5,cluster.h,clusterMsg.clusterMsgData,,false,368,clusterMsgData,21
67302,TYPE_DECL,,commands.c:<global>,NAMESPACE_BLOCK,<global>,1,commands.c,commands.c:<global>,,false,1,<global>,5
67307,TYPE_DECL,,commands.h:<global>,NAMESPACE_BLOCK,<global>,1,commands.h,commands.h:<global>,,false,1,<global>,1
67310,TYPE_DECL,,,,"typedef enum {
    ARG_TYPE_STRING,
    ARG_TYPE_INTEGER,
    ARG_TYPE_DOUBLE,
    ARG_TYPE_KEY, /* A string, but represents a keyname */
    ARG_TYPE_PATTERN,
    ARG_TYPE_UNIX_TIME,
    ARG_TYPE_PURE_TOKEN,
    ARG_TYPE_ONEOF, /* Has subargs */
    ARG_TYPE_BLOCK /* Has subargs */
}",1,commands.h,redisCommandArgType,,false,5,redisCommandArgType,1
67321,TYPE_DECL,redisCommandArg,,,"typedef struct redisCommandArg {
    const char *name;
    redisCommandArgType type;
    int key_spec_index;
    const char *token;
    const char *summary;
    const char *since;
    int flags;
    const char *deprecated_since;
    int num_args;
    struct redisCommandArg *subargs;
    const char *display_text;
}",1,commands.h,redisCommandArg,,false,23,redisCommandArg,3
67331,TYPE_DECL,subargs,,,struct redisCommandArg,5,commands.h,redisCommandArg.redisCommandArg,,false,33,redisCommandArg,10
67334,TYPE_DECL,redisCommandArg,,,"typedef struct redisCommandArg {
    const char *name;
    redisCommandArgType type;
    int key_spec_index;
    const char *token;
    const char *summary;
    const char *since;
    int flags;
    const char *deprecated_since;
    int num_args;
    struct redisCommandArg *subargs;
    const char *display_text;
} redisCommandArg;",3,commands.h,redisCommandArg,,false,35,redisCommandArg,4
67362,TYPE_DECL,,config.c:<global>,NAMESPACE_BLOCK,<global>,1,config.c,config.c:<global>,,false,1,<global>,11
67365,TYPE_DECL,deprecatedConfig,,,"typedef struct deprecatedConfig {
    const char *name;
    const int argc_min;
    const int argc_max;
}",1,config.c,deprecatedConfig,,false,47,deprecatedConfig,1
67369,TYPE_DECL,deprecatedConfig,,,"typedef struct deprecatedConfig {
    const char *name;
    const int argc_min;
    const int argc_max;
} deprecatedConfig;",3,config.c,deprecatedConfig,,false,51,deprecatedConfig,2
67809,TYPE_DECL,boolConfigData,,,"typedef struct boolConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
}",1,config.c,boolConfigData,,false,185,boolConfigData,35
67818,TYPE_DECL,boolConfigData,,,"typedef struct boolConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
} boolConfigData;",3,config.c,boolConfigData,,false,189,boolConfigData,36
67819,TYPE_DECL,stringConfigData,,,"typedef struct stringConfigData {
    char **config; /* Pointer to the server config this value is stored in. */
    const char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(char* val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty strings should
                                  be stored as a NULL value. */
}",1,config.c,stringConfigData,,false,191,stringConfigData,37
67829,TYPE_DECL,stringConfigData,,,"typedef struct stringConfigData {
    char **config; /* Pointer to the server config this value is stored in. */
    const char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(char* val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty strings should
                                  be stored as a NULL value. */
} stringConfigData;",3,config.c,stringConfigData,,false,197,stringConfigData,38
67830,TYPE_DECL,sdsConfigData,,,"typedef struct sdsConfigData {
    sds *config; /* Pointer to the server config this value is stored in. */
    char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(sds val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty SDS strings should
                                  be stored as a NULL value. */
}",1,config.c,sdsConfigData,,false,199,sdsConfigData,39
67840,TYPE_DECL,sdsConfigData,,,"typedef struct sdsConfigData {
    sds *config; /* Pointer to the server config this value is stored in. */
    char *default_value; /* Default value of the config on rewrite. */
    int (*is_valid_fn)(sds val, const char **err); /* Optional function to check validity of new value (generic doc above) */
    int convert_empty_to_null; /* Boolean indicating if empty SDS strings should
                                  be stored as a NULL value. */
} sdsConfigData;",3,config.c,sdsConfigData,,false,205,sdsConfigData,40
67841,TYPE_DECL,enumConfigData,,,"typedef struct enumConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    configEnum *enum_value; /* The underlying enum type this data represents */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
}",1,config.c,enumConfigData,,false,207,enumConfigData,41
67851,TYPE_DECL,enumConfigData,,,"typedef struct enumConfigData {
    int *config; /* The pointer to the server config this value is stored in */
    configEnum *enum_value; /* The underlying enum type this data represents */
    int default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(int val, const char **err); /* Optional function to check validity of new value (generic doc above) */
} enumConfigData;",3,config.c,enumConfigData,,false,212,enumConfigData,42
67852,TYPE_DECL,numericType,,,"typedef enum numericType {
    NUMERIC_TYPE_INT,
    NUMERIC_TYPE_UINT,
    NUMERIC_TYPE_LONG,
    NUMERIC_TYPE_ULONG,
    NUMERIC_TYPE_LONG_LONG,
    NUMERIC_TYPE_ULONG_LONG,
    NUMERIC_TYPE_SIZE_T,
    NUMERIC_TYPE_SSIZE_T,
    NUMERIC_TYPE_OFF_T,
    NUMERIC_TYPE_TIME_T,
}",1,config.c,numericType,,false,214,numericType,43
67863,TYPE_DECL,numericType,,,"typedef enum numericType {
    NUMERIC_TYPE_INT,
    NUMERIC_TYPE_UINT,
    NUMERIC_TYPE_LONG,
    NUMERIC_TYPE_ULONG,
    NUMERIC_TYPE_LONG_LONG,
    NUMERIC_TYPE_ULONG_LONG,
    NUMERIC_TYPE_SIZE_T,
    NUMERIC_TYPE_SSIZE_T,
    NUMERIC_TYPE_OFF_T,
    NUMERIC_TYPE_TIME_T,
} numericType;",3,config.c,numericType,,false,225,numericType,44
67864,TYPE_DECL,numericConfigData,,,"typedef struct numericConfigData {
    union {
        int *i;
        unsigned int *ui;
        long *l;
        unsigned long *ul;
        long long *ll;
        unsigned long long *ull;
        size_t *st;
        ssize_t *sst;
        off_t *ot;
        time_t *tt;
    } config; /* The pointer to the numeric config this value is stored in */
    unsigned int flags;
    numericType numeric_type; /* An enum indicating the type of this value */
    long long lower_bound; /* The lower bound of this numeric value */
    long long upper_bound; /* The upper bound of this numeric value */
    long long default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(long long val, const char **err); /* Optional function to check validity of new value (generic doc above) */
}",1,config.c,numericConfigData,,false,227,numericConfigData,45
67865,TYPE_DECL,config,,,"union {
        int *i;
        unsigned int *ui;
        long *l;
        unsigned long *ul;
        long long *ll;
        unsigned long long *ull;
        size_t *st;
        ssize_t *sst;
        off_t *ot;
        time_t *tt;
    }",5,config.c,numericConfigData.config,,false,228,numericConfigData.config,1
67888,TYPE_DECL,numericConfigData,,,"typedef struct numericConfigData {
    union {
        int *i;
        unsigned int *ui;
        long *l;
        unsigned long *ul;
        long long *ll;
        unsigned long long *ull;
        size_t *st;
        ssize_t *sst;
        off_t *ot;
        time_t *tt;
    } config; /* The pointer to the numeric config this value is stored in */
    unsigned int flags;
    numericType numeric_type; /* An enum indicating the type of this value */
    long long lower_bound; /* The lower bound of this numeric value */
    long long upper_bound; /* The upper bound of this numeric value */
    long long default_value; /* The default value of the config on rewrite */
    int (*is_valid_fn)(long long val, const char **err); /* Optional function to check validity of new value (generic doc above) */
} numericConfigData;",3,config.c,numericConfigData,,false,246,numericConfigData,46
67889,TYPE_DECL,typeData,,,"typedef union typeData {
    boolConfigData yesno;
    stringConfigData string;
    sdsConfigData sds;
    enumConfigData enumd;
    numericConfigData numeric;
}",1,config.c,typeData,,false,248,typeData,47
67895,TYPE_DECL,typeData,,,"typedef union typeData {
    boolConfigData yesno;
    stringConfigData string;
    sdsConfigData sds;
    enumConfigData enumd;
    numericConfigData numeric;
} typeData;",3,config.c,typeData,,false,254,typeData,48
67896,TYPE_DECL,standardConfig,,,typedef struct standardConfig,1,config.c,standardConfig,,false,256,standardConfig,49
67897,TYPE_DECL,standardConfig,,,typedef struct standardConfig standardConfig;,31,config.c,standardConfig,,false,256,standardConfig,50
67903,TYPE_DECL,typeInterface,,,"typedef struct typeInterface {
    /* Called on server start, to init the server with default value */
    void (*init)(standardConfig *config);
    /* Called on server startup and CONFIG SET, returns 1 on success,
     * 2 meaning no actual change done, 0 on error and can set a verbose err
     * string */
    int (*set)(standardConfig *config, sds *argv, int argc, const char **err);
    /* Optional: called after `set()` to apply the config change. Used only in
     * the context of CONFIG SET. Returns 1 on success, 0 on failure.
     * Optionally set err to a static error string. */
    apply_fn apply;
    /* Called on CONFIG GET, returns sds to be used in reply */
    sds (*get)(standardConfig *config);
    /* Called on CONFIG REWRITE, required to rewrite the config state */
    void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);
}",1,config.c,typeInterface,,false,259,typeInterface,52
67930,TYPE_DECL,typeInterface,,,"typedef struct typeInterface {
    /* Called on server start, to init the server with default value */
    void (*init)(standardConfig *config);
    /* Called on server startup and CONFIG SET, returns 1 on success,
     * 2 meaning no actual change done, 0 on error and can set a verbose err
     * string */
    int (*set)(standardConfig *config, sds *argv, int argc, const char **err);
    /* Optional: called after `set()` to apply the config change. Used only in
     * the context of CONFIG SET. Returns 1 on success, 0 on failure.
     * Optionally set err to a static error string. */
    apply_fn apply;
    /* Called on CONFIG GET, returns sds to be used in reply */
    sds (*get)(standardConfig *config);
    /* Called on CONFIG REWRITE, required to rewrite the config state */
    void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);
} typeInterface;",3,config.c,typeInterface,,false,274,typeInterface,53
67931,TYPE_DECL,,,,"struct standardConfig {
    const char *name; /* The user visible name of this config */
    const char *alias; /* An alias that can also be used for this config */
    unsigned int flags; /* Flags for this specific config */
    typeInterface interface; /* The function pointers that define the type interface */
    typeData data; /* The type specific data exposed used by the interface */
    configType type; /* The type of config this is. */
    void *privdata; /* privdata for this config, for module configs this is a ModuleConfig struct */
}",1,config.c,standardConfig,,false,276,standardConfig,54
70733,TYPE_DECL,,,,"struct rewriteConfigState {
    dict *option_to_line; /* Option -> list of config file lines map */
    dict *rewritten;      /* Dictionary of already processed options */
    int numlines;         /* Number of lines in current config */
    sds *lines;           /* Current lines as an array of sds strings */
    int needs_signature;  /* True if we need to append the rewrite
                             signature. */
    int force_write;      /* True if we want all keywords to be force
                             written. Currently only used for testing
                             and debug information. */
}",1,config.c,rewriteConfigState,,false,1054,rewriteConfigState,81
97474,TYPE_DECL,,config.h:<global>,NAMESPACE_BLOCK,<global>,1,config.h,config.h:<global>,,false,1,<global>,13
97483,TYPE_DECL,,connection.c:<global>,NAMESPACE_BLOCK,<global>,1,connection.c,connection.c:<global>,,false,1,<global>,3
98077,TYPE_DECL,,connection.h:<global>,NAMESPACE_BLOCK,<global>,1,connection.h,connection.h:<global>,,false,1,<global>,6
98080,TYPE_DECL,,,,struct aeEventLoop,1,connection.h,aeEventLoop,,false,45,aeEventLoop,1
98081,TYPE_DECL,connection,,,typedef struct connection,1,connection.h,connection,,false,46,connection,2
98082,TYPE_DECL,connection,,,typedef struct connection connection;,27,connection.h,connection,,false,46,connection,3
98083,TYPE_DECL,connListener,,,typedef struct connListener,1,connection.h,connListener,,false,47,connListener,4
98084,TYPE_DECL,connListener,,,typedef struct connListener connListener;,29,connection.h,connListener,,false,47,connListener,5
98085,TYPE_DECL,,,,"typedef enum {
    CONN_STATE_NONE = 0,
    CONN_STATE_CONNECTING,
    CONN_STATE_ACCEPTING,
    CONN_STATE_CONNECTED,
    CONN_STATE_CLOSED,
    CONN_STATE_ERROR
}",1,connection.h,ConnectionState,,false,49,ConnectionState,6
98105,TYPE_DECL,ConnectionType,,,"typedef struct ConnectionType {
    /* connection type */
    const char *(*get_type)(struct connection *conn);

    /* connection type initialize & finalize & configure */
    void (*init)(void); /* auto-call during register */
    void (*cleanup)(void);
    int (*configure)(void *priv, int reconfigure);

    /* ae & accept & listen & error & address handler */
    void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);
    aeFileProc *accept_handler;
    int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);
    int (*is_local)(connection *conn);
    int (*listen)(connListener *listener);

    /* create/shutdown/close connection */
    connection* (*conn_create)(void);
    connection* (*conn_create_accepted)(int fd, void *priv);
    void (*shutdown)(struct connection *conn);
    void (*close)(struct connection *conn);

    /* connect & accept */
    int (*connect)(struct connection *conn, const char *addr, int port, const char *sourc...",1,connection.h,ConnectionType,,false,68,ConnectionType,9
98277,TYPE_DECL,ConnectionType,,,"typedef struct ConnectionType {
    /* connection type */
    const char *(*get_type)(struct connection *conn);

    /* connection type initialize & finalize & configure */
    void (*init)(void); /* auto-call during register */
    void (*cleanup)(void);
    int (*configure)(void *priv, int reconfigure);

    /* ae & accept & listen & error & address handler */
    void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);
    aeFileProc *accept_handler;
    int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);
    int (*is_local)(connection *conn);
    int (*listen)(connListener *listener);

    /* create/shutdown/close connection */
    connection* (*conn_create)(void);
    connection* (*conn_create_accepted)(int fd, void *priv);
    void (*shutdown)(struct connection *conn);
    void (*close)(struct connection *conn);

    /* connect & accept */
    int (*connect)(struct connection *conn, const char *addr, int port, const char *sourc...",3,connection.h,ConnectionType,,false,112,ConnectionType,10
98278,TYPE_DECL,,,,"struct connection {
    ConnectionType *type;
    ConnectionState state;
    int last_errno;
    int fd;
    short int flags;
    short int refs;
    unsigned short int iovcnt;
    void *private_data;
    ConnectionCallbackFunc conn_handler;
    ConnectionCallbackFunc write_handler;
    ConnectionCallbackFunc read_handler;
}",1,connection.h,connection,,false,114,connection,11
98290,TYPE_DECL,,,,"struct connListener {
    int fd[CONFIG_BINDADDR_MAX];
    int count;
    char **bindaddr;
    int bindaddr_count;
    int port;
    ConnectionType *ct;
    void *priv; /* used by connection type specified data */
}",1,connection.h,connListener,,false,131,connListener,12
99008,TYPE_DECL,,connhelpers.h:<global>,NAMESPACE_BLOCK,<global>,1,connhelpers.h,connhelpers.h:<global>,,false,1,<global>,2
99079,TYPE_DECL,,crc16.c:<global>,NAMESPACE_BLOCK,<global>,1,crc16.c,crc16.c:<global>,,false,1,<global>,2
99384,TYPE_DECL,,crc16_slottable.h:<global>,NAMESPACE_BLOCK,<global>,1,crc16_slottable.h,crc16_slottable.h:<global>,,false,1,<global>,1
100400,TYPE_DECL,,crc64.c:<global>,NAMESPACE_BLOCK,<global>,1,crc64.c,crc64.c:<global>,,false,1,<global>,4
100557,TYPE_DECL,,crc64.h:<global>,NAMESPACE_BLOCK,<global>,1,crc64.h,crc64.h:<global>,,false,1,<global>,2
100576,TYPE_DECL,,crcspeed.c:<global>,NAMESPACE_BLOCK,<global>,1,crcspeed.c,crcspeed.c:<global>,,false,1,<global>,2
101683,TYPE_DECL,,crcspeed.h:<global>,NAMESPACE_BLOCK,<global>,1,crcspeed.h,crcspeed.h:<global>,,false,1,<global>,3
101802,TYPE_DECL,,db.c:<global>,NAMESPACE_BLOCK,<global>,1,db.c,db.c:<global>,,false,1,<global>,9
104065,TYPE_DECL,scanData,,,"typedef struct {
    list *keys;   /* elements that collect from dict */
    robj *o;      /* o must be a hash/set/zset object, NULL means current db */
    long long type; /* the particular type when scan the db */
    sds pattern;  /* pattern string, NULL means no pattern */
    long sampled; /* cumulative number of keys sampled */
}",1,db.c,scanData,,false,814,scanData,43
108295,TYPE_DECL,ChannelSpecs,,,"typedef struct ChannelSpecs {
    redisCommandProc *proc; /* Command procedure to match against */
    uint64_t flags;         /* CMD_CHANNEL_* flags for this command */
    int start;              /* The initial position of the first channel */
    int count;              /* The number of channels, or -1 if all remaining
                             * arguments are channels. */
}",1,db.c,ChannelSpecs,,false,2035,ChannelSpecs,80
108300,TYPE_DECL,ChannelSpecs,,,"typedef struct ChannelSpecs {
    redisCommandProc *proc; /* Command procedure to match against */
    uint64_t flags;         /* CMD_CHANNEL_* flags for this command */
    int start;              /* The initial position of the first channel */
    int count;              /* The number of channels, or -1 if all remaining
                             * arguments are channels. */
} ChannelSpecs;",3,db.c,ChannelSpecs,,false,2041,ChannelSpecs,81
110220,TYPE_DECL,,debug.c:<global>,NAMESPACE_BLOCK,<global>,1,debug.c,debug.c:<global>,,false,1,<global>,19
116197,TYPE_DECL,,debugmacro.h:<global>,NAMESPACE_BLOCK,<global>,1,debugmacro.h,debugmacro.h:<global>,,false,1,<global>,2
116212,TYPE_DECL,,defrag.c:<global>,NAMESPACE_BLOCK,<global>,1,defrag.c,defrag.c:<global>,,false,1,<global>,6
116272,TYPE_DECL,,dict.c:<global>,NAMESPACE_BLOCK,<global>,1,dict.c,dict.c:<global>,,false,1,<global>,13
116283,TYPE_DECL,,,,"struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;     /* Next entry in the same hash bucket. */
    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as returned
                                 * by dictType's dictEntryMetadataBytes(). */
}",1,dict.c,dictEntry,,false,63,dictEntry,5
116285,TYPE_DECL,v,,,"union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    }",5,dict.c,dictEntry.v,,false,65,dictEntry.v,2
116291,TYPE_DECL,next,,,struct dictEntry,5,dict.c,dictEntry.dictEntry,,false,71,dictEntry,4
116299,TYPE_DECL,dictEntryNoValue,,,"typedef struct {
    void *key;
    dictEntry *next;
}",1,dict.c,dictEntryNoValue,,false,77,dictEntryNoValue,6
122559,TYPE_DECL,,dict.h:<global>,NAMESPACE_BLOCK,<global>,1,dict.h,dict.h:<global>,,false,1,<global>,5
122562,TYPE_DECL,dictEntry,,,typedef struct dictEntry,1,dict.h,dictEntry,,false,47,dictEntry,1
122563,TYPE_DECL,dictEntry,,,typedef struct dictEntry dictEntry;,26,dict.h,dictEntry,,false,47,dictEntry,2
122564,TYPE_DECL,dict,,,typedef struct dict,1,dict.h,dict,,false,49,dict,3
122565,TYPE_DECL,dict,,,typedef struct dict dict;,21,dict.h,dict,,false,49,dict,4
122566,TYPE_DECL,dictType,,,"typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(dict *d, const void *key);
    void *(*valDup)(dict *d, const void *obj);
    int (*keyCompare)(dict *d, const void *key1, const void *key2);
    void (*keyDestructor)(dict *d, void *key);
    void (*valDestructor)(dict *d, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
    /* Flags */
    /* The 'no_value' flag, if set, indicates that values are not used, i.e. the
     * dict is a set. When this flag is set, it's not possible to access the
     * value of a dictEntry and it's also impossible to use dictSetKey(). Entry
     * metadata can also not be used. */
    unsigned int no_value:1;
    /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1
     * enables one more optimization: to store a key without an allocated
     * dictEntry. */
    unsigned int keys_are_odd:1;
    /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that...",1,dict.h,dictType,,false,51,dictType,5
122627,TYPE_DECL,dictType,,,"typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(dict *d, const void *key);
    void *(*valDup)(dict *d, const void *obj);
    int (*keyCompare)(dict *d, const void *key1, const void *key2);
    void (*keyDestructor)(dict *d, void *key);
    void (*valDestructor)(dict *d, void *obj);
    int (*expandAllowed)(size_t moreMem, double usedRatio);
    /* Flags */
    /* The 'no_value' flag, if set, indicates that values are not used, i.e. the
     * dict is a set. When this flag is set, it's not possible to access the
     * value of a dictEntry and it's also impossible to use dictSetKey(). Entry
     * metadata can also not be used. */
    unsigned int no_value:1;
    /* If no_value = 1 and all keys are odd (LSB=1), setting keys_are_odd = 1
     * enables one more optimization: to store a key without an allocated
     * dictEntry. */
    unsigned int keys_are_odd:1;
    /* TODO: Add a 'keys_are_even' flag and use a similar optimization if that...",3,dict.h,dictType,,false,79,dictType,6
122628,TYPE_DECL,,,,"struct dict {
    dictType *type;

    dictEntry **ht_table[2];
    unsigned long ht_used[2];

    long rehashidx; /* rehashing not in progress if rehashidx == -1 */

    /* Keep small vars at end for optimal (minimal) struct padding */
    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */
    signed char ht_size_exp[2]; /* exponent of size. (size = 1<<exp) */

    void *metadata[];           /* An arbitrary number of bytes (starting at a
                                 * pointer-aligned address) of size as defined
                                 * by dictType's dictEntryBytes. */
}",1,dict.h,dict,,false,84,dict,7
122647,TYPE_DECL,dictIterator,,,"typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    unsigned long long fingerprint;
}",1,dict.h,dictIterator,,false,105,dictIterator,8
122655,TYPE_DECL,dictIterator,,,"typedef struct dictIterator {
    dict *d;
    long index;
    int table, safe;
    dictEntry *entry, *nextEntry;
    /* unsafe iterator fingerprint for misuse detection. */
    unsigned long long fingerprint;
} dictIterator;",3,dict.h,dictIterator,,false,112,dictIterator,9
122667,TYPE_DECL,dictDefragFunctions,,,"typedef struct {
    dictDefragAllocFunction *defragAlloc; /* Used for entries etc. */
    dictDefragAllocFunction *defragKey;   /* Defrag-realloc keys (optional) */
    dictDefragAllocFunction *defragVal;   /* Defrag-realloc values (optional) */
}",1,dict.h,dictDefragFunctions,,false,116,dictDefragFunctions,12
122672,TYPE_DECL,,,,"typedef enum {
    DICT_RESIZE_ENABLE,
    DICT_RESIZE_AVOID,
    DICT_RESIZE_FORBID,
}",1,dict.h,dictResizeEnable,,false,160,dictResizeEnable,14
123034,TYPE_DECL,,endianconv.c:<global>,NAMESPACE_BLOCK,<global>,1,endianconv.c,endianconv.c:<global>,,false,1,<global>,3
123222,TYPE_DECL,,endianconv.h:<global>,NAMESPACE_BLOCK,<global>,1,endianconv.h,endianconv.h:<global>,,false,1,<global>,3
123281,TYPE_DECL,,eval.c:<global>,NAMESPACE_BLOCK,<global>,1,eval.c,eval.c:<global>,,false,1,<global>,13
123363,TYPE_DECL,lctx,,,"struct luaCtx {
    lua_State *lua; /* The Lua interpreter. We use just one for all clients */
    client *lua_client;   /* The ""fake client"" to query Redis from Lua */
    dict *lua_scripts;         /* A dictionary of SHA1 -> Lua scripts */
    unsigned long long lua_scripts_mem;  /* Cached scripts' memory + oh */
}",1,eval.c,luaCtx,,false,73,luaCtx,10
123369,TYPE_DECL,ldb,,,"struct ldbState {
    connection *conn; /* Connection of the debugging client. */
    int active; /* Are we debugging EVAL right now? */
    int forked; /* Is this a fork()ed debugging session? */
    list *logs; /* List of messages to send to the client. */
    list *traces; /* Messages about Redis commands executed since last stop.*/
    list *children; /* All forked debugging sessions pids. */
    int bp[LDB_BREAKPOINTS_MAX]; /* An array of breakpoints line numbers. */
    int bpcount; /* Number of valid entries inside bp. */
    int step;   /* Stop at next line regardless of breakpoints. */
    int luabp;  /* Stop at next line because redis.breakpoint() was called. */
    sds *src;   /* Lua script source code split by line. */
    int lines;  /* Number of lines in 'src'. */
    int currentline;    /* Current line number. */
    sds cbuf;   /* Debugger client command buffer. */
    size_t maxlen;  /* Max var dump / reply length. */
    int maxlen_hint_sent; /* Did we already hint...",1,eval.c,ldbState,,false,83,ldbState,12
128830,TYPE_DECL,,evict.c:<global>,NAMESPACE_BLOCK,<global>,1,evict.c,evict.c:<global>,,false,1,<global>,6
128833,TYPE_DECL,,,,"struct evictionPoolEntry {
    unsigned long long idle;    /* Object idle time (inverse frequency for LFU) */
    sds key;                    /* Key name. */
    sds cached;                 /* Cached SDS object for key name. */
    int dbid;                   /* Key DB number. */
}",1,evict.c,evictionPoolEntry,,false,56,evictionPoolEntry,1
128838,TYPE_DECL,EvictionPoolLRU,,,static struct evictionPoolEntry,1,evict.c,evictionPoolEntry,,false,63,evictionPoolEntry,2
130778,TYPE_DECL,,expire.c:<global>,NAMESPACE_BLOCK,<global>,1,expire.c,expire.c:<global>,,false,1,<global>,2
130821,TYPE_DECL,expireScanData,,,"typedef struct {
    redisDb *db;
    long long now;
    unsigned long sampled; /* num keys checked */
    unsigned long expired; /* num keys expired */
    long long ttl_sum; /* sum of ttl for key with ttl not yet expired */
    int ttl_samples; /* num keys with ttl not yet expired */
}",1,expire.c,expireScanData,,false,114,expireScanData,2
132625,TYPE_DECL,,fmacros.h:<global>,NAMESPACE_BLOCK,<global>,1,fmacros.h,fmacros.h:<global>,,false,1,<global>,2
132640,TYPE_DECL,,function_lua.c:<global>,NAMESPACE_BLOCK,<global>,1,function_lua.c,function_lua.c:<global>,,false,1,<global>,6
132643,TYPE_DECL,luaEngineCtx,,,"typedef struct luaEngineCtx {
    lua_State *lua;
}",1,function_lua.c,luaEngineCtx,,false,57,luaEngineCtx,1
132645,TYPE_DECL,luaEngineCtx,,,"typedef struct luaEngineCtx {
    lua_State *lua;
} luaEngineCtx;",3,function_lua.c,luaEngineCtx,,false,59,luaEngineCtx,2
132646,TYPE_DECL,luaFunctionCtx,,,"typedef struct luaFunctionCtx {
    /* Special ID that allows getting the Lua function object from the Lua registry */
    int lua_function_ref;
}",1,function_lua.c,luaFunctionCtx,,false,62,luaFunctionCtx,3
132648,TYPE_DECL,luaFunctionCtx,,,"typedef struct luaFunctionCtx {
    /* Special ID that allows getting the Lua function object from the Lua registry */
    int lua_function_ref;
} luaFunctionCtx;",3,function_lua.c,luaFunctionCtx,,false,65,luaFunctionCtx,4
132649,TYPE_DECL,loadCtx,,,"typedef struct loadCtx {
    functionLibInfo *li;
    monotime start_time;
}",1,function_lua.c,loadCtx,,false,67,loadCtx,5
132652,TYPE_DECL,loadCtx,,,"typedef struct loadCtx {
    functionLibInfo *li;
    monotime start_time;
} loadCtx;",3,function_lua.c,loadCtx,,false,70,loadCtx,6
132653,TYPE_DECL,registerFunctionArgs,,,"typedef struct registerFunctionArgs {
    sds name;
    sds desc;
    luaFunctionCtx *lua_f_ctx;
    uint64_t f_flags;
}",1,function_lua.c,registerFunctionArgs,,false,72,registerFunctionArgs,7
132658,TYPE_DECL,registerFunctionArgs,,,"typedef struct registerFunctionArgs {
    sds name;
    sds desc;
    luaFunctionCtx *lua_f_ctx;
    uint64_t f_flags;
} registerFunctionArgs;",3,function_lua.c,registerFunctionArgs,,false,77,registerFunctionArgs,8
133925,TYPE_DECL,,functions.c:<global>,NAMESPACE_BLOCK,<global>,1,functions.c,functions.c:<global>,,false,1,<global>,6
133928,TYPE_DECL,,,,"typedef enum {
    restorePolicy_Flush, restorePolicy_Append, restorePolicy_Replace
}",1,functions.c,restorePolicy,,false,36,restorePolicy,1
133960,TYPE_DECL,functionsLibEngineStats,,,"typedef struct functionsLibEngineStats {
    size_t n_lib;
    size_t n_functions;
}",1,functions.c,functionsLibEngineStats,,false,48,functionsLibEngineStats,9
133963,TYPE_DECL,functionsLibEngineStats,,,"typedef struct functionsLibEngineStats {
    size_t n_lib;
    size_t n_functions;
} functionsLibEngineStats;",3,functions.c,functionsLibEngineStats,,false,51,functionsLibEngineStats,10
133964,TYPE_DECL,,,,"struct functionsLibCtx {
    dict *libraries;     /* Library name -> Library object */
    dict *functions;     /* Function name -> Function object that can be used to run the function */
    size_t cache_memory; /* Overhead memory (structs, dictionaries, ..) used by all the functions */
    dict *engines_stats; /* Per engine statistics */
}",1,functions.c,functionsLibCtx,,false,53,functionsLibCtx,11
133969,TYPE_DECL,functionsLibMataData,,,"typedef struct functionsLibMataData {
    sds engine;
    sds name;
    sds code;
}",1,functions.c,functionsLibMataData,,false,60,functionsLibMataData,12
133973,TYPE_DECL,functionsLibMataData,,,"typedef struct functionsLibMataData {
    sds engine;
    sds name;
    sds code;
} functionsLibMataData;",3,functions.c,functionsLibMataData,,false,64,functionsLibMataData,13
137412,TYPE_DECL,,functions.h:<global>,NAMESPACE_BLOCK,<global>,1,functions.h,functions.h:<global>,,false,1,<global>,4
137415,TYPE_DECL,functionLibInfo,,,typedef struct functionLibInfo,1,functions.h,functionLibInfo,,false,50,functionLibInfo,1
137416,TYPE_DECL,functionLibInfo,,,typedef struct functionLibInfo functionLibInfo;,32,functions.h,functionLibInfo,,false,50,functionLibInfo,2
137417,TYPE_DECL,engine,,,"typedef struct engine {
    /* engine specific context */
    void *engine_ctx;

    /* Create function callback, get the engine_ctx, and function code.
     * returns NULL on error and set sds to be the error message */
    int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);

    /* Invoking a function, r_ctx is an opaque object (from engine POV).
     * The r_ctx should be used by the engine to interaction with Redis,
     * such interaction could be running commands, set resp, or set
     * replication mode
     */
    void (*call)(scriptRunCtx *r_ctx, void *engine_ctx, void *compiled_function,
            robj **keys, size_t nkeys, robj **args, size_t nargs);

    /* get current used memory by the engine */
    size_t (*get_used_memory)(void *engine_ctx);

    /* Return memory overhead for a given function,
     * such memory is not counted as engine memory but as general
     * structs memory that hold different information */
    size_t (*get_function_mem...",1,functions.h,engine,,false,52,engine,3
137459,TYPE_DECL,engine,,,"typedef struct engine {
    /* engine specific context */
    void *engine_ctx;

    /* Create function callback, get the engine_ctx, and function code.
     * returns NULL on error and set sds to be the error message */
    int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);

    /* Invoking a function, r_ctx is an opaque object (from engine POV).
     * The r_ctx should be used by the engine to interaction with Redis,
     * such interaction could be running commands, set resp, or set
     * replication mode
     */
    void (*call)(scriptRunCtx *r_ctx, void *engine_ctx, void *compiled_function,
            robj **keys, size_t nkeys, robj **args, size_t nargs);

    /* get current used memory by the engine */
    size_t (*get_used_memory)(void *engine_ctx);

    /* Return memory overhead for a given function,
     * such memory is not counted as engine memory but as general
     * structs memory that hold different information */
    size_t (*get_function_mem...",3,functions.h,engine,,false,81,engine,4
137460,TYPE_DECL,engineInfo,,,"typedef struct engineInfo {
    sds name;       /* Name of the engine */
    engine *engine; /* engine callbacks that allows to interact with the engine */
    client *c;      /* Client that is used to run commands */
}",1,functions.h,engineInfo,,false,85,engineInfo,5
137464,TYPE_DECL,engineInfo,,,"typedef struct engineInfo {
    sds name;       /* Name of the engine */
    engine *engine; /* engine callbacks that allows to interact with the engine */
    client *c;      /* Client that is used to run commands */
} engineInfo;",3,functions.h,engineInfo,,false,89,engineInfo,6
137465,TYPE_DECL,functionInfo,,,"typedef struct functionInfo {
    sds name;            /* Function name */
    void *function;      /* Opaque object that set by the function's engine and allow it
                            to run the function, usually it's the function compiled code. */
    functionLibInfo* li; /* Pointer to the library created the function */
    sds desc;            /* Function description */
    uint64_t f_flags;    /* Function flags */
}",1,functions.h,functionInfo,,false,93,functionInfo,7
137471,TYPE_DECL,functionInfo,,,"typedef struct functionInfo {
    sds name;            /* Function name */
    void *function;      /* Opaque object that set by the function's engine and allow it
                            to run the function, usually it's the function compiled code. */
    functionLibInfo* li; /* Pointer to the library created the function */
    sds desc;            /* Function description */
    uint64_t f_flags;    /* Function flags */
} functionInfo;",3,functions.h,functionInfo,,false,100,functionInfo,8
137472,TYPE_DECL,,,,"struct functionLibInfo {
    sds name;        /* Library name */
    dict *functions; /* Functions dictionary */
    engineInfo *ei;  /* Pointer to the function engine */
    sds code;        /* Library code */
}",1,functions.h,functionLibInfo,,false,104,functionLibInfo,9
137581,TYPE_DECL,,geo.c:<global>,NAMESPACE_BLOCK,<global>,1,geo.c,geo.c:<global>,,false,1,<global>,5
141334,TYPE_DECL,,geo.h:<global>,NAMESPACE_BLOCK,<global>,1,geo.h,geo.h:<global>,,false,1,<global>,2
141337,TYPE_DECL,geoPoint,,,"typedef struct geoPoint {
    double longitude;
    double latitude;
    double dist;
    double score;
    char *member;
}",1,geo.h,geoPoint,,false,8,geoPoint,1
141343,TYPE_DECL,geoPoint,,,"typedef struct geoPoint {
    double longitude;
    double latitude;
    double dist;
    double score;
    char *member;
} geoPoint;",3,geo.h,geoPoint,,false,14,geoPoint,2
141344,TYPE_DECL,geoArray,,,"typedef struct geoArray {
    struct geoPoint *array;
    size_t buckets;
    size_t used;
}",1,geo.h,geoArray,,false,16,geoArray,3
141345,TYPE_DECL,array,,,struct geoPoint,5,geo.h,geoArray.geoPoint,,false,17,geoPoint,1
141349,TYPE_DECL,geoArray,,,"typedef struct geoArray {
    struct geoPoint *array;
    size_t buckets;
    size_t used;
} geoArray;",3,geo.h,geoArray,,false,20,geoArray,4
141354,TYPE_DECL,,geohash.c:<global>,NAMESPACE_BLOCK,<global>,1,geohash.c,geohash.c:<global>,,false,1,<global>,2
142699,TYPE_DECL,,geohash.h:<global>,NAMESPACE_BLOCK,<global>,1,geohash.h,geohash.h:<global>,,false,1,<global>,3
142702,TYPE_DECL,,,,"typedef enum {
    GEOHASH_NORTH = 0,
    GEOHASH_EAST,
    GEOHASH_WEST,
    GEOHASH_SOUTH,
    GEOHASH_SOUTH_WEST,
    GEOHASH_SOUTH_EAST,
    GEOHASH_NORT_WEST,
    GEOHASH_NORT_EAST
}",1,geohash.h,GeoDirection,,false,54,GeoDirection,1
142719,TYPE_DECL,GeoHashBits,,,"typedef struct {
    uint64_t bits;
    uint8_t step;
}",1,geohash.h,GeoHashBits,,false,65,GeoHashBits,3
142723,TYPE_DECL,GeoHashRange,,,"typedef struct {
    double min;
    double max;
}",1,geohash.h,GeoHashRange,,false,70,GeoHashRange,5
142727,TYPE_DECL,GeoHashArea,,,"typedef struct {
    GeoHashBits hash;
    GeoHashRange longitude;
    GeoHashRange latitude;
}",1,geohash.h,GeoHashArea,,false,75,GeoHashArea,7
142732,TYPE_DECL,GeoHashNeighbors,,,"typedef struct {
    GeoHashBits north;
    GeoHashBits east;
    GeoHashBits west;
    GeoHashBits south;
    GeoHashBits north_east;
    GeoHashBits south_east;
    GeoHashBits north_west;
    GeoHashBits south_west;
}",1,geohash.h,GeoHashNeighbors,,false,81,GeoHashNeighbors,9
142742,TYPE_DECL,GeoShape,,,"typedef struct {
    int type; /* search type */
    double xy[2]; /* search center point, xy[0]: lon, xy[1]: lat */
    double conversion; /* km: 1000 */
    double bounds[4]; /* bounds[0]: min_lon, bounds[1]: min_lat
                       * bounds[2]: max_lon, bounds[3]: max_lat */
    union {
        /* CIRCULAR_TYPE */
        double radius;
        /* RECTANGLE_TYPE */
        struct {
            double height;
            double width;
        } r;
    } t;
}",1,geohash.h,GeoShape,,false,94,GeoShape,11
142747,TYPE_DECL,t,,,"union {
        /* CIRCULAR_TYPE */
        double radius;
        /* RECTANGLE_TYPE */
        struct {
            double height;
            double width;
        } r;
    }",5,geohash.h,GeoShape.t,,false,100,GeoShape.t,5
142749,TYPE_DECL,r,,,"struct {
            double height;
            double width;
        }",9,geohash.h,GeoShape.t.r,,false,104,GeoShape.t.r,2
142849,TYPE_DECL,,geohash_helper.c:<global>,NAMESPACE_BLOCK,<global>,1,geohash_helper.c,geohash_helper.c:<global>,,false,1,<global>,5
143904,TYPE_DECL,,geohash_helper.h:<global>,NAMESPACE_BLOCK,<global>,1,geohash_helper.h,geohash_helper.h:<global>,,false,1,<global>,2
143907,TYPE_DECL,ANY,,,typedef uint64_t GeoHashFix52Bits;,18,geohash_helper.h,GeoHashFix52Bits,,false,41,GeoHashFix52Bits,1
143908,TYPE_DECL,ANY,,,typedef uint64_t GeoHashVarBits;,18,geohash_helper.h,GeoHashVarBits,,false,42,GeoHashVarBits,2
143909,TYPE_DECL,GeoHashRadius,,,"typedef struct {
    GeoHashBits hash;
    GeoHashArea area;
    GeoHashNeighbors neighbors;
}",1,geohash_helper.h,GeoHashRadius,,false,44,GeoHashRadius,3
143983,TYPE_DECL,,hyperloglog.c:<global>,NAMESPACE_BLOCK,<global>,1,hyperloglog.c,hyperloglog.c:<global>,,false,1,<global>,4
143986,TYPE_DECL,,,,"struct hllhdr {
    char magic[4];      /* ""HYLL"" */
    uint8_t encoding;   /* HLL_DENSE or HLL_SPARSE. */
    uint8_t notused[3]; /* Reserved for future use, must be zero. */
    uint8_t card[8];    /* Cached cardinality, little endian. */
    uint8_t registers[]; /* Data bytes. */
}",1,hyperloglog.c,hllhdr,,false,182,hllhdr,1
149259,TYPE_DECL,,intset.c:<global>,NAMESPACE_BLOCK,<global>,1,intset.c,intset.c:<global>,,false,1,<global>,10
150543,TYPE_DECL,,intset.h:<global>,NAMESPACE_BLOCK,<global>,1,intset.h,intset.h:<global>,,false,1,<global>,2
150546,TYPE_DECL,intset,,,"typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
}",1,intset.h,intset,,false,35,intset,1
150555,TYPE_DECL,intset,,,"typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;",3,intset.h,intset,,false,39,intset,2
150626,TYPE_DECL,,latency.c:<global>,NAMESPACE_BLOCK,<global>,1,latency.c,latency.c:<global>,,false,1,<global>,3
152989,TYPE_DECL,,latency.h:<global>,NAMESPACE_BLOCK,<global>,1,latency.h,latency.h:<global>,,false,1,<global>,1
152992,TYPE_DECL,,,,"struct latencySample {
    int32_t time; /* We don't use time_t to force 4 bytes usage everywhere. */
    uint32_t latency; /* Latency in milliseconds. */
}",1,latency.h,latencySample,,false,41,latencySample,1
152995,TYPE_DECL,,,,"struct latencyTimeSeries {
    int idx; /* Index of the next sample to store. */
    uint32_t max; /* Max latency observed for this event. */
    struct latencySample samples[LATENCY_TS_LEN]; /* Latest history. */
}",1,latency.h,latencyTimeSeries,,false,47,latencyTimeSeries,2
152998,TYPE_DECL,samples,,,struct latencySample,5,latency.h,latencyTimeSeries.latencySample,,false,50,latencySample,3
153008,TYPE_DECL,,,,"struct latencyStats {
    uint32_t all_time_high; /* Absolute max observed since latest reset. */
    uint32_t avg;           /* Average of current samples. */
    uint32_t min;           /* Min of current samples. */
    uint32_t max;           /* Max of current samples. */
    uint32_t mad;           /* Mean absolute deviation. */
    uint32_t samples;       /* Number of non-zero samples. */
    time_t period;          /* Number of seconds since first event and now. */
}",1,latency.h,latencyStats,,false,54,latencyStats,3
153027,TYPE_DECL,durationStats,,,"typedef struct durationStats {
    unsigned long long cnt;
    unsigned long long sum;
    unsigned long long max;
}",1,latency.h,durationStats,,false,92,durationStats,6
153031,TYPE_DECL,durationStats,,,"typedef struct durationStats {
    unsigned long long cnt;
    unsigned long long sum;
    unsigned long long max;
} durationStats;",3,latency.h,durationStats,,false,96,durationStats,7
153032,TYPE_DECL,,,,"typedef enum {
    EL_DURATION_TYPE_EL = 0, // cumulative time duration metric of the whole eventloop
    EL_DURATION_TYPE_CMD,    // cumulative time duration metric of executing commands
    EL_DURATION_TYPE_AOF,    // cumulative time duration metric of flushing AOF in eventloop
    EL_DURATION_TYPE_CRON,   // cumulative time duration metric of cron (serverCron and beforeSleep, but excluding IO and AOF)
    EL_DURATION_TYPE_NUM
}",1,latency.h,DurationType,,false,98,DurationType,8
153062,TYPE_DECL,,lazyfree.c:<global>,NAMESPACE_BLOCK,<global>,1,lazyfree.c,lazyfree.c:<global>,,false,1,<global>,5
153833,TYPE_DECL,,listpack.c:<global>,NAMESPACE_BLOCK,<global>,1,listpack.c,listpack.c:<global>,,false,1,<global>,15
159970,TYPE_DECL,,listpack.h:<global>,NAMESPACE_BLOCK,<global>,1,listpack.h,listpack.h:<global>,,false,1,<global>,3
159973,TYPE_DECL,listpackEntry,,,"typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    uint32_t slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
}",1,listpack.h,listpackEntry,,false,49,listpackEntry,1
160249,TYPE_DECL,,listpack_malloc.h:<global>,NAMESPACE_BLOCK,<global>,1,listpack_malloc.h,listpack_malloc.h:<global>,,false,1,<global>,2
160258,TYPE_DECL,,localtime.c:<global>,NAMESPACE_BLOCK,<global>,1,localtime.c,localtime.c:<global>,,false,1,<global>,3
160478,TYPE_DECL,,logreqres.c:<global>,NAMESPACE_BLOCK,<global>,1,logreqres.c,logreqres.c:<global>,,false,1,<global>,3
160544,TYPE_DECL,,lolwut.c:<global>,NAMESPACE_BLOCK,<global>,1,lolwut.c,lolwut.c:<global>,,false,1,<global>,4
161097,TYPE_DECL,,lolwut.h:<global>,NAMESPACE_BLOCK,<global>,1,lolwut.h,lolwut.h:<global>,,false,1,<global>,1
161100,TYPE_DECL,lwCanvas,,,"typedef struct lwCanvas {
    int width;
    int height;
    char *pixels;
}",1,lolwut.h,lwCanvas,,false,41,lwCanvas,1
161104,TYPE_DECL,lwCanvas,,,"typedef struct lwCanvas {
    int width;
    int height;
    char *pixels;
} lwCanvas;",3,lolwut.h,lwCanvas,,false,45,lwCanvas,2
161162,TYPE_DECL,,lolwut5.c:<global>,NAMESPACE_BLOCK,<global>,1,lolwut5.c,lolwut5.c:<global>,,false,1,<global>,5
161767,TYPE_DECL,,lolwut6.c:<global>,NAMESPACE_BLOCK,<global>,1,lolwut6.c,lolwut6.c:<global>,,false,1,<global>,3
161870,TYPE_DECL,,,,"struct skyscraper {
    int xoff;       /* X offset. */
    int width;      /* Pixels width. */
    int height;     /* Pixels height. */
    int windows;    /* Draw windows if true. */
    int color;      /* Color of the skyscraper. */
}",1,lolwut6.c,skyscraper,,false,74,skyscraper,2
162409,TYPE_DECL,,lzf.h:<global>,NAMESPACE_BLOCK,<global>,1,lzf.h,lzf.h:<global>,,false,1,<global>,1
162444,TYPE_DECL,,lzfP.h:<global>,NAMESPACE_BLOCK,<global>,1,lzfP.h,lzfP.h:<global>,,false,1,<global>,8
162447,TYPE_DECL,unsigned char,,,typedef unsigned char u8;,23,lzfP.h,u8,,false,161,u8,1
162448,TYPE_DECL,unsigned char,,,typedef const u8 *LZF_HSLOT;,20,lzfP.h,LZF_HSLOT,,false,168,LZF_HSLOT,2
162449,TYPE_DECL,unsigned char[65536],,,typedef LZF_HSLOT LZF_STATE[1 << (HLOG)];,19,lzfP.h,LZF_STATE,,false,171,LZF_STATE,3
162460,TYPE_DECL,,lzf_c.c:<global>,NAMESPACE_BLOCK,<global>,1,lzf_c.c,lzf_c.c:<global>,,false,1,<global>,2
163235,TYPE_DECL,,lzf_d.c:<global>,NAMESPACE_BLOCK,<global>,1,lzf_d.c,lzf_d.c:<global>,,false,1,<global>,3
163865,TYPE_DECL,,memtest.c:<global>,NAMESPACE_BLOCK,<global>,1,memtest.c,memtest.c:<global>,,false,1,<global>,12
163868,TYPE_DECL,ws,,,static struct winsize,1,memtest.c,winsize,,false,69,winsize,1
164975,TYPE_DECL,,module.c:<global>,NAMESPACE_BLOCK,<global>,1,module.c,module.c:<global>,,false,1,<global>,14
164978,TYPE_DECL,,,,"struct RedisModuleInfoCtx {
    struct RedisModule *module;
    dict *requested_sections;
    sds info;           /* info string we collected so far */
    int sections;       /* number of sections we collected so far */
    int in_section;     /* indication if we're in an active section or not */
    int in_dict_field;  /* indication that we're currently appending to a dict */
}",1,module.c,RedisModuleInfoCtx,,false,74,RedisModuleInfoCtx,1
164979,TYPE_DECL,module,,,struct RedisModule,5,module.c,RedisModuleInfoCtx.RedisModule,,false,75,RedisModule,1
164986,TYPE_DECL,,,,"struct RedisModuleSharedAPI {
    void *func;
    RedisModule *module;
}",1,module.c,RedisModuleSharedAPI,,false,87,RedisModuleSharedAPI,2
164989,TYPE_DECL,RedisModuleSharedAPI,,,typedef struct RedisModuleSharedAPI,1,module.c,RedisModuleSharedAPI,,false,91,RedisModuleSharedAPI,3
164990,TYPE_DECL,RedisModuleSharedAPI,,,typedef struct RedisModuleSharedAPI RedisModuleSharedAPI;,37,module.c,RedisModuleSharedAPI,,false,91,RedisModuleSharedAPI,4
164992,TYPE_DECL,,,,"struct AutoMemEntry {
    void *ptr;
    int type;
}",1,module.c,AutoMemEntry,,false,97,AutoMemEntry,6
164995,TYPE_DECL,RedisModulePoolAllocBlock,,,"typedef struct RedisModulePoolAllocBlock {
    uint32_t size;
    uint32_t used;
    struct RedisModulePoolAllocBlock *next;
    char memory[];
}",1,module.c,RedisModulePoolAllocBlock,,false,126,RedisModulePoolAllocBlock,7
164998,TYPE_DECL,next,,,struct RedisModulePoolAllocBlock,5,module.c,RedisModulePoolAllocBlock.RedisModulePoolAllocBlock,,false,129,RedisModulePoolAllocBlock,3
165006,TYPE_DECL,RedisModulePoolAllocBlock,,,"typedef struct RedisModulePoolAllocBlock {
    uint32_t size;
    uint32_t used;
    struct RedisModulePoolAllocBlock *next;
    char memory[];
} RedisModulePoolAllocBlock;",3,module.c,RedisModulePoolAllocBlock,,false,131,RedisModulePoolAllocBlock,8
165007,TYPE_DECL,,,,struct RedisModuleBlockedClient,1,module.c,RedisModuleBlockedClient,,false,141,RedisModuleBlockedClient,9
165008,TYPE_DECL,,,,struct RedisModuleUser,1,module.c,RedisModuleUser,,false,142,RedisModuleUser,10
165009,TYPE_DECL,,,,"struct RedisModuleCtx {
    void *getapifuncptr;            /* NOTE: Must be the first field. */
    struct RedisModule *module;     /* Module reference. */
    client *client;                 /* Client calling a command. */
    struct RedisModuleBlockedClient *blocked_client; /* Blocked client for
                                                        thread safe context. */
    struct AutoMemEntry *amqueue;   /* Auto memory queue of objects to free. */
    int amqueue_len;                /* Number of slots in amqueue. */
    int amqueue_used;               /* Number of used slots in amqueue. */
    int flags;                      /* REDISMODULE_CTX_... flags. */
    void **postponed_arrays;        /* To set with RM_ReplySetArrayLength(). */
    int postponed_arrays_count;     /* Number of entries in postponed_arrays. */
    void *blocked_privdata;         /* Privdata set when unblocking a client. */
    RedisModuleString *blocked_ready_key; /* Key ready when the reply callback
  ...",1,module.c,RedisModuleCtx,,false,144,RedisModuleCtx,11
165011,TYPE_DECL,module,,,struct RedisModule,5,module.c,RedisModuleCtx.RedisModule,,false,146,RedisModule,2
165014,TYPE_DECL,blocked_client,,,struct RedisModuleBlockedClient,5,module.c,RedisModuleCtx.RedisModuleBlockedClient,,false,148,RedisModuleBlockedClient,5
165016,TYPE_DECL,amqueue,,,struct AutoMemEntry,5,module.c,RedisModuleCtx.AutoMemEntry,,false,150,AutoMemEntry,7
165026,TYPE_DECL,pa_head,,,struct RedisModulePoolAllocBlock,5,module.c,RedisModuleCtx.RedisModulePoolAllocBlock,,false,165,RedisModulePoolAllocBlock,17
165029,TYPE_DECL,user,,,const struct RedisModuleUser,5,module.c,RedisModuleCtx.RedisModuleUser,,false,168,RedisModuleUser,20
165031,TYPE_DECL,RedisModuleCtx,,,typedef struct RedisModuleCtx,1,module.c,RedisModuleCtx,,false,171,RedisModuleCtx,12
165032,TYPE_DECL,RedisModuleCtx,,,typedef struct RedisModuleCtx RedisModuleCtx;,31,module.c,RedisModuleCtx,,false,171,RedisModuleCtx,13
165033,TYPE_DECL,,,,"struct RedisModuleKey {
    RedisModuleCtx *ctx;
    redisDb *db;
    robj *key;      /* Key name object. */
    robj *value;    /* Value object, or NULL if the key was not found. */
    void *iter;     /* Iterator. */
    int mode;       /* Opening mode. */

    union {
        struct {
            /* List, use only if value->type == OBJ_LIST */
            listTypeEntry entry;   /* Current entry in iteration. */
            long index;            /* Current 0-based index in iteration. */
        } list;
        struct {
            /* Zset iterator, use only if value->type == OBJ_ZSET */
            uint32_t type;         /* REDISMODULE_ZSET_RANGE_* */
            zrangespec rs;         /* Score range. */
            zlexrangespec lrs;     /* Lex range. */
            uint32_t start;        /* Start pos for positional ranges. */
            uint32_t end;          /* End pos for positional ranges. */
            void *current;         /* Zset iterator current node. */
            i...",1,module.c,RedisModuleKey,,false,189,RedisModuleKey,14
165040,TYPE_DECL,u,,,"union {
        struct {
            /* List, use only if value->type == OBJ_LIST */
            listTypeEntry entry;   /* Current entry in iteration. */
            long index;            /* Current 0-based index in iteration. */
        } list;
        struct {
            /* Zset iterator, use only if value->type == OBJ_ZSET */
            uint32_t type;         /* REDISMODULE_ZSET_RANGE_* */
            zrangespec rs;         /* Score range. */
            zlexrangespec lrs;     /* Lex range. */
            uint32_t start;        /* Start pos for positional ranges. */
            uint32_t end;          /* End pos for positional ranges. */
            void *current;         /* Zset iterator current node. */
            int er;                /* Zset iterator end reached flag
                                       (true if end was reached). */
        } zset;
        struct {
            /* Stream, use only if value->type == OBJ_STREAM */
            streamID currentid;    /* Curr...",5,module.c,RedisModuleKey.u,,false,197,RedisModuleKey.u,7
165041,TYPE_DECL,list,,,"struct {
            /* List, use only if value->type == OBJ_LIST */
            listTypeEntry entry;   /* Current entry in iteration. */
            long index;            /* Current 0-based index in iteration. */
        }",9,module.c,RedisModuleKey.u.list,,false,198,RedisModuleKey.u.list,1
165045,TYPE_DECL,zset,,,"struct {
            /* Zset iterator, use only if value->type == OBJ_ZSET */
            uint32_t type;         /* REDISMODULE_ZSET_RANGE_* */
            zrangespec rs;         /* Score range. */
            zlexrangespec lrs;     /* Lex range. */
            uint32_t start;        /* Start pos for positional ranges. */
            uint32_t end;          /* End pos for positional ranges. */
            void *current;         /* Zset iterator current node. */
            int er;                /* Zset iterator end reached flag
                                       (true if end was reached). */
        }",9,module.c,RedisModuleKey.u.zset,,false,203,RedisModuleKey.u.zset,3
165054,TYPE_DECL,stream,,,"struct {
            /* Stream, use only if value->type == OBJ_STREAM */
            streamID currentid;    /* Current entry while iterating. */
            int64_t numfieldsleft; /* Fields left to fetch for current entry. */
            int signalready;       /* Flag that signalKeyAsReady() is needed. */
        }",9,module.c,RedisModuleKey.u.stream,,false,214,RedisModuleKey.u.stream,5
165060,TYPE_DECL,,,,struct RedisModuleBlockedClient,1,module.c,RedisModuleBlockedClient,,false,231,RedisModuleBlockedClient,15
165082,TYPE_DECL,,,,"struct RedisModuleCommand {
    struct RedisModule *module;
    RedisModuleCmdFunc func;
    struct redisCommand *rediscmd;
}",1,module.c,RedisModuleCommand,,false,237,RedisModuleCommand,19
165083,TYPE_DECL,module,,,struct RedisModule,5,module.c,RedisModuleCommand.RedisModule,,false,238,RedisModule,1
165086,TYPE_DECL,rediscmd,,,struct redisCommand,5,module.c,RedisModuleCommand.redisCommand,,false,240,redisCommand,4
165088,TYPE_DECL,RedisModuleCommand,,,typedef struct RedisModuleCommand,1,module.c,RedisModuleCommand,,false,242,RedisModuleCommand,20
165089,TYPE_DECL,RedisModuleCommand,,,typedef struct RedisModuleCommand RedisModuleCommand;,35,module.c,RedisModuleCommand,,false,242,RedisModuleCommand,21
165090,TYPE_DECL,RedisModuleCallReply,,,typedef struct CallReply,1,module.c,CallReply,,false,252,CallReply,22
165091,TYPE_DECL,CallReply,,,typedef struct CallReply RedisModuleCallReply;,26,module.c,RedisModuleCallReply,,false,252,RedisModuleCallReply,23
165092,TYPE_DECL,RedisModuleAuthCtx,,,"typedef struct RedisModuleAuthCtx {
    struct RedisModule *module;
    RedisModuleAuthCallback auth_cb;
}",1,module.c,RedisModuleAuthCtx,,false,255,RedisModuleAuthCtx,24
165093,TYPE_DECL,module,,,struct RedisModule,5,module.c,RedisModuleAuthCtx.RedisModule,,false,256,RedisModule,1
165096,TYPE_DECL,RedisModuleAuthCtx,,,"typedef struct RedisModuleAuthCtx {
    struct RedisModule *module;
    RedisModuleAuthCallback auth_cb;
} RedisModuleAuthCtx;",3,module.c,RedisModuleAuthCtx,,false,258,RedisModuleAuthCtx,25
165097,TYPE_DECL,RedisModuleBlockedClient,,,"typedef struct RedisModuleBlockedClient {
    client *client;  /* Pointer to the blocked client. or NULL if the client
                        was destroyed during the life of this object. */
    RedisModule *module;    /* Module blocking the client. */
    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/
    RedisModuleAuthCallback auth_reply_cb; /* Reply callback on completing blocking
                                                    module authentication. */
    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */
    RedisModuleDisconnectFunc disconnect_callback; /* Called on disconnection.*/
    void (*free_privdata)(RedisModuleCtx*,void*);/* privdata cleanup callback.*/
    void *privdata;     /* Module private data that may be used by the reply
                           or timeout callback. It is set via the
                           RedisModule_UnblockClient() API. */
    client *thread_safe_ctx_client; /* Fake client to be u...",1,module.c,RedisModuleBlockedClient,,false,262,RedisModuleBlockedClient,26
165118,TYPE_DECL,RedisModuleBlockedClient,,,"typedef struct RedisModuleBlockedClient {
    client *client;  /* Pointer to the blocked client. or NULL if the client
                        was destroyed during the life of this object. */
    RedisModule *module;    /* Module blocking the client. */
    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/
    RedisModuleAuthCallback auth_reply_cb; /* Reply callback on completing blocking
                                                    module authentication. */
    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */
    RedisModuleDisconnectFunc disconnect_callback; /* Called on disconnection.*/
    void (*free_privdata)(RedisModuleCtx*,void*);/* privdata cleanup callback.*/
    void *privdata;     /* Module private data that may be used by the reply
                           or timeout callback. It is set via the
                           RedisModule_UnblockClient() API. */
    client *thread_safe_ctx_client; /* Fake client to be u...",3,module.c,RedisModuleBlockedClient,,false,285,RedisModuleBlockedClient,27
165156,TYPE_DECL,RedisModuleKeyspaceSubscriber,,,"typedef struct RedisModuleKeyspaceSubscriber {
    /* The module subscribed to the event */
    RedisModule *module;
    /* Notification callback in the module*/
    RedisModuleNotificationFunc notify_callback;
    /* A bit mask of the events the module is interested in */
    int event_mask;
    /* Active flag set on entry, to avoid reentrant subscribers
     * calling themselves */
    int active;
}",1,module.c,RedisModuleKeyspaceSubscriber,,false,318,RedisModuleKeyspaceSubscriber,43
165161,TYPE_DECL,RedisModuleKeyspaceSubscriber,,,"typedef struct RedisModuleKeyspaceSubscriber {
    /* The module subscribed to the event */
    RedisModule *module;
    /* Notification callback in the module*/
    RedisModuleNotificationFunc notify_callback;
    /* A bit mask of the events the module is interested in */
    int event_mask;
    /* Active flag set on entry, to avoid reentrant subscribers
     * calling themselves */
    int active;
} RedisModuleKeyspaceSubscriber;",3,module.c,RedisModuleKeyspaceSubscriber,,false,328,RedisModuleKeyspaceSubscriber,44
165162,TYPE_DECL,RedisModulePostExecUnitJob,,,"typedef struct RedisModulePostExecUnitJob {
    /* The module subscribed to the event */
    RedisModule *module;
    RedisModulePostNotificationJobFunc callback;
    void *pd;
    void (*free_pd)(void*);
    int dbid;
}",1,module.c,RedisModulePostExecUnitJob,,false,330,RedisModulePostExecUnitJob,45
165172,TYPE_DECL,RedisModulePostExecUnitJob,,,"typedef struct RedisModulePostExecUnitJob {
    /* The module subscribed to the event */
    RedisModule *module;
    RedisModulePostNotificationJobFunc callback;
    void *pd;
    void (*free_pd)(void*);
    int dbid;
} RedisModulePostExecUnitJob;",3,module.c,RedisModulePostExecUnitJob,,false,337,RedisModulePostExecUnitJob,46
165175,TYPE_DECL,RedisModuleDict,,,"typedef struct RedisModuleDict {
    rax *rax;                       /* The radix tree. */
}",1,module.c,RedisModuleDict,,false,346,RedisModuleDict,49
165177,TYPE_DECL,RedisModuleDict,,,"typedef struct RedisModuleDict {
    rax *rax;                       /* The radix tree. */
} RedisModuleDict;",3,module.c,RedisModuleDict,,false,348,RedisModuleDict,50
165178,TYPE_DECL,RedisModuleDictIter,,,"typedef struct RedisModuleDictIter {
    RedisModuleDict *dict;
    raxIterator ri;
}",1,module.c,RedisModuleDictIter,,false,350,RedisModuleDictIter,51
165181,TYPE_DECL,RedisModuleDictIter,,,"typedef struct RedisModuleDictIter {
    RedisModuleDict *dict;
    raxIterator ri;
} RedisModuleDictIter;",3,module.c,RedisModuleDictIter,,false,353,RedisModuleDictIter,52
165182,TYPE_DECL,RedisModuleCommandFilterCtx,,,"typedef struct RedisModuleCommandFilterCtx {
    RedisModuleString **argv;
    int argv_len;
    int argc;
    client *c;
}",1,module.c,RedisModuleCommandFilterCtx,,false,355,RedisModuleCommandFilterCtx,53
165187,TYPE_DECL,RedisModuleCommandFilterCtx,,,"typedef struct RedisModuleCommandFilterCtx {
    RedisModuleString **argv;
    int argv_len;
    int argc;
    client *c;
} RedisModuleCommandFilterCtx;",3,module.c,RedisModuleCommandFilterCtx,,false,360,RedisModuleCommandFilterCtx,54
165193,TYPE_DECL,RedisModuleCommandFilter,,,"typedef struct RedisModuleCommandFilter {
    /* The module that registered the filter */
    RedisModule *module;
    /* Filter callback function */
    RedisModuleCommandFilterFunc callback;
    /* REDISMODULE_CMDFILTER_* flags */
    int flags;
}",1,module.c,RedisModuleCommandFilter,,false,364,RedisModuleCommandFilter,56
165197,TYPE_DECL,RedisModuleCommandFilter,,,"typedef struct RedisModuleCommandFilter {
    /* The module that registered the filter */
    RedisModule *module;
    /* Filter callback function */
    RedisModuleCommandFilterFunc callback;
    /* REDISMODULE_CMDFILTER_* flags */
    int flags;
} RedisModuleCommandFilter;",3,module.c,RedisModuleCommandFilter,,false,371,RedisModuleCommandFilter,57
165206,TYPE_DECL,moduleForkInfo,,,"static struct RedisModuleForkInfo {
    RedisModuleForkDoneHandler done_handler;
    void* done_handler_user_data;
}",1,module.c,RedisModuleForkInfo,,false,378,RedisModuleForkInfo,60
165214,TYPE_DECL,RedisModuleServerInfoData,,,"typedef struct RedisModuleServerInfoData {
    rax *rax;                       /* parsed info data. */
}",1,module.c,RedisModuleServerInfoData,,false,383,RedisModuleServerInfoData,63
165216,TYPE_DECL,RedisModuleServerInfoData,,,"typedef struct RedisModuleServerInfoData {
    rax *rax;                       /* parsed info data. */
} RedisModuleServerInfoData;",3,module.c,RedisModuleServerInfoData,,false,385,RedisModuleServerInfoData,64
165217,TYPE_DECL,RedisModuleEventListener,,,"typedef struct RedisModuleEventListener {
    RedisModule *module;
    RedisModuleEvent event;
    RedisModuleEventCallback callback;
}",1,module.c,RedisModuleEventListener,,false,413,RedisModuleEventListener,65
165221,TYPE_DECL,RedisModuleEventListener,,,"typedef struct RedisModuleEventListener {
    RedisModule *module;
    RedisModuleEvent event;
    RedisModuleEventCallback callback;
} RedisModuleEventListener;",3,module.c,RedisModuleEventListener,,false,417,RedisModuleEventListener,66
165223,TYPE_DECL,RedisModuleUser,,,"typedef struct RedisModuleUser {
    user *user; /* Reference to the real redis user */
    int free_user; /* Indicates that user should also be freed when this object is freed */
}",1,module.c,RedisModuleUser,,false,426,RedisModuleUser,68
165226,TYPE_DECL,RedisModuleUser,,,"typedef struct RedisModuleUser {
    user *user; /* Reference to the real redis user */
    int free_user; /* Indicates that user should also be freed when this object is freed */
} RedisModuleUser;",3,module.c,RedisModuleUser,,false,429,RedisModuleUser,69
165227,TYPE_DECL,RedisModuleKeyOptCtx,,,"typedef struct RedisModuleKeyOptCtx {
    struct redisObject *from_key, *to_key; /* Optional name of key processed, NULL when unknown. 
                                              In most cases, only 'from_key' is valid, but in callbacks 
                                              such as `copy2`, both 'from_key' and 'to_key' are valid. */
    int from_dbid, to_dbid;                /* The dbid of the key being processed, -1 when unknown.
                                              In most cases, only 'from_dbid' is valid, but in callbacks such 
                                              as `copy2`, 'from_dbid' and 'to_dbid' are both valid. */
}",1,module.c,RedisModuleKeyOptCtx,,false,432,RedisModuleKeyOptCtx,70
165228,TYPE_DECL,from_key,,,struct redisObject,5,module.c,RedisModuleKeyOptCtx.redisObject,,false,433,redisObject,1
165233,TYPE_DECL,RedisModuleKeyOptCtx,,,"typedef struct RedisModuleKeyOptCtx {
    struct redisObject *from_key, *to_key; /* Optional name of key processed, NULL when unknown. 
                                              In most cases, only 'from_key' is valid, but in callbacks 
                                              such as `copy2`, both 'from_key' and 'to_key' are valid. */
    int from_dbid, to_dbid;                /* The dbid of the key being processed, -1 when unknown.
                                              In most cases, only 'from_dbid' is valid, but in callbacks such 
                                              as `copy2`, 'from_dbid' and 'to_dbid' are both valid. */
} RedisModuleKeyOptCtx;",3,module.c,RedisModuleKeyOptCtx,,false,439,RedisModuleKeyOptCtx,71
165297,TYPE_DECL,,,,"struct ModuleConfig {
    sds name; /* Name of config without the module name appended to the front */
    void *privdata; /* Optional data passed into the module config callbacks */
    union get_fn { /* The get callback specified by the module */
        RedisModuleConfigGetStringFunc get_string;
        RedisModuleConfigGetNumericFunc get_numeric;
        RedisModuleConfigGetBoolFunc get_bool;
        RedisModuleConfigGetEnumFunc get_enum;
    } get_fn;
    union set_fn { /* The set callback specified by the module */
        RedisModuleConfigSetStringFunc set_string;
        RedisModuleConfigSetNumericFunc set_numeric;
        RedisModuleConfigSetBoolFunc set_bool;
        RedisModuleConfigSetEnumFunc set_enum;
    } set_fn;
    RedisModuleConfigApplyFunc apply_fn;
    RedisModule *module;
}",1,module.c,ModuleConfig,,false,456,ModuleConfig,81
165300,TYPE_DECL,get_fn,,,"union get_fn { /* The get callback specified by the module */
        RedisModuleConfigGetStringFunc get_string;
        RedisModuleConfigGetNumericFunc get_numeric;
        RedisModuleConfigGetBoolFunc get_bool;
        RedisModuleConfigGetEnumFunc get_enum;
    }",5,module.c,ModuleConfig.get_fn,,false,459,get_fn,3
165306,TYPE_DECL,set_fn,,,"union set_fn { /* The set callback specified by the module */
        RedisModuleConfigSetStringFunc set_string;
        RedisModuleConfigSetNumericFunc set_numeric;
        RedisModuleConfigSetBoolFunc set_bool;
        RedisModuleConfigSetEnumFunc set_enum;
    }",5,module.c,ModuleConfig.set_fn,,false,465,set_fn,5
165314,TYPE_DECL,RedisModuleAsyncRMCallPromise,,,"typedef struct RedisModuleAsyncRMCallPromise{
    size_t ref_count;
    void *private_data;
    RedisModule *module;
    RedisModuleOnUnblocked on_unblocked;
    client *c;
    RedisModuleCtx *ctx;
}",1,module.c,RedisModuleAsyncRMCallPromise,,false,475,RedisModuleAsyncRMCallPromise,82
165321,TYPE_DECL,RedisModuleAsyncRMCallPromise,,,"typedef struct RedisModuleAsyncRMCallPromise{
    size_t ref_count;
    void *private_data;
    RedisModule *module;
    RedisModuleOnUnblocked on_unblocked;
    client *c;
    RedisModuleCtx *ctx;
} RedisModuleAsyncRMCallPromise;",3,module.c,RedisModuleAsyncRMCallPromise,,false,482,RedisModuleAsyncRMCallPromise,83
165390,TYPE_DECL,moduleCopyCommandArgs,,,static struct redisCommandArg,1,module.c,redisCommandArg,,false,503,redisCommandArg,96
187471,TYPE_DECL,moduleClusterReceiver,,,"typedef struct moduleClusterReceiver {
    uint64_t module_id;
    RedisModuleClusterMessageReceiver callback;
    struct RedisModule *module;
    struct moduleClusterReceiver *next;
}",1,module.c,moduleClusterReceiver,,false,8758,moduleClusterReceiver,428
187474,TYPE_DECL,module,,,struct RedisModule,5,module.c,moduleClusterReceiver.RedisModule,,false,8761,RedisModule,3
187476,TYPE_DECL,next,,,struct moduleClusterReceiver,5,module.c,moduleClusterReceiver.moduleClusterReceiver,,false,8762,moduleClusterReceiver,5
187478,TYPE_DECL,moduleClusterReceiver,,,"typedef struct moduleClusterReceiver {
    uint64_t module_id;
    RedisModuleClusterMessageReceiver callback;
    struct RedisModule *module;
    struct moduleClusterReceiver *next;
} moduleClusterReceiver;",3,module.c,moduleClusterReceiver,,false,8763,moduleClusterReceiver,429
187479,TYPE_DECL,mdouleClusterNodeInfo,,,"typedef struct moduleClusterNodeInfo {
    int flags;
    char ip[NET_IP_STR_LEN];
    int port;
    char master_id[40]; /* Only if flags & REDISMODULE_NODE_MASTER is true. */
}",1,module.c,moduleClusterNodeInfo,,false,8765,moduleClusterNodeInfo,430
187494,TYPE_DECL,moduleClusterNodeInfo,,,"typedef struct moduleClusterNodeInfo {
    int flags;
    char ip[NET_IP_STR_LEN];
    int port;
    char master_id[40]; /* Only if flags & REDISMODULE_NODE_MASTER is true. */
} mdouleClusterNodeInfo;",3,module.c,mdouleClusterNodeInfo,,false,8770,mdouleClusterNodeInfo,431
188222,TYPE_DECL,RedisModuleTimer,,,"typedef struct RedisModuleTimer {
    RedisModule *module;                /* Module reference. */
    RedisModuleTimerProc callback;      /* The callback to invoke on expire. */
    void *data;                         /* Private data for the callback. */
    int dbid;                           /* Database number selected by the original client. */
}",1,module.c,RedisModuleTimer,,false,9025,RedisModuleTimer,447
188227,TYPE_DECL,RedisModuleTimer,,,"typedef struct RedisModuleTimer {
    RedisModule *module;                /* Module reference. */
    RedisModuleTimerProc callback;      /* The callback to invoke on expire. */
    void *data;                         /* Private data for the callback. */
    int dbid;                           /* Database number selected by the original client. */
} RedisModuleTimer;",3,module.c,RedisModuleTimer,,false,9030,RedisModuleTimer,448
188733,TYPE_DECL,EventLoopData,,,"typedef struct EventLoopData {
    RedisModuleEventLoopFunc rFunc;
    RedisModuleEventLoopFunc wFunc;
    void *user_data;
}",1,module.c,EventLoopData,,false,9194,EventLoopData,454
188737,TYPE_DECL,EventLoopData,,,"typedef struct EventLoopData {
    RedisModuleEventLoopFunc rFunc;
    RedisModuleEventLoopFunc wFunc;
    void *user_data;
} EventLoopData;",3,module.c,EventLoopData,,false,9198,EventLoopData,455
188738,TYPE_DECL,EventLoopOneShot,,,"typedef struct EventLoopOneShot {
    RedisModuleEventLoopOneShotFunc func;
    void *user_data;
}",1,module.c,EventLoopOneShot,,false,9200,EventLoopOneShot,456
188741,TYPE_DECL,EventLoopOneShot,,,"typedef struct EventLoopOneShot {
    RedisModuleEventLoopOneShotFunc func;
    void *user_data;
} EventLoopOneShot;",3,module.c,EventLoopOneShot,,false,9203,EventLoopOneShot,457
192811,TYPE_DECL,ScanCBData,,,"typedef struct {
    RedisModuleCtx *ctx;
    void* user_data;
    RedisModuleScanCB fn;
}",1,module.c,ScanCBData,,false,10830,ScanCBData,553
192816,TYPE_DECL,RedisModuleScanCursor,,,"typedef struct RedisModuleScanCursor{
    unsigned long cursor;
    int done;
}",1,module.c,RedisModuleScanCursor,,false,10836,RedisModuleScanCursor,555
192819,TYPE_DECL,RedisModuleScanCursor,,,"typedef struct RedisModuleScanCursor{
    unsigned long cursor;
    int done;
}RedisModuleScanCursor;",2,module.c,RedisModuleScanCursor,,false,10839,RedisModuleScanCursor,556
193006,TYPE_DECL,ScanKeyCBData,,,"typedef struct {
    RedisModuleKey *key;
    void* user_data;
    RedisModuleScanKeyCB fn;
}",1,module.c,ScanKeyCBData,,false,10949,ScanKeyCBData,563
194110,TYPE_DECL,KeyInfo,,,"typedef struct KeyInfo {
    int32_t dbnum;
    RedisModuleString *key;
    robj *value;
    int mode;
}",1,module.c,KeyInfo,,false,11595,KeyInfo,577
194115,TYPE_DECL,KeyInfo,,,"typedef struct KeyInfo {
    int32_t dbnum;
    RedisModuleString *key;
    robj *value;
    int mode;
} KeyInfo;",3,module.c,KeyInfo,,false,11600,KeyInfo,578
198709,TYPE_DECL,RedisModuleRdbStream,,,"typedef struct RedisModuleRdbStream {
    int type;

    union {
        char *filename;
    } data;
}",1,module.c,RedisModuleRdbStream,,false,12842,RedisModuleRdbStream,638
198711,TYPE_DECL,data,,,"union {
        char *filename;
    }",5,module.c,RedisModuleRdbStream.data,,false,12845,RedisModuleRdbStream.data,2
198714,TYPE_DECL,RedisModuleRdbStream,,,"typedef struct RedisModuleRdbStream {
    int type;

    union {
        char *filename;
    } data;
} RedisModuleRdbStream;",3,module.c,RedisModuleRdbStream,,false,12848,RedisModuleRdbStream,639
199864,TYPE_DECL,,,,"struct RedisModuleDefragCtx {
    long long int endtime;
    unsigned long *cursor;
    struct redisObject *key; /* Optional name of key processed, NULL when unknown. */
    int dbid;                /* The dbid of the key being processed, -1 when unknown. */
}",1,module.c,RedisModuleDefragCtx,,false,13291,RedisModuleDefragCtx,659
199867,TYPE_DECL,key,,,struct redisObject,5,module.c,RedisModuleDefragCtx.redisObject,,false,13294,redisObject,3
203397,TYPE_DECL,,modules\helloacl.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\helloacl.c,modules\helloacl.c:<global>,,false,1,<global>,4
203864,TYPE_DECL,,modules\helloblock.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\helloblock.c,modules\helloblock.c:<global>,,false,1,<global>,6
204342,TYPE_DECL,,modules\hellocluster.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\hellocluster.c,modules\hellocluster.c:<global>,,false,1,<global>,6
204627,TYPE_DECL,,modules\hellodict.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\hellodict.c,modules\hellodict.c:<global>,,false,1,<global>,6
204909,TYPE_DECL,,modules\hellohook.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\hellohook.c,modules\hellohook.c:<global>,,false,1,<global>,6
205103,TYPE_DECL,,modules\hellotimer.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\hellotimer.c,modules\hellotimer.c:<global>,,false,1,<global>,6
205262,TYPE_DECL,,modules\hellotype.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\hellotype.c,modules\hellotype.c:<global>,,false,1,<global>,7
205266,TYPE_DECL,,,,"struct HelloTypeNode {
    int64_t value;
    struct HelloTypeNode *next;
}",1,modules\hellotype.c,HelloTypeNode,,false,53,HelloTypeNode,2
205268,TYPE_DECL,next,,,struct HelloTypeNode,5,modules\hellotype.c,HelloTypeNode.HelloTypeNode,,false,55,HelloTypeNode,2
205270,TYPE_DECL,,,,"struct HelloTypeObject {
    struct HelloTypeNode *head;
    size_t len; /* Number of elements added. */
}",1,modules\hellotype.c,HelloTypeObject,,false,58,HelloTypeObject,3
205271,TYPE_DECL,head,,,struct HelloTypeNode,5,modules\hellotype.c,HelloTypeObject.HelloTypeNode,,false,59,HelloTypeNode,1
206288,TYPE_DECL,,modules\helloworld.c:<global>,NAMESPACE_BLOCK,<global>,1,modules\helloworld.c,modules\helloworld.c:<global>,,false,1,<global>,6
208088,TYPE_DECL,,monotonic.c:<global>,NAMESPACE_BLOCK,<global>,1,monotonic.c,monotonic.c:<global>,,false,1,<global>,9
208193,TYPE_DECL,,monotonic.h:<global>,NAMESPACE_BLOCK,<global>,1,monotonic.h,monotonic.h:<global>,,false,1,<global>,4
208196,TYPE_DECL,ANY,,,typedef uint64_t monotime;,18,monotonic.h,monotime,,false,22,monotime,1
208202,TYPE_DECL,monotonic_clock_type,,,"typedef enum monotonic_clock_type {
    MONOTONIC_CLOCK_POSIX,
    MONOTONIC_CLOCK_HW,
}",1,monotonic.h,monotonic_clock_type,,false,27,monotonic_clock_type,3
208205,TYPE_DECL,monotonic_clock_type,,,"typedef enum monotonic_clock_type {
    MONOTONIC_CLOCK_POSIX,
    MONOTONIC_CLOCK_HW,
} monotonic_clock_type;",3,monotonic.h,monotonic_clock_type,,false,30,monotonic_clock_type,4
208255,TYPE_DECL,,mt19937-64.c:<global>,NAMESPACE_BLOCK,<global>,1,mt19937-64.c,mt19937-64.c:<global>,,false,1,<global>,3
208766,TYPE_DECL,,mt19937-64.h:<global>,NAMESPACE_BLOCK,<global>,1,mt19937-64.h,mt19937-64.h:<global>,,false,1,<global>,1
208814,TYPE_DECL,,multi.c:<global>,NAMESPACE_BLOCK,<global>,1,multi.c,multi.c:<global>,,false,1,<global>,2
209709,TYPE_DECL,watchedKey,,,"typedef struct watchedKey {
    listNode node;
    robj *key;
    redisDb *db;
    client *client;
    unsigned expired:1; /* Flag that we're watching an already expired key. */
}",1,multi.c,watchedKey,,false,274,watchedKey,10
209715,TYPE_DECL,watchedKey,,,"typedef struct watchedKey {
    listNode node;
    robj *key;
    redisDb *db;
    client *client;
    unsigned expired:1; /* Flag that we're watching an already expired key. */
} watchedKey;",3,multi.c,watchedKey,,false,280,watchedKey,11
210505,TYPE_DECL,,networking.c:<global>,NAMESPACE_BLOCK,<global>,1,networking.c,networking.c:<global>,,false,1,<global>,10
225363,TYPE_DECL,threads_pending,,,"typedef struct __attribute__((aligned(CACHE_LINE_SIZE))) threads_pending {
    redisAtomic unsigned long value;
}",1,networking.c,threads_pending,,false,4149,threads_pending,145
225365,TYPE_DECL,threads_pending,,,"typedef struct __attribute__((aligned(CACHE_LINE_SIZE))) threads_pending {
    redisAtomic unsigned long value;
} threads_pending;",3,networking.c,threads_pending,,false,4151,threads_pending,146
226818,TYPE_DECL,,notify.c:<global>,NAMESPACE_BLOCK,<global>,1,notify.c,notify.c:<global>,,false,1,<global>,2
227522,TYPE_DECL,,object.c:<global>,NAMESPACE_BLOCK,<global>,1,object.c,object.c:<global>,,false,1,<global>,6
234269,TYPE_DECL,,pqsort.c:<global>,NAMESPACE_BLOCK,<global>,1,pqsort.c,pqsort.c:<global>,,false,1,<global>,5
235173,TYPE_DECL,,pqsort.h:<global>,NAMESPACE_BLOCK,<global>,1,pqsort.h,pqsort.h:<global>,,false,1,<global>,1
235192,TYPE_DECL,,pubsub.c:<global>,NAMESPACE_BLOCK,<global>,1,pubsub.c,pubsub.c:<global>,,false,1,<global>,3
235195,TYPE_DECL,pubsubtype,,,"typedef struct pubsubtype {
    int shard;
    dict *(*clientPubSubChannels)(client*);
    int (*subscriptionCount)(client*);
    dict **serverPubSubChannels;
    robj **subscribeMsg;
    robj **unsubscribeMsg;
    robj **messageBulk;
}",1,pubsub.c,pubsubtype,,false,35,pubsubtype,1
235211,TYPE_DECL,pubsubtype,,,"typedef struct pubsubtype {
    int shard;
    dict *(*clientPubSubChannels)(client*);
    int (*subscriptionCount)(client*);
    dict **serverPubSubChannels;
    robj **subscribeMsg;
    robj **unsubscribeMsg;
    robj **messageBulk;
}pubsubtype;",2,pubsub.c,pubsubtype,,false,43,pubsubtype,2
237813,TYPE_DECL,,quicklist.c:<global>,NAMESPACE_BLOCK,<global>,1,quicklist.c,quicklist.c:<global>,,false,1,<global>,15
243720,TYPE_DECL,,quicklist.h:<global>,NAMESPACE_BLOCK,<global>,1,quicklist.h,quicklist.h:<global>,,false,1,<global>,2
243723,TYPE_DECL,quicklistNode,,,"typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *entry;
    size_t sz;             /* entry size in bytes */
    unsigned int count : 16;     /* count of items in listpack */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* PLAIN==1 or PACKED==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */
    unsigned int extra : 9; /* more bits to steal for future usage */
}",1,quicklist.h,quicklistNode,,false,46,quicklistNode,1
243724,TYPE_DECL,prev,,,struct quicklistNode,5,quicklist.h,quicklistNode.quicklistNode,,false,47,quicklistNode,1
243726,TYPE_DECL,next,,,struct quicklistNode,5,quicklist.h,quicklistNode.quicklistNode,,false,48,quicklistNode,3
243737,TYPE_DECL,quicklistNode,,,"typedef struct quicklistNode {
    struct quicklistNode *prev;
    struct quicklistNode *next;
    unsigned char *entry;
    size_t sz;             /* entry size in bytes */
    unsigned int count : 16;     /* count of items in listpack */
    unsigned int encoding : 2;   /* RAW==1 or LZF==2 */
    unsigned int container : 2;  /* PLAIN==1 or PACKED==2 */
    unsigned int recompress : 1; /* was this node previous compressed? */
    unsigned int attempted_compress : 1; /* node can't compress; too small */
    unsigned int dont_compress : 1; /* prevent compression of entry that will be used later */
    unsigned int extra : 9; /* more bits to steal for future usage */
} quicklistNode;",3,quicklist.h,quicklistNode,,false,58,quicklistNode,2
243738,TYPE_DECL,quicklistLZF,,,"typedef struct quicklistLZF {
    size_t sz; /* LZF size in bytes*/
    char compressed[];
}",1,quicklist.h,quicklistLZF,,false,65,quicklistLZF,3
243746,TYPE_DECL,quicklistLZF,,,"typedef struct quicklistLZF {
    size_t sz; /* LZF size in bytes*/
    char compressed[];
} quicklistLZF;",3,quicklist.h,quicklistLZF,,false,68,quicklistLZF,4
243747,TYPE_DECL,quicklistBookmark,,,"typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
}",1,quicklist.h,quicklistBookmark,,false,78,quicklistBookmark,5
243750,TYPE_DECL,quicklistBookmark,,,"typedef struct quicklistBookmark {
    quicklistNode *node;
    char *name;
} quicklistBookmark;",3,quicklist.h,quicklistBookmark,,false,81,quicklistBookmark,6
243751,TYPE_DECL,quicklist,,,"typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all listpacks */
    unsigned long len;          /* number of quicklistNodes */
    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
}",1,quicklist.h,quicklist,,false,106,quicklist,7
243765,TYPE_DECL,quicklist,,,"typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;        /* total count of all entries in all listpacks */
    unsigned long len;          /* number of quicklistNodes */
    signed int fill : QL_FILL_BITS;       /* fill factor for individual nodes */
    unsigned int compress : QL_COMP_BITS; /* depth of end nodes not to compress;0=off */
    unsigned int bookmark_count: QL_BM_BITS;
    quicklistBookmark bookmarks[];
} quicklist;",3,quicklist.h,quicklist,,false,115,quicklist,8
243766,TYPE_DECL,quicklistIter,,,"typedef struct quicklistIter {
    quicklist *quicklist;
    quicklistNode *current;
    unsigned char *zi; /* points to the current element */
    long offset; /* offset in current listpack */
    int direction;
}",1,quicklist.h,quicklistIter,,false,117,quicklistIter,9
243772,TYPE_DECL,quicklistIter,,,"typedef struct quicklistIter {
    quicklist *quicklist;
    quicklistNode *current;
    unsigned char *zi; /* points to the current element */
    long offset; /* offset in current listpack */
    int direction;
} quicklistIter;",3,quicklist.h,quicklistIter,,false,123,quicklistIter,10
243773,TYPE_DECL,quicklistEntry,,,"typedef struct quicklistEntry {
    const quicklist *quicklist;
    quicklistNode *node;
    unsigned char *zi;
    unsigned char *value;
    long long longval;
    size_t sz;
    int offset;
}",1,quicklist.h,quicklistEntry,,false,125,quicklistEntry,11
243781,TYPE_DECL,quicklistEntry,,,"typedef struct quicklistEntry {
    const quicklist *quicklist;
    quicklistNode *node;
    unsigned char *zi;
    unsigned char *value;
    long long longval;
    size_t sz;
    int offset;
} quicklistEntry;",3,quicklist.h,quicklistEntry,,false,133,quicklistEntry,12
244034,TYPE_DECL,,rand.c:<global>,NAMESPACE_BLOCK,<global>,1,rand.c,rand.c:<global>,,false,1,<global>,2
244713,TYPE_DECL,,rand.h:<global>,NAMESPACE_BLOCK,<global>,1,rand.h,rand.h:<global>,,false,1,<global>,1
244744,TYPE_DECL,,rax.c:<global>,NAMESPACE_BLOCK,<global>,1,rax.c,rax.c:<global>,,false,1,<global>,9
251835,TYPE_DECL,,rax.h:<global>,NAMESPACE_BLOCK,<global>,1,rax.h,rax.h:<global>,,false,1,<global>,2
251838,TYPE_DECL,raxNode,,,"typedef struct raxNode {
    uint32_t iskey:1;     /* Does this node contain a key? */
    uint32_t isnull:1;    /* Associated value is NULL (don't store it). */
    uint32_t iscompr:1;   /* Node is compressed. */
    uint32_t size:29;     /* Number of children, or compressed string len. */
    /* Data layout is as follows:
     *
     * If node is not compressed we have 'size' bytes, one for each children
     * character, and 'size' raxNode pointers, point to each child node.
     * Note how the character is not stored in the children but in the
     * edge of the parents:
     *
     * [header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?)
     *
     * if node is compressed (iscompr bit is 1) the node has 1 children.
     * In that case the 'size' bytes of the string stored immediately at
     * the start of the data section, represent a sequence of successive
     * nodes linked one after the other, for which only the last one in
     * the sequence is actually represented as...",1,rax.h,raxNode,,false,98,raxNode,1
251849,TYPE_DECL,raxNode,,,"typedef struct raxNode {
    uint32_t iskey:1;     /* Does this node contain a key? */
    uint32_t isnull:1;    /* Associated value is NULL (don't store it). */
    uint32_t iscompr:1;   /* Node is compressed. */
    uint32_t size:29;     /* Number of children, or compressed string len. */
    /* Data layout is as follows:
     *
     * If node is not compressed we have 'size' bytes, one for each children
     * character, and 'size' raxNode pointers, point to each child node.
     * Note how the character is not stored in the children but in the
     * edge of the parents:
     *
     * [header iscompr=0][abc][a-ptr][b-ptr][c-ptr](value-ptr?)
     *
     * if node is compressed (iscompr bit is 1) the node has 1 children.
     * In that case the 'size' bytes of the string stored immediately at
     * the start of the data section, represent a sequence of successive
     * nodes linked one after the other, for which only the last one in
     * the sequence is actually represented as...",3,rax.h,raxNode,,false,131,raxNode,2
251850,TYPE_DECL,rax,,,"typedef struct rax {
    raxNode *head;
    uint64_t numele;
    uint64_t numnodes;
}",1,rax.h,rax,,false,133,rax,3
251854,TYPE_DECL,rax,,,"typedef struct rax {
    raxNode *head;
    uint64_t numele;
    uint64_t numnodes;
} rax;",3,rax.h,rax,,false,137,rax,4
251855,TYPE_DECL,raxStack,,,"typedef struct raxStack {
    void **stack; /* Points to static_items or an heap allocated array. */
    size_t items, maxitems; /* Number of items contained and total space. */
    /* Up to RAXSTACK_STACK_ITEMS items we avoid to allocate on the heap
     * and use this static array of pointers instead. */
    void *static_items[RAX_STACK_STATIC_ITEMS];
    int oom; /* True if pushing into this stack failed for OOM at some point. */
}",1,rax.h,raxStack,,false,143,raxStack,5
251869,TYPE_DECL,raxStack,,,"typedef struct raxStack {
    void **stack; /* Points to static_items or an heap allocated array. */
    size_t items, maxitems; /* Number of items contained and total space. */
    /* Up to RAXSTACK_STACK_ITEMS items we avoid to allocate on the heap
     * and use this static array of pointers instead. */
    void *static_items[RAX_STACK_STATIC_ITEMS];
    int oom; /* True if pushing into this stack failed for OOM at some point. */
} raxStack;",3,rax.h,raxStack,,false,150,raxStack,6
251875,TYPE_DECL,raxIterator,,,"typedef struct raxIterator {
    int flags;
    rax *rt;                /* Radix tree we are iterating. */
    unsigned char *key;     /* The current string. */
    void *data;             /* Data associated to this key. */
    size_t key_len;         /* Current key length. */
    size_t key_max;         /* Max key len the current key buffer can hold. */
    unsigned char key_static_string[RAX_ITER_STATIC_LEN];
    raxNode *node;          /* Current node. Only for unsafe iteration. */
    raxStack stack;         /* Stack used for unsafe iteration. */
    raxNodeCallback node_cb; /* Optional node callback. Normally set to NULL. */
}",1,rax.h,raxIterator,,false,175,raxIterator,8
251894,TYPE_DECL,raxIterator,,,"typedef struct raxIterator {
    int flags;
    rax *rt;                /* Radix tree we are iterating. */
    unsigned char *key;     /* The current string. */
    void *data;             /* Data associated to this key. */
    size_t key_len;         /* Current key length. */
    size_t key_max;         /* Max key len the current key buffer can hold. */
    unsigned char key_static_string[RAX_ITER_STATIC_LEN];
    raxNode *node;          /* Current node. Only for unsafe iteration. */
    raxStack stack;         /* Stack used for unsafe iteration. */
    raxNodeCallback node_cb; /* Optional node callback. Normally set to NULL. */
} raxIterator;",3,rax.h,raxIterator,,false,186,raxIterator,9
252023,TYPE_DECL,,rax_malloc.h:<global>,NAMESPACE_BLOCK,<global>,1,rax_malloc.h,rax_malloc.h:<global>,,false,1,<global>,2
252064,TYPE_DECL,,rdb.c:<global>,NAMESPACE_BLOCK,<global>,1,rdb.c,rdb.c:<global>,,false,1,<global>,19
266141,TYPE_DECL,,rdb.h:<global>,NAMESPACE_BLOCK,<global>,1,rdb.h,rdb.h:<global>,,false,1,<global>,4
266451,TYPE_DECL,,redis-benchmark.c:<global>,NAMESPACE_BLOCK,<global>,1,redis-benchmark.c,redis-benchmark.c:<global>,,false,1,<global>,29
266454,TYPE_DECL,,,,struct benchmarkThread,1,redis-benchmark.c,benchmarkThread,,false,78,benchmarkThread,1
266455,TYPE_DECL,,,,struct clusterNode,1,redis-benchmark.c,clusterNode,,false,79,clusterNode,2
266456,TYPE_DECL,,,,struct redisConfig,1,redis-benchmark.c,redisConfig,,false,80,redisConfig,3
266457,TYPE_DECL,config,,,"static struct config {
    aeEventLoop *el;
    cliConnInfo conn_info;
    const char *hostsocket;
    int tls;
    struct cliSSLconfig sslconfig;
    int numclients;
    redisAtomic int liveclients;
    int requests;
    redisAtomic int requests_issued;
    redisAtomic int requests_finished;
    redisAtomic int previous_requests_finished;
    int last_printed_bytes;
    long long previous_tick;
    int keysize;
    int datasize;
    int randomkeys;
    int randomkeys_keyspacelen;
    int keepalive;
    int pipeline;
    long long start;
    long long totlatency;
    const char *title;
    list *clients;
    int quiet;
    int csv;
    int loop;
    int idlemode;
    sds input_dbnumstr;
    char *tests;
    int stdinarg; /* get last arg from stdin. (-x option) */
    int precision;
    int num_threads;
    struct benchmarkThread **threads;
    int cluster_mode;
    int cluster_node_count;
    struct clusterNode **cluster_nodes;
    struct redisConfig *redis_config;
    struct hdr_hi...",1,redis-benchmark.c,config,,false,82,config,4
266462,TYPE_DECL,sslconfig,,,struct cliSSLconfig,5,redis-benchmark.c,config.cliSSLconfig,,false,87,cliSSLconfig,5
266491,TYPE_DECL,threads,,,struct benchmarkThread,5,redis-benchmark.c,config.benchmarkThread,,false,115,benchmarkThread,34
266495,TYPE_DECL,cluster_nodes,,,struct clusterNode,5,redis-benchmark.c,config.clusterNode,,false,118,clusterNode,38
266497,TYPE_DECL,redis_config,,,struct redisConfig,5,redis-benchmark.c,config.redisConfig,,false,119,redisConfig,40
266499,TYPE_DECL,latency_histogram,,,struct hdr_histogram,5,redis-benchmark.c,config.hdr_histogram,,false,120,hdr_histogram,42
266501,TYPE_DECL,current_sec_latency_histogram,,,struct hdr_histogram,5,redis-benchmark.c,config.hdr_histogram,,false,121,hdr_histogram,44
266511,TYPE_DECL,client,,,"typedef struct _client {
    redisContext *context;
    sds obuf;
    char **randptr;         /* Pointers to :rand: strings inside the command buf */
    size_t randlen;         /* Number of pointers in client->randptr */
    size_t randfree;        /* Number of unused pointers in client->randptr */
    char **stagptr;         /* Pointers to slot hashtags (cluster mode only) */
    size_t staglen;         /* Number of pointers in client->stagptr */
    size_t stagfree;        /* Number of unused pointers in client->stagptr */
    size_t written;         /* Bytes of 'obuf' already written */
    long long start;        /* Start time of a request */
    long long latency;      /* Request latency */
    int pending;            /* Number of pending requests (replies to consume) */
    int prefix_pending;     /* If non-zero, number of pending prefix commands. Commands
                               such as auth and select are prefixed to the pipeline of
                               ben...",1,redis-benchmark.c,_client,,false,131,_client,6
266527,TYPE_DECL,cluster_node,,,struct clusterNode,5,redis-benchmark.c,_client.clusterNode,,false,149,clusterNode,16
266530,TYPE_DECL,_client*,,,"typedef struct _client {
    redisContext *context;
    sds obuf;
    char **randptr;         /* Pointers to :rand: strings inside the command buf */
    size_t randlen;         /* Number of pointers in client->randptr */
    size_t randfree;        /* Number of unused pointers in client->randptr */
    char **stagptr;         /* Pointers to slot hashtags (cluster mode only) */
    size_t staglen;         /* Number of pointers in client->stagptr */
    size_t stagfree;        /* Number of unused pointers in client->stagptr */
    size_t written;         /* Bytes of 'obuf' already written */
    long long start;        /* Start time of a request */
    long long latency;      /* Request latency */
    int pending;            /* Number of pending requests (replies to consume) */
    int prefix_pending;     /* If non-zero, number of pending prefix commands. Commands
                               such as auth and select are prefixed to the pipeline of
                               ben...",3,redis-benchmark.c,client,,false,151,client,7
266531,TYPE_DECL,benchmarkThread,,,"typedef struct benchmarkThread {
    int index;
    pthread_t thread;
    aeEventLoop *el;
}",1,redis-benchmark.c,benchmarkThread,,false,155,benchmarkThread,8
266535,TYPE_DECL,benchmarkThread,,,"typedef struct benchmarkThread {
    int index;
    pthread_t thread;
    aeEventLoop *el;
} benchmarkThread;",3,redis-benchmark.c,benchmarkThread,,false,159,benchmarkThread,9
266536,TYPE_DECL,clusterNode,,,"typedef struct clusterNode {
    char *ip;
    int port;
    sds name;
    int flags;
    sds replicate;  /* Master ID if node is a slave */
    int *slots;
    int slots_count;
    int current_slot_index;
    int *updated_slots;         /* Used by updateClusterSlotsConfiguration */
    int updated_slots_count;    /* Used by updateClusterSlotsConfiguration */
    int replicas_count;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    struct redisConfig *redis_config;
}",1,redis-benchmark.c,clusterNode,,false,162,clusterNode,10
266552,TYPE_DECL,redis_config,,,struct redisConfig,5,redis-benchmark.c,clusterNode.redisConfig,,false,180,redisConfig,16
266554,TYPE_DECL,clusterNode,,,"typedef struct clusterNode {
    char *ip;
    int port;
    sds name;
    int flags;
    sds replicate;  /* Master ID if node is a slave */
    int *slots;
    int slots_count;
    int current_slot_index;
    int *updated_slots;         /* Used by updateClusterSlotsConfiguration */
    int updated_slots_count;    /* Used by updateClusterSlotsConfiguration */
    int replicas_count;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    struct redisConfig *redis_config;
} clusterNode;",3,redis-benchmark.c,clusterNode,,false,181,clusterNode,11
266555,TYPE_DECL,redisConfig,,,"typedef struct redisConfig {
    sds save;
    sds appendonly;
}",1,redis-benchmark.c,redisConfig,,false,183,redisConfig,12
266558,TYPE_DECL,redisConfig,,,"typedef struct redisConfig {
    sds save;
    sds appendonly;
} redisConfig;",3,redis-benchmark.c,redisConfig,,false,186,redisConfig,13
274120,TYPE_DECL,,redis-check-aof.c:<global>,NAMESPACE_BLOCK,<global>,1,redis-check-aof.c,redis-check-aof.c:<global>,,false,1,<global>,6
274123,TYPE_DECL,,,,"typedef enum {
    AOF_RESP,
    AOF_RDB_PREAMBLE,
    AOF_MULTI_PART,
}",1,redis-check-aof.c,input_file_type,,false,42,input_file_type,1
275685,TYPE_DECL,,redis-check-rdb.c:<global>,NAMESPACE_BLOCK,<global>,1,redis-check-rdb.c,redis-check-rdb.c:<global>,,false,1,<global>,8
275704,TYPE_DECL,rdbstate,,,"struct {
    rio *rio;
    robj *key;                      /* Current key we are reading. */
    int key_type;                   /* Current key type if != -1. */
    unsigned long keys;             /* Number of keys processed. */
    unsigned long expires;          /* Number of keys with an expire. */
    unsigned long already_expired;  /* Number of keys already expired. */
    int doing;                      /* The state while reading the RDB. */
    int error_set;                  /* True if error is populated. */
    char error[1024];
}",1,redis-check-rdb.c,rdbstate,,false,43,rdbstate,5
277016,TYPE_DECL,,redis-cli.c:<global>,NAMESPACE_BLOCK,<global>,1,redis-cli.c,redis-cli.c:<global>,,false,1,<global>,34
277073,TYPE_DECL,orig_termios,,,static struct termios,1,redis-cli.c,termios,,false,178,termios,13
277099,TYPE_DECL,clusterManagerCommand,,,"typedef struct clusterManagerCommand {
    char *name;
    int argc;
    char **argv;
    sds stdin_arg; /* arg from stdin. (-X option) */
    int flags;
    int replicas;
    char *from;
    char *to;
    char **weight;
    int weight_argc;
    char *master_id;
    int slots;
    int timeout;
    int pipeline;
    float threshold;
    char *backup_dir;
    char *from_user;
    char *from_pass;
    int from_askpass;
}",1,redis-cli.c,clusterManagerCommand,,false,188,clusterManagerCommand,19
277119,TYPE_DECL,clusterManagerCommand,,,"typedef struct clusterManagerCommand {
    char *name;
    int argc;
    char **argv;
    sds stdin_arg; /* arg from stdin. (-X option) */
    int flags;
    int replicas;
    char *from;
    char *to;
    char **weight;
    int weight_argc;
    char *master_id;
    int slots;
    int timeout;
    int pipeline;
    float threshold;
    char *backup_dir;
    char *from_user;
    char *from_pass;
    int from_askpass;
} clusterManagerCommand;",3,redis-cli.c,clusterManagerCommand,,false,208,clusterManagerCommand,20
277128,TYPE_DECL,config,,,"static struct config {
    cliConnInfo conn_info;
    char *hostsocket;
    int tls;
    cliSSLconfig sslconfig;
    long repeat;
    long interval;
    int dbnum; /* db num currently selected */
    int interactive;
    int shutdown;
    int monitor_mode;
    int pubsub_mode;
    int blocking_state_aborted; /* used to abort monitor_mode and pubsub_mode. */
    int latency_mode;
    int latency_dist_mode;
    int latency_history;
    int lru_test_mode;
    long long lru_test_sample_size;
    int cluster_mode;
    int cluster_reissue_command;
    int cluster_send_asking;
    int slave_mode;
    int pipe_mode;
    int pipe_timeout;
    int getrdb_mode;
    int get_functions_rdb_mode;
    int stat_mode;
    int scan_mode;
    int count;
    int intrinsic_latency_mode;
    int intrinsic_latency_duration;
    sds pattern;
    char *rdb_filename;
    int bigkeys;
    int memkeys;
    unsigned memkeys_samples;
    int hotkeys;
    int stdin_lastarg; /* get last arg from stdin. (-x option) ...",1,redis-cli.c,config,,false,214,config,23
277201,TYPE_DECL,pref,,,"static struct pref {
    int hints;
}",1,redis-cli.c,pref,,false,283,pref,25
277559,TYPE_DECL,helpEntry,,,"typedef struct {
    int type;
    int argc;
    sds *argv;
    sds full;

    /* Only used for help on commands */
    struct commandDocs docs;
}",1,redis-cli.c,helpEntry,,false,414,helpEntry,47
277564,TYPE_DECL,docs,,,struct commandDocs,5,redis-cli.c,helpEntry.commandDocs,,false,421,commandDocs,5
289857,TYPE_DECL,cluster_manager,,,"static struct clusterManager {
    list *nodes;    /* List of nodes in the configuration. */
    list *errors;
    int unreachable_masters;    /* Masters we are not able to reach. */
}",1,redis-cli.c,clusterManager,,false,3596,clusterManager,137
289866,TYPE_DECL,clusterManagerNode,,,"typedef struct clusterManagerNode {
    redisContext *context;
    sds name;
    char *ip;
    int port;
    int bus_port; /* cluster-port */
    uint64_t current_epoch;
    time_t ping_sent;
    time_t ping_recv;
    int flags;
    list *flags_str; /* Flags string representations */
    sds replicate;  /* Master ID if node is a slave */
    int dirty;      /* Node has changes that can be flushed */
    uint8_t slots[CLUSTER_MANAGER_SLOTS];
    int slots_count;
    int replicas_count;
    list *friends;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    float weight;   /* Weight used by rebalance */
...",1,redis-cli.c,clusterManagerNode,,false,3605,clusterManagerNode,141
289897,TYPE_DECL,clusterManagerNode,,,"typedef struct clusterManagerNode {
    redisContext *context;
    sds name;
    char *ip;
    int port;
    int bus_port; /* cluster-port */
    uint64_t current_epoch;
    time_t ping_sent;
    time_t ping_recv;
    int flags;
    list *flags_str; /* Flags string representations */
    sds replicate;  /* Master ID if node is a slave */
    int dirty;      /* Node has changes that can be flushed */
    uint8_t slots[CLUSTER_MANAGER_SLOTS];
    int slots_count;
    int replicas_count;
    list *friends;
    sds *migrating; /* An array of sds where even strings are slots and odd
                     * strings are the destination node IDs. */
    sds *importing; /* An array of sds where even strings are slots and odd
                     * strings are the source node IDs. */
    int migrating_count; /* Length of the migrating array (migrating slots*2) */
    int importing_count; /* Length of the importing array (importing slots*2) */
    float weight;   /* Weight used by rebalance */
...",3,redis-cli.c,clusterManagerNode,,false,3630,clusterManagerNode,142
289898,TYPE_DECL,clusterManagerNodeArray,,,"typedef struct clusterManagerNodeArray {
    clusterManagerNode **nodes; /* Actual nodes array */
    clusterManagerNode **alloc; /* Pointer to the allocated memory */
    int len;                    /* Actual length of the array */
    int count;                  /* Non-NULL nodes count */
}",1,redis-cli.c,clusterManagerNodeArray,,false,3633,clusterManagerNodeArray,143
289903,TYPE_DECL,clusterManagerNodeArray,,,"typedef struct clusterManagerNodeArray {
    clusterManagerNode **nodes; /* Actual nodes array */
    clusterManagerNode **alloc; /* Pointer to the allocated memory */
    int len;                    /* Actual length of the array */
    int count;                  /* Non-NULL nodes count */
} clusterManagerNodeArray;",3,redis-cli.c,clusterManagerNodeArray,,false,3638,clusterManagerNodeArray,144
289904,TYPE_DECL,clusterManagerReshardTableItem,,,"typedef struct clusterManagerReshardTableItem {
    clusterManagerNode *source;
    int slot;
}",1,redis-cli.c,clusterManagerReshardTableItem,,false,3641,clusterManagerReshardTableItem,145
289907,TYPE_DECL,clusterManagerReshardTableItem,,,"typedef struct clusterManagerReshardTableItem {
    clusterManagerNode *source;
    int slot;
} clusterManagerReshardTableItem;",3,redis-cli.c,clusterManagerReshardTableItem,,false,3644,clusterManagerReshardTableItem,146
289908,TYPE_DECL,clusterManagerLink,,,"typedef struct clusterManagerLink {
    sds node_name;
    sds node_addr;
    int connected;
    int handshaking;
}",1,redis-cli.c,clusterManagerLink,,false,3648,clusterManagerLink,147
289913,TYPE_DECL,clusterManagerLink,,,"typedef struct clusterManagerLink {
    sds node_name;
    sds node_addr;
    int connected;
    int handshaking;
} clusterManagerLink;",3,redis-cli.c,clusterManagerLink,,false,3653,clusterManagerLink,148
290169,TYPE_DECL,clusterManagerCommandDef,,,"typedef struct clusterManagerCommandDef {
    char *name;
    clusterManagerCommandProc *proc;
    int arity;
    char *args;
    char *options;
}",1,redis-cli.c,clusterManagerCommandDef,,false,3730,clusterManagerCommandDef,193
290175,TYPE_DECL,clusterManagerCommandDef,,,"typedef struct clusterManagerCommandDef {
    char *name;
    clusterManagerCommandProc *proc;
    int arity;
    char *args;
    char *options;
} clusterManagerCommandDef;",3,redis-cli.c,clusterManagerCommandDef,,false,3736,clusterManagerCommandDef,194
290265,TYPE_DECL,clusterManagerOptionDef,,,"typedef struct clusterManagerOptionDef {
    char *name;
    char *desc;
}",1,redis-cli.c,clusterManagerOptionDef,,false,3766,clusterManagerOptionDef,197
290268,TYPE_DECL,clusterManagerOptionDef,,,"typedef struct clusterManagerOptionDef {
    char *name;
    char *desc;
} clusterManagerOptionDef;",3,redis-cli.c,clusterManagerOptionDef,,false,3769,clusterManagerOptionDef,198
308481,TYPE_DECL,,,,"struct distsamples {
    long long max;   /* Max latency to fit into this interval (usec). */
    long long count; /* Number of samples in this interval. */
    int character;   /* Associated character in visualization. */
}",1,redis-cli.c,distsamples,,false,8240,distsamples,293
310345,TYPE_DECL,typeinfo,,,"typedef struct {
    char *name;
    char *sizecmd;
    char *sizeunit;
    unsigned long long biggest;
    unsigned long long count;
    unsigned long long totalsize;
    sds biggest_key;
}",1,redis-cli.c,typeinfo,,false,8888,typeinfo,307
314082,TYPE_DECL,,redisassert.c:<global>,NAMESPACE_BLOCK,<global>,1,redisassert.c,redisassert.c:<global>,,false,1,<global>,4
314127,TYPE_DECL,,redisassert.h:<global>,NAMESPACE_BLOCK,<global>,1,redisassert.h,redisassert.h:<global>,,false,1,<global>,2
314154,TYPE_DECL,,redismodule.h:<global>,NAMESPACE_BLOCK,<global>,1,redismodule.h,redismodule.h:<global>,,false,1,<global>,5
314157,TYPE_DECL,RedisModuleString,,,typedef struct RedisModuleString,1,redismodule.h,RedisModuleString,,false,10,RedisModuleString,1
314158,TYPE_DECL,RedisModuleString,,,typedef struct RedisModuleString RedisModuleString;,34,redismodule.h,RedisModuleString,,false,10,RedisModuleString,2
314159,TYPE_DECL,RedisModuleKey,,,typedef struct RedisModuleKey,1,redismodule.h,RedisModuleKey,,false,11,RedisModuleKey,3
314160,TYPE_DECL,RedisModuleKey,,,typedef struct RedisModuleKey RedisModuleKey;,31,redismodule.h,RedisModuleKey,,false,11,RedisModuleKey,4
314161,TYPE_DECL,long long int,,,typedef long long mstime_t;,19,redismodule.h,mstime_t,,false,26,mstime_t,5
314162,TYPE_DECL,long long int,,,typedef long long ustime_t;,19,redismodule.h,ustime_t,,false,27,ustime_t,6
314163,TYPE_DECL,RedisModuleStreamID,,,"typedef struct RedisModuleStreamID {
    uint64_t ms;
    uint64_t seq;
}",1,redismodule.h,RedisModuleStreamID,,false,133,RedisModuleStreamID,7
314166,TYPE_DECL,RedisModuleStreamID,,,"typedef struct RedisModuleStreamID {
    uint64_t ms;
    uint64_t seq;
} RedisModuleStreamID;",3,redismodule.h,RedisModuleStreamID,,false,136,RedisModuleStreamID,8
314167,TYPE_DECL,ANY,,,typedef uint64_t RedisModuleTimerID;,18,redismodule.h,RedisModuleTimerID,,false,285,RedisModuleTimerID,9
314168,TYPE_DECL,,,,"typedef enum {
    REDISMODULE_ARG_TYPE_STRING,
    REDISMODULE_ARG_TYPE_INTEGER,
    REDISMODULE_ARG_TYPE_DOUBLE,
    REDISMODULE_ARG_TYPE_KEY, /* A string, but represents a keyname */
    REDISMODULE_ARG_TYPE_PATTERN,
    REDISMODULE_ARG_TYPE_UNIX_TIME,
    REDISMODULE_ARG_TYPE_PURE_TOKEN,
    REDISMODULE_ARG_TYPE_ONEOF, /* Must have sub-arguments */
    REDISMODULE_ARG_TYPE_BLOCK /* Must have sub-arguments */
}",1,redismodule.h,RedisModuleCommandArgType,,false,314,RedisModuleCommandArgType,10
314179,TYPE_DECL,,,,"typedef enum {
    REDISMODULE_KSPEC_BS_INVALID = 0, /* Must be zero. An implicitly value of
                                       * zero is provided when the field is
                                       * absent in a struct literal. */
    REDISMODULE_KSPEC_BS_UNKNOWN,
    REDISMODULE_KSPEC_BS_INDEX,
    REDISMODULE_KSPEC_BS_KEYWORD
}",1,redismodule.h,RedisModuleKeySpecBeginSearchType,,false,332,RedisModuleKeySpecBeginSearchType,12
314192,TYPE_DECL,,,,"typedef enum {
    REDISMODULE_KSPEC_FK_OMITTED = 0, /* Used when the field is absent in a
                                       * struct literal. Don't use this value
                                       * explicitly. */
    REDISMODULE_KSPEC_FK_UNKNOWN,
    REDISMODULE_KSPEC_FK_RANGE,
    REDISMODULE_KSPEC_FK_KEYNUM
}",1,redismodule.h,RedisModuleKeySpecFindKeysType,,false,341,RedisModuleKeySpecFindKeysType,14
314205,TYPE_DECL,RedisModuleCommandArg,,,"typedef struct RedisModuleCommandArg {
    const char *name;
    RedisModuleCommandArgType type;
    int key_spec_index;       /* If type is KEY, this is a zero-based index of
                               * the key_spec in the command. For other types,
                               * you may specify -1. */
    const char *token;        /* If type is PURE_TOKEN, this is the token. */
    const char *summary;
    const char *since;
    int flags;                /* The REDISMODULE_CMD_ARG_* macros. */
    const char *deprecated_since;
    struct RedisModuleCommandArg *subargs;
    const char *display_text;
}",1,redismodule.h,RedisModuleCommandArg,,false,371,RedisModuleCommandArg,16
314214,TYPE_DECL,subargs,,,struct RedisModuleCommandArg,5,redismodule.h,RedisModuleCommandArg.RedisModuleCommandArg,,false,382,RedisModuleCommandArg,9
314217,TYPE_DECL,RedisModuleCommandArg,,,"typedef struct RedisModuleCommandArg {
    const char *name;
    RedisModuleCommandArgType type;
    int key_spec_index;       /* If type is KEY, this is a zero-based index of
                               * the key_spec in the command. For other types,
                               * you may specify -1. */
    const char *token;        /* If type is PURE_TOKEN, this is the token. */
    const char *summary;
    const char *since;
    int flags;                /* The REDISMODULE_CMD_ARG_* macros. */
    const char *deprecated_since;
    struct RedisModuleCommandArg *subargs;
    const char *display_text;
} RedisModuleCommandArg;",3,redismodule.h,RedisModuleCommandArg,,false,384,RedisModuleCommandArg,17
314218,TYPE_DECL,RedisModuleCommandHistoryEntry,,,"typedef struct {
    const char *since;
    const char *changes;
}",1,redismodule.h,RedisModuleCommandHistoryEntry,,false,386,RedisModuleCommandHistoryEntry,18
314222,TYPE_DECL,RedisModuleCommandKeySpec,,,"typedef struct {
    const char *notes;
    uint64_t flags; /* REDISMODULE_CMD_KEY_* macros. */
    RedisModuleKeySpecBeginSearchType begin_search_type;
    union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    } bs;
    RedisModuleKeySpecFindKeysType find_keys_type;
    union {
        struct {
            /* Index of the last key relative to the result of the begin search
             * step. Can be negative, in which case it's not relative. -1
             * indicating till the last argument, -2 one before the la...",1,redismodule.h,RedisModuleCommandKeySpec,,false,391,RedisModuleCommandKeySpec,20
314226,TYPE_DECL,bs,,,"union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    }",5,redismodule.h,RedisModuleCommandKeySpec.bs,,false,395,RedisModuleCommandKeySpec.bs,4
314227,TYPE_DECL,index,,,"struct {
            /* The index from which we start the search for keys */
            int pos;
        }",9,redismodule.h,RedisModuleCommandKeySpec.bs.index,,false,396,RedisModuleCommandKeySpec.bs.index,1
314230,TYPE_DECL,keyword,,,"struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        }",9,redismodule.h,RedisModuleCommandKeySpec.bs.keyword,,false,400,RedisModuleCommandKeySpec.bs.keyword,3
314236,TYPE_DECL,fk,,,"union {
        struct {
            /* Index of the last key relative to the result of the begin search
             * step. Can be negative, in which case it's not relative. -1
             * indicating till the last argument, -2 one before the last and so
             * on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to
             * find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0
             * and 1 mean no limit. 2 means 1/2 of the remaining args, 3 means
             * 1/3, and so on. */
            int limit;
        } range;
        struct {
            /* Index of the argument containing the number of keys to come
             * relative to the result of the begin search step */
            int keynumidx;
            /* Index of the fist key. (Usually it's just after keynumidx, in
             * which case it should be set to keynumidx +...",5,redismodule.h,RedisModuleCommandKeySpec.fk,,false,410,RedisModuleCommandKeySpec.fk,7
314237,TYPE_DECL,range,,,"struct {
            /* Index of the last key relative to the result of the begin search
             * step. Can be negative, in which case it's not relative. -1
             * indicating till the last argument, -2 one before the last and so
             * on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to
             * find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0
             * and 1 mean no limit. 2 means 1/2 of the remaining args, 3 means
             * 1/3, and so on. */
            int limit;
        }",9,redismodule.h,RedisModuleCommandKeySpec.fk.range,,false,411,RedisModuleCommandKeySpec.fk.range,1
314242,TYPE_DECL,keynum,,,"struct {
            /* Index of the argument containing the number of keys to come
             * relative to the result of the begin search step */
            int keynumidx;
            /* Index of the fist key. (Usually it's just after keynumidx, in
             * which case it should be set to keynumidx + 1.) */
            int firstkey;
            /* How many args should we skip after finding a key, in order to
             * find the next one, relative to the result of the begin search
             * step. */
            int keystep;
        }",9,redismodule.h,RedisModuleCommandKeySpec.fk.keynum,,false,425,RedisModuleCommandKeySpec.fk.keynum,3
314249,TYPE_DECL,RedisModuleCommandInfoVersion,,,"typedef struct {
    int version;
    size_t sizeof_historyentry;
    size_t sizeof_keyspec;
    size_t sizeof_arg;
}",1,redismodule.h,RedisModuleCommandInfoVersion,,false,440,RedisModuleCommandInfoVersion,22
314278,TYPE_DECL,RedisModuleCommandInfo,,,"typedef struct {
    /* Always set version to REDISMODULE_COMMAND_INFO_VERSION */
    const RedisModuleCommandInfoVersion *version;
    /* Version 1 fields (added in Redis 7.0.0) */
    const char *summary;          /* Summary of the command */
    const char *complexity;       /* Complexity description */
    const char *since;            /* Debut module version of the command */
    RedisModuleCommandHistoryEntry *history; /* History */
    /* A string of space-separated tips meant for clients/proxies regarding this
     * command */
    const char *tips;
    /* Number of arguments, it is possible to use -N to say >= N */
    int arity;
    RedisModuleCommandKeySpec *key_specs;
    RedisModuleCommandArg *args;
}",1,redismodule.h,RedisModuleCommandInfo,,false,456,RedisModuleCommandInfo,26
314301,TYPE_DECL,RedisModuleEvent,,,"typedef struct RedisModuleEvent {
    uint64_t id;        /* REDISMODULE_EVENT_... defines. */
    uint64_t dataver;   /* Version of the structure we pass as 'data'. */
}",1,redismodule.h,RedisModuleEvent,,false,503,RedisModuleEvent,30
314304,TYPE_DECL,RedisModuleEvent,,,"typedef struct RedisModuleEvent {
    uint64_t id;        /* REDISMODULE_EVENT_... defines. */
    uint64_t dataver;   /* Version of the structure we pass as 'data'. */
} RedisModuleEvent;",3,redismodule.h,RedisModuleEvent,,false,506,RedisModuleEvent,31
314305,TYPE_DECL,,,,struct RedisModuleCtx,1,redismodule.h,RedisModuleCtx,,false,508,RedisModuleCtx,32
314306,TYPE_DECL,,,,struct RedisModuleDefragCtx,1,redismodule.h,RedisModuleDefragCtx,,false,509,RedisModuleDefragCtx,33
314459,TYPE_DECL,RedisModuleClientInfoV1,,,"typedef struct RedisModuleClientInfo {
    uint64_t version;       /* Version of this structure for ABI compat. */
    uint64_t flags;         /* REDISMODULE_CLIENTINFO_FLAG_* */
    uint64_t id;            /* Client ID. */
    char addr[46];          /* IPv4 or IPv6 address. */
    uint16_t port;          /* TCP port. */
    uint16_t db;            /* Selected DB. */
}",1,redismodule.h,RedisModuleClientInfo,,false,714,RedisModuleClientInfo,71
314472,TYPE_DECL,RedisModuleClientInfo,,,"typedef struct RedisModuleClientInfo {
    uint64_t version;       /* Version of this structure for ABI compat. */
    uint64_t flags;         /* REDISMODULE_CLIENTINFO_FLAG_* */
    uint64_t id;            /* Client ID. */
    char addr[46];          /* IPv4 or IPv6 address. */
    uint16_t port;          /* TCP port. */
    uint16_t db;            /* Selected DB. */
} RedisModuleClientInfoV1;",3,redismodule.h,RedisModuleClientInfoV1,,false,721,RedisModuleClientInfoV1,72
314473,TYPE_DECL,RedisModuleReplicationInfoV1,,,"typedef struct RedisModuleReplicationInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int master;             /* true if master, false if replica */
    char *masterhost;       /* master instance hostname for NOW_REPLICA */
    int masterport;         /* master instance port for NOW_REPLICA */
    char *replid1;          /* Main replication ID */
    char *replid2;          /* Secondary replication ID */
    uint64_t repl1_offset;  /* Main replication offset */
    uint64_t repl2_offset;  /* Offset of replid2 validity */
}",1,redismodule.h,RedisModuleReplicationInfo,,false,728,RedisModuleReplicationInfo,73
314482,TYPE_DECL,RedisModuleReplicationInfo,,,"typedef struct RedisModuleReplicationInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int master;             /* true if master, false if replica */
    char *masterhost;       /* master instance hostname for NOW_REPLICA */
    int masterport;         /* master instance port for NOW_REPLICA */
    char *replid1;          /* Main replication ID */
    char *replid2;          /* Secondary replication ID */
    uint64_t repl1_offset;  /* Main replication offset */
    uint64_t repl2_offset;  /* Offset of replid2 validity */
} RedisModuleReplicationInfoV1;",3,redismodule.h,RedisModuleReplicationInfoV1,,false,739,RedisModuleReplicationInfoV1,74
314483,TYPE_DECL,RedisModuleFlushInfoV1,,,"typedef struct RedisModuleFlushInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t sync;           /* Synchronous or threaded flush?. */
    int32_t dbnum;          /* Flushed database number, -1 for ALL. */
}",1,redismodule.h,RedisModuleFlushInfo,,false,744,RedisModuleFlushInfo,75
314487,TYPE_DECL,RedisModuleFlushInfo,,,"typedef struct RedisModuleFlushInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t sync;           /* Synchronous or threaded flush?. */
    int32_t dbnum;          /* Flushed database number, -1 for ALL. */
} RedisModuleFlushInfoV1;",3,redismodule.h,RedisModuleFlushInfoV1,,false,750,RedisModuleFlushInfoV1,76
314488,TYPE_DECL,RedisModuleModuleChangeV1,,,"typedef struct RedisModuleModuleChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    const char* module_name;/* Name of module loaded or unloaded. */
    int32_t module_version; /* Module version. */
}",1,redismodule.h,RedisModuleModuleChange,,false,755,RedisModuleModuleChange,77
314492,TYPE_DECL,RedisModuleModuleChange,,,"typedef struct RedisModuleModuleChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    const char* module_name;/* Name of module loaded or unloaded. */
    int32_t module_version; /* Module version. */
} RedisModuleModuleChangeV1;",3,redismodule.h,RedisModuleModuleChangeV1,,false,761,RedisModuleModuleChangeV1,78
314493,TYPE_DECL,RedisModuleConfigChangeV1,,,"typedef struct RedisModuleConfigChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    uint32_t num_changes;   /* how many redis config options were changed */
    const char **config_names; /* the config names that were changed */
}",1,redismodule.h,RedisModuleConfigChange,,false,766,RedisModuleConfigChange,79
314497,TYPE_DECL,RedisModuleConfigChange,,,"typedef struct RedisModuleConfigChange {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    uint32_t num_changes;   /* how many redis config options were changed */
    const char **config_names; /* the config names that were changed */
} RedisModuleConfigChangeV1;",3,redismodule.h,RedisModuleConfigChangeV1,,false,772,RedisModuleConfigChangeV1,80
314498,TYPE_DECL,RedisModuleCronLoopV1,,,"typedef struct RedisModuleCronLoopInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
}",1,redismodule.h,RedisModuleCronLoopInfo,,false,777,RedisModuleCronLoopInfo,81
314501,TYPE_DECL,RedisModuleCronLoopInfo,,,"typedef struct RedisModuleCronLoopInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
} RedisModuleCronLoopV1;",3,redismodule.h,RedisModuleCronLoopV1,,false,782,RedisModuleCronLoopV1,82
314502,TYPE_DECL,RedisModuleLoadingProgressV1,,,"typedef struct RedisModuleLoadingProgressInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
    int32_t progress;       /* Approximate progress between 0 and 1024, or -1
                             * if unknown. */
}",1,redismodule.h,RedisModuleLoadingProgressInfo,,false,787,RedisModuleLoadingProgressInfo,83
314506,TYPE_DECL,RedisModuleLoadingProgressInfo,,,"typedef struct RedisModuleLoadingProgressInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t hz;             /* Approximate number of events per second. */
    int32_t progress;       /* Approximate progress between 0 and 1024, or -1
                             * if unknown. */
} RedisModuleLoadingProgressV1;",3,redismodule.h,RedisModuleLoadingProgressV1,,false,794,RedisModuleLoadingProgressV1,84
314507,TYPE_DECL,RedisModuleSwapDbInfoV1,,,"typedef struct RedisModuleSwapDbInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t dbnum_first;    /* Swap Db first dbnum */
    int32_t dbnum_second;   /* Swap Db second dbnum */
}",1,redismodule.h,RedisModuleSwapDbInfo,,false,799,RedisModuleSwapDbInfo,85
314511,TYPE_DECL,RedisModuleSwapDbInfo,,,"typedef struct RedisModuleSwapDbInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    int32_t dbnum_first;    /* Swap Db first dbnum */
    int32_t dbnum_second;   /* Swap Db second dbnum */
} RedisModuleSwapDbInfoV1;",3,redismodule.h,RedisModuleSwapDbInfoV1,,false,805,RedisModuleSwapDbInfoV1,86
314512,TYPE_DECL,RedisModuleKeyInfoV1,,,"typedef struct RedisModuleKeyInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    RedisModuleKey *key;    /* Opened key. */
}",1,redismodule.h,RedisModuleKeyInfo,,false,810,RedisModuleKeyInfo,87
314515,TYPE_DECL,RedisModuleKeyInfo,,,"typedef struct RedisModuleKeyInfo {
    uint64_t version;       /* Not used since this structure is never passed
                               from the module to the core right now. Here
                               for future compatibility. */
    RedisModuleKey *key;    /* Opened key. */
} RedisModuleKeyInfoV1;",3,redismodule.h,RedisModuleKeyInfoV1,,false,815,RedisModuleKeyInfoV1,88
314516,TYPE_DECL,,,,"typedef enum {
    REDISMODULE_ACL_LOG_AUTH = 0, /* Authentication failure */
    REDISMODULE_ACL_LOG_CMD, /* Command authorization failure */
    REDISMODULE_ACL_LOG_KEY, /* Key authorization failure */
    REDISMODULE_ACL_LOG_CHANNEL /* Channel authorization failure */
}",1,redismodule.h,RedisModuleACLLogEntryReason,,false,819,RedisModuleACLLogEntryReason,89
314529,TYPE_DECL,RedisModuleIO,,,typedef struct RedisModuleIO,1,redismodule.h,RedisModuleIO,,false,827,RedisModuleIO,91
314530,TYPE_DECL,RedisModuleIO,,,typedef struct RedisModuleIO RedisModuleIO;,30,redismodule.h,RedisModuleIO,,false,827,RedisModuleIO,92
314531,TYPE_DECL,RedisModuleDigest,,,typedef struct RedisModuleDigest,1,redismodule.h,RedisModuleDigest,,false,828,RedisModuleDigest,93
314532,TYPE_DECL,RedisModuleDigest,,,typedef struct RedisModuleDigest RedisModuleDigest;,34,redismodule.h,RedisModuleDigest,,false,828,RedisModuleDigest,94
314533,TYPE_DECL,RedisModuleInfoCtx,,,typedef struct RedisModuleInfoCtx,1,redismodule.h,RedisModuleInfoCtx,,false,829,RedisModuleInfoCtx,95
314534,TYPE_DECL,RedisModuleInfoCtx,,,typedef struct RedisModuleInfoCtx RedisModuleInfoCtx;,35,redismodule.h,RedisModuleInfoCtx,,false,829,RedisModuleInfoCtx,96
314535,TYPE_DECL,RedisModuleDefragCtx,,,typedef struct RedisModuleDefragCtx,1,redismodule.h,RedisModuleDefragCtx,,false,830,RedisModuleDefragCtx,97
314536,TYPE_DECL,RedisModuleDefragCtx,,,typedef struct RedisModuleDefragCtx RedisModuleDefragCtx;,37,redismodule.h,RedisModuleDefragCtx,,false,830,RedisModuleDefragCtx,98
314554,TYPE_DECL,RedisModuleCtx,,,typedef struct RedisModuleCtx,1,redismodule.h,RedisModuleCtx,,false,870,RedisModuleCtx,102
314555,TYPE_DECL,RedisModuleCtx,,,typedef struct RedisModuleCtx RedisModuleCtx;,31,redismodule.h,RedisModuleCtx,,false,870,RedisModuleCtx,103
314556,TYPE_DECL,RedisModuleCommand,,,typedef struct RedisModuleCommand,1,redismodule.h,RedisModuleCommand,,false,871,RedisModuleCommand,104
314557,TYPE_DECL,RedisModuleCommand,,,typedef struct RedisModuleCommand RedisModuleCommand;,35,redismodule.h,RedisModuleCommand,,false,871,RedisModuleCommand,105
314558,TYPE_DECL,RedisModuleCallReply,,,typedef struct RedisModuleCallReply,1,redismodule.h,RedisModuleCallReply,,false,872,RedisModuleCallReply,106
314559,TYPE_DECL,RedisModuleCallReply,,,typedef struct RedisModuleCallReply RedisModuleCallReply;,37,redismodule.h,RedisModuleCallReply,,false,872,RedisModuleCallReply,107
314560,TYPE_DECL,RedisModuleType,,,typedef struct RedisModuleType,1,redismodule.h,RedisModuleType,,false,873,RedisModuleType,108
314561,TYPE_DECL,RedisModuleType,,,typedef struct RedisModuleType RedisModuleType;,32,redismodule.h,RedisModuleType,,false,873,RedisModuleType,109
314562,TYPE_DECL,RedisModuleBlockedClient,,,typedef struct RedisModuleBlockedClient,1,redismodule.h,RedisModuleBlockedClient,,false,874,RedisModuleBlockedClient,110
314563,TYPE_DECL,RedisModuleBlockedClient,,,typedef struct RedisModuleBlockedClient RedisModuleBlockedClient;,41,redismodule.h,RedisModuleBlockedClient,,false,874,RedisModuleBlockedClient,111
314564,TYPE_DECL,RedisModuleClusterInfo,,,typedef struct RedisModuleClusterInfo,1,redismodule.h,RedisModuleClusterInfo,,false,875,RedisModuleClusterInfo,112
314565,TYPE_DECL,RedisModuleClusterInfo,,,typedef struct RedisModuleClusterInfo RedisModuleClusterInfo;,39,redismodule.h,RedisModuleClusterInfo,,false,875,RedisModuleClusterInfo,113
314566,TYPE_DECL,RedisModuleDict,,,typedef struct RedisModuleDict,1,redismodule.h,RedisModuleDict,,false,876,RedisModuleDict,114
314567,TYPE_DECL,RedisModuleDict,,,typedef struct RedisModuleDict RedisModuleDict;,32,redismodule.h,RedisModuleDict,,false,876,RedisModuleDict,115
314568,TYPE_DECL,RedisModuleDictIter,,,typedef struct RedisModuleDictIter,1,redismodule.h,RedisModuleDictIter,,false,877,RedisModuleDictIter,116
314569,TYPE_DECL,RedisModuleDictIter,,,typedef struct RedisModuleDictIter RedisModuleDictIter;,36,redismodule.h,RedisModuleDictIter,,false,877,RedisModuleDictIter,117
314570,TYPE_DECL,RedisModuleCommandFilterCtx,,,typedef struct RedisModuleCommandFilterCtx,1,redismodule.h,RedisModuleCommandFilterCtx,,false,878,RedisModuleCommandFilterCtx,118
314571,TYPE_DECL,RedisModuleCommandFilterCtx,,,typedef struct RedisModuleCommandFilterCtx RedisModuleCommandFilterCtx;,44,redismodule.h,RedisModuleCommandFilterCtx,,false,878,RedisModuleCommandFilterCtx,119
314572,TYPE_DECL,RedisModuleCommandFilter,,,typedef struct RedisModuleCommandFilter,1,redismodule.h,RedisModuleCommandFilter,,false,879,RedisModuleCommandFilter,120
314573,TYPE_DECL,RedisModuleCommandFilter,,,typedef struct RedisModuleCommandFilter RedisModuleCommandFilter;,41,redismodule.h,RedisModuleCommandFilter,,false,879,RedisModuleCommandFilter,121
314574,TYPE_DECL,RedisModuleServerInfoData,,,typedef struct RedisModuleServerInfoData,1,redismodule.h,RedisModuleServerInfoData,,false,880,RedisModuleServerInfoData,122
314575,TYPE_DECL,RedisModuleServerInfoData,,,typedef struct RedisModuleServerInfoData RedisModuleServerInfoData;,42,redismodule.h,RedisModuleServerInfoData,,false,880,RedisModuleServerInfoData,123
314576,TYPE_DECL,RedisModuleScanCursor,,,typedef struct RedisModuleScanCursor,1,redismodule.h,RedisModuleScanCursor,,false,881,RedisModuleScanCursor,124
314577,TYPE_DECL,RedisModuleScanCursor,,,typedef struct RedisModuleScanCursor RedisModuleScanCursor;,38,redismodule.h,RedisModuleScanCursor,,false,881,RedisModuleScanCursor,125
314578,TYPE_DECL,RedisModuleUser,,,typedef struct RedisModuleUser,1,redismodule.h,RedisModuleUser,,false,882,RedisModuleUser,126
314579,TYPE_DECL,RedisModuleUser,,,typedef struct RedisModuleUser RedisModuleUser;,32,redismodule.h,RedisModuleUser,,false,882,RedisModuleUser,127
314580,TYPE_DECL,RedisModuleKeyOptCtx,,,typedef struct RedisModuleKeyOptCtx,1,redismodule.h,RedisModuleKeyOptCtx,,false,883,RedisModuleKeyOptCtx,128
314581,TYPE_DECL,RedisModuleKeyOptCtx,,,typedef struct RedisModuleKeyOptCtx RedisModuleKeyOptCtx;,37,redismodule.h,RedisModuleKeyOptCtx,,false,883,RedisModuleKeyOptCtx,129
314582,TYPE_DECL,RedisModuleRdbStream,,,typedef struct RedisModuleRdbStream,1,redismodule.h,RedisModuleRdbStream,,false,884,RedisModuleRdbStream,130
314583,TYPE_DECL,RedisModuleRdbStream,,,typedef struct RedisModuleRdbStream RedisModuleRdbStream;,37,redismodule.h,RedisModuleRdbStream,,false,884,RedisModuleRdbStream,131
314831,TYPE_DECL,RedisModuleTypeMethods,,,"typedef struct RedisModuleTypeMethods {
    uint64_t version;
    RedisModuleTypeLoadFunc rdb_load;
    RedisModuleTypeSaveFunc rdb_save;
    RedisModuleTypeRewriteFunc aof_rewrite;
    RedisModuleTypeMemUsageFunc mem_usage;
    RedisModuleTypeDigestFunc digest;
    RedisModuleTypeFreeFunc free;
    RedisModuleTypeAuxLoadFunc aux_load;
    RedisModuleTypeAuxSaveFunc aux_save;
    int aux_save_triggers;
    RedisModuleTypeFreeEffortFunc free_effort;
    RedisModuleTypeUnlinkFunc unlink;
    RedisModuleTypeCopyFunc copy;
    RedisModuleTypeDefragFunc defrag;
    RedisModuleTypeMemUsageFunc2 mem_usage2;
    RedisModuleTypeFreeEffortFunc2 free_effort2;
    RedisModuleTypeUnlinkFunc2 unlink2;
    RedisModuleTypeCopyFunc2 copy2;
    RedisModuleTypeAuxSaveFunc aux_save2;
}",1,redismodule.h,RedisModuleTypeMethods,,false,924,RedisModuleTypeMethods,169
314851,TYPE_DECL,RedisModuleTypeMethods,,,"typedef struct RedisModuleTypeMethods {
    uint64_t version;
    RedisModuleTypeLoadFunc rdb_load;
    RedisModuleTypeSaveFunc rdb_save;
    RedisModuleTypeRewriteFunc aof_rewrite;
    RedisModuleTypeMemUsageFunc mem_usage;
    RedisModuleTypeDigestFunc digest;
    RedisModuleTypeFreeFunc free;
    RedisModuleTypeAuxLoadFunc aux_load;
    RedisModuleTypeAuxSaveFunc aux_save;
    int aux_save_triggers;
    RedisModuleTypeFreeEffortFunc free_effort;
    RedisModuleTypeUnlinkFunc unlink;
    RedisModuleTypeCopyFunc copy;
    RedisModuleTypeDefragFunc defrag;
    RedisModuleTypeMemUsageFunc2 mem_usage2;
    RedisModuleTypeFreeEffortFunc2 free_effort2;
    RedisModuleTypeUnlinkFunc2 unlink2;
    RedisModuleTypeCopyFunc2 copy2;
    RedisModuleTypeAuxSaveFunc aux_save2;
} RedisModuleTypeMethods;",3,redismodule.h,RedisModuleTypeMethods,,false,944,RedisModuleTypeMethods,170
319946,TYPE_DECL,,release.c:<global>,NAMESPACE_BLOCK,<global>,1,release.c,release.c:<global>,,false,1,<global>,5
320040,TYPE_DECL,,replication.c:<global>,NAMESPACE_BLOCK,<global>,1,replication.c,replication.c:<global>,,false,1,<global>,13
333306,TYPE_DECL,,resp_parser.c:<global>,NAMESPACE_BLOCK,<global>,1,resp_parser.c,resp_parser.c:<global>,,false,1,<global>,3
334226,TYPE_DECL,,resp_parser.h:<global>,NAMESPACE_BLOCK,<global>,1,resp_parser.h,resp_parser.h:<global>,,false,1,<global>,2
334229,TYPE_DECL,ReplyParser,,,typedef struct ReplyParser,1,resp_parser.h,ReplyParser,,false,35,ReplyParser,1
334230,TYPE_DECL,ReplyParser,,,typedef struct ReplyParser ReplyParser;,28,resp_parser.h,ReplyParser,,false,35,ReplyParser,2
334231,TYPE_DECL,ReplyParserCallbacks,,,"typedef struct ReplyParserCallbacks {
    /* Called when the parser reaches an empty mbulk ('*-1') */
    void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches an empty bulk ('$-1') (bulk len is -1) */
    void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches a bulk ('$'), which is passed as 'str' along with its length 'len' */
    void (*bulk_string_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches an error ('-'), which is passed as 'str' along with its length 'len' */
    void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches a simple string ('+'), which is passed as 'str' along with its length 'len' */
    void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, s...",1,resp_parser.h,ReplyParserCallbacks,,false,37,ReplyParserCallbacks,3
334360,TYPE_DECL,ReplyParserCallbacks,,,"typedef struct ReplyParserCallbacks {
    /* Called when the parser reaches an empty mbulk ('*-1') */
    void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches an empty bulk ('$-1') (bulk len is -1) */
    void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);

    /* Called when the parser reaches a bulk ('$'), which is passed as 'str' along with its length 'len' */
    void (*bulk_string_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches an error ('-'), which is passed as 'str' along with its length 'len' */
    void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);

    /* Called when the parser reaches a simple string ('+'), which is passed as 'str' along with its length 'len' */
    void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, s...",3,resp_parser.h,ReplyParserCallbacks,,false,84,ReplyParserCallbacks,4
334361,TYPE_DECL,,,,"struct ReplyParser {
    /* The current location in the reply buffer, needs to be set to the beginning of the reply */
    const char *curr_location;
    ReplyParserCallbacks callbacks;
}",1,resp_parser.h,ReplyParser,,false,86,ReplyParser,5
334392,TYPE_DECL,,rio.c:<global>,NAMESPACE_BLOCK,<global>,1,rio.c,rio.c:<global>,,false,1,<global>,11
336162,TYPE_DECL,,rio.h:<global>,NAMESPACE_BLOCK,<global>,1,rio.h,rio.h:<global>,,false,1,<global>,5
336165,TYPE_DECL,,,,"struct _rio {
    /* Backend functions.
     * Since this functions do not tolerate short writes or reads the return
     * value is simplified to: zero on error, non zero on complete success. */
    size_t (*read)(struct _rio *, void *buf, size_t len);
    size_t (*write)(struct _rio *, const void *buf, size_t len);
    off_t (*tell)(struct _rio *);
    int (*flush)(struct _rio *);
    /* The update_cksum method if not NULL is used to compute the checksum of
     * all the data that was read or written so far. The method should be
     * designed so that can be called with the current checksum, and the buf
     * and len fields pointing to the new block of data to add to the checksum
     * computation. */
    void (*update_cksum)(struct _rio *, const void *buf, size_t len);

    /* The current checksum and flags (see RIO_FLAG_*) */
    uint64_t cksum, flags;

    /* number of bytes read or written */
    size_t processed_bytes;

    /* maximum single read or write chunk size */
  ...",1,rio.h,_rio,,false,48,_rio,1
336201,TYPE_DECL,io,,,"union {
        /* In-memory buffer target. */
        struct {
            sds ptr;
            off_t pos;
        } buffer;
        /* Stdio file pointer target. */
        struct {
            FILE *fp;
            off_t buffered; /* Bytes written since last fsync. */
            off_t autosync; /* fsync after 'autosync' bytes written. */
            unsigned reclaim_cache:1; /* A flag to indicate reclaim cache after fsync */
        } file;
        /* Connection object (used to read from socket) */
        struct {
            connection *conn;   /* Connection */
            off_t pos;    /* pos in buf that was returned */
            sds buf;      /* buffered data */
            size_t read_limit;  /* don't allow to buffer/read more than that */
            size_t read_so_far; /* amount of data read from the rio (not buffered) */
        } conn;
        /* FD target (used to write to pipe). */
        struct {
            int fd;       /* File descriptor. */
            off_t p...",5,rio.h,_rio.io,,false,73,_rio.io,10
336202,TYPE_DECL,buffer,,,"struct {
            sds ptr;
            off_t pos;
        }",9,rio.h,_rio.io.buffer,,false,75,_rio.io.buffer,1
336206,TYPE_DECL,file,,,"struct {
            FILE *fp;
            off_t buffered; /* Bytes written since last fsync. */
            off_t autosync; /* fsync after 'autosync' bytes written. */
            unsigned reclaim_cache:1; /* A flag to indicate reclaim cache after fsync */
        }",9,rio.h,_rio.io.file,,false,80,_rio.io.file,3
336212,TYPE_DECL,conn,,,"struct {
            connection *conn;   /* Connection */
            off_t pos;    /* pos in buf that was returned */
            sds buf;      /* buffered data */
            size_t read_limit;  /* don't allow to buffer/read more than that */
            size_t read_so_far; /* amount of data read from the rio (not buffered) */
        }",9,rio.h,_rio.io.conn,,false,87,_rio.io.conn,5
336219,TYPE_DECL,fd,,,"struct {
            int fd;       /* File descriptor. */
            off_t pos;
            sds buf;
        }",9,rio.h,_rio.io.fd,,false,95,_rio.io.fd,7
336225,TYPE_DECL,rio,,,typedef struct _rio,1,rio.h,_rio,,false,103,_rio,2
336226,TYPE_DECL,_rio,,,typedef struct _rio rio;,21,rio.h,rio,,false,103,rio,3
336548,TYPE_DECL,,,,struct redisObject,1,rio.h,redisObject,,false,178,redisObject,21
336587,TYPE_DECL,,script.c:<global>,NAMESPACE_BLOCK,<global>,1,script.c,script.c:<global>,,false,1,<global>,4
338600,TYPE_DECL,,script.h:<global>,NAMESPACE_BLOCK,<global>,1,script.h,script.h:<global>,,false,1,<global>,1
338603,TYPE_DECL,scriptRunCtx,,,typedef struct scriptRunCtx,1,script.h,scriptRunCtx,,false,68,scriptRunCtx,1
338604,TYPE_DECL,scriptRunCtx,,,typedef struct scriptRunCtx scriptRunCtx;,29,script.h,scriptRunCtx,,false,68,scriptRunCtx,2
338605,TYPE_DECL,,,,"struct scriptRunCtx {
    const char *funcname;
    client *c;
    client *original_client;
    int flags;
    int repl_flags;
    monotime start_time;
}",1,script.h,scriptRunCtx,,false,70,scriptRunCtx,3
338612,TYPE_DECL,scriptFlag,,,"typedef struct scriptFlag {
    uint64_t flag;
    const char *str;
}",1,script.h,scriptFlag,,false,88,scriptFlag,4
338615,TYPE_DECL,scriptFlag,,,"typedef struct scriptFlag {
    uint64_t flag;
    const char *str;
} scriptFlag;",3,script.h,scriptFlag,,false,91,scriptFlag,5
338731,TYPE_DECL,,script_lua.c:<global>,NAMESPACE_BLOCK,<global>,1,script_lua.c,script_lua.c:<global>,,false,1,<global>,14
343368,TYPE_DECL,,script_lua.h:<global>,NAMESPACE_BLOCK,<global>,1,script_lua.h,script_lua.h:<global>,,false,1,<global>,6
343371,TYPE_DECL,errorInfo,,,"typedef struct errorInfo {
    sds msg;
    sds source;
    sds line;
    int ignore_err_stats_update;
}",1,script_lua.h,errorInfo,,false,61,errorInfo,1
343376,TYPE_DECL,errorInfo,,,"typedef struct errorInfo {
    sds msg;
    sds source;
    sds line;
    int ignore_err_stats_update;
}errorInfo;",2,script_lua.h,errorInfo,,false,66,errorInfo,2
343501,TYPE_DECL,,sds.c:<global>,NAMESPACE_BLOCK,<global>,1,sds.c,sds.c:<global>,,false,1,<global>,13
346962,TYPE_DECL,,sds.h:<global>,NAMESPACE_BLOCK,<global>,1,sds.h,sds.h:<global>,,false,1,<global>,4
346966,TYPE_DECL,char*,,,typedef char *sds;,14,sds.h,sds,,false,43,sds,2
346967,TYPE_DECL,,,,"struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
}",1,sds.h,sdshdr5,,false,47,sdshdr5,3
346975,TYPE_DECL,,,,"struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",1,sds.h,sdshdr8,,false,51,sdshdr8,4
346985,TYPE_DECL,,,,"struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",1,sds.h,sdshdr16,,false,57,sdshdr16,5
346995,TYPE_DECL,,,,"struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",1,sds.h,sdshdr32,,false,63,sdshdr32,6
347005,TYPE_DECL,,,,"struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
}",1,sds.h,sdshdr64,,false,69,sdshdr64,7
347949,TYPE_DECL,,sdsalloc.h:<global>,NAMESPACE_BLOCK,<global>,1,sdsalloc.h,sdsalloc.h:<global>,,false,1,<global>,2
347974,TYPE_DECL,,sentinel.c:<global>,NAMESPACE_BLOCK,<global>,1,sentinel.c,sentinel.c:<global>,,false,1,<global>,11
347978,TYPE_DECL,sentinelAddr,,,"typedef struct sentinelAddr {
    char *hostname;         /* Hostname OR address, as specified */
    char *ip;               /* Always a resolved address */
    int port;
}",1,sentinel.c,sentinelAddr,,false,57,sentinelAddr,2
347982,TYPE_DECL,sentinelAddr,,,"typedef struct sentinelAddr {
    char *hostname;         /* Hostname OR address, as specified */
    char *ip;               /* Always a resolved address */
    int port;
} sentinelAddr;",3,sentinel.c,sentinelAddr,,false,61,sentinelAddr,3
348045,TYPE_DECL,instanceLink,,,"typedef struct instanceLink {
    int refcount;          /* Number of sentinelRedisInstance owners. */
    int disconnected;      /* Non-zero if we need to reconnect cc or pc. */
    int pending_commands;  /* Number of commands sent waiting for a reply. */
    redisAsyncContext *cc; /* Hiredis context for commands. */
    redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */
    mstime_t cc_conn_time; /* cc connection time. */
    mstime_t pc_conn_time; /* pc connection time. */
    mstime_t pc_last_activity; /* Last time we received any message. */
    mstime_t last_avail_time; /* Last time the instance replied to ping with
                                 a reply we consider valid. */
    mstime_t act_ping_time;   /* Time at which the last pending ping (no pong
                                 received after it) was sent. This field is
                                 set to 0 when a pong is received, and set again
                                 to the current time if the ...",1,sentinel.c,instanceLink,,false,155,instanceLink,30
348059,TYPE_DECL,instanceLink,,,"typedef struct instanceLink {
    int refcount;          /* Number of sentinelRedisInstance owners. */
    int disconnected;      /* Non-zero if we need to reconnect cc or pc. */
    int pending_commands;  /* Number of commands sent waiting for a reply. */
    redisAsyncContext *cc; /* Hiredis context for commands. */
    redisAsyncContext *pc; /* Hiredis context for Pub / Sub. */
    mstime_t cc_conn_time; /* cc connection time. */
    mstime_t pc_conn_time; /* pc connection time. */
    mstime_t pc_last_activity; /* Last time we received any message. */
    mstime_t last_avail_time; /* Last time the instance replied to ping with
                                 a reply we consider valid. */
    mstime_t act_ping_time;   /* Time at which the last pending ping (no pong
                                 received after it) was sent. This field is
                                 set to 0 when a pong is received, and set again
                                 to the current time if the ...",3,sentinel.c,instanceLink,,false,180,instanceLink,31
348060,TYPE_DECL,sentinelRedisInstance,,,"typedef struct sentinelRedisInstance {
    int flags;      /* See SRI_... defines */
    char *name;     /* Master name from the point of view of this sentinel. */
    char *runid;    /* Run ID of this instance, or unique ID if is a Sentinel.*/
    uint64_t config_epoch;  /* Configuration epoch. */
    sentinelAddr *addr; /* Master host. */
    instanceLink *link; /* Link to the instance, may be shared for Sentinels. */
    mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */
    mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time
                                 we received a hello from this Sentinel
                                 via Pub/Sub. */
    mstime_t last_master_down_reply_time; /* Time of last reply to
                                             SENTINEL is-master-down command. */
    mstime_t s_down_since_time; /* Subjectively down since time. */
    mstime_t o_down_since_time; /* Objectively down since time. */
    mstime_t down_a...",1,sentinel.c,sentinelRedisInstance,,false,182,sentinelRedisInstance,32
348090,TYPE_DECL,master,,,struct sentinelRedisInstance,5,sentinel.c,sentinelRedisInstance.sentinelRedisInstance,,false,228,sentinelRedisInstance,30
348104,TYPE_DECL,promoted_slave,,,struct sentinelRedisInstance,5,sentinel.c,sentinelRedisInstance.sentinelRedisInstance,,false,246,sentinelRedisInstance,44
348109,TYPE_DECL,sentinelRedisInstance,,,"typedef struct sentinelRedisInstance {
    int flags;      /* See SRI_... defines */
    char *name;     /* Master name from the point of view of this sentinel. */
    char *runid;    /* Run ID of this instance, or unique ID if is a Sentinel.*/
    uint64_t config_epoch;  /* Configuration epoch. */
    sentinelAddr *addr; /* Master host. */
    instanceLink *link; /* Link to the instance, may be shared for Sentinels. */
    mstime_t last_pub_time;   /* Last time we sent hello via Pub/Sub. */
    mstime_t last_hello_time; /* Only used if SRI_SENTINEL is set. Last time
                                 we received a hello from this Sentinel
                                 via Pub/Sub. */
    mstime_t last_master_down_reply_time; /* Time of last reply to
                                             SENTINEL is-master-down command. */
    mstime_t s_down_since_time; /* Subjectively down since time. */
    mstime_t o_down_since_time; /* Objectively down since time. */
    mstime_t down_a...",3,sentinel.c,sentinelRedisInstance,,false,252,sentinelRedisInstance,33
348110,TYPE_DECL,sentinel,,,"struct sentinelState {
    char myid[CONFIG_RUN_ID_SIZE+1]; /* This sentinel ID. */
    uint64_t current_epoch;         /* Current epoch. */
    dict *masters;      /* Dictionary of master sentinelRedisInstances.
                           Key is the instance name, value is the
                           sentinelRedisInstance structure pointer. */
    int tilt;           /* Are we in TILT mode? */
    int running_scripts;    /* Number of scripts in execution right now. */
    mstime_t tilt_start_time;       /* When TITL started. */
    mstime_t previous_time;         /* Last time we ran the time handler. */
    list *scripts_queue;            /* Queue of user scripts to execute. */
    char *announce_ip;  /* IP addr that is gossiped to other sentinels if
                           not NULL. */
    int announce_port;  /* Port that is gossiped to other sentinels if
                           non zero. */
    unsigned long simfailure_flags; /* Failures simulation. */
    int deny_scrip...",1,sentinel.c,sentinelState,,false,255,sentinelState,34
348138,TYPE_DECL,sentinelScriptJob,,,"typedef struct sentinelScriptJob {
    int flags;              /* Script job flags: SENTINEL_SCRIPT_* */
    int retry_num;          /* Number of times we tried to execute it. */
    char **argv;            /* Arguments to call the script. */
    mstime_t start_time;    /* Script execution time if the script is running,
                               otherwise 0 if we are allowed to retry the
                               execution at any time. If the script is not
                               running and it's not 0, it means: do not run
                               before the specified time. */
    pid_t pid;              /* Script execution pid. */
}",1,sentinel.c,sentinelScriptJob,,false,280,sentinelScriptJob,36
348144,TYPE_DECL,sentinelScriptJob,,,"typedef struct sentinelScriptJob {
    int flags;              /* Script job flags: SENTINEL_SCRIPT_* */
    int retry_num;          /* Number of times we tried to execute it. */
    char **argv;            /* Arguments to call the script. */
    mstime_t start_time;    /* Script execution time if the script is running,
                               otherwise 0 if we are allowed to retry the
                               execution at any time. If the script is not
                               running and it's not 0, it means: do not run
                               before the specified time. */
    pid_t pid;              /* Script execution pid. */
} sentinelScriptJob;",3,sentinel.c,sentinelScriptJob,,false,290,sentinelScriptJob,37
348145,TYPE_DECL,redisAeEvents,,,"typedef struct redisAeEvents {
    redisAsyncContext *context;
    aeEventLoop *loop;
    int fd;
    int reading, writing;
}",1,sentinel.c,redisAeEvents,,false,297,redisAeEvents,38
348151,TYPE_DECL,redisAeEvents,,,"typedef struct redisAeEvents {
    redisAsyncContext *context;
    aeEventLoop *loop;
    int fd;
    int reading, writing;
} redisAeEvents;",3,sentinel.c,redisAeEvents,,false,302,redisAeEvents,39
364401,TYPE_DECL,,,,"struct sentinelLeader {
    char *runid;
    unsigned long votes;
}",1,sentinel.c,sentinelLeader,,false,4776,sentinelLeader,181
366667,TYPE_DECL,,server.c:<global>,NAMESPACE_BLOCK,<global>,1,server.c,server.c:<global>,,false,1,<global>,39
366670,TYPE_DECL,shared,,,struct sharedObjectsStruct,1,server.c,sharedObjectsStruct,,false,74,sharedObjectsStruct,1
366676,TYPE_DECL,server,,,struct redisServer,1,server.c,redisServer,,false,85,redisServer,7
376673,TYPE_DECL,redisCommandTable,,,extern struct redisCommand,1,server.c,redisCommand,,false,3023,redisCommand,135
382004,TYPE_DECL,replyFlagNames,,,"typedef struct replyFlagNames {
    uint64_t flag;
    const char *name;
}",1,server.c,replyFlagNames,,false,4543,replyFlagNames,187
382007,TYPE_DECL,replyFlagNames,,,"typedef struct replyFlagNames {
    uint64_t flag;
    const char *name;
} replyFlagNames;",3,server.c,replyFlagNames,,false,4546,replyFlagNames,188
383917,TYPE_DECL,,,,"typedef enum {
    COMMAND_LIST_FILTER_MODULE,
    COMMAND_LIST_FILTER_ACLCAT,
    COMMAND_LIST_FILTER_PATTERN,
}",1,server.c,commandListFilterType,,false,5047,commandListFilterType,208
383922,TYPE_DECL,commandListFilter,,,"typedef struct {
    commandListFilterType type;
    sds arg;
    struct {
        int valid;
        union {
            uint64_t aclcat;
            void *module_handle;
        } u;
    } cache;
}",1,server.c,commandListFilter,,false,5053,commandListFilter,210
383925,TYPE_DECL,cache,,,"struct {
        int valid;
        union {
            uint64_t aclcat;
            void *module_handle;
        } u;
    }",5,server.c,commandListFilter.cache,,false,5056,commandListFilter.cache,3
383927,TYPE_DECL,u,,,"union {
            uint64_t aclcat;
            void *module_handle;
        }",9,server.c,commandListFilter.cache.u,,false,5058,commandListFilter.cache.u,2
390921,TYPE_DECL,,server.h:<global>,NAMESPACE_BLOCK,<global>,1,server.h,server.h:<global>,,false,1,<global>,45
390924,TYPE_DECL,long long int,,,typedef long long mstime_t;,19,server.h,mstime_t,,false,65,mstime_t,1
390925,TYPE_DECL,long long int,,,typedef long long ustime_t;,19,server.h,ustime_t,,false,66,ustime_t,2
390926,TYPE_DECL,robj,,,typedef struct redisObject,1,server.h,redisObject,,false,84,redisObject,3
390927,TYPE_DECL,redisObject,,,typedef struct redisObject robj;,28,server.h,robj,,false,84,robj,4
390928,TYPE_DECL,,,,struct hdr_histogram,1,server.h,hdr_histogram,,false,94,hdr_histogram,5
390934,TYPE_DECL,blocking_type,,,"typedef enum blocking_type {
    BLOCKED_NONE,    /* Not blocked, no CLIENT_BLOCKED flag set. */
    BLOCKED_LIST,    /* BLPOP & co. */
    BLOCKED_WAIT,    /* WAIT for synchronous replication. */
    BLOCKED_WAITAOF, /* WAITAOF for AOF file fsync. */
    BLOCKED_MODULE,  /* Blocked by a loadable module. */
    BLOCKED_STREAM,  /* XREAD. */
    BLOCKED_ZSET,    /* BZPOP et al. */
    BLOCKED_POSTPONE, /* Blocked by processCommand, re-try processing later. */
    BLOCKED_SHUTDOWN, /* SHUTDOWN. */
    BLOCKED_NUM,      /* Number of blocked states. */
    BLOCKED_END       /* End of enumeration */
}",1,server.h,blocking_type,,false,406,blocking_type,8
390946,TYPE_DECL,blocking_type,,,"typedef enum blocking_type {
    BLOCKED_NONE,    /* Not blocked, no CLIENT_BLOCKED flag set. */
    BLOCKED_LIST,    /* BLPOP & co. */
    BLOCKED_WAIT,    /* WAIT for synchronous replication. */
    BLOCKED_WAITAOF, /* WAITAOF for AOF file fsync. */
    BLOCKED_MODULE,  /* Blocked by a loadable module. */
    BLOCKED_STREAM,  /* XREAD. */
    BLOCKED_ZSET,    /* BZPOP et al. */
    BLOCKED_POSTPONE, /* Blocked by processCommand, re-try processing later. */
    BLOCKED_SHUTDOWN, /* SHUTDOWN. */
    BLOCKED_NUM,      /* Number of blocked states. */
    BLOCKED_END       /* End of enumeration */
} blocking_type;",3,server.h,blocking_type,,false,418,blocking_type,9
390947,TYPE_DECL,,,,"typedef enum {
    REPL_STATE_NONE = 0,            /* No active replication */
    REPL_STATE_CONNECT,             /* Must connect to master */
    REPL_STATE_CONNECTING,          /* Connecting to master */
    /* --- Handshake states, must be ordered --- */
    REPL_STATE_RECEIVE_PING_REPLY,  /* Wait for PING reply */
    REPL_STATE_SEND_HANDSHAKE,      /* Send handshake sequence to master */
    REPL_STATE_RECEIVE_AUTH_REPLY,  /* Wait for AUTH reply */
    REPL_STATE_RECEIVE_PORT_REPLY,  /* Wait for REPLCONF reply */
    REPL_STATE_RECEIVE_IP_REPLY,    /* Wait for REPLCONF reply */
    REPL_STATE_RECEIVE_CAPA_REPLY,  /* Wait for REPLCONF reply */
    REPL_STATE_SEND_PSYNC,          /* Send PSYNC */
    REPL_STATE_RECEIVE_PSYNC_REPLY, /* Wait for PSYNC reply */
    /* --- End of handshake states --- */
    REPL_STATE_TRANSFER,        /* Receiving .rdb from master */
    REPL_STATE_CONNECTED,       /* Connected to master */
}",1,server.h,repl_state,,false,437,repl_state,10
390969,TYPE_DECL,,,,"typedef enum {
    NO_FAILOVER = 0,        /* No failover in progress */
    FAILOVER_WAIT_FOR_SYNC, /* Waiting for target replica to catch up */
    FAILOVER_IN_PROGRESS    /* Waiting for target replica to accept
                             * PSYNC FAILOVER request. */
}",1,server.h,failover_state,,false,456,failover_state,12
390981,TYPE_DECL,,,,"typedef enum {
    PAUSE_BY_CLIENT_COMMAND = 0,
    PAUSE_DURING_SHUTDOWN,
    PAUSE_DURING_FAILOVER,
    NUM_PAUSE_PURPOSES /* This value is the number of purposes above. */
}",1,server.h,pause_purpose,,false,622,pause_purpose,14
390994,TYPE_DECL,pause_event,,,"typedef struct {
    uint32_t paused_actions; /* Bitmask of actions */
    mstime_t end;
}",1,server.h,pause_event,,false,629,pause_event,16
390998,TYPE_DECL,,,,"typedef enum {
    CLUSTER_ENDPOINT_TYPE_IP = 0,          /* Show IP address */
    CLUSTER_ENDPOINT_TYPE_HOSTNAME,        /* Show hostname */
    CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT /* Show NULL or empty */
}",1,server.h,cluster_endpoint_type,,false,635,cluster_endpoint_type,18
391010,TYPE_DECL,,,,struct RedisModule,1,server.h,RedisModule,,false,725,RedisModule,20
391011,TYPE_DECL,,,,struct RedisModuleIO,1,server.h,RedisModuleIO,,false,726,RedisModuleIO,21
391012,TYPE_DECL,,,,struct RedisModuleDigest,1,server.h,RedisModuleDigest,,false,727,RedisModuleDigest,22
391013,TYPE_DECL,,,,struct RedisModuleCtx,1,server.h,RedisModuleCtx,,false,728,RedisModuleCtx,23
391014,TYPE_DECL,,,,struct moduleLoadQueueEntry,1,server.h,moduleLoadQueueEntry,,false,729,moduleLoadQueueEntry,24
391015,TYPE_DECL,,,,struct RedisModuleKeyOptCtx,1,server.h,RedisModuleKeyOptCtx,,false,730,RedisModuleKeyOptCtx,25
391016,TYPE_DECL,,,,struct RedisModuleCommand,1,server.h,RedisModuleCommand,,false,731,RedisModuleCommand,26
391130,TYPE_DECL,moduleType,,,"typedef struct RedisModuleType {
    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
    struct RedisModule *module;
    moduleTypeLoadFunc rdb_load;
    moduleTypeSaveFunc rdb_save;
    moduleTypeRewriteFunc aof_rewrite;
    moduleTypeMemUsageFunc mem_usage;
    moduleTypeDigestFunc digest;
    moduleTypeFreeFunc free;
    moduleTypeFreeEffortFunc free_effort;
    moduleTypeUnlinkFunc unlink;
    moduleTypeCopyFunc copy;
    moduleTypeDefragFunc defrag;
    moduleTypeAuxLoadFunc aux_load;
    moduleTypeAuxSaveFunc aux_save;
    moduleTypeMemUsageFunc2 mem_usage2;
    moduleTypeFreeEffortFunc2 free_effort2;
    moduleTypeUnlinkFunc2 unlink2;
    moduleTypeCopyFunc2 copy2;
    moduleTypeAuxSaveFunc aux_save2;
    int aux_save_triggers;
    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
}",1,server.h,RedisModuleType,,false,759,RedisModuleType,45
391132,TYPE_DECL,module,,,struct RedisModule,5,server.h,RedisModuleType.RedisModule,,false,761,RedisModule,2
391159,TYPE_DECL,RedisModuleType,,,"typedef struct RedisModuleType {
    uint64_t id; /* Higher 54 bits of type ID + 10 lower bits of encoding ver. */
    struct RedisModule *module;
    moduleTypeLoadFunc rdb_load;
    moduleTypeSaveFunc rdb_save;
    moduleTypeRewriteFunc aof_rewrite;
    moduleTypeMemUsageFunc mem_usage;
    moduleTypeDigestFunc digest;
    moduleTypeFreeFunc free;
    moduleTypeFreeEffortFunc free_effort;
    moduleTypeUnlinkFunc unlink;
    moduleTypeCopyFunc copy;
    moduleTypeDefragFunc defrag;
    moduleTypeAuxLoadFunc aux_load;
    moduleTypeAuxSaveFunc aux_save;
    moduleTypeMemUsageFunc2 mem_usage2;
    moduleTypeFreeEffortFunc2 free_effort2;
    moduleTypeUnlinkFunc2 unlink2;
    moduleTypeCopyFunc2 copy2;
    moduleTypeAuxSaveFunc aux_save2;
    int aux_save_triggers;
    char name[10]; /* 9 bytes name + null term. Charset: A-Z a-z 0-9 _- */
} moduleType;",3,server.h,moduleType,,false,781,moduleType,46
391160,TYPE_DECL,moduleValue,,,"typedef struct moduleValue {
    moduleType *type;
    void *value;
}",1,server.h,moduleValue,,false,798,moduleValue,47
391163,TYPE_DECL,moduleValue,,,"typedef struct moduleValue {
    moduleType *type;
    void *value;
} moduleValue;",3,server.h,moduleValue,,false,801,moduleValue,48
391164,TYPE_DECL,,,,"struct RedisModule {
    void *handle;   /* Module dlopen() handle. */
    char *name;     /* Module name. */
    int ver;        /* Module version. We use just progressive integers. */
    int apiver;     /* Module API version as requested during initialization.*/
    list *types;    /* Module data types. */
    list *usedby;   /* List of modules using APIs from this one. */
    list *using;    /* List of modules we use some APIs of. */
    list *filters;  /* List of filters the module has registered. */
    list *module_configs; /* List of configurations the module has registered */
    int configs_initialized; /* Have the module configurations been initialized? */
    int in_call;    /* RM_Call() nesting level */
    int in_hook;    /* Hooks callback nesting level for this module (0 or 1). */
    int options;    /* Module options and capabilities. */
    int blocked_clients;         /* Count of RedisModuleBlockedClient in this module. */
    RedisModuleInfoFunc info_cb; /* Callba...",1,server.h,RedisModule,,false,804,RedisModule,49
391181,TYPE_DECL,loadmod,,,struct moduleLoadQueueEntry,5,server.h,RedisModule.moduleLoadQueueEntry,,false,821,moduleLoadQueueEntry,17
391185,TYPE_DECL,RedisModule,,,typedef struct RedisModule,1,server.h,RedisModule,,false,825,RedisModule,50
391186,TYPE_DECL,RedisModule,,,typedef struct RedisModule RedisModule;,28,server.h,RedisModule,,false,825,RedisModule,51
391187,TYPE_DECL,,,,"struct RedisModuleIO {
    size_t bytes;       /* Bytes read / written so far. */
    rio *rio;           /* Rio stream. */
    moduleType *type;   /* Module type doing the operation. */
    int error;          /* True if error condition happened. */
    struct RedisModuleCtx *ctx; /* Optional context, see RM_GetContextFromIO()*/
    struct redisObject *key;    /* Optional name of key processed */
    int dbid;            /* The dbid of the key being processed, -1 when unknown. */
    sds pre_flush_buffer; /* A buffer that should be flushed before next write operation
                           * See rdbSaveSingleModuleAux for more details */
}",1,server.h,RedisModuleIO,,false,830,RedisModuleIO,52
391192,TYPE_DECL,ctx,,,struct RedisModuleCtx,5,server.h,RedisModuleIO.RedisModuleCtx,,false,835,RedisModuleCtx,5
391194,TYPE_DECL,key,,,struct redisObject,5,server.h,RedisModuleIO.redisObject,,false,836,redisObject,7
391198,TYPE_DECL,,,,"struct RedisModuleDigest {
    unsigned char o[20];    /* Ordered elements. */
    unsigned char x[20];    /* Xored elements. */
    struct redisObject *key; /* Optional name of key processed */
    int dbid;                /* The dbid of the key being processed */
}",1,server.h,RedisModuleDigest,,false,860,RedisModuleDigest,53
391201,TYPE_DECL,key,,,struct redisObject,5,server.h,RedisModuleDigest.redisObject,,false,863,redisObject,3
391212,TYPE_DECL,,,,"struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    int refcount;
    void *ptr;
}",1,server.h,redisObject,,false,899,redisObject,54
391223,TYPE_DECL,,,,struct evictionPoolEntry,1,server.h,evictionPoolEntry,,false,925,evictionPoolEntry,56
391224,TYPE_DECL,clientReplyBlock,,,"typedef struct clientReplyBlock {
    size_t size, used;
    char buf[];
}",1,server.h,clientReplyBlock,,false,929,clientReplyBlock,57
391233,TYPE_DECL,clientReplyBlock,,,"typedef struct clientReplyBlock {
    size_t size, used;
    char buf[];
} clientReplyBlock;",3,server.h,clientReplyBlock,,false,932,clientReplyBlock,58
391234,TYPE_DECL,replBufBlock,,,"typedef struct replBufBlock {
    int refcount;           /* Number of replicas or repl backlog using. */
    long long id;           /* The unique incremental number. */
    long long repl_offset;  /* Start replication offset of the block. */
    size_t size, used;
    char buf[];
}",1,server.h,replBufBlock,,false,953,replBufBlock,59
391246,TYPE_DECL,replBufBlock,,,"typedef struct replBufBlock {
    int refcount;           /* Number of replicas or repl backlog using. */
    long long id;           /* The unique incremental number. */
    long long repl_offset;  /* Start replication offset of the block. */
    size_t size, used;
    char buf[];
} replBufBlock;",3,server.h,replBufBlock,,false,959,replBufBlock,60
391247,TYPE_DECL,clusterSlotToKeyMapping,,,typedef struct clusterSlotToKeyMapping,1,server.h,clusterSlotToKeyMapping,,false,962,clusterSlotToKeyMapping,61
391248,TYPE_DECL,clusterSlotToKeyMapping,,,typedef struct clusterSlotToKeyMapping clusterSlotToKeyMapping;,40,server.h,clusterSlotToKeyMapping,,false,962,clusterSlotToKeyMapping,62
391249,TYPE_DECL,redisDb,,,"typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *blocking_keys_unblock_on_nokey;   /* Keys with clients waiting for
                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).
                                             * This is a subset of blocking_keys*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
    clusterSlotToKeyMapping *slots_to_keys; /* Array...",1,server.h,redisDb,,false,967,redisDb,63
391261,TYPE_DECL,redisDb,,,"typedef struct redisDb {
    dict *dict;                 /* The keyspace for this DB */
    dict *expires;              /* Timeout of keys with a timeout set */
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP)*/
    dict *blocking_keys_unblock_on_nokey;   /* Keys with clients waiting for
                                             * data, and should be unblocked if key is deleted (XREADEDGROUP).
                                             * This is a subset of blocking_keys*/
    dict *ready_keys;           /* Blocked keys that received a PUSH */
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */
    int id;                     /* Database ID */
    long long avg_ttl;          /* Average TTL, just for stats */
    unsigned long expires_cursor; /* Cursor of the active expire cycle. */
    list *defrag_later;         /* List of key names to attempt to defrag one by one, gradually. */
    clusterSlotToKeyMapping *slots_to_keys; /* Array...",3,server.h,redisDb,,false,981,redisDb,64
391262,TYPE_DECL,functionsLibCtx,,,typedef struct functionsLibCtx,1,server.h,functionsLibCtx,,false,984,functionsLibCtx,65
391263,TYPE_DECL,functionsLibCtx,,,typedef struct functionsLibCtx functionsLibCtx;,32,server.h,functionsLibCtx,,false,984,functionsLibCtx,66
391264,TYPE_DECL,rdbLoadingCtx,,,"typedef struct rdbLoadingCtx {
    redisDb* dbarray;
    functionsLibCtx* functions_lib_ctx;
}",1,server.h,rdbLoadingCtx,,false,991,rdbLoadingCtx,67
391267,TYPE_DECL,rdbLoadingCtx,,,"typedef struct rdbLoadingCtx {
    redisDb* dbarray;
    functionsLibCtx* functions_lib_ctx;
}rdbLoadingCtx;",2,server.h,rdbLoadingCtx,,false,994,rdbLoadingCtx,68
391268,TYPE_DECL,multiCmd,,,"typedef struct multiCmd {
    robj **argv;
    int argv_len;
    int argc;
    struct redisCommand *cmd;
}",1,server.h,multiCmd,,false,997,multiCmd,69
391272,TYPE_DECL,cmd,,,struct redisCommand,5,server.h,multiCmd.redisCommand,,false,1001,redisCommand,4
391274,TYPE_DECL,multiCmd,,,"typedef struct multiCmd {
    robj **argv;
    int argv_len;
    int argc;
    struct redisCommand *cmd;
} multiCmd;",3,server.h,multiCmd,,false,1002,multiCmd,70
391275,TYPE_DECL,multiState,,,"typedef struct multiState {
    multiCmd *commands;     /* Array of MULTI commands */
    int count;              /* Total number of MULTI commands */
    int cmd_flags;          /* The accumulated command flags OR-ed together.
                               So if at least a command has a given flag, it
                               will be set in this field. */
    int cmd_inv_flags;      /* Same as cmd_flags, OR-ing the ~flags. so that it
                               is possible to know if all the commands have a
                               certain flag. */
    size_t argv_len_sums;    /* mem used by all commands arguments */
    int alloc_count;         /* total number of multiCmd struct memory reserved. */
}",1,server.h,multiState,,false,1004,multiState,71
391282,TYPE_DECL,multiState,,,"typedef struct multiState {
    multiCmd *commands;     /* Array of MULTI commands */
    int count;              /* Total number of MULTI commands */
    int cmd_flags;          /* The accumulated command flags OR-ed together.
                               So if at least a command has a given flag, it
                               will be set in this field. */
    int cmd_inv_flags;      /* Same as cmd_flags, OR-ing the ~flags. so that it
                               is possible to know if all the commands have a
                               certain flag. */
    size_t argv_len_sums;    /* mem used by all commands arguments */
    int alloc_count;         /* total number of multiCmd struct memory reserved. */
} multiState;",3,server.h,multiState,,false,1015,multiState,72
391283,TYPE_DECL,blockingState,,,"typedef struct blockingState {
    /* Generic fields. */
    blocking_type btype;                  /* Type of blocking op if CLIENT_BLOCKED. */
    mstime_t timeout;           /* Blocking operation timeout. If UNIX current time
                                 * is > timeout then the operation timed out. */
    int unblock_on_nokey;       /* Whether to unblock the client when at least one of the keys
                                   is deleted or does not exist anymore */
    /* BLOCKED_LIST, BLOCKED_ZSET and BLOCKED_STREAM or any other Keys related blocking */
    dict *keys;                 /* The keys we are blocked on */

    /* BLOCKED_WAIT and BLOCKED_WAITAOF */
    int numreplicas;        /* Number of replicas we are waiting for ACK. */
    int numlocal;           /* Indication if WAITAOF is waiting for local fsync. */
    long long reploffset;   /* Replication offset to reach. */

    /* BLOCKED_MODULE */
    void *module_blocked_handle; /* RedisModuleBlockedClient structu...",1,server.h,blockingState,,false,1019,blockingState,73
391293,TYPE_DECL,blockingState,,,"typedef struct blockingState {
    /* Generic fields. */
    blocking_type btype;                  /* Type of blocking op if CLIENT_BLOCKED. */
    mstime_t timeout;           /* Blocking operation timeout. If UNIX current time
                                 * is > timeout then the operation timed out. */
    int unblock_on_nokey;       /* Whether to unblock the client when at least one of the keys
                                   is deleted or does not exist anymore */
    /* BLOCKED_LIST, BLOCKED_ZSET and BLOCKED_STREAM or any other Keys related blocking */
    dict *keys;                 /* The keys we are blocked on */

    /* BLOCKED_WAIT and BLOCKED_WAITAOF */
    int numreplicas;        /* Number of replicas we are waiting for ACK. */
    int numlocal;           /* Indication if WAITAOF is waiting for local fsync. */
    long long reploffset;   /* Replication offset to reach. */

    /* BLOCKED_MODULE */
    void *module_blocked_handle; /* RedisModuleBlockedClient structu...",3,server.h,blockingState,,false,1042,blockingState,74
391294,TYPE_DECL,readyList,,,"typedef struct readyList {
    redisDb *db;
    robj *key;
}",1,server.h,readyList,,false,1055,readyList,75
391297,TYPE_DECL,readyList,,,"typedef struct readyList {
    redisDb *db;
    robj *key;
} readyList;",3,server.h,readyList,,false,1058,readyList,76
391298,TYPE_DECL,user,,,"typedef struct {
    sds name;       /* The username as an SDS string. */
    uint32_t flags; /* See USER_FLAG_* */
    list *passwords; /* A list of SDS valid passwords for this user. */
    list *selectors; /* A list of selectors this user validates commands
                        against. This list will always contain at least
                        one selector for backwards compatibility. */
    robj *acl_string; /* cached string represent of ACLs */
}",1,server.h,user,,false,1088,user,77
391305,TYPE_DECL,replBacklog,,,"typedef struct replBacklog {
    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,
                                  * see the definition of replBufBlock. */
    size_t unindexed_count;      /* The count from last creating index block. */
    rax *blocks_index;           /* The index of recorded blocks of replication
                                  * buffer for quickly searching replication
                                  * offset on partial resynchronization. */
    long long histlen;           /* Backlog actual data length */
    long long offset;            /* Replication ""master offset"" of first
                                  * byte in the replication backlog buffer.*/
}",1,server.h,replBacklog,,false,1111,replBacklog,79
391311,TYPE_DECL,replBacklog,,,"typedef struct replBacklog {
    listNode *ref_repl_buf_node; /* Referenced node of replication buffer blocks,
                                  * see the definition of replBufBlock. */
    size_t unindexed_count;      /* The count from last creating index block. */
    rax *blocks_index;           /* The index of recorded blocks of replication
                                  * buffer for quickly searching replication
                                  * offset on partial resynchronization. */
    long long histlen;           /* Backlog actual data length */
    long long offset;            /* Replication ""master offset"" of first
                                  * byte in the replication backlog buffer.*/
} replBacklog;",3,server.h,replBacklog,,false,1121,replBacklog,80
391312,TYPE_DECL,clientMemUsageBucket,,,"typedef struct {
    list *clients;
    size_t mem_usage_sum;
}",1,server.h,clientMemUsageBucket,,false,1123,clientMemUsageBucket,81
391316,TYPE_DECL,client,,,"typedef struct client {
    uint64_t id;            /* Client incremental unique ID. */
    uint64_t flags;         /* Client flags: CLIENT_* macros. */
    connection *conn;
    int resp;               /* RESP protocol version. Can be 2 or 3. */
    redisDb *db;            /* Pointer to currently SELECTed DB. */
    robj *name;             /* As set by CLIENT SETNAME. */
    robj *lib_name;         /* The client library name as set by CLIENT SETINFO. */
    robj *lib_ver;          /* The client library version as set by CLIENT SETINFO. */
    sds querybuf;           /* Buffer we use to accumulate client queries. */
    size_t qb_pos;          /* The position we have read in querybuf. */
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
    int argc;               /* Num of arguments of current command. */
    robj **argv;            /* Arguments of current command. */
    int argv_len;           /* Size of argv array (may be more than argc) */
    int ...",1,server.h,client,,false,1153,client,83
391334,TYPE_DECL,cmd,,,struct redisCommand,5,server.h,client.redisCommand,,false,1171,redisCommand,18
391337,TYPE_DECL,realcmd,,,struct redisCommand,5,server.h,client.redisCommand,,false,1172,redisCommand,21
391415,TYPE_DECL,client,,,"typedef struct client {
    uint64_t id;            /* Client incremental unique ID. */
    uint64_t flags;         /* Client flags: CLIENT_* macros. */
    connection *conn;
    int resp;               /* RESP protocol version. Can be 2 or 3. */
    redisDb *db;            /* Pointer to currently SELECTed DB. */
    robj *name;             /* As set by CLIENT SETNAME. */
    robj *lib_name;         /* The client library name as set by CLIENT SETINFO. */
    robj *lib_ver;          /* The client library version as set by CLIENT SETINFO. */
    sds querybuf;           /* Buffer we use to accumulate client queries. */
    size_t qb_pos;          /* The position we have read in querybuf. */
    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size. */
    int argc;               /* Num of arguments of current command. */
    robj **argv;            /* Arguments of current command. */
    int argv_len;           /* Size of argv array (may be more than argc) */
    int ...",3,server.h,client,,false,1276,client,84
391416,TYPE_DECL,aclInfo,,,"typedef struct aclInfo {
    long long user_auth_failures; /* Auth failure counts on user level */
    long long invalid_cmd_accesses; /* Invalid command accesses that user doesn't have permission to */
    long long invalid_key_accesses; /* Invalid key accesses that user doesn't have permission to */
    long long invalid_channel_accesses; /* Invalid channel accesses that user doesn't have permission to */
}",1,server.h,aclInfo,,false,1279,aclInfo,85
391421,TYPE_DECL,aclInfo,,,"typedef struct aclInfo {
    long long user_auth_failures; /* Auth failure counts on user level */
    long long invalid_cmd_accesses; /* Invalid command accesses that user doesn't have permission to */
    long long invalid_key_accesses; /* Invalid key accesses that user doesn't have permission to */
    long long invalid_channel_accesses; /* Invalid channel accesses that user doesn't have permission to */
} aclInfo;",3,server.h,aclInfo,,false,1284,aclInfo,86
391422,TYPE_DECL,,,,"struct saveparam {
    time_t seconds;
    int changes;
}",1,server.h,saveparam,,false,1286,saveparam,87
391425,TYPE_DECL,,,,"struct moduleLoadQueueEntry {
    sds path;
    int argc;
    robj **argv;
}",1,server.h,moduleLoadQueueEntry,,false,1291,moduleLoadQueueEntry,88
391429,TYPE_DECL,,,,"struct sentinelLoadQueueEntry {
    int argc;
    sds *argv;
    int linenum;
    sds line;
}",1,server.h,sentinelLoadQueueEntry,,false,1297,sentinelLoadQueueEntry,89
391434,TYPE_DECL,,,,"struct sentinelConfig {
    list *pre_monitor_cfg;
    list *monitor_cfg;
    list *post_monitor_cfg;
}",1,server.h,sentinelConfig,,false,1304,sentinelConfig,90
391438,TYPE_DECL,,,,"struct sharedObjectsStruct {
    robj *ok, *err, *emptybulk, *czero, *cone, *pong, *space,
    *queued, *null[4], *nullarray[4], *emptymap[4], *emptyset[4],
    *emptyarray, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,
    *outofrangeerr, *noscripterr, *loadingerr,
    *slowevalerr, *slowscripterr, *slowmoduleerr, *bgsaveerr,
    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,
    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,
    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *unlink,
    *rpop, *lpop, *lpush, *rpoplpush, *lmove, *blmove, *zpopmin, *zpopmax,
    *emptyscan, *multi, *exec, *left, *right, *hset, *srem, *xgroup, *xclaim,  
    *script, *replconf, *eval, *persist, *set, *pexpireat, *pexpire, 
    *time, *pxat, *absttl, *retrycount, *force, *justid, *entriesread,
    *lastid, *ping, *setid, *keepttl, *load, *createconsumer,
    *getack, *special_asterick, *special_equals, *default_username, *redact...",1,server.h,sharedObjectsStruct,,false,1310,sharedObjectsStruct,91
391568,TYPE_DECL,zskiplistNode,,,"typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
}",1,server.h,zskiplistNode,,false,1336,zskiplistNode,92
391571,TYPE_DECL,backward,,,struct zskiplistNode,5,server.h,zskiplistNode.zskiplistNode,,false,1339,zskiplistNode,3
391573,TYPE_DECL,level,,,"struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    }",5,server.h,zskiplistNode.zskiplistLevel,,false,1340,zskiplistLevel,5
391574,TYPE_DECL,forward,,,struct zskiplistNode,9,server.h,zskiplistNode.zskiplistLevel.zskiplistNode,,false,1341,zskiplistNode,1
391583,TYPE_DECL,zskiplistNode,,,"typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;",3,server.h,zskiplistNode,,false,1344,zskiplistNode,93
391584,TYPE_DECL,zskiplist,,,"typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
}",1,server.h,zskiplist,,false,1346,zskiplist,94
391585,TYPE_DECL,header,,,struct zskiplistNode,5,server.h,zskiplist.zskiplistNode,,false,1347,zskiplistNode,1
391590,TYPE_DECL,zskiplist,,,"typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;",3,server.h,zskiplist,,false,1350,zskiplist,95
391591,TYPE_DECL,zset,,,"typedef struct zset {
    dict *dict;
    zskiplist *zsl;
}",1,server.h,zset,,false,1352,zset,96
391594,TYPE_DECL,zset,,,"typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;",3,server.h,zset,,false,1355,zset,97
391595,TYPE_DECL,clientBufferLimitsConfig,,,"typedef struct clientBufferLimitsConfig {
    unsigned long long hard_limit_bytes;
    unsigned long long soft_limit_bytes;
    time_t soft_limit_seconds;
}",1,server.h,clientBufferLimitsConfig,,false,1357,clientBufferLimitsConfig,98
391599,TYPE_DECL,clientBufferLimitsConfig,,,"typedef struct clientBufferLimitsConfig {
    unsigned long long hard_limit_bytes;
    unsigned long long soft_limit_bytes;
    time_t soft_limit_seconds;
} clientBufferLimitsConfig;",3,server.h,clientBufferLimitsConfig,,false,1361,clientBufferLimitsConfig,99
391605,TYPE_DECL,redisOp,,,"typedef struct redisOp {
    robj **argv;
    int argc, dbid, target;
}",1,server.h,redisOp,,false,1371,redisOp,102
391610,TYPE_DECL,redisOp,,,"typedef struct redisOp {
    robj **argv;
    int argc, dbid, target;
} redisOp;",3,server.h,redisOp,,false,1374,redisOp,103
391611,TYPE_DECL,redisOpArray,,,"typedef struct redisOpArray {
    redisOp *ops;
    int numops;
    int capacity;
}",1,server.h,redisOpArray,,false,1382,redisOpArray,104
391615,TYPE_DECL,redisOpArray,,,"typedef struct redisOpArray {
    redisOp *ops;
    int numops;
    int capacity;
} redisOpArray;",3,server.h,redisOpArray,,false,1386,redisOpArray,105
391616,TYPE_DECL,,,,"struct redisMemOverhead {
    size_t peak_allocated;
    size_t total_allocated;
    size_t startup_allocated;
    size_t repl_backlog;
    size_t clients_slaves;
    size_t clients_normal;
    size_t cluster_links;
    size_t aof_buffer;
    size_t lua_caches;
    size_t functions_caches;
    size_t overhead_total;
    size_t dataset;
    size_t total_keys;
    size_t bytes_per_key;
    float dataset_perc;
    float peak_perc;
    float total_frag;
    ssize_t total_frag_bytes;
    float allocator_frag;
    ssize_t allocator_frag_bytes;
    float allocator_rss;
    ssize_t allocator_rss_bytes;
    float rss_extra;
    size_t rss_extra_bytes;
    size_t num_dbs;
    struct {
        size_t dbid;
        size_t overhead_ht_main;
        size_t overhead_ht_expires;
        size_t overhead_ht_slot_to_keys;
    } *db;
}",1,server.h,redisMemOverhead,,false,1390,redisMemOverhead,106
391642,TYPE_DECL,db,,,"struct {
        size_t dbid;
        size_t overhead_ht_main;
        size_t overhead_ht_expires;
        size_t overhead_ht_slot_to_keys;
    }",5,server.h,redisMemOverhead.db,,false,1416,redisMemOverhead.db,26
391648,TYPE_DECL,,,,"typedef enum {
    PROPAGATION_ERR_BEHAVIOR_IGNORE = 0,
    PROPAGATION_ERR_BEHAVIOR_PANIC,
    PROPAGATION_ERR_BEHAVIOR_PANIC_ON_REPLICAS
}",1,server.h,replicationErrorBehavior,,false,1427,replicationErrorBehavior,107
391660,TYPE_DECL,rdbSaveInfo,,,"typedef struct rdbSaveInfo {
    /* Used saving and loading. */
    int repl_stream_db;  /* DB to select in server.master client. */

    /* Used only loading. */
    int repl_id_is_set;  /* True if repl_id field is set. */
    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */
    long long repl_offset;                  /* Replication offset. */
}",1,server.h,rdbSaveInfo,,false,1441,rdbSaveInfo,109
391675,TYPE_DECL,rdbSaveInfo,,,"typedef struct rdbSaveInfo {
    /* Used saving and loading. */
    int repl_stream_db;  /* DB to select in server.master client. */

    /* Used only loading. */
    int repl_id_is_set;  /* True if repl_id field is set. */
    char repl_id[CONFIG_RUN_ID_SIZE+1];     /* Replication ID. */
    long long repl_offset;                  /* Replication offset. */
} rdbSaveInfo;",3,server.h,rdbSaveInfo,,false,1449,rdbSaveInfo,110
391676,TYPE_DECL,,,,"struct malloc_stats {
    size_t zmalloc_used;
    size_t process_rss;
    size_t allocator_allocated;
    size_t allocator_active;
    size_t allocator_resident;
}",1,server.h,malloc_stats,,false,1453,malloc_stats,111
391682,TYPE_DECL,redisTLSContextConfig,,,"typedef struct redisTLSContextConfig {
    char *cert_file;                /* Server side and optionally client side cert file name */
    char *key_file;                 /* Private key filename for cert_file */
    char *key_file_pass;            /* Optional password for key_file */
    char *client_cert_file;         /* Certificate to use as a client; if none, use cert_file */
    char *client_key_file;          /* Private key filename for client_cert_file */
    char *client_key_file_pass;     /* Optional password for client_key_file */
    char *dh_params_file;
    char *ca_cert_file;
    char *ca_cert_dir;
    char *protocols;
    char *ciphers;
    char *ciphersuites;
    int prefer_server_ciphers;
    int session_caching;
    int session_cache_size;
    int session_cache_timeout;
}",1,server.h,redisTLSContextConfig,,false,1465,redisTLSContextConfig,112
391699,TYPE_DECL,redisTLSContextConfig,,,"typedef struct redisTLSContextConfig {
    char *cert_file;                /* Server side and optionally client side cert file name */
    char *key_file;                 /* Private key filename for cert_file */
    char *key_file_pass;            /* Optional password for key_file */
    char *client_cert_file;         /* Certificate to use as a client; if none, use cert_file */
    char *client_key_file;          /* Private key filename for client_cert_file */
    char *client_key_file_pass;     /* Optional password for client_key_file */
    char *dh_params_file;
    char *ca_cert_file;
    char *ca_cert_dir;
    char *protocols;
    char *ciphers;
    char *ciphersuites;
    int prefer_server_ciphers;
    int session_caching;
    int session_cache_size;
    int session_cache_timeout;
} redisTLSContextConfig;",3,server.h,redisTLSContextConfig,,false,1482,redisTLSContextConfig,113
391700,TYPE_DECL,,,,"typedef enum {
    AOF_FILE_TYPE_BASE  = 'b', /* BASE file */
    AOF_FILE_TYPE_HIST  = 'h', /* HISTORY file */
    AOF_FILE_TYPE_INCR  = 'i', /* INCR file */
}",1,server.h,aof_file_type,,false,1487,aof_file_type,114
391718,TYPE_DECL,aofInfo,,,"typedef struct {
    sds           file_name;  /* file name */
    long long     file_seq;   /* file sequence */
    aof_file_type file_type;  /* file type */
}",1,server.h,aofInfo,,false,1493,aofInfo,116
391723,TYPE_DECL,aofManifest,,,"typedef struct {
    aofInfo     *base_aof_info;       /* BASE file information. NULL if there is no BASE file. */
    list        *incr_aof_list;       /* INCR AOFs list. We may have multiple INCR AOF when rewrite fails. */
    list        *history_aof_list;    /* HISTORY AOF list. When the AOFRW success, The aofInfo contained in
                                         `base_aof_info` and `incr_aof_list` will be moved to this list. We
                                         will delete these AOF files when AOFRW finish. */
    long long   curr_base_file_seq;   /* The sequence number used by the current BASE file. */
    long long   curr_incr_file_seq;   /* The sequence number used by the current INCR file. */
    int         dirty;                /* 1 Indicates that the aofManifest in the memory is inconsistent with
                                         disk, we need to persist it immediately. */
}",1,server.h,aofManifest,,false,1499,aofManifest,118
391731,TYPE_DECL,childInfoType,,,"typedef enum childInfoType {
    CHILD_INFO_TYPE_CURRENT_INFO,
    CHILD_INFO_TYPE_AOF_COW_SIZE,
    CHILD_INFO_TYPE_RDB_COW_SIZE,
    CHILD_INFO_TYPE_MODULE_COW_SIZE
}",1,server.h,childInfoType,,false,1527,childInfoType,120
391736,TYPE_DECL,childInfoType,,,"typedef enum childInfoType {
    CHILD_INFO_TYPE_CURRENT_INFO,
    CHILD_INFO_TYPE_AOF_COW_SIZE,
    CHILD_INFO_TYPE_RDB_COW_SIZE,
    CHILD_INFO_TYPE_MODULE_COW_SIZE
} childInfoType;",3,server.h,childInfoType,,false,1532,childInfoType,121
391737,TYPE_DECL,,,,"struct redisServer {
    /* General */
    pid_t pid;                  /* Main process pid. */
    pthread_t main_thread_id;         /* Main thread id */
    char *configfile;           /* Absolute config file path, or NULL */
    char *executable;           /* Absolute executable file path. */
    char **exec_argv;           /* Executable argv vector (copy). */
    int dynamic_hz;             /* Change hz value depending on # of clients. */
    int config_hz;              /* Configured HZ value. May be different than
                                   the actual 'hz' field value if dynamic-hz
                                   is enabled. */
    mode_t umask;               /* The umask value of the process on startup */
    int hz;                     /* serverCron() calls frequency in hertz */
    int in_fork_child;          /* indication that this is a fork child */
    redisDb *db;
    dict *commands;             /* Command table */
    dict *orig_commands;        /* Command tab...",1,server.h,redisServer,,false,1534,redisServer,122
391862,TYPE_DECL,cron_malloc_stats,,,struct malloc_stats,5,server.h,redisServer.malloc_stats,,false,1675,malloc_stats,125
391886,TYPE_DECL,inst_metric,,,"struct {
        long long last_sample_base;  /* The divisor of last sample window */
        long long last_sample_value; /* The dividend of last sample window */
        long long samples[STATS_METRIC_SAMPLES];
        int idx;
    }",5,server.h,redisServer.inst_metric,,false,1700,redisServer.inst_metric,149
391974,TYPE_DECL,saveparams,,,struct saveparam,5,server.h,redisServer.saveparam,,false,1791,saveparam,225
392118,TYPE_DECL,cluster,,,struct clusterState,5,server.h,redisServer.clusterState,,false,1974,clusterState,369
392162,TYPE_DECL,sentinel_config,,,struct sentinelConfig,5,server.h,redisServer.sentinelConfig,,false,2035,sentinelConfig,413
392239,TYPE_DECL,keyReference,,,"typedef struct {
    int pos; /* The position of the key within the client array */
    int flags; /* The flags associated with the key access, see
                  CMD_KEY_* for more information */
}",1,server.h,keyReference,,false,2054,keyReference,123
392243,TYPE_DECL,getKeysResult,,,"typedef struct {
    keyReference keysbuf[MAX_KEYS_BUFFER];       /* Pre-allocated buffer, to save heap allocations */
    keyReference *keys;                          /* Key indices array, points to keysbuf or heap */
    int numkeys;                        /* Number of key indices return */
    int size;                           /* Available array size */
}",1,server.h,getKeysResult,,false,2064,getKeysResult,125
392257,TYPE_DECL,,,,"typedef enum {
    KSPEC_BS_INVALID = 0, /* Must be 0 */
    KSPEC_BS_UNKNOWN,
    KSPEC_BS_INDEX,
    KSPEC_BS_KEYWORD
}",1,server.h,kspec_bs_type,,false,2092,kspec_bs_type,127
392270,TYPE_DECL,,,,"typedef enum {
    KSPEC_FK_INVALID = 0, /* Must be 0 */
    KSPEC_FK_UNKNOWN,
    KSPEC_FK_RANGE,
    KSPEC_FK_KEYNUM
}",1,server.h,kspec_fk_type,,false,2100,kspec_fk_type,129
392283,TYPE_DECL,keySpec,,,"typedef struct {
    /* Declarative data */
    const char *notes;
    uint64_t flags;
    kspec_bs_type begin_search_type;
    union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    } bs;
    kspec_fk_type find_keys_type;
    union {
        /* NOTE: Indices in this struct are relative to the result of the begin_search step!
         * These are: range.lastkey, keynum.keynumidx, keynum.firstkey */
        struct {
            /* Index of the last key.
             * Can be negative, in which case it's not relative. ...",1,server.h,keySpec,,false,2108,keySpec,131
392287,TYPE_DECL,bs,,,"union {
        struct {
            /* The index from which we start the search for keys */
            int pos;
        } index;
        struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        } keyword;
    }",5,server.h,keySpec.bs,,false,2113,keySpec.bs,4
392288,TYPE_DECL,index,,,"struct {
            /* The index from which we start the search for keys */
            int pos;
        }",9,server.h,keySpec.bs.index,,false,2114,keySpec.bs.index,1
392291,TYPE_DECL,keyword,,,"struct {
            /* The keyword that indicates the beginning of key args */
            const char *keyword;
            /* An index in argv from which to start searching.
             * Can be negative, which means start search from the end, in reverse
             * (Example: -2 means to start in reverse from the penultimate arg) */
            int startfrom;
        }",9,server.h,keySpec.bs.keyword,,false,2118,keySpec.bs.keyword,3
392297,TYPE_DECL,fk,,,"union {
        /* NOTE: Indices in this struct are relative to the result of the begin_search step!
         * These are: range.lastkey, keynum.keynumidx, keynum.firstkey */
        struct {
            /* Index of the last key.
             * Can be negative, in which case it's not relative. -1 indicating till the last argument,
             * -2 one before the last and so on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0 and 1 mean no limit.
             * 2 means 1/2 of the remaining args, 3 means 1/3, and so on. */
            int limit;
        } range;
        struct {
            /* Index of the argument containing the number of keys to come */
            int keynumidx;
            /* Index of the fist key (Usually it's just after keynumidx, in
             * which case it should be set to k...",5,server.h,keySpec.fk,,false,2128,keySpec.fk,7
392298,TYPE_DECL,range,,,"struct {
            /* Index of the last key.
             * Can be negative, in which case it's not relative. -1 indicating till the last argument,
             * -2 one before the last and so on. */
            int lastkey;
            /* How many args should we skip after finding a key, in order to find the next one. */
            int keystep;
            /* If lastkey is -1, we use limit to stop the search by a factor. 0 and 1 mean no limit.
             * 2 means 1/2 of the remaining args, 3 means 1/3, and so on. */
            int limit;
        }",9,server.h,keySpec.fk.range,,false,2131,keySpec.fk.range,1
392303,TYPE_DECL,keynum,,,"struct {
            /* Index of the argument containing the number of keys to come */
            int keynumidx;
            /* Index of the fist key (Usually it's just after keynumidx, in
             * which case it should be set to keynumidx+1). */
            int firstkey;
            /* How many args should we skip after finding a key, in order to find the next one. */
            int keystep;
        }",9,server.h,keySpec.fk.keynum,,false,2142,keySpec.fk.keynum,3
392310,TYPE_DECL,commandHistory,,,"typedef struct {
    const char *since;
    const char *changes;
}",1,server.h,commandHistory,,false,2188,commandHistory,133
392314,TYPE_DECL,,,,"typedef enum {
    COMMAND_GROUP_GENERIC,
    COMMAND_GROUP_STRING,
    COMMAND_GROUP_LIST,
    COMMAND_GROUP_SET,
    COMMAND_GROUP_SORTED_SET,
    COMMAND_GROUP_HASH,
    COMMAND_GROUP_PUBSUB,
    COMMAND_GROUP_TRANSACTIONS,
    COMMAND_GROUP_CONNECTION,
    COMMAND_GROUP_SERVER,
    COMMAND_GROUP_SCRIPTING,
    COMMAND_GROUP_HYPERLOGLOG,
    COMMAND_GROUP_CLUSTER,
    COMMAND_GROUP_SENTINEL,
    COMMAND_GROUP_GEO,
    COMMAND_GROUP_STREAM,
    COMMAND_GROUP_BITMAP,
    COMMAND_GROUP_MODULE,
}",1,server.h,redisCommandGroup,,false,2194,redisCommandGroup,135
392347,TYPE_DECL,,,,"struct redisCommand {
    /* Declarative data */
    const char *declared_name; /* A string representing the command declared_name.
                                * It is a const char * for native commands and SDS for module commands. */
    const char *summary; /* Summary of the command (optional). */
    const char *complexity; /* Complexity description (optional). */
    const char *since; /* Debut version of the command (optional). */
    int doc_flags; /* Flags for documentation (see CMD_DOC_*). */
    const char *replaced_by; /* In case the command is deprecated, this is the successor command. */
    const char *deprecated_since; /* In case the command is deprecated, when did it happen? */
    redisCommandGroup group; /* Command group */
    commandHistory *history; /* History of the command */
    int num_history;
    const char **tips; /* An array of strings that are meant to be tips for clients/proxies regarding this command */
    int num_tips;
    redisCommandProc *proc;...",1,server.h,redisCommand,,false,2311,redisCommand,139
392368,TYPE_DECL,subcommands,,,struct redisCommand,5,server.h,redisCommand.redisCommand,,false,2337,redisCommand,21
392370,TYPE_DECL,args,,,struct redisCommandArg,5,server.h,redisCommand.redisCommandArg,,false,2339,redisCommandArg,23
392372,TYPE_DECL,reply_schema,,,struct jsonObject,5,server.h,redisCommand.jsonObject,,false,2342,jsonObject,25
392380,TYPE_DECL,latency_histogram,,,struct hdr_histogram,5,server.h,redisCommand.hdr_histogram,,false,2353,hdr_histogram,33
392384,TYPE_DECL,parent,,,struct redisCommand,5,server.h,redisCommand.redisCommand,,false,2360,redisCommand,37
392386,TYPE_DECL,module_cmd,,,struct RedisModuleCommand,5,server.h,redisCommand.RedisModuleCommand,,false,2361,RedisModuleCommand,39
392388,TYPE_DECL,,,,"struct redisError {
    long long count;
}",1,server.h,redisError,,false,2364,redisError,140
392390,TYPE_DECL,,,,"struct redisFunctionSym {
    char *name;
    unsigned long pointer;
}",1,server.h,redisFunctionSym,,false,2368,redisFunctionSym,141
392393,TYPE_DECL,redisSortObject,,,"typedef struct _redisSortObject {
    robj *obj;
    union {
        double score;
        robj *cmpobj;
    } u;
}",1,server.h,_redisSortObject,,false,2373,_redisSortObject,142
392395,TYPE_DECL,u,,,"union {
        double score;
        robj *cmpobj;
    }",5,server.h,_redisSortObject.u,,false,2375,_redisSortObject.u,2
392399,TYPE_DECL,_redisSortObject,,,"typedef struct _redisSortObject {
    robj *obj;
    union {
        double score;
        robj *cmpobj;
    } u;
} redisSortObject;",3,server.h,redisSortObject,,false,2379,redisSortObject,143
392400,TYPE_DECL,redisSortOperation,,,"typedef struct _redisSortOperation {
    int type;
    robj *pattern;
}",1,server.h,_redisSortOperation,,false,2381,_redisSortOperation,144
392403,TYPE_DECL,_redisSortOperation,,,"typedef struct _redisSortOperation {
    int type;
    robj *pattern;
} redisSortOperation;",3,server.h,redisSortOperation,,false,2384,redisSortOperation,145
392404,TYPE_DECL,listTypeIterator,,,"typedef struct {
    robj *subject;
    unsigned char encoding;
    unsigned char direction; /* Iteration direction */

    unsigned char *lpi; /* listpack iterator */
    quicklistIter *iter; /* quicklist iterator */
}",1,server.h,listTypeIterator,,false,2387,listTypeIterator,146
392411,TYPE_DECL,listTypeEntry,,,"typedef struct {
    listTypeIterator *li;
    unsigned char *lpe; /* Entry in listpack */
    quicklistEntry entry; /* Entry in quicklist */
}",1,server.h,listTypeEntry,,false,2397,listTypeEntry,148
392416,TYPE_DECL,setTypeIterator,,,"typedef struct {
    robj *subject;
    int encoding;
    int ii; /* intset iterator */
    dictIterator *di;
    unsigned char *lpi; /* listpack iterator */
}",1,server.h,setTypeIterator,,false,2404,setTypeIterator,150
392423,TYPE_DECL,hashTypeIterator,,,"typedef struct {
    robj *subject;
    int encoding;

    unsigned char *fptr, *vptr;

    dictIterator *di;
    dictEntry *de;
}",1,server.h,hashTypeIterator,,false,2416,hashTypeIterator,152
392432,TYPE_DECL,server,,,extern struct redisServer,1,server.h,redisServer,,false,2440,redisServer,155
392434,TYPE_DECL,shared,,,extern struct sharedObjectsStruct,1,server.h,sharedObjectsStruct,,false,2441,sharedObjectsStruct,157
393693,TYPE_DECL,,,,"typedef enum {
    LIST_CONV_AUTO,
    LIST_CONV_GROWING,
    LIST_CONV_SHRINKING,
}",1,server.h,list_conv_type,,false,2702,list_conv_type,391
394554,TYPE_DECL,,,,"typedef enum {
    AUTH_OK = 0,
    AUTH_ERR,
    AUTH_NOT_HANDLED,
    AUTH_BLOCKED
}",1,server.h,AuthResult,,false,2906,AuthResult,547
394747,TYPE_DECL,zrangespec,,,"typedef struct {
    double min, max;
    int minex, maxex; /* are min or max exclusive? */
}",1,server.h,zrangespec,,false,2959,zrangespec,577
394753,TYPE_DECL,zlexrangespec,,,"typedef struct {
    sds min, max;     /* May be set to shared.(minstring|maxstring) */
    int minex, maxex; /* are min or max exclusive? */
}",1,server.h,zlexrangespec,,false,2965,zlexrangespec,579
395054,TYPE_DECL,lookupSubcommand,,,struct redisCommand,1,server.h,redisCommand,,false,3024,redisCommand,629
395056,TYPE_DECL,lookupCommand,,,struct redisCommand,1,server.h,redisCommand,,false,3025,redisCommand,631
395058,TYPE_DECL,lookupCommandBySdsLogic,,,struct redisCommand,1,server.h,redisCommand,,false,3026,redisCommand,633
395060,TYPE_DECL,lookupCommandBySds,,,struct redisCommand,1,server.h,redisCommand,,false,3027,redisCommand,635
395062,TYPE_DECL,lookupCommandByCStringLogic,,,struct redisCommand,1,server.h,redisCommand,,false,3028,redisCommand,637
395064,TYPE_DECL,lookupCommandByCString,,,struct redisCommand,1,server.h,redisCommand,,false,3029,redisCommand,639
395066,TYPE_DECL,lookupCommandOrOriginal,,,struct redisCommand,1,server.h,redisCommand,,false,3030,redisCommand,641
395279,TYPE_DECL,getMemoryOverheadData,,,struct redisMemOverhead,1,server.h,redisMemOverhead,,false,3075,redisMemOverhead,682
395620,TYPE_DECL,configEnum,,,"typedef struct configEnum {
    char *name;
    int val;
}",1,server.h,configEnum,,false,3175,configEnum,739
395623,TYPE_DECL,configEnum,,,"typedef struct configEnum {
    char *name;
    int val;
} configEnum;",3,server.h,configEnum,,false,3178,configEnum,740
395624,TYPE_DECL,,,,"typedef enum {
    BOOL_CONFIG,
    NUMERIC_CONFIG,
    STRING_CONFIG,
    SDS_CONFIG,
    ENUM_CONFIG,
    SPECIAL_CONFIG,
}",1,server.h,configType,,false,3181,configType,741
395650,TYPE_DECL,,,,struct rewriteConfigState,1,server.h,rewriteConfigState,,false,3193,rewriteConfigState,746
395702,TYPE_DECL,ModuleConfig,,,typedef struct ModuleConfig,1,server.h,ModuleConfig,,false,3205,ModuleConfig,756
395703,TYPE_DECL,ModuleConfig,,,typedef struct ModuleConfig ModuleConfig;,29,server.h,ModuleConfig,,false,3205,ModuleConfig,757
396454,TYPE_DECL,luaScript,,,"typedef struct luaScript {
    uint64_t flags;
    robj *body;
}",1,server.h,luaScript,,false,3359,luaScript,874
396457,TYPE_DECL,luaScript,,,"typedef struct luaScript {
    uint64_t flags;
    robj *body;
} luaScript;",3,server.h,luaScript,,false,3362,luaScript,875
398195,TYPE_DECL,,setcpuaffinity.c:<global>,NAMESPACE_BLOCK,<global>,1,setcpuaffinity.c,setcpuaffinity.c:<global>,,false,1,<global>,12
398212,TYPE_DECL,,setproctitle.c:<global>,NAMESPACE_BLOCK,<global>,1,setproctitle.c,setproctitle.c:<global>,,false,1,<global>,7
398229,TYPE_DECL,,sha1.c:<global>,NAMESPACE_BLOCK,<global>,1,sha1.c,sha1.c:<global>,,false,1,<global>,7
407580,TYPE_DECL,,sha1.h:<global>,NAMESPACE_BLOCK,<global>,1,sha1.h,sha1.h:<global>,,false,1,<global>,1
407583,TYPE_DECL,SHA1_CTX,,,"typedef struct {
    uint32_t state[5];
    uint32_t count[2];
    unsigned char buffer[64];
}",1,sha1.h,SHA1_CTX,,false,10,SHA1_CTX,1
407630,TYPE_DECL,,sha256.c:<global>,NAMESPACE_BLOCK,<global>,1,sha256.c,sha256.c:<global>,,false,1,<global>,4
408620,TYPE_DECL,,sha256.h:<global>,NAMESPACE_BLOCK,<global>,1,sha256.h,sha256.h:<global>,,false,1,<global>,3
408623,TYPE_DECL,ANY,,,typedef uint8_t BYTE;,17,sha256.h,BYTE,,false,20,BYTE,1
408624,TYPE_DECL,ANY,,,typedef uint32_t WORD;,18,sha256.h,WORD,,false,21,WORD,2
408625,TYPE_DECL,SHA256_CTX,,,"typedef struct {
	BYTE data[64];
	WORD datalen;
	unsigned long long bitlen;
	WORD state[8];
}",1,sha256.h,SHA256_CTX,,false,23,SHA256_CTX,3
408669,TYPE_DECL,,siphash.c:<global>,NAMESPACE_BLOCK,<global>,1,siphash.c,siphash.c:<global>,,false,1,<global>,6
410455,TYPE_DECL,,slowlog.c:<global>,NAMESPACE_BLOCK,<global>,1,slowlog.c,slowlog.c:<global>,,false,1,<global>,3
411163,TYPE_DECL,,slowlog.h:<global>,NAMESPACE_BLOCK,<global>,1,slowlog.h,slowlog.h:<global>,,false,1,<global>,1
411166,TYPE_DECL,slowlogEntry,,,"typedef struct slowlogEntry {
    robj **argv;
    int argc;
    long long id;       /* Unique entry identifier. */
    long long duration; /* Time spent by the query, in microseconds. */
    time_t time;        /* Unix time at which the query was executed. */
    sds cname;          /* Client name. */
    sds peerid;         /* Client network address. */
}",1,slowlog.h,slowlogEntry,,false,37,slowlogEntry,1
411174,TYPE_DECL,slowlogEntry,,,"typedef struct slowlogEntry {
    robj **argv;
    int argc;
    long long id;       /* Unique entry identifier. */
    long long duration; /* Time spent by the query, in microseconds. */
    time_t time;        /* Unix time at which the query was executed. */
    sds cname;          /* Client name. */
    sds peerid;         /* Client network address. */
} slowlogEntry;",3,slowlog.h,slowlogEntry,,false,45,slowlogEntry,2
411194,TYPE_DECL,,socket.c:<global>,NAMESPACE_BLOCK,<global>,1,socket.c,socket.c:<global>,,false,1,<global>,3
412559,TYPE_DECL,,solarisfixes.h:<global>,NAMESPACE_BLOCK,<global>,1,solarisfixes.h,solarisfixes.h:<global>,,false,1,<global>,2
412570,TYPE_DECL,,sort.c:<global>,NAMESPACE_BLOCK,<global>,1,sort.c,sort.c:<global>,,false,1,<global>,4
414840,TYPE_DECL,,sparkline.c:<global>,NAMESPACE_BLOCK,<global>,1,sparkline.c,sparkline.c:<global>,,false,1,<global>,3
415397,TYPE_DECL,,sparkline.h:<global>,NAMESPACE_BLOCK,<global>,1,sparkline.h,sparkline.h:<global>,,false,1,<global>,1
415400,TYPE_DECL,,,,"struct sample {
    double value;
    char *label;
}",1,sparkline.h,sample,,false,34,sample,1
415403,TYPE_DECL,,,,"struct sequence {
    int length;
    int labels;
    struct sample *samples;
    double min, max;
}",1,sparkline.h,sequence,,false,39,sequence,2
415406,TYPE_DECL,samples,,,struct sample,5,sparkline.h,sequence.sample,,false,42,sample,3
415410,TYPE_DECL,createSparklineSequence,,,struct sequence,1,sparkline.h,sequence,,false,50,sequence,3
415449,TYPE_DECL,,stream.h:<global>,NAMESPACE_BLOCK,<global>,1,stream.h,stream.h:<global>,,false,1,<global>,3
415452,TYPE_DECL,streamID,,,"typedef struct streamID {
    uint64_t ms;        /* Unix time in milliseconds. */
    uint64_t seq;       /* Sequence number. */
}",1,stream.h,streamID,,false,11,streamID,1
415455,TYPE_DECL,streamID,,,"typedef struct streamID {
    uint64_t ms;        /* Unix time in milliseconds. */
    uint64_t seq;       /* Sequence number. */
} streamID;",3,stream.h,streamID,,false,14,streamID,2
415456,TYPE_DECL,stream,,,"typedef struct stream {
    rax *rax;               /* The radix tree holding the stream. */
    uint64_t length;        /* Current number of elements inside this stream. */
    streamID last_id;       /* Zero if there are yet no items. */
    streamID first_id;      /* The first non-tombstone entry, zero if empty. */
    streamID max_deleted_entry_id;  /* The maximal ID that was deleted. */
    uint64_t entries_added; /* All time count of elements added. */
    rax *cgroups;           /* Consumer groups dictionary: name -> streamCG */
}",1,stream.h,stream,,false,16,stream,3
415464,TYPE_DECL,stream,,,"typedef struct stream {
    rax *rax;               /* The radix tree holding the stream. */
    uint64_t length;        /* Current number of elements inside this stream. */
    streamID last_id;       /* Zero if there are yet no items. */
    streamID first_id;      /* The first non-tombstone entry, zero if empty. */
    streamID max_deleted_entry_id;  /* The maximal ID that was deleted. */
    uint64_t entries_added; /* All time count of elements added. */
    rax *cgroups;           /* Consumer groups dictionary: name -> streamCG */
} stream;",3,stream.h,stream,,false,24,stream,4
415465,TYPE_DECL,streamIterator,,,"typedef struct streamIterator {
    stream *stream;         /* The stream we are iterating. */
    streamID master_id;     /* ID of the master entry at listpack head. */
    uint64_t master_fields_count;       /* Master entries # of fields. */
    unsigned char *master_fields_start; /* Master entries start in listpack. */
    unsigned char *master_fields_ptr;   /* Master field to emit next. */
    int entry_flags;                    /* Flags of entry we are emitting. */
    int rev;                /* True if iterating end to start (reverse). */
    int skip_tombstones;    /* True if not emitting tombstone entries. */
    uint64_t start_key[2];  /* Start key as 128 bit big endian. */
    uint64_t end_key[2];    /* End key as 128 bit big endian. */
    raxIterator ri;         /* Rax iterator. */
    unsigned char *lp;      /* Current listpack. */
    unsigned char *lp_ele;  /* Current listpack cursor. */
    unsigned char *lp_flags; /* Current entry flags pointer. */
    /* Buffers us...",1,stream.h,streamIterator,,false,32,streamIterator,5
415498,TYPE_DECL,streamIterator,,,"typedef struct streamIterator {
    stream *stream;         /* The stream we are iterating. */
    streamID master_id;     /* ID of the master entry at listpack head. */
    uint64_t master_fields_count;       /* Master entries # of fields. */
    unsigned char *master_fields_start; /* Master entries start in listpack. */
    unsigned char *master_fields_ptr;   /* Master field to emit next. */
    int entry_flags;                    /* Flags of entry we are emitting. */
    int rev;                /* True if iterating end to start (reverse). */
    int skip_tombstones;    /* True if not emitting tombstone entries. */
    uint64_t start_key[2];  /* Start key as 128 bit big endian. */
    uint64_t end_key[2];    /* End key as 128 bit big endian. */
    raxIterator ri;         /* Rax iterator. */
    unsigned char *lp;      /* Current listpack. */
    unsigned char *lp_ele;  /* Current listpack cursor. */
    unsigned char *lp_flags; /* Current entry flags pointer. */
    /* Buffers us...",3,stream.h,streamIterator,,false,52,streamIterator,6
415499,TYPE_DECL,streamCG,,,"typedef struct streamCG {
    streamID last_id;       /* Last delivered (not acknowledged) ID for this
                               group. Consumers that will just ask for more
                               messages will served with IDs > than this. */
    long long entries_read; /* In a perfect world (CG starts at 0-0, no dels, no
                               XGROUP SETID, ...), this is the total number of
                               group reads. In the real world, the reasoning behind
                               this value is detailed at the top comment of
                               streamEstimateDistanceFromFirstEverEntry(). */
    rax *pel;               /* Pending entries list. This is a radix tree that
                               has every message delivered to consumers (without
                               the NOACK option) that was yet not acknowledged
                               as processed. The key of the radix tree is the
                          ...",1,stream.h,streamCG,,false,55,streamCG,7
415504,TYPE_DECL,streamCG,,,"typedef struct streamCG {
    streamID last_id;       /* Last delivered (not acknowledged) ID for this
                               group. Consumers that will just ask for more
                               messages will served with IDs > than this. */
    long long entries_read; /* In a perfect world (CG starts at 0-0, no dels, no
                               XGROUP SETID, ...), this is the total number of
                               group reads. In the real world, the reasoning behind
                               this value is detailed at the top comment of
                               streamEstimateDistanceFromFirstEverEntry(). */
    rax *pel;               /* Pending entries list. This is a radix tree that
                               has every message delivered to consumers (without
                               the NOACK option) that was yet not acknowledged
                               as processed. The key of the radix tree is the
                          ...",3,stream.h,streamCG,,false,73,streamCG,8
415505,TYPE_DECL,streamConsumer,,,"typedef struct streamConsumer {
    mstime_t seen_time;         /* Last time this consumer tried to perform an action (attempted reading/claiming). */
    mstime_t active_time;       /* Last time this consumer was active (successful reading/claiming). */
    sds name;                   /* Consumer name. This is how the consumer
                                   will be identified in the consumer group
                                   protocol. Case sensitive. */
    rax *pel;                   /* Consumer specific pending entries list: all
                                   the pending messages delivered to this
                                   consumer not yet acknowledged. Keys are
                                   big endian message IDs, while values are
                                   the same streamNACK structure referenced
                                   in the ""pel"" of the consumer group structure
                                   itself, so the value is shared. ...",1,stream.h,streamConsumer,,false,76,streamConsumer,9
415510,TYPE_DECL,streamConsumer,,,"typedef struct streamConsumer {
    mstime_t seen_time;         /* Last time this consumer tried to perform an action (attempted reading/claiming). */
    mstime_t active_time;       /* Last time this consumer was active (successful reading/claiming). */
    sds name;                   /* Consumer name. This is how the consumer
                                   will be identified in the consumer group
                                   protocol. Case sensitive. */
    rax *pel;                   /* Consumer specific pending entries list: all
                                   the pending messages delivered to this
                                   consumer not yet acknowledged. Keys are
                                   big endian message IDs, while values are
                                   the same streamNACK structure referenced
                                   in the ""pel"" of the consumer group structure
                                   itself, so the value is shared. ...",3,stream.h,streamConsumer,,false,89,streamConsumer,10
415511,TYPE_DECL,streamNACK,,,"typedef struct streamNACK {
    mstime_t delivery_time;     /* Last time this message was delivered. */
    uint64_t delivery_count;    /* Number of times this message was delivered.*/
    streamConsumer *consumer;   /* The consumer this message was delivered to
                                   in the last delivery. */
}",1,stream.h,streamNACK,,false,92,streamNACK,11
415515,TYPE_DECL,streamNACK,,,"typedef struct streamNACK {
    mstime_t delivery_time;     /* Last time this message was delivered. */
    uint64_t delivery_count;    /* Number of times this message was delivered.*/
    streamConsumer *consumer;   /* The consumer this message was delivered to
                                   in the last delivery. */
} streamNACK;",3,stream.h,streamNACK,,false,97,streamNACK,12
415516,TYPE_DECL,streamPropInfo,,,"typedef struct streamPropInfo {
    robj *keyname;
    robj *groupname;
}",1,stream.h,streamPropInfo,,false,101,streamPropInfo,13
415519,TYPE_DECL,streamPropInfo,,,"typedef struct streamPropInfo {
    robj *keyname;
    robj *groupname;
} streamPropInfo;",3,stream.h,streamPropInfo,,false,104,streamPropInfo,14
415520,TYPE_DECL,,,,struct client,1,stream.h,client,,false,107,client,15
415727,TYPE_DECL,,strl.c:<global>,NAMESPACE_BLOCK,<global>,1,strl.c,strl.c:<global>,,false,1,<global>,2
415880,TYPE_DECL,,syncio.c:<global>,NAMESPACE_BLOCK,<global>,1,syncio.c,syncio.c:<global>,,false,1,<global>,2
416207,TYPE_DECL,,syscheck.c:<global>,NAMESPACE_BLOCK,<global>,1,syscheck.c,syscheck.c:<global>,,false,1,<global>,15
416210,TYPE_DECL,check,,,"typedef struct {
    const char *name;
    int (*check_fn)(sds*);
}",1,syscheck.c,check,,false,335,check,1
416305,TYPE_DECL,,syscheck.h:<global>,NAMESPACE_BLOCK,<global>,1,syscheck.h,syscheck.h:<global>,,false,1,<global>,3
416319,TYPE_DECL,,t_hash.c:<global>,NAMESPACE_BLOCK,<global>,1,t_hash.c,t_hash.c:<global>,,false,1,<global>,3
420553,TYPE_DECL,,t_list.c:<global>,NAMESPACE_BLOCK,<global>,1,t_list.c,t_list.c:<global>,,false,1,<global>,2
425784,TYPE_DECL,,t_set.c:<global>,NAMESPACE_BLOCK,<global>,1,t_set.c,t_set.c:<global>,,false,1,<global>,3
431842,TYPE_DECL,,t_stream.c:<global>,NAMESPACE_BLOCK,<global>,1,t_stream.c,t_stream.c:<global>,,false,1,<global>,4
433795,TYPE_DECL,streamAddTrimArgs,,,"typedef struct {
    /* XADD options */
    streamID id; /* User-provided ID, for XADD only. */
    int id_given; /* Was an ID different than ""*"" specified? for XADD only. */
    int seq_given; /* Was an ID different than ""ms-*"" specified? for XADD only. */
    int no_mkstream; /* if set to 1 do not create new stream */

    /* XADD + XTRIM common options */
    int trim_strategy; /* TRIM_STRATEGY_* */
    int trim_strategy_arg_idx; /* Index of the count in MAXLEN/MINID, for rewriting. */
    int approx_trim; /* If 1 only delete whole radix tree nodes, so
                      * the trim argument is not applied verbatim. */
    long long limit; /* Maximum amount of entries to trim. If 0, no limitation
                      * on the amount of trimming work is enforced. */
    /* TRIM_STRATEGY_MAXLEN options */
    long long maxlen; /* After trimming, leave stream at this length . */
    /* TRIM_STRATEGY_MINID options */
    streamID minid; /* Trim by ID (No stream entries with ID < '...",1,t_stream.c,streamAddTrimArgs,,false,672,streamAddTrimArgs,21
445126,TYPE_DECL,,t_string.c:<global>,NAMESPACE_BLOCK,<global>,1,t_string.c,t_string.c:<global>,,false,1,<global>,3
449347,TYPE_DECL,,t_zset.c:<global>,NAMESPACE_BLOCK,<global>,1,t_zset.c,t_zset.c:<global>,,false,1,<global>,4
456023,TYPE_DECL,,,,"typedef enum {
    ZRANGE_AUTO = 0,
    ZRANGE_RANK,
    ZRANGE_SCORE,
    ZRANGE_LEX,
}",1,t_zset.c,zrange_type,,false,1872,zrange_type,74
456547,TYPE_DECL,zsetopsrc,,,"typedef struct {
    robj *subject;
    int type; /* Set, sorted set */
    int encoding;
    double weight;

    union {
        /* Set iterators. */
        union _iterset {
            struct {
                intset *is;
                int ii;
            } is;
            struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            } ht;
            struct {
                unsigned char *lp;
                unsigned char *p;
            } lp;
        } set;

        /* Sorted set iterators. */
        union _iterzset {
            struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            } zl;
            struct {
                zset *zs;
                zskiplistNode *node;
            } sl;
        } zset;
    } iter;
}",1,t_zset.c,zsetopsrc,,false,1999,zsetopsrc,80
456552,TYPE_DECL,iter,,,"union {
        /* Set iterators. */
        union _iterset {
            struct {
                intset *is;
                int ii;
            } is;
            struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            } ht;
            struct {
                unsigned char *lp;
                unsigned char *p;
            } lp;
        } set;

        /* Sorted set iterators. */
        union _iterzset {
            struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            } zl;
            struct {
                zset *zs;
                zskiplistNode *node;
            } sl;
        } zset;
    }",5,t_zset.c,zsetopsrc.iter,,false,2005,zsetopsrc.iter,5
456553,TYPE_DECL,set,,,"union _iterset {
            struct {
                intset *is;
                int ii;
            } is;
            struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            } ht;
            struct {
                unsigned char *lp;
                unsigned char *p;
            } lp;
        }",9,t_zset.c,zsetopsrc.iter._iterset,,false,2007,_iterset,1
456554,TYPE_DECL,is,,,"struct {
                intset *is;
                int ii;
            }",13,t_zset.c,zsetopsrc.iter._iterset.is,,false,2008,zsetopsrc.iter._iterset.is,1
456558,TYPE_DECL,ht,,,"struct {
                dict *dict;
                dictIterator *di;
                dictEntry *de;
            }",13,t_zset.c,zsetopsrc.iter._iterset.ht,,false,2012,zsetopsrc.iter._iterset.ht,3
456563,TYPE_DECL,lp,,,"struct {
                unsigned char *lp;
                unsigned char *p;
            }",13,t_zset.c,zsetopsrc.iter._iterset.lp,,false,2017,zsetopsrc.iter._iterset.lp,5
456568,TYPE_DECL,zset,,,"union _iterzset {
            struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            } zl;
            struct {
                zset *zs;
                zskiplistNode *node;
            } sl;
        }",9,t_zset.c,zsetopsrc.iter._iterzset,,false,2024,_iterzset,3
456569,TYPE_DECL,zl,,,"struct {
                unsigned char *zl;
                unsigned char *eptr, *sptr;
            }",13,t_zset.c,zsetopsrc.iter._iterzset.zl,,false,2025,zsetopsrc.iter._iterzset.zl,1
456574,TYPE_DECL,sl,,,"struct {
                zset *zs;
                zskiplistNode *node;
            }",13,t_zset.c,zsetopsrc.iter._iterzset.sl,,false,2029,zsetopsrc.iter._iterzset.sl,3
456581,TYPE_DECL,zsetopval,,,"typedef struct {
    int flags;
    unsigned char _buf[32]; /* Private buffer. */
    sds ele;
    unsigned char *estr;
    unsigned int elen;
    long long ell;
    double score;
}",1,t_zset.c,zsetopval,,false,2049,zsetopval,82
456596,TYPE_DECL,iterset,,,typedef union _iterset,1,t_zset.c,_iterset,,false,2059,_iterset,84
456597,TYPE_DECL,_iterset,,,typedef union _iterset iterset;,24,t_zset.c,iterset,,false,2059,iterset,85
456598,TYPE_DECL,iterzset,,,typedef union _iterzset,1,t_zset.c,_iterzset,,false,2060,_iterzset,86
456599,TYPE_DECL,_iterzset,,,typedef union _iterzset iterzset;,25,t_zset.c,iterzset,,false,2060,iterzset,87
459888,TYPE_DECL,,,,"typedef enum {
    ZRANGE_DIRECTION_AUTO = 0,
    ZRANGE_DIRECTION_FORWARD,
    ZRANGE_DIRECTION_REVERSE
}",1,t_zset.c,zrange_direction,,false,2897,zrange_direction,116
459900,TYPE_DECL,,,,"typedef enum {
    ZRANGE_CONSUMER_TYPE_CLIENT = 0,
    ZRANGE_CONSUMER_TYPE_INTERNAL
}",1,t_zset.c,zrange_consumer_type,,false,2903,zrange_consumer_type,118
459911,TYPE_DECL,zrange_result_handler,,,typedef struct zrange_result_handler,1,t_zset.c,zrange_result_handler,,false,2908,zrange_result_handler,120
459912,TYPE_DECL,zrange_result_handler,,,typedef struct zrange_result_handler zrange_result_handler;,38,t_zset.c,zrange_result_handler,,false,2908,zrange_result_handler,121
459949,TYPE_DECL,,,,"struct zrange_result_handler {
    zrange_consumer_type                 type;
    client                              *client;
    robj                                *dstkey;
    robj                                *dstobj;
    void                                *userdata;
    int                                  withscores;
    int                                  should_emit_array_length;
    zrangeResultBeginFunction            beginResultEmission;
    zrangeResultFinalizeFunction         finalizeResultEmission;
    zrangeResultEmitCBufferFunction      emitResultFromCBuffer;
    zrangeResultEmitLongLongFunction     emitResultFromLongLong;
}",1,t_zset.c,zrange_result_handler,,false,2924,zrange_result_handler,127
465006,TYPE_DECL,,testhelp.h:<global>,NAMESPACE_BLOCK,<global>,1,testhelp.h,testhelp.h:<global>,,false,1,<global>,1
465019,TYPE_DECL,,timeout.c:<global>,NAMESPACE_BLOCK,<global>,1,timeout.c,timeout.c:<global>,,false,1,<global>,4
465578,TYPE_DECL,,tls.c:<global>,NAMESPACE_BLOCK,<global>,1,tls.c,tls.c:<global>,,false,1,<global>,13
465614,TYPE_DECL,,tracking.c:<global>,NAMESPACE_BLOCK,<global>,1,tracking.c,tracking.c:<global>,,false,1,<global>,2
465630,TYPE_DECL,bcastState,,,"typedef struct bcastState {
    rax *keys;      /* Keys modified in the current event loop cycle. */
    rax *clients;   /* Clients subscribed to the notification events for this
                       prefix. */
}",1,tracking.c,bcastState,,false,55,bcastState,8
465633,TYPE_DECL,bcastState,,,"typedef struct bcastState {
    rax *keys;      /* Keys modified in the current event loop cycle. */
    rax *clients;   /* Clients subscribed to the notification events for this
                       prefix. */
} bcastState;",3,tracking.c,bcastState,,false,59,bcastState,9
467606,TYPE_DECL,,unix.c:<global>,NAMESPACE_BLOCK,<global>,1,unix.c,unix.c:<global>,,false,1,<global>,3
468287,TYPE_DECL,,util.c:<global>,NAMESPACE_BLOCK,<global>,1,util.c,util.c:<global>,,false,1,<global>,25
471335,TYPE_DECL,,util.h:<global>,NAMESPACE_BLOCK,<global>,1,util.h,util.h:<global>,,false,1,<global>,3
471338,TYPE_DECL,,,,"typedef enum {
    LD_STR_AUTO,     /* %.17Lg */
    LD_STR_HUMAN,    /* %.17Lf + Trimming of trailing zeros */
    LD_STR_HEX       /* %La */
}",1,util.h,ld2string_mode,,false,54,ld2string_mode,1
471554,TYPE_DECL,,version.h:<global>,NAMESPACE_BLOCK,<global>,1,version.h,version.h:<global>,,false,1,<global>,1
471589,TYPE_DECL,,ziplist.c:<global>,NAMESPACE_BLOCK,<global>,1,ziplist.c,ziplist.c:<global>,,false,1,<global>,16
471621,TYPE_DECL,zlentry,,,"typedef struct zlentry {
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
    unsigned int prevrawlen;     /* Previous entry len. */
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
    unsigned int headersize;     /* prevrawlensize + lensize. */
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
         ...",1,ziplist.c,zlentry,,false,284,zlentry,2
471629,TYPE_DECL,zlentry,,,"typedef struct zlentry {
    unsigned int prevrawlensize; /* Bytes used to encode the previous entry len*/
    unsigned int prevrawlen;     /* Previous entry len. */
    unsigned int lensize;        /* Bytes used to encode this entry type/len.
                                    For example strings have a 1, 2 or 5 bytes
                                    header. Integers always use a single byte.*/
    unsigned int len;            /* Bytes used to represent the actual entry.
                                    For strings this is just the string length
                                    while for integers it is 1, 2, 3, 4, 8 or
                                    0 (for 4 bit immediate) depending on the
                                    number range. */
    unsigned int headersize;     /* prevrawlensize + lensize. */
    unsigned char encoding;      /* Set to ZIP_STR_* or ZIP_INT_* depending on
                                    the entry encoding. However for 4 bits
         ...",3,ziplist.c,zlentry,,false,302,zlentry,3
478173,TYPE_DECL,,ziplist.h:<global>,NAMESPACE_BLOCK,<global>,1,ziplist.h,ziplist.h:<global>,,false,1,<global>,1
478176,TYPE_DECL,ziplistEntry,,,"typedef struct {
    /* When string is used, it is provided with the length (slen). */
    unsigned char *sval;
    unsigned int slen;
    /* When integer is used, 'sval' is NULL, and lval holds the value. */
    long long lval;
}",1,ziplist.h,ziplistEntry,,false,38,ziplistEntry,1
478342,TYPE_DECL,,zipmap.c:<global>,NAMESPACE_BLOCK,<global>,1,zipmap.c,zipmap.c:<global>,,false,1,<global>,5
479461,TYPE_DECL,,zipmap.h:<global>,NAMESPACE_BLOCK,<global>,1,zipmap.h,zipmap.h:<global>,,false,1,<global>,1
479601,TYPE_DECL,,zmalloc.c:<global>,NAMESPACE_BLOCK,<global>,1,zmalloc.c,zmalloc.c:<global>,,false,1,<global>,31
480507,TYPE_DECL,,zmalloc.h:<global>,NAMESPACE_BLOCK,<global>,1,zmalloc.h,zmalloc.h:<global>,,false,1,<global>,6
481965,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ACLCategoryItem[],,<includes>,ACLCategoryItem[],,true,,ACLCategoryItem[],-1
481966,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ACLCommandCategories,,<includes>,ACLCommandCategories,,true,,ACLCommandCategories,-1
481967,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ACLLogEntry*,,<includes>,ACLLogEntry*,,true,,ACLLogEntry*,-1
481968,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ACLSelectorFlags[],,<includes>,ACLSelectorFlags[],,true,,ACLSelectorFlags[],-1
481969,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ACLUserFlag[],,<includes>,ACLUserFlag[],,true,,ACLUserFlag[],-1
481970,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ACLUserFlags,,<includes>,ACLUserFlags,,true,,ACLUserFlags,-1
481971,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ANY,,<includes>,ANY,,true,,ANY,-1
481972,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,AutoMemEntry*,,<includes>,AutoMemEntry*,,true,,AutoMemEntry*,-1
481973,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BYTE[64],,<includes>,BYTE[64],,true,,BYTE[64],-1
481974,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,BYTE[],,<includes>,BYTE[],,true,,BYTE[],-1
481975,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CHAR64LONG16[1],,<includes>,CHAR64LONG16[1],,true,,CHAR64LONG16[1],-1
481976,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CallReply*,,<includes>,CallReply*,,true,,CallReply*,-1
481977,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,CallReply**,,<includes>,CallReply**,,true,,CallReply**,-1
481978,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ChannelSpecs*,,<includes>,ChannelSpecs*,,true,,ChannelSpecs*,-1
481979,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ChannelSpecs[],,<includes>,ChannelSpecs[],,true,,ChannelSpecs[],-1
481980,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ConnectionCallbackFunc,,<includes>,ConnectionCallbackFunc,,true,,ConnectionCallbackFunc,-1
481981,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ConnectionType*,,<includes>,ConnectionType*,,true,,ConnectionType*,-1
481982,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ConnectionType*[8],,<includes>,ConnectionType*[8],,true,,ConnectionType*[8],-1
481983,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,DIR*,,<includes>,DIR*,,true,,DIR*,-1
481984,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,Dl_info,,<includes>,Dl_info,,true,,Dl_info,-1
481985,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EventLoopData*,,<includes>,EventLoopData*,,true,,EventLoopData*,-1
481986,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EventLoopOneShot*,,<includes>,EventLoopOneShot*,,true,,EventLoopOneShot*,-1
481987,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,EvictionPoolLRU,,<includes>,EvictionPoolLRU,,true,,EvictionPoolLRU,-1
481988,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,FILE*,,<includes>,FILE*,,true,,FILE*,-1
481989,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashArea*,,<includes>,GeoHashArea*,,true,,GeoHashArea*,-1
481990,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashBits*,,<includes>,GeoHashBits*,,true,,GeoHashBits*,-1
481991,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashBits[9],,<includes>,GeoHashBits[9],,true,,GeoHashBits[9],-1
481992,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashFix52Bits*,,<includes>,GeoHashFix52Bits*,,true,,GeoHashFix52Bits*,-1
481993,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashNeighbors*,,<includes>,GeoHashNeighbors*,,true,,GeoHashNeighbors*,-1
481994,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashRadius*,,<includes>,GeoHashRadius*,,true,,GeoHashRadius*,-1
481995,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashRange*,,<includes>,GeoHashRange*,,true,,GeoHashRange*,-1
481996,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoHashRange[2],,<includes>,GeoHashRange[2],,true,,GeoHashRange[2],-1
481997,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,GeoShape*,,<includes>,GeoShape*,,true,,GeoShape*,-1
481998,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,HelloTypeNode*,,<includes>,HelloTypeNode*,,true,,HelloTypeNode*,-1
481999,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,HelloTypeObject*,,<includes>,HelloTypeObject*,,true,,HelloTypeObject*,-1
482000,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,KeyInfo*,,<includes>,KeyInfo*,,true,,KeyInfo*,-1
482001,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,LZF_HSLOT*,,<includes>,LZF_HSLOT*,,true,,LZF_HSLOT*,-1
482002,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ModuleConfig*,,<includes>,ModuleConfig*,,true,,ModuleConfig*,-1
482003,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModule*,,<includes>,RedisModule*,,true,,RedisModule*,-1
482004,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleAsyncRMCallPromise*,,<includes>,RedisModuleAsyncRMCallPromise*,,true,,RedisModuleAsyncRMCallPromise*,-1
482005,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleAuthCallback,,<includes>,RedisModuleAuthCallback,,true,,RedisModuleAuthCallback,-1
482006,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleAuthCtx*,,<includes>,RedisModuleAuthCtx*,,true,,RedisModuleAuthCtx*,-1
482007,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleBlockedClient*,,<includes>,RedisModuleBlockedClient*,,true,,RedisModuleBlockedClient*,-1
482008,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCallReply*,,<includes>,RedisModuleCallReply*,,true,,RedisModuleCallReply*,-1
482009,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCallReply**,,<includes>,RedisModuleCallReply**,,true,,RedisModuleCallReply**,-1
482010,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleClientInfoV1*,,<includes>,RedisModuleClientInfoV1*,,true,,RedisModuleClientInfoV1*,-1
482011,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleClusterMessageReceiver,,<includes>,RedisModuleClusterMessageReceiver,,true,,RedisModuleClusterMessageReceiver,-1
482012,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCmdFunc,,<includes>,RedisModuleCmdFunc,,true,,RedisModuleCmdFunc,-1
482013,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommand*,,<includes>,RedisModuleCommand*,,true,,RedisModuleCommand*,-1
482014,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandArg*,,<includes>,RedisModuleCommandArg*,,true,,RedisModuleCommandArg*,-1
482015,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandFilter*,,<includes>,RedisModuleCommandFilter*,,true,,RedisModuleCommandFilter*,-1
482016,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandFilterCtx*,,<includes>,RedisModuleCommandFilterCtx*,,true,,RedisModuleCommandFilterCtx*,-1
482017,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandFilterFunc,,<includes>,RedisModuleCommandFilterFunc,,true,,RedisModuleCommandFilterFunc,-1
482018,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandHistoryEntry*,,<includes>,RedisModuleCommandHistoryEntry*,,true,,RedisModuleCommandHistoryEntry*,-1
482019,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandInfo*,,<includes>,RedisModuleCommandInfo*,,true,,RedisModuleCommandInfo*,-1
482020,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandInfoVersion*,,<includes>,RedisModuleCommandInfoVersion*,,true,,RedisModuleCommandInfoVersion*,-1
482021,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCommandKeySpec*,,<includes>,RedisModuleCommandKeySpec*,,true,,RedisModuleCommandKeySpec*,-1
482022,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigApplyFunc,,<includes>,RedisModuleConfigApplyFunc,,true,,RedisModuleConfigApplyFunc,-1
482023,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigGetBoolFunc,,<includes>,RedisModuleConfigGetBoolFunc,,true,,RedisModuleConfigGetBoolFunc,-1
482024,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigGetEnumFunc,,<includes>,RedisModuleConfigGetEnumFunc,,true,,RedisModuleConfigGetEnumFunc,-1
482025,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigGetNumericFunc,,<includes>,RedisModuleConfigGetNumericFunc,,true,,RedisModuleConfigGetNumericFunc,-1
482026,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigGetStringFunc,,<includes>,RedisModuleConfigGetStringFunc,,true,,RedisModuleConfigGetStringFunc,-1
482027,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigSetBoolFunc,,<includes>,RedisModuleConfigSetBoolFunc,,true,,RedisModuleConfigSetBoolFunc,-1
482028,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigSetEnumFunc,,<includes>,RedisModuleConfigSetEnumFunc,,true,,RedisModuleConfigSetEnumFunc,-1
482029,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigSetNumericFunc,,<includes>,RedisModuleConfigSetNumericFunc,,true,,RedisModuleConfigSetNumericFunc,-1
482030,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleConfigSetStringFunc,,<includes>,RedisModuleConfigSetStringFunc,,true,,RedisModuleConfigSetStringFunc,-1
482031,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleCtx*,,<includes>,RedisModuleCtx*,,true,,RedisModuleCtx*,-1
482032,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleDefragCtx*,,<includes>,RedisModuleDefragCtx*,,true,,RedisModuleDefragCtx*,-1
482033,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleDefragFunc,,<includes>,RedisModuleDefragFunc,,true,,RedisModuleDefragFunc,-1
482034,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleDict*,,<includes>,RedisModuleDict*,,true,,RedisModuleDict*,-1
482035,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleDictIter*,,<includes>,RedisModuleDictIter*,,true,,RedisModuleDictIter*,-1
482036,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleDigest*,,<includes>,RedisModuleDigest*,,true,,RedisModuleDigest*,-1
482037,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleDisconnectFunc,,<includes>,RedisModuleDisconnectFunc,,true,,RedisModuleDisconnectFunc,-1
482038,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleEventCallback,,<includes>,RedisModuleEventCallback,,true,,RedisModuleEventCallback,-1
482039,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleEventListener*,,<includes>,RedisModuleEventListener*,,true,,RedisModuleEventListener*,-1
482040,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleEventLoopFunc,,<includes>,RedisModuleEventLoopFunc,,true,,RedisModuleEventLoopFunc,-1
482041,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleEventLoopOneShotFunc,,<includes>,RedisModuleEventLoopOneShotFunc,,true,,RedisModuleEventLoopOneShotFunc,-1
482042,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleFlushInfoV1*,,<includes>,RedisModuleFlushInfoV1*,,true,,RedisModuleFlushInfoV1*,-1
482043,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleForkDoneHandler,,<includes>,RedisModuleForkDoneHandler,,true,,RedisModuleForkDoneHandler,-1
482044,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleIO*,,<includes>,RedisModuleIO*,,true,,RedisModuleIO*,-1
482045,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleInfoCtx*,,<includes>,RedisModuleInfoCtx*,,true,,RedisModuleInfoCtx*,-1
482046,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleInfoFunc,,<includes>,RedisModuleInfoFunc,,true,,RedisModuleInfoFunc,-1
482047,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleKey*,,<includes>,RedisModuleKey*,,true,,RedisModuleKey*,-1
482048,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleKeyOptCtx*,,<includes>,RedisModuleKeyOptCtx*,,true,,RedisModuleKeyOptCtx*,-1
482049,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleKeyspaceSubscriber*,,<includes>,RedisModuleKeyspaceSubscriber*,,true,,RedisModuleKeyspaceSubscriber*,-1
482050,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleNotificationFunc,,<includes>,RedisModuleNotificationFunc,,true,,RedisModuleNotificationFunc,-1
482051,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleOnUnblocked,,<includes>,RedisModuleOnUnblocked,,true,,RedisModuleOnUnblocked,-1
482052,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModulePoolAllocBlock*,,<includes>,RedisModulePoolAllocBlock*,,true,,RedisModulePoolAllocBlock*,-1
482053,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModulePostExecUnitJob*,,<includes>,RedisModulePostExecUnitJob*,,true,,RedisModulePostExecUnitJob*,-1
482054,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModulePostNotificationJobFunc,,<includes>,RedisModulePostNotificationJobFunc,,true,,RedisModulePostNotificationJobFunc,-1
482055,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleRdbStream*,,<includes>,RedisModuleRdbStream*,,true,,RedisModuleRdbStream*,-1
482056,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleReplicationInfoV1*,,<includes>,RedisModuleReplicationInfoV1*,,true,,RedisModuleReplicationInfoV1*,-1
482057,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleScanCB,,<includes>,RedisModuleScanCB,,true,,RedisModuleScanCB,-1
482058,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleScanCursor*,,<includes>,RedisModuleScanCursor*,,true,,RedisModuleScanCursor*,-1
482059,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleScanKeyCB,,<includes>,RedisModuleScanKeyCB,,true,,RedisModuleScanKeyCB,-1
482060,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleServerInfoData*,,<includes>,RedisModuleServerInfoData*,,true,,RedisModuleServerInfoData*,-1
482061,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleSharedAPI*,,<includes>,RedisModuleSharedAPI*,,true,,RedisModuleSharedAPI*,-1
482062,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleStreamID*,,<includes>,RedisModuleStreamID*,,true,,RedisModuleStreamID*,-1
482063,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleString*,,<includes>,RedisModuleString*,,true,,RedisModuleString*,-1
482064,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleString**,,<includes>,RedisModuleString**,,true,,RedisModuleString**,-1
482065,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTimer*,,<includes>,RedisModuleTimer*,,true,,RedisModuleTimer*,-1
482066,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTimerProc,,<includes>,RedisModuleTimerProc,,true,,RedisModuleTimerProc,-1
482067,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleType*,,<includes>,RedisModuleType*,,true,,RedisModuleType*,-1
482068,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeAuxLoadFunc,,<includes>,RedisModuleTypeAuxLoadFunc,,true,,RedisModuleTypeAuxLoadFunc,-1
482069,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeAuxSaveFunc,,<includes>,RedisModuleTypeAuxSaveFunc,,true,,RedisModuleTypeAuxSaveFunc,-1
482070,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeCopyFunc,,<includes>,RedisModuleTypeCopyFunc,,true,,RedisModuleTypeCopyFunc,-1
482071,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeCopyFunc2,,<includes>,RedisModuleTypeCopyFunc2,,true,,RedisModuleTypeCopyFunc2,-1
482072,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeDefragFunc,,<includes>,RedisModuleTypeDefragFunc,,true,,RedisModuleTypeDefragFunc,-1
482073,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeDigestFunc,,<includes>,RedisModuleTypeDigestFunc,,true,,RedisModuleTypeDigestFunc,-1
482074,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeFreeEffortFunc,,<includes>,RedisModuleTypeFreeEffortFunc,,true,,RedisModuleTypeFreeEffortFunc,-1
482075,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeFreeEffortFunc2,,<includes>,RedisModuleTypeFreeEffortFunc2,,true,,RedisModuleTypeFreeEffortFunc2,-1
482076,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeFreeFunc,,<includes>,RedisModuleTypeFreeFunc,,true,,RedisModuleTypeFreeFunc,-1
482077,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeLoadFunc,,<includes>,RedisModuleTypeLoadFunc,,true,,RedisModuleTypeLoadFunc,-1
482078,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeMemUsageFunc,,<includes>,RedisModuleTypeMemUsageFunc,,true,,RedisModuleTypeMemUsageFunc,-1
482079,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeMemUsageFunc2,,<includes>,RedisModuleTypeMemUsageFunc2,,true,,RedisModuleTypeMemUsageFunc2,-1
482080,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeMethods*,,<includes>,RedisModuleTypeMethods*,,true,,RedisModuleTypeMethods*,-1
482081,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeRewriteFunc,,<includes>,RedisModuleTypeRewriteFunc,,true,,RedisModuleTypeRewriteFunc,-1
482082,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeSaveFunc,,<includes>,RedisModuleTypeSaveFunc,,true,,RedisModuleTypeSaveFunc,-1
482083,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeUnlinkFunc,,<includes>,RedisModuleTypeUnlinkFunc,,true,,RedisModuleTypeUnlinkFunc,-1
482084,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleTypeUnlinkFunc2,,<includes>,RedisModuleTypeUnlinkFunc2,,true,,RedisModuleTypeUnlinkFunc2,-1
482085,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleUser*,,<includes>,RedisModuleUser*,,true,,RedisModuleUser*,-1
482086,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,RedisModuleUserChangedFunc,,<includes>,RedisModuleUserChangedFunc,,true,,RedisModuleUserChangedFunc,-1
482087,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ReplyParser*,,<includes>,ReplyParser*,,true,,ReplyParser*,-1
482088,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SHA1_CTX*,,<includes>,SHA1_CTX*,,true,,SHA1_CTX*,-1
482089,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,SHA256_CTX*,,<includes>,SHA256_CTX*,,true,,SHA256_CTX*,-1
482090,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ScanCBData*,,<includes>,ScanCBData*,,true,,ScanCBData*,-1
482091,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ScanKeyCBData*,,<includes>,ScanKeyCBData*,,true,,ScanKeyCBData*,-1
482092,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WORD[64],,<includes>,WORD[64],,true,,WORD[64],-1
482093,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,WORD[8],,<includes>,WORD[8],,true,,WORD[8],-1
482094,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,[7],,<includes>,[7],,true,,[7],-1
482095,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,[],,<includes>,[],,true,,[],-1
482096,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_client*,,<includes>,_client*,,true,,_client*,-1
482097,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,_rio*,,<includes>,_rio*,,true,,_rio*,-1
482098,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aclKeyResultCache*,,<includes>,aclKeyResultCache*,,true,,aclKeyResultCache*,-1
482099,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aclSelector*,,<includes>,aclSelector*,,true,,aclSelector*,-1
482100,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,addrinfo,,<includes>,addrinfo,,true,,addrinfo,-1
482101,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,addrinfo*,,<includes>,addrinfo*,,true,,addrinfo*,-1
482102,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeApiState*,,<includes>,aeApiState*,,true,,aeApiState*,-1
482103,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeBeforeSleepProc*,,<includes>,aeBeforeSleepProc*,,true,,aeBeforeSleepProc*,-1
482104,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeEventFinalizerProc*,,<includes>,aeEventFinalizerProc*,,true,,aeEventFinalizerProc*,-1
482105,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeEventLoop*,,<includes>,aeEventLoop*,,true,,aeEventLoop*,-1
482106,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeFileEvent*,,<includes>,aeFileEvent*,,true,,aeFileEvent*,-1
482107,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeFileProc,,<includes>,aeFileProc,,true,,aeFileProc,-1
482108,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeFileProc*,,<includes>,aeFileProc*,,true,,aeFileProc*,-1
482109,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeFiredEvent*,,<includes>,aeFiredEvent*,,true,,aeFiredEvent*,-1
482110,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeTimeEvent*,,<includes>,aeTimeEvent*,,true,,aeTimeEvent*,-1
482111,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aeTimeProc*,,<includes>,aeTimeProc*,,true,,aeTimeProc*,-1
482112,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,amqueue,,<includes>,amqueue,,true,,amqueue,-1
482113,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aofInfo*,,<includes>,aofInfo*,,true,,aofInfo*,-1
482114,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aofManifest*,,<includes>,aofManifest*,,true,,aofManifest*,-1
482115,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,apply_fn,,<includes>,apply_fn,,true,,apply_fn,-1
482116,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,apply_fn*,,<includes>,apply_fn*,,true,,apply_fn*,-1
482117,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,args,,<includes>,args,,true,,args,-1
482118,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,array,,<includes>,array,,true,,array,-1
482119,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,attribute,,<includes>,attribute,,true,,attribute,-1
482120,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,auxFieldHandler[],,<includes>,auxFieldHandler[],,true,,auxFieldHandler[],-1
482121,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aux_value_getter*,,<includes>,aux_value_getter*,,true,,aux_value_getter*,-1
482122,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aux_value_present*,,<includes>,aux_value_present*,,true,,aux_value_present*,-1
482123,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,aux_value_setter*,,<includes>,aux_value_setter*,,true,,aux_value_setter*,-1
482124,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,backward,,<includes>,backward,,true,,backward,-1
482125,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,bcastState*,,<includes>,bcastState*,,true,,bcastState*,-1
482126,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,beforeConvertCB,,<includes>,beforeConvertCB,,true,,beforeConvertCB,-1
482127,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,benchmarkThread*,,<includes>,benchmarkThread*,,true,,benchmarkThread*,-1
482128,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,benchmarkThread**,,<includes>,benchmarkThread**,,true,,benchmarkThread**,-1
482129,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,bio_job*,,<includes>,bio_job*,,true,,bio_job*,-1
482130,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,bitfieldOp*,,<includes>,bitfieldOp*,,true,,bitfieldOp*,-1
482131,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,blocked_client,,<includes>,blocked_client,,true,,blocked_client,-1
482132,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,bs,,<includes>,bs,,true,,bs,-1
482133,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,buffer,,<includes>,buffer,,true,,buffer,-1
482134,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cache,,<includes>,cache,,true,,cache,-1
482135,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char,,<includes>,char,,true,,char,-1
482136,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*,,<includes>,char*,,true,,char*,-1
482137,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char**,,<includes>,char**,,true,,char**,-1
482138,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char***,,<includes>,char***,,true,,char***,-1
482139,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char**[],,<includes>,char**[],,true,,char**[],-1
482140,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*[16],,<includes>,char*[16],,true,,char*[16],-1
482141,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*[17],,<includes>,char*[17],,true,,char*[17],-1
482142,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*[2],,<includes>,char*[2],,true,,char*[2],-1
482143,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*[3],,<includes>,char*[3],,true,,char*[3],-1
482144,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*[7],,<includes>,char*[7],,true,,char*[7],-1
482145,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char*[],,<includes>,char*[],,true,,char*[],-1
482146,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1024],,<includes>,char[1024],,true,,char[1024],-1
482147,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1025],,<includes>,char[1025],,true,,char[1025],-1
482148,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1044],,<includes>,char[1044],,true,,char[1044],-1
482149,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1070],,<includes>,char[1070],,true,,char[1070],-1
482150,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[10],,<includes>,char[10],,true,,char[10],-1
482151,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[128],,<includes>,char[128],,true,,char[128],-1
482152,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[12],,<includes>,char[12],,true,,char[12],-1
482153,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[131],,<includes>,char[131],,true,,char[131],-1
482154,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[138],,<includes>,char[138],,true,,char[138],-1
482155,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[16384],,<includes>,char[16384],,true,,char[16384],-1
482156,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[16],,<includes>,char[16],,true,,char[16],-1
482157,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[17],,<includes>,char[17],,true,,char[17],-1
482158,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[1],,<includes>,char[1],,true,,char[1],-1
482159,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[201],,<includes>,char[201],,true,,char[201],-1
482160,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[20],,<includes>,char[20],,true,,char[20],-1
482161,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[21],,<includes>,char[21],,true,,char[21],-1
482162,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[24],,<includes>,char[24],,true,,char[24],-1
482163,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[255],,<includes>,char[255],,true,,char[255],-1
482164,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[256],,<includes>,char[256],,true,,char[256],-1
482165,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[26],,<includes>,char[26],,true,,char[26],-1
482166,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[288],,<includes>,char[288],,true,,char[288],-1
482167,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[2],,<includes>,char[2],,true,,char[2],-1
482168,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[30],,<includes>,char[30],,true,,char[30],-1
482169,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[32],,<includes>,char[32],,true,,char[32],-1
482170,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[3],,<includes>,char[3],,true,,char[3],-1
482171,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[4096],,<includes>,char[4096],,true,,char[4096],-1
482172,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[40],,<includes>,char[40],,true,,char[40],-1
482173,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[41],,<includes>,char[41],,true,,char[41],-1
482174,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[43],,<includes>,char[43],,true,,char[43],-1
482175,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[46],,<includes>,char[46],,true,,char[46],-1
482176,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[47],,<includes>,char[47],,true,,char[47],-1
482177,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[4],,<includes>,char[4],,true,,char[4],-1
482178,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[5120],,<includes>,char[5120],,true,,char[5120],-1
482179,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[5121],,<includes>,char[5121],,true,,char[5121],-1
482180,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[5152],,<includes>,char[5152],,true,,char[5152],-1
482181,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[5],,<includes>,char[5],,true,,char[5],-1
482182,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[64],,<includes>,char[64],,true,,char[64],-1
482183,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[65],,<includes>,char[65],,true,,char[65],-1
482184,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[6],,<includes>,char[6],,true,,char[6],-1
482185,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[78],,<includes>,char[78],,true,,char[78],-1
482186,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[9],,<includes>,char[9],,true,,char[9],-1
482187,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,char[],,<includes>,char[],,true,,char[],-1
482188,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,check*,,<includes>,check*,,true,,check*,-1
482189,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,check[],,<includes>,check[],,true,,check[],-1
482190,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,childInfoType*,,<includes>,childInfoType*,,true,,childInfoType*,-1
482191,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cliCommandArg*,,<includes>,cliCommandArg*,,true,,cliCommandArg*,-1
482192,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cliConnInfo*,,<includes>,cliConnInfo*,,true,,cliConnInfo*,-1
482193,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,client*,,<includes>,client*,,true,,client*,-1
482194,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,client**,,<includes>,client**,,true,,client**,-1
482195,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clientBufferLimitsConfig[3],,<includes>,clientBufferLimitsConfig[3],,true,,clientBufferLimitsConfig[3],-1
482196,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clientMemUsageBucket*,,<includes>,clientMemUsageBucket*,,true,,clientMemUsageBucket*,-1
482197,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clientReplyBlock*,,<includes>,clientReplyBlock*,,true,,clientReplyBlock*,-1
482198,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clientReqResInfo,,<includes>,clientReqResInfo,,true,,clientReqResInfo,-1
482199,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cluster,,<includes>,cluster,,true,,cluster,-1
482200,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterDictMetadata*,,<includes>,clusterDictMetadata*,,true,,clusterDictMetadata*,-1
482201,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterLink*,,<includes>,clusterLink*,,true,,clusterLink*,-1
482202,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerCommand*,,<includes>,clusterManagerCommand*,,true,,clusterManagerCommand*,-1
482203,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerCommandDef*,,<includes>,clusterManagerCommandDef*,,true,,clusterManagerCommandDef*,-1
482204,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerCommandDef[],,<includes>,clusterManagerCommandDef[],,true,,clusterManagerCommandDef[],-1
482205,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerCommandProc,,<includes>,clusterManagerCommandProc,,true,,clusterManagerCommandProc,-1
482206,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerCommandProc*,,<includes>,clusterManagerCommandProc*,,true,,clusterManagerCommandProc*,-1
482207,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerLink*,,<includes>,clusterManagerLink*,,true,,clusterManagerLink*,-1
482208,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerNode*,,<includes>,clusterManagerNode*,,true,,clusterManagerNode*,-1
482209,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerNode**,,<includes>,clusterManagerNode**,,true,,clusterManagerNode**,-1
482210,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerNode***,,<includes>,clusterManagerNode***,,true,,clusterManagerNode***,-1
482211,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerNode*[16384],,<includes>,clusterManagerNode*[16384],,true,,clusterManagerNode*[16384],-1
482212,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerNodeArray*,,<includes>,clusterManagerNodeArray*,,true,,clusterManagerNodeArray*,-1
482213,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerOnReplyError,,<includes>,clusterManagerOnReplyError,,true,,clusterManagerOnReplyError,-1
482214,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerOptionDef*,,<includes>,clusterManagerOptionDef*,,true,,clusterManagerOptionDef*,-1
482215,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerOptionDef[],,<includes>,clusterManagerOptionDef[],,true,,clusterManagerOptionDef[],-1
482216,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterManagerReshardTableItem*,,<includes>,clusterManagerReshardTableItem*,,true,,clusterManagerReshardTableItem*,-1
482217,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsg*,,<includes>,clusterMsg*,,true,,clusterMsg*,-1
482218,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgDataGossip*,,<includes>,clusterMsgDataGossip*,,true,,clusterMsgDataGossip*,-1
482219,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgDataGossip[1],,<includes>,clusterMsgDataGossip[1],,true,,clusterMsgDataGossip[1],-1
482220,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgPingExt*,,<includes>,clusterMsgPingExt*,,true,,clusterMsgPingExt*,-1
482221,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgPingExtForgottenNode*,,<includes>,clusterMsgPingExtForgottenNode*,,true,,clusterMsgPingExtForgottenNode*,-1
482222,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgPingExtHostname*,,<includes>,clusterMsgPingExtHostname*,,true,,clusterMsgPingExtHostname*,-1
482223,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgPingExtHumanNodename*,,<includes>,clusterMsgPingExtHumanNodename*,,true,,clusterMsgPingExtHumanNodename*,-1
482224,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgPingExtShardId*,,<includes>,clusterMsgPingExtShardId*,,true,,clusterMsgPingExtShardId*,-1
482225,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsgSendBlock*,,<includes>,clusterMsgSendBlock*,,true,,clusterMsgSendBlock*,-1
482226,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterMsg[1],,<includes>,clusterMsg[1],,true,,clusterMsg[1],-1
482227,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterNode*,,<includes>,clusterNode*,,true,,clusterNode*,-1
482228,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterNode**,,<includes>,clusterNode**,,true,,clusterNode**,-1
482229,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterNode*[16384],,<includes>,clusterNode*[16384],,true,,clusterNode*[16384],-1
482230,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterNodeFailReport*,,<includes>,clusterNodeFailReport*,,true,,clusterNodeFailReport*,-1
482231,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterSlotToKeyMapping*,,<includes>,clusterSlotToKeyMapping*,,true,,clusterSlotToKeyMapping*,-1
482232,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,clusterState*,,<includes>,clusterState*,,true,,clusterState*,-1
482233,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cluster_manager,,<includes>,cluster_manager,,true,,cluster_manager,-1
482234,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cluster_node,,<includes>,cluster_node,,true,,cluster_node,-1
482235,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cluster_nodes,,<includes>,cluster_nodes,,true,,cluster_nodes,-1
482236,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cmd,,<includes>,cmd,,true,,cmd,-1
482237,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,commandDocs*,,<includes>,commandDocs*,,true,,commandDocs*,-1
482238,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,commandDocs[],,<includes>,commandDocs[],,true,,commandDocs[],-1
482239,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,commandHistory*,,<includes>,commandHistory*,,true,,commandHistory*,-1
482240,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,commandListFilter*,,<includes>,commandListFilter*,,true,,commandListFilter*,-1
482241,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,configEnum*,,<includes>,configEnum*,,true,,configEnum*,-1
482242,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,configEnum[],,<includes>,configEnum[],,true,,configEnum[],-1
482243,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,conn,,<includes>,conn,,true,,conn,-1
482244,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,connListener*,,<includes>,connListener*,,true,,connListener*,-1
482245,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,connListener[8],,<includes>,connListener[8],,true,,connListener[8],-1
482246,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,connection*,,<includes>,connection*,,true,,connection*,-1
482247,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,connection**,,<includes>,connection**,,true,,connection**,-1
482248,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,const,,<includes>,const,,true,,const,-1
482249,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,const char*,,<includes>,const char*,,true,,const char*,-1
482250,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,crcfn16,,<includes>,crcfn16,,true,,crcfn16,-1
482251,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,crcfn64,,<includes>,crcfn64,,true,,crcfn64,-1
482252,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,createSparklineSequence,,<includes>,createSparklineSequence,,true,,createSparklineSequence,-1
482253,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,cron_malloc_stats,,<includes>,cron_malloc_stats,,true,,cron_malloc_stats,-1
482254,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ctx,,<includes>,ctx,,true,,ctx,-1
482255,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,current_sec_latency_histogram,,<includes>,current_sec_latency_histogram,,true,,current_sec_latency_histogram,-1
482256,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,data,,<includes>,data,,true,,data,-1
482257,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,db,,<includes>,db,,true,,db,-1
482258,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,deprecatedConfig*,,<includes>,deprecatedConfig*,,true,,deprecatedConfig*,-1
482259,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,deprecatedConfig[],,<includes>,deprecatedConfig[],,true,,deprecatedConfig[],-1
482260,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dict*,,<includes>,dict*,,true,,dict*,-1
482261,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dict**,,<includes>,dict**,,true,,dict**,-1
482262,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dict*[],,<includes>,dict*[],,true,,dict*[],-1
482263,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictDefragAllocFunction*,,<includes>,dictDefragAllocFunction*,,true,,dictDefragAllocFunction*,-1
482264,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictDefragFunctions*,,<includes>,dictDefragFunctions*,,true,,dictDefragFunctions*,-1
482265,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntry*,,<includes>,dictEntry*,,true,,dictEntry*,-1
482266,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntry**,,<includes>,dictEntry**,,true,,dictEntry**,-1
482267,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntry***,,<includes>,dictEntry***,,true,,dictEntry***,-1
482268,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntry**[2],,<includes>,dictEntry**[2],,true,,dictEntry**[2],-1
482269,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntry*[15],,<includes>,dictEntry*[15],,true,,dictEntry*[15],-1
482270,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntry*[],,<includes>,dictEntry*[],,true,,dictEntry*[],-1
482271,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictEntryNoValue*,,<includes>,dictEntryNoValue*,,true,,dictEntryNoValue*,-1
482272,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictIterator*,,<includes>,dictIterator*,,true,,dictIterator*,-1
482273,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictScanFunction*,,<includes>,dictScanFunction*,,true,,dictScanFunction*,-1
482274,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dictType*,,<includes>,dictType*,,true,,dictType*,-1
482275,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,dirent*,,<includes>,dirent*,,true,,dirent*,-1
482276,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,distsamples*,,<includes>,distsamples*,,true,,distsamples*,-1
482277,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,distsamples[],,<includes>,distsamples[],,true,,distsamples[],-1
482278,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,docs,,<includes>,docs,,true,,docs,-1
482279,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double,,<includes>,double,,true,,double,-1
482280,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double*,,<includes>,double*,,true,,double*,-1
482281,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double[2],,<includes>,double[2],,true,,double[2],-1
482282,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double[4],,<includes>,double[4],,true,,double[4],-1
482283,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,double[],,<includes>,double[],,true,,double[],-1
482284,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,durationStats*,,<includes>,durationStats*,,true,,durationStats*,-1
482285,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,durationStats[4],,<includes>,durationStats[4],,true,,durationStats[4],-1
482286,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,engine*,,<includes>,engine*,,true,,engine*,-1
482287,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,engineInfo*,,<includes>,engineInfo*,,true,,engineInfo*,-1
482288,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,enum,,<includes>,enum,,true,,enum,-1
482289,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,epoll_event,,<includes>,epoll_event,,true,,epoll_event,-1
482290,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,epoll_event*,,<includes>,epoll_event*,,true,,epoll_event*,-1
482291,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,errorInfo*,,<includes>,errorInfo*,,true,,errorInfo*,-1
482292,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,events,,<includes>,events,,true,,events,-1
482293,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,evictionPoolEntry*,,<includes>,evictionPoolEntry*,,true,,evictionPoolEntry*,-1
482294,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,expireScanData*,,<includes>,expireScanData*,,true,,expireScanData*,-1
482295,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ext,,<includes>,ext,,true,,ext,-1
482296,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,fail,,<includes>,fail,,true,,fail,-1
482297,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,fd,,<includes>,fd,,true,,fd,-1
482298,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,fd_args,,<includes>,fd_args,,true,,fd_args,-1
482299,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,fd_set,,<includes>,fd_set,,true,,fd_set,-1
482300,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,file,,<includes>,file,,true,,file,-1
482301,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,fk,,<includes>,fk,,true,,fk,-1
482302,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,float,,<includes>,float,,true,,float,-1
482303,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,float*,,<includes>,float*,,true,,float*,-1
482304,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,forward,,<includes>,forward,,true,,forward,-1
482305,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,free_args,,<includes>,free_args,,true,,free_args,-1
482306,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,from_key,,<includes>,from_key,,true,,from_key,-1
482307,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,functionInfo*,,<includes>,functionInfo*,,true,,functionInfo*,-1
482308,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,functionLibInfo*,,<includes>,functionLibInfo*,,true,,functionLibInfo*,-1
482309,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,functionsLibCtx*,,<includes>,functionsLibCtx*,,true,,functionsLibCtx*,-1
482310,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,functionsLibEngineStats*,,<includes>,functionsLibEngineStats*,,true,,functionsLibEngineStats*,-1
482311,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,functionsLibMataData*,,<includes>,functionsLibMataData*,,true,,functionsLibMataData*,-1
482312,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,geoArray*,,<includes>,geoArray*,,true,,geoArray*,-1
482313,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,geoPoint*,,<includes>,geoPoint*,,true,,geoPoint*,-1
482314,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,getKeysResult*,,<includes>,getKeysResult*,,true,,getKeysResult*,-1
482315,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,getMemoryOverheadData,,<includes>,getMemoryOverheadData,,true,,getMemoryOverheadData,-1
482316,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,get_fn,,<includes>,get_fn,,true,,get_fn,-1
482317,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,glob_t,,<includes>,glob_t,,true,,glob_t,-1
482318,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,hashTypeIterator*,,<includes>,hashTypeIterator*,,true,,hashTypeIterator*,-1
482319,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,hdr_histogram*,,<includes>,hdr_histogram*,,true,,hdr_histogram*,-1
482320,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,hdr_histogram**,,<includes>,hdr_histogram**,,true,,hdr_histogram**,-1
482321,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,hdr_iter,,<includes>,hdr_iter,,true,,hdr_iter,-1
482322,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,hdr_iter_percentiles*,,<includes>,hdr_iter_percentiles*,,true,,hdr_iter_percentiles*,-1
482323,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,head,,<includes>,head,,true,,head,-1
482324,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,header,,<includes>,header,,true,,header,-1
482325,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,helpEntry*,,<includes>,helpEntry*,,true,,helpEntry*,-1
482326,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,hllhdr*,,<includes>,hllhdr*,,true,,hllhdr*,-1
482327,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ht,,<includes>,ht,,true,,ht,-1
482328,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,index,,<includes>,index,,true,,index,-1
482329,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,inst_metric,,<includes>,inst_metric,,true,,inst_metric,-1
482330,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,instanceLink*,,<includes>,instanceLink*,,true,,instanceLink*,-1
482331,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int,,<includes>,int,,true,,int,-1
482332,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int*,,<includes>,int*,,true,,int*,-1
482333,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int**,,<includes>,int**,,true,,int**,-1
482334,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int16_t,,<includes>,int16_t,,true,,int16_t,-1
482335,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int32_t,,<includes>,int32_t,,true,,int32_t,-1
482336,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int64_t,,<includes>,int64_t,,true,,int64_t,-1
482337,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int64_t*,,<includes>,int64_t*,,true,,int64_t*,-1
482338,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int64_t[][2],,<includes>,int64_t[][2],,true,,int64_t[][2],-1
482339,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int8_t,,<includes>,int8_t,,true,,int8_t,-1
482340,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int8_t[],,<includes>,int8_t[],,true,,int8_t[],-1
482341,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[12],,<includes>,int[12],,true,,int[12],-1
482342,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[16],,<includes>,int[16],,true,,int[16],-1
482343,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[2],,<includes>,int[2],,true,,int[2],-1
482344,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[3],,<includes>,int[3],,true,,int[3],-1
482345,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[4],,<includes>,int[4],,true,,int[4],-1
482346,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[512],,<includes>,int[512],,true,,int[512],-1
482347,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[64],,<includes>,int[64],,true,,int[64],-1
482348,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,int[],,<includes>,int[],,true,,int[],-1
482349,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,intptr_t,,<includes>,intptr_t,,true,,intptr_t,-1
482350,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,intset*,,<includes>,intset*,,true,,intset*,-1
482351,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,io,,<includes>,io,,true,,io,-1
482352,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,iovec*,,<includes>,iovec*,,true,,iovec*,-1
482353,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,iovec[],,<includes>,iovec[],,true,,iovec[],-1
482354,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,is,,<includes>,is,,true,,is,-1
482355,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,iter,,<includes>,iter,,true,,iter,-1
482356,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,iterset*,,<includes>,iterset*,,true,,iterset*,-1
482357,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,iterzset*,,<includes>,iterzset*,,true,,iterzset*,-1
482358,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,itimerval,,<includes>,itimerval,,true,,itimerval,-1
482359,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,jsonObject*,,<includes>,jsonObject*,,true,,jsonObject*,-1
482360,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kevent,,<includes>,kevent,,true,,kevent,-1
482361,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,kevent*,,<includes>,kevent*,,true,,kevent*,-1
482362,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,key,,<includes>,key,,true,,key,-1
482363,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,keyPattern*,,<includes>,keyPattern*,,true,,keyPattern*,-1
482364,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,keyReference*,,<includes>,keyReference*,,true,,keyReference*,-1
482365,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,keyReference[256],,<includes>,keyReference[256],,true,,keyReference[256],-1
482366,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,keySpec*,,<includes>,keySpec*,,true,,keySpec*,-1
482367,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,keynum,,<includes>,keynum,,true,,keynum,-1
482368,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,keyword,,<includes>,keyword,,true,,keyword,-1
482369,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,latencySample[160],,<includes>,latencySample[160],,true,,latencySample[160],-1
482370,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,latencyStats*,,<includes>,latencyStats*,,true,,latencyStats*,-1
482371,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,latencyTimeSeries*,,<includes>,latencyTimeSeries*,,true,,latencyTimeSeries*,-1
482372,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,latency_histogram,,<includes>,latency_histogram,,true,,latency_histogram,-1
482373,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lazy_free_fn,,<includes>,lazy_free_fn,,true,,lazy_free_fn,-1
482374,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lazy_free_fn*,,<includes>,lazy_free_fn*,,true,,lazy_free_fn*,-1
482375,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lctx,,<includes>,lctx,,true,,lctx,-1
482376,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ldb,,<includes>,ldb,,true,,ldb,-1
482377,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,level,,<includes>,level,,true,,level,-1
482378,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,linenoiseCompletions*,,<includes>,linenoiseCompletions*,,true,,linenoiseCompletions*,-1
482379,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,list*,,<includes>,list*,,true,,list*,-1
482380,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,list*[128],,<includes>,list*[128],,true,,list*[128],-1
482381,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,list*[3],,<includes>,list*[3],,true,,list*[3],-1
482382,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,list*[],,<includes>,list*[],,true,,list*[],-1
482383,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,listIter*,,<includes>,listIter*,,true,,listIter*,-1
482384,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,listNode*,,<includes>,listNode*,,true,,listNode*,-1
482385,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,listTypeEntry*,,<includes>,listTypeEntry*,,true,,listTypeEntry*,-1
482386,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,listTypeIterator*,,<includes>,listTypeIterator*,,true,,listTypeIterator*,-1
482387,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,listpackEntry*,,<includes>,listpackEntry*,,true,,listpackEntry*,-1
482388,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,listpackValidateEntryCB,,<includes>,listpackValidateEntryCB,,true,,listpackValidateEntryCB,-1
482389,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,loadCtx*,,<includes>,loadCtx*,,true,,loadCtx*,-1
482390,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,loadmod,,<includes>,loadmod,,true,,loadmod,-1
482391,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long,,<includes>,long,,true,,long,-1
482392,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long double,,<includes>,long double,,true,,long double,-1
482393,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long int,,<includes>,long int,,true,,long int,-1
482394,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long,,<includes>,long long,,true,,long long,-1
482395,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long int,,<includes>,long long int,,true,,long long int,-1
482396,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long unsigned,,<includes>,long long unsigned,,true,,long long unsigned,-1
482397,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long unsigned*,,<includes>,long long unsigned*,,true,,long long unsigned*,-1
482398,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long long*,,<includes>,long long*,,true,,long long*,-1
482399,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long unsigned,,<includes>,long unsigned,,true,,long unsigned,-1
482400,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long unsigned int,,<includes>,long unsigned int,,true,,long unsigned int,-1
482401,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long unsigned*,,<includes>,long unsigned*,,true,,long unsigned*,-1
482402,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,long*,,<includes>,long*,,true,,long*,-1
482403,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longdouble*,,<includes>,longdouble*,,true,,longdouble*,-1
482404,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longint*,,<includes>,longint*,,true,,longint*,-1
482405,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longlong*,,<includes>,longlong*,,true,,longlong*,-1
482406,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longlongint[11],,<includes>,longlongint[11],,true,,longlongint[11],-1
482407,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longlongint[16],,<includes>,longlongint[16],,true,,longlongint[16],-1
482408,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longlongunsigned*,,<includes>,longlongunsigned*,,true,,longlongunsigned*,-1
482409,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longlongunsigned[],,<includes>,longlongunsigned[],,true,,longlongunsigned[],-1
482410,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,longunsigned*,,<includes>,longunsigned*,,true,,longunsigned*,-1
482411,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupCommand,,<includes>,lookupCommand,,true,,lookupCommand,-1
482412,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupCommandByCString,,<includes>,lookupCommandByCString,,true,,lookupCommandByCString,-1
482413,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupCommandByCStringLogic,,<includes>,lookupCommandByCStringLogic,,true,,lookupCommandByCStringLogic,-1
482414,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupCommandBySds,,<includes>,lookupCommandBySds,,true,,lookupCommandBySds,-1
482415,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupCommandBySdsLogic,,<includes>,lookupCommandBySdsLogic,,true,,lookupCommandBySdsLogic,-1
482416,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupCommandOrOriginal,,<includes>,lookupCommandOrOriginal,,true,,lookupCommandOrOriginal,-1
482417,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lookupSubcommand,,<includes>,lookupSubcommand,,true,,lookupSubcommand,-1
482418,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lp,,<includes>,lp,,true,,lp,-1
482419,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,luaEngineCtx*,,<includes>,luaEngineCtx*,,true,,luaEngineCtx*,-1
482420,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,luaFunctionCtx*,,<includes>,luaFunctionCtx*,,true,,luaFunctionCtx*,-1
482421,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,luaScript*,,<includes>,luaScript*,,true,,luaScript*,-1
482422,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lua_CFunction,,<includes>,lua_CFunction,,true,,lua_CFunction,-1
482423,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lua_Debug,,<includes>,lua_Debug,,true,,lua_Debug,-1
482424,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lua_Debug*,,<includes>,lua_Debug*,,true,,lua_Debug*,-1
482425,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lua_Number,,<includes>,lua_Number,,true,,lua_Number,-1
482426,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lua_State*,,<includes>,lua_State*,,true,,lua_State*,-1
482427,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,lwCanvas*,,<includes>,lwCanvas*,,true,,lwCanvas*,-1
482428,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,master,,<includes>,master,,true,,master,-1
482429,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,migrateCachedSocket*,,<includes>,migrateCachedSocket*,,true,,migrateCachedSocket*,-1
482430,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,mode_t,,<includes>,mode_t,,true,,mode_t,-1
482431,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,mode_t*,,<includes>,mode_t*,,true,,mode_t*,-1
482432,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,module,,<includes>,module,,true,,module,-1
482433,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleClusterReceiver*,,<includes>,moduleClusterReceiver*,,true,,moduleClusterReceiver*,-1
482434,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleClusterReceiver*[],,<includes>,moduleClusterReceiver*[],,true,,moduleClusterReceiver*[],-1
482435,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleCopyCommandArgs,,<includes>,moduleCopyCommandArgs,,true,,moduleCopyCommandArgs,-1
482436,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleForkInfo,,<includes>,moduleForkInfo,,true,,moduleForkInfo,-1
482437,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleLoadQueueEntry*,,<includes>,moduleLoadQueueEntry*,,true,,moduleLoadQueueEntry*,-1
482438,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleType*,,<includes>,moduleType*,,true,,moduleType*,-1
482439,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeAuxLoadFunc,,<includes>,moduleTypeAuxLoadFunc,,true,,moduleTypeAuxLoadFunc,-1
482440,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeAuxSaveFunc,,<includes>,moduleTypeAuxSaveFunc,,true,,moduleTypeAuxSaveFunc,-1
482441,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeCopyFunc,,<includes>,moduleTypeCopyFunc,,true,,moduleTypeCopyFunc,-1
482442,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeCopyFunc2,,<includes>,moduleTypeCopyFunc2,,true,,moduleTypeCopyFunc2,-1
482443,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeDefragFunc,,<includes>,moduleTypeDefragFunc,,true,,moduleTypeDefragFunc,-1
482444,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeDigestFunc,,<includes>,moduleTypeDigestFunc,,true,,moduleTypeDigestFunc,-1
482445,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeFreeEffortFunc,,<includes>,moduleTypeFreeEffortFunc,,true,,moduleTypeFreeEffortFunc,-1
482446,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeFreeEffortFunc2,,<includes>,moduleTypeFreeEffortFunc2,,true,,moduleTypeFreeEffortFunc2,-1
482447,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeFreeFunc,,<includes>,moduleTypeFreeFunc,,true,,moduleTypeFreeFunc,-1
482448,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeLoadFunc,,<includes>,moduleTypeLoadFunc,,true,,moduleTypeLoadFunc,-1
482449,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeMemUsageFunc,,<includes>,moduleTypeMemUsageFunc,,true,,moduleTypeMemUsageFunc,-1
482450,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeMemUsageFunc2,,<includes>,moduleTypeMemUsageFunc2,,true,,moduleTypeMemUsageFunc2,-1
482451,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeRewriteFunc,,<includes>,moduleTypeRewriteFunc,,true,,moduleTypeRewriteFunc,-1
482452,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeSaveFunc,,<includes>,moduleTypeSaveFunc,,true,,moduleTypeSaveFunc,-1
482453,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeUnlinkFunc,,<includes>,moduleTypeUnlinkFunc,,true,,moduleTypeUnlinkFunc,-1
482454,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleTypeUnlinkFunc2,,<includes>,moduleTypeUnlinkFunc2,,true,,moduleTypeUnlinkFunc2,-1
482455,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,moduleValue*,,<includes>,moduleValue*,,true,,moduleValue*,-1
482456,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,module_cmd,,<includes>,module_cmd,,true,,module_cmd,-1
482457,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,monotime*,,<includes>,monotime*,,true,,monotime*,-1
482458,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,mstime_t*,,<includes>,mstime_t*,,true,,mstime_t*,-1
482459,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,multiCmd*,,<includes>,multiCmd*,,true,,multiCmd*,-1
482460,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,multiState*,,<includes>,multiState*,,true,,multiState*,-1
482461,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,next,,<includes>,next,,true,,next,-1
482462,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,node,,<includes>,node,,true,,node,-1
482463,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,off_t,,<includes>,off_t,,true,,off_t,-1
482464,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,off_t*,,<includes>,off_t*,,true,,off_t*,-1
482465,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,orig_termios,,<includes>,orig_termios,,true,,orig_termios,-1
482466,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pa_head,,<includes>,pa_head,,true,,pa_head,-1
482467,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,parent,,<includes>,parent,,true,,parent,-1
482468,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pause_event*,,<includes>,pause_event*,,true,,pause_event*,-1
482469,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pause_event[3],,<includes>,pause_event[3],,true,,pause_event[3],-1
482470,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pick,,<includes>,pick,,true,,pick,-1
482471,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pick*,,<includes>,pick*,,true,,pick*,-1
482472,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pid_t,,<includes>,pid_t,,true,,pid_t,-1
482473,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ping,,<includes>,ping,,true,,ping,-1
482474,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pollfd,,<includes>,pollfd,,true,,pollfd,-1
482475,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,port_event_t[512],,<includes>,port_event_t[512],,true,,port_event_t[512],-1
482476,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,prev,,<includes>,prev,,true,,prev,-1
482477,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,promoted_slave,,<includes>,promoted_slave,,true,,promoted_slave,-1
482478,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_attr_t,,<includes>,pthread_attr_t,,true,,pthread_attr_t,-1
482479,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_cond_t[],,<includes>,pthread_cond_t[],,true,,pthread_cond_t[],-1
482480,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_mutex_t,,<includes>,pthread_mutex_t,,true,,pthread_mutex_t,-1
482481,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_mutex_t[128],,<includes>,pthread_mutex_t[128],,true,,pthread_mutex_t[128],-1
482482,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_mutex_t[],,<includes>,pthread_mutex_t[],,true,,pthread_mutex_t[],-1
482483,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_t,,<includes>,pthread_t,,true,,pthread_t,-1
482484,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_t[128],,<includes>,pthread_t[128],,true,,pthread_t[128],-1
482485,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,pthread_t[],,<includes>,pthread_t[],,true,,pthread_t[],-1
482486,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,publish,,<includes>,publish,,true,,publish,-1
482487,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklist*,,<includes>,quicklist*,,true,,quicklist*,-1
482488,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklist**,,<includes>,quicklist**,,true,,quicklist**,-1
482489,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklistBookmark*,,<includes>,quicklistBookmark*,,true,,quicklistBookmark*,-1
482490,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklistBookmark[],,<includes>,quicklistBookmark[],,true,,quicklistBookmark[],-1
482491,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklistEntry*,,<includes>,quicklistEntry*,,true,,quicklistEntry*,-1
482492,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklistIter*,,<includes>,quicklistIter*,,true,,quicklistIter*,-1
482493,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklistLZF*,,<includes>,quicklistLZF*,,true,,quicklistLZF*,-1
482494,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,quicklistNode*,,<includes>,quicklistNode*,,true,,quicklistNode*,-1
482495,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,r,,<includes>,r,,true,,r,-1
482496,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rand_pick*,,<includes>,rand_pick*,,true,,rand_pick*,-1
482497,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,range,,<includes>,range,,true,,range,-1
482498,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rax*,,<includes>,rax*,,true,,rax*,-1
482499,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,raxIterator*,,<includes>,raxIterator*,,true,,raxIterator*,-1
482500,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,raxNode*,,<includes>,raxNode*,,true,,raxNode*,-1
482501,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,raxNode**,,<includes>,raxNode**,,true,,raxNode**,-1
482502,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,raxNode***,,<includes>,raxNode***,,true,,raxNode***,-1
482503,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,raxNodeCallback,,<includes>,raxNodeCallback,,true,,raxNodeCallback,-1
482504,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,raxStack*,,<includes>,raxStack*,,true,,raxStack*,-1
482505,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rdbLoadingCtx*,,<includes>,rdbLoadingCtx*,,true,,rdbLoadingCtx*,-1
482506,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rdbSaveInfo*,,<includes>,rdbSaveInfo*,,true,,rdbSaveInfo*,-1
482507,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,readyList*,,<includes>,readyList*,,true,,readyList*,-1
482508,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,realcmd,,<includes>,realcmd,,true,,realcmd,-1
482509,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisAeEvents*,,<includes>,redisAeEvents*,,true,,redisAeEvents*,-1
482510,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisAsyncContext*,,<includes>,redisAsyncContext*,,true,,redisAsyncContext*,-1
482511,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCallback*,,<includes>,redisCallback*,,true,,redisCallback*,-1
482512,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCallbackList*,,<includes>,redisCallbackList*,,true,,redisCallbackList*,-1
482513,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCommand*,,<includes>,redisCommand*,,true,,redisCommand*,-1
482514,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCommandArg*,,<includes>,redisCommandArg*,,true,,redisCommandArg*,-1
482515,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCommandProc*,,<includes>,redisCommandProc*,,true,,redisCommandProc*,-1
482516,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCommandTable,,<includes>,redisCommandTable,,true,,redisCommandTable,-1
482517,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisCommand[],,<includes>,redisCommand[],,true,,redisCommand[],-1
482518,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisConfig*,,<includes>,redisConfig*,,true,,redisConfig*,-1
482519,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisContext,,<includes>,redisContext,,true,,redisContext,-1
482520,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisContext*,,<includes>,redisContext*,,true,,redisContext*,-1
482521,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisDb*,,<includes>,redisDb*,,true,,redisDb*,-1
482522,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisError*,,<includes>,redisError*,,true,,redisError*,-1
482523,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisGetKeysProc*,,<includes>,redisGetKeysProc*,,true,,redisGetKeysProc*,-1
482524,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisMemOverhead*,,<includes>,redisMemOverhead*,,true,,redisMemOverhead*,-1
482525,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisNodeFlags*,,<includes>,redisNodeFlags*,,true,,redisNodeFlags*,-1
482526,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisNodeFlagsTable,,<includes>,redisNodeFlagsTable,,true,,redisNodeFlagsTable,-1
482527,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisNodeFlags[],,<includes>,redisNodeFlags[],,true,,redisNodeFlags[],-1
482528,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*,,<includes>,redisObject*,,true,,redisObject*,-1
482529,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[10000],,<includes>,redisObject*[10000],,true,,redisObject*[10000],-1
482530,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[10],,<includes>,redisObject*[10],,true,,redisObject*[10],-1
482531,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[14],,<includes>,redisObject*[14],,true,,redisObject*[14],-1
482532,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[1],,<includes>,redisObject*[1],,true,,redisObject*[1],-1
482533,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[2],,<includes>,redisObject*[2],,true,,redisObject*[2],-1
482534,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[32],,<includes>,redisObject*[32],,true,,redisObject*[32],-1
482535,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[3],,<includes>,redisObject*[3],,true,,redisObject*[3],-1
482536,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[4],,<includes>,redisObject*[4],,true,,redisObject*[4],-1
482537,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[5],,<includes>,redisObject*[5],,true,,redisObject*[5],-1
482538,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[7],,<includes>,redisObject*[7],,true,,redisObject*[7],-1
482539,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject*[],,<includes>,redisObject*[],,true,,redisObject*[],-1
482540,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisObject[],,<includes>,redisObject[],,true,,redisObject[],-1
482541,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisOp*,,<includes>,redisOp*,,true,,redisOp*,-1
482542,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisOpArray*,,<includes>,redisOpArray*,,true,,redisOpArray*,-1
482543,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisReply,,<includes>,redisReply,,true,,redisReply,-1
482544,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisReply*,,<includes>,redisReply*,,true,,redisReply*,-1
482545,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisSortObject*,,<includes>,redisSortObject*,,true,,redisSortObject*,-1
482546,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redisSortOperation*,,<includes>,redisSortOperation*,,true,,redisSortOperation*,-1
482547,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,redis_config,,<includes>,redis_config,,true,,redis_config,-1
482548,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rediscmd,,<includes>,rediscmd,,true,,rediscmd,-1
482549,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,registerFunctionArgs*,,<includes>,registerFunctionArgs*,,true,,registerFunctionArgs*,-1
482550,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,replBacklog*,,<includes>,replBacklog*,,true,,replBacklog*,-1
482551,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,replBufBlock*,,<includes>,replBufBlock*,,true,,replBufBlock*,-1
482552,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,replyFlagNames*,,<includes>,replyFlagNames*,,true,,replyFlagNames*,-1
482553,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,replyFlagNames[],,<includes>,replyFlagNames[],,true,,replyFlagNames[],-1
482554,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,reply_schema,,<includes>,reply_schema,,true,,reply_schema,-1
482555,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rewriteConfigState*,,<includes>,rewriteConfigState*,,true,,rewriteConfigState*,-1
482556,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rio*,,<includes>,rio*,,true,,rio*,-1
482557,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rlim_t,,<includes>,rlim_t,,true,,rlim_t,-1
482558,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rlimit,,<includes>,rlimit,,true,,rlimit,-1
482559,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,robj*,,<includes>,robj*,,true,,robj*,-1
482560,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,robj**,,<includes>,robj**,,true,,robj**,-1
482561,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,robj***,,<includes>,robj***,,true,,robj***,-1
482562,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,rusage,,<includes>,rusage,,true,,rusage,-1
482563,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sample*,,<includes>,sample*,,true,,sample*,-1
482564,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,samples,,<includes>,samples,,true,,samples,-1
482565,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,saveparam*,,<includes>,saveparam*,,true,,saveparam*,-1
482566,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,saveparams,,<includes>,saveparams,,true,,saveparams,-1
482567,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,scanData*,,<includes>,scanData*,,true,,scanData*,-1
482568,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,scriptFlag*,,<includes>,scriptFlag*,,true,,scriptFlag*,-1
482569,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,scriptFlag[],,<includes>,scriptFlag[],,true,,scriptFlag[],-1
482570,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,scriptRunCtx*,,<includes>,scriptRunCtx*,,true,,scriptRunCtx*,-1
482571,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sds*,,<includes>,sds*,,true,,sds*,-1
482572,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sds**,,<includes>,sds**,,true,,sds**,-1
482573,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sds[16],,<includes>,sds[16],,true,,sds[16],-1
482574,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sdshdr16*,,<includes>,sdshdr16*,,true,,sdshdr16*,-1
482575,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sdshdr32*,,<includes>,sdshdr32*,,true,,sdshdr32*,-1
482576,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sdshdr64*,,<includes>,sdshdr64*,,true,,sdshdr64*,-1
482577,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sdshdr8*,,<includes>,sdshdr8*,,true,,sdshdr8*,-1
482578,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sdstemplate_callback_t,,<includes>,sdstemplate_callback_t,,true,,sdstemplate_callback_t,-1
482579,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinel,,<includes>,sentinel,,true,,sentinel,-1
482580,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelAddr*,,<includes>,sentinelAddr*,,true,,sentinelAddr*,-1
482581,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelAddr**,,<includes>,sentinelAddr**,,true,,sentinelAddr**,-1
482582,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelConfig*,,<includes>,sentinelConfig*,,true,,sentinelConfig*,-1
482583,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelLoadQueueEntry*,,<includes>,sentinelLoadQueueEntry*,,true,,sentinelLoadQueueEntry*,-1
482584,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelRedisInstance*,,<includes>,sentinelRedisInstance*,,true,,sentinelRedisInstance*,-1
482585,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelRedisInstance**,,<includes>,sentinelRedisInstance**,,true,,sentinelRedisInstance**,-1
482586,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinelScriptJob*,,<includes>,sentinelScriptJob*,,true,,sentinelScriptJob*,-1
482587,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sentinel_config,,<includes>,sentinel_config,,true,,sentinel_config,-1
482588,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sequence*,,<includes>,sequence*,,true,,sequence*,-1
482589,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,server,,<includes>,server,,true,,server,-1
482590,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,set,,<includes>,set,,true,,set,-1
482591,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,setTypeIterator*,,<includes>,setTypeIterator*,,true,,setTypeIterator*,-1
482592,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,set_fn,,<includes>,set_fn,,true,,set_fn,-1
482593,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,shared,,<includes>,shared,,true,,shared,-1
482594,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,short int,,<includes>,short int,,true,,short int,-1
482595,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,short unsigned,,<includes>,short unsigned,,true,,short unsigned,-1
482596,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,short unsigned int,,<includes>,short unsigned int,,true,,short unsigned int,-1
482597,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sig_atomic_t,,<includes>,sig_atomic_t,,true,,sig_atomic_t,-1
482598,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sigaction,,<includes>,sigaction,,true,,sigaction,-1
482599,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,siginfo_t*,,<includes>,siginfo_t*,,true,,siginfo_t*,-1
482600,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,signed char,,<includes>,signed char,,true,,signed char,-1
482601,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,signed int,,<includes>,signed int,,true,,signed int,-1
482602,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,signedchar[2],,<includes>,signedchar[2],,true,,signedchar[2],-1
482603,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sigset_t,,<includes>,sigset_t,,true,,sigset_t,-1
482604,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t,,<includes>,size_t,,true,,size_t,-1
482605,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t*,,<includes>,size_t*,,true,,size_t*,-1
482606,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[32],,<includes>,size_t[32],,true,,size_t[32],-1
482607,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[3],,<includes>,size_t[3],,true,,size_t[3],-1
482608,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[4],,<includes>,size_t[4],,true,,size_t[4],-1
482609,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[8],,<includes>,size_t[8],,true,,size_t[8],-1
482610,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,size_t[],,<includes>,size_t[],,true,,size_t[],-1
482611,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,skyscraper*,,<includes>,skyscraper*,,true,,skyscraper*,-1
482612,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sl,,<includes>,sl,,true,,sl,-1
482613,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,slaveof,,<includes>,slaveof,,true,,slaveof,-1
482614,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,slaves,,<includes>,slaves,,true,,slaves,-1
482615,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,slotToKeys*,,<includes>,slotToKeys*,,true,,slotToKeys*,-1
482616,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,slotToKeys[16384],,<includes>,slotToKeys[16384],,true,,slotToKeys[16384],-1
482617,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,slowlogEntry*,,<includes>,slowlogEntry*,,true,,slowlogEntry*,-1
482618,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sockaddr*,,<includes>,sockaddr*,,true,,sockaddr*,-1
482619,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sockaddr_in*,,<includes>,sockaddr_in*,,true,,sockaddr_in*,-1
482620,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sockaddr_in6*,,<includes>,sockaddr_in6*,,true,,sockaddr_in6*,-1
482621,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sockaddr_storage,,<includes>,sockaddr_storage,,true,,sockaddr_storage,-1
482622,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sockaddr_un,,<includes>,sockaddr_un,,true,,sockaddr_un,-1
482623,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,socklen_t,,<includes>,socklen_t,,true,,socklen_t,-1
482624,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,socklen_t*,,<includes>,socklen_t*,,true,,socklen_t*,-1
482625,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ssize_t,,<includes>,ssize_t,,true,,ssize_t,-1
482626,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ssize_t*,,<includes>,ssize_t*,,true,,ssize_t*,-1
482627,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,sslconfig,,<includes>,sslconfig,,true,,sslconfig,-1
482628,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,standardConfig*,,<includes>,standardConfig*,,true,,standardConfig*,-1
482629,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,standardConfig**,,<includes>,standardConfig**,,true,,standardConfig**,-1
482630,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,standardConfig[],,<includes>,standardConfig[],,true,,standardConfig[],-1
482631,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,stat,,<includes>,stat,,true,,stat,-1
482632,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static pthread_cond_t[],,<includes>,static pthread_cond_t[],,true,,static pthread_cond_t[],-1
482633,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static pthread_mutex_t[],,<includes>,static pthread_mutex_t[],,true,,static pthread_mutex_t[],-1
482634,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static pthread_t[],,<includes>,static pthread_t[],,true,,static pthread_t[],-1
482635,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static size_t[32],,<includes>,static size_t[32],,true,,static size_t[32],-1
482636,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static uint32_t[3],,<includes>,static uint32_t[3],,true,,static uint32_t[3],-1
482637,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static uint64_t[8][256],,<includes>,static uint64_t[8][256],,true,,static uint64_t[8][256],-1
482638,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static uint64_t[],,<includes>,static uint64_t[],,true,,static uint64_t[],-1
482639,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static uint8_t[16],,<includes>,static uint8_t[16],,true,,static uint8_t[16],-1
482640,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,static[3],,<includes>,static[3],,true,,static[3],-1
482641,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,stream*,,<includes>,stream*,,true,,stream*,-1
482642,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamAddTrimArgs*,,<includes>,streamAddTrimArgs*,,true,,streamAddTrimArgs*,-1
482643,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamCG*,,<includes>,streamCG*,,true,,streamCG*,-1
482644,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamCG**,,<includes>,streamCG**,,true,,streamCG**,-1
482645,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamConsumer*,,<includes>,streamConsumer*,,true,,streamConsumer*,-1
482646,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamID*,,<includes>,streamID*,,true,,streamID*,-1
482647,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamID[8],,<includes>,streamID[8],,true,,streamID[8],-1
482648,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamIterator*,,<includes>,streamIterator*,,true,,streamIterator*,-1
482649,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamNACK*,,<includes>,streamNACK*,,true,,streamNACK*,-1
482650,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,streamPropInfo*,,<includes>,streamPropInfo*,,true,,streamPropInfo*,-1
482651,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct,,<includes>,struct,,true,,struct,-1
482652,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct HelloTypeObject,,<includes>,struct HelloTypeObject,,true,,struct HelloTypeObject,-1
482653,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct client,,<includes>,struct client,,true,,struct client,-1
482654,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct redisCommand,,<includes>,struct redisCommand,,true,,struct redisCommand,-1
482655,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct redisCommandArg,,<includes>,struct redisCommandArg,,true,,struct redisCommandArg,-1
482656,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct redisMemOverhead,,<includes>,struct redisMemOverhead,,true,,struct redisMemOverhead,-1
482657,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct rewriteConfigState,,<includes>,struct rewriteConfigState,,true,,struct rewriteConfigState,-1
482658,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct sequence,,<includes>,struct sequence,,true,,struct sequence,-1
482659,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,struct*,,<includes>,struct*,,true,,struct*,-1
482660,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,subargs,,<includes>,subargs,,true,,subargs,-1
482661,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,subcommands,,<includes>,subcommands,,true,,subcommands,-1
482662,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,t,,<includes>,t,,true,,t,-1
482663,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,threads,,<includes>,threads,,true,,threads,-1
482664,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,threads_pending[128],,<includes>,threads_pending[128],,true,,threads_pending[128],-1
482665,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,time_t,,<includes>,time_t,,true,,time_t,-1
482666,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,time_t*,,<includes>,time_t*,,true,,time_t*,-1
482667,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,timespec,,<includes>,timespec,,true,,timespec,-1
482668,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,timespec*,,<includes>,timespec*,,true,,timespec*,-1
482669,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,timeval,,<includes>,timeval,,true,,timeval,-1
482670,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,timeval*,,<includes>,timeval*,,true,,timeval*,-1
482671,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,timezone,,<includes>,timezone,,true,,timezone,-1
482672,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,tm,,<includes>,tm,,true,,tm,-1
482673,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,tm*,,<includes>,tm*,,true,,tm*,-1
482674,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,typeinfo*,,<includes>,typeinfo*,,true,,typeinfo*,-1
482675,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,typeinfo**,,<includes>,typeinfo**,,true,,typeinfo**,-1
482676,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,typemethods*,,<includes>,typemethods*,,true,,typemethods*,-1
482677,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,u,,<includes>,u,,true,,u,-1
482678,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,u8*,,<includes>,u8*,,true,,u8*,-1
482679,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint16_t,,<includes>,uint16_t,,true,,uint16_t,-1
482680,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint16_t*,,<includes>,uint16_t*,,true,,uint16_t*,-1
482681,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint16_t[16384],,<includes>,uint16_t[16384],,true,,uint16_t[16384],-1
482682,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint16_t[8][256],,<includes>,uint16_t[8][256],,true,,uint16_t[8][256],-1
482683,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t,,<includes>,uint32_t,,true,,uint32_t,-1
482684,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t*,,<includes>,uint32_t*,,true,,uint32_t*,-1
482685,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t[2],,<includes>,uint32_t[2],,true,,uint32_t[2],-1
482686,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t[3],,<includes>,uint32_t[3],,true,,uint32_t[3],-1
482687,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint32_t[5],,<includes>,uint32_t[5],,true,,uint32_t[5],-1
482688,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t,,<includes>,uint64_t,,true,,uint64_t,-1
482689,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t*,,<includes>,uint64_t*,,true,,uint64_t*,-1
482690,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t[16],,<includes>,uint64_t[16],,true,,uint64_t[16],-1
482691,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t[2],,<includes>,uint64_t[2],,true,,uint64_t[2],-1
482692,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t[8][256],,<includes>,uint64_t[8][256],,true,,uint64_t[8][256],-1
482693,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint64_t[],,<includes>,uint64_t[],,true,,uint64_t[],-1
482694,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t,,<includes>,uint8_t,,true,,uint8_t,-1
482695,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t*,,<includes>,uint8_t*,,true,,uint8_t*,-1
482696,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[16384],,<includes>,uint8_t[16384],,true,,uint8_t[16384],-1
482697,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[16],,<includes>,uint8_t[16],,true,,uint8_t[16],-1
482698,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[1],,<includes>,uint8_t[1],,true,,uint8_t[1],-1
482699,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[3],,<includes>,uint8_t[3],,true,,uint8_t[3],-1
482700,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[5],,<includes>,uint8_t[5],,true,,uint8_t[5],-1
482701,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[8],,<includes>,uint8_t[8],,true,,uint8_t[8],-1
482702,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint8_t[],,<includes>,uint8_t[],,true,,uint8_t[],-1
482703,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint_fast64_t,,<includes>,uint_fast64_t,,true,,uint_fast64_t,-1
482704,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint_fast8_t,,<includes>,uint_fast8_t,,true,,uint_fast8_t,-1
482705,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,uint_t,,<includes>,uint_t,,true,,uint_t,-1
482706,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,union,,<includes>,union,,true,,union,-1
482707,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,union _iterset,,<includes>,union _iterset,,true,,union _iterset,-1
482708,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,union _iterzset,,<includes>,union _iterzset,,true,,union _iterzset,-1
482709,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,union clusterMsgData,,<includes>,union clusterMsgData,,true,,union clusterMsgData,-1
482710,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,union get_fn,,<includes>,union get_fn,,true,,union get_fn,-1
482711,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,union set_fn,,<includes>,union set_fn,,true,,union set_fn,-1
482712,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned,,<includes>,unsigned,,true,,unsigned,-1
482713,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char,,<includes>,unsigned char,,true,,unsigned char,-1
482714,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char*,,<includes>,unsigned char*,,true,,unsigned char*,-1
482715,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char**,,<includes>,unsigned char**,,true,,unsigned char**,-1
482716,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[128],,<includes>,unsigned char[128],,true,,unsigned char[128],-1
482717,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[16],,<includes>,unsigned char[16],,true,,unsigned char[16],-1
482718,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[2048],,<includes>,unsigned char[2048],,true,,unsigned char[2048],-1
482719,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[20],,<includes>,unsigned char[20],,true,,unsigned char[20],-1
482720,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[21],,<includes>,unsigned char[21],,true,,unsigned char[21],-1
482721,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[256],,<includes>,unsigned char[256],,true,,unsigned char[256],-1
482722,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[2],,<includes>,unsigned char[2],,true,,unsigned char[2],-1
482723,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[32],,<includes>,unsigned char[32],,true,,unsigned char[32],-1
482724,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[3],,<includes>,unsigned char[3],,true,,unsigned char[3],-1
482725,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[4],,<includes>,unsigned char[4],,true,,unsigned char[4],-1
482726,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[5],,<includes>,unsigned char[5],,true,,unsigned char[5],-1
482727,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[64],,<includes>,unsigned char[64],,true,,unsigned char[64],-1
482728,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[65536],,<includes>,unsigned char[65536],,true,,unsigned char[65536],-1
482729,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[8],,<includes>,unsigned char[8],,true,,unsigned char[8],-1
482730,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[9],,<includes>,unsigned char[9],,true,,unsigned char[9],-1
482731,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned char[],,<includes>,unsigned char[],,true,,unsigned char[],-1
482732,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned int,,<includes>,unsigned int,,true,,unsigned int,-1
482733,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned int*,,<includes>,unsigned int*,,true,,unsigned int*,-1
482734,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned int[9],,<includes>,unsigned int[9],,true,,unsigned int[9],-1
482735,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned int[],,<includes>,unsigned int[],,true,,unsigned int[],-1
482736,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned long,,<includes>,unsigned long,,true,,unsigned long,-1
482737,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned long long,,<includes>,unsigned long long,,true,,unsigned long long,-1
482738,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint,,<includes>,unsigned longint,,true,,unsigned longint,-1
482739,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint*[16],,<includes>,unsigned longint*[16],,true,,unsigned longint*[16],-1
482740,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint[256],,<includes>,unsigned longint[256],,true,,unsigned longint[256],-1
482741,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint[2],,<includes>,unsigned longint[2],,true,,unsigned longint[2],-1
482742,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint[32],,<includes>,unsigned longint[32],,true,,unsigned longint[32],-1
482743,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint[4],,<includes>,unsigned longint[4],,true,,unsigned longint[4],-1
482744,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint[50],,<includes>,unsigned longint[50],,true,,unsigned longint[50],-1
482745,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longint[],,<includes>,unsigned longint[],,true,,unsigned longint[],-1
482746,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longlongint,,<includes>,unsigned longlongint,,true,,unsigned longlongint,-1
482747,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longlongint[16],,<includes>,unsigned longlongint[16],,true,,unsigned longlongint[16],-1
482748,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longlongint[2],,<includes>,unsigned longlongint[2],,true,,unsigned longlongint[2],-1
482749,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longlongint[312],,<includes>,unsigned longlongint[312],,true,,unsigned longlongint[312],-1
482750,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,unsigned longlongint[6],,<includes>,unsigned longlongint[6],,true,,unsigned longlongint[6],-1
482751,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,update,,<includes>,update,,true,,update,-1
482752,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,user*,,<includes>,user*,,true,,user*,-1
482753,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,utsname,,<includes>,utsname,,true,,utsname,-1
482754,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,v,,<includes>,v,,true,,v,-1
482755,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,va_list,,<includes>,va_list,,true,,va_list,-1
482756,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,val,,<includes>,val,,true,,val,-1
482757,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,verbatim_str,,<includes>,verbatim_str,,true,,verbatim_str,-1
482758,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void,,<includes>,void,,true,,void,-1
482759,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void(*)(int),,<includes>,void(*)(int),,true,,void(*)(int),-1
482760,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void*,,<includes>,void*,,true,,void*,-1
482761,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void**,,<includes>,void**,,true,,void**,-1
482762,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void*[32],,<includes>,void*[32],,true,,void*[32],-1
482763,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void*[],,<includes>,void*[],,true,,void*[],-1
482764,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,void[]*,,<includes>,void[]*,,true,,void[]*,-1
482765,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,watchedKey*,,<includes>,watchedKey*,,true,,watchedKey*,-1
482766,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ws,,<includes>,ws,,true,,ws,-1
482767,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ziplistEntry*,,<includes>,ziplistEntry*,,true,,ziplistEntry*,-1
482768,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,ziplistValidateEntryCB,,<includes>,ziplistValidateEntryCB,,true,,ziplistValidateEntryCB,-1
482769,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zl,,<includes>,zl,,true,,zl,-1
482770,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zlentry*,,<includes>,zlentry*,,true,,zlentry*,-1
482771,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zlexrangespec*,,<includes>,zlexrangespec*,,true,,zlexrangespec*,-1
482772,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zrangeResultBeginFunction,,<includes>,zrangeResultBeginFunction,,true,,zrangeResultBeginFunction,-1
482773,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zrangeResultEmitCBufferFunction,,<includes>,zrangeResultEmitCBufferFunction,,true,,zrangeResultEmitCBufferFunction,-1
482774,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zrangeResultEmitLongLongFunction,,<includes>,zrangeResultEmitLongLongFunction,,true,,zrangeResultEmitLongLongFunction,-1
482775,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zrangeResultFinalizeFunction,,<includes>,zrangeResultFinalizeFunction,,true,,zrangeResultFinalizeFunction,-1
482776,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zrange_result_handler*,,<includes>,zrange_result_handler*,,true,,zrange_result_handler*,-1
482777,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zrangespec*,,<includes>,zrangespec*,,true,,zrangespec*,-1
482778,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zset*,,<includes>,zset*,,true,,zset*,-1
482779,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zsetopsrc*,,<includes>,zsetopsrc*,,true,,zsetopsrc*,-1
482780,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zsetopval*,,<includes>,zsetopval*,,true,,zsetopval*,-1
482781,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zskiplist*,,<includes>,zskiplist*,,true,,zskiplist*,-1
482782,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zskiplistLevel,,<includes>,zskiplistLevel,,true,,zskiplistLevel,-1
482783,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zskiplistLevel[],,<includes>,zskiplistLevel[],,true,,zskiplistLevel[],-1
482784,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zskiplistNode*,,<includes>,zskiplistNode*,,true,,zskiplistNode*,-1
482785,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zskiplistNode**,,<includes>,zskiplistNode**,,true,,zskiplistNode**,-1
482786,TYPE_DECL,,<includes>:<global>,NAMESPACE_BLOCK,zskiplistNode*[32],,<includes>,zskiplistNode*[32],,true,,zskiplistNode*[32],-1
