13,METHOD,acl.c:<global>,TYPE_DECL,<global>,1,1,acl.c,acl.c:<global>,,false,1,3141,<global>,,,1,
271,METHOD,<empty>,<empty>,<empty>,1,,acl.c,aclSelector:<clinit>,,false,115,,<clinit>,,,7,
282,METHOD,acl.c:<global>,TYPE_DECL,"void ACLResetFirstArgsForCommand(aclSelector *selector, unsigned long id);",6,73,acl.c,ACLResetFirstArgsForCommand,,false,144,144,ACLResetFirstArgsForCommand,,,22,"void ACLResetFirstArgsForCommand (aclSelector*,long unsigned)"
288,METHOD,acl.c:<global>,TYPE_DECL,void ACLResetFirstArgs(aclSelector *selector);,6,45,acl.c,ACLResetFirstArgs,,false,145,145,ACLResetFirstArgs,,,23,void ACLResetFirstArgs (aclSelector*)
293,METHOD,acl.c:<global>,TYPE_DECL,"void ACLAddAllowedFirstArg(aclSelector *selector, unsigned long id, const char *sub);",6,84,acl.c,ACLAddAllowedFirstArg,,false,146,146,ACLAddAllowedFirstArg,,,24,"void ACLAddAllowedFirstArg (aclSelector*,long unsigned,char*)"
300,METHOD,acl.c:<global>,TYPE_DECL,void ACLFreeLogEntry(void *le);,6,30,acl.c,ACLFreeLogEntry,,false,147,147,ACLFreeLogEntry,,,25,void ACLFreeLogEntry (void*)
305,METHOD,acl.c:<global>,TYPE_DECL,"int ACLSetSelector(aclSelector *selector, const char *op, size_t oplen);",5,71,acl.c,ACLSetSelector,,false,148,148,ACLSetSelector,,,26,"int ACLSetSelector (aclSelector*,char*,size_t)"
312,METHOD,acl.c:<global>,TYPE_DECL,"int time_independent_strcmp(char *a, char *b, int len) {
    int diff = 0;
    for (int j = 0; j < len; j++) {
        diff |= (a[j] ^ b[j]);
    }
    return diff; /* If zero strings are the same. */
}",1,1,acl.c,time_independent_strcmp,,false,162,168,time_independent_strcmp,,,27,"int time_independent_strcmp (char*,char*,int)"
346,METHOD,acl.c:<global>,TYPE_DECL,"sds ACLHashPassword(unsigned char *cleartext, size_t len) {
    SHA256_CTX ctx;
    unsigned char hash[SHA256_BLOCK_SIZE];
    char hex[HASH_PASSWORD_LEN];
    char *cset = ""0123456789abcdef"";

    sha256_init(&ctx);
    sha256_update(&ctx,(unsigned char*)cleartext,len);
    sha256_final(&ctx,hash);

    for (int j = 0; j < SHA256_BLOCK_SIZE; j++) {
        hex[j*2] = cset[((hash[j]&0xF0)>>4)];
        hex[j*2+1] = cset[(hash[j]&0xF)];
    }
    return sdsnewlen(hex,HASH_PASSWORD_LEN);
}",1,23,acl.c,ACLHashPassword,,false,172,187,ACLHashPassword,,,28,"sds ACLHashPassword (unsigned char*,size_t)"
425,METHOD,acl.c:<global>,TYPE_DECL,"int ACLCheckPasswordHash(unsigned char *hash, int hashlen) {
    if (hashlen != HASH_PASSWORD_LEN) {
        return C_ERR;
    }

    /* Password hashes can only be characters that represent
     * hexadecimal values, which are numbers and lowercase
     * characters 'a' through 'f'. */
    for(int i = 0; i < HASH_PASSWORD_LEN; i++) {
        char c = hash[i];
        if ((c < 'a' || c > 'f') && (c < '0' || c > '9')) {
            return C_ERR;
        }
    }
    return C_OK;
}",1,19,acl.c,ACLCheckPasswordHash,,false,191,206,ACLCheckPasswordHash,,,29,"int ACLCheckPasswordHash (unsigned char*,int)"
493,METHOD,acl.c:<global>,TYPE_DECL,"int ACLStringHasSpaces(const char *s, size_t len) {
    for (size_t i = 0; i < len; i++) {
        if (isspace(s[i]) || s[i] == 0) return 1;
    }
    return 0;
}",1,1,acl.c,ACLStringHasSpaces,,false,217,222,ACLStringHasSpaces,,,30,"int ACLStringHasSpaces (char*,size_t)"
527,METHOD,acl.c:<global>,TYPE_DECL,"uint64_t ACLGetCommandCategoryFlagByName(const char *name) {
    for (int j = 0; ACLCommandCategories[j].flag != 0; j++) {
        if (!strcasecmp(name,ACLCommandCategories[j].name)) {
            return ACLCommandCategories[j].flag;
        }
    }
    return 0; /* No match. */
}",1,1,acl.c,ACLGetCommandCategoryFlagByName,,false,226,233,ACLGetCommandCategoryFlagByName,,,31,uint64_t ACLGetCommandCategoryFlagByName (char*)
566,METHOD,acl.c:<global>,TYPE_DECL,"int ACLListMatchLoadedUser(void *definition, void *user) {
    sds *user_definition = definition;
    return sdscmp(user_definition[0], user) == 0;
}",1,1,acl.c,ACLListMatchLoadedUser,,false,238,241,ACLListMatchLoadedUser,,,32,"int ACLListMatchLoadedUser (void*,void*)"
584,METHOD,acl.c:<global>,TYPE_DECL,"int ACLListMatchSds(void *a, void *b) {
    return sdscmp(a,b) == 0;
}",1,1,acl.c,ACLListMatchSds,,false,245,247,ACLListMatchSds,,,33,"int ACLListMatchSds (void*,void*)"
596,METHOD,acl.c:<global>,TYPE_DECL,"void ACLListFreeSds(void *item) {
    sdsfree(item);
}",1,1,acl.c,ACLListFreeSds,,false,250,252,ACLListFreeSds,,,34,void ACLListFreeSds (void*)
603,METHOD,acl.c:<global>,TYPE_DECL,"void *ACLListDupSds(void *item) {
    return sdsdup(item);
}",1,1,acl.c,ACLListDupSds,,false,255,257,ACLListDupSds,,,35,void* ACLListDupSds (void*)
615,METHOD,acl.c:<global>,TYPE_DECL,"keyPattern *ACLKeyPatternCreate(sds pattern, int flags) {
    keyPattern *new = (keyPattern *) zmalloc(sizeof(keyPattern));
    new->pattern = pattern;
    new->flags = flags;
    return new;
}",1,1,acl.c,ACLKeyPatternCreate,,false,267,272,ACLKeyPatternCreate,,,38,"keyPattern ACLKeyPatternCreate (sds,int)"
641,METHOD,acl.c:<global>,TYPE_DECL,"void ACLKeyPatternFree(keyPattern *pattern) {
    sdsfree(pattern->pattern);
    zfree(pattern);
}",1,1,acl.c,ACLKeyPatternFree,,false,275,278,ACLKeyPatternFree,,,39,void ACLKeyPatternFree (keyPattern*)
652,METHOD,acl.c:<global>,TYPE_DECL,"int ACLListMatchKeyPattern(void *a, void *b) {
    return sdscmp(((keyPattern *) a)->pattern,((keyPattern *) b)->pattern) == 0;
}",1,1,acl.c,ACLListMatchKeyPattern,,false,282,284,ACLListMatchKeyPattern,,,40,"int ACLListMatchKeyPattern (void*,void*)"
672,METHOD,acl.c:<global>,TYPE_DECL,"void ACLListFreeKeyPattern(void *item) {
    ACLKeyPatternFree(item);
}",1,1,acl.c,ACLListFreeKeyPattern,,false,287,289,ACLListFreeKeyPattern,,,41,void ACLListFreeKeyPattern (void*)
679,METHOD,acl.c:<global>,TYPE_DECL,"void *ACLListDupKeyPattern(void *item) {
    keyPattern *old = (keyPattern *) item;
    return ACLKeyPatternCreate(sdsdup(old->pattern), old->flags);
}",1,1,acl.c,ACLListDupKeyPattern,,false,292,295,ACLListDupKeyPattern,,,42,void* ACLListDupKeyPattern (void*)
699,METHOD,acl.c:<global>,TYPE_DECL,"sds sdsCatPatternString(sds base, keyPattern *pat) {
    if (pat->flags == ACL_ALL_PERMISSION) {
        base = sdscatlen(base,""~"",1);
    } else if (pat->flags == ACL_READ_PERMISSION) {
        base = sdscatlen(base,""%R~"",3);
    } else if (pat->flags == ACL_WRITE_PERMISSION) {
        base = sdscatlen(base,""%W~"",3);
    } else {
        serverPanic(""Invalid key pattern flag detected"");
    }
    return sdscatsds(base, pat->pattern);
}",1,22,acl.c,sdsCatPatternString,,false,299,310,sdsCatPatternString,,,43,"sds sdsCatPatternString (sds,keyPattern*)"
780,METHOD,acl.c:<global>,TYPE_DECL,"aclSelector *ACLCreateSelector(int flags) {
    aclSelector *selector = zmalloc(sizeof(aclSelector));
    selector->flags = flags | server.acl_pubsub_default;
    selector->patterns = listCreate();
    selector->channels = listCreate();
    selector->allowed_firstargs = NULL;
    selector->command_rules = sdsempty();

    listSetMatchMethod(selector->patterns,ACLListMatchKeyPattern);
    listSetFreeMethod(selector->patterns,ACLListFreeKeyPattern);
    listSetDupMethod(selector->patterns,ACLListDupKeyPattern);
    listSetMatchMethod(selector->channels,ACLListMatchSds);
    listSetFreeMethod(selector->channels,ACLListFreeSds);
    listSetDupMethod(selector->channels,ACLListDupSds);
    memset(selector->allowed_commands,0,sizeof(selector->allowed_commands));

    return selector;
}",1,4,acl.c,ACLCreateSelector,,false,314,331,ACLCreateSelector,,,44,aclSelector ACLCreateSelector (int)
909,METHOD,acl.c:<global>,TYPE_DECL,"void ACLFreeSelector(aclSelector *selector) {
    listRelease(selector->patterns);
    listRelease(selector->channels);
    sdsfree(selector->command_rules);
    ACLResetFirstArgs(selector);
    zfree(selector);
}",1,1,acl.c,ACLFreeSelector,,false,334,340,ACLFreeSelector,,,45,void ACLFreeSelector (aclSelector*)
930,METHOD,acl.c:<global>,TYPE_DECL,"aclSelector *ACLCopySelector(aclSelector *src) {
    aclSelector *dst = zmalloc(sizeof(aclSelector));
    dst->flags = src->flags;
    dst->patterns = listDup(src->patterns);
    dst->channels = listDup(src->channels);
    dst->command_rules = sdsdup(src->command_rules);
    memcpy(dst->allowed_commands,src->allowed_commands,
           sizeof(dst->allowed_commands));
    dst->allowed_firstargs = NULL;
    /* Copy the allowed first-args array of array of SDS strings. */
    if (src->allowed_firstargs) {
        for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
            if (!(src->allowed_firstargs[j])) continue;
            for (int i = 0; src->allowed_firstargs[j][i]; i++) {
                ACLAddAllowedFirstArg(dst, j, src->allowed_firstargs[j][i]);
            }
        }
    }
    return dst;
}",1,28,acl.c,ACLCopySelector,,false,343,362,ACLCopySelector,,,46,aclSelector ACLCopySelector (aclSelector*)
1044,METHOD,acl.c:<global>,TYPE_DECL,"void ACLListFreeSelector(void *a) {
    ACLFreeSelector((aclSelector *) a);
}",1,1,acl.c,ACLListFreeSelector,,false,365,367,ACLListFreeSelector,,,47,void ACLListFreeSelector (void*)
1053,METHOD,acl.c:<global>,TYPE_DECL,"void *ACLListDuplicateSelector(void *src) {
    return ACLCopySelector((aclSelector *)src);
}",1,1,acl.c,ACLListDuplicateSelector,,false,370,372,ACLListDuplicateSelector,,,48,void* ACLListDuplicateSelector (void*)
1063,METHOD,acl.c:<global>,TYPE_DECL,"aclSelector *ACLUserGetRootSelector(user *u) {
    serverAssert(listLength(u->selectors));
    aclSelector *s = (aclSelector *) listNodeValue(listFirst(u->selectors));
    serverAssert(s->flags & SELECTOR_FLAG_ROOT);
    return s;
}",1,4,acl.c,ACLUserGetRootSelector,,false,377,382,ACLUserGetRootSelector,,,49,aclSelector ACLUserGetRootSelector (user*)
1122,METHOD,acl.c:<global>,TYPE_DECL,"user *ACLCreateUser(const char *name, size_t namelen) {
    if (raxFind(Users,(unsigned char*)name,namelen) != raxNotFound) return NULL;
    user *u = zmalloc(sizeof(*u));
    u->name = sdsnewlen(name,namelen);
    u->flags = USER_FLAG_DISABLED;
    u->flags |= USER_FLAG_SANITIZE_PAYLOAD;
    u->passwords = listCreate();
    u->acl_string = NULL;
    listSetMatchMethod(u->passwords,ACLListMatchSds);
    listSetFreeMethod(u->passwords,ACLListFreeSds);
    listSetDupMethod(u->passwords,ACLListDupSds);

    u->selectors = listCreate();
    listSetFreeMethod(u->selectors,ACLListFreeSelector);
    listSetDupMethod(u->selectors,ACLListDuplicateSelector);

    /* Add the initial root selector */
    aclSelector *s = ACLCreateSelector(SELECTOR_FLAG_ROOT);
    listAddNodeHead(u->selectors, s);

    raxInsert(Users,(unsigned char*)name,namelen,u,NULL);
    return u;
}",1,15,acl.c,ACLCreateUser,,false,389,411,ACLCreateUser,,,50,"user ACLCreateUser (char*,size_t)"
1276,METHOD,acl.c:<global>,TYPE_DECL,"user *ACLCreateUnlinkedUser(void) {
    char username[64];
    for (int j = 0; ; j++) {
        snprintf(username,sizeof(username),""__fakeuser:%d__"",j);
        user *fakeuser = ACLCreateUser(username,strlen(username));
        if (fakeuser == NULL) continue;
        int retval = raxRemove(Users,(unsigned char*) username,
                               strlen(username),NULL);
        serverAssert(retval != 0);
        return fakeuser;
    }
}",1,8,acl.c,ACLCreateUnlinkedUser,,false,417,428,ACLCreateUnlinkedUser,,,51,user ACLCreateUnlinkedUser (void)
1339,METHOD,acl.c:<global>,TYPE_DECL,"void ACLFreeUser(user *u) {
    sdsfree(u->name);
    if (u->acl_string) {
        decrRefCount(u->acl_string);
        u->acl_string = NULL;
    }
    listRelease(u->passwords);
    listRelease(u->selectors);
    zfree(u);
}",1,1,acl.c,ACLFreeUser,,false,432,441,ACLFreeUser,,,52,void ACLFreeUser (user*)
1372,METHOD,acl.c:<global>,TYPE_DECL,"void ACLFreeUserAndKillClients(user *u) {
    listIter li;
    listNode *ln;
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (c->user == u) {
            /* We'll free the connection asynchronously, so
             * in theory to set a different user is not needed.
             * However if there are bugs in Redis, soon or later
             * this may result in some security hole: it's much
             * more defensive to set the default user and put
             * it in non authenticated mode. */
            c->user = DefaultUser;
            c->authenticated = 0;
            /* We will write replies to this client later, so we can't
             * close it directly even if async. */
            if (c == server.current_client) {
                c->flags |= CLIENT_CLOSE_AFTER_COMMAND;
            } else {
                freeClientAsync(c);
            }
        }
    }
    ACLFreeUser(u);
}",1,20,acl.c,ACLFreeUserAndKillClients,,false,446,471,ACLFreeUserAndKillClients,,,53,void ACLFreeUserAndKillClients (user*)
1442,METHOD,acl.c:<global>,TYPE_DECL,"void ACLCopyUser(user *dst, user *src) {
    listRelease(dst->passwords);
    listRelease(dst->selectors);
    dst->passwords = listDup(src->passwords);
    dst->selectors = listDup(src->selectors);
    dst->flags = src->flags;
    if (dst->acl_string) {
        decrRefCount(dst->acl_string);
    }
    dst->acl_string = src->acl_string;
    if (dst->acl_string) {
        /* if src is NULL, we set it to NULL, if not, need to increment reference count */
        incrRefCount(dst->acl_string);
    }
}",1,1,acl.c,ACLCopyUser,,false,476,490,ACLCopyUser,,,54,"void ACLCopyUser (user*,user*)"
1504,METHOD,acl.c:<global>,TYPE_DECL,"void ACLFreeUsersSet(rax *users) {
    raxFreeWithCallback(users,(void(*)(void*))ACLFreeUserAndKillClients);
}",1,1,acl.c,ACLFreeUsersSet,,false,494,496,ACLFreeUsersSet,,,55,void ACLFreeUsersSet (rax*)
1514,METHOD,acl.c:<global>,TYPE_DECL,"int ACLGetCommandBitCoordinates(uint64_t id, uint64_t *word, uint64_t *bit) {
    if (id >= USER_COMMAND_BITS_COUNT) return C_ERR;
    *word = id / sizeof(uint64_t) / 8;
    *bit = 1ULL << (id % (sizeof(uint64_t) * 8));
    return C_OK;
}",1,14,acl.c,ACLGetCommandBitCoordinates,,false,504,509,ACLGetCommandBitCoordinates,,,56,"int ACLGetCommandBitCoordinates (uint64_t,uint64_t*,uint64_t*)"
1557,METHOD,acl.c:<global>,TYPE_DECL,"int ACLGetSelectorCommandBit(const aclSelector *selector, unsigned long id) {
    uint64_t word, bit;
    if (ACLGetCommandBitCoordinates(id,&word,&bit) == C_ERR) return 0;
    return (selector->allowed_commands[word] & bit) != 0;
}",1,54,acl.c,ACLGetSelectorCommandBit,,false,518,522,ACLGetSelectorCommandBit,,,57,"int ACLGetSelectorCommandBit (aclSelector*,long unsigned)"
1590,METHOD,acl.c:<global>,TYPE_DECL,"int ACLSelectorCanExecuteFutureCommands(aclSelector *selector) {
    return ACLGetSelectorCommandBit(selector,USER_COMMAND_BITS_COUNT-1);
}",1,45,acl.c,ACLSelectorCanExecuteFutureCommands,,false,527,529,ACLSelectorCanExecuteFutureCommands,,,58,int ACLSelectorCanExecuteFutureCommands (aclSelector*)
1603,METHOD,acl.c:<global>,TYPE_DECL,"void ACLSetSelectorCommandBit(aclSelector *selector, unsigned long id, int value) {
    uint64_t word, bit;
    if (ACLGetCommandBitCoordinates(id,&word,&bit) == C_ERR) return;
    if (value) {
        selector->allowed_commands[word] |= bit;
    } else {
        selector->allowed_commands[word] &= ~bit;
        selector->flags &= ~SELECTOR_FLAG_ALLCOMMANDS;
    }
}",1,54,acl.c,ACLSetSelectorCommandBit,,false,536,545,ACLSetSelectorCommandBit,,,59,"void ACLSetSelectorCommandBit (aclSelector*,long unsigned,int)"
1656,METHOD,acl.c:<global>,TYPE_DECL,"void ACLSelectorRemoveCommandRule(aclSelector *selector, sds new_rule) {
    size_t new_len = sdslen(new_rule);
    char *existing_rule = selector->command_rules;

    /* Loop over the existing rules, trying to find a rule that ""matches""
     * the new rule. If we find a match, then remove the command from the string by
     * copying the later rules over it. */
    while(existing_rule[0]) {
        /* The first character of the rule is +/-, which we don't need to compare. */
        char *copy_position = existing_rule;
        existing_rule += 1;

        /* Assume a trailing space after a command is part of the command, like '+get ', so trim it
         * as well if the command is removed. */
        char *rule_end = strchr(existing_rule, ' ');
        if (!rule_end) {
            /* This is the last rule, so it it to the end of the string. */
            rule_end = existing_rule + strlen(existing_rule);

            /* This approach can leave a trailing space if the last rule is ...",1,45,acl.c,ACLSelectorRemoveCommandRule,,false,550,590,ACLSelectorRemoveCommandRule,,,60,"void ACLSelectorRemoveCommandRule (aclSelector*,sds)"
1774,METHOD,acl.c:<global>,TYPE_DECL,"void ACLUpdateCommandRules(aclSelector *selector, const char *rule, int allow) {
    sds new_rule = sdsnew(rule);
    sdstolower(new_rule);

    ACLSelectorRemoveCommandRule(selector, new_rule);
    if (sdslen(selector->command_rules)) selector->command_rules = sdscat(selector->command_rules, "" "");
    selector->command_rules = sdscatfmt(selector->command_rules, allow ? ""+%S"" : ""-%S"", new_rule);
    sdsfree(new_rule);
}",1,1,acl.c,ACLUpdateCommandRules,,false,594,602,ACLUpdateCommandRules,,,61,"void ACLUpdateCommandRules (aclSelector*,char*,int)"
1821,METHOD,acl.c:<global>,TYPE_DECL,"void ACLChangeSelectorPerm(aclSelector *selector, struct redisCommand *cmd, int allow) {
    unsigned long id = cmd->id;
    ACLSetSelectorCommandBit(selector,id,allow);
    ACLResetFirstArgsForCommand(selector,id);
    if (cmd->subcommands_dict) {
        dictEntry *de;
        dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);
        while((de = dictNext(di)) != NULL) {
            struct redisCommand *sub = (struct redisCommand *)dictGetVal(de);
            ACLSetSelectorCommandBit(selector,sub->id,allow);
        }
        dictReleaseIterator(di);
    }
}",1,1,acl.c,ACLChangeSelectorPerm,,false,606,619,ACLChangeSelectorPerm,,,62,"void ACLChangeSelectorPerm (aclSelector*,redisCommand*,int)"
1877,METHOD,acl.c:<global>,TYPE_DECL,"void ACLSetSelectorCommandBitsForCategory(dict *commands, aclSelector *selector, uint64_t cflag, int value) {
    dictIterator *di = dictGetIterator(commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->acl_categories & cflag) {
            ACLChangeSelectorPerm(selector,cmd,value);
        }
        if (cmd->subcommands_dict) {
            ACLSetSelectorCommandBitsForCategory(cmd->subcommands_dict, selector, cflag, value);
        }
    }
    dictReleaseIterator(di);
}",1,1,acl.c,ACLSetSelectorCommandBitsForCategory,,false,627,640,ACLSetSelectorCommandBitsForCategory,,,63,"void ACLSetSelectorCommandBitsForCategory (dict*,aclSelector*,uint64_t,int)"
1929,METHOD,acl.c:<global>,TYPE_DECL,"void ACLRecomputeCommandBitsFromCommandRulesAllUsers(void) {
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        listIter li;
        listNode *ln;
        listRewind(u->selectors,&li);
        while((ln = listNext(&li))) {
            aclSelector *selector = (aclSelector *) listNodeValue(ln);
            int argc = 0;
            sds *argv = sdssplitargs(selector->command_rules, &argc);
            serverAssert(argv != NULL);
            /* Checking selector's permissions for all commands to start with a clean state. */
            if (ACLSelectorCanExecuteFutureCommands(selector)) {
                int res = ACLSetSelector(selector,""+@all"",-1);
                serverAssert(res == C_OK);
            } else {
                int res = ACLSetSelector(selector,""-@all"",-1);
                serverAssert(res == C_OK);
            }

            /* Apply all of the commands and categories to this selector. ...",1,52,acl.c,ACLRecomputeCommandBitsFromCommandRulesAllUsers,,false,645,678,ACLRecomputeCommandBitsFromCommandRulesAllUsers,,,64,void ACLRecomputeCommandBitsFromCommandRulesAllUsers (void)
2111,METHOD,acl.c:<global>,TYPE_DECL,"int ACLSetSelectorCategory(aclSelector *selector, const char *category, int allow) {
    uint64_t cflag = ACLGetCommandCategoryFlagByName(category + 1);
    if (!cflag) return C_ERR;

    ACLUpdateCommandRules(selector, category, allow);

    /* Set the actual command bits on the selector. */
    ACLSetSelectorCommandBitsForCategory(server.orig_commands, selector, cflag, allow);
    return C_OK;
}",1,23,acl.c,ACLSetSelectorCategory,,false,680,689,ACLSetSelectorCategory,,,65,"int ACLSetSelectorCategory (aclSelector*,char*,int)"
2149,METHOD,acl.c:<global>,TYPE_DECL,"void ACLCountCategoryBitsForCommands(dict *commands, aclSelector *selector, unsigned long *on, unsigned long *off, uint64_t cflag) {
    dictIterator *di = dictGetIterator(commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->acl_categories & cflag) {
            if (ACLGetSelectorCommandBit(selector,cmd->id))
                (*on)++;
            else
                (*off)++;
        }
        if (cmd->subcommands_dict) {
            ACLCountCategoryBitsForCommands(cmd->subcommands_dict, selector, on, off, cflag);
        }
    }
    dictReleaseIterator(di);
}",1,1,acl.c,ACLCountCategoryBitsForCommands,,false,691,707,ACLCountCategoryBitsForCommands,,,66,"void ACLCountCategoryBitsForCommands (dict*,aclSelector*,long unsigned*,long unsigned*,uint64_t)"
2214,METHOD,acl.c:<global>,TYPE_DECL,"int ACLCountCategoryBitsForSelector(aclSelector *selector, unsigned long *on, unsigned long *off,
                                const char *category)
{
    uint64_t cflag = ACLGetCommandCategoryFlagByName(category);
    if (!cflag) return C_ERR;

    *on = *off = 0;
    ACLCountCategoryBitsForCommands(server.orig_commands, selector, on, off, cflag);
    return C_OK;
}",1,23,acl.c,ACLCountCategoryBitsForSelector,,false,713,722,ACLCountCategoryBitsForSelector,,,67,"int ACLCountCategoryBitsForSelector (aclSelector*,long unsigned*,long unsigned*,char*)"
2255,METHOD,acl.c:<global>,TYPE_DECL,"sds ACLDescribeSelectorCommandRules(aclSelector *selector) {
    sds rules = sdsempty();

    /* We use this fake selector as a ""sanity"" check to make sure the rules
     * we generate have the same bitmap as those on the current selector. */
    aclSelector *fake_selector = ACLCreateSelector(0);

    /* Here we want to understand if we should start with +@all or -@all.
     * Note that when starting with +@all and subtracting, the user
     * will be able to execute future commands, while -@all and adding will just
     * allow the user the run the selected commands and/or categories.
     * How do we test for that? We use the trick of a reserved command ID bit
     * that is set only by +@all (and its alias ""allcommands""). */
    if (ACLSelectorCanExecuteFutureCommands(selector)) {
        rules = sdscat(rules,""+@all "");
        ACLSetSelector(fake_selector,""+@all"",-1);
    } else {
        rules = sdscat(rules,""-@all "");
        ACLSetSelector(fake_selector,""-@all"",-1);
    }

  ...",1,4,acl.c,ACLDescribeSelectorCommandRules,,false,731,784,ACLDescribeSelectorCommandRules,,,68,sds ACLDescribeSelectorCommandRules (aclSelector*)
2430,METHOD,acl.c:<global>,TYPE_DECL,"sds ACLDescribeSelector(aclSelector *selector) {
    listIter li;
    listNode *ln;
    sds res = sdsempty();
    /* Key patterns. */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) {
        res = sdscatlen(res,""~* "",3);
    } else {
        listRewind(selector->patterns,&li);
        while((ln = listNext(&li))) {
            keyPattern *thispat = (keyPattern *)listNodeValue(ln);
            res = sdsCatPatternString(res, thispat);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Pub/sub channel patterns. */
    if (selector->flags & SELECTOR_FLAG_ALLCHANNELS) {
        res = sdscatlen(res,""&* "",3);
    } else {
        res = sdscatlen(res,""resetchannels "",14);
        listRewind(selector->channels,&li);
        while((ln = listNext(&li))) {
            sds thispat = listNodeValue(ln);
            res = sdscatlen(res,""&"",1);
            res = sdscatsds(res,thispat);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Command rules. */
    sds rules = ACL...",1,26,acl.c,ACLDescribeSelector,,false,786,821,ACLDescribeSelector,,,69,sds ACLDescribeSelector (aclSelector*)
2573,METHOD,acl.c:<global>,TYPE_DECL,"robj *ACLDescribeUser(user *u) {
    if (u->acl_string) {
        incrRefCount(u->acl_string);
        return u->acl_string;
    }

    sds res = sdsempty();

    /* Flags. */
    for (int j = 0; ACLUserFlags[j].flag; j++) {
        if (u->flags & ACLUserFlags[j].flag) {
            res = sdscat(res,ACLUserFlags[j].name);
            res = sdscatlen(res,"" "",1);
        }
    }

    /* Passwords. */
    listIter li;
    listNode *ln;
    listRewind(u->passwords,&li);
    while((ln = listNext(&li))) {
        sds thispass = listNodeValue(ln);
        res = sdscatlen(res,""#"",1);
        res = sdscatsds(res,thispass);
        res = sdscatlen(res,"" "",1);
    }

    /* Selectors (Commands and keys) */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *selector = (aclSelector *) listNodeValue(ln);
        sds default_perm = ACLDescribeSelector(selector);
        if (selector->flags & SELECTOR_FLAG_ROOT) {
            res = sdscatfmt(res, ""%s"", default_...",1,23,acl.c,ACLDescribeUser,,false,829,874,ACLDescribeUser,,,70,robj ACLDescribeUser (user*)
2749,METHOD,acl.c:<global>,TYPE_DECL,"struct redisCommand *ACLLookupCommand(const char *name) {
    struct redisCommand *cmd;
    sds sdsname = sdsnew(name);
    cmd = lookupCommandBySdsLogic(server.orig_commands,sdsname);
    sdsfree(sdsname);
    return cmd;
}",1,1,acl.c,ACLLookupCommand,,false,879,885,ACLLookupCommand,,,71,struct redisCommand ACLLookupCommand (char*)
2771,METHOD,acl.c:<global>,TYPE_DECL,"void ACLResetFirstArgsForCommand(aclSelector *selector, unsigned long id) {
    if (selector->allowed_firstargs && selector->allowed_firstargs[id]) {
        for (int i = 0; selector->allowed_firstargs[id][i]; i++)
            sdsfree(selector->allowed_firstargs[id][i]);
        zfree(selector->allowed_firstargs[id]);
        selector->allowed_firstargs[id] = NULL;
    }
}",1,1,acl.c,ACLResetFirstArgsForCommand,,false,889,896,ACLResetFirstArgsForCommand,,,72,"void ACLResetFirstArgsForCommand (aclSelector*,long unsigned)"
2824,METHOD,acl.c:<global>,TYPE_DECL,"void ACLResetFirstArgs(aclSelector *selector) {
    if (selector->allowed_firstargs == NULL) return;
    for (int j = 0; j < USER_COMMAND_BITS_COUNT; j++) {
        if (selector->allowed_firstargs[j]) {
            for (int i = 0; selector->allowed_firstargs[j][i]; i++)
                sdsfree(selector->allowed_firstargs[j][i]);
            zfree(selector->allowed_firstargs[j]);
        }
    }
    zfree(selector->allowed_firstargs);
    selector->allowed_firstargs = NULL;
}",1,24,acl.c,ACLResetFirstArgs,,false,901,912,ACLResetFirstArgs,,,73,void ACLResetFirstArgs (aclSelector*)
2896,METHOD,acl.c:<global>,TYPE_DECL,"void ACLAddAllowedFirstArg(aclSelector *selector, unsigned long id, const char *sub) {
    /* If this is the first first-arg to be configured for
     * this user, we have to allocate the first-args array. */
    if (selector->allowed_firstargs == NULL) {
        selector->allowed_firstargs = zcalloc(USER_COMMAND_BITS_COUNT * sizeof(sds*));
    }

    /* We also need to enlarge the allocation pointing to the
     * null terminated SDS array, to make space for this one.
     * To start check the current size, and while we are here
     * make sure the first-arg is not already specified inside. */
    long items = 0;
    if (selector->allowed_firstargs[id]) {
        while(selector->allowed_firstargs[id][items]) {
            /* If it's already here do not add it again. */
            if (!strcasecmp(selector->allowed_firstargs[id][items],sub))
                return;
            items++;
        }
    }

    /* Now we can make space for the new item (and the null term). */
    items ...",1,46,acl.c,ACLAddAllowedFirstArg,,false,916,942,ACLAddAllowedFirstArg,,,74,"void ACLAddAllowedFirstArg (aclSelector*,long unsigned,char*)"
2998,METHOD,acl.c:<global>,TYPE_DECL,"aclSelector *aclCreateSelectorFromOpSet(const char *opset, size_t opsetlen) {
    serverAssert(opset[0] == '(' && opset[opsetlen - 1] == ')');
    aclSelector *s = ACLCreateSelector(0);

    int argc = 0;
    sds trimmed = sdsnewlen(opset + 1, opsetlen - 2);
    sds *argv = sdssplitargs(trimmed, &argc);
    for (int i = 0; i < argc; i++) {
        if (ACLSetSelector(s, argv[i], sdslen(argv[i])) == C_ERR) {
            ACLFreeSelector(s);
            s = NULL;
            goto cleanup;
        }
    }

cleanup:
    sdsfreesplitres(argv, argc);
    sdsfree(trimmed);
    return s;
}",1,4,acl.c,aclCreateSelectorFromOpSet,,false,950,969,aclCreateSelectorFromOpSet,,,75,"aclSelector aclCreateSelectorFromOpSet (char*,size_t)"
3098,METHOD,acl.c:<global>,TYPE_DECL,"int ACLSetSelector(aclSelector *selector, const char* op, size_t oplen) {
    if (!strcasecmp(op,""allkeys"") ||
               !strcasecmp(op,""~*""))
    {
        selector->flags |= SELECTOR_FLAG_ALLKEYS;
        listEmpty(selector->patterns);
    } else if (!strcasecmp(op,""resetkeys"")) {
        selector->flags &= ~SELECTOR_FLAG_ALLKEYS;
        listEmpty(selector->patterns);
    } else if (!strcasecmp(op,""allchannels"") ||
               !strcasecmp(op,""&*""))
    {
        selector->flags |= SELECTOR_FLAG_ALLCHANNELS;
        listEmpty(selector->channels);
    } else if (!strcasecmp(op,""resetchannels"")) {
        selector->flags &= ~SELECTOR_FLAG_ALLCHANNELS;
        listEmpty(selector->channels);
    } else if (!strcasecmp(op,""allcommands"") ||
               !strcasecmp(op,""+@all""))
    {
        memset(selector->allowed_commands,255,sizeof(selector->allowed_commands));
        selector->flags |= SELECTOR_FLAG_ALLCOMMANDS;
        sdsclear(selector->command_rules);
        ACLReset...",1,27,acl.c,ACLSetSelector,,false,1008,1178,ACLSetSelector,,,76,"int ACLSetSelector (aclSelector*,char*,size_t)"
3880,METHOD,acl.c:<global>,TYPE_DECL,"int ACLSetUser(user *u, const char *op, ssize_t oplen) {
    /* as we are changing the ACL, the old generated string is now invalid */
    if (u->acl_string) {
        decrRefCount(u->acl_string);
        u->acl_string = NULL;
    }

    if (oplen == -1) oplen = strlen(op);
    if (oplen == 0) return C_OK; /* Empty string is a no-operation. */
    if (!strcasecmp(op,""on"")) {
        u->flags |= USER_FLAG_ENABLED;
        u->flags &= ~USER_FLAG_DISABLED;
    } else if (!strcasecmp(op,""off"")) {
        u->flags |= USER_FLAG_DISABLED;
        u->flags &= ~USER_FLAG_ENABLED;
    } else if (!strcasecmp(op,""skip-sanitize-payload"")) {
        u->flags |= USER_FLAG_SANITIZE_PAYLOAD_SKIP;
        u->flags &= ~USER_FLAG_SANITIZE_PAYLOAD;
    } else if (!strcasecmp(op,""sanitize-payload"")) {
        u->flags &= ~USER_FLAG_SANITIZE_PAYLOAD_SKIP;
        u->flags |= USER_FLAG_SANITIZE_PAYLOAD;
    } else if (!strcasecmp(op,""nopass"")) {
        u->flags |= USER_FLAG_NOPASS;
        listEmpty(u->pa...",1,27,acl.c,ACLSetUser,,false,1250,1350,ACLSetUser,,,77,"int ACLSetUser (user*,char*,ssize_t)"
4565,METHOD,acl.c:<global>,TYPE_DECL,"const char *ACLSetUserStringError(void) {
    const char *errmsg = ""Wrong format"";
    if (errno == ENOENT)
        errmsg = ""Unknown command or category name in ACL"";
    else if (errno == EINVAL)
        errmsg = ""Syntax error"";
    else if (errno == EEXIST)
        errmsg = ""Adding a pattern after the * pattern (or the ""
                 ""'allkeys' flag) is not valid and does not have any ""
                 ""effect. Try 'resetkeys' to start with an empty ""
                 ""list of patterns"";
    else if (errno == EISDIR)
        errmsg = ""Adding a pattern after the * pattern (or the ""
                 ""'allchannels' flag) is not valid and does not have any ""
                 ""effect. Try 'resetchannels' to start with an empty ""
                 ""list of channels"";
    else if (errno == ENODEV)
        errmsg = ""The password you are trying to remove from the user does ""
                 ""not exist"";
    else if (errno == EBADMSG)
        errmsg = ""The password hash must be exactl...",1,1,acl.c,ACLSetUserStringError,,false,1354,1382,ACLSetUserStringError,,,78,const char* ACLSetUserStringError (void)
4654,METHOD,acl.c:<global>,TYPE_DECL,"user *ACLCreateDefaultUser(void) {
    user *new = ACLCreateUser(""default"",7);
    ACLSetUser(new,""+@all"",-1);
    ACLSetUser(new,""~*"",-1);
    ACLSetUser(new,""&*"",-1);
    ACLSetUser(new,""on"",-1);
    ACLSetUser(new,""nopass"",-1);
    return new;
}",1,1,acl.c,ACLCreateDefaultUser,,false,1385,1393,ACLCreateDefaultUser,,,79,user ACLCreateDefaultUser (void)
4692,METHOD,acl.c:<global>,TYPE_DECL,"void ACLInit(void) {
    Users = raxNew();
    UsersToLoad = listCreate();
    listSetMatchMethod(UsersToLoad, ACLListMatchLoadedUser);
    ACLLog = listCreate();
    DefaultUser = ACLCreateDefaultUser();
}",1,4,acl.c,ACLInit,,false,1396,1402,ACLInit,,,80,void ACLInit (void)
4718,METHOD,acl.c:<global>,TYPE_DECL,"int ACLCheckUserCredentials(robj *username, robj *password) {
    user *u = ACLGetUserByName(username->ptr,sdslen(username->ptr));
    if (u == NULL) {
        errno = ENOENT;
        return C_ERR;
    }

    /* Disabled users can't login. */
    if (u->flags & USER_FLAG_DISABLED) {
        errno = EINVAL;
        return C_ERR;
    }

    /* If the user is configured to don't require any password, we
     * are already fine here. */
    if (u->flags & USER_FLAG_NOPASS) return C_OK;

    /* Check all the user passwords for at least one to match. */
    listIter li;
    listNode *ln;
    listRewind(u->passwords,&li);
    sds hashed = ACLHashPassword(password->ptr,sdslen(password->ptr));
    while((ln = listNext(&li))) {
        sds thispass = listNodeValue(ln);
        if (!time_independent_strcmp(hashed, thispass, HASH_PASSWORD_LEN)) {
            sdsfree(hashed);
            return C_OK;
        }
    }
    sdsfree(hashed);

    /* If we reached this point, no password matched. */
 ...",1,15,acl.c,ACLCheckUserCredentials,,false,1410,1444,ACLCheckUserCredentials,,,81,"int ACLCheckUserCredentials (robj*,robj*)"
4844,METHOD,acl.c:<global>,TYPE_DECL,"void addAuthErrReply(client *c, robj *err) {
    if (clientHasPendingReplies(c)) return;
    if (!err) {
        addReplyError(c, ""-WRONGPASS invalid username-password pair or user is disabled."");
        return;
    }
    addReplyError(c, err->ptr);
}",1,1,acl.c,addAuthErrReply,,false,1448,1455,addAuthErrReply,,,82,"void addAuthErrReply (client*,robj*)"
4868,METHOD,acl.c:<global>,TYPE_DECL,"int checkPasswordBasedAuth(client *c, robj *username, robj *password) {
    if (ACLCheckUserCredentials(username,password) == C_OK) {
        c->authenticated = 1;
        c->user = ACLGetUserByName(username->ptr,sdslen(username->ptr));
        moduleNotifyUserChanged(c);
        return AUTH_OK;
    } else {
        addACLLogEntry(c,ACL_DENIED_AUTH,(c->flags & CLIENT_MULTI) ? ACL_LOG_CTX_MULTI : ACL_LOG_CTX_TOPLEVEL,0,username->ptr,NULL);
        return AUTH_ERR;
    }
}",1,54,acl.c,checkPasswordBasedAuth,,false,1462,1472,checkPasswordBasedAuth,,,83,"int checkPasswordBasedAuth (client*,robj*,robj*)"
4935,METHOD,acl.c:<global>,TYPE_DECL,"int ACLAuthenticateUser(client *c, robj *username, robj *password, robj **err) {
    int result = checkModuleAuthentication(c, username, password, err);
    /* If authentication was not handled by any Module, attempt normal password based auth. */
    if (result == AUTH_NOT_HANDLED) {
        result = checkPasswordBasedAuth(c, username, password);
    }
    return result;
}",1,1,acl.c,ACLAuthenticateUser,,false,1481,1488,ACLAuthenticateUser,,,84,"int ACLAuthenticateUser (client*,robj*,robj*,robj**)"
4964,METHOD,acl.c:<global>,TYPE_DECL,"unsigned long ACLGetCommandID(sds cmdname) {
    sds lowername = sdsdup(cmdname);
    sdstolower(lowername);
    if (commandId == NULL) commandId = raxNew();
    void *id = raxFind(commandId,(unsigned char*)lowername,sdslen(lowername));
    if (id != raxNotFound) {
        sdsfree(lowername);
        return (unsigned long)id;
    }
    raxInsert(commandId,(unsigned char*)lowername,strlen(lowername),
              (void*)nextid,NULL);
    sdsfree(lowername);
    unsigned long thisid = nextid;
    nextid++;

    /* We never assign the last bit in the user commands bitmap structure,
     * this way we can later check if this bit is set, understanding if the
     * current ACL for the user was created starting with a +@all to add all
     * the possible commands and just subtracting other single commands or
     * categories, or if, instead, the ACL was created just adding commands
     * and command categories from scratch, not allowing future commands by
     * default (loaded via mod...",1,18,acl.c,ACLGetCommandID,,false,1499,1524,ACLGetCommandID,,,85,unsigned long ACLGetCommandID (sds)
5037,METHOD,acl.c:<global>,TYPE_DECL,"void ACLClearCommandID(void) {
    if (commandId) raxFree(commandId);
    commandId = NULL;
    nextid = 0;
}",1,1,acl.c,ACLClearCommandID,,false,1527,1531,ACLClearCommandID,,,86,void ACLClearCommandID (void)
5053,METHOD,acl.c:<global>,TYPE_DECL,"user *ACLGetUserByName(const char *name, size_t namelen) {
    void *myuser = raxFind(Users,(unsigned char*)name,namelen);
    if (myuser == raxNotFound) return NULL;
    return myuser;
}",1,1,acl.c,ACLGetUserByName,,false,1534,1538,ACLGetUserByName,,,87,"user ACLGetUserByName (char*,size_t)"
5077,METHOD,acl.c:<global>,TYPE_DECL,"static int ACLSelectorCheckKey(aclSelector *selector, const char *key, int keylen, int keyspec_flags) {
    /* The selector can access any key */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) return ACL_OK;

    listIter li;
    listNode *ln;
    listRewind(selector->patterns,&li);

    int key_flags = 0;
    if (keyspec_flags & CMD_KEY_ACCESS) key_flags |= ACL_READ_PERMISSION;
    if (keyspec_flags & CMD_KEY_INSERT) key_flags |= ACL_WRITE_PERMISSION;
    if (keyspec_flags & CMD_KEY_DELETE) key_flags |= ACL_WRITE_PERMISSION;
    if (keyspec_flags & CMD_KEY_UPDATE) key_flags |= ACL_WRITE_PERMISSION;

    /* Test this key against every pattern. */
    while((ln = listNext(&li))) {
        keyPattern *pattern = listNodeValue(ln);
        if ((pattern->flags & key_flags) != key_flags)
            continue;
        size_t plen = sdslen(pattern->pattern);
        if (stringmatchlen(pattern->pattern,plen,key,keylen,0))
            return ACL_OK;
    }
    return ACL_DENIED_KEY;
}",1,26,acl.c,ACLSelectorCheckKey,,false,1548,1572,ACLSelectorCheckKey,,,88,"int ACLSelectorCheckKey (aclSelector*,char*,int,int)"
5227,METHOD,acl.c:<global>,TYPE_DECL,"static int ACLSelectorHasUnrestrictedKeyAccess(aclSelector *selector, int flags) {
    /* The selector can access any key */
    if (selector->flags & SELECTOR_FLAG_ALLKEYS) return 1;

    listIter li;
    listNode *ln;
    listRewind(selector->patterns,&li);

    int access_flags = 0;
    if (flags & CMD_KEY_ACCESS) access_flags |= ACL_READ_PERMISSION;
    if (flags & CMD_KEY_INSERT) access_flags |= ACL_WRITE_PERMISSION;
    if (flags & CMD_KEY_DELETE) access_flags |= ACL_WRITE_PERMISSION;
    if (flags & CMD_KEY_UPDATE) access_flags |= ACL_WRITE_PERMISSION;

    /* Test this key against every pattern. */
    while((ln = listNext(&li))) {
        keyPattern *pattern = listNodeValue(ln);
        if ((pattern->flags & access_flags) != access_flags)
            continue;
        if (!strcmp(pattern->pattern,""*"")) {
           return 1;
       }
    }
    return 0;
}",1,26,acl.c,ACLSelectorHasUnrestrictedKeyAccess,,false,1579,1603,ACLSelectorHasUnrestrictedKeyAccess,,,89,"int ACLSelectorHasUnrestrictedKeyAccess (aclSelector*,int)"
5360,METHOD,acl.c:<global>,TYPE_DECL,"static int ACLCheckChannelAgainstList(list *reference, const char *channel, int channellen, int is_pattern) {
    listIter li;
    listNode *ln;

    listRewind(reference, &li);
    while((ln = listNext(&li))) {
        sds pattern = listNodeValue(ln);
        size_t plen = sdslen(pattern);
        /* Channel patterns are matched literally against the channels in
         * the list. Regular channels perform pattern matching. */
        if ((is_pattern && !strcmp(pattern,channel)) || 
            (!is_pattern && stringmatchlen(pattern,plen,channel,channellen,0)))
        {
            return ACL_OK;
        }
    }
    return ACL_DENIED_CHANNEL;
}",1,22,acl.c,ACLCheckChannelAgainstList,,false,1613,1630,ACLCheckChannelAgainstList,,,90,"int ACLCheckChannelAgainstList (list*,char*,int,int)"
5425,METHOD,acl.c:<global>,TYPE_DECL,"void initACLKeyResultCache(aclKeyResultCache *cache) {
    cache->keys_init = 0;
}",1,1,acl.c,initACLKeyResultCache,,false,1639,1641,initACLKeyResultCache,,,93,void initACLKeyResultCache (aclKeyResultCache*)
5435,METHOD,acl.c:<global>,TYPE_DECL,"void cleanupACLKeyResultCache(aclKeyResultCache *cache) {
    if (cache->keys_init) getKeysFreeResult(&(cache->keys));
}",1,1,acl.c,cleanupACLKeyResultCache,,false,1643,1645,cleanupACLKeyResultCache,,,94,void cleanupACLKeyResultCache (aclKeyResultCache*)
5450,METHOD,acl.c:<global>,TYPE_DECL,"static int ACLSelectorCheckCmd(aclSelector *selector, struct redisCommand *cmd, robj **argv, int argc, int *keyidxptr, aclKeyResultCache *cache) {
    uint64_t id = cmd->id;
    int ret;
    if (!(selector->flags & SELECTOR_FLAG_ALLCOMMANDS) && !(cmd->flags & CMD_NO_AUTH)) {
        /* If the bit is not set we have to check further, in case the
         * command is allowed just with that specific first argument. */
        if (ACLGetSelectorCommandBit(selector,id) == 0) {
            /* Check if the first argument matches. */
            if (argc < 2 ||
                selector->allowed_firstargs == NULL ||
                selector->allowed_firstargs[id] == NULL)
            {
                return ACL_DENIED_CMD;
            }

            long subid = 0;
            while (1) {
                if (selector->allowed_firstargs[id][subid] == NULL)
                    return ACL_DENIED_CMD;
                int idx = cmd->parent ? 2 : 1;
                if (!strcasecmp(argv[idx]->ptr...",1,28,acl.c,ACLSelectorCheckCmd,,false,1655,1723,ACLSelectorCheckCmd,,,95,"int ACLSelectorCheckCmd (aclSelector*,redisCommand*,robj**,int,int*,aclKeyResultCache*)"
5845,METHOD,acl.c:<global>,TYPE_DECL,"int ACLUserCheckKeyPerm(user *u, const char *key, int keylen, int flags) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* Check all of the selectors */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        if (ACLSelectorCheckKey(s, key, keylen, flags) == ACL_OK) {
            return ACL_OK;
        }
    }
    return ACL_DENIED_KEY;
}",1,26,acl.c,ACLUserCheckKeyPerm,,false,1731,1747,ACLUserCheckKeyPerm,,,96,"int ACLUserCheckKeyPerm (user*,char*,int,int)"
5907,METHOD,acl.c:<global>,TYPE_DECL,"int ACLUserCheckCmdWithUnrestrictedKeyAccess(user *u, struct redisCommand *cmd, robj **argv, int argc, int flags) {
    listIter li;
    listNode *ln;
    int local_idxptr;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return 1;

    /* For multiple selectors, we cache the key result in between selector
     * calls to prevent duplicate lookups. */
    aclKeyResultCache cache;
    initACLKeyResultCache(&cache);

    /* Check each selector sequentially */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        int acl_retval = ACLSelectorCheckCmd(s, cmd, argv, argc, &local_idxptr, &cache);
        if (acl_retval == ACL_OK && ACLSelectorHasUnrestrictedKeyAccess(s, flags)) {
            cleanupACLKeyResultCache(&cache);
            return 1;
        }
    }
    cleanupACLKeyResultCache(&cache);
    return 0;
}",1,41,acl.c,ACLUserCheckCmdWithUnrestrictedKeyAccess,,false,1755,1780,ACLUserCheckCmdWithUnrestrictedKeyAccess,,,97,"int ACLUserCheckCmdWithUnrestrictedKeyAccess (user*,redisCommand*,robj**,int,int)"
5987,METHOD,acl.c:<global>,TYPE_DECL,"int ACLUserCheckChannelPerm(user *u, sds channel, int is_pattern) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* Check all of the selectors */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        /* The selector can run any keys */
        if (s->flags & SELECTOR_FLAG_ALLCHANNELS) return ACL_OK;

        /* Otherwise, loop over the selectors list and check each channel */
        if (ACLCheckChannelAgainstList(s->channels, channel, sdslen(channel), is_pattern) == ACL_OK) {
            return ACL_OK;
        }
    }
    return ACL_DENIED_CHANNEL;
}",1,26,acl.c,ACLUserCheckChannelPerm,,false,1787,1807,ACLUserCheckChannelPerm,,,98,"int ACLUserCheckChannelPerm (user*,sds,int)"
6066,METHOD,acl.c:<global>,TYPE_DECL,"int ACLCheckAllUserCommandPerm(user *u, struct redisCommand *cmd, robj **argv, int argc, int *idxptr) {
    listIter li;
    listNode *ln;

    /* If there is no associated user, the connection can run anything. */
    if (u == NULL) return ACL_OK;

    /* We have to pick a single error to log, the logic for picking is as follows:
     * 1) If no selector can execute the command, return the command.
     * 2) Return the last key or channel that no selector could match. */
    int relevant_error = ACL_DENIED_CMD;
    int local_idxptr = 0, last_idx = 0;

    /* For multiple selectors, we cache the key result in between selector
     * calls to prevent duplicate lookups. */
    aclKeyResultCache cache;
    initACLKeyResultCache(&cache);

    /* Check each selector sequentially */
    listRewind(u->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        int acl_retval = ACLSelectorCheckCmd(s, cmd, argv, argc, &local_idxptr, &...",1,26,acl.c,ACLCheckAllUserCommandPerm,,false,1814,1852,ACLCheckAllUserCommandPerm,,,99,"int ACLCheckAllUserCommandPerm (user*,redisCommand*,robj**,int,int*)"
6182,METHOD,acl.c:<global>,TYPE_DECL,"int ACLCheckAllPerm(client *c, int *idxptr) {
    return ACLCheckAllUserCommandPerm(c->user, c->cmd, c->argv, c->argc, idxptr);
}",1,1,acl.c,ACLCheckAllPerm,,false,1855,1857,ACLCheckAllPerm,,,100,"int ACLCheckAllPerm (client*,int*)"
6203,METHOD,acl.c:<global>,TYPE_DECL,"void ACLKillPubsubClientsIfNeeded(user *new, user *original) {
    listIter li, lpi;
    listNode *ln, *lpn;
    robj *o;
    int kill = 0;
    
    /* First optimization is we check if any selector has all channel
     * permissions. */
    listRewind(new->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        if (s->flags & SELECTOR_FLAG_ALLCHANNELS) return;
    }

    /* Second optimization is to check if the new list of channels
     * is a strict superset of the original. This is done by
     * created an ""upcoming"" list of all channels that are in
     * the new user and checking each of the existing channels
     * against it.  */
    list *upcoming = listCreate();
    listRewind(new->selectors,&li);
    while((ln = listNext(&li))) {
        aclSelector *s = (aclSelector *) listNodeValue(ln);
        listRewind(s->channels, &lpi);
        while((lpn = listNext(&lpi))) {
            listAddNodeTail(upcoming, listNo...",1,41,acl.c,ACLKillPubsubClientsIfNeeded,,false,1861,1965,ACLKillPubsubClientsIfNeeded,,,101,"void ACLKillPubsubClientsIfNeeded (user*,user*)"
6571,METHOD,acl.c:<global>,TYPE_DECL,"sds *ACLMergeSelectorArguments(sds *argv, int argc, int *merged_argc, int *invalid_idx) {
    *merged_argc = 0;
    int open_bracket_start = -1;

    sds *acl_args = (sds *) zmalloc(sizeof(sds) * argc);

    sds selector = NULL;
    for (int j = 0; j < argc; j++) {
        char *op = argv[j];

        if (op[0] == '(' && op[sdslen(op) - 1] != ')') {
            selector = sdsdup(argv[j]);
            open_bracket_start = j;
            continue;
        }

        if (open_bracket_start != -1) {
            selector = sdscatfmt(selector, "" %s"", op);
            if (op[sdslen(op) - 1] == ')') {
                open_bracket_start = -1;
                acl_args[*merged_argc] = selector;                        
                (*merged_argc)++;
            }
            continue;
        }

        acl_args[*merged_argc] = sdsdup(argv[j]);
        (*merged_argc)++;
    }

    if (open_bracket_start != -1) {
        for (int i = 0; i < *merged_argc; i++) sdsfree(acl_args[i]);
        zfr...",1,1,acl.c,ACLMergeSelectorArguments,,false,1983,2022,ACLMergeSelectorArguments,,,102,"sds ACLMergeSelectorArguments (sds*,int,int*,int*)"
6731,METHOD,acl.c:<global>,TYPE_DECL,"sds ACLStringSetUser(user *u, sds username, sds *argv, int argc) {
    serverAssert(u != NULL || username != NULL);

    sds error = NULL;

    int merged_argc = 0, invalid_idx = 0;
    sds *acl_args = ACLMergeSelectorArguments(argv, argc, &merged_argc, &invalid_idx);

    if (!acl_args) {
        return sdscatfmt(sdsempty(),
                         ""Unmatched parenthesis in acl selector starting ""
                         ""at '%s'."", (char *) argv[invalid_idx]);
    }

    /* Create a temporary user to validate and stage all changes against
     * before applying to an existing user or creating a new user. If all
     * arguments are valid the user parameters will all be applied together.
     * If there are any errors then none of the changes will be applied. */
    user *tempu = ACLCreateUnlinkedUser();
    if (u) {
        ACLCopyUser(tempu, u);
    }

    for (int j = 0; j < merged_argc; j++) {
        if (ACLSetUser(tempu,acl_args[j],(ssize_t) sdslen(acl_args[j])) != C_OK) {
...",1,4,acl.c,ACLStringSetUser,,false,2029,2084,ACLStringSetUser,,,103,"sds ACLStringSetUser (user*,sds,sds*,int)"
6907,METHOD,acl.c:<global>,TYPE_DECL,"int ACLAppendUserForLoading(sds *argv, int argc, int *argc_err) {
    if (argc < 2 || strcasecmp(argv[0],""user"")) {
        if (argc_err) *argc_err = 0;
        return C_ERR;
    }

    if (listSearchKey(UsersToLoad, argv[1])) {
        if (argc_err) *argc_err = 1;
        errno = EALREADY;
        return C_ERR; 
    }

    /* Merged selectors before trying to process */
    int merged_argc;
    sds *acl_args = ACLMergeSelectorArguments(argv + 2, argc - 2, &merged_argc, argc_err);

    if (!acl_args) {
        return C_ERR;
    }

    /* Try to apply the user rules in a fake user to see if they
     * are actually valid. */
    user *fakeuser = ACLCreateUnlinkedUser();

    for (int j = 0; j < merged_argc; j++) {
        if (ACLSetUser(fakeuser,acl_args[j],sdslen(acl_args[j])) == C_ERR) {
            if (errno != ENOENT) {
                ACLFreeUser(fakeuser);
                if (argc_err) *argc_err = j;
                for (int i = 0; i < merged_argc; i++) sdsfree(acl_args[i]);
  ...",1,15,acl.c,ACLAppendUserForLoading,,false,2104,2150,ACLAppendUserForLoading,,,104,"int ACLAppendUserForLoading (sds*,int,int*)"
7122,METHOD,acl.c:<global>,TYPE_DECL,"int ACLLoadConfiguredUsers(void) {
    listIter li;
    listNode *ln;
    listRewind(UsersToLoad,&li);
    while ((ln = listNext(&li)) != NULL) {
        sds *aclrules = listNodeValue(ln);
        sds username = aclrules[0];

        if (ACLStringHasSpaces(aclrules[0],sdslen(aclrules[0]))) {
            serverLog(LL_WARNING,""Spaces not allowed in ACL usernames"");
            return C_ERR;
        }

        user *u = ACLCreateUser(username,sdslen(username));
        if (!u) {
            /* Only valid duplicate user is the default one. */
            serverAssert(!strcmp(username, ""default""));
            u = ACLGetUserByName(""default"",7);
            ACLSetUser(u,""reset"",-1);
        }

        /* Load every rule defined for this user. */
        for (int j = 1; aclrules[j]; j++) {
            if (ACLSetUser(u,aclrules[j],sdslen(aclrules[j])) != C_OK) {
                const char *errmsg = ACLSetUserStringError();
                serverLog(LL_WARNING,""Error loading ACL rule '%s' fo...",1,24,acl.c,ACLLoadConfiguredUsers,,false,2155,2197,ACLLoadConfiguredUsers,,,105,int ACLLoadConfiguredUsers (void)
7325,METHOD,acl.c:<global>,TYPE_DECL,"sds ACLLoadFromFile(const char *filename) {
    FILE *fp;
    char buf[1024];

    /* Open the ACL file. */
    if ((fp = fopen(filename,""r"")) == NULL) {
        sds errors = sdscatprintf(sdsempty(),
            ""Error loading ACLs, opening file '%s': %s"",
            filename, strerror(errno));
        return errors;
    }

    /* Load the whole file as a single string in memory. */
    sds acls = sdsempty();
    while(fgets(buf,sizeof(buf),fp) != NULL)
        acls = sdscat(acls,buf);
    fclose(fp);

    /* Split the file into lines and attempt to load each line. */
    int totlines;
    sds *lines, errors = sdsempty();
    lines = sdssplitlen(acls,strlen(acls),""\n"",1,&totlines);
    sdsfree(acls);

    /* We do all the loading in a fresh instance of the Users radix tree,
     * so if there are errors loading the ACL file we can rollback to the
     * old version. */
    rax *old_users = Users;
    Users = raxNew();

    /* Load each line of the file. */
    for (int i = 0; i < t...",1,65,acl.c,ACLLoadFromFile,,false,2222,2379,ACLLoadFromFile,,,106,sds ACLLoadFromFile (char*)
7752,METHOD,acl.c:<global>,TYPE_DECL,"int ACLSaveToFile(const char *filename) {
    sds acl = sdsempty();
    int fd = -1;
    sds tmpfilename = NULL;
    int retval = C_ERR;

    /* Let's generate an SDS string containing the new version of the
     * ACL file. */
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        /* Return information in the configuration file format. */
        sds user = sdsnew(""user "");
        user = sdscatsds(user,u->name);
        user = sdscatlen(user,"" "",1);
        robj *descr = ACLDescribeUser(u);
        user = sdscatsds(user,descr->ptr);
        decrRefCount(descr);
        acl = sdscatsds(acl,user);
        acl = sdscatlen(acl,""\n"",1);
        sdsfree(user);
    }
    raxStop(&ri);

    /* Create a temp file with the new content. */
    tmpfilename = sdsnew(filename);
    tmpfilename = sdscatfmt(tmpfilename,"".tmp-%i-%I"",
        (int) getpid(),commandTimeSnapshot());
    if ((fd = open(tmpfilename,O_WRONLY...",1,17,acl.c,ACLSaveToFile,,false,2384,2459,ACLSaveToFile,,,107,int ACLSaveToFile (char*)
8075,METHOD,acl.c:<global>,TYPE_DECL,"void ACLLoadUsersAtStartup(void) {
    if (server.acl_filename[0] != '\0' && listLength(UsersToLoad) != 0) {
        serverLog(LL_WARNING,
            ""Configuring Redis with users defined in redis.conf and at ""
            ""the same setting an ACL file path is invalid. This setup ""
            ""is very likely to lead to configuration errors and security ""
            ""holes, please define either an ACL file or declare users ""
            ""directly in your redis.conf, but not both."");
        exit(1);
    }

    if (ACLLoadConfiguredUsers() == C_ERR) {
        serverLog(LL_WARNING,
            ""Critical error while loading ACLs. Exiting."");
        exit(1);
    }

    if (server.acl_filename[0] != '\0') {
        sds errors = ACLLoadFromFile(server.acl_filename);
        if (errors) {
            serverLog(LL_WARNING,
                ""Aborting Redis startup because of ACL errors: %s"", errors);
            sdsfree(errors);
            exit(1);
        }
    }
}",1,42,acl.c,ACLLoadUsersAtStartup,,false,2466,2492,ACLLoadUsersAtStartup,,,108,void ACLLoadUsersAtStartup (void)
8199,METHOD,acl.c:<global>,TYPE_DECL,"int ACLLogMatchEntry(ACLLogEntry *a, ACLLogEntry *b) {
    if (a->reason != b->reason) return 0;
    if (a->context != b->context) return 0;
    mstime_t delta = a->ctime - b->ctime;
    if (delta < 0) delta = -delta;
    if (delta > ACL_LOG_GROUPING_MAX_TIME_DELTA) return 0;
    if (sdscmp(a->object,b->object) != 0) return 0;
    if (sdscmp(a->username,b->username) != 0) return 0;
    return 1;
}",1,16,acl.c,ACLLogMatchEntry,,false,2517,2526,ACLLogMatchEntry,,,111,"int ACLLogMatchEntry (ACLLogEntry*,ACLLogEntry*)"
8283,METHOD,acl.c:<global>,TYPE_DECL,"void ACLFreeLogEntry(void *leptr) {
    ACLLogEntry *le = leptr;
    sdsfree(le->object);
    sdsfree(le->username);
    sdsfree(le->cinfo);
    zfree(le);
}",1,1,acl.c,ACLFreeLogEntry,,false,2529,2535,ACLFreeLogEntry,,,112,void ACLFreeLogEntry (void*)
8306,METHOD,acl.c:<global>,TYPE_DECL,"void ACLUpdateInfoMetrics(int reason){
    if (reason == ACL_DENIED_AUTH) {
        server.acl_info.user_auth_failures++;
    } else if (reason == ACL_DENIED_CMD) {
        server.acl_info.invalid_cmd_accesses++;
    } else if (reason == ACL_DENIED_KEY) {
        server.acl_info.invalid_key_accesses++;
    } else if (reason == ACL_DENIED_CHANNEL) {
        server.acl_info.invalid_channel_accesses++;
    } else {
        serverPanic(""Unknown ACL_DENIED encoding"");
    }
}",1,18,acl.c,ACLUpdateInfoMetrics,,false,2538,2550,ACLUpdateInfoMetrics,,,113,void ACLUpdateInfoMetrics (int)
8379,METHOD,acl.c:<global>,TYPE_DECL,"void addACLLogEntry(client *c, int reason, int context, int argpos, sds username, sds object) {
    /* Update ACL info metrics */
    ACLUpdateInfoMetrics(reason);
    
    /* Create a new entry. */
    struct ACLLogEntry *le = zmalloc(sizeof(*le));
    le->count = 1;
    le->reason = reason;
    le->username = sdsdup(username ? username : c->user->name);
    le->ctime = commandTimeSnapshot();
    le->entry_id = ACLLogEntryCount;
    le->timestamp_created = le->ctime;

    if (object) {
        le->object = object;
    } else {
        switch(reason) {
            case ACL_DENIED_CMD: le->object = sdsdup(c->cmd->fullname); break;
            case ACL_DENIED_KEY: le->object = sdsdup(c->argv[argpos]->ptr); break;
            case ACL_DENIED_CHANNEL: le->object = sdsdup(c->argv[argpos]->ptr); break;
            case ACL_DENIED_AUTH: le->object = sdsdup(c->argv[0]->ptr); break;
            default: le->object = sdsempty();
        }
    }

    /* if we have a real client from the networ...",1,17,acl.c,addACLLogEntry,,false,2567,2640,addACLLogEntry,,,114,"void addACLLogEntry (client*,int,int,int,sds,sds)"
8670,METHOD,acl.c:<global>,TYPE_DECL,"sds getAclErrorMessage(int acl_res, user *user, struct redisCommand *cmd, sds errored_val, int verbose) {
    switch (acl_res) {
    case ACL_DENIED_CMD:
        return sdscatfmt(sdsempty(), ""User %S has no permissions to run ""
                                     ""the '%S' command"", user->name, cmd->fullname);
    case ACL_DENIED_KEY:
        if (verbose) {
            return sdscatfmt(sdsempty(), ""User %S has no permissions to access ""
                                         ""the '%S' key"", user->name, errored_val);
        } else {
            return sdsnew(""No permissions to access a key"");
        }
    case ACL_DENIED_CHANNEL:
        if (verbose) {
            return sdscatfmt(sdsempty(), ""User %S has no permissions to access ""
                                         ""the '%S' channel"", user->name, errored_val);
        } else {
            return sdsnew(""No permissions to access a channel"");
        }
    }
    serverPanic(""Reached deadcode on getAclErrorMessage"");
}",1,9,acl.c,getAclErrorMessage,,false,2642,2663,getAclErrorMessage,,,115,"sds getAclErrorMessage (int,user*,redisCommand*,sds,int)"
8744,METHOD,acl.c:<global>,TYPE_DECL,"void aclCatWithFlags(client *c, dict *commands, uint64_t cflag, int *arraylen) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (cmd->flags & CMD_MODULE) continue;
        if (cmd->acl_categories & cflag) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            (*arraylen)++;
        }

        if (cmd->subcommands_dict) {
            aclCatWithFlags(c, cmd->subcommands_dict, cflag, arraylen);
        }
    }
    dictReleaseIterator(di);
}",1,25,acl.c,aclCatWithFlags,,false,2670,2687,aclCatWithFlags,,,116,"void aclCatWithFlags (client*,dict*,uint64_t,int*)"
8816,METHOD,acl.c:<global>,TYPE_DECL,"int aclAddReplySelectorDescription(client *c, aclSelector *s) {
    listIter li;
    listNode *ln;

    /* Commands */
    addReplyBulkCString(c,""commands"");
    sds cmddescr = ACLDescribeSelectorCommandRules(s);
    addReplyBulkSds(c,cmddescr);
    
    /* Key patterns */
    addReplyBulkCString(c,""keys"");
    if (s->flags & SELECTOR_FLAG_ALLKEYS) {
        addReplyBulkCBuffer(c,""~*"",2);
    } else {
        sds dsl = sdsempty();
        listRewind(s->patterns,&li);
        while((ln = listNext(&li))) {
            keyPattern *thispat = (keyPattern *) listNodeValue(ln);
            if (ln != listFirst(s->patterns)) dsl = sdscat(dsl, "" "");
            dsl = sdsCatPatternString(dsl, thispat);
        }
        addReplyBulkSds(c, dsl);
    }

    /* Pub/sub patterns */
    addReplyBulkCString(c,""channels"");
    if (s->flags & SELECTOR_FLAG_ALLCHANNELS) {
        addReplyBulkCBuffer(c,""&*"",2);
    } else {
        sds dsl = sdsempty();
        listRewind(s->channels,&li);
        while...",1,19,acl.c,aclAddReplySelectorDescription,,false,2695,2734,aclAddReplySelectorDescription,,,117,"int aclAddReplySelectorDescription (client*,aclSelector*)"
8986,METHOD,acl.c:<global>,TYPE_DECL,"void aclCommand(client *c) {
    char *sub = c->argv[1]->ptr;
    if (!strcasecmp(sub,""setuser"") && c->argc >= 3) {
        /* Initially redact all of the arguments to not leak any information
         * about the user. */
        for (int j = 2; j < c->argc; j++) {
            redactClientCommandArgument(c, j);
        }

        sds username = c->argv[2]->ptr;
        /* Check username validity. */
        if (ACLStringHasSpaces(username,sdslen(username))) {
            addReplyErrorFormat(c,
                ""Usernames can't contain spaces or null characters"");
            return;
        }

        user *u = ACLGetUserByName(username,sdslen(username));

        sds *temp_argv = zmalloc(c->argc * sizeof(sds));
        for (int i = 3; i < c->argc; i++) temp_argv[i-3] = c->argv[i]->ptr;

        sds error = ACLStringSetUser(u, username, temp_argv, c->argc - 3);
        zfree(temp_argv);
        if (error == NULL) {
            addReply(c,shared.ok);
        } else {
            addR...",1,27,acl.c,aclCommand,,false,2750,3071,aclCommand,,,118,void aclCommand (client*)
10430,METHOD,acl.c:<global>,TYPE_DECL,"void addReplyCommandCategories(client *c, struct redisCommand *cmd) {
    int flagcount = 0;
    void *flaglen = addReplyDeferredLen(c);
    for (int j = 0; ACLCommandCategories[j].flag != 0; j++) {
        if (cmd->acl_categories & ACLCommandCategories[j].flag) {
            addReplyStatusFormat(c, ""@%s"", ACLCommandCategories[j].name);
            flagcount++;
        }
    }
    setDeferredSetLen(c, flaglen, flagcount);
}",1,1,acl.c,addReplyCommandCategories,,false,3073,3083,addReplyCommandCategories,,,119,"void addReplyCommandCategories (client*,redisCommand*)"
10486,METHOD,acl.c:<global>,TYPE_DECL,"void authCommand(client *c) {
    /* Only two or three argument forms are allowed. */
    if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }
    /* Always redact the second argument */
    redactClientCommandArgument(c, 1);

    /* Handle the two different forms here. The form with two arguments
     * will just use ""default"" as username. */
    robj *username, *password;
    if (c->argc == 2) {
        /* Mimic the old behavior of giving an error for the two argument
         * form if no password is configured. */
        if (DefaultUser->flags & USER_FLAG_NOPASS) {
            addReplyError(c,""AUTH <password> called without any password ""
                            ""configured for the default user. Are you sure ""
                            ""your configuration is correct?"");
            return;
        }

        username = shared.default_username; 
        password = c->argv[1];
    } else {
        username = c->argv[1];
        password ...",1,33,acl.c,authCommand,,false,3090,3128,authCommand,,,120,void authCommand (client*)
10600,METHOD,acl.c:<global>,TYPE_DECL,"void ACLUpdateDefaultUserPassword(sds password) {
    ACLSetUser(DefaultUser,""resetpass"",-1);
    if (password) {
        sds aclop = sdscatlen(sdsnew("">""), password, sdslen(password));
        ACLSetUser(DefaultUser,aclop,sdslen(aclop));
        sdsfree(aclop);
    } else {
        ACLSetUser(DefaultUser,""nopass"",-1);
    }
}",1,1,acl.c,ACLUpdateDefaultUserPassword,,false,3132,3141,ACLUpdateDefaultUserPassword,,,121,void ACLUpdateDefaultUserPassword (sds)
10645,METHOD,adlist.c:<global>,TYPE_DECL,<global>,1,20,adlist.c,adlist.c:<global>,,false,1,417,<global>,,,1,
10647,METHOD,adlist.c:<global>,TYPE_DECL,"list *listCreate(void)
{
    struct list *list;

    if ((list = zmalloc(sizeof(*list))) == NULL)
        return NULL;
    list->head = list->tail = NULL;
    list->len = 0;
    list->dup = NULL;
    list->free = NULL;
    list->match = NULL;
    return list;
}",1,1,adlist.c,listCreate,,false,42,54,listCreate,,,1,list listCreate (void)
10696,METHOD,adlist.c:<global>,TYPE_DECL,"void listEmpty(list *list)
{
    unsigned long len;
    listNode *current, *next;

    current = list->head;
    len = list->len;
    while(len--) {
        next = current->next;
        if (list->free) list->free(current->value);
        zfree(current);
        current = next;
    }
    list->head = list->tail = NULL;
    list->len = 0;
}",1,1,adlist.c,listEmpty,,false,57,72,listEmpty,,,2,void listEmpty (list*)
10754,METHOD,adlist.c:<global>,TYPE_DECL,"void listRelease(list *list)
{
    listEmpty(list);
    zfree(list);
}",1,1,adlist.c,listRelease,,false,77,81,listRelease,,,3,void listRelease (list*)
10763,METHOD,adlist.c:<global>,TYPE_DECL,"list *listAddNodeHead(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    listLinkNodeHead(list, node);
    return list;
}",1,1,adlist.c,listAddNodeHead,,false,89,98,listAddNodeHead,,,4,"list listAddNodeHead (list*,void*)"
10792,METHOD,adlist.c:<global>,TYPE_DECL,"void listLinkNodeHead(list* list, listNode *node) {
    if (list->len == 0) {
        list->head = list->tail = node;
        node->prev = node->next = NULL;
    } else {
        node->prev = NULL;
        node->next = list->head;
        list->head->prev = node;
        list->head = node;
    }
    list->len++;
}",1,1,adlist.c,listLinkNodeHead,,false,103,114,listLinkNodeHead,,,5,"void listLinkNodeHead (list*,listNode*)"
10853,METHOD,adlist.c:<global>,TYPE_DECL,"list *listAddNodeTail(list *list, void *value)
{
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    listLinkNodeTail(list, node);
    return list;
}",1,1,adlist.c,listAddNodeTail,,false,122,131,listAddNodeTail,,,6,"list listAddNodeTail (list*,void*)"
10882,METHOD,adlist.c:<global>,TYPE_DECL,"void listLinkNodeTail(list *list, listNode *node) {
    if (list->len == 0) {
        list->head = list->tail = node;
        node->prev = node->next = NULL;
    } else {
        node->prev = list->tail;
        node->next = NULL;
        list->tail->next = node;
        list->tail = node;
    }
    list->len++;
}",1,1,adlist.c,listLinkNodeTail,,false,136,147,listLinkNodeTail,,,7,"void listLinkNodeTail (list*,listNode*)"
10943,METHOD,adlist.c:<global>,TYPE_DECL,"list *listInsertNode(list *list, listNode *old_node, void *value, int after) {
    listNode *node;

    if ((node = zmalloc(sizeof(*node))) == NULL)
        return NULL;
    node->value = value;
    if (after) {
        node->prev = old_node;
        node->next = old_node->next;
        if (list->tail == old_node) {
            list->tail = node;
        }
    } else {
        node->next = old_node;
        node->prev = old_node->prev;
        if (list->head == old_node) {
            list->head = node;
        }
    }
    if (node->prev != NULL) {
        node->prev->next = node;
    }
    if (node->next != NULL) {
        node->next->prev = node;
    }
    list->len++;
    return list;
}",1,1,adlist.c,listInsertNode,,false,149,176,listInsertNode,,,8,"list listInsertNode (list*,listNode*,void*,int)"
11056,METHOD,adlist.c:<global>,TYPE_DECL,"void listDelNode(list *list, listNode *node)
{
    listUnlinkNode(list, node);
    if (list->free) list->free(node->value);
    zfree(node);
}",1,1,adlist.c,listDelNode,,false,182,187,listDelNode,,,9,"void listDelNode (list*,listNode*)"
11079,METHOD,adlist.c:<global>,TYPE_DECL,"void listUnlinkNode(list *list, listNode *node) {
    if (node->prev)
        node->prev->next = node->next;
    else
        list->head = node->next;
    if (node->next)
        node->next->prev = node->prev;
    else
        list->tail = node->prev;

    node->next = NULL;
    node->prev = NULL;

    list->len--;
}",1,1,adlist.c,listUnlinkNode,,false,192,206,listUnlinkNode,,,10,"void listUnlinkNode (list*,listNode*)"
11145,METHOD,adlist.c:<global>,TYPE_DECL,"listIter *listGetIterator(list *list, int direction)
{
    listIter *iter;

    if ((iter = zmalloc(sizeof(*iter))) == NULL) return NULL;
    if (direction == AL_START_HEAD)
        iter->next = list->head;
    else
        iter->next = list->tail;
    iter->direction = direction;
    return iter;
}",1,21,adlist.c,listGetIterator,,false,212,223,listGetIterator,,,11,"listIter listGetIterator (list*,int)"
11194,METHOD,adlist.c:<global>,TYPE_DECL,"void listReleaseIterator(listIter *iter) {
    zfree(iter);
}",1,1,adlist.c,listReleaseIterator,,false,226,228,listReleaseIterator,,,12,void listReleaseIterator (listIter*)
11201,METHOD,adlist.c:<global>,TYPE_DECL,"void listRewind(list *list, listIter *li) {
    li->next = list->head;
    li->direction = AL_START_HEAD;
}",1,20,adlist.c,listRewind,,false,231,234,listRewind,,,13,"void listRewind (list*,listIter*)"
11221,METHOD,adlist.c:<global>,TYPE_DECL,"void listRewindTail(list *list, listIter *li) {
    li->next = list->tail;
    li->direction = AL_START_TAIL;
}",1,20,adlist.c,listRewindTail,,false,236,239,listRewindTail,,,14,"void listRewindTail (list*,listIter*)"
11241,METHOD,adlist.c:<global>,TYPE_DECL,"listNode *listNext(listIter *iter)
{
    listNode *current = iter->next;

    if (current != NULL) {
        if (iter->direction == AL_START_HEAD)
            iter->next = current->next;
        else
            iter->next = current->prev;
    }
    return current;
}",1,31,adlist.c,listNext,,false,255,266,listNext,,,15,listNode listNext (listIter*)
11284,METHOD,adlist.c:<global>,TYPE_DECL,"list *listDup(list *orig)
{
    list *copy;
    listIter iter;
    listNode *node;

    if ((copy = listCreate()) == NULL)
        return NULL;
    copy->dup = orig->dup;
    copy->free = orig->free;
    copy->match = orig->match;
    listRewind(orig, &iter);
    while((node = listNext(&iter)) != NULL) {
        void *value;

        if (copy->dup) {
            value = copy->dup(node->value);
            if (value == NULL) {
                listRelease(copy);
                return NULL;
            }
        } else {
            value = node->value;
        }
        
        if (listAddNodeTail(copy, value) == NULL) {
            /* Free value if dup succeed but listAddNodeTail failed. */
            if (copy->free) copy->free(value);

            listRelease(copy);
            return NULL;
        }
    }
    return copy;
}",1,1,adlist.c,listDup,,false,276,310,listDup,,,16,list listDup (list*)
11389,METHOD,adlist.c:<global>,TYPE_DECL,"listNode *listSearchKey(list *list, void *key)
{
    listIter iter;
    listNode *node;

    listRewind(list, &iter);
    while((node = listNext(&iter)) != NULL) {
        if (list->match) {
            if (list->match(node->value, key)) {
                return node;
            }
        } else {
            if (key == node->value) {
                return node;
            }
        }
    }
    return NULL;
}",1,1,adlist.c,listSearchKey,,false,321,339,listSearchKey,,,17,"listNode listSearchKey (list*,void*)"
11440,METHOD,adlist.c:<global>,TYPE_DECL,"listNode *listIndex(list *list, long index) {
    listNode *n;

    if (index < 0) {
        index = (-index)-1;
        n = list->tail;
        while(index-- && n) n = n->prev;
    } else {
        n = list->head;
        while(index-- && n) n = n->next;
    }
    return n;
}",1,1,adlist.c,listIndex,,false,346,358,listIndex,,,18,"listNode listIndex (list*,long)"
11492,METHOD,adlist.c:<global>,TYPE_DECL,"void listRotateTailToHead(list *list) {
    if (listLength(list) <= 1) return;

    /* Detach current tail */
    listNode *tail = list->tail;
    list->tail = tail->prev;
    list->tail->next = NULL;
    /* Move it as head */
    list->head->prev = tail;
    tail->prev = NULL;
    tail->next = list->head;
    list->head = tail;
}",1,8,adlist.c,listRotateTailToHead,,false,361,373,listRotateTailToHead,,,19,void listRotateTailToHead (list*)
11552,METHOD,adlist.c:<global>,TYPE_DECL,"void listRotateHeadToTail(list *list) {
    if (listLength(list) <= 1) return;

    listNode *head = list->head;
    /* Detach current head */
    list->head = head->next;
    list->head->prev = NULL;
    /* Move it as tail */
    list->tail->next = head;
    head->next = NULL;
    head->prev = list->tail;
    list->tail = head;
}",1,8,adlist.c,listRotateHeadToTail,,false,376,388,listRotateHeadToTail,,,20,void listRotateHeadToTail (list*)
11612,METHOD,adlist.c:<global>,TYPE_DECL,"void listJoin(list *l, list *o) {
    if (o->len == 0) return;

    o->head->prev = l->tail;

    if (l->tail)
        l->tail->next = o->head;
    else
        l->head = o->head;

    l->tail = o->tail;
    l->len += o->len;

    /* Setup other as an empty list. */
    o->head = o->tail = NULL;
    o->len = 0;
}",1,1,adlist.c,listJoin,,false,392,408,listJoin,,,21,"void listJoin (list*,list*)"
11686,METHOD,adlist.c:<global>,TYPE_DECL,"void listInitNode(listNode *node, void *value) {
    node->prev = NULL;
    node->next = NULL;
    node->value = value;
}",1,1,adlist.c,listInitNode,,false,413,417,listInitNode,,,22,"void listInitNode (listNode*,void*)"
11710,METHOD,adlist.h:<global>,TYPE_DECL,<global>,1,25,adlist.h,adlist.h:<global>,,false,1,100,<global>,,,1,
11726,METHOD,list,TYPE_DECL,void *(*dup)(void *ptr);,10,27,adlist.h,list.dup,,false,50,50,dup,,,3,void* list.dup (void*)
11731,METHOD,list,TYPE_DECL,void (*free)(void *ptr);,10,27,adlist.h,list.free,,false,51,51,free,,,4,void list.free (void*)
11736,METHOD,list,TYPE_DECL,"int (*match)(void *ptr, void *key);",9,38,adlist.h,list.match,,false,52,52,match,,,5,"int list.match (void*,void*)"
11744,METHOD,adlist.h:<global>,TYPE_DECL,list *listCreate(void);,6,22,adlist.h,listCreate,,false,73,73,listCreate,,,7,list* listCreate (void)
11749,METHOD,adlist.h:<global>,TYPE_DECL,void listRelease(list *list);,6,28,adlist.h,listRelease,,false,74,74,listRelease,,,8,void listRelease (list*)
11754,METHOD,adlist.h:<global>,TYPE_DECL,void listEmpty(list *list);,6,26,adlist.h,listEmpty,,false,75,75,listEmpty,,,9,void listEmpty (list*)
11759,METHOD,adlist.h:<global>,TYPE_DECL,"list *listAddNodeHead(list *list, void *value);",6,46,adlist.h,listAddNodeHead,,false,76,76,listAddNodeHead,,,10,"list* listAddNodeHead (list*,void*)"
11765,METHOD,adlist.h:<global>,TYPE_DECL,"list *listAddNodeTail(list *list, void *value);",6,46,adlist.h,listAddNodeTail,,false,77,77,listAddNodeTail,,,11,"list* listAddNodeTail (list*,void*)"
11771,METHOD,adlist.h:<global>,TYPE_DECL,"list *listInsertNode(list *list, listNode *old_node, void *value, int after);",6,76,adlist.h,listInsertNode,,false,78,78,listInsertNode,,,12,"list* listInsertNode (list*,listNode*,void*,int)"
11779,METHOD,adlist.h:<global>,TYPE_DECL,"void listDelNode(list *list, listNode *node);",6,44,adlist.h,listDelNode,,false,79,79,listDelNode,,,13,"void listDelNode (list*,listNode*)"
11785,METHOD,adlist.h:<global>,TYPE_DECL,"listIter *listGetIterator(list *list, int direction);",10,52,adlist.h,listGetIterator,,false,80,80,listGetIterator,,,14,"listIter* listGetIterator (list*,int)"
11791,METHOD,adlist.h:<global>,TYPE_DECL,listNode *listNext(listIter *iter);,10,34,adlist.h,listNext,,false,81,81,listNext,,,15,listNode* listNext (listIter*)
11796,METHOD,adlist.h:<global>,TYPE_DECL,void listReleaseIterator(listIter *iter);,6,40,adlist.h,listReleaseIterator,,false,82,82,listReleaseIterator,,,16,void listReleaseIterator (listIter*)
11801,METHOD,adlist.h:<global>,TYPE_DECL,list *listDup(list *orig);,6,25,adlist.h,listDup,,false,83,83,listDup,,,17,list* listDup (list*)
11806,METHOD,adlist.h:<global>,TYPE_DECL,"listNode *listSearchKey(list *list, void *key);",10,46,adlist.h,listSearchKey,,false,84,84,listSearchKey,,,18,"listNode* listSearchKey (list*,void*)"
11812,METHOD,adlist.h:<global>,TYPE_DECL,"listNode *listIndex(list *list, long index);",10,43,adlist.h,listIndex,,false,85,85,listIndex,,,19,"listNode* listIndex (list*,long)"
11818,METHOD,adlist.h:<global>,TYPE_DECL,"void listRewind(list *list, listIter *li);",6,41,adlist.h,listRewind,,false,86,86,listRewind,,,20,"void listRewind (list*,listIter*)"
11824,METHOD,adlist.h:<global>,TYPE_DECL,"void listRewindTail(list *list, listIter *li);",6,45,adlist.h,listRewindTail,,false,87,87,listRewindTail,,,21,"void listRewindTail (list*,listIter*)"
11830,METHOD,adlist.h:<global>,TYPE_DECL,void listRotateTailToHead(list *list);,6,37,adlist.h,listRotateTailToHead,,false,88,88,listRotateTailToHead,,,22,void listRotateTailToHead (list*)
11835,METHOD,adlist.h:<global>,TYPE_DECL,void listRotateHeadToTail(list *list);,6,37,adlist.h,listRotateHeadToTail,,false,89,89,listRotateHeadToTail,,,23,void listRotateHeadToTail (list*)
11840,METHOD,adlist.h:<global>,TYPE_DECL,"void listJoin(list *l, list *o);",6,31,adlist.h,listJoin,,false,90,90,listJoin,,,24,"void listJoin (list*,list*)"
11846,METHOD,adlist.h:<global>,TYPE_DECL,"void listInitNode(listNode *node, void *value);",6,46,adlist.h,listInitNode,,false,91,91,listInitNode,,,25,"void listInitNode (listNode*,void*)"
11852,METHOD,adlist.h:<global>,TYPE_DECL,"void listLinkNodeHead(list *list, listNode *node);",6,49,adlist.h,listLinkNodeHead,,false,92,92,listLinkNodeHead,,,26,"void listLinkNodeHead (list*,listNode*)"
11858,METHOD,adlist.h:<global>,TYPE_DECL,"void listLinkNodeTail(list *list, listNode *node);",6,49,adlist.h,listLinkNodeTail,,false,93,93,listLinkNodeTail,,,27,"void listLinkNodeTail (list*,listNode*)"
11864,METHOD,adlist.h:<global>,TYPE_DECL,"void listUnlinkNode(list *list, listNode *node);",6,47,adlist.h,listUnlinkNode,,false,94,94,listUnlinkNode,,,28,"void listUnlinkNode (list*,listNode*)"
11909,METHOD,ae.c:<global>,TYPE_DECL,<global>,1,1,ae.c,ae.c:<global>,,false,1,512,<global>,,,1,
11911,METHOD,ae.c:<global>,TYPE_DECL,"aeEventLoop *aeCreateEventLoop(int setsize) {
    aeEventLoop *eventLoop;
    int i;

    monotonicInit();    /* just in case the calling app didn't initialize */

    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;
    eventLoop->events = zmalloc(sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zmalloc(sizeof(aeFiredEvent)*setsize);
    if (eventLoop->events == NULL || eventLoop->fired == NULL) goto err;
    eventLoop->setsize = setsize;
    eventLoop->timeEventHead = NULL;
    eventLoop->timeEventNextId = 0;
    eventLoop->stop = 0;
    eventLoop->maxfd = -1;
    eventLoop->beforesleep = NULL;
    eventLoop->aftersleep = NULL;
    eventLoop->flags = 0;
    if (aeApiCreate(eventLoop) == -1) goto err;
    /* Events with mask == AE_NONE are not set. So let's initialize the
     * vector with it. */
    for (i = 0; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return eventLoop;

err:
    if (eventLoop) {
        zfree(eventLoop->events);
     ...",1,36,ae.c,aeCreateEventLoop,,false,67,99,aeCreateEventLoop,,,1,aeEventLoop aeCreateEventLoop (int)
12050,METHOD,ae.c:<global>,TYPE_DECL,"int aeGetSetSize(aeEventLoop *eventLoop) {
    return eventLoop->setsize;
}",1,1,ae.c,aeGetSetSize,,false,102,104,aeGetSetSize,,,2,int aeGetSetSize (aeEventLoop*)
12059,METHOD,ae.c:<global>,TYPE_DECL,"void aeSetDontWait(aeEventLoop *eventLoop, int noWait) {
    if (noWait)
        eventLoop->flags |= AE_DONT_WAIT;
    else
        eventLoop->flags &= ~AE_DONT_WAIT;
}",1,28,ae.c,aeSetDontWait,,false,111,116,aeSetDontWait,,,3,"void aeSetDontWait (aeEventLoop*,int)"
12089,METHOD,ae.c:<global>,TYPE_DECL,"int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {
    int i;

    if (setsize == eventLoop->setsize) return AE_OK;
    if (eventLoop->maxfd >= setsize) return AE_ERR;
    if (aeApiResize(eventLoop,setsize) == -1) return AE_ERR;

    eventLoop->events = zrealloc(eventLoop->events,sizeof(aeFileEvent)*setsize);
    eventLoop->fired = zrealloc(eventLoop->fired,sizeof(aeFiredEvent)*setsize);
    eventLoop->setsize = setsize;

    /* Make sure that if we created new slots, they are initialized with
     * an AE_NONE mask. */
    for (i = eventLoop->maxfd+1; i < setsize; i++)
        eventLoop->events[i].mask = AE_NONE;
    return AE_OK;
}",1,46,ae.c,aeResizeSetSize,,false,125,141,aeResizeSetSize,,,4,"int aeResizeSetSize (aeEventLoop*,int)"
12190,METHOD,ae.c:<global>,TYPE_DECL,"void aeDeleteEventLoop(aeEventLoop *eventLoop) {
    aeApiFree(eventLoop);
    zfree(eventLoop->events);
    zfree(eventLoop->fired);

    /* Free the time events list. */
    aeTimeEvent *next_te, *te = eventLoop->timeEventHead;
    while (te) {
        next_te = te->next;
        zfree(te);
        te = next_te;
    }
    zfree(eventLoop);
}",1,1,ae.c,aeDeleteEventLoop,,false,143,156,aeDeleteEventLoop,,,5,void aeDeleteEventLoop (aeEventLoop*)
12227,METHOD,ae.c:<global>,TYPE_DECL,"void aeStop(aeEventLoop *eventLoop) {
    eventLoop->stop = 1;
}",1,1,ae.c,aeStop,,false,158,160,aeStop,,,6,void aeStop (aeEventLoop*)
12237,METHOD,ae.c:<global>,TYPE_DECL,"int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData)
{
    if (fd >= eventLoop->setsize) {
        errno = ERANGE;
        return AE_ERR;
    }
    aeFileEvent *fe = &eventLoop->events[fd];

    if (aeApiAddEvent(eventLoop, fd, mask) == -1)
        return AE_ERR;
    fe->mask |= mask;
    if (mask & AE_READABLE) fe->rfileProc = proc;
    if (mask & AE_WRITABLE) fe->wfileProc = proc;
    fe->clientData = clientData;
    if (fd > eventLoop->maxfd)
        eventLoop->maxfd = fd;
    return AE_OK;
}",1,15,ae.c,aeCreateFileEvent,,false,162,180,aeCreateFileEvent,,,7,"int aeCreateFileEvent (aeEventLoop*,int,int,aeFileProc*,void*)"
12334,METHOD,ae.c:<global>,TYPE_DECL,"void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)
{
    if (fd >= eventLoop->setsize) return;
    aeFileEvent *fe = &eventLoop->events[fd];
    if (fe->mask == AE_NONE) return;

    /* We want to always remove AE_BARRIER if set when AE_WRITABLE
     * is removed. */
    if (mask & AE_WRITABLE) mask |= AE_BARRIER;

    aeApiDelEvent(eventLoop, fd, mask);
    fe->mask = fe->mask & (~mask);
    if (fd == eventLoop->maxfd && fe->mask == AE_NONE) {
        /* Update the max fd */
        int j;

        for (j = eventLoop->maxfd-1; j >= 0; j--)
            if (eventLoop->events[j].mask != AE_NONE) break;
        eventLoop->maxfd = j;
    }
}",1,20,ae.c,aeDeleteFileEvent,,false,182,202,aeDeleteFileEvent,,,8,"void aeDeleteFileEvent (aeEventLoop*,int,int)"
12443,METHOD,ae.c:<global>,TYPE_DECL,"void *aeGetFileClientData(aeEventLoop *eventLoop, int fd) {
    if (fd >= eventLoop->setsize) return NULL;
    aeFileEvent *fe = &eventLoop->events[fd];
    if (fe->mask == AE_NONE) return NULL;

    return fe->clientData;
}",1,20,ae.c,aeGetFileClientData,,false,204,210,aeGetFileClientData,,,9,"void* aeGetFileClientData (aeEventLoop*,int)"
12482,METHOD,ae.c:<global>,TYPE_DECL,"int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {
    if (fd >= eventLoop->setsize) return 0;
    aeFileEvent *fe = &eventLoop->events[fd];

    return fe->mask;
}",1,1,ae.c,aeGetFileEvents,,false,212,217,aeGetFileEvents,,,10,"int aeGetFileEvents (aeEventLoop*,int)"
12510,METHOD,ae.c:<global>,TYPE_DECL,"long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
        aeTimeProc *proc, void *clientData,
        aeEventFinalizerProc *finalizerProc)
{
    long long id = eventLoop->timeEventNextId++;
    aeTimeEvent *te;

    te = zmalloc(sizeof(*te));
    if (te == NULL) return AE_ERR;
    te->id = id;
    te->when = getMonotonicUs() + milliseconds * 1000;
    te->timeProc = proc;
    te->finalizerProc = finalizerProc;
    te->clientData = clientData;
    te->prev = NULL;
    te->next = eventLoop->timeEventHead;
    te->refcount = 0;
    if (te->next)
        te->next->prev = te;
    eventLoop->timeEventHead = te;
    return id;
}",1,27,ae.c,aeCreateTimeEvent,,false,219,240,aeCreateTimeEvent,,,11,"long long aeCreateTimeEvent (aeEventLoop*,long long,aeTimeProc*,void*,aeEventFinalizerProc*)"
12608,METHOD,ae.c:<global>,TYPE_DECL,"int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)
{
    aeTimeEvent *te = eventLoop->timeEventHead;
    while(te) {
        if (te->id == id) {
            te->id = AE_DELETED_EVENT_ID;
            return AE_OK;
        }
        te = te->next;
    }
    return AE_ERR; /* NO event with the specified ID found */
}",1,21,ae.c,aeDeleteTimeEvent,,false,242,253,aeDeleteTimeEvent,,,12,"int aeDeleteTimeEvent (aeEventLoop*,long long)"
12652,METHOD,ae.c:<global>,TYPE_DECL,"static int64_t usUntilEarliestTimer(aeEventLoop *eventLoop) {
    aeTimeEvent *te = eventLoop->timeEventHead;
    if (te == NULL) return -1;

    aeTimeEvent *earliest = NULL;
    while (te) {
        if ((!earliest || te->when < earliest->when) && te->id != AE_DELETED_EVENT_ID)
            earliest = te;
        te = te->next;
    }

    monotime now = getMonotonicUs();
    return (now >= earliest->when) ? 0 : earliest->when - now;
}",1,66,ae.c,usUntilEarliestTimer,,false,264,277,usUntilEarliestTimer,,,13,int64_t usUntilEarliestTimer (aeEventLoop*)
12724,METHOD,ae.c:<global>,TYPE_DECL,"static int processTimeEvents(aeEventLoop *eventLoop) {
    int processed = 0;
    aeTimeEvent *te;
    long long maxId;

    te = eventLoop->timeEventHead;
    maxId = eventLoop->timeEventNextId-1;
    monotime now = getMonotonicUs();
    while(te) {
        long long id;

        /* Remove events scheduled for deletion. */
        if (te->id == AE_DELETED_EVENT_ID) {
            aeTimeEvent *next = te->next;
            /* If a reference exists for this timer event,
             * don't free it. This is currently incremented
             * for recursive timerProc calls */
            if (te->refcount) {
                te = next;
                continue;
            }
            if (te->prev)
                te->prev->next = te->next;
            else
                eventLoop->timeEventHead = te->next;
            if (te->next)
                te->next->prev = te->prev;
            if (te->finalizerProc) {
                te->finalizerProc(eventLoop, te->clientData);
           ...",1,22,ae.c,processTimeEvents,,false,280,344,processTimeEvents,,,14,int processTimeEvents (aeEventLoop*)
12923,METHOD,ae.c:<global>,TYPE_DECL,"int aeProcessEvents(aeEventLoop *eventLoop, int flags)
{
    int processed = 0, numevents;

    /* Nothing to do? return ASAP */
    if (!(flags & AE_TIME_EVENTS) && !(flags & AE_FILE_EVENTS)) return 0;

    /* Note that we want to call aeApiPoll() even if there are no
     * file events to process as long as we want to process time
     * events, in order to sleep until the next time event is ready
     * to fire. */
    if (eventLoop->maxfd != -1 ||
        ((flags & AE_TIME_EVENTS) && !(flags & AE_DONT_WAIT))) {
        int j;
        struct timeval tv, *tvp = NULL; /* NULL means infinite wait. */
        int64_t usUntilTimer;

        if (eventLoop->beforesleep != NULL && (flags & AE_CALL_BEFORE_SLEEP))
            eventLoop->beforesleep(eventLoop);

        /* The eventLoop->flags may be changed inside beforesleep.
         * So we should check it after beforesleep be called. At the same time,
         * the parameter flags always should have the highest priority.
         * Th...",1,18,ae.c,aeProcessEvents,,false,361,469,aeProcessEvents,,,15,"int aeProcessEvents (aeEventLoop*,int)"
13300,METHOD,ae.c:<global>,TYPE_DECL,"int aeWait(int fd, int mask, long long milliseconds) {
    struct pollfd pfd;
    int retmask = 0, retval;

    memset(&pfd, 0, sizeof(pfd));
    pfd.fd = fd;
    if (mask & AE_READABLE) pfd.events |= POLLIN;
    if (mask & AE_WRITABLE) pfd.events |= POLLOUT;

    if ((retval = poll(&pfd, 1, milliseconds))== 1) {
        if (pfd.revents & POLLIN) retmask |= AE_READABLE;
        if (pfd.revents & POLLOUT) retmask |= AE_WRITABLE;
        if (pfd.revents & POLLERR) retmask |= AE_WRITABLE;
        if (pfd.revents & POLLHUP) retmask |= AE_WRITABLE;
        return retmask;
    } else {
        return retval;
    }
}",1,15,ae.c,aeWait,,false,473,491,aeWait,,,16,"int aeWait (int,int,long long)"
13413,METHOD,ae.c:<global>,TYPE_DECL,"void aeMain(aeEventLoop *eventLoop) {
    eventLoop->stop = 0;
    while (!eventLoop->stop) {
        aeProcessEvents(eventLoop, AE_ALL_EVENTS|
                                   AE_CALL_BEFORE_SLEEP|
                                   AE_CALL_AFTER_SLEEP);
    }
}",1,35,ae.c,aeMain,,false,493,500,aeMain,,,17,void aeMain (aeEventLoop*)
13452,METHOD,ae.c:<global>,TYPE_DECL,"char *aeGetApiName(void) {
    return aeApiName();
}",1,1,ae.c,aeGetApiName,,false,502,504,aeGetApiName,,,18,char* aeGetApiName (void)
13459,METHOD,ae.c:<global>,TYPE_DECL,"void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {
    eventLoop->beforesleep = beforesleep;
}",1,1,ae.c,aeSetBeforeSleepProc,,false,506,508,aeSetBeforeSleepProc,,,19,"void aeSetBeforeSleepProc (aeEventLoop*,aeBeforeSleepProc*)"
13470,METHOD,ae.c:<global>,TYPE_DECL,"void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep) {
    eventLoop->aftersleep = aftersleep;
}",1,1,ae.c,aeSetAfterSleepProc,,false,510,512,aeSetAfterSleepProc,,,20,"void aeSetAfterSleepProc (aeEventLoop*,aeBeforeSleepProc*)"
13486,METHOD,ae.h:<global>,TYPE_DECL,<global>,1,1,ae.h,ae.h:<global>,,false,1,136,<global>,,,1,
13489,METHOD,ae.h:<global>,TYPE_DECL,"typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);",14,90,ae.h,aeFileProc,,false,66,66,aeFileProc,,,2,"void aeFileProc (aeEventLoop*,int,void*,int)"
13497,METHOD,ae.h:<global>,TYPE_DECL,"typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);",13,85,ae.h,aeTimeProc,,false,67,67,aeTimeProc,,,3,"int aeTimeProc (aeEventLoop*,long long,void*)"
13504,METHOD,ae.h:<global>,TYPE_DECL,"typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);",14,82,ae.h,aeEventFinalizerProc,,false,68,68,aeEventFinalizerProc,,,4,"void aeEventFinalizerProc (aeEventLoop*,void*)"
13510,METHOD,ae.h:<global>,TYPE_DECL,typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);,14,61,ae.h,aeBeforeSleepProc,,false,69,69,aeBeforeSleepProc,,,5,void aeBeforeSleepProc (aeEventLoop*)
13550,METHOD,ae.h:<global>,TYPE_DECL,aeEventLoop *aeCreateEventLoop(int setsize);,13,43,ae.h,aeCreateEventLoop,,false,114,114,aeCreateEventLoop,,,14,aeEventLoop* aeCreateEventLoop (int)
13555,METHOD,ae.h:<global>,TYPE_DECL,void aeDeleteEventLoop(aeEventLoop *eventLoop);,6,46,ae.h,aeDeleteEventLoop,,false,115,115,aeDeleteEventLoop,,,15,void aeDeleteEventLoop (aeEventLoop*)
13560,METHOD,ae.h:<global>,TYPE_DECL,void aeStop(aeEventLoop *eventLoop);,6,35,ae.h,aeStop,,false,116,116,aeStop,,,16,void aeStop (aeEventLoop*)
13565,METHOD,ae.h:<global>,TYPE_DECL,"int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,
        aeFileProc *proc, void *clientData);",5,43,ae.h,aeCreateFileEvent,,false,117,118,aeCreateFileEvent,,,17,"int aeCreateFileEvent (aeEventLoop*,int,int,aeFileProc*,void*)"
13574,METHOD,ae.h:<global>,TYPE_DECL,"void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);",6,64,ae.h,aeDeleteFileEvent,,false,119,119,aeDeleteFileEvent,,,18,"void aeDeleteFileEvent (aeEventLoop*,int,int)"
13581,METHOD,ae.h:<global>,TYPE_DECL,"int aeGetFileEvents(aeEventLoop *eventLoop, int fd);",5,51,ae.h,aeGetFileEvents,,false,120,120,aeGetFileEvents,,,19,"int aeGetFileEvents (aeEventLoop*,int)"
13587,METHOD,ae.h:<global>,TYPE_DECL,"void *aeGetFileClientData(aeEventLoop *eventLoop, int fd);",6,57,ae.h,aeGetFileClientData,,false,121,121,aeGetFileClientData,,,20,"void* aeGetFileClientData (aeEventLoop*,int)"
13593,METHOD,ae.h:<global>,TYPE_DECL,"long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,
        aeTimeProc *proc, void *clientData,
        aeEventFinalizerProc *finalizerProc);",11,44,ae.h,aeCreateTimeEvent,,false,122,124,aeCreateTimeEvent,,,21,"long long aeCreateTimeEvent (aeEventLoop*,long long,aeTimeProc*,void*,aeEventFinalizerProc*)"
13602,METHOD,ae.h:<global>,TYPE_DECL,"int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);",5,59,ae.h,aeDeleteTimeEvent,,false,125,125,aeDeleteTimeEvent,,,22,"int aeDeleteTimeEvent (aeEventLoop*,long long)"
13608,METHOD,ae.h:<global>,TYPE_DECL,"int aeProcessEvents(aeEventLoop *eventLoop, int flags);",5,54,ae.h,aeProcessEvents,,false,126,126,aeProcessEvents,,,23,"int aeProcessEvents (aeEventLoop*,int)"
13614,METHOD,ae.h:<global>,TYPE_DECL,"int aeWait(int fd, int mask, long long milliseconds);",5,52,ae.h,aeWait,,false,127,127,aeWait,,,24,"int aeWait (int,int,long long)"
13621,METHOD,ae.h:<global>,TYPE_DECL,void aeMain(aeEventLoop *eventLoop);,6,35,ae.h,aeMain,,false,128,128,aeMain,,,25,void aeMain (aeEventLoop*)
13626,METHOD,ae.h:<global>,TYPE_DECL,char *aeGetApiName(void);,6,24,ae.h,aeGetApiName,,false,129,129,aeGetApiName,,,26,char* aeGetApiName (void)
13631,METHOD,ae.h:<global>,TYPE_DECL,"void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);",6,81,ae.h,aeSetBeforeSleepProc,,false,130,130,aeSetBeforeSleepProc,,,27,"void aeSetBeforeSleepProc (aeEventLoop*,aeBeforeSleepProc*)"
13637,METHOD,ae.h:<global>,TYPE_DECL,"void aeSetAfterSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *aftersleep);",6,79,ae.h,aeSetAfterSleepProc,,false,131,131,aeSetAfterSleepProc,,,28,"void aeSetAfterSleepProc (aeEventLoop*,aeBeforeSleepProc*)"
13643,METHOD,ae.h:<global>,TYPE_DECL,int aeGetSetSize(aeEventLoop *eventLoop);,5,40,ae.h,aeGetSetSize,,false,132,132,aeGetSetSize,,,29,int aeGetSetSize (aeEventLoop*)
13648,METHOD,ae.h:<global>,TYPE_DECL,"int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);",5,56,ae.h,aeResizeSetSize,,false,133,133,aeResizeSetSize,,,30,"int aeResizeSetSize (aeEventLoop*,int)"
13654,METHOD,ae.h:<global>,TYPE_DECL,"void aeSetDontWait(aeEventLoop *eventLoop, int noWait);",6,54,ae.h,aeSetDontWait,,false,134,134,aeSetDontWait,,,31,"void aeSetDontWait (aeEventLoop*,int)"
13665,METHOD,ae_epoll.c:<global>,TYPE_DECL,<global>,1,1,ae_epoll.c,ae_epoll.c:<global>,,false,1,139,<global>,,,1,
13672,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static int aeApiCreate(aeEventLoop *eventLoop) {
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    state->events = zmalloc(sizeof(struct epoll_event)*eventLoop->setsize);
    if (!state->events) {
        zfree(state);
        return -1;
    }
    state->epfd = epoll_create(1024); /* 1024 is just a hint for the kernel */
    if (state->epfd == -1) {
        zfree(state->events);
        zfree(state);
        return -1;
    }
    anetCloexec(state->epfd);
    eventLoop->apidata = state;
    return 0;
}",1,1,ae_epoll.c,aeApiCreate,,false,39,57,aeApiCreate,,,3,int aeApiCreate (aeEventLoop*)
13746,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
    aeApiState *state = eventLoop->apidata;

    state->events = zrealloc(state->events, sizeof(struct epoll_event)*setsize);
    return 0;
}",1,1,ae_epoll.c,aeApiResize,,false,59,64,aeApiResize,,,4,"int aeApiResize (aeEventLoop*,int)"
13772,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static void aeApiFree(aeEventLoop *eventLoop) {
    aeApiState *state = eventLoop->apidata;

    close(state->epfd);
    zfree(state->events);
    zfree(state);
}",1,1,ae_epoll.c,aeApiFree,,false,66,72,aeApiFree,,,5,void aeApiFree (aeEventLoop*)
13793,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;
    struct epoll_event ee = {0}; /* avoid valgrind warning */
    /* If the fd was already monitored for some event, we need a MOD
     * operation. Otherwise we need an ADD operation. */
    int op = eventLoop->events[fd].mask == AE_NONE ?
            EPOLL_CTL_ADD : EPOLL_CTL_MOD;

    ee.events = 0;
    mask |= eventLoop->events[fd].mask; /* Merge old events */
    if (mask & AE_READABLE) ee.events |= EPOLLIN;
    if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
    ee.data.fd = fd;
    if (epoll_ctl(state->epfd,op,fd,&ee) == -1) return -1;
    return 0;
}",1,1,ae_epoll.c,aeApiAddEvent,,false,74,89,aeApiAddEvent,,,6,"int aeApiAddEvent (aeEventLoop*,int,int)"
13885,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {
    aeApiState *state = eventLoop->apidata;
    struct epoll_event ee = {0}; /* avoid valgrind warning */
    int mask = eventLoop->events[fd].mask & (~delmask);

    ee.events = 0;
    if (mask & AE_READABLE) ee.events |= EPOLLIN;
    if (mask & AE_WRITABLE) ee.events |= EPOLLOUT;
    ee.data.fd = fd;
    if (mask != AE_NONE) {
        epoll_ctl(state->epfd,EPOLL_CTL_MOD,fd,&ee);
    } else {
        /* Note, Kernel < 2.6.9 requires a non null event pointer even for
         * EPOLL_CTL_DEL. */
        epoll_ctl(state->epfd,EPOLL_CTL_DEL,fd,&ee);
    }
}",1,1,ae_epoll.c,aeApiDelEvent,,false,91,107,aeApiDelEvent,,,7,"void aeApiDelEvent (aeEventLoop*,int,int)"
13971,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
    aeApiState *state = eventLoop->apidata;
    int retval, numevents = 0;

    retval = epoll_wait(state->epfd,state->events,eventLoop->setsize,
            tvp ? (tvp->tv_sec*1000 + (tvp->tv_usec + 999)/1000) : -1);
    if (retval > 0) {
        int j;

        numevents = retval;
        for (j = 0; j < numevents; j++) {
            int mask = 0;
            struct epoll_event *e = state->events+j;

            if (e->events & EPOLLIN) mask |= AE_READABLE;
            if (e->events & EPOLLOUT) mask |= AE_WRITABLE;
            if (e->events & EPOLLERR) mask |= AE_WRITABLE|AE_READABLE;
            if (e->events & EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE;
            eventLoop->fired[j].fd = e->data.fd;
            eventLoop->fired[j].mask = mask;
        }
    } else if (retval == -1 && errno != EINTR) {
        panic(""aeApiPoll: epoll_wait, %s"", strerror(errno));
    }

    return numevents;
}",1,1,ae_epoll.c,aeApiPoll,,false,109,135,aeApiPoll,,,8,"int aeApiPoll (aeEventLoop*,timeval*)"
14133,METHOD,ae_epoll.c:<global>,TYPE_DECL,"static char *aeApiName(void) {
    return ""epoll"";
}",1,1,ae_epoll.c,aeApiName,,false,137,139,aeApiName,,,9,char* aeApiName (void)
14155,METHOD,ae_evport.c:<global>,TYPE_DECL,<global>,1,24,ae_evport.c,ae_evport.c:<global>,,false,1,321,<global>,,,1,
14166,METHOD,<empty>,<empty>,<empty>,1,,ae_evport.c,aeApiState:<clinit>,,false,67,,<clinit>,,,5,
14179,METHOD,ae_evport.c:<global>,TYPE_DECL,"static int aeApiCreate(aeEventLoop *eventLoop) {
    int i;
    aeApiState *state = zmalloc(sizeof(aeApiState));
    if (!state) return -1;

    state->portfd = port_create();
    if (state->portfd == -1) {
        zfree(state);
        return -1;
    }
    anetCloexec(state->portfd);

    state->npending = 0;

    for (i = 0; i < MAX_EVENT_BATCHSZ; i++) {
        state->pending_fds[i] = -1;
        state->pending_masks[i] = AE_NONE;
    }

    eventLoop->apidata = state;
    return 0;
}",1,20,ae_evport.c,aeApiCreate,,false,74,95,aeApiCreate,,,5,int aeApiCreate (aeEventLoop*)
14260,METHOD,ae_evport.c:<global>,TYPE_DECL,"static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
    (void) eventLoop;
    (void) setsize;
    /* Nothing to resize here. */
    return 0;
}",1,1,ae_evport.c,aeApiResize,,false,97,102,aeApiResize,,,6,"int aeApiResize (aeEventLoop*,int)"
14274,METHOD,ae_evport.c:<global>,TYPE_DECL,"static void aeApiFree(aeEventLoop *eventLoop) {
    aeApiState *state = eventLoop->apidata;

    close(state->portfd);
    zfree(state);
}",1,1,ae_evport.c,aeApiFree,,false,104,109,aeApiFree,,,7,void aeApiFree (aeEventLoop*)
14291,METHOD,ae_evport.c:<global>,TYPE_DECL,"static int aeApiLookupPending(aeApiState *state, int fd) {
    uint_t i;

    for (i = 0; i < state->npending; i++) {
        if (state->pending_fds[i] == fd)
            return (i);
    }

    return (-1);
}",1,1,ae_evport.c,aeApiLookupPending,,false,111,120,aeApiLookupPending,,,8,"int aeApiLookupPending (aeApiState*,int)"
14325,METHOD,ae_evport.c:<global>,TYPE_DECL,"static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {
    int events = 0;
    int rv, err;

    if (mask & AE_READABLE)
        events |= POLLIN;
    if (mask & AE_WRITABLE)
        events |= POLLOUT;

    if (evport_debug)
        fprintf(stderr, ""%s: port_associate(%d, 0x%x) = "", where, fd, events);

    rv = port_associate(portfd, PORT_SOURCE_FD, fd, events,
        (void *)(uintptr_t)mask);
    err = errno;

    if (evport_debug)
        fprintf(stderr, ""%d (%s)\n"", rv, rv == 0 ? ""no error"" : strerror(err));

    if (rv == -1) {
        fprintf(stderr, ""%s: port_associate: %s\n"", where, strerror(err));

        if (err == EAGAIN)
            fprintf(stderr, ""aeApiAssociate: event port limit exceeded."");
    }

    return rv;
}",1,1,ae_evport.c,aeApiAssociate,,false,125,152,aeApiAssociate,,,9,"int aeApiAssociate (char*,int,int,int)"
14415,METHOD,ae_evport.c:<global>,TYPE_DECL,"static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;
    int fullmask, pfd;

    if (evport_debug)
        fprintf(stderr, ""aeApiAddEvent: fd %d mask 0x%x\n"", fd, mask);

    /*
     * Since port_associate's ""events"" argument replaces any existing events, we
     * must be sure to include whatever events are already associated when
     * we call port_associate() again.
     */
    fullmask = mask | eventLoop->events[fd].mask;
    pfd = aeApiLookupPending(state, fd);

    if (pfd != -1) {
        /*
         * This fd was recently returned from aeApiPoll.  It should be safe to
         * assume that the consumer has processed that poll event, but we play
         * it safer by simply updating pending_mask.  The fd will be
         * re-associated as usual when aeApiPoll is called again.
         */
        if (evport_debug)
            fprintf(stderr, ""aeApiAddEvent: adding to pending fd %d\n"", fd);
        state->pending_m...",1,1,ae_evport.c,aeApiAddEvent,,false,154,183,aeApiAddEvent,,,10,"int aeApiAddEvent (aeEventLoop*,int,int)"
14484,METHOD,ae_evport.c:<global>,TYPE_DECL,"static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;
    int fullmask, pfd;

    if (evport_debug)
        fprintf(stderr, ""del fd %d mask 0x%x\n"", fd, mask);

    pfd = aeApiLookupPending(state, fd);

    if (pfd != -1) {
        if (evport_debug)
            fprintf(stderr, ""deleting event from pending fd %d\n"", fd);

        /*
         * This fd was just returned from aeApiPoll, so it's not currently
         * associated with the port.  All we need to do is update
         * pending_mask appropriately.
         */
        state->pending_masks[pfd] &= ~mask;

        if (state->pending_masks[pfd] == AE_NONE)
            state->pending_fds[pfd] = -1;

        return;
    }

    /*
     * The fd is currently associated with the port.  Like with the add case
     * above, we must look at the full mask for the file descriptor before
     * updating that association.  We don't have a good way of knowing what the
     * even...",1,1,ae_evport.c,aeApiDelEvent,,false,185,243,aeApiDelEvent,,,11,"void aeApiDelEvent (aeEventLoop*,int,int)"
14599,METHOD,ae_evport.c:<global>,TYPE_DECL,"static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
    aeApiState *state = eventLoop->apidata;
    struct timespec timeout, *tsp;
    uint_t mask, i;
    uint_t nevents;
    port_event_t event[MAX_EVENT_BATCHSZ];

    /*
     * If we've returned fd events before, we must re-associate them with the
     * port now, before calling port_get().  See the block comment at the top of
     * this file for an explanation of why.
     */
    for (i = 0; i < state->npending; i++) {
        if (state->pending_fds[i] == -1)
            /* This fd has since been deleted. */
            continue;

        if (aeApiAssociate(""aeApiPoll"", state->portfd,
            state->pending_fds[i], state->pending_masks[i]) != 0) {
            /* See aeApiDelEvent for why this case is fatal. */
            abort();
        }

        state->pending_masks[i] = AE_NONE;
        state->pending_fds[i] = -1;
    }

    state->npending = 0;

    if (tvp != NULL) {
        timeout.tv_sec = tvp->tv_sec...",1,23,ae_evport.c,aeApiPoll,,false,245,317,aeApiPoll,,,12,"int aeApiPoll (aeEventLoop*,timeval*)"
14858,METHOD,ae_evport.c:<global>,TYPE_DECL,"static char *aeApiName(void) {
    return ""evport"";
}",1,1,ae_evport.c,aeApiName,,false,319,321,aeApiName,,,13,char* aeApiName (void)
14874,METHOD,ae_kqueue.c:<global>,TYPE_DECL,<global>,1,32,ae_kqueue.c,ae_kqueue.c:<global>,,false,1,190,<global>,,,1,
14882,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static inline int getEventMask(const char *eventsMask, int fd) {
    return (eventsMask[fd/4] >> EVENT_MASK_OFFSET(fd)) & 0x3;
}",1,32,ae_kqueue.c,getEventMask,,false,50,52,getEventMask,,,3,"int getEventMask (char*,int)"
14905,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static inline void addEventMask(char *eventsMask, int fd, int mask) {
    eventsMask[fd/4] |= EVENT_MASK_ENCODE(fd, mask);
}",1,24,ae_kqueue.c,addEventMask,,false,54,56,addEventMask,,,4,"void addEventMask (char*,int,int)"
14931,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static inline void resetEventMask(char *eventsMask, int fd) {
    eventsMask[fd/4] &= ~EVENT_MASK_ENCODE(fd, 0x3);
}",1,25,ae_kqueue.c,resetEventMask,,false,58,60,resetEventMask,,,5,"void resetEventMask (char*,int)"
14957,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static int aeApiCreate(aeEventLoop *eventLoop) {
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    state->events = zmalloc(sizeof(struct kevent)*eventLoop->setsize);
    if (!state->events) {
        zfree(state);
        return -1;
    }
    state->kqfd = kqueue();
    if (state->kqfd == -1) {
        zfree(state->events);
        zfree(state);
        return -1;
    }
    anetCloexec(state->kqfd);
    state->eventsMask = zmalloc(EVENT_MASK_MALLOC_SIZE(eventLoop->setsize));
    memset(state->eventsMask, 0, EVENT_MASK_MALLOC_SIZE(eventLoop->setsize));
    eventLoop->apidata = state;
    return 0;
}",1,32,ae_kqueue.c,aeApiCreate,,false,62,82,aeApiCreate,,,6,int aeApiCreate (aeEventLoop*)
15064,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
    aeApiState *state = eventLoop->apidata;

    state->events = zrealloc(state->events, sizeof(struct kevent)*setsize);
    state->eventsMask = zrealloc(state->eventsMask, EVENT_MASK_MALLOC_SIZE(setsize));
    memset(state->eventsMask, 0, EVENT_MASK_MALLOC_SIZE(setsize));
    return 0;
}",1,52,ae_kqueue.c,aeApiResize,,false,84,91,aeApiResize,,,7,"int aeApiResize (aeEventLoop*,int)"
15119,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static void aeApiFree(aeEventLoop *eventLoop) {
    aeApiState *state = eventLoop->apidata;

    close(state->kqfd);
    zfree(state->events);
    zfree(state->eventsMask);
    zfree(state);
}",1,1,ae_kqueue.c,aeApiFree,,false,93,100,aeApiFree,,,8,void aeApiFree (aeEventLoop*)
15144,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;
    struct kevent ke;

    if (mask & AE_READABLE) {
        EV_SET(&ke, fd, EVFILT_READ, EV_ADD, 0, 0, NULL);
        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
    }
    if (mask & AE_WRITABLE) {
        EV_SET(&ke, fd, EVFILT_WRITE, EV_ADD, 0, 0, NULL);
        if (kevent(state->kqfd, &ke, 1, NULL, 0, NULL) == -1) return -1;
    }
    return 0;
}",1,1,ae_kqueue.c,aeApiAddEvent,,false,102,115,aeApiAddEvent,,,9,"int aeApiAddEvent (aeEventLoop*,int,int)"
15224,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;
    struct kevent ke;

    if (mask & AE_READABLE) {
        EV_SET(&ke, fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);
        kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
    }
    if (mask & AE_WRITABLE) {
        EV_SET(&ke, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
        kevent(state->kqfd, &ke, 1, NULL, 0, NULL);
    }
}",1,1,ae_kqueue.c,aeApiDelEvent,,false,117,129,aeApiDelEvent,,,10,"void aeApiDelEvent (aeEventLoop*,int,int)"
15286,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
    aeApiState *state = eventLoop->apidata;
    int retval, numevents = 0;

    if (tvp != NULL) {
        struct timespec timeout;
        timeout.tv_sec = tvp->tv_sec;
        timeout.tv_nsec = tvp->tv_usec * 1000;
        retval = kevent(state->kqfd, NULL, 0, state->events, eventLoop->setsize,
                        &timeout);
    } else {
        retval = kevent(state->kqfd, NULL, 0, state->events, eventLoop->setsize,
                        NULL);
    }

    if (retval > 0) {
        int j;

        /* Normally we execute the read event first and then the write event.
         * When the barrier is set, we will do it reverse.
         * 
         * However, under kqueue, read and write events would be separate
         * events, which would make it impossible to control the order of
         * reads and writes. So we store the event's mask we've got and merge
         * the same fd events later. */
        for...",1,1,ae_kqueue.c,aeApiPoll,,false,131,186,aeApiPoll,,,11,"int aeApiPoll (aeEventLoop*,timeval*)"
15503,METHOD,ae_kqueue.c:<global>,TYPE_DECL,"static char *aeApiName(void) {
    return ""kqueue"";
}",1,1,ae_kqueue.c,aeApiName,,false,188,190,aeApiName,,,12,char* aeApiName (void)
15517,METHOD,ae_select.c:<global>,TYPE_DECL,<global>,1,1,ae_select.c,ae_select.c:<global>,,false,1,110,<global>,,,1,
15525,METHOD,ae_select.c:<global>,TYPE_DECL,"static int aeApiCreate(aeEventLoop *eventLoop) {
    aeApiState *state = zmalloc(sizeof(aeApiState));

    if (!state) return -1;
    FD_ZERO(&state->rfds);
    FD_ZERO(&state->wfds);
    eventLoop->apidata = state;
    return 0;
}",1,1,ae_select.c,aeApiCreate,,false,42,50,aeApiCreate,,,3,int aeApiCreate (aeEventLoop*)
15560,METHOD,ae_select.c:<global>,TYPE_DECL,"static int aeApiResize(aeEventLoop *eventLoop, int setsize) {
    AE_NOTUSED(eventLoop);
    /* Just ensure we have enough room in the fd_set type. */
    if (setsize >= FD_SETSIZE) return -1;
    return 0;
}",1,1,ae_select.c,aeApiResize,,false,52,57,aeApiResize,,,4,"int aeApiResize (aeEventLoop*,int)"
15578,METHOD,ae_select.c:<global>,TYPE_DECL,"static void aeApiFree(aeEventLoop *eventLoop) {
    zfree(eventLoop->apidata);
}",1,1,ae_select.c,aeApiFree,,false,59,61,aeApiFree,,,5,void aeApiFree (aeEventLoop*)
15587,METHOD,ae_select.c:<global>,TYPE_DECL,"static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;

    if (mask & AE_READABLE) FD_SET(fd,&state->rfds);
    if (mask & AE_WRITABLE) FD_SET(fd,&state->wfds);
    return 0;
}",1,1,ae_select.c,aeApiAddEvent,,false,63,69,aeApiAddEvent,,,6,"int aeApiAddEvent (aeEventLoop*,int,int)"
15624,METHOD,ae_select.c:<global>,TYPE_DECL,"static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {
    aeApiState *state = eventLoop->apidata;

    if (mask & AE_READABLE) FD_CLR(fd,&state->rfds);
    if (mask & AE_WRITABLE) FD_CLR(fd,&state->wfds);
}",1,1,ae_select.c,aeApiDelEvent,,false,71,76,aeApiDelEvent,,,7,"void aeApiDelEvent (aeEventLoop*,int,int)"
15659,METHOD,ae_select.c:<global>,TYPE_DECL,"static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
    aeApiState *state = eventLoop->apidata;
    int retval, j, numevents = 0;

    memcpy(&state->_rfds,&state->rfds,sizeof(fd_set));
    memcpy(&state->_wfds,&state->wfds,sizeof(fd_set));

    retval = select(eventLoop->maxfd+1,
                &state->_rfds,&state->_wfds,NULL,tvp);
    if (retval > 0) {
        for (j = 0; j <= eventLoop->maxfd; j++) {
            int mask = 0;
            aeFileEvent *fe = &eventLoop->events[j];

            if (fe->mask == AE_NONE) continue;
            if (fe->mask & AE_READABLE && FD_ISSET(j,&state->_rfds))
                mask |= AE_READABLE;
            if (fe->mask & AE_WRITABLE && FD_ISSET(j,&state->_wfds))
                mask |= AE_WRITABLE;
            eventLoop->fired[numevents].fd = j;
            eventLoop->fired[numevents].mask = mask;
            numevents++;
        }
    } else if (retval == -1 && errno != EINTR) {
        panic(""aeApiPoll: select, %s"", strerror(...",1,1,ae_select.c,aeApiPoll,,false,78,106,aeApiPoll,,,8,"int aeApiPoll (aeEventLoop*,timeval*)"
15828,METHOD,ae_select.c:<global>,TYPE_DECL,"static char *aeApiName(void) {
    return ""select"";
}",1,1,ae_select.c,aeApiName,,false,108,110,aeApiName,,,9,char* aeApiName (void)
15876,METHOD,anet.c:<global>,TYPE_DECL,<global>,1,1,anet.c,anet.c:<global>,,false,1,705,<global>,,,1,
15878,METHOD,anet.c:<global>,TYPE_DECL,"static void anetSetError(char *err, const char *fmt, ...)
{
    va_list ap;

    if (!err) return;
    va_start(ap, fmt);
    vsnprintf(err, ANET_ERR_LEN, fmt, ap);
    va_end(ap);
}",1,19,anet.c,anetSetError,,false,55,63,anetSetError,,,1,"void anetSetError (char*,char*...)"
15902,METHOD,anet.c:<global>,TYPE_DECL,"int anetGetError(int fd) {
    int sockerr = 0;
    socklen_t errlen = sizeof(sockerr);

    if (getsockopt(fd, SOL_SOCKET, SO_ERROR, &sockerr, &errlen) == -1)
        sockerr = errno;
    return sockerr;
}",1,1,anet.c,anetGetError,,false,65,72,anetGetError,,,2,int anetGetError (int)
15934,METHOD,anet.c:<global>,TYPE_DECL,"int anetSetBlock(char *err, int fd, int non_block) {
    int flags;

    /* Set the socket blocking (if non_block is zero) or non-blocking.
     * Note that fcntl(2) for F_GETFL and F_SETFL can't be
     * interrupted by a signal. */
    if ((flags = fcntl(fd, F_GETFL)) == -1) {
        anetSetError(err, ""fcntl(F_GETFL): %s"", strerror(errno));
        return ANET_ERR;
    }

    /* Check if this flag has been set or unset, if so, 
     * then there is no need to call fcntl to set/unset it again. */
    if (!!(flags & O_NONBLOCK) == !!non_block)
        return ANET_OK;

    if (non_block)
        flags |= O_NONBLOCK;
    else
        flags &= ~O_NONBLOCK;

    if (fcntl(fd, F_SETFL, flags) == -1) {
        anetSetError(err, ""fcntl(F_SETFL,O_NONBLOCK): %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetSetBlock,,false,74,100,anetSetBlock,,,3,"int anetSetBlock (char*,int,int)"
16012,METHOD,anet.c:<global>,TYPE_DECL,"int anetNonBlock(char *err, int fd) {
    return anetSetBlock(err,fd,1);
}",1,1,anet.c,anetNonBlock,,false,102,104,anetNonBlock,,,4,"int anetNonBlock (char*,int)"
16023,METHOD,anet.c:<global>,TYPE_DECL,"int anetBlock(char *err, int fd) {
    return anetSetBlock(err,fd,0);
}",1,1,anet.c,anetBlock,,false,106,108,anetBlock,,,5,"int anetBlock (char*,int)"
16034,METHOD,anet.c:<global>,TYPE_DECL,"int anetCloexec(int fd) {
    int r;
    int flags;

    do {
        r = fcntl(fd, F_GETFD);
    } while (r == -1 && errno == EINTR);

    if (r == -1 || (r & FD_CLOEXEC))
        return r;

    flags = r | FD_CLOEXEC;

    do {
        r = fcntl(fd, F_SETFD, flags);
    } while (r == -1 && errno == EINTR);

    return r;
}",1,1,anet.c,anetCloexec,,false,113,131,anetCloexec,,,6,int anetCloexec (int)
16091,METHOD,anet.c:<global>,TYPE_DECL,"int anetKeepAlive(char *err, int fd, int interval)
{
    int val = 1;

    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &val, sizeof(val)) == -1)
    {
        anetSetError(err, ""setsockopt SO_KEEPALIVE: %s"", strerror(errno));
        return ANET_ERR;
    }

#ifdef __linux__
    /* Default settings are more or less garbage, with the keepalive time
     * set to 7200 by default on Linux. Modify settings to make the feature
     * actually useful. */

    /* Send first probe after interval. */
    val = interval;
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &val, sizeof(val)) < 0) {
        anetSetError(err, ""setsockopt TCP_KEEPIDLE: %s\n"", strerror(errno));
        return ANET_ERR;
    }

    /* Send next probes after the specified interval. Note that we set the
     * delay as interval / 3, as we send three probes before detecting
     * an error (see the next setsockopt call). */
    val = interval/3;
    if (val == 0) val = 1;
    if (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL...",1,15,anet.c,anetKeepAlive,,false,136,187,anetKeepAlive,,,7,"int anetKeepAlive (char*,int,int)"
16132,METHOD,anet.c:<global>,TYPE_DECL,"static int anetSetTcpNoDelay(char *err, int fd, int val)
{
    if (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &val, sizeof(val)) == -1)
    {
        anetSetError(err, ""setsockopt TCP_NODELAY: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetSetTcpNoDelay,,false,189,197,anetSetTcpNoDelay,,,8,"int anetSetTcpNoDelay (char*,int,int)"
16166,METHOD,anet.c:<global>,TYPE_DECL,"int anetEnableTcpNoDelay(char *err, int fd)
{
    return anetSetTcpNoDelay(err, fd, 1);
}",1,1,anet.c,anetEnableTcpNoDelay,,false,199,202,anetEnableTcpNoDelay,,,9,"int anetEnableTcpNoDelay (char*,int)"
16177,METHOD,anet.c:<global>,TYPE_DECL,"int anetDisableTcpNoDelay(char *err, int fd)
{
    return anetSetTcpNoDelay(err, fd, 0);
}",1,1,anet.c,anetDisableTcpNoDelay,,false,204,207,anetDisableTcpNoDelay,,,10,"int anetDisableTcpNoDelay (char*,int)"
16188,METHOD,anet.c:<global>,TYPE_DECL,"int anetSendTimeout(char *err, int fd, long long ms) {
    struct timeval tv;

    tv.tv_sec = ms/1000;
    tv.tv_usec = (ms%1000)*1000;
    if (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
        anetSetError(err, ""setsockopt SO_SNDTIMEO: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetSendTimeout,,false,211,221,anetSendTimeout,,,11,"int anetSendTimeout (char*,int,long long)"
16239,METHOD,anet.c:<global>,TYPE_DECL,"int anetRecvTimeout(char *err, int fd, long long ms) {
    struct timeval tv;

    tv.tv_sec = ms/1000;
    tv.tv_usec = (ms%1000)*1000;
    if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
        anetSetError(err, ""setsockopt SO_RCVTIMEO: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetRecvTimeout,,false,225,235,anetRecvTimeout,,,12,"int anetRecvTimeout (char*,int,long long)"
16290,METHOD,anet.c:<global>,TYPE_DECL,"int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,
                       int flags)
{
    struct addrinfo hints, *info;
    int rv;

    memset(&hints,0,sizeof(hints));
    if (flags & ANET_IP_ONLY) hints.ai_flags = AI_NUMERICHOST;
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;  /* specify socktype to avoid dups */

    if ((rv = getaddrinfo(host, NULL, &hints, &info)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    if (info->ai_family == AF_INET) {
        struct sockaddr_in *sa = (struct sockaddr_in *)info->ai_addr;
        inet_ntop(AF_INET, &(sa->sin_addr), ipbuf, ipbuf_len);
    } else {
        struct sockaddr_in6 *sa = (struct sockaddr_in6 *)info->ai_addr;
        inet_ntop(AF_INET6, &(sa->sin6_addr), ipbuf, ipbuf_len);
    }

    freeaddrinfo(info);
    return ANET_OK;
}",1,16,anet.c,anetResolve,,false,243,268,anetResolve,,,13,"int anetResolve (char*,char*,char*,size_t,int)"
16402,METHOD,anet.c:<global>,TYPE_DECL,"static int anetSetReuseAddr(char *err, int fd) {
    int yes = 1;
    /* Make sure connection-intensive things like the redis benchmark
     * will be able to close/open sockets a zillion of times */
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1) {
        anetSetError(err, ""setsockopt SO_REUSEADDR: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetSetReuseAddr,,false,270,279,anetSetReuseAddr,,,14,"int anetSetReuseAddr (char*,int)"
16439,METHOD,anet.c:<global>,TYPE_DECL,"static int anetCreateSocket(char *err, int domain) {
    int s;
    if ((s = socket(domain, SOCK_STREAM, 0)) == -1) {
        anetSetError(err, ""creating socket: %s"", strerror(errno));
        return ANET_ERR;
    }

    /* Make sure connection-intensive things like the redis benchmark
     * will be able to close/open sockets a zillion of times */
    if (anetSetReuseAddr(err,s) == ANET_ERR) {
        close(s);
        return ANET_ERR;
    }
    return s;
}",1,15,anet.c,anetCreateSocket,,false,281,295,anetCreateSocket,,,15,"int anetCreateSocket (char*,int)"
16486,METHOD,anet.c:<global>,TYPE_DECL,"static int anetTcpGenericConnect(char *err, const char *addr, int port,
                                 const char *source_addr, int flags)
{
    int s = ANET_ERR, rv;
    char portstr[6];  /* strlen(""65535"") + 1; */
    struct addrinfo hints, *servinfo, *bservinfo, *p, *b;

    snprintf(portstr,sizeof(portstr),""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((rv = getaddrinfo(addr,portstr,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        /* Try to create the socket and to connect it.
         * If we fail in the socket() call, or on connect(), we retry with
         * the next entry in servinfo. */
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        if (flags & ANET_CONNECT_...",1,12,anet.c,anetTcpGenericConnect,,false,300,378,anetTcpGenericConnect,,,16,"int anetTcpGenericConnect (char*,char*,int,char*,int)"
16774,METHOD,anet.c:<global>,TYPE_DECL,"int anetTcpNonBlockConnect(char *err, const char *addr, int port)
{
    return anetTcpGenericConnect(err,addr,port,NULL,ANET_CONNECT_NONBLOCK);
}",1,52,anet.c,anetTcpNonBlockConnect,,false,380,383,anetTcpNonBlockConnect,,,17,"int anetTcpNonBlockConnect (char*,char*,int)"
16790,METHOD,anet.c:<global>,TYPE_DECL,"int anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port,
                                         const char *source_addr)
{
    return anetTcpGenericConnect(err,addr,port,source_addr,
            ANET_CONNECT_NONBLOCK|ANET_CONNECT_BE_BINDING);
}",1,12,anet.c,anetTcpNonBlockBestEffortBindConnect,,false,385,390,anetTcpNonBlockBestEffortBindConnect,,,18,"int anetTcpNonBlockBestEffortBindConnect (char*,char*,int,char*)"
16811,METHOD,anet.c:<global>,TYPE_DECL,"int anetUnixGenericConnect(char *err, const char *path, int flags)
{
    int s;
    struct sockaddr_un sa;

    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
        return ANET_ERR;

    sa.sun_family = AF_LOCAL;
    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));
    if (flags & ANET_CONNECT_NONBLOCK) {
        if (anetNonBlock(err,s) != ANET_OK) {
            close(s);
            return ANET_ERR;
        }
    }
    if (connect(s,(struct sockaddr*)&sa,sizeof(sa)) == -1) {
        if (errno == EINPROGRESS &&
            flags & ANET_CONNECT_NONBLOCK)
            return s;

        anetSetError(err, ""connect: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return s;
}",1,48,anet.c,anetUnixGenericConnect,,false,392,418,anetUnixGenericConnect,,,19,"int anetUnixGenericConnect (char*,char*,int)"
16914,METHOD,anet.c:<global>,TYPE_DECL,"static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {
    if (bind(s,sa,len) == -1) {
        anetSetError(err, ""bind: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }

    if (listen(s, backlog) == -1) {
        anetSetError(err, ""listen: %s"", strerror(errno));
        close(s);
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetListen,,false,420,433,anetListen,,,20,"int anetListen (char*,int,sockaddr*,socklen_t,int)"
16968,METHOD,anet.c:<global>,TYPE_DECL,"static int anetV6Only(char *err, int s) {
    int yes = 1;
    if (setsockopt(s,IPPROTO_IPV6,IPV6_V6ONLY,&yes,sizeof(yes)) == -1) {
        anetSetError(err, ""setsockopt: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
}",1,15,anet.c,anetV6Only,,false,435,442,anetV6Only,,,21,"int anetV6Only (char*,int)"
17005,METHOD,anet.c:<global>,TYPE_DECL,"static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)
{
    int s = -1, rv;
    char _port[6];  /* strlen(""65535"") */
    struct addrinfo hints, *servinfo, *p;

    snprintf(_port,6,""%d"",port);
    memset(&hints,0,sizeof(hints));
    hints.ai_family = af;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;    /* No effect if bindaddr != NULL */
    if (bindaddr && !strcmp(""*"", bindaddr))
        bindaddr = NULL;
    if (af == AF_INET6 && bindaddr && !strcmp(""::*"", bindaddr))
        bindaddr = NULL;

    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {
        anetSetError(err, ""%s"", gai_strerror(rv));
        return ANET_ERR;
    }
    for (p = servinfo; p != NULL; p = p->ai_next) {
        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)
            continue;

        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;
        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;
        ...",1,15,anet.c,_anetTcpServer,,false,444,484,_anetTcpServer,,,22,"int _anetTcpServer (char*,int,char*,int,int)"
17211,METHOD,anet.c:<global>,TYPE_DECL,"int anetTcpServer(char *err, int port, char *bindaddr, int backlog)
{
    return _anetTcpServer(err, port, bindaddr, AF_INET, backlog);
}",1,1,anet.c,anetTcpServer,,false,486,489,anetTcpServer,,,23,"int anetTcpServer (char*,int,char*,int)"
17226,METHOD,anet.c:<global>,TYPE_DECL,"int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)
{
    return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);
}",1,1,anet.c,anetTcp6Server,,false,491,494,anetTcp6Server,,,24,"int anetTcp6Server (char*,int,char*,int)"
17241,METHOD,anet.c:<global>,TYPE_DECL,"int anetUnixServer(char *err, char *path, mode_t perm, int backlog)
{
    int s;
    struct sockaddr_un sa;

    if (strlen(path) > sizeof(sa.sun_path)-1) {
        anetSetError(err,""unix socket path too long (%zu), must be under %zu"", strlen(path), sizeof(sa.sun_path));
        return ANET_ERR;
    }
    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)
        return ANET_ERR;

    memset(&sa,0,sizeof(sa));
    sa.sun_family = AF_LOCAL;
    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));
    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)
        return ANET_ERR;
    if (perm)
        chmod(sa.sun_path, perm);
    return s;
}",1,15,anet.c,anetUnixServer,,false,496,516,anetUnixServer,,,25,"int anetUnixServer (char*,char*,mode_t,int)"
17345,METHOD,anet.c:<global>,TYPE_DECL,"static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {
    int fd;
    do {
        /* Use the accept4() call on linux to simultaneously accept and
         * set a socket as non-blocking. */
#ifdef HAVE_ACCEPT4
        fd = accept4(s, sa, len,  SOCK_NONBLOCK | SOCK_CLOEXEC);
#else
        fd = accept(s,sa,len);
#endif
    } while(fd == -1 && errno == EINTR);
    if (fd == -1) {
        anetSetError(err, ""accept: %s"", strerror(errno));
        return ANET_ERR;
    }
#ifndef HAVE_ACCEPT4
    if (anetCloexec(fd) == -1) {
        anetSetError(err, ""anetCloexec: %s"", strerror(errno));
        close(fd);
        return ANET_ERR;
    }
    if (anetNonBlock(err, fd) != ANET_OK) {
        close(fd);
        return ANET_ERR;
    }
#endif
    return fd;
}",1,15,anet.c,anetGenericAccept,,false,520,547,anetGenericAccept,,,26,"int anetGenericAccept (char*,int,sockaddr*,socklen_t*)"
17423,METHOD,anet.c:<global>,TYPE_DECL,"int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port) {
    int fd;
    struct sockaddr_storage sa;
    socklen_t salen = sizeof(sa);
    if ((fd = anetGenericAccept(err,serversock,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
        return ANET_ERR;

    if (sa.ss_family == AF_INET) {
        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
        if (ip) inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len);
        if (port) *port = ntohs(s->sin_port);
    } else {
        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
        if (ip) inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len);
        if (port) *port = ntohs(s->sin6_port);
    }
    return fd;
}",1,81,anet.c,anetTcpAccept,,false,551,568,anetTcpAccept,,,27,"int anetTcpAccept (char*,int,char*,size_t,int*)"
17533,METHOD,anet.c:<global>,TYPE_DECL,"int anetUnixAccept(char *err, int s) {
    int fd;
    struct sockaddr_un sa;
    socklen_t salen = sizeof(sa);
    if ((fd = anetGenericAccept(err,s,(struct sockaddr*)&sa,&salen)) == ANET_ERR)
        return ANET_ERR;

    return fd;
}",1,72,anet.c,anetUnixAccept,,false,572,580,anetUnixAccept,,,28,"int anetUnixAccept (char*,int)"
17571,METHOD,anet.c:<global>,TYPE_DECL,"int anetFdToString(int fd, char *ip, size_t ip_len, int *port, int remote) {
    struct sockaddr_storage sa;
    socklen_t salen = sizeof(sa);

    if (remote) {
        if (getpeername(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;
    } else {
        if (getsockname(fd, (struct sockaddr *)&sa, &salen) == -1) goto error;
    }

    if (sa.ss_family == AF_INET) {
        struct sockaddr_in *s = (struct sockaddr_in *)&sa;
        if (ip) {
            if (inet_ntop(AF_INET,(void*)&(s->sin_addr),ip,ip_len) == NULL)
                goto error;
        }
        if (port) *port = ntohs(s->sin_port);
    } else if (sa.ss_family == AF_INET6) {
        struct sockaddr_in6 *s = (struct sockaddr_in6 *)&sa;
        if (ip) {
            if (inet_ntop(AF_INET6,(void*)&(s->sin6_addr),ip,ip_len) == NULL)
                goto error;
        }
        if (port) *port = ntohs(s->sin6_port);
    } else if (sa.ss_family == AF_UNIX) {
        if (ip) {
            int res = snprintf(ip, ip_le...",1,1,anet.c,anetFdToString,,false,582,628,anetFdToString,,,29,"int anetFdToString (int,char*,size_t,int*,int)"
17789,METHOD,anet.c:<global>,TYPE_DECL,"int anetPipe(int fds[2], int read_flags, int write_flags) {
    int pipe_flags = 0;
#if defined(__linux__) || defined(__FreeBSD__)
    /* When possible, try to leverage pipe2() to apply flags that are common to both ends.
     * There is no harm to set O_CLOEXEC to prevent fd leaks. */
    pipe_flags = O_CLOEXEC | (read_flags & write_flags);
    if (pipe2(fds, pipe_flags)) {
        /* Fail on real failures, and fallback to simple pipe if pipe2 is unsupported. */
        if (errno != ENOSYS && errno != EINVAL)
            return -1;
        pipe_flags = 0;
    } else {
        /* If the flags on both ends are identical, no need to do anything else. */
        if ((O_CLOEXEC | read_flags) == (O_CLOEXEC | write_flags))
            return 0;
        /* Clear the flags which have already been set using pipe2. */
        read_flags &= ~pipe_flags;
        write_flags &= ~pipe_flags;
    }
#endif

    /* When we reach here with pipe_flags of 0, it means pipe2 failed (or was not attempted)...",1,1,anet.c,anetPipe,,false,633,684,anetPipe,,,30,"int anetPipe (int[2],int,int)"
17885,METHOD,anet.c:<global>,TYPE_DECL,"int anetSetSockMarkId(char *err, int fd, uint32_t id) {
#ifdef HAVE_SOCKOPTMARKID
    if (setsockopt(fd, SOL_SOCKET, SOCKOPTMARKID, (void *)&id, sizeof(id)) == -1) {
        anetSetError(err, ""setsockopt: %s"", strerror(errno));
        return ANET_ERR;
    }
    return ANET_OK;
#else
    UNUSED(fd);
    UNUSED(id);
    anetSetError(err,""anetSetSockMarkid unsupported on this platform"");
    return ANET_OK;
#endif
}",1,4,anet.c,anetSetSockMarkId,,false,686,699,anetSetSockMarkId,,,31,"int anetSetSockMarkId (char*,int,uint32_t)"
17911,METHOD,anet.c:<global>,TYPE_DECL,"int anetIsFifo(char *filepath) {
    struct stat sb;
    if (stat(filepath, &sb) == -1) return 0;
    return S_ISFIFO(sb.st_mode);
}",1,1,anet.c,anetIsFifo,,false,701,705,anetIsFifo,,,32,int anetIsFifo (char*)
17938,METHOD,anet.h:<global>,TYPE_DECL,<global>,1,6,anet.h,anet.h:<global>,,false,1,75,<global>,,,1,
17940,METHOD,anet.h:<global>,TYPE_DECL,"int anetTcpNonBlockConnect(char *err, const char *addr, int port);",5,65,anet.h,anetTcpNonBlockConnect,,false,52,52,anetTcpNonBlockConnect,,,1,"int anetTcpNonBlockConnect (char*,char*,int)"
17947,METHOD,anet.h:<global>,TYPE_DECL,"int anetTcpNonBlockBestEffortBindConnect(char *err, const char *addr, int port, const char *source_addr);",5,104,anet.h,anetTcpNonBlockBestEffortBindConnect,,false,53,53,anetTcpNonBlockBestEffortBindConnect,,,2,"int anetTcpNonBlockBestEffortBindConnect (char*,char*,int,char*)"
17955,METHOD,anet.h:<global>,TYPE_DECL,"int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len, int flags);",5,80,anet.h,anetResolve,,false,54,54,anetResolve,,,3,"int anetResolve (char*,char*,char*,size_t,int)"
17964,METHOD,anet.h:<global>,TYPE_DECL,"int anetTcpServer(char *err, int port, char *bindaddr, int backlog);",5,67,anet.h,anetTcpServer,,false,55,55,anetTcpServer,,,4,"int anetTcpServer (char*,int,char*,int)"
17972,METHOD,anet.h:<global>,TYPE_DECL,"int anetTcp6Server(char *err, int port, char *bindaddr, int backlog);",5,68,anet.h,anetTcp6Server,,false,56,56,anetTcp6Server,,,5,"int anetTcp6Server (char*,int,char*,int)"
17980,METHOD,anet.h:<global>,TYPE_DECL,"int anetUnixServer(char *err, char *path, mode_t perm, int backlog);",5,67,anet.h,anetUnixServer,,false,57,57,anetUnixServer,,,6,"int anetUnixServer (char*,char*,mode_t,int)"
17988,METHOD,anet.h:<global>,TYPE_DECL,"int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port);",5,80,anet.h,anetTcpAccept,,false,58,58,anetTcpAccept,,,7,"int anetTcpAccept (char*,int,char*,size_t,int*)"
17997,METHOD,anet.h:<global>,TYPE_DECL,"int anetUnixAccept(char *err, int serversock);",5,45,anet.h,anetUnixAccept,,false,59,59,anetUnixAccept,,,8,"int anetUnixAccept (char*,int)"
18003,METHOD,anet.h:<global>,TYPE_DECL,"int anetNonBlock(char *err, int fd);",5,35,anet.h,anetNonBlock,,false,60,60,anetNonBlock,,,9,"int anetNonBlock (char*,int)"
18009,METHOD,anet.h:<global>,TYPE_DECL,"int anetBlock(char *err, int fd);",5,32,anet.h,anetBlock,,false,61,61,anetBlock,,,10,"int anetBlock (char*,int)"
18015,METHOD,anet.h:<global>,TYPE_DECL,int anetCloexec(int fd);,5,23,anet.h,anetCloexec,,false,62,62,anetCloexec,,,11,int anetCloexec (int)
18020,METHOD,anet.h:<global>,TYPE_DECL,"int anetEnableTcpNoDelay(char *err, int fd);",5,43,anet.h,anetEnableTcpNoDelay,,false,63,63,anetEnableTcpNoDelay,,,12,"int anetEnableTcpNoDelay (char*,int)"
18026,METHOD,anet.h:<global>,TYPE_DECL,"int anetDisableTcpNoDelay(char *err, int fd);",5,44,anet.h,anetDisableTcpNoDelay,,false,64,64,anetDisableTcpNoDelay,,,13,"int anetDisableTcpNoDelay (char*,int)"
18032,METHOD,anet.h:<global>,TYPE_DECL,"int anetSendTimeout(char *err, int fd, long long ms);",5,52,anet.h,anetSendTimeout,,false,65,65,anetSendTimeout,,,14,"int anetSendTimeout (char*,int,long long)"
18039,METHOD,anet.h:<global>,TYPE_DECL,"int anetRecvTimeout(char *err, int fd, long long ms);",5,52,anet.h,anetRecvTimeout,,false,66,66,anetRecvTimeout,,,15,"int anetRecvTimeout (char*,int,long long)"
18046,METHOD,anet.h:<global>,TYPE_DECL,"int anetFdToString(int fd, char *ip, size_t ip_len, int *port, int remote);",5,74,anet.h,anetFdToString,,false,67,67,anetFdToString,,,16,"int anetFdToString (int,char*,size_t,int*,int)"
18055,METHOD,anet.h:<global>,TYPE_DECL,"int anetKeepAlive(char *err, int fd, int interval);",5,50,anet.h,anetKeepAlive,,false,68,68,anetKeepAlive,,,17,"int anetKeepAlive (char*,int,int)"
18062,METHOD,anet.h:<global>,TYPE_DECL,"int anetFormatAddr(char *fmt, size_t fmt_len, char *ip, int port);",5,65,anet.h,anetFormatAddr,,false,69,69,anetFormatAddr,,,18,"int anetFormatAddr (char*,size_t,char*,int)"
18070,METHOD,anet.h:<global>,TYPE_DECL,"int anetPipe(int fds[2], int read_flags, int write_flags);",5,57,anet.h,anetPipe,,false,70,70,anetPipe,,,19,"int anetPipe (int[2],int,int)"
18077,METHOD,anet.h:<global>,TYPE_DECL,"int anetSetSockMarkId(char *err, int fd, uint32_t id);",5,53,anet.h,anetSetSockMarkId,,false,71,71,anetSetSockMarkId,,,20,"int anetSetSockMarkId (char*,int,uint32_t)"
18084,METHOD,anet.h:<global>,TYPE_DECL,int anetGetError(int fd);,5,24,anet.h,anetGetError,,false,72,72,anetGetError,,,21,int anetGetError (int)
18089,METHOD,anet.h:<global>,TYPE_DECL,int anetIsFifo(char *filepath);,5,30,anet.h,anetIsFifo,,false,73,73,anetIsFifo,,,22,int anetIsFifo (char*)
18121,METHOD,aof.c:<global>,TYPE_DECL,<global>,1,1,aof.c,aof.c:<global>,,false,1,2738,<global>,,,1,
18123,METHOD,aof.c:<global>,TYPE_DECL,void freeClientArgv(client *c);,6,30,aof.c,freeClientArgv,,false,44,44,freeClientArgv,,,1,void freeClientArgv (client*)
18128,METHOD,aof.c:<global>,TYPE_DECL,"off_t getAppendOnlyFileSize(sds filename, int *status);",7,54,aof.c,getAppendOnlyFileSize,,false,45,45,getAppendOnlyFileSize,,,2,"off_t getAppendOnlyFileSize (sds,int*)"
18134,METHOD,aof.c:<global>,TYPE_DECL,"off_t getBaseAndIncrAppendOnlyFilesSize(aofManifest *am, int *status);",7,69,aof.c,getBaseAndIncrAppendOnlyFilesSize,,false,46,46,getBaseAndIncrAppendOnlyFilesSize,,,3,"off_t getBaseAndIncrAppendOnlyFilesSize (aofManifest*,int*)"
18140,METHOD,aof.c:<global>,TYPE_DECL,int getBaseAndIncrAppendOnlyFilesNum(aofManifest *am);,5,53,aof.c,getBaseAndIncrAppendOnlyFilesNum,,false,47,47,getBaseAndIncrAppendOnlyFilesNum,,,4,int getBaseAndIncrAppendOnlyFilesNum (aofManifest*)
18145,METHOD,aof.c:<global>,TYPE_DECL,int aofFileExist(char *filename);,5,32,aof.c,aofFileExist,,false,48,48,aofFileExist,,,5,int aofFileExist (char*)
18150,METHOD,aof.c:<global>,TYPE_DECL,int rewriteAppendOnlyFile(char *filename);,5,41,aof.c,rewriteAppendOnlyFile,,false,49,49,rewriteAppendOnlyFile,,,6,int rewriteAppendOnlyFile (char*)
18155,METHOD,aof.c:<global>,TYPE_DECL,aofManifest *aofLoadManifestFromFile(sds am_filepath);,13,53,aof.c,aofLoadManifestFromFile,,false,50,50,aofLoadManifestFromFile,,,7,aofManifest* aofLoadManifestFromFile (sds)
18160,METHOD,aof.c:<global>,TYPE_DECL,void aofManifestFreeAndUpdate(aofManifest *am);,6,46,aof.c,aofManifestFreeAndUpdate,,false,51,51,aofManifestFreeAndUpdate,,,8,void aofManifestFreeAndUpdate (aofManifest*)
18165,METHOD,aof.c:<global>,TYPE_DECL,void aof_background_fsync_and_close(int fd);,6,43,aof.c,aof_background_fsync_and_close,,false,52,52,aof_background_fsync_and_close,,,9,void aof_background_fsync_and_close (int)
18170,METHOD,aof.c:<global>,TYPE_DECL,"aofInfo *aofInfoCreate(void) {
    return zcalloc(sizeof(aofInfo));
}",1,1,aof.c,aofInfoCreate,,false,99,101,aofInfoCreate,,,10,aofInfo aofInfoCreate (void)
18179,METHOD,aof.c:<global>,TYPE_DECL,"void aofInfoFree(aofInfo *ai) {
    serverAssert(ai != NULL);
    if (ai->file_name) sdsfree(ai->file_name);
    zfree(ai);
}",1,4,aof.c,aofInfoFree,,false,104,108,aofInfoFree,,,11,void aofInfoFree (aofInfo*)
18211,METHOD,aof.c:<global>,TYPE_DECL,"aofInfo *aofInfoDup(aofInfo *orig) {
    serverAssert(orig != NULL);
    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdsdup(orig->file_name);
    ai->file_seq = orig->file_seq;
    ai->file_type = orig->file_type;
    return ai;
}",1,4,aof.c,aofInfoDup,,false,111,118,aofInfoDup,,,12,aofInfo aofInfoDup (aofInfo*)
18260,METHOD,aof.c:<global>,TYPE_DECL,"sds aofInfoFormat(sds buf, aofInfo *ai) {
    sds filename_repr = NULL;

    if (sdsneedsrepr(ai->file_name))
        filename_repr = sdscatrepr(sdsempty(), ai->file_name, sdslen(ai->file_name));

    sds ret = sdscatprintf(buf, ""%s %s %s %lld %s %c\n"",
        AOF_MANIFEST_KEY_FILE_NAME, filename_repr ? filename_repr : ai->file_name,
        AOF_MANIFEST_KEY_FILE_SEQ, ai->file_seq,
        AOF_MANIFEST_KEY_FILE_TYPE, ai->file_type);
    sdsfree(filename_repr);

    return ret;
}",1,8,aof.c,aofInfoFormat,,false,121,134,aofInfoFormat,,,13,"sds aofInfoFormat (sds,aofInfo*)"
18318,METHOD,aof.c:<global>,TYPE_DECL,"void aofListFree(void *item) {
    aofInfo *ai = (aofInfo *)item;
    aofInfoFree(ai);
}",1,1,aof.c,aofListFree,,false,137,140,aofListFree,,,14,void aofListFree (void*)
18331,METHOD,aof.c:<global>,TYPE_DECL,"void *aofListDup(void *item) {
    return aofInfoDup(item);
}",1,1,aof.c,aofListDup,,false,143,145,aofListDup,,,15,void* aofListDup (void*)
18339,METHOD,aof.c:<global>,TYPE_DECL,"aofManifest *aofManifestCreate(void) {
    aofManifest *am = zcalloc(sizeof(aofManifest));
    am->incr_aof_list = listCreate();
    am->history_aof_list = listCreate();
    listSetFreeMethod(am->incr_aof_list, aofListFree);
    listSetDupMethod(am->incr_aof_list, aofListDup);
    listSetFreeMethod(am->history_aof_list, aofListFree);
    listSetDupMethod(am->history_aof_list, aofListDup);
    return am;
}",1,4,aof.c,aofManifestCreate,,false,148,157,aofManifestCreate,,,16,aofManifest aofManifestCreate (void)
18414,METHOD,aof.c:<global>,TYPE_DECL,"void aofManifestFree(aofManifest *am) {
    if (am->base_aof_info) aofInfoFree(am->base_aof_info);
    if (am->incr_aof_list) listRelease(am->incr_aof_list);
    if (am->history_aof_list) listRelease(am->history_aof_list);
    zfree(am);
}",1,1,aof.c,aofManifestFree,,false,160,165,aofManifestFree,,,17,void aofManifestFree (aofManifest*)
18448,METHOD,aof.c:<global>,TYPE_DECL,"sds getAofManifestFileName(void) {
    return sdscatprintf(sdsempty(), ""%s%s"", server.aof_filename,
                MANIFEST_NAME_SUFFIX);
}",1,16,aof.c,getAofManifestFileName,,false,167,170,getAofManifestFileName,,,18,sds getAofManifestFileName (void)
18463,METHOD,aof.c:<global>,TYPE_DECL,"sds getTempAofManifestFileName(void) {
    return sdscatprintf(sdsempty(), ""%s%s%s"", TEMP_FILE_NAME_PREFIX,
                server.aof_filename, MANIFEST_NAME_SUFFIX);
}",1,46,aof.c,getTempAofManifestFileName,,false,172,175,getTempAofManifestFileName,,,19,sds getTempAofManifestFileName (void)
18481,METHOD,aof.c:<global>,TYPE_DECL,"sds getAofManifestAsString(aofManifest *am) {
    serverAssert(am != NULL);

    sds buf = sdsempty();
    listNode *ln;
    listIter li;

    /* 1. Add BASE File information, it is always at the beginning
     * of the manifest file. */
    if (am->base_aof_info) {
        buf = aofInfoFormat(buf, am->base_aof_info);
    }

    /* 2. Add HISTORY type AOF information. */
    listRewind(am->history_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        buf = aofInfoFormat(buf, ai);
    }

    /* 3. Add INCR type AOF information. */
    listRewind(am->incr_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        buf = aofInfoFormat(buf, ai);
    }

    return buf;
}",1,4,aof.c,getAofManifestAsString,,false,192,220,getAofManifestAsString,,,20,sds getAofManifestAsString (aofManifest*)
18578,METHOD,aof.c:<global>,TYPE_DECL,"void aofLoadManifestFromDisk(void) {
    server.aof_manifest = aofManifestCreate();
    if (!dirExists(server.aof_dirname)) {
        serverLog(LL_DEBUG, ""The AOF directory %s doesn't exist"", server.aof_dirname);
        return;
    }

    sds am_name = getAofManifestFileName();
    sds am_filepath = makePath(server.aof_dirname, am_name);
    if (!fileExist(am_filepath)) {
        serverLog(LL_DEBUG, ""The AOF manifest file %s doesn't exist"", am_name);
        sdsfree(am_name);
        sdsfree(am_filepath);
        return;
    }

    aofManifest *am = aofLoadManifestFromFile(am_filepath);
    if (am) aofManifestFreeAndUpdate(am);
    sdsfree(am_name);
    sdsfree(am_filepath);
}",1,8,aof.c,aofLoadManifestFromDisk,,false,232,252,aofLoadManifestFromDisk,,,21,void aofLoadManifestFromDisk (void)
18672,METHOD,aof.c:<global>,TYPE_DECL,"aofManifest *aofLoadManifestFromFile(sds am_filepath) {
    const char *err = NULL;
    long long maxseq = 0;

    aofManifest *am = aofManifestCreate();
    FILE *fp = fopen(am_filepath, ""r"");
    if (fp == NULL) {
        serverLog(LL_WARNING, ""Fatal error: can't open the AOF manifest ""
            ""file %s for reading: %s"", am_filepath, strerror(errno));
        exit(1);
    }

    char buf[MANIFEST_MAX_LINE+1];
    sds *argv = NULL;
    int argc;
    aofInfo *ai = NULL;

    sds line = NULL;
    int linenum = 0;

    while (1) {
        if (fgets(buf, MANIFEST_MAX_LINE+1, fp) == NULL) {
            if (feof(fp)) {
                if (linenum == 0) {
                    err = ""Found an empty AOF manifest"";
                    goto loaderr;
                } else {
                    break;
                }
            } else {
                err = ""Read AOF manifest failed"";
                goto loaderr;
            }
        }

        linenum++;

        /* Skip comments lin...",1,8,aof.c,aofLoadManifestFromFile,,false,256,382,aofLoadManifestFromFile,,,22,aofManifest aofLoadManifestFromFile (sds)
19144,METHOD,aof.c:<global>,TYPE_DECL,"aofManifest *aofManifestDup(aofManifest *orig) {
    serverAssert(orig != NULL);
    aofManifest *am = zcalloc(sizeof(aofManifest));

    am->curr_base_file_seq = orig->curr_base_file_seq;
    am->curr_incr_file_seq = orig->curr_incr_file_seq;
    am->dirty = orig->dirty;

    if (orig->base_aof_info) {
        am->base_aof_info = aofInfoDup(orig->base_aof_info);
    }

    am->incr_aof_list = listDup(orig->incr_aof_list);
    am->history_aof_list = listDup(orig->history_aof_list);
    serverAssert(am->incr_aof_list != NULL);
    serverAssert(am->history_aof_list != NULL);
    return am;
}",1,4,aof.c,aofManifestDup,,false,391,408,aofManifestDup,,,23,aofManifest aofManifestDup (aofManifest*)
19259,METHOD,aof.c:<global>,TYPE_DECL,"void aofManifestFreeAndUpdate(aofManifest *am) {
    serverAssert(am != NULL);
    if (server.aof_manifest) aofManifestFree(server.aof_manifest);
    server.aof_manifest = am;
}",1,4,aof.c,aofManifestFreeAndUpdate,,false,412,416,aofManifestFreeAndUpdate,,,24,void aofManifestFreeAndUpdate (aofManifest*)
19294,METHOD,aof.c:<global>,TYPE_DECL,"sds getNewBaseFileNameAndMarkPreAsHistory(aofManifest *am) {
    serverAssert(am != NULL);
    if (am->base_aof_info) {
        serverAssert(am->base_aof_info->file_type == AOF_FILE_TYPE_BASE);
        am->base_aof_info->file_type = AOF_FILE_TYPE_HIST;
        listAddNodeHead(am->history_aof_list, am->base_aof_info);
    }

    char *format_suffix = server.aof_use_rdb_preamble ?
        RDB_FORMAT_SUFFIX:AOF_FORMAT_SUFFIX;

    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdscatprintf(sdsempty(), ""%s.%lld%s%s"", server.aof_filename,
                        ++am->curr_base_file_seq, BASE_FILE_SUFFIX, format_suffix);
    ai->file_seq = am->curr_base_file_seq;
    ai->file_type = AOF_FILE_TYPE_BASE;
    am->base_aof_info = ai;
    am->dirty = 1;
    return am->base_aof_info->file_name;
}",1,4,aof.c,getNewBaseFileNameAndMarkPreAsHistory,,false,427,446,getNewBaseFileNameAndMarkPreAsHistory,,,25,sds getNewBaseFileNameAndMarkPreAsHistory (aofManifest*)
19417,METHOD,aof.c:<global>,TYPE_DECL,"sds getNewIncrAofName(aofManifest *am) {
    aofInfo *ai = aofInfoCreate();
    ai->file_type = AOF_FILE_TYPE_INCR;
    ai->file_name = sdscatprintf(sdsempty(), ""%s.%lld%s%s"", server.aof_filename,
                        ++am->curr_incr_file_seq, INCR_FILE_SUFFIX, AOF_FORMAT_SUFFIX);
    ai->file_seq = am->curr_incr_file_seq;
    listAddNodeTail(am->incr_aof_list, ai);
    am->dirty = 1;
    return ai->file_name;
}",1,50,aof.c,getNewIncrAofName,,false,455,464,getNewIncrAofName,,,26,sds getNewIncrAofName (aofManifest*)
19472,METHOD,aof.c:<global>,TYPE_DECL,"sds getTempIncrAofName(void) {
    return sdscatprintf(sdsempty(), ""%s%s%s"", TEMP_FILE_NAME_PREFIX, server.aof_filename,
        INCR_FILE_SUFFIX);
}",1,46,aof.c,getTempIncrAofName,,false,467,470,getTempIncrAofName,,,27,sds getTempIncrAofName (void)
19490,METHOD,aof.c:<global>,TYPE_DECL,"sds getLastIncrAofName(aofManifest *am) {
    serverAssert(am != NULL);

    /* If 'incr_aof_list' is empty, just create a new one. */
    if (!listLength(am->incr_aof_list)) {
        return getNewIncrAofName(am);
    }

    /* Or return the last one. */
    listNode *lastnode = listIndex(am->incr_aof_list, -1);
    aofInfo *ai = listNodeValue(lastnode);
    return ai->file_name;
}",1,4,aof.c,getLastIncrAofName,,false,473,485,getLastIncrAofName,,,28,sds getLastIncrAofName (aofManifest*)
19549,METHOD,aof.c:<global>,TYPE_DECL,"void markRewrittenIncrAofAsHistory(aofManifest *am) {
    serverAssert(am != NULL);
    if (!listLength(am->incr_aof_list)) {
        return;
    }

    listNode *ln;
    listIter li;

    listRewindTail(am->incr_aof_list, &li);

    /* ""server.aof_fd != -1"" means AOF enabled, then we must skip the
     * last AOF, because this file is our currently writing. */
    if (server.aof_fd != -1) {
        ln = listNext(&li);
        serverAssert(ln != NULL);
    }

    /* Move aofInfo from 'incr_aof_list' to 'history_aof_list'. */
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_INCR);

        aofInfo *hai = aofInfoDup(ai);
        hai->file_type = AOF_FILE_TYPE_HIST;
        listAddNodeHead(am->history_aof_list, hai);
        listDelNode(am->incr_aof_list, ln);
    }

    am->dirty = 1;
}",1,4,aof.c,markRewrittenIncrAofAsHistory,,false,492,522,markRewrittenIncrAofAsHistory,,,29,void markRewrittenIncrAofAsHistory (aofManifest*)
19681,METHOD,aof.c:<global>,TYPE_DECL,"int writeAofManifestFile(sds buf) {
    int ret = C_OK;
    ssize_t nwritten;
    int len;

    sds am_name = getAofManifestFileName();
    sds am_filepath = makePath(server.aof_dirname, am_name);
    sds tmp_am_name = getTempAofManifestFileName();
    sds tmp_am_filepath = makePath(server.aof_dirname, tmp_am_name);

    int fd = open(tmp_am_filepath, O_WRONLY|O_TRUNC|O_CREAT, 0644);
    if (fd == -1) {
        serverLog(LL_WARNING, ""Can't open the AOF manifest file %s: %s"",
            tmp_am_name, strerror(errno));

        ret = C_ERR;
        goto cleanup;
    }

    len = sdslen(buf);
    while(len) {
        nwritten = write(fd, buf, len);

        if (nwritten < 0) {
            if (errno == EINTR) continue;

            serverLog(LL_WARNING, ""Error trying to write the temporary AOF manifest file %s: %s"",
                tmp_am_name, strerror(errno));

            ret = C_ERR;
            goto cleanup;
        }

        len -= nwritten;
        buf += nwritten;
    }

    if...",1,14,aof.c,writeAofManifestFile,,false,525,595,writeAofManifestFile,,,30,int writeAofManifestFile (sds)
19949,METHOD,aof.c:<global>,TYPE_DECL,"int persistAofManifest(aofManifest *am) {
    if (am->dirty == 0) {
        return C_OK;
    }

    sds amstr = getAofManifestAsString(am);
    int ret = writeAofManifestFile(amstr);
    sdsfree(amstr);
    if (ret == C_OK) am->dirty = 0;
    return ret;
}",1,15,aof.c,persistAofManifest,,false,598,608,persistAofManifest,,,31,int persistAofManifest (aofManifest*)
19991,METHOD,aof.c:<global>,TYPE_DECL,"void aofUpgradePrepare(aofManifest *am) {
    serverAssert(!aofFileExist(server.aof_filename));

    /* Create AOF directory use 'server.aof_dirname' as the name. */
    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        exit(1);
    }

    /* Manually construct a BASE type aofInfo and add it to aofManifest. */
    if (am->base_aof_info) aofInfoFree(am->base_aof_info);
    aofInfo *ai = aofInfoCreate();
    ai->file_name = sdsnew(server.aof_filename);
    ai->file_seq = 1;
    ai->file_type = AOF_FILE_TYPE_BASE;
    am->base_aof_info = ai;
    am->curr_base_file_seq = 1;
    am->dirty = 1;

    /* Persist the manifest file to AOF directory. */
    if (persistAofManifest(am) != C_OK) {
        exit(1);
    }

    /* Move the old AOF file to AOF directory. */
    sds aof_filepath = makePath(server.aof_dirname, server.aof_filename);
    if (rename(serv...",1,4,aof.c,aofUpgradePrepare,,false,620,660,aofUpgradePrepare,,,32,void aofUpgradePrepare (aofManifest*)
20185,METHOD,aof.c:<global>,TYPE_DECL,"int aofDelHistoryFiles(void) {
    if (server.aof_manifest == NULL ||
        server.aof_disable_auto_gc == 1 ||
        !listLength(server.aof_manifest->history_aof_list))
    {
        return C_OK;
    }

    listNode *ln;
    listIter li;

    listRewind(server.aof_manifest->history_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_HIST);
        serverLog(LL_NOTICE, ""Removing the history file %s in the background"", ai->file_name);
        sds aof_filepath = makePath(server.aof_dirname, ai->file_name);
        bg_unlink(aof_filepath);
        sdsfree(aof_filepath);
        listDelNode(server.aof_manifest->history_aof_list, ln);
    }

    server.aof_manifest->dirty = 1;
    return persistAofManifest(server.aof_manifest);
}",1,9,aof.c,aofDelHistoryFiles,,false,668,692,aofDelHistoryFiles,,,33,int aofDelHistoryFiles (void)
20322,METHOD,aof.c:<global>,TYPE_DECL,"void aofDelTempIncrAofFile(void) {
    sds aof_filename = getTempIncrAofName();
    sds aof_filepath = makePath(server.aof_dirname, aof_filename);
    serverLog(LL_NOTICE, ""Removing the temp incr aof file %s in the background"", aof_filename);
    bg_unlink(aof_filepath);
    sdsfree(aof_filepath);
    sdsfree(aof_filename);
    return;
}",1,4,aof.c,aofDelTempIncrAofFile,,false,695,703,aofDelTempIncrAofFile,,,34,void aofDelTempIncrAofFile (void)
20365,METHOD,aof.c:<global>,TYPE_DECL,"void aofOpenIfNeededOnServerStart(void) {
    if (server.aof_state != AOF_ON) {
        return;
    }

    serverAssert(server.aof_manifest != NULL);
    serverAssert(server.aof_fd == -1);

    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        exit(1);
    }

    /* If we start with an empty dataset, we will force create a BASE file. */
    size_t incr_aof_len = listLength(server.aof_manifest->incr_aof_list);
    if (!server.aof_manifest->base_aof_info && !incr_aof_len) {
        sds base_name = getNewBaseFileNameAndMarkPreAsHistory(server.aof_manifest);
        sds base_filepath = makePath(server.aof_dirname, base_name);
        if (rewriteAppendOnlyFile(base_filepath) != C_OK) {
            exit(1);
        }
        sdsfree(base_filepath);
        serverLog(LL_NOTICE, ""Creating AOF base file %s on server start"",
            base_name);
    }

  ...",1,28,aof.c,aofOpenIfNeededOnServerStart,,false,713,768,aofOpenIfNeededOnServerStart,,,35,void aofOpenIfNeededOnServerStart (void)
20658,METHOD,aof.c:<global>,TYPE_DECL,"int aofFileExist(char *filename) {
    sds file_path = makePath(server.aof_dirname, filename);
    int ret = fileExist(file_path);
    sdsfree(file_path);
    return ret;
}",1,1,aof.c,aofFileExist,,false,770,775,aofFileExist,,,36,int aofFileExist (char*)
20680,METHOD,aof.c:<global>,TYPE_DECL,"int openNewIncrAofForAppend(void) {
    serverAssert(server.aof_manifest != NULL);
    int newfd = -1;
    aofManifest *temp_am = NULL;
    sds new_aof_name = NULL;

    /* Only open new INCR AOF when AOF enabled. */
    if (server.aof_state == AOF_OFF) return C_OK;

    /* Open new AOF. */
    if (server.aof_state == AOF_WAIT_REWRITE) {
        /* Use a temporary INCR AOF file to accumulate data during AOF_WAIT_REWRITE. */
        new_aof_name = getTempIncrAofName();
    } else {
        /* Dup a temp aof_manifest to modify. */
        temp_am = aofManifestDup(server.aof_manifest);
        new_aof_name = sdsdup(getNewIncrAofName(temp_am));
    }
    sds new_aof_filepath = makePath(server.aof_dirname, new_aof_name);
    newfd = open(new_aof_filepath, O_WRONLY|O_TRUNC|O_CREAT, 0644);
    sdsfree(new_aof_filepath);
    if (newfd == -1) {
        serverLog(LL_WARNING, ""Can't open the append-only file %s: %s"",
            new_aof_name, strerror(errno));
        goto cleanup;
    }

    ...",1,4,aof.c,openNewIncrAofForAppend,,false,790,853,openNewIncrAofForAppend,,,37,int openNewIncrAofForAppend (void)
20903,METHOD,aof.c:<global>,TYPE_DECL,"int aofRewriteLimited(void) {
    static int next_delay_minutes = 0;
    static time_t next_rewrite_time = 0;

    if (server.stat_aofrw_consecutive_failures < AOF_REWRITE_LIMITE_THRESHOLD) {
        /* We may be recovering from limited state, so reset all states. */
        next_delay_minutes = 0;
        next_rewrite_time = 0;
        return 0;
    }

    /* if it is in the limiting state, then check if the next_rewrite_time is reached */
    if (next_rewrite_time != 0) {
        if (server.unixtime < next_rewrite_time) {
            return 1;
        } else {
            next_rewrite_time = 0;
            return 0;
        }
    }

    next_delay_minutes = (next_delay_minutes == 0) ? 1 : (next_delay_minutes * 2);
    if (next_delay_minutes > AOF_REWRITE_LIMITE_MAX_MINUTES) {
        next_delay_minutes = AOF_REWRITE_LIMITE_MAX_MINUTES;
    }

    next_rewrite_time = server.unixtime + next_delay_minutes * 60;
    serverLog(LL_WARNING,
        ""Background AOF rewrite has repeatedly ...",1,49,aof.c,aofRewriteLimited,,false,877,907,aofRewriteLimited,,,38,int aofRewriteLimited (void)
21006,METHOD,aof.c:<global>,TYPE_DECL,"int aofFsyncInProgress(void) {
    /* Note that we don't care about aof_background_fsync_and_close because
     * server.aof_fd has been replaced by the new INCR AOF file fd,
     * see openNewIncrAofForAppend. */
    return bioPendingJobsOfType(BIO_AOF_FSYNC) != 0;
}",1,1,aof.c,aofFsyncInProgress,,false,915,920,aofFsyncInProgress,,,39,int aofFsyncInProgress (void)
21016,METHOD,aof.c:<global>,TYPE_DECL,"void aof_background_fsync(int fd) {
    bioCreateFsyncJob(fd, server.master_repl_offset, 1);
}",1,1,aof.c,aof_background_fsync,,false,924,926,aof_background_fsync,,,40,void aof_background_fsync (int)
21027,METHOD,aof.c:<global>,TYPE_DECL,"void aof_background_fsync_and_close(int fd) {
    bioCreateCloseAofJob(fd, server.master_repl_offset, 1);
}",1,1,aof.c,aof_background_fsync_and_close,,false,929,931,aof_background_fsync_and_close,,,41,void aof_background_fsync_and_close (int)
21038,METHOD,aof.c:<global>,TYPE_DECL,"void killAppendOnlyChild(void) {
    int statloc;
    /* No AOFRW child? return. */
    if (server.child_type != CHILD_TYPE_AOF) return;
    /* Kill AOFRW child, wait for child exit. */
    serverLog(LL_NOTICE,""Killing running AOF rewrite child: %ld"",
        (long) server.child_pid);
    if (kill(server.child_pid,SIGUSR1) != -1) {
        while(waitpid(-1, &statloc, 0) != server.child_pid);
    }
    aofRemoveTempFile(server.child_pid);
    resetChildState();
    server.aof_rewrite_time_start = -1;
}",1,29,aof.c,killAppendOnlyChild,,false,934,947,killAppendOnlyChild,,,42,void killAppendOnlyChild (void)
21109,METHOD,aof.c:<global>,TYPE_DECL,"void stopAppendOnly(void) {
    serverAssert(server.aof_state != AOF_OFF);
    flushAppendOnlyFile(1);
    if (redis_fsync(server.aof_fd) == -1) {
        serverLog(LL_WARNING,""Fail to fsync the AOF file: %s"",strerror(errno));
    } else {
        server.aof_last_fsync = server.unixtime;
    }
    close(server.aof_fd);

    server.aof_fd = -1;
    server.aof_selected_db = -1;
    server.aof_state = AOF_OFF;
    server.aof_rewrite_scheduled = 0;
    server.aof_last_incr_size = 0;
    server.aof_last_incr_fsync_offset = 0;
    server.fsynced_reploff = -1;
    atomicSet(server.fsynced_reploff_pending, 0);
    killAppendOnlyChild();
    sdsfree(server.aof_buf);
    server.aof_buf = sdsempty();
}",1,4,aof.c,stopAppendOnly,,false,951,972,stopAppendOnly,,,43,void stopAppendOnly (void)
21236,METHOD,aof.c:<global>,TYPE_DECL,"int startAppendOnly(void) {
    serverAssert(server.aof_state == AOF_OFF);

    /* Wait for all bio jobs related to AOF to drain. This prevents a race
     * between updates to `fsynced_reploff_pending` of the worker thread, belonging
     * to the previous AOF, and the new one. This concern is specific for a full
     * sync scenario where we don't wanna risk the ACKed replication offset
     * jumping backwards or forward when switching to a different master. */
    bioDrainWorker(BIO_AOF_FSYNC);

    /* Set the initial repl_offset, which will be applied to fsynced_reploff
     * when AOFRW finishes (after possibly being updated by a bio thread) */
    atomicSet(server.fsynced_reploff_pending, server.master_repl_offset);
    server.fsynced_reploff = 0;

    server.aof_state = AOF_WAIT_REWRITE;
    if (hasActiveChildProcess() && server.child_type != CHILD_TYPE_AOF) {
        server.aof_rewrite_scheduled = 1;
        serverLog(LL_NOTICE,""AOF was enabled but there is already another ...",1,4,aof.c,startAppendOnly,,false,976,1029,startAppendOnly,,,44,int startAppendOnly (void)
21497,METHOD,aof.c:<global>,TYPE_DECL,"ssize_t aofWrite(int fd, const char *buf, size_t len) {
    ssize_t nwritten = 0, totwritten = 0;

    while(len) {
        nwritten = write(fd, buf, len);

        if (nwritten < 0) {
            if (errno == EINTR) continue;
            return totwritten ? totwritten : -1;
        }

        len -= nwritten;
        buf += nwritten;
        totwritten += nwritten;
    }

    return totwritten;
}",1,1,aof.c,aofWrite,,false,1038,1055,aofWrite,,,45,"ssize_t aofWrite (int,char*,size_t)"
21549,METHOD,aof.c:<global>,TYPE_DECL,"void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) {
        /* Check if we need to do fsync even the aof buffer is empty,
         * because previously in AOF_FSYNC_EVERYSEC mode, fsync is
         * called only when aof buffer is not empty, so if users
         * stop write commands before fsync called in one second,
         * the data in page cache cannot be flushed in time. */
        if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
            server.aof_last_incr_fsync_offset != server.aof_last_incr_size &&
            server.unixtime > server.aof_last_fsync &&
            !(sync_in_progress = aofFsyncInProgress())) {
            goto try_fsync;

        /* Check if we need to do fsync even the aof buffer is empty,
         * the reason is described in the previous AOF_FSYNC_EVERYSEC block,
         * and AOF_FSYNC_ALWAYS is also checked here to handle a case where
         * aof_f...",1,32,aof.c,flushAppendOnlyFile,,false,1076,1278,flushAppendOnlyFile,,,46,void flushAppendOnlyFile (int)
22292,METHOD,aof.c:<global>,TYPE_DECL,"sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {
    char buf[32];
    int len, j;
    robj *o;

    buf[0] = '*';
    len = 1+ll2string(buf+1,sizeof(buf)-1,argc);
    buf[len++] = '\r';
    buf[len++] = '\n';
    dst = sdscatlen(dst,buf,len);

    for (j = 0; j < argc; j++) {
        o = getDecodedObject(argv[j]);
        buf[0] = '$';
        len = 1+ll2string(buf+1,sizeof(buf)-1,sdslen(o->ptr));
        buf[len++] = '\r';
        buf[len++] = '\n';
        dst = sdscatlen(dst,buf,len);
        dst = sdscatlen(dst,o->ptr,sdslen(o->ptr));
        dst = sdscatlen(dst,""\r\n"",2);
        decrRefCount(o);
    }
    return dst;
}",1,1,aof.c,catAppendOnlyGenericCommand,,false,1280,1303,catAppendOnlyGenericCommand,,,47,"sds catAppendOnlyGenericCommand (sds,int,robj**)"
22416,METHOD,aof.c:<global>,TYPE_DECL,"sds genAofTimestampAnnotationIfNeeded(int force) {
    sds ts = NULL;

    if (force || server.aof_cur_timestamp < server.unixtime) {
        server.aof_cur_timestamp = force ? time(NULL) : server.unixtime;
        ts = sdscatfmt(sdsempty(), ""#TS:%I\r\n"", server.aof_cur_timestamp);
        serverAssert(sdslen(ts) <= AOF_ANNOTATION_LINE_MAX_LEN);
    }
    return ts;
}",1,8,aof.c,genAofTimestampAnnotationIfNeeded,,false,1313,1322,genAofTimestampAnnotationIfNeeded,,,48,sds genAofTimestampAnnotationIfNeeded (int)
22474,METHOD,aof.c:<global>,TYPE_DECL,"void feedAppendOnlyFile(int dictid, robj **argv, int argc) {
    sds buf = sdsempty();

    serverAssert(dictid == -1 || (dictid >= 0 && dictid < server.dbnum));

    /* Feed timestamp if needed */
    if (server.aof_timestamp_enabled) {
        sds ts = genAofTimestampAnnotationIfNeeded(0);
        if (ts != NULL) {
            buf = sdscatsds(buf, ts);
            sdsfree(ts);
        }
    }

    /* The DB this command was targeting is not the same as the last command
     * we appended. To issue a SELECT command is needed. */
    if (dictid != -1 && dictid != server.aof_selected_db) {
        char seldb[64];

        snprintf(seldb,sizeof(seldb),""%d"",dictid);
        buf = sdscatprintf(buf,""*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"",
            (unsigned long)strlen(seldb),seldb);
        server.aof_selected_db = dictid;
    }

    /* All commands should be propagated the same way in AOF as in replication.
     * No need for AOF-specific translation. */
    buf = catAppendOnlyGeneri...",1,4,aof.c,feedAppendOnlyFile,,false,1332,1371,feedAppendOnlyFile,,,49,"void feedAppendOnlyFile (int,robj**,int)"
22612,METHOD,aof.c:<global>,TYPE_DECL,"struct client *createAOFClient(void) {
    struct client *c = createClient(NULL);

    c->id = CLIENT_ID_AOF; /* So modules can identify it's the AOF client. */

    /*
     * The AOF client should never be blocked (unlike master
     * replication connection).
     * This is because blocking the AOF client might cause
     * deadlock (because potentially no one will unblock it).
     * Also, if the AOF client will be blocked just for
     * background processing there is a chance that the
     * command execution order will be violated.
     */
    c->flags = CLIENT_DENY_BLOCKING;

    /* We set the fake client as a slave waiting for the synchronization
     * so that Redis will not try to send replies to this client. */
    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;
    return c;
}",1,12,aof.c,createAOFClient,,false,1379,1399,createAOFClient,,,50,struct client createAOFClient (void)
22647,METHOD,aof.c:<global>,TYPE_DECL,"int loadSingleAppendOnlyFile(char *filename) {
    struct client *fakeClient;
    struct redis_stat sb;
    int old_aof_state = server.aof_state;
    long loops = 0;
    off_t valid_up_to = 0; /* Offset of latest well-formed command loaded. */
    off_t valid_before_multi = 0; /* Offset before MULTI command loaded. */
    off_t last_progress_report_size = 0;
    int ret = AOF_OK;

    sds aof_filepath = makePath(server.aof_dirname, filename);
    FILE *fp = fopen(aof_filepath, ""r"");
    if (fp == NULL) {
        int en = errno;
        if (redis_stat(aof_filepath, &sb) == 0 || errno != ENOENT) {
            serverLog(LL_WARNING,""Fatal error: can't open the append log file %s for reading: %s"", filename, strerror(en));
            sdsfree(aof_filepath);
            return AOF_OPEN_ERR;
        } else {
            serverLog(LL_WARNING,""The append log file %s doesn't exist: %s"", filename, strerror(errno));
            sdsfree(aof_filepath);
            return AOF_NOT_EXIST;
        }
 ...",1,11,aof.c,loadSingleAppendOnlyFile,,false,1407,1658,loadSingleAppendOnlyFile,,,51,int loadSingleAppendOnlyFile (char*)
23735,METHOD,aof.c:<global>,TYPE_DECL,"int loadAppendOnlyFiles(aofManifest *am) {
    serverAssert(am != NULL);
    int status, ret = AOF_OK;
    long long start;
    off_t total_size = 0, base_size = 0;
    sds aof_name;
    int total_num, aof_num = 0, last_file;

    /* If the 'server.aof_filename' file exists in dir, we may be starting
     * from an old redis version. We will use enter upgrade mode in three situations.
     *
     * 1. If the 'server.aof_dirname' directory not exist
     * 2. If the 'server.aof_dirname' directory exists but the manifest file is missing
     * 3. If the 'server.aof_dirname' directory exists and the manifest file it contains
     *    has only one base AOF record, and the file name of this base AOF is 'server.aof_filename',
     *    and the 'server.aof_filename' file not exist in 'server.aof_dirname' directory
     * */
    if (fileExist(server.aof_filename)) {
        if (!dirExists(server.aof_dirname) ||
            (am->base_aof_info == NULL && listLength(am->incr_aof_list) == 0) |...",1,4,aof.c,loadAppendOnlyFiles,,false,1661,1784,loadAppendOnlyFiles,,,52,int loadAppendOnlyFiles (aofManifest*)
24283,METHOD,aof.c:<global>,TYPE_DECL,"int rioWriteBulkObject(rio *r, robj *obj) {
    /* Avoid using getDecodedObject to help copy-on-write (we are often
     * in a child process when this function is called). */
    if (obj->encoding == OBJ_ENCODING_INT) {
        return rioWriteBulkLongLong(r,(long)obj->ptr);
    } else if (sdsEncodedObject(obj)) {
        return rioWriteBulkString(r,obj->ptr,sdslen(obj->ptr));
    } else {
        serverPanic(""Unknown string encoding"");
    }
}",1,25,aof.c,rioWriteBulkObject,,false,1792,1802,rioWriteBulkObject,,,53,"int rioWriteBulkObject (rio*,robj*)"
24344,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteListObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = listTypeLength(o);

    listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
    listTypeEntry entry;
    while (listTypeNext(li,&entry)) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;
            if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
                !rioWriteBulkString(r,""RPUSH"",5) ||
                !rioWriteBulkObject(r,key)) 
            {
                listTypeReleaseIterator(li);
                return 0;
            }
        }

        unsigned char *vstr;
        size_t vlen;
        long long lval;
        vstr = listTypeGetValue(&entry,&vlen,&lval);
        if (vstr) {
            if (!rioWriteBulkString(r,(char*)vstr,vlen)) {
                listTypeReleaseIterator(li);
                return 0;
            }
        } else {
            if (!rioWriteBulkLongLong(r,lval)) {
 ...",1,52,aof.c,rewriteListObject,,false,1806,1844,rewriteListObject,,,54,"int rewriteListObject (rio*,robj*,robj*)"
24475,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteSetObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = setTypeSize(o);
    setTypeIterator *si = setTypeInitIterator(o);
    char *str;
    size_t len;
    int64_t llval;
    while (setTypeNext(si, &str, &len, &llval) != -1) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;
            if (!rioWriteBulkCount(r,'*',2+cmd_items) ||
                !rioWriteBulkString(r,""SADD"",4) ||
                !rioWriteBulkObject(r,key))
            {
                return 0;
            }
        }
        size_t written = str ?
            rioWriteBulkString(r, str, len) : rioWriteBulkLongLong(r, llval);
        if (!written) {
            setTypeReleaseIterator(si);
            return 0;
        }
        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
        items--;
    }
    setTypeReleaseIterator(si);
    return 1;
}",1,37,aof.c,rewriteSetObject,,false,1848,1876,rewriteSetObject,,,55,"int rewriteSetObject (rio*,robj*,robj*)"
24589,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteSortedSetObject(rio *r, robj *key, robj *o) {
    long long count = 0, items = zsetLength(o);

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vll;
        double score;

        eptr = lpSeek(zl,0);
        serverAssert(eptr != NULL);
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        while (eptr != NULL) {
            vstr = lpGetValue(eptr,&vlen,&vll);
            score = zzlGetScore(sptr);

            if (count == 0) {
                int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                    AOF_REWRITE_ITEMS_PER_CMD : items;

                if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
                    !rioWriteBulkString(r,""ZADD"",4) ||
                    !rioWriteBulkObject(r,key)) 
                {
                    return 0;
                }
            }
            i...",1,23,aof.c,rewriteSortedSetObject,,false,1880,1956,rewriteSortedSetObject,,,56,"int rewriteSortedSetObject (rio*,robj*,robj*)"
24912,METHOD,aof.c:<global>,TYPE_DECL,"static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);
        if (vstr)
            return rioWriteBulkString(r, (char*)vstr, vlen);
        else
            return rioWriteBulkLongLong(r, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds value = hashTypeCurrentFromHashTable(hi, what);
        return rioWriteBulkString(r, value, sdslen(value));
    }

    serverPanic(""Unknown hash encoding"");
    return 0;
}",1,24,aof.c,rioWriteHashIteratorCursor,,false,1964,1982,rioWriteHashIteratorCursor,,,57,"int rioWriteHashIteratorCursor (rio*,hashTypeIterator*,int)"
24998,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteHashObject(rio *r, robj *key, robj *o) {
    hashTypeIterator *hi;
    long long count = 0, items = hashTypeLength(o);

    hi = hashTypeInitIterator(o);
    while (hashTypeNext(hi) != C_ERR) {
        if (count == 0) {
            int cmd_items = (items > AOF_REWRITE_ITEMS_PER_CMD) ?
                AOF_REWRITE_ITEMS_PER_CMD : items;

            if (!rioWriteBulkCount(r,'*',2+cmd_items*2) ||
                !rioWriteBulkString(r,""HMSET"",5) ||
                !rioWriteBulkObject(r,key)) 
            {
                hashTypeReleaseIterator(hi);
                return 0;
            }
        }

        if (!rioWriteHashIteratorCursor(r, hi, OBJ_HASH_KEY) ||
            !rioWriteHashIteratorCursor(r, hi, OBJ_HASH_VALUE))
        {
            hashTypeReleaseIterator(hi);
            return 0;           
        }
        if (++count == AOF_REWRITE_ITEMS_PER_CMD) count = 0;
        items--;
    }

    hashTypeReleaseIterator(hi);

    return 1;
}",1,31,aof.c,rewriteHashObject,,false,1986,2018,rewriteHashObject,,,58,"int rewriteHashObject (rio*,robj*,robj*)"
25110,METHOD,aof.c:<global>,TYPE_DECL,"int rioWriteBulkStreamID(rio *r,streamID *id) {
    int retval;

    sds replyid = sdscatfmt(sdsempty(),""%U-%U"",id->ms,id->seq);
    retval = rioWriteBulkString(r,replyid,sdslen(replyid));
    sdsfree(replyid);
    return retval;
}",1,1,aof.c,rioWriteBulkStreamID,,false,2022,2029,rioWriteBulkStreamID,,,59,"int rioWriteBulkStreamID (rio*,streamID*)"
25140,METHOD,aof.c:<global>,TYPE_DECL,"int rioWriteStreamPendingEntry(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer, unsigned char *rawid, streamNACK *nack) {
     /* XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
               RETRYCOUNT <count> JUSTID FORCE. */
    streamID id;
    streamDecodeID(rawid,&id);
    if (rioWriteBulkCount(r,'*',12) == 0) return 0;
    if (rioWriteBulkString(r,""XCLAIM"",6) == 0) return 0;
    if (rioWriteBulkObject(r,key) == 0) return 0;
    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
    if (rioWriteBulkString(r,""0"",1) == 0) return 0;
    if (rioWriteBulkStreamID(r,&id) == 0) return 0;
    if (rioWriteBulkString(r,""TIME"",4) == 0) return 0;
    if (rioWriteBulkLongLong(r,nack->delivery_time) == 0) return 0;
    if (rioWriteBulkString(r,""RETRYCOUNT"",10) == 0) return 0;
    if (rioWriteBulkLongLong(r,nack->delivery_count) == ...",1,1,aof.c,rioWriteStreamPendingEntry,,false,2035,2054,rioWriteStreamPendingEntry,,,60,"int rioWriteStreamPendingEntry (rio*,robj*,char*,size_t,streamConsumer*,unsigned char*,streamNACK*)"
25294,METHOD,aof.c:<global>,TYPE_DECL,"int rioWriteStreamEmptyConsumer(rio *r, robj *key, const char *groupname, size_t groupname_len, streamConsumer *consumer) {
    /* XGROUP CREATECONSUMER <key> <group> <consumer> */
    if (rioWriteBulkCount(r,'*',5) == 0) return 0;
    if (rioWriteBulkString(r,""XGROUP"",6) == 0) return 0;
    if (rioWriteBulkString(r,""CREATECONSUMER"",14) == 0) return 0;
    if (rioWriteBulkObject(r,key) == 0) return 0;
    if (rioWriteBulkString(r,groupname,groupname_len) == 0) return 0;
    if (rioWriteBulkString(r,consumer->name,sdslen(consumer->name)) == 0) return 0;
    return 1;
}",1,1,aof.c,rioWriteStreamEmptyConsumer,,false,2059,2068,rioWriteStreamEmptyConsumer,,,61,"int rioWriteStreamEmptyConsumer (rio*,robj*,char*,size_t,streamConsumer*)"
25369,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteStreamObject(rio *r, robj *key, robj *o) {
    stream *s = o->ptr;
    streamIterator si;
    streamIteratorStart(&si,s,NULL,NULL,0);
    streamID id;
    int64_t numfields;

    if (s->length) {
        /* Reconstruct the stream data using XADD commands. */
        while(streamIteratorGetID(&si,&id,&numfields)) {
            /* Emit a two elements array for each item. The first is
             * the ID, the second is an array of field-value pairs. */

            /* Emit the XADD <key> <id> ...fields... command. */
            if (!rioWriteBulkCount(r,'*',3+numfields*2) || 
                !rioWriteBulkString(r,""XADD"",4) ||
                !rioWriteBulkObject(r,key) ||
                !rioWriteBulkStreamID(r,&id)) 
            {
                streamIteratorStop(&si);
                return 0;
            }
            while(numfields--) {
                unsigned char *field, *value;
                int64_t field_len, value_len;
                streamIteratorGetField(&...",1,1,aof.c,rewriteStreamObject,,false,2072,2210,rewriteStreamObject,,,62,"int rewriteStreamObject (rio*,robj*,robj*)"
25829,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteModuleObject(rio *r, robj *key, robj *o, int dbid) {
    RedisModuleIO io;
    moduleValue *mv = o->ptr;
    moduleType *mt = mv->type;
    moduleInitIOContext(io,mt,r,key,dbid);
    mt->aof_rewrite(&io,key,mv->value);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    return io.error ? 0 : 1;
}",1,4,aof.c,rewriteModuleObject,,false,2215,2226,rewriteModuleObject,,,63,"int rewriteModuleObject (rio*,robj*,robj*,int)"
25930,METHOD,aof.c:<global>,TYPE_DECL,"static int rewriteFunctions(rio *aof) {
    dict *functions = functionsLibGet();
    dictIterator *iter = dictGetIterator(functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionLibInfo *li = dictGetVal(entry);
        if (rioWrite(aof, ""*3\r\n"", 4) == 0) goto werr;
        char function_load[] = ""$8\r\nFUNCTION\r\n$4\r\nLOAD\r\n"";
        if (rioWrite(aof, function_load, sizeof(function_load) - 1) == 0) goto werr;
        if (rioWriteBulkString(aof, li->code, sdslen(li->code)) == 0) goto werr;
    }
    dictReleaseIterator(iter);
    return 1;

werr:
    dictReleaseIterator(iter);
    return 0;
}",1,1,aof.c,rewriteFunctions,,false,2228,2245,rewriteFunctions,,,64,int rewriteFunctions (rio*)
26007,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteAppendOnlyFileRio(rio *aof) {
    dictIterator *di = NULL;
    dictEntry *de;
    int j;
    long key_count = 0;
    long long updated_time = 0;

    /* Record timestamp at the beginning of rewriting AOF. */
    if (server.aof_timestamp_enabled) {
        sds ts = genAofTimestampAnnotationIfNeeded(1);
        if (rioWrite(aof,ts,sdslen(ts)) == 0) { sdsfree(ts); goto werr; }
        sdsfree(ts);
    }

    if (rewriteFunctions(aof) == 0) goto werr;

    for (j = 0; j < server.dbnum; j++) {
        char selectcmd[] = ""*2\r\n$6\r\nSELECT\r\n"";
        redisDb *db = server.db+j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;
        di = dictGetSafeIterator(d);

        /* SELECT the new DB */
        if (rioWrite(aof,selectcmd,sizeof(selectcmd)-1) == 0) goto werr;
        if (rioWriteBulkLongLong(aof,j) == 0) goto werr;

        /* Iterate this DB writing every entry */
        while((de = dictNext(di)) != NULL) {
            sds keystr;
            robj...",1,12,aof.c,rewriteAppendOnlyFileRio,,false,2247,2348,rewriteAppendOnlyFileRio,,,65,int rewriteAppendOnlyFileRio (rio*)
26481,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp = NULL;
    char tmpfile[256];

    /* Note that we have to use a different temp name here compared to the
     * one used by rewriteAppendOnlyFileBackground() function. */
    snprintf(tmpfile,256,""temp-rewriteaof-%d.aof"", (int) getpid());
    fp = fopen(tmpfile,""w"");
    if (!fp) {
        serverLog(LL_WARNING, ""Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s"", strerror(errno));
        return C_ERR;
    }

    rioInitWithFile(&aof,fp);

    if (server.aof_rewrite_incremental_fsync) {
        rioSetAutoSync(&aof,REDIS_AUTOSYNC_BYTES);
        rioSetReclaimCache(&aof,1);
    }

    startSaving(RDBFLAGS_AOF_PREAMBLE);

    if (server.aof_use_rdb_preamble) {
        int error;
        if (rdbSaveRio(SLAVE_REQ_NONE,&aof,&error,RDBFLAGS_AOF_PREAMBLE,NULL) == C_ERR) {
            errno = error;
            goto werr;
        }
    } else {
        if (rewriteAppendOnlyFileRio(&aof) == C_ERR) goto ...",1,8,aof.c,rewriteAppendOnlyFile,,false,2357,2418,rewriteAppendOnlyFile,,,66,int rewriteAppendOnlyFile (char*)
26736,METHOD,aof.c:<global>,TYPE_DECL,"int rewriteAppendOnlyFileBackground(void) {
    pid_t childpid;

    if (hasActiveChildProcess()) return C_ERR;

    if (dirCreateIfMissing(server.aof_dirname) == -1) {
        serverLog(LL_WARNING, ""Can't open or create append-only dir %s: %s"",
            server.aof_dirname, strerror(errno));
        server.aof_lastbgrewrite_status = C_ERR;
        return C_ERR;
    }

    /* We set aof_selected_db to -1 in order to force the next call to the
     * feedAppendOnlyFile() to issue a SELECT command. */
    server.aof_selected_db = -1;
    flushAppendOnlyFile(1);
    if (openNewIncrAofForAppend() != C_OK) {
        server.aof_lastbgrewrite_status = C_ERR;
        return C_ERR;
    }
    server.stat_aof_rewrites++;
    if ((childpid = redisFork(CHILD_TYPE_AOF)) == 0) {
        char tmpfile[256];

        /* Child */
        redisSetProcTitle(""redis-aof-rewrite"");
        redisSetCpuAffinity(server.aof_rewrite_cpulist);
        snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) get...",1,40,aof.c,rewriteAppendOnlyFileBackground,,false,2437,2489,rewriteAppendOnlyFileBackground,,,67,int rewriteAppendOnlyFileBackground (void)
26968,METHOD,aof.c:<global>,TYPE_DECL,"void bgrewriteaofCommand(client *c) {
    if (server.child_type == CHILD_TYPE_AOF) {
        addReplyError(c,""Background append only file rewriting already in progress"");
    } else if (hasActiveChildProcess() || server.in_exec) {
        server.aof_rewrite_scheduled = 1;
        /* When manually triggering AOFRW we reset the count 
         * so that it can be executed immediately. */
        server.stat_aofrw_consecutive_failures = 0;
        addReplyStatus(c,""Background append only file rewriting scheduled"");
    } else if (rewriteAppendOnlyFileBackground() == C_OK) {
        addReplyStatus(c,""Background append only file rewriting started"");
    } else {
        addReplyError(c,""Can't execute an AOF background rewriting. ""
                        ""Please check the server logs for more information."");
    }
}",1,29,aof.c,bgrewriteaofCommand,,false,2491,2506,bgrewriteaofCommand,,,68,void bgrewriteaofCommand (client*)
27024,METHOD,aof.c:<global>,TYPE_DECL,"void aofRemoveTempFile(pid_t childpid) {
    char tmpfile[256];

    snprintf(tmpfile,256,""temp-rewriteaof-bg-%d.aof"", (int) childpid);
    bg_unlink(tmpfile);

    snprintf(tmpfile,256,""temp-rewriteaof-%d.aof"", (int) childpid);
    bg_unlink(tmpfile);
}",1,1,aof.c,aofRemoveTempFile,,false,2508,2516,aofRemoveTempFile,,,69,void aofRemoveTempFile (pid_t)
27048,METHOD,aof.c:<global>,TYPE_DECL,"off_t getAppendOnlyFileSize(sds filename, int *status) {
    struct redis_stat sb;
    off_t size;
    mstime_t latency;

    sds aof_filepath = makePath(server.aof_dirname, filename);
    latencyStartMonitor(latency);
    if (redis_stat(aof_filepath, &sb) == -1) {
        if (status) *status = errno == ENOENT ? AOF_NOT_EXIST : AOF_OPEN_ERR;
        serverLog(LL_WARNING, ""Unable to obtain the AOF file %s length. stat: %s"",
            filename, strerror(errno));
        size = 0;
    } else {
        if (status) *status = AOF_OK;
        size = sb.st_size;
    }
    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded(""aof-fstat"", latency);
    sdsfree(aof_filepath);
    return size;
}",1,11,aof.c,getAppendOnlyFileSize,,false,2521,2541,getAppendOnlyFileSize,,,70,"off_t getAppendOnlyFileSize (sds,int*)"
27183,METHOD,aof.c:<global>,TYPE_DECL,"off_t getBaseAndIncrAppendOnlyFilesSize(aofManifest *am, int *status) {
    off_t size = 0;
    listNode *ln;
    listIter li;

    if (am->base_aof_info) {
        serverAssert(am->base_aof_info->file_type == AOF_FILE_TYPE_BASE);

        size += getAppendOnlyFileSize(am->base_aof_info->file_name, status);
        if (*status != AOF_OK) return 0;
    }

    listRewind(am->incr_aof_list, &li);
    while ((ln = listNext(&li)) != NULL) {
        aofInfo *ai = (aofInfo*)ln->value;
        serverAssert(ai->file_type == AOF_FILE_TYPE_INCR);
        size += getAppendOnlyFileSize(ai->file_name, status);
        if (*status != AOF_OK) return 0;
    }

    return size;
}",1,8,aof.c,getBaseAndIncrAppendOnlyFilesSize,,false,2546,2567,getBaseAndIncrAppendOnlyFilesSize,,,71,"off_t getBaseAndIncrAppendOnlyFilesSize (aofManifest*,int*)"
27299,METHOD,aof.c:<global>,TYPE_DECL,"int getBaseAndIncrAppendOnlyFilesNum(aofManifest *am) {
    int num = 0;
    if (am->base_aof_info) num++;
    if (am->incr_aof_list) num += listLength(am->incr_aof_list);
    return num;
}",1,34,aof.c,getBaseAndIncrAppendOnlyFilesNum,,false,2569,2574,getBaseAndIncrAppendOnlyFilesNum,,,72,int getBaseAndIncrAppendOnlyFilesNum (aofManifest*)
27334,METHOD,aof.c:<global>,TYPE_DECL,"void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        char tmpfile[256];
        long long now = ustime();
        sds new_base_filepath = NULL;
        sds new_incr_filepath = NULL;
        aofManifest *temp_am;
        mstime_t latency;

        serverLog(LL_NOTICE,
            ""Background AOF rewrite terminated with success"");

        snprintf(tmpfile, 256, ""temp-rewriteaof-bg-%d.aof"",
            (int)server.child_pid);

        serverAssert(server.aof_manifest != NULL);

        /* Dup a temporary aof_manifest for subsequent modifications. */
        temp_am = aofManifestDup(server.aof_manifest);

        /* Get a new BASE file name and mark the previous (if we have)
         * as the HISTORY type. */
        sds new_base_filename = getNewBaseFileNameAndMarkPreAsHistory(temp_am);
        serverAssert(new_base_filename != NULL);
        new_base_filepath = makePath(server.aof_dirname, new_base_filename);

        /* Rename...",1,8,aof.c,backgroundRewriteDoneHandler,,false,2578,2738,backgroundRewriteDoneHandler,,,73,"void backgroundRewriteDoneHandler (int,int)"
28002,METHOD,asciilogo.h:<global>,TYPE_DECL,<global>,1,76,asciilogo.h,asciilogo.h:<global>,,false,1,47,<global>,,,1,
28019,METHOD,atomicvar.h:<global>,TYPE_DECL,<global>,1,21,atomicvar.h,atomicvar.h:<global>,,false,1,158,<global>,,,1,
28028,METHOD,bio.c:<global>,TYPE_DECL,<global>,1,1,bio.c,bio.c:<global>,,false,1,345,<global>,,,1,
28117,METHOD,<empty>,<empty>,<empty>,5,,bio.c,bio_job.free_args:<clinit>,,false,105,,<clinit>,,,4,
28124,METHOD,bio.c:<global>,TYPE_DECL,void *bioProcessBackgroundJobs(void *arg);,6,41,bio.c,bioProcessBackgroundJobs,,false,112,112,bioProcessBackgroundJobs,,,17,void* bioProcessBackgroundJobs (void*)
28129,METHOD,bio.c:<global>,TYPE_DECL,"void bioInit(void) {
    pthread_attr_t attr;
    pthread_t thread;
    size_t stacksize;
    unsigned long j;

    /* Initialization of state vars and objects */
    for (j = 0; j < BIO_WORKER_NUM; j++) {
        pthread_mutex_init(&bio_mutex[j],NULL);
        pthread_cond_init(&bio_newjob_cond[j],NULL);
        bio_jobs[j] = listCreate();
    }

    /* Set the stack size as by default it may be small in some system */
    pthread_attr_init(&attr);
    pthread_attr_getstacksize(&attr,&stacksize);
    if (!stacksize) stacksize = 1; /* The world is full of Solaris Fixes */
    while (stacksize < REDIS_THREAD_STACK_SIZE) stacksize *= 2;
    pthread_attr_setstacksize(&attr, stacksize);

    /* Ready to spawn our threads. We use the single argument the thread
     * function accepts in order to pass the job ID the thread is
     * responsible for. */
    for (j = 0; j < BIO_WORKER_NUM; j++) {
        void *arg = (void*)(unsigned long) j;
        if (pthread_create(&thread,&attr,bioProce...",1,20,bio.c,bioInit,,false,119,150,bioInit,,,18,void bioInit (void)
28269,METHOD,bio.c:<global>,TYPE_DECL,"void bioSubmitJob(int type, bio_job *job) {
    job->header.type = type;
    unsigned long worker = bio_job_to_worker[type];
    pthread_mutex_lock(&bio_mutex[worker]);
    listAddNodeTail(bio_jobs[worker],job);
    bio_jobs_counter[type]++;
    pthread_cond_signal(&bio_newjob_cond[worker]);
    pthread_mutex_unlock(&bio_mutex[worker]);
}",1,1,bio.c,bioSubmitJob,,false,152,160,bioSubmitJob,,,19,"void bioSubmitJob (int,bio_job*)"
28312,METHOD,bio.c:<global>,TYPE_DECL,"void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...) {
    va_list valist;
    /* Allocate memory for the job structure and all required
     * arguments */
    bio_job *job = zmalloc(sizeof(*job) + sizeof(void *) * (arg_count));
    job->free_args.free_fn = free_fn;

    va_start(valist, arg_count);
    for (int i = 0; i < arg_count; i++) {
        job->free_args.free_args[i] = va_arg(valist, void *);
    }
    va_end(valist);
    bioSubmitJob(BIO_LAZY_FREE, job);
}",1,1,bio.c,bioCreateLazyFreeJob,,false,162,175,bioCreateLazyFreeJob,,,20,"void bioCreateLazyFreeJob (lazy_free_fn,int...)"
28359,METHOD,bio.c:<global>,TYPE_DECL,"void bioCreateCloseJob(int fd, int need_fsync, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.need_fsync = need_fsync;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_CLOSE_FILE, job);
}",1,1,bio.c,bioCreateCloseJob,,false,177,184,bioCreateCloseJob,,,21,"void bioCreateCloseJob (int,int,int)"
28397,METHOD,bio.c:<global>,TYPE_DECL,"void bioCreateCloseAofJob(int fd, long long offset, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.offset = offset;
    job->fd_args.need_fsync = 1;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_CLOSE_AOF, job);
}",1,1,bio.c,bioCreateCloseAofJob,,false,186,194,bioCreateCloseAofJob,,,22,"void bioCreateCloseAofJob (int,long long,int)"
28442,METHOD,bio.c:<global>,TYPE_DECL,"void bioCreateFsyncJob(int fd, long long offset, int need_reclaim_cache) {
    bio_job *job = zmalloc(sizeof(*job));
    job->fd_args.fd = fd;
    job->fd_args.offset = offset;
    job->fd_args.need_reclaim_cache = need_reclaim_cache;

    bioSubmitJob(BIO_AOF_FSYNC, job);
}",1,1,bio.c,bioCreateFsyncJob,,false,196,203,bioCreateFsyncJob,,,23,"void bioCreateFsyncJob (int,long long,int)"
28480,METHOD,bio.c:<global>,TYPE_DECL,"void *bioProcessBackgroundJobs(void *arg) {
    bio_job *job;
    unsigned long worker = (unsigned long) arg;
    sigset_t sigset;

    /* Check that the worker is within the right interval. */
    serverAssert(worker < BIO_WORKER_NUM);

    redis_set_thread_title(bio_worker_title[worker]);

    redisSetCpuAffinity(server.bio_cpulist);

    makeThreadKillable();

    pthread_mutex_lock(&bio_mutex[worker]);
    /* Block SIGALRM so we are sure that only the main thread will
     * receive the watchdog signal. */
    sigemptyset(&sigset);
    sigaddset(&sigset, SIGALRM);
    if (pthread_sigmask(SIG_BLOCK, &sigset, NULL))
        serverLog(LL_WARNING,
            ""Warning: can't mask SIGALRM in bio.c thread: %s"", strerror(errno));

    while(1) {
        listNode *ln;

        /* The loop always starts with the lock hold. */
        if (listLength(bio_jobs[worker]) == 0) {
            pthread_cond_wait(&bio_newjob_cond[worker], &bio_mutex[worker]);
            continue;
        }
      ...",1,4,bio.c,bioProcessBackgroundJobs,,false,205,300,bioProcessBackgroundJobs,,,24,void* bioProcessBackgroundJobs (void*)
28920,METHOD,bio.c:<global>,TYPE_DECL,"unsigned long bioPendingJobsOfType(int type) {
    unsigned int worker = bio_job_to_worker[type];

    pthread_mutex_lock(&bio_mutex[worker]);
    unsigned long val = bio_jobs_counter[type];
    pthread_mutex_unlock(&bio_mutex[worker]);

    return val;
}",1,1,bio.c,bioPendingJobsOfType,,false,303,311,bioPendingJobsOfType,,,25,unsigned long bioPendingJobsOfType (int)
28949,METHOD,bio.c:<global>,TYPE_DECL,"void bioDrainWorker(int job_type) {
    unsigned long worker = bio_job_to_worker[job_type];

    pthread_mutex_lock(&bio_mutex[worker]);
    while (listLength(bio_jobs[worker]) > 0) {
        pthread_cond_wait(&bio_newjob_cond[worker], &bio_mutex[worker]);
    }
    pthread_mutex_unlock(&bio_mutex[worker]);
}",1,11,bio.c,bioDrainWorker,,false,314,322,bioDrainWorker,,,26,void bioDrainWorker (int)
28993,METHOD,bio.c:<global>,TYPE_DECL,"void bioKillThreads(void) {
    int err;
    unsigned long j;

    for (j = 0; j < BIO_WORKER_NUM; j++) {
        if (bio_threads[j] == pthread_self()) continue;
        if (bio_threads[j] && pthread_cancel(bio_threads[j]) == 0) {
            if ((err = pthread_join(bio_threads[j],NULL)) != 0) {
                serverLog(LL_WARNING,
                    ""Bio worker thread #%lu can not be joined: %s"",
                        j, strerror(err));
            } else {
                serverLog(LL_WARNING,
                    ""Bio worker thread #%lu terminated"",j);
            }
        }
    }
}",1,20,bio.c,bioKillThreads,,false,328,345,bioKillThreads,,,27,void bioKillThreads (void)
29094,METHOD,bio.h:<global>,TYPE_DECL,<global>,1,6,bio.h,bio.h:<global>,,false,1,54,<global>,,,1,
29096,METHOD,bio.h:<global>,TYPE_DECL,typedef void lazy_free_fn(void *args[]);,14,39,bio.h,lazy_free_fn,,false,33,33,lazy_free_fn,,,1,void lazy_free_fn (void[]*)
29101,METHOD,bio.h:<global>,TYPE_DECL,void bioInit(void);,6,18,bio.h,bioInit,,false,36,36,bioInit,,,2,void bioInit (void)
29106,METHOD,bio.h:<global>,TYPE_DECL,unsigned long bioPendingJobsOfType(int type);,15,44,bio.h,bioPendingJobsOfType,,false,37,37,bioPendingJobsOfType,,,3,long unsigned bioPendingJobsOfType (int)
29111,METHOD,bio.h:<global>,TYPE_DECL,void bioDrainWorker(int job_type);,6,33,bio.h,bioDrainWorker,,false,38,38,bioDrainWorker,,,4,void bioDrainWorker (int)
29116,METHOD,bio.h:<global>,TYPE_DECL,void bioKillThreads(void);,6,25,bio.h,bioKillThreads,,false,39,39,bioKillThreads,,,5,void bioKillThreads (void)
29121,METHOD,bio.h:<global>,TYPE_DECL,"void bioCreateCloseJob(int fd, int need_fsync, int need_reclaim_cache);",6,70,bio.h,bioCreateCloseJob,,false,40,40,bioCreateCloseJob,,,6,"void bioCreateCloseJob (int,int,int)"
29128,METHOD,bio.h:<global>,TYPE_DECL,"void bioCreateCloseAofJob(int fd, long long offset, int need_reclaim_cache);",6,75,bio.h,bioCreateCloseAofJob,,false,41,41,bioCreateCloseAofJob,,,7,"void bioCreateCloseAofJob (int,long long,int)"
29135,METHOD,bio.h:<global>,TYPE_DECL,"void bioCreateFsyncJob(int fd, long long offset, int need_reclaim_cache);",6,72,bio.h,bioCreateFsyncJob,,false,42,42,bioCreateFsyncJob,,,8,"void bioCreateFsyncJob (int,long long,int)"
29142,METHOD,bio.h:<global>,TYPE_DECL,"void bioCreateLazyFreeJob(lazy_free_fn free_fn, int arg_count, ...);",6,67,bio.h,bioCreateLazyFreeJob,,false,43,43,bioCreateLazyFreeJob,,,9,"void bioCreateLazyFreeJob (lazy_free_fn,int...)"
29154,METHOD,<empty>,<empty>,<empty>,1,,bio.h,anonymous_enum_0:<clinit>,,false,46,,<clinit>,,,6,
29166,METHOD,bitops.c:<global>,TYPE_DECL,<global>,1,1,bitops.c,bitops.c:<global>,,false,1,1267,<global>,,,1,
29168,METHOD,bitops.c:<global>,TYPE_DECL,"long long redisPopcount(void *s, long count) {
    long long bits = 0;
    unsigned char *p = s;
    uint32_t *p4;
    static const unsigned char bitsinbyte[256] = {0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8};

    /* Count initial bytes not aligned to 32 bit. */
    while((unsigned long)p & 3 && count) {
        bits += bitsinbyte[*p++];
        count--;
    }

    /* Count bits 28 bytes at a time */
    p4 = (uint32_t*)p;
    while(count>=28) {
        uint32_t aux1, aux2, aux3, aux4, aux5, aux6, aux7;

        aux1 = *p...",1,1,bitops.c,redisPopcount,,false,40,92,redisPopcount,,,1,"long long redisPopcount (void*,long)"
29734,METHOD,bitops.c:<global>,TYPE_DECL,"long long redisBitpos(void *s, unsigned long count, int bit) {
    unsigned long *l;
    unsigned char *c;
    unsigned long skipval, word = 0, one;
    long long pos = 0; /* Position of bit, to return to the caller. */
    unsigned long j;
    int found;

    /* Process whole words first, seeking for first word that is not
     * all ones or all zeros respectively if we are looking for zeros
     * or ones. This is much faster with large strings having contiguous
     * blocks of 1 or 0 bits compared to the vanilla bit per bit processing.
     *
     * Note that if we start from an address that is not aligned
     * to sizeof(unsigned long) we consume it byte by byte until it is
     * aligned. */

    /* Skip initial bits not aligned to sizeof(unsigned long) byte by byte. */
    skipval = bit ? 0 : UCHAR_MAX;
    c = (unsigned char*) s;
    found = 0;
    while((unsigned long)c & (sizeof(*l)-1) && count) {
        if (*c != skipval) {
            found = 1;
            break;
    ...",1,4,bitops.c,redisBitpos,,false,101,186,redisBitpos,,,2,"long long redisBitpos (void*,long unsigned,int)"
29925,METHOD,bitops.c:<global>,TYPE_DECL,"void setUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, uint64_t value) {
    uint64_t byte, bit, byteval, bitval, j;

    for (j = 0; j < bits; j++) {
        bitval = (value & ((uint64_t)1<<(bits-1-j))) != 0;
        byte = offset >> 3;
        bit = 7 - (offset & 0x7);
        byteval = p[byte];
        byteval &= ~(1 << bit);
        byteval |= bitval << bit;
        p[byte] = byteval & 0xff;
        offset++;
    }
}",1,1,bitops.c,setUnsignedBitfield,,false,209,222,setUnsignedBitfield,,,3,"void setUnsignedBitfield (unsigned char*,uint64_t,uint64_t,uint64_t)"
30001,METHOD,bitops.c:<global>,TYPE_DECL,"void setSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits, int64_t value) {
    uint64_t uv = value; /* Casting will add UINT64_MAX + 1 if v is negative. */
    setUnsignedBitfield(p,offset,bits,uv);
}",1,1,bitops.c,setSignedBitfield,,false,224,227,setSignedBitfield,,,4,"void setSignedBitfield (unsigned char*,uint64_t,uint64_t,int64_t)"
30018,METHOD,bitops.c:<global>,TYPE_DECL,"uint64_t getUnsignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
    uint64_t byte, bit, byteval, bitval, j, value = 0;

    for (j = 0; j < bits; j++) {
        byte = offset >> 3;
        bit = 7 - (offset & 0x7);
        byteval = p[byte];
        bitval = (byteval >> bit) & 1;
        value = (value<<1) | bitval;
        offset++;
    }
    return value;
}",1,1,bitops.c,getUnsignedBitfield,,false,229,241,getUnsignedBitfield,,,5,"uint64_t getUnsignedBitfield (unsigned char*,uint64_t,uint64_t)"
30080,METHOD,bitops.c:<global>,TYPE_DECL,"int64_t getSignedBitfield(unsigned char *p, uint64_t offset, uint64_t bits) {
    int64_t value;
    union {uint64_t u; int64_t i;} conv;

    /* Converting from unsigned to signed is undefined when the value does
     * not fit, however here we assume two's complement and the original value
     * was obtained from signed -> unsigned conversion, so we'll find the
     * most significant bit set if the original value was negative.
     *
     * Note that two's complement is mandatory for exact-width types
     * according to the C99 standard. */
    conv.u = getUnsignedBitfield(p,offset,bits);
    value = conv.i;

    /* If the top significant bit is 1, propagate it to all the
     * higher bits for two's complement representation of signed
     * integers. */
    if (bits < 64 && (value & ((uint64_t)1 << (bits-1))))
        value |= ((uint64_t)-1) << bits;
    return value;
}",1,1,bitops.c,getSignedBitfield,,false,243,263,getSignedBitfield,,,6,"int64_t getSignedBitfield (unsigned char*,uint64_t,uint64_t)"
30126,METHOD,bitops.c:<global>,TYPE_DECL,"int checkUnsignedBitfieldOverflow(uint64_t value, int64_t incr, uint64_t bits, int owtype, uint64_t *limit) {
    uint64_t max = (bits == 64) ? UINT64_MAX : (((uint64_t)1<<bits)-1);
    int64_t maxincr = max-value;
    int64_t minincr = -value;

    if (value > max || (incr > 0 && incr > maxincr)) {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = max;
            }
        }
        return 1;
    } else if (incr < 0 && incr < minincr) {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = 0;
            }
        }
        return -1;
    }
    return 0;

handle_wrap:
    {
        uint64_t mask = ((uint64_t)-1) << bits;
        uint64_t res = value+incr;

        res &= ~mask;
        *limit = res;
    }
    return 1;
}",1,26,bitops.c,checkUnsignedBitfieldOverflow,,false,288,323,checkUnsignedBitfieldOverflow,,,7,"int checkUnsignedBitfieldOverflow (uint64_t,int64_t,uint64_t,int,uint64_t*)"
30266,METHOD,bitops.c:<global>,TYPE_DECL,"int checkSignedBitfieldOverflow(int64_t value, int64_t incr, uint64_t bits, int owtype, int64_t *limit) {
    int64_t max = (bits == 64) ? INT64_MAX : (((int64_t)1<<(bits-1))-1);
    int64_t min = (-max)-1;

    /* Note that maxincr and minincr could overflow, but we use the values
     * only after checking 'value' range, so when we use it no overflow
     * happens. 'uint64_t' cast is there just to prevent undefined behavior on
     * overflow */
    int64_t maxincr = (uint64_t)max-value;
    int64_t minincr = min-value;

    if (value > max || (bits != 64 && incr > maxincr) || (value >= 0 && incr > 0 && incr > maxincr))
    {
        if (limit) {
            if (owtype == BFOVERFLOW_WRAP) {
                goto handle_wrap;
            } else if (owtype == BFOVERFLOW_SAT) {
                *limit = max;
            }
        }
        return 1;
    } else if (value < min || (bits != 64 && incr < minincr) || (value < 0 && incr < 0 && incr < minincr)) {
        if (limit) {
       ...",1,26,bitops.c,checkSignedBitfieldOverflow,,false,325,378,checkSignedBitfieldOverflow,,,8,"int checkSignedBitfieldOverflow (int64_t,int64_t,uint64_t,int,int64_t*)"
30479,METHOD,bitops.c:<global>,TYPE_DECL,"void printBits(unsigned char *p, unsigned long count) {
    unsigned long j, i, byte;

    for (j = 0; j < count; j++) {
        byte = p[j];
        for (i = 0x80; i > 0; i /= 2)
            printf(""%c"", (byte & i) ? '1' : '0');
        printf(""|"");
    }
    printf(""\n"");
}",1,1,bitops.c,printBits,,false,382,392,printBits,,,9,"void printBits (unsigned char*,long unsigned)"
30527,METHOD,bitops.c:<global>,TYPE_DECL,"int getBitOffsetFromArgument(client *c, robj *o, uint64_t *offset, int hash, int bits) {
    long long loffset;
    char *err = ""bit offset is not an integer or out of range"";
    char *p = o->ptr;
    size_t plen = sdslen(p);
    int usehash = 0;

    /* Handle #<offset> form. */
    if (p[0] == '#' && hash && bits > 0) usehash = 1;

    if (string2ll(p+usehash,plen-usehash,&loffset) == 0) {
        addReplyError(c,err);
        return C_ERR;
    }

    /* Adjust the offset by 'bits' for #<offset> form. */
    if (usehash) loffset *= bits;

    /* Limit offset to server.proto_max_bulk_len (512MB in bytes by default) */
    if (loffset < 0 || (!mustObeyClient(c) && (loffset >> 3) >= server.proto_max_bulk_len))
    {
        addReplyError(c,err);
        return C_ERR;
    }

    *offset = loffset;
    return C_OK;
}",1,15,bitops.c,getBitOffsetFromArgument,,false,414,441,getBitOffsetFromArgument,,,10,"int getBitOffsetFromArgument (client*,robj*,uint64_t*,int,int)"
30632,METHOD,bitops.c:<global>,TYPE_DECL,"int getBitfieldTypeFromArgument(client *c, robj *o, int *sign, int *bits) {
    char *p = o->ptr;
    char *err = ""Invalid bitfield type. Use something like i16 u8. Note that u64 is not supported but i64 is."";
    long long llbits;

    if (p[0] == 'i') {
        *sign = 1;
    } else if (p[0] == 'u') {
        *sign = 0;
    } else {
        addReplyError(c,err);
        return C_ERR;
    }

    if ((string2ll(p+1,strlen(p+1),&llbits)) == 0 ||
        llbits < 1 ||
        (*sign == 1 && llbits > 64) ||
        (*sign == 0 && llbits > 63))
    {
        addReplyError(c,err);
        return C_ERR;
    }
    *bits = llbits;
    return C_OK;
}",1,15,bitops.c,getBitfieldTypeFromArgument,,false,450,474,getBitfieldTypeFromArgument,,,11,"int getBitfieldTypeFromArgument (client*,robj*,int*,int*)"
30737,METHOD,bitops.c:<global>,TYPE_DECL,"robj *lookupStringForBitCommand(client *c, uint64_t maxbit, int *dirty) {
    size_t byte = maxbit >> 3;
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return NULL;
    if (dirty) *dirty = 0;

    if (o == NULL) {
        o = createObject(OBJ_STRING,sdsnewlen(NULL, byte+1));
        dbAdd(c->db,c->argv[1],o);
        if (dirty) *dirty = 1;
    } else {
        o = dbUnshareStringValue(c->db,c->argv[1],o);
        size_t oldlen = sdslen(o->ptr);
        o->ptr = sdsgrowzero(o->ptr,byte+1);
        if (dirty && oldlen != sdslen(o->ptr)) *dirty = 1;
    }
    return o;
}",1,22,bitops.c,lookupStringForBitCommand,,false,481,498,lookupStringForBitCommand,,,12,"robj lookupStringForBitCommand (client*,uint64_t,int*)"
30860,METHOD,bitops.c:<global>,TYPE_DECL,"unsigned char *getObjectReadOnlyString(robj *o, long *len, char *llbuf) {
    serverAssert(!o || o->type == OBJ_STRING);
    unsigned char *p = NULL;

    /* Set the 'p' pointer to the string, that can be just a stack allocated
     * array if our string was integer encoded. */
    if (o && o->encoding == OBJ_ENCODING_INT) {
        p = (unsigned char*) llbuf;
        if (len) *len = ll2string(llbuf,LONG_STR_SIZE,(long)o->ptr);
    } else if (o) {
        p = (unsigned char*) o->ptr;
        if (len) *len = sdslen(o->ptr);
    } else {
        if (len) *len = 0;
    }
    return p;
}",1,4,bitops.c,getObjectReadOnlyString,,false,513,529,getObjectReadOnlyString,,,13,"unsigned char* getObjectReadOnlyString (robj*,long*,char*)"
30957,METHOD,bitops.c:<global>,TYPE_DECL,"void setbitCommand(client *c) {
    robj *o;
    char *err = ""bit is not an integer or out of range"";
    uint64_t bitoffset;
    ssize_t byte, bit;
    int byteval, bitval;
    long on;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if (getLongFromObjectOrReply(c,c->argv[3],&on,err) != C_OK)
        return;

    /* Bits can only be set or cleared... */
    if (on & ~1) {
        addReplyError(c,err);
        return;
    }

    int dirty;
    if ((o = lookupStringForBitCommand(c,bitoffset,&dirty)) == NULL) return;

    /* Get current values */
    byte = bitoffset >> 3;
    byteval = ((uint8_t*)o->ptr)[byte];
    bit = 7 - (bitoffset & 0x7);
    bitval = byteval & (1 << bit);

    /* Either it is newly created, changed length, or the bit changes before and after.
     * Note that the bitval here is actually a decimal number.
     * So we need to use `!!` to convert it to 0 or 1 for comparison. */
    if (dirty || (!!bitval != on)) {
    ...",1,65,bitops.c,setbitCommand,,false,532,576,setbitCommand,,,14,void setbitCommand (client*)
31131,METHOD,bitops.c:<global>,TYPE_DECL,"void getbitCommand(client *c) {
    robj *o;
    char llbuf[32];
    uint64_t bitoffset;
    size_t byte, bit;
    size_t bitval = 0;

    if (getBitOffsetFromArgument(c,c->argv[2],&bitoffset,0,0) != C_OK)
        return;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;

    byte = bitoffset >> 3;
    bit = 7 - (bitoffset & 0x7);
    if (sdsEncodedObject(o)) {
        if (byte < sdslen(o->ptr))
            bitval = ((uint8_t*)o->ptr)[byte] & (1 << bit);
    } else {
        if (byte < (size_t)ll2string(llbuf,sizeof(llbuf),(long)o->ptr))
            bitval = llbuf[byte] & (1 << bit);
    }

    addReply(c, bitval ? shared.cone : shared.czero);
}",1,65,bitops.c,getbitCommand,,false,579,603,getbitCommand,,,15,void getbitCommand (client*)
31272,METHOD,bitops.c:<global>,TYPE_DECL,"void bitopCommand(client *c) {
    char *opname = c->argv[1]->ptr;
    robj *o, *targetkey = c->argv[2];
    unsigned long op, j, numkeys;
    robj **objects;      /* Array of source objects. */
    unsigned char **src; /* Array of source strings pointers. */
    unsigned long *len, maxlen = 0; /* Array of length of src strings,
                                       and max len. */
    unsigned long minlen = 0;    /* Min len among the input keys. */
    unsigned char *res = NULL; /* Resulting string. */

    /* Parse the operation name. */
    if ((opname[0] == 'a' || opname[0] == 'A') && !strcasecmp(opname,""and""))
        op = BITOP_AND;
    else if((opname[0] == 'o' || opname[0] == 'O') && !strcasecmp(opname,""or""))
        op = BITOP_OR;
    else if((opname[0] == 'x' || opname[0] == 'X') && !strcasecmp(opname,""xor""))
        op = BITOP_XOR;
    else if((opname[0] == 'n' || opname[0] == 'N') && !strcasecmp(opname,""not""))
        op = BITOP_NOT;
    else {
        addReplyErrorObje...",1,13,bitops.c,bitopCommand,,false,607,793,bitopCommand,,,16,void bitopCommand (client*)
32170,METHOD,bitops.c:<global>,TYPE_DECL,"void bitcountCommand(client *c) {
    robj *o;
    long long start, end;
    long strlen;
    unsigned char *p;
    char llbuf[LONG_STR_SIZE];
    int isbit = 0;
    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;

    /* Lookup, check for type, and return 0 for non existing keys. */
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;
    p = getObjectReadOnlyString(o,&strlen,llbuf);

    /* Parse start/end range if any. */
    if (c->argc == 4 || c->argc == 5) {
        long long totlen = strlen;
        /* Make sure we will not overflow */
        serverAssert(totlen <= LLONG_MAX >> 3);
        if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
            return;
        if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
            return;
        /* Convert negative indexes */
        if (start < 0 && end < 0 && start > end) {
            addReply(c,shared.czero);
    ...",1,15,bitops.c,bitcountCommand,,false,796,874,bitcountCommand,,,17,void bitcountCommand (client*)
32555,METHOD,bitops.c:<global>,TYPE_DECL,"void bitposCommand(client *c) {
    robj *o;
    long long start, end;
    long bit, strlen;
    unsigned char *p;
    char llbuf[LONG_STR_SIZE];
    int isbit = 0, end_given = 0;
    unsigned char first_byte_neg_mask = 0, last_byte_neg_mask = 0;

    /* Parse the bit argument to understand what we are looking for, set
     * or clear bits. */
    if (getLongFromObjectOrReply(c,c->argv[2],&bit,NULL) != C_OK)
        return;
    if (bit != 0 && bit != 1) {
        addReplyError(c, ""The bit argument must be 1 or 0."");
        return;
    }

    /* If the key does not exist, from our point of view it is an infinite
     * array of 0 bits. If the user is looking for the first clear bit return 0,
     * If the user is looking for the first set bit, return -1. */
    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
        addReplyLongLong(c, bit ? -1 : 0);
        return;
    }
    if (checkType(c,o,OBJ_STRING)) return;
    p = getObjectReadOnlyString(o,&strlen,llbuf);

    /* Parse ...",1,15,bitops.c,bitposCommand,,false,877,1003,bitposCommand,,,18,void bitposCommand (client*)
33129,METHOD,bitops.c:<global>,TYPE_DECL,"void bitfieldGeneric(client *c, int flags) {
    robj *o;
    uint64_t bitoffset;
    int j, numops = 0, changes = 0, dirty = 0;
    struct bitfieldOp *ops = NULL; /* Array of ops to execute at end. */
    int owtype = BFOVERFLOW_WRAP; /* Overflow type. */
    int readonly = 1;
    uint64_t highest_write_offset = 0;

    for (j = 2; j < c->argc; j++) {
        int remargs = c->argc-j-1; /* Remaining args other than current. */
        char *subcmd = c->argv[j]->ptr; /* Current command name. */
        int opcode; /* Current operation code. */
        long long i64 = 0;  /* Signed SET value. */
        int sign = 0; /* Signed or unsigned type? */
        int bits = 0; /* Bitfield width in bits. */

        if (!strcasecmp(subcmd,""get"") && remargs >= 2)
            opcode = BITFIELDOP_GET;
        else if (!strcasecmp(subcmd,""set"") && remargs >= 3)
            opcode = BITFIELDOP_SET;
        else if (!strcasecmp(subcmd,""incrby"") && remargs >= 3)
            opcode = BITFIELDOP_INCRBY...",1,17,bitops.c,bitfieldGeneric,,false,1030,1259,bitfieldGeneric,,,20,"void bitfieldGeneric (client*,int)"
34005,METHOD,bitops.c:<global>,TYPE_DECL,"void bitfieldCommand(client *c) {
    bitfieldGeneric(c, BITFIELD_FLAG_NONE);
}",1,23,bitops.c,bitfieldCommand,,false,1261,1263,bitfieldCommand,,,21,void bitfieldCommand (client*)
34015,METHOD,bitops.c:<global>,TYPE_DECL,"void bitfieldroCommand(client *c) {
    bitfieldGeneric(c, BITFIELD_FLAG_READONLY);
}",1,23,bitops.c,bitfieldroCommand,,false,1265,1267,bitfieldroCommand,,,22,void bitfieldroCommand (client*)
34038,METHOD,blocked.c:<global>,TYPE_DECL,<global>,1,1,blocked.c,blocked.c:<global>,,false,1,763,<global>,,,1,
34040,METHOD,blocked.c:<global>,TYPE_DECL,static void unblockClientWaitingData(client *c);,13,47,blocked.c,unblockClientWaitingData,,false,69,69,unblockClientWaitingData,,,1,void unblockClientWaitingData (client*)
34045,METHOD,blocked.c:<global>,TYPE_DECL,static void handleClientsBlockedOnKey(readyList *rl);,13,52,blocked.c,handleClientsBlockedOnKey,,false,70,70,handleClientsBlockedOnKey,,,2,void handleClientsBlockedOnKey (readyList*)
34050,METHOD,blocked.c:<global>,TYPE_DECL,"static void unblockClientOnKey(client *c, robj *key);",13,52,blocked.c,unblockClientOnKey,,false,71,71,unblockClientOnKey,,,3,"void unblockClientOnKey (client*,robj*)"
34056,METHOD,blocked.c:<global>,TYPE_DECL,"static void moduleUnblockClientOnKey(client *c, robj *key);",13,58,blocked.c,moduleUnblockClientOnKey,,false,72,72,moduleUnblockClientOnKey,,,4,"void moduleUnblockClientOnKey (client*,robj*)"
34062,METHOD,blocked.c:<global>,TYPE_DECL,"static void releaseBlockedEntry(client *c, dictEntry *de, int remove_key);",13,73,blocked.c,releaseBlockedEntry,,false,73,73,releaseBlockedEntry,,,5,"void releaseBlockedEntry (client*,dictEntry*,int)"
34069,METHOD,blocked.c:<global>,TYPE_DECL,"void initClientBlockingState(client *c) {
    c->bstate.btype = BLOCKED_NONE;
    c->bstate.timeout = 0;
    c->bstate.keys = dictCreate(&objectKeyHeapPointerValueDictType);
    c->bstate.numreplicas = 0;
    c->bstate.reploffset = 0;
    c->bstate.unblock_on_nokey = 0;
    c->bstate.async_rm_call_handle = NULL;
}",1,1,blocked.c,initClientBlockingState,,false,75,83,initClientBlockingState,,,6,void initClientBlockingState (client*)
34125,METHOD,blocked.c:<global>,TYPE_DECL,"void blockClient(client *c, int btype) {
    /* Master client should never be blocked unless pause or module */
    serverAssert(!(c->flags & CLIENT_MASTER &&
                   btype != BLOCKED_MODULE &&
                   btype != BLOCKED_POSTPONE));

    c->flags |= CLIENT_BLOCKED;
    c->bstate.btype = btype;
    if (!(c->flags & CLIENT_MODULE)) server.blocked_clients++; /* We count blocked client stats on regular clients and not on module clients */
    server.blocked_clients_by_type[btype]++;
    addClientToTimeoutTable(c);
}",1,4,blocked.c,blockClient,,false,88,99,blockClient,,,7,"void blockClient (client*,int)"
34200,METHOD,blocked.c:<global>,TYPE_DECL,"void updateStatsOnUnblock(client *c, long blocked_us, long reply_us, int had_errors){
    const ustime_t total_cmd_duration = c->duration + blocked_us + reply_us;
    c->lastcmd->microseconds += total_cmd_duration;
    c->lastcmd->calls++;
    server.stat_numcommands++;
    if (had_errors)
        c->lastcmd->failed_calls++;
    if (server.latency_tracking_enabled)
        updateCommandLatencyHistogram(&(c->lastcmd->latency_histogram), total_cmd_duration*1000);
    /* Log the command into the Slow log if needed. */
    slowlogPushCurrentCommand(c, c->lastcmd, total_cmd_duration);
    c->duration = 0;
    /* Log the reply duration event. */
    latencyAddSampleIfNeeded(""command-unblocking"",reply_us/1000);
}",1,4,blocked.c,updateStatsOnUnblock,,false,106,120,updateStatsOnUnblock,,,8,"void updateStatsOnUnblock (client*,long,long,int)"
34291,METHOD,blocked.c:<global>,TYPE_DECL,"void processUnblockedClients(void) {
    listNode *ln;
    client *c;

    while (listLength(server.unblocked_clients)) {
        ln = listFirst(server.unblocked_clients);
        serverAssert(ln != NULL);
        c = ln->value;
        listDelNode(server.unblocked_clients,ln);
        c->flags &= ~CLIENT_UNBLOCKED;

        if (c->flags & CLIENT_MODULE) {
            if (!(c->flags & CLIENT_BLOCKED)) {
                moduleCallCommandUnblockedHandler(c);
            }
            continue;
        }

        /* Process remaining data in the input buffer, unless the client
         * is blocked again. Actually processInputBuffer() checks that the
         * client is not blocked before to proceed, but things may change and
         * the code is conceptually more correct this way. */
        if (!(c->flags & CLIENT_BLOCKED)) {
            /* If we have a queued command, execute it now. */
            if (processPendingCommandAndInputBuffer(c) == C_ERR) {
                c = NULL;
 ...",1,11,blocked.c,processUnblockedClients,,false,125,155,processUnblockedClients,,,9,void processUnblockedClients (void)
34410,METHOD,blocked.c:<global>,TYPE_DECL,"void queueClientForReprocessing(client *c) {
    /* The client may already be into the unblocked list because of a previous
     * blocking operation, don't add back it into the list multiple times. */
    if (!(c->flags & CLIENT_UNBLOCKED)) {
        c->flags |= CLIENT_UNBLOCKED;
        listAddNodeTail(server.unblocked_clients,c);
    }
}",1,21,blocked.c,queueClientForReprocessing,,false,173,180,queueClientForReprocessing,,,10,void queueClientForReprocessing (client*)
34441,METHOD,blocked.c:<global>,TYPE_DECL,"void unblockClient(client *c, int queue_for_reprocessing) {
    if (c->bstate.btype == BLOCKED_LIST ||
        c->bstate.btype == BLOCKED_ZSET ||
        c->bstate.btype == BLOCKED_STREAM) {
        unblockClientWaitingData(c);
    } else if (c->bstate.btype == BLOCKED_WAIT || c->bstate.btype == BLOCKED_WAITAOF) {
        unblockClientWaitingReplicas(c);
    } else if (c->bstate.btype == BLOCKED_MODULE) {
        if (moduleClientIsBlockedOnKeys(c)) unblockClientWaitingData(c);
        unblockClientFromModule(c);
    } else if (c->bstate.btype == BLOCKED_POSTPONE) {
        listDelNode(server.postponed_clients,c->postponed_list_node);
        c->postponed_list_node = NULL;
    } else if (c->bstate.btype == BLOCKED_SHUTDOWN) {
        /* No special cleanup. */
    } else {
        serverPanic(""Unknown btype in unblockClient()."");
    }

    /* Reset the client for a new query, unless the client has pending command to process
     * or in case a shutdown operation was canceled and we a...",1,8,blocked.c,unblockClient,,false,184,224,unblockClient,,,11,"void unblockClient (client*,int)"
34641,METHOD,blocked.c:<global>,TYPE_DECL,"void replyToBlockedClientTimedOut(client *c) {
    if (c->bstate.btype == BLOCKED_LIST ||
        c->bstate.btype == BLOCKED_ZSET ||
        c->bstate.btype == BLOCKED_STREAM) {
        addReplyNullArray(c);
        updateStatsOnUnblock(c, 0, 0, 0);
    } else if (c->bstate.btype == BLOCKED_WAIT) {
        addReplyLongLong(c,replicationCountAcksByOffset(c->bstate.reploffset));
    } else if (c->bstate.btype == BLOCKED_WAITAOF) {
        addReplyArrayLen(c,2);
        addReplyLongLong(c,server.fsynced_reploff >= c->bstate.reploffset);
        addReplyLongLong(c,replicationCountAOFAcksByOffset(c->bstate.reploffset));
    } else if (c->bstate.btype == BLOCKED_MODULE) {
        moduleBlockedClientTimedOut(c);
    } else {
        serverPanic(""Unknown btype in replyToBlockedClientTimedOut()."");
    }
}",1,8,blocked.c,replyToBlockedClientTimedOut,,false,229,246,replyToBlockedClientTimedOut,,,12,void replyToBlockedClientTimedOut (client*)
34753,METHOD,blocked.c:<global>,TYPE_DECL,"void replyToClientsBlockedOnShutdown(void) {
    if (server.blocked_clients_by_type[BLOCKED_SHUTDOWN] == 0) return;
    listNode *ln;
    listIter li;
    listRewind(server.clients, &li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        if (c->flags & CLIENT_BLOCKED && c->bstate.btype == BLOCKED_SHUTDOWN) {
            addReplyError(c, ""Errors trying to SHUTDOWN. Check logs."");
            unblockClient(c, 1);
        }
    }
}",1,20,blocked.c,replyToClientsBlockedOnShutdown,,false,250,262,replyToClientsBlockedOnShutdown,,,13,void replyToClientsBlockedOnShutdown (void)
34817,METHOD,blocked.c:<global>,TYPE_DECL,"void disconnectAllBlockedClients(void) {
    listNode *ln;
    listIter li;

    listRewind(server.clients,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);

        if (c->flags & CLIENT_BLOCKED) {
            /* POSTPONEd clients are an exception, when they'll be unblocked, the
             * command processing will start from scratch, and the command will
             * be either executed or rejected. (unlike LIST blocked clients for
             * which the command is already in progress in a way. */
            if (c->bstate.btype == BLOCKED_POSTPONE)
                continue;

            unblockClientOnError(c,
                ""-UNBLOCKED force unblock from blocking operation, ""
                ""instance state changed (master -> replica?)"");
            c->flags |= CLIENT_CLOSE_AFTER_REPLY;
        }
    }
}",1,20,blocked.c,disconnectAllBlockedClients,,false,271,293,disconnectAllBlockedClients,,,14,void disconnectAllBlockedClients (void)
34879,METHOD,blocked.c:<global>,TYPE_DECL,"void handleClientsBlockedOnKeys(void) {

    /* In case we are already in the process of unblocking clients we should
     * not make a recursive call, in order to prevent breaking fairness. */
    static int in_handling_blocked_clients = 0;
    if (in_handling_blocked_clients)
        return;
    in_handling_blocked_clients = 1;

    /* This function is called only when also_propagate is in its basic state
     * (i.e. not from call(), module context, etc.) */
    serverAssert(server.also_propagate.numops == 0);

    /* If a command being unblocked causes another command to get unblocked,
     * like a BLMOVE would do, then the new unblocked command will get processed
     * right away rather than wait for later. */
    while(listLength(server.ready_keys) != 0) {
        list *l;

        /* Point server.ready_keys to a fresh list and save the current one
         * locally. This way as we run the old list we are free to call
         * signalKeyAsReady() that may push new elements...",1,4,blocked.c,handleClientsBlockedOnKeys,,false,315,359,handleClientsBlockedOnKeys,,,15,void handleClientsBlockedOnKeys (void)
34990,METHOD,blocked.c:<global>,TYPE_DECL,"void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, int unblock_on_nokey) {
    dictEntry *db_blocked_entry, *db_blocked_existing_entry, *client_blocked_entry;
    list *l;
    int j;

    c->bstate.timeout = timeout;
    for (j = 0; j < numkeys; j++) {
        /* If the key already exists in the dictionary ignore it. */
        if (!(client_blocked_entry = dictAddRaw(c->bstate.keys,keys[j],NULL))) {
            continue;
        }
        incrRefCount(keys[j]);

        /* And in the other ""side"", to map keys -> clients */
        db_blocked_entry = dictAddRaw(c->db->blocking_keys,keys[j], &db_blocked_existing_entry);

        /* In case key[j] did not have blocking clients yet, we need to create a new list */
        if (db_blocked_entry != NULL) {
            l = listCreate();
            dictSetVal(c->db->blocking_keys, db_blocked_entry, l);
            incrRefCount(keys[j]);
        } else {
            l = dictGetVal(db_blocked_existing_entry);
...",1,55,blocked.c,blockForKeys,,false,368,415,blockForKeys,,,16,"void blockForKeys (client*,int,robj**,int,mstime_t,int)"
35153,METHOD,blocked.c:<global>,TYPE_DECL,"static void unblockClientWaitingData(client *c) {
    dictEntry *de;
    dictIterator *di;

    if (dictSize(c->bstate.keys) == 0)
        return;

    di = dictGetIterator(c->bstate.keys);
    /* The client may wait for multiple keys, so unblock it for every key. */
    while((de = dictNext(di)) != NULL) {
        releaseBlockedEntry(c, de, 0);
    }
    dictReleaseIterator(di);
    dictEmpty(c->bstate.keys, NULL);
}",1,8,blocked.c,unblockClientWaitingData,,false,419,433,unblockClientWaitingData,,,17,void unblockClientWaitingData (client*)
35220,METHOD,blocked.c:<global>,TYPE_DECL,"static blocking_type getBlockedTypeByType(int type) {
    switch (type) {
        case OBJ_LIST: return BLOCKED_LIST;
        case OBJ_ZSET: return BLOCKED_ZSET;
        case OBJ_MODULE: return BLOCKED_MODULE;
        case OBJ_STREAM: return BLOCKED_STREAM;
        default: return BLOCKED_NONE;
    }
}",1,13,blocked.c,getBlockedTypeByType,,false,435,443,getBlockedTypeByType,,,18,blocking_type getBlockedTypeByType (int)
35255,METHOD,blocked.c:<global>,TYPE_DECL,"static void signalKeyAsReadyLogic(redisDb *db, robj *key, int type, int deleted) {
    readyList *rl;

    /* Quick returns. */
    int btype = getBlockedTypeByType(type);
    if (btype == BLOCKED_NONE) {
        /* The type can never block. */
        return;
    }
    if (!server.blocked_clients_by_type[btype] &&
        !server.blocked_clients_by_type[BLOCKED_MODULE]) {
        /* No clients block on this type. Note: Blocked modules are represented
         * by BLOCKED_MODULE, even if the intention is to wake up by normal
         * types (list, zset, stream), so we need to check that there are no
         * blocked modules before we do a quick return here. */
        return;
    }

    if (deleted) {
        /* Key deleted and no clients blocking for this key? No need to queue it. */
        if (dictFind(db->blocking_keys_unblock_on_nokey,key) == NULL)
            return;
        /* Note: if we made it here it means the key is also present in db->blocking_keys */
    } else {
 ...",1,1,blocked.c,signalKeyAsReadyLogic,,false,452,499,signalKeyAsReadyLogic,,,19,"void signalKeyAsReadyLogic (redisDb*,robj*,int,int)"
35358,METHOD,blocked.c:<global>,TYPE_DECL,"static void releaseBlockedEntry(client *c, dictEntry *de, int remove_key) {
    list *l;
    listNode *pos;
    void *key;
    dictEntry *unblock_on_nokey_entry;

    key = dictGetKey(de);
    pos = dictGetVal(de);
    /* Remove this client from the list of clients waiting for this key. */
    l = dictFetchValue(c->db->blocking_keys, key);
    serverAssertWithInfo(c,key,l != NULL);
    listUnlinkNode(l,pos);
    /* If the list is empty we need to remove it to avoid wasting memory
     * We will also remove the key (if exists) from the blocking_keys_unblock_on_nokey dict.
     * However, in case the list is not empty, we will have to still perform reference accounting
     * on the blocking_keys_unblock_on_nokey and delete the entry in case of zero reference.
     * Why? because it is possible that some more clients are blocked on the same key but without
     * require to be triggered on key deletion, we do not want these to be later triggered by the
     * signalDeletedKeyAsReady. ...",1,4,blocked.c,releaseBlockedEntry,,false,512,545,releaseBlockedEntry,,,20,"void releaseBlockedEntry (client*,dictEntry*,int)"
35495,METHOD,blocked.c:<global>,TYPE_DECL,"void signalKeyAsReady(redisDb *db, robj *key, int type) {
    signalKeyAsReadyLogic(db, key, type, 0);
}",1,1,blocked.c,signalKeyAsReady,,false,547,549,signalKeyAsReady,,,21,"void signalKeyAsReady (redisDb*,robj*,int)"
35507,METHOD,blocked.c:<global>,TYPE_DECL,"void signalDeletedKeyAsReady(redisDb *db, robj *key, int type) {
    signalKeyAsReadyLogic(db, key, type, 1);
}",1,1,blocked.c,signalDeletedKeyAsReady,,false,551,553,signalDeletedKeyAsReady,,,22,"void signalDeletedKeyAsReady (redisDb*,robj*,int)"
35519,METHOD,blocked.c:<global>,TYPE_DECL,"static void handleClientsBlockedOnKey(readyList *rl) {

    /* We serve clients in the same order they blocked for
     * this key, from the first blocked to the last. */
    dictEntry *de = dictFind(rl->db->blocking_keys,rl->key);

    if (de) {
        list *clients = dictGetVal(de);
        listNode *ln;
        listIter li;
        listRewind(clients,&li);

        /* Avoid processing more than the initial count so that we're not stuck
         * in an endless loop in case the reprocessing of the command blocks again. */
        long count = listLength(clients);
        while ((ln = listNext(&li)) && count--) {
            client *receiver = listNodeValue(ln);
            robj *o = lookupKeyReadWithFlags(rl->db, rl->key, LOOKUP_NOEFFECTS);
            /* 1. In case new key was added/touched we need to verify it satisfy the
             *    blocked type, since we might process the wrong key type.
             * 2. We want to serve clients blocked on module keys
             *   ...",1,21,blocked.c,handleClientsBlockedOnKey,,false,558,594,handleClientsBlockedOnKey,,,23,void handleClientsBlockedOnKey (readyList*)
35660,METHOD,blocked.c:<global>,TYPE_DECL,"void blockForReplication(client *c, mstime_t timeout, long long offset, long numreplicas) {
    c->bstate.timeout = timeout;
    c->bstate.reploffset = offset;
    c->bstate.numreplicas = numreplicas;
    listAddNodeHead(server.clients_waiting_acks,c);
    blockClient(c,BLOCKED_WAIT);
}",1,1,blocked.c,blockForReplication,,false,597,603,blockForReplication,,,24,"void blockForReplication (client*,mstime_t,long long,long)"
35697,METHOD,blocked.c:<global>,TYPE_DECL,"void blockForAofFsync(client *c, mstime_t timeout, long long offset, int numlocal, long numreplicas) {
    c->bstate.timeout = timeout;
    c->bstate.reploffset = offset;
    c->bstate.numreplicas = numreplicas;
    c->bstate.numlocal = numlocal;
    listAddNodeHead(server.clients_waiting_acks,c);
    blockClient(c,BLOCKED_WAITAOF);
}",1,1,blocked.c,blockForAofFsync,,false,606,613,blockForAofFsync,,,25,"void blockForAofFsync (client*,mstime_t,long long,int,long)"
35742,METHOD,blocked.c:<global>,TYPE_DECL,"void blockPostponeClient(client *c) {
    c->bstate.timeout = 0;
    blockClient(c,BLOCKED_POSTPONE);
    listAddNodeTail(server.postponed_clients, c);
    c->postponed_list_node = listLast(server.postponed_clients);
    /* Mark this client to execute its command */
    c->flags |= CLIENT_PENDING_COMMAND;
}",1,29,blocked.c,blockPostponeClient,,false,618,625,blockPostponeClient,,,26,void blockPostponeClient (client*)
35785,METHOD,blocked.c:<global>,TYPE_DECL,"void blockClientShutdown(client *c) {
    blockClient(c, BLOCKED_SHUTDOWN);
}",1,1,blocked.c,blockClientShutdown,,false,628,630,blockClientShutdown,,,27,void blockClientShutdown (client*)
35793,METHOD,blocked.c:<global>,TYPE_DECL,"static void unblockClientOnKey(client *c, robj *key) {
    dictEntry *de;

    de = dictFind(c->bstate.keys, key);
    releaseBlockedEntry(c, de, 1);

    /* Only in case of blocking API calls, we might be blocked on several keys.
       however we should force unblock the entire blocking keys */
    serverAssert(c->bstate.btype == BLOCKED_STREAM ||
                c->bstate.btype == BLOCKED_LIST   ||
                c->bstate.btype == BLOCKED_ZSET);

    /* We need to unblock the client before calling processCommandAndResetClient
     * because it checks the CLIENT_BLOCKED flag */
    unblockClient(c, 0);
    /* In case this client was blocked on keys during command
     * we need to re process the command again */
    if (c->flags & CLIENT_PENDING_COMMAND) {
        c->flags &= ~CLIENT_PENDING_COMMAND;
        /* We want the command processing and the unblock handler (see RM_Call 'K' option)
         * to run atomically, this is why we must enter the execution unit here before
   ...",1,4,blocked.c,unblockClientOnKey,,false,636,675,unblockClientOnKey,,,28,"void unblockClientOnKey (client*,robj*)"
35926,METHOD,blocked.c:<global>,TYPE_DECL,"static void moduleUnblockClientOnKey(client *c, robj *key) {
    long long prev_error_replies = server.stat_total_error_replies;
    client *old_client = server.current_client;
    server.current_client = c;
    monotime replyTimer;
    elapsedStart(&replyTimer);

    if (moduleTryServeClientBlockedOnKey(c, key)) {
        updateStatsOnUnblock(c, 0, elapsedUs(replyTimer), server.stat_total_error_replies != prev_error_replies);
        moduleUnblockClient(c);
    }
    /* We need to call afterCommand even if the client was not unblocked
     * in order to propagate any changes that could have been done inside
     * moduleTryServeClientBlockedOnKey */
    afterCommand(c);
    server.current_client = old_client;
}",1,1,blocked.c,moduleUnblockClientOnKey,,false,681,697,moduleUnblockClientOnKey,,,29,"void moduleUnblockClientOnKey (client*,robj*)"
35977,METHOD,blocked.c:<global>,TYPE_DECL,"void unblockClientOnTimeout(client *c) {
    replyToBlockedClientTimedOut(c);
    if (c->flags & CLIENT_PENDING_COMMAND)
        c->flags &= ~CLIENT_PENDING_COMMAND;
    unblockClient(c, 1);
}",1,19,blocked.c,unblockClientOnTimeout,,false,705,710,unblockClientOnTimeout,,,30,void unblockClientOnTimeout (client*)
36008,METHOD,blocked.c:<global>,TYPE_DECL,"void unblockClientOnError(client *c, const char *err_str) {
    if (err_str)
        addReplyError(c, err_str);
    updateStatsOnUnblock(c, 0, 0, 1);
    if (c->flags & CLIENT_PENDING_COMMAND)
        c->flags &= ~CLIENT_PENDING_COMMAND;
    unblockClient(c, 1);
}",1,19,blocked.c,unblockClientOnError,,false,714,721,unblockClientOnError,,,31,"void unblockClientOnError (client*,char*)"
36049,METHOD,blocked.c:<global>,TYPE_DECL,"void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey) {
    unsigned long bkeys=0, bkeys_on_nokey=0;
    for (int j = 0; j < server.dbnum; j++) {
        bkeys += dictSize(server.db[j].blocking_keys);
        bkeys_on_nokey += dictSize(server.db[j].blocking_keys_unblock_on_nokey);
    }
    if (blocking_keys)
        *blocking_keys = bkeys;
    if (bloking_keys_on_nokey)
        *bloking_keys_on_nokey = bkeys_on_nokey;
}",1,17,blocked.c,totalNumberOfBlockingKeys,,false,726,736,totalNumberOfBlockingKeys,,,32,"void totalNumberOfBlockingKeys (long unsigned*,long unsigned*)"
36159,METHOD,blocked.c:<global>,TYPE_DECL,"void blockedBeforeSleep(void) {
    /* Handle precise timeouts of blocked clients. */
    handleBlockedClientsTimeout();

    /* Unblock all the clients blocked for synchronous replication
     * in WAIT or WAITAOF. */
    if (listLength(server.clients_waiting_acks))
        processClientsWaitingReplicas();

    /* Try to process blocked clients every once in while.
     *
     * Example: A module calls RM_SignalKeyAsReady from within a timer callback
     * (So we don't visit processCommand() at all).
     *
     * This may unblock clients, so must be done before processUnblockedClients */
    handleClientsBlockedOnKeys();

    /* Check if there are clients unblocked by modules that implement
     * blocking commands. */
    if (moduleCount())
        moduleHandleBlockedClients();

    /* Try to process pending commands for clients that were just unblocked. */
    if (listLength(server.unblocked_clients))
        processUnblockedClients();
}",1,8,blocked.c,blockedBeforeSleep,,false,738,763,blockedBeforeSleep,,,33,void blockedBeforeSleep (void)
36203,METHOD,call_reply.c:<global>,TYPE_DECL,<global>,1,1,call_reply.c,call_reply.c:<global>,,false,1,560,<global>,,,1,
36227,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplySetSharedData(CallReply *rep, int type, const char *proto, size_t proto_len, int extra_flags) {
    rep->type = type;
    rep->proto = proto;
    rep->proto_len = proto_len;
    rep->flags |= extra_flags;
}",1,1,call_reply.c,callReplySetSharedData,,false,67,72,callReplySetSharedData,,,2,"void callReplySetSharedData (CallReply*,int,char*,size_t,int)"
36256,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyNull(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, REPLY_FLAG_RESP3);
}",1,32,call_reply.c,callReplyNull,,false,74,77,callReplyNull,,,3,"void callReplyNull (void*,char*,size_t)"
36279,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyNullBulkString(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, 0);
}",1,32,call_reply.c,callReplyNullBulkString,,false,79,82,callReplyNullBulkString,,,4,"void callReplyNullBulkString (void*,char*,size_t)"
36298,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyNullArray(void *ctx, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_NULL, proto, proto_len, 0);
}",1,32,call_reply.c,callReplyNullArray,,false,84,87,callReplyNullArray,,,5,"void callReplyNullArray (void*,char*,size_t)"
36317,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyBulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_STRING, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",1,32,call_reply.c,callReplyBulkString,,false,89,94,callReplyBulkString,,,6,"void callReplyBulkString (void*,char*,size_t,char*,size_t)"
36350,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyError(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_ERROR, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",1,32,call_reply.c,callReplyError,,false,96,101,callReplyError,,,7,"void callReplyError (void*,char*,size_t,char*,size_t)"
36383,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplySimpleStr(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_STRING, proto, proto_len, 0);
    rep->len = len;
    rep->val.str = str;
}",1,32,call_reply.c,callReplySimpleStr,,false,103,108,callReplySimpleStr,,,8,"void callReplySimpleStr (void*,char*,size_t,char*,size_t)"
36416,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyLong(void *ctx, long long val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_INTEGER, proto, proto_len, 0);
    rep->val.ll = val;
}",1,32,call_reply.c,callReplyLong,,false,110,114,callReplyLong,,,9,"void callReplyLong (void*,long long,char*,size_t)"
36443,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyDouble(void *ctx, double val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_DOUBLE, proto, proto_len, REPLY_FLAG_RESP3);
    rep->val.d = val;
}",1,32,call_reply.c,callReplyDouble,,false,116,120,callReplyDouble,,,10,"void callReplyDouble (void*,double,char*,size_t)"
36474,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyVerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_VERBATIM_STRING, proto, proto_len, REPLY_FLAG_RESP3);
    rep->len = len;
    rep->val.verbatim_str.str = str;
    rep->val.verbatim_str.format = format;
}",1,32,call_reply.c,callReplyVerbatimString,,false,122,128,callReplyVerbatimString,,,11,"void callReplyVerbatimString (void*,char*,char*,size_t,char*,size_t)"
36523,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyBigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_BIG_NUMBER, proto, proto_len, REPLY_FLAG_RESP3);
    rep->len = len;
    rep->val.str = str;
}",1,32,call_reply.c,callReplyBigNumber,,false,130,135,callReplyBigNumber,,,12,"void callReplyBigNumber (void*,char*,size_t,char*,size_t)"
36560,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyBool(void *ctx, int val, const char *proto, size_t proto_len) {
    CallReply *rep = ctx;
    callReplySetSharedData(rep, REDISMODULE_REPLY_BOOL, proto, proto_len, REPLY_FLAG_RESP3);
    rep->val.ll = val;
}",1,32,call_reply.c,callReplyBool,,false,137,141,callReplyBool,,,13,"void callReplyBool (void*,int,char*,size_t)"
36591,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyParseCollection(ReplyParser *parser, CallReply *rep, size_t len, const char *proto, size_t elements_per_entry) {
    rep->len = len;
    rep->val.array = zcalloc(elements_per_entry * len * sizeof(CallReply));
    for (size_t i = 0; i < len * elements_per_entry; i += elements_per_entry) {
        for (size_t j = 0 ; j < elements_per_entry ; ++j) {
            rep->val.array[i + j].private_data = rep->private_data;
            parseReply(parser, rep->val.array + i + j);
            rep->val.array[i + j].flags |= REPLY_FLAG_PARSED;
            if (rep->val.array[i + j].flags & REPLY_FLAG_RESP3) {
                /* If one of the sub-replies is RESP3, then the current reply is also RESP3. */
                rep->flags |= REPLY_FLAG_RESP3;
            }
        }
    }
    rep->proto = proto;
    rep->proto_len = parser->curr_location - proto;
}",1,43,call_reply.c,callReplyParseCollection,,false,143,159,callReplyParseCollection,,,14,"void callReplyParseCollection (ReplyParser*,CallReply*,size_t,char*,size_t)"
36730,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyAttribute(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->attribute = zcalloc(sizeof(CallReply));

    /* Continue parsing the attribute reply */
    rep->attribute->len = len;
    rep->attribute->type = REDISMODULE_REPLY_ATTRIBUTE;
    callReplyParseCollection(parser, rep->attribute, len, proto, 2);
    rep->attribute->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_RESP3;
    rep->attribute->private_data = rep->private_data;

    /* Continue parsing the reply */
    parseReply(parser, rep);

    /* In this case we need to fix the proto address and len, it should start from the attribute */
    rep->proto = proto;
    rep->proto_len = parser->curr_location - proto;
    rep->flags |= REPLY_FLAG_RESP3;
}",1,27,call_reply.c,callReplyAttribute,,false,161,179,callReplyAttribute,,,15,"void callReplyAttribute (ReplyParser*,void*,size_t,char*)"
36825,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyArray(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_ARRAY;
    callReplyParseCollection(parser, rep, len, proto, 1);
}",1,16,call_reply.c,callReplyArray,,false,181,185,callReplyArray,,,16,"void callReplyArray (ReplyParser*,void*,size_t,char*)"
36850,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplySet(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_SET;
    callReplyParseCollection(parser, rep, len, proto, 1);
    rep->flags |= REPLY_FLAG_RESP3;
}",1,16,call_reply.c,callReplySet,,false,187,192,callReplySet,,,17,"void callReplySet (ReplyParser*,void*,size_t,char*)"
36884,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyMap(ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_MAP;
    callReplyParseCollection(parser, rep, len, proto, 2);
    rep->flags |= REPLY_FLAG_RESP3;
}",1,16,call_reply.c,callReplyMap,,false,194,199,callReplyMap,,,18,"void callReplyMap (ReplyParser*,void*,size_t,char*)"
36918,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyParseError(void *ctx) {
    CallReply *rep = ctx;
    rep->type = REDISMODULE_REPLY_UNKNOWN;
}",1,16,call_reply.c,callReplyParseError,,false,201,204,callReplyParseError,,,19,void callReplyParseError (void*)
36935,METHOD,call_reply.c:<global>,TYPE_DECL,"static void freeCallReplyInternal(CallReply *rep) {
    if (rep->type == REDISMODULE_REPLY_ARRAY || rep->type == REDISMODULE_REPLY_SET) {
        for (size_t i = 0 ; i < rep->len ; ++i) {
            freeCallReplyInternal(rep->val.array + i);
        }
        zfree(rep->val.array);
    }

    if (rep->type == REDISMODULE_REPLY_MAP || rep->type == REDISMODULE_REPLY_ATTRIBUTE) {
        for (size_t i = 0 ; i < rep->len ; ++i) {
            freeCallReplyInternal(rep->val.array + i * 2);
            freeCallReplyInternal(rep->val.array + i * 2 + 1);
        }
        zfree(rep->val.array);
    }

    if (rep->attribute) {
        freeCallReplyInternal(rep->attribute);
        zfree(rep->attribute);
    }
}",1,21,call_reply.c,freeCallReplyInternal,,false,207,227,freeCallReplyInternal,,,20,void freeCallReplyInternal (CallReply*)
37057,METHOD,call_reply.c:<global>,TYPE_DECL,"void freeCallReply(CallReply *rep) {
    if (!(rep->flags & REPLY_FLAG_ROOT)) {
        return;
    }
    if (rep->flags & REPLY_FLAG_PARSED) {
        if (rep->type == REDISMODULE_REPLY_PROMISE) {
            zfree(rep);
            return;
        }
        freeCallReplyInternal(rep);
    }
    sdsfree(rep->original_proto);
    if (rep->deferred_error_list)
        listRelease(rep->deferred_error_list);
    zfree(rep);
}",1,23,call_reply.c,freeCallReply,,false,232,247,freeCallReply,,,21,void freeCallReply (CallReply*)
37115,METHOD,call_reply.c:<global>,TYPE_DECL,"CallReply *callReplyCreatePromise(void *private_data) {
    CallReply *res = zmalloc(sizeof(*res));
    res->type = REDISMODULE_REPLY_PROMISE;
    /* Mark the reply as parsed so there will be not attempt to parse
     * it when calling reply API such as freeCallReply.
     * Also mark the reply as root so freeCallReply will not ignore it. */
    res->flags |= REPLY_FLAG_PARSED | REPLY_FLAG_ROOT;
    res->private_data = private_data;
    return res;
}",1,16,call_reply.c,callReplyCreatePromise,,false,249,258,callReplyCreatePromise,,,22,CallReply callReplyCreatePromise (void*)
37224,METHOD,call_reply.c:<global>,TYPE_DECL,"static void callReplyParse(CallReply *rep) {
    if (rep->flags & REPLY_FLAG_PARSED) {
        return;
    }

    ReplyParser parser = {.curr_location = rep->proto, .callbacks = DefaultParserCallbacks};

    parseReply(&parser, rep);
    rep->flags |= REPLY_FLAG_PARSED;
}",1,21,call_reply.c,callReplyParse,,false,281,290,callReplyParse,,,25,void callReplyParse (CallReply*)
37268,METHOD,call_reply.c:<global>,TYPE_DECL,"int callReplyType(CallReply *rep) {
    if (!rep) return REDISMODULE_REPLY_UNKNOWN;
    callReplyParse(rep);
    return rep->type;
}",1,21,call_reply.c,callReplyType,,false,293,297,callReplyType,,,26,int callReplyType (CallReply*)
37288,METHOD,call_reply.c:<global>,TYPE_DECL,"const char *callReplyGetString(CallReply *rep, size_t *len) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_STRING &&
        rep->type != REDISMODULE_REPLY_ERROR) return NULL;
    if (len) *len = rep->len;
    return rep->val.str;
}",1,21,call_reply.c,callReplyGetString,,false,309,315,callReplyGetString,,,27,"const char* callReplyGetString (CallReply*,size_t*)"
37330,METHOD,call_reply.c:<global>,TYPE_DECL,"long long callReplyGetLongLong(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;
    return rep->val.ll;
}",1,21,call_reply.c,callReplyGetLongLong,,false,320,324,callReplyGetLongLong,,,28,long long callReplyGetLongLong (CallReply*)
37354,METHOD,call_reply.c:<global>,TYPE_DECL,"double callReplyGetDouble(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_DOUBLE) return LLONG_MIN;
    return rep->val.d;
}",1,21,call_reply.c,callReplyGetDouble,,false,329,333,callReplyGetDouble,,,29,double callReplyGetDouble (CallReply*)
37378,METHOD,call_reply.c:<global>,TYPE_DECL,"int callReplyGetBool(CallReply *rep) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_BOOL) return INT_MIN;
    return rep->val.ll;
}",1,21,call_reply.c,callReplyGetBool,,false,338,342,callReplyGetBool,,,30,int callReplyGetBool (CallReply*)
37402,METHOD,call_reply.c:<global>,TYPE_DECL,"size_t callReplyGetLen(CallReply *rep) {
    callReplyParse(rep);
    switch(rep->type) {
        case REDISMODULE_REPLY_STRING:
        case REDISMODULE_REPLY_ERROR:
        case REDISMODULE_REPLY_ARRAY:
        case REDISMODULE_REPLY_SET:
        case REDISMODULE_REPLY_MAP:
        case REDISMODULE_REPLY_ATTRIBUTE:
            return rep->len;
        default:
            return 0;
    }
}",1,13,call_reply.c,callReplyGetLen,,false,352,365,callReplyGetLen,,,31,size_t callReplyGetLen (CallReply*)
37445,METHOD,call_reply.c:<global>,TYPE_DECL,"static CallReply *callReplyGetCollectionElement(CallReply *rep, size_t idx, int elements_per_entry) {
    if (idx >= rep->len * elements_per_entry) return NULL; // real len is rep->len * elements_per_entry
    return rep->val.array+idx;
}",1,1,call_reply.c,callReplyGetCollectionElement,,false,367,370,callReplyGetCollectionElement,,,32,"CallReply callReplyGetCollectionElement (CallReply*,size_t,int)"
37471,METHOD,call_reply.c:<global>,TYPE_DECL,"CallReply *callReplyGetArrayElement(CallReply *rep, size_t idx) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_ARRAY) return NULL;
    return callReplyGetCollectionElement(rep, idx, 1);
}",1,21,call_reply.c,callReplyGetArrayElement,,false,378,382,callReplyGetArrayElement,,,33,"CallReply callReplyGetArrayElement (CallReply*,size_t)"
37495,METHOD,call_reply.c:<global>,TYPE_DECL,"CallReply *callReplyGetSetElement(CallReply *rep, size_t idx) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_SET) return NULL;
    return callReplyGetCollectionElement(rep, idx, 1);
}",1,21,call_reply.c,callReplyGetSetElement,,false,390,394,callReplyGetSetElement,,,34,"CallReply callReplyGetSetElement (CallReply*,size_t)"
37519,METHOD,call_reply.c:<global>,TYPE_DECL,"static int callReplyGetMapElementInternal(CallReply *rep, size_t idx, CallReply **key, CallReply **val, int type) {
    callReplyParse(rep);
    if (rep->type != type) return C_ERR;
    if (idx >= rep->len) return C_ERR;
    if (key) *key = callReplyGetCollectionElement(rep, idx * 2, 2);
    if (val) *val = callReplyGetCollectionElement(rep, idx * 2 + 1, 2);
    return C_OK;
}",1,34,call_reply.c,callReplyGetMapElementInternal,,false,396,403,callReplyGetMapElementInternal,,,35,"int callReplyGetMapElementInternal (CallReply*,size_t,CallReply**,CallReply**,int)"
37584,METHOD,call_reply.c:<global>,TYPE_DECL,"int callReplyGetMapElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val) {
    return callReplyGetMapElementInternal(rep, idx, key, val, REDISMODULE_REPLY_MAP);
}",1,62,call_reply.c,callReplyGetMapElement,,false,417,419,callReplyGetMapElement,,,36,"int callReplyGetMapElement (CallReply*,size_t,CallReply**,CallReply**)"
37601,METHOD,call_reply.c:<global>,TYPE_DECL,"CallReply *callReplyGetAttribute(CallReply *rep) {
    return rep->attribute;
}",1,1,call_reply.c,callReplyGetAttribute,,false,426,428,callReplyGetAttribute,,,37,CallReply callReplyGetAttribute (CallReply*)
37610,METHOD,call_reply.c:<global>,TYPE_DECL,"int callReplyGetAttributeElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val) {
    return callReplyGetMapElementInternal(rep, idx, key, val, REDISMODULE_REPLY_MAP);
}",1,62,call_reply.c,callReplyGetAttributeElement,,false,442,444,callReplyGetAttributeElement,,,38,"int callReplyGetAttributeElement (CallReply*,size_t,CallReply**,CallReply**)"
37627,METHOD,call_reply.c:<global>,TYPE_DECL,"const char *callReplyGetBigNumber(CallReply *rep, size_t *len) {
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_BIG_NUMBER) return NULL;
    *len = rep->len;
    return rep->val.str;
}",1,21,call_reply.c,callReplyGetBigNumber,,false,458,463,callReplyGetBigNumber,,,39,"const char* callReplyGetBigNumber (CallReply*,size_t*)"
37658,METHOD,call_reply.c:<global>,TYPE_DECL,"const char *callReplyGetVerbatim(CallReply *rep, size_t *len, const char **format){
    callReplyParse(rep);
    if (rep->type != REDISMODULE_REPLY_VERBATIM_STRING) return NULL;
    *len = rep->len;
    if (format) *format = rep->val.verbatim_str.format;
    return rep->val.verbatim_str.str;
}",1,21,call_reply.c,callReplyGetVerbatim,,false,479,485,callReplyGetVerbatim,,,40,"const char* callReplyGetVerbatim (CallReply*,size_t*,char**)"
37705,METHOD,call_reply.c:<global>,TYPE_DECL,"const char *callReplyGetProto(CallReply *rep, size_t *proto_len) {
    *proto_len = rep->proto_len;
    return rep->proto;
}",1,1,call_reply.c,callReplyGetProto,,false,492,495,callReplyGetProto,,,41,"const char* callReplyGetProto (CallReply*,size_t*)"
37721,METHOD,call_reply.c:<global>,TYPE_DECL,"void *callReplyGetPrivateData(CallReply *rep) {
    return rep->private_data;
}",1,1,call_reply.c,callReplyGetPrivateData,,false,499,501,callReplyGetPrivateData,,,42,void* callReplyGetPrivateData (CallReply*)
37730,METHOD,call_reply.c:<global>,TYPE_DECL,"int callReplyIsResp3(CallReply *rep) {
    return rep->flags & REPLY_FLAG_RESP3;
}",1,24,call_reply.c,callReplyIsResp3,,false,504,506,callReplyIsResp3,,,43,int callReplyIsResp3 (CallReply*)
37745,METHOD,call_reply.c:<global>,TYPE_DECL,"list *callReplyDeferredErrorList(CallReply *rep) {
    return rep->deferred_error_list;
}",1,1,call_reply.c,callReplyDeferredErrorList,,false,509,511,callReplyDeferredErrorList,,,44,list callReplyDeferredErrorList (CallReply*)
37754,METHOD,call_reply.c:<global>,TYPE_DECL,"CallReply *callReplyCreate(sds reply, list *deferred_error_list, void *private_data) {
    CallReply *res = zmalloc(sizeof(*res));
    res->flags = REPLY_FLAG_ROOT;
    res->original_proto = reply;
    res->proto = reply;
    res->proto_len = sdslen(reply);
    res->private_data = private_data;
    res->attribute = NULL;
    res->deferred_error_list = deferred_error_list;
    return res;
}",1,17,call_reply.c,callReplyCreate,,false,532,542,callReplyCreate,,,45,"CallReply callReplyCreate (sds,list*,void*)"
37810,METHOD,call_reply.c:<global>,TYPE_DECL,"CallReply *callReplyCreateError(sds reply, void *private_data) {
    sds err_buff = reply;
    if (err_buff[0] != '-') {
        err_buff = sdscatfmt(sdsempty(), ""-ERR %S\r\n"", reply);
        sdsfree(reply);
    }
    list *deferred_error_list = listCreate();
    listSetFreeMethod(deferred_error_list, (void (*)(void*))sdsfree);
    listAddNodeTail(deferred_error_list, sdsnew(err_buff));
    return callReplyCreate(err_buff, deferred_error_list, private_data);
}",1,4,call_reply.c,callReplyCreateError,,false,550,560,callReplyCreateError,,,46,"CallReply callReplyCreateError (sds,void*)"
37863,METHOD,call_reply.h:<global>,TYPE_DECL,<global>,1,1,call_reply.h,call_reply.h:<global>,,false,1,60,<global>,,,1,
37867,METHOD,call_reply.h:<global>,TYPE_DECL,"typedef void (*RedisModuleOnUnblocked)(void *ctx, CallReply *reply, void *private_data);",14,87,call_reply.h,RedisModuleOnUnblocked,,false,36,36,RedisModuleOnUnblocked,,,3,"void RedisModuleOnUnblocked (void*,CallReply*,void*)"
37874,METHOD,call_reply.h:<global>,TYPE_DECL,"CallReply *callReplyCreate(sds reply, list *deferred_error_list, void *private_data);",11,84,call_reply.h,callReplyCreate,,false,38,38,callReplyCreate,,,4,"CallReply* callReplyCreate (sds,list*,void*)"
37881,METHOD,call_reply.h:<global>,TYPE_DECL,"CallReply *callReplyCreateError(sds reply, void *private_data);",11,62,call_reply.h,callReplyCreateError,,false,39,39,callReplyCreateError,,,5,"CallReply* callReplyCreateError (sds,void*)"
37887,METHOD,call_reply.h:<global>,TYPE_DECL,int callReplyType(CallReply *rep);,5,33,call_reply.h,callReplyType,,false,40,40,callReplyType,,,6,int callReplyType (CallReply*)
37892,METHOD,call_reply.h:<global>,TYPE_DECL,"const char *callReplyGetString(CallReply *rep, size_t *len);",12,59,call_reply.h,callReplyGetString,,false,41,41,callReplyGetString,,,7,"char* callReplyGetString (CallReply*,size_t*)"
37898,METHOD,call_reply.h:<global>,TYPE_DECL,long long callReplyGetLongLong(CallReply *rep);,11,46,call_reply.h,callReplyGetLongLong,,false,42,42,callReplyGetLongLong,,,8,long long callReplyGetLongLong (CallReply*)
37903,METHOD,call_reply.h:<global>,TYPE_DECL,double callReplyGetDouble(CallReply *rep);,8,41,call_reply.h,callReplyGetDouble,,false,43,43,callReplyGetDouble,,,9,double callReplyGetDouble (CallReply*)
37908,METHOD,call_reply.h:<global>,TYPE_DECL,int callReplyGetBool(CallReply *rep);,5,36,call_reply.h,callReplyGetBool,,false,44,44,callReplyGetBool,,,10,int callReplyGetBool (CallReply*)
37913,METHOD,call_reply.h:<global>,TYPE_DECL,size_t callReplyGetLen(CallReply *rep);,8,38,call_reply.h,callReplyGetLen,,false,45,45,callReplyGetLen,,,11,size_t callReplyGetLen (CallReply*)
37918,METHOD,call_reply.h:<global>,TYPE_DECL,"CallReply *callReplyGetArrayElement(CallReply *rep, size_t idx);",11,63,call_reply.h,callReplyGetArrayElement,,false,46,46,callReplyGetArrayElement,,,12,"CallReply* callReplyGetArrayElement (CallReply*,size_t)"
37924,METHOD,call_reply.h:<global>,TYPE_DECL,"CallReply *callReplyGetSetElement(CallReply *rep, size_t idx);",11,61,call_reply.h,callReplyGetSetElement,,false,47,47,callReplyGetSetElement,,,13,"CallReply* callReplyGetSetElement (CallReply*,size_t)"
37930,METHOD,call_reply.h:<global>,TYPE_DECL,"int callReplyGetMapElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val);",5,88,call_reply.h,callReplyGetMapElement,,false,48,48,callReplyGetMapElement,,,14,"int callReplyGetMapElement (CallReply*,size_t,CallReply**,CallReply**)"
37938,METHOD,call_reply.h:<global>,TYPE_DECL,CallReply *callReplyGetAttribute(CallReply *rep);,11,48,call_reply.h,callReplyGetAttribute,,false,49,49,callReplyGetAttribute,,,15,CallReply* callReplyGetAttribute (CallReply*)
37943,METHOD,call_reply.h:<global>,TYPE_DECL,"int callReplyGetAttributeElement(CallReply *rep, size_t idx, CallReply **key, CallReply **val);",5,94,call_reply.h,callReplyGetAttributeElement,,false,50,50,callReplyGetAttributeElement,,,16,"int callReplyGetAttributeElement (CallReply*,size_t,CallReply**,CallReply**)"
37951,METHOD,call_reply.h:<global>,TYPE_DECL,"const char *callReplyGetBigNumber(CallReply *rep, size_t *len);",12,62,call_reply.h,callReplyGetBigNumber,,false,51,51,callReplyGetBigNumber,,,17,"char* callReplyGetBigNumber (CallReply*,size_t*)"
37957,METHOD,call_reply.h:<global>,TYPE_DECL,"const char *callReplyGetVerbatim(CallReply *rep, size_t *len, const char **format);",12,82,call_reply.h,callReplyGetVerbatim,,false,52,52,callReplyGetVerbatim,,,18,"char* callReplyGetVerbatim (CallReply*,size_t*,char**)"
37964,METHOD,call_reply.h:<global>,TYPE_DECL,"const char *callReplyGetProto(CallReply *rep, size_t *len);",12,58,call_reply.h,callReplyGetProto,,false,53,53,callReplyGetProto,,,19,"char* callReplyGetProto (CallReply*,size_t*)"
37970,METHOD,call_reply.h:<global>,TYPE_DECL,void *callReplyGetPrivateData(CallReply *rep);,6,45,call_reply.h,callReplyGetPrivateData,,false,54,54,callReplyGetPrivateData,,,20,void* callReplyGetPrivateData (CallReply*)
37975,METHOD,call_reply.h:<global>,TYPE_DECL,int callReplyIsResp3(CallReply *rep);,5,36,call_reply.h,callReplyIsResp3,,false,55,55,callReplyIsResp3,,,21,int callReplyIsResp3 (CallReply*)
37980,METHOD,call_reply.h:<global>,TYPE_DECL,list *callReplyDeferredErrorList(CallReply *rep);,6,48,call_reply.h,callReplyDeferredErrorList,,false,56,56,callReplyDeferredErrorList,,,22,list* callReplyDeferredErrorList (CallReply*)
37985,METHOD,call_reply.h:<global>,TYPE_DECL,void freeCallReply(CallReply *rep);,6,34,call_reply.h,freeCallReply,,false,57,57,freeCallReply,,,23,void freeCallReply (CallReply*)
37990,METHOD,call_reply.h:<global>,TYPE_DECL,CallReply *callReplyCreatePromise(void *private_data);,11,53,call_reply.h,callReplyCreatePromise,,false,58,58,callReplyCreatePromise,,,24,CallReply* callReplyCreatePromise (void*)
38004,METHOD,childinfo.c:<global>,TYPE_DECL,<global>,1,1,childinfo.c,childinfo.c:<global>,,false,1,183,<global>,,,1,
38013,METHOD,childinfo.c:<global>,TYPE_DECL,"void openChildInfoPipe(void) {
    if (anetPipe(server.child_info_pipe, O_NONBLOCK, 0) == -1) {
        /* On error our two file descriptors should be still set to -1,
         * but we call anyway closeChildInfoPipe() since can't hurt. */
        closeChildInfoPipe();
    } else {
        server.child_info_nread = 0;
    }
}",1,1,childinfo.c,openChildInfoPipe,,false,45,53,openChildInfoPipe,,,3,void openChildInfoPipe (void)
38037,METHOD,childinfo.c:<global>,TYPE_DECL,"void closeChildInfoPipe(void) {
    if (server.child_info_pipe[0] != -1 ||
        server.child_info_pipe[1] != -1)
    {
        close(server.child_info_pipe[0]);
        close(server.child_info_pipe[1]);
        server.child_info_pipe[0] = -1;
        server.child_info_pipe[1] = -1;
        server.child_info_nread = 0;
    }
}",1,1,childinfo.c,closeChildInfoPipe,,false,56,66,closeChildInfoPipe,,,4,void closeChildInfoPipe (void)
38094,METHOD,childinfo.c:<global>,TYPE_DECL,"void sendChildInfoGeneric(childInfoType info_type, size_t keys, double progress, char *pname) {
    if (server.child_info_pipe[1] == -1) return;

    static monotime cow_updated = 0;
    static uint64_t cow_update_cost = 0;
    static size_t cow = 0;
    static size_t peak_cow = 0;
    static size_t update_count = 0;
    static unsigned long long sum_cow = 0;

    child_info_data data = {0}; /* zero everything, including padding to satisfy valgrind */

    /* When called to report current info, we need to throttle down CoW updates as they
     * can be very expensive. To do that, we measure the time it takes to get a reading
     * and schedule the next reading to happen not before time*CHILD_COW_COST_FACTOR
     * passes. */

    monotime now = getMonotonicUs();
    if (info_type != CHILD_INFO_TYPE_CURRENT_INFO ||
        !cow_updated ||
        now - cow_updated > cow_update_cost * CHILD_COW_DUTY_CYCLE)
    {
        cow = zmalloc_get_private_dirty(-1);
        cow_updated = getMo...",1,46,childinfo.c,sendChildInfoGeneric,,false,69,119,sendChildInfoGeneric,,,5,"void sendChildInfoGeneric (childInfoType,size_t,double,char*)"
38302,METHOD,childinfo.c:<global>,TYPE_DECL,"void updateChildInfo(childInfoType information_type, size_t cow, monotime cow_updated, size_t keys, double progress) {
    if (cow > server.stat_current_cow_peak) server.stat_current_cow_peak = cow;

    if (information_type == CHILD_INFO_TYPE_CURRENT_INFO) {
        server.stat_current_cow_bytes = cow;
        server.stat_current_cow_updated = cow_updated;
        server.stat_current_save_keys_processed = keys;
        if (progress != -1) server.stat_module_progress = progress;
    } else if (information_type == CHILD_INFO_TYPE_AOF_COW_SIZE) {
        server.stat_aof_cow_bytes = server.stat_current_cow_peak;
    } else if (information_type == CHILD_INFO_TYPE_RDB_COW_SIZE) {
        server.stat_rdb_cow_bytes = server.stat_current_cow_peak;
    } else if (information_type == CHILD_INFO_TYPE_MODULE_COW_SIZE) {
        server.stat_module_cow_bytes = server.stat_current_cow_peak;
    }
}",1,1,childinfo.c,updateChildInfo,,false,122,137,updateChildInfo,,,6,"void updateChildInfo (childInfoType,size_t,monotime,size_t,double)"
38396,METHOD,childinfo.c:<global>,TYPE_DECL,"int readChildInfo(childInfoType *information_type, size_t *cow, monotime *cow_updated, size_t *keys, double* progress) {
    /* We are using here a static buffer in combination with the server.child_info_nread to handle short reads */
    static child_info_data buffer;
    ssize_t wlen = sizeof(buffer);

    /* Do not overlap */
    if (server.child_info_nread == wlen) server.child_info_nread = 0;

    int nread = read(server.child_info_pipe[0], (char *)&buffer + server.child_info_nread, wlen - server.child_info_nread);
    if (nread > 0) {
        server.child_info_nread += nread;
    }

    /* We have complete child info */
    if (server.child_info_nread == wlen) {
        *information_type = buffer.information_type;
        *cow = buffer.cow;
        *cow_updated = buffer.cow_updated;
        *keys = buffer.keys;
        *progress = buffer.progress;
        return 1;
    } else {
        return 0;
    }
}",1,1,childinfo.c,readChildInfo,,false,143,167,readChildInfo,,,7,"int readChildInfo (childInfoType*,size_t*,monotime*,size_t*,double*)"
38498,METHOD,childinfo.c:<global>,TYPE_DECL,"void receiveChildInfo(void) {
    if (server.child_info_pipe[0] == -1) return;

    size_t cow;
    monotime cow_updated;
    size_t keys;
    double progress;
    childInfoType information_type;

    /* Drain the pipe and update child info so that we get the final message. */
    while (readChildInfo(&information_type, &cow, &cow_updated, &keys, &progress)) {
        updateChildInfo(information_type, cow, cow_updated, keys, progress);
    }
}",1,1,childinfo.c,receiveChildInfo,,false,170,183,receiveChildInfo,,,8,void receiveChildInfo (void)
38547,METHOD,cli_commands.c:<global>,TYPE_DECL,<global>,1,20,cli_commands.c,cli_commands.c:<global>,,false,1,10845,<global>,,,1,
38556,METHOD,cli_commands.h:<global>,TYPE_DECL,<global>,1,20,cli_commands.h,cli_commands.h:<global>,,false,1,46,<global>,,,1,
38619,METHOD,cli_common.c:<global>,TYPE_DECL,<global>,1,1,cli_common.c,cli_common.c:<global>,,false,1,408,<global>,,,1,
38621,METHOD,cli_common.c:<global>,TYPE_DECL,"int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err) {
#ifdef USE_OPENSSL
    static SSL_CTX *ssl_ctx = NULL;

    if (!ssl_ctx) {
        ssl_ctx = SSL_CTX_new(SSLv23_client_method());
        if (!ssl_ctx) {
            *err = ""Failed to create SSL_CTX"";
            goto error;
        }
        SSL_CTX_set_options(ssl_ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3);
        SSL_CTX_set_verify(ssl_ctx, config.skip_cert_verify ? SSL_VERIFY_NONE : SSL_VERIFY_PEER, NULL);

        if (config.cacert || config.cacertdir) {
            if (!SSL_CTX_load_verify_locations(ssl_ctx, config.cacert, config.cacertdir)) {
                *err = ""Invalid CA Certificate File/Directory"";
                goto error;
            }
        } else {
            if (!SSL_CTX_set_default_verify_paths(ssl_ctx)) {
                *err = ""Failed to use default CA paths"";
                goto error;
            }
        }

        if (config.cert && !SSL_CTX_use_certificate_chain_file(ss...",1,1,cli_common.c,cliSecureConnection,,false,54,124,cliSecureConnection,,,1,"int cliSecureConnection (redisContext*,cliSSLconfig,char**)"
38639,METHOD,cli_common.c:<global>,TYPE_DECL,"ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len)
{
    int done = 0;

    /* Append data to buffer which is *usually* expected to be empty
     * but we don't assume that, and write.
     */
    c->obuf = sdscatlen(c->obuf, buf, buf_len);
    if (redisBufferWrite(c, &done) == REDIS_ERR) {
        if (!(c->flags & REDIS_BLOCK))
            errno = EAGAIN;

        /* On error, we assume nothing was written and we roll back the
         * buffer to its original state.
         */
        if (sdslen(c->obuf) > buf_len)
            sdsrange(c->obuf, 0, -(buf_len+1));
        else
            sdsclear(c->obuf);

        return -1;
    }

    /* If we're done, free up everything. We may have written more than
     * buf_len (if c->obuf was not initially empty) but we don't have to
     * tell.
     */
    if (done) {
        sdsclear(c->obuf);
        return buf_len;
    }

    /* Write was successful but we have some leftovers which we should
     * remove from the ...",1,1,cli_common.c,cliWriteConn,,false,140,190,cliWriteConn,,,2,"ssize_t cliWriteConn (redisContext*,char*,size_t)"
38748,METHOD,cli_common.c:<global>,TYPE_DECL,"int cliSecureInit(void)
{
#ifdef USE_OPENSSL
    ERR_load_crypto_strings();
    SSL_load_error_strings();
    SSL_library_init();
#endif
    return REDIS_OK;
}",1,1,cli_common.c,cliSecureInit,,false,194,202,cliSecureInit,,,3,int cliSecureInit (void)
38755,METHOD,cli_common.c:<global>,TYPE_DECL,"sds readArgFromStdin(void) {
    char buf[1024];
    sds arg = sdsempty();

    while(1) {
        int nread = read(fileno(stdin),buf,1024);

        if (nread == 0) break;
        else if (nread == -1) {
            perror(""Reading from standard input"");
            exit(1);
        }
        arg = sdscatlen(arg,buf,nread);
    }
    return arg;
}",1,1,cli_common.c,readArgFromStdin,,false,205,220,readArgFromStdin,,,4,sds readArgFromStdin (void)
38802,METHOD,cli_common.c:<global>,TYPE_DECL,"sds *getSdsArrayFromArgv(int argc,char **argv, int quoted) {
    sds *res = sds_malloc(sizeof(sds) * argc);

    for (int j = 0; j < argc; j++) {
        if (quoted) {
            sds unquoted = unquoteCString(argv[j]);
            if (!unquoted) {
                while (--j >= 0) sdsfree(res[j]);
                sds_free(res);
                return NULL;
            }
            res[j] = unquoted;
        } else {
            res[j] = sdsnew(argv[j]);
        }
    }

    return res;
}",1,1,cli_common.c,getSdsArrayFromArgv,,false,229,247,getSdsArrayFromArgv,,,5,"sds getSdsArrayFromArgv (int,char**,int)"
38873,METHOD,cli_common.c:<global>,TYPE_DECL,"sds unquoteCString(char *str) {
    int count;
    sds *unquoted = sdssplitargs(str, &count);
    sds res = NULL;

    if (unquoted && count == 1) {
        res = unquoted[0];
        unquoted[0] = NULL;
    }

    if (unquoted)
        sdsfreesplitres(unquoted, count);

    return res;
}",1,1,cli_common.c,unquoteCString,,false,250,264,unquoteCString,,,6,sds unquoteCString (char*)
38915,METHOD,cli_common.c:<global>,TYPE_DECL,"static sds percentDecode(const char *pe, size_t len) {
    const char *end = pe + len;
    sds ret = sdsempty();
    const char *curr = pe;

    while (curr < end) {
        if (*curr == '%') {
            if ((end - curr) < 2) {
                fprintf(stderr, ""Incomplete URI encoding\n"");
                exit(1);
            }

            char h = tolower(*(++curr));
            char l = tolower(*(++curr));
            if (!isHexChar(h) || !isHexChar(l)) {
                fprintf(stderr, ""Illegal character in URI encoding\n"");
                exit(1);
            }
            char c = decodeHex(h, l);
            ret = sdscatlen(ret, &c, 1);
            curr++;
        } else {
            ret = sdscatlen(ret, curr++, 1);
        }
    }

    return ret;
}",1,17,cli_common.c,percentDecode,,false,272,299,percentDecode,,,7,"sds percentDecode (char*,size_t)"
39060,METHOD,cli_common.c:<global>,TYPE_DECL,"void parseRedisUri(const char *uri, const char* tool_name, cliConnInfo *connInfo, int *tls_flag) {
#ifdef USE_OPENSSL
    UNUSED(tool_name);
#else
    UNUSED(tls_flag);
#endif

    const char *scheme = ""redis://"";
    const char *tlsscheme = ""rediss://"";
    const char *curr = uri;
    const char *end = uri + strlen(uri);
    const char *userinfo, *username, *port, *host, *path;

    /* URI must start with a valid scheme. */
    if (!strncasecmp(tlsscheme, curr, strlen(tlsscheme))) {
#ifdef USE_OPENSSL
        *tls_flag = 1;
        curr += strlen(tlsscheme);
#else
        fprintf(stderr,""rediss:// is only supported when %s is compiled with OpenSSL\n"", tool_name);
        exit(1);
#endif
    } else if (!strncasecmp(scheme, curr, strlen(scheme))) {
        curr += strlen(scheme);
    } else {
        fprintf(stderr,""Invalid URI scheme\n"");
        exit(1);
    }
    if (curr == end) return;

    /* Extract user info. */
    if ((userinfo = strchr(curr,'@'))) {
        if ((username =...",1,4,cli_common.c,parseRedisUri,,false,309,377,parseRedisUri,,,8,"void parseRedisUri (char*,char*,cliConnInfo*,int*)"
39304,METHOD,cli_common.c:<global>,TYPE_DECL,"void freeCliConnInfo(cliConnInfo connInfo){
    if (connInfo.hostip) sdsfree(connInfo.hostip);
    if (connInfo.auth) sdsfree(connInfo.auth);
    if (connInfo.user) sdsfree(connInfo.user);
}",1,1,cli_common.c,freeCliConnInfo,,false,379,383,freeCliConnInfo,,,9,void freeCliConnInfo (cliConnInfo)
39336,METHOD,cli_common.c:<global>,TYPE_DECL,"sds escapeJsonString(sds s, const char *p, size_t len) {
    s = sdscatlen(s,""\"""",1);
    while(len--) {
        switch(*p) {
        case '\\':
        case '""':
            s = sdscatprintf(s,""\\%c"",*p);
            break;
        case '\n': s = sdscatlen(s,""\\n"",2); break;
        case '\f': s = sdscatlen(s,""\\f"",2); break;
        case '\r': s = sdscatlen(s,""\\r"",2); break;
        case '\t': s = sdscatlen(s,""\\t"",2); break;
        case '\b': s = sdscatlen(s,""\\b"",2); break;
        default:
            s = sdscatprintf(s,*(unsigned char *)p <= 0x1f ? ""\\u%04x"" : ""%c"",*p);
        }
        p++;
    }
    return sdscatlen(s,""\"""",1);
}",1,1,cli_common.c,escapeJsonString,,false,389,408,escapeJsonString,,,10,"sds escapeJsonString (sds,char*,size_t)"
39444,METHOD,cli_common.h:<global>,TYPE_DECL,<global>,1,26,cli_common.h,cli_common.h:<global>,,false,1,54,<global>,,,1,
39463,METHOD,cli_common.h:<global>,TYPE_DECL,"int cliSecureConnection(redisContext *c, cliSSLconfig config, const char **err);",5,79,cli_common.h,cliSecureConnection,,false,36,36,cliSecureConnection,,,5,"int cliSecureConnection (redisContext*,cliSSLconfig,char**)"
39470,METHOD,cli_common.h:<global>,TYPE_DECL,"ssize_t cliWriteConn(redisContext *c, const char *buf, size_t buf_len);",9,70,cli_common.h,cliWriteConn,,false,38,38,cliWriteConn,,,6,"ssize_t cliWriteConn (redisContext*,char*,size_t)"
39477,METHOD,cli_common.h:<global>,TYPE_DECL,int cliSecureInit(void);,5,23,cli_common.h,cliSecureInit,,false,40,40,cliSecureInit,,,7,int cliSecureInit (void)
39482,METHOD,cli_common.h:<global>,TYPE_DECL,sds readArgFromStdin(void);,5,26,cli_common.h,readArgFromStdin,,false,42,42,readArgFromStdin,,,8,sds readArgFromStdin (void)
39487,METHOD,cli_common.h:<global>,TYPE_DECL,"sds *getSdsArrayFromArgv(int argc,char **argv, int quoted);",5,58,cli_common.h,getSdsArrayFromArgv,,false,44,44,getSdsArrayFromArgv,,,9,"sds* getSdsArrayFromArgv (int,char**,int)"
39494,METHOD,cli_common.h:<global>,TYPE_DECL,sds unquoteCString(char *str);,5,29,cli_common.h,unquoteCString,,false,46,46,unquoteCString,,,10,sds unquoteCString (char*)
39499,METHOD,cli_common.h:<global>,TYPE_DECL,"void parseRedisUri(const char *uri, const char* tool_name, cliConnInfo *connInfo, int *tls_flag);",6,96,cli_common.h,parseRedisUri,,false,48,48,parseRedisUri,,,11,"void parseRedisUri (char*,char*,cliConnInfo*,int*)"
39507,METHOD,cli_common.h:<global>,TYPE_DECL,void freeCliConnInfo(cliConnInfo connInfo);,6,42,cli_common.h,freeCliConnInfo,,false,50,50,freeCliConnInfo,,,12,void freeCliConnInfo (cliConnInfo)
39512,METHOD,cli_common.h:<global>,TYPE_DECL,"sds escapeJsonString(sds s, const char *p, size_t len);",5,54,cli_common.h,escapeJsonString,,false,52,52,escapeJsonString,,,13,"sds escapeJsonString (sds,char*,size_t)"
39548,METHOD,cluster.c:<global>,TYPE_DECL,<global>,1,1,cluster.c,cluster.c:<global>,,false,1,7679,<global>,,,1,
39554,METHOD,cluster.c:<global>,TYPE_DECL,"clusterNode *createClusterNode(char *nodename, int flags);",13,57,cluster.c,createClusterNode,,false,51,51,createClusterNode,,,3,"clusterNode* createClusterNode (char*,int)"
39560,METHOD,cluster.c:<global>,TYPE_DECL,void clusterAddNode(clusterNode *node);,6,38,cluster.c,clusterAddNode,,false,52,52,clusterAddNode,,,4,void clusterAddNode (clusterNode*)
39565,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);",6,76,cluster.c,clusterAcceptHandler,,false,53,53,clusterAcceptHandler,,,5,"void clusterAcceptHandler (aeEventLoop*,int,void*,int)"
39573,METHOD,cluster.c:<global>,TYPE_DECL,void clusterReadHandler(connection *conn);,6,41,cluster.c,clusterReadHandler,,false,54,54,clusterReadHandler,,,6,void clusterReadHandler (connection*)
39578,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendPing(clusterLink *link, int type);",6,49,cluster.c,clusterSendPing,,false,55,55,clusterSendPing,,,7,"void clusterSendPing (clusterLink*,int)"
39584,METHOD,cluster.c:<global>,TYPE_DECL,void clusterSendFail(char *nodename);,6,36,cluster.c,clusterSendFail,,false,56,56,clusterSendFail,,,8,void clusterSendFail (char*)
39589,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request);",6,76,cluster.c,clusterSendFailoverAuthIfNeeded,,false,57,57,clusterSendFailoverAuthIfNeeded,,,9,"void clusterSendFailoverAuthIfNeeded (clusterNode*,clusterMsg*)"
39595,METHOD,cluster.c:<global>,TYPE_DECL,void clusterUpdateState(void);,6,29,cluster.c,clusterUpdateState,,false,58,58,clusterUpdateState,,,10,void clusterUpdateState (void)
39600,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeGetSlotBit(clusterNode *n, int slot);",5,51,cluster.c,clusterNodeGetSlotBit,,false,59,59,clusterNodeGetSlotBit,,,11,"int clusterNodeGetSlotBit (clusterNode*,int)"
39606,METHOD,cluster.c:<global>,TYPE_DECL,list *clusterGetNodesInMyShard(clusterNode *node);,6,49,cluster.c,clusterGetNodesInMyShard,,false,60,60,clusterGetNodesInMyShard,,,12,list* clusterGetNodesInMyShard (clusterNode*)
39611,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeAddSlave(clusterNode *master, clusterNode *slave);",5,64,cluster.c,clusterNodeAddSlave,,false,61,61,clusterNodeAddSlave,,,13,"int clusterNodeAddSlave (clusterNode*,clusterNode*)"
39617,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterAddSlot(clusterNode *n, int slot);",5,44,cluster.c,clusterAddSlot,,false,62,62,clusterAddSlot,,,14,"int clusterAddSlot (clusterNode*,int)"
39623,METHOD,cluster.c:<global>,TYPE_DECL,int clusterDelSlot(int slot);,5,28,cluster.c,clusterDelSlot,,false,63,63,clusterDelSlot,,,15,int clusterDelSlot (int)
39628,METHOD,cluster.c:<global>,TYPE_DECL,int clusterDelNodeSlots(clusterNode *node);,5,42,cluster.c,clusterDelNodeSlots,,false,64,64,clusterDelNodeSlots,,,16,int clusterDelNodeSlots (clusterNode*)
39633,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeSetSlotBit(clusterNode *n, int slot);",5,51,cluster.c,clusterNodeSetSlotBit,,false,65,65,clusterNodeSetSlotBit,,,17,"int clusterNodeSetSlotBit (clusterNode*,int)"
39639,METHOD,cluster.c:<global>,TYPE_DECL,void clusterSetMaster(clusterNode *n);,6,37,cluster.c,clusterSetMaster,,false,66,66,clusterSetMaster,,,18,void clusterSetMaster (clusterNode*)
39644,METHOD,cluster.c:<global>,TYPE_DECL,void clusterHandleSlaveFailover(void);,6,37,cluster.c,clusterHandleSlaveFailover,,false,67,67,clusterHandleSlaveFailover,,,19,void clusterHandleSlaveFailover (void)
39649,METHOD,cluster.c:<global>,TYPE_DECL,void clusterHandleSlaveMigration(int max_slaves);,6,48,cluster.c,clusterHandleSlaveMigration,,false,68,68,clusterHandleSlaveMigration,,,20,void clusterHandleSlaveMigration (int)
39654,METHOD,cluster.c:<global>,TYPE_DECL,"int bitmapTestBit(unsigned char *bitmap, int pos);",5,49,cluster.c,bitmapTestBit,,false,69,69,bitmapTestBit,,,21,"int bitmapTestBit (unsigned char*,int)"
39660,METHOD,cluster.c:<global>,TYPE_DECL,"void bitmapSetBit(unsigned char *bitmap, int pos);",6,49,cluster.c,bitmapSetBit,,false,70,70,bitmapSetBit,,,22,"void bitmapSetBit (unsigned char*,int)"
39666,METHOD,cluster.c:<global>,TYPE_DECL,"void bitmapClearBit(unsigned char *bitmap, int pos);",6,51,cluster.c,bitmapClearBit,,false,71,71,bitmapClearBit,,,23,"void bitmapClearBit (unsigned char*,int)"
39672,METHOD,cluster.c:<global>,TYPE_DECL,void clusterDoBeforeSleep(int flags);,6,36,cluster.c,clusterDoBeforeSleep,,false,72,72,clusterDoBeforeSleep,,,24,void clusterDoBeforeSleep (int)
39677,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendUpdate(clusterLink *link, clusterNode *node);",6,60,cluster.c,clusterSendUpdate,,false,73,73,clusterSendUpdate,,,25,"void clusterSendUpdate (clusterLink*,clusterNode*)"
39683,METHOD,cluster.c:<global>,TYPE_DECL,void resetManualFailover(void);,6,30,cluster.c,resetManualFailover,,false,74,74,resetManualFailover,,,26,void resetManualFailover (void)
39688,METHOD,cluster.c:<global>,TYPE_DECL,void clusterCloseAllSlots(void);,6,31,cluster.c,clusterCloseAllSlots,,false,75,75,clusterCloseAllSlots,,,27,void clusterCloseAllSlots (void)
39693,METHOD,cluster.c:<global>,TYPE_DECL,void clusterSetNodeAsMaster(clusterNode *n);,6,43,cluster.c,clusterSetNodeAsMaster,,false,76,76,clusterSetNodeAsMaster,,,28,void clusterSetNodeAsMaster (clusterNode*)
39698,METHOD,cluster.c:<global>,TYPE_DECL,void clusterDelNode(clusterNode *delnode);,6,41,cluster.c,clusterDelNode,,false,77,77,clusterDelNode,,,29,void clusterDelNode (clusterNode*)
39703,METHOD,cluster.c:<global>,TYPE_DECL,"sds representClusterNodeFlags(sds ci, uint16_t flags);",5,53,cluster.c,representClusterNodeFlags,,false,78,78,representClusterNodeFlags,,,30,"sds representClusterNodeFlags (sds,uint16_t)"
39709,METHOD,cluster.c:<global>,TYPE_DECL,"sds representSlotInfo(sds ci, uint16_t *slot_info_pairs, int slot_info_pairs_count);",5,83,cluster.c,representSlotInfo,,false,79,79,representSlotInfo,,,31,"sds representSlotInfo (sds,uint16_t*,int)"
39716,METHOD,cluster.c:<global>,TYPE_DECL,void clusterFreeNodesSlotsInfo(clusterNode *n);,6,46,cluster.c,clusterFreeNodesSlotsInfo,,false,80,80,clusterFreeNodesSlotsInfo,,,32,void clusterFreeNodesSlotsInfo (clusterNode*)
39721,METHOD,cluster.c:<global>,TYPE_DECL,uint64_t clusterGetMaxEpoch(void);,10,33,cluster.c,clusterGetMaxEpoch,,false,81,81,clusterGetMaxEpoch,,,33,uint64_t clusterGetMaxEpoch (void)
39726,METHOD,cluster.c:<global>,TYPE_DECL,int clusterBumpConfigEpochWithoutConsensus(void);,5,48,cluster.c,clusterBumpConfigEpochWithoutConsensus,,false,82,82,clusterBumpConfigEpochWithoutConsensus,,,34,int clusterBumpConfigEpochWithoutConsensus (void)
39731,METHOD,cluster.c:<global>,TYPE_DECL,"void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len);",6,132,cluster.c,moduleCallClusterReceivers,,false,83,83,moduleCallClusterReceivers,,,35,"void moduleCallClusterReceivers (char*,uint64_t,uint8_t,unsigned char*,uint32_t)"
39740,METHOD,cluster.c:<global>,TYPE_DECL,const char *clusterGetMessageTypeString(int type);,12,49,cluster.c,clusterGetMessageTypeString,,false,84,84,clusterGetMessageTypeString,,,36,char* clusterGetMessageTypeString (int)
39745,METHOD,cluster.c:<global>,TYPE_DECL,void removeChannelsInSlot(unsigned int slot);,6,44,cluster.c,removeChannelsInSlot,,false,85,85,removeChannelsInSlot,,,37,void removeChannelsInSlot (unsigned int)
39750,METHOD,cluster.c:<global>,TYPE_DECL,unsigned int countKeysInSlot(unsigned int hashslot);,14,51,cluster.c,countKeysInSlot,,false,86,86,countKeysInSlot,,,38,unsigned int countKeysInSlot (unsigned int)
39755,METHOD,cluster.c:<global>,TYPE_DECL,unsigned int countChannelsInSlot(unsigned int hashslot);,14,55,cluster.c,countChannelsInSlot,,false,87,87,countChannelsInSlot,,,39,unsigned int countChannelsInSlot (unsigned int)
39760,METHOD,cluster.c:<global>,TYPE_DECL,unsigned int delKeysInSlot(unsigned int hashslot);,14,49,cluster.c,delKeysInSlot,,false,88,88,delKeysInSlot,,,40,unsigned int delKeysInSlot (unsigned int)
39765,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterAddNodeToShard(const char *shard_id, clusterNode *node);",6,67,cluster.c,clusterAddNodeToShard,,false,89,89,clusterAddNodeToShard,,,41,"void clusterAddNodeToShard (char*,clusterNode*)"
39771,METHOD,cluster.c:<global>,TYPE_DECL,list *clusterLookupNodeListByShardId(const char *shard_id);,6,58,cluster.c,clusterLookupNodeListByShardId,,false,90,90,clusterLookupNodeListByShardId,,,42,list* clusterLookupNodeListByShardId (char*)
39776,METHOD,cluster.c:<global>,TYPE_DECL,void clusterRemoveNodeFromShard(clusterNode *node);,6,50,cluster.c,clusterRemoveNodeFromShard,,false,91,91,clusterRemoveNodeFromShard,,,43,void clusterRemoveNodeFromShard (clusterNode*)
39781,METHOD,cluster.c:<global>,TYPE_DECL,"int auxShardIdSetter(clusterNode *n, void *value, int length);",5,61,cluster.c,auxShardIdSetter,,false,92,92,auxShardIdSetter,,,44,"int auxShardIdSetter (clusterNode*,void*,int)"
39788,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxShardIdGetter(clusterNode *n, sds s);",5,43,cluster.c,auxShardIdGetter,,false,93,93,auxShardIdGetter,,,45,"sds auxShardIdGetter (clusterNode*,sds)"
39794,METHOD,cluster.c:<global>,TYPE_DECL,int auxShardIdPresent(clusterNode *n);,5,37,cluster.c,auxShardIdPresent,,false,94,94,auxShardIdPresent,,,46,int auxShardIdPresent (clusterNode*)
39799,METHOD,cluster.c:<global>,TYPE_DECL,"int auxHumanNodenameSetter(clusterNode *n, void *value, int length);",5,67,cluster.c,auxHumanNodenameSetter,,false,95,95,auxHumanNodenameSetter,,,47,"int auxHumanNodenameSetter (clusterNode*,void*,int)"
39806,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxHumanNodenameGetter(clusterNode *n, sds s);",5,49,cluster.c,auxHumanNodenameGetter,,false,96,96,auxHumanNodenameGetter,,,48,"sds auxHumanNodenameGetter (clusterNode*,sds)"
39812,METHOD,cluster.c:<global>,TYPE_DECL,int auxHumanNodenamePresent(clusterNode *n);,5,43,cluster.c,auxHumanNodenamePresent,,false,97,97,auxHumanNodenamePresent,,,49,int auxHumanNodenamePresent (clusterNode*)
39817,METHOD,cluster.c:<global>,TYPE_DECL,"int auxTcpPortSetter(clusterNode *n, void *value, int length);",5,61,cluster.c,auxTcpPortSetter,,false,98,98,auxTcpPortSetter,,,50,"int auxTcpPortSetter (clusterNode*,void*,int)"
39824,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxTcpPortGetter(clusterNode *n, sds s);",5,43,cluster.c,auxTcpPortGetter,,false,99,99,auxTcpPortGetter,,,51,"sds auxTcpPortGetter (clusterNode*,sds)"
39830,METHOD,cluster.c:<global>,TYPE_DECL,int auxTcpPortPresent(clusterNode *n);,5,37,cluster.c,auxTcpPortPresent,,false,100,100,auxTcpPortPresent,,,52,int auxTcpPortPresent (clusterNode*)
39835,METHOD,cluster.c:<global>,TYPE_DECL,"int auxTlsPortSetter(clusterNode *n, void *value, int length);",5,61,cluster.c,auxTlsPortSetter,,false,101,101,auxTlsPortSetter,,,53,"int auxTlsPortSetter (clusterNode*,void*,int)"
39842,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxTlsPortGetter(clusterNode *n, sds s);",5,43,cluster.c,auxTlsPortGetter,,false,102,102,auxTlsPortGetter,,,54,"sds auxTlsPortGetter (clusterNode*,sds)"
39848,METHOD,cluster.c:<global>,TYPE_DECL,int auxTlsPortPresent(clusterNode *n);,5,37,cluster.c,auxTlsPortPresent,,false,103,103,auxTlsPortPresent,,,55,int auxTlsPortPresent (clusterNode*)
39853,METHOD,cluster.c:<global>,TYPE_DECL,"static void clusterBuildMessageHdr(clusterMsg *hdr, int type, size_t msglen);",13,76,cluster.c,clusterBuildMessageHdr,,false,104,104,clusterBuildMessageHdr,,,56,"void clusterBuildMessageHdr (clusterMsg*,int,size_t)"
39860,METHOD,cluster.c:<global>,TYPE_DECL,"int getNodeDefaultClientPort(clusterNode *n) {
    return server.tls_cluster ? n->tls_port : n->tcp_port;
}",1,1,cluster.c,getNodeDefaultClientPort,,false,106,108,getNodeDefaultClientPort,,,57,int getNodeDefaultClientPort (clusterNode*)
39876,METHOD,cluster.c:<global>,TYPE_DECL,"static inline int getNodeDefaultReplicationPort(clusterNode *n) {
    return server.tls_replication ? n->tls_port : n->tcp_port;
}",1,1,cluster.c,getNodeDefaultReplicationPort,,false,110,112,getNodeDefaultReplicationPort,,,58,int getNodeDefaultReplicationPort (clusterNode*)
39892,METHOD,cluster.c:<global>,TYPE_DECL,"static inline int getNodeClientPort(clusterNode *n, int use_tls) {
    return use_tls ? n->tls_port : n->tcp_port;
}",1,1,cluster.c,getNodeClientPort,,false,114,116,getNodeClientPort,,,59,"int getNodeClientPort (clusterNode*,int)"
39907,METHOD,cluster.c:<global>,TYPE_DECL,"static inline int defaultClientPort(void) {
    return server.tls_cluster ? server.tls_port : server.port;
}",1,1,cluster.c,defaultClientPort,,false,118,120,defaultClientPort,,,60,int defaultClientPort (void)
39945,METHOD,cluster.c:<global>,TYPE_DECL,"static ConnectionType *connTypeOfCluster(void) {
    if (server.tls_cluster) {
        return connectionTypeTls();
    }

    return connectionTypeTcp();
}",1,1,cluster.c,connTypeOfCluster,,false,161,167,connTypeOfCluster,,,65,ConnectionType connTypeOfCluster (void)
39970,METHOD,cluster.c:<global>,TYPE_DECL,"typedef int (aux_value_setter) (clusterNode* n, void *value, int length);",13,72,cluster.c,aux_value_setter,,false,189,189,aux_value_setter,,,68,"int aux_value_setter (clusterNode*,void*,int)"
39977,METHOD,cluster.c:<global>,TYPE_DECL,"typedef sds (aux_value_getter) (clusterNode* n, sds s);",13,54,cluster.c,aux_value_getter,,false,193,193,aux_value_getter,,,69,"sds aux_value_getter (clusterNode*,sds)"
39983,METHOD,cluster.c:<global>,TYPE_DECL,typedef int (aux_value_present) (clusterNode* n);,13,48,cluster.c,aux_value_present,,false,195,195,aux_value_present,,,70,int aux_value_present (clusterNode*)
40025,METHOD,cluster.c:<global>,TYPE_DECL,"int isValidAuxChar(int c) {
    return isalnum(c) || (strchr(""!#$%&()*+:;<>?@[]^{|}~"", c) == NULL);
}",1,1,cluster.c,isValidAuxChar,,false,224,226,isValidAuxChar,,,77,int isValidAuxChar (int)
40039,METHOD,cluster.c:<global>,TYPE_DECL,"int isValidAuxString(char *s, unsigned int length) {
    for (unsigned i = 0; i < length; i++) {
        if (!isValidAuxChar(s[i])) return 0;
    }
    return 1;
}",1,1,cluster.c,isValidAuxString,,false,228,233,isValidAuxString,,,78,"int isValidAuxString (char*,unsigned int)"
40068,METHOD,cluster.c:<global>,TYPE_DECL,"int auxShardIdSetter(clusterNode *n, void *value, int length) {
    if (verifyClusterNodeId(value, length) == C_ERR) {
        return C_ERR;
    }
    memcpy(n->shard_id, value, CLUSTER_NAMELEN);
    /* if n already has replicas, make sure they all agree
     * on the shard id */
    for (int i = 0; i < n->numslaves; i++) {
        if (memcmp(n->slaves[i]->shard_id, n->shard_id, CLUSTER_NAMELEN) != 0) {
            return C_ERR;
        }
    }
    clusterAddNodeToShard(value, n);
    return C_OK;
}",1,46,cluster.c,auxShardIdSetter,,false,235,249,auxShardIdSetter,,,79,"int auxShardIdSetter (clusterNode*,void*,int)"
40142,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxShardIdGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%.40s"", n->shard_id);
}",1,1,cluster.c,auxShardIdGetter,,false,251,253,auxShardIdGetter,,,80,"sds auxShardIdGetter (clusterNode*,sds)"
40155,METHOD,cluster.c:<global>,TYPE_DECL,"int auxShardIdPresent(clusterNode *n) {
    return strlen(n->shard_id);
}",1,1,cluster.c,auxShardIdPresent,,false,255,257,auxShardIdPresent,,,81,int auxShardIdPresent (clusterNode*)
40165,METHOD,cluster.c:<global>,TYPE_DECL,"int auxHumanNodenameSetter(clusterNode *n, void *value, int length) {
    if (n && !strncmp(value, n->human_nodename, length)) {
        return C_OK;
    } else if (!n && (length == 0)) {
        return C_OK;
    }
    if (n) {
        n->human_nodename = sdscpylen(n->human_nodename, value, length);
    } else if (sdslen(n->human_nodename) != 0) {
        sdsclear(n->human_nodename);
    } else {
        return C_ERR;
    }
    return C_OK;
}",1,15,cluster.c,auxHumanNodenameSetter,,false,259,273,auxHumanNodenameSetter,,,82,"int auxHumanNodenameSetter (clusterNode*,void*,int)"
40239,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxHumanNodenameGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%s"", n->human_nodename);
}",1,1,cluster.c,auxHumanNodenameGetter,,false,275,277,auxHumanNodenameGetter,,,83,"sds auxHumanNodenameGetter (clusterNode*,sds)"
40252,METHOD,cluster.c:<global>,TYPE_DECL,"int auxHumanNodenamePresent(clusterNode *n) {
    return sdslen(n->human_nodename);
}",1,1,cluster.c,auxHumanNodenamePresent,,false,279,281,auxHumanNodenamePresent,,,84,int auxHumanNodenamePresent (clusterNode*)
40262,METHOD,cluster.c:<global>,TYPE_DECL,"int auxTcpPortSetter(clusterNode *n, void *value, int length) {
    if (length > 5 || length < 1) {
        return C_ERR;
    }
    char buf[length + 1];
    memcpy(buf, (char*)value, length);
    buf[length] = '\0';
    n->tcp_port = atoi(buf);
    return (n->tcp_port < 0 || n->tcp_port >= 65536) ? C_ERR : C_OK;
}",1,15,cluster.c,auxTcpPortSetter,,false,283,292,auxTcpPortSetter,,,85,"int auxTcpPortSetter (clusterNode*,void*,int)"
40321,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxTcpPortGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%d"", n->tcp_port);
}",1,1,cluster.c,auxTcpPortGetter,,false,294,296,auxTcpPortGetter,,,86,"sds auxTcpPortGetter (clusterNode*,sds)"
40334,METHOD,cluster.c:<global>,TYPE_DECL,"int auxTcpPortPresent(clusterNode *n) {
    return n->tcp_port >= 0 && n->tcp_port < 65536;
}",1,1,cluster.c,auxTcpPortPresent,,false,298,300,auxTcpPortPresent,,,87,int auxTcpPortPresent (clusterNode*)
40351,METHOD,cluster.c:<global>,TYPE_DECL,"int auxTlsPortSetter(clusterNode *n, void *value, int length) {
    if (length > 5 || length < 1) {
        return C_ERR;
    }
    char buf[length + 1];
    memcpy(buf, (char*)value, length);
    buf[length] = '\0';
    n->tls_port = atoi(buf);
    return (n->tls_port < 0 || n->tls_port >= 65536) ? C_ERR : C_OK;
}",1,15,cluster.c,auxTlsPortSetter,,false,302,311,auxTlsPortSetter,,,88,"int auxTlsPortSetter (clusterNode*,void*,int)"
40410,METHOD,cluster.c:<global>,TYPE_DECL,"sds auxTlsPortGetter(clusterNode *n, sds s) {
    return sdscatprintf(s, ""%d"", n->tls_port);
}",1,1,cluster.c,auxTlsPortGetter,,false,313,315,auxTlsPortGetter,,,89,"sds auxTlsPortGetter (clusterNode*,sds)"
40423,METHOD,cluster.c:<global>,TYPE_DECL,"int auxTlsPortPresent(clusterNode *n) {
    return n->tls_port >= 0 && n->tls_port < 65536;
}",1,1,cluster.c,auxTlsPortPresent,,false,317,319,auxTlsPortPresent,,,90,int auxTlsPortPresent (clusterNode*)
40445,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterLoadConfig(char *filename) {
    FILE *fp = fopen(filename,""r"");
    struct stat sb;
    char *line;
    int maxline, j;

    if (fp == NULL) {
        if (errno == ENOENT) {
            return C_ERR;
        } else {
            serverLog(LL_WARNING,
                ""Loading the cluster node config from %s: %s"",
                filename, strerror(errno));
            exit(1);
        }
    }

    if (redis_fstat(fileno(fp),&sb) == -1) {
        serverLog(LL_WARNING,
            ""Unable to obtain the cluster node config file stat %s: %s"",
            filename, strerror(errno));
        exit(1);
    }
    /* Check if the file is zero-length: if so return C_ERR to signal
     * we have to write the config. */
    if (sb.st_size == 0) {
        fclose(fp);
        return C_ERR;
    }

    /* Parse the file. Note that single lines of the cluster config file can
     * be really long as they include all the hash slots of the node.
     * This means in the worst possible case, ...",1,19,cluster.c,clusterLoadConfig,,false,338,692,clusterLoadConfig,,,93,int clusterLoadConfig (char*)
41825,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterSaveConfig(int do_fsync) {
    sds ci,tmpfilename;
    size_t content_size,offset = 0;
    ssize_t written_bytes;
    int fd = -1;
    int retval = C_ERR;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_SAVE_CONFIG;

    /* Get the nodes description and concatenate our ""vars"" directive to
     * save currentEpoch and lastVoteEpoch. */
    ci = clusterGenNodesDescription(NULL, CLUSTER_NODE_HANDSHAKE, 0);
    ci = sdscatprintf(ci,""vars currentEpoch %llu lastVoteEpoch %llu\n"",
        (unsigned long long) server.cluster->currentEpoch,
        (unsigned long long) server.cluster->lastVoteEpoch);
    content_size = sdslen(ci);

    /* Create a temp file with the new content. */
    tmpfilename = sdscatfmt(sdsempty(),""%s.tmp-%i-%I"",
        server.cluster_configfile,(int) getpid(),mstime());
    if ((fd = open(tmpfilename,O_WRONLY|O_CREAT,0644)) == -1) {
        serverLog(LL_WARNING,""Could not open temp cluster config file: %s"",strerror(errno));
        goto cleanup;
  ...",1,17,cluster.c,clusterSaveConfig,,false,706,769,clusterSaveConfig,,,94,int clusterSaveConfig (int)
42125,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSaveConfigOrDie(int do_fsync) {
    if (clusterSaveConfig(do_fsync) == -1) {
        serverLog(LL_WARNING,""Fatal: can't update cluster config file."");
        exit(1);
    }
}",1,8,cluster.c,clusterSaveConfigOrDie,,false,771,776,clusterSaveConfigOrDie,,,95,void clusterSaveConfigOrDie (int)
42157,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterLockConfig(char *filename) {
/* flock() does not exist on Solaris
 * and a fcntl-based solution won't help, as we constantly re-open that file,
 * which will release _all_ locks anyway
 */
#if !defined(__sun)
    /* To lock it, we need to open the file in a way it is created if
     * it does not exist, otherwise there is a race condition with other
     * processes. */
    int fd = open(filename,O_WRONLY|O_CREAT|O_CLOEXEC,0644);
    if (fd == -1) {
        serverLog(LL_WARNING,
            ""Can't open %s in order to acquire a lock: %s"",
            filename, strerror(errno));
        return C_ERR;
    }

    if (flock(fd,LOCK_EX|LOCK_NB) == -1) {
        if (errno == EWOULDBLOCK) {
            serverLog(LL_WARNING,
                 ""Sorry, the cluster configuration file %s is already used ""
                 ""by a different Redis Cluster node. Please make sure that ""
                 ""different nodes use different cluster configuration ""
                 ""files."", filenam...",1,8,cluster.c,clusterLockConfig,,false,787,833,clusterLockConfig,,,96,int clusterLockConfig (char*)
42278,METHOD,cluster.c:<global>,TYPE_DECL,"void deriveAnnouncedPorts(int *announced_tcp_port, int *announced_tls_port,
                          int *announced_cport) {
    /* Config overriding announced ports. */
    *announced_tcp_port = server.cluster_announce_port ? 
                          server.cluster_announce_port : server.port;
    *announced_tls_port = server.cluster_announce_tls_port ? 
                          server.cluster_announce_tls_port : server.tls_port;
    /* Derive cluster bus port. */
    if (server.cluster_announce_bus_port) {
        *announced_cport = server.cluster_announce_bus_port;
    } else if (server.cluster_port) {
        *announced_cport = server.cluster_port;
    } else {
        *announced_cport = defaultClientPort() + CLUSTER_PORT_INCR;
    }
}",1,49,cluster.c,deriveAnnouncedPorts,,false,836,851,deriveAnnouncedPorts,,,97,"void deriveAnnouncedPorts (int*,int*,int*)"
42345,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateMyselfFlags(void) {
    if (!myself) return;
    int oldflags = myself->flags;
    int nofailover = server.cluster_slave_no_failover ?
                     CLUSTER_NODE_NOFAILOVER : 0;
    myself->flags &= ~CLUSTER_NODE_NOFAILOVER;
    myself->flags |= nofailover;
    if (myself->flags != oldflags) {
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                             CLUSTER_TODO_UPDATE_STATE);
    }
}",1,21,cluster.c,clusterUpdateMyselfFlags,,false,857,868,clusterUpdateMyselfFlags,,,98,void clusterUpdateMyselfFlags (void)
42404,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateMyselfAnnouncedPorts(void) {
    if (!myself) return;
    deriveAnnouncedPorts(&myself->tcp_port,&myself->tls_port,&myself->cport);
}",1,1,cluster.c,clusterUpdateMyselfAnnouncedPorts,,false,874,877,clusterUpdateMyselfAnnouncedPorts,,,99,void clusterUpdateMyselfAnnouncedPorts (void)
42427,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateMyselfIp(void) {
    if (!myself) return;
    static char *prev_ip = NULL;
    char *curr_ip = server.cluster_announce_ip;
    int changed = 0;

    if (prev_ip == NULL && curr_ip != NULL) changed = 1;
    else if (prev_ip != NULL && curr_ip == NULL) changed = 1;
    else if (prev_ip && curr_ip && strcmp(prev_ip,curr_ip)) changed = 1;

    if (changed) {
        if (prev_ip) zfree(prev_ip);
        prev_ip = curr_ip;

        if (curr_ip) {
            /* We always take a copy of the previous IP address, by
            * duplicating the string. This way later we can check if
            * the address really changed. */
            prev_ip = zstrdup(prev_ip);
            redis_strlcpy(myself->ip,server.cluster_announce_ip,NET_IP_STR_LEN);
        } else {
            myself->ip[0] = '\0'; /* Force autodetection. */
        }
    }
}",1,64,cluster.c,clusterUpdateMyselfIp,,false,881,905,clusterUpdateMyselfIp,,,100,void clusterUpdateMyselfIp (void)
42528,METHOD,cluster.c:<global>,TYPE_DECL,"static void updateAnnouncedHostname(clusterNode *node, char *new) {
    /* Previous and new hostname are the same, no need to update. */
    if (new && !strcmp(new, node->hostname)) {
        return;
    } else if (!new && (sdslen(node->hostname) == 0)) {
        return;
    }

    if (new) {
        node->hostname = sdscpy(node->hostname, new);
    } else if (sdslen(node->hostname) != 0) {
        sdsclear(node->hostname);
    }
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}",1,25,cluster.c,updateAnnouncedHostname,,false,908,922,updateAnnouncedHostname,,,101,"void updateAnnouncedHostname (clusterNode*,char*)"
42591,METHOD,cluster.c:<global>,TYPE_DECL,"static void updateAnnouncedHumanNodename(clusterNode *node, char *new) {
    if (new && !strcmp(new, node->human_nodename)) {
        return;
    } else if (!new && (sdslen(node->human_nodename) == 0)) {
        return;
    }
    
    if (new) {
        node->human_nodename = sdscpy(node->human_nodename, new);
    } else if (sdslen(node->human_nodename) != 0) {
        sdsclear(node->human_nodename);
    }
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
}",1,25,cluster.c,updateAnnouncedHumanNodename,,false,924,937,updateAnnouncedHumanNodename,,,102,"void updateAnnouncedHumanNodename (clusterNode*,char*)"
42654,METHOD,cluster.c:<global>,TYPE_DECL,"static void updateShardId(clusterNode *node, const char *shard_id) {
    if (memcmp(node->shard_id, shard_id, CLUSTER_NAMELEN) != 0) {
        clusterRemoveNodeFromShard(node);
        memcpy(node->shard_id, shard_id, CLUSTER_NAMELEN);
        clusterAddNodeToShard(shard_id, node);
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG);
    }
    if (myself != node && myself->slaveof == node) {
        if (memcmp(myself->shard_id, shard_id, CLUSTER_NAMELEN) != 0) {
            /* shard-id can diverge right after a rolling upgrade
             * from pre-7.2 releases */
            clusterRemoveNodeFromShard(myself);
            memcpy(myself->shard_id, shard_id, CLUSTER_NAMELEN);
            clusterAddNodeToShard(shard_id, myself);
            clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|CLUSTER_TODO_FSYNC_CONFIG);
        }
    }
}",1,41,cluster.c,updateShardId,,false,940,957,updateShardId,,,103,"void updateShardId (clusterNode*,char*)"
42739,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateMyselfHostname(void) {
    if (!myself) return;
    updateAnnouncedHostname(myself, server.cluster_announce_hostname);
}",1,1,cluster.c,clusterUpdateMyselfHostname,,false,960,963,clusterUpdateMyselfHostname,,,104,void clusterUpdateMyselfHostname (void)
42754,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateMyselfHumanNodename(void) {
    if (!myself) return;
    updateAnnouncedHumanNodename(myself, server.cluster_announce_human_nodename);
}",1,1,cluster.c,clusterUpdateMyselfHumanNodename,,false,965,968,clusterUpdateMyselfHumanNodename,,,105,void clusterUpdateMyselfHumanNodename (void)
42769,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterInit(void) {
    int saveconf = 0;

    server.cluster = zmalloc(sizeof(clusterState));
    server.cluster->myself = NULL;
    server.cluster->currentEpoch = 0;
    server.cluster->state = CLUSTER_FAIL;
    server.cluster->size = 1;
    server.cluster->todo_before_sleep = 0;
    server.cluster->nodes = dictCreate(&clusterNodesDictType);
    server.cluster->shards = dictCreate(&clusterSdsToListType);
    server.cluster->nodes_black_list =
        dictCreate(&clusterNodesBlackListDictType);
    server.cluster->failover_auth_time = 0;
    server.cluster->failover_auth_count = 0;
    server.cluster->failover_auth_rank = 0;
    server.cluster->failover_auth_epoch = 0;
    server.cluster->cant_failover_reason = CLUSTER_CANT_FAILOVER_NONE;
    server.cluster->lastVoteEpoch = 0;

    /* Initialize stats */
    for (int i = 0; i < CLUSTERMSG_TYPE_COUNT; i++) {
        server.cluster->stats_bus_messages_sent[i] = 0;
        server.cluster->stats_bus_messages_received[i] = 0;
    }...",1,28,cluster.c,clusterInit,,false,970,1056,clusterInit,,,106,void clusterInit (void)
43156,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterInitListeners(void) {
    if (connectionIndexByType(connTypeOfCluster()->get_type(NULL)) < 0) {
        serverLog(LL_WARNING, ""Missing connection type %s, but it is required for the Cluster bus."", connTypeOfCluster()->get_type(NULL));
        exit(1);
    }

    int port = defaultClientPort();
    connListener *listener = &server.clistener;
    listener->count = 0;
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.cluster_port ? server.cluster_port : port + CLUSTER_PORT_INCR;
    listener->ct = connTypeOfCluster();
    if (connListen(listener) == C_ERR ) {
        /* Note: the following log text is matched by the test suite. */
        serverLog(LL_WARNING, ""Failed listening on port %u (cluster), aborting."", listener->port);
        exit(1);
    }
    
    if (createSocketAcceptHandler(&server.clistener, clusterAcceptHandler) != C_OK) {
        serverPanic(""Unrecoverable error creating Redis Cluste...",1,8,cluster.c,clusterInitListeners,,false,1058,1080,clusterInitListeners,,,107,void clusterInitListeners (void)
43299,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterReset(int hard) {
    dictIterator *di;
    dictEntry *de;
    int j;

    /* Turn into master. */
    if (nodeIsSlave(myself)) {
        clusterSetNodeAsMaster(myself);
        replicationUnsetMaster();
        emptyData(-1,EMPTYDB_NO_FLAGS,NULL);
    }

    /* Close slots, reset manual failover state. */
    clusterCloseAllSlots();
    resetManualFailover();

    /* Unassign all the slots. */
    for (j = 0; j < CLUSTER_SLOTS; j++) clusterDelSlot(j);

    /* Recreate shards dict */
    dictEmpty(server.cluster->shards, NULL);

    /* Forget all the nodes, but myself. */
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node == myself) continue;
        clusterDelNode(node);
    }
    dictReleaseIterator(di);

    /* Hard reset only: set epochs to 0, change node ID. */
    if (hard) {
        sds oldname;

        server.cluster->currentEpoch = 0;
        server.cluster-...",1,8,cluster.c,clusterReset,,false,1091,1150,clusterReset,,,108,void clusterReset (int)
43500,METHOD,cluster.c:<global>,TYPE_DECL,"static clusterMsgSendBlock *createClusterMsgSendBlock(int type, uint32_t msglen) {
    uint32_t blocklen = msglen + sizeof(clusterMsgSendBlock) - sizeof(clusterMsg);
    clusterMsgSendBlock *msgblock = zcalloc(blocklen);
    msgblock->refcount = 1;
    msgblock->totlen = blocklen;
    server.stat_cluster_links_memory += blocklen;
    clusterBuildMessageHdr(&msgblock->msg,type,msglen);
    return msgblock;
}",1,1,cluster.c,createClusterMsgSendBlock,,false,1155,1163,createClusterMsgSendBlock,,,109,"clusterMsgSendBlock createClusterMsgSendBlock (int,uint32_t)"
43545,METHOD,cluster.c:<global>,TYPE_DECL,"static void clusterMsgSendBlockDecrRefCount(void *node) {
    clusterMsgSendBlock *msgblock = (clusterMsgSendBlock*)node;
    msgblock->refcount--;
    serverAssert(msgblock->refcount >= 0);
    if (msgblock->refcount == 0) {
        server.stat_cluster_links_memory -= msgblock->totlen;
        zfree(msgblock);
    }
}",1,4,cluster.c,clusterMsgSendBlockDecrRefCount,,false,1165,1173,clusterMsgSendBlockDecrRefCount,,,110,void clusterMsgSendBlockDecrRefCount (void*)
43594,METHOD,cluster.c:<global>,TYPE_DECL,"clusterLink *createClusterLink(clusterNode *node) {
    clusterLink *link = zmalloc(sizeof(*link));
    link->ctime = mstime();
    link->send_msg_queue = listCreate();
    listSetFreeMethod(link->send_msg_queue, clusterMsgSendBlockDecrRefCount);
    link->head_msg_send_offset = 0;
    link->send_msg_queue_mem = sizeof(list);
    link->rcvbuf = zmalloc(link->rcvbuf_alloc = RCVBUF_INIT_LEN);
    link->rcvbuf_len = 0;
    server.stat_cluster_links_memory += link->rcvbuf_alloc + link->send_msg_queue_mem;
    link->conn = NULL;
    link->node = node;
    /* Related node can only possibly be known at link creation time if this is an outbound link */
    link->inbound = (node == NULL);
    if (!link->inbound) {
        node->link = link;
    }
    return link;
}",1,4,cluster.c,createClusterLink,,false,1175,1193,createClusterLink,,,111,clusterLink createClusterLink (clusterNode*)
43698,METHOD,cluster.c:<global>,TYPE_DECL,"void freeClusterLink(clusterLink *link) {
    if (link->conn) {
        connClose(link->conn);
        link->conn = NULL;
    }
    server.stat_cluster_links_memory -= sizeof(list) + listLength(link->send_msg_queue)*sizeof(listNode);
    listRelease(link->send_msg_queue);
    server.stat_cluster_links_memory -= link->rcvbuf_alloc;
    zfree(link->rcvbuf);
    if (link->node) {
        if (link->node->link == link) {
            serverAssert(!link->inbound);
            link->node->link = NULL;
        } else if (link->node->inbound_link == link) {
            serverAssert(link->inbound);
            link->node->inbound_link = NULL;
        }
    }
    zfree(link);
}",1,55,cluster.c,freeClusterLink,,false,1198,1217,freeClusterLink,,,112,void freeClusterLink (clusterLink*)
43833,METHOD,cluster.c:<global>,TYPE_DECL,"void setClusterNodeToInboundClusterLink(clusterNode *node, clusterLink *link) {
    serverAssert(!link->node);
    serverAssert(link->inbound);
    if (node->inbound_link) {
        /* A peer may disconnect and then reconnect with us, and it's not guaranteed that
         * we would always process the disconnection of the existing inbound link before
         * accepting a new existing inbound link. Therefore, it's possible to have more than
         * one inbound link from the same node at the same time. Our cleanup logic assumes
         * a one to one relationship between nodes and inbound links, so we need to kill
         * one of the links. The existing link is more likely the outdated one, but it's
         * possible the other node may need to open another link. */
        serverLog(LL_DEBUG, ""Replacing inbound link fd %d from node %.40s with fd %d"",
                node->inbound_link->conn->fd, node->name, link->conn->fd);
        freeClusterLink(node->inbound_link);
    }
...",1,4,cluster.c,setClusterNodeToInboundClusterLink,,false,1219,1237,setClusterNodeToInboundClusterLink,,,113,"void setClusterNodeToInboundClusterLink (clusterNode*,clusterLink*)"
43952,METHOD,cluster.c:<global>,TYPE_DECL,"static void clusterConnAcceptHandler(connection *conn) {
    clusterLink *link;

    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_VERBOSE,
                ""Error accepting cluster node connection: %s"", connGetLastError(conn));
        connClose(conn);
        return;
    }

    /* Create a link object we use to handle the connection.
     * It gets passed to the readable handler when data is available.
     * Initially the link->node pointer is set to NULL as we don't know
     * which node is, but the right node is references once we know the
     * node identity. */
    link = createClusterLink(NULL);
    link->conn = conn;
    connSetPrivateData(conn, link);

    /* Register read handler */
    connSetReadHandler(conn, clusterReadHandler);
}",1,8,cluster.c,clusterConnAcceptHandler,,false,1239,1260,clusterConnAcceptHandler,,,114,void clusterConnAcceptHandler (connection*)
44002,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd;
    int max = MAX_CLUSTER_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    int require_auth = TLS_CLIENT_AUTH_YES;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    /* If the server is starting up, don't accept cluster connections:
     * UPDATE messages may interact with the database content. */
    if (server.masterhost == NULL && server.loading) return;

    while(max--) {
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_VERBOSE,
                    ""Error accepting cluster node: %s"", server.neterr);
            return;
        }

        connection *conn = connCreateAccepted(connTypeOfCluster(), cfd, &require_auth);

        /* Make sure connection is not in an error state */
        if (connGetState(conn) != CONN_STATE_ACCEPTING) {
            se...",1,14,cluster.c,clusterAcceptHandler,,false,1263,1313,clusterAcceptHandler,,,115,"void clusterAcceptHandler (aeEventLoop*,int,void*,int)"
44213,METHOD,cluster.c:<global>,TYPE_DECL,"unsigned long getClusterConnectionsCount(void) {
    /* We decrement the number of nodes by one, since there is the
     * ""myself"" node too in the list. Each node uses two file descriptors,
     * one incoming and one outgoing, thus the multiplication by 2. */
    return server.cluster_enabled ?
           ((dictSize(server.cluster->nodes)-1)*2) : 0;
}",1,13,cluster.c,getClusterConnectionsCount,,false,1317,1323,getClusterConnectionsCount,,,116,unsigned long getClusterConnectionsCount (void)
44254,METHOD,cluster.c:<global>,TYPE_DECL,"unsigned int keyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) & 0x3FFF;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) & 0x3FFF;
}",1,1,cluster.c,keyHashSlot,,false,1335,1354,keyHashSlot,,,117,"unsigned int keyHashSlot (char*,int)"
44342,METHOD,cluster.c:<global>,TYPE_DECL,"clusterNode *createClusterNode(char *nodename, int flags) {
    clusterNode *node = zmalloc(sizeof(*node));

    if (nodename)
        memcpy(node->name, nodename, CLUSTER_NAMELEN);
    else
        getRandomHexChars(node->name, CLUSTER_NAMELEN);
    getRandomHexChars(node->shard_id, CLUSTER_NAMELEN);
    node->ctime = mstime();
    node->configEpoch = 0;
    node->flags = flags;
    memset(node->slots,0,sizeof(node->slots));
    node->slot_info_pairs = NULL;
    node->slot_info_pairs_count = 0;
    node->numslots = 0;
    node->numslaves = 0;
    node->slaves = NULL;
    node->slaveof = NULL;
    node->last_in_ping_gossip = 0;
    node->ping_sent = node->pong_received = 0;
    node->data_received = 0;
    node->fail_time = 0;
    node->link = NULL;
    node->inbound_link = NULL;
    memset(node->ip,0,sizeof(node->ip));
    node->hostname = sdsempty();
    node->human_nodename = sdsempty();
    node->tcp_port = 0;
    node->cport = 0;
    node->tls_port = 0;
    node->fail_reports =...",1,37,cluster.c,createClusterNode,,false,1367,1404,createClusterNode,,,118,"clusterNode createClusterNode (char*,int)"
44544,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {
    list *l = failing->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    /* If a failure report from the same sender already exists, just update
     * the timestamp. */
    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (fr->node == sender) {
            fr->time = mstime();
            return 0;
        }
    }

    /* Otherwise create a new report. */
    fr = zmalloc(sizeof(*fr));
    fr->node = sender;
    fr->time = mstime();
    listAddNodeTail(l,fr);
    return 1;
}",1,1,cluster.c,clusterNodeAddFailureReport,,false,1416,1439,clusterNodeAddFailureReport,,,119,"int clusterNodeAddFailureReport (clusterNode*,clusterNode*)"
44612,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterNodeCleanupFailureReports(clusterNode *node) {
    list *l = node->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;
    mstime_t maxtime = server.cluster_node_timeout *
                     CLUSTER_FAIL_REPORT_VALIDITY_MULT;
    mstime_t now = mstime();

    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (now - fr->time > maxtime) listDelNode(l,ln);
    }
}",1,21,cluster.c,clusterNodeCleanupFailureReports,,false,1446,1460,clusterNodeCleanupFailureReports,,,120,void clusterNodeCleanupFailureReports (clusterNode*)
44670,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {
    list *l = node->fail_reports;
    listNode *ln;
    listIter li;
    clusterNodeFailReport *fr;

    /* Search for a failure report from this sender. */
    listRewind(l,&li);
    while ((ln = listNext(&li)) != NULL) {
        fr = ln->value;
        if (fr->node == sender) break;
    }
    if (!ln) return 0; /* No failure report from this sender. */

    /* Remove the failure report. */
    listDelNode(l,ln);
    clusterNodeCleanupFailureReports(node);
    return 1;
}",1,1,cluster.c,clusterNodeDelFailureReport,,false,1473,1491,clusterNodeDelFailureReport,,,121,"int clusterNodeDelFailureReport (clusterNode*,clusterNode*)"
44724,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeFailureReportsCount(clusterNode *node) {
    clusterNodeCleanupFailureReports(node);
    return listLength(node->fail_reports);
}",1,11,cluster.c,clusterNodeFailureReportsCount,,false,1496,1499,clusterNodeFailureReportsCount,,,122,int clusterNodeFailureReportsCount (clusterNode*)
44742,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {
    int j;

    for (j = 0; j < master->numslaves; j++) {
        if (master->slaves[j] == slave) {
            if ((j+1) < master->numslaves) {
                int remaining_slaves = (master->numslaves - j) - 1;
                memmove(master->slaves+j,master->slaves+(j+1),
                        (sizeof(*master->slaves) * remaining_slaves));
            }
            master->numslaves--;
            if (master->numslaves == 0)
                master->flags &= ~CLUSTER_NODE_MIGRATE_TO;
            return C_OK;
        }
    }
    return C_ERR;
}",1,34,cluster.c,clusterNodeRemoveSlave,,false,1501,1518,clusterNodeRemoveSlave,,,123,"int clusterNodeRemoveSlave (clusterNode*,clusterNode*)"
44838,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {
    int j;

    /* If it's already a slave, don't add it again. */
    for (j = 0; j < master->numslaves; j++)
        if (master->slaves[j] == slave) return C_ERR;
    master->slaves = zrealloc(master->slaves,
        sizeof(clusterNode*)*(master->numslaves+1));
    master->slaves[master->numslaves] = slave;
    master->numslaves++;
    master->flags |= CLUSTER_NODE_MIGRATE_TO;
    return C_OK;
}",1,47,cluster.c,clusterNodeAddSlave,,false,1520,1532,clusterNodeAddSlave,,,124,"int clusterNodeAddSlave (clusterNode*,clusterNode*)"
44911,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterCountNonFailingSlaves(clusterNode *n) {
    int j, okslaves = 0;

    for (j = 0; j < n->numslaves; j++)
        if (!nodeFailed(n->slaves[j])) okslaves++;
    return okslaves;
}",1,13,cluster.c,clusterCountNonFailingSlaves,,false,1534,1540,clusterCountNonFailingSlaves,,,125,int clusterCountNonFailingSlaves (clusterNode*)
44956,METHOD,cluster.c:<global>,TYPE_DECL,"void freeClusterNode(clusterNode *n) {
    sds nodename;
    int j;

    /* If the node has associated slaves, we have to set
     * all the slaves->slaveof fields to NULL (unknown). */
    for (j = 0; j < n->numslaves; j++)
        n->slaves[j]->slaveof = NULL;

    /* Remove this node from the list of slaves of its master. */
    if (nodeIsSlave(n) && n->slaveof) clusterNodeRemoveSlave(n->slaveof,n);

    /* Unlink from the set of nodes. */
    nodename = sdsnewlen(n->name, CLUSTER_NAMELEN);
    serverAssert(dictDelete(server.cluster->nodes,nodename) == DICT_OK);
    sdsfree(nodename);
    sdsfree(n->hostname);
    sdsfree(n->human_nodename);

    /* Release links and associated data structures. */
    if (n->link) freeClusterLink(n->link);
    if (n->inbound_link) freeClusterLink(n->inbound_link);
    listRelease(n->fail_reports);
    zfree(n->slaves);
    zfree(n);
}",1,8,cluster.c,freeClusterNode,,false,1543,1568,freeClusterNode,,,126,void freeClusterNode (clusterNode*)
45072,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterAddNode(clusterNode *node) {
    int retval;

    retval = dictAdd(server.cluster->nodes,
            sdsnewlen(node->name,CLUSTER_NAMELEN), node);
    serverAssert(retval == DICT_OK);
}",1,33,cluster.c,clusterAddNode,,false,1571,1577,clusterAddNode,,,127,void clusterAddNode (clusterNode*)
45110,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterDelNode(clusterNode *delnode) {
    int j;
    dictIterator *di;
    dictEntry *de;

    /* 1) Mark slots as unassigned. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (server.cluster->importing_slots_from[j] == delnode)
            server.cluster->importing_slots_from[j] = NULL;
        if (server.cluster->migrating_slots_to[j] == delnode)
            server.cluster->migrating_slots_to[j] = NULL;
        if (server.cluster->slots[j] == delnode)
            clusterDelSlot(j);
    }

    /* 2) Remove failure reports. */
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node == delnode) continue;
        clusterNodeDelFailureReport(node,delnode);
    }
    dictReleaseIterator(di);

    /* 3) Remove the node from the owning shard */
    clusterRemoveNodeFromShard(delnode);

    /* 4) Free the node, unlinking it from the cluster. */
    freeClusterNode(delnode);
}",1,20,cluster.c,clusterDelNode,,false,1591,1621,clusterDelNode,,,128,void clusterDelNode (clusterNode*)
45220,METHOD,cluster.c:<global>,TYPE_DECL,"int verifyClusterNodeId(const char *name, int length) {
    if (length != CLUSTER_NAMELEN) return C_ERR;
    for (int i = 0; i < length; i++) {
        if (name[i] >= 'a' && name[i] <= 'z') continue;
        if (name[i] >= '0' && name[i] <= '9') continue;
        return C_ERR;
    }
    return C_OK;
}",1,18,cluster.c,verifyClusterNodeId,,false,1625,1633,verifyClusterNodeId,,,129,"int verifyClusterNodeId (char*,int)"
45287,METHOD,cluster.c:<global>,TYPE_DECL,"clusterNode *clusterLookupNode(const char *name, int length) {
    if (verifyClusterNodeId(name, length) != C_OK) return NULL;
    sds s = sdsnewlen(name, length);
    dictEntry *de = dictFind(server.cluster->nodes, s);
    sdsfree(s);
    if (de == NULL) return NULL;
    return dictGetVal(de);
}",1,45,cluster.c,clusterLookupNode,,false,1636,1643,clusterLookupNode,,,130,"clusterNode clusterLookupNode (char*,int)"
45332,METHOD,cluster.c:<global>,TYPE_DECL,"list *clusterGetNodesInMyShard(clusterNode *node) {
    sds s = sdsnewlen(node->shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards,s);
    sdsfree(s);
    return (de != NULL) ? dictGetVal(de) : NULL;
}",1,38,cluster.c,clusterGetNodesInMyShard,,false,1651,1656,clusterGetNodesInMyShard,,,131,list clusterGetNodesInMyShard (clusterNode*)
45367,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterRenameNode(clusterNode *node, char *newname) {
    int retval;
    sds s = sdsnewlen(node->name, CLUSTER_NAMELEN);

    serverLog(LL_DEBUG,""Renaming node %.40s into %.40s"",
        node->name, newname);
    retval = dictDelete(server.cluster->nodes, s);
    sdsfree(s);
    serverAssert(retval == DICT_OK);
    memcpy(node->name, newname, CLUSTER_NAMELEN);
    clusterAddNode(node);
}",1,34,cluster.c,clusterRenameNode,,false,1662,1673,clusterRenameNode,,,132,"void clusterRenameNode (clusterNode*,char*)"
45443,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterAddNodeToShard(const char *shard_id, clusterNode *node) {
    sds s = sdsnewlen(shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards,s);
    if (de == NULL) {
        list *l = listCreate();
        listAddNodeTail(l, node);
        serverAssert(dictAdd(server.cluster->shards, s, l) == DICT_OK);
    } else {
        list *l = dictGetVal(de);
        if (listSearchKey(l, node) == NULL) {
            listAddNodeTail(l, node);
        }
        sdsfree(s);
    }
}",1,32,cluster.c,clusterAddNodeToShard,,false,1675,1689,clusterAddNodeToShard,,,133,"void clusterAddNodeToShard (char*,clusterNode*)"
45521,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterRemoveNodeFromShard(clusterNode *node) {
    sds s = sdsnewlen(node->shard_id, CLUSTER_NAMELEN);
    dictEntry *de = dictFind(server.cluster->shards, s);
    if (de != NULL) {
        list *l = dictGetVal(de);
        listNode *ln = listSearchKey(l, node);
        if (ln != NULL) {
            listDelNode(l, ln);
        }
        if (listLength(l) == 0) {
            dictDelete(server.cluster->shards, s);
        }
    }
    sdsfree(s);
}",1,38,cluster.c,clusterRemoveNodeFromShard,,false,1691,1705,clusterRemoveNodeFromShard,,,134,void clusterRemoveNodeFromShard (clusterNode*)
45589,METHOD,cluster.c:<global>,TYPE_DECL,"uint64_t clusterGetMaxEpoch(void) {
    uint64_t max = 0;
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->configEpoch > max) max = node->configEpoch;
    }
    dictReleaseIterator(di);
    if (max < server.cluster->currentEpoch) max = server.cluster->currentEpoch;
    return max;
}",1,1,cluster.c,clusterGetMaxEpoch,,false,1713,1726,clusterGetMaxEpoch,,,135,uint64_t clusterGetMaxEpoch (void)
45653,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterBumpConfigEpochWithoutConsensus(void) {
    uint64_t maxEpoch = clusterGetMaxEpoch();

    if (myself->configEpoch == 0 ||
        myself->configEpoch != maxEpoch)
    {
        server.cluster->currentEpoch++;
        myself->configEpoch = server.cluster->currentEpoch;
        clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                             CLUSTER_TODO_FSYNC_CONFIG);
        serverLog(LL_NOTICE,
            ""New configEpoch set to %llu"",
            (unsigned long long) myself->configEpoch);
        return C_OK;
    } else {
        return C_ERR;
    }
}",1,29,cluster.c,clusterBumpConfigEpochWithoutConsensus,,false,1757,1774,clusterBumpConfigEpochWithoutConsensus,,,136,int clusterBumpConfigEpochWithoutConsensus (void)
45736,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterHandleConfigEpochCollision(clusterNode *sender) {
    /* Prerequisites: nodes have the same configEpoch and are both masters. */
    if (sender->configEpoch != myself->configEpoch ||
        !nodeIsMaster(sender) || !nodeIsMaster(myself)) return;
    /* Don't act if the colliding node has a smaller Node ID. */
    if (memcmp(sender->name,myself->name,CLUSTER_NAMELEN) <= 0) return;
    /* Get the next ID available at the best of this node knowledge. */
    server.cluster->currentEpoch++;
    myself->configEpoch = server.cluster->currentEpoch;
    clusterSaveConfigOrDie(1);
    serverLog(LL_VERBOSE,
        ""WARNING: configEpoch collision with node %.40s (%s).""
        "" configEpoch set to %llu"",
        sender->name,sender->human_nodename,
        (unsigned long long) myself->configEpoch);
}",1,9,cluster.c,clusterHandleConfigEpochCollision,,false,1822,1837,clusterHandleConfigEpochCollision,,,137,void clusterHandleConfigEpochCollision (clusterNode*)
45832,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterBlacklistCleanup(void) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes_black_list);
    while((de = dictNext(di)) != NULL) {
        int64_t expire = dictGetUnsignedIntegerVal(de);

        if (expire < server.unixtime)
            dictDelete(server.cluster->nodes_black_list,dictGetKey(de));
    }
    dictReleaseIterator(di);
}",1,1,cluster.c,clusterBlacklistCleanup,,false,1870,1882,clusterBlacklistCleanup,,,138,void clusterBlacklistCleanup (void)
45877,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterBlacklistAddNode(clusterNode *node) {
    dictEntry *de;
    sds id = sdsnewlen(node->name,CLUSTER_NAMELEN);

    clusterBlacklistCleanup();
    if (dictAdd(server.cluster->nodes_black_list,id,NULL) == DICT_OK) {
        /* If the key was added, duplicate the sds string representation of
         * the key for the next lookup. We'll free it at the end. */
        id = sdsdup(id);
    }
    de = dictFind(server.cluster->nodes_black_list,id);
    dictSetUnsignedIntegerVal(de,time(NULL)+CLUSTER_BLACKLIST_TTL);
    sdsfree(id);
}",1,34,cluster.c,clusterBlacklistAddNode,,false,1885,1898,clusterBlacklistAddNode,,,139,void clusterBlacklistAddNode (clusterNode*)
45931,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterBlacklistExists(char *nodeid) {
    sds id = sdsnewlen(nodeid,CLUSTER_NAMELEN);
    int retval;

    clusterBlacklistCleanup();
    retval = dictFind(server.cluster->nodes_black_list,id) != NULL;
    sdsfree(id);
    return retval;
}",1,30,cluster.c,clusterBlacklistExists,,false,1903,1911,clusterBlacklistExists,,,140,int clusterBlacklistExists (char*)
45961,METHOD,cluster.c:<global>,TYPE_DECL,"void markNodeAsFailingIfNeeded(clusterNode *node) {
    int failures;
    int needed_quorum = (server.cluster->size / 2) + 1;

    if (!nodeTimedOut(node)) return; /* We can reach it. */
    if (nodeFailed(node)) return; /* Already FAILing. */

    failures = clusterNodeFailureReportsCount(node);
    /* Also count myself as a voter if I'm a master. */
    if (nodeIsMaster(myself)) failures++;
    if (failures < needed_quorum) return; /* No weak agreement from masters. */

    serverLog(LL_NOTICE,
        ""Marking node %.40s (%s) as failing (quorum reached)."", node->name, node->human_nodename);

    /* Mark the node as failing. */
    node->flags &= ~CLUSTER_NODE_PFAIL;
    node->flags |= CLUSTER_NODE_FAIL;
    node->fail_time = mstime();

    /* Broadcast the failing node name to everybody, forcing all the other
     * reachable nodes to flag the node as FAIL.
     * We do that even if this node is a replica and not a master: anyway
     * the failing state is triggered collecting f...",1,9,cluster.c,markNodeAsFailingIfNeeded,,false,1938,1965,markNodeAsFailingIfNeeded,,,141,void markNodeAsFailingIfNeeded (clusterNode*)
46084,METHOD,cluster.c:<global>,TYPE_DECL,"void clearNodeFailureIfNeeded(clusterNode *node) {
    mstime_t now = mstime();

    serverAssert(nodeFailed(node));

    /* For slaves we always clear the FAIL flag if we can contact the
     * node again. */
    if (nodeIsSlave(node) || node->numslots == 0) {
        serverLog(LL_NOTICE,
            ""Clear FAIL state for node %.40s (%s):%s is reachable again."",
                node->name,node->human_nodename,
                nodeIsSlave(node) ? ""replica"" : ""master without slots"");
        node->flags &= ~CLUSTER_NODE_FAIL;
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE|CLUSTER_TODO_SAVE_CONFIG);
    }

    /* If it is a master and...
     * 1) The FAIL state is old enough.
     * 2) It is yet serving slots from our point of view (not failed over).
     * Apparently no one is going to fix these slots, clear the FAIL flag. */
    if (nodeIsMaster(node) && node->numslots > 0 &&
        (now - node->fail_time) >
        (server.cluster_node_timeout * CLUSTER_FAIL_UNDO_TIME_MUL...",1,4,cluster.c,clearNodeFailureIfNeeded,,false,1970,2000,clearNodeFailureIfNeeded,,,142,void clearNodeFailureIfNeeded (clusterNode*)
46253,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterHandshakeInProgress(char *ip, int port, int cport) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (!nodeInHandshake(node)) continue;
        if (!strcasecmp(node->ip,ip) &&
            getNodeDefaultClientPort(node) == port &&
            node->cport == cport) break;
    }
    dictReleaseIterator(di);
    return de != NULL;
}",1,13,cluster.c,clusterHandshakeInProgress,,false,2005,2020,clusterHandshakeInProgress,,,143,"int clusterHandshakeInProgress (char*,int,int)"
46321,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterStartHandshake(char *ip, int port, int cport) {
    clusterNode *n;
    char norm_ip[NET_IP_STR_LEN];
    struct sockaddr_storage sa;

    /* IP sanity check */
    if (inet_pton(AF_INET,ip,
            &(((struct sockaddr_in *)&sa)->sin_addr)))
    {
        sa.ss_family = AF_INET;
    } else if (inet_pton(AF_INET6,ip,
            &(((struct sockaddr_in6 *)&sa)->sin6_addr)))
    {
        sa.ss_family = AF_INET6;
    } else {
        errno = EINVAL;
        return 0;
    }

    /* Port sanity check */
    if (port <= 0 || port > 65535 || cport <= 0 || cport > 65535) {
        errno = EINVAL;
        return 0;
    }

    /* Set norm_ip as the normalized string representation of the node
     * IP address. */
    memset(norm_ip,0,NET_IP_STR_LEN);
    if (sa.ss_family == AF_INET)
        inet_ntop(AF_INET,
            (void*)&(((struct sockaddr_in *)&sa)->sin_addr),
            norm_ip,NET_IP_STR_LEN);
    else
        inet_ntop(AF_INET6,
            (void*)&(((struct socka...",1,17,cluster.c,clusterStartHandshake,,false,2029,2084,clusterStartHandshake,,,144,"int clusterStartHandshake (char*,int,int)"
46498,METHOD,cluster.c:<global>,TYPE_DECL,"static void getClientPortFromClusterMsg(clusterMsg *hdr, int *tls_port, int *tcp_port) {
    if (server.tls_cluster) {
        *tls_port = ntohs(hdr->port);
        *tcp_port = ntohs(hdr->pport);
    } else {
        *tls_port = ntohs(hdr->pport);
        *tcp_port = ntohs(hdr->port);
    }
}",1,1,cluster.c,getClientPortFromClusterMsg,,false,2086,2094,getClientPortFromClusterMsg,,,145,"void getClientPortFromClusterMsg (clusterMsg*,int*,int*)"
46540,METHOD,cluster.c:<global>,TYPE_DECL,"static void getClientPortFromGossip(clusterMsgDataGossip *g, int *tls_port, int *tcp_port) {
    if (server.tls_cluster) {
        *tls_port = ntohs(g->port);
        *tcp_port = ntohs(g->pport);
    } else {
        *tls_port = ntohs(g->pport);
        *tcp_port = ntohs(g->port);
    }
}",1,1,cluster.c,getClientPortFromGossip,,false,2096,2104,getClientPortFromGossip,,,146,"void getClientPortFromGossip (clusterMsgDataGossip*,int*,int*)"
46582,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {
    uint16_t count = ntohs(hdr->count);
    clusterMsgDataGossip *g = (clusterMsgDataGossip*) hdr->data.ping.gossip;
    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);

    while(count--) {
        uint16_t flags = ntohs(g->flags);
        clusterNode *node;
        sds ci;

        if (server.verbosity == LL_DEBUG) {
            ci = representClusterNodeFlags(sdsempty(), flags);
            serverLog(LL_DEBUG,""GOSSIP %.40s %s:%d@%d %s"",
                g->nodename,
                g->ip,
                ntohs(g->port),
                ntohs(g->cport),
                ci);
            sdsfree(ci);
        }

        /* Convert port and pport into TCP port and TLS port. */
        int msg_tls_port, msg_tcp_port;
        getClientPortFromGossip(g, &msg_tls_port, &msg_tcp_port);

        /* Update our state accordingly to the gossip sections */
        node = cluster...",1,83,cluster.c,clusterProcessGossipSection,,false,2110,2226,clusterProcessGossipSection,,,147,"void clusterProcessGossipSection (clusterMsg*,clusterLink*)"
47045,METHOD,cluster.c:<global>,TYPE_DECL,"int nodeIp2String(char *buf, clusterLink *link, char *announced_ip) {
    if (announced_ip[0] != '\0') {
        memcpy(buf,announced_ip,NET_IP_STR_LEN);
        buf[NET_IP_STR_LEN-1] = '\0'; /* We are not sure the input is sane. */
        return C_OK;
    } else {
        if (connAddrPeerName(link->conn, buf, NET_IP_STR_LEN, NULL) == -1) {
            serverLog(LL_NOTICE, ""Error converting peer IP to string: %s"",
                link->conn ? connGetLastError(link->conn) : ""no link"");
            return C_ERR;
        }
        return C_OK;
    }
}",1,32,cluster.c,nodeIp2String,,false,2231,2244,nodeIp2String,,,148,"int nodeIp2String (char*,clusterLink*,char*)"
47130,METHOD,cluster.c:<global>,TYPE_DECL,"int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link,
                              clusterMsg *hdr)
{
    char ip[NET_IP_STR_LEN] = {0};
    int cport = ntohs(hdr->cport);
    int tcp_port, tls_port;
    getClientPortFromClusterMsg(hdr, &tls_port, &tcp_port);

    /* We don't proceed if the link is the same as the sender link, as this
     * function is designed to see if the node link is consistent with the
     * symmetric link that is used to receive PINGs from the node.
     *
     * As a side effect this function never frees the passed 'link', so
     * it is safe to call during packet processing. */
    if (link == node->link) return 0;

    /* If the peer IP is unavailable for some reasons like invalid fd or closed
     * link, just give up the update this time, and the update will be retried
     * in the next round of PINGs */
    if (nodeIp2String(ip,link,hdr->myip) == C_ERR) return 0;

    if (node->tcp_port == tcp_port && node->cport == cport && node->tls_...",1,12,cluster.c,nodeUpdateAddressIfNeeded,,false,2258,2297,nodeUpdateAddressIfNeeded,,,149,"int nodeUpdateAddressIfNeeded (clusterNode*,clusterLink*,clusterMsg*)"
47302,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSetNodeAsMaster(clusterNode *n) {
    if (nodeIsMaster(n)) return;

    if (n->slaveof) {
        clusterNodeRemoveSlave(n->slaveof,n);
        if (n != myself) n->flags |= CLUSTER_NODE_MIGRATE_TO;
    }
    n->flags &= ~CLUSTER_NODE_SLAVE;
    n->flags |= CLUSTER_NODE_MASTER;
    n->slaveof = NULL;

    /* Update config and state. */
    clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
                         CLUSTER_TODO_UPDATE_STATE);
}",1,8,cluster.c,clusterSetNodeAsMaster,,false,2302,2316,clusterSetNodeAsMaster,,,150,void clusterSetNodeAsMaster (clusterNode*)
47372,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {
    int j;
    clusterNode *curmaster = NULL, *newmaster = NULL;
    /* The dirty slots list is a list of slots for which we lose the ownership
     * while having still keys inside. This usually happens after a failover
     * or after a manual cluster reconfiguration operated by the admin.
     *
     * If the update message is not able to demote a master to slave (in this
     * case we'll resync with the master updating the whole key space), we
     * need to delete all the keys in the slots we lost ownership. */
    uint16_t dirty_slots[CLUSTER_SLOTS];
    int dirty_slots_count = 0;

    /* We should detect if sender is new master of our shard.
     * We will know it if all our slots were migrated to sender, and sender
     * has no slots except ours */
    int sender_slots = 0;
    int migrated_our_slots = 0;

    /* Here we set curmaster to this node or the node this nod...",1,25,cluster.c,clusterUpdateSlotsConfigWith,,false,2329,2465,clusterUpdateSlotsConfigWith,,,151,"void clusterUpdateSlotsConfigWith (clusterNode*,uint64_t,unsigned char*)"
47783,METHOD,cluster.c:<global>,TYPE_DECL,"static uint32_t getPingExtLength(clusterMsgPingExt *ext) {
    return ntohl(ext->length);
}",1,1,cluster.c,getPingExtLength,,false,2478,2480,getPingExtLength,,,152,uint32_t getPingExtLength (clusterMsgPingExt*)
47793,METHOD,cluster.c:<global>,TYPE_DECL,"static clusterMsgPingExt *getInitialPingExt(clusterMsg *hdr, int count) {
    clusterMsgPingExt *initial = (clusterMsgPingExt*) &(hdr->data.ping.gossip[count]);
    return initial;
}",1,1,cluster.c,getInitialPingExt,,false,2484,2487,getInitialPingExt,,,153,"clusterMsgPingExt getInitialPingExt (clusterMsg*,int)"
47816,METHOD,cluster.c:<global>,TYPE_DECL,"static clusterMsgPingExt *getNextPingExt(clusterMsgPingExt *ext) {
    clusterMsgPingExt *next = (clusterMsgPingExt *) (((char *) ext) + getPingExtLength(ext));
    return next;
}",1,1,cluster.c,getNextPingExt,,false,2491,2494,getNextPingExt,,,154,clusterMsgPingExt getNextPingExt (clusterMsgPingExt*)
47834,METHOD,cluster.c:<global>,TYPE_DECL,"uint32_t getAlignedPingExtSize(uint32_t dataSize) {

    return sizeof(clusterMsgPingExt) + EIGHT_BYTE_ALIGN(dataSize);
}",1,39,cluster.c,getAlignedPingExtSize,,false,2497,2500,getAlignedPingExtSize,,,155,uint32_t getAlignedPingExtSize (uint32_t)
47853,METHOD,cluster.c:<global>,TYPE_DECL,"uint32_t getHostnamePingExtSize(void) {
    if (sdslen(myself->hostname) == 0) {
        return 0;
    }
    return getAlignedPingExtSize(sdslen(myself->hostname) + 1);
}",1,1,cluster.c,getHostnamePingExtSize,,false,2502,2507,getHostnamePingExtSize,,,156,uint32_t getHostnamePingExtSize (void)
47876,METHOD,cluster.c:<global>,TYPE_DECL,"uint32_t getHumanNodenamePingExtSize(void) {
    if (sdslen(myself->human_nodename) == 0) {
        return 0;
    }
    return getAlignedPingExtSize(sdslen(myself->human_nodename) + 1);
}",1,1,cluster.c,getHumanNodenamePingExtSize,,false,2509,2514,getHumanNodenamePingExtSize,,,157,uint32_t getHumanNodenamePingExtSize (void)
47899,METHOD,cluster.c:<global>,TYPE_DECL,"uint32_t getShardIdPingExtSize(void) {
    return getAlignedPingExtSize(sizeof(clusterMsgPingExtShardId));
}",1,1,cluster.c,getShardIdPingExtSize,,false,2516,2518,getShardIdPingExtSize,,,158,uint32_t getShardIdPingExtSize (void)
47908,METHOD,cluster.c:<global>,TYPE_DECL,"uint32_t getForgottenNodeExtSize(void) {
    return getAlignedPingExtSize(sizeof(clusterMsgPingExtForgottenNode));
}",1,1,cluster.c,getForgottenNodeExtSize,,false,2520,2522,getForgottenNodeExtSize,,,159,uint32_t getForgottenNodeExtSize (void)
47917,METHOD,cluster.c:<global>,TYPE_DECL,"void *preparePingExt(clusterMsgPingExt *ext, uint16_t type, uint32_t length) {
    ext->type = htons(type);
    ext->length = htonl(length);
    return &ext->ext[0];
}",1,1,cluster.c,preparePingExt,,false,2524,2528,preparePingExt,,,160,"void* preparePingExt (clusterMsgPingExt*,uint16_t,uint32_t)"
47943,METHOD,cluster.c:<global>,TYPE_DECL,"clusterMsgPingExt *nextPingExt(clusterMsgPingExt *ext) {
    return (clusterMsgPingExt *)((char*)ext + ntohl(ext->length));
}",1,1,cluster.c,nextPingExt,,false,2530,2532,nextPingExt,,,161,clusterMsgPingExt nextPingExt (clusterMsgPingExt*)
47959,METHOD,cluster.c:<global>,TYPE_DECL,"uint32_t writePingExt(clusterMsg *hdr, int gossipcount)  {
    uint16_t extensions = 0;
    uint32_t totlen = 0;
    clusterMsgPingExt *cursor = NULL;
    /* Set the initial extension position */
    if (hdr != NULL) {
        cursor = getInitialPingExt(hdr, gossipcount);
    }

    /* hostname is optional */
    if (sdslen(myself->hostname) != 0) {
        if (cursor != NULL) {
            /* Populate hostname */
            clusterMsgPingExtHostname *ext = preparePingExt(cursor, CLUSTERMSG_EXT_TYPE_HOSTNAME, getHostnamePingExtSize());
            memcpy(ext->hostname, myself->hostname, sdslen(myself->hostname));

            /* Move the write cursor */
            cursor = nextPingExt(cursor);
        }

        totlen += getHostnamePingExtSize();
        extensions++;
    }

    if (sdslen(myself->human_nodename) != 0) {
        if (cursor != NULL) {
            /* Populate human_nodename */
            clusterMsgPingExtHumanNodename *ext = preparePingExt(cursor, CLUSTERMSG_EXT_T...",1,8,cluster.c,writePingExt,,false,2540,2619,writePingExt,,,162,"uint32_t writePingExt (clusterMsg*,int)"
48239,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterProcessPingExtensions(clusterMsg *hdr, clusterLink *link) {
    clusterNode *sender = link->node ? link->node : clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
    char *ext_hostname = NULL;
    char *ext_humannodename = NULL;
    char *ext_shardid = NULL;
    uint16_t extensions = ntohs(hdr->extensions);
    /* Loop through all the extensions and process them */
    clusterMsgPingExt *ext = getInitialPingExt(hdr, ntohs(hdr->count));
    while (extensions--) {
        uint16_t type = ntohs(ext->type);
        if (type == CLUSTERMSG_EXT_TYPE_HOSTNAME) {
            clusterMsgPingExtHostname *hostname_ext = (clusterMsgPingExtHostname *) &(ext->ext[0].hostname);
            ext_hostname = hostname_ext->hostname;
	} else if (type == CLUSTERMSG_EXT_TYPE_HUMAN_NODENAME) {
            clusterMsgPingExtHumanNodename *humannodename_ext = (clusterMsgPingExtHumanNodename *) &(ext->ext[0].human_nodename);
            ext_humannodename = humannodename_ext->human_nodename;
        } ...",1,83,cluster.c,clusterProcessPingExtensions,,false,2623,2669,clusterProcessPingExtensions,,,163,"void clusterProcessPingExtensions (clusterMsg*,clusterLink*)"
48529,METHOD,cluster.c:<global>,TYPE_DECL,"static clusterNode *getNodeFromLinkAndMsg(clusterLink *link, clusterMsg *hdr) {
    clusterNode *sender;
    if (link->node && !nodeInHandshake(link->node)) {
        /* If the link has an associated node, use that so that we don't have to look it
         * up every time, except when the node is still in handshake, the node still has
         * a random name thus not truly ""known"". */
        sender = link->node;
    } else {
        /* Otherwise, fetch sender based on the message */
        sender = clusterLookupNode(hdr->sender, CLUSTER_NAMELEN);
        /* We know the sender node but haven't associate it with the link. This must
         * be an inbound link because only for inbound links we didn't know which node
         * to associate when they were created. */
        if (sender && !link->node) {
            setClusterNodeToInboundClusterLink(sender, link);
        }
    }
    return sender;
}",1,23,cluster.c,getNodeFromLinkAndMsg,,false,2671,2689,getNodeFromLinkAndMsg,,,164,"clusterNode getNodeFromLinkAndMsg (clusterLink*,clusterMsg*)"
48584,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterProcessPacket(clusterLink *link) {
    clusterMsg *hdr = (clusterMsg*) link->rcvbuf;
    uint32_t totlen = ntohl(hdr->totlen);
    uint16_t type = ntohs(hdr->type);
    mstime_t now = mstime();

    if (type < CLUSTERMSG_TYPE_COUNT)
        server.cluster->stats_bus_messages_received[type]++;
    serverLog(LL_DEBUG,""--- Processing packet of type %s, %lu bytes"",
        clusterGetMessageTypeString(type), (unsigned long) totlen);

    /* Perform sanity checks */
    if (totlen < 16) return 1; /* At least signature, version, totlen, count. */
    if (totlen > link->rcvbuf_len) return 1;

    if (ntohs(hdr->ver) != CLUSTER_PROTO_VER) {
        /* Can't handle messages of different versions. */
        return 1;
    }

    if (type == server.cluster_drop_packet_filter) {
        serverLog(LL_WARNING, ""Dropping packet that matches debug drop filter"");
        return 1;
    }

    uint16_t flags = ntohs(hdr->flags);
    uint16_t extensions = ntohs(hdr->extensions);
    uint64_t ...",1,15,cluster.c,clusterProcessPacket,,false,2700,3218,clusterProcessPacket,,,165,int clusterProcessPacket (clusterLink*)
50800,METHOD,cluster.c:<global>,TYPE_DECL,"void handleLinkIOError(clusterLink *link) {
    freeClusterLink(link);
}",1,1,cluster.c,handleLinkIOError,,false,3226,3228,handleLinkIOError,,,166,void handleLinkIOError (clusterLink*)
50807,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterWriteHandler(connection *conn) {
    clusterLink *link = connGetPrivateData(conn);
    ssize_t nwritten;
    size_t totwritten = 0;

    while (totwritten < NET_MAX_WRITES_PER_EVENT && listLength(link->send_msg_queue) > 0) {
        listNode *head = listFirst(link->send_msg_queue);
        clusterMsgSendBlock *msgblock = (clusterMsgSendBlock*)head->value;
        clusterMsg *msg = &msgblock->msg;
        size_t msg_offset = link->head_msg_send_offset;
        size_t msg_len = ntohl(msg->totlen);

        nwritten = connWrite(conn, (char*)msg + msg_offset, msg_len - msg_offset);
        if (nwritten <= 0) {
            serverLog(LL_DEBUG,""I/O error writing to node link: %s"",
                (nwritten == -1) ? connGetLastError(conn) : ""short write"");
            handleLinkIOError(link);
            return;
        }
        if (msg_offset + nwritten < msg_len) {
            /* If full message wasn't written, record the offset
             * and continue sending from this p...",1,24,cluster.c,clusterWriteHandler,,false,3231,3270,clusterWriteHandler,,,167,void clusterWriteHandler (connection*)
51014,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterLinkConnectHandler(connection *conn) {
    clusterLink *link = connGetPrivateData(conn);
    clusterNode *node = link->node;

    /* Check if connection succeeded */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_VERBOSE, ""Connection with Node %.40s at %s:%d failed: %s"",
                node->name, node->ip, node->cport,
                connGetLastError(conn));
        freeClusterLink(link);
        return;
    }

    /* Register a read handler from now on */
    connSetReadHandler(conn, clusterReadHandler);

    /* Queue a PING in the new connection ASAP: this is crucial
     * to avoid false positives in failure detection.
     *
     * If the node is flagged as MEET, we send a MEET message instead
     * of a PING one, to force the receiver to add us in its node
     * table. */
    mstime_t old_ping_sent = node->ping_sent;
    clusterSendPing(link, node->flags & CLUSTER_NODE_MEET ?
            CLUSTERMSG_TYPE_MEET : CLUSTERMSG_TYPE_PING);
...",1,8,cluster.c,clusterLinkConnectHandler,,false,3275,3315,clusterLinkConnectHandler,,,168,void clusterLinkConnectHandler (connection*)
51136,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterReadHandler(connection *conn) {
    clusterMsg buf[1];
    ssize_t nread;
    clusterMsg *hdr;
    clusterLink *link = connGetPrivateData(conn);
    unsigned int readlen, rcvbuflen;

    while(1) { /* Read as long as there is data to read. */
        rcvbuflen = link->rcvbuf_len;
        if (rcvbuflen < 8) {
            /* First, obtain the first 8 bytes to get the full message
             * length. */
            readlen = 8 - rcvbuflen;
        } else {
            /* Finally read the full message. */
            hdr = (clusterMsg*) link->rcvbuf;
            if (rcvbuflen == 8) {
                /* Perform some sanity check on the message signature
                 * and length. */
                if (memcmp(hdr->sig,""RCmb"",4) != 0 ||
                    ntohl(hdr->totlen) < CLUSTERMSG_MIN_LEN)
                {
                    char ip[NET_IP_STR_LEN];
                    int port;
                    if (connAddrPeerName(conn, ip, sizeof(ip), &port) == -1) {
    ...",1,41,cluster.c,clusterReadHandler,,false,3320,3402,clusterReadHandler,,,169,void clusterReadHandler (connection*)
51496,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendMessage(clusterLink *link, clusterMsgSendBlock *msgblock) {
    if (!link) {
        return;
    }
    if (listLength(link->send_msg_queue) == 0 && msgblock->msg.totlen != 0)
        connSetWriteHandlerWithBarrier(link->conn, clusterWriteHandler, 1);

    listAddNodeTail(link->send_msg_queue, msgblock);
    msgblock->refcount++;

    /* Update memory tracking */
    link->send_msg_queue_mem += sizeof(listNode) + msgblock->totlen;
    server.stat_cluster_links_memory += sizeof(listNode);

    /* Populate sent messages stats. */
    uint16_t type = ntohs(msgblock->msg.type);
    if (type < CLUSTERMSG_TYPE_COUNT)
        server.cluster->stats_bus_messages_sent[type]++;
}",1,8,cluster.c,clusterSendMessage,,false,3409,3427,clusterSendMessage,,,170,"void clusterSendMessage (clusterLink*,clusterMsgSendBlock*)"
51584,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterBroadcastMessage(clusterMsgSendBlock *msgblock) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        clusterSendMessage(node->link,msgblock);
    }
    dictReleaseIterator(di);
}",1,27,cluster.c,clusterBroadcastMessage,,false,3435,3448,clusterBroadcastMessage,,,171,void clusterBroadcastMessage (clusterMsgSendBlock*)
51633,METHOD,cluster.c:<global>,TYPE_DECL,"static void clusterBuildMessageHdr(clusterMsg *hdr, int type, size_t msglen) {
    uint64_t offset;
    clusterNode *master;

    /* If this node is a master, we send its slots bitmap and configEpoch.
     * If this node is a slave we send the master's information instead (the
     * node is flagged as slave so the receiver knows that it is NOT really
     * in charge for this slots. */
    master = (nodeIsSlave(myself) && myself->slaveof) ?
              myself->slaveof : myself;

    hdr->ver = htons(CLUSTER_PROTO_VER);
    hdr->sig[0] = 'R';
    hdr->sig[1] = 'C';
    hdr->sig[2] = 'm';
    hdr->sig[3] = 'b';
    hdr->type = htons(type);
    memcpy(hdr->sender,myself->name,CLUSTER_NAMELEN);

    /* If cluster-announce-ip option is enabled, force the receivers of our
     * packets to use the specified address for this node. Otherwise if the
     * first byte is zero, they'll do auto discovery. */
    memset(hdr->myip,0,NET_IP_STR_LEN);
    if (server.cluster_announce_ip) {
      ...",1,14,cluster.c,clusterBuildMessageHdr,,false,3452,3514,clusterBuildMessageHdr,,,172,"void clusterBuildMessageHdr (clusterMsg*,int,size_t)"
51930,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSetGossipEntry(clusterMsg *hdr, int i, clusterNode *n) {
    clusterMsgDataGossip *gossip;
    gossip = &(hdr->data.ping.gossip[i]);
    memcpy(gossip->nodename,n->name,CLUSTER_NAMELEN);
    gossip->ping_sent = htonl(n->ping_sent/1000);
    gossip->pong_received = htonl(n->pong_received/1000);
    memcpy(gossip->ip,n->ip,sizeof(n->ip));
    if (server.tls_cluster) {
        gossip->port = htons(n->tls_port);
        gossip->pport = htons(n->tcp_port);
    } else {
        gossip->port = htons(n->tcp_port);
        gossip->pport = htons(n->tls_port);
    }
    gossip->cport = htons(n->cport);
    gossip->flags = htons(n->flags);
    gossip->notused1 = 0;
}",1,36,cluster.c,clusterSetGossipEntry,,false,3518,3535,clusterSetGossipEntry,,,173,"void clusterSetGossipEntry (clusterMsg*,int,clusterNode*)"
52051,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendPing(clusterLink *link, int type) {
    static unsigned long long cluster_pings_sent = 0;
    cluster_pings_sent++;
    int gossipcount = 0; /* Number of gossip sections added so far. */
    int wanted; /* Number of gossip sections we want to append if possible. */
    int estlen; /* Upper bound on estimated packet length */
    /* freshnodes is the max number of nodes we can hope to append at all:
     * nodes available minus two (ourself and the node we are sending the
     * message to). However practically there may be less valid nodes since
     * nodes in handshake state, disconnected, are not considered. */
    int freshnodes = dictSize(server.cluster->nodes)-2;

    /* How many gossip sections we want to add? 1/10 of the number of nodes
     * and anyway at least 3. Why 1/10?
     *
     * If we have N masters, with N/10 entries, and we consider that in
     * node_timeout we exchange with each other node at least 4 packets
     * (we ping in the worst case i...",1,21,cluster.c,clusterSendPing,,false,3539,3667,clusterSendPing,,,174,"void clusterSendPing (clusterLink*,int)"
52442,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterBroadcastPong(int target) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (!node->link) continue;
        if (node == myself || nodeInHandshake(node)) continue;
        if (target == CLUSTER_BROADCAST_LOCAL_SLAVES) {
            int local_slave =
                nodeIsSlave(node) && node->slaveof &&
                (node->slaveof == myself || node->slaveof == myself->slaveof);
            if (!local_slave) continue;
        }
        clusterSendPing(node->link,CLUSTERMSG_TYPE_PONG);
    }
    dictReleaseIterator(di);
}",1,30,cluster.c,clusterBroadcastPong,,false,3685,3704,clusterBroadcastPong,,,175,void clusterBroadcastPong (int)
52542,METHOD,cluster.c:<global>,TYPE_DECL,"clusterMsgSendBlock *clusterCreatePublishMsgBlock(robj *channel, robj *message, uint16_t type) {

    uint32_t channel_len, message_len;

    channel = getDecodedObject(channel);
    message = getDecodedObject(message);
    channel_len = sdslen(channel->ptr);
    message_len = sdslen(message->ptr);

    size_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    msglen += sizeof(clusterMsgDataPublish) - 8 + channel_len + message_len;
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(type, msglen);

    clusterMsg *hdr = &msgblock->msg;
    hdr->data.publish.msg.channel_len = htonl(channel_len);
    hdr->data.publish.msg.message_len = htonl(message_len);
    memcpy(hdr->data.publish.msg.bulk_data,channel->ptr,sdslen(channel->ptr));
    memcpy(hdr->data.publish.msg.bulk_data+sdslen(channel->ptr),
        message->ptr,sdslen(message->ptr));

    decrRefCount(channel);
    decrRefCount(message);
    
    return msgblock;
}",1,1,cluster.c,clusterCreatePublishMsgBlock,,false,3713,3737,clusterCreatePublishMsgBlock,,,176,"clusterMsgSendBlock clusterCreatePublishMsgBlock (robj*,robj*,uint16_t)"
52671,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendFail(char *nodename) {
    uint32_t msglen = sizeof(clusterMsg) - sizeof(union clusterMsgData)
        + sizeof(clusterMsgDataFail);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAIL, msglen);

    clusterMsg *hdr = &msgblock->msg;
    memcpy(hdr->data.fail.about.nodename,nodename,CLUSTER_NAMELEN);

    clusterBroadcastMessage(msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,62,cluster.c,clusterSendFail,,false,3744,3754,clusterSendFail,,,177,void clusterSendFail (char*)
52720,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendUpdate(clusterLink *link, clusterNode *node) {
    if (link == NULL) return;

    uint32_t msglen = sizeof(clusterMsg) - sizeof(union clusterMsgData)
        + sizeof(clusterMsgDataUpdate);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_UPDATE, msglen);

    clusterMsg *hdr = &msgblock->msg;
    memcpy(hdr->data.update.nodecfg.nodename,node->name,CLUSTER_NAMELEN);
    hdr->data.update.nodecfg.configEpoch = htonu64(node->configEpoch);
    memcpy(hdr->data.update.nodecfg.slots,node->slots,sizeof(node->slots));
    for (unsigned int i = 0; i < sizeof(node->slots); i++) {
        /* Don't advertise slots that the node stopped claiming */
        hdr->data.update.nodecfg.slots[i] = hdr->data.update.nodecfg.slots[i] & (~server.cluster->owner_not_claiming_slot[i]);
    }

    clusterSendMessage(link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,62,cluster.c,clusterSendUpdate,,false,3759,3777,clusterSendUpdate,,,178,"void clusterSendUpdate (clusterLink*,clusterNode*)"
52862,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendModule(clusterLink *link, uint64_t module_id, uint8_t type,
                       const char *payload, uint32_t len) {
    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    msglen += sizeof(clusterMsgModule) - 3 + len;
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_MODULE, msglen);

    clusterMsg *hdr = &msgblock->msg;
    hdr->data.module.msg.module_id = module_id; /* Already endian adjusted. */
    hdr->data.module.msg.type = type;
    hdr->data.module.msg.len = htonl(len);
    memcpy(hdr->data.module.msg.bulk_data,payload,len);

    if (link)
        clusterSendMessage(link,msgblock);
    else
        clusterBroadcastMessage(msgblock);

    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,62,cluster.c,clusterSendModule,,false,3782,3800,clusterSendModule,,,179,"void clusterSendModule (clusterLink*,uint64_t,uint8_t,char*,uint32_t)"
52960,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, const char *payload, uint32_t len) {
    clusterNode *node = NULL;

    if (target != NULL) {
        node = clusterLookupNode(target, strlen(target));
        if (node == NULL || node->link == NULL) return C_ERR;
    }

    clusterSendModule(target ? node->link : NULL,
                      module_id, type, payload, len);
    return C_OK;
}",1,55,cluster.c,clusterSendModuleMessageToTarget,,false,3808,3819,clusterSendModuleMessageToTarget,,,180,"int clusterSendModuleMessageToTarget (char*,uint64_t,uint8_t,char*,uint32_t)"
53015,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterPropagatePublish(robj *channel, robj *message, int sharded) {
    clusterMsgSendBlock *msgblock;

    if (!sharded) {
        msgblock = clusterCreatePublishMsgBlock(channel, message, CLUSTERMSG_TYPE_PUBLISH);
        clusterBroadcastMessage(msgblock);
        clusterMsgSendBlockDecrRefCount(msgblock);
        return;
    }

    listIter li;
    listNode *ln;
    list *nodes_for_slot = clusterGetNodesInMyShard(server.cluster->myself);
    serverAssert(nodes_for_slot != NULL);
    listRewind(nodes_for_slot, &li);
    msgblock = clusterCreatePublishMsgBlock(channel, message, CLUSTERMSG_TYPE_PUBLISHSHARD);
    while((ln = listNext(&li))) {
        clusterNode *node = listNodeValue(ln);
        if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_HANDSHAKE))
            continue;
        clusterSendMessage(node->link,msgblock);
    }
    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,66,cluster.c,clusterPropagatePublish,,false,3831,3854,clusterPropagatePublish,,,181,"void clusterPropagatePublish (robj*,robj*,int)"
53116,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterRequestFailoverAuth(void) {
    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST, msglen);

    clusterMsg *hdr = &msgblock->msg;
    /* If this is a manual failover, set the CLUSTERMSG_FLAG0_FORCEACK bit
     * in the header to communicate the nodes receiving the message that
     * they should authorized the failover even if the master is working. */
    if (server.cluster->mf_end) hdr->mflags[0] |= CLUSTERMSG_FLAG0_FORCEACK;
    clusterBroadcastMessage(msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,62,cluster.c,clusterRequestFailoverAuth,,false,3866,3877,clusterRequestFailoverAuth,,,182,void clusterRequestFailoverAuth (void)
53166,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendFailoverAuth(clusterNode *node) {
    if (!node->link) return;

    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK, msglen);

    clusterSendMessage(node->link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,62,cluster.c,clusterSendFailoverAuth,,false,3880,3888,clusterSendFailoverAuth,,,183,void clusterSendFailoverAuth (clusterNode*)
53201,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendMFStart(clusterNode *node) {
    if (!node->link) return;

    uint32_t msglen = sizeof(clusterMsg)-sizeof(union clusterMsgData);
    clusterMsgSendBlock *msgblock = createClusterMsgSendBlock(CLUSTERMSG_TYPE_MFSTART, msglen);

    clusterSendMessage(node->link,msgblock);
    clusterMsgSendBlockDecrRefCount(msgblock);
}",1,62,cluster.c,clusterSendMFStart,,false,3891,3899,clusterSendMFStart,,,184,void clusterSendMFStart (clusterNode*)
53236,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {
    clusterNode *master = node->slaveof;
    uint64_t requestCurrentEpoch = ntohu64(request->currentEpoch);
    uint64_t requestConfigEpoch = ntohu64(request->configEpoch);
    unsigned char *claimed_slots = request->myslots;
    int force_ack = request->mflags[0] & CLUSTERMSG_FLAG0_FORCEACK;
    int j;

    /* IF we are not a master serving at least 1 slot, we don't have the
     * right to vote, as the cluster size in Redis Cluster is the number
     * of masters serving at least one slot, and quorum is the cluster
     * size + 1 */
    if (nodeIsSlave(myself) || myself->numslots == 0) return;

    /* Request epoch must be >= our currentEpoch.
     * Note that it is impossible for it to actually be greater since
     * our currentEpoch was updated as a side effect of receiving this
     * request, if the request epoch was greater. */
    if (requestCurrentEpoch < server.cluster->currentEpoch) {
       ...",1,35,cluster.c,clusterSendFailoverAuthIfNeeded,,false,3902,4003,clusterSendFailoverAuthIfNeeded,,,185,"void clusterSendFailoverAuthIfNeeded (clusterNode*,clusterMsg*)"
53743,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterGetSlaveRank(void) {
    long long myoffset;
    int j, rank = 0;
    clusterNode *master;

    serverAssert(nodeIsSlave(myself));
    master = myself->slaveof;
    if (master == NULL) return 0; /* Never called by slaves without master. */

    myoffset = replicationGetSlaveOffset();
    for (j = 0; j < master->numslaves; j++)
        if (master->slaves[j] != myself &&
            !nodeCantFailover(master->slaves[j]) &&
            master->slaves[j]->repl_offset > myoffset) rank++;
    return rank;
}",1,4,cluster.c,clusterGetSlaveRank,,false,4017,4032,clusterGetSlaveRank,,,186,int clusterGetSlaveRank (void)
53841,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterLogCantFailover(int reason) {
    char *msg;
    static time_t lastlog_time = 0;
    mstime_t nolog_fail_time = server.cluster_node_timeout + 5000;

    /* Don't log if we have the same reason for some time. */
    if (reason == server.cluster->cant_failover_reason &&
        time(NULL)-lastlog_time < CLUSTER_CANT_FAILOVER_RELOG_PERIOD)
        return;

    server.cluster->cant_failover_reason = reason;

    /* We also don't emit any log if the master failed no long ago, the
     * goal of this function is to log slaves in a stalled condition for
     * a long time. */
    if (myself->slaveof &&
        nodeFailed(myself->slaveof) &&
        (mstime() - myself->slaveof->fail_time) < nolog_fail_time) return;

    switch(reason) {
    case CLUSTER_CANT_FAILOVER_DATA_AGE:
        msg = ""Disconnected from master for longer than allowed. ""
              ""Please check the 'cluster-replica-validity-factor' configuration ""
              ""option."";
        break;
    case CLUSTER...",1,34,cluster.c,clusterLogCantFailover,,false,4056,4103,clusterLogCantFailover,,,187,void clusterLogCantFailover (int)
54030,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterFailoverReplaceYourMaster(void) {
    int j;
    clusterNode *oldmaster = myself->slaveof;

    if (nodeIsMaster(myself) || oldmaster == NULL) return;

    /* 1) Turn this node into a master. */
    clusterSetNodeAsMaster(myself);
    replicationUnsetMaster();

    /* 2) Claim all the slots assigned to our master. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (clusterNodeGetSlotBit(oldmaster,j)) {
            clusterDelSlot(j);
            clusterAddSlot(myself,j);
        }
    }

    /* 3) Update state and save config. */
    clusterUpdateState();
    clusterSaveConfigOrDie(1);

    /* 4) Pong all the other nodes so that they can update the state
     *    accordingly and detect that we switched to master role. */
    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);

    /* 5) If there was a manual failover in progress, clear the state. */
    resetManualFailover();
}",1,8,cluster.c,clusterFailoverReplaceYourMaster,,false,4111,4139,clusterFailoverReplaceYourMaster,,,188,void clusterFailoverReplaceYourMaster (void)
54091,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterHandleSlaveFailover(void) {
    mstime_t data_age;
    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
    int needed_quorum = (server.cluster->size / 2) + 1;
    int manual_failover = server.cluster->mf_end != 0 &&
                          server.cluster->mf_can_start;
    mstime_t auth_timeout, auth_retry_time;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_HANDLE_FAILOVER;

    /* Compute the failover timeout (the max time we have to send votes
     * and wait for replies), and the failover retry time (the time to wait
     * before trying to get voted again).
     *
     * Timeout is MAX(NODE_TIMEOUT*2,2000) milliseconds.
     * Retry is two times the Timeout.
     */
    auth_timeout = server.cluster_node_timeout*2;
    if (auth_timeout < 2000) auth_timeout = 2000;
    auth_retry_time = auth_timeout*2;

    /* Pre conditions to run the function, that must be met both in case
     * of an automatic or manual failover:
     * 1) We are a s...",1,42,cluster.c,clusterHandleSlaveFailover,,false,4149,4318,clusterHandleSlaveFailover,,,189,void clusterHandleSlaveFailover (void)
54678,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterHandleSlaveMigration(int max_slaves) {
    int j, okslaves = 0;
    clusterNode *mymaster = myself->slaveof, *target = NULL, *candidate = NULL;
    dictIterator *di;
    dictEntry *de;

    /* Step 1: Don't migrate if the cluster state is not ok. */
    if (server.cluster->state != CLUSTER_OK) return;

    /* Step 2: Don't migrate if my master will not be left with at least
     *         'migration-barrier' slaves after my migration. */
    if (mymaster == NULL) return;
    for (j = 0; j < mymaster->numslaves; j++)
        if (!nodeFailed(mymaster->slaves[j]) &&
            !nodeTimedOut(mymaster->slaves[j])) okslaves++;
    if (okslaves <= server.cluster_migration_barrier) return;

    /* Step 3: Identify a candidate for migration, and check if among the
     * masters with the greatest number of ok slaves, I'm the one with the
     * smallest node ID (the ""candidate slave"").
     *
     * Note: this means that eventually a replica migration will occur
     * since sla...",1,33,cluster.c,clusterHandleSlaveMigration,,false,4347,4430,clusterHandleSlaveMigration,,,190,void clusterHandleSlaveMigration (int)
55000,METHOD,cluster.c:<global>,TYPE_DECL,"void resetManualFailover(void) {
    if (server.cluster->mf_slave) {
        /* We were a master failing over, so we paused clients and related actions.
         * Regardless of the outcome we unpause now to allow traffic again. */
        unpauseActions(PAUSE_DURING_FAILOVER);
    }
    server.cluster->mf_end = 0; /* No manual failover in progress. */
    server.cluster->mf_can_start = 0;
    server.cluster->mf_slave = NULL;
    server.cluster->mf_master_offset = -1;
}",1,1,cluster.c,resetManualFailover,,false,4466,4476,resetManualFailover,,,191,void resetManualFailover (void)
55043,METHOD,cluster.c:<global>,TYPE_DECL,"void manualFailoverCheckTimeout(void) {
    if (server.cluster->mf_end && server.cluster->mf_end < mstime()) {
        serverLog(LL_WARNING,""Manual failover timed out."");
        resetManualFailover();
    }
}",1,8,cluster.c,manualFailoverCheckTimeout,,false,4479,4484,manualFailoverCheckTimeout,,,192,void manualFailoverCheckTimeout (void)
55082,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterHandleManualFailover(void) {
    /* Return ASAP if no manual failover is in progress. */
    if (server.cluster->mf_end == 0) return;

    /* If mf_can_start is non-zero, the failover was already triggered so the
     * next steps are performed by clusterHandleSlaveFailover(). */
    if (server.cluster->mf_can_start) return;

    if (server.cluster->mf_master_offset == -1) return; /* Wait for offset... */

    if (server.cluster->mf_master_offset == replicationGetSlaveOffset()) {
        /* Our replication offset matches the master replication offset
         * announced after clients were paused. We can start the failover. */
        server.cluster->mf_can_start = 1;
        serverLog(LL_NOTICE,
            ""All master replication stream processed, ""
            ""manual failover can start."");
        clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_FAILOVER);
        return;
    }
    clusterDoBeforeSleep(CLUSTER_TODO_HANDLE_MANUALFAILOVER);
}",1,8,cluster.c,clusterHandleManualFailover,,false,4488,4509,clusterHandleManualFailover,,,193,void clusterHandleManualFailover (void)
55163,METHOD,cluster.c:<global>,TYPE_DECL,"static int clusterNodeCronHandleReconnect(clusterNode *node, mstime_t handshake_timeout, mstime_t now) {
    /* Not interested in reconnecting the link with myself or nodes
     * for which we have no address. */
    if (node->flags & (CLUSTER_NODE_MYSELF|CLUSTER_NODE_NOADDR)) return 1;

    if (node->flags & CLUSTER_NODE_PFAIL)
        server.cluster->stats_pfail_nodes++;

    /* A Node in HANDSHAKE state has a limited lifespan equal to the
     * configured node timeout. */
    if (nodeInHandshake(node) && now - node->ctime > handshake_timeout) {
        clusterDelNode(node);
        return 1;
    }

    if (node->link == NULL) {
        clusterLink *link = createClusterLink(node);
        link->conn = connCreate(connTypeOfCluster());
        connSetPrivateData(link->conn, link);
        if (connConnect(link->conn, node->ip, node->cport, server.bind_source_addr,
                    clusterLinkConnectHandler) == C_ERR) {
            /* We got a synchronous error from connect before...",1,23,cluster.c,clusterNodeCronHandleReconnect,,false,4518,4554,clusterNodeCronHandleReconnect,,,194,"int clusterNodeCronHandleReconnect (clusterNode*,mstime_t,mstime_t)"
55311,METHOD,cluster.c:<global>,TYPE_DECL,"static void freeClusterLinkOnBufferLimitReached(clusterLink *link) {
    if (link == NULL || server.cluster_link_msg_queue_limit_bytes == 0) {
        return;
    }

    unsigned long long mem_link = link->send_msg_queue_mem;
    if (mem_link > server.cluster_link_msg_queue_limit_bytes) {
        serverLog(LL_WARNING, ""Freeing cluster link(%s node %.40s, used memory: %llu) due to ""
                ""exceeding send buffer memory limit."", link->inbound ? ""from"" : ""to"",
                link->node ? link->node->name : """", mem_link);
        freeClusterLink(link);
        server.cluster->stat_cluster_links_buffer_limit_exceeded++;
    }
}",1,8,cluster.c,freeClusterLinkOnBufferLimitReached,,false,4556,4569,freeClusterLinkOnBufferLimitReached,,,195,void freeClusterLinkOnBufferLimitReached (clusterLink*)
55384,METHOD,cluster.c:<global>,TYPE_DECL,"static void clusterNodeCronFreeLinkOnBufferLimitReached(clusterNode *node) {
    freeClusterLinkOnBufferLimitReached(node->link);
    freeClusterLinkOnBufferLimitReached(node->inbound_link);
}",1,1,cluster.c,clusterNodeCronFreeLinkOnBufferLimitReached,,false,4572,4575,clusterNodeCronFreeLinkOnBufferLimitReached,,,196,void clusterNodeCronFreeLinkOnBufferLimitReached (clusterNode*)
55397,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterCron(void) {
    dictIterator *di;
    dictEntry *de;
    int update_state = 0;
    int orphaned_masters; /* How many masters there are without ok slaves. */
    int max_slaves; /* Max number of ok slaves for a single master. */
    int this_slaves; /* Number of ok slaves for our master (if we are slave). */
    mstime_t min_pong = 0, now = mstime();
    clusterNode *min_pong_node = NULL;
    static unsigned long long iteration = 0;
    mstime_t handshake_timeout;

    iteration++; /* Number of times this function was called so far. */

    clusterUpdateMyselfHostname();

    /* The handshake timeout is the time after which a handshake node that was
     * not turned into a normal node is removed from the nodes. Usually it is
     * just the NODE_TIMEOUT value, but when NODE_TIMEOUT is too small we use
     * the value of 1 second. */
    handshake_timeout = server.cluster_node_timeout;
    if (handshake_timeout < 1000) handshake_timeout = 1000;

    /* Clear so clusterN...",1,31,cluster.c,clusterCron,,false,4578,4779,clusterCron,,,197,void clusterCron (void)
56022,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterBeforeSleep(void) {
    int flags = server.cluster->todo_before_sleep;

    /* Reset our flags (not strictly needed since every single function
     * called for flags set should be able to clear its flag). */
    server.cluster->todo_before_sleep = 0;

    if (flags & CLUSTER_TODO_HANDLE_MANUALFAILOVER) {
        /* Handle manual failover as soon as possible so that won't have a 100ms
         * as it was handled only in clusterCron */
        if(nodeIsSlave(myself)) {
            clusterHandleManualFailover();
            if (!(server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_FAILOVER))
                clusterHandleSlaveFailover();
        }
    } else if (flags & CLUSTER_TODO_HANDLE_FAILOVER) {
        /* Handle failover, this is needed when it is likely that there is already
         * the quorum from masters in order to react fast. */
        clusterHandleSlaveFailover();
    }

    /* Update the cluster state. */
    if (flags & CLUSTER_TODO_UPDATE_STATE)
     ...",1,16,cluster.c,clusterBeforeSleep,,false,4786,4816,clusterBeforeSleep,,,198,void clusterBeforeSleep (void)
56118,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterDoBeforeSleep(int flags) {
    server.cluster->todo_before_sleep |= flags;
}",1,1,cluster.c,clusterDoBeforeSleep,,false,4818,4820,clusterDoBeforeSleep,,,199,void clusterDoBeforeSleep (int)
56130,METHOD,cluster.c:<global>,TYPE_DECL,"int bitmapTestBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    return (bitmap[byte] & (1<<bit)) != 0;
}",1,1,cluster.c,bitmapTestBit,,false,4828,4832,bitmapTestBit,,,200,"int bitmapTestBit (unsigned char*,int)"
56158,METHOD,cluster.c:<global>,TYPE_DECL,"void bitmapSetBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    bitmap[byte] |= 1<<bit;
}",1,1,cluster.c,bitmapSetBit,,false,4835,4839,bitmapSetBit,,,201,"void bitmapSetBit (unsigned char*,int)"
56183,METHOD,cluster.c:<global>,TYPE_DECL,"void bitmapClearBit(unsigned char *bitmap, int pos) {
    off_t byte = pos/8;
    int bit = pos&7;
    bitmap[byte] &= ~(1<<bit);
}",1,1,cluster.c,bitmapClearBit,,false,4842,4846,bitmapClearBit,,,202,"void bitmapClearBit (unsigned char*,int)"
56209,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterMastersHaveSlaves(void) {
    dictIterator *di = dictGetSafeIterator(server.cluster->nodes);
    dictEntry *de;
    int slaves = 0;
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (nodeIsSlave(node)) continue;
        slaves += node->numslaves;
    }
    dictReleaseIterator(di);
    return slaves != 0;
}",1,12,cluster.c,clusterMastersHaveSlaves,,false,4851,4863,clusterMastersHaveSlaves,,,203,int clusterMastersHaveSlaves (void)
56263,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeSetSlotBit(clusterNode *n, int slot) {
    int old = bitmapTestBit(n->slots,slot);
    if (!old) {
        bitmapSetBit(n->slots,slot);
        n->numslots++;
        /* When a master gets its first slot, even if it has no slaves,
         * it gets flagged with MIGRATE_TO, that is, the master is a valid
         * target for replicas migration, if and only if at least one of
         * the other masters has slaves right now.
         *
         * Normally masters are valid targets of replica migration if:
         * 1. The used to have slaves (but no longer have).
         * 2. They are slaves failing over a master that used to have slaves.
         *
         * However new masters with slots assigned are considered valid
         * migration targets if the rest of the cluster is not a slave-less.
         *
         * See https://github.com/redis/redis/issues/3043 for more info. */
        if (n->numslots == 1 && clusterMastersHaveSlaves())
            n->flags |= C...",1,24,cluster.c,clusterNodeSetSlotBit,,false,4866,4888,clusterNodeSetSlotBit,,,204,"int clusterNodeSetSlotBit (clusterNode*,int)"
56308,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeClearSlotBit(clusterNode *n, int slot) {
    int old = bitmapTestBit(n->slots,slot);
    if (old) {
        bitmapClearBit(n->slots,slot);
        n->numslots--;
    }
    return old;
}",1,1,cluster.c,clusterNodeClearSlotBit,,false,4891,4898,clusterNodeClearSlotBit,,,205,"int clusterNodeClearSlotBit (clusterNode*,int)"
56336,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterNodeGetSlotBit(clusterNode *n, int slot) {
    return bitmapTestBit(n->slots,slot);
}",1,1,cluster.c,clusterNodeGetSlotBit,,false,4901,4903,clusterNodeGetSlotBit,,,206,"int clusterNodeGetSlotBit (clusterNode*,int)"
56348,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterAddSlot(clusterNode *n, int slot) {
    if (server.cluster->slots[slot]) return C_ERR;
    clusterNodeSetSlotBit(n,slot);
    server.cluster->slots[slot] = n;
    return C_OK;
}",1,44,cluster.c,clusterAddSlot,,false,4909,4914,clusterAddSlot,,,207,"int clusterAddSlot (clusterNode*,int)"
56384,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterDelSlot(int slot) {
    clusterNode *n = server.cluster->slots[slot];

    if (!n) return C_ERR;

    /* Cleanup the channels in master/replica as part of slot deletion. */
    list *nodes_for_slot = clusterGetNodesInMyShard(n);
    serverAssert(nodes_for_slot != NULL);
    listNode *ln = listSearchKey(nodes_for_slot, myself);
    if (ln != NULL) {
        removeChannelsInSlot(slot);
    }
    serverAssert(clusterNodeClearSlotBit(n,slot) == 1);
    server.cluster->slots[slot] = NULL;
    return C_OK;
}",1,19,cluster.c,clusterDelSlot,,false,4919,4934,clusterDelSlot,,,208,int clusterDelSlot (int)
56473,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterDelNodeSlots(clusterNode *node) {
    int deleted = 0, j;

    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (clusterNodeGetSlotBit(node,j)) {
            clusterDelSlot(j);
            deleted++;
        }
    }
    return deleted;
}",1,20,cluster.c,clusterDelNodeSlots,,false,4938,4948,clusterDelNodeSlots,,,209,int clusterDelNodeSlots (clusterNode*)
56507,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterCloseAllSlots(void) {
    memset(server.cluster->migrating_slots_to,0,
        sizeof(server.cluster->migrating_slots_to));
    memset(server.cluster->importing_slots_from,0,
        sizeof(server.cluster->importing_slots_from));
}",1,1,cluster.c,clusterCloseAllSlots,,false,4952,4957,clusterCloseAllSlots,,,210,void clusterCloseAllSlots (void)
56538,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateState(void) {
    int j, new_state;
    int reachable_masters = 0;
    static mstime_t among_minority_time;
    static mstime_t first_call_time = 0;

    server.cluster->todo_before_sleep &= ~CLUSTER_TODO_UPDATE_STATE;

    /* If this is a master node, wait some time before turning the state
     * into OK, since it is not a good idea to rejoin the cluster as a writable
     * master, after a reboot, without giving the cluster a chance to
     * reconfigure this node. Note that the delay is calculated starting from
     * the first call to this function and not since the server start, in order
     * to not count the DB loading time. */
    if (first_call_time == 0) first_call_time = mstime();
    if (nodeIsMaster(myself) &&
        server.cluster->state == CLUSTER_FAIL &&
        mstime() - first_call_time < CLUSTER_WRITABLE_DELAY) return;

    /* Start assuming the state is OK. We'll turn it into FAIL if there
     * are the right conditions. */
    new_state = C...",1,42,cluster.c,clusterUpdateState,,false,4971,5066,clusterUpdateState,,,211,void clusterUpdateState (void)
56856,METHOD,cluster.c:<global>,TYPE_DECL,"int verifyClusterConfigWithData(void) {
    int j;
    int update_config = 0;

    /* Return ASAP if a module disabled cluster redirections. In that case
     * every master can store keys about every possible hash slot. */
    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
        return C_OK;

    /* If this node is a slave, don't perform the check at all as we
     * completely depend on the replication stream. */
    if (nodeIsSlave(myself)) return C_OK;

    /* Make sure we only have keys in DB0. */
    for (j = 1; j < server.dbnum; j++) {
        if (dictSize(server.db[j].dict)) return C_ERR;
    }

    /* Check that all the slots we see populated memory have a corresponding
     * entry in the cluster table. Otherwise fix the table. */
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (!countKeysInSlot(j)) continue; /* No keys in this slot. */
        /* Check if we are assigned to this slot or if we are importing it.
         * In both cases check t...",1,38,cluster.c,verifyClusterConfigWithData,,false,5090,5137,verifyClusterConfigWithData,,,212,int verifyClusterConfigWithData (void)
57068,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterSetMaster(clusterNode *n) {
    serverAssert(n != myself);
    serverAssert(myself->numslots == 0);

    if (nodeIsMaster(myself)) {
        myself->flags &= ~(CLUSTER_NODE_MASTER|CLUSTER_NODE_MIGRATE_TO);
        myself->flags |= CLUSTER_NODE_SLAVE;
        clusterCloseAllSlots();
    } else {
        if (myself->slaveof)
            clusterNodeRemoveSlave(myself->slaveof,myself);
    }
    myself->slaveof = n;
    updateShardId(myself, n->shard_id);
    clusterNodeAddSlave(n,myself);
    replicationSetMaster(n->ip, getNodeDefaultReplicationPort(n));
    resetManualFailover();
}",1,4,cluster.c,clusterSetMaster,,false,5145,5162,clusterSetMaster,,,213,void clusterSetMaster (clusterNode*)
57217,METHOD,cluster.c:<global>,TYPE_DECL,"sds representClusterNodeFlags(sds ci, uint16_t flags) {
    size_t orig_len = sdslen(ci);
    int i, size = sizeof(redisNodeFlagsTable)/sizeof(struct redisNodeFlags);
    for (i = 0; i < size; i++) {
        struct redisNodeFlags *nodeflag = redisNodeFlagsTable + i;
        if (flags & nodeflag->flag) ci = sdscat(ci, nodeflag->name);
    }
    /* If no flag was added, add the ""noflags"" special flag. */
    if (sdslen(ci) == orig_len) ci = sdscat(ci,""noflags,"");
    sdsIncrLen(ci,-1); /* Remove trailing comma. */
    return ci;
}",1,1,cluster.c,representClusterNodeFlags,,false,5186,5197,representClusterNodeFlags,,,218,"sds representClusterNodeFlags (sds,uint16_t)"
57285,METHOD,cluster.c:<global>,TYPE_DECL,"sds representSlotInfo(sds ci, uint16_t *slot_info_pairs, int slot_info_pairs_count) {
    for (int i = 0; i< slot_info_pairs_count; i+=2) {
        unsigned long start = slot_info_pairs[i];
        unsigned long end = slot_info_pairs[i+1];
        if (start == end) {
            ci = sdscatfmt(ci, "" %i"", start);
        } else {
            ci = sdscatfmt(ci, "" %i-%i"", start, end);
        }
    }
    return ci;
}",1,1,cluster.c,representSlotInfo,,false,5202,5213,representSlotInfo,,,219,"sds representSlotInfo (sds,uint16_t*,int)"
57341,METHOD,cluster.c:<global>,TYPE_DECL,"sds clusterGenNodeDescription(client *c, clusterNode *node, int tls_primary) {
    int j, start;
    sds ci;
    int port = getNodeClientPort(node, tls_primary);

    /* Node coordinates */
    ci = sdscatlen(sdsempty(),node->name,CLUSTER_NAMELEN);
    ci = sdscatfmt(ci,"" %s:%i@%i"",
        node->ip,
        port,
        node->cport);
    if (sdslen(node->hostname) != 0) {
        ci = sdscatfmt(ci,"",%s"", node->hostname);
    }
    if (sdslen(node->hostname) == 0) {
        ci = sdscatfmt(ci,"","", 1);
    }
    /* Don't expose aux fields to any clients yet but do allow them
     * to be persisted to nodes.conf */
    if (c == NULL) {
        for (int i = af_count-1; i >=0; i--) {
            if ((tls_primary && i == af_tls_port) || (!tls_primary && i == af_tcp_port)) {
                continue;
            }
            if (auxFieldHandlers[i].isPresent(node)) {
                ci = sdscatprintf(ci, "",%s="", auxFieldHandlers[i].field);
                ci = auxFieldHandlers[i].getter(...",1,41,cluster.c,clusterGenNodeDescription,,false,5219,5313,clusterGenNodeDescription,,,220,"sds clusterGenNodeDescription (client*,clusterNode*,int)"
57765,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterGenNodesSlotsInfo(int filter) {
    clusterNode *n = NULL;
    int start = -1;

    for (int i = 0; i <= CLUSTER_SLOTS; i++) {
        /* Find start node and slot id. */
        if (n == NULL) {
            if (i == CLUSTER_SLOTS) break;
            n = server.cluster->slots[i];
            start = i;
            continue;
        }

        /* Generate slots info when occur different node with start
         * or end of slot. */
        if (i == CLUSTER_SLOTS || n != server.cluster->slots[i]) {
            if (!(n->flags & filter)) {
                if (!n->slot_info_pairs) {
                    n->slot_info_pairs = zmalloc(2 * n->numslots * sizeof(uint16_t));
                }
                serverAssert((n->slot_info_pairs_count + 1) < (2 * n->numslots));
                n->slot_info_pairs[n->slot_info_pairs_count++] = start;
                n->slot_info_pairs[n->slot_info_pairs_count++] = i-1;
            }
            if (i == CLUSTER_SLOTS) break;
            n = ...",1,25,cluster.c,clusterGenNodesSlotsInfo,,false,5319,5348,clusterGenNodesSlotsInfo,,,221,void clusterGenNodesSlotsInfo (int)
57929,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterFreeNodesSlotsInfo(clusterNode *n) {
    zfree(n->slot_info_pairs);
    n->slot_info_pairs = NULL;
    n->slot_info_pairs_count = 0;
}",1,1,cluster.c,clusterFreeNodesSlotsInfo,,false,5350,5354,clusterFreeNodesSlotsInfo,,,222,void clusterFreeNodesSlotsInfo (clusterNode*)
57948,METHOD,cluster.c:<global>,TYPE_DECL,"sds clusterGenNodesDescription(client *c, int filter, int tls_primary) {
    sds ci = sdsempty(), ni;
    dictIterator *di;
    dictEntry *de;

    /* Generate all nodes slots info firstly. */
    clusterGenNodesSlotsInfo(filter);

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);

        if (node->flags & filter) continue;
        ni = clusterGenNodeDescription(c, node, tls_primary);
        ci = sdscatsds(ci,ni);
        sdsfree(ni);
        ci = sdscatlen(ci,""\n"",1);

        /* Release slots info. */
        clusterFreeNodesSlotsInfo(node);
    }
    dictReleaseIterator(di);
    return ci;
}",1,1,cluster.c,clusterGenNodesDescription,,false,5371,5394,clusterGenNodesDescription,,,223,"sds clusterGenNodesDescription (client*,int,int)"
58018,METHOD,cluster.c:<global>,TYPE_DECL,"void addReplyClusterLinkDescription(client *c, clusterLink *link) {
    addReplyMapLen(c, 6);

    addReplyBulkCString(c, ""direction"");
    addReplyBulkCString(c, link->inbound ? ""from"" : ""to"");

    /* addReplyClusterLinkDescription is only called for links that have been
     * associated with nodes. The association is always bi-directional, so
     * in addReplyClusterLinkDescription, link->node should never be NULL. */
    serverAssert(link->node);
    sds node_name = sdsnewlen(link->node->name, CLUSTER_NAMELEN);
    addReplyBulkCString(c, ""node"");
    addReplyBulkCString(c, node_name);
    sdsfree(node_name);

    addReplyBulkCString(c, ""create-time"");
    addReplyLongLong(c, link->ctime);

    char events[3], *p;
    p = events;
    if (link->conn) {
        if (connHasReadHandler(link->conn)) *p++ = 'r';
        if (connHasWriteHandler(link->conn)) *p++ = 'w';
    }
    *p = '\0';
    addReplyBulkCString(c, ""events"");
    addReplyBulkCString(c, events);

    addReplyBulkCStri...",1,4,cluster.c,addReplyClusterLinkDescription,,false,5398,5431,addReplyClusterLinkDescription,,,224,"void addReplyClusterLinkDescription (client*,clusterLink*)"
58143,METHOD,cluster.c:<global>,TYPE_DECL,"void addReplyClusterLinksDescription(client *c) {
    dictIterator *di;
    dictEntry *de;
    void *arraylen_ptr = NULL;
    int num_links = 0;

    arraylen_ptr = addReplyDeferredLen(c);

    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->link) {
            num_links++;
            addReplyClusterLinkDescription(c, node->link);
        }
        if (node->inbound_link) {
            num_links++;
            addReplyClusterLinkDescription(c, node->inbound_link);
        }
    }
    dictReleaseIterator(di);

    setDeferredArrayLen(c, arraylen_ptr, num_links);
}",1,1,cluster.c,addReplyClusterLinksDescription,,false,5435,5458,addReplyClusterLinksDescription,,,225,void addReplyClusterLinksDescription (client*)
58213,METHOD,cluster.c:<global>,TYPE_DECL,"const char *getPreferredEndpoint(clusterNode *n) {
    switch(server.cluster_preferred_endpoint_type) {
    case CLUSTER_ENDPOINT_TYPE_IP: return n->ip;
    case CLUSTER_ENDPOINT_TYPE_HOSTNAME: return (sdslen(n->hostname) != 0) ? n->hostname : ""?"";
    case CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT: return """";
    }
    return ""unknown"";
}",1,1,cluster.c,getPreferredEndpoint,,false,5464,5471,getPreferredEndpoint,,,226,const char* getPreferredEndpoint (clusterNode*)
58249,METHOD,cluster.c:<global>,TYPE_DECL,"const char *clusterGetMessageTypeString(int type) {
    switch(type) {
    case CLUSTERMSG_TYPE_PING: return ""ping"";
    case CLUSTERMSG_TYPE_PONG: return ""pong"";
    case CLUSTERMSG_TYPE_MEET: return ""meet"";
    case CLUSTERMSG_TYPE_FAIL: return ""fail"";
    case CLUSTERMSG_TYPE_PUBLISH: return ""publish"";
    case CLUSTERMSG_TYPE_PUBLISHSHARD: return ""publishshard"";
    case CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST: return ""auth-req"";
    case CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK: return ""auth-ack"";
    case CLUSTERMSG_TYPE_UPDATE: return ""update"";
    case CLUSTERMSG_TYPE_MFSTART: return ""mfstart"";
    case CLUSTERMSG_TYPE_MODULE: return ""module"";
    }
    return ""unknown"";
}",1,9,cluster.c,clusterGetMessageTypeString,,false,5473,5488,clusterGetMessageTypeString,,,227,const char* clusterGetMessageTypeString (int)
58325,METHOD,cluster.c:<global>,TYPE_DECL,"int getSlotOrReply(client *c, robj *o) {
    long long slot;

    if (getLongLongFromObject(o,&slot) != C_OK ||
        slot < 0 || slot >= CLUSTER_SLOTS)
    {
        addReplyError(c,""Invalid or out of range slot"");
        return -1;
    }
    return (int) slot;
}",1,42,cluster.c,getSlotOrReply,,false,5490,5500,getSlotOrReply,,,228,"int getSlotOrReply (client*,robj*)"
58362,METHOD,cluster.c:<global>,TYPE_DECL,"static int isReplicaAvailable(clusterNode *node) {
    if (nodeFailed(node)) {
        return 0;
    }
    long long repl_offset = node->repl_offset;
    if (node->flags & CLUSTER_NODE_MYSELF) {
        /* Nodes do not update their own information
         * in the cluster node list. */
        repl_offset = replicationGetSlaveOffset();
    }
    return (repl_offset != 0);
}",1,8,cluster.c,isReplicaAvailable,,false,5507,5518,isReplicaAvailable,,,229,int isReplicaAvailable (clusterNode*)
58401,METHOD,cluster.c:<global>,TYPE_DECL,"int checkSlotAssignmentsOrReply(client *c, unsigned char *slots, int del, int start_slot, int end_slot) {
    int slot;
    for (slot = start_slot; slot <= end_slot; slot++) {
        if (del && server.cluster->slots[slot] == NULL) {
            addReplyErrorFormat(c,""Slot %d is already unassigned"", slot);
            return C_ERR;
        } else if (!del && server.cluster->slots[slot]) {
            addReplyErrorFormat(c,""Slot %d is already busy"", slot);
            return C_ERR;
        }
        if (slots[slot]++ == 1) {
            addReplyErrorFormat(c,""Slot %d specified multiple times"",(int)slot);
            return C_ERR;
        }
    }
    return C_OK;
}",1,19,cluster.c,checkSlotAssignmentsOrReply,,false,5520,5536,checkSlotAssignmentsOrReply,,,230,"int checkSlotAssignmentsOrReply (client*,unsigned char*,int,int,int)"
58490,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterUpdateSlots(client *c, unsigned char *slots, int del) {
    int j;
    for (j = 0; j < CLUSTER_SLOTS; j++) {
        if (slots[j]) {
            int retval;
                
            /* If this slot was set as importing we can clear this
             * state as now we are the real owner of the slot. */
            if (server.cluster->importing_slots_from[j])
                server.cluster->importing_slots_from[j] = NULL;

            retval = del ? clusterDelSlot(j) :
                           clusterAddSlot(myself,j);
            serverAssertWithInfo(c,NULL,retval == C_OK);
        }
    }
}",1,20,cluster.c,clusterUpdateSlots,,false,5538,5554,clusterUpdateSlots,,,231,"void clusterUpdateSlots (client*,unsigned char*,int)"
58564,METHOD,cluster.c:<global>,TYPE_DECL,"void addNodeToNodeReply(client *c, clusterNode *node) {
    addReplyArrayLen(c, 4);
    if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_IP) {
        addReplyBulkCString(c, node->ip);
    } else if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_HOSTNAME) {
        if (sdslen(node->hostname) != 0) {
            addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));
        } else {
            addReplyBulkCString(c, ""?"");
        }
    } else if (server.cluster_preferred_endpoint_type == CLUSTER_ENDPOINT_TYPE_UNKNOWN_ENDPOINT) {
        addReplyNull(c);
    } else {
        serverPanic(""Unrecognized preferred endpoint type"");
    }

    /* Report TLS ports to TLS client, and report non-TLS port to non-TLS client. */
    addReplyLongLong(c, getNodeClientPort(node, connIsTLS(c->conn)));
    addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);

    /* Add the additional endpoint information, this is all the known networking information
    ...",1,8,cluster.c,addNodeToNodeReply,,false,5556,5604,addNodeToNodeReply,,,232,"void addNodeToNodeReply (client*,clusterNode*)"
58746,METHOD,cluster.c:<global>,TYPE_DECL,"void addNodeReplyForClusterSlot(client *c, clusterNode *node, int start_slot, int end_slot) {
    int i, nested_elements = 3; /* slots (2) + master addr (1) */
    for (i = 0; i < node->numslaves; i++) {
        if (!isReplicaAvailable(node->slaves[i])) continue;
        nested_elements++;
    }
    addReplyArrayLen(c, nested_elements);
    addReplyLongLong(c, start_slot);
    addReplyLongLong(c, end_slot);
    addNodeToNodeReply(c, node);

    /* Remaining nodes in reply are replicas for slot range */
    for (i = 0; i < node->numslaves; i++) {
        /* This loop is copy/pasted from clusterGenNodeDescription()
         * with modifications for per-slot node aggregation. */
        if (!isReplicaAvailable(node->slaves[i])) continue;
        addNodeToNodeReply(c, node->slaves[i]);
        nested_elements--;
    }
    serverAssert(nested_elements == 3); /* Original 3 elements */
}",1,4,cluster.c,addNodeReplyForClusterSlot,,false,5606,5626,addNodeReplyForClusterSlot,,,233,"void addNodeReplyForClusterSlot (client*,clusterNode*,int,int)"
58844,METHOD,cluster.c:<global>,TYPE_DECL,"void addNodeDetailsToShardReply(client *c, clusterNode *node) {
    int reply_count = 0;
    void *node_replylen = addReplyDeferredLen(c);
    addReplyBulkCString(c, ""id"");
    addReplyBulkCBuffer(c, node->name, CLUSTER_NAMELEN);
    reply_count++;

    if (node->tcp_port) {
        addReplyBulkCString(c, ""port"");
        addReplyLongLong(c, node->tcp_port);
        reply_count++;
    }

    if (node->tls_port) {
        addReplyBulkCString(c, ""tls-port"");
        addReplyLongLong(c, node->tls_port);
        reply_count++;
    }

    addReplyBulkCString(c, ""ip"");
    addReplyBulkCString(c, node->ip);
    reply_count++;

    addReplyBulkCString(c, ""endpoint"");
    addReplyBulkCString(c, getPreferredEndpoint(node));
    reply_count++;

    if (sdslen(node->hostname) != 0) {
        addReplyBulkCString(c, ""hostname"");
        addReplyBulkCBuffer(c, node->hostname, sdslen(node->hostname));
        reply_count++;
    }

    long long node_offset;
    if (node->flags & CLUSTER_NODE_MYSELF...",1,39,cluster.c,addNodeDetailsToShardReply,,false,5629,5690,addNodeDetailsToShardReply,,,234,"void addNodeDetailsToShardReply (client*,clusterNode*)"
59054,METHOD,cluster.c:<global>,TYPE_DECL,"void addShardReplyForClusterShards(client *c, list *nodes) {
    serverAssert(listLength(nodes) > 0);
    clusterNode *n = listNodeValue(listFirst(nodes));
    addReplyMapLen(c, 2);
    addReplyBulkCString(c, ""slots"");

    /* Use slot_info_pairs from the primary only */
    while (n->slaveof != NULL) n = n->slaveof;

    if (n->slot_info_pairs != NULL) {
        serverAssert((n->slot_info_pairs_count % 2) == 0);
        addReplyArrayLen(c, n->slot_info_pairs_count);
        for (int i = 0; i < n->slot_info_pairs_count; i++)
            addReplyBulkLongLong(c, (unsigned long)n->slot_info_pairs[i]);
    } else {
        /* If no slot info pair is provided, the node owns no slots */
        addReplyArrayLen(c, 0);
    }

    addReplyBulkCString(c, ""nodes"");
    addReplyArrayLen(c, listLength(nodes));
    listIter li;
    listRewind(nodes, &li);
    for (listNode *ln = listNext(&li); ln != NULL; ln = listNext(&li)) {
        clusterNode *n = listNodeValue(ln);
        addNodeDetailsToS...",1,4,cluster.c,addShardReplyForClusterShards,,false,5693,5721,addShardReplyForClusterShards,,,235,"void addShardReplyForClusterShards (client*,list*)"
59211,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterReplyShards(client *c) {
    addReplyArrayLen(c, dictSize(server.cluster->shards));
    /* This call will add slot_info_pairs to all nodes */
    clusterGenNodesSlotsInfo(0);
    dictIterator *di = dictGetSafeIterator(server.cluster->shards);
    for(dictEntry *de = dictNext(di); de != NULL; de = dictNext(di)) {
        addShardReplyForClusterShards(c, dictGetVal(de));
    }
    dictReleaseIterator(di);
}",1,24,cluster.c,clusterReplyShards,,false,5726,5735,clusterReplyShards,,,236,void clusterReplyShards (client*)
59276,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterReplyMultiBulkSlots(client * c) {
    /* Format: 1) 1) start slot
     *            2) end slot
     *            3) 1) master IP
     *               2) master port
     *               3) node ID
     *            4) 1) replica IP
     *               2) replica port
     *               3) node ID
     *           ... continued until done
     */
    clusterNode *n = NULL;
    int num_masters = 0, start = -1;
    void *slot_replylen = addReplyDeferredLen(c);

    for (int i = 0; i <= CLUSTER_SLOTS; i++) {
        /* Find start node and slot id. */
        if (n == NULL) {
            if (i == CLUSTER_SLOTS) break;
            n = server.cluster->slots[i];
            start = i;
            continue;
        }

        /* Add cluster slots info when occur different node with start
         * or end of slot. */
        if (i == CLUSTER_SLOTS || n != server.cluster->slots[i]) {
            addNodeReplyForClusterSlot(c, n, start, i-1);
            num_masters++;
         ...",1,25,cluster.c,clusterReplyMultiBulkSlots,,false,5737,5772,clusterReplyMultiBulkSlots,,,237,void clusterReplyMultiBulkSlots (client*)
59389,METHOD,cluster.c:<global>,TYPE_DECL,"sds genClusterInfoString(void) {
    sds info = sdsempty();
    char *statestr[] = {""ok"",""fail""};
    int slots_assigned = 0, slots_ok = 0, slots_pfail = 0, slots_fail = 0;
    uint64_t myepoch;
    int j;

    for (j = 0; j < CLUSTER_SLOTS; j++) {
        clusterNode *n = server.cluster->slots[j];

        if (n == NULL) continue;
        slots_assigned++;
        if (nodeFailed(n)) {
            slots_fail++;
        } else if (nodeTimedOut(n)) {
            slots_pfail++;
        } else {
            slots_ok++;
        }
    }

    myepoch = (nodeIsSlave(myself) && myself->slaveof) ?
                myself->slaveof->configEpoch : myself->configEpoch;

    info = sdscatprintf(info,
        ""cluster_state:%s\r\n""
        ""cluster_slots_assigned:%d\r\n""
        ""cluster_slots_ok:%d\r\n""
        ""cluster_slots_pfail:%d\r\n""
        ""cluster_slots_fail:%d\r\n""
        ""cluster_known_nodes:%lu\r\n""
        ""cluster_size:%d\r\n""
        ""cluster_current_epoch:%llu\r\n""
        ""cluster...",1,20,cluster.c,genClusterInfoString,,false,5774,5850,genClusterInfoString,,,238,sds genClusterInfoString (void)
59693,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""ADDSLOTS <slot> [<slot> ...]"",
""    Assign slots to current node."",
""ADDSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]"",
""    Assign slots which are between <start-slot> and <end-slot> to current node."",
""BUMPEPOCH"",
""    Advance the cluster config epoch."",
""COUNT-FAILURE-REPORTS <node-id>"",
""    Return number of failure reports for <node-id>."",
""COUNTKEYSINSLOT <slot>"",
""    Return the number of keys in <slot>."",
""DELSLOTS <slot> [<slot> ...]"",
""    Delete slots information from current node."",
""DELSLOTSRANGE <start slot> <end slot> [<start slot> <end slot> ...]"",
""    Delete slots information which are between <start-slot> and <end-slot> from current node."",
""FAILOVER [FORCE|TAKEOVER]"",
""    Promote current...",1,56,cluster.c,clusterCommand,,false,5852,6455,clusterCommand,,,239,void clusterCommand (client*)
62410,METHOD,cluster.c:<global>,TYPE_DECL,"void removeChannelsInSlot(unsigned int slot) {
    unsigned int channelcount = countChannelsInSlot(slot);
    if (channelcount == 0) return;

    /* Retrieve all the channels for the slot. */
    robj **channels = zmalloc(sizeof(robj*)*channelcount);
    raxIterator iter;
    int j = 0;
    unsigned char indexed[2];

    indexed[0] = (slot >> 8) & 0xff;
    indexed[1] = slot & 0xff;
    raxStart(&iter,server.cluster->slots_to_channels);
    raxSeek(&iter,"">="",indexed,2);
    while(raxNext(&iter)) {
        if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
        channels[j++] = createStringObject((char*)iter.key + 2, iter.key_len - 2);
    }
    raxStop(&iter);

    pubsubUnsubscribeShardChannels(channels, channelcount);
    zfree(channels);
}",1,1,cluster.c,removeChannelsInSlot,,false,6457,6479,removeChannelsInSlot,,,240,void removeChannelsInSlot (unsigned int)
62523,METHOD,cluster.c:<global>,TYPE_DECL,"void createDumpPayload(rio *payload, robj *o, robj *key, int dbid) {
    unsigned char buf[2];
    uint64_t crc;

    /* Serialize the object in an RDB-like format. It consist of an object type
     * byte followed by the serialized object. This is understood by RESTORE. */
    rioInitWithBuffer(payload,sdsempty());
    serverAssert(rdbSaveObjectType(payload,o));
    serverAssert(rdbSaveObject(payload,o,key,dbid));

    /* Write the footer, this is how it looks like:
     * ----------------+---------------------+---------------+
     * ... RDB payload | 2 bytes RDB version | 8 bytes CRC64 |
     * ----------------+---------------------+---------------+
     * RDB version and CRC are both in little endian.
     */

    /* RDB version */
    buf[0] = RDB_VERSION & 0xff;
    buf[1] = (RDB_VERSION >> 8) & 0xff;
    payload->io.buffer.ptr = sdscatlen(payload->io.buffer.ptr,buf,2);

    /* CRC64 */
    crc = crc64(0,(unsigned char*)payload->io.buffer.ptr,
                sdslen(payload->i...",1,4,cluster.c,createDumpPayload,,false,6487,6514,createDumpPayload,,,241,"void createDumpPayload (rio*,robj*,robj*,int)"
62655,METHOD,cluster.c:<global>,TYPE_DECL,"int verifyDumpPayload(unsigned char *p, size_t len, uint16_t *rdbver_ptr) {
    unsigned char *footer;
    uint16_t rdbver;
    uint64_t crc;

    /* At least 2 bytes of RDB version and 8 of CRC64 should be present. */
    if (len < 10) return C_ERR;
    footer = p+(len-10);

    /* Set and verify RDB version. */
    rdbver = (footer[1] << 8) | footer[0];
    if (rdbver_ptr) {
        *rdbver_ptr = rdbver;
    }
    if (rdbver > RDB_VERSION) return C_ERR;

    if (server.skip_checksum_validation)
        return C_OK;

    /* Verify CRC64 */
    crc = crc64(0,p,len-8);
    memrev64ifbe(&crc);
    return (memcmp(&crc,footer+2,8) == 0) ? C_OK : C_ERR;
}",1,25,cluster.c,verifyDumpPayload,,false,6521,6544,verifyDumpPayload,,,242,"int verifyDumpPayload (unsigned char*,size_t,uint16_t*)"
62754,METHOD,cluster.c:<global>,TYPE_DECL,"void dumpCommand(client *c) {
    robj *o;
    rio payload;

    /* Check if the key is here. */
    if ((o = lookupKeyRead(c->db,c->argv[1])) == NULL) {
        addReplyNull(c);
        return;
    }

    /* Create the DUMP encoded representation. */
    createDumpPayload(&payload,o,c->argv[1],c->db->id);

    /* Transfer to the client */
    addReplyBulkSds(c,payload.io.buffer.ptr);
    return;
}",1,1,cluster.c,dumpCommand,,false,6549,6565,dumpCommand,,,243,void dumpCommand (client*)
62803,METHOD,cluster.c:<global>,TYPE_DECL,"void restoreCommand(client *c) {
    long long ttl, lfu_freq = -1, lru_idle = -1, lru_clock = -1;
    rio payload;
    int j, type, replace = 0, absttl = 0;
    robj *obj;

    /* Parse additional options */
    for (j = 4; j < c->argc; j++) {
        int additional = c->argc-j-1;
        if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""absttl"")) {
            absttl = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""idletime"") && additional >= 1 &&
                   lfu_freq == -1)
        {
            if (getLongLongFromObjectOrReply(c,c->argv[j+1],&lru_idle,NULL)
                    != C_OK) return;
            if (lru_idle < 0) {
                addReplyError(c,""Invalid IDLETIME value, must be >= 0"");
                return;
            }
            lru_clock = LRU_CLOCK();
            j++; /* Consume additional arg. */
        } else if (!strcasecmp(c->argv[j]->ptr,""freq"") && additional >= 1 &&
         ...",1,23,cluster.c,restoreCommand,,false,6568,6674,restoreCommand,,,244,void restoreCommand (client*)
63295,METHOD,cluster.c:<global>,TYPE_DECL,"migrateCachedSocket* migrateGetSocket(client *c, robj *host, robj *port, long timeout) {
    connection *conn;
    sds name = sdsempty();
    migrateCachedSocket *cs;

    /* Check if we have an already cached socket for this ip:port pair. */
    name = sdscatlen(name,host->ptr,sdslen(host->ptr));
    name = sdscatlen(name,"":"",1);
    name = sdscatlen(name,port->ptr,sdslen(port->ptr));
    cs = dictFetchValue(server.migrate_cached_sockets,name);
    if (cs) {
        sdsfree(name);
        cs->last_use_time = server.unixtime;
        return cs;
    }

    /* No cached socket, create one. */
    if (dictSize(server.migrate_cached_sockets) == MIGRATE_SOCKET_CACHE_ITEMS) {
        /* Too many items, drop one at random. */
        dictEntry *de = dictGetRandomKey(server.migrate_cached_sockets);
        cs = dictGetVal(de);
        connClose(cs->conn);
        zfree(cs);
        dictDelete(server.migrate_cached_sockets,dictGetKey(de));
    }

    /* Create the connection */
    conn = co...",1,8,cluster.c,migrateGetSocket,,false,6702,6747,migrateGetSocket,,,247,"migrateCachedSocket migrateGetSocket (client*,robj*,robj*,long)"
63470,METHOD,cluster.c:<global>,TYPE_DECL,"void migrateCloseSocket(robj *host, robj *port) {
    sds name = sdsempty();
    migrateCachedSocket *cs;

    name = sdscatlen(name,host->ptr,sdslen(host->ptr));
    name = sdscatlen(name,"":"",1);
    name = sdscatlen(name,port->ptr,sdslen(port->ptr));
    cs = dictFetchValue(server.migrate_cached_sockets,name);
    if (!cs) {
        sdsfree(name);
        return;
    }

    connClose(cs->conn);
    zfree(cs);
    dictDelete(server.migrate_cached_sockets,name);
    sdsfree(name);
}",1,1,cluster.c,migrateCloseSocket,,false,6750,6767,migrateCloseSocket,,,248,"void migrateCloseSocket (robj*,robj*)"
63536,METHOD,cluster.c:<global>,TYPE_DECL,"void migrateCloseTimedoutSockets(void) {
    dictIterator *di = dictGetSafeIterator(server.migrate_cached_sockets);
    dictEntry *de;

    while((de = dictNext(di)) != NULL) {
        migrateCachedSocket *cs = dictGetVal(de);

        if ((server.unixtime - cs->last_use_time) > MIGRATE_SOCKET_CACHE_TTL) {
            connClose(cs->conn);
            zfree(cs);
            dictDelete(server.migrate_cached_sockets,dictGetKey(de));
        }
    }
    dictReleaseIterator(di);
}",1,52,cluster.c,migrateCloseTimedoutSockets,,false,6769,6783,migrateCloseTimedoutSockets,,,249,void migrateCloseTimedoutSockets (void)
63589,METHOD,cluster.c:<global>,TYPE_DECL,"void migrateCommand(client *c) {
    migrateCachedSocket *cs;
    int copy = 0, replace = 0, j;
    char *username = NULL;
    char *password = NULL;
    long timeout;
    long dbid;
    robj **ov = NULL; /* Objects to migrate. */
    robj **kv = NULL; /* Key names. */
    robj **newargv = NULL; /* Used to rewrite the command as DEL ... keys ... */
    rio cmd, payload;
    int may_retry = 1;
    int write_error = 0;
    int argv_rewritten = 0;

    /* To support the KEYS option we need the following additional state. */
    int first_key = 3; /* Argument index of the first key. */
    int num_keys = 1;  /* By default only migrate the 'key' argument. */

    /* Parse additional options */
    for (j = 6; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        if (!strcasecmp(c->argv[j]->ptr,""copy"")) {
            copy = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""auth"")) {
      ...",1,64,cluster.c,migrateCommand,,false,6792,7130,migrateCommand,,,250,void migrateCommand (client*)
64924,METHOD,cluster.c:<global>,TYPE_DECL,"void askingCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags |= CLIENT_ASKING;
    addReply(c,shared.ok);
}",1,16,cluster.c,askingCommand,,false,7140,7147,askingCommand,,,251,void askingCommand (client*)
64954,METHOD,cluster.c:<global>,TYPE_DECL,"void readonlyCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags |= CLIENT_READONLY;
    addReply(c,shared.ok);
}",1,16,cluster.c,readonlyCommand,,false,7152,7159,readonlyCommand,,,252,void readonlyCommand (client*)
64984,METHOD,cluster.c:<global>,TYPE_DECL,"void readwriteCommand(client *c) {
    if (server.cluster_enabled == 0) {
        addReplyError(c,""This instance has cluster support disabled"");
        return;
    }
    c->flags &= ~CLIENT_READONLY;
    addReply(c,shared.ok);
}",1,17,cluster.c,readwriteCommand,,false,7162,7169,readwriteCommand,,,253,void readwriteCommand (client*)
65015,METHOD,cluster.c:<global>,TYPE_DECL,"clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {
    clusterNode *n = NULL;
    robj *firstkey = NULL;
    int multiple_keys = 0;
    multiState *ms, _ms;
    multiCmd mc;
    int i, slot = 0, migrating_slot = 0, importing_slot = 0, missing_keys = 0,
        existing_keys = 0;

    /* Allow any key to be set if a module disabled cluster redirections. */
    if (server.cluster_module_flags & CLUSTER_MODULE_FLAG_NO_REDIRECTION)
        return myself;

    /* Set error code optimistically for the base case. */
    if (error_code) *error_code = CLUSTER_REDIR_NONE;

    /* Modules can turn off Redis Cluster redirection: this is useful
     * when writing a module that implements a completely different
     * distributed system. */

    /* We handle all the cases as if they were EXEC commands, so we have
     * a common code path for everything */
    if (cmd->proc == execCommand) {
        /* If CLIENT_MULTI flag is...",1,38,cluster.c,getNodeByQuery,,false,7203,7413,getNodeByQuery,,,254,"clusterNode getNodeByQuery (client*,redisCommand*,robj**,int,int*,int*)"
65692,METHOD,cluster.c:<global>,TYPE_DECL,"void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
    if (error_code == CLUSTER_REDIR_CROSS_SLOT) {
        addReplyError(c,""-CROSSSLOT Keys in request don't hash to the same slot"");
    } else if (error_code == CLUSTER_REDIR_UNSTABLE) {
        /* The request spawns multiple keys in the same slot,
         * but the slot is not ""stable"" currently as there is
         * a migration or import in progress. */
        addReplyError(c,""-TRYAGAIN Multiple keys request during rehashing of slot"");
    } else if (error_code == CLUSTER_REDIR_DOWN_STATE) {
        addReplyError(c,""-CLUSTERDOWN The cluster is down"");
    } else if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
        addReplyError(c,""-CLUSTERDOWN The cluster is down and only accepts read commands"");
    } else if (error_code == CLUSTER_REDIR_DOWN_UNBOUND) {
        addReplyError(c,""-CLUSTERDOWN Hash slot not served"");
    } else if (error_code == CLUSTER_REDIR_MOVED ||
               error_c...",1,22,cluster.c,clusterRedirectClient,,false,7422,7448,clusterRedirectClient,,,255,"void clusterRedirectClient (client*,clusterNode*,int,int)"
65809,METHOD,cluster.c:<global>,TYPE_DECL,"int clusterRedirectBlockedClientIfNeeded(client *c) {
    if (c->flags & CLIENT_BLOCKED &&
        (c->bstate.btype == BLOCKED_LIST ||
         c->bstate.btype == BLOCKED_ZSET ||
         c->bstate.btype == BLOCKED_STREAM ||
         c->bstate.btype == BLOCKED_MODULE))
    {
        dictEntry *de;
        dictIterator *di;

        /* If the cluster is down, unblock the client with the right error.
         * If the cluster is configured to allow reads on cluster down, we
         * still want to emit this error since a write will be required
         * to unblock them which may never come.  */
        if (server.cluster->state == CLUSTER_FAIL) {
            clusterRedirectClient(c,NULL,0,CLUSTER_REDIR_DOWN_STATE);
            return 1;
        }

        /* If the client is blocked on module, but not on a specific key,
         * don't unblock it (except for the CLUSTER_FAIL case above). */
        if (c->bstate.btype == BLOCKED_MODULE && !moduleClientIsBlockedOnKeys(c))
          ...",1,19,cluster.c,clusterRedirectBlockedClientIfNeeded,,false,7461,7521,clusterRedirectBlockedClientIfNeeded,,,256,int clusterRedirectBlockedClientIfNeeded (client*)
66024,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToKeyAddEntry(dictEntry *entry, redisDb *db) {
    sds key = dictGetKey(entry);
    unsigned int hashslot = keyHashSlot(key, sdslen(key));
    slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
    slot_to_keys->count++;

    /* Insert entry before the first element in the list. */
    dictEntry *first = slot_to_keys->head;
    dictEntryNextInSlot(entry) = first;
    if (first != NULL) {
        serverAssert(dictEntryPrevInSlot(first) == NULL);
        dictEntryPrevInSlot(first) = entry;
    }
    serverAssert(dictEntryPrevInSlot(entry) == NULL);
    slot_to_keys->head = entry;
}",1,4,cluster.c,slotToKeyAddEntry,,false,7528,7543,slotToKeyAddEntry,,,257,"void slotToKeyAddEntry (dictEntry*,redisDb*)"
66138,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToKeyDelEntry(dictEntry *entry, redisDb *db) {
    sds key = dictGetKey(entry);
    unsigned int hashslot = keyHashSlot(key, sdslen(key));
    slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
    slot_to_keys->count--;

    /* Connect previous and next entries to each other. */
    dictEntry *next = dictEntryNextInSlot(entry);
    dictEntry *prev = dictEntryPrevInSlot(entry);
    if (next != NULL) {
        dictEntryPrevInSlot(next) = prev;
    }
    if (prev != NULL) {
        dictEntryNextInSlot(prev) = next;
    } else {
        /* The removed entry was the first in the list. */
        serverAssert(slot_to_keys->head == entry);
        slot_to_keys->head = next;
    }
}",1,22,cluster.c,slotToKeyDelEntry,,false,7545,7564,slotToKeyDelEntry,,,258,"void slotToKeyDelEntry (dictEntry*,redisDb*)"
66253,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToKeyReplaceEntry(dict *d, dictEntry *entry) {
    dictEntry *next = dictEntryNextInSlot(entry);
    dictEntry *prev = dictEntryPrevInSlot(entry);
    if (next != NULL) {
        dictEntryPrevInSlot(next) = entry;
    }
    if (prev != NULL) {
        dictEntryNextInSlot(prev) = entry;
    } else {
        /* The replaced entry was the first in the list. */
        sds key = dictGetKey(entry);
        unsigned int hashslot = keyHashSlot(key, sdslen(key));
        clusterDictMetadata *dictmeta = dictMetadata(d);
        redisDb *db = dictmeta->db;
        slotToKeys *slot_to_keys = &(*db->slots_to_keys).by_slot[hashslot];
        slot_to_keys->head = entry;
    }
}",1,22,cluster.c,slotToKeyReplaceEntry,,false,7568,7585,slotToKeyReplaceEntry,,,259,"void slotToKeyReplaceEntry (dict*,dictEntry*)"
66357,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToKeyInit(redisDb *db) {
    db->slots_to_keys = zcalloc(sizeof(clusterSlotToKeyMapping));
    clusterDictMetadata *dictmeta = dictMetadata(db->dict);
    dictmeta->db = db;
}",1,1,cluster.c,slotToKeyInit,,false,7588,7592,slotToKeyInit,,,260,void slotToKeyInit (redisDb*)
66381,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToKeyFlush(redisDb *db) {
    memset(db->slots_to_keys, 0,
        sizeof(clusterSlotToKeyMapping));
}",1,1,cluster.c,slotToKeyFlush,,false,7595,7598,slotToKeyFlush,,,261,void slotToKeyFlush (redisDb*)
66393,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToKeyDestroy(redisDb *db) {
    zfree(db->slots_to_keys);
    db->slots_to_keys = NULL;
}",1,1,cluster.c,slotToKeyDestroy,,false,7601,7604,slotToKeyDestroy,,,262,void slotToKeyDestroy (redisDb*)
66407,METHOD,cluster.c:<global>,TYPE_DECL,"unsigned int delKeysInSlot(unsigned int hashslot) {
    unsigned int j = 0;

    dictEntry *de = (*server.db->slots_to_keys).by_slot[hashslot].head;
    while (de != NULL) {
        sds sdskey = dictGetKey(de);
        de = dictEntryNextInSlot(de);
        robj *key = createStringObject(sdskey, sdslen(sdskey));
        dbDelete(&server.db[0], key);
        propagateDeletion(&server.db[0], key, server.lazyfree_lazy_server_del);
        signalModifiedKey(NULL, &server.db[0], key);
        moduleNotifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", key, server.db[0].id);
        postExecutionUnitOperations();
        decrRefCount(key);
        j++;
        server.dirty++;
    }

    return j;
}",1,13,cluster.c,delKeysInSlot,,false,7608,7627,delKeysInSlot,,,263,unsigned int delKeysInSlot (unsigned int)
66513,METHOD,cluster.c:<global>,TYPE_DECL,"unsigned int countKeysInSlot(unsigned int hashslot) {
    return (*server.db->slots_to_keys).by_slot[hashslot].count;
}",1,1,cluster.c,countKeysInSlot,,false,7629,7631,countKeysInSlot,,,264,unsigned int countKeysInSlot (unsigned int)
66531,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToChannelUpdate(sds channel, int add) {
    size_t keylen = sdslen(channel);
    unsigned int hashslot = keyHashSlot(channel,keylen);
    unsigned char buf[64];
    unsigned char *indexed = buf;

    if (keylen+2 > 64) indexed = zmalloc(keylen+2);
    indexed[0] = (hashslot >> 8) & 0xff;
    indexed[1] = hashslot & 0xff;
    memcpy(indexed+2,channel,keylen);
    if (add) {
        raxInsert(server.cluster->slots_to_channels,indexed,keylen+2,NULL,NULL);
    } else {
        raxRemove(server.cluster->slots_to_channels,indexed,keylen+2,NULL);
    }
    if (indexed != buf) zfree(indexed);
}",1,1,cluster.c,slotToChannelUpdate,,false,7637,7653,slotToChannelUpdate,,,265,"void slotToChannelUpdate (sds,int)"
66623,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToChannelAdd(sds channel) {
    slotToChannelUpdate(channel,1);
}",1,1,cluster.c,slotToChannelAdd,,false,7655,7657,slotToChannelAdd,,,266,void slotToChannelAdd (sds)
66631,METHOD,cluster.c:<global>,TYPE_DECL,"void slotToChannelDel(sds channel) {
    slotToChannelUpdate(channel,0);
}",1,1,cluster.c,slotToChannelDel,,false,7659,7661,slotToChannelDel,,,267,void slotToChannelDel (sds)
66639,METHOD,cluster.c:<global>,TYPE_DECL,"unsigned int countChannelsInSlot(unsigned int hashslot) {
    raxIterator iter;
    int j = 0;
    unsigned char indexed[2];

    indexed[0] = (hashslot >> 8) & 0xff;
    indexed[1] = hashslot & 0xff;
    raxStart(&iter,server.cluster->slots_to_channels);
    raxSeek(&iter,"">="",indexed,2);
    while(raxNext(&iter)) {
        if (iter.key[0] != indexed[0] || iter.key[1] != indexed[1]) break;
        j++;
    }
    raxStop(&iter);
    return j;
}",1,1,cluster.c,countChannelsInSlot,,false,7664,7679,countChannelsInSlot,,,268,unsigned int countChannelsInSlot (unsigned int)
66717,METHOD,cluster.h:<global>,TYPE_DECL,<global>,1,14,cluster.h,cluster.h:<global>,,false,1,446,<global>,,,1,
66771,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterNode:<clinit>,,false,117,,<clinit>,,,33,
66798,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterSlotToKeyMapping:<clinit>,,false,161,,<clinit>,,,2,
66842,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterState:<clinit>,,false,176,,<clinit>,,,29,
66883,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgDataGossip:<clinit>,,false,230,,<clinit>,,,10,
66896,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgDataFail:<clinit>,,false,242,,<clinit>,,,2,
66909,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgDataPublish:<clinit>,,false,246,,<clinit>,,,4,
66920,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgDataUpdate:<clinit>,,false,252,,<clinit>,,,4,
66940,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgModule:<clinit>,,false,258,,<clinit>,,,5,
66955,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgPingExtHostname:<clinit>,,false,278,,<clinit>,,,2,
66964,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgPingExtHumanNodename:<clinit>,,false,282,,<clinit>,,,2,
66974,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgPingExtForgottenNode:<clinit>,,false,286,,<clinit>,,,3,
66986,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgPingExtShardId:<clinit>,,false,293,,<clinit>,,,2,
67005,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsgPingExt:<clinit>,,false,297,,<clinit>,,,6,
67014,METHOD,<empty>,<empty>,<empty>,5,,cluster.h,clusterMsgData.ping:<clinit>,,false,312,,<clinit>,,,2,
67056,METHOD,<empty>,<empty>,<empty>,1,,cluster.h,clusterMsg:<clinit>,,false,343,,<clinit>,,,23,
67104,METHOD,cluster.h:<global>,TYPE_DECL,void clusterInit(void);,6,22,cluster.h,clusterInit,,false,412,412,clusterInit,,,64,void clusterInit (void)
67109,METHOD,cluster.h:<global>,TYPE_DECL,void clusterInitListeners(void);,6,31,cluster.h,clusterInitListeners,,false,413,413,clusterInitListeners,,,65,void clusterInitListeners (void)
67114,METHOD,cluster.h:<global>,TYPE_DECL,void clusterCron(void);,6,22,cluster.h,clusterCron,,false,414,414,clusterCron,,,66,void clusterCron (void)
67119,METHOD,cluster.h:<global>,TYPE_DECL,void clusterBeforeSleep(void);,6,29,cluster.h,clusterBeforeSleep,,false,415,415,clusterBeforeSleep,,,67,void clusterBeforeSleep (void)
67124,METHOD,cluster.h:<global>,TYPE_DECL,"clusterNode *getNodeByQuery(client *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask);",13,112,cluster.h,getNodeByQuery,,false,416,416,getNodeByQuery,,,68,"clusterNode* getNodeByQuery (client*,redisCommand*,robj**,int,int*,int*)"
67134,METHOD,cluster.h:<global>,TYPE_DECL,"int verifyClusterNodeId(const char *name, int length);",5,53,cluster.h,verifyClusterNodeId,,false,417,417,verifyClusterNodeId,,,69,"int verifyClusterNodeId (char*,int)"
67140,METHOD,cluster.h:<global>,TYPE_DECL,"clusterNode *clusterLookupNode(const char *name, int length);",13,60,cluster.h,clusterLookupNode,,false,418,418,clusterLookupNode,,,70,"clusterNode* clusterLookupNode (char*,int)"
67146,METHOD,cluster.h:<global>,TYPE_DECL,int clusterRedirectBlockedClientIfNeeded(client *c);,5,51,cluster.h,clusterRedirectBlockedClientIfNeeded,,false,419,419,clusterRedirectBlockedClientIfNeeded,,,71,int clusterRedirectBlockedClientIfNeeded (client*)
67151,METHOD,cluster.h:<global>,TYPE_DECL,"void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code);",6,83,cluster.h,clusterRedirectClient,,false,420,420,clusterRedirectClient,,,72,"void clusterRedirectClient (client*,clusterNode*,int,int)"
67159,METHOD,cluster.h:<global>,TYPE_DECL,void migrateCloseTimedoutSockets(void);,6,38,cluster.h,migrateCloseTimedoutSockets,,false,421,421,migrateCloseTimedoutSockets,,,73,void migrateCloseTimedoutSockets (void)
67164,METHOD,cluster.h:<global>,TYPE_DECL,int verifyClusterConfigWithData(void);,5,37,cluster.h,verifyClusterConfigWithData,,false,422,422,verifyClusterConfigWithData,,,74,int verifyClusterConfigWithData (void)
67169,METHOD,cluster.h:<global>,TYPE_DECL,unsigned long getClusterConnectionsCount(void);,15,46,cluster.h,getClusterConnectionsCount,,false,423,423,getClusterConnectionsCount,,,75,long unsigned getClusterConnectionsCount (void)
67174,METHOD,cluster.h:<global>,TYPE_DECL,"int clusterSendModuleMessageToTarget(const char *target, uint64_t module_id, uint8_t type, const char *payload, uint32_t len);",5,125,cluster.h,clusterSendModuleMessageToTarget,,false,424,424,clusterSendModuleMessageToTarget,,,76,"int clusterSendModuleMessageToTarget (char*,uint64_t,uint8_t,char*,uint32_t)"
67183,METHOD,cluster.h:<global>,TYPE_DECL,"void clusterPropagatePublish(robj *channel, robj *message, int sharded);",6,71,cluster.h,clusterPropagatePublish,,false,425,425,clusterPropagatePublish,,,77,"void clusterPropagatePublish (robj*,robj*,int)"
67190,METHOD,cluster.h:<global>,TYPE_DECL,"unsigned int keyHashSlot(char *key, int keylen);",14,47,cluster.h,keyHashSlot,,false,426,426,keyHashSlot,,,78,"unsigned int keyHashSlot (char*,int)"
67196,METHOD,cluster.h:<global>,TYPE_DECL,"void slotToKeyAddEntry(dictEntry *entry, redisDb *db);",6,53,cluster.h,slotToKeyAddEntry,,false,427,427,slotToKeyAddEntry,,,79,"void slotToKeyAddEntry (dictEntry*,redisDb*)"
67202,METHOD,cluster.h:<global>,TYPE_DECL,"void slotToKeyDelEntry(dictEntry *entry, redisDb *db);",6,53,cluster.h,slotToKeyDelEntry,,false,428,428,slotToKeyDelEntry,,,80,"void slotToKeyDelEntry (dictEntry*,redisDb*)"
67208,METHOD,cluster.h:<global>,TYPE_DECL,"void slotToKeyReplaceEntry(dict *d, dictEntry *entry);",6,53,cluster.h,slotToKeyReplaceEntry,,false,429,429,slotToKeyReplaceEntry,,,81,"void slotToKeyReplaceEntry (dict*,dictEntry*)"
67214,METHOD,cluster.h:<global>,TYPE_DECL,void slotToKeyInit(redisDb *db);,6,31,cluster.h,slotToKeyInit,,false,430,430,slotToKeyInit,,,82,void slotToKeyInit (redisDb*)
67219,METHOD,cluster.h:<global>,TYPE_DECL,void slotToKeyFlush(redisDb *db);,6,32,cluster.h,slotToKeyFlush,,false,431,431,slotToKeyFlush,,,83,void slotToKeyFlush (redisDb*)
67224,METHOD,cluster.h:<global>,TYPE_DECL,void slotToKeyDestroy(redisDb *db);,6,34,cluster.h,slotToKeyDestroy,,false,432,432,slotToKeyDestroy,,,84,void slotToKeyDestroy (redisDb*)
67229,METHOD,cluster.h:<global>,TYPE_DECL,void clusterUpdateMyselfFlags(void);,6,35,cluster.h,clusterUpdateMyselfFlags,,false,433,433,clusterUpdateMyselfFlags,,,85,void clusterUpdateMyselfFlags (void)
67234,METHOD,cluster.h:<global>,TYPE_DECL,void clusterUpdateMyselfIp(void);,6,32,cluster.h,clusterUpdateMyselfIp,,false,434,434,clusterUpdateMyselfIp,,,86,void clusterUpdateMyselfIp (void)
67239,METHOD,cluster.h:<global>,TYPE_DECL,void slotToChannelAdd(sds channel);,6,34,cluster.h,slotToChannelAdd,,false,435,435,slotToChannelAdd,,,87,void slotToChannelAdd (sds)
67244,METHOD,cluster.h:<global>,TYPE_DECL,void slotToChannelDel(sds channel);,6,34,cluster.h,slotToChannelDel,,false,436,436,slotToChannelDel,,,88,void slotToChannelDel (sds)
67249,METHOD,cluster.h:<global>,TYPE_DECL,void clusterUpdateMyselfHostname(void);,6,38,cluster.h,clusterUpdateMyselfHostname,,false,437,437,clusterUpdateMyselfHostname,,,89,void clusterUpdateMyselfHostname (void)
67254,METHOD,cluster.h:<global>,TYPE_DECL,void clusterUpdateMyselfAnnouncedPorts(void);,6,44,cluster.h,clusterUpdateMyselfAnnouncedPorts,,false,438,438,clusterUpdateMyselfAnnouncedPorts,,,90,void clusterUpdateMyselfAnnouncedPorts (void)
67259,METHOD,cluster.h:<global>,TYPE_DECL,"sds clusterGenNodesDescription(client *c, int filter, int tls_primary);",5,70,cluster.h,clusterGenNodesDescription,,false,439,439,clusterGenNodesDescription,,,91,"sds clusterGenNodesDescription (client*,int,int)"
67266,METHOD,cluster.h:<global>,TYPE_DECL,sds genClusterInfoString(void);,5,30,cluster.h,genClusterInfoString,,false,440,440,genClusterInfoString,,,92,sds genClusterInfoString (void)
67271,METHOD,cluster.h:<global>,TYPE_DECL,void freeClusterLink(clusterLink *link);,6,39,cluster.h,freeClusterLink,,false,441,441,freeClusterLink,,,93,void freeClusterLink (clusterLink*)
67276,METHOD,cluster.h:<global>,TYPE_DECL,void clusterUpdateMyselfHumanNodename(void);,6,43,cluster.h,clusterUpdateMyselfHumanNodename,,false,442,442,clusterUpdateMyselfHumanNodename,,,94,void clusterUpdateMyselfHumanNodename (void)
67281,METHOD,cluster.h:<global>,TYPE_DECL,"int isValidAuxString(char *s, unsigned int length);",5,50,cluster.h,isValidAuxString,,false,443,443,isValidAuxString,,,95,"int isValidAuxString (char*,unsigned int)"
67287,METHOD,cluster.h:<global>,TYPE_DECL,int getNodeDefaultClientPort(clusterNode *n);,5,44,cluster.h,getNodeDefaultClientPort,,false,444,444,getNodeDefaultClientPort,,,96,int getNodeDefaultClientPort (clusterNode*)
67303,METHOD,commands.c:<global>,TYPE_DECL,<global>,1,6,commands.h,commands.c:<global>,,false,1,13,<global>,,,1,
67308,METHOD,commands.h:<global>,TYPE_DECL,<global>,1,6,commands.h,commands.h:<global>,,false,1,40,<global>,,,1,
67335,METHOD,commands.h:<global>,TYPE_DECL,const char *commandGroupStr(int index);,12,38,commands.h,commandGroupStr,,false,38,38,commandGroupStr,,,5,char* commandGroupStr (int)
67363,METHOD,config.c:<global>,TYPE_DECL,<global>,1,1,config.c,config.c:<global>,,false,1,3413,<global>,,,1,
67812,METHOD,boolConfigData,TYPE_DECL,"int (*is_valid_fn)(int val, const char **err);",9,49,config.c,boolConfigData.is_valid_fn,,false,188,188,is_valid_fn,,,3,"int boolConfigData.is_valid_fn (int,char**)"
67822,METHOD,stringConfigData,TYPE_DECL,"int (*is_valid_fn)(char* val, const char **err);",9,51,config.c,stringConfigData.is_valid_fn,,false,194,194,is_valid_fn,,,3,"int stringConfigData.is_valid_fn (char*,char**)"
67833,METHOD,sdsConfigData,TYPE_DECL,"int (*is_valid_fn)(sds val, const char **err);",9,49,config.c,sdsConfigData.is_valid_fn,,false,202,202,is_valid_fn,,,3,"int sdsConfigData.is_valid_fn (sds,char**)"
67845,METHOD,enumConfigData,TYPE_DECL,"int (*is_valid_fn)(int val, const char **err);",9,49,config.c,enumConfigData.is_valid_fn,,false,211,211,is_valid_fn,,,4,"int enumConfigData.is_valid_fn (int,char**)"
67882,METHOD,numericConfigData,TYPE_DECL,"int (*is_valid_fn)(long long val, const char **err);",9,55,config.c,numericConfigData.is_valid_fn,,false,245,245,is_valid_fn,,,8,"int numericConfigData.is_valid_fn (long long,char**)"
67898,METHOD,config.c:<global>,TYPE_DECL,typedef int (*apply_fn)(const char **err);,13,41,config.c,apply_fn,,false,258,258,apply_fn,,,51,int apply_fn (char**)
67904,METHOD,typeInterface,TYPE_DECL,void (*init)(standardConfig *config);,10,40,config.c,typeInterface.init,,false,261,261,init,,,1,void typeInterface.init (standardConfig*)
67909,METHOD,typeInterface,TYPE_DECL,"int (*set)(standardConfig *config, sds *argv, int argc, const char **err);",9,77,config.c,typeInterface.set,,false,265,265,set,,,2,"int typeInterface.set (standardConfig*,sds*,int,char**)"
67918,METHOD,typeInterface,TYPE_DECL,sds (*get)(standardConfig *config);,9,38,config.c,typeInterface.get,,false,271,271,get,,,4,sds typeInterface.get (standardConfig*)
67923,METHOD,typeInterface,TYPE_DECL,"void (*rewrite)(standardConfig *config, const char *name, struct rewriteConfigState *state);",10,95,config.c,typeInterface.rewrite,,false,273,273,rewrite,,,5,"void typeInterface.rewrite (standardConfig*,char*,rewriteConfigState*)"
67943,METHOD,config.c:<global>,TYPE_DECL,"static standardConfig *lookupConfig(sds name) {
    dictEntry *de = dictFind(configs, name);
    return de ? dictGetVal(de) : NULL;
}",1,1,config.c,lookupConfig,,false,290,293,lookupConfig,,,57,standardConfig lookupConfig (sds)
67960,METHOD,config.c:<global>,TYPE_DECL,"int configEnumGetValue(configEnum *ce, sds *argv, int argc, int bitflags) {
    if (argc == 0 || (!bitflags && argc != 1)) return INT_MIN;
    int values = 0;
    for (int i = 0; i < argc; i++) {
        int matched = 0;
        for (configEnum *ceItem = ce; ceItem->name != NULL; ceItem++) {
            if (!strcasecmp(argv[i],ceItem->name)) {
                values |= ceItem->val;
                matched = 1;
            }
        }
        if (!matched) return INT_MIN;
    }
    return values;
}",1,1,config.c,configEnumGetValue,,false,300,314,configEnumGetValue,,,58,"int configEnumGetValue (configEnum*,sds*,int,int)"
68042,METHOD,config.c:<global>,TYPE_DECL,"static sds configEnumGetName(configEnum *ce, int values, int bitflags) {
    sds names = NULL;
    int unmatched = values;
    for( ; ce->name != NULL; ce++) {
        if (values == ce->val) { /* Short path for perfect match */
            sdsfree(names);
            return sdsnew(ce->name);
        }

        /* Note: for bitflags, we want them sorted from high to low, so that if there are several / partially
         * overlapping entries, we'll prefer the ones matching more bits. */
        if (bitflags && ce->val && ce->val == (unmatched & ce->val)) {
            names = names ? sdscatfmt(names, "" %s"", ce->name) : sdsnew(ce->name);
            unmatched &= ~ce->val;
        }
    }
    if (!names || unmatched) {
        sdsfree(names);
        return sdsnew(""unknown"");
    }
    return names;
}",1,1,config.c,configEnumGetName,,false,317,338,configEnumGetName,,,59,"sds configEnumGetName (configEnum*,int,int)"
68131,METHOD,config.c:<global>,TYPE_DECL,"const char *evictPolicyToString(void) {
    for (configEnum *ce = maxmemory_policy_enum; ce->name != NULL; ce++) {
        if (server.maxmemory_policy == ce->val)
            return ce->name;
    }
    serverPanic(""unknown eviction policy"");
}",1,4,config.c,evictPolicyToString,,false,341,347,evictPolicyToString,,,60,const char* evictPolicyToString (void)
68171,METHOD,config.c:<global>,TYPE_DECL,"int yesnotoi(char *s) {
    if (!strcasecmp(s,""yes"")) return 1;
    else if (!strcasecmp(s,""no"")) return 0;
    else return -1;
}",1,1,config.c,yesnotoi,,false,353,357,yesnotoi,,,61,int yesnotoi (char*)
68199,METHOD,config.c:<global>,TYPE_DECL,"void appendServerSaveParams(time_t seconds, int changes) {
    server.saveparams = zrealloc(server.saveparams,sizeof(struct saveparam)*(server.saveparamslen+1));
    server.saveparams[server.saveparamslen].seconds = seconds;
    server.saveparams[server.saveparamslen].changes = changes;
    server.saveparamslen++;
}",1,1,config.c,appendServerSaveParams,,false,359,364,appendServerSaveParams,,,62,"void appendServerSaveParams (time_t,int)"
68247,METHOD,config.c:<global>,TYPE_DECL,"void resetServerSaveParams(void) {
    zfree(server.saveparams);
    server.saveparams = NULL;
    server.saveparamslen = 0;
}",1,1,config.c,resetServerSaveParams,,false,366,370,resetServerSaveParams,,,63,void resetServerSaveParams (void)
68266,METHOD,config.c:<global>,TYPE_DECL,"void queueLoadModule(sds path, sds *argv, int argc) {
    int i;
    struct moduleLoadQueueEntry *loadmod;

    loadmod = zmalloc(sizeof(struct moduleLoadQueueEntry));
    loadmod->argv = argc ? zmalloc(sizeof(robj*)*argc) : NULL;
    loadmod->path = sdsnew(path);
    loadmod->argc = argc;
    for (i = 0; i < argc; i++) {
        loadmod->argv[i] = createRawStringObject(argv[i],sdslen(argv[i]));
    }
    listAddNodeTail(server.loadmodule_queue,loadmod);
}",1,1,config.c,queueLoadModule,,false,372,384,queueLoadModule,,,64,"void queueLoadModule (sds,sds*,int)"
68333,METHOD,config.c:<global>,TYPE_DECL,"static int updateClientOutputBufferLimit(sds *args, int arg_len, const char **err) {
    int j;
    int class;
    unsigned long long hard, soft;
    int hard_err, soft_err;
    int soft_seconds;
    char *soft_seconds_eptr;
    clientBufferLimitsConfig values[CLIENT_TYPE_OBUF_COUNT];
    int classes[CLIENT_TYPE_OBUF_COUNT] = {0};

    /* We need a multiple of 4: <class> <hard> <soft> <soft_seconds> */
    if (arg_len % 4) {
        if (err) *err = ""Wrong number of arguments in ""
                        ""buffer limit configuration."";
        return 0;
    }

    /* Sanity check of single arguments, so that we either refuse the
     * whole configuration string or accept it all, even if a single
     * error in a single client class is present. */
    for (j = 0; j < arg_len; j += 4) {
        class = getClientTypeByName(args[j]);
        if (class == -1 || class == CLIENT_TYPE_MASTER) {
            if (err) *err = ""Invalid client class specified in ""
                            ""buf...",1,36,config.c,updateClientOutputBufferLimit,,false,389,440,updateClientOutputBufferLimit,,,65,"int updateClientOutputBufferLimit (sds*,int,char**)"
68517,METHOD,config.c:<global>,TYPE_DECL,"void loadServerConfigFromString(char *config) {
    deprecatedConfig deprecated_configs[] = {
        {""list-max-ziplist-entries"", 2, 2},
        {""list-max-ziplist-value"", 2, 2},
        {""lua-replicate-commands"", 2, 2},
        {NULL, 0},
    };
    char buf[1024];
    const char *err = NULL;
    int linenum = 0, totlines, i;
    sds *lines;
    sds *argv = NULL;
    int argc;

    reading_config_file = 1;
    lines = sdssplitlen(config,strlen(config),""\n"",1,&totlines);

    for (i = 0; i < totlines; i++) {
        linenum = i+1;
        lines[i] = sdstrim(lines[i],"" \t\r\n"");

        /* Skip comments and blank lines */
        if (lines[i][0] == '#' || lines[i][0] == '\0') continue;

        /* Split into arguments */
        argv = sdssplitargs(lines[i],&argc);
        if (argv == NULL) {
            err = ""Unbalanced quotes in configuration line"";
            goto loaderr;
        }

        /* Skip this line if the resulting command vector is empty. */
        if (argc == 0) ...",1,34,config.c,loadServerConfigFromString,,false,447,645,loadServerConfigFromString,,,67,void loadServerConfigFromString (char*)
69259,METHOD,config.c:<global>,TYPE_DECL,"void loadServerConfig(char *filename, char config_from_stdin, char *options) {
    sds config = sdsempty();
    char buf[CONFIG_READ_LEN+1];
    FILE *fp;
    glob_t globbuf;

    /* Load the file content */
    if (filename) {

        /* The logic for handling wildcards has slightly different behavior in cases where
         * there is a failure to locate the included file.
         * Whether or not a wildcard is specified, we should ALWAYS log errors when attempting
         * to open included config files.
         *
         * However, we desire a behavioral difference between instances where a wildcard was
         * specified and those where it hasn't:
         *      no wildcards   : attempt to open the specified file and fail with a logged error
         *                       if the file cannot be found and opened.
         *      with wildcards : attempt to glob the specified pattern; if no files match the
         *                       pattern, then gracefully continu...",1,13,config.c,loadServerConfig,,false,655,726,loadServerConfig,,,68,"void loadServerConfig (char*,char,char*)"
69483,METHOD,config.c:<global>,TYPE_DECL,"static int performInterfaceSet(standardConfig *config, sds value, const char **errstr) {
    sds *argv;
    int argc, res;

    if (config->flags & MULTI_ARG_CONFIG) {
        argv = sdssplitlen(value, sdslen(value), "" "", 1, &argc);
    } else {
        argv = (char**)&value;
        argc = 1;
    }

    /* Set the config */
    res = config->interface.set(config, argv, argc, errstr);
    if (config->flags & MULTI_ARG_CONFIG) sdsfreesplitres(argv, argc);
    return res;
}",1,24,config.c,performInterfaceSet,,false,728,743,performInterfaceSet,,,69,"int performInterfaceSet (standardConfig*,sds,char**)"
69553,METHOD,config.c:<global>,TYPE_DECL,"int performModuleConfigSetFromName(sds name, sds value, const char **err) {
    standardConfig *config = lookupConfig(name);
    if (!config || !(config->flags & MODULE_CONFIG)) {
        *err = ""Config name not found"";
        return 0;
    }
    return performInterfaceSet(config, value, err);
}",1,37,config.c,performModuleConfigSetFromName,,false,746,753,performModuleConfigSetFromName,,,70,"int performModuleConfigSetFromName (sds,sds,char**)"
69591,METHOD,config.c:<global>,TYPE_DECL,"int performModuleConfigSetDefaultFromName(sds name, const char **err) {
    standardConfig *config = lookupConfig(name);
    serverAssert(config);
    if (!(config->flags & MODULE_CONFIG)) {
        *err = ""Config name not found"";
        return 0;
    }
    switch (config->type) {
        case BOOL_CONFIG:
            return setModuleBoolConfig(config->privdata, config->data.yesno.default_value, err);
        case SDS_CONFIG:
            return setModuleStringConfig(config->privdata, config->data.sds.default_value, err);
        case NUMERIC_CONFIG:
            return setModuleNumericConfig(config->privdata, config->data.numeric.default_value, err);
        case ENUM_CONFIG:
            return setModuleEnumConfig(config->privdata, config->data.enumd.default_value, err);
        default:
            serverPanic(""Config type of module config is not allowed."");
    }
    return 0;
}",1,4,config.c,performModuleConfigSetDefaultFromName,,false,756,776,performModuleConfigSetDefaultFromName,,,71,"int performModuleConfigSetDefaultFromName (sds,char**)"
69711,METHOD,config.c:<global>,TYPE_DECL,"static void restoreBackupConfig(standardConfig **set_configs, sds *old_values, int count, apply_fn *apply_fns, list *module_configs) {
    int i;
    const char *errstr = ""unknown error"";
    /* Set all backup values */
    for (i = 0; i < count; i++) {
        if (!performInterfaceSet(set_configs[i], old_values[i], &errstr))
            serverLog(LL_WARNING, ""Failed restoring failed CONFIG SET command. Error setting %s to '%s': %s"",
                      set_configs[i]->name, old_values[i], errstr);
    }
    /* Apply backup */
    if (apply_fns) {
        for (i = 0; i < count && apply_fns[i] != NULL; i++) {
            if (!apply_fns[i](&errstr))
                serverLog(LL_WARNING, ""Failed applying restored failed CONFIG SET command: %s"", errstr);
        }
    }
    if (module_configs) {
        if (!moduleConfigApplyConfig(module_configs, &errstr, NULL))
            serverLog(LL_WARNING, ""Failed applying restored failed CONFIG SET command: %s"", errstr);
    }
}",1,12,config.c,restoreBackupConfig,,false,778,798,restoreBackupConfig,,,72,"void restoreBackupConfig (standardConfig**,sds*,int,apply_fn*,list*)"
69853,METHOD,config.c:<global>,TYPE_DECL,"void configSetCommand(client *c) {
    const char *errstr = NULL;
    const char *invalid_arg_name = NULL;
    const char *err_arg_name = NULL;
    standardConfig **set_configs; /* TODO: make this a dict for better performance */
    list *module_configs_apply;
    const char **config_names;
    sds *new_values;
    sds *old_values = NULL;
    apply_fn *apply_fns; /* TODO: make this a set for better performance */
    int config_count, i, j;
    int invalid_args = 0, deny_loading_error = 0;
    int *config_map_fns;

    /* Make sure we have an even number of arguments: conf-val pairs */
    if (c->argc & 1) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    config_count = (c->argc - 2) / 2;

    module_configs_apply = listCreate();
    set_configs = zcalloc(sizeof(standardConfig*)*config_count);
    config_names = zcalloc(sizeof(char*)*config_count);
    new_values = zmalloc(sizeof(sds*)*config_count);
    old_values = zcalloc(sizeof(sds*)*config_count);
 ...",1,28,config.c,configSetCommand,,false,804,964,configSetCommand,,,73,void configSetCommand (client*)
70527,METHOD,config.c:<global>,TYPE_DECL,"void configGetCommand(client *c) {
    int i;
    dictEntry *de;
    dictIterator *di;
    /* Create a dictionary to store the matched configs */
    dict *matches = dictCreate(&externalStringType);
    for (i = 0; i < c->argc - 2; i++) {
        robj *o = c->argv[2+i];
        sds name = o->ptr;

        /* If the string doesn't contain glob patterns, just directly
         * look up the key in the dictionary. */
        if (!strpbrk(name, ""[*?"")) {
            if (dictFind(matches, name)) continue;
            standardConfig *config = lookupConfig(name);

            if (config) {
                dictAdd(matches, name, config);
            }
            continue;
        }

        /* Otherwise, do a match against all items in the dictionary. */
        di = dictGetIterator(configs);
        
        while ((de = dictNext(di)) != NULL) {
            standardConfig *config = dictGetVal(de);
            /* Note that hidden configs require an exact match (not a pattern) */
          ...",1,32,config.c,configGetCommand,,false,970,1016,configGetCommand,,,74,void configGetCommand (client*)
70700,METHOD,config.c:<global>,TYPE_DECL,"void dictListDestructor(dict *d, void *val);",6,43,config.c,dictListDestructor,,false,1027,1027,dictListDestructor,,,75,"void dictListDestructor (dict*,void*)"
70706,METHOD,config.c:<global>,TYPE_DECL,void rewriteConfigSentinelOption(struct rewriteConfigState *state);,6,66,config.c,rewriteConfigSentinelOption,,false,1031,1031,rewriteConfigSentinelOption,,,76,void rewriteConfigSentinelOption (rewriteConfigState*)
70740,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigReleaseState(struct rewriteConfigState *state) {
    sdsfreesplitres(state->lines,state->numlines);
    dictRelease(state->option_to_line);
    dictRelease(state->rewritten);
    zfree(state);
}",1,1,config.c,rewriteConfigReleaseState,,false,1067,1072,rewriteConfigReleaseState,,,82,void rewriteConfigReleaseState (rewriteConfigState*)
70762,METHOD,config.c:<global>,TYPE_DECL,"struct rewriteConfigState *rewriteConfigCreateState(void) {
    struct rewriteConfigState *state = zmalloc(sizeof(*state));
    state->option_to_line = dictCreate(&optionToLineDictType);
    state->rewritten = dictCreate(&optionSetDictType);
    state->numlines = 0;
    state->lines = NULL;
    state->needs_signature = 1;
    state->force_write = 0;
    return state;
}",1,1,config.c,rewriteConfigCreateState,,false,1075,1084,rewriteConfigCreateState,,,83,struct rewriteConfigState rewriteConfigCreateState (void)
70810,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {
    state->lines = zrealloc(state->lines, sizeof(char*) * (state->numlines+1));
    state->lines[state->numlines++] = line;
}",1,1,config.c,rewriteConfigAppendLine,,false,1087,1090,rewriteConfigAppendLine,,,84,"void rewriteConfigAppendLine (rewriteConfigState*,sds)"
70842,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {
    list *l = dictFetchValue(state->option_to_line,option);

    if (l == NULL) {
        l = listCreate();
        dictAdd(state->option_to_line,sdsdup(option),l);
    }
    listAddNodeTail(l,(void*)(long)linenum);
}",1,1,config.c,rewriteConfigAddLineNumberToOption,,false,1093,1101,rewriteConfigAddLineNumberToOption,,,85,"void rewriteConfigAddLineNumberToOption (rewriteConfigState*,sds,int)"
70879,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option) {
    sds opt = sdsnew(option);

    if (dictAdd(state->rewritten,opt,NULL) != DICT_OK) sdsfree(opt);
}",1,46,config.c,rewriteConfigMarkAsProcessed,,false,1107,1111,rewriteConfigMarkAsProcessed,,,86,"void rewriteConfigMarkAsProcessed (rewriteConfigState*,char*)"
70904,METHOD,config.c:<global>,TYPE_DECL,"struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {
    FILE *fp = fopen(path,""r"");
    if (fp == NULL && errno != ENOENT) return NULL;

    struct redis_stat sb;
    if (fp && redis_fstat(fileno(fp),&sb) == -1) return NULL;

    int linenum = -1;
    struct rewriteConfigState *state = rewriteConfigCreateState();

    if (fp == NULL || sb.st_size == 0) return state;

    /* Load the file content */
    sds config = sdsnewlen(SDS_NOINIT,sb.st_size);
    if (fread(config,1,sb.st_size,fp) == 0) {
        sdsfree(config);
        rewriteConfigReleaseState(state);
        fclose(fp);
        return NULL;
    }

    int i, totlines;
    sds *lines = sdssplitlen(config,sdslen(config),""\n"",1,&totlines);

    /* Read the old content line by line, populate the state. */
    for (i = 0; i < totlines; i++) {
        int argc;
        sds *argv;
        sds line = sdstrim(lines[i],""\r\n\t "");
        lines[i] = NULL;

        linenum++; /* Zero based, so we init at -1 */

        /...",1,11,config.c,rewriteConfigReadOldFile,,false,1118,1213,rewriteConfigReadOldFile,,,87,struct rewriteConfigState rewriteConfigReadOldFile (char*)
71232,METHOD,config.c:<global>,TYPE_DECL,"int rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force) {
    sds o = sdsnew(option);
    list *l = dictFetchValue(state->option_to_line,o);

    rewriteConfigMarkAsProcessed(state,option);

    if (!l && !force && !state->force_write) {
        /* Option not used previously, and we are not forced to use it. */
        sdsfree(line);
        sdsfree(o);
        return 0;
    }

    if (l) {
        listNode *ln = listFirst(l);
        int linenum = (long) ln->value;

        /* There are still lines in the old configuration file we can reuse
         * for this option. Replace the line with the new one. */
        listDelNode(l,ln);
        if (listLength(l) == 0) dictDelete(state->option_to_line,o);
        sdsfree(state->lines[linenum]);
        state->lines[linenum] = line;
    } else {
        /* Append a new line. */
        if (state->needs_signature) {
            rewriteConfigAppendLine(state,
                sdsnew(REDIS_CONFI...",1,23,config.c,rewriteConfigRewriteLine,,false,1231,1265,rewriteConfigRewriteLine,,,88,"int rewriteConfigRewriteLine (rewriteConfigState*,char*,sds,int)"
71350,METHOD,config.c:<global>,TYPE_DECL,"int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {
    int gb = 1024*1024*1024;
    int mb = 1024*1024;
    int kb = 1024;

    if (bytes && (bytes % gb) == 0) {
        return snprintf(buf,len,""%lldgb"",bytes/gb);
    } else if (bytes && (bytes % mb) == 0) {
        return snprintf(buf,len,""%lldmb"",bytes/mb);
    } else if (bytes && (bytes % kb) == 0) {
        return snprintf(buf,len,""%lldkb"",bytes/kb);
    } else {
        return snprintf(buf,len,""%lld"",bytes);
    }
}",1,1,config.c,rewriteConfigFormatMemory,,false,1269,1283,rewriteConfigFormatMemory,,,89,"int rewriteConfigFormatMemory (char*,size_t,long long)"
71438,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigBytesOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    char buf[64];
    int force = value != defvalue;
    sds line;

    rewriteConfigFormatMemory(buf,sizeof(buf),value);
    line = sdscatprintf(sdsempty(),""%s %s"",option,buf);
    rewriteConfigRewriteLine(state,option,line,force);
}",1,1,config.c,rewriteConfigBytesOption,,false,1286,1294,rewriteConfigBytesOption,,,90,"void rewriteConfigBytesOption (rewriteConfigState*,char*,long long,long long)"
71471,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigPercentOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %lld%%"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1,1,config.c,rewriteConfigPercentOption,,false,1297,1302,rewriteConfigPercentOption,,,91,"void rewriteConfigPercentOption (rewriteConfigState*,char*,long long,long long)"
71498,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigYesNoOption(struct rewriteConfigState *state, const char *option, int value, int defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %s"",option,
        value ? ""yes"" : ""no"");

    rewriteConfigRewriteLine(state,option,line,force);
}",1,1,config.c,rewriteConfigYesNoOption,,false,1305,1311,rewriteConfigYesNoOption,,,92,"void rewriteConfigYesNoOption (rewriteConfigState*,char*,int,int)"
71528,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigStringOption(struct rewriteConfigState *state, const char *option, char *value, const char *defvalue) {
    int force = 1;
    sds line;

    /* String options set to NULL need to be not present at all in the
     * configuration file to be set to NULL again at the next reboot. */
    if (value == NULL) {
        rewriteConfigMarkAsProcessed(state,option);
        return;
    }

    /* Set force to zero if the value is set to its default. */
    if (defvalue && strcmp(value,defvalue) == 0) force = 0;

    line = sdsnew(option);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, value, strlen(value));

    rewriteConfigRewriteLine(state,option,line,force);
}",1,1,config.c,rewriteConfigStringOption,,false,1314,1333,rewriteConfigStringOption,,,93,"void rewriteConfigStringOption (rewriteConfigState*,char*,char*,char*)"
71584,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigSdsOption(struct rewriteConfigState *state, const char *option, sds value, const char *defvalue) {
    int force = 1;
    sds line;

    /* If there is no value set, we don't want the SDS option
     * to be present in the configuration at all. */
    if (value == NULL) {
        rewriteConfigMarkAsProcessed(state, option);
        return;
    }

    /* Set force to zero if the value is set to its default. */
    if (defvalue && strcmp(value, defvalue) == 0) force = 0;

    line = sdsnew(option);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, value, sdslen(value));

    rewriteConfigRewriteLine(state, option, line, force);
}",1,1,config.c,rewriteConfigSdsOption,,false,1336,1355,rewriteConfigSdsOption,,,94,"void rewriteConfigSdsOption (rewriteConfigState*,char*,sds,char*)"
71640,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigNumericalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %lld"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1,1,config.c,rewriteConfigNumericalOption,,false,1358,1363,rewriteConfigNumericalOption,,,95,"void rewriteConfigNumericalOption (rewriteConfigState*,char*,long long,long long)"
71667,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigOctalOption(struct rewriteConfigState *state, const char *option, long long value, long long defvalue) {
    int force = value != defvalue;
    sds line = sdscatprintf(sdsempty(),""%s %llo"",option,value);

    rewriteConfigRewriteLine(state,option,line,force);
}",1,1,config.c,rewriteConfigOctalOption,,false,1366,1371,rewriteConfigOctalOption,,,96,"void rewriteConfigOctalOption (rewriteConfigState*,char*,long long,long long)"
71694,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigEnumOption(struct rewriteConfigState *state, const char *option, int value, standardConfig *config) {
    int multiarg = config->flags & MULTI_ARG_CONFIG;
    sds names = configEnumGetName(config->data.enumd.enum_value,value,multiarg);
    sds line = sdscatfmt(sdsempty(),""%s %s"",option,names);
    sdsfree(names);
    int force = value != config->data.enumd.default_value;

    rewriteConfigRewriteLine(state,option,line,force);
}",1,35,config.c,rewriteConfigEnumOption,,false,1376,1384,rewriteConfigEnumOption,,,97,"void rewriteConfigEnumOption (rewriteConfigState*,char*,int,standardConfig*)"
71754,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigSaveOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int j;
    sds line;

    /* In Sentinel mode we don't need to rewrite the save parameters */
    if (server.sentinel_mode) {
        rewriteConfigMarkAsProcessed(state,name);
        return;
    }

    /* Rewrite save parameters, or an empty 'save """"' line to avoid the
     * defaults from being used.
     */
    if (!server.saveparamslen) {
        rewriteConfigRewriteLine(state,name,sdsnew(""save \""\""""),1);
    } else {
        for (j = 0; j < server.saveparamslen; j++) {
            line = sdscatprintf(sdsempty(),""save %ld %d"",
                (long) server.saveparams[j].seconds, server.saveparams[j].changes);
            rewriteConfigRewriteLine(state,name,line,1);
        }
    }

    /* Mark ""save"" as processed in case server.saveparamslen is zero. */
    rewriteConfigMarkAsProcessed(state,name);
}",1,4,config.c,rewriteConfigSaveOption,,false,1387,1413,rewriteConfigSaveOption,,,98,"void rewriteConfigSaveOption (standardConfig*,char*,rewriteConfigState*)"
71834,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigUserOption(struct rewriteConfigState *state) {
    /* If there is a user file defined we just mark this configuration
     * directive as processed, so that all the lines containing users
     * inside the config file gets discarded. */
    if (server.acl_filename[0] != '\0') {
        rewriteConfigMarkAsProcessed(state,""user"");
        return;
    }

    /* Otherwise scan the list of users and rewrite every line. Note that
     * in case the list here is empty, the effect will just be to comment
     * all the users directive inside the config file. */
    raxIterator ri;
    raxStart(&ri,Users);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        user *u = ri.data;
        sds line = sdsnew(""user "");
        line = sdscatsds(line,u->name);
        line = sdscatlen(line,"" "",1);
        robj *descr = ACLDescribeUser(u);
        line = sdscatsds(line,descr->ptr);
        decrRefCount(descr);
        rewriteConfigRewriteLine(state,""user"",line,1);
    }
   ...",1,1,config.c,rewriteConfigUserOption,,false,1416,1445,rewriteConfigUserOption,,,99,void rewriteConfigUserOption (rewriteConfigState*)
71917,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigDirOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    char cwd[1024];

    if (getcwd(cwd,sizeof(cwd)) == NULL) {
        rewriteConfigMarkAsProcessed(state,name);
        return; /* no rewrite on error. */
    }
    rewriteConfigStringOption(state,name,cwd,NULL);
}",1,4,config.c,rewriteConfigDirOption,,false,1448,1457,rewriteConfigDirOption,,,100,"void rewriteConfigDirOption (standardConfig*,char*,rewriteConfigState*)"
71948,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigReplicaOfOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    sds line;

    /* If this is a master, we want all the slaveof config options
     * in the file to be removed. Note that if this is a cluster instance
     * we don't want a slaveof directive inside redis.conf. */
    if (server.cluster_enabled || server.masterhost == NULL) {
        rewriteConfigMarkAsProcessed(state, name);
        return;
    }
    line = sdscatprintf(sdsempty(),""%s %s %d"", name,
        server.masterhost, server.masterport);
    rewriteConfigRewriteLine(state,name,line,1);
}",1,4,config.c,rewriteConfigReplicaOfOption,,false,1460,1474,rewriteConfigReplicaOfOption,,,101,"void rewriteConfigReplicaOfOption (standardConfig*,char*,rewriteConfigState*)"
71994,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigNotifyKeyspaceEventsOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = server.notify_keyspace_events != 0;
    sds line, flags;

    flags = keyspaceEventsFlagsToString(server.notify_keyspace_events);
    line = sdsnew(name);
    line = sdscatlen(line, "" "", 1);
    line = sdscatrepr(line, flags, sdslen(flags));
    sdsfree(flags);
    rewriteConfigRewriteLine(state,name,line,force);
}",1,4,config.c,rewriteConfigNotifyKeyspaceEventsOption,,false,1477,1488,rewriteConfigNotifyKeyspaceEventsOption,,,102,"void rewriteConfigNotifyKeyspaceEventsOption (standardConfig*,char*,rewriteConfigState*)"
72047,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigClientOutputBufferLimitOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int j;
    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
        int force = (server.client_obuf_limits[j].hard_limit_bytes !=
                    clientBufferLimitsDefaults[j].hard_limit_bytes) ||
                    (server.client_obuf_limits[j].soft_limit_bytes !=
                    clientBufferLimitsDefaults[j].soft_limit_bytes) ||
                    (server.client_obuf_limits[j].soft_limit_seconds !=
                    clientBufferLimitsDefaults[j].soft_limit_seconds);
        sds line;
        char hard[64], soft[64];

        rewriteConfigFormatMemory(hard,sizeof(hard),
                server.client_obuf_limits[j].hard_limit_bytes);
        rewriteConfigFormatMemory(soft,sizeof(soft),
                server.client_obuf_limits[j].soft_limit_bytes);

        char *typename = getClientTypeName(j);
        if (!strcmp(typename,""...",1,4,config.c,rewriteConfigClientOutputBufferLimitOption,,false,1491,1516,rewriteConfigClientOutputBufferLimitOption,,,103,"void rewriteConfigClientOutputBufferLimitOption (standardConfig*,char*,rewriteConfigState*)"
72180,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigOOMScoreAdjValuesOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = 0;
    int j;
    sds line;

    line = sdsnew(name);
    line = sdscatlen(line, "" "", 1);
    for (j = 0; j < CONFIG_OOM_COUNT; j++) {
        if (server.oom_score_adj_values[j] != configOOMScoreAdjValuesDefaults[j])
            force = 1;

        line = sdscatprintf(line, ""%d"", server.oom_score_adj_values[j]);
        if (j+1 != CONFIG_OOM_COUNT)
            line = sdscatlen(line, "" "", 1);
    }
    rewriteConfigRewriteLine(state,name,line,force);
}",1,4,config.c,rewriteConfigOOMScoreAdjValuesOption,,false,1519,1536,rewriteConfigOOMScoreAdjValuesOption,,,104,"void rewriteConfigOOMScoreAdjValuesOption (standardConfig*,char*,rewriteConfigState*)"
72266,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigBindOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    int force = 1;
    sds line, addresses;
    int is_default = 0;

    /* Compare server.bindaddr with CONFIG_DEFAULT_BINDADDR */
    if (server.bindaddr_count == CONFIG_DEFAULT_BINDADDR_COUNT) {
        is_default = 1;
        char *default_bindaddr[CONFIG_DEFAULT_BINDADDR_COUNT] = CONFIG_DEFAULT_BINDADDR;
        for (int j = 0; j < CONFIG_DEFAULT_BINDADDR_COUNT; j++) {
            if (strcmp(server.bindaddr[j], default_bindaddr[j]) != 0) {
                is_default = 0;
                break;
            }
        }
    }

    if (is_default) {
        rewriteConfigMarkAsProcessed(state,name);
        return;
    }

    /* Rewrite as bind <addr1> <addr2> ... <addrN> */
    if (server.bindaddr_count > 0)
        addresses = sdsjoin(server.bindaddr,server.bindaddr_count,"" "");
    else
        addresses = sdsnew(""\""\"""");
    line = sdsnew(name);
    line ...",1,4,config.c,rewriteConfigBindOption,,false,1539,1573,rewriteConfigBindOption,,,105,"void rewriteConfigBindOption (standardConfig*,char*,rewriteConfigState*)"
72390,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigLoadmoduleOption(struct rewriteConfigState *state) {
    sds line;

    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        line = sdsnew(""loadmodule "");
        line = sdscatsds(line, module->loadmod->path);
        for (int i = 0; i < module->loadmod->argc; i++) {
            line = sdscatlen(line, "" "", 1);
            line = sdscatsds(line, module->loadmod->argv[i]->ptr);
        }
        rewriteConfigRewriteLine(state,""loadmodule"",line,1);
    }
    dictReleaseIterator(di);
    /* Mark ""loadmodule"" as processed in case modules is empty. */
    rewriteConfigMarkAsProcessed(state,""loadmodule"");
}",1,1,config.c,rewriteConfigLoadmoduleOption,,false,1576,1594,rewriteConfigLoadmoduleOption,,,106,void rewriteConfigLoadmoduleOption (rewriteConfigState*)
72473,METHOD,config.c:<global>,TYPE_DECL,"sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {
    sds content = sdsempty();
    int j, was_empty = 0;

    for (j = 0; j < state->numlines; j++) {
        /* Every cluster of empty lines is turned into a single empty line. */
        if (sdslen(state->lines[j]) == 0) {
            if (was_empty) continue;
            was_empty = 1;
        } else {
            was_empty = 0;
        }
        content = sdscatsds(content,state->lines[j]);
        content = sdscatlen(content,""\n"",1);
    }
    return content;
}",1,1,config.c,rewriteConfigGetContentFromState,,false,1598,1614,rewriteConfigGetContentFromState,,,107,sds rewriteConfigGetContentFromState (rewriteConfigState*)
72539,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {
    dictIterator *di = dictGetIterator(state->option_to_line);
    dictEntry *de;

    while((de = dictNext(di)) != NULL) {
        list *l = dictGetVal(de);
        sds option = dictGetKey(de);

        /* Don't blank lines about options the rewrite process
         * don't understand. */
        if (dictFind(state->rewritten,option) == NULL) {
            serverLog(LL_DEBUG,""Not rewritten option: %s"", option);
            continue;
        }

        while(listLength(l)) {
            listNode *ln = listFirst(l);
            int linenum = (long) ln->value;

            sdsfree(state->lines[linenum]);
            state->lines[linenum] = sdsempty();
            listDelNode(l,ln);
        }
    }
    dictReleaseIterator(di);
}",1,12,config.c,rewriteConfigRemoveOrphaned,,false,1624,1649,rewriteConfigRemoveOrphaned,,,108,void rewriteConfigRemoveOrphaned (rewriteConfigState*)
72642,METHOD,config.c:<global>,TYPE_DECL,"sds getConfigDebugInfo(void) {
    struct rewriteConfigState *state = rewriteConfigCreateState();
    state->force_write = 1; /* Force the output */
    state->needs_signature = 0; /* Omit the rewrite signature */

    /* Iterate the configs and ""rewrite"" the ones that have 
     * the debug flag. */
    dictIterator *di = dictGetIterator(configs);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        standardConfig *config = dictGetVal(de);
        if (!(config->flags & DEBUG_CONFIG)) continue;
        config->interface.rewrite(config, config->name, state);
    }
    dictReleaseIterator(di);
    sds info = rewriteConfigGetContentFromState(state);
    rewriteConfigReleaseState(state);
    return info;
}",1,30,config.c,getConfigDebugInfo,,false,1653,1671,getConfigDebugInfo,,,109,sds getConfigDebugInfo (void)
72715,METHOD,config.c:<global>,TYPE_DECL,"int rewriteConfigOverwriteFile(char *configfile, sds content) {
    int fd = -1;
    int retval = -1;
    char tmp_conffile[PATH_MAX];
    const char *tmp_suffix = "".XXXXXX"";
    size_t offset = 0;
    ssize_t written_bytes = 0;
    int old_errno;

    int tmp_path_len = snprintf(tmp_conffile, sizeof(tmp_conffile), ""%s%s"", configfile, tmp_suffix);
    if (tmp_path_len <= 0 || (unsigned int)tmp_path_len >= sizeof(tmp_conffile)) {
        serverLog(LL_WARNING, ""Config file full path is too long"");
        errno = ENAMETOOLONG;
        return retval;
    }

#if defined(_GNU_SOURCE) && !defined(__HAIKU__)
    fd = mkostemp(tmp_conffile, O_CLOEXEC);
#else
    /* There's a theoretical chance here to leak the FD if a module thread forks & execv in the middle */
    fd = mkstemp(tmp_conffile);
#endif

    if (fd == -1) {
        serverLog(LL_WARNING, ""Could not create tmp config file (%s)"", strerror(errno));
        return retval;
    }

    while (offset < sdslen(content)) {
         writt...",1,8,config.c,rewriteConfigOverwriteFile,,false,1678,1735,rewriteConfigOverwriteFile,,,110,"int rewriteConfigOverwriteFile (char*,sds)"
73033,METHOD,config.c:<global>,TYPE_DECL,"int rewriteConfig(char *path, int force_write) {
    struct rewriteConfigState *state;
    sds newcontent;
    int retval;

    /* Step 1: read the old config into our rewrite state. */
    if ((state = rewriteConfigReadOldFile(path)) == NULL) return -1;
    if (force_write) state->force_write = 1;

    /* Step 2: rewrite every single option, replacing or appending it inside
     * the rewrite state. */

    /* Iterate the configs that are standard */
    dictIterator *di = dictGetIterator(configs);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        standardConfig *config = dictGetVal(de);
        /* Only rewrite the primary names */
        if (config->flags & ALIAS_CONFIG) continue;
        if (config->interface.rewrite) config->interface.rewrite(config, dictGetKey(de), state);
    }
    dictReleaseIterator(di);

    rewriteConfigUserOption(state);
    rewriteConfigLoadmoduleOption(state);

    /* Rewrite Sentinel config if in Sentinel mode. */
    if (server.sen...",1,28,config.c,rewriteConfig,,false,1747,1789,rewriteConfig,,,111,"int rewriteConfig (char*,int)"
73146,METHOD,config.c:<global>,TYPE_DECL,"static void boolConfigInit(standardConfig *config) {
    *config->data.yesno.config = config->data.yesno.default_value;
}",1,1,config.c,boolConfigInit,,false,1823,1825,boolConfigInit,,,114,void boolConfigInit (standardConfig*)
73167,METHOD,config.c:<global>,TYPE_DECL,"static int boolConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    int yn = yesnotoi(argv[0]);
    if (yn == -1) {
        *err = ""argument must be 'yes' or 'no'"";
        return 0;
    }
    if (config->data.yesno.is_valid_fn && !config->data.yesno.is_valid_fn(yn, err))
        return 0;
    int prev = config->flags & MODULE_CONFIG ? getModuleBoolConfig(config->privdata) : *(config->data.yesno.config);
    if (prev != yn) {
        if (config->flags & MODULE_CONFIG) {
            return setModuleBoolConfig(config->privdata, yn, err);
        }
        *(config->data.yesno.config) = yn;
        return 1;
    }
    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1,4,config.c,boolConfigSet,,false,1827,1845,boolConfigSet,,,115,"int boolConfigSet (standardConfig*,sds*,int,char**)"
73296,METHOD,config.c:<global>,TYPE_DECL,"static sds boolConfigGet(standardConfig *config) {
    if (config->flags & MODULE_CONFIG) {
        return sdsnew(getModuleBoolConfig(config->privdata) ? ""yes"" : ""no"");
    }
    return sdsnew(*config->data.yesno.config ? ""yes"" : ""no"");
}",1,24,config.c,boolConfigGet,,false,1847,1852,boolConfigGet,,,116,sds boolConfigGet (standardConfig*)
73334,METHOD,config.c:<global>,TYPE_DECL,"static void boolConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    int val = config->flags & MODULE_CONFIG ? getModuleBoolConfig(config->privdata) : *(config->data.yesno.config);
    rewriteConfigYesNoOption(state, name, val, config->data.yesno.default_value);
}",1,30,config.c,boolConfigRewrite,,false,1854,1857,boolConfigRewrite,,,117,"void boolConfigRewrite (standardConfig*,char*,rewriteConfigState*)"
73377,METHOD,config.c:<global>,TYPE_DECL,"static void stringConfigInit(standardConfig *config) {
    *config->data.string.config = (config->data.string.convert_empty_to_null && !config->data.string.default_value) ? NULL : zstrdup(config->data.string.default_value);
}",1,1,config.c,stringConfigInit,,false,1871,1873,stringConfigInit,,,118,void stringConfigInit (standardConfig*)
73417,METHOD,config.c:<global>,TYPE_DECL,"static int stringConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    if (config->data.string.is_valid_fn && !config->data.string.is_valid_fn(argv[0], err))
        return 0;
    char *prev = *config->data.string.config;
    char *new = (config->data.string.convert_empty_to_null && !argv[0][0]) ? NULL : argv[0];
    if (new != prev && (new == NULL || prev == NULL || strcmp(prev, new))) {
        *config->data.string.config = new != NULL ? zstrdup(new) : NULL;
        zfree(prev);
        return 1;
    }
    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1,4,config.c,stringConfigSet,,false,1875,1887,stringConfigSet,,,119,"int stringConfigSet (standardConfig*,sds*,int,char**)"
73539,METHOD,config.c:<global>,TYPE_DECL,"static sds stringConfigGet(standardConfig *config) {
    return sdsnew(*config->data.string.config ? *config->data.string.config : """");
}",1,1,config.c,stringConfigGet,,false,1889,1891,stringConfigGet,,,120,sds stringConfigGet (standardConfig*)
73564,METHOD,config.c:<global>,TYPE_DECL,"static void stringConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    rewriteConfigStringOption(state, name,*(config->data.string.config), config->data.string.default_value);
}",1,1,config.c,stringConfigRewrite,,false,1893,1895,stringConfigRewrite,,,121,"void stringConfigRewrite (standardConfig*,char*,rewriteConfigState*)"
73589,METHOD,config.c:<global>,TYPE_DECL,"static void sdsConfigInit(standardConfig *config) {
    *config->data.sds.config = (config->data.sds.convert_empty_to_null && !config->data.sds.default_value) ? NULL : sdsnew(config->data.sds.default_value);
}",1,1,config.c,sdsConfigInit,,false,1898,1900,sdsConfigInit,,,122,void sdsConfigInit (standardConfig*)
73629,METHOD,config.c:<global>,TYPE_DECL,"static int sdsConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    if (config->data.sds.is_valid_fn && !config->data.sds.is_valid_fn(argv[0], err))
        return 0;

    sds prev = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    sds new = (config->data.string.convert_empty_to_null && (sdslen(argv[0]) == 0)) ? NULL : argv[0];

    /* if prev and new configuration are not equal, set the new one */
    if (new != prev && (new == NULL || prev == NULL || sdscmp(prev, new))) {
        /* If MODULE_CONFIG flag is set, then free temporary prev getModuleStringConfig returned.
         * Otherwise, free the actual previous config value Redis held (Same action, different reasons) */
        sdsfree(prev);

        if (config->flags & MODULE_CONFIG) {
            return setModuleStringConfig(config->privdata, new, err);
        }
        *config->data.sds.config = new != NULL ? sdsdup(new) : NUL...",1,4,config.c,sdsConfigSet,,false,1902,1924,sdsConfigSet,,,123,"int sdsConfigSet (standardConfig*,sds*,int,char**)"
73798,METHOD,config.c:<global>,TYPE_DECL,"static sds sdsConfigGet(standardConfig *config) {
    sds val = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    if (val) {
        if (config->flags & MODULE_CONFIG) return val;
        return sdsdup(val);
    } else {
        return sdsnew("""");
    }
}",1,30,config.c,sdsConfigGet,,false,1926,1934,sdsConfigGet,,,124,sds sdsConfigGet (standardConfig*)
73852,METHOD,config.c:<global>,TYPE_DECL,"static void sdsConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    sds val = config->flags & MODULE_CONFIG ? getModuleStringConfig(config->privdata) : *config->data.sds.config;
    rewriteConfigSdsOption(state, name, val, config->data.sds.default_value);
    if ((val) && (config->flags & MODULE_CONFIG)) sdsfree(val);
}",1,30,config.c,sdsConfigRewrite,,false,1936,1940,sdsConfigRewrite,,,125,"void sdsConfigRewrite (standardConfig*,char*,rewriteConfigState*)"
73910,METHOD,config.c:<global>,TYPE_DECL,"static void enumConfigInit(standardConfig *config) {
    *config->data.enumd.config = config->data.enumd.default_value;
}",1,1,config.c,enumConfigInit,,false,1971,1973,enumConfigInit,,,126,void enumConfigInit (standardConfig*)
73931,METHOD,config.c:<global>,TYPE_DECL,"static int enumConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    int enumval;
    int bitflags = !!(config->flags & MULTI_ARG_CONFIG);
    enumval = configEnumGetValue(config->data.enumd.enum_value, argv, argc, bitflags);

    if (enumval == INT_MIN) {
        sds enumerr = sdsnew(""argument(s) must be one of the following: "");
        configEnum *enumNode = config->data.enumd.enum_value;
        while(enumNode->name != NULL) {
            enumerr = sdscatlen(enumerr, enumNode->name,
                                strlen(enumNode->name));
            enumerr = sdscatlen(enumerr, "", "", 2);
            enumNode++;
        }
        sdsrange(enumerr,0,-3); /* Remove final "", "". */

        redis_strlcpy(loadbuf, enumerr, LOADBUF_SIZE);

        sdsfree(enumerr);
        *err = loadbuf;
        return 0;
    }
    if (config->data.enumd.is_valid_fn && !config->data.enumd.is_valid_fn(enumval, err))
        return 0;
    int prev = config->flags & MODULE_CONFI...",1,38,config.c,enumConfigSet,,false,1975,2007,enumConfigSet,,,127,"int enumConfigSet (standardConfig*,sds*,int,char**)"
74128,METHOD,config.c:<global>,TYPE_DECL,"static sds enumConfigGet(standardConfig *config) {
    int val = config->flags & MODULE_CONFIG ? getModuleEnumConfig(config->privdata) : *(config->data.enumd.config);
    int bitflags = !!(config->flags & MULTI_ARG_CONFIG);
    return configEnumGetName(config->data.enumd.enum_value,val,bitflags);
}",1,30,config.c,enumConfigGet,,false,2009,2013,enumConfigGet,,,128,sds enumConfigGet (standardConfig*)
74183,METHOD,config.c:<global>,TYPE_DECL,"static void enumConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    int val = config->flags & MODULE_CONFIG ? getModuleEnumConfig(config->privdata) : *(config->data.enumd.config);
    rewriteConfigEnumOption(state, name, val, config);
}",1,30,config.c,enumConfigRewrite,,false,2015,2018,enumConfigRewrite,,,129,"void enumConfigRewrite (standardConfig*,char*,rewriteConfigState*)"
74220,METHOD,config.c:<global>,TYPE_DECL,"int setNumericType(standardConfig *config, long long val, const char **err) {
    if (config->data.numeric.numeric_type == NUMERIC_TYPE_INT) {
        *(config->data.numeric.config.i) = (int) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_UINT) {
        *(config->data.numeric.config.ui) = (unsigned int) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_LONG) {
        *(config->data.numeric.config.l) = (long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG) {
        *(config->data.numeric.config.ul) = (unsigned long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_LONG_LONG) {
        if (config->flags & MODULE_CONFIG)
            return setModuleNumericConfig(config->privdata, val, err);
        else *(config->data.numeric.config.ll) = (long long) val;
    } else if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG) {
        *(config->data.numeric.config.ull) = (unsigned long...",1,28,config.c,setNumericType,,false,2034,2059,setNumericType,,,130,"int setNumericType (standardConfig*,long long,char**)"
74517,METHOD,config.c:<global>,TYPE_DECL,"static void numericConfigInit(standardConfig *config) {
    setNumericType(config, config->data.numeric.default_value, NULL);
}",1,1,config.c,numericConfigInit,,false,2088,2090,numericConfigInit,,,131,void numericConfigInit (standardConfig*)
74532,METHOD,config.c:<global>,TYPE_DECL,"static int numericBoundaryCheck(standardConfig *config, long long ll, const char **err) {
    if (config->data.numeric.numeric_type == NUMERIC_TYPE_ULONG_LONG ||
        config->data.numeric.numeric_type == NUMERIC_TYPE_UINT ||
        config->data.numeric.numeric_type == NUMERIC_TYPE_SIZE_T) {
        /* Boundary check for unsigned types */
        unsigned long long ull = ll;
        unsigned long long upper_bound = config->data.numeric.upper_bound;
        unsigned long long lower_bound = config->data.numeric.lower_bound;
        if (ull > upper_bound || ull < lower_bound) {
            if (config->data.numeric.flags & OCTAL_CONFIG) {
                snprintf(loadbuf, LOADBUF_SIZE,
                    ""argument must be between %llo and %llo inclusive"",
                    lower_bound,
                    upper_bound);
            } else {
                snprintf(loadbuf, LOADBUF_SIZE,
                    ""argument must be between %llu and %llu inclusive"",
                    low...",1,45,config.c,numericBoundaryCheck,,false,2092,2137,numericBoundaryCheck,,,132,"int numericBoundaryCheck (standardConfig*,long long,char**)"
74745,METHOD,config.c:<global>,TYPE_DECL,"static int numericParseString(standardConfig *config, sds value, const char **err, long long *res) {
    /* First try to parse as memory */
    if (config->data.numeric.flags & MEMORY_CONFIG) {
        int memerr;
        *res = memtoull(value, &memerr);
        if (!memerr)
            return 1;
    }

    /* Attempt to parse as percent */
    if (config->data.numeric.flags & PERCENT_CONFIG &&
        sdslen(value) > 1 && value[sdslen(value)-1] == '%' &&
        string2ll(value, sdslen(value)-1, res) &&
        *res >= 0) {
            /* We store percentage as negative value */
            *res = -*res;
            return 1;
    }

    /* Attempt to parse as an octal number */
    if (config->data.numeric.flags & OCTAL_CONFIG) {
        char *endptr;
        errno = 0;
        *res = strtoll(value, &endptr, 8);
        if (errno == 0 && *endptr == '\0')
            return 1; /* No overflow or invalid characters */
    }

    /* Attempt a simple number (no special flags set) */
   ...",1,37,config.c,numericParseString,,false,2139,2182,numericParseString,,,133,"int numericParseString (standardConfig*,sds,char**,long long*)"
74972,METHOD,config.c:<global>,TYPE_DECL,"static int numericConfigSet(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(argc);
    long long ll, prev = 0;

    if (!numericParseString(config, argv[0], err, &ll))
        return 0;

    if (!numericBoundaryCheck(config, ll, err))
        return 0;

    if (config->data.numeric.is_valid_fn && !config->data.numeric.is_valid_fn(ll, err))
        return 0;

    GET_NUMERIC_TYPE(prev)
    if (prev != ll) {
        return setNumericType(config, ll, err);
    }

    return (config->flags & VOLATILE_CONFIG) ? 1 : 2;
}",1,4,config.c,numericConfigSet,,false,2184,2203,numericConfigSet,,,134,"int numericConfigSet (standardConfig*,sds*,int,char**)"
75327,METHOD,config.c:<global>,TYPE_DECL,"static sds numericConfigGet(standardConfig *config) {
    char buf[128];

    long long value = 0;
    GET_NUMERIC_TYPE(value)

    if (config->data.numeric.flags & PERCENT_CONFIG && value < 0) {
        int len = ll2string(buf, sizeof(buf), -value);
        buf[len] = '%';
        buf[len+1] = '\0';
    }
    else if (config->data.numeric.flags & MEMORY_CONFIG) {
        ull2string(buf, sizeof(buf), value);
    } else if (config->data.numeric.flags & OCTAL_CONFIG) {
        snprintf(buf, sizeof(buf), ""%llo"", value);
    } else {
        ll2string(buf, sizeof(buf), value);
    }
    return sdsnew(buf);
}",1,4,config.c,numericConfigGet,,false,2205,2224,numericConfigGet,,,135,sds numericConfigGet (standardConfig*)
75700,METHOD,config.c:<global>,TYPE_DECL,"static void numericConfigRewrite(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    long long value = 0;

    GET_NUMERIC_TYPE(value)

    if (config->data.numeric.flags & PERCENT_CONFIG && value < 0) {
        rewriteConfigPercentOption(state, name, -value, config->data.numeric.default_value);
    } else if (config->data.numeric.flags & MEMORY_CONFIG) {
        rewriteConfigBytesOption(state, name, value, config->data.numeric.default_value);
    } else if (config->data.numeric.flags & OCTAL_CONFIG) {
        rewriteConfigOctalOption(state, name, value, config->data.numeric.default_value);
    } else {
        rewriteConfigNumericalOption(state, name, value, config->data.numeric.default_value);
    }
}",1,4,config.c,numericConfigRewrite,,false,2226,2240,numericConfigRewrite,,,136,"void numericConfigRewrite (standardConfig*,char*,rewriteConfigState*)"
76079,METHOD,config.c:<global>,TYPE_DECL,"static int isValidActiveDefrag(int val, const char **err) {
#ifndef HAVE_DEFRAG
    if (val) {
        *err = ""Active defragmentation cannot be enabled: it ""
               ""requires a Redis server compiled with a modified Jemalloc ""
               ""like the one shipped by default with the Redis source ""
               ""distribution"";
        return 0;
    }
#else
    UNUSED(val);
    UNUSED(err);
#endif
    return 1;
}",1,1,config.c,isValidActiveDefrag,,false,2329,2343,isValidActiveDefrag,,,137,"int isValidActiveDefrag (int,char**)"
76096,METHOD,config.c:<global>,TYPE_DECL,"static int isValidDBfilename(char *val, const char **err) {
    if (!pathIsBaseName(val)) {
        *err = ""dbfilename can't be a path, just a filename"";
        return 0;
    }
    return 1;
}",1,1,config.c,isValidDBfilename,,false,2345,2351,isValidDBfilename,,,138,"int isValidDBfilename (char*,char**)"
76115,METHOD,config.c:<global>,TYPE_DECL,"static int isValidAOFfilename(char *val, const char **err) {
    if (!strcmp(val, """")) {
        *err = ""appendfilename can't be empty"";
        return 0;
    }
    if (!pathIsBaseName(val)) {
        *err = ""appendfilename can't be a path, just a filename"";
        return 0;
    }
    return 1;
}",1,1,config.c,isValidAOFfilename,,false,2353,2363,isValidAOFfilename,,,139,"int isValidAOFfilename (char*,char**)"
76146,METHOD,config.c:<global>,TYPE_DECL,"static int isValidAOFdirname(char *val, const char **err) {
    if (!strcmp(val, """")) {
        *err = ""appenddirname can't be empty"";
        return 0;
    }
    if (!pathIsBaseName(val)) {
        *err = ""appenddirname can't be a path, just a dirname"";
        return 0;
    }
    return 1;
}",1,1,config.c,isValidAOFdirname,,false,2365,2375,isValidAOFdirname,,,140,"int isValidAOFdirname (char*,char**)"
76177,METHOD,config.c:<global>,TYPE_DECL,"static int isValidShutdownOnSigFlags(int val, const char **err) {
    /* Individual arguments are validated by createEnumConfig logic.
     * We just need to ensure valid combinations here. */
    if (val & SHUTDOWN_NOSAVE && val & SHUTDOWN_SAVE) {
        *err = ""shutdown options SAVE and NOSAVE can't be used simultaneously"";
        return 0;
    }
    return 1;
}",1,14,config.c,isValidShutdownOnSigFlags,,false,2377,2385,isValidShutdownOnSigFlags,,,141,"int isValidShutdownOnSigFlags (int,char**)"
76204,METHOD,config.c:<global>,TYPE_DECL,"static int isValidAnnouncedNodename(char *val,const char **err) {
    if (!(isValidAuxString(val,sdslen(val)))) {
        *err = ""Announced human node name contained invalid character"";
	return 0;
    }
    return 1;
}",1,1,config.c,isValidAnnouncedNodename,,false,2387,2393,isValidAnnouncedNodename,,,142,"int isValidAnnouncedNodename (char*,char**)"
76225,METHOD,config.c:<global>,TYPE_DECL,"static int isValidAnnouncedHostname(char *val, const char **err) {
    if (strlen(val) >= NET_HOST_STR_LEN) {
        *err = ""Hostnames must be less than ""
            STRINGIFY(NET_HOST_STR_LEN) "" characters"";
        return 0;
    }

    int i = 0;
    char c;
    while ((c = val[i])) {
        /* We just validate the character set to make sure that everything
         * is parsed and handled correctly. */
        if (!((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')
            || (c >= '0' && c <= '9') || (c == '-') || (c == '.')))
        {
            *err = ""Hostnames may only contain alphanumeric characters, ""
                ""hyphens or dots"";
            return 0;
        }
        c = val[i++];
    }
    return 1;
}",1,23,config.c,isValidAnnouncedHostname,,false,2395,2417,isValidAnnouncedHostname,,,143,"int isValidAnnouncedHostname (char*,char**)"
76305,METHOD,config.c:<global>,TYPE_DECL,"static int isValidProcTitleTemplate(char *val, const char **err) {
    if (!validateProcTitleTemplate(val)) {
        *err = ""template format is invalid or contains unknown variables"";
        return 0;
    }
    return 1;
}",1,1,config.c,isValidProcTitleTemplate,,false,2420,2426,isValidProcTitleTemplate,,,144,"int isValidProcTitleTemplate (char*,char**)"
76324,METHOD,config.c:<global>,TYPE_DECL,"static int updateLocaleCollate(const char **err) {
    const char *s = setlocale(LC_COLLATE, server.locale_collate);
    if (s == NULL) {
        *err = ""Invalid locale name"";
        return 0;
    }
    return 1;
}",1,1,config.c,updateLocaleCollate,,false,2428,2435,updateLocaleCollate,,,145,int updateLocaleCollate (char**)
76350,METHOD,config.c:<global>,TYPE_DECL,"static int updateProcTitleTemplate(const char **err) {
    if (redisSetProcTitle(NULL) == C_ERR) {
        *err = ""failed to set process title"";
        return 0;
    }
    return 1;
}",1,35,config.c,updateProcTitleTemplate,,false,2437,2443,updateProcTitleTemplate,,,146,int updateProcTitleTemplate (char**)
76372,METHOD,config.c:<global>,TYPE_DECL,"static int updateHZ(const char **err) {
    UNUSED(err);
    /* Hz is more a hint from the user, so we accept values out of range
     * but cap them to reasonable values. */
    if (server.config_hz < CONFIG_MIN_HZ) server.config_hz = CONFIG_MIN_HZ;
    if (server.config_hz > CONFIG_MAX_HZ) server.config_hz = CONFIG_MAX_HZ;
    server.hz = server.config_hz;
    return 1;
}",1,4,config.c,updateHZ,,false,2445,2453,updateHZ,,,147,int updateHZ (char**)
76424,METHOD,config.c:<global>,TYPE_DECL,"static int updatePort(const char **err) {
    connListener *listener = listenerByType(CONN_TYPE_SOCKET);

    serverAssert(listener != NULL);
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.port;
    listener->ct = connectionByType(CONN_TYPE_SOCKET);
    if (changeListener(listener) == C_ERR) {
        *err = ""Unable to listen on this port. Check server logs."";
        return 0;
    }

    return 1;
}",1,44,config.c,updatePort,,false,2455,2469,updatePort,,,148,int updatePort (char**)
76498,METHOD,config.c:<global>,TYPE_DECL,"static int updateJemallocBgThread(const char **err) {
    UNUSED(err);
    set_jemalloc_bg_thread(server.jemalloc_bg_thread);
    return 1;
}",1,4,config.c,updateJemallocBgThread,,false,2471,2475,updateJemallocBgThread,,,149,int updateJemallocBgThread (char**)
76515,METHOD,config.c:<global>,TYPE_DECL,"static int updateReplBacklogSize(const char **err) {
    UNUSED(err);
    resizeReplicationBacklog();
    return 1;
}",1,4,config.c,updateReplBacklogSize,,false,2477,2481,updateReplBacklogSize,,,150,int updateReplBacklogSize (char**)
76529,METHOD,config.c:<global>,TYPE_DECL,"static int updateMaxmemory(const char **err) {
    UNUSED(err);
    if (server.maxmemory) {
        size_t used = zmalloc_used_memory()-freeMemoryGetNotCountedMemory();
        if (server.maxmemory < used) {
            serverLog(LL_WARNING,""WARNING: the new maxmemory value set via CONFIG SET (%llu) is smaller than the current memory usage (%zu). This will result in key eviction and/or the inability to accept new write commands depending on the maxmemory-policy."", server.maxmemory, used);
        }
        startEvictionTimeProc();
    }
    return 1;
}",1,4,config.c,updateMaxmemory,,false,2483,2493,updateMaxmemory,,,151,int updateMaxmemory (char**)
76583,METHOD,config.c:<global>,TYPE_DECL,"static int updateGoodSlaves(const char **err) {
    UNUSED(err);
    refreshGoodSlavesCount();
    return 1;
}",1,4,config.c,updateGoodSlaves,,false,2495,2499,updateGoodSlaves,,,152,int updateGoodSlaves (char**)
76597,METHOD,config.c:<global>,TYPE_DECL,"static int updateWatchdogPeriod(const char **err) {
    UNUSED(err);
    applyWatchdogPeriod();
    return 1;
}",1,4,config.c,updateWatchdogPeriod,,false,2501,2505,updateWatchdogPeriod,,,153,int updateWatchdogPeriod (char**)
76611,METHOD,config.c:<global>,TYPE_DECL,"static int updateAppendonly(const char **err) {
    if (!server.aof_enabled && server.aof_state != AOF_OFF) {
        stopAppendOnly();
    } else if (server.aof_enabled && server.aof_state == AOF_OFF) {
        if (startAppendOnly() == C_ERR) {
            *err = ""Unable to turn on AOF. Check server logs."";
            return 0;
        }
    }
    return 1;
}",1,51,config.c,updateAppendonly,,false,2507,2517,updateAppendonly,,,154,int updateAppendonly (char**)
76662,METHOD,config.c:<global>,TYPE_DECL,"static int updateAofAutoGCEnabled(const char **err) {
    UNUSED(err);
    if (!server.aof_disable_auto_gc) {
        aofDelHistoryFiles();
    }

    return 1;
}",1,4,config.c,updateAofAutoGCEnabled,,false,2519,2526,updateAofAutoGCEnabled,,,155,int updateAofAutoGCEnabled (char**)
76682,METHOD,config.c:<global>,TYPE_DECL,"static int updateSighandlerEnabled(const char **err) {
    UNUSED(err);
    if (server.crashlog_enabled)
        setupSignalHandlers();
    else
        removeSignalHandlers();
    return 1;
}",1,4,config.c,updateSighandlerEnabled,,false,2528,2535,updateSighandlerEnabled,,,156,int updateSighandlerEnabled (char**)
76704,METHOD,config.c:<global>,TYPE_DECL,"static int updateMaxclients(const char **err) {
    unsigned int new_maxclients = server.maxclients;
    adjustOpenFilesLimit();
    if (server.maxclients != new_maxclients) {
        static char msg[128];
        snprintf(msg, sizeof(msg), ""The operating system is not able to handle the specified number of clients, try with %d"", server.maxclients);
        *err = msg;
        return 0;
    }
    if ((unsigned int) aeGetSetSize(server.el) <
        server.maxclients + CONFIG_FDSET_INCR)
    {
        if (aeResizeSetSize(server.el,
            server.maxclients + CONFIG_FDSET_INCR) == AE_ERR)
        {
            *err = ""The event loop API used by Redis is not able to handle the specified number of clients"";
            return 0;
        }
    }
    return 1;
}",1,28,config.c,updateMaxclients,,false,2537,2557,updateMaxclients,,,157,int updateMaxclients (char**)
76784,METHOD,config.c:<global>,TYPE_DECL,"static int updateOOMScoreAdj(const char **err) {
    if (setOOMScoreAdj(-1) == C_ERR) {
        *err = ""Failed to set current oom_score_adj. Check server logs."";
        return 0;
    }

    return 1;
}",1,30,config.c,updateOOMScoreAdj,,false,2559,2566,updateOOMScoreAdj,,,158,int updateOOMScoreAdj (char**)
76807,METHOD,config.c:<global>,TYPE_DECL,"int updateRequirePass(const char **err) {
    UNUSED(err);
    /* The old ""requirepass"" directive just translates to setting
     * a password to the default user. The only thing we do
     * additionally is to remember the cleartext password in this
     * case, for backward compatibility with Redis <= 5. */
    ACLUpdateDefaultUserPassword(server.requirepass);
    return 1;
}",1,4,config.c,updateRequirePass,,false,2568,2576,updateRequirePass,,,159,int updateRequirePass (char**)
76824,METHOD,config.c:<global>,TYPE_DECL,"int updateAppendFsync(const char **err) {
    UNUSED(err);
    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        /* Wait for all bio jobs related to AOF to drain before proceeding. This prevents a race
         * between updates to `fsynced_reploff_pending` done in the main thread and those done on the
         * worker thread. */
        bioDrainWorker(BIO_AOF_FSYNC);
    }
    return 1;
}",1,4,config.c,updateAppendFsync,,false,2578,2587,updateAppendFsync,,,160,int updateAppendFsync (char**)
76848,METHOD,config.c:<global>,TYPE_DECL,"static int applyBind(const char **err) {
    connListener *tcp_listener = listenerByType(CONN_TYPE_SOCKET);
    connListener *tls_listener = listenerByType(CONN_TYPE_TLS);

    serverAssert(tcp_listener != NULL);
    tcp_listener->bindaddr = server.bindaddr;
    tcp_listener->bindaddr_count = server.bindaddr_count;
    tcp_listener->port = server.port;
    tcp_listener->ct = connectionByType(CONN_TYPE_SOCKET);
    if (changeListener(tcp_listener) == C_ERR) {
        *err = ""Failed to bind to specified addresses."";
        if (tls_listener)
            closeListener(tls_listener); /* failed with TLS together */
        return 0;
    }

    if (server.tls_port != 0) {
        serverAssert(tls_listener != NULL);
        tls_listener->bindaddr = server.bindaddr;
        tls_listener->bindaddr_count = server.bindaddr_count;
        tls_listener->port = server.tls_port;
        tls_listener->ct = connectionByType(CONN_TYPE_TLS);
        if (changeListener(tls_listener) == C_ERR) {
       ...",1,48,config.c,applyBind,,false,2590,2620,applyBind,,,161,int applyBind (char**)
77003,METHOD,config.c:<global>,TYPE_DECL,"int updateClusterFlags(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfFlags();
    return 1;
}",1,4,config.c,updateClusterFlags,,false,2622,2626,updateClusterFlags,,,162,int updateClusterFlags (char**)
77017,METHOD,config.c:<global>,TYPE_DECL,"static int updateClusterAnnouncedPort(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfAnnouncedPorts();
    return 1;
}",1,4,config.c,updateClusterAnnouncedPort,,false,2628,2632,updateClusterAnnouncedPort,,,163,int updateClusterAnnouncedPort (char**)
77031,METHOD,config.c:<global>,TYPE_DECL,"static int updateClusterIp(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfIp();
    return 1;
}",1,4,config.c,updateClusterIp,,false,2634,2638,updateClusterIp,,,164,int updateClusterIp (char**)
77045,METHOD,config.c:<global>,TYPE_DECL,"int updateClusterHostname(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfHostname();
    return 1;
}",1,4,config.c,updateClusterHostname,,false,2640,2644,updateClusterHostname,,,165,int updateClusterHostname (char**)
77059,METHOD,config.c:<global>,TYPE_DECL,"int updateClusterHumanNodename(const char **err) {
    UNUSED(err);
    clusterUpdateMyselfHumanNodename();
    return 1;
}",1,4,config.c,updateClusterHumanNodename,,false,2646,2650,updateClusterHumanNodename,,,166,int updateClusterHumanNodename (char**)
77073,METHOD,config.c:<global>,TYPE_DECL,"static int applyTlsCfg(const char **err) {
    UNUSED(err);

    /* If TLS is enabled, try to configure OpenSSL. */
    if ((server.tls_port || server.tls_replication || server.tls_cluster)
         && connTypeConfigure(connectionTypeTls(), &server.tls_ctx_config, 1) == C_ERR) {
        *err = ""Unable to update TLS configuration. Check server logs."";
        return 0;
    }
    return 1;
}",1,4,config.c,applyTlsCfg,,false,2652,2662,applyTlsCfg,,,167,int applyTlsCfg (char**)
77118,METHOD,config.c:<global>,TYPE_DECL,"static int applyTLSPort(const char **err) {
    /* Configure TLS in case it wasn't enabled */
    if (connTypeConfigure(connectionTypeTls(), &server.tls_ctx_config, 0) == C_ERR) {
        *err = ""Unable to update TLS configuration. Check server logs."";
        return 0;
    }

    connListener *listener = listenerByType(CONN_TYPE_TLS);
    serverAssert(listener != NULL);
    listener->bindaddr = server.bindaddr;
    listener->bindaddr_count = server.bindaddr_count;
    listener->port = server.tls_port;
    listener->ct = connectionByType(CONN_TYPE_TLS);
    if (changeListener(listener) == C_ERR) {
        *err = ""Unable to listen on this port. Check server logs."";
        return 0;
    }

    return 1;
}",1,77,config.c,applyTLSPort,,false,2664,2683,applyTLSPort,,,168,int applyTLSPort (char**)
77212,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigDirOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    if (argc != 1) {
        *err = ""wrong number of arguments"";
        return 0;
    }
    if (chdir(argv[0]) == -1) {
        *err = strerror(errno);
        return 0;
    }
    return 1;
}",1,4,config.c,setConfigDirOption,,false,2685,2696,setConfigDirOption,,,169,"int setConfigDirOption (standardConfig*,sds*,int,char**)"
77255,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigDirOption(standardConfig *config) {
    UNUSED(config);
    char buf[1024];

    if (getcwd(buf,sizeof(buf)) == NULL)
        buf[0] = '\0';

    return sdsnew(buf);
}",1,4,config.c,getConfigDirOption,,false,2698,2706,getConfigDirOption,,,170,sds getConfigDirOption (standardConfig*)
77283,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigSaveOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    int j;

    /* Special case: treat single arg """" as zero args indicating empty save configuration */
    if (argc == 1 && !strcasecmp(argv[0],"""")) {
        resetServerSaveParams();
        argc = 0;
    }

    /* Perform sanity check before setting the new config:
    * - Even number of args
    * - Seconds >= 1, changes >= 0 */
    if (argc & 1) {
        *err = ""Invalid save parameters"";
        return 0;
    }
    for (j = 0; j < argc; j++) {
        char *eptr;
        long val;

        val = strtoll(argv[j], &eptr, 10);
        if (eptr[0] != '\0' ||
            ((j & 1) == 0 && val < 1) ||
            ((j & 1) == 1 && val < 0)) {
            *err = ""Invalid save parameters"";
            return 0;
        }
    }
    /* Finally set the new config */
    if (!reading_config_file) {
        resetServerSaveParams();
    } else {
        /* We don't reset save p...",1,4,config.c,setConfigSaveOption,,false,2708,2761,setConfigSaveOption,,,171,"int setConfigSaveOption (standardConfig*,sds*,int,char**)"
77436,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigSaveOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;

    for (j = 0; j < server.saveparamslen; j++) {
        buf = sdscatprintf(buf,""%jd %d"",
                           (intmax_t)server.saveparams[j].seconds,
                           server.saveparams[j].changes);
        if (j != server.saveparamslen-1)
            buf = sdscatlen(buf,"" "",1);
    }

    return buf;
}",1,4,config.c,getConfigSaveOption,,false,2763,2777,getConfigSaveOption,,,172,sds getConfigSaveOption (standardConfig*)
77503,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigClientOutputBufferLimitOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    return updateClientOutputBufferLimit(argv, argc, err);
}",1,4,config.c,setConfigClientOutputBufferLimitOption,,false,2779,2782,setConfigClientOutputBufferLimitOption,,,173,"int setConfigClientOutputBufferLimitOption (standardConfig*,sds*,int,char**)"
77522,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigClientOutputBufferLimitOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;
    for (j = 0; j < CLIENT_TYPE_OBUF_COUNT; j++) {
        buf = sdscatprintf(buf,""%s %llu %llu %ld"",
                           getClientTypeName(j),
                           server.client_obuf_limits[j].hard_limit_bytes,
                           server.client_obuf_limits[j].soft_limit_bytes,
                           (long) server.client_obuf_limits[j].soft_limit_seconds);
        if (j != CLIENT_TYPE_OBUF_COUNT-1)
            buf = sdscatlen(buf,"" "",1);
    }
    return buf;
}",1,4,config.c,getConfigClientOutputBufferLimitOption,,false,2784,2798,getConfigClientOutputBufferLimitOption,,,174,sds getConfigClientOutputBufferLimitOption (standardConfig*)
77598,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigOOMScoreAdjValuesOption(standardConfig *config, sds *argv, int argc, const char **err) {
    int i;
    int values[CONFIG_OOM_COUNT];
    int change = 0;
    UNUSED(config);

    if (argc != CONFIG_OOM_COUNT) {
        *err = ""wrong number of arguments"";
        return 0;
    }

    for (i = 0; i < CONFIG_OOM_COUNT; i++) {
        char *eptr;
        long long val = strtoll(argv[i], &eptr, 10);

        if (*eptr != '\0' || val < -2000 || val > 2000) {
            if (err) *err = ""Invalid oom-score-adj-values, elements must be between -2000 and 2000."";
            return 0;
        }

        values[i] = val;
    }

    /* Verify that the values make sense. If they don't omit a warning but
     * keep the configuration, which may still be valid for privileged processes.
     */

    if (values[CONFIG_OOM_REPLICA] < values[CONFIG_OOM_MASTER] ||
        values[CONFIG_OOM_BGCHILD] < values[CONFIG_OOM_REPLICA])
    {
        serverLog(LL_WARNING,
                  ""T...",1,15,config.c,setConfigOOMScoreAdjValuesOption,,false,2803,2846,setConfigOOMScoreAdjValuesOption,,,175,"int setConfigOOMScoreAdjValuesOption (standardConfig*,sds*,int,char**)"
77768,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigOOMScoreAdjValuesOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    int j;

    for (j = 0; j < CONFIG_OOM_COUNT; j++) {
        buf = sdscatprintf(buf,""%d"", server.oom_score_adj_values[j]);
        if (j != CONFIG_OOM_COUNT-1)
            buf = sdscatlen(buf,"" "",1);
    }

    return buf;
}",1,4,config.c,getConfigOOMScoreAdjValuesOption,,false,2848,2860,getConfigOOMScoreAdjValuesOption,,,176,sds getConfigOOMScoreAdjValuesOption (standardConfig*)
77824,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigNotifyKeyspaceEventsOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    if (argc != 1) {
        *err = ""wrong number of arguments"";
        return 0;
    }
    int flags = keyspaceEventsStringToFlags(argv[0]);
    if (flags == -1) {
        *err = ""Invalid event class character. Use 'Ag$lshzxeKEtmdn'."";
        return 0;
    }
    server.notify_keyspace_events = flags;
    return 1;
}",1,4,config.c,setConfigNotifyKeyspaceEventsOption,,false,2862,2875,setConfigNotifyKeyspaceEventsOption,,,177,"int setConfigNotifyKeyspaceEventsOption (standardConfig*,sds*,int,char**)"
77875,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigNotifyKeyspaceEventsOption(standardConfig *config) {
    UNUSED(config);
    return keyspaceEventsFlagsToString(server.notify_keyspace_events);
}",1,4,config.c,getConfigNotifyKeyspaceEventsOption,,false,2877,2880,getConfigNotifyKeyspaceEventsOption,,,178,sds getConfigNotifyKeyspaceEventsOption (standardConfig*)
77891,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigBindOption(standardConfig *config, sds* argv, int argc, const char **err) {
    UNUSED(config);
    int j;

    if (argc > CONFIG_BINDADDR_MAX) {
        *err = ""Too many bind addresses specified."";
        return 0;
    }

    /* A single empty argument is treated as a zero bindaddr count */
    if (argc == 1 && sdslen(argv[0]) == 0) argc = 0;

    /* Free old bind addresses */
    for (j = 0; j < server.bindaddr_count; j++) {
        zfree(server.bindaddr[j]);
    }
    for (j = 0; j < argc; j++)
        server.bindaddr[j] = zstrdup(argv[j]);
    server.bindaddr_count = argc;

    return 1;
}",1,4,config.c,setConfigBindOption,,false,2882,2903,setConfigBindOption,,,179,"int setConfigBindOption (standardConfig*,sds*,int,char**)"
77980,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigReplicaOfOption(standardConfig *config, sds* argv, int argc, const char **err) {
    UNUSED(config);

    if (argc != 2) {
        *err = ""wrong number of arguments"";
        return 0;
    }

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (!strcasecmp(argv[0], ""no"") && !strcasecmp(argv[1], ""one"")) {
        return 1;
    }
    char *ptr;
    server.masterport = strtol(argv[1], &ptr, 10);
    if (server.masterport < 0 || server.masterport > 65535 || *ptr != '\0') {
        *err = ""Invalid master port"";
        return 0;
    }
    server.masterhost = sdsnew(argv[0]);
    server.repl_state = REPL_STATE_CONNECT;
    return 1;
}",1,4,config.c,setConfigReplicaOfOption,,false,2905,2927,setConfigReplicaOfOption,,,180,"int setConfigReplicaOfOption (standardConfig*,sds*,int,char**)"
78082,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigBindOption(standardConfig *config) {
    UNUSED(config);
    return sdsjoin(server.bindaddr,server.bindaddr_count,"" "");
}",1,4,config.c,getConfigBindOption,,false,2929,2932,getConfigBindOption,,,181,sds getConfigBindOption (standardConfig*)
78102,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigReplicaOfOption(standardConfig *config) {
    UNUSED(config);
    char buf[256];
    if (server.masterhost)
        snprintf(buf,sizeof(buf),""%s %d"",
                 server.masterhost, server.masterport);
    else
        buf[0] = '\0';
    return sdsnew(buf);
}",1,4,config.c,getConfigReplicaOfOption,,false,2934,2943,getConfigReplicaOfOption,,,182,sds getConfigReplicaOfOption (standardConfig*)
78140,METHOD,config.c:<global>,TYPE_DECL,"int allowProtectedAction(int config, client *c) {
    return (config == PROTECTED_ACTION_ALLOWED_YES) ||
           (config == PROTECTED_ACTION_ALLOWED_LOCAL && (connIsLocal(c->conn) == 1));
}",1,22,config.c,allowProtectedAction,,false,2945,2948,allowProtectedAction,,,183,"int allowProtectedAction (int,client*)"
78165,METHOD,config.c:<global>,TYPE_DECL,"static int setConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config, sds *argv, int argc, const char **err) {
    UNUSED(config);
    zfree(server.latency_tracking_info_percentiles);
    server.latency_tracking_info_percentiles = NULL;
    server.latency_tracking_info_percentiles_len = argc;

    /* Special case: treat single arg """" as zero args indicating empty percentile configuration */
    if (argc == 1 && sdslen(argv[0]) == 0)
        server.latency_tracking_info_percentiles_len = 0;
    else
        server.latency_tracking_info_percentiles = zmalloc(sizeof(double)*argc);

    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        double percentile;
        if (!string2d(argv[j], sdslen(argv[j]), &percentile)) {
            *err = ""Invalid latency-tracking-info-percentiles parameters"";
            goto configerr;
        }
        if (percentile > 100.0 || percentile < 0.0) {
            *err = ""latency-tracking-info-percentiles param...",1,4,config.c,setConfigLatencyTrackingInfoPercentilesOutputOption,,false,2951,2982,setConfigLatencyTrackingInfoPercentilesOutputOption,,,184,"int setConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*,sds*,int,char**)"
78294,METHOD,config.c:<global>,TYPE_DECL,"static sds getConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config) {
    UNUSED(config);
    sds buf = sdsempty();
    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        char fbuf[128];
        size_t len = snprintf(fbuf, sizeof(fbuf), ""%f"", server.latency_tracking_info_percentiles[j]);
        len = trimDoubleString(fbuf, len);
        buf = sdscatlen(buf, fbuf, len);
        if (j != server.latency_tracking_info_percentiles_len-1)
            buf = sdscatlen(buf,"" "",1);
    }
    return buf;
}",1,4,config.c,getConfigLatencyTrackingInfoPercentilesOutputOption,,false,2984,2996,getConfigLatencyTrackingInfoPercentilesOutputOption,,,185,sds getConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*)
78365,METHOD,config.c:<global>,TYPE_DECL,"void rewriteConfigLatencyTrackingInfoPercentilesOutputOption(standardConfig *config, const char *name, struct rewriteConfigState *state) {
    UNUSED(config);
    sds line = sdsnew(name);
    /* Rewrite latency-tracking-info-percentiles parameters,
     * or an empty 'latency-tracking-info-percentiles """"' line to avoid the
     * defaults from being used.
     */
    if (!server.latency_tracking_info_percentiles_len) {
        line = sdscat(line,"" \""\"""");
    } else {
        for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
            char fbuf[128];
            size_t len = snprintf(fbuf, sizeof(fbuf), "" %f"", server.latency_tracking_info_percentiles[j]);
            len = trimDoubleString(fbuf, len);
            line = sdscatlen(line, fbuf, len);
        }
    }
    rewriteConfigRewriteLine(state,name,line,1);
}",1,4,config.c,rewriteConfigLatencyTrackingInfoPercentilesOutputOption,,false,2999,3017,rewriteConfigLatencyTrackingInfoPercentilesOutputOption,,,186,"void rewriteConfigLatencyTrackingInfoPercentilesOutputOption (standardConfig*,char*,rewriteConfigState*)"
78440,METHOD,config.c:<global>,TYPE_DECL,"static int applyClientMaxMemoryUsage(const char **err) {
    UNUSED(err);
    listIter li;
    listNode *ln;

    /* server.client_mem_usage_buckets is an indication that the previous config
     * was non-zero, in which case we can exit and no apply is needed. */
    if(server.maxmemory_clients !=0 && server.client_mem_usage_buckets)
        return 1;
    if (server.maxmemory_clients != 0)
        initServerClientMemUsageBuckets();

    /* When client eviction is enabled update memory buckets for all clients.
     * When disabled, clear that data structure. */
    listRewind(server.clients, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (server.maxmemory_clients == 0) {
            /* Remove client from memory usage bucket. */
            removeClientFromMemUsageBucket(c, 0);
        } else {
            /* Update each client(s) memory usage and add to appropriate bucket. */
            updateClientMemUsageAndBucket(c);
        }
...",1,4,config.c,applyClientMaxMemoryUsage,,false,3019,3048,applyClientMaxMemoryUsage,,,187,int applyClientMaxMemoryUsage (char**)
96540,METHOD,config.c:<global>,TYPE_DECL,"int registerConfigValue(const char *name, const standardConfig *config, int alias) {
    standardConfig *new = zmalloc(sizeof(standardConfig));
    memcpy(new, config, sizeof(standardConfig));
    if (alias) {
        new->flags |= ALIAS_CONFIG;
        new->name = config->alias;
        new->alias = config->name;
    }

    return dictAdd(configs, sdsnew(name), new) == DICT_OK;
}",1,22,config.c,registerConfigValue,,false,3271,3281,registerConfigValue,,,190,"int registerConfigValue (char*,standardConfig*,int)"
96594,METHOD,config.c:<global>,TYPE_DECL,"void initConfigValues(void) {
    configs = dictCreate(&sdsHashDictType);
    dictExpand(configs, sizeof(static_configs) / sizeof(standardConfig));
    for (standardConfig *config = static_configs; config->name != NULL; config++) {
        if (config->interface.init) config->interface.init(config);
        /* Add the primary config to the dictionary. */
        int ret = registerConfigValue(config->name, config, 0);
        serverAssert(ret);

        /* Aliases are the same as their primary counter parts, but they
         * also have a flag indicating they are the alias. */
        if (config->alias) {
            int ret = registerConfigValue(config->alias, config, ALIAS_CONFIG);
            serverAssert(ret);
        }
    }
}",1,8,config.c,initConfigValues,,false,3285,3301,initConfigValues,,,191,void initConfigValues (void)
96696,METHOD,config.c:<global>,TYPE_DECL,"void removeConfig(sds name) {
    standardConfig *config = lookupConfig(name);
    if (!config) return;
    if (config->flags & MODULE_CONFIG) {
        sdsfree((sds) config->name);
        if (config->type == ENUM_CONFIG) {
            configEnum *enumNode = config->data.enumd.enum_value;
            while(enumNode->name != NULL) {
                zfree(enumNode->name);
                enumNode++;
            }
            zfree(config->data.enumd.enum_value);
        } else if (config->type == SDS_CONFIG) {
            if (config->data.sds.default_value) sdsfree((sds)config->data.sds.default_value);
        }
    }
    dictDelete(configs, name);
}",1,24,config.c,removeConfig,,false,3304,3321,removeConfig,,,192,void removeConfig (sds)
96797,METHOD,config.c:<global>,TYPE_DECL,"void addModuleBoolConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    int config_dummy_address;
    standardConfig module_config = createBoolConfig(config_name, NULL, flags | MODULE_CONFIG, config_dummy_address, default_val, NULL, NULL);
    module_config.data.yesno.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",1,35,config.c,addModuleBoolConfig,,false,3328,3335,addModuleBoolConfig,,,193,"void addModuleBoolConfig (char*,char*,int,void*,int)"
96915,METHOD,config.c:<global>,TYPE_DECL,"void addModuleStringConfig(const char *module_name, const char *name, int flags, void *privdata, sds default_val) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    sds config_dummy_address;
    standardConfig module_config = createSDSConfig(config_name, NULL, flags | MODULE_CONFIG, 0, config_dummy_address, default_val, NULL, NULL);
    module_config.data.sds.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",1,35,config.c,addModuleStringConfig,,false,3337,3344,addModuleStringConfig,,,194,"void addModuleStringConfig (char*,char*,int,void*,sds)"
97041,METHOD,config.c:<global>,TYPE_DECL,"void addModuleEnumConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val, configEnum *enum_vals) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    int config_dummy_address;
    standardConfig module_config = createEnumConfig(config_name, NULL, flags | MODULE_CONFIG, enum_vals, config_dummy_address, default_val, NULL, NULL);
    module_config.data.enumd.config = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",1,35,config.c,addModuleEnumConfig,,false,3346,3353,addModuleEnumConfig,,,195,"void addModuleEnumConfig (char*,char*,int,void*,int,configEnum*)"
97168,METHOD,config.c:<global>,TYPE_DECL,"void addModuleNumericConfig(const char *module_name, const char *name, int flags, void *privdata, long long default_val, int conf_flags, long long lower, long long upper) {
    sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module_name, name);
    long long config_dummy_address;
    standardConfig module_config = createLongLongConfig(config_name, NULL, flags | MODULE_CONFIG, lower, upper, config_dummy_address, default_val, conf_flags, NULL, NULL);
    module_config.data.numeric.config.ll = NULL;
    module_config.privdata = privdata;
    registerConfigValue(config_name, &module_config, 0);
}",1,35,config.c,addModuleNumericConfig,,false,3355,3362,addModuleNumericConfig,,,196,"void addModuleNumericConfig (char*,char*,int,void*,long long,int,long long,long long)"
97331,METHOD,config.c:<global>,TYPE_DECL,"void configHelpCommand(client *c) {
    const char *help[] = {
""GET <pattern>"",
""    Return parameters matching the glob-like <pattern> and their values."",
""SET <directive> <value>"",
""    Set the configuration <directive> to <value>."",
""RESETSTAT"",
""    Reset statistics reported by the INFO command."",
""REWRITE"",
""    Rewrite the configuration file."",
NULL
    };

    addReplyHelp(c, help);
}",1,1,config.c,configHelpCommand,,false,3368,3382,configHelpCommand,,,197,void configHelpCommand (client*)
97352,METHOD,config.c:<global>,TYPE_DECL,"void configResetStatCommand(client *c) {
    resetServerStats();
    resetCommandTableStats(server.commands);
    resetErrorTableStats();
    addReply(c,shared.ok);
}",1,1,config.c,configResetStatCommand,,false,3388,3393,configResetStatCommand,,,198,void configResetStatCommand (client*)
97368,METHOD,config.c:<global>,TYPE_DECL,"void configRewriteCommand(client *c) {
    if (server.configfile == NULL) {
        addReplyError(c,""The server is running without a config file"");
        return;
    }
    if (rewriteConfig(server.configfile, 0) == -1) {
        /* save errno in case of being tainted. */
        int err = errno;
        serverLog(LL_WARNING,""CONFIG REWRITE failed: %s"", strerror(err));
        addReplyErrorFormat(c,""Rewriting config file: %s"", strerror(err));
    } else {
        serverLog(LL_NOTICE,""CONFIG REWRITE executed with success."");
        addReply(c,shared.ok);
    }
}",1,8,config.c,configRewriteCommand,,false,3399,3413,configRewriteCommand,,,199,void configRewriteCommand (client*)
97475,METHOD,config.h:<global>,TYPE_DECL,<global>,1,19,config.h,config.h:<global>,,false,1,317,<global>,,,1,
97484,METHOD,connection.c:<global>,TYPE_DECL,<global>,1,1,connection.c,connection.c:<global>,,false,1,208,<global>,,,1,
97491,METHOD,connection.c:<global>,TYPE_DECL,"int connTypeRegister(ConnectionType *ct) {
    const char *typename = ct->get_type(NULL);
    ConnectionType *tmpct;
    int type;

    /* find an empty slot to store the new connection type */
    for (type = 0; type < CONN_TYPE_MAX; type++) {
        tmpct = connTypes[type];
        if (!tmpct)
            break;

        /* ignore case, we really don't care ""tls""/""TLS"" */
        if (!strcasecmp(typename, tmpct->get_type(NULL))) {
            serverLog(LL_WARNING, ""Connection types %s already registered"", typename);
            return C_ERR;
        }
    }

    serverLog(LL_VERBOSE, ""Connection type %s registered"", typename);
    connTypes[type] = ct;

    if (ct->init) {
        ct->init();
    }

    return C_OK;
}",1,26,connection.c,connTypeRegister,,false,32,58,connTypeRegister,,,3,int connTypeRegister (ConnectionType*)
97600,METHOD,connection.c:<global>,TYPE_DECL,"int connTypeInitialize(void) {
    /* currently socket connection type is necessary  */
    serverAssert(RedisRegisterConnectionTypeSocket() == C_OK);

    /* currently unix socket connection type is necessary  */
    serverAssert(RedisRegisterConnectionTypeUnix() == C_OK);

    /* may fail if without BUILD_TLS=yes */
    RedisRegisterConnectionTypeTLS();

    return C_OK;
}",1,4,connection.c,connTypeInitialize,,false,60,71,connTypeInitialize,,,4,int connTypeInitialize (void)
97642,METHOD,connection.c:<global>,TYPE_DECL,"ConnectionType *connectionByType(const char *typename) {
    ConnectionType *ct;

    for (int type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (!strcasecmp(typename, ct->get_type(NULL)))
            return ct;
    }

    serverLog(LL_WARNING, ""Missing implement of connection type %s"", typename);

    return NULL;
}",1,30,connection.c,connectionByType,,false,73,88,connectionByType,,,5,ConnectionType connectionByType (char*)
97705,METHOD,connection.c:<global>,TYPE_DECL,"ConnectionType *connectionTypeTcp(void) {
    static ConnectionType *ct_tcp = NULL;

    if (ct_tcp != NULL)
        return ct_tcp;

    ct_tcp = connectionByType(CONN_TYPE_SOCKET);
    serverAssert(ct_tcp != NULL);

    return ct_tcp;
}",1,30,connection.c,connectionTypeTcp,,false,91,101,connectionTypeTcp,,,6,ConnectionType connectionTypeTcp (void)
97745,METHOD,connection.c:<global>,TYPE_DECL,"ConnectionType *connectionTypeTls(void) {
    static ConnectionType *ct_tls = NULL;
    static int cached = 0;

    /* Unlike the TCP and Unix connections, the TLS one can be missing
     * So we need the cached pointer to handle NULL correctly too. */
    if (!cached) {
        cached = 1;
        ct_tls = connectionByType(CONN_TYPE_TLS);
    }

    return ct_tls;
}",1,34,connection.c,connectionTypeTls,,false,104,116,connectionTypeTls,,,7,ConnectionType connectionTypeTls (void)
97773,METHOD,connection.c:<global>,TYPE_DECL,"ConnectionType *connectionTypeUnix(void) {
    static ConnectionType *ct_unix = NULL;

    if (ct_unix != NULL)
        return ct_unix;

    ct_unix = connectionByType(CONN_TYPE_UNIX);
    return ct_unix;
}",1,31,connection.c,connectionTypeUnix,,false,119,127,connectionTypeUnix,,,8,ConnectionType connectionTypeUnix (void)
97797,METHOD,connection.c:<global>,TYPE_DECL,"int connectionIndexByType(const char *typename) {
    ConnectionType *ct;

    for (int type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (!strcasecmp(typename, ct->get_type(NULL)))
            return type;
    }

    return -1;
}",1,30,connection.c,connectionIndexByType,,false,129,142,connectionIndexByType,,,9,int connectionIndexByType (char*)
97842,METHOD,connection.c:<global>,TYPE_DECL,"void connTypeCleanupAll(void) {
    ConnectionType *ct;
    int type;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (!ct)
            break;

        if (ct->cleanup)
            ct->cleanup();
    }
}",1,26,connection.c,connTypeCleanupAll,,false,144,156,connTypeCleanupAll,,,10,void connTypeCleanupAll (void)
97881,METHOD,connection.c:<global>,TYPE_DECL,"int connTypeHasPendingData(void) {
    ConnectionType *ct;
    int type;
    int ret = 0;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (ct && ct->has_pending_data && (ret = ct->has_pending_data())) {
            return ret;
        }
    }

    return ret;
}",1,26,connection.c,connTypeHasPendingData,,false,159,172,connTypeHasPendingData,,,11,int connTypeHasPendingData (void)
97928,METHOD,connection.c:<global>,TYPE_DECL,"int connTypeProcessPendingData(void) {
    ConnectionType *ct;
    int type;
    int ret = 0;

    for (type = 0; type < CONN_TYPE_MAX; type++) {
        ct = connTypes[type];
        if (ct && ct->process_pending_data) {
            ret += ct->process_pending_data();
        }
    }

    return ret;
}",1,26,connection.c,connTypeProcessPendingData,,false,175,188,connTypeProcessPendingData,,,12,int connTypeProcessPendingData (void)
97972,METHOD,connection.c:<global>,TYPE_DECL,"sds getListensInfoString(sds info) {
    for (int j = 0; j < CONN_TYPE_MAX; j++) {
        connListener *listener = &server.listeners[j];
        if (listener->ct == NULL)
            continue;

        info = sdscatfmt(info, ""listener%i:name=%s"", j, listener->ct->get_type(NULL));
        for (int i = 0; i < listener->count; i++) {
            info = sdscatfmt(info, "",bind=%s"", listener->bindaddr[i]);
        }

        if (listener->port)
            info = sdscatfmt(info, "",port=%i"", listener->port);

        info = sdscatfmt(info, ""\r\n"");
    }

    return info;
}",1,24,connection.c,getListensInfoString,,false,190,208,getListensInfoString,,,13,sds getListensInfoString (sds)
98078,METHOD,connection.h:<global>,TYPE_DECL,<global>,1,1,connection.h,connection.h:<global>,,false,1,454,<global>,,,1,
98092,METHOD,<empty>,<empty>,<empty>,1,,connection.h,ConnectionState:<clinit>,,false,49,,<clinit>,,,7,
98100,METHOD,connection.h:<global>,TYPE_DECL,typedef void (*ConnectionCallbackFunc)(struct connection *conn);,14,63,connection.h,ConnectionCallbackFunc,,false,66,66,ConnectionCallbackFunc,,,8,void ConnectionCallbackFunc (connection*)
98106,METHOD,ConnectionType,TYPE_DECL,const char *(*get_type)(struct connection *conn);,16,52,connection.h,ConnectionType.get_type,,false,70,70,get_type,,,1,char* ConnectionType.get_type (connection*)
98111,METHOD,ConnectionType,TYPE_DECL,void (*init)(void);,10,22,connection.h,ConnectionType.init,,false,73,73,init,,,2,void ConnectionType.init (void)
98116,METHOD,ConnectionType,TYPE_DECL,void (*cleanup)(void);,10,25,connection.h,ConnectionType.cleanup,,false,74,74,cleanup,,,3,void ConnectionType.cleanup (void)
98121,METHOD,ConnectionType,TYPE_DECL,"int (*configure)(void *priv, int reconfigure);",9,49,connection.h,ConnectionType.configure,,false,75,75,configure,,,4,"int ConnectionType.configure (void*,int)"
98127,METHOD,ConnectionType,TYPE_DECL,"void (*ae_handler)(struct aeEventLoop *el, int fd, void *clientData, int mask);",10,82,connection.h,ConnectionType.ae_handler,,false,78,78,ae_handler,,,5,"void ConnectionType.ae_handler (aeEventLoop*,int,void*,int)"
98136,METHOD,ConnectionType,TYPE_DECL,"int (*addr)(connection *conn, char *ip, size_t ip_len, int *port, int remote);",9,81,connection.h,ConnectionType.addr,,false,80,80,addr,,,7,"int ConnectionType.addr (connection*,char*,size_t,int*,int)"
98145,METHOD,ConnectionType,TYPE_DECL,int (*is_local)(connection *conn);,9,37,connection.h,ConnectionType.is_local,,false,81,81,is_local,,,8,int ConnectionType.is_local (connection*)
98150,METHOD,ConnectionType,TYPE_DECL,int (*listen)(connListener *listener);,9,41,connection.h,ConnectionType.listen,,false,82,82,listen,,,9,int ConnectionType.listen (connListener*)
98155,METHOD,ConnectionType,TYPE_DECL,connection* (*conn_create)(void);,15,36,connection.h,ConnectionType.conn_create,,false,85,85,conn_create,,,10,connection* ConnectionType.conn_create (void)
98160,METHOD,ConnectionType,TYPE_DECL,"connection* (*conn_create_accepted)(int fd, void *priv);",15,59,connection.h,ConnectionType.conn_create_accepted,,false,86,86,conn_create_accepted,,,11,"connection* ConnectionType.conn_create_accepted (int,void*)"
98166,METHOD,ConnectionType,TYPE_DECL,void (*shutdown)(struct connection *conn);,10,45,connection.h,ConnectionType.shutdown,,false,87,87,shutdown,,,12,void ConnectionType.shutdown (connection*)
98171,METHOD,ConnectionType,TYPE_DECL,void (*close)(struct connection *conn);,10,42,connection.h,ConnectionType.close,,false,88,88,close,,,13,void ConnectionType.close (connection*)
98176,METHOD,ConnectionType,TYPE_DECL,"int (*connect)(struct connection *conn, const char *addr, int port, const char *source_addr, ConnectionCallbackFunc connect_handler);",9,136,connection.h,ConnectionType.connect,,false,91,91,connect,,,14,"int ConnectionType.connect (connection*,char*,int,char*,ConnectionCallbackFunc)"
98185,METHOD,ConnectionType,TYPE_DECL,"int (*blocking_connect)(struct connection *conn, const char *addr, int port, long long timeout);",9,99,connection.h,ConnectionType.blocking_connect,,false,92,92,blocking_connect,,,15,"int ConnectionType.blocking_connect (connection*,char*,int,long long)"
98193,METHOD,ConnectionType,TYPE_DECL,"int (*accept)(struct connection *conn, ConnectionCallbackFunc accept_handler);",9,81,connection.h,ConnectionType.accept,,false,93,93,accept,,,16,"int ConnectionType.accept (connection*,ConnectionCallbackFunc)"
98199,METHOD,ConnectionType,TYPE_DECL,"int (*write)(struct connection *conn, const void *data, size_t data_len);",9,76,connection.h,ConnectionType.write,,false,96,96,write,,,17,"int ConnectionType.write (connection*,void*,size_t)"
98206,METHOD,ConnectionType,TYPE_DECL,"int (*writev)(struct connection *conn, const struct iovec *iov, int iovcnt);",9,79,connection.h,ConnectionType.writev,,false,97,97,writev,,,18,"int ConnectionType.writev (connection*,iovec*,int)"
98213,METHOD,ConnectionType,TYPE_DECL,"int (*read)(struct connection *conn, void *buf, size_t buf_len);",9,67,connection.h,ConnectionType.read,,false,98,98,read,,,19,"int ConnectionType.read (connection*,void*,size_t)"
98220,METHOD,ConnectionType,TYPE_DECL,"int (*set_write_handler)(struct connection *conn, ConnectionCallbackFunc handler, int barrier);",9,98,connection.h,ConnectionType.set_write_handler,,false,99,99,set_write_handler,,,20,"int ConnectionType.set_write_handler (connection*,ConnectionCallbackFunc,int)"
98227,METHOD,ConnectionType,TYPE_DECL,"int (*set_read_handler)(struct connection *conn, ConnectionCallbackFunc handler);",9,84,connection.h,ConnectionType.set_read_handler,,false,100,100,set_read_handler,,,21,"int ConnectionType.set_read_handler (connection*,ConnectionCallbackFunc)"
98233,METHOD,ConnectionType,TYPE_DECL,const char *(*get_last_error)(struct connection *conn);,16,58,connection.h,ConnectionType.get_last_error,,false,101,101,get_last_error,,,22,char* ConnectionType.get_last_error (connection*)
98238,METHOD,ConnectionType,TYPE_DECL,"ssize_t (*sync_write)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",13,94,connection.h,ConnectionType.sync_write,,false,102,102,sync_write,,,23,"ssize_t ConnectionType.sync_write (connection*,char*,ssize_t,long long)"
98246,METHOD,ConnectionType,TYPE_DECL,"ssize_t (*sync_read)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",13,93,connection.h,ConnectionType.sync_read,,false,103,103,sync_read,,,24,"ssize_t ConnectionType.sync_read (connection*,char*,ssize_t,long long)"
98254,METHOD,ConnectionType,TYPE_DECL,"ssize_t (*sync_readline)(struct connection *conn, char *ptr, ssize_t size, long long timeout);",13,97,connection.h,ConnectionType.sync_readline,,false,104,104,sync_readline,,,25,"ssize_t ConnectionType.sync_readline (connection*,char*,ssize_t,long long)"
98262,METHOD,ConnectionType,TYPE_DECL,int (*has_pending_data)(void);,9,33,connection.h,ConnectionType.has_pending_data,,false,107,107,has_pending_data,,,26,int ConnectionType.has_pending_data (void)
98267,METHOD,ConnectionType,TYPE_DECL,int (*process_pending_data)(void);,9,37,connection.h,ConnectionType.process_pending_data,,false,108,108,process_pending_data,,,27,int ConnectionType.process_pending_data (void)
98272,METHOD,ConnectionType,TYPE_DECL,sds (*get_peer_cert)(struct connection *conn);,9,49,connection.h,ConnectionType.get_peer_cert,,false,111,111,get_peer_cert,,,28,sds ConnectionType.get_peer_cert (connection*)
98298,METHOD,<empty>,<empty>,<empty>,1,,connection.h,connListener:<clinit>,,false,131,,<clinit>,,,8,
98306,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    return conn->type->accept(conn, accept_handler);
}",1,1,connection.h,connAccept,,false,159,161,connAccept,,,13,"int connAccept (connection*,ConnectionCallbackFunc)"
98321,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connConnect(connection *conn, const char *addr, int port, const char *src_addr,
        ConnectionCallbackFunc connect_handler) {
    return conn->type->connect(conn, addr, port, src_addr, connect_handler);
}",1,1,connection.h,connConnect,,false,172,175,connConnect,,,14,"int connConnect (connection*,char*,int,char*,ConnectionCallbackFunc)"
98342,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {
    return conn->type->blocking_connect(conn, addr, port, timeout);
}",1,1,connection.h,connBlockingConnect,,false,183,185,connBlockingConnect,,,15,"int connBlockingConnect (connection*,char*,int,long long)"
98361,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connWrite(connection *conn, const void *data, size_t data_len) {
    return conn->type->write(conn, data, data_len);
}",1,1,connection.h,connWrite,,false,194,196,connWrite,,,16,"int connWrite (connection*,void*,size_t)"
98378,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    return conn->type->writev(conn, iov, iovcnt);
}",1,1,connection.h,connWritev,,false,206,208,connWritev,,,17,"int connWritev (connection*,iovec*,int)"
98395,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connRead(connection *conn, void *buf, size_t buf_len) {
    int ret = conn->type->read(conn, buf, buf_len);
    return ret;
}",1,1,connection.h,connRead,,false,218,221,connRead,,,18,"int connRead (connection*,void*,size_t)"
98416,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connSetWriteHandler(connection *conn, ConnectionCallbackFunc func) {
    return conn->type->set_write_handler(conn, func, 0);
}",1,1,connection.h,connSetWriteHandler,,false,226,228,connSetWriteHandler,,,19,"int connSetWriteHandler (connection*,ConnectionCallbackFunc)"
98432,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    return conn->type->set_read_handler(conn, func);
}",1,1,connection.h,connSetReadHandler,,false,233,235,connSetReadHandler,,,20,"int connSetReadHandler (connection*,ConnectionCallbackFunc)"
98447,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connSetWriteHandlerWithBarrier(connection *conn, ConnectionCallbackFunc func, int barrier) {
    return conn->type->set_write_handler(conn, func, barrier);
}",1,1,connection.h,connSetWriteHandlerWithBarrier,,false,242,244,connSetWriteHandlerWithBarrier,,,21,"int connSetWriteHandlerWithBarrier (connection*,ConnectionCallbackFunc,int)"
98464,METHOD,connection.h:<global>,TYPE_DECL,"static inline void connShutdown(connection *conn) {
    conn->type->shutdown(conn);
}",1,1,connection.h,connShutdown,,false,246,248,connShutdown,,,22,void connShutdown (connection*)
98476,METHOD,connection.h:<global>,TYPE_DECL,"static inline void connClose(connection *conn) {
    conn->type->close(conn);
}",1,1,connection.h,connClose,,false,250,252,connClose,,,23,void connClose (connection*)
98488,METHOD,connection.h:<global>,TYPE_DECL,"static inline const char *connGetLastError(connection *conn) {
    return conn->type->get_last_error(conn);
}",1,1,connection.h,connGetLastError,,false,257,259,connGetLastError,,,24,const char* connGetLastError (connection*)
98501,METHOD,connection.h:<global>,TYPE_DECL,"static inline ssize_t connSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_write(conn, ptr, size, timeout);
}",1,1,connection.h,connSyncWrite,,false,261,263,connSyncWrite,,,25,"ssize_t connSyncWrite (connection*,char*,ssize_t,long long)"
98520,METHOD,connection.h:<global>,TYPE_DECL,"static inline ssize_t connSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_read(conn, ptr, size, timeout);
}",1,1,connection.h,connSyncRead,,false,265,267,connSyncRead,,,26,"ssize_t connSyncRead (connection*,char*,ssize_t,long long)"
98539,METHOD,connection.h:<global>,TYPE_DECL,"static inline ssize_t connSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return conn->type->sync_readline(conn, ptr, size, timeout);
}",1,1,connection.h,connSyncReadLine,,false,269,271,connSyncReadLine,,,27,"ssize_t connSyncReadLine (connection*,char*,ssize_t,long long)"
98558,METHOD,connection.h:<global>,TYPE_DECL,"static inline const char *connGetType(connection *conn) {
    return conn->type->get_type(conn);
}",1,1,connection.h,connGetType,,false,274,276,connGetType,,,28,const char* connGetType (connection*)
98571,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connLastErrorRetryable(connection *conn) {
    return conn->last_errno == EINTR;
}",1,1,connection.h,connLastErrorRetryable,,false,278,280,connLastErrorRetryable,,,29,int connLastErrorRetryable (connection*)
98582,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    if (conn && conn->type->addr) {
        return conn->type->addr(conn, ip, ip_len, port, remote);
    }

    return -1;
}",1,1,connection.h,connAddr,,false,284,290,connAddr,,,30,"int connAddr (connection*,char*,size_t,int*,int)"
98615,METHOD,connection.h:<global>,TYPE_DECL,"static inline int formatAddr(char *buf, size_t buf_len, char *ip, int port) {
    return snprintf(buf, buf_len, strchr(ip,':') ?
           ""[%s]:%d"" : ""%s:%d"", ip, port);
}",1,1,connection.h,formatAddr,,false,295,298,formatAddr,,,31,"int formatAddr (char*,size_t,char*,int)"
98635,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connFormatAddr(connection *conn, char *buf, size_t buf_len, int remote)
{
    char ip[CONN_ADDR_STR_LEN];
    int port;

    if (connAddr(conn, ip, sizeof(ip), &port, remote) < 0) {
        return -1;
    }

    return formatAddr(buf, buf_len, ip, port);
}",1,12,connection.h,connFormatAddr,,false,300,310,connFormatAddr,,,32,"int connFormatAddr (connection*,char*,size_t,int)"
98666,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connAddrPeerName(connection *conn, char *ip, size_t ip_len, int *port) {
    return connAddr(conn, ip, ip_len, port, 1);
}",1,1,connection.h,connAddrPeerName,,false,312,314,connAddrPeerName,,,33,"int connAddrPeerName (connection*,char*,size_t,int*)"
98681,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connAddrSockName(connection *conn, char *ip, size_t ip_len, int *port) {
    return connAddr(conn, ip, ip_len, port, 0);
}",1,1,connection.h,connAddrSockName,,false,316,318,connAddrSockName,,,34,"int connAddrSockName (connection*,char*,size_t,int*)"
98696,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connIsLocal(connection *conn) {
    if (conn && conn->type->is_local) {
        return conn->type->is_local(conn);
    }

    return -1;
}",1,1,connection.h,connIsLocal,,false,322,328,connIsLocal,,,35,int connIsLocal (connection*)
98721,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connGetState(connection *conn) {
    return conn->state;
}",1,1,connection.h,connGetState,,false,330,332,connGetState,,,36,int connGetState (connection*)
98730,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connHasWriteHandler(connection *conn) {
    return conn->write_handler != NULL;
}",1,1,connection.h,connHasWriteHandler,,false,335,337,connHasWriteHandler,,,37,int connHasWriteHandler (connection*)
98741,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connHasReadHandler(connection *conn) {
    return conn->read_handler != NULL;
}",1,1,connection.h,connHasReadHandler,,false,340,342,connHasReadHandler,,,38,int connHasReadHandler (connection*)
98752,METHOD,connection.h:<global>,TYPE_DECL,"static inline void connSetPrivateData(connection *conn, void *data) {
    conn->private_data = data;
}",1,1,connection.h,connSetPrivateData,,false,345,347,connSetPrivateData,,,39,"void connSetPrivateData (connection*,void*)"
98763,METHOD,connection.h:<global>,TYPE_DECL,"static inline void *connGetPrivateData(connection *conn) {
    return conn->private_data;
}",1,1,connection.h,connGetPrivateData,,false,350,352,connGetPrivateData,,,40,void* connGetPrivateData (connection*)
98772,METHOD,connection.h:<global>,TYPE_DECL,"static inline const char *connGetInfo(connection *conn, char *buf, size_t buf_len) {
    snprintf(buf, buf_len-1, ""fd=%i"", conn == NULL ? -1 : conn->fd);
    return buf;
}",1,1,connection.h,connGetInfo,,false,359,362,connGetInfo,,,41,"const char* connGetInfo (connection*,char*,size_t)"
98796,METHOD,connection.h:<global>,TYPE_DECL,int connBlock(connection *conn);,5,31,connection.h,connBlock,,false,365,365,connBlock,,,42,int connBlock (connection*)
98801,METHOD,connection.h:<global>,TYPE_DECL,int connNonBlock(connection *conn);,5,34,connection.h,connNonBlock,,false,366,366,connNonBlock,,,43,int connNonBlock (connection*)
98806,METHOD,connection.h:<global>,TYPE_DECL,int connEnableTcpNoDelay(connection *conn);,5,42,connection.h,connEnableTcpNoDelay,,false,367,367,connEnableTcpNoDelay,,,44,int connEnableTcpNoDelay (connection*)
98811,METHOD,connection.h:<global>,TYPE_DECL,int connDisableTcpNoDelay(connection *conn);,5,43,connection.h,connDisableTcpNoDelay,,false,368,368,connDisableTcpNoDelay,,,45,int connDisableTcpNoDelay (connection*)
98816,METHOD,connection.h:<global>,TYPE_DECL,"int connKeepAlive(connection *conn, int interval);",5,49,connection.h,connKeepAlive,,false,369,369,connKeepAlive,,,46,"int connKeepAlive (connection*,int)"
98822,METHOD,connection.h:<global>,TYPE_DECL,"int connSendTimeout(connection *conn, long long ms);",5,51,connection.h,connSendTimeout,,false,370,370,connSendTimeout,,,47,"int connSendTimeout (connection*,long long)"
98828,METHOD,connection.h:<global>,TYPE_DECL,"int connRecvTimeout(connection *conn, long long ms);",5,51,connection.h,connRecvTimeout,,false,371,371,connRecvTimeout,,,48,"int connRecvTimeout (connection*,long long)"
98834,METHOD,connection.h:<global>,TYPE_DECL,"static inline sds connGetPeerCert(connection *conn) {
    if (conn->type->get_peer_cert) {
        return conn->type->get_peer_cert(conn);
    }

    return NULL;
}",1,1,connection.h,connGetPeerCert,,false,374,380,connGetPeerCert,,,49,sds connGetPeerCert (connection*)
98856,METHOD,connection.h:<global>,TYPE_DECL,int connTypeInitialize(void);,5,28,connection.h,connTypeInitialize,,false,383,383,connTypeInitialize,,,50,int connTypeInitialize (void)
98861,METHOD,connection.h:<global>,TYPE_DECL,int connTypeRegister(ConnectionType *ct);,5,40,connection.h,connTypeRegister,,false,386,386,connTypeRegister,,,51,int connTypeRegister (ConnectionType*)
98866,METHOD,connection.h:<global>,TYPE_DECL,ConnectionType *connectionByType(const char *typename);,16,54,connection.h,connectionByType,,false,389,389,connectionByType,,,52,ConnectionType* connectionByType (char*)
98871,METHOD,connection.h:<global>,TYPE_DECL,ConnectionType *connectionTypeTcp(void);,16,39,connection.h,connectionTypeTcp,,false,392,392,connectionTypeTcp,,,53,ConnectionType* connectionTypeTcp (void)
98876,METHOD,connection.h:<global>,TYPE_DECL,ConnectionType *connectionTypeTls(void);,16,39,connection.h,connectionTypeTls,,false,395,395,connectionTypeTls,,,54,ConnectionType* connectionTypeTls (void)
98881,METHOD,connection.h:<global>,TYPE_DECL,ConnectionType *connectionTypeUnix(void);,16,40,connection.h,connectionTypeUnix,,false,398,398,connectionTypeUnix,,,55,ConnectionType* connectionTypeUnix (void)
98886,METHOD,connection.h:<global>,TYPE_DECL,int connectionIndexByType(const char *typename);,5,47,connection.h,connectionIndexByType,,false,401,401,connectionIndexByType,,,56,int connectionIndexByType (char*)
98891,METHOD,connection.h:<global>,TYPE_DECL,"static inline connection *connCreate(ConnectionType *ct) {
    return ct->conn_create();
}",1,1,connection.h,connCreate,,false,404,406,connCreate,,,57,connection connCreate (ConnectionType*)
98901,METHOD,connection.h:<global>,TYPE_DECL,"static inline connection *connCreateAccepted(ConnectionType *ct, int fd, void *priv) {
    return ct->conn_create_accepted(fd, priv);
}",1,1,connection.h,connCreateAccepted,,false,410,412,connCreateAccepted,,,58,"connection connCreateAccepted (ConnectionType*,int,void*)"
98915,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connTypeConfigure(ConnectionType *ct, void *priv, int reconfigure) {
    return ct->configure(priv, reconfigure);
}",1,1,connection.h,connTypeConfigure,,false,417,419,connTypeConfigure,,,59,"int connTypeConfigure (ConnectionType*,void*,int)"
98929,METHOD,connection.h:<global>,TYPE_DECL,void connTypeCleanupAll(void);,6,29,connection.h,connTypeCleanupAll,,false,422,422,connTypeCleanupAll,,,60,void connTypeCleanupAll (void)
98934,METHOD,connection.h:<global>,TYPE_DECL,int connTypeHasPendingData(void);,5,32,connection.h,connTypeHasPendingData,,false,425,425,connTypeHasPendingData,,,61,int connTypeHasPendingData (void)
98939,METHOD,connection.h:<global>,TYPE_DECL,int connTypeProcessPendingData(void);,5,36,connection.h,connTypeProcessPendingData,,false,428,428,connTypeProcessPendingData,,,62,int connTypeProcessPendingData (void)
98944,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connListen(connListener *listener) {
    return listener->ct->listen(listener);
}",1,1,connection.h,connListen,,false,431,433,connListen,,,63,int connListen (connListener*)
98957,METHOD,connection.h:<global>,TYPE_DECL,"static inline aeFileProc *connAcceptHandler(ConnectionType *ct) {
    if (ct)
        return ct->accept_handler;
    return NULL;
}",1,1,connection.h,connAcceptHandler,,false,436,440,connAcceptHandler,,,64,aeFileProc connAcceptHandler (ConnectionType*)
98971,METHOD,connection.h:<global>,TYPE_DECL,sds getListensInfoString(sds info);,5,34,connection.h,getListensInfoString,,false,443,443,getListensInfoString,,,65,sds getListensInfoString (sds)
98976,METHOD,connection.h:<global>,TYPE_DECL,int RedisRegisterConnectionTypeSocket(void);,5,43,connection.h,RedisRegisterConnectionTypeSocket,,false,445,445,RedisRegisterConnectionTypeSocket,,,66,int RedisRegisterConnectionTypeSocket (void)
98981,METHOD,connection.h:<global>,TYPE_DECL,int RedisRegisterConnectionTypeUnix(void);,5,41,connection.h,RedisRegisterConnectionTypeUnix,,false,446,446,RedisRegisterConnectionTypeUnix,,,67,int RedisRegisterConnectionTypeUnix (void)
98986,METHOD,connection.h:<global>,TYPE_DECL,int RedisRegisterConnectionTypeTLS(void);,5,40,connection.h,RedisRegisterConnectionTypeTLS,,false,447,447,RedisRegisterConnectionTypeTLS,,,68,int RedisRegisterConnectionTypeTLS (void)
98991,METHOD,connection.h:<global>,TYPE_DECL,"static inline int connIsTLS(connection *conn) {
    return conn && conn->type == connectionTypeTls();
}",1,1,connection.h,connIsTLS,,false,450,452,connIsTLS,,,69,int connIsTLS (connection*)
99009,METHOD,connhelpers.h:<global>,TYPE_DECL,<global>,1,1,connhelpers.h,connhelpers.h:<global>,,false,1,88,<global>,,,1,
99011,METHOD,connhelpers.h:<global>,TYPE_DECL,"static inline void connIncrRefs(connection *conn) {
    conn->refs++;
}",1,1,connhelpers.h,connIncrRefs,,false,52,54,connIncrRefs,,,1,void connIncrRefs (connection*)
99020,METHOD,connhelpers.h:<global>,TYPE_DECL,"static inline void connDecrRefs(connection *conn) {
    conn->refs--;
}",1,1,connhelpers.h,connDecrRefs,,false,64,66,connDecrRefs,,,2,void connDecrRefs (connection*)
99029,METHOD,connhelpers.h:<global>,TYPE_DECL,"static inline int connHasRefs(connection *conn) {
    return conn->refs;
}",1,1,connhelpers.h,connHasRefs,,false,68,70,connHasRefs,,,3,int connHasRefs (connection*)
99038,METHOD,connhelpers.h:<global>,TYPE_DECL,"static inline int callHandler(connection *conn, ConnectionCallbackFunc handler) {
    connIncrRefs(conn);
    if (handler) handler(conn);
    connDecrRefs(conn);
    if (conn->flags & CONN_FLAG_CLOSE_SCHEDULED) {
        if (!connHasRefs(conn)) connClose(conn);
        return 0;
    }
    return 1;
}",1,22,connhelpers.h,callHandler,,false,77,86,callHandler,,,4,"int callHandler (connection*,ConnectionCallbackFunc)"
99080,METHOD,crc16.c:<global>,TYPE_DECL,<global>,1,1,server.h,crc16.c:<global>,,false,1,88,<global>,,,1,
99342,METHOD,crc16.c:<global>,TYPE_DECL,"uint16_t crc16(const char *buf, int len) {
    int counter;
    uint16_t crc = 0;
    for (counter = 0; counter < len; counter++)
            crc = (crc<<8) ^ crc16tab[((crc>>8) ^ *buf++)&0x00FF];
    return crc;
}",1,1,crc16.c,crc16,,false,82,88,crc16,,,3,"uint16_t crc16 (char*,int)"
99385,METHOD,crc16_slottable.h:<global>,TYPE_DECL,<global>,1,7,crc16_slottable.h,crc16_slottable.h:<global>,,false,1,834,<global>,,,1,
100401,METHOD,crc64.c:<global>,TYPE_DECL,<global>,1,1,crc64.c,crc64.c:<global>,,false,1,161,<global>,,,1,
100409,METHOD,crc64.c:<global>,TYPE_DECL,"static inline uint_fast64_t crc_reflect(uint_fast64_t data, size_t data_len) {
    uint_fast64_t ret = data & 0x01;

    for (size_t i = 1; i < data_len; i++) {
        data >>= 1;
        ret = (ret << 1) | (data & 0x01);
    }

    return ret;
}",1,1,crc64.c,crc_reflect,,false,69,78,crc_reflect,,,3,"uint_fast64_t crc_reflect (uint_fast64_t,size_t)"
100447,METHOD,crc64.c:<global>,TYPE_DECL,"uint64_t _crc64(uint_fast64_t crc, const void *in_data, const uint64_t len) {
    const uint8_t *data = in_data;
    unsigned long long bit;

    for (uint64_t offset = 0; offset < len; offset++) {
        uint8_t c = data[offset];
        for (uint_fast8_t i = 0x01; i & 0xff; i <<= 1) {
            bit = crc & 0x8000000000000000;
            if (c & i) {
                bit = !bit;
            }

            crc <<= 1;
            if (bit) {
                crc ^= POLY;
            }
        }

        crc &= 0xffffffffffffffff;
    }

    crc = crc & 0xffffffffffffffff;
    return crc_reflect(crc, 64) ^ 0x0000000000000000;
}",1,23,crc64.c,_crc64,,false,88,111,_crc64,,,4,"uint64_t _crc64 (uint_fast64_t,void*,uint64_t)"
100530,METHOD,crc64.c:<global>,TYPE_DECL,"void crc64_init(void) {
    crcspeed64native_init(_crc64, crc64_table);
}",1,1,crc64.c,crc64_init,,false,116,118,crc64_init,,,5,void crc64_init (void)
100538,METHOD,crc64.c:<global>,TYPE_DECL,"uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
    return crcspeed64native(crc64_table, crc, (void *) s, l);
}",1,1,crc64.c,crc64,,false,121,123,crc64,,,6,"uint64_t crc64 (uint64_t,unsigned char*,uint64_t)"
100558,METHOD,crc64.h:<global>,TYPE_DECL,<global>,1,6,crc64.h,crc64.h:<global>,,false,1,13,<global>,,,1,
100560,METHOD,crc64.h:<global>,TYPE_DECL,void crc64_init(void);,6,21,crc64.h,crc64_init,,false,6,6,crc64_init,,,1,void crc64_init (void)
100565,METHOD,crc64.h:<global>,TYPE_DECL,"uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);",10,64,crc64.h,crc64,,false,7,7,crc64,,,2,"uint64_t crc64 (uint64_t,unsigned char*,uint64_t)"
100577,METHOD,crcspeed.c:<global>,TYPE_DECL,<global>,1,1,crcspeed.c,crcspeed.c:<global>,,false,1,282,<global>,,,1,
100579,METHOD,crcspeed.c:<global>,TYPE_DECL,"void crcspeed64little_init(crcfn64 crcfn, uint64_t table[8][256]) {
    uint64_t crc;

    /* generate CRCs for all single byte sequences */
    for (int n = 0; n < 256; n++) {
        unsigned char v = n;
        table[0][n] = crcfn(0, &v, 1);
    }

    /* generate nested CRC table for future slice-by-8 lookup */
    for (int n = 0; n < 256; n++) {
        crc = table[0][n];
        for (int k = 1; k < 8; k++) {
            crc = table[0][crc & 0xff] ^ (crc >> 8);
            table[k][n] = crc;
        }
    }
}",1,1,crcspeed.c,crcspeed64little_init,,false,33,50,crcspeed64little_init,,,1,"void crcspeed64little_init (crcfn64,uint64_t[8][256])"
100664,METHOD,crcspeed.c:<global>,TYPE_DECL,"void crcspeed16little_init(crcfn16 crcfn, uint16_t table[8][256]) {
    uint16_t crc;

    /* generate CRCs for all single byte sequences */
    for (int n = 0; n < 256; n++) {
        table[0][n] = crcfn(0, &n, 1);
    }

    /* generate nested CRC table for future slice-by-8 lookup */
    for (int n = 0; n < 256; n++) {
        crc = table[0][n];
        for (int k = 1; k < 8; k++) {
            crc = table[0][(crc >> 8) & 0xff] ^ (crc << 8);
            table[k][n] = crc;
        }
    }
}",1,1,crcspeed.c,crcspeed16little_init,,false,52,68,crcspeed16little_init,,,2,"void crcspeed16little_init (crcfn16,uint16_t[8][256])"
100747,METHOD,crcspeed.c:<global>,TYPE_DECL,"static inline uint64_t rev8(uint64_t a) {
#if defined(__GNUC__) || defined(__clang__)
    return __builtin_bswap64(a);
#else
    uint64_t m;

    m = UINT64_C(0xff00ff00ff00ff);
    a = ((a >> 8) & m) | (a & m) << 8;
    m = UINT64_C(0xffff0000ffff);
    a = ((a >> 16) & m) | (a & m) << 16;
    return a >> 32 | a << 32;
#endif
}",1,1,crcspeed.c,rev8,,false,71,83,rev8,,,3,uint64_t rev8 (uint64_t)
100795,METHOD,crcspeed.c:<global>,TYPE_DECL,"void crcspeed64big_init(crcfn64 fn, uint64_t big_table[8][256]) {
    /* Create the little endian table then reverse all the entries. */
    crcspeed64little_init(fn, big_table);
    for (int k = 0; k < 8; k++) {
        for (int n = 0; n < 256; n++) {
            big_table[k][n] = rev8(big_table[k][n]);
        }
    }
}",1,1,crcspeed.c,crcspeed64big_init,,false,87,95,crcspeed64big_init,,,4,"void crcspeed64big_init (crcfn64,uint64_t[8][256])"
100840,METHOD,crcspeed.c:<global>,TYPE_DECL,"void crcspeed16big_init(crcfn16 fn, uint16_t big_table[8][256]) {
    /* Create the little endian table then reverse all the entries. */
    crcspeed16little_init(fn, big_table);
    for (int k = 0; k < 8; k++) {
        for (int n = 0; n < 256; n++) {
            big_table[k][n] = rev8(big_table[k][n]);
        }
    }
}",1,1,crcspeed.c,crcspeed16big_init,,false,97,105,crcspeed16big_init,,,5,"void crcspeed16big_init (crcfn16,uint16_t[8][256])"
100885,METHOD,crcspeed.c:<global>,TYPE_DECL,"uint64_t crcspeed64little(uint64_t little_table[8][256], uint64_t crc,
                          void *buf, size_t len) {
    unsigned char *next = buf;

    /* process individual bytes until we reach an 8-byte aligned pointer */
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = little_table[0][(crc ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    /* fast middle processing, 8 bytes (aligned!) per loop */
    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = little_table[7][crc & 0xff] ^
              little_table[6][(crc >> 8) & 0xff] ^
              little_table[5][(crc >> 16) & 0xff] ^
              little_table[4][(crc >> 24) & 0xff] ^
              little_table[3][(crc >> 32) & 0xff] ^
              little_table[2][(crc >> 40) & 0xff] ^
              little_table[1][(crc >> 48) & 0xff] ^
              little_table[0][crc >> 56];
        next += 8;
        len -= 8;
    }

    /* process remaining bytes (can't be larger than 8) */
    while ...",1,1,crcspeed.c,crcspeed64little,,false,112,144,crcspeed64little,,,6,"uint64_t crcspeed64little (uint64_t[8][256],uint64_t,void*,size_t)"
101045,METHOD,crcspeed.c:<global>,TYPE_DECL,"uint16_t crcspeed16little(uint16_t little_table[8][256], uint16_t crc,
                          void *buf, size_t len) {
    unsigned char *next = buf;

    /* process individual bytes until we reach an 8-byte aligned pointer */
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = little_table[0][((crc >> 8) ^ *next++) & 0xff] ^ (crc << 8);
        len--;
    }

    /* fast middle processing, 8 bytes (aligned!) per loop */
    while (len >= 8) {
        uint64_t n = *(uint64_t *)next;
        crc = little_table[7][(n & 0xff) ^ ((crc >> 8) & 0xff)] ^
              little_table[6][((n >> 8) & 0xff) ^ (crc & 0xff)] ^
              little_table[5][(n >> 16) & 0xff] ^
              little_table[4][(n >> 24) & 0xff] ^
              little_table[3][(n >> 32) & 0xff] ^
              little_table[2][(n >> 40) & 0xff] ^
              little_table[1][(n >> 48) & 0xff] ^
              little_table[0][n >> 56];
        next += 8;
        len -= 8;
    }

    /* process remaining bytes ...",1,1,crcspeed.c,crcspeed16little,,false,146,178,crcspeed16little,,,7,"uint16_t crcspeed16little (uint16_t[8][256],uint16_t,void*,size_t)"
101220,METHOD,crcspeed.c:<global>,TYPE_DECL,"uint64_t crcspeed64big(uint64_t big_table[8][256], uint64_t crc, void *buf,
                       size_t len) {
    unsigned char *next = buf;

    crc = rev8(crc);
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = big_table[0][(crc >> 56) ^ *next++] ^ (crc << 8);
        len--;
    }

    while (len >= 8) {
        crc ^= *(uint64_t *)next;
        crc = big_table[0][crc & 0xff] ^
              big_table[1][(crc >> 8) & 0xff] ^
              big_table[2][(crc >> 16) & 0xff] ^
              big_table[3][(crc >> 24) & 0xff] ^
              big_table[4][(crc >> 32) & 0xff] ^
              big_table[5][(crc >> 40) & 0xff] ^
              big_table[6][(crc >> 48) & 0xff] ^
              big_table[7][crc >> 56];
        next += 8;
        len -= 8;
    }

    while (len) {
        crc = big_table[0][(crc >> 56) ^ *next++] ^ (crc << 8);
        len--;
    }

    return rev8(crc);
}",1,1,crcspeed.c,crcspeed64big,,false,183,213,crcspeed64big,,,8,"uint64_t crcspeed64big (uint64_t[8][256],uint64_t,void*,size_t)"
101385,METHOD,crcspeed.c:<global>,TYPE_DECL,"uint16_t crcspeed16big(uint16_t big_table[8][256], uint16_t crc_in, void *buf,
                       size_t len) {
    unsigned char *next = buf;
    uint64_t crc = crc_in;

    crc = rev8(crc);
    while (len && ((uintptr_t)next & 7) != 0) {
        crc = big_table[0][((crc >> (56 - 8)) ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    while (len >= 8) {
        uint64_t n = *(uint64_t *)next;
        crc = big_table[0][(n & 0xff) ^ ((crc >> (56 - 8)) & 0xff)] ^
              big_table[1][((n >> 8) & 0xff) ^ (crc & 0xff)] ^
              big_table[2][(n >> 16) & 0xff] ^
              big_table[3][(n >> 24) & 0xff] ^
              big_table[4][(n >> 32) & 0xff] ^
              big_table[5][(n >> 40) & 0xff] ^
              big_table[6][(n >> 48) & 0xff] ^
              big_table[7][n >> 56];
        next += 8;
        len -= 8;
    }

    while (len) {
        crc = big_table[0][((crc >> (56 - 8)) ^ *next++) & 0xff] ^ (crc >> 8);
        len--;
    }

    return rev8(crc);
}",1,1,crcspeed.c,crcspeed16big,,false,216,247,crcspeed16big,,,9,"uint16_t crcspeed16big (uint16_t[8][256],uint16_t,void*,size_t)"
101575,METHOD,crcspeed.c:<global>,TYPE_DECL,"uint64_t crcspeed64native(uint64_t table[8][256], uint64_t crc, void *buf,
                          size_t len) {
    uint64_t n = 1;

    return *(char *)&n ? crcspeed64little(table, crc, buf, len)
                       : crcspeed64big(table, crc, buf, len);
}",1,1,crcspeed.c,crcspeed64native,,false,253,259,crcspeed64native,,,10,"uint64_t crcspeed64native (uint64_t[8][256],uint64_t,void*,size_t)"
101604,METHOD,crcspeed.c:<global>,TYPE_DECL,"uint16_t crcspeed16native(uint16_t table[8][256], uint16_t crc, void *buf,
                          size_t len) {
    uint64_t n = 1;

    return *(char *)&n ? crcspeed16little(table, crc, buf, len)
                       : crcspeed16big(table, crc, buf, len);
}",1,1,crcspeed.c,crcspeed16native,,false,261,267,crcspeed16native,,,11,"uint16_t crcspeed16native (uint16_t[8][256],uint16_t,void*,size_t)"
101633,METHOD,crcspeed.c:<global>,TYPE_DECL,"void crcspeed64native_init(crcfn64 fn, uint64_t table[8][256]) {
    uint64_t n = 1;

    *(char *)&n ? crcspeed64little_init(fn, table)
                : crcspeed64big_init(fn, table);
}",1,1,crcspeed.c,crcspeed64native_init,,false,270,275,crcspeed64native_init,,,12,"void crcspeed64native_init (crcfn64,uint64_t[8][256])"
101655,METHOD,crcspeed.c:<global>,TYPE_DECL,"void crcspeed16native_init(crcfn16 fn, uint16_t table[8][256]) {
    uint64_t n = 1;

    *(char *)&n ? crcspeed16little_init(fn, table)
                : crcspeed16big_init(fn, table);
}",1,1,crcspeed.c,crcspeed16native_init,,false,277,282,crcspeed16native_init,,,13,"void crcspeed16native_init (crcfn16,uint16_t[8][256])"
101684,METHOD,crcspeed.h:<global>,TYPE_DECL,<global>,1,6,crcspeed.h,crcspeed.h:<global>,,false,1,60,<global>,,,1,
101686,METHOD,crcspeed.h:<global>,TYPE_DECL,"typedef uint64_t (*crcfn64)(uint64_t, const void *, const uint64_t);",18,67,crcspeed.h,crcfn64,,false,34,34,crcfn64,,,1,"uint64_t crcfn64 (ANY,void*,const)"
101693,METHOD,crcspeed.h:<global>,TYPE_DECL,"typedef uint16_t (*crcfn16)(uint16_t, const void *, const uint64_t);",18,67,crcspeed.h,crcfn16,,false,35,35,crcfn16,,,2,"uint16_t crcfn16 (ANY,void*,const)"
101700,METHOD,crcspeed.h:<global>,TYPE_DECL,"void crcspeed64little_init(crcfn64 fn, uint64_t table[8][256]);",6,62,crcspeed.h,crcspeed64little_init,,false,38,38,crcspeed64little_init,,,3,"void crcspeed64little_init (crcfn64,uint64_t[8][256])"
101706,METHOD,crcspeed.h:<global>,TYPE_DECL,"void crcspeed64big_init(crcfn64 fn, uint64_t table[8][256]);",6,59,crcspeed.h,crcspeed64big_init,,false,39,39,crcspeed64big_init,,,4,"void crcspeed64big_init (crcfn64,uint64_t[8][256])"
101712,METHOD,crcspeed.h:<global>,TYPE_DECL,"void crcspeed64native_init(crcfn64 fn, uint64_t table[8][256]);",6,62,crcspeed.h,crcspeed64native_init,,false,40,40,crcspeed64native_init,,,5,"void crcspeed64native_init (crcfn64,uint64_t[8][256])"
101718,METHOD,crcspeed.h:<global>,TYPE_DECL,"uint64_t crcspeed64little(uint64_t table[8][256], uint64_t crc, void *buf,
                          size_t len);",10,37,crcspeed.h,crcspeed64little,,false,42,43,crcspeed64little,,,6,"uint64_t crcspeed64little (uint64_t[8][256],uint64_t,void*,size_t)"
101726,METHOD,crcspeed.h:<global>,TYPE_DECL,"uint64_t crcspeed64big(uint64_t table[8][256], uint64_t crc, void *buf,
                       size_t len);",10,34,crcspeed.h,crcspeed64big,,false,44,45,crcspeed64big,,,7,"uint64_t crcspeed64big (uint64_t[8][256],uint64_t,void*,size_t)"
101734,METHOD,crcspeed.h:<global>,TYPE_DECL,"uint64_t crcspeed64native(uint64_t table[8][256], uint64_t crc, void *buf,
                          size_t len);",10,37,crcspeed.h,crcspeed64native,,false,46,47,crcspeed64native,,,8,"uint64_t crcspeed64native (uint64_t[8][256],uint64_t,void*,size_t)"
101742,METHOD,crcspeed.h:<global>,TYPE_DECL,"void crcspeed16little_init(crcfn16 fn, uint16_t table[8][256]);",6,62,crcspeed.h,crcspeed16little_init,,false,50,50,crcspeed16little_init,,,9,"void crcspeed16little_init (crcfn16,uint16_t[8][256])"
101748,METHOD,crcspeed.h:<global>,TYPE_DECL,"void crcspeed16big_init(crcfn16 fn, uint16_t table[8][256]);",6,59,crcspeed.h,crcspeed16big_init,,false,51,51,crcspeed16big_init,,,10,"void crcspeed16big_init (crcfn16,uint16_t[8][256])"
101754,METHOD,crcspeed.h:<global>,TYPE_DECL,"void crcspeed16native_init(crcfn16 fn, uint16_t table[8][256]);",6,62,crcspeed.h,crcspeed16native_init,,false,52,52,crcspeed16native_init,,,11,"void crcspeed16native_init (crcfn16,uint16_t[8][256])"
101760,METHOD,crcspeed.h:<global>,TYPE_DECL,"uint16_t crcspeed16little(uint16_t table[8][256], uint16_t crc, void *buf,
                          size_t len);",10,37,crcspeed.h,crcspeed16little,,false,54,55,crcspeed16little,,,12,"uint16_t crcspeed16little (uint16_t[8][256],uint16_t,void*,size_t)"
101768,METHOD,crcspeed.h:<global>,TYPE_DECL,"uint16_t crcspeed16big(uint16_t table[8][256], uint16_t crc, void *buf,
                       size_t len);",10,34,crcspeed.h,crcspeed16big,,false,56,57,crcspeed16big,,,13,"uint16_t crcspeed16big (uint16_t[8][256],uint16_t,void*,size_t)"
101776,METHOD,crcspeed.h:<global>,TYPE_DECL,"uint16_t crcspeed16native(uint16_t table[8][256], uint16_t crc, void *buf,
                          size_t len);",10,37,crcspeed.h,crcspeed16native,,false,58,59,crcspeed16native,,,14,"uint16_t crcspeed16native (uint16_t[8][256],uint16_t,void*,size_t)"
101803,METHOD,db.c:<global>,TYPE_DECL,<global>,1,1,db.c,db.c:<global>,,false,1,2557,<global>,,,1,
101805,METHOD,db.c:<global>,TYPE_DECL,"int expireIfNeeded(redisDb *db, robj *key, int flags);",5,53,db.c,expireIfNeeded,,false,48,48,expireIfNeeded,,,1,"int expireIfNeeded (redisDb*,robj*,int)"
101812,METHOD,db.c:<global>,TYPE_DECL,"int keyIsExpired(redisDb *db, robj *key);",5,40,db.c,keyIsExpired,,false,49,49,keyIsExpired,,,2,"int keyIsExpired (redisDb*,robj*)"
101818,METHOD,db.c:<global>,TYPE_DECL,"static void dbSetValue(redisDb *db, robj *key, robj *val, int overwrite, dictEntry *de);",13,87,db.c,dbSetValue,,false,50,50,dbSetValue,,,3,"void dbSetValue (redisDb*,robj*,robj*,int,dictEntry*)"
101827,METHOD,db.c:<global>,TYPE_DECL,"void updateLFU(robj *val) {
    unsigned long counter = LFUDecrAndReturn(val);
    counter = LFULogIncr(counter);
    val->lru = (LFUGetTimeInMinutes()<<8) | counter;
}",1,1,db.c,updateLFU,,false,55,59,updateLFU,,,4,void updateLFU (robj*)
101850,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKey(redisDb *db, robj *key, int flags) {
    dictEntry *de = dictFind(db->dict,key->ptr);
    robj *val = NULL;
    if (de) {
        val = dictGetVal(de);
        /* Forcing deletion of expired keys on a replica makes the replica
         * inconsistent with the master. We forbid it on readonly replicas, but
         * we have to allow it on writable replicas to make write commands
         * behave consistently.
         *
         * It's possible that the WRITE flag is set even during a readonly
         * command, since the command may trigger events that cause modules to
         * perform additional writes. */
        int is_ro_replica = server.masterhost && server.repl_slave_ro;
        int expire_flags = 0;
        if (flags & LOOKUP_WRITE && !is_ro_replica)
            expire_flags |= EXPIRE_FORCE_DELETE_EXPIRED;
        if (flags & LOOKUP_NOEXPIRE)
            expire_flags |= EXPIRE_AVOID_DELETE_EXPIRED;
        if (expireIfNeeded(db, key, expire_flags)) {
    ...",1,20,db.c,lookupKey,,false,88,140,lookupKey,,,5,"robj lookupKey (redisDb*,robj*,int)"
102073,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags) {
    serverAssert(!(flags & LOOKUP_WRITE));
    return lookupKey(db, key, flags);
}",1,4,db.c,lookupKeyReadWithFlags,,false,151,154,lookupKeyReadWithFlags,,,6,"robj lookupKeyReadWithFlags (redisDb*,robj*,int)"
102104,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKeyRead(redisDb *db, robj *key) {
    return lookupKeyReadWithFlags(db,key,LOOKUP_NONE);
}",1,41,db.c,lookupKeyRead,,false,158,160,lookupKeyRead,,,7,"robj lookupKeyRead (redisDb*,robj*)"
102117,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags) {
    return lookupKey(db, key, flags | LOOKUP_WRITE);
}",1,38,db.c,lookupKeyWriteWithFlags,,false,168,170,lookupKeyWriteWithFlags,,,8,"robj lookupKeyWriteWithFlags (redisDb*,robj*,int)"
102135,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKeyWrite(redisDb *db, robj *key) {
    return lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);
}",1,44,db.c,lookupKeyWrite,,false,172,174,lookupKeyWrite,,,9,"robj lookupKeyWrite (redisDb*,robj*)"
102148,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply) {
    robj *o = lookupKeyRead(c->db, key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",1,1,db.c,lookupKeyReadOrReply,,false,176,180,lookupKeyReadOrReply,,,10,"robj lookupKeyReadOrReply (client*,robj*,robj*)"
102172,METHOD,db.c:<global>,TYPE_DECL,"robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply) {
    robj *o = lookupKeyWrite(c->db, key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",1,1,db.c,lookupKeyWriteOrReply,,false,182,186,lookupKeyWriteOrReply,,,11,"robj lookupKeyWriteOrReply (client*,robj*,robj*)"
102196,METHOD,db.c:<global>,TYPE_DECL,"static void dbAddInternal(redisDb *db, robj *key, robj *val, int update_if_existing) {
    dictEntry *existing;
    dictEntry *de = dictAddRaw(db->dict, key->ptr, &existing);
    if (update_if_existing && existing) {
        dbSetValue(db, key, val, 1, existing);
        return;
    }
    serverAssertWithInfo(NULL, key, de != NULL);
    dictSetKey(db->dict, de, sdsdup(key->ptr));
    initObjectLRUOrLFU(val);
    dictSetVal(db->dict, de, val);
    signalKeyAsReady(db, key, val->type);
    if (server.cluster_enabled) slotToKeyAddEntry(de, db);
    notifyKeyspaceEvent(NOTIFY_NEW,""new"",key,db->id);
}",1,4,db.c,dbAddInternal,,false,193,207,dbAddInternal,,,12,"void dbAddInternal (redisDb*,robj*,robj*,int)"
102291,METHOD,db.c:<global>,TYPE_DECL,"void dbAdd(redisDb *db, robj *key, robj *val) {
    dbAddInternal(db, key, val, 0);
}",1,1,db.c,dbAdd,,false,209,211,dbAdd,,,13,"void dbAdd (redisDb*,robj*,robj*)"
102303,METHOD,db.c:<global>,TYPE_DECL,"int dbAddRDBLoad(redisDb *db, sds key, robj *val) {
    dictEntry *de = dictAddRaw(db->dict, key, NULL);
    if (de == NULL) return 0;
    initObjectLRUOrLFU(val);
    dictSetVal(db->dict, de, val);
    if (server.cluster_enabled) slotToKeyAddEntry(de, db);
    return 1;
}",1,1,db.c,dbAddRDBLoad,,false,224,231,dbAddRDBLoad,,,14,"int dbAddRDBLoad (redisDb*,sds,robj*)"
102344,METHOD,db.c:<global>,TYPE_DECL,"static void dbSetValue(redisDb *db, robj *key, robj *val, int overwrite, dictEntry *de) {
    if (!de) de = dictFind(db->dict,key->ptr);
    serverAssertWithInfo(NULL,key,de != NULL);
    robj *old = dictGetVal(de);

    val->lru = old->lru;

    if (overwrite) {
        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we
         * need to incr to retain old */
        incrRefCount(old);
        /* Although the key is not really deleted from the database, we regard
         * overwrite as two steps of unlink+add, so we still need to call the unlink
         * callback of the module. */
        moduleNotifyKeyUnlink(key,old,db->id,DB_FLAG_KEY_OVERWRITE);
        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */
        signalDeletedKeyAsReady(db,key,old->type);
        decrRefCount(old);
        /* Because of RM_StringDMA, old may be changed, so we need get old again */
        old = dictGetVal(de);
    }
    dictSetVal(db-...",1,4,db.c,dbSetValue,,false,245,274,dbSetValue,,,15,"void dbSetValue (redisDb*,robj*,robj*,int,dictEntry*)"
102457,METHOD,db.c:<global>,TYPE_DECL,"void dbReplaceValue(redisDb *db, robj *key, robj *val) {
    dbSetValue(db, key, val, 0, NULL);
}",1,1,db.c,dbReplaceValue,,false,278,280,dbReplaceValue,,,16,"void dbReplaceValue (redisDb*,robj*,robj*)"
102470,METHOD,db.c:<global>,TYPE_DECL,"void setKey(client *c, redisDb *db, robj *key, robj *val, int flags) {
    int keyfound = 0;

    if (flags & SETKEY_ALREADY_EXIST)
        keyfound = 1;
    else if (flags & SETKEY_ADD_OR_UPDATE)
        keyfound = -1;
    else if (!(flags & SETKEY_DOESNT_EXIST))
        keyfound = (lookupKeyWrite(db,key) != NULL);

    if (!keyfound) {
        dbAdd(db,key,val);
    } else if (keyfound<0) {
        dbAddInternal(db,key,val,1);
    } else {
        dbSetValue(db,key,val,1,NULL);
    }
    incrRefCount(val);
    if (!(flags & SETKEY_KEEPTTL)) removeExpire(db,key);
    if (!(flags & SETKEY_NO_SIGNAL)) signalModifiedKey(c,db,key);
}",1,16,db.c,setKey,,false,295,315,setKey,,,17,"void setKey (client*,redisDb*,robj*,robj*,int)"
102576,METHOD,db.c:<global>,TYPE_DECL,"robj *dbRandomKey(redisDb *db) {
    dictEntry *de;
    int maxtries = 100;
    int allvolatile = dictSize(db->dict) == dictSize(db->expires);

    while(1) {
        sds key;
        robj *keyobj;

        de = dictGetFairRandomKey(db->dict);
        if (de == NULL) return NULL;

        key = dictGetKey(de);
        keyobj = createStringObject(key,sdslen(key));
        if (dictFind(db->expires,key)) {
            if (allvolatile && server.masterhost && --maxtries == 0) {
                /* If the DB is composed only of keys with an expire set,
                 * it could happen that all the keys are already logically
                 * expired in the slave, so the function cannot stop because
                 * expireIfNeeded() is false, nor it can stop because
                 * dictGetFairRandomKey() returns NULL (there are keys to return).
                 * To prevent the infinite loop we do some tries, but if there
                 * are the conditions for an infinite loop, e...",1,22,db.c,dbRandomKey,,false,321,354,dbRandomKey,,,18,robj dbRandomKey (redisDb*)
102690,METHOD,db.c:<global>,TYPE_DECL,"int dbGenericDelete(redisDb *db, robj *key, int async, int flags) {
    dictEntry **plink;
    int table;
    dictEntry *de = dictTwoPhaseUnlinkFind(db->dict,key->ptr,&plink,&table);
    if (de) {
        robj *val = dictGetVal(de);
        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we
         * need to incr to retain val */
        incrRefCount(val);
        /* Tells the module that the key has been unlinked from the database. */
        moduleNotifyKeyUnlink(key,val,db->id,flags);
        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */
        signalDeletedKeyAsReady(db,key,val->type);
        /* We should call decr before freeObjAsync. If not, the refcount may be
         * greater than 1, so freeObjAsync doesn't work */
        decrRefCount(val);
        if (async) {
            /* Because of dbUnshareStringValue, the val in de may change. */
            freeObjAsync(key, dictGetVal(de), db->id);
            di...",1,12,db.c,dbGenericDelete,,false,357,388,dbGenericDelete,,,19,"int dbGenericDelete (redisDb*,robj*,int,int)"
102807,METHOD,db.c:<global>,TYPE_DECL,"int dbSyncDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, 0, DB_FLAG_KEY_DELETED);
}",1,39,db.c,dbSyncDelete,,false,391,393,dbSyncDelete,,,20,"int dbSyncDelete (redisDb*,robj*)"
102823,METHOD,db.c:<global>,TYPE_DECL,"int dbAsyncDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, 1, DB_FLAG_KEY_DELETED);
}",1,39,db.c,dbAsyncDelete,,false,397,399,dbAsyncDelete,,,21,"int dbAsyncDelete (redisDb*,robj*)"
102839,METHOD,db.c:<global>,TYPE_DECL,"int dbDelete(redisDb *db, robj *key) {
    return dbGenericDelete(db, key, server.lazyfree_lazy_server_del, DB_FLAG_KEY_DELETED);
}",1,69,db.c,dbDelete,,false,403,405,dbDelete,,,22,"int dbDelete (redisDb*,robj*)"
102857,METHOD,db.c:<global>,TYPE_DECL,"robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {
    serverAssert(o->type == OBJ_STRING);
    if (o->refcount != 1 || o->encoding != OBJ_ENCODING_RAW) {
        robj *decoded = getDecodedObject(o);
        o = createRawStringObject(decoded->ptr, sdslen(decoded->ptr));
        decrRefCount(decoded);
        dbReplaceValue(db,key,o);
    }
    return o;
}",1,4,db.c,dbUnshareStringValue,,false,434,443,dbUnshareStringValue,,,23,"robj dbUnshareStringValue (redisDb*,robj*,robj*)"
102920,METHOD,db.c:<global>,TYPE_DECL,"long long emptyDbStructure(redisDb *dbarray, int dbnum, int async,
                           void(callback)(dict*))
{
    long long removed = 0;
    int startdb, enddb;

    if (dbnum == -1) {
        startdb = 0;
        enddb = server.dbnum-1;
    } else {
        startdb = enddb = dbnum;
    }

    for (int j = startdb; j <= enddb; j++) {
        removed += dictSize(dbarray[j].dict);
        if (async) {
            emptyDbAsync(&dbarray[j]);
        } else {
            dictEmpty(dbarray[j].dict,callback);
            dictEmpty(dbarray[j].expires,callback);
        }
        /* Because all keys of database are removed, reset average ttl. */
        dbarray[j].avg_ttl = 0;
        dbarray[j].expires_cursor = 0;
    }

    return removed;
}",1,19,db.c,emptyDbStructure,,false,451,478,emptyDbStructure,,,24,"long long emptyDbStructure (redisDb*,int,int,void)"
103037,METHOD,db.c:<global>,TYPE_DECL,"long long emptyData(int dbnum, int flags, void(callback)(dict*)) {
    int async = (flags & EMPTYDB_ASYNC);
    int with_functions = !(flags & EMPTYDB_NOFUNCTIONS);
    RedisModuleFlushInfoV1 fi = {REDISMODULE_FLUSHINFO_VERSION,!async,dbnum};
    long long removed = 0;

    if (dbnum < -1 || dbnum >= server.dbnum) {
        errno = EINVAL;
        return -1;
    }

    /* Fire the flushdb modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_FLUSHDB,
                          REDISMODULE_SUBEVENT_FLUSHDB_START,
                          &fi);

    /* Make sure the WATCHed keys are affected by the FLUSH* commands.
     * Note that we need to call the function while the keys are still
     * there. */
    signalFlushedDb(dbnum, async);

    /* Empty redis database structure. */
    removed = emptyDbStructure(server.db, dbnum, async, callback);

    /* Flush slots to keys map if enable cluster, we can flush entire
     * slots to keys map whatever dbnum because only support one...",1,25,db.c,emptyData,,false,495,538,emptyData,,,25,"long long emptyData (int,int,void)"
103167,METHOD,db.c:<global>,TYPE_DECL,"redisDb *initTempDb(void) {
    redisDb *tempDb = zcalloc(sizeof(redisDb)*server.dbnum);
    for (int i=0; i<server.dbnum; i++) {
        tempDb[i].dict = dictCreate(&dbDictType);
        tempDb[i].expires = dictCreate(&dbExpiresDictType);
        tempDb[i].slots_to_keys = NULL;
    }

    if (server.cluster_enabled) {
        /* Prepare temp slot to key map to be written during async diskless replication. */
        slotToKeyInit(tempDb);
    }

    return tempDb;
}",1,1,db.c,initTempDb,,false,541,555,initTempDb,,,26,redisDb initTempDb (void)
103230,METHOD,db.c:<global>,TYPE_DECL,"void discardTempDb(redisDb *tempDb, void(callback)(dict*)) {
    int async = 1;

    /* Release temp DBs. */
    emptyDbStructure(tempDb, -1, async, callback);
    for (int i=0; i<server.dbnum; i++) {
        dictRelease(tempDb[i].dict);
        dictRelease(tempDb[i].expires);
    }

    if (server.cluster_enabled) {
        /* Release temp slot to key map. */
        slotToKeyDestroy(tempDb);
    }

    zfree(tempDb);
}",1,1,db.c,discardTempDb,,false,558,574,discardTempDb,,,27,"void discardTempDb (redisDb*,void)"
103281,METHOD,db.c:<global>,TYPE_DECL,"int selectDb(client *c, int id) {
    if (id < 0 || id >= server.dbnum)
        return C_ERR;
    c->db = &server.db[id];
    return C_OK;
}",1,15,db.c,selectDb,,false,576,581,selectDb,,,28,"int selectDb (client*,int)"
103317,METHOD,db.c:<global>,TYPE_DECL,"long long dbTotalServerKeyCount(void) {
    long long total = 0;
    int j;
    for (j = 0; j < server.dbnum; j++) {
        total += dictSize(server.db[j].dict);
    }
    return total;
}",1,17,db.c,dbTotalServerKeyCount,,false,583,590,dbTotalServerKeyCount,,,29,long long dbTotalServerKeyCount (void)
103376,METHOD,db.c:<global>,TYPE_DECL,"void signalModifiedKey(client *c, redisDb *db, robj *key) {
    touchWatchedKey(db,key);
    trackingInvalidateKey(c,key,1);
}",1,1,db.c,signalModifiedKey,,false,603,606,signalModifiedKey,,,30,"void signalModifiedKey (client*,redisDb*,robj*)"
103390,METHOD,db.c:<global>,TYPE_DECL,"void signalFlushedDb(int dbid, int async) {
    int startdb, enddb;
    if (dbid == -1) {
        startdb = 0;
        enddb = server.dbnum-1;
    } else {
        startdb = enddb = dbid;
    }

    for (int j = startdb; j <= enddb; j++) {
        scanDatabaseForDeletedKeys(&server.db[j], NULL);
        touchAllWatchedKeysInDb(&server.db[j], NULL);
    }

    trackingInvalidateKeysOnFlush(async);

    /* Changes in this method may take place in swapMainDbWithTempDb as well,
     * where we execute similar calls, but with subtle differences as it's
     * not simply flushing db. */
}",1,1,db.c,signalFlushedDb,,false,608,627,signalFlushedDb,,,31,"void signalFlushedDb (int,int)"
103451,METHOD,db.c:<global>,TYPE_DECL,"int getFlushCommandFlags(client *c, int *flags) {
    /* Parse the optional ASYNC option. */
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""sync"")) {
        *flags = EMPTYDB_NO_FLAGS;
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""async"")) {
        *flags = EMPTYDB_ASYNC;
    } else if (c->argc == 1) {
        *flags = server.lazyfree_lazy_user_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return C_ERR;
    }
    return C_OK;
}",1,17,db.c,getFlushCommandFlags,,false,642,655,getFlushCommandFlags,,,32,"int getFlushCommandFlags (client*,int*)"
103549,METHOD,db.c:<global>,TYPE_DECL,"void flushAllDataAndResetRDB(int flags) {
    server.dirty += emptyData(-1,flags,NULL);
    if (server.child_type == CHILD_TYPE_RDB) killRDBChild();
    if (server.saveparamslen > 0) {
        rdbSaveInfo rsi, *rsiptr;
        rsiptr = rdbPopulateSaveInfo(&rsi);
        rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr,RDBFLAGS_NONE);
    }

#if defined(USE_JEMALLOC)
    /* jemalloc 5 doesn't release pages back to the OS when there's no traffic.
     * for large databases, flushdb blocks for long anyway, so a bit more won't
     * harm and this way the flush and purge will be synchronous. */
    if (!(flags & EMPTYDB_ASYNC))
        jemalloc_purge();
#endif
}",1,29,db.c,flushAllDataAndResetRDB,,false,658,674,flushAllDataAndResetRDB,,,33,void flushAllDataAndResetRDB (int)
103598,METHOD,db.c:<global>,TYPE_DECL,"void flushdbCommand(client *c) {
    int flags;

    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
    /* flushdb should not flush the functions */
    server.dirty += emptyData(c->db->id,flags | EMPTYDB_NOFUNCTIONS,NULL);

    /* Without the forceCommandPropagation, when DB was already empty,
     * FLUSHDB will not be replicated nor put into the AOF. */
    forceCommandPropagation(c, PROPAGATE_REPL | PROPAGATE_AOF);

    addReply(c,shared.ok);

#if defined(USE_JEMALLOC)
    /* jemalloc 5 doesn't release pages back to the OS when there's no traffic.
     * for large databases, flushdb blocks for long anyway, so a bit more won't
     * harm and this way the flush and purge will be synchronous. */
    if (!(flags & EMPTYDB_ASYNC))
        jemalloc_purge();
#endif
}",1,42,db.c,flushdbCommand,,false,679,699,flushdbCommand,,,34,void flushdbCommand (client*)
103648,METHOD,db.c:<global>,TYPE_DECL,"void flushallCommand(client *c) {
    int flags;
    if (getFlushCommandFlags(c,&flags) == C_ERR) return;
    /* flushall should not flush the functions */
    flushAllDataAndResetRDB(flags | EMPTYDB_NOFUNCTIONS);

    /* Without the forceCommandPropagation, when DBs were already empty,
     * FLUSHALL will not be replicated nor put into the AOF. */
    forceCommandPropagation(c, PROPAGATE_REPL | PROPAGATE_AOF);

    addReply(c,shared.ok);
}",1,42,db.c,flushallCommand,,false,704,715,flushallCommand,,,35,void flushallCommand (client*)
103688,METHOD,db.c:<global>,TYPE_DECL,"void delGenericCommand(client *c, int lazy) {
    int numdel = 0, j;

    for (j = 1; j < c->argc; j++) {
        expireIfNeeded(c->db,c->argv[j],0);
        int deleted  = lazy ? dbAsyncDelete(c->db,c->argv[j]) :
                              dbSyncDelete(c->db,c->argv[j]);
        if (deleted) {
            signalModifiedKey(c,c->db,c->argv[j]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,
                ""del"",c->argv[j],c->db->id);
            server.dirty++;
            numdel++;
        }
    }
    addReplyLongLong(c,numdel);
}",1,32,db.c,delGenericCommand,,false,718,734,delGenericCommand,,,36,"void delGenericCommand (client*,int)"
103784,METHOD,db.c:<global>,TYPE_DECL,"void delCommand(client *c) {
    delGenericCommand(c,server.lazyfree_lazy_user_del);
}",1,1,db.c,delCommand,,false,736,738,delCommand,,,37,void delCommand (client*)
103794,METHOD,db.c:<global>,TYPE_DECL,"void unlinkCommand(client *c) {
    delGenericCommand(c,1);
}",1,1,db.c,unlinkCommand,,false,740,742,unlinkCommand,,,38,void unlinkCommand (client*)
103802,METHOD,db.c:<global>,TYPE_DECL,"void existsCommand(client *c) {
    long long count = 0;
    int j;

    for (j = 1; j < c->argc; j++) {
        if (lookupKeyReadWithFlags(c->db,c->argv[j],LOOKUP_NOTOUCH)) count++;
    }
    addReplyLongLong(c,count);
}",1,52,db.c,existsCommand,,false,746,754,existsCommand,,,39,void existsCommand (client*)
103846,METHOD,db.c:<global>,TYPE_DECL,"void selectCommand(client *c) {
    int id;

    if (getIntFromObjectOrReply(c, c->argv[1], &id, NULL) != C_OK)
        return;

    if (server.cluster_enabled && id != 0) {
        addReplyError(c,""SELECT is not allowed in cluster mode"");
        return;
    }
    if (selectDb(c,id) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
    } else {
        addReply(c,shared.ok);
    }
}",1,61,db.c,selectCommand,,false,756,771,selectCommand,,,40,void selectCommand (client*)
103902,METHOD,db.c:<global>,TYPE_DECL,"void randomkeyCommand(client *c) {
    robj *key;

    if ((key = dbRandomKey(c->db)) == NULL) {
        addReplyNull(c);
        return;
    }

    addReplyBulk(c,key);
    decrRefCount(key);
}",1,1,db.c,randomkeyCommand,,false,773,783,randomkeyCommand,,,41,void randomkeyCommand (client*)
103926,METHOD,db.c:<global>,TYPE_DECL,"void keysCommand(client *c) {
    dictIterator *di;
    dictEntry *de;
    sds pattern = c->argv[1]->ptr;
    int plen = sdslen(pattern), allkeys;
    unsigned long numkeys = 0;
    void *replylen = addReplyDeferredLen(c);

    di = dictGetSafeIterator(c->db->dict);
    allkeys = (pattern[0] == '*' && plen == 1);
    robj keyobj;
    while((de = dictNext(di)) != NULL) {
        sds key = dictGetKey(de);

        if (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),0)) {
            initStaticStringObject(keyobj, key);
            if (!keyIsExpired(c->db, &keyobj)) {
                addReplyBulkCBuffer(c, key, sdslen(key));
                numkeys++;
            }
        }
        if (c->flags & CLIENT_CLOSE_ASAP)
            break;
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c,replylen,numkeys);
}",1,12,db.c,keysCommand,,false,785,811,keysCommand,,,42,void keysCommand (client*)
104072,METHOD,db.c:<global>,TYPE_DECL,"int objectTypeCompare(robj *o, long long target) {
    if (o->type != OBJ_MODULE) {
        if (o->type != target) 
            return 0;
        else 
            return 1;
    }
    /* module type compare */
    long long mt = (long long)REDISMODULE_TYPE_SIGN(((moduleValue *)o->ptr)->type->id);
    if (target != -mt)
        return 0;
    else 
        return 1;
}",1,19,db.c,objectTypeCompare,,false,823,836,objectTypeCompare,,,45,"int objectTypeCompare (robj*,long long)"
104138,METHOD,db.c:<global>,TYPE_DECL,"void scanCallback(void *privdata, const dictEntry *de) {
    scanData *data = (scanData *)privdata;
    list *keys = data->keys;
    robj *o = data->o;
    sds val = NULL;
    sds key = NULL;
    data->sampled++;

    /* o and typename can not have values at the same time. */
    serverAssert(!((data->type != LLONG_MAX) && o));

    /* Filter an element if it isn't the type we want. */
    /* TODO: uncomment in redis 8.0
    if (!o && data->type != LLONG_MAX) {
        robj *rval = dictGetVal(de);
        if (!objectTypeCompare(rval, data->type)) return;
    }*/

    /* Filter element if it does not match the pattern. */
    sds keysds = dictGetKey(de);
    if (data->pattern) {
        if (!stringmatchlen(data->pattern, sdslen(data->pattern), keysds, sdslen(keysds), 0)) {
            return;
        }
    }

    if (o == NULL) {
        key = keysds;
    } else if (o->type == OBJ_SET) {
        key = keysds;
    } else if (o->type == OBJ_HASH) {
        key = keysds;
        val = d...",1,4,db.c,scanCallback,,false,839,883,scanCallback,,,46,"void scanCallback (void*,dictEntry*)"
104314,METHOD,db.c:<global>,TYPE_DECL,"int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor) {
    char *eptr;

    /* Use strtoul() because we need an *unsigned* long, so
     * getLongLongFromObject() does not cover the whole cursor space. */
    errno = 0;
    *cursor = strtoul(o->ptr, &eptr, 10);
    if (isspace(((char*)o->ptr)[0]) || eptr[0] != '\0' || errno == ERANGE)
    {
        addReplyError(c, ""invalid cursor"");
        return C_ERR;
    }
    return C_OK;
}",1,15,db.c,parseScanCursorOrReply,,false,889,902,parseScanCursorOrReply,,,47,"int parseScanCursorOrReply (client*,robj*,long unsigned*)"
104378,METHOD,db.c:<global>,TYPE_DECL,"long long getObjectTypeByName(char *name) {

    for (long long i = 0; i < OBJ_TYPE_MAX; i++) {
        if (obj_type_name[i] && !strcasecmp(name, obj_type_name[i])) {
            return i;
        }
    }

    moduleType *mt = moduleTypeLookupModuleByNameIgnoreCase(name);
    if (mt != NULL) return -(REDISMODULE_TYPE_SIGN(mt->id));

    return LLONG_MAX;
}",1,30,db.c,getObjectTypeByName,,false,915,927,getObjectTypeByName,,,50,long long getObjectTypeByName (char*)
104443,METHOD,db.c:<global>,TYPE_DECL,"char *getObjectTypeName(robj *o) {
    if (o == NULL) {
        return ""none"";
    }

    serverAssert(o->type >= 0 && o->type < OBJ_TYPE_MAX);

    if (o->type == OBJ_MODULE) {
        moduleValue *mv = o->ptr;
        return mv->type->name;
    } else {
        return obj_type_name[o->type];
    }
}",1,4,db.c,getObjectTypeName,,false,929,942,getObjectTypeName,,,51,char* getObjectTypeName (robj*)
104508,METHOD,db.c:<global>,TYPE_DECL,"void scanGenericCommand(client *c, robj *o, unsigned long cursor) {
    int i, j;
    listNode *node;
    long count = 10;
    sds pat = NULL;
    sds typename = NULL;
    long long type = LLONG_MAX;
    int patlen = 0, use_pattern = 0;
    dict *ht;

    /* Object must be NULL (to iterate keys names), or the type of the object
     * must be Set, Sorted Set, or Hash. */
    serverAssert(o == NULL || o->type == OBJ_SET || o->type == OBJ_HASH ||
                o->type == OBJ_ZSET);

    /* Set i to the first option argument. The previous one is the cursor. */
    i = (o == NULL) ? 2 : 3; /* Skip the key argument if needed. */

    /* Step 1: Parse options. */
    while (i < c->argc) {
        j = c->argc - i;
        if (!strcasecmp(c->argv[i]->ptr, ""count"") && j >= 2) {
            if (getLongFromObjectOrReply(c, c->argv[i+1], &count, NULL)
                != C_OK)
            {
                return;
            }

            if (count < 1) {
                addReplyErrorObject(...",1,4,db.c,scanGenericCommand,,false,955,1159,scanGenericCommand,,,52,"void scanGenericCommand (client*,robj*,long unsigned)"
105271,METHOD,db.c:<global>,TYPE_DECL,"void scanCommand(client *c) {
    unsigned long cursor;
    if (parseScanCursorOrReply(c,c->argv[1],&cursor) == C_ERR) return;
    scanGenericCommand(c,NULL,cursor);
}",1,56,db.c,scanCommand,,false,1162,1166,scanCommand,,,53,void scanCommand (client*)
105298,METHOD,db.c:<global>,TYPE_DECL,"void dbsizeCommand(client *c) {
    addReplyLongLong(c,dictSize(c->db->dict));
}",1,23,db.c,dbsizeCommand,,false,1168,1170,dbsizeCommand,,,54,void dbsizeCommand (client*)
105331,METHOD,db.c:<global>,TYPE_DECL,"void lastsaveCommand(client *c) {
    addReplyLongLong(c,server.lastsave);
}",1,1,db.c,lastsaveCommand,,false,1172,1174,lastsaveCommand,,,55,void lastsaveCommand (client*)
105341,METHOD,db.c:<global>,TYPE_DECL,"void typeCommand(client *c) {
    robj *o;
    o = lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH);
    addReplyStatus(c, getObjectTypeName(o));
}",1,48,db.c,typeCommand,,false,1176,1180,typeCommand,,,56,void typeCommand (client*)
105367,METHOD,db.c:<global>,TYPE_DECL,"void shutdownCommand(client *c) {
    int flags = SHUTDOWN_NOFLAGS;
    int abort = 0;
    for (int i = 1; i < c->argc; i++) {
        if (!strcasecmp(c->argv[i]->ptr,""nosave"")) {
            flags |= SHUTDOWN_NOSAVE;
        } else if (!strcasecmp(c->argv[i]->ptr,""save"")) {
            flags |= SHUTDOWN_SAVE;
        } else if (!strcasecmp(c->argv[i]->ptr, ""now"")) {
            flags |= SHUTDOWN_NOW;
        } else if (!strcasecmp(c->argv[i]->ptr, ""force"")) {
            flags |= SHUTDOWN_FORCE;
        } else if (!strcasecmp(c->argv[i]->ptr, ""abort"")) {
            abort = 1;
        } else {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        }
    }
    if ((abort && flags != SHUTDOWN_NOFLAGS) ||
        (flags & SHUTDOWN_NOSAVE && flags & SHUTDOWN_SAVE))
    {
        /* Illegal combo. */
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    if (abort) {
        if (abortShutdown() == C_OK)
            addReply(c, shared.ok);
 ...",1,16,db.c,shutdownCommand,,false,1182,1241,shutdownCommand,,,57,void shutdownCommand (client*)
105632,METHOD,db.c:<global>,TYPE_DECL,"void renameGenericCommand(client *c, int nx) {
    robj *o;
    long long expire;
    int samekey = 0;

    /* When source and dest key is the same, no operation is performed,
     * if the key exists, however we still return an error on unexisting key. */
    if (sdscmp(c->argv[1]->ptr,c->argv[2]->ptr) == 0) samekey = 1;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr)) == NULL)
        return;

    if (samekey) {
        addReply(c,nx ? shared.czero : shared.ok);
        return;
    }

    incrRefCount(o);
    expire = getExpire(c->db,c->argv[1]);
    if (lookupKeyWrite(c->db,c->argv[2]) != NULL) {
        if (nx) {
            decrRefCount(o);
            addReply(c,shared.czero);
            return;
        }
        /* Overwrite: delete the old key before creating the new one
         * with the same name. */
        dbDelete(c->db,c->argv[2]);
    }
    dbAdd(c->db,c->argv[2],o);
    if (expire != -1) setExpire(c,c->db,c->argv[2],expire);
    dbDelete(c->db,c-...",1,24,db.c,renameGenericCommand,,false,1243,1283,renameGenericCommand,,,58,"void renameGenericCommand (client*,int)"
105847,METHOD,db.c:<global>,TYPE_DECL,"void renameCommand(client *c) {
    renameGenericCommand(c,0);
}",1,1,db.c,renameCommand,,false,1285,1287,renameCommand,,,59,void renameCommand (client*)
105855,METHOD,db.c:<global>,TYPE_DECL,"void renamenxCommand(client *c) {
    renameGenericCommand(c,1);
}",1,1,db.c,renamenxCommand,,false,1289,1291,renamenxCommand,,,60,void renamenxCommand (client*)
105863,METHOD,db.c:<global>,TYPE_DECL,"void moveCommand(client *c) {
    robj *o;
    redisDb *src, *dst;
    int srcid, dbid;
    long long expire;

    if (server.cluster_enabled) {
        addReplyError(c,""MOVE is not allowed in cluster mode"");
        return;
    }

    /* Obtain source and target DB pointers */
    src = c->db;
    srcid = c->db->id;

    if (getIntFromObjectOrReply(c, c->argv[2], &dbid, NULL) != C_OK)
        return;

    if (selectDb(c,dbid) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
        return;
    }
    dst = c->db;
    selectDb(c,srcid); /* Back to the source DB */

    /* If the user is moving using as target the same
     * DB as the source DB it is probably an error. */
    if (src == dst) {
        addReplyErrorObject(c,shared.sameobjecterr);
        return;
    }

    /* Check if the element exists and get a reference */
    o = lookupKeyWrite(c->db,c->argv[1]);
    if (!o) {
        addReply(c,shared.czero);
        return;
    }
    expire = getExpire(c->db,c->a...",1,63,db.c,moveCommand,,false,1293,1353,moveCommand,,,61,void moveCommand (client*)
106081,METHOD,db.c:<global>,TYPE_DECL,"void copyCommand(client *c) {
    robj *o;
    redisDb *src, *dst;
    int srcid, dbid;
    long long expire;
    int j, replace = 0, delete = 0;

    /* Obtain source and target DB pointers 
     * Default target DB is the same as the source DB 
     * Parse the REPLACE option and targetDB option. */
    src = c->db;
    dst = c->db;
    srcid = c->db->id;
    dbid = c->db->id;
    for (j = 3; j < c->argc; j++) {
        int additional = c->argc - j - 1;
        if (!strcasecmp(c->argv[j]->ptr,""replace"")) {
            replace = 1;
        } else if (!strcasecmp(c->argv[j]->ptr, ""db"") && additional >= 1) {
            if (getIntFromObjectOrReply(c, c->argv[j+1], &dbid, NULL) != C_OK)
                return;

            if (selectDb(c, dbid) == C_ERR) {
                addReplyError(c,""DB index is out of range"");
                return;
            }
            dst = c->db;
            selectDb(c,srcid); /* Back to the source DB */
            j++; /* Consume additional arg. */
  ...",1,73,db.c,copyCommand,,false,1355,1455,copyCommand,,,62,void copyCommand (client*)
106471,METHOD,db.c:<global>,TYPE_DECL,"void scanDatabaseForReadyKeys(redisDb *db) {
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(db->blocking_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        dictEntry *kde = dictFind(db->dict,key->ptr);
        if (kde) {
            robj *value = dictGetVal(kde);
            signalKeyAsReady(db, key, value->type);
        }
    }
    dictReleaseIterator(di);
}",1,1,db.c,scanDatabaseForReadyKeys,,false,1461,1473,scanDatabaseForReadyKeys,,,63,void scanDatabaseForReadyKeys (redisDb*)
106523,METHOD,db.c:<global>,TYPE_DECL,"void scanDatabaseForDeletedKeys(redisDb *emptied, redisDb *replaced_with) {
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(emptied->blocking_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        int existed = 0, exists = 0;
        int original_type = -1, curr_type = -1;

        dictEntry *kde = dictFind(emptied->dict, key->ptr);
        if (kde) {
            robj *value = dictGetVal(kde);
            original_type = value->type;
            existed = 1;
        }

        if (replaced_with) {
            dictEntry *kde = dictFind(replaced_with->dict, key->ptr);
            if (kde) {
                robj *value = dictGetVal(kde);
                curr_type = value->type;
                exists = 1;
            }
        }
        /* We want to try to unblock any client using a blocking XREADGROUP */
        if ((existed && !exists) || original_type != curr_type)
            signalDeletedKeyAsReady(emptied, key, original_type);
 ...",1,1,db.c,scanDatabaseForDeletedKeys,,false,1478,1506,scanDatabaseForDeletedKeys,,,64,"void scanDatabaseForDeletedKeys (redisDb*,redisDb*)"
106639,METHOD,db.c:<global>,TYPE_DECL,"int dbSwapDatabases(int id1, int id2) {
    if (id1 < 0 || id1 >= server.dbnum ||
        id2 < 0 || id2 >= server.dbnum) return C_ERR;
    if (id1 == id2) return C_OK;
    redisDb aux = server.db[id1];
    redisDb *db1 = &server.db[id1], *db2 = &server.db[id2];

    /* Swapdb should make transaction fail if there is any
     * client watching keys */
    touchAllWatchedKeysInDb(db1, db2);
    touchAllWatchedKeysInDb(db2, db1);

    /* Try to unblock any XREADGROUP clients if the key no longer exists. */
    scanDatabaseForDeletedKeys(db1, db2);
    scanDatabaseForDeletedKeys(db2, db1);

    /* Swap hash tables. Note that we don't swap blocking_keys,
     * ready_keys and watched_keys, since we want clients to
     * remain in the same DB they were. */
    db1->dict = db2->dict;
    db1->expires = db2->expires;
    db1->avg_ttl = db2->avg_ttl;
    db1->expires_cursor = db2->expires_cursor;

    db2->dict = aux.dict;
    db2->expires = aux.expires;
    db2->avg_ttl = aux.avg_ttl;
   ...",1,47,db.c,dbSwapDatabases,,false,1516,1557,dbSwapDatabases,,,65,"int dbSwapDatabases (int,int)"
106782,METHOD,db.c:<global>,TYPE_DECL,"void swapMainDbWithTempDb(redisDb *tempDb) {
    if (server.cluster_enabled) {
        /* Swap slots_to_keys from tempdb just loaded with main db slots_to_keys. */
        clusterSlotToKeyMapping *aux = server.db->slots_to_keys;
        server.db->slots_to_keys = tempDb->slots_to_keys;
        tempDb->slots_to_keys = aux;
    }

    for (int i=0; i<server.dbnum; i++) {
        redisDb aux = server.db[i];
        redisDb *activedb = &server.db[i], *newdb = &tempDb[i];

        /* Swapping databases should make transaction fail if there is any
         * client watching keys. */
        touchAllWatchedKeysInDb(activedb, newdb);

        /* Try to unblock any XREADGROUP clients if the key no longer exists. */
        scanDatabaseForDeletedKeys(activedb, newdb);

        /* Swap hash tables. Note that we don't swap blocking_keys,
         * ready_keys and watched_keys, since clients 
         * remain in the same DB they were. */
        activedb->dict = newdb->dict;
        activedb->e...",1,1,db.c,swapMainDbWithTempDb,,false,1562,1608,swapMainDbWithTempDb,,,66,void swapMainDbWithTempDb (redisDb*)
106919,METHOD,db.c:<global>,TYPE_DECL,"void swapdbCommand(client *c) {
    int id1, id2;

    /* Not allowed in cluster mode: we have just DB 0 there. */
    if (server.cluster_enabled) {
        addReplyError(c,""SWAPDB is not allowed in cluster mode"");
        return;
    }

    /* Get the two DBs indexes. */
    if (getIntFromObjectOrReply(c, c->argv[1], &id1,
        ""invalid first DB index"") != C_OK)
        return;

    if (getIntFromObjectOrReply(c, c->argv[2], &id2,
        ""invalid second DB index"") != C_OK)
        return;

    /* Swap... */
    if (dbSwapDatabases(id1,id2) == C_ERR) {
        addReplyError(c,""DB index is out of range"");
        return;
    } else {
        RedisModuleSwapDbInfo si = {REDISMODULE_SWAPDBINFO_VERSION,id1,id2};
        moduleFireServerEvent(REDISMODULE_EVENT_SWAPDB,0,&si);
        server.dirty++;
        addReply(c,shared.ok);
    }
}",1,37,db.c,swapdbCommand,,false,1611,1639,swapdbCommand,,,67,void swapdbCommand (client*)
107010,METHOD,db.c:<global>,TYPE_DECL,"int removeExpire(redisDb *db, robj *key) {
    return dictDelete(db->expires,key->ptr) == DICT_OK;
}",1,47,db.c,removeExpire,,false,1645,1647,removeExpire,,,68,"int removeExpire (redisDb*,robj*)"
107028,METHOD,db.c:<global>,TYPE_DECL,"void setExpire(client *c, redisDb *db, robj *key, long long when) {
    dictEntry *kde, *de;

    /* Reuse the sds from the main dict in the expire dict */
    kde = dictFind(db->dict,key->ptr);
    serverAssertWithInfo(NULL,key,kde != NULL);
    de = dictAddOrFind(db->expires,dictGetKey(kde));
    dictSetSignedIntegerVal(de,when);

    int writable_slave = server.masterhost && server.repl_slave_ro == 0;
    if (c && writable_slave && !(c->flags & CLIENT_MASTER))
        rememberSlaveKeyWithExpire(db,key);
}",1,4,db.c,setExpire,,false,1653,1665,setExpire,,,69,"void setExpire (client*,redisDb*,robj*,long long)"
107109,METHOD,db.c:<global>,TYPE_DECL,"long long getExpire(redisDb *db, robj *key) {
    dictEntry *de;

    /* No expire? return ASAP */
    if (dictSize(db->expires) == 0 ||
       (de = dictFind(db->expires,key->ptr)) == NULL) return -1;

    return dictGetSignedIntegerVal(de);
}",1,8,db.c,getExpire,,false,1669,1677,getExpire,,,70,"long long getExpire (redisDb*,robj*)"
107158,METHOD,db.c:<global>,TYPE_DECL,"void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj) {
    mstime_t expire_latency;
    latencyStartMonitor(expire_latency);
    dbGenericDelete(db,keyobj,server.lazyfree_lazy_expire,DB_FLAG_KEY_EXPIRED);
    latencyEndMonitor(expire_latency);
    latencyAddSampleIfNeeded(""expire-del"",expire_latency);
    notifyKeyspaceEvent(NOTIFY_EXPIRED,""expired"",keyobj,db->id);
    signalModifiedKey(NULL, db, keyobj);
    propagateDeletion(db,keyobj,server.lazyfree_lazy_expire);
    server.stat_expiredkeys++;
}",1,4,db.c,deleteExpiredKeyAndPropagate,,false,1680,1690,deleteExpiredKeyAndPropagate,,,71,"void deleteExpiredKeyAndPropagate (redisDb*,robj*)"
107248,METHOD,db.c:<global>,TYPE_DECL,"void propagateDeletion(redisDb *db, robj *key, int lazy) {
    robj *argv[2];

    argv[0] = lazy ? shared.unlink : shared.del;
    argv[1] = key;
    incrRefCount(argv[0]);
    incrRefCount(argv[1]);

    /* If the master decided to expire a key we must propagate it to replicas no matter what..
     * Even if module executed a command without asking for propagation. */
    int prev_replication_allowed = server.replication_allowed;
    server.replication_allowed = 1;
    alsoPropagate(db->id,argv,2,PROPAGATE_AOF|PROPAGATE_REPL);
    server.replication_allowed = prev_replication_allowed;

    decrRefCount(argv[0]);
    decrRefCount(argv[1]);
}",1,32,db.c,propagateDeletion,,false,1710,1727,propagateDeletion,,,72,"void propagateDeletion (redisDb*,robj*,int)"
107318,METHOD,db.c:<global>,TYPE_DECL,"int keyIsExpired(redisDb *db, robj *key) {
    /* Don't expire anything while loading. It will be done later. */
    if (server.loading) return 0;

    mstime_t when = getExpire(db,key);
    mstime_t now;

    if (when < 0) return 0; /* No expire for this key */

    now = commandTimeSnapshot();

    /* The key expired if the current (virtual or real) time is greater
     * than the expire time of the key. */
    return now > when;
}",1,1,db.c,keyIsExpired,,false,1730,1744,keyIsExpired,,,73,"int keyIsExpired (redisDb*,robj*)"
107352,METHOD,db.c:<global>,TYPE_DECL,"int expireIfNeeded(redisDb *db, robj *key, int flags) {
    if (server.lazy_expire_disabled) return 0;
    if (!keyIsExpired(db,key)) return 0;

    /* If we are running in the context of a replica, instead of
     * evicting the expired key from the database, we return ASAP:
     * the replica key expiration is controlled by the master that will
     * send us synthesized DEL operations for expired keys. The
     * exception is when write operations are performed on writable
     * replicas.
     *
     * Still we try to return the right information to the caller,
     * that is, 0 if we think the key should be still valid, 1 if
     * we think the key is expired at this time.
     *
     * When replicating commands from the master, keys are never considered
     * expired. */
    if (server.masterhost != NULL) {
        if (server.current_client && (server.current_client->flags & CLIENT_MASTER)) return 0;
        if (!(flags & EXPIRE_FORCE_DELETE_EXPIRED)) return 1;
    }

    /* ...",1,69,db.c,expireIfNeeded,,false,1775,1818,expireIfNeeded,,,74,"int expireIfNeeded (redisDb*,robj*,int)"
107464,METHOD,db.c:<global>,TYPE_DECL,"keyReference *getKeysPrepareResult(getKeysResult *result, int numkeys) {
    /* GETKEYS_RESULT_INIT initializes keys to NULL, point it to the pre-allocated stack
     * buffer here. */
    if (!result->keys) {
        serverAssert(!result->numkeys);
        result->keys = result->keysbuf;
    }

    /* Resize if necessary */
    if (numkeys > result->size) {
        if (result->keys != result->keysbuf) {
            /* We're not using a static buffer, just (re)alloc */
            result->keys = zrealloc(result->keys, numkeys * sizeof(keyReference));
        } else {
            /* We are using a static buffer, copy its contents */
            result->keys = zmalloc(numkeys * sizeof(keyReference));
            if (result->numkeys)
                memcpy(result->keys, result->keysbuf, result->numkeys * sizeof(keyReference));
        }
        result->size = numkeys;
    }

    return result->keys;
}",1,8,db.c,getKeysPrepareResult,,false,1830,1853,getKeysPrepareResult,,,75,"keyReference getKeysPrepareResult (getKeysResult*,int)"
107570,METHOD,db.c:<global>,TYPE_DECL,"int64_t getAllKeySpecsFlags(struct redisCommand *cmd, int inv) {
    int64_t flags = 0;
    for (int j = 0; j < cmd->key_specs_num; j++) {
        keySpec *spec = cmd->key_specs + j;
        flags |= inv? ~spec->flags : spec->flags;
    }
    return flags;
}",1,1,db.c,getAllKeySpecsFlags,,false,1857,1864,getAllKeySpecsFlags,,,76,"int64_t getAllKeySpecsFlags (redisCommand*,int)"
107615,METHOD,db.c:<global>,TYPE_DECL,"int getKeysUsingKeySpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result) {
    int j, i, last, first, step;
    keyReference *keys;
    serverAssert(result->numkeys == 0); /* caller should initialize or reset it */

    for (j = 0; j < cmd->key_specs_num; j++) {
        keySpec *spec = cmd->key_specs + j;
        serverAssert(spec->begin_search_type != KSPEC_BS_INVALID);
        /* Skip specs that represent 'fake' keys */
        if ((spec->flags & CMD_KEY_NOT_KEY) && !(search_flags & GET_KEYSPEC_INCLUDE_NOT_KEYS)) {
            continue;
        }

        first = 0;
        if (spec->begin_search_type == KSPEC_BS_INDEX) {
            first = spec->bs.index.pos;
        } else if (spec->begin_search_type == KSPEC_BS_KEYWORD) {
            int start_index = spec->bs.keyword.startfrom > 0 ? spec->bs.keyword.startfrom : argc+spec->bs.keyword.startfrom;
            int end_index = spec->bs.keyword.startfrom > 0 ? argc-1: 1;
            for (i =...",1,4,db.c,getKeysUsingKeySpecs,,false,1873,1986,getKeysUsingKeySpecs,,,77,"int getKeysUsingKeySpecs (redisCommand*,robj**,int,int,getKeysResult*)"
108178,METHOD,db.c:<global>,TYPE_DECL,"int getKeysFromCommandWithSpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result) {
    /* The command has at least one key-spec not marked as NOT_KEY */
    int has_keyspec = (getAllKeySpecsFlags(cmd, 1) & CMD_KEY_NOT_KEY);
    /* The command has at least one key-spec marked as VARIABLE_FLAGS */
    int has_varflags = (getAllKeySpecsFlags(cmd, 0) & CMD_KEY_VARIABLE_FLAGS);

    /* We prefer key-specs if there are any, and their flags are reliable. */
    if (has_keyspec && !has_varflags) {
        int ret = getKeysUsingKeySpecs(cmd,argv,argc,search_flags,result);
        if (ret >= 0)
            return ret;
        /* If the specs returned with an error (probably an INVALID or INCOMPLETE spec),
         * fallback to the callback method. */
    }

    /* Resort to getkeys callback methods. */
    if (cmd->flags & CMD_MODULE_GETKEYS)
        return moduleGetCommandKeysViaAPI(cmd,argv,argc,result);

    /* We use native getkeys as a last resor...",1,53,db.c,getKeysFromCommandWithSpecs,,false,2000,2024,getKeysFromCommandWithSpecs,,,78,"int getKeysFromCommandWithSpecs (redisCommand*,robj**,int,int,getKeysResult*)"
108266,METHOD,db.c:<global>,TYPE_DECL,"int doesCommandHaveKeys(struct redisCommand *cmd) {
    return cmd->getkeys_proc ||                                 /* has getkeys_proc (non modules) */
        (cmd->flags & CMD_MODULE_GETKEYS) ||                    /* module with GETKEYS */
        (getAllKeySpecsFlags(cmd, 1) & CMD_KEY_NOT_KEY);        /* has at least one key-spec not marked as NOT_KEY */
}",1,22,db.c,doesCommandHaveKeys,,false,2027,2031,doesCommandHaveKeys,,,79,int doesCommandHaveKeys (redisCommand*)
108398,METHOD,db.c:<global>,TYPE_DECL,"int doesCommandHaveChannelsWithFlags(struct redisCommand *cmd, int flags) {
    /* If a module declares get channels, we are just going to assume
     * has channels. This API is allowed to return false positives. */
    if (cmd->flags & CMD_MODULE_GETCHANNELS) {
        return 1;
    }
    for (ChannelSpecs *spec = commands_with_channels; spec->proc != NULL; spec += 1) {
        if (cmd->proc == spec->proc) {
            return !!(spec->flags & flags);
        }
    }
    return 0;
}",1,21,db.c,doesCommandHaveChannelsWithFlags,,false,2057,2069,doesCommandHaveChannelsWithFlags,,,84,"int doesCommandHaveChannelsWithFlags (redisCommand*,int)"
108451,METHOD,db.c:<global>,TYPE_DECL,"int getChannelsFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    /* If a module declares get channels, use that. */
    if (cmd->flags & CMD_MODULE_GETCHANNELS) {
        return moduleGetCommandChannelsViaAPI(cmd, argv, argc, result);
    }
    /* Otherwise check the channel spec table */
    for (ChannelSpecs *spec = commands_with_channels; spec != NULL; spec += 1) {
        if (cmd->proc == spec->proc) {
            int start = spec->start;
            int stop = (spec->count == -1) ? argc : start + spec->count;
            if (stop > argc) stop = argc;
            int count = 0;
            keys = getKeysPrepareResult(result, stop - start);
            for (int i = start; i < stop; i++ ) {
                keys[count].pos = i;
                keys[count++].flags = spec->flags;
            }
            result->numkeys = count;
            return count;
        }
    }
    return 0;
}",1,21,db.c,getChannelsFromCommand,,false,2084,2107,getChannelsFromCommand,,,85,"int getChannelsFromCommand (redisCommand*,robj**,int,getKeysResult*)"
108578,METHOD,db.c:<global>,TYPE_DECL,"int getKeysUsingLegacyRangeSpec(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int j, i = 0, last, first, step;
    keyReference *keys;
    UNUSED(argv);

    if (cmd->legacy_range_key_spec.begin_search_type == KSPEC_BS_INVALID) {
        result->numkeys = 0;
        return 0;
    }

    first = cmd->legacy_range_key_spec.bs.index.pos;
    last = cmd->legacy_range_key_spec.fk.range.lastkey;
    if (last >= 0)
        last += first;
    step = cmd->legacy_range_key_spec.fk.range.keystep;

    if (last < 0) last = argc+last;

    int count = ((last - first)+1);
    keys = getKeysPrepareResult(result, count);

    for (j = first; j <= last; j += step) {
        if (j >= argc || j < first) {
            /* Modules commands, and standard commands with a not fixed number
             * of arguments (negative arity parameter) do not have dispatch
             * time arity checks, so we need to handle the case where the user
             * passed an invalid nu...",1,4,db.c,getKeysUsingLegacyRangeSpec,,false,2119,2161,getKeysUsingLegacyRangeSpec,,,86,"int getKeysUsingLegacyRangeSpec (redisCommand*,robj**,int,getKeysResult*)"
108758,METHOD,db.c:<global>,TYPE_DECL,"int getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    if (cmd->flags & CMD_MODULE_GETKEYS) {
        return moduleGetCommandKeysViaAPI(cmd,argv,argc,result);
    } else if (cmd->getkeys_proc) {
        return cmd->getkeys_proc(cmd,argv,argc,result);
    } else {
        return getKeysUsingLegacyRangeSpec(cmd,argv,argc,result);
    }
}",1,21,db.c,getKeysFromCommand,,false,2174,2182,getKeysFromCommand,,,87,"int getKeysFromCommand (redisCommand*,robj**,int,getKeysResult*)"
108807,METHOD,db.c:<global>,TYPE_DECL,"void getKeysFreeResult(getKeysResult *result) {
    if (result && result->keys != result->keysbuf)
        zfree(result->keys);
}",1,1,db.c,getKeysFreeResult,,false,2185,2188,getKeysFreeResult,,,88,void getKeysFreeResult (getKeysResult*)
108827,METHOD,db.c:<global>,TYPE_DECL,"int genericGetKeys(int storeKeyOfs, int keyCountOfs, int firstKeyOfs, int keyStep,
                    robj **argv, int argc, getKeysResult *result) {
    int i, num;
    keyReference *keys;

    num = atoi(argv[keyCountOfs]->ptr);
    /* Sanity check. Don't return any key if the command is going to
     * reply with syntax error. (no input keys). */
    if (num < 1 || num > (argc - firstKeyOfs)/keyStep) {
        result->numkeys = 0;
        return 0;
    }

    int numkeys = storeKeyOfs ? num + 1 : num;
    keys = getKeysPrepareResult(result, numkeys);
    result->numkeys = numkeys;

    /* Add all key positions for argv[firstKeyOfs...n] to keys[] */
    for (i = 0; i < num; i++) {
        keys[i].pos = firstKeyOfs+(i*keyStep);
        keys[i].flags = 0;
    } 

    if (storeKeyOfs) {
        keys[num].pos = storeKeyOfs;
        keys[num].flags = 0;
    } 
    return result->numkeys;
}",1,1,db.c,genericGetKeys,,false,2203,2231,genericGetKeys,,,89,"int genericGetKeys (int,int,int,int,robj**,int,getKeysResult*)"
108938,METHOD,db.c:<global>,TYPE_DECL,"int sintercardGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",1,4,db.c,sintercardGetKeys,,false,2233,2236,sintercardGetKeys,,,90,"int sintercardGetKeys (redisCommand*,robj**,int,getKeysResult*)"
108961,METHOD,db.c:<global>,TYPE_DECL,"int zunionInterDiffStoreGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(1, 2, 3, 1, argv, argc, result);
}",1,4,db.c,zunionInterDiffStoreGetKeys,,false,2238,2241,zunionInterDiffStoreGetKeys,,,91,"int zunionInterDiffStoreGetKeys (redisCommand*,robj**,int,getKeysResult*)"
108984,METHOD,db.c:<global>,TYPE_DECL,"int zunionInterDiffGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",1,4,db.c,zunionInterDiffGetKeys,,false,2243,2246,zunionInterDiffGetKeys,,,92,"int zunionInterDiffGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109007,METHOD,db.c:<global>,TYPE_DECL,"int evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",1,4,db.c,evalGetKeys,,false,2248,2251,evalGetKeys,,,93,"int evalGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109030,METHOD,db.c:<global>,TYPE_DECL,"int functionGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",1,4,db.c,functionGetKeys,,false,2253,2256,functionGetKeys,,,94,"int functionGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109053,METHOD,db.c:<global>,TYPE_DECL,"int lmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",1,4,db.c,lmpopGetKeys,,false,2258,2261,lmpopGetKeys,,,95,"int lmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109076,METHOD,db.c:<global>,TYPE_DECL,"int blmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",1,4,db.c,blmpopGetKeys,,false,2263,2266,blmpopGetKeys,,,96,"int blmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109099,METHOD,db.c:<global>,TYPE_DECL,"int zmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 1, 2, 1, argv, argc, result);
}",1,4,db.c,zmpopGetKeys,,false,2268,2271,zmpopGetKeys,,,97,"int zmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109122,METHOD,db.c:<global>,TYPE_DECL,"int bzmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    UNUSED(cmd);
    return genericGetKeys(0, 2, 3, 1, argv, argc, result);
}",1,4,db.c,bzmpopGetKeys,,false,2273,2276,bzmpopGetKeys,,,98,"int bzmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109145,METHOD,db.c:<global>,TYPE_DECL,"int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    UNUSED(cmd);
    UNUSED(argv);
    UNUSED(argc);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* <sort-key> is always present. */
    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;
    return 1;
}",1,4,db.c,sortROGetKeys,,false,2288,2298,sortROGetKeys,,,99,"int sortROGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109203,METHOD,db.c:<global>,TYPE_DECL,"int sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, j, num, found_store = 0;
    keyReference *keys;
    UNUSED(cmd);

    num = 0;
    keys = getKeysPrepareResult(result, 2); /* Alloc 2 places for the worst case. */
    keys[num].pos = 1; /* <sort-key> is always present. */
    keys[num++].flags = CMD_KEY_RO | CMD_KEY_ACCESS;

    /* Search for STORE option. By default we consider options to don't
     * have arguments, so if we find an unknown option name we scan the
     * next. However there are options with 1 or 2 arguments, so we
     * provide a list here in order to skip the right number of args. */
    struct {
        char *name;
        int skip;
    } skiplist[] = {
        {""limit"", 2},
        {""get"", 1},
        {""by"", 1},
        {NULL, 0} /* End of elements. */
    };

    for (i = 2; i < argc; i++) {
        for (j = 0; skiplist[j].name != NULL; j++) {
            if (!strcasecmp(argv[i]->ptr,skiplist[j].name)) {
   ...",1,4,db.c,sortGetKeys,,false,2309,2351,sortGetKeys,,,100,"int sortGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109381,METHOD,db.c:<global>,TYPE_DECL,"int migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, j, num, first;
    keyReference *keys;
    UNUSED(cmd);

    /* Assume the obvious form. */
    first = 3;
    num = 1;

    /* But check for the extended one with the KEYS option. */
    struct {
        char* name;
        int skip;
    } skip_keywords[] = {       
        {""copy"", 0},
        {""replace"", 0},
        {""auth"", 1},
        {""auth2"", 2},
        {NULL, 0}
    };
    if (argc > 6) {
        for (i = 6; i < argc; i++) {
            if (!strcasecmp(argv[i]->ptr, ""keys"")) {
                if (sdslen(argv[3]->ptr) > 0) {
                    /* This is a syntax error. So ignore the keys and leave
                     * the syntax error to be handled by migrateCommand. */
                    num = 0; 
                } else {
                    first = i + 1;
                    num = argc - first;
                }
                break;
            }
            for (...",1,4,db.c,migrateGetKeys,,false,2354,2403,migrateGetKeys,,,101,"int migrateGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109569,METHOD,db.c:<global>,TYPE_DECL,"int georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, num;
    keyReference *keys;
    UNUSED(cmd);

    /* Check for the presence of the stored key in the command */
    int stored_key = -1;
    for (i = 5; i < argc; i++) {
        char *arg = argv[i]->ptr;
        /* For the case when user specifies both ""store"" and ""storedist"" options, the
         * second key specified would override the first key. This behavior is kept
         * the same as in georadiusCommand method.
         */
        if ((!strcasecmp(arg, ""store"") || !strcasecmp(arg, ""storedist"")) && ((i+1) < argc)) {
            stored_key = i+1;
            i++;
        }
    }
    num = 1 + (stored_key == -1 ? 0 : 1);

    /* Keys in the command come from two places:
     * argv[1] = key,
     * argv[5...n] = stored key if present
     */
    keys = getKeysPrepareResult(result, num);

    /* Add all key positions to keys[] */
    keys[0].pos = 1;
    keys[0].flags = 0...",1,4,db.c,georadiusGetKeys,,false,2411,2446,georadiusGetKeys,,,102,"int georadiusGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109690,METHOD,db.c:<global>,TYPE_DECL,"int xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    int i, num = 0;
    keyReference *keys;
    UNUSED(cmd);

    /* We need to parse the options of the command in order to seek the first
     * ""STREAMS"" string which is actually the option. This is needed because
     * ""STREAMS"" could also be the name of the consumer group and even the
     * name of the stream key. */
    int streams_pos = -1;
    for (i = 1; i < argc; i++) {
        char *arg = argv[i]->ptr;
        if (!strcasecmp(arg, ""block"")) {
            i++; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""count"")) {
            i++; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""group"")) {
            i += 2; /* Skip option argument. */
        } else if (!strcasecmp(arg, ""noack"")) {
            /* Nothing to do. */
        } else if (!strcasecmp(arg, ""streams"")) {
            streams_pos = i;
            break;
        } else {
            brea...",1,4,db.c,xreadGetKeys,,false,2452,2496,xreadGetKeys,,,103,"int xreadGetKeys (redisCommand*,robj**,int,getKeysResult*)"
109874,METHOD,db.c:<global>,TYPE_DECL,"int setGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    UNUSED(cmd);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* We always know the position */
    result->numkeys = 1;

    for (int i = 3; i < argc; i++) {
        char *arg = argv[i]->ptr;
        if ((arg[0] == 'g' || arg[0] == 'G') &&
            (arg[1] == 'e' || arg[1] == 'E') &&
            (arg[2] == 't' || arg[2] == 'T') && arg[3] == '\0')
        {
            keys[0].flags = CMD_KEY_RW | CMD_KEY_ACCESS | CMD_KEY_UPDATE;
            return 1;
        }
    }

    keys[0].flags = CMD_KEY_OW | CMD_KEY_UPDATE;
    return 1;
}",1,4,db.c,setGetKeys,,false,2500,2521,setGetKeys,,,104,"int setGetKeys (redisCommand*,robj**,int,getKeysResult*)"
110013,METHOD,db.c:<global>,TYPE_DECL,"int bitfieldGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    keyReference *keys;
    int readonly = 1;
    UNUSED(cmd);

    keys = getKeysPrepareResult(result, 1);
    keys[0].pos = 1; /* We always know the position */
    result->numkeys = 1;

    for (int i = 2; i < argc; i++) {
        int remargs = argc - i - 1; /* Remaining args other than current. */
        char *arg = argv[i]->ptr;
        if (!strcasecmp(arg, ""get"") && remargs >= 2) {
            i += 2;
        } else if ((!strcasecmp(arg, ""set"") || !strcasecmp(arg, ""incrby"")) && remargs >= 3) {
            readonly = 0;
            i += 3;
            break;
        } else if (!strcasecmp(arg, ""overflow"") && remargs >= 1) {
            i += 1;
        } else {
            readonly = 0; /* Syntax error. safer to assume non-RO. */
            break;
        }
    }

    if (readonly) {
        keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;
    } else {
        keys[0].flags = CMD_KEY_RW |...",1,4,db.c,bitfieldGetKeys,,false,2525,2557,bitfieldGetKeys,,,105,"int bitfieldGetKeys (redisCommand*,robj**,int,getKeysResult*)"
110221,METHOD,debug.c:<global>,TYPE_DECL,<global>,1,1,debug.c,debug.c:<global>,,false,1,2322,<global>,,,1,
110231,METHOD,debug.c:<global>,TYPE_DECL,void bugReportStart(void);,6,25,debug.c,bugReportStart,,false,71,71,bugReportStart,,,5,void bugReportStart (void)
110236,METHOD,debug.c:<global>,TYPE_DECL,void printCrashReport(void);,6,27,debug.c,printCrashReport,,false,72,72,printCrashReport,,,6,void printCrashReport (void)
110241,METHOD,debug.c:<global>,TYPE_DECL,"void bugReportEnd(int killViaSignal, int sig);",6,45,debug.c,bugReportEnd,,false,73,73,bugReportEnd,,,7,"void bugReportEnd (int,int)"
110247,METHOD,debug.c:<global>,TYPE_DECL,"void logStackTrace(void *eip, int uplevel);",6,42,debug.c,logStackTrace,,false,74,74,logStackTrace,,,8,"void logStackTrace (void*,int)"
110253,METHOD,debug.c:<global>,TYPE_DECL,"void xorDigest(unsigned char *digest, const void *ptr, size_t len) {
    SHA1_CTX ctx;
    unsigned char hash[20];
    int j;

    SHA1Init(&ctx);
    SHA1Update(&ctx,ptr,len);
    SHA1Final(hash,&ctx);

    for (j = 0; j < 20; j++)
        digest[j] ^= hash[j];
}",1,1,debug.c,xorDigest,,false,84,95,xorDigest,,,9,"void xorDigest (unsigned char*,void*,size_t)"
110292,METHOD,debug.c:<global>,TYPE_DECL,"void xorStringObjectDigest(unsigned char *digest, robj *o) {
    o = getDecodedObject(o);
    xorDigest(digest,o->ptr,sdslen(o->ptr));
    decrRefCount(o);
}",1,1,debug.c,xorStringObjectDigest,,false,97,101,xorStringObjectDigest,,,10,"void xorStringObjectDigest (unsigned char*,robj*)"
110313,METHOD,debug.c:<global>,TYPE_DECL,"void mixDigest(unsigned char *digest, const void *ptr, size_t len) {
    SHA1_CTX ctx;

    xorDigest(digest,ptr,len);
    SHA1Init(&ctx);
    SHA1Update(&ctx,digest,20);
    SHA1Final(digest,&ctx);
}",1,1,debug.c,mixDigest,,false,117,124,mixDigest,,,11,"void mixDigest (unsigned char*,void*,size_t)"
110337,METHOD,debug.c:<global>,TYPE_DECL,"void mixStringObjectDigest(unsigned char *digest, robj *o) {
    o = getDecodedObject(o);
    mixDigest(digest,o->ptr,sdslen(o->ptr));
    decrRefCount(o);
}",1,1,debug.c,mixStringObjectDigest,,false,126,130,mixStringObjectDigest,,,12,"void mixStringObjectDigest (unsigned char*,robj*)"
110358,METHOD,debug.c:<global>,TYPE_DECL,"void xorObjectDigest(redisDb *db, robj *keyobj, unsigned char *digest, robj *o) {
    uint32_t aux = htonl(o->type);
    mixDigest(digest,&aux,sizeof(aux));
    long long expiretime = getExpire(db,keyobj);
    char buf[128];

    /* Save the key and associated value */
    if (o->type == OBJ_STRING) {
        mixStringObjectDigest(digest,o);
    } else if (o->type == OBJ_LIST) {
        listTypeIterator *li = listTypeInitIterator(o,0,LIST_TAIL);
        listTypeEntry entry;
        while(listTypeNext(li,&entry)) {
            robj *eleobj = listTypeGet(&entry);
            mixStringObjectDigest(digest,eleobj);
            decrRefCount(eleobj);
        }
        listTypeReleaseIterator(li);
    } else if (o->type == OBJ_SET) {
        setTypeIterator *si = setTypeInitIterator(o);
        sds sdsele;
        while((sdsele = setTypeNextObject(si)) != NULL) {
            xorDigest(digest,sdsele,sdslen(sdsele));
            sdsfree(sdsele);
        }
        setTypeReleaseIterator(si);
 ...",1,19,debug.c,xorObjectDigest,,false,140,269,xorObjectDigest,,,13,"void xorObjectDigest (redisDb*,robj*,unsigned char*,robj*)"
110948,METHOD,debug.c:<global>,TYPE_DECL,"void computeDatasetDigest(unsigned char *final) {
    unsigned char digest[20];
    dictIterator *di = NULL;
    dictEntry *de;
    int j;
    uint32_t aux;

    memset(final,0,20); /* Start with a clean result */

    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db+j;

        if (dictSize(db->dict) == 0) continue;
        di = dictGetSafeIterator(db->dict);

        /* hash the DB id, so the same dataset moved in a different
         * DB will lead to a different digest */
        aux = htonl(j);
        mixDigest(final,&aux,sizeof(aux));

        /* Iterate this DB writing every entry */
        while((de = dictNext(di)) != NULL) {
            sds key;
            robj *keyobj, *o;

            memset(digest,0,20); /* This key-val digest */
            key = dictGetKey(de);
            keyobj = createStringObject(key,sdslen(key));

            mixDigest(digest,key,sdslen(key));

            o = dictGetVal(de);
            xorObjectDigest(db,keyobj,digest,o);
...",1,12,debug.c,computeDatasetDigest,,false,277,317,computeDatasetDigest,,,14,void computeDatasetDigest (unsigned char*)
111074,METHOD,debug.c:<global>,TYPE_DECL,"void debugCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""AOF-FLUSH-SLEEP <microsec>"",
""    Server will sleep before flushing the AOF, this is used for testing."",
""ASSERT"",
""    Crash by assertion failed."",
""CHANGE-REPL-ID"",
""    Change the replication IDs of the instance."",
""    Dangerous: should be used only for testing the replication subsystem."",
""CONFIG-REWRITE-FORCE-ALL"",
""    Like CONFIG REWRITE but writes all configuration options, including"",
""    keywords not listed in original configuration file or default values."",
""CRASH-AND-RECOVER [<milliseconds>]"",
""    Hard crash and restart after a <milliseconds> delay (default 0)."",
""DIGEST"",
""    Output a hex signature representing the current DB content."",
""DIGEST-VALUE <key> [<key> ...]"",
""    Output a hex signature of the values of all the specified keys."",
""ERROR <string>"",
""    Return a Redis protocol error with <string> as message. Useful for clients"",
""   ...",1,8,debug.c,debugCommand,,false,390,1049,debugCommand,,,15,void debugCommand (client*)
114303,METHOD,debug.c:<global>,TYPE_DECL,"void _serverAssert(const char *estr, const char *file, int line) {
    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED ==="");
    serverLog(LL_WARNING,""==> %s:%d '%s' is not true"",file,line,estr);

    if (server.crashlog_enabled) {
#ifdef HAVE_BACKTRACE
        logStackTrace(NULL, 1);
#endif
        printCrashReport();
    }

    // remove the signal handler so on abort() we will output the crash report.
    removeSignalHandlers();
    bugReportEnd(0, 0);
}",1,4,debug.c,_serverAssert,,false,1053,1068,_serverAssert,,,16,"void _serverAssert (char*,char*,int)"
114360,METHOD,debug.c:<global>,TYPE_DECL,"void _serverAssertPrintClientInfo(const client *c) {
    int j;
    char conninfo[CONN_INFO_LEN];

    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED CLIENT CONTEXT ==="");
    serverLog(LL_WARNING,""client->flags = %llu"", (unsigned long long) c->flags);
    serverLog(LL_WARNING,""client->conn = %s"", connGetInfo(c->conn, conninfo, sizeof(conninfo)));
    serverLog(LL_WARNING,""client->argc = %d"", c->argc);
    for (j=0; j < c->argc; j++) {
        char buf[128];
        char *arg;

        if (c->argv[j]->type == OBJ_STRING && sdsEncodedObject(c->argv[j])) {
            arg = (char*) c->argv[j]->ptr;
        } else {
            snprintf(buf,sizeof(buf),""Object type: %u, encoding: %u"",
                c->argv[j]->type, c->argv[j]->encoding);
            arg = buf;
        }
        serverLog(LL_WARNING,""client->argv[%d] = \""%s\"" (refcount: %d)"",
            j, arg, c->argv[j]->refcount);
    }
}",1,18,debug.c,_serverAssertPrintClientInfo,,false,1070,1093,_serverAssertPrintClientInfo,,,17,void _serverAssertPrintClientInfo (client*)
114572,METHOD,debug.c:<global>,TYPE_DECL,"void serverLogObjectDebugInfo(const robj *o) {
    serverLog(LL_WARNING,""Object type: %u"", o->type);
    serverLog(LL_WARNING,""Object encoding: %u"", o->encoding);
    serverLog(LL_WARNING,""Object refcount: %d"", o->refcount);
#if UNSAFE_CRASH_REPORT
    /* This code is now disabled. o->ptr may be unreliable to print. in some
     * cases a ziplist could have already been freed by realloc, but not yet
     * updated to o->ptr. in other cases the call to ziplistLen may need to
     * iterate on all the items in the list (and possibly crash again).
     * For some cases it may be ok to crash here again, but these could cause
     * invalid memory access which will bother valgrind and also possibly cause
     * random memory portion to be ""leaked"" into the logfile. */
    if (o->type == OBJ_STRING && sdsEncodedObject(o)) {
        serverLog(LL_WARNING,""Object raw string len: %zu"", sdslen(o->ptr));
        if (sdslen(o->ptr) < 4096) {
            sds repr = sdscatrepr(sdsempty(),o->ptr,sd...",1,4,debug.c,serverLogObjectDebugInfo,,false,1095,1128,serverLogObjectDebugInfo,,,18,void serverLogObjectDebugInfo (robj*)
114640,METHOD,debug.c:<global>,TYPE_DECL,"void _serverAssertPrintObject(const robj *o) {
    bugReportStart();
    serverLog(LL_WARNING,""=== ASSERTION FAILED OBJECT CONTEXT ==="");
    serverLogObjectDebugInfo(o);
}",1,4,debug.c,_serverAssertPrintObject,,false,1130,1134,_serverAssertPrintObject,,,19,void _serverAssertPrintObject (robj*)
114666,METHOD,debug.c:<global>,TYPE_DECL,"void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line) {
    if (c) _serverAssertPrintClientInfo(c);
    if (o) _serverAssertPrintObject(o);
    _serverAssert(estr,file,line);
}",1,1,debug.c,_serverAssertWithInfo,,false,1136,1140,_serverAssertWithInfo,,,20,"void _serverAssertWithInfo (client*,robj*,char*,char*,int)"
114689,METHOD,debug.c:<global>,TYPE_DECL,"void _serverPanic(const char *file, int line, const char *msg, ...) {
    va_list ap;
    va_start(ap,msg);
    char fmtmsg[256];
    vsnprintf(fmtmsg,sizeof(fmtmsg),msg,ap);
    va_end(ap);

    bugReportStart();
    serverLog(LL_WARNING,""------------------------------------------------"");
    serverLog(LL_WARNING,""!!! Software Failure. Press left mouse button to continue"");
    serverLog(LL_WARNING,""Guru Meditation: %s #%s:%d"",fmtmsg,file,line);

    if (server.crashlog_enabled) {
#ifdef HAVE_BACKTRACE
        logStackTrace(NULL, 1);
#endif
        printCrashReport();
    }

    // remove the signal handler so on abort() we will output the crash report.
    removeSignalHandlers();
    bugReportEnd(0, 0);
}",1,4,debug.c,_serverPanic,,false,1142,1164,_serverPanic,,,21,"void _serverPanic (char*,int,char*...)"
114778,METHOD,debug.c:<global>,TYPE_DECL,"void bugReportStart(void) {
    pthread_mutex_lock(&bug_report_start_mutex);
    if (bug_report_start == 0) {
        serverLogRaw(LL_WARNING|LL_RAW,
        ""\n\n=== REDIS BUG REPORT START: Cut & paste starting from here ===\n"");
        bug_report_start = 1;
    }
    pthread_mutex_unlock(&bug_report_start_mutex);
}",1,21,debug.c,bugReportStart,,false,1166,1174,bugReportStart,,,22,void bugReportStart (void)
114808,METHOD,debug.c:<global>,TYPE_DECL,"int openDirectLogFiledes(void) {
    int log_to_stdout = server.logfile[0] == '\0';
    int fd = log_to_stdout ?
        STDOUT_FILENO :
        open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
    return fd;
}",1,1,debug.c,openDirectLogFiledes,,false,1804,1810,openDirectLogFiledes,,,23,int openDirectLogFiledes (void)
114841,METHOD,debug.c:<global>,TYPE_DECL,"void closeDirectLogFiledes(int fd) {
    int log_to_stdout = server.logfile[0] == '\0';
    if (!log_to_stdout) close(fd);
}",1,1,debug.c,closeDirectLogFiledes,,false,1813,1816,closeDirectLogFiledes,,,24,void closeDirectLogFiledes (int)
114862,METHOD,debug.c:<global>,TYPE_DECL,"sds genClusterDebugString(sds infostring) {
    infostring = sdscatprintf(infostring, ""\r\n# Cluster info\r\n"");
    infostring = sdscatsds(infostring, genClusterInfoString()); 
    infostring = sdscatprintf(infostring, ""\n------ CLUSTER NODES OUTPUT ------\n"");
    infostring = sdscatsds(infostring, clusterGenNodesDescription(NULL, 0, 0));
    
    return infostring;
}",1,1,debug.c,genClusterDebugString,,false,1857,1864,genClusterDebugString,,,25,sds genClusterDebugString (sds)
114892,METHOD,debug.c:<global>,TYPE_DECL,"void logServerInfo(void) {
    sds infostring, clients;
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ INFO OUTPUT ------\n"");
    int all = 0, everything = 0;
    robj *argv[1];
    argv[0] = createStringObject(""all"", strlen(""all""));
    dict *section_dict = genInfoSectionDict(argv, 1, NULL, &all, &everything);
    infostring = genRedisInfoString(section_dict, all, everything);
    if (server.cluster_enabled){
        infostring = genClusterDebugString(infostring);
    }
    serverLogRaw(LL_WARNING|LL_RAW, infostring);
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ CLIENT LIST OUTPUT ------\n"");
    clients = getAllClientsInfoString(-1);
    serverLogRaw(LL_WARNING|LL_RAW, clients);
    sdsfree(infostring);
    sdsfree(clients);
    releaseInfoSectionDict(section_dict);
    decrRefCount(argv[0]);
}",1,17,debug.c,logServerInfo,,false,1867,1886,logServerInfo,,,26,void logServerInfo (void)
115001,METHOD,debug.c:<global>,TYPE_DECL,"void logConfigDebugInfo(void) {
    sds configstring;
    configstring = getConfigDebugInfo();
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ CONFIG DEBUG OUTPUT ------\n"");
    serverLogRaw(LL_WARNING|LL_RAW, configstring);
    sdsfree(configstring);
}",1,17,debug.c,logConfigDebugInfo,,false,1889,1895,logConfigDebugInfo,,,27,void logConfigDebugInfo (void)
115034,METHOD,debug.c:<global>,TYPE_DECL,"void logModulesInfo(void) {
    serverLogRaw(LL_WARNING|LL_RAW, ""\n------ MODULES INFO OUTPUT ------\n"");
    sds infostring = modulesCollectInfo(sdsempty(), NULL, 1, 0);
    serverLogRaw(LL_WARNING|LL_RAW, infostring);
    sdsfree(infostring);
}",1,17,debug.c,logModulesInfo,,false,1898,1903,logModulesInfo,,,28,void logModulesInfo (void)
115071,METHOD,debug.c:<global>,TYPE_DECL,"void logCurrentClient(client *cc, const char *title) {
    if (cc == NULL) return;

    sds client;
    int j;

    serverLog(LL_WARNING|LL_RAW, ""\n------ %s CLIENT INFO ------\n"", title);
    client = catClientInfoString(sdsempty(),cc);
    serverLog(LL_WARNING|LL_RAW,""%s\n"", client);
    sdsfree(client);
    serverLog(LL_WARNING|LL_RAW,""argc: '%d'\n"", cc->argc);
    for (j = 0; j < cc->argc; j++) {
        robj *decoded;
        decoded = getDecodedObject(cc->argv[j]);
        sds repr = sdscatrepr(sdsempty(),decoded->ptr, min(sdslen(decoded->ptr), 128));
        serverLog(LL_WARNING|LL_RAW,""argv[%d]: '%s'\n"", j, (char*)repr);
        if (!strcasecmp(decoded->ptr, ""auth"") || !strcasecmp(decoded->ptr, ""auth2"")) {
            sdsfree(repr);
            decrRefCount(decoded);
            break;
        }
        sdsfree(repr);
        decrRefCount(decoded);
    }
    /* Check if the first argument, usually a key, is found inside the
     * selected DB, and if so print info about the ...",1,4,debug.c,logCurrentClient,,false,1908,1947,logCurrentClient,,,29,"void logCurrentClient (client*,char*)"
115341,METHOD,debug.c:<global>,TYPE_DECL,"static void killMainThread(void) {
    int err;
    if (pthread_self() != server.main_thread_id && pthread_cancel(server.main_thread_id) == 0) {
        if ((err = pthread_join(server.main_thread_id,NULL)) != 0) {
            serverLog(LL_WARNING, ""main thread can not be joined: %s"", strerror(err));
        } else {
            serverLog(LL_WARNING, ""main thread terminated"");
        }
    }
}",1,12,debug.c,killMainThread,,false,2019,2028,killMainThread,,,30,void killMainThread (void)
115412,METHOD,debug.c:<global>,TYPE_DECL,"void killThreads(void) {
    killMainThread();
    bioKillThreads();
    killIOThreads();
}",1,1,debug.c,killThreads,,false,2034,2038,killThreads,,,31,void killThreads (void)
115420,METHOD,debug.c:<global>,TYPE_DECL,"void doFastMemoryTest(void) {
#if defined(HAVE_PROC_MAPS)
    if (server.memcheck_enabled) {
        /* Test memory */
        serverLogRaw(LL_WARNING|LL_RAW, ""\n------ FAST MEMORY TEST ------\n"");
        killThreads();
        if (memtest_test_linux_anonymous_maps()) {
            serverLogRaw(LL_WARNING|LL_RAW,
                ""!!! MEMORY ERROR DETECTED! Check your memory ASAP !!!\n"");
        } else {
            serverLogRaw(LL_WARNING|LL_RAW,
                ""Fast memory test PASSED, however your memory can still be broken. Please run a memory test for several hours if possible.\n"");
        }
    }
#endif /* HAVE_PROC_MAPS */
}",1,1,debug.c,doFastMemoryTest,,false,2040,2055,doFastMemoryTest,,,32,void doFastMemoryTest (void)
115425,METHOD,debug.c:<global>,TYPE_DECL,"void dumpX86Calls(void *addr, size_t len) {
    size_t j;
    unsigned char *p = addr;
    Dl_info info;
    /* Hash table to best-effort avoid printing the same symbol
     * multiple times. */
    unsigned long ht[256] = {0};

    if (len < 5) return;
    for (j = 0; j < len-4; j++) {
        if (p[j] != 0xE8) continue; /* Not an E8 CALL opcode. */
        unsigned long target = (unsigned long)addr+j+5;
        uint32_t tmp;
        memcpy(&tmp, p+j+1, sizeof(tmp));
        target += tmp;
        if (dladdr((void*)target, &info) != 0 && info.dli_sname != NULL) {
            if (ht[target&0xff] != target) {
                printf(""Function at 0x%lx is %s\n"",target,info.dli_sname);
                ht[target&0xff] = target;
            }
            j += 4; /* Skip the 32 bit immediate. */
        }
    }
}",1,1,debug.c,dumpX86Calls,,false,2060,2083,dumpX86Calls,,,33,"void dumpX86Calls (void*,size_t)"
115534,METHOD,debug.c:<global>,TYPE_DECL,"void dumpCodeAroundEIP(void *eip) {
    Dl_info info;
    if (dladdr(eip, &info) != 0) {
        serverLog(LL_WARNING|LL_RAW,
            ""\n------ DUMPING CODE AROUND EIP ------\n""
            ""Symbol: %s (base: %p)\n""
            ""Module: %s (base %p)\n""
            ""$ xxd -r -p /tmp/dump.hex /tmp/dump.bin\n""
            ""$ objdump --adjust-vma=%p -D -b binary -m i386:x86-64 /tmp/dump.bin\n""
            ""------\n"",
            info.dli_sname, info.dli_saddr, info.dli_fname, info.dli_fbase,
            info.dli_saddr);
        size_t len = (long)eip - (long)info.dli_saddr;
        unsigned long sz = sysconf(_SC_PAGESIZE);
        if (len < 1<<13) { /* we don't have functions over 8k (verified) */
            /* Find the address of the next page, which is our ""safety""
             * limit when dumping. Then try to dump just 128 bytes more
             * than EIP if there is room, or stop sooner. */
            void *base = (void *)info.dli_saddr;
            unsigned long next = ((u...",1,8,debug.c,dumpCodeAroundEIP,,false,2085,2113,dumpCodeAroundEIP,,,34,void dumpCodeAroundEIP (void*)
115667,METHOD,debug.c:<global>,TYPE_DECL,void invalidFunctionWasCalled(void) {},1,38,debug.c,invalidFunctionWasCalled,,false,2115,2115,invalidFunctionWasCalled,,,35,void invalidFunctionWasCalled (void)
115672,METHOD,debug.c:<global>,TYPE_DECL,typedef void (*invalidFunctionWasCalledType)(void);,14,50,debug.c,invalidFunctionWasCalledType,,false,2117,2117,invalidFunctionWasCalledType,,,36,void invalidFunctionWasCalledType (void)
115677,METHOD,debug.c:<global>,TYPE_DECL,"void sigsegvHandler(int sig, siginfo_t *info, void *secret) {
    UNUSED(secret);
    UNUSED(info);

    bugReportStart();
    serverLog(LL_WARNING,
        ""Redis %s crashed by signal: %d, si_code: %d"", REDIS_VERSION, sig, info->si_code);
    if (sig == SIGSEGV || sig == SIGBUS) {
        serverLog(LL_WARNING,
        ""Accessing address: %p"", (void*)info->si_addr);
    }
    if (info->si_code == SI_USER && info->si_pid != -1) {
        serverLog(LL_WARNING, ""Killed by PID: %ld, UID: %d"", (long) info->si_pid, info->si_uid);
    }

#ifdef HAVE_BACKTRACE
    ucontext_t *uc = (ucontext_t*) secret;
    void *eip = getAndSetMcontextEip(uc, NULL);
    if (eip != NULL) {
        serverLog(LL_WARNING,
        ""Crashed running the instruction at: %p"", eip);
    }

    if (eip == info->si_addr) {
        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped
         * function pointer. In that case the call to backtrace will crash trying to access t...",1,4,debug.c,sigsegvHandler,,false,2119,2172,sigsegvHandler,,,37,"void sigsegvHandler (int,siginfo_t*,void*)"
115796,METHOD,debug.c:<global>,TYPE_DECL,"void printCrashReport(void) {
    /* Log INFO and CLIENT LIST */
    logServerInfo();

    /* Log the current client */
    logCurrentClient(server.current_client, ""CURRENT"");
    logCurrentClient(server.executing_client, ""EXECUTING"");

    /* Log modules info. Something we wanna do last since we fear it may crash. */
    logModulesInfo();

    /* Log debug config information, which are some values
     * which may be useful for debugging crashes. */
    logConfigDebugInfo();

    /* Run memory test in case the crash was triggered by memory corruption. */
    doFastMemoryTest();
}",1,1,debug.c,printCrashReport,,false,2174,2191,printCrashReport,,,38,void printCrashReport (void)
115815,METHOD,debug.c:<global>,TYPE_DECL,"void bugReportEnd(int killViaSignal, int sig) {
    struct sigaction act;

    serverLogRaw(LL_WARNING|LL_RAW,
""\n=== REDIS BUG REPORT END. Make sure to include from START to END. ===\n\n""
""       Please report the crash by opening an issue on github:\n\n""
""           http://github.com/redis/redis/issues\n\n""
""  If a Redis module was involved, please open in the module's repo instead.\n\n""
""  Suspect RAM error? Use redis-server --test-memory to verify it.\n\n""
""  Some other issues could be detected by redis-server --check-system\n""
);

    /* free(messages); Don't call free() with possibly corrupted memory. */
    if (server.daemonize && server.supervised == 0 && server.pidfile) unlink(server.pidfile);

    if (!killViaSignal) {
        /* To avoid issues with valgrind, we may wanna exit rahter than generate a signal */
        if (server.use_exit_on_panic) {
             /* Using _exit to bypass false leak reports by gcc ASAN */
             fflush(stdout);
            _exit(1);
  ...",1,17,debug.c,bugReportEnd,,false,2193,2225,bugReportEnd,,,39,"void bugReportEnd (int,int)"
115893,METHOD,debug.c:<global>,TYPE_DECL,"void serverLogHexDump(int level, char *descr, void *value, size_t len) {
    char buf[65], *b;
    unsigned char *v = value;
    char charset[] = ""0123456789abcdef"";

    serverLog(level,""%s (hexdump of %zu bytes):"", descr, len);
    b = buf;
    while(len) {
        b[0] = charset[(*v)>>4];
        b[1] = charset[(*v)&0xf];
        b[2] = '\0';
        b += 2;
        len--;
        v++;
        if (b-buf == 64 || len == 0) {
            serverLogRaw(level|LL_RAW,buf);
            b = buf;
        }
    }
    serverLogRaw(level|LL_RAW,""\n"");
}",1,4,debug.c,serverLogHexDump,,false,2229,2249,serverLogHexDump,,,40,"void serverLogHexDump (int,char*,void*,size_t)"
116002,METHOD,debug.c:<global>,TYPE_DECL,"void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {
#ifdef HAVE_BACKTRACE
    ucontext_t *uc = (ucontext_t*) secret;
#else
    (void)secret;
#endif
    UNUSED(info);
    UNUSED(sig);

    serverLogFromHandler(LL_WARNING,""\n--- WATCHDOG TIMER EXPIRED ---"");
#ifdef HAVE_BACKTRACE
    logStackTrace(getAndSetMcontextEip(uc, NULL), 1);
#else
    serverLogFromHandler(LL_WARNING,""Sorry: no support for backtrace()."");
#endif
    serverLogFromHandler(LL_WARNING,""--------\n"");
}",1,4,debug.c,watchdogSignalHandler,,false,2254,2270,watchdogSignalHandler,,,41,"void watchdogSignalHandler (int,siginfo_t*,void*)"
116039,METHOD,debug.c:<global>,TYPE_DECL,"void watchdogScheduleSignal(int period) {
    struct itimerval it;

    /* Will stop the timer if period is 0. */
    it.it_value.tv_sec = period/1000;
    it.it_value.tv_usec = (period%1000)*1000;
    /* Don't automatically restart. */
    it.it_interval.tv_sec = 0;
    it.it_interval.tv_usec = 0;
    setitimer(ITIMER_REAL, &it, NULL);
}",1,1,debug.c,watchdogScheduleSignal,,false,2275,2285,watchdogScheduleSignal,,,42,void watchdogScheduleSignal (int)
116084,METHOD,debug.c:<global>,TYPE_DECL,"void applyWatchdogPeriod(void) {
    struct sigaction act;

    /* Disable watchdog when period is 0 */
    if (server.watchdog_period == 0) {
        watchdogScheduleSignal(0); /* Stop the current timer. */

        /* Set the signal handler to SIG_IGN, this will also remove pending
         * signals from the queue. */
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;
        act.sa_handler = SIG_IGN;
        sigaction(SIGALRM, &act, NULL);
    } else {
        /* Setup the signal handler. */
        sigemptyset(&act.sa_mask);
        act.sa_flags = SA_SIGINFO;
        act.sa_sigaction = watchdogSignalHandler;
        sigaction(SIGALRM, &act, NULL);

        /* If the configured period is smaller than twice the timer period, it is
         * too short for the software watchdog to work reliably. Fix it now
         * if needed. */
        int min_period = (1000/server.hz)*2;
        if (server.watchdog_period < min_period) server.watchdog_period = min_period;
        wat...",1,1,debug.c,applyWatchdogPeriod,,false,2286,2313,applyWatchdogPeriod,,,43,void applyWatchdogPeriod (void)
116167,METHOD,debug.c:<global>,TYPE_DECL,"void debugDelay(int usec) {
    /* Since even the shortest sleep results in context switch and system call,
     * the way we achieve short sleeps is by statistically sleeping less often. */
    if (usec < 0) usec = (rand() % -usec) == 0 ? 1: 0;
    if (usec) usleep(usec);
}",1,1,debug.c,debugDelay,,false,2317,2322,debugDelay,,,44,void debugDelay (int)
116198,METHOD,debugmacro.h:<global>,TYPE_DECL,<global>,1,33,debugmacro.h,debugmacro.h:<global>,,false,1,46,<global>,,,1,
116213,METHOD,defrag.c:<global>,TYPE_DECL,<global>,1,1,defrag.c,defrag.c:<global>,,false,1,1079,<global>,,,1,
116215,METHOD,defrag.c:<global>,TYPE_DECL,"void activeDefragCycle(void) {
    /* Not implemented yet. */
}",1,1,defrag.c,activeDefragCycle,,false,1065,1067,activeDefragCycle,,,1,void activeDefragCycle (void)
116220,METHOD,defrag.c:<global>,TYPE_DECL,"void *activeDefragAlloc(void *ptr) {
    UNUSED(ptr);
    return NULL;
}",1,4,defrag.c,activeDefragAlloc,,false,1069,1072,activeDefragAlloc,,,2,void* activeDefragAlloc (void*)
116233,METHOD,defrag.c:<global>,TYPE_DECL,"robj *activeDefragStringOb(robj *ob) {
    UNUSED(ob);
    return NULL;
}",1,4,defrag.c,activeDefragStringOb,,false,1074,1077,activeDefragStringOb,,,3,robj activeDefragStringOb (robj*)
116273,METHOD,dict.c:<global>,TYPE_DECL,<global>,1,1,dict.c,dict.c:<global>,,false,1,1754,<global>,,,1,
116294,METHOD,<empty>,<empty>,<empty>,1,,dict.c,dictEntry:<clinit>,,false,63,,<clinit>,,,7,
116303,METHOD,dict.c:<global>,TYPE_DECL,static int _dictExpandIfNeeded(dict *d);,12,39,dict.c,_dictExpandIfNeeded,,false,84,84,_dictExpandIfNeeded,,,8,int _dictExpandIfNeeded (dict*)
116308,METHOD,dict.c:<global>,TYPE_DECL,static signed char _dictNextExp(unsigned long size);,20,51,dict.c,_dictNextExp,,false,85,85,_dictNextExp,,,9,signed char _dictNextExp (long unsigned)
116313,METHOD,dict.c:<global>,TYPE_DECL,"static int _dictInit(dict *d, dictType *type);",12,45,dict.c,_dictInit,,false,86,86,_dictInit,,,10,"int _dictInit (dict*,dictType*)"
116319,METHOD,dict.c:<global>,TYPE_DECL,static dictEntry *dictGetNext(const dictEntry *de);,18,50,dict.c,dictGetNext,,false,87,87,dictGetNext,,,11,dictEntry* dictGetNext (dictEntry*)
116324,METHOD,dict.c:<global>,TYPE_DECL,static dictEntry **dictGetNextRef(dictEntry *de);,18,48,dict.c,dictGetNextRef,,false,88,88,dictGetNextRef,,,12,dictEntry** dictGetNextRef (dictEntry*)
116329,METHOD,dict.c:<global>,TYPE_DECL,"static void dictSetNext(dictEntry *de, dictEntry *next);",13,55,dict.c,dictSetNext,,false,89,89,dictSetNext,,,13,"void dictSetNext (dictEntry*,dictEntry*)"
116338,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetHashFunctionSeed(uint8_t *seed) {
    memcpy(dict_hash_function_seed,seed,sizeof(dict_hash_function_seed));
}",1,1,dict.c,dictSetHashFunctionSeed,,false,95,97,dictSetHashFunctionSeed,,,16,void dictSetHashFunctionSeed (uint8_t*)
116348,METHOD,dict.c:<global>,TYPE_DECL,"uint8_t *dictGetHashFunctionSeed(void) {
    return dict_hash_function_seed;
}",1,1,dict.c,dictGetHashFunctionSeed,,false,99,101,dictGetHashFunctionSeed,,,17,uint8_t dictGetHashFunctionSeed (void)
116355,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k);",10,73,dict.c,siphash,,false,106,106,siphash,,,18,"uint64_t siphash (uint8_t*,size_t,uint8_t*)"
116362,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k);",10,80,dict.c,siphash_nocase,,false,107,107,siphash_nocase,,,19,"uint64_t siphash_nocase (uint8_t*,size_t,uint8_t*)"
116369,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t dictGenHashFunction(const void *key, size_t len) {
    return siphash(key,len,dict_hash_function_seed);
}",1,1,dict.c,dictGenHashFunction,,false,109,111,dictGenHashFunction,,,20,"uint64_t dictGenHashFunction (void*,size_t)"
116380,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t dictGenCaseHashFunction(const unsigned char *buf, size_t len) {
    return siphash_nocase(buf,len,dict_hash_function_seed);
}",1,1,dict.c,dictGenCaseHashFunction,,false,113,115,dictGenCaseHashFunction,,,21,"uint64_t dictGenCaseHashFunction (unsigned char*,size_t)"
116391,METHOD,dict.c:<global>,TYPE_DECL,"static inline int entryIsKey(const dictEntry *de) {
    return (uintptr_t)(void *)de & 1;
}",1,1,dict.c,entryIsKey,,false,129,131,entryIsKey,,,22,int entryIsKey (dictEntry*)
116404,METHOD,dict.c:<global>,TYPE_DECL,"static inline int entryIsNormal(const dictEntry *de) {
    return ((uintptr_t)(void *)de & ENTRY_PTR_MASK) == ENTRY_PTR_NORMAL;
}",1,36,dict.c,entryIsNormal,,false,135,137,entryIsNormal,,,23,int entryIsNormal (dictEntry*)
116423,METHOD,dict.c:<global>,TYPE_DECL,"static inline int entryIsNoValue(const dictEntry *de) {
    return ((uintptr_t)(void *)de & ENTRY_PTR_MASK) == ENTRY_PTR_NO_VALUE;
}",1,36,dict.c,entryIsNoValue,,false,141,143,entryIsNoValue,,,24,int entryIsNoValue (dictEntry*)
116442,METHOD,dict.c:<global>,TYPE_DECL,"static inline dictEntry *createEntryNoValue(void *key, dictEntry *next) {
    dictEntryNoValue *entry = zmalloc(sizeof(*entry));
    entry->key = key;
    entry->next = next;
    return (dictEntry *)(void *)((uintptr_t)(void *)entry | ENTRY_PTR_NO_VALUE);
}",1,60,dict.c,createEntryNoValue,,false,146,151,createEntryNoValue,,,25,"dictEntry createEntryNoValue (void*,dictEntry*)"
116479,METHOD,dict.c:<global>,TYPE_DECL,"static inline dictEntry *encodeMaskedPtr(const void *ptr, unsigned int bits) {
    assert(((uintptr_t)ptr & ENTRY_PTR_MASK) == 0);
    return (dictEntry *)(void *)((uintptr_t)ptr | bits);
}",1,4,dict.c,encodeMaskedPtr,,false,153,156,encodeMaskedPtr,,,26,"dictEntry encodeMaskedPtr (void*,unsigned int)"
116515,METHOD,dict.c:<global>,TYPE_DECL,"static inline void *decodeMaskedPtr(const dictEntry *de) {
    assert(!entryIsKey(de));
    return (void *)((uintptr_t)(void *)de & ~ENTRY_PTR_MASK);
}",1,4,dict.c,decodeMaskedPtr,,false,158,161,decodeMaskedPtr,,,27,void* decodeMaskedPtr (dictEntry*)
116552,METHOD,dict.c:<global>,TYPE_DECL,"static inline dictEntryNoValue *decodeEntryNoValue(const dictEntry *de) {
    return decodeMaskedPtr(de);
}",1,1,dict.c,decodeEntryNoValue,,false,165,167,decodeEntryNoValue,,,28,dictEntryNoValue decodeEntryNoValue (dictEntry*)
116560,METHOD,dict.c:<global>,TYPE_DECL,"static inline int entryHasValue(const dictEntry *de) {
    return entryIsNormal(de);
}",1,1,dict.c,entryHasValue,,false,170,172,entryHasValue,,,29,int entryHasValue (dictEntry*)
116568,METHOD,dict.c:<global>,TYPE_DECL,"static void _dictReset(dict *d, int htidx)
{
    d->ht_table[htidx] = NULL;
    d->ht_size_exp[htidx] = -1;
    d->ht_used[htidx] = 0;
}",1,1,dict.c,_dictReset,,false,177,182,_dictReset,,,30,"void _dictReset (dict*,int)"
116596,METHOD,dict.c:<global>,TYPE_DECL,"dict *dictCreate(dictType *type)
{
    size_t metasize = type->dictMetadataBytes ? type->dictMetadataBytes() : 0;
    dict *d = zmalloc(sizeof(*d) + metasize);
    if (metasize) {
        memset(dictMetadata(d), 0, metasize);
    }

    _dictInit(d,type);
    return d;
}",1,1,dict.c,dictCreate,,false,185,195,dictCreate,,,31,dict dictCreate (dictType*)
116635,METHOD,dict.c:<global>,TYPE_DECL,"int _dictInit(dict *d, dictType *type)
{
    _dictReset(d, 0);
    _dictReset(d, 1);
    d->type = type;
    d->rehashidx = -1;
    d->pauserehash = 0;
    return DICT_OK;
}",1,11,dict.c,_dictInit,,false,198,206,_dictInit,,,32,"int _dictInit (dict*,dictType*)"
116667,METHOD,dict.c:<global>,TYPE_DECL,"int dictResize(dict *d)
{
    unsigned long minimal;

    if (dict_can_resize != DICT_RESIZE_ENABLE || dictIsRehashing(d)) return DICT_ERR;
    minimal = d->ht_used[0];
    if (minimal < DICT_HT_INITIAL_SIZE)
        minimal = DICT_HT_INITIAL_SIZE;
    return dictExpand(d, minimal);
}",1,49,dict.c,dictResize,,false,210,219,dictResize,,,33,int dictResize (dict*)
116719,METHOD,dict.c:<global>,TYPE_DECL,"int _dictExpand(dict *d, unsigned long size, int* malloc_failed)
{
    if (malloc_failed) *malloc_failed = 0;

    /* the size is invalid if it is smaller than the number of
     * elements already inside the hash table */
    if (dictIsRehashing(d) || d->ht_used[0] > size)
        return DICT_ERR;

    /* the new hash table */
    dictEntry **new_ht_table;
    unsigned long new_ht_used;
    signed char new_ht_size_exp = _dictNextExp(size);

    /* Detect overflows */
    size_t newsize = 1ul<<new_ht_size_exp;
    if (newsize < size || newsize * sizeof(dictEntry*) < newsize)
        return DICT_ERR;

    /* Rehashing to the same table size is not useful. */
    if (new_ht_size_exp == d->ht_size_exp[0]) return DICT_ERR;

    /* Allocate the new hash table and initialize all pointers to NULL */
    if (malloc_failed) {
        new_ht_table = ztrycalloc(newsize*sizeof(dictEntry*));
        *malloc_failed = new_ht_table == NULL;
        if (*malloc_failed)
            return DICT_ERR;
 ...",1,8,dict.c,_dictExpand,,false,224,272,_dictExpand,,,34,"int _dictExpand (dict*,long unsigned,int*)"
116898,METHOD,dict.c:<global>,TYPE_DECL,"int dictExpand(dict *d, unsigned long size) {
    return _dictExpand(d, size, NULL);
}",1,1,dict.c,dictExpand,,false,275,277,dictExpand,,,35,"int dictExpand (dict*,long unsigned)"
116909,METHOD,dict.c:<global>,TYPE_DECL,"int dictTryExpand(dict *d, unsigned long size) {
    int malloc_failed;
    _dictExpand(d, size, &malloc_failed);
    return malloc_failed? DICT_ERR : DICT_OK;
}",1,26,dict.c,dictTryExpand,,false,280,284,dictTryExpand,,,36,"int dictTryExpand (dict*,long unsigned)"
116930,METHOD,dict.c:<global>,TYPE_DECL,"int dictRehash(dict *d, int n) {
    int empty_visits = n*10; /* Max number of empty buckets to visit. */
    unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);
    unsigned long s1 = DICTHT_SIZE(d->ht_size_exp[1]);
    if (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) return 0;
    if (dict_can_resize == DICT_RESIZE_AVOID && 
        ((s1 > s0 && s1 / s0 < dict_force_resize_ratio) ||
         (s1 < s0 && s0 / s1 < dict_force_resize_ratio)))
    {
        return 0;
    }

    while(n-- && d->ht_used[0] != 0) {
        dictEntry *de, *nextde;

        /* Note that rehashidx can't overflow as we are sure there are more
         * elements because ht[0].used != 0 */
        assert(DICTHT_SIZE(d->ht_size_exp[0]) > (unsigned long)d->rehashidx);
        while(d->ht_table[0][d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }
        de = d->ht_table[0][d->rehashidx];
        /* Move all the keys in this bucket from ...",1,23,dict.c,dictRehash,,false,295,381,dictRehash,,,37,"int dictRehash (dict*,int)"
117464,METHOD,dict.c:<global>,TYPE_DECL,"long long timeInMilliseconds(void) {
    struct timeval tv;

    gettimeofday(&tv,NULL);
    return (((long long)tv.tv_sec)*1000)+(tv.tv_usec/1000);
}",1,1,dict.c,timeInMilliseconds,,false,383,388,timeInMilliseconds,,,38,long long timeInMilliseconds (void)
117488,METHOD,dict.c:<global>,TYPE_DECL,"int dictRehashMilliseconds(dict *d, int ms) {
    if (d->pauserehash > 0) return 0;

    long long start = timeInMilliseconds();
    int rehashes = 0;

    while(dictRehash(d,100)) {
        rehashes += 100;
        if (timeInMilliseconds()-start > ms) break;
    }
    return rehashes;
}",1,1,dict.c,dictRehashMilliseconds,,false,393,404,dictRehashMilliseconds,,,39,"int dictRehashMilliseconds (dict*,int)"
117529,METHOD,dict.c:<global>,TYPE_DECL,"static void _dictRehashStep(dict *d) {
    if (d->pauserehash == 0) dictRehash(d,1);
}",1,1,dict.c,_dictRehashStep,,false,414,416,_dictRehashStep,,,40,void _dictRehashStep (dict*)
117544,METHOD,dict.c:<global>,TYPE_DECL,"void *dictMetadata(dict *d) {
    return &d->metadata;
}",1,1,dict.c,dictMetadata,,false,419,421,dictMetadata,,,41,void* dictMetadata (dict*)
117554,METHOD,dict.c:<global>,TYPE_DECL,"int dictAdd(dict *d, void *key, void *val)
{
    dictEntry *entry = dictAddRaw(d,key,NULL);

    if (!entry) return DICT_ERR;
    if (!d->type->no_value) dictSetVal(d, entry, val);
    return DICT_OK;
}",1,23,dict.c,dictAdd,,false,424,431,dictAdd,,,42,"int dictAdd (dict*,void*,void*)"
117592,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing)
{
    /* Get the position for the new key or NULL if the key already exists. */
    void *position = dictFindPositionForInsert(d, key, existing);
    if (!position) return NULL;

    /* Dup the key if necessary. */
    if (d->type->keyDup) key = d->type->keyDup(d, key);

    return dictInsertAtPosition(d, key, position);
}",1,1,dict.c,dictAddRaw,,false,451,461,dictAddRaw,,,43,"dictEntry dictAddRaw (dict*,void*,dictEntry**)"
117634,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictInsertAtPosition(dict *d, void *key, void *position) {
    dictEntry **bucket = position; /* It's a bucket, but the API hides that. */
    dictEntry *entry;
    /* If rehashing is ongoing, we insert in table 1, otherwise in table 0.
     * Assert that the provided bucket is the right table. */
    int htidx = dictIsRehashing(d) ? 1 : 0;
    assert(bucket >= &d->ht_table[htidx][0] &&
           bucket <= &d->ht_table[htidx][DICTHT_SIZE_MASK(d->ht_size_exp[htidx])]);
    size_t metasize = dictEntryMetadataSize(d);
    if (d->type->no_value) {
        assert(!metasize); /* Entry metadata + no value not supported. */
        if (d->type->keys_are_odd && !*bucket) {
            /* We can store the key directly in the destination bucket without the
             * allocated entry.
             *
             * TODO: Add a flag 'keys_are_even' and if set, we can use this
             * optimization for these dicts too. We can set the LSB bit when
             * stored as a di...",1,16,dict.c,dictInsertAtPosition,,false,467,509,dictInsertAtPosition,,,44,"dictEntry dictInsertAtPosition (dict*,void*,void*)"
117868,METHOD,dict.c:<global>,TYPE_DECL,"int dictReplace(dict *d, void *key, void *val)
{
    dictEntry *entry, *existing;

    /* Try to add the element. If the key
     * does not exists dictAdd will succeed. */
    entry = dictAddRaw(d,key,&existing);
    if (entry) {
        dictSetVal(d, entry, val);
        return 1;
    }

    /* Set the new value and free the old one. Note that it is important
     * to do that in this order, as the value may just be exactly the same
     * as the previous one. In this context, think to reference counting,
     * you want to increment (set), and then decrement (free), and not the
     * reverse. */
    void *oldval = dictGetVal(existing);
    dictSetVal(d, existing, val);
    if (d->type->valDestructor)
        d->type->valDestructor(d, oldval);
    return 0;
}",1,1,dict.c,dictReplace,,false,516,538,dictReplace,,,45,"int dictReplace (dict*,void*,void*)"
117919,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictAddOrFind(dict *d, void *key) {
    dictEntry *entry, *existing;
    entry = dictAddRaw(d,key,&existing);
    return entry ? entry : existing;
}",1,1,dict.c,dictAddOrFind,,false,547,551,dictAddOrFind,,,46,"dictEntry dictAddOrFind (dict*,void*)"
117939,METHOD,dict.c:<global>,TYPE_DECL,"static dictEntry *dictGenericDelete(dict *d, const void *key, int nofree) {
    uint64_t h, idx;
    dictEntry *he, *prevHe;
    int table;

    /* dict is empty */
    if (dictSize(d) == 0) return NULL;

    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        prevHe = NULL;
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key)) {
                /* Unlink the element from the list */
                if (prevHe)
                    dictSetNext(prevHe, dictGetNext(he));
                else
                    d->ht_table[table][idx] = dictGetNext(he);
                if (!nofree) {
                    dictFreeUnlinkedEntry(d, he);
                }
                d->ht_used[table]--;
                return he;
            }
            prevHe...",1,8,dict.c,dictGenericDelete,,false,556,591,dictGenericDelete,,,47,"dictEntry dictGenericDelete (dict*,void*,int)"
118155,METHOD,dict.c:<global>,TYPE_DECL,"int dictDelete(dict *ht, const void *key) {
    return dictGenericDelete(ht,key,0) ? DICT_OK : DICT_ERR;
}",1,41,dict.c,dictDelete,,false,595,597,dictDelete,,,48,"int dictDelete (dict*,void*)"
118173,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictUnlink(dict *d, const void *key) {
    return dictGenericDelete(d,key,1);
}",1,1,dict.c,dictUnlink,,false,620,622,dictUnlink,,,49,"dictEntry dictUnlink (dict*,void*)"
118184,METHOD,dict.c:<global>,TYPE_DECL,"void dictFreeUnlinkedEntry(dict *d, dictEntry *he) {
    if (he == NULL) return;
    dictFreeKey(d, he);
    dictFreeVal(d, he);
    if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
}",1,4,dict.c,dictFreeUnlinkedEntry,,false,626,631,dictFreeUnlinkedEntry,,,50,"void dictFreeUnlinkedEntry (dict*,dictEntry*)"
118247,METHOD,dict.c:<global>,TYPE_DECL,"int _dictClear(dict *d, int htidx, void(callback)(dict*)) {
    unsigned long i;

    /* Free all the elements */
    for (i = 0; i < DICTHT_SIZE(d->ht_size_exp[htidx]) && d->ht_used[htidx] > 0; i++) {
        dictEntry *he, *nextHe;

        if (callback && (i & 65535) == 0) callback(d);

        if ((he = d->ht_table[htidx][i]) == NULL) continue;
        while(he) {
            nextHe = dictGetNext(he);
            dictFreeKey(d, he);
            dictFreeVal(d, he);
            if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
            d->ht_used[htidx]--;
            he = nextHe;
        }
    }
    /* Free the table and the allocated cache structure */
    zfree(d->ht_table[htidx]);
    /* Re-initialize the table */
    _dictReset(d, htidx);
    return DICT_OK; /* never fails */
}",1,20,dict.c,_dictClear,,false,634,658,_dictClear,,,51,"int _dictClear (dict*,int,void)"
118406,METHOD,dict.c:<global>,TYPE_DECL,"void dictRelease(dict *d)
{
    _dictClear(d,0,NULL);
    _dictClear(d,1,NULL);
    zfree(d);
}",1,1,dict.c,dictRelease,,false,661,666,dictRelease,,,52,void dictRelease (dict*)
118421,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictFind(dict *d, const void *key)
{
    dictEntry *he;
    uint64_t h, idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);
    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key))
                return he;
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",1,8,dict.c,dictFind,,false,668,688,dictFind,,,53,"dictEntry dictFind (dict*,void*)"
118598,METHOD,dict.c:<global>,TYPE_DECL,"void *dictFetchValue(dict *d, const void *key) {
    dictEntry *he;

    he = dictFind(d,key);
    return he ? dictGetVal(he) : NULL;
}",1,1,dict.c,dictFetchValue,,false,690,695,dictFetchValue,,,54,"void* dictFetchValue (dict*,void*)"
118616,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictTwoPhaseUnlinkFind(dict *d, const void *key, dictEntry ***plink, int *table_index) {
    uint64_t h, idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    if (dictIsRehashing(d)) _dictRehashStep(d);
    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        dictEntry **ref = &d->ht_table[table][idx];
        while (ref && *ref) {
            void *de_key = dictGetKey(*ref);
            if (key == de_key || dictCompareKeys(d, key, de_key)) {
                *table_index = table;
                *plink = ref;
                dictPauseRehashing(d);
                return *ref;
            }
            ref = dictGetNextRef(*ref);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",1,8,dict.c,dictTwoPhaseUnlinkFind,,false,713,736,dictTwoPhaseUnlinkFind,,,55,"dictEntry dictTwoPhaseUnlinkFind (dict*,void*,dictEntry***,int*)"
118817,METHOD,dict.c:<global>,TYPE_DECL,"void dictTwoPhaseUnlinkFree(dict *d, dictEntry *he, dictEntry **plink, int table_index) {
    if (he == NULL) return;
    d->ht_used[table_index]--;
    *plink = dictGetNext(he);
    dictFreeKey(d, he);
    dictFreeVal(d, he);
    if (!entryIsKey(he)) zfree(decodeMaskedPtr(he));
    dictResumeRehashing(d);
}",1,4,dict.c,dictTwoPhaseUnlinkFree,,false,738,746,dictTwoPhaseUnlinkFree,,,56,"void dictTwoPhaseUnlinkFree (dict*,dictEntry*,dictEntry**,int)"
118900,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetKey(dict *d, dictEntry* de, void *key) {
    assert(!d->type->no_value);
    if (d->type->keyDup)
        de->key = d->type->keyDup(d, key);
    else
        de->key = key;
}",1,4,dict.c,dictSetKey,,false,748,754,dictSetKey,,,57,"void dictSetKey (dict*,dictEntry*,void*)"
118958,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetVal(dict *d, dictEntry *de, void *val) {
    assert(entryHasValue(de));
    de->v.val = d->type->valDup ? d->type->valDup(d, val) : val;
}",1,4,dict.c,dictSetVal,,false,756,759,dictSetVal,,,58,"void dictSetVal (dict*,dictEntry*,void*)"
119003,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetSignedIntegerVal(dictEntry *de, int64_t val) {
    assert(entryHasValue(de));
    de->v.s64 = val;
}",1,4,dict.c,dictSetSignedIntegerVal,,false,761,764,dictSetSignedIntegerVal,,,59,"void dictSetSignedIntegerVal (dictEntry*,int64_t)"
119033,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetUnsignedIntegerVal(dictEntry *de, uint64_t val) {
    assert(entryHasValue(de));
    de->v.u64 = val;
}",1,4,dict.c,dictSetUnsignedIntegerVal,,false,766,769,dictSetUnsignedIntegerVal,,,60,"void dictSetUnsignedIntegerVal (dictEntry*,uint64_t)"
119063,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetDoubleVal(dictEntry *de, double val) {
    assert(entryHasValue(de));
    de->v.d = val;
}",1,4,dict.c,dictSetDoubleVal,,false,771,774,dictSetDoubleVal,,,61,"void dictSetDoubleVal (dictEntry*,double)"
119093,METHOD,dict.c:<global>,TYPE_DECL,"int64_t dictIncrSignedIntegerVal(dictEntry *de, int64_t val) {
    assert(entryHasValue(de));
    return de->v.s64 += val;
}",1,4,dict.c,dictIncrSignedIntegerVal,,false,776,779,dictIncrSignedIntegerVal,,,62,"int64_t dictIncrSignedIntegerVal (dictEntry*,int64_t)"
119124,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t dictIncrUnsignedIntegerVal(dictEntry *de, uint64_t val) {
    assert(entryHasValue(de));
    return de->v.u64 += val;
}",1,4,dict.c,dictIncrUnsignedIntegerVal,,false,781,784,dictIncrUnsignedIntegerVal,,,63,"uint64_t dictIncrUnsignedIntegerVal (dictEntry*,uint64_t)"
119155,METHOD,dict.c:<global>,TYPE_DECL,"double dictIncrDoubleVal(dictEntry *de, double val) {
    assert(entryHasValue(de));
    return de->v.d += val;
}",1,4,dict.c,dictIncrDoubleVal,,false,786,789,dictIncrDoubleVal,,,64,"double dictIncrDoubleVal (dictEntry*,double)"
119186,METHOD,dict.c:<global>,TYPE_DECL,"void *dictEntryMetadata(dictEntry *de) {
    assert(entryHasValue(de));
    return &de->metadata;
}",1,4,dict.c,dictEntryMetadata,,false,792,795,dictEntryMetadata,,,65,void* dictEntryMetadata (dictEntry*)
119213,METHOD,dict.c:<global>,TYPE_DECL,"void *dictGetKey(const dictEntry *de) {
    if (entryIsKey(de)) return (void*)de;
    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->key;
    return de->key;
}",1,1,dict.c,dictGetKey,,false,797,801,dictGetKey,,,66,void* dictGetKey (dictEntry*)
119239,METHOD,dict.c:<global>,TYPE_DECL,"void *dictGetVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.val;
}",1,4,dict.c,dictGetVal,,false,803,806,dictGetVal,,,67,void* dictGetVal (dictEntry*)
119267,METHOD,dict.c:<global>,TYPE_DECL,"int64_t dictGetSignedIntegerVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.s64;
}",1,4,dict.c,dictGetSignedIntegerVal,,false,808,811,dictGetSignedIntegerVal,,,68,int64_t dictGetSignedIntegerVal (dictEntry*)
119295,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t dictGetUnsignedIntegerVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.u64;
}",1,4,dict.c,dictGetUnsignedIntegerVal,,false,813,816,dictGetUnsignedIntegerVal,,,69,uint64_t dictGetUnsignedIntegerVal (dictEntry*)
119323,METHOD,dict.c:<global>,TYPE_DECL,"double dictGetDoubleVal(const dictEntry *de) {
    assert(entryHasValue(de));
    return de->v.d;
}",1,4,dict.c,dictGetDoubleVal,,false,818,821,dictGetDoubleVal,,,70,double dictGetDoubleVal (dictEntry*)
119351,METHOD,dict.c:<global>,TYPE_DECL,"double *dictGetDoubleValPtr(dictEntry *de) {
    assert(entryHasValue(de));
    return &de->v.d;
}",1,4,dict.c,dictGetDoubleValPtr,,false,824,827,dictGetDoubleValPtr,,,71,double* dictGetDoubleValPtr (dictEntry*)
119380,METHOD,dict.c:<global>,TYPE_DECL,"static dictEntry *dictGetNext(const dictEntry *de) {
    if (entryIsKey(de)) return NULL; /* there's no next */
    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->next;
    return de->next;
}",1,1,dict.c,dictGetNext,,false,831,835,dictGetNext,,,72,dictEntry dictGetNext (dictEntry*)
119404,METHOD,dict.c:<global>,TYPE_DECL,"static dictEntry **dictGetNextRef(dictEntry *de) {
    if (entryIsKey(de)) return NULL;
    if (entryIsNoValue(de)) return &decodeEntryNoValue(de)->next;
    return &de->next;
}",1,1,dict.c,dictGetNextRef,,false,839,843,dictGetNextRef,,,73,dictEntry dictGetNextRef (dictEntry*)
119430,METHOD,dict.c:<global>,TYPE_DECL,"static void dictSetNext(dictEntry *de, dictEntry *next) {
    assert(!entryIsKey(de));
    if (entryIsNoValue(de)) {
        dictEntryNoValue *entry = decodeEntryNoValue(de);
        entry->next = next;
    } else {
        de->next = next;
    }
}",1,4,dict.c,dictSetNext,,false,845,853,dictSetNext,,,74,"void dictSetNext (dictEntry*,dictEntry*)"
119476,METHOD,dict.c:<global>,TYPE_DECL,"size_t dictMemUsage(const dict *d) {
    return dictSize(d) * sizeof(dictEntry) +
        dictSlots(d) * sizeof(dictEntry*);
}",1,11,dict.c,dictMemUsage,,false,857,860,dictMemUsage,,,75,size_t dictMemUsage (dict*)
119545,METHOD,dict.c:<global>,TYPE_DECL,"size_t dictEntryMemUsage(void) {
    return sizeof(dictEntry);
}",1,1,dict.c,dictEntryMemUsage,,false,862,864,dictEntryMemUsage,,,76,size_t dictEntryMemUsage (void)
119553,METHOD,dict.c:<global>,TYPE_DECL,"unsigned long long dictFingerprint(dict *d) {
    unsigned long long integers[6], hash = 0;
    int j;

    integers[0] = (long) d->ht_table[0];
    integers[1] = d->ht_size_exp[0];
    integers[2] = d->ht_used[0];
    integers[3] = (long) d->ht_table[1];
    integers[4] = d->ht_size_exp[1];
    integers[5] = d->ht_used[1];

    /* We hash N integers by summing every successive integer with the integer
     * hashing of the previous sum. Basically:
     *
     * Result = hash(hash(hash(int1)+int2)+int3) ...
     *
     * This way the same set of integers in a different order will (likely) hash
     * to a different number. */
    for (j = 0; j < 6; j++) {
        hash += integers[j];
        /* For the hashing step we use Tomas Wang's 64 bit integer hash. */
        hash = (~hash) + (hash << 21); // hash = (hash << 21) - hash - 1;
        hash = hash ^ (hash >> 24);
        hash = (hash + (hash << 3)) + (hash << 8); // hash * 265
        hash = hash ^ (hash >> 14);
        hash = (h...",1,1,dict.c,dictFingerprint,,false,872,902,dictFingerprint,,,77,unsigned long long dictFingerprint (dict*)
119698,METHOD,dict.c:<global>,TYPE_DECL,"void dictInitIterator(dictIterator *iter, dict *d)
{
    iter->d = d;
    iter->table = 0;
    iter->index = -1;
    iter->safe = 0;
    iter->entry = NULL;
    iter->nextEntry = NULL;
}",1,1,dict.c,dictInitIterator,,false,904,912,dictInitIterator,,,78,"void dictInitIterator (dictIterator*,dict*)"
119735,METHOD,dict.c:<global>,TYPE_DECL,"void dictInitSafeIterator(dictIterator *iter, dict *d)
{
    dictInitIterator(iter, d);
    iter->safe = 1;
}",1,1,dict.c,dictInitSafeIterator,,false,914,918,dictInitSafeIterator,,,79,"void dictInitSafeIterator (dictIterator*,dict*)"
119749,METHOD,dict.c:<global>,TYPE_DECL,"void dictResetIterator(dictIterator *iter)
{
    if (!(iter->index == -1 && iter->table == 0)) {
        if (iter->safe)
            dictResumeRehashing(iter->d);
        else
            assert(iter->fingerprint == dictFingerprint(iter->d));
    }
}",1,12,dict.c,dictResetIterator,,false,920,928,dictResetIterator,,,80,void dictResetIterator (dictIterator*)
119808,METHOD,dict.c:<global>,TYPE_DECL,"dictIterator *dictGetIterator(dict *d)
{
    dictIterator *iter = zmalloc(sizeof(*iter));
    dictInitIterator(iter, d);
    return iter;
}",1,1,dict.c,dictGetIterator,,false,930,935,dictGetIterator,,,81,dictIterator dictGetIterator (dict*)
119825,METHOD,dict.c:<global>,TYPE_DECL,"dictIterator *dictGetSafeIterator(dict *d) {
    dictIterator *i = dictGetIterator(d);

    i->safe = 1;
    return i;
}",1,1,dict.c,dictGetSafeIterator,,false,937,942,dictGetSafeIterator,,,82,dictIterator dictGetSafeIterator (dict*)
119842,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictNext(dictIterator *iter)
{
    while (1) {
        if (iter->entry == NULL) {
            if (iter->index == -1 && iter->table == 0) {
                if (iter->safe)
                    dictPauseRehashing(iter->d);
                else
                    iter->fingerprint = dictFingerprint(iter->d);
            }
            iter->index++;
            if (iter->index >= (long) DICTHT_SIZE(iter->d->ht_size_exp[iter->table])) {
                if (dictIsRehashing(iter->d) && iter->table == 0) {
                    iter->table++;
                    iter->index = 0;
                } else {
                    break;
                }
            }
            iter->entry = iter->d->ht_table[iter->table][iter->index];
        } else {
            iter->entry = iter->nextEntry;
        }
        if (iter->entry) {
            /* We need to save the 'next' here, the iterator user
             * may delete the entry we are returning. */
            iter->nextEntry = dictG...",1,20,dict.c,dictNext,,false,944,975,dictNext,,,83,dictEntry dictNext (dictIterator*)
120025,METHOD,dict.c:<global>,TYPE_DECL,"void dictReleaseIterator(dictIterator *iter)
{
    dictResetIterator(iter);
    zfree(iter);
}",1,1,dict.c,dictReleaseIterator,,false,977,981,dictReleaseIterator,,,84,void dictReleaseIterator (dictIterator*)
120034,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictGetRandomKey(dict *d)
{
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;
    if (dictIsRehashing(d)) _dictRehashStep(d);
    if (dictIsRehashing(d)) {
        unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);
        do {
            /* We are sure there are no elements in indexes from 0
             * to rehashidx-1 */
            h = d->rehashidx + (randomULong() % (dictSlots(d) - d->rehashidx));
            he = (h >= s0) ? d->ht_table[1][h - s0] : d->ht_table[0][h];
        } while(he == NULL);
    } else {
        unsigned long m = DICTHT_SIZE_MASK(d->ht_size_exp[0]);
        do {
            h = randomULong() & m;
            he = d->ht_table[0][h];
        } while(he == NULL);
    }

    /* Now we found a non empty bucket, but it is a linked
     * list and we need to get a random element from the list.
     * The only sane way to do so is counting the elements and
     * select a random index. ...",1,8,dict.c,dictGetRandomKey,,false,985,1023,dictGetRandomKey,,,85,dictEntry dictGetRandomKey (dict*)
120300,METHOD,dict.c:<global>,TYPE_DECL,"unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {
    unsigned long j; /* internal hash table id, 0 or 1. */
    unsigned long tables; /* 1 or 2 tables? */
    unsigned long stored = 0, maxsizemask;
    unsigned long maxsteps;

    if (dictSize(d) < count) count = dictSize(d);
    maxsteps = count*10;

    /* Try to do a rehashing work proportional to 'count'. */
    for (j = 0; j < count; j++) {
        if (dictIsRehashing(d))
            _dictRehashStep(d);
        else
            break;
    }

    tables = dictIsRehashing(d) ? 2 : 1;
    maxsizemask = DICTHT_SIZE_MASK(d->ht_size_exp[0]);
    if (tables > 1 && maxsizemask < DICTHT_SIZE_MASK(d->ht_size_exp[1]))
        maxsizemask = DICTHT_SIZE_MASK(d->ht_size_exp[1]);

    /* Pick a random point inside the larger table. */
    unsigned long i = randomULong() & maxsizemask;
    unsigned long emptylen = 0; /* Continuous empty entries so far. */
    while(stored < count && maxsteps--) {
        for (j = 0;...",1,8,dict.c,dictGetSomeKeys,,false,1047,1125,dictGetSomeKeys,,,86,"unsigned int dictGetSomeKeys (dict*,dictEntry**,unsigned int)"
120747,METHOD,dict.c:<global>,TYPE_DECL,"static void dictDefragBucket(dict *d, dictEntry **bucketref, dictDefragFunctions *defragfns) {
    dictDefragAllocFunction *defragalloc = defragfns->defragAlloc;
    dictDefragAllocFunction *defragkey = defragfns->defragKey;
    dictDefragAllocFunction *defragval = defragfns->defragVal;
    while (bucketref && *bucketref) {
        dictEntry *de = *bucketref, *newde = NULL;
        void *newkey = defragkey ? defragkey(dictGetKey(de)) : NULL;
        void *newval = defragval ? defragval(dictGetVal(de)) : NULL;
        if (entryIsKey(de)) {
            if (newkey) *bucketref = newkey;
            assert(entryIsKey(*bucketref));
        } else if (entryIsNoValue(de)) {
            dictEntryNoValue *entry = decodeEntryNoValue(de), *newentry;
            if ((newentry = defragalloc(entry))) {
                newde = encodeMaskedPtr(newentry, ENTRY_PTR_NO_VALUE);
                entry = newentry;
            }
            if (newkey) entry->key = newkey;
        } else {
            asser...",1,12,dict.c,dictDefragBucket,,false,1130,1162,dictDefragBucket,,,87,"void dictDefragBucket (dict*,dictEntry**,dictDefragFunctions*)"
120945,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictGetFairRandomKey(dict *d) {
    dictEntry *entries[GETFAIR_NUM_ENTRIES];
    unsigned int count = dictGetSomeKeys(d,entries,GETFAIR_NUM_ENTRIES);
    /* Note that dictGetSomeKeys() may return zero elements in an unlucky
     * run() even if there are actually elements inside the hash table. So
     * when we get zero, we call the true dictGetRandomKey() that will always
     * yield the element if the hash table has at least one. */
    if (count == 0) return dictGetRandomKey(d);
    unsigned int idx = rand() % count;
    return entries[idx];
}",1,23,dict.c,dictGetFairRandomKey,,false,1176,1186,dictGetFairRandomKey,,,88,dictEntry dictGetFairRandomKey (dict*)
120978,METHOD,dict.c:<global>,TYPE_DECL,"static unsigned long rev(unsigned long v) {
    unsigned long s = CHAR_BIT * sizeof(v); // bit size; must be power of 2
    unsigned long mask = ~0UL;
    while ((s >>= 1) > 0) {
        mask ^= (mask << s);
        v = ((v >> s) & mask) | ((v << s) & ~mask);
    }
    return v;
}",1,1,dict.c,rev,,false,1190,1198,rev,,,89,unsigned long rev (long unsigned)
121023,METHOD,dict.c:<global>,TYPE_DECL,"unsigned long dictScan(dict *d,
                       unsigned long v,
                       dictScanFunction *fn,
                       void *privdata)
{
    return dictScanDefrag(d, v, fn, NULL, privdata);
}",1,1,dict.c,dictScan,,false,1284,1290,dictScan,,,90,"unsigned long dictScan (dict*,long unsigned,dictScanFunction*,void*)"
121038,METHOD,dict.c:<global>,TYPE_DECL,"unsigned long dictScanDefrag(dict *d,
                             unsigned long v,
                             dictScanFunction *fn,
                             dictDefragFunctions *defragfns,
                             void *privdata)
{
    int htidx0, htidx1;
    const dictEntry *de, *next;
    unsigned long m0, m1;

    if (dictSize(d) == 0) return 0;

    /* This is needed in case the scan callback tries to do dictFind or alike. */
    dictPauseRehashing(d);

    if (!dictIsRehashing(d)) {
        htidx0 = 0;
        m0 = DICTHT_SIZE_MASK(d->ht_size_exp[htidx0]);

        /* Emit entries at cursor */
        if (defragfns) {
            dictDefragBucket(d, &d->ht_table[htidx0][v & m0], defragfns);
        }
        de = d->ht_table[htidx0][v & m0];
        while (de) {
            next = dictGetNext(de);
            fn(privdata, de);
            de = next;
        }

        /* Set unmasked bits so incrementing the reversed cursor
         * operates on the masked bits */
 ...",1,8,dict.c,dictScanDefrag,,false,1300,1390,dictScanDefrag,,,91,"unsigned long dictScanDefrag (dict*,long unsigned,dictScanFunction*,dictDefragFunctions*,void*)"
121448,METHOD,dict.c:<global>,TYPE_DECL,"static int dictTypeExpandAllowed(dict *d) {
    if (d->type->expandAllowed == NULL) return 1;
    return d->type->expandAllowed(
                    DICTHT_SIZE(_dictNextExp(d->ht_used[0] + 1)) * sizeof(dictEntry*),
                    (double)d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]));
}",1,20,dict.c,dictTypeExpandAllowed,,false,1397,1402,dictTypeExpandAllowed,,,92,int dictTypeExpandAllowed (dict*)
121535,METHOD,dict.c:<global>,TYPE_DECL,"static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK;

    /* If the hash table is empty expand it to the initial size. */
    if (DICTHT_SIZE(d->ht_size_exp[0]) == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the ""safe"" threshold, we resize doubling
     * the number of buckets. */
    if (!dictTypeExpandAllowed(d))
        return DICT_OK;
    if ((dict_can_resize == DICT_RESIZE_ENABLE &&
         d->ht_used[0] >= DICTHT_SIZE(d->ht_size_exp[0])) ||
        (dict_can_resize != DICT_RESIZE_FORBID &&
         d->ht_used[0] / DICTHT_SIZE(d->ht_size_exp[0]) > dict_force_resize_ratio))
    {
        return dictExpand(d, d->ht_used[0] + 1);
    }
    return DICT_OK;
}",1,8,dict.c,_dictExpandIfNeeded,,false,1405,1427,_dictExpandIfNeeded,,,93,int _dictExpandIfNeeded (dict*)
121693,METHOD,dict.c:<global>,TYPE_DECL,"static signed char _dictNextExp(unsigned long size)
{
    unsigned char e = DICT_HT_INITIAL_EXP;

    if (size >= LONG_MAX) return (8*sizeof(long)-1);
    while(1) {
        if (((unsigned long)1<<e) >= size)
            return e;
        e++;
    }
}",1,22,dict.c,_dictNextExp,,false,1431,1441,_dictNextExp,,,94,signed char _dictNextExp (long unsigned)
121732,METHOD,dict.c:<global>,TYPE_DECL,"void *dictFindPositionForInsert(dict *d, const void *key, dictEntry **existing) {
    unsigned long idx, table;
    dictEntry *he;
    uint64_t hash = dictHashKey(d, key);
    if (existing) *existing = NULL;
    if (dictIsRehashing(d)) _dictRehashStep(d);

    /* Expand the hash table if needed */
    if (_dictExpandIfNeeded(d) == DICT_ERR)
        return NULL;
    for (table = 0; table <= 1; table++) {
        idx = hash & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        /* Search if this slot does not already contain the given key */
        he = d->ht_table[table][idx];
        while(he) {
            void *he_key = dictGetKey(he);
            if (key == he_key || dictCompareKeys(d, key, he_key)) {
                if (existing) *existing = he;
                return NULL;
            }
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) break;
    }

    /* If we are in the process of rehashing the hash table, the bucket is
     * always returned in the c...",1,20,dict.c,dictFindPositionForInsert,,false,1447,1476,dictFindPositionForInsert,,,95,"void* dictFindPositionForInsert (dict*,void*,dictEntry**)"
121935,METHOD,dict.c:<global>,TYPE_DECL,"void dictEmpty(dict *d, void(callback)(dict*)) {
    _dictClear(d,0,callback);
    _dictClear(d,1,callback);
    d->rehashidx = -1;
    d->pauserehash = 0;
}",1,1,dict.c,dictEmpty,,false,1478,1483,dictEmpty,,,96,"void dictEmpty (dict*,void)"
121960,METHOD,dict.c:<global>,TYPE_DECL,"void dictSetResizeEnabled(dictResizeEnable enable) {
    dict_can_resize = enable;
}",1,1,dict.c,dictSetResizeEnabled,,false,1485,1487,dictSetResizeEnabled,,,97,void dictSetResizeEnabled (dictResizeEnable)
121968,METHOD,dict.c:<global>,TYPE_DECL,"uint64_t dictGetHash(dict *d, const void *key) {
    return dictHashKey(d, key);
}",1,11,dict.c,dictGetHash,,false,1489,1491,dictGetHash,,,98,"uint64_t dictGetHash (dict*,void*)"
121986,METHOD,dict.c:<global>,TYPE_DECL,"dictEntry *dictFindEntryByPtrAndHash(dict *d, const void *oldptr, uint64_t hash) {
    dictEntry *he;
    unsigned long idx, table;

    if (dictSize(d) == 0) return NULL; /* dict is empty */
    for (table = 0; table <= 1; table++) {
        idx = hash & DICTHT_SIZE_MASK(d->ht_size_exp[table]);
        he = d->ht_table[table][idx];
        while(he) {
            if (oldptr == dictGetKey(he))
                return he;
            he = dictGetNext(he);
        }
        if (!dictIsRehashing(d)) return NULL;
    }
    return NULL;
}",1,8,dict.c,dictFindEntryByPtrAndHash,,false,1498,1514,dictFindEntryByPtrAndHash,,,99,"dictEntry dictFindEntryByPtrAndHash (dict*,void*,uint64_t)"
122109,METHOD,dict.c:<global>,TYPE_DECL,"size_t _dictGetStatsHt(char *buf, size_t bufsize, dict *d, int htidx, int full) {
    unsigned long i, slots = 0, chainlen, maxchainlen = 0;
    unsigned long totchainlen = 0;
    unsigned long clvector[DICT_STATS_VECTLEN];
    size_t l = 0;

    if (d->ht_used[htidx] == 0) {
        return snprintf(buf,bufsize,
            ""Hash table %d stats (%s):\n""
            ""No stats available for empty dictionaries\n"",
            htidx, (htidx == 0) ? ""main hash table"" : ""rehashing target"");
    }

    if (!full) {
        l += snprintf(buf+l,bufsize-l,
            ""Hash table %d stats (%s):\n""
            "" table size: %lu\n""
            "" number of elements: %lu\n"",
            htidx, (htidx == 0) ? ""main hash table"" : ""rehashing target"",
            DICTHT_SIZE(d->ht_size_exp[htidx]), d->ht_used[htidx]);

        /* Make sure there is a NULL term at the end. */
        buf[bufsize-1] = '\0';
        /* Unlike snprintf(), return the number of characters actually written. */
        retur...",1,27,dict.c,_dictGetStatsHt,,false,1519,1594,_dictGetStatsHt,,,100,"size_t _dictGetStatsHt (char*,size_t,dict*,int,int)"
122490,METHOD,dict.c:<global>,TYPE_DECL,"void dictGetStats(char *buf, size_t bufsize, dict *d, int full) {
    size_t l;
    char *orig_buf = buf;
    size_t orig_bufsize = bufsize;

    l = _dictGetStatsHt(buf,bufsize,d,0,full);
    if (dictIsRehashing(d) && bufsize > l) {
        buf += l;
        bufsize -= l;
        _dictGetStatsHt(buf,bufsize,d,1,full);
    }
    /* Make sure there is a NULL term at the end. */
    orig_buf[orig_bufsize-1] = '\0';
}",1,8,dict.c,dictGetStats,,false,1596,1609,dictGetStats,,,101,"void dictGetStats (char*,size_t,dict*,int)"
122560,METHOD,dict.h:<global>,TYPE_DECL,<global>,1,1,dict.h,dict.h:<global>,,false,1,231,<global>,,,1,
122567,METHOD,dictType,TYPE_DECL,uint64_t (*hashFunction)(const void *key);,14,45,dict.h,dictType.hashFunction,,false,52,52,hashFunction,,,1,uint64_t dictType.hashFunction (void*)
122572,METHOD,dictType,TYPE_DECL,"void *(*keyDup)(dict *d, const void *key);",10,45,dict.h,dictType.keyDup,,false,53,53,keyDup,,,2,"void* dictType.keyDup (dict*,void*)"
122578,METHOD,dictType,TYPE_DECL,"void *(*valDup)(dict *d, const void *obj);",10,45,dict.h,dictType.valDup,,false,54,54,valDup,,,3,"void* dictType.valDup (dict*,void*)"
122584,METHOD,dictType,TYPE_DECL,"int (*keyCompare)(dict *d, const void *key1, const void *key2);",9,66,dict.h,dictType.keyCompare,,false,55,55,keyCompare,,,4,"int dictType.keyCompare (dict*,void*,void*)"
122591,METHOD,dictType,TYPE_DECL,"void (*keyDestructor)(dict *d, void *key);",10,45,dict.h,dictType.keyDestructor,,false,56,56,keyDestructor,,,5,"void dictType.keyDestructor (dict*,void*)"
122597,METHOD,dictType,TYPE_DECL,"void (*valDestructor)(dict *d, void *obj);",10,45,dict.h,dictType.valDestructor,,false,57,57,valDestructor,,,6,"void dictType.valDestructor (dict*,void*)"
122603,METHOD,dictType,TYPE_DECL,"int (*expandAllowed)(size_t moreMem, double usedRatio);",9,58,dict.h,dictType.expandAllowed,,false,58,58,expandAllowed,,,7,"int dictType.expandAllowed (size_t,double)"
122611,METHOD,dictType,TYPE_DECL,size_t (*dictEntryMetadataBytes)(dict *d);,12,45,dict.h,dictType.dictEntryMetadataBytes,,false,74,74,dictEntryMetadataBytes,,,10,size_t dictType.dictEntryMetadataBytes (dict*)
122616,METHOD,dictType,TYPE_DECL,size_t (*dictMetadataBytes)(void);,12,37,dict.h,dictType.dictMetadataBytes,,false,75,75,dictMetadataBytes,,,11,size_t dictType.dictMetadataBytes (void)
122621,METHOD,dictType,TYPE_DECL,"void (*afterReplaceEntry)(dict *d, dictEntry *entry);",10,56,dict.h,dictType.afterReplaceEntry,,false,78,78,afterReplaceEntry,,,12,"void dictType.afterReplaceEntry (dict*,dictEntry*)"
122636,METHOD,<empty>,<empty>,<empty>,1,,dict.h,dict:<clinit>,,false,84,,<clinit>,,,8,
122656,METHOD,dict.h:<global>,TYPE_DECL,"typedef void (dictScanFunction)(void *privdata, const dictEntry *de);",14,68,dict.h,dictScanFunction,,false,114,114,dictScanFunction,,,10,"void dictScanFunction (void*,dictEntry*)"
122662,METHOD,dict.h:<global>,TYPE_DECL,typedef void *(dictDefragAllocFunction)(void *ptr);,14,50,dict.h,dictDefragAllocFunction,,false,115,115,dictDefragAllocFunction,,,11,void* dictDefragAllocFunction (void*)
122677,METHOD,dict.h:<global>,TYPE_DECL,dict *dictCreate(dictType *type);,6,32,dict.h,dictCreate,,false,167,167,dictCreate,,,16,dict* dictCreate (dictType*)
122682,METHOD,dict.h:<global>,TYPE_DECL,"int dictExpand(dict *d, unsigned long size);",5,43,dict.h,dictExpand,,false,168,168,dictExpand,,,17,"int dictExpand (dict*,long unsigned)"
122688,METHOD,dict.h:<global>,TYPE_DECL,"int dictTryExpand(dict *d, unsigned long size);",5,46,dict.h,dictTryExpand,,false,169,169,dictTryExpand,,,18,"int dictTryExpand (dict*,long unsigned)"
122694,METHOD,dict.h:<global>,TYPE_DECL,void *dictMetadata(dict *d);,6,27,dict.h,dictMetadata,,false,170,170,dictMetadata,,,19,void* dictMetadata (dict*)
122699,METHOD,dict.h:<global>,TYPE_DECL,"int dictAdd(dict *d, void *key, void *val);",5,42,dict.h,dictAdd,,false,171,171,dictAdd,,,20,"int dictAdd (dict*,void*,void*)"
122706,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing);",11,63,dict.h,dictAddRaw,,false,172,172,dictAddRaw,,,21,"dictEntry* dictAddRaw (dict*,void*,dictEntry**)"
122713,METHOD,dict.h:<global>,TYPE_DECL,"void *dictFindPositionForInsert(dict *d, const void *key, dictEntry **existing);",6,79,dict.h,dictFindPositionForInsert,,false,173,173,dictFindPositionForInsert,,,22,"void* dictFindPositionForInsert (dict*,void*,dictEntry**)"
122720,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry *dictInsertAtPosition(dict *d, void *key, void *position);",11,67,dict.h,dictInsertAtPosition,,false,174,174,dictInsertAtPosition,,,23,"dictEntry* dictInsertAtPosition (dict*,void*,void*)"
122727,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry *dictAddOrFind(dict *d, void *key);",11,44,dict.h,dictAddOrFind,,false,175,175,dictAddOrFind,,,24,"dictEntry* dictAddOrFind (dict*,void*)"
122733,METHOD,dict.h:<global>,TYPE_DECL,"int dictReplace(dict *d, void *key, void *val);",5,46,dict.h,dictReplace,,false,176,176,dictReplace,,,25,"int dictReplace (dict*,void*,void*)"
122740,METHOD,dict.h:<global>,TYPE_DECL,"int dictDelete(dict *d, const void *key);",5,40,dict.h,dictDelete,,false,177,177,dictDelete,,,26,"int dictDelete (dict*,void*)"
122746,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry *dictUnlink(dict *d, const void *key);",11,47,dict.h,dictUnlink,,false,178,178,dictUnlink,,,27,"dictEntry* dictUnlink (dict*,void*)"
122752,METHOD,dict.h:<global>,TYPE_DECL,"void dictFreeUnlinkedEntry(dict *d, dictEntry *he);",6,50,dict.h,dictFreeUnlinkedEntry,,false,179,179,dictFreeUnlinkedEntry,,,28,"void dictFreeUnlinkedEntry (dict*,dictEntry*)"
122758,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry *dictTwoPhaseUnlinkFind(dict *d, const void *key, dictEntry ***plink, int *table_index);",11,97,dict.h,dictTwoPhaseUnlinkFind,,false,180,180,dictTwoPhaseUnlinkFind,,,29,"dictEntry* dictTwoPhaseUnlinkFind (dict*,void*,dictEntry***,int*)"
122766,METHOD,dict.h:<global>,TYPE_DECL,"void dictTwoPhaseUnlinkFree(dict *d, dictEntry *he, dictEntry **plink, int table_index);",6,87,dict.h,dictTwoPhaseUnlinkFree,,false,181,181,dictTwoPhaseUnlinkFree,,,30,"void dictTwoPhaseUnlinkFree (dict*,dictEntry*,dictEntry**,int)"
122774,METHOD,dict.h:<global>,TYPE_DECL,void dictRelease(dict *d);,6,25,dict.h,dictRelease,,false,182,182,dictRelease,,,31,void dictRelease (dict*)
122779,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry * dictFind(dict *d, const void *key);",11,46,dict.h,dictFind,,false,183,183,dictFind,,,32,"dictEntry* dictFind (dict*,void*)"
122785,METHOD,dict.h:<global>,TYPE_DECL,"void *dictFetchValue(dict *d, const void *key);",6,46,dict.h,dictFetchValue,,false,184,184,dictFetchValue,,,33,"void* dictFetchValue (dict*,void*)"
122791,METHOD,dict.h:<global>,TYPE_DECL,int dictResize(dict *d);,5,23,dict.h,dictResize,,false,185,185,dictResize,,,34,int dictResize (dict*)
122796,METHOD,dict.h:<global>,TYPE_DECL,"void dictSetKey(dict *d, dictEntry* de, void *key);",6,50,dict.h,dictSetKey,,false,186,186,dictSetKey,,,35,"void dictSetKey (dict*,dictEntry*,void*)"
122803,METHOD,dict.h:<global>,TYPE_DECL,"void dictSetVal(dict *d, dictEntry *de, void *val);",6,50,dict.h,dictSetVal,,false,187,187,dictSetVal,,,36,"void dictSetVal (dict*,dictEntry*,void*)"
122810,METHOD,dict.h:<global>,TYPE_DECL,"void dictSetSignedIntegerVal(dictEntry *de, int64_t val);",6,56,dict.h,dictSetSignedIntegerVal,,false,188,188,dictSetSignedIntegerVal,,,37,"void dictSetSignedIntegerVal (dictEntry*,int64_t)"
122816,METHOD,dict.h:<global>,TYPE_DECL,"void dictSetUnsignedIntegerVal(dictEntry *de, uint64_t val);",6,59,dict.h,dictSetUnsignedIntegerVal,,false,189,189,dictSetUnsignedIntegerVal,,,38,"void dictSetUnsignedIntegerVal (dictEntry*,uint64_t)"
122822,METHOD,dict.h:<global>,TYPE_DECL,"void dictSetDoubleVal(dictEntry *de, double val);",6,48,dict.h,dictSetDoubleVal,,false,190,190,dictSetDoubleVal,,,39,"void dictSetDoubleVal (dictEntry*,double)"
122828,METHOD,dict.h:<global>,TYPE_DECL,"int64_t dictIncrSignedIntegerVal(dictEntry *de, int64_t val);",9,60,dict.h,dictIncrSignedIntegerVal,,false,191,191,dictIncrSignedIntegerVal,,,40,"int64_t dictIncrSignedIntegerVal (dictEntry*,int64_t)"
122834,METHOD,dict.h:<global>,TYPE_DECL,"uint64_t dictIncrUnsignedIntegerVal(dictEntry *de, uint64_t val);",10,64,dict.h,dictIncrUnsignedIntegerVal,,false,192,192,dictIncrUnsignedIntegerVal,,,41,"uint64_t dictIncrUnsignedIntegerVal (dictEntry*,uint64_t)"
122840,METHOD,dict.h:<global>,TYPE_DECL,"double dictIncrDoubleVal(dictEntry *de, double val);",8,51,dict.h,dictIncrDoubleVal,,false,193,193,dictIncrDoubleVal,,,42,"double dictIncrDoubleVal (dictEntry*,double)"
122846,METHOD,dict.h:<global>,TYPE_DECL,void *dictEntryMetadata(dictEntry *de);,6,38,dict.h,dictEntryMetadata,,false,194,194,dictEntryMetadata,,,43,void* dictEntryMetadata (dictEntry*)
122851,METHOD,dict.h:<global>,TYPE_DECL,void *dictGetKey(const dictEntry *de);,6,37,dict.h,dictGetKey,,false,195,195,dictGetKey,,,44,void* dictGetKey (dictEntry*)
122856,METHOD,dict.h:<global>,TYPE_DECL,void *dictGetVal(const dictEntry *de);,6,37,dict.h,dictGetVal,,false,196,196,dictGetVal,,,45,void* dictGetVal (dictEntry*)
122861,METHOD,dict.h:<global>,TYPE_DECL,int64_t dictGetSignedIntegerVal(const dictEntry *de);,9,52,dict.h,dictGetSignedIntegerVal,,false,197,197,dictGetSignedIntegerVal,,,46,int64_t dictGetSignedIntegerVal (dictEntry*)
122866,METHOD,dict.h:<global>,TYPE_DECL,uint64_t dictGetUnsignedIntegerVal(const dictEntry *de);,10,55,dict.h,dictGetUnsignedIntegerVal,,false,198,198,dictGetUnsignedIntegerVal,,,47,uint64_t dictGetUnsignedIntegerVal (dictEntry*)
122871,METHOD,dict.h:<global>,TYPE_DECL,double dictGetDoubleVal(const dictEntry *de);,8,44,dict.h,dictGetDoubleVal,,false,199,199,dictGetDoubleVal,,,48,double dictGetDoubleVal (dictEntry*)
122876,METHOD,dict.h:<global>,TYPE_DECL,double *dictGetDoubleValPtr(dictEntry *de);,8,42,dict.h,dictGetDoubleValPtr,,false,200,200,dictGetDoubleValPtr,,,49,double* dictGetDoubleValPtr (dictEntry*)
122881,METHOD,dict.h:<global>,TYPE_DECL,size_t dictMemUsage(const dict *d);,8,34,dict.h,dictMemUsage,,false,201,201,dictMemUsage,,,50,size_t dictMemUsage (dict*)
122886,METHOD,dict.h:<global>,TYPE_DECL,size_t dictEntryMemUsage(void);,8,30,dict.h,dictEntryMemUsage,,false,202,202,dictEntryMemUsage,,,51,size_t dictEntryMemUsage (void)
122891,METHOD,dict.h:<global>,TYPE_DECL,dictIterator *dictGetIterator(dict *d);,14,38,dict.h,dictGetIterator,,false,203,203,dictGetIterator,,,52,dictIterator* dictGetIterator (dict*)
122896,METHOD,dict.h:<global>,TYPE_DECL,dictIterator *dictGetSafeIterator(dict *d);,14,42,dict.h,dictGetSafeIterator,,false,204,204,dictGetSafeIterator,,,53,dictIterator* dictGetSafeIterator (dict*)
122901,METHOD,dict.h:<global>,TYPE_DECL,"void dictInitIterator(dictIterator *iter, dict *d);",6,50,dict.h,dictInitIterator,,false,205,205,dictInitIterator,,,54,"void dictInitIterator (dictIterator*,dict*)"
122907,METHOD,dict.h:<global>,TYPE_DECL,"void dictInitSafeIterator(dictIterator *iter, dict *d);",6,54,dict.h,dictInitSafeIterator,,false,206,206,dictInitSafeIterator,,,55,"void dictInitSafeIterator (dictIterator*,dict*)"
122913,METHOD,dict.h:<global>,TYPE_DECL,void dictResetIterator(dictIterator *iter);,6,42,dict.h,dictResetIterator,,false,207,207,dictResetIterator,,,56,void dictResetIterator (dictIterator*)
122918,METHOD,dict.h:<global>,TYPE_DECL,dictEntry *dictNext(dictIterator *iter);,11,39,dict.h,dictNext,,false,208,208,dictNext,,,57,dictEntry* dictNext (dictIterator*)
122923,METHOD,dict.h:<global>,TYPE_DECL,void dictReleaseIterator(dictIterator *iter);,6,44,dict.h,dictReleaseIterator,,false,209,209,dictReleaseIterator,,,58,void dictReleaseIterator (dictIterator*)
122928,METHOD,dict.h:<global>,TYPE_DECL,dictEntry *dictGetRandomKey(dict *d);,11,36,dict.h,dictGetRandomKey,,false,210,210,dictGetRandomKey,,,59,dictEntry* dictGetRandomKey (dict*)
122933,METHOD,dict.h:<global>,TYPE_DECL,dictEntry *dictGetFairRandomKey(dict *d);,11,40,dict.h,dictGetFairRandomKey,,false,211,211,dictGetFairRandomKey,,,60,dictEntry* dictGetFairRandomKey (dict*)
122938,METHOD,dict.h:<global>,TYPE_DECL,"unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);",14,74,dict.h,dictGetSomeKeys,,false,212,212,dictGetSomeKeys,,,61,"unsigned int dictGetSomeKeys (dict*,dictEntry**,unsigned int)"
122945,METHOD,dict.h:<global>,TYPE_DECL,"void dictGetStats(char *buf, size_t bufsize, dict *d, int full);",6,63,dict.h,dictGetStats,,false,213,213,dictGetStats,,,62,"void dictGetStats (char*,size_t,dict*,int)"
122953,METHOD,dict.h:<global>,TYPE_DECL,"uint64_t dictGenHashFunction(const void *key, size_t len);",10,57,dict.h,dictGenHashFunction,,false,214,214,dictGenHashFunction,,,63,"uint64_t dictGenHashFunction (void*,size_t)"
122959,METHOD,dict.h:<global>,TYPE_DECL,"uint64_t dictGenCaseHashFunction(const unsigned char *buf, size_t len);",10,70,dict.h,dictGenCaseHashFunction,,false,215,215,dictGenCaseHashFunction,,,64,"uint64_t dictGenCaseHashFunction (unsigned char*,size_t)"
122965,METHOD,dict.h:<global>,TYPE_DECL,"void dictEmpty(dict *d, void(callback)(dict*));",6,46,dict.h,dictEmpty,,false,216,216,dictEmpty,,,65,"void dictEmpty (dict*,void)"
122971,METHOD,dict.h:<global>,TYPE_DECL,void dictSetResizeEnabled(dictResizeEnable enable);,6,50,dict.h,dictSetResizeEnabled,,false,217,217,dictSetResizeEnabled,,,66,void dictSetResizeEnabled (dictResizeEnable)
122976,METHOD,dict.h:<global>,TYPE_DECL,"int dictRehash(dict *d, int n);",5,30,dict.h,dictRehash,,false,218,218,dictRehash,,,67,"int dictRehash (dict*,int)"
122982,METHOD,dict.h:<global>,TYPE_DECL,"int dictRehashMilliseconds(dict *d, int ms);",5,43,dict.h,dictRehashMilliseconds,,false,219,219,dictRehashMilliseconds,,,68,"int dictRehashMilliseconds (dict*,int)"
122988,METHOD,dict.h:<global>,TYPE_DECL,void dictSetHashFunctionSeed(uint8_t *seed);,6,43,dict.h,dictSetHashFunctionSeed,,false,220,220,dictSetHashFunctionSeed,,,69,void dictSetHashFunctionSeed (uint8_t*)
122993,METHOD,dict.h:<global>,TYPE_DECL,uint8_t *dictGetHashFunctionSeed(void);,9,38,dict.h,dictGetHashFunctionSeed,,false,221,221,dictGetHashFunctionSeed,,,70,uint8_t* dictGetHashFunctionSeed (void)
122998,METHOD,dict.h:<global>,TYPE_DECL,"unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);",15,86,dict.h,dictScan,,false,222,222,dictScan,,,71,"long unsigned dictScan (dict*,long unsigned,dictScanFunction*,void*)"
123006,METHOD,dict.h:<global>,TYPE_DECL,"unsigned long dictScanDefrag(dict *d, unsigned long v, dictScanFunction *fn, dictDefragFunctions *defragfns, void *privdata);",15,124,dict.h,dictScanDefrag,,false,223,223,dictScanDefrag,,,72,"long unsigned dictScanDefrag (dict*,long unsigned,dictScanFunction*,dictDefragFunctions*,void*)"
123015,METHOD,dict.h:<global>,TYPE_DECL,"uint64_t dictGetHash(dict *d, const void *key);",10,46,dict.h,dictGetHash,,false,224,224,dictGetHash,,,73,"uint64_t dictGetHash (dict*,void*)"
123021,METHOD,dict.h:<global>,TYPE_DECL,"dictEntry *dictFindEntryByPtrAndHash(dict *d, const void *oldptr, uint64_t hash);",11,80,dict.h,dictFindEntryByPtrAndHash,,false,225,225,dictFindEntryByPtrAndHash,,,74,"dictEntry* dictFindEntryByPtrAndHash (dict*,void*,uint64_t)"
123035,METHOD,endianconv.c:<global>,TYPE_DECL,<global>,1,6,endianconv.c,endianconv.c:<global>,,false,1,129,<global>,,,1,
123037,METHOD,endianconv.c:<global>,TYPE_DECL,"void memrev16(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[1];
    x[1] = t;
}",1,1,endianconv.c,memrev16,,false,49,55,memrev16,,,1,void memrev16 (void*)
123064,METHOD,endianconv.c:<global>,TYPE_DECL,"void memrev32(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[3];
    x[3] = t;
    t = x[1];
    x[1] = x[2];
    x[2] = t;
}",1,1,endianconv.c,memrev32,,false,59,68,memrev32,,,2,void memrev32 (void*)
123108,METHOD,endianconv.c:<global>,TYPE_DECL,"void memrev64(void *p) {
    unsigned char *x = p, t;

    t = x[0];
    x[0] = x[7];
    x[7] = t;
    t = x[1];
    x[1] = x[6];
    x[6] = t;
    t = x[2];
    x[2] = x[5];
    x[5] = t;
    t = x[3];
    x[3] = x[4];
    x[4] = t;
}",1,1,endianconv.c,memrev64,,false,72,87,memrev64,,,3,void memrev64 (void*)
123186,METHOD,endianconv.c:<global>,TYPE_DECL,"uint16_t intrev16(uint16_t v) {
    memrev16(&v);
    return v;
}",1,1,endianconv.c,intrev16,,false,89,92,intrev16,,,4,uint16_t intrev16 (uint16_t)
123196,METHOD,endianconv.c:<global>,TYPE_DECL,"uint32_t intrev32(uint32_t v) {
    memrev32(&v);
    return v;
}",1,1,endianconv.c,intrev32,,false,94,97,intrev32,,,5,uint32_t intrev32 (uint32_t)
123206,METHOD,endianconv.c:<global>,TYPE_DECL,"uint64_t intrev64(uint64_t v) {
    memrev64(&v);
    return v;
}",1,1,endianconv.c,intrev64,,false,99,102,intrev64,,,6,uint64_t intrev64 (uint64_t)
123223,METHOD,endianconv.h:<global>,TYPE_DECL,<global>,1,1,endianconv.h,endianconv.h:<global>,,false,1,78,<global>,,,1,
123225,METHOD,endianconv.h:<global>,TYPE_DECL,void memrev16(void *p);,6,22,endianconv.h,memrev16,,false,39,39,memrev16,,,1,void memrev16 (void*)
123230,METHOD,endianconv.h:<global>,TYPE_DECL,void memrev32(void *p);,6,22,endianconv.h,memrev32,,false,40,40,memrev32,,,2,void memrev32 (void*)
123235,METHOD,endianconv.h:<global>,TYPE_DECL,void memrev64(void *p);,6,22,endianconv.h,memrev64,,false,41,41,memrev64,,,3,void memrev64 (void*)
123240,METHOD,endianconv.h:<global>,TYPE_DECL,uint16_t intrev16(uint16_t v);,10,29,endianconv.h,intrev16,,false,42,42,intrev16,,,4,uint16_t intrev16 (uint16_t)
123245,METHOD,endianconv.h:<global>,TYPE_DECL,uint32_t intrev32(uint32_t v);,10,29,endianconv.h,intrev32,,false,43,43,intrev32,,,5,uint32_t intrev32 (uint32_t)
123250,METHOD,endianconv.h:<global>,TYPE_DECL,uint64_t intrev64(uint64_t v);,10,29,endianconv.h,intrev64,,false,44,44,intrev64,,,6,uint64_t intrev64 (uint64_t)
123282,METHOD,eval.c:<global>,TYPE_DECL,<global>,1,1,eval.c,eval.c:<global>,,false,1,1667,<global>,,,1,
123284,METHOD,eval.c:<global>,TYPE_DECL,void ldbInit(void);,6,18,eval.c,ldbInit,,false,44,44,ldbInit,,,1,void ldbInit (void)
123289,METHOD,eval.c:<global>,TYPE_DECL,void ldbDisable(client *c);,6,26,eval.c,ldbDisable,,false,45,45,ldbDisable,,,2,void ldbDisable (client*)
123294,METHOD,eval.c:<global>,TYPE_DECL,void ldbEnable(client *c);,6,25,eval.c,ldbEnable,,false,46,46,ldbEnable,,,3,void ldbEnable (client*)
123299,METHOD,eval.c:<global>,TYPE_DECL,"void evalGenericCommandWithDebugging(client *c, int evalsha);",6,60,eval.c,evalGenericCommandWithDebugging,,false,47,47,evalGenericCommandWithDebugging,,,4,"void evalGenericCommandWithDebugging (client*,int)"
123305,METHOD,eval.c:<global>,TYPE_DECL,"sds ldbCatStackValue(sds s, lua_State *lua, int idx);",5,52,eval.c,ldbCatStackValue,,false,48,48,ldbCatStackValue,,,5,"sds ldbCatStackValue (sds,lua_State*,int)"
123312,METHOD,eval.c:<global>,TYPE_DECL,"static void dictLuaScriptDestructor(dict *d, void *val) {
    UNUSED(d);
    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
    decrRefCount(((luaScript*)val)->body);
    zfree(val);
}",1,4,eval.c,dictLuaScriptDestructor,,false,50,55,dictLuaScriptDestructor,,,6,"void dictLuaScriptDestructor (dict*,void*)"
123338,METHOD,eval.c:<global>,TYPE_DECL,"static uint64_t dictStrCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, strlen((char*)key));
}",1,1,eval.c,dictStrCaseHash,,false,57,59,dictStrCaseHash,,,7,uint64_t dictStrCaseHash (void*)
123386,METHOD,<empty>,<empty>,<empty>,1,,eval.c,ldbState:<clinit>,,false,83,,<clinit>,,,17,
123395,METHOD,eval.c:<global>,TYPE_DECL,"void sha1hex(char *digest, char *script, size_t len) {
    SHA1_CTX ctx;
    unsigned char hash[20];
    char *cset = ""0123456789abcdef"";
    int j;

    SHA1Init(&ctx);
    SHA1Update(&ctx,(unsigned char*)script,len);
    SHA1Final(hash,&ctx);

    for (j = 0; j < 20; j++) {
        digest[j*2] = cset[((hash[j]&0xF0)>>4)];
        digest[j*2+1] = cset[(hash[j]&0xF)];
    }
    digest[40] = '\0';
}",1,1,eval.c,sha1hex,,false,112,127,sha1hex,,,14,"void sha1hex (char*,char*,size_t)"
123469,METHOD,eval.c:<global>,TYPE_DECL,"int luaRedisBreakpointCommand(lua_State *lua) {
    if (ldb.active) {
        ldb.luabp = 1;
        lua_pushboolean(lua,1);
    } else {
        lua_pushboolean(lua,0);
    }
    return 1;
}",1,1,eval.c,luaRedisBreakpointCommand,,false,134,142,luaRedisBreakpointCommand,,,15,int luaRedisBreakpointCommand (lua_State*)
123494,METHOD,eval.c:<global>,TYPE_DECL,"int luaRedisDebugCommand(lua_State *lua) {
    if (!ldb.active) return 0;
    int argc = lua_gettop(lua);
    sds log = sdscatprintf(sdsempty(),""<debug> line %d: "", ldb.currentline);
    while(argc--) {
        log = ldbCatStackValue(log,lua,-1 - argc);
        if (argc != 0) log = sdscatlen(log,"", "",2);
    }
    ldbLog(log);
    return 0;
}",1,1,eval.c,luaRedisDebugCommand,,false,149,159,luaRedisDebugCommand,,,16,int luaRedisDebugCommand (lua_State*)
123549,METHOD,eval.c:<global>,TYPE_DECL,"int luaRedisReplicateCommandsCommand(lua_State *lua) {
    lua_pushboolean(lua,1);
    return 1;
}",1,1,eval.c,luaRedisReplicateCommandsCommand,,false,168,171,luaRedisReplicateCommandsCommand,,,17,int luaRedisReplicateCommandsCommand (lua_State*)
123559,METHOD,eval.c:<global>,TYPE_DECL,"void scriptingInit(int setup) {
    lua_State *lua = lua_open();

    if (setup) {
        lctx.lua_client = NULL;
        server.script_disable_deny_script = 0;
        ldbInit();
    }

    /* Initialize a dictionary we use to map SHAs to scripts.
     * This is useful for replication, as we need to replicate EVALSHA
     * as EVAL, so we need to remember the associated script. */
    lctx.lua_scripts = dictCreate(&shaScriptObjectDictType);
    lctx.lua_scripts_mem = 0;

    luaRegisterRedisAPI(lua);

    /* register debug commands */
    lua_getglobal(lua,""redis"");

    /* redis.breakpoint */
    lua_pushstring(lua,""breakpoint"");
    lua_pushcfunction(lua,luaRedisBreakpointCommand);
    lua_settable(lua,-3);

    /* redis.debug */
    lua_pushstring(lua,""debug"");
    lua_pushcfunction(lua,luaRedisDebugCommand);
    lua_settable(lua,-3);

    /* redis.replicate_commands */
    lua_pushstring(lua, ""replicate_commands"");
    lua_pushcfunction(lua, luaRedisReplicateCommandsCommand);
...",1,34,eval.c,scriptingInit,,false,183,265,scriptingInit,,,18,void scriptingInit (int)
123698,METHOD,eval.c:<global>,TYPE_DECL,"void scriptingRelease(int async) {
    if (async)
        freeLuaScriptsAsync(lctx.lua_scripts);
    else
        dictRelease(lctx.lua_scripts);
    lctx.lua_scripts_mem = 0;
    lua_close(lctx.lua);
}",1,1,eval.c,scriptingRelease,,false,269,276,scriptingRelease,,,19,void scriptingRelease (int)
123725,METHOD,eval.c:<global>,TYPE_DECL,"void scriptingReset(int async) {
    scriptingRelease(async);
    scriptingInit(0);
}",1,1,eval.c,scriptingReset,,false,278,281,scriptingReset,,,20,void scriptingReset (int)
123734,METHOD,eval.c:<global>,TYPE_DECL,"static void evalCalcFunctionName(int evalsha, sds script, char *out_funcname) {
    /* We obtain the script SHA1, then check if this function is already
     * defined into the Lua state */
    out_funcname[0] = 'f';
    out_funcname[1] = '_';
    if (!evalsha) {
        /* Hash the code if this is an EVAL call */
        sha1hex(out_funcname+2,script,sdslen(script));
    } else {
        /* We already have the SHA if it is an EVALSHA */
        int j;
        char *sha = script;

        /* Convert to lowercase. We don't use tolower since the function
         * managed to always show up in the profiler output consuming
         * a non trivial amount of time. */
        for (j = 0; j < 40; j++)
            out_funcname[j+2] = (sha[j] >= 'A' && sha[j] <= 'Z') ?
                sha[j]+('a'-'A') : sha[j];
        out_funcname[42] = '\0';
    }
}",1,1,eval.c,evalCalcFunctionName,,false,287,308,evalCalcFunctionName,,,21,"void evalCalcFunctionName (int,sds,char*)"
123812,METHOD,eval.c:<global>,TYPE_DECL,"int evalExtractShebangFlags(sds body, uint64_t *out_flags, ssize_t *out_shebang_len, sds *err) {
    ssize_t shebang_len = 0;
    uint64_t script_flags = SCRIPT_FLAG_EVAL_COMPAT_MODE;
    if (!strncmp(body, ""#!"", 2)) {
        int numparts,j;
        char *shebang_end = strchr(body, '\n');
        if (shebang_end == NULL) {
            if (err)
                *err = sdsnew(""Invalid script shebang"");
            return C_ERR;
        }
        shebang_len = shebang_end - body;
        sds shebang = sdsnewlen(body, shebang_len);
        sds *parts = sdssplitargs(shebang, &numparts);
        sdsfree(shebang);
        if (!parts || numparts == 0) {
            if (err)
                *err = sdsnew(""Invalid engine in script shebang"");
            sdsfreesplitres(parts, numparts);
            return C_ERR;
        }
        /* Verify lua interpreter was specified */
        if (strcmp(parts[0], ""#!lua"")) {
            if (err)
                *err = sdscatfmt(sdsempty(), ""Unexpected eng...",1,28,eval.c,evalExtractShebangFlags,,false,315,378,evalExtractShebangFlags,,,22,"int evalExtractShebangFlags (sds,uint64_t*,ssize_t*,sds*)"
124099,METHOD,eval.c:<global>,TYPE_DECL,"uint64_t evalGetCommandFlags(client *c, uint64_t cmd_flags) {
    char funcname[43];
    int evalsha = c->cmd->proc == evalShaCommand || c->cmd->proc == evalShaRoCommand;
    if (evalsha && sdslen(c->argv[1]->ptr) != 40)
        return cmd_flags;
    uint64_t script_flags;
    evalCalcFunctionName(evalsha, c->argv[1]->ptr, funcname);
    char *lua_cur_script = funcname + 2;
    c->cur_script = dictFind(lctx.lua_scripts, lua_cur_script);
    if (!c->cur_script) {
        if (evalsha)
            return cmd_flags;
        if (evalExtractShebangFlags(c->argv[1]->ptr, &script_flags, NULL, NULL) == C_ERR)
            return cmd_flags;
    } else {
        luaScript *l = dictGetVal(c->cur_script);
        script_flags = l->flags;
    }
    if (script_flags & SCRIPT_FLAG_EVAL_COMPAT_MODE)
        return cmd_flags;
    return scriptFlagsToCmdFlags(cmd_flags, script_flags);
}",1,83,eval.c,evalGetCommandFlags,,false,382,403,evalGetCommandFlags,,,23,"uint64_t evalGetCommandFlags (client*,uint64_t)"
124227,METHOD,eval.c:<global>,TYPE_DECL,"sds luaCreateFunction(client *c, robj *body) {
    char funcname[43];
    dictEntry *de;
    uint64_t script_flags;

    funcname[0] = 'f';
    funcname[1] = '_';
    sha1hex(funcname+2,body->ptr,sdslen(body->ptr));

    if ((de = dictFind(lctx.lua_scripts,funcname+2)) != NULL) {
        return dictGetKey(de);
    }

    /* Handle shebang header in script code */
    ssize_t shebang_len = 0;
    sds err = NULL;
    if (evalExtractShebangFlags(body->ptr, &script_flags, &shebang_len, &err) == C_ERR) {
        addReplyErrorSds(c, err);
        return NULL;
    }

    /* Note that in case of a shebang line we skip it but keep the line feed to conserve the user's line numbers */
    if (luaL_loadbuffer(lctx.lua,(char*)body->ptr + shebang_len,sdslen(body->ptr) - shebang_len,""@user_script"")) {
        if (c != NULL) {
            addReplyErrorFormat(c,
                ""Error compiling script (new function): %s"",
                lua_tostring(lctx.lua,-1));
        }
        lua_pop(lctx.lua...",1,81,eval.c,luaCreateFunction,,false,422,470,luaCreateFunction,,,24,"sds luaCreateFunction (client*,robj*)"
124439,METHOD,eval.c:<global>,TYPE_DECL,"void evalGenericCommand(client *c, int evalsha) {
    lua_State *lua = lctx.lua;
    char funcname[43];
    long long numkeys;

    /* Get the number of arguments that are keys */
    if (getLongLongFromObjectOrReply(c,c->argv[2],&numkeys,NULL) != C_OK)
        return;
    if (numkeys > (c->argc - 3)) {
        addReplyError(c,""Number of keys can't be greater than number of args"");
        return;
    } else if (numkeys < 0) {
        addReplyError(c,""Number of keys can't be negative"");
        return;
    }

    if (c->cur_script) {
        funcname[0] = 'f', funcname[1] = '_';
        memcpy(funcname+2, dictGetKey(c->cur_script), 40);
        funcname[42] = '\0';
    } else
        evalCalcFunctionName(evalsha, c->argv[1]->ptr, funcname);

    /* Push the pcall error handler function on the stack. */
    lua_getglobal(lua, ""__redis__err__handler"");

    /* Try to lookup the Lua function */
    lua_getfield(lua, LUA_REGISTRYINDEX, funcname);
    if (lua_isnil(lua,-1)) {
        lua...",1,68,eval.c,evalGenericCommand,,false,472,539,evalGenericCommand,,,25,"void evalGenericCommand (client*,int)"
124712,METHOD,eval.c:<global>,TYPE_DECL,"void evalCommand(client *c) {
    /* Explicitly feed monitor here so that lua commands appear after their
     * script command. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
    if (!(c->flags & CLIENT_LUA_DEBUG))
        evalGenericCommand(c,0);
    else
        evalGenericCommandWithDebugging(c,0);
}",1,21,eval.c,evalCommand,,false,541,549,evalCommand,,,26,void evalCommand (client*)
124753,METHOD,eval.c:<global>,TYPE_DECL,"void evalRoCommand(client *c) {
    evalCommand(c);
}",1,1,eval.c,evalRoCommand,,false,551,553,evalRoCommand,,,27,void evalRoCommand (client*)
124760,METHOD,eval.c:<global>,TYPE_DECL,"void evalShaCommand(client *c) {
    /* Explicitly feed monitor here so that lua commands appear after their
     * script command. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
    if (sdslen(c->argv[1]->ptr) != 40) {
        /* We know that a match is not possible if the provided SHA is
         * not the right length. So we return an error ASAP, this way
         * evalGenericCommand() can be implemented without string length
         * sanity check */
        addReplyErrorObject(c, shared.noscripterr);
        return;
    }
    if (!(c->flags & CLIENT_LUA_DEBUG))
        evalGenericCommand(c,1);
    else {
        addReplyError(c,""Please use EVAL instead of EVALSHA for debugging"");
        return;
    }
}",1,21,eval.c,evalShaCommand,,false,555,573,evalShaCommand,,,28,void evalShaCommand (client*)
124820,METHOD,eval.c:<global>,TYPE_DECL,"void evalShaRoCommand(client *c) {
    evalShaCommand(c);
}",1,1,eval.c,evalShaRoCommand,,false,575,577,evalShaRoCommand,,,29,void evalShaRoCommand (client*)
124827,METHOD,eval.c:<global>,TYPE_DECL,"void scriptCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""DEBUG (YES|SYNC|NO)"",
""    Set the debug mode for subsequent scripts executed."",
""EXISTS <sha1> [<sha1> ...]"",
""    Return information about the existence of the scripts in the script cache."",
""FLUSH [ASYNC|SYNC]"",
""    Flush the Lua scripts cache. Very dangerous on replicas."",
""    When called without the optional mode argument, the behavior is determined by the"",
""    lazyfree-lazy-user-flush configuration directive. Valid modes are:"",
""    * ASYNC: Asynchronously flush the scripts cache."",
""    * SYNC: Synchronously flush the scripts cache."",
""KILL"",
""    Kill the currently executing Lua script."",
""LOAD <script>"",
""    Load a script into the scripts cache without executing it."",
NULL
        };
        addReplyHelp(c, help);
    } else if (c->argc >= 2 && !strcasecmp(c->argv[1]->ptr,""flush"")) {
        int async = 0;
        if (c->argc == 3 && !strcasecm...",1,24,eval.c,scriptCommand,,false,579,651,scriptCommand,,,30,void scriptCommand (client*)
125207,METHOD,eval.c:<global>,TYPE_DECL,"unsigned long evalMemory(void) {
    return luaMemory(lctx.lua);
}",1,1,eval.c,evalMemory,,false,653,655,evalMemory,,,31,unsigned long evalMemory (void)
125217,METHOD,eval.c:<global>,TYPE_DECL,"dict* evalScriptsDict(void) {
    return lctx.lua_scripts;
}",1,1,eval.c,evalScriptsDict,,false,657,659,evalScriptsDict,,,32,dict evalScriptsDict (void)
125226,METHOD,eval.c:<global>,TYPE_DECL,"unsigned long evalScriptsMemory(void) {
    return lctx.lua_scripts_mem +
            dictMemUsage(lctx.lua_scripts) +
            dictSize(lctx.lua_scripts) * sizeof(luaScript);
}",1,12,eval.c,evalScriptsMemory,,false,661,665,evalScriptsMemory,,,33,unsigned long evalScriptsMemory (void)
125264,METHOD,eval.c:<global>,TYPE_DECL,"void ldbInit(void) {
    ldb.conn = NULL;
    ldb.active = 0;
    ldb.logs = listCreate();
    listSetFreeMethod(ldb.logs,(void (*)(void*))sdsfree);
    ldb.children = listCreate();
    ldb.src = NULL;
    ldb.lines = 0;
    ldb.cbuf = sdsempty();
}",1,4,eval.c,ldbInit,,false,672,681,ldbInit,,,34,void ldbInit (void)
125318,METHOD,eval.c:<global>,TYPE_DECL,"void ldbFlushLog(list *log) {
    listNode *ln;

    while((ln = listFirst(log)) != NULL)
        listDelNode(log,ln);
}",1,16,eval.c,ldbFlushLog,,false,684,689,ldbFlushLog,,,35,void ldbFlushLog (list*)
125338,METHOD,eval.c:<global>,TYPE_DECL,"int ldbIsEnabled(void){
    return ldb.active && ldb.step;
}",1,1,eval.c,ldbIsEnabled,,false,691,693,ldbIsEnabled,,,36,int ldbIsEnabled (void)
125351,METHOD,eval.c:<global>,TYPE_DECL,"void ldbEnable(client *c) {
    c->flags |= CLIENT_LUA_DEBUG;
    ldbFlushLog(ldb.logs);
    ldb.conn = c->conn;
    ldb.step = 1;
    ldb.bpcount = 0;
    ldb.luabp = 0;
    sdsfree(ldb.cbuf);
    ldb.cbuf = sdsempty();
    ldb.maxlen = LDB_MAX_LEN_DEFAULT;
    ldb.maxlen_hint_sent = 0;
}",1,16,eval.c,ldbEnable,,false,696,707,ldbEnable,,,37,void ldbEnable (client*)
125412,METHOD,eval.c:<global>,TYPE_DECL,"void ldbDisable(client *c) {
    c->flags &= ~(CLIENT_LUA_DEBUG|CLIENT_LUA_DEBUG_SYNC);
}",1,18,eval.c,ldbDisable,,false,712,714,ldbDisable,,,38,void ldbDisable (client*)
125433,METHOD,eval.c:<global>,TYPE_DECL,"void ldbLog(sds entry) {
    listAddNodeTail(ldb.logs,entry);
}",1,1,eval.c,ldbLog,,false,717,719,ldbLog,,,39,void ldbLog (sds)
125443,METHOD,eval.c:<global>,TYPE_DECL,"void ldbLogWithMaxLen(sds entry) {
    int trimmed = 0;
    if (ldb.maxlen && sdslen(entry) > ldb.maxlen) {
        sdsrange(entry,0,ldb.maxlen-1);
        entry = sdscatlen(entry,"" ..."",4);
        trimmed = 1;
    }
    ldbLog(entry);
    if (trimmed && ldb.maxlen_hint_sent == 0) {
        ldb.maxlen_hint_sent = 1;
        ldbLog(sdsnew(
        ""<hint> The above reply was trimmed. Use 'maxlen 0' to disable trimming.""));
    }
}",1,1,eval.c,ldbLogWithMaxLen,,false,725,738,ldbLogWithMaxLen,,,40,void ldbLogWithMaxLen (sds)
125500,METHOD,eval.c:<global>,TYPE_DECL,"void ldbSendLogs(void) {
    sds proto = sdsempty();
    proto = sdscatfmt(proto,""*%i\r\n"", (int)listLength(ldb.logs));
    while(listLength(ldb.logs)) {
        listNode *ln = listFirst(ldb.logs);
        proto = sdscatlen(proto,""+"",1);
        sdsmapchars(ln->value,""\r\n"",""  "",2);
        proto = sdscatsds(proto,ln->value);
        proto = sdscatlen(proto,""\r\n"",2);
        listDelNode(ldb.logs,ln);
    }
    if (connWrite(ldb.conn,proto,sdslen(proto)) == -1) {
        /* Avoid warning. We don't check the return value of write()
         * since the next read() will catch the I/O error and will
         * close the debugging session. */
    }
    sdsfree(proto);
}",1,44,eval.c,ldbSendLogs,,false,743,760,ldbSendLogs,,,41,void ldbSendLogs (void)
125596,METHOD,eval.c:<global>,TYPE_DECL,"int ldbStartSession(client *c) {
    ldb.forked = (c->flags & CLIENT_LUA_DEBUG_SYNC) == 0;
    if (ldb.forked) {
        pid_t cp = redisFork(CHILD_TYPE_LDB);
        if (cp == -1) {
            addReplyErrorFormat(c,""Fork() failed: can't run EVAL in debugging mode: %s"", strerror(errno));
            return 0;
        } else if (cp == 0) {
            /* Child. Let's ignore important signals handled by the parent. */
            struct sigaction act;
            sigemptyset(&act.sa_mask);
            act.sa_flags = 0;
            act.sa_handler = SIG_IGN;
            sigaction(SIGTERM, &act, NULL);
            sigaction(SIGINT, &act, NULL);

            /* Log the creation of the child and close the listening
             * socket to make sure if the parent crashes a reset is sent
             * to the clients. */
            serverLog(LL_NOTICE,""Redis forked for debugging eval"");
        } else {
            /* Parent */
            listAddNodeTail(ldb.children,(void*)(unsigned lon...",1,29,eval.c,ldbStartSession,,false,774,823,ldbStartSession,,,42,int ldbStartSession (client*)
125803,METHOD,eval.c:<global>,TYPE_DECL,"void ldbEndSession(client *c) {
    /* Emit the remaining logs and an <endsession> mark. */
    ldbLog(sdsnew(""<endsession>""));
    ldbSendLogs();

    /* If it's a fork()ed session, we just exit. */
    if (ldb.forked) {
        writeToClient(c,0);
        serverLog(LL_NOTICE,""Lua debugging session child exiting"");
        exitFromChild(0);
    } else {
        serverLog(LL_NOTICE,
            ""Redis synchronous debugging eval session ended"");
    }

    /* Otherwise let's restore client's state. */
    connNonBlock(ldb.conn);
    connSendTimeout(ldb.conn,0);

    /* Close the client connection after sending the final EVAL reply
     * in order to signal the end of the debugging session. */
    c->flags |= CLIENT_CLOSE_AFTER_REPLY;

    /* Cleanup. */
    sdsfreesplitres(ldb.src,ldb.lines);
    ldb.lines = 0;
    ldb.active = 0;
}",1,8,eval.c,ldbEndSession,,false,827,854,ldbEndSession,,,43,void ldbEndSession (client*)
125895,METHOD,eval.c:<global>,TYPE_DECL,"int ldbRemoveChild(pid_t pid) {
    listNode *ln = listSearchKey(ldb.children,(void*)(unsigned long)pid);
    if (ln) {
        listDelNode(ldb.children,ln);
        return 1;
    }
    return 0;
}",1,1,eval.c,ldbRemoveChild,,false,859,866,ldbRemoveChild,,,44,int ldbRemoveChild (pid_t)
125924,METHOD,eval.c:<global>,TYPE_DECL,"int ldbPendingChildren(void) {
    return listLength(ldb.children);
}",1,11,eval.c,ldbPendingChildren,,false,870,872,ldbPendingChildren,,,45,int ldbPendingChildren (void)
125940,METHOD,eval.c:<global>,TYPE_DECL,"void ldbKillForkedSessions(void) {
    listIter li;
    listNode *ln;

    listRewind(ldb.children,&li);
    while((ln = listNext(&li))) {
        pid_t pid = (unsigned long) ln->value;
        serverLog(LL_NOTICE,""Killing debugging session %ld"",(long)pid);
        kill(pid,SIGKILL);
    }
    listRelease(ldb.children);
    ldb.children = listCreate();
}",1,8,eval.c,ldbKillForkedSessions,,false,875,887,ldbKillForkedSessions,,,46,void ldbKillForkedSessions (void)
126001,METHOD,eval.c:<global>,TYPE_DECL,"void evalGenericCommandWithDebugging(client *c, int evalsha) {
    if (ldbStartSession(c)) {
        evalGenericCommand(c,evalsha);
        ldbEndSession(c);
    } else {
        ldbDisable(c);
    }
}",1,1,eval.c,evalGenericCommandWithDebugging,,false,891,898,evalGenericCommandWithDebugging,,,47,"void evalGenericCommandWithDebugging (client*,int)"
126020,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbGetSourceLine(int line) {
    int idx = line-1;
    if (idx < 0 || idx >= ldb.lines) return ""<out of range source code line>"";
    return ldb.src[idx];
}",1,1,eval.c,ldbGetSourceLine,,false,902,906,ldbGetSourceLine,,,48,char* ldbGetSourceLine (int)
126050,METHOD,eval.c:<global>,TYPE_DECL,"int ldbIsBreakpoint(int line) {
    int j;

    for (j = 0; j < ldb.bpcount; j++)
        if (ldb.bp[j] == line) return 1;
    return 0;
}",1,1,eval.c,ldbIsBreakpoint,,false,909,915,ldbIsBreakpoint,,,49,int ldbIsBreakpoint (int)
126081,METHOD,eval.c:<global>,TYPE_DECL,"int ldbAddBreakpoint(int line) {
    if (line <= 0 || line > ldb.lines) return 0;
    if (!ldbIsBreakpoint(line) && ldb.bpcount != LDB_BREAKPOINTS_MAX) {
        ldb.bp[ldb.bpcount++] = line;
        return 1;
    }
    return 0;
}",1,49,eval.c,ldbAddBreakpoint,,false,920,927,ldbAddBreakpoint,,,50,int ldbAddBreakpoint (int)
126126,METHOD,eval.c:<global>,TYPE_DECL,"int ldbDelBreakpoint(int line) {
    int j;

    for (j = 0; j < ldb.bpcount; j++) {
        if (ldb.bp[j] == line) {
            ldb.bpcount--;
            memmove(ldb.bp+j,ldb.bp+j+1,ldb.bpcount-j);
            return 1;
        }
    }
    return 0;
}",1,1,eval.c,ldbDelBreakpoint,,false,931,942,ldbDelBreakpoint,,,51,int ldbDelBreakpoint (int)
126180,METHOD,eval.c:<global>,TYPE_DECL,"sds *ldbReplParseCommand(int *argcp, char** err) {
    static char* protocol_error = ""protocol error"";
    sds *argv = NULL;
    int argc = 0;
    if (sdslen(ldb.cbuf) == 0) return NULL;

    /* Working on a copy is simpler in this case. We can modify it freely
     * for the sake of simpler parsing. */
    sds copy = sdsdup(ldb.cbuf);
    char *p = copy;

    /* This Redis protocol parser is a joke... just the simplest thing that
     * works in this context. It is also very forgiving regarding broken
     * protocol. */

    /* Seek and parse *<count>\r\n. */
    p = strchr(p,'*'); if (!p) goto protoerr;
    char *plen = p+1; /* Multi bulk len pointer. */
    p = strstr(p,""\r\n""); if (!p) goto keep_reading;
    *p = '\0'; p += 2;
    *argcp = atoi(plen);
    if (*argcp <= 0 || *argcp > 1024) goto protoerr;

    /* Parse each argument. */
    argv = zmalloc(sizeof(sds)*(*argcp));
    argc = 0;
    while(argc < *argcp) {
        /* reached the end but there should be more data to re...",1,1,eval.c,ldbReplParseCommand,,false,947,998,ldbReplParseCommand,,,52,"sds ldbReplParseCommand (int*,char**)"
126396,METHOD,eval.c:<global>,TYPE_DECL,"void ldbLogSourceLine(int lnum) {
    char *line = ldbGetSourceLine(lnum);
    char *prefix;
    int bp = ldbIsBreakpoint(lnum);
    int current = ldb.currentline == lnum;

    if (current && bp)
        prefix = ""->#"";
    else if (current)
        prefix = ""-> "";
    else if (bp)
        prefix = ""  #"";
    else
        prefix = ""   "";
    sds thisline = sdscatprintf(sdsempty(),""%s%-3d %s"", prefix, lnum, line);
    ldbLog(thisline);
}",1,1,eval.c,ldbLogSourceLine,,false,1001,1017,ldbLogSourceLine,,,53,void ldbLogSourceLine (int)
126460,METHOD,eval.c:<global>,TYPE_DECL,"void ldbList(int around, int context) {
    int j;

    for (j = 1; j <= ldb.lines; j++) {
        if (around != 0 && abs(around-j) > context) continue;
        ldbLogSourceLine(j);
    }
}",1,1,eval.c,ldbList,,false,1024,1031,ldbList,,,54,"void ldbList (int,int)"
126495,METHOD,eval.c:<global>,TYPE_DECL,"sds ldbCatStackValueRec(sds s, lua_State *lua, int idx, int level) {
    int t = lua_type(lua,idx);

    if (level++ == LDB_MAX_VALUES_DEPTH)
        return sdscat(s,""<max recursion level reached! Nested table?>"");

    switch(t) {
    case LUA_TSTRING:
        {
        size_t strl;
        char *strp = (char*)lua_tolstring(lua,idx,&strl);
        s = sdscatrepr(s,strp,strl);
        }
        break;
    case LUA_TBOOLEAN:
        s = sdscat(s,lua_toboolean(lua,idx) ? ""true"" : ""false"");
        break;
    case LUA_TNUMBER:
        s = sdscatprintf(s,""%g"",(double)lua_tonumber(lua,idx));
        break;
    case LUA_TNIL:
        s = sdscatlen(s,""nil"",3);
        break;
    case LUA_TTABLE:
        {
        int expected_index = 1; /* First index we expect in an array. */
        int is_array = 1; /* Will be set to null if check fails. */
        /* Note: we create two representations at the same time, one
         * assuming the table is an array, one assuming it is not. At the
     ...",1,19,eval.c,ldbCatStackValueRec,,false,1041,1122,ldbCatStackValueRec,,,55,"sds ldbCatStackValueRec (sds,lua_State*,int,int)"
126800,METHOD,eval.c:<global>,TYPE_DECL,"sds ldbCatStackValue(sds s, lua_State *lua, int idx) {
    return ldbCatStackValueRec(s,lua,idx,0);
}",1,1,eval.c,ldbCatStackValue,,false,1126,1128,ldbCatStackValue,,,56,"sds ldbCatStackValue (sds,lua_State*,int)"
126813,METHOD,eval.c:<global>,TYPE_DECL,"void ldbLogStackValue(lua_State *lua, char *prefix) {
    sds s = sdsnew(prefix);
    s = ldbCatStackValue(s,lua,-1);
    ldbLogWithMaxLen(s);
}",1,1,eval.c,ldbLogStackValue,,false,1133,1137,ldbLogStackValue,,,57,"void ldbLogStackValue (lua_State*,char*)"
126833,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Int(sds *o, char *reply);",6,54,eval.c,ldbRedisProtocolToHuman_Int,,false,1139,1139,ldbRedisProtocolToHuman_Int,,,58,"char* ldbRedisProtocolToHuman_Int (sds*,char*)"
126839,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply);",6,55,eval.c,ldbRedisProtocolToHuman_Bulk,,false,1140,1140,ldbRedisProtocolToHuman_Bulk,,,59,"char* ldbRedisProtocolToHuman_Bulk (sds*,char*)"
126845,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Status(sds *o, char *reply);",6,57,eval.c,ldbRedisProtocolToHuman_Status,,false,1141,1141,ldbRedisProtocolToHuman_Status,,,60,"char* ldbRedisProtocolToHuman_Status (sds*,char*)"
126851,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply);",6,60,eval.c,ldbRedisProtocolToHuman_MultiBulk,,false,1142,1142,ldbRedisProtocolToHuman_MultiBulk,,,61,"char* ldbRedisProtocolToHuman_MultiBulk (sds*,char*)"
126857,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Set(sds *o, char *reply);",6,54,eval.c,ldbRedisProtocolToHuman_Set,,false,1143,1143,ldbRedisProtocolToHuman_Set,,,62,"char* ldbRedisProtocolToHuman_Set (sds*,char*)"
126863,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Map(sds *o, char *reply);",6,54,eval.c,ldbRedisProtocolToHuman_Map,,false,1144,1144,ldbRedisProtocolToHuman_Map,,,63,"char* ldbRedisProtocolToHuman_Map (sds*,char*)"
126869,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Null(sds *o, char *reply);",6,55,eval.c,ldbRedisProtocolToHuman_Null,,false,1145,1145,ldbRedisProtocolToHuman_Null,,,64,"char* ldbRedisProtocolToHuman_Null (sds*,char*)"
126875,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Bool(sds *o, char *reply);",6,55,eval.c,ldbRedisProtocolToHuman_Bool,,false,1146,1146,ldbRedisProtocolToHuman_Bool,,,65,"char* ldbRedisProtocolToHuman_Bool (sds*,char*)"
126881,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Double(sds *o, char *reply);",6,57,eval.c,ldbRedisProtocolToHuman_Double,,false,1147,1147,ldbRedisProtocolToHuman_Double,,,66,"char* ldbRedisProtocolToHuman_Double (sds*,char*)"
126887,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman(sds *o, char *reply) {
    char *p = reply;
    switch(*p) {
    case ':': p = ldbRedisProtocolToHuman_Int(o,reply); break;
    case '$': p = ldbRedisProtocolToHuman_Bulk(o,reply); break;
    case '+': p = ldbRedisProtocolToHuman_Status(o,reply); break;
    case '-': p = ldbRedisProtocolToHuman_Status(o,reply); break;
    case '*': p = ldbRedisProtocolToHuman_MultiBulk(o,reply); break;
    case '~': p = ldbRedisProtocolToHuman_Set(o,reply); break;
    case '%': p = ldbRedisProtocolToHuman_Map(o,reply); break;
    case '_': p = ldbRedisProtocolToHuman_Null(o,reply); break;
    case '#': p = ldbRedisProtocolToHuman_Bool(o,reply); break;
    case ',': p = ldbRedisProtocolToHuman_Double(o,reply); break;
    }
    return p;
}",1,1,eval.c,ldbRedisProtocolToHuman,,false,1154,1169,ldbRedisProtocolToHuman,,,67,"char* ldbRedisProtocolToHuman (sds*,char*)"
126983,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Int(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,reply+1,p-reply-1);
    return p+2;
}",1,1,eval.c,ldbRedisProtocolToHuman_Int,,false,1174,1178,ldbRedisProtocolToHuman_Int,,,68,"char* ldbRedisProtocolToHuman_Int (sds*,char*)"
127015,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Bulk(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long bulklen;

    string2ll(reply+1,p-reply-1,&bulklen);
    if (bulklen == -1) {
        *o = sdscatlen(*o,""NULL"",4);
        return p+2;
    } else {
        *o = sdscatrepr(*o,p+2,bulklen);
        return p+2+bulklen+2;
    }
}",1,1,eval.c,ldbRedisProtocolToHuman_Bulk,,false,1180,1192,ldbRedisProtocolToHuman_Bulk,,,69,"char* ldbRedisProtocolToHuman_Bulk (sds*,char*)"
127079,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Status(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');

    *o = sdscatrepr(*o,reply,p-reply);
    return p+2;
}",1,1,eval.c,ldbRedisProtocolToHuman_Status,,false,1194,1199,ldbRedisProtocolToHuman_Status,,,70,"char* ldbRedisProtocolToHuman_Status (sds*,char*)"
127107,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_MultiBulk(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    if (mbulklen == -1) {
        *o = sdscatlen(*o,""NULL"",4);
        return p;
    }
    *o = sdscatlen(*o,""["",1);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,""]"",1);
    return p;
}",1,1,eval.c,ldbRedisProtocolToHuman_MultiBulk,,false,1201,1219,ldbRedisProtocolToHuman_MultiBulk,,,71,"char* ldbRedisProtocolToHuman_MultiBulk (sds*,char*)"
127205,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Set(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    *o = sdscatlen(*o,""~("",2);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,"")"",1);
    return p;
}",1,1,eval.c,ldbRedisProtocolToHuman_Set,,false,1221,1235,ldbRedisProtocolToHuman_Set,,,72,"char* ldbRedisProtocolToHuman_Set (sds*,char*)"
127287,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Map(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    long long mbulklen;
    int j = 0;

    string2ll(reply+1,p-reply-1,&mbulklen);
    p += 2;
    *o = sdscatlen(*o,""{"",1);
    for (j = 0; j < mbulklen; j++) {
        p = ldbRedisProtocolToHuman(o,p);
        *o = sdscatlen(*o,"" => "",4);
        p = ldbRedisProtocolToHuman(o,p);
        if (j != mbulklen-1) *o = sdscatlen(*o,"","",1);
    }
    *o = sdscatlen(*o,""}"",1);
    return p;
}",1,1,eval.c,ldbRedisProtocolToHuman_Map,,false,1237,1253,ldbRedisProtocolToHuman_Map,,,73,"char* ldbRedisProtocolToHuman_Map (sds*,char*)"
127382,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Null(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,""(null)"",6);
    return p+2;
}",1,1,eval.c,ldbRedisProtocolToHuman_Null,,false,1255,1259,ldbRedisProtocolToHuman_Null,,,74,"char* ldbRedisProtocolToHuman_Null (sds*,char*)"
127408,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Bool(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    if (reply[1] == 't')
        *o = sdscatlen(*o,""#true"",5);
    else
        *o = sdscatlen(*o,""#false"",6);
    return p+2;
}",1,1,eval.c,ldbRedisProtocolToHuman_Bool,,false,1261,1268,ldbRedisProtocolToHuman_Bool,,,75,"char* ldbRedisProtocolToHuman_Bool (sds*,char*)"
127451,METHOD,eval.c:<global>,TYPE_DECL,"char *ldbRedisProtocolToHuman_Double(sds *o, char *reply) {
    char *p = strchr(reply+1,'\r');
    *o = sdscatlen(*o,""(double) "",9);
    *o = sdscatlen(*o,reply+1,p-reply-1);
    return p+2;
}",1,1,eval.c,ldbRedisProtocolToHuman_Double,,false,1270,1275,ldbRedisProtocolToHuman_Double,,,76,"char* ldbRedisProtocolToHuman_Double (sds*,char*)"
127491,METHOD,eval.c:<global>,TYPE_DECL,"void ldbLogRedisReply(char *reply) {
    sds log = sdsnew(""<reply> "");
    ldbRedisProtocolToHuman(&log,reply);
    ldbLogWithMaxLen(log);
}",1,1,eval.c,ldbLogRedisReply,,false,1280,1284,ldbLogRedisReply,,,77,void ldbLogRedisReply (char*)
127507,METHOD,eval.c:<global>,TYPE_DECL,"void ldbPrint(lua_State *lua, char *varname) {
    lua_Debug ar;

    int l = 0; /* Stack level. */
    while (lua_getstack(lua,l,&ar) != 0) {
        l++;
        const char *name;
        int i = 1; /* Variable index. */
        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
            i++;
            if (strcmp(varname,name) == 0) {
                ldbLogStackValue(lua,""<value> "");
                lua_pop(lua,1);
                return;
            } else {
                lua_pop(lua,1); /* Discard the var name on the stack. */
            }
        }
    }

    /* Let's try with global vars in two selected cases */
    if (!strcmp(varname,""ARGV"") || !strcmp(varname,""KEYS"")) {
        lua_getglobal(lua, varname);
        ldbLogStackValue(lua,""<value> "");
        lua_pop(lua,1);
    } else {
        ldbLog(sdsnew(""No such variable.""));
    }
}",1,1,eval.c,ldbPrint,,false,1289,1317,ldbPrint,,,78,"void ldbPrint (lua_State*,char*)"
127591,METHOD,eval.c:<global>,TYPE_DECL,"void ldbPrintAll(lua_State *lua) {
    lua_Debug ar;
    int vars = 0;

    if (lua_getstack(lua,0,&ar) != 0) {
        const char *name;
        int i = 1; /* Variable index. */
        while((name = lua_getlocal(lua,&ar,i)) != NULL) {
            i++;
            if (!strstr(name,""(*temporary)"")) {
                sds prefix = sdscatprintf(sdsempty(),""<value> %s = "",name);
                ldbLogStackValue(lua,prefix);
                sdsfree(prefix);
                vars++;
            }
            lua_pop(lua,1);
        }
    }

    if (vars == 0) {
        ldbLog(sdsnew(""No local variables in the current context.""));
    }
}",1,1,eval.c,ldbPrintAll,,false,1321,1343,ldbPrintAll,,,79,void ldbPrintAll (lua_State*)
127659,METHOD,eval.c:<global>,TYPE_DECL,"void ldbBreak(sds *argv, int argc) {
    if (argc == 1) {
        if (ldb.bpcount == 0) {
            ldbLog(sdsnew(""No breakpoints set. Use 'b <line>' to add one.""));
            return;
        } else {
            ldbLog(sdscatfmt(sdsempty(),""%i breakpoints set:"",ldb.bpcount));
            int j;
            for (j = 0; j < ldb.bpcount; j++)
                ldbLogSourceLine(ldb.bp[j]);
        }
    } else {
        int j;
        for (j = 1; j < argc; j++) {
            char *arg = argv[j];
            long line;
            if (!string2l(arg,sdslen(arg),&line)) {
                ldbLog(sdscatfmt(sdsempty(),""Invalid argument:'%s'"",arg));
            } else {
                if (line == 0) {
                    ldb.bpcount = 0;
                    ldbLog(sdsnew(""All breakpoints removed.""));
                } else if (line > 0) {
                    if (ldb.bpcount == LDB_BREAKPOINTS_MAX) {
                        ldbLog(sdsnew(""Too many breakpoints set.""));
                    } ...",1,39,eval.c,ldbBreak,,false,1346,1385,ldbBreak,,,80,"void ldbBreak (sds*,int)"
127812,METHOD,eval.c:<global>,TYPE_DECL,"void ldbEval(lua_State *lua, sds *argv, int argc) {
    /* Glue the script together if it is composed of multiple arguments. */
    sds code = sdsjoinsds(argv+1,argc-1,"" "",1);
    sds expr = sdscatsds(sdsnew(""return ""),code);

    /* Try to compile it as an expression, prepending ""return "". */
    if (luaL_loadbuffer(lua,expr,sdslen(expr),""@ldb_eval"")) {
        lua_pop(lua,1);
        /* Failed? Try as a statement. */
        if (luaL_loadbuffer(lua,code,sdslen(code),""@ldb_eval"")) {
            ldbLog(sdscatfmt(sdsempty(),""<error> %s"",lua_tostring(lua,-1)));
            lua_pop(lua,1);
            sdsfree(code);
            sdsfree(expr);
            return;
        }
    }

    /* Call it. */
    sdsfree(code);
    sdsfree(expr);
    if (lua_pcall(lua,0,1,0)) {
        ldbLog(sdscatfmt(sdsempty(),""<error> %s"",lua_tostring(lua,-1)));
        lua_pop(lua,1);
        return;
    }
    ldbLogStackValue(lua,""<retval> "");
    lua_pop(lua,1);
}",1,1,eval.c,ldbEval,,false,1390,1418,ldbEval,,,81,"void ldbEval (lua_State*,sds*,int)"
127902,METHOD,eval.c:<global>,TYPE_DECL,"void ldbRedis(lua_State *lua, sds *argv, int argc) {
    int j;

    if (!lua_checkstack(lua, argc + 1)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 'argc + 1' elements to the stack. On failure, return error.
         * Notice that we need, in worst case, 'argc + 1' elements because we push all the arguments
         * given by the user (without the first argument) and we also push the 'redis' global table and
         * 'redis.call' function so:
         * (1 (redis table)) + (1 (redis.call function)) + (argc - 1 (all arguments without the first)) = argc + 1*/
        ldbLogRedisReply(""max lua stack reached"");
        return;
    }

    lua_getglobal(lua,""redis"");
    lua_pushstring(lua,""call"");
    lua_gettable(lua,-2);       /* Stack: redis, redis.call */
    for (j = 1; j < argc; j++)
        lua_pushlstring(lua,argv[j],sdslen(argv[j]));
    ldb.step = 1;               /* Force redis.call() to log. */
    lua_pcall(lua,argc-...",1,1,eval.c,ldbRedis,,false,1424,1447,ldbRedis,,,82,"void ldbRedis (lua_State*,sds*,int)"
127970,METHOD,eval.c:<global>,TYPE_DECL,"void ldbTrace(lua_State *lua) {
    lua_Debug ar;
    int level = 0;

    while(lua_getstack(lua,level,&ar)) {
        lua_getinfo(lua,""Snl"",&ar);
        if(strstr(ar.short_src,""user_script"") != NULL) {
            ldbLog(sdscatprintf(sdsempty(),""%s %s:"",
                (level == 0) ? ""In"" : ""From"",
                ar.name ? ar.name : ""top level""));
            ldbLogSourceLine(ar.currentline);
        }
        level++;
    }
    if (level == 0) {
        ldbLog(sdsnew(""<error> Can't retrieve Lua stack.""));
    }
}",1,1,eval.c,ldbTrace,,false,1451,1468,ldbTrace,,,83,void ldbTrace (lua_State*)
128033,METHOD,eval.c:<global>,TYPE_DECL,"void ldbMaxlen(sds *argv, int argc) {
    if (argc == 2) {
        int newval = atoi(argv[1]);
        ldb.maxlen_hint_sent = 1; /* User knows about this command. */
        if (newval != 0 && newval <= 60) newval = 60;
        ldb.maxlen = newval;
    }
    if (ldb.maxlen) {
        ldbLog(sdscatprintf(sdsempty(),""<value> replies are truncated at %d bytes."",(int)ldb.maxlen));
    } else {
        ldbLog(sdscatprintf(sdsempty(),""<value> replies are unlimited.""));
    }
}",1,1,eval.c,ldbMaxlen,,false,1472,1484,ldbMaxlen,,,84,"void ldbMaxlen (sds*,int)"
128093,METHOD,eval.c:<global>,TYPE_DECL,"int ldbRepl(lua_State *lua) {
    sds *argv;
    int argc;
    char* err = NULL;

    /* We continue processing commands until a command that should return
     * to the Lua interpreter is found. */
    while(1) {
        while((argv = ldbReplParseCommand(&argc, &err)) == NULL) {
            char buf[1024];
            if (err) {
                luaPushError(lua, err);
                luaError(lua);
            }
            int nread = connRead(ldb.conn,buf,sizeof(buf));
            if (nread <= 0) {
                /* Make sure the script runs without user input since the
                 * client is no longer connected. */
                ldb.step = 0;
                ldb.bpcount = 0;
                return C_ERR;
            }
            ldb.cbuf = sdscatlen(ldb.cbuf,buf,nread);
            /* after 1M we will exit with an error
             * so that the client will not blow the memory
             */
            if (sdslen(ldb.cbuf) > 1<<20) {
                sdsfree(ldb.cbuf...",1,23,eval.c,ldbRepl,,false,1489,1616,ldbRepl,,,85,int ldbRepl (lua_State*)
128624,METHOD,eval.c:<global>,TYPE_DECL,"void luaLdbLineHook(lua_State *lua, lua_Debug *ar) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    lua_getstack(lua,0,ar);
    lua_getinfo(lua,""Sl"",ar);
    ldb.currentline = ar->currentline;

    int bp = ldbIsBreakpoint(ldb.currentline) || ldb.luabp;
    int timeout = 0;

    /* Events outside our script are not interesting. */
    if(strstr(ar->short_src,""user_script"") == NULL) return;

    /* Check if a timeout occurred. */
    if (ar->event == LUA_HOOKCOUNT && ldb.step == 0 && bp == 0) {
        mstime_t elapsed = elapsedMs(rctx->start_time);
        mstime_t timelimit = server.busy_reply_threshold ?
                             server.busy_reply_threshold : 5000;
        if (elapsed >= timelimit) {
            timeout = 1;
            ldb.step = 1;
        } else {
            return; /* No timeout, ignore the COUNT event. */
        }
    }

    if (ldb.step || bp) {
        c...",1,49,eval.c,luaLdbLineHook,,false,1620,1667,luaLdbLineHook,,,86,"void luaLdbLineHook (lua_State*,lua_Debug*)"
128831,METHOD,evict.c:<global>,TYPE_DECL,<global>,1,1,evict.c,evict.c:<global>,,false,1,755,<global>,,,1,
128840,METHOD,evict.c:<global>,TYPE_DECL,"unsigned int getLRUClock(void) {
    return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
}",1,21,evict.c,getLRUClock,,false,72,74,getLRUClock,,,4,unsigned int getLRUClock (void)
128859,METHOD,evict.c:<global>,TYPE_DECL,"unsigned int LRU_CLOCK(void) {
    unsigned int lruclock;
    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {
        lruclock = server.lruclock;
    } else {
        lruclock = getLRUClock();
    }
    return lruclock;
}",1,26,evict.c,LRU_CLOCK,,false,80,88,LRU_CLOCK,,,5,unsigned int LRU_CLOCK (void)
128888,METHOD,evict.c:<global>,TYPE_DECL,"unsigned long long estimateObjectIdleTime(robj *o) {
    unsigned long long lruclock = LRU_CLOCK();
    if (lruclock >= o->lru) {
        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
    } else {
        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *
                    LRU_CLOCK_RESOLUTION;
    }
}",1,37,evict.c,estimateObjectIdleTime,,false,92,100,estimateObjectIdleTime,,,6,unsigned long long estimateObjectIdleTime (robj*)
128934,METHOD,evict.c:<global>,TYPE_DECL,"void evictionPoolAlloc(void) {
    struct evictionPoolEntry *ep;
    int j;

    ep = zmalloc(sizeof(*ep)*EVPOOL_SIZE);
    for (j = 0; j < EVPOOL_SIZE; j++) {
        ep[j].idle = 0;
        ep[j].key = NULL;
        ep[j].cached = sdsnewlen(NULL,EVPOOL_CACHED_SDS_SIZE);
        ep[j].dbid = 0;
    }
    EvictionPoolLRU = ep;
}",1,29,evict.c,evictionPoolAlloc,,false,123,135,evictionPoolAlloc,,,7,void evictionPoolAlloc (void)
128999,METHOD,evict.c:<global>,TYPE_DECL,"void evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {
    int j, k, count;
    dictEntry *samples[server.maxmemory_samples];

    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);
    for (j = 0; j < count; j++) {
        unsigned long long idle;
        sds key;
        robj *o;
        dictEntry *de;

        de = samples[j];
        key = dictGetKey(de);

        /* If the dictionary we are sampling from is not the main
         * dictionary (but the expires one) we need to lookup the key
         * again in the key dictionary to obtain the value object. */
        if (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) {
            if (sampledict != keydict) de = dictFind(keydict, key);
            o = dictGetVal(de);
        }

        /* Calculate the idle time according to the policy. This is called
         * idle just because the code initially handled LRU, but is in fact
         * just a score where an h...",1,39,evict.c,evictionPoolPopulate,,false,146,241,evictionPoolPopulate,,,8,"void evictionPoolPopulate (int,dict*,dict*,evictionPoolEntry*)"
129361,METHOD,evict.c:<global>,TYPE_DECL,"unsigned long LFUGetTimeInMinutes(void) {
    return (server.unixtime/60) & 65535;
}",1,1,evict.c,LFUGetTimeInMinutes,,false,283,285,LFUGetTimeInMinutes,,,9,unsigned long LFUGetTimeInMinutes (void)
129374,METHOD,evict.c:<global>,TYPE_DECL,"unsigned long LFUTimeElapsed(unsigned long ldt) {
    unsigned long now = LFUGetTimeInMinutes();
    if (now >= ldt) return now-ldt;
    return 65535-ldt+now;
}",1,1,evict.c,LFUTimeElapsed,,false,291,295,LFUTimeElapsed,,,10,unsigned long LFUTimeElapsed (long unsigned)
129398,METHOD,evict.c:<global>,TYPE_DECL,"uint8_t LFULogIncr(uint8_t counter) {
    if (counter == 255) return 255;
    double r = (double)rand()/RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval < 0) baseval = 0;
    double p = 1.0/(baseval*server.lfu_log_factor+1);
    if (r < p) counter++;
    return counter;
}",1,31,evict.c,LFULogIncr,,false,299,307,LFULogIncr,,,11,uint8_t LFULogIncr (uint8_t)
129455,METHOD,evict.c:<global>,TYPE_DECL,"unsigned long LFUDecrAndReturn(robj *o) {
    unsigned long ldt = o->lru >> 8;
    unsigned long counter = o->lru & 255;
    unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;
    if (num_periods)
        counter = (num_periods > counter) ? 0 : counter - num_periods;
    return counter;
}",1,1,evict.c,LFUDecrAndReturn,,false,319,326,LFUDecrAndReturn,,,12,unsigned long LFUDecrAndReturn (robj*)
129505,METHOD,evict.c:<global>,TYPE_DECL,"size_t freeMemoryGetNotCountedMemory(void) {
    size_t overhead = 0;

    /* Since all replicas and replication backlog share global replication
     * buffer, we think only the part of exceeding backlog size is the extra
     * separate consumption of replicas.
     *
     * Note that although the backlog is also initially incrementally grown
     * (pushing DELs consumes memory), it'll eventually stop growing and
     * remain constant in size, so even if its creation will cause some
     * eviction, it's capped, and also here to stay (no resonance effect)
     *
     * Note that, because we trim backlog incrementally in the background,
     * backlog size may exceeds our setting if slow replicas that reference
     * vast replication buffer blocks disconnect. To avoid massive eviction
     * loop, we don't count the delayed freed replication backlog into used
     * memory even if there are no replicas, i.e. we still regard this memory
     * as replicas'. */
    if ((long long)...",1,38,evict.c,freeMemoryGetNotCountedMemory,,false,336,371,freeMemoryGetNotCountedMemory,,,13,size_t freeMemoryGetNotCountedMemory (void)
129584,METHOD,evict.c:<global>,TYPE_DECL,"int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {
    size_t mem_reported, mem_used, mem_tofree;

    /* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */
    mem_reported = zmalloc_used_memory();
    if (total) *total = mem_reported;

    /* We may return ASAP if there is no need to compute the level. */
    if (!server.maxmemory) {
        if (level) *level = 0;
        return C_OK;
    }
    if (mem_reported <= server.maxmemory && !level) return C_OK;

    /* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */
    mem_used = mem_reported;
    size_t overhead = freeMemoryGetNotCountedMemory();
    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;

    /* Compute the ratio of memory usage. */
    if (level) *level = (float)mem_used / (float)server.maxmemory;

    if (mem_reported <= server.maxmemory) ret...",1,15,evict.c,getMaxmemoryState,,false,397,433,getMaxmemoryState,,,14,"int getMaxmemoryState (size_t*,size_t*,size_t*,float*)"
129716,METHOD,evict.c:<global>,TYPE_DECL,"int overMaxmemoryAfterAlloc(size_t moremem) {
    if (!server.maxmemory) return  0; /* No limit. */

    /* Check quickly. */
    size_t mem_used = zmalloc_used_memory();
    if (mem_used + moremem <= server.maxmemory) return 0;

    size_t overhead = freeMemoryGetNotCountedMemory();
    mem_used = (mem_used > overhead) ? mem_used - overhead : 0;
    return mem_used + moremem > server.maxmemory;
}",1,1,evict.c,overMaxmemoryAfterAlloc,,false,438,448,overMaxmemoryAfterAlloc,,,15,int overMaxmemoryAfterAlloc (size_t)
129770,METHOD,evict.c:<global>,TYPE_DECL,"static int evictionTimeProc(
        struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    if (performEvictions() == EVICT_RUNNING) return 0;  /* keep evicting */

    /* For EVICT_OK - things are good, no need to keep evicting.
     * For EVICT_FAIL - there is nothing left to evict.  */
    isEvictionProcRunning = 0;
    return AE_NOMORE;
}",1,4,evict.c,evictionTimeProc,,false,455,467,evictionTimeProc,,,18,"int evictionTimeProc (aeEventLoop*,long long,void*)"
129812,METHOD,evict.c:<global>,TYPE_DECL,"void startEvictionTimeProc(void) {
    if (!isEvictionProcRunning) {
        isEvictionProcRunning = 1;
        aeCreateTimeEvent(server.el, 0,
                evictionTimeProc, NULL, NULL);
    }
}",1,1,evict.c,startEvictionTimeProc,,false,469,475,startEvictionTimeProc,,,19,void startEvictionTimeProc (void)
129832,METHOD,evict.c:<global>,TYPE_DECL,"static int isSafeToPerformEvictions(void) {
    /* - There must be no script in timeout condition.
     * - Nor we are loading data right now.  */
    if (isInsideYieldingLongCommand() || server.loading) return 0;

    /* By default replicas should ignore maxmemory
     * and just be masters exact copies. */
    if (server.masterhost && server.repl_slave_ignore_maxmemory) return 0;

    /* If 'evict' action is paused, for whatever reason, then return false */
    if (isPausedActionsWithUpdate(PAUSE_ACTION_EVICT)) return 0;

    return 1;
}",1,34,evict.c,isSafeToPerformEvictions,,false,481,494,isSafeToPerformEvictions,,,20,int isSafeToPerformEvictions (void)
129869,METHOD,evict.c:<global>,TYPE_DECL,"static unsigned long evictionTimeLimitUs(void) {
    serverAssert(server.maxmemory_eviction_tenacity >= 0);
    serverAssert(server.maxmemory_eviction_tenacity <= 100);

    if (server.maxmemory_eviction_tenacity <= 10) {
        /* A linear progression from 0..500us */
        return 50uL * server.maxmemory_eviction_tenacity;
    }

    if (server.maxmemory_eviction_tenacity < 100) {
        /* A 15% geometric progression, resulting in a limit of ~2 min at tenacity==99  */
        return (unsigned long)(500.0 * pow(1.15, server.maxmemory_eviction_tenacity - 10.0));
    }

    return ULONG_MAX;   /* No limit to eviction time */
}",1,4,evict.c,evictionTimeLimitUs,,false,497,512,evictionTimeLimitUs,,,21,unsigned long evictionTimeLimitUs (void)
129944,METHOD,evict.c:<global>,TYPE_DECL,"int performEvictions(void) {
    /* Note, we don't goto update_metrics here because this check skips eviction
     * as if it wasn't triggered. it's a fake EVICT_OK. */
    if (!isSafeToPerformEvictions()) return EVICT_OK;

    int keys_freed = 0;
    size_t mem_reported, mem_tofree;
    long long mem_freed; /* May be negative */
    mstime_t latency, eviction_latency;
    long long delta;
    int slaves = listLength(server.slaves);
    int result = EVICT_FAIL;

    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK) {
        result = EVICT_OK;
        goto update_metrics;
    }

    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION) {
        result = EVICT_FAIL;  /* We need to free memory, but policy forbids. */
        goto update_metrics;
    }

    unsigned long eviction_time_limit_us = evictionTimeLimitUs();

    mem_freed = 0;

    latencyStartMonitor(latency);

    monotime evictionTimer;
    elapsedStart(&evictionTimer);

    /* Try to smoke-out bugs (se...",1,44,evict.c,performEvictions,,false,538,755,performEvictions,,,22,int performEvictions (void)
130779,METHOD,expire.c:<global>,TYPE_DECL,<global>,1,1,expire.c,expire.c:<global>,,false,1,752,<global>,,,1,
130781,METHOD,expire.c:<global>,TYPE_DECL,"int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {
    long long t = dictGetSignedIntegerVal(de);
    if (now > t) {
        sds key = dictGetKey(de);
        robj *keyobj = createStringObject(key,sdslen(key));
        deleteExpiredKeyAndPropagate(db,keyobj);
        decrRefCount(keyobj);
        return 1;
    } else {
        return 0;
    }
}",1,1,expire.c,activeExpireCycleTryExpire,,false,54,65,activeExpireCycleTryExpire,,,1,"int activeExpireCycleTryExpire (redisDb*,dictEntry*,long long)"
130829,METHOD,expire.c:<global>,TYPE_DECL,"void expireScanCallback(void *privdata, const dictEntry *const_de) {
    dictEntry *de = (dictEntry *)const_de;
    expireScanData *data = privdata;
    long long ttl  = dictGetSignedIntegerVal(de) - data->now;
    if (activeExpireCycleTryExpire(data->db, de, data->now)) {
        data->expired++;
        /* Propagate the DEL command */
        postExecutionUnitOperations();
    }
    if (ttl > 0) {
        /* We want the average TTL of keys yet not expired. */
        data->ttl_sum += ttl;
        data->ttl_samples++;
    }
    data->sampled++;
}",1,1,expire.c,expireScanCallback,,false,123,138,expireScanCallback,,,4,"void expireScanCallback (void*,dictEntry*)"
130887,METHOD,expire.c:<global>,TYPE_DECL,"void activeExpireCycle(int type) {
    /* Adjust the running parameters according to the configured expire
     * effort. The default effort is 1, and the maximum configurable effort
     * is 10. */
    unsigned long
    effort = server.active_expire_effort-1, /* Rescale from 0 to 9. */
    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +
                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/4*effort,
    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +
                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/4*effort,
    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +
                                  2*effort,
    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-
                                    effort;

    /* This function has some global state in order to continue the work
     * incrementally across calls. */
    static unsigned int current_db = 0; /* Next DB to test. */
    static int timel...",1,27,expire.c,activeExpireCycle,,false,140,322,activeExpireCycle,,,5,void activeExpireCycle (int)
131464,METHOD,expire.c:<global>,TYPE_DECL,"void expireSlaveKeys(void) {
    if (slaveKeysWithExpire == NULL ||
        dictSize(slaveKeysWithExpire) == 0) return;

    int cycles = 0, noexpire = 0;
    mstime_t start = mstime();
    while(1) {
        dictEntry *de = dictGetRandomKey(slaveKeysWithExpire);
        sds keyname = dictGetKey(de);
        uint64_t dbids = dictGetUnsignedIntegerVal(de);
        uint64_t new_dbids = 0;

        /* Check the key against every database corresponding to the
         * bits set in the value bitmap. */
        int dbid = 0;
        while(dbids && dbid < server.dbnum) {
            if ((dbids & 1) != 0) {
                redisDb *db = server.db+dbid;
                dictEntry *expire = dictFind(db->expires,keyname);
                int expired = 0;

                if (expire &&
                    activeExpireCycleTryExpire(server.db+dbid,expire,start))
                {
                    expired = 1;
                    /* Propagate the DEL (writable replicas do not propagate anythin...",1,8,expire.c,expireSlaveKeys,,false,363,421,expireSlaveKeys,,,8,void expireSlaveKeys (void)
131654,METHOD,expire.c:<global>,TYPE_DECL,"void rememberSlaveKeyWithExpire(redisDb *db, robj *key) {
    if (slaveKeysWithExpire == NULL) {
        static dictType dt = {
            dictSdsHash,                /* hash function */
            NULL,                       /* key dup */
            NULL,                       /* val dup */
            dictSdsKeyCompare,          /* key compare */
            dictSdsDestructor,          /* key destructor */
            NULL,                       /* val destructor */
            NULL                        /* allow to expand */
        };
        slaveKeysWithExpire = dictCreate(&dt);
    }
    if (db->id > 63) return;

    dictEntry *de = dictAddOrFind(slaveKeysWithExpire,key->ptr);
    /* If the entry was just created, set it to a copy of the SDS string
     * representing the key: we don't want to need to take those keys
     * in sync with the main DB. The keys will be removed by expireSlaveKeys()
     * as it scans to find keys to remove. */
    if (dictGetKey(de) == key->p...",1,1,expire.c,rememberSlaveKeyWithExpire,,false,425,453,rememberSlaveKeyWithExpire,,,9,"void rememberSlaveKeyWithExpire (redisDb*,robj*)"
131732,METHOD,expire.c:<global>,TYPE_DECL,"size_t getSlaveKeyWithExpireCount(void) {
    if (slaveKeysWithExpire == NULL) return 0;
    return dictSize(slaveKeysWithExpire);
}",1,11,expire.c,getSlaveKeyWithExpireCount,,false,456,459,getSlaveKeyWithExpireCount,,,10,size_t getSlaveKeyWithExpireCount (void)
131759,METHOD,expire.c:<global>,TYPE_DECL,"void flushSlaveKeysWithExpireList(void) {
    if (slaveKeysWithExpire) {
        dictRelease(slaveKeysWithExpire);
        slaveKeysWithExpire = NULL;
    }
}",1,1,expire.c,flushSlaveKeysWithExpireList,,false,469,474,flushSlaveKeysWithExpireList,,,11,void flushSlaveKeysWithExpireList (void)
131772,METHOD,expire.c:<global>,TYPE_DECL,"int checkAlreadyExpired(long long when) {
    /* EXPIRE with negative TTL, or EXPIREAT with a timestamp into the past
     * should never be executed as a DEL when load the AOF or in the context
     * of a slave instance.
     *
     * Instead we add the already expired key to the database with expire time
     * (possibly in the past) and wait for an explicit DEL from the master. */
    return (when <= commandTimeSnapshot() && !server.loading && !server.masterhost);
}",1,1,expire.c,checkAlreadyExpired,,false,476,484,checkAlreadyExpired,,,12,int checkAlreadyExpired (long long)
131791,METHOD,expire.c:<global>,TYPE_DECL,"int parseExtendedExpireArgumentsOrReply(client *c, int *flags) {
    int nx = 0, xx = 0, gt = 0, lt = 0;

    int j = 3;
    while (j < c->argc) {
        char *opt = c->argv[j]->ptr;
        if (!strcasecmp(opt,""nx"")) {
            *flags |= EXPIRE_NX;
            nx = 1;
        } else if (!strcasecmp(opt,""xx"")) {
            *flags |= EXPIRE_XX;
            xx = 1;
        } else if (!strcasecmp(opt,""gt"")) {
            *flags |= EXPIRE_GT;
            gt = 1;
        } else if (!strcasecmp(opt,""lt"")) {
            *flags |= EXPIRE_LT;
            lt = 1;
        } else {
            addReplyErrorFormat(c, ""Unsupported option %s"", opt);
            return C_ERR;
        }
        j++;
    }

    if ((nx && xx) || (nx && gt) || (nx && lt)) {
        addReplyError(c, ""NX and XX, GT or LT options at the same time are not compatible"");
        return C_ERR;
    }

    if (gt && lt) {
        addReplyError(c, ""GT and LT options at the same time are not compatible"");
        return C_E...",1,22,expire.c,parseExtendedExpireArgumentsOrReply,,false,498,534,parseExtendedExpireArgumentsOrReply,,,13,"int parseExtendedExpireArgumentsOrReply (client*,int*)"
131959,METHOD,expire.c:<global>,TYPE_DECL,"void expireGenericCommand(client *c, long long basetime, int unit) {
    robj *key = c->argv[1], *param = c->argv[2];
    long long when; /* unix time in milliseconds when the key will expire. */
    long long current_expire = -1;
    int flag = 0;

    /* checking optional flags */
    if (parseExtendedExpireArgumentsOrReply(c, &flag) != C_OK) {
        return;
    }

    if (getLongLongFromObjectOrReply(c, param, &when, NULL) != C_OK)
        return;

    /* EXPIRE allows negative numbers, but we can at least detect an
     * overflow by either unit conversion or basetime addition. */
    if (unit == UNIT_SECONDS) {
        if (when > LLONG_MAX / 1000 || when < LLONG_MIN / 1000) {
            addReplyErrorExpireTime(c);
            return;
        }
        when *= 1000;
    }

    if (when > LLONG_MAX - basetime) {
        addReplyErrorExpireTime(c);
        return;
    }
    when += basetime;

    /* No key, return zero. */
    if (lookupKeyWrite(c->db,key) == NULL) {
        ad...",1,57,expire.c,expireGenericCommand,,false,549,664,expireGenericCommand,,,14,"void expireGenericCommand (client*,long long,int)"
132333,METHOD,expire.c:<global>,TYPE_DECL,"void expireCommand(client *c) {
    expireGenericCommand(c,commandTimeSnapshot(),UNIT_SECONDS);
}",1,49,expire.c,expireCommand,,false,667,669,expireCommand,,,15,void expireCommand (client*)
132344,METHOD,expire.c:<global>,TYPE_DECL,"void expireatCommand(client *c) {
    expireGenericCommand(c,0,UNIT_SECONDS);
}",1,29,expire.c,expireatCommand,,false,672,674,expireatCommand,,,16,void expireatCommand (client*)
132355,METHOD,expire.c:<global>,TYPE_DECL,"void pexpireCommand(client *c) {
    expireGenericCommand(c,commandTimeSnapshot(),UNIT_MILLISECONDS);
}",1,49,expire.c,pexpireCommand,,false,677,679,pexpireCommand,,,17,void pexpireCommand (client*)
132366,METHOD,expire.c:<global>,TYPE_DECL,"void pexpireatCommand(client *c) {
    expireGenericCommand(c,0,UNIT_MILLISECONDS);
}",1,29,expire.c,pexpireatCommand,,false,682,684,pexpireatCommand,,,18,void pexpireatCommand (client*)
132377,METHOD,expire.c:<global>,TYPE_DECL,"void ttlGenericCommand(client *c, int output_ms, int output_abs) {
    long long expire, ttl = -1;

    /* If the key does not exist at all, return -2 */
    if (lookupKeyReadWithFlags(c->db,c->argv[1],LOOKUP_NOTOUCH) == NULL) {
        addReplyLongLong(c,-2);
        return;
    }

    /* The key exists. Return -1 if it has no expire, or the actual
     * TTL value otherwise. */
    expire = getExpire(c->db,c->argv[1]);
    if (expire != -1) {
        ttl = output_abs ? expire : expire-commandTimeSnapshot();
        if (ttl < 0) ttl = 0;
    }
    if (ttl == -1) {
        addReplyLongLong(c,-1);
    } else {
        addReplyLongLong(c,output_ms ? ttl : ((ttl+500)/1000));
    }
}",1,48,expire.c,ttlGenericCommand,,false,687,708,ttlGenericCommand,,,19,"void ttlGenericCommand (client*,int,int)"
132468,METHOD,expire.c:<global>,TYPE_DECL,"void ttlCommand(client *c) {
    ttlGenericCommand(c, 0, 0);
}",1,1,expire.c,ttlCommand,,false,711,713,ttlCommand,,,20,void ttlCommand (client*)
132477,METHOD,expire.c:<global>,TYPE_DECL,"void pttlCommand(client *c) {
    ttlGenericCommand(c, 1, 0);
}",1,1,expire.c,pttlCommand,,false,716,718,pttlCommand,,,21,void pttlCommand (client*)
132486,METHOD,expire.c:<global>,TYPE_DECL,"void expiretimeCommand(client *c) {
    ttlGenericCommand(c, 0, 1);
}",1,1,expire.c,expiretimeCommand,,false,721,723,expiretimeCommand,,,22,void expiretimeCommand (client*)
132495,METHOD,expire.c:<global>,TYPE_DECL,"void pexpiretimeCommand(client *c) {
    ttlGenericCommand(c, 1, 1);
}",1,1,expire.c,pexpiretimeCommand,,false,726,728,pexpiretimeCommand,,,23,void pexpiretimeCommand (client*)
132504,METHOD,expire.c:<global>,TYPE_DECL,"void persistCommand(client *c) {
    if (lookupKeyWrite(c->db,c->argv[1])) {
        if (removeExpire(c->db,c->argv[1])) {
            signalModifiedKey(c,c->db,c->argv[1]);
            notifyKeyspaceEvent(NOTIFY_GENERIC,""persist"",c->argv[1],c->db->id);
            addReply(c,shared.cone);
            server.dirty++;
        } else {
            addReply(c,shared.czero);
        }
    } else {
        addReply(c,shared.czero);
    }
}",1,32,expire.c,persistCommand,,false,731,744,persistCommand,,,24,void persistCommand (client*)
132581,METHOD,expire.c:<global>,TYPE_DECL,"void touchCommand(client *c) {
    int touched = 0;
    for (int j = 1; j < c->argc; j++)
        if (lookupKeyRead(c->db,c->argv[j]) != NULL) touched++;
    addReplyLongLong(c,touched);
}",1,1,expire.c,touchCommand,,false,747,752,touchCommand,,,25,void touchCommand (client*)
132626,METHOD,fmacros.h:<global>,TYPE_DECL,<global>,1,6,fmacros.h,fmacros.h:<global>,,false,1,76,<global>,,,1,
132641,METHOD,function_lua.c:<global>,TYPE_DECL,<global>,1,1,function_lua.c,function_lua.c:<global>,,false,1,505,<global>,,,1,
132659,METHOD,function_lua.c:<global>,TYPE_DECL,"static void luaEngineLoadHook(lua_State *lua, lua_Debug *ar) {
    UNUSED(ar);
    loadCtx *load_ctx = luaGetFromRegistry(lua, REGISTRY_LOAD_CTX_NAME);
    serverAssert(load_ctx); /* Only supported inside script invocation */
    uint64_t duration = elapsedMs(load_ctx->start_time);
    if (duration > LOAD_TIMEOUT_MS) {
        lua_sethook(lua, luaEngineLoadHook, LUA_MASKLINE, 0);

        luaPushError(lua,""FUNCTION LOAD timeout"");
        luaError(lua);
    }
}",1,4,function_lua.c,luaEngineLoadHook,,false,83,94,luaEngineLoadHook,,,9,"void luaEngineLoadHook (lua_State*,lua_Debug*)"
132718,METHOD,function_lua.c:<global>,TYPE_DECL,"static int luaEngineCreate(void *engine_ctx, functionLibInfo *li, sds blob, sds *err) {
    int ret = C_ERR;
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;

    /* set load library globals */
    lua_getmetatable(lua, LUA_GLOBALSINDEX);
    lua_enablereadonlytable(lua, -1, 0); /* disable global protection */
    lua_getfield(lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);
    lua_setfield(lua, -2, ""__index"");
    lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1); /* enable global protection */
    lua_pop(lua, 1); /* pop the metatable */

    /* compile the code */
    if (luaL_loadbuffer(lua, blob, sdslen(blob), ""@user_function"")) {
        *err = sdscatprintf(sdsempty(), ""Error compiling function: %s"", lua_tostring(lua, -1));
        lua_pop(lua, 1); /* pops the error */
        goto done;
    }
    serverAssert(lua_isfunction(lua, -1));

    loadCtx load_ctx = {
        .li = li,
        .start_time = getMonotonicUs(),
    };
    luaSaveOnRegi...",1,14,function_lua.c,luaEngineCreate,,false,103,155,luaEngineCreate,,,10,"int luaEngineCreate (void*,functionLibInfo*,sds,sds*)"
132909,METHOD,function_lua.c:<global>,TYPE_DECL,"static void luaEngineCall(scriptRunCtx *run_ctx,
                          void *engine_ctx,
                          void *compiled_function,
                          robj **keys,
                          size_t nkeys,
                          robj **args,
                          size_t nargs)
{
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;
    luaFunctionCtx *f_ctx = compiled_function;

    /* Push error handler */
    lua_pushstring(lua, REGISTRY_ERROR_HANDLER_NAME);
    lua_gettable(lua, LUA_REGISTRYINDEX);

    lua_rawgeti(lua, LUA_REGISTRYINDEX, f_ctx->lua_function_ref);

    serverAssert(lua_isfunction(lua, -1));

    luaCallFunction(run_ctx, lua, keys, nkeys, args, nargs, 0);
    lua_pop(lua, 1); /* Pop error handler */
}",1,24,function_lua.c,luaEngineCall,,false,160,182,luaEngineCall,,,11,"void luaEngineCall (scriptRunCtx*,void*,void*,robj**,size_t,robj**,size_t)"
132976,METHOD,function_lua.c:<global>,TYPE_DECL,"static size_t luaEngineGetUsedMemoy(void *engine_ctx) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    return luaMemory(lua_engine_ctx->lua);
}",1,1,function_lua.c,luaEngineGetUsedMemoy,,false,184,187,luaEngineGetUsedMemoy,,,12,size_t luaEngineGetUsedMemoy (void*)
132990,METHOD,function_lua.c:<global>,TYPE_DECL,"static size_t luaEngineFunctionMemoryOverhead(void *compiled_function) {
    return zmalloc_size(compiled_function);
}",1,1,function_lua.c,luaEngineFunctionMemoryOverhead,,false,189,191,luaEngineFunctionMemoryOverhead,,,13,size_t luaEngineFunctionMemoryOverhead (void*)
132998,METHOD,function_lua.c:<global>,TYPE_DECL,"static size_t luaEngineMemoryOverhead(void *engine_ctx) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    return zmalloc_size(lua_engine_ctx);
}",1,1,function_lua.c,luaEngineMemoryOverhead,,false,193,196,luaEngineMemoryOverhead,,,14,size_t luaEngineMemoryOverhead (void*)
133010,METHOD,function_lua.c:<global>,TYPE_DECL,"static void luaEngineFreeFunction(void *engine_ctx, void *compiled_function) {
    luaEngineCtx *lua_engine_ctx = engine_ctx;
    lua_State *lua = lua_engine_ctx->lua;
    luaFunctionCtx *f_ctx = compiled_function;
    lua_unref(lua, f_ctx->lua_function_ref);
    zfree(f_ctx);
}",1,1,function_lua.c,luaEngineFreeFunction,,false,198,204,luaEngineFreeFunction,,,15,"void luaEngineFreeFunction (void*,void*)"
133037,METHOD,function_lua.c:<global>,TYPE_DECL,"static void luaRegisterFunctionArgsInitialize(registerFunctionArgs *register_f_args,
    sds name,
    sds desc,
    luaFunctionCtx *lua_f_ctx,
    uint64_t flags)
{
    *register_f_args = (registerFunctionArgs){
        .name = name,
        .desc = desc,
        .lua_f_ctx = lua_f_ctx,
        .f_flags = flags,
    };
}",1,1,function_lua.c,luaRegisterFunctionArgsInitialize,,false,206,218,luaRegisterFunctionArgsInitialize,,,16,"void luaRegisterFunctionArgsInitialize (registerFunctionArgs*,sds,sds,luaFunctionCtx*,uint64_t)"
133068,METHOD,function_lua.c:<global>,TYPE_DECL,"static void luaRegisterFunctionArgsDispose(lua_State *lua, registerFunctionArgs *register_f_args) {
    sdsfree(register_f_args->name);
    if (register_f_args->desc) sdsfree(register_f_args->desc);
    lua_unref(lua, register_f_args->lua_f_ctx->lua_function_ref);
    zfree(register_f_args->lua_f_ctx);
}",1,1,function_lua.c,luaRegisterFunctionArgsDispose,,false,220,225,luaRegisterFunctionArgsDispose,,,17,"void luaRegisterFunctionArgsDispose (lua_State*,registerFunctionArgs*)"
133098,METHOD,function_lua.c:<global>,TYPE_DECL,"static int luaRegisterFunctionReadFlags(lua_State *lua, uint64_t *flags) {
    int j = 1;
    int ret = C_ERR;
    int f_flags = 0;
    while(1) {
        lua_pushnumber(lua,j++);
        lua_gettable(lua,-2);
        int t = lua_type(lua,-1);
        if (t == LUA_TNIL) {
            lua_pop(lua,1);
            break;
        }
        if (!lua_isstring(lua, -1)) {
            lua_pop(lua,1);
            goto done;
        }

        const char *flag_str = lua_tostring(lua, -1);
        int found = 0;
        for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
            if (!strcasecmp(flag->str, flag_str)) {
                f_flags |= flag->flag;
                found = 1;
                break;
            }
        }
        /* pops the value to continue the iteration */
        lua_pop(lua,1);
        if (!found) {
            /* flag not found */
            goto done;
        }
    }

    *flags = f_flags;
    ret = C_OK;

done:
    return ret;
}",1,14,function_lua.c,luaRegisterFunctionReadFlags,,false,230,269,luaRegisterFunctionReadFlags,,,18,"int luaRegisterFunctionReadFlags (lua_State*,uint64_t*)"
133217,METHOD,function_lua.c:<global>,TYPE_DECL,"static int luaRegisterFunctionReadNamedArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    char *err = NULL;
    sds name = NULL;
    sds desc = NULL;
    luaFunctionCtx *lua_f_ctx = NULL;
    uint64_t flags = 0;
    if (!lua_istable(lua, 1)) {
        err = ""calling redis.register_function with a single argument is only applicable to Lua table (representing named arguments)."";
        goto error;
    }

    /* Iterating on all the named arguments */
    lua_pushnil(lua);
    while (lua_next(lua, -2)) {
        /* Stack now: table, key, value */
        if (!lua_isstring(lua, -2)) {
            err = ""named argument key given to redis.register_function is not a string"";
            goto error;
        }
        const char *key = lua_tostring(lua, -2);
        if (!strcasecmp(key, ""function_name"")) {
            if (!(name = luaGetStringSds(lua, -1))) {
                err = ""function_name argument given to redis.register_function must be a string"";
                goto...",1,61,function_lua.c,luaRegisterFunctionReadNamedArgs,,false,271,351,luaRegisterFunctionReadNamedArgs,,,19,"int luaRegisterFunctionReadNamedArgs (lua_State*,registerFunctionArgs*)"
133453,METHOD,function_lua.c:<global>,TYPE_DECL,"static int luaRegisterFunctionReadPositionalArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    char *err = NULL;
    sds name = NULL;
    sds desc = NULL;
    luaFunctionCtx *lua_f_ctx = NULL;
    if (!(name = luaGetStringSds(lua, 1))) {
        err = ""first argument to redis.register_function must be a string"";
        goto error;
    }

    if (!lua_isfunction(lua, 2)) {
        err = ""second argument to redis.register_function must be a function"";
        goto error;
    }

    int lua_function_ref = luaL_ref(lua, LUA_REGISTRYINDEX);

    lua_f_ctx = zmalloc(sizeof(*lua_f_ctx));
    lua_f_ctx->lua_function_ref = lua_function_ref;

    luaRegisterFunctionArgsInitialize(register_f_args, name, NULL, lua_f_ctx, 0);

    return C_OK;

error:
    if (name) sdsfree(name);
    if (desc) sdsfree(desc);
    luaPushError(lua, err);
    return C_ERR;
}",1,11,function_lua.c,luaRegisterFunctionReadPositionalArgs,,false,353,382,luaRegisterFunctionReadPositionalArgs,,,20,"int luaRegisterFunctionReadPositionalArgs (lua_State*,registerFunctionArgs*)"
133543,METHOD,function_lua.c:<global>,TYPE_DECL,"static int luaRegisterFunctionReadArgs(lua_State *lua, registerFunctionArgs *register_f_args) {
    int argc = lua_gettop(lua);
    if (argc < 1 || argc > 2) {
        luaPushError(lua, ""wrong number of arguments to redis.register_function"");
        return C_ERR;
    }

    if (argc == 1) {
        return luaRegisterFunctionReadNamedArgs(lua, register_f_args);
    } else {
        return luaRegisterFunctionReadPositionalArgs(lua, register_f_args);
    }
}",1,15,function_lua.c,luaRegisterFunctionReadArgs,,false,384,396,luaRegisterFunctionReadArgs,,,21,"int luaRegisterFunctionReadArgs (lua_State*,registerFunctionArgs*)"
133586,METHOD,function_lua.c:<global>,TYPE_DECL,"static int luaRegisterFunction(lua_State *lua) {
    registerFunctionArgs register_f_args = {0};

    loadCtx *load_ctx = luaGetFromRegistry(lua, REGISTRY_LOAD_CTX_NAME);
    if (!load_ctx) {
        luaPushError(lua, ""redis.register_function can only be called on FUNCTION LOAD command"");
        return luaError(lua);
    }

    if (luaRegisterFunctionReadArgs(lua, &register_f_args) != C_OK) {
        return luaError(lua);
    }

    sds err = NULL;
    if (functionLibCreateFunction(register_f_args.name, register_f_args.lua_f_ctx, load_ctx->li, register_f_args.desc, register_f_args.f_flags, &err) != C_OK) {
        luaRegisterFunctionArgsDispose(lua, &register_f_args);
        luaPushError(lua, err);
        sdsfree(err);
        return luaError(lua);
    }

    return 0;
}",1,48,function_lua.c,luaRegisterFunction,,false,398,420,luaRegisterFunction,,,22,int luaRegisterFunction (lua_State*)
133669,METHOD,function_lua.c:<global>,TYPE_DECL,"int luaEngineInitEngine(void) {
    luaEngineCtx *lua_engine_ctx = zmalloc(sizeof(*lua_engine_ctx));
    lua_engine_ctx->lua = lua_open();

    luaRegisterRedisAPI(lua_engine_ctx->lua);

    /* Register the library commands table and fields and store it to registry */
    lua_newtable(lua_engine_ctx->lua); /* load library globals */
    lua_newtable(lua_engine_ctx->lua); /* load library `redis` table */

    lua_pushstring(lua_engine_ctx->lua, ""register_function"");
    lua_pushcfunction(lua_engine_ctx->lua, luaRegisterFunction);
    lua_settable(lua_engine_ctx->lua, -3);

    luaRegisterLogFunction(lua_engine_ctx->lua);
    luaRegisterVersion(lua_engine_ctx->lua);

    luaSetErrorMetatable(lua_engine_ctx->lua);
    lua_setfield(lua_engine_ctx->lua, -2, REDIS_API_NAME);

    luaSetErrorMetatable(lua_engine_ctx->lua);
    luaSetTableProtectionRecursively(lua_engine_ctx->lua); /* protect load library globals */
    lua_setfield(lua_engine_ctx->lua, LUA_REGISTRYINDEX, LIBRARY_API_NAME);...",1,42,function_lua.c,luaEngineInitEngine,,false,423,505,luaEngineInitEngine,,,23,int luaEngineInitEngine (void)
133926,METHOD,functions.c:<global>,TYPE_DECL,<global>,1,1,functions.c,functions.c:<global>,,false,1,1133,<global>,,,1,
133937,METHOD,functions.c:<global>,TYPE_DECL,"static void engineFunctionDispose(dict *d, void *obj);",13,53,functions.c,engineFunctionDispose,,false,43,43,engineFunctionDispose,,,5,"void engineFunctionDispose (dict*,void*)"
133943,METHOD,functions.c:<global>,TYPE_DECL,"static void engineStatsDispose(dict *d, void *obj);",13,50,functions.c,engineStatsDispose,,false,44,44,engineStatsDispose,,,6,"void engineStatsDispose (dict*,void*)"
133949,METHOD,functions.c:<global>,TYPE_DECL,"static void engineLibraryDispose(dict *d, void *obj);",13,52,functions.c,engineLibraryDispose,,false,45,45,engineLibraryDispose,,,7,"void engineLibraryDispose (dict*,void*)"
133955,METHOD,functions.c:<global>,TYPE_DECL,static int functionsVerifyName(sds name);,12,40,functions.c,functionsVerifyName,,false,46,46,functionsVerifyName,,,8,int functionsVerifyName (sds)
134037,METHOD,functions.c:<global>,TYPE_DECL,"static size_t functionMallocSize(functionInfo *fi) {
    return zmalloc_size(fi) + sdsZmallocSize(fi->name)
            + (fi->desc ? sdsZmallocSize(fi->desc) : 0)
            + fi->li->ei->engine->get_function_memory_overhead(fi->function);
}",1,1,functions.c,functionMallocSize,,false,125,129,functionMallocSize,,,28,size_t functionMallocSize (functionInfo*)
134074,METHOD,functions.c:<global>,TYPE_DECL,"static size_t libraryMallocSize(functionLibInfo *li) {
    return zmalloc_size(li) + sdsZmallocSize(li->name)
            + sdsZmallocSize(li->code);
}",1,1,functions.c,libraryMallocSize,,false,131,134,libraryMallocSize,,,29,size_t libraryMallocSize (functionLibInfo*)
134092,METHOD,functions.c:<global>,TYPE_DECL,"static void engineStatsDispose(dict *d, void *obj) {
    UNUSED(d);
    functionsLibEngineStats *stats = obj;
    zfree(stats);
}",1,4,functions.c,engineStatsDispose,,false,136,140,engineStatsDispose,,,30,"void engineStatsDispose (dict*,void*)"
134110,METHOD,functions.c:<global>,TYPE_DECL,"static void engineFunctionDispose(dict *d, void *obj) {
    UNUSED(d);
    if (!obj) {
        return;
    }
    functionInfo *fi = obj;
    sdsfree(fi->name);
    if (fi->desc) {
        sdsfree(fi->desc);
    }
    engine *engine = fi->li->ei->engine;
    engine->free_function(engine->engine_ctx, fi->function);
    zfree(fi);
}",1,4,functions.c,engineFunctionDispose,,false,143,156,engineFunctionDispose,,,31,"void engineFunctionDispose (dict*,void*)"
134166,METHOD,functions.c:<global>,TYPE_DECL,"static void engineLibraryFree(functionLibInfo* li) {
    if (!li) {
        return;
    }
    dictRelease(li->functions);
    sdsfree(li->name);
    sdsfree(li->code);
    zfree(li);
}",1,1,functions.c,engineLibraryFree,,false,158,166,engineLibraryFree,,,32,void engineLibraryFree (functionLibInfo*)
134190,METHOD,functions.c:<global>,TYPE_DECL,"static void engineLibraryDispose(dict *d, void *obj) {
    UNUSED(d);
    engineLibraryFree(obj);
}",1,4,functions.c,engineLibraryDispose,,false,168,171,engineLibraryDispose,,,33,"void engineLibraryDispose (dict*,void*)"
134204,METHOD,functions.c:<global>,TYPE_DECL,"void functionsLibCtxClear(functionsLibCtx *lib_ctx) {
    dictEmpty(lib_ctx->functions, NULL);
    dictEmpty(lib_ctx->libraries, NULL);
    dictIterator *iter = dictGetIterator(lib_ctx->engines_stats);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionsLibEngineStats *stats = dictGetVal(entry);
        stats->n_functions = 0;
        stats->n_lib = 0;
    }
    dictReleaseIterator(iter);
    curr_functions_lib_ctx->cache_memory = 0;
}",1,1,functions.c,functionsLibCtxClear,,false,174,186,functionsLibCtxClear,,,34,void functionsLibCtxClear (functionsLibCtx*)
134258,METHOD,functions.c:<global>,TYPE_DECL,"void functionsLibCtxClearCurrent(int async) {
    if (async) {
        functionsLibCtx *old_l_ctx = curr_functions_lib_ctx;
        curr_functions_lib_ctx = functionsLibCtxCreate();
        freeFunctionsAsync(old_l_ctx);
    } else {
        functionsLibCtxClear(curr_functions_lib_ctx);
    }
}",1,1,functions.c,functionsLibCtxClearCurrent,,false,188,196,functionsLibCtxClearCurrent,,,35,void functionsLibCtxClearCurrent (int)
134279,METHOD,functions.c:<global>,TYPE_DECL,"void functionsLibCtxFree(functionsLibCtx *functions_lib_ctx) {
    functionsLibCtxClear(functions_lib_ctx);
    dictRelease(functions_lib_ctx->functions);
    dictRelease(functions_lib_ctx->libraries);
    dictRelease(functions_lib_ctx->engines_stats);
    zfree(functions_lib_ctx);
}",1,1,functions.c,functionsLibCtxFree,,false,199,205,functionsLibCtxFree,,,36,void functionsLibCtxFree (functionsLibCtx*)
134300,METHOD,functions.c:<global>,TYPE_DECL,"void functionsLibCtxSwapWithCurrent(functionsLibCtx *new_lib_ctx) {
    functionsLibCtxFree(curr_functions_lib_ctx);
    curr_functions_lib_ctx = new_lib_ctx;
}",1,1,functions.c,functionsLibCtxSwapWithCurrent,,false,209,212,functionsLibCtxSwapWithCurrent,,,37,void functionsLibCtxSwapWithCurrent (functionsLibCtx*)
134310,METHOD,functions.c:<global>,TYPE_DECL,"functionsLibCtx* functionsLibCtxGetCurrent(void) {
    return curr_functions_lib_ctx;
}",1,1,functions.c,functionsLibCtxGetCurrent,,false,215,217,functionsLibCtxGetCurrent,,,38,functionsLibCtx functionsLibCtxGetCurrent (void)
134317,METHOD,functions.c:<global>,TYPE_DECL,"functionsLibCtx* functionsLibCtxCreate(void) {
    functionsLibCtx *ret = zmalloc(sizeof(functionsLibCtx));
    ret->libraries = dictCreate(&librariesDictType);
    ret->functions = dictCreate(&functionDictType);
    ret->engines_stats = dictCreate(&engineStatsDictType);
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        engineInfo *ei = dictGetVal(entry);
        functionsLibEngineStats *stats = zcalloc(sizeof(*stats));
        dictAdd(ret->engines_stats, ei->name, stats);
    }
    dictReleaseIterator(iter);
    ret->cache_memory = 0;
    return ret;
}",1,1,functions.c,functionsLibCtxCreate,,false,220,235,functionsLibCtxCreate,,,39,functionsLibCtx functionsLibCtxCreate (void)
134393,METHOD,functions.c:<global>,TYPE_DECL,"int functionLibCreateFunction(sds name, void *function, functionLibInfo *li, sds desc, uint64_t f_flags, sds *err) {
    if (functionsVerifyName(name) != C_OK) {
        *err = sdsnew(""Library names can only contain letters, numbers, or underscores(_) and must be at least one character long"");
        return C_ERR;
    }

    if (dictFetchValue(li->functions, name)) {
        *err = sdsnew(""Function already exists in the library"");
        return C_ERR;
    }

    functionInfo *fi = zmalloc(sizeof(*fi));
    *fi = (functionInfo) {
        .name = name,
        .function = function,
        .li = li,
        .desc = desc,
        .f_flags = f_flags,
    };

    int res = dictAdd(li->functions, fi->name, fi);
    serverAssert(res == DICT_OK);

    return C_OK;
}",1,37,functions.c,functionLibCreateFunction,,false,246,270,functionLibCreateFunction,,,40,"int functionLibCreateFunction (sds,void*,functionLibInfo*,sds,uint64_t,sds*)"
134502,METHOD,functions.c:<global>,TYPE_DECL,"static functionLibInfo* engineLibraryCreate(sds name, engineInfo *ei, sds code) {
    functionLibInfo *li = zmalloc(sizeof(*li));
    *li = (functionLibInfo) {
        .name = sdsdup(name),
        .functions = dictCreate(&libraryFunctionDictType),
        .ei = ei,
        .code = sdsdup(code),
    };
    return li;
}",1,1,functions.c,engineLibraryCreate,,false,272,281,engineLibraryCreate,,,41,"functionLibInfo engineLibraryCreate (sds,engineInfo*,sds)"
134544,METHOD,functions.c:<global>,TYPE_DECL,"static void libraryUnlink(functionsLibCtx *lib_ctx, functionLibInfo* li) {
    dictIterator *iter = dictGetIterator(li->functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionInfo *fi = dictGetVal(entry);
        int ret = dictDelete(lib_ctx->functions, fi->name);
        serverAssert(ret == DICT_OK);
        lib_ctx->cache_memory -= functionMallocSize(fi);
    }
    dictReleaseIterator(iter);
    entry = dictUnlink(lib_ctx->libraries, li->name);
    dictSetVal(lib_ctx->libraries, entry, NULL);
    dictFreeUnlinkedEntry(lib_ctx->libraries, entry);
    lib_ctx->cache_memory -= libraryMallocSize(li);

    /* update stats */
    functionsLibEngineStats *stats = dictFetchValue(lib_ctx->engines_stats, li->ei->name);
    serverAssert(stats);
    stats->n_lib--;
    stats->n_functions -= dictSize(li->functions);
}",1,8,functions.c,libraryUnlink,,false,283,303,libraryUnlink,,,42,"void libraryUnlink (functionsLibCtx*,functionLibInfo*)"
134687,METHOD,functions.c:<global>,TYPE_DECL,"static void libraryLink(functionsLibCtx *lib_ctx, functionLibInfo* li) {
    dictIterator *iter = dictGetIterator(li->functions);
    dictEntry *entry = NULL;
    while ((entry = dictNext(iter))) {
        functionInfo *fi = dictGetVal(entry);
        dictAdd(lib_ctx->functions, fi->name, fi);
        lib_ctx->cache_memory += functionMallocSize(fi);
    }
    dictReleaseIterator(iter);

    dictAdd(lib_ctx->libraries, li->name, li);
    lib_ctx->cache_memory += libraryMallocSize(li);

    /* update stats */
    functionsLibEngineStats *stats = dictFetchValue(lib_ctx->engines_stats, li->ei->name);
    serverAssert(stats);
    stats->n_lib++;
    stats->n_functions += dictSize(li->functions);
}",1,4,functions.c,libraryLink,,false,305,323,libraryLink,,,43,"void libraryLink (functionsLibCtx*,functionLibInfo*)"
134800,METHOD,functions.c:<global>,TYPE_DECL,"static int libraryJoin(functionsLibCtx *functions_lib_ctx_dst, functionsLibCtx *functions_lib_ctx_src, int replace, sds *err) {
    int ret = C_ERR;
    dictIterator *iter = NULL;
    /* Stores the libraries we need to replace in case a revert is required.
     * Only initialized when needed */
    list *old_libraries_list = NULL;
    dictEntry *entry = NULL;
    iter = dictGetIterator(functions_lib_ctx_src->libraries);
    while ((entry = dictNext(iter))) {
        functionLibInfo *li = dictGetVal(entry);
        functionLibInfo *old_li = dictFetchValue(functions_lib_ctx_dst->libraries, li->name);
        if (old_li) {
            if (!replace) {
                /* library already exists, failed the restore. */
                *err = sdscatfmt(sdsempty(), ""Library %s already exists"", li->name);
                goto done;
            } else {
                if (!old_libraries_list) {
                    old_libraries_list = listCreate();
                    listSetFreeMethod(old_li...",1,14,functions.c,libraryJoin,,false,331,403,libraryJoin,,,44,"int libraryJoin (functionsLibCtx*,functionsLibCtx*,int,sds*)"
135043,METHOD,functions.c:<global>,TYPE_DECL,"int functionsRegisterEngine(const char *engine_name, engine *engine) {
    sds engine_name_sds = sdsnew(engine_name);
    if (dictFetchValue(engines, engine_name_sds)) {
        serverLog(LL_WARNING, ""Same engine was registered twice"");
        sdsfree(engine_name_sds);
        return C_ERR;
    }

    client *c = createClient(NULL);
    c->flags |= (CLIENT_DENY_BLOCKING | CLIENT_SCRIPT);
    engineInfo *ei = zmalloc(sizeof(*ei));
    *ei = (engineInfo ) { .name = engine_name_sds, .engine = engine, .c = c,};

    dictAdd(engines, engine_name_sds, ei);

    engine_cache_memory += zmalloc_size(ei) + sdsZmallocSize(ei->name) +
            zmalloc_size(engine) +
            engine->get_engine_memory_overhead(engine->engine_ctx);

    return C_OK;
}",1,8,functions.c,functionsRegisterEngine,,false,409,429,functionsRegisterEngine,,,45,"int functionsRegisterEngine (char*,engine*)"
135157,METHOD,functions.c:<global>,TYPE_DECL,"void functionStatsCommand(client *c) {
    if (scriptIsRunning() && scriptIsEval()) {
        addReplyErrorObject(c, shared.slowevalerr);
        return;
    }

    addReplyMapLen(c, 2);

    addReplyBulkCString(c, ""running_script"");
    if (!scriptIsRunning()) {
        addReplyNull(c);
    } else {
        addReplyMapLen(c, 3);
        addReplyBulkCString(c, ""name"");
        addReplyBulkCString(c, scriptCurrFunction());
        addReplyBulkCString(c, ""command"");
        client *script_client = scriptGetCaller();
        addReplyArrayLen(c, script_client->argc);
        for (int i = 0 ; i < script_client->argc ; ++i) {
            addReplyBulkCBuffer(c, script_client->argv[i]->ptr, sdslen(script_client->argv[i]->ptr));
        }
        addReplyBulkCString(c, ""duration_ms"");
        addReplyLongLong(c, scriptRunDuration());
    }

    addReplyBulkCString(c, ""engines"");
    addReplyMapLen(c, dictSize(engines));
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry ...",1,22,functions.c,functionStatsCommand,,false,434,474,functionStatsCommand,,,46,void functionStatsCommand (client*)
135320,METHOD,functions.c:<global>,TYPE_DECL,"static void functionListReplyFlags(client *c, functionInfo *fi) {
    /* First count the number of flags we have */
    int flagcount = 0;
    for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
        if (fi->f_flags & flag->flag) {
            ++flagcount;
        }
    }

    addReplySetLen(c, flagcount);

    for (scriptFlag *flag = scripts_flags_def; flag->str ; ++flag) {
        if (fi->f_flags & flag->flag) {
            addReplyStatus(c, flag->str);
        }
    }
}",1,1,functions.c,functionListReplyFlags,,false,476,492,functionListReplyFlags,,,47,"void functionListReplyFlags (client*,functionInfo*)"
135382,METHOD,functions.c:<global>,TYPE_DECL,"void functionListCommand(client *c) {
    int with_code = 0;
    sds library_name = NULL;
    for (int i = 2 ; i < c->argc ; ++i) {
        robj *next_arg = c->argv[i];
        if (!with_code && !strcasecmp(next_arg->ptr, ""withcode"")) {
            with_code = 1;
            continue;
        }
        if (!library_name && !strcasecmp(next_arg->ptr, ""libraryname"")) {
            if (i >= c->argc - 1) {
                addReplyError(c, ""library name argument was not given"");
                return;
            }
            library_name = c->argv[++i]->ptr;
            continue;
        }
        addReplyErrorSds(c, sdscatfmt(sdsempty(), ""Unknown argument %s"", next_arg->ptr));
        return;
    }
    size_t reply_len = 0;
    void *len_ptr = NULL;
    if (library_name) {
        len_ptr = addReplyDeferredLen(c);
    } else {
        /* If no pattern is asked we know the reply len and we can just set it */
        addReplyArrayLen(c, dictSize(curr_functions_lib_ctx->libraries));
   ...",1,28,functions.c,functionListCommand,,false,508,581,functionListCommand,,,48,void functionListCommand (client*)
135707,METHOD,functions.c:<global>,TYPE_DECL,"void functionDeleteCommand(client *c) {
    robj *function_name = c->argv[2];
    functionLibInfo *li = dictFetchValue(curr_functions_lib_ctx->libraries, function_name->ptr);
    if (!li) {
        addReplyError(c, ""Library not found"");
        return;
    }

    libraryUnlink(curr_functions_lib_ctx, li);
    engineLibraryFree(li);
    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReply(c, shared.ok);
}",1,1,functions.c,functionDeleteCommand,,false,586,600,functionDeleteCommand,,,49,void functionDeleteCommand (client*)
135752,METHOD,functions.c:<global>,TYPE_DECL,"void functionKillCommand(client *c) {
    scriptKill(c, 0);
}",1,1,functions.c,functionKillCommand,,false,603,605,functionKillCommand,,,50,void functionKillCommand (client*)
135760,METHOD,functions.c:<global>,TYPE_DECL,"uint64_t fcallGetCommandFlags(client *c, uint64_t cmd_flags) {
    robj *function_name = c->argv[1];
    c->cur_script = dictFind(curr_functions_lib_ctx->functions, function_name->ptr);
    if (!c->cur_script)
        return cmd_flags;
    functionInfo *fi = dictGetVal(c->cur_script);
    uint64_t script_flags = fi->f_flags;
    return scriptFlagsToCmdFlags(cmd_flags, script_flags);
}",1,1,functions.c,fcallGetCommandFlags,,false,609,617,fcallGetCommandFlags,,,51,"uint64_t fcallGetCommandFlags (client*,uint64_t)"
135810,METHOD,functions.c:<global>,TYPE_DECL,"static void fcallCommandGeneric(client *c, int ro) {
    /* Functions need to be fed to monitors before the commands they execute. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);

    robj *function_name = c->argv[1];
    dictEntry *de = c->cur_script;
    if (!de)
        de = dictFind(curr_functions_lib_ctx->functions, function_name->ptr);
    if (!de) {
        addReplyError(c, ""Function not found"");
        return;
    }
    functionInfo *fi = dictGetVal(de);
    engine *engine = fi->li->ei->engine;

    long long numkeys;
    /* Get the number of arguments that are keys */
    if (getLongLongFromObject(c->argv[2], &numkeys) != C_OK) {
        addReplyError(c, ""Bad number of keys provided"");
        return;
    }
    if (numkeys > (c->argc - 3)) {
        addReplyError(c, ""Number of keys can't be greater than number of args"");
        return;
    } else if (numkeys < 0) {
        addReplyError(c, ""Number of keys can't be negative"");
        return;
 ...",1,55,functions.c,fcallCommandGeneric,,false,619,656,fcallCommandGeneric,,,52,"void fcallCommandGeneric (client*,int)"
135986,METHOD,functions.c:<global>,TYPE_DECL,"void fcallCommand(client *c) {
    fcallCommandGeneric(c, 0);
}",1,1,functions.c,fcallCommand,,false,661,663,fcallCommand,,,53,void fcallCommand (client*)
135994,METHOD,functions.c:<global>,TYPE_DECL,"void fcallroCommand(client *c) {
    fcallCommandGeneric(c, 1);
}",1,1,functions.c,fcallroCommand,,false,668,670,fcallroCommand,,,54,void fcallroCommand (client*)
136002,METHOD,functions.c:<global>,TYPE_DECL,"void functionDumpCommand(client *c) {
    unsigned char buf[2];
    uint64_t crc;
    rio payload;
    rioInitWithBuffer(&payload, sdsempty());

    rdbSaveFunctions(&payload);

    /* RDB version */
    buf[0] = RDB_VERSION & 0xff;
    buf[1] = (RDB_VERSION >> 8) & 0xff;
    payload.io.buffer.ptr = sdscatlen(payload.io.buffer.ptr, buf, 2);

    /* CRC64 */
    crc = crc64(0, (unsigned char*) payload.io.buffer.ptr,
                sdslen(payload.io.buffer.ptr));
    memrev64ifbe(&crc);
    payload.io.buffer.ptr = sdscatlen(payload.io.buffer.ptr, &crc, 8);

    addReplyBulkSds(c, payload.io.buffer.ptr);
}",1,13,functions.c,functionDumpCommand,,false,690,710,functionDumpCommand,,,55,void functionDumpCommand (client*)
136111,METHOD,functions.c:<global>,TYPE_DECL,"void functionRestoreCommand(client *c) {
    if (c->argc > 4) {
        addReplySubcommandSyntaxError(c);
        return;
    }

    restorePolicy restore_replicy = restorePolicy_Append; /* default policy: APPEND */
    sds data = c->argv[2]->ptr;
    size_t data_len = sdslen(data);
    rio payload;
    sds err = NULL;

    if (c->argc == 4) {
        const char *restore_policy_str = c->argv[3]->ptr;
        if (!strcasecmp(restore_policy_str, ""append"")) {
            restore_replicy = restorePolicy_Append;
        } else if (!strcasecmp(restore_policy_str, ""replace"")) {
            restore_replicy = restorePolicy_Replace;
        } else if (!strcasecmp(restore_policy_str, ""flush"")) {
            restore_replicy = restorePolicy_Flush;
        } else {
            addReplyError(c, ""Wrong restore policy given, value should be either FLUSH, APPEND or REPLACE."");
            return;
        }
    }

    uint16_t rdbver;
    if (verifyDumpPayload((unsigned char*)data, data_len, &rdbver) ...",1,70,functions.c,functionRestoreCommand,,false,722,802,functionRestoreCommand,,,56,void functionRestoreCommand (client*)
136358,METHOD,functions.c:<global>,TYPE_DECL,"void functionFlushCommand(client *c) {
    if (c->argc > 3) {
        addReplySubcommandSyntaxError(c);
        return;
    }
    int async = 0;
    if (c->argc == 3 && !strcasecmp(c->argv[2]->ptr,""sync"")) {
        async = 0;
    } else if (c->argc == 3 && !strcasecmp(c->argv[2]->ptr,""async"")) {
        async = 1;
    } else if (c->argc == 2) {
        async = server.lazyfree_lazy_user_flush ? 1 : 0;
    } else {
        addReplyError(c,""FUNCTION FLUSH only supports SYNC|ASYNC option"");
        return;
    }

    functionsLibCtxClearCurrent(async);

    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReply(c,shared.ok);
}",1,1,functions.c,functionFlushCommand,,false,805,828,functionFlushCommand,,,57,void functionFlushCommand (client*)
136455,METHOD,functions.c:<global>,TYPE_DECL,"void functionHelpCommand(client *c) {
    const char *help[] = {
""LOAD [REPLACE] <FUNCTION CODE>"",
""    Create a new library with the given library name and code."",
""DELETE <LIBRARY NAME>"",
""    Delete the given library."",
""LIST [LIBRARYNAME PATTERN] [WITHCODE]"",
""    Return general information on all the libraries:"",
""    * Library name"",
""    * The engine used to run the Library"",
""    * Library description"",
""    * Functions list"",
""    * Library code (if WITHCODE is given)"",
""    It also possible to get only function that matches a pattern using LIBRARYNAME argument."",
""STATS"",
""    Return information about the current function running:"",
""    * Function name"",
""    * Command used to run the function"",
""    * Duration in MS that the function is running"",
""    If no function is running, return nil"",
""    In addition, returns a list of available engines."",
""KILL"",
""    Kill the current running function."",
""FLUSH [ASYNC|SYNC]"",
""    Delete all the libraries."",
""    When called with...",1,1,functions.c,functionHelpCommand,,false,831,872,functionHelpCommand,,,58,void functionHelpCommand (client*)
136505,METHOD,functions.c:<global>,TYPE_DECL,"static int functionsVerifyName(sds name) {
    if (sdslen(name) == 0) {
        return C_ERR;
    }
    for (size_t i = 0 ; i < sdslen(name) ; ++i) {
        char curr_char = name[i];
        if ((curr_char >= 'a' && curr_char <= 'z') ||
            (curr_char >= 'A' && curr_char <= 'Z') ||
            (curr_char >= '0' && curr_char <= '9') ||
            (curr_char == '_'))
        {
            continue;
        }
        return C_ERR;
    }
    return C_OK;
}",1,15,functions.c,functionsVerifyName,,false,875,891,functionsVerifyName,,,59,int functionsVerifyName (sds)
136579,METHOD,functions.c:<global>,TYPE_DECL,"int functionExtractLibMetaData(sds payload, functionsLibMataData *md, sds *err) {
    sds name = NULL;
    sds desc = NULL;
    sds engine = NULL;
    sds code = NULL;
    if (strncmp(payload, ""#!"", 2) != 0) {
        *err = sdsnew(""Missing library metadata"");
        return C_ERR;
    }
    char *shebang_end = strchr(payload, '\n');
    if (shebang_end == NULL) {
        *err = sdsnew(""Invalid library metadata"");
        return C_ERR;
    }
    size_t shebang_len = shebang_end - payload;
    sds shebang = sdsnewlen(payload, shebang_len);
    int numparts;
    sds *parts = sdssplitargs(shebang, &numparts);
    sdsfree(shebang);
    if (!parts || numparts == 0) {
        *err = sdsnew(""Invalid library metadata"");
        sdsfreesplitres(parts, numparts);
        return C_ERR;
    }
    engine = sdsdup(parts[0]);
    sdsrange(engine, 2, -1);
    for (int i = 1 ; i < numparts ; ++i) {
        sds part = parts[i];
        if (strncasecmp(part, ""name="", 5) == 0) {
            if (name) {...",1,15,functions.c,functionExtractLibMetaData,,false,893,954,functionExtractLibMetaData,,,60,"int functionExtractLibMetaData (sds,functionsLibMataData*,sds*)"
136815,METHOD,functions.c:<global>,TYPE_DECL,"void functionFreeLibMetaData(functionsLibMataData *md) {
    if (md->code) sdsfree(md->code);
    if (md->name) sdsfree(md->name);
    if (md->engine) sdsfree(md->engine);
}",1,1,functions.c,functionFreeLibMetaData,,false,956,960,functionFreeLibMetaData,,,61,void functionFreeLibMetaData (functionsLibMataData*)
136847,METHOD,functions.c:<global>,TYPE_DECL,"sds functionsCreateWithLibraryCtx(sds code, int replace, sds* err, functionsLibCtx *lib_ctx) {
    dictIterator *iter = NULL;
    dictEntry *entry = NULL;
    functionLibInfo *new_li = NULL;
    functionLibInfo *old_li = NULL;
    functionsLibMataData md = {0};
    if (functionExtractLibMetaData(code, &md, err) != C_OK) {
        return NULL;
    }

    if (functionsVerifyName(md.name)) {
        *err = sdsnew(""Library names can only contain letters, numbers, or underscores(_) and must be at least one character long"");
        goto error;
    }

    engineInfo *ei = dictFetchValue(engines, md.engine);
    if (!ei) {
        *err = sdscatfmt(sdsempty(), ""Engine '%S' not found"", md.engine);
        goto error;
    }
    engine *engine = ei->engine;

    old_li = dictFetchValue(lib_ctx->libraries, md.name);
    if (old_li && !replace) {
        old_li = NULL;
        *err = sdscatfmt(sdsempty(), ""Library '%S' already exists"", md.name);
        goto error;
    }

    if (old_li) {
     ...",1,54,functions.c,functionsCreateWithLibraryCtx,,false,964,1038,functionsCreateWithLibraryCtx,,,62,"sds functionsCreateWithLibraryCtx (sds,int,sds*,functionsLibCtx*)"
137107,METHOD,functions.c:<global>,TYPE_DECL,"void functionLoadCommand(client *c) {
    int replace = 0;
    int argc_pos = 2;
    while (argc_pos < c->argc - 1) {
        robj *next_arg = c->argv[argc_pos++];
        if (!strcasecmp(next_arg->ptr, ""replace"")) {
            replace = 1;
            continue;
        }
        addReplyErrorFormat(c, ""Unknown option given: %s"", (char*)next_arg->ptr);
        return;
    }

    if (argc_pos >= c->argc) {
        addReplyError(c, ""Function code is missing"");
        return;
    }

    robj *code = c->argv[argc_pos];
    sds err = NULL;
    sds library_name = NULL;
    if (!(library_name = functionsCreateWithLibraryCtx(code->ptr, replace, &err, curr_functions_lib_ctx)))
    {
        addReplyErrorSds(c, err);
        return;
    }
    /* Indicate that the command changed the data so it will be replicated and
     * counted as a data change (for persistence configuration) */
    server.dirty++;
    addReplyBulkSds(c, library_name);
}",1,1,functions.c,functionLoadCommand,,false,1045,1075,functionLoadCommand,,,63,void functionLoadCommand (client*)
137210,METHOD,functions.c:<global>,TYPE_DECL,"unsigned long functionsMemory(void) {
    dictIterator *iter = dictGetIterator(engines);
    dictEntry *entry = NULL;
    size_t engines_nemory = 0;
    while ((entry = dictNext(iter))) {
        engineInfo *ei = dictGetVal(entry);
        engine *engine = ei->engine;
        engines_nemory += engine->get_used_memory(engine->engine_ctx);
    }
    dictReleaseIterator(iter);

    return engines_nemory;
}",1,1,functions.c,functionsMemory,,false,1078,1090,functionsMemory,,,64,unsigned long functionsMemory (void)
137258,METHOD,functions.c:<global>,TYPE_DECL,"unsigned long functionsMemoryOverhead(void) {
    size_t memory_overhead = dictMemUsage(engines);
    memory_overhead += dictMemUsage(curr_functions_lib_ctx->functions);
    memory_overhead += sizeof(functionsLibCtx);
    memory_overhead += curr_functions_lib_ctx->cache_memory;
    memory_overhead += engine_cache_memory;

    return memory_overhead;
}",1,1,functions.c,functionsMemoryOverhead,,false,1093,1101,functionsMemoryOverhead,,,65,unsigned long functionsMemoryOverhead (void)
137288,METHOD,functions.c:<global>,TYPE_DECL,"unsigned long functionsNum(void) {
    return dictSize(curr_functions_lib_ctx->functions);
}",1,11,functions.c,functionsNum,,false,1104,1106,functionsNum,,,66,unsigned long functionsNum (void)
137314,METHOD,functions.c:<global>,TYPE_DECL,"unsigned long functionsLibNum(void) {
    return dictSize(curr_functions_lib_ctx->libraries);
}",1,11,functions.c,functionsLibNum,,false,1108,1110,functionsLibNum,,,67,unsigned long functionsLibNum (void)
137340,METHOD,functions.c:<global>,TYPE_DECL,"dict* functionsLibGet(void) {
    return curr_functions_lib_ctx->libraries;
}",1,1,functions.c,functionsLibGet,,false,1112,1114,functionsLibGet,,,68,dict functionsLibGet (void)
137349,METHOD,functions.c:<global>,TYPE_DECL,"size_t functionsLibCtxfunctionsLen(functionsLibCtx *functions_ctx) {
    return dictSize(functions_ctx->functions);
}",1,11,functions.c,functionsLibCtxfunctionsLen,,false,1116,1118,functionsLibCtxfunctionsLen,,,69,size_t functionsLibCtxfunctionsLen (functionsLibCtx*)
137375,METHOD,functions.c:<global>,TYPE_DECL,"int functionsInit(void) {
    engines = dictCreate(&engineDictType);

    if (luaEngineInitEngine() != C_OK) {
        return C_ERR;
    }

    /* Must be initialized after engines initialization */
    curr_functions_lib_ctx = functionsLibCtxCreate();

    return C_OK;
}",1,33,functions.c,functionsInit,,false,1122,1133,functionsInit,,,70,int functionsInit (void)
137413,METHOD,functions.h:<global>,TYPE_DECL,<global>,1,1,functions.h,functions.h:<global>,,false,1,131,<global>,,,1,
137419,METHOD,engine,TYPE_DECL,"int (*create)(void *engine_ctx, functionLibInfo *li, sds code, sds *err);",9,76,functions.h,engine.create,,false,58,58,create,,,2,"int engine.create (void*,functionLibInfo*,sds,sds*)"
137427,METHOD,engine,TYPE_DECL,"void (*call)(scriptRunCtx *r_ctx, void *engine_ctx, void *compiled_function,
            robj **keys, size_t nkeys, robj **args, size_t nargs);",10,65,functions.h,engine.call,,false,65,66,call,,,3,"void engine.call (scriptRunCtx*,void*,void*,robj**,size_t,robj**,size_t)"
137438,METHOD,engine,TYPE_DECL,size_t (*get_used_memory)(void *engine_ctx);,12,47,functions.h,engine.get_used_memory,,false,69,69,get_used_memory,,,4,size_t engine.get_used_memory (void*)
137443,METHOD,engine,TYPE_DECL,size_t (*get_function_memory_overhead)(void *compiled_function);,12,67,functions.h,engine.get_function_memory_overhead,,false,74,74,get_function_memory_overhead,,,5,size_t engine.get_function_memory_overhead (void*)
137448,METHOD,engine,TYPE_DECL,size_t (*get_engine_memory_overhead)(void *engine_ctx);,12,58,functions.h,engine.get_engine_memory_overhead,,false,77,77,get_engine_memory_overhead,,,6,size_t engine.get_engine_memory_overhead (void*)
137453,METHOD,engine,TYPE_DECL,"void (*free_function)(void *engine_ctx, void *compiled_function);",10,68,functions.h,engine.free_function,,false,80,80,free_function,,,7,"void engine.free_function (void*,void*)"
137477,METHOD,functions.h:<global>,TYPE_DECL,"int functionsRegisterEngine(const char *engine_name, engine *engine_ctx);",5,72,functions.h,functionsRegisterEngine,,false,111,111,functionsRegisterEngine,,,10,"int functionsRegisterEngine (char*,engine*)"
137483,METHOD,functions.h:<global>,TYPE_DECL,"sds functionsCreateWithLibraryCtx(sds code, int replace, sds* err, functionsLibCtx *lib_ctx);",5,92,functions.h,functionsCreateWithLibraryCtx,,false,112,112,functionsCreateWithLibraryCtx,,,11,"sds functionsCreateWithLibraryCtx (sds,int,sds*,functionsLibCtx*)"
137491,METHOD,functions.h:<global>,TYPE_DECL,unsigned long functionsMemory(void);,15,35,functions.h,functionsMemory,,false,113,113,functionsMemory,,,12,long unsigned functionsMemory (void)
137496,METHOD,functions.h:<global>,TYPE_DECL,unsigned long functionsMemoryOverhead(void);,15,43,functions.h,functionsMemoryOverhead,,false,114,114,functionsMemoryOverhead,,,13,long unsigned functionsMemoryOverhead (void)
137501,METHOD,functions.h:<global>,TYPE_DECL,unsigned long functionsNum(void);,15,32,functions.h,functionsNum,,false,115,115,functionsNum,,,14,long unsigned functionsNum (void)
137506,METHOD,functions.h:<global>,TYPE_DECL,unsigned long functionsLibNum(void);,15,35,functions.h,functionsLibNum,,false,116,116,functionsLibNum,,,15,long unsigned functionsLibNum (void)
137511,METHOD,functions.h:<global>,TYPE_DECL,dict* functionsLibGet(void);,5,27,functions.h,functionsLibGet,,false,117,117,functionsLibGet,,,16,dict* functionsLibGet (void)
137516,METHOD,functions.h:<global>,TYPE_DECL,size_t functionsLibCtxfunctionsLen(functionsLibCtx *functions_ctx);,8,66,functions.h,functionsLibCtxfunctionsLen,,false,118,118,functionsLibCtxfunctionsLen,,,17,size_t functionsLibCtxfunctionsLen (functionsLibCtx*)
137521,METHOD,functions.h:<global>,TYPE_DECL,functionsLibCtx* functionsLibCtxGetCurrent(void);,16,48,functions.h,functionsLibCtxGetCurrent,,false,119,119,functionsLibCtxGetCurrent,,,18,functionsLibCtx* functionsLibCtxGetCurrent (void)
137526,METHOD,functions.h:<global>,TYPE_DECL,functionsLibCtx* functionsLibCtxCreate(void);,16,44,functions.h,functionsLibCtxCreate,,false,120,120,functionsLibCtxCreate,,,19,functionsLibCtx* functionsLibCtxCreate (void)
137531,METHOD,functions.h:<global>,TYPE_DECL,void functionsLibCtxClearCurrent(int async);,6,43,functions.h,functionsLibCtxClearCurrent,,false,121,121,functionsLibCtxClearCurrent,,,20,void functionsLibCtxClearCurrent (int)
137536,METHOD,functions.h:<global>,TYPE_DECL,void functionsLibCtxFree(functionsLibCtx *lib_ctx);,6,50,functions.h,functionsLibCtxFree,,false,122,122,functionsLibCtxFree,,,21,void functionsLibCtxFree (functionsLibCtx*)
137541,METHOD,functions.h:<global>,TYPE_DECL,void functionsLibCtxClear(functionsLibCtx *lib_ctx);,6,51,functions.h,functionsLibCtxClear,,false,123,123,functionsLibCtxClear,,,22,void functionsLibCtxClear (functionsLibCtx*)
137546,METHOD,functions.h:<global>,TYPE_DECL,void functionsLibCtxSwapWithCurrent(functionsLibCtx *lib_ctx);,6,61,functions.h,functionsLibCtxSwapWithCurrent,,false,124,124,functionsLibCtxSwapWithCurrent,,,23,void functionsLibCtxSwapWithCurrent (functionsLibCtx*)
137551,METHOD,functions.h:<global>,TYPE_DECL,"int functionLibCreateFunction(sds name, void *function, functionLibInfo *li, sds desc, uint64_t f_flags, sds *err);",5,114,functions.h,functionLibCreateFunction,,false,126,126,functionLibCreateFunction,,,24,"int functionLibCreateFunction (sds,void*,functionLibInfo*,sds,uint64_t,sds*)"
137561,METHOD,functions.h:<global>,TYPE_DECL,int luaEngineInitEngine(void);,5,29,functions.h,luaEngineInitEngine,,false,128,128,luaEngineInitEngine,,,25,int luaEngineInitEngine (void)
137566,METHOD,functions.h:<global>,TYPE_DECL,int functionsInit(void);,5,23,functions.h,functionsInit,,false,129,129,functionsInit,,,26,int functionsInit (void)
137582,METHOD,geo.c:<global>,TYPE_DECL,<global>,1,1,geo.c,geo.c:<global>,,false,1,1005,<global>,,,1,
137584,METHOD,geo.c:<global>,TYPE_DECL,"unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);",15,68,geo.c,zzlFirstInRange,,false,38,38,zzlFirstInRange,,,1,"unsigned char* zzlFirstInRange (unsigned char*,zrangespec*)"
137590,METHOD,geo.c:<global>,TYPE_DECL,"int zslValueLteMax(double value, zrangespec *spec);",5,50,geo.c,zslValueLteMax,,false,39,39,zslValueLteMax,,,2,"int zslValueLteMax (double,zrangespec*)"
137596,METHOD,geo.c:<global>,TYPE_DECL,"geoArray *geoArrayCreate(void) {
    geoArray *ga = zmalloc(sizeof(*ga));
    /* It gets allocated on first geoArrayAppend() call. */
    ga->array = NULL;
    ga->buckets = 0;
    ga->used = 0;
    return ga;
}",1,1,geo.c,geoArrayCreate,,false,54,61,geoArrayCreate,,,3,geoArray geoArrayCreate (void)
137625,METHOD,geo.c:<global>,TYPE_DECL,"geoPoint *geoArrayAppend(geoArray *ga, double *xy, double dist,
                         double score, char *member)
{
    if (ga->used == ga->buckets) {
        ga->buckets = (ga->buckets == 0) ? 8 : ga->buckets*2;
        ga->array = zrealloc(ga->array,sizeof(geoPoint)*ga->buckets);
    }
    geoPoint *gp = ga->array+ga->used;
    gp->longitude = xy[0];
    gp->latitude = xy[1];
    gp->dist = dist;
    gp->member = member;
    gp->score = score;
    ga->used++;
    return gp;
}",1,1,geo.c,geoArrayAppend,,false,64,79,geoArrayAppend,,,4,"geoPoint geoArrayAppend (geoArray*,double*,double,double,char*)"
137718,METHOD,geo.c:<global>,TYPE_DECL,"void geoArrayFree(geoArray *ga) {
    size_t i;
    for (i = 0; i < ga->used; i++) sdsfree(ga->array[i].member);
    zfree(ga->array);
    zfree(ga);
}",1,1,geo.c,geoArrayFree,,false,82,87,geoArrayFree,,,5,void geoArrayFree (geoArray*)
137750,METHOD,geo.c:<global>,TYPE_DECL,"int decodeGeohash(double bits, double *xy) {
    GeoHashBits hash = { .bits = (uint64_t)bits, .step = GEO_STEP_MAX };
    return geohashDecodeToLongLatWGS84(hash, xy);
}",1,57,geo.c,decodeGeohash,,false,92,95,decodeGeohash,,,6,"int decodeGeohash (double,double*)"
137776,METHOD,geo.c:<global>,TYPE_DECL,"int extractLongLatOrReply(client *c, robj **argv, double *xy) {
    int i;
    for (i = 0; i < 2; i++) {
        if (getDoubleFromObjectOrReply(c, argv[i], xy + i, NULL) !=
            C_OK) {
            return C_ERR;
        }
    }
    if (xy[0] < GEO_LONG_MIN || xy[0] > GEO_LONG_MAX ||
        xy[1] < GEO_LAT_MIN  || xy[1] > GEO_LAT_MAX) {
        addReplyErrorFormat(c,
            ""-ERR invalid longitude,latitude pair %f,%f\r\n"",xy[0],xy[1]);
        return C_ERR;
    }
    return C_OK;
}",1,12,geo.c,extractLongLatOrReply,,false,100,115,extractLongLatOrReply,,,7,"int extractLongLatOrReply (client*,robj**,double*)"
137868,METHOD,geo.c:<global>,TYPE_DECL,"int longLatFromMember(robj *zobj, robj *member, double *xy) {
    double score = 0;

    if (zsetScore(zobj, member->ptr, &score) == C_ERR) return C_ERR;
    if (!decodeGeohash(score, xy)) return C_ERR;
    return C_OK;
}",1,48,geo.c,longLatFromMember,,false,120,126,longLatFromMember,,,8,"int longLatFromMember (robj*,robj*,double*)"
137913,METHOD,geo.c:<global>,TYPE_DECL,"double extractUnitOrReply(client *c, robj *unit) {
    char *u = unit->ptr;

    if (!strcasecmp(u, ""m"")) {
        return 1;
    } else if (!strcasecmp(u, ""km"")) {
        return 1000;
    } else if (!strcasecmp(u, ""ft"")) {
        return 0.3048;
    } else if (!strcasecmp(u, ""mi"")) {
        return 1609.34;
    } else {
        addReplyError(c,
            ""unsupported unit provided. please use M, KM, FT, MI"");
        return -1;
    }
}",1,1,geo.c,extractUnitOrReply,,false,134,150,extractUnitOrReply,,,9,"double extractUnitOrReply (client*,robj*)"
137971,METHOD,geo.c:<global>,TYPE_DECL,"int extractDistanceOrReply(client *c, robj **argv,
                              double *conversion, double *radius) {
    double distance;
    if (getDoubleFromObjectOrReply(c, argv[0], &distance,
                                   ""need numeric radius"") != C_OK) {
        return C_ERR;
    }

    if (distance < 0) {
        addReplyError(c,""radius cannot be negative"");
        return C_ERR;
    }
    if (radius) *radius = distance;

    double to_meters = extractUnitOrReply(c,argv[1]);
    if (to_meters < 0) {
        return C_ERR;
    }

    if (conversion) *conversion = to_meters;
    return C_OK;
}",1,61,geo.c,extractDistanceOrReply,,false,156,177,extractDistanceOrReply,,,10,"int extractDistanceOrReply (client*,robj**,double*,double*)"
138048,METHOD,geo.c:<global>,TYPE_DECL,"int extractBoxOrReply(client *c, robj **argv, double *conversion,
                         double *width, double *height) {
    double h, w;
    if ((getDoubleFromObjectOrReply(c, argv[0], &w, ""need numeric width"") != C_OK) ||
        (getDoubleFromObjectOrReply(c, argv[1], &h, ""need numeric height"") != C_OK)) {
        return C_ERR;
    }

    if (h < 0 || w < 0) {
        addReplyError(c, ""height or width cannot be negative"");
        return C_ERR;
    }
    if (height) *height = h;
    if (width) *width = w;

    double to_meters = extractUnitOrReply(c,argv[2]);
    if (to_meters < 0) {
        return C_ERR;
    }

    if (conversion) *conversion = to_meters;
    return C_OK;
}",1,77,geo.c,extractBoxOrReply,,false,183,205,extractBoxOrReply,,,11,"int extractBoxOrReply (client*,robj**,double*,double*,double*)"
138151,METHOD,geo.c:<global>,TYPE_DECL,"void addReplyDoubleDistance(client *c, double d) {
    char dbuf[128];
    const int dlen = fixedpoint_d2string(dbuf, sizeof(dbuf), d, 4);
    addReplyBulkCBuffer(c, dbuf, dlen);
}",1,1,geo.c,addReplyDoubleDistance,,false,212,216,addReplyDoubleDistance,,,12,"void addReplyDoubleDistance (client*,double)"
138171,METHOD,geo.c:<global>,TYPE_DECL,"int geoWithinShape(GeoShape *shape, double score, double *xy, double *distance) {
    if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */
    /* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in
     * reverse order: longitude first, latitude later. */
    if (shape->type == CIRCULAR_TYPE) {
        if (!geohashGetDistanceIfInRadiusWGS84(shape->xy[0], shape->xy[1], xy[0], xy[1],
                                               shape->t.radius*shape->conversion, distance))
            return C_ERR;
    } else if (shape->type == RECTANGLE_TYPE) {
        if (!geohashGetDistanceIfInRectangle(shape->t.r.width * shape->conversion,
                                             shape->t.r.height * shape->conversion,
                                             shape->xy[0], shape->xy[1], xy[0], xy[1], distance))
            return C_ERR;
    }
    return C_OK;
}",1,41,geo.c,geoWithinShape,,false,232,247,geoWithinShape,,,13,"int geoWithinShape (GeoShape*,double,double*,double*)"
138297,METHOD,geo.c:<global>,TYPE_DECL,"int geoGetPointsInRange(robj *zobj, double min, double max, GeoShape *shape, geoArray *ga, unsigned long limit) {
    /* minex 0 = include min in range; maxex 1 = exclude max in range */
    /* That's: min <= val < max */
    zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };
    size_t origincount = ga->used;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr = NULL;
        unsigned int vlen = 0;
        long long vlong = 0;
        double score = 0;

        if ((eptr = zzlFirstInRange(zl, &range)) == NULL) {
            /* Nothing exists starting at our min.  No results. */
            return 0;
        }

        sptr = lpNext(zl, eptr);
        while (eptr) {
            double xy[2];
            double distance = 0;
            score = zzlGetScore(sptr);

            /* If we fell out of range, break. */
            if (!zslValueLteMax(score, &range))
   ...",1,26,geo.c,geoGetPointsInRange,,false,261,323,geoGetPointsInRange,,,14,"int geoGetPointsInRange (robj*,double,double,GeoShape*,geoArray*,long unsigned)"
138569,METHOD,geo.c:<global>,TYPE_DECL,"void scoresOfGeoHashBox(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max) {
    /* We want to compute the sorted set scores that will include all the
     * elements inside the specified Geohash 'hash', which has as many
     * bits as specified by hash.step * 2.
     *
     * So if step is, for example, 3, and the hash value in binary
     * is 101010, since our score is 52 bits we want every element which
     * is in binary: 101010?????????????????????????????????????????????
     * Where ? can be 0 or 1.
     *
     * To get the min score we just use the initial hash value left
     * shifted enough to get the 52 bit value. Later we increment the
     * 6 bit prefix (see the hash.bits++ statement), and get the new
     * prefix: 101011, which we align again to 52 bits to get the maximum
     * value (which is excluded from the search). So we get everything
     * between the two following scores (represented in binary):
     *
     * 1010100000000000000000000000000...",1,1,geo.c,scoresOfGeoHashBox,,false,328,352,scoresOfGeoHashBox,,,15,"void scoresOfGeoHashBox (GeoHashBits,GeoHashFix52Bits*,GeoHashFix52Bits*)"
138590,METHOD,geo.c:<global>,TYPE_DECL,"int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, GeoShape *shape, unsigned long limit) {
    GeoHashFix52Bits min, max;

    scoresOfGeoHashBox(hash,&min,&max);
    return geoGetPointsInRange(zobj, min, max, shape, ga, limit);
}",1,1,geo.c,membersOfGeoHashBox,,false,357,362,membersOfGeoHashBox,,,16,"int membersOfGeoHashBox (robj*,GeoHashBits,geoArray*,GeoShape*,long unsigned)"
138615,METHOD,geo.c:<global>,TYPE_DECL,"int membersOfAllNeighbors(robj *zobj, const GeoHashRadius *n, GeoShape *shape, geoArray *ga, unsigned long limit) {
    GeoHashBits neighbors[9];
    unsigned int i, count = 0, last_processed = 0;
    int debugmsg = 0;

    neighbors[0] = n->hash;
    neighbors[1] = n->neighbors.north;
    neighbors[2] = n->neighbors.south;
    neighbors[3] = n->neighbors.east;
    neighbors[4] = n->neighbors.west;
    neighbors[5] = n->neighbors.north_east;
    neighbors[6] = n->neighbors.north_west;
    neighbors[7] = n->neighbors.south_east;
    neighbors[8] = n->neighbors.south_west;

    /* For each neighbor (*and* our own hashbox), get all the matching
     * members and add them to the potential result list. */
    for (i = 0; i < sizeof(neighbors) / sizeof(*neighbors); i++) {
        if (HASHISZERO(neighbors[i])) {
            if (debugmsg) D(""neighbors[%d] is zero"",i);
            continue;
        }

        /* Debugging info. */
        if (debugmsg) {
            GeoHashRange long_range,...",1,12,geo.c,membersOfAllNeighbors,,false,365,421,membersOfAllNeighbors,,,17,"int membersOfAllNeighbors (robj*,GeoHashRadius*,GeoShape*,geoArray*,long unsigned)"
139073,METHOD,geo.c:<global>,TYPE_DECL,"static int sort_gp_asc(const void *a, const void *b) {
    const struct geoPoint *gpa = a, *gpb = b;
    /* We can't do adist - bdist because they are doubles and
     * the comparator returns an int. */
    if (gpa->dist > gpb->dist)
        return 1;
    else if (gpa->dist == gpb->dist)
        return 0;
    else
        return -1;
}",1,1,geo.c,sort_gp_asc,,false,424,434,sort_gp_asc,,,18,"int sort_gp_asc (void*,void*)"
139116,METHOD,geo.c:<global>,TYPE_DECL,"static int sort_gp_desc(const void *a, const void *b) {
    return -sort_gp_asc(a, b);
}",1,1,geo.c,sort_gp_desc,,false,436,438,sort_gp_desc,,,19,"int sort_gp_desc (void*,void*)"
139127,METHOD,geo.c:<global>,TYPE_DECL,"void geoaddCommand(client *c) {
    int xx = 0, nx = 0, longidx = 2;
    int i;

    /* Parse options. At the end 'longidx' is set to the argument position
     * of the longitude of the first element. */
    while (longidx < c->argc) {
        char *opt = c->argv[longidx]->ptr;
        if (!strcasecmp(opt,""nx"")) nx = 1;
        else if (!strcasecmp(opt,""xx"")) xx = 1;
        else if (!strcasecmp(opt,""ch"")) { /* Handle in zaddCommand. */ }
        else break;
        longidx++;
    }

    if ((c->argc - longidx) % 3 || (xx && nx)) {
        /* Need an odd number of arguments if we got this far... */
            addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Set up the vector for calling ZADD. */
    int elements = (c->argc - longidx) / 3;
    int argc = longidx+elements*2; /* ZADD key [CH] [NX|XX] score ele ... */
    robj **argv = zcalloc(argc*sizeof(robj*));
    argv[0] = createRawStringObject(""zadd"",4);
    for (i = 1; i < longidx; i++) {
        argv[i] =...",1,68,geo.c,geoaddCommand,,false,445,503,geoaddCommand,,,20,void geoaddCommand (client*)
139389,METHOD,geo.c:<global>,TYPE_DECL,"void georadiusGeneric(client *c, int srcKeyIndex, int flags) {
    robj *storekey = NULL;
    int storedist = 0; /* 0 for STORE, 1 for STOREDIST. */

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[srcKeyIndex]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Find long/lat to use for radius or box search based on inquiry type */
    int base_args;
    GeoShape shape = {0};
    if (flags & RADIUS_COORDS) {
        /* GEORADIUS or GEORADIUS_RO */
        base_args = 6;
        shape.type = CIRCULAR_TYPE;
        if (extractLongLatOrReply(c, c->argv + 2, shape.xy) == C_ERR) return;
        if (extractDistanceOrReply(c, c->argv+base_args-2, &shape.conversion, &shape.t.radius) != C_OK) return;
    } else if ((flags & RADIUS_MEMBER) && !zobj) {
        /* We don't have a source key, but we need to proceed with argument
         * parsing, so we know which reply to use depending on the STORE flag. */
        base_args = 5;
    } else if (flags & RA...",1,27,geo.c,georadiusGeneric,,false,523,844,georadiusGeneric,,,21,"void georadiusGeneric (client*,int,int)"
140434,METHOD,geo.c:<global>,TYPE_DECL,"int (*sort_gp_callback)(const void *a, const void *b) = NULL;",13,68,geo.c,georadiusGeneric.sort_gp_callback,,false,741,741,sort_gp_callback,,,1,"int georadiusGeneric.sort_gp_callback (void*,void*)"
140793,METHOD,geo.c:<global>,TYPE_DECL,"void georadiusCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_COORDS);
}",1,27,geo.c,georadiusCommand,,false,847,849,georadiusCommand,,,22,void georadiusCommand (client*)
140806,METHOD,geo.c:<global>,TYPE_DECL,"void georadiusbymemberCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_MEMBER);
}",1,27,geo.c,georadiusbymemberCommand,,false,852,854,georadiusbymemberCommand,,,23,void georadiusbymemberCommand (client*)
140819,METHOD,geo.c:<global>,TYPE_DECL,"void georadiusroCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_COORDS|RADIUS_NOSTORE);
}",1,27,geo.c,georadiusroCommand,,false,857,859,georadiusroCommand,,,24,void georadiusroCommand (client*)
140838,METHOD,geo.c:<global>,TYPE_DECL,"void georadiusbymemberroCommand(client *c) {
    georadiusGeneric(c, 1, RADIUS_MEMBER|RADIUS_NOSTORE);
}",1,27,geo.c,georadiusbymemberroCommand,,false,862,864,georadiusbymemberroCommand,,,25,void georadiusbymemberroCommand (client*)
140857,METHOD,geo.c:<global>,TYPE_DECL,"void geosearchCommand(client *c) {
    georadiusGeneric(c, 1, GEOSEARCH);
}",1,27,geo.c,geosearchCommand,,false,866,868,geosearchCommand,,,26,void geosearchCommand (client*)
140870,METHOD,geo.c:<global>,TYPE_DECL,"void geosearchstoreCommand(client *c) {
    georadiusGeneric(c, 2, GEOSEARCH|GEOSEARCHSTORE);
}",1,27,geo.c,geosearchstoreCommand,,false,870,872,geosearchstoreCommand,,,27,void geosearchstoreCommand (client*)
140889,METHOD,geo.c:<global>,TYPE_DECL,"void geohashCommand(client *c) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Geohash elements one after the other, using a null bulk reply for
     * missing elements. */
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(c);
        } else {
            /* The internal format we use for geocoding is a bit different
             * than the standard, since we use as initial latitude range
             * -85,85, while the normal geohashing algorithm uses -90,90.
             * So we have to decode our position and re-encode using the
             * standard ranges in order to output a valid geohash string. */

            /* Decode... */
            double xy[2];
            if (!...",1,27,geo.c,geohashCommand,,false,878,934,geohashCommand,,,28,void geohashCommand (client*)
141081,METHOD,geo.c:<global>,TYPE_DECL,"void geoposCommand(client *c) {
    int j;

    /* Look up the requested zset */
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c, zobj, OBJ_ZSET)) return;

    /* Report elements one after the other, using a null bulk reply for
     * missing elements. */
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNullArray(c);
        } else {
            /* Decode... */
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNullArray(c);
                continue;
            }
            addReplyArrayLen(c,2);
            addReplyHumanLongDouble(c,xy[0]);
            addReplyHumanLongDouble(c,xy[1]);
        }
    }
}",1,27,geo.c,geoposCommand,,false,940,966,geoposCommand,,,29,void geoposCommand (client*)
141177,METHOD,geo.c:<global>,TYPE_DECL,"void geodistCommand(client *c) {
    double to_meter = 1;

    /* Check if there is the unit to extract, otherwise assume meters. */
    if (c->argc == 5) {
        to_meter = extractUnitOrReply(c,c->argv[4]);
        if (to_meter < 0) return;
    } else if (c->argc > 5) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Look up the requested zset */
    robj *zobj = NULL;
    if ((zobj = lookupKeyReadOrReply(c, c->argv[1], shared.null[c->resp]))
        == NULL || checkType(c, zobj, OBJ_ZSET)) return;

    /* Get the scores. We need both otherwise NULL is returned. */
    double score1, score2, xyxy[4];
    if (zsetScore(zobj, c->argv[2]->ptr, &score1) == C_ERR ||
        zsetScore(zobj, c->argv[3]->ptr, &score2) == C_ERR)
    {
        addReplyNull(c);
        return;
    }

    /* Decode & compute the distance. */
    if (!decodeGeohash(score1,xyxy) || !decodeGeohash(score2,xyxy+2))
        addReplyNull(c);
    else
        addReplyDoubleDistance(c,
...",1,38,geo.c,geodistCommand,,false,973,1005,geodistCommand,,,30,void geodistCommand (client*)
141335,METHOD,geo.h:<global>,TYPE_DECL,<global>,1,1,geo.h,geo.h:<global>,,false,1,22,<global>,,,1,
141355,METHOD,geohash.c:<global>,TYPE_DECL,<global>,1,4,geohash.c,geohash.c:<global>,,false,1,299,<global>,,,1,
141357,METHOD,geohash.c:<global>,TYPE_DECL,"static inline uint64_t interleave64(uint32_t xlo, uint32_t ylo) {
    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                 0x0000FFFF0000FFFFULL};
    static const unsigned int S[] = {1, 2, 4, 8, 16};

    uint64_t x = xlo;
    uint64_t y = ylo;

    x = (x | (x << S[4])) & B[4];
    y = (y | (y << S[4])) & B[4];

    x = (x | (x << S[3])) & B[3];
    y = (y | (y << S[3])) & B[3];

    x = (x | (x << S[2])) & B[2];
    y = (y | (y << S[2])) & B[2];

    x = (x | (x << S[1])) & B[1];
    y = (y | (y << S[1])) & B[1];

    x = (x | (x << S[0])) & B[0];
    y = (y | (y << S[0])) & B[0];

    return x | (y << 1);
}",1,1,geohash.c,interleave64,,false,52,77,interleave64,,,1,"uint64_t interleave64 (uint32_t,uint32_t)"
141525,METHOD,geohash.c:<global>,TYPE_DECL,"static inline uint64_t deinterleave64(uint64_t interleaved) {
    static const uint64_t B[] = {0x5555555555555555ULL, 0x3333333333333333ULL,
                                 0x0F0F0F0F0F0F0F0FULL, 0x00FF00FF00FF00FFULL,
                                 0x0000FFFF0000FFFFULL, 0x00000000FFFFFFFFULL};
    static const unsigned int S[] = {0, 1, 2, 4, 8, 16};

    uint64_t x = interleaved;
    uint64_t y = interleaved >> 1;

    x = (x | (x >> S[0])) & B[0];
    y = (y | (y >> S[0])) & B[0];

    x = (x | (x >> S[1])) & B[1];
    y = (y | (y >> S[1])) & B[1];

    x = (x | (x >> S[2])) & B[2];
    y = (y | (y >> S[2])) & B[2];

    x = (x | (x >> S[3])) & B[3];
    y = (y | (y >> S[3])) & B[3];

    x = (x | (x >> S[4])) & B[4];
    y = (y | (y >> S[4])) & B[4];

    x = (x | (x >> S[5])) & B[5];
    y = (y | (y >> S[5])) & B[5];

    return x | (y << 32);
}",1,1,geohash.c,deinterleave64,,false,82,110,deinterleave64,,,2,uint64_t deinterleave64 (uint64_t)
141722,METHOD,geohash.c:<global>,TYPE_DECL,"void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range) {
    /* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */
    /* We can't geocode at the north/south pole. */
    long_range->max = GEO_LONG_MAX;
    long_range->min = GEO_LONG_MIN;
    lat_range->max = GEO_LAT_MAX;
    lat_range->min = GEO_LAT_MIN;
}",1,22,geohash.c,geohashGetCoordRange,,false,112,119,geohashGetCoordRange,,,3,"void geohashGetCoordRange (GeoHashRange*,GeoHashRange*)"
141758,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
                  double longitude, double latitude, uint8_t step,
                  GeoHashBits *hash) {
    /* Check basic arguments sanity. */
    if (hash == NULL || step > 32 || step == 0 ||
        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) return 0;

    /* Return an error when trying to index outside the supported
     * constraints. */
    if (longitude > GEO_LONG_MAX || longitude < GEO_LONG_MIN ||
        latitude > GEO_LAT_MAX || latitude < GEO_LAT_MIN) return 0;

    hash->bits = 0;
    hash->step = step;

    if (latitude < lat_range->min || latitude > lat_range->max ||
        longitude < long_range->min || longitude > long_range->max) {
        return 0;
    }

    double lat_offset =
        (latitude - lat_range->min) / (lat_range->max - lat_range->min);
    double long_offset =
        (longitude - long_range->min) / (long_range->max - long_range->min);

    /* convert to fix...",1,8,geohash.c,geohashEncode,,false,121,151,geohashEncode,,,4,"int geohashEncode (GeoHashRange*,GeoHashRange*,double,double,uint8_t,GeoHashBits*)"
141938,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashEncodeType(double longitude, double latitude, uint8_t step, GeoHashBits *hash) {
    GeoHashRange r[2] = {{0}};
    geohashGetCoordRange(&r[0], &r[1]);
    return geohashEncode(&r[0], &r[1], longitude, latitude, step, hash);
}",1,1,geohash.c,geohashEncodeType,,false,153,157,geohashEncodeType,,,5,"int geohashEncodeType (double,double,uint8_t,GeoHashBits*)"
141975,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
                       GeoHashBits *hash) {
    return geohashEncodeType(longitude, latitude, step, hash);
}",1,1,geohash.c,geohashEncodeWGS84,,false,159,162,geohashEncodeWGS84,,,6,"int geohashEncodeWGS84 (double,double,uint8_t,GeoHashBits*)"
141989,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
                   const GeoHashBits hash, GeoHashArea *area) {
    if (HASHISZERO(hash) || NULL == area || RANGEISZERO(lat_range) ||
        RANGEISZERO(long_range)) {
        return 0;
    }

    area->hash = hash;
    uint8_t step = hash.step;
    uint64_t hash_sep = deinterleave64(hash.bits); /* hash = [LAT][LONG] */

    double lat_scale = lat_range.max - lat_range.min;
    double long_scale = long_range.max - long_range.min;

    uint32_t ilato = hash_sep;       /* get lat part of deinterleaved hash */
    uint32_t ilono = hash_sep >> 32; /* shift over to get long part of hash */

    /* divide by 2**step.
     * Then, for 0-1 coordinate, multiply times scale and add
       to the min to get the absolute coordinate. */
    area->latitude.min =
        lat_range.min + (ilato * 1.0 / (1ull << step)) * lat_scale;
    area->latitude.max =
        lat_range.min + ((ilato + 1) * 1.0 / (1ull << step)) * la...",1,8,geohash.c,geohashDecode,,false,164,194,geohashDecode,,,7,"int geohashDecode (GeoHashRange,GeoHashRange,GeoHashBits,GeoHashArea*)"
142173,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area) {
    GeoHashRange r[2] = {{0}};
    geohashGetCoordRange(&r[0], &r[1]);
    return geohashDecode(r[0], r[1], hash, area);
}",1,1,geohash.c,geohashDecodeType,,false,196,200,geohashDecodeType,,,8,"int geohashDecodeType (GeoHashBits,GeoHashArea*)"
142204,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area) {
    return geohashDecodeType(hash, area);
}",1,1,geohash.c,geohashDecodeWGS84,,false,202,204,geohashDecodeWGS84,,,9,"int geohashDecodeWGS84 (GeoHashBits,GeoHashArea*)"
142214,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy) {
    if (!xy) return 0;
    xy[0] = (area->longitude.min + area->longitude.max) / 2;
    if (xy[0] > GEO_LONG_MAX) xy[0] = GEO_LONG_MAX;
    if (xy[0] < GEO_LONG_MIN) xy[0] = GEO_LONG_MIN;
    xy[1] = (area->latitude.min + area->latitude.max) / 2;
    if (xy[1] > GEO_LAT_MAX) xy[1] = GEO_LAT_MAX;
    if (xy[1] < GEO_LAT_MIN) xy[1] = GEO_LAT_MIN;
    return 1;
}",1,16,geohash.c,geohashDecodeAreaToLongLat,,false,206,215,geohashDecodeAreaToLongLat,,,10,"int geohashDecodeAreaToLongLat (GeoHashArea*,double*)"
142330,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy) {
    GeoHashArea area = {{0}};
    if (!xy || !geohashDecodeType(hash, &area))
        return 0;
    return geohashDecodeAreaToLongLat(&area, xy);
}",1,1,geohash.c,geohashDecodeToLongLatType,,false,217,222,geohashDecodeToLongLatType,,,11,"int geohashDecodeToLongLatType (GeoHashBits,double*)"
142359,METHOD,geohash.c:<global>,TYPE_DECL,"int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy) {
    return geohashDecodeToLongLatType(hash, xy);
}",1,1,geohash.c,geohashDecodeToLongLatWGS84,,false,224,226,geohashDecodeToLongLatWGS84,,,12,"int geohashDecodeToLongLatWGS84 (GeoHashBits,double*)"
142369,METHOD,geohash.c:<global>,TYPE_DECL,"static void geohash_move_x(GeoHashBits *hash, int8_t d) {
    if (d == 0)
        return;

    uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
    uint64_t y = hash->bits & 0x5555555555555555ULL;

    uint64_t zz = 0x5555555555555555ULL >> (64 - hash->step * 2);

    if (d > 0) {
        x = x + (zz + 1);
    } else {
        x = x | zz;
        x = x - (zz + 1);
    }

    x &= (0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2));
    hash->bits = (x | y);
}",1,1,geohash.c,geohash_move_x,,false,228,246,geohash_move_x,,,13,"void geohash_move_x (GeoHashBits*,int8_t)"
142453,METHOD,geohash.c:<global>,TYPE_DECL,"static void geohash_move_y(GeoHashBits *hash, int8_t d) {
    if (d == 0)
        return;

    uint64_t x = hash->bits & 0xaaaaaaaaaaaaaaaaULL;
    uint64_t y = hash->bits & 0x5555555555555555ULL;

    uint64_t zz = 0xaaaaaaaaaaaaaaaaULL >> (64 - hash->step * 2);
    if (d > 0) {
        y = y + (zz + 1);
    } else {
        y = y | zz;
        y = y - (zz + 1);
    }
    y &= (0x5555555555555555ULL >> (64 - hash->step * 2));
    hash->bits = (x | y);
}",1,1,geohash.c,geohash_move_y,,false,248,264,geohash_move_y,,,14,"void geohash_move_y (GeoHashBits*,int8_t)"
142537,METHOD,geohash.c:<global>,TYPE_DECL,"void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors) {
    neighbors->east = *hash;
    neighbors->west = *hash;
    neighbors->north = *hash;
    neighbors->south = *hash;
    neighbors->south_east = *hash;
    neighbors->south_west = *hash;
    neighbors->north_east = *hash;
    neighbors->north_west = *hash;

    geohash_move_x(&neighbors->east, 1);
    geohash_move_y(&neighbors->east, 0);

    geohash_move_x(&neighbors->west, -1);
    geohash_move_y(&neighbors->west, 0);

    geohash_move_x(&neighbors->south, 0);
    geohash_move_y(&neighbors->south, -1);

    geohash_move_x(&neighbors->north, 0);
    geohash_move_y(&neighbors->north, 1);

    geohash_move_x(&neighbors->north_west, -1);
    geohash_move_y(&neighbors->north_west, 1);

    geohash_move_x(&neighbors->north_east, 1);
    geohash_move_y(&neighbors->north_east, 1);

    geohash_move_x(&neighbors->south_east, 1);
    geohash_move_y(&neighbors->south_east, -1);

    geohash_move_x(&neighbors->sout...",1,1,geohash.c,geohashNeighbors,,false,266,299,geohashNeighbors,,,15,"void geohashNeighbors (GeoHashBits*,GeoHashNeighbors*)"
142700,METHOD,geohash.h:<global>,TYPE_DECL,<global>,1,23,geohash.h,geohash.h:<global>,,false,1,135,<global>,,,1,
142711,METHOD,<empty>,<empty>,<empty>,1,,geohash.h,GeoDirection:<clinit>,,false,54,,<clinit>,,,9,
142754,METHOD,<empty>,<empty>,<empty>,1,,geohash.h,GeoShape:<clinit>,,false,94,,<clinit>,,,7,
142763,METHOD,geohash.h:<global>,TYPE_DECL,"void geohashGetCoordRange(GeoHashRange *long_range, GeoHashRange *lat_range);",6,76,geohash.h,geohashGetCoordRange,,false,115,115,geohashGetCoordRange,,,13,"void geohashGetCoordRange (GeoHashRange*,GeoHashRange*)"
142769,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashEncode(const GeoHashRange *long_range, const GeoHashRange *lat_range,
                  double longitude, double latitude, uint8_t step,
                  GeoHashBits *hash);",5,36,geohash.h,geohashEncode,,false,116,118,geohashEncode,,,14,"int geohashEncode (GeoHashRange*,GeoHashRange*,double,double,uint8_t,GeoHashBits*)"
142779,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashEncodeType(double longitude, double latitude,
                      uint8_t step, GeoHashBits *hash);",5,54,geohash.h,geohashEncodeType,,false,119,120,geohashEncodeType,,,15,"int geohashEncodeType (double,double,uint8_t,GeoHashBits*)"
142787,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashEncodeWGS84(double longitude, double latitude, uint8_t step,
                       GeoHashBits *hash);",5,41,geohash.h,geohashEncodeWGS84,,false,121,122,geohashEncodeWGS84,,,16,"int geohashEncodeWGS84 (double,double,uint8_t,GeoHashBits*)"
142795,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashDecode(const GeoHashRange long_range, const GeoHashRange lat_range,
                  const GeoHashBits hash, GeoHashArea *area);",5,60,geohash.h,geohashDecode,,false,123,124,geohashDecode,,,17,"int geohashDecode (GeoHashRange,GeoHashRange,GeoHashBits,GeoHashArea*)"
142803,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashDecodeType(const GeoHashBits hash, GeoHashArea *area);",5,64,geohash.h,geohashDecodeType,,false,125,125,geohashDecodeType,,,18,"int geohashDecodeType (GeoHashBits,GeoHashArea*)"
142809,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashDecodeWGS84(const GeoHashBits hash, GeoHashArea *area);",5,65,geohash.h,geohashDecodeWGS84,,false,126,126,geohashDecodeWGS84,,,19,"int geohashDecodeWGS84 (GeoHashBits,GeoHashArea*)"
142815,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashDecodeAreaToLongLat(const GeoHashArea *area, double *xy);",5,67,geohash.h,geohashDecodeAreaToLongLat,,false,127,127,geohashDecodeAreaToLongLat,,,20,"int geohashDecodeAreaToLongLat (GeoHashArea*,double*)"
142821,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashDecodeToLongLatType(const GeoHashBits hash, double *xy);",5,66,geohash.h,geohashDecodeToLongLatType,,false,128,128,geohashDecodeToLongLatType,,,21,"int geohashDecodeToLongLatType (GeoHashBits,double*)"
142827,METHOD,geohash.h:<global>,TYPE_DECL,"int geohashDecodeToLongLatWGS84(const GeoHashBits hash, double *xy);",5,67,geohash.h,geohashDecodeToLongLatWGS84,,false,129,129,geohashDecodeToLongLatWGS84,,,22,"int geohashDecodeToLongLatWGS84 (GeoHashBits,double*)"
142833,METHOD,geohash.h:<global>,TYPE_DECL,"void geohashNeighbors(const GeoHashBits *hash, GeoHashNeighbors *neighbors);",6,75,geohash.h,geohashNeighbors,,false,130,130,geohashNeighbors,,,23,"void geohashNeighbors (GeoHashBits*,GeoHashNeighbors*)"
142850,METHOD,geohash_helper.c:<global>,TYPE_DECL,<global>,1,1,geohash_helper.c,geohash_helper.c:<global>,,false,1,280,<global>,,,1,
142869,METHOD,geohash_helper.c:<global>,TYPE_DECL,static inline double deg_rad(double ang) { return ang * D_R; },1,56,geohash_helper.c,deg_rad,,false,57,57,deg_rad,,,9,double deg_rad (double)
142882,METHOD,geohash_helper.c:<global>,TYPE_DECL,static inline double rad_deg(double ang) { return ang / D_R; },1,56,geohash_helper.c,rad_deg,,false,58,58,rad_deg,,,10,double rad_deg (double)
142895,METHOD,geohash_helper.c:<global>,TYPE_DECL,"uint8_t geohashEstimateStepsByRadius(double range_meters, double lat) {
    if (range_meters == 0) return 26;
    int step = 1;
    while (range_meters < MERCATOR_MAX) {
        range_meters *= 2;
        step++;
    }
    step -= 2; /* Make sure range is included in most of the base cases. */

    /* Wider range towards the poles... Note: it is possible to do better
     * than this approximation by computing the distance between meridians
     * at this latitude, but this does the trick for now. */
    if (lat > 66 || lat < -66) {
        step--;
        if (lat > 80 || lat < -80) step--;
    }

    /* Frame to valid range. */
    if (step < 1) step = 1;
    if (step > 26) step = 26;
    return step;
}",1,1,geohash_helper.c,geohashEstimateStepsByRadius,,false,62,83,geohashEstimateStepsByRadius,,,11,"uint8_t geohashEstimateStepsByRadius (double,double)"
142967,METHOD,geohash_helper.c:<global>,TYPE_DECL,"int geohashBoundingBox(GeoShape *shape, double *bounds) {
    if (!bounds) return 0;
    double longitude = shape->xy[0];
    double latitude = shape->xy[1];
    double height = shape->conversion * (shape->type == CIRCULAR_TYPE ? shape->t.radius : shape->t.r.height/2);
    double width = shape->conversion * (shape->type == CIRCULAR_TYPE ? shape->t.radius : shape->t.r.width/2);

    const double lat_delta = rad_deg(height/EARTH_RADIUS_IN_METERS);
    const double long_delta_top = rad_deg(width/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude+lat_delta)));
    const double long_delta_bottom = rad_deg(width/EARTH_RADIUS_IN_METERS/cos(deg_rad(latitude-lat_delta)));
    /* The directions of the northern and southern hemispheres
     * are opposite, so we choice different points as min/max long/lat */
    int southern_hemisphere = latitude < 0 ? 1 : 0;
    bounds[0] = southern_hemisphere ? longitude-long_delta_bottom : longitude-long_delta_top;
    bounds[2] = southern_hemisphere ? longitude+l...",1,56,geohash_helper.c,geohashBoundingBox,,false,98,116,geohashBoundingBox,,,12,"int geohashBoundingBox (GeoShape*,double*)"
143135,METHOD,geohash_helper.c:<global>,TYPE_DECL,"GeoHashRadius geohashCalculateAreasByShapeWGS84(GeoShape *shape) {
    GeoHashRange long_range, lat_range;
    GeoHashRadius radius;
    GeoHashBits hash;
    GeoHashNeighbors neighbors;
    GeoHashArea area;
    double min_lon, max_lon, min_lat, max_lat;
    int steps;

    geohashBoundingBox(shape, shape->bounds);
    min_lon = shape->bounds[0];
    min_lat = shape->bounds[1];
    max_lon = shape->bounds[2];
    max_lat = shape->bounds[3];

    double longitude = shape->xy[0];
    double latitude = shape->xy[1];
    /* radius_meters is calculated differently in different search types:
     * 1) CIRCULAR_TYPE, just use radius.
     * 2) RECTANGLE_TYPE, we use sqrt((width/2)^2 + (height/2)^2) to
     * calculate the distance from the center point to the corner */
    double radius_meters = shape->type == CIRCULAR_TYPE ? shape->t.radius :
            sqrt((shape->t.r.width/2)*(shape->t.r.width/2) + (shape->t.r.height/2)*(shape->t.r.height/2));
    radius_meters *= shape->conversion;
...",1,42,geohash_helper.c,geohashCalculateAreasByShapeWGS84,,false,121,211,geohashCalculateAreasByShapeWGS84,,,13,GeoHashRadius geohashCalculateAreasByShapeWGS84 (GeoShape*)
143685,METHOD,geohash_helper.c:<global>,TYPE_DECL,"GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash) {
    uint64_t bits = hash.bits;
    bits <<= (52 - hash.step * 2);
    return bits;
}",1,1,geohash_helper.c,geohashAlign52Bits,,false,213,217,geohashAlign52Bits,,,14,GeoHashFix52Bits geohashAlign52Bits (GeoHashBits)
143707,METHOD,geohash_helper.c:<global>,TYPE_DECL,"double geohashGetLatDistance(double lat1d, double lat2d) {
    return EARTH_RADIUS_IN_METERS * fabs(deg_rad(lat2d) - deg_rad(lat1d));
}",1,1,geohash_helper.c,geohashGetLatDistance,,false,224,226,geohashGetLatDistance,,,15,"double geohashGetLatDistance (double,double)"
143722,METHOD,geohash_helper.c:<global>,TYPE_DECL,"double geohashGetDistance(double lon1d, double lat1d, double lon2d, double lat2d) {
    double lat1r, lon1r, lat2r, lon2r, u, v, a;
    lon1r = deg_rad(lon1d);
    lon2r = deg_rad(lon2d);
    v = sin((lon2r - lon1r) / 2);
    /* if v == 0 we can avoid doing expensive math when lons are practically the same */
    if (v == 0.0)
        return geohashGetLatDistance(lat1d, lat2d);
    lat1r = deg_rad(lat1d);
    lat2r = deg_rad(lat2d);
    u = sin((lat2r - lat1r) / 2);
    a = u * u + cos(lat1r) * cos(lat2r) * v * v;
    return 2.0 * EARTH_RADIUS_IN_METERS * asin(sqrt(a));
}",1,1,geohash_helper.c,geohashGetDistance,,false,229,242,geohashGetDistance,,,16,"double geohashGetDistance (double,double,double,double)"
143801,METHOD,geohash_helper.c:<global>,TYPE_DECL,"int geohashGetDistanceIfInRadius(double x1, double y1,
                                 double x2, double y2, double radius,
                                 double *distance) {
    *distance = geohashGetDistance(x1, y1, x2, y2);
    if (*distance > radius) return 0;
    return 1;
}",1,1,geohash_helper.c,geohashGetDistanceIfInRadius,,false,244,250,geohashGetDistanceIfInRadius,,,17,"int geohashGetDistanceIfInRadius (double,double,double,double,double,double*)"
143829,METHOD,geohash_helper.c:<global>,TYPE_DECL,"int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
                                      double y2, double radius,
                                      double *distance) {
    return geohashGetDistanceIfInRadius(x1, y1, x2, y2, radius, distance);
}",1,1,geohash_helper.c,geohashGetDistanceIfInRadiusWGS84,,false,252,256,geohashGetDistanceIfInRadiusWGS84,,,18,"int geohashGetDistanceIfInRadiusWGS84 (double,double,double,double,double,double*)"
143847,METHOD,geohash_helper.c:<global>,TYPE_DECL,"int geohashGetDistanceIfInRectangle(double width_m, double height_m, double x1, double y1,
                                    double x2, double y2, double *distance) {
    /* latitude distance is less expensive to compute than longitude distance
     * so we check first for the latitude condition */
    double lat_distance = geohashGetLatDistance(y2, y1);
    if (lat_distance > height_m/2) {
        return 0;
    }
    double lon_distance = geohashGetDistance(x2, y2, x1, y2);
    if (lon_distance > width_m/2) {
        return 0;
    }
    *distance = geohashGetDistance(x1, y1, x2, y2);
    return 1;
}",1,1,geohash_helper.c,geohashGetDistanceIfInRectangle,,false,266,280,geohashGetDistanceIfInRectangle,,,19,"int geohashGetDistanceIfInRectangle (double,double,double,double,double,double,double*)"
143905,METHOD,geohash_helper.h:<global>,TYPE_DECL,<global>,1,1,geohash_helper.h,geohash_helper.h:<global>,,false,1,65,<global>,,,1,
143914,METHOD,geohash_helper.h:<global>,TYPE_DECL,"uint8_t geohashEstimateStepsByRadius(double range_meters, double lat);",9,69,geohash_helper.h,geohashEstimateStepsByRadius,,false,50,50,geohashEstimateStepsByRadius,,,5,"uint8_t geohashEstimateStepsByRadius (double,double)"
143920,METHOD,geohash_helper.h:<global>,TYPE_DECL,"int geohashBoundingBox(GeoShape *shape, double *bounds);",5,55,geohash_helper.h,geohashBoundingBox,,false,51,51,geohashBoundingBox,,,6,"int geohashBoundingBox (GeoShape*,double*)"
143926,METHOD,geohash_helper.h:<global>,TYPE_DECL,GeoHashRadius geohashCalculateAreasByShapeWGS84(GeoShape *shape);,15,64,geohash_helper.h,geohashCalculateAreasByShapeWGS84,,false,52,52,geohashCalculateAreasByShapeWGS84,,,7,GeoHashRadius geohashCalculateAreasByShapeWGS84 (GeoShape*)
143931,METHOD,geohash_helper.h:<global>,TYPE_DECL,GeoHashFix52Bits geohashAlign52Bits(const GeoHashBits hash);,18,59,geohash_helper.h,geohashAlign52Bits,,false,53,53,geohashAlign52Bits,,,8,GeoHashFix52Bits geohashAlign52Bits (GeoHashBits)
143936,METHOD,geohash_helper.h:<global>,TYPE_DECL,"double geohashGetDistance(double lon1d, double lat1d,
                          double lon2d, double lat2d);",8,53,geohash_helper.h,geohashGetDistance,,false,54,55,geohashGetDistance,,,9,"double geohashGetDistance (double,double,double,double)"
143944,METHOD,geohash_helper.h:<global>,TYPE_DECL,"int geohashGetDistanceIfInRadius(double x1, double y1,
                                 double x2, double y2, double radius,
                                 double *distance);",5,50,geohash_helper.h,geohashGetDistanceIfInRadius,,false,56,58,geohashGetDistanceIfInRadius,,,10,"int geohashGetDistanceIfInRadius (double,double,double,double,double,double*)"
143954,METHOD,geohash_helper.h:<global>,TYPE_DECL,"int geohashGetDistanceIfInRadiusWGS84(double x1, double y1, double x2,
                                      double y2, double radius,
                                      double *distance);",5,55,geohash_helper.h,geohashGetDistanceIfInRadiusWGS84,,false,59,61,geohashGetDistanceIfInRadiusWGS84,,,11,"int geohashGetDistanceIfInRadiusWGS84 (double,double,double,double,double,double*)"
143964,METHOD,geohash_helper.h:<global>,TYPE_DECL,"int geohashGetDistanceIfInRectangle(double width_m, double height_m, double x1, double y1,
                                    double x2, double y2, double *distance);",5,75,geohash_helper.h,geohashGetDistanceIfInRectangle,,false,62,63,geohashGetDistanceIfInRectangle,,,12,"int geohashGetDistanceIfInRectangle (double,double,double,double,double,double,double*)"
143984,METHOD,hyperloglog.c:<global>,TYPE_DECL,<global>,1,1,hyperloglog.c,hyperloglog.c:<global>,,false,1,1617,<global>,,,1,
143992,METHOD,<empty>,<empty>,<empty>,1,,hyperloglog.c,hllhdr:<clinit>,,false,182,,<clinit>,,,6,
144007,METHOD,hyperloglog.c:<global>,TYPE_DECL,"uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {
    const uint64_t m = 0xc6a4a7935bd1e995;
    const int r = 47;
    uint64_t h = seed ^ (len * m);
    const uint8_t *data = (const uint8_t *)key;
    const uint8_t *end = data + (len-(len&7));

    while(data != end) {
        uint64_t k;

#if (BYTE_ORDER == LITTLE_ENDIAN)
    #ifdef USE_ALIGNED_ACCESS
        memcpy(&k,data,sizeof(uint64_t));
    #else
        k = *((uint64_t*)data);
    #endif
#else
        k = (uint64_t) data[0];
        k |= (uint64_t) data[1] << 8;
        k |= (uint64_t) data[2] << 16;
        k |= (uint64_t) data[3] << 24;
        k |= (uint64_t) data[4] << 32;
        k |= (uint64_t) data[5] << 40;
        k |= (uint64_t) data[6] << 48;
        k |= (uint64_t) data[7] << 56;
#endif

        k *= m;
        k ^= k >> r;
        k *= m;
        h ^= k;
        h *= m;
        data += 8;
    }

    switch(len & 7) {
    case 7: h ^= (uint64_t)data[6] << 48; /* fall-thru */
    case 6: h ^...",1,19,hyperloglog.c,MurmurHash64A,,false,397,447,MurmurHash64A,,,4,"uint64_t MurmurHash64A (void*,int,unsigned int)"
144240,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {
    uint64_t hash, bit, index;
    int count;

    /* Count the number of zeroes starting from bit HLL_REGISTERS
     * (that is a power of two corresponding to the first bit we don't use
     * as index). The max run can be 64-P+1 = Q+1 bits.
     *
     * Note that the final ""1"" ending the sequence of zeroes must be
     * included in the count, so if we find ""001"" the count is 3, and
     * the smallest count possible is no zeroes at all, just a 1 bit
     * at the first position, that is a count of 1.
     *
     * This may sound like inefficient, but actually in the average case
     * there are high probabilities to find a 1 after a few iterations. */
    hash = MurmurHash64A(ele,elesize,0xadc83b19ULL);
    index = hash & HLL_P_MASK; /* Register index. */
    hash >>= HLL_P; /* Remove bits used to address the register. */
    hash |= ((uint64_t)1<<HLL_Q); /* Make sure the loop terminates
                          ...",1,19,hyperloglog.c,hllPatLen,,false,452,480,hllPatLen,,,5,"int hllPatLen (unsigned char*,size_t,long*)"
144310,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllDenseSet(uint8_t *registers, long index, uint8_t count) {
    uint8_t oldcount;

    HLL_DENSE_GET_REGISTER(oldcount,registers,index);
    if (count > oldcount) {
        HLL_DENSE_SET_REGISTER(registers,index,count);
        return 1;
    } else {
        return 0;
    }
}",1,4,hyperloglog.c,hllDenseSet,,false,494,504,hllDenseSet,,,6,"int hllDenseSet (uint8_t*,long,uint8_t)"
144487,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {
    long index;
    uint8_t count = hllPatLen(ele,elesize,&index);
    /* Update the register if this element produced a longer run of zeroes. */
    return hllDenseSet(registers,index,count);
}",1,1,hyperloglog.c,hllDenseAdd,,false,512,517,hllDenseAdd,,,7,"int hllDenseAdd (uint8_t*,unsigned char*,size_t)"
144508,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void hllDenseRegHisto(uint8_t *registers, int* reghisto) {
    int j;

    /* Redis default is to use 16384 registers 6 bits each. The code works
     * with other values by modifying the defines, but for our target value
     * we take a faster path with unrolled loops. */
    if (HLL_REGISTERS == 16384 && HLL_BITS == 6) {
        uint8_t *r = registers;
        unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9,
                      r10, r11, r12, r13, r14, r15;
        for (j = 0; j < 1024; j++) {
            /* Handle 16 registers per iteration. */
            r0 = r[0] & 63;
            r1 = (r[0] >> 6 | r[1] << 2) & 63;
            r2 = (r[1] >> 4 | r[2] << 4) & 63;
            r3 = (r[2] >> 2) & 63;
            r4 = r[3] & 63;
            r5 = (r[3] >> 6 | r[4] << 2) & 63;
            r6 = (r[4] >> 4 | r[5] << 4) & 63;
            r7 = (r[5] >> 2) & 63;
            r8 = r[6] & 63;
            r9 = (r[6] >> 6 | r[7] << 2) & 63;
            r10 = (r[7] >> 4 | r[8] << 4) & 63...",1,8,hyperloglog.c,hllDenseRegHisto,,false,520,575,hllDenseRegHisto,,,8,"void hllDenseRegHisto (uint8_t*,int*)"
144905,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllSparseToDense(robj *o) {
    sds sparse = o->ptr, dense;
    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
    int idx = 0, runlen, regval;
    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);

    /* If the representation is already the right one return ASAP. */
    hdr = (struct hllhdr*) sparse;
    if (hdr->encoding == HLL_DENSE) return C_OK;

    /* Create a string of the right size filled with zero bytes.
     * Note that the cached cardinality is set to 0 as a side effect
     * that is exactly the cardinality of an empty HLL. */
    dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
    hdr = (struct hllhdr*) dense;
    *hdr = *oldhdr; /* This will copy the magic and cached cardinality. */
    hdr->encoding = HLL_DENSE;

    /* Now read the sparse representation and set non-zero registers
     * accordingly. */
    p += HLL_HDR_SIZE;
    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
   ...",1,25,hyperloglog.c,hllSparseToDense,,false,585,638,hllSparseToDense,,,9,int hllSparseToDense (robj*)
145237,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllSparseSet(robj *o, long index, uint8_t count) {
    struct hllhdr *hdr;
    uint8_t oldcount, *sparse, *end, *p, *prev, *next;
    long first, span;
    long is_zero = 0, is_xzero = 0, is_val = 0, runlen = 0;

    /* If the count is too big to be representable by the sparse representation
     * switch to dense representation. */
    if (count > HLL_SPARSE_VAL_MAX_VALUE) goto promote;

    /* When updating a sparse representation, sometimes we may need to enlarge the
     * buffer for up to 3 bytes in the worst case (XZERO split into XZERO-VAL-XZERO),
     * and the following code does the enlarge job.
     * Actually, we use a greedy strategy, enlarge more than 3 bytes to avoid the need
     * for future reallocates on incremental growth. But we do not allocate more than
     * 'server.hll_sparse_max_bytes' bytes for the sparse representation.
     * If the available size of hyperloglog sds string is not enough for the increment
     * we need, we promote the hypreloglog to ...",1,16,hyperloglog.c,hllSparseSet,,false,655,907,hllSparseSet,,,10,"int hllSparseSet (robj*,long,uint8_t)"
146271,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {
    long index;
    uint8_t count = hllPatLen(ele,elesize,&index);
    /* Update the register if this element produced a longer run of zeroes. */
    return hllSparseSet(o,index,count);
}",1,1,hyperloglog.c,hllSparseAdd,,false,915,920,hllSparseAdd,,,11,"int hllSparseAdd (robj*,unsigned char*,size_t)"
146292,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void hllSparseRegHisto(uint8_t *sparse, int sparselen, int *invalid, int* reghisto) {
    int idx = 0, runlen, regval;
    uint8_t *end = sparse+sparselen, *p = sparse;

    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
            reghisto[0] += runlen;
            p++;
        } else if (HLL_SPARSE_IS_XZERO(p)) {
            runlen = HLL_SPARSE_XZERO_LEN(p);
            idx += runlen;
            reghisto[0] += runlen;
            p += 2;
        } else {
            runlen = HLL_SPARSE_VAL_LEN(p);
            regval = HLL_SPARSE_VAL_VALUE(p);
            idx += runlen;
            reghisto[regval] += runlen;
            p++;
        }
    }
    if (idx != HLL_REGISTERS && invalid) *invalid = 1;
}",1,12,hyperloglog.c,hllSparseRegHisto,,false,923,947,hllSparseRegHisto,,,12,"void hllSparseRegHisto (uint8_t*,int,int*,int*)"
146446,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void hllRawRegHisto(uint8_t *registers, int* reghisto) {
    uint64_t *word = (uint64_t*) registers;
    uint8_t *bytes;
    int j;

    for (j = 0; j < HLL_REGISTERS/8; j++) {
        if (*word == 0) {
            reghisto[0] += 8;
        } else {
            bytes = (uint8_t*) word;
            reghisto[bytes[0]]++;
            reghisto[bytes[1]]++;
            reghisto[bytes[2]]++;
            reghisto[bytes[3]]++;
            reghisto[bytes[4]]++;
            reghisto[bytes[5]]++;
            reghisto[bytes[6]]++;
            reghisto[bytes[7]]++;
        }
        word++;
    }
}",1,20,hyperloglog.c,hllRawRegHisto,,false,957,978,hllRawRegHisto,,,13,"void hllRawRegHisto (uint8_t*,int*)"
146545,METHOD,hyperloglog.c:<global>,TYPE_DECL,"double hllSigma(double x) {
    if (x == 1.) return INFINITY;
    double zPrime;
    double y = 1;
    double z = x;
    do {
        x *= x;
        zPrime = z;
        z += x * y;
        y += y;
    } while(zPrime != z);
    return z;
}",1,1,hyperloglog.c,hllSigma,,false,983,995,hllSigma,,,14,double hllSigma (double)
146587,METHOD,hyperloglog.c:<global>,TYPE_DECL,"double hllTau(double x) {
    if (x == 0. || x == 1.) return 0.;
    double zPrime;
    double y = 1.0;
    double z = 1 - x;
    do {
        x = sqrt(x);
        zPrime = z;
        y *= 0.5;
        z -= pow(1 - x, 2)*y;
    } while(zPrime != z);
    return z / 3;
}",1,1,hyperloglog.c,hllTau,,false,1000,1012,hllTau,,,15,double hllTau (double)
146642,METHOD,hyperloglog.c:<global>,TYPE_DECL,"uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
    double m = HLL_REGISTERS;
    double E;
    int j;
    /* Note that reghisto size could be just HLL_Q+2, because HLL_Q+1 is
     * the maximum frequency of the ""000...1"" sequence the hash function is
     * able to return. However it is slow to check for sanity of the
     * input: instead we history array at a safe size: overflows will
     * just write data to wrong, but correctly allocated, places. */
    int reghisto[64] = {0};

    /* Compute register histogram */
    if (hdr->encoding == HLL_DENSE) {
        hllDenseRegHisto(hdr->registers,reghisto);
    } else if (hdr->encoding == HLL_SPARSE) {
        hllSparseRegHisto(hdr->registers,
                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);
    } else if (hdr->encoding == HLL_RAW) {
        hllRawRegHisto(hdr->registers,reghisto);
    } else {
        serverPanic(""Unknown HyperLogLog encoding in hllCount()"");
    }

    /* Estimate cardinality from re...",1,15,hyperloglog.c,hllCount,,false,1025,1060,hllCount,,,16,"uint64_t hllCount (hllhdr*,int*)"
146801,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllAdd(robj *o, unsigned char *ele, size_t elesize) {
    struct hllhdr *hdr = o->ptr;
    switch(hdr->encoding) {
    case HLL_DENSE: return hllDenseAdd(hdr->registers,ele,elesize);
    case HLL_SPARSE: return hllSparseAdd(o,ele,elesize);
    default: return -1; /* Invalid representation. */
    }
}",1,9,hyperloglog.c,hllAdd,,false,1063,1070,hllAdd,,,17,"int hllAdd (robj*,unsigned char*,size_t)"
146843,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int hllMerge(uint8_t *max, robj *hll) {
    struct hllhdr *hdr = hll->ptr;
    int i;

    if (hdr->encoding == HLL_DENSE) {
        uint8_t val;

        for (i = 0; i < HLL_REGISTERS; i++) {
            HLL_DENSE_GET_REGISTER(val,hdr->registers,i);
            if (val > max[i]) max[i] = val;
        }
    } else {
        uint8_t *p = hll->ptr, *end = p + sdslen(hll->ptr);
        long runlen, regval;

        p += HLL_HDR_SIZE;
        i = 0;
        while(p < end) {
            if (HLL_SPARSE_IS_ZERO(p)) {
                runlen = HLL_SPARSE_ZERO_LEN(p);
                i += runlen;
                p++;
            } else if (HLL_SPARSE_IS_XZERO(p)) {
                runlen = HLL_SPARSE_XZERO_LEN(p);
                i += runlen;
                p += 2;
            } else {
                runlen = HLL_SPARSE_VAL_LEN(p);
                regval = HLL_SPARSE_VAL_VALUE(p);
                if ((runlen + i) > HLL_REGISTERS) break; /* Overflow. */
                while(runlen--) {
    ...",1,25,hyperloglog.c,hllMerge,,false,1080,1120,hllMerge,,,18,"int hllMerge (uint8_t*,robj*)"
147141,METHOD,hyperloglog.c:<global>,TYPE_DECL,"robj *createHLLObject(void) {
    robj *o;
    struct hllhdr *hdr;
    sds s;
    uint8_t *p;
    int sparselen = HLL_HDR_SIZE +
                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN-1)) /
                     HLL_SPARSE_XZERO_MAX_LEN)*2);
    int aux;

    /* Populate the sparse representation with as many XZERO opcodes as
     * needed to represent all the registers. */
    aux = HLL_REGISTERS;
    s = sdsnewlen(NULL,sparselen);
    p = (uint8_t*)s + HLL_HDR_SIZE;
    while(aux) {
        int xzero = HLL_SPARSE_XZERO_MAX_LEN;
        if (xzero > aux) xzero = aux;
        HLL_SPARSE_XZERO_SET(p,xzero);
        p += 2;
        aux -= xzero;
    }
    serverAssert((p-(uint8_t*)s) == sparselen);

    /* Create the actual object. */
    o = createObject(OBJ_STRING,s);
    hdr = o->ptr;
    memcpy(hdr->magic,""HYLL"",4);
    hdr->encoding = HLL_SPARSE;
    return o;
}",1,20,hyperloglog.c,createHLLObject,,false,1126,1156,createHLLObject,,,19,robj createHLLObject (void)
147298,METHOD,hyperloglog.c:<global>,TYPE_DECL,"int isHLLObjectOrReply(client *c, robj *o) {
    struct hllhdr *hdr;

    /* Key exists, check type */
    if (checkType(c,o,OBJ_STRING))
        return C_ERR; /* Error already sent. */

    if (!sdsEncodedObject(o)) goto invalid;
    if (stringObjectLen(o) < sizeof(*hdr)) goto invalid;
    hdr = o->ptr;

    /* Magic should be ""HYLL"". */
    if (hdr->magic[0] != 'H' || hdr->magic[1] != 'Y' ||
        hdr->magic[2] != 'L' || hdr->magic[3] != 'L') goto invalid;

    if (hdr->encoding > HLL_MAX_ENCODING) goto invalid;

    /* Dense representation string length should match exactly. */
    if (hdr->encoding == HLL_DENSE &&
        stringObjectLen(o) != HLL_DENSE_SIZE) goto invalid;

    /* All tests passed. */
    return C_OK;

invalid:
    addReplyError(c,""-WRONGTYPE Key is not a valid ""
               ""HyperLogLog string value."");
    return C_ERR;
}",1,22,hyperloglog.c,isHLLObjectOrReply,,false,1161,1189,isHLLObjectOrReply,,,20,"int isHLLObjectOrReply (client*,robj*)"
147435,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void pfaddCommand(client *c) {
    robj *o = lookupKeyWrite(c->db,c->argv[1]);
    struct hllhdr *hdr;
    int updated = 0, j;

    if (o == NULL) {
        /* Create the key with a string value of the exact length to
         * hold our HLL data structure. sdsnewlen() when NULL is passed
         * is guaranteed to return bytes initialized to zero. */
        o = createHLLObject();
        dbAdd(c->db,c->argv[1],o);
        updated++;
    } else {
        if (isHLLObjectOrReply(c,o) != C_OK) return;
        o = dbUnshareStringValue(c->db,c->argv[1],o);
    }
    /* Perform the low level ADD operation for every element. */
    for (j = 2; j < c->argc; j++) {
        int retval = hllAdd(o, (unsigned char*)c->argv[j]->ptr,
                               sdslen(c->argv[j]->ptr));
        switch(retval) {
        case 1:
            updated++;
            break;
        case -1:
            addReplyError(c,invalid_hll_err);
            return;
        }
    }
    hdr = o->ptr;
    if (u...",1,39,hyperloglog.c,pfaddCommand,,false,1192,1229,pfaddCommand,,,21,void pfaddCommand (client*)
147614,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void pfcountCommand(client *c) {
    robj *o;
    struct hllhdr *hdr;
    uint64_t card;

    /* Case 1: multi-key keys, cardinality of the union.
     *
     * When multiple keys are specified, PFCOUNT actually computes
     * the cardinality of the merge of the N HLLs specified. */
    if (c->argc > 2) {
        uint8_t max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;
        int j;

        /* Compute an HLL with M[i] = MAX(M[i]_j). */
        memset(max,0,sizeof(max));
        hdr = (struct hllhdr*) max;
        hdr->encoding = HLL_RAW; /* Special internal-only encoding. */
        registers = max + HLL_HDR_SIZE;
        for (j = 1; j < c->argc; j++) {
            /* Check type and size. */
            robj *o = lookupKeyRead(c->db,c->argv[j]);
            if (o == NULL) continue; /* Assume empty HLL for non existing var.*/
            if (isHLLObjectOrReply(c,o) != C_OK) return;

            /* Merge with this HLL with our 'max' HLL by setting max[i]
             * to MAX(max[i],hl...",1,20,hyperloglog.c,pfcountCommand,,false,1232,1325,pfcountCommand,,,22,void pfcountCommand (client*)
147992,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void pfmergeCommand(client *c) {
    uint8_t max[HLL_REGISTERS];
    struct hllhdr *hdr;
    int j;
    int use_dense = 0; /* Use dense representation as target? */

    /* Compute an HLL with M[i] = MAX(M[i]_j).
     * We store the maximum into the max array of registers. We'll write
     * it to the target variable later. */
    memset(max,0,sizeof(max));
    for (j = 1; j < c->argc; j++) {
        /* Check type and size. */
        robj *o = lookupKeyRead(c->db,c->argv[j]);
        if (o == NULL) continue; /* Assume empty HLL for non existing var. */
        if (isHLLObjectOrReply(c,o) != C_OK) return;

        /* If at least one involved HLL is dense, use the dense representation
         * as target ASAP to save time and avoid the conversion step. */
        hdr = o->ptr;
        if (hdr->encoding == HLL_DENSE) use_dense = 1;

        /* Merge with this HLL with our 'max' HLL by setting max[i]
         * to MAX(max[i],hll[i]). */
        if (hllMerge(max,o) == C_ERR) {
        ...",1,16,hyperloglog.c,pfmergeCommand,,false,1328,1399,pfmergeCommand,,,23,void pfmergeCommand (client*)
148250,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void pfselftestCommand(client *c) {
    unsigned int j, i;
    sds bitcounters = sdsnewlen(NULL,HLL_DENSE_SIZE);
    struct hllhdr *hdr = (struct hllhdr*) bitcounters, *hdr2;
    robj *o = NULL;
    uint8_t bytecounters[HLL_REGISTERS];

    /* Test 1: access registers.
     * The test is conceived to test that the different counters of our data
     * structure are accessible and that setting their values both result in
     * the correct value to be retained and not affect adjacent values. */
    for (j = 0; j < HLL_TEST_CYCLES; j++) {
        /* Set the HLL counters and an array of unsigned byes of the
         * same size to the same set of random values. */
        for (i = 0; i < HLL_REGISTERS; i++) {
            unsigned int r = rand() & HLL_REGISTER_MAX;

            bytecounters[i] = r;
            HLL_DENSE_SET_REGISTER(hdr->registers,i,r);
        }
        /* Check that we are able to retrieve the same values. */
        for (i = 0; i < HLL_REGISTERS; i++) {
            u...",1,37,hyperloglog.c,pfselftestCommand,,false,1407,1507,pfselftestCommand,,,24,void pfselftestCommand (client*)
148748,METHOD,hyperloglog.c:<global>,TYPE_DECL,"void pfdebugCommand(client *c) {
    char *cmd = c->argv[1]->ptr;
    struct hllhdr *hdr;
    robj *o;
    int j;

    o = lookupKeyWrite(c->db,c->argv[2]);
    if (o == NULL) {
        addReplyError(c,""The specified key does not exist"");
        return;
    }
    if (isHLLObjectOrReply(c,o) != C_OK) return;
    o = dbUnshareStringValue(c->db,c->argv[2],o);
    hdr = o->ptr;

    /* PFDEBUG GETREG <key> */
    if (!strcasecmp(cmd,""getreg"")) {
        if (c->argc != 3) goto arityerr;

        if (hdr->encoding == HLL_SPARSE) {
            if (hllSparseToDense(o) == C_ERR) {
                addReplyError(c,invalid_hll_err);
                return;
            }
            server.dirty++; /* Force propagation on encoding change. */
        }

        hdr = o->ptr;
        addReplyArrayLen(c,HLL_REGISTERS);
        for (j = 0; j < HLL_REGISTERS; j++) {
            uint8_t val;

            HLL_DENSE_GET_REGISTER(val,hdr->registers,j);
            addReplyLongLong(c,val);
        }
    ...",1,35,hyperloglog.c,pfdebugCommand,,false,1516,1617,pfdebugCommand,,,25,void pfdebugCommand (client*)
149260,METHOD,intset.c:<global>,TYPE_DECL,<global>,1,20,intset.c,intset.c:<global>,,false,1,560,<global>,,,1,
149262,METHOD,intset.c:<global>,TYPE_DECL,"static uint8_t _intsetValueEncoding(int64_t v) {
    if (v < INT32_MIN || v > INT32_MAX)
        return INTSET_ENC_INT64;
    else if (v < INT16_MIN || v > INT16_MAX)
        return INTSET_ENC_INT32;
    else
        return INTSET_ENC_INT16;
}",1,15,intset.c,_intsetValueEncoding,,false,46,53,_intsetValueEncoding,,,1,uint8_t _intsetValueEncoding (int64_t)
149304,METHOD,intset.c:<global>,TYPE_DECL,"static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
    int64_t v64;
    int32_t v32;
    int16_t v16;

    if (enc == INTSET_ENC_INT64) {
        memcpy(&v64,((int64_t*)is->contents)+pos,sizeof(v64));
        memrev64ifbe(&v64);
        return v64;
    } else if (enc == INTSET_ENC_INT32) {
        memcpy(&v32,((int32_t*)is->contents)+pos,sizeof(v32));
        memrev32ifbe(&v32);
        return v32;
    } else {
        memcpy(&v16,((int16_t*)is->contents)+pos,sizeof(v16));
        memrev16ifbe(&v16);
        return v16;
    }
}",1,15,intset.c,_intsetGetEncoded,,false,56,74,_intsetGetEncoded,,,2,"int64_t _intsetGetEncoded (intset*,int,uint8_t)"
149397,METHOD,intset.c:<global>,TYPE_DECL,"static int64_t _intsetGet(intset *is, int pos) {
    return _intsetGetEncoded(is,pos,intrev32ifbe(is->encoding));
}",1,36,intset.c,_intsetGet,,false,77,79,_intsetGet,,,3,"int64_t _intsetGet (intset*,int)"
149416,METHOD,intset.c:<global>,TYPE_DECL,"static void _intsetSet(intset *is, int pos, int64_t value) {
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        ((int64_t*)is->contents)[pos] = value;
        memrev64ifbe(((int64_t*)is->contents)+pos);
    } else if (encoding == INTSET_ENC_INT32) {
        ((int32_t*)is->contents)[pos] = value;
        memrev32ifbe(((int32_t*)is->contents)+pos);
    } else {
        ((int16_t*)is->contents)[pos] = value;
        memrev16ifbe(((int16_t*)is->contents)+pos);
    }
}",1,24,intset.c,_intsetSet,,false,82,95,_intsetSet,,,4,"void _intsetSet (intset*,int,int64_t)"
149512,METHOD,intset.c:<global>,TYPE_DECL,"intset *intsetNew(void) {
    intset *is = zmalloc(sizeof(intset));
    is->encoding = intrev32ifbe(INTSET_ENC_INT16);
    is->length = 0;
    return is;
}",1,19,intset.c,intsetNew,,false,98,103,intsetNew,,,5,intset intsetNew (void)
149539,METHOD,intset.c:<global>,TYPE_DECL,"static intset *intsetResize(intset *is, uint32_t len) {
    uint64_t size = (uint64_t)len*intrev32ifbe(is->encoding);
    assert(size <= SIZE_MAX - sizeof(intset));
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}",1,34,intset.c,intsetResize,,false,106,111,intsetResize,,,6,"intset intsetResize (intset*,uint32_t)"
149590,METHOD,intset.c:<global>,TYPE_DECL,"static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
    int64_t cur = -1;

    /* The value can never be found when the set is empty */
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        /* Check for the case where we know we cannot find the value,
         * but do know the insert position. */
        if (value > _intsetGet(is,max)) {
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is,0)) {
            if (pos) *pos = 0;
            return 0;
        }
    }

    while(max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is,mid);
        if (value > cur) {
            min = mid+1;
        } else if (value < cur) {
            max = mid-1;
        } else {
            break;
        }
    }

    if (value == cur) {
        if (pos) *pos =...",1,23,intset.c,intsetSearch,,false,117,156,intsetSearch,,,7,"uint8_t intsetSearch (intset*,int64_t,uint32_t*)"
149762,METHOD,intset.c:<global>,TYPE_DECL,"static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    int prepend = value < 0 ? 1 : 0;

    /* First set new encoding and resize */
    is->encoding = intrev32ifbe(newenc);
    is = intsetResize(is,intrev32ifbe(is->length)+1);

    /* Upgrade back-to-front so we don't overwrite values.
     * Note that the ""prepend"" variable is used to make sure we have an empty
     * space at either the beginning or the end of the intset. */
    while(length--)
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));

    /* Set the value at the beginning or the end. */
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is->length),value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}",1,21,intset.c,intsetUpgradeAndAdd,,false,159,182,intsetUpgradeAndAdd,,,8,"intset intsetUpgradeAndAdd (intset*,int64_t)"
149881,METHOD,intset.c:<global>,TYPE_DECL,"static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
    void *src, *dst;
    uint32_t bytes = intrev32ifbe(is->length)-from;
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        src = (int64_t*)is->contents+from;
        dst = (int64_t*)is->contents+to;
        bytes *= sizeof(int64_t);
    } else if (encoding == INTSET_ENC_INT32) {
        src = (int32_t*)is->contents+from;
        dst = (int32_t*)is->contents+to;
        bytes *= sizeof(int32_t);
    } else {
        src = (int16_t*)is->contents+from;
        dst = (int16_t*)is->contents+to;
        bytes *= sizeof(int16_t);
    }
    memmove(dst,src,bytes);
}",1,21,intset.c,intsetMoveTail,,false,184,203,intsetMoveTail,,,9,"void intsetMoveTail (intset*,uint32_t,uint32_t)"
150006,METHOD,intset.c:<global>,TYPE_DECL,"intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 1;

    /* Upgrade encoding if necessary. If we need to upgrade, we know that
     * this value should be either appended (if > 0) or prepended (if < 0),
     * because it lies outside the range of existing values. */
    if (valenc > intrev32ifbe(is->encoding)) {
        /* This always succeeds, so we don't need to curry *success. */
        return intsetUpgradeAndAdd(is,value);
    } else {
        /* Abort if the value is already present in the set.
         * This call will populate ""pos"" with the right position to insert
         * the value when it cannot be found. */
        if (intsetSearch(is,value,&pos)) {
            if (success) *success = 0;
            return is;
        }

        is = intsetResize(is,intrev32ifbe(is->length)+1);
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }

...",1,17,intset.c,intsetAdd,,false,206,233,intsetAdd,,,10,"intset intsetAdd (intset*,int64_t,uint8_t*)"
150117,METHOD,intset.c:<global>,TYPE_DECL,"intset *intsetRemove(intset *is, int64_t value, int *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 0;

    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {
        uint32_t len = intrev32ifbe(is->length);

        /* We know we can delete */
        if (success) *success = 1;

        /* Overwrite value with tail and update length */
        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
        is = intsetResize(is,len-1);
        is->length = intrev32ifbe(len-1);
    }
    return is;
}",1,18,intset.c,intsetRemove,,false,236,253,intsetRemove,,,11,"intset intsetRemove (intset*,int64_t,int*)"
150207,METHOD,intset.c:<global>,TYPE_DECL,"uint8_t intsetFind(intset *is, int64_t value) {
    uint8_t valenc = _intsetValueEncoding(value);
    return valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,NULL);
}",1,21,intset.c,intsetFind,,false,256,259,intsetFind,,,12,"uint8_t intsetFind (intset*,int64_t)"
150235,METHOD,intset.c:<global>,TYPE_DECL,"int64_t intsetRandom(intset *is) {
    uint32_t len = intrev32ifbe(is->length);
    assert(len); /* avoid division by zero on corrupt intset payload. */
    return _intsetGet(is,rand()%len);
}",1,19,intset.c,intsetRandom,,false,262,266,intsetRandom,,,13,int64_t intsetRandom (intset*)
150273,METHOD,intset.c:<global>,TYPE_DECL,"int64_t intsetMax(intset *is) {
    uint32_t len = intrev32ifbe(is->length);
    return _intsetGet(is, len - 1);
}",1,19,intset.c,intsetMax,,false,269,272,intsetMax,,,14,int64_t intsetMax (intset*)
150296,METHOD,intset.c:<global>,TYPE_DECL,"int64_t intsetMin(intset *is) {
    return _intsetGet(is, 0);
}",1,1,intset.c,intsetMin,,false,275,277,intsetMin,,,15,int64_t intsetMin (intset*)
150305,METHOD,intset.c:<global>,TYPE_DECL,"uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {
    if (pos < intrev32ifbe(is->length)) {
        *value = _intsetGet(is,pos);
        return 1;
    }
    return 0;
}",1,14,intset.c,intsetGet,,false,281,287,intsetGet,,,16,"uint8_t intsetGet (intset*,uint32_t,int64_t*)"
150335,METHOD,intset.c:<global>,TYPE_DECL,"uint32_t intsetLen(const intset *is) {
    return intrev32ifbe(is->length);
}",1,11,intset.c,intsetLen,,false,290,292,intsetLen,,,17,uint32_t intsetLen (intset*)
150350,METHOD,intset.c:<global>,TYPE_DECL,"size_t intsetBlobLen(intset *is) {
    return sizeof(intset)+(size_t)intrev32ifbe(is->length)*intrev32ifbe(is->encoding);
}",1,34,intset.c,intsetBlobLen,,false,295,297,intsetBlobLen,,,18,size_t intsetBlobLen (intset*)
150380,METHOD,intset.c:<global>,TYPE_DECL,"int intsetValidateIntegrity(const unsigned char *p, size_t size, int deep) {
    intset *is = (intset *)p;
    /* check that we can actually read the header. */
    if (size < sizeof(*is))
        return 0;

    uint32_t encoding = intrev32ifbe(is->encoding);

    size_t record_size;
    if (encoding == INTSET_ENC_INT64) {
        record_size = INTSET_ENC_INT64;
    } else if (encoding == INTSET_ENC_INT32) {
        record_size = INTSET_ENC_INT32;
    } else if (encoding == INTSET_ENC_INT16){
        record_size = INTSET_ENC_INT16;
    } else {
        return 0;
    }

    /* check that the size matches (all records are inside the buffer). */
    uint32_t count = intrev32ifbe(is->length);
    if (sizeof(*is) + count*record_size != size)
        return 0;

    /* check that the set is not empty. */
    if (count==0)
        return 0;

    if (!deep)
        return 1;

    /* check that there are no dup or out of order records. */
    int64_t prev = _intsetGet(is,0);
    for (uint32_t...",1,24,intset.c,intsetValidateIntegrity,,false,302,343,intsetValidateIntegrity,,,19,"int intsetValidateIntegrity (unsigned char*,size_t,int)"
150544,METHOD,intset.h:<global>,TYPE_DECL,<global>,1,20,intset.h,intset.h:<global>,,false,1,57,<global>,,,1,
150550,METHOD,<empty>,<empty>,<empty>,1,,intset.h,intset:<clinit>,,false,35,,<clinit>,,,4,
150556,METHOD,intset.h:<global>,TYPE_DECL,intset *intsetNew(void);,8,23,intset.h,intsetNew,,false,41,41,intsetNew,,,3,intset* intsetNew (void)
150561,METHOD,intset.h:<global>,TYPE_DECL,"intset *intsetAdd(intset *is, int64_t value, uint8_t *success);",8,62,intset.h,intsetAdd,,false,42,42,intsetAdd,,,4,"intset* intsetAdd (intset*,int64_t,uint8_t*)"
150568,METHOD,intset.h:<global>,TYPE_DECL,"intset *intsetRemove(intset *is, int64_t value, int *success);",8,61,intset.h,intsetRemove,,false,43,43,intsetRemove,,,5,"intset* intsetRemove (intset*,int64_t,int*)"
150575,METHOD,intset.h:<global>,TYPE_DECL,"uint8_t intsetFind(intset *is, int64_t value);",9,45,intset.h,intsetFind,,false,44,44,intsetFind,,,6,"uint8_t intsetFind (intset*,int64_t)"
150581,METHOD,intset.h:<global>,TYPE_DECL,int64_t intsetRandom(intset *is);,9,32,intset.h,intsetRandom,,false,45,45,intsetRandom,,,7,int64_t intsetRandom (intset*)
150586,METHOD,intset.h:<global>,TYPE_DECL,int64_t intsetMax(intset *is);,9,29,intset.h,intsetMax,,false,46,46,intsetMax,,,8,int64_t intsetMax (intset*)
150591,METHOD,intset.h:<global>,TYPE_DECL,int64_t intsetMin(intset *is);,9,29,intset.h,intsetMin,,false,47,47,intsetMin,,,9,int64_t intsetMin (intset*)
150596,METHOD,intset.h:<global>,TYPE_DECL,"uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);",9,59,intset.h,intsetGet,,false,48,48,intsetGet,,,10,"uint8_t intsetGet (intset*,uint32_t,int64_t*)"
150603,METHOD,intset.h:<global>,TYPE_DECL,uint32_t intsetLen(const intset *is);,10,36,intset.h,intsetLen,,false,49,49,intsetLen,,,11,uint32_t intsetLen (intset*)
150608,METHOD,intset.h:<global>,TYPE_DECL,size_t intsetBlobLen(intset *is);,8,32,intset.h,intsetBlobLen,,false,50,50,intsetBlobLen,,,12,size_t intsetBlobLen (intset*)
150613,METHOD,intset.h:<global>,TYPE_DECL,"int intsetValidateIntegrity(const unsigned char *is, size_t size, int deep);",5,75,intset.h,intsetValidateIntegrity,,false,51,51,intsetValidateIntegrity,,,13,"int intsetValidateIntegrity (unsigned char*,size_t,int)"
150627,METHOD,latency.c:<global>,TYPE_DECL,<global>,1,1,latency.c,latency.c:<global>,,false,1,739,<global>,,,1,
150629,METHOD,latency.c:<global>,TYPE_DECL,"int dictStringKeyCompare(dict *d, const void *key1, const void *key2) {
    UNUSED(d);
    return strcmp(key1,key2) == 0;
}",1,4,latency.c,dictStringKeyCompare,,false,40,43,dictStringKeyCompare,,,1,"int dictStringKeyCompare (dict*,void*,void*)"
150648,METHOD,latency.c:<global>,TYPE_DECL,"uint64_t dictStringHash(const void *key) {
    return dictGenHashFunction(key, strlen(key));
}",1,1,latency.c,dictStringHash,,false,45,47,dictStringHash,,,2,uint64_t dictStringHash (void*)
150658,METHOD,latency.c:<global>,TYPE_DECL,"void dictVanillaFree(dict *d, void *val);",6,40,latency.c,dictVanillaFree,,false,49,49,dictVanillaFree,,,3,"void dictVanillaFree (dict*,void*)"
150675,METHOD,latency.c:<global>,TYPE_DECL,"int THPGetAnonHugePagesSize(void) {
    return zmalloc_get_smap_bytes_by_field(""AnonHugePages:"",-1);
}",1,1,latency.c,THPGetAnonHugePagesSize,,false,66,68,THPGetAnonHugePagesSize,,,6,int THPGetAnonHugePagesSize (void)
150685,METHOD,latency.c:<global>,TYPE_DECL,"void latencyMonitorInit(void) {
    server.latency_events = dictCreate(&latencyTimeSeriesDictType);
}",1,1,latency.c,latencyMonitorInit,,false,75,77,latencyMonitorInit,,,7,void latencyMonitorInit (void)
150697,METHOD,latency.c:<global>,TYPE_DECL,"void latencyAddSample(const char *event, mstime_t latency) {
    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
    time_t now = time(NULL);
    int prev;

    /* Create the time series if it does not exist. */
    if (ts == NULL) {
        ts = zmalloc(sizeof(*ts));
        ts->idx = 0;
        ts->max = 0;
        memset(ts->samples,0,sizeof(ts->samples));
        dictAdd(server.latency_events,zstrdup(event),ts);
    }

    if (latency > ts->max) ts->max = latency;

    /* If the previous sample is in the same second, we update our old sample
     * if this latency is > of the old one, or just return. */
    prev = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;
    if (ts->samples[prev].time == now) {
        if (latency > ts->samples[prev].latency)
            ts->samples[prev].latency = latency;
        return;
    }

    ts->samples[ts->idx].time = now;
    ts->samples[ts->idx].latency = latency;

    ts->idx++;
    if (ts->idx == LATENCY_TS_LEN) ...",1,22,latency.c,latencyAddSample,,false,83,113,latencyAddSample,,,8,"void latencyAddSample (char*,mstime_t)"
150853,METHOD,latency.c:<global>,TYPE_DECL,"int latencyResetEvent(char *event_to_reset) {
    dictIterator *di;
    dictEntry *de;
    int resets = 0;

    di = dictGetSafeIterator(server.latency_events);
    while((de = dictNext(di)) != NULL) {
        char *event = dictGetKey(de);

        if (event_to_reset == NULL || strcasecmp(event,event_to_reset) == 0) {
            dictDelete(server.latency_events, event);
            resets++;
        }
    }
    dictReleaseIterator(di);
    return resets;
}",1,1,latency.c,latencyResetEvent,,false,120,136,latencyResetEvent,,,9,int latencyResetEvent (char*)
150905,METHOD,latency.c:<global>,TYPE_DECL,"void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {
    struct latencyTimeSeries *ts = dictFetchValue(server.latency_events,event);
    int j;
    uint64_t sum;

    ls->all_time_high = ts ? ts->max : 0;
    ls->avg = 0;
    ls->min = 0;
    ls->max = 0;
    ls->mad = 0;
    ls->samples = 0;
    ls->period = 0;
    if (!ts) return;

    /* First pass, populate everything but the MAD. */
    sum = 0;
    for (j = 0; j < LATENCY_TS_LEN; j++) {
        if (ts->samples[j].time == 0) continue;
        ls->samples++;
        if (ls->samples == 1) {
            ls->min = ls->max = ts->samples[j].latency;
        } else {
            if (ls->min > ts->samples[j].latency)
                ls->min = ts->samples[j].latency;
            if (ls->max < ts->samples[j].latency)
                ls->max = ts->samples[j].latency;
        }
        sum += ts->samples[j].latency;

        /* Track the oldest event time in ls->period. */
        if (ls->period == 0 || ts->samples[j].time <...",1,20,latency.c,analyzeLatencyForEvent,,false,145,199,analyzeLatencyForEvent,,,10,"void analyzeLatencyForEvent (char*,latencyStats*)"
151215,METHOD,latency.c:<global>,TYPE_DECL,"sds createLatencyReport(void) {
    sds report = sdsempty();
    int advise_better_vm = 0;       /* Better virtual machines. */
    int advise_slowlog_enabled = 0; /* Enable slowlog. */
    int advise_slowlog_tuning = 0;  /* Reconfigure slowlog. */
    int advise_slowlog_inspect = 0; /* Check your slowlog. */
    int advise_disk_contention = 0; /* Try to lower disk contention. */
    int advise_scheduler = 0;       /* Intrinsic latency. */
    int advise_data_writeback = 0;  /* data=writeback. */
    int advise_no_appendfsync = 0;  /* don't fsync during rewrites. */
    int advise_local_disk = 0;      /* Avoid remote disks. */
    int advise_ssd = 0;             /* Use an SSD drive. */
    int advise_write_load_info = 0; /* Print info about AOF and write load. */
    int advise_hz = 0;              /* Use higher HZ. */
    int advise_large_objects = 0;   /* Deletion of large objects. */
    int advise_mass_eviction = 0;   /* Avoid mass eviction of keys. */
    int advise_relax_fsync...",1,8,latency.c,createLatencyReport,,false,202,457,createLatencyReport,,,11,sds createLatencyReport (void)
151901,METHOD,latency.c:<global>,TYPE_DECL,"void fillCommandCDF(client *c, struct hdr_histogram* histogram) {
    addReplyMapLen(c,2);
    addReplyBulkCString(c,""calls"");
    addReplyLongLong(c,(long long) histogram->total_count);
    addReplyBulkCString(c,""histogram_usec"");
    void *replylen = addReplyDeferredLen(c);
    int samples = 0;
    struct hdr_iter iter;
    hdr_iter_log_init(&iter,histogram,1024,2);
    int64_t previous_count = 0;
    while (hdr_iter_next(&iter)) {
        const int64_t micros = iter.highest_equivalent_value / 1000;
        const int64_t cumulative_count = iter.cumulative_count;
        if(cumulative_count > previous_count){
            addReplyLongLong(c,(long long) micros);
            addReplyLongLong(c,(long long) cumulative_count);
            samples++;
        }
        previous_count = cumulative_count;
    }
    setDeferredMapLen(c,replylen,samples);
}",1,1,latency.c,fillCommandCDF,,false,468,489,fillCommandCDF,,,12,"void fillCommandCDF (client*,hdr_histogram*)"
151986,METHOD,latency.c:<global>,TYPE_DECL,"void latencyAllCommandsFillCDF(client *c, dict *commands, int *command_with_data) {
    dictIterator *di = dictGetSafeIterator(commands);
    dictEntry *de;
    struct redisCommand *cmd;

    while((de = dictNext(di)) != NULL) {
        cmd = (struct redisCommand *) dictGetVal(de);
        if (cmd->latency_histogram) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            fillCommandCDF(c, cmd->latency_histogram);
            (*command_with_data)++;
        }

        if (cmd->subcommands) {
            latencyAllCommandsFillCDF(c, cmd->subcommands_dict, command_with_data);
        }
    }
    dictReleaseIterator(di);
}",1,1,latency.c,latencyAllCommandsFillCDF,,false,493,511,latencyAllCommandsFillCDF,,,13,"void latencyAllCommandsFillCDF (client*,dict*,int*)"
152049,METHOD,latency.c:<global>,TYPE_DECL,"void latencySpecificCommandsFillCDF(client *c) {
    void *replylen = addReplyDeferredLen(c);
    int command_with_data = 0;
    for (int j = 2; j < c->argc; j++){
        struct redisCommand *cmd = lookupCommandBySds(c->argv[j]->ptr);
        /* If the command does not exist we skip the reply */
        if (cmd == NULL) {
            continue;
        }

        if (cmd->latency_histogram) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            fillCommandCDF(c, cmd->latency_histogram);
            command_with_data++;
        }

        if (cmd->subcommands_dict) {
            dictEntry *de;
            dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);

            while ((de = dictNext(di)) != NULL) {
                struct redisCommand *sub = dictGetVal(de);
                if (sub->latency_histogram) {
                    addReplyBulkCBuffer(c, sub->fullname, sdslen(sub->fullname));
                    fillCommandCDF(c, sub->latency_...",1,1,latency.c,latencySpecificCommandsFillCDF,,false,515,547,latencySpecificCommandsFillCDF,,,14,void latencySpecificCommandsFillCDF (client*)
152168,METHOD,latency.c:<global>,TYPE_DECL,"void latencyCommandReplyWithSamples(client *c, struct latencyTimeSeries *ts) {
    void *replylen = addReplyDeferredLen(c);
    int samples = 0, j;

    for (j = 0; j < LATENCY_TS_LEN; j++) {
        int i = (ts->idx + j) % LATENCY_TS_LEN;

        if (ts->samples[i].time == 0) continue;
        addReplyArrayLen(c,2);
        addReplyLongLong(c,ts->samples[i].time);
        addReplyLongLong(c,ts->samples[i].latency);
        samples++;
    }
    setDeferredArrayLen(c,replylen,samples);
}",1,20,latency.c,latencyCommandReplyWithSamples,,false,551,565,latencyCommandReplyWithSamples,,,15,"void latencyCommandReplyWithSamples (client*,latencyTimeSeries*)"
152248,METHOD,latency.c:<global>,TYPE_DECL,"void latencyCommandReplyWithLatestEvents(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c,dictSize(server.latency_events));
    di = dictGetIterator(server.latency_events);
    while((de = dictNext(di)) != NULL) {
        char *event = dictGetKey(de);
        struct latencyTimeSeries *ts = dictGetVal(de);
        int last = (ts->idx + LATENCY_TS_LEN - 1) % LATENCY_TS_LEN;

        addReplyArrayLen(c,4);
        addReplyBulkCString(c,event);
        addReplyLongLong(c,ts->samples[last].time);
        addReplyLongLong(c,ts->samples[last].latency);
        addReplyLongLong(c,ts->max);
    }
    dictReleaseIterator(di);
}",1,23,latency.c,latencyCommandReplyWithLatestEvents,,false,569,587,latencyCommandReplyWithLatestEvents,,,16,void latencyCommandReplyWithLatestEvents (client*)
152348,METHOD,latency.c:<global>,TYPE_DECL,"sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {
    int j;
    struct sequence *seq = createSparklineSequence();
    sds graph = sdsempty();
    uint32_t min = 0, max = 0;

    for (j = 0; j < LATENCY_TS_LEN; j++) {
        int i = (ts->idx + j) % LATENCY_TS_LEN;
        int elapsed;
        char buf[64];

        if (ts->samples[i].time == 0) continue;
        /* Update min and max. */
        if (seq->length == 0) {
            min = max = ts->samples[i].latency;
        } else {
            if (ts->samples[i].latency > max) max = ts->samples[i].latency;
            if (ts->samples[i].latency < min) min = ts->samples[i].latency;
        }
        /* Use as label the number of seconds / minutes / hours / days
         * ago the event happened. */
        elapsed = time(NULL) - ts->samples[i].time;
        if (elapsed < 60)
            snprintf(buf,sizeof(buf),""%ds"",elapsed);
        else if (elapsed < 3600)
            snprintf(buf,sizeof(buf),""%dm"",ela...",1,20,latency.c,latencyCommandGenSparkeline,,false,590,632,latencyCommandGenSparkeline,,,17,"sds latencyCommandGenSparkeline (char*,latencyTimeSeries*)"
152604,METHOD,latency.c:<global>,TYPE_DECL,"void latencyCommand(client *c) {
    struct latencyTimeSeries *ts;

    if (!strcasecmp(c->argv[1]->ptr,""history"") && c->argc == 3) {
        /* LATENCY HISTORY <event> */
        ts = dictFetchValue(server.latency_events,c->argv[2]->ptr);
        if (ts == NULL) {
            addReplyArrayLen(c,0);
        } else {
            latencyCommandReplyWithSamples(c,ts);
        }
    } else if (!strcasecmp(c->argv[1]->ptr,""graph"") && c->argc == 3) {
        /* LATENCY GRAPH <event> */
        sds graph;
        dictEntry *de;
        char *event;

        de = dictFind(server.latency_events,c->argv[2]->ptr);
        if (de == NULL) goto nodataerr;
        ts = dictGetVal(de);
        event = dictGetKey(de);

        graph = latencyCommandGenSparkeline(event,ts);
        addReplyVerbatim(c,graph,sdslen(graph),""txt"");
        sdsfree(graph);
    } else if (!strcasecmp(c->argv[1]->ptr,""latest"") && c->argc == 2) {
        /* LATENCY LATEST */
        latencyCommandReplyWithLatestEvents(c);
 ...",1,1,latency.c,latencyCommand,,false,643,727,latencyCommand,,,18,void latencyCommand (client*)
152945,METHOD,latency.c:<global>,TYPE_DECL,"void durationAddSample(int type, monotime duration) {
    if (type >= EL_DURATION_TYPE_NUM) {
        return;
    }
    durationStats* ds = &server.duration_stats[type];
    ds->cnt++;
    ds->sum += duration;
    if (duration > ds->max) {
        ds->max = duration;
    }
}",1,1,latency.c,durationAddSample,,false,729,739,durationAddSample,,,19,"void durationAddSample (int,monotime)"
152990,METHOD,latency.h:<global>,TYPE_DECL,<global>,1,33,latency.h,latency.h:<global>,,false,1,108,<global>,,,1,
153000,METHOD,<empty>,<empty>,<empty>,1,,latency.h,latencyTimeSeries:<clinit>,,false,47,,<clinit>,,,5,
153016,METHOD,latency.h:<global>,TYPE_DECL,void latencyMonitorInit(void);,6,29,latency.h,latencyMonitorInit,,false,64,64,latencyMonitorInit,,,4,void latencyMonitorInit (void)
153021,METHOD,latency.h:<global>,TYPE_DECL,"void latencyAddSample(const char *event, mstime_t latency);",6,58,latency.h,latencyAddSample,,false,65,65,latencyAddSample,,,5,"void latencyAddSample (char*,mstime_t)"
153038,METHOD,<empty>,<empty>,<empty>,1,,latency.h,DurationType:<clinit>,,false,98,,<clinit>,,,6,
153046,METHOD,latency.h:<global>,TYPE_DECL,"void durationAddSample(int type, monotime duration);",6,51,latency.h,durationAddSample,,false,106,106,durationAddSample,,,10,"void durationAddSample (int,monotime)"
153063,METHOD,lazyfree.c:<global>,TYPE_DECL,<global>,1,1,server.h,lazyfree.c:<global>,,false,1,227,<global>,,,1,
153073,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyfreeFreeObject(void *args[]) {
    robj *o = (robj *) args[0];
    decrRefCount(o);
    atomicDecr(lazyfree_objects,1);
    atomicIncr(lazyfreed_objects,1);
}",1,1,lazyfree.c,lazyfreeFreeObject,,false,11,16,lazyfreeFreeObject,,,5,void lazyfreeFreeObject (void[]*)
153094,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyfreeFreeDatabase(void *args[]) {
    dict *ht1 = (dict *) args[0];
    dict *ht2 = (dict *) args[1];

    size_t numkeys = dictSize(ht1);
    dictRelease(ht1);
    dictRelease(ht2);
    atomicDecr(lazyfree_objects,numkeys);
    atomicIncr(lazyfreed_objects,numkeys);
}",1,21,lazyfree.c,lazyfreeFreeDatabase,,false,21,30,lazyfreeFreeDatabase,,,6,void lazyfreeFreeDatabase (void[]*)
153142,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyFreeTrackingTable(void *args[]) {
    rax *rt = args[0];
    size_t len = rt->numele;
    freeTrackingRadixTree(rt);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",1,1,lazyfree.c,lazyFreeTrackingTable,,false,33,39,lazyFreeTrackingTable,,,7,void lazyFreeTrackingTable (void[]*)
153167,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyFreeLuaScripts(void *args[]) {
    dict *lua_scripts = args[0];
    long long len = dictSize(lua_scripts);
    dictRelease(lua_scripts);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",1,20,lazyfree.c,lazyFreeLuaScripts,,false,42,48,lazyFreeLuaScripts,,,8,void lazyFreeLuaScripts (void[]*)
153203,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyFreeFunctionsCtx(void *args[]) {
    functionsLibCtx *functions_lib_ctx = args[0];
    size_t len = functionsLibCtxfunctionsLen(functions_lib_ctx);
    functionsLibCtxFree(functions_lib_ctx);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",1,1,lazyfree.c,lazyFreeFunctionsCtx,,false,51,57,lazyFreeFunctionsCtx,,,9,void lazyFreeFunctionsCtx (void[]*)
153227,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyFreeReplicationBacklogRefMem(void *args[]) {
    list *blocks = args[0];
    rax *index = args[1];
    long long len = listLength(blocks);
    len += raxSize(index);
    listRelease(blocks);
    raxFree(index);
    atomicDecr(lazyfree_objects,len);
    atomicIncr(lazyfreed_objects,len);
}",1,20,lazyfree.c,lazyFreeReplicationBacklogRefMem,,false,60,69,lazyFreeReplicationBacklogRefMem,,,10,void lazyFreeReplicationBacklogRefMem (void[]*)
153267,METHOD,lazyfree.c:<global>,TYPE_DECL,"size_t lazyfreeGetPendingObjectsCount(void) {
    size_t aux;
    atomicGet(lazyfree_objects,aux);
    return aux;
}",1,1,lazyfree.c,lazyfreeGetPendingObjectsCount,,false,72,76,lazyfreeGetPendingObjectsCount,,,11,size_t lazyfreeGetPendingObjectsCount (void)
153278,METHOD,lazyfree.c:<global>,TYPE_DECL,"size_t lazyfreeGetFreedObjectsCount(void) {
    size_t aux;
    atomicGet(lazyfreed_objects,aux);
    return aux;
}",1,1,lazyfree.c,lazyfreeGetFreedObjectsCount,,false,79,83,lazyfreeGetFreedObjectsCount,,,12,size_t lazyfreeGetFreedObjectsCount (void)
153289,METHOD,lazyfree.c:<global>,TYPE_DECL,"void lazyfreeResetStats(void) {
    atomicSet(lazyfreed_objects,0);
}",1,1,lazyfree.c,lazyfreeResetStats,,false,85,87,lazyfreeResetStats,,,13,void lazyfreeResetStats (void)
153297,METHOD,lazyfree.c:<global>,TYPE_DECL,"size_t lazyfreeGetFreeEffort(robj *key, robj *obj, int dbid) {
    if (obj->type == OBJ_LIST && obj->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = obj->ptr;
        return ql->len;
    } else if (obj->type == OBJ_SET && obj->encoding == OBJ_ENCODING_HT) {
        dict *ht = obj->ptr;
        return dictSize(ht);
    } else if (obj->type == OBJ_ZSET && obj->encoding == OBJ_ENCODING_SKIPLIST){
        zset *zs = obj->ptr;
        return zs->zsl->length;
    } else if (obj->type == OBJ_HASH && obj->encoding == OBJ_ENCODING_HT) {
        dict *ht = obj->ptr;
        return dictSize(ht);
    } else if (obj->type == OBJ_STREAM) {
        size_t effort = 0;
        stream *s = obj->ptr;

        /* Make a best effort estimate to maintain constant runtime. Every macro
         * node in the Stream is one allocation. */
        effort += s->rax->numnodes;

        /* Every consumer group is an allocation and so are the entries in its
         * PEL. We use size of the first g...",1,21,lazyfree.c,lazyfreeGetFreeEffort,,false,104,149,lazyfreeGetFreeEffort,,,14,"size_t lazyfreeGetFreeEffort (robj*,robj*,int)"
153565,METHOD,lazyfree.c:<global>,TYPE_DECL,"void freeObjAsync(robj *key, robj *obj, int dbid) {
    size_t free_effort = lazyfreeGetFreeEffort(key,obj,dbid);
    /* Note that if the object is shared, to reclaim it now it is not
     * possible. This rarely happens, however sometimes the implementation
     * of parts of the Redis core may call incrRefCount() to protect
     * objects, and then call dbDelete(). */
    if (free_effort > LAZYFREE_THRESHOLD && obj->refcount == 1) {
        atomicIncr(lazyfree_objects,1);
        bioCreateLazyFreeJob(lazyfreeFreeObject,1,obj);
    } else {
        decrRefCount(obj);
    }
}",1,22,lazyfree.c,freeObjAsync,,false,159,171,freeObjAsync,,,15,"void freeObjAsync (robj*,robj*,int)"
153603,METHOD,lazyfree.c:<global>,TYPE_DECL,"void emptyDbAsync(redisDb *db) {
    dict *oldht1 = db->dict, *oldht2 = db->expires;
    db->dict = dictCreate(&dbDictType);
    db->expires = dictCreate(&dbExpiresDictType);
    atomicIncr(lazyfree_objects,dictSize(oldht1));
    bioCreateLazyFreeJob(lazyfreeFreeDatabase,2,oldht1,oldht2);
}",1,32,lazyfree.c,emptyDbAsync,,false,176,182,emptyDbAsync,,,16,void emptyDbAsync (redisDb*)
153655,METHOD,lazyfree.c:<global>,TYPE_DECL,"void freeTrackingRadixTreeAsync(rax *tracking) {
    /* Because this rax has only keys and no values so we use numnodes. */
    if (tracking->numnodes > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,tracking->numele);
        bioCreateLazyFreeJob(lazyFreeTrackingTable,1,tracking);
    } else {
        freeTrackingRadixTree(tracking);
    }
}",1,29,lazyfree.c,freeTrackingRadixTreeAsync,,false,186,194,freeTrackingRadixTreeAsync,,,17,void freeTrackingRadixTreeAsync (rax*)
153682,METHOD,lazyfree.c:<global>,TYPE_DECL,"void freeLuaScriptsAsync(dict *lua_scripts) {
    if (dictSize(lua_scripts) > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,dictSize(lua_scripts));
        bioCreateLazyFreeJob(lazyFreeLuaScripts,1,lua_scripts);
    } else {
        dictRelease(lua_scripts);
    }
}",1,8,lazyfree.c,freeLuaScriptsAsync,,false,197,204,freeLuaScriptsAsync,,,18,void freeLuaScriptsAsync (dict*)
153731,METHOD,lazyfree.c:<global>,TYPE_DECL,"void freeFunctionsAsync(functionsLibCtx *functions_lib_ctx) {
    if (functionsLibCtxfunctionsLen(functions_lib_ctx) > LAZYFREE_THRESHOLD) {
        atomicIncr(lazyfree_objects,functionsLibCtxfunctionsLen(functions_lib_ctx));
        bioCreateLazyFreeJob(lazyFreeFunctionsCtx,1,functions_lib_ctx);
    } else {
        functionsLibCtxFree(functions_lib_ctx);
    }
}",1,57,lazyfree.c,freeFunctionsAsync,,false,207,214,freeFunctionsAsync,,,19,void freeFunctionsAsync (functionsLibCtx*)
153756,METHOD,lazyfree.c:<global>,TYPE_DECL,"void freeReplicationBacklogRefMemAsync(list *blocks, rax *index) {
    if (listLength(blocks) > LAZYFREE_THRESHOLD ||
        raxSize(index) > LAZYFREE_THRESHOLD)
    {
        atomicIncr(lazyfree_objects,listLength(blocks)+raxSize(index));
        bioCreateLazyFreeJob(lazyFreeReplicationBacklogRefMem,2,blocks,index);
    } else {
        listRelease(blocks);
        raxFree(index);
    }
}",1,8,lazyfree.c,freeReplicationBacklogRefMemAsync,,false,217,227,freeReplicationBacklogRefMemAsync,,,20,"void freeReplicationBacklogRefMemAsync (list*,rax*)"
153834,METHOD,listpack.c:<global>,TYPE_DECL,<global>,1,1,listpack.c,listpack.c:<global>,,false,1,2660,<global>,,,1,
153836,METHOD,listpack.c:<global>,TYPE_DECL,"static inline void lpAssertValidEntry(unsigned char* lp, size_t lpbytes, unsigned char *p);",20,90,listpack.c,lpAssertValidEntry,,false,140,140,lpAssertValidEntry,,,1,"void lpAssertValidEntry (unsigned char*,size_t,unsigned char*)"
153843,METHOD,listpack.c:<global>,TYPE_DECL,"int lpSafeToAdd(unsigned char* lp, size_t add) {
    size_t len = lp? lpGetTotalBytes(lp): 0;
    if (len + add > LISTPACK_MAX_SAFETY_SIZE)
        return 0;
    return 1;
}",1,21,listpack.c,lpSafeToAdd,,false,145,150,lpSafeToAdd,,,2,"int lpSafeToAdd (unsigned char*,size_t)"
153900,METHOD,listpack.c:<global>,TYPE_DECL,"int lpStringToInt64(const char *s, unsigned long slen, int64_t *value) {
    const char *p = s;
    unsigned long plen = 0;
    int negative = 0;
    uint64_t v;

    /* Abort if length indicates this cannot possibly be an int */
    if (slen == 0 || slen >= LONG_STR_SIZE)
        return 0;

    /* Special case: first and only digit is 0. */
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }

    if (p[0] == '-') {
        negative = 1;
        p++; plen++;

        /* Abort on only a negative sign. */
        if (plen == slen)
            return 0;
    }

    /* First digit should be 1-9, otherwise the string should just be 0. */
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else {
        return 0;
    }

    while (plen < slen && p[0] >= '0' && p[0] <= '9') {
        if (v > (UINT64_MAX / 10)) /* Overflow. */
            return 0;
        v *= 10;

        if (v > (UINT64_MAX - (p[0]-'0'))) /...",1,29,listpack.c,lpStringToInt64,,false,176,235,lpStringToInt64,,,3,"int lpStringToInt64 (char*,long unsigned,int64_t*)"
154110,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpNew(size_t capacity) {
    unsigned char *lp = lp_malloc(capacity > LP_HDR_SIZE+1 ? capacity : LP_HDR_SIZE+1);
    if (lp == NULL) return NULL;
    lpSetTotalBytes(lp,LP_HDR_SIZE+1);
    lpSetNumElements(lp,0);
    lp[LP_HDR_SIZE] = LP_EOF;
    return lp;
}",1,24,listpack.c,lpNew,,false,242,249,lpNew,,,4,unsigned char* lpNew (size_t)
154221,METHOD,listpack.c:<global>,TYPE_DECL,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}",1,4,listpack.c,lpFree,,false,252,254,lpFree,,,5,void lpFree (unsigned char*)
154230,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char* lpShrinkToFit(unsigned char *lp) {
    size_t size = lpGetTotalBytes(lp);
    if (size < lp_malloc_size(lp)) {
        return lp_realloc(lp, size);
    } else {
        return lp;
    }
}",1,18,listpack.c,lpShrinkToFit,,false,257,264,lpShrinkToFit,,,6,unsigned char* lpShrinkToFit (unsigned char*)
154289,METHOD,listpack.c:<global>,TYPE_DECL,"static inline void lpEncodeIntegerGetType(int64_t v, unsigned char *intenc, uint64_t *enclen) {
    if (v >= 0 && v <= 127) {
        /* Single byte 0-127 integer. */
        intenc[0] = v;
        *enclen = 1;
    } else if (v >= -4096 && v <= 4095) {
        /* 13 bit integer. */
        if (v < 0) v = ((int64_t)1<<13)+v;
        intenc[0] = (v>>8)|LP_ENCODING_13BIT_INT;
        intenc[1] = v&0xff;
        *enclen = 2;
    } else if (v >= -32768 && v <= 32767) {
        /* 16 bit integer. */
        if (v < 0) v = ((int64_t)1<<16)+v;
        intenc[0] = LP_ENCODING_16BIT_INT;
        intenc[1] = v&0xff;
        intenc[2] = v>>8;
        *enclen = 3;
    } else if (v >= -8388608 && v <= 8388607) {
        /* 24 bit integer. */
        if (v < 0) v = ((int64_t)1<<24)+v;
        intenc[0] = LP_ENCODING_24BIT_INT;
        intenc[1] = v&0xff;
        intenc[2] = (v>>8)&0xff;
        intenc[3] = v>>16;
        *enclen = 4;
    } else if (v >= -2147483648 && v <= 2147483647) {
        /*...",1,27,listpack.c,lpEncodeIntegerGetType,,false,267,316,lpEncodeIntegerGetType,,,7,"void lpEncodeIntegerGetType (int64_t,unsigned char*,uint64_t*)"
154627,METHOD,listpack.c:<global>,TYPE_DECL,"static inline int lpEncodeGetType(unsigned char *ele, uint32_t size, unsigned char *intenc, uint64_t *enclen) {
    int64_t v;
    if (lpStringToInt64((const char*)ele, size, &v)) {
        lpEncodeIntegerGetType(v, intenc, enclen);
        return LP_ENCODING_INT;
    } else {
        if (size < 64) *enclen = 1+size;
        else if (size < 4096) *enclen = 2+size;
        else *enclen = 5+(uint64_t)size;
        return LP_ENCODING_STRING;
    }
}",1,15,listpack.c,lpEncodeGetType,,false,329,340,lpEncodeGetType,,,8,"int lpEncodeGetType (unsigned char*,uint32_t,unsigned char*,uint64_t*)"
154693,METHOD,listpack.c:<global>,TYPE_DECL,"static inline unsigned long lpEncodeBacklen(unsigned char *buf, uint64_t l) {
    if (l <= 127) {
        if (buf) buf[0] = l;
        return 1;
    } else if (l < 16383) {
        if (buf) {
            buf[0] = l>>7;
            buf[1] = (l&127)|128;
        }
        return 2;
    } else if (l < 2097151) {
        if (buf) {
            buf[0] = l>>14;
            buf[1] = ((l>>7)&127)|128;
            buf[2] = (l&127)|128;
        }
        return 3;
    } else if (l < 268435455) {
        if (buf) {
            buf[0] = l>>21;
            buf[1] = ((l>>14)&127)|128;
            buf[2] = ((l>>7)&127)|128;
            buf[3] = (l&127)|128;
        }
        return 4;
    } else {
        if (buf) {
            buf[0] = l>>28;
            buf[1] = ((l>>21)&127)|128;
            buf[2] = ((l>>14)&127)|128;
            buf[3] = ((l>>7)&127)|128;
            buf[4] = (l&127)|128;
        }
        return 5;
    }
}",1,1,listpack.c,lpEncodeBacklen,,false,347,382,lpEncodeBacklen,,,9,"unsigned long lpEncodeBacklen (unsigned char*,uint64_t)"
154887,METHOD,listpack.c:<global>,TYPE_DECL,"static inline uint64_t lpDecodeBacklen(unsigned char *p) {
    uint64_t val = 0;
    uint64_t shift = 0;
    do {
        val |= (uint64_t)(p[0] & 127) << shift;
        if (!(p[0] & 128)) break;
        shift += 7;
        p--;
        if (shift > 28) return UINT64_MAX;
    } while(1);
    return val;
}",1,1,listpack.c,lpDecodeBacklen,,false,386,397,lpDecodeBacklen,,,10,uint64_t lpDecodeBacklen (unsigned char*)
154936,METHOD,listpack.c:<global>,TYPE_DECL,"static inline void lpEncodeString(unsigned char *buf, unsigned char *s, uint32_t len) {
    if (len < 64) {
        buf[0] = len | LP_ENCODING_6BIT_STR;
        memcpy(buf+1,s,len);
    } else if (len < 4096) {
        buf[0] = (len >> 8) | LP_ENCODING_12BIT_STR;
        buf[1] = len & 0xff;
        memcpy(buf+2,s,len);
    } else {
        buf[0] = LP_ENCODING_32BIT_STR;
        buf[1] = len & 0xff;
        buf[2] = (len >> 8) & 0xff;
        buf[3] = (len >> 16) & 0xff;
        buf[4] = (len >> 24) & 0xff;
        memcpy(buf+5,s,len);
    }
}",1,23,listpack.c,lpEncodeString,,false,403,419,lpEncodeString,,,11,"void lpEncodeString (unsigned char*,unsigned char*,uint32_t)"
155043,METHOD,listpack.c:<global>,TYPE_DECL,"static inline uint32_t lpCurrentEncodedSizeUnsafe(unsigned char *p) {
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1+LP_ENCODING_6BIT_STR_LEN(p);
    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 2;
    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 3;
    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 4;
    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 5;
    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 9;
    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2+LP_ENCODING_12BIT_STR_LEN(p);
    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5+LP_ENCODING_32BIT_STR_LEN(p);
    if (p[0] == LP_EOF) return 1;
    return 0;
}",1,8,listpack.c,lpCurrentEncodedSizeUnsafe,,false,428,440,lpCurrentEncodedSizeUnsafe,,,12,uint32_t lpCurrentEncodedSizeUnsafe (unsigned char*)
155260,METHOD,listpack.c:<global>,TYPE_DECL,"static inline uint32_t lpCurrentEncodedSizeBytes(unsigned char *p) {
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) return 1;
    if (LP_ENCODING_IS_6BIT_STR(p[0])) return 1;
    if (LP_ENCODING_IS_13BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_16BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_24BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_32BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_64BIT_INT(p[0])) return 1;
    if (LP_ENCODING_IS_12BIT_STR(p[0])) return 2;
    if (LP_ENCODING_IS_32BIT_STR(p[0])) return 5;
    if (p[0] == LP_EOF) return 1;
    return 0;
}",1,8,listpack.c,lpCurrentEncodedSizeBytes,,false,446,458,lpCurrentEncodedSizeBytes,,,13,uint32_t lpCurrentEncodedSizeBytes (unsigned char*)
155422,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpSkip(unsigned char *p) {
    unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p);
    entrylen += lpEncodeBacklen(NULL,entrylen);
    p += entrylen;
    return p;
}",1,1,listpack.c,lpSkip,,false,464,469,lpSkip,,,14,unsigned char* lpSkip (unsigned char*)
155442,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpNext(unsigned char *lp, unsigned char *p) {
    assert(p);
    p = lpSkip(p);
    if (p[0] == LP_EOF) return NULL;
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",1,4,listpack.c,lpNext,,false,474,480,lpNext,,,15,"unsigned char* lpNext (unsigned char*,unsigned char*)"
155485,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpPrev(unsigned char *lp, unsigned char *p) {
    assert(p);
    if (p-lp == LP_HDR_SIZE) return NULL;
    p--; /* Seek the first backlen byte of the last element. */
    uint64_t prevlen = lpDecodeBacklen(p);
    prevlen += lpEncodeBacklen(NULL,prevlen);
    p -= prevlen-1; /* Seek the first byte of the previous entry. */
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",1,4,listpack.c,lpPrev,,false,485,494,lpPrev,,,16,"unsigned char* lpPrev (unsigned char*,unsigned char*)"
155541,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpFirst(unsigned char *lp) {
    unsigned char *p = lp + LP_HDR_SIZE; /* Skip the header. */
    if (p[0] == LP_EOF) return NULL;
    lpAssertValidEntry(lp, lpBytes(lp), p);
    return p;
}",1,28,listpack.c,lpFirst,,false,498,503,lpFirst,,,17,unsigned char* lpFirst (unsigned char*)
155572,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpLast(unsigned char *lp) {
    unsigned char *p = lp+lpGetTotalBytes(lp)-1; /* Seek EOF element. */
    return lpPrev(lp,p); /* Will return NULL if EOF is the only element. */
}",1,26,listpack.c,lpLast,,false,507,510,lpLast,,,18,unsigned char* lpLast (unsigned char*)
155618,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned long lpLength(unsigned char *lp) {
    uint32_t numele = lpGetNumElements(lp);
    if (numele != LP_HDR_NUMELE_UNKNOWN) return numele;

    /* Too many elements inside the listpack. We need to scan in order
     * to get the total number. */
    uint32_t count = 0;
    unsigned char *p = lpFirst(lp);
    while(p) {
        count++;
        p = lpNext(lp,p);
    }

    /* If the count is again within range of the header numele field,
     * set it. */
    if (count < LP_HDR_NUMELE_UNKNOWN) lpSetNumElements(lp,count);
    return count;
}",1,22,listpack.c,lpLength,,false,517,534,lpLength,,,19,unsigned long lpLength (unsigned char*)
155702,METHOD,listpack.c:<global>,TYPE_DECL,"static inline unsigned char *lpGetWithSize(unsigned char *p, int64_t *count, unsigned char *intbuf, uint64_t *entry_size) {
    int64_t val;
    uint64_t uval, negstart, negmax;

    assert(p); /* assertion for valgrind (avoid NPD) */
    if (LP_ENCODING_IS_7BIT_UINT(p[0])) {
        negstart = UINT64_MAX; /* 7 bit ints are always positive. */
        negmax = 0;
        uval = p[0] & 0x7f;
        if (entry_size) *entry_size = LP_ENCODING_7BIT_UINT_ENTRY_SIZE;
    } else if (LP_ENCODING_IS_6BIT_STR(p[0])) {
        *count = LP_ENCODING_6BIT_STR_LEN(p);
        if (entry_size) *entry_size = 1 + *count + lpEncodeBacklen(NULL, *count + 1);
        return p+1;
    } else if (LP_ENCODING_IS_13BIT_INT(p[0])) {
        uval = ((p[0]&0x1f)<<8) | p[1];
        negstart = (uint64_t)1<<12;
        negmax = 8191;
        if (entry_size) *entry_size = LP_ENCODING_13BIT_INT_ENTRY_SIZE;
    } else if (LP_ENCODING_IS_16BIT_INT(p[0])) {
        uval = (uint64_t)p[1] |
               (uint64_t)p[2]<...",1,4,listpack.c,lpGetWithSize,,false,572,660,lpGetWithSize,,,20,"unsigned char* lpGetWithSize (unsigned char*,int64_t*,unsigned char*,uint64_t*)"
156324,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf) {
    return lpGetWithSize(p, count, intbuf, NULL);
}",1,1,listpack.c,lpGet,,false,662,664,lpGet,,,21,"unsigned char* lpGet (unsigned char*,int64_t*,unsigned char*)"
156337,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpGetValue(unsigned char *p, unsigned int *slen, long long *lval) {
    unsigned char *vstr;
    int64_t ele_len;

    vstr = lpGet(p, &ele_len, NULL);
    if (vstr) {
        *slen = ele_len;
    } else {
        *lval = ele_len;
    }
    return vstr;
}",1,1,listpack.c,lpGetValue,,false,671,682,lpGetValue,,,22,"unsigned char* lpGetValue (unsigned char*,unsigned int*,long long*)"
156368,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpFind(unsigned char *lp, unsigned char *p, unsigned char *s, 
                      uint32_t slen, unsigned int skip) {
    int skipcnt = 0;
    unsigned char vencoding = 0;
    unsigned char *value;
    int64_t ll, vll;
    uint64_t entry_size = 123456789; /* initialized to avoid warning. */
    uint32_t lp_bytes = lpBytes(lp);

    assert(p);
    while (p) {
        if (skipcnt == 0) {
            value = lpGetWithSize(p, &ll, NULL, &entry_size);
            if (value) {
                /* check the value doesn't reach outside the listpack before accessing it */
                assert(p >= lp + LP_HDR_SIZE && p + entry_size < lp + lp_bytes);
                if (slen == ll && memcmp(value, s, slen) == 0) {
                    return p;
                }
            } else {
                /* Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is s...",1,4,listpack.c,lpFind,,false,686,750,lpFind,,,23,"unsigned char* lpFind (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned int)"
156581,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpInsert(unsigned char *lp, unsigned char *elestr, unsigned char *eleint,
                        uint32_t size, unsigned char *p, int where, unsigned char **newp)
{
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
    unsigned char backlen[LP_MAX_BACKLEN_SIZE];

    uint64_t enclen; /* The length of the encoded element. */
    int delete = (elestr == NULL && eleint == NULL);

    /* when deletion, it is conceptually replacing the element with a
     * zero-length element. So whatever we get passed as 'where', set
     * it to LP_REPLACE. */
    if (delete) where = LP_REPLACE;

    /* If we need to insert after the current element, we just jump to the
     * next element (that could be the EOF one) and handle the case of
     * inserting before. So the function will actually deal with just two
     * cases: LP_BEFORE and LP_REPLACE. */
    if (where == LP_AFTER) {
        p = lpSkip(p);
        where = LP_BEFORE;
        ASSERT_INTEGRITY(lp, p);
    }

    /* Store ...",1,25,listpack.c,lpInsert,,false,780,927,lpInsert,,,24,"unsigned char* lpInsert (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)"
157167,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpInsertString(unsigned char *lp, unsigned char *s, uint32_t slen,
                              unsigned char *p, int where, unsigned char **newp)
{
    return lpInsert(lp, s, NULL, slen, p, where, newp);
}",1,1,listpack.c,lpInsertString,,false,930,934,lpInsertString,,,25,"unsigned char* lpInsertString (unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)"
157186,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpInsertInteger(unsigned char *lp, long long lval, unsigned char *p, int where, unsigned char **newp) {
    uint64_t enclen; /* The length of the encoded element. */
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];

    lpEncodeIntegerGetType(lval, intenc, &enclen);
    return lpInsert(lp, NULL, intenc, enclen, p, where, newp);
}",1,25,listpack.c,lpInsertInteger,,false,938,944,lpInsertInteger,,,26,"unsigned char* lpInsertInteger (unsigned char*,long long,unsigned char*,int,unsigned char**)"
157211,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpPrepend(unsigned char *lp, unsigned char *s, uint32_t slen) {
    unsigned char *p = lpFirst(lp);
    if (!p) return lpAppend(lp, s, slen);
    return lpInsert(lp, s, NULL, slen, p, LP_BEFORE, NULL);
}",1,42,listpack.c,lpPrepend,,false,947,951,lpPrepend,,,27,"unsigned char* lpPrepend (unsigned char*,unsigned char*,uint32_t)"
157243,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpPrependInteger(unsigned char *lp, long long lval) {
    unsigned char *p = lpFirst(lp);
    if (!p) return lpAppendInteger(lp, lval);
    return lpInsertInteger(lp, lval, p, LP_BEFORE, NULL);
}",1,40,listpack.c,lpPrependInteger,,false,954,958,lpPrependInteger,,,28,"unsigned char* lpPrependInteger (unsigned char*,long long)"
157271,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size) {
    uint64_t listpack_bytes = lpGetTotalBytes(lp);
    unsigned char *eofptr = lp + listpack_bytes - 1;
    return lpInsert(lp,ele,NULL,size,eofptr,LP_BEFORE,NULL);
}",1,30,listpack.c,lpAppend,,false,963,967,lpAppend,,,29,"unsigned char* lpAppend (unsigned char*,unsigned char*,uint32_t)"
157330,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpAppendInteger(unsigned char *lp, long long lval) {
    uint64_t listpack_bytes = lpGetTotalBytes(lp);
    unsigned char *eofptr = lp + listpack_bytes - 1;
    return lpInsertInteger(lp, lval, eofptr, LP_BEFORE, NULL);
}",1,30,listpack.c,lpAppendInteger,,false,970,974,lpAppendInteger,,,30,"unsigned char* lpAppendInteger (unsigned char*,long long)"
157386,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpReplace(unsigned char *lp, unsigned char **p, unsigned char *s, uint32_t slen) {
    return lpInsert(lp, s, NULL, slen, *p, LP_REPLACE, p);
}",1,43,listpack.c,lpReplace,,false,979,981,lpReplace,,,31,"unsigned char* lpReplace (unsigned char*,unsigned char**,unsigned char*,uint32_t)"
157406,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **p, long long lval) {
    return lpInsertInteger(lp, lval, *p, LP_REPLACE, p);
}",1,41,listpack.c,lpReplaceInteger,,false,987,989,lpReplaceInteger,,,32,"unsigned char* lpReplaceInteger (unsigned char*,unsigned char**,long long)"
157423,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp) {
    return lpInsert(lp,NULL,NULL,0,p,LP_REPLACE,newp);
}",1,37,listpack.c,lpDelete,,false,995,997,lpDelete,,,33,"unsigned char* lpDelete (unsigned char*,unsigned char*,unsigned char**)"
157441,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpDeleteRangeWithEntry(unsigned char *lp, unsigned char **p, unsigned long num) {
    size_t bytes = lpBytes(lp);
    unsigned long deleted = 0;
    unsigned char *eofptr = lp + bytes - 1;
    unsigned char *first, *tail;
    first = tail = *p;

    if (num == 0) return lp;  /* Nothing to delete, return ASAP. */

    /* Find the next entry to the last entry that needs to be deleted.
     * lpLength may be unreliable due to corrupt data, so we cannot
     * treat 'num' as the number of elements to be deleted. */
    while (num--) {
        deleted++;
        tail = lpSkip(tail);
        if (tail[0] == LP_EOF) break;
        lpAssertValidEntry(lp, bytes, tail);
    }

    /* Store the offset of the element 'first', so that we can obtain its
     * address again after a reallocation. */
    unsigned long poff = first-lp;

    /* Move tail to the front of the listpack */
    memmove(first, tail, eofptr - tail + 1);
    lpSetTotalBytes(lp, bytes - (tail - first));
    uint...",1,23,listpack.c,lpDeleteRangeWithEntry,,false,1000,1036,lpDeleteRangeWithEntry,,,34,"unsigned char* lpDeleteRangeWithEntry (unsigned char*,unsigned char**,long unsigned)"
157652,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpDeleteRange(unsigned char *lp, long index, unsigned long num) {
    unsigned char *p;
    uint32_t numele = lpGetNumElements(lp);

    if (num == 0) return lp; /* Nothing to delete, return ASAP. */
    if ((p = lpSeek(lp, index)) == NULL) return lp;

    /* If we know we're gonna delete beyond the end of the listpack, we can just move
     * the EOF marker, and there's no need to iterate through the entries,
     * but if we can't be sure how many entries there are, we rather avoid calling lpLength
     * since that means an additional iteration on all elements.
     *
     * Note that index could overflow, but we use the value after seek, so when we
     * use it no overflow happens. */
    if (numele != LP_HDR_NUMELE_UNKNOWN && index < 0) index = (long)numele + index;
    if (numele != LP_HDR_NUMELE_UNKNOWN && (numele - (unsigned long)index) <= num) {
        p[0] = LP_EOF;
        lpSetTotalBytes(lp, p - lp + 1);
        lpSetNumElements(lp, index);
        lp = ...",1,22,listpack.c,lpDeleteRange,,false,1039,1064,lpDeleteRange,,,35,"unsigned char* lpDeleteRange (unsigned char*,long,long unsigned)"
157831,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpBatchDelete(unsigned char *lp, unsigned char **ps, unsigned long count) {
    if (count == 0) return lp;
    unsigned char *dst = ps[0];
    size_t total_bytes = lpGetTotalBytes(lp);
    unsigned char *lp_end = lp + total_bytes; /* After the EOF element. */
    assert(lp_end[-1] == LP_EOF);
    /*
     * ----+--------+-----------+--------+---------+-----+---+
     * ... | Delete | Keep      | Delete | Keep    | ... |EOF|
     * ... |xxxxxxxx|           |xxxxxxxx|         | ... |   |
     * ----+--------+-----------+--------+---------+-----+---+
     *     ^        ^           ^                            ^
     *     |        |           |                            |
     *     ps[i]    |           ps[i+1]                      |
     *     skip     keep_start  keep_end                     lp_end
     *
     * The loop memmoves the bytes between keep_start and keep_end to dst.
     */
    for (unsigned long i = 0; i < count; i++) {
        unsigned char *skip = ps[i...",1,25,listpack.c,lpBatchDelete,,false,1069,1113,lpBatchDelete,,,36,"unsigned char* lpBatchDelete (unsigned char*,unsigned char**,long unsigned)"
158134,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpMerge(unsigned char **first, unsigned char **second) {
    /* If any params are null, we can't merge, so NULL. */
    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
        return NULL;

    /* Can't merge same list into itself. */
    if (*first == *second)
        return NULL;

    size_t first_bytes = lpBytes(*first);
    unsigned long first_len = lpLength(*first);

    size_t second_bytes = lpBytes(*second);
    unsigned long second_len = lpLength(*second);

    int append;
    unsigned char *source, *target;
    size_t target_bytes, source_bytes;
    /* Pick the largest listpack so we can resize easily in-place.
     * We must also track if we are now appending or prepending to
     * the target listpack. */
    if (first_bytes >= second_bytes) {
        /* retain first, append second to first. */
        target = *first;
        target_bytes = first_bytes;
        source = *second;
        source_bytes = second_bytes;
        append ...",1,82,listpack.c,lpMerge,,false,1130,1210,lpMerge,,,37,"unsigned char* lpMerge (unsigned char**,unsigned char**)"
158434,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpDup(unsigned char *lp) {
    size_t lpbytes = lpBytes(lp);
    unsigned char *newlp = lp_malloc(lpbytes);
    memcpy(newlp, lp, lpbytes);
    return newlp;
}",1,27,listpack.c,lpDup,,false,1212,1217,lpDup,,,38,unsigned char* lpDup (unsigned char*)
158459,METHOD,listpack.c:<global>,TYPE_DECL,"size_t lpBytes(unsigned char *lp) {
    return lpGetTotalBytes(lp);
}",1,11,listpack.c,lpBytes,,false,1220,1222,lpBytes,,,39,size_t lpBytes (unsigned char*)
158495,METHOD,listpack.c:<global>,TYPE_DECL,"size_t lpEstimateBytesRepeatedInteger(long long lval, unsigned long rep) {
    uint64_t enclen;
    unsigned char intenc[LP_MAX_INT_ENCODING_LEN];
    lpEncodeIntegerGetType(lval, intenc, &enclen);
    unsigned long backlen = lpEncodeBacklen(NULL, enclen);
    return LP_HDR_SIZE + (enclen + backlen) * rep + 1;
}",1,25,listpack.c,lpEstimateBytesRepeatedInteger,,false,1225,1231,lpEstimateBytesRepeatedInteger,,,40,"size_t lpEstimateBytesRepeatedInteger (long long,long unsigned)"
158526,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpSeek(unsigned char *lp, long index) {
    int forward = 1; /* Seek forward by default. */

    /* We want to seek from left to right or the other way around
     * depending on the listpack length and the element position.
     * However if the listpack length cannot be obtained in constant time,
     * we always seek from left to right. */
    uint32_t numele = lpGetNumElements(lp);
    if (numele != LP_HDR_NUMELE_UNKNOWN) {
        if (index < 0) index = (long)numele+index;
        if (index < 0) return NULL; /* Index still < 0 means out of range. */
        if (index >= (long)numele) return NULL; /* Out of range the other side. */
        /* We want to scan right-to-left if the element we are looking for
         * is past the half of the listpack. */
        if (index > (long)numele/2) {
            forward = 0;
            /* Right to left scanning always expects a negative index. Convert
             * our index to negative form. */
            index -= numele...",1,22,listpack.c,lpSeek,,false,1238,1280,lpSeek,,,41,"unsigned char* lpSeek (unsigned char*,long)"
158663,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpValidateFirst(unsigned char *lp) {
    unsigned char *p = lp + LP_HDR_SIZE; /* Skip the header. */
    if (p[0] == LP_EOF) return NULL;
    return p;
}",1,28,listpack.c,lpValidateFirst,,false,1283,1287,lpValidateFirst,,,42,unsigned char* lpValidateFirst (unsigned char*)
158689,METHOD,listpack.c:<global>,TYPE_DECL,"int lpValidateNext(unsigned char *lp, unsigned char **pp, size_t lpbytes) {
#define OUT_OF_RANGE(p) ( \
        (p) < lp + LP_HDR_SIZE || \
        (p) > lp + lpbytes - 1)
    unsigned char *p = *pp;
    if (!p)
        return 0;

    /* Before accessing p, make sure it's valid. */
    if (OUT_OF_RANGE(p))
        return 0;

    if (*p == LP_EOF) {
        *pp = NULL;
        return 1;
    }

    /* check that we can read the encoded size */
    uint32_t lenbytes = lpCurrentEncodedSizeBytes(p);
    if (!lenbytes)
        return 0;

    /* make sure the encoded entry length doesn't reach outside the edge of the listpack */
    if (OUT_OF_RANGE(p + lenbytes))
        return 0;

    /* get the entry length and encoded backlen. */
    unsigned long entrylen = lpCurrentEncodedSizeUnsafe(p);
    unsigned long encodedBacklen = lpEncodeBacklen(NULL,entrylen);
    entrylen += encodedBacklen;

    /* make sure the entry doesn't reach outside the edge of the listpack */
    if (OUT_OF_RANGE(p ...",1,8,listpack.c,lpValidateNext,,false,1292,1338,lpValidateNext,,,43,"int lpValidateNext (unsigned char*,unsigned char**,size_t)"
158837,METHOD,listpack.c:<global>,TYPE_DECL,"static inline void lpAssertValidEntry(unsigned char* lp, size_t lpbytes, unsigned char *p) {
    assert(lpValidateNext(lp, &p, lpbytes));
}",1,4,listpack.c,lpAssertValidEntry,,false,1341,1343,lpAssertValidEntry,,,44,"void lpAssertValidEntry (unsigned char*,size_t,unsigned char*)"
158862,METHOD,listpack.c:<global>,TYPE_DECL,"int lpValidateIntegrity(unsigned char *lp, size_t size, int deep, 
                        listpackValidateEntryCB entry_cb, void *cb_userdata) {
    /* Check that we can actually read the header. (and EOF) */
    if (size < LP_HDR_SIZE + 1)
        return 0;

    /* Check that the encoded size in the header must match the allocated size. */
    size_t bytes = lpGetTotalBytes(lp);
    if (bytes != size)
        return 0;

    /* The last byte must be the terminator. */
    if (lp[size-1] != LP_EOF)
        return 0;

    if (!deep)
        return 1;

    /* Validate the individual entries. */
    uint32_t count = 0;
    uint32_t numele = lpGetNumElements(lp);
    unsigned char *p = lp + LP_HDR_SIZE;
    while(p && p[0] != LP_EOF) {
        unsigned char *prev = p;

        /* Validate this entry and move to the next entry in advance
         * to avoid callback crash due to corrupt listpack. */
        if (!lpValidateNext(lp, &p, bytes))
            return 0;

        /* Optionally ...",1,15,listpack.c,lpValidateIntegrity,,false,1348,1394,lpValidateIntegrity,,,45,"int lpValidateIntegrity (unsigned char*,size_t,int,listpackValidateEntryCB,void*)"
159036,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned int lpCompare(unsigned char *p, unsigned char *s, uint32_t slen) {
    unsigned char *value;
    int64_t sz;
    if (p[0] == LP_EOF) return 0;

    value = lpGet(p, &sz, NULL);
    if (value) {
        return (slen == sz) && memcmp(value,s,slen) == 0;
    } else {
        /* We use lpStringToInt64() to get an integer representation of the
         * string 's' and compare it to 'sval', it's much faster than convert
         * integer to string and comparing. */
        int64_t sval;
        if (lpStringToInt64((const char*)s, slen, &sval))
            return sz == sval;
    }

    return 0;
}",1,16,listpack.c,lpCompare,,false,1398,1416,lpCompare,,,46,"unsigned int lpCompare (unsigned char*,unsigned char*,uint32_t)"
159095,METHOD,listpack.c:<global>,TYPE_DECL,"static int uintCompare(const void *a, const void *b) {
    return (*(unsigned int *) a - *(unsigned int *) b);
}",1,1,listpack.c,uintCompare,,false,1419,1421,uintCompare,,,47,"int uintCompare (void*,void*)"
159111,METHOD,listpack.c:<global>,TYPE_DECL,"static inline void lpSaveValue(unsigned char *val, unsigned int len, int64_t lval, listpackEntry *dest) {
    dest->sval = val;
    dest->slen = len;
    dest->lval = lval;
}",1,1,listpack.c,lpSaveValue,,false,1424,1428,lpSaveValue,,,48,"void lpSaveValue (unsigned char*,unsigned int,int64_t,listpackEntry*)"
159134,METHOD,listpack.c:<global>,TYPE_DECL,"void lpRandomPair(unsigned char *lp, unsigned long total_count, listpackEntry *key, listpackEntry *val) {
    unsigned char *p;

    /* Avoid div by zero on corrupt listpack */
    assert(total_count);

    /* Generate even numbers, because listpack saved K-V pair */
    int r = (rand() % total_count) * 2;
    assert((p = lpSeek(lp, r)));
    key->sval = lpGetValue(p, &(key->slen), &(key->lval));

    if (!val)
        return;
    assert((p = lpNext(lp, p)));
    val->sval = lpGetValue(p, &(val->slen), &(val->lval));
}",1,4,listpack.c,lpRandomPair,,false,1434,1449,lpRandomPair,,,49,"void lpRandomPair (unsigned char*,long unsigned,listpackEntry*,listpackEntry*)"
159235,METHOD,listpack.c:<global>,TYPE_DECL,"void lpRandomEntries(unsigned char *lp, unsigned int count, listpackEntry *entries) {
    struct pick {
        unsigned int index;
        unsigned int order;
    } *picks = lp_malloc(count * sizeof(struct pick));
    unsigned int total_size = lpLength(lp);
    assert(total_size);
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = rand() % total_size;
        picks[i].order = i;
    }

    /* Sort by index. */
    qsort(picks, count, sizeof(struct pick), uintCompare);

    /* Iterate over listpack in index order and store the values in the entries
     * array respecting the original order. */
    unsigned char *p = lpFirst(lp);
    unsigned int j = 0; /* index in listpack */
    for (unsigned int i = 0; i < count; i++) {
        /* Advance listpack pointer to until we reach 'index' listpack. */
        while (j < picks[i].index) {
            p = lpNext(lp, p);
            j++;
        }
        int storeorder = picks[i].order;
        unsigned int len = 0;
  ...",1,15,listpack.c,lpRandomEntries,,false,1454,1486,lpRandomEntries,,,50,"void lpRandomEntries (unsigned char*,unsigned int,listpackEntry*)"
159381,METHOD,listpack.c:<global>,TYPE_DECL,"void lpRandomPairs(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    unsigned char *p, *key, *value;
    unsigned int klen = 0, vlen = 0;
    long long klval = 0, vlval = 0;

    /* Notice: the index member must be first due to the use in uintCompare */
    typedef struct {
        unsigned int index;
        unsigned int order;
    } rand_pick;
    rand_pick *picks = lp_malloc(sizeof(rand_pick)*count);
    unsigned int total_size = lpLength(lp)/2;

    /* Avoid div by zero on corrupt listpack */
    assert(total_size);

    /* create a pool of random indexes (some may be duplicate). */
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = (rand() % total_size) * 2; /* Generate even indexes */
        /* keep track of the order we picked them */
        picks[i].order = i;
    }

    /* sort by indexes. */
    qsort(picks, count, sizeof(rand_pick), uintCompare);

    /* fetch the elements form the listpack into a output array re...",1,23,listpack.c,lpRandomPairs,,false,1492,1537,lpRandomPairs,,,51,"void lpRandomPairs (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)"
159590,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned int lpRandomPairsUnique(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    unsigned char *p, *key;
    unsigned int klen = 0;
    long long klval = 0;
    unsigned int total_size = lpLength(lp)/2;
    unsigned int index = 0;
    if (count > total_size)
        count = total_size;

    p = lpFirst(lp);
    unsigned int picked = 0, remaining = count;
    while (picked < count && p) {
        assert((p = lpNextRandom(lp, p, &index, remaining, 1)));
        key = lpGetValue(p, &klen, &klval);
        lpSaveValue(key, klen, klval, &keys[picked]);
        assert((p = lpNext(lp, p)));
        index++;
        if (vals) {
            key = lpGetValue(p, &klen, &klval);
            lpSaveValue(key, klen, klval, &vals[picked]);
        }
        p = lpNext(lp, p);
        remaining--;
        picked++;
        index++;
    }
    return picked;
}",1,8,listpack.c,lpRandomPairsUnique,,false,1545,1572,lpRandomPairsUnique,,,52,"unsigned int lpRandomPairsUnique (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)"
159736,METHOD,listpack.c:<global>,TYPE_DECL,"unsigned char *lpNextRandom(unsigned char *lp, unsigned char *p, unsigned int *index,
                            unsigned int remaining, int even_only)
{
    /* To only iterate once, every time we try to pick a member, the probability
     * we pick it is the quotient of the count left we want to pick and the
     * count still we haven't visited. This way, we could make every member be
     * equally likely to be picked. */
    unsigned int i = *index;
    unsigned int total_size = lpLength(lp);
    while (i < total_size && p != NULL) {
        if (even_only && i % 2 != 0) {
            p = lpNext(lp, p);
            i++;
            continue;
        }

        /* Do we pick this element? */
        unsigned int available = total_size - i;
        if (even_only) available /= 2;
        double randomDouble = ((double)rand()) / RAND_MAX;
        double threshold = ((double)remaining) / available;
        if (randomDouble <= threshold) {
            *index = i;
            return p;...",1,1,listpack.c,lpNextRandom,,false,1598,1629,lpNextRandom,,,53,"unsigned char* lpNextRandom (unsigned char*,unsigned char*,unsigned int*,unsigned int,int)"
159829,METHOD,listpack.c:<global>,TYPE_DECL,"void lpRepr(unsigned char *lp) {
    unsigned char *p, *vstr;
    int64_t vlen;
    unsigned char intbuf[LP_INTBUF_SIZE];
    int index = 0;

    printf(""{total bytes %zu} {num entries %lu}\n"", lpBytes(lp), lpLength(lp));
        
    p = lpFirst(lp);
    while(p) {
        uint32_t encoded_size_bytes = lpCurrentEncodedSizeBytes(p);
        uint32_t encoded_size = lpCurrentEncodedSizeUnsafe(p);
        unsigned long back_len = lpEncodeBacklen(NULL, encoded_size);
        printf(
            ""{\n""
                ""\taddr: 0x%08lx,\n""
                ""\tindex: %2d,\n""
                ""\toffset: %1lu,\n""
                ""\thdr+entrylen+backlen: %2lu,\n""
                ""\thdrlen: %3u,\n""
                ""\tbacklen: %2lu,\n""
                ""\tpayload: %1u\n"",
            (long unsigned)p,
            index,
            (unsigned long) (p-lp),
            encoded_size + back_len,
            encoded_size_bytes,
            back_len,
            encoded_size - encoded_size_bytes);
      ...",1,25,listpack.c,lpRepr,,false,1632,1680,lpRepr,,,54,void lpRepr (unsigned char*)
159971,METHOD,listpack.h:<global>,TYPE_DECL,<global>,1,6,listpack.h,listpack.h:<global>,,false,1,106,<global>,,,1,
159978,METHOD,listpack.h:<global>,TYPE_DECL,unsigned char *lpNew(size_t capacity);,15,37,listpack.h,lpNew,,false,57,57,lpNew,,,3,unsigned char* lpNew (size_t)
159983,METHOD,listpack.h:<global>,TYPE_DECL,void lpFree(unsigned char *lp);,6,30,listpack.h,lpFree,,false,58,58,lpFree,,,4,void lpFree (unsigned char*)
159988,METHOD,listpack.h:<global>,TYPE_DECL,unsigned char* lpShrinkToFit(unsigned char *lp);,14,47,listpack.h,lpShrinkToFit,,false,59,59,lpShrinkToFit,,,5,unsigned char* lpShrinkToFit (unsigned char*)
159993,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpInsertString(unsigned char *lp, unsigned char *s, uint32_t slen,
                              unsigned char *p, int where, unsigned char **newp);",15,80,listpack.h,lpInsertString,,false,60,61,lpInsertString,,,6,"unsigned char* lpInsertString (unsigned char*,unsigned char*,uint32_t,unsigned char*,int,unsigned char**)"
160003,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpInsertInteger(unsigned char *lp, long long lval,
                               unsigned char *p, int where, unsigned char **newp);",15,81,listpack.h,lpInsertInteger,,false,62,63,lpInsertInteger,,,7,"unsigned char* lpInsertInteger (unsigned char*,long long,unsigned char*,int,unsigned char**)"
160012,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpPrepend(unsigned char *lp, unsigned char *s, uint32_t slen);",15,76,listpack.h,lpPrepend,,false,64,64,lpPrepend,,,8,"unsigned char* lpPrepend (unsigned char*,unsigned char*,uint32_t)"
160019,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpPrependInteger(unsigned char *lp, long long lval);",15,66,listpack.h,lpPrependInteger,,false,65,65,lpPrependInteger,,,9,"unsigned char* lpPrependInteger (unsigned char*,long long)"
160025,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpAppend(unsigned char *lp, unsigned char *s, uint32_t slen);",15,75,listpack.h,lpAppend,,false,66,66,lpAppend,,,10,"unsigned char* lpAppend (unsigned char*,unsigned char*,uint32_t)"
160032,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpAppendInteger(unsigned char *lp, long long lval);",15,65,listpack.h,lpAppendInteger,,false,67,67,lpAppendInteger,,,11,"unsigned char* lpAppendInteger (unsigned char*,long long)"
160038,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpReplace(unsigned char *lp, unsigned char **p, unsigned char *s, uint32_t slen);",15,95,listpack.h,lpReplace,,false,68,68,lpReplace,,,12,"unsigned char* lpReplace (unsigned char*,unsigned char**,unsigned char*,uint32_t)"
160046,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpReplaceInteger(unsigned char *lp, unsigned char **p, long long lval);",15,85,listpack.h,lpReplaceInteger,,false,69,69,lpReplaceInteger,,,13,"unsigned char* lpReplaceInteger (unsigned char*,unsigned char**,long long)"
160053,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp);",15,82,listpack.h,lpDelete,,false,70,70,lpDelete,,,14,"unsigned char* lpDelete (unsigned char*,unsigned char*,unsigned char**)"
160060,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpDeleteRangeWithEntry(unsigned char *lp, unsigned char **p, unsigned long num);",15,94,listpack.h,lpDeleteRangeWithEntry,,false,71,71,lpDeleteRangeWithEntry,,,15,"unsigned char* lpDeleteRangeWithEntry (unsigned char*,unsigned char**,long unsigned)"
160067,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpDeleteRange(unsigned char *lp, long index, unsigned long num);",15,78,listpack.h,lpDeleteRange,,false,72,72,lpDeleteRange,,,16,"unsigned char* lpDeleteRange (unsigned char*,long,long unsigned)"
160074,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpBatchDelete(unsigned char *lp, unsigned char **ps, unsigned long count);",15,88,listpack.h,lpBatchDelete,,false,73,73,lpBatchDelete,,,17,"unsigned char* lpBatchDelete (unsigned char*,unsigned char**,long unsigned)"
160081,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpMerge(unsigned char **first, unsigned char **second);",15,69,listpack.h,lpMerge,,false,74,74,lpMerge,,,18,"unsigned char* lpMerge (unsigned char**,unsigned char**)"
160087,METHOD,listpack.h:<global>,TYPE_DECL,unsigned char *lpDup(unsigned char *lp);,15,39,listpack.h,lpDup,,false,75,75,lpDup,,,19,unsigned char* lpDup (unsigned char*)
160092,METHOD,listpack.h:<global>,TYPE_DECL,unsigned long lpLength(unsigned char *lp);,15,41,listpack.h,lpLength,,false,76,76,lpLength,,,20,long unsigned lpLength (unsigned char*)
160097,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf);",15,77,listpack.h,lpGet,,false,77,77,lpGet,,,21,"unsigned char* lpGet (unsigned char*,int64_t*,unsigned char*)"
160104,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpGetValue(unsigned char *p, unsigned int *slen, long long *lval);",15,80,listpack.h,lpGetValue,,false,78,78,lpGetValue,,,22,"unsigned char* lpGetValue (unsigned char*,unsigned int*,long long*)"
160111,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpFind(unsigned char *lp, unsigned char *p, unsigned char *s, uint32_t slen, unsigned int skip);",15,110,listpack.h,lpFind,,false,79,79,lpFind,,,23,"unsigned char* lpFind (unsigned char*,unsigned char*,unsigned char*,uint32_t,unsigned int)"
160120,METHOD,listpack.h:<global>,TYPE_DECL,unsigned char *lpFirst(unsigned char *lp);,15,41,listpack.h,lpFirst,,false,80,80,lpFirst,,,24,unsigned char* lpFirst (unsigned char*)
160125,METHOD,listpack.h:<global>,TYPE_DECL,unsigned char *lpLast(unsigned char *lp);,15,40,listpack.h,lpLast,,false,81,81,lpLast,,,25,unsigned char* lpLast (unsigned char*)
160130,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpNext(unsigned char *lp, unsigned char *p);",15,58,listpack.h,lpNext,,false,82,82,lpNext,,,26,"unsigned char* lpNext (unsigned char*,unsigned char*)"
160136,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpPrev(unsigned char *lp, unsigned char *p);",15,58,listpack.h,lpPrev,,false,83,83,lpPrev,,,27,"unsigned char* lpPrev (unsigned char*,unsigned char*)"
160142,METHOD,listpack.h:<global>,TYPE_DECL,size_t lpBytes(unsigned char *lp);,8,33,listpack.h,lpBytes,,false,84,84,lpBytes,,,28,size_t lpBytes (unsigned char*)
160147,METHOD,listpack.h:<global>,TYPE_DECL,"size_t lpEstimateBytesRepeatedInteger(long long lval, unsigned long rep);",8,72,listpack.h,lpEstimateBytesRepeatedInteger,,false,85,85,lpEstimateBytesRepeatedInteger,,,29,"size_t lpEstimateBytesRepeatedInteger (long long,long unsigned)"
160153,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpSeek(unsigned char *lp, long index);",15,52,listpack.h,lpSeek,,false,86,86,lpSeek,,,30,"unsigned char* lpSeek (unsigned char*,long)"
160159,METHOD,listpack.h:<global>,TYPE_DECL,"typedef int (*listpackValidateEntryCB)(unsigned char *p, unsigned int head_count, void *userdata);",13,97,listpack.h,listpackValidateEntryCB,,false,87,87,listpackValidateEntryCB,,,31,"int listpackValidateEntryCB (unsigned char*,unsigned int,void*)"
160166,METHOD,listpack.h:<global>,TYPE_DECL,"int lpValidateIntegrity(unsigned char *lp, size_t size, int deep,
                        listpackValidateEntryCB entry_cb, void *cb_userdata);",5,76,listpack.h,lpValidateIntegrity,,false,88,89,lpValidateIntegrity,,,32,"int lpValidateIntegrity (unsigned char*,size_t,int,listpackValidateEntryCB,void*)"
160175,METHOD,listpack.h:<global>,TYPE_DECL,unsigned char *lpValidateFirst(unsigned char *lp);,15,49,listpack.h,lpValidateFirst,,false,90,90,lpValidateFirst,,,33,unsigned char* lpValidateFirst (unsigned char*)
160180,METHOD,listpack.h:<global>,TYPE_DECL,"int lpValidateNext(unsigned char *lp, unsigned char **pp, size_t lpbytes);",5,73,listpack.h,lpValidateNext,,false,91,91,lpValidateNext,,,34,"int lpValidateNext (unsigned char*,unsigned char**,size_t)"
160187,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned int lpCompare(unsigned char *p, unsigned char *s, uint32_t slen);",14,73,listpack.h,lpCompare,,false,92,92,lpCompare,,,35,"unsigned int lpCompare (unsigned char*,unsigned char*,uint32_t)"
160194,METHOD,listpack.h:<global>,TYPE_DECL,"void lpRandomPair(unsigned char *lp, unsigned long total_count, listpackEntry *key, listpackEntry *val);",6,103,listpack.h,lpRandomPair,,false,93,93,lpRandomPair,,,36,"void lpRandomPair (unsigned char*,long unsigned,listpackEntry*,listpackEntry*)"
160202,METHOD,listpack.h:<global>,TYPE_DECL,"void lpRandomPairs(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals);",6,99,listpack.h,lpRandomPairs,,false,94,94,lpRandomPairs,,,37,"void lpRandomPairs (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)"
160210,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned int lpRandomPairsUnique(unsigned char *lp, unsigned int count, listpackEntry *keys, listpackEntry *vals);",14,113,listpack.h,lpRandomPairsUnique,,false,95,95,lpRandomPairsUnique,,,38,"unsigned int lpRandomPairsUnique (unsigned char*,unsigned int,listpackEntry*,listpackEntry*)"
160218,METHOD,listpack.h:<global>,TYPE_DECL,"void lpRandomEntries(unsigned char *lp, unsigned int count, listpackEntry *entries);",6,83,listpack.h,lpRandomEntries,,false,96,96,lpRandomEntries,,,39,"void lpRandomEntries (unsigned char*,unsigned int,listpackEntry*)"
160225,METHOD,listpack.h:<global>,TYPE_DECL,"unsigned char *lpNextRandom(unsigned char *lp, unsigned char *p, unsigned int *index,
                            unsigned int remaining, int even_only);",15,66,listpack.h,lpNextRandom,,false,97,98,lpNextRandom,,,40,"unsigned char* lpNextRandom (unsigned char*,unsigned char*,unsigned int*,unsigned int,int)"
160234,METHOD,listpack.h:<global>,TYPE_DECL,"int lpSafeToAdd(unsigned char* lp, size_t add);",5,46,listpack.h,lpSafeToAdd,,false,99,99,lpSafeToAdd,,,41,"int lpSafeToAdd (unsigned char*,size_t)"
160240,METHOD,listpack.h:<global>,TYPE_DECL,void lpRepr(unsigned char *lp);,6,30,listpack.h,lpRepr,,false,100,100,lpRepr,,,42,void lpRepr (unsigned char*)
160250,METHOD,listpack_malloc.h:<global>,TYPE_DECL,<global>,1,25,listpack_malloc.h,listpack_malloc.h:<global>,,false,1,49,<global>,,,1,
160259,METHOD,localtime.c:<global>,TYPE_DECL,<global>,1,6,localtime.c,localtime.c:<global>,,false,1,123,<global>,,,1,
160261,METHOD,localtime.c:<global>,TYPE_DECL,"static int is_leap_year(time_t year) {
    if (year % 4) return 0;         /* A year not divisible by 4 is not leap. */
    else if (year % 100) return 1;  /* If div by 4 and not 100 is surely leap. */
    else if (year % 400) return 0;  /* If div by 100 *and* not by 400 is not leap. */
    else return 1;                  /* If div by 100 and 400 is leap. */
}",1,1,localtime.c,is_leap_year,,false,52,57,is_leap_year,,,1,int is_leap_year (time_t)
160295,METHOD,localtime.c:<global>,TYPE_DECL,"void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst) {
    const time_t secs_min = 60;
    const time_t secs_hour = 3600;
    const time_t secs_day = 3600*24;

    t -= tz;                            /* Adjust for timezone. */
    t += 3600*dst;                      /* Adjust for daylight time. */
    time_t days = t / secs_day;         /* Days passed since epoch. */
    time_t seconds = t % secs_day;      /* Remaining seconds. */

    tmp->tm_isdst = dst;
    tmp->tm_hour = seconds / secs_hour;
    tmp->tm_min = (seconds % secs_hour) / secs_min;
    tmp->tm_sec = (seconds % secs_hour) % secs_min;

    /* 1/1/1970 was a Thursday, that is, day 4 from the POV of the tm structure
     * where sunday = 0, so to calculate the day of the week we have to add 4
     * and take the modulo by 7. */
    tmp->tm_wday = (days+4)%7;

    /* Calculate the current year. */
    tmp->tm_year = 1970;
    while(1) {
        /* Leap years have one day more. */
        time_t days_this_ye...",1,1,localtime.c,nolocks_localtime,,false,59,104,nolocks_localtime,,,2,"void nolocks_localtime (tm*,time_t,time_t,int)"
160479,METHOD,logreqres.c:<global>,TYPE_DECL,<global>,1,1,logreqres.c,logreqres.c:<global>,,false,1,315,<global>,,,1,
160481,METHOD,logreqres.c:<global>,TYPE_DECL,"void reqresReset(client *c, int free_buf) {
    UNUSED(c);
    UNUSED(free_buf);
}",1,4,logreqres.c,reqresReset,,false,296,299,reqresReset,,,1,"void reqresReset (client*,int)"
160499,METHOD,logreqres.c:<global>,TYPE_DECL,"inline void reqresSaveClientReplyOffset(client *c) {
    UNUSED(c);
}",1,4,logreqres.c,reqresSaveClientReplyOffset,,false,301,303,reqresSaveClientReplyOffset,,,2,void reqresSaveClientReplyOffset (client*)
160510,METHOD,logreqres.c:<global>,TYPE_DECL,"inline size_t reqresAppendRequest(client *c) {
    UNUSED(c);
    return 0;
}",1,4,logreqres.c,reqresAppendRequest,,false,305,308,reqresAppendRequest,,,3,size_t reqresAppendRequest (client*)
160523,METHOD,logreqres.c:<global>,TYPE_DECL,"inline size_t reqresAppendResponse(client *c) {
    UNUSED(c);
    return 0;
}",1,4,logreqres.c,reqresAppendResponse,,false,310,313,reqresAppendResponse,,,4,size_t reqresAppendResponse (client*)
160545,METHOD,lolwut.c:<global>,TYPE_DECL,<global>,1,1,lolwut.c,lolwut.c:<global>,,false,1,188,<global>,,,1,
160547,METHOD,lolwut.c:<global>,TYPE_DECL,void lolwut5Command(client *c);,6,30,lolwut.c,lolwut5Command,,false,40,40,lolwut5Command,,,1,void lolwut5Command (client*)
160552,METHOD,lolwut.c:<global>,TYPE_DECL,void lolwut6Command(client *c);,6,30,lolwut.c,lolwut6Command,,false,41,41,lolwut6Command,,,2,void lolwut6Command (client*)
160557,METHOD,lolwut.c:<global>,TYPE_DECL,"void lolwutUnstableCommand(client *c) {
    sds rendered = sdsnew(""Redis ver. "");
    rendered = sdscat(rendered,REDIS_VERSION);
    rendered = sdscatlen(rendered,""\n"",1);
    addReplyVerbatim(c,rendered,sdslen(rendered),""txt"");
    sdsfree(rendered);
}",1,31,lolwut.c,lolwutUnstableCommand,,false,45,51,lolwutUnstableCommand,,,3,void lolwutUnstableCommand (client*)
160588,METHOD,lolwut.c:<global>,TYPE_DECL,"void lolwutCommand(client *c) {
    char *v = REDIS_VERSION;
    char verstr[64];

    if (c->argc >= 3 && !strcasecmp(c->argv[1]->ptr,""version"")) {
        long ver;
        if (getLongFromObjectOrReply(c,c->argv[2],&ver,NULL) != C_OK) return;
        snprintf(verstr,sizeof(verstr),""%u.0.0"",(unsigned int)ver);
        v = verstr;

        /* Adjust argv/argc to filter the ""VERSION ..."" option, since the
         * specific LOLWUT version implementations don't know about it
         * and expect their arguments. */
        c->argv += 2;
        c->argc -= 2;
    }

    if ((v[0] == '5' && v[1] == '.' && v[2] != '9') ||
        (v[0] == '4' && v[1] == '.' && v[2] == '9'))
        lolwut5Command(c);
    else if ((v[0] == '6' && v[1] == '.' && v[2] != '9') ||
             (v[0] == '5' && v[1] == '.' && v[2] == '9'))
        lolwut6Command(c);
    else
        lolwutUnstableCommand(c);

    /* Fix back argc/argv in case of VERSION argument. */
    if (v == verstr) {
        c->argv -= 2...",1,14,lolwut.c,lolwutCommand,,false,54,85,lolwutCommand,,,4,void lolwutCommand (client*)
160756,METHOD,lolwut.c:<global>,TYPE_DECL,"lwCanvas *lwCreateCanvas(int width, int height, int bgcolor) {
    lwCanvas *canvas = zmalloc(sizeof(*canvas));
    canvas->width = width;
    canvas->height = height;
    canvas->pixels = zmalloc((size_t)width*height);
    memset(canvas->pixels,bgcolor,(size_t)width*height);
    return canvas;
}",1,1,lolwut.c,lwCreateCanvas,,false,93,100,lwCreateCanvas,,,5,"lwCanvas lwCreateCanvas (int,int,int)"
160802,METHOD,lolwut.c:<global>,TYPE_DECL,"void lwFreeCanvas(lwCanvas *canvas) {
    zfree(canvas->pixels);
    zfree(canvas);
}",1,1,lolwut.c,lwFreeCanvas,,false,103,106,lwFreeCanvas,,,6,void lwFreeCanvas (lwCanvas*)
160813,METHOD,lolwut.c:<global>,TYPE_DECL,"void lwDrawPixel(lwCanvas *canvas, int x, int y, int color) {
    if (x < 0 || x >= canvas->width ||
        y < 0 || y >= canvas->height) return;
    canvas->pixels[x+y*canvas->width] = color;
}",1,1,lolwut.c,lwDrawPixel,,false,112,116,lwDrawPixel,,,7,"void lwDrawPixel (lwCanvas*,int,int,int)"
160856,METHOD,lolwut.c:<global>,TYPE_DECL,"int lwGetPixel(lwCanvas *canvas, int x, int y) {
    if (x < 0 || x >= canvas->width ||
        y < 0 || y >= canvas->height) return 0;
    return canvas->pixels[x+y*canvas->width];
}",1,1,lolwut.c,lwGetPixel,,false,119,123,lwGetPixel,,,8,"int lwGetPixel (lwCanvas*,int,int)"
160898,METHOD,lolwut.c:<global>,TYPE_DECL,"void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color) {
    int dx = abs(x2-x1);
    int dy = abs(y2-y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx-dy, e2;

    while(1) {
        lwDrawPixel(canvas,x1,y1,color);
        if (x1 == x2 && y1 == y2) break;
        e2 = err*2;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
}",1,1,lolwut.c,lwDrawLine,,false,126,146,lwDrawLine,,,9,"void lwDrawLine (lwCanvas*,int,int,int,int,int)"
160995,METHOD,lolwut.c:<global>,TYPE_DECL,"void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle, int color) {
    int px[4], py[4];

    /* Adjust the desired size according to the fact that the square inscribed
     * into a circle of radius 1 has the side of length SQRT(2). This way
     * size becomes a simple multiplication factor we can use with our
     * coordinates to magnify them. */
    size /= 1.4142135623;
    size = round(size);

    /* Compute the four points. */
    float k = M_PI/4 + angle;
    for (int j = 0; j < 4; j++) {
        px[j] = round(sin(k) * size + x);
        py[j] = round(cos(k) * size + y);
        k += M_PI/2;
    }

    /* Draw the square. */
    for (int j = 0; j < 4; j++)
        lwDrawLine(canvas,px[j],py[j],px[(j+1)%4],py[(j+1)%4],color);
}",1,1,lolwut.c,lwDrawSquare,,false,167,188,lwDrawSquare,,,10,"void lwDrawSquare (lwCanvas*,int,int,float,float,int)"
161098,METHOD,lolwut.h:<global>,TYPE_DECL,<global>,1,6,lolwut.h,lolwut.h:<global>,,false,1,55,<global>,,,1,
161105,METHOD,lolwut.h:<global>,TYPE_DECL,"lwCanvas *lwCreateCanvas(int width, int height, int bgcolor);",10,60,lolwut.h,lwCreateCanvas,,false,48,48,lwCreateCanvas,,,3,"lwCanvas* lwCreateCanvas (int,int,int)"
161112,METHOD,lolwut.h:<global>,TYPE_DECL,void lwFreeCanvas(lwCanvas *canvas);,6,35,lolwut.h,lwFreeCanvas,,false,49,49,lwFreeCanvas,,,4,void lwFreeCanvas (lwCanvas*)
161117,METHOD,lolwut.h:<global>,TYPE_DECL,"void lwDrawPixel(lwCanvas *canvas, int x, int y, int color);",6,59,lolwut.h,lwDrawPixel,,false,50,50,lwDrawPixel,,,5,"void lwDrawPixel (lwCanvas*,int,int,int)"
161125,METHOD,lolwut.h:<global>,TYPE_DECL,"int lwGetPixel(lwCanvas *canvas, int x, int y);",5,46,lolwut.h,lwGetPixel,,false,51,51,lwGetPixel,,,6,"int lwGetPixel (lwCanvas*,int,int)"
161132,METHOD,lolwut.h:<global>,TYPE_DECL,"void lwDrawLine(lwCanvas *canvas, int x1, int y1, int x2, int y2, int color);",6,76,lolwut.h,lwDrawLine,,false,52,52,lwDrawLine,,,7,"void lwDrawLine (lwCanvas*,int,int,int,int,int)"
161142,METHOD,lolwut.h:<global>,TYPE_DECL,"void lwDrawSquare(lwCanvas *canvas, int x, int y, float size, float angle, int color);",6,85,lolwut.h,lwDrawSquare,,false,53,53,lwDrawSquare,,,8,"void lwDrawSquare (lwCanvas*,int,int,float,float,int)"
161163,METHOD,lolwut5.c:<global>,TYPE_DECL,<global>,1,1,lolwut5.c,lolwut5.c:<global>,,false,1,177,<global>,,,1,
161165,METHOD,lolwut5.c:<global>,TYPE_DECL,"void lwTranslatePixelsGroup(int byte, char *output) {
    int code = 0x2800 + byte;
    /* Convert to unicode. This is in the U0800-UFFFF range, so we need to
     * emit it like this in three bytes:
     * 1110xxxx 10xxxxxx 10xxxxxx. */
    output[0] = 0xE0 | (code >> 12);          /* 1110-xxxx */
    output[1] = 0x80 | ((code >> 6) & 0x3F);  /* 10-xxxxxx */
    output[2] = 0x80 | (code & 0x3F);         /* 10-xxxxxx */
}",1,1,lolwut5.c,lwTranslatePixelsGroup,,false,54,62,lwTranslatePixelsGroup,,,1,"void lwTranslatePixelsGroup (int,char*)"
161206,METHOD,lolwut5.c:<global>,TYPE_DECL,"lwCanvas *lwDrawSchotter(int console_cols, int squares_per_row, int squares_per_col) {
    /* Calculate the canvas size. */
    int canvas_width = console_cols*2;
    int padding = canvas_width > 4 ? 2 : 0;
    float square_side = (float)(canvas_width-padding*2) / squares_per_row;
    int canvas_height = square_side * squares_per_col + padding*2;
    lwCanvas *canvas = lwCreateCanvas(canvas_width, canvas_height, 0);

    for (int y = 0; y < squares_per_col; y++) {
        for (int x = 0; x < squares_per_row; x++) {
            int sx = x * square_side + square_side/2 + padding;
            int sy = y * square_side + square_side/2 + padding;
            /* Rotate and translate randomly as we go down to lower
             * rows. */
            float angle = 0;
            if (y > 1) {
                float r1 = (float)rand() / (float) RAND_MAX / squares_per_col * y;
                float r2 = (float)rand() / (float) RAND_MAX / squares_per_col * y;
                float r3 = (float)ra...",1,1,lolwut5.c,lwDrawSchotter,,false,71,102,lwDrawSchotter,,,2,"lwCanvas lwDrawSchotter (int,int,int)"
161409,METHOD,lolwut5.c:<global>,TYPE_DECL,"static sds renderCanvas(lwCanvas *canvas) {
    sds text = sdsempty();
    for (int y = 0; y < canvas->height; y += 4) {
        for (int x = 0; x < canvas->width; x += 2) {
            /* We need to emit groups of 8 bits according to a specific
             * arrangement. See lwTranslatePixelsGroup() for more info. */
            int byte = 0;
            if (lwGetPixel(canvas,x,y)) byte |= (1<<0);
            if (lwGetPixel(canvas,x,y+1)) byte |= (1<<1);
            if (lwGetPixel(canvas,x,y+2)) byte |= (1<<2);
            if (lwGetPixel(canvas,x+1,y)) byte |= (1<<3);
            if (lwGetPixel(canvas,x+1,y+1)) byte |= (1<<4);
            if (lwGetPixel(canvas,x+1,y+2)) byte |= (1<<5);
            if (lwGetPixel(canvas,x,y+3)) byte |= (1<<6);
            if (lwGetPixel(canvas,x+1,y+3)) byte |= (1<<7);
            char unicode[3];
            lwTranslatePixelsGroup(byte,unicode);
            text = sdscatlen(text,unicode,3);
        }
        if (y != canvas->height-1) text = sdsca...",1,1,lolwut5.c,renderCanvas,,false,109,131,renderCanvas,,,3,sds renderCanvas (lwCanvas*)
161587,METHOD,lolwut5.c:<global>,TYPE_DECL,"void lolwut5Command(client *c) {
    long cols = 66;
    long squares_per_row = 8;
    long squares_per_col = 12;

    /* Parse the optional arguments if any. */
    if (c->argc > 1 &&
        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
        return;

    if (c->argc > 2 &&
        getLongFromObjectOrReply(c,c->argv[2],&squares_per_row,NULL) != C_OK)
        return;

    if (c->argc > 3 &&
        getLongFromObjectOrReply(c,c->argv[3],&squares_per_col,NULL) != C_OK)
        return;

    /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
     * so we have maximum number of columns, rows, and output resolution. */
    if (cols < 1) cols = 1;
    if (cols > 1000) cols = 1000;
    if (squares_per_row < 1) squares_per_row = 1;
    if (squares_per_row > 200) squares_per_row = 200;
    if (squares_per_col < 1) squares_per_col = 1;
    if (squares_per_col > 200) squares_per_col = 200;

    /* Generate some computer art and reply. */
    lwCanvas *ca...",1,61,lolwut5.c,lolwut5Command,,false,140,177,lolwut5Command,,,4,void lolwut5Command (client*)
161768,METHOD,lolwut6.c:<global>,TYPE_DECL,<global>,1,1,lolwut6.c,lolwut6.c:<global>,,false,1,201,<global>,,,1,
161770,METHOD,lolwut6.c:<global>,TYPE_DECL,"static sds renderCanvas(lwCanvas *canvas) {
    sds text = sdsempty();
    for (int y = 0; y < canvas->height; y++) {
        for (int x = 0; x < canvas->width; x++) {
            int color = lwGetPixel(canvas,x,y);
            char *ce; /* Color escape sequence. */

            /* Note that we set both the foreground and background color.
             * This way we are able to get a more consistent result among
             * different terminals implementations. */
            switch(color) {
            case 0: ce = ""0;30;40m""; break;    /* Black */
            case 1: ce = ""0;90;100m""; break;   /* Gray 1 */
            case 2: ce = ""0;37;47m""; break;    /* Gray 2 */
            case 3: ce = ""0;97;107m""; break;   /* White */
            default: ce = ""0;30;40m""; break;   /* Just for safety. */
            }
            text = sdscatprintf(text,""\033[%s \033[0m"",ce);
        }
        if (y != canvas->height-1) text = sdscatlen(text,""\n"",1);
    }
    return text;
}",1,1,lolwut6.c,renderCanvas,,false,47,69,renderCanvas,,,1,sds renderCanvas (lwCanvas*)
161876,METHOD,lolwut6.c:<global>,TYPE_DECL,"void generateSkyscraper(lwCanvas *canvas, struct skyscraper *si) {
    int starty = canvas->height-1;
    int endy = starty - si->height + 1;
    for (int y = starty; y >= endy; y--) {
        for (int x = si->xoff; x < si->xoff+si->width; x++) {
            /* The roof is four pixels less wide. */
            if (y == endy && (x <= si->xoff+1 || x >= si->xoff+si->width-2))
                continue;
            int color = si->color;
            /* Alter the color if this is a place where we want to
             * draw a window. We check that we are in the inner part of the
             * skyscraper, so that windows are far from the borders. */
            if (si->windows &&
                x > si->xoff+1 &&
                x < si->xoff+si->width-2 &&
                y > endy+1 &&
                y < starty-1)
            {
                /* Calculate the x,y position relative to the start of
                 * the window area. */
                int relx = x - (si->xoff+1);
      ...",1,1,lolwut6.c,generateSkyscraper,,false,82,120,generateSkyscraper,,,3,"void generateSkyscraper (lwCanvas*,skyscraper*)"
162062,METHOD,lolwut6.c:<global>,TYPE_DECL,"void generateSkyline(lwCanvas *canvas) {
    struct skyscraper si;

    /* First draw the background skyscraper without windows, using the
     * two different grays. We use two passes to make sure that the lighter
     * ones are always in the background. */
    for (int color = 2; color >= 1; color--) {
        si.color = color;
        for (int offset = -10; offset < canvas->width;) {
            offset += rand() % 8;
            si.xoff = offset;
            si.width = 10 + rand()%9;
            if (color == 2)
                si.height = canvas->height/2 + rand()%canvas->height/2;
            else
                si.height = canvas->height/2 + rand()%canvas->height/3;
            si.windows = 0;
            generateSkyscraper(canvas, &si);
            if (color == 2)
                offset += si.width/2;
            else
                offset += si.width+1;
        }
    }

    /* Now draw the foreground skyscraper with the windows. */
    si.color = 0;
    for (int offset = -...",1,1,lolwut6.c,generateSkyline,,false,123,160,generateSkyline,,,4,void generateSkyline (lwCanvas*)
162274,METHOD,lolwut6.c:<global>,TYPE_DECL,"void lolwut6Command(client *c) {
    long cols = 80;
    long rows = 20;

    /* Parse the optional arguments if any. */
    if (c->argc > 1 &&
        getLongFromObjectOrReply(c,c->argv[1],&cols,NULL) != C_OK)
        return;

    if (c->argc > 2 &&
        getLongFromObjectOrReply(c,c->argv[2],&rows,NULL) != C_OK)
        return;

    /* Limits. We want LOLWUT to be always reasonably fast and cheap to execute
     * so we have maximum number of columns, rows, and output resolution. */
    if (cols < 1) cols = 1;
    if (cols > 1000) cols = 1000;
    if (rows < 1) rows = 1;
    if (rows > 1000) rows = 1000;

    /* Generate the city skyline and reply. */
    lwCanvas *canvas = lwCreateCanvas(cols,rows,3);
    generateSkyline(canvas);
    sds rendered = renderCanvas(canvas);
    rendered = sdscat(rendered,
        ""\nDedicated to the 8 bit game developers of past and present.\n""
        ""Original 8 bit image from Plaguemon by hikikomori. Redis ver. "");
    rendered = sdscat(rendered...",1,61,lolwut6.c,lolwut6Command,,false,169,201,lolwut6Command,,,5,void lolwut6Command (client*)
162410,METHOD,lzf.h:<global>,TYPE_DECL,<global>,1,7,lzf.h,lzf.h:<global>,,false,1,99,<global>,,,1,
162412,METHOD,lzf.h:<global>,TYPE_DECL,"size_t
lzf_compress (const void *const in_data,  size_t in_len,
              void             *out_data, size_t out_len);",1,57,lzf.h,lzf_compress,,false,77,78,lzf_compress,,,1,"size_t lzf_compress (void*,size_t,void*,size_t)"
162420,METHOD,lzf.h:<global>,TYPE_DECL,"size_t
lzf_decompress (const void *const in_data,  size_t in_len,
                void             *out_data, size_t out_len);",1,59,lzf.h,lzf_decompress,,false,96,97,lzf_decompress,,,2,"size_t lzf_decompress (void*,size_t,void*,size_t)"
162445,METHOD,lzfP.h:<global>,TYPE_DECL,<global>,1,4,lzfP.h,lzfP.h:<global>,,false,1,189,<global>,,,1,
162461,METHOD,lzf_c.c:<global>,TYPE_DECL,<global>,1,1,lzf_c.c,lzf_c.c:<global>,,false,1,301,<global>,,,1,
162463,METHOD,lzf_c.c:<global>,TYPE_DECL,"size_t
lzf_compress (const void *const in_data, size_t in_len,
	      void *out_data, size_t out_len
#if LZF_STATE_ARG
              , LZF_STATE htab
#endif
              )
{
#if !LZF_STATE_ARG
  LZF_STATE htab;
#endif
  const u8 *ip = (const u8 *)in_data;
        u8 *op = (u8 *)out_data;
  const u8 *in_end  = ip + in_len;
        u8 *out_end = op + out_len;
  const u8 *ref;

  /* off requires a type wide enough to hold a general pointer difference.
   * ISO C doesn't have that (size_t might not be enough and ptrdiff_t only
   * works for differences within a single object). We also assume that no
   * no bit pattern traps. Since the only platform that is both non-POSIX
   * and fails to support both assumptions is windows 64 bit, we make a
   * special workaround for it.
   */
#if defined (WIN32) && defined (_M_X64)
  unsigned _int64 off; /* workaround for missing POSIX compliance */
#else
  size_t off;
#endif
  unsigned int hval;
  int lit;

  if (!in_len || !out_len)
    return 0...",1,4,lzf_c.c,lzf_compress,,false,108,301,lzf_compress,,,1,"size_t lzf_compress (void*,size_t,void*,size_t)"
163236,METHOD,lzf_d.c:<global>,TYPE_DECL,<global>,1,1,lzf_d.c,lzf_d.c:<global>,,false,1,191,<global>,,,1,
163238,METHOD,lzf_d.c:<global>,TYPE_DECL,"size_t
lzf_decompress (const void *const in_data,  size_t in_len,
                void             *out_data, size_t out_len)
{
  u8 const *ip = (const u8 *)in_data;
  u8       *op = (u8 *)out_data;
  u8 const *const in_end  = ip + in_len;
  u8       *const out_end = op + out_len;

  while (ip < in_end)
    {
      unsigned int ctrl;
      ctrl = *ip++;

      if (ctrl < (1 << 5)) /* literal run */
        {
          ctrl++;

          if (op + ctrl > out_end)
            {
              SET_ERRNO (E2BIG);
              return 0;
            }

#if CHECK_INPUT
          if (ip + ctrl > in_end)
            {
              SET_ERRNO (EINVAL);
              return 0;
            }
#endif

#ifdef lzf_movsb
          lzf_movsb (op, ip, ctrl);
#else
          switch (ctrl)
            {
              case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
              case 28: *op++ = *ip++; case 27: *op++ = *ip++; case 26: *op++ = *ip++; case 25:...",1,14,lzf_d.c,lzf_decompress,,false,59,188,lzf_decompress,,,1,"size_t lzf_decompress (void*,size_t,void*,size_t)"
163866,METHOD,memtest.c:<global>,TYPE_DECL,<global>,1,7,memtest.c,memtest.c:<global>,,false,1,377,<global>,,,1,
163872,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest_progress_start(char *title, int pass) {
    int j;

    printf(""\x1b[H\x1b[2J"");    /* Cursor home, clear screen. */
    /* Fill with dots. */
    for (j = 0; j < ws.ws_col*(ws.ws_row-2); j++) printf(""."");
    printf(""Please keep the test running several minutes per GB of memory.\n"");
    printf(""Also check http://www.memtest86.com/ and http://pyropus.ca/software/memtester/"");
    printf(""\x1b[H\x1b[2K"");          /* Cursor home, clear current line.  */
    printf(""%s [%d]\n"", title, pass); /* Print title. */
    progress_printed = 0;
    progress_full = (size_t)ws.ws_col*(ws.ws_row-3);
    fflush(stdout);
}",1,1,memtest.c,memtest_progress_start,,false,73,86,memtest_progress_start,,,5,"void memtest_progress_start (char*,int)"
163929,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest_progress_end(void) {
    printf(""\x1b[H\x1b[2J"");    /* Cursor home, clear screen. */
}",1,1,memtest.c,memtest_progress_end,,false,88,90,memtest_progress_end,,,6,void memtest_progress_end (void)
163936,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest_progress_step(size_t curr, size_t size, char c) {
    size_t chars = ((unsigned long long)curr*progress_full)/size, j;

    for (j = 0; j < chars-progress_printed; j++) printf(""%c"",c);
    progress_printed = chars;
    fflush(stdout);
}",1,1,memtest.c,memtest_progress_step,,false,92,98,memtest_progress_step,,,7,"void memtest_progress_step (size_t,size_t,char)"
163974,METHOD,memtest.c:<global>,TYPE_DECL,"int memtest_addressing(unsigned long *l, size_t bytes, int interactive) {
    unsigned long words = bytes/sizeof(unsigned long);
    unsigned long j, *p;

    /* Fill */
    p = l;
    for (j = 0; j < words; j++) {
        *p = (unsigned long)p;
        p++;
        if ((j & 0xffff) == 0 && interactive)
            memtest_progress_step(j,words*2,'A');
    }
    /* Test */
    p = l;
    for (j = 0; j < words; j++) {
        if (*p != (unsigned long)p) {
            if (interactive) {
                printf(""\n*** MEMORY ADDRESSING ERROR: %p contains %lu\n"",
                    (void*) p, *p);
                exit(1);
            }
            return 1;
        }
        p++;
        if ((j & 0xffff) == 0 && interactive)
            memtest_progress_step(j+words,words*2,'A');
    }
    return 0;
}",1,1,memtest.c,memtest_addressing,,false,103,131,memtest_addressing,,,8,"int memtest_addressing (long unsigned*,size_t,int)"
164084,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest_fill_random(unsigned long *l, size_t bytes, int interactive) {
    unsigned long step = 4096/sizeof(unsigned long);
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long iwords = words/step;  /* words per iteration */
    unsigned long off, w, *l1, *l2;
    uint64_t rseed = UINT64_C(0xd13133de9afdb566); /* Just a random seed. */
    uint64_t rout = 0;

    assert((bytes & 4095) == 0);
    for (off = 0; off < step; off++) {
        l1 = l+off;
        l2 = l1+words;
        for (w = 0; w < iwords; w++) {
            xorshift64star_next();
            *l1 = *l2 = (unsigned long) rout;
            l1 += step;
            l2 += step;
            if ((w & 0xffff) == 0 && interactive)
                memtest_progress_step(w+iwords*off,words,'R');
        }
    }
}",1,12,memtest.c,memtest_fill_random,,false,148,169,memtest_fill_random,,,9,"void memtest_fill_random (long unsigned*,size_t,int)"
164222,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,
                        unsigned long v2, char sym, int interactive)
{
    unsigned long step = 4096/sizeof(unsigned long);
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long iwords = words/step;  /* words per iteration */
    unsigned long off, w, *l1, *l2, v;

    assert((bytes & 4095) == 0);
    for (off = 0; off < step; off++) {
        l1 = l+off;
        l2 = l1+words;
        v = (off & 1) ? v2 : v1;
        for (w = 0; w < iwords; w++) {
#ifdef MEMTEST_32BIT
            *l1 = *l2 = ((unsigned long)     v) |
                        (((unsigned long)    v) << 16);
#else
            *l1 = *l2 = ((unsigned long)     v) |
                        (((unsigned long)    v) << 16) |
                        (((unsigned long)    v) << 32) |
                        (((unsigned long)    v) << 48);
#endif
            l1 += step;
            l2 += step;
            if ((w & 0xffff) == 0 && inte...",1,1,memtest.c,memtest_fill_value,,false,173,202,memtest_fill_value,,,10,"void memtest_fill_value (long unsigned*,size_t,long unsigned,long unsigned,char,int)"
164355,METHOD,memtest.c:<global>,TYPE_DECL,"int memtest_compare(unsigned long *l, size_t bytes, int interactive) {
    unsigned long words = bytes/sizeof(unsigned long)/2;
    unsigned long w, *l1, *l2;

    assert((bytes & 4095) == 0);
    l1 = l;
    l2 = l1+words;
    for (w = 0; w < words; w++) {
        if (*l1 != *l2) {
            if (interactive) {
                printf(""\n*** MEMORY ERROR DETECTED: %p != %p (%lu vs %lu)\n"",
                    (void*)l1, (void*)l2, *l1, *l2);
                exit(1);
            }
            return 1;
        }
        l1 ++;
        l2 ++;
        if ((w & 0xffff) == 0 && interactive)
            memtest_progress_step(w,words,'=');
    }
    return 0;
}",1,1,memtest.c,memtest_compare,,false,204,226,memtest_compare,,,11,"int memtest_compare (long unsigned*,size_t,int)"
164444,METHOD,memtest.c:<global>,TYPE_DECL,"int memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times,
                          int interactive)
{
    int j;
    int errors = 0;

    for (j = 0; j < times; j++) {
        if (interactive) memtest_progress_start(""Compare"",pass);
        errors += memtest_compare(m,bytes,interactive);
        if (interactive) memtest_progress_end();
    }
    return errors;
}",1,1,memtest.c,memtest_compare_times,,false,228,240,memtest_compare_times,,,12,"int memtest_compare_times (long unsigned*,size_t,int,int,int)"
164487,METHOD,memtest.c:<global>,TYPE_DECL,"int memtest_test(unsigned long *m, size_t bytes, int passes, int interactive) {
    int pass = 0;
    int errors = 0;

    while (pass != passes) {
        pass++;

        if (interactive) memtest_progress_start(""Addressing test"",pass);
        errors += memtest_addressing(m,bytes,interactive);
        if (interactive) memtest_progress_end();

        if (interactive) memtest_progress_start(""Random fill"",pass);
        memtest_fill_random(m,bytes,interactive);
        if (interactive) memtest_progress_end();
        errors += memtest_compare_times(m,bytes,pass,4,interactive);

        if (interactive) memtest_progress_start(""Solid fill"",pass);
        memtest_fill_value(m,bytes,0,(unsigned long)-1,'S',interactive);
        if (interactive) memtest_progress_end();
        errors += memtest_compare_times(m,bytes,pass,4,interactive);

        if (interactive) memtest_progress_start(""Checkerboard fill"",pass);
        memtest_fill_value(m,bytes,ULONG_ONEZERO,ULONG_ZEROONE,'C',interactiv...",1,35,memtest.c,memtest_test,,false,247,274,memtest_test,,,13,"int memtest_test (long unsigned*,size_t,int,int)"
164607,METHOD,memtest.c:<global>,TYPE_DECL,"int memtest_preserving_test(unsigned long *m, size_t bytes, int passes) {
    unsigned long backup[MEMTEST_BACKUP_WORDS];
    unsigned long *p = m;
    unsigned long *end = (unsigned long*) (((unsigned char*)m)+(bytes-MEMTEST_DECACHE_SIZE));
    size_t left = bytes;
    int errors = 0;

    if (bytes & 4095) return 0; /* Can't test across 4k page boundaries. */
    if (bytes < 4096*2) return 0; /* Can't test a single page. */

    while(left) {
        /* If we have to test a single final page, go back a single page
         * so that we can test two pages, since the code can't test a single
         * page but at least two. */
        if (left == 4096) {
            left += 4096;
            p -= 4096/sizeof(unsigned long);
        }

        int pass = 0;
        size_t len = (left > sizeof(backup)) ? sizeof(backup) : left;

        /* Always test an even number of pages. */
        if (len/4096 % 2) len -= 4096;

        memcpy(backup,p,len); /* Backup. */
        while(pass != p...",1,25,memtest.c,memtest_preserving_test,,false,292,345,memtest_preserving_test,,,14,"int memtest_preserving_test (long unsigned*,size_t,int)"
164869,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest_alloc_and_test(size_t megabytes, int passes) {
    size_t bytes = megabytes*1024*1024;
    unsigned long *m = malloc(bytes);

    if (m == NULL) {
        fprintf(stderr,""Unable to allocate %zu megabytes: %s"",
            megabytes, strerror(errno));
        exit(1);
    }
    memtest_test(m,bytes,passes,1);
    free(m);
}",1,1,memtest.c,memtest_alloc_and_test,,false,348,359,memtest_alloc_and_test,,,15,"void memtest_alloc_and_test (size_t,int)"
164908,METHOD,memtest.c:<global>,TYPE_DECL,"void memtest(size_t megabytes, int passes) {
#if !defined(__HAIKU__)
    if (ioctl(1, TIOCGWINSZ, &ws) == -1) {
        ws.ws_col = 80;
        ws.ws_row = 20;
    }
#else
    ws.ws_col = 80;
    ws.ws_row = 20;
#endif
    memtest_alloc_and_test(megabytes,passes);
    printf(""\nYour memory passed this test.\n"");
    printf(""Please if you are still in doubt use the following two tools:\n"");
    printf(""1) memtest86: http://www.memtest86.com/\n"");
    printf(""2) memtester: http://pyropus.ca/software/memtester/\n"");
    exit(0);
}",1,1,memtest.c,memtest,,false,361,377,memtest,,,16,"void memtest (size_t,int)"
164976,METHOD,module.c:<global>,TYPE_DECL,<global>,1,1,module.c,module.c:<global>,,false,1,13849,<global>,,,1,
165001,METHOD,<empty>,<empty>,<empty>,1,,module.c,RedisModulePoolAllocBlock:<clinit>,,false,126,,<clinit>,,,6,
165061,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);",13,78,module.c,RedisModuleCmdFunc,,false,232,232,RedisModuleCmdFunc,,,16,"int RedisModuleCmdFunc (RedisModuleCtx*,void**,int)"
165068,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleAuthCallback)(RedisModuleCtx *ctx, void *username, void *password, RedisModuleString **err);",13,92,module.c,RedisModuleAuthCallback,,false,233,233,RedisModuleAuthCallback,,,17,"int RedisModuleAuthCallback (RedisModuleCtx*,void*,void*,robj**)"
165076,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);",14,100,module.c,RedisModuleDisconnectFunc,,false,234,234,RedisModuleDisconnectFunc,,,18,"void RedisModuleDisconnectFunc (RedisModuleCtx*,RedisModuleBlockedClient*)"
165104,METHOD,RedisModuleBlockedClient,TYPE_DECL,"void (*free_privdata)(RedisModuleCtx*,void*);",10,48,module.c,RedisModuleBlockedClient.free_privdata,,false,271,271,free_privdata,,,7,"void RedisModuleBlockedClient.free_privdata (RedisModuleCtx*,void*)"
165142,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);",13,94,module.c,RedisModuleNotificationFunc,,false,311,311,RedisModuleNotificationFunc,,,41,"int RedisModuleNotificationFunc (RedisModuleCtx*,int,char*,robj*)"
165150,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModulePostNotificationJobFunc) (RedisModuleCtx *ctx, void *pd);",14,82,module.c,RedisModulePostNotificationJobFunc,,false,314,314,RedisModulePostNotificationJobFunc,,,42,"void RedisModulePostNotificationJobFunc (RedisModuleCtx*,void*)"
165166,METHOD,RedisModulePostExecUnitJob,TYPE_DECL,void (*free_pd)(void*);,10,26,module.c,RedisModulePostExecUnitJob.free_pd,,false,335,335,free_pd,,,4,void RedisModulePostExecUnitJob.free_pd (void*)
165188,METHOD,module.c:<global>,TYPE_DECL,typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);,14,82,module.c,RedisModuleCommandFilterFunc,,false,362,362,RedisModuleCommandFilterFunc,,,55,void RedisModuleCommandFilterFunc (RedisModuleCommandFilterCtx*)
165199,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModuleForkDoneHandler) (int exitcode, int bysignal, void *user_data);",14,88,module.c,RedisModuleForkDoneHandler,,false,376,376,RedisModuleForkDoneHandler,,,59,"void RedisModuleForkDoneHandler (int,int,void*)"
165234,METHOD,module.c:<global>,TYPE_DECL,"typedef RedisModuleString * (*RedisModuleConfigGetStringFunc)(const char *name, void *privdata);",27,95,module.c,RedisModuleConfigGetStringFunc,,false,443,443,RedisModuleConfigGetStringFunc,,,72,"robj* RedisModuleConfigGetStringFunc (char*,void*)"
165240,METHOD,module.c:<global>,TYPE_DECL,"typedef long long (*RedisModuleConfigGetNumericFunc)(const char *name, void *privdata);",19,86,module.c,RedisModuleConfigGetNumericFunc,,false,444,444,RedisModuleConfigGetNumericFunc,,,73,"long long RedisModuleConfigGetNumericFunc (char*,void*)"
165246,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigGetBoolFunc)(const char *name, void *privdata);",13,77,module.c,RedisModuleConfigGetBoolFunc,,false,445,445,RedisModuleConfigGetBoolFunc,,,74,"int RedisModuleConfigGetBoolFunc (char*,void*)"
165252,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigGetEnumFunc)(const char *name, void *privdata);",13,77,module.c,RedisModuleConfigGetEnumFunc,,false,446,446,RedisModuleConfigGetEnumFunc,,,75,"int RedisModuleConfigGetEnumFunc (char*,void*)"
165258,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetStringFunc)(const char *name, RedisModuleString *val, void *privdata, RedisModuleString **err);",13,64,module.c,RedisModuleConfigSetStringFunc,,false,448,448,RedisModuleConfigSetStringFunc,,,76,"int RedisModuleConfigSetStringFunc (char*,robj*,void*,robj**)"
165266,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetNumericFunc)(const char *name, long long val, void *privdata, RedisModuleString **err);",13,96,module.c,RedisModuleConfigSetNumericFunc,,false,449,449,RedisModuleConfigSetNumericFunc,,,77,"int RedisModuleConfigSetNumericFunc (char*,long long,void*,robj**)"
165274,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetBoolFunc)(const char *name, int val, void *privdata, RedisModuleString **err);",13,87,module.c,RedisModuleConfigSetBoolFunc,,false,450,450,RedisModuleConfigSetBoolFunc,,,78,"int RedisModuleConfigSetBoolFunc (char*,int,void*,robj**)"
165282,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetEnumFunc)(const char *name, int val, void *privdata, RedisModuleString **err);",13,87,module.c,RedisModuleConfigSetEnumFunc,,false,451,451,RedisModuleConfigSetEnumFunc,,,79,"int RedisModuleConfigSetEnumFunc (char*,int,void*,robj**)"
165290,METHOD,module.c:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigApplyFunc)(RedisModuleCtx *ctx, void *privdata, RedisModuleString **err);",13,79,module.c,RedisModuleConfigApplyFunc,,false,453,453,RedisModuleConfigApplyFunc,,,80,"int RedisModuleConfigApplyFunc (RedisModuleCtx*,void*,robj**)"
165322,METHOD,module.c:<global>,TYPE_DECL,void RM_FreeCallReply(RedisModuleCallReply *reply);,6,50,module.c,RM_FreeCallReply,,false,488,488,RM_FreeCallReply,,,84,void RM_FreeCallReply (RedisModuleCallReply*)
165327,METHOD,module.c:<global>,TYPE_DECL,void RM_CloseKey(RedisModuleKey *key);,6,37,module.c,RM_CloseKey,,false,489,489,RM_CloseKey,,,85,void RM_CloseKey (RedisModuleKey*)
165332,METHOD,module.c:<global>,TYPE_DECL,void autoMemoryCollect(RedisModuleCtx *ctx);,6,43,module.c,autoMemoryCollect,,false,490,490,autoMemoryCollect,,,86,void autoMemoryCollect (RedisModuleCtx*)
165337,METHOD,module.c:<global>,TYPE_DECL,"robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);",6,111,module.c,moduleCreateArgvFromUserFormat,,false,491,491,moduleCreateArgvFromUserFormat,,,87,"robj** moduleCreateArgvFromUserFormat (char*,char*,int*,int*,va_list)"
165346,METHOD,module.c:<global>,TYPE_DECL,void RM_ZsetRangeStop(RedisModuleKey *kp);,6,41,module.c,RM_ZsetRangeStop,,false,492,492,RM_ZsetRangeStop,,,88,void RM_ZsetRangeStop (RedisModuleKey*)
165351,METHOD,module.c:<global>,TYPE_DECL,static void zsetKeyReset(RedisModuleKey *key);,13,45,module.c,zsetKeyReset,,false,493,493,zsetKeyReset,,,89,void zsetKeyReset (RedisModuleKey*)
165356,METHOD,module.c:<global>,TYPE_DECL,static void moduleInitKeyTypeSpecific(RedisModuleKey *key);,13,58,module.c,moduleInitKeyTypeSpecific,,false,494,494,moduleInitKeyTypeSpecific,,,90,void moduleInitKeyTypeSpecific (RedisModuleKey*)
165361,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);",6,57,module.c,RM_FreeDict,,false,495,495,RM_FreeDict,,,91,"void RM_FreeDict (RedisModuleCtx*,RedisModuleDict*)"
165367,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeServerInfo(RedisModuleCtx *ctx, RedisModuleServerInfoData *data);",6,76,module.c,RM_FreeServerInfo,,false,496,496,RM_FreeServerInfo,,,92,"void RM_FreeServerInfo (RedisModuleCtx*,RedisModuleServerInfoData*)"
165373,METHOD,module.c:<global>,TYPE_DECL,static int moduleValidateCommandInfo(const RedisModuleCommandInfo *info);,12,72,module.c,moduleValidateCommandInfo,,false,499,499,moduleValidateCommandInfo,,,93,int moduleValidateCommandInfo (RedisModuleCommandInfo*)
165378,METHOD,module.c:<global>,TYPE_DECL,"static int64_t moduleConvertKeySpecsFlags(int64_t flags, int from_api);",16,70,module.c,moduleConvertKeySpecsFlags,,false,500,500,moduleConvertKeySpecsFlags,,,94,"int64_t moduleConvertKeySpecsFlags (int64_t,int)"
165384,METHOD,module.c:<global>,TYPE_DECL,"static int moduleValidateCommandArgs(RedisModuleCommandArg *args,
                                     const RedisModuleCommandInfoVersion *version);",12,82,module.c,moduleValidateCommandArgs,,false,501,502,moduleValidateCommandArgs,,,95,"int moduleValidateCommandArgs (RedisModuleCommandArg*,RedisModuleCommandInfoVersion*)"
165392,METHOD,module.c:<global>,TYPE_DECL,"static redisCommandArgType moduleConvertArgType(RedisModuleCommandArgType type, int *error);",28,91,module.c,moduleConvertArgType,,false,505,505,moduleConvertArgType,,,98,"redisCommandArgType moduleConvertArgType (RedisModuleCommandArgType,int*)"
165398,METHOD,module.c:<global>,TYPE_DECL,static int moduleConvertArgFlags(int flags);,12,43,module.c,moduleConvertArgFlags,,false,506,506,moduleConvertArgFlags,,,99,int moduleConvertArgFlags (int)
165403,METHOD,module.c:<global>,TYPE_DECL,"void moduleCreateContext(RedisModuleCtx *out_ctx, RedisModule *module, int ctx_flags);",6,85,module.c,moduleCreateContext,,false,507,507,moduleCreateContext,,,100,"void moduleCreateContext (RedisModuleCtx*,RedisModule*,int)"
165410,METHOD,module.c:<global>,TYPE_DECL,"void *RM_Alloc(size_t bytes) {
    /* Use 'zmalloc_usable()' instead of 'zmalloc()' to allow the compiler
     * to recognize the additional memory size, which means that modules can
     * use the memory reported by 'RM_MallocUsableSize()' safely. In theory this
     * isn't really needed since this API can't be inlined (not even for embedded
     * modules like TLS (we use function pointers for module APIs), and the API doesn't
     * have the malloc_size attribute, but it's hard to predict how smart future compilers
     * will be, so better safe than sorry. */
    return zmalloc_usable(bytes,NULL);
}",1,1,module.c,RM_Alloc,,false,520,529,RM_Alloc,,,101,void* RM_Alloc (size_t)
165419,METHOD,module.c:<global>,TYPE_DECL,"void *RM_TryAlloc(size_t bytes) {
    return ztrymalloc_usable(bytes,NULL);
}",1,1,module.c,RM_TryAlloc,,false,533,535,RM_TryAlloc,,,102,void* RM_TryAlloc (size_t)
165428,METHOD,module.c:<global>,TYPE_DECL,"void *RM_Calloc(size_t nmemb, size_t size) {
    return zcalloc_usable(nmemb*size,NULL);
}",1,1,module.c,RM_Calloc,,false,541,543,RM_Calloc,,,103,"void* RM_Calloc (size_t,size_t)"
165440,METHOD,module.c:<global>,TYPE_DECL,"void* RM_Realloc(void *ptr, size_t bytes) {
    return zrealloc_usable(ptr,bytes,NULL);
}",1,1,module.c,RM_Realloc,,false,546,548,RM_Realloc,,,104,"void* RM_Realloc (void*,size_t)"
165451,METHOD,module.c:<global>,TYPE_DECL,"void RM_Free(void *ptr) {
    zfree(ptr);
}",1,1,module.c,RM_Free,,false,553,555,RM_Free,,,105,void RM_Free (void*)
165458,METHOD,module.c:<global>,TYPE_DECL,"char *RM_Strdup(const char *str) {
    return zstrdup(str);
}",1,1,module.c,RM_Strdup,,false,558,560,RM_Strdup,,,106,char* RM_Strdup (char*)
165466,METHOD,module.c:<global>,TYPE_DECL,"void poolAllocRelease(RedisModuleCtx *ctx) {
    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;

    while(head != NULL) {
        next = head->next;
        zfree(head);
        head = next;
    }
    ctx->pa_head = NULL;
}",1,1,module.c,poolAllocRelease,,false,567,576,poolAllocRelease,,,107,void poolAllocRelease (RedisModuleCtx*)
165498,METHOD,module.c:<global>,TYPE_DECL,"void *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {
    if (bytes == 0) return NULL;
    RedisModulePoolAllocBlock *b = ctx->pa_head;
    size_t left = b ? b->size - b->used : 0;

    /* Fix alignment. */
    if (left >= bytes) {
        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;
        while (bytes < alignment && alignment/2 >= bytes) alignment /= 2;
        if (b->used % alignment)
            b->used += alignment - (b->used % alignment);
        left = (b->used > b->size) ? 0 : b->size - b->used;
    }

    /* Create a new block if needed. */
    if (left < bytes) {
        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;
        if (blocksize < bytes) blocksize = bytes;
        b = zmalloc(sizeof(*b) + blocksize);
        b->size = blocksize;
        b->used = 0;
        b->next = ctx->pa_head;
        ctx->pa_head = b;
    }

    char *retval = b->memory + b->used;
    b->used += bytes;
    return retval;
}",1,27,module.c,RM_PoolAlloc,,false,590,618,RM_PoolAlloc,,,108,"void* RM_PoolAlloc (RedisModuleCtx*,size_t)"
165659,METHOD,module.c:<global>,TYPE_DECL,"client *moduleAllocTempClient(void) {
    client *c = NULL;

    if (moduleTempClientCount > 0) {
        c = moduleTempClients[--moduleTempClientCount];
        if (moduleTempClientCount < moduleTempClientMinCount)
            moduleTempClientMinCount = moduleTempClientCount;
    } else {
        c = createClient(NULL);
        c->flags |= CLIENT_MODULE;
        c->user = NULL; /* Root user */
    }
    return c;
}",1,20,module.c,moduleAllocTempClient,,false,624,637,moduleAllocTempClient,,,109,client moduleAllocTempClient (void)
165709,METHOD,module.c:<global>,TYPE_DECL,"static void freeRedisModuleAsyncRMCallPromise(RedisModuleAsyncRMCallPromise *promise) {
    if (--promise->ref_count > 0) {
        return;
    }
    /* When the promise is finally freed it can not have a client attached to it.
     * Either releasing the client or RM_CallReplyPromiseAbort would have removed it. */
    serverAssert(!promise->c);
    zfree(promise);
}",1,4,module.c,freeRedisModuleAsyncRMCallPromise,,false,639,647,freeRedisModuleAsyncRMCallPromise,,,110,void freeRedisModuleAsyncRMCallPromise (RedisModuleAsyncRMCallPromise*)
165746,METHOD,module.c:<global>,TYPE_DECL,"void moduleReleaseTempClient(client *c) {
    if (moduleTempClientCount == moduleTempClientCap) {
        moduleTempClientCap = moduleTempClientCap ? moduleTempClientCap*2 : 32;
        moduleTempClients = zrealloc(moduleTempClients, sizeof(c)*moduleTempClientCap);
    }
    clearClientConnectionState(c);
    listEmpty(c->reply);
    c->reply_bytes = 0;
    c->duration = 0;
    resetClient(c);
    c->bufpos = 0;
    c->flags = CLIENT_MODULE;
    c->user = NULL; /* Root user */
    c->cmd = c->lastcmd = c->realcmd = NULL;
    if (c->bstate.async_rm_call_handle) {
        RedisModuleAsyncRMCallPromise *promise = c->bstate.async_rm_call_handle;
        promise->c = NULL; /* Remove the client from the promise so it will no longer be possible to abort it. */
        freeRedisModuleAsyncRMCallPromise(promise);
        c->bstate.async_rm_call_handle = NULL;
    }
    moduleTempClients[moduleTempClientCount++] = c;
}",1,15,module.c,moduleReleaseTempClient,,false,649,670,moduleReleaseTempClient,,,111,void moduleReleaseTempClient (client*)
165857,METHOD,module.c:<global>,TYPE_DECL,"int moduleCreateEmptyKey(RedisModuleKey *key, int type) {
    robj *obj;

    /* The key must be open for writing and non existing to proceed. */
    if (!(key->mode & REDISMODULE_WRITE) || key->value)
        return REDISMODULE_ERR;

    switch(type) {
    case REDISMODULE_KEYTYPE_LIST:
        obj = createListListpackObject();
        break;
    case REDISMODULE_KEYTYPE_ZSET:
        obj = createZsetListpackObject();
        break;
    case REDISMODULE_KEYTYPE_HASH:
        obj = createHashObject();
        break;
    case REDISMODULE_KEYTYPE_STREAM:
        obj = createStreamObject();
        break;
    default: return REDISMODULE_ERR;
    }
    dbAdd(key->db,key->key,obj);
    key->value = obj;
    moduleInitKeyTypeSpecific(key);
    return REDISMODULE_OK;
}",1,22,module.c,moduleCreateEmptyKey,,false,684,710,moduleCreateEmptyKey,,,112,"int moduleCreateEmptyKey (RedisModuleKey*,int)"
165943,METHOD,module.c:<global>,TYPE_DECL,"static void moduleFreeKeyIterator(RedisModuleKey *key) {
    serverAssert(key->iter != NULL);
    switch (key->value->type) {
    case OBJ_LIST: listTypeReleaseIterator(key->iter); break;
    case OBJ_STREAM:
        streamIteratorStop(key->iter);
        zfree(key->iter);
        break;
    default: serverAssert(0); /* No key->iter for other types. */
    }
    key->iter = NULL;
}",1,4,module.c,moduleFreeKeyIterator,,false,713,724,moduleFreeKeyIterator,,,113,void moduleFreeKeyIterator (RedisModuleKey*)
166016,METHOD,module.c:<global>,TYPE_DECL,"static void moduleFreeListIterator(void *data) {
    RedisModuleKey *key = (RedisModuleKey*)data;
    serverAssert(key->value->type == OBJ_LIST);
    if (key->iter) moduleFreeKeyIterator(key);
}",1,4,module.c,moduleFreeListIterator,,false,728,732,moduleFreeListIterator,,,114,void moduleFreeListIterator (void*)
166054,METHOD,module.c:<global>,TYPE_DECL,"int moduleDelKeyIfEmpty(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) return 0;
    int isempty;
    robj *o = key->value;

    switch(o->type) {
    case OBJ_LIST: isempty = listTypeLength(o) == 0; break;
    case OBJ_SET: isempty = setTypeSize(o) == 0; break;
    case OBJ_ZSET: isempty = zsetLength(o) == 0; break;
    case OBJ_HASH: isempty = hashTypeLength(o) == 0; break;
    case OBJ_STREAM: isempty = streamLength(o) == 0; break;
    default: isempty = 0;
    }

    if (isempty) {
        if (key->iter) moduleFreeKeyIterator(key);
        dbDelete(key->db,key->key);
        key->value = NULL;
        return 1;
    } else {
        return 0;
    }
}",1,22,module.c,moduleDelKeyIfEmpty,,false,744,766,moduleDelKeyIfEmpty,,,115,int moduleDelKeyIfEmpty (RedisModuleKey*)
166178,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetApi(const char *funcname, void **targetPtrPtr) {
    /* Lookup the requested module API and store the function pointer into the
     * target pointer. The function returns REDISMODULE_ERR if there is no such
     * named API, otherwise REDISMODULE_OK.
     *
     * This function is not meant to be used by modules developer, it is only
     * used implicitly by including redismodule.h. */
    dictEntry *he = dictFind(server.moduleapi, funcname);
    if (!he) return REDISMODULE_ERR;
    *targetPtrPtr = dictGetVal(he);
    return REDISMODULE_OK;
}",1,20,module.c,RM_GetApi,,false,778,789,RM_GetApi,,,116,"int RM_GetApi (char*,void**)"
166209,METHOD,module.c:<global>,TYPE_DECL,"void modulePostExecutionUnitOperations(void) {
    if (server.execution_nesting)
        return;

    if (server.busy_module_yield_flags) {
        blockingOperationEnds();
        server.busy_module_yield_flags = BUSY_MODULE_YIELD_NONE;
        if (server.current_client)
            unprotectClient(server.current_client);
        unblockPostponedClients();
    }
}",1,41,module.c,modulePostExecutionUnitOperations,,false,791,802,modulePostExecutionUnitOperations,,,117,void modulePostExecutionUnitOperations (void)
166243,METHOD,module.c:<global>,TYPE_DECL,"void moduleFreeContext(RedisModuleCtx *ctx) {
    /* See comment in moduleCreateContext */
    if (!(ctx->flags & (REDISMODULE_CTX_THREAD_SAFE|REDISMODULE_CTX_COMMAND))) {
        exitExecutionUnit();
        postExecutionUnitOperations();
    }
    autoMemoryCollect(ctx);
    poolAllocRelease(ctx);
    if (ctx->postponed_arrays) {
        zfree(ctx->postponed_arrays);
        ctx->postponed_arrays_count = 0;
        serverLog(LL_WARNING,
            ""API misuse detected in module %s: ""
            ""RedisModule_ReplyWith*(REDISMODULE_POSTPONED_LEN) ""
            ""not matched by the same number of RedisModule_SetReply*Len() ""
            ""calls."",
            ctx->module->name);
    }
    /* If this context has a temp client, we return it back to the pool.
     * If this context created a new client (e.g detached context), we free it.
     * If the client is assigned manually, e.g ctx->client = someClientInstance,
     * none of these flags will be set and we do not attempt to free i...",1,24,module.c,moduleFreeContext,,false,805,831,moduleFreeContext,,,118,void moduleFreeContext (RedisModuleCtx*)
166341,METHOD,module.c:<global>,TYPE_DECL,"static CallReply *moduleParseReply(client *c, RedisModuleCtx *ctx) {
    /* Convert the result of the Redis command into a module reply. */
    sds proto = sdsnewlen(c->buf,c->bufpos);
    c->bufpos = 0;
    while(listLength(c->reply)) {
        clientReplyBlock *o = listNodeValue(listFirst(c->reply));

        proto = sdscatlen(proto,o->buf,o->used);
        listDelNode(c->reply,listFirst(c->reply));
    }
    CallReply *reply = callReplyCreate(proto, c->deferred_reply_errors, ctx);
    c->deferred_reply_errors = NULL; /* now the responsibility of the reply object. */
    return reply;
}",1,10,module.c,moduleParseReply,,false,833,846,moduleParseReply,,,119,"CallReply moduleParseReply (client*,RedisModuleCtx*)"
166426,METHOD,module.c:<global>,TYPE_DECL,"void moduleCallCommandUnblockedHandler(client *c) {
    RedisModuleCtx ctx;
    RedisModuleAsyncRMCallPromise *promise = c->bstate.async_rm_call_handle;
    serverAssert(promise);
    RedisModule *module = promise->module;
    if (!promise->on_unblocked) {
        moduleReleaseTempClient(c);
        return; /* module did not set any unblock callback. */
    }
    moduleCreateContext(&ctx, module, REDISMODULE_CTX_TEMP_CLIENT);
    selectDb(ctx.client, c->db->id);

    CallReply *reply = moduleParseReply(c, NULL);
    module->in_call++;
    promise->on_unblocked(&ctx, reply, promise->private_data);
    module->in_call--;

    moduleFreeContext(&ctx);
    moduleReleaseTempClient(c);
}",1,4,module.c,moduleCallCommandUnblockedHandler,,false,848,867,moduleCallCommandUnblockedHandler,,,120,void moduleCallCommandUnblockedHandler (client*)
166517,METHOD,module.c:<global>,TYPE_DECL,"void moduleCreateContext(RedisModuleCtx *out_ctx, RedisModule *module, int ctx_flags) {
    memset(out_ctx, 0 ,sizeof(RedisModuleCtx));
    out_ctx->getapifuncptr = (void*)(unsigned long)&RM_GetApi;
    out_ctx->module = module;
    out_ctx->flags = ctx_flags;
    if (ctx_flags & REDISMODULE_CTX_TEMP_CLIENT)
        out_ctx->client = moduleAllocTempClient();
    else if (ctx_flags & REDISMODULE_CTX_NEW_CLIENT)
        out_ctx->client = createClient(NULL);

    /* Calculate the initial yield time for long blocked contexts.
     * in loading we depend on the server hz, but in other cases we also wait
     * for busy_reply_threshold.
     * Note that in theory we could have started processing BUSY_MODULE_YIELD_EVENTS
     * sooner, and only delay the processing for clients till the busy_reply_threshold,
     * but this carries some overheads of frequently marking clients with BLOCKED_POSTPONE
     * and releasing them, i.e. if modules only block for short periods. */
    if (server.loa...",1,20,module.c,moduleCreateContext,,false,875,907,moduleCreateContext,,,121,"void moduleCreateContext (RedisModuleCtx*,RedisModule*,int)"
166628,METHOD,module.c:<global>,TYPE_DECL,"void RedisModuleCommandDispatcher(client *c) {
    RedisModuleCommand *cp = c->cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_COMMAND);

    ctx.client = c;
    cp->func(&ctx,(void**)c->argv,c->argc);
    moduleFreeContext(&ctx);

    /* In some cases processMultibulkBuffer uses sdsMakeRoomFor to
     * expand the query buffer, and in order to avoid a big object copy
     * the query buffer SDS may be used directly as the SDS string backing
     * the client argument vectors: sometimes this will result in the SDS
     * string having unused space at the end. Later if a module takes ownership
     * of the RedisString, such space will be wasted forever. Inside the
     * Redis core this is not a problem because tryObjectEncoding() is called
     * before storing strings in the key space. Here we need to do it
     * for the module. */
    for (int i = 0; i < c->argc; i++) {
        /* Only do the work if the module took ownership of...",1,42,module.c,RedisModuleCommandDispatcher,,false,911,935,RedisModuleCommandDispatcher,,,122,void RedisModuleCommandDispatcher (client*)
166707,METHOD,module.c:<global>,TYPE_DECL,"int moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    RedisModuleCommand *cp = cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_KEYS_POS_REQUEST);

    /* Initialize getKeysResult */
    getKeysPrepareResult(result, MAX_KEYS_BUFFER);
    ctx.keys_result = result;

    cp->func(&ctx,(void**)argv,argc);
    /* We currently always use the array allocated by RM_KeyAtPos() and don't try
     * to optimize for the pre-allocated buffer.
     */
    moduleFreeContext(&ctx);
    return result->numkeys;
}",1,42,module.c,moduleGetCommandKeysViaAPI,,false,946,961,moduleGetCommandKeysViaAPI,,,123,"int moduleGetCommandKeysViaAPI (redisCommand*,robj**,int,getKeysResult*)"
166760,METHOD,module.c:<global>,TYPE_DECL,"int moduleGetCommandChannelsViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {
    RedisModuleCommand *cp = cmd->module_cmd;
    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, cp->module, REDISMODULE_CTX_CHANNELS_POS_REQUEST);

    /* Initialize getKeysResult */
    getKeysPrepareResult(result, MAX_KEYS_BUFFER);
    ctx.keys_result = result;

    cp->func(&ctx,(void**)argv,argc);
    /* We currently always use the array allocated by RM_RM_ChannelAtPosWithFlags() and don't try
     * to optimize for the pre-allocated buffer. */
    moduleFreeContext(&ctx);
    return result->numkeys;
}",1,42,module.c,moduleGetCommandChannelsViaAPI,,false,966,980,moduleGetCommandChannelsViaAPI,,,124,"int moduleGetCommandChannelsViaAPI (redisCommand*,robj**,int,getKeysResult*)"
166813,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;
}",1,25,module.c,RM_IsKeysPositionRequest,,false,993,995,RM_IsKeysPositionRequest,,,125,int RM_IsKeysPositionRequest (RedisModuleCtx*)
166830,METHOD,module.c:<global>,TYPE_DECL,"void RM_KeyAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags) {
    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) || !ctx->keys_result) return;
    if (pos <= 0) return;

    getKeysResult *res = ctx->keys_result;

    /* Check overflow */
    if (res->numkeys == res->size) {
        int newsize = res->size + (res->size > 8192 ? 8192 : res->size);
        getKeysPrepareResult(res, newsize);
    }

    res->keys[res->numkeys].pos = pos;
    res->keys[res->numkeys].flags = moduleConvertKeySpecsFlags(flags, 1);
    res->numkeys++;
}",1,23,module.c,RM_KeyAtPosWithFlags,,false,1017,1032,RM_KeyAtPosWithFlags,,,126,"void RM_KeyAtPosWithFlags (RedisModuleCtx*,int,int)"
166924,METHOD,module.c:<global>,TYPE_DECL,"void RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {
    /* Default flags require full access */
    int flags = moduleConvertKeySpecsFlags(CMD_KEY_FULL_ACCESS, 0);
    RM_KeyAtPosWithFlags(ctx, pos, flags);
}",1,43,module.c,RM_KeyAtPos,,false,1037,1041,RM_KeyAtPos,,,127,"void RM_KeyAtPos (RedisModuleCtx*,int)"
166952,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsChannelsPositionRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_CHANNELS_POS_REQUEST) != 0;
}",1,25,module.c,RM_IsChannelsPositionRequest,,false,1046,1048,RM_IsChannelsPositionRequest,,,128,int RM_IsChannelsPositionRequest (RedisModuleCtx*)
166969,METHOD,module.c:<global>,TYPE_DECL,"void RM_ChannelAtPosWithFlags(RedisModuleCtx *ctx, int pos, int flags) {
    if (!(ctx->flags & REDISMODULE_CTX_CHANNELS_POS_REQUEST) || !ctx->keys_result) return;
    if (pos <= 0) return;

    getKeysResult *res = ctx->keys_result;

    /* Check overflow */
    if (res->numkeys == res->size) {
        int newsize = res->size + (res->size > 8192 ? 8192 : res->size);
        getKeysPrepareResult(res, newsize);
    }

    int new_flags = 0;
    if (flags & REDISMODULE_CMD_CHANNEL_SUBSCRIBE) new_flags |= CMD_CHANNEL_SUBSCRIBE;
    if (flags & REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE) new_flags |= CMD_CHANNEL_UNSUBSCRIBE;
    if (flags & REDISMODULE_CMD_CHANNEL_PUBLISH) new_flags |= CMD_CHANNEL_PUBLISH;
    if (flags & REDISMODULE_CMD_CHANNEL_PATTERN) new_flags |= CMD_CHANNEL_PATTERN;

    res->keys[res->numkeys].pos = pos;
    res->keys[res->numkeys].flags = new_flags;
    res->numkeys++;
}",1,23,module.c,RM_ChannelAtPosWithFlags,,false,1076,1097,RM_ChannelAtPosWithFlags,,,129,"void RM_ChannelAtPosWithFlags (RedisModuleCtx*,int,int)"
167129,METHOD,module.c:<global>,TYPE_DECL,"int isCommandNameValid(const char *name) {
    const char *block_chars = "" \r\n|@=,"";

    if (strpbrk(name, block_chars))
        return 0;
    return 1;
}",1,1,module.c,isCommandNameValid,,false,1111,1117,isCommandNameValid,,,130,int isCommandNameValid (char*)
167147,METHOD,module.c:<global>,TYPE_DECL,"int64_t commandFlagsFromString(char *s) {
    int count, j;
    int64_t flags = 0;
    sds *tokens = sdssplitlen(s,strlen(s),"" "",1,&count);
    for (j = 0; j < count; j++) {
        char *t = tokens[j];
        if (!strcasecmp(t,""write"")) flags |= CMD_WRITE;
        else if (!strcasecmp(t,""readonly"")) flags |= CMD_READONLY;
        else if (!strcasecmp(t,""admin"")) flags |= CMD_ADMIN;
        else if (!strcasecmp(t,""deny-oom"")) flags |= CMD_DENYOOM;
        else if (!strcasecmp(t,""deny-script"")) flags |= CMD_NOSCRIPT;
        else if (!strcasecmp(t,""allow-loading"")) flags |= CMD_LOADING;
        else if (!strcasecmp(t,""pubsub"")) flags |= CMD_PUBSUB;
        else if (!strcasecmp(t,""random"")) { /* Deprecated. Silently ignore. */ }
        else if (!strcasecmp(t,""blocking"")) flags |= CMD_BLOCKING;
        else if (!strcasecmp(t,""allow-stale"")) flags |= CMD_STALE;
        else if (!strcasecmp(t,""no-monitor"")) flags |= CMD_SKIP_MONITOR;
        else if (!strcasecmp(t,""no-slowlog"")) flags ...",1,45,module.c,commandFlagsFromString,,false,1123,1154,commandFlagsFromString,,,131,int64_t commandFlagsFromString (char*)
167493,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCommand *moduleCreateCommandProxy(struct RedisModule *module, sds declared_name, sds fullname, RedisModuleCmdFunc cmdfunc, int64_t flags, int firstkey, int lastkey, int keystep);",20,188,module.c,moduleCreateCommandProxy,,false,1156,1156,moduleCreateCommandProxy,,,132,"RedisModuleCommand* moduleCreateCommandProxy (RedisModule*,sds,sds,RedisModuleCmdFunc,int64_t,int,int,int)"
167505,METHOD,module.c:<global>,TYPE_DECL,"int RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
    if (!ctx->module->onload)
        return REDISMODULE_ERR;
    int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
    if (flags == -1) return REDISMODULE_ERR;
    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
        return REDISMODULE_ERR;

    /* Check if the command name is valid. */
    if (!isCommandNameValid(name))
        return REDISMODULE_ERR;

    /* Check if the command name is busy. */
    if (lookupCommandByCString(name) != NULL)
        return REDISMODULE_ERR;

    sds declared_name = sdsnew(name);
    RedisModuleCommand *cp = moduleCreateCommandProxy(ctx->module, declared_name, sdsdup(declared_name), cmdfunc, flags, firstkey, lastkey, keystep);
    cp->rediscmd->arity = cmdfunc ? -1 : -2; /* Default value, can be changed later via dedicated API */

    serverAssert(dictAdd(serve...",1,15,module.c,RM_CreateCommand,,false,1254,1278,RM_CreateCommand,,,133,"int RM_CreateCommand (RedisModuleCtx*,char*,RedisModuleCmdFunc,char*,int,int,int)"
167676,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCommand *moduleCreateCommandProxy(struct RedisModule *module, sds declared_name, sds fullname, RedisModuleCmdFunc cmdfunc, int64_t flags, int firstkey, int lastkey, int keystep) {
    struct redisCommand *rediscmd;
    RedisModuleCommand *cp;

    /* Create a command ""proxy"", which is a structure that is referenced
     * in the command table, so that the generic command that works as
     * binding between modules and Redis, can know what function to call
     * and what the module is. */
    cp = zcalloc(sizeof(*cp));
    cp->module = module;
    cp->func = cmdfunc;
    cp->rediscmd = zcalloc(sizeof(*rediscmd));
    cp->rediscmd->declared_name = declared_name; /* SDS for module commands */
    cp->rediscmd->fullname = fullname;
    cp->rediscmd->group = COMMAND_GROUP_MODULE;
    cp->rediscmd->proc = RedisModuleCommandDispatcher;
    cp->rediscmd->flags = flags | CMD_MODULE;
    cp->rediscmd->module_cmd = cp;
    if (firstkey != 0) {
        cp->rediscmd->key_specs_num =...",1,34,module.c,moduleCreateCommandProxy,,false,1287,1327,moduleCreateCommandProxy,,,134,"RedisModuleCommand moduleCreateCommandProxy (RedisModule*,sds,sds,RedisModuleCmdFunc,int64_t,int,int,int)"
167969,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCommand *RM_GetCommand(RedisModuleCtx *ctx, const char *name) {
    struct redisCommand *cmd = lookupCommandByCString(name);

    if (!cmd || !(cmd->flags & CMD_MODULE))
        return NULL;

    RedisModuleCommand *cp = cmd->module_cmd;
    if (cp->module != ctx->module)
        return NULL;

    return cp;
}",1,31,module.c,RM_GetCommand,,false,1338,1349,RM_GetCommand,,,135,"RedisModuleCommand RM_GetCommand (RedisModuleCtx*,char*)"
168016,METHOD,module.c:<global>,TYPE_DECL,"int RM_CreateSubcommand(RedisModuleCommand *parent, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {
    if (!parent->module->onload)
        return REDISMODULE_ERR;
    int64_t flags = strflags ? commandFlagsFromString((char*)strflags) : 0;
    if (flags == -1) return REDISMODULE_ERR;
    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)
        return REDISMODULE_ERR;

    struct redisCommand *parent_cmd = parent->rediscmd;

    if (parent_cmd->parent)
        return REDISMODULE_ERR; /* We don't allow more than one level of subcommands */

    RedisModuleCommand *parent_cp = parent_cmd->module_cmd;
    if (parent_cp->func)
        return REDISMODULE_ERR; /* A parent command should be a pure container of subcommands */

    /* Check if the command name is valid. */
    if (!isCommandNameValid(name))
        return REDISMODULE_ERR;

    /* Check if the command name is busy within the parent command. */
    sds...",1,15,module.c,RM_CreateSubcommand,,false,1378,1412,RM_CreateSubcommand,,,136,"int RM_CreateSubcommand (RedisModuleCommand*,char*,RedisModuleCmdFunc,char*,int,int,int)"
168177,METHOD,module.c:<global>,TYPE_DECL,"static RedisModuleCommandHistoryEntry *
moduleCmdHistoryEntryAt(const RedisModuleCommandInfoVersion *version,
                        RedisModuleCommandHistoryEntry *entries, int index) {
    off_t offset = index * version->sizeof_historyentry;
    return (RedisModuleCommandHistoryEntry *)((char *)(entries) + offset);
}",1,1,module.c,moduleCmdHistoryEntryAt,,false,1416,1421,moduleCmdHistoryEntryAt,,,137,"RedisModuleCommandHistoryEntry moduleCmdHistoryEntryAt (RedisModuleCommandInfoVersion*,RedisModuleCommandHistoryEntry*,int)"
168200,METHOD,module.c:<global>,TYPE_DECL,"static RedisModuleCommandKeySpec *
moduleCmdKeySpecAt(const RedisModuleCommandInfoVersion *version,
                   RedisModuleCommandKeySpec *keyspecs, int index) {
    off_t offset = index * version->sizeof_keyspec;
    return (RedisModuleCommandKeySpec *)((char *)(keyspecs) + offset);
}",1,1,module.c,moduleCmdKeySpecAt,,false,1422,1427,moduleCmdKeySpecAt,,,138,"RedisModuleCommandKeySpec moduleCmdKeySpecAt (RedisModuleCommandInfoVersion*,RedisModuleCommandKeySpec*,int)"
168223,METHOD,module.c:<global>,TYPE_DECL,"static RedisModuleCommandArg *
moduleCmdArgAt(const RedisModuleCommandInfoVersion *version,
               const RedisModuleCommandArg *args, int index) {
    off_t offset = index * version->sizeof_arg;
    return (RedisModuleCommandArg *)((char *)(args) + offset);
}",1,1,module.c,moduleCmdArgAt,,false,1428,1433,moduleCmdArgAt,,,139,"RedisModuleCommandArg moduleCmdArgAt (RedisModuleCommandInfoVersion*,RedisModuleCommandArg*,int)"
168246,METHOD,module.c:<global>,TYPE_DECL,"int populateArgsStructure(struct redisCommandArg *args) {
    if (!args)
        return 0;
    int count = 0;
    while (args->name) {
        serverAssert(count < INT_MAX);
        args->num_args = populateArgsStructure(args->subargs);
        count++;
        args++;
    }
    return count;
}",1,8,module.c,populateArgsStructure,,false,1437,1448,populateArgsStructure,,,140,int populateArgsStructure (redisCommandArg*)
168296,METHOD,module.c:<global>,TYPE_DECL,"int matchAclCategoryFlag(char *flag, int64_t *acl_categories_flags) {
    uint64_t this_flag = ACLGetCommandCategoryFlagByName(flag);
    if (this_flag) {
        *acl_categories_flags |= (int64_t) this_flag;
        return 1;
    }
    return 0; /* Unrecognized */
}",1,1,module.c,matchAclCategoryFlag,,false,1455,1462,matchAclCategoryFlag,,,141,"int matchAclCategoryFlag (char*,int64_t*)"
168320,METHOD,module.c:<global>,TYPE_DECL,"int64_t categoryFlagsFromString(char *aclflags) {
    int count, j;
    int64_t acl_categories_flags = 0;
    sds *tokens = sdssplitlen(aclflags,strlen(aclflags),"" "",1,&count);
    for (j = 0; j < count; j++) {
        char *t = tokens[j];
        if (!matchAclCategoryFlag(t, &acl_categories_flags)) {
            serverLog(LL_WARNING,""Unrecognized categories flag %s on module load"", t);
            break;
        }
    }
    sdsfreesplitres(tokens,count);
    if (j != count) return -1; /* Some token not processed correctly. */
    return acl_categories_flags;
}",1,12,module.c,categoryFlagsFromString,,false,1469,1483,categoryFlagsFromString,,,142,int64_t categoryFlagsFromString (char*)
168399,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetCommandACLCategories(RedisModuleCommand *command, const char *aclflags) {
    if (!command || !command->module || !command->module->onload) return REDISMODULE_ERR;
    int64_t categories_flags = aclflags ? categoryFlagsFromString((char*)aclflags) : 0;
    if (categories_flags == -1) return REDISMODULE_ERR;
    struct redisCommand *rcmd = command->rediscmd;
    rcmd->acl_categories = categories_flags; /* ACL categories flags for module command */
    command->module->num_commands_with_acl_categories++;
    return REDISMODULE_OK;
}",1,73,module.c,RM_SetCommandACLCategories,,false,1497,1505,RM_SetCommandACLCategories,,,143,"int RM_SetCommandACLCategories (RedisModuleCommand*,char*)"
168466,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetCommandInfo(RedisModuleCommand *command, const RedisModuleCommandInfo *info) {
    if (!moduleValidateCommandInfo(info)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    struct redisCommand *cmd = command->rediscmd;

    /* Check if any info has already been set. Overwriting info involves freeing
     * the old info, which is not implemented. */
    if (cmd->summary || cmd->complexity || cmd->since || cmd->history ||
        cmd->tips || cmd->args ||
        !(cmd->key_specs_num == 0 ||
          /* Allow key spec populated from legacy (first,last,step) to exist. */
          (cmd->key_specs_num == 1 &&
           cmd->key_specs[0].begin_search_type == KSPEC_BS_INDEX &&
           cmd->key_specs[0].find_keys_type == KSPEC_FK_RANGE))) {
        errno = EEXIST;
        return REDISMODULE_ERR;
    }

    if (info->summary) cmd->summary = zstrdup(info->summary);
    if (info->complexity) cmd->complexity = zstrdup(info->complexity);
    if (info->since) cmd-...",1,15,module.c,RM_SetCommandInfo,,false,1808,1945,RM_SetCommandInfo,,,144,"int RM_SetCommandInfo (RedisModuleCommand*,RedisModuleCommandInfo*)"
169258,METHOD,module.c:<global>,TYPE_DECL,"static inline int isPowerOfTwo(uint64_t v) {
    return v && !(v & (v - 1));
}",1,1,module.c,isPowerOfTwo,,false,1948,1950,isPowerOfTwo,,,145,int isPowerOfTwo (uint64_t)
169272,METHOD,module.c:<global>,TYPE_DECL,"static int moduleValidateCommandInfo(const RedisModuleCommandInfo *info) {
    const RedisModuleCommandInfoVersion *version = info->version;
    if (!version) {
        serverLog(LL_WARNING, ""Invalid command info: version missing"");
        return 0;
    }

    /* No validation for the fields summary, complexity, since, tips (strings or
     * NULL) and arity (any integer). */

    /* History: If since is set, changes must also be set. */
    if (info->history) {
        for (size_t j = 0;
             moduleCmdHistoryEntryAt(version, info->history, j)->since;
             j++)
        {
            if (!moduleCmdHistoryEntryAt(version, info->history, j)->changes) {
                serverLog(LL_WARNING, ""Invalid command info: history[%zd].changes missing"", j);
                return 0;
            }
        }
    }

    /* Key specs. */
    if (info->key_specs) {
        for (size_t j = 0;
             moduleCmdKeySpecAt(version, info->key_specs, j)->begin_search_type;
             ...",1,8,module.c,moduleValidateCommandInfo,,false,1953,2047,moduleValidateCommandInfo,,,146,int moduleValidateCommandInfo (RedisModuleCommandInfo*)
169650,METHOD,module.c:<global>,TYPE_DECL,"static int64_t moduleConvertKeySpecsFlags(int64_t flags, int from_api) {
    int64_t out = 0;
    int64_t map[][2] = {
        {REDISMODULE_CMD_KEY_RO, CMD_KEY_RO},
        {REDISMODULE_CMD_KEY_RW, CMD_KEY_RW},
        {REDISMODULE_CMD_KEY_OW, CMD_KEY_OW},
        {REDISMODULE_CMD_KEY_RM, CMD_KEY_RM},
        {REDISMODULE_CMD_KEY_ACCESS, CMD_KEY_ACCESS},
        {REDISMODULE_CMD_KEY_INSERT, CMD_KEY_INSERT},
        {REDISMODULE_CMD_KEY_UPDATE, CMD_KEY_UPDATE},
        {REDISMODULE_CMD_KEY_DELETE, CMD_KEY_DELETE},
        {REDISMODULE_CMD_KEY_NOT_KEY, CMD_KEY_NOT_KEY},
        {REDISMODULE_CMD_KEY_INCOMPLETE, CMD_KEY_INCOMPLETE},
        {REDISMODULE_CMD_KEY_VARIABLE_FLAGS, CMD_KEY_VARIABLE_FLAGS},
        {0,0}};

    int from_idx = from_api ? 0 : 1, to_idx = !from_idx;
    for (int i=0; map[i][0]; i++)
        if (flags & map[i][from_idx]) out |= map[i][to_idx];
    return out;
}",1,9,module.c,moduleConvertKeySpecsFlags,,false,2051,2071,moduleConvertKeySpecsFlags,,,147,"int64_t moduleConvertKeySpecsFlags (int64_t,int)"
169831,METHOD,module.c:<global>,TYPE_DECL,"static int moduleValidateCommandArgs(RedisModuleCommandArg *args,
                                     const RedisModuleCommandInfoVersion *version) {
    if (args == NULL) return 1; /* Missing args is OK. */
    for (size_t j = 0; moduleCmdArgAt(version, args, j)->name != NULL; j++) {
        RedisModuleCommandArg *arg = moduleCmdArgAt(version, args, j);
        int arg_type_error = 0;
        moduleConvertArgType(arg->type, &arg_type_error);
        if (arg_type_error) {
            serverLog(LL_WARNING,
                      ""Invalid command info: Argument \""%s\"": Undefined type %d"",
                      arg->name, arg->type);
            return 0;
        }
        if (arg->type == REDISMODULE_ARG_TYPE_PURE_TOKEN && !arg->token) {
            serverLog(LL_WARNING,
                      ""Invalid command info: Argument \""%s\"": ""
                      ""token required when type is PURE_TOKEN"", args[j].name);
            return 0;
        }

        if (arg->type == REDISMODULE_ARG_...",1,12,module.c,moduleValidateCommandArgs,,false,2075,2142,moduleValidateCommandArgs,,,148,"int moduleValidateCommandArgs (RedisModuleCommandArg*,RedisModuleCommandInfoVersion*)"
170144,METHOD,module.c:<global>,TYPE_DECL,"static struct redisCommandArg *moduleCopyCommandArgs(RedisModuleCommandArg *args,
                                                     const RedisModuleCommandInfoVersion *version) {
    size_t count = 0;
    while (moduleCmdArgAt(version, args, count)->name) count++;
    serverAssert(count < SIZE_MAX / sizeof(struct redisCommandArg));
    struct redisCommandArg *realargs = zcalloc((count+1) * sizeof(redisCommandArg));

    for (size_t j = 0; j < count; j++) {
        RedisModuleCommandArg *arg = moduleCmdArgAt(version, args, j);
        realargs[j].name = zstrdup(arg->name);
        realargs[j].type = moduleConvertArgType(arg->type, NULL);
        if (arg->type == REDISMODULE_ARG_TYPE_KEY)
            realargs[j].key_spec_index = arg->key_spec_index;
        else
            realargs[j].key_spec_index = -1;
        if (arg->token) realargs[j].token = zstrdup(arg->token);
        if (arg->summary) realargs[j].summary = zstrdup(arg->summary);
        if (arg->since) realargs[j].since...",1,4,module.c,moduleCopyCommandArgs,,false,2146,2170,moduleCopyCommandArgs,,,149,"struct redisCommandArg moduleCopyCommandArgs (RedisModuleCommandArg*,RedisModuleCommandInfoVersion*)"
170361,METHOD,module.c:<global>,TYPE_DECL,"static redisCommandArgType moduleConvertArgType(RedisModuleCommandArgType type, int *error) {
    if (error) *error = 0;
    switch (type) {
    case REDISMODULE_ARG_TYPE_STRING: return ARG_TYPE_STRING;
    case REDISMODULE_ARG_TYPE_INTEGER: return ARG_TYPE_INTEGER;
    case REDISMODULE_ARG_TYPE_DOUBLE: return ARG_TYPE_DOUBLE;
    case REDISMODULE_ARG_TYPE_KEY: return ARG_TYPE_KEY;
    case REDISMODULE_ARG_TYPE_PATTERN: return ARG_TYPE_PATTERN;
    case REDISMODULE_ARG_TYPE_UNIX_TIME: return ARG_TYPE_UNIX_TIME;
    case REDISMODULE_ARG_TYPE_PURE_TOKEN: return ARG_TYPE_PURE_TOKEN;
    case REDISMODULE_ARG_TYPE_ONEOF: return ARG_TYPE_ONEOF;
    case REDISMODULE_ARG_TYPE_BLOCK: return ARG_TYPE_BLOCK;
    default:
        if (error) *error = 1;
        return -1;
    }
}",1,1,module.c,moduleConvertArgType,,false,2172,2188,moduleConvertArgType,,,150,"redisCommandArgType moduleConvertArgType (RedisModuleCommandArgType,int*)"
170424,METHOD,module.c:<global>,TYPE_DECL,"static int moduleConvertArgFlags(int flags) {
    int realflags = 0;
    if (flags & REDISMODULE_CMD_ARG_OPTIONAL) realflags |= CMD_ARG_OPTIONAL;
    if (flags & REDISMODULE_CMD_ARG_MULTIPLE) realflags |= CMD_ARG_MULTIPLE;
    if (flags & REDISMODULE_CMD_ARG_MULTIPLE_TOKEN) realflags |= CMD_ARG_MULTIPLE_TOKEN;
    return realflags;
}",1,16,module.c,moduleConvertArgFlags,,false,2190,2196,moduleConvertArgFlags,,,151,int moduleConvertArgFlags (int)
170483,METHOD,module.c:<global>,TYPE_DECL,"void *moduleGetHandleByName(char *modulename) {
    return dictFetchValue(modules,modulename);
}",1,1,module.c,moduleGetHandleByName,,false,2199,2201,moduleGetHandleByName,,,152,void* moduleGetHandleByName (char*)
170492,METHOD,module.c:<global>,TYPE_DECL,"int moduleIsModuleCommand(void *module_handle, struct redisCommand *cmd) {
    if (cmd->proc != RedisModuleCommandDispatcher)
        return 0;
    if (module_handle == NULL)
        return 0;
    RedisModuleCommand *cp = cmd->module_cmd;
    return (cp->module == module_handle);
}",1,1,module.c,moduleIsModuleCommand,,false,2204,2211,moduleIsModuleCommand,,,153,"int moduleIsModuleCommand (void*,redisCommand*)"
170526,METHOD,module.c:<global>,TYPE_DECL,"int moduleListConfigMatch(void *config, void *name) {
    return strcasecmp(((ModuleConfig *) config)->name, (char *) name) == 0;
}",1,1,module.c,moduleListConfigMatch,,false,2217,2219,moduleListConfigMatch,,,154,"int moduleListConfigMatch (void*,void*)"
170544,METHOD,module.c:<global>,TYPE_DECL,"void moduleListFree(void *config) {
    ModuleConfig *module_config = (ModuleConfig *) config;
    sdsfree(module_config->name);
    zfree(config);
}",1,1,module.c,moduleListFree,,false,2221,2225,moduleListFree,,,155,void moduleListFree (void*)
170561,METHOD,module.c:<global>,TYPE_DECL,"void RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
    /* Called by RM_Init() to setup the `ctx->module` structure.
     *
     * This is an internal function, Redis modules developers don't need
     * to use it. */
    RedisModule *module;

    if (ctx->module != NULL) return;
    module = zmalloc(sizeof(*module));
    module->name = sdsnew(name);
    module->ver = ver;
    module->apiver = apiver;
    module->types = listCreate();
    module->usedby = listCreate();
    module->using = listCreate();
    module->filters = listCreate();
    module->module_configs = listCreate();
    listSetMatchMethod(module->module_configs, moduleListConfigMatch);
    listSetFreeMethod(module->module_configs, moduleListFree);
    module->in_call = 0;
    module->configs_initialized = 0;
    module->in_hook = 0;
    module->options = 0;
    module->info_cb = 0;
    module->defrag_cb = 0;
    module->loadmod = NULL;
    module->num_commands_with_acl_categories = 0;...",1,4,module.c,RM_SetModuleAttribs,,false,2227,2256,RM_SetModuleAttribs,,,156,"void RM_SetModuleAttribs (RedisModuleCtx*,char*,int,int)"
170701,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsModuleNameBusy(const char *name) {
    sds modulename = sdsnew(name);
    dictEntry *de = dictFind(modules,modulename);
    sdsfree(modulename);
    return de != NULL;
}",1,1,module.c,RM_IsModuleNameBusy,,false,2260,2265,RM_IsModuleNameBusy,,,157,int RM_IsModuleNameBusy (char*)
170723,METHOD,module.c:<global>,TYPE_DECL,"mstime_t RM_Milliseconds(void) {
    return mstime();
}",1,1,module.c,RM_Milliseconds,,false,2268,2270,RM_Milliseconds,,,158,mstime_t RM_Milliseconds (void)
170730,METHOD,module.c:<global>,TYPE_DECL,"uint64_t RM_MonotonicMicroseconds(void) {
    return getMonotonicUs();
}",1,1,module.c,RM_MonotonicMicroseconds,,false,2273,2275,RM_MonotonicMicroseconds,,,159,uint64_t RM_MonotonicMicroseconds (void)
170737,METHOD,module.c:<global>,TYPE_DECL,"ustime_t RM_Microseconds(void) {
    return ustime();
}",1,1,module.c,RM_Microseconds,,false,2278,2280,RM_Microseconds,,,160,ustime_t RM_Microseconds (void)
170744,METHOD,module.c:<global>,TYPE_DECL,"ustime_t RM_CachedMicroseconds(void) {
    return server.ustime;
}",1,1,module.c,RM_CachedMicroseconds,,false,2288,2290,RM_CachedMicroseconds,,,161,ustime_t RM_CachedMicroseconds (void)
170753,METHOD,module.c:<global>,TYPE_DECL,"int RM_BlockedClientMeasureTimeStart(RedisModuleBlockedClient *bc) {
    elapsedStart(&(bc->background_timer));
    return REDISMODULE_OK;
}",1,11,module.c,RM_BlockedClientMeasureTimeStart,,false,2298,2301,RM_BlockedClientMeasureTimeStart,,,162,int RM_BlockedClientMeasureTimeStart (RedisModuleBlockedClient*)
170767,METHOD,module.c:<global>,TYPE_DECL,"int RM_BlockedClientMeasureTimeEnd(RedisModuleBlockedClient *bc) {
    // If the counter is 0 then we haven't called RM_BlockedClientMeasureTimeStart
    if (!bc->background_timer)
        return REDISMODULE_ERR;
    bc->background_duration += elapsedUs(bc->background_timer);
    return REDISMODULE_OK;
}",1,15,module.c,RM_BlockedClientMeasureTimeEnd,,false,2308,2314,RM_BlockedClientMeasureTimeEnd,,,163,int RM_BlockedClientMeasureTimeEnd (RedisModuleBlockedClient*)
170794,METHOD,module.c:<global>,TYPE_DECL,"void RM_Yield(RedisModuleCtx *ctx, int flags, const char *busy_reply) {
    static int yield_nesting = 0;
    /* Avoid nested calls to RM_Yield */
    if (yield_nesting)
        return;
    yield_nesting++;

    long long now = getMonotonicUs();
    if (now >= ctx->next_yield_time) {
        /* In loading mode, there's no need to handle busy_module_yield_reply,
         * and busy_module_yield_flags, since redis is anyway rejecting all
         * commands with -LOADING. */
        if (server.loading) {
            /* Let redis process events */
            processEventsWhileBlocked();
        } else {
            const char *prev_busy_module_yield_reply = server.busy_module_yield_reply;
            server.busy_module_yield_reply = busy_reply;
            /* start the blocking operation if not already started. */
            if (!server.busy_module_yield_flags) {
                server.busy_module_yield_flags = BUSY_MODULE_YIELD_EVENTS;
                blockingOperationStarts();
    ...",1,49,module.c,RM_Yield,,false,2337,2379,RM_Yield,,,164,"void RM_Yield (RedisModuleCtx*,int,char*)"
170913,METHOD,module.c:<global>,TYPE_DECL,"void RM_SetModuleOptions(RedisModuleCtx *ctx, int options) {
    ctx->module->options = options;
}",1,1,module.c,RM_SetModuleOptions,,false,2404,2406,RM_SetModuleOptions,,,165,"void RM_SetModuleOptions (RedisModuleCtx*,int)"
170926,METHOD,module.c:<global>,TYPE_DECL,"int RM_SignalModifiedKey(RedisModuleCtx *ctx, RedisModuleString *keyname) {
    signalModifiedKey(ctx->client,ctx->client->db,keyname);
    return REDISMODULE_OK;
}",1,46,module.c,RM_SignalModifiedKey,,false,2415,2418,RM_SignalModifiedKey,,,166,"int RM_SignalModifiedKey (RedisModuleCtx*,robj*)"
170946,METHOD,module.c:<global>,TYPE_DECL,"void RM_AutoMemory(RedisModuleCtx *ctx) {
    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
}",1,18,module.c,RM_AutoMemory,,false,2439,2441,RM_AutoMemory,,,167,void RM_AutoMemory (RedisModuleCtx*)
170960,METHOD,module.c:<global>,TYPE_DECL,"void autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
    if (ctx->amqueue_used == ctx->amqueue_len) {
        ctx->amqueue_len *= 2;
        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;
        ctx->amqueue = zrealloc(ctx->amqueue,sizeof(struct AutoMemEntry)*ctx->amqueue_len);
    }
    ctx->amqueue[ctx->amqueue_used].type = type;
    ctx->amqueue[ctx->amqueue_used].ptr = ptr;
    ctx->amqueue_used++;
}",1,23,module.c,autoMemoryAdd,,false,2444,2454,autoMemoryAdd,,,168,"void autoMemoryAdd (RedisModuleCtx*,int,void*)"
171046,METHOD,module.c:<global>,TYPE_DECL,"int autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;

    int count = (ctx->amqueue_used+1)/2;
    for (int j = 0; j < count; j++) {
        for (int side = 0; side < 2; side++) {
            /* For side = 0 check right side of the array, for
             * side = 1 check the left side instead (zig-zag scanning). */
            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;
            if (ctx->amqueue[i].type == type &&
                ctx->amqueue[i].ptr == ptr)
            {
                ctx->amqueue[i].type = REDISMODULE_AM_FREED;

                /* Switch the freed element and the last element, to avoid growing
                 * the queue unnecessarily if we allocate/free in a loop */
                if (i != ctx->amqueue_used-1) {
                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];
                }

                /* Reduce the size of the queue because we either moved...",1,23,module.c,autoMemoryFreed,,false,2461,2489,autoMemoryFreed,,,169,"int autoMemoryFreed (RedisModuleCtx*,int,void*)"
171180,METHOD,module.c:<global>,TYPE_DECL,"void autoMemoryCollect(RedisModuleCtx *ctx) {
    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;
    /* Clear the AUTO_MEMORY flag from the context, otherwise the functions
     * we call to free the resources, will try to scan the auto release
     * queue to mark the entries as freed. */
    ctx->flags &= ~REDISMODULE_CTX_AUTO_MEMORY;
    int j;
    for (j = 0; j < ctx->amqueue_used; j++) {
        void *ptr = ctx->amqueue[j].ptr;
        switch(ctx->amqueue[j].type) {
        case REDISMODULE_AM_STRING: decrRefCount(ptr); break;
        case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;
        case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;
        case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;
        case REDISMODULE_AM_INFO: RM_FreeServerInfo(NULL,ptr); break;
        }
    }
    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;
    zfree(ctx->amqueue);
    ctx->amqueue = NULL;
    ctx->amqueue_len = 0;
    ctx->amqueue_used = 0;
}",1,23,module.c,autoMemoryCollect,,false,2492,2514,autoMemoryCollect,,,170,void autoMemoryCollect (RedisModuleCtx*)
171306,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {
    RedisModuleString *o = createStringObject(ptr,len);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",1,17,module.c,RM_CreateString,,false,2530,2534,RM_CreateString,,,171,"robj RM_CreateString (RedisModuleCtx*,char*,size_t)"
171334,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {
    sds s = sdsempty();

    va_list ap;
    va_start(ap, fmt);
    s = sdscatvprintf(s, fmt, ap);
    va_end(ap);

    RedisModuleString *o = createObject(OBJ_STRING, s);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);

    return o;
}",1,17,module.c,RM_CreateStringPrintf,,false,2544,2556,RM_CreateStringPrintf,,,172,"robj RM_CreateStringPrintf (RedisModuleCtx*,char*...)"
171377,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {
    char buf[LONG_STR_SIZE];
    size_t len = ll2string(buf,sizeof(buf),ll);
    return RM_CreateString(ctx,buf,len);
}",1,17,module.c,RM_CreateStringFromLongLong,,false,2567,2571,RM_CreateStringFromLongLong,,,173,"robj RM_CreateStringFromLongLong (RedisModuleCtx*,long long)"
171397,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromULongLong(RedisModuleCtx *ctx, unsigned long long ull) {
    char buf[LONG_STR_SIZE];
    size_t len = ull2string(buf,sizeof(buf),ull);
    return RM_CreateString(ctx,buf,len);
}",1,17,module.c,RM_CreateStringFromULongLong,,false,2581,2585,RM_CreateStringFromULongLong,,,174,"robj RM_CreateStringFromULongLong (RedisModuleCtx*,long long unsigned)"
171417,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromDouble(RedisModuleCtx *ctx, double d) {
    char buf[MAX_D2STRING_CHARS];
    size_t len = d2string(buf,sizeof(buf),d);
    return RM_CreateString(ctx,buf,len);
}",1,17,module.c,RM_CreateStringFromDouble,,false,2592,2596,RM_CreateStringFromDouble,,,175,"robj RM_CreateStringFromDouble (RedisModuleCtx*,double)"
171437,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromLongDouble(RedisModuleCtx *ctx, long double ld, int humanfriendly) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    size_t len = ld2string(buf,sizeof(buf),ld,
        (humanfriendly ? LD_STR_HUMAN : LD_STR_AUTO));
    return RM_CreateString(ctx,buf,len);
}",1,17,module.c,RM_CreateStringFromLongDouble,,false,2606,2611,RM_CreateStringFromLongDouble,,,176,"robj RM_CreateStringFromLongDouble (RedisModuleCtx*,long double,int)"
171462,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {
    RedisModuleString *o = dupStringObject(str);
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",1,17,module.c,RM_CreateStringFromString,,false,2621,2625,RM_CreateStringFromString,,,177,"robj RM_CreateStringFromString (RedisModuleCtx*,robj*)"
171488,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromStreamID(RedisModuleCtx *ctx, const RedisModuleStreamID *id) {
    streamID streamid = {id->ms, id->seq};
    RedisModuleString *o = createObjectFromStreamID(&streamid);
    if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, o);
    return o;
}",1,17,module.c,RM_CreateStringFromStreamID,,false,2632,2637,RM_CreateStringFromStreamID,,,178,"robj RM_CreateStringFromStreamID (RedisModuleCtx*,RedisModuleStreamID*)"
171525,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {
    decrRefCount(str);
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);
}",1,40,module.c,RM_FreeString,,false,2651,2654,RM_FreeString,,,179,"void RM_FreeString (RedisModuleCtx*,robj*)"
171544,METHOD,module.c:<global>,TYPE_DECL,"void RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {
    if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {
        /* Increment the string reference counting only if we can't
         * just remove the object from the list of objects that should
         * be reclaimed. Why we do that, instead of just incrementing
         * the refcount in any case, and let the automatic FreeString()
         * call at the end to bring the refcount back at the desired
         * value? Because this way we ensure that the object refcount
         * value is 1 (instead of going to 2 to be dropped later to 1)
         * after the call to this function. This is needed for functions
         * like RedisModule_StringAppendBuffer() to work. */
        incrRefCount(str);
    }
}",1,42,module.c,RM_RetainString,,false,2688,2701,RM_RetainString,,,180,"void RM_RetainString (RedisModuleCtx*,robj*)"
171565,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString* RM_HoldString(RedisModuleCtx *ctx, RedisModuleString *str) {
    if (str->refcount == OBJ_STATIC_REFCOUNT) {
        return RM_CreateStringFromString(ctx, str);
    }

    incrRefCount(str);
    if (ctx != NULL) {
        /*
         * Put the str in the auto memory management of the ctx.
         * It might already be there, in this case, the ref count will
         * be 2 and we will decrease the ref count twice and free the
         * object in the auto memory free function.
         *
         * Why we can not do the same trick of just remove the object
         * from the auto memory (like in RM_RetainString)?
         * This code shows the issue:
         *
         * RM_AutoMemory(ctx);
         * str1 = RM_CreateString(ctx, ""test"", 4);
         * str2 = RM_HoldString(ctx, str1);
         * RM_FreeString(str1);
         * RM_FreeString(str2);
         *
         * If after the RM_HoldString we would just remove the string from
         * the auto memory, th...",1,17,module.c,RM_HoldString,,false,2730,2767,RM_HoldString,,,181,"robj RM_HoldString (RedisModuleCtx*,robj*)"
171601,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {
    if (str == NULL) {
        const char *errmsg = ""(NULL string reply referenced in module)"";
        if (len) *len = strlen(errmsg);
        return errmsg;
    }
    if (len) *len = sdslen(str->ptr);
    return str->ptr;
}",1,34,module.c,RM_StringPtrLen,,false,2772,2780,RM_StringPtrLen,,,182,"const char* RM_StringPtrLen (robj*,size_t*)"
171640,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringToLongLong(const RedisModuleString *str, long long *ll) {
    return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :
                                                     REDISMODULE_ERR;
}",1,30,module.c,RM_StringToLongLong,,false,2790,2793,RM_StringToLongLong,,,183,"int RM_StringToLongLong (robj*,long long*)"
171663,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringToULongLong(const RedisModuleString *str, unsigned long long *ull) {
    return string2ull(str->ptr,ull) ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,31,module.c,RM_StringToULongLong,,false,2799,2801,RM_StringToULongLong,,,184,"int RM_StringToULongLong (robj*,long long unsigned*)"
171682,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringToDouble(const RedisModuleString *str, double *d) {
    int retval = getDoubleFromObject(str,d);
    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,28,module.c,RM_StringToDouble,,false,2806,2809,RM_StringToDouble,,,185,"int RM_StringToDouble (robj*,double*)"
171707,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringToLongDouble(const RedisModuleString *str, long double *ld) {
    int retval = string2ld(str->ptr,sdslen(str->ptr),ld);
    return retval ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,32,module.c,RM_StringToLongDouble,,false,2814,2817,RM_StringToLongDouble,,,186,"int RM_StringToLongDouble (robj*,long double*)"
171734,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringToStreamID(const RedisModuleString *str, RedisModuleStreamID *id) {
    streamID streamid;
    if (streamParseID(str, &streamid) == C_OK) {
        id->ms = streamid.ms;
        id->seq = streamid.seq;
        return REDISMODULE_OK;
    } else {
        return REDISMODULE_ERR;
    }
}",1,30,module.c,RM_StringToStreamID,,false,2824,2833,RM_StringToStreamID,,,187,"int RM_StringToStreamID (robj*,RedisModuleStreamID*)"
171775,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringCompare(const RedisModuleString *a, const RedisModuleString *b) {
    return compareStringObjects(a,b);
}",1,27,module.c,RM_StringCompare,,false,2838,2840,RM_StringCompare,,,188,"int RM_StringCompare (robj*,robj*)"
171785,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {
    if (str->refcount != 1) {
        serverLog(LL_WARNING,
            ""Module attempted to use an in-place string modify operation ""
            ""with a string referenced multiple times. Please check the code ""
            ""for API usage correctness."");
        return NULL;
    }
    if (str->encoding == OBJ_ENCODING_EMBSTR) {
        /* Note: here we ""leak"" the additional allocation that was
         * used in order to store the embedded string in the object. */
        str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));
        str->encoding = OBJ_ENCODING_RAW;
    } else if (str->encoding == OBJ_ENCODING_INT) {
        /* Convert the string from integer to raw encoding. */
        str->ptr = sdsfromlonglong((long)str->ptr);
        str->encoding = OBJ_ENCODING_RAW;
    }
    return str;
}",1,17,module.c,moduleAssertUnsharedString,,false,2844,2863,moduleAssertUnsharedString,,,189,robj moduleAssertUnsharedString (robj*)
171875,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {
    UNUSED(ctx);
    str = moduleAssertUnsharedString(str);
    if (str == NULL) return REDISMODULE_ERR;
    str->ptr = sdscatlen(str->ptr,buf,len);
    return REDISMODULE_OK;
}",1,47,module.c,RM_StringAppendBuffer,,false,2868,2874,RM_StringAppendBuffer,,,190,"int RM_StringAppendBuffer (RedisModuleCtx*,robj*,char*,size_t)"
171916,METHOD,module.c:<global>,TYPE_DECL,"void RM_TrimStringAllocation(RedisModuleString *str) {
    if (!str) return;
    trimStringObjectIfNeeded(str, 1);
}",1,29,module.c,RM_TrimStringAllocation,,false,2899,2902,RM_TrimStringAllocation,,,191,void RM_TrimStringAllocation (robj*)
171929,METHOD,module.c:<global>,TYPE_DECL,"int RM_WrongArity(RedisModuleCtx *ctx) {
    addReplyErrorArity(ctx->client);
    return REDISMODULE_OK;
}",1,11,module.c,RM_WrongArity,,false,2935,2938,RM_WrongArity,,,192,int RM_WrongArity (RedisModuleCtx*)
171942,METHOD,module.c:<global>,TYPE_DECL,"client *moduleGetReplyClient(RedisModuleCtx *ctx) {
    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {
        if (ctx->blocked_client)
            return ctx->blocked_client->reply_client;
        else
            return NULL;
    } else {
        /* If this is a non thread safe context, just return the client
         * that is running the command if any. This may be NULL as well
         * in the case of contexts that are not executed with associated
         * clients, like timer contexts. */
        return ctx->client;
    }
}",1,21,module.c,moduleGetReplyClient,,false,2954,2967,moduleGetReplyClient,,,193,client moduleGetReplyClient (RedisModuleCtx*)
171979,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyLongLong(c,ll);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithLongLong,,false,2971,2976,RM_ReplyWithLongLong,,,194,"int RM_ReplyWithLongLong (RedisModuleCtx*,long long)"
172006,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyErrorFormat(c,""-%s"",err);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithError,,false,2992,2997,RM_ReplyWithError,,,195,"int RM_ReplyWithError (RedisModuleCtx*,char*)"
172034,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithErrorFormat(RedisModuleCtx *ctx, const char *fmt, ...) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;

    int len = strlen(fmt) + 2; /* 1 for the \0 and 1 for the hyphen */
    char *hyphenfmt = zmalloc(len);
    snprintf(hyphenfmt, len, ""-%s"", fmt);

    va_list ap;
    va_start(ap, fmt);
    addReplyErrorFormatInternal(c, 0, hyphenfmt, ap);
    va_end(ap);

    zfree(hyphenfmt);

    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithErrorFormat,,false,3013,3029,RM_ReplyWithErrorFormat,,,196,"int RM_ReplyWithErrorFormat (RedisModuleCtx*,char*...)"
172088,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyProto(c,""+"",1);
    addReplyProto(c,msg,strlen(msg));
    addReplyProto(c,""\r\n"",2);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithSimpleString,,false,3036,3043,RM_ReplyWithSimpleString,,,197,"int RM_ReplyWithSimpleString (RedisModuleCtx*,char*)"
172125,METHOD,module.c:<global>,TYPE_DECL,"int moduleReplyWithCollection(RedisModuleCtx *ctx, long len, int type) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    if (len == REDISMODULE_POSTPONED_LEN) {
        ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*
                (ctx->postponed_arrays_count+1));
        ctx->postponed_arrays[ctx->postponed_arrays_count] =
            addReplyDeferredLen(c);
        ctx->postponed_arrays_count++;
    } else if (len == 0) {
        switch (type) {
        case COLLECTION_REPLY_ARRAY:
            addReply(c, shared.emptyarray);
            break;
        case COLLECTION_REPLY_MAP:
            addReply(c, shared.emptymap[c->resp]);
            break;
        case COLLECTION_REPLY_SET:
            addReply(c, shared.emptyset[c->resp]);
            break;
        case COLLECTION_REPLY_ATTRIBUTE:
            addReplyAttributeLen(c,len);
            break;
        default:
            serverPanic(""Invalid module empty reply ...",1,26,module.c,moduleReplyWithCollection,,false,3050,3094,moduleReplyWithCollection,,,198,"int moduleReplyWithCollection (RedisModuleCtx*,long,int)"
172301,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_ARRAY);
}",1,47,module.c,RM_ReplyWithArray,,false,3105,3107,RM_ReplyWithArray,,,199,"int RM_ReplyWithArray (RedisModuleCtx*,long)"
172314,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithMap(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_MAP);
}",1,47,module.c,RM_ReplyWithMap,,false,3122,3124,RM_ReplyWithMap,,,200,"int RM_ReplyWithMap (RedisModuleCtx*,long)"
172327,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithSet(RedisModuleCtx *ctx, long len) {
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_SET);
}",1,47,module.c,RM_ReplyWithSet,,false,3139,3141,RM_ReplyWithSet,,,201,"int RM_ReplyWithSet (RedisModuleCtx*,long)"
172340,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithAttribute(RedisModuleCtx *ctx, long len) {
    if (ctx->client->resp == 2) return REDISMODULE_ERR;
 
    return moduleReplyWithCollection(ctx, len, COLLECTION_REPLY_ATTRIBUTE);
}",1,39,module.c,RM_ReplyWithAttribute,,false,3155,3159,RM_ReplyWithAttribute,,,202,"int RM_ReplyWithAttribute (RedisModuleCtx*,long)"
172366,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithNullArray(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyNullArray(c);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithNullArray,,false,3169,3174,RM_ReplyWithNullArray,,,203,int RM_ReplyWithNullArray (RedisModuleCtx*)
172391,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithEmptyArray(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReply(c,shared.emptyarray);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithEmptyArray,,false,3179,3184,RM_ReplyWithEmptyArray,,,204,int RM_ReplyWithEmptyArray (RedisModuleCtx*)
172419,METHOD,module.c:<global>,TYPE_DECL,"void moduleReplySetCollectionLength(RedisModuleCtx *ctx, long len, int type) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return;
    if (ctx->postponed_arrays_count == 0) {
        serverLog(LL_WARNING,
            ""API misuse detected in module %s: ""
            ""RedisModule_ReplySet*Length() called without previous ""
            ""RedisModule_ReplyWith*(ctx,REDISMODULE_POSTPONED_LEN) ""
            ""call."", ctx->module->name);
            return;
    }
    ctx->postponed_arrays_count--;
    switch(type) {
    case COLLECTION_REPLY_ARRAY:
        setDeferredArrayLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_MAP:
        setDeferredMapLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_SET:
        setDeferredSetLen(c,ctx->postponed_arrays[ctx->postponed_arrays_count],len);
        break;
    case COLLECTION_REPLY_ATTRIBUTE:
        setDeferredAttributeLen(...",1,8,module.c,moduleReplySetCollectionLength,,false,3186,3218,moduleReplySetCollectionLength,,,205,"void moduleReplySetCollectionLength (RedisModuleCtx*,long,int)"
172561,METHOD,module.c:<global>,TYPE_DECL,"void RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_ARRAY);
}",1,45,module.c,RM_ReplySetArrayLength,,false,3246,3248,RM_ReplySetArrayLength,,,206,"void RM_ReplySetArrayLength (RedisModuleCtx*,long)"
172573,METHOD,module.c:<global>,TYPE_DECL,"void RM_ReplySetMapLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_MAP);
}",1,45,module.c,RM_ReplySetMapLength,,false,3254,3256,RM_ReplySetMapLength,,,207,"void RM_ReplySetMapLength (RedisModuleCtx*,long)"
172585,METHOD,module.c:<global>,TYPE_DECL,"void RM_ReplySetSetLength(RedisModuleCtx *ctx, long len) {
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_SET);
}",1,45,module.c,RM_ReplySetSetLength,,false,3260,3262,RM_ReplySetSetLength,,,208,"void RM_ReplySetSetLength (RedisModuleCtx*,long)"
172597,METHOD,module.c:<global>,TYPE_DECL,"void RM_ReplySetAttributeLength(RedisModuleCtx *ctx, long len) {
    if (ctx->client->resp == 2) return;
    moduleReplySetCollectionLength(ctx, len, COLLECTION_REPLY_ATTRIBUTE);
}",1,45,module.c,RM_ReplySetAttributeLength,,false,3268,3271,RM_ReplySetAttributeLength,,,209,"void RM_ReplySetAttributeLength (RedisModuleCtx*,long)"
172619,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulkCBuffer(c,(char*)buf,len);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithStringBuffer,,false,3276,3281,RM_ReplyWithStringBuffer,,,210,"int RM_ReplyWithStringBuffer (RedisModuleCtx*,char*,size_t)"
172650,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithCString(RedisModuleCtx *ctx, const char *buf) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulkCString(c,(char*)buf);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithCString,,false,3287,3292,RM_ReplyWithCString,,,211,"int RM_ReplyWithCString (RedisModuleCtx*,char*)"
172679,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBulk(c,str);
    return REDISMODULE_OK;
}",1,44,module.c,RM_ReplyWithString,,false,3297,3302,RM_ReplyWithString,,,212,"int RM_ReplyWithString (RedisModuleCtx*,robj*)"
172706,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithEmptyString(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReply(c,shared.emptybulk);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithEmptyString,,false,3307,3312,RM_ReplyWithEmptyString,,,213,int RM_ReplyWithEmptyString (RedisModuleCtx*)
172734,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithVerbatimStringType(RedisModuleCtx *ctx, const char *buf, size_t len, const char *ext) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyVerbatim(c, buf, len, ext);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithVerbatimStringType,,false,3318,3323,RM_ReplyWithVerbatimStringType,,,214,"int RM_ReplyWithVerbatimStringType (RedisModuleCtx*,char*,size_t,char*)"
172765,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithVerbatimString(RedisModuleCtx *ctx, const char *buf, size_t len) {
	return RM_ReplyWithVerbatimStringType(ctx, buf, len, ""txt"");
}",1,1,module.c,RM_ReplyWithVerbatimString,,false,3329,3331,RM_ReplyWithVerbatimString,,,215,"int RM_ReplyWithVerbatimString (RedisModuleCtx*,char*,size_t)"
172778,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithNull(RedisModuleCtx *ctx) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyNull(c);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithNull,,false,3336,3341,RM_ReplyWithNull,,,216,int RM_ReplyWithNull (RedisModuleCtx*)
172803,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithBool(RedisModuleCtx *ctx, int b) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBool(c,b);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithBool,,false,3350,3355,RM_ReplyWithBool,,,217,"int RM_ReplyWithBool (RedisModuleCtx*,int)"
172830,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    if (c->resp == 2 && callReplyIsResp3(reply)) {
        /* The reply is in RESP3 format and the client is RESP2,
         * so it isn't possible to send this reply to the client. */
        return REDISMODULE_ERR;
    }
    size_t proto_len;
    const char *proto = callReplyGetProto(reply, &proto_len);
    addReplyProto(c, proto, proto_len);
    /* Propagate the error list from that reply to the other client, to do some
     * post error reply handling, like statistics.
     * Note that if the original reply had an array with errors, and the module
     * replied with just a portion of the original reply, and not the entire
     * reply, the errors are currently not propagated and the errors stats
     * will not get propagated. */
    list *errors = callReplyDeferredErrorList(reply);
    if (errors)
        deferredAft...",1,26,module.c,RM_ReplyWithCallReply,,false,3370,3391,RM_ReplyWithCallReply,,,218,"int RM_ReplyWithCallReply (RedisModuleCtx*,RedisModuleCallReply*)"
172891,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyDouble(c,d);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithDouble,,false,3405,3410,RM_ReplyWithDouble,,,219,"int RM_ReplyWithDouble (RedisModuleCtx*,double)"
172918,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithBigNumber(RedisModuleCtx *ctx, const char *bignum, size_t len) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyBigNum(c, bignum, len);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithBigNumber,,false,3420,3425,RM_ReplyWithBigNumber,,,220,"int RM_ReplyWithBigNumber (RedisModuleCtx*,char*,size_t)"
172947,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplyWithLongDouble(RedisModuleCtx *ctx, long double ld) {
    client *c = moduleGetReplyClient(ctx);
    if (c == NULL) return REDISMODULE_OK;
    addReplyHumanLongDouble(c, ld);
    return REDISMODULE_OK;
}",1,26,module.c,RM_ReplyWithLongDouble,,false,3435,3440,RM_ReplyWithLongDouble,,,221,"int RM_ReplyWithLongDouble (RedisModuleCtx*,long double)"
172974,METHOD,module.c:<global>,TYPE_DECL,"int RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    struct redisCommand *cmd;
    robj **argv = NULL;
    int argc = 0, flags = 0, j;
    va_list ap;

    cmd = lookupCommandByCString((char*)cmdname);
    if (!cmd) return REDISMODULE_ERR;

    /* Create the client and dispatch the command. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    va_end(ap);
    if (argv == NULL) return REDISMODULE_ERR;

    /* Select the propagation target. Usually is AOF + replicas, however
     * the caller can exclude one or the other using the ""A"" or ""R""
     * modifiers. */
    int target = 0;
    if (!(flags & REDISMODULE_ARGV_NO_AOF)) target |= PROPAGATE_AOF;
    if (!(flags & REDISMODULE_ARGV_NO_REPLICAS)) target |= PROPAGATE_REPL;

    alsoPropagate(ctx->client->db->id,argv,argc,target);

    /* Release the argv. */
    for (j = 0; j < argc; j++) decrRefCount(argv[j]);
    zfree(argv);
    server.dirty++;
    re...",1,21,module.c,RM_Replicate,,false,3483,3512,RM_Replicate,,,222,"int RM_Replicate (RedisModuleCtx*,char*,char*...)"
173103,METHOD,module.c:<global>,TYPE_DECL,"int RM_ReplicateVerbatim(RedisModuleCtx *ctx) {
    alsoPropagate(ctx->client->db->id,
        ctx->client->argv,ctx->client->argc,
        PROPAGATE_AOF|PROPAGATE_REPL);
    server.dirty++;
    return REDISMODULE_OK;
}",1,8,module.c,RM_ReplicateVerbatim,,false,3525,3531,RM_ReplicateVerbatim,,,223,int RM_ReplicateVerbatim (RedisModuleCtx*)
173141,METHOD,module.c:<global>,TYPE_DECL,"unsigned long long RM_GetClientId(RedisModuleCtx *ctx) {
    if (ctx->client == NULL) return 0;
    return ctx->client->id;
}",1,1,module.c,RM_GetClientId,,false,3556,3559,RM_GetClientId,,,224,unsigned long long RM_GetClientId (RedisModuleCtx*)
173161,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_GetClientUserNameById(RedisModuleCtx *ctx, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL) {
        errno = ENOENT;
        return NULL;
    }
    
    if (client->user == NULL) {
        errno = ENOTSUP;
        return NULL;
    }

    sds name = sdsnew(client->user->name);
    robj *str = createObject(OBJ_STRING, name);
    autoMemoryAdd(ctx, REDISMODULE_AM_STRING, str);
    return str;
}",1,17,module.c,RM_GetClientUserNameById,,false,3565,3581,RM_GetClientUserNameById,,,225,"robj RM_GetClientUserNameById (RedisModuleCtx*,uint64_t)"
173219,METHOD,module.c:<global>,TYPE_DECL,"int modulePopulateClientInfoStructure(void *ci, client *client, int structver) {
    if (structver != 1) return REDISMODULE_ERR;

    RedisModuleClientInfoV1 *ci1 = ci;
    memset(ci1,0,sizeof(*ci1));
    ci1->version = structver;
    if (client->flags & CLIENT_MULTI)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_MULTI;
    if (client->flags & CLIENT_PUBSUB)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_PUBSUB;
    if (client->flags & CLIENT_UNIX_SOCKET)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET;
    if (client->flags & CLIENT_TRACKING)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_TRACKING;
    if (client->flags & CLIENT_BLOCKED)
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_BLOCKED;
    if (client->conn->type == connectionTypeTls())
        ci1->flags |= REDISMODULE_CLIENTINFO_FLAG_SSL;

    int port;
    connAddrPeerName(client->conn,ci1->addr,sizeof(ci1->addr),&port);
    ci1->port = port;
    ci1->db = client->db->id;
    ci1->id = client->id;...",1,31,module.c,modulePopulateClientInfoStructure,,false,3589,3614,modulePopulateClientInfoStructure,,,226,"int modulePopulateClientInfoStructure (void*,client*,int)"
173407,METHOD,module.c:<global>,TYPE_DECL,"int modulePopulateReplicationInfoStructure(void *ri, int structver) {
    if (structver != 1) return REDISMODULE_ERR;

    RedisModuleReplicationInfoV1 *ri1 = ri;
    memset(ri1,0,sizeof(*ri1));
    ri1->version = structver;
    ri1->master = server.masterhost==NULL;
    ri1->masterhost = server.masterhost? server.masterhost: """";
    ri1->masterport = server.masterport;
    ri1->replid1 = server.replid;
    ri1->replid2 = server.replid2;
    ri1->repl1_offset = server.master_repl_offset;
    ri1->repl2_offset = server.second_replid_offset;
    return REDISMODULE_OK;
}",1,31,module.c,modulePopulateReplicationInfoStructure,,false,3621,3635,modulePopulateReplicationInfoStructure,,,227,"int modulePopulateReplicationInfoStructure (void*,int)"
173497,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetClientInfoById(void *ci, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL) return REDISMODULE_ERR;
    if (ci == NULL) return REDISMODULE_OK;

    /* Fill the info structure if passed. */
    uint64_t structver = ((uint64_t*)ci)[0];
    return modulePopulateClientInfoStructure(ci,client,structver);
}",1,31,module.c,RM_GetClientInfoById,,false,3679,3687,RM_GetClientInfoById,,,228,"int RM_GetClientInfoById (void*,uint64_t)"
173539,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_GetClientNameById(RedisModuleCtx *ctx, uint64_t id) {
    client *client = lookupClientByID(id);
    if (client == NULL || client->name == NULL) return NULL;
    robj *name = client->name;
    incrRefCount(name);
    autoMemoryAdd(ctx, REDISMODULE_AM_STRING, name);
    return name;
}",1,17,module.c,RM_GetClientNameById,,false,3693,3700,RM_GetClientNameById,,,229,"robj RM_GetClientNameById (RedisModuleCtx*,uint64_t)"
173579,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetClientNameById(uint64_t id, RedisModuleString *name) {
    client *client = lookupClientByID(id);
    if (client == NULL) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    if (clientSetName(client, name, NULL) == C_ERR) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",1,38,module.c,RM_SetClientNameById,,false,3710,3721,RM_SetClientNameById,,,230,"int RM_SetClientNameById (uint64_t,robj*)"
173624,METHOD,module.c:<global>,TYPE_DECL,"int RM_PublishMessage(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {
    UNUSED(ctx);
    return pubsubPublishMessageAndPropagateToCluster(channel, message, 0);
}",1,43,module.c,RM_PublishMessage,,false,3724,3727,RM_PublishMessage,,,231,"int RM_PublishMessage (RedisModuleCtx*,robj*,robj*)"
173642,METHOD,module.c:<global>,TYPE_DECL,"int RM_PublishMessageShard(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) {
    UNUSED(ctx);
    return pubsubPublishMessageAndPropagateToCluster(channel, message, 1);
}",1,48,module.c,RM_PublishMessageShard,,false,3730,3733,RM_PublishMessageShard,,,232,"int RM_PublishMessageShard (RedisModuleCtx*,robj*,robj*)"
173660,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetSelectedDb(RedisModuleCtx *ctx) {
    return ctx->client->db->id;
}",1,1,module.c,RM_GetSelectedDb,,false,3736,3738,RM_GetSelectedDb,,,233,int RM_GetSelectedDb (RedisModuleCtx*)
173673,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetContextFlags(RedisModuleCtx *ctx) {
    int flags = 0;

    /* Client specific flags */
    if (ctx) {
        if (ctx->client) {
            if (ctx->client->flags & CLIENT_DENY_BLOCKING)
                flags |= REDISMODULE_CTX_FLAGS_DENY_BLOCKING;
            /* Module command received from MASTER, is replicated. */
            if (ctx->client->flags & CLIENT_MASTER)
                flags |= REDISMODULE_CTX_FLAGS_REPLICATED;
            if (ctx->client->resp == 3) {
                flags |= REDISMODULE_CTX_FLAGS_RESP3;
            }
        }

        /* For DIRTY flags, we need the blocked client if used */
        client *c = ctx->blocked_client ? ctx->blocked_client->client : ctx->client;
        if (c && (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC))) {
            flags |= REDISMODULE_CTX_FLAGS_MULTI_DIRTY;
        }
    }

    if (scriptIsRunning())
        flags |= REDISMODULE_CTX_FLAGS_LUA;

    if (server.in_exec)
        flags |= REDISMODULE_CTX_FLAGS_MULTI...",1,37,module.c,RM_GetContextFlags,,false,3810,3899,RM_GetContextFlags,,,234,int RM_GetContextFlags (RedisModuleCtx*)
174102,METHOD,module.c:<global>,TYPE_DECL,"int RM_AvoidReplicaTraffic(void) {
    return !!(isPausedActionsWithUpdate(PAUSE_ACTION_REPLICA));
}",1,40,module.c,RM_AvoidReplicaTraffic,,false,3921,3923,RM_AvoidReplicaTraffic,,,235,int RM_AvoidReplicaTraffic (void)
174116,METHOD,module.c:<global>,TYPE_DECL,"int RM_SelectDb(RedisModuleCtx *ctx, int newid) {
    int retval = selectDb(ctx->client,newid);
    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,22,module.c,RM_SelectDb,,false,3935,3938,RM_SelectDb,,,236,"int RM_SelectDb (RedisModuleCtx*,int)"
174143,METHOD,module.c:<global>,TYPE_DECL,"int RM_KeyExists(RedisModuleCtx *ctx, robj *keyname) {
    robj *value = lookupKeyReadWithFlags(ctx->client->db, keyname, LOOKUP_NOTOUCH);
    return (value != NULL);
}",1,67,module.c,RM_KeyExists,,false,3946,3949,RM_KeyExists,,,237,"int RM_KeyExists (RedisModuleCtx*,robj*)"
174168,METHOD,module.c:<global>,TYPE_DECL,"static void moduleInitKey(RedisModuleKey *kp, RedisModuleCtx *ctx, robj *keyname, robj *value, int mode){
    kp->ctx = ctx;
    kp->db = ctx->client->db;
    kp->key = keyname;
    incrRefCount(keyname);
    kp->value = value;
    kp->iter = NULL;
    kp->mode = mode;
    if (kp->value) moduleInitKeyTypeSpecific(kp);
}",1,1,module.c,moduleInitKey,,false,3952,3961,moduleInitKey,,,238,"void moduleInitKey (RedisModuleKey*,RedisModuleCtx*,robj*,robj*,int)"
174220,METHOD,module.c:<global>,TYPE_DECL,"static void moduleInitKeyTypeSpecific(RedisModuleKey *key) {
    switch (key->value->type) {
    case OBJ_ZSET: zsetKeyReset(key); break;
    case OBJ_STREAM: key->u.stream.signalready = 0; break;
    }
}",1,9,module.c,moduleInitKeyTypeSpecific,,false,3964,3969,moduleInitKeyTypeSpecific,,,239,void moduleInitKeyTypeSpecific (RedisModuleKey*)
174253,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleKey *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {
    RedisModuleKey *kp;
    robj *value;
    int flags = 0;
    flags |= (mode & REDISMODULE_OPEN_KEY_NOTOUCH? LOOKUP_NOTOUCH: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NONOTIFY? LOOKUP_NONOTIFY: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOSTATS? LOOKUP_NOSTATS: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOEXPIRE? LOOKUP_NOEXPIRE: 0);
    flags |= (mode & REDISMODULE_OPEN_KEY_NOEFFECTS? LOOKUP_NOEFFECTS: 0);

    if (mode & REDISMODULE_WRITE) {
        value = lookupKeyWriteWithFlags(ctx->client->db,keyname, flags);
    } else {
        value = lookupKeyReadWithFlags(ctx->client->db,keyname, flags);
        if (value == NULL) {
            return NULL;
        }
    }

    /* Setup the key handle. */
    kp = zmalloc(sizeof(*kp));
    moduleInitKey(kp, ctx, keyname, value, mode);
    autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);
    return kp;
}",1,21,module.c,RM_OpenKey,,false,3992,4016,RM_OpenKey,,,240,"RedisModuleKey RM_OpenKey (RedisModuleCtx*,robj*,int)"
174416,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetOpenKeyModesAll(void) {
    return _REDISMODULE_OPEN_KEY_ALL;
}",1,11,module.c,RM_GetOpenKeyModesAll,,false,4031,4033,RM_GetOpenKeyModesAll,,,241,int RM_GetOpenKeyModesAll (void)
174451,METHOD,module.c:<global>,TYPE_DECL,"static void moduleCloseKey(RedisModuleKey *key) {
    int signal = SHOULD_SIGNAL_MODIFIED_KEYS(key->ctx);
    if ((key->mode & REDISMODULE_WRITE) && signal)
        signalModifiedKey(key->ctx->client,key->db,key->key);
    if (key->value) {
        if (key->iter) moduleFreeKeyIterator(key);
        switch (key->value->type) {
        case OBJ_ZSET:
            RM_ZsetRangeStop(key);
            break;
        case OBJ_STREAM:
            if (key->u.stream.signalready)
                /* One or more RM_StreamAdd() have been done. */
                signalKeyAsReady(key->db, key->key, OBJ_STREAM);
            break;
        }
    }
    serverAssert(key->iter == NULL);
    decrRefCount(key->key);
}",1,17,module.c,moduleCloseKey,,false,4036,4055,moduleCloseKey,,,242,void moduleCloseKey (RedisModuleKey*)
174580,METHOD,module.c:<global>,TYPE_DECL,"void RM_CloseKey(RedisModuleKey *key) {
    if (key == NULL) return;
    moduleCloseKey(key);
    autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);
    zfree(key);
}",1,29,module.c,RM_CloseKey,,false,4058,4063,RM_CloseKey,,,243,void RM_CloseKey (RedisModuleKey*)
174603,METHOD,module.c:<global>,TYPE_DECL,"int RM_KeyType(RedisModuleKey *key) {
    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;
    /* We map between defines so that we are free to change the internal
     * defines as desired. */
    switch(key->value->type) {
    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;
    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;
    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;
    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;
    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;
    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;
    case OBJ_STREAM: return REDISMODULE_KEYTYPE_STREAM;
    default: return REDISMODULE_KEYTYPE_EMPTY;
    }
}",1,51,module.c,RM_KeyType,,false,4067,4081,RM_KeyType,,,244,int RM_KeyType (RedisModuleKey*)
174691,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_ValueLength(RedisModuleKey *key) {
    if (key == NULL || key->value == NULL) return 0;
    switch(key->value->type) {
    case OBJ_STRING: return stringObjectLen(key->value);
    case OBJ_LIST: return listTypeLength(key->value);
    case OBJ_SET: return setTypeSize(key->value);
    case OBJ_ZSET: return zsetLength(key->value);
    case OBJ_HASH: return hashTypeLength(key->value);
    case OBJ_STREAM: return streamLength(key->value);
    default: return 0;
    }
}",1,9,module.c,RM_ValueLength,,false,4088,4099,RM_ValueLength,,,245,size_t RM_ValueLength (RedisModuleKey*)
174773,METHOD,module.c:<global>,TYPE_DECL,"int RM_DeleteKey(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value) {
        dbDelete(key->db,key->key);
        key->value = NULL;
    }
    return REDISMODULE_OK;
}",1,22,module.c,RM_DeleteKey,,false,4105,4112,RM_DeleteKey,,,246,int RM_DeleteKey (RedisModuleKey*)
174815,METHOD,module.c:<global>,TYPE_DECL,"int RM_UnlinkKey(RedisModuleKey *key) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value) {
        dbAsyncDelete(key->db,key->key);
        key->value = NULL;
    }
    return REDISMODULE_OK;
}",1,22,module.c,RM_UnlinkKey,,false,4119,4126,RM_UnlinkKey,,,247,int RM_UnlinkKey (RedisModuleKey*)
174857,METHOD,module.c:<global>,TYPE_DECL,"mstime_t RM_GetExpire(RedisModuleKey *key) {
    mstime_t expire = getExpire(key->db,key->key);
    if (expire == -1 || key->value == NULL)
        return REDISMODULE_NO_EXPIRE;
    expire -= commandTimeSnapshot();
    return expire >= 0 ? expire : 0;
}",1,15,module.c,RM_GetExpire,,false,4131,4137,RM_GetExpire,,,248,mstime_t RM_GetExpire (RedisModuleKey*)
174899,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetExpire(RedisModuleKey *key, mstime_t expire) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL || (expire < 0 && expire != REDISMODULE_NO_EXPIRE))
        return REDISMODULE_ERR;
    if (expire != REDISMODULE_NO_EXPIRE) {
        expire += commandTimeSnapshot();
        setExpire(key->ctx->client,key->db,key->key,expire);
    } else {
        removeExpire(key->db,key->key);
    }
    return REDISMODULE_OK;
}",1,22,module.c,RM_SetExpire,,false,4148,4158,RM_SetExpire,,,249,"int RM_SetExpire (RedisModuleKey*,mstime_t)"
174975,METHOD,module.c:<global>,TYPE_DECL,"mstime_t RM_GetAbsExpire(RedisModuleKey *key) {
    mstime_t expire = getExpire(key->db,key->key);
    if (expire == -1 || key->value == NULL)
        return REDISMODULE_NO_EXPIRE;
    return expire;
}",1,15,module.c,RM_GetAbsExpire,,false,4163,4168,RM_GetAbsExpire,,,250,mstime_t RM_GetAbsExpire (RedisModuleKey*)
175009,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetAbsExpire(RedisModuleKey *key, mstime_t expire) {
    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL || (expire < 0 && expire != REDISMODULE_NO_EXPIRE))
        return REDISMODULE_ERR;
    if (expire != REDISMODULE_NO_EXPIRE) {
        setExpire(key->ctx->client,key->db,key->key,expire);
    } else {
        removeExpire(key->db,key->key);
    }
    return REDISMODULE_OK;
}",1,22,module.c,RM_SetAbsExpire,,false,4179,4188,RM_SetAbsExpire,,,251,"int RM_SetAbsExpire (RedisModuleKey*,mstime_t)"
175082,METHOD,module.c:<global>,TYPE_DECL,"void RM_ResetDataset(int restart_aof, int async) {
    if (restart_aof && server.aof_state != AOF_OFF) stopAppendOnly();
    flushAllDataAndResetRDB((async? EMPTYDB_ASYNC: EMPTYDB_NO_FLAGS) | EMPTYDB_NOFUNCTIONS);
    if (server.aof_enabled && restart_aof) restartAOFAfterSYNC();
}",1,43,module.c,RM_ResetDataset,,false,4194,4198,RM_ResetDataset,,,252,"void RM_ResetDataset (int,int)"
175125,METHOD,module.c:<global>,TYPE_DECL,"unsigned long long RM_DbSize(RedisModuleCtx *ctx) {
    return dictSize(ctx->client->db->dict);
}",1,11,module.c,RM_DbSize,,false,4201,4203,RM_DbSize,,,253,unsigned long long RM_DbSize (RedisModuleCtx*)
175163,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_RandomKey(RedisModuleCtx *ctx) {
    robj *key = dbRandomKey(ctx->client->db);
    autoMemoryAdd(ctx,REDISMODULE_AM_STRING,key);
    return key;
}",1,17,module.c,RM_RandomKey,,false,4206,4210,RM_RandomKey,,,254,robj RM_RandomKey (RedisModuleCtx*)
175185,METHOD,module.c:<global>,TYPE_DECL,"const RedisModuleString *RM_GetKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->from_key;
}",1,6,module.c,RM_GetKeyNameFromOptCtx,,false,4213,4215,RM_GetKeyNameFromOptCtx,,,255,robj RM_GetKeyNameFromOptCtx (RedisModuleKeyOptCtx*)
175194,METHOD,module.c:<global>,TYPE_DECL,"const RedisModuleString *RM_GetToKeyNameFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->to_key;
}",1,6,module.c,RM_GetToKeyNameFromOptCtx,,false,4218,4220,RM_GetToKeyNameFromOptCtx,,,256,robj RM_GetToKeyNameFromOptCtx (RedisModuleKeyOptCtx*)
175203,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->from_dbid;
}",1,1,module.c,RM_GetDbIdFromOptCtx,,false,4223,4225,RM_GetDbIdFromOptCtx,,,257,int RM_GetDbIdFromOptCtx (RedisModuleKeyOptCtx*)
175212,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetToDbIdFromOptCtx(RedisModuleKeyOptCtx *ctx) {
    return ctx->to_dbid;
}",1,1,module.c,RM_GetToDbIdFromOptCtx,,false,4228,4230,RM_GetToDbIdFromOptCtx,,,258,int RM_GetToDbIdFromOptCtx (RedisModuleKeyOptCtx*)
175221,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
    RM_DeleteKey(key);
    setKey(key->ctx->client,key->db,key->key,str,SETKEY_NO_SIGNAL);
    key->value = str;
    return REDISMODULE_OK;
}",1,38,module.c,RM_StringSet,,false,4241,4247,RM_StringSet,,,259,"int RM_StringSet (RedisModuleKey*,robj*)"
175274,METHOD,module.c:<global>,TYPE_DECL,"char *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {
    /* We need to return *some* pointer for empty keys, we just return
     * a string literal pointer, that is the advantage to be mapped into
     * a read only memory page, so the module will segfault if a write
     * attempt is performed. */
    char *emptystring = ""<dma-empty-string>"";
    if (key->value == NULL) {
        *len = 0;
        return emptystring;
    }

    if (key->value->type != OBJ_STRING) return NULL;

    /* For write access, and even for read access if the object is encoded,
     * we unshare the string (that has the side effect of decoding it). */
    if ((mode & REDISMODULE_WRITE) || key->value->encoding != OBJ_ENCODING_RAW)
        key->value = dbUnshareStringValue(key->db, key->key, key->value);

    *len = sdslen(key->value->ptr);
    return key->value->ptr;
}",1,28,module.c,RM_StringDMA,,false,4278,4298,RM_StringDMA,,,260,"char* RM_StringDMA (RedisModuleKey*,size_t*,int)"
175359,METHOD,module.c:<global>,TYPE_DECL,"int RM_StringTruncate(RedisModuleKey *key, size_t newlen) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;
    if (newlen > 512*1024*1024) return REDISMODULE_ERR;

    /* Empty key and new len set to 0. Just return REDISMODULE_OK without
     * doing anything. */
    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;

    if (key->value == NULL) {
        /* Empty key: create it with the new size. */
        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));
        setKey(key->ctx->client,key->db,key->key,o,SETKEY_NO_SIGNAL);
        key->value = o;
        decrRefCount(o);
    } else {
        /* Unshare and resize. */
        key->value = dbUnshareStringValue(key->db, key->key, key->value);
        size_t curlen = sdslen(key->value->ptr);
        if (newlen > curlen) {
            key->value->ptr = sdsgrowzero(key->value->ptr,newlen);
        } else if (newlen < cu...",1,22,module.c,RM_StringTruncate,,false,4312,4341,RM_StringTruncate,,,261,"int RM_StringTruncate (RedisModuleKey*,size_t)"
175558,METHOD,module.c:<global>,TYPE_DECL,"int moduleListIteratorSeek(RedisModuleKey *key, long index, int mode) {
    if (!key) {
        errno = EINVAL;
        return 0;
    } else if (!key->value || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return 0;
    } if (!(key->mode & mode)) {
        errno = EBADF;
        return 0;
    }

    long length = listTypeLength(key->value);
    if (index < -length || index >= length) {
        errno = EDOM; /* Invalid index */
        return 0;
    }

    if (key->iter == NULL) {
        /* No existing iterator. Create one. */
        key->iter = listTypeInitIterator(key->value, index, LIST_TAIL);
        serverAssert(key->iter != NULL);
        serverAssert(listTypeNext(key->iter, &key->u.list.entry));
        key->u.list.index = index;
        return 1;
    }

    /* There's an existing iterator. Make sure the requested index has the same
     * sign as the iterator's index. */
    if      (index < 0 && key->u.list.index >= 0) index += length;
    else if (index...",1,50,module.c,moduleListIteratorSeek,,false,4375,4417,moduleListIteratorSeek,,,262,"int moduleListIteratorSeek (RedisModuleKey*,long,int)"
175843,METHOD,module.c:<global>,TYPE_DECL,"int RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {
    if (!key || !ele) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key->value != NULL && key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }

    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;
    if (key->iter) moduleFreeKeyIterator(key);
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);
    listTypeTryConversionAppend(key->value, &ele, 0, 0, moduleFreeListIterator, key);
    listTypePush(key->value, ele,
        (where == REDISMODULE_LIST_HEAD) ? LIST_HEAD : LIST_TAIL);
    return REDISMODULE_OK;
}",1,48,module.c,RM_ListPush,,false,4430,4450,RM_ListPush,,,263,"int RM_ListPush (RedisModuleKey*,int,robj*)"
175994,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {
    if (!key) {
        errno = EINVAL;
        return NULL;
    } else if (key->value == NULL || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return NULL;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return NULL;
    }
    if (key->iter) moduleFreeKeyIterator(key);
    robj *ele = listTypePop(key->value,
        (where == REDISMODULE_LIST_HEAD) ? LIST_HEAD : LIST_TAIL);
    robj *decoded = getDecodedObject(ele);
    decrRefCount(ele);
    if (!moduleDelKeyIfEmpty(key))
        listTypeTryConversion(key->value, LIST_CONV_SHRINKING, moduleFreeListIterator, key);
    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);
    return decoded;
}",1,17,module.c,RM_ListPop,,false,4464,4484,RM_ListPop,,,264,"robj RM_ListPop (RedisModuleKey*,int)"
176107,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_ListGet(RedisModuleKey *key, long index) {
    if (moduleListIteratorSeek(key, index, REDISMODULE_READ)) {
        robj *elem = listTypeGet(&key->u.list.entry);
        robj *decoded = getDecodedObject(elem);
        decrRefCount(elem);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, decoded);
        return decoded;
    } else {
        return NULL;
    }
}",1,17,module.c,RM_ListGet,,false,4503,4513,RM_ListGet,,,265,"robj RM_ListGet (RedisModuleKey*,long)"
176156,METHOD,module.c:<global>,TYPE_DECL,"int RM_ListSet(RedisModuleKey *key, long index, RedisModuleString *value) {
    if (!value) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    if (!key->value || key->value->type != OBJ_LIST) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    }
    listTypeTryConversionAppend(key->value, &value, 0, 0, moduleFreeListIterator, key);
    if (moduleListIteratorSeek(key, index, REDISMODULE_WRITE)) {
        listTypeReplace(&key->u.list.entry, value);
        /* A note in quicklist.c forbids use of iterator after insert, so
         * probably also after replace. */
        moduleFreeKeyIterator(key);
        return REDISMODULE_OK;
    } else {
        return REDISMODULE_ERR;
    }
}",1,48,module.c,RM_ListSet,,false,4530,4549,RM_ListSet,,,266,"int RM_ListSet (RedisModuleKey*,long,robj*)"
176239,METHOD,module.c:<global>,TYPE_DECL,"int RM_ListInsert(RedisModuleKey *key, long index, RedisModuleString *value) {
    if (!value) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key != NULL && key->value == NULL &&
               (index == 0 || index == -1)) {
        /* Insert in empty key => push. */
        return RM_ListPush(key, REDISMODULE_LIST_TAIL, value);
    } else if (key != NULL && key->value != NULL &&
               key->value->type == OBJ_LIST &&
               (index == (long)listTypeLength(key->value) || index == -1)) {
        /* Insert after the last element => push tail. */
        return RM_ListPush(key, REDISMODULE_LIST_TAIL, value);
    } else if (key != NULL && key->value != NULL &&
               key->value->type == OBJ_LIST &&
               (index == 0 || index == -(long)listTypeLength(key->value) - 1)) {
        /* Insert before the first element => push head. */
        return RM_ListPush(key, REDISMODULE_LIST_HEAD, value);
    }
    listTypeTryConversionAppend(ke...",1,51,module.c,RM_ListInsert,,false,4566,4595,RM_ListInsert,,,267,"int RM_ListInsert (RedisModuleKey*,long,robj*)"
176432,METHOD,module.c:<global>,TYPE_DECL,"int RM_ListDelete(RedisModuleKey *key, long index) {
    if (moduleListIteratorSeek(key, index, REDISMODULE_WRITE)) {
        listTypeDelete(key->iter, &key->u.list.entry);
        if (moduleDelKeyIfEmpty(key)) return REDISMODULE_OK;
        listTypeTryConversion(key->value, LIST_CONV_SHRINKING, moduleFreeListIterator, key);
        if (!key->iter) return REDISMODULE_OK; /* Return ASAP if iterator has been freed */
        if (listTypeNext(key->iter, &key->u.list.entry)) {
            /* After delete entry at position 'index', we need to update
             * 'key->u.list.index' according to the following cases:
             * 1) [1, 2, 3] => dir: forward, index: 0  => [2, 3] => index: still 0
             * 2) [1, 2, 3] => dir: forward, index: -3 => [2, 3] => index: -2
             * 3) [1, 2, 3] => dir: reverse, index: 2  => [1, 2] => index: 1
             * 4) [1, 2, 3] => dir: reverse, index: -1 => [1, 2] => index: still -1 */
            listTypeIterator *li = key->iter;
      ...",1,43,module.c,RM_ListDelete,,false,4608,4635,RM_ListDelete,,,268,"int RM_ListDelete (RedisModuleKey*,long)"
176567,METHOD,module.c:<global>,TYPE_DECL,"int moduleZsetAddFlagsToCoreFlags(int flags) {
    int retflags = 0;
    if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_IN_XX;
    if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_IN_NX;
    if (flags & REDISMODULE_ZADD_GT) retflags |= ZADD_IN_GT;
    if (flags & REDISMODULE_ZADD_LT) retflags |= ZADD_IN_LT;
    return retflags;
}",1,16,module.c,moduleZsetAddFlagsToCoreFlags,,false,4645,4652,moduleZsetAddFlagsToCoreFlags,,,269,int moduleZsetAddFlagsToCoreFlags (int)
176642,METHOD,module.c:<global>,TYPE_DECL,"int moduleZsetAddFlagsFromCoreFlags(int flags) {
    int retflags = 0;
    if (flags & ZADD_OUT_ADDED) retflags |= REDISMODULE_ZADD_ADDED;
    if (flags & ZADD_OUT_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;
    if (flags & ZADD_OUT_NOP) retflags |= REDISMODULE_ZADD_NOP;
    return retflags;
}",1,16,module.c,moduleZsetAddFlagsFromCoreFlags,,false,4655,4661,moduleZsetAddFlagsFromCoreFlags,,,270,int moduleZsetAddFlagsFromCoreFlags (int)
176701,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {
    int in_flags = 0, out_flags = 0;
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
    if (flagsptr) in_flags = moduleZsetAddFlagsToCoreFlags(*flagsptr);
    if (zsetAdd(key->value,score,ele->ptr,in_flags,&out_flags,NULL) == 0) {
        if (flagsptr) *flagsptr = 0;
        moduleDelKeyIfEmpty(key);
        return REDISMODULE_ERR;
    }
    if (flagsptr) *flagsptr = moduleZsetAddFlagsFromCoreFlags(out_flags);
    return REDISMODULE_OK;
}",1,50,module.c,RM_ZsetAdd,,false,4695,4708,RM_ZsetAdd,,,271,"int RM_ZsetAdd (RedisModuleKey*,double,robj*,int*)"
176813,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {
    int in_flags = 0, out_flags = 0;
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);
    if (flagsptr) in_flags = moduleZsetAddFlagsToCoreFlags(*flagsptr);
    in_flags |= ZADD_IN_INCR;
    if (zsetAdd(key->value,score,ele->ptr,in_flags,&out_flags,newscore) == 0) {
        if (flagsptr) *flagsptr = 0;
        moduleDelKeyIfEmpty(key);
        return REDISMODULE_ERR;
    }
    if (flagsptr) *flagsptr = moduleZsetAddFlagsFromCoreFlags(out_flags);
    return REDISMODULE_OK;
}",1,53,module.c,RM_ZsetIncrby,,false,4723,4737,RM_ZsetIncrby,,,272,"int RM_ZsetIncrby (RedisModuleKey*,double,robj*,int*,double*)"
176933,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {
    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;
    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (key->value != NULL && zsetDel(key->value,ele->ptr)) {
        if (deleted) *deleted = 1;
        moduleDelKeyIfEmpty(key);
    } else {
        if (deleted) *deleted = 0;
    }
    return REDISMODULE_OK;
}",1,36,module.c,RM_ZsetRem,,false,4757,4767,RM_ZsetRem,,,273,"int RM_ZsetRem (RedisModuleKey*,robj*,int*)"
177012,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {
    if (key->value == NULL) return REDISMODULE_ERR;
    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;
    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;
    return REDISMODULE_OK;
}",1,38,module.c,RM_ZsetScore,,false,4777,4782,RM_ZsetScore,,,274,"int RM_ZsetScore (RedisModuleKey*,robj*,double*)"
177068,METHOD,module.c:<global>,TYPE_DECL,"void zsetKeyReset(RedisModuleKey *key) {
    key->u.zset.type = REDISMODULE_ZSET_RANGE_NONE;
    key->u.zset.current = NULL;
    key->u.zset.er = 1;
}",1,23,module.c,zsetKeyReset,,false,4788,4792,zsetKeyReset,,,275,void zsetKeyReset (RedisModuleKey*)
177102,METHOD,module.c:<global>,TYPE_DECL,"void RM_ZsetRangeStop(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return;
    /* Free resources if needed. */
    if (key->u.zset.type == REDISMODULE_ZSET_RANGE_LEX)
        zslFreeLexRange(&key->u.zset.lrs);
    /* Setup sensible values so that misused iteration API calls when an
     * iterator is not active will result into something more sensible
     * than crashing. */
    zsetKeyReset(key);
}",1,43,module.c,RM_ZsetRangeStop,,false,4795,4804,RM_ZsetRangeStop,,,276,void RM_ZsetRangeStop (RedisModuleKey*)
177148,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetRangeEndReached(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 1;
    return key->u.zset.er;
}",1,43,module.c,RM_ZsetRangeEndReached,,false,4807,4810,RM_ZsetRangeEndReached,,,277,int RM_ZsetRangeEndReached (RedisModuleKey*)
177179,METHOD,module.c:<global>,TYPE_DECL,"int zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {
    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;

    RM_ZsetRangeStop(key);
    key->u.zset.type = REDISMODULE_ZSET_RANGE_SCORE;
    key->u.zset.er = 0;

    /* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */
    zrangespec *zrs = &key->u.zset.rs;
    zrs->min = min;
    zrs->max = max;
    zrs->minex = minex;
    zrs->maxex = maxex;

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        key->u.zset.current = first ? zzlFirstInRange(key->value->ptr,zrs) :
                                      zzlLastInRange(key->value->ptr,zrs);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = key->value->ptr;
        zskiplist *zsl = zs->zsl;
        key->u.zset.current = first ? zslFirstInRange(zsl,zrs) :
                                      zslLastI...",1,43,module.c,zsetInitScoreRange,,false,4818,4846,zsetInitScoreRange,,,278,"int zsetInitScoreRange (RedisModuleKey*,double,double,int,int,int)"
177374,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
    return zsetInitScoreRange(key,min,max,minex,maxex,1);
}",1,1,module.c,RM_ZsetFirstInScoreRange,,false,4863,4865,RM_ZsetFirstInScoreRange,,,279,"int RM_ZsetFirstInScoreRange (RedisModuleKey*,double,double,int,int)"
177391,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {
    return zsetInitScoreRange(key,min,max,minex,maxex,0);
}",1,1,module.c,RM_ZsetLastInScoreRange,,false,4869,4871,RM_ZsetLastInScoreRange,,,280,"int RM_ZsetLastInScoreRange (RedisModuleKey*,double,double,int,int)"
177408,METHOD,module.c:<global>,TYPE_DECL,"int zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {
    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;

    RM_ZsetRangeStop(key);
    key->u.zset.er = 0;

    /* Setup the range structure used by the sorted set core implementation
     * in order to seek at the specified element. */
    zlexrangespec *zlrs = &key->u.zset.lrs;
    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;

    /* Set the range type to lex only after successfully parsing the range,
     * otherwise we don't want the zlexrangespec to be freed. */
    key->u.zset.type = REDISMODULE_ZSET_RANGE_LEX;

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        key->u.zset.current = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :
                                      zzlLastInLexRange(key->value->ptr,zlrs);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = key->value->ptr;
     ...",1,42,module.c,zsetInitLexRange,,false,4882,4911,zsetInitLexRange,,,281,"int zsetInitLexRange (RedisModuleKey*,robj*,robj*,int)"
177596,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
    return zsetInitLexRange(key,min,max,1);
}",1,48,module.c,RM_ZsetFirstInLexRange,,false,4925,4927,RM_ZsetFirstInLexRange,,,282,"int RM_ZsetFirstInLexRange (RedisModuleKey*,robj*,robj*)"
177609,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {
    return zsetInitLexRange(key,min,max,0);
}",1,47,module.c,RM_ZsetLastInLexRange,,false,4931,4933,RM_ZsetLastInLexRange,,,283,"int RM_ZsetLastInLexRange (RedisModuleKey*,robj*,robj*)"
177622,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {
    RedisModuleString *str;

    if (!key->value || key->value->type != OBJ_ZSET) return NULL;
    if (key->u.zset.current == NULL) return NULL;
    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr, *sptr;
        eptr = key->u.zset.current;
        sds ele = lpGetObject(eptr);
        if (score) {
            sptr = lpNext(key->value->ptr,eptr);
            *score = zzlGetScore(sptr);
        }
        str = createObject(OBJ_STRING,ele);
    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {
        zskiplistNode *ln = key->u.zset.current;
        if (score) *score = ln->score;
        str = createStringObject(ln->ele,sdslen(ln->ele));
    } else {
        serverPanic(""Unsupported zset encoding"");
    }
    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);
    return str;
}",1,17,module.c,RM_ZsetRangeCurrentElement,,false,4938,4961,RM_ZsetRangeCurrentElement,,,284,"robj RM_ZsetRangeCurrentElement (RedisModuleKey*,double*)"
177773,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetRangeNext(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 0;
    if (!key->u.zset.type || !key->u.zset.current) return 0; /* No active iterator. */

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = key->value->ptr;
        unsigned char *eptr = key->u.zset.current;
        unsigned char *next;
        next = lpNext(zl,eptr); /* Skip element. */
        if (next) next = lpNext(zl,next); /* Skip score. */
        if (next == NULL) {
            key->u.zset.er = 1;
            return 0;
        } else {
            /* Are we still within the range? */
            if (key->u.zset.type == REDISMODULE_ZSET_RANGE_SCORE) {
                /* Fetch the next element score for the
                 * range check. */
                unsigned char *saved_next = next;
                next = lpNext(zl,next); /* Skip next element. */
                double score = zzlGetScore(next); /* Obtain the next score. */
       ...",1,43,module.c,RM_ZsetRangeNext,,false,4966,5025,RM_ZsetRangeNext,,,285,int RM_ZsetRangeNext (RedisModuleKey*)
178133,METHOD,module.c:<global>,TYPE_DECL,"int RM_ZsetRangePrev(RedisModuleKey *key) {
    if (!key->value || key->value->type != OBJ_ZSET) return 0;
    if (!key->u.zset.type || !key->u.zset.current) return 0; /* No active iterator. */

    if (key->value->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = key->value->ptr;
        unsigned char *eptr = key->u.zset.current;
        unsigned char *prev;
        prev = lpPrev(zl,eptr); /* Go back to previous score. */
        if (prev) prev = lpPrev(zl,prev); /* Back to previous ele. */
        if (prev == NULL) {
            key->u.zset.er = 1;
            return 0;
        } else {
            /* Are we still within the range? */
            if (key->u.zset.type == REDISMODULE_ZSET_RANGE_SCORE) {
                /* Fetch the previous element score for the
                 * range check. */
                unsigned char *saved_prev = prev;
                prev = lpNext(zl,prev); /* Skip element to get the score.*/
                double score = zzlGetScore(prev)...",1,43,module.c,RM_ZsetRangePrev,,false,5030,5089,RM_ZsetRangePrev,,,286,int RM_ZsetRangePrev (RedisModuleKey*)
178489,METHOD,module.c:<global>,TYPE_DECL,"int RM_HashSet(RedisModuleKey *key, int flags, ...) {
    va_list ap;
    if (!key || (flags & ~(REDISMODULE_HASH_NX |
                           REDISMODULE_HASH_XX |
                           REDISMODULE_HASH_CFIELDS |
                           REDISMODULE_HASH_COUNT_ALL))) {
        errno = EINVAL;
        return 0;
    } else if (key->value && key->value->type != OBJ_HASH) {
        errno = ENOTSUP;
        return 0;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return 0;
    }
    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);

    int count = 0;
    va_start(ap, flags);
    while(1) {
        RedisModuleString *field, *value;
        /* Get the field and value objects. */
        if (flags & REDISMODULE_HASH_CFIELDS) {
            char *cfield = va_arg(ap,char*);
            if (cfield == NULL) break;
            field = createRawStringObject(cfield,strlen(cfield));
        } else {
            field = va_arg(a...",1,27,module.c,RM_HashSet,,false,5164,5237,RM_HashSet,,,287,"int RM_HashSet (RedisModuleKey*,int...)"
178811,METHOD,module.c:<global>,TYPE_DECL,"int RM_HashGet(RedisModuleKey *key, int flags, ...) {
    va_list ap;
    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;

    va_start(ap, flags);
    while(1) {
        RedisModuleString *field, **valueptr;
        int *existsptr;
        /* Get the field object and the value pointer to pointer. */
        if (flags & REDISMODULE_HASH_CFIELDS) {
            char *cfield = va_arg(ap,char*);
            if (cfield == NULL) break;
            field = createRawStringObject(cfield,strlen(cfield));
        } else {
            field = va_arg(ap,RedisModuleString*);
            if (field == NULL) break;
        }

        /* Query the hash for existence or value object. */
        if (flags & REDISMODULE_HASH_EXISTS) {
            existsptr = va_arg(ap,int*);
            if (key->value)
                *existsptr = hashTypeExists(key->value,field->ptr);
            else
                *existsptr = 0;
        } else {
            valueptr = va_arg(ap,RedisModuleSt...",1,42,module.c,RM_HashGet,,false,5280,5326,RM_HashGet,,,288,"int RM_HashGet (RedisModuleKey*,int...)"
178979,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamAdd(RedisModuleKey *key, int flags, RedisModuleStreamID *id, RedisModuleString **argv, long numfields) {
    /* Validate args */
    if (!key || (numfields != 0 && !argv) || /* invalid key or argv */
        (flags & ~(REDISMODULE_STREAM_ADD_AUTOID)) || /* invalid flags */
        (!(flags & REDISMODULE_STREAM_ADD_AUTOID) && !id)) { /* id required */
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (key->value && key->value->type != OBJ_STREAM) {
        errno = ENOTSUP; /* wrong type */
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF; /* key not open for writing */
        return REDISMODULE_ERR;
    } else if (!(flags & REDISMODULE_STREAM_ADD_AUTOID) &&
               id->ms == 0 && id->seq == 0) {
        errno = EDOM; /* ID out of range */
        return REDISMODULE_ERR;
    }

    /* Create key if necessary */
    int created = 0;
    if (key->value == NULL) {
        moduleCreateEmptyKey...",1,74,module.c,RM_StreamAdd,,false,5369,5428,RM_StreamAdd,,,289,"int RM_StreamAdd (RedisModuleKey*,int,RedisModuleStreamID*,robj**,long)"
179248,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamDelete(RedisModuleKey *key, RedisModuleStreamID *id) {
    if (!key || !id) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP; /* wrong type */
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE) ||
               key->iter != NULL) {
        errno = EBADF; /* key not opened for writing or iterator started */
        return REDISMODULE_ERR;
    }
    stream *s = key->value->ptr;
    streamID streamid = {id->ms, id->seq};
    if (streamDeleteItem(s, &streamid)) {
        return REDISMODULE_OK;
    } else {
        errno = ENOENT; /* no entry with this id */
        return REDISMODULE_ERR;
    }
}",1,15,module.c,RM_StreamDelete,,false,5448,5468,RM_StreamDelete,,,290,"int RM_StreamDelete (RedisModuleKey*,RedisModuleStreamID*)"
179357,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamIteratorStart(RedisModuleKey *key, int flags, RedisModuleStreamID *start, RedisModuleStreamID *end) {
    /* check args */
    if (!key ||
        (flags & ~(REDISMODULE_STREAM_ITERATOR_EXCLUSIVE |
                   REDISMODULE_STREAM_ITERATOR_REVERSE))) {
        errno = EINVAL; /* key missing or invalid flags */
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR; /* not a stream */
    } else if (key->iter) {
        errno = EBADF; /* iterator already started */
        return REDISMODULE_ERR;
    }

    /* define range for streamIteratorStart() */
    streamID lower, upper;
    if (start) lower = (streamID){start->ms, start->seq};
    if (end)   upper = (streamID){end->ms,   end->seq};
    if (flags & REDISMODULE_STREAM_ITERATOR_EXCLUSIVE) {
        if ((start && streamIncrID(&lower) != C_OK) ||
            (end   && streamDecrID(&upper) != C_OK)) {
            errno...",1,19,module.c,RM_StreamIteratorStart,,false,5519,5556,RM_StreamIteratorStart,,,291,"int RM_StreamIteratorStart (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleStreamID*)"
179576,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamIteratorStop(RedisModuleKey *key) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }
    streamIteratorStop(key->iter);
    zfree(key->iter);
    key->iter = NULL;
    return REDISMODULE_OK;
}",1,15,module.c,RM_StreamIteratorStop,,false,5570,5585,RM_StreamIteratorStop,,,292,int RM_StreamIteratorStop (RedisModuleKey*)
179649,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamIteratorNextID(RedisModuleKey *key, RedisModuleStreamID *id, long *numfields) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    int64_t *num_ptr = &key->u.stream.numfieldsleft;
    streamID *streamid_ptr = &key->u.stream.currentid;
    if (streamIteratorGetID(si, streamid_ptr, num_ptr)) {
        if (id) {
            id->ms = streamid_ptr->ms;
            id->seq = streamid_ptr->seq;
        }
        if (numfields) *numfields = *num_ptr;
        return REDISMODULE_OK;
    } else {
        /* No entry found. */
        key->u.stream.currentid.ms = 0; /* for RM_StreamIteratorDelete() */
        key->u.stream.currentid.seq = 0;
        key->u.stream.numfieldsleft = 0; /* for RM_StreamIteratorNextField...",1,15,module.c,RM_StreamIteratorNextID,,false,5612,5641,RM_StreamIteratorNextID,,,293,"int RM_StreamIteratorNextID (RedisModuleKey*,RedisModuleStreamID*,long*)"
179810,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamIteratorNextField(RedisModuleKey *key, RedisModuleString **field_ptr, RedisModuleString **value_ptr) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    } else if (key->u.stream.numfieldsleft <= 0) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    unsigned char *field, *value;
    int64_t field_len, value_len;
    streamIteratorGetField(si, &field, &value, &field_len, &value_len);
    if (field_ptr) {
        *field_ptr = createRawStringObject((char *)field, field_len);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, *field_ptr);
    }
    if (value_ptr) {
        *value_ptr = createRawStringObject((char *)value, value_len);
        autoMemoryAdd(key->ctx, REDISMODULE_AM_STRING, *val...",1,52,module.c,RM_StreamIteratorNextField,,false,5668,5696,RM_StreamIteratorNextField,,,294,"int RM_StreamIteratorNextField (RedisModuleKey*,robj**,robj**)"
179960,METHOD,module.c:<global>,TYPE_DECL,"int RM_StreamIteratorDelete(RedisModuleKey *key) {
    if (!key) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    } else if (!(key->mode & REDISMODULE_WRITE) || !key->iter) {
        errno = EBADF;
        return REDISMODULE_ERR;
    } else if (key->u.stream.currentid.ms == 0 &&
               key->u.stream.currentid.seq == 0) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }
    streamIterator *si = key->iter;
    streamIteratorRemoveEntry(si, &key->u.stream.currentid);
    key->u.stream.currentid.ms = 0; /* Make sure repeated Delete() fails */
    key->u.stream.currentid.seq = 0;
    key->u.stream.numfieldsleft = 0; /* Make sure NextField() fails */
    return REDISMODULE_OK;
}",1,15,module.c,RM_StreamIteratorDelete,,false,5711,5732,RM_StreamIteratorDelete,,,295,int RM_StreamIteratorDelete (RedisModuleKey*)
180112,METHOD,module.c:<global>,TYPE_DECL,"long long RM_StreamTrimByLength(RedisModuleKey *key, int flags, long long length) {
    if (!key || (flags & ~(REDISMODULE_STREAM_TRIM_APPROX)) || length < 0) {
        errno = EINVAL;
        return -1;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return -1;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return -1;
    }
    int approx = flags & REDISMODULE_STREAM_TRIM_APPROX ? 1 : 0;
    return streamTrimByLength((stream *)key->value->ptr, length, approx);
}",1,27,module.c,RM_StreamTrimByLength,,false,5749,5762,RM_StreamTrimByLength,,,296,"long long RM_StreamTrimByLength (RedisModuleKey*,int,long long)"
180210,METHOD,module.c:<global>,TYPE_DECL,"long long RM_StreamTrimByID(RedisModuleKey *key, int flags, RedisModuleStreamID *id) {
    if (!key || (flags & ~(REDISMODULE_STREAM_TRIM_APPROX)) || !id) {
        errno = EINVAL;
        return -1;
    } else if (!key->value || key->value->type != OBJ_STREAM) {
        errno = ENOTSUP;
        return -1;
    } else if (!(key->mode & REDISMODULE_WRITE)) {
        errno = EBADF;
        return -1;
    }
    int approx = flags & REDISMODULE_STREAM_TRIM_APPROX ? 1 : 0;
    streamID minid = (streamID){id->ms, id->seq};
    return streamTrimByID((stream *)key->value->ptr, minid, approx);
}",1,27,module.c,RM_StreamTrimByID,,false,5779,5793,RM_StreamTrimByID,,,297,"long long RM_StreamTrimByID (RedisModuleKey*,int,RedisModuleStreamID*)"
180319,METHOD,module.c:<global>,TYPE_DECL,void moduleParseCallReply_Int(RedisModuleCallReply *reply);,6,58,module.c,moduleParseCallReply_Int,,false,5802,5802,moduleParseCallReply_Int,,,298,void moduleParseCallReply_Int (RedisModuleCallReply*)
180324,METHOD,module.c:<global>,TYPE_DECL,void moduleParseCallReply_BulkString(RedisModuleCallReply *reply);,6,65,module.c,moduleParseCallReply_BulkString,,false,5803,5803,moduleParseCallReply_BulkString,,,299,void moduleParseCallReply_BulkString (RedisModuleCallReply*)
180329,METHOD,module.c:<global>,TYPE_DECL,void moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);,6,67,module.c,moduleParseCallReply_SimpleString,,false,5804,5804,moduleParseCallReply_SimpleString,,,300,void moduleParseCallReply_SimpleString (RedisModuleCallReply*)
180334,METHOD,module.c:<global>,TYPE_DECL,void moduleParseCallReply_Array(RedisModuleCallReply *reply);,6,60,module.c,moduleParseCallReply_Array,,false,5805,5805,moduleParseCallReply_Array,,,301,void moduleParseCallReply_Array (RedisModuleCallReply*)
180339,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeCallReply(RedisModuleCallReply *reply) {
    /* This is a wrapper for the recursive free reply function. This is needed
     * in order to have the first level function to return on nested replies,
     * but only if called by the module API. */

    RedisModuleCtx *ctx = NULL;
    if(callReplyType(reply) == REDISMODULE_REPLY_PROMISE) {
        RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
        ctx = promise->ctx;
        freeRedisModuleAsyncRMCallPromise(promise);
    } else {
        ctx = callReplyGetPrivateData(reply);
    }

    freeCallReply(reply);
    if (ctx) {
        autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);
    }
}",1,31,module.c,RM_FreeCallReply,,false,5812,5830,RM_FreeCallReply,,,302,void RM_FreeCallReply (RedisModuleCallReply*)
180385,METHOD,module.c:<global>,TYPE_DECL,"int RM_CallReplyType(RedisModuleCallReply *reply) {
    return callReplyType(reply);
}",1,1,module.c,RM_CallReplyType,,false,5848,5850,RM_CallReplyType,,,303,int RM_CallReplyType (RedisModuleCallReply*)
180393,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_CallReplyLength(RedisModuleCallReply *reply) {
    return callReplyGetLen(reply);
}",1,1,module.c,RM_CallReplyLength,,false,5853,5855,RM_CallReplyLength,,,304,size_t RM_CallReplyLength (RedisModuleCallReply*)
180401,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {
    return callReplyGetArrayElement(reply, idx);
}",1,1,module.c,RM_CallReplyArrayElement,,false,5859,5861,RM_CallReplyArrayElement,,,305,"RedisModuleCallReply RM_CallReplyArrayElement (RedisModuleCallReply*,size_t)"
180411,METHOD,module.c:<global>,TYPE_DECL,"long long RM_CallReplyInteger(RedisModuleCallReply *reply) {
    return callReplyGetLongLong(reply);
}",1,1,module.c,RM_CallReplyInteger,,false,5864,5866,RM_CallReplyInteger,,,306,long long RM_CallReplyInteger (RedisModuleCallReply*)
180419,METHOD,module.c:<global>,TYPE_DECL,"double RM_CallReplyDouble(RedisModuleCallReply *reply) {
    return callReplyGetDouble(reply);
}",1,1,module.c,RM_CallReplyDouble,,false,5869,5871,RM_CallReplyDouble,,,307,double RM_CallReplyDouble (RedisModuleCallReply*)
180427,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_CallReplyBigNumber(RedisModuleCallReply *reply, size_t *len) {
    return callReplyGetBigNumber(reply, len);
}",1,1,module.c,RM_CallReplyBigNumber,,false,5874,5876,RM_CallReplyBigNumber,,,308,"const char* RM_CallReplyBigNumber (RedisModuleCallReply*,size_t*)"
180437,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_CallReplyVerbatim(RedisModuleCallReply *reply, size_t *len, const char **format) {
    return callReplyGetVerbatim(reply, len, format);
}",1,1,module.c,RM_CallReplyVerbatim,,false,5880,5882,RM_CallReplyVerbatim,,,309,"const char* RM_CallReplyVerbatim (RedisModuleCallReply*,size_t*,char**)"
180449,METHOD,module.c:<global>,TYPE_DECL,"int RM_CallReplyBool(RedisModuleCallReply *reply) {
    return callReplyGetBool(reply);
}",1,1,module.c,RM_CallReplyBool,,false,5885,5887,RM_CallReplyBool,,,310,int RM_CallReplyBool (RedisModuleCallReply*)
180457,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCallReply *RM_CallReplySetElement(RedisModuleCallReply *reply, size_t idx) {
    return callReplyGetSetElement(reply, idx);
}",1,1,module.c,RM_CallReplySetElement,,false,5891,5893,RM_CallReplySetElement,,,311,"RedisModuleCallReply RM_CallReplySetElement (RedisModuleCallReply*,size_t)"
180467,METHOD,module.c:<global>,TYPE_DECL,"int RM_CallReplyMapElement(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) {
    if (callReplyGetMapElement(reply, idx, key, val) == C_OK){
        return REDISMODULE_OK;
    }
    return REDISMODULE_ERR;
}",1,56,module.c,RM_CallReplyMapElement,,false,5903,5908,RM_CallReplyMapElement,,,312,"int RM_CallReplyMapElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)"
180494,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCallReply *RM_CallReplyAttribute(RedisModuleCallReply *reply) {
    return callReplyGetAttribute(reply);
}",1,1,module.c,RM_CallReplyAttribute,,false,5911,5913,RM_CallReplyAttribute,,,313,RedisModuleCallReply RM_CallReplyAttribute (RedisModuleCallReply*)
180502,METHOD,module.c:<global>,TYPE_DECL,"int RM_CallReplyAttributeElement(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) {
    if (callReplyGetAttributeElement(reply, idx, key, val) == C_OK){
        return REDISMODULE_OK;
    }
    return REDISMODULE_ERR;
}",1,62,module.c,RM_CallReplyAttributeElement,,false,5923,5928,RM_CallReplyAttributeElement,,,314,"int RM_CallReplyAttributeElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)"
180529,METHOD,module.c:<global>,TYPE_DECL,"void RM_CallReplyPromiseSetUnblockHandler(RedisModuleCallReply *reply, RedisModuleOnUnblocked on_unblock, void *private_data) {
    RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
    promise->on_unblocked = on_unblock;
    promise->private_data = private_data;
}",1,1,module.c,RM_CallReplyPromiseSetUnblockHandler,,false,5932,5936,RM_CallReplyPromiseSetUnblockHandler,,,315,"void RM_CallReplyPromiseSetUnblockHandler (RedisModuleCallReply*,RedisModuleOnUnblocked,void*)"
180551,METHOD,module.c:<global>,TYPE_DECL,"int RM_CallReplyPromiseAbort(RedisModuleCallReply *reply, void **private_data) {
    RedisModuleAsyncRMCallPromise *promise = callReplyGetPrivateData(reply);
    if (!promise->c) return REDISMODULE_ERR; /* Promise can not be aborted, either already aborted or already finished. */
    if (!(promise->c->flags & CLIENT_BLOCKED)) return REDISMODULE_ERR; /* Client is not blocked anymore, can not abort it. */

    /* Client is still blocked, remove it from any blocking state and release it. */
    if (private_data) *private_data = promise->private_data;
    promise->private_data = NULL;
    promise->on_unblocked = NULL;
    unblockClient(promise->c, 0);
    moduleReleaseTempClient(promise->c);
    return REDISMODULE_OK;
}",1,28,module.c,RM_CallReplyPromiseAbort,,false,5949,5961,RM_CallReplyPromiseAbort,,,316,"int RM_CallReplyPromiseAbort (RedisModuleCallReply*,void**)"
180622,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {
    size_t private_len;
    if (!len) len = &private_len;
    return callReplyGetString(reply, len);
}",1,1,module.c,RM_CallReplyStringPtr,,false,5964,5968,RM_CallReplyStringPtr,,,317,"const char* RM_CallReplyStringPtr (RedisModuleCallReply*,size_t*)"
180641,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {
    RedisModuleCtx* ctx = callReplyGetPrivateData(reply);
    size_t len;
    const char *str;
    switch(callReplyType(reply)) {
        case REDISMODULE_REPLY_STRING:
        case REDISMODULE_REPLY_ERROR:
            str = callReplyGetString(reply, &len);
            return RM_CreateString(ctx, str, len);
        case REDISMODULE_REPLY_INTEGER: {
            char buf[64];
            int len = ll2string(buf,sizeof(buf),callReplyGetLongLong(reply));
            return RM_CreateString(ctx ,buf,len);
            }
        default:
            return NULL;
    }
}",1,17,module.c,RM_CreateStringFromCallReply,,false,5972,5989,RM_CreateStringFromCallReply,,,318,robj RM_CreateStringFromCallReply (RedisModuleCallReply*)
180699,METHOD,module.c:<global>,TYPE_DECL,"void RM_SetContextUser(RedisModuleCtx *ctx, const RedisModuleUser *user) {
    ctx->user = user;
}",1,1,module.c,RM_SetContextUser,,false,5992,5994,RM_SetContextUser,,,319,"void RM_SetContextUser (RedisModuleCtx*,RedisModuleUser*)"
180710,METHOD,module.c:<global>,TYPE_DECL,"robj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {
    int argc = 0, argv_size, j;
    robj **argv = NULL;

    /* As a first guess to avoid useless reallocations, size argv to
     * hold one argument for each char specifier in 'fmt'. */
    argv_size = strlen(fmt)+1; /* +1 because of the command name. */
    argv = zrealloc(argv,sizeof(robj*)*argv_size);

    /* Build the arguments vector based on the format specifier. */
    argv[0] = createStringObject(cmdname,strlen(cmdname));
    argc++;

    /* Create the client and dispatch the command. */
    const char *p = fmt;
    while(*p) {
        if (*p == 'c') {
            char *cstr = va_arg(ap,char*);
            argv[argc++] = createStringObject(cstr,strlen(cstr));
        } else if (*p == 's') {
            robj *obj = va_arg(ap,void*);
            if (obj->refcount == OBJ_STATIC_REFCOUNT)
                obj = createStringObject(obj->ptr,sdslen(obj->ptr));
        ...",1,33,module.c,moduleCreateArgvFromUserFormat,,false,6014,6100,moduleCreateArgvFromUserFormat,,,320,"robj moduleCreateArgvFromUserFormat (char*,char*,int*,int*,va_list)"
181178,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {
    client *c = NULL;
    robj **argv = NULL;
    int argc = 0, flags = 0;
    va_list ap;
    RedisModuleCallReply *reply = NULL;
    int replicate = 0; /* Replicate this command? */
    int error_as_call_replies = 0; /* return errors as RedisModuleCallReply object */
    uint64_t cmd_flags;

    /* Handle arguments. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    replicate = flags & REDISMODULE_ARGV_REPLICATE;
    error_as_call_replies = flags & REDISMODULE_ARGV_CALL_REPLIES_AS_ERRORS;
    va_end(ap);

    c = moduleAllocTempClient();

    if (!(flags & REDISMODULE_ARGV_ALLOW_BLOCK)) {
        /* We do not want to allow block, the module do not expect it */
        c->flags |= CLIENT_DENY_BLOCKING;
    }
    c->db = ctx->client->db;
    c->argv = argv;
    /* We have to assign argv_len, which is equal to argc in that case (RM_Call)
 ...",1,24,module.c,RM_Call,,false,6206,6509,RM_Call,,,321,"RedisModuleCallReply RM_Call (RedisModuleCtx*,char*,char*...)"
182341,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {
    return callReplyGetProto(reply, len);
}",1,1,module.c,RM_CallReplyProto,,false,6513,6515,RM_CallReplyProto,,,322,"const char* RM_CallReplyProto (RedisModuleCallReply*,size_t*)"
182355,METHOD,module.c:<global>,TYPE_DECL,"uint64_t moduleTypeEncodeId(const char *name, int encver) {
    /* We use 64 symbols so that we can map each character into 6 bits
     * of the final output. */
    const char *cset = ModuleTypeNameCharSet;
    if (strlen(name) != 9) return 0;
    if (encver < 0 || encver > 1023) return 0;

    uint64_t id = 0;
    for (int j = 0; j < 9; j++) {
        char *p = strchr(cset,name[j]);
        if (!p) return 0;
        unsigned long pos = p-cset;
        id = (id << 6) | pos;
    }
    id = (id << 10) | encver;
    return id;
}",1,1,module.c,moduleTypeEncodeId,,false,6555,6571,moduleTypeEncodeId,,,325,"uint64_t moduleTypeEncodeId (char*,int)"
182436,METHOD,module.c:<global>,TYPE_DECL,"moduleType *moduleTypeLookupModuleByNameInternal(const char *name, int ignore_case) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *mt = ln->value;
            if ((!ignore_case && memcmp(name,mt->name,sizeof(mt->name)) == 0)
                || (ignore_case && !strcasecmp(name, mt->name)))
            {
                dictReleaseIterator(di);
                return mt;
            }
        }
    }
    dictReleaseIterator(di);
    return NULL;
}",1,1,module.c,moduleTypeLookupModuleByNameInternal,,false,6576,6598,moduleTypeLookupModuleByNameInternal,,,326,"moduleType moduleTypeLookupModuleByNameInternal (char*,int)"
182515,METHOD,module.c:<global>,TYPE_DECL,"moduleType *moduleTypeLookupModuleByName(const char *name) {
    return moduleTypeLookupModuleByNameInternal(name, 0);
}",1,1,module.c,moduleTypeLookupModuleByName,,false,6600,6602,moduleTypeLookupModuleByName,,,327,moduleType moduleTypeLookupModuleByName (char*)
182524,METHOD,module.c:<global>,TYPE_DECL,"moduleType *moduleTypeLookupModuleByNameIgnoreCase(const char *name) {
    return moduleTypeLookupModuleByNameInternal(name, 1);
}",1,1,module.c,moduleTypeLookupModuleByNameIgnoreCase,,false,6605,6607,moduleTypeLookupModuleByNameIgnoreCase,,,328,moduleType moduleTypeLookupModuleByNameIgnoreCase (char*)
182533,METHOD,module.c:<global>,TYPE_DECL,"moduleType *moduleTypeLookupModuleByID(uint64_t id) {
    static struct {
        uint64_t id;
        moduleType *mt;
    } cache[MODULE_LOOKUP_CACHE_SIZE];

    /* Search in cache to start. */
    int j;
    for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)
        if (cache[j].id == id) return cache[j].mt;

    /* Slow module by module lookup. */
    moduleType *mt = NULL;
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL && mt == NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *this_mt = ln->value;
            /* Compare only the 54 bit module identifier and not the
             * encoding version. */
            if (this_mt->id >> 10 == id >> 10) {
                mt = this_mt;
                break;
            }
        }
    }
    dictReleaseIt...",1,12,module.c,moduleTypeLookupModuleByID,,false,6614,6654,moduleTypeLookupModuleByID,,,329,moduleType moduleTypeLookupModuleByID (uint64_t)
182665,METHOD,module.c:<global>,TYPE_DECL,"void moduleTypeNameByID(char *name, uint64_t moduleid) {
    const char *cset = ModuleTypeNameCharSet;

    name[9] = '\0';
    char *p = name+8;
    moduleid >>= 10;
    for (int j = 0; j < 9; j++) {
        *p-- = cset[moduleid & 63];
        moduleid >>= 6;
    }
}",1,1,module.c,moduleTypeNameByID,,false,6660,6670,moduleTypeNameByID,,,330,"void moduleTypeNameByID (char*,uint64_t)"
182713,METHOD,module.c:<global>,TYPE_DECL,"const char *moduleTypeModuleName(moduleType *mt) {
    if (!mt || !mt->module) return NULL;
    return mt->module->name;
}",1,1,module.c,moduleTypeModuleName,,false,6673,6676,moduleTypeModuleName,,,331,const char* moduleTypeModuleName (moduleType*)
182735,METHOD,module.c:<global>,TYPE_DECL,"const char *moduleNameFromCommand(struct redisCommand *cmd) {
    serverAssert(cmd->proc == RedisModuleCommandDispatcher);

    RedisModuleCommand *cp = cmd->module_cmd;
    return cp->module->name;
}",1,4,module.c,moduleNameFromCommand,,false,6679,6684,moduleNameFromCommand,,,332,const char* moduleNameFromCommand (redisCommand*)
182770,METHOD,module.c:<global>,TYPE_DECL,"robj *moduleTypeDupOrReply(client *c, robj *fromkey, robj *tokey, int todb, robj *value) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;
    if (!mt->copy && !mt->copy2) {
        addReplyError(c, ""not supported for this module key"");
        return NULL;
    }
    void *newval = NULL;
    if (mt->copy2 != NULL) {
        RedisModuleKeyOptCtx ctx = {fromkey, tokey, c->db->id, todb};
        newval = mt->copy2(&ctx, mv->value);
    } else {
        newval = mt->copy(fromkey, tokey, mv->value);
    }
     
    if (!newval) {
        addReplyError(c, ""module key failed to copy"");
        return NULL;
    }
    return createModuleObject(mt, newval);
}",1,1,module.c,moduleTypeDupOrReply,,false,6689,6709,moduleTypeDupOrReply,,,333,"robj moduleTypeDupOrReply (client*,robj*,robj*,int,robj*)"
182867,METHOD,module.c:<global>,TYPE_DECL,"moduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {
    if (!ctx->module->onload)
        return NULL;
    uint64_t id = moduleTypeEncodeId(name,encver);
    if (id == 0) return NULL;
    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;

    long typemethods_version = ((long*)typemethods_ptr)[0];
    if (typemethods_version == 0) return NULL;

    struct typemethods {
        uint64_t version;
        moduleTypeLoadFunc rdb_load;
        moduleTypeSaveFunc rdb_save;
        moduleTypeRewriteFunc aof_rewrite;
        moduleTypeMemUsageFunc mem_usage;
        moduleTypeDigestFunc digest;
        moduleTypeFreeFunc free;
        struct {
            moduleTypeAuxLoadFunc aux_load;
            moduleTypeAuxSaveFunc aux_save;
            int aux_save_triggers;
        } v2;
        struct {
            moduleTypeFreeEffortFunc free_effort;
            moduleTypeUnlinkFunc unlink;
            moduleTypeCopyFunc copy;
      ...",1,1,module.c,RM_CreateDataType,,false,6832,6904,RM_CreateDataType,,,334,"moduleType RM_CreateDataType (RedisModuleCtx*,char*,int,void*)"
183142,METHOD,module.c:<global>,TYPE_DECL,"int RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;
    RM_DeleteKey(key);
    robj *o = createModuleObject(mt,value);
    setKey(key->ctx->client,key->db,key->key,o,SETKEY_NO_SIGNAL);
    decrRefCount(o);
    key->value = o;
    return REDISMODULE_OK;
}",1,22,module.c,RM_ModuleTypeSetValue,,false,6910,6918,RM_ModuleTypeSetValue,,,335,"int RM_ModuleTypeSetValue (RedisModuleKey*,moduleType*,void*)"
183204,METHOD,module.c:<global>,TYPE_DECL,"moduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {
    if (key == NULL ||
        key->value == NULL ||
        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
    moduleValue *mv = key->value->ptr;
    return mv->type;
}",1,27,module.c,RM_ModuleTypeGetType,,false,6925,6931,RM_ModuleTypeGetType,,,336,moduleType RM_ModuleTypeGetType (RedisModuleKey*)
183241,METHOD,module.c:<global>,TYPE_DECL,"void *RM_ModuleTypeGetValue(RedisModuleKey *key) {
    if (key == NULL ||
        key->value == NULL ||
        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;
    moduleValue *mv = key->value->ptr;
    return mv->value;
}",1,27,module.c,RM_ModuleTypeGetValue,,false,6939,6945,RM_ModuleTypeGetValue,,,337,void* RM_ModuleTypeGetValue (RedisModuleKey*)
183278,METHOD,module.c:<global>,TYPE_DECL,"void moduleRDBLoadError(RedisModuleIO *io) {
    if (io->type->module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS) {
        io->error = 1;
        return;
    }
    serverPanic(
        ""Error loading data from RDB (short read or EOF). ""
        ""Read performed by module '%s' about type '%s' ""
        ""after reading '%llu' bytes of a value ""
        ""for key named: '%s'."",
        io->type->module->name,
        io->type->name,
        (unsigned long long)io->bytes,
        io->key? (char*)io->key->ptr: ""(null)"");
}",1,36,module.c,moduleRDBLoadError,,false,6954,6968,moduleRDBLoadError,,,338,void moduleRDBLoadError (RedisModuleIO*)
183341,METHOD,module.c:<global>,TYPE_DECL,"int moduleAllDatatypesHandleErrors(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (listLength(module->types) &&
            !(module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS))
        {
            dictReleaseIterator(di);
            return 0;
        }
    }
    dictReleaseIterator(di);
    return 1;
}",1,12,module.c,moduleAllDatatypesHandleErrors,,false,6973,6988,moduleAllDatatypesHandleErrors,,,339,int moduleAllDatatypesHandleErrors (void)
183396,METHOD,module.c:<global>,TYPE_DECL,"int moduleAllModulesHandleReplAsyncLoad(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!(module->options & REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD)) {
            dictReleaseIterator(di);
            return 0;
        }
    }
    dictReleaseIterator(di);
    return 1;
}",1,32,module.c,moduleAllModulesHandleReplAsyncLoad,,false,6993,7006,moduleAllModulesHandleReplAsyncLoad,,,340,int moduleAllModulesHandleReplAsyncLoad (void)
183440,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsIOError(RedisModuleIO *io) {
    return io->error;
}",1,1,module.c,RM_IsIOError,,false,7011,7013,RM_IsIOError,,,341,int RM_IsIOError (RedisModuleIO*)
183449,METHOD,module.c:<global>,TYPE_DECL,"static int flushRedisModuleIOBuffer(RedisModuleIO *io) {
    if (!io->pre_flush_buffer) return 0;

    /* We have data that must be flushed before saving the current data.
     * Lets flush it. */
    sds pre_flush_buffer = io->pre_flush_buffer;
    io->pre_flush_buffer = NULL;
    ssize_t retval = rdbWriteRaw(io->rio, pre_flush_buffer, sdslen(pre_flush_buffer));
    sdsfree(pre_flush_buffer);
    if (retval >= 0) io->bytes += retval;
    return retval;
}",1,1,module.c,flushRedisModuleIOBuffer,,false,7015,7026,flushRedisModuleIOBuffer,,,342,int flushRedisModuleIOBuffer (RedisModuleIO*)
183497,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveLen(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",1,37,module.c,RM_SaveUnsigned,,false,7031,7046,RM_SaveUnsigned,,,343,"void RM_SaveUnsigned (RedisModuleIO*,uint64_t)"
183565,METHOD,module.c:<global>,TYPE_DECL,"uint64_t RM_LoadUnsigned(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;
    uint64_t value;
    int retval = rdbLoadLenByRef(io->rio, NULL, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",1,18,module.c,RM_LoadUnsigned,,false,7051,7063,RM_LoadUnsigned,,,344,uint64_t RM_LoadUnsigned (RedisModuleIO*)
183618,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveSigned(RedisModuleIO *io, int64_t value) {
    union {uint64_t u; int64_t i;} conv;
    conv.i = value;
    RM_SaveUnsigned(io,conv.u);
}",1,1,module.c,RM_SaveSigned,,false,7066,7070,RM_SaveSigned,,,345,"void RM_SaveSigned (RedisModuleIO*,int64_t)"
183635,METHOD,module.c:<global>,TYPE_DECL,"int64_t RM_LoadSigned(RedisModuleIO *io) {
    union {uint64_t u; int64_t i;} conv;
    conv.u = RM_LoadUnsigned(io);
    return conv.i;
}",1,1,module.c,RM_LoadSigned,,false,7073,7077,RM_LoadSigned,,,346,int64_t RM_LoadSigned (RedisModuleIO*)
183651,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveStringObject(io->rio, s);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",1,38,module.c,RM_SaveString,,false,7085,7100,RM_SaveString,,,347,"void RM_SaveString (RedisModuleIO*,robj*)"
183719,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",1,41,module.c,RM_SaveStringBuffer,,false,7104,7119,RM_SaveStringBuffer,,,348,"void RM_SaveStringBuffer (RedisModuleIO*,char*,size_t)"
183791,METHOD,module.c:<global>,TYPE_DECL,"void *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {
    if (io->error) return NULL;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;
    void *s = rdbGenericLoadStringObject(io->rio,
              plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);
    if (s == NULL) goto loaderr;
    return s;

loaderr:
    moduleRDBLoadError(io);
    return NULL;
}",1,18,module.c,moduleLoadString,,false,7122,7134,moduleLoadString,,,349,"void* moduleLoadString (RedisModuleIO*,int,size_t*)"
183852,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_LoadString(RedisModuleIO *io) {
    return moduleLoadString(io,0,NULL);
}",1,17,module.c,RM_LoadString,,false,7145,7147,RM_LoadString,,,350,robj RM_LoadString (RedisModuleIO*)
183862,METHOD,module.c:<global>,TYPE_DECL,"char *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {
    return moduleLoadString(io,1,lenptr);
}",1,1,module.c,RM_LoadStringBuffer,,false,7156,7158,RM_LoadStringBuffer,,,351,"char* RM_LoadStringBuffer (RedisModuleIO*,size_t*)"
183873,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveDouble(RedisModuleIO *io, double value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveBinaryDoubleValue(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",1,37,module.c,RM_SaveDouble,,false,7163,7178,RM_SaveDouble,,,352,"void RM_SaveDouble (RedisModuleIO*,double)"
183941,METHOD,module.c:<global>,TYPE_DECL,"double RM_LoadDouble(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;
    double value;
    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",1,18,module.c,RM_LoadDouble,,false,7182,7194,RM_LoadDouble,,,353,double RM_LoadDouble (RedisModuleIO*)
183993,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveFloat(RedisModuleIO *io, float value) {
    if (io->error) return;
    if (flushRedisModuleIOBuffer(io) == -1) goto saveerr;
    /* Save opcode. */
    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    /* Save value. */
    retval = rdbSaveBinaryFloatValue(io->rio, value);
    if (retval == -1) goto saveerr;
    io->bytes += retval;
    return;

saveerr:
    io->error = 1;
}",1,37,module.c,RM_SaveFloat,,false,7199,7214,RM_SaveFloat,,,354,"void RM_SaveFloat (RedisModuleIO*,float)"
184061,METHOD,module.c:<global>,TYPE_DECL,"float RM_LoadFloat(RedisModuleIO *io) {
    if (io->error) return 0;
    uint64_t opcode = rdbLoadLen(io->rio,NULL);
    if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;
    float value;
    int retval = rdbLoadBinaryFloatValue(io->rio, &value);
    if (retval == -1) goto loaderr;
    return value;

loaderr:
    moduleRDBLoadError(io);
    return 0;
}",1,18,module.c,RM_LoadFloat,,false,7218,7230,RM_LoadFloat,,,355,float RM_LoadFloat (RedisModuleIO*)
184113,METHOD,module.c:<global>,TYPE_DECL,"void RM_SaveLongDouble(RedisModuleIO *io, long double value) {
    if (io->error) return;
    char buf[MAX_LONG_DOUBLE_CHARS];
    /* Long double has different number of bits in different platforms, so we
     * save it as a string type. */
    size_t len = ld2string(buf,sizeof(buf),value,LD_STR_HEX);
    RM_SaveStringBuffer(io,buf,len);
}",1,13,module.c,RM_SaveLongDouble,,false,7235,7242,RM_SaveLongDouble,,,356,"void RM_SaveLongDouble (RedisModuleIO*,long double)"
184139,METHOD,module.c:<global>,TYPE_DECL,"long double RM_LoadLongDouble(RedisModuleIO *io) {
    if (io->error) return 0;
    long double value;
    size_t len;
    char* str = RM_LoadStringBuffer(io,&len);
    if (!str) return 0;
    string2ld(str,len,&value);
    RM_Free(str);
    return value;
}",1,1,module.c,RM_LoadLongDouble,,false,7246,7255,RM_LoadLongDouble,,,357,long double RM_LoadLongDouble (RedisModuleIO*)
184175,METHOD,module.c:<global>,TYPE_DECL,"ssize_t rdbSaveModulesAux(rio *rdb, int when) {
    size_t total_written = 0;
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        listIter li;
        listNode *ln;

        listRewind(module->types,&li);
        while((ln = listNext(&li))) {
            moduleType *mt = ln->value;
            if ((!mt->aux_save && !mt->aux_save2) || !(mt->aux_save_triggers & when))
                continue;
            ssize_t ret = rdbSaveSingleModuleAux(rdb, when, mt);
            if (ret==-1) {
                dictReleaseIterator(di);
                return -1;
            }
            total_written += ret;
        }
    }

    dictReleaseIterator(di);
    return total_written;
}",1,1,module.c,rdbSaveModulesAux,,false,7259,7285,rdbSaveModulesAux,,,358,"ssize_t rdbSaveModulesAux (rio*,int)"
184269,METHOD,module.c:<global>,TYPE_DECL,"void RM_DigestAddStringBuffer(RedisModuleDigest *md, const char *ele, size_t len) {
    mixDigest(md->o,ele,len);
}",1,1,module.c,RM_DigestAddStringBuffer,,false,7329,7331,RM_DigestAddStringBuffer,,,359,"void RM_DigestAddStringBuffer (RedisModuleDigest*,char*,size_t)"
184282,METHOD,module.c:<global>,TYPE_DECL,"void RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {
    char buf[LONG_STR_SIZE];
    size_t len = ll2string(buf,sizeof(buf),ll);
    mixDigest(md->o,buf,len);
}",1,13,module.c,RM_DigestAddLongLong,,false,7335,7339,RM_DigestAddLongLong,,,360,"void RM_DigestAddLongLong (RedisModuleDigest*,long long)"
184303,METHOD,module.c:<global>,TYPE_DECL,"void RM_DigestEndSequence(RedisModuleDigest *md) {
    xorDigest(md->x,md->o,sizeof(md->o));
    memset(md->o,0,sizeof(md->o));
}",1,1,module.c,RM_DigestEndSequence,,false,7342,7345,RM_DigestEndSequence,,,361,void RM_DigestEndSequence (RedisModuleDigest*)
184328,METHOD,module.c:<global>,TYPE_DECL,"void *RM_LoadDataTypeFromStringEncver(const RedisModuleString *str, const moduleType *mt, int encver) {
    rio payload;
    RedisModuleIO io;
    void *ret;

    rioInitWithBuffer(&payload, str->ptr);
    moduleInitIOContext(io,(moduleType *)mt,&payload,NULL,-1);

    /* All RM_Save*() calls always write a version 2 compatible format, so we
     * need to make sure we read the same.
     */
    ret = mt->rdb_load(&io,encver);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    return ret;
}",1,44,module.c,RM_LoadDataTypeFromStringEncver,,false,7361,7378,RM_LoadDataTypeFromStringEncver,,,362,"void* RM_LoadDataTypeFromStringEncver (robj*,moduleType*,int)"
184423,METHOD,module.c:<global>,TYPE_DECL,"void *RM_LoadDataTypeFromString(const RedisModuleString *str, const moduleType *mt) {
    return RM_LoadDataTypeFromStringEncver(str, mt, 0);
}",1,38,module.c,RM_LoadDataTypeFromString,,false,7383,7385,RM_LoadDataTypeFromString,,,363,"void* RM_LoadDataTypeFromString (robj*,moduleType*)"
184434,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_SaveDataTypeToString(RedisModuleCtx *ctx, void *data, const moduleType *mt) {
    rio payload;
    RedisModuleIO io;

    rioInitWithBuffer(&payload,sdsempty());
    moduleInitIOContext(io,(moduleType *)mt,&payload,NULL,-1);
    mt->rdb_save(&io,data);
    if (io.ctx) {
        moduleFreeContext(io.ctx);
        zfree(io.ctx);
    }
    if (io.error) {
        return NULL;
    } else {
        robj *str = createObject(OBJ_STRING,payload.io.buffer.ptr);
        if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,str);
        return str;
    }
}",1,17,module.c,RM_SaveDataTypeToString,,false,7394,7412,RM_SaveDataTypeToString,,,364,"robj RM_SaveDataTypeToString (RedisModuleCtx*,void*,moduleType*)"
184558,METHOD,module.c:<global>,TYPE_DECL,"const RedisModuleString *RM_GetKeyNameFromDigest(RedisModuleDigest *dig) {
    return dig->key;
}",1,6,module.c,RM_GetKeyNameFromDigest,,false,7415,7417,RM_GetKeyNameFromDigest,,,365,robj RM_GetKeyNameFromDigest (RedisModuleDigest*)
184567,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetDbIdFromDigest(RedisModuleDigest *dig) {
    return dig->dbid;
}",1,1,module.c,RM_GetDbIdFromDigest,,false,7420,7422,RM_GetDbIdFromDigest,,,366,int RM_GetDbIdFromDigest (RedisModuleDigest*)
184576,METHOD,module.c:<global>,TYPE_DECL,"void RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {
    if (io->error) return;
    struct redisCommand *cmd;
    robj **argv = NULL;
    int argc = 0, flags = 0, j;
    va_list ap;

    cmd = lookupCommandByCString((char*)cmdname);
    if (!cmd) {
        serverLog(LL_WARNING,
            ""Fatal: AOF method for module data type '%s' tried to ""
            ""emit unknown command '%s'"",
            io->type->name, cmdname);
        io->error = 1;
        errno = EINVAL;
        return;
    }

    /* Emit the arguments into the AOF in Redis protocol format. */
    va_start(ap, fmt);
    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);
    va_end(ap);
    if (argv == NULL) {
        serverLog(LL_WARNING,
            ""Fatal: AOF method for module data type '%s' tried to ""
            ""call RedisModule_EmitAOF() with wrong format specifiers '%s'"",
            io->type->name, fmt);
        io->error = 1;
        errno = EINVAL;
        return;
...",1,8,module.c,RM_EmitAOF,,false,7432,7476,RM_EmitAOF,,,367,"void RM_EmitAOF (RedisModuleIO*,char*,char*...)"
184759,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {
    if (io->ctx) return io->ctx; /* Can't have more than one... */
    io->ctx = zmalloc(sizeof(RedisModuleCtx));
    moduleCreateContext(io->ctx, io->type->module, REDISMODULE_CTX_NONE);
    return io->ctx;
}",1,51,module.c,RM_GetContextFromIO,,false,7482,7487,RM_GetContextFromIO,,,368,RedisModuleCtx RM_GetContextFromIO (RedisModuleIO*)
184796,METHOD,module.c:<global>,TYPE_DECL,"const RedisModuleString *RM_GetKeyNameFromIO(RedisModuleIO *io) {
    return io->key;
}",1,6,module.c,RM_GetKeyNameFromIO,,false,7492,7494,RM_GetKeyNameFromIO,,,369,robj RM_GetKeyNameFromIO (RedisModuleIO*)
184805,METHOD,module.c:<global>,TYPE_DECL,"const RedisModuleString *RM_GetKeyNameFromModuleKey(RedisModuleKey *key) {
    return key ? key->key : NULL;
}",1,6,module.c,RM_GetKeyNameFromModuleKey,,false,7497,7499,RM_GetKeyNameFromModuleKey,,,370,robj RM_GetKeyNameFromModuleKey (RedisModuleKey*)
184817,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetDbIdFromModuleKey(RedisModuleKey *key) {
    return key ? key->db->id : -1;
}",1,1,module.c,RM_GetDbIdFromModuleKey,,false,7502,7504,RM_GetDbIdFromModuleKey,,,371,int RM_GetDbIdFromModuleKey (RedisModuleKey*)
184832,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetDbIdFromIO(RedisModuleIO *io) {
    return io->dbid;
}",1,1,module.c,RM_GetDbIdFromIO,,false,7509,7511,RM_GetDbIdFromIO,,,372,int RM_GetDbIdFromIO (RedisModuleIO*)
184841,METHOD,module.c:<global>,TYPE_DECL,"void moduleLogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {
    char msg[LOG_MAX_LEN];
    size_t name_len;
    int level;

    if (!strcasecmp(levelstr,""debug"")) level = LL_DEBUG;
    else if (!strcasecmp(levelstr,""verbose"")) level = LL_VERBOSE;
    else if (!strcasecmp(levelstr,""notice"")) level = LL_NOTICE;
    else if (!strcasecmp(levelstr,""warning"")) level = LL_WARNING;
    else level = LL_VERBOSE; /* Default. */

    if (level < server.verbosity) return;

    name_len = snprintf(msg, sizeof(msg),""<%s> "", module? module->name: ""module"");
    vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);
    serverLogRaw(level,msg);
}",1,13,module.c,moduleLogRaw,,false,7523,7539,moduleLogRaw,,,373,"void moduleLogRaw (RedisModule*,char*,char*,va_list)"
184943,METHOD,module.c:<global>,TYPE_DECL,"void RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    moduleLogRaw(ctx? ctx->module: NULL,levelstr,fmt,ap);
    va_end(ap);
}",1,1,module.c,RM_Log,,false,7559,7564,RM_Log,,,374,"void RM_Log (RedisModuleCtx*,char*,char*...)"
184966,METHOD,module.c:<global>,TYPE_DECL,"void RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    moduleLogRaw(io->type->module,levelstr,fmt,ap);
    va_end(ap);
}",1,1,module.c,RM_LogIOError,,false,7571,7576,RM_LogIOError,,,375,"void RM_LogIOError (RedisModuleIO*,char*,char*...)"
184988,METHOD,module.c:<global>,TYPE_DECL,"void RM__Assert(const char *estr, const char *file, int line) {
    _serverAssert(estr, file, line);
}",1,1,module.c,RM__Assert,,false,7586,7588,RM__Assert,,,376,"void RM__Assert (char*,char*,int)"
184999,METHOD,module.c:<global>,TYPE_DECL,"void RM_LatencyAddSample(const char *event, mstime_t latency) {
    if (latency >= server.latency_monitor_threshold)
        latencyAddSample(event, latency);
}",1,1,module.c,RM_LatencyAddSample,,false,7593,7596,RM_LatencyAddSample,,,377,"void RM_LatencyAddSample (char*,mstime_t)"
185015,METHOD,module.c:<global>,TYPE_DECL,"void unblockClientFromModule(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Call the disconnection callback if any. Note that
     * bc->disconnect_callback is set to NULL if the client gets disconnected
     * by the module itself or because of a timeout, so the callback will NOT
     * get called if this is not an actual disconnection event. */
    if (bc->disconnect_callback) {
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_NONE);
        ctx.blocked_privdata = bc->privdata;
        ctx.client = bc->client;
        bc->disconnect_callback(&ctx,bc);
        moduleFreeContext(&ctx);
    }

    /* If we made it here and client is still blocked it means that the command
     * timed-out, client was killed or disconnected and disconnect_callback was
     * not implemented (or it was, but RM_UnblockClient was not called from
     * within it, as it should).
     * We must call moduleUnblockClient in or...",1,46,module.c,unblockClientFromModule,,false,7617,7652,unblockClientFromModule,,,378,void unblockClientFromModule (client*)
185084,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleBlockedClient *moduleBlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                            RedisModuleAuthCallback auth_reply_callback,
                                            RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                            long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata,
                                            int flags) {
    client *c = ctx->client;
    int islua = scriptIsRunning();
    int ismulti = server.in_exec;

    c->bstate.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    ctx->module->blocked_clients++;

    /* We need to handle the invalid operation of calling modules blocking
     * commands from Lua or MULTI. We actually create an already aborted
     * (client set to NULL) blocked client handle, and actually reply ...",1,66,module.c,moduleBlockClient,,false,7674,7739,moduleBlockClient,,,379,"RedisModuleBlockedClient moduleBlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleAuthCallback,RedisModuleCmdFunc,void,long long,robj**,int,void*,int)"
185378,METHOD,module.c:<global>,TYPE_DECL,"void RM_RegisterAuthCallback(RedisModuleCtx *ctx, RedisModuleAuthCallback cb) {
    RedisModuleAuthCtx *auth_ctx = zmalloc(sizeof(RedisModuleAuthCtx));
    auth_ctx->module = ctx->module;
    auth_ctx->auth_cb = cb;
    listAddNodeHead(moduleAuthCallbacks, auth_ctx);
}",1,1,module.c,RM_RegisterAuthCallback,,false,7794,7799,RM_RegisterAuthCallback,,,380,"void RM_RegisterAuthCallback (RedisModuleCtx*,RedisModuleAuthCallback)"
185405,METHOD,module.c:<global>,TYPE_DECL,"void moduleInvokeFreePrivDataCallback(client *c, RedisModuleBlockedClient *bc) {
    if (bc->privdata && bc->free_privdata) {
        RedisModuleCtx ctx;
        int ctx_flags = c == NULL ? REDISMODULE_CTX_BLOCKED_DISCONNECTED : REDISMODULE_CTX_NONE;
        moduleCreateContext(&ctx, bc->module, ctx_flags);
        ctx.blocked_privdata = bc->privdata;
        ctx.client = bc->client;
        bc->free_privdata(&ctx,bc->privdata);
        moduleFreeContext(&ctx);
    }
}",1,36,module.c,moduleInvokeFreePrivDataCallback,,false,7802,7812,moduleInvokeFreePrivDataCallback,,,381,"void moduleInvokeFreePrivDataCallback (client*,RedisModuleBlockedClient*)"
185469,METHOD,module.c:<global>,TYPE_DECL,"void moduleUnregisterAuthCBs(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(moduleAuthCallbacks, &li);
    while ((ln = listNext(&li))) {
        RedisModuleAuthCtx *ctx = listNodeValue(ln);
        if (ctx->module == module) {
            listDelNode(moduleAuthCallbacks, ln);
            zfree(ctx);
        }
    }
}",1,34,module.c,moduleUnregisterAuthCBs,,false,7815,7826,moduleUnregisterAuthCBs,,,382,void moduleUnregisterAuthCBs (RedisModule*)
185508,METHOD,module.c:<global>,TYPE_DECL,"int attemptNextAuthCb(client *c, robj *username, robj *password, robj **err) {
    int handle_next_callback = c->module_auth_ctx == NULL;
    RedisModuleAuthCtx *cur_auth_ctx = NULL;
    listNode *ln;
    listIter li;
    listRewind(moduleAuthCallbacks, &li);
    int result = REDISMODULE_AUTH_NOT_HANDLED;
    while((ln = listNext(&li))) {
        cur_auth_ctx = listNodeValue(ln);
        /* Skip over the previously attempted auth contexts. */
        if (!handle_next_callback) {
            handle_next_callback = cur_auth_ctx == c->module_auth_ctx;
            continue;
        }
        /* Remove the module auth complete flag before we attempt the next cb. */
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, cur_auth_ctx->module, REDISMODULE_CTX_NONE);
        ctx.client = c;
        *err = NULL;
        c->module_auth_ctx = cur_auth_ctx;
        result = cur_auth_ctx->auth_cb(&ctx, username, password, err);
        mo...",1,17,module.c,attemptNextAuthCb,,false,7830,7857,attemptNextAuthCb,,,383,"int attemptNextAuthCb (client*,robj*,robj*,robj**)"
185625,METHOD,module.c:<global>,TYPE_DECL,"int attemptBlockedAuthReplyCallback(client *c, robj *username, robj *password, robj **err) {
    int result = REDISMODULE_AUTH_NOT_HANDLED;
    if (!c->module_blocked_client) return result;
    RedisModuleBlockedClient *bc = (RedisModuleBlockedClient *) c->module_blocked_client;
    bc->client = c;
    if (bc->auth_reply_cb) {
        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_REPLY);
        ctx.blocked_privdata = bc->privdata;
        ctx.blocked_ready_key = NULL;
        ctx.client = bc->client;
        ctx.blocked_client = bc;
        result = bc->auth_reply_cb(&ctx, username, password, err);
        moduleFreeContext(&ctx);
    }
    moduleInvokeFreePrivDataCallback(c, bc);
    c->module_blocked_client = NULL;
    c->lastcmd->microseconds += bc->background_duration;
    bc->module->blocked_clients--;
    zfree(bc);
    return result;
}",1,17,module.c,attemptBlockedAuthReplyCallback,,false,7864,7885,attemptBlockedAuthReplyCallback,,,384,"int attemptBlockedAuthReplyCallback (client*,robj*,robj*,robj**)"
185742,METHOD,module.c:<global>,TYPE_DECL,"int checkModuleAuthentication(client *c, robj *username, robj *password, robj **err) {
    if (!listLength(moduleAuthCallbacks)) return AUTH_NOT_HANDLED;
    int result = attemptBlockedAuthReplyCallback(c, username, password, err);
    if (result == REDISMODULE_AUTH_NOT_HANDLED) {
        result = attemptNextAuthCb(c, username, password, err);
    }
    if (c->flags & CLIENT_BLOCKED) {
        /* Modules are expected to return REDISMODULE_AUTH_HANDLED when blocking clients. */
        serverAssert(result == REDISMODULE_AUTH_HANDLED);
        return AUTH_BLOCKED;
    }
    c->module_auth_ctx = NULL;
    if (result == REDISMODULE_AUTH_NOT_HANDLED) {
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        return AUTH_NOT_HANDLED;
    }
    if (c->flags & CLIENT_MODULE_AUTH_HAS_RESULT) {
        c->flags &= ~CLIENT_MODULE_AUTH_HAS_RESULT;
        if (c->authenticated) return AUTH_OK;
    }
    return AUTH_ERR;
}",1,9,module.c,checkModuleAuthentication,,false,7897,7918,checkModuleAuthentication,,,385,"int checkModuleAuthentication (client*,robj*,robj*,robj**)"
185866,METHOD,module.c:<global>,TYPE_DECL,"int moduleTryServeClientBlockedOnKey(client *c, robj *key) {
    int served = 0;
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Protect against re-processing: don't serve clients that are already
     * in the unblocking list for any reason (including RM_UnblockClient()
     * explicit call). See #6798. */
    if (bc->unblocked) return 0;

    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_REPLY);
    ctx.blocked_ready_key = key;
    ctx.blocked_privdata = bc->privdata;
    ctx.client = bc->client;
    ctx.blocked_client = bc;
    if (bc->reply_callback(&ctx,(void**)c->argv,c->argc) == REDISMODULE_OK)
        served = 1;
    moduleFreeContext(&ctx);
    return served;
}",1,42,module.c,moduleTryServeClientBlockedOnKey,,false,7927,7946,moduleTryServeClientBlockedOnKey,,,386,"int moduleTryServeClientBlockedOnKey (client*,robj*)"
185955,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                         RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                         long long timeout_ms) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, NULL,0,NULL,0);
}",1,1,module.c,RM_BlockClient,,false,7987,7991,RM_BlockClient,,,387,"RedisModuleBlockedClient RM_BlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long)"
185976,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleBlockedClient *RM_BlockClientOnAuth(RedisModuleCtx *ctx, RedisModuleAuthCallback reply_callback,
                                               void (*free_privdata)(RedisModuleCtx*,void*)) {
    if (!clientHasModuleAuthInProgress(ctx->client)) {
        addReplyError(ctx->client, ""Module blocking client on auth when not currently undergoing module authentication"");
        return NULL;
    }
    RedisModuleBlockedClient *bc = moduleBlockClient(ctx,NULL,reply_callback,NULL,free_privdata,0, NULL,0,NULL,0);
    if (ctx->client->flags & CLIENT_BLOCKED) {
        ctx->client->flags |= CLIENT_PENDING_COMMAND;
    }
    return bc;
}",1,9,module.c,RM_BlockClientOnAuth,,false,7997,8008,RM_BlockClientOnAuth,,,388,"RedisModuleBlockedClient RM_BlockClientOnAuth (RedisModuleCtx*,RedisModuleAuthCallback,void)"
186045,METHOD,module.c:<global>,TYPE_DECL,"void *RM_BlockClientGetPrivateData(RedisModuleBlockedClient *blocked_client) {
    return blocked_client->privdata;
}",1,1,module.c,RM_BlockClientGetPrivateData,,false,8011,8013,RM_BlockClientGetPrivateData,,,389,void* RM_BlockClientGetPrivateData (RedisModuleBlockedClient*)
186054,METHOD,module.c:<global>,TYPE_DECL,"void RM_BlockClientSetPrivateData(RedisModuleBlockedClient *blocked_client, void *private_data) {
    blocked_client->privdata = private_data;
}",1,1,module.c,RM_BlockClientSetPrivateData,,false,8016,8018,RM_BlockClientSetPrivateData,,,390,"void RM_BlockClientSetPrivateData (RedisModuleBlockedClient*,void*)"
186065,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleBlockedClient *RM_BlockClientOnKeys(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                               RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                               long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, keys,numkeys,privdata,0);
}",1,69,module.c,RM_BlockClientOnKeys,,false,8078,8082,RM_BlockClientOnKeys,,,391,"RedisModuleBlockedClient RM_BlockClientOnKeys (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,robj**,int,void*)"
186089,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleBlockedClient *RM_BlockClientOnKeysWithFlags(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback,
                                                        RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*),
                                                        long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata,
                                                        int flags) {
    return moduleBlockClient(ctx,reply_callback,NULL,timeout_callback,free_privdata,timeout_ms, keys,numkeys,privdata,flags);
}",1,78,module.c,RM_BlockClientOnKeysWithFlags,,false,8093,8098,RM_BlockClientOnKeysWithFlags,,,392,"RedisModuleBlockedClient RM_BlockClientOnKeysWithFlags (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,robj**,int,void*,int)"
186114,METHOD,module.c:<global>,TYPE_DECL,"void RM_SignalKeyAsReady(RedisModuleCtx *ctx, RedisModuleString *key) {
    signalKeyAsReady(ctx->client->db, key, OBJ_MODULE);
}",1,46,module.c,RM_SignalKeyAsReady,,false,8103,8105,RM_SignalKeyAsReady,,,393,"void RM_SignalKeyAsReady (RedisModuleCtx*,robj*)"
186130,METHOD,module.c:<global>,TYPE_DECL,"int moduleUnblockClientByHandle(RedisModuleBlockedClient *bc, void *privdata) {
    pthread_mutex_lock(&moduleUnblockedClientsMutex);
    if (!bc->blocked_on_keys) bc->privdata = privdata;
    bc->unblocked = 1;
    if (listLength(moduleUnblockedClients) == 0) {
        if (write(server.module_pipe[1],""A"",1) != 1) {
            /* Ignore the error, this is best-effort. */
        }
    }
    listAddNodeTail(moduleUnblockedClients,bc);
    pthread_mutex_unlock(&moduleUnblockedClientsMutex);
    return REDISMODULE_OK;
}",1,8,module.c,moduleUnblockClientByHandle,,false,8108,8120,moduleUnblockClientByHandle,,,394,"int moduleUnblockClientByHandle (RedisModuleBlockedClient*,void*)"
186187,METHOD,module.c:<global>,TYPE_DECL,"void moduleUnblockClient(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    moduleUnblockClientByHandle(bc,NULL);
}",1,1,module.c,moduleUnblockClient,,false,8124,8127,moduleUnblockClient,,,395,void moduleUnblockClient (client*)
186203,METHOD,module.c:<global>,TYPE_DECL,"int moduleClientIsBlockedOnKeys(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    return bc->blocked_on_keys;
}",1,1,module.c,moduleClientIsBlockedOnKeys,,false,8131,8134,moduleClientIsBlockedOnKeys,,,396,int moduleClientIsBlockedOnKeys (client*)
186220,METHOD,module.c:<global>,TYPE_DECL,"int RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {
    if (bc->blocked_on_keys) {
        /* In theory the user should always pass the timeout handler as an
         * argument, but better to be safe than sorry. */
        if (bc->timeout_callback == NULL) return REDISMODULE_ERR;
        if (bc->unblocked) return REDISMODULE_OK;
        if (bc->client) moduleBlockedClientTimedOut(bc->client);
    }
    moduleUnblockClientByHandle(bc,privdata);
    return REDISMODULE_OK;
}",1,49,module.c,RM_UnblockClient,,false,8155,8165,RM_UnblockClient,,,397,"int RM_UnblockClient (RedisModuleBlockedClient*,void*)"
186267,METHOD,module.c:<global>,TYPE_DECL,"int RM_AbortBlock(RedisModuleBlockedClient *bc) {
    bc->reply_callback = NULL;
    bc->disconnect_callback = NULL;
    bc->auth_reply_cb = NULL;
    return RM_UnblockClient(bc,NULL);
}",1,1,module.c,RM_AbortBlock,,false,8169,8174,RM_AbortBlock,,,398,int RM_AbortBlock (RedisModuleBlockedClient*)
186291,METHOD,module.c:<global>,TYPE_DECL,"void RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {
    bc->disconnect_callback = callback;
}",1,1,module.c,RM_SetDisconnectCallback,,false,8192,8194,RM_SetDisconnectCallback,,,399,"void RM_SetDisconnectCallback (RedisModuleBlockedClient*,RedisModuleDisconnectFunc)"
186302,METHOD,module.c:<global>,TYPE_DECL,"void moduleHandleBlockedClients(void) {
    listNode *ln;
    RedisModuleBlockedClient *bc;

    pthread_mutex_lock(&moduleUnblockedClientsMutex);
    while (listLength(moduleUnblockedClients)) {
        ln = listFirst(moduleUnblockedClients);
        bc = ln->value;
        client *c = bc->client;
        listDelNode(moduleUnblockedClients,ln);
        pthread_mutex_unlock(&moduleUnblockedClientsMutex);

        /* Release the lock during the loop, as long as we don't
         * touch the shared list. */

        /* Call the reply callback if the client is valid and we have
         * any callback. However the callback is not called if the client
         * was blocked on keys (RM_BlockClientOnKeys()), because we already
         * called such callback in moduleTryServeClientBlockedOnKey() when
         * the key was signaled as ready. */
        long long prev_error_replies = server.stat_total_error_replies;
        uint64_t reply_us = 0;
        if (c && !bc->blocked_on_keys && b...",1,11,module.c,moduleHandleBlockedClients,,false,8204,8298,moduleHandleBlockedClients,,,400,void moduleHandleBlockedClients (void)
186584,METHOD,module.c:<global>,TYPE_DECL,"int moduleBlockedClientMayTimeout(client *c) {
    if (c->bstate.btype != BLOCKED_MODULE)
        return 1;

    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;
    return (bc && bc->timeout_callback != NULL);
}",1,1,module.c,moduleBlockedClientMayTimeout,,false,8303,8309,moduleBlockedClientMayTimeout,,,401,int moduleBlockedClientMayTimeout (client*)
186616,METHOD,module.c:<global>,TYPE_DECL,"void moduleBlockedClientTimedOut(client *c) {
    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;

    /* Protect against re-processing: don't serve clients that are already
     * in the unblocking list for any reason (including RM_UnblockClient()
     * explicit call). See #6798. */
    if (bc->unblocked) return;

    RedisModuleCtx ctx;
    moduleCreateContext(&ctx, bc->module, REDISMODULE_CTX_BLOCKED_TIMEOUT);
    ctx.client = bc->client;
    ctx.blocked_client = bc;
    ctx.blocked_privdata = bc->privdata;
    long long prev_error_replies = server.stat_total_error_replies;
    bc->timeout_callback(&ctx,(void**)c->argv,c->argc);
    moduleFreeContext(&ctx);
    updateStatsOnUnblock(c, bc->background_duration, 0, server.stat_total_error_replies != prev_error_replies);

    /* For timeout events, we do not want to call the disconnect callback,
     * because the blocked client will be automatically disconnected in
     * this case, and the user can still hook using...",1,42,module.c,moduleBlockedClientTimedOut,,false,8315,8337,moduleBlockedClientTimedOut,,,402,void moduleBlockedClientTimedOut (client*)
186705,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;
}",1,25,module.c,RM_IsBlockedReplyRequest,,false,8341,8343,RM_IsBlockedReplyRequest,,,403,int RM_IsBlockedReplyRequest (RedisModuleCtx*)
186722,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;
}",1,25,module.c,RM_IsBlockedTimeoutRequest,,false,8347,8349,RM_IsBlockedTimeoutRequest,,,404,int RM_IsBlockedTimeoutRequest (RedisModuleCtx*)
186739,METHOD,module.c:<global>,TYPE_DECL,"void *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {
    return ctx->blocked_privdata;
}",1,1,module.c,RM_GetBlockedClientPrivateData,,false,8352,8354,RM_GetBlockedClientPrivateData,,,405,void* RM_GetBlockedClientPrivateData (RedisModuleCtx*)
186748,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_GetBlockedClientReadyKey(RedisModuleCtx *ctx) {
    return ctx->blocked_ready_key;
}",1,17,module.c,RM_GetBlockedClientReadyKey,,false,8358,8360,RM_GetBlockedClientReadyKey,,,406,robj RM_GetBlockedClientReadyKey (RedisModuleCtx*)
186757,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {
    return ctx->blocked_client;
}",1,1,module.c,RM_GetBlockedClientHandle,,false,8366,8368,RM_GetBlockedClientHandle,,,407,RedisModuleBlockedClient RM_GetBlockedClientHandle (RedisModuleCtx*)
186766,METHOD,module.c:<global>,TYPE_DECL,"int RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {
    return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;
}",1,25,module.c,RM_BlockedClientDisconnected,,false,8373,8375,RM_BlockedClientDisconnected,,,408,int RM_BlockedClientDisconnected (RedisModuleCtx*)
186783,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {
    RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));
    RedisModule *module = bc ? bc->module : NULL;
    int flags = REDISMODULE_CTX_THREAD_SAFE;

    /* Creating a new client object is costly. To avoid that, we have an
     * internal pool of client objects. In blockClient(), a client object is
     * assigned to bc->thread_safe_ctx_client to be used for the thread safe
     * context.
     * For detached thread safe contexts, we create a new client object.
     * Otherwise, as this function can be called from different threads, we
     * would need to synchronize access to internal pool of client objects.
     * Assuming creating detached context is rare and not that performance
     * critical, we avoid synchronizing access to the client pool by creating
     * a new client */
    if (!bc) flags |= REDISMODULE_CTX_NEW_CLIENT;
    moduleCreateContext(ctx, module, flags);
    /* Even when the context is associate...",1,16,module.c,RM_GetThreadSafeContext,,false,8401,8432,RM_GetThreadSafeContext,,,409,RedisModuleCtx RM_GetThreadSafeContext (RedisModuleBlockedClient*)
186878,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCtx *RM_GetDetachedThreadSafeContext(RedisModuleCtx *ctx) {
    RedisModuleCtx *new_ctx = zmalloc(sizeof(*new_ctx));
    /* We create a new client object for the detached context.
     * See RM_GetThreadSafeContext() for more information */
    moduleCreateContext(new_ctx, ctx->module,
                        REDISMODULE_CTX_THREAD_SAFE|REDISMODULE_CTX_NEW_CLIENT);
    return new_ctx;
}",1,24,module.c,RM_GetDetachedThreadSafeContext,,false,8439,8446,RM_GetDetachedThreadSafeContext,,,410,RedisModuleCtx RM_GetDetachedThreadSafeContext (RedisModuleCtx*)
186908,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {
    moduleFreeContext(ctx);
    zfree(ctx);
}",1,1,module.c,RM_FreeThreadSafeContext,,false,8449,8452,RM_FreeThreadSafeContext,,,411,void RM_FreeThreadSafeContext (RedisModuleCtx*)
186917,METHOD,module.c:<global>,TYPE_DECL,"void moduleGILAfterLock(void) {
    /* We should never get here if we already inside a module
     * code block which already opened a context. */
    serverAssert(server.execution_nesting == 0);
    /* Bump up the nesting level to prevent immediate propagation
     * of possible RM_Call from th thread */
    enterExecutionUnit(1, 0);
}",1,4,module.c,moduleGILAfterLock,,false,8454,8461,moduleGILAfterLock,,,412,void moduleGILAfterLock (void)
186943,METHOD,module.c:<global>,TYPE_DECL,"void RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {
    UNUSED(ctx);
    moduleAcquireGIL();
    moduleGILAfterLock();
}",1,4,module.c,RM_ThreadSafeContextLock,,false,8466,8470,RM_ThreadSafeContextLock,,,413,void RM_ThreadSafeContextLock (RedisModuleCtx*)
186956,METHOD,module.c:<global>,TYPE_DECL,"int RM_ThreadSafeContextTryLock(RedisModuleCtx *ctx) {
    UNUSED(ctx);

    int res = moduleTryAcquireGIL();
    if(res != 0) {
        errno = res;
        return REDISMODULE_ERR;
    }
    moduleGILAfterLock();
    return REDISMODULE_OK;
}",1,4,module.c,RM_ThreadSafeContextTryLock,,false,8478,8488,RM_ThreadSafeContextTryLock,,,414,int RM_ThreadSafeContextTryLock (RedisModuleCtx*)
186988,METHOD,module.c:<global>,TYPE_DECL,"void moduleGILBeforeUnlock(void) {
    /* We should never get here if we already inside a module
     * code block which already opened a context, except
     * the bump-up from moduleGILAcquired. */
    serverAssert(server.execution_nesting == 1);
    /* Restore nesting level and propagate pending commands
     * (because it's unclear when thread safe contexts are
     * released we have to propagate here). */
    exitExecutionUnit();
    postExecutionUnitOperations();
}",1,4,module.c,moduleGILBeforeUnlock,,false,8490,8500,moduleGILBeforeUnlock,,,415,void moduleGILBeforeUnlock (void)
187013,METHOD,module.c:<global>,TYPE_DECL,"void RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {
    UNUSED(ctx);
    moduleGILBeforeUnlock();
    moduleReleaseGIL();
}",1,4,module.c,RM_ThreadSafeContextUnlock,,false,8503,8507,RM_ThreadSafeContextUnlock,,,416,void RM_ThreadSafeContextUnlock (RedisModuleCtx*)
187026,METHOD,module.c:<global>,TYPE_DECL,"void moduleAcquireGIL(void) {
    pthread_mutex_lock(&moduleGIL);
}",1,1,module.c,moduleAcquireGIL,,false,8509,8511,moduleAcquireGIL,,,417,void moduleAcquireGIL (void)
187034,METHOD,module.c:<global>,TYPE_DECL,"int moduleTryAcquireGIL(void) {
    return pthread_mutex_trylock(&moduleGIL);
}",1,1,module.c,moduleTryAcquireGIL,,false,8513,8515,moduleTryAcquireGIL,,,418,int moduleTryAcquireGIL (void)
187043,METHOD,module.c:<global>,TYPE_DECL,"void moduleReleaseGIL(void) {
    pthread_mutex_unlock(&moduleGIL);
}",1,1,module.c,moduleReleaseGIL,,false,8517,8519,moduleReleaseGIL,,,419,void moduleReleaseGIL (void)
187051,METHOD,module.c:<global>,TYPE_DECL,"int RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {
    RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));
    sub->module = ctx->module;
    sub->event_mask = types;
    sub->notify_callback = callback;
    sub->active = 0;

    listAddNodeTail(moduleKeyspaceSubscribers, sub);
    return REDISMODULE_OK;
}",1,11,module.c,RM_SubscribeToKeyspaceEvents,,false,8594,8603,RM_SubscribeToKeyspaceEvents,,,420,"int RM_SubscribeToKeyspaceEvents (RedisModuleCtx*,int,RedisModuleNotificationFunc)"
187094,METHOD,module.c:<global>,TYPE_DECL,"void firePostExecutionUnitJobs(void) {
    /* Avoid propagation of commands.
     * In that way, postExecutionUnitOperations will prevent
     * recursive calls to firePostExecutionUnitJobs.
     * This is a special case where we need to increase 'execution_nesting'
     * but we do not want to update the cached time */
    enterExecutionUnit(0, 0);
    while (listLength(modulePostExecUnitJobs) > 0) {
        listNode *ln = listFirst(modulePostExecUnitJobs);
        RedisModulePostExecUnitJob *job = listNodeValue(ln);
        listDelNode(modulePostExecUnitJobs, ln);

        RedisModuleCtx ctx;
        moduleCreateContext(&ctx, job->module, REDISMODULE_CTX_TEMP_CLIENT);
        selectDb(ctx.client, job->dbid);

        job->callback(&ctx, job->pd);
        if (job->free_pd) job->free_pd(job->pd);

        moduleFreeContext(&ctx);
        zfree(job);
    }
    exitExecutionUnit();
}",1,11,module.c,firePostExecutionUnitJobs,,false,8605,8628,firePostExecutionUnitJobs,,,421,void firePostExecutionUnitJobs (void)
187179,METHOD,module.c:<global>,TYPE_DECL,"int RM_AddPostNotificationJob(RedisModuleCtx *ctx, RedisModulePostNotificationJobFunc callback, void *privdata, void (*free_privdata)(void*)) {
    if (server.loading|| (server.masterhost && server.repl_slave_ro)) {
        return REDISMODULE_ERR;
    }
    RedisModulePostExecUnitJob *job = zmalloc(sizeof(*job));
    job->module = ctx->module;
    job->callback = callback;
    job->pd = privdata;
    job->free_pd = free_privdata;
    job->dbid = ctx->client->db->id;

    listAddNodeTail(modulePostExecUnitJobs, job);
    return REDISMODULE_OK;
}",1,15,module.c,RM_AddPostNotificationJob,,false,8647,8660,RM_AddPostNotificationJob,,,422,"int RM_AddPostNotificationJob (RedisModuleCtx*,RedisModulePostNotificationJobFunc,void*,void)"
187251,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetNotifyKeyspaceEvents(void) {
    return server.notify_keyspace_events;
}",1,1,module.c,RM_GetNotifyKeyspaceEvents,,false,8664,8666,RM_GetNotifyKeyspaceEvents,,,423,int RM_GetNotifyKeyspaceEvents (void)
187260,METHOD,module.c:<global>,TYPE_DECL,"int RM_NotifyKeyspaceEvent(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key) {
    if (!ctx || !ctx->client)
        return REDISMODULE_ERR;
    notifyKeyspaceEvent(type, (char *)event, key, ctx->client->db->id);
    return REDISMODULE_OK;
}",1,77,module.c,RM_NotifyKeyspaceEvent,,false,8669,8674,RM_NotifyKeyspaceEvent,,,424,"int RM_NotifyKeyspaceEvent (RedisModuleCtx*,int,char*,robj*)"
187298,METHOD,module.c:<global>,TYPE_DECL,"void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {
    /* Don't do anything if there aren't any subscribers */
    if (listLength(moduleKeyspaceSubscribers) == 0) return;

    /* Ugly hack to handle modules which use write commands from within
     * notify_callback, which they should NOT do!
     * Modules should use RedisModules_AddPostNotificationJob instead.
     *
     * Anyway, we want any propagated commands from within notify_callback
     * to be propagated inside a MULTI/EXEC together with the original
     * command that caused the KSN.
     * Note that it's only relevant for KSNs which are not generated from within
     * call(), for example active-expiry and eviction (because anyway
     * execution_nesting is incremented from within call())
     *
     * In order to do that we increment the execution_nesting counter, thus
     * preventing postExecutionUnitOperations (from within moduleFreeContext)
     * from propagating commands from C...",1,8,module.c,moduleNotifyKeyspaceEvent,,false,8679,8732,moduleNotifyKeyspaceEvent,,,425,"void moduleNotifyKeyspaceEvent (int,char*,robj*,int)"
187426,METHOD,module.c:<global>,TYPE_DECL,"void moduleUnsubscribeNotifications(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(moduleKeyspaceSubscribers,&li);
    while((ln = listNext(&li))) {
        RedisModuleKeyspaceSubscriber *sub = ln->value;
        if (sub->module == module) {
            listDelNode(moduleKeyspaceSubscribers, ln);
            zfree(sub);
        }
    }
}",1,1,module.c,moduleUnsubscribeNotifications,,false,8735,8746,moduleUnsubscribeNotifications,,,426,void moduleUnsubscribeNotifications (RedisModule*)
187462,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);",14,151,module.c,RedisModuleClusterMessageReceiver,,false,8753,8753,RedisModuleClusterMessageReceiver,,,427,"void RedisModuleClusterMessageReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)"
187484,METHOD,<empty>,<empty>,<empty>,1,,module.c,moduleClusterNodeInfo:<clinit>,,false,8765,,<clinit>,,,5,
187498,METHOD,module.c:<global>,TYPE_DECL,"void moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    moduleClusterReceiver *r = clusterReceivers[type];
    while(r) {
        if (r->module_id == module_id) {
            RedisModuleCtx ctx;
            moduleCreateContext(&ctx, r->module, REDISMODULE_CTX_TEMP_CLIENT);
            r->callback(&ctx,sender_id,type,payload,len);
            moduleFreeContext(&ctx);
            return;
        }
        r = r->next;
    }
}",1,49,module.c,moduleCallClusterReceivers,,false,8777,8789,moduleCallClusterReceivers,,,434,"void moduleCallClusterReceivers (char*,uint64_t,uint8_t,unsigned char*,uint32_t)"
187554,METHOD,module.c:<global>,TYPE_DECL,"void RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {
    if (!server.cluster_enabled) return;

    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
    moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;
    while(r) {
        if (r->module_id == module_id) {
            /* Found! Set or delete. */
            if (callback) {
                r->callback = callback;
            } else {
                /* Delete the receiver entry if the user is setting
                 * it to NULL. Just unlink the receiver node from the
                 * linked list. */
                if (prev)
                    prev->next = r->next;
                else
                    clusterReceivers[type]->next = r->next;
                zfree(r);
            }
            return;
        }
        prev = r;
        r = r->next;
    }

    /* Not found, let's add it. */
    if (callback) {
        r = zmalloc(si...",1,1,module.c,RM_RegisterClusterMessageReceiver,,false,8796,8831,RM_RegisterClusterMessageReceiver,,,435,"void RM_RegisterClusterMessageReceiver (RedisModuleCtx*,uint8_t,RedisModuleClusterMessageReceiver)"
187678,METHOD,module.c:<global>,TYPE_DECL,"int RM_SendClusterMessage(RedisModuleCtx *ctx, const char *target_id, uint8_t type, const char *msg, uint32_t len) {
    if (!server.cluster_enabled) return REDISMODULE_ERR;
    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);
    if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)
        return REDISMODULE_OK;
    else
        return REDISMODULE_ERR;
}",1,40,module.c,RM_SendClusterMessage,,false,8840,8847,RM_SendClusterMessage,,,436,"int RM_SendClusterMessage (RedisModuleCtx*,char*,uint8_t,char*,uint32_t)"
187729,METHOD,module.c:<global>,TYPE_DECL,"char **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {
    UNUSED(ctx);

    if (!server.cluster_enabled) return NULL;
    size_t count = dictSize(server.cluster->nodes);
    char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);
    dictIterator *di = dictGetIterator(server.cluster->nodes);
    dictEntry *de;
    int j = 0;
    while((de = dictNext(di)) != NULL) {
        clusterNode *node = dictGetVal(de);
        if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;
        ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);
        memcpy(ids[j],node->name,REDISMODULE_NODE_ID_LEN);
        j++;
    }
    *numnodes = j;
    ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need
                    * to also get the count argument. */
    dictReleaseIterator(di);
    return ids;
}",1,4,module.c,RM_GetClusterNodesList,,false,8871,8892,RM_GetClusterNodesList,,,437,"char** RM_GetClusterNodesList (RedisModuleCtx*,size_t*)"
187863,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeClusterNodesList(char **ids) {
    if (ids == NULL) return;
    for (int j = 0; ids[j]; j++) zfree(ids[j]);
    zfree(ids);
}",1,1,module.c,RM_FreeClusterNodesList,,false,8895,8899,RM_FreeClusterNodesList,,,438,void RM_FreeClusterNodesList (char**)
187891,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_GetMyClusterID(void) {
    if (!server.cluster_enabled) return NULL;
    return server.cluster->myself->name;
}",1,1,module.c,RM_GetMyClusterID,,false,8903,8906,RM_GetMyClusterID,,,439,const char* RM_GetMyClusterID (void)
187912,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_GetClusterSize(void) {
    if (!server.cluster_enabled) return 0;
    return dictSize(server.cluster->nodes);
}",1,11,module.c,RM_GetClusterSize,,false,8912,8915,RM_GetClusterSize,,,440,size_t RM_GetClusterSize (void)
187952,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {
    UNUSED(ctx);

    clusterNode *node = clusterLookupNode(id, strlen(id));
    if (node == NULL ||
        node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))
    {
        return REDISMODULE_ERR;
    }

    if (ip) redis_strlcpy(ip,node->ip,NET_IP_STR_LEN);

    if (master_id) {
        /* If the information is not available, the function will set the
         * field to zero bytes, so that when the field can't be populated the
         * function kinda remains predictable. */
        if (node->flags & CLUSTER_NODE_SLAVE && node->slaveof)
            memcpy(master_id,node->slaveof->name,REDISMODULE_NODE_ID_LEN);
        else
            memset(master_id,0,REDISMODULE_NODE_ID_LEN);
    }
    if (port) *port = getNodeDefaultClientPort(node);

    /* As usually we have to remap flags for modules, in order to ensure
     * we can provide binary compatibility. */
...",1,4,module.c,RM_GetClusterNodeInfo,,false,8937,8972,RM_GetClusterNodeInfo,,,441,"int RM_GetClusterNodeInfo (RedisModuleCtx*,char*,char*,char*,int*,int*)"
188162,METHOD,module.c:<global>,TYPE_DECL,"void RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {
    UNUSED(ctx);
    if (flags & REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)
        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;
    if (flags & REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)
        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;
}",1,4,module.c,RM_SetClusterFlags,,false,8992,8998,RM_SetClusterFlags,,,442,"void RM_SetClusterFlags (RedisModuleCtx*,uint64_t)"
188216,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);",14,69,module.c,RedisModuleTimerProc,,false,9022,9022,RedisModuleTimerProc,,,446,"void RedisModuleTimerProc (RedisModuleCtx*,void*)"
188228,METHOD,module.c:<global>,TYPE_DECL,"int moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* To start let's try to fire all the timers already expired. */
    raxIterator ri;
    raxStart(&ri,Timers);
    uint64_t now = ustime();
    long long next_period = 0;
    while(1) {
        raxSeek(&ri,""^"",NULL,0);
        if (!raxNext(&ri)) break;
        uint64_t expiretime;
        memcpy(&expiretime,ri.key,sizeof(expiretime));
        expiretime = ntohu64(expiretime);
        if (now >= expiretime) {
            RedisModuleTimer *timer = ri.data;
            RedisModuleCtx ctx;
            moduleCreateContext(&ctx,timer->module,REDISMODULE_CTX_TEMP_CLIENT);
            selectDb(ctx.client, timer->dbid);
            timer->callback(&ctx,timer->data);
            moduleFreeContext(&ctx);
            raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);
            zfree(timer);
        } else {
            /* We call us...",1,4,module.c,moduleTimerHandler,,false,9034,9080,moduleTimerHandler,,,449,"int moduleTimerHandler (aeEventLoop*,long long,void*)"
188395,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {
    RedisModuleTimer *timer = zmalloc(sizeof(*timer));
    timer->module = ctx->module;
    timer->callback = callback;
    timer->data = data;
    timer->dbid = ctx->client ? ctx->client->db->id : 0;
    uint64_t expiretime = ustime()+period*1000;
    uint64_t key;

    while(1) {
        key = htonu64(expiretime);
        if (raxFind(Timers, (unsigned char*)&key,sizeof(key)) == raxNotFound) {
            raxInsert(Timers,(unsigned char*)&key,sizeof(key),timer,NULL);
            break;
        } else {
            expiretime++;
        }
    }

    /* We need to install the main event loop timer if it's not already
     * installed, or we may need to refresh its period if we just installed
     * a timer that will expire sooner than any other else (i.e. the timer
     * we just installed is the first timer in the Timers rax). */
    if (aeTimer != -1) {
        raxIt...",1,14,module.c,RM_CreateTimer,,false,9094,9137,RM_CreateTimer,,,450,"RedisModuleTimerID RM_CreateTimer (RedisModuleCtx*,mstime_t,RedisModuleTimerProc,void*)"
188551,METHOD,module.c:<global>,TYPE_DECL,"int RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {
    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
    if (timer == raxNotFound || timer->module != ctx->module)
        return REDISMODULE_ERR;
    if (data) *data = timer->data;
    raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);
    zfree(timer);
    return REDISMODULE_OK;
}",1,15,module.c,RM_StopTimer,,false,9143,9151,RM_StopTimer,,,451,"int RM_StopTimer (RedisModuleCtx*,RedisModuleTimerID,void**)"
188610,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {
    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));
    if (timer == raxNotFound || timer->module != ctx->module)
        return REDISMODULE_ERR;
    if (remaining) {
        int64_t rem = ntohu64(id)-ustime();
        if (rem < 0) rem = 0;
        *remaining = rem/1000; /* Scale to milliseconds. */
    }
    if (data) *data = timer->data;
    return REDISMODULE_OK;
}",1,15,module.c,RM_GetTimerInfo,,false,9159,9170,RM_GetTimerInfo,,,452,"int RM_GetTimerInfo (RedisModuleCtx*,RedisModuleTimerID,uint64_t*,void**)"
188686,METHOD,module.c:<global>,TYPE_DECL,"int moduleHoldsTimer(struct RedisModule *module) {
    raxIterator iter;
    int found = 0;
    raxStart(&iter,Timers);
    raxSeek(&iter,""^"",NULL,0);
    while (raxNext(&iter)) {
        RedisModuleTimer *timer = iter.data;
        if (timer->module == module) {
            found = 1;
            break;
        }
    }
    raxStop(&iter);
    return found;
}",1,1,module.c,moduleHoldsTimer,,false,9174,9188,moduleHoldsTimer,,,453,int moduleHoldsTimer (RedisModule*)
188747,METHOD,module.c:<global>,TYPE_DECL,"static int eventLoopToAeMask(int mask) {
    int aeMask = 0;
    if (mask & REDISMODULE_EVENTLOOP_READABLE)
        aeMask |= AE_READABLE;
    if (mask & REDISMODULE_EVENTLOOP_WRITABLE)
        aeMask |= AE_WRITABLE;
    return aeMask;
}",1,15,module.c,eventLoopToAeMask,,false,9208,9215,eventLoopToAeMask,,,461,int eventLoopToAeMask (int)
188782,METHOD,module.c:<global>,TYPE_DECL,"static int eventLoopFromAeMask(int ae_mask) {
    int mask = 0;
    if (ae_mask & AE_READABLE)
        mask |= REDISMODULE_EVENTLOOP_READABLE;
    if (ae_mask & AE_WRITABLE)
        mask |= REDISMODULE_EVENTLOOP_WRITABLE;
    return mask;
}",1,18,module.c,eventLoopFromAeMask,,false,9217,9224,eventLoopFromAeMask,,,462,int eventLoopFromAeMask (int)
188817,METHOD,module.c:<global>,TYPE_DECL,"static void eventLoopCbReadable(struct aeEventLoop *ae, int fd, void *user_data, int ae_mask) {
    UNUSED(ae);
    EventLoopData *data = user_data;
    data->rFunc(fd, data->user_data, eventLoopFromAeMask(ae_mask));
}",1,4,module.c,eventLoopCbReadable,,false,9226,9230,eventLoopCbReadable,,,463,"void eventLoopCbReadable (aeEventLoop*,int,void*,int)"
188845,METHOD,module.c:<global>,TYPE_DECL,"static void eventLoopCbWritable(struct aeEventLoop *ae, int fd, void *user_data, int ae_mask) {
    UNUSED(ae);
    EventLoopData *data = user_data;
    data->wFunc(fd, data->user_data, eventLoopFromAeMask(ae_mask));
}",1,4,module.c,eventLoopCbWritable,,false,9232,9236,eventLoopCbWritable,,,464,"void eventLoopCbWritable (aeEventLoop*,int,void*,int)"
188873,METHOD,module.c:<global>,TYPE_DECL,"int RM_EventLoopAdd(int fd, int mask, RedisModuleEventLoopFunc func, void *user_data) {
    if (fd < 0 || fd >= aeGetSetSize(server.el)) {
        errno = ERANGE;
        return REDISMODULE_ERR;
    }

    if (!func || mask & ~(REDISMODULE_EVENTLOOP_READABLE |
                          REDISMODULE_EVENTLOOP_WRITABLE)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* We are going to register stub callbacks to 'ae' for two reasons:
     *
     * - ""ae"" callback signature is different from RedisModuleEventLoopCallback,
     *   that will be handled it in our stub callbacks.
     * - We need to remap 'mask' value to provide binary compatibility.
     *
     * For the stub callbacks, saving user 'callback' and 'user_data' in an
     * EventLoopData object and passing it to ae, later, we'll extract
     * 'callback' and 'user_data' from that.
     */
    EventLoopData *data = aeGetFileClientData(server.el, fd);
    if (!data)
        data = zcalloc(sizeof(*data));

...",1,15,module.c,RM_EventLoopAdd,,false,9263,9311,RM_EventLoopAdd,,,465,"int RM_EventLoopAdd (int,int,RedisModuleEventLoopFunc,void*)"
189028,METHOD,module.c:<global>,TYPE_DECL,"int RM_EventLoopDel(int fd, int mask) {
    if (fd < 0 || fd >= aeGetSetSize(server.el)) {
        errno = ERANGE;
        return REDISMODULE_ERR;
    }

    if (mask & ~(REDISMODULE_EVENTLOOP_READABLE |
                 REDISMODULE_EVENTLOOP_WRITABLE)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* After deleting the event, if fd does not have any registered event
     * anymore, we can free the EventLoopData object. */
    EventLoopData *data = aeGetFileClientData(server.el, fd);
    aeDeleteFileEvent(server.el, fd, eventLoopToAeMask(mask));
    if (aeGetFileEvents(server.el, fd) == AE_NONE)
        zfree(data);

    errno = 0;
    return REDISMODULE_OK;
}",1,15,module.c,RM_EventLoopDel,,false,9327,9348,RM_EventLoopDel,,,466,"int RM_EventLoopDel (int,int)"
189107,METHOD,module.c:<global>,TYPE_DECL,"int RM_EventLoopAddOneShot(RedisModuleEventLoopOneShotFunc func, void *user_data) {
    if (!func) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    EventLoopOneShot *oneshot = zmalloc(sizeof(*oneshot));
    oneshot->func = func;
    oneshot->user_data = user_data;

    pthread_mutex_lock(&moduleEventLoopMutex);
    if (!moduleEventLoopOneShots) moduleEventLoopOneShots = listCreate();
    listAddNodeTail(moduleEventLoopOneShots, oneshot);
    pthread_mutex_unlock(&moduleEventLoopMutex);

    if (write(server.module_pipe[1],""A"",1) != 1) {
        /* Pipe is non-blocking, write() may fail if it's full. */
    }

    errno = 0;
    return REDISMODULE_OK;
}",1,15,module.c,RM_EventLoopAddOneShot,,false,9354,9375,RM_EventLoopAddOneShot,,,467,"int RM_EventLoopAddOneShot (RedisModuleEventLoopOneShotFunc,void*)"
189176,METHOD,module.c:<global>,TYPE_DECL,"static void eventLoopHandleOneShotEvents(void) {
    pthread_mutex_lock(&moduleEventLoopMutex);
    if (moduleEventLoopOneShots) {
        while (listLength(moduleEventLoopOneShots)) {
            listNode *ln = listFirst(moduleEventLoopOneShots);
            EventLoopOneShot *oneshot = ln->value;
            listDelNode(moduleEventLoopOneShots, ln);
            /* Unlock mutex before the callback. Another oneshot event can be
             * added in the callback, it will need to lock the mutex. */
            pthread_mutex_unlock(&moduleEventLoopMutex);
            oneshot->func(oneshot->user_data);
            zfree(oneshot);
            /* Lock again for the next iteration */
            pthread_mutex_lock(&moduleEventLoopMutex);
        }
    }
    pthread_mutex_unlock(&moduleEventLoopMutex);
}",1,15,module.c,eventLoopHandleOneShotEvents,,false,9379,9396,eventLoopHandleOneShotEvents,,,468,void eventLoopHandleOneShotEvents (void)
189231,METHOD,module.c:<global>,TYPE_DECL,"void moduleNotifyUserChanged(client *c) {
    if (c->auth_callback) {
        c->auth_callback(c->id, c->auth_callback_privdata);

        /* The callback will fire exactly once, even if the user remains
         * the same. It is expected to completely clean up the state
         * so all references are cleared here. */
        c->auth_callback = NULL;
        c->auth_callback_privdata = NULL;
        c->auth_module = NULL;
    }
}",1,1,module.c,moduleNotifyUserChanged,,false,9410,9421,moduleNotifyUserChanged,,,469,void moduleNotifyUserChanged (client*)
189266,METHOD,module.c:<global>,TYPE_DECL,"void revokeClientAuthentication(client *c) {
    /* Freeing the client would result in moduleNotifyUserChanged() to be
     * called later, however since we use revokeClientAuthentication() also
     * in moduleFreeAuthenticatedClients() to implement module unloading, we
     * do this action ASAP: this way if the module is unloaded, when the client
     * is eventually freed we don't rely on the module to still exist. */
    moduleNotifyUserChanged(c);

    c->user = DefaultUser;
    c->authenticated = 0;
    /* We will write replies to this client later, so we can't close it
     * directly even if async. */
    if (c == server.current_client) {
        c->flags |= CLIENT_CLOSE_AFTER_COMMAND;
    } else {
        freeClientAsync(c);
    }
}",1,20,module.c,revokeClientAuthentication,,false,9423,9440,revokeClientAuthentication,,,470,void revokeClientAuthentication (client*)
189303,METHOD,module.c:<global>,TYPE_DECL,"static void moduleFreeAuthenticatedClients(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        if (!c->auth_module) continue;

        RedisModule *auth_module = (RedisModule *) c->auth_module;
        if (auth_module == module) {
            revokeClientAuthentication(c);
        }
    }
}",1,20,module.c,moduleFreeAuthenticatedClients,,false,9445,9458,moduleFreeAuthenticatedClients,,,471,void moduleFreeAuthenticatedClients (RedisModule*)
189356,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleUser *RM_CreateModuleUser(const char *name) {
    RedisModuleUser *new_user = zmalloc(sizeof(RedisModuleUser));
    new_user->user = ACLCreateUnlinkedUser();
    new_user->free_user = 1;

    /* Free the previous temporarily assigned name to assign the new one */
    sdsfree(new_user->user->name);
    new_user->user->name = sdsnew(name);
    return new_user;
}",1,1,module.c,RM_CreateModuleUser,,false,9480,9489,RM_CreateModuleUser,,,472,RedisModuleUser RM_CreateModuleUser (char*)
189393,METHOD,module.c:<global>,TYPE_DECL,"int RM_FreeModuleUser(RedisModuleUser *user) {
    if (user->free_user)
        ACLFreeUserAndKillClients(user->user);
    zfree(user);
    return REDISMODULE_OK;
}",1,11,module.c,RM_FreeModuleUser,,false,9493,9498,RM_FreeModuleUser,,,473,int RM_FreeModuleUser (RedisModuleUser*)
189413,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetModuleUserACL(RedisModuleUser *user, const char* acl) {
    return ACLSetUser(user->user, acl, -1);
}",1,1,module.c,RM_SetModuleUserACL,,false,9507,9509,RM_SetModuleUserACL,,,474,"int RM_SetModuleUserACL (RedisModuleUser*,char*)"
189427,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetModuleUserACLString(RedisModuleCtx *ctx, RedisModuleUser *user, const char *acl, RedisModuleString **error) {
    serverAssert(user != NULL);

    int argc;
    sds *argv = sdssplitargs(acl, &argc);

    sds err = ACLStringSetUser(user->user, NULL, argv, argc);

    sdsfreesplitres(argv, argc);

    if (err) {
        if (error) {
            *error = createObject(OBJ_STRING, err);
            if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, *error);
        } else {
            sdsfree(err);
        }

        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",1,91,module.c,RM_SetModuleUserACLString,,false,9518,9540,RM_SetModuleUserACLString,,,475,"int RM_SetModuleUserACLString (RedisModuleCtx*,RedisModuleUser*,char*,robj**)"
189510,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_GetModuleUserACLString(RedisModuleUser *user) {
    serverAssert(user != NULL);

    return ACLDescribeUser(user->user);
}",1,17,module.c,RM_GetModuleUserACLString,,false,9545,9549,RM_GetModuleUserACLString,,,476,robj RM_GetModuleUserACLString (RedisModuleUser*)
189536,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_GetCurrentUserName(RedisModuleCtx *ctx) {
    return RM_CreateString(ctx,ctx->client->user->name,sdslen(ctx->client->user->name));
}",1,17,module.c,RM_GetCurrentUserName,,false,9557,9559,RM_GetCurrentUserName,,,477,robj RM_GetCurrentUserName (RedisModuleCtx*)
189559,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleUser *RM_GetModuleUserFromUserName(RedisModuleString *name) {
    /* First, verify that the user exist */
    user *acl_user = ACLGetUserByName(name->ptr, sdslen(name->ptr));
    if (acl_user == NULL) {
        return NULL;
    }

    RedisModuleUser *new_user = zmalloc(sizeof(RedisModuleUser));
    new_user->user = acl_user;
    new_user->free_user = 0;
    return new_user;
}",1,46,module.c,RM_GetModuleUserFromUserName,,false,9572,9583,RM_GetModuleUserFromUserName,,,478,RedisModuleUser RM_GetModuleUserFromUserName (robj*)
189600,METHOD,module.c:<global>,TYPE_DECL,"int RM_ACLCheckCommandPermissions(RedisModuleUser *user, RedisModuleString **argv, int argc) {
    int keyidxptr;
    struct redisCommand *cmd;

    /* Find command */
    if ((cmd = lookupCommand(argv, argc)) == NULL) {
        errno = ENOENT;
        return REDISMODULE_ERR;
    }

    if (ACLCheckAllUserCommandPerm(user->user, cmd, argv, argc, &keyidxptr) != ACL_OK) {
        errno = EACCES;
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",1,57,module.c,RM_ACLCheckCommandPermissions,,false,9593,9609,RM_ACLCheckCommandPermissions,,,479,"int RM_ACLCheckCommandPermissions (RedisModuleUser*,robj**,int)"
189651,METHOD,module.c:<global>,TYPE_DECL,"int RM_ACLCheckKeyPermissions(RedisModuleUser *user, RedisModuleString *key, int flags) {
    const int allow_mask = (REDISMODULE_CMD_KEY_ACCESS
        | REDISMODULE_CMD_KEY_INSERT
        | REDISMODULE_CMD_KEY_DELETE
        | REDISMODULE_CMD_KEY_UPDATE);

    if ((flags & allow_mask) != flags) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    int keyspec_flags = moduleConvertKeySpecsFlags(flags, 0);
    if (ACLUserCheckKeyPerm(user->user, key->ptr, sdslen(key->ptr), keyspec_flags) != ACL_OK) {
        errno = EACCES;
        return REDISMODULE_ERR;
    }

    return REDISMODULE_OK;
}",1,53,module.c,RM_ACLCheckKeyPermissions,,false,9626,9644,RM_ACLCheckKeyPermissions,,,480,"int RM_ACLCheckKeyPermissions (RedisModuleUser*,robj*,int)"
189733,METHOD,module.c:<global>,TYPE_DECL,"int RM_ACLCheckChannelPermissions(RedisModuleUser *user, RedisModuleString *ch, int flags) {
    const int allow_mask = (REDISMODULE_CMD_CHANNEL_PUBLISH
        | REDISMODULE_CMD_CHANNEL_SUBSCRIBE
        | REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE
        | REDISMODULE_CMD_CHANNEL_PATTERN);

    if ((flags & allow_mask) != flags) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* Unsubscribe permissions are currently always allowed. */
    if (flags & REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE){
        return REDISMODULE_OK;
    }

    int is_pattern = flags & REDISMODULE_CMD_CHANNEL_PATTERN;
    if (ACLUserCheckChannelPerm(user->user, ch->ptr, is_pattern) != ACL_OK)
        return REDISMODULE_ERR;

    return REDISMODULE_OK;
}",1,57,module.c,RM_ACLCheckChannelPermissions,,false,9656,9677,RM_ACLCheckChannelPermissions,,,481,"int RM_ACLCheckChannelPermissions (RedisModuleUser*,robj*,int)"
189825,METHOD,module.c:<global>,TYPE_DECL,"int moduleGetACLLogEntryReason(RedisModuleACLLogEntryReason reason) {
    int acl_reason = 0;
    switch (reason) {
        case REDISMODULE_ACL_LOG_AUTH: acl_reason = ACL_DENIED_AUTH; break;
        case REDISMODULE_ACL_LOG_KEY: acl_reason = ACL_DENIED_KEY; break;
        case REDISMODULE_ACL_LOG_CHANNEL: acl_reason = ACL_DENIED_CHANNEL; break;
        case REDISMODULE_ACL_LOG_CMD: acl_reason = ACL_DENIED_CMD; break;
        default: break;
    }
    return acl_reason;
}",1,52,module.c,moduleGetACLLogEntryReason,,false,9680,9690,moduleGetACLLogEntryReason,,,482,int moduleGetACLLogEntryReason (RedisModuleACLLogEntryReason)
189873,METHOD,module.c:<global>,TYPE_DECL,"int RM_ACLAddLogEntry(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) {
    int acl_reason = moduleGetACLLogEntryReason(reason);
    if (!acl_reason) return REDISMODULE_ERR;
    addACLLogEntry(ctx->client, acl_reason, ACL_LOG_CTX_MODULE, -1, user->user->name, sdsdup(object->ptr));
    return REDISMODULE_OK;
}",1,66,module.c,RM_ACLAddLogEntry,,false,9696,9701,RM_ACLAddLogEntry,,,483,"int RM_ACLAddLogEntry (RedisModuleCtx*,RedisModuleUser*,robj*,RedisModuleACLLogEntryReason)"
189917,METHOD,module.c:<global>,TYPE_DECL,"int RM_ACLAddLogEntryByUserName(RedisModuleCtx *ctx, RedisModuleString *username, RedisModuleString *object, RedisModuleACLLogEntryReason reason) {
    int acl_reason = moduleGetACLLogEntryReason(reason);
    if (!acl_reason) return REDISMODULE_ERR;
    addACLLogEntry(ctx->client, acl_reason, ACL_LOG_CTX_MODULE, -1, username->ptr, sdsdup(object->ptr));
    return REDISMODULE_OK;
}",1,53,module.c,RM_ACLAddLogEntryByUserName,,false,9707,9712,RM_ACLAddLogEntryByUserName,,,484,"int RM_ACLAddLogEntryByUserName (RedisModuleCtx*,robj*,robj*,RedisModuleACLLogEntryReason)"
189959,METHOD,module.c:<global>,TYPE_DECL,"static int authenticateClientWithUser(RedisModuleCtx *ctx, user *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    if (user->flags & USER_FLAG_DISABLED) {
        return REDISMODULE_ERR;
    }

    /* Avoid settings which are meaningless and will be lost */
    if (!ctx->client || (ctx->client->flags & CLIENT_MODULE)) {
        return REDISMODULE_ERR;
    }

    moduleNotifyUserChanged(ctx->client);

    ctx->client->user = user;
    ctx->client->authenticated = 1;

    if (clientHasModuleAuthInProgress(ctx->client)) {
        ctx->client->flags |= CLIENT_MODULE_AUTH_HAS_RESULT;
    }

    if (callback) {
        ctx->client->auth_callback = callback;
        ctx->client->auth_callback_privdata = privdata;
        ctx->client->auth_module = ctx->module;
    }

    if (client_id) {
        *client_id = ctx->client->id;
    }

    return REDISMODULE_OK;
}",1,22,module.c,authenticateClientWithUser,,false,9734,9764,authenticateClientWithUser,,,485,"int authenticateClientWithUser (RedisModuleCtx*,user*,RedisModuleUserChangedFunc,void*,uint64_t*)"
190089,METHOD,module.c:<global>,TYPE_DECL,"int RM_AuthenticateClientWithUser(RedisModuleCtx *ctx, RedisModuleUser *module_user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    return authenticateClientWithUser(ctx, module_user->user, callback, privdata, client_id);
}",1,1,module.c,RM_AuthenticateClientWithUser,,false,9772,9774,RM_AuthenticateClientWithUser,,,486,"int RM_AuthenticateClientWithUser (RedisModuleCtx*,RedisModuleUser*,RedisModuleUserChangedFunc,void*,uint64_t*)"
190107,METHOD,module.c:<global>,TYPE_DECL,"int RM_AuthenticateClientWithACLUser(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) {
    user *acl_user = ACLGetUserByName(name, len);

    if (!acl_user) {
        return REDISMODULE_ERR;
    }
    return authenticateClientWithUser(ctx, acl_user, callback, privdata, client_id);
}",1,15,module.c,RM_AuthenticateClientWithACLUser,,false,9781,9788,RM_AuthenticateClientWithACLUser,,,487,"int RM_AuthenticateClientWithACLUser (RedisModuleCtx*,char*,size_t,RedisModuleUserChangedFunc,void*,uint64_t*)"
190138,METHOD,module.c:<global>,TYPE_DECL,"int RM_DeauthenticateAndCloseClient(RedisModuleCtx *ctx, uint64_t client_id) {
    UNUSED(ctx);
    client *c = lookupClientByID(client_id);
    if (c == NULL) return REDISMODULE_ERR;

    /* Revoke also marks client to be closed ASAP */
    revokeClientAuthentication(c);
    return REDISMODULE_OK;
}",1,4,module.c,RM_DeauthenticateAndCloseClient,,false,9802,9810,RM_DeauthenticateAndCloseClient,,,488,"int RM_DeauthenticateAndCloseClient (RedisModuleCtx*,uint64_t)"
190170,METHOD,module.c:<global>,TYPE_DECL,"int RM_RedactClientCommandArgument(RedisModuleCtx *ctx, int pos) {
    if (!ctx || !ctx->client || pos <= 0 || ctx->client->argc <= pos) {
        return REDISMODULE_ERR;
    }
    redactClientCommandArgument(ctx->client, pos);
    return REDISMODULE_OK;
}",1,15,module.c,RM_RedactClientCommandArgument,,false,9822,9828,RM_RedactClientCommandArgument,,,489,"int RM_RedactClientCommandArgument (RedisModuleCtx*,int)"
190210,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_GetClientCertificate(RedisModuleCtx *ctx, uint64_t client_id) {
    client *c = lookupClientByID(client_id);
    if (c == NULL) return NULL;

    sds cert = connGetPeerCert(c->conn);
    if (!cert) return NULL;

    RedisModuleString *s = createObject(OBJ_STRING, cert);
    if (ctx != NULL) autoMemoryAdd(ctx, REDISMODULE_AM_STRING, s);

    return s;
}",1,17,module.c,RM_GetClientCertificate,,false,9842,9853,RM_GetClientCertificate,,,490,"robj RM_GetClientCertificate (RedisModuleCtx*,uint64_t)"
190262,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {
    struct RedisModuleDict *d = zmalloc(sizeof(*d));
    d->rax = raxNew();
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);
    return d;
}",1,39,module.c,RM_CreateDict,,false,9876,9881,RM_CreateDict,,,491,RedisModuleDict RM_CreateDict (RedisModuleCtx*)
190292,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);
    raxFree(d->rax);
    zfree(d);
}",1,41,module.c,RM_FreeDict,,false,9886,9890,RM_FreeDict,,,492,"void RM_FreeDict (RedisModuleCtx*,RedisModuleDict*)"
190315,METHOD,module.c:<global>,TYPE_DECL,"uint64_t RM_DictSize(RedisModuleDict *d) {
    return raxSize(d->rax);
}",1,1,module.c,RM_DictSize,,false,9893,9895,RM_DictSize,,,493,uint64_t RM_DictSize (RedisModuleDict*)
190325,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
    int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);
    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,27,module.c,RM_DictSetC,,false,9901,9904,RM_DictSetC,,,494,"int RM_DictSetC (RedisModuleDict*,void*,size_t,void*)"
190355,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {
    int retval = raxInsert(d->rax,key,keylen,ptr,NULL);
    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,27,module.c,RM_DictReplaceC,,false,9908,9911,RM_DictReplaceC,,,495,"int RM_DictReplaceC (RedisModuleDict*,void*,size_t,void*)"
190385,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
    return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);
}",1,35,module.c,RM_DictSet,,false,9914,9916,RM_DictSet,,,496,"int RM_DictSet (RedisModuleDict*,robj*,void*)"
190403,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {
    return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);
}",1,39,module.c,RM_DictReplace,,false,9919,9921,RM_DictReplace,,,497,"int RM_DictReplace (RedisModuleDict*,robj*,void*)"
190421,METHOD,module.c:<global>,TYPE_DECL,"void *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {
    void *res = raxFind(d->rax,key,keylen);
    if (nokey) *nokey = (res == raxNotFound);
    return (res == raxNotFound) ? NULL : res;
}",1,1,module.c,RM_DictGetC,,false,9928,9932,RM_DictGetC,,,498,"void* RM_DictGetC (RedisModuleDict*,void*,size_t,int*)"
190454,METHOD,module.c:<global>,TYPE_DECL,"void *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {
    return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);
}",1,37,module.c,RM_DictGet,,false,9935,9937,RM_DictGet,,,499,"void* RM_DictGet (RedisModuleDict*,robj*,int*)"
190472,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {
    int retval = raxRemove(d->rax,key,keylen,oldval);
    return retval ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,20,module.c,RM_DictDelC,,false,9946,9949,RM_DictDelC,,,500,"int RM_DictDelC (RedisModuleDict*,void*,size_t,void*)"
190499,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {
    return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);
}",1,35,module.c,RM_DictDel,,false,9952,9954,RM_DictDel,,,501,"int RM_DictDel (RedisModuleDict*,robj*,void*)"
190517,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {
    RedisModuleDictIter *di = zmalloc(sizeof(*di));
    di->dict = d;
    raxStart(&di->ri,d->rax);
    raxSeek(&di->ri,op,key,keylen);
    return di;
}",1,1,module.c,RM_DictIteratorStartC,,false,9976,9982,RM_DictIteratorStartC,,,502,"RedisModuleDictIter RM_DictIteratorStartC (RedisModuleDict*,char*,void*,size_t)"
190555,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {
    return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));
}",1,78,module.c,RM_DictIteratorStart,,false,9986,9988,RM_DictIteratorStart,,,503,"RedisModuleDictIter RM_DictIteratorStart (RedisModuleDict*,char*,robj*)"
190573,METHOD,module.c:<global>,TYPE_DECL,"void RM_DictIteratorStop(RedisModuleDictIter *di) {
    raxStop(&di->ri);
    zfree(di);
}",1,1,module.c,RM_DictIteratorStop,,false,9992,9995,RM_DictIteratorStop,,,504,void RM_DictIteratorStop (RedisModuleDictIter*)
190585,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
    return raxSeek(&di->ri,op,key,keylen);
}",1,1,module.c,RM_DictIteratorReseekC,,false,10004,10006,RM_DictIteratorReseekC,,,505,"int RM_DictIteratorReseekC (RedisModuleDictIter*,char*,void*,size_t)"
190602,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
    return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));
}",1,67,module.c,RM_DictIteratorReseek,,false,10010,10012,RM_DictIteratorReseek,,,506,"int RM_DictIteratorReseek (RedisModuleDictIter*,char*,robj*)"
190620,METHOD,module.c:<global>,TYPE_DECL,"void *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
    if (!raxNext(&di->ri)) return NULL;
    if (keylen) *keylen = di->ri.key_len;
    if (dataptr) *dataptr = di->ri.data;
    return di->ri.key;
}",1,1,module.c,RM_DictNextC,,false,10039,10044,RM_DictNextC,,,507,"void* RM_DictNextC (RedisModuleDictIter*,size_t*,void**)"
190665,METHOD,module.c:<global>,TYPE_DECL,"void *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {
    if (!raxPrev(&di->ri)) return NULL;
    if (keylen) *keylen = di->ri.key_len;
    if (dataptr) *dataptr = di->ri.data;
    return di->ri.key;
}",1,1,module.c,RM_DictPrevC,,false,10049,10054,RM_DictPrevC,,,508,"void* RM_DictPrevC (RedisModuleDictIter*,size_t*,void**)"
190710,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
    size_t keylen;
    void *key = RM_DictNextC(di,&keylen,dataptr);
    if (key == NULL) return NULL;
    return RM_CreateString(ctx,key,keylen);
}",1,17,module.c,RM_DictNext,,false,10063,10068,RM_DictNext,,,509,"robj RM_DictNext (RedisModuleCtx*,RedisModuleDictIter*,void**)"
190738,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {
    size_t keylen;
    void *key = RM_DictPrevC(di,&keylen,dataptr);
    if (key == NULL) return NULL;
    return RM_CreateString(ctx,key,keylen);
}",1,17,module.c,RM_DictPrev,,false,10073,10078,RM_DictPrev,,,510,"robj RM_DictPrev (RedisModuleCtx*,RedisModuleDictIter*,void**)"
190766,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {
    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
    int res = raxCompare(&di->ri,op,key,keylen);
    return res ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,32,module.c,RM_DictCompareC,,false,10092,10096,RM_DictCompareC,,,511,"int RM_DictCompareC (RedisModuleDictIter*,char*,void*,size_t)"
190805,METHOD,module.c:<global>,TYPE_DECL,"int RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {
    if (raxEOF(&di->ri)) return REDISMODULE_ERR;
    int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));
    return res ? REDISMODULE_OK : REDISMODULE_ERR;
}",1,60,module.c,RM_DictCompare,,false,10100,10104,RM_DictCompare,,,512,"int RM_DictCompare (RedisModuleDictIter*,char*,robj*)"
190848,METHOD,module.c:<global>,TYPE_DECL,int RM_InfoEndDictField(RedisModuleInfoCtx *ctx);,5,48,module.c,RM_InfoEndDictField,,false,10113,10113,RM_InfoEndDictField,,,513,int RM_InfoEndDictField (RedisModuleInfoCtx*)
190853,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoAddSection(RedisModuleInfoCtx *ctx, const char *name) {
    sds full_name = sdsdup(ctx->module->name);
    if (name != NULL && strlen(name) > 0)
        full_name = sdscatfmt(full_name, ""_%s"", name);

    /* Implicitly end dicts, instead of returning an error which is likely un checked. */
    if (ctx->in_dict_field)
        RM_InfoEndDictField(ctx);

    /* proceed only if:
     * 1) no section was requested (emit all)
     * 2) the module name was requested (emit all)
     * 3) this specific section was requested. */
    if (ctx->requested_sections) {
        if ((!full_name || !dictFind(ctx->requested_sections, full_name)) &&
            (!dictFind(ctx->requested_sections, ctx->module->name)))
        {
            sdsfree(full_name);
            ctx->in_section = 0;
            return REDISMODULE_ERR;
        }
    }
    if (ctx->sections++) ctx->info = sdscat(ctx->info,""\r\n"");
    ctx->info = sdscatfmt(ctx->info, ""# %S\r\n"", full_name);
    ctx->in_section = 1;
    ...",1,19,module.c,RM_InfoAddSection,,false,10119,10146,RM_InfoAddSection,,,514,"int RM_InfoAddSection (RedisModuleInfoCtx*,char*)"
190965,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoBeginDictField(RedisModuleInfoCtx *ctx, const char *name) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    /* Implicitly end dicts, instead of returning an error which is likely un checked. */
    if (ctx->in_dict_field)
        RM_InfoEndDictField(ctx);
    char *tmpmodname, *tmpname;
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:"",
        getSafeInfoString(ctx->module->name, strlen(ctx->module->name), &tmpmodname),
        getSafeInfoString(name, strlen(name), &tmpname));
    if (tmpmodname != NULL) zfree(tmpmodname);
    if (tmpname != NULL) zfree(tmpname);
    ctx->in_dict_field = 1;
    return REDISMODULE_OK;
}",1,15,module.c,RM_InfoBeginDictField,,false,10151,10166,RM_InfoBeginDictField,,,515,"int RM_InfoBeginDictField (RedisModuleInfoCtx*,char*)"
191042,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoEndDictField(RedisModuleInfoCtx *ctx) {
    if (!ctx->in_dict_field)
        return REDISMODULE_ERR;
    /* trim the last ',' if found. */
    if (ctx->info[sdslen(ctx->info)-1]==',')
        sdsIncrLen(ctx->info, -1);
    ctx->info = sdscat(ctx->info, ""\r\n"");
    ctx->in_dict_field = 0;
    return REDISMODULE_OK;
}",1,15,module.c,RM_InfoEndDictField,,false,10169,10178,RM_InfoEndDictField,,,516,int RM_InfoEndDictField (RedisModuleInfoCtx*)
191095,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoAddFieldString(RedisModuleInfoCtx *ctx, const char *field, RedisModuleString *value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%S,"",
            field,
            (sds)value->ptr);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%S\r\n"",
        ctx->module->name,
        field,
        (sds)value->ptr);
    return REDISMODULE_OK;
}",1,70,module.c,RM_InfoAddFieldString,,false,10183,10199,RM_InfoAddFieldString,,,517,"int RM_InfoAddFieldString (RedisModuleInfoCtx*,char*,robj*)"
191160,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoAddFieldCString(RedisModuleInfoCtx *ctx, const char *field, const char *value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%s,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%s\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",1,15,module.c,RM_InfoAddFieldCString,,false,10202,10218,RM_InfoAddFieldCString,,,518,"int RM_InfoAddFieldCString (RedisModuleInfoCtx*,char*,char*)"
191217,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoAddFieldDouble(RedisModuleInfoCtx *ctx, const char *field, double value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatprintf(ctx->info,
            ""%s=%.17g,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatprintf(ctx->info,
        ""%s_%s:%.17g\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",1,15,module.c,RM_InfoAddFieldDouble,,false,10221,10237,RM_InfoAddFieldDouble,,,519,"int RM_InfoAddFieldDouble (RedisModuleInfoCtx*,char*,double)"
191274,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoAddFieldLongLong(RedisModuleInfoCtx *ctx, const char *field, long long value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%I,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%I\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",1,15,module.c,RM_InfoAddFieldLongLong,,false,10240,10256,RM_InfoAddFieldLongLong,,,520,"int RM_InfoAddFieldLongLong (RedisModuleInfoCtx*,char*,long long)"
191331,METHOD,module.c:<global>,TYPE_DECL,"int RM_InfoAddFieldULongLong(RedisModuleInfoCtx *ctx, const char *field, unsigned long long value) {
    if (!ctx->in_section)
        return REDISMODULE_ERR;
    if (ctx->in_dict_field) {
        ctx->info = sdscatfmt(ctx->info,
            ""%s=%U,"",
            field,
            value);
        return REDISMODULE_OK;
    }
    ctx->info = sdscatfmt(ctx->info,
        ""%s_%s:%U\r\n"",
        ctx->module->name,
        field,
        value);
    return REDISMODULE_OK;
}",1,15,module.c,RM_InfoAddFieldULongLong,,false,10259,10275,RM_InfoAddFieldULongLong,,,521,"int RM_InfoAddFieldULongLong (RedisModuleInfoCtx*,char*,long long unsigned)"
191388,METHOD,module.c:<global>,TYPE_DECL,"int RM_RegisterInfoFunc(RedisModuleCtx *ctx, RedisModuleInfoFunc cb) {
    ctx->module->info_cb = cb;
    return REDISMODULE_OK;
}",1,11,module.c,RM_RegisterInfoFunc,,false,10279,10282,RM_RegisterInfoFunc,,,522,"int RM_RegisterInfoFunc (RedisModuleCtx*,RedisModuleInfoFunc)"
191405,METHOD,module.c:<global>,TYPE_DECL,"sds modulesCollectInfo(sds info, dict *sections_dict, int for_crash_report, int sections) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!module->info_cb)
            continue;
        RedisModuleInfoCtx info_ctx = {module, sections_dict, info, sections, 0, 0};
        module->info_cb(&info_ctx, for_crash_report);
        /* Implicitly end dicts (no way to handle errors, and we must add the newline). */
        if (info_ctx.in_dict_field)
            RM_InfoEndDictField(&info_ctx);
        info = info_ctx.info;
        sections = info_ctx.sections;
    }
    dictReleaseIterator(di);
    return info;
}",1,1,module.c,modulesCollectInfo,,false,10284,10302,modulesCollectInfo,,,523,"sds modulesCollectInfo (sds,dict*,int,int)"
191478,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleServerInfoData *RM_GetServerInfo(RedisModuleCtx *ctx, const char *section) {
    struct RedisModuleServerInfoData *d = zmalloc(sizeof(*d));
    d->rax = raxNew();
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_INFO,d);
    int all = 0, everything = 0;
    robj *argv[1];
    argv[0] = section ? createStringObject(section, strlen(section)) : NULL;
    dict *section_dict = genInfoSectionDict(argv, section ? 1 : 0, NULL, &all, &everything);
    sds info = genRedisInfoString(section_dict, all, everything);
    int totlines, i;
    sds *lines = sdssplitlen(info, sdslen(info), ""\r\n"", 2, &totlines);
    for(i=0; i<totlines; i++) {
        sds line = lines[i];
        if (line[0]=='#') continue;
        char *sep = strchr(line, ':');
        if (!sep) continue;
        unsigned char *key = (unsigned char*)line;
        size_t keylen = (intptr_t)sep-(intptr_t)line;
        sds val = sdsnewlen(sep+1,sdslen(line)-((intptr_t)sep-(intptr_t)line)-1);
        if (!raxTryInsert(d-...",1,39,module.c,RM_GetServerInfo,,false,10310,10337,RM_GetServerInfo,,,524,"RedisModuleServerInfoData RM_GetServerInfo (RedisModuleCtx*,char*)"
191663,METHOD,module.c:<global>,TYPE_DECL,"void RM_FreeServerInfo(RedisModuleCtx *ctx, RedisModuleServerInfoData *data) {
    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_INFO,data);
    raxFreeWithCallback(data->rax, (void(*)(void*))sdsfree);
    zfree(data);
}",1,41,module.c,RM_FreeServerInfo,,false,10342,10346,RM_FreeServerInfo,,,525,"void RM_FreeServerInfo (RedisModuleCtx*,RedisModuleServerInfoData*)"
191689,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_ServerInfoGetField(RedisModuleCtx *ctx, RedisModuleServerInfoData *data, const char* field) {
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) return NULL;
    RedisModuleString *o = createStringObject(val,sdslen(val));
    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);
    return o;
}",1,17,module.c,RM_ServerInfoGetField,,false,10352,10358,RM_ServerInfoGetField,,,526,"robj RM_ServerInfoGetField (RedisModuleCtx*,RedisModuleServerInfoData*,char*)"
191737,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_ServerInfoGetFieldC(RedisModuleServerInfoData *data, const char* field) {
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) return NULL;
    return val;
}",1,1,module.c,RM_ServerInfoGetFieldC,,false,10361,10365,RM_ServerInfoGetFieldC,,,527,"const char* RM_ServerInfoGetFieldC (RedisModuleServerInfoData*,char*)"
191764,METHOD,module.c:<global>,TYPE_DECL,"long long RM_ServerInfoGetFieldSigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    long long ll;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2ll(val,sdslen(val),&ll)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return ll;
}",1,32,module.c,RM_ServerInfoGetFieldSigned,,false,10370,10383,RM_ServerInfoGetFieldSigned,,,528,"long long RM_ServerInfoGetFieldSigned (RedisModuleServerInfoData*,char*,int*)"
191831,METHOD,module.c:<global>,TYPE_DECL,"unsigned long long RM_ServerInfoGetFieldUnsigned(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    unsigned long long ll;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2ull(val,&ll)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return ll;
}",1,32,module.c,RM_ServerInfoGetFieldUnsigned,,false,10388,10401,RM_ServerInfoGetFieldUnsigned,,,529,"unsigned long long RM_ServerInfoGetFieldUnsigned (RedisModuleServerInfoData*,char*,int*)"
191896,METHOD,module.c:<global>,TYPE_DECL,"double RM_ServerInfoGetFieldDouble(RedisModuleServerInfoData *data, const char* field, int *out_err) {
    double dbl;
    sds val = raxFind(data->rax, (unsigned char *)field, strlen(field));
    if (val == raxNotFound) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (!string2d(val,sdslen(val),&dbl)) {
        if (out_err) *out_err = REDISMODULE_ERR;
        return 0;
    }
    if (out_err) *out_err = REDISMODULE_OK;
    return dbl;
}",1,32,module.c,RM_ServerInfoGetFieldDouble,,false,10406,10419,RM_ServerInfoGetFieldDouble,,,530,"double RM_ServerInfoGetFieldDouble (RedisModuleServerInfoData*,char*,int*)"
191963,METHOD,module.c:<global>,TYPE_DECL,"void RM_GetRandomBytes(unsigned char *dst, size_t len) {
    getRandomBytes(dst,len);
}",1,1,module.c,RM_GetRandomBytes,,false,10429,10431,RM_GetRandomBytes,,,531,"void RM_GetRandomBytes (unsigned char*,size_t)"
191972,METHOD,module.c:<global>,TYPE_DECL,"void RM_GetRandomHexChars(char *dst, size_t len) {
    getRandomHexChars(dst,len);
}",1,1,module.c,RM_GetRandomHexChars,,false,10436,10438,RM_GetRandomHexChars,,,532,"void RM_GetRandomHexChars (char*,size_t)"
191981,METHOD,module.c:<global>,TYPE_DECL,"int RM_ExportSharedAPI(RedisModuleCtx *ctx, const char *apiname, void *func) {
    RedisModuleSharedAPI *sapi = zmalloc(sizeof(*sapi));
    sapi->module = ctx->module;
    sapi->func = func;
    if (dictAdd(server.sharedapi, (char*)apiname, sapi) != DICT_OK) {
        zfree(sapi);
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",1,59,module.c,RM_ExportSharedAPI,,false,10456,10465,RM_ExportSharedAPI,,,533,"int RM_ExportSharedAPI (RedisModuleCtx*,char*,void*)"
192031,METHOD,module.c:<global>,TYPE_DECL,"void *RM_GetSharedAPI(RedisModuleCtx *ctx, const char *apiname) {
    dictEntry *de = dictFind(server.sharedapi, apiname);
    if (de == NULL) return NULL;
    RedisModuleSharedAPI *sapi = dictGetVal(de);
    if (listSearchKey(sapi->module->usedby,ctx->module) == NULL) {
        listAddNodeTail(sapi->module->usedby,ctx->module);
        listAddNodeTail(ctx->module->using,sapi->module);
    }
    return sapi->func;
}",1,1,module.c,RM_GetSharedAPI,,false,10500,10509,RM_GetSharedAPI,,,534,"void* RM_GetSharedAPI (RedisModuleCtx*,char*)"
192092,METHOD,module.c:<global>,TYPE_DECL,"int moduleUnregisterSharedAPI(RedisModule *module) {
    int count = 0;
    dictIterator *di = dictGetSafeIterator(server.sharedapi);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        const char *apiname = dictGetKey(de);
        RedisModuleSharedAPI *sapi = dictGetVal(de);
        if (sapi->module == module) {
            dictDelete(server.sharedapi,apiname);
            zfree(sapi);
            count++;
        }
    }
    dictReleaseIterator(di);
    return count;
}",1,1,module.c,moduleUnregisterSharedAPI,,false,10517,10532,moduleUnregisterSharedAPI,,,535,int moduleUnregisterSharedAPI (RedisModule*)
192147,METHOD,module.c:<global>,TYPE_DECL,"int moduleUnregisterUsedAPI(RedisModule *module) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(module->using,&li);
    while((ln = listNext(&li))) {
        RedisModule *used = ln->value;
        listNode *ln = listSearchKey(used->usedby,module);
        if (ln) {
            listDelNode(used->usedby,ln);
            count++;
        }
    }
    return count;
}",1,1,module.c,moduleUnregisterUsedAPI,,false,10538,10553,moduleUnregisterUsedAPI,,,536,int moduleUnregisterUsedAPI (RedisModule*)
192197,METHOD,module.c:<global>,TYPE_DECL,"int moduleUnregisterFilters(RedisModule *module) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(module->filters,&li);
    while((ln = listNext(&li))) {
        RedisModuleCommandFilter *filter = ln->value;
        listNode *ln = listSearchKey(moduleCommandFilters,filter);
        if (ln) {
            listDelNode(moduleCommandFilters,ln);
            count++;
        }
        zfree(filter);
    }
    return count;
}",1,1,module.c,moduleUnregisterFilters,,false,10559,10575,moduleUnregisterFilters,,,537,int moduleUnregisterFilters (RedisModule*)
192245,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleCommandFilter *RM_RegisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc callback, int flags) {
    RedisModuleCommandFilter *filter = zmalloc(sizeof(*filter));
    filter->module = ctx->module;
    filter->callback = callback;
    filter->flags = flags;

    listAddNodeTail(moduleCommandFilters, filter);
    listAddNodeTail(ctx->module->filters, filter);
    return filter;
}",1,1,module.c,RM_RegisterCommandFilter,,false,10632,10641,RM_RegisterCommandFilter,,,538,"RedisModuleCommandFilter RM_RegisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilterFunc,int)"
192288,METHOD,module.c:<global>,TYPE_DECL,"int RM_UnregisterCommandFilter(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) {
    listNode *ln;

    /* A module can only remove its own filters */
    if (filter->module != ctx->module) return REDISMODULE_ERR;

    ln = listSearchKey(moduleCommandFilters,filter);
    if (!ln) return REDISMODULE_ERR;
    listDelNode(moduleCommandFilters,ln);

    ln = listSearchKey(ctx->module->filters,filter);
    if (!ln) return REDISMODULE_ERR;    /* Shouldn't happen */
    listDelNode(ctx->module->filters,ln);

    zfree(filter);

    return REDISMODULE_OK;
}",1,46,module.c,RM_UnregisterCommandFilter,,false,10645,10662,RM_UnregisterCommandFilter,,,539,"int RM_UnregisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilter*)"
192354,METHOD,module.c:<global>,TYPE_DECL,"void moduleCallCommandFilters(client *c) {
    if (listLength(moduleCommandFilters) == 0) return;

    listIter li;
    listNode *ln;
    listRewind(moduleCommandFilters,&li);

    RedisModuleCommandFilterCtx filter = {
        .argv = c->argv,
        .argv_len = c->argv_len,
        .argc = c->argc,
        .c = c
    };

    while((ln = listNext(&li))) {
        RedisModuleCommandFilter *f = ln->value;

        /* Skip filter if REDISMODULE_CMDFILTER_NOSELF is set and module is
         * currently processing a command.
         */
        if ((f->flags & REDISMODULE_CMDFILTER_NOSELF) && f->module->in_call) continue;

        /* Call filter */
        f->callback(&filter);
    }

    c->argv = filter.argv;
    c->argv_len = filter.argv_len;
    c->argc = filter.argc;
}",1,8,module.c,moduleCallCommandFilters,,false,10664,10693,moduleCallCommandFilters,,,540,void moduleCallCommandFilters (client*)
192460,METHOD,module.c:<global>,TYPE_DECL,"int RM_CommandFilterArgsCount(RedisModuleCommandFilterCtx *fctx)
{
    return fctx->argc;
}",1,1,module.c,RM_CommandFilterArgsCount,,false,10698,10701,RM_CommandFilterArgsCount,,,541,int RM_CommandFilterArgsCount (RedisModuleCommandFilterCtx*)
192469,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_CommandFilterArgGet(RedisModuleCommandFilterCtx *fctx, int pos)
{
    if (pos < 0 || pos >= fctx->argc) return NULL;
    return fctx->argv[pos];
}",1,17,module.c,RM_CommandFilterArgGet,,false,10706,10710,RM_CommandFilterArgGet,,,542,"robj RM_CommandFilterArgGet (RedisModuleCommandFilterCtx*,int)"
192494,METHOD,module.c:<global>,TYPE_DECL,"int RM_CommandFilterArgInsert(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
{
    int i;

    if (pos < 0 || pos > fctx->argc) return REDISMODULE_ERR;

    if (fctx->argv_len < fctx->argc+1) {
        fctx->argv_len = fctx->argc+1;
        fctx->argv = zrealloc(fctx->argv, fctx->argv_len*sizeof(RedisModuleString *));
    }
    for (i = fctx->argc; i > pos; i--) {
        fctx->argv[i] = fctx->argv[i-1];
    }
    fctx->argv[pos] = arg;
    fctx->argc++;

    return REDISMODULE_OK;
}",1,74,module.c,RM_CommandFilterArgInsert,,false,10717,10734,RM_CommandFilterArgInsert,,,543,"int RM_CommandFilterArgInsert (RedisModuleCommandFilterCtx*,int,robj*)"
192592,METHOD,module.c:<global>,TYPE_DECL,"int RM_CommandFilterArgReplace(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg)
{
    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;

    decrRefCount(fctx->argv[pos]);
    fctx->argv[pos] = arg;

    return REDISMODULE_OK;
}",1,75,module.c,RM_CommandFilterArgReplace,,false,10741,10749,RM_CommandFilterArgReplace,,,544,"int RM_CommandFilterArgReplace (RedisModuleCommandFilterCtx*,int,robj*)"
192631,METHOD,module.c:<global>,TYPE_DECL,"int RM_CommandFilterArgDelete(RedisModuleCommandFilterCtx *fctx, int pos)
{
    int i;
    if (pos < 0 || pos >= fctx->argc) return REDISMODULE_ERR;

    decrRefCount(fctx->argv[pos]);
    for (i = pos; i < fctx->argc-1; i++) {
        fctx->argv[i] = fctx->argv[i+1];
    }
    fctx->argc--;

    return REDISMODULE_OK;
}",1,45,module.c,RM_CommandFilterArgDelete,,false,10754,10766,RM_CommandFilterArgDelete,,,545,"int RM_CommandFilterArgDelete (RedisModuleCommandFilterCtx*,int)"
192695,METHOD,module.c:<global>,TYPE_DECL,"unsigned long long RM_CommandFilterGetClientId(RedisModuleCommandFilterCtx *fctx) {
    return fctx->c->id;
}",1,1,module.c,RM_CommandFilterGetClientId,,false,10769,10771,RM_CommandFilterGetClientId,,,546,unsigned long long RM_CommandFilterGetClientId (RedisModuleCommandFilterCtx*)
192706,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_MallocSize(void* ptr) {
    return zmalloc_size(ptr);
}",1,1,module.c,RM_MallocSize,,false,10779,10781,RM_MallocSize,,,547,size_t RM_MallocSize (void*)
192714,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_MallocUsableSize(void *ptr) {
    /* It is safe to use 'zmalloc_usable_size()' to manipulate additional
     * memory space, as we guarantee that the compiler can recognize this
     * after 'RM_Alloc', 'RM_TryAlloc', 'RM_Realloc', or 'RM_Calloc'. */
    return zmalloc_usable_size(ptr);
}",1,1,module.c,RM_MallocUsableSize,,false,10785,10790,RM_MallocUsableSize,,,548,size_t RM_MallocUsableSize (void*)
192722,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_MallocSizeString(RedisModuleString* str) {
    serverAssert(str->type == OBJ_STRING);
    return sizeof(*str) + getStringObjectSdsUsedMemory(str);
}",1,27,module.c,RM_MallocSizeString,,false,10794,10797,RM_MallocSizeString,,,549,size_t RM_MallocSizeString (robj*)
192752,METHOD,module.c:<global>,TYPE_DECL,"size_t RM_MallocSizeDict(RedisModuleDict* dict) {
    size_t size = sizeof(RedisModuleDict) + sizeof(rax);
    size += dict->rax->numnodes * sizeof(raxNode);
    /* For more info about this weird line, see streamRadixTreeMemoryUsage */
    size += dict->rax->numnodes * sizeof(long)*30;
    return size;
}",1,1,module.c,RM_MallocSizeDict,,false,10803,10809,RM_MallocSizeDict,,,550,size_t RM_MallocSizeDict (RedisModuleDict*)
192789,METHOD,module.c:<global>,TYPE_DECL,"float RM_GetUsedMemoryRatio(void){
    float level;
    getMaxmemoryState(NULL, NULL, NULL, &level);
    return level;
}",1,1,module.c,RM_GetUsedMemoryRatio,,false,10819,10823,RM_GetUsedMemoryRatio,,,551,float RM_GetUsedMemoryRatio (void)
192803,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModuleScanCB)(RedisModuleCtx *ctx, RedisModuleString *keyname, RedisModuleKey *key, void *privdata);",14,55,module.c,RedisModuleScanCB,,false,10829,10829,RedisModuleScanCB,,,552,"void RedisModuleScanCB (RedisModuleCtx*,robj*,RedisModuleKey*,void*)"
192820,METHOD,module.c:<global>,TYPE_DECL,"static void moduleScanCallback(void *privdata, const dictEntry *de) {
    ScanCBData *data = privdata;
    sds key = dictGetKey(de);
    robj* val = dictGetVal(de);
    RedisModuleString *keyname = createObject(OBJ_STRING,sdsdup(key));

    /* Setup the key handle. */
    RedisModuleKey kp = {0};
    moduleInitKey(&kp, data->ctx, keyname, val, REDISMODULE_READ);

    data->fn(data->ctx, keyname, &kp, data->user_data);

    moduleCloseKey(&kp);
    decrRefCount(keyname);
}",1,4,module.c,moduleScanCallback,,false,10841,10855,moduleScanCallback,,,557,"void moduleScanCallback (void*,dictEntry*)"
192885,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleScanCursor *RM_ScanCursorCreate(void) {
    RedisModuleScanCursor* cursor = zmalloc(sizeof(*cursor));
    cursor->cursor = 0;
    cursor->done = 0;
    return cursor;
}",1,1,module.c,RM_ScanCursorCreate,,false,10858,10863,RM_ScanCursorCreate,,,558,RedisModuleScanCursor RM_ScanCursorCreate (void)
192909,METHOD,module.c:<global>,TYPE_DECL,"void RM_ScanCursorRestart(RedisModuleScanCursor *cursor) {
    cursor->cursor = 0;
    cursor->done = 0;
}",1,1,module.c,RM_ScanCursorRestart,,false,10866,10869,RM_ScanCursorRestart,,,559,void RM_ScanCursorRestart (RedisModuleScanCursor*)
192924,METHOD,module.c:<global>,TYPE_DECL,"void RM_ScanCursorDestroy(RedisModuleScanCursor *cursor) {
    zfree(cursor);
}",1,1,module.c,RM_ScanCursorDestroy,,false,10872,10874,RM_ScanCursorDestroy,,,560,void RM_ScanCursorDestroy (RedisModuleScanCursor*)
192931,METHOD,module.c:<global>,TYPE_DECL,"int RM_Scan(RedisModuleCtx *ctx, RedisModuleScanCursor *cursor, RedisModuleScanCB fn, void *privdata) {
    if (cursor->done) {
        errno = ENOENT;
        return 0;
    }
    int ret = 1;
    ScanCBData data = { ctx, privdata, fn };
    cursor->cursor = dictScan(ctx->client->db->dict, cursor->cursor, moduleScanCallback, &data);
    if (cursor->cursor == 0) {
        cursor->done = 1;
        ret = 0;
    }
    errno = 0;
    return ret;
}",1,1,module.c,RM_Scan,,false,10932,10946,RM_Scan,,,561,"int RM_Scan (RedisModuleCtx*,RedisModuleScanCursor*,RedisModuleScanCB,void*)"
192998,METHOD,module.c:<global>,TYPE_DECL,"typedef void (*RedisModuleScanKeyCB)(RedisModuleKey *key, RedisModuleString *field, RedisModuleString *value, void *privdata);",14,58,module.c,RedisModuleScanKeyCB,,false,10948,10948,RedisModuleScanKeyCB,,,562,"void RedisModuleScanKeyCB (RedisModuleKey*,robj*,robj*,void*)"
193011,METHOD,module.c:<global>,TYPE_DECL,"static void moduleScanKeyCallback(void *privdata, const dictEntry *de) {
    ScanKeyCBData *data = privdata;
    sds key = dictGetKey(de);
    robj *o = data->key->value;
    robj *field = createStringObject(key, sdslen(key));
    robj *value = NULL;
    if (o->type == OBJ_SET) {
        value = NULL;
    } else if (o->type == OBJ_HASH) {
        sds val = dictGetVal(de);
        value = createStringObject(val, sdslen(val));
    } else if (o->type == OBJ_ZSET) {
        double *val = (double*)dictGetVal(de);
        value = createStringObjectFromLongDouble(*val, 0);
    }

    data->fn(data->key, field, value, data->user_data);
    decrRefCount(field);
    if (value) decrRefCount(value);
}",1,19,module.c,moduleScanKeyCallback,,false,10955,10974,moduleScanKeyCallback,,,565,"void moduleScanKeyCallback (void*,dictEntry*)"
193122,METHOD,module.c:<global>,TYPE_DECL,"int RM_ScanKey(RedisModuleKey *key, RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, void *privdata) {
    if (key == NULL || key->value == NULL) {
        errno = EINVAL;
        return 0;
    }
    dict *ht = NULL;
    robj *o = key->value;
    if (o->type == OBJ_SET) {
        if (o->encoding == OBJ_ENCODING_HT)
            ht = o->ptr;
    } else if (o->type == OBJ_HASH) {
        if (o->encoding == OBJ_ENCODING_HT)
            ht = o->ptr;
    } else if (o->type == OBJ_ZSET) {
        if (o->encoding == OBJ_ENCODING_SKIPLIST)
            ht = ((zset *)o->ptr)->dict;
    } else {
        errno = EINVAL;
        return 0;
    }
    if (cursor->done) {
        errno = ENOENT;
        return 0;
    }
    int ret = 1;
    if (ht) {
        ScanKeyCBData data = { key, privdata, fn };
        cursor->cursor = dictScan(ht, cursor->cursor, moduleScanKeyCallback, &data);
        if (cursor->cursor == 0) {
            cursor->done = 1;
            ret = 0;
        }
    } else if (...",1,19,module.c,RM_ScanKey,,false,11024,11094,RM_ScanKey,,,566,"int RM_ScanKey (RedisModuleKey*,RedisModuleScanCursor*,RedisModuleScanKeyCB,void*)"
193464,METHOD,module.c:<global>,TYPE_DECL,"int RM_Fork(RedisModuleForkDoneHandler cb, void *user_data) {
    pid_t childpid;

    if ((childpid = redisFork(CHILD_TYPE_MODULE)) == 0) {
        /* Child */
        redisSetProcTitle(""redis-module-fork"");
    } else if (childpid == -1) {
        serverLog(LL_WARNING,""Can't fork for module: %s"", strerror(errno));
    } else {
        /* Parent */
        moduleForkInfo.done_handler = cb;
        moduleForkInfo.done_handler_user_data = user_data;
        serverLog(LL_VERBOSE, ""Module fork started pid: %ld "", (long) childpid);
    }
    return childpid;
}",1,30,module.c,RM_Fork,,false,11112,11127,RM_Fork,,,567,"int RM_Fork (RedisModuleForkDoneHandler,void*)"
193546,METHOD,module.c:<global>,TYPE_DECL,"void RM_SendChildHeartbeat(double progress) {
    sendChildInfoGeneric(CHILD_INFO_TYPE_CURRENT_INFO, 0, progress, ""Module fork"");
}",1,1,module.c,RM_SendChildHeartbeat,,false,11133,11135,RM_SendChildHeartbeat,,,568,void RM_SendChildHeartbeat (double)
193556,METHOD,module.c:<global>,TYPE_DECL,"int RM_ExitFromChild(int retcode) {
    sendChildCowInfo(CHILD_INFO_TYPE_MODULE_COW_SIZE, ""Module fork"");
    exitFromChild(retcode);
    return REDISMODULE_OK;
}",1,11,module.c,RM_ExitFromChild,,false,11140,11144,RM_ExitFromChild,,,569,int RM_ExitFromChild (int)
193570,METHOD,module.c:<global>,TYPE_DECL,"int TerminateModuleForkChild(int child_pid, int wait) {
    /* Module child should be active and pid should match. */
    if (server.child_type != CHILD_TYPE_MODULE ||
        server.child_pid != child_pid) return C_ERR;

    int statloc;
    serverLog(LL_VERBOSE,""Killing running module fork child: %ld"",
        (long) server.child_pid);
    if (kill(server.child_pid,SIGUSR1) != -1 && wait) {
        while(waitpid(server.child_pid, &statloc, 0) !=
              server.child_pid);
    }
    /* Reset the buffer accumulating changes while the child saves. */
    resetChildState();
    moduleForkInfo.done_handler = NULL;
    moduleForkInfo.done_handler_user_data = NULL;
    return C_OK;
}",1,29,module.c,TerminateModuleForkChild,,false,11149,11166,TerminateModuleForkChild,,,570,"int TerminateModuleForkChild (int,int)"
193659,METHOD,module.c:<global>,TYPE_DECL,"int RM_KillForkChild(int child_pid) {
    /* Kill module child, wait for child exit. */
    if (TerminateModuleForkChild(child_pid,1) == C_OK)
        return REDISMODULE_OK;
    else
        return REDISMODULE_ERR;
}",1,49,module.c,RM_KillForkChild,,false,11170,11176,RM_KillForkChild,,,571,int RM_KillForkChild (int)
193683,METHOD,module.c:<global>,TYPE_DECL,"void ModuleForkDoneHandler(int exitcode, int bysignal) {
    serverLog(LL_NOTICE,
        ""Module fork exited pid: %ld, retcode: %d, bysignal: %d"",
        (long) server.child_pid, exitcode, bysignal);
    if (moduleForkInfo.done_handler) {
        moduleForkInfo.done_handler(exitcode, bysignal,
            moduleForkInfo.done_handler_user_data);
    }

    moduleForkInfo.done_handler = NULL;
    moduleForkInfo.done_handler_user_data = NULL;
}",1,4,module.c,ModuleForkDoneHandler,,false,11178,11189,ModuleForkDoneHandler,,,572,"void ModuleForkDoneHandler (int,int)"
193786,METHOD,module.c:<global>,TYPE_DECL,"int RM_SubscribeToServerEvent(RedisModuleCtx *ctx, RedisModuleEvent event, RedisModuleEventCallback callback) {
    RedisModuleEventListener *el;

    /* Protect in case of calls from contexts without a module reference. */
    if (ctx->module == NULL) return REDISMODULE_ERR;
    if (event.id >= _REDISMODULE_EVENT_NEXT) return REDISMODULE_ERR;
    if (event.dataver > moduleEventVersions[event.id]) return REDISMODULE_ERR; /* Module compiled with a newer redismodule.h than we support */

    /* Search an event matching this module and event ID. */
    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);
    while((ln = listNext(&li))) {
        el = ln->value;
        if (el->module == ctx->module && el->event.id == event.id)
            break; /* Matching event found. */
    }

    /* Modify or remove the event listener if we already had one. */
    if (ln) {
        if (callback == NULL) {
            listDelNode(RedisModule_EventListeners,ln);
            ...",1,36,module.c,RM_SubscribeToServerEvent,,false,11511,11547,RM_SubscribeToServerEvent,,,575,"int RM_SubscribeToServerEvent (RedisModuleCtx*,RedisModuleEvent,RedisModuleEventCallback)"
193925,METHOD,module.c:<global>,TYPE_DECL,"int RM_IsSubEventSupported(RedisModuleEvent event, int64_t subevent) {
    switch (event.id) {
    case REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED:
        return subevent < _REDISMODULE_EVENT_REPLROLECHANGED_NEXT;
    case REDISMODULE_EVENT_PERSISTENCE:
        return subevent < _REDISMODULE_SUBEVENT_PERSISTENCE_NEXT;
    case REDISMODULE_EVENT_FLUSHDB:
        return subevent < _REDISMODULE_SUBEVENT_FLUSHDB_NEXT;
    case REDISMODULE_EVENT_LOADING:
        return subevent < _REDISMODULE_SUBEVENT_LOADING_NEXT;
    case REDISMODULE_EVENT_CLIENT_CHANGE:
        return subevent < _REDISMODULE_SUBEVENT_CLIENT_CHANGE_NEXT;
    case REDISMODULE_EVENT_SHUTDOWN:
        return subevent < _REDISMODULE_SUBEVENT_SHUTDOWN_NEXT;
    case REDISMODULE_EVENT_REPLICA_CHANGE:
        return subevent < _REDISMODULE_EVENT_REPLROLECHANGED_NEXT;
    case REDISMODULE_EVENT_MASTER_LINK_CHANGE:
        return subevent < _REDISMODULE_SUBEVENT_MASTER_NEXT;
    case REDISMODULE_EVENT_CRON_LOOP:
        return...",1,9,module.c,RM_IsSubEventSupported,,false,11553,11593,RM_IsSubEventSupported,,,576,"int RM_IsSubEventSupported (RedisModuleEvent,int64_t)"
194116,METHOD,module.c:<global>,TYPE_DECL,"void moduleFireServerEvent(uint64_t eid, int subid, void *data) {
    /* Fast path to return ASAP if there is nothing to do, avoiding to
     * setup the iterator and so forth: we want this call to be extremely
     * cheap if there are no registered modules. */
    if (listLength(RedisModule_EventListeners) == 0) return;

    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);
    while((ln = listNext(&li))) {
        RedisModuleEventListener *el = ln->value;
        if (el->event.id == eid) {
            RedisModuleCtx ctx;
            if (eid == REDISMODULE_EVENT_CLIENT_CHANGE) {
                /* In the case of client changes, we're pushing the real client
                 * so the event handler can mutate it if needed. For example,
                 * to change its authentication state in a way that does not
                 * depend on specific commands executed later.
                 */
                moduleCreateContext(&ctx,el->module,REDISMODUL...",1,8,module.c,moduleFireServerEvent,,false,11609,11689,moduleFireServerEvent,,,579,"void moduleFireServerEvent (uint64_t,int,void*)"
194489,METHOD,module.c:<global>,TYPE_DECL,"void moduleUnsubscribeAllServerEvents(RedisModule *module) {
    RedisModuleEventListener *el;
    listIter li;
    listNode *ln;
    listRewind(RedisModule_EventListeners,&li);

    while((ln = listNext(&li))) {
        el = ln->value;
        if (el->module == module) {
            listDelNode(RedisModule_EventListeners,ln);
            zfree(el);
        }
    }
}",1,1,module.c,moduleUnsubscribeAllServerEvents,,false,11693,11706,moduleUnsubscribeAllServerEvents,,,580,void moduleUnsubscribeAllServerEvents (RedisModule*)
194525,METHOD,module.c:<global>,TYPE_DECL,"void processModuleLoadingProgressEvent(int is_aof) {
    long long now = server.ustime;
    static long long next_event = 0;
    if (now >= next_event) {
        /* Fire the loading progress modules end event. */
        int progress = -1;
        if (server.loading_total_bytes)
            progress = (server.loading_loaded_bytes<<10) / server.loading_total_bytes;
        RedisModuleLoadingProgressV1 fi = {REDISMODULE_LOADING_PROGRESS_VERSION,
                                     server.hz,
                                     progress};
        moduleFireServerEvent(REDISMODULE_EVENT_LOADING_PROGRESS,
                              is_aof?
                                REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF:
                                REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB,
                              &fi);
        /* decide when the next event should fire. */
        next_event = now + 1000000 / server.hz;
    }
}",1,43,module.c,processModuleLoadingProgressEvent,,false,11708,11727,processModuleLoadingProgressEvent,,,581,void processModuleLoadingProgressEvent (int)
194600,METHOD,module.c:<global>,TYPE_DECL,"void moduleNotifyKeyUnlink(robj *key, robj *val, int dbid, int flags) {
    server.lazy_expire_disabled++;
    int subevent = REDISMODULE_SUBEVENT_KEY_DELETED;
    if (flags & DB_FLAG_KEY_EXPIRED) {
        subevent = REDISMODULE_SUBEVENT_KEY_EXPIRED;
    } else if (flags & DB_FLAG_KEY_EVICTED) {
        subevent = REDISMODULE_SUBEVENT_KEY_EVICTED;
    } else if (flags & DB_FLAG_KEY_OVERWRITE) {
        subevent = REDISMODULE_SUBEVENT_KEY_OVERWRITTEN;
    }
    KeyInfo info = {dbid, key, val, REDISMODULE_READ};
    moduleFireServerEvent(REDISMODULE_EVENT_KEY, subevent, &info);

    if (val->type == OBJ_MODULE) {
        moduleValue *mv = val->ptr;
        moduleType *mt = mv->type;
        /* We prefer to use the enhanced version. */
        if (mt->unlink2 != NULL) {
            RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
            mt->unlink2(&ctx,mv->value);
        } else if (mt->unlink != NULL) {
            mt->unlink(key,mv->value);
        }
    }
    server.lazy_exp...",1,19,module.c,moduleNotifyKeyUnlink,,false,11731,11756,moduleNotifyKeyUnlink,,,582,"void moduleNotifyKeyUnlink (robj*,robj*,int,int)"
194750,METHOD,module.c:<global>,TYPE_DECL,"size_t moduleGetFreeEffort(robj *key, robj *val, int dbid) {
    moduleValue *mv = val->ptr;
    moduleType *mt = mv->type;
    size_t effort = 1;
    /* We prefer to use the enhanced version. */
    if (mt->free_effort2 != NULL) {
        RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
        effort = mt->free_effort2(&ctx,mv->value);
    } else if (mt->free_effort != NULL) {
        effort = mt->free_effort(key,mv->value);
    }  

    return effort;
}",1,1,module.c,moduleGetFreeEffort,,false,11761,11774,moduleGetFreeEffort,,,583,"size_t moduleGetFreeEffort (robj*,robj*,int)"
194821,METHOD,module.c:<global>,TYPE_DECL,"size_t moduleGetMemUsage(robj *key, robj *val, size_t sample_size, int dbid) {
    moduleValue *mv = val->ptr;
    moduleType *mt = mv->type;
    size_t size = 0;
    /* We prefer to use the enhanced version. */
    if (mt->mem_usage2 != NULL) {
        RedisModuleKeyOptCtx ctx = {key, NULL, dbid, -1};
        size = mt->mem_usage2(&ctx, mv->value, sample_size);
    } else if (mt->mem_usage != NULL) {
        size = mt->mem_usage(mv->value);
    } 

    return size;
}",1,1,module.c,moduleGetMemUsage,,false,11778,11791,moduleGetMemUsage,,,584,"size_t moduleGetMemUsage (robj*,robj*,size_t,int)"
194893,METHOD,module.c:<global>,TYPE_DECL,"uint64_t dictCStringKeyHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
}",1,1,module.c,dictCStringKeyHash,,false,11800,11802,dictCStringKeyHash,,,585,uint64_t dictCStringKeyHash (void*)
194907,METHOD,module.c:<global>,TYPE_DECL,"int dictCStringKeyCompare(dict *d, const void *key1, const void *key2) {
    UNUSED(d);
    return strcmp(key1,key2) == 0;
}",1,4,module.c,dictCStringKeyCompare,,false,11804,11807,dictCStringKeyCompare,,,586,"int dictCStringKeyCompare (dict*,void*,void*)"
194937,METHOD,module.c:<global>,TYPE_DECL,"int moduleRegisterApi(const char *funcname, void *funcptr) {
    return dictAdd(server.moduleapi, (char*)funcname, funcptr);
}",1,1,module.c,moduleRegisterApi,,false,11819,11821,moduleRegisterApi,,,589,"int moduleRegisterApi (char*,void*)"
194952,METHOD,module.c:<global>,TYPE_DECL,void moduleRegisterCoreAPI(void);,6,32,module.c,moduleRegisterCoreAPI,,false,11827,11827,moduleRegisterCoreAPI,,,590,void moduleRegisterCoreAPI (void)
194957,METHOD,module.c:<global>,TYPE_DECL,"void moduleInitModulesSystemLast(void) {
}",1,1,module.c,moduleInitModulesSystemLast,,false,11833,11834,moduleInitModulesSystemLast,,,591,void moduleInitModulesSystemLast (void)
194973,METHOD,module.c:<global>,TYPE_DECL,"void moduleInitModulesSystem(void) {
    moduleUnblockedClients = listCreate();
    server.loadmodule_queue = listCreate();
    server.module_configs_queue = dictCreate(&sdsKeyValueHashDictType);
    modules = dictCreate(&modulesDictType);
    moduleAuthCallbacks = listCreate();

    /* Set up the keyspace notification subscriber list and static client */
    moduleKeyspaceSubscribers = listCreate();

    modulePostExecUnitJobs = listCreate();

    /* Set up filter list */
    moduleCommandFilters = listCreate();

    moduleRegisterCoreAPI();

    /* Create a pipe for module threads to be able to wake up the redis main thread.
     * Make the pipe non blocking. This is just a best effort aware mechanism
     * and we do not want to block not in the read nor in the write half.
     * Enable close-on-exec flag on pipes in case of the fork-exec system calls in
     * sentinels or redis servers. */
    if (anetPipe(server.module_pipe, O_CLOEXEC|O_NONBLOCK, O_CLOEXEC|O_NONBLOCK) == -1) {...",1,8,module.c,moduleInitModulesSystem,,false,11847,11887,moduleInitModulesSystem,,,594,void moduleInitModulesSystem (void)
195079,METHOD,module.c:<global>,TYPE_DECL,"void modulesCron(void) {
    /* Check number of temporary clients in the pool and free the unused ones
     * since the last cron. moduleTempClientMinCount tracks minimum count of
     * clients in the pool since the last cron. This is the number of clients
     * that we didn't use for the last cron period. */

    /* Limit the max client count to be freed at once to avoid latency spikes.*/
    int iteration = 50;
    /* We are freeing clients if we have more than 8 unused clients. Keeping
     * small amount of clients to avoid client allocation costs if temporary
     * clients are required after some idle period. */
    const unsigned int min_client = 8;
    while (iteration > 0 && moduleTempClientCount > 0 && moduleTempClientMinCount > min_client) {
        client *c = moduleTempClients[--moduleTempClientCount];
        freeClient(c);
        iteration--;
        moduleTempClientMinCount--;
    }
    moduleTempClientMinCount = moduleTempClientCount;

    /* Shrink moduleTempCli...",1,1,module.c,modulesCron,,false,11889,11914,modulesCron,,,595,void modulesCron (void)
195143,METHOD,module.c:<global>,TYPE_DECL,"void moduleLoadQueueEntryFree(struct moduleLoadQueueEntry *loadmod) {
    if (!loadmod) return;
    sdsfree(loadmod->path);
    for (int i = 0; i < loadmod->argc; i++) {
        decrRefCount(loadmod->argv[i]);
    }
    zfree(loadmod->argv);
    zfree(loadmod);
}",1,1,module.c,moduleLoadQueueEntryFree,,false,11916,11924,moduleLoadQueueEntryFree,,,596,void moduleLoadQueueEntryFree (moduleLoadQueueEntry*)
195183,METHOD,module.c:<global>,TYPE_DECL,"void moduleRemoveConfigs(RedisModule *module) {
    listIter li;
    listNode *ln;
    listRewind(module->module_configs, &li);
    while ((ln = listNext(&li))) {
        ModuleConfig *config = listNodeValue(ln);
        sds module_name = sdsnew(module->name);
        sds full_name = sdscat(sdscat(module_name, "".""), config->name); /* ModuleName.ModuleConfig */
        removeConfig(full_name);
        sdsfree(full_name);
    }
}",1,31,module.c,moduleRemoveConfigs,,false,11927,11938,moduleRemoveConfigs,,,597,void moduleRemoveConfigs (RedisModule*)
195233,METHOD,module.c:<global>,TYPE_DECL,"void moduleLoadFromQueue(void) {
    listIter li;
    listNode *ln;

    listRewind(server.loadmodule_queue,&li);
    while((ln = listNext(&li))) {
        struct moduleLoadQueueEntry *loadmod = ln->value;
        if (moduleLoad(loadmod->path,(void **)loadmod->argv,loadmod->argc, 0)
            == C_ERR)
        {
            serverLog(LL_WARNING,
                ""Can't load module from %s: server aborting"",
                loadmod->path);
            exit(1);
        }
        moduleLoadQueueEntryFree(loadmod);
        listDelNode(server.loadmodule_queue, ln);
    }
    if (dictSize(server.module_configs_queue)) {
        serverLog(LL_WARNING, ""Module Configuration detected without loadmodule directive or no ApplyConfig call: aborting"");
        exit(1);
    }
}",1,15,module.c,moduleLoadFromQueue,,false,11949,11971,moduleLoadFromQueue,,,598,void moduleLoadFromQueue (void)
195351,METHOD,module.c:<global>,TYPE_DECL,"void moduleFreeModuleStructure(struct RedisModule *module) {
    listRelease(module->types);
    listRelease(module->filters);
    listRelease(module->usedby);
    listRelease(module->using);
    listRelease(module->module_configs);
    sdsfree(module->name);
    moduleLoadQueueEntryFree(module->loadmod);
    zfree(module);
}",1,1,module.c,moduleFreeModuleStructure,,false,11973,11982,moduleFreeModuleStructure,,,599,void moduleFreeModuleStructure (RedisModule*)
195386,METHOD,module.c:<global>,TYPE_DECL,"void moduleFreeArgs(struct redisCommandArg *args, int num_args) {
    for (int j = 0; j < num_args; j++) {
        zfree((char *)args[j].name);
        zfree((char *)args[j].token);
        zfree((char *)args[j].summary);
        zfree((char *)args[j].since);
        zfree((char *)args[j].deprecated_since);
        zfree((char *)args[j].display_text);

        if (args[j].subargs) {
            moduleFreeArgs(args[j].subargs, args[j].num_args);
        }
    }
    zfree(args);
}",1,1,module.c,moduleFreeArgs,,false,11984,11998,moduleFreeArgs,,,600,"void moduleFreeArgs (redisCommandArg*,int)"
195472,METHOD,module.c:<global>,TYPE_DECL,"int moduleFreeCommand(struct RedisModule *module, struct redisCommand *cmd) {
    if (cmd->proc != RedisModuleCommandDispatcher)
        return C_ERR;

    RedisModuleCommand *cp = cmd->module_cmd;
    if (cp->module != module)
        return C_ERR;

    /* Free everything except cmd->fullname and cmd itself. */
    for (int j = 0; j < cmd->key_specs_num; j++) {
        if (cmd->key_specs[j].notes)
            zfree((char *)cmd->key_specs[j].notes);
        if (cmd->key_specs[j].begin_search_type == KSPEC_BS_KEYWORD)
            zfree((char *)cmd->key_specs[j].bs.keyword.keyword);
    }
    zfree(cmd->key_specs);
    for (int j = 0; cmd->tips && cmd->tips[j]; j++)
        zfree((char *)cmd->tips[j]);
    zfree(cmd->tips);
    for (int j = 0; cmd->history && cmd->history[j].since; j++) {
        zfree((char *)cmd->history[j].since);
        zfree((char *)cmd->history[j].changes);
    }
    zfree(cmd->history);
    zfree((char *)cmd->summary);
    zfree((char *)cmd->since);
    zfree(...",1,15,module.c,moduleFreeCommand,,false,12006,12058,moduleFreeCommand,,,601,"int moduleFreeCommand (RedisModule*,redisCommand*)"
195770,METHOD,module.c:<global>,TYPE_DECL,"void moduleUnregisterCommands(struct RedisModule *module) {
    /* Unregister all the commands registered by this module. */
    dictIterator *di = dictGetSafeIterator(server.commands);
    dictEntry *de;
    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (moduleFreeCommand(module, cmd) != C_OK) continue;

        serverAssert(dictDelete(server.commands, cmd->fullname) == DICT_OK);
        serverAssert(dictDelete(server.orig_commands, cmd->fullname) == DICT_OK);
        sdsfree((sds)cmd->declared_name);
        sdsfree(cmd->fullname);
        zfree(cmd);
    }
    dictReleaseIterator(di);
}",1,46,module.c,moduleUnregisterCommands,,false,12060,12075,moduleUnregisterCommands,,,602,void moduleUnregisterCommands (RedisModule*)
195864,METHOD,module.c:<global>,TYPE_DECL,"int parseLoadexArguments(RedisModuleString ***module_argv, int *module_argc) {
    int args_specified = 0;
    RedisModuleString **argv = *module_argv;
    int argc = *module_argc;
    for (int i = 0; i < argc; i++) {
        char *arg_val = argv[i]->ptr;
        if (!strcasecmp(arg_val, ""CONFIG"")) {
            if (i + 2 >= argc) {
                serverLog(LL_NOTICE, ""CONFIG specified without name value pair"");
                return REDISMODULE_ERR;
            }
            sds name = sdsdup(argv[i + 1]->ptr);
            sds value = sdsdup(argv[i + 2]->ptr);
            if (!dictReplace(server.module_configs_queue, name, value)) sdsfree(name);
            i += 2;
        } else if (!strcasecmp(arg_val, ""ARGS"")) {
            args_specified = 1;
            i++;
            if (i >= argc) {
                *module_argv = NULL;
                *module_argc = 0;
            } else {
                *module_argv = argv + i;
                *module_argc = argc - i;
            }
   ...",1,25,module.c,parseLoadexArguments,,false,12080,12116,parseLoadexArguments,,,603,"int parseLoadexArguments (robj***,int*)"
196059,METHOD,module.c:<global>,TYPE_DECL,"int moduleLoad(const char *path, void **module_argv, int module_argc, int is_loadex) {
    int (*onload)(void *, void **, int);
    void *handle;

    struct stat st;
    if (stat(path, &st) == 0) {
        /* This check is best effort */
        if (!(st.st_mode & (S_IXUSR  | S_IXGRP | S_IXOTH))) {
            serverLog(LL_WARNING, ""Module %s failed to load: It does not have execute permissions."", path);
            return C_ERR;
        }
    }

    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);
    if (handle == NULL) {
        serverLog(LL_WARNING, ""Module %s failed to load: %s"", path, dlerror());
        return C_ERR;
    }
    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,""RedisModule_OnLoad"");
    if (onload == NULL) {
        dlclose(handle);
        serverLog(LL_WARNING,
            ""Module %s does not export RedisModule_OnLoad() ""
            ""symbol. Module not loaded."",path);
        return C_ERR;
    }
    RedisModuleCtx ctx;
    moduleCreateContext(&...",1,12,module.c,moduleLoad,,false,12120,12211,moduleLoad,,,604,"int moduleLoad (char*,void**,int,int)"
196065,METHOD,module.c:<global>,TYPE_DECL,"int (*onload)(void *, void **, int);",9,39,module.c,moduleLoad.onload,,false,12121,12121,onload,,,1,"int moduleLoad.onload (void*,void**,int)"
196526,METHOD,module.c:<global>,TYPE_DECL,"int moduleUnload(sds name, const char **errmsg) {
    struct RedisModule *module = dictFetchValue(modules,name);

    if (module == NULL) {
        *errmsg = ""no such module with that name"";
        return C_ERR;
    } else if (listLength(module->types)) {
        *errmsg = ""the module exports one or more module-side data ""
                  ""types, can't unload"";
        return C_ERR;
    } else if (listLength(module->usedby)) {
        *errmsg = ""the module exports APIs used by other modules. ""
                  ""Please unload them first and try again"";
        return C_ERR;
    } else if (module->blocked_clients) {
        *errmsg = ""the module has blocked clients. ""
                  ""Please wait for them to be unblocked and try again"";
        return C_ERR;
    } else if (moduleHoldsTimer(module)) {
        *errmsg = ""the module holds timer that is not fired. ""
                  ""Please stop the timer or wait until it fires."";
        return C_ERR;
    }

    /* Give module a c...",1,15,module.c,moduleUnload,,false,12216,12290,moduleUnload,,,605,"int moduleUnload (sds,char**)"
196627,METHOD,module.c:<global>,TYPE_DECL,int (*onunload)(void *);,9,27,module.c,moduleUnload.onunload,,false,12241,12241,onunload,,,4,int moduleUnload.onunload (void*)
196810,METHOD,module.c:<global>,TYPE_DECL,"void modulePipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);
    UNUSED(privdata);

    char buf[128];
    while (read(fd, buf, sizeof(buf)) == sizeof(buf));

    /* Handle event loop events if pipe was written from event loop API */
    eventLoopHandleOneShotEvents();
}",1,4,module.c,modulePipeReadable,,false,12292,12303,modulePipeReadable,,,606,"void modulePipeReadable (aeEventLoop*,int,void*,int)"
196853,METHOD,module.c:<global>,TYPE_DECL,"void addReplyLoadedModules(client *c) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    addReplyArrayLen(c,dictSize(modules));
    while ((de = dictNext(di)) != NULL) {
        sds name = dictGetKey(de);
        struct RedisModule *module = dictGetVal(de);
        sds path = module->loadmod->path;
        addReplyMapLen(c,4);
        addReplyBulkCString(c,""name"");
        addReplyBulkCBuffer(c,name,sdslen(name));
        addReplyBulkCString(c,""ver"");
        addReplyLongLong(c,module->ver);
        addReplyBulkCString(c,""path"");
        addReplyBulkCBuffer(c,path,sdslen(path));
        addReplyBulkCString(c,""args"");
        addReplyArrayLen(c,module->loadmod->argc);
        for (int i = 0; i < module->loadmod->argc; i++) {
            addReplyBulk(c,module->loadmod->argv[i]);
        }
    }
    dictReleaseIterator(di);
}",1,23,module.c,addReplyLoadedModules,,false,12307,12330,addReplyLoadedModules,,,607,void addReplyLoadedModules (client*)
196970,METHOD,module.c:<global>,TYPE_DECL,"sds genModulesInfoStringRenderModulesList(list *l) {
    listIter li;
    listNode *ln;
    listRewind(l,&li);
    sds output = sdsnew(""["");
    while((ln = listNext(&li))) {
        RedisModule *module = ln->value;
        output = sdscat(output,module->name);
        if (ln != listLast(l))
            output = sdscat(output,""|"");
    }
    output = sdscat(output,""]"");
    return output;
}",1,18,module.c,genModulesInfoStringRenderModulesList,,false,12334,12347,genModulesInfoStringRenderModulesList,,,608,sds genModulesInfoStringRenderModulesList (list*)
197028,METHOD,module.c:<global>,TYPE_DECL,"sds genModulesInfoStringRenderModuleOptions(struct RedisModule *module) {
    sds output = sdsnew(""["");
    if (module->options & REDISMODULE_OPTIONS_HANDLE_IO_ERRORS)
        output = sdscat(output,""handle-io-errors|"");
    if (module->options & REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD)
        output = sdscat(output,""handle-repl-async-load|"");
    if (module->options & REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED)
        output = sdscat(output,""no-implicit-signal-modified|"");
    output = sdstrim(output,""|"");
    output = sdscat(output,""]"");
    return output;
}",1,26,module.c,genModulesInfoStringRenderModuleOptions,,false,12350,12361,genModulesInfoStringRenderModuleOptions,,,609,sds genModulesInfoStringRenderModuleOptions (RedisModule*)
197098,METHOD,module.c:<global>,TYPE_DECL,"sds genModulesInfoString(sds info) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        sds name = dictGetKey(de);
        struct RedisModule *module = dictGetVal(de);

        sds usedby = genModulesInfoStringRenderModulesList(module->usedby);
        sds using = genModulesInfoStringRenderModulesList(module->using);
        sds options = genModulesInfoStringRenderModuleOptions(module);
        info = sdscatfmt(info,
            ""module:name=%S,ver=%i,api=%i,filters=%i,""
            ""usedby=%S,using=%S,options=%S\r\n"",
                name, module->ver, module->apiver,
                (int)listLength(module->filters), usedby, using, options);
        sdsfree(usedby);
        sdsfree(using);
        sdsfree(options);
    }
    dictReleaseIterator(di);
    return info;
}",1,21,module.c,genModulesInfoString,,false,12369,12391,genModulesInfoString,,,610,sds genModulesInfoString (sds)
197183,METHOD,module.c:<global>,TYPE_DECL,"int isModuleConfigNameRegistered(RedisModule *module, sds name) {
    listNode *match = listSearchKey(module->module_configs, (void *) name);
    return match != NULL;
}",1,1,module.c,isModuleConfigNameRegistered,,false,12398,12401,isModuleConfigNameRegistered,,,611,"int isModuleConfigNameRegistered (RedisModule*,sds)"
197203,METHOD,module.c:<global>,TYPE_DECL,"int moduleVerifyConfigFlags(unsigned int flags, configType type) {
    if ((flags & ~(REDISMODULE_CONFIG_DEFAULT
                    | REDISMODULE_CONFIG_IMMUTABLE
                    | REDISMODULE_CONFIG_SENSITIVE
                    | REDISMODULE_CONFIG_HIDDEN
                    | REDISMODULE_CONFIG_PROTECTED
                    | REDISMODULE_CONFIG_DENY_LOADING
                    | REDISMODULE_CONFIG_BITFLAGS
                    | REDISMODULE_CONFIG_MEMORY))) {
        serverLogRaw(LL_WARNING, ""Invalid flag(s) for configuration"");
        return REDISMODULE_ERR;
    }
    if (type != NUMERIC_CONFIG && flags & REDISMODULE_CONFIG_MEMORY) {
        serverLogRaw(LL_WARNING, ""Numeric flag provided for non-numeric configuration."");
        return REDISMODULE_ERR;
    }
    if (type != ENUM_CONFIG && flags & REDISMODULE_CONFIG_BITFLAGS) {
        serverLogRaw(LL_WARNING, ""Enum flag provided for non-enum configuration."");
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",1,19,module.c,moduleVerifyConfigFlags,,false,12404,12425,moduleVerifyConfigFlags,,,612,"int moduleVerifyConfigFlags (unsigned int,configType)"
197316,METHOD,module.c:<global>,TYPE_DECL,"int moduleVerifyConfigName(sds name) {
    if (sdslen(name) == 0) {
        serverLogRaw(LL_WARNING, ""Module config names cannot be an empty string."");
        return REDISMODULE_ERR;
    }
    for (size_t i = 0 ; i < sdslen(name) ; ++i) {
        char curr_char = name[i];
        if ((curr_char >= 'a' && curr_char <= 'z') ||
            (curr_char >= 'A' && curr_char <= 'Z') ||
            (curr_char >= '0' && curr_char <= '9') ||
            (curr_char == '_') || (curr_char == '-'))
        {
            continue;
        }
        serverLog(LL_WARNING, ""Invalid character %c in Module Config name %s."", curr_char, name);
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",1,21,module.c,moduleVerifyConfigName,,false,12427,12445,moduleVerifyConfigName,,,613,int moduleVerifyConfigName (sds)
197422,METHOD,module.c:<global>,TYPE_DECL,"static void propagateErrorString(RedisModuleString *err_in, const char **err) {
    if (err_in) {
        redis_strlcpy(configerr, err_in->ptr, CONFIG_ERR_SIZE);
        decrRefCount(err_in);
        *err = configerr;
    }
}",1,33,module.c,propagateErrorString,,false,12451,12457,propagateErrorString,,,616,"void propagateErrorString (robj*,char**)"
197445,METHOD,module.c:<global>,TYPE_DECL,"int setModuleBoolConfig(ModuleConfig *config, int val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_bool(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",1,4,module.c,setModuleBoolConfig,,false,12459,12464,setModuleBoolConfig,,,617,"int setModuleBoolConfig (ModuleConfig*,int,char**)"
197488,METHOD,module.c:<global>,TYPE_DECL,"int setModuleStringConfig(ModuleConfig *config, sds strval, const char **err) {
    RedisModuleString *error = NULL;
    RedisModuleString *new = createStringObject(strval, sdslen(strval));
    int return_code = config->set_fn.set_string(config->name, new, config->privdata, &error);
    propagateErrorString(error, err);
    decrRefCount(new);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",1,4,module.c,setModuleStringConfig,,false,12466,12473,setModuleStringConfig,,,618,"int setModuleStringConfig (ModuleConfig*,sds,char**)"
197542,METHOD,module.c:<global>,TYPE_DECL,"int setModuleEnumConfig(ModuleConfig *config, int val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_enum(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",1,4,module.c,setModuleEnumConfig,,false,12475,12480,setModuleEnumConfig,,,619,"int setModuleEnumConfig (ModuleConfig*,int,char**)"
197585,METHOD,module.c:<global>,TYPE_DECL,"int setModuleNumericConfig(ModuleConfig *config, long long val, const char **err) {
    RedisModuleString *error = NULL;
    int return_code = config->set_fn.set_numeric(config->name, val, config->privdata, &error);
    propagateErrorString(error, err);
    return return_code == REDISMODULE_OK ? 1 : 0;
}",1,4,module.c,setModuleNumericConfig,,false,12482,12487,setModuleNumericConfig,,,620,"int setModuleNumericConfig (ModuleConfig*,long long,char**)"
197628,METHOD,module.c:<global>,TYPE_DECL,"int getModuleBoolConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_bool(module_config->name, module_config->privdata);
}",1,1,module.c,getModuleBoolConfig,,false,12491,12493,getModuleBoolConfig,,,621,int getModuleBoolConfig (ModuleConfig*)
197646,METHOD,module.c:<global>,TYPE_DECL,"sds getModuleStringConfig(ModuleConfig *module_config) {
    RedisModuleString *val = module_config->get_fn.get_string(module_config->name, module_config->privdata);
    return val ? sdsdup(val->ptr) : NULL;
}",1,4,module.c,getModuleStringConfig,,false,12495,12498,getModuleStringConfig,,,622,sds getModuleStringConfig (ModuleConfig*)
197676,METHOD,module.c:<global>,TYPE_DECL,"int getModuleEnumConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_enum(module_config->name, module_config->privdata);
}",1,1,module.c,getModuleEnumConfig,,false,12500,12502,getModuleEnumConfig,,,623,int getModuleEnumConfig (ModuleConfig*)
197694,METHOD,module.c:<global>,TYPE_DECL,"long long getModuleNumericConfig(ModuleConfig *module_config) {
    return module_config->get_fn.get_numeric(module_config->name, module_config->privdata);
}",1,1,module.c,getModuleNumericConfig,,false,12504,12506,getModuleNumericConfig,,,624,long long getModuleNumericConfig (ModuleConfig*)
197712,METHOD,module.c:<global>,TYPE_DECL,"int loadModuleConfigs(RedisModule *module) {
    listIter li;
    listNode *ln;
    const char *err = NULL;
    listRewind(module->module_configs, &li);
    while ((ln = listNext(&li))) {
        ModuleConfig *module_config = listNodeValue(ln);
        sds config_name = sdscatfmt(sdsempty(), ""%s.%s"", module->name, module_config->name);
        dictEntry *config_argument = dictFind(server.module_configs_queue, config_name);
        if (config_argument) {
            if (!performModuleConfigSetFromName(dictGetKey(config_argument), dictGetVal(config_argument), &err)) {
                serverLog(LL_WARNING, ""Issue during loading of configuration %s : %s"", (sds) dictGetKey(config_argument), err);
                sdsfree(config_name);
                dictEmpty(server.module_configs_queue, NULL);
                return REDISMODULE_ERR;
            }
        } else {
            if (!performModuleConfigSetDefaultFromName(config_name, &err)) {
                serverLog(LL_WARNING, ""Issue att...",1,38,module.c,loadModuleConfigs,,false,12510,12539,loadModuleConfigs,,,625,int loadModuleConfigs (RedisModule*)
197870,METHOD,module.c:<global>,TYPE_DECL,"void addModuleConfigApply(list *module_configs, ModuleConfig *module_config) {
    if (!module_config->apply_fn) return;
    listIter li;
    listNode *ln;
    ModuleConfig *pending_apply;
    listRewind(module_configs, &li);
    while ((ln = listNext(&li))) {
        pending_apply = listNodeValue(ln);
        if (pending_apply->apply_fn == module_config->apply_fn && pending_apply->privdata == module_config->privdata) {
            return;
        }
    }
    listAddNodeTail(module_configs, module_config);
}",1,24,module.c,addModuleConfigApply,,false,12542,12555,addModuleConfigApply,,,626,"void addModuleConfigApply (list*,ModuleConfig*)"
197926,METHOD,module.c:<global>,TYPE_DECL,"int moduleConfigApplyConfig(list *module_configs, const char **err, const char **err_arg_name) {
    if (!listLength(module_configs)) return 1;
    listIter li;
    listNode *ln;
    ModuleConfig *module_config;
    RedisModuleString *error = NULL;
    RedisModuleCtx ctx;

    listRewind(module_configs, &li);
    while ((ln = listNext(&li))) {
        module_config = listNodeValue(ln);
        moduleCreateContext(&ctx, module_config->module, REDISMODULE_CTX_NONE);
        if (module_config->apply_fn(&ctx, module_config->privdata, &error)) {
            if (err_arg_name) *err_arg_name = module_config->name;
            propagateErrorString(error, err);
            moduleFreeContext(&ctx);
            return 0;
        }
        moduleFreeContext(&ctx);
    }
    return 1;
}",1,9,module.c,moduleConfigApplyConfig,,false,12558,12579,moduleConfigApplyConfig,,,627,"int moduleConfigApplyConfig (list*,char**,char**)"
198017,METHOD,module.c:<global>,TYPE_DECL,"ModuleConfig *createModuleConfig(sds name, RedisModuleConfigApplyFunc apply_fn, void *privdata, RedisModule *module) {
    ModuleConfig *new_config = zmalloc(sizeof(ModuleConfig));
    new_config->name = sdsdup(name);
    new_config->apply_fn = apply_fn;
    new_config->privdata = privdata;
    new_config->module = module;
    return new_config;
}",1,1,module.c,createModuleConfig,,false,12586,12593,createModuleConfig,,,628,"ModuleConfig createModuleConfig (sds,RedisModuleConfigApplyFunc,void*,RedisModule*)"
198054,METHOD,module.c:<global>,TYPE_DECL,"int moduleConfigValidityCheck(RedisModule *module, sds name, unsigned int flags, configType type) {
    if (!module->onload) {
        errno = EBUSY;
        return REDISMODULE_ERR;
    }
    if (moduleVerifyConfigFlags(flags, type) || moduleVerifyConfigName(name)) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }
    if (isModuleConfigNameRegistered(module, name)) {
        serverLog(LL_WARNING, ""Configuration by the name: %s already registered"", name);
        errno = EALREADY;
        return REDISMODULE_ERR;
    }
    return REDISMODULE_OK;
}",1,15,module.c,moduleConfigValidityCheck,,false,12595,12610,moduleConfigValidityCheck,,,629,"int moduleConfigValidityCheck (RedisModule*,sds,unsigned int,configType)"
198125,METHOD,module.c:<global>,TYPE_DECL,"unsigned int maskModuleConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_DEFAULT) new_flags |= MODIFIABLE_CONFIG;
    if (flags & REDISMODULE_CONFIG_IMMUTABLE) new_flags |= IMMUTABLE_CONFIG;
    if (flags & REDISMODULE_CONFIG_HIDDEN) new_flags |= HIDDEN_CONFIG;
    if (flags & REDISMODULE_CONFIG_PROTECTED) new_flags |= PROTECTED_CONFIG;
    if (flags & REDISMODULE_CONFIG_DENY_LOADING) new_flags |= DENY_LOADING_CONFIG;
    return new_flags;
}",1,16,module.c,maskModuleConfigFlags,,false,12612,12620,maskModuleConfigFlags,,,630,unsigned int maskModuleConfigFlags (unsigned int)
198212,METHOD,module.c:<global>,TYPE_DECL,"unsigned int maskModuleNumericConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_MEMORY) new_flags |= MEMORY_CONFIG;
    return new_flags;
}",1,16,module.c,maskModuleNumericConfigFlags,,false,12622,12626,maskModuleNumericConfigFlags,,,631,unsigned int maskModuleNumericConfigFlags (unsigned int)
198239,METHOD,module.c:<global>,TYPE_DECL,"unsigned int maskModuleEnumConfigFlags(unsigned int flags) {
    unsigned int new_flags = 0;
    if (flags & REDISMODULE_CONFIG_BITFLAGS) new_flags |= MULTI_ARG_CONFIG;
    return new_flags;
}",1,16,module.c,maskModuleEnumConfigFlags,,false,12628,12632,maskModuleEnumConfigFlags,,,632,unsigned int maskModuleEnumConfigFlags (unsigned int)
198266,METHOD,module.c:<global>,TYPE_DECL,"int RM_RegisterStringConfig(RedisModuleCtx *ctx, const char *name, const char *default_val, unsigned int flags, RedisModuleConfigGetStringFunc getfn, RedisModuleConfigSetStringFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, NUMERIC_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_string = getfn;
    new_config->set_fn.set_string = setfn;
    listAddNodeTail(module->module_configs, new_config);
    flags = maskModuleConfigFlags(flags);
    addModuleStringConfig(module->name, name, flags, new_config, default_val ? sdsnew(default_val) : NULL);
    return REDISMODULE_OK;
}",1,15,module.c,RM_RegisterStringConfig,,false,12709,12724,RM_RegisterStringConfig,,,633,"int RM_RegisterStringConfig (RedisModuleCtx*,char*,char*,unsigned int,RedisModuleConfigGetStringFunc,RedisModuleConfigSetStringFunc,RedisModuleConfigApplyFunc,void*)"
198351,METHOD,module.c:<global>,TYPE_DECL,"int RM_RegisterBoolConfig(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, RedisModuleConfigGetBoolFunc getfn, RedisModuleConfigSetBoolFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, BOOL_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_bool = getfn;
    new_config->set_fn.set_bool = setfn;
    listAddNodeTail(module->module_configs, new_config);
    flags = maskModuleConfigFlags(flags);
    addModuleBoolConfig(module->name, name, flags, new_config, default_val);
    return REDISMODULE_OK;
}",1,15,module.c,RM_RegisterBoolConfig,,false,12729,12744,RM_RegisterBoolConfig,,,634,"int RM_RegisterBoolConfig (RedisModuleCtx*,char*,int,unsigned int,RedisModuleConfigGetBoolFunc,RedisModuleConfigSetBoolFunc,RedisModuleConfigApplyFunc,void*)"
198432,METHOD,module.c:<global>,TYPE_DECL,"int RM_RegisterEnumConfig(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, const char **enum_values, const int *int_values, int num_enum_vals, RedisModuleConfigGetEnumFunc getfn, RedisModuleConfigSetEnumFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, ENUM_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_enum = getfn;
    new_config->set_fn.set_enum = setfn;
    configEnum *enum_vals = zmalloc((num_enum_vals + 1) * sizeof(configEnum));
    for (int i = 0; i < num_enum_vals; i++) {
        enum_vals[i].name = zstrdup(enum_values[i]);
        enum_vals[i].val = int_values[i];
    }
    enum_vals[num_enum_vals].name = NULL;
    enum_vals...",1,15,module.c,RM_RegisterEnumConfig,,false,12775,12797,RM_RegisterEnumConfig,,,635,"int RM_RegisterEnumConfig (RedisModuleCtx*,char*,int,unsigned int,char**,int*,int,RedisModuleConfigGetEnumFunc,RedisModuleConfigSetEnumFunc,RedisModuleConfigApplyFunc,void*)"
198575,METHOD,module.c:<global>,TYPE_DECL,"int RM_RegisterNumericConfig(RedisModuleCtx *ctx, const char *name, long long default_val, unsigned int flags, long long min, long long max, RedisModuleConfigGetNumericFunc getfn, RedisModuleConfigSetNumericFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) {
    RedisModule *module = ctx->module;
    sds config_name = sdsnew(name);
    if (moduleConfigValidityCheck(module, config_name, flags, NUMERIC_CONFIG)) {
        sdsfree(config_name);
        return REDISMODULE_ERR;
    }
    ModuleConfig *new_config = createModuleConfig(config_name, applyfn, privdata, module);
    sdsfree(config_name);
    new_config->get_fn.get_numeric = getfn;
    new_config->set_fn.set_numeric = setfn;
    listAddNodeTail(module->module_configs, new_config);
    unsigned int numeric_flags = maskModuleNumericConfigFlags(flags);
    flags = maskModuleConfigFlags(flags);
    addModuleNumericConfig(module->name, name, flags, new_config, default_val, numeric_flags, min, max);
    return REDISMODUL...",1,15,module.c,RM_RegisterNumericConfig,,false,12803,12819,RM_RegisterNumericConfig,,,636,"int RM_RegisterNumericConfig (RedisModuleCtx*,char*,long long,unsigned int,long long,long long,RedisModuleConfigGetNumericFunc,RedisModuleConfigSetNumericFunc,RedisModuleConfigApplyFunc,void*)"
198666,METHOD,module.c:<global>,TYPE_DECL,"int RM_LoadConfigs(RedisModuleCtx *ctx) {
    if (!ctx || !ctx->module || !ctx->module->onload) {
        return REDISMODULE_ERR;
    }
    RedisModule *module = ctx->module;
    /* Load configs from conf file or arguments from loadex */
    if (loadModuleConfigs(module)) return REDISMODULE_ERR;
    return REDISMODULE_OK;
}",1,15,module.c,RM_LoadConfigs,,false,12826,12834,RM_LoadConfigs,,,637,int RM_LoadConfigs (RedisModuleCtx*)
198715,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleRdbStream *RM_RdbStreamCreateFromFile(const char *filename) {
    RedisModuleRdbStream *stream = zmalloc(sizeof(*stream));
    stream->type = REDISMODULE_RDB_STREAM_FILE;
    stream->data.filename = zstrdup(filename);
    return stream;
}",1,19,module.c,RM_RdbStreamCreateFromFile,,false,12855,12860,RM_RdbStreamCreateFromFile,,,640,RedisModuleRdbStream RM_RdbStreamCreateFromFile (char*)
198744,METHOD,module.c:<global>,TYPE_DECL,"void RM_RdbStreamFree(RedisModuleRdbStream *stream) {
    switch (stream->type) {
    case REDISMODULE_RDB_STREAM_FILE:
        zfree(stream->data.filename);
        break;
    default:
        serverAssert(0);
        break;
    }
    zfree(stream);
}",1,9,module.c,RM_RdbStreamFree,,false,12863,12873,RM_RdbStreamFree,,,641,void RM_RdbStreamFree (RedisModuleRdbStream*)
198784,METHOD,module.c:<global>,TYPE_DECL,"int RM_RdbLoad(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) {
    UNUSED(ctx);

    if (!stream || flags != 0) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    /* Not allowed on replicas. */
    if (server.masterhost != NULL) {
        errno = ENOTSUP;
        return REDISMODULE_ERR;
    }

    /* Drop replicas if exist. */
    disconnectSlaves();
    freeReplicationBacklog();

    if (server.aof_state != AOF_OFF) stopAppendOnly();

    /* Kill existing RDB fork as it is saving outdated data. Also killing it
     * will prevent COW memory issue. */
    if (server.child_type == CHILD_TYPE_RDB) killRDBChild();

    emptyData(-1,EMPTYDB_NO_FLAGS,NULL);

    /* rdbLoad() can go back to the networking and process network events. If
     * RM_RdbLoad() is called inside a command callback, we don't want to
     * process the current client. Otherwise, we may free the client or try to
     * process next message while we are already in the command callba...",1,4,module.c,RM_RdbLoad,,false,12889,12934,RM_RdbLoad,,,642,"int RM_RdbLoad (RedisModuleCtx*,RedisModuleRdbStream*,int)"
198942,METHOD,module.c:<global>,TYPE_DECL,"int RM_RdbSave(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) {
    UNUSED(ctx);

    if (!stream || flags != 0) {
        errno = EINVAL;
        return REDISMODULE_ERR;
    }

    serverAssert(stream->type == REDISMODULE_RDB_STREAM_FILE);

    if (rdbSaveToFile(stream->data.filename) != C_OK) {
        return REDISMODULE_ERR;
    }

    errno = 0;
    return REDISMODULE_OK;
}",1,4,module.c,RM_RdbSave,,false,12949,12965,RM_RdbSave,,,643,"int RM_RdbSave (RedisModuleCtx*,RedisModuleRdbStream*,int)"
199011,METHOD,module.c:<global>,TYPE_DECL,"void moduleCommand(client *c) {
    char *subcmd = c->argv[1]->ptr;

    if (c->argc == 2 && !strcasecmp(subcmd,""help"")) {
        const char *help[] = {
""LIST"",
""    Return a list of loaded modules."",
""LOAD <path> [<arg> ...]"",
""    Load a module library from <path>, passing to it any optional arguments."",
""LOADEX <path> [[CONFIG NAME VALUE] [CONFIG NAME VALUE]] [ARGS ...]"",
""    Load a module library from <path>, while passing it module configurations and optional arguments."",
""UNLOAD <name>"",
""    Unload a module."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(subcmd,""load"") && c->argc >= 3) {
        robj **argv = NULL;
        int argc = 0;

        if (c->argc > 3) {
            argc = c->argc - 3;
            argv = &c->argv[3];
        }

        if (moduleLoad(c->argv[2]->ptr,(void **)argv,argc, 0) == C_OK)
            addReply(c,shared.ok);
        else
            addReplyError(c,
                ""Error loading the extension. Please check the ...",1,65,module.c,moduleCommand,,false,12974,13038,moduleCommand,,,644,void moduleCommand (client*)
199319,METHOD,module.c:<global>,TYPE_DECL,"size_t moduleCount(void) {
    return dictSize(modules);
}",1,11,module.c,moduleCount,,false,13041,13043,moduleCount,,,645,size_t moduleCount (void)
199339,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetLRU(RedisModuleKey *key, mstime_t lru_idle) {
    if (!key->value)
        return REDISMODULE_ERR;
    if (objectSetLRUOrLFU(key->value, -1, lru_idle, lru_idle>=0 ? LRU_CLOCK() : 0, 1))
        return REDISMODULE_OK;
    return REDISMODULE_ERR;
}",1,15,module.c,RM_SetLRU,,false,13052,13058,RM_SetLRU,,,646,"int RM_SetLRU (RedisModuleKey*,mstime_t)"
199379,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetLRU(RedisModuleKey *key, mstime_t *lru_idle) {
    *lru_idle = -1;
    if (!key->value)
        return REDISMODULE_ERR;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU)
        return REDISMODULE_OK;
    *lru_idle = estimateObjectIdleTime(key->value);
    return REDISMODULE_OK;
}",1,15,module.c,RM_GetLRU,,false,13064,13072,RM_GetLRU,,,647,"int RM_GetLRU (RedisModuleKey*,mstime_t*)"
199426,METHOD,module.c:<global>,TYPE_DECL,"int RM_SetLFU(RedisModuleKey *key, long long lfu_freq) {
    if (!key->value)
        return REDISMODULE_ERR;
    if (objectSetLRUOrLFU(key->value, lfu_freq, -1, 0, 1))
        return REDISMODULE_OK;
    return REDISMODULE_ERR;
}",1,15,module.c,RM_SetLFU,,false,13079,13085,RM_SetLFU,,,648,"int RM_SetLFU (RedisModuleKey*,long long)"
199461,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetLFU(RedisModuleKey *key, long long *lfu_freq) {
    *lfu_freq = -1;
    if (!key->value)
        return REDISMODULE_ERR;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU)
        *lfu_freq = LFUDecrAndReturn(key->value);
    return REDISMODULE_OK;
}",1,15,module.c,RM_GetLFU,,false,13090,13097,RM_GetLFU,,,649,"int RM_GetLFU (RedisModuleKey*,long long*)"
199504,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetModuleOptionsAll(void) {
    return _REDISMODULE_OPTIONS_FLAGS_NEXT - 1;
}",1,11,module.c,RM_GetModuleOptionsAll,,false,13116,13118,RM_GetModuleOptionsAll,,,650,int RM_GetModuleOptionsAll (void)
199517,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetContextFlagsAll(void) {
    return _REDISMODULE_CTX_FLAGS_NEXT - 1;
}",1,11,module.c,RM_GetContextFlagsAll,,false,13133,13135,RM_GetContextFlagsAll,,,651,int RM_GetContextFlagsAll (void)
199530,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetKeyspaceNotificationFlagsAll(void) {
    return _REDISMODULE_NOTIFY_NEXT - 1;
}",1,11,module.c,RM_GetKeyspaceNotificationFlagsAll,,false,13150,13152,RM_GetKeyspaceNotificationFlagsAll,,,652,int RM_GetKeyspaceNotificationFlagsAll (void)
199543,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetServerVersion(void) {
    return REDIS_VERSION_NUM;
}",1,11,module.c,RM_GetServerVersion,,false,13158,13160,RM_GetServerVersion,,,653,int RM_GetServerVersion (void)
199552,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetTypeMethodVersion(void) {
    return REDISMODULE_TYPE_METHOD_VERSION;
}",1,11,module.c,RM_GetTypeMethodVersion,,false,13167,13169,RM_GetTypeMethodVersion,,,654,int RM_GetTypeMethodVersion (void)
199561,METHOD,module.c:<global>,TYPE_DECL,"int RM_ModuleTypeReplaceValue(RedisModuleKey *key, moduleType *mt, void *new_value, void **old_value) {
    if (!(key->mode & REDISMODULE_WRITE) || key->iter)
        return REDISMODULE_ERR;
    if (!key->value || key->value->type != OBJ_MODULE)
        return REDISMODULE_ERR;

    moduleValue *mv = key->value->ptr;
    if (mv->type != mt)
        return REDISMODULE_ERR;

    if (old_value)
        *old_value = mv->value;
    mv->value = new_value;

    return REDISMODULE_OK;
}",1,22,module.c,RM_ModuleTypeReplaceValue,,false,13188,13203,RM_ModuleTypeReplaceValue,,,655,"int RM_ModuleTypeReplaceValue (RedisModuleKey*,moduleType*,void*,void**)"
199646,METHOD,module.c:<global>,TYPE_DECL,"int *RM_GetCommandKeysWithFlags(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys, int **out_flags) {
    UNUSED(ctx);
    struct redisCommand *cmd;
    int *res = NULL;

    /* Find command */
    if ((cmd = lookupCommand(argv,argc)) == NULL) {
        errno = ENOENT;
        return NULL;
    }

    /* Bail out if command has no keys */
    if (!doesCommandHaveKeys(cmd)) {
        errno = 0;
        return NULL;
    }

    if ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) {
        errno = EINVAL;
        return NULL;
    }

    getKeysResult result = GETKEYS_RESULT_INIT;
    getKeysFromCommand(cmd, argv, argc, &result);

    *num_keys = result.numkeys;
    if (!result.numkeys) {
        errno = 0;
        getKeysFreeResult(&result);
        return NULL;
    }

    /* The return value here expects an array of key positions */
    unsigned long int size = sizeof(int) * result.numkeys;
    res = zmalloc(size);
    if (out_flags)
        *out_fla...",1,53,module.c,RM_GetCommandKeysWithFlags,,false,13225,13269,RM_GetCommandKeysWithFlags,,,656,"int* RM_GetCommandKeysWithFlags (RedisModuleCtx*,robj**,int,int*,int**)"
199816,METHOD,module.c:<global>,TYPE_DECL,"int *RM_GetCommandKeys(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys) {
    return RM_GetCommandKeysWithFlags(ctx, argv, argc, num_keys, NULL);
}",1,44,module.c,RM_GetCommandKeys,,false,13272,13274,RM_GetCommandKeys,,,657,"int* RM_GetCommandKeys (RedisModuleCtx*,robj**,int,int*)"
199831,METHOD,module.c:<global>,TYPE_DECL,"const char *RM_GetCurrentCommandName(RedisModuleCtx *ctx) {
    if (!ctx || !ctx->client || !ctx->client->cmd)
        return NULL;

    return (const char*)ctx->client->cmd->fullname;
}",1,1,module.c,RM_GetCurrentCommandName,,false,13277,13282,RM_GetCurrentCommandName,,,658,const char* RM_GetCurrentCommandName (RedisModuleCtx*)
199870,METHOD,module.c:<global>,TYPE_DECL,"int RM_RegisterDefragFunc(RedisModuleCtx *ctx, RedisModuleDefragFunc cb) {
    ctx->module->defrag_cb = cb;
    return REDISMODULE_OK;
}",1,11,module.c,RM_RegisterDefragFunc,,false,13301,13304,RM_RegisterDefragFunc,,,660,"int RM_RegisterDefragFunc (RedisModuleCtx*,RedisModuleDefragFunc)"
199887,METHOD,module.c:<global>,TYPE_DECL,"int RM_DefragShouldStop(RedisModuleDefragCtx *ctx) {
    return (ctx->endtime != 0 && ctx->endtime < ustime());
}",1,1,module.c,RM_DefragShouldStop,,false,13320,13322,RM_DefragShouldStop,,,661,int RM_DefragShouldStop (RedisModuleDefragCtx*)
199904,METHOD,module.c:<global>,TYPE_DECL,"int RM_DefragCursorSet(RedisModuleDefragCtx *ctx, unsigned long cursor) {
    if (!ctx->cursor)
        return REDISMODULE_ERR;

    *ctx->cursor = cursor;
    return REDISMODULE_OK;
}",1,15,module.c,RM_DefragCursorSet,,false,13346,13352,RM_DefragCursorSet,,,662,"int RM_DefragCursorSet (RedisModuleDefragCtx*,long unsigned)"
199930,METHOD,module.c:<global>,TYPE_DECL,"int RM_DefragCursorGet(RedisModuleDefragCtx *ctx, unsigned long *cursor) {
    if (!ctx->cursor)
        return REDISMODULE_ERR;

    *cursor = *ctx->cursor;
    return REDISMODULE_OK;
}",1,15,module.c,RM_DefragCursorGet,,false,13360,13366,RM_DefragCursorGet,,,663,"int RM_DefragCursorGet (RedisModuleDefragCtx*,long unsigned*)"
199957,METHOD,module.c:<global>,TYPE_DECL,"void *RM_DefragAlloc(RedisModuleDefragCtx *ctx, void *ptr) {
    UNUSED(ctx);
    return activeDefragAlloc(ptr);
}",1,4,module.c,RM_DefragAlloc,,false,13379,13382,RM_DefragAlloc,,,664,"void* RM_DefragAlloc (RedisModuleDefragCtx*,void*)"
199972,METHOD,module.c:<global>,TYPE_DECL,"RedisModuleString *RM_DefragRedisModuleString(RedisModuleDefragCtx *ctx, RedisModuleString *str) {
    UNUSED(ctx);
    return activeDefragStringOb(str);
}",1,17,module.c,RM_DefragRedisModuleString,,false,13394,13397,RM_DefragRedisModuleString,,,665,"robj RM_DefragRedisModuleString (RedisModuleDefragCtx*,robj*)"
199987,METHOD,module.c:<global>,TYPE_DECL,"int moduleLateDefrag(robj *key, robj *value, unsigned long *cursor, long long endtime, int dbid) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;

    RedisModuleDefragCtx defrag_ctx = { endtime, cursor, key, dbid};

    /* Invoke callback. Note that the callback may be missing if the key has been
     * replaced with a different type since our last visit.
     */
    int ret = 0;
    if (mt->defrag)
        ret = mt->defrag(&defrag_ctx, key, &mv->value);

    if (!ret) {
        *cursor = 0;    /* No more work to do */
        return 0;
    }

    return 1;
}",1,1,module.c,moduleLateDefrag,,false,13405,13424,moduleLateDefrag,,,666,"int moduleLateDefrag (robj*,robj*,long unsigned*,long long,int)"
200050,METHOD,module.c:<global>,TYPE_DECL,"int moduleDefragValue(robj *key, robj *value, int dbid) {
    moduleValue *mv = value->ptr;
    moduleType *mt = mv->type;

    /* Try to defrag moduleValue itself regardless of whether or not
     * defrag callbacks are provided.
     */
    moduleValue *newmv = activeDefragAlloc(mv);
    if (newmv) {
        value->ptr = mv = newmv;
    }

    if (!mt->defrag)
        return 1;

    /* Use free_effort to determine complexity of module value, and if
     * necessary schedule it for defragLater instead of quick immediate
     * defrag.
     */
    size_t effort = moduleGetFreeEffort(key, value, dbid);
    if (!effort)
        effort = SIZE_MAX;
    if (effort > server.active_defrag_max_scan_fields) {
        return 0;  /* Defrag later */
    }

    RedisModuleDefragCtx defrag_ctx = { 0, NULL, key, dbid };
    mt->defrag(&defrag_ctx, key, &mv->value);
    return 1;
}",1,1,module.c,moduleDefragValue,,false,13432,13461,moduleDefragValue,,,667,"int moduleDefragValue (robj*,robj*,int)"
200136,METHOD,module.c:<global>,TYPE_DECL,"void moduleDefragGlobals(void) {
    dictIterator *di = dictGetIterator(modules);
    dictEntry *de;

    while ((de = dictNext(di)) != NULL) {
        struct RedisModule *module = dictGetVal(de);
        if (!module->defrag_cb)
            continue;
        RedisModuleDefragCtx defrag_ctx = { 0, NULL, NULL, -1};
        module->defrag_cb(&defrag_ctx);
    }
    dictReleaseIterator(di);
}",1,1,module.c,moduleDefragGlobals,,false,13464,13476,moduleDefragGlobals,,,668,void moduleDefragGlobals (void)
200184,METHOD,module.c:<global>,TYPE_DECL,"const RedisModuleString *RM_GetKeyNameFromDefragCtx(RedisModuleDefragCtx *ctx) {
    return ctx->key;
}",1,6,module.c,RM_GetKeyNameFromDefragCtx,,false,13481,13483,RM_GetKeyNameFromDefragCtx,,,669,robj RM_GetKeyNameFromDefragCtx (RedisModuleDefragCtx*)
200193,METHOD,module.c:<global>,TYPE_DECL,"int RM_GetDbIdFromDefragCtx(RedisModuleDefragCtx *ctx) {
    return ctx->dbid;
}",1,1,module.c,RM_GetDbIdFromDefragCtx,,false,13488,13490,RM_GetDbIdFromDefragCtx,,,670,int RM_GetDbIdFromDefragCtx (RedisModuleDefragCtx*)
200202,METHOD,module.c:<global>,TYPE_DECL,"void moduleRegisterCoreAPI(void) {
    server.moduleapi = dictCreate(&moduleAPIDictType);
    server.sharedapi = dictCreate(&moduleAPIDictType);
    REGISTER_API(Alloc);
    REGISTER_API(TryAlloc);
    REGISTER_API(Calloc);
    REGISTER_API(Realloc);
    REGISTER_API(Free);
    REGISTER_API(Strdup);
    REGISTER_API(CreateCommand);
    REGISTER_API(GetCommand);
    REGISTER_API(CreateSubcommand);
    REGISTER_API(SetCommandInfo);
    REGISTER_API(SetCommandACLCategories);
    REGISTER_API(SetModuleAttribs);
    REGISTER_API(IsModuleNameBusy);
    REGISTER_API(WrongArity);
    REGISTER_API(ReplyWithLongLong);
    REGISTER_API(ReplyWithError);
    REGISTER_API(ReplyWithErrorFormat);
    REGISTER_API(ReplyWithSimpleString);
    REGISTER_API(ReplyWithArray);
    REGISTER_API(ReplyWithMap);
    REGISTER_API(ReplyWithSet);
    REGISTER_API(ReplyWithAttribute);
    REGISTER_API(ReplyWithNullArray);
    REGISTER_API(ReplyWithEmptyArray);
    REGISTER_API(ReplySetArrayLength);
    REGISTER_A...",1,4,module.c,moduleRegisterCoreAPI,,false,13494,13849,moduleRegisterCoreAPI,,,671,void moduleRegisterCoreAPI (void)
203398,METHOD,modules\helloacl.c:<global>,TYPE_DECL,<global>,1,1,modules\helloacl.c,modules\helloacl.c:<global>,,false,1,190,<global>,,,1,
203405,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int RevokeCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (global_auth_client_id) {
        RedisModule_DeauthenticateAndCloseClient(ctx, global_auth_client_id);
        return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
    } else {
        return RedisModule_ReplyWithError(ctx, ""Global user currently not used"");    
    }
}",1,4,modules\helloacl.c,RevokeCommand_RedisCommand,,false,44,54,RevokeCommand_RedisCommand,,,4,"int RevokeCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
203440,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int ResetCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModule_FreeModuleUser(global);
    global = RedisModule_CreateModuleUser(""global"");
    RedisModule_SetModuleUserACL(global, ""allcommands"");
    RedisModule_SetModuleUserACL(global, ""allkeys"");
    RedisModule_SetModuleUserACL(global, ""on"");

    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",1,4,modules\helloacl.c,ResetCommand_RedisCommand,,false,58,69,ResetCommand_RedisCommand,,,5,"int ResetCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
203478,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"void HelloACL_UserChanged(uint64_t client_id, void *privdata) {
    REDISMODULE_NOT_USED(privdata);
    REDISMODULE_NOT_USED(client_id);
    global_auth_client_id = 0;
}",1,4,modules\helloacl.c,HelloACL_UserChanged,,false,73,77,HelloACL_UserChanged,,,6,"void HelloACL_UserChanged (uint64_t,void*)"
203499,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int AuthGlobalCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (global_auth_client_id) {
        return RedisModule_ReplyWithError(ctx, ""Global user currently used"");    
    }

    RedisModule_AuthenticateClientWithUser(ctx, global, HelloACL_UserChanged, NULL, &global_auth_client_id);

    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",1,4,modules\helloacl.c,AuthGlobalCommand_RedisCommand,,false,81,92,AuthGlobalCommand_RedisCommand,,,7,"int AuthGlobalCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
203536,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int HelloACL_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    size_t length;

    RedisModuleString *user_string = RedisModule_GetBlockedClientPrivateData(ctx);
    const char *name = RedisModule_StringPtrLen(user_string, &length);

    if (RedisModule_AuthenticateClientWithACLUser(ctx, name, length, NULL, NULL, NULL) == 
            REDISMODULE_ERR) {
        return RedisModule_ReplyWithError(ctx, ""Invalid Username or password"");    
    }
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",1,4,modules\helloacl.c,HelloACL_Reply,,false,97,110,HelloACL_Reply,,,8,"int HelloACL_Reply (RedisModuleCtx*,RedisModuleString**,int)"
203589,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int HelloACL_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx, ""Request timedout"");
}",1,4,modules\helloacl.c,HelloACL_Timeout,,false,113,117,HelloACL_Timeout,,,9,"int HelloACL_Timeout (RedisModuleCtx*,RedisModuleString**,int)"
203612,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"void HelloACL_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_FreeString(NULL, privdata);
}",1,4,modules\helloacl.c,HelloACL_FreeData,,false,120,123,HelloACL_FreeData,,,10,"void HelloACL_FreeData (RedisModuleCtx*,void*)"
203627,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"void *HelloACL_ThreadMain(void *args) {
    void **targs = args;
    RedisModuleBlockedClient *bc = targs[0];
    RedisModuleString *user = targs[1];
    RedisModule_Free(targs);

    RedisModule_UnblockClient(bc,user);
    return NULL;
}",1,1,modules\helloacl.c,HelloACL_ThreadMain,,false,126,134,HelloACL_ThreadMain,,,11,void* HelloACL_ThreadMain (void*)
203655,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int AuthAsyncCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    pthread_t tid;
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx, HelloACL_Reply, HelloACL_Timeout, HelloACL_FreeData, TIMEOUT_TIME);
    

    void **targs = RedisModule_Alloc(sizeof(void*)*2);
    targs[0] = bc;
    targs[1] = RedisModule_CreateStringFromString(NULL, argv[1]);

    if (pthread_create(&tid, NULL, HelloACL_ThreadMain, targs) != 0) {
        RedisModule_AbortBlock(bc);
        return RedisModule_ReplyWithError(ctx, ""-ERR Can't start thread"");
    }

    return REDISMODULE_OK;
}",1,117,modules\helloacl.c,AuthAsyncCommand_RedisCommand,,false,138,155,AuthAsyncCommand_RedisCommand,,,12,"int AuthAsyncCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
203724,METHOD,modules\helloacl.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""helloacl"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""helloacl.reset"",
        ResetCommand_RedisCommand,"""",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""helloacl.revoke"",
        RevokeCommand_RedisCommand,"""",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""helloacl.authglobal"",
        AuthGlobalCommand_RedisCommand,""no-auth"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""helloacl.authasync"",
        AuthAsyncCommand_RedisCommand,""no-auth"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    global = RedisModule_CreateModuleUser(""global"");
    RedisModule_SetModuleUserACL(g...",1,4,modules\helloacl.c,RedisModule_OnLoad,,false,159,190,RedisModule_OnLoad,,,13,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
203865,METHOD,modules\helloblock.c:<global>,TYPE_DECL,<global>,1,1,modules\helloblock.c,modules\helloblock.c:<global>,,false,1,218,<global>,,,1,
203867,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    int *myint = RedisModule_GetBlockedClientPrivateData(ctx);
    return RedisModule_ReplyWithLongLong(ctx,*myint);
}",1,4,modules\helloblock.c,HelloBlock_Reply,,false,41,46,HelloBlock_Reply,,,1,"int HelloBlock_Reply (RedisModuleCtx*,RedisModuleString**,int)"
203896,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx,""Request timedout"");
}",1,4,modules\helloblock.c,HelloBlock_Timeout,,false,49,53,HelloBlock_Timeout,,,2,"int HelloBlock_Timeout (RedisModuleCtx*,RedisModuleString**,int)"
203919,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_Free(privdata);
}",1,4,modules\helloblock.c,HelloBlock_FreeData,,false,56,59,HelloBlock_FreeData,,,3,"void HelloBlock_FreeData (RedisModuleCtx*,void*)"
203933,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"void *HelloBlock_ThreadMain(void *arg) {
    void **targ = arg;
    RedisModuleBlockedClient *bc = targ[0];
    long long delay = (unsigned long)targ[1];
    RedisModule_Free(targ);

    sleep(delay);
    int *r = RedisModule_Alloc(sizeof(int));
    *r = rand();
    RedisModule_UnblockClient(bc,r);
    return NULL;
}",1,1,modules\helloblock.c,HelloBlock_ThreadMain,,false,63,74,HelloBlock_ThreadMain,,,4,void* HelloBlock_ThreadMain (void*)
203975,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"void HelloBlock_Disconnected(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc) {
    RedisModule_Log(ctx,""warning"",""Blocked client %p disconnected!"",
        (void*)bc);

    /* Here you should cleanup your state / threads, and if possible
     * call RedisModule_UnblockClient(), or notify the thread that will
     * call the function ASAP. */
}",1,1,modules\helloblock.c,HelloBlock_Disconnected,,false,84,91,HelloBlock_Disconnected,,,5,"void HelloBlock_Disconnected (RedisModuleCtx*,RedisModuleBlockedClient*)"
203988,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"int HelloBlock_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    long long delay;
    long long timeout;

    if (RedisModule_StringToLongLong(argv[1],&delay) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    if (RedisModule_StringToLongLong(argv[2],&timeout) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    pthread_t tid;
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,HelloBlock_Reply,HelloBlock_Timeout,HelloBlock_FreeData,timeout);

    /* Here we set a disconnection handler, however since this module will
     * block in sleep() in a thread, there is not much we can do in the
     * callback, so this is just to show you the API. */
    RedisModule_SetDisconnectCallback(bc,HelloBlock_Disconnected);

    /* Now that we setup a blocking client, we need to pass the control
     * to the thr...",1,56,modules\helloblock.c,HelloBlock_RedisCommand,,false,96,129,HelloBlock_RedisCommand,,,6,"int HelloBlock_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
204092,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"void *HelloKeys_ThreadMain(void *arg) {
    RedisModuleBlockedClient *bc = arg;
    RedisModuleCtx *ctx = RedisModule_GetThreadSafeContext(bc);
    long long cursor = 0;
    size_t replylen = 0;

    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    do {
        RedisModule_ThreadSafeContextLock(ctx);
        RedisModuleCallReply *reply = RedisModule_Call(ctx,
            ""SCAN"",""l"",(long long)cursor);
        RedisModule_ThreadSafeContextUnlock(ctx);

        RedisModuleCallReply *cr_cursor =
            RedisModule_CallReplyArrayElement(reply,0);
        RedisModuleCallReply *cr_keys =
            RedisModule_CallReplyArrayElement(reply,1);

        RedisModuleString *s = RedisModule_CreateStringFromCallReply(cr_cursor);
        RedisModule_StringToLongLong(s,&cursor);
        RedisModule_FreeString(ctx,s);

        size_t items = RedisModule_CallReplyLength(cr_keys);
        for (size_t j = 0; j < items; j++) {
            RedisModuleCallReply *ele =
                ...",1,35,modules\helloblock.c,HelloKeys_ThreadMain,,false,138,174,HelloKeys_ThreadMain,,,7,void* HelloKeys_ThreadMain (void*)
204203,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"int HelloKeys_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    if (argc != 1) return RedisModule_WrongArity(ctx);

    pthread_t tid;

    /* Note that when blocking the client we do not set any callback: no
     * timeout is possible since we passed '0', nor we need a reply callback
     * because we'll use the thread safe context to accumulate a reply. */
    RedisModuleBlockedClient *bc = RedisModule_BlockClient(ctx,NULL,NULL,NULL,0);

    /* Now that we setup a blocking client, we need to pass the control
     * to the thread. However we need to pass arguments to the thread:
     * the reference to the blocked client handle. */
    if (pthread_create(&tid,NULL,HelloKeys_ThreadMain,bc) != 0) {
        RedisModule_AbortBlock(bc);
        return RedisModule_ReplyWithError(ctx,""-ERR Can't start thread"");
    }
    return REDISMODULE_OK;
}",1,4,modules\helloblock.c,HelloKeys_RedisCommand,,false,180,199,HelloKeys_RedisCommand,,,8,"int HelloKeys_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
204254,METHOD,modules\helloblock.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""helloblock"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.block"",
        HelloBlock_RedisCommand,"""",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;
    if (RedisModule_CreateCommand(ctx,""hello.keys"",
        HelloKeys_RedisCommand,"""",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    return REDISMODULE_OK;
}",1,4,modules\helloblock.c,RedisModule_OnLoad,,false,203,218,RedisModule_OnLoad,,,9,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
204343,METHOD,modules\hellocluster.c:<global>,TYPE_DECL,<global>,1,1,modules\hellocluster.c,modules\hellocluster.c:<global>,,false,1,118,<global>,,,1,
204345,METHOD,modules\hellocluster.c:<global>,TYPE_DECL,"int PingallCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PING,""Hey"",3);
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",1,4,modules\hellocluster.c,PingallCommand_RedisCommand,,false,43,49,PingallCommand_RedisCommand,,,1,"int PingallCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
204376,METHOD,modules\hellocluster.c:<global>,TYPE_DECL,"int ListCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    size_t numnodes;
    char **ids = RedisModule_GetClusterNodesList(ctx,&numnodes);
    if (ids == NULL) {
        return RedisModule_ReplyWithError(ctx,""Cluster not enabled"");
    }

    RedisModule_ReplyWithArray(ctx,numnodes);
    for (size_t j = 0; j < numnodes; j++) {
        int port;
        RedisModule_GetClusterNodeInfo(ctx,ids[j],NULL,NULL,&port,NULL);
        RedisModule_ReplyWithArray(ctx,2);
        RedisModule_ReplyWithStringBuffer(ctx,ids[j],REDISMODULE_NODE_ID_LEN);
        RedisModule_ReplyWithLongLong(ctx,port);
    }
    RedisModule_FreeClusterNodesList(ids);
    return REDISMODULE_OK;
}",1,4,modules\hellocluster.c,ListCommand_RedisCommand,,false,52,72,ListCommand_RedisCommand,,,2,"int ListCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
204458,METHOD,modules\hellocluster.c:<global>,TYPE_DECL,"void PingReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    RedisModule_Log(ctx,""notice"",""PING (type %d) RECEIVED from %.*s: '%.*s'"",
        type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
    RedisModule_SendClusterMessage(ctx,NULL,MSGTYPE_PONG,""Ohi!"",4);
    RedisModuleCallReply *reply = RedisModule_Call(ctx, ""INCR"", ""c"", ""pings_received"");
    RedisModule_FreeCallReply(reply);
}",1,13,modules\hellocluster.c,PingReceiver,,false,75,81,PingReceiver,,,3,"void PingReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)"
204498,METHOD,modules\hellocluster.c:<global>,TYPE_DECL,"void PongReceiver(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len) {
    RedisModule_Log(ctx,""notice"",""PONG (type %d) RECEIVED from %.*s: '%.*s'"",
        type,REDISMODULE_NODE_ID_LEN,sender_id,(int)len, payload);
}",1,13,modules\hellocluster.c,PongReceiver,,false,84,87,PongReceiver,,,4,"void PongReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)"
204520,METHOD,modules\hellocluster.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""hellocluster"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellocluster.pingall"",
        PingallCommand_RedisCommand,""readonly"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellocluster.list"",
        ListCommand_RedisCommand,""readonly"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    /* Disable Redis Cluster sharding and redirections. This way every node
     * will be able to access every possible key, regardless of the hash slot.
     * This way the PING message handler will be able to increment a specific
     * variable. Normally you do that in order for the distributed system
     * you create as a module to have total freedom in the keyspace
     * manipulation. *...",1,4,modules\hellocluster.c,RedisModule_OnLoad,,false,91,118,RedisModule_OnLoad,,,5,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
204628,METHOD,modules\hellodict.c:<global>,TYPE_DECL,<global>,1,1,modules\hellodict.c,modules\hellodict.c:<global>,,false,1,131,<global>,,,1,
204631,METHOD,modules\hellodict.c:<global>,TYPE_DECL,"int cmd_SET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 3) return RedisModule_WrongArity(ctx);
    RedisModule_DictSet(Keyspace,argv[1],argv[2]);
    /* We need to keep a reference to the value stored at the key, otherwise
     * it would be freed when this callback returns. */
    RedisModule_RetainString(NULL,argv[2]);
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",1,1,modules\hellodict.c,cmd_SET,,false,47,54,cmd_SET,,,2,"int cmd_SET (RedisModuleCtx*,RedisModuleString**,int)"
204663,METHOD,modules\hellodict.c:<global>,TYPE_DECL,"int cmd_GET(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    RedisModuleString *val = RedisModule_DictGet(Keyspace,argv[1],NULL);
    if (val == NULL) {
        return RedisModule_ReplyWithNull(ctx);
    } else {
        return RedisModule_ReplyWithString(ctx, val);
    }
}",1,1,modules\hellodict.c,cmd_GET,,false,60,68,cmd_GET,,,3,"int cmd_GET (RedisModuleCtx*,RedisModuleString**,int)"
204701,METHOD,modules\hellodict.c:<global>,TYPE_DECL,"int cmd_KEYRANGE(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    /* Parse the count argument. */
    long long count;
    if (RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");
    }

    /* Seek the iterator. */
    RedisModuleDictIter *iter = RedisModule_DictIteratorStart(
        Keyspace, "">="", argv[1]);

    /* Reply with the matching items. */
    char *key;
    size_t keylen;
    long long replylen = 0; /* Keep track of the emitted array len. */
    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    while((key = RedisModule_DictNextC(iter,&keylen,NULL)) != NULL) {
        if (replylen >= count) break;
        if (RedisModule_DictCompare(iter,""<="",argv[2]) == REDISMODULE_ERR)
            break;
        RedisModule_ReplyWithStringBuffer(ctx,key,keylen);
        replylen++;
    }
    RedisModule_ReplySetArrayLength(...",1,56,modules\hellodict.c,cmd_KEYRANGE,,false,74,104,cmd_KEYRANGE,,,4,"int cmd_KEYRANGE (RedisModuleCtx*,RedisModuleString**,int)"
204799,METHOD,modules\hellodict.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""hellodict"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellodict.set"",
        cmd_SET,""write deny-oom"",1,1,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellodict.get"",
        cmd_GET,""readonly"",1,1,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellodict.keyrange"",
        cmd_KEYRANGE,""readonly"",1,1,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    /* Create our global dictionary. Here we'll set our keys and values. */
    Keyspace = RedisModule_CreateDict(NULL);

    return REDISMODULE_OK;
}",1,4,modules\hellodict.c,RedisModule_OnLoad,,false,108,131,RedisModule_OnLoad,,,5,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
204910,METHOD,modules\hellohook.c:<global>,TYPE_DECL,<global>,1,1,modules\hellohook.c,modules\hellohook.c:<global>,,false,1,92,<global>,,,1,
204912,METHOD,modules\hellohook.c:<global>,TYPE_DECL,"void clientChangeCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)
{
    REDISMODULE_NOT_USED(ctx);
    REDISMODULE_NOT_USED(e);

    RedisModuleClientInfo *ci = data;
    printf(""Client %s event for client #%llu %s:%d\n"",
        (sub == REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED) ?
            ""connection"" : ""disconnection"",
        (unsigned long long)ci->id,ci->addr,ci->port);
}",1,4,modules\hellohook.c,clientChangeCallback,,false,40,50,clientChangeCallback,,,1,"void clientChangeCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)"
204959,METHOD,modules\hellohook.c:<global>,TYPE_DECL,"void flushdbCallback(RedisModuleCtx *ctx, RedisModuleEvent e, uint64_t sub, void *data)
{
    REDISMODULE_NOT_USED(ctx);
    REDISMODULE_NOT_USED(e);

    RedisModuleFlushInfo *fi = data;
    if (sub == REDISMODULE_SUBEVENT_FLUSHDB_START) {
        if (fi->dbnum != -1) {
            RedisModuleCallReply *reply;
            reply = RedisModule_Call(ctx,""DBSIZE"","""");
            long long numkeys = RedisModule_CallReplyInteger(reply);
            printf(""FLUSHDB event of database %d started (%lld keys in DB)\n"",
                fi->dbnum, numkeys);
            RedisModule_FreeCallReply(reply);
        } else {
            printf(""FLUSHALL event started\n"");
        }
    } else {
        if (fi->dbnum != -1) {
            printf(""FLUSHDB event of database %d ended\n"",fi->dbnum);
        } else {
            printf(""FLUSHALL event ended\n"");
        }
    }
}",1,4,modules\hellohook.c,flushdbCallback,,false,52,76,flushdbCallback,,,2,"void flushdbCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)"
205043,METHOD,modules\hellohook.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""hellohook"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    RedisModule_SubscribeToServerEvent(ctx,
        RedisModuleEvent_ClientChange, clientChangeCallback);
    RedisModule_SubscribeToServerEvent(ctx,
        RedisModuleEvent_FlushDB, flushdbCallback);
    return REDISMODULE_OK;
}",1,4,modules\hellohook.c,RedisModule_OnLoad,,false,80,92,RedisModule_OnLoad,,,3,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
205104,METHOD,modules\hellotimer.c:<global>,TYPE_DECL,<global>,1,1,modules\hellotimer.c,modules\hellotimer.c:<global>,,false,1,75,<global>,,,1,
205106,METHOD,modules\hellotimer.c:<global>,TYPE_DECL,"void timerHandler(RedisModuleCtx *ctx, void *data) {
    REDISMODULE_NOT_USED(ctx);
    printf(""Fired %s!\n"", (char *)data);
    RedisModule_Free(data);
}",1,4,modules\hellotimer.c,timerHandler,,false,40,44,timerHandler,,,1,"void timerHandler (RedisModuleCtx*,void*)"
205125,METHOD,modules\hellotimer.c:<global>,TYPE_DECL,"int TimerCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    for (int j = 0; j < 10; j++) {
        int delay = rand() % 5000;
        char *buf = RedisModule_Alloc(256);
        snprintf(buf,256,""After %d"", delay);
        RedisModuleTimerID tid = RedisModule_CreateTimer(ctx,delay,timerHandler,buf);
        REDISMODULE_NOT_USED(tid);
    }
    return RedisModule_ReplyWithSimpleString(ctx, ""OK"");
}",1,4,modules\hellotimer.c,TimerCommand_RedisCommand,,false,47,59,TimerCommand_RedisCommand,,,2,"int TimerCommand_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
205190,METHOD,modules\hellotimer.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""hellotimer"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellotimer.timer"",
        TimerCommand_RedisCommand,""readonly"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    return REDISMODULE_OK;
}",1,4,modules\hellotimer.c,RedisModule_OnLoad,,false,63,75,RedisModule_OnLoad,,,3,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
205263,METHOD,modules\hellotype.c:<global>,TYPE_DECL,<global>,1,1,modules\hellotype.c,modules\hellotype.c:<global>,,false,1,362,<global>,,,1,
205274,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"struct HelloTypeObject *createHelloTypeObject(void) {
    struct HelloTypeObject *o;
    o = RedisModule_Alloc(sizeof(*o));
    o->head = NULL;
    o->len = 0;
    return o;
}",1,1,modules\hellotype.c,createHelloTypeObject,,false,63,69,createHelloTypeObject,,,4,struct HelloTypeObject createHelloTypeObject (void)
205298,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloTypeInsert(struct HelloTypeObject *o, int64_t ele) {
    struct HelloTypeNode *next = o->head, *newnode, *prev = NULL;

    while(next && next->value < ele) {
        prev = next;
        next = next->next;
    }
    newnode = RedisModule_Alloc(sizeof(*newnode));
    newnode->value = ele;
    newnode->next = next;
    if (prev) {
        prev->next = newnode;
    } else {
        o->head = newnode;
    }
    o->len++;
}",1,1,modules\hellotype.c,HelloTypeInsert,,false,71,87,HelloTypeInsert,,,5,"void HelloTypeInsert (HelloTypeObject*,int64_t)"
205367,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloTypeReleaseObject(struct HelloTypeObject *o) {
    struct HelloTypeNode *cur, *next;
    cur = o->head;
    while(cur) {
        next = cur->next;
        RedisModule_Free(cur);
        cur = next;
    }
    RedisModule_Free(o);
}",1,1,modules\hellotype.c,HelloTypeReleaseObject,,false,89,98,HelloTypeReleaseObject,,,6,void HelloTypeReleaseObject (HelloTypeObject*)
205394,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int HelloTypeInsert_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 3) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long value;
    if ((RedisModule_StringToLongLong(argv[2],&value) != REDISMODULE_OK)) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid value: must be a signed 64 bit integer"");
    }

    /* Create an empty value object if the key is currently empty. */
    struct HelloTypeObject *hto;
    if (type == REDISMODULE_KEYTYPE_EMPTY) {
        hto = createHelloTypeObject();
        RedisModule_ModuleTypeSetValue(key,Hel...",1,8,modules\hellotype.c,HelloTypeInsert_RedisCommand,,false,103,137,HelloTypeInsert_RedisCommand,,,7,"int HelloTypeInsert_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
205510,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int HelloTypeRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long first, count;
    if (RedisModule_StringToLongLong(argv[2],&first) != REDISMODULE_OK ||
        RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK ||
        first < 0 || count < 0)
    {
        return RedisModule_ReplyWithError(ctx,
            ""ERR invalid first or count parameters"");
    }

    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
    struct HelloTypeNode *node = hto ? hto->he...",1,8,modules\hellotype.c,HelloTypeRange_RedisCommand,,false,140,173,HelloTypeRange_RedisCommand,,,8,"int HelloTypeRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
205655,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int HelloTypeLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 2) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    struct HelloTypeObject *hto = RedisModule_ModuleTypeGetValue(key);
    RedisModule_ReplyWithLongLong(ctx,hto ? hto->len : 0);
    return REDISMODULE_OK;
}",1,8,modules\hellotype.c,HelloTypeLen_RedisCommand,,false,176,192,HelloTypeLen_RedisCommand,,,9,"int HelloTypeLen_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
205731,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int HelloBlock_Reply(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    RedisModuleString *keyname = RedisModule_GetBlockedClientReadyKey(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,keyname,REDISMODULE_READ);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_MODULE ||
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        RedisModule_CloseKey(key);
        return REDISMODULE_ERR;
    }

    /* In case the key is able to serve our blocked client, let's directly
     * use our original command implementation to make this example simpler. */
    RedisModule_CloseKey(key);
    return HelloTypeRange_RedisCommand(ctx,argv,argc-1);
}",1,4,modules\hellotype.c,HelloBlock_Reply,,false,199,217,HelloBlock_Reply,,,10,"int HelloBlock_Reply (RedisModuleCtx*,RedisModuleString**,int)"
205798,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int HelloBlock_Timeout(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    return RedisModule_ReplyWithSimpleString(ctx,""Request timedout"");
}",1,4,modules\hellotype.c,HelloBlock_Timeout,,false,220,224,HelloBlock_Timeout,,,11,"int HelloBlock_Timeout (RedisModuleCtx*,RedisModuleString**,int)"
205821,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloBlock_FreeData(RedisModuleCtx *ctx, void *privdata) {
    REDISMODULE_NOT_USED(ctx);
    RedisModule_Free(privdata);
}",1,4,modules\hellotype.c,HelloBlock_FreeData,,false,227,230,HelloBlock_FreeData,,,12,"void HelloBlock_FreeData (RedisModuleCtx*,void*)"
205835,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int HelloTypeBRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 5) return RedisModule_WrongArity(ctx);
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_EMPTY &&
        RedisModule_ModuleTypeGetType(key) != HelloType)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Parse the timeout before even trying to serve the client synchronously,
     * so that we always fail ASAP on syntax errors. */
    long long timeout;
    if (RedisModule_StringToLongLong(argv[4],&timeout) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,
            ""ERR invalid timeout parameter"");
    }

    /* Can we serve the reply synchronously? */
    if (type != REDISMODULE_KEYTYPE_EMPTY) {
        retu...",1,8,modules\hellotype.c,HelloTypeBRange_RedisCommand,,false,235,264,HelloTypeBRange_RedisCommand,,,13,"int HelloTypeBRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
205945,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void *HelloTypeRdbLoad(RedisModuleIO *rdb, int encver) {
    if (encver != 0) {
        /* RedisModule_Log(""warning"",""Can't load data with version %d"", encver);*/
        return NULL;
    }
    uint64_t elements = RedisModule_LoadUnsigned(rdb);
    struct HelloTypeObject *hto = createHelloTypeObject();
    while(elements--) {
        int64_t ele = RedisModule_LoadSigned(rdb);
        HelloTypeInsert(hto,ele);
    }
    return hto;
}",1,1,modules\hellotype.c,HelloTypeRdbLoad,,false,268,280,HelloTypeRdbLoad,,,14,"void* HelloTypeRdbLoad (RedisModuleIO*,int)"
205981,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloTypeRdbSave(RedisModuleIO *rdb, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    RedisModule_SaveUnsigned(rdb,hto->len);
    while(node) {
        RedisModule_SaveSigned(rdb,node->value);
        node = node->next;
    }
}",1,1,modules\hellotype.c,HelloTypeRdbSave,,false,282,290,HelloTypeRdbSave,,,15,"void HelloTypeRdbSave (RedisModuleIO*,void*)"
206015,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloTypeAofRewrite(RedisModuleIO *aof, RedisModuleString *key, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    while(node) {
        RedisModule_EmitAOF(aof,""HELLOTYPE.INSERT"",""sl"",key,node->value);
        node = node->next;
    }
}",1,1,modules\hellotype.c,HelloTypeAofRewrite,,false,292,299,HelloTypeAofRewrite,,,16,"void HelloTypeAofRewrite (RedisModuleIO*,RedisModuleString*,void*)"
206048,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"size_t HelloTypeMemUsage(const void *value) {
    const struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    return sizeof(*hto) + sizeof(*node)*hto->len;
}",1,1,modules\hellotype.c,HelloTypeMemUsage,,false,303,307,HelloTypeMemUsage,,,17,size_t HelloTypeMemUsage (void*)
206075,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloTypeFree(void *value) {
    HelloTypeReleaseObject(value);
}",1,1,modules\hellotype.c,HelloTypeFree,,false,309,311,HelloTypeFree,,,18,void HelloTypeFree (void*)
206082,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"void HelloTypeDigest(RedisModuleDigest *md, void *value) {
    struct HelloTypeObject *hto = value;
    struct HelloTypeNode *node = hto->head;
    while(node) {
        RedisModule_DigestAddLongLong(md,node->value);
        node = node->next;
    }
    RedisModule_DigestEndSequence(md);
}",1,1,modules\hellotype.c,HelloTypeDigest,,false,313,321,HelloTypeDigest,,,19,"void HelloTypeDigest (RedisModuleDigest*,void*)"
206113,METHOD,modules\hellotype.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);

    if (RedisModule_Init(ctx,""hellotype"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    RedisModuleTypeMethods tm = {
        .version = REDISMODULE_TYPE_METHOD_VERSION,
        .rdb_load = HelloTypeRdbLoad,
        .rdb_save = HelloTypeRdbSave,
        .aof_rewrite = HelloTypeAofRewrite,
        .mem_usage = HelloTypeMemUsage,
        .free = HelloTypeFree,
        .digest = HelloTypeDigest
    };

    HelloType = RedisModule_CreateDataType(ctx,""hellotype"",0,&tm);
    if (HelloType == NULL) return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellotype.insert"",
        HelloTypeInsert_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hellotype.range"",
        HelloTypeRange_RedisCommand,""readonly"",1,1,1) == REDISMOD...",1,4,modules\hellotype.c,RedisModule_OnLoad,,false,325,362,RedisModule_OnLoad,,,20,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
206289,METHOD,modules\helloworld.c:<global>,TYPE_DECL,<global>,1,1,modules\helloworld.c,modules\helloworld.c:<global>,,false,1,621,<global>,,,1,
206291,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloSimple_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    RedisModule_ReplyWithLongLong(ctx,RedisModule_GetSelectedDb(ctx));
    return REDISMODULE_OK;
}",1,4,modules\helloworld.c,HelloSimple_RedisCommand,,false,48,53,HelloSimple_RedisCommand,,,1,"int HelloSimple_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206318,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloPushNative_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    RedisModule_ListPush(key,REDISMODULE_LIST_TAIL,argv[2]);
    size_t newlen = RedisModule_ValueLength(key);
    RedisModule_CloseKey(key);
    RedisModule_ReplyWithLongLong(ctx,newlen);
    return REDISMODULE_OK;
}",1,8,modules\helloworld.c,HelloPushNative_RedisCommand,,false,61,73,HelloPushNative_RedisCommand,,,2,"int HelloPushNative_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206374,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloPushCall_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""RPUSH"",""ss"",argv[1],argv[2]);
    long long len = RedisModule_CallReplyInteger(reply);
    RedisModule_FreeCallReply(reply);
    RedisModule_ReplyWithLongLong(ctx,len);
    return REDISMODULE_OK;
}",1,11,modules\helloworld.c,HelloPushCall_RedisCommand,,false,80,91,HelloPushCall_RedisCommand,,,3,"int HelloPushCall_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206416,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloPushCall2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 3) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""RPUSH"",""ss"",argv[1],argv[2]);
    RedisModule_ReplyWithCallReply(ctx,reply);
    RedisModule_FreeCallReply(reply);
    return REDISMODULE_OK;
}",1,11,modules\helloworld.c,HelloPushCall2_RedisCommand,,false,96,106,HelloPushCall2_RedisCommand,,,4,"int HelloPushCall2_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206453,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloListSumLen_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModuleCallReply *reply;

    reply = RedisModule_Call(ctx,""LRANGE"",""sll"",argv[1],(long long)0,(long long)-1);
    size_t strlen = 0;
    size_t items = RedisModule_CallReplyLength(reply);
    size_t j;
    for (j = 0; j < items; j++) {
        RedisModuleCallReply *ele = RedisModule_CallReplyArrayElement(reply,j);
        strlen += RedisModule_CallReplyLength(ele);
    }
    RedisModule_FreeCallReply(reply);
    RedisModule_ReplyWithLongLong(ctx,strlen);
    return REDISMODULE_OK;
}",1,11,modules\helloworld.c,HelloListSumLen_RedisCommand,,false,111,128,HelloListSumLen_RedisCommand,,,5,"int HelloListSumLen_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206525,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloListSplice_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
        REDISMODULE_READ|REDISMODULE_WRITE);

    /* Src and dst key must be empty or lists. */
    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
    {
        RedisModule_CloseKey(srckey);
        RedisModule_CloseKey(dstkey);
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long count;
    if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
        (count < 0)) {
        RedisModule_Cl...",1,8,modules\helloworld.c,HelloListSplice_RedisCommand,,false,134,175,HelloListSplice_RedisCommand,,,6,"int HelloListSplice_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206687,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloListSpliceAuto_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 4) return RedisModule_WrongArity(ctx);

    RedisModule_AutoMemory(ctx);

    RedisModuleKey *srckey = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    RedisModuleKey *dstkey = RedisModule_OpenKey(ctx,argv[2],
        REDISMODULE_READ|REDISMODULE_WRITE);

    /* Src and dst key must be empty or lists. */
    if ((RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(srckey) != REDISMODULE_KEYTYPE_EMPTY) ||
        (RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_LIST &&
         RedisModule_KeyType(dstkey) != REDISMODULE_KEYTYPE_EMPTY))
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    long long count;
    if ((RedisModule_StringToLongLong(argv[3],&count) != REDISMODULE_OK) ||
        (count < 0))
    {
        return RedisModule_ReplyWithError(ctx,""ERR inval...",1,8,modules\helloworld.c,HelloListSpliceAuto_RedisCommand,,false,179,216,HelloListSpliceAuto_RedisCommand,,,7,"int HelloListSpliceAuto_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206836,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloRandArray_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    long long count;
    if (RedisModule_StringToLongLong(argv[1],&count) != REDISMODULE_OK ||
        count < 0)
        return RedisModule_ReplyWithError(ctx,""ERR invalid count"");

    /* To reply with an array, we call RedisModule_ReplyWithArray() followed
     * by other ""count"" calls to other reply functions in order to generate
     * the elements of the array. */
    RedisModule_ReplyWithArray(ctx,count);
    while(count--) RedisModule_ReplyWithLongLong(ctx,rand());
    return REDISMODULE_OK;
}",1,56,modules\helloworld.c,HelloRandArray_RedisCommand,,false,221,234,HelloRandArray_RedisCommand,,,8,"int HelloRandArray_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206885,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloRepl1_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc)
{
    REDISMODULE_NOT_USED(argv);
    REDISMODULE_NOT_USED(argc);
    RedisModule_AutoMemory(ctx);

    /* This will be replicated *after* the two INCR statements, since
     * the Call() replication has precedence, so the actual replication
     * stream will be:
     *
     * MULTI
     * INCR foo
     * INCR bar
     * ECHO c foo
     * EXEC
     */
    RedisModule_Replicate(ctx,""ECHO"",""c"",""foo"");

    /* Using the ""!"" modifier we replicate the command if it
     * modified the dataset in some way. */
    RedisModule_Call(ctx,""INCR"",""c!"",""foo"");
    RedisModule_Call(ctx,""INCR"",""c!"",""bar"");

    RedisModule_ReplyWithLongLong(ctx,0);

    return REDISMODULE_OK;
}",1,4,modules\helloworld.c,HelloRepl1_RedisCommand,,false,240,266,HelloRepl1_RedisCommand,,,9,"int HelloRepl1_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
206928,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloRepl2_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_LIST)
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);

    size_t listlen = RedisModule_ValueLength(key);
    long long sum = 0;

    /* Rotate and increment. */
    while(listlen--) {
        RedisModuleString *ele = RedisModule_ListPop(key,REDISMODULE_LIST_TAIL);
        long long val;
        if (RedisModule_StringToLongLong(ele,&val) != REDISMODULE_OK) val = 0;
        val++;
        sum += val;
        RedisModuleString *newele = RedisModule_CreateStringFromLongLong(ctx,val);
        RedisModule_ListPush(key,REDISMODULE_LIST_HEAD,newele);
    }
    RedisModule_ReplyWithLongLong(...",1,8,modules\helloworld.c,HelloRepl2_RedisCommand,,false,278,304,HelloRepl2_RedisCommand,,,10,"int HelloRepl2_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207039,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloToggleCase_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);

    int keytype = RedisModule_KeyType(key);
    if (keytype != REDISMODULE_KEYTYPE_STRING &&
        keytype != REDISMODULE_KEYTYPE_EMPTY)
    {
        RedisModule_CloseKey(key);
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    if (keytype == REDISMODULE_KEYTYPE_STRING) {
        size_t len, j;
        char *s = RedisModule_StringDMA(key,&len,REDISMODULE_WRITE);
        for (j = 0; j < len; j++) {
            if (isupper(s[j])) {
                s[j] = tolower(s[j]);
            } else {
                s[j] = toupper(s[j]);
            }
        }
    }

    RedisModule_CloseKey(key);
    RedisModule_ReplyWithSimpleString(ctx,""OK"");
    RedisModule_ReplicateVerbatim(ctx);
    return REDISMODU...",1,8,modules\helloworld.c,HelloToggleCase_RedisCommand,,false,314,344,HelloToggleCase_RedisCommand,,,11,"int HelloToggleCase_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207166,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloMoreExpire_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    if (argc != 3) return RedisModule_WrongArity(ctx);

    mstime_t addms, expire;

    if (RedisModule_StringToLongLong(argv[2],&addms) != REDISMODULE_OK)
        return RedisModule_ReplyWithError(ctx,""ERR invalid expire time"");

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    expire = RedisModule_GetExpire(key);
    if (expire != REDISMODULE_NO_EXPIRE) {
        expire += addms;
        RedisModule_SetExpire(key,expire);
    }
    return RedisModule_ReplyWithSimpleString(ctx,""OK"");
}",1,56,modules\helloworld.c,HelloMoreExpire_RedisCommand,,false,350,367,HelloMoreExpire_RedisCommand,,,12,"int HelloMoreExpire_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207242,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloZsumRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    double score_start, score_end;
    if (argc != 4) return RedisModule_WrongArity(ctx);

    if (RedisModule_StringToDouble(argv[2],&score_start) != REDISMODULE_OK ||
        RedisModule_StringToDouble(argv[3],&score_end) != REDISMODULE_OK)
    {
        return RedisModule_ReplyWithError(ctx,""ERR invalid range"");
    }

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    double scoresum_a = 0;
    double scoresum_b = 0;

    RedisModule_ZsetFirstInScoreRange(key,score_start,score_end,0,0);
    while(!RedisModule_ZsetRangeEndReached(key)) {
        double score;
        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
        RedisModule_FreeString(ctx,ele);
       ...",1,60,modules\helloworld.c,HelloZsumRange_RedisCommand,,false,375,421,HelloZsumRange_RedisCommand,,,13,"int HelloZsumRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207400,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloLexRange_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 6) return RedisModule_WrongArity(ctx);

    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    if (RedisModule_KeyType(key) != REDISMODULE_KEYTYPE_ZSET) {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    if (RedisModule_ZsetFirstInLexRange(key,argv[2],argv[3]) != REDISMODULE_OK) {
        return RedisModule_ReplyWithError(ctx,""invalid range"");
    }

    int arraylen = 0;
    RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_LEN);
    while(!RedisModule_ZsetRangeEndReached(key)) {
        double score;
        RedisModuleString *ele = RedisModule_ZsetRangeCurrentElement(key,&score);
        RedisModule_ReplyWithString(ctx,ele);
        RedisModule_FreeString(ctx,ele);
        RedisModule_ZsetRangeNext(key);
    ...",1,8,modules\helloworld.c,HelloLexRange_RedisCommand,,false,430,459,HelloLexRange_RedisCommand,,,14,"int HelloLexRange_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207512,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloHCopy_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */

    if (argc != 4) return RedisModule_WrongArity(ctx);
    RedisModuleKey *key = RedisModule_OpenKey(ctx,argv[1],
        REDISMODULE_READ|REDISMODULE_WRITE);
    int type = RedisModule_KeyType(key);
    if (type != REDISMODULE_KEYTYPE_HASH &&
        type != REDISMODULE_KEYTYPE_EMPTY)
    {
        return RedisModule_ReplyWithError(ctx,REDISMODULE_ERRORMSG_WRONGTYPE);
    }

    /* Get the old field value. */
    RedisModuleString *oldval;
    RedisModule_HashGet(key,REDISMODULE_HASH_NONE,argv[2],&oldval,NULL);
    if (oldval) {
        RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[3],oldval,NULL);
    }
    RedisModule_ReplyWithLongLong(ctx,oldval != NULL);
    return REDISMODULE_OK;
}",1,8,modules\helloworld.c,HelloHCopy_RedisCommand,,false,468,489,HelloHCopy_RedisCommand,,,15,"int HelloHCopy_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207606,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int HelloLeftPad_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    RedisModule_AutoMemory(ctx); /* Use automatic memory management. */
    long long padlen;

    if (argc != 4) return RedisModule_WrongArity(ctx);

    if ((RedisModule_StringToLongLong(argv[2],&padlen) != REDISMODULE_OK) ||
        (padlen< 0)) {
        return RedisModule_ReplyWithError(ctx,""ERR invalid padding length"");
    }
    size_t strlen, chlen;
    const char *str = RedisModule_StringPtrLen(argv[1], &strlen);
    const char *ch = RedisModule_StringPtrLen(argv[3], &chlen);

    /* If the string is already larger than the target len, just return
     * the string itself. */
    if (strlen >= (size_t)padlen)
        return RedisModule_ReplyWithString(ctx,argv[1]);

    /* Padding must be a single character in this simple implementation. */
    if (chlen != 1)
        return RedisModule_ReplyWithError(ctx,
            ""ERR padding must be a single char"");

    /* Here we use our pool al...",1,58,modules\helloworld.c,HelloLeftPad_RedisCommand,,false,509,541,HelloLeftPad_RedisCommand,,,16,"int HelloLeftPad_RedisCommand (RedisModuleCtx*,RedisModuleString**,int)"
207730,METHOD,modules\helloworld.c:<global>,TYPE_DECL,"int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx,""helloworld"",1,REDISMODULE_APIVER_1)
        == REDISMODULE_ERR) return REDISMODULE_ERR;

    /* Log the list of parameters passing loading the module. */
    for (int j = 0; j < argc; j++) {
        const char *s = RedisModule_StringPtrLen(argv[j],NULL);
        printf(""Module loaded with ARGV[%d] = %s\n"", j, s);
    }

    if (RedisModule_CreateCommand(ctx,""hello.simple"",
        HelloSimple_RedisCommand,""readonly"",0,0,0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.native"",
        HelloPushNative_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.call"",
        HelloPushCall_RedisCommand,""write deny-oom"",1,1,1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;

    if (RedisModule_CreateCommand(ctx,""hello.push.call2"",
     ...",1,44,modules\helloworld.c,RedisModule_OnLoad,,false,545,621,RedisModule_OnLoad,,,17,"int RedisModule_OnLoad (RedisModuleCtx*,RedisModuleString**,int)"
208089,METHOD,monotonic.c:<global>,TYPE_DECL,<global>,1,1,monotonic.h,monotonic.c:<global>,,false,1,180,<global>,,,1,
208091,METHOD,monotonic.c:<global>,TYPE_DECL,monotime (*getMonotonicUs)(void) = NULL;,10,39,monotonic.c,getMonotonicUs,,false,12,12,getMonotonicUs,,,1,monotime getMonotonicUs (void)
208102,METHOD,monotonic.c:<global>,TYPE_DECL,"static monotime getMonotonicUs_posix(void) {
    /* clock_gettime() is specified in POSIX.1b (1993).  Even so, some systems
     * did not support this until much later.  CLOCK_MONOTONIC is technically
     * optional and may not be supported - but it appears to be universal.
     * If this is not supported, provide a system-specific alternate version.  */
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ((uint64_t)ts.tv_sec) * 1000000 + ts.tv_nsec / 1000;
}",1,1,monotonic.c,getMonotonicUs_posix,,false,133,141,getMonotonicUs_posix,,,5,monotime getMonotonicUs_posix (void)
208126,METHOD,monotonic.c:<global>,TYPE_DECL,"static void monotonicInit_posix(void) {
    /* Ensure that CLOCK_MONOTONIC is supported.  This should be supported
     * on any reasonably current OS.  If the assertion below fails, provide
     * an appropriate alternate implementation.  */
    struct timespec ts;
    int rc = clock_gettime(CLOCK_MONOTONIC, &ts);
    assert(rc == 0);

    snprintf(monotonic_info_string, sizeof(monotonic_info_string),
            ""POSIX clock_gettime"");
    getMonotonicUs = getMonotonicUs_posix;
}",1,1,monotonic.c,monotonicInit_posix,,false,143,154,monotonicInit_posix,,,6,void monotonicInit_posix (void)
208151,METHOD,monotonic.c:<global>,TYPE_DECL,"const char * monotonicInit(void) {
    #if defined(USE_PROCESSOR_CLOCK) && defined(__x86_64__) && defined(__linux__)
    if (getMonotonicUs == NULL) monotonicInit_x86linux();
    #endif

    #if defined(USE_PROCESSOR_CLOCK) && defined(__aarch64__)
    if (getMonotonicUs == NULL) monotonicInit_aarch64();
    #endif

    if (getMonotonicUs == NULL) monotonicInit_posix();

    return monotonic_info_string;
}",1,1,monotonic.c,monotonicInit,,false,158,170,monotonicInit,,,7,const char* monotonicInit (void)
208164,METHOD,monotonic.c:<global>,TYPE_DECL,"const char *monotonicInfoString(void) {
    return monotonic_info_string;
}",1,1,monotonic.c,monotonicInfoString,,false,172,174,monotonicInfoString,,,8,const char* monotonicInfoString (void)
208171,METHOD,monotonic.c:<global>,TYPE_DECL,"monotonic_clock_type monotonicGetType(void) {
    if (getMonotonicUs == getMonotonicUs_posix)
        return MONOTONIC_CLOCK_POSIX;
    return MONOTONIC_CLOCK_HW;
}",1,1,monotonic.c,monotonicGetType,,false,176,180,monotonicGetType,,,9,monotonic_clock_type monotonicGetType (void)
208194,METHOD,monotonic.h:<global>,TYPE_DECL,<global>,1,1,monotonic.h,monotonic.h:<global>,,false,1,61,<global>,,,1,
208197,METHOD,monotonic.h:<global>,TYPE_DECL,extern monotime (*getMonotonicUs)(void);,17,39,monotonic.h,getMonotonicUs,,false,25,25,getMonotonicUs,,,2,monotime getMonotonicUs (void)
208206,METHOD,monotonic.h:<global>,TYPE_DECL,const char *monotonicInit(void);,12,31,monotonic.h,monotonicInit,,false,36,36,monotonicInit,,,5,char* monotonicInit (void)
208211,METHOD,monotonic.h:<global>,TYPE_DECL,const char *monotonicInfoString(void);,12,37,monotonic.h,monotonicInfoString,,false,39,39,monotonicInfoString,,,6,char* monotonicInfoString (void)
208216,METHOD,monotonic.h:<global>,TYPE_DECL,monotonic_clock_type monotonicGetType(void);,22,43,monotonic.h,monotonicGetType,,false,42,42,monotonicGetType,,,7,monotonic_clock_type monotonicGetType (void)
208221,METHOD,monotonic.h:<global>,TYPE_DECL,"static inline void elapsedStart(monotime *start_time) {
    *start_time = getMonotonicUs();
}",1,1,monotonic.h,elapsedStart,,false,49,51,elapsedStart,,,8,void elapsedStart (monotime*)
208230,METHOD,monotonic.h:<global>,TYPE_DECL,"static inline uint64_t elapsedUs(monotime start_time) {
    return getMonotonicUs() - start_time;
}",1,1,monotonic.h,elapsedUs,,false,53,55,elapsedUs,,,9,uint64_t elapsedUs (monotime)
208239,METHOD,monotonic.h:<global>,TYPE_DECL,"static inline uint64_t elapsedMs(monotime start_time) {
    return elapsedUs(start_time) / 1000;
}",1,1,monotonic.h,elapsedMs,,false,57,59,elapsedMs,,,10,uint64_t elapsedMs (monotime)
208256,METHOD,mt19937-64.c:<global>,TYPE_DECL,<global>,1,1,mt19937-64.c,mt19937-64.c:<global>,,false,1,187,<global>,,,1,
208271,METHOD,mt19937-64.c:<global>,TYPE_DECL,"void init_genrand64(unsigned long long seed)
{
    mt[0] = seed;
    for (mti=1; mti<NN; mti++)
        mt[mti] =  (6364136223846793005ULL * (mt[mti-1] ^ (mt[mti-1] >> 62)) + mti);
}",1,20,mt19937-64.c,init_genrand64,,false,73,78,init_genrand64,,,5,void init_genrand64 (long long unsigned)
208314,METHOD,mt19937-64.c:<global>,TYPE_DECL,"void init_by_array64(unsigned long long init_key[],
                     unsigned long long key_length)
{
    unsigned long long i, j, k;
    init_genrand64(19650218ULL);
    i=1; j=0;
    k = (NN>key_length ? NN : key_length);
    for (; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 62)) * 3935559000370003845ULL))
          + init_key[j] + j; /* non linear */
        i++; j++;
        if (i>=NN) { mt[0] = mt[NN-1]; i=1; }
        if (j>=key_length) j=0;
    }
    for (k=NN-1; k; k--) {
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 62)) * 2862933555777941757ULL))
          - i; /* non linear */
        i++;
        if (i>=NN) { mt[0] = mt[NN-1]; i=1; }
    }

    mt[0] = 1ULL << 63; /* MSB is 1; assuring non-zero initial array */
}",1,9,mt19937-64.c,init_by_array64,,false,83,105,init_by_array64,,,6,"void init_by_array64 (long long unsigned[],long long unsigned)"
208477,METHOD,mt19937-64.c:<global>,TYPE_DECL,"unsigned long long genrand64_int64(void)
{
    int i;
    unsigned long long x;
    static unsigned long long mag01[2]={0ULL, MATRIX_A};

    if (mti >= NN) { /* generate NN words at one time */

        /* if init_genrand64() has not been called, */
        /* a default initial seed is used     */
        if (mti == NN+1)
            init_genrand64(5489ULL);

        for (i=0;i<NN-MM;i++) {
            x = (mt[i]&UM)|(mt[i+1]&LM);
            mt[i] = mt[i+MM] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
        }
        for (;i<NN-1;i++) {
            x = (mt[i]&UM)|(mt[i+1]&LM);
            mt[i] = mt[i+(MM-NN)] ^ (x>>1) ^ mag01[(int)(x&1ULL)];
        }
        x = (mt[NN-1]&UM)|(mt[0]&LM);
        mt[NN-1] = mt[MM-1] ^ (x>>1) ^ mag01[(int)(x&1ULL)];

        mti = 0;
    }

    x = mt[mti++];

    x ^= (x >> 29) & 0x5555555555555555ULL;
    x ^= (x << 17) & 0x71D67FFFEDA60000ULL;
    x ^= (x << 37) & 0xFFF7EEE000000000ULL;
    x ^= (x >> 43);

    return x;
}",1,46,mt19937-64.c,genrand64_int64,,false,108,143,genrand64_int64,,,7,unsigned long long genrand64_int64 (void)
208712,METHOD,mt19937-64.c:<global>,TYPE_DECL,"long long genrand64_int63(void)
{
    return (long long)(genrand64_int64() >> 1);
}",1,1,mt19937-64.c,genrand64_int63,,false,146,149,genrand64_int63,,,8,long long genrand64_int63 (void)
208723,METHOD,mt19937-64.c:<global>,TYPE_DECL,"double genrand64_real1(void)
{
    return (genrand64_int64() >> 11) * (1.0/9007199254740991.0);
}",1,1,mt19937-64.c,genrand64_real1,,false,152,155,genrand64_real1,,,9,double genrand64_real1 (void)
208736,METHOD,mt19937-64.c:<global>,TYPE_DECL,"double genrand64_real2(void)
{
    return (genrand64_int64() >> 11) * (1.0/9007199254740992.0);
}",1,1,mt19937-64.c,genrand64_real2,,false,158,161,genrand64_real2,,,10,double genrand64_real2 (void)
208749,METHOD,mt19937-64.c:<global>,TYPE_DECL,"double genrand64_real3(void)
{
    return ((genrand64_int64() >> 12) + 0.5) * (1.0/4503599627370496.0);
}",1,1,mt19937-64.c,genrand64_real3,,false,164,167,genrand64_real3,,,11,double genrand64_real3 (void)
208767,METHOD,mt19937-64.h:<global>,TYPE_DECL,<global>,1,6,mt19937-64.h,mt19937-64.h:<global>,,false,1,87,<global>,,,1,
208769,METHOD,mt19937-64.h:<global>,TYPE_DECL,void init_genrand64(unsigned long long seed);,6,44,mt19937-64.h,init_genrand64,,false,60,60,init_genrand64,,,1,void init_genrand64 (long long unsigned)
208774,METHOD,mt19937-64.h:<global>,TYPE_DECL,"void init_by_array64(unsigned long long init_key[],
                     unsigned long long key_length);",6,51,mt19937-64.h,init_by_array64,,false,65,66,init_by_array64,,,2,"void init_by_array64 (long long unsigned[],long long unsigned)"
208780,METHOD,mt19937-64.h:<global>,TYPE_DECL,unsigned long long genrand64_int64(void);,20,40,mt19937-64.h,genrand64_int64,,false,69,69,genrand64_int64,,,3,long long unsigned genrand64_int64 (void)
208785,METHOD,mt19937-64.h:<global>,TYPE_DECL,long long genrand64_int63(void);,11,31,mt19937-64.h,genrand64_int63,,false,73,73,genrand64_int63,,,4,long long genrand64_int63 (void)
208790,METHOD,mt19937-64.h:<global>,TYPE_DECL,double genrand64_real1(void);,8,28,mt19937-64.h,genrand64_real1,,false,76,76,genrand64_real1,,,5,double genrand64_real1 (void)
208795,METHOD,mt19937-64.h:<global>,TYPE_DECL,double genrand64_real2(void);,8,28,mt19937-64.h,genrand64_real2,,false,79,79,genrand64_real2,,,6,double genrand64_real2 (void)
208800,METHOD,mt19937-64.h:<global>,TYPE_DECL,double genrand64_real3(void);,8,28,mt19937-64.h,genrand64_real3,,false,82,82,genrand64_real3,,,7,double genrand64_real3 (void)
208805,METHOD,mt19937-64.h:<global>,TYPE_DECL,double genrand64_real4(void);,8,28,mt19937-64.h,genrand64_real4,,false,85,85,genrand64_real4,,,8,double genrand64_real4 (void)
208815,METHOD,multi.c:<global>,TYPE_DECL,<global>,1,1,multi.c,multi.c:<global>,,false,1,500,<global>,,,1,
208817,METHOD,multi.c:<global>,TYPE_DECL,"void initClientMultiState(client *c) {
    c->mstate.commands = NULL;
    c->mstate.count = 0;
    c->mstate.cmd_flags = 0;
    c->mstate.cmd_inv_flags = 0;
    c->mstate.argv_len_sums = 0;
    c->mstate.alloc_count = 0;
}",1,1,multi.c,initClientMultiState,,false,35,42,initClientMultiState,,,1,void initClientMultiState (client*)
208864,METHOD,multi.c:<global>,TYPE_DECL,"void freeClientMultiState(client *c) {
    int j;

    for (j = 0; j < c->mstate.count; j++) {
        int i;
        multiCmd *mc = c->mstate.commands+j;

        for (i = 0; i < mc->argc; i++)
            decrRefCount(mc->argv[i]);
        zfree(mc->argv);
    }
    zfree(c->mstate.commands);
}",1,1,multi.c,freeClientMultiState,,false,45,57,freeClientMultiState,,,2,void freeClientMultiState (client*)
208924,METHOD,multi.c:<global>,TYPE_DECL,"void queueMultiCommand(client *c, uint64_t cmd_flags) {
    multiCmd *mc;

    /* No sense to waste memory if the transaction is already aborted.
     * this is useful in case client sends these in a pipeline, or doesn't
     * bother to read previous responses and didn't notice the multi was already
     * aborted. */
    if (c->flags & (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC))
        return;
    if (c->mstate.count == 0) {
        /* If a client is using multi/exec, assuming it is used to execute at least
         * two commands. Hence, creating by default size of 2. */
        c->mstate.commands = zmalloc(sizeof(multiCmd)*2);
        c->mstate.alloc_count = 2;
    }
    if (c->mstate.count == c->mstate.alloc_count) {
        c->mstate.alloc_count = c->mstate.alloc_count < INT_MAX/2 ? c->mstate.alloc_count*2 : INT_MAX;
        c->mstate.commands = zrealloc(c->mstate.commands, sizeof(multiCmd)*(c->mstate.alloc_count));
    }
    mc = c->mstate.commands+c->mstate.count;
    mc->cmd = c...",1,20,multi.c,queueMultiCommand,,false,60,96,queueMultiCommand,,,3,"void queueMultiCommand (client*,uint64_t)"
209131,METHOD,multi.c:<global>,TYPE_DECL,"void discardTransaction(client *c) {
    freeClientMultiState(c);
    initClientMultiState(c);
    c->flags &= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);
    unwatchAllKeys(c);
}",1,18,multi.c,discardTransaction,,false,98,103,discardTransaction,,,4,void discardTransaction (client*)
209164,METHOD,multi.c:<global>,TYPE_DECL,"void flagTransaction(client *c) {
    if (c->flags & CLIENT_MULTI)
        c->flags |= CLIENT_DIRTY_EXEC;
}",1,19,multi.c,flagTransaction,,false,107,110,flagTransaction,,,5,void flagTransaction (client*)
209189,METHOD,multi.c:<global>,TYPE_DECL,"void multiCommand(client *c) {
    if (c->flags & CLIENT_MULTI) {
        addReplyError(c,""MULTI calls can not be nested"");
        return;
    }
    c->flags |= CLIENT_MULTI;

    addReply(c,shared.ok);
}",1,19,multi.c,multiCommand,,false,112,120,multiCommand,,,6,void multiCommand (client*)
209223,METHOD,multi.c:<global>,TYPE_DECL,"void discardCommand(client *c) {
    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,""DISCARD without MULTI"");
        return;
    }
    discardTransaction(c);
    addReply(c,shared.ok);
}",1,21,multi.c,discardCommand,,false,122,129,discardCommand,,,7,void discardCommand (client*)
209251,METHOD,multi.c:<global>,TYPE_DECL,"void execCommandAbort(client *c, sds error) {
    discardTransaction(c);

    if (error[0] == '-') error++;
    addReplyErrorFormat(c, ""-EXECABORT Transaction discarded because of: %s"", error);

    /* Send EXEC to clients waiting data from MONITOR. We did send a MULTI
     * already, and didn't send any of the queued commands, now we'll just send
     * EXEC so it is clear that the transaction is over. */
    replicationFeedMonitors(c,server.monitors,c->db->id,c->argv,c->argc);
}",1,1,multi.c,execCommandAbort,,false,136,146,execCommandAbort,,,8,"void execCommandAbort (client*,sds)"
209288,METHOD,multi.c:<global>,TYPE_DECL,"void execCommand(client *c) {
    int j;
    robj **orig_argv;
    int orig_argc, orig_argv_len;
    struct redisCommand *orig_cmd;

    if (!(c->flags & CLIENT_MULTI)) {
        addReplyError(c,""EXEC without MULTI"");
        return;
    }

    /* EXEC with expired watched key is disallowed*/
    if (isWatchedKeyExpired(c)) {
        c->flags |= (CLIENT_DIRTY_CAS);
    }

    /* Check if we need to abort the EXEC because:
     * 1) Some WATCHed key was touched.
     * 2) There was a previous error while queueing commands.
     * A failed EXEC in the first case returns a multi bulk nil object
     * (technically it is not an error but a special behavior), while
     * in the second an EXECABORT error is returned. */
    if (c->flags & (CLIENT_DIRTY_CAS | CLIENT_DIRTY_EXEC)) {
        if (c->flags & CLIENT_DIRTY_EXEC) {
            addReplyErrorObject(c, shared.execaborterr);
        } else {
            addReply(c, shared.nullarray[c->resp]);
        }

        discardTransaction(c);...",1,21,multi.c,execCommand,,false,148,256,execCommand,,,9,void execCommand (client*)
209716,METHOD,multi.c:<global>,TYPE_DECL,"static inline void watchedKeyLinkToClients(list *clients, watchedKey *wk) {
    wk->node.value = clients; /* Point the value back to the list */
    listLinkNodeTail(clients, &wk->node); /* Link the embedded node */
}",1,1,multi.c,watchedKeyLinkToClients,,false,283,286,watchedKeyLinkToClients,,,12,"void watchedKeyLinkToClients (list*,watchedKey*)"
209735,METHOD,multi.c:<global>,TYPE_DECL,"static inline list *watchedKeyGetClients(watchedKey *wk) {
    return listNodeValue(&wk->node); /* embedded node->value points back to the list */
}",1,11,multi.c,watchedKeyGetClients,,false,289,291,watchedKeyGetClients,,,13,list watchedKeyGetClients (watchedKey*)
209753,METHOD,multi.c:<global>,TYPE_DECL,"static inline listNode *watchedKeyGetClientNode(watchedKey *wk) {
    return &wk->node;
}",1,1,multi.c,watchedKeyGetClientNode,,false,295,297,watchedKeyGetClientNode,,,14,listNode watchedKeyGetClientNode (watchedKey*)
209763,METHOD,multi.c:<global>,TYPE_DECL,"void watchForKey(client *c, robj *key) {
    list *clients = NULL;
    listIter li;
    listNode *ln;
    watchedKey *wk;

    /* Check if we are already watching for this key */
    listRewind(c->watched_keys,&li);
    while((ln = listNext(&li))) {
        wk = listNodeValue(ln);
        if (wk->db == c->db && equalStringObjects(key,wk->key))
            return; /* Key already watched */
    }
    /* This key is not already watched in this DB. Let's add it */
    clients = dictFetchValue(c->db->watched_keys,key);
    if (!clients) {
        clients = listCreate();
        dictAdd(c->db->watched_keys,key,clients);
        incrRefCount(key);
    }
    /* Add the new key to the list of keys watched by this client */
    wk = zmalloc(sizeof(*wk));
    wk->key = key;
    wk->client = c;
    wk->db = c->db;
    wk->expired = keyIsExpired(c->db, key);
    incrRefCount(key);
    listAddNodeTail(c->watched_keys, wk);
    watchedKeyLinkToClients(clients, wk);
}",1,13,multi.c,watchForKey,,false,300,329,watchForKey,,,15,"void watchForKey (client*,robj*)"
209881,METHOD,multi.c:<global>,TYPE_DECL,"void unwatchAllKeys(client *c) {
    listIter li;
    listNode *ln;

    if (listLength(c->watched_keys) == 0) return;
    listRewind(c->watched_keys,&li);
    while((ln = listNext(&li))) {
        list *clients;
        watchedKey *wk;

        /* Remove the client's wk from the list of clients watching the key. */
        wk = listNodeValue(ln);
        clients = watchedKeyGetClients(wk);
        serverAssertWithInfo(c,NULL,clients != NULL);
        listUnlinkNode(clients, watchedKeyGetClientNode(wk));
        /* Kill the entry at all if this was the only client */
        if (listLength(clients) == 0)
            dictDelete(wk->db->watched_keys, wk->key);
        /* Remove this watched key from the client->watched list */
        listDelNode(c->watched_keys,ln);
        decrRefCount(wk->key);
        zfree(wk);
    }
}",1,8,multi.c,unwatchAllKeys,,false,333,356,unwatchAllKeys,,,16,void unwatchAllKeys (client*)
209984,METHOD,multi.c:<global>,TYPE_DECL,"int isWatchedKeyExpired(client *c) {
    listIter li;
    listNode *ln;
    watchedKey *wk;
    if (listLength(c->watched_keys) == 0) return 0;
    listRewind(c->watched_keys,&li);
    while ((ln = listNext(&li))) {
        wk = listNodeValue(ln);
        if (wk->expired) continue; /* was expired when WATCH was called */
        if (keyIsExpired(wk->db, wk->key)) return 1;
    }

    return 0;
}",1,8,multi.c,isWatchedKeyExpired,,false,360,373,isWatchedKeyExpired,,,17,int isWatchedKeyExpired (client*)
210048,METHOD,multi.c:<global>,TYPE_DECL,"void touchWatchedKey(redisDb *db, robj *key) {
    list *clients;
    listIter li;
    listNode *ln;

    if (dictSize(db->watched_keys) == 0) return;
    clients = dictFetchValue(db->watched_keys, key);
    if (!clients) return;

    /* Mark all the clients watching this key as CLIENT_DIRTY_CAS */
    /* Check if we are already watching for this key */
    listRewind(clients,&li);
    while((ln = listNext(&li))) {
        watchedKey *wk = redis_member2struct(watchedKey, node, ln);
        client *c = wk->client;

        if (wk->expired) {
            /* The key was already expired when WATCH was called. */
            if (db == wk->db &&
                equalStringObjects(key, wk->key) &&
                dictFind(db->dict, key->ptr) == NULL)
            {
                /* Already expired key is deleted, so logically no change. Clear
                 * the flag. Deleted keys are not flagged as expired. */
                wk->expired = 0;
                goto skip_client;
        ...",1,8,multi.c,touchWatchedKey,,false,377,416,touchWatchedKey,,,18,"void touchWatchedKey (redisDb*,robj*)"
210176,METHOD,multi.c:<global>,TYPE_DECL,"void touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with) {
    listIter li;
    listNode *ln;
    dictEntry *de;

    if (dictSize(emptied->watched_keys) == 0) return;

    dictIterator *di = dictGetSafeIterator(emptied->watched_keys);
    while((de = dictNext(di)) != NULL) {
        robj *key = dictGetKey(de);
        int exists_in_emptied = dictFind(emptied->dict, key->ptr) != NULL;
        if (exists_in_emptied ||
            (replaced_with && dictFind(replaced_with->dict, key->ptr)))
        {
            list *clients = dictGetVal(de);
            if (!clients) continue;
            listRewind(clients,&li);
            while((ln = listNext(&li))) {
                watchedKey *wk = redis_member2struct(watchedKey, node, ln);
                if (wk->expired) {
                    if (!replaced_with || !dictFind(replaced_with->dict, key->ptr)) {
                        /* Expired key now deleted. No logical change. Clear the
                         * flag. Deleted ke...",1,8,multi.c,touchAllWatchedKeysInDb,,false,425,468,touchAllWatchedKeysInDb,,,19,"void touchAllWatchedKeysInDb (redisDb*,redisDb*)"
210358,METHOD,multi.c:<global>,TYPE_DECL,"void watchCommand(client *c) {
    int j;

    if (c->flags & CLIENT_MULTI) {
        addReplyError(c,""WATCH inside MULTI is not allowed"");
        return;
    }
    /* No point in watching if the client is already dirty. */
    if (c->flags & CLIENT_DIRTY_CAS) {
        addReply(c,shared.ok);
        return;
    }
    for (j = 1; j < c->argc; j++)
        watchForKey(c,c->argv[j]);
    addReply(c,shared.ok);
}",1,19,multi.c,watchCommand,,false,470,485,watchCommand,,,20,void watchCommand (client*)
210420,METHOD,multi.c:<global>,TYPE_DECL,"void unwatchCommand(client *c) {
    unwatchAllKeys(c);
    c->flags &= (~CLIENT_DIRTY_CAS);
    addReply(c,shared.ok);
}",1,18,multi.c,unwatchCommand,,false,487,491,unwatchCommand,,,21,void unwatchCommand (client*)
210442,METHOD,multi.c:<global>,TYPE_DECL,"size_t multiStateMemOverhead(client *c) {
    size_t mem = c->mstate.argv_len_sums;
    /* Add watched keys overhead, Note: this doesn't take into account the watched keys themselves, because they aren't managed per-client. */
    mem += listLength(c->watched_keys) * (sizeof(listNode) + sizeof(watchedKey));
    /* Reserved memory for queued multi commands. */
    mem += c->mstate.alloc_count * sizeof(multiCmd);
    return mem;
}",1,11,multi.c,multiStateMemOverhead,,false,493,500,multiStateMemOverhead,,,22,size_t multiStateMemOverhead (client*)
210506,METHOD,networking.c:<global>,TYPE_DECL,<global>,1,1,networking.c,networking.c:<global>,,false,1,4578,<global>,,,1,
210508,METHOD,networking.c:<global>,TYPE_DECL,"static void setProtocolError(const char *errstr, client *c);",13,59,networking.c,setProtocolError,,false,40,40,setProtocolError,,,1,"void setProtocolError (char*,client*)"
210514,METHOD,networking.c:<global>,TYPE_DECL,"static void pauseClientsByClient(mstime_t end, int isPauseClientAll);",13,68,networking.c,pauseClientsByClient,,false,41,41,pauseClientsByClient,,,2,"void pauseClientsByClient (mstime_t,int)"
210520,METHOD,networking.c:<global>,TYPE_DECL,int postponeClientRead(client *c);,5,33,networking.c,postponeClientRead,,false,42,42,postponeClientRead,,,3,int postponeClientRead (client*)
210525,METHOD,networking.c:<global>,TYPE_DECL,char *getClientSockname(client *c);,6,34,networking.c,getClientSockname,,false,43,43,getClientSockname,,,4,char* getClientSockname (client*)
210534,METHOD,networking.c:<global>,TYPE_DECL,"size_t sdsZmallocSize(sds s) {
    void *sh = sdsAllocPtr(s);
    return zmalloc_size(sh);
}",1,1,networking.c,sdsZmallocSize,,false,49,52,sdsZmallocSize,,,7,size_t sdsZmallocSize (sds)
210547,METHOD,networking.c:<global>,TYPE_DECL,"size_t getStringObjectSdsUsedMemory(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    switch(o->encoding) {
    case OBJ_ENCODING_RAW: return sdsZmallocSize(o->ptr);
    case OBJ_ENCODING_EMBSTR: return zmalloc_size(o)-sizeof(robj);
    default: return 0; /* Just integer encoding for now. */
    }
}",1,4,networking.c,getStringObjectSdsUsedMemory,,false,56,63,getStringObjectSdsUsedMemory,,,8,size_t getStringObjectSdsUsedMemory (robj*)
210601,METHOD,networking.c:<global>,TYPE_DECL,"size_t getStringObjectLen(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    switch(o->encoding) {
    case OBJ_ENCODING_RAW: return sdslen(o->ptr);
    case OBJ_ENCODING_EMBSTR: return sdslen(o->ptr);
    default: return 0; /* Just integer encoding for now. */
    }
}",1,4,networking.c,getStringObjectLen,,false,67,74,getStringObjectLen,,,9,size_t getStringObjectLen (robj*)
210654,METHOD,networking.c:<global>,TYPE_DECL,"void *dupClientReplyValue(void *o) {
    clientReplyBlock *old = o;
    clientReplyBlock *buf = zmalloc(sizeof(clientReplyBlock) + old->size);
    memcpy(buf, o, sizeof(clientReplyBlock) + old->size);
    return buf;
}",1,1,networking.c,dupClientReplyValue,,false,77,82,dupClientReplyValue,,,10,void* dupClientReplyValue (void*)
210684,METHOD,networking.c:<global>,TYPE_DECL,"void freeClientReplyValue(void *o) {
    zfree(o);
}",1,1,networking.c,freeClientReplyValue,,false,84,86,freeClientReplyValue,,,11,void freeClientReplyValue (void*)
210691,METHOD,networking.c:<global>,TYPE_DECL,"void linkClient(client *c) {
    listAddNodeTail(server.clients,c);
    /* Note that we remember the linked list node where the client is stored,
     * this way removing the client in unlinkClient() will not require
     * a linear scan, but just a constant time operation. */
    c->client_list_node = listLast(server.clients);
    uint64_t id = htonu64(c->id);
    raxInsert(server.clients_index,(unsigned char*)&id,sizeof(id),c,NULL);
}",1,26,networking.c,linkClient,,false,90,98,linkClient,,,12,void linkClient (client*)
210739,METHOD,networking.c:<global>,TYPE_DECL,"static void clientSetDefaultAuth(client *c) {
    /* If the default user does not require authentication, the user is
     * directly authenticated. */
    c->user = DefaultUser;
    c->authenticated = (c->user->flags & USER_FLAG_NOPASS) &&
                       !(c->user->flags & USER_FLAG_DISABLED);
}",1,41,networking.c,clientSetDefaultAuth,,false,102,108,clientSetDefaultAuth,,,13,void clientSetDefaultAuth (client*)
210777,METHOD,networking.c:<global>,TYPE_DECL,"int authRequired(client *c) {
    /* Check if the user is authenticated. This check is skipped in case
     * the default user is flagged as ""nopass"" and is active. */
    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||
                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&
                        !c->authenticated;
    return auth_required;
}",1,48,networking.c,authRequired,,false,110,117,authRequired,,,14,int authRequired (client*)
210812,METHOD,networking.c:<global>,TYPE_DECL,"client *createClient(connection *conn) {
    client *c = zmalloc(sizeof(client));

    /* passing NULL as conn it is possible to create a non connected client.
     * This is useful since all the commands needs to be executed
     * in the context of a client. When commands are executed in other
     * contexts (for instance a Lua script) we need a non connected client. */
    if (conn) {
        connEnableTcpNoDelay(conn);
        if (server.tcpkeepalive)
            connKeepAlive(conn,server.tcpkeepalive);
        connSetReadHandler(conn, readQueryFromClient);
        connSetPrivateData(conn, c);
    }
    c->buf = zmalloc_usable(PROTO_REPLY_CHUNK_BYTES, &c->buf_usable_size);
    selectDb(c,0);
    uint64_t client_id;
    atomicGetIncr(server.next_client_id, client_id, 1);
    c->id = client_id;
#ifdef LOG_REQ_RES
    reqresReset(c, 0);
    c->resp = server.client_default_resp;
#else
    c->resp = 2;
#endif
    c->conn = conn;
    c->name = NULL;
    c->lib_name = NULL;
    c->lib...",1,28,networking.c,createClient,,false,119,218,createClient,,,15,client createClient (connection*)
211285,METHOD,networking.c:<global>,TYPE_DECL,"void installClientWriteHandler(client *c) {
    int ae_barrier = 0;
    /* For the fsync=always policy, we want that a given FD is never
     * served for reading and writing in the same event loop iteration,
     * so that in the middle of receiving the query, and serving it
     * to the client, we'll call beforeSleep() that will do the
     * actual fsync of AOF to disk. the write barrier ensures that. */
    if (server.aof_state == AOF_ON &&
        server.aof_fsync == AOF_FSYNC_ALWAYS)
    {
        ae_barrier = 1;
    }
    if (connSetWriteHandlerWithBarrier(c->conn, sendReplyToClient, ae_barrier) == C_ERR) {
        freeClientAsync(c);
    }
}",1,28,networking.c,installClientWriteHandler,,false,220,235,installClientWriteHandler,,,16,void installClientWriteHandler (client*)
211329,METHOD,networking.c:<global>,TYPE_DECL,"void putClientInPendingWriteQueue(client *c) {
    /* Schedule the client to write the output buffers to the socket only
     * if not already done and, for slaves, if the slave can actually receive
     * writes at this stage. */
    if (!(c->flags & CLIENT_PENDING_WRITE) &&
        (c->replstate == REPL_STATE_NONE ||
         (c->replstate == SLAVE_STATE_ONLINE && !c->repl_start_cmd_stream_on_ack)))
    {
        /* Here instead of installing the write handler, we just flag the
         * client and put it into a list of clients that have something
         * to write to the socket. This way before re-entering the event
         * loop, we can try to directly write to the client sockets avoiding
         * a system call. We'll only really install the write handler if
         * we'll not be able to write the whole reply at once. */
        c->flags |= CLIENT_PENDING_WRITE;
        listLinkNodeHead(server.clients_pending_write, &c->clients_pending_write_node);
    }
}",1,21,networking.c,putClientInPendingWriteQueue,,false,244,261,putClientInPendingWriteQueue,,,17,void putClientInPendingWriteQueue (client*)
211382,METHOD,networking.c:<global>,TYPE_DECL,"int prepareClientToWrite(client *c) {
    /* If it's the Lua client we always return ok without installing any
     * handler since there is no socket at all. */
    if (c->flags & (CLIENT_SCRIPT|CLIENT_MODULE)) return C_OK;

    /* If CLIENT_CLOSE_ASAP flag is set, we need not write anything. */
    if (c->flags & CLIENT_CLOSE_ASAP) return C_ERR;

    /* CLIENT REPLY OFF / SKIP handling: don't send replies.
     * CLIENT_PUSHING handling: disables the reply silencing flags. */
    if ((c->flags & (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) &&
        !(c->flags & CLIENT_PUSHING)) return C_ERR;

    /* Masters don't receive replies, unless CLIENT_MASTER_FORCE_REPLY flag
     * is set. */
    if ((c->flags & CLIENT_MASTER) &&
        !(c->flags & CLIENT_MASTER_FORCE_REPLY)) return C_ERR;

    if (!c->conn) return C_ERR; /* Fake client for AOF loading. */

    /* Schedule the client to write the output buffers to the socket, unless
     * it should already be setup to do so (it has already ...",1,20,networking.c,prepareClientToWrite,,false,285,317,prepareClientToWrite,,,18,int prepareClientToWrite (client*)
211512,METHOD,networking.c:<global>,TYPE_DECL,"size_t _addReplyToBuffer(client *c, const char *s, size_t len) {
    size_t available = c->buf_usable_size - c->bufpos;

    /* If there already are entries in the reply list, we cannot
     * add anything more to the static buffer. */
    if (listLength(c->reply) > 0) return 0;

    size_t reply_len = len > available ? available : len;
    memcpy(c->buf+c->bufpos,s,reply_len);
    c->bufpos+=reply_len;
    /* We update the buffer peak after appending the reply to the buffer */
    if(c->buf_peak < (size_t)c->bufpos)
        c->buf_peak = (size_t)c->bufpos;
    return reply_len;
}",1,8,networking.c,_addReplyToBuffer,,false,330,344,_addReplyToBuffer,,,19,"size_t _addReplyToBuffer (client*,char*,size_t)"
211591,METHOD,networking.c:<global>,TYPE_DECL,"void _addReplyProtoToList(client *c, list *reply_list, const char *s, size_t len) {
    listNode *ln = listLast(reply_list);
    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;

    /* Note that 'tail' may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used, it sets a dummy node to NULL just
     * to fill it later, when the size of the bulk length is set. */

    /* Append to tail string when possible. */
    if (tail) {
        /* Copy the part we can fit into the tail, and leave the rest for a
         * new node */
        size_t avail = tail->size - tail->used;
        size_t copy = avail >= len? len: avail;
        memcpy(tail->buf + tail->used, s, copy);
        tail->used += copy;
        s += copy;
        len -= copy;
    }
    if (len) {
        /* Create a new node, make sure it is allocated to at
         * least PROTO_REPLY_CHUNK_BYTES */
        size_t usable_size;
        size_t size = len < PROTO_REPLY_CHUNK_BYTES? PROTO_REPL...",1,19,networking.c,_addReplyProtoToList,,false,348,382,_addReplyProtoToList,,,20,"void _addReplyProtoToList (client*,list*,char*,size_t)"
211725,METHOD,networking.c:<global>,TYPE_DECL,"int cmdHasPushAsReply(struct redisCommand *cmd) {
    if (!cmd) return 0;
    return cmd->proc == subscribeCommand  || cmd->proc == unsubscribeCommand ||
           cmd->proc == psubscribeCommand || cmd->proc == punsubscribeCommand ||
           cmd->proc == ssubscribeCommand || cmd->proc == sunsubscribeCommand;
}",1,1,networking.c,cmdHasPushAsReply,,false,387,392,cmdHasPushAsReply,,,21,int cmdHasPushAsReply (redisCommand*)
211772,METHOD,networking.c:<global>,TYPE_DECL,"void _addReplyToBufferOrList(client *c, const char *s, size_t len) {
    if (c->flags & CLIENT_CLOSE_AFTER_REPLY) return;

    /* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the
     * replication link that caused a reply to be generated we'll simply disconnect it.
     * Note this is the simplest way to check a command added a response. Replication links are used to write data but
     * not for responses, so we should normally never get here on a replica client. */
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        sds cmdname = c->lastcmd ? c->lastcmd->fullname : NULL;
        logInvalidUseAndFreeClientAsync(c, ""Replica generated a reply to command '%s'"",
                                        cmdname ? cmdname : ""<unknown>"");
        return;
    }

    /* We call it here because this function may affect the reply
     * buffer offset (see function comment) */
    reqresSaveClientReplyOffset(c);

    /* If we...",1,19,networking.c,_addReplyToBufferOrList,,false,394,426,_addReplyToBufferOrList,,,22,"void _addReplyToBufferOrList (client*,char*,size_t)"
211882,METHOD,networking.c:<global>,TYPE_DECL,"void addReply(client *c, robj *obj) {
    if (prepareClientToWrite(c) != C_OK) return;

    if (sdsEncodedObject(obj)) {
        _addReplyToBufferOrList(c,obj->ptr,sdslen(obj->ptr));
    } else if (obj->encoding == OBJ_ENCODING_INT) {
        /* For integer encoded strings we just convert it into a string
         * using our optimized function, and attach the resulting string
         * to the output buffer. */
        char buf[32];
        size_t len = ll2string(buf,sizeof(buf),(long)obj->ptr);
        _addReplyToBufferOrList(c,buf,len);
    } else {
        serverPanic(""Wrong obj->encoding in addReply()"");
    }
}",1,35,networking.c,addReply,,false,434,449,addReply,,,23,"void addReply (client*,robj*)"
211960,METHOD,networking.c:<global>,TYPE_DECL,"void addReplySds(client *c, sds s) {
    if (prepareClientToWrite(c) != C_OK) {
        /* The caller expects the sds to be free'd. */
        sdsfree(s);
        return;
    }
    _addReplyToBufferOrList(c,s,sdslen(s));
    sdsfree(s);
}",1,35,networking.c,addReplySds,,false,453,461,addReplySds,,,24,"void addReplySds (client*,sds)"
211984,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyProto(client *c, const char *s, size_t len) {
    if (prepareClientToWrite(c) != C_OK) return;
    _addReplyToBufferOrList(c,s,len);
}",1,35,networking.c,addReplyProto,,false,471,474,addReplyProto,,,25,"void addReplyProto (client*,char*,size_t)"
212004,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorLength(client *c, const char *s, size_t len) {
    /* If the string already starts with ""-..."" then the error code
     * is provided by the caller. Otherwise we use ""-ERR"". */
    if (!len || s[0] != '-') addReplyProto(c,""-ERR "",5);
    addReplyProto(c,s,len);
    addReplyProto(c,""\r\n"",2);
}",1,1,networking.c,addReplyErrorLength,,false,485,491,addReplyErrorLength,,,26,"void addReplyErrorLength (client*,char*,size_t)"
212033,METHOD,networking.c:<global>,TYPE_DECL,"void afterErrorReply(client *c, const char *s, size_t len, int flags) {
    /* Module clients fall into two categories:
     * Calls to RM_Call, in which case the error isn't being returned to a client, so should not be counted.
     * Module thread safe context calls to RM_ReplyWithError, which will be added to a real client by the main thread later. */
    if (c->flags & CLIENT_MODULE) {
        if (!c->deferred_reply_errors) {
            c->deferred_reply_errors = listCreate();
            listSetFreeMethod(c->deferred_reply_errors, (void (*)(void*))sdsfree);
        }
        listAddNodeTail(c->deferred_reply_errors, sdsnewlen(s, len));
        return;
    }

    if (!(flags & ERR_REPLY_FLAG_NO_STATS_UPDATE)) {
        /* Increment the global error counter */
        server.stat_total_error_replies++;
        /* Increment the error stats
         * If the string already starts with ""-..."" then the error prefix
         * is provided by the caller ( we limit the search to 32 cha...",1,19,networking.c,afterErrorReply,,false,496,587,afterErrorReply,,,27,"void afterErrorReply (client*,char*,size_t,int)"
212351,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorObject(client *c, robj *err) {
    addReply(c, err);
    afterErrorReply(c, err->ptr, sdslen(err->ptr)-2, 0); /* Ignore trailing \r\n */
}",1,1,networking.c,addReplyErrorObject,,false,591,594,addReplyErrorObject,,,28,"void addReplyErrorObject (client*,robj*)"
212372,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyOrErrorObject(client *c, robj *reply) {
    serverAssert(sdsEncodedObject(reply));
    sds rep = reply->ptr;
    if (sdslen(rep) > 1 && rep[0] == '-') {
        addReplyErrorObject(c, reply);
    } else {
        addReply(c, reply);
    }
}",1,4,networking.c,addReplyOrErrorObject,,false,601,609,addReplyOrErrorObject,,,29,"void addReplyOrErrorObject (client*,robj*)"
212428,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyError(client *c, const char *err) {
    addReplyErrorLength(c,err,strlen(err));
    afterErrorReply(c,err,strlen(err),0);
}",1,1,networking.c,addReplyError,,false,612,615,addReplyError,,,30,"void addReplyError (client*,char*)"
212445,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorSdsEx(client *c, sds err, int flags) {
    addReplyErrorLength(c,err,sdslen(err));
    afterErrorReply(c,err,sdslen(err),flags);
    sdsfree(err);
}",1,1,networking.c,addReplyErrorSdsEx,,false,620,624,addReplyErrorSdsEx,,,31,"void addReplyErrorSdsEx (client*,sds,int)"
212465,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorSds(client *c, sds err) {
    addReplyErrorSdsEx(c, err, 0);
}",1,1,networking.c,addReplyErrorSds,,false,628,630,addReplyErrorSds,,,32,"void addReplyErrorSds (client*,sds)"
212475,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorSdsSafe(client *c, sds err) {
    err = sdsmapchars(err, ""\r\n"", ""  "",  2);
    addReplyErrorSdsEx(c, err, 0);
}",1,1,networking.c,addReplyErrorSdsSafe,,false,634,637,addReplyErrorSdsSafe,,,33,"void addReplyErrorSdsSafe (client*,sds)"
212492,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorFormatInternal(client *c, int flags, const char *fmt, va_list ap) {
    va_list cpy;
    va_copy(cpy,ap);
    sds s = sdscatvprintf(sdsempty(),fmt,cpy);
    va_end(cpy);
    /* Trim any newlines at the end (ones will be added by addReplyErrorLength) */
    s = sdstrim(s, ""\r\n"");
    /* Make sure there are no newlines in the middle of the string, otherwise
     * invalid protocol is emitted. */
    s = sdsmapchars(s, ""\r\n"", ""  "",  2);
    addReplyErrorLength(c,s,sdslen(s));
    afterErrorReply(c,s,sdslen(s),flags);
    sdsfree(s);
}",1,1,networking.c,addReplyErrorFormatInternal,,false,641,654,addReplyErrorFormatInternal,,,34,"void addReplyErrorFormatInternal (client*,int,char*,va_list)"
212538,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorFormatEx(client *c, int flags, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    addReplyErrorFormatInternal(c, flags, fmt, ap);
    va_end(ap);
}",1,1,networking.c,addReplyErrorFormatEx,,false,656,661,addReplyErrorFormatEx,,,35,"void addReplyErrorFormatEx (client*,int,char*...)"
212556,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    addReplyErrorFormatInternal(c, 0, fmt, ap);
    va_end(ap);
}",1,1,networking.c,addReplyErrorFormat,,false,665,670,addReplyErrorFormat,,,36,"void addReplyErrorFormat (client*,char*...)"
212573,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorArity(client *c) {
    addReplyErrorFormat(c, ""wrong number of arguments for '%s' command"",
                        c->cmd->fullname);
}",1,1,networking.c,addReplyErrorArity,,false,672,675,addReplyErrorArity,,,37,void addReplyErrorArity (client*)
212586,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyErrorExpireTime(client *c) {
    addReplyErrorFormat(c, ""invalid expire time in '%s' command"",
                        c->cmd->fullname);
}",1,1,networking.c,addReplyErrorExpireTime,,false,677,680,addReplyErrorExpireTime,,,38,void addReplyErrorExpireTime (client*)
212599,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyStatusLength(client *c, const char *s, size_t len) {
    addReplyProto(c,""+"",1);
    addReplyProto(c,s,len);
    addReplyProto(c,""\r\n"",2);
}",1,1,networking.c,addReplyStatusLength,,false,682,686,addReplyStatusLength,,,39,"void addReplyStatusLength (client*,char*,size_t)"
212618,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyStatus(client *c, const char *status) {
    addReplyStatusLength(c,status,strlen(status));
}",1,1,networking.c,addReplyStatus,,false,688,690,addReplyStatus,,,40,"void addReplyStatus (client*,char*)"
212629,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyStatusFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    sds s = sdscatvprintf(sdsempty(),fmt,ap);
    va_end(ap);
    addReplyStatusLength(c,s,sdslen(s));
    sdsfree(s);
}",1,1,networking.c,addReplyStatusFormat,,false,692,699,addReplyStatusFormat,,,41,"void addReplyStatusFormat (client*,char*...)"
212655,METHOD,networking.c:<global>,TYPE_DECL,"void trimReplyUnusedTailSpace(client *c) {
    listNode *ln = listLast(c->reply);
    clientReplyBlock *tail = ln? listNodeValue(ln): NULL;

    /* Note that 'tail' may be NULL even if we have a tail node, because when
     * addReplyDeferredLen() is used */
    if (!tail) return;

    /* We only try to trim the space is relatively high (more than a 1/4 of the
     * allocation), otherwise there's a high chance realloc will NOP.
     * Also, to avoid large memmove which happens as part of realloc, we only do
     * that if the used part is small.  */
    if (tail->size - tail->used > tail->size / 4 &&
        tail->used < PROTO_REPLY_CHUNK_BYTES)
    {
        size_t usable_size;
        size_t old_size = tail->size;
        tail = zrealloc_usable(tail, tail->used + sizeof(clientReplyBlock), &usable_size);
        /* take over the allocation's internal fragmentation (at least for
         * memory usage tracking) */
        tail->size = usable_size - sizeof(clientReplyBlock);
      ...",1,19,networking.c,trimReplyUnusedTailSpace,,false,704,728,trimReplyUnusedTailSpace,,,42,void trimReplyUnusedTailSpace (client*)
212763,METHOD,networking.c:<global>,TYPE_DECL,"void *addReplyDeferredLen(client *c) {
    /* Note that we install the write event here even if the object is not
     * ready to be sent, since we are sure that before returning to the
     * event loop setDeferredAggregateLen() will be called. */
    if (prepareClientToWrite(c) != C_OK) return NULL;

    /* Replicas should normally not cause any writes to the reply buffer. In case a rogue replica sent a command on the
     * replication link that caused a reply to be generated we'll simply disconnect it.
     * Note this is the simplest way to check a command added a response. Replication links are used to write data but
     * not for responses, so we should normally never get here on a replica client. */
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        sds cmdname = c->lastcmd ? c->lastcmd->fullname : NULL;
        logInvalidUseAndFreeClientAsync(c, ""Replica generated a reply to command '%s'"",
                                        cmdname ? cmdname : ""<unknown>"");
    ...",1,35,networking.c,addReplyDeferredLen,,false,732,756,addReplyDeferredLen,,,43,void* addReplyDeferredLen (client*)
212828,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredReply(client *c, void *node, const char *s, size_t length) {
    listNode *ln = (listNode*)node;
    clientReplyBlock *next, *prev;

    /* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addReplyDeferredLen() */
    if (node == NULL) return;
    serverAssert(!listNodeValue(ln));

    /* Normally we fill this dummy NULL node, added by addReplyDeferredLen(),
     * with a new buffer structure containing the protocol needed to specify
     * the length of the array following. However sometimes there might be room
     * in the previous/next node so we can instead remove this NULL node, and
     * suffix/prefix our data in the node immediately before/after it, in order
     * to save a write(2) syscall later. Conditions needed to do it:
     *
     * - The prev node is non-NULL and has space in it or
     * - The next node is non-NULL,
     * - It has enough room already allocated
     * - And not too large (avoid large memmov...",1,4,networking.c,setDeferredReply,,false,758,815,setDeferredReply,,,44,"void setDeferredReply (client*,void*,char*,size_t)"
213067,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredAggregateLen(client *c, void *node, long length, char prefix) {
    serverAssert(length >= 0);

    /* Abort when *node is NULL: when the client should not accept writes
     * we return NULL in addReplyDeferredLen() */
    if (node == NULL) return;

    /* Things like *2\r\n, %3\r\n or ~4\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */
    const size_t hdr_len = OBJ_SHARED_HDR_STRLEN(length);
    const int opt_hdr = length < OBJ_SHARED_BULKHDR_LEN;
    if (prefix == '*' && opt_hdr) {
        setDeferredReply(c, node, shared.mbulkhdr[length]->ptr, hdr_len);
        return;
    }
    if (prefix == '%' && opt_hdr) {
        setDeferredReply(c, node, shared.maphdr[length]->ptr, hdr_len);
        return;
    }
    if (prefix == '~' && opt_hdr) {
        setDeferredReply(c, node, shared.sethdr[length]->ptr, hdr_len);
        return;
    }

    char lenstr[128];
    siz...",1,4,networking.c,setDeferredAggregateLen,,false,818,846,setDeferredAggregateLen,,,45,"void setDeferredAggregateLen (client*,void*,long,char)"
213190,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredArrayLen(client *c, void *node, long length) {
    setDeferredAggregateLen(c,node,length,'*');
}",1,1,networking.c,setDeferredArrayLen,,false,848,850,setDeferredArrayLen,,,46,"void setDeferredArrayLen (client*,void*,long)"
213202,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredMapLen(client *c, void *node, long length) {
    int prefix = c->resp == 2 ? '*' : '%';
    if (c->resp == 2) length *= 2;
    setDeferredAggregateLen(c,node,length,prefix);
}",1,1,networking.c,setDeferredMapLen,,false,852,856,setDeferredMapLen,,,47,"void setDeferredMapLen (client*,void*,long)"
213235,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredSetLen(client *c, void *node, long length) {
    int prefix = c->resp == 2 ? '*' : '~';
    setDeferredAggregateLen(c,node,length,prefix);
}",1,1,networking.c,setDeferredSetLen,,false,858,861,setDeferredSetLen,,,48,"void setDeferredSetLen (client*,void*,long)"
213258,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredAttributeLen(client *c, void *node, long length) {
    serverAssert(c->resp >= 3);
    setDeferredAggregateLen(c,node,length,'|');
}",1,4,networking.c,setDeferredAttributeLen,,false,863,866,setDeferredAttributeLen,,,49,"void setDeferredAttributeLen (client*,void*,long)"
213288,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredPushLen(client *c, void *node, long length) {
    serverAssert(c->resp >= 3);
    setDeferredAggregateLen(c,node,length,'>');
}",1,4,networking.c,setDeferredPushLen,,false,868,871,setDeferredPushLen,,,50,"void setDeferredPushLen (client*,void*,long)"
213318,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyDouble(client *c, double d) {
    if (c->resp == 3) {
        char dbuf[MAX_D2STRING_CHARS+3];
        dbuf[0] = ',';
        const int dlen = d2string(dbuf+1,sizeof(dbuf)-1,d);
        dbuf[dlen+1] = '\r';
        dbuf[dlen+2] = '\n';
        dbuf[dlen+3] = '\0';
        addReplyProto(c,dbuf,dlen+3);
    } else {
        char dbuf[MAX_LONG_DOUBLE_CHARS+32];
        /* In order to prepend the string length before the formatted number,
         * but still avoid an extra memcpy of the whole number, we reserve space
         * for maximum header `$0000\r\n`, print double, add the resp header in
         * front of it, and then send the buffer with the right `start` offset. */
        const int dlen = d2string(dbuf+7,sizeof(dbuf)-7,d);
        int digits = digits10(dlen);
        int start = 4 - digits;
        serverAssert(start >= 0);
        dbuf[start] = '$';

        /* Convert `dlen` to string, putting it's digits after '$' and before the
            * formatted doub...",1,18,networking.c,addReplyDouble,,false,874,907,addReplyDouble,,,51,"void addReplyDouble (client*,double)"
213497,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBigNum(client *c, const char* num, size_t len) {
    if (c->resp == 2) {
        addReplyBulkCBuffer(c, num, len);
    } else {
        addReplyProto(c,""("",1);
        addReplyProto(c,num,len);
        addReplyProto(c,""\r\n"",2);
    }
}",1,1,networking.c,addReplyBigNum,,false,909,917,addReplyBigNum,,,52,"void addReplyBigNum (client*,char*,size_t)"
213529,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyHumanLongDouble(client *c, long double d) {
    if (c->resp == 2) {
        robj *o = createStringObjectFromLongDouble(d,1);
        addReplyBulk(c,o);
        decrRefCount(o);
    } else {
        char buf[MAX_LONG_DOUBLE_CHARS];
        int len = ld2string(buf,sizeof(buf),d,LD_STR_HUMAN);
        addReplyProto(c,"","",1);
        addReplyProto(c,buf,len);
        addReplyProto(c,""\r\n"",2);
    }
}",1,17,networking.c,addReplyHumanLongDouble,,false,922,934,addReplyHumanLongDouble,,,53,"void addReplyHumanLongDouble (client*,long double)"
213577,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyLongLongWithPrefix(client *c, long long ll, char prefix) {
    char buf[128];
    int len;

    /* Things like $3\r\n or *2\r\n are emitted very often by the protocol
     * so we have a few shared objects to use if the integer is small
     * like it is most of the times. */
    const int opt_hdr = ll < OBJ_SHARED_BULKHDR_LEN && ll >= 0;
    const size_t hdr_len = OBJ_SHARED_HDR_STRLEN(ll);
    if (prefix == '*' && opt_hdr) {
        addReplyProto(c,shared.mbulkhdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '$' && opt_hdr) {
        addReplyProto(c,shared.bulkhdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '%' && opt_hdr) {
        addReplyProto(c,shared.maphdr[ll]->ptr,hdr_len);
        return;
    } else if (prefix == '~' && opt_hdr) {
        addReplyProto(c,shared.sethdr[ll]->ptr,hdr_len);
        return;
    }

    buf[0] = prefix;
    len = ll2string(buf+1,sizeof(buf)-1,ll);
    buf[len+1] = '\r';
    buf[len+2] = '\n';
    addRep...",1,29,networking.c,addReplyLongLongWithPrefix,,false,938,966,addReplyLongLongWithPrefix,,,54,"void addReplyLongLongWithPrefix (client*,long long,char)"
213724,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyLongLong(client *c, long long ll) {
    if (ll == 0)
        addReply(c,shared.czero);
    else if (ll == 1)
        addReply(c,shared.cone);
    else
        addReplyLongLongWithPrefix(c,ll,':');
}",1,1,networking.c,addReplyLongLong,,false,968,975,addReplyLongLong,,,55,"void addReplyLongLong (client*,long long)"
213758,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyAggregateLen(client *c, long length, int prefix) {
    serverAssert(length >= 0);
    addReplyLongLongWithPrefix(c,length,prefix);
}",1,4,networking.c,addReplyAggregateLen,,false,977,980,addReplyAggregateLen,,,56,"void addReplyAggregateLen (client*,long,int)"
213785,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyArrayLen(client *c, long length) {
    addReplyAggregateLen(c,length,'*');
}",1,1,networking.c,addReplyArrayLen,,false,982,984,addReplyArrayLen,,,57,"void addReplyArrayLen (client*,long)"
213795,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyMapLen(client *c, long length) {
    int prefix = c->resp == 2 ? '*' : '%';
    if (c->resp == 2) length *= 2;
    addReplyAggregateLen(c,length,prefix);
}",1,1,networking.c,addReplyMapLen,,false,986,990,addReplyMapLen,,,58,"void addReplyMapLen (client*,long)"
213826,METHOD,networking.c:<global>,TYPE_DECL,"void addReplySetLen(client *c, long length) {
    int prefix = c->resp == 2 ? '*' : '~';
    addReplyAggregateLen(c,length,prefix);
}",1,1,networking.c,addReplySetLen,,false,992,995,addReplySetLen,,,59,"void addReplySetLen (client*,long)"
213847,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyAttributeLen(client *c, long length) {
    serverAssert(c->resp >= 3);
    addReplyAggregateLen(c,length,'|');
}",1,4,networking.c,addReplyAttributeLen,,false,997,1000,addReplyAttributeLen,,,60,"void addReplyAttributeLen (client*,long)"
213875,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyPushLen(client *c, long length) {
    serverAssert(c->resp >= 3);
    serverAssertWithInfo(c, NULL, c->flags & CLIENT_PUSHING);
    addReplyAggregateLen(c,length,'>');
}",1,4,networking.c,addReplyPushLen,,false,1002,1006,addReplyPushLen,,,61,"void addReplyPushLen (client*,long)"
213927,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyNull(client *c) {
    if (c->resp == 2) {
        addReplyProto(c,""$-1\r\n"",5);
    } else {
        addReplyProto(c,""_\r\n"",3);
    }
}",1,1,networking.c,addReplyNull,,false,1008,1014,addReplyNull,,,62,void addReplyNull (client*)
213949,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBool(client *c, int b) {
    if (c->resp == 2) {
        addReply(c, b ? shared.cone : shared.czero);
    } else {
        addReplyProto(c, b ? ""#t\r\n"" : ""#f\r\n"",4);
    }
}",1,1,networking.c,addReplyBool,,false,1016,1022,addReplyBool,,,63,"void addReplyBool (client*,int)"
213981,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyNullArray(client *c) {
    if (c->resp == 2) {
        addReplyProto(c,""*-1\r\n"",5);
    } else {
        addReplyProto(c,""_\r\n"",3);
    }
}",1,1,networking.c,addReplyNullArray,,false,1028,1034,addReplyNullArray,,,64,void addReplyNullArray (client*)
214003,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBulkLen(client *c, robj *obj) {
    size_t len = stringObjectLen(obj);

    addReplyLongLongWithPrefix(c,len,'$');
}",1,1,networking.c,addReplyBulkLen,,false,1037,1041,addReplyBulkLen,,,65,"void addReplyBulkLen (client*,robj*)"
214018,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBulk(client *c, robj *obj) {
    addReplyBulkLen(c,obj);
    addReply(c,obj);
    addReplyProto(c,""\r\n"",2);
}",1,1,networking.c,addReplyBulk,,false,1044,1048,addReplyBulk,,,66,"void addReplyBulk (client*,robj*)"
214034,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBulkCBuffer(client *c, const void *p, size_t len) {
    addReplyLongLongWithPrefix(c,len,'$');
    addReplyProto(c,p,len);
    addReplyProto(c,""\r\n"",2);
}",1,1,networking.c,addReplyBulkCBuffer,,false,1051,1055,addReplyBulkCBuffer,,,67,"void addReplyBulkCBuffer (client*,void*,size_t)"
214053,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBulkSds(client *c, sds s)  {
    addReplyLongLongWithPrefix(c,sdslen(s),'$');
    addReplySds(c,s);
    addReplyProto(c,""\r\n"",2);
}",1,1,networking.c,addReplyBulkSds,,false,1058,1062,addReplyBulkSds,,,68,"void addReplyBulkSds (client*,sds)"
214071,METHOD,networking.c:<global>,TYPE_DECL,"void setDeferredReplyBulkSds(client *c, void *node, sds s) {
    sds reply = sdscatprintf(sdsempty(), ""$%d\r\n%s\r\n"", (unsigned)sdslen(s), s);
    setDeferredReply(c, node, reply, sdslen(reply));
    sdsfree(reply);
    sdsfree(s);
}",1,1,networking.c,setDeferredReplyBulkSds,,false,1065,1070,setDeferredReplyBulkSds,,,69,"void setDeferredReplyBulkSds (client*,void*,sds)"
214099,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBulkCString(client *c, const char *s) {
    if (s == NULL) {
        addReplyNull(c);
    } else {
        addReplyBulkCBuffer(c,s,strlen(s));
    }
}",1,1,networking.c,addReplyBulkCString,,false,1073,1079,addReplyBulkCString,,,70,"void addReplyBulkCString (client*,char*)"
214119,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyBulkLongLong(client *c, long long ll) {
    char buf[64];
    int len;

    len = ll2string(buf,64,ll);
    addReplyBulkCBuffer(c,buf,len);
}",1,1,networking.c,addReplyBulkLongLong,,false,1082,1088,addReplyBulkLongLong,,,71,"void addReplyBulkLongLong (client*,long long)"
214137,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyVerbatim(client *c, const char *s, size_t len, const char *ext) {
    if (c->resp == 2) {
        addReplyBulkCBuffer(c,s,len);
    } else {
        char buf[32];
        size_t preflen = snprintf(buf,sizeof(buf),""=%zu\r\nxxx:"",len+4);
        char *p = buf+preflen-4;
        for (int i = 0; i < 3; i++) {
            if (*ext == '\0') {
                p[i] = ' ';
            } else {
                p[i] = *ext++;
            }
        }
        addReplyProto(c,buf,preflen);
        addReplyProto(c,s,len);
        addReplyProto(c,""\r\n"",2);
    }
}",1,1,networking.c,addReplyVerbatim,,false,1099,1117,addReplyVerbatim,,,72,"void addReplyVerbatim (client*,char*,size_t,char*)"
214222,METHOD,networking.c:<global>,TYPE_DECL,"void addReplyHelp(client *c, const char **help) {
    sds cmd = sdsnew((char*) c->argv[0]->ptr);
    void *blenp = addReplyDeferredLen(c);
    int blen = 0;

    sdstoupper(cmd);
    addReplyStatusFormat(c,
        ""%s <subcommand> [<arg> [value] [opt] ...]. Subcommands are:"",cmd);
    sdsfree(cmd);

    while (help[blen]) addReplyStatus(c,help[blen++]);

    addReplyStatus(c,""HELP"");
    addReplyStatus(c,""    Print this help."");

    blen += 1;  /* Account for the header. */
    blen += 2;  /* Account for the footer. */
    setDeferredArrayLen(c,blenp,blen);
}",1,1,networking.c,addReplyHelp,,false,1123,1141,addReplyHelp,,,73,"void addReplyHelp (client*,char**)"
214284,METHOD,networking.c:<global>,TYPE_DECL,"void addReplySubcommandSyntaxError(client *c) {
    sds cmd = sdsnew((char*) c->argv[0]->ptr);
    sdstoupper(cmd);
    addReplyErrorFormat(c,
        ""unknown subcommand or wrong number of arguments for '%.128s'. Try %s HELP."",
        (char*)c->argv[1]->ptr,cmd);
    sdsfree(cmd);
}",1,1,networking.c,addReplySubcommandSyntaxError,,false,1146,1153,addReplySubcommandSyntaxError,,,74,void addReplySubcommandSyntaxError (client*)
214319,METHOD,networking.c:<global>,TYPE_DECL,"void AddReplyFromClient(client *dst, client *src) {
    /* If the source client contains a partial response due to client output
     * buffer limits, propagate that to the dest rather than copy a partial
     * reply. We don't wanna run the risk of copying partial response in case
     * for some reason the output limits don't reach the same decision (maybe
     * they changed) */
    if (src->flags & CLIENT_CLOSE_ASAP) {
        sds client = catClientInfoString(sdsempty(),dst);
        freeClientAsync(dst);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
        return;
    }

    /* First add the static buffer (either into the static buffer or reply list) */
    addReplyProto(dst,src->buf, src->bufpos);

    /* We need to check with prepareClientToWrite again (after addReplyProto)
     * since addReplyProto may have changed something (like CLIENT_CLOSE_ASAP) */
    if (prepareClientToW...",1,21,networking.c,AddReplyFromClient,,false,1157,1198,AddReplyFromClient,,,75,"void AddReplyFromClient (client*,client*)"
214453,METHOD,networking.c:<global>,TYPE_DECL,"void deferredAfterErrorReply(client *c, list *errors) {
    listIter li;
    listNode *ln;
    listRewind(errors,&li);
    while((ln = listNext(&li))) {
        sds err = ln->value;
        afterErrorReply(c, err, sdslen(err), 0);
    }
}",1,1,networking.c,deferredAfterErrorReply,,false,1202,1210,deferredAfterErrorReply,,,76,"void deferredAfterErrorReply (client*,list*)"
214484,METHOD,networking.c:<global>,TYPE_DECL,"void copyReplicaOutputBuffer(client *dst, client *src) {
    serverAssert(src->bufpos == 0 && listLength(src->reply) == 0);

    if (src->ref_repl_buf_node == NULL) return;
    dst->ref_repl_buf_node = src->ref_repl_buf_node;
    dst->ref_block_pos = src->ref_block_pos;
    ((replBufBlock *)listNodeValue(dst->ref_repl_buf_node))->refcount++;
}",1,4,networking.c,copyReplicaOutputBuffer,,false,1214,1221,copyReplicaOutputBuffer,,,77,"void copyReplicaOutputBuffer (client*,client*)"
214553,METHOD,networking.c:<global>,TYPE_DECL,"int clientHasPendingReplies(client *c) {
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        /* Replicas use global shared replication buffer instead of
         * private output buffer. */
        serverAssert(c->bufpos == 0 && listLength(c->reply) == 0);
        if (c->ref_repl_buf_node == NULL) return 0;

        /* If the last replication buffer block content is totally sent,
         * we have nothing to send. */
        listNode *ln = listLast(server.repl_buffer_blocks);
        replBufBlock *tail = listNodeValue(ln);
        if (ln == c->ref_repl_buf_node &&
            c->ref_block_pos == tail->used) return 0;

        return 1;
    } else {
        return c->bufpos || listLength(c->reply);
    }
}",1,28,networking.c,clientHasPendingReplies,,false,1225,1243,clientHasPendingReplies,,,78,int clientHasPendingReplies (client*)
214659,METHOD,networking.c:<global>,TYPE_DECL,"void clientAcceptHandler(connection *conn) {
    client *c = connGetPrivateData(conn);

    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_WARNING,
                  ""Error accepting a client connection: %s (addr=%s laddr=%s)"",
                  connGetLastError(conn), getClientPeerId(c), getClientSockname(c));
        freeClientAsync(c);
        return;
    }

    /* If the server is running in protected mode (the default) and there
     * is no password set, nor a specific interface is bound, we don't accept
     * requests from non loopback interfaces. Instead we try to explain the
     * user what to do to fix it if needed. */
    if (server.protected_mode &&
        DefaultUser->flags & USER_FLAG_NOPASS)
    {
        if (connIsLocal(conn) != 1) {
            char *err =
                ""-DENIED Redis is running in protected mode because protected ""
                ""mode is enabled and no password is set for the default user. ""
                ""In this m...",1,8,networking.c,clientAcceptHandler,,false,1245,1297,clientAcceptHandler,,,79,void clientAcceptHandler (connection*)
214758,METHOD,networking.c:<global>,TYPE_DECL,"void acceptCommonHandler(connection *conn, int flags, char *ip) {
    client *c;
    UNUSED(ip);

    if (connGetState(conn) != CONN_STATE_ACCEPTING) {
        char addr[NET_ADDR_STR_LEN] = {0};
        char laddr[NET_ADDR_STR_LEN] = {0};
        connFormatAddr(conn, addr, sizeof(addr), 1);
        connFormatAddr(conn, laddr, sizeof(addr), 0);
        serverLog(LL_VERBOSE,
                  ""Accepted client connection in error state: %s (addr=%s laddr=%s)"",
                  connGetLastError(conn), addr, laddr);
        connClose(conn);
        return;
    }

    /* Limit the number of connections we take at the same time.
     *
     * Admission control will happen before a client is created and connAccept()
     * called, because we don't want to even start transport-level negotiation
     * if rejected. */
    if (listLength(server.clients) + getClusterConnectionsCount()
        >= server.maxclients)
    {
        char *err;
        if (server.cluster_enabled)
            err = ""...",1,4,networking.c,acceptCommonHandler,,false,1299,1373,acceptCommonHandler,,,80,"void acceptCommonHandler (connection*,int,char*)"
214978,METHOD,networking.c:<global>,TYPE_DECL,"void freeClientOriginalArgv(client *c) {
    /* We didn't rewrite this client */
    if (!c->original_argv) return;

    for (int j = 0; j < c->original_argc; j++)
        decrRefCount(c->original_argv[j]);
    zfree(c->original_argv);
    c->original_argv = NULL;
    c->original_argc = 0;
}",1,1,networking.c,freeClientOriginalArgv,,false,1375,1384,freeClientOriginalArgv,,,81,void freeClientOriginalArgv (client*)
215023,METHOD,networking.c:<global>,TYPE_DECL,"void freeClientArgv(client *c) {
    int j;
    for (j = 0; j < c->argc; j++)
        decrRefCount(c->argv[j]);
    c->argc = 0;
    c->cmd = NULL;
    c->argv_len_sum = 0;
    c->argv_len = 0;
    zfree(c->argv);
    c->argv = NULL;
}",1,1,networking.c,freeClientArgv,,false,1386,1396,freeClientArgv,,,82,void freeClientArgv (client*)
215076,METHOD,networking.c:<global>,TYPE_DECL,"void disconnectSlaves(void) {
    listIter li;
    listNode *ln;
    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        freeClient((client*)ln->value);
    }
}",1,1,networking.c,disconnectSlaves,,false,1401,1408,disconnectSlaves,,,83,void disconnectSlaves (void)
215102,METHOD,networking.c:<global>,TYPE_DECL,"int anyOtherSlaveWaitRdb(client *except_me) {
    listIter li;
    listNode *ln;

    listRewind(server.slaves, &li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (slave != except_me &&
            slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END)
        {
            return 1;
        }
    }
    return 0;
}",1,32,networking.c,anyOtherSlaveWaitRdb,,false,1413,1427,anyOtherSlaveWaitRdb,,,84,int anyOtherSlaveWaitRdb (client*)
215145,METHOD,networking.c:<global>,TYPE_DECL,"void unlinkClient(client *c) {
    listNode *ln;

    /* If this is marked as current client unset it. */
    if (server.current_client == c) server.current_client = NULL;

    /* Certain operations must be done only if the client has an active connection.
     * If the client was already unlinked or if it's a ""fake client"" the
     * conn is already set to NULL. */
    if (c->conn) {
        /* Remove from the list of active clients. */
        if (c->client_list_node) {
            uint64_t id = htonu64(c->id);
            raxRemove(server.clients_index,(unsigned char*)&id,sizeof(id),NULL);
            listDelNode(server.clients,c->client_list_node);
            c->client_list_node = NULL;
        }

        /* Check if this is a replica waiting for diskless replication (rdb pipe),
         * in which case it needs to be cleaned from that list */
        if (c->flags & CLIENT_SLAVE &&
            c->replstate == SLAVE_STATE_WAIT_BGSAVE_END &&
            server.rdb_pipe_conns)
   ...",1,26,networking.c,unlinkClient,,false,1432,1498,unlinkClient,,,85,void unlinkClient (client*)
215442,METHOD,networking.c:<global>,TYPE_DECL,"void clearClientConnectionState(client *c) {
    listNode *ln;

    /* MONITOR clients are also marked with CLIENT_SLAVE, we need to
     * distinguish between the two.
     */
    if (c->flags & CLIENT_MONITOR) {
        ln = listSearchKey(server.monitors,c);
        serverAssert(ln != NULL);
        listDelNode(server.monitors,ln);

        c->flags &= ~(CLIENT_MONITOR|CLIENT_SLAVE);
    }

    serverAssert(!(c->flags &(CLIENT_SLAVE|CLIENT_MASTER)));

    if (c->flags & CLIENT_TRACKING) disableTracking(c);
    selectDb(c,0);
#ifdef LOG_REQ_RES
    c->resp = server.client_default_resp;
#else
    c->resp = 2;
#endif

    clientSetDefaultAuth(c);
    moduleNotifyUserChanged(c);
    discardTransaction(c);

    pubsubUnsubscribeAllChannels(c,0);
    pubsubUnsubscribeShardAllChannels(c, 0);
    pubsubUnsubscribeAllPatterns(c,0);

    if (c->name) {
        decrRefCount(c->name);
        c->name = NULL;
    }

    /* Note: lib_name and lib_ver are not reset since they still
     * repres...",1,19,networking.c,clearClientConnectionState,,false,1501,1544,clearClientConnectionState,,,86,void clearClientConnectionState (client*)
215624,METHOD,networking.c:<global>,TYPE_DECL,"void freeClient(client *c) {
    listNode *ln;

    /* If a client is protected, yet we need to free it right now, make sure
     * to at least use asynchronous freeing. */
    if (c->flags & CLIENT_PROTECTED) {
        freeClientAsync(c);
        return;
    }

    /* For connected clients, call the disconnection event of modules hooks. */
    if (c->conn) {
        moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,
                              REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED,
                              c);
    }

    /* Notify module system that this client auth status changed. */
    moduleNotifyUserChanged(c);

    /* Free the RedisModuleBlockedClient held onto for reprocessing if not already freed. */
    zfree(c->module_blocked_client);

    /* If this client was scheduled for async freeing we need to remove it
     * from the queue. Note that we need to do this here, because later
     * we may call replicationCacheMaster() and the client should alread...",1,19,networking.c,freeClient,,false,1546,1701,freeClient,,,87,void freeClient (client*)
216142,METHOD,networking.c:<global>,TYPE_DECL,"void freeClientAsync(client *c) {
    /* We need to handle concurrent access to the server.clients_to_close list
     * only in the freeClientAsync() function, since it's the only function that
     * may access the list while Redis uses I/O threads. All the other accesses
     * are in the context of the main thread while the other threads are
     * idle. */
    if (c->flags & CLIENT_CLOSE_ASAP || c->flags & CLIENT_SCRIPT) return;
    c->flags |= CLIENT_CLOSE_ASAP;
    if (server.io_threads_num == 1) {
        /* no need to bother with locking if there's just one thread (the main thread) */
        listAddNodeTail(server.clients_to_close,c);
        return;
    }
    static pthread_mutex_t async_free_queue_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_lock(&async_free_queue_mutex);
    listAddNodeTail(server.clients_to_close,c);
    pthread_mutex_unlock(&async_free_queue_mutex);
}",1,19,networking.c,freeClientAsync,,false,1707,1724,freeClientAsync,,,88,void freeClientAsync (client*)
216206,METHOD,networking.c:<global>,TYPE_DECL,"void logInvalidUseAndFreeClientAsync(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    sds info = sdscatvprintf(sdsempty(), fmt, ap);
    va_end(ap);

    sds client = catClientInfoString(sdsempty(), c);
    serverLog(LL_WARNING, ""%s, disconnecting it: %s"", info, client);

    sdsfree(info);
    sdsfree(client);
    freeClientAsync(c);
}",1,4,networking.c,logInvalidUseAndFreeClientAsync,,false,1728,1740,logInvalidUseAndFreeClientAsync,,,89,"void logInvalidUseAndFreeClientAsync (client*,char*...)"
216257,METHOD,networking.c:<global>,TYPE_DECL,"int beforeNextClient(client *c) {
    /* Notice, this code is also called from 'processUnblockedClients'.
     * But in case of a module blocked client (see RM_Call 'K' flag) we do not reach this code path.
     * So whenever we change the code here we need to consider if we need this change on module
     * blocked client as well */

    /* Skip the client processing if we're in an IO thread, in that case we'll perform
       this operation later (this function is called again) in the fan-in stage of the threading mechanism */
    if (io_threads_op != IO_THREADS_OP_IDLE)
        return C_OK;
    /* Handle async frees */
    /* Note: this doesn't make the server.clients_to_close list redundant because of
     * cases where we want an async free of a client other than myself. For example
     * in ACL modifications we disconnect clients authenticated to non-existent
     * users (see ACL LOAD). */
    if (c && (c->flags & CLIENT_CLOSE_ASAP)) {
        freeClient(c);
        return C_...",1,25,networking.c,beforeNextClient,,false,1748,1768,beforeNextClient,,,90,int beforeNextClient (client*)
216297,METHOD,networking.c:<global>,TYPE_DECL,"int freeClientsInAsyncFreeQueue(void) {
    int freed = 0;
    listIter li;
    listNode *ln;

    listRewind(server.clients_to_close,&li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);

        if (c->flags & CLIENT_PROTECTED) continue;

        c->flags &= ~CLIENT_CLOSE_ASAP;
        freeClient(c);
        listDelNode(server.clients_to_close,ln);
        freed++;
    }
    return freed;
}",1,20,networking.c,freeClientsInAsyncFreeQueue,,false,1772,1789,freeClientsInAsyncFreeQueue,,,91,int freeClientsInAsyncFreeQueue (void)
216365,METHOD,networking.c:<global>,TYPE_DECL,"client *lookupClientByID(uint64_t id) {
    id = htonu64(id);
    client *c = raxFind(server.clients_index,(unsigned char*)&id,sizeof(id));
    return (c == raxNotFound) ? NULL : c;
}",1,9,networking.c,lookupClientByID,,false,1794,1798,lookupClientByID,,,92,client lookupClientByID (uint64_t)
216397,METHOD,networking.c:<global>,TYPE_DECL,"static int _writevToClient(client *c, ssize_t *nwritten) {
    int iovcnt = 0;
    int iovmax = min(IOV_MAX, c->conn->iovcnt);
    struct iovec iov[iovmax];
    size_t iov_bytes_len = 0;
    /* If the static reply buffer is not empty, 
     * add it to the iov array for writev() as well. */
    if (c->bufpos > 0) {
        iov[iovcnt].iov_base = c->buf + c->sentlen;
        iov[iovcnt].iov_len = c->bufpos - c->sentlen;
        iov_bytes_len += iov[iovcnt++].iov_len;
    }
    /* The first node of reply list might be incomplete from the last call,
     * thus it needs to be calibrated to get the actual data address and length. */
    size_t offset = c->bufpos > 0 ? 0 : c->sentlen;
    listIter iter;
    listNode *next;
    clientReplyBlock *o;
    listRewind(c->reply, &iter);
    while ((next = listNext(&iter)) && iovcnt < iovmax && iov_bytes_len < NET_MAX_WRITES_PER_EVENT) {
        o = listNodeValue(next);
        if (o->used == 0) { /* empty node, just release it and skip. */
    ...",1,17,networking.c,_writevToClient,,false,1805,1871,_writevToClient,,,93,"int _writevToClient (client*,ssize_t*)"
216730,METHOD,networking.c:<global>,TYPE_DECL,"int _writeToClient(client *c, ssize_t *nwritten) {
    *nwritten = 0;
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        serverAssert(c->bufpos == 0 && listLength(c->reply) == 0);

        replBufBlock *o = listNodeValue(c->ref_repl_buf_node);
        serverAssert(o->used >= c->ref_block_pos);
        /* Send current block if it is not fully sent. */
        if (o->used > c->ref_block_pos) {
            *nwritten = connWrite(c->conn, o->buf+c->ref_block_pos,
                                  o->used-c->ref_block_pos);
            if (*nwritten <= 0) return C_ERR;
            c->ref_block_pos += *nwritten;
        }

        /* If we fully sent the object on head, go to the next one. */
        listNode *next = listNextNode(c->ref_repl_buf_node);
        if (next && c->ref_block_pos == o->used) {
            o->refcount--;
            ((replBufBlock *)(listNodeValue(next)))->refcount++;
            c->ref_repl_buf_node = next;
            c->ref_block_pos = 0;
            incre...",1,28,networking.c,_writeToClient,,false,1878,1929,_writeToClient,,,94,"int _writeToClient (client*,ssize_t*)"
217044,METHOD,networking.c:<global>,TYPE_DECL,"int writeToClient(client *c, int handler_installed) {
    /* Update total number of writes on server */
    atomicIncr(server.stat_total_writes_processed, 1);

    ssize_t nwritten = 0, totwritten = 0;

    while(clientHasPendingReplies(c)) {
        int ret = _writeToClient(c, &nwritten);
        if (ret == C_ERR) break;
        totwritten += nwritten;
        /* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT
         * bytes, in a single threaded server it's a good idea to serve
         * other clients as well, even if a very large request comes from
         * super fast link that is always able to accept data (in real world
         * scenario think about 'KEYS *' against the loopback interface).
         *
         * However if we are over the maxmemory limit we ignore that and
         * just deliver as much data as it is possible to deliver.
         *
         * Moreover, we also send as much as possible if the client is
         * a slave or a monitor (other...",1,19,networking.c,writeToClient,,false,1939,2011,writeToClient,,,95,"int writeToClient (client*,int)"
217271,METHOD,networking.c:<global>,TYPE_DECL,"void sendReplyToClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    writeToClient(c,1);
}",1,1,networking.c,sendReplyToClient,,false,2014,2017,sendReplyToClient,,,96,void sendReplyToClient (connection*)
217284,METHOD,networking.c:<global>,TYPE_DECL,"int handleClientsWithPendingWrites(void) {
    listIter li;
    listNode *ln;
    int processed = listLength(server.clients_pending_write);

    listRewind(server.clients_pending_write,&li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        c->flags &= ~CLIENT_PENDING_WRITE;
        listUnlinkNode(server.clients_pending_write,ln);

        /* If a client is protected, don't do anything,
         * that may trigger write error or recreate handler. */
        if (c->flags & CLIENT_PROTECTED) continue;

        /* Don't write to clients that are going to be closed anyway. */
        if (c->flags & CLIENT_CLOSE_ASAP) continue;

        /* Try to write buffers to the client socket. */
        if (writeToClient(c,0) == C_ERR) continue;

        /* If after the synchronous writes above we still have data to
         * output to the client, we need to install the writable handler. */
        if (clientHasPendingReplies(c)) {
            installClientWriteHandl...",1,20,networking.c,handleClientsWithPendingWrites,,false,2023,2051,handleClientsWithPendingWrites,,,97,int handleClientsWithPendingWrites (void)
217384,METHOD,networking.c:<global>,TYPE_DECL,"void resetClient(client *c) {
    redisCommandProc *prevcmd = c->cmd ? c->cmd->proc : NULL;

    freeClientArgv(c);
    c->cur_script = NULL;
    c->reqtype = 0;
    c->multibulklen = 0;
    c->bulklen = -1;
    c->slot = -1;
    c->flags &= ~CLIENT_EXECUTING_COMMAND;

    /* Make sure the duration has been recorded to some command. */
    serverAssert(c->duration == 0);
#ifdef LOG_REQ_RES
    reqresReset(c, 1);
#endif

    if (c->deferred_reply_errors)
        listRelease(c->deferred_reply_errors);
    c->deferred_reply_errors = NULL;

    /* We clear the ASKING flag as well if we are not inside a MULTI, and
     * if what we just executed is not the ASKING command itself. */
    if (!(c->flags & CLIENT_MULTI) && prevcmd != askingCommand)
        c->flags &= ~CLIENT_ASKING;

    /* We do the same for the CACHING command as well. It also affects
     * the next command or transaction executed, in a way very similar
     * to ASKING. */
    if (!(c->flags & CLIENT_MULTI) && prevcmd !...",1,17,networking.c,resetClient,,false,2054,2094,resetClient,,,98,void resetClient (client*)
217565,METHOD,networking.c:<global>,TYPE_DECL,"void protectClient(client *c) {
    c->flags |= CLIENT_PROTECTED;
    if (c->conn) {
        connSetReadHandler(c->conn,NULL);
        connSetWriteHandler(c->conn,NULL);
    }
}",1,16,networking.c,protectClient,,false,2109,2115,protectClient,,,99,void protectClient (client*)
217594,METHOD,networking.c:<global>,TYPE_DECL,"void unprotectClient(client *c) {
    if (c->flags & CLIENT_PROTECTED) {
        c->flags &= ~CLIENT_PROTECTED;
        if (c->conn) {
            connSetReadHandler(c->conn,readQueryFromClient);
            if (clientHasPendingReplies(c)) putClientInPendingWriteQueue(c);
        }
    }
}",1,19,networking.c,unprotectClient,,false,2118,2126,unprotectClient,,,100,void unprotectClient (client*)
217636,METHOD,networking.c:<global>,TYPE_DECL,"int processInlineBuffer(client *c) {
    char *newline;
    int argc, j, linefeed_chars = 1;
    sds *argv, aux;
    size_t querylen;

    /* Search for end of line */
    newline = strchr(c->querybuf+c->qb_pos,'\n');

    /* Nothing to do without a \r\n */
    if (newline == NULL) {
        if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
            addReplyError(c,""Protocol error: too big inline request"");
            setProtocolError(""too big inline request"",c);
        }
        return C_ERR;
    }

    /* Handle the \r\n case. */
    if (newline != c->querybuf+c->qb_pos && *(newline-1) == '\r')
        newline--, linefeed_chars++;

    /* Split the input buffer up to the \r\n */
    querylen = newline-(c->querybuf+c->qb_pos);
    aux = sdsnewlen(c->querybuf+c->qb_pos,querylen);
    argv = sdssplitargs(aux,&argc);
    sdsfree(aux);
    if (argv == NULL) {
        addReplyError(c,""Protocol error: unbalanced quotes in request"");
        setProtocolError(""unbalanced qu...",1,44,networking.c,processInlineBuffer,,false,2135,2207,processInlineBuffer,,,101,int processInlineBuffer (client*)
217916,METHOD,networking.c:<global>,TYPE_DECL,"static void setProtocolError(const char *errstr, client *c) {
    if (server.verbosity <= LL_VERBOSE || c->flags & CLIENT_MASTER) {
        sds client = catClientInfoString(sdsempty(),c);

        /* Sample some protocol to given an idea about what was inside. */
        char buf[256];
        if (sdslen(c->querybuf)-c->qb_pos < PROTO_DUMP_LEN) {
            snprintf(buf,sizeof(buf),""Query buffer during protocol error: '%s'"", c->querybuf+c->qb_pos);
        } else {
            snprintf(buf,sizeof(buf),""Query buffer during protocol error: '%.*s' (... more %zu bytes ...) '%.*s'"", PROTO_DUMP_LEN/2, c->querybuf+c->qb_pos, sdslen(c->querybuf)-c->qb_pos-PROTO_DUMP_LEN, PROTO_DUMP_LEN/2, c->querybuf+sdslen(c->querybuf)-PROTO_DUMP_LEN/2);
        }

        /* Remove non printable chars. */
        char *p = buf;
        while (*p != '\0') {
            if (!isprint(*p)) *p = '.';
            p++;
        }

        /* Log all the client and protocol info. */
        int loglevel = (c->fla...",1,28,networking.c,setProtocolError,,false,2213,2240,setProtocolError,,,102,"void setProtocolError (char*,client*)"
218104,METHOD,networking.c:<global>,TYPE_DECL,"int processMultibulkBuffer(client *c) {
    char *newline = NULL;
    int ok;
    long long ll;

    if (c->multibulklen == 0) {
        /* The client should have been reset */
        serverAssertWithInfo(c,NULL,c->argc == 0);

        /* Multi bulk length cannot be read without a \r\n */
        newline = strchr(c->querybuf+c->qb_pos,'\r');
        if (newline == NULL) {
            if (sdslen(c->querybuf)-c->qb_pos > PROTO_INLINE_MAX_SIZE) {
                addReplyError(c,""Protocol error: too big mbulk count string"");
                setProtocolError(""too big mbulk count string"",c);
            }
            return C_ERR;
        }

        /* Buffer should also contain \n */
        if (newline-(c->querybuf+c->qb_pos) > (ssize_t)(sdslen(c->querybuf)-c->qb_pos-2))
            return C_ERR;

        /* We know for sure there is a whole line since newline != NULL,
         * so go ahead and find out the multi bulk length. */
        serverAssertWithInfo(c,NULL,c->querybuf[c->qb_po...",1,8,networking.c,processMultibulkBuffer,,false,2253,2413,processMultibulkBuffer,,,103,int processMultibulkBuffer (client*)
218931,METHOD,networking.c:<global>,TYPE_DECL,"void commandProcessed(client *c) {
    /* If client is blocked(including paused), just return avoid reset and replicate.
     *
     * 1. Don't reset the client structure for blocked clients, so that the reply
     *    callback will still be able to access the client argv and argc fields.
     *    The client will be reset in unblockClient().
     * 2. Don't update replication offset or propagate commands to replicas,
     *    since we have not applied the command. */
    if (c->flags & CLIENT_BLOCKED) return;

    reqresAppendResponse(c);
    resetClient(c);

    long long prev_offset = c->reploff;
    if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
        /* Update the applied replication offset of our master. */
        c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;
    }

    /* If the client is a master we need to compute the difference
     * between the applied offset before and after processing the buffer,
     * to understand how much of th...",1,19,networking.c,commandProcessed,,false,2420,2452,commandProcessed,,,104,void commandProcessed (client*)
219032,METHOD,networking.c:<global>,TYPE_DECL,"int processCommandAndResetClient(client *c) {
    int deadclient = 0;
    client *old_client = server.current_client;
    server.current_client = c;
    if (processCommand(c) == C_OK) {
        commandProcessed(c);
        /* Update the client's memory to include output buffer growth following the
         * processed command. */
        updateClientMemUsageAndBucket(c);
    }

    if (server.current_client == NULL) deadclient = 1;
    /*
     * Restore the old client, this is needed because when a script
     * times out, we will get into this code from processEventsWhileBlocked.
     * Which will cause to set the server.current_client. If not restored
     * we will return 1 to our caller which will falsely indicate the client
     * is dead and will stop reading from its buffer.
     */
    server.current_client = old_client;
    /* performEvictions may flush slave output buffers. This may
     * result in a slave, that may be the active client, to be
     * freed. */
    return ...",1,29,networking.c,processCommandAndResetClient,,false,2462,2486,processCommandAndResetClient,,,105,int processCommandAndResetClient (client*)
219089,METHOD,networking.c:<global>,TYPE_DECL,"int processPendingCommandAndInputBuffer(client *c) {
    /* Notice, this code is also called from 'processUnblockedClients'.
     * But in case of a module blocked client (see RM_Call 'K' flag) we do not reach this code path.
     * So whenever we change the code here we need to consider if we need this change on module
     * blocked client as well */
    if (c->flags & CLIENT_PENDING_COMMAND) {
        c->flags &= ~CLIENT_PENDING_COMMAND;
        if (processCommandAndResetClient(c) == C_ERR) {
            return C_ERR;
        }
    }

    /* Now process client if it has more data in it's buffer.
     *
     * Note: when a master client steps into this function,
     * it can always satisfy this condition, because its querybuf
     * contains data not applied. */
    if (c->querybuf && sdslen(c->querybuf) > 0) {
        return processInputBuffer(c);
    }
    return C_OK;
}",1,19,networking.c,processPendingCommandAndInputBuffer,,false,2492,2513,processPendingCommandAndInputBuffer,,,106,int processPendingCommandAndInputBuffer (client*)
219148,METHOD,networking.c:<global>,TYPE_DECL,"int processInputBuffer(client *c) {
    /* Keep processing while there is something in the input buffer */
    while(c->qb_pos < sdslen(c->querybuf)) {
        /* Immediately abort if the client is in the middle of something. */
        if (c->flags & CLIENT_BLOCKED) break;

        /* Don't process more buffers from clients that have already pending
         * commands to execute in c->argv. */
        if (c->flags & CLIENT_PENDING_COMMAND) break;

        /* Don't process input from the master while there is a busy script
         * condition on the slave. We want just to accumulate the replication
         * stream (instead of replying -BUSY like we do with other clients) and
         * later resume the processing. */
        if (isInsideYieldingLongCommand() && c->flags & CLIENT_MASTER) break;

        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is
         * written to the client. Make sure to not let the reply grow after
         * this flag has been set (...",1,23,networking.c,processInputBuffer,,false,2520,2614,processInputBuffer,,,107,int processInputBuffer (client*)
219429,METHOD,networking.c:<global>,TYPE_DECL,"void readQueryFromClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    int nread, big_arg = 0;
    size_t qblen, readlen;

    /* Check if we want to read from the client later when exiting from
     * the event loop. This is the case if threaded I/O is enabled. */
    if (postponeClientRead(c)) return;

    /* Update total number of reads on server */
    atomicIncr(server.stat_total_reads_processed, 1);

    readlen = PROTO_IOBUF_LEN;
    /* If this is a multi bulk request, and we are processing a bulk reply
     * that is large enough, try to maximize the probability that the query
     * buffer contains exactly the SDS string representing the object, even
     * at the risk of requiring more read(2) calls. This way the function
     * processMultiBulkBuffer() can avoid copying buffers to create the
     * Redis Object representing the argument. */
    if (c->reqtype == PROTO_REQ_MULTIBULK && c->multibulklen && c->bulklen != -1
        && c->bulklen >= PROTO_M...",1,14,networking.c,readQueryFromClient,,false,2616,2718,readQueryFromClient,,,108,void readQueryFromClient (connection*)
219858,METHOD,networking.c:<global>,TYPE_DECL,"void genClientAddrString(client *client, char *addr,
                         size_t addr_len, int remote) {
    if (client->flags & CLIENT_UNIX_SOCKET) {
        /* Unix socket client. */
        snprintf(addr,addr_len,""%s:0"",server.unixsocket);
    } else {
        /* TCP client. */
        connFormatAddr(client->conn,addr,addr_len,remote);
    }
}",1,24,networking.c,genClientAddrString,,false,2731,2740,genClientAddrString,,,109,"void genClientAddrString (client*,char*,size_t,int)"
219893,METHOD,networking.c:<global>,TYPE_DECL,"char *getClientPeerId(client *c) {
    char peerid[NET_ADDR_STR_LEN] = {0};

    if (c->peerid == NULL) {
        genClientAddrString(c,peerid,sizeof(peerid),1);
        c->peerid = sdsnew(peerid);
    }
    return c->peerid;
}",1,16,networking.c,getClientPeerId,,false,2746,2754,getClientPeerId,,,110,char* getClientPeerId (client*)
219926,METHOD,networking.c:<global>,TYPE_DECL,"char *getClientSockname(client *c) {
    char sockname[NET_ADDR_STR_LEN] = {0};

    if (c->sockname == NULL) {
        genClientAddrString(c,sockname,sizeof(sockname),0);
        c->sockname = sdsnew(sockname);
    }
    return c->sockname;
}",1,18,networking.c,getClientSockname,,false,2760,2768,getClientSockname,,,111,char* getClientSockname (client*)
219959,METHOD,networking.c:<global>,TYPE_DECL,"sds catClientInfoString(sds s, client *client) {
    char flags[17], events[3], conninfo[CONN_INFO_LEN], *p;

    p = flags;
    if (client->flags & CLIENT_SLAVE) {
        if (client->flags & CLIENT_MONITOR)
            *p++ = 'O';
        else
            *p++ = 'S';
    }
    if (client->flags & CLIENT_MASTER) *p++ = 'M';
    if (client->flags & CLIENT_PUBSUB) *p++ = 'P';
    if (client->flags & CLIENT_MULTI) *p++ = 'x';
    if (client->flags & CLIENT_BLOCKED) *p++ = 'b';
    if (client->flags & CLIENT_TRACKING) *p++ = 't';
    if (client->flags & CLIENT_TRACKING_BROKEN_REDIR) *p++ = 'R';
    if (client->flags & CLIENT_TRACKING_BCAST) *p++ = 'B';
    if (client->flags & CLIENT_DIRTY_CAS) *p++ = 'd';
    if (client->flags & CLIENT_CLOSE_AFTER_REPLY) *p++ = 'c';
    if (client->flags & CLIENT_UNBLOCKED) *p++ = 'u';
    if (client->flags & CLIENT_CLOSE_ASAP) *p++ = 'A';
    if (client->flags & CLIENT_UNIX_SOCKET) *p++ = 'U';
    if (client->flags & CLIENT_READONLY) *p++ = 'r';
    i...",1,40,networking.c,catClientInfoString,,false,2772,2851,catClientInfoString,,,112,"sds catClientInfoString (sds,client*)"
220615,METHOD,networking.c:<global>,TYPE_DECL,"sds getAllClientsInfoString(int type) {
    listNode *ln;
    listIter li;
    client *client;
    sds o = sdsnewlen(SDS_NOINIT,200*listLength(server.clients));
    sdsclear(o);
    listRewind(server.clients,&li);
    while ((ln = listNext(&li)) != NULL) {
        client = listNodeValue(ln);
        if (type != -1 && getClientType(client) != type) continue;
        o = catClientInfoString(o,client);
        o = sdscatlen(o,""\n"",1);
    }
    return o;
}",1,37,networking.c,getAllClientsInfoString,,false,2853,2867,getAllClientsInfoString,,,113,sds getAllClientsInfoString (int)
220690,METHOD,networking.c:<global>,TYPE_DECL,"int validateClientAttr(const char *val) {
    /* Check if the charset is ok. We need to do this otherwise
     * CLIENT LIST format will break. You should always be able to
     * split by space to get the different fields. */
    while (*val) {
        if (*val < '!' || *val > '~') { /* ASCII is assumed. */
            return C_ERR;
        }
        val++;
    }
    return C_OK;
}",1,19,networking.c,validateClientAttr,,false,2870,2881,validateClientAttr,,,114,int validateClientAttr (char*)
220721,METHOD,networking.c:<global>,TYPE_DECL,"int validateClientName(robj *name, const char **err) {
    const char *err_msg = ""Client names cannot contain spaces, newlines or special characters."";
    int len = (name != NULL) ? sdslen(name->ptr) : 0;
    /* We allow setting the client name to an empty string. */
    if (len == 0)
        return C_OK;
    if (validateClientAttr(name->ptr) == C_ERR) {
        if (err) *err = err_msg;
        return C_ERR;
    }
    return C_OK;
}",1,15,networking.c,validateClientName,,false,2884,2895,validateClientName,,,115,"int validateClientName (robj*,char**)"
220779,METHOD,networking.c:<global>,TYPE_DECL,"int clientSetName(client *c, robj *name, const char **err) {
    if (validateClientName(name, err) == C_ERR) {
        return C_ERR;
    }
    int len = (name != NULL) ? sdslen(name->ptr) : 0;
    /* Setting the client name to an empty string actually removes
     * the current name. */
    if (len == 0) {
        if (c->name) decrRefCount(c->name);
        c->name = NULL;
        return C_OK;
    }
    if (c->name) decrRefCount(c->name);
    c->name = name;
    incrRefCount(name);
    return C_OK;
}",1,41,networking.c,clientSetName,,false,2898,2914,clientSetName,,,116,"int clientSetName (client*,robj*,char**)"
220856,METHOD,networking.c:<global>,TYPE_DECL,"int clientSetNameOrReply(client *c, robj *name) {
    const char *err = NULL;
    int result = clientSetName(c, name, &err);
    if (result == C_ERR) {
        addReplyError(c, err);
    }
    return result;
}",1,18,networking.c,clientSetNameOrReply,,false,2925,2932,clientSetNameOrReply,,,117,"int clientSetNameOrReply (client*,robj*)"
220887,METHOD,networking.c:<global>,TYPE_DECL,"void clientSetinfoCommand(client *c) {
    sds attr = c->argv[2]->ptr;
    robj *valob = c->argv[3];
    sds val = valob->ptr;
    robj **destvar = NULL;
    if (!strcasecmp(attr,""lib-name"")) {
        destvar = &c->lib_name;
    } else if (!strcasecmp(attr,""lib-ver"")) {
        destvar = &c->lib_ver;
    } else {
        addReplyErrorFormat(c,""Unrecognized option '%s'"", attr);
        return;
    }

    if (validateClientAttr(val)==C_ERR) {
        addReplyErrorFormat(c,
            ""%s cannot contain spaces, newlines or special characters."", attr);
        return;
    }
    if (*destvar) decrRefCount(*destvar);
    if (sdslen(val)) {
        *destvar = valob;
        incrRefCount(valob);
    } else
        *destvar = NULL;
    addReply(c,shared.ok);
}",1,33,networking.c,clientSetinfoCommand,,false,2935,2961,clientSetinfoCommand,,,118,void clientSetinfoCommand (client*)
220995,METHOD,networking.c:<global>,TYPE_DECL,"void resetCommand(client *c) {
    /* MONITOR clients are also marked with CLIENT_SLAVE, we need to
     * distinguish between the two.
     */
    uint64_t flags = c->flags;
    if (flags & CLIENT_MONITOR) flags &= ~(CLIENT_MONITOR|CLIENT_SLAVE);

    if (flags & (CLIENT_SLAVE|CLIENT_MASTER|CLIENT_MODULE)) {
        addReplyError(c,""can only reset normal client connections"");
        return;
    }

    clearClientConnectionState(c);
    addReplyStatus(c,""RESET"");
}",1,16,networking.c,resetCommand,,false,2965,2979,resetCommand,,,119,void resetCommand (client*)
221059,METHOD,networking.c:<global>,TYPE_DECL,"void quitCommand(client *c) {
    addReply(c,shared.ok);
    c->flags |= CLIENT_CLOSE_AFTER_REPLY;
}",1,16,networking.c,quitCommand,,false,2982,2985,quitCommand,,,120,void quitCommand (client*)
221078,METHOD,networking.c:<global>,TYPE_DECL,"void clientCommand(client *c) {
    listNode *ln;
    listIter li;

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CACHING (YES|NO)"",
""    Enable/disable tracking of the keys for next command in OPTIN/OPTOUT modes."",
""GETREDIR"",
""    Return the client ID we are redirecting to when tracking is enabled."",
""GETNAME"",
""    Return the name of the current connection."",
""ID"",
""    Return the ID of the current connection."",
""INFO"",
""    Return information about the current client connection."",
""KILL <ip:port>"",
""    Kill connection made from <ip:port>."",
""KILL <option> <value> [<option> <value> [...]]"",
""    Kill connections. Options are:"",
""    * ADDR (<ip:port>|<unixsocket>:0)"",
""      Kill connections made from the specified address"",
""    * LADDR (<ip:port>|<unixsocket>:0)"",
""      Kill connections made to specified local address"",
""    * TYPE (NORMAL|MASTER|REPLICA|PUBSUB)"",
""      Kill connections by type."",
""    * USER <username>"",
""   ...",1,26,networking.c,clientCommand,,false,2987,3527,clientCommand,,,121,void clientCommand (client*)
223423,METHOD,networking.c:<global>,TYPE_DECL,"void helloCommand(client *c) {
    long long ver = 0;
    int next_arg = 1;

    if (c->argc >= 2) {
        if (getLongLongFromObjectOrReply(c, c->argv[next_arg++], &ver,
            ""Protocol version is not an integer or out of range"") != C_OK) {
            return;
        }

        if (ver < 2 || ver > 3) {
            addReplyError(c,""-NOPROTO unsupported protocol version"");
            return;
        }
    }

    robj *username = NULL;
    robj *password = NULL;
    robj *clientname = NULL;
    for (int j = next_arg; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        const char *opt = c->argv[j]->ptr;
        if (!strcasecmp(opt,""AUTH"") && moreargs >= 2) {
            redactClientCommandArgument(c, j+1);
            redactClientCommandArgument(c, j+2);
            username = c->argv[j+1];
            password = c->argv[j+2];
            j += 2;
        } else if (!strcasecmp(opt,""SETNAME"") && moreargs) {
            clientname = c->argv[j+1];
            con...",1,69,networking.c,helloCommand,,false,3530,3626,helloCommand,,,122,void helloCommand (client*)
223760,METHOD,networking.c:<global>,TYPE_DECL,"void securityWarningCommand(client *c) {
    static time_t logged_time = 0;
    time_t now = time(NULL);

    if (llabs(now-logged_time) > 60) {
        char ip[NET_IP_STR_LEN];
        int port;
        if (connAddrPeerName(c->conn, ip, sizeof(ip), &port) == -1) {
            serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted."");
        } else {
            serverLog(LL_WARNING,""Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection from %s:%d aborted."", ip, port);
        }
        logged_time = now;
    }
    freeClientAsync(c);
}",1,16,networking.c,securityWarningCommand,,false,3637,3652,securityWarningCommand,,,123,void securityWarningCommand (client*)
223843,METHOD,networking.c:<global>,TYPE_DECL,"static void retainOriginalCommandVector(client *c) {
    /* We already rewrote this command, so don't rewrite it again */
    if (c->original_argv) return;
    c->original_argc = c->argc;
    c->original_argv = zmalloc(sizeof(robj*)*(c->argc));
    for (int j = 0; j < c->argc; j++) {
        c->original_argv[j] = c->argv[j];
        incrRefCount(c->argv[j]);
    }
}",1,1,networking.c,retainOriginalCommandVector,,false,3656,3665,retainOriginalCommandVector,,,124,void retainOriginalCommandVector (client*)
223903,METHOD,networking.c:<global>,TYPE_DECL,"void redactClientCommandArgument(client *c, int argc) {
    retainOriginalCommandVector(c);
    if (c->original_argv[argc] == shared.redacted) {
        /* This argument has already been redacted */
        return;
    }
    decrRefCount(c->original_argv[argc]);
    c->original_argv[argc] = shared.redacted;
}",1,1,networking.c,redactClientCommandArgument,,false,3670,3678,redactClientCommandArgument,,,125,"void redactClientCommandArgument (client*,int)"
223938,METHOD,networking.c:<global>,TYPE_DECL,"void rewriteClientCommandVector(client *c, int argc, ...) {
    va_list ap;
    int j;
    robj **argv; /* The new argument vector */

    argv = zmalloc(sizeof(robj*)*argc);
    va_start(ap,argc);
    for (j = 0; j < argc; j++) {
        robj *a;

        a = va_arg(ap, robj*);
        argv[j] = a;
        incrRefCount(a);
    }
    replaceClientCommandVector(c, argc, argv);
    va_end(ap);
}",1,1,networking.c,rewriteClientCommandVector,,false,3683,3699,rewriteClientCommandVector,,,126,"void rewriteClientCommandVector (client*,int...)"
223983,METHOD,networking.c:<global>,TYPE_DECL,"void replaceClientCommandVector(client *c, int argc, robj **argv) {
    int j;
    retainOriginalCommandVector(c);
    freeClientArgv(c);
    c->argv = argv;
    c->argc = argc;
    c->argv_len_sum = 0;
    for (j = 0; j < c->argc; j++)
        if (c->argv[j])
            c->argv_len_sum += getStringObjectLen(c->argv[j]);
    c->cmd = lookupCommandOrOriginal(c->argv,c->argc);
    serverAssertWithInfo(c,NULL,c->cmd != NULL);
}",1,4,networking.c,replaceClientCommandVector,,false,3702,3714,replaceClientCommandVector,,,127,"void replaceClientCommandVector (client*,int,robj**)"
224072,METHOD,networking.c:<global>,TYPE_DECL,"void rewriteClientCommandArgument(client *c, int i, robj *newval) {
    robj *oldval;
    retainOriginalCommandVector(c);

    /* We need to handle both extending beyond argc (just update it and
     * initialize the new element) or beyond argv_len (realloc is needed).
     */
    if (i >= c->argc) {
        if (i >= c->argv_len) {
            c->argv = zrealloc(c->argv,sizeof(robj*)*(i+1));
            c->argv_len = i+1;
        }
        c->argc = i+1;
        c->argv[i] = NULL;
    }
    oldval = c->argv[i];
    if (oldval) c->argv_len_sum -= getStringObjectLen(oldval);
    if (newval) c->argv_len_sum += getStringObjectLen(newval);
    c->argv[i] = newval;
    incrRefCount(newval);
    if (oldval) decrRefCount(oldval);

    /* If this is the command name make sure to fix c->cmd. */
    if (i == 0) {
        c->cmd = lookupCommandOrOriginal(c->argv,c->argc);
        serverAssertWithInfo(c,NULL,c->cmd != NULL);
    }
}",1,8,networking.c,rewriteClientCommandArgument,,false,3727,3754,rewriteClientCommandArgument,,,128,"void rewriteClientCommandArgument (client*,int,robj*)"
224208,METHOD,networking.c:<global>,TYPE_DECL,"size_t getClientOutputBufferMemoryUsage(client *c) {
    if (getClientType(c) == CLIENT_TYPE_SLAVE) {
        size_t repl_buf_size = 0;
        size_t repl_node_num = 0;
        size_t repl_node_size = sizeof(listNode) + sizeof(replBufBlock);
        if (c->ref_repl_buf_node) {
            replBufBlock *last = listNodeValue(listLast(server.repl_buffer_blocks));
            replBufBlock *cur = listNodeValue(c->ref_repl_buf_node);
            repl_buf_size = last->repl_offset + last->size - cur->repl_offset;
            repl_node_num = last->id - cur->id + 1;
        }
        return repl_buf_size + (repl_node_size*repl_node_num);
    } else { 
        size_t list_item_size = sizeof(listNode) + sizeof(clientReplyBlock);
        return c->reply_bytes + (list_item_size*listLength(c->reply));
    }
}",1,28,networking.c,getClientOutputBufferMemoryUsage,,false,3762,3778,getClientOutputBufferMemoryUsage,,,129,size_t getClientOutputBufferMemoryUsage (client*)
224324,METHOD,networking.c:<global>,TYPE_DECL,"size_t getClientMemoryUsage(client *c, size_t *output_buffer_mem_usage) {
    size_t mem = getClientOutputBufferMemoryUsage(c);
    if (output_buffer_mem_usage != NULL)
        *output_buffer_mem_usage = mem;
    mem += sdsZmallocSize(c->querybuf);
    mem += zmalloc_size(c);
    mem += c->buf_usable_size;
    /* For efficiency (less work keeping track of the argv memory), it doesn't include the used memory
     * i.e. unused sds space and internal fragmentation, just the string length. but this is enough to
     * spot problematic clients. */
    mem += c->argv_len_sum + sizeof(robj*)*c->argc;
    mem += multiStateMemOverhead(c);

    /* Add memory overhead of pubsub channels and patterns. Note: this is just the overhead of the robj pointers
     * to the strings themselves because they aren't stored per client. */
    mem += pubsubMemOverhead(c);

    /* Add memory overhead of the tracking prefixes, this is an underestimation so we don't need to traverse the entire rax */
    if (...",1,1,networking.c,getClientMemoryUsage,,false,3783,3805,getClientMemoryUsage,,,130,"size_t getClientMemoryUsage (client*,size_t*)"
224399,METHOD,networking.c:<global>,TYPE_DECL,"int getClientType(client *c) {
    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;
    /* Even though MONITOR clients are marked as replicas, we
     * want the expose them as normal clients. */
    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))
        return CLIENT_TYPE_SLAVE;
    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;
    return CLIENT_TYPE_NORMAL;
}",1,19,networking.c,getClientType,,false,3816,3824,getClientType,,,131,int getClientType (client*)
224464,METHOD,networking.c:<global>,TYPE_DECL,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""replica"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}",1,43,networking.c,getClientTypeByName,,false,3826,3833,getClientTypeByName,,,132,int getClientTypeByName (char*)
224532,METHOD,networking.c:<global>,TYPE_DECL,"char *getClientTypeName(int class) {
    switch(class) {
    case CLIENT_TYPE_NORMAL: return ""normal"";
    case CLIENT_TYPE_SLAVE:  return ""slave"";
    case CLIENT_TYPE_PUBSUB: return ""pubsub"";
    case CLIENT_TYPE_MASTER: return ""master"";
    default:                       return NULL;
    }
}",1,9,networking.c,getClientTypeName,,false,3835,3843,getClientTypeName,,,133,char* getClientTypeName (int)
224567,METHOD,networking.c:<global>,TYPE_DECL,"int checkClientOutputBufferLimits(client *c) {
    int soft = 0, hard = 0, class;
    unsigned long used_mem = getClientOutputBufferMemoryUsage(c);

    class = getClientType(c);
    /* For the purpose of output buffer limiting, masters are handled
     * like normal clients. */
    if (class == CLIENT_TYPE_MASTER) class = CLIENT_TYPE_NORMAL;

    /* Note that it doesn't make sense to set the replica clients output buffer
     * limit lower than the repl-backlog-size config (partial sync will succeed
     * and then replica will get disconnected).
     * Such a configuration is ignored (the size of repl-backlog-size will be used).
     * This doesn't have memory consumption implications since the replica client
     * will share the backlog buffers memory. */
    size_t hard_limit_bytes = server.client_obuf_limits[class].hard_limit_bytes;
    if (class == CLIENT_TYPE_SLAVE && hard_limit_bytes &&
        (long long)hard_limit_bytes < server.repl_backlog_size)
        hard_limit_bytes...",1,17,networking.c,checkClientOutputBufferLimits,,false,3851,3897,checkClientOutputBufferLimits,,,134,int checkClientOutputBufferLimits (client*)
224729,METHOD,networking.c:<global>,TYPE_DECL,"int closeClientOnOutputBufferLimitReached(client *c, int async) {
    if (!c->conn) return 0; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    /* Note that c->reply_bytes is irrelevant for replica clients
     * (they use the global repl buffers). */
    if ((c->reply_bytes == 0 && getClientType(c) != CLIENT_TYPE_SLAVE) ||
        c->flags & CLIENT_CLOSE_ASAP) return 0;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        if (async) {
            freeClientAsync(c);
            serverLog(LL_WARNING,
                      ""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."",
                      client);
        } else {
            freeClient(c);
            serverLog(LL_WARNING,
                      ""Client %s closed for overcoming of output buffer limits."",
                      client);
        }
        sdsfree(client);
        return  1;
    }
...",1,4,networking.c,closeClientOnOutputBufferLimitReached,,false,3910,3935,closeClientOnOutputBufferLimitReached,,,135,"int closeClientOnOutputBufferLimitReached (client*,int)"
224854,METHOD,networking.c:<global>,TYPE_DECL,"void flushSlavesOutputBuffers(void) {
    listIter li;
    listNode *ln;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = listNodeValue(ln);
        int can_receive_writes = connHasWriteHandler(slave->conn) ||
                                 (slave->flags & CLIENT_PENDING_WRITE);

        /* We don't want to send the pending data to the replica in a few
         * cases:
         *
         * 1. For some reason there is neither the write handler installed
         *    nor the client is flagged as to have pending writes: for some
         *    reason this replica may not be set to receive data. This is
         *    just for the sake of defensive programming.
         *
         * 2. The put_online_on_ack flag is true. To know why we don't want
         *    to send data to the replica in this case, please grep for the
         *    flag for this flag.
         *
         * 3. Obviously if the slave is not ONLINE.
         */
        if ...",1,24,networking.c,flushSlavesOutputBuffers,,false,3941,3974,flushSlavesOutputBuffers,,,136,void flushSlavesOutputBuffers (void)
224933,METHOD,networking.c:<global>,TYPE_DECL,"void updatePausedActions(void) {
    uint32_t prev_paused_actions = server.paused_actions;
    server.paused_actions = 0;

    for (int i = 0; i < NUM_PAUSE_PURPOSES; i++) {
        pause_event *p = &(server.client_pause_per_purpose[i]);
        if (p->end > server.mstime)
            server.paused_actions |= p->paused_actions;
        else {
            p->paused_actions = 0;
            p->end = 0;
        }
    }

    /* If the pause type is less restrictive than before, we unblock all clients
     * so they are reprocessed (may get re-paused). */
    uint32_t mask_cli = (PAUSE_ACTION_CLIENT_WRITE|PAUSE_ACTION_CLIENT_ALL);
    if ((server.paused_actions & mask_cli) < (prev_paused_actions & mask_cli)) {
        unblockPostponedClients();
    }
}",1,25,networking.c,updatePausedActions,,false,3978,3998,updatePausedActions,,,137,void updatePausedActions (void)
225024,METHOD,networking.c:<global>,TYPE_DECL,"void unblockPostponedClients(void) {
    listNode *ln;
    listIter li;
    listRewind(server.postponed_clients, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *c = listNodeValue(ln);
        unblockClient(c, 1);
    }
}",1,20,networking.c,unblockPostponedClients,,false,4002,4010,unblockPostponedClients,,,138,void unblockPostponedClients (void)
225058,METHOD,networking.c:<global>,TYPE_DECL,"static void pauseClientsByClient(mstime_t endTime, int isPauseClientAll) {
    uint32_t actions;
    pause_event *p = &server.client_pause_per_purpose[PAUSE_BY_CLIENT_COMMAND];

    if (isPauseClientAll)
        actions = PAUSE_ACTIONS_CLIENT_ALL_SET;
    else {
        actions = PAUSE_ACTIONS_CLIENT_WRITE_SET;
        /* If currently configured most restrictive client pause, then keep it */
        if (p->paused_actions & PAUSE_ACTION_CLIENT_ALL)
            actions = PAUSE_ACTIONS_CLIENT_ALL_SET;
    }
    
    pauseActions(PAUSE_BY_CLIENT_COMMAND, endTime, actions);
}",1,18,networking.c,pauseClientsByClient,,false,4015,4029,pauseClientsByClient,,,139,"void pauseClientsByClient (mstime_t,int)"
225151,METHOD,networking.c:<global>,TYPE_DECL,"void pauseActions(pause_purpose purpose, mstime_t end, uint32_t actions) {
    /* Manage pause type and end time per pause purpose. */
    server.client_pause_per_purpose[purpose].paused_actions = actions;

    /* If currently configured end time bigger than new one, then keep it */
    if (server.client_pause_per_purpose[purpose].end < end)
        server.client_pause_per_purpose[purpose].end = end;

    updatePausedActions();

    /* We allow write commands that were queued
     * up before and after to execute. We need
     * to track this state so that we don't assert
     * in propagateNow(). */
    if (server.in_exec) {
        server.client_pause_in_transaction = 1;
    }
}",1,1,networking.c,pauseActions,,false,4044,4061,pauseActions,,,140,"void pauseActions (pause_purpose,mstime_t,uint32_t)"
225198,METHOD,networking.c:<global>,TYPE_DECL,"void unpauseActions(pause_purpose purpose) {
    server.client_pause_per_purpose[purpose].end = 0;
    server.client_pause_per_purpose[purpose].paused_actions = 0;
    updatePausedActions();
}",1,1,networking.c,unpauseActions,,false,4064,4068,unpauseActions,,,141,void unpauseActions (pause_purpose)
225222,METHOD,networking.c:<global>,TYPE_DECL,"uint32_t isPausedActions(uint32_t actions_bitmask) {
    return (server.paused_actions & actions_bitmask);
}",1,1,networking.c,isPausedActions,,false,4071,4073,isPausedActions,,,142,uint32_t isPausedActions (uint32_t)
225233,METHOD,networking.c:<global>,TYPE_DECL,"uint32_t isPausedActionsWithUpdate(uint32_t actions_bitmask) {
    if (!(server.paused_actions & actions_bitmask)) return 0;
    updatePausedActions();
    return (server.paused_actions & actions_bitmask);
}",1,1,networking.c,isPausedActionsWithUpdate,,false,4076,4080,isPausedActionsWithUpdate,,,143,uint32_t isPausedActionsWithUpdate (uint32_t)
225255,METHOD,networking.c:<global>,TYPE_DECL,"void processEventsWhileBlocked(void) {
    int iterations = 4; /* See the function top-comment. */

    /* Update our cached time since it is used to create and update the last
     * interaction time with clients and for other important things. */
    updateCachedTime(0);

    /* For the few commands that are allowed during busy scripts, we rather
     * provide a fresher time than the one from when the script started (they
     * still won't get it from the call due to execution_nesting. For commands
     * during loading this doesn't matter. */
    mstime_t prev_cmd_time_snapshot = server.cmd_time_snapshot;
    server.cmd_time_snapshot = server.mstime;

    /* Note: when we are processing events while blocked (for instance during
     * busy Lua scripts), we set a global flag. When such flag is set, we
     * avoid handling the read part of clients using threaded I/O.
     * See https://github.com/redis/redis/issues/6988 for more info.
     * Note that there could be cases of nes...",1,12,networking.c,processEventsWhileBlocked,,false,4094,4134,processEventsWhileBlocked,,,144,void processEventsWhileBlocked (void)
225387,METHOD,networking.c:<global>,TYPE_DECL,"static inline unsigned long getIOPendingCount(int i) {
    unsigned long count = 0;
    atomicGetWithSync(io_threads_pending[i].value, count);
    return count;
}",1,1,networking.c,getIOPendingCount,,false,4163,4167,getIOPendingCount,,,156,unsigned long getIOPendingCount (int)
225405,METHOD,networking.c:<global>,TYPE_DECL,"static inline void setIOPendingCount(int i, unsigned long count) {
    atomicSetWithSync(io_threads_pending[i].value, count);
}",1,1,networking.c,setIOPendingCount,,false,4169,4171,setIOPendingCount,,,157,"void setIOPendingCount (int,long unsigned)"
225418,METHOD,networking.c:<global>,TYPE_DECL,"void *IOThreadMain(void *myid) {
    /* The ID is the thread number (from 0 to server.io_threads_num-1), and is
     * used by the thread to just manipulate a single sub-array of clients. */
    long id = (unsigned long)myid;
    char thdname[16];

    snprintf(thdname, sizeof(thdname), ""io_thd_%ld"", id);
    redis_set_thread_title(thdname);
    redisSetCpuAffinity(server.server_cpulist);
    makeThreadKillable();

    while(1) {
        /* Wait for start */
        for (int j = 0; j < 1000000; j++) {
            if (getIOPendingCount(id) != 0) break;
        }

        /* Give the main thread a chance to stop this thread. */
        if (getIOPendingCount(id) == 0) {
            pthread_mutex_lock(&io_threads_mutex[id]);
            pthread_mutex_unlock(&io_threads_mutex[id]);
            continue;
        }

        serverAssert(getIOPendingCount(id) != 0);

        /* Process: note that the main thread will never touch our list
         * before we drop the pending count to 0. */
...",1,4,networking.c,IOThreadMain,,false,4173,4217,IOThreadMain,,,158,void* IOThreadMain (void*)
225561,METHOD,networking.c:<global>,TYPE_DECL,"void initThreadedIO(void) {
    server.io_threads_active = 0; /* We start with threads not active. */

    /* Indicate that io-threads are currently idle */
    io_threads_op = IO_THREADS_OP_IDLE;

    /* Don't spawn any thread if the user selected a single thread:
     * we'll handle I/O directly from the main thread. */
    if (server.io_threads_num == 1) return;

    if (server.io_threads_num > IO_THREADS_MAX_NUM) {
        serverLog(LL_WARNING,""Fatal: too many I/O threads configured. ""
                             ""The maximum number is %d."", IO_THREADS_MAX_NUM);
        exit(1);
    }

    /* Spawn and initialize the I/O threads. */
    for (int i = 0; i < server.io_threads_num; i++) {
        /* Things we do for all the threads including the main thread. */
        io_threads_list[i] = listCreate();
        if (i == 0) continue; /* Thread 0 is the main thread. */

        /* Things we do only for the additional threads. */
        pthread_t tid;
        pthread_mutex_init(&io_...",1,20,networking.c,initThreadedIO,,false,4220,4253,initThreadedIO,,,159,void initThreadedIO (void)
225693,METHOD,networking.c:<global>,TYPE_DECL,"void killIOThreads(void) {
    int err, j;
    for (j = 0; j < server.io_threads_num; j++) {
        if (io_threads[j] == pthread_self()) continue;
        if (io_threads[j] && pthread_cancel(io_threads[j]) == 0) {
            if ((err = pthread_join(io_threads[j],NULL)) != 0) {
                serverLog(LL_WARNING,
                    ""IO thread(tid:%lu) can not be joined: %s"",
                        (unsigned long)io_threads[j], strerror(err));
            } else {
                serverLog(LL_WARNING,
                    ""IO thread(tid:%lu) terminated"",(unsigned long)io_threads[j]);
            }
        }
    }
}",1,16,networking.c,killIOThreads,,false,4255,4270,killIOThreads,,,160,void killIOThreads (void)
225794,METHOD,networking.c:<global>,TYPE_DECL,"void startThreadedIO(void) {
    serverAssert(server.io_threads_active == 0);
    for (int j = 1; j < server.io_threads_num; j++)
        pthread_mutex_unlock(&io_threads_mutex[j]);
    server.io_threads_active = 1;
}",1,4,networking.c,startThreadedIO,,false,4272,4277,startThreadedIO,,,161,void startThreadedIO (void)
225840,METHOD,networking.c:<global>,TYPE_DECL,"void stopThreadedIO(void) {
    /* We may have still clients with pending reads when this function
     * is called: handle them before stopping the threads. */
    handleClientsWithPendingReadsUsingThreads();
    serverAssert(server.io_threads_active == 1);
    for (int j = 1; j < server.io_threads_num; j++)
        pthread_mutex_lock(&io_threads_mutex[j]);
    server.io_threads_active = 0;
}",1,4,networking.c,stopThreadedIO,,false,4279,4287,stopThreadedIO,,,162,void stopThreadedIO (void)
225887,METHOD,networking.c:<global>,TYPE_DECL,"int stopThreadedIOIfNeeded(void) {
    int pending = listLength(server.clients_pending_write);

    /* Return ASAP if IO threads are disabled (single threaded mode). */
    if (server.io_threads_num == 1) return 1;

    if (pending < (server.io_threads_num*2)) {
        if (server.io_threads_active) stopThreadedIO();
        return 1;
    } else {
        return 0;
    }
}",1,18,networking.c,stopThreadedIOIfNeeded,,false,4298,4310,stopThreadedIOIfNeeded,,,163,int stopThreadedIOIfNeeded (void)
225935,METHOD,networking.c:<global>,TYPE_DECL,"int handleClientsWithPendingWritesUsingThreads(void) {
    int processed = listLength(server.clients_pending_write);
    if (processed == 0) return 0; /* Return ASAP if there are no clients. */

    /* If I/O threads are disabled or we have few clients to serve, don't
     * use I/O threads, but the boring synchronous code. */
    if (server.io_threads_num == 1 || stopThreadedIOIfNeeded()) {
        return handleClientsWithPendingWrites();
    }

    /* Start threads if needed. */
    if (!server.io_threads_active) startThreadedIO();

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_write,&li);
    int item_id = 0;
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        c->flags &= ~CLIENT_PENDING_WRITE;

        /* Remove clients from the list of pending writes since
         * they are going to be closed ASAP. */
        if (c->flags & CLIENT_CLOSE_ASAP) {
            listUn...",1,20,networking.c,handleClientsWithPendingWritesUsingThreads,,false,4318,4410,handleClientsWithPendingWritesUsingThreads,,,164,int handleClientsWithPendingWritesUsingThreads (void)
226221,METHOD,networking.c:<global>,TYPE_DECL,"int postponeClientRead(client *c) {
    if (server.io_threads_active &&
        server.io_threads_do_reads &&
        !ProcessingEventsWhileBlocked &&
        !(c->flags & (CLIENT_MASTER|CLIENT_SLAVE|CLIENT_BLOCKED)) &&
        io_threads_op == IO_THREADS_OP_IDLE)
    {
        listAddNodeHead(server.clients_pending_read,c);
        c->pending_read_list_node = listFirst(server.clients_pending_read);
        return 1;
    } else {
        return 0;
    }
}",1,22,networking.c,postponeClientRead,,false,4416,4429,postponeClientRead,,,165,int postponeClientRead (client*)
226292,METHOD,networking.c:<global>,TYPE_DECL,"int handleClientsWithPendingReadsUsingThreads(void) {
    if (!server.io_threads_active || !server.io_threads_do_reads) return 0;
    int processed = listLength(server.clients_pending_read);
    if (processed == 0) return 0;

    /* Distribute the clients across N different lists. */
    listIter li;
    listNode *ln;
    listRewind(server.clients_pending_read,&li);
    int item_id = 0;
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        int target_id = item_id % server.io_threads_num;
        listAddNodeTail(io_threads_list[target_id],c);
        item_id++;
    }

    /* Give the start condition to the waiting threads, by setting the
     * start condition atomic var. */
    io_threads_op = IO_THREADS_OP_READ;
    for (int j = 1; j < server.io_threads_num; j++) {
        int count = listLength(io_threads_list[j]);
        setIOPendingCount(j, count);
    }

    /* Also use the main thread to process a slice of clients. */
    listRewind(io_threads_list[...",1,20,networking.c,handleClientsWithPendingReadsUsingThreads,,false,4443,4523,handleClientsWithPendingReadsUsingThreads,,,166,int handleClientsWithPendingReadsUsingThreads (void)
226583,METHOD,networking.c:<global>,TYPE_DECL,"size_t getClientEvictionLimit(void) {
    size_t maxmemory_clients_actual = SIZE_MAX;

    /* Handle percentage of maxmemory*/
    if (server.maxmemory_clients < 0 && server.maxmemory > 0) {
        unsigned long long maxmemory_clients_bytes = (unsigned long long)((double)server.maxmemory * -(double) server.maxmemory_clients / 100);
        if (maxmemory_clients_bytes <= SIZE_MAX)
            maxmemory_clients_actual = maxmemory_clients_bytes;
    }
    else if (server.maxmemory_clients > 0)
        maxmemory_clients_actual = server.maxmemory_clients;
    else
        return 0;

    /* Don't allow a too small maxmemory-clients to avoid cases where we can't communicate
     * at all with the server because of bad configuration */
    if (maxmemory_clients_actual < 1024*128)
        maxmemory_clients_actual = 1024*128;

    return maxmemory_clients_actual;
}",1,1,networking.c,getClientEvictionLimit,,false,4527,4547,getClientEvictionLimit,,,167,size_t getClientEvictionLimit (void)
226664,METHOD,networking.c:<global>,TYPE_DECL,"void evictClients(void) {
    if (!server.client_mem_usage_buckets)
        return;
    /* Start eviction from topmost bucket (largest clients) */
    int curr_bucket = CLIENT_MEM_USAGE_BUCKETS-1;
    listIter bucket_iter;
    listRewind(server.client_mem_usage_buckets[curr_bucket].clients, &bucket_iter);
    size_t client_eviction_limit = getClientEvictionLimit();
    if (client_eviction_limit == 0)
        return;
    while (server.stat_clients_type_memory[CLIENT_TYPE_NORMAL] +
           server.stat_clients_type_memory[CLIENT_TYPE_PUBSUB] >= client_eviction_limit) {
        listNode *ln = listNext(&bucket_iter);
        if (ln) {
            client *c = ln->value;
            sds ci = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE, ""Evicting client: %s"", ci);
            freeClient(c);
            sdsfree(ci);
            server.stat_evictedclients++;
        } else {
            curr_bucket--;
            if (curr_bucket < 0) {
                serverLog(LL_WA...",1,22,networking.c,evictClients,,false,4549,4578,evictClients,,,168,void evictClients (void)
226819,METHOD,notify.c:<global>,TYPE_DECL,<global>,1,1,notify.c,notify.c:<global>,,false,1,145,<global>,,,1,
226821,METHOD,notify.c:<global>,TYPE_DECL,"int keyspaceEventsStringToFlags(char *classes) {
    char *p = classes;
    int c, flags = 0;

    while((c = *p++) != '\0') {
        switch(c) {
        case 'A': flags |= NOTIFY_ALL; break;
        case 'g': flags |= NOTIFY_GENERIC; break;
        case '$': flags |= NOTIFY_STRING; break;
        case 'l': flags |= NOTIFY_LIST; break;
        case 's': flags |= NOTIFY_SET; break;
        case 'h': flags |= NOTIFY_HASH; break;
        case 'z': flags |= NOTIFY_ZSET; break;
        case 'x': flags |= NOTIFY_EXPIRED; break;
        case 'e': flags |= NOTIFY_EVICTED; break;
        case 'K': flags |= NOTIFY_KEYSPACE; break;
        case 'E': flags |= NOTIFY_KEYEVENT; break;
        case 't': flags |= NOTIFY_STREAM; break;
        case 'm': flags |= NOTIFY_KEY_MISS; break;
        case 'd': flags |= NOTIFY_MODULE; break;
        case 'n': flags |= NOTIFY_NEW; break;
        default: return -1;
        }
    }
    return flags;
}",1,27,notify.c,keyspaceEventsStringToFlags,,false,40,65,keyspaceEventsStringToFlags,,,1,int keyspaceEventsStringToFlags (char*)
227039,METHOD,notify.c:<global>,TYPE_DECL,"sds keyspaceEventsFlagsToString(int flags) {
    sds res;

    res = sdsempty();
    if ((flags & NOTIFY_ALL) == NOTIFY_ALL) {
        res = sdscatlen(res,""A"",1);
    } else {
        if (flags & NOTIFY_GENERIC) res = sdscatlen(res,""g"",1);
        if (flags & NOTIFY_STRING) res = sdscatlen(res,""$"",1);
        if (flags & NOTIFY_LIST) res = sdscatlen(res,""l"",1);
        if (flags & NOTIFY_SET) res = sdscatlen(res,""s"",1);
        if (flags & NOTIFY_HASH) res = sdscatlen(res,""h"",1);
        if (flags & NOTIFY_ZSET) res = sdscatlen(res,""z"",1);
        if (flags & NOTIFY_EXPIRED) res = sdscatlen(res,""x"",1);
        if (flags & NOTIFY_EVICTED) res = sdscatlen(res,""e"",1);
        if (flags & NOTIFY_STREAM) res = sdscatlen(res,""t"",1);
        if (flags & NOTIFY_MODULE) res = sdscatlen(res,""d"",1);
        if (flags & NOTIFY_NEW) res = sdscatlen(res,""n"",1);
    }
    if (flags & NOTIFY_KEYSPACE) res = sdscatlen(res,""K"",1);
    if (flags & NOTIFY_KEYEVENT) res = sdscatlen(res,""E"",1);
    if (f...",1,17,notify.c,keyspaceEventsFlagsToString,,false,71,94,keyspaceEventsFlagsToString,,,2,sds keyspaceEventsFlagsToString (int)
227355,METHOD,notify.c:<global>,TYPE_DECL,"void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {
    sds chan;
    robj *chanobj, *eventobj;
    int len = -1;
    char buf[24];

    /* If any modules are interested in events, notify the module system now.
     * This bypasses the notifications configuration, but the module engine
     * will only call event subscribers if the event type matches the types
     * they are interested in. */
     moduleNotifyKeyspaceEvent(type, event, key, dbid);

    /* If notifications for this class of events are off, return ASAP. */
    if (!(server.notify_keyspace_events & type)) return;

    eventobj = createStringObject(event,strlen(event));

    /* __keyspace@<db>__:<key> <event> notifications. */
    if (server.notify_keyspace_events & NOTIFY_KEYSPACE) {
        chan = sdsnewlen(""__keyspace@"",11);
        len = ll2string(buf,sizeof(buf),dbid);
        chan = sdscatlen(chan, buf, len);
        chan = sdscatlen(chan, ""__:"", 3);
        chan = sdscatsds(chan, key->ptr);
  ...",1,40,notify.c,notifyKeyspaceEvent,,false,104,145,notifyKeyspaceEvent,,,3,"void notifyKeyspaceEvent (int,char*,robj*,int)"
227523,METHOD,object.c:<global>,TYPE_DECL,<global>,1,1,object.c,object.c:<global>,,false,1,1688,<global>,,,1,
227525,METHOD,object.c:<global>,TYPE_DECL,"robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o->type = type;
    o->encoding = OBJ_ENCODING_RAW;
    o->ptr = ptr;
    o->refcount = 1;
    o->lru = 0;
    return o;
}",1,18,object.c,createObject,,false,43,51,createObject,,,1,"robj createObject (int,void*)"
227567,METHOD,object.c:<global>,TYPE_DECL,"void initObjectLRUOrLFU(robj *o) {
    if (o->refcount == OBJ_SHARED_REFCOUNT)
        return;
    /* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes() << 8) | LFU_INIT_VAL;
    } else {
        o->lru = LRU_CLOCK();
    }
    return;
}",1,23,object.c,initObjectLRUOrLFU,,false,53,64,initObjectLRUOrLFU,,,2,void initObjectLRUOrLFU (robj*)
227612,METHOD,object.c:<global>,TYPE_DECL,"robj *makeObjectShared(robj *o) {
    serverAssert(o->refcount == 1);
    o->refcount = OBJ_SHARED_REFCOUNT;
    return o;
}",1,4,object.c,makeObjectShared,,false,77,81,makeObjectShared,,,3,robj makeObjectShared (robj*)
227644,METHOD,object.c:<global>,TYPE_DECL,"robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}",1,24,object.c,createRawStringObject,,false,85,87,createRawStringObject,,,4,"robj createRawStringObject (char*,size_t)"
227658,METHOD,object.c:<global>,TYPE_DECL,"robj *createEmbeddedStringObject(const char *ptr, size_t len) {
    robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
    struct sdshdr8 *sh = (void*)(o+1);

    o->type = OBJ_STRING;
    o->encoding = OBJ_ENCODING_EMBSTR;
    o->ptr = sh+1;
    o->refcount = 1;
    o->lru = 0;

    sh->len = len;
    sh->alloc = len;
    sh->flags = SDS_TYPE_8;
    if (ptr == SDS_NOINIT)
        sh->buf[len] = '\0';
    else if (ptr) {
        memcpy(sh->buf,ptr,len);
        sh->buf[len] = '\0';
    } else {
        memset(sh->buf,0,len+1);
    }
    return o;
}",1,14,object.c,createEmbeddedStringObject,,false,92,114,createEmbeddedStringObject,,,5,"robj createEmbeddedStringObject (char*,size_t)"
227775,METHOD,object.c:<global>,TYPE_DECL,"robj *createStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return createRawStringObject(ptr,len);
}",1,15,object.c,createStringObject,,false,123,128,createStringObject,,,6,"robj createStringObject (char*,size_t)"
227798,METHOD,object.c:<global>,TYPE_DECL,"robj *tryCreateRawStringObject(const char *ptr, size_t len) {
    sds str = sdstrynewlen(ptr,len);
    if (!str) return NULL;
    return createObject(OBJ_STRING, str);
}",1,24,object.c,tryCreateRawStringObject,,false,131,135,tryCreateRawStringObject,,,7,"robj tryCreateRawStringObject (char*,size_t)"
227822,METHOD,object.c:<global>,TYPE_DECL,"robj *tryCreateStringObject(const char *ptr, size_t len) {
    if (len <= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)
        return createEmbeddedStringObject(ptr,len);
    else
        return tryCreateRawStringObject(ptr,len);
}",1,15,object.c,tryCreateStringObject,,false,138,143,tryCreateStringObject,,,8,"robj tryCreateStringObject (char*,size_t)"
227845,METHOD,object.c:<global>,TYPE_DECL,"robj *createStringObjectFromLongLongWithOptions(long long value, int flag) {
    robj *o;

    if (value >= 0 && value < OBJ_SHARED_INTEGERS && flag == LL2STROBJ_AUTO) {
        o = shared.integers[value];
    } else {
        if ((value >= LONG_MIN && value <= LONG_MAX) && flag != LL2STROBJ_NO_INT_ENC) {
            o = createObject(OBJ_STRING, NULL);
            o->encoding = OBJ_ENCODING_INT;
            o->ptr = (void*)((long)value);
        } else {
            char buf[LONG_STR_SIZE];
            int len = ll2string(buf, sizeof(buf), value);
            o = createStringObject(buf, len);
        }
    }
    return o;
}",1,30,object.c,createStringObjectFromLongLongWithOptions,,false,149,166,createStringObjectFromLongLongWithOptions,,,9,"robj createStringObjectFromLongLongWithOptions (long long,int)"
227934,METHOD,object.c:<global>,TYPE_DECL,"robj *createStringObjectFromLongLong(long long value) {
    return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);
}",1,60,object.c,createStringObjectFromLongLong,,false,170,172,createStringObjectFromLongLong,,,10,robj createStringObjectFromLongLong (long long)
227945,METHOD,object.c:<global>,TYPE_DECL,"robj *createStringObjectFromLongLongForValue(long long value) {
    if (server.maxmemory == 0 || !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) {
        /* If the maxmemory policy permits, we can still return shared integers */
        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);
    } else {
        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_SHARED);
    }
}",1,61,object.c,createStringObjectFromLongLongForValue,,false,179,186,createStringObjectFromLongLongForValue,,,11,robj createStringObjectFromLongLongForValue (long long)
227986,METHOD,object.c:<global>,TYPE_DECL,"robj *createStringObjectFromLongLongWithSds(long long value) {
    return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_INT_ENC);
}",1,60,object.c,createStringObjectFromLongLongWithSds,,false,190,192,createStringObjectFromLongLongWithSds,,,12,robj createStringObjectFromLongLongWithSds (long long)
227997,METHOD,object.c:<global>,TYPE_DECL,"robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    int len = ld2string(buf,sizeof(buf),value,humanfriendly? LD_STR_HUMAN: LD_STR_AUTO);
    return createStringObject(buf,len);
}",1,13,object.c,createStringObjectFromLongDouble,,false,200,204,createStringObjectFromLongDouble,,,13,"robj createStringObjectFromLongDouble (long double,int)"
228020,METHOD,object.c:<global>,TYPE_DECL,"robj *dupStringObject(const robj *o) {
    robj *d;

    serverAssert(o->type == OBJ_STRING);

    switch(o->encoding) {
    case OBJ_ENCODING_RAW:
        return createRawStringObject(o->ptr,sdslen(o->ptr));
    case OBJ_ENCODING_EMBSTR:
        return createEmbeddedStringObject(o->ptr,sdslen(o->ptr));
    case OBJ_ENCODING_INT:
        d = createObject(OBJ_STRING, NULL);
        d->encoding = OBJ_ENCODING_INT;
        d->ptr = o->ptr;
        return d;
    default:
        serverPanic(""Wrong encoding."");
        break;
    }
}",1,4,object.c,dupStringObject,,false,214,233,dupStringObject,,,14,robj dupStringObject (robj*)
228112,METHOD,object.c:<global>,TYPE_DECL,"robj *createQuicklistObject(void) {
    quicklist *l = quicklistCreate();
    robj *o = createObject(OBJ_LIST,l);
    o->encoding = OBJ_ENCODING_QUICKLIST;
    return o;
}",1,27,object.c,createQuicklistObject,,false,235,240,createQuicklistObject,,,15,robj createQuicklistObject (void)
228138,METHOD,object.c:<global>,TYPE_DECL,"robj *createListListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_LIST,lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",1,27,object.c,createListListpackObject,,false,242,247,createListListpackObject,,,16,robj createListListpackObject (void)
228165,METHOD,object.c:<global>,TYPE_DECL,"robj *createSetObject(void) {
    dict *d = dictCreate(&setDictType);
    robj *o = createObject(OBJ_SET,d);
    o->encoding = OBJ_ENCODING_HT;
    return o;
}",1,27,object.c,createSetObject,,false,249,254,createSetObject,,,17,robj createSetObject (void)
228193,METHOD,object.c:<global>,TYPE_DECL,"robj *createIntsetObject(void) {
    intset *is = intsetNew();
    robj *o = createObject(OBJ_SET,is);
    o->encoding = OBJ_ENCODING_INTSET;
    return o;
}",1,27,object.c,createIntsetObject,,false,256,261,createIntsetObject,,,18,robj createIntsetObject (void)
228219,METHOD,object.c:<global>,TYPE_DECL,"robj *createSetListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_SET, lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",1,27,object.c,createSetListpackObject,,false,263,268,createSetListpackObject,,,19,robj createSetListpackObject (void)
228246,METHOD,object.c:<global>,TYPE_DECL,"robj *createHashObject(void) {
    unsigned char *zl = lpNew(0);
    robj *o = createObject(OBJ_HASH, zl);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",1,27,object.c,createHashObject,,false,270,275,createHashObject,,,20,robj createHashObject (void)
228273,METHOD,object.c:<global>,TYPE_DECL,"robj *createZsetObject(void) {
    zset *zs = zmalloc(sizeof(*zs));
    robj *o;

    zs->dict = dictCreate(&zsetDictType);
    zs->zsl = zslCreate();
    o = createObject(OBJ_ZSET,zs);
    o->encoding = OBJ_ENCODING_SKIPLIST;
    return o;
}",1,21,object.c,createZsetObject,,false,277,286,createZsetObject,,,21,robj createZsetObject (void)
228314,METHOD,object.c:<global>,TYPE_DECL,"robj *createZsetListpackObject(void) {
    unsigned char *lp = lpNew(0);
    robj *o = createObject(OBJ_ZSET,lp);
    o->encoding = OBJ_ENCODING_LISTPACK;
    return o;
}",1,27,object.c,createZsetListpackObject,,false,288,293,createZsetListpackObject,,,22,robj createZsetListpackObject (void)
228341,METHOD,object.c:<global>,TYPE_DECL,"robj *createStreamObject(void) {
    stream *s = streamNew();
    robj *o = createObject(OBJ_STREAM,s);
    o->encoding = OBJ_ENCODING_STREAM;
    return o;
}",1,27,object.c,createStreamObject,,false,295,300,createStreamObject,,,23,robj createStreamObject (void)
228367,METHOD,object.c:<global>,TYPE_DECL,"robj *createModuleObject(moduleType *mt, void *value) {
    moduleValue *mv = zmalloc(sizeof(*mv));
    mv->type = mt;
    mv->value = value;
    return createObject(OBJ_MODULE,mv);
}",1,24,object.c,createModuleObject,,false,302,307,createModuleObject,,,24,"robj createModuleObject (moduleType*,void*)"
228396,METHOD,object.c:<global>,TYPE_DECL,"void freeStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        sdsfree(o->ptr);
    }
}",1,23,object.c,freeStringObject,,false,309,313,freeStringObject,,,25,void freeStringObject (robj*)
228414,METHOD,object.c:<global>,TYPE_DECL,"void freeListObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistRelease(o->ptr);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        lpFree(o->ptr);
    } else {
        serverPanic(""Unknown list encoding type"");
    }
}",1,23,object.c,freeListObject,,false,315,323,freeListObject,,,26,void freeListObject (robj*)
228457,METHOD,object.c:<global>,TYPE_DECL,"void freeSetObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_INTSET:
    case OBJ_ENCODING_LISTPACK:
        zfree(o->ptr);
        break;
    default:
        serverPanic(""Unknown set encoding type"");
    }
}",1,9,object.c,freeSetObject,,false,325,337,freeSetObject,,,27,void freeSetObject (robj*)
228500,METHOD,object.c:<global>,TYPE_DECL,"void freeZsetObject(robj *o) {
    zset *zs;
    switch (o->encoding) {
    case OBJ_ENCODING_SKIPLIST:
        zs = o->ptr;
        dictRelease(zs->dict);
        zslFree(zs->zsl);
        zfree(zs);
        break;
    case OBJ_ENCODING_LISTPACK:
        zfree(o->ptr);
        break;
    default:
        serverPanic(""Unknown sorted set encoding"");
    }
}",1,9,object.c,freeZsetObject,,false,339,354,freeZsetObject,,,28,void freeZsetObject (robj*)
228549,METHOD,object.c:<global>,TYPE_DECL,"void freeHashObject(robj *o) {
    switch (o->encoding) {
    case OBJ_ENCODING_HT:
        dictRelease((dict*) o->ptr);
        break;
    case OBJ_ENCODING_LISTPACK:
        lpFree(o->ptr);
        break;
    default:
        serverPanic(""Unknown hash encoding type"");
        break;
    }
}",1,9,object.c,freeHashObject,,false,356,368,freeHashObject,,,29,void freeHashObject (robj*)
228589,METHOD,object.c:<global>,TYPE_DECL,"void freeModuleObject(robj *o) {
    moduleValue *mv = o->ptr;
    mv->type->free(mv->value);
    zfree(mv);
}",1,1,object.c,freeModuleObject,,false,370,374,freeModuleObject,,,30,void freeModuleObject (robj*)
228611,METHOD,object.c:<global>,TYPE_DECL,"void freeStreamObject(robj *o) {
    freeStream(o->ptr);
}",1,1,object.c,freeStreamObject,,false,376,378,freeStreamObject,,,31,void freeStreamObject (robj*)
228620,METHOD,object.c:<global>,TYPE_DECL,"void incrRefCount(robj *o) {
    if (o->refcount < OBJ_FIRST_SPECIAL_REFCOUNT) {
        o->refcount++;
    } else {
        if (o->refcount == OBJ_SHARED_REFCOUNT) {
            /* Nothing to do: this refcount is immutable. */
        } else if (o->refcount == OBJ_STATIC_REFCOUNT) {
            serverPanic(""You tried to retain an object allocated in the stack"");
        }
    }
}",1,22,object.c,incrRefCount,,false,380,390,incrRefCount,,,32,void incrRefCount (robj*)
228672,METHOD,object.c:<global>,TYPE_DECL,"void decrRefCount(robj *o) {
    if (o->refcount == 1) {
        switch(o->type) {
        case OBJ_STRING: freeStringObject(o); break;
        case OBJ_LIST: freeListObject(o); break;
        case OBJ_SET: freeSetObject(o); break;
        case OBJ_ZSET: freeZsetObject(o); break;
        case OBJ_HASH: freeHashObject(o); break;
        case OBJ_MODULE: freeModuleObject(o); break;
        case OBJ_STREAM: freeStreamObject(o); break;
        default: serverPanic(""Unknown object type""); break;
        }
        zfree(o);
    } else {
        if (o->refcount <= 0) serverPanic(""decrRefCount against refcount <= 0"");
        if (o->refcount != OBJ_SHARED_REFCOUNT) o->refcount--;
    }
}",1,13,object.c,decrRefCount,,false,392,409,decrRefCount,,,33,void decrRefCount (robj*)
228780,METHOD,object.c:<global>,TYPE_DECL,"void dismissSds(sds s) {
    dismissMemory(sdsAllocPtr(s), sdsAllocSize(s));
}",1,1,object.c,dismissSds,,false,412,414,dismissSds,,,34,void dismissSds (sds)
228790,METHOD,object.c:<global>,TYPE_DECL,"void dismissStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        dismissSds(o->ptr);
    }
}",1,23,object.c,dismissStringObject,,false,417,421,dismissStringObject,,,35,void dismissStringObject (robj*)
228808,METHOD,object.c:<global>,TYPE_DECL,"void dismissListObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        serverAssert(ql->len != 0);
        /* We iterate all nodes only when average node size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / ql->len >= server.page_size) {
            quicklistNode *node = ql->head;
            while (node) {
                if (quicklistNodeIsCompressed(node)) {
                    dismissMemory(node->entry, ((quicklistLZF*)node->entry)->sz);
                } else {
                    dismissMemory(node->entry, node->sz);
                }
                node = node->next;
            }
        }
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        dismissMemory(o->ptr, lpBytes((unsigned char*)o->ptr));
    } else {
        serverPanic(""Unknown list encoding type"");
    }
}",1,23,object.c,dismissListObject,,false,424,446,dismissListObject,,,36,"void dismissListObject (robj*,size_t)"
228933,METHOD,object.c:<global>,TYPE_DECL,"void dismissSetObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *set = o->ptr;
        serverAssert(dictSize(set) != 0);
        /* We iterate all nodes only when average member size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / dictSize(set) >= server.page_size) {
            dictEntry *de;
            dictIterator *di = dictGetIterator(set);
            while ((de = dictNext(di)) != NULL) {
                dismissSds(dictGetKey(de));
            }
            dictReleaseIterator(di);
        }

        /* Dismiss hash table memory. */
        dismissMemory(set->ht_table[0], DICTHT_SIZE(set->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(set->ht_table[1], DICTHT_SIZE(set->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_INTSET) {
        dismissMemory(o->ptr, intsetBlobLen((intset*)o->ptr));
    } else if (o->encoding =...",1,23,object.c,dismissSetObject,,false,449,474,dismissSetObject,,,37,"void dismissSetObject (robj*,size_t)"
229143,METHOD,object.c:<global>,TYPE_DECL,"void dismissZsetObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = o->ptr;
        zskiplist *zsl = zs->zsl;
        serverAssert(zsl->length != 0);
        /* We iterate all nodes only when average member size is bigger than a
         * page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / zsl->length >= server.page_size) {
            zskiplistNode *zn = zsl->tail;
            while (zn != NULL) {
                dismissSds(zn->ele);
                zn = zn->backward;
            }
        }

        /* Dismiss hash table memory. */
        dict *d = zs->dict;
        dismissMemory(d->ht_table[0], DICTHT_SIZE(d->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(d->ht_table[1], DICTHT_SIZE(d->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        dismissMemory(o->ptr, lpBytes((unsigned char*)o->ptr));
    } else {
        serverPanic...",1,23,object.c,dismissZsetObject,,false,477,501,dismissZsetObject,,,38,"void dismissZsetObject (robj*,size_t)"
229326,METHOD,object.c:<global>,TYPE_DECL,"void dismissHashObject(robj *o, size_t size_hint) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *d = o->ptr;
        serverAssert(dictSize(d) != 0);
        /* We iterate all fields only when average field/value size is bigger than
         * a page size, and there's a high chance we'll actually dismiss something. */
        if (size_hint / dictSize(d) >= server.page_size) {
            dictEntry *de;
            dictIterator *di = dictGetIterator(d);
            while ((de = dictNext(di)) != NULL) {
                /* Only dismiss values memory since the field size
                 * usually is small. */
                dismissSds(dictGetVal(de));
            }
            dictReleaseIterator(di);
        }

        /* Dismiss hash table memory. */
        dismissMemory(d->ht_table[0], DICTHT_SIZE(d->ht_size_exp[0])*sizeof(dictEntry*));
        dismissMemory(d->ht_table[1], DICTHT_SIZE(d->ht_size_exp[1])*sizeof(dictEntry*));
    } else if (o->encoding == OBJ_ENCODING_LIS...",1,23,object.c,dismissHashObject,,false,504,529,dismissHashObject,,,39,"void dismissHashObject (robj*,size_t)"
229515,METHOD,object.c:<global>,TYPE_DECL,"void dismissStreamObject(robj *o, size_t size_hint) {
    stream *s = o->ptr;
    rax *rax = s->rax;
    if (raxSize(rax) == 0) return;

    /* Iterate only on stream entries, although size_hint may include serialized
     * consumer groups info, but usually, stream entries take up most of
     * the space. */
    if (size_hint / raxSize(rax) >= server.page_size) {
        raxIterator ri;
        raxStart(&ri,rax);
        raxSeek(&ri,""^"",NULL,0);
        while (raxNext(&ri)) {
            dismissMemory(ri.data, lpBytes(ri.data));
        }
        raxStop(&ri);
    }
}",1,1,object.c,dismissStreamObject,,false,532,549,dismissStreamObject,,,40,"void dismissStreamObject (robj*,size_t)"
229577,METHOD,object.c:<global>,TYPE_DECL,"void dismissObject(robj *o, size_t size_hint) {
    /* madvise(MADV_DONTNEED) may not work if Transparent Huge Pages is enabled. */
    if (server.thp_enabled) return;

    /* Currently we use zmadvise_dontneed only when we use jemalloc with Linux.
     * so we avoid these pointless loops when they're not going to do anything. */
#if defined(USE_JEMALLOC) && defined(__linux__)
    if (o->refcount != 1) return;
    switch(o->type) {
        case OBJ_STRING: dismissStringObject(o); break;
        case OBJ_LIST: dismissListObject(o, size_hint); break;
        case OBJ_SET: dismissSetObject(o, size_hint); break;
        case OBJ_ZSET: dismissZsetObject(o, size_hint); break;
        case OBJ_HASH: dismissHashObject(o, size_hint); break;
        case OBJ_STREAM: dismissStreamObject(o, size_hint); break;
        default: break;
    }
#else
    UNUSED(o); UNUSED(size_hint);
#endif
}",1,4,object.c,dismissObject,,false,564,584,dismissObject,,,41,"void dismissObject (robj*,size_t)"
229601,METHOD,object.c:<global>,TYPE_DECL,"void decrRefCountVoid(void *o) {
    decrRefCount(o);
}",1,1,object.c,decrRefCountVoid,,false,589,591,decrRefCountVoid,,,42,void decrRefCountVoid (void*)
229608,METHOD,object.c:<global>,TYPE_DECL,"int checkType(client *c, robj *o, int type) {
    /* A NULL is considered an empty key */
    if (o && o->type != type) {
        addReplyErrorObject(c,shared.wrongtypeerr);
        return 1;
    }
    return 0;
}",1,1,object.c,checkType,,false,593,600,checkType,,,43,"int checkType (client*,robj*,int)"
229633,METHOD,object.c:<global>,TYPE_DECL,"int isSdsRepresentableAsLongLong(sds s, long long *llval) {
    return string2ll(s,sdslen(s),llval) ? C_OK : C_ERR;
}",1,42,object.c,isSdsRepresentableAsLongLong,,false,602,604,isSdsRepresentableAsLongLong,,,44,"int isSdsRepresentableAsLongLong (sds,long long*)"
229653,METHOD,object.c:<global>,TYPE_DECL,"int isObjectRepresentableAsLongLong(robj *o, long long *llval) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    if (o->encoding == OBJ_ENCODING_INT) {
        if (llval) *llval = (long) o->ptr;
        return C_OK;
    } else {
        return isSdsRepresentableAsLongLong(o->ptr,llval);
    }
}",1,4,object.c,isObjectRepresentableAsLongLong,,false,606,614,isObjectRepresentableAsLongLong,,,45,"int isObjectRepresentableAsLongLong (robj*,long long*)"
229713,METHOD,object.c:<global>,TYPE_DECL,"void trimStringObjectIfNeeded(robj *o, int trim_small_values) {
    if (o->encoding != OBJ_ENCODING_RAW) return;
    /* A string may have free space in the following cases:
     * 1. When an arg len is greater than PROTO_MBULK_BIG_ARG the query buffer may be used directly as the SDS string.
     * 2. When utilizing the argument caching mechanism in Lua. 
     * 3. When calling from RM_TrimStringAllocation (trim_small_values is true). */
    size_t len = sdslen(o->ptr);
    if (len >= PROTO_MBULK_BIG_ARG ||
        trim_small_values||
        (server.executing_client && server.executing_client->flags & CLIENT_SCRIPT && len < LUA_CMD_OBJCACHE_MAX_LEN)) {
        if (sdsavail(o->ptr) > len/10) {
            o->ptr = sdsRemoveFreeSpace(o->ptr, 0);
        }
    }
}",1,23,object.c,trimStringObjectIfNeeded,,false,618,632,trimStringObjectIfNeeded,,,46,"void trimStringObjectIfNeeded (robj*,int)"
229788,METHOD,object.c:<global>,TYPE_DECL,"robj *tryObjectEncodingEx(robj *o, int try_trim) {
    long value;
    sds s = o->ptr;
    size_t len;

    /* Make sure this is a string object, the only type we encode
     * in this function. Other types use encoded memory efficient
     * representations but are handled by the commands implementing
     * the type. */
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);

    /* We try some specialized encoding only for objects that are
     * RAW or EMBSTR encoded, in other words objects that are still
     * in represented by an actually array of chars. */
    if (!sdsEncodedObject(o)) return o;

    /* It's not safe to encode shared objects: shared objects can be shared
     * everywhere in the ""object space"" of Redis and may end in places where
     * they are not handled. We handle them only as values in the keyspace. */
     if (o->refcount > 1) return o;

    /* Check if we can represent this string as a long integer.
     * Note that we are sure that a string larger th...",1,4,object.c,tryObjectEncodingEx,,false,635,705,tryObjectEncodingEx,,,47,"robj tryObjectEncodingEx (robj*,int)"
229991,METHOD,object.c:<global>,TYPE_DECL,"robj *tryObjectEncoding(robj *o) {
    return tryObjectEncodingEx(o, 1);
}",1,1,object.c,tryObjectEncoding,,false,707,709,tryObjectEncoding,,,48,robj tryObjectEncoding (robj*)
230000,METHOD,object.c:<global>,TYPE_DECL,"robj *getDecodedObject(robj *o) {
    robj *dec;

    if (sdsEncodedObject(o)) {
        incrRefCount(o);
        return o;
    }
    if (o->type == OBJ_STRING && o->encoding == OBJ_ENCODING_INT) {
        char buf[32];

        ll2string(buf,32,(long)o->ptr);
        dec = createStringObject(buf,strlen(buf));
        return dec;
    } else {
        serverPanic(""Unknown encoding type"");
    }
}",1,8,object.c,getDecodedObject,,false,713,729,getDecodedObject,,,49,robj getDecodedObject (robj*)
230070,METHOD,object.c:<global>,TYPE_DECL,"int compareStringObjectsWithFlags(const robj *a, const robj *b, int flags) {
    serverAssertWithInfo(NULL,a,a->type == OBJ_STRING && b->type == OBJ_STRING);
    char bufa[128], bufb[128], *astr, *bstr;
    size_t alen, blen, minlen;

    if (a == b) return 0;
    if (sdsEncodedObject(a)) {
        astr = a->ptr;
        alen = sdslen(astr);
    } else {
        alen = ll2string(bufa,sizeof(bufa),(long) a->ptr);
        astr = bufa;
    }
    if (sdsEncodedObject(b)) {
        bstr = b->ptr;
        blen = sdslen(bstr);
    } else {
        blen = ll2string(bufb,sizeof(bufb),(long) b->ptr);
        bstr = bufb;
    }
    if (flags & REDIS_COMPARE_COLL) {
        return strcoll(astr,bstr);
    } else {
        int cmp;

        minlen = (alen < blen) ? alen : blen;
        cmp = memcmp(astr,bstr,minlen);
        if (cmp == 0) return alen-blen;
        return cmp;
    }
}",1,4,object.c,compareStringObjectsWithFlags,,false,742,772,compareStringObjectsWithFlags,,,50,"int compareStringObjectsWithFlags (robj*,robj*,int)"
230242,METHOD,object.c:<global>,TYPE_DECL,"int compareStringObjects(const robj *a, const robj *b) {
    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_BINARY);
}",1,45,object.c,compareStringObjects,,false,775,777,compareStringObjects,,,51,"int compareStringObjects (robj*,robj*)"
230257,METHOD,object.c:<global>,TYPE_DECL,"int collateStringObjects(const robj *a, const robj *b) {
    return compareStringObjectsWithFlags(a,b,REDIS_COMPARE_COLL);
}",1,45,object.c,collateStringObjects,,false,780,782,collateStringObjects,,,52,"int collateStringObjects (robj*,robj*)"
230272,METHOD,object.c:<global>,TYPE_DECL,"int equalStringObjects(robj *a, robj *b) {
    if (a->encoding == OBJ_ENCODING_INT &&
        b->encoding == OBJ_ENCODING_INT){
        /* If both strings are integer encoded just check if the stored
         * long is the same. */
        return a->ptr == b->ptr;
    } else {
        return compareStringObjects(a,b) == 0;
    }
}",1,23,object.c,equalStringObjects,,false,788,797,equalStringObjects,,,53,"int equalStringObjects (robj*,robj*)"
230311,METHOD,object.c:<global>,TYPE_DECL,"size_t stringObjectLen(robj *o) {
    serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
    if (sdsEncodedObject(o)) {
        return sdslen(o->ptr);
    } else {
        return sdigits10((long)o->ptr);
    }
}",1,4,object.c,stringObjectLen,,false,799,806,stringObjectLen,,,54,size_t stringObjectLen (robj*)
230368,METHOD,object.c:<global>,TYPE_DECL,"int getDoubleFromObject(const robj *o, double *target) {
    double value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (!string2d(o->ptr, sdslen(o->ptr), &value))
                return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    *target = value;
    return C_OK;
}",1,8,object.c,getDoubleFromObject,,false,808,826,getDoubleFromObject,,,55,"int getDoubleFromObject (robj*,double*)"
230477,METHOD,object.c:<global>,TYPE_DECL,"int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg) {
    double value;
    if (getDoubleFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not a valid float"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",1,42,object.c,getDoubleFromObjectOrReply,,false,828,840,getDoubleFromObjectOrReply,,,56,"int getDoubleFromObjectOrReply (client*,robj*,double*,char*)"
230524,METHOD,object.c:<global>,TYPE_DECL,"int getLongDoubleFromObject(robj *o, long double *target) {
    long double value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (!string2ld(o->ptr, sdslen(o->ptr), &value))
                return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    *target = value;
    return C_OK;
}",1,8,object.c,getLongDoubleFromObject,,false,842,860,getLongDoubleFromObject,,,57,"int getLongDoubleFromObject (robj*,long double*)"
230633,METHOD,object.c:<global>,TYPE_DECL,"int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg) {
    long double value;
    if (getLongDoubleFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not a valid float"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",1,46,object.c,getLongDoubleFromObjectOrReply,,false,862,874,getLongDoubleFromObjectOrReply,,,58,"int getLongDoubleFromObjectOrReply (client*,robj*,long double*,char*)"
230680,METHOD,object.c:<global>,TYPE_DECL,"int getLongLongFromObject(robj *o, long long *target) {
    long long value;

    if (o == NULL) {
        value = 0;
    } else {
        serverAssertWithInfo(NULL,o,o->type == OBJ_STRING);
        if (sdsEncodedObject(o)) {
            if (string2ll(o->ptr,sdslen(o->ptr),&value) == 0) return C_ERR;
        } else if (o->encoding == OBJ_ENCODING_INT) {
            value = (long)o->ptr;
        } else {
            serverPanic(""Unknown string encoding"");
        }
    }
    if (target) *target = value;
    return C_OK;
}",1,8,object.c,getLongLongFromObject,,false,876,893,getLongLongFromObject,,,59,"int getLongLongFromObject (robj*,long long*)"
230793,METHOD,object.c:<global>,TYPE_DECL,"int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg) {
    long long value;
    if (getLongLongFromObject(o, &value) != C_OK) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is not an integer or out of range"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",1,44,object.c,getLongLongFromObjectOrReply,,false,895,907,getLongLongFromObjectOrReply,,,60,"int getLongLongFromObjectOrReply (client*,robj*,long long*,char*)"
230840,METHOD,object.c:<global>,TYPE_DECL,"int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
    long long value;

    if (getLongLongFromObjectOrReply(c, o, &value, msg) != C_OK) return C_ERR;
    if (value < LONG_MIN || value > LONG_MAX) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyError(c,""value is out of range"");
        }
        return C_ERR;
    }
    *target = value;
    return C_OK;
}",1,59,object.c,getLongFromObjectOrReply,,false,909,923,getLongFromObjectOrReply,,,61,"int getLongFromObjectOrReply (client*,robj*,long*,char*)"
230903,METHOD,object.c:<global>,TYPE_DECL,"int getRangeLongFromObjectOrReply(client *c, robj *o, long min, long max, long *target, const char *msg) {
    if (getLongFromObjectOrReply(c, o, target, msg) != C_OK) return C_ERR;
    if (*target < min || *target > max) {
        if (msg != NULL) {
            addReplyError(c,(char*)msg);
        } else {
            addReplyErrorFormat(c,""value is out of range, value must between %ld and %ld"", min, max);
        }
        return C_ERR;
    }
    return C_OK;
}",1,55,object.c,getRangeLongFromObjectOrReply,,false,925,936,getRangeLongFromObjectOrReply,,,62,"int getRangeLongFromObjectOrReply (client*,robj*,long,long,long*,char*)"
230966,METHOD,object.c:<global>,TYPE_DECL,"int getPositiveLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg) {
    if (msg) {
        return getRangeLongFromObjectOrReply(c, o, 0, LONG_MAX, target, msg);
    } else {
        return getRangeLongFromObjectOrReply(c, o, 0, LONG_MAX, target, ""value is out of range, must be positive"");
    }
}",1,1,object.c,getPositiveLongFromObjectOrReply,,false,938,944,getPositiveLongFromObjectOrReply,,,63,"int getPositiveLongFromObjectOrReply (client*,robj*,long*,char*)"
230995,METHOD,object.c:<global>,TYPE_DECL,"int getIntFromObjectOrReply(client *c, robj *o, int *target, const char *msg) {
    long value;

    if (getRangeLongFromObjectOrReply(c, o, INT_MIN, INT_MAX, &value, msg) != C_OK)
        return C_ERR;

    *target = value;
    return C_OK;
}",1,78,object.c,getIntFromObjectOrReply,,false,946,954,getIntFromObjectOrReply,,,64,"int getIntFromObjectOrReply (client*,robj*,int*,char*)"
231031,METHOD,object.c:<global>,TYPE_DECL,"char *strEncoding(int encoding) {
    switch(encoding) {
    case OBJ_ENCODING_RAW: return ""raw"";
    case OBJ_ENCODING_INT: return ""int"";
    case OBJ_ENCODING_HT: return ""hashtable"";
    case OBJ_ENCODING_QUICKLIST: return ""quicklist"";
    case OBJ_ENCODING_LISTPACK: return ""listpack"";
    case OBJ_ENCODING_INTSET: return ""intset"";
    case OBJ_ENCODING_SKIPLIST: return ""skiplist"";
    case OBJ_ENCODING_EMBSTR: return ""embstr"";
    case OBJ_ENCODING_STREAM: return ""stream"";
    default: return ""unknown"";
    }
}",1,9,object.c,strEncoding,,false,956,969,strEncoding,,,65,char* strEncoding (int)
231096,METHOD,object.c:<global>,TYPE_DECL,"size_t streamRadixTreeMemoryUsage(rax *rax) {
    size_t size = sizeof(*rax);
    size = rax->numele * sizeof(streamID);
    size += rax->numnodes * sizeof(raxNode);
    /* Add a fixed overhead due to the aux data pointer, children, ... */
    size += rax->numnodes * sizeof(long)*30;
    return size;
}",1,1,object.c,streamRadixTreeMemoryUsage,,false,988,995,streamRadixTreeMemoryUsage,,,66,size_t streamRadixTreeMemoryUsage (rax*)
231135,METHOD,object.c:<global>,TYPE_DECL,"size_t objectComputeSize(robj *key, robj *o, size_t sample_size, int dbid) {
    sds ele, ele2;
    dict *d;
    dictIterator *di;
    struct dictEntry *de;
    size_t asize = 0, elesize = 0, samples = 0;

    if (o->type == OBJ_STRING) {
        if(o->encoding == OBJ_ENCODING_INT) {
            asize = sizeof(*o);
        } else if(o->encoding == OBJ_ENCODING_RAW) {
            asize = sdsZmallocSize(o->ptr)+sizeof(*o);
        } else if(o->encoding == OBJ_ENCODING_EMBSTR) {
            asize = zmalloc_size((void *)o);
        } else {
            serverPanic(""Unknown string encoding"");
        }
    } else if (o->type == OBJ_LIST) {
        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
            quicklist *ql = o->ptr;
            quicklistNode *node = ql->head;
            asize = sizeof(*o)+sizeof(quicklist);
            do {
                elesize += sizeof(quicklistNode)+zmalloc_size(node->entry);
                samples++;
            } while ((node = node->next) && samples...",1,19,object.c,objectComputeSize,,false,1002,1161,objectComputeSize,,,67,"size_t objectComputeSize (robj*,robj*,size_t,int)"
232146,METHOD,object.c:<global>,TYPE_DECL,"void freeMemoryOverheadData(struct redisMemOverhead *mh) {
    zfree(mh->db);
    zfree(mh);
}",1,1,object.c,freeMemoryOverheadData,,false,1164,1167,freeMemoryOverheadData,,,68,void freeMemoryOverheadData (redisMemOverhead*)
232157,METHOD,object.c:<global>,TYPE_DECL,"struct redisMemOverhead *getMemoryOverheadData(void) {
    int j;
    size_t mem_total = 0;
    size_t mem = 0;
    size_t zmalloc_used = zmalloc_used_memory();
    struct redisMemOverhead *mh = zcalloc(sizeof(*mh));

    mh->total_allocated = zmalloc_used;
    mh->startup_allocated = server.initial_memory_usage;
    mh->peak_allocated = server.stat_peak_memory;
    mh->total_frag =
        (float)server.cron_malloc_stats.process_rss / server.cron_malloc_stats.zmalloc_used;
    mh->total_frag_bytes =
        server.cron_malloc_stats.process_rss - server.cron_malloc_stats.zmalloc_used;
    mh->allocator_frag =
        (float)server.cron_malloc_stats.allocator_active / server.cron_malloc_stats.allocator_allocated;
    mh->allocator_frag_bytes =
        server.cron_malloc_stats.allocator_active - server.cron_malloc_stats.allocator_allocated;
    mh->allocator_rss =
        (float)server.cron_malloc_stats.allocator_resident / server.cron_malloc_stats.allocator_active;
    mh->allocator_...",1,8,object.c,getMemoryOverheadData,,false,1172,1287,getMemoryOverheadData,,,69,struct redisMemOverhead getMemoryOverheadData (void)
232829,METHOD,object.c:<global>,TYPE_DECL,"void inputCatSds(void *result, const char *str) {
    /* result is actually a (sds *), so re-cast it here */
    sds *info = (sds *)result;
    *info = sdscat(*info, str);
}",1,1,object.c,inputCatSds,,false,1291,1295,inputCatSds,,,70,"void inputCatSds (void*,char*)"
232848,METHOD,object.c:<global>,TYPE_DECL,"sds getMemoryDoctorReport(void) {
    int empty = 0;          /* Instance is empty or almost empty. */
    int big_peak = 0;       /* Memory peak is much larger than used mem. */
    int high_frag = 0;      /* High fragmentation. */
    int high_alloc_frag = 0;/* High allocator fragmentation. */
    int high_proc_rss = 0;  /* High process rss overhead. */
    int high_alloc_rss = 0; /* High rss overhead. */
    int big_slave_buf = 0;  /* Slave buffers are too big. */
    int big_client_buf = 0; /* Client buffers are too big. */
    int many_scripts = 0;   /* Script cache has too many scripts. */
    int num_reports = 0;
    struct redisMemOverhead *mh = getMemoryOverheadData();

    if (mh->total_allocated < (1024*1024*5)) {
        empty = 1;
        num_reports++;
    } else {
        /* Peak is > 150% of current used memory? */
        if (((float)mh->peak_allocated / mh->total_allocated) > 1.5) {
            big_peak = 1;
            num_reports++;
        }

        /* Fragment...",1,25,object.c,getMemoryDoctorReport,,false,1299,1409,getMemoryDoctorReport,,,71,sds getMemoryDoctorReport (void)
233203,METHOD,object.c:<global>,TYPE_DECL,"int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
                       long long lru_clock, int lru_multiplier) {
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        if (lfu_freq >= 0) {
            serverAssert(lfu_freq <= 255);
            val->lru = (LFUGetTimeInMinutes()<<8) | lfu_freq;
            return 1;
        }
    } else if (lru_idle >= 0) {
        /* Provided LRU idle time is in seconds. Scale
         * according to the LRU clock resolution this Redis
         * instance was compiled with (normally 1000 ms, so the
         * below statement will expand to lru_idle*1000/1000. */
        lru_idle = lru_idle*lru_multiplier/LRU_CLOCK_RESOLUTION;
        long lru_abs = lru_clock - lru_idle; /* Absolute access time. */
        /* If the LRU field underflows (since lru_clock is a wrapping clock),
         * we need to make it positive again. This be handled by the unwrapping
         * code in estimateObjectIdleTime. I.e. imagine a day wh...",1,34,object.c,objectSetLRUOrLFU,,false,1416,1442,objectSetLRUOrLFU,,,72,"int objectSetLRUOrLFU (robj*,long long,long long,long long,int)"
233300,METHOD,object.c:<global>,TYPE_DECL,"robj *objectCommandLookup(client *c, robj *key) {
    return lookupKeyReadWithFlags(c->db,key,LOOKUP_NOTOUCH|LOOKUP_NONOTIFY);
}",1,44,object.c,objectCommandLookup,,false,1448,1450,objectCommandLookup,,,73,"robj objectCommandLookup (client*,robj*)"
233323,METHOD,object.c:<global>,TYPE_DECL,"robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply) {
    robj *o = objectCommandLookup(c,key);
    if (!o) addReplyOrErrorObject(c, reply);
    return o;
}",1,1,object.c,objectCommandLookupOrReply,,false,1452,1456,objectCommandLookupOrReply,,,74,"robj objectCommandLookupOrReply (client*,robj*,robj*)"
233345,METHOD,object.c:<global>,TYPE_DECL,"void objectCommand(client *c) {
    robj *o;

    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""ENCODING <key>"",
""    Return the kind of internal representation used in order to store the value"",
""    associated with a <key>."",
""FREQ <key>"",
""    Return the access frequency index of the <key>. The returned integer is"",
""    proportional to the logarithm of the recent access frequency of the key."",
""IDLETIME <key>"",
""    Return the idle time of the <key>, that is the approximated number of"",
""    seconds elapsed since the last access to the key."",
""REFCOUNT <key>"",
""    Return the number of references of the value associated with the specified"",
""    <key>."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""refcount"") && c->argc == 3) {
        if ((o = objectCommandLookupOrReply(c,c->argv[2],shared.null[c->resp]))
                == NULL) return;
        addReplyLongLong(c,o->refcount);
    } else...",1,38,object.c,objectCommand,,false,1460,1511,objectCommand,,,75,void objectCommand (client*)
233609,METHOD,object.c:<global>,TYPE_DECL,"void memoryCommand(client *c) {
    if (!strcasecmp(c->argv[1]->ptr,""help"") && c->argc == 2) {
        const char *help[] = {
""DOCTOR"",
""    Return memory problems reports."",
""MALLOC-STATS"",
""    Return internal statistics report from the memory allocator."",
""PURGE"",
""    Attempt to purge dirty pages for reclamation by the allocator."",
""STATS"",
""    Return information about the memory usage of the server."",
""USAGE <key> [SAMPLES <count>]"",
""    Return memory in bytes used by <key> and its value. Nested values are"",
""    sampled up to <count> times (default: 5, 0 means sample all)."",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""usage"") && c->argc >= 3) {
        dictEntry *de;
        long long samples = OBJ_COMPUTE_SIZE_DEF_SAMPLES;
        for (int j = 3; j < c->argc; j++) {
            if (!strcasecmp(c->argv[j]->ptr,""samples"") &&
                j+1 < c->argc)
            {
                if (getLongLongFromObjectOrReply(c,c->argv[j+...",1,28,object.c,memoryCommand,,false,1517,1688,memoryCommand,,,76,void memoryCommand (client*)
234270,METHOD,pqsort.c:<global>,TYPE_DECL,<global>,1,2,pqsort.c,pqsort.c:<global>,,false,1,185,<global>,,,1,
234272,METHOD,pqsort.c:<global>,TYPE_DECL,"static inline char	*med3 (char *, char *, char *,
    int (*)(const void *, const void *));",20,40,pqsort.c,med3,,false,45,46,med3,,,1,"char* med3 (char*,char*,char*,int)"
234280,METHOD,pqsort.c:<global>,TYPE_DECL,"static inline void	 swapfunc (char *, char *, size_t, int);",21,58,pqsort.c,swapfunc,,false,47,47,swapfunc,,,2,"void swapfunc (char*,char*,ANY,int)"
234288,METHOD,pqsort.c:<global>,TYPE_DECL,"static inline void
swapfunc(char *a, char *b, size_t n, int swaptype)
{

	if (swaptype <= 1)
		swapcode(long, a, b, n)
	else
		swapcode(char, a, b, n)
}",1,2,pqsort.c,swapfunc,,false,68,76,swapfunc,,,3,"void swapfunc (char*,char*,size_t,int)"
234393,METHOD,pqsort.c:<global>,TYPE_DECL,"static inline char *
med3(char *a, char *b, char *c,
    int (*cmp) (const void *, const void *))
{

	return cmp(a, b) < 0 ?
	       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))
              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));
}",1,1,pqsort.c,med3,,false,88,96,med3,,,4,"char* med3 (char*,char*,char*,int)"
234438,METHOD,pqsort.c:<global>,TYPE_DECL,"static void
_pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), void *lrange, void *rrange)
{
	char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
	size_t d, r;
	int swaptype, cmp_result;

loop:	SWAPINIT(a, es);
	if (n < 7) {
		for (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)
			for (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;
			     pl -= es)
				swap(pl, pl - es);
		return;
	}
	pm = (char *) a + (n / 2) * es;
	if (n > 7) {
		pl = (char *) a;
		pn = (char *) a + (n - 1) * es;
		if (n > 40) {
			d = (n / 8) * es;
			pl = med3(pl, pl + d, pl + 2 * d, cmp);
			pm = med3(pm - d, pm, pm + d, cmp);
			pn = med3(pn - 2 * d, pn - d, pn, cmp);
		}
		pm = med3(pl, pm, pn, cmp);
	}
	swap(a, pm);
	pa = pb = (char *) a + es;

	pc = pd = (char *) a + (n - 1) * es;
	for (;;) {
		while (pb <= pc && (cmp_result = cmp(pb, a)) <= 0) {
			if (cmp_result == 0) {
				swap(pa, pb);
				pa += es;
			}
			pb += es;
		}
		while (pb <= pc && (cmp_result = cmp(pc, a)) >...",1,6,pqsort.c,_pqsort,,false,98,177,_pqsort,,,5,"void _pqsort (void*,size_t,size_t,int,void*,void*)"
235138,METHOD,pqsort.c:<global>,TYPE_DECL,"void
pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
{
    _pqsort(a,n,es,cmp,((unsigned char*)a)+(lrange*es),
                       ((unsigned char*)a)+((rrange+1)*es)-1);
}",1,1,pqsort.c,pqsort,,false,179,185,pqsort,,,6,"void pqsort (void*,size_t,size_t,int,size_t,size_t)"
235174,METHOD,pqsort.h:<global>,TYPE_DECL,<global>,1,6,pqsort.h,pqsort.h:<global>,,false,1,40,<global>,,,1,
235176,METHOD,pqsort.h:<global>,TYPE_DECL,"void
pqsort(void *a, size_t n, size_t es,
    int (*cmp) (const void *, const void *), size_t lrange, size_t rrange);",1,74,pqsort.h,pqsort,,false,37,38,pqsort,,,1,"void pqsort (void*,size_t,size_t,int,size_t,size_t)"
235193,METHOD,pubsub.c:<global>,TYPE_DECL,<global>,1,1,pubsub.c,pubsub.c:<global>,,false,1,754,<global>,,,1,
235197,METHOD,pubsubtype,TYPE_DECL,dict *(*clientPubSubChannels)(client*);,10,42,pubsub.c,pubsubtype.clientPubSubChannels,,false,37,37,clientPubSubChannels,,,2,dict* pubsubtype.clientPubSubChannels (client*)
235202,METHOD,pubsubtype,TYPE_DECL,int (*subscriptionCount)(client*);,9,37,pubsub.c,pubsubtype.subscriptionCount,,false,38,38,subscriptionCount,,,3,int pubsubtype.subscriptionCount (client*)
235212,METHOD,pubsub.c:<global>,TYPE_DECL,int clientSubscriptionsCount(client *c);,5,39,pubsub.c,clientSubscriptionsCount,,false,48,48,clientSubscriptionsCount,,,3,int clientSubscriptionsCount (client*)
235217,METHOD,pubsub.c:<global>,TYPE_DECL,int clientShardSubscriptionsCount(client *c);,5,44,pubsub.c,clientShardSubscriptionsCount,,false,53,53,clientShardSubscriptionsCount,,,4,int clientShardSubscriptionsCount (client*)
235222,METHOD,pubsub.c:<global>,TYPE_DECL,dict* getClientPubSubChannels(client *c);,5,40,pubsub.c,getClientPubSubChannels,,false,58,58,getClientPubSubChannels,,,5,dict* getClientPubSubChannels (client*)
235227,METHOD,pubsub.c:<global>,TYPE_DECL,dict* getClientPubSubShardChannels(client *c);,5,45,pubsub.c,getClientPubSubShardChannels,,false,63,63,getClientPubSubShardChannels,,,6,dict* getClientPubSubShardChannels (client*)
235232,METHOD,pubsub.c:<global>,TYPE_DECL,"void channelList(client *c, sds pat, dict* pubsub_channels);",6,59,pubsub.c,channelList,,false,70,70,channelList,,,7,"void channelList (client*,sds,dict*)"
235327,METHOD,pubsub.c:<global>,TYPE_DECL,"void addReplyPubsubMessage(client *c, robj *channel, robj *msg, robj *message_bulk) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,message_bulk);
    addReplyBulk(c,channel);
    if (msg) addReplyBulk(c,msg);
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",1,16,pubsub.c,addReplyPubsubMessage,,false,107,118,addReplyPubsubMessage,,,12,"void addReplyPubsubMessage (client*,robj*,robj*,robj*)"
235401,METHOD,pubsub.c:<global>,TYPE_DECL,"void addReplyPubsubPatMessage(client *c, robj *pat, robj *channel, robj *msg) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[4]);
    else
        addReplyPushLen(c,4);
    addReply(c,shared.pmessagebulk);
    addReplyBulk(c,pat);
    addReplyBulk(c,channel);
    addReplyBulk(c,msg);
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",1,16,pubsub.c,addReplyPubsubPatMessage,,false,123,135,addReplyPubsubPatMessage,,,13,"void addReplyPubsubPatMessage (client*,robj*,robj*,robj*)"
235477,METHOD,pubsub.c:<global>,TYPE_DECL,"void addReplyPubsubSubscribed(client *c, robj *channel, pubsubtype type) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,*type.subscribeMsg);
    addReplyBulk(c,channel);
    addReplyLongLong(c,type.subscriptionCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",1,16,pubsub.c,addReplyPubsubSubscribed,,false,138,149,addReplyPubsubSubscribed,,,14,"void addReplyPubsubSubscribed (client*,robj*,pubsubtype)"
235554,METHOD,pubsub.c:<global>,TYPE_DECL,"void addReplyPubsubUnsubscribed(client *c, robj *channel, pubsubtype type) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c, *type.unsubscribeMsg);
    if (channel)
        addReplyBulk(c,channel);
    else
        addReplyNull(c);
    addReplyLongLong(c,type.subscriptionCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",1,16,pubsub.c,addReplyPubsubUnsubscribed,,false,155,169,addReplyPubsubUnsubscribed,,,15,"void addReplyPubsubUnsubscribed (client*,robj*,pubsubtype)"
235638,METHOD,pubsub.c:<global>,TYPE_DECL,"void addReplyPubsubPatSubscribed(client *c, robj *pattern) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,shared.psubscribebulk);
    addReplyBulk(c,pattern);
    addReplyLongLong(c,clientSubscriptionsCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",1,16,pubsub.c,addReplyPubsubPatSubscribed,,false,172,183,addReplyPubsubPatSubscribed,,,16,"void addReplyPubsubPatSubscribed (client*,robj*)"
235710,METHOD,pubsub.c:<global>,TYPE_DECL,"void addReplyPubsubPatUnsubscribed(client *c, robj *pattern) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;
    if (c->resp == 2)
        addReply(c,shared.mbulkhdr[3]);
    else
        addReplyPushLen(c,3);
    addReply(c,shared.punsubscribebulk);
    if (pattern)
        addReplyBulk(c,pattern);
    else
        addReplyNull(c);
    addReplyLongLong(c,clientSubscriptionsCount(c));
    if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
}",1,16,pubsub.c,addReplyPubsubPatUnsubscribed,,false,189,203,addReplyPubsubPatUnsubscribed,,,17,"void addReplyPubsubPatUnsubscribed (client*,robj*)"
235789,METHOD,pubsub.c:<global>,TYPE_DECL,"int serverPubsubSubscriptionCount(void) {
    return dictSize(server.pubsub_channels) + dictSize(server.pubsub_patterns);
}",1,11,pubsub.c,serverPubsubSubscriptionCount,,false,210,212,serverPubsubSubscriptionCount,,,18,int serverPubsubSubscriptionCount (void)
235836,METHOD,pubsub.c:<global>,TYPE_DECL,"int serverPubsubShardSubscriptionCount(void) {
    return dictSize(server.pubsubshard_channels);
}",1,11,pubsub.c,serverPubsubShardSubscriptionCount,,false,215,217,serverPubsubShardSubscriptionCount,,,19,int serverPubsubShardSubscriptionCount (void)
235862,METHOD,pubsub.c:<global>,TYPE_DECL,"int clientSubscriptionsCount(client *c) {
    return dictSize(c->pubsub_channels) + dictSize(c->pubsub_patterns);
}",1,11,pubsub.c,clientSubscriptionsCount,,false,221,223,clientSubscriptionsCount,,,20,int clientSubscriptionsCount (client*)
235909,METHOD,pubsub.c:<global>,TYPE_DECL,"int clientShardSubscriptionsCount(client *c) {
    return dictSize(c->pubsubshard_channels);
}",1,11,pubsub.c,clientShardSubscriptionsCount,,false,226,228,clientShardSubscriptionsCount,,,21,int clientShardSubscriptionsCount (client*)
235935,METHOD,pubsub.c:<global>,TYPE_DECL,"dict* getClientPubSubChannels(client *c) {
    return c->pubsub_channels;
}",1,1,pubsub.c,getClientPubSubChannels,,false,230,232,getClientPubSubChannels,,,22,dict getClientPubSubChannels (client*)
235944,METHOD,pubsub.c:<global>,TYPE_DECL,"dict* getClientPubSubShardChannels(client *c) {
    return c->pubsubshard_channels;
}",1,1,pubsub.c,getClientPubSubShardChannels,,false,234,236,getClientPubSubShardChannels,,,23,dict getClientPubSubShardChannels (client*)
235953,METHOD,pubsub.c:<global>,TYPE_DECL,"int clientTotalPubSubSubscriptionCount(client *c) {
    return clientSubscriptionsCount(c) + clientShardSubscriptionsCount(c);
}",1,1,pubsub.c,clientTotalPubSubSubscriptionCount,,false,240,242,clientTotalPubSubSubscriptionCount,,,24,int clientTotalPubSubSubscriptionCount (client*)
235964,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubSubscribeChannel(client *c, robj *channel, pubsubtype type) {
    dictEntry *de;
    list *clients = NULL;
    int retval = 0;

    /* Add the channel to the client -> channels hash table */
    if (dictAdd(type.clientPubSubChannels(c),channel,NULL) == DICT_OK) {
        retval = 1;
        incrRefCount(channel);
        /* Add the client to the channel -> list of clients hash table */
        de = dictFind(*type.serverPubSubChannels, channel);
        if (de == NULL) {
            clients = listCreate();
            dictAdd(*type.serverPubSubChannels, channel, clients);
            incrRefCount(channel);
        } else {
            clients = dictGetVal(de);
        }
        listAddNodeTail(clients,c);
    }
    /* Notify the client */
    addReplyPubsubSubscribed(c,channel,type);
    return retval;
}",1,62,pubsub.c,pubsubSubscribeChannel,,false,246,269,pubsubSubscribeChannel,,,25,"int pubsubSubscribeChannel (client*,robj*,pubsubtype)"
236039,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubUnsubscribeChannel(client *c, robj *channel, int notify, pubsubtype type) {
    dictEntry *de;
    list *clients;
    listNode *ln;
    int retval = 0;

    /* Remove the channel from the client -> channels hash table */
    incrRefCount(channel); /* channel may be just a pointer to the same object
                            we have in the hash tables. Protect it... */
    if (dictDelete(type.clientPubSubChannels(c),channel) == DICT_OK) {
        retval = 1;
        /* Remove the client from the channel -> clients list hash table */
        de = dictFind(*type.serverPubSubChannels, channel);
        serverAssertWithInfo(c,NULL,de != NULL);
        clients = dictGetVal(de);
        ln = listSearchKey(clients,c);
        serverAssertWithInfo(c,NULL,ln != NULL);
        listDelNode(clients,ln);
        if (listLength(clients) == 0) {
            /* Free the list and associated hash entry at all if this was
             * the latest client, so that it will be possible to abus...",1,60,pubsub.c,pubsubUnsubscribeChannel,,false,273,309,pubsubUnsubscribeChannel,,,26,"int pubsubUnsubscribeChannel (client*,robj*,int,pubsubtype)"
236172,METHOD,pubsub.c:<global>,TYPE_DECL,"void pubsubShardUnsubscribeAllClients(robj *channel) {
    int retval;
    dictEntry *de = dictFind(server.pubsubshard_channels, channel);
    serverAssertWithInfo(NULL,channel,de != NULL);
    list *clients = dictGetVal(de);
    if (listLength(clients) > 0) {
        /* For each client subscribed to the channel, unsubscribe it. */
        listIter li;
        listNode *ln;
        listRewind(clients, &li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = listNodeValue(ln);
            retval = dictDelete(c->pubsubshard_channels, channel);
            serverAssertWithInfo(c,channel,retval == DICT_OK);
            addReplyPubsubUnsubscribed(c, channel, pubSubShardType);
            /* If the client has no other pubsub subscription,
             * move out of pubsub mode. */
            if (clientTotalPubSubSubscriptionCount(c) == 0) {
                c->flags &= ~CLIENT_PUBSUB;
            }
        }
    }
    /* Delete the channel from server pubsubshard chann...",1,4,pubsub.c,pubsubShardUnsubscribeAllClients,,false,311,339,pubsubShardUnsubscribeAllClients,,,27,void pubsubShardUnsubscribeAllClients (robj*)
236325,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubSubscribePattern(client *c, robj *pattern) {
    dictEntry *de;
    list *clients;
    int retval = 0;

    if (dictAdd(c->pubsub_patterns, pattern, NULL) == DICT_OK) {
        retval = 1;
        incrRefCount(pattern);
        /* Add the client to the pattern -> list of clients hash table */
        de = dictFind(server.pubsub_patterns,pattern);
        if (de == NULL) {
            clients = listCreate();
            dictAdd(server.pubsub_patterns,pattern,clients);
            incrRefCount(pattern);
        } else {
            clients = dictGetVal(de);
        }
        listAddNodeTail(clients,c);
    }
    /* Notify the client */
    addReplyPubsubPatSubscribed(c,pattern);
    return retval;
}",1,54,pubsub.c,pubsubSubscribePattern,,false,343,365,pubsubSubscribePattern,,,28,"int pubsubSubscribePattern (client*,robj*)"
236391,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubUnsubscribePattern(client *c, robj *pattern, int notify) {
    dictEntry *de;
    list *clients;
    listNode *ln;
    int retval = 0;

    incrRefCount(pattern); /* Protect the object. May be the same we remove */
    if (dictDelete(c->pubsub_patterns, pattern) == DICT_OK) {
        retval = 1;
        /* Remove the client from the pattern -> clients list hash table */
        de = dictFind(server.pubsub_patterns,pattern);
        serverAssertWithInfo(c,NULL,de != NULL);
        clients = dictGetVal(de);
        ln = listSearchKey(clients,c);
        serverAssertWithInfo(c,NULL,ln != NULL);
        listDelNode(clients,ln);
        if (listLength(clients) == 0) {
            /* Free the list and associated hash entry at all if this was
             * the latest client. */
            dictDelete(server.pubsub_patterns,pattern);
        }
    }
    /* Notify the client */
    if (notify) addReplyPubsubPatUnsubscribed(c,pattern);
    decrRefCount(pattern);
    return retval;
}",1,51,pubsub.c,pubsubUnsubscribePattern,,false,369,395,pubsubUnsubscribePattern,,,29,"int pubsubUnsubscribePattern (client*,robj*,int)"
236505,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubUnsubscribeAllChannelsInternal(client *c, int notify, pubsubtype type) {
    int count = 0;
    if (dictSize(type.clientPubSubChannels(c)) > 0) {
        dictIterator *di = dictGetSafeIterator(type.clientPubSubChannels(c));
        dictEntry *de;

        while((de = dictNext(di)) != NULL) {
            robj *channel = dictGetKey(de);

            count += pubsubUnsubscribeChannel(c,channel,notify,type);
        }
        dictReleaseIterator(di);
    }
    /* We were subscribed to nothing? Still reply to the client. */
    if (notify && count == 0) {
        addReplyPubsubUnsubscribed(c,NULL,type);
    }
    return count;
}",1,8,pubsub.c,pubsubUnsubscribeAllChannelsInternal,,false,399,417,pubsubUnsubscribeAllChannelsInternal,,,30,"int pubsubUnsubscribeAllChannelsInternal (client*,int,pubsubtype)"
236591,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubUnsubscribeAllChannels(client *c, int notify) {
    int count = pubsubUnsubscribeAllChannelsInternal(c,notify,pubSubType);
    return count;
}",1,1,pubsub.c,pubsubUnsubscribeAllChannels,,false,422,425,pubsubUnsubscribeAllChannels,,,31,"int pubsubUnsubscribeAllChannels (client*,int)"
236606,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubUnsubscribeShardAllChannels(client *c, int notify) {
    int count = pubsubUnsubscribeAllChannelsInternal(c, notify, pubSubShardType);
    return count;
}",1,1,pubsub.c,pubsubUnsubscribeShardAllChannels,,false,430,433,pubsubUnsubscribeShardAllChannels,,,32,"int pubsubUnsubscribeShardAllChannels (client*,int)"
236621,METHOD,pubsub.c:<global>,TYPE_DECL,"void pubsubUnsubscribeShardChannels(robj **channels, unsigned int count) {
    for (unsigned int j = 0; j < count; j++) {
        /* Remove the channel from server and from the clients
         * subscribed to it as well as notify them. */
        pubsubShardUnsubscribeAllClients(channels[j]);
    }
}",1,1,pubsub.c,pubsubUnsubscribeShardChannels,,false,438,444,pubsubUnsubscribeShardChannels,,,33,"void pubsubUnsubscribeShardChannels (robj**,unsigned int)"
236643,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubUnsubscribeAllPatterns(client *c, int notify) {
    int count = 0;

    if (dictSize(c->pubsub_patterns) > 0) {
        dictIterator *di = dictGetSafeIterator(c->pubsub_patterns);
        dictEntry *de;

        while ((de = dictNext(di)) != NULL) {
            robj *pattern = dictGetKey(de);
            count += pubsubUnsubscribePattern(c, pattern, notify);
        }
        dictReleaseIterator(di);
    }

    /* We were subscribed to nothing? Still reply to the client. */
    if (notify && count == 0) addReplyPubsubPatUnsubscribed(c,NULL);
    return count;
}",1,8,pubsub.c,pubsubUnsubscribeAllPatterns,,false,448,465,pubsubUnsubscribeAllPatterns,,,34,"int pubsubUnsubscribeAllPatterns (client*,int)"
236718,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubPublishMessageInternal(robj *channel, robj *message, pubsubtype type) {
    int receivers = 0;
    dictEntry *de;
    dictIterator *di;
    listNode *ln;
    listIter li;

    /* Send to clients listening for that channel */
    de = dictFind(*type.serverPubSubChannels, channel);
    if (de) {
        list *list = dictGetVal(de);
        listNode *ln;
        listIter li;

        listRewind(list,&li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = ln->value;
            addReplyPubsubMessage(c,channel,message,*type.messageBulk);
            updateClientMemUsageAndBucket(c);
            receivers++;
        }
    }

    if (type.shard) {
        /* Shard pubsub ignores patterns. */
        return receivers;
    }

    /* Send to clients listening to matching channels */
    di = dictGetIterator(server.pubsub_patterns);
    if (di) {
        channel = getDecodedObject(channel);
        while((de = dictNext(di)) != NULL) {
            robj *pattern = ...",1,28,pubsub.c,pubsubPublishMessageInternal,,false,470,522,pubsubPublishMessageInternal,,,35,"int pubsubPublishMessageInternal (robj*,robj*,pubsubtype)"
236881,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubPublishMessage(robj *channel, robj *message, int sharded) {
    return pubsubPublishMessageInternal(channel, message, sharded? pubSubShardType : pubSubType);
}",1,1,pubsub.c,pubsubPublishMessage,,false,525,527,pubsubPublishMessage,,,36,"int pubsubPublishMessage (robj*,robj*,int)"
236896,METHOD,pubsub.c:<global>,TYPE_DECL,"void subscribeCommand(client *c) {
    int j;
    if ((c->flags & CLIENT_DENY_BLOCKING) && !(c->flags & CLIENT_MULTI)) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe.
         *
         * Notice that we have a special treatment for multi because of
         * backward compatibility
         */
        addReplyError(c, ""SUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }
    for (j = 1; j < c->argc; j++)
        pubsubSubscribeChannel(c,c->argv[j],pubSubType);
    c->flags |= CLIENT_PUBSUB;
}",1,20,pubsub.c,subscribeCommand,,false,534,550,subscribeCommand,,,37,void subscribeCommand (client*)
236957,METHOD,pubsub.c:<global>,TYPE_DECL,"void unsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeAllChannels(c,1);
    } else {
        int j;

        for (j = 1; j < c->argc; j++)
            pubsubUnsubscribeChannel(c,c->argv[j],1,pubSubType);
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",1,65,pubsub.c,unsubscribeCommand,,false,553,563,unsubscribeCommand,,,38,void unsubscribeCommand (client*)
237012,METHOD,pubsub.c:<global>,TYPE_DECL,"void psubscribeCommand(client *c) {
    int j;
    if ((c->flags & CLIENT_DENY_BLOCKING) && !(c->flags & CLIENT_MULTI)) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe.
         *
         * Notice that we have a special treatment for multi because of
         * backward compatibility
         */
        addReplyError(c, ""PSUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }

    for (j = 1; j < c->argc; j++)
        pubsubSubscribePattern(c,c->argv[j]);
    c->flags |= CLIENT_PUBSUB;
}",1,20,pubsub.c,psubscribeCommand,,false,566,583,psubscribeCommand,,,39,void psubscribeCommand (client*)
237072,METHOD,pubsub.c:<global>,TYPE_DECL,"void punsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeAllPatterns(c,1);
    } else {
        int j;

        for (j = 1; j < c->argc; j++)
            pubsubUnsubscribePattern(c,c->argv[j],1);
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",1,65,pubsub.c,punsubscribeCommand,,false,586,596,punsubscribeCommand,,,40,void punsubscribeCommand (client*)
237126,METHOD,pubsub.c:<global>,TYPE_DECL,"int pubsubPublishMessageAndPropagateToCluster(robj *channel, robj *message, int sharded) {
    int receivers = pubsubPublishMessage(channel, message, sharded);
    if (server.cluster_enabled)
        clusterPropagatePublish(channel, message, sharded);
    return receivers;
}",1,1,pubsub.c,pubsubPublishMessageAndPropagateToCluster,,false,600,605,pubsubPublishMessageAndPropagateToCluster,,,41,"int pubsubPublishMessageAndPropagateToCluster (robj*,robj*,int)"
237151,METHOD,pubsub.c:<global>,TYPE_DECL,"void publishCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelPublishCommand(c);
        return;
    }

    int receivers = pubsubPublishMessageAndPropagateToCluster(c->argv[1],c->argv[2],0);
    if (!server.cluster_enabled)
        forceCommandPropagation(c,PROPAGATE_REPL);
    addReplyLongLong(c,receivers);
}",1,34,pubsub.c,publishCommand,,false,608,618,publishCommand,,,42,void publishCommand (client*)
237193,METHOD,pubsub.c:<global>,TYPE_DECL,"void pubsubCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CHANNELS [<pattern>]"",
""    Return the currently active channels matching a <pattern> (default: '*')."",
""NUMPAT"",
""    Return number of subscriptions to patterns."",
""NUMSUB [<channel> ...]"",
""    Return the number of subscribers for the specified channels, excluding"",
""    pattern subscriptions(default: no channels)."",
""SHARDCHANNELS [<pattern>]"",
""    Return the currently active shard level channels matching a <pattern> (default: '*')."",
""SHARDNUMSUB [<shardchannel> ...]"",
""    Return the number of subscribers for the specified shard level channel(s)"",
NULL
        };
        addReplyHelp(c, help);
    } else if (!strcasecmp(c->argv[1]->ptr,""channels"") &&
        (c->argc == 2 || c->argc == 3))
    {
        /* PUBSUB CHANNELS [<pattern>] */
        sds pat = (c->argc == 2) ? NULL : c->argv[2]->ptr;
        channelList(c, pat, server.pubsub_channels);
    }...",1,35,pubsub.c,pubsubCommand,,false,621,678,pubsubCommand,,,43,void pubsubCommand (client*)
237525,METHOD,pubsub.c:<global>,TYPE_DECL,"void channelList(client *c, sds pat, dict *pubsub_channels) {
    dictIterator *di = dictGetIterator(pubsub_channels);
    dictEntry *de;
    long mblen = 0;
    void *replylen;

    replylen = addReplyDeferredLen(c);
    while((de = dictNext(di)) != NULL) {
        robj *cobj = dictGetKey(de);
        sds channel = cobj->ptr;

        if (!pat || stringmatchlen(pat, sdslen(pat),
                                   channel, sdslen(channel),0))
        {
            addReplyBulk(c,cobj);
            mblen++;
        }
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c,replylen,mblen);
}",1,1,pubsub.c,channelList,,false,680,700,channelList,,,44,"void channelList (client*,sds,dict*)"
237590,METHOD,pubsub.c:<global>,TYPE_DECL,"void spublishCommand(client *c) {
    int receivers = pubsubPublishMessageAndPropagateToCluster(c->argv[1],c->argv[2],1);
    if (!server.cluster_enabled)
        forceCommandPropagation(c,PROPAGATE_REPL);
    addReplyLongLong(c,receivers);
}",1,34,pubsub.c,spublishCommand,,false,703,708,spublishCommand,,,45,void spublishCommand (client*)
237624,METHOD,pubsub.c:<global>,TYPE_DECL,"void ssubscribeCommand(client *c) {
    if (c->flags & CLIENT_DENY_BLOCKING) {
        /* A client that has CLIENT_DENY_BLOCKING flag on
         * expect a reply per command and so can not execute subscribe. */
        addReplyError(c, ""SSUBSCRIBE isn't allowed for a DENY BLOCKING client"");
        return;
    }

    for (int j = 1; j < c->argc; j++) {
        /* A channel is only considered to be added, if a
         * subscriber exists for it. And if a subscriber
         * already exists the slotToChannel doesn't needs
         * to be incremented. */
        if (server.cluster_enabled &
            (dictFind(*pubSubShardType.serverPubSubChannels, c->argv[j]) == NULL)) {
            slotToChannelAdd(c->argv[j]->ptr);
        }
        pubsubSubscribeChannel(c, c->argv[j], pubSubShardType);
    }
    c->flags |= CLIENT_PUBSUB;
}",1,19,pubsub.c,ssubscribeCommand,,false,711,731,ssubscribeCommand,,,46,void ssubscribeCommand (client*)
237701,METHOD,pubsub.c:<global>,TYPE_DECL,"void sunsubscribeCommand(client *c) {
    if (c->argc == 1) {
        pubsubUnsubscribeShardAllChannels(c, 1);
    } else {
        for (int j = 1; j < c->argc; j++) {
            pubsubUnsubscribeChannel(c, c->argv[j], 1, pubSubShardType);
        }
    }
    if (clientTotalPubSubSubscriptionCount(c) == 0) c->flags &= ~CLIENT_PUBSUB;
}",1,65,pubsub.c,sunsubscribeCommand,,false,735,744,sunsubscribeCommand,,,47,void sunsubscribeCommand (client*)
237757,METHOD,pubsub.c:<global>,TYPE_DECL,"size_t pubsubMemOverhead(client *c) {
    /* PubSub patterns */
    size_t mem = dictMemUsage(c->pubsub_patterns);
    /* Global PubSub channels */
    mem += dictMemUsage(c->pubsub_channels);
    /* Sharded PubSub channels */
    mem += dictMemUsage(c->pubsubshard_channels);
    return mem;
}",1,1,pubsub.c,pubsubMemOverhead,,false,746,754,pubsubMemOverhead,,,48,size_t pubsubMemOverhead (client*)
237814,METHOD,quicklist.c:<global>,TYPE_DECL,<global>,1,20,quicklist.c,quicklist.c:<global>,,false,1,3257,<global>,,,1,
237831,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistisSetPackedThreshold(size_t sz) {
    /* Don't allow threshold to be set above or even slightly below 4GB */
    if (sz > (1ull<<32) - (1<<20)) {
        return 0;
    } else if (sz == 0) { /* 0 means restore threshold */
        sz = (1 << 30);
    }
    packed_threshold = sz;
    return 1;
}",1,1,quicklist.c,quicklistisSetPackedThreshold,,false,57,66,quicklistisSetPackedThreshold,,,5,int quicklistisSetPackedThreshold (size_t)
237866,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistBookmark *_quicklistBookmarkFindByName(quicklist *ql, const char *name);",19,80,quicklist.c,_quicklistBookmarkFindByName,,false,103,103,_quicklistBookmarkFindByName,,,6,"quicklistBookmark* _quicklistBookmarkFindByName (quicklist*,char*)"
237872,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistBookmark *_quicklistBookmarkFindByNode(quicklist *ql, quicklistNode *node);",19,83,quicklist.c,_quicklistBookmarkFindByNode,,false,104,104,_quicklistBookmarkFindByNode,,,7,"quicklistBookmark* _quicklistBookmarkFindByNode (quicklist*,quicklistNode*)"
237878,METHOD,quicklist.c:<global>,TYPE_DECL,"void _quicklistBookmarkDelete(quicklist *ql, quicklistBookmark *bm);",6,67,quicklist.c,_quicklistBookmarkDelete,,false,105,105,_quicklistBookmarkDelete,,,8,"void _quicklistBookmarkDelete (quicklist*,quicklistBookmark*)"
237884,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklist *quicklistCreate(void) {
    struct quicklist *quicklist;

    quicklist = zmalloc(sizeof(*quicklist));
    quicklist->head = quicklist->tail = NULL;
    quicklist->len = 0;
    quicklist->count = 0;
    quicklist->compress = 0;
    quicklist->fill = -2;
    quicklist->bookmark_count = 0;
    return quicklist;
}",1,1,quicklist.c,quicklistCreate,,false,128,139,quicklistCreate,,,9,quicklist quicklistCreate (void)
237933,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistSetCompressDepth(quicklist *quicklist, int compress) {
    if (compress > COMPRESS_MAX) {
        compress = COMPRESS_MAX;
    } else if (compress < 0) {
        compress = 0;
    }
    quicklist->compress = compress;
}",1,19,quicklist.c,quicklistSetCompressDepth,,false,142,149,quicklistSetCompressDepth,,,10,"void quicklistSetCompressDepth (quicklist*,int)"
237974,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistSetFill(quicklist *quicklist, int fill) {
    if (fill > FILL_MAX) {
        fill = FILL_MAX;
    } else if (fill < -5) {
        fill = -5;
    }
    quicklist->fill = fill;
}",1,15,quicklist.c,quicklistSetFill,,false,152,159,quicklistSetFill,,,11,"void quicklistSetFill (quicklist*,int)"
238021,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistSetOptions(quicklist *quicklist, int fill, int depth) {
    quicklistSetFill(quicklist, fill);
    quicklistSetCompressDepth(quicklist, depth);
}",1,1,quicklist.c,quicklistSetOptions,,false,161,164,quicklistSetOptions,,,12,"void quicklistSetOptions (quicklist*,int,int)"
238034,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklist *quicklistNew(int fill, int compress) {
    quicklist *quicklist = quicklistCreate();
    quicklistSetOptions(quicklist, fill, compress);
    return quicklist;
}",1,1,quicklist.c,quicklistNew,,false,167,171,quicklistNew,,,13,"quicklist quicklistNew (int,int)"
238050,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC quicklistNode *quicklistCreateNode(void) {
    quicklistNode *node;
    node = zmalloc(sizeof(*node));
    node->entry = NULL;
    node->count = 0;
    node->sz = 0;
    node->next = node->prev = NULL;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    node->container = QUICKLIST_NODE_CONTAINER_PACKED;
    node->recompress = 0;
    node->dont_compress = 0;
    return node;
}",1,12,quicklist.c,quicklistCreateNode,,false,173,185,quicklistCreateNode,,,14,quicklistNode quicklistCreateNode (void)
238112,METHOD,quicklist.c:<global>,TYPE_DECL,unsigned long quicklistCount(const quicklist *ql) { return ql->count; },1,71,quicklist.c,quicklistCount,,false,188,188,quicklistCount,,,15,unsigned long quicklistCount (quicklist*)
238121,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistRelease(quicklist *quicklist) {
    unsigned long len;
    quicklistNode *current, *next;

    current = quicklist->head;
    len = quicklist->len;
    while (len--) {
        next = current->next;

        zfree(current->entry);
        quicklist->count -= current->count;

        zfree(current);

        quicklist->len--;
        current = next;
    }
    quicklistBookmarksClear(quicklist);
    zfree(quicklist);
}",1,1,quicklist.c,quicklistRelease,,false,191,210,quicklistRelease,,,16,void quicklistRelease (quicklist*)
238172,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC int __quicklistCompressNode(quicklistNode *node) {
#ifdef REDIS_TEST
    node->attempted_compress = 1;
#endif
    if (node->dont_compress) return 0;

    /* validate that the node is neither
     * tail nor head (it has prev and next)*/
    assert(node->prev && node->next);

    node->recompress = 0;
    /* Don't bother compressing small values */
    if (node->sz < MIN_COMPRESS_BYTES)
        return 0;

    quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);

    /* Cancel if compression fails or doesn't compress small enough */
    if (((lzf->sz = lzf_compress(node->entry, node->sz, lzf->compressed,
                                 node->sz)) == 0) ||
        lzf->sz + MIN_COMPRESS_IMPROVE >= node->sz) {
        /* lzf_compress aborts/rejects compression if value not compressible. */
        zfree(lzf);
        return 0;
    }
    lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
    zfree(node->entry);
    node->entry = (unsigned char *)lzf;
    node->encoding = QUICKLI...",1,12,quicklist.c,__quicklistCompressNode,,false,215,245,__quicklistCompressNode,,,17,int __quicklistCompressNode (quicklistNode*)
238299,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC int __quicklistDecompressNode(quicklistNode *node) {
#ifdef REDIS_TEST
    node->attempted_compress = 0;
#endif
    node->recompress = 0;

    void *decompressed = zmalloc(node->sz);
    quicklistLZF *lzf = (quicklistLZF *)node->entry;
    if (lzf_decompress(lzf->compressed, lzf->sz, decompressed, node->sz) == 0) {
        /* Someone requested decompress, but we can't decompress.  Not good. */
        zfree(decompressed);
        return 0;
    }
    zfree(lzf);
    node->entry = decompressed;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    return 1;
}",1,12,quicklist.c,__quicklistDecompressNode,,false,257,274,__quicklistDecompressNode,,,18,int __quicklistDecompressNode (quicklistNode*)
238359,METHOD,quicklist.c:<global>,TYPE_DECL,"size_t quicklistGetLzf(const quicklistNode *node, void **data) {
    quicklistLZF *lzf = (quicklistLZF *)node->entry;
    *data = lzf->compressed;
    return lzf->sz;
}",1,1,quicklist.c,quicklistGetLzf,,false,296,300,quicklistGetLzf,,,19,"size_t quicklistGetLzf (quicklistNode*,void**)"
238383,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
                                      quicklistNode *node) {
    if (quicklist->len == 0) return;

    /* The head and tail should never be compressed (we should not attempt to recompress them) */
    assert(quicklist->head->recompress == 0 && quicklist->tail->recompress == 0);

    /* If length is less than our compress depth (from both sides),
     * we can't compress anything. */
    if (!quicklistAllowsCompression(quicklist) ||
        quicklist->len < (unsigned int)(quicklist->compress * 2))
        return;

#if 0
    /* Optimized cases for small depth counts */
    if (quicklist->compress == 1) {
        quicklistNode *h = quicklist->head, *t = quicklist->tail;
        quicklistDecompressNode(h);
        quicklistDecompressNode(t);
        if (h != node && t != node)
            quicklistCompressNode(node);
        return;
    } else if (quicklist->compress == 2) {
        quicklistNode *h = quicklist->head, *hn...",1,12,quicklist.c,__quicklistCompress,,false,308,379,__quicklistCompress,,,20,"void __quicklistCompress (quicklist*,quicklistNode*)"
238600,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void __quicklistInsertNode(quicklist *quicklist,
                                        quicklistNode *old_node,
                                        quicklistNode *new_node, int after) {
    if (after) {
        new_node->prev = old_node;
        if (old_node) {
            new_node->next = old_node->next;
            if (old_node->next)
                old_node->next->prev = new_node;
            old_node->next = new_node;
        }
        if (quicklist->tail == old_node)
            quicklist->tail = new_node;
    } else {
        new_node->next = old_node;
        if (old_node) {
            new_node->prev = old_node->prev;
            if (old_node->prev)
                old_node->prev->next = new_node;
            old_node->prev = new_node;
        }
        if (quicklist->head == old_node)
            quicklist->head = new_node;
    }
    /* If this insert creates the only element so far, initialize head/tail. */
    if (quicklist->len == 0) {
        quickli...",1,12,quicklist.c,__quicklistInsertNode,,false,400,436,__quicklistInsertNode,,,21,"void __quicklistInsertNode (quicklist*,quicklistNode*,quicklistNode*,int)"
238786,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void _quicklistInsertNodeBefore(quicklist *quicklist,
                                             quicklistNode *old_node,
                                             quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 0);
}",1,12,quicklist.c,_quicklistInsertNodeBefore,,false,439,443,_quicklistInsertNodeBefore,,,22,"void _quicklistInsertNodeBefore (quicklist*,quicklistNode*,quicklistNode*)"
238798,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void _quicklistInsertNodeAfter(quicklist *quicklist,
                                            quicklistNode *old_node,
                                            quicklistNode *new_node) {
    __quicklistInsertNode(quicklist, old_node, new_node, 1);
}",1,12,quicklist.c,_quicklistInsertNodeAfter,,false,445,449,_quicklistInsertNodeAfter,,,23,"void _quicklistInsertNodeAfter (quicklist*,quicklistNode*,quicklistNode*)"
238810,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistNodeLimit(int fill, size_t *size, unsigned int *count) {
    *size = SIZE_MAX;
    *count = UINT_MAX;

    if (fill >= 0) {
        /* Ensure that one node have at least one entry */
        *count = (fill == 0) ? 1 : fill;
    } else {
        size_t offset = (-fill) - 1;
        size_t max_level = sizeof(optimization_level) / sizeof(*optimization_level);
        if (offset >= max_level) offset = max_level - 1;
        *size = optimization_level[offset];
    }
}",1,1,quicklist.c,quicklistNodeLimit,,false,455,468,quicklistNodeLimit,,,24,"void quicklistNodeLimit (int,size_t*,unsigned int*)"
238873,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistNodeExceedsLimit(int fill, size_t new_sz, unsigned int new_count) {
    size_t sz_limit;
    unsigned int count_limit;
    quicklistNodeLimit(fill, &sz_limit, &count_limit);

    if (likely(sz_limit != SIZE_MAX)) {
        return new_sz > sz_limit;
    } else if (count_limit != UINT_MAX) {
        /* when we reach here we know that the limit is a size limit (which is
         * safe, see comments next to optimization_level and SIZE_SAFETY_LIMIT) */
        if (!sizeMeetsSafetyLimit(new_sz)) return 1;
        return new_count > count_limit;
    }

    redis_unreachable();
}",1,8,quicklist.c,quicklistNodeExceedsLimit,,false,474,489,quicklistNodeExceedsLimit,,,25,"int quicklistNodeExceedsLimit (int,size_t,unsigned int)"
238924,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
                                           const int fill, const size_t sz) {
    if (unlikely(!node))
        return 0;

    if (unlikely(QL_NODE_IS_PLAIN(node) || isLargeElement(sz)))
        return 0;

    /* Estimate how many bytes will be added to the listpack by this one entry.
     * We prefer an overestimation, which would at worse lead to a few bytes
     * below the lowest limit of 4k (see optimization_level).
     * Note: No need to check for overflow below since both `node->sz` and
     * `sz` are to be less than 1GB after the plain/large element check above. */
    size_t new_sz = node->sz + sz + SIZE_ESTIMATE_OVERHEAD;
    if (unlikely(quicklistNodeExceedsLimit(fill, new_sz, node->count + 1)))
        return 0;
    return 1;
}",1,12,quicklist.c,_quicklistNodeAllowInsert,,false,491,508,_quicklistNodeAllowInsert,,,26,"int _quicklistNodeAllowInsert (quicklistNode*,int,size_t)"
238984,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,
                                          const quicklistNode *b,
                                          const int fill) {
    if (!a || !b)
        return 0;

    if (unlikely(QL_NODE_IS_PLAIN(a) || QL_NODE_IS_PLAIN(b)))
        return 0;

    /* approximate merged listpack size (- 7 to remove one listpack
     * header/trailer, see LP_HDR_SIZE and LP_EOF) */
    unsigned int merge_sz = a->sz + b->sz - 7;
    if (unlikely(quicklistNodeExceedsLimit(fill, merge_sz, a->count + b->count)))
        return 0;
    return 1;
}",1,12,quicklist.c,_quicklistNodeAllowMerge,,false,510,525,_quicklistNodeAllowMerge,,,27,"int _quicklistNodeAllowMerge (quicklistNode*,quicklistNode*,int)"
239047,METHOD,quicklist.c:<global>,TYPE_DECL,"static quicklistNode* __quicklistCreatePlainNode(void *value, size_t sz) {
    quicklistNode *new_node = quicklistCreateNode();
    new_node->entry = zmalloc(sz);
    new_node->container = QUICKLIST_NODE_CONTAINER_PLAIN;
    memcpy(new_node->entry, value, sz);
    new_node->sz = sz;
    new_node->count++;
    return new_node;
}",1,26,quicklist.c,__quicklistCreatePlainNode,,false,532,540,__quicklistCreatePlainNode,,,28,"quicklistNode __quicklistCreatePlainNode (void*,size_t)"
239087,METHOD,quicklist.c:<global>,TYPE_DECL,"static void __quicklistInsertPlainNode(quicklist *quicklist, quicklistNode *old_node,
                                       void *value, size_t sz, int after) {
    __quicklistInsertNode(quicklist, old_node, __quicklistCreatePlainNode(value, sz), after);
    quicklist->count++;
}",1,1,quicklist.c,__quicklistInsertPlainNode,,false,542,546,__quicklistInsertPlainNode,,,29,"void __quicklistInsertPlainNode (quicklist*,quicklistNode*,void*,size_t,int)"
239107,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist->head;

    if (unlikely(isLargeElement(sz))) {
        __quicklistInsertPlainNode(quicklist, quicklist->head, value, sz, 0);
        return 1;
    }

    if (likely(
            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
        quicklist->head->entry = lpPrepend(quicklist->head->entry, value, sz);
        quicklistNodeUpdateSz(quicklist->head);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->entry = lpPrepend(lpNew(0), value, sz);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
    }
    quicklist->count++;
    quicklist->head->count++;
    return (orig_head != quicklist->head);
}",1,8,quicklist.c,quicklistPushHead,,false,552,574,quicklistPushHead,,,30,"int quicklistPushHead (quicklist*,void*,size_t)"
239234,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist->tail;
    if (unlikely(isLargeElement(sz))) {
        __quicklistInsertPlainNode(quicklist, quicklist->tail, value, sz, 1);
        return 1;
    }

    if (likely(
            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {
        quicklist->tail->entry = lpAppend(quicklist->tail->entry, value, sz);
        quicklistNodeUpdateSz(quicklist->tail);
    } else {
        quicklistNode *node = quicklistCreateNode();
        node->entry = lpAppend(lpNew(0), value, sz);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    }
    quicklist->count++;
    quicklist->tail->count++;
    return (orig_tail != quicklist->tail);
}",1,8,quicklist.c,quicklistPushTail,,false,580,601,quicklistPushTail,,,31,"int quicklistPushTail (quicklist*,void*,size_t)"
239361,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistAppendListpack(quicklist *quicklist, unsigned char *zl) {
    quicklistNode *node = quicklistCreateNode();

    node->entry = zl;
    node->count = lpLength(node->entry);
    node->sz = lpBytes(zl);

    _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    quicklist->count += node->count;
}",1,1,quicklist.c,quicklistAppendListpack,,false,606,615,quicklistAppendListpack,,,32,"void quicklistAppendListpack (quicklist*,unsigned char*)"
239403,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistAppendPlainNode(quicklist *quicklist, unsigned char *data, size_t sz) {
    quicklistNode *node = quicklistCreateNode();

    node->entry = data;
    node->count = 1;
    node->sz = sz;
    node->container = QUICKLIST_NODE_CONTAINER_PLAIN;

    _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    quicklist->count += node->count;
}",1,22,quicklist.c,quicklistAppendPlainNode,,false,621,631,quicklistAppendPlainNode,,,33,"void quicklistAppendPlainNode (quicklist*,unsigned char*,size_t)"
239449,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void __quicklistDelNode(quicklist *quicklist,
                                     quicklistNode *node) {
    /* Update the bookmark if any */
    quicklistBookmark *bm = _quicklistBookmarkFindByNode(quicklist, node);
    if (bm) {
        bm->node = node->next;
        /* if the bookmark was to the last node, delete it. */
        if (!bm->node)
            _quicklistBookmarkDelete(quicklist, bm);
    }

    if (node->next)
        node->next->prev = node->prev;
    if (node->prev)
        node->prev->next = node->next;

    if (node == quicklist->tail) {
        quicklist->tail = node->prev;
    }

    if (node == quicklist->head) {
        quicklist->head = node->next;
    }

    /* Update len first, so in __quicklistCompress we know exactly len */
    quicklist->len--;
    quicklist->count -= node->count;

    /* If we deleted a node within our compress depth, we
     * now have compressed nodes needing to be decompressed. */
    __quicklistCompress(quicklist, NULL)...",1,12,quicklist.c,__quicklistDelNode,,false,641,675,__quicklistDelNode,,,34,"void __quicklistDelNode (quicklist*,quicklistNode*)"
239556,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC int quicklistDelIndex(quicklist *quicklist, quicklistNode *node,
                                   unsigned char **p) {
    int gone = 0;

    if (unlikely(QL_NODE_IS_PLAIN(node))) {
        __quicklistDelNode(quicklist, node);
        return 1;
    }
    node->entry = lpDelete(node->entry, *p, p);
    node->count--;
    if (node->count == 0) {
        gone = 1;
        __quicklistDelNode(quicklist, node);
    } else {
        quicklistNodeUpdateSz(node);
    }
    quicklist->count--;
    /* If we deleted the node, the original node is no longer valid */
    return gone ? 1 : 0;
}",1,12,quicklist.c,quicklistDelIndex,,false,685,704,quicklistDelIndex,,,35,"int quicklistDelIndex (quicklist*,quicklistNode*,unsigned char**)"
239634,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry) {
    quicklistNode *prev = entry->node->prev;
    quicklistNode *next = entry->node->next;
    int deleted_node = quicklistDelIndex((quicklist *)entry->quicklist,
                                         entry->node, &entry->zi);

    /* after delete, the zi is now invalid for any future usage. */
    iter->zi = NULL;

    /* If current node is deleted, we must update iterator node and offset. */
    if (deleted_node) {
        if (iter->direction == AL_START_HEAD) {
            iter->current = next;
            iter->offset = 0;
        } else if (iter->direction == AL_START_TAIL) {
            iter->current = prev;
            iter->offset = -1;
        }
    }
    /* else if (!deleted_node), no changes needed.
     * we already reset iter->zi above, and the existing iter->offset
     * doesn't move again because:
     *   - [1, 2, 3] => delete offset 1 => [1, 3]: next element still offset 1
     *   - [1, 2, 3] =...",1,31,quicklist.c,quicklistDelEntry,,false,710,737,quicklistDelEntry,,,36,"void quicklistDelEntry (quicklistIter*,quicklistEntry*)"
239721,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistReplaceEntry(quicklistIter *iter, quicklistEntry *entry,
                           void *data, size_t sz)
{
    quicklist* quicklist = iter->quicklist;

    if (likely(!QL_NODE_IS_PLAIN(entry->node) && !isLargeElement(sz))) {
        entry->node->entry = lpReplace(entry->node->entry, &entry->zi, data, sz);
        quicklistNodeUpdateSz(entry->node);
        /* quicklistNext() and quicklistGetIteratorEntryAtIdx() provide an uncompressed node */
        quicklistCompress(quicklist, entry->node);
    } else if (QL_NODE_IS_PLAIN(entry->node)) {
        if (isLargeElement(sz)) {
            zfree(entry->node->entry);
            entry->node->entry = zmalloc(sz);
            entry->node->sz = sz;
            memcpy(entry->node->entry, data, sz);
            quicklistCompress(quicklist, entry->node);
        } else {
            quicklistInsertAfter(iter, entry, data, sz);
            __quicklistDelNode(quicklist, entry->node);
        }
    } else {
        entry->node->don...",1,8,quicklist.c,quicklistReplaceEntry,,false,740,778,quicklistReplaceEntry,,,37,"void quicklistReplaceEntry (quicklistIter*,quicklistEntry*,void*,size_t)"
240110,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,
                            size_t sz) {
    quicklistEntry entry;
    quicklistIter *iter = quicklistGetIteratorEntryAtIdx(quicklist, index, &entry);
    if (likely(iter)) {
        quicklistReplaceEntry(iter, &entry, data, sz);
        quicklistReleaseIterator(iter);
        return 1;
    } else {
        return 0;
    }
}",1,8,quicklist.c,quicklistReplaceAtIndex,,false,784,795,quicklistReplaceAtIndex,,,38,"int quicklistReplaceAtIndex (quicklist*,long,void*,size_t)"
240147,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC quicklistNode *_quicklistListpackMerge(quicklist *quicklist,
                                                    quicklistNode *a,
                                                    quicklistNode *b) {
    D(""Requested merge (a,b) (%u, %u)"", a->count, b->count);

    quicklistDecompressNode(a);
    quicklistDecompressNode(b);
    if ((lpMerge(&a->entry, &b->entry))) {
        /* We merged listpacks! Now remove the unused quicklistNode. */
        quicklistNode *keep = NULL, *nokeep = NULL;
        if (!a->entry) {
            nokeep = a;
            keep = b;
        } else if (!b->entry) {
            nokeep = b;
            keep = a;
        }
        keep->count = lpLength(keep->entry);
        quicklistNodeUpdateSz(keep);

        nokeep->count = 0;
        __quicklistDelNode(quicklist, nokeep);
        quicklistCompress(quicklist, keep);
        return keep;
    } else {
        /* else, the merge returned NULL and nothing changed. */
        return NULL;
    }
}",1,12,quicklist.c,_quicklistListpackMerge,,false,810,838,_quicklistListpackMerge,,,39,"quicklistNode _quicklistListpackMerge (quicklist*,quicklistNode*,quicklistNode*)"
240300,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void _quicklistMergeNodes(quicklist *quicklist,
                                       quicklistNode *center) {
    int fill = quicklist->fill;
    quicklistNode *prev, *prev_prev, *next, *next_next, *target;
    prev = prev_prev = next = next_next = target = NULL;

    if (center->prev) {
        prev = center->prev;
        if (center->prev->prev)
            prev_prev = center->prev->prev;
    }

    if (center->next) {
        next = center->next;
        if (center->next->next)
            next_next = center->next->next;
    }

    /* Try to merge prev_prev and prev */
    if (_quicklistNodeAllowMerge(prev, prev_prev, fill)) {
        _quicklistListpackMerge(quicklist, prev_prev, prev);
        prev_prev = prev = NULL; /* they could have moved, invalidate them. */
    }

    /* Try to merge next and next_next */
    if (_quicklistNodeAllowMerge(next, next_next, fill)) {
        _quicklistListpackMerge(quicklist, next, next_next);
        next = next_next = NULL; /*...",1,12,quicklist.c,_quicklistMergeNodes,,false,848,891,_quicklistMergeNodes,,,40,"void _quicklistMergeNodes (quicklist*,quicklistNode*)"
240444,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC quicklistNode *_quicklistSplitNode(quicklistNode *node, int offset,
                                                int after) {
    size_t zl_sz = node->sz;

    quicklistNode *new_node = quicklistCreateNode();
    new_node->entry = zmalloc(zl_sz);

    /* Copy original listpack so we can split it */
    memcpy(new_node->entry, node->entry, zl_sz);

    /* Need positive offset for calculating extent below. */
    if (offset < 0) offset = node->count + offset;

    /* Ranges to be trimmed: -1 here means ""continue deleting until the list ends"" */
    int orig_start = after ? offset + 1 : 0;
    int orig_extent = after ? -1 : offset;
    int new_start = after ? 0 : offset;
    int new_extent = after ? offset + 1 : -1;

    D(""After %d (%d); ranges: [%d, %d], [%d, %d]"", after, offset, orig_start,
      orig_extent, new_start, new_extent);

    node->entry = lpDeleteRange(node->entry, orig_start, orig_extent);
    node->count = lpLength(node->entry);
    quicklistNodeUpdate...",1,12,quicklist.c,_quicklistSplitNode,,false,912,944,_quicklistSplitNode,,,41,"quicklistNode _quicklistSplitNode (quicklistNode*,int,int)"
240587,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void _quicklistInsert(quicklistIter *iter, quicklistEntry *entry,
                                   void *value, const size_t sz, int after)
{
    quicklist *quicklist = iter->quicklist;
    int full = 0, at_tail = 0, at_head = 0, avail_next = 0, avail_prev = 0;
    int fill = quicklist->fill;
    quicklistNode *node = entry->node;
    quicklistNode *new_node = NULL;

    if (!node) {
        /* we have no reference node, so let's create only node in the list */
        D(""No node given!"");
        if (unlikely(isLargeElement(sz))) {
            __quicklistInsertPlainNode(quicklist, quicklist->tail, value, sz, after);
            return;
        }
        new_node = quicklistCreateNode();
        new_node->entry = lpPrepend(lpNew(0), value, sz);
        __quicklistInsertNode(quicklist, NULL, new_node, after);
        new_node->count++;
        quicklist->count++;
        return;
    }

    /* Populate accounting flags for easier boolean checks later */
    if (!_quickl...",1,12,quicklist.c,_quicklistInsert,,false,950,1081,_quicklistInsert,,,42,"void _quicklistInsert (quicklistIter*,quicklistEntry*,void*,size_t,int)"
241419,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistInsertBefore(quicklistIter *iter, quicklistEntry *entry,
                           void *value, const size_t sz)
{
    _quicklistInsert(iter, entry, value, sz, 0);
}",1,1,quicklist.c,quicklistInsertBefore,,false,1083,1087,quicklistInsertBefore,,,43,"void quicklistInsertBefore (quicklistIter*,quicklistEntry*,void*,size_t)"
241433,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistInsertAfter(quicklistIter *iter, quicklistEntry *entry,
                          void *value, const size_t sz)
{
    _quicklistInsert(iter, entry, value, sz, 1);
}",1,1,quicklist.c,quicklistInsertAfter,,false,1089,1093,quicklistInsertAfter,,,44,"void quicklistInsertAfter (quicklistIter*,quicklistEntry*,void*,size_t)"
241447,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistDelRange(quicklist *quicklist, const long start,
                      const long count) {
    if (count <= 0)
        return 0;

    unsigned long extent = count; /* range is inclusive of start position */

    if (start >= 0 && extent > (quicklist->count - start)) {
        /* if requesting delete more elements than exist, limit to list size. */
        extent = quicklist->count - start;
    } else if (start < 0 && extent > (unsigned long)(-start)) {
        /* else, if at negative offset, limit max size to rest of list. */
        extent = -start; /* c.f. LREM -29 29; just delete until end. */
    }

    quicklistIter *iter = quicklistGetIteratorAtIdx(quicklist, AL_START_TAIL, start);
    if (!iter)
        return 0;

    D(""Quicklist delete request for start %ld, count %ld, extent: %ld"", start,
      count, extent);
    quicklistNode *node = iter->current;
    long offset = iter->offset;
    quicklistReleaseIterator(iter);

    /* iterate over next nodes until every...",1,63,quicklist.c,quicklistDelRange,,false,1101,1184,quicklistDelRange,,,45,"int quicklistDelRange (quicklist*,long,long)"
241743,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistCompare(quicklistEntry* entry, unsigned char *p2, const size_t p2_len) {
    if (unlikely(QL_NODE_IS_PLAIN(entry->node))) {
        return ((entry->sz == p2_len) && (memcmp(entry->value, p2, p2_len) == 0));
    }
    return lpCompare(entry->zi, p2, p2_len);
}",1,8,quicklist.c,quicklistCompare,,false,1187,1192,quicklistCompare,,,46,"int quicklistCompare (quicklistEntry*,unsigned char*,size_t)"
241783,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistIter *quicklistGetIterator(quicklist *quicklist, int direction) {
    quicklistIter *iter;

    iter = zmalloc(sizeof(*iter));

    if (direction == AL_START_HEAD) {
        iter->current = quicklist->head;
        iter->offset = 0;
    } else if (direction == AL_START_TAIL) {
        iter->current = quicklist->tail;
        iter->offset = -1;
    }

    iter->direction = direction;
    iter->quicklist = quicklist;

    iter->zi = NULL;

    return iter;
}",1,21,quicklist.c,quicklistGetIterator,,false,1196,1215,quicklistGetIterator,,,47,"quicklistIter quicklistGetIterator (quicklist*,int)"
241854,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistIter *quicklistGetIteratorAtIdx(quicklist *quicklist,
                                         const int direction,
                                         const long long idx)
{
    quicklistNode *n;
    unsigned long long accum = 0;
    unsigned long long index;
    int forward = idx < 0 ? 0 : 1; /* < 0 -> reverse, 0+ -> forward */

    index = forward ? idx : (-idx) - 1;
    if (index >= quicklist->count)
        return NULL;

    /* Seek in the other direction if that way is shorter. */
    int seek_forward = forward;
    unsigned long long seek_index = index;
    if (index > (quicklist->count - 1) / 2) {
        seek_forward = !forward;
        seek_index = quicklist->count - 1 - index;
    }

    n = seek_forward ? quicklist->head : quicklist->tail;
    while (likely(n)) {
        if ((accum + n->count) > seek_index) {
            break;
        } else {
            D(""Skipping over (%p) %u at accum %lld"", (void *)n, n->count,
              accum);
            accum ...",1,11,quicklist.c,quicklistGetIteratorAtIdx,,false,1219,1273,quicklistGetIteratorAtIdx,,,48,"quicklistIter quicklistGetIteratorAtIdx (quicklist*,int,long long)"
242026,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistReleaseIterator(quicklistIter *iter) {
    if (!iter) return;
    if (iter->current)
        quicklistCompress(iter->quicklist, iter->current);

    zfree(iter);
}",1,8,quicklist.c,quicklistReleaseIterator,,false,1277,1283,quicklistReleaseIterator,,,49,void quicklistReleaseIterator (quicklistIter*)
242090,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistNext(quicklistIter *iter, quicklistEntry *entry) {
    initEntry(entry);

    if (!iter) {
        D(""Returning because no iter!"");
        return 0;
    }

    entry->quicklist = iter->quicklist;
    entry->node = iter->current;

    if (!iter->current) {
        D(""Returning because current node is NULL"");
        return 0;
    }

    unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;
    int offset_update = 0;

    int plain = QL_NODE_IS_PLAIN(iter->current);
    if (!iter->zi) {
        /* If !zi, use current index. */
        quicklistDecompressNodeForUse(iter->current);
        if (unlikely(plain))
            iter->zi = iter->current->entry;
        else
            iter->zi = lpSeek(iter->current->entry, iter->offset);
    } else if (unlikely(plain)) {
        iter->zi = NULL;
    } else {
        /* else, use existing iterator offset and get prev/next as necessary. */
        if (iter->direction == AL_START_HEAD) {
            nextFn = lpNext;
 ...",1,4,quicklist.c,quicklistNext,,false,1306,1380,quicklistNext,,,50,"int quicklistNext (quicklistIter*,quicklistEntry*)"
242163,METHOD,quicklist.c:<global>,TYPE_DECL,"unsigned char *(*nextFn)(unsigned char *, unsigned char *) = NULL;",19,69,quicklist.c,quicklistNext.nextFn,,false,1322,1322,nextFn,,,6,"unsigned char* quicklistNext.nextFn (unsigned char*,unsigned char*)"
242501,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistSetDirection(quicklistIter *iter, int direction) {
    iter->direction = direction;
}",1,1,quicklist.c,quicklistSetDirection,,false,1383,1385,quicklistSetDirection,,,51,"void quicklistSetDirection (quicklistIter*,int)"
242512,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklist *quicklistDup(quicklist *orig) {
    quicklist *copy;

    copy = quicklistNew(orig->fill, orig->compress);

    for (quicklistNode *current = orig->head; current;
         current = current->next) {
        quicklistNode *node = quicklistCreateNode();

        if (current->encoding == QUICKLIST_NODE_ENCODING_LZF) {
            quicklistLZF *lzf = (quicklistLZF *)current->entry;
            size_t lzf_sz = sizeof(*lzf) + lzf->sz;
            node->entry = zmalloc(lzf_sz);
            memcpy(node->entry, current->entry, lzf_sz);
        } else if (current->encoding == QUICKLIST_NODE_ENCODING_RAW) {
            node->entry = zmalloc(current->sz);
            memcpy(node->entry, current->entry, current->sz);
        }

        node->count = current->count;
        copy->count += node->count;
        node->sz = current->sz;
        node->encoding = current->encoding;
        node->container = current->container;

        _quicklistInsertNodeAfter(copy, copy->tail, node);
    }...",1,33,quicklist.c,quicklistDup,,false,1393,1423,quicklistDup,,,52,quicklist quicklistDup (quicklist*)
242659,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistIter *quicklistGetIteratorEntryAtIdx(quicklist *quicklist, const long long idx,
                                              quicklistEntry *entry)
{
    quicklistIter *iter = quicklistGetIteratorAtIdx(quicklist, AL_START_TAIL, idx);
    if (!iter) return NULL;
    assert(quicklistNext(iter, entry));
    return iter;
}",1,63,quicklist.c,quicklistGetIteratorEntryAtIdx,,false,1433,1440,quicklistGetIteratorEntryAtIdx,,,53,"quicklistIter quicklistGetIteratorEntryAtIdx (quicklist*,long long,quicklistEntry*)"
242699,METHOD,quicklist.c:<global>,TYPE_DECL,"static void quicklistRotatePlain(quicklist *quicklist) {
    quicklistNode *new_head = quicklist->tail;
    quicklistNode *new_tail = quicklist->tail->prev;
    quicklist->head->prev = new_head;
    new_tail->next = NULL;
    new_head->next = quicklist->head;
    new_head->prev = NULL;
    quicklist->head = new_head;
    quicklist->tail = new_tail;
}",1,1,quicklist.c,quicklistRotatePlain,,false,1442,1451,quicklistRotatePlain,,,54,void quicklistRotatePlain (quicklist*)
242752,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistRotate(quicklist *quicklist) {
    if (quicklist->count <= 1)
        return;

    if (unlikely(QL_NODE_IS_PLAIN(quicklist->tail))) {
        quicklistRotatePlain(quicklist);
        return;
    }

    /* First, get the tail entry */
    unsigned char *p = lpSeek(quicklist->tail->entry, -1);
    unsigned char *value, *tmp;
    long long longval;
    unsigned int sz;
    char longstr[32] = {0};
    tmp = lpGetValue(p, &sz, &longval);

    /* If value found is NULL, then lpGet populated longval instead */
    if (!tmp) {
        /* Write the longval as a string so we can re-add it */
        sz = ll2string(longstr, sizeof(longstr), longval);
        value = (unsigned char *)longstr;
    } else if (quicklist->len == 1) {
        /* Copy buffer since there could be a memory overlap when move
         * entity from tail to head in the same listpack. */
        value = zmalloc(sz);
        memcpy(value, tmp, sz);
    } else {
        value = tmp;
    }

    /* Add tail entry...",1,8,quicklist.c,quicklistRotate,,false,1454,1499,quicklistRotate,,,55,void quicklistRotate (quicklist*)
242886,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
                       size_t *sz, long long *sval,
                       void *(*saver)(unsigned char *data, size_t sz)) {
    unsigned char *p;
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    int pos = (where == QUICKLIST_HEAD) ? 0 : -1;

    if (quicklist->count == 0)
        return 0;

    if (data)
        *data = NULL;
    if (sz)
        *sz = 0;
    if (sval)
        *sval = -123456789;

    quicklistNode *node;
    if (where == QUICKLIST_HEAD && quicklist->head) {
        node = quicklist->head;
    } else if (where == QUICKLIST_TAIL && quicklist->tail) {
        node = quicklist->tail;
    } else {
        return 0;
    }

    /* The head and tail should never be compressed */
    assert(node->encoding != QUICKLIST_NODE_ENCODING_LZF);

    if (unlikely(QL_NODE_IS_PLAIN(node))) {
        if (data)
            *data = saver(node->entry, node->sz);
        if (sz)
         ...",1,24,quicklist.c,quicklistPopCustom,,false,1510,1565,quicklistPopCustom,,,56,"int quicklistPopCustom (quicklist*,int,unsigned char**,size_t*,long long*,void*)"
243095,METHOD,quicklist.c:<global>,TYPE_DECL,"REDIS_STATIC void *_quicklistSaver(unsigned char *data, size_t sz) {
    unsigned char *vstr;
    if (data) {
        vstr = zmalloc(sz);
        memcpy(vstr, data, sz);
        return vstr;
    }
    return NULL;
}",1,12,quicklist.c,_quicklistSaver,,false,1568,1576,_quicklistSaver,,,57,"void* _quicklistSaver (unsigned char*,size_t)"
243117,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
                 size_t *sz, long long *slong) {
    unsigned char *vstr = NULL;
    size_t vlen = 0;
    long long vlong = 0;
    if (quicklist->count == 0)
        return 0;
    int ret = quicklistPopCustom(quicklist, where, &vstr, &vlen, &vlong,
                                 _quicklistSaver);
    if (data)
        *data = vstr;
    if (slong)
        *slong = vlong;
    if (sz)
        *sz = vlen;
    return ret;
}",1,1,quicklist.c,quicklistPop,,false,1581,1597,quicklistPop,,,58,"int quicklistPop (quicklist*,int,unsigned char**,size_t*,long long*)"
243183,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                   int where) {
    /* The head and tail should never be compressed (we don't attempt to decompress them) */
    if (quicklist->head)
        assert(quicklist->head->encoding != QUICKLIST_NODE_ENCODING_LZF);
    if (quicklist->tail)
        assert(quicklist->tail->encoding != QUICKLIST_NODE_ENCODING_LZF);

    if (where == QUICKLIST_HEAD) {
        quicklistPushHead(quicklist, value, sz);
    } else if (where == QUICKLIST_TAIL) {
        quicklistPushTail(quicklist, value, sz);
    }
}",1,8,quicklist.c,quicklistPush,,false,1600,1613,quicklistPush,,,59,"void quicklistPush (quicklist*,void*,size_t,int)"
243266,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistRepr(unsigned char *ql, int full) {
    int i = 0;
    quicklist *quicklist  = (struct quicklist*) ql;
    printf(""{count : %ld}\n"", quicklist->count);
    printf(""{len : %ld}\n"", quicklist->len);
    printf(""{fill : %d}\n"", quicklist->fill);
    printf(""{compress : %d}\n"", quicklist->compress);
    printf(""{bookmark_count : %d}\n"", quicklist->bookmark_count);
    quicklistNode* node = quicklist->head;

    while(node != NULL) {
        printf(""{quicklist node(%d)\n"", i++);
        printf(""{container : %s, encoding: %s, size: %zu, count: %d, recompress: %d, attempted_compress: %d}\n"",
               QL_NODE_IS_PLAIN(node) ? ""PLAIN"": ""PACKED"",
               (node->encoding == QUICKLIST_NODE_ENCODING_RAW) ? ""RAW"": ""LZF"",
               node->sz,
               node->count,
               node->recompress,
               node->attempted_compress);

        if (full) {
            quicklistDecompressNode(node);
            if (node->container == QUICKLIST_NODE_CONTAINER_P...",1,15,quicklist.c,quicklistRepr,,false,1616,1651,quicklistRepr,,,60,"void quicklistRepr (unsigned char*,int)"
243443,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistBookmarkCreate(quicklist **ql_ref, const char *name, quicklistNode *node) {
    quicklist *ql = *ql_ref;
    if (ql->bookmark_count >= QL_MAX_BM)
        return 0;
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (bm) {
        bm->node = node;
        return 1;
    }
    ql = zrealloc(ql, sizeof(quicklist) + (ql->bookmark_count+1) * sizeof(quicklistBookmark));
    *ql_ref = ql;
    ql->bookmarks[ql->bookmark_count].node = node;
    ql->bookmarks[ql->bookmark_count].name = zstrdup(name);
    ql->bookmark_count++;
    return 1;
}",1,30,quicklist.c,quicklistBookmarkCreate,,false,1661,1676,quicklistBookmarkCreate,,,61,"int quicklistBookmarkCreate (quicklist**,char*,quicklistNode*)"
243534,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistNode *quicklistBookmarkFind(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm) return NULL;
    return bm->node;
}",1,1,quicklist.c,quicklistBookmarkFind,,false,1681,1685,quicklistBookmarkFind,,,62,"quicklistNode quicklistBookmarkFind (quicklist*,char*)"
243556,METHOD,quicklist.c:<global>,TYPE_DECL,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}",1,1,quicklist.c,quicklistBookmarkDelete,,false,1690,1696,quicklistBookmarkDelete,,,63,"int quicklistBookmarkDelete (quicklist*,char*)"
243579,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistBookmark *_quicklistBookmarkFindByName(quicklist *ql, const char *name) {
    unsigned i;
    for (i=0; i<ql->bookmark_count; i++) {
        if (!strcmp(ql->bookmarks[i].name, name)) {
            return &ql->bookmarks[i];
        }
    }
    return NULL;
}",1,1,quicklist.c,_quicklistBookmarkFindByName,,false,1698,1706,_quicklistBookmarkFindByName,,,64,"quicklistBookmark _quicklistBookmarkFindByName (quicklist*,char*)"
243620,METHOD,quicklist.c:<global>,TYPE_DECL,"quicklistBookmark *_quicklistBookmarkFindByNode(quicklist *ql, quicklistNode *node) {
    unsigned i;
    for (i=0; i<ql->bookmark_count; i++) {
        if (ql->bookmarks[i].node == node) {
            return &ql->bookmarks[i];
        }
    }
    return NULL;
}",1,1,quicklist.c,_quicklistBookmarkFindByNode,,false,1708,1716,_quicklistBookmarkFindByNode,,,65,"quicklistBookmark _quicklistBookmarkFindByNode (quicklist*,quicklistNode*)"
243660,METHOD,quicklist.c:<global>,TYPE_DECL,"void _quicklistBookmarkDelete(quicklist *ql, quicklistBookmark *bm) {
    int index = bm - ql->bookmarks;
    zfree(bm->name);
    ql->bookmark_count--;
    memmove(bm, bm+1, (ql->bookmark_count - index)* sizeof(*bm));
    /* NOTE: We do not shrink (realloc) the quicklist yet (to avoid resonance,
     * it may be re-used later (a call to realloc may NOP). */
}",1,1,quicklist.c,_quicklistBookmarkDelete,,false,1718,1725,_quicklistBookmarkDelete,,,66,"void _quicklistBookmarkDelete (quicklist*,quicklistBookmark*)"
243696,METHOD,quicklist.c:<global>,TYPE_DECL,"void quicklistBookmarksClear(quicklist *ql) {
    while (ql->bookmark_count)
        zfree(ql->bookmarks[--ql->bookmark_count].name);
    /* NOTE: We do not shrink (realloc) the quick list. main use case for this
     * function is just before releasing the allocation. */
}",1,1,quicklist.c,quicklistBookmarksClear,,false,1727,1732,quicklistBookmarksClear,,,67,void quicklistBookmarksClear (quicklist*)
243721,METHOD,quicklist.h:<global>,TYPE_DECL,<global>,1,28,quicklist.h,quicklist.h:<global>,,false,1,214,<global>,,,1,
243741,METHOD,<empty>,<empty>,<empty>,1,,quicklist.h,quicklistLZF:<clinit>,,false,65,,<clinit>,,,3,
243760,METHOD,<empty>,<empty>,<empty>,1,,quicklist.h,quicklist:<clinit>,,false,106,,<clinit>,,,9,
243782,METHOD,quicklist.h:<global>,TYPE_DECL,quicklist *quicklistCreate(void);,11,32,quicklist.h,quicklistCreate,,false,155,155,quicklistCreate,,,13,quicklist* quicklistCreate (void)
243787,METHOD,quicklist.h:<global>,TYPE_DECL,"quicklist *quicklistNew(int fill, int compress);",11,47,quicklist.h,quicklistNew,,false,156,156,quicklistNew,,,14,"quicklist* quicklistNew (int,int)"
243793,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistSetCompressDepth(quicklist *quicklist, int depth);",6,63,quicklist.h,quicklistSetCompressDepth,,false,157,157,quicklistSetCompressDepth,,,15,"void quicklistSetCompressDepth (quicklist*,int)"
243799,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistSetFill(quicklist *quicklist, int fill);",6,53,quicklist.h,quicklistSetFill,,false,158,158,quicklistSetFill,,,16,"void quicklistSetFill (quicklist*,int)"
243805,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistSetOptions(quicklist *quicklist, int fill, int depth);",6,67,quicklist.h,quicklistSetOptions,,false,159,159,quicklistSetOptions,,,17,"void quicklistSetOptions (quicklist*,int,int)"
243812,METHOD,quicklist.h:<global>,TYPE_DECL,void quicklistRelease(quicklist *quicklist);,6,43,quicklist.h,quicklistRelease,,false,160,160,quicklistRelease,,,18,void quicklistRelease (quicklist*)
243817,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistPushHead(quicklist *quicklist, void *value, const size_t sz);",5,73,quicklist.h,quicklistPushHead,,false,161,161,quicklistPushHead,,,19,"int quicklistPushHead (quicklist*,void*,size_t)"
243824,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistPushTail(quicklist *quicklist, void *value, const size_t sz);",5,73,quicklist.h,quicklistPushTail,,false,162,162,quicklistPushTail,,,20,"int quicklistPushTail (quicklist*,void*,size_t)"
243831,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistPush(quicklist *quicklist, void *value, const size_t sz,
                   int where);",6,29,quicklist.h,quicklistPush,,false,163,164,quicklistPush,,,21,"void quicklistPush (quicklist*,void*,size_t,int)"
243839,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistAppendListpack(quicklist *quicklist, unsigned char *zl);",6,69,quicklist.h,quicklistAppendListpack,,false,165,165,quicklistAppendListpack,,,22,"void quicklistAppendListpack (quicklist*,unsigned char*)"
243845,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistAppendPlainNode(quicklist *quicklist, unsigned char *data, size_t sz);",6,83,quicklist.h,quicklistAppendPlainNode,,false,166,166,quicklistAppendPlainNode,,,23,"void quicklistAppendPlainNode (quicklist*,unsigned char*,size_t)"
243852,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistInsertAfter(quicklistIter *iter, quicklistEntry *entry,
                          void *value, const size_t sz);",6,55,quicklist.h,quicklistInsertAfter,,false,167,168,quicklistInsertAfter,,,24,"void quicklistInsertAfter (quicklistIter*,quicklistEntry*,void*,size_t)"
243860,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistInsertBefore(quicklistIter *iter, quicklistEntry *entry,
                           void *value, const size_t sz);",6,56,quicklist.h,quicklistInsertBefore,,false,169,170,quicklistInsertBefore,,,25,"void quicklistInsertBefore (quicklistIter*,quicklistEntry*,void*,size_t)"
243868,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistDelEntry(quicklistIter *iter, quicklistEntry *entry);",6,66,quicklist.h,quicklistDelEntry,,false,171,171,quicklistDelEntry,,,26,"void quicklistDelEntry (quicklistIter*,quicklistEntry*)"
243874,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistReplaceEntry(quicklistIter *iter, quicklistEntry *entry,
                           void *data, size_t sz);",6,49,quicklist.h,quicklistReplaceEntry,,false,172,173,quicklistReplaceEntry,,,27,"void quicklistReplaceEntry (quicklistIter*,quicklistEntry*,void*,size_t)"
243882,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistReplaceAtIndex(quicklist *quicklist, long index, void *data,
                            const size_t sz);",5,44,quicklist.h,quicklistReplaceAtIndex,,false,174,175,quicklistReplaceAtIndex,,,28,"int quicklistReplaceAtIndex (quicklist*,long,void*,size_t)"
243890,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistDelRange(quicklist *quicklist, const long start, const long stop);",5,78,quicklist.h,quicklistDelRange,,false,176,176,quicklistDelRange,,,29,"int quicklistDelRange (quicklist*,long,long)"
243897,METHOD,quicklist.h:<global>,TYPE_DECL,"quicklistIter *quicklistGetIterator(quicklist *quicklist, int direction);",15,72,quicklist.h,quicklistGetIterator,,false,177,177,quicklistGetIterator,,,30,"quicklistIter* quicklistGetIterator (quicklist*,int)"
243903,METHOD,quicklist.h:<global>,TYPE_DECL,"quicklistIter *quicklistGetIteratorAtIdx(quicklist *quicklist,
                                         int direction, const long long idx);",15,76,quicklist.h,quicklistGetIteratorAtIdx,,false,178,179,quicklistGetIteratorAtIdx,,,31,"quicklistIter* quicklistGetIteratorAtIdx (quicklist*,int,long long)"
243910,METHOD,quicklist.h:<global>,TYPE_DECL,"quicklistIter *quicklistGetIteratorEntryAtIdx(quicklist *quicklist, const long long index,
                                              quicklistEntry *entry);",15,68,quicklist.h,quicklistGetIteratorEntryAtIdx,,false,180,181,quicklistGetIteratorEntryAtIdx,,,32,"quicklistIter* quicklistGetIteratorEntryAtIdx (quicklist*,long long,quicklistEntry*)"
243917,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistNext(quicklistIter *iter, quicklistEntry *entry);",5,61,quicklist.h,quicklistNext,,false,182,182,quicklistNext,,,33,"int quicklistNext (quicklistIter*,quicklistEntry*)"
243923,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistSetDirection(quicklistIter *iter, int direction);",6,62,quicklist.h,quicklistSetDirection,,false,183,183,quicklistSetDirection,,,34,"void quicklistSetDirection (quicklistIter*,int)"
243929,METHOD,quicklist.h:<global>,TYPE_DECL,void quicklistReleaseIterator(quicklistIter *iter);,6,50,quicklist.h,quicklistReleaseIterator,,false,184,184,quicklistReleaseIterator,,,35,void quicklistReleaseIterator (quicklistIter*)
243934,METHOD,quicklist.h:<global>,TYPE_DECL,quicklist *quicklistDup(quicklist *orig);,11,40,quicklist.h,quicklistDup,,false,185,185,quicklistDup,,,36,quicklist* quicklistDup (quicklist*)
243939,METHOD,quicklist.h:<global>,TYPE_DECL,void quicklistRotate(quicklist *quicklist);,6,42,quicklist.h,quicklistRotate,,false,186,186,quicklistRotate,,,37,void quicklistRotate (quicklist*)
243944,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistPopCustom(quicklist *quicklist, int where, unsigned char **data,
                       size_t *sz, long long *sval,
                       void *(*saver)(unsigned char *data, size_t sz));",5,70,quicklist.h,quicklistPopCustom,,false,187,189,quicklistPopCustom,,,38,"int quicklistPopCustom (quicklist*,int,unsigned char**,size_t*,long long*,void*)"
243954,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistPop(quicklist *quicklist, int where, unsigned char **data,
                 size_t *sz, long long *slong);",5,46,quicklist.h,quicklistPop,,false,190,191,quicklistPop,,,39,"int quicklistPop (quicklist*,int,unsigned char**,size_t*,long long*)"
243963,METHOD,quicklist.h:<global>,TYPE_DECL,unsigned long quicklistCount(const quicklist *ql);,15,49,quicklist.h,quicklistCount,,false,192,192,quicklistCount,,,40,long unsigned quicklistCount (quicklist*)
243968,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistCompare(quicklistEntry *entry, unsigned char *p2, const size_t p2_len);",5,83,quicklist.h,quicklistCompare,,false,193,193,quicklistCompare,,,41,"int quicklistCompare (quicklistEntry*,unsigned char*,size_t)"
243975,METHOD,quicklist.h:<global>,TYPE_DECL,"size_t quicklistGetLzf(const quicklistNode *node, void **data);",8,62,quicklist.h,quicklistGetLzf,,false,194,194,quicklistGetLzf,,,42,"size_t quicklistGetLzf (quicklistNode*,void**)"
243981,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistNodeLimit(int fill, size_t *size, unsigned int *count);",6,68,quicklist.h,quicklistNodeLimit,,false,195,195,quicklistNodeLimit,,,43,"void quicklistNodeLimit (int,size_t*,unsigned int*)"
243988,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistNodeExceedsLimit(int fill, size_t new_sz, unsigned int new_count);",5,78,quicklist.h,quicklistNodeExceedsLimit,,false,196,196,quicklistNodeExceedsLimit,,,44,"int quicklistNodeExceedsLimit (int,size_t,unsigned int)"
243995,METHOD,quicklist.h:<global>,TYPE_DECL,"void quicklistRepr(unsigned char *ql, int full);",6,47,quicklist.h,quicklistRepr,,false,197,197,quicklistRepr,,,45,"void quicklistRepr (unsigned char*,int)"
244001,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistBookmarkCreate(quicklist **ql_ref, const char *name, quicklistNode *node);",5,86,quicklist.h,quicklistBookmarkCreate,,false,200,200,quicklistBookmarkCreate,,,46,"int quicklistBookmarkCreate (quicklist**,char*,quicklistNode*)"
244008,METHOD,quicklist.h:<global>,TYPE_DECL,"int quicklistBookmarkDelete(quicklist *ql, const char *name);",5,60,quicklist.h,quicklistBookmarkDelete,,false,201,201,quicklistBookmarkDelete,,,47,"int quicklistBookmarkDelete (quicklist*,char*)"
244014,METHOD,quicklist.h:<global>,TYPE_DECL,"quicklistNode *quicklistBookmarkFind(quicklist *ql, const char *name);",15,69,quicklist.h,quicklistBookmarkFind,,false,202,202,quicklistBookmarkFind,,,48,"quicklistNode* quicklistBookmarkFind (quicklist*,char*)"
244020,METHOD,quicklist.h:<global>,TYPE_DECL,void quicklistBookmarksClear(quicklist *ql);,6,43,quicklist.h,quicklistBookmarksClear,,false,203,203,quicklistBookmarksClear,,,49,void quicklistBookmarksClear (quicklist*)
244025,METHOD,quicklist.h:<global>,TYPE_DECL,int quicklistisSetPackedThreshold(size_t sz);,5,44,quicklist.h,quicklistisSetPackedThreshold,,false,204,204,quicklistisSetPackedThreshold,,,50,int quicklistisSetPackedThreshold (size_t)
244035,METHOD,rand.c:<global>,TYPE_DECL,<global>,1,25,rand.c,rand.c:<global>,,false,1,93,<global>,,,1,
244069,METHOD,rand.c:<global>,TYPE_DECL,static void next(void);,13,22,rand.c,next,,false,69,69,next,,,7,void next (void)
244074,METHOD,rand.c:<global>,TYPE_DECL,"int32_t redisLrand48(void) {
    next();
    return (((int32_t)x[2] << (N - 1)) + (x[1] >> 1));
}",1,31,rand.c,redisLrand48,,false,71,74,redisLrand48,,,8,int32_t redisLrand48 (void)
244098,METHOD,rand.c:<global>,TYPE_DECL,"void redisSrand48(int32_t seedval) {
    SEED(X0, LOW(seedval), HIGH(seedval));
}",1,4,rand.c,redisSrand48,,false,76,78,redisSrand48,,,9,void redisSrand48 (int32_t)
244178,METHOD,rand.c:<global>,TYPE_DECL,"static void next(void) {
    uint32_t p[2], q[2], r[2], carry0, carry1;

    MUL(a[0], x[0], p);
    ADDEQU(p[0], c, carry0);
    ADDEQU(p[1], carry0, carry1);
    MUL(a[0], x[1], q);
    ADDEQU(p[1], q[0], carry0);
    MUL(a[1], x[0], r);
    x[2] = LOW(carry0 + carry1 + CARRY(p[1], r[0]) + q[1] + r[1] +
            a[0] * x[2] + a[1] * x[1] + a[2] * x[0]);
    x[1] = LOW(p[1] + r[0]);
    x[0] = LOW(p[0]);
}",1,4,rand.c,next,,false,80,93,next,,,10,void next (void)
244714,METHOD,rand.h:<global>,TYPE_DECL,<global>,1,6,rand.h,rand.h:<global>,,false,1,38,<global>,,,1,
244716,METHOD,rand.h:<global>,TYPE_DECL,int32_t redisLrand48(void);,9,26,rand.h,redisLrand48,,false,33,33,redisLrand48,,,1,int32_t redisLrand48 (void)
244721,METHOD,rand.h:<global>,TYPE_DECL,void redisSrand48(int32_t seedval);,6,34,rand.h,redisSrand48,,false,34,34,redisSrand48,,,2,void redisSrand48 (int32_t)
244745,METHOD,rax.c:<global>,TYPE_DECL,<global>,1,18,rax.c,rax.c:<global>,,false,1,1927,<global>,,,1,
244753,METHOD,rax.c:<global>,TYPE_DECL,"void raxDebugShowNode(const char *msg, raxNode *n);",6,50,rax.c,raxDebugShowNode,,false,54,54,raxDebugShowNode,,,3,"void raxDebugShowNode (char*,raxNode*)"
244763,METHOD,rax.c:<global>,TYPE_DECL,"void raxSetDebugMsg(int onoff) {
    raxDebugMsg = onoff;
}",1,1,rax.c,raxSetDebugMsg,,false,81,83,raxSetDebugMsg,,,6,void raxSetDebugMsg (int)
244771,METHOD,rax.c:<global>,TYPE_DECL,"static inline void raxStackInit(raxStack *ts) {
    ts->stack = ts->static_items;
    ts->items = 0;
    ts->maxitems = RAX_STACK_STATIC_ITEMS;
    ts->oom = 0;
}",1,19,rax.c,raxStackInit,,false,94,99,raxStackInit,,,7,void raxStackInit (raxStack*)
244800,METHOD,rax.c:<global>,TYPE_DECL,"static inline int raxStackPush(raxStack *ts, void *ptr) {
    if (ts->items == ts->maxitems) {
        if (ts->stack == ts->static_items) {
            ts->stack = rax_malloc(sizeof(void*)*ts->maxitems*2);
            if (ts->stack == NULL) {
                ts->stack = ts->static_items;
                ts->oom = 1;
                errno = ENOMEM;
                return 0;
            }
            memcpy(ts->stack,ts->static_items,sizeof(void*)*ts->maxitems);
        } else {
            void **newalloc = rax_realloc(ts->stack,sizeof(void*)*ts->maxitems*2);
            if (newalloc == NULL) {
                ts->oom = 1;
                errno = ENOMEM;
                return 0;
            }
            ts->stack = newalloc;
        }
        ts->maxitems *= 2;
    }
    ts->stack[ts->items] = ptr;
    ts->items++;
    return 1;
}",1,24,rax.c,raxStackPush,,false,102,127,raxStackPush,,,8,"int raxStackPush (raxStack*,void*)"
244935,METHOD,rax.c:<global>,TYPE_DECL,"static inline void *raxStackPop(raxStack *ts) {
    if (ts->items == 0) return NULL;
    ts->items--;
    return ts->stack[ts->items];
}",1,1,rax.c,raxStackPop,,false,131,135,raxStackPop,,,9,void* raxStackPop (raxStack*)
244961,METHOD,rax.c:<global>,TYPE_DECL,"static inline void *raxStackPeek(raxStack *ts) {
    if (ts->items == 0) return NULL;
    return ts->stack[ts->items-1];
}",1,1,rax.c,raxStackPeek,,false,139,142,raxStackPeek,,,10,void* raxStackPeek (raxStack*)
244985,METHOD,rax.c:<global>,TYPE_DECL,"static inline void raxStackFree(raxStack *ts) {
    if (ts->stack != ts->static_items) rax_free(ts->stack);
}",1,39,rax.c,raxStackFree,,false,145,147,raxStackFree,,,11,void raxStackFree (raxStack*)
245005,METHOD,rax.c:<global>,TYPE_DECL,"raxNode *raxNewNode(size_t children, int datafield) {
    size_t nodesize = sizeof(raxNode)+children+raxPadding(children)+
                      sizeof(raxNode*)*children;
    if (datafield) nodesize += sizeof(void*);
    raxNode *node = rax_malloc(nodesize);
    if (node == NULL) return NULL;
    node->iskey = 0;
    node->isnull = 0;
    node->iscompr = 0;
    node->size = children;
    return node;
}",1,47,rax.c,raxNewNode,,false,188,199,raxNewNode,,,12,"raxNode raxNewNode (size_t,int)"
245084,METHOD,rax.c:<global>,TYPE_DECL,"rax *raxNew(void) {
    rax *rax = rax_malloc(sizeof(*rax));
    if (rax == NULL) return NULL;
    rax->numele = 0;
    rax->numnodes = 1;
    rax->head = raxNewNode(0,0);
    if (rax->head == NULL) {
        rax_free(rax);
        return NULL;
    } else {
        return rax;
    }
}",1,15,rax.c,raxNew,,false,203,215,raxNew,,,13,rax raxNew (void)
245139,METHOD,rax.c:<global>,TYPE_DECL,"raxNode *raxReallocForData(raxNode *n, void *data) {
    if (data == NULL) return n; /* No reallocation needed, setting isnull=1 */
    size_t curlen = raxNodeCurrentLength(n);
    return rax_realloc(n,curlen+sizeof(void*));
}",1,20,rax.c,raxReallocForData,,false,219,223,raxReallocForData,,,14,"raxNode raxReallocForData (raxNode*,void*)"
245215,METHOD,rax.c:<global>,TYPE_DECL,"void raxSetData(raxNode *n, void *data) {
    n->iskey = 1;
    if (data != NULL) {
        n->isnull = 0;
        void **ndata = (void**)
            ((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
        memcpy(ndata,&data,sizeof(data));
    } else {
        n->isnull = 1;
    }
}",1,22,rax.c,raxSetData,,false,226,236,raxSetData,,,15,"void raxSetData (raxNode*,void*)"
245312,METHOD,rax.c:<global>,TYPE_DECL,"void *raxGetData(raxNode *n) {
    if (n->isnull) return NULL;
    void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));
    void *data;
    memcpy(&data,ndata,sizeof(data));
    return data;
}",1,36,rax.c,raxGetData,,false,239,245,raxGetData,,,16,void* raxGetData (raxNode*)
245396,METHOD,rax.c:<global>,TYPE_DECL,"raxNode *raxAddChild(raxNode *n, unsigned char c, raxNode **childptr, raxNode ***parentlink) {
    assert(n->iscompr == 0);

    size_t curlen = raxNodeCurrentLength(n);
    n->size++;
    size_t newlen = raxNodeCurrentLength(n);
    n->size--; /* For now restore the original size. We'll update it only on
                  success at the end. */

    /* Alloc the new child we will link to 'n'. */
    raxNode *child = raxNewNode(0,0);
    if (child == NULL) return NULL;

    /* Make space in the original node. */
    raxNode *newn = rax_realloc(n,newlen);
    if (newn == NULL) {
        rax_free(child);
        return NULL;
    }
    n = newn;

    /* After the reallocation, we have up to 8/16 (depending on the system
     * pointer size, and the required node padding) bytes at the end, that is,
     * the additional char in the 'data' section, plus one pointer to the new
     * child, plus the padding needed in order to store addresses into aligned
     * locations.
     *
     * So...",1,20,rax.c,raxAddChild,,false,256,387,raxAddChild,,,17,"raxNode raxAddChild (raxNode*,unsigned char,raxNode**,raxNode***)"
245816,METHOD,rax.c:<global>,TYPE_DECL,"raxNode *raxCompressNode(raxNode *n, unsigned char *s, size_t len, raxNode **child) {
    assert(n->size == 0 && n->iscompr == 0);
    void *data = NULL; /* Initialized only to avoid warnings. */
    size_t newsize;

    debugf(""Compress node: %.*s\n"", (int)len,s);

    /* Allocate the child to link to this node. */
    *child = raxNewNode(0,0);
    if (*child == NULL) return NULL;

    /* Make space in the parent node. */
    newsize = sizeof(raxNode)+len+raxPadding(len)+sizeof(raxNode*);
    if (n->iskey) {
        data = raxGetData(n); /* To restore it later. */
        if (!n->isnull) newsize += sizeof(void*);
    }
    raxNode *newn = rax_realloc(n,newsize);
    if (newn == NULL) {
        rax_free(*child);
        return NULL;
    }
    n = newn;

    n->iscompr = 1;
    n->size = len;
    memcpy(n->data,s,len);
    if (n->iskey) raxSetData(n,data);
    raxNode **childfield = raxNodeLastChildPtr(n);
    memcpy(childfield,child,sizeof(*child));
    return n;
}",1,4,rax.c,raxCompressNode,,false,397,428,raxCompressNode,,,18,"raxNode raxCompressNode (raxNode*,unsigned char*,size_t,raxNode**)"
246032,METHOD,rax.c:<global>,TYPE_DECL,"static inline size_t raxLowWalk(rax *rax, unsigned char *s, size_t len, raxNode **stopnode, raxNode ***plink, int *splitpos, raxStack *ts) {
    raxNode *h = rax->head;
    raxNode **parentlink = &rax->head;

    size_t i = 0; /* Position in the string. */
    size_t j = 0; /* Position in the node children (or bytes if compressed).*/
    while(h->size && i < len) {
        debugnode(""Lookup current node"",h);
        unsigned char *v = h->data;

        if (h->iscompr) {
            for (j = 0; j < h->size && i < len; j++, i++) {
                if (v[j] != s[i]) break;
            }
            if (j != h->size) break;
        } else {
            /* Even when h->size is large, linear scan provides good
             * performances compared to other approaches that are in theory
             * more sounding, like performing a binary search. */
            for (j = 0; j < h->size; j++) {
                if (v[j] == s[i]) break;
            }
            if (j == h->size) break;
      ...",1,8,rax.c,raxLowWalk,,false,459,500,raxLowWalk,,,19,"size_t raxLowWalk (rax*,unsigned char*,size_t,raxNode**,raxNode***,int*,raxStack*)"
246246,METHOD,rax.c:<global>,TYPE_DECL,"int raxGenericInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old, int overwrite) {
    size_t i;
    int j = 0; /* Split position. If raxLowWalk() stops in a compressed
                  node, the index 'j' represents the char we stopped within the
                  compressed node, that is, the position where to split the
                  node for insertion. */
    raxNode *h, **parentlink;

    debugf(""### Insert %.*s with value %p\n"", (int)len, s, data);
    i = raxLowWalk(rax,s,len,&h,&parentlink,&j,NULL);

    /* If i == len we walked following the whole string. If we are not
     * in the middle of a compressed node, the string is either already
     * inserted or this middle node is currently not a key, but can represent
     * our key. We have just to reallocate the node and make space for the
     * data pointer. */
    if (i == len && (!h->iscompr || j == 0 /* not in the middle if j is 0 */)) {
        debugf(""### Insert: node representing key exists\n""...",1,4,rax.c,raxGenericInsert,,false,509,900,raxGenericInsert,,,20,"int raxGenericInsert (rax*,unsigned char*,size_t,void*,void**,int)"
247762,METHOD,rax.c:<global>,TYPE_DECL,"int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
    return raxGenericInsert(rax,s,len,data,old,1);
}",1,1,rax.c,raxInsert,,false,904,906,raxInsert,,,21,"int raxInsert (rax*,unsigned char*,size_t,void*,void**)"
247779,METHOD,rax.c:<global>,TYPE_DECL,"int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old) {
    return raxGenericInsert(rax,s,len,data,old,0);
}",1,1,rax.c,raxTryInsert,,false,911,913,raxTryInsert,,,22,"int raxTryInsert (rax*,unsigned char*,size_t,void*,void**)"
247796,METHOD,rax.c:<global>,TYPE_DECL,"void *raxFind(rax *rax, unsigned char *s, size_t len) {
    raxNode *h;

    debugf(""### Lookup: %.*s\n"", (int)len, s);
    int splitpos = 0;
    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);
    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)
        return raxNotFound;
    return raxGetData(h);
}",1,4,rax.c,raxFind,,false,918,927,raxFind,,,23,"void* raxFind (rax*,unsigned char*,size_t)"
247844,METHOD,rax.c:<global>,TYPE_DECL,"raxNode **raxFindParentLink(raxNode *parent, raxNode *child) {
    raxNode **cp = raxNodeFirstChildPtr(parent);
    raxNode *c;
    while(1) {
        memcpy(&c,cp,sizeof(c));
        if (c == child) break;
        cp++;
    }
    return cp;
}",1,19,rax.c,raxFindParentLink,,false,934,943,raxFindParentLink,,,24,"raxNode raxFindParentLink (raxNode*,raxNode*)"
247902,METHOD,rax.c:<global>,TYPE_DECL,"raxNode *raxRemoveChild(raxNode *parent, raxNode *child) {
    debugnode(""raxRemoveChild before"", parent);
    /* If parent is a compressed node (having a single child, as for definition
     * of the data structure), the removal of the child consists into turning
     * it into a normal node without children. */
    if (parent->iscompr) {
        void *data = NULL;
        if (parent->iskey) data = raxGetData(parent);
        parent->isnull = 0;
        parent->iscompr = 0;
        parent->size = 0;
        if (parent->iskey) raxSetData(parent,data);
        debugnode(""raxRemoveChild after"", parent);
        return parent;
    }

    /* Otherwise we need to scan for the child pointer and memmove()
     * accordingly.
     *
     * 1. To start we seek the first element in both the children
     *    pointers and edge bytes in the node. */
    raxNode **cp = raxNodeFirstChildPtr(parent);
    raxNode **c = cp;
    unsigned char *e = parent->data;

    /* 2. Search the child pointer to...",1,4,rax.c,raxRemoveChild,,false,949,1018,raxRemoveChild,,,25,"raxNode raxRemoveChild (raxNode*,raxNode*)"
248168,METHOD,rax.c:<global>,TYPE_DECL,"int raxRemove(rax *rax, unsigned char *s, size_t len, void **old) {
    raxNode *h;
    raxStack ts;

    debugf(""### Delete: %.*s\n"", (int)len, s);
    raxStackInit(&ts);
    int splitpos = 0;
    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,&ts);
    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey) {
        raxStackFree(&ts);
        return 0;
    }
    if (old) *old = raxGetData(h);
    h->iskey = 0;
    rax->numele--;

    /* If this node has no children, the deletion needs to reclaim the
     * no longer used nodes. This is an iterative process that needs to
     * walk the three upward, deleting all the nodes with just one child
     * that are not keys, until the head of the rax is reached or the first
     * node with more than one child is found. */

    int trycompress = 0; /* Will be set to 1 if we should try to optimize the
                            tree resulting from the deletion. */

    if (h->size == 0) {
        debugf(""Key deleted in node withou...",1,4,rax.c,raxRemove,,false,1022,1219,raxRemove,,,26,"int raxRemove (rax*,unsigned char*,size_t,void**)"
248882,METHOD,rax.c:<global>,TYPE_DECL,"void raxRecursiveFree(rax *rax, raxNode *n, void (*free_callback)(void*)) {
    debugnode(""free traversing"",n);
    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeLastChildPtr(n);
    while(numchildren--) {
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        raxRecursiveFree(rax,child,free_callback);
        cp--;
    }
    debugnode(""free depth-first"",n);
    if (free_callback && n->iskey && !n->isnull)
        free_callback(raxGetData(n));
    rax_free(n);
    rax->numnodes--;
}",1,4,rax.c,raxRecursiveFree,,false,1223,1238,raxRecursiveFree,,,27,"void raxRecursiveFree (rax*,raxNode*,void)"
249016,METHOD,rax.c:<global>,TYPE_DECL,"void raxFreeWithCallback(rax *rax, void (*free_callback)(void*)) {
    raxRecursiveFree(rax,rax->head,free_callback);
    assert(rax->numnodes == 0);
    rax_free(rax);
}",1,4,rax.c,raxFreeWithCallback,,false,1242,1246,raxFreeWithCallback,,,28,"void raxFreeWithCallback (rax*,void)"
249038,METHOD,rax.c:<global>,TYPE_DECL,"void raxFree(rax *rax) {
    raxFreeWithCallback(rax,NULL);
}",1,1,rax.c,raxFree,,false,1249,1251,raxFree,,,29,void raxFree (rax*)
249046,METHOD,rax.c:<global>,TYPE_DECL,"void raxStart(raxIterator *it, rax *rt) {
    it->flags = RAX_ITER_EOF; /* No crash if the iterator is not seeked. */
    it->rt = rt;
    it->key_len = 0;
    it->key = it->key_static_string;
    it->key_max = RAX_ITER_STATIC_LEN;
    it->data = NULL;
    it->node_cb = NULL;
    raxStackInit(&it->stack);
}",1,16,rax.c,raxStart,,false,1258,1267,raxStart,,,30,"void raxStart (raxIterator*,rax*)"
249100,METHOD,rax.c:<global>,TYPE_DECL,"int raxIteratorAddChars(raxIterator *it, unsigned char *s, size_t len) {
    if (len == 0) return 1;
    if (it->key_max < it->key_len+len) {
        unsigned char *old = (it->key == it->key_static_string) ? NULL :
                                                                  it->key;
        size_t new_max = (it->key_len+len)*2;
        it->key = rax_realloc(old,new_max);
        if (it->key == NULL) {
            it->key = (!old) ? it->key_static_string : old;
            errno = ENOMEM;
            return 0;
        }
        if (old == NULL) memcpy(it->key,it->key_static_string,it->key_len);
        it->key_max = new_max;
    }
    /* Use memmove since there could be an overlap between 's' and
     * it->key when we use the current key in order to re-seek. */
    memmove(it->key+it->key_len,s,len);
    it->key_len += len;
    return 1;
}",1,18,rax.c,raxIteratorAddChars,,false,1272,1292,raxIteratorAddChars,,,31,"int raxIteratorAddChars (raxIterator*,unsigned char*,size_t)"
249219,METHOD,rax.c:<global>,TYPE_DECL,"void raxIteratorDelChars(raxIterator *it, size_t count) {
    it->key_len -= count;
}",1,1,rax.c,raxIteratorDelChars,,false,1296,1298,raxIteratorDelChars,,,32,"void raxIteratorDelChars (raxIterator*,size_t)"
249230,METHOD,rax.c:<global>,TYPE_DECL,"int raxIteratorNextStep(raxIterator *it, int noup) {
    if (it->flags & RAX_ITER_EOF) {
        return 1;
    } else if (it->flags & RAX_ITER_JUST_SEEKED) {
        it->flags &= ~RAX_ITER_JUST_SEEKED;
        return 1;
    }

    /* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */
    size_t orig_key_len = it->key_len;
    size_t orig_stack_items = it->stack.items;
    raxNode *orig_node = it->node;

    while(1) {
        int children = it->node->iscompr ? 1 : it->node->size;
        if (!noup && children) {
            debugf(""GO DEEPER\n"");
            /* Seek the lexicographically smaller key in this subtree, which
             * is the first one found always going towards the first child
             * of every successive node. */
            if (!raxStackPush(&it->stack,it->node)) return 0;
            raxNode **cp = raxNodeFirstChildPtr(it->node);
            if (!raxIteratorAddChars(it,...",1,20,rax.c,raxIteratorNextStep,,false,1314,1410,raxIteratorNextStep,,,33,"int raxIteratorNextStep (raxIterator*,int)"
249717,METHOD,rax.c:<global>,TYPE_DECL,"int raxSeekGreatest(raxIterator *it) {
    while(it->node->size) {
        if (it->node->iscompr) {
            if (!raxIteratorAddChars(it,it->node->data,
                it->node->size)) return 0;
        } else {
            if (!raxIteratorAddChars(it,it->node->data+it->node->size-1,1))
                return 0;
        }
        raxNode **cp = raxNodeLastChildPtr(it->node);
        if (!raxStackPush(&it->stack,it->node)) return 0;
        memcpy(&it->node,cp,sizeof(it->node));
    }
    return 1;
}",1,23,rax.c,raxSeekGreatest,,false,1415,1429,raxSeekGreatest,,,34,int raxSeekGreatest (raxIterator*)
249897,METHOD,rax.c:<global>,TYPE_DECL,"int raxIteratorPrevStep(raxIterator *it, int noup) {
    if (it->flags & RAX_ITER_EOF) {
        return 1;
    } else if (it->flags & RAX_ITER_JUST_SEEKED) {
        it->flags &= ~RAX_ITER_JUST_SEEKED;
        return 1;
    }

    /* Save key len, stack items and the node where we are currently
     * so that on iterator EOF we can restore the current key and state. */
    size_t orig_key_len = it->key_len;
    size_t orig_stack_items = it->stack.items;
    raxNode *orig_node = it->node;

    while(1) {
        int old_noup = noup;

        /* Already on head? Can't go up, iteration finished. */
        if (!noup && it->node == it->rt->head) {
            it->flags |= RAX_ITER_EOF;
            it->stack.items = orig_stack_items;
            it->key_len = orig_key_len;
            it->node = orig_node;
            return 1;
        }

        unsigned char prevchild = it->key[it->key_len-1];
        if (!noup) {
            it->node = raxStackPop(&it->stack);
        } else {
       ...",1,20,rax.c,raxIteratorPrevStep,,false,1434,1505,raxIteratorPrevStep,,,35,"int raxIteratorPrevStep (raxIterator*,int)"
250272,METHOD,rax.c:<global>,TYPE_DECL,"int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len) {
    int eq = 0, lt = 0, gt = 0, first = 0, last = 0;

    it->stack.items = 0; /* Just resetting. Initialized by raxStart(). */
    it->flags |= RAX_ITER_JUST_SEEKED;
    it->flags &= ~RAX_ITER_EOF;
    it->key_len = 0;
    it->node = NULL;

    /* Set flags according to the operator used to perform the seek. */
    if (op[0] == '>') {
        gt = 1;
        if (op[1] == '=') eq = 1;
    } else if (op[0] == '<') {
        lt = 1;
        if (op[1] == '=') eq = 1;
    } else if (op[0] == '=') {
        eq = 1;
    } else if (op[0] == '^') {
        first = 1;
    } else if (op[0] == '$') {
        last = 1;
    } else {
        errno = 0;
        return 0; /* Error. */
    }

    /* If there are no elements, set the EOF condition immediately and
     * return. */
    if (it->rt->numele == 0) {
        it->flags |= RAX_ITER_EOF;
        return 1;
    }

    if (first) {
        /* Seeking the first key gre...",1,17,rax.c,raxSeek,,false,1511,1670,raxSeek,,,36,"int raxSeek (raxIterator*,char*,unsigned char*,size_t)"
250858,METHOD,rax.c:<global>,TYPE_DECL,"int raxNext(raxIterator *it) {
    if (!raxIteratorNextStep(it,0)) {
        errno = ENOMEM;
        return 0;
    }
    if (it->flags & RAX_ITER_EOF) {
        errno = 0;
        return 0;
    }
    return 1;
}",1,20,rax.c,raxNext,,false,1675,1685,raxNext,,,37,int raxNext (raxIterator*)
250892,METHOD,rax.c:<global>,TYPE_DECL,"int raxPrev(raxIterator *it) {
    if (!raxIteratorPrevStep(it,0)) {
        errno = ENOMEM;
        return 0;
    }
    if (it->flags & RAX_ITER_EOF) {
        errno = 0;
        return 0;
    }
    return 1;
}",1,20,rax.c,raxPrev,,false,1690,1700,raxPrev,,,38,int raxPrev (raxIterator*)
250926,METHOD,rax.c:<global>,TYPE_DECL,"int raxRandomWalk(raxIterator *it, size_t steps) {
    if (it->rt->numele == 0) {
        it->flags |= RAX_ITER_EOF;
        return 0;
    }

    if (steps == 0) {
        size_t fle = 1+floor(log(it->rt->numele));
        fle *= 2;
        steps = 1 + rand() % fle;
    }

    raxNode *n = it->node;
    while(steps > 0 || !n->iskey) {
        int numchildren = n->iscompr ? 1 : n->size;
        int r = rand() % (numchildren+(n != it->rt->head));

        if (r == numchildren) {
            /* Go up to parent. */
            n = raxStackPop(&it->stack);
            int todel = n->iscompr ? n->size : 1;
            raxIteratorDelChars(it,todel);
        } else {
            /* Select a random child. */
            if (n->iscompr) {
                if (!raxIteratorAddChars(it,n->data,n->size)) return 0;
            } else {
                if (!raxIteratorAddChars(it,n->data+r,1)) return 0;
            }
            raxNode **cp = raxNodeFirstChildPtr(n)+r;
            if (!raxStackPush...",1,21,rax.c,raxRandomWalk,,false,1714,1752,raxRandomWalk,,,39,"int raxRandomWalk (raxIterator*,size_t)"
251154,METHOD,rax.c:<global>,TYPE_DECL,"int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len) {
    int eq = 0, lt = 0, gt = 0;

    if (op[0] == '=' || op[1] == '=') eq = 1;
    if (op[0] == '>') gt = 1;
    else if (op[0] == '<') lt = 1;
    else if (op[1] != '=') return 0; /* Syntax error. */

    size_t minlen = key_len < iter->key_len ? key_len : iter->key_len;
    int cmp = memcmp(iter->key,key,minlen);

    /* Handle == */
    if (lt == 0 && gt == 0) return cmp == 0 && key_len == iter->key_len;

    /* Handle >, >=, <, <= */
    if (cmp == 0) {
        /* Same prefix: longer wins. */
        if (eq && key_len == iter->key_len) return 1;
        else if (lt) return iter->key_len < key_len;
        else if (gt) return iter->key_len > key_len;
        else return 0; /* Avoid warning, just 'eq' is handled before. */
    } else if (cmp > 0) {
        return gt ? 1 : 0;
    } else /* (cmp < 0) */ {
        return lt ? 1 : 0;
    }
}",1,1,rax.c,raxCompare,,false,1757,1783,raxCompare,,,40,"int raxCompare (raxIterator*,char*,unsigned char*,size_t)"
251325,METHOD,rax.c:<global>,TYPE_DECL,"void raxStop(raxIterator *it) {
    if (it->key != it->key_static_string) rax_free(it->key);
    raxStackFree(&it->stack);
}",1,42,rax.c,raxStop,,false,1786,1789,raxStop,,,41,void raxStop (raxIterator*)
251350,METHOD,rax.c:<global>,TYPE_DECL,"int raxEOF(raxIterator *it) {
    return it->flags & RAX_ITER_EOF;
}",1,23,rax.c,raxEOF,,false,1795,1797,raxEOF,,,42,int raxEOF (raxIterator*)
251365,METHOD,rax.c:<global>,TYPE_DECL,"uint64_t raxSize(rax *rax) {
    return rax->numele;
}",1,1,rax.c,raxSize,,false,1800,1802,raxSize,,,43,uint64_t raxSize (rax*)
251374,METHOD,rax.c:<global>,TYPE_DECL,"void raxRecursiveShow(int level, int lpad, raxNode *n) {
    char s = n->iscompr ? '""' : '[';
    char e = n->iscompr ? '""' : ']';

    int numchars = printf(""%c%.*s%c"", s, n->size, n->data, e);
    if (n->iskey) {
        numchars += printf(""=%p"",raxGetData(n));
    }

    int numchildren = n->iscompr ? 1 : n->size;
    /* Note that 7 and 4 magic constants are the string length
     * of "" `-(x) "" and "" -> "" respectively. */
    if (level) {
        lpad += (numchildren > 1) ? 7 : 4;
        if (numchildren == 1) lpad += numchars;
    }
    raxNode **cp = raxNodeFirstChildPtr(n);
    for (int i = 0; i < numchildren; i++) {
        char *branch = "" `-(%c) "";
        if (numchildren > 1) {
            printf(""\n"");
            for (int j = 0; j < lpad; j++) putchar(' ');
            printf(branch,n->data[i]);
        } else {
            printf("" -> "");
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        raxRecursiveShow(level+1,lpad,child);
        cp+...",1,19,rax.c,raxRecursiveShow,,false,1832,1863,raxRecursiveShow,,,44,"void raxRecursiveShow (int,int,raxNode*)"
251547,METHOD,rax.c:<global>,TYPE_DECL,"void raxShow(rax *rax) {
    raxRecursiveShow(0,0,rax->head);
    putchar('\n');
}",1,1,rax.c,raxShow,,false,1866,1869,raxShow,,,45,void raxShow (rax*)
251560,METHOD,rax.c:<global>,TYPE_DECL,"void raxDebugShowNode(const char *msg, raxNode *n) {
    if (raxDebugMsg == 0) return;
    printf(""%s: %p [%.*s] key:%u size:%u children:"",
        msg, (void*)n, (int)n->size, (char*)n->data, n->iskey, n->size);
    int numcld = n->iscompr ? 1 : n->size;
    raxNode **cldptr = raxNodeLastChildPtr(n) - (numcld-1);
    while(numcld--) {
        raxNode *child;
        memcpy(&child,cldptr,sizeof(child));
        cldptr++;
        printf(""%p "", (void*)child);
    }
    printf(""\n"");
    fflush(stdout);
}",1,23,rax.c,raxDebugShowNode,,false,1872,1886,raxDebugShowNode,,,46,"void raxDebugShowNode (char*,raxNode*)"
251707,METHOD,rax.c:<global>,TYPE_DECL,"unsigned long raxTouch(raxNode *n) {
    debugf(""Touching %p\n"", (void*)n);
    unsigned long sum = 0;
    if (n->iskey) {
        sum += (unsigned long)raxGetData(n);
    }

    int numchildren = n->iscompr ? 1 : n->size;
    raxNode **cp = raxNodeFirstChildPtr(n);
    int count = 0;
    for (int i = 0; i < numchildren; i++) {
        if (numchildren > 1) {
            sum += (long)n->data[i];
        }
        raxNode *child;
        memcpy(&child,cp,sizeof(child));
        if (child == (void*)0x65d1760) count++;
        if (count > 1) exit(1);
        sum += raxTouch(child);
        cp++;
    }
    return sum;
}",1,4,rax.c,raxTouch,,false,1905,1927,raxTouch,,,47,unsigned long raxTouch (raxNode*)
251836,METHOD,rax.h:<global>,TYPE_DECL,<global>,1,23,rax.h,rax.h:<global>,,false,1,216,<global>,,,1,
251844,METHOD,<empty>,<empty>,<empty>,1,,rax.h,raxNode:<clinit>,,false,98,,<clinit>,,,6,
251861,METHOD,<empty>,<empty>,<empty>,1,,rax.h,raxStack:<clinit>,,false,143,,<clinit>,,,6,
251870,METHOD,rax.h:<global>,TYPE_DECL,typedef int (*raxNodeCallback)(raxNode **noderef);,13,49,rax.h,raxNodeCallback,,false,165,165,raxNodeCallback,,,7,int raxNodeCallback (raxNode**)
251886,METHOD,<empty>,<empty>,<empty>,1,,rax.h,raxIterator:<clinit>,,false,175,,<clinit>,,,11,
251896,METHOD,rax.h:<global>,TYPE_DECL,rax *raxNew(void);,5,17,rax.h,raxNew,,false,192,192,raxNew,,,11,rax* raxNew (void)
251901,METHOD,rax.h:<global>,TYPE_DECL,"int raxInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old);",5,77,rax.h,raxInsert,,false,193,193,raxInsert,,,12,"int raxInsert (rax*,unsigned char*,size_t,void*,void**)"
251910,METHOD,rax.h:<global>,TYPE_DECL,"int raxTryInsert(rax *rax, unsigned char *s, size_t len, void *data, void **old);",5,80,rax.h,raxTryInsert,,false,194,194,raxTryInsert,,,13,"int raxTryInsert (rax*,unsigned char*,size_t,void*,void**)"
251919,METHOD,rax.h:<global>,TYPE_DECL,"int raxRemove(rax *rax, unsigned char *s, size_t len, void **old);",5,65,rax.h,raxRemove,,false,195,195,raxRemove,,,14,"int raxRemove (rax*,unsigned char*,size_t,void**)"
251927,METHOD,rax.h:<global>,TYPE_DECL,"void *raxFind(rax *rax, unsigned char *s, size_t len);",6,53,rax.h,raxFind,,false,196,196,raxFind,,,15,"void* raxFind (rax*,unsigned char*,size_t)"
251934,METHOD,rax.h:<global>,TYPE_DECL,void raxFree(rax *rax);,6,22,rax.h,raxFree,,false,197,197,raxFree,,,16,void raxFree (rax*)
251939,METHOD,rax.h:<global>,TYPE_DECL,"void raxFreeWithCallback(rax *rax, void (*free_callback)(void*));",6,64,rax.h,raxFreeWithCallback,,false,198,198,raxFreeWithCallback,,,17,"void raxFreeWithCallback (rax*,void)"
251945,METHOD,rax.h:<global>,TYPE_DECL,"void raxStart(raxIterator *it, rax *rt);",6,39,rax.h,raxStart,,false,199,199,raxStart,,,18,"void raxStart (raxIterator*,rax*)"
251951,METHOD,rax.h:<global>,TYPE_DECL,"int raxSeek(raxIterator *it, const char *op, unsigned char *ele, size_t len);",5,76,rax.h,raxSeek,,false,200,200,raxSeek,,,19,"int raxSeek (raxIterator*,char*,unsigned char*,size_t)"
251959,METHOD,rax.h:<global>,TYPE_DECL,int raxNext(raxIterator *it);,5,28,rax.h,raxNext,,false,201,201,raxNext,,,20,int raxNext (raxIterator*)
251964,METHOD,rax.h:<global>,TYPE_DECL,int raxPrev(raxIterator *it);,5,28,rax.h,raxPrev,,false,202,202,raxPrev,,,21,int raxPrev (raxIterator*)
251969,METHOD,rax.h:<global>,TYPE_DECL,"int raxRandomWalk(raxIterator *it, size_t steps);",5,48,rax.h,raxRandomWalk,,false,203,203,raxRandomWalk,,,22,"int raxRandomWalk (raxIterator*,size_t)"
251975,METHOD,rax.h:<global>,TYPE_DECL,"int raxCompare(raxIterator *iter, const char *op, unsigned char *key, size_t key_len);",5,85,rax.h,raxCompare,,false,204,204,raxCompare,,,23,"int raxCompare (raxIterator*,char*,unsigned char*,size_t)"
251983,METHOD,rax.h:<global>,TYPE_DECL,void raxStop(raxIterator *it);,6,29,rax.h,raxStop,,false,205,205,raxStop,,,24,void raxStop (raxIterator*)
251988,METHOD,rax.h:<global>,TYPE_DECL,int raxEOF(raxIterator *it);,5,27,rax.h,raxEOF,,false,206,206,raxEOF,,,25,int raxEOF (raxIterator*)
251993,METHOD,rax.h:<global>,TYPE_DECL,void raxShow(rax *rax);,6,22,rax.h,raxShow,,false,207,207,raxShow,,,26,void raxShow (rax*)
251998,METHOD,rax.h:<global>,TYPE_DECL,uint64_t raxSize(rax *rax);,10,26,rax.h,raxSize,,false,208,208,raxSize,,,27,uint64_t raxSize (rax*)
252003,METHOD,rax.h:<global>,TYPE_DECL,unsigned long raxTouch(raxNode *n);,15,34,rax.h,raxTouch,,false,209,209,raxTouch,,,28,long unsigned raxTouch (raxNode*)
252008,METHOD,rax.h:<global>,TYPE_DECL,void raxSetDebugMsg(int onoff);,6,30,rax.h,raxSetDebugMsg,,false,210,210,raxSetDebugMsg,,,29,void raxSetDebugMsg (int)
252013,METHOD,rax.h:<global>,TYPE_DECL,"void raxSetData(raxNode *n, void *data);",6,39,rax.h,raxSetData,,false,214,214,raxSetData,,,30,"void raxSetData (raxNode*,void*)"
252024,METHOD,rax_malloc.h:<global>,TYPE_DECL,<global>,1,20,rax_malloc.h,rax_malloc.h:<global>,,false,1,44,<global>,,,1,
252065,METHOD,rdb.c:<global>,TYPE_DECL,<global>,1,1,rdb.c,rdb.c:<global>,,false,1,3722,<global>,,,1,
252072,METHOD,rdb.c:<global>,TYPE_DECL,"void rdbCheckError(const char *fmt, ...);",6,40,rdb.c,rdbCheckError,,false,61,61,rdbCheckError,,,4,void rdbCheckError (char*...)
252077,METHOD,rdb.c:<global>,TYPE_DECL,"void rdbCheckSetError(const char *fmt, ...);",6,43,rdb.c,rdbCheckSetError,,false,62,62,rdbCheckSetError,,,5,void rdbCheckSetError (char*...)
252082,METHOD,rdb.c:<global>,TYPE_DECL,"void rdbReportError(int corruption_error, int linenum, char *reason, ...) {
    va_list ap;
    char msg[1024];
    int len;

    len = snprintf(msg,sizeof(msg),
        ""Internal error in RDB reading offset %llu, function at rdb.c:%d -> "",
        (unsigned long long)server.loading_loaded_bytes, linenum);
    va_start(ap,reason);
    vsnprintf(msg+len,sizeof(msg)-len,reason,ap);
    va_end(ap);

    if (isRestoreContext()) {
        /* If we're in the context of a RESTORE command, just propagate the error. */
        /* log in VERBOSE, and return (don't exit). */
        serverLog(LL_VERBOSE, ""%s"", msg);
        return;
    } else if (rdbCheckMode) {
        /* If we're inside the rdb checker, let it handle the error. */
        rdbCheckError(""%s"",msg);
    } else if (rdbFileBeingLoaded) {
        /* If we're loading an rdb file form disk, run rdb check (and exit) */
        serverLog(LL_WARNING, ""%s"", msg);
        char *argv[2] = {"""",rdbFileBeingLoaded};
        if (anetIsFifo(ar...",1,8,rdb.c,rdbReportError,,false,67,108,rdbReportError,,,6,"void rdbReportError (int,int,char*...)"
252280,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len) {
    if (rdb && rioWrite(rdb,p,len) == 0)
        return -1;
    return len;
}",1,1,rdb.c,rdbWriteRaw,,false,110,114,rdbWriteRaw,,,7,"ssize_t rdbWriteRaw (rio*,void*,size_t)"
252302,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveType(rio *rdb, unsigned char type) {
    return rdbWriteRaw(rdb,&type,1);
}",1,1,rdb.c,rdbSaveType,,false,116,118,rdbSaveType,,,8,"int rdbSaveType (rio*,unsigned char)"
252314,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadType(rio *rdb) {
    unsigned char type;
    if (rioRead(rdb,&type,1) == 0) return -1;
    return type;
}",1,1,rdb.c,rdbLoadType,,false,123,127,rdbLoadType,,,9,int rdbLoadType (rio*)
252334,METHOD,rdb.c:<global>,TYPE_DECL,"time_t rdbLoadTime(rio *rdb) {
    int32_t t32;
    if (rioRead(rdb,&t32,4) == 0) return -1;
    return (time_t)t32;
}",1,1,rdb.c,rdbLoadTime,,false,134,138,rdbLoadTime,,,10,time_t rdbLoadTime (rio*)
252356,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveMillisecondTime(rio *rdb, long long t) {
    int64_t t64 = (int64_t) t;
    memrev64ifbe(&t64); /* Store in little endian. */
    return rdbWriteRaw(rdb,&t64,8);
}",1,4,rdb.c,rdbSaveMillisecondTime,,false,140,144,rdbSaveMillisecondTime,,,11,"int rdbSaveMillisecondTime (rio*,long long)"
252381,METHOD,rdb.c:<global>,TYPE_DECL,"long long rdbLoadMillisecondTime(rio *rdb, int rdbver) {
    int64_t t64;
    if (rioRead(rdb,&t64,8) == 0) return LLONG_MAX;
    if (rdbver >= 9) /* Check the top comment of this function. */
        memrev64ifbe(&t64); /* Convert in big endian if the system is BE. */
    return (long long)t64;
}",1,8,rdb.c,rdbLoadMillisecondTime,,false,161,167,rdbLoadMillisecondTime,,,12,"long long rdbLoadMillisecondTime (rio*,int)"
252415,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveLen(rio *rdb, uint64_t len) {
    unsigned char buf[2];
    size_t nwritten;

    if (len < (1<<6)) {
        /* Save a 6 bit len */
        buf[0] = (len&0xFF)|(RDB_6BITLEN<<6);
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        nwritten = 1;
    } else if (len < (1<<14)) {
        /* Save a 14 bit len */
        buf[0] = ((len>>8)&0xFF)|(RDB_14BITLEN<<6);
        buf[1] = len&0xFF;
        if (rdbWriteRaw(rdb,buf,2) == -1) return -1;
        nwritten = 2;
    } else if (len <= UINT32_MAX) {
        /* Save a 32 bit len */
        buf[0] = RDB_32BITLEN;
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        uint32_t len32 = htonl(len);
        if (rdbWriteRaw(rdb,&len32,4) == -1) return -1;
        nwritten = 1+4;
    } else {
        /* Save a 64 bit len */
        buf[0] = RDB_64BITLEN;
        if (rdbWriteRaw(rdb,buf,1) == -1) return -1;
        len = htonu64(len);
        if (rdbWriteRaw(rdb,&len,8) == -1) return -1;
        nwritten = 1+8;
    }
    ...",1,29,rdb.c,rdbSaveLen,,false,172,203,rdbSaveLen,,,13,"int rdbSaveLen (rio*,uint64_t)"
252601,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr) {
    unsigned char buf[2];
    int type;

    if (isencoded) *isencoded = 0;
    if (rioRead(rdb,buf,1) == 0) return -1;
    type = (buf[0]&0xC0)>>6;
    if (type == RDB_ENCVAL) {
        /* Read a 6 bit encoding type. */
        if (isencoded) *isencoded = 1;
        *lenptr = buf[0]&0x3F;
    } else if (type == RDB_6BITLEN) {
        /* Read a 6 bit len. */
        *lenptr = buf[0]&0x3F;
    } else if (type == RDB_14BITLEN) {
        /* Read a 14 bit len. */
        if (rioRead(rdb,buf+1,1) == 0) return -1;
        *lenptr = ((buf[0]&0x3F)<<8)|buf[1];
    } else if (buf[0] == RDB_32BITLEN) {
        /* Read a 32 bit len. */
        uint32_t len;
        if (rioRead(rdb,&len,4) == 0) return -1;
        *lenptr = ntohl(len);
    } else if (buf[0] == RDB_64BITLEN) {
        /* Read a 64 bit len. */
        uint64_t len;
        if (rioRead(rdb,&len,8) == 0) return -1;
        *lenptr = ntohu64(len);
    } else {
       ...",1,16,rdb.c,rdbLoadLenByRef,,false,215,249,rdbLoadLenByRef,,,14,"int rdbLoadLenByRef (rio*,int*,uint64_t*)"
252787,METHOD,rdb.c:<global>,TYPE_DECL,"uint64_t rdbLoadLen(rio *rdb, int *isencoded) {
    uint64_t len;

    if (rdbLoadLenByRef(rdb,isencoded,&len) == -1) return RDB_LENERR;
    return len;
}",1,58,rdb.c,rdbLoadLen,,false,255,260,rdbLoadLen,,,15,"uint64_t rdbLoadLen (rio*,int*)"
252810,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbEncodeInteger(long long value, unsigned char *enc) {
    if (value >= -(1<<7) && value <= (1<<7)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT8;
        enc[1] = value&0xFF;
        return 2;
    } else if (value >= -(1<<15) && value <= (1<<15)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT16;
        enc[1] = value&0xFF;
        enc[2] = (value>>8)&0xFF;
        return 3;
    } else if (value >= -((long long)1<<31) && value <= ((long long)1<<31)-1) {
        enc[0] = (RDB_ENCVAL<<6)|RDB_ENC_INT32;
        enc[1] = value&0xFF;
        enc[2] = (value>>8)&0xFF;
        enc[3] = (value>>16)&0xFF;
        enc[4] = (value>>24)&0xFF;
        return 5;
    } else {
        return 0;
    }
}",1,18,rdb.c,rdbEncodeInteger,,false,266,286,rdbEncodeInteger,,,16,"int rdbEncodeInteger (long long,unsigned char*)"
252978,METHOD,rdb.c:<global>,TYPE_DECL,"void *rdbLoadIntegerObject(rio *rdb, int enctype, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    int encode = flags & RDB_LOAD_ENC;
    unsigned char enc[4];
    long long val;

    if (enctype == RDB_ENC_INT8) {
        if (rioRead(rdb,enc,1) == 0) return NULL;
        val = (signed char)enc[0];
    } else if (enctype == RDB_ENC_INT16) {
        uint16_t v;
        if (rioRead(rdb,enc,2) == 0) return NULL;
        v = ((uint32_t)enc[0])|
            ((uint32_t)enc[1]<<8);
        val = (int16_t)v;
    } else if (enctype == RDB_ENC_INT32) {
        uint32_t v;
        if (rioRead(rdb,enc,4) == 0) return NULL;
        v = ((uint32_t)enc[0])|
            ((uint32_t)enc[1]<<8)|
            ((uint32_t)enc[2]<<16)|
            ((uint32_t)enc[3]<<24);
        val = (int32_t)v;
    } else {
        rdbReportCorruptRDB(""Unknown RDB integer encoding type %d"",enctype);
        return NULL; /* Never reached. */
    }
    if (plain |...",1,24,rdb.c,rdbLoadIntegerObject,,false,291,331,rdbLoadIntegerObject,,,17,"void* rdbLoadIntegerObject (rio*,int,int,size_t*)"
253199,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {
    long long value;
    if (string2ll(s, len, &value)) {
        return rdbEncodeInteger(value, enc);
    } else {
        return 0;
    }
}",1,1,rdb.c,rdbTryIntegerEncoding,,false,336,343,rdbTryIntegerEncoding,,,18,"int rdbTryIntegerEncoding (char*,size_t,unsigned char*)"
253222,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveLzfBlob(rio *rdb, void *data, size_t compress_len,
                       size_t original_len) {
    unsigned char byte;
    ssize_t n, nwritten = 0;

    /* Data compressed! Let's save it on disk */
    byte = (RDB_ENCVAL<<6)|RDB_ENC_LZF;
    if ((n = rdbWriteRaw(rdb,&byte,1)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbSaveLen(rdb,compress_len)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbSaveLen(rdb,original_len)) == -1) goto writeerr;
    nwritten += n;

    if ((n = rdbWriteRaw(rdb,data,compress_len)) == -1) goto writeerr;
    nwritten += n;

    return nwritten;

writeerr:
    return -1;
}",1,12,rdb.c,rdbSaveLzfBlob,,false,345,368,rdbSaveLzfBlob,,,19,"ssize_t rdbSaveLzfBlob (rio*,void*,size_t,size_t)"
253312,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {
    size_t comprlen, outlen;
    void *out;

    /* We require at least four bytes compression for this to be worth it */
    if (len <= 4) return 0;
    outlen = len-4;
    if ((out = zmalloc(outlen+1)) == NULL) return 0;
    comprlen = lzf_compress(s, len, out, outlen);
    if (comprlen == 0) {
        zfree(out);
        return 0;
    }
    ssize_t nwritten = rdbSaveLzfBlob(rdb, out, comprlen, len);
    zfree(out);
    return nwritten;
}",1,1,rdb.c,rdbSaveLzfStringObject,,false,370,386,rdbSaveLzfStringObject,,,20,"ssize_t rdbSaveLzfStringObject (rio*,unsigned char*,size_t)"
253374,METHOD,rdb.c:<global>,TYPE_DECL,"void *rdbLoadLzfStringObject(rio *rdb, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    uint64_t len, clen;
    unsigned char *c = NULL;
    char *val = NULL;

    if ((clen = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
    if ((len = rdbLoadLen(rdb,NULL)) == RDB_LENERR) return NULL;
    if ((c = ztrymalloc(clen)) == NULL) {
        serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbLoadLzfStringObject failed allocating %llu bytes"", (unsigned long long)clen);
        goto err;
    }

    /* Allocate our target according to the uncompressed size. */
    if (plain) {
        val = ztrymalloc(len);
    } else {
        val = sdstrynewlen(SDS_NOINIT,len);
    }
    if (!val) {
        serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbLoadLzfStringObject failed allocating %llu bytes"", (unsigned long long)len);
        goto err;
    }

    if (lenptr) *lenptr = len;

    /* Load the compressed representation ...",1,24,rdb.c,rdbLoadLzfStringObject,,false,391,438,rdbLoadLzfStringObject,,,21,"void* rdbLoadLzfStringObject (rio*,int,size_t*)"
253642,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {
    int enclen;
    ssize_t n, nwritten = 0;

    /* Try integer encoding */
    if (len <= 11) {
        unsigned char buf[5];
        if ((enclen = rdbTryIntegerEncoding((char*)s,len,buf)) > 0) {
            if (rdbWriteRaw(rdb,buf,enclen) == -1) return -1;
            return enclen;
        }
    }

    /* Try LZF compression - under 20 bytes it's unable to compress even
     * aaaaaaaaaaaaaaaaaa so skip it */
    if (server.rdb_compression && len > 20) {
        n = rdbSaveLzfStringObject(rdb,s,len);
        if (n == -1) return -1;
        if (n > 0) return n;
        /* Return value of 0 means data can't be compressed, save the old way */
    }

    /* Store verbatim */
    if ((n = rdbSaveLen(rdb,len)) == -1) return -1;
    nwritten += n;
    if (len > 0) {
        if (rdbWriteRaw(rdb,s,len) == -1) return -1;
        nwritten += len;
    }
    return nwritten;
}",1,1,rdb.c,rdbSaveRawString,,false,442,472,rdbSaveRawString,,,22,"ssize_t rdbSaveRawString (rio*,unsigned char*,size_t)"
253756,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveLongLongAsStringObject(rio *rdb, long long value) {
    unsigned char buf[32];
    ssize_t n, nwritten = 0;
    int enclen = rdbEncodeInteger(value,buf);
    if (enclen > 0) {
        return rdbWriteRaw(rdb,buf,enclen);
    } else {
        /* Encode as string */
        enclen = ll2string((char*)buf,32,value);
        serverAssert(enclen < 32);
        if ((n = rdbSaveLen(rdb,enclen)) == -1) return -1;
        nwritten += n;
        if ((n = rdbWriteRaw(rdb,buf,enclen)) == -1) return -1;
        nwritten += n;
    }
    return nwritten;
}",1,8,rdb.c,rdbSaveLongLongAsStringObject,,false,475,491,rdbSaveLongLongAsStringObject,,,23,"ssize_t rdbSaveLongLongAsStringObject (rio*,long long)"
253845,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveStringObject(rio *rdb, robj *obj) {
    /* Avoid to decode the object, then encode it again, if the
     * object is already integer encoded. */
    if (obj->encoding == OBJ_ENCODING_INT) {
        return rdbSaveLongLongAsStringObject(rdb,(long)obj->ptr);
    } else {
        serverAssertWithInfo(NULL,obj,sdsEncodedObject(obj));
        return rdbSaveRawString(rdb,obj->ptr,sdslen(obj->ptr));
    }
}",1,25,rdb.c,rdbSaveStringObject,,false,494,503,rdbSaveStringObject,,,24,"ssize_t rdbSaveStringObject (rio*,robj*)"
253908,METHOD,rdb.c:<global>,TYPE_DECL,"void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr) {
    int plain = flags & RDB_LOAD_PLAIN;
    int sds = flags & RDB_LOAD_SDS;
    int isencoded;
    unsigned long long len;

    len = rdbLoadLen(rdb,&isencoded);
    if (len == RDB_LENERR) return NULL;

    if (isencoded) {
        switch(len) {
        case RDB_ENC_INT8:
        case RDB_ENC_INT16:
        case RDB_ENC_INT32:
            return rdbLoadIntegerObject(rdb,len,flags,lenptr);
        case RDB_ENC_LZF:
            return rdbLoadLzfStringObject(rdb,flags,lenptr);
        default:
            rdbReportCorruptRDB(""Unknown RDB string encoding type %llu"",len);
            return NULL;
        }
    }

    if (plain || sds) {
        void *buf = plain ? ztrymalloc(len) : sdstrynewlen(SDS_NOINIT,len);
        if (!buf) {
            serverLog(isRestoreContext()? LL_VERBOSE: LL_WARNING, ""rdbGenericLoadStringObject failed allocating %llu bytes"", len);
            return NULL;
        }
        if (lenptr) *le...",1,24,rdb.c,rdbGenericLoadStringObject,,false,518,568,rdbGenericLoadStringObject,,,25,"void* rdbGenericLoadStringObject (rio*,int,size_t*)"
254188,METHOD,rdb.c:<global>,TYPE_DECL,"robj *rdbLoadStringObject(rio *rdb) {
    return rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
}",1,42,rdb.c,rdbLoadStringObject,,false,570,572,rdbLoadStringObject,,,26,robj rdbLoadStringObject (rio*)
254200,METHOD,rdb.c:<global>,TYPE_DECL,"robj *rdbLoadEncodedStringObject(rio *rdb) {
    return rdbGenericLoadStringObject(rdb,RDB_LOAD_ENC,NULL);
}",1,42,rdb.c,rdbLoadEncodedStringObject,,false,574,576,rdbLoadEncodedStringObject,,,27,robj rdbLoadEncodedStringObject (rio*)
254214,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveDoubleValue(rio *rdb, double val) {
    unsigned char buf[128];
    int len;

    if (isnan(val)) {
        buf[0] = 253;
        len = 1;
    } else if (!isfinite(val)) {
        len = 1;
        buf[0] = (val < 0) ? 255 : 254;
    } else {
        long long lvalue;
        /* Integer printing function is much faster, check if we can safely use it. */
        if (double2ll(val, &lvalue))
            ll2string((char*)buf+1,sizeof(buf)-1,lvalue);
        else {
            const int dlen = fpconv_dtoa(val, (char*)buf+1);
            buf[dlen+1] = '\0';
        }
        buf[0] = strlen((char*)buf+1);
        len = buf[0]+1;
    }
    return rdbWriteRaw(rdb,buf,len);
}",1,1,rdb.c,rdbSaveDoubleValue,,false,586,609,rdbSaveDoubleValue,,,28,"int rdbSaveDoubleValue (rio*,double)"
254315,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadDoubleValue(rio *rdb, double *val) {
    char buf[256];
    unsigned char len;

    if (rioRead(rdb,&len,1) == 0) return -1;
    switch(len) {
    case 255: *val = R_NegInf; return 0;
    case 254: *val = R_PosInf; return 0;
    case 253: *val = R_Nan; return 0;
    default:
        if (rioRead(rdb,buf,len) == 0) return -1;
        buf[len] = '\0';
        if (sscanf(buf, ""%lg"", val)!=1) return -1;
        return 0;
    }
}",1,1,rdb.c,rdbLoadDoubleValue,,false,612,627,rdbLoadDoubleValue,,,29,"int rdbLoadDoubleValue (rio*,double*)"
254392,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveBinaryDoubleValue(rio *rdb, double val) {
    memrev64ifbe(&val);
    return rdbWriteRaw(rdb,&val,sizeof(val));
}",1,4,rdb.c,rdbSaveBinaryDoubleValue,,false,634,637,rdbSaveBinaryDoubleValue,,,30,"int rdbSaveBinaryDoubleValue (rio*,double)"
254412,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadBinaryDoubleValue(rio *rdb, double *val) {
    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
    memrev64ifbe(val);
    return 0;
}",1,4,rdb.c,rdbLoadBinaryDoubleValue,,false,641,645,rdbLoadBinaryDoubleValue,,,31,"int rdbLoadBinaryDoubleValue (rio*,double*)"
254438,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveBinaryFloatValue(rio *rdb, float val) {
    memrev32ifbe(&val);
    return rdbWriteRaw(rdb,&val,sizeof(val));
}",1,4,rdb.c,rdbSaveBinaryFloatValue,,false,648,651,rdbSaveBinaryFloatValue,,,32,"int rdbSaveBinaryFloatValue (rio*,float)"
254458,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadBinaryFloatValue(rio *rdb, float *val) {
    if (rioRead(rdb,val,sizeof(*val)) == 0) return -1;
    memrev32ifbe(val);
    return 0;
}",1,4,rdb.c,rdbLoadBinaryFloatValue,,false,654,658,rdbLoadBinaryFloatValue,,,33,"int rdbLoadBinaryFloatValue (rio*,float*)"
254484,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveObjectType(rio *rdb, robj *o) {
    switch (o->type) {
    case OBJ_STRING:
        return rdbSaveType(rdb,RDB_TYPE_STRING);
    case OBJ_LIST:
        if (o->encoding == OBJ_ENCODING_QUICKLIST || o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb, RDB_TYPE_LIST_QUICKLIST_2);
        else
            serverPanic(""Unknown list encoding"");
    case OBJ_SET:
        if (o->encoding == OBJ_ENCODING_INTSET)
            return rdbSaveType(rdb,RDB_TYPE_SET_INTSET);
        else if (o->encoding == OBJ_ENCODING_HT)
            return rdbSaveType(rdb,RDB_TYPE_SET);
        else if (o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb,RDB_TYPE_SET_LISTPACK);
        else
            serverPanic(""Unknown set encoding"");
    case OBJ_ZSET:
        if (o->encoding == OBJ_ENCODING_LISTPACK)
            return rdbSaveType(rdb,RDB_TYPE_ZSET_LISTPACK);
        else if (o->encoding == OBJ_ENCODING_SKIPLIST)
            return rdbSaveType(rdb,RDB_TYP...",1,9,rdb.c,rdbSaveObjectType,,false,661,701,rdbSaveObjectType,,,34,"int rdbSaveObjectType (rio*,robj*)"
254729,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadObjectType(rio *rdb) {
    int type;
    if ((type = rdbLoadType(rdb)) == -1) return -1;
    if (!rdbIsObjectType(type)) return -1;
    return type;
}",1,9,rdb.c,rdbLoadObjectType,,false,705,710,rdbLoadObjectType,,,35,int rdbLoadObjectType (rio*)
254773,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveStreamPEL(rio *rdb, rax *pel, int nacks) {
    ssize_t n, nwritten = 0;

    /* Number of entries in the PEL. */
    if ((n = rdbSaveLen(rdb,raxSize(pel))) == -1) return -1;
    nwritten += n;

    /* Save each entry. */
    raxIterator ri;
    raxStart(&ri,pel);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        /* We store IDs in raw form as 128 big big endian numbers, like
         * they are inside the radix tree key. */
        if ((n = rdbWriteRaw(rdb,ri.key,sizeof(streamID))) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        if (nacks) {
            streamNACK *nack = ri.data;
            if ((n = rdbSaveMillisecondTime(rdb,nack->delivery_time)) == -1) {
                raxStop(&ri);
                return -1;
            }
            nwritten += n;
            if ((n = rdbSaveLen(rdb,nack->delivery_count)) == -1) {
                raxStop(&ri);
                return -1;
            }
            n...",1,1,rdb.c,rdbSaveStreamPEL,,false,719,758,rdbSaveStreamPEL,,,36,"ssize_t rdbSaveStreamPEL (rio*,rax*,int)"
254897,METHOD,rdb.c:<global>,TYPE_DECL,"size_t rdbSaveStreamConsumers(rio *rdb, streamCG *cg) {
    ssize_t n, nwritten = 0;

    /* Number of consumers in this consumer group. */
    if ((n = rdbSaveLen(rdb,raxSize(cg->consumers))) == -1) return -1;
    nwritten += n;

    /* Save each consumer. */
    raxIterator ri;
    raxStart(&ri,cg->consumers);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        streamConsumer *consumer = ri.data;

        /* Consumer name. */
        if ((n = rdbSaveRawString(rdb,ri.key,ri.key_len)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Seen time. */
        if ((n = rdbSaveMillisecondTime(rdb,consumer->seen_time)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Active time. */
        if ((n = rdbSaveMillisecondTime(rdb,consumer->active_time)) == -1) {
            raxStop(&ri);
            return -1;
        }
        nwritten += n;

        /* Consumer PEL, without t...",1,1,rdb.c,rdbSaveStreamConsumers,,false,763,810,rdbSaveStreamConsumers,,,37,"size_t rdbSaveStreamConsumers (rio*,streamCG*)"
255044,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key, int dbid) {
    ssize_t n = 0, nwritten = 0;

    if (o->type == OBJ_STRING) {
        /* Save a string value */
        if ((n = rdbSaveStringObject(rdb,o)) == -1) return -1;
        nwritten += n;
    } else if (o->type == OBJ_LIST) {
        /* Save a list value */
        if (o->encoding == OBJ_ENCODING_QUICKLIST) {
            quicklist *ql = o->ptr;
            quicklistNode *node = ql->head;

            if ((n = rdbSaveLen(rdb,ql->len)) == -1) return -1;
            nwritten += n;

            while(node) {
                if ((n = rdbSaveLen(rdb,node->container)) == -1) return -1;
                nwritten += n;

                if (quicklistNodeIsCompressed(node)) {
                    void *data;
                    size_t compress_len = quicklistGetLzf(node, &data);
                    if ((n = rdbSaveLzfBlob(rdb,data,compress_len,node->sz)) == -1) return -1;
                    nwritten += n;
                } else {
  ...",1,19,rdb.c,rdbSaveObject,,false,814,1110,rdbSaveObject,,,38,"ssize_t rdbSaveObject (rio*,robj*,robj*,int)"
256451,METHOD,rdb.c:<global>,TYPE_DECL,"size_t rdbSavedObjectLen(robj *o, robj *key, int dbid) {
    ssize_t len = rdbSaveObject(NULL,o,key,dbid);
    serverAssertWithInfo(NULL,o,len != -1);
    return len;
}",1,4,rdb.c,rdbSavedObjectLen,,false,1116,1120,rdbSavedObjectLen,,,39,"size_t rdbSavedObjectLen (robj*,robj*,int)"
256489,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, int dbid) {
    int savelru = server.maxmemory_policy & MAXMEMORY_FLAG_LRU;
    int savelfu = server.maxmemory_policy & MAXMEMORY_FLAG_LFU;

    /* Save the expire time */
    if (expiretime != -1) {
        if (rdbSaveType(rdb,RDB_OPCODE_EXPIRETIME_MS) == -1) return -1;
        if (rdbSaveMillisecondTime(rdb,expiretime) == -1) return -1;
    }

    /* Save the LRU info. */
    if (savelru) {
        uint64_t idletime = estimateObjectIdleTime(val);
        idletime /= 1000; /* Using seconds is enough and requires less space.*/
        if (rdbSaveType(rdb,RDB_OPCODE_IDLE) == -1) return -1;
        if (rdbSaveLen(rdb,idletime) == -1) return -1;
    }

    /* Save the LFU info. */
    if (savelfu) {
        uint8_t buf[1];
        buf[0] = LFUDecrAndReturn(val);
        /* We can encode this in exactly two bytes: the opcode and an 8
         * bit counter, since the frequency is logarithmic with a 0-255 range...",1,44,rdb.c,rdbSaveKeyValuePair,,false,1125,1165,rdbSaveKeyValuePair,,,40,"int rdbSaveKeyValuePair (rio*,robj*,robj*,long long,int)"
256668,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveAuxField(rio *rdb, void *key, size_t keylen, void *val, size_t vallen) {
    ssize_t ret, len = 0;
    if ((ret = rdbSaveType(rdb,RDB_OPCODE_AUX)) == -1) return -1;
    len += ret;
    if ((ret = rdbSaveRawString(rdb,key,keylen)) == -1) return -1;
    len += ret;
    if ((ret = rdbSaveRawString(rdb,val,vallen)) == -1) return -1;
    len += ret;
    return len;
}",1,31,rdb.c,rdbSaveAuxField,,false,1168,1177,rdbSaveAuxField,,,41,"ssize_t rdbSaveAuxField (rio*,void*,size_t,void*,size_t)"
256736,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}",1,1,rdb.c,rdbSaveAuxFieldStrStr,,false,1181,1183,rdbSaveAuxFieldStrStr,,,42,"ssize_t rdbSaveAuxFieldStrStr (rio*,char*,char*)"
256752,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveAuxFieldStrInt(rio *rdb, char *key, long long val) {
    char buf[LONG_STR_SIZE];
    int vlen = ll2string(buf,sizeof(buf),val);
    return rdbSaveAuxField(rdb,key,strlen(key),buf,vlen);
}",1,13,rdb.c,rdbSaveAuxFieldStrInt,,false,1186,1190,rdbSaveAuxFieldStrInt,,,43,"ssize_t rdbSaveAuxFieldStrInt (rio*,char*,long long)"
256776,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveInfoAuxFields(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
    int redis_bits = (sizeof(void*) == 8) ? 64 : 32;
    int aof_base = (rdbflags & RDBFLAGS_AOF_PREAMBLE) != 0;

    /* Add a few fields about the state when the RDB was created. */
    if (rdbSaveAuxFieldStrStr(rdb,""redis-ver"",REDIS_VERSION) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""redis-bits"",redis_bits) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""ctime"",time(NULL)) == -1) return -1;
    if (rdbSaveAuxFieldStrInt(rdb,""used-mem"",zmalloc_used_memory()) == -1) return -1;

    /* Handle saving options that generate aux fields. */
    if (rsi) {
        if (rdbSaveAuxFieldStrInt(rdb,""repl-stream-db"",rsi->repl_stream_db)
            == -1) return -1;
        if (rdbSaveAuxFieldStrStr(rdb,""repl-id"",server.replid)
            == -1) return -1;
        if (rdbSaveAuxFieldStrInt(rdb,""repl-offset"",server.master_repl_offset)
            == -1) return -1;
    }
    if (rdbSaveAuxFieldStrInt(rdb, ""aof-bas...",1,31,rdb.c,rdbSaveInfoAuxFields,,false,1193,1214,rdbSaveInfoAuxFields,,,44,"int rdbSaveInfoAuxFields (rio*,int,rdbSaveInfo*)"
256915,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt) {
    /* Save a module-specific aux value. */
    RedisModuleIO io;
    int retval = 0;
    moduleInitIOContext(io,mt,rdb,NULL,-1);

    /* We save the AUX field header in a temporary buffer so we can support aux_save2 API.
     * If aux_save2 is used the buffer will be flushed at the first time the module will perform
     * a write operation to the RDB and will be ignored is case there was no writes. */
    rio aux_save_headers_rio;
    rioInitWithBuffer(&aux_save_headers_rio, sdsempty());

    if (rdbSaveType(&aux_save_headers_rio, RDB_OPCODE_MODULE_AUX) == -1) goto error;

    /* Write the ""module"" identifier as prefix, so that we'll be able
     * to call the right module during loading. */
    if (rdbSaveLen(&aux_save_headers_rio,mt->id) == -1) goto error;

    /* write the 'when' so that we can provide it on loading. add a UINT opcode
     * for backwards compatibility, everything after the MT needs to be pref...",1,4,rdb.c,rdbSaveSingleModuleAux,,false,1216,1277,rdbSaveSingleModuleAux,,,45,"ssize_t rdbSaveSingleModuleAux (rio*,int,moduleType*)"
257200,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveFunctions(rio *rdb) {
    dict *functions = functionsLibGet();
    dictIterator *iter = dictGetIterator(functions);
    dictEntry *entry = NULL;
    ssize_t written = 0;
    ssize_t ret;
    while ((entry = dictNext(iter))) {
        if ((ret = rdbSaveType(rdb, RDB_OPCODE_FUNCTION2)) < 0) goto werr;
        written += ret;
        functionLibInfo *li = dictGetVal(entry);
        if ((ret = rdbSaveRawString(rdb, (unsigned char *) li->code, sdslen(li->code))) < 0) goto werr;
        written += ret;
    }
    dictReleaseIterator(iter);
    return written;

werr:
    dictReleaseIterator(iter);
    return -1;
}",1,36,rdb.c,rdbSaveFunctions,,false,1279,1298,rdbSaveFunctions,,,46,ssize_t rdbSaveFunctions (rio*)
257280,METHOD,rdb.c:<global>,TYPE_DECL,"ssize_t rdbSaveDb(rio *rdb, int dbid, int rdbflags, long *key_counter) {
    dictIterator *di;
    dictEntry *de;
    ssize_t written = 0;
    ssize_t res;
    static long long info_updated_time = 0;
    char *pname = (rdbflags & RDBFLAGS_AOF_PREAMBLE) ? ""AOF rewrite"" :  ""RDB"";

    redisDb *db = server.db + dbid;
    dict *d = db->dict;
    if (dictSize(d) == 0) return 0;
    di = dictGetSafeIterator(d);

    /* Write the SELECT DB opcode */
    if ((res = rdbSaveType(rdb,RDB_OPCODE_SELECTDB)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb, dbid)) < 0) goto werr;
    written += res;

    /* Write the RESIZE DB opcode. */
    uint64_t db_size, expires_size;
    db_size = dictSize(db->dict);
    expires_size = dictSize(db->expires);
    if ((res = rdbSaveType(rdb,RDB_OPCODE_RESIZEDB)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb,db_size)) < 0) goto werr;
    written += res;
    if ((res = rdbSaveLen(rdb,expires_size)) < 0) goto werr;
    writte...",1,30,rdb.c,rdbSaveDb,,false,1300,1366,rdbSaveDb,,,47,"ssize_t rdbSaveDb (rio*,int,int,long*)"
257597,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveRio(int req, rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi) {
    char magic[10];
    uint64_t cksum;
    long key_counter = 0;
    int j;

    if (server.rdb_checksum)
        rdb->update_cksum = rioGenericUpdateChecksum;
    snprintf(magic,sizeof(magic),""REDIS%04d"",RDB_VERSION);
    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;
    if (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == -1) goto werr;
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA) && rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == -1) goto werr;

    /* save functions */
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_FUNCTIONS) && rdbSaveFunctions(rdb) == -1) goto werr;

    /* save all databases, skip this if we're in functions-only mode */
    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA)) {
        for (j = 0; j < server.dbnum; j++) {
            if (rdbSaveDb(rdb, j, rdbflags, &key_counter) == -1) goto werr;
        }
    }

    if (!(req & SLAVE_REQ_RDB_EXCLUDE_DATA) && rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFT...",1,45,rdb.c,rdbSaveRio,,false,1376,1414,rdbSaveRio,,,48,"int rdbSaveRio (int,rio*,int*,int,rdbSaveInfo*)"
257797,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveRioWithEOFMark(int req, rio *rdb, int *error, rdbSaveInfo *rsi) {
    char eofmark[RDB_EOF_MARK_SIZE];

    startSaving(RDBFLAGS_REPLICATION);
    getRandomHexChars(eofmark,RDB_EOF_MARK_SIZE);
    if (error) *error = 0;
    if (rioWrite(rdb,""$EOF:"",5) == 0) goto werr;
    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
    if (rioWrite(rdb,""\r\n"",2) == 0) goto werr;
    if (rdbSaveRio(req,rdb,error,RDBFLAGS_NONE,rsi) == C_ERR) goto werr;
    if (rioWrite(rdb,eofmark,RDB_EOF_MARK_SIZE) == 0) goto werr;
    stopSaving(1);
    return C_OK;

werr: /* Write error. */
    /* Set 'error' only if not already set by rdbSaveRio() call. */
    if (error && *error == 0) *error = errno;
    stopSaving(0);
    return C_ERR;
}",1,17,rdb.c,rdbSaveRioWithEOFMark,,false,1424,1443,rdbSaveRioWithEOFMark,,,49,"int rdbSaveRioWithEOFMark (int,rio*,int*,rdbSaveInfo*)"
257906,METHOD,rdb.c:<global>,TYPE_DECL,"static int rdbSaveInternal(int req, const char *filename, rdbSaveInfo *rsi, int rdbflags) {
    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */
    rio rdb;
    int error = 0;
    int saved_errno;
    char *err_op;    /* For a detailed log */

    FILE *fp = fopen(filename,""w"");
    if (!fp) {
        saved_errno = errno;
        char *str_err = strerror(errno);
        char *cwdp = getcwd(cwd,MAXPATHLEN);
        serverLog(LL_WARNING,
            ""Failed opening the temp RDB file %s (in server root dir %s) ""
            ""for saving: %s"",
            filename,
            cwdp ? cwdp : ""unknown"",
            str_err);
        errno = saved_errno;
        return C_ERR;
    }

    rioInitWithFile(&rdb,fp);

    if (server.rdb_save_incremental_fsync) {
        rioSetAutoSync(&rdb,REDIS_AUTOSYNC_BYTES);
        if (!(rdbflags & RDBFLAGS_KEEP_CACHE)) rioSetReclaimCache(&rdb,1);
    }

    if (rdbSaveRio(req,&rdb,&error,rdbflags,rsi) == C_ERR) {
        errno = er...",1,8,rdb.c,rdbSaveInternal,,false,1445,1497,rdbSaveInternal,,,50,"int rdbSaveInternal (int,char*,rdbSaveInfo*,int)"
258144,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveToFile(const char *filename) {
    startSaving(RDBFLAGS_NONE);

    if (rdbSaveInternal(SLAVE_REQ_NONE,filename,NULL,RDBFLAGS_NONE) != C_OK) {
        int saved_errno = errno;
        stopSaving(0);
        errno = saved_errno;
        return C_ERR;
    }

    stopSaving(1);
    return C_OK;
}",1,16,rdb.c,rdbSaveToFile,,false,1501,1513,rdbSaveToFile,,,51,int rdbSaveToFile (char*)
258188,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSave(int req, char *filename, rdbSaveInfo *rsi, int rdbflags) {
    char tmpfile[256];
    char cwd[MAXPATHLEN]; /* Current working dir path for error messages. */

    startSaving(RDBFLAGS_NONE);
    snprintf(tmpfile,256,""temp-%d.rdb"", (int) getpid());

    if (rdbSaveInternal(req,tmpfile,rsi,rdbflags) != C_OK) {
        stopSaving(0);
        return C_ERR;
    }
    
    /* Use RENAME to make sure the DB file is changed atomically only
     * if the generate DB file is ok. */
    if (rename(tmpfile,filename) == -1) {
        char *str_err = strerror(errno);
        char *cwdp = getcwd(cwd,MAXPATHLEN);
        serverLog(LL_WARNING,
            ""Error moving temp DB file %s on the final ""
            ""destination %s (in server root dir %s): %s"",
            tmpfile,
            filename,
            cwdp ? cwdp : ""unknown"",
            str_err);
        unlink(tmpfile);
        stopSaving(0);
        return C_ERR;
    }
    if (fsyncFileDir(filename) != 0) {
        serverLog...",1,16,rdb.c,rdbSave,,false,1516,1557,rdbSave,,,52,"int rdbSave (int,char*,rdbSaveInfo*,int)"
258355,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveBackground(int req, char *filename, rdbSaveInfo *rsi, int rdbflags) {
    pid_t childpid;

    if (hasActiveChildProcess()) return C_ERR;
    server.stat_rdb_saves++;

    server.dirty_before_bgsave = server.dirty;
    server.lastbgsave_try = time(NULL);

    if ((childpid = redisFork(CHILD_TYPE_RDB)) == 0) {
        int retval;

        /* Child */
        redisSetProcTitle(""redis-rdb-bgsave"");
        redisSetCpuAffinity(server.bgsave_cpulist);
        retval = rdbSave(req, filename,rsi,rdbflags);
        if (retval == C_OK) {
            sendChildCowInfo(CHILD_INFO_TYPE_RDB_COW_SIZE, ""RDB"");
        }
        exitFromChild((retval == C_OK) ? 0 : 1);
    } else {
        /* Parent */
        if (childpid == -1) {
            server.lastbgsave_status = C_ERR;
            serverLog(LL_WARNING,""Can't save in background: fork: %s"",
                strerror(errno));
            return C_ERR;
        }
        serverLog(LL_NOTICE,""Background saving started by pid %ld"",(long) ...",1,40,rdb.c,rdbSaveBackground,,false,1559,1593,rdbSaveBackground,,,53,"int rdbSaveBackground (int,char*,rdbSaveInfo*,int)"
258515,METHOD,rdb.c:<global>,TYPE_DECL,"void rdbRemoveTempFile(pid_t childpid, int from_signal) {
    char tmpfile[256];
    char pid[32];

    /* Generate temp rdb file name using async-signal safe functions. */
    ll2string(pid, sizeof(pid), childpid);
    redis_strlcpy(tmpfile, ""temp-"", sizeof(tmpfile));
    redis_strlcat(tmpfile, pid, sizeof(tmpfile));
    redis_strlcat(tmpfile, "".rdb"", sizeof(tmpfile));

    if (from_signal) {
        /* bg_unlink is not async-signal-safe, but in this case we don't really
         * need to close the fd, it'll be released when the process exists. */
        int fd = open(tmpfile, O_RDONLY|O_NONBLOCK);
        UNUSED(fd);
        unlink(tmpfile);
    } else {
        bg_unlink(tmpfile);
    }
}",1,8,rdb.c,rdbRemoveTempFile,,false,1599,1618,rdbRemoveTempFile,,,54,"void rdbRemoveTempFile (pid_t,int)"
258566,METHOD,rdb.c:<global>,TYPE_DECL,"robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename) {
    uint64_t opcode;
    while((opcode = rdbLoadLen(rdb,NULL)) != RDB_MODULE_OPCODE_EOF) {
        if (opcode == RDB_MODULE_OPCODE_SINT ||
            opcode == RDB_MODULE_OPCODE_UINT)
        {
            uint64_t len;
            if (rdbLoadLenByRef(rdb,NULL,&len) == -1) {
                rdbReportCorruptRDB(
                    ""Error reading integer from module %s value"", modulename);
            }
        } else if (opcode == RDB_MODULE_OPCODE_STRING) {
            robj *o = rdbGenericLoadStringObject(rdb,RDB_LOAD_NONE,NULL);
            if (o == NULL) {
                rdbReportCorruptRDB(
                    ""Error reading string from module %s value"", modulename);
            }
            decrRefCount(o);
        } else if (opcode == RDB_MODULE_OPCODE_FLOAT) {
            float val;
            if (rdbLoadBinaryFloatValue(rdb,&val) == -1) {
                rdbReportCorruptRDB(
                    ""Error reading fl...",1,45,rdb.c,rdbLoadCheckModuleValue,,false,1624,1657,rdbLoadCheckModuleValue,,,55,"robj rdbLoadCheckModuleValue (rio*,char*)"
258703,METHOD,rdb.c:<global>,TYPE_DECL,"static int _ziplistPairsEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    unsigned char *str;
    unsigned int slen;
    long long vll;

    struct {
        long count;
        dict *fields;
        unsigned char **lp;
    } *data = userdata;

    if (data->fields == NULL) {
        data->fields = dictCreate(&hashDictType);
        dictExpand(data->fields, head_count/2);
    }

    if (!ziplistGet(p, &str, &slen, &vll))
        return 0;

    /* Even records are field names, add to dict and check that's not a dup */
    if (((data->count) & 1) == 0) {
        sds field = str? sdsnewlen(str, slen): sdsfromlonglong(vll);
        if (dictAdd(data->fields, field, NULL) != DICT_OK) {
            /* Duplicate, return an error */
            sdsfree(field);
            return 0;
        }
    }

    if (str) {
        *(data->lp) = lpAppend(*(data->lp), (unsigned char*)str, slen);
    } else {
        *(data->lp) = lpAppendInteger(*(data->lp), vll);
...",1,50,rdb.c,_ziplistPairsEntryConvertAndValidate,,false,1662,1699,_ziplistPairsEntryConvertAndValidate,,,56,"int _ziplistPairsEntryConvertAndValidate (unsigned char*,unsigned int,void*)"
258822,METHOD,rdb.c:<global>,TYPE_DECL,"int ziplistPairsConvertAndValidateIntegrity(unsigned char *zl, size_t size, unsigned char **lp) {
    /* Keep track of the field names to locate duplicate ones */
    struct {
        long count;
        dict *fields; /* Initialisation at the first callback. */
        unsigned char **lp;
    } data = {0, NULL, lp};

    int ret = ziplistValidateIntegrity(zl, size, 1, _ziplistPairsEntryConvertAndValidate, &data);

    /* make sure we have an even number of records. */
    if (data.count & 1)
        ret = 0;

    if (data.fields) dictRelease(data.fields);
    return ret;
}",1,1,rdb.c,ziplistPairsConvertAndValidateIntegrity,,false,1705,1721,ziplistPairsConvertAndValidateIntegrity,,,57,"int ziplistPairsConvertAndValidateIntegrity (unsigned char*,size_t,unsigned char**)"
258867,METHOD,rdb.c:<global>,TYPE_DECL,"static int _ziplistEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    UNUSED(head_count);
    unsigned char *str;
    unsigned int slen;
    long long vll;
    unsigned char **lp = (unsigned char**)userdata;

    if (!ziplistGet(p, &str, &slen, &vll)) return 0;

    if (str)
        *lp = lpAppend(*lp, (unsigned char*)str, slen);
    else
        *lp = lpAppendInteger(*lp, vll);

    return 1;
}",1,4,rdb.c,_ziplistEntryConvertAndValidate,,false,1725,1740,_ziplistEntryConvertAndValidate,,,58,"int _ziplistEntryConvertAndValidate (unsigned char*,unsigned int,void*)"
258926,METHOD,rdb.c:<global>,TYPE_DECL,"static int _listZiplistEntryConvertAndValidate(unsigned char *p, unsigned int head_count, void *userdata) {
    UNUSED(head_count);
    unsigned char *str;
    unsigned int slen;
    long long vll;
    char longstr[32] = {0};
    quicklist *ql = (quicklist*)userdata;

    if (!ziplistGet(p, &str, &slen, &vll)) return 0;
    if (!str) {
        /* Write the longval as a string so we can re-add it */
        slen = ll2string(longstr, sizeof(longstr), vll);
        str = (unsigned char *)longstr;
    }
    quicklistPushTail(ql, str, slen);
    return 1;
}",1,4,rdb.c,_listZiplistEntryConvertAndValidate,,false,1744,1760,_listZiplistEntryConvertAndValidate,,,59,"int _listZiplistEntryConvertAndValidate (unsigned char*,unsigned int,void*)"
258988,METHOD,rdb.c:<global>,TYPE_DECL,"static int _lpEntryValidation(unsigned char *p, unsigned int head_count, void *userdata) {
    struct {
        int pairs;
        long count;
        dict *fields;
    } *data = userdata;

    if (data->fields == NULL) {
        data->fields = dictCreate(&hashDictType);
        dictExpand(data->fields, data->pairs ? head_count/2 : head_count);
    }

    /* If we're checking pairs, then even records are field names. Otherwise
     * we're checking all elements. Add to dict and check that's not a dup */
    if (!data->pairs || ((data->count) & 1) == 0) {
        unsigned char *str;
        int64_t slen;
        unsigned char buf[LP_INTBUF_SIZE];

        str = lpGet(p, &slen, buf);
        sds field = sdsnewlen(str, slen);
        if (dictAdd(data->fields, field, NULL) != DICT_OK) {
            /* Duplicate, return an error */
            sdsfree(field);
            return 0;
        }
    }

    (data->count)++;
    return 1;
}",1,26,rdb.c,_lpEntryValidation,,false,1763,1793,_lpEntryValidation,,,60,"int _lpEntryValidation (unsigned char*,unsigned int,void*)"
259077,METHOD,rdb.c:<global>,TYPE_DECL,"int lpValidateIntegrityAndDups(unsigned char *lp, size_t size, int deep, int pairs) {
    if (!deep)
        return lpValidateIntegrity(lp, size, 0, NULL, NULL);

    /* Keep track of the field names to locate duplicate ones */
    struct {
        int pairs;
        long count;
        dict *fields; /* Initialisation at the first callback. */
    } data = {pairs, 0, NULL};

    int ret = lpValidateIntegrity(lp, size, 1, _lpEntryValidation, &data);

    /* make sure we have an even number of records. */
    if (pairs && data.count & 1)
        ret = 0;

    if (data.fields) dictRelease(data.fields);
    return ret;
}",1,1,rdb.c,lpValidateIntegrityAndDups,,false,1800,1819,lpValidateIntegrityAndDups,,,61,"int lpValidateIntegrityAndDups (unsigned char*,size_t,int,int)"
259136,METHOD,rdb.c:<global>,TYPE_DECL,"robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error) {
    robj *o = NULL, *ele, *dec;
    uint64_t len;
    unsigned int i;

    /* Set default error of load object, it will be set to 0 on success. */
    if (error) *error = RDB_LOAD_ERR_OTHER;

    int deep_integrity_validation = server.sanitize_dump_payload == SANITIZE_DUMP_YES;
    if (server.sanitize_dump_payload == SANITIZE_DUMP_CLIENTS) {
        /* Skip sanitization when loading (an RDB), or getting a RESTORE command
         * from either the master or a client using an ACL user with the skip-sanitize-payload flag. */
        int skip = server.loading ||
            (server.current_client && (server.current_client->flags & CLIENT_MASTER));
        if (!skip && server.current_client && server.current_client->user)
            skip = !!(server.current_client->user->flags & USER_FLAG_SANITIZE_PAYLOAD_SKIP);
        deep_integrity_validation = !skip;
    }

    if (rdbtype == RDB_TYPE_STRING) {
        /* R...",1,24,rdb.c,rdbLoadObject,,false,1825,2854,rdbLoadObject,,,62,"robj rdbLoadObject (int,rio*,sds,int,int*)"
262680,METHOD,rdb.c:<global>,TYPE_DECL,"void startLoading(size_t size, int rdbflags, int async) {
    /* Load the DB */
    server.loading = 1;
    if (async == 1) server.async_loading = 1;
    server.loading_start_time = time(NULL);
    server.loading_loaded_bytes = 0;
    server.loading_total_bytes = size;
    server.loading_rdb_used_mem = 0;
    server.rdb_last_load_keys_expired = 0;
    server.rdb_last_load_keys_loaded = 0;
    blockingOperationStarts();

    /* Fire the loading modules start event. */
    int subevent;
    if (rdbflags & RDBFLAGS_AOF_PREAMBLE)
        subevent = REDISMODULE_SUBEVENT_LOADING_AOF_START;
    else if(rdbflags & RDBFLAGS_REPLICATION)
        subevent = REDISMODULE_SUBEVENT_LOADING_REPL_START;
    else
        subevent = REDISMODULE_SUBEVENT_LOADING_RDB_START;
    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,subevent,NULL);
}",1,19,rdb.c,startLoading,,false,2858,2879,startLoading,,,63,"void startLoading (size_t,int,int)"
262778,METHOD,rdb.c:<global>,TYPE_DECL,"void startLoadingFile(size_t size, char* filename, int rdbflags) {
    rdbFileBeingLoaded = filename;
    startLoading(size, rdbflags, 0);
}",1,1,rdb.c,startLoadingFile,,false,2884,2887,startLoadingFile,,,64,"void startLoadingFile (size_t,char*,int)"
262792,METHOD,rdb.c:<global>,TYPE_DECL,"void loadingAbsProgress(off_t pos) {
    server.loading_loaded_bytes = pos;
    if (server.stat_peak_memory < zmalloc_used_memory())
        server.stat_peak_memory = zmalloc_used_memory();
}",1,1,rdb.c,loadingAbsProgress,,false,2890,2894,loadingAbsProgress,,,65,void loadingAbsProgress (off_t)
262814,METHOD,rdb.c:<global>,TYPE_DECL,"void loadingIncrProgress(off_t size) {
    server.loading_loaded_bytes += size;
    if (server.stat_peak_memory < zmalloc_used_memory())
        server.stat_peak_memory = zmalloc_used_memory();
}",1,1,rdb.c,loadingIncrProgress,,false,2897,2901,loadingIncrProgress,,,66,void loadingIncrProgress (off_t)
262836,METHOD,rdb.c:<global>,TYPE_DECL,"void updateLoadingFileName(char* filename) {
    rdbFileBeingLoaded = filename;
}",1,1,rdb.c,updateLoadingFileName,,false,2904,2906,updateLoadingFileName,,,67,void updateLoadingFileName (char*)
262844,METHOD,rdb.c:<global>,TYPE_DECL,"void stopLoading(int success) {
    server.loading = 0;
    server.async_loading = 0;
    blockingOperationEnds();
    rdbFileBeingLoaded = NULL;

    /* Fire the loading modules end event. */
    moduleFireServerEvent(REDISMODULE_EVENT_LOADING,
                          success?
                            REDISMODULE_SUBEVENT_LOADING_ENDED:
                            REDISMODULE_SUBEVENT_LOADING_FAILED,
                           NULL);
}",1,26,rdb.c,stopLoading,,false,2909,2921,stopLoading,,,68,void stopLoading (int)
262876,METHOD,rdb.c:<global>,TYPE_DECL,"void startSaving(int rdbflags) {
    /* Fire the persistence modules start event. */
    int subevent;
    if (rdbflags & RDBFLAGS_AOF_PREAMBLE && getpid() != server.pid)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;
    else if (rdbflags & RDBFLAGS_AOF_PREAMBLE)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START;
    else if (getpid()!=server.pid)
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;
    else
        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;
    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,NULL);
}",1,19,rdb.c,startSaving,,false,2923,2935,startSaving,,,69,void startSaving (int)
262945,METHOD,rdb.c:<global>,TYPE_DECL,"void stopSaving(int success) {
    /* Fire the persistence modules end event. */
    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,
                          success?
                            REDISMODULE_SUBEVENT_PERSISTENCE_ENDED:
                            REDISMODULE_SUBEVENT_PERSISTENCE_FAILED,
                          NULL);
}",1,26,rdb.c,stopSaving,,false,2937,2944,stopSaving,,,70,void stopSaving (int)
262963,METHOD,rdb.c:<global>,TYPE_DECL,"void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {
    if (server.rdb_checksum)
        rioGenericUpdateChecksum(r, buf, len);
    if (server.loading_process_events_interval_bytes &&
        (r->processed_bytes + len)/server.loading_process_events_interval_bytes > r->processed_bytes/server.loading_process_events_interval_bytes)
    {
        if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER)
            replicationSendNewlineToMaster();
        loadingAbsProgress(r->processed_bytes);
        processEventsWhileBlocked();
        processModuleLoadingProgressEvent(0);
    }
    if (server.repl_state == REPL_STATE_TRANSFER && rioCheckType(r) == RIO_TYPE_CONN) {
        atomicIncr(server.stat_net_repl_input_bytes, len);
    }
}",1,71,rdb.c,rdbLoadProgressCallback,,false,2948,2963,rdbLoadProgressCallback,,,71,"void rdbLoadProgressCallback (rio*,void*,size_t)"
263042,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbFunctionLoad(rio *rdb, int ver, functionsLibCtx* lib_ctx, int rdbflags, sds *err) {
    UNUSED(ver);
    sds error = NULL;
    sds final_payload = NULL;
    int res = C_ERR;
    if (!(final_payload = rdbGenericLoadStringObject(rdb, RDB_LOAD_SDS, NULL))) {
        error = sdsnew(""Failed loading library payload"");
        goto done;
    }

    if (lib_ctx) {
        sds library_name = NULL;
        if (!(library_name = functionsCreateWithLibraryCtx(final_payload, rdbflags & RDBFLAGS_ALLOW_DUP, &error, lib_ctx))) {
            if (!error) {
                error = sdsnew(""Failed creating the library"");
            }
            goto done;
        }
        sdsfree(library_name);
    }

    res = C_OK;

done:
    if (final_payload) sdsfree(final_payload);
    if (error) {
        if (err) {
            *err = error;
        } else {
            serverLog(LL_WARNING, ""Failed creating function, %s"", error);
            sdsfree(error);
        }
    }
    return res;
}",1,4,rdb.c,rdbFunctionLoad,,false,2972,3006,rdbFunctionLoad,,,72,"int rdbFunctionLoad (rio*,int,functionsLibCtx*,int,sds*)"
263171,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi) {
    functionsLibCtx* functions_lib_ctx = functionsLibCtxGetCurrent();
    rdbLoadingCtx loading_ctx = { .dbarray = server.db, .functions_lib_ctx = functions_lib_ctx };
    int retval = rdbLoadRioWithLoadingCtx(rdb,rdbflags,rsi,&loading_ctx);
    return retval;
}",1,1,rdb.c,rdbLoadRio,,false,3010,3015,rdbLoadRio,,,73,"int rdbLoadRio (rio*,int,rdbSaveInfo*)"
263207,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoadRioWithLoadingCtx(rio *rdb, int rdbflags, rdbSaveInfo *rsi, rdbLoadingCtx *rdb_loading_ctx) {
    uint64_t dbid = 0;
    int type, rdbver;
    redisDb *db = rdb_loading_ctx->dbarray+0;
    char buf[1024];
    int error;
    long long empty_keys_skipped = 0;

    rdb->update_cksum = rdbLoadProgressCallback;
    rdb->max_processing_chunk = server.loading_process_events_interval_bytes;
    if (rioRead(rdb,buf,9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf,""REDIS"",5) != 0) {
        serverLog(LL_WARNING,""Wrong signature trying to load DB from file"");
        return C_ERR;
    }
    rdbver = atoi(buf+5);
    if (rdbver < 1 || rdbver > RDB_VERSION) {
        serverLog(LL_WARNING,""Can't handle RDB format version %d"",rdbver);
        return C_ERR;
    }

    /* Key-specific attributes, set by opcodes before the key type. */
    long long lru_idle = -1, lfu_freq = -1, expiretime = -1, now = mstime();
    long long lru_clock = LRU_CLOCK();

    while(1) {
        sds k...",1,8,rdb.c,rdbLoadRioWithLoadingCtx,,false,3023,3367,rdbLoadRioWithLoadingCtx,,,74,"int rdbLoadRioWithLoadingCtx (rio*,int,rdbSaveInfo*,rdbLoadingCtx*)"
264874,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags) {
    FILE *fp;
    rio rdb;
    int retval;
    struct stat sb;
    int rdb_fd;

    fp = fopen(filename, ""r"");
    if (fp == NULL) {
        if (errno == ENOENT) return RDB_NOT_EXIST;

        serverLog(LL_WARNING,""Fatal error: can't open the RDB file %s for reading: %s"", filename, strerror(errno));
        return RDB_FAILED;
    }

    if (fstat(fileno(fp), &sb) == -1)
        sb.st_size = 0;

    startLoadingFile(sb.st_size, filename, rdbflags);
    rioInitWithFile(&rdb,fp);

    retval = rdbLoadRio(&rdb,rdbflags,rsi);

    fclose(fp);
    stopLoading(retval==C_OK);
    /* Reclaim the cache backed by rdb */
    if (retval == C_OK && !(rdbflags & RDBFLAGS_KEEP_CACHE)) {
        /* TODO: maybe we could combine the fopen and open into one in the future */
        rdb_fd = open(filename, O_RDONLY);
        if (rdb_fd > 0) bioCreateCloseJob(rdb_fd, 0, 1);
    }
    return (retval==C_OK) ? RDB_OK : RDB_FAILED;
}",1,36,rdb.c,rdbLoad,,false,3376,3408,rdbLoad,,,75,"int rdbLoad (char*,rdbSaveInfo*,int)"
265013,METHOD,rdb.c:<global>,TYPE_DECL,"static void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        serverLog(LL_NOTICE,
            ""Background saving terminated with success"");
        server.dirty = server.dirty - server.dirty_before_bgsave;
        server.lastsave = time(NULL);
        server.lastbgsave_status = C_OK;
    } else if (!bysignal && exitcode != 0) {
        serverLog(LL_WARNING, ""Background saving error"");
        server.lastbgsave_status = C_ERR;
    } else {
        mstime_t latency;

        serverLog(LL_WARNING,
            ""Background saving terminated by signal %d"", bysignal);
        latencyStartMonitor(latency);
        rdbRemoveTempFile(server.child_pid, 0);
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded(""rdb-unlink-temp-file"",latency);
        /* SIGUSR1 is whitelisted, so we have a way to kill a child without
         * triggering an error condition. */
        if (bysignal != SIGUSR1)
            server.lastbgsave_...",1,8,rdb.c,backgroundSaveDoneHandlerDisk,,false,3412,3436,backgroundSaveDoneHandlerDisk,,,76,"void backgroundSaveDoneHandlerDisk (int,int)"
265192,METHOD,rdb.c:<global>,TYPE_DECL,"static void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {
    if (!bysignal && exitcode == 0) {
        serverLog(LL_NOTICE,
            ""Background RDB transfer terminated with success"");
    } else if (!bysignal && exitcode != 0) {
        serverLog(LL_WARNING, ""Background transfer error"");
    } else {
        serverLog(LL_WARNING,
            ""Background transfer terminated by signal %d"", bysignal);
    }
    if (server.rdb_child_exit_pipe!=-1)
        close(server.rdb_child_exit_pipe);
    aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);
    close(server.rdb_pipe_read);
    server.rdb_child_exit_pipe = -1;
    server.rdb_pipe_read = -1;
    zfree(server.rdb_pipe_conns);
    server.rdb_pipe_conns = NULL;
    server.rdb_pipe_numconns = 0;
    server.rdb_pipe_numconns_writing = 0;
    zfree(server.rdb_pipe_buff);
    server.rdb_pipe_buff = NULL;
    server.rdb_pipe_bufflen = 0;
}",1,8,rdb.c,backgroundSaveDoneHandlerSocket,,false,3441,3464,backgroundSaveDoneHandlerSocket,,,77,"void backgroundSaveDoneHandlerSocket (int,int)"
265344,METHOD,rdb.c:<global>,TYPE_DECL,"void backgroundSaveDoneHandler(int exitcode, int bysignal) {
    int type = server.rdb_child_type;
    switch(server.rdb_child_type) {
    case RDB_CHILD_TYPE_DISK:
        backgroundSaveDoneHandlerDisk(exitcode,bysignal);
        break;
    case RDB_CHILD_TYPE_SOCKET:
        backgroundSaveDoneHandlerSocket(exitcode,bysignal);
        break;
    default:
        serverPanic(""Unknown RDB child type."");
        break;
    }

    server.rdb_child_type = RDB_CHILD_TYPE_NONE;
    server.rdb_save_time_last = time(NULL)-server.rdb_save_time_start;
    server.rdb_save_time_start = -1;
    /* Possibly there are slaves waiting for a BGSAVE in order to be served
     * (the first stage of SYNC is a bulk transfer of dump.rdb) */
    updateSlavesWaitingBgsave((!bysignal && exitcode == 0) ? C_OK : C_ERR, type);
}",1,9,rdb.c,backgroundSaveDoneHandler,,false,3467,3487,backgroundSaveDoneHandler,,,78,"void backgroundSaveDoneHandler (int,int)"
265426,METHOD,rdb.c:<global>,TYPE_DECL,"void killRDBChild(void) {
    kill(server.child_pid, SIGUSR1);
    /* Because we are not using here waitpid (like we have in killAppendOnlyChild
     * and TerminateModuleForkChild), all the cleanup operations is done by
     * checkChildrenDone, that later will find that the process killed.
     * This includes:
     * - resetChildState
     * - rdbRemoveTempFile */
}",1,1,rdb.c,killRDBChild,,false,3492,3500,killRDBChild,,,79,void killRDBChild (void)
265436,METHOD,rdb.c:<global>,TYPE_DECL,"int rdbSaveToSlavesSockets(int req, rdbSaveInfo *rsi) {
    listNode *ln;
    listIter li;
    pid_t childpid;
    int pipefds[2], rdb_pipe_write, safe_to_exit_pipe;

    if (hasActiveChildProcess()) return C_ERR;

    /* Even if the previous fork child exited, don't start a new one until we
     * drained the pipe. */
    if (server.rdb_pipe_conns) return C_ERR;

    /* Before to fork, create a pipe that is used to transfer the rdb bytes to
     * the parent, we can't let it write directly to the sockets, since in case
     * of TLS we must let the parent handle a continuous TLS state when the
     * child terminates and parent takes over. */
    if (anetPipe(pipefds, O_NONBLOCK, 0) == -1) return C_ERR;
    server.rdb_pipe_read = pipefds[0]; /* read end */
    rdb_pipe_write = pipefds[1]; /* write end */

    /* create another pipe that is used by the parent to signal to the child
     * that it can exit. */
    if (anetPipe(pipefds, 0, 0) == -1) {
        close(rdb_pipe_write);
  ...",1,40,rdb.c,rdbSaveToSlavesSockets,,false,3504,3619,rdbSaveToSlavesSockets,,,80,"int rdbSaveToSlavesSockets (int,rdbSaveInfo*)"
265869,METHOD,rdb.c:<global>,TYPE_DECL,"void saveCommand(client *c) {
    if (server.child_type == CHILD_TYPE_RDB) {
        addReplyError(c,""Background save already in progress"");
        return;
    }

    server.stat_rdb_saves++;

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);
    if (rdbSave(SLAVE_REQ_NONE,server.rdb_filename,rsiptr,RDBFLAGS_NONE) == C_OK) {
        addReply(c,shared.ok);
    } else {
        addReplyErrorObject(c,shared.err);
    }
}",1,29,rdb.c,saveCommand,,false,3621,3636,saveCommand,,,81,void saveCommand (client*)
265927,METHOD,rdb.c:<global>,TYPE_DECL,"void bgsaveCommand(client *c) {
    int schedule = 0;

    /* The SCHEDULE option changes the behavior of BGSAVE when an AOF rewrite
     * is in progress. Instead of returning an error a BGSAVE gets scheduled. */
    if (c->argc > 1) {
        if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""schedule"")) {
            schedule = 1;
        } else {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        }
    }

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);

    if (server.child_type == CHILD_TYPE_RDB) {
        addReplyError(c,""Background save already in progress"");
    } else if (hasActiveChildProcess() || server.in_exec) {
        if (schedule || server.in_exec) {
            server.rdb_bgsave_scheduled = 1;
            addReplyStatus(c,""Background saving scheduled"");
        } else {
            addReplyError(c,
            ""Another child process is active (AOF?): can't BGSAVE right now. ""
            ""Use BGSAVE SCHEDULE in order...",1,29,rdb.c,bgsaveCommand,,false,3639,3673,bgsaveCommand,,,82,void bgsaveCommand (client*)
266049,METHOD,rdb.c:<global>,TYPE_DECL,"rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi) {
    rdbSaveInfo rsi_init = RDB_SAVE_INFO_INIT;
    *rsi = rsi_init;

    /* If the instance is a master, we can populate the replication info
     * only when repl_backlog is not NULL. If the repl_backlog is NULL,
     * it means that the instance isn't in any replication chains. In this
     * scenario the replication info is useless, because when a slave
     * connects to us, the NULL repl_backlog will trigger a full
     * synchronization, at the same time we will use a new replid and clear
     * replid2. */
    if (!server.masterhost && server.repl_backlog) {
        /* Note that when server.slaveseldb is -1, it means that this master
         * didn't apply any write commands after a full synchronization.
         * So we can let repl_stream_db be 0, this allows a restarted slave
         * to reload replication ID/offset, it's safe because the next write
         * command must generate a SELECT statement. */
        rsi->...",1,27,rdb.c,rdbPopulateSaveInfo,,false,3684,3722,rdbPopulateSaveInfo,,,83,rdbSaveInfo rdbPopulateSaveInfo (rdbSaveInfo*)
266142,METHOD,rdb.h:<global>,TYPE_DECL,<global>,1,19,rdb.h,rdb.h:<global>,,false,1,184,<global>,,,1,
266144,METHOD,rdb.h:<global>,TYPE_DECL,"ssize_t rdbWriteRaw(rio *rdb, void *p, size_t len);",9,50,rdb.h,rdbWriteRaw,,false,145,145,rdbWriteRaw,,,1,"ssize_t rdbWriteRaw (rio*,void*,size_t)"
266151,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveType(rio *rdb, unsigned char type);",5,45,rdb.h,rdbSaveType,,false,146,146,rdbSaveType,,,2,"int rdbSaveType (rio*,unsigned char)"
266157,METHOD,rdb.h:<global>,TYPE_DECL,int rdbLoadType(rio *rdb);,5,25,rdb.h,rdbLoadType,,false,147,147,rdbLoadType,,,3,int rdbLoadType (rio*)
266162,METHOD,rdb.h:<global>,TYPE_DECL,time_t rdbLoadTime(rio *rdb);,8,28,rdb.h,rdbLoadTime,,false,148,148,rdbLoadTime,,,4,time_t rdbLoadTime (rio*)
266167,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveLen(rio *rdb, uint64_t len);",5,38,rdb.h,rdbSaveLen,,false,149,149,rdbSaveLen,,,5,"int rdbSaveLen (rio*,uint64_t)"
266173,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveMillisecondTime(rio *rdb, long long t);",5,49,rdb.h,rdbSaveMillisecondTime,,false,150,150,rdbSaveMillisecondTime,,,6,"int rdbSaveMillisecondTime (rio*,long long)"
266179,METHOD,rdb.h:<global>,TYPE_DECL,"long long rdbLoadMillisecondTime(rio *rdb, int rdbver);",11,54,rdb.h,rdbLoadMillisecondTime,,false,151,151,rdbLoadMillisecondTime,,,7,"long long rdbLoadMillisecondTime (rio*,int)"
266185,METHOD,rdb.h:<global>,TYPE_DECL,"uint64_t rdbLoadLen(rio *rdb, int *isencoded);",10,45,rdb.h,rdbLoadLen,,false,152,152,rdbLoadLen,,,8,"uint64_t rdbLoadLen (rio*,int*)"
266191,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbLoadLenByRef(rio *rdb, int *isencoded, uint64_t *lenptr);",5,63,rdb.h,rdbLoadLenByRef,,false,153,153,rdbLoadLenByRef,,,9,"int rdbLoadLenByRef (rio*,int*,uint64_t*)"
266198,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveObjectType(rio *rdb, robj *o);",5,40,rdb.h,rdbSaveObjectType,,false,154,154,rdbSaveObjectType,,,10,"int rdbSaveObjectType (rio*,robj*)"
266204,METHOD,rdb.h:<global>,TYPE_DECL,int rdbLoadObjectType(rio *rdb);,5,31,rdb.h,rdbLoadObjectType,,false,155,155,rdbLoadObjectType,,,11,int rdbLoadObjectType (rio*)
266209,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbLoad(char *filename, rdbSaveInfo *rsi, int rdbflags);",5,59,rdb.h,rdbLoad,,false,156,156,rdbLoad,,,12,"int rdbLoad (char*,rdbSaveInfo*,int)"
266216,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveBackground(int req, char *filename, rdbSaveInfo *rsi, int rdbflags);",5,78,rdb.h,rdbSaveBackground,,false,157,157,rdbSaveBackground,,,13,"int rdbSaveBackground (int,char*,rdbSaveInfo*,int)"
266224,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveToSlavesSockets(int req, rdbSaveInfo *rsi);",5,53,rdb.h,rdbSaveToSlavesSockets,,false,158,158,rdbSaveToSlavesSockets,,,14,"int rdbSaveToSlavesSockets (int,rdbSaveInfo*)"
266230,METHOD,rdb.h:<global>,TYPE_DECL,"void rdbRemoveTempFile(pid_t childpid, int from_signal);",6,55,rdb.h,rdbRemoveTempFile,,false,159,159,rdbRemoveTempFile,,,15,"void rdbRemoveTempFile (pid_t,int)"
266236,METHOD,rdb.h:<global>,TYPE_DECL,int rdbSaveToFile(const char *filename);,5,39,rdb.h,rdbSaveToFile,,false,160,160,rdbSaveToFile,,,16,int rdbSaveToFile (char*)
266241,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSave(int req, char *filename, rdbSaveInfo *rsi, int rdbflags);",5,68,rdb.h,rdbSave,,false,161,161,rdbSave,,,17,"int rdbSave (int,char*,rdbSaveInfo*,int)"
266249,METHOD,rdb.h:<global>,TYPE_DECL,"ssize_t rdbSaveObject(rio *rdb, robj *o, robj *key, int dbid);",9,61,rdb.h,rdbSaveObject,,false,162,162,rdbSaveObject,,,18,"ssize_t rdbSaveObject (rio*,robj*,robj*,int)"
266257,METHOD,rdb.h:<global>,TYPE_DECL,"size_t rdbSavedObjectLen(robj *o, robj *key, int dbid);",8,54,rdb.h,rdbSavedObjectLen,,false,163,163,rdbSavedObjectLen,,,19,"size_t rdbSavedObjectLen (robj*,robj*,int)"
266264,METHOD,rdb.h:<global>,TYPE_DECL,"robj *rdbLoadObject(int rdbtype, rio *rdb, sds key, int dbid, int *error);",6,73,rdb.h,rdbLoadObject,,false,164,164,rdbLoadObject,,,20,"robj* rdbLoadObject (int,rio*,sds,int,int*)"
266273,METHOD,rdb.h:<global>,TYPE_DECL,"void backgroundSaveDoneHandler(int exitcode, int bysignal);",6,58,rdb.h,backgroundSaveDoneHandler,,false,165,165,backgroundSaveDoneHandler,,,21,"void backgroundSaveDoneHandler (int,int)"
266279,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime,int dbid);",5,86,rdb.h,rdbSaveKeyValuePair,,false,166,166,rdbSaveKeyValuePair,,,22,"int rdbSaveKeyValuePair (rio*,robj*,robj*,long long,int)"
266288,METHOD,rdb.h:<global>,TYPE_DECL,"ssize_t rdbSaveSingleModuleAux(rio *rdb, int when, moduleType *mt);",9,66,rdb.h,rdbSaveSingleModuleAux,,false,167,167,rdbSaveSingleModuleAux,,,23,"ssize_t rdbSaveSingleModuleAux (rio*,int,moduleType*)"
266295,METHOD,rdb.h:<global>,TYPE_DECL,"robj *rdbLoadCheckModuleValue(rio *rdb, char *modulename);",6,57,rdb.h,rdbLoadCheckModuleValue,,false,168,168,rdbLoadCheckModuleValue,,,24,"robj* rdbLoadCheckModuleValue (rio*,char*)"
266301,METHOD,rdb.h:<global>,TYPE_DECL,robj *rdbLoadStringObject(rio *rdb);,6,35,rdb.h,rdbLoadStringObject,,false,169,169,rdbLoadStringObject,,,25,robj* rdbLoadStringObject (rio*)
266306,METHOD,rdb.h:<global>,TYPE_DECL,"ssize_t rdbSaveStringObject(rio *rdb, robj *obj);",9,48,rdb.h,rdbSaveStringObject,,false,170,170,rdbSaveStringObject,,,26,"ssize_t rdbSaveStringObject (rio*,robj*)"
266312,METHOD,rdb.h:<global>,TYPE_DECL,"ssize_t rdbSaveRawString(rio *rdb, unsigned char *s, size_t len);",9,64,rdb.h,rdbSaveRawString,,false,171,171,rdbSaveRawString,,,27,"ssize_t rdbSaveRawString (rio*,unsigned char*,size_t)"
266319,METHOD,rdb.h:<global>,TYPE_DECL,"void *rdbGenericLoadStringObject(rio *rdb, int flags, size_t *lenptr);",6,69,rdb.h,rdbGenericLoadStringObject,,false,172,172,rdbGenericLoadStringObject,,,28,"void* rdbGenericLoadStringObject (rio*,int,size_t*)"
266326,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveBinaryDoubleValue(rio *rdb, double val);",5,50,rdb.h,rdbSaveBinaryDoubleValue,,false,173,173,rdbSaveBinaryDoubleValue,,,29,"int rdbSaveBinaryDoubleValue (rio*,double)"
266332,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbLoadBinaryDoubleValue(rio *rdb, double *val);",5,51,rdb.h,rdbLoadBinaryDoubleValue,,false,174,174,rdbLoadBinaryDoubleValue,,,30,"int rdbLoadBinaryDoubleValue (rio*,double*)"
266338,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveBinaryFloatValue(rio *rdb, float val);",5,48,rdb.h,rdbSaveBinaryFloatValue,,false,175,175,rdbSaveBinaryFloatValue,,,31,"int rdbSaveBinaryFloatValue (rio*,float)"
266344,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbLoadBinaryFloatValue(rio *rdb, float *val);",5,49,rdb.h,rdbLoadBinaryFloatValue,,false,176,176,rdbLoadBinaryFloatValue,,,32,"int rdbLoadBinaryFloatValue (rio*,float*)"
266350,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbLoadRio(rio *rdb, int rdbflags, rdbSaveInfo *rsi);",5,56,rdb.h,rdbLoadRio,,false,177,177,rdbLoadRio,,,33,"int rdbLoadRio (rio*,int,rdbSaveInfo*)"
266357,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbLoadRioWithLoadingCtx(rio *rdb, int rdbflags, rdbSaveInfo *rsi, rdbLoadingCtx *rdb_loading_ctx);",5,102,rdb.h,rdbLoadRioWithLoadingCtx,,false,178,178,rdbLoadRioWithLoadingCtx,,,34,"int rdbLoadRioWithLoadingCtx (rio*,int,rdbSaveInfo*,rdbLoadingCtx*)"
266365,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbFunctionLoad(rio *rdb, int ver, functionsLibCtx* lib_ctx, int rdbflags, sds *err);",5,88,rdb.h,rdbFunctionLoad,,false,179,179,rdbFunctionLoad,,,35,"int rdbFunctionLoad (rio*,int,functionsLibCtx*,int,sds*)"
266374,METHOD,rdb.h:<global>,TYPE_DECL,"int rdbSaveRio(int req, rio *rdb, int *error, int rdbflags, rdbSaveInfo *rsi);",5,77,rdb.h,rdbSaveRio,,false,180,180,rdbSaveRio,,,36,"int rdbSaveRio (int,rio*,int*,int,rdbSaveInfo*)"
266383,METHOD,rdb.h:<global>,TYPE_DECL,ssize_t rdbSaveFunctions(rio *rdb);,9,34,rdb.h,rdbSaveFunctions,,false,181,181,rdbSaveFunctions,,,37,ssize_t rdbSaveFunctions (rio*)
266388,METHOD,rdb.h:<global>,TYPE_DECL,rdbSaveInfo *rdbPopulateSaveInfo(rdbSaveInfo *rsi);,13,50,rdb.h,rdbPopulateSaveInfo,,false,182,182,rdbPopulateSaveInfo,,,38,rdbSaveInfo* rdbPopulateSaveInfo (rdbSaveInfo*)
266452,METHOD,redis-benchmark.c:<global>,TYPE_DECL,<global>,1,1,redis-benchmark.c,redis-benchmark.c:<global>,,false,1,2060,<global>,,,1,
266559,METHOD,redis-benchmark.c:<global>,TYPE_DECL,char *redisGitSHA1(void);,6,24,redis-benchmark.c,redisGitSHA1,,false,189,189,redisGitSHA1,,,14,char* redisGitSHA1 (void)
266564,METHOD,redis-benchmark.c:<global>,TYPE_DECL,char *redisGitDirty(void);,6,25,redis-benchmark.c,redisGitDirty,,false,190,190,redisGitDirty,,,15,char* redisGitDirty (void)
266569,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask);",13,75,redis-benchmark.c,writeHandler,,false,191,191,writeHandler,,,16,"void writeHandler (aeEventLoop*,int,void*,int)"
266577,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static void createMissingClients(client c);,13,42,redis-benchmark.c,createMissingClients,,false,192,192,createMissingClients,,,17,void createMissingClients (client)
266582,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static benchmarkThread *createBenchmarkThread(int index);,24,56,redis-benchmark.c,createBenchmarkThread,,false,193,193,createBenchmarkThread,,,18,benchmarkThread* createBenchmarkThread (int)
266587,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static void freeBenchmarkThread(benchmarkThread *thread);,13,56,redis-benchmark.c,freeBenchmarkThread,,false,194,194,freeBenchmarkThread,,,19,void freeBenchmarkThread (benchmarkThread*)
266592,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static void freeBenchmarkThreads(void);,13,38,redis-benchmark.c,freeBenchmarkThreads,,false,195,195,freeBenchmarkThreads,,,20,void freeBenchmarkThreads (void)
266597,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static void *execBenchmarkThread(void *ptr);,13,43,redis-benchmark.c,execBenchmarkThread,,false,196,196,execBenchmarkThread,,,21,void* execBenchmarkThread (void*)
266602,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static clusterNode *createClusterNode(char *ip, int port);",20,57,redis-benchmark.c,createClusterNode,,false,197,197,createClusterNode,,,22,"clusterNode* createClusterNode (char*,int)"
266608,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static redisConfig *getRedisConfig(const char *ip, int port,
                                   const char *hostsocket);",20,58,redis-benchmark.c,getRedisConfig,,false,198,199,getRedisConfig,,,23,"redisConfig* getRedisConfig (char*,int,char*)"
266615,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static redisContext *getRedisContext(const char *ip, int port,
                                     const char *hostsocket);",21,60,redis-benchmark.c,getRedisContext,,false,200,201,getRedisContext,,,24,"redisContext* getRedisContext (char*,int,char*)"
266622,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static void freeRedisConfig(redisConfig *cfg);,13,45,redis-benchmark.c,freeRedisConfig,,false,202,202,freeRedisConfig,,,25,void freeRedisConfig (redisConfig*)
266627,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static int fetchClusterSlotsConfiguration(client c);,12,51,redis-benchmark.c,fetchClusterSlotsConfiguration,,false,203,203,fetchClusterSlotsConfiguration,,,26,int fetchClusterSlotsConfiguration (client)
266632,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static void updateClusterSlotsConfiguration(void);,13,49,redis-benchmark.c,updateClusterSlotsConfiguration,,false,204,204,updateClusterSlotsConfiguration,,,27,void updateClusterSlotsConfiguration (void)
266637,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"int showThroughput(struct aeEventLoop *eventLoop, long long id,
                   void *clientData);",5,36,redis-benchmark.c,showThroughput,,false,205,206,showThroughput,,,28,"int showThroughput (aeEventLoop*,long long,void*)"
266644,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static sds benchmarkVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",1,45,redis-benchmark.c,benchmarkVersion,,false,208,220,benchmarkVersion,,,29,sds benchmarkVersion (void)
266688,METHOD,redis-benchmark.c:<global>,TYPE_DECL,static uint64_t dictSdsHash(const void *key);,17,44,redis-benchmark.c,dictSdsHash,,false,223,223,dictSdsHash,,,30,uint64_t dictSdsHash (void*)
266693,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static int dictSdsKeyCompare(dict *d, const void *key1, const void *key2);",12,73,redis-benchmark.c,dictSdsKeyCompare,,false,224,224,dictSdsKeyCompare,,,31,"int dictSdsKeyCompare (dict*,void*,void*)"
266700,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static long long ustime(void) {
    struct timeval tv;
    long long ust;

    gettimeofday(&tv, NULL);
    ust = ((long long)tv.tv_sec)*1000000;
    ust += tv.tv_usec;
    return ust;
}",1,1,redis-benchmark.c,ustime,,false,227,235,ustime,,,32,long long ustime (void)
266727,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static long long mstime(void) {
    return ustime()/1000;
}",1,1,redis-benchmark.c,mstime,,false,237,239,mstime,,,33,long long mstime (void)
266736,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static uint64_t dictSdsHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
}",1,1,redis-benchmark.c,dictSdsHash,,false,241,243,dictSdsHash,,,34,uint64_t dictSdsHash (void*)
266750,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static int dictSdsKeyCompare(dict *d, const void *key1, const void *key2)
{
    int l1,l2;
    UNUSED(d);

    l1 = sdslen((sds)key1);
    l2 = sdslen((sds)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",1,4,redis-benchmark.c,dictSdsKeyCompare,,false,245,254,dictSdsKeyCompare,,,35,"int dictSdsKeyCompare (dict*,void*,void*)"
266791,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static redisContext *getRedisContext(const char *ip, int port,
                                     const char *hostsocket)
{
    redisContext *ctx = NULL;
    redisReply *reply =  NULL;
    if (hostsocket == NULL)
        ctx = redisConnect(ip, port);
    else
        ctx = redisConnectUnix(hostsocket);
    if (ctx == NULL || ctx->err) {
        fprintf(stderr,""Could not connect to Redis at "");
        char *err = (ctx != NULL ? ctx->errstr : """");
        if (hostsocket == NULL)
            fprintf(stderr,""%s:%d: %s\n"",ip,port,err);
        else
            fprintf(stderr,""%s: %s\n"",hostsocket,err);
        goto cleanup;
    }
    if (config.tls==1) {
        const char *err = NULL;
        if (cliSecureConnection(ctx, config.sslconfig, &err) == REDIS_ERR && err) {
            fprintf(stderr, ""Could not negotiate a TLS connection: %s\n"", err);
            goto cleanup;
        }
    }
    if (config.conn_info.auth == NULL)
        return ctx;
    if (config.conn_info.user == NULL)
...",1,1,redis-benchmark.c,getRedisContext,,false,256,309,getRedisContext,,,36,"redisContext getRedisContext (char*,int,char*)"
267010,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static redisConfig *getRedisConfig(const char *ip, int port,
                                   const char *hostsocket)
{
    redisConfig *cfg = zcalloc(sizeof(*cfg));
    if (!cfg) return NULL;
    redisContext *c = NULL;
    redisReply *reply = NULL, *sub_reply = NULL;
    c = getRedisContext(ip, port, hostsocket);
    if (c == NULL) {
        freeRedisConfig(cfg);
        exit(1);
    }
    redisAppendCommand(c, ""CONFIG GET %s"", ""save"");
    redisAppendCommand(c, ""CONFIG GET %s"", ""appendonly"");
    int abort_test = 0;
    int i = 0;
    void *r = NULL;
    for (; i < 2; i++) {
        int res = redisGetReply(c, &r);
        if (reply) freeReplyObject(reply);
        reply = res == REDIS_OK ? ((redisReply *) r) : NULL;
        if (res != REDIS_OK || !r) goto fail;
        if (reply->type == REDIS_REPLY_ERROR) {
            goto fail;
        }
        if (reply->type != REDIS_REPLY_ARRAY || reply->elements < 2) goto fail;
        sub_reply = reply->element[1];
        char *value ...",1,1,redis-benchmark.c,getRedisConfig,,false,313,364,getRedisConfig,,,37,"redisConfig getRedisConfig (char*,int,char*)"
267241,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeRedisConfig(redisConfig *cfg) {
    if (cfg->save) sdsfree(cfg->save);
    if (cfg->appendonly) sdsfree(cfg->appendonly);
    zfree(cfg);
}",1,1,redis-benchmark.c,freeRedisConfig,,false,365,369,freeRedisConfig,,,38,void freeRedisConfig (redisConfig*)
267266,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeClient(client c) {
    aeEventLoop *el = CLIENT_GET_EVENTLOOP(c);
    listNode *ln;
    aeDeleteFileEvent(el,c->context->fd,AE_WRITABLE);
    aeDeleteFileEvent(el,c->context->fd,AE_READABLE);
    if (c->thread_id >= 0) {
        int requests_finished = 0;
        atomicGet(config.requests_finished, requests_finished);
        if (requests_finished >= config.requests) {
            aeStop(el);
        }
    }
    redisFree(c->context);
    sdsfree(c->obuf);
    zfree(c->randptr);
    zfree(c->stagptr);
    zfree(c);
    if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
    config.liveclients--;
    ln = listSearchKey(config.clients,c);
    assert(ln != NULL);
    listDelNode(config.clients,ln);
    if (config.num_threads) pthread_mutex_unlock(&(config.liveclients_mutex));
}",1,22,redis-benchmark.c,freeClient,,false,371,394,freeClient,,,39,void freeClient (client)
267399,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeAllClients(void) {
    listNode *ln = config.clients->head, *next;

    while(ln) {
        next = ln->next;
        freeClient(ln->value);
        ln = next;
    }
}",1,1,redis-benchmark.c,freeAllClients,,false,396,404,freeAllClients,,,40,void freeAllClients (void)
267428,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void resetClient(client c) {
    aeEventLoop *el = CLIENT_GET_EVENTLOOP(c);
    aeDeleteFileEvent(el,c->context->fd,AE_WRITABLE);
    aeDeleteFileEvent(el,c->context->fd,AE_READABLE);
    aeCreateFileEvent(el,c->context->fd,AE_WRITABLE,writeHandler,c);
    c->written = 0;
    c->pending = config.pipeline;
}",1,22,redis-benchmark.c,resetClient,,false,406,413,resetClient,,,41,void resetClient (client)
267501,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void randomizeClientKey(client c) {
    size_t i;

    for (i = 0; i < c->randlen; i++) {
        char *p = c->randptr[i]+11;
        size_t r = 0;
        if (config.randomkeys_keyspacelen != 0)
            r = random() % config.randomkeys_keyspacelen;
        size_t j;

        for (j = 0; j < 12; j++) {
            *p = '0'+r%10;
            r/=10;
            p--;
        }
    }
}",1,1,redis-benchmark.c,randomizeClientKey,,false,415,431,randomizeClientKey,,,42,void randomizeClientKey (client)
267573,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void setClusterKeyHashTag(client c) {
    assert(c->thread_id >= 0);
    clusterNode *node = c->cluster_node;
    assert(node);
    assert(node->current_slot_index < node->slots_count);
    int is_updating_slots = 0;
    atomicGet(config.is_updating_slots, is_updating_slots);
    /* If updateClusterSlotsConfiguration is updating the slots array,
     * call updateClusterSlotsConfiguration is order to block the thread
     * since the mutex is locked. When the slots will be updated by the
     * thread that's actually performing the update, the execution of
     * updateClusterSlotsConfiguration won't actually do anything, since
     * the updated_slots_count array will be already NULL. */
    if (is_updating_slots) updateClusterSlotsConfiguration();
    int slot = node->slots[node->current_slot_index];
    const char *tag = crc16_slot_table[slot];
    int taglen = strlen(tag);
    size_t i;
    for (i = 0; i < c->staglen; i++) {
        char *p = c->stagptr[i] + 1;
        p[...",1,1,redis-benchmark.c,setClusterKeyHashTag,,false,433,457,setClusterKeyHashTag,,,43,void setClusterKeyHashTag (client)
267689,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void clientDone(client c) {
    int requests_finished = 0;
    atomicGet(config.requests_finished, requests_finished);
    if (requests_finished >= config.requests) {
        freeClient(c);
        if (!config.num_threads && config.el) aeStop(config.el);
        return;
    }
    if (config.keepalive) {
        resetClient(c);
    } else {
        if (config.num_threads) pthread_mutex_lock(&(config.liveclients_mutex));
        config.liveclients--;
        createMissingClients(c);
        config.liveclients++;
        if (config.num_threads)
            pthread_mutex_unlock(&(config.liveclients_mutex));
        freeClient(c);
    }
}",1,1,redis-benchmark.c,clientDone,,false,459,478,clientDone,,,44,void clientDone (client)
267768,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    client c = privdata;
    void *reply = NULL;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);

    /* Calculate latency only for the first read event. This means that the
     * server already sent the reply and we need to parse it. Parsing overhead
     * is not part of the latency, so calculate it only once, here. */
    if (c->latency < 0) c->latency = ustime()-(c->start);

    if (redisBufferRead(c->context) != REDIS_OK) {
        fprintf(stderr,""Error: %s\n"",c->context->errstr);
        exit(1);
    } else {
        while(c->pending) {
            if (redisGetReply(c->context,&reply) != REDIS_OK) {
                fprintf(stderr,""Error: %s\n"",c->context->errstr);
                exit(1);
            }
            if (reply != NULL) {
                if (reply == (void*)REDIS_REPLY_ERROR) {
                    fprintf(stderr,""Unexpected error reply, exiting...\n"");
                    exit(1);
    ...",1,4,redis-benchmark.c,readHandler,,false,480,591,readHandler,,,45,"void readHandler (aeEventLoop*,int,void*,int)"
268221,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    client c = privdata;
    UNUSED(el);
    UNUSED(fd);
    UNUSED(mask);

    /* Initialize request when nothing was written. */
    if (c->written == 0) {
        /* Enforce upper bound to number of requests. */
        int requests_issued = 0;
        atomicGetIncr(config.requests_issued, requests_issued, config.pipeline);
        if (requests_issued >= config.requests) {
            return;
        }

        /* Really initialize: randomize keys and set start time. */
        if (config.randomkeys) randomizeClientKey(c);
        if (config.cluster_mode && c->staglen > 0) setClusterKeyHashTag(c);
        atomicGet(config.slots_last_update, c->slots_last_update);
        c->start = ustime();
        c->latency = -1;
    }
    const ssize_t buflen = sdslen(c->obuf);
    const ssize_t writeLen = buflen-c->written;
    if (writeLen > 0) {
        void *ptr = c->obuf+c->written;
        while(1) {
         ...",1,4,redis-benchmark.c,writeHandler,,false,593,640,writeHandler,,,46,"void writeHandler (aeEventLoop*,int,void*,int)"
268424,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static client createClient(char *cmd, size_t len, client from, int thread_id) {
    int j;
    int is_cluster_client = (config.cluster_mode && thread_id >= 0);
    client c = zmalloc(sizeof(struct _client));

    const char *ip = NULL;
    int port = 0;
    c->cluster_node = NULL;
    if (config.hostsocket == NULL || is_cluster_client) {
        if (!is_cluster_client) {
            ip = config.conn_info.hostip;
            port = config.conn_info.hostport;
        } else {
            int node_idx = 0;
            if (config.num_threads < config.cluster_node_count)
                node_idx = config.liveclients % config.cluster_node_count;
            else
                node_idx = thread_id % config.cluster_node_count;
            clusterNode *node = config.cluster_nodes[node_idx];
            assert(node != NULL);
            ip = (const char *) node->ip;
            port = node->port;
            c->cluster_node = node;
        }
        c->context = redisConnectNonBlock(ip,port...",1,26,redis-benchmark.c,createClient,,false,663,850,createClient,,,47,"client createClient (char*,size_t,client,int)"
269337,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void createMissingClients(client c) {
    int n = 0;
    while(config.liveclients < config.numclients) {
        int thread_id = -1;
        if (config.num_threads)
            thread_id = config.liveclients % config.num_threads;
        createClient(NULL,0,c,thread_id);

        /* Listen backlog is quite limited on most systems */
        if (++n > 64) {
            usleep(50000);
            n = 0;
        }
    }
}",1,1,redis-benchmark.c,createMissingClients,,false,852,866,createMissingClients,,,48,void createMissingClients (client)
269390,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void showLatencyReport(void) {

    const float reqpersec = (float)config.requests_finished/((float)config.totlatency/1000.0f);
    const float p0 = ((float) hdr_min(config.latency_histogram))/1000.0f;
    const float p50 = hdr_value_at_percentile(config.latency_histogram, 50.0 )/1000.0f;
    const float p95 = hdr_value_at_percentile(config.latency_histogram, 95.0 )/1000.0f;
    const float p99 = hdr_value_at_percentile(config.latency_histogram, 99.0 )/1000.0f;
    const float p100 = ((float) hdr_max(config.latency_histogram))/1000.0f;
    const float avg = hdr_mean(config.latency_histogram)/1000.0f;

    if (!config.quiet && !config.csv) {
        printf(""%*s\r"", config.last_printed_bytes, "" ""); // ensure there is a clean line
        printf(""====== %s ======\n"", config.title);
        printf(""  %d requests completed in %.2f seconds\n"", config.requests_finished,
            (float)config.totlatency/1000);
        printf(""  %d parallel clients\n"", config.numclients);
        ...",1,1,redis-benchmark.c,showLatencyReport,,false,868,959,showLatencyReport,,,49,void showLatencyReport (void)
269832,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void initBenchmarkThreads(void) {
    int i;
    if (config.threads) freeBenchmarkThreads();
    config.threads = zmalloc(config.num_threads * sizeof(benchmarkThread*));
    for (i = 0; i < config.num_threads; i++) {
        benchmarkThread *thread = createBenchmarkThread(i);
        config.threads[i] = thread;
    }
}",1,1,redis-benchmark.c,initBenchmarkThreads,,false,961,969,initBenchmarkThreads,,,50,void initBenchmarkThreads (void)
269880,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void startBenchmarkThreads(void) {
    int i;
    for (i = 0; i < config.num_threads; i++) {
        benchmarkThread *t = config.threads[i];
        if (pthread_create(&(t->thread), NULL, execBenchmarkThread, t)){
            fprintf(stderr, ""FATAL: Failed to start thread %d.\n"", i);
            exit(1);
        }
    }
    for (i = 0; i < config.num_threads; i++)
        pthread_join(config.threads[i]->thread, NULL);
}",1,1,redis-benchmark.c,startBenchmarkThreads,,false,971,982,startBenchmarkThreads,,,51,void startBenchmarkThreads (void)
269944,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void benchmark(const char *title, char *cmd, int len) {
    client c;

    config.title = title;
    config.requests_issued = 0;
    config.requests_finished = 0;
    config.previous_requests_finished = 0;
    config.last_printed_bytes = 0;
    hdr_init(
        CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,  // Minimum value
        CONFIG_LATENCY_HISTOGRAM_MAX_VALUE,  // Maximum value
        config.precision,  // Number of significant figures
        &config.latency_histogram);  // Pointer to initialise
    hdr_init(
        CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,  // Minimum value
        CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE,  // Maximum value
        config.precision,  // Number of significant figures
        &config.current_sec_latency_histogram);  // Pointer to initialise

    if (config.num_threads) initBenchmarkThreads();

    int thread_id = config.num_threads > 0 ? 0 : -1;
    c = createClient(cmd,len,NULL,thread_id);
    createMissingClients(c);

    config.start = mstime(...",1,8,redis-benchmark.c,benchmark,,false,984,1020,benchmark,,,52,"void benchmark (char*,char*,int)"
270085,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static benchmarkThread *createBenchmarkThread(int index) {
    benchmarkThread *thread = zmalloc(sizeof(*thread));
    if (thread == NULL) return NULL;
    thread->index = index;
    thread->el = aeCreateEventLoop(1024*10);
    aeCreateTimeEvent(thread->el,1,showThroughput,(void *)thread,NULL);
    return thread;
}",1,1,redis-benchmark.c,createBenchmarkThread,,false,1024,1031,createBenchmarkThread,,,53,benchmarkThread createBenchmarkThread (int)
270129,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeBenchmarkThread(benchmarkThread *thread) {
    if (thread->el) aeDeleteEventLoop(thread->el);
    zfree(thread);
}",1,1,redis-benchmark.c,freeBenchmarkThread,,false,1033,1036,freeBenchmarkThread,,,54,void freeBenchmarkThread (benchmarkThread*)
270145,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeBenchmarkThreads(void) {
    int i = 0;
    for (; i < config.num_threads; i++) {
        benchmarkThread *thread = config.threads[i];
        if (thread) freeBenchmarkThread(thread);
    }
    zfree(config.threads);
    config.threads = NULL;
}",1,1,redis-benchmark.c,freeBenchmarkThreads,,false,1038,1046,freeBenchmarkThreads,,,55,void freeBenchmarkThreads (void)
270186,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void *execBenchmarkThread(void *ptr) {
    benchmarkThread *thread = (benchmarkThread *) ptr;
    aeMain(thread->el);
    return NULL;
}",1,1,redis-benchmark.c,execBenchmarkThread,,false,1048,1052,execBenchmarkThread,,,56,void* execBenchmarkThread (void*)
270203,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static clusterNode *createClusterNode(char *ip, int port) {
    clusterNode *node = zmalloc(sizeof(*node));
    if (!node) return NULL;
    node->ip = ip;
    node->port = port;
    node->name = NULL;
    node->flags = 0;
    node->replicate = NULL;
    node->replicas_count = 0;
    node->slots = zmalloc(CLUSTER_SLOTS * sizeof(int));
    node->slots_count = 0;
    node->current_slot_index = 0;
    node->updated_slots = NULL;
    node->updated_slots_count = 0;
    node->migrating = NULL;
    node->importing = NULL;
    node->migrating_count = 0;
    node->importing_count = 0;
    node->redis_config = NULL;
    return node;
}",1,26,redis-benchmark.c,createClusterNode,,false,1056,1076,createClusterNode,,,57,"clusterNode createClusterNode (char*,int)"
270310,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeClusterNode(clusterNode *node) {
    int i;
    if (node->name) sdsfree(node->name);
    if (node->replicate) sdsfree(node->replicate);
    if (node->migrating != NULL) {
        for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
        zfree(node->migrating);
    }
    if (node->importing != NULL) {
        for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
        zfree(node->importing);
    }
    /* If the node is not the reference node, that uses the address from
     * config.conn_info.hostip and config.conn_info.hostport, then the node ip has been
     * allocated by fetchClusterConfiguration, so it must be freed. */
    if (node->ip && strcmp(node->ip, config.conn_info.hostip) != 0) sdsfree(node->ip);
    if (node->redis_config != NULL) freeRedisConfig(node->redis_config);
    zfree(node->slots);
    zfree(node);
}",1,1,redis-benchmark.c,freeClusterNode,,false,1078,1097,freeClusterNode,,,58,void freeClusterNode (clusterNode*)
270430,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void freeClusterNodes(void) {
    int i = 0;
    for (; i < config.cluster_node_count; i++) {
        clusterNode *n = config.cluster_nodes[i];
        if (n) freeClusterNode(n);
    }
    zfree(config.cluster_nodes);
    config.cluster_nodes = NULL;
}",1,1,redis-benchmark.c,freeClusterNodes,,false,1099,1107,freeClusterNodes,,,59,void freeClusterNodes (void)
270471,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static clusterNode **addClusterNode(clusterNode *node) {
    int count = config.cluster_node_count + 1;
    config.cluster_nodes = zrealloc(config.cluster_nodes,
                                    count * sizeof(*node));
    if (!config.cluster_nodes) return NULL;
    config.cluster_nodes[config.cluster_node_count++] = node;
    return config.cluster_nodes;
}",1,1,redis-benchmark.c,addClusterNode,,false,1109,1116,addClusterNode,,,60,clusterNode addClusterNode (clusterNode*)
270519,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static int fetchClusterConfiguration(void) {
    int success = 1;
    redisContext *ctx = NULL;
    redisReply *reply =  NULL;
    ctx = getRedisContext(config.conn_info.hostip, config.conn_info.hostport, config.hostsocket);
    if (ctx == NULL) {
        exit(1);
    }
    clusterNode *firstNode = createClusterNode((char *) config.conn_info.hostip,
                                               config.conn_info.hostport);
    if (!firstNode) {success = 0; goto cleanup;}
    reply = redisCommand(ctx, ""CLUSTER NODES"");
    success = (reply != NULL);
    if (!success) goto cleanup;
    success = (reply->type != REDIS_REPLY_ERROR);
    if (!success) {
        if (config.hostsocket == NULL) {
            fprintf(stderr, ""Cluster node %s:%d replied with error:\n%s\n"",
                    config.conn_info.hostip, config.conn_info.hostport, reply->str);
        } else {
            fprintf(stderr, ""Cluster node %s replied with error:\n%s\n"",
                    config.hostsocket, reply->st...",1,1,redis-benchmark.c,fetchClusterConfiguration,,false,1121,1285,fetchClusterConfiguration,,,61,int fetchClusterConfiguration (void)
271262,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static int fetchClusterSlotsConfiguration(client c) {
    UNUSED(c);
    int success = 1, is_fetching_slots = 0, last_update = 0;
    size_t i;
    atomicGet(config.slots_last_update, last_update);
    if (c->slots_last_update < last_update) {
        c->slots_last_update = last_update;
        return -1;
    }
    redisReply *reply = NULL;
    atomicGetIncr(config.is_fetching_slots, is_fetching_slots, 1);
    if (is_fetching_slots) return -1; //TODO: use other codes || errno ?
    atomicSet(config.is_fetching_slots, 1);
    fprintf(stderr,
            ""WARNING: Cluster slots configuration changed, fetching new one...\n"");
    const char *errmsg = ""Failed to update cluster slots configuration"";
    static dictType dtype = {
        dictSdsHash,               /* hash function */
        NULL,                      /* key dup */
        NULL,                      /* val dup */
        dictSdsKeyCompare,         /* key compare */
        NULL,                      /* key destructor */
 ...",1,4,redis-benchmark.c,fetchClusterSlotsConfiguration,,false,1289,1377,fetchClusterSlotsConfiguration,,,62,int fetchClusterSlotsConfiguration (client)
271660,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void updateClusterSlotsConfiguration(void) {
    pthread_mutex_lock(&config.is_updating_slots_mutex);
    atomicSet(config.is_updating_slots, 1);
    int i;
    for (i = 0; i < config.cluster_node_count; i++) {
        clusterNode *node = config.cluster_nodes[i];
        if (node->updated_slots != NULL) {
            int *oldslots = node->slots;
            node->slots = node->updated_slots;
            node->slots_count = node->updated_slots_count;
            node->current_slot_index = 0;
            node->updated_slots = NULL;
            node->updated_slots_count = 0;
            zfree(oldslots);
        }
    }
    atomicSet(config.is_updating_slots, 0);
    atomicIncr(config.slots_last_update, 1);
    pthread_mutex_unlock(&config.is_updating_slots_mutex);
}",1,1,redis-benchmark.c,updateClusterSlotsConfiguration,,false,1380,1399,updateClusterSlotsConfiguration,,,63,void updateClusterSlotsConfiguration (void)
271756,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"static void genBenchmarkRandomData(char *data, int count) {
    static uint32_t state = 1234;
    int i = 0;

    while (count--) {
        state = (state*1103515245+12345);
        data[i++] = '0'+((state>>16)&63);
    }
}",1,1,redis-benchmark.c,genBenchmarkRandomData,,false,1402,1410,genBenchmarkRandomData,,,64,"void genBenchmarkRandomData (char*,int)"
271793,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"int parseOptions(int argc, char **argv) {
    int i;
    int lastarg;
    int exit_status = 1;
    char *tls_usage;

    for (i = 1; i < argc; i++) {
        lastarg = (i == (argc-1));

        if (!strcmp(argv[i],""-c"")) {
            if (lastarg) goto invalid;
            config.numclients = atoi(argv[++i]);
        } else if (!strcmp(argv[i],""-v"") || !strcmp(argv[i], ""--version"")) {
            sds version = benchmarkVersion();
            printf(""redis-benchmark %s\n"", version);
            sdsfree(version);
            exit(0);
        } else if (!strcmp(argv[i],""-n"")) {
            if (lastarg) goto invalid;
            config.requests = atoi(argv[++i]);
        } else if (!strcmp(argv[i],""-k"")) {
            if (lastarg) goto invalid;
            config.keepalive = atoi(argv[++i]);
        } else if (!strcmp(argv[i],""-h"")) {
            if (lastarg) goto invalid;
            sdsfree(config.conn_info.hostip);
            config.conn_info.hostip = sdsnew(argv[++i]);
        } el...",1,57,redis-benchmark.c,parseOptions,,false,1413,1673,parseOptions,,,65,"int parseOptions (int,char**)"
272687,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    UNUSED(eventLoop);
    UNUSED(id);
    benchmarkThread *thread = (benchmarkThread *)clientData;
    int liveclients = 0;
    int requests_finished = 0;
    int previous_requests_finished = 0;
    long long current_tick = mstime();
    atomicGet(config.liveclients, liveclients);
    atomicGet(config.requests_finished, requests_finished);
    atomicGet(config.previous_requests_finished, previous_requests_finished);

    if (liveclients == 0 && requests_finished != config.requests) {
        fprintf(stderr,""All clients disconnected... aborting.\n"");
        exit(1);
    }
    if (config.num_threads && requests_finished >= config.requests) {
        aeStop(eventLoop);
        return AE_NOMORE;
    }
    if (config.csv) return SHOW_THROUGHPUT_INTERVAL;
    /* only first thread output throughput */
    if (thread != NULL && thread->index != 0) {
        return SHOW_THROUGHPUT_INTERVAL;
    }
    if (co...",1,4,redis-benchmark.c,showThroughput,,false,1675,1717,showThroughput,,,66,"int showThroughput (aeEventLoop*,long long,void*)"
272914,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"int test_is_selected(const char *name) {
    char buf[256];
    int l = strlen(name);

    if (config.tests == NULL) return 1;
    buf[0] = ',';
    memcpy(buf+1,name,l);
    buf[l+1] = ',';
    buf[l+2] = '\0';
    return strstr(config.tests,buf) != NULL;
}",1,1,redis-benchmark.c,test_is_selected,,false,1721,1731,test_is_selected,,,67,int test_is_selected (char*)
272967,METHOD,redis-benchmark.c:<global>,TYPE_DECL,"int main(int argc, char **argv) {
    int i;
    char *data, *cmd, *tag;
    int len;

    client c;

    srandom(time(NULL) ^ getpid());
    init_genrand64(ustime() ^ getpid());
    signal(SIGHUP, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);

    memset(&config.sslconfig, 0, sizeof(config.sslconfig));
    config.numclients = 50;
    config.requests = 100000;
    config.liveclients = 0;
    config.el = aeCreateEventLoop(1024*10);
    aeCreateTimeEvent(config.el,1,showThroughput,NULL,NULL);
    config.keepalive = 1;
    config.datasize = 3;
    config.pipeline = 1;
    config.randomkeys = 0;
    config.randomkeys_keyspacelen = 0;
    config.quiet = 0;
    config.csv = 0;
    config.loop = 0;
    config.idlemode = 0;
    config.clients = listCreate();
    config.conn_info.hostip = sdsnew(""127.0.0.1"");
    config.conn_info.hostport = 6379;
    config.hostsocket = NULL;
    config.tests = NULL;
    config.conn_info.input_dbnum = 0;
    config.stdinarg = 0;
    config.conn_info.auth = NULL;
 ...",1,23,redis-benchmark.c,main,,false,1733,2060,main,,,68,"int main (int,char**)"
274121,METHOD,redis-check-aof.c:<global>,TYPE_DECL,<global>,1,1,redis-check-aof.c,redis-check-aof.c:<global>,,false,1,566,<global>,,,1,
274128,METHOD,redis-check-aof.c:<global>,TYPE_DECL,aofManifest *aofManifestCreate(void);,13,36,redis-check-aof.c,aofManifestCreate,,false,48,48,aofManifestCreate,,,3,aofManifest* aofManifestCreate (void)
274133,METHOD,redis-check-aof.c:<global>,TYPE_DECL,void aofManifestFree(aofManifest *am);,6,37,redis-check-aof.c,aofManifestFree,,false,49,49,aofManifestFree,,,4,void aofManifestFree (aofManifest*)
274138,METHOD,redis-check-aof.c:<global>,TYPE_DECL,aofManifest *aofLoadManifestFromFile(sds am_filepath);,13,53,redis-check-aof.c,aofLoadManifestFromFile,,false,50,50,aofLoadManifestFromFile,,,5,aofManifest* aofLoadManifestFromFile (sds)
274155,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int consumeNewline(char *buf) {
    if (strncmp(buf,""\r\n"",2) != 0) {
        ERROR(""Expected \\r\\n, got: %02x%02x"",buf[0],buf[1]);
        return 0;
    }
    line += 1;
    return 1;
}",1,8,redis-check-aof.c,consumeNewline,,false,63,70,consumeNewline,,,13,int consumeNewline (char*)
274199,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int readLong(FILE *fp, char prefix, long *target) {
    char buf[128], *eptr;
    epos = ftello(fp);
    if (fgets(buf,sizeof(buf),fp) == NULL) {
        return 0;
    }
    if (buf[0] != prefix) {
        ERROR(""Expected prefix '%c', got: '%c'"",prefix,buf[0]);
        return 0;
    }
    *target = strtol(buf+1,&eptr,10);
    return consumeNewline(eptr);
}",1,8,redis-check-aof.c,readLong,,false,72,84,readLong,,,14,"int readLong (FILE*,char,long*)"
274267,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int readBytes(FILE *fp, char *target, long length) {
    long real;
    epos = ftello(fp);
    real = fread(target,1,length,fp);
    if (real != length) {
        ERROR(""Expected to read %ld bytes, got %ld bytes"",length,real);
        return 0;
    }
    return 1;
}",1,8,redis-check-aof.c,readBytes,,false,86,95,readBytes,,,15,"int readBytes (FILE*,char*,long)"
274315,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int readString(FILE *fp, char** target) {
    long len;
    *target = NULL;
    if (!readLong(fp,'$',&len)) {
        return 0;
    }

    if (len < 0 || len > LONG_MAX - 2) {
        ERROR(""Expected to read string of %ld bytes, which is not in the suitable range"",len);
        return 0;
    }

    /* Increase length to also consume \r\n */
    len += 2;
    *target = (char*)zmalloc(len);
    if (!readBytes(fp,*target,len)) {
        zfree(*target);
        *target = NULL;
        return 0;
    }
    if (!consumeNewline(*target+len-2)) {
        zfree(*target);
        *target = NULL;
        return 0;
    }
    (*target)[len-2] = '\0';
    return 1;
}",1,8,redis-check-aof.c,readString,,false,97,124,readString,,,16,"int readString (FILE*,char**)"
274424,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int readArgc(FILE *fp, long *target) {
    return readLong(fp,'*',target);
}",1,1,redis-check-aof.c,readArgc,,false,126,128,readArgc,,,17,"int readArgc (FILE*,long*)"
274435,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int processRESP(FILE *fp, char *filename, int *out_multi) {
    long argc;
    char *str;

    if (!readArgc(fp, &argc)) return 0;

    for (int i = 0; i < argc; i++) {
        if (!readString(fp, &str)) return 0;
        if (i == 0) {
            if (strcasecmp(str, ""multi"") == 0) {
                if ((*out_multi)++) {
                    ERROR(""Unexpected MULTI in AOF %s"", filename);
                    zfree(str);
                    return 0;
                }
            } else if (strcasecmp(str, ""exec"") == 0) {
                if (--(*out_multi)) {
                    ERROR(""Unexpected EXEC in AOF %s"", filename);
                    zfree(str);
                    return 0;
                }
            }
        }
        zfree(str);
    }

    return 1;
}",1,20,redis-check-aof.c,processRESP,,false,137,164,processRESP,,,18,"int processRESP (FILE*,char*,int*)"
274555,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int processAnnotations(FILE *fp, char *filename, int last_file) {
    char buf[AOF_ANNOTATION_LINE_MAX_LEN];

    epos = ftello(fp);
    if (fgets(buf, sizeof(buf), fp) == NULL) {
        printf(""Failed to read annotations from AOF %s, aborting...\n"", filename);
        exit(1);
    }

    if (to_timestamp && strncmp(buf, ""#TS:"", 4) == 0) {
        char *endptr;
        errno = 0;
        time_t ts = strtol(buf+4, &endptr, 10);
        if (errno != 0 || *endptr != '\r') {
            printf(""Invalid timestamp annotation\n"");
            exit(1);
        }
        if (ts <= to_timestamp) return 1;
        if (epos == 0) {
            printf(""AOF %s has nothing before timestamp %ld, ""
                    ""aborting...\n"", filename, to_timestamp);
            exit(1);
        }
        if (!last_file) {
            printf(""Failed to truncate AOF %s to timestamp %ld to offset %ld because it is not the last file.\n"",
                filename, to_timestamp, (long int)epos);
            pri...",1,13,redis-check-aof.c,processAnnotations,,false,175,215,processAnnotations,,,19,"int processAnnotations (FILE*,char*,int)"
274673,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int checkSingleAof(char *aof_filename, char *aof_filepath, int last_file, int fix, int preamble) {
    off_t pos = 0, diff;
    int multi = 0;
    char buf[2];

    FILE *fp = fopen(aof_filepath, ""r+"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s, aborting...\n"", aof_filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp),&sb) == -1) {
        printf(""Cannot stat file: %s, aborting...\n"", aof_filename);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        return AOF_CHECK_EMPTY;
    }

    if (preamble) {
        char *argv[2] = {NULL, aof_filepath};
        if (redis_check_rdb_main(2, argv, fp) == C_ERR) {
            printf(""RDB preamble of AOF file is not sane, aborting.\n"");
            exit(1);
        } else {
            printf(""RDB preamble is OK, proceeding with AOF tail...\n"");
        }
    }

    while(1) {
        if (!multi) pos = ftello(fp);
        if (fgets(buf, sizeo...",1,11,redis-check-aof.c,checkSingleAof,,false,222,330,checkSingleAof,,,20,"int checkSingleAof (char*,char*,int,int,int)"
275022,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int fileIsRDB(char *filepath) {
    FILE *fp = fopen(filepath, ""r"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s\n"", filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        printf(""Cannot stat file: %s\n"", filepath);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        fclose(fp);
        return 0;
    }

    if (size >= 8) {    /* There must be at least room for the RDB header. */
        char sig[5];
        int rdb_file = fread(sig, sizeof(sig), 1, fp) == 1 &&
                            memcmp(sig, ""REDIS"", sizeof(sig)) == 0;
        if (rdb_file) {
            fclose(fp);
            return 1;
        } 
    }

    fclose(fp);
    return 0;
}",1,11,redis-check-aof.c,fileIsRDB,,false,336,367,fileIsRDB,,,21,int fileIsRDB (char*)
275114,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int fileIsManifest(char *filepath) {
    int is_manifest = 0;
    FILE *fp = fopen(filepath, ""r"");
    if (fp == NULL) {
        printf(""Cannot open file %s: %s\n"", filepath, strerror(errno));
        exit(1);
    }

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        printf(""Cannot stat file: %s\n"", filepath);
        exit(1);
    }

    off_t size = sb.st_size;
    if (size == 0) {
        fclose(fp);
        return 0;
    }

    char buf[MANIFEST_MAX_LINE+1];
    while (1) {
        if (fgets(buf, MANIFEST_MAX_LINE+1, fp) == NULL) {
            if (feof(fp)) {
                break;
            } else {
                printf(""Cannot read file: %s\n"", filepath);
                exit(1);
            }
        }

        /* Skip comments lines */
        if (buf[0] == '#') {
            continue;
        } else if (!memcmp(buf, ""file"", strlen(""file""))) {
            is_manifest = 1;
        }
    }

    fclose(fp);
    return is_manifest;
}",1,11,redis-check-aof.c,fileIsManifest,,false,371,412,fileIsManifest,,,22,int fileIsManifest (char*)
275227,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"input_file_type getInputFileType(char *filepath) {
    if (fileIsManifest(filepath)) {
        return AOF_MULTI_PART;
    } else if (fileIsRDB(filepath)) {
        return AOF_RDB_PREAMBLE;
    } else {
        return AOF_RESP;
    }
}",1,1,redis-check-aof.c,getInputFileType,,false,422,430,getInputFileType,,,23,input_file_type getInputFileType (char*)
275250,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"void printAofStyle(int ret, char *aofFileName, char *aofType) {
    if (ret == AOF_CHECK_OK) {
        printf(""%s %s is valid\n"", aofType, aofFileName);
    } else if (ret == AOF_CHECK_EMPTY) {
        printf(""%s %s is empty\n"", aofType, aofFileName);
    } else if (ret == AOF_CHECK_TIMESTAMP_TRUNCATED) {
        printf(""Successfully truncated AOF %s to timestamp %ld\n"",
            aofFileName, to_timestamp);
    } else if (ret == AOF_CHECK_TRUNCATED) {
        printf(""Successfully truncated AOF %s\n"", aofFileName);
    }
}",1,15,redis-check-aof.c,printAofStyle,,false,432,443,printAofStyle,,,24,"void printAofStyle (int,char*,char*)"
275306,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"void checkMultiPartAof(char *dirpath, char *manifest_filepath, int fix) {
    int total_num = 0, aof_num = 0, last_file;
    int ret;

    printf(""Start checking Multi Part AOF\n"");
    aofManifest *am = aofLoadManifestFromFile(manifest_filepath);

    if (am->base_aof_info) total_num++;
    if (am->incr_aof_list) total_num += listLength(am->incr_aof_list);

    if (am->base_aof_info) {
        sds aof_filename = am->base_aof_info->file_name;
        sds aof_filepath = makePath(dirpath, aof_filename);
        last_file = ++aof_num == total_num;
        int aof_preable = fileIsRDB(aof_filepath);

        printf(""Start to check BASE AOF (%s format).\n"", aof_preable ? ""RDB"":""RESP"");
        ret = checkSingleAof(aof_filename, aof_filepath, last_file, fix, aof_preable);
        printAofStyle(ret, aof_filename, (char *)""BASE AOF"");
        sdsfree(aof_filepath);
    }

    if (listLength(am->incr_aof_list)) {
        listNode *ln;
        listIter li;

        printf(""Start to check INCR ...",1,40,redis-check-aof.c,checkMultiPartAof,,false,456,497,checkMultiPartAof,,,25,"void checkMultiPartAof (char*,char*,int)"
275485,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"void checkOldStyleAof(char *filepath, int fix, int preamble) {
    printf(""Start checking Old-Style AOF\n"");
    int ret = checkSingleAof(filepath, filepath, 1, fix, preamble);
    printAofStyle(ret, filepath, (char *)""AOF"");
}",1,1,redis-check-aof.c,checkOldStyleAof,,false,502,506,checkOldStyleAof,,,26,"void checkOldStyleAof (char*,int,int)"
275509,METHOD,redis-check-aof.c:<global>,TYPE_DECL,"int redis_check_aof_main(int argc, char **argv) {
    char *filepath;
    char temp_filepath[PATH_MAX + 1];
    char *dirpath;
    int fix = 0;

    if (argc < 2) {
        goto invalid_args;
    } else if (argc == 2) {
        filepath = argv[1];
    } else if (argc == 3) {
        if (!strcmp(argv[1], ""--fix"")) {
            filepath = argv[2];
            fix = 1;
        } else {
            goto invalid_args;
        }
    } else if (argc == 4) {
        if (!strcmp(argv[1], ""--truncate-to-timestamp"")) {
            char *endptr;
            errno = 0;
            to_timestamp = strtol(argv[2], &endptr, 10);
            if (errno != 0 || *endptr != '\0') {
                printf(""Invalid timestamp, aborting...\n"");
                exit(1);
            }
            filepath = argv[3];
        } else {
            goto invalid_args;
        }
    } else {
        goto invalid_args;
    }

    /* In the glibc implementation dirname may modify their argument. */
    memcpy(temp_fi...",1,1,redis-check-aof.c,redis_check_aof_main,,false,508,566,redis_check_aof_main,,,27,"int redis_check_aof_main (int,char**)"
275686,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,<global>,1,1,redis-check-rdb.c,redis-check-rdb.c:<global>,,false,1,447,<global>,,,1,
275688,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,void createSharedObjects(void);,6,30,redis-check-rdb.c,createSharedObjects,,false,39,39,createSharedObjects,,,1,void createSharedObjects (void)
275693,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbLoadProgressCallback(rio *r, const void *buf, size_t len);",6,65,redis-check-rdb.c,rdbLoadProgressCallback,,false,40,40,rdbLoadProgressCallback,,,2,"void rdbLoadProgressCallback (rio*,void*,size_t)"
275714,METHOD,<empty>,<empty>,<empty>,1,,redis-check-rdb.c,rdbstate:<clinit>,,false,43,,<clinit>,,,10,
275759,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbShowGenericInfo(void) {
    printf(""[info] %lu keys read\n"", rdbstate.keys);
    printf(""[info] %lu expires\n"", rdbstate.expires);
    printf(""[info] %lu already expired\n"", rdbstate.already_expired);
}",1,1,redis-check-rdb.c,rdbShowGenericInfo,,false,105,109,rdbShowGenericInfo,,,11,void rdbShowGenericInfo (void)
275779,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbCheckError(const char *fmt, ...) {
    char msg[1024];
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    printf(""--- RDB ERROR DETECTED ---\n"");
    printf(""[offset %llu] %s\n"",
        (unsigned long long) (rdbstate.rio ?
            rdbstate.rio->processed_bytes : 0), msg);
    printf(""[additional info] While doing: %s\n"",
        rdb_check_doing_string[rdbstate.doing]);
    if (rdbstate.key)
        printf(""[additional info] Reading key '%s'\n"",
            (char*)rdbstate.key->ptr);
    if (rdbstate.key_type != -1)
        printf(""[additional info] Reading type %d (%s)\n"",
            rdbstate.key_type,
            ((unsigned)rdbstate.key_type <
             sizeof(rdb_type_string)/sizeof(char*)) ?
                rdb_type_string[rdbstate.key_type] : ""unknown"");
    rdbShowGenericInfo();
}",1,1,redis-check-rdb.c,rdbCheckError,,false,113,137,rdbCheckError,,,12,void rdbCheckError (char*...)
275867,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbCheckInfo(const char *fmt, ...) {
    char msg[1024];
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    printf(""[offset %llu] %s\n"",
        (unsigned long long) (rdbstate.rio ?
            rdbstate.rio->processed_bytes : 0), msg);
}",1,1,redis-check-rdb.c,rdbCheckInfo,,false,140,151,rdbCheckInfo,,,13,void rdbCheckInfo (char*...)
275900,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbCheckSetError(const char *fmt, ...) {
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(rdbstate.error, sizeof(rdbstate.error), fmt, ap);
    va_end(ap);
    rdbstate.error_set = 1;
}",1,1,redis-check-rdb.c,rdbCheckSetError,,false,155,162,rdbCheckSetError,,,14,void rdbCheckSetError (char*...)
275926,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbCheckHandleCrash(int sig, siginfo_t *info, void *secret) {
    UNUSED(sig);
    UNUSED(info);
    UNUSED(secret);

    rdbCheckError(""Server crash checking the specified RDB file!"");
    exit(1);
}",1,4,redis-check-rdb.c,rdbCheckHandleCrash,,false,167,174,rdbCheckHandleCrash,,,15,"void rdbCheckHandleCrash (int,siginfo_t*,void*)"
275955,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"void rdbCheckSetupSignals(void) {
    struct sigaction act;

    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = rdbCheckHandleCrash;
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
}",1,1,redis-check-rdb.c,rdbCheckSetupSignals,,false,176,187,rdbCheckSetupSignals,,,16,void rdbCheckSetupSignals (void)
276005,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"int redis_check_rdb(char *rdbfilename, FILE *fp) {
    uint64_t dbid;
    int selected_dbid = -1;
    int type, rdbver;
    char buf[1024];
    long long expiretime, now = mstime();
    static rio rdb; /* Pointed by global struct riostate. */
    struct stat sb;

    int closefile = (fp == NULL);
    if (fp == NULL && (fp = fopen(rdbfilename,""r"")) == NULL) return 1;

    if (fstat(fileno(fp), &sb) == -1)
        sb.st_size = 0;

    startLoadingFile(sb.st_size, rdbfilename, RDBFLAGS_NONE);
    rioInitWithFile(&rdb,fp);
    rdbstate.rio = &rdb;
    rdb.update_cksum = rdbLoadProgressCallback;
    if (rioRead(&rdb,buf,9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf,""REDIS"",5) != 0) {
        rdbCheckError(""Wrong signature trying to load DB from file"");
        goto err;
    }
    rdbver = atoi(buf+5);
    if (rdbver < 1 || rdbver > RDB_VERSION) {
        rdbCheckError(""Can't handle RDB format version %d"",rdbver);
        goto err;
    }

    expiretime = -1;
    while(1) {
...",1,46,redis-check-rdb.c,redis_check_rdb,,false,193,386,redis_check_rdb,,,17,"int redis_check_rdb (char*,FILE*)"
276769,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"static sds checkRdbVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",1,45,redis-check-rdb.c,checkRdbVersion,,false,388,400,checkRdbVersion,,,18,sds checkRdbVersion (void)
276813,METHOD,redis-check-rdb.c:<global>,TYPE_DECL,"int redis_check_rdb_main(int argc, char **argv, FILE *fp) {
    struct timeval tv;

    if (argc != 2 && fp == NULL) {
        fprintf(stderr, ""Usage: %s <rdb-file-name>\n"", argv[0]);
        exit(1);
    } else if (!strcmp(argv[1],""-v"") || !strcmp(argv[1], ""--version"")) {
        sds version = checkRdbVersion();
        printf(""redis-check-rdb %s\n"", version);
        sdsfree(version);
        exit(0);
    }

    gettimeofday(&tv, NULL);
    init_genrand64(((long long) tv.tv_sec * 1000000 + tv.tv_usec) ^ getpid());

    /* In order to call the loading functions we need to create the shared
     * integer objects, however since this function may be called from
     * an already initialized Redis instance, check if we really need to. */
    if (shared.integers[0] == NULL)
        createSharedObjects();
    server.loading_process_events_interval_bytes = 0;
    server.sanitize_dump_payload = SANITIZE_DUMP_YES;
    rdbCheckMode = 1;
    rdbCheckInfo(""Checking RDB file %s"", argv[1]);
   ...",1,35,redis-check-rdb.c,redis_check_rdb_main,,false,414,447,redis_check_rdb_main,,,19,"int redis_check_rdb_main (int,char**,FILE*)"
277017,METHOD,redis-cli.c:<global>,TYPE_DECL,<global>,1,1,redis-cli.c,redis-cli.c:<global>,,false,1,9978,<global>,,,1,
277075,METHOD,redis-cli.c:<global>,TYPE_DECL,static uint64_t dictSdsHash(const void *key);,17,44,redis-cli.c,dictSdsHash,,false,181,181,dictSdsHash,,,15,uint64_t dictSdsHash (void*)
277080,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int dictSdsKeyCompare(dict *d, const void *key1,
    const void *key2);",12,21,redis-cli.c,dictSdsKeyCompare,,false,182,183,dictSdsKeyCompare,,,16,"int dictSdsKeyCompare (dict*,void*,void*)"
277087,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void dictSdsDestructor(dict *d, void *val);",13,49,redis-cli.c,dictSdsDestructor,,false,184,184,dictSdsDestructor,,,17,"void dictSdsDestructor (dict*,void*)"
277093,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void dictListDestructor(dict *d, void *val);",13,50,redis-cli.c,dictListDestructor,,false,185,185,dictListDestructor,,,18,"void dictListDestructor (dict*,void*)"
277120,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int createClusterManagerCommand(char *cmdname, int argc, char **argv);",12,76,redis-cli.c,createClusterManagerCommand,,false,210,210,createClusterManagerCommand,,,21,"int createClusterManagerCommand (char*,int,char**)"
277194,METHOD,<empty>,<empty>,<empty>,1,,redis-cli.c,config:<clinit>,,false,214,,<clinit>,,,66,
277208,METHOD,redis-cli.c:<global>,TYPE_DECL,static void usage(int err);,13,26,redis-cli.c,usage,,false,288,288,usage,,,29,void usage (int)
277213,METHOD,redis-cli.c:<global>,TYPE_DECL,static void slaveMode(int send_sync);,13,36,redis-cli.c,slaveMode,,false,289,289,slaveMode,,,30,void slaveMode (int)
277218,METHOD,redis-cli.c:<global>,TYPE_DECL,char *redisGitSHA1(void);,6,24,redis-cli.c,redisGitSHA1,,false,290,290,redisGitSHA1,,,31,char* redisGitSHA1 (void)
277223,METHOD,redis-cli.c:<global>,TYPE_DECL,char *redisGitDirty(void);,6,25,redis-cli.c,redisGitDirty,,false,291,291,redisGitDirty,,,32,char* redisGitDirty (void)
277228,METHOD,redis-cli.c:<global>,TYPE_DECL,static int cliConnect(int flags);,12,32,redis-cli.c,cliConnect,,false,292,292,cliConnect,,,33,int cliConnect (int)
277233,METHOD,redis-cli.c:<global>,TYPE_DECL,"static char *getInfoField(char *info, char *field);",13,50,redis-cli.c,getInfoField,,false,294,294,getInfoField,,,34,"char* getInfoField (char*,char*)"
277239,METHOD,redis-cli.c:<global>,TYPE_DECL,"static long getLongInfoField(char *info, char *field);",13,53,redis-cli.c,getLongInfoField,,false,295,295,getLongInfoField,,,35,"long getLongInfoField (char*,char*)"
277245,METHOD,redis-cli.c:<global>,TYPE_DECL,"size_t redis_strlcpy(char *dst, const char *src, size_t dsize);",8,62,redis-cli.c,redis_strlcpy,,false,300,300,redis_strlcpy,,,36,"size_t redis_strlcpy (char*,char*,size_t)"
277252,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliPushHandler(void *, void *);",13,42,redis-cli.c,cliPushHandler,,false,302,302,cliPushHandler,,,37,"void cliPushHandler (void*,void*)"
277258,METHOD,redis-cli.c:<global>,TYPE_DECL,"uint16_t crc16(const char *buf, int len);",10,40,redis-cli.c,crc16,,false,304,304,crc16,,,38,"uint16_t crc16 (char*,int)"
277264,METHOD,redis-cli.c:<global>,TYPE_DECL,"static long long ustime(void) {
    struct timeval tv;
    long long ust;

    gettimeofday(&tv, NULL);
    ust = ((long long)tv.tv_sec)*1000000;
    ust += tv.tv_usec;
    return ust;
}",1,1,redis-cli.c,ustime,,false,306,314,ustime,,,39,long long ustime (void)
277291,METHOD,redis-cli.c:<global>,TYPE_DECL,"static long long mstime(void) {
    return ustime()/1000;
}",1,1,redis-cli.c,mstime,,false,316,318,mstime,,,40,long long mstime (void)
277300,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliRefreshPrompt(void) {
    if (config.eval_ldb) return;

    sds prompt = sdsempty();
    if (config.hostsocket != NULL) {
        prompt = sdscatfmt(prompt,""redis %s"",config.hostsocket);
    } else {
        char addr[256];
        formatAddr(addr, sizeof(addr), config.conn_info.hostip, config.conn_info.hostport);
        prompt = sdscatlen(prompt,addr,strlen(addr));
    }

    /* Add [dbnum] if needed */
    if (config.dbnum != 0)
        prompt = sdscatfmt(prompt,""[%i]"",config.dbnum);

    /* Add TX if in transaction state*/
    if (config.in_multi)  
        prompt = sdscatlen(prompt,""(TX)"",4);

    if (config.pubsub_mode)
        prompt = sdscatfmt(prompt,""(subscribed mode)"");

    /* Copy the prompt in the static buffer. */
    prompt = sdscatlen(prompt,""> "",2);
    snprintf(config.prompt,sizeof(config.prompt),""%s"",prompt);
    sdsfree(prompt);
}",1,1,redis-cli.c,cliRefreshPrompt,,false,320,347,cliRefreshPrompt,,,41,void cliRefreshPrompt (void)
277408,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds getDotfilePath(char *envoverride, char *dotfilename) {
    char *path = NULL;
    sds dotPath = NULL;

    /* Check the env for a dotfile override. */
    path = getenv(envoverride);
    if (path != NULL && *path != '\0') {
        if (!strcmp(""/dev/null"", path)) {
            return NULL;
        }

        /* If the env is set, return it. */
        dotPath = sdsnew(path);
    } else {
        char *home = getenv(""HOME"");
        if (home != NULL && *home != '\0') {
            /* If no override is set use $HOME/<dotfilename>. */
            dotPath = sdscatprintf(sdsempty(), ""%s/%s"", home, dotfilename);
        }
    }
    return dotPath;
}",1,1,redis-cli.c,getDotfilePath,,false,357,378,getDotfilePath,,,42,"sds getDotfilePath (char*,char*)"
277474,METHOD,redis-cli.c:<global>,TYPE_DECL,"static uint64_t dictSdsHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
}",1,1,redis-cli.c,dictSdsHash,,false,380,382,dictSdsHash,,,43,uint64_t dictSdsHash (void*)
277488,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int dictSdsKeyCompare(dict *d, const void *key1, const void *key2)
{
    int l1,l2;
    UNUSED(d);

    l1 = sdslen((sds)key1);
    l2 = sdslen((sds)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",1,4,redis-cli.c,dictSdsKeyCompare,,false,384,393,dictSdsKeyCompare,,,44,"int dictSdsKeyCompare (dict*,void*,void*)"
277529,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void dictSdsDestructor(dict *d, void *val)
{
    UNUSED(d);
    sdsfree(val);
}",1,4,redis-cli.c,dictSdsDestructor,,false,395,399,dictSdsDestructor,,,45,"void dictSdsDestructor (dict*,void*)"
277543,METHOD,redis-cli.c:<global>,TYPE_DECL,"void dictListDestructor(dict *d, void *val)
{
    UNUSED(d);
    listRelease((list*)val);
}",1,4,redis-cli.c,dictListDestructor,,false,401,405,dictListDestructor,,,46,"void dictListDestructor (dict*,void*)"
277575,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliVersion(void) {
    sds version;
    version = sdscatprintf(sdsempty(), ""%s"", REDIS_VERSION);

    /* Add git commit and working tree status when available */
    if (strtoll(redisGitSHA1(),NULL,16)) {
        version = sdscatprintf(version, "" (git:%s"", redisGitSHA1());
        if (strtoll(redisGitDirty(),NULL,10))
            version = sdscatprintf(version, ""-dirty"");
        version = sdscat(version, "")"");
    }
    return version;
}",1,45,redis-cli.c,cliVersion,,false,427,439,cliVersion,,,53,sds cliVersion (void)
277619,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliLegacyIntegrateHelp(void) {
    if (cliConnect(CC_QUIET) == REDIS_ERR) return;

    redisReply *reply = redisCommand(context, ""COMMAND"");
    if(reply == NULL || reply->type != REDIS_REPLY_ARRAY) return;

    /* Scan the array reported by COMMAND and fill only the entries that
     * don't already match what we have. */
    for (size_t j = 0; j < reply->elements; j++) {
        redisReply *entry = reply->element[j];
        if (entry->type != REDIS_REPLY_ARRAY || entry->elements < 4 ||
            entry->element[0]->type != REDIS_REPLY_STRING ||
            entry->element[1]->type != REDIS_REPLY_INTEGER ||
            entry->element[3]->type != REDIS_REPLY_INTEGER) return;
        char *cmdname = entry->element[0]->str;
        int i;

        for (i = 0; i < helpEntriesLen; i++) {
            helpEntry *he = helpEntries+i;
            if (!strcasecmp(he->argv[0],cmdname))
                break;
        }
        if (i != helpEntriesLen) continue;

        helpEntries...",1,19,redis-cli.c,cliLegacyIntegrateHelp,,false,447,500,cliLegacyIntegrateHelp,,,54,void cliLegacyIntegrateHelp (void)
277960,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds sdscat_orempty(sds params, const char *value) {
    if (value[0] == '\0') {
        return sdscat(params, ""\""\"""");
    }
    return sdscat(params, value);
}",1,1,redis-cli.c,sdscat_orempty,,false,503,508,sdscat_orempty,,,55,"sds sdscat_orempty (sds,char*)"
277981,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds makeHint(char **inputargv, int inputargc, int cmdlen, struct commandDocs docs);",12,89,redis-cli.c,makeHint,,false,510,510,makeHint,,,56,"sds makeHint (char**,int,int,commandDocs)"
277989,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliAddCommandDocArg(cliCommandArg *cmdArg, redisReply *argMap);",13,74,redis-cli.c,cliAddCommandDocArg,,false,512,512,cliAddCommandDocArg,,,57,"void cliAddCommandDocArg (cliCommandArg*,redisReply*)"
277995,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliMakeCommandDocArgs(redisReply *arguments, cliCommandArg *result) {
    for (size_t j = 0; j < arguments->elements; j++) {
        cliAddCommandDocArg(&result[j], arguments->element[j]);
    }
}",1,1,redis-cli.c,cliMakeCommandDocArgs,,false,514,518,cliMakeCommandDocArgs,,,58,"void cliMakeCommandDocArgs (redisReply*,cliCommandArg*)"
278025,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliAddCommandDocArg(cliCommandArg *cmdArg, redisReply *argMap) {
    if (argMap->type != REDIS_REPLY_MAP && argMap->type != REDIS_REPLY_ARRAY) {
        return;
    }

    for (size_t i = 0; i < argMap->elements; i += 2) {
        assert(argMap->element[i]->type == REDIS_REPLY_STRING);
        char *key = argMap->element[i]->str;
        if (!strcmp(key, ""name"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->name = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""display_text"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->display_text = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""token"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY_STRING);
            cmdArg->token = sdsnew(argMap->element[i + 1]->str);
        } else if (!strcmp(key, ""type"")) {
            assert(argMap->element[i + 1]->type == REDIS_REPLY...",1,37,redis-cli.c,cliAddCommandDocArg,,false,520,580,cliAddCommandDocArg,,,59,"void cliAddCommandDocArg (cliCommandArg*,redisReply*)"
278481,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliFillInCommandHelpEntry(helpEntry *help, char *cmdname, char *subcommandname) {
    help->argc = subcommandname ? 2 : 1;
    help->argv = zmalloc(sizeof(sds) * help->argc);
    help->argv[0] = sdsnew(cmdname);
    sdstoupper(help->argv[0]);
    if (subcommandname) {
        /* Subcommand name may be two words separated by a pipe character. */
        char *pipe = strchr(subcommandname, '|');
        if (pipe != NULL) {
            help->argv[1] = sdsnew(pipe + 1);
        } else {
            help->argv[1] = sdsnew(subcommandname);
        }
        sdstoupper(help->argv[1]);
    }
    sds fullname = sdsnew(help->argv[0]);
    if (subcommandname) {
        fullname = sdscat(fullname, "" "");
        fullname = sdscat(fullname, help->argv[1]);
    }
    help->full = fullname;
    help->type = CLI_HELP_COMMAND;

    help->docs.name = help->full;
    help->docs.params = NULL;
    help->docs.args = NULL;
    help->docs.numargs = 0;
    help->docs.since = NULL;
}",1,17,redis-cli.c,cliFillInCommandHelpEntry,,false,583,611,cliFillInCommandHelpEntry,,,60,"void cliFillInCommandHelpEntry (helpEntry*,char*,char*)"
278636,METHOD,redis-cli.c:<global>,TYPE_DECL,"static helpEntry *cliInitCommandHelpEntry(char *cmdname, char *subcommandname,
                                          helpEntry *next, redisReply *specs,
                                          dict *groups) {
    helpEntry *help = next++;
    cliFillInCommandHelpEntry(help, cmdname, subcommandname);

    assert(specs->type == REDIS_REPLY_MAP || specs->type == REDIS_REPLY_ARRAY);
    for (size_t j = 0; j < specs->elements; j += 2) {
        assert(specs->element[j]->type == REDIS_REPLY_STRING);
        char *key = specs->element[j]->str;
        if (!strcmp(key, ""summary"")) {
            redisReply *reply = specs->element[j + 1];
            assert(reply->type == REDIS_REPLY_STRING);
            help->docs.summary = sdsnew(reply->str);
        } else if (!strcmp(key, ""since"")) {
            redisReply *reply = specs->element[j + 1];
            assert(reply->type == REDIS_REPLY_STRING);
            help->docs.since = sdsnew(reply->str);
        } else if (!strcmp(key, ""group""))...",1,48,redis-cli.c,cliInitCommandHelpEntry,,false,619,665,cliInitCommandHelpEntry,,,61,"helpEntry cliInitCommandHelpEntry (char*,char*,helpEntry*,redisReply*,dict*)"
278985,METHOD,redis-cli.c:<global>,TYPE_DECL,"static size_t cliCountCommands(redisReply* commandTable) {
    size_t numCommands = commandTable->elements / 2;

    /* The command docs table maps command names to a map of their specs. */    
    for (size_t i = 0; i < commandTable->elements; i += 2) {
        assert(commandTable->element[i]->type == REDIS_REPLY_STRING);  /* Command name. */
        assert(commandTable->element[i + 1]->type == REDIS_REPLY_MAP ||
               commandTable->element[i + 1]->type == REDIS_REPLY_ARRAY);
        redisReply *map = commandTable->element[i + 1];
        for (size_t j = 0; j < map->elements; j += 2) {
            assert(map->element[j]->type == REDIS_REPLY_STRING);
            char *key = map->element[j]->str;
            if (!strcmp(key, ""subcommands"")) {
                redisReply *subcommands = map->element[j + 1];
                assert(subcommands->type == REDIS_REPLY_MAP || subcommands->type == REDIS_REPLY_ARRAY);
                numCommands += subcommands->elements / 2;
           ...",1,1,redis-cli.c,cliCountCommands,,false,668,688,cliCountCommands,,,62,size_t cliCountCommands (redisReply*)
279129,METHOD,redis-cli.c:<global>,TYPE_DECL,"int helpEntryCompare(const void *entry1, const void *entry2) {
    helpEntry *i1 = (helpEntry *)entry1;
    helpEntry *i2 = (helpEntry *)entry2;
    return strcmp(i1->full, i2->full);
}",1,1,redis-cli.c,helpEntryCompare,,false,691,695,helpEntryCompare,,,63,"int helpEntryCompare (void*,void*)"
279155,METHOD,redis-cli.c:<global>,TYPE_DECL,"void cliInitGroupHelpEntries(dict *groups) {
    dictIterator *iter = dictGetIterator(groups);
    dictEntry *entry;
    helpEntry tmp;

    int numGroups = dictSize(groups);
    int pos = helpEntriesLen;
    helpEntriesLen += numGroups;
    helpEntries = zrealloc(helpEntries, sizeof(helpEntry)*helpEntriesLen);

    for (entry = dictNext(iter); entry != NULL; entry = dictNext(iter)) {
        tmp.argc = 1;
        tmp.argv = zmalloc(sizeof(sds));
        tmp.argv[0] = sdscatprintf(sdsempty(),""@%s"",(char *)dictGetKey(entry));
        tmp.full = tmp.argv[0];
        tmp.type = CLI_HELP_GROUP;
        tmp.docs.name = NULL;
        tmp.docs.params = NULL;
        tmp.docs.args = NULL;
        tmp.docs.numargs = 0;
        tmp.docs.summary = NULL;
        tmp.docs.since = NULL;
        tmp.docs.group = NULL;
        helpEntries[pos++] = tmp;
    }
    dictReleaseIterator(iter);
}",1,20,redis-cli.c,cliInitGroupHelpEntries,,false,701,727,cliInitGroupHelpEntries,,,64,void cliInitGroupHelpEntries (dict*)
279311,METHOD,redis-cli.c:<global>,TYPE_DECL,"void cliInitCommandHelpEntries(redisReply *commandTable, dict *groups) {
    helpEntry *next = helpEntries;
    for (size_t i = 0; i < commandTable->elements; i += 2) {
        assert(commandTable->element[i]->type == REDIS_REPLY_STRING);
        char *cmdname = commandTable->element[i]->str;

        assert(commandTable->element[i + 1]->type == REDIS_REPLY_MAP ||
               commandTable->element[i + 1]->type == REDIS_REPLY_ARRAY);
        redisReply *cmdspecs = commandTable->element[i + 1];
        next = cliInitCommandHelpEntry(cmdname, NULL, next, cmdspecs, groups);
    }
}",1,1,redis-cli.c,cliInitCommandHelpEntries,,false,730,741,cliInitCommandHelpEntries,,,65,"void cliInitCommandHelpEntries (redisReply*,dict*)"
279398,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int versionIsSupported(sds version, sds since) {
    int i;
    char *versionPos = version;
    char *sincePos = since;
    if (!since) {
        return 1;
    }

    for (i = 0; i != 3; i++) {
        int versionPart = atoi(versionPos);
        int sincePart = atoi(sincePos);
        if (versionPart > sincePart) {
            return 1;
        } else if (sincePart > versionPart) {
            return 0;
        }
        versionPos = strchr(versionPos, '.');
        sincePos = strchr(sincePos, '.');
        if (!versionPos || !sincePos)
            return 0;
        versionPos++;
        sincePos++;
    }
    return 0;
}",1,1,redis-cli.c,versionIsSupported,,false,745,769,versionIsSupported,,,66,"int versionIsSupported (sds,sds)"
279481,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void removeUnsupportedArgs(struct cliCommandArg *args, int *numargs, sds version) {
    int i = 0, j;
    while (i != *numargs) {
        if (versionIsSupported(version, args[i].since)) {
            if (args[i].subargs) {
                removeUnsupportedArgs(args[i].subargs, &args[i].numsubargs, version);
            }
            i++;
            continue;
        }
        for (j = i; j != *numargs; j++) {
            args[j] = args[j + 1];
        }
        (*numargs)--;
    }
}",1,1,redis-cli.c,removeUnsupportedArgs,,false,771,786,removeUnsupportedArgs,,,67,"void removeUnsupportedArgs (cliCommandArg*,int*,sds)"
279555,METHOD,redis-cli.c:<global>,TYPE_DECL,"static helpEntry *cliLegacyInitCommandHelpEntry(char *cmdname, char *subcommandname,
                                                helpEntry *next, struct commandDocs *command,
                                                dict *groups, sds version) {
    helpEntry *help = next++;
    cliFillInCommandHelpEntry(help, cmdname, subcommandname);
    
    help->docs.summary = sdsnew(command->summary);
    help->docs.since = sdsnew(command->since);
    help->docs.group = sdsnew(command->group);
    sds group = sdsdup(help->docs.group);
    if (dictAdd(groups, group, NULL) != DICT_OK) {
        sdsfree(group);
    }

    if (command->args != NULL) {
        help->docs.args = command->args;
        help->docs.numargs = command->numargs;
        if (version)
            removeUnsupportedArgs(help->docs.args, &help->docs.numargs, version);
        help->docs.params = makeHint(NULL, 0, 0, help->docs);
    }

    if (command->subcommands != NULL) {
        for (size_t i = 0; command->subcom...",1,40,redis-cli.c,cliLegacyInitCommandHelpEntry,,false,788,820,cliLegacyInitCommandHelpEntry,,,68,"helpEntry cliLegacyInitCommandHelpEntry (char*,char*,helpEntry*,commandDocs*,dict*,sds)"
279744,METHOD,redis-cli.c:<global>,TYPE_DECL,"int cliLegacyInitCommandHelpEntries(struct commandDocs *commands, dict *groups, sds version) {
    helpEntry *next = helpEntries;
    for (size_t i = 0; commands[i].name != NULL; i++) {
        if (!version || versionIsSupported(version, commands[i].since)) {
            next = cliLegacyInitCommandHelpEntry(commands[i].name, NULL, next, &commands[i], groups, version);
        }
    }
    return next - helpEntries;
}",1,1,redis-cli.c,cliLegacyInitCommandHelpEntries,,false,822,830,cliLegacyInitCommandHelpEntries,,,69,"int cliLegacyInitCommandHelpEntries (commandDocs*,dict*,sds)"
279803,METHOD,redis-cli.c:<global>,TYPE_DECL,"static size_t cliLegacyCountCommands(struct commandDocs *commands, sds version) {
    int numCommands = 0;
    for (size_t i = 0; commands[i].name != NULL; i++) {
        if (version && !versionIsSupported(version, commands[i].since)) {
            continue;
        }
        numCommands++;
        if (commands[i].subcommands != NULL) {
            numCommands += cliLegacyCountCommands(commands[i].subcommands, version);
        }
    }
    return numCommands;
}",1,1,redis-cli.c,cliLegacyCountCommands,,false,835,847,cliLegacyCountCommands,,,70,"size_t cliLegacyCountCommands (commandDocs*,sds)"
279864,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliGetServerVersion(void) {
    static const char *key = ""\nredis_version:"";
    redisReply *serverInfo = NULL;
    char *pos;

    if (config.server_version != NULL) {
        return config.server_version;
    }

    if (!context) return NULL;
    serverInfo = redisCommand(context, ""INFO SERVER"");
    if (serverInfo == NULL || serverInfo->type == REDIS_REPLY_ERROR) {
        freeReplyObject(serverInfo);
        return sdsempty();
    }

    assert(serverInfo->type == REDIS_REPLY_STRING || serverInfo->type == REDIS_REPLY_VERB);
    sds info = serverInfo->str;

    /* Finds the first appearance of ""redis_version"" in the INFO SERVER reply. */
    pos = strstr(info, key);
    if (pos) {
        pos += strlen(key);
        char *end = strchr(pos, '\r');
        if (end) {
            sds version = sdsnewlen(pos, end - pos);
            freeReplyObject(serverInfo);
            config.server_version = version;
            return version;
        }
    }
    freeReplyObject(serv...",1,1,redis-cli.c,cliGetServerVersion,,false,852,885,cliGetServerVersion,,,71,sds cliGetServerVersion (void)
279975,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliLegacyInitHelp(dict *groups) {
    sds serverVersion = cliGetServerVersion();
    
    /* Scan the commandDocs array and fill in the entries */
    helpEntriesLen = cliLegacyCountCommands(redisCommandTable, serverVersion);
    helpEntries = zmalloc(sizeof(helpEntry)*helpEntriesLen);

    helpEntriesLen = cliLegacyInitCommandHelpEntries(redisCommandTable, groups, serverVersion);
    cliInitGroupHelpEntries(groups);

    qsort(helpEntries, helpEntriesLen, sizeof(helpEntry), helpEntryCompare);
    dictRelease(groups);
}",1,1,redis-cli.c,cliLegacyInitHelp,,false,887,899,cliLegacyInitHelp,,,72,void cliLegacyInitHelp (dict*)
280012,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliInitHelp(void) {
    /* Dict type for a set of strings, used to collect names of command groups. */
    dictType groupsdt = {
        dictSdsHash,                /* hash function */
        NULL,                       /* key dup */
        NULL,                       /* val dup */
        dictSdsKeyCompare,          /* key compare */
        dictSdsDestructor,          /* key destructor */
        NULL,                       /* val destructor */
        NULL                        /* allow to expand */
    };
    redisReply *commandTable;
    dict *groups;

    if (cliConnect(CC_QUIET) == REDIS_ERR) {
        /* Can not connect to the server, but we still want to provide
         * help, generate it only from the static cli_commands.c data instead. */
        groups = dictCreate(&groupsdt);
        cliLegacyInitHelp(groups);
        return;
    }
    commandTable = redisCommand(context, ""COMMAND DOCS"");
    if (commandTable == NULL || commandTable->type == REDIS_REPLY...",1,19,redis-cli.c,cliInitHelp,,false,904,949,cliInitHelp,,,73,void cliInitHelp (void)
280120,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliOutputCommandHelp(struct commandDocs *help, int group) {
    printf(""\r\n  \x1b[1m%s\x1b[0m \x1b[90m%s\x1b[0m\r\n"", help->name, help->params);
    printf(""  \x1b[33msummary:\x1b[0m %s\r\n"", help->summary);
    if (help->since != NULL) {
        printf(""  \x1b[33msince:\x1b[0m %s\r\n"", help->since);
    }
    if (group) {
        printf(""  \x1b[33mgroup:\x1b[0m %s\r\n"", help->group);
    }
}",1,1,redis-cli.c,cliOutputCommandHelp,,false,952,961,cliOutputCommandHelp,,,74,"void cliOutputCommandHelp (commandDocs*,int)"
280159,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliOutputGenericHelp(void) {
    sds version = cliVersion();
    printf(
        ""redis-cli %s\n""
        ""To get help about Redis commands type:\n""
        ""      \""help @<group>\"" to get a list of commands in <group>\n""
        ""      \""help <command>\"" for help on <command>\n""
        ""      \""help <tab>\"" to get a list of possible help topics\n""
        ""      \""quit\"" to exit\n""
        ""\n""
        ""To set redis-cli preferences:\n""
        ""      \"":set hints\"" enable online hints\n""
        ""      \"":set nohints\"" disable online hints\n""
        ""Set your preferences in ~/.redisclirc\n"",
        version
    );
    sdsfree(version);
}",1,1,redis-cli.c,cliOutputGenericHelp,,false,964,981,cliOutputGenericHelp,,,75,void cliOutputGenericHelp (void)
280173,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliOutputHelp(int argc, char **argv) {
    int i, j;
    char *group = NULL;
    helpEntry *entry;
    struct commandDocs *help;

    if (argc == 0) {
        cliOutputGenericHelp();
        return;
    } else if (argc > 0 && argv[0][0] == '@') {
        group = argv[0]+1;
    }

    if (helpEntries == NULL) {
        /* Initialize the help using the results of the COMMAND command.
         * In case we are using redis-cli help XXX, we need to init it. */
        cliInitHelp();
    }

    assert(argc > 0);
    for (i = 0; i < helpEntriesLen; i++) {
        entry = &helpEntries[i];
        if (entry->type != CLI_HELP_COMMAND) continue;

        help = &entry->docs;
        if (group == NULL) {
            /* Compare all arguments */
            if (argc <= entry->argc) {
                for (j = 0; j < argc; j++) {
                    if (strcasecmp(argv[j],entry->argv[j]) != 0) break;
                }
                if (j == argc) {
                    cliOutputCommand...",1,27,redis-cli.c,cliOutputHelp,,false,984,1024,cliOutputHelp,,,76,"void cliOutputHelp (int,char**)"
280320,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void completionCallback(const char *buf, linenoiseCompletions *lc) {
    size_t startpos = 0;
    int mask;
    int i;
    size_t matchlen;
    sds tmp;

    if (strncasecmp(buf,""help "",5) == 0) {
        startpos = 5;
        while (isspace(buf[startpos])) startpos++;
        mask = CLI_HELP_COMMAND | CLI_HELP_GROUP;
    } else {
        mask = CLI_HELP_COMMAND;
    }

    for (i = 0; i < helpEntriesLen; i++) {
        if (!(helpEntries[i].type & mask)) continue;

        matchlen = strlen(buf+startpos);
        if (strncasecmp(buf+startpos,helpEntries[i].full,matchlen) == 0) {
            tmp = sdsnewlen(buf,startpos);
            tmp = sdscat(tmp,helpEntries[i].full);
            linenoiseAddCompletion(lc,tmp);
            sdsfree(tmp);
        }
    }
}",1,15,redis-cli.c,completionCallback,,false,1027,1053,completionCallback,,,77,"void completionCallback (char*,linenoiseCompletions*)"
280429,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds addHintForArgument(sds hint, cliCommandArg *arg);",12,59,redis-cli.c,addHintForArgument,,false,1055,1055,addHintForArgument,,,78,"sds addHintForArgument (sds,cliCommandArg*)"
280435,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds addSeparator(sds str, size_t *len, char *separator, int is_last) {
    if (sdslen(str) > *len && !is_last) {
        str = sdscat(str, separator);
        *len = sdslen(str);
    }
    return str;
}",1,1,redis-cli.c,addSeparator,,false,1061,1067,addSeparator,,,79,"sds addSeparator (sds,size_t*,char*,int)"
280465,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clearMatchedArgs(cliCommandArg *args, int numargs) {
    for (int i = 0; i != numargs; ++i) {
        args[i].matched = 0;
        args[i].matched_token = 0;
        args[i].matched_name = 0;
        args[i].matched_all = 0;
        if (args[i].subargs) {
            clearMatchedArgs(args[i].subargs, args[i].numsubargs);
        }
    }
}",1,1,redis-cli.c,clearMatchedArgs,,false,1070,1080,clearMatchedArgs,,,80,"void clearMatchedArgs (cliCommandArg*,int)"
280529,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds addHintForArguments(sds hint, cliCommandArg *args, int numargs, char *separator) {
    int i, j, incomplete;
    size_t len=sdslen(hint);
    for (i = 0; i < numargs; i++) {
        if (!(args[i].flags & CMD_ARG_OPTIONAL)) {
            hint = addHintForArgument(hint, &args[i]);
            hint = addSeparator(hint, &len, separator, i == numargs-1);
            continue;
        }

        /* The rule is that successive ""optional"" arguments can appear in any order.
         * But if they are followed by a required argument, no more of those optional arguments
         * can appear after that.
         * 
         * This code handles all successive optional args together. This lets us show the
         * completion of the currently-incomplete optional arg first, if there is one.
         */
        for (j = i, incomplete = -1; j < numargs; j++) {
            if (!(args[j].flags & CMD_ARG_OPTIONAL)) break;
            if (args[j].matched != 0 && args[j].matched_all == 0) {
...",1,30,redis-cli.c,addHintForArguments,,false,1085,1127,addHintForArguments,,,81,"sds addHintForArguments (sds,cliCommandArg*,int,char*)"
280715,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds addHintForRepeatedArgument(sds hint, cliCommandArg *arg) {
    if (!(arg->flags & CMD_ARG_MULTIPLE)) {
        return hint;
    }

    /* The repeating part is always shown at the end of the argument's hint,
     * so we can safely clear its matched flags before printing it.
     */
    clearMatchedArgs(arg, 1);
        
    if (hint[0] != '\0') {
        hint = sdscat(hint, "" "");
    }
    hint = sdscat(hint, ""["");

    if (arg->flags & CMD_ARG_MULTIPLE_TOKEN) {
        hint = sdscat_orempty(hint, arg->token);
        if (arg->type != ARG_TYPE_PURE_TOKEN) {
            hint = sdscat(hint, "" "");
        }
    }

    switch (arg->type) {
     case ARG_TYPE_ONEOF:
        hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, ""|"");
        break;

    case ARG_TYPE_BLOCK:
        hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, "" "");
        break;

    case ARG_TYPE_PURE_TOKEN:
        break;

    default:
        hint = sdscat_orempty(hint, arg->di...",1,23,redis-cli.c,addHintForRepeatedArgument,,false,1132,1173,addHintForRepeatedArgument,,,82,"sds addHintForRepeatedArgument (sds,cliCommandArg*)"
280844,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds addHintForArgument(sds hint, cliCommandArg *arg) {
    if (arg->matched_all) {
        return hint;
    }

    /* Surround an optional arg with brackets, unless it's partially matched. */
    if ((arg->flags & CMD_ARG_OPTIONAL) && !arg->matched) {
        hint = sdscat(hint, ""["");
    }

    /* Start with the token, if present and not matched. */
    if (arg->token != NULL && !arg->matched_token) {
        hint = sdscat_orempty(hint, arg->token);
        if (arg->type != ARG_TYPE_PURE_TOKEN) {
            hint = sdscat(hint, "" "");
        }
    }

    /* Add the body of the syntax string. */
    switch (arg->type) {
     case ARG_TYPE_ONEOF:
        if (arg->matched == 0) {
            hint = addHintForArguments(hint, arg->subargs, arg->numsubargs, ""|"");
        } else {
            int i;
            for (i = 0; i < arg->numsubargs; i++) {
                if (arg->subargs[i].matched != 0) {
                    hint = addHintForArgument(hint, &arg->subargs[i]);
          ...",1,22,redis-cli.c,addHintForArgument,,false,1176,1230,addHintForArgument,,,83,"sds addHintForArgument (sds,cliCommandArg*)"
281039,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchArg(char **nextword, int numwords, cliCommandArg *arg);",12,70,redis-cli.c,matchArg,,false,1232,1232,matchArg,,,84,"int matchArg (char**,int,cliCommandArg*)"
281046,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchArgs(char **words, int numwords, cliCommandArg *args, int numargs);",12,82,redis-cli.c,matchArgs,,false,1233,1233,matchArgs,,,85,"int matchArgs (char**,int,cliCommandArg*,int)"
281054,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchNoTokenArg(char **nextword, int numwords, cliCommandArg *arg) {
    int i;
    switch (arg->type) {
    case ARG_TYPE_BLOCK: {
        arg->matched += matchArgs(nextword, numwords, arg->subargs, arg->numsubargs);

        /* All the subargs must be matched for the block to match. */
        arg->matched_all = 1;
        for (i = 0; i < arg->numsubargs; i++) {
            if (arg->subargs[i].matched_all == 0) {
                arg->matched_all = 0;
            }
        }
        break;
    }
    case ARG_TYPE_ONEOF: {
        for (i = 0; i < arg->numsubargs; i++) {
            if (matchArg(nextword, numwords, &arg->subargs[i])) {
                arg->matched += arg->subargs[i].matched;
                arg->matched_all = arg->subargs[i].matched_all;
                break;
            }
        }
        break;
    }

    case ARG_TYPE_INTEGER:
    case ARG_TYPE_UNIX_TIME: {
        long long value;
        if (sscanf(*nextword, ""%lld"", &value)) {
            arg->matc...",1,1,redis-cli.c,matchNoTokenArg,,false,1236,1298,matchNoTokenArg,,,86,"int matchNoTokenArg (char**,int,cliCommandArg*)"
281272,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchToken(char **nextword, cliCommandArg *arg) {
    if (strcasecmp(arg->token, nextword[0]) != 0) {
        return 0;
    }
    arg->matched_token = 1;
    arg->matched = 1;
    return 1;
}",1,1,redis-cli.c,matchToken,,false,1301,1308,matchToken,,,87,"int matchToken (char**,cliCommandArg*)"
281303,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchArgOnce(char **nextword, int numwords, cliCommandArg *arg) {
    /* First match the token, if present. */
    if (arg->token != NULL) {
        if (!matchToken(nextword, arg)) {
            return 0;
        }
        if (arg->type == ARG_TYPE_PURE_TOKEN) {
            arg->matched_all = 1;
            return 1;
        }
        if (numwords == 1) {
            return 1;
        }
        nextword++;
        numwords--;
    }

    /* Then match the rest of the argument. */
    if (!matchNoTokenArg(nextword, numwords, arg)) {
        return 0;
    }
    return arg->matched;
}",1,1,redis-cli.c,matchArgOnce,,false,1314,1336,matchArgOnce,,,88,"int matchArgOnce (char**,int,cliCommandArg*)"
281363,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchArg(char **nextword, int numwords, cliCommandArg *arg) {
    int matchedWords = 0;
    int matchedOnce = matchArgOnce(nextword, numwords, arg);
    if (!(arg->flags & CMD_ARG_MULTIPLE)) {
        return matchedOnce;
    }

    /* Found one match; now match a ""multiple"" argument as many times as possible. */
    matchedWords += matchedOnce;
    while (arg->matched_all && matchedWords < numwords) {
        clearMatchedArgs(arg, 1);
        if (arg->token != NULL && !(arg->flags & CMD_ARG_MULTIPLE_TOKEN)) {
            /* The token only appears the first time; the rest of the times,
             * pretend we saw it so we don't hint it.
             */
            matchedOnce = matchNoTokenArg(nextword + matchedWords, numwords - matchedWords, arg);
            if (arg->matched) {
                arg->matched_token = 1;
            }
        } else {
            matchedOnce = matchArgOnce(nextword + matchedWords, numwords - matchedWords, arg);
        }
        matchedWor...",1,23,redis-cli.c,matchArg,,false,1341,1367,matchArg,,,89,"int matchArg (char**,int,cliCommandArg*)"
281470,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchOneOptionalArg(char **words, int numwords, cliCommandArg *args, int numargs, int *matchedarg) {
    for (int nextword = 0, nextarg = 0; nextword != numwords && nextarg != numargs; ++nextarg) {
        if (args[nextarg].matched) {
            /* Already matched this arg. */
            continue;
        }

        int matchedWords = matchArg(&words[nextword], numwords - nextword, &args[nextarg]);
        if (matchedWords != 0) {
            *matchedarg = nextarg;
            return matchedWords;
        }
    }
    return 0;
}",1,1,redis-cli.c,matchOneOptionalArg,,false,1372,1386,matchOneOptionalArg,,,90,"int matchOneOptionalArg (char**,int,cliCommandArg*,int,int*)"
281535,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchOptionalArgs(char **words, int numwords, cliCommandArg *args, int numargs) {
    int nextword = 0;
    int matchedarg = -1, lastmatchedarg = -1;
    while (nextword != numwords) {
        int matchedWords = matchOneOptionalArg(&words[nextword], numwords - nextword, args, numargs, &matchedarg);
        if (matchedWords == 0) {
            break;
        }
        /* Successfully matched an optional arg; mark any previous match as completed
         * so it won't be partially hinted.
         */
        if (lastmatchedarg != -1) {
            args[lastmatchedarg].matched_all = 1;
        }
        lastmatchedarg = matchedarg;
        nextword += matchedWords;
    }
    return nextword;
}",1,1,redis-cli.c,matchOptionalArgs,,false,1389,1407,matchOptionalArgs,,,91,"int matchOptionalArgs (char**,int,cliCommandArg*,int)"
281604,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int matchArgs(char **words, int numwords, cliCommandArg *args, int numargs) {
    int nextword, nextarg, matchedWords;
    for (nextword = 0, nextarg = 0; nextword != numwords && nextarg != numargs; ++nextarg) {
        /* Optional args can occur in any order. Collect a range of consecutive optional args
         * and try to match them as a group against the next input words.
         */
        if (args[nextarg].flags & CMD_ARG_OPTIONAL) {
            int lastoptional;
            for (lastoptional = nextarg; lastoptional < numargs; lastoptional++) {
                if (!(args[lastoptional].flags & CMD_ARG_OPTIONAL)) break;
            }
            matchedWords = matchOptionalArgs(&words[nextword], numwords - nextword, &args[nextarg], lastoptional - nextarg);
            nextarg = lastoptional - 1;
        } else {
            matchedWords = matchArg(&words[nextword], numwords - nextword, &args[nextarg]);
            if (matchedWords == 0) {
                /* Couldn't mat...",1,34,redis-cli.c,matchArgs,,false,1410,1434,matchArgs,,,92,"int matchArgs (char**,int,cliCommandArg*,int)"
281724,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds makeHint(char **inputargv, int inputargc, int cmdlen, struct commandDocs docs) {
    sds hint;

    if (docs.args) {
        /* Remove arguments from the returned hint to show only the
         * ones the user did not yet type. */
        clearMatchedArgs(docs.args, docs.numargs);
        hint = sdsempty();
        int matchedWords = 0;
        if (inputargv && inputargc)
            matchedWords = matchArgs(inputargv + cmdlen, inputargc - cmdlen, docs.args, docs.numargs);
        if (matchedWords == inputargc - cmdlen) {
            hint = addHintForArguments(hint, docs.args, docs.numargs, "" "");
        }
        return hint;
    }

    /* If arg specs are not available, show the hint string until the user types something. */
    if (inputargc <= cmdlen) {
        hint = sdsnew(docs.params);
    } else {
        hint = sdsempty();
    }
    return hint;
}",1,1,redis-cli.c,makeHint,,false,1441,1465,makeHint,,,93,"sds makeHint (char**,int,int,commandDocs)"
281810,METHOD,redis-cli.c:<global>,TYPE_DECL,"static helpEntry* findHelpEntry(int argc, char **argv) {
    helpEntry *entry = NULL;
    int i, rawargc, matchlen = 0;
    sds *rawargv;

    for (i = 0; i < helpEntriesLen; i++) {
        if (!(helpEntries[i].type & CLI_HELP_COMMAND)) continue;

        rawargv = helpEntries[i].argv;
        rawargc = helpEntries[i].argc;
        if (rawargc <= argc) {
            int j;
            for (j = 0; j < rawargc; j++) {
                if (strcasecmp(rawargv[j],argv[j])) {
                    break;
                }
            }
            if (j == rawargc && rawargc > matchlen) {
                matchlen = rawargc;
                entry = &helpEntries[i];
            }
        }
    }
    return entry;
}",1,36,redis-cli.c,findHelpEntry,,false,1468,1492,findHelpEntry,,,94,"helpEntry findHelpEntry (int,char**)"
281912,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds getHintForInput(const char *charinput) {
    sds hint = NULL;
    int inputargc, inputlen = strlen(charinput);
    sds *inputargv = sdssplitargs(charinput, &inputargc);
    int endspace = inputlen && isspace(charinput[inputlen-1]);

    /* Don't match the last word until the user has typed a space after it. */
    int matchargc = endspace ? inputargc : inputargc - 1;

    helpEntry *entry = findHelpEntry(matchargc, inputargv);
    if (entry) {
       hint = makeHint(inputargv, matchargc, entry->argc, entry->docs);
    }
    sdsfreesplitres(inputargv, inputargc);
    return hint;
}",1,1,redis-cli.c,getHintForInput,,false,1495,1510,getHintForInput,,,95,sds getHintForInput (char*)
281979,METHOD,redis-cli.c:<global>,TYPE_DECL,"static char *hintsCallback(const char *buf, int *color, int *bold) {
    if (!pref.hints) return NULL;

    sds hint = getHintForInput(buf);
    if (hint == NULL) {
        return NULL;
    }

    *color = 90;
    *bold = 0;

    /* Add an initial space if needed. */
    int len = strlen(buf);
    int endspace = len && isspace(buf[len-1]);
    if (!endspace) {
        sds newhint = sdsnewlen("" "",1);
        newhint = sdscatsds(newhint,hint);
        sdsfree(hint);
        hint = newhint;
    }

    return hint;
}",1,1,redis-cli.c,hintsCallback,,false,1513,1535,hintsCallback,,,96,"char* hintsCallback (char*,int*,int*)"
282052,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void freeHintsCallback(void *ptr) {
    sdsfree(ptr);
}",1,1,redis-cli.c,freeHintsCallback,,false,1537,1539,freeHintsCallback,,,97,void freeHintsCallback (void*)
282059,METHOD,redis-cli.c:<global>,TYPE_DECL,"void cliRestoreTTY(void) {
    if (orig_termios_saved)
        tcsetattr(STDIN_FILENO, TCSANOW, &orig_termios);
}",1,1,redis-cli.c,cliRestoreTTY,,false,1546,1549,cliRestoreTTY,,,98,void cliRestoreTTY (void)
282072,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliPressAnyKeyTTY(void) {
    if (!isatty(STDIN_FILENO)) return;
    if (!orig_termios_saved) {
        if (tcgetattr(STDIN_FILENO, &orig_termios) == -1) return;
        atexit(cliRestoreTTY);
        orig_termios_saved = 1;
    }
    struct termios mode = orig_termios;
    mode.c_lflag &= ~(ECHO | ICANON); /* echoing off, canonical off */
    tcsetattr(STDIN_FILENO, TCSANOW, &mode);
}",1,1,redis-cli.c,cliPressAnyKeyTTY,,false,1552,1562,cliPressAnyKeyTTY,,,99,void cliPressAnyKeyTTY (void)
282119,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliAuth(redisContext *ctx, char *user, char *auth) {
    redisReply *reply;
    if (auth == NULL) return REDIS_OK;

    if (user == NULL)
        reply = redisCommand(ctx,""AUTH %s"",auth);
    else
        reply = redisCommand(ctx,""AUTH %s %s"",user,auth);

    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr, ""AUTH failed: %s\n"", reply->str);
    }
    freeReplyObject(reply);
    return result;
}",1,1,redis-cli.c,cliAuth,,false,1569,1590,cliAuth,,,100,"int cliAuth (redisContext*,char*,char*)"
282188,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliSelect(void) {
    redisReply *reply;
    if (config.conn_info.input_dbnum == config.dbnum) return REDIS_OK;

    reply = redisCommand(context,""SELECT %d"",config.conn_info.input_dbnum);
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr,""SELECT %d failed: %s\n"",config.conn_info.input_dbnum,reply->str);
    } else {
        config.dbnum = config.conn_info.input_dbnum;
        cliRefreshPrompt();
    }
    freeReplyObject(reply);
    return result;
}",1,1,redis-cli.c,cliSelect,,false,1593,1613,cliSelect,,,101,int cliSelect (void)
282268,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliSwitchProto(void) {
    redisReply *reply;
    if (!config.resp3 || config.resp2) return REDIS_OK;

    reply = redisCommand(context,""HELLO 3"");
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }

    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr,""HELLO 3 failed: %s\n"",reply->str);
        if (config.resp3 == 1) {
            result = REDIS_ERR;
        } else if (config.resp3 == 2) {
            result = REDIS_OK;
        }
    }

    /* Retrieve server version string for later use. */
    for (size_t i = 0; i < reply->elements; i += 2) {
        assert(reply->element[i]->type == REDIS_REPLY_STRING);
        char *key = reply->element[i]->str;
        if (!strcmp(key, ""version"")) {
            assert(reply->element[i + 1]->type == REDIS_REPLY_STRING);
            config.server_version = sdsnew(reply->element[i + 1]->str);
        }
    }
    freeReplyObject(reply);
    config.c...",1,1,redis-cli.c,cliSwitchProto,,false,1616,1648,cliSwitchProto,,,102,int cliSwitchProto (void)
282416,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliConnect(int flags) {
    if (context == NULL || flags & CC_FORCE) {
        if (context != NULL) {
            redisFree(context);
            config.dbnum = 0;
            config.in_multi = 0;
            cliRefreshPrompt();
        }

        /* Do not use hostsocket when we got redirected in cluster mode */
        if (config.hostsocket == NULL ||
            (config.cluster_mode && config.cluster_reissue_command)) {
            context = redisConnect(config.conn_info.hostip,config.conn_info.hostport);
        } else {
            context = redisConnectUnix(config.hostsocket);
        }

        if (!context->err && config.tls) {
            const char *err = NULL;
            if (cliSecureConnection(context, config.sslconfig, &err) == REDIS_ERR && err) {
                fprintf(stderr, ""Could not negotiate a TLS connection: %s\n"", err);
                redisFree(context);
                context = NULL;
                return REDIS_ERR;
            }
        }

   ...",1,35,redis-cli.c,cliConnect,,false,1654,1724,cliConnect,,,103,int cliConnect (int)
282648,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliSendAsking(void) {
    redisReply *reply;

    config.cluster_send_asking = 0;
    if (context == NULL) {
        return REDIS_ERR;
    }
    reply = redisCommand(context,""ASKING"");
    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        return REDIS_ERR;
    }
    int result = REDIS_OK;
    if (reply->type == REDIS_REPLY_ERROR) {
        result = REDIS_ERR;
        fprintf(stderr,""ASKING failed: %s\n"",reply->str);
    }
    freeReplyObject(reply);
    return result;
}",1,1,redis-cli.c,cliSendAsking,,false,1728,1747,cliSendAsking,,,104,int cliSendAsking (void)
282705,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliPrintContextError(void) {
    if (context == NULL) return;
    fprintf(stderr,""Error: %s\n"",context->errstr);
}",1,1,redis-cli.c,cliPrintContextError,,false,1749,1752,cliPrintContextError,,,105,void cliPrintContextError (void)
282722,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int isInvalidateReply(redisReply *reply) {
    return reply->type == REDIS_REPLY_PUSH && reply->elements == 2 &&
        reply->element[0]->type == REDIS_REPLY_STRING &&
        !strncmp(reply->element[0]->str, ""invalidate"", 10) &&
        reply->element[1]->type == REDIS_REPLY_ARRAY;
}",1,1,redis-cli.c,isInvalidateReply,,false,1754,1759,isInvalidateReply,,,106,int isInvalidateReply (redisReply*)
282771,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliFormatInvalidateTTY(redisReply *r) {
    sds out = sdsnew(""-> invalidate: "");

    for (size_t i = 0; i < r->element[1]->elements; i++) {
        redisReply *key = r->element[1]->element[i];
        assert(key->type == REDIS_REPLY_STRING);

        out = sdscatfmt(out, ""'%s'"", key->str, key->len);
        if (i < r->element[1]->elements - 1)
            out = sdscatlen(out, "", "", 2);
    }

    return sdscatlen(out, ""\n"", 1);
}",1,1,redis-cli.c,cliFormatInvalidateTTY,,false,1764,1777,cliFormatInvalidateTTY,,,107,sds cliFormatInvalidateTTY (redisReply*)
282852,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliIsMultilineValueTTY(redisReply *r) {
    switch (r->type) {
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
        if (r->elements == 0) return 0;
        if (r->elements > 1) return 1;
        return cliIsMultilineValueTTY(r->element[0]);
    case REDIS_REPLY_MAP:
        if (r->elements == 0) return 0;
        if (r->elements > 2) return 1;
        return cliIsMultilineValueTTY(r->element[1]);
    default:
        return 0;
    }
}",1,1,redis-cli.c,cliIsMultilineValueTTY,,false,1780,1795,cliIsMultilineValueTTY,,,108,int cliIsMultilineValueTTY (redisReply*)
282923,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliFormatReplyTTY(redisReply *r, char *prefix) {
    sds out = sdsempty();
    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscatprintf(out,""(error) %s\n"", r->str);
    break;
    case REDIS_REPLY_STATUS:
        out = sdscat(out,r->str);
        out = sdscat(out,""\n"");
    break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""(integer) %lld\n"",r->integer);
    break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""(double) %s\n"",r->str);
    break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        /* If you are producing output for the standard output we want
        * a more interesting output with quoted characters and so forth,
        * unless it's a verbatim string type. */
        if (r->type == REDIS_REPLY_STRING) {
            out = sdscatrepr(out,r->str,r->len);
            out = sdscat(out,""\n"");
        } else {
            out = sdscatlen(out,r->str,r->len);
            out = sdscat(out,""\n"");
       ...",1,1,redis-cli.c,cliFormatReplyTTY,,false,1797,1913,cliFormatReplyTTY,,,109,"sds cliFormatReplyTTY (redisReply*,char*)"
283342,METHOD,redis-cli.c:<global>,TYPE_DECL,"int isPubsubPush(redisReply *r) {
    if (r == NULL ||
        r->type != (config.current_resp3 ? REDIS_REPLY_PUSH : REDIS_REPLY_ARRAY) ||
        r->elements < 3 ||
        r->element[0]->type != REDIS_REPLY_STRING)
    {
        return 0;
    }
    char *str = r->element[0]->str;
    size_t len = r->element[0]->len;
    /* Check if it is [p|s][un]subscribe or [p|s]message, but even simpler, we
     * just check that it ends with ""message"" or ""subscribe"". */
    return ((len >= strlen(""message"") &&
             !strcmp(str + len - strlen(""message""), ""message"")) ||
            (len >= strlen(""subscribe"") &&
             !strcmp(str + len - strlen(""subscribe""), ""subscribe"")));
}",1,1,redis-cli.c,isPubsubPush,,false,1916,1932,isPubsubPush,,,110,int isPubsubPush (redisReply*)
283431,METHOD,redis-cli.c:<global>,TYPE_DECL,"int isColorTerm(void) {
    char *t = getenv(""TERM"");
    return t != NULL && strstr(t,""xterm"") != NULL;
}",1,1,redis-cli.c,isColorTerm,,false,1934,1937,isColorTerm,,,111,int isColorTerm (void)
283451,METHOD,redis-cli.c:<global>,TYPE_DECL,"sds sdscatcolor(sds o, char *s, size_t len, char *color) {
    if (!isColorTerm()) return sdscatlen(o,s,len);

    int bold = strstr(color,""bold"") != NULL;
    int ccode = 37; /* Defaults to white. */
    if (strstr(color,""red"")) ccode = 31;
    else if (strstr(color,""green"")) ccode = 32;
    else if (strstr(color,""yellow"")) ccode = 33;
    else if (strstr(color,""blue"")) ccode = 34;
    else if (strstr(color,""magenta"")) ccode = 35;
    else if (strstr(color,""cyan"")) ccode = 36;
    else if (strstr(color,""white"")) ccode = 37;

    o = sdscatfmt(o,""\033[%i;%i;49m"",bold,ccode);
    o = sdscatlen(o,s,len);
    o = sdscat(o,""\033[0m"");
    return o;
}",1,1,redis-cli.c,sdscatcolor,,false,1941,1958,sdscatcolor,,,112,"sds sdscatcolor (sds,char*,size_t,char*)"
283568,METHOD,redis-cli.c:<global>,TYPE_DECL,"sds sdsCatColorizedLdbReply(sds o, char *s, size_t len) {
    char *color = ""white"";

    if (strstr(s,""<debug>"")) color = ""bold"";
    if (strstr(s,""<redis>"")) color = ""green"";
    if (strstr(s,""<reply>"")) color = ""cyan"";
    if (strstr(s,""<error>"")) color = ""red"";
    if (strstr(s,""<hint>"")) color = ""bold"";
    if (strstr(s,""<value>"") || strstr(s,""<retval>"")) color = ""magenta"";
    if (len > 4 && isdigit(s[3])) {
        if (s[1] == '>') color = ""yellow""; /* Current line. */
        else if (s[2] == '#') color = ""bold""; /* Break point. */
    }
    return sdscatcolor(o,s,len,color);
}",1,1,redis-cli.c,sdsCatColorizedLdbReply,,false,1962,1976,sdsCatColorizedLdbReply,,,113,"sds sdsCatColorizedLdbReply (sds,char*,size_t)"
283669,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliFormatReplyRaw(redisReply *r) {
    sds out = sdsempty(), tmp;
    size_t i;

    switch (r->type) {
    case REDIS_REPLY_NIL:
        /* Nothing... */
        break;
    case REDIS_REPLY_ERROR:
        out = sdscatlen(out,r->str,r->len);
        out = sdscatlen(out,""\n"",1);
        break;
    case REDIS_REPLY_STATUS:
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        if (r->type == REDIS_REPLY_STATUS && config.eval_ldb) {
            /* The Lua debugger replies with arrays of simple (status)
             * strings. We colorize the output for more fun if this
             * is a debugging session. */

            /* Detect the end of a debugging session. */
            if (strstr(r->str,""<endsession>"") == r->str) {
                config.enable_ldb_on_eval = 0;
                config.eval_ldb = 0;
                config.eval_ldb_end = 1; /* Signal the caller session ended. */
                config.output = OUTPUT_STANDARD;
                cliRefreshPrompt...",1,32,redis-cli.c,cliFormatReplyRaw,,false,1978,2049,cliFormatReplyRaw,,,114,sds cliFormatReplyRaw (redisReply*)
283949,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliFormatReplyCSV(redisReply *r) {
    unsigned int i;

    sds out = sdsempty();
    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscat(out,""ERROR,"");
        out = sdscatrepr(out,r->str,strlen(r->str));
    break;
    case REDIS_REPLY_STATUS:
        out = sdscatrepr(out,r->str,r->len);
    break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""%lld"",r->integer);
    break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""%s"",r->str);
        break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        out = sdscatrepr(out,r->str,r->len);
    break;
    case REDIS_REPLY_NIL:
        out = sdscat(out,""NULL"");
    break;
    case REDIS_REPLY_BOOL:
        out = sdscat(out,r->integer ? ""true"" : ""false"");
    break;
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
    case REDIS_REPLY_MAP: /* CSV has no map type, just output flat list. */
        for (i = 0; i < r->elements; i++) {
        ...",1,1,redis-cli.c,cliFormatReplyCSV,,false,2051,2095,cliFormatReplyCSV,,,115,sds cliFormatReplyCSV (redisReply*)
284119,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds jsonStringOutput(sds out, const char *p, int len, int mode) {
    if (mode == OUTPUT_JSON) {
        return escapeJsonString(out, p, len);
    } else if (mode == OUTPUT_QUOTED_JSON) {
        /* Need to double-quote backslashes */
        sds tmp = sdscatrepr(sdsempty(), p, len);
        int tmplen = sdslen(tmp);
        char *n = tmp;
        while (tmplen--) {
            if (*n == '\\') out = sdscatlen(out, ""\\\\"", 2);
            else out = sdscatlen(out, n, 1);
            n++;
        }

        sdsfree(tmp);
        return out;
    } else {
        assert(0);
    }
}",1,16,redis-cli.c,jsonStringOutput,,false,2099,2118,jsonStringOutput,,,116,"sds jsonStringOutput (sds,char*,int,int)"
284198,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliFormatReplyJson(sds out, redisReply *r, int mode) {
    unsigned int i;

    switch (r->type) {
    case REDIS_REPLY_ERROR:
        out = sdscat(out,""error:"");
        out = jsonStringOutput(out,r->str,strlen(r->str),mode);
        break;
    case REDIS_REPLY_STATUS:
        out = jsonStringOutput(out,r->str,r->len,mode);
        break;
    case REDIS_REPLY_INTEGER:
        out = sdscatprintf(out,""%lld"",r->integer);
        break;
    case REDIS_REPLY_DOUBLE:
        out = sdscatprintf(out,""%s"",r->str);
        break;
    case REDIS_REPLY_STRING:
    case REDIS_REPLY_VERB:
        out = jsonStringOutput(out,r->str,r->len,mode);
        break;
    case REDIS_REPLY_NIL:
        out = sdscat(out,""null"");
        break;
    case REDIS_REPLY_BOOL:
        out = sdscat(out,r->integer ? ""true"" : ""false"");
        break;
    case REDIS_REPLY_ARRAY:
    case REDIS_REPLY_SET:
    case REDIS_REPLY_PUSH:
        out = sdscat(out,""["");
        for (i = 0; i < r->elements; i++ ) {
 ...",1,1,redis-cli.c,cliFormatReplyJson,,false,2120,2189,cliFormatReplyJson,,,117,"sds cliFormatReplyJson (sds,redisReply*,int)"
284497,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds cliFormatReply(redisReply *reply, int mode, int verbatim) {
    sds out;

    if (verbatim) {
        out = cliFormatReplyRaw(reply);
    }  else if (mode == OUTPUT_STANDARD) {
        out = cliFormatReplyTTY(reply, """");
    } else if (mode == OUTPUT_RAW) {
        out = cliFormatReplyRaw(reply);
        out = sdscatsds(out, config.cmd_delim);
    } else if (mode == OUTPUT_CSV) {
        out = cliFormatReplyCSV(reply);
        out = sdscatlen(out, ""\n"", 1);
    } else if (mode == OUTPUT_JSON || mode == OUTPUT_QUOTED_JSON) {
        out = cliFormatReplyJson(sdsempty(), reply, mode);
        out = sdscatlen(out, ""\n"", 1);
    } else {
        fprintf(stderr, ""Error:  Unknown output encoding %d\n"", mode);
        exit(1);
    }

    return out;
}",1,24,redis-cli.c,cliFormatReply,,false,2192,2214,cliFormatReply,,,118,"sds cliFormatReply (redisReply*,int,int)"
284602,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliPushHandler(void *privdata, void *reply) {
    UNUSED(privdata);
    sds out;

    if (config.output == OUTPUT_STANDARD && isInvalidateReply(reply)) {
        out = cliFormatInvalidateTTY(reply);
    } else {
        out = cliFormatReply(reply, config.output, 0);
    }

    fwrite(out, sdslen(out), 1, stdout);

    freeReplyObject(reply);
    sdsfree(out);
}",1,4,redis-cli.c,cliPushHandler,,false,2217,2231,cliPushHandler,,,119,"void cliPushHandler (void*,void*)"
284651,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliReadReply(int output_raw_strings) {
    void *_reply;
    redisReply *reply;
    sds out = NULL;
    int output = 1;

    if (config.last_reply) {
        freeReplyObject(config.last_reply);
        config.last_reply = NULL;
    }

    if (redisGetReply(context,&_reply) != REDIS_OK) {
        if (config.blocking_state_aborted) {
            config.blocking_state_aborted = 0;
            config.monitor_mode = 0;
            config.pubsub_mode = 0;
            return cliConnect(CC_FORCE);
        }

        if (config.shutdown) {
            redisFree(context);
            context = NULL;
            return REDIS_OK;
        }
        if (config.interactive) {
            /* Filter cases where we should reconnect */
            if (context->err == REDIS_ERR_IO &&
                (errno == ECONNRESET || errno == EPIPE))
                return REDIS_ERR;
            if (context->err == REDIS_ERR_EOF)
                return REDIS_ERR;
        }
        cliPrintContextError(...",1,30,redis-cli.c,cliReadReply,,false,2233,2320,cliReadReply,,,120,int cliReadReply (int)
284965,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void cliWaitForMessagesOrStdin(void) {
    int show_info = config.output != OUTPUT_RAW && (isatty(STDOUT_FILENO) ||
                                                    getenv(""FAKETTY""));
    int use_color = show_info && isColorTerm();
    cliPressAnyKeyTTY();
    while (config.pubsub_mode) {
        /* First check if there are any buffered replies. */
        redisReply *reply;
        do {
            if (redisGetReplyFromReader(context, (void **)&reply) != REDIS_OK) {
                cliPrintContextError();
                exit(1);
            }
            if (reply) {
                sds out = cliFormatReply(reply, config.output, 0);
                fwrite(out,sdslen(out),1,stdout);
                fflush(stdout);
                sdsfree(out);
            }
        } while(reply);

        /* Wait for input, either on the Redis socket or on stdin. */
        struct timeval tv;
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(context->fd, &readfds);
     ...",1,37,redis-cli.c,cliWaitForMessagesOrStdin,,false,2323,2385,cliWaitForMessagesOrStdin,,,121,void cliWaitForMessagesOrStdin (void)
285158,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int cliSendCommand(int argc, char **argv, long repeat) {
    char *command = argv[0];
    size_t *argvlen;
    int j, output_raw;

    if (context == NULL) return REDIS_ERR;

    output_raw = 0;
    if (!strcasecmp(command,""info"") ||
        !strcasecmp(command,""lolwut"") ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""htstats"")) ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""htstats-key"")) ||
        (argc >= 2 && !strcasecmp(command,""debug"") &&
                       !strcasecmp(argv[1],""client-eviction"")) ||
        (argc >= 2 && !strcasecmp(command,""memory"") &&
                      (!strcasecmp(argv[1],""malloc-stats"") ||
                       !strcasecmp(argv[1],""doctor""))) ||
        (argc == 2 && !strcasecmp(command,""cluster"") &&
                      (!strcasecmp(argv[1],""nodes"") ||
                       !strcasecmp(argv[1],""info""))) ||
        (argc >= 2 && !st...",1,24,redis-cli.c,cliSendCommand,,false,2387,2591,cliSendCommand,,,122,"int cliSendCommand (int,char**,long)"
286004,METHOD,redis-cli.c:<global>,TYPE_DECL,"static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {
    redisReply *reply = NULL;
    int tries = 0;
    va_list ap;

    assert(!c->err);
    while(reply == NULL) {
        while (c->err & (REDIS_ERR_IO | REDIS_ERR_EOF)) {
            printf(""\r\x1b[0K""); /* Cursor to left edge + clear line. */
            printf(""Reconnecting... %d\r"", ++tries);
            fflush(stdout);

            redisFree(c);
            c = redisConnect(config.conn_info.hostip,config.conn_info.hostport);
            if (!c->err && config.tls) {
                const char *err = NULL;
                if (cliSecureConnection(c, config.sslconfig, &err) == REDIS_ERR && err) {
                    fprintf(stderr, ""TLS Error: %s\n"", err);
                    exit(1);
                }
            }
            usleep(1000000);
        }

        va_start(ap,fmt);
        reply = redisvCommand(c,fmt,ap);
        va_end(ap);

        if (c->err && !(c->err & (REDIS_ERR_IO | REDIS_ER...",1,1,redis-cli.c,reconnectingRedisCommand,,false,2594,2632,reconnectingRedisCommand,,,123,"redisReply reconnectingRedisCommand (redisContext*,char*...)"
286143,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int parseOptions(int argc, char **argv) {
    int i;

    for (i = 1; i < argc; i++) {
        int lastarg = i==argc-1;

        if (!strcmp(argv[i],""-h"") && !lastarg) {
            sdsfree(config.conn_info.hostip);
            config.conn_info.hostip = sdsnew(argv[++i]);
        } else if (!strcmp(argv[i],""-h"") && lastarg) {
            usage(0);
        } else if (!strcmp(argv[i],""--help"")) {
            usage(0);
        } else if (!strcmp(argv[i],""-x"")) {
            config.stdin_lastarg = 1;
        } else if (!strcmp(argv[i], ""-X"") && !lastarg) {
            config.stdin_tag_arg = 1;
            config.stdin_tag_name = argv[++i];
        } else if (!strcmp(argv[i],""-p"") && !lastarg) {
            config.conn_info.hostport = atoi(argv[++i]);
            if (config.conn_info.hostport < 0 || config.conn_info.hostport > 65535) {
                fprintf(stderr, ""Invalid server port.\n"");
                exit(1);
            }
        } else if (!strcmp(argv[i],""-s"") && !last...",1,28,redis-cli.c,parseOptions,,false,2638,2969,parseOptions,,,124,"int parseOptions (int,char**)"
288272,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void parseEnv(void) {
    /* Set auth from env, but do not overwrite CLI arguments if passed */
    char *auth = getenv(REDIS_CLI_AUTH_ENV);
    if (auth != NULL && config.conn_info.auth == NULL) {
        config.conn_info.auth = auth;
    }

    char *cluster_yes = getenv(REDIS_CLI_CLUSTER_YES_ENV);
    if (cluster_yes != NULL && !strcmp(cluster_yes, ""1"")) {
        config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_YES;
    }
}",1,24,redis-cli.c,parseEnv,,false,2971,2982,parseEnv,,,125,void parseEnv (void)
288332,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void usage(int err) {
    sds version = cliVersion();
    FILE *target = err ? stderr: stdout;
    const char *tls_usage =
#ifdef USE_OPENSSL
""  --tls              Establish a secure TLS connection.\n""
""  --sni <host>       Server name indication for TLS.\n""
""  --cacert <file>    CA Certificate file to verify with.\n""
""  --cacertdir <dir>  Directory where trusted CA certificates are stored.\n""
""                     If neither cacert nor cacertdir are specified, the default\n""
""                     system-wide trusted root certs configuration will apply.\n""
""  --insecure         Allow insecure TLS connection by skipping cert validation.\n""
""  --cert <file>      Client certificate to authenticate with.\n""
""  --key <file>       Private key file to authenticate with.\n""
""  --tls-ciphers <list> Sets the list of preferred ciphers (TLSv1.2 and below)\n""
""                     in order of preference from highest to lowest separated by colon (\"":\"").\n""
""                     See the ci...",1,45,redis-cli.c,usage,,false,2984,3128,usage,,,126,void usage (int)
288373,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int confirmWithYes(char *msg, int ignore_force) {
    /* if --cluster-yes option is set and ignore_force is false,
     * do not prompt for an answer */
    if (!ignore_force &&
        (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_YES)) {
        return 1;
    }

    printf(""%s (type 'yes' to accept): "", msg);
    fflush(stdout);
    char buf[4];
    int nread = read(fileno(stdin),buf,4);
    buf[3] = '\0';
    return (nread != 0 && !strcmp(""yes"", buf));
}",1,48,redis-cli.c,confirmWithYes,,false,3130,3144,confirmWithYes,,,127,"int confirmWithYes (char*,int)"
288425,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int issueCommandRepeat(int argc, char **argv, long repeat) {
    /* In Lua debugging mode, we want to pass the ""help"" to Redis to get
     * it's own HELP message, rather than handle it by the CLI, see ldbRepl.
     *
     * For the normal Redis HELP, we can process it without a connection. */
    if (!config.eval_ldb &&
        (!strcasecmp(argv[0],""help"") || !strcasecmp(argv[0],""?"")))
    {
        cliOutputHelp(--argc, ++argv);
        return REDIS_OK;
    }

    while (1) {
        if (config.cluster_reissue_command || context == NULL ||
            context->err == REDIS_ERR_IO || context->err == REDIS_ERR_EOF)
        {
            if (cliConnect(CC_FORCE) != REDIS_OK) {
                cliPrintContextError();
                config.cluster_reissue_command = 0;
                return REDIS_ERR;
            }
        }
        config.cluster_reissue_command = 0;
        if (config.cluster_send_asking) {
            if (cliSendAsking() != REDIS_OK) {
                cliPri...",1,27,redis-cli.c,issueCommandRepeat,,false,3146,3189,issueCommandRepeat,,,128,"int issueCommandRepeat (int,char**,long)"
288548,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int issueCommand(int argc, char **argv) {
    return issueCommandRepeat(argc, argv, config.repeat);
}",1,1,redis-cli.c,issueCommand,,false,3191,3193,issueCommand,,,129,"int issueCommand (int,char**)"
288561,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds *cliSplitArgs(char *line, int *argc) {
    if (config.eval_ldb && (strstr(line,""eval "") == line ||
                            strstr(line,""e "") == line))
    {
        sds *argv = sds_malloc(sizeof(sds)*2);
        *argc = 2;
        int len = strlen(line);
        int elen = line[1] == ' ' ? 2 : 5; /* ""e "" or ""eval ""? */
        argv[0] = sdsnewlen(line,elen-1);
        argv[1] = sdsnewlen(line+elen,len-elen);
        return argv;
    } else {
        return sdssplitargs(line,argc);
    }
}",1,1,redis-cli.c,cliSplitArgs,,false,3201,3215,cliSplitArgs,,,130,"sds cliSplitArgs (char*,int*)"
288640,METHOD,redis-cli.c:<global>,TYPE_DECL,"void cliSetPreferences(char **argv, int argc, int interactive) {
    if (!strcasecmp(argv[0],"":set"") && argc >= 2) {
        if (!strcasecmp(argv[1],""hints"")) pref.hints = 1;
        else if (!strcasecmp(argv[1],""nohints"")) pref.hints = 0;
        else {
            printf(""%sunknown redis-cli preference '%s'\n"",
                interactive ? """" : "".redisclirc: "",
                argv[1]);
        }
    } else {
        printf(""%sunknown redis-cli internal command '%s'\n"",
            interactive ? """" : "".redisclirc: "",
            argv[0]);
    }
}",1,1,redis-cli.c,cliSetPreferences,,false,3220,3234,cliSetPreferences,,,131,"void cliSetPreferences (char**,int,int)"
288709,METHOD,redis-cli.c:<global>,TYPE_DECL,"void cliLoadPreferences(void) {
    sds rcfile = getDotfilePath(REDIS_CLI_RCFILE_ENV,REDIS_CLI_RCFILE_DEFAULT);
    if (rcfile == NULL) return;
    FILE *fp = fopen(rcfile,""r"");
    char buf[1024];

    if (fp) {
        while(fgets(buf,sizeof(buf),fp) != NULL) {
            sds *argv;
            int argc;

            argv = sdssplitargs(buf,&argc);
            if (argc > 0) cliSetPreferences(argv,argc,0);
            sdsfreesplitres(argv,argc);
        }
        fclose(fp);
    }
    sdsfree(rcfile);
}",1,32,redis-cli.c,cliLoadPreferences,,false,3237,3255,cliLoadPreferences,,,132,void cliLoadPreferences (void)
288773,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int isSensitiveCommand(int argc, char **argv) {
    if (!strcasecmp(argv[0],""auth"")) {
        return 1;
    } else if (argc > 1 &&
        !strcasecmp(argv[0],""acl"") &&
        !strcasecmp(argv[1],""setuser""))
    {
        return 1;
    } else if (argc > 2 &&
        !strcasecmp(argv[0],""config"") &&
        !strcasecmp(argv[1],""set"")) {
            for (int j = 2; j < argc; j = j+2) {
                if (!strcasecmp(argv[j],""masterauth"") ||
		    !strcasecmp(argv[j],""masteruser"") ||
		    !strcasecmp(argv[j],""requirepass"")) {
                    return 1;
                }
            }
            return 0;
    /* HELLO [protover [AUTH username password] [SETNAME clientname]] */
    } else if (argc > 4 && !strcasecmp(argv[0],""hello"")) {
        for (int j = 2; j < argc; j++) {
            int moreargs = argc - 1 - j;
            if (!strcasecmp(argv[j],""AUTH"") && moreargs >= 2) {
                return 1;
            } else if (!strcasecmp(argv[j],""SETNAME"") && moreargs) {
...",1,1,redis-cli.c,isSensitiveCommand,,false,3264,3310,isSensitiveCommand,,,133,"int isSensitiveCommand (int,char**)"
289018,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void repl(void) {
    sds historyfile = NULL;
    int history = 0;
    char *line;
    int argc;
    sds *argv;

    /* There is no need to initialize redis HELP when we are in lua debugger mode.
     * It has its own HELP and commands (COMMAND or COMMAND DOCS will fail and got nothing).
     * We will initialize the redis HELP after the Lua debugging session ended.*/
    if ((!config.eval_ldb) && isatty(fileno(stdin))) {
        /* Initialize the help using the results of the COMMAND command. */
        cliInitHelp();
    }

    config.interactive = 1;
    linenoiseSetMultiLine(1);
    linenoiseSetCompletionCallback(completionCallback);
    linenoiseSetHintsCallback(hintsCallback);
    linenoiseSetFreeHintsCallback(freeHintsCallback);

    /* Only use history and load the rc file when stdin is a tty. */
    if (isatty(fileno(stdin))) {
        historyfile = getDotfilePath(REDIS_CLI_HISTFILE_ENV,REDIS_CLI_HISTFILE_DEFAULT);
        //keep in-memory history always regardless i...",1,37,redis-cli.c,repl,,false,3312,3458,repl,,,134,void repl (void)
289473,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int noninteractive(int argc, char **argv) {
    int retval = 0;
    sds *sds_args = getSdsArrayFromArgv(argc, argv, config.quoted_input);

    if (!sds_args) {
        printf(""Invalid quoted string\n"");
        return 1;
    }

    if (config.stdin_lastarg) {
        sds_args = sds_realloc(sds_args, (argc + 1) * sizeof(sds));
        sds_args[argc] = readArgFromStdin();
        argc++;
    } else if (config.stdin_tag_arg) {
        int i = 0, tag_match = 0;

        for (; i < argc; i++) {
            if (strcmp(config.stdin_tag_name, sds_args[i]) != 0) continue;

            tag_match = 1;
            sdsfree(sds_args[i]);
            sds_args[i] = readArgFromStdin();
            break;
        }

        if (!tag_match) {
            sdsfreesplitres(sds_args, argc);
            fprintf(stderr, ""Using -X option but stdin tag not match.\n"");
            return 1;
        }
    }

    retval = issueCommand(argc, sds_args);
    sdsfreesplitres(sds_args, argc);
    while (config...",1,1,redis-cli.c,noninteractive,,false,3460,3502,noninteractive,,,135,"int noninteractive (int,char**)"
289613,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int evalMode(int argc, char **argv) {
    sds script = NULL;
    FILE *fp;
    char buf[1024];
    size_t nread;
    char **argv2;
    int j, got_comma, keys;
    int retval = REDIS_OK;

    while(1) {
        if (config.eval_ldb) {
            printf(
            ""Lua debugging session started, please use:\n""
            ""quit    -- End the session.\n""
            ""restart -- Restart the script in debug mode again.\n""
            ""help    -- Show Lua script debugging commands.\n\n""
            );
        }

        sdsfree(script);
        script = sdsempty();
        got_comma = 0;
        keys = 0;

        /* Load the script from the file, as an sds string. */
        fp = fopen(config.eval,""r"");
        if (!fp) {
            fprintf(stderr,
                ""Can't open file '%s': %s\n"", config.eval, strerror(errno));
            exit(1);
        }
        while((nread = fread(buf,1,sizeof(buf),fp)) != 0) {
            script = sdscatlen(script,buf,nread);
        }
     ...",1,27,redis-cli.c,evalMode,,false,3508,3589,evalMode,,,136,"int evalMode (int,char**)"
289889,METHOD,<empty>,<empty>,<empty>,1,,redis-cli.c,clusterManagerNode:<clinit>,,false,3605,,<clinit>,,,23,
289936,METHOD,redis-cli.c:<global>,TYPE_DECL,"typedef int clusterManagerCommandProc(int argc, char **argv);",13,60,redis-cli.c,clusterManagerCommandProc,,false,3675,3675,clusterManagerCommandProc,,,153,"int clusterManagerCommandProc (int,char**)"
289942,METHOD,redis-cli.c:<global>,TYPE_DECL,"typedef int (*clusterManagerOnReplyError)(redisReply *reply,
    clusterManagerNode *n, int bulk_idx);",13,40,redis-cli.c,clusterManagerOnReplyError,,false,3676,3677,clusterManagerOnReplyError,,,154,"int clusterManagerOnReplyError (redisReply*,clusterManagerNode*,int)"
289949,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerNewNode(char *ip, int port, int bus_port);",27,82,redis-cli.c,clusterManagerNewNode,,false,3681,3681,clusterManagerNewNode,,,155,"clusterManagerNode* clusterManagerNewNode (char*,int,int)"
289956,METHOD,redis-cli.c:<global>,TYPE_DECL,static clusterManagerNode *clusterManagerNodeByName(const char *name);,27,69,redis-cli.c,clusterManagerNodeByName,,false,3682,3682,clusterManagerNodeByName,,,156,clusterManagerNode* clusterManagerNodeByName (char*)
289961,METHOD,redis-cli.c:<global>,TYPE_DECL,static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char *n);,27,77,redis-cli.c,clusterManagerNodeByAbbreviatedName,,false,3683,3683,clusterManagerNodeByAbbreviatedName,,,157,clusterManagerNode* clusterManagerNodeByAbbreviatedName (char*)
289966,METHOD,redis-cli.c:<global>,TYPE_DECL,static void clusterManagerNodeResetSlots(clusterManagerNode *node);,13,66,redis-cli.c,clusterManagerNodeResetSlots,,false,3684,3684,clusterManagerNodeResetSlots,,,158,void clusterManagerNodeResetSlots (clusterManagerNode*)
289971,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err);",12,76,redis-cli.c,clusterManagerNodeIsCluster,,false,3685,3685,clusterManagerNodeIsCluster,,,159,"int clusterManagerNodeIsCluster (clusterManagerNode*,char**)"
289977,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
                                                   char *err);",13,61,redis-cli.c,clusterManagerPrintNotClusterNodeError,,false,3686,3687,clusterManagerPrintNotClusterNodeError,,,160,"void clusterManagerPrintNotClusterNodeError (clusterManagerNode*,char*)"
289983,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
                                      char **err);",12,49,redis-cli.c,clusterManagerNodeLoadInfo,,false,3688,3689,clusterManagerNodeLoadInfo,,,161,"int clusterManagerNodeLoadInfo (clusterManagerNode*,int,char**)"
289990,METHOD,redis-cli.c:<global>,TYPE_DECL,static int clusterManagerLoadInfoFromNode(clusterManagerNode *node);,12,67,redis-cli.c,clusterManagerLoadInfoFromNode,,false,3690,3690,clusterManagerLoadInfoFromNode,,,162,int clusterManagerLoadInfoFromNode (clusterManagerNode*)
289995,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err);",12,74,redis-cli.c,clusterManagerNodeIsEmpty,,false,3691,3691,clusterManagerNodeIsEmpty,,,163,"int clusterManagerNodeIsEmpty (clusterManagerNode*,char**)"
290001,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
    int ip_count, clusterManagerNode ***offending, int *offending_len);",12,70,redis-cli.c,clusterManagerGetAntiAffinityScore,,false,3692,3693,clusterManagerGetAntiAffinityScore,,,164,"int clusterManagerGetAntiAffinityScore (clusterManagerNodeArray*,int,clusterManagerNode***,int*)"
290009,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
    int ip_count);",13,17,redis-cli.c,clusterManagerOptimizeAntiAffinity,,false,3694,3695,clusterManagerOptimizeAntiAffinity,,,165,"void clusterManagerOptimizeAntiAffinity (clusterManagerNodeArray*,int)"
290015,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent);",12,71,redis-cli.c,clusterManagerNodeInfo,,false,3696,3696,clusterManagerNodeInfo,,,166,"sds clusterManagerNodeInfo (clusterManagerNode*,int)"
290021,METHOD,redis-cli.c:<global>,TYPE_DECL,static void clusterManagerShowNodes(void);,13,41,redis-cli.c,clusterManagerShowNodes,,false,3697,3697,clusterManagerShowNodes,,,167,void clusterManagerShowNodes (void)
290026,METHOD,redis-cli.c:<global>,TYPE_DECL,static void clusterManagerShowClusterInfo(void);,13,47,redis-cli.c,clusterManagerShowClusterInfo,,false,3698,3698,clusterManagerShowClusterInfo,,,168,void clusterManagerShowClusterInfo (void)
290031,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err);",12,78,redis-cli.c,clusterManagerFlushNodeConfig,,false,3699,3699,clusterManagerFlushNodeConfig,,,169,"int clusterManagerFlushNodeConfig (clusterManagerNode*,char**)"
290037,METHOD,redis-cli.c:<global>,TYPE_DECL,static void clusterManagerWaitForClusterJoin(void);,13,50,redis-cli.c,clusterManagerWaitForClusterJoin,,false,3700,3700,clusterManagerWaitForClusterJoin,,,170,void clusterManagerWaitForClusterJoin (void)
290042,METHOD,redis-cli.c:<global>,TYPE_DECL,static int clusterManagerCheckCluster(int quiet);,12,48,redis-cli.c,clusterManagerCheckCluster,,false,3701,3701,clusterManagerCheckCluster,,,171,int clusterManagerCheckCluster (int)
290047,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerLog(int level, const char* fmt, ...);",13,62,redis-cli.c,clusterManagerLog,,false,3702,3702,clusterManagerLog,,,172,"void clusterManagerLog (int,char*...)"
290053,METHOD,redis-cli.c:<global>,TYPE_DECL,static int clusterManagerIsConfigConsistent(void);,12,49,redis-cli.c,clusterManagerIsConfigConsistent,,false,3703,3703,clusterManagerIsConfigConsistent,,,173,int clusterManagerIsConfigConsistent (void)
290058,METHOD,redis-cli.c:<global>,TYPE_DECL,static dict *clusterManagerGetLinkStatus(void);,13,46,redis-cli.c,clusterManagerGetLinkStatus,,false,3704,3704,clusterManagerGetLinkStatus,,,174,dict* clusterManagerGetLinkStatus (void)
290063,METHOD,redis-cli.c:<global>,TYPE_DECL,static void clusterManagerOnError(sds err);,13,42,redis-cli.c,clusterManagerOnError,,false,3705,3705,clusterManagerOnError,,,175,void clusterManagerOnError (sds)
290068,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
                                        int len);",13,48,redis-cli.c,clusterManagerNodeArrayInit,,false,3706,3707,clusterManagerNodeArrayInit,,,176,"void clusterManagerNodeArrayInit (clusterManagerNodeArray*,int)"
290074,METHOD,redis-cli.c:<global>,TYPE_DECL,static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array);,13,72,redis-cli.c,clusterManagerNodeArrayReset,,false,3708,3708,clusterManagerNodeArrayReset,,,177,void clusterManagerNodeArrayReset (clusterManagerNodeArray*)
290079,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
                                         clusterManagerNode **nodeptr);",13,70,redis-cli.c,clusterManagerNodeArrayShift,,false,3709,3710,clusterManagerNodeArrayShift,,,178,"void clusterManagerNodeArrayShift (clusterManagerNodeArray*,clusterManagerNode**)"
290085,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
                                       clusterManagerNode *node);",13,64,redis-cli.c,clusterManagerNodeArrayAdd,,false,3711,3712,clusterManagerNodeArrayAdd,,,179,"void clusterManagerNodeArrayAdd (clusterManagerNodeArray*,clusterManagerNode*)"
290091,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandCreate(int argc, char **argv);",12,61,redis-cli.c,clusterManagerCommandCreate,,false,3716,3716,clusterManagerCommandCreate,,,180,"int clusterManagerCommandCreate (int,char**)"
290097,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandAddNode(int argc, char **argv);",12,62,redis-cli.c,clusterManagerCommandAddNode,,false,3717,3717,clusterManagerCommandAddNode,,,181,"int clusterManagerCommandAddNode (int,char**)"
290103,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandDeleteNode(int argc, char **argv);",12,65,redis-cli.c,clusterManagerCommandDeleteNode,,false,3718,3718,clusterManagerCommandDeleteNode,,,182,"int clusterManagerCommandDeleteNode (int,char**)"
290109,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandInfo(int argc, char **argv);",12,59,redis-cli.c,clusterManagerCommandInfo,,false,3719,3719,clusterManagerCommandInfo,,,183,"int clusterManagerCommandInfo (int,char**)"
290115,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandCheck(int argc, char **argv);",12,60,redis-cli.c,clusterManagerCommandCheck,,false,3720,3720,clusterManagerCommandCheck,,,184,"int clusterManagerCommandCheck (int,char**)"
290121,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandFix(int argc, char **argv);",12,58,redis-cli.c,clusterManagerCommandFix,,false,3721,3721,clusterManagerCommandFix,,,185,"int clusterManagerCommandFix (int,char**)"
290127,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandReshard(int argc, char **argv);",12,62,redis-cli.c,clusterManagerCommandReshard,,false,3722,3722,clusterManagerCommandReshard,,,186,"int clusterManagerCommandReshard (int,char**)"
290133,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandRebalance(int argc, char **argv);",12,64,redis-cli.c,clusterManagerCommandRebalance,,false,3723,3723,clusterManagerCommandRebalance,,,187,"int clusterManagerCommandRebalance (int,char**)"
290139,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandSetTimeout(int argc, char **argv);",12,65,redis-cli.c,clusterManagerCommandSetTimeout,,false,3724,3724,clusterManagerCommandSetTimeout,,,188,"int clusterManagerCommandSetTimeout (int,char**)"
290145,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandImport(int argc, char **argv);",12,61,redis-cli.c,clusterManagerCommandImport,,false,3725,3725,clusterManagerCommandImport,,,189,"int clusterManagerCommandImport (int,char**)"
290151,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandCall(int argc, char **argv);",12,59,redis-cli.c,clusterManagerCommandCall,,false,3726,3726,clusterManagerCommandCall,,,190,"int clusterManagerCommandCall (int,char**)"
290157,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandHelp(int argc, char **argv);",12,59,redis-cli.c,clusterManagerCommandHelp,,false,3727,3727,clusterManagerCommandHelp,,,191,"int clusterManagerCommandHelp (int,char**)"
290163,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandBackup(int argc, char **argv);",12,61,redis-cli.c,clusterManagerCommandBackup,,false,3728,3728,clusterManagerCommandBackup,,,192,"int clusterManagerCommandBackup (int,char**)"
290276,METHOD,redis-cli.c:<global>,TYPE_DECL,static void getRDB(clusterManagerNode *node);,13,44,redis-cli.c,getRDB,,false,3775,3775,getRDB,,,201,void getRDB (clusterManagerNode*)
290281,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int createClusterManagerCommand(char *cmdname, int argc, char **argv) {
    clusterManagerCommand *cmd = &config.cluster_manager_command;
    cmd->name = cmdname;
    cmd->argc = argc;
    cmd->argv = argc ? argv : NULL;
    if (isColorTerm()) cmd->flags |= CLUSTER_MANAGER_CMD_FLAG_COLOR;

    if (config.stdin_lastarg) {
        char **new_argv = zmalloc(sizeof(char*) * (cmd->argc+1));
        memcpy(new_argv, cmd->argv, sizeof(char*) * cmd->argc);

        cmd->stdin_arg = readArgFromStdin();
        new_argv[cmd->argc++] = cmd->stdin_arg;
        cmd->argv = new_argv;
    } else if (config.stdin_tag_arg) {
        int i = 0, tag_match = 0;
        cmd->stdin_arg = readArgFromStdin();

        for (; i < argc; i++) {
            if (strcmp(argv[i], config.stdin_tag_name) != 0) continue;

            tag_match = 1;
            cmd->argv[i] = (char *)cmd->stdin_arg;
            break;
        }

        if (!tag_match) {
            sdsfree(cmd->stdin_arg);
            fprintf...",1,37,redis-cli.c,createClusterManagerCommand,,false,3777,3811,createClusterManagerCommand,,,202,"int createClusterManagerCommand (char*,int,char**)"
290443,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerCommandProc *validateClusterManagerCommand(void) {
    int i, commands_count = sizeof(clusterManagerCommands) /
                            sizeof(clusterManagerCommandDef);
    clusterManagerCommandProc *proc = NULL;
    char *cmdname = config.cluster_manager_command.name;
    int argc = config.cluster_manager_command.argc;
    for (i = 0; i < commands_count; i++) {
        clusterManagerCommandDef cmddef = clusterManagerCommands[i];
        if (!strcmp(cmddef.name, cmdname)) {
            if ((cmddef.arity > 0 && argc != cmddef.arity) ||
                (cmddef.arity < 0 && argc < (cmddef.arity * -1))) {
                fprintf(stderr, ""[ERR] Wrong number of arguments for ""
                                ""specified --cluster sub command\n"");
                return NULL;
            }
            proc = cmddef.proc;
        }
    }
    if (!proc) fprintf(stderr, ""Unknown --cluster subcommand\n"");
    return proc;
}",1,1,redis-cli.c,validateClusterManagerCommand,,false,3813,3833,validateClusterManagerCommand,,,203,clusterManagerCommandProc validateClusterManagerCommand (void)
290549,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int parseClusterNodeAddress(char *addr, char **ip_ptr, int *port_ptr,
                                   int *bus_port_ptr)
{
    /* ip:port[@bus_port] */
    char *c = strrchr(addr, '@');
    if (c != NULL) {
        *c = '\0';
        if (bus_port_ptr != NULL)
            *bus_port_ptr = atoi(c + 1);
    }
    c = strrchr(addr, ':');
    if (c != NULL) {
        *c = '\0';
        *ip_ptr = addr;
        *port_ptr = atoi(++c);
    } else return 0;
    return 1;
}",1,1,redis-cli.c,parseClusterNodeAddress,,false,3835,3852,parseClusterNodeAddress,,,204,"int parseClusterNodeAddress (char*,char**,int*,int*)"
290614,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int getClusterHostFromCmdArgs(int argc, char **argv,
                                     char **ip_ptr, int *port_ptr) {
    int port = 0;
    char *ip = NULL;
    if (argc == 1) {
        char *addr = argv[0];
        if (!parseClusterNodeAddress(addr, &ip, &port, NULL)) return 0;
    } else {
        ip = argv[0];
        port = atoi(argv[1]);
    }
    if (!ip || !port) return 0;
    else {
        *ip_ptr = ip;
        *port_ptr = port;
    }
    return 1;
}",1,1,redis-cli.c,getClusterHostFromCmdArgs,,false,3860,3877,getClusterHostFromCmdArgs,,,205,"int getClusterHostFromCmdArgs (int,char**,char**,int*)"
290687,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void freeClusterManagerNodeFlags(list *flags) {
    listIter li;
    listNode *ln;
    listRewind(flags, &li);
    while ((ln = listNext(&li)) != NULL) {
        sds flag = ln->value;
        sdsfree(flag);
    }
    listRelease(flags);
}",1,1,redis-cli.c,freeClusterManagerNodeFlags,,false,3879,3888,freeClusterManagerNodeFlags,,,206,void freeClusterManagerNodeFlags (list*)
290717,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void freeClusterManagerNode(clusterManagerNode *node) {
    if (node->context != NULL) redisFree(node->context);
    if (node->friends != NULL) {
        listIter li;
        listNode *ln;
        listRewind(node->friends,&li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerNode *fn = ln->value;
            freeClusterManagerNode(fn);
        }
        listRelease(node->friends);
        node->friends = NULL;
    }
    if (node->name != NULL) sdsfree(node->name);
    if (node->replicate != NULL) sdsfree(node->replicate);
    if ((node->flags & CLUSTER_MANAGER_FLAG_FRIEND) && node->ip)
        sdsfree(node->ip);
    int i;
    if (node->migrating != NULL) {
        for (i = 0; i < node->migrating_count; i++) sdsfree(node->migrating[i]);
        zfree(node->migrating);
    }
    if (node->importing != NULL) {
        for (i = 0; i < node->importing_count; i++) sdsfree(node->importing[i]);
        zfree(node->importing);
    }
    if (node->flags_str !=...",1,23,redis-cli.c,freeClusterManagerNode,,false,3890,3921,freeClusterManagerNode,,,207,void freeClusterManagerNode (clusterManagerNode*)
290892,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void freeClusterManager(void) {
    listIter li;
    listNode *ln;
    if (cluster_manager.nodes != NULL) {
        listRewind(cluster_manager.nodes,&li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerNode *n = ln->value;
            freeClusterManagerNode(n);
        }
        listRelease(cluster_manager.nodes);
        cluster_manager.nodes = NULL;
    }
    if (cluster_manager.errors != NULL) {
        listRewind(cluster_manager.errors,&li);
        while ((ln = listNext(&li)) != NULL) {
            sds err = ln->value;
            sdsfree(err);
        }
        listRelease(cluster_manager.errors);
        cluster_manager.errors = NULL;
    }
    if (clusterManagerUncoveredSlots != NULL)
        dictRelease(clusterManagerUncoveredSlots);
}",1,1,redis-cli.c,freeClusterManager,,false,3923,3946,freeClusterManager,,,208,void freeClusterManager (void)
290984,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerNewNode(char *ip, int port, int bus_port) {
    clusterManagerNode *node = zmalloc(sizeof(*node));
    node->context = NULL;
    node->name = NULL;
    node->ip = ip;
    node->port = port;
    /* We don't need to know the bus_port, at this point this value may be wrong.
     * If it is used, it will be corrected in clusterManagerLoadInfoFromNode. */
    node->bus_port = bus_port ? bus_port : port + CLUSTER_MANAGER_PORT_INCR;
    node->current_epoch = 0;
    node->ping_sent = 0;
    node->ping_recv = 0;
    node->flags = 0;
    node->flags_str = NULL;
    node->replicate = NULL;
    node->dirty = 0;
    node->friends = NULL;
    node->migrating = NULL;
    node->importing = NULL;
    node->migrating_count = 0;
    node->importing_count = 0;
    node->replicas_count = 0;
    node->weight = 1.0f;
    node->balance = 0;
    clusterManagerNodeResetSlots(node);
    return node;
}",1,50,redis-cli.c,clusterManagerNewNode,,false,3948,3974,clusterManagerNewNode,,,209,"clusterManagerNode clusterManagerNewNode (char*,int,int)"
291109,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerGetNodeRDBFilename(clusterManagerNode *node) {
    assert(config.cluster_manager_command.backup_dir);
    sds filename = sdsnew(config.cluster_manager_command.backup_dir);
    if (filename[sdslen(filename) - 1] != '/')
        filename = sdscat(filename, ""/"");
    filename = sdscatprintf(filename, ""redis-node-%s-%d-%s.rdb"", node->ip,
                            node->port, node->name);
    return filename;
}",1,1,redis-cli.c,clusterManagerGetNodeRDBFilename,,false,3976,3984,clusterManagerGetNodeRDBFilename,,,210,sds clusterManagerGetNodeRDBFilename (clusterManagerNode*)
291160,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCheckRedisReply(clusterManagerNode *n,
                                         redisReply *r, char **err)
{
    int is_err = 0;
    if (!r || (is_err = (r->type == REDIS_REPLY_ERROR))) {
        if (is_err) {
            if (err != NULL) {
                *err = zmalloc((r->len + 1) * sizeof(char));
                redis_strlcpy(*err, r->str,(r->len + 1));
            } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(n, r->str);
        }
        return 0;
    }
    return 1;
}",1,19,redis-cli.c,clusterManagerCheckRedisReply,,false,3990,4004,clusterManagerCheckRedisReply,,,211,"int clusterManagerCheckRedisReply (clusterManagerNode*,redisReply*,char**)"
291238,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerStartTransaction(clusterManagerNode *node) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""MULTI"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerStartTransaction,,false,4007,4012,clusterManagerStartTransaction,,,212,int clusterManagerStartTransaction (clusterManagerNode*)
291269,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerExecTransaction(clusterManagerNode *node,
                                         clusterManagerOnReplyError onerror)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""EXEC"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (success) {
        if (reply->type != REDIS_REPLY_ARRAY) {
            success = 0;
            goto cleanup;
        }
        size_t i;
        for (i = 0; i < reply->elements; i++) {
            redisReply *r = reply->element[i];
            char *err = NULL;
            success = clusterManagerCheckRedisReply(node, r, &err);
            if (!success && onerror) success = onerror(r, node, i);
            if (err) {
                if (!success)
                    CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
                zfree(err);
            }
            if (!success) break;
        }
    }
cleanup:
    if (reply) freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerExecTransaction,,false,4015,4042,clusterManagerExecTransaction,,,213,"int clusterManagerExecTransaction (clusterManagerNode*,clusterManagerOnReplyError)"
291389,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeConnect(clusterManagerNode *node) {
    if (node->context) redisFree(node->context);
    node->context = redisConnect(node->ip, node->port);
    if (!node->context->err && config.tls) {
        const char *err = NULL;
        if (cliSecureConnection(node->context, config.sslconfig, &err) == REDIS_ERR && err) {
            fprintf(stderr,""TLS Error: %s\n"", err);
            redisFree(node->context);
            node->context = NULL;
            return 0;
        }
    }
    if (node->context->err) {
        fprintf(stderr,""Could not connect to Redis at "");
        fprintf(stderr,""%s:%d: %s\n"", node->ip, node->port,
                node->context->errstr);
        redisFree(node->context);
        node->context = NULL;
        return 0;
    }
    /* Set aggressive KEEP_ALIVE socket option in the Redis context socket
     * in order to prevent timeouts caused by the execution of long
     * commands. At the same time this improves the detection of real
     ...",1,43,redis-cli.c,clusterManagerNodeConnect,,false,4044,4081,clusterManagerNodeConnect,,,214,int clusterManagerNodeConnect (clusterManagerNode*)
291575,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerRemoveNodeFromList(list *nodelist,
                                             clusterManagerNode *node) {
    listIter li;
    listNode *ln;
    listRewind(nodelist, &li);
    while ((ln = listNext(&li)) != NULL) {
        if (node == ln->value) {
            listDelNode(nodelist, ln);
            break;
        }
    }
}",1,1,redis-cli.c,clusterManagerRemoveNodeFromList,,false,4083,4094,clusterManagerRemoveNodeFromList,,,215,"void clusterManagerRemoveNodeFromList (list*,clusterManagerNode*)"
291607,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerNodeByName(const char *name) {
    if (cluster_manager.nodes == NULL) return NULL;
    clusterManagerNode *found = NULL;
    sds lcname = sdsempty();
    lcname = sdscpy(lcname, name);
    sdstolower(lcname);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->name && !sdscmp(n->name, lcname)) {
            found = n;
            break;
        }
    }
    sdsfree(lcname);
    return found;
}",1,1,redis-cli.c,clusterManagerNodeByName,,false,4097,4115,clusterManagerNodeByName,,,216,clusterManagerNode clusterManagerNodeByName (char*)
291679,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerNodeByAbbreviatedName(const char*name)
{
    if (cluster_manager.nodes == NULL) return NULL;
    clusterManagerNode *found = NULL;
    sds lcname = sdsempty();
    lcname = sdscpy(lcname, name);
    sdstolower(lcname);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->name &&
            strstr(n->name, lcname) == n->name) {
            found = n;
            break;
        }
    }
    sdsfree(lcname);
    return found;
}",1,1,redis-cli.c,clusterManagerNodeByAbbreviatedName,,false,4121,4141,clusterManagerNodeByAbbreviatedName,,,217,clusterManagerNode clusterManagerNodeByAbbreviatedName (char*)
291754,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeResetSlots(clusterManagerNode *node) {
    memset(node->slots, 0, sizeof(node->slots));
    node->slots_count = 0;
}",1,1,redis-cli.c,clusterManagerNodeResetSlots,,false,4143,4146,clusterManagerNodeResetSlots,,,218,void clusterManagerNodeResetSlots (clusterManagerNode*)
291773,METHOD,redis-cli.c:<global>,TYPE_DECL,"static redisReply *clusterManagerGetNodeRedisInfo(clusterManagerNode *node,
                                                  char **err)
{
    redisReply *info = CLUSTER_MANAGER_COMMAND(node, ""INFO"");
    if (err != NULL) *err = NULL;
    if (info == NULL) return NULL;
    if (info->type == REDIS_REPLY_ERROR) {
        if (err != NULL) {
            *err = zmalloc((info->len + 1) * sizeof(char));
            redis_strlcpy(*err, info->str,(info->len + 1));
        }
        freeReplyObject(info);
        return  NULL;
    }
    return info;
}",1,23,redis-cli.c,clusterManagerGetNodeRedisInfo,,false,4149,4164,clusterManagerGetNodeRedisInfo,,,219,"redisReply clusterManagerGetNodeRedisInfo (clusterManagerNode*,char**)"
291848,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeIsCluster(clusterManagerNode *node, char **err) {
    redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
    if (info == NULL) return 0;
    int is_cluster = (int) getLongInfoField(info->str, ""cluster_enabled"");
    freeReplyObject(info);
    return is_cluster;
}",1,1,redis-cli.c,clusterManagerNodeIsCluster,,false,4166,4172,clusterManagerNodeIsCluster,,,220,"int clusterManagerNodeIsCluster (clusterManagerNode*,char**)"
291881,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeIsEmpty(clusterManagerNode *node, char **err) {
    redisReply *info = clusterManagerGetNodeRedisInfo(node, err);
    int is_empty = 1;
    if (info == NULL) return 0;
    if (strstr(info->str, ""db0:"") != NULL) {
        is_empty = 0;
        goto result;
    }
    freeReplyObject(info);
    info = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER INFO"");
    if (err != NULL) *err = NULL;
    if (!clusterManagerCheckRedisReply(node, info, err)) {
        is_empty = 0;
        goto result;
    }
    long known_nodes = getLongInfoField(info->str, ""cluster_known_nodes"");
    is_empty = (known_nodes == 1);
result:
    freeReplyObject(info);
    return is_empty;
}",1,11,redis-cli.c,clusterManagerNodeIsEmpty,,false,4176,4196,clusterManagerNodeIsEmpty,,,221,"int clusterManagerNodeIsEmpty (clusterManagerNode*,char**)"
291967,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerGetAntiAffinityScore(clusterManagerNodeArray *ipnodes,
    int ip_count, clusterManagerNode ***offending, int *offending_len)
{
    int score = 0, i, j;
    int node_len = cluster_manager.nodes->len;
    clusterManagerNode **offending_p = NULL;
    if (offending != NULL) {
        *offending = zcalloc(node_len * sizeof(clusterManagerNode*));
        offending_p = *offending;
    }
    /* For each set of nodes in the same host, split by
     * related nodes (masters and slaves which are involved in
     * replication of each other) */
    for (i = 0; i < ip_count; i++) {
        clusterManagerNodeArray *node_array = &(ipnodes[i]);
        dict *related = dictCreate(&clusterManagerDictType);
        char *ip = NULL;
        for (j = 0; j < node_array->len; j++) {
            clusterManagerNode *node = node_array->nodes[j];
            if (node == NULL) continue;
            if (!ip) ip = node->ip;
            sds types;
            /* We always use the Master ...",1,1,redis-cli.c,clusterManagerGetAntiAffinityScore,,false,4227,4296,clusterManagerGetAntiAffinityScore,,,222,"int clusterManagerGetAntiAffinityScore (clusterManagerNodeArray*,int,clusterManagerNode***,int*)"
292274,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerOptimizeAntiAffinity(clusterManagerNodeArray *ipnodes,
    int ip_count)
{
    clusterManagerNode **offenders = NULL;
    int score = clusterManagerGetAntiAffinityScore(ipnodes, ip_count,
                                                   NULL, NULL);
    if (score == 0) goto cleanup;
    clusterManagerLogInfo("">>> Trying to optimize slaves allocation ""
                          ""for anti-affinity\n"");
    int node_len = cluster_manager.nodes->len;
    int maxiter = 500 * node_len; // Effort is proportional to cluster size...
    srand(time(NULL));
    while (maxiter > 0) {
        int offending_len = 0;
        if (offenders != NULL) {
            zfree(offenders);
            offenders = NULL;
        }
        score = clusterManagerGetAntiAffinityScore(ipnodes,
                                                   ip_count,
                                                   &offenders,
                                                   &offending_len);
    ...",1,4,redis-cli.c,clusterManagerOptimizeAntiAffinity,,false,4298,4374,clusterManagerOptimizeAntiAffinity,,,223,"void clusterManagerOptimizeAntiAffinity (clusterManagerNodeArray*,int)"
292561,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerNodeFlagString(clusterManagerNode *node) {
    sds flags = sdsempty();
    if (!node->flags_str) return flags;
    int empty = 1;
    listIter li;
    listNode *ln;
    listRewind(node->flags_str, &li);
    while ((ln = listNext(&li)) != NULL) {
        sds flag = ln->value;
        if (strcmp(flag, ""myself"") == 0) continue;
        if (!empty) flags = sdscat(flags, "","");
        flags = sdscatfmt(flags, ""%S"", flag);
        empty = 0;
    }
    return flags;
}",1,1,redis-cli.c,clusterManagerNodeFlagString,,false,4377,4392,clusterManagerNodeFlagString,,,224,sds clusterManagerNodeFlagString (clusterManagerNode*)
292633,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerNodeSlotsString(clusterManagerNode *node) {
    sds slots = sdsempty();
    int first_range_idx = -1, last_slot_idx = -1, i;
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        int has_slot = node->slots[i];
        if (has_slot) {
            if (first_range_idx == -1) {
                if (sdslen(slots)) slots = sdscat(slots, "","");
                first_range_idx = i;
                slots = sdscatfmt(slots, ""[%u"", i);
            }
            last_slot_idx = i;
        } else {
            if (last_slot_idx >= 0) {
                if (first_range_idx == last_slot_idx)
                    slots = sdscat(slots, ""]"");
                else slots = sdscatfmt(slots, ""-%u]"", last_slot_idx);
            }
            last_slot_idx = -1;
            first_range_idx = -1;
        }
    }
    if (last_slot_idx >= 0) {
        if (first_range_idx == last_slot_idx) slots = sdscat(slots, ""]"");
        else slots = sdscatfmt(slots, ""-%u]"", last_slot_idx);
    }
 ...",1,20,redis-cli.c,clusterManagerNodeSlotsString,,false,4395,4422,clusterManagerNodeSlotsString,,,225,sds clusterManagerNodeSlotsString (clusterManagerNode*)
292762,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerNodeGetJSON(clusterManagerNode *node,
                                     unsigned long error_count)
{
    sds json = sdsempty();
    sds replicate = sdsempty();
    if (node->replicate)
        replicate = sdscatprintf(replicate, ""\""%s\"""", node->replicate);
    else
        replicate = sdscat(replicate, ""null"");
    sds slots = clusterManagerNodeSlotsString(node);
    sds flags = clusterManagerNodeFlagString(node);
    char *p = slots;
    while ((p = strchr(p, '-')) != NULL)
        *(p++) = ',';
    json = sdscatprintf(json,
        ""  {\n""
        ""    \""name\"": \""%s\"",\n""
        ""    \""host\"": \""%s\"",\n""
        ""    \""port\"": %d,\n""
        ""    \""replicate\"": %s,\n""
        ""    \""slots\"": [%s],\n""
        ""    \""slots_count\"": %d,\n""
        ""    \""flags\"": \""%s\"",\n""
        ""    \""current_epoch\"": %llu"",
        node->name,
        node->ip,
        node->port,
        replicate,
        slots,
        node->slots_count,
        flags,
        (u...",1,1,redis-cli.c,clusterManagerNodeGetJSON,,false,4424,4496,clusterManagerNodeGetJSON,,,226,"sds clusterManagerNodeGetJSON (clusterManagerNode*,long unsigned)"
293046,METHOD,redis-cli.c:<global>,TYPE_DECL,"static unsigned int clusterManagerKeyHashSlot(char *key, int keylen) {
    int s, e; /* start-end indexes of { and } */

    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    /* No '{' ? Hash the whole key. This is the base case. */
    if (s == keylen) return crc16(key,keylen) & 0x3FFF;

    /* '{' found? Check if we have the corresponding '}'. */
    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    /* No '}' or nothing between {} ? Hash the whole key. */
    if (e == keylen || e == s+1) return crc16(key,keylen) & 0x3FFF;

    /* If we are here there is both a { and a } on its right. Hash
     * what is in the middle between { and }. */
    return crc16(key+s+1,e-s-1) & 0x3FFF;
}",1,1,redis-cli.c,clusterManagerKeyHashSlot,,false,4509,4528,clusterManagerKeyHashSlot,,,227,"unsigned int clusterManagerKeyHashSlot (char*,int)"
293134,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerNodeInfo(clusterManagerNode *node, int indent) {
    sds info = sdsempty();
    sds spaces = sdsempty();
    int i;
    for (i = 0; i < indent; i++) spaces = sdscat(spaces, "" "");
    if (indent) info = sdscat(info, spaces);
    int is_master = !(node->flags & CLUSTER_MANAGER_FLAG_SLAVE);
    char *role = (is_master ? ""M"" : ""S"");
    sds slots = NULL;
    if (node->dirty && node->replicate != NULL)
        info = sdscatfmt(info, ""S: %S %s:%u"", node->name, node->ip, node->port);
    else {
        slots = clusterManagerNodeSlotsString(node);
        sds flags = clusterManagerNodeFlagString(node);
        info = sdscatfmt(info, ""%s: %S %s:%u\n""
                               ""%s   slots:%S (%u slots) ""
                               ""%S"",
                               role, node->name, node->ip, node->port, spaces,
                               slots, node->slots_count, flags);
        sdsfree(slots);
        sdsfree(flags);
    }
    if (node->replicate != N...",1,36,redis-cli.c,clusterManagerNodeInfo,,false,4531,4560,clusterManagerNodeInfo,,,228,"sds clusterManagerNodeInfo (clusterManagerNode*,int)"
293293,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerShowNodes(void) {
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        sds info = clusterManagerNodeInfo(node, 0);
        printf(""%s\n"", (char *) info);
        sdsfree(info);
    }
}",1,1,redis-cli.c,clusterManagerShowNodes,,false,4562,4572,clusterManagerShowNodes,,,229,void clusterManagerShowNodes (void)
293334,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerShowClusterInfo(void) {
    int masters = 0;
    int keys = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        if (!(node->flags & CLUSTER_MANAGER_FLAG_SLAVE)) {
            if (!node->name) continue;
            int replicas = 0;
            int dbsize = -1;
            char name[9];
            memcpy(name, node->name, 8);
            name[8] = '\0';
            listIter ri;
            listNode *rn;
            listRewind(cluster_manager.nodes, &ri);
            while ((rn = listNext(&ri)) != NULL) {
                clusterManagerNode *n = rn->value;
                if (n == node || !(n->flags & CLUSTER_MANAGER_FLAG_SLAVE))
                    continue;
                if (n->replicate && !strcmp(n->replicate, node->name))
                    replicas++;
            }
            redisReply *reply = CLUSTER_MANAGER_COMMAND(node,...",1,28,redis-cli.c,clusterManagerShowClusterInfo,,false,4574,4621,clusterManagerShowClusterInfo,,,230,void clusterManagerShowClusterInfo (void)
293587,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerAddSlots(clusterManagerNode *node, char**err)
{
    redisReply *reply = NULL;
    void *_reply = NULL;
    int success = 1;
    /* First two args are used for the command itself. */
    int argc = node->slots_count + 2;
    sds *argv = zmalloc(argc * sizeof(*argv));
    size_t *argvlen = zmalloc(argc * sizeof(*argvlen));
    argv[0] = ""CLUSTER"";
    argv[1] = ""ADDSLOTS"";
    argvlen[0] = 7;
    argvlen[1] = 8;
    *err = NULL;
    int i, argv_idx = 2;
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        if (argv_idx >= argc) break;
        if (node->slots[i]) {
            argv[argv_idx] = sdsfromlonglong((long long) i);
            argvlen[argv_idx] = sdslen(argv[argv_idx]);
            argv_idx++;
        }
    }
    if (argv_idx == 2) {
        success = 0;
        goto cleanup;
    }
    redisAppendCommandArgv(node->context,argc,(const char**)argv,argvlen);
    if (redisGetReply(node->context, &_reply) != REDIS_OK) {
        success = 0;
        got...",1,20,redis-cli.c,clusterManagerAddSlots,,false,4624,4666,clusterManagerAddSlots,,,231,"int clusterManagerAddSlots (clusterManagerNode*,char**)"
293780,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerGetSlotOwner(clusterManagerNode *n,
                                                      int slot, char **err)
{
    assert(slot >= 0 && slot < CLUSTER_MANAGER_SLOTS);
    clusterManagerNode *owner = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(n, ""CLUSTER SLOTS"");
    if (clusterManagerCheckRedisReply(n, reply, err)) {
        assert(reply->type == REDIS_REPLY_ARRAY);
        size_t i;
        for (i = 0; i < reply->elements; i++) {
            redisReply *r = reply->element[i];
            assert(r->type == REDIS_REPLY_ARRAY && r->elements >= 3);
            int from, to;
            from = r->element[0]->integer;
            to = r->element[1]->integer;
            if (slot < from || slot > to) continue;
            redisReply *nr =  r->element[2];
            assert(nr->type == REDIS_REPLY_ARRAY && nr->elements >= 2);
            char *name = NULL;
            if (nr->elements >= 3)
                name =  nr->element[2]->str;
 ...",1,31,redis-cli.c,clusterManagerGetSlotOwner,,false,4672,4715,clusterManagerGetSlotOwner,,,232,"clusterManagerNode clusterManagerGetSlotOwner (clusterManagerNode*,int,char**)"
294018,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerSetSlot(clusterManagerNode *node1,
                                 clusterManagerNode *node2,
                                 int slot, const char *status, char **err) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node1, ""CLUSTER ""
                                                ""SETSLOT %d %s %s"",
                                                slot, status,
                                                (char *) node2->name);
    if (err != NULL) *err = NULL;
    if (!reply) {
        if (err) *err = zstrdup(""CLUSTER SETSLOT failed to run"");
        return 0;
    }
    int success = 1;
    if (reply->type == REDIS_REPLY_ERROR) {
        success = 0;
        if (err != NULL) {
            *err = zmalloc((reply->len + 1) * sizeof(char));
            redis_strlcpy(*err, reply->str,(reply->len + 1));
        } else CLUSTER_MANAGER_PRINT_REPLY_ERROR(node1, reply->str);
        goto cleanup;
    }
cleanup:
    freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerSetSlot,,false,4718,4742,clusterManagerSetSlot,,,233,"int clusterManagerSetSlot (clusterManagerNode*,clusterManagerNode*,int,char*,char**)"
294136,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerClearSlotStatus(clusterManagerNode *node, int slot) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER SETSLOT %d %s"", slot, ""STABLE"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerClearSlotStatus,,false,4744,4750,clusterManagerClearSlotStatus,,,234,"int clusterManagerClearSlotStatus (clusterManagerNode*,int)"
294169,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerDelSlot(clusterManagerNode *node, int slot,
                                 int ignore_unassigned_err)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER DELSLOTS %d"", slot);
    char *err = NULL;
    int success = clusterManagerCheckRedisReply(node, reply, &err);
    if (!success && reply && reply->type == REDIS_REPLY_ERROR &&
        ignore_unassigned_err)
    {
        char *get_owner_err = NULL;
        clusterManagerNode *assigned_to =
            clusterManagerGetSlotOwner(node, slot, &get_owner_err);
        if (!assigned_to) {
            if (get_owner_err == NULL) success = 1;
            else {
                CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, get_owner_err);
                zfree(get_owner_err);
            }
        }
    }
    if (!success && err != NULL) {
        CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, err);
        zfree(err);
    }
    if (reply) freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerDelSlot,,false,4752,4779,clusterManagerDelSlot,,,235,"int clusterManagerDelSlot (clusterManagerNode*,int,int)"
294287,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerAddSlot(clusterManagerNode *node, int slot) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER ADDSLOTS %d"", slot);
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerAddSlot,,false,4781,4787,clusterManagerAddSlot,,,236,"int clusterManagerAddSlot (clusterManagerNode*,int)"
294319,METHOD,redis-cli.c:<global>,TYPE_DECL,"static signed int clusterManagerCountKeysInSlot(clusterManagerNode *node,
                                                int slot)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node,
        ""CLUSTER COUNTKEYSINSLOT %d"", slot);
    int count = -1;
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (success && reply->type == REDIS_REPLY_INTEGER) count = reply->integer;
    if (reply) freeReplyObject(reply);
    return count;
}",1,24,redis-cli.c,clusterManagerCountKeysInSlot,,false,4789,4799,clusterManagerCountKeysInSlot,,,237,"signed int clusterManagerCountKeysInSlot (clusterManagerNode*,int)"
294370,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerBumpEpoch(clusterManagerNode *node) {
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER BUMPEPOCH"");
    int success = clusterManagerCheckRedisReply(node, reply, NULL);
    if (reply) freeReplyObject(reply);
    return success;
}",1,24,redis-cli.c,clusterManagerBumpEpoch,,false,4801,4806,clusterManagerBumpEpoch,,,238,int clusterManagerBumpEpoch (clusterManagerNode*)
294400,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerOnSetOwnerErr(redisReply *reply,
    clusterManagerNode *n, int bulk_idx)
{
    UNUSED(reply);
    UNUSED(n);
    /* Only raise error when ADDSLOTS fail (bulk_idx == 1). */
    return (bulk_idx != 1);
}",1,4,redis-cli.c,clusterManagerOnSetOwnerErr,,false,4811,4818,clusterManagerOnSetOwnerErr,,,239,"int clusterManagerOnSetOwnerErr (redisReply*,clusterManagerNode*,int)"
294423,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerSetSlotOwner(clusterManagerNode *owner,
                                      int slot,
                                      int do_clear)
{
    int success = clusterManagerStartTransaction(owner);
    if (!success) return 0;
    /* Ensure the slot is not already assigned. */
    clusterManagerDelSlot(owner, slot, 1);
    /* Add the slot and bump epoch. */
    clusterManagerAddSlot(owner, slot);
    if (do_clear) clusterManagerClearSlotStatus(owner, slot);
    clusterManagerBumpEpoch(owner);
    success = clusterManagerExecTransaction(owner, clusterManagerOnSetOwnerErr);
    return success;
}",1,1,redis-cli.c,clusterManagerSetSlotOwner,,false,4820,4834,clusterManagerSetSlotOwner,,,240,"int clusterManagerSetSlotOwner (clusterManagerNode*,int,int)"
294463,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCompareKeysValues(clusterManagerNode *n1,
                                          clusterManagerNode *n2,
                                          redisReply *keys_reply,
                                          list *diffs)
{
    size_t i, argc = keys_reply->elements + 2;
    static const char *hash_zero = ""0000000000000000000000000000000000000000"";
    char **argv = zcalloc(argc * sizeof(char *));
    size_t  *argv_len = zcalloc(argc * sizeof(size_t));
    argv[0] = ""DEBUG"";
    argv_len[0] = 5;
    argv[1] = ""DIGEST-VALUE"";
    argv_len[1] = 12;
    for (i = 0; i < keys_reply->elements; i++) {
        redisReply *entry = keys_reply->element[i];
        int idx = i + 2;
        argv[idx] = entry->str;
        argv_len[idx] = entry->len;
    }
    int success = 0;
    void *_reply1 = NULL, *_reply2 = NULL;
    redisReply *r1 = NULL, *r2 = NULL;
    redisAppendCommandArgv(n1->context,argc, (const char**)argv,argv_len);
    success = (redisGetReply(n1->co...",1,8,redis-cli.c,clusterManagerCompareKeysValues,,false,4841,4898,clusterManagerCompareKeysValues,,,241,"int clusterManagerCompareKeysValues (clusterManagerNode*,clusterManagerNode*,redisReply*,list*)"
294813,METHOD,redis-cli.c:<global>,TYPE_DECL,"static redisReply *clusterManagerMigrateKeysInReply(clusterManagerNode *source,
                                                    clusterManagerNode *target,
                                                    redisReply *reply,
                                                    int replace, int timeout,
                                                    char *dots)
{
    redisReply *migrate_reply = NULL;
    char **argv = NULL;
    size_t *argv_len = NULL;
    int c = (replace ? 8 : 7);
    if (config.conn_info.auth) c += 2;
    if (config.conn_info.user) c += 1;
    size_t argc = c + reply->elements;
    size_t i, offset = 6; // Keys Offset
    argv = zcalloc(argc * sizeof(char *));
    argv_len = zcalloc(argc * sizeof(size_t));
    char portstr[255];
    char timeoutstr[255];
    snprintf(portstr, 10, ""%d"", target->port);
    snprintf(timeoutstr, 10, ""%d"", timeout);
    argv[0] = ""MIGRATE"";
    argv_len[0] = 7;
    argv[1] = target->ip;
    argv_len[1] = strlen(target->ip);
 ...",1,1,redis-cli.c,clusterManagerMigrateKeysInReply,,false,4903,4983,clusterManagerMigrateKeysInReply,,,242,"redisReply clusterManagerMigrateKeysInReply (clusterManagerNode*,clusterManagerNode*,redisReply*,int,int,char*)"
295230,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerMigrateKeysInSlot(clusterManagerNode *source,
                                           clusterManagerNode *target,
                                           int slot, int timeout,
                                           int pipeline, int verbose,
                                           char **err)
{
    int success = 1;
    int do_fix = config.cluster_manager_command.flags &
                 CLUSTER_MANAGER_CMD_FLAG_FIX;
    int do_replace = config.cluster_manager_command.flags &
                     CLUSTER_MANAGER_CMD_FLAG_REPLACE;
    while (1) {
        char *dots = NULL;
        redisReply *reply = NULL, *migrate_reply = NULL;
        reply = CLUSTER_MANAGER_COMMAND(source, ""CLUSTER ""
                                        ""GETKEYSINSLOT %d %d"", slot,
                                        pipeline);
        success = (reply != NULL);
        if (!success) return 0;
        if (reply->type == REDIS_REPLY_ERROR) {
            success = 0;
    ...",1,17,redis-cli.c,clusterManagerMigrateKeysInSlot,,false,4986,5141,clusterManagerMigrateKeysInSlot,,,243,"int clusterManagerMigrateKeysInSlot (clusterManagerNode*,clusterManagerNode*,int,int,int,int,char**)"
295740,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerMoveSlot(clusterManagerNode *source,
                                  clusterManagerNode *target,
                                  int slot, int opts,  char**err)
{
    if (!(opts & CLUSTER_MANAGER_OPT_QUIET)) {
        printf(""Moving slot %d from %s:%d to %s:%d: "", slot, source->ip,
               source->port, target->ip, target->port);
        fflush(stdout);
    }
    if (err != NULL) *err = NULL;
    int pipeline = config.cluster_manager_command.pipeline,
        timeout = config.cluster_manager_command.timeout,
        print_dots = (opts & CLUSTER_MANAGER_OPT_VERBOSE),
        option_cold = (opts & CLUSTER_MANAGER_OPT_COLD),
        success = 1;
    if (!option_cold) {
        success = clusterManagerSetSlot(target, source, slot,
                                        ""importing"", err);
        if (!success) return 0;
        success = clusterManagerSetSlot(source, target, slot,
                                        ""migrating"", err);
        if (...",1,17,redis-cli.c,clusterManagerMoveSlot,,false,5152,5223,clusterManagerMoveSlot,,,244,"int clusterManagerMoveSlot (clusterManagerNode*,clusterManagerNode*,int,int,char**)"
296030,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerFlushNodeConfig(clusterManagerNode *node, char **err) {
    if (!node->dirty) return 0;
    redisReply *reply = NULL;
    int is_err = 0, success = 1;
    if (err != NULL) *err = NULL;
    if (node->replicate != NULL) {
        reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER REPLICATE %s"",
                                        node->replicate);
        if (reply == NULL || (is_err = (reply->type == REDIS_REPLY_ERROR))) {
            if (is_err && err != NULL) {
                *err = zmalloc((reply->len + 1) * sizeof(char));
                redis_strlcpy(*err, reply->str, (reply->len + 1));
            }
            success = 0;
            /* If the cluster did not already joined it is possible that
             * the slave does not know the master node yet. So on errors
             * we return ASAP leaving the dirty flag set, to flush the
             * config later. */
            goto cleanup;
        }
    } else {
        int added = clusterManagerAd...",1,16,redis-cli.c,clusterManagerFlushNodeConfig,,false,5227,5255,clusterManagerFlushNodeConfig,,,245,"int clusterManagerFlushNodeConfig (clusterManagerNode*,char**)"
296167,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerWaitForClusterJoin(void) {
    printf(""Waiting for the cluster to join\n"");
    int counter = 0,
        check_after = CLUSTER_JOIN_CHECK_AFTER +
                      (int)(listLength(cluster_manager.nodes) * 0.15f);
    while(!clusterManagerIsConfigConsistent()) {
        printf(""."");
        fflush(stdout);
        sleep(1);
        if (++counter > check_after) {
            dict *status = clusterManagerGetLinkStatus();
            dictIterator *iter = NULL;
            if (status != NULL && dictSize(status) > 0) {
                printf(""\n"");
                clusterManagerLogErr(""Warning: %d node(s) may ""
                                     ""be unreachable\n"", dictSize(status));
                iter = dictGetIterator(status);
                dictEntry *entry;
                while ((entry = dictNext(iter)) != NULL) {
                    sds nodeaddr = (sds) dictGetKey(entry);
                    char *node_ip = NULL;
                    int node_port ...",1,22,redis-cli.c,clusterManagerWaitForClusterJoin,,false,5258,5311,clusterManagerWaitForClusterJoin,,,246,void clusterManagerWaitForClusterJoin (void)
296384,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerNodeLoadInfo(clusterManagerNode *node, int opts,
                                      char **err)
{
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    int success = 1;
    *err = NULL;
    if (!clusterManagerCheckRedisReply(node, reply, err)) {
        success = 0;
        goto cleanup;
    }
    int getfriends = (opts & CLUSTER_MANAGER_OPT_GETFRIENDS);
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *name = NULL, *addr = NULL, *flags = NULL, *master_id = NULL,
             *ping_sent = NULL, *ping_recv = NULL, *config_epoch = NULL,
             *link_status = NULL;
        UNUSED(link_status);
        int i = 0;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            switch(i++){
            case 0: name = token; break;
          ...",1,24,redis-cli.c,clusterManagerNodeLoadInfo,,false,5318,5488,clusterManagerNodeLoadInfo,,,247,"int clusterManagerNodeLoadInfo (clusterManagerNode*,int,char**)"
297242,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerLoadInfoFromNode(clusterManagerNode *node) {
    if (node->context == NULL && !clusterManagerNodeConnect(node)) {
        freeClusterManagerNode(node);
        return 0;
    }
    char *e = NULL;
    if (!clusterManagerNodeIsCluster(node, &e)) {
        clusterManagerPrintNotClusterNodeError(node, e);
        if (e) zfree(e);
        freeClusterManagerNode(node);
        return 0;
    }
    e = NULL;
    if (!clusterManagerNodeLoadInfo(node, CLUSTER_MANAGER_OPT_GETFRIENDS, &e)) {
        if (e) {
            CLUSTER_MANAGER_PRINT_REPLY_ERROR(node, e);
            zfree(e);
        }
        freeClusterManagerNode(node);
        return 0;
    }
    listIter li;
    listNode *ln;
    if (cluster_manager.nodes != NULL) {
        listRewind(cluster_manager.nodes, &li);
        while ((ln = listNext(&li)) != NULL)
            freeClusterManagerNode((clusterManagerNode *) ln->value);
        listRelease(cluster_manager.nodes);
    }
    cluster_manager.nodes = lis...",1,42,redis-cli.c,clusterManagerLoadInfoFromNode,,false,5494,5570,clusterManagerLoadInfoFromNode,,,248,int clusterManagerLoadInfoFromNode (clusterManagerNode*)
297561,METHOD,redis-cli.c:<global>,TYPE_DECL,"int clusterManagerSlotCompare(const void *slot1, const void *slot2) {
    const char **i1 = (const char **)slot1;
    const char **i2 = (const char **)slot2;
    return strcmp(*i1, *i2);
}",1,1,redis-cli.c,clusterManagerSlotCompare,,false,5573,5577,clusterManagerSlotCompare,,,249,"int clusterManagerSlotCompare (void*,void*)"
297585,METHOD,redis-cli.c:<global>,TYPE_DECL,"int clusterManagerSlotCountCompareDesc(const void *n1, const void *n2) {
    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
    clusterManagerNode *node2 = *((clusterManagerNode **) n2);
    return node2->slots_count - node1->slots_count;
}",1,1,redis-cli.c,clusterManagerSlotCountCompareDesc,,false,5579,5583,clusterManagerSlotCountCompareDesc,,,250,"int clusterManagerSlotCountCompareDesc (void*,void*)"
297613,METHOD,redis-cli.c:<global>,TYPE_DECL,"int clusterManagerCompareNodeBalance(const void *n1, const void *n2) {
    clusterManagerNode *node1 = *((clusterManagerNode **) n1);
    clusterManagerNode *node2 = *((clusterManagerNode **) n2);
    return node1->balance - node2->balance;
}",1,1,redis-cli.c,clusterManagerCompareNodeBalance,,false,5585,5589,clusterManagerCompareNodeBalance,,,251,"int clusterManagerCompareNodeBalance (void*,void*)"
297641,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds clusterManagerGetConfigSignature(clusterManagerNode *node) {
    sds signature = NULL;
    int node_count = 0, i = 0, name_len = 0;
    char **node_configs = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    if (reply == NULL || reply->type == REDIS_REPLY_ERROR)
        goto cleanup;
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        i = 0;
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *nodename = NULL;
        int tot_size = 0;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            if (i == 0) {
                nodename = token;
                tot_size = (p - token);
                name_len = tot_size++; // Make room for ':' in tot_size
            }
            if (++i == 8) break;
        }
        if (i != 8) continue;
        if (nodename == NULL) continue;
        int re...",1,24,redis-cli.c,clusterManagerGetConfigSignature,,false,5591,5682,clusterManagerGetConfigSignature,,,252,sds clusterManagerGetConfigSignature (clusterManagerNode*)
298075,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerIsConfigConsistent(void) {
    if (cluster_manager.nodes == NULL) return 0;
    int consistent = (listLength(cluster_manager.nodes) <= 1);
    // If the Cluster has only one node, it's always consistent
    if (consistent) return 1;
    sds first_cfg = NULL;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        sds cfg = clusterManagerGetConfigSignature(node);
        if (cfg == NULL) {
            consistent = 0;
            break;
        }
        if (first_cfg == NULL) first_cfg = cfg;
        else {
            consistent = !sdscmp(first_cfg, cfg);
            sdsfree(cfg);
            if (!consistent) break;
        }
    }
    if (first_cfg != NULL) sdsfree(first_cfg);
    return consistent;
}",1,22,redis-cli.c,clusterManagerIsConfigConsistent,,false,5684,5709,clusterManagerIsConfigConsistent,,,253,int clusterManagerIsConfigConsistent (void)
298182,METHOD,redis-cli.c:<global>,TYPE_DECL,"static list *clusterManagerGetDisconnectedLinks(clusterManagerNode *node) {
    list *links = NULL;
    redisReply *reply = CLUSTER_MANAGER_COMMAND(node, ""CLUSTER NODES"");
    if (!clusterManagerCheckRedisReply(node, reply, NULL)) goto cleanup;
    links = listCreate();
    char *lines = reply->str, *p, *line;
    while ((p = strstr(lines, ""\n"")) != NULL) {
        int i = 0;
        *p = '\0';
        line = lines;
        lines = p + 1;
        char *nodename = NULL, *addr = NULL, *flags = NULL, *link_status = NULL;
        while ((p = strchr(line, ' ')) != NULL) {
            *p = '\0';
            char *token = line;
            line = p + 1;
            if (i == 0) nodename = token;
            else if (i == 1) addr = token;
            else if (i == 2) flags = token;
            else if (i == 7) link_status = token;
            else if (i == 8) break;
            i++;
        }
        if (i == 7) link_status = line;
        if (nodename == NULL || addr == NULL || flags == NUL...",1,24,redis-cli.c,clusterManagerGetDisconnectedLinks,,false,5711,5753,clusterManagerGetDisconnectedLinks,,,254,list clusterManagerGetDisconnectedLinks (clusterManagerNode*)
298433,METHOD,redis-cli.c:<global>,TYPE_DECL,"static dict *clusterManagerGetLinkStatus(void) {
    if (cluster_manager.nodes == NULL) return NULL;
    dict *status = dictCreate(&clusterManagerLinkDictType);
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        list *links = clusterManagerGetDisconnectedLinks(node);
        if (links) {
            listIter lli;
            listNode *lln;
            listRewind(links, &lli);
            while ((lln = listNext(&lli)) != NULL) {
                clusterManagerLink *link = lln->value;
                list *from = NULL;
                dictEntry *entry = dictFind(status, link->node_addr);
                if (entry) from = dictGetVal(entry);
                else {
                    from = listCreate();
                    dictAdd(status, sdsdup(link->node_addr), from);
                }
                sds myaddr = sdsempty();
                myaddr = sdscatfmt(m...",1,1,redis-cli.c,clusterManagerGetLinkStatus,,false,5758,5791,clusterManagerGetLinkStatus,,,255,dict clusterManagerGetLinkStatus (void)
298568,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerOnError(sds err) {
    if (cluster_manager.errors == NULL)
        cluster_manager.errors = listCreate();
    listAddNodeTail(cluster_manager.errors, err);
    clusterManagerLogErr(""%s\n"", (char *) err);
}",1,4,redis-cli.c,clusterManagerOnError,,false,5794,5799,clusterManagerOnError,,,256,void clusterManagerOnError (sds)
298598,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerGetCoveredSlots(char *all_slots) {
    if (cluster_manager.nodes == NULL) return 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    int totslots = 0, i;
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
            if (node->slots[i] && !all_slots[i]) {
                all_slots[i] = 1;
                totslots++;
            }
        }
    }
    return totslots;
}",1,24,redis-cli.c,clusterManagerGetCoveredSlots,,false,5804,5820,clusterManagerGetCoveredSlots,,,257,int clusterManagerGetCoveredSlots (char*)
298674,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerPrintSlotsList(list *slots) {
    clusterManagerNode n = {0};
    listIter li;
    listNode *ln;
    listRewind(slots, &li);
    while ((ln = listNext(&li)) != NULL) {
        int slot = atoi(ln->value);
        if (slot >= 0 && slot < CLUSTER_MANAGER_SLOTS)
            n.slots[slot] = 1;
    }
    sds nodeslist = clusterManagerNodeSlotsString(&n);
    printf(""%s\n"", nodeslist);
    sdsfree(nodeslist);
}",1,32,redis-cli.c,clusterManagerPrintSlotsList,,false,5822,5835,clusterManagerPrintSlotsList,,,258,void clusterManagerPrintSlotsList (list*)
298735,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode * clusterManagerGetNodeWithMostKeysInSlot(list *nodes,
                                                                    int slot,
                                                                    char **err)
{
    clusterManagerNode *node = NULL;
    int numkeys = 0;
    listIter li;
    listNode *ln;
    listRewind(nodes, &li);
    if (err) *err = NULL;
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE || n->replicate)
            continue;
        redisReply *r =
            CLUSTER_MANAGER_COMMAND(n, ""CLUSTER COUNTKEYSINSLOT %d"", slot);
        int success = clusterManagerCheckRedisReply(n, r, err);
        if (success) {
            if (r->integer > numkeys || node == NULL) {
                numkeys = r->integer;
                node = n;
            }
        }
        if (r != NULL) freeReplyObject(r);
        /* If the reply contains errors */
        if (!succ...",1,23,redis-cli.c,clusterManagerGetNodeWithMostKeysInSlot,,false,5839,5872,clusterManagerGetNodeWithMostKeysInSlot,,,259,"clusterManagerNode clusterManagerGetNodeWithMostKeysInSlot (list*,int,char**)"
298876,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerNodeWithLeastReplicas(void) {
    clusterManagerNode *node = NULL;
    int lowest_count = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        if (node == NULL || n->replicas_count < lowest_count) {
            node = n;
            lowest_count = n->replicas_count;
        }
    }
    return node;
}",1,23,redis-cli.c,clusterManagerNodeWithLeastReplicas,,false,5878,5893,clusterManagerNodeWithLeastReplicas,,,260,clusterManagerNode clusterManagerNodeWithLeastReplicas (void)
298945,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterManagerNodeMasterRandom(void) {
    int master_count = 0;
    int idx;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        master_count++;
    }

    assert(master_count > 0);
    srand(time(NULL));
    idx = rand() % master_count;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if (n->flags & CLUSTER_MANAGER_FLAG_SLAVE) continue;
        if (!idx--) {
            return n;
        }
    }
    /* Can not be reached */
    assert(0);
}",1,23,redis-cli.c,clusterManagerNodeMasterRandom,,false,5897,5922,clusterManagerNodeMasterRandom,,,261,clusterManagerNode clusterManagerNodeMasterRandom (void)
299046,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerFixSlotsCoverage(char *all_slots) {
    int force_fix = config.cluster_manager_command.flags &
                    CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS;

    if (cluster_manager.unreachable_masters > 0 && !force_fix) {
        clusterManagerLogWarn(""*** Fixing slots coverage with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\n"", cluster_manager.unreachable_masters);
        exit(1);
    }

    int i, fixed = 0;
    list *none = NULL, *single = NULL, *multi = NULL;
    clusterManagerLogInfo("">>> Fixing slots coverage...\n"");
    for (i = 0; i < CLUSTER_MANAGER_SLOTS; i++) {
        int covered = all_slots[i];
        if (!covered) {
            sds slot = sdsfromlonglong...",1,20,redis-cli.c,clusterManagerFixSlotsCoverage,,false,5924,6121,clusterManagerFixSlotsCoverage,,,262,int clusterManagerFixSlotsCoverage (char*)
299769,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerFixOpenSlot(int slot) {
    int force_fix = config.cluster_manager_command.flags &
                    CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS;

    if (cluster_manager.unreachable_masters > 0 && !force_fix) {
        clusterManagerLogWarn(""*** Fixing open slots with %d unreachable masters is dangerous: redis-cli will assume that slots about masters that are not reachable are not covered, and will try to reassign them to the reachable nodes. This can cause data loss and is rarely what you want to do. If you really want to proceed use the --cluster-fix-with-unreachable-masters option.\n"", cluster_manager.unreachable_masters);
        exit(1);
    }

    clusterManagerLogInfo("">>> Fixing open slot %d\n"", slot);
    /* Try to obtain the current slot owner, according to the current
     * nodes configuration. */
    int success = 1;
    list *owners = listCreate();    /* List of nodes claiming some ownership.
                                       ...",1,20,redis-cli.c,clusterManagerFixOpenSlot,,false,6126,6456,clusterManagerFixOpenSlot,,,263,int clusterManagerFixOpenSlot (int)
301077,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerFixMultipleSlotOwners(int slot, list *owners) {
    clusterManagerLogInfo("">>> Fixing multiple owners for slot %d...\n"", slot);
    int success = 0;
    assert(listLength(owners) > 1);
    clusterManagerNode *owner = clusterManagerGetNodeWithMostKeysInSlot(owners,
                                                                        slot,
                                                                        NULL);
    if (!owner) owner = listFirst(owners)->value;
    clusterManagerLogInfo("">>> Setting slot %d owner: %s:%d\n"",
                          slot, owner->ip, owner->port);
    /* Set the slot owner. */
    if (!clusterManagerSetSlotOwner(owner, slot, 0)) return 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    /* Update configuration in all the other master nodes by assigning the slot
     * itself to the new owner, and by eventually migrating keys if the node
     * has keys for the slot. */
    while ((ln = ...",1,4,redis-cli.c,clusterManagerFixMultipleSlotOwners,,false,6458,6493,clusterManagerFixMultipleSlotOwners,,,264,"int clusterManagerFixMultipleSlotOwners (int,list*)"
301250,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCheckCluster(int quiet) {
    listNode *ln = listFirst(cluster_manager.nodes);
    if (!ln) return 0;
    clusterManagerNode *node = ln->value;
    clusterManagerLogInfo("">>> Performing Cluster Check (using node %s:%d)\n"",
                          node->ip, node->port);
    int result = 1, consistent = 0;
    int do_fix = config.cluster_manager_command.flags &
                 CLUSTER_MANAGER_CMD_FLAG_FIX;
    if (!quiet) clusterManagerShowNodes();
    consistent = clusterManagerIsConfigConsistent();
    if (!consistent) {
        sds err = sdsnew(""[ERR] Nodes don't agree about configuration!"");
        clusterManagerOnError(err);
        result = 0;
    } else {
        clusterManagerLogOk(""[OK] All nodes agree about slots ""
                            ""configuration.\n"");
    }
    /* Check open slots */
    clusterManagerLogInfo("">>> Check for open slots...\n"");
    listIter li;
    listRewind(cluster_manager.nodes, &li);
    int i;
    dict *open_slots ...",1,19,redis-cli.c,clusterManagerCheckCluster,,false,6495,6657,clusterManagerCheckCluster,,,265,int clusterManagerCheckCluster (int)
301931,METHOD,redis-cli.c:<global>,TYPE_DECL,"static clusterManagerNode *clusterNodeForResharding(char *id,
                                                    clusterManagerNode *target,
                                                    int *raise_err)
{
    clusterManagerNode *node = NULL;
    const char *invalid_node_msg = ""*** The specified node (%s) is not known ""
                                   ""or not a master, please retry.\n"";
    node = clusterManagerNodeByName(id);
    *raise_err = 0;
    if (!node || node->flags & CLUSTER_MANAGER_FLAG_SLAVE) {
        clusterManagerLogErr(invalid_node_msg, id);
        *raise_err = 1;
        return NULL;
    } else if (target != NULL) {
        if (!strcmp(node->name, target->name)) {
            clusterManagerLogErr( ""*** It is not possible to use ""
                                  ""the target node as ""
                                  ""source node.\n"");
            return NULL;
        }
    }
    return node;
}",1,31,redis-cli.c,clusterNodeForResharding,,false,6659,6681,clusterNodeForResharding,,,266,"clusterManagerNode clusterNodeForResharding (char*,clusterManagerNode*,int*)"
302006,METHOD,redis-cli.c:<global>,TYPE_DECL,"static list *clusterManagerComputeReshardTable(list *sources, int numslots) {
    list *moved = listCreate();
    int src_count = listLength(sources), i = 0, tot_slots = 0, j;
    clusterManagerNode **sorted = zmalloc(src_count * sizeof(*sorted));
    listIter li;
    listNode *ln;
    listRewind(sources, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *node = ln->value;
        tot_slots += node->slots_count;
        sorted[i++] = node;
    }
    qsort(sorted, src_count, sizeof(clusterManagerNode *),
          clusterManagerSlotCountCompareDesc);
    for (i = 0; i < src_count; i++) {
        clusterManagerNode *node = sorted[i];
        float n = ((float) numslots / tot_slots * node->slots_count);
        if (i == 0) n = ceil(n);
        else n = floor(n);
        int max = (int) n, count = 0;
        for (j = 0; j < CLUSTER_MANAGER_SLOTS; j++) {
            int slot = node->slots[j];
            if (!slot) continue;
            if (count >= max || (int)...",1,20,redis-cli.c,clusterManagerComputeReshardTable,,false,6683,6716,clusterManagerComputeReshardTable,,,267,"list clusterManagerComputeReshardTable (list*,int)"
302204,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerShowReshardTable(list *table) {
    listIter li;
    listNode *ln;
    listRewind(table, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerReshardTableItem *item = ln->value;
        clusterManagerNode *n = item->source;
        printf(""    Moving slot %d from %s\n"", item->slot, (char *) n->name);
    }
}",1,1,redis-cli.c,clusterManagerShowReshardTable,,false,6718,6727,clusterManagerShowReshardTable,,,268,void clusterManagerShowReshardTable (list*)
302246,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerReleaseReshardTable(list *table) {
    if (table != NULL) {
        listIter li;
        listNode *ln;
        listRewind(table, &li);
        while ((ln = listNext(&li)) != NULL) {
            clusterManagerReshardTableItem *item = ln->value;
            zfree(item);
        }
        listRelease(table);
    }
}",1,1,redis-cli.c,clusterManagerReleaseReshardTable,,false,6729,6740,clusterManagerReleaseReshardTable,,,269,void clusterManagerReleaseReshardTable (list*)
302281,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerLog(int level, const char* fmt, ...) {
    int use_colors =
        (config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_COLOR);
    if (use_colors) {
        printf(""\033["");
        switch (level) {
        case CLUSTER_MANAGER_LOG_LVL_INFO: printf(LOG_COLOR_BOLD); break;
        case CLUSTER_MANAGER_LOG_LVL_WARN: printf(LOG_COLOR_YELLOW); break;
        case CLUSTER_MANAGER_LOG_LVL_ERR: printf(LOG_COLOR_RED); break;
        case CLUSTER_MANAGER_LOG_LVL_SUCCESS: printf(LOG_COLOR_GREEN); break;
        default: printf(LOG_COLOR_RESET); break;
        }
    }
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    va_end(ap);
    if (use_colors) printf(""\033["" LOG_COLOR_RESET);
}",1,48,redis-cli.c,clusterManagerLog,,false,6742,6760,clusterManagerLog,,,270,"void clusterManagerLog (int,char*...)"
302365,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayInit(clusterManagerNodeArray *array,
                                        int alloc_len)
{
    array->nodes = zcalloc(alloc_len * sizeof(clusterManagerNode*));
    array->alloc = array->nodes;
    array->len = alloc_len;
    array->count = 0;
}",1,1,redis-cli.c,clusterManagerNodeArrayInit,,false,6762,6769,clusterManagerNodeArrayInit,,,271,"void clusterManagerNodeArrayInit (clusterManagerNodeArray*,int)"
302397,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayReset(clusterManagerNodeArray *array) {
    if (array->nodes > array->alloc) {
        array->len = array->nodes - array->alloc;
        array->nodes = array->alloc;
        array->count = 0;
        int i = 0;
        for(; i < array->len; i++) {
            if (array->nodes[i] != NULL) array->count++;
        }
    }
}",1,1,redis-cli.c,clusterManagerNodeArrayReset,,false,6773,6783,clusterManagerNodeArrayReset,,,272,void clusterManagerNodeArrayReset (clusterManagerNodeArray*)
302461,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayShift(clusterManagerNodeArray *array,
                                         clusterManagerNode **nodeptr)
{
    assert(array->len > 0);
    /* If the first node to be shifted is not NULL, decrement count. */
    if (*array->nodes != NULL) array->count--;
    /* Store the first node to be shifted into 'nodeptr'. */
    *nodeptr = *array->nodes;
    /* Shift the nodes array and decrement length. */
    array->nodes++;
    array->len--;
}",1,1,redis-cli.c,clusterManagerNodeArrayShift,,false,6786,6797,clusterManagerNodeArrayShift,,,273,"void clusterManagerNodeArrayShift (clusterManagerNodeArray*,clusterManagerNode**)"
302500,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerNodeArrayAdd(clusterManagerNodeArray *array,
                                       clusterManagerNode *node)
{
    assert(array->len > 0);
    assert(node != NULL);
    assert(array->count < array->len);
    array->nodes[array->count++] = node;
}",1,1,redis-cli.c,clusterManagerNodeArrayAdd,,false,6799,6806,clusterManagerNodeArrayAdd,,,274,"void clusterManagerNodeArrayAdd (clusterManagerNodeArray*,clusterManagerNode*)"
302534,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerPrintNotEmptyNodeError(clusterManagerNode *node,
                                                 char *err)
{
    char *msg;
    if (err) msg = err;
    else {
        msg = ""is not empty. Either the node already knows other ""
              ""nodes (check with CLUSTER NODES) or contains some ""
              ""key in database 0."";
    }
    clusterManagerLogErr(""[ERR] Node %s:%d %s\n"", node->ip, node->port, msg);
}",1,4,redis-cli.c,clusterManagerPrintNotEmptyNodeError,,false,6808,6819,clusterManagerPrintNotEmptyNodeError,,,275,"void clusterManagerPrintNotEmptyNodeError (clusterManagerNode*,char*)"
302564,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerPrintNotClusterNodeError(clusterManagerNode *node,
                                                   char *err)
{
    char *msg = (err ? err : ""is not configured as a cluster node."");
    clusterManagerLogErr(""[ERR] Node %s:%d %s\n"", node->ip, node->port, msg);
}",1,4,redis-cli.c,clusterManagerPrintNotClusterNodeError,,false,6821,6826,clusterManagerPrintNotClusterNodeError,,,276,"void clusterManagerPrintNotClusterNodeError (clusterManagerNode*,char*)"
302589,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void clusterManagerMode(clusterManagerCommandProc *proc) {
    int argc = config.cluster_manager_command.argc;
    char **argv = config.cluster_manager_command.argv;
    cluster_manager.nodes = NULL;
    int success = proc(argc, argv);

    /* Initialized in createClusterManagerCommand. */
    if (config.stdin_lastarg) {
        zfree(config.cluster_manager_command.argv);
        sdsfree(config.cluster_manager_command.stdin_arg);
    } else if (config.stdin_tag_arg) {
        sdsfree(config.cluster_manager_command.stdin_arg);
    }
    freeClusterManager();

    exit(success ? 0 : 1);
}",1,1,redis-cli.c,clusterManagerMode,,false,6829,6845,clusterManagerMode,,,277,void clusterManagerMode (clusterManagerCommandProc*)
302657,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandCreate(int argc, char **argv) {
    int i, j, success = 1;
    cluster_manager.nodes = listCreate();
    for (i = 0; i < argc; i++) {
        char *addr = argv[i];
        char *ip = NULL;
        int port = 0;
        if (!parseClusterNodeAddress(addr, &ip, &port, NULL)) {
            fprintf(stderr, ""Invalid address format: %s\n"", addr);
            return 0;
        }

        clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
        if (!clusterManagerNodeConnect(node)) {
            freeClusterManagerNode(node);
            return 0;
        }
        char *err = NULL;
        if (!clusterManagerNodeIsCluster(node, &err)) {
            clusterManagerPrintNotClusterNodeError(node, err);
            if (err) zfree(err);
            freeClusterManagerNode(node);
            return 0;
        }
        err = NULL;
        if (!clusterManagerNodeLoadInfo(node, 0, &err)) {
            if (err) {
                CLUSTER_MANAGER_PRINT_REPLY_...",1,16,redis-cli.c,clusterManagerCommandCreate,,false,6849,7140,clusterManagerCommandCreate,,,278,"int clusterManagerCommandCreate (int,char**)"
303913,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandAddNode(int argc, char **argv) {
    int success = 1;
    redisReply *reply = NULL;
    redisReply *function_restore_reply = NULL;
    redisReply *function_list_reply = NULL;
    char *ref_ip = NULL, *ip = NULL;
    int ref_port = 0, port = 0;
    if (!getClusterHostFromCmdArgs(argc - 1, argv + 1, &ref_ip, &ref_port))
        goto invalid_args;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port))
        goto invalid_args;
    clusterManagerLogInfo("">>> Adding node %s:%d to cluster %s:%d\n"", ip, port,
                          ref_ip, ref_port);
    // Check the existing cluster
    clusterManagerNode *refnode = clusterManagerNewNode(ref_ip, ref_port, 0);
    if (!clusterManagerLoadInfoFromNode(refnode)) return 0;
    if (!clusterManagerCheckCluster(0)) return 0;

    /* If --cluster-master-id was specified, try to resolve it now so that we
     * abort before starting with the node configuration. */
    clusterManagerNode *master_node = NULL;
   ...",1,4,redis-cli.c,clusterManagerCommandAddNode,,false,7142,7295,clusterManagerCommandAddNode,,,279,"int clusterManagerCommandAddNode (int,char**)"
304539,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandDeleteNode(int argc, char **argv) {
    UNUSED(argc);
    int success = 1;
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    char *node_id = argv[1];
    clusterManagerLogInfo("">>> Removing node %s from cluster %s:%d\n"",
                          node_id, ip, port);
    clusterManagerNode *ref_node = clusterManagerNewNode(ip, port, 0);
    clusterManagerNode *node = NULL;

    // Load cluster information
    if (!clusterManagerLoadInfoFromNode(ref_node)) return 0;

    // Check if the node exists and is not empty
    node = clusterManagerNodeByName(node_id);
    if (node == NULL) {
        clusterManagerLogErr(""[ERR] No such node ID %s\n"", node_id);
        return 0;
    }
    if (node->slots_count != 0) {
        clusterManagerLogErr(""[ERR] Node %s:%d is not empty! Reshard data ""
                             ""away and try again.\n"", node->ip, node->port);
        return 0;
    }

  ...",1,4,redis-cli.c,clusterManagerCommandDeleteNode,,false,7297,7362,clusterManagerCommandDeleteNode,,,280,"int clusterManagerCommandDeleteNode (int,char**)"
304809,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandInfo(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    clusterManagerShowClusterInfo();
    return 1;
invalid_args:
    fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
    return 0;
}",1,20,redis-cli.c,clusterManagerCommandInfo,,false,7364,7375,clusterManagerCommandInfo,,,281,"int clusterManagerCommandInfo (int,char**)"
304859,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandCheck(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    clusterManagerShowClusterInfo();
    return clusterManagerCheckCluster(0);
invalid_args:
    fprintf(stderr, CLUSTER_MANAGER_INVALID_HOST_ARG);
    return 0;
}",1,20,redis-cli.c,clusterManagerCommandCheck,,false,7377,7388,clusterManagerCommandCheck,,,282,"int clusterManagerCommandCheck (int,char**)"
304910,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandFix(int argc, char **argv) {
    config.cluster_manager_command.flags |= CLUSTER_MANAGER_CMD_FLAG_FIX;
    return clusterManagerCommandCheck(argc, argv);
}",1,44,redis-cli.c,clusterManagerCommandFix,,false,7390,7393,clusterManagerCommandFix,,,283,"int clusterManagerCommandFix (int,char**)"
304931,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandReshard(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    clusterManagerCheckCluster(0);
    if (cluster_manager.errors && listLength(cluster_manager.errors) > 0) {
        fflush(stdout);
        fprintf(stderr,
                ""*** Please fix your cluster problems before resharding\n"");
        return 0;
    }
    int slots = config.cluster_manager_command.slots;
    if (!slots) {
        while (slots <= 0 || slots > CLUSTER_MANAGER_SLOTS) {
            printf(""How many slots do you want to move (from 1 to %d)? "",
                   CLUSTER_MANAGER_SLOTS);
            fflush(stdout);
            char buf[6];
            int nread = read(fileno(stdin),buf,6);
            if (nread <= 0) continue;
            int last_idx = nread - 1;...",1,34,redis-cli.c,clusterManagerCommandReshard,,false,7395,7580,clusterManagerCommandReshard,,,284,"int clusterManagerCommandReshard (int,char**)"
305667,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandRebalance(int argc, char **argv) {
    int port = 0;
    char *ip = NULL;
    clusterManagerNode **weightedNodes = NULL;
    list *involved = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    int result = 1, i;
    if (config.cluster_manager_command.weight != NULL) {
        for (i = 0; i < config.cluster_manager_command.weight_argc; i++) {
            char *name = config.cluster_manager_command.weight[i];
            char *p = strchr(name, '=');
            if (p == NULL) {
                clusterManagerLogErr(""*** invalid input %s\n"", name);
                result = 0;
                goto cleanup;
            }
            *p = '\0';
            float w = atof(++p);
            clusterManagerNode *n = clusterManagerNodeByAbbreviatedName(name);
            if (n == NULL) {
                ...",1,16,redis-cli.c,clusterManagerCommandRebalance,,false,7582,7775,clusterManagerCommandRebalance,,,285,"int clusterManagerCommandRebalance (int,char**)"
306444,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandSetTimeout(int argc, char **argv) {
    UNUSED(argc);
    int port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    int timeout = atoi(argv[1]);
    if (timeout < 100) {
        fprintf(stderr, ""Setting a node timeout of less than 100 ""
                ""milliseconds is a bad idea.\n"");
        return 0;
    }
    // Load cluster information
    clusterManagerNode *node = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(node)) return 0;
    int ok_count = 0, err_count = 0;

    clusterManagerLogInfo("">>> Reconfiguring node timeout in every ""
                          ""cluster node...\n"");
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        char *err = NULL;
        redisReply *reply = CLUSTER_MANAGER_COMMAND(n, ""CONFIG %s %s %d"",
                     ...",1,4,redis-cli.c,clusterManagerCommandSetTimeout,,false,7777,7833,clusterManagerCommandSetTimeout,,,286,"int clusterManagerCommandSetTimeout (int,char**)"
306680,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandImport(int argc, char **argv) {
    int success = 1;
    int port = 0, src_port = 0;
    char *ip = NULL, *src_ip = NULL;
    char *invalid_args_msg = NULL;
    sds cmdfmt = NULL;
    if (!getClusterHostFromCmdArgs(argc, argv, &ip, &port)) {
        invalid_args_msg = CLUSTER_MANAGER_INVALID_HOST_ARG;
        goto invalid_args;
    }
    if (config.cluster_manager_command.from == NULL) {
        invalid_args_msg = ""[ERR] Option '--cluster-from' is required for ""
                           ""subcommand 'import'.\n"";
        goto invalid_args;
    }
    char *src_host[] = {config.cluster_manager_command.from};
    if (!getClusterHostFromCmdArgs(1, src_host, &src_ip, &src_port)) {
        invalid_args_msg = ""[ERR] Invalid --cluster-from host. You need to ""
                           ""pass a valid address (ie. 120.0.0.1:7000).\n"";
        goto invalid_args;
    }
    clusterManagerLogInfo("">>> Importing data from %s:%d to cluster %s:%d\n"",
                ...",1,27,redis-cli.c,clusterManagerCommandImport,,false,7835,7988,clusterManagerCommandImport,,,287,"int clusterManagerCommandImport (int,char**)"
307392,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandCall(int argc, char **argv) {
    int port = 0, i;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(refnode)) return 0;
    argc--;
    argv++;
    size_t *argvlen = zmalloc(argc*sizeof(size_t));
    clusterManagerLogInfo("">>> Calling"");
    for (i = 0; i < argc; i++) {
        argvlen[i] = strlen(argv[i]);
        printf("" %s"", argv[i]);
    }
    printf(""\n"");
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        clusterManagerNode *n = ln->value;
        if ((config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_MASTERS_ONLY)
              && (n->replicate != NULL)) continue;  // continue if node is slave
        if ((config.cluster_manager_command.flags & CLUSTER_MANAGER_CMD_FLAG_SLAVES_ONLY)
              &...",1,4,redis-cli.c,clusterManagerCommandCall,,false,7990,8032,clusterManagerCommandCall,,,288,"int clusterManagerCommandCall (int,char**)"
307629,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandBackup(int argc, char **argv) {
    UNUSED(argc);
    int success = 1, port = 0;
    char *ip = NULL;
    if (!getClusterHostFromCmdArgs(1, argv, &ip, &port)) goto invalid_args;
    clusterManagerNode *refnode = clusterManagerNewNode(ip, port, 0);
    if (!clusterManagerLoadInfoFromNode(refnode)) return 0;
    int no_issues = clusterManagerCheckCluster(0);
    int cluster_errors_count = (no_issues ? 0 :
                                listLength(cluster_manager.errors));
    config.cluster_manager_command.backup_dir = argv[1];
    /* TODO: check if backup_dir is a valid directory. */
    sds json = sdsnew(""[\n"");
    int first_node = 0;
    listIter li;
    listNode *ln;
    listRewind(cluster_manager.nodes, &li);
    while ((ln = listNext(&li)) != NULL) {
        if (!first_node) first_node = 1;
        else json = sdscat(json, "",\n"");
        clusterManagerNode *node = ln->value;
        sds node_json = clusterManagerNodeGetJSON(node, cluster_errors...",1,4,redis-cli.c,clusterManagerCommandBackup,,false,8034,8096,clusterManagerCommandBackup,,,289,"int clusterManagerCommandBackup (int,char**)"
307899,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int clusterManagerCommandHelp(int argc, char **argv) {
    UNUSED(argc);
    UNUSED(argv);
    int commands_count = sizeof(clusterManagerCommands) /
                         sizeof(clusterManagerCommandDef);
    int i = 0, j;
    fprintf(stdout, ""Cluster Manager Commands:\n"");
    int padding = 15;
    for (; i < commands_count; i++) {
        clusterManagerCommandDef *def = &(clusterManagerCommands[i]);
        int namelen = strlen(def->name), padlen = padding - namelen;
        fprintf(stdout, ""  %s"", def->name);
        for (j = 0; j < padlen; j++) fprintf(stdout, "" "");
        fprintf(stdout, ""%s\n"", (def->args ? def->args : """"));
        if (def->options != NULL) {
            int optslen = strlen(def->options);
            char *p = def->options, *eos = p + optslen;
            char *comma = NULL;
            while ((comma = strchr(p, ',')) != NULL) {
                int deflen = (int)(comma - p);
                char buf[255];
                memcpy(buf, p, deflen);
  ...",1,4,redis-cli.c,clusterManagerCommandHelp,,false,8098,8151,clusterManagerCommandHelp,,,290,"int clusterManagerCommandHelp (int,char**)"
308177,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void latencyModePrint(long long min, long long max, double avg, long long count) {
    if (config.output == OUTPUT_STANDARD) {
        printf(""min: %lld, max: %lld, avg: %.2f (%lld samples)"",
                min, max, avg, count);
        fflush(stdout);
    } else if (config.output == OUTPUT_CSV) {
        printf(""%lld,%lld,%.2f,%lld\n"", min, max, avg, count);
    } else if (config.output == OUTPUT_RAW) {
        printf(""%lld %lld %.2f %lld\n"", min, max, avg, count);
    } else if (config.output == OUTPUT_JSON) {
        printf(""{\""min\"": %lld, \""max\"": %lld, \""avg\"": %.2f, \""count\"": %lld}\n"", min, max, avg, count);
    }
}",1,25,redis-cli.c,latencyModePrint,,false,8157,8169,latencyModePrint,,,291,"void latencyModePrint (long long,long long,double,long long)"
308253,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void latencyMode(void) {
    redisReply *reply;
    long long start, latency, min = 0, max = 0, tot = 0, count = 0;
    long long history_interval =
        config.interval ? config.interval/1000 :
                          LATENCY_HISTORY_DEFAULT_INTERVAL;
    double avg;
    long long history_start = mstime();

    /* Set a default for the interval in case of --latency option
     * with --raw, --csv or when it is redirected to non tty. */
    if (config.interval == 0) {
        config.interval = 1000;
    } else {
        config.interval /= 1000; /* We need to convert to milliseconds. */
    }

    if (!context) exit(1);
    while(1) {
        start = mstime();
        reply = reconnectingRedisCommand(context,""PING"");
        if (reply == NULL) {
            fprintf(stderr,""\nI/O error\n"");
            exit(1);
        }
        latency = mstime()-start;
        freeReplyObject(reply);
        count++;
        if (count == 1) {
            min = max = tot = latency;
      ...",1,26,redis-cli.c,latencyMode,,false,8173,8231,latencyMode,,,292,void latencyMode (void)
308485,METHOD,redis-cli.c:<global>,TYPE_DECL,"void showLatencyDistSamples(struct distsamples *samples, long long tot) {
    int j;

     /* We convert samples into an index inside the palette
     * proportional to the percentage a given bucket represents.
     * This way intensity of the different parts of the spectrum
     * don't change relative to the number of requests, which avoids to
     * pollute the visualization with non-latency related info. */
    printf(""\033[38;5;0m""); /* Set foreground color to black. */
    for (j = 0; ; j++) {
        int coloridx =
            ceil((double) samples[j].count / tot * (spectrum_palette_size-1));
        int color = spectrum_palette[coloridx];
        printf(""\033[48;5;%dm%c"", (int)color, samples[j].character);
        samples[j].count = 0;
        if (samples[j].max == 0) break; /* Last sample. */
    }
    printf(""\033[0m\n"");
    fflush(stdout);
}",1,1,redis-cli.c,showLatencyDistSamples,,false,8257,8276,showLatencyDistSamples,,,294,"void showLatencyDistSamples (distsamples*,long long)"
308556,METHOD,redis-cli.c:<global>,TYPE_DECL,"void showLatencyDistLegend(void) {
    int j;

    printf(""---------------------------------------------\n"");
    printf("". - * #          .01 .125 .25 .5 milliseconds\n"");
    printf(""1,2,3,...,9      from 1 to 9     milliseconds\n"");
    printf(""A,B,C,D,E        10,20,30,40,50  milliseconds\n"");
    printf(""F,G,H,I,J        .1,.2,.3,.4,.5       seconds\n"");
    printf(""K,L,M,N,O,P,Q,?  1,2,4,8,16,30,60,>60 seconds\n"");
    printf(""From 0 to 100%%: "");
    for (j = 0; j < spectrum_palette_size; j++) {
        printf(""\033[48;5;%dm "", spectrum_palette[j]);
    }
    printf(""\033[0m\n"");
    printf(""---------------------------------------------\n"");
}",1,1,redis-cli.c,showLatencyDistLegend,,false,8280,8295,showLatencyDistLegend,,,295,void showLatencyDistLegend (void)
308596,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void latencyDistMode(void) {
    redisReply *reply;
    long long start, latency, count = 0;
    long long history_interval =
        config.interval ? config.interval/1000 :
                          LATENCY_DIST_DEFAULT_INTERVAL;
    long long history_start = ustime();
    int j, outputs = 0;

    struct distsamples samples[] = {
        /* We use a mostly logarithmic scale, with certain linear intervals
         * which are more interesting than others, like 1-10 milliseconds
         * range. */
        {10,0,'.'},         /* 0.01 ms */
        {125,0,'-'},        /* 0.125 ms */
        {250,0,'*'},        /* 0.25 ms */
        {500,0,'#'},        /* 0.5 ms */
        {1000,0,'1'},       /* 1 ms */
        {2000,0,'2'},       /* 2 ms */
        {3000,0,'3'},       /* 3 ms */
        {4000,0,'4'},       /* 4 ms */
        {5000,0,'5'},       /* 5 ms */
        {6000,0,'6'},       /* 6 ms */
        {7000,0,'7'},       /* 7 ms */
        {8000,0,'8'},       /* 8 ms */
     ...",1,26,redis-cli.c,latencyDistMode,,false,8297,8373,latencyDistMode,,,296,void latencyDistMode (void)
308863,METHOD,redis-cli.c:<global>,TYPE_DECL,"int sendReplconf(const char* arg1, const char* arg2) {
    int res = 1;
    fprintf(stderr, ""sending REPLCONF %s %s\n"", arg1, arg2);
    redisReply *reply = redisCommand(context, ""REPLCONF %s %s"", arg1, arg2);

    /* Handle any error conditions */
    if(reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if(reply->type == REDIS_REPLY_ERROR) {
        /* non fatal, old versions may not support it */
        fprintf(stderr, ""REPLCONF %s error: %s\n"", arg1, reply->str);
        res = 0;
    }
    freeReplyObject(reply);
    return res;
}",1,1,redis-cli.c,sendReplconf,,false,8381,8397,sendReplconf,,,297,"int sendReplconf (char*,char*)"
308919,METHOD,redis-cli.c:<global>,TYPE_DECL,"void sendCapa(void) {
    sendReplconf(""capa"", ""eof"");
}",1,1,redis-cli.c,sendCapa,,false,8399,8401,sendCapa,,,298,void sendCapa (void)
308927,METHOD,redis-cli.c:<global>,TYPE_DECL,"void sendRdbOnly(void) {
    sendReplconf(""rdb-only"", ""1"");
}",1,1,redis-cli.c,sendRdbOnly,,false,8403,8405,sendRdbOnly,,,299,void sendRdbOnly (void)
308935,METHOD,redis-cli.c:<global>,TYPE_DECL,"static ssize_t readConn(redisContext *c, char *buf, size_t len)
{
    return c->funcs->read(c, buf, len);
}",1,1,redis-cli.c,readConn,,false,8410,8413,readConn,,,300,"ssize_t readConn (redisContext*,char*,size_t)"
308952,METHOD,redis-cli.c:<global>,TYPE_DECL,"unsigned long long sendSync(redisContext *c, int send_sync, char *out_eof, int *out_full_mode) {
    /* To start we need to send the SYNC command and return the payload.
     * The hiredis client lib does not understand this part of the protocol
     * and we don't want to mess with its buffers, so everything is performed
     * using direct low-level I/O. */
    char buf[4096], *p;
    ssize_t nread;

    if (out_full_mode) *out_full_mode = 1;

    if (send_sync) {
        /* Send the SYNC command. */
        if (cliWriteConn(c, ""SYNC\r\n"", 6) != 6) {
            fprintf(stderr,""Error writing to master\n"");
            exit(1);
        }
    } else {
        /* We have written the command into c->obuf before. */
        if (cliWriteConn(c, """", 0) != 0) {
            fprintf(stderr,""Error writing to master\n"");
            exit(1);
        }
    }

    /* Read $<payload>\r\n, making sure to read just up to ""\n"" */
    p = buf;
    while(1) {
        nread = readConn(c,p,1);
        ...",1,57,redis-cli.c,sendSync,,false,8425,8499,sendSync,,,301,"unsigned long long sendSync (redisContext*,int,char*,int*)"
309199,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void slaveMode(int send_sync) {
    static char eofmark[RDB_EOF_MARK_SIZE];
    static char lastbytes[RDB_EOF_MARK_SIZE];
    static int usemark = 0;
    static int out_full_mode;
    unsigned long long payload = sendSync(context, send_sync, eofmark, &out_full_mode);
    char buf[1024];
    int original_output = config.output;
    char *info = out_full_mode ? ""Full resync"" : ""Partial resync"";

    if (out_full_mode == 1 && payload == 0) {
        /* SYNC with EOF marker or PSYNC +FULLRESYNC with EOF marker. */
        payload = ULLONG_MAX;
        memset(lastbytes,0,RDB_EOF_MARK_SIZE);
        usemark = 1;
        fprintf(stderr, ""%s with master, discarding ""
                        ""bytes of bulk transfer until EOF marker...\n"", info);
    } else if (out_full_mode == 1 && payload != 0) {
        /* SYNC without EOF marker or PSYNC +FULLRESYNC. */
        fprintf(stderr, ""%s with master, discarding %llu ""
                        ""bytes of bulk transfer...\n"", info, payload);
...",1,24,redis-cli.c,slaveMode,,false,8501,8565,slaveMode,,,302,void slaveMode (int)
309418,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void getRDB(clusterManagerNode *node) {
    int fd;
    redisContext *s;
    char *filename;
    if (node != NULL) {
        assert(node->context);
        s = node->context;
        filename = clusterManagerGetNodeRDBFilename(node);
    } else {
        s = context;
        filename = config.rdb_filename;
    }
    static char eofmark[RDB_EOF_MARK_SIZE];
    static char lastbytes[RDB_EOF_MARK_SIZE];
    static int usemark = 0;
    unsigned long long payload = sendSync(s, 1, eofmark, NULL);
    char buf[4096];

    if (payload == 0) {
        payload = ULLONG_MAX;
        memset(lastbytes,0,RDB_EOF_MARK_SIZE);
        usemark = 1;
        fprintf(stderr,""SYNC sent to master, writing bytes of bulk transfer ""
                ""until EOF marker to '%s'\n"", filename);
    } else {
        fprintf(stderr,""SYNC sent to master, writing %llu bytes to '%s'\n"",
            payload, filename);
    }

    int write_to_stdout = !strcmp(filename,""-"");
    /* Write to file. */
    if (write_...",1,24,redis-cli.c,getRDB,,false,8573,8665,getRDB,,,303,void getRDB (clusterManagerNode*)
309719,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void pipeMode(void) {
    long long errors = 0, replies = 0, obuf_len = 0, obuf_pos = 0;
    char obuf[1024*16]; /* Output buffer */
    char aneterr[ANET_ERR_LEN];
    redisReply *reply;
    int eof = 0; /* True once we consumed all the standard input. */
    int done = 0;
    char magic[20]; /* Special reply we recognize. */
    time_t last_read_time = time(NULL);

    srand(time(NULL));

    /* Use non blocking I/O. */
    if (anetNonBlock(aneterr,context->fd) == ANET_ERR) {
        fprintf(stderr, ""Can't set the socket in non blocking mode: %s\n"",
            aneterr);
        exit(1);
    }

    context->flags &= ~REDIS_BLOCK;

    /* Transfer raw protocol and read replies from the server at the same
     * time. */
    while(!done) {
        int mask = AE_READABLE;

        if (!eof || obuf_len != 0) mask |= AE_WRITABLE;
        mask = aeWait(context->fd,mask,1000);

        /* Handle the readable state: we can read replies from the server. */
        if (mask & AE_READ...",1,17,redis-cli.c,pipeMode,,false,8672,8824,pipeMode,,,304,void pipeMode (void)
310156,METHOD,redis-cli.c:<global>,TYPE_DECL,"static redisReply *sendScan(unsigned long long *it) {
    redisReply *reply;

    if (config.pattern)
        reply = redisCommand(context, ""SCAN %llu MATCH %b COUNT %d"",
            *it, config.pattern, sdslen(config.pattern), config.count);
    else
        reply = redisCommand(context,""SCAN %llu"",*it);

    /* Handle any error conditions */
    if(reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if(reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr, ""SCAN error: %s\n"", reply->str);
        exit(1);
    } else if(reply->type != REDIS_REPLY_ARRAY) {
        fprintf(stderr, ""Non ARRAY response from SCAN!\n"");
        exit(1);
    } else if(reply->elements != 2) {
        fprintf(stderr, ""Invalid element count from SCAN!\n"");
        exit(1);
    }

    /* Validate our types are correct */
    assert(reply->element[0]->type == REDIS_REPLY_STRING);
    assert(reply->element[1]->type == REDIS_REPLY_ARRAY);

    /* Update iterator */
    *it...",1,1,redis-cli.c,sendScan,,false,8830,8862,sendScan,,,305,redisReply sendScan (long long unsigned*)
310283,METHOD,redis-cli.c:<global>,TYPE_DECL,"static int getDbSize(void) {
    redisReply *reply;
    int size;

    reply = redisCommand(context, ""DBSIZE"");

    if (reply == NULL) {
        fprintf(stderr, ""\nI/O error\n"");
        exit(1);
    } else if (reply->type == REDIS_REPLY_ERROR) {
        fprintf(stderr, ""Couldn't determine DBSIZE: %s\n"", reply->str);
        exit(1);
    } else if (reply->type != REDIS_REPLY_INTEGER) {
        fprintf(stderr, ""Non INTEGER response from DBSIZE!\n"");
        exit(1);
    }

    /* Grab the number of keys and free our reply */
    size = reply->integer;
    freeReplyObject(reply);

    return size;
}",1,1,redis-cli.c,getDbSize,,false,8864,8886,getDbSize,,,306,int getDbSize (void)
310403,METHOD,redis-cli.c:<global>,TYPE_DECL,"static typeinfo* typeinfo_add(dict *types, char* name, typeinfo* type_template) {
    typeinfo *info = zmalloc(sizeof(typeinfo));
    *info = *type_template;
    info->name = sdsnew(name);
    dictAdd(types, info->name, info);
    return info;
}",1,1,redis-cli.c,typeinfo_add,,false,8906,8912,typeinfo_add,,,323,"typeinfo typeinfo_add (dict*,char*,typeinfo*)"
310435,METHOD,redis-cli.c:<global>,TYPE_DECL,"void type_free(dict *d, void* val) {
    typeinfo *info = val;
    UNUSED(d);
    if (info->biggest_key)
        sdsfree(info->biggest_key);
    sdsfree(info->name);
    zfree(info);
}",1,4,redis-cli.c,type_free,,false,8914,8921,type_free,,,324,"void type_free (dict*,void*)"
310477,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void getKeyTypes(dict *types_dict, redisReply *keys, typeinfo **types) {
    redisReply *reply;
    unsigned int i;

    /* Pipeline TYPE commands */
    for(i=0;i<keys->elements;i++) {
        const char* argv[] = {""TYPE"", keys->element[i]->str};
        size_t lens[] = {4, keys->element[i]->len};
        redisAppendCommandArgv(context, 2, argv, lens);
    }

    /* Retrieve types */
    for(i=0;i<keys->elements;i++) {
        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
            fprintf(stderr, ""Error getting type for key '%s' (%d: %s)\n"",
                keys->element[i]->str, context->err, context->errstr);
            exit(1);
        } else if(reply->type != REDIS_REPLY_STATUS) {
            if(reply->type == REDIS_REPLY_ERROR) {
                fprintf(stderr, ""TYPE returned an error: %s\n"", reply->str);
            } else {
                fprintf(stderr,
                    ""Invalid reply type (%d) for TYPE on key '%s'!\n"",
                    reply->typ...",1,1,redis-cli.c,getKeyTypes,,false,8933,8972,getKeyTypes,,,327,"void getKeyTypes (dict*,redisReply*,typeinfo**)"
310659,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void getKeySizes(redisReply *keys, typeinfo **types,
                        unsigned long long *sizes, int memkeys,
                        unsigned memkeys_samples)
{
    redisReply *reply;
    unsigned int i;

    /* Pipeline size commands */
    for(i=0;i<keys->elements;i++) {
        /* Skip keys that disappeared between SCAN and TYPE (or unknown types when not in memkeys mode) */
        if(!types[i] || (!types[i]->sizecmd && !memkeys))
            continue;

        if (!memkeys) {
            const char* argv[] = {types[i]->sizecmd, keys->element[i]->str};
            size_t lens[] = {strlen(types[i]->sizecmd), keys->element[i]->len};
            redisAppendCommandArgv(context, 2, argv, lens);
        } else if (memkeys_samples==0) {
            const char* argv[] = {""MEMORY"", ""USAGE"", keys->element[i]->str};
            size_t lens[] = {6, 5, keys->element[i]->len};
            redisAppendCommandArgv(context, 3, argv, lens);
        } else {
            sds samplesst...",1,1,redis-cli.c,getKeySizes,,false,8974,9031,getKeySizes,,,328,"void getKeySizes (redisReply*,typeinfo**,long long unsigned*,int,unsigned)"
310932,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void longStatLoopModeStop(int s) {
    UNUSED(s);
    force_cancel_loop = 1;
}",1,4,redis-cli.c,longStatLoopModeStop,,false,9033,9036,longStatLoopModeStop,,,329,void longStatLoopModeStop (int)
310946,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void findBigKeys(int memkeys, unsigned memkeys_samples) {
    unsigned long long sampled = 0, total_keys, totlen=0, *sizes=NULL, it=0, scan_loops = 0;
    redisReply *reply, *keys;
    unsigned int arrsize=0, i;
    dictIterator *di;
    dictEntry *de;
    typeinfo **types = NULL;
    double pct;

    dict *types_dict = dictCreate(&typeinfoDictType);
    typeinfo_add(types_dict, ""string"", &type_string);
    typeinfo_add(types_dict, ""list"", &type_list);
    typeinfo_add(types_dict, ""set"", &type_set);
    typeinfo_add(types_dict, ""hash"", &type_hash);
    typeinfo_add(types_dict, ""zset"", &type_zset);
    typeinfo_add(types_dict, ""stream"", &type_stream);

    signal(SIGINT, longStatLoopModeStop);
    /* Total keys pre scanning */
    total_keys = getDbSize();

    /* Status message */
    printf(""\n# Scanning the entire keyspace to find biggest keys as well as\n"");
    printf(""# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"");
    printf(""# per 100 SCAN comma...",1,1,redis-cli.c,findBigKeys,,false,9038,9173,findBigKeys,,,330,"void findBigKeys (int,unsigned)"
311409,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void getKeyFreqs(redisReply *keys, unsigned long long *freqs) {
    redisReply *reply;
    unsigned int i;

    /* Pipeline OBJECT freq commands */
    for(i=0;i<keys->elements;i++) {
        const char* argv[] = {""OBJECT"", ""FREQ"", keys->element[i]->str};
        size_t lens[] = {6, 4, keys->element[i]->len};
        redisAppendCommandArgv(context, 3, argv, lens);
    }

    /* Retrieve freqs */
    for(i=0;i<keys->elements;i++) {
        if(redisGetReply(context, (void**)&reply)!=REDIS_OK) {
            sds keyname = sdscatrepr(sdsempty(), keys->element[i]->str, keys->element[i]->len);
            fprintf(stderr, ""Error getting freq for key '%s' (%d: %s)\n"",
                keyname, context->err, context->errstr);
            sdsfree(keyname);
            exit(1);
        } else if(reply->type != REDIS_REPLY_INTEGER) {
            if(reply->type == REDIS_REPLY_ERROR) {
                fprintf(stderr, ""Error: %s\n"", reply->str);
                exit(1);
            } else {
 ...",1,1,redis-cli.c,getKeyFreqs,,false,9175,9209,getKeyFreqs,,,331,"void getKeyFreqs (redisReply*,long long unsigned*)"
311584,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void findHotKeys(void) {
    redisReply *keys, *reply;
    unsigned long long counters[HOTKEYS_SAMPLE] = {0};
    sds hotkeys[HOTKEYS_SAMPLE] = {NULL};
    unsigned long long sampled = 0, total_keys, *freqs = NULL, it = 0, scan_loops = 0;
    unsigned int arrsize = 0, i, k;
    double pct;

    signal(SIGINT, longStatLoopModeStop);
    /* Total keys pre scanning */
    total_keys = getDbSize();

    /* Status message */
    printf(""\n# Scanning the entire keyspace to find hot keys as well as\n"");
    printf(""# average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec\n"");
    printf(""# per 100 SCAN commands (not usually needed).\n\n"");

    /* SCAN loop */
    do {
        /* Calculate approximate percentage completion */
        pct = 100 * (double)sampled/total_keys;

        /* Grab some keys and point to the keys array */
        reply = sendScan(&it);
        scan_loops++;
        keys  = reply->element[1];

        /* Reallocate our freqs array if we need to */
 ...",1,32,redis-cli.c,findHotKeys,,false,9212,9304,findHotKeys,,,332,void findHotKeys (void)
311909,METHOD,redis-cli.c:<global>,TYPE_DECL,"static char *getInfoField(char *info, char *field) {
    char *p = strstr(info,field);
    char *n1, *n2;
    char *result;

    if (!p) return NULL;
    p += strlen(field)+1;
    n1 = strchr(p,'\r');
    n2 = strchr(p,',');
    if (n2 && n2 < n1) n1 = n2;
    result = zmalloc(sizeof(char)*(n1-p)+1);
    memcpy(result,p,(n1-p));
    result[n1-p] = '\0';
    return result;
}",1,1,redis-cli.c,getInfoField,,false,9313,9327,getInfoField,,,333,"char* getInfoField (char*,char*)"
311982,METHOD,redis-cli.c:<global>,TYPE_DECL,"static long getLongInfoField(char *info, char *field) {
    char *value = getInfoField(info,field);
    long l;

    if (!value) return LONG_MIN;
    l = strtol(value,NULL,10);
    zfree(value);
    return l;
}",1,1,redis-cli.c,getLongInfoField,,false,9331,9339,getLongInfoField,,,334,"long getLongInfoField (char*,char*)"
312011,METHOD,redis-cli.c:<global>,TYPE_DECL,"void bytesToHuman(char *s, size_t size, long long n) {
    double d;

    if (n < 0) {
        *s = '-';
        s++;
        n = -n;
    }
    if (n < 1024) {
        /* Bytes */
        snprintf(s,size,""%lldB"",n);
        return;
    } else if (n < (1024*1024)) {
        d = (double)n/(1024);
        snprintf(s,size,""%.2fK"",d);
    } else if (n < (1024LL*1024*1024)) {
        d = (double)n/(1024*1024);
        snprintf(s,size,""%.2fM"",d);
    } else if (n < (1024LL*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024);
        snprintf(s,size,""%.2fG"",d);
    }
}",1,1,redis-cli.c,bytesToHuman,,false,9343,9365,bytesToHuman,,,335,"void bytesToHuman (char*,size_t,long long)"
312120,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void statMode(void) {
    redisReply *reply;
    long aux, requests = 0;
    int i = 0;

    while(1) {
        char buf[64];
        int j;

        reply = reconnectingRedisCommand(context,""INFO"");
        if (reply == NULL) {
            fprintf(stderr, ""\nI/O error\n"");
            exit(1);
        } else if (reply->type == REDIS_REPLY_ERROR) {
            fprintf(stderr, ""ERROR: %s\n"", reply->str);
            exit(1);
        }

        if ((i++ % 20) == 0) {
            printf(
""------- data ------ --------------------- load -------------------- - child -\n""
""keys       mem      clients blocked requests            connections          \n"");
        }

        /* Keys */
        aux = 0;
        for (j = 0; j < 20; j++) {
            long k;

            snprintf(buf,sizeof(buf),""db%d:keys"",j);
            k = getLongInfoField(reply->str,buf);
            if (k == LONG_MIN) continue;
            aux += k;
        }
        snprintf(buf,sizeof(buf),""%ld"",aux);
        pr...",1,1,redis-cli.c,statMode,,false,9367,9454,statMode,,,336,void statMode (void)
312377,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void scanMode(void) {
    redisReply *reply;
    unsigned long long cur = 0;
    signal(SIGINT, longStatLoopModeStop);
    do {
        reply = sendScan(&cur);
        for (unsigned int j = 0; j < reply->element[1]->elements; j++) {
            if (config.output == OUTPUT_STANDARD) {
                sds out = sdscatrepr(sdsempty(), reply->element[1]->element[j]->str,
                                     reply->element[1]->element[j]->len);
                printf(""%s\n"", out);
                sdsfree(out);
            } else {
                printf(""%s\n"", reply->element[1]->element[j]->str);
            }
        }
        freeReplyObject(reply);
        if (config.interval) usleep(config.interval);
    } while(force_cancel_loop == 0 && cur != 0);

    exit(0);
}",1,33,redis-cli.c,scanMode,,false,9460,9481,scanMode,,,337,void scanMode (void)
312491,METHOD,redis-cli.c:<global>,TYPE_DECL,"long long powerLawRand(long long min, long long max, double alpha) {
    double pl, r;

    max += 1;
    r = ((double)rand()) / RAND_MAX;
    pl = pow(
        ((pow(max,alpha+1) - pow(min,alpha+1))*r + pow(min,alpha+1)),
        (1.0/(alpha+1)));
    return (max-1-(long long)pl)+min;
}",1,1,redis-cli.c,powerLawRand,,false,9493,9502,powerLawRand,,,338,"long long powerLawRand (long long,long long,double)"
312547,METHOD,redis-cli.c:<global>,TYPE_DECL,"void LRUTestGenKey(char *buf, size_t buflen) {
    snprintf(buf, buflen, ""lru:%lld"",
        powerLawRand(1, config.lru_test_sample_size, 6.2));
}",1,1,redis-cli.c,LRUTestGenKey,,false,9506,9509,LRUTestGenKey,,,339,"void LRUTestGenKey (char*,size_t)"
312563,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void LRUTestMode(void) {
    redisReply *reply;
    char key[128];
    long long start_cycle;
    int j;

    srand(time(NULL)^getpid());
    while(1) {
        /* Perform cycles of 1 second with 50% writes and 50% reads.
         * We use pipelining batching writes / reads N times per cycle in order
         * to fill the target instance easily. */
        start_cycle = mstime();
        long long hits = 0, misses = 0;
        while(mstime() - start_cycle < LRU_CYCLE_PERIOD) {
            /* Write cycle. */
            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++) {
                char val[6];
                val[5] = '\0';
                for (int i = 0; i < 5; i++) val[i] = 'A'+rand()%('z'-'A');
                LRUTestGenKey(key,sizeof(key));
                redisAppendCommand(context, ""SET %s %s"",key,val);
            }
            for (j = 0; j < LRU_CYCLE_PIPELINE_SIZE; j++)
                redisGetReply(context, (void**)&reply);

            /* Read cycle. */
        ...",1,39,redis-cli.c,LRUTestMode,,false,9513,9572,LRUTestMode,,,340,void LRUTestMode (void)
312772,METHOD,redis-cli.c:<global>,TYPE_DECL,"unsigned long compute_something_fast(void) {
    unsigned char s[256], i, j, t;
    int count = 1000, k;
    unsigned long output = 0;

    for (k = 0; k < 256; k++) s[k] = k;

    i = 0;
    j = 0;
    while(count--) {
        i++;
        j = j + s[i];
        t = s[i];
        s[i] = s[j];
        s[j] = t;
        output += s[(s[i]+s[j])&255];
    }
    return output;
}",1,1,redis-cli.c,compute_something_fast,,false,9585,9603,compute_something_fast,,,341,unsigned long compute_something_fast (void)
312856,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void sigIntHandler(int s) {
    UNUSED(s);

    if (config.monitor_mode || config.pubsub_mode) {
        close(context->fd);
        context->fd = REDIS_INVALID_FD;
        config.blocking_state_aborted = 1;
    } else {
        exit(1);
    }
}",1,4,redis-cli.c,sigIntHandler,,false,9605,9615,sigIntHandler,,,342,void sigIntHandler (int)
312894,METHOD,redis-cli.c:<global>,TYPE_DECL,"static void intrinsicLatencyMode(void) {
    long long test_end, run_time, max_latency = 0, runs = 0;

    run_time = (long long)config.intrinsic_latency_duration * 1000000;
    test_end = ustime() + run_time;
    signal(SIGINT, longStatLoopModeStop);

    while(1) {
        long long start, end, latency;

        start = ustime();
        compute_something_fast();
        end = ustime();
        latency = end-start;
        runs++;
        if (latency <= 0) continue;

        /* Reporting */
        if (latency > max_latency) {
            max_latency = latency;
            printf(""Max latency so far: %lld microseconds.\n"", max_latency);
        }

        double avg_us = (double)run_time/runs;
        double avg_ns = avg_us * 1e3;
        if (force_cancel_loop || end > test_end) {
            printf(""\n%lld total runs ""
                ""(avg latency: ""
                ""%.4f microseconds / %.2f nanoseconds per run).\n"",
                runs, avg_us, avg_ns);
            printf(""Wor...",1,1,redis-cli.c,intrinsicLatencyMode,,false,9617,9652,intrinsicLatencyMode,,,343,void intrinsicLatencyMode (void)
312996,METHOD,redis-cli.c:<global>,TYPE_DECL,"static sds askPassword(const char *msg) {
    linenoiseMaskModeEnable();
    sds auth = linenoise(msg);
    linenoiseMaskModeDisable();
    return auth;
}",1,1,redis-cli.c,askPassword,,false,9654,9659,askPassword,,,344,sds askPassword (char*)
313010,METHOD,redis-cli.c:<global>,TYPE_DECL,"void testHint(const char *input) {
    cliInitHelp();

    sds hint = getHintForInput(input);
    printf(""%s\n"", hint);
    exit(0);
}",1,1,redis-cli.c,testHint,,false,9662,9668,testHint,,,345,void testHint (char*)
313026,METHOD,redis-cli.c:<global>,TYPE_DECL,"sds readHintSuiteLine(char buf[], size_t size, FILE *fp) {
    while (fgets(buf, size, fp) != NULL) {
        if (buf[0] != '#') {
            sds input = sdsnew(buf);

            /* Strip newline. */
            input = sdstrim(input, ""\n"");
            return input;
        }
    }
    return NULL;
}",1,1,redis-cli.c,readHintSuiteLine,,false,9670,9681,readHintSuiteLine,,,346,"sds readHintSuiteLine (char[],size_t,FILE*)"
313062,METHOD,redis-cli.c:<global>,TYPE_DECL,"void testHintSuite(char *filename) {
    FILE *fp;
    char buf[256];
    sds line, input, expected, hint;
    int pass=0, fail=0;
    int argc;
    char **argv;

    fp = fopen(filename, ""r"");
    if (!fp) {
        fprintf(stderr,
            ""Can't open file '%s': %s\n"", filename, strerror(errno));
        exit(-1);
    }

    cliInitHelp();

    while (1) {
        line = readHintSuiteLine(buf, sizeof(buf), fp);
        if (line == NULL) break;
        argv = sdssplitargs(line, &argc);
        sdsfree(line);
        if (argc == 0) {
            sdsfreesplitres(argv, argc);
            continue;
        }

        if (argc == 1) {
            fprintf(stderr,
                ""Missing expected hint for input '%s'\n"", argv[0]);
            exit(-1);
        }
        input = argv[0];
        expected = argv[1];
        hint = getHintForInput(input);
        if (config.verbose) {
            printf(""Input: '%s', Expected: '%s', Hint: '%s'\n"", input, expected, hint);
        }

      ...",1,1,redis-cli.c,testHintSuite,,false,9684,9743,testHintSuite,,,347,void testHintSuite (char*)
313248,METHOD,redis-cli.c:<global>,TYPE_DECL,"int main(int argc, char **argv) {
    int firstarg;
    struct timeval tv;

    memset(&config.sslconfig, 0, sizeof(config.sslconfig));
    config.conn_info.hostip = sdsnew(""127.0.0.1"");
    config.conn_info.hostport = 6379;
    config.hostsocket = NULL;
    config.repeat = 1;
    config.interval = 0;
    config.dbnum = 0;
    config.conn_info.input_dbnum = 0;
    config.interactive = 0;
    config.shutdown = 0;
    config.monitor_mode = 0;
    config.pubsub_mode = 0;
    config.blocking_state_aborted = 0;
    config.latency_mode = 0;
    config.latency_dist_mode = 0;
    config.latency_history = 0;
    config.lru_test_mode = 0;
    config.lru_test_sample_size = 0;
    config.cluster_mode = 0;
    config.cluster_send_asking = 0;
    config.slave_mode = 0;
    config.getrdb_mode = 0;
    config.get_functions_rdb_mode = 0;
    config.stat_mode = 0;
    config.scan_mode = 0;
    config.count = 10;
    config.intrinsic_latency_mode = 0;
    config.pattern = NULL;
    config.rdb_filename...",1,26,redis-cli.c,main,,false,9749,9978,main,,,348,"int main (int,char**)"
314083,METHOD,redisassert.c:<global>,TYPE_DECL,<global>,1,1,redisassert.c,redisassert.c:<global>,,false,1,53,<global>,,,1,
314085,METHOD,redisassert.c:<global>,TYPE_DECL,"void _serverAssert(const char *estr, const char *file, int line) {
    fprintf(stderr, ""=== ASSERTION FAILED ==="");
    fprintf(stderr, ""==> %s:%d '%s' is not true"",file,line,estr);
    raise(SIGSEGV);
}",1,1,redisassert.c,_serverAssert,,false,42,46,_serverAssert,,,1,"void _serverAssert (char*,char*,int)"
314103,METHOD,redisassert.c:<global>,TYPE_DECL,"void _serverPanic(const char *file, int line, const char *msg, ...) {
    fprintf(stderr, ""------------------------------------------------"");
    fprintf(stderr, ""!!! Software Failure. Press left mouse button to continue"");
    fprintf(stderr, ""Guru Meditation: %s #%s:%d"",msg,file,line);
    abort();
}",1,1,redisassert.c,_serverPanic,,false,48,53,_serverPanic,,,2,"void _serverPanic (char*,int,char*...)"
314128,METHOD,redisassert.h:<global>,TYPE_DECL,<global>,1,1,redisassert.h,redisassert.h:<global>,,false,1,49,<global>,,,1,
314130,METHOD,redisassert.h:<global>,TYPE_DECL,"void _serverAssert(const char *estr, const char *file, int line);",6,64,redisassert.h,_serverAssert,,false,46,46,_serverAssert,,,1,"void _serverAssert (char*,char*,int)"
314137,METHOD,redisassert.h:<global>,TYPE_DECL,"void _serverPanic(const char *file, int line, const char *msg, ...);",6,67,redisassert.h,_serverPanic,,false,47,47,_serverPanic,,,2,"void _serverPanic (char*,int,char*...)"
314155,METHOD,redismodule.h:<global>,TYPE_DECL,<global>,1,8,redismodule.h,redismodule.h:<global>,,false,1,1685,<global>,,,1,
314184,METHOD,<empty>,<empty>,<empty>,1,,redismodule.h,RedisModuleKeySpecBeginSearchType:<clinit>,,false,332,,<clinit>,,,5,
314197,METHOD,<empty>,<empty>,<empty>,1,,redismodule.h,RedisModuleKeySpecFindKeysType:<clinit>,,false,341,,<clinit>,,,5,
314289,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleEventLoopFunc)(int fd, void *user_data, int mask);",14,75,redismodule.h,RedisModuleEventLoopFunc,,false,476,476,RedisModuleEventLoopFunc,,,28,"void RedisModuleEventLoopFunc (int,void*,int)"
314296,METHOD,redismodule.h:<global>,TYPE_DECL,typedef void (*RedisModuleEventLoopOneShotFunc)(void *user_data);,14,64,redismodule.h,RedisModuleEventLoopOneShotFunc,,false,477,477,RedisModuleEventLoopOneShotFunc,,,29,void RedisModuleEventLoopOneShotFunc (void*)
314307,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleEventCallback)(struct RedisModuleCtx *ctx, RedisModuleEvent eid, uint64_t subevent, void *data);",14,121,redismodule.h,RedisModuleEventCallback,,false,510,510,RedisModuleEventCallback,,,34,"void RedisModuleEventCallback (RedisModuleCtx*,RedisModuleEvent,uint64_t,void*)"
314466,METHOD,<empty>,<empty>,<empty>,1,,redismodule.h,RedisModuleClientInfo:<clinit>,,false,714,,<clinit>,,,7,
314521,METHOD,<empty>,<empty>,<empty>,1,,redismodule.h,RedisModuleACLLogEntryReason:<clinit>,,false,819,,<clinit>,,,5,
314537,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleInfoFunc)(RedisModuleInfoCtx *ctx, int for_crash_report);",14,82,redismodule.h,RedisModuleInfoFunc,,false,834,834,RedisModuleInfoFunc,,,99,"void RedisModuleInfoFunc (RedisModuleInfoCtx*,int)"
314543,METHOD,redismodule.h:<global>,TYPE_DECL,typedef void (*RedisModuleDefragFunc)(RedisModuleDefragCtx *ctx);,14,64,redismodule.h,RedisModuleDefragFunc,,false,835,835,RedisModuleDefragFunc,,,100,void RedisModuleDefragFunc (RedisModuleDefragCtx*)
314548,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleUserChangedFunc) (uint64_t client_id, void *privdata);",14,79,redismodule.h,RedisModuleUserChangedFunc,,false,836,836,RedisModuleUserChangedFunc,,,101,"void RedisModuleUserChangedFunc (uint64_t,void*)"
314584,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleCmdFunc)(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);",13,90,redismodule.h,RedisModuleCmdFunc,,false,886,886,RedisModuleCmdFunc,,,132,"int RedisModuleCmdFunc (RedisModuleCtx*,RedisModuleString**,int)"
314591,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleDisconnectFunc)(RedisModuleCtx *ctx, RedisModuleBlockedClient *bc);",14,92,redismodule.h,RedisModuleDisconnectFunc,,false,887,887,RedisModuleDisconnectFunc,,,133,"void RedisModuleDisconnectFunc (RedisModuleCtx*,RedisModuleBlockedClient*)"
314597,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleNotificationFunc)(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);",13,116,redismodule.h,RedisModuleNotificationFunc,,false,888,888,RedisModuleNotificationFunc,,,134,"int RedisModuleNotificationFunc (RedisModuleCtx*,int,char*,RedisModuleString*)"
314605,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModulePostNotificationJobFunc) (RedisModuleCtx *ctx, void *pd);",14,82,redismodule.h,RedisModulePostNotificationJobFunc,,false,889,889,RedisModulePostNotificationJobFunc,,,135,"void RedisModulePostNotificationJobFunc (RedisModuleCtx*,void*)"
314611,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void *(*RedisModuleTypeLoadFunc)(RedisModuleIO *rdb, int encver);",14,72,redismodule.h,RedisModuleTypeLoadFunc,,false,890,890,RedisModuleTypeLoadFunc,,,136,"void* RedisModuleTypeLoadFunc (RedisModuleIO*,int)"
314617,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTypeSaveFunc)(RedisModuleIO *rdb, void *value);",14,72,redismodule.h,RedisModuleTypeSaveFunc,,false,891,891,RedisModuleTypeSaveFunc,,,137,"void RedisModuleTypeSaveFunc (RedisModuleIO*,void*)"
314623,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleTypeAuxLoadFunc)(RedisModuleIO *rdb, int encver, int when);",13,83,redismodule.h,RedisModuleTypeAuxLoadFunc,,false,892,892,RedisModuleTypeAuxLoadFunc,,,138,"int RedisModuleTypeAuxLoadFunc (RedisModuleIO*,int,int)"
314630,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTypeAuxSaveFunc)(RedisModuleIO *rdb, int when);",14,72,redismodule.h,RedisModuleTypeAuxSaveFunc,,false,893,893,RedisModuleTypeAuxSaveFunc,,,139,"void RedisModuleTypeAuxSaveFunc (RedisModuleIO*,int)"
314636,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTypeRewriteFunc)(RedisModuleIO *aof, RedisModuleString *key, void *value);",14,99,redismodule.h,RedisModuleTypeRewriteFunc,,false,894,894,RedisModuleTypeRewriteFunc,,,140,"void RedisModuleTypeRewriteFunc (RedisModuleIO*,RedisModuleString*,void*)"
314643,METHOD,redismodule.h:<global>,TYPE_DECL,typedef size_t (*RedisModuleTypeMemUsageFunc)(const void *value);,16,64,redismodule.h,RedisModuleTypeMemUsageFunc,,false,895,895,RedisModuleTypeMemUsageFunc,,,141,size_t RedisModuleTypeMemUsageFunc (void*)
314648,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef size_t (*RedisModuleTypeMemUsageFunc2)(RedisModuleKeyOptCtx *ctx, const void *value, size_t sample_size);",16,112,redismodule.h,RedisModuleTypeMemUsageFunc2,,false,896,896,RedisModuleTypeMemUsageFunc2,,,142,"size_t RedisModuleTypeMemUsageFunc2 (RedisModuleKeyOptCtx*,void*,size_t)"
314655,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTypeDigestFunc)(RedisModuleDigest *digest, void *value);",14,81,redismodule.h,RedisModuleTypeDigestFunc,,false,897,897,RedisModuleTypeDigestFunc,,,143,"void RedisModuleTypeDigestFunc (RedisModuleDigest*,void*)"
314661,METHOD,redismodule.h:<global>,TYPE_DECL,typedef void (*RedisModuleTypeFreeFunc)(void *value);,14,52,redismodule.h,RedisModuleTypeFreeFunc,,false,898,898,RedisModuleTypeFreeFunc,,,144,void RedisModuleTypeFreeFunc (void*)
314666,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef size_t (*RedisModuleTypeFreeEffortFunc)(RedisModuleString *key, const void *value);",16,90,redismodule.h,RedisModuleTypeFreeEffortFunc,,false,899,899,RedisModuleTypeFreeEffortFunc,,,145,"size_t RedisModuleTypeFreeEffortFunc (RedisModuleString*,void*)"
314672,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef size_t (*RedisModuleTypeFreeEffortFunc2)(RedisModuleKeyOptCtx *ctx, const void *value);",16,94,redismodule.h,RedisModuleTypeFreeEffortFunc2,,false,900,900,RedisModuleTypeFreeEffortFunc2,,,146,"size_t RedisModuleTypeFreeEffortFunc2 (RedisModuleKeyOptCtx*,void*)"
314678,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTypeUnlinkFunc)(RedisModuleString *key, const void *value);",14,84,redismodule.h,RedisModuleTypeUnlinkFunc,,false,901,901,RedisModuleTypeUnlinkFunc,,,147,"void RedisModuleTypeUnlinkFunc (RedisModuleString*,void*)"
314684,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTypeUnlinkFunc2)(RedisModuleKeyOptCtx *ctx, const void *value);",14,88,redismodule.h,RedisModuleTypeUnlinkFunc2,,false,902,902,RedisModuleTypeUnlinkFunc2,,,148,"void RedisModuleTypeUnlinkFunc2 (RedisModuleKeyOptCtx*,void*)"
314690,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void *(*RedisModuleTypeCopyFunc)(RedisModuleString *fromkey, RedisModuleString *tokey, const void *value);",14,113,redismodule.h,RedisModuleTypeCopyFunc,,false,903,903,RedisModuleTypeCopyFunc,,,149,"void* RedisModuleTypeCopyFunc (RedisModuleString*,RedisModuleString*,void*)"
314697,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void *(*RedisModuleTypeCopyFunc2)(RedisModuleKeyOptCtx *ctx, const void *value);",14,87,redismodule.h,RedisModuleTypeCopyFunc2,,false,904,904,RedisModuleTypeCopyFunc2,,,150,"void* RedisModuleTypeCopyFunc2 (RedisModuleKeyOptCtx*,void*)"
314703,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleTypeDefragFunc)(RedisModuleDefragCtx *ctx, RedisModuleString *key, void **value);",13,105,redismodule.h,RedisModuleTypeDefragFunc,,false,905,905,RedisModuleTypeDefragFunc,,,151,"int RedisModuleTypeDefragFunc (RedisModuleDefragCtx*,RedisModuleString*,void**)"
314710,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);",14,151,redismodule.h,RedisModuleClusterMessageReceiver,,false,906,906,RedisModuleClusterMessageReceiver,,,152,"void RedisModuleClusterMessageReceiver (RedisModuleCtx*,char*,uint8_t,unsigned char*,uint32_t)"
314719,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);",14,69,redismodule.h,RedisModuleTimerProc,,false,907,907,RedisModuleTimerProc,,,153,"void RedisModuleTimerProc (RedisModuleCtx*,void*)"
314725,METHOD,redismodule.h:<global>,TYPE_DECL,typedef void (*RedisModuleCommandFilterFunc) (RedisModuleCommandFilterCtx *filter);,14,82,redismodule.h,RedisModuleCommandFilterFunc,,false,908,908,RedisModuleCommandFilterFunc,,,154,void RedisModuleCommandFilterFunc (RedisModuleCommandFilterCtx*)
314730,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleForkDoneHandler) (int exitcode, int bysignal, void *user_data);",14,88,redismodule.h,RedisModuleForkDoneHandler,,false,909,909,RedisModuleForkDoneHandler,,,155,"void RedisModuleForkDoneHandler (int,int,void*)"
314737,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleScanCB)(RedisModuleCtx *ctx, RedisModuleString *keyname, RedisModuleKey *key, void *privdata);",14,119,redismodule.h,RedisModuleScanCB,,false,910,910,RedisModuleScanCB,,,156,"void RedisModuleScanCB (RedisModuleCtx*,RedisModuleString*,RedisModuleKey*,void*)"
314745,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleScanKeyCB)(RedisModuleKey *key, RedisModuleString *field, RedisModuleString *value, void *privdata);",14,125,redismodule.h,RedisModuleScanKeyCB,,false,911,911,RedisModuleScanKeyCB,,,157,"void RedisModuleScanKeyCB (RedisModuleKey*,RedisModuleString*,RedisModuleString*,void*)"
314753,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef RedisModuleString * (*RedisModuleConfigGetStringFunc)(const char *name, void *privdata);",27,95,redismodule.h,RedisModuleConfigGetStringFunc,,false,912,912,RedisModuleConfigGetStringFunc,,,158,"RedisModuleString* RedisModuleConfigGetStringFunc (char*,void*)"
314759,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef long long (*RedisModuleConfigGetNumericFunc)(const char *name, void *privdata);",19,86,redismodule.h,RedisModuleConfigGetNumericFunc,,false,913,913,RedisModuleConfigGetNumericFunc,,,159,"long long RedisModuleConfigGetNumericFunc (char*,void*)"
314765,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigGetBoolFunc)(const char *name, void *privdata);",13,77,redismodule.h,RedisModuleConfigGetBoolFunc,,false,914,914,RedisModuleConfigGetBoolFunc,,,160,"int RedisModuleConfigGetBoolFunc (char*,void*)"
314771,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigGetEnumFunc)(const char *name, void *privdata);",13,77,redismodule.h,RedisModuleConfigGetEnumFunc,,false,915,915,RedisModuleConfigGetEnumFunc,,,161,"int RedisModuleConfigGetEnumFunc (char*,void*)"
314777,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetStringFunc)(const char *name, RedisModuleString *val, void *privdata, RedisModuleString **err);",13,128,redismodule.h,RedisModuleConfigSetStringFunc,,false,916,916,RedisModuleConfigSetStringFunc,,,162,"int RedisModuleConfigSetStringFunc (char*,RedisModuleString*,void*,RedisModuleString**)"
314785,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetNumericFunc)(const char *name, long long val, void *privdata, RedisModuleString **err);",13,120,redismodule.h,RedisModuleConfigSetNumericFunc,,false,917,917,RedisModuleConfigSetNumericFunc,,,163,"int RedisModuleConfigSetNumericFunc (char*,long long,void*,RedisModuleString**)"
314793,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetBoolFunc)(const char *name, int val, void *privdata, RedisModuleString **err);",13,111,redismodule.h,RedisModuleConfigSetBoolFunc,,false,918,918,RedisModuleConfigSetBoolFunc,,,164,"int RedisModuleConfigSetBoolFunc (char*,int,void*,RedisModuleString**)"
314801,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigSetEnumFunc)(const char *name, int val, void *privdata, RedisModuleString **err);",13,111,redismodule.h,RedisModuleConfigSetEnumFunc,,false,919,919,RedisModuleConfigSetEnumFunc,,,165,"int RedisModuleConfigSetEnumFunc (char*,int,void*,RedisModuleString**)"
314809,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleConfigApplyFunc)(RedisModuleCtx *ctx, void *privdata, RedisModuleString **err);",13,103,redismodule.h,RedisModuleConfigApplyFunc,,false,920,920,RedisModuleConfigApplyFunc,,,166,"int RedisModuleConfigApplyFunc (RedisModuleCtx*,void*,RedisModuleString**)"
314816,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef void (*RedisModuleOnUnblocked)(RedisModuleCtx *ctx, RedisModuleCallReply *reply, void *private_data);",14,108,redismodule.h,RedisModuleOnUnblocked,,false,921,921,RedisModuleOnUnblocked,,,167,"void RedisModuleOnUnblocked (RedisModuleCtx*,RedisModuleCallReply*,void*)"
314823,METHOD,redismodule.h:<global>,TYPE_DECL,"typedef int (*RedisModuleAuthCallback)(RedisModuleCtx *ctx, RedisModuleString *username, RedisModuleString *password, RedisModuleString **err);",13,142,redismodule.h,RedisModuleAuthCallback,,false,922,922,RedisModuleAuthCallback,,,168,"int RedisModuleAuthCallback (RedisModuleCtx*,RedisModuleString*,RedisModuleString*,RedisModuleString**)"
314852,METHOD,redismodule.h:<global>,TYPE_DECL,void * (*RedisModule_Alloc)(size_t bytes) REDISMODULE_ATTR;,22,57,redismodule.h,RedisModule_Alloc,,false,959,959,RedisModule_Alloc,,,171,void* RedisModule_Alloc (size_t)
314857,METHOD,redismodule.h:<global>,TYPE_DECL,void * (*RedisModule_TryAlloc)(size_t bytes) REDISMODULE_ATTR;,22,60,redismodule.h,RedisModule_TryAlloc,,false,960,960,RedisModule_TryAlloc,,,172,void* RedisModule_TryAlloc (size_t)
314862,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_Realloc)(void *ptr, size_t bytes) REDISMODULE_ATTR;",22,70,redismodule.h,RedisModule_Realloc,,false,961,961,RedisModule_Realloc,,,173,"void* RedisModule_Realloc (void*,size_t)"
314868,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_Free)(void *ptr) REDISMODULE_ATTR;,22,51,redismodule.h,RedisModule_Free,,false,962,962,RedisModule_Free,,,174,void RedisModule_Free (void*)
314873,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_Calloc)(size_t nmemb, size_t size) REDISMODULE_ATTR;",22,71,redismodule.h,RedisModule_Calloc,,false,963,963,RedisModule_Calloc,,,175,"void* RedisModule_Calloc (size_t,size_t)"
314879,METHOD,redismodule.h:<global>,TYPE_DECL,char * (*RedisModule_Strdup)(const char *str) REDISMODULE_ATTR;,22,61,redismodule.h,RedisModule_Strdup,,false,964,964,RedisModule_Strdup,,,176,char* RedisModule_Strdup (char*)
314884,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_GetApi)(const char *, void *) REDISMODULE_ATTR;",21,63,redismodule.h,RedisModule_GetApi,,false,965,965,RedisModule_GetApi,,,177,"int RedisModule_GetApi (char*,void*)"
314890,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CreateCommand)(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) REDISMODULE_ATTR;",21,177,redismodule.h,RedisModule_CreateCommand,,false,966,966,RedisModule_CreateCommand,,,178,"int RedisModule_CreateCommand (RedisModuleCtx*,char*,RedisModuleCmdFunc,char*,int,int,int)"
314901,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleCommand *(*RedisModule_GetCommand)(RedisModuleCtx *ctx, const char *name) REDISMODULE_ATTR;",36,100,redismodule.h,RedisModule_GetCommand,,false,967,967,RedisModule_GetCommand,,,179,"RedisModuleCommand* RedisModule_GetCommand (RedisModuleCtx*,char*)"
314907,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CreateSubcommand)(RedisModuleCommand *parent, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) REDISMODULE_ATTR;",21,187,redismodule.h,RedisModule_CreateSubcommand,,false,968,968,RedisModule_CreateSubcommand,,,180,"int RedisModule_CreateSubcommand (RedisModuleCommand*,char*,RedisModuleCmdFunc,char*,int,int,int)"
314918,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetCommandInfo)(RedisModuleCommand *command, const RedisModuleCommandInfo *info) REDISMODULE_ATTR;",21,114,redismodule.h,RedisModule_SetCommandInfo,,false,969,969,RedisModule_SetCommandInfo,,,181,"int RedisModule_SetCommandInfo (RedisModuleCommand*,RedisModuleCommandInfo*)"
314924,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetCommandACLCategories)(RedisModuleCommand *command, const char *ctgrsflags) REDISMODULE_ATTR;",21,111,redismodule.h,RedisModule_SetCommandACLCategories,,false,970,970,RedisModule_SetCommandACLCategories,,,182,"int RedisModule_SetCommandACLCategories (RedisModuleCommand*,char*)"
314930,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SetModuleAttribs)(RedisModuleCtx *ctx, const char *name, int ver, int apiver) REDISMODULE_ATTR;",22,112,redismodule.h,RedisModule_SetModuleAttribs,,false,971,971,RedisModule_SetModuleAttribs,,,183,"void RedisModule_SetModuleAttribs (RedisModuleCtx*,char*,int,int)"
314938,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_IsModuleNameBusy)(const char *name) REDISMODULE_ATTR;,21,69,redismodule.h,RedisModule_IsModuleNameBusy,,false,972,972,RedisModule_IsModuleNameBusy,,,184,int RedisModule_IsModuleNameBusy (char*)
314943,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_WrongArity)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,66,redismodule.h,RedisModule_WrongArity,,false,973,973,RedisModule_WrongArity,,,185,int RedisModule_WrongArity (RedisModuleCtx*)
314948,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithLongLong)(RedisModuleCtx *ctx, long long ll) REDISMODULE_ATTR;",21,87,redismodule.h,RedisModule_ReplyWithLongLong,,false,974,974,RedisModule_ReplyWithLongLong,,,186,"int RedisModule_ReplyWithLongLong (RedisModuleCtx*,long long)"
314954,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetSelectedDb)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,69,redismodule.h,RedisModule_GetSelectedDb,,false,975,975,RedisModule_GetSelectedDb,,,187,int RedisModule_GetSelectedDb (RedisModuleCtx*)
314959,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SelectDb)(RedisModuleCtx *ctx, int newid) REDISMODULE_ATTR;",21,75,redismodule.h,RedisModule_SelectDb,,false,976,976,RedisModule_SelectDb,,,188,"int RedisModule_SelectDb (RedisModuleCtx*,int)"
314965,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_KeyExists)(RedisModuleCtx *ctx, RedisModuleString *keyname) REDISMODULE_ATTR;",21,93,redismodule.h,RedisModule_KeyExists,,false,977,977,RedisModule_KeyExists,,,189,"int RedisModule_KeyExists (RedisModuleCtx*,RedisModuleString*)"
314971,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleKey * (*RedisModule_OpenKey)(RedisModuleCtx *ctx, RedisModuleString *keyname, int mode) REDISMODULE_ATTR;",32,114,redismodule.h,RedisModule_OpenKey,,false,978,978,RedisModule_OpenKey,,,190,"RedisModuleKey* RedisModule_OpenKey (RedisModuleCtx*,RedisModuleString*,int)"
314978,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetOpenKeyModesAll)(void) REDISMODULE_ATTR;,21,59,redismodule.h,RedisModule_GetOpenKeyModesAll,,false,979,979,RedisModule_GetOpenKeyModesAll,,,191,int RedisModule_GetOpenKeyModesAll (void)
314983,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_CloseKey)(RedisModuleKey *kp) REDISMODULE_ATTR;,22,64,redismodule.h,RedisModule_CloseKey,,false,980,980,RedisModule_CloseKey,,,192,void RedisModule_CloseKey (RedisModuleKey*)
314988,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_KeyType)(RedisModuleKey *kp) REDISMODULE_ATTR;,21,62,redismodule.h,RedisModule_KeyType,,false,981,981,RedisModule_KeyType,,,193,int RedisModule_KeyType (RedisModuleKey*)
314993,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_ValueLength)(RedisModuleKey *kp) REDISMODULE_ATTR;,24,69,redismodule.h,RedisModule_ValueLength,,false,982,982,RedisModule_ValueLength,,,194,size_t RedisModule_ValueLength (RedisModuleKey*)
314998,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ListPush)(RedisModuleKey *kp, int where, RedisModuleString *ele) REDISMODULE_ATTR;",21,98,redismodule.h,RedisModule_ListPush,,false,983,983,RedisModule_ListPush,,,195,"int RedisModule_ListPush (RedisModuleKey*,int,RedisModuleString*)"
315005,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_ListPop)(RedisModuleKey *key, int where) REDISMODULE_ATTR;",35,90,redismodule.h,RedisModule_ListPop,,false,984,984,RedisModule_ListPop,,,196,"RedisModuleString* RedisModule_ListPop (RedisModuleKey*,int)"
315011,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_ListGet)(RedisModuleKey *key, long index) REDISMODULE_ATTR;",35,91,redismodule.h,RedisModule_ListGet,,false,985,985,RedisModule_ListGet,,,197,"RedisModuleString* RedisModule_ListGet (RedisModuleKey*,long)"
315017,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ListSet)(RedisModuleKey *key, long index, RedisModuleString *value) REDISMODULE_ATTR;",21,101,redismodule.h,RedisModule_ListSet,,false,986,986,RedisModule_ListSet,,,198,"int RedisModule_ListSet (RedisModuleKey*,long,RedisModuleString*)"
315024,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ListInsert)(RedisModuleKey *key, long index, RedisModuleString *value) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_ListInsert,,false,987,987,RedisModule_ListInsert,,,199,"int RedisModule_ListInsert (RedisModuleKey*,long,RedisModuleString*)"
315031,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ListDelete)(RedisModuleKey *key, long index) REDISMODULE_ATTR;",21,78,redismodule.h,RedisModule_ListDelete,,false,988,988,RedisModule_ListDelete,,,200,"int RedisModule_ListDelete (RedisModuleKey*,long)"
315037,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleCallReply * (*RedisModule_Call)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",38,122,redismodule.h,RedisModule_Call,,false,989,989,RedisModule_Call,,,201,"RedisModuleCallReply* RedisModule_Call (RedisModuleCtx*,char*,char*...)"
315044,METHOD,redismodule.h:<global>,TYPE_DECL,"const char * (*RedisModule_CallReplyProto)(RedisModuleCallReply *reply, size_t *len) REDISMODULE_ATTR;",28,100,redismodule.h,RedisModule_CallReplyProto,,false,990,990,RedisModule_CallReplyProto,,,202,"char* RedisModule_CallReplyProto (RedisModuleCallReply*,size_t*)"
315050,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_FreeCallReply)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,22,78,redismodule.h,RedisModule_FreeCallReply,,false,991,991,RedisModule_FreeCallReply,,,203,void RedisModule_FreeCallReply (RedisModuleCallReply*)
315055,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_CallReplyType)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,21,77,redismodule.h,RedisModule_CallReplyType,,false,992,992,RedisModule_CallReplyType,,,204,int RedisModule_CallReplyType (RedisModuleCallReply*)
315060,METHOD,redismodule.h:<global>,TYPE_DECL,long long (*RedisModule_CallReplyInteger)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,27,86,redismodule.h,RedisModule_CallReplyInteger,,false,993,993,RedisModule_CallReplyInteger,,,205,long long RedisModule_CallReplyInteger (RedisModuleCallReply*)
315065,METHOD,redismodule.h:<global>,TYPE_DECL,double (*RedisModule_CallReplyDouble)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,24,82,redismodule.h,RedisModule_CallReplyDouble,,false,994,994,RedisModule_CallReplyDouble,,,206,double RedisModule_CallReplyDouble (RedisModuleCallReply*)
315070,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_CallReplyBool)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,21,77,redismodule.h,RedisModule_CallReplyBool,,false,995,995,RedisModule_CallReplyBool,,,207,int RedisModule_CallReplyBool (RedisModuleCallReply*)
315075,METHOD,redismodule.h:<global>,TYPE_DECL,"const char* (*RedisModule_CallReplyBigNumber)(RedisModuleCallReply *reply, size_t *len) REDISMODULE_ATTR;",27,103,redismodule.h,RedisModule_CallReplyBigNumber,,false,996,996,RedisModule_CallReplyBigNumber,,,208,"char* RedisModule_CallReplyBigNumber (RedisModuleCallReply*,size_t*)"
315081,METHOD,redismodule.h:<global>,TYPE_DECL,"const char* (*RedisModule_CallReplyVerbatim)(RedisModuleCallReply *reply, size_t *len, const char **format) REDISMODULE_ATTR;",27,123,redismodule.h,RedisModule_CallReplyVerbatim,,false,997,997,RedisModule_CallReplyVerbatim,,,209,"char* RedisModule_CallReplyVerbatim (RedisModuleCallReply*,size_t*,char**)"
315088,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleCallReply * (*RedisModule_CallReplySetElement)(RedisModuleCallReply *reply, size_t idx) REDISMODULE_ATTR;",38,114,redismodule.h,RedisModule_CallReplySetElement,,false,998,998,RedisModule_CallReplySetElement,,,210,"RedisModuleCallReply* RedisModule_CallReplySetElement (RedisModuleCallReply*,size_t)"
315094,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CallReplyMapElement)(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) REDISMODULE_ATTR;",21,151,redismodule.h,RedisModule_CallReplyMapElement,,false,999,999,RedisModule_CallReplyMapElement,,,211,"int RedisModule_CallReplyMapElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)"
315102,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CallReplyAttributeElement)(RedisModuleCallReply *reply, size_t idx, RedisModuleCallReply **key, RedisModuleCallReply **val) REDISMODULE_ATTR;",21,157,redismodule.h,RedisModule_CallReplyAttributeElement,,false,1000,1000,RedisModule_CallReplyAttributeElement,,,212,"int RedisModule_CallReplyAttributeElement (RedisModuleCallReply*,size_t,RedisModuleCallReply**,RedisModuleCallReply**)"
315110,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_CallReplyPromiseSetUnblockHandler)(RedisModuleCallReply *reply, RedisModuleOnUnblocked on_unblock, void *private_data) REDISMODULE_ATTR;",22,153,redismodule.h,RedisModule_CallReplyPromiseSetUnblockHandler,,false,1001,1001,RedisModule_CallReplyPromiseSetUnblockHandler,,,213,"void RedisModule_CallReplyPromiseSetUnblockHandler (RedisModuleCallReply*,RedisModuleOnUnblocked,void*)"
315117,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CallReplyPromiseAbort)(RedisModuleCallReply *reply, void **private_data) REDISMODULE_ATTR;",21,106,redismodule.h,RedisModule_CallReplyPromiseAbort,,false,1002,1002,RedisModule_CallReplyPromiseAbort,,,214,"int RedisModule_CallReplyPromiseAbort (RedisModuleCallReply*,void**)"
315123,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleCallReply * (*RedisModule_CallReplyAttribute)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,38,101,redismodule.h,RedisModule_CallReplyAttribute,,false,1003,1003,RedisModule_CallReplyAttribute,,,215,RedisModuleCallReply* RedisModule_CallReplyAttribute (RedisModuleCallReply*)
315128,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_CallReplyLength)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,24,82,redismodule.h,RedisModule_CallReplyLength,,false,1004,1004,RedisModule_CallReplyLength,,,216,size_t RedisModule_CallReplyLength (RedisModuleCallReply*)
315133,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleCallReply * (*RedisModule_CallReplyArrayElement)(RedisModuleCallReply *reply, size_t idx) REDISMODULE_ATTR;",38,116,redismodule.h,RedisModule_CallReplyArrayElement,,false,1005,1005,RedisModule_CallReplyArrayElement,,,217,"RedisModuleCallReply* RedisModule_CallReplyArrayElement (RedisModuleCallReply*,size_t)"
315139,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateString)(RedisModuleCtx *ctx, const char *ptr, size_t len) REDISMODULE_ATTR;",35,113,redismodule.h,RedisModule_CreateString,,false,1006,1006,RedisModule_CreateString,,,218,"RedisModuleString* RedisModule_CreateString (RedisModuleCtx*,char*,size_t)"
315146,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringFromLongLong)(RedisModuleCtx *ctx, long long ll) REDISMODULE_ATTR;",35,110,redismodule.h,RedisModule_CreateStringFromLongLong,,false,1007,1007,RedisModule_CreateStringFromLongLong,,,219,"RedisModuleString* RedisModule_CreateStringFromLongLong (RedisModuleCtx*,long long)"
315152,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringFromULongLong)(RedisModuleCtx *ctx, unsigned long long ull) REDISMODULE_ATTR;",35,121,redismodule.h,RedisModule_CreateStringFromULongLong,,false,1008,1008,RedisModule_CreateStringFromULongLong,,,220,"RedisModuleString* RedisModule_CreateStringFromULongLong (RedisModuleCtx*,long long unsigned)"
315158,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringFromDouble)(RedisModuleCtx *ctx, double d) REDISMODULE_ATTR;",35,104,redismodule.h,RedisModule_CreateStringFromDouble,,false,1009,1009,RedisModule_CreateStringFromDouble,,,221,"RedisModuleString* RedisModule_CreateStringFromDouble (RedisModuleCtx*,double)"
315164,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringFromLongDouble)(RedisModuleCtx *ctx, long double ld, int humanfriendly) REDISMODULE_ATTR;",35,133,redismodule.h,RedisModule_CreateStringFromLongDouble,,false,1010,1010,RedisModule_CreateStringFromLongDouble,,,222,"RedisModuleString* RedisModule_CreateStringFromLongDouble (RedisModuleCtx*,long double,int)"
315171,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringFromString)(RedisModuleCtx *ctx, const RedisModuleString *str) REDISMODULE_ATTR;",35,124,redismodule.h,RedisModule_CreateStringFromString,,false,1011,1011,RedisModule_CreateStringFromString,,,223,"RedisModuleString* RedisModule_CreateStringFromString (RedisModuleCtx*,RedisModuleString*)"
315177,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringFromStreamID)(RedisModuleCtx *ctx, const RedisModuleStreamID *id) REDISMODULE_ATTR;",35,127,redismodule.h,RedisModule_CreateStringFromStreamID,,false,1012,1012,RedisModule_CreateStringFromStreamID,,,224,"RedisModuleString* RedisModule_CreateStringFromStreamID (RedisModuleCtx*,RedisModuleStreamID*)"
315183,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CreateStringPrintf)(RedisModuleCtx *ctx, const char *fmt, ...) REDISMODULE_ATTR_PRINTF(2,3) REDISMODULE_ATTR;",35,112,redismodule.h,RedisModule_CreateStringPrintf,,false,1013,1013,RedisModule_CreateStringPrintf,,,225,"RedisModuleString* RedisModule_CreateStringPrintf (RedisModuleCtx*,char*...)"
315189,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_FreeString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",22,91,redismodule.h,RedisModule_FreeString,,false,1014,1014,RedisModule_FreeString,,,226,"void RedisModule_FreeString (RedisModuleCtx*,RedisModuleString*)"
315195,METHOD,redismodule.h:<global>,TYPE_DECL,"const char * (*RedisModule_StringPtrLen)(const RedisModuleString *str, size_t *len) REDISMODULE_ATTR;",28,99,redismodule.h,RedisModule_StringPtrLen,,false,1015,1015,RedisModule_StringPtrLen,,,227,"char* RedisModule_StringPtrLen (RedisModuleString*,size_t*)"
315201,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithError)(RedisModuleCtx *ctx, const char *err) REDISMODULE_ATTR;",21,87,redismodule.h,RedisModule_ReplyWithError,,false,1016,1016,RedisModule_ReplyWithError,,,228,"int RedisModule_ReplyWithError (RedisModuleCtx*,char*)"
315207,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithErrorFormat)(RedisModuleCtx *ctx, const char *fmt, ...) REDISMODULE_ATTR;",21,98,redismodule.h,RedisModule_ReplyWithErrorFormat,,false,1017,1017,RedisModule_ReplyWithErrorFormat,,,229,"int RedisModule_ReplyWithErrorFormat (RedisModuleCtx*,char*...)"
315213,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithSimpleString)(RedisModuleCtx *ctx, const char *msg) REDISMODULE_ATTR;",21,94,redismodule.h,RedisModule_ReplyWithSimpleString,,false,1018,1018,RedisModule_ReplyWithSimpleString,,,230,"int RedisModule_ReplyWithSimpleString (RedisModuleCtx*,char*)"
315219,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithArray)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",21,80,redismodule.h,RedisModule_ReplyWithArray,,false,1019,1019,RedisModule_ReplyWithArray,,,231,"int RedisModule_ReplyWithArray (RedisModuleCtx*,long)"
315225,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithMap)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",21,78,redismodule.h,RedisModule_ReplyWithMap,,false,1020,1020,RedisModule_ReplyWithMap,,,232,"int RedisModule_ReplyWithMap (RedisModuleCtx*,long)"
315231,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithSet)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",21,78,redismodule.h,RedisModule_ReplyWithSet,,false,1021,1021,RedisModule_ReplyWithSet,,,233,"int RedisModule_ReplyWithSet (RedisModuleCtx*,long)"
315237,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithAttribute)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",21,84,redismodule.h,RedisModule_ReplyWithAttribute,,false,1022,1022,RedisModule_ReplyWithAttribute,,,234,"int RedisModule_ReplyWithAttribute (RedisModuleCtx*,long)"
315243,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ReplyWithNullArray)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,74,redismodule.h,RedisModule_ReplyWithNullArray,,false,1023,1023,RedisModule_ReplyWithNullArray,,,235,int RedisModule_ReplyWithNullArray (RedisModuleCtx*)
315248,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ReplyWithEmptyArray)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,75,redismodule.h,RedisModule_ReplyWithEmptyArray,,false,1024,1024,RedisModule_ReplyWithEmptyArray,,,236,int RedisModule_ReplyWithEmptyArray (RedisModuleCtx*)
315253,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ReplySetArrayLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",22,86,redismodule.h,RedisModule_ReplySetArrayLength,,false,1025,1025,RedisModule_ReplySetArrayLength,,,237,"void RedisModule_ReplySetArrayLength (RedisModuleCtx*,long)"
315259,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ReplySetMapLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",22,84,redismodule.h,RedisModule_ReplySetMapLength,,false,1026,1026,RedisModule_ReplySetMapLength,,,238,"void RedisModule_ReplySetMapLength (RedisModuleCtx*,long)"
315265,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ReplySetSetLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",22,84,redismodule.h,RedisModule_ReplySetSetLength,,false,1027,1027,RedisModule_ReplySetSetLength,,,239,"void RedisModule_ReplySetSetLength (RedisModuleCtx*,long)"
315271,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ReplySetAttributeLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",22,90,redismodule.h,RedisModule_ReplySetAttributeLength,,false,1028,1028,RedisModule_ReplySetAttributeLength,,,240,"void RedisModule_ReplySetAttributeLength (RedisModuleCtx*,long)"
315277,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ReplySetPushLength)(RedisModuleCtx *ctx, long len) REDISMODULE_ATTR;",22,85,redismodule.h,RedisModule_ReplySetPushLength,,false,1029,1029,RedisModule_ReplySetPushLength,,,241,"void RedisModule_ReplySetPushLength (RedisModuleCtx*,long)"
315283,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithStringBuffer)(RedisModuleCtx *ctx, const char *buf, size_t len) REDISMODULE_ATTR;",21,106,redismodule.h,RedisModule_ReplyWithStringBuffer,,false,1030,1030,RedisModule_ReplyWithStringBuffer,,,242,"int RedisModule_ReplyWithStringBuffer (RedisModuleCtx*,char*,size_t)"
315290,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithCString)(RedisModuleCtx *ctx, const char *buf) REDISMODULE_ATTR;",21,89,redismodule.h,RedisModule_ReplyWithCString,,false,1031,1031,RedisModule_ReplyWithCString,,,243,"int RedisModule_ReplyWithCString (RedisModuleCtx*,char*)"
315296,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",21,95,redismodule.h,RedisModule_ReplyWithString,,false,1032,1032,RedisModule_ReplyWithString,,,244,"int RedisModule_ReplyWithString (RedisModuleCtx*,RedisModuleString*)"
315302,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ReplyWithEmptyString)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,76,redismodule.h,RedisModule_ReplyWithEmptyString,,false,1033,1033,RedisModule_ReplyWithEmptyString,,,245,int RedisModule_ReplyWithEmptyString (RedisModuleCtx*)
315307,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithVerbatimString)(RedisModuleCtx *ctx, const char *buf, size_t len) REDISMODULE_ATTR;",21,108,redismodule.h,RedisModule_ReplyWithVerbatimString,,false,1034,1034,RedisModule_ReplyWithVerbatimString,,,246,"int RedisModule_ReplyWithVerbatimString (RedisModuleCtx*,char*,size_t)"
315314,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithVerbatimStringType)(RedisModuleCtx *ctx, const char *buf, size_t len, const char *ext) REDISMODULE_ATTR;",21,129,redismodule.h,RedisModule_ReplyWithVerbatimStringType,,false,1035,1035,RedisModule_ReplyWithVerbatimStringType,,,247,"int RedisModule_ReplyWithVerbatimStringType (RedisModuleCtx*,char*,size_t,char*)"
315322,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ReplyWithNull)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,69,redismodule.h,RedisModule_ReplyWithNull,,false,1036,1036,RedisModule_ReplyWithNull,,,248,int RedisModule_ReplyWithNull (RedisModuleCtx*)
315327,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithBool)(RedisModuleCtx *ctx, int b) REDISMODULE_ATTR;",21,76,redismodule.h,RedisModule_ReplyWithBool,,false,1037,1037,RedisModule_ReplyWithBool,,,249,"int RedisModule_ReplyWithBool (RedisModuleCtx*,int)"
315333,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithLongDouble)(RedisModuleCtx *ctx, long double d) REDISMODULE_ATTR;",21,90,redismodule.h,RedisModule_ReplyWithLongDouble,,false,1038,1038,RedisModule_ReplyWithLongDouble,,,250,"int RedisModule_ReplyWithLongDouble (RedisModuleCtx*,long double)"
315339,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithDouble)(RedisModuleCtx *ctx, double d) REDISMODULE_ATTR;",21,81,redismodule.h,RedisModule_ReplyWithDouble,,false,1039,1039,RedisModule_ReplyWithDouble,,,251,"int RedisModule_ReplyWithDouble (RedisModuleCtx*,double)"
315345,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithBigNumber)(RedisModuleCtx *ctx, const char *bignum, size_t len) REDISMODULE_ATTR;",21,106,redismodule.h,RedisModule_ReplyWithBigNumber,,false,1040,1040,RedisModule_ReplyWithBigNumber,,,252,"int RedisModule_ReplyWithBigNumber (RedisModuleCtx*,char*,size_t)"
315352,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ReplyWithCallReply)(RedisModuleCtx *ctx, RedisModuleCallReply *reply) REDISMODULE_ATTR;",21,103,redismodule.h,RedisModule_ReplyWithCallReply,,false,1041,1041,RedisModule_ReplyWithCallReply,,,253,"int RedisModule_ReplyWithCallReply (RedisModuleCtx*,RedisModuleCallReply*)"
315358,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringToLongLong)(const RedisModuleString *str, long long *ll) REDISMODULE_ATTR;",21,96,redismodule.h,RedisModule_StringToLongLong,,false,1042,1042,RedisModule_StringToLongLong,,,254,"int RedisModule_StringToLongLong (RedisModuleString*,long long*)"
315364,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringToULongLong)(const RedisModuleString *str, unsigned long long *ull) REDISMODULE_ATTR;",21,107,redismodule.h,RedisModule_StringToULongLong,,false,1043,1043,RedisModule_StringToULongLong,,,255,"int RedisModule_StringToULongLong (RedisModuleString*,long long unsigned*)"
315370,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringToDouble)(const RedisModuleString *str, double *d) REDISMODULE_ATTR;",21,90,redismodule.h,RedisModule_StringToDouble,,false,1044,1044,RedisModule_StringToDouble,,,256,"int RedisModule_StringToDouble (RedisModuleString*,double*)"
315376,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringToLongDouble)(const RedisModuleString *str, long double *d) REDISMODULE_ATTR;",21,99,redismodule.h,RedisModule_StringToLongDouble,,false,1045,1045,RedisModule_StringToLongDouble,,,257,"int RedisModule_StringToLongDouble (RedisModuleString*,long double*)"
315382,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringToStreamID)(const RedisModuleString *str, RedisModuleStreamID *id) REDISMODULE_ATTR;",21,106,redismodule.h,RedisModule_StringToStreamID,,false,1046,1046,RedisModule_StringToStreamID,,,258,"int RedisModule_StringToStreamID (RedisModuleString*,RedisModuleStreamID*)"
315388,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_AutoMemory)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,22,67,redismodule.h,RedisModule_AutoMemory,,false,1047,1047,RedisModule_AutoMemory,,,259,void RedisModule_AutoMemory (RedisModuleCtx*)
315393,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_Replicate)(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",21,108,redismodule.h,RedisModule_Replicate,,false,1048,1048,RedisModule_Replicate,,,260,"int RedisModule_Replicate (RedisModuleCtx*,char*,char*...)"
315400,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ReplicateVerbatim)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,73,redismodule.h,RedisModule_ReplicateVerbatim,,false,1049,1049,RedisModule_ReplicateVerbatim,,,261,int RedisModule_ReplicateVerbatim (RedisModuleCtx*)
315405,METHOD,redismodule.h:<global>,TYPE_DECL,"const char * (*RedisModule_CallReplyStringPtr)(RedisModuleCallReply *reply, size_t *len) REDISMODULE_ATTR;",28,104,redismodule.h,RedisModule_CallReplyStringPtr,,false,1050,1050,RedisModule_CallReplyStringPtr,,,262,"char* RedisModule_CallReplyStringPtr (RedisModuleCallReply*,size_t*)"
315411,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleString * (*RedisModule_CreateStringFromCallReply)(RedisModuleCallReply *reply) REDISMODULE_ATTR;,35,105,redismodule.h,RedisModule_CreateStringFromCallReply,,false,1051,1051,RedisModule_CreateStringFromCallReply,,,263,RedisModuleString* RedisModule_CreateStringFromCallReply (RedisModuleCallReply*)
315416,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_DeleteKey)(RedisModuleKey *key) REDISMODULE_ATTR;,21,65,redismodule.h,RedisModule_DeleteKey,,false,1052,1052,RedisModule_DeleteKey,,,264,int RedisModule_DeleteKey (RedisModuleKey*)
315421,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_UnlinkKey)(RedisModuleKey *key) REDISMODULE_ATTR;,21,65,redismodule.h,RedisModule_UnlinkKey,,false,1053,1053,RedisModule_UnlinkKey,,,265,int RedisModule_UnlinkKey (RedisModuleKey*)
315426,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringSet)(RedisModuleKey *key, RedisModuleString *str) REDISMODULE_ATTR;",21,89,redismodule.h,RedisModule_StringSet,,false,1054,1054,RedisModule_StringSet,,,266,"int RedisModule_StringSet (RedisModuleKey*,RedisModuleString*)"
315432,METHOD,redismodule.h:<global>,TYPE_DECL,"char * (*RedisModule_StringDMA)(RedisModuleKey *key, size_t *len, int mode) REDISMODULE_ATTR;",22,91,redismodule.h,RedisModule_StringDMA,,false,1055,1055,RedisModule_StringDMA,,,267,"char* RedisModule_StringDMA (RedisModuleKey*,size_t*,int)"
315439,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringTruncate)(RedisModuleKey *key, size_t newlen) REDISMODULE_ATTR;",21,85,redismodule.h,RedisModule_StringTruncate,,false,1056,1056,RedisModule_StringTruncate,,,268,"int RedisModule_StringTruncate (RedisModuleKey*,size_t)"
315445,METHOD,redismodule.h:<global>,TYPE_DECL,mstime_t (*RedisModule_GetExpire)(RedisModuleKey *key) REDISMODULE_ATTR;,26,70,redismodule.h,RedisModule_GetExpire,,false,1057,1057,RedisModule_GetExpire,,,269,mstime_t RedisModule_GetExpire (RedisModuleKey*)
315450,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetExpire)(RedisModuleKey *key, mstime_t expire) REDISMODULE_ATTR;",21,82,redismodule.h,RedisModule_SetExpire,,false,1058,1058,RedisModule_SetExpire,,,270,"int RedisModule_SetExpire (RedisModuleKey*,mstime_t)"
315456,METHOD,redismodule.h:<global>,TYPE_DECL,mstime_t (*RedisModule_GetAbsExpire)(RedisModuleKey *key) REDISMODULE_ATTR;,26,73,redismodule.h,RedisModule_GetAbsExpire,,false,1059,1059,RedisModule_GetAbsExpire,,,271,mstime_t RedisModule_GetAbsExpire (RedisModuleKey*)
315461,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetAbsExpire)(RedisModuleKey *key, mstime_t expire) REDISMODULE_ATTR;",21,85,redismodule.h,RedisModule_SetAbsExpire,,false,1060,1060,RedisModule_SetAbsExpire,,,272,"int RedisModule_SetAbsExpire (RedisModuleKey*,mstime_t)"
315467,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ResetDataset)(int restart_aof, int async) REDISMODULE_ATTR;",22,76,redismodule.h,RedisModule_ResetDataset,,false,1061,1061,RedisModule_ResetDataset,,,273,"void RedisModule_ResetDataset (int,int)"
315473,METHOD,redismodule.h:<global>,TYPE_DECL,unsigned long long (*RedisModule_DbSize)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,36,77,redismodule.h,RedisModule_DbSize,,false,1062,1062,RedisModule_DbSize,,,274,long long unsigned RedisModule_DbSize (RedisModuleCtx*)
315478,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleString * (*RedisModule_RandomKey)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,35,81,redismodule.h,RedisModule_RandomKey,,false,1063,1063,RedisModule_RandomKey,,,275,RedisModuleString* RedisModule_RandomKey (RedisModuleCtx*)
315483,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetAdd)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) REDISMODULE_ATTR;",21,116,redismodule.h,RedisModule_ZsetAdd,,false,1064,1064,RedisModule_ZsetAdd,,,276,"int RedisModule_ZsetAdd (RedisModuleKey*,double,RedisModuleString*,int*)"
315491,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetIncrby)(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) REDISMODULE_ATTR;",21,137,redismodule.h,RedisModule_ZsetIncrby,,false,1065,1065,RedisModule_ZsetIncrby,,,277,"int RedisModule_ZsetIncrby (RedisModuleKey*,double,RedisModuleString*,int*,double*)"
315500,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetScore)(RedisModuleKey *key, RedisModuleString *ele, double *score) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_ZsetScore,,false,1066,1066,RedisModule_ZsetScore,,,278,"int RedisModule_ZsetScore (RedisModuleKey*,RedisModuleString*,double*)"
315507,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetRem)(RedisModuleKey *key, RedisModuleString *ele, int *deleted) REDISMODULE_ATTR;",21,101,redismodule.h,RedisModule_ZsetRem,,false,1067,1067,RedisModule_ZsetRem,,,279,"int RedisModule_ZsetRem (RedisModuleKey*,RedisModuleString*,int*)"
315514,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_ZsetRangeStop)(RedisModuleKey *key) REDISMODULE_ATTR;,22,70,redismodule.h,RedisModule_ZsetRangeStop,,false,1068,1068,RedisModule_ZsetRangeStop,,,280,void RedisModule_ZsetRangeStop (RedisModuleKey*)
315519,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetFirstInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex) REDISMODULE_ATTR;",21,123,redismodule.h,RedisModule_ZsetFirstInScoreRange,,false,1069,1069,RedisModule_ZsetFirstInScoreRange,,,281,"int RedisModule_ZsetFirstInScoreRange (RedisModuleKey*,double,double,int,int)"
315528,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetLastInScoreRange)(RedisModuleKey *key, double min, double max, int minex, int maxex) REDISMODULE_ATTR;",21,122,redismodule.h,RedisModule_ZsetLastInScoreRange,,false,1070,1070,RedisModule_ZsetLastInScoreRange,,,282,"int RedisModule_ZsetLastInScoreRange (RedisModuleKey*,double,double,int,int)"
315537,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetFirstInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) REDISMODULE_ATTR;",21,123,redismodule.h,RedisModule_ZsetFirstInLexRange,,false,1071,1071,RedisModule_ZsetFirstInLexRange,,,283,"int RedisModule_ZsetFirstInLexRange (RedisModuleKey*,RedisModuleString*,RedisModuleString*)"
315544,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ZsetLastInLexRange)(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) REDISMODULE_ATTR;",21,122,redismodule.h,RedisModule_ZsetLastInLexRange,,false,1072,1072,RedisModule_ZsetLastInLexRange,,,284,"int RedisModule_ZsetLastInLexRange (RedisModuleKey*,RedisModuleString*,RedisModuleString*)"
315551,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_ZsetRangeCurrentElement)(RedisModuleKey *key, double *score) REDISMODULE_ATTR;",35,110,redismodule.h,RedisModule_ZsetRangeCurrentElement,,false,1073,1073,RedisModule_ZsetRangeCurrentElement,,,285,"RedisModuleString* RedisModule_ZsetRangeCurrentElement (RedisModuleKey*,double*)"
315557,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ZsetRangeNext)(RedisModuleKey *key) REDISMODULE_ATTR;,21,69,redismodule.h,RedisModule_ZsetRangeNext,,false,1074,1074,RedisModule_ZsetRangeNext,,,286,int RedisModule_ZsetRangeNext (RedisModuleKey*)
315562,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ZsetRangePrev)(RedisModuleKey *key) REDISMODULE_ATTR;,21,69,redismodule.h,RedisModule_ZsetRangePrev,,false,1075,1075,RedisModule_ZsetRangePrev,,,287,int RedisModule_ZsetRangePrev (RedisModuleKey*)
315567,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ZsetRangeEndReached)(RedisModuleKey *key) REDISMODULE_ATTR;,21,75,redismodule.h,RedisModule_ZsetRangeEndReached,,false,1076,1076,RedisModule_ZsetRangeEndReached,,,288,int RedisModule_ZsetRangeEndReached (RedisModuleKey*)
315572,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_HashSet)(RedisModuleKey *key, int flags, ...) REDISMODULE_ATTR;",21,79,redismodule.h,RedisModule_HashSet,,false,1077,1077,RedisModule_HashSet,,,289,"int RedisModule_HashSet (RedisModuleKey*,int...)"
315578,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_HashGet)(RedisModuleKey *key, int flags, ...) REDISMODULE_ATTR;",21,79,redismodule.h,RedisModule_HashGet,,false,1078,1078,RedisModule_HashGet,,,290,"int RedisModule_HashGet (RedisModuleKey*,int...)"
315584,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StreamAdd)(RedisModuleKey *key, int flags, RedisModuleStreamID *id, RedisModuleString **argv, int64_t numfields) REDISMODULE_ATTR;",21,146,redismodule.h,RedisModule_StreamAdd,,false,1079,1079,RedisModule_StreamAdd,,,291,"int RedisModule_StreamAdd (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleString**,int64_t)"
315593,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StreamDelete)(RedisModuleKey *key, RedisModuleStreamID *id) REDISMODULE_ATTR;",21,93,redismodule.h,RedisModule_StreamDelete,,false,1080,1080,RedisModule_StreamDelete,,,292,"int RedisModule_StreamDelete (RedisModuleKey*,RedisModuleStreamID*)"
315599,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StreamIteratorStart)(RedisModuleKey *key, int flags, RedisModuleStreamID *startid, RedisModuleStreamID *endid) REDISMODULE_ATTR;",21,144,redismodule.h,RedisModule_StreamIteratorStart,,false,1081,1081,RedisModule_StreamIteratorStart,,,293,"int RedisModule_StreamIteratorStart (RedisModuleKey*,int,RedisModuleStreamID*,RedisModuleStreamID*)"
315607,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_StreamIteratorStop)(RedisModuleKey *key) REDISMODULE_ATTR;,21,74,redismodule.h,RedisModule_StreamIteratorStop,,false,1082,1082,RedisModule_StreamIteratorStop,,,294,int RedisModule_StreamIteratorStop (RedisModuleKey*)
315612,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StreamIteratorNextID)(RedisModuleKey *key, RedisModuleStreamID *id, long *numfields) REDISMODULE_ATTR;",21,118,redismodule.h,RedisModule_StreamIteratorNextID,,false,1083,1083,RedisModule_StreamIteratorNextID,,,295,"int RedisModule_StreamIteratorNextID (RedisModuleKey*,RedisModuleStreamID*,long*)"
315619,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StreamIteratorNextField)(RedisModuleKey *key, RedisModuleString **field_ptr, RedisModuleString **value_ptr) REDISMODULE_ATTR;",21,141,redismodule.h,RedisModule_StreamIteratorNextField,,false,1084,1084,RedisModule_StreamIteratorNextField,,,296,"int RedisModule_StreamIteratorNextField (RedisModuleKey*,RedisModuleString**,RedisModuleString**)"
315626,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_StreamIteratorDelete)(RedisModuleKey *key) REDISMODULE_ATTR;,21,76,redismodule.h,RedisModule_StreamIteratorDelete,,false,1085,1085,RedisModule_StreamIteratorDelete,,,297,int RedisModule_StreamIteratorDelete (RedisModuleKey*)
315631,METHOD,redismodule.h:<global>,TYPE_DECL,"long long (*RedisModule_StreamTrimByLength)(RedisModuleKey *key, int flags, long long length) REDISMODULE_ATTR;",27,109,redismodule.h,RedisModule_StreamTrimByLength,,false,1086,1086,RedisModule_StreamTrimByLength,,,298,"long long RedisModule_StreamTrimByLength (RedisModuleKey*,int,long long)"
315638,METHOD,redismodule.h:<global>,TYPE_DECL,"long long (*RedisModule_StreamTrimByID)(RedisModuleKey *key, int flags, RedisModuleStreamID *id) REDISMODULE_ATTR;",27,112,redismodule.h,RedisModule_StreamTrimByID,,false,1087,1087,RedisModule_StreamTrimByID,,,299,"long long RedisModule_StreamTrimByID (RedisModuleKey*,int,RedisModuleStreamID*)"
315645,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_IsKeysPositionRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,77,redismodule.h,RedisModule_IsKeysPositionRequest,,false,1088,1088,RedisModule_IsKeysPositionRequest,,,300,int RedisModule_IsKeysPositionRequest (RedisModuleCtx*)
315650,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_KeyAtPos)(RedisModuleCtx *ctx, int pos) REDISMODULE_ATTR;",22,74,redismodule.h,RedisModule_KeyAtPos,,false,1089,1089,RedisModule_KeyAtPos,,,301,"void RedisModule_KeyAtPos (RedisModuleCtx*,int)"
315656,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_KeyAtPosWithFlags)(RedisModuleCtx *ctx, int pos, int flags) REDISMODULE_ATTR;",22,94,redismodule.h,RedisModule_KeyAtPosWithFlags,,false,1090,1090,RedisModule_KeyAtPosWithFlags,,,302,"void RedisModule_KeyAtPosWithFlags (RedisModuleCtx*,int,int)"
315663,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_IsChannelsPositionRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,81,redismodule.h,RedisModule_IsChannelsPositionRequest,,false,1091,1091,RedisModule_IsChannelsPositionRequest,,,303,int RedisModule_IsChannelsPositionRequest (RedisModuleCtx*)
315668,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ChannelAtPosWithFlags)(RedisModuleCtx *ctx, int pos, int flags) REDISMODULE_ATTR;",22,98,redismodule.h,RedisModule_ChannelAtPosWithFlags,,false,1092,1092,RedisModule_ChannelAtPosWithFlags,,,304,"void RedisModule_ChannelAtPosWithFlags (RedisModuleCtx*,int,int)"
315675,METHOD,redismodule.h:<global>,TYPE_DECL,unsigned long long (*RedisModule_GetClientId)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,36,82,redismodule.h,RedisModule_GetClientId,,false,1093,1093,RedisModule_GetClientId,,,305,long long unsigned RedisModule_GetClientId (RedisModuleCtx*)
315680,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_GetClientUserNameById)(RedisModuleCtx *ctx, uint64_t id) REDISMODULE_ATTR;",35,106,redismodule.h,RedisModule_GetClientUserNameById,,false,1094,1094,RedisModule_GetClientUserNameById,,,306,"RedisModuleString* RedisModule_GetClientUserNameById (RedisModuleCtx*,uint64_t)"
315686,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_GetClientInfoById)(void *ci, uint64_t id) REDISMODULE_ATTR;",21,75,redismodule.h,RedisModule_GetClientInfoById,,false,1095,1095,RedisModule_GetClientInfoById,,,307,"int RedisModule_GetClientInfoById (void*,uint64_t)"
315692,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_GetClientNameById)(RedisModuleCtx *ctx, uint64_t id) REDISMODULE_ATTR;",35,102,redismodule.h,RedisModule_GetClientNameById,,false,1096,1096,RedisModule_GetClientNameById,,,308,"RedisModuleString* RedisModule_GetClientNameById (RedisModuleCtx*,uint64_t)"
315698,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetClientNameById)(uint64_t id, RedisModuleString *name) REDISMODULE_ATTR;",21,90,redismodule.h,RedisModule_SetClientNameById,,false,1097,1097,RedisModule_SetClientNameById,,,309,"int RedisModule_SetClientNameById (uint64_t,RedisModuleString*)"
315704,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_PublishMessage)(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) REDISMODULE_ATTR;",21,126,redismodule.h,RedisModule_PublishMessage,,false,1098,1098,RedisModule_PublishMessage,,,310,"int RedisModule_PublishMessage (RedisModuleCtx*,RedisModuleString*,RedisModuleString*)"
315711,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_PublishMessageShard)(RedisModuleCtx *ctx, RedisModuleString *channel, RedisModuleString *message) REDISMODULE_ATTR;",21,131,redismodule.h,RedisModule_PublishMessageShard,,false,1099,1099,RedisModule_PublishMessageShard,,,311,"int RedisModule_PublishMessageShard (RedisModuleCtx*,RedisModuleString*,RedisModuleString*)"
315718,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetContextFlags)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,71,redismodule.h,RedisModule_GetContextFlags,,false,1100,1100,RedisModule_GetContextFlags,,,312,int RedisModule_GetContextFlags (RedisModuleCtx*)
315723,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_AvoidReplicaTraffic)(void) REDISMODULE_ATTR;,21,60,redismodule.h,RedisModule_AvoidReplicaTraffic,,false,1101,1101,RedisModule_AvoidReplicaTraffic,,,313,int RedisModule_AvoidReplicaTraffic (void)
315728,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_PoolAlloc)(RedisModuleCtx *ctx, size_t bytes) REDISMODULE_ATTR;",22,82,redismodule.h,RedisModule_PoolAlloc,,false,1102,1102,RedisModule_PoolAlloc,,,314,"void* RedisModule_PoolAlloc (RedisModuleCtx*,size_t)"
315734,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleType * (*RedisModule_CreateDataType)(RedisModuleCtx *ctx, const char *name, int encver, RedisModuleTypeMethods *typemethods) REDISMODULE_ATTR;",33,151,redismodule.h,RedisModule_CreateDataType,,false,1103,1103,RedisModule_CreateDataType,,,315,"RedisModuleType* RedisModule_CreateDataType (RedisModuleCtx*,char*,int,RedisModuleTypeMethods*)"
315742,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ModuleTypeSetValue)(RedisModuleKey *key, RedisModuleType *mt, void *value) REDISMODULE_ATTR;",21,108,redismodule.h,RedisModule_ModuleTypeSetValue,,false,1104,1104,RedisModule_ModuleTypeSetValue,,,316,"int RedisModule_ModuleTypeSetValue (RedisModuleKey*,RedisModuleType*,void*)"
315749,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ModuleTypeReplaceValue)(RedisModuleKey *key, RedisModuleType *mt, void *new_value, void **old_value) REDISMODULE_ATTR;",21,134,redismodule.h,RedisModule_ModuleTypeReplaceValue,,false,1105,1105,RedisModule_ModuleTypeReplaceValue,,,317,"int RedisModule_ModuleTypeReplaceValue (RedisModuleKey*,RedisModuleType*,void*,void**)"
315757,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleType * (*RedisModule_ModuleTypeGetType)(RedisModuleKey *key) REDISMODULE_ATTR;,33,87,redismodule.h,RedisModule_ModuleTypeGetType,,false,1106,1106,RedisModule_ModuleTypeGetType,,,318,RedisModuleType* RedisModule_ModuleTypeGetType (RedisModuleKey*)
315762,METHOD,redismodule.h:<global>,TYPE_DECL,void * (*RedisModule_ModuleTypeGetValue)(RedisModuleKey *key) REDISMODULE_ATTR;,22,77,redismodule.h,RedisModule_ModuleTypeGetValue,,false,1107,1107,RedisModule_ModuleTypeGetValue,,,319,void* RedisModule_ModuleTypeGetValue (RedisModuleKey*)
315767,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_IsIOError)(RedisModuleIO *io) REDISMODULE_ATTR;,21,63,redismodule.h,RedisModule_IsIOError,,false,1108,1108,RedisModule_IsIOError,,,320,int RedisModule_IsIOError (RedisModuleIO*)
315772,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SetModuleOptions)(RedisModuleCtx *ctx, int options) REDISMODULE_ATTR;",22,86,redismodule.h,RedisModule_SetModuleOptions,,false,1109,1109,RedisModule_SetModuleOptions,,,321,"void RedisModule_SetModuleOptions (RedisModuleCtx*,int)"
315778,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SignalModifiedKey)(RedisModuleCtx *ctx, RedisModuleString *keyname) REDISMODULE_ATTR;",21,101,redismodule.h,RedisModule_SignalModifiedKey,,false,1110,1110,RedisModule_SignalModifiedKey,,,322,"int RedisModule_SignalModifiedKey (RedisModuleCtx*,RedisModuleString*)"
315784,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveUnsigned)(RedisModuleIO *io, uint64_t value) REDISMODULE_ATTR;",22,83,redismodule.h,RedisModule_SaveUnsigned,,false,1111,1111,RedisModule_SaveUnsigned,,,323,"void RedisModule_SaveUnsigned (RedisModuleIO*,uint64_t)"
315790,METHOD,redismodule.h:<global>,TYPE_DECL,uint64_t (*RedisModule_LoadUnsigned)(RedisModuleIO *io) REDISMODULE_ATTR;,26,71,redismodule.h,RedisModule_LoadUnsigned,,false,1112,1112,RedisModule_LoadUnsigned,,,324,uint64_t RedisModule_LoadUnsigned (RedisModuleIO*)
315795,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveSigned)(RedisModuleIO *io, int64_t value) REDISMODULE_ATTR;",22,80,redismodule.h,RedisModule_SaveSigned,,false,1113,1113,RedisModule_SaveSigned,,,325,"void RedisModule_SaveSigned (RedisModuleIO*,int64_t)"
315801,METHOD,redismodule.h:<global>,TYPE_DECL,int64_t (*RedisModule_LoadSigned)(RedisModuleIO *io) REDISMODULE_ATTR;,25,68,redismodule.h,RedisModule_LoadSigned,,false,1114,1114,RedisModule_LoadSigned,,,326,int64_t RedisModule_LoadSigned (RedisModuleIO*)
315806,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_EmitAOF)(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) REDISMODULE_ATTR;",22,105,redismodule.h,RedisModule_EmitAOF,,false,1115,1115,RedisModule_EmitAOF,,,327,"void RedisModule_EmitAOF (RedisModuleIO*,char*,char*...)"
315813,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveString)(RedisModuleIO *io, RedisModuleString *s) REDISMODULE_ATTR;",22,87,redismodule.h,RedisModule_SaveString,,false,1116,1116,RedisModule_SaveString,,,328,"void RedisModule_SaveString (RedisModuleIO*,RedisModuleString*)"
315819,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveStringBuffer)(RedisModuleIO *io, const char *str, size_t len) REDISMODULE_ATTR;",22,100,redismodule.h,RedisModule_SaveStringBuffer,,false,1117,1117,RedisModule_SaveStringBuffer,,,329,"void RedisModule_SaveStringBuffer (RedisModuleIO*,char*,size_t)"
315826,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleString * (*RedisModule_LoadString)(RedisModuleIO *io) REDISMODULE_ATTR;,35,80,redismodule.h,RedisModule_LoadString,,false,1118,1118,RedisModule_LoadString,,,330,RedisModuleString* RedisModule_LoadString (RedisModuleIO*)
315831,METHOD,redismodule.h:<global>,TYPE_DECL,"char * (*RedisModule_LoadStringBuffer)(RedisModuleIO *io, size_t *lenptr) REDISMODULE_ATTR;",22,89,redismodule.h,RedisModule_LoadStringBuffer,,false,1119,1119,RedisModule_LoadStringBuffer,,,331,"char* RedisModule_LoadStringBuffer (RedisModuleIO*,size_t*)"
315837,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveDouble)(RedisModuleIO *io, double value) REDISMODULE_ATTR;",22,79,redismodule.h,RedisModule_SaveDouble,,false,1120,1120,RedisModule_SaveDouble,,,332,"void RedisModule_SaveDouble (RedisModuleIO*,double)"
315843,METHOD,redismodule.h:<global>,TYPE_DECL,double (*RedisModule_LoadDouble)(RedisModuleIO *io) REDISMODULE_ATTR;,24,67,redismodule.h,RedisModule_LoadDouble,,false,1121,1121,RedisModule_LoadDouble,,,333,double RedisModule_LoadDouble (RedisModuleIO*)
315848,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveFloat)(RedisModuleIO *io, float value) REDISMODULE_ATTR;",22,77,redismodule.h,RedisModule_SaveFloat,,false,1122,1122,RedisModule_SaveFloat,,,334,"void RedisModule_SaveFloat (RedisModuleIO*,float)"
315854,METHOD,redismodule.h:<global>,TYPE_DECL,float (*RedisModule_LoadFloat)(RedisModuleIO *io) REDISMODULE_ATTR;,23,65,redismodule.h,RedisModule_LoadFloat,,false,1123,1123,RedisModule_LoadFloat,,,335,float RedisModule_LoadFloat (RedisModuleIO*)
315859,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SaveLongDouble)(RedisModuleIO *io, long double value) REDISMODULE_ATTR;",22,88,redismodule.h,RedisModule_SaveLongDouble,,false,1124,1124,RedisModule_SaveLongDouble,,,336,"void RedisModule_SaveLongDouble (RedisModuleIO*,long double)"
315865,METHOD,redismodule.h:<global>,TYPE_DECL,long double (*RedisModule_LoadLongDouble)(RedisModuleIO *io) REDISMODULE_ATTR;,29,76,redismodule.h,RedisModule_LoadLongDouble,,false,1125,1125,RedisModule_LoadLongDouble,,,337,long double RedisModule_LoadLongDouble (RedisModuleIO*)
315870,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_LoadDataTypeFromString)(const RedisModuleString *str, const RedisModuleType *mt) REDISMODULE_ATTR;",22,117,redismodule.h,RedisModule_LoadDataTypeFromString,,false,1126,1126,RedisModule_LoadDataTypeFromString,,,338,"void* RedisModule_LoadDataTypeFromString (RedisModuleString*,RedisModuleType*)"
315876,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_LoadDataTypeFromStringEncver)(const RedisModuleString *str, const RedisModuleType *mt, int encver) REDISMODULE_ATTR;",22,135,redismodule.h,RedisModule_LoadDataTypeFromStringEncver,,false,1127,1127,RedisModule_LoadDataTypeFromStringEncver,,,339,"void* RedisModule_LoadDataTypeFromStringEncver (RedisModuleString*,RedisModuleType*,int)"
315883,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_SaveDataTypeToString)(RedisModuleCtx *ctx, void *data, const RedisModuleType *mt) REDISMODULE_ATTR;",35,131,redismodule.h,RedisModule_SaveDataTypeToString,,false,1128,1128,RedisModule_SaveDataTypeToString,,,340,"RedisModuleString* RedisModule_SaveDataTypeToString (RedisModuleCtx*,void*,RedisModuleType*)"
315890,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_Log)(RedisModuleCtx *ctx, const char *level, const char *fmt, ...) REDISMODULE_ATTR REDISMODULE_ATTR_PRINTF(3,4);",22,101,redismodule.h,RedisModule_Log,,false,1129,1129,RedisModule_Log,,,341,"void RedisModule_Log (RedisModuleCtx*,char*,char*...)"
315897,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_LogIOError)(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) REDISMODULE_ATTR REDISMODULE_ATTR_PRINTF(3,4);",22,109,redismodule.h,RedisModule_LogIOError,,false,1130,1130,RedisModule_LogIOError,,,342,"void RedisModule_LogIOError (RedisModuleIO*,char*,char*...)"
315904,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule__Assert)(const char *estr, const char *file, int line) REDISMODULE_ATTR;",22,89,redismodule.h,RedisModule__Assert,,false,1131,1131,RedisModule__Assert,,,343,"void RedisModule__Assert (char*,char*,int)"
315911,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_LatencyAddSample)(const char *event, mstime_t latency) REDISMODULE_ATTR;",22,89,redismodule.h,RedisModule_LatencyAddSample,,false,1132,1132,RedisModule_LatencyAddSample,,,344,"void RedisModule_LatencyAddSample (char*,mstime_t)"
315917,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringAppendBuffer)(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) REDISMODULE_ATTR;",21,127,redismodule.h,RedisModule_StringAppendBuffer,,false,1133,1133,RedisModule_StringAppendBuffer,,,345,"int RedisModule_StringAppendBuffer (RedisModuleCtx*,RedisModuleString*,char*,size_t)"
315925,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_TrimStringAllocation)(RedisModuleString *str) REDISMODULE_ATTR;,22,80,redismodule.h,RedisModule_TrimStringAllocation,,false,1134,1134,RedisModule_TrimStringAllocation,,,346,void RedisModule_TrimStringAllocation (RedisModuleString*)
315930,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_RetainString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",22,93,redismodule.h,RedisModule_RetainString,,false,1135,1135,RedisModule_RetainString,,,347,"void RedisModule_RetainString (RedisModuleCtx*,RedisModuleString*)"
315936,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_HoldString)(RedisModuleCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",35,106,redismodule.h,RedisModule_HoldString,,false,1136,1136,RedisModule_HoldString,,,348,"RedisModuleString* RedisModule_HoldString (RedisModuleCtx*,RedisModuleString*)"
315942,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StringCompare)(const RedisModuleString *a, const RedisModuleString *b) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_StringCompare,,false,1137,1137,RedisModule_StringCompare,,,349,"int RedisModule_StringCompare (RedisModuleString*,RedisModuleString*)"
315948,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleCtx * (*RedisModule_GetContextFromIO)(RedisModuleIO *io) REDISMODULE_ATTR;,32,83,redismodule.h,RedisModule_GetContextFromIO,,false,1138,1138,RedisModule_GetContextFromIO,,,350,RedisModuleCtx* RedisModule_GetContextFromIO (RedisModuleIO*)
315953,METHOD,redismodule.h:<global>,TYPE_DECL,const RedisModuleString * (*RedisModule_GetKeyNameFromIO)(RedisModuleIO *io) REDISMODULE_ATTR;,41,92,redismodule.h,RedisModule_GetKeyNameFromIO,,false,1139,1139,RedisModule_GetKeyNameFromIO,,,351,RedisModuleString* RedisModule_GetKeyNameFromIO (RedisModuleIO*)
315958,METHOD,redismodule.h:<global>,TYPE_DECL,const RedisModuleString * (*RedisModule_GetKeyNameFromModuleKey)(RedisModuleKey *key) REDISMODULE_ATTR;,41,101,redismodule.h,RedisModule_GetKeyNameFromModuleKey,,false,1140,1140,RedisModule_GetKeyNameFromModuleKey,,,352,RedisModuleString* RedisModule_GetKeyNameFromModuleKey (RedisModuleKey*)
315963,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetDbIdFromModuleKey)(RedisModuleKey *key) REDISMODULE_ATTR;,21,76,redismodule.h,RedisModule_GetDbIdFromModuleKey,,false,1141,1141,RedisModule_GetDbIdFromModuleKey,,,353,int RedisModule_GetDbIdFromModuleKey (RedisModuleKey*)
315968,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetDbIdFromIO)(RedisModuleIO *io) REDISMODULE_ATTR;,21,67,redismodule.h,RedisModule_GetDbIdFromIO,,false,1142,1142,RedisModule_GetDbIdFromIO,,,354,int RedisModule_GetDbIdFromIO (RedisModuleIO*)
315973,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetDbIdFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,21,79,redismodule.h,RedisModule_GetDbIdFromOptCtx,,false,1143,1143,RedisModule_GetDbIdFromOptCtx,,,355,int RedisModule_GetDbIdFromOptCtx (RedisModuleKeyOptCtx*)
315978,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetToDbIdFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,21,81,redismodule.h,RedisModule_GetToDbIdFromOptCtx,,false,1144,1144,RedisModule_GetToDbIdFromOptCtx,,,356,int RedisModule_GetToDbIdFromOptCtx (RedisModuleKeyOptCtx*)
315983,METHOD,redismodule.h:<global>,TYPE_DECL,const RedisModuleString * (*RedisModule_GetKeyNameFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,41,104,redismodule.h,RedisModule_GetKeyNameFromOptCtx,,false,1145,1145,RedisModule_GetKeyNameFromOptCtx,,,357,RedisModuleString* RedisModule_GetKeyNameFromOptCtx (RedisModuleKeyOptCtx*)
315988,METHOD,redismodule.h:<global>,TYPE_DECL,const RedisModuleString * (*RedisModule_GetToKeyNameFromOptCtx)(RedisModuleKeyOptCtx *ctx) REDISMODULE_ATTR;,41,106,redismodule.h,RedisModule_GetToKeyNameFromOptCtx,,false,1146,1146,RedisModule_GetToKeyNameFromOptCtx,,,358,RedisModuleString* RedisModule_GetToKeyNameFromOptCtx (RedisModuleKeyOptCtx*)
315993,METHOD,redismodule.h:<global>,TYPE_DECL,mstime_t (*RedisModule_Milliseconds)(void) REDISMODULE_ATTR;,26,58,redismodule.h,RedisModule_Milliseconds,,false,1147,1147,RedisModule_Milliseconds,,,359,mstime_t RedisModule_Milliseconds (void)
315998,METHOD,redismodule.h:<global>,TYPE_DECL,uint64_t (*RedisModule_MonotonicMicroseconds)(void) REDISMODULE_ATTR;,26,67,redismodule.h,RedisModule_MonotonicMicroseconds,,false,1148,1148,RedisModule_MonotonicMicroseconds,,,360,uint64_t RedisModule_MonotonicMicroseconds (void)
316003,METHOD,redismodule.h:<global>,TYPE_DECL,ustime_t (*RedisModule_Microseconds)(void) REDISMODULE_ATTR;,26,58,redismodule.h,RedisModule_Microseconds,,false,1149,1149,RedisModule_Microseconds,,,361,ustime_t RedisModule_Microseconds (void)
316008,METHOD,redismodule.h:<global>,TYPE_DECL,ustime_t (*RedisModule_CachedMicroseconds)(void) REDISMODULE_ATTR;,26,64,redismodule.h,RedisModule_CachedMicroseconds,,false,1150,1150,RedisModule_CachedMicroseconds,,,362,ustime_t RedisModule_CachedMicroseconds (void)
316013,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_DigestAddStringBuffer)(RedisModuleDigest *md, const char *ele, size_t len) REDISMODULE_ATTR;",22,109,redismodule.h,RedisModule_DigestAddStringBuffer,,false,1151,1151,RedisModule_DigestAddStringBuffer,,,363,"void RedisModule_DigestAddStringBuffer (RedisModuleDigest*,char*,size_t)"
316020,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_DigestAddLongLong)(RedisModuleDigest *md, long long ele) REDISMODULE_ATTR;",22,91,redismodule.h,RedisModule_DigestAddLongLong,,false,1152,1152,RedisModule_DigestAddLongLong,,,364,"void RedisModule_DigestAddLongLong (RedisModuleDigest*,long long)"
316026,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_DigestEndSequence)(RedisModuleDigest *md) REDISMODULE_ATTR;,22,76,redismodule.h,RedisModule_DigestEndSequence,,false,1153,1153,RedisModule_DigestEndSequence,,,365,void RedisModule_DigestEndSequence (RedisModuleDigest*)
316031,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetDbIdFromDigest)(RedisModuleDigest *dig) REDISMODULE_ATTR;,21,76,redismodule.h,RedisModule_GetDbIdFromDigest,,false,1154,1154,RedisModule_GetDbIdFromDigest,,,366,int RedisModule_GetDbIdFromDigest (RedisModuleDigest*)
316036,METHOD,redismodule.h:<global>,TYPE_DECL,const RedisModuleString * (*RedisModule_GetKeyNameFromDigest)(RedisModuleDigest *dig) REDISMODULE_ATTR;,41,101,redismodule.h,RedisModule_GetKeyNameFromDigest,,false,1155,1155,RedisModule_GetKeyNameFromDigest,,,367,RedisModuleString* RedisModule_GetKeyNameFromDigest (RedisModuleDigest*)
316041,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleDict * (*RedisModule_CreateDict)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,33,80,redismodule.h,RedisModule_CreateDict,,false,1156,1156,RedisModule_CreateDict,,,368,RedisModuleDict* RedisModule_CreateDict (RedisModuleCtx*)
316046,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_FreeDict)(RedisModuleCtx *ctx, RedisModuleDict *d) REDISMODULE_ATTR;",22,85,redismodule.h,RedisModule_FreeDict,,false,1157,1157,RedisModule_FreeDict,,,369,"void RedisModule_FreeDict (RedisModuleCtx*,RedisModuleDict*)"
316052,METHOD,redismodule.h:<global>,TYPE_DECL,uint64_t (*RedisModule_DictSize)(RedisModuleDict *d) REDISMODULE_ATTR;,26,68,redismodule.h,RedisModule_DictSize,,false,1158,1158,RedisModule_DictSize,,,370,uint64_t RedisModule_DictSize (RedisModuleDict*)
316057,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictSetC)(RedisModuleDict *d, void *key, size_t keylen, void *ptr) REDISMODULE_ATTR;",21,100,redismodule.h,RedisModule_DictSetC,,false,1159,1159,RedisModule_DictSetC,,,371,"int RedisModule_DictSetC (RedisModuleDict*,void*,size_t,void*)"
316065,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictReplaceC)(RedisModuleDict *d, void *key, size_t keylen, void *ptr) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_DictReplaceC,,false,1160,1160,RedisModule_DictReplaceC,,,372,"int RedisModule_DictReplaceC (RedisModuleDict*,void*,size_t,void*)"
316073,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictSet)(RedisModuleDict *d, RedisModuleString *key, void *ptr) REDISMODULE_ATTR;",21,97,redismodule.h,RedisModule_DictSet,,false,1161,1161,RedisModule_DictSet,,,373,"int RedisModule_DictSet (RedisModuleDict*,RedisModuleString*,void*)"
316080,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictReplace)(RedisModuleDict *d, RedisModuleString *key, void *ptr) REDISMODULE_ATTR;",21,101,redismodule.h,RedisModule_DictReplace,,false,1162,1162,RedisModule_DictReplace,,,374,"int RedisModule_DictReplace (RedisModuleDict*,RedisModuleString*,void*)"
316087,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_DictGetC)(RedisModuleDict *d, void *key, size_t keylen, int *nokey) REDISMODULE_ATTR;",22,104,redismodule.h,RedisModule_DictGetC,,false,1163,1163,RedisModule_DictGetC,,,375,"void* RedisModule_DictGetC (RedisModuleDict*,void*,size_t,int*)"
316095,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_DictGet)(RedisModuleDict *d, RedisModuleString *key, int *nokey) REDISMODULE_ATTR;",22,101,redismodule.h,RedisModule_DictGet,,false,1164,1164,RedisModule_DictGet,,,376,"void* RedisModule_DictGet (RedisModuleDict*,RedisModuleString*,int*)"
316102,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictDelC)(RedisModuleDict *d, void *key, size_t keylen, void *oldval) REDISMODULE_ATTR;",21,103,redismodule.h,RedisModule_DictDelC,,false,1165,1165,RedisModule_DictDelC,,,377,"int RedisModule_DictDelC (RedisModuleDict*,void*,size_t,void*)"
316110,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictDel)(RedisModuleDict *d, RedisModuleString *key, void *oldval) REDISMODULE_ATTR;",21,100,redismodule.h,RedisModule_DictDel,,false,1166,1166,RedisModule_DictDel,,,378,"int RedisModule_DictDel (RedisModuleDict*,RedisModuleString*,void*)"
316117,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleDictIter * (*RedisModule_DictIteratorStartC)(RedisModuleDict *d, const char *op, void *key, size_t keylen) REDISMODULE_ATTR;",37,133,redismodule.h,RedisModule_DictIteratorStartC,,false,1167,1167,RedisModule_DictIteratorStartC,,,379,"RedisModuleDictIter* RedisModule_DictIteratorStartC (RedisModuleDict*,char*,void*,size_t)"
316125,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleDictIter * (*RedisModule_DictIteratorStart)(RedisModuleDict *d, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",37,130,redismodule.h,RedisModule_DictIteratorStart,,false,1168,1168,RedisModule_DictIteratorStart,,,380,"RedisModuleDictIter* RedisModule_DictIteratorStart (RedisModuleDict*,char*,RedisModuleString*)"
316132,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_DictIteratorStop)(RedisModuleDictIter *di) REDISMODULE_ATTR;,22,77,redismodule.h,RedisModule_DictIteratorStop,,false,1169,1169,RedisModule_DictIteratorStop,,,381,void RedisModule_DictIteratorStop (RedisModuleDictIter*)
316137,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictIteratorReseekC)(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) REDISMODULE_ATTR;",21,121,redismodule.h,RedisModule_DictIteratorReseekC,,false,1170,1170,RedisModule_DictIteratorReseekC,,,382,"int RedisModule_DictIteratorReseekC (RedisModuleDictIter*,char*,void*,size_t)"
316145,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictIteratorReseek)(RedisModuleDictIter *di, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",21,118,redismodule.h,RedisModule_DictIteratorReseek,,false,1171,1171,RedisModule_DictIteratorReseek,,,383,"int RedisModule_DictIteratorReseek (RedisModuleDictIter*,char*,RedisModuleString*)"
316152,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_DictNextC)(RedisModuleDictIter *di, size_t *keylen, void **dataptr) REDISMODULE_ATTR;",22,104,redismodule.h,RedisModule_DictNextC,,false,1172,1172,RedisModule_DictNextC,,,384,"void* RedisModule_DictNextC (RedisModuleDictIter*,size_t*,void**)"
316159,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_DictPrevC)(RedisModuleDictIter *di, size_t *keylen, void **dataptr) REDISMODULE_ATTR;",22,104,redismodule.h,RedisModule_DictPrevC,,false,1173,1173,RedisModule_DictPrevC,,,385,"void* RedisModule_DictPrevC (RedisModuleDictIter*,size_t*,void**)"
316166,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_DictNext)(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) REDISMODULE_ATTR;",35,121,redismodule.h,RedisModule_DictNext,,false,1174,1174,RedisModule_DictNext,,,386,"RedisModuleString* RedisModule_DictNext (RedisModuleCtx*,RedisModuleDictIter*,void**)"
316173,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_DictPrev)(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) REDISMODULE_ATTR;",35,121,redismodule.h,RedisModule_DictPrev,,false,1175,1175,RedisModule_DictPrev,,,387,"RedisModuleString* RedisModule_DictPrev (RedisModuleCtx*,RedisModuleDictIter*,void**)"
316180,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictCompareC)(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) REDISMODULE_ATTR;",21,114,redismodule.h,RedisModule_DictCompareC,,false,1176,1176,RedisModule_DictCompareC,,,388,"int RedisModule_DictCompareC (RedisModuleDictIter*,char*,void*,size_t)"
316188,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DictCompare)(RedisModuleDictIter *di, const char *op, RedisModuleString *key) REDISMODULE_ATTR;",21,111,redismodule.h,RedisModule_DictCompare,,false,1177,1177,RedisModule_DictCompare,,,389,"int RedisModule_DictCompare (RedisModuleDictIter*,char*,RedisModuleString*)"
316195,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RegisterInfoFunc)(RedisModuleCtx *ctx, RedisModuleInfoFunc cb) REDISMODULE_ATTR;",21,96,redismodule.h,RedisModule_RegisterInfoFunc,,false,1178,1178,RedisModule_RegisterInfoFunc,,,390,"int RedisModule_RegisterInfoFunc (RedisModuleCtx*,RedisModuleInfoFunc)"
316201,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_RegisterAuthCallback)(RedisModuleCtx *ctx, RedisModuleAuthCallback cb) REDISMODULE_ATTR;",22,105,redismodule.h,RedisModule_RegisterAuthCallback,,false,1179,1179,RedisModule_RegisterAuthCallback,,,391,"void RedisModule_RegisterAuthCallback (RedisModuleCtx*,RedisModuleAuthCallback)"
316207,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoAddSection)(RedisModuleInfoCtx *ctx, const char *name) REDISMODULE_ATTR;",21,92,redismodule.h,RedisModule_InfoAddSection,,false,1180,1180,RedisModule_InfoAddSection,,,392,"int RedisModule_InfoAddSection (RedisModuleInfoCtx*,char*)"
316213,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoBeginDictField)(RedisModuleInfoCtx *ctx, const char *name) REDISMODULE_ATTR;",21,96,redismodule.h,RedisModule_InfoBeginDictField,,false,1181,1181,RedisModule_InfoBeginDictField,,,393,"int RedisModule_InfoBeginDictField (RedisModuleInfoCtx*,char*)"
316219,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_InfoEndDictField)(RedisModuleInfoCtx *ctx) REDISMODULE_ATTR;,21,76,redismodule.h,RedisModule_InfoEndDictField,,false,1182,1182,RedisModule_InfoEndDictField,,,394,int RedisModule_InfoEndDictField (RedisModuleInfoCtx*)
316224,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoAddFieldString)(RedisModuleInfoCtx *ctx, const char *field, RedisModuleString *value) REDISMODULE_ATTR;",21,123,redismodule.h,RedisModule_InfoAddFieldString,,false,1183,1183,RedisModule_InfoAddFieldString,,,395,"int RedisModule_InfoAddFieldString (RedisModuleInfoCtx*,char*,RedisModuleString*)"
316231,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoAddFieldCString)(RedisModuleInfoCtx *ctx, const char *field,const  char *value) REDISMODULE_ATTR;",21,117,redismodule.h,RedisModule_InfoAddFieldCString,,false,1184,1184,RedisModule_InfoAddFieldCString,,,396,"int RedisModule_InfoAddFieldCString (RedisModuleInfoCtx*,char*,char*)"
316238,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoAddFieldDouble)(RedisModuleInfoCtx *ctx, const char *field, double value) REDISMODULE_ATTR;",21,111,redismodule.h,RedisModule_InfoAddFieldDouble,,false,1185,1185,RedisModule_InfoAddFieldDouble,,,397,"int RedisModule_InfoAddFieldDouble (RedisModuleInfoCtx*,char*,double)"
316245,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoAddFieldLongLong)(RedisModuleInfoCtx *ctx, const char *field, long long value) REDISMODULE_ATTR;",21,116,redismodule.h,RedisModule_InfoAddFieldLongLong,,false,1186,1186,RedisModule_InfoAddFieldLongLong,,,398,"int RedisModule_InfoAddFieldLongLong (RedisModuleInfoCtx*,char*,long long)"
316252,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_InfoAddFieldULongLong)(RedisModuleInfoCtx *ctx, const char *field, unsigned long long value) REDISMODULE_ATTR;",21,126,redismodule.h,RedisModule_InfoAddFieldULongLong,,false,1187,1187,RedisModule_InfoAddFieldULongLong,,,399,"int RedisModule_InfoAddFieldULongLong (RedisModuleInfoCtx*,char*,long long unsigned)"
316259,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleServerInfoData * (*RedisModule_GetServerInfo)(RedisModuleCtx *ctx, const char *section) REDISMODULE_ATTR;",43,114,redismodule.h,RedisModule_GetServerInfo,,false,1188,1188,RedisModule_GetServerInfo,,,400,"RedisModuleServerInfoData* RedisModule_GetServerInfo (RedisModuleCtx*,char*)"
316265,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_FreeServerInfo)(RedisModuleCtx *ctx, RedisModuleServerInfoData *data) REDISMODULE_ATTR;",22,104,redismodule.h,RedisModule_FreeServerInfo,,false,1189,1189,RedisModule_FreeServerInfo,,,401,"void RedisModule_FreeServerInfo (RedisModuleCtx*,RedisModuleServerInfoData*)"
316271,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_ServerInfoGetField)(RedisModuleCtx *ctx, RedisModuleServerInfoData *data, const char* field) REDISMODULE_ATTR;",35,142,redismodule.h,RedisModule_ServerInfoGetField,,false,1190,1190,RedisModule_ServerInfoGetField,,,402,"RedisModuleString* RedisModule_ServerInfoGetField (RedisModuleCtx*,RedisModuleServerInfoData*,char*)"
316278,METHOD,redismodule.h:<global>,TYPE_DECL,"const char * (*RedisModule_ServerInfoGetFieldC)(RedisModuleServerInfoData *data, const char* field) REDISMODULE_ATTR;",28,115,redismodule.h,RedisModule_ServerInfoGetFieldC,,false,1191,1191,RedisModule_ServerInfoGetFieldC,,,403,"char* RedisModule_ServerInfoGetFieldC (RedisModuleServerInfoData*,char*)"
316284,METHOD,redismodule.h:<global>,TYPE_DECL,"long long (*RedisModule_ServerInfoGetFieldSigned)(RedisModuleServerInfoData *data, const char* field, int *out_err) REDISMODULE_ATTR;",27,131,redismodule.h,RedisModule_ServerInfoGetFieldSigned,,false,1192,1192,RedisModule_ServerInfoGetFieldSigned,,,404,"long long RedisModule_ServerInfoGetFieldSigned (RedisModuleServerInfoData*,char*,int*)"
316291,METHOD,redismodule.h:<global>,TYPE_DECL,"unsigned long long (*RedisModule_ServerInfoGetFieldUnsigned)(RedisModuleServerInfoData *data, const char* field, int *out_err) REDISMODULE_ATTR;",36,142,redismodule.h,RedisModule_ServerInfoGetFieldUnsigned,,false,1193,1193,RedisModule_ServerInfoGetFieldUnsigned,,,405,"long long unsigned RedisModule_ServerInfoGetFieldUnsigned (RedisModuleServerInfoData*,char*,int*)"
316298,METHOD,redismodule.h:<global>,TYPE_DECL,"double (*RedisModule_ServerInfoGetFieldDouble)(RedisModuleServerInfoData *data, const char* field, int *out_err) REDISMODULE_ATTR;",24,128,redismodule.h,RedisModule_ServerInfoGetFieldDouble,,false,1194,1194,RedisModule_ServerInfoGetFieldDouble,,,406,"double RedisModule_ServerInfoGetFieldDouble (RedisModuleServerInfoData*,char*,int*)"
316305,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SubscribeToServerEvent)(RedisModuleCtx *ctx, RedisModuleEvent event, RedisModuleEventCallback callback) REDISMODULE_ATTR;",21,137,redismodule.h,RedisModule_SubscribeToServerEvent,,false,1195,1195,RedisModule_SubscribeToServerEvent,,,407,"int RedisModule_SubscribeToServerEvent (RedisModuleCtx*,RedisModuleEvent,RedisModuleEventCallback)"
316312,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetLRU)(RedisModuleKey *key, mstime_t lru_idle) REDISMODULE_ATTR;",21,81,redismodule.h,RedisModule_SetLRU,,false,1196,1196,RedisModule_SetLRU,,,408,"int RedisModule_SetLRU (RedisModuleKey*,mstime_t)"
316318,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_GetLRU)(RedisModuleKey *key, mstime_t *lru_idle) REDISMODULE_ATTR;",21,82,redismodule.h,RedisModule_GetLRU,,false,1197,1197,RedisModule_GetLRU,,,409,"int RedisModule_GetLRU (RedisModuleKey*,mstime_t*)"
316324,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetLFU)(RedisModuleKey *key, long long lfu_freq) REDISMODULE_ATTR;",21,82,redismodule.h,RedisModule_SetLFU,,false,1198,1198,RedisModule_SetLFU,,,410,"int RedisModule_SetLFU (RedisModuleKey*,long long)"
316330,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_GetLFU)(RedisModuleKey *key, long long *lfu_freq) REDISMODULE_ATTR;",21,83,redismodule.h,RedisModule_GetLFU,,false,1199,1199,RedisModule_GetLFU,,,411,"int RedisModule_GetLFU (RedisModuleKey*,long long*)"
316336,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnKeys)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata) REDISMODULE_ATTR;",42,291,redismodule.h,RedisModule_BlockClientOnKeys,,false,1200,1200,RedisModule_BlockClientOnKeys,,,412,"RedisModuleBlockedClient* RedisModule_BlockClientOnKeys (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,RedisModuleString**,int,void*)"
316348,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnKeysWithFlags)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms, RedisModuleString **keys, int numkeys, void *privdata, int flags) REDISMODULE_ATTR;",42,311,redismodule.h,RedisModule_BlockClientOnKeysWithFlags,,false,1201,1201,RedisModule_BlockClientOnKeysWithFlags,,,413,"RedisModuleBlockedClient* RedisModule_BlockClientOnKeysWithFlags (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long,RedisModuleString**,int,void*,int)"
316361,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SignalKeyAsReady)(RedisModuleCtx *ctx, RedisModuleString *key) REDISMODULE_ATTR;",22,97,redismodule.h,RedisModule_SignalKeyAsReady,,false,1202,1202,RedisModule_SignalKeyAsReady,,,414,"void RedisModule_SignalKeyAsReady (RedisModuleCtx*,RedisModuleString*)"
316367,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleString * (*RedisModule_GetBlockedClientReadyKey)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,35,96,redismodule.h,RedisModule_GetBlockedClientReadyKey,,false,1203,1203,RedisModule_GetBlockedClientReadyKey,,,415,RedisModuleString* RedisModule_GetBlockedClientReadyKey (RedisModuleCtx*)
316372,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleScanCursor * (*RedisModule_ScanCursorCreate)(void) REDISMODULE_ATTR;,39,77,redismodule.h,RedisModule_ScanCursorCreate,,false,1204,1204,RedisModule_ScanCursorCreate,,,416,RedisModuleScanCursor* RedisModule_ScanCursorCreate (void)
316377,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_ScanCursorRestart)(RedisModuleScanCursor *cursor) REDISMODULE_ATTR;,22,84,redismodule.h,RedisModule_ScanCursorRestart,,false,1205,1205,RedisModule_ScanCursorRestart,,,417,void RedisModule_ScanCursorRestart (RedisModuleScanCursor*)
316382,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_ScanCursorDestroy)(RedisModuleScanCursor *cursor) REDISMODULE_ATTR;,22,84,redismodule.h,RedisModule_ScanCursorDestroy,,false,1206,1206,RedisModule_ScanCursorDestroy,,,418,void RedisModule_ScanCursorDestroy (RedisModuleScanCursor*)
316387,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_Scan)(RedisModuleCtx *ctx, RedisModuleScanCursor *cursor, RedisModuleScanCB fn, void *privdata) REDISMODULE_ATTR;",21,129,redismodule.h,RedisModule_Scan,,false,1207,1207,RedisModule_Scan,,,419,"int RedisModule_Scan (RedisModuleCtx*,RedisModuleScanCursor*,RedisModuleScanCB,void*)"
316395,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ScanKey)(RedisModuleKey *key, RedisModuleScanCursor *cursor, RedisModuleScanKeyCB fn, void *privdata) REDISMODULE_ATTR;",21,135,redismodule.h,RedisModule_ScanKey,,false,1208,1208,RedisModule_ScanKey,,,420,"int RedisModule_ScanKey (RedisModuleKey*,RedisModuleScanCursor*,RedisModuleScanKeyCB,void*)"
316403,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetContextFlagsAll)(void) REDISMODULE_ATTR;,21,59,redismodule.h,RedisModule_GetContextFlagsAll,,false,1209,1209,RedisModule_GetContextFlagsAll,,,421,int RedisModule_GetContextFlagsAll (void)
316408,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetModuleOptionsAll)(void) REDISMODULE_ATTR;,21,60,redismodule.h,RedisModule_GetModuleOptionsAll,,false,1210,1210,RedisModule_GetModuleOptionsAll,,,422,int RedisModule_GetModuleOptionsAll (void)
316413,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetKeyspaceNotificationFlagsAll)(void) REDISMODULE_ATTR;,21,72,redismodule.h,RedisModule_GetKeyspaceNotificationFlagsAll,,false,1211,1211,RedisModule_GetKeyspaceNotificationFlagsAll,,,423,int RedisModule_GetKeyspaceNotificationFlagsAll (void)
316418,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_IsSubEventSupported)(RedisModuleEvent event, uint64_t subevent) REDISMODULE_ATTR;",21,97,redismodule.h,RedisModule_IsSubEventSupported,,false,1212,1212,RedisModule_IsSubEventSupported,,,424,"int RedisModule_IsSubEventSupported (RedisModuleEvent,uint64_t)"
316424,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetServerVersion)(void) REDISMODULE_ATTR;,21,57,redismodule.h,RedisModule_GetServerVersion,,false,1213,1213,RedisModule_GetServerVersion,,,425,int RedisModule_GetServerVersion (void)
316429,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetTypeMethodVersion)(void) REDISMODULE_ATTR;,21,61,redismodule.h,RedisModule_GetTypeMethodVersion,,false,1214,1214,RedisModule_GetTypeMethodVersion,,,426,int RedisModule_GetTypeMethodVersion (void)
316434,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_Yield)(RedisModuleCtx *ctx, int flags, const char *busy_reply) REDISMODULE_ATTR;",22,97,redismodule.h,RedisModule_Yield,,false,1215,1215,RedisModule_Yield,,,427,"void RedisModule_Yield (RedisModuleCtx*,int,char*)"
316441,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleBlockedClient * (*RedisModule_BlockClient)(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) REDISMODULE_ATTR;",42,230,redismodule.h,RedisModule_BlockClient,,false,1216,1216,RedisModule_BlockClient,,,428,"RedisModuleBlockedClient* RedisModule_BlockClient (RedisModuleCtx*,RedisModuleCmdFunc,RedisModuleCmdFunc,void,long long)"
316450,METHOD,redismodule.h:<global>,TYPE_DECL,void * (*RedisModule_BlockClientGetPrivateData)(RedisModuleBlockedClient *blocked_client) REDISMODULE_ATTR;,22,105,redismodule.h,RedisModule_BlockClientGetPrivateData,,false,1217,1217,RedisModule_BlockClientGetPrivateData,,,429,void* RedisModule_BlockClientGetPrivateData (RedisModuleBlockedClient*)
316455,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_BlockClientSetPrivateData)(RedisModuleBlockedClient *blocked_client, void *private_data) REDISMODULE_ATTR;",22,123,redismodule.h,RedisModule_BlockClientSetPrivateData,,false,1218,1218,RedisModule_BlockClientSetPrivateData,,,430,"void RedisModule_BlockClientSetPrivateData (RedisModuleBlockedClient*,void*)"
316461,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleBlockedClient * (*RedisModule_BlockClientOnAuth)(RedisModuleCtx *ctx, RedisModuleAuthCallback reply_callback, void (*free_privdata)(RedisModuleCtx*,void*)) REDISMODULE_ATTR;",42,182,redismodule.h,RedisModule_BlockClientOnAuth,,false,1219,1219,RedisModule_BlockClientOnAuth,,,431,"RedisModuleBlockedClient* RedisModule_BlockClientOnAuth (RedisModuleCtx*,RedisModuleAuthCallback,void)"
316468,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_UnblockClient)(RedisModuleBlockedClient *bc, void *privdata) REDISMODULE_ATTR;",21,94,redismodule.h,RedisModule_UnblockClient,,false,1220,1220,RedisModule_UnblockClient,,,432,"int RedisModule_UnblockClient (RedisModuleBlockedClient*,void*)"
316474,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_IsBlockedReplyRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,77,redismodule.h,RedisModule_IsBlockedReplyRequest,,false,1221,1221,RedisModule_IsBlockedReplyRequest,,,433,int RedisModule_IsBlockedReplyRequest (RedisModuleCtx*)
316479,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_IsBlockedTimeoutRequest)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,79,redismodule.h,RedisModule_IsBlockedTimeoutRequest,,false,1222,1222,RedisModule_IsBlockedTimeoutRequest,,,434,int RedisModule_IsBlockedTimeoutRequest (RedisModuleCtx*)
316484,METHOD,redismodule.h:<global>,TYPE_DECL,void * (*RedisModule_GetBlockedClientPrivateData)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,22,86,redismodule.h,RedisModule_GetBlockedClientPrivateData,,false,1223,1223,RedisModule_GetBlockedClientPrivateData,,,435,void* RedisModule_GetBlockedClientPrivateData (RedisModuleCtx*)
316489,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleBlockedClient * (*RedisModule_GetBlockedClientHandle)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,42,101,redismodule.h,RedisModule_GetBlockedClientHandle,,false,1224,1224,RedisModule_GetBlockedClientHandle,,,436,RedisModuleBlockedClient* RedisModule_GetBlockedClientHandle (RedisModuleCtx*)
316494,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_AbortBlock)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,21,75,redismodule.h,RedisModule_AbortBlock,,false,1225,1225,RedisModule_AbortBlock,,,437,int RedisModule_AbortBlock (RedisModuleBlockedClient*)
316499,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_BlockedClientMeasureTimeStart)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,21,94,redismodule.h,RedisModule_BlockedClientMeasureTimeStart,,false,1226,1226,RedisModule_BlockedClientMeasureTimeStart,,,438,int RedisModule_BlockedClientMeasureTimeStart (RedisModuleBlockedClient*)
316504,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_BlockedClientMeasureTimeEnd)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,21,92,redismodule.h,RedisModule_BlockedClientMeasureTimeEnd,,false,1227,1227,RedisModule_BlockedClientMeasureTimeEnd,,,439,int RedisModule_BlockedClientMeasureTimeEnd (RedisModuleBlockedClient*)
316509,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleCtx * (*RedisModule_GetThreadSafeContext)(RedisModuleBlockedClient *bc) REDISMODULE_ATTR;,32,98,redismodule.h,RedisModule_GetThreadSafeContext,,false,1228,1228,RedisModule_GetThreadSafeContext,,,440,RedisModuleCtx* RedisModule_GetThreadSafeContext (RedisModuleBlockedClient*)
316514,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleCtx * (*RedisModule_GetDetachedThreadSafeContext)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,32,97,redismodule.h,RedisModule_GetDetachedThreadSafeContext,,false,1229,1229,RedisModule_GetDetachedThreadSafeContext,,,441,RedisModuleCtx* RedisModule_GetDetachedThreadSafeContext (RedisModuleCtx*)
316519,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_FreeThreadSafeContext)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,22,78,redismodule.h,RedisModule_FreeThreadSafeContext,,false,1230,1230,RedisModule_FreeThreadSafeContext,,,442,void RedisModule_FreeThreadSafeContext (RedisModuleCtx*)
316524,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_ThreadSafeContextLock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,22,78,redismodule.h,RedisModule_ThreadSafeContextLock,,false,1231,1231,RedisModule_ThreadSafeContextLock,,,443,void RedisModule_ThreadSafeContextLock (RedisModuleCtx*)
316529,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ThreadSafeContextTryLock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,80,redismodule.h,RedisModule_ThreadSafeContextTryLock,,false,1232,1232,RedisModule_ThreadSafeContextTryLock,,,444,int RedisModule_ThreadSafeContextTryLock (RedisModuleCtx*)
316534,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_ThreadSafeContextUnlock)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,22,80,redismodule.h,RedisModule_ThreadSafeContextUnlock,,false,1233,1233,RedisModule_ThreadSafeContextUnlock,,,445,void RedisModule_ThreadSafeContextUnlock (RedisModuleCtx*)
316539,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SubscribeToKeyspaceEvents)(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc cb) REDISMODULE_ATTR;",21,124,redismodule.h,RedisModule_SubscribeToKeyspaceEvents,,false,1234,1234,RedisModule_SubscribeToKeyspaceEvents,,,446,"int RedisModule_SubscribeToKeyspaceEvents (RedisModuleCtx*,int,RedisModuleNotificationFunc)"
316546,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_AddPostNotificationJob)(RedisModuleCtx *ctx, RedisModulePostNotificationJobFunc callback, void *pd, void (*free_pd)(void*)) REDISMODULE_ATTR;",21,157,redismodule.h,RedisModule_AddPostNotificationJob,,false,1235,1235,RedisModule_AddPostNotificationJob,,,447,"int RedisModule_AddPostNotificationJob (RedisModuleCtx*,RedisModulePostNotificationJobFunc,void*,void)"
316554,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_NotifyKeyspaceEvent)(RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key) REDISMODULE_ATTR;",21,128,redismodule.h,RedisModule_NotifyKeyspaceEvent,,false,1236,1236,RedisModule_NotifyKeyspaceEvent,,,448,"int RedisModule_NotifyKeyspaceEvent (RedisModuleCtx*,int,char*,RedisModuleString*)"
316562,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetNotifyKeyspaceEvents)(void) REDISMODULE_ATTR;,21,64,redismodule.h,RedisModule_GetNotifyKeyspaceEvents,,false,1237,1237,RedisModule_GetNotifyKeyspaceEvents,,,449,int RedisModule_GetNotifyKeyspaceEvents (void)
316567,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_BlockedClientDisconnected)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,81,redismodule.h,RedisModule_BlockedClientDisconnected,,false,1238,1238,RedisModule_BlockedClientDisconnected,,,450,int RedisModule_BlockedClientDisconnected (RedisModuleCtx*)
316572,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_RegisterClusterMessageReceiver)(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) REDISMODULE_ATTR;",22,145,redismodule.h,RedisModule_RegisterClusterMessageReceiver,,false,1239,1239,RedisModule_RegisterClusterMessageReceiver,,,451,"void RedisModule_RegisterClusterMessageReceiver (RedisModuleCtx*,uint8_t,RedisModuleClusterMessageReceiver)"
316579,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SendClusterMessage)(RedisModuleCtx *ctx, const char *target_id, uint8_t type, const char *msg, uint32_t len) REDISMODULE_ATTR;",21,142,redismodule.h,RedisModule_SendClusterMessage,,false,1240,1240,RedisModule_SendClusterMessage,,,452,"int RedisModule_SendClusterMessage (RedisModuleCtx*,char*,uint8_t,char*,uint32_t)"
316588,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_GetClusterNodeInfo)(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) REDISMODULE_ATTR;",21,140,redismodule.h,RedisModule_GetClusterNodeInfo,,false,1241,1241,RedisModule_GetClusterNodeInfo,,,453,"int RedisModule_GetClusterNodeInfo (RedisModuleCtx*,char*,char*,char*,int*,int*)"
316598,METHOD,redismodule.h:<global>,TYPE_DECL,"char ** (*RedisModule_GetClusterNodesList)(RedisModuleCtx *ctx, size_t *numnodes) REDISMODULE_ATTR;",22,97,redismodule.h,RedisModule_GetClusterNodesList,,false,1242,1242,RedisModule_GetClusterNodesList,,,454,"char** RedisModule_GetClusterNodesList (RedisModuleCtx*,size_t*)"
316604,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_FreeClusterNodesList)(char **ids) REDISMODULE_ATTR;,22,68,redismodule.h,RedisModule_FreeClusterNodesList,,false,1243,1243,RedisModule_FreeClusterNodesList,,,455,void RedisModule_FreeClusterNodesList (char**)
316609,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleTimerID (*RedisModule_CreateTimer)(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) REDISMODULE_ATTR;",36,142,redismodule.h,RedisModule_CreateTimer,,false,1244,1244,RedisModule_CreateTimer,,,456,"RedisModuleTimerID RedisModule_CreateTimer (RedisModuleCtx*,mstime_t,RedisModuleTimerProc,void*)"
316617,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_StopTimer)(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) REDISMODULE_ATTR;",21,101,redismodule.h,RedisModule_StopTimer,,false,1245,1245,RedisModule_StopTimer,,,457,"int RedisModule_StopTimer (RedisModuleCtx*,RedisModuleTimerID,void**)"
316624,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_GetTimerInfo)(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) REDISMODULE_ATTR;",21,125,redismodule.h,RedisModule_GetTimerInfo,,false,1246,1246,RedisModule_GetTimerInfo,,,458,"int RedisModule_GetTimerInfo (RedisModuleCtx*,RedisModuleTimerID,uint64_t*,void**)"
316632,METHOD,redismodule.h:<global>,TYPE_DECL,const char * (*RedisModule_GetMyClusterID)(void) REDISMODULE_ATTR;,28,64,redismodule.h,RedisModule_GetMyClusterID,,false,1247,1247,RedisModule_GetMyClusterID,,,459,char* RedisModule_GetMyClusterID (void)
316637,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_GetClusterSize)(void) REDISMODULE_ATTR;,24,58,redismodule.h,RedisModule_GetClusterSize,,false,1248,1248,RedisModule_GetClusterSize,,,460,size_t RedisModule_GetClusterSize (void)
316642,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_GetRandomBytes)(unsigned char *dst, size_t len) REDISMODULE_ATTR;",22,82,redismodule.h,RedisModule_GetRandomBytes,,false,1249,1249,RedisModule_GetRandomBytes,,,461,"void RedisModule_GetRandomBytes (unsigned char*,size_t)"
316648,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_GetRandomHexChars)(char *dst, size_t len) REDISMODULE_ATTR;",22,76,redismodule.h,RedisModule_GetRandomHexChars,,false,1250,1250,RedisModule_GetRandomHexChars,,,462,"void RedisModule_GetRandomHexChars (char*,size_t)"
316654,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SetDisconnectCallback)(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) REDISMODULE_ATTR;",22,123,redismodule.h,RedisModule_SetDisconnectCallback,,false,1251,1251,RedisModule_SetDisconnectCallback,,,463,"void RedisModule_SetDisconnectCallback (RedisModuleBlockedClient*,RedisModuleDisconnectFunc)"
316660,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SetClusterFlags)(RedisModuleCtx *ctx, uint64_t flags) REDISMODULE_ATTR;",22,88,redismodule.h,RedisModule_SetClusterFlags,,false,1252,1252,RedisModule_SetClusterFlags,,,464,"void RedisModule_SetClusterFlags (RedisModuleCtx*,uint64_t)"
316666,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ExportSharedAPI)(RedisModuleCtx *ctx, const char *apiname, void *func) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_ExportSharedAPI,,false,1253,1253,RedisModule_ExportSharedAPI,,,465,"int RedisModule_ExportSharedAPI (RedisModuleCtx*,char*,void*)"
316673,METHOD,redismodule.h:<global>,TYPE_DECL,"void * (*RedisModule_GetSharedAPI)(RedisModuleCtx *ctx, const char *apiname) REDISMODULE_ATTR;",22,92,redismodule.h,RedisModule_GetSharedAPI,,false,1254,1254,RedisModule_GetSharedAPI,,,466,"void* RedisModule_GetSharedAPI (RedisModuleCtx*,char*)"
316679,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleCommandFilter * (*RedisModule_RegisterCommandFilter)(RedisModuleCtx *ctx, RedisModuleCommandFilterFunc cb, int flags) REDISMODULE_ATTR;",42,144,redismodule.h,RedisModule_RegisterCommandFilter,,false,1255,1255,RedisModule_RegisterCommandFilter,,,467,"RedisModuleCommandFilter* RedisModule_RegisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilterFunc,int)"
316686,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_UnregisterCommandFilter)(RedisModuleCtx *ctx, RedisModuleCommandFilter *filter) REDISMODULE_ATTR;",21,113,redismodule.h,RedisModule_UnregisterCommandFilter,,false,1256,1256,RedisModule_UnregisterCommandFilter,,,468,"int RedisModule_UnregisterCommandFilter (RedisModuleCtx*,RedisModuleCommandFilter*)"
316692,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_CommandFilterArgsCount)(RedisModuleCommandFilterCtx *fctx) REDISMODULE_ATTR;,21,92,redismodule.h,RedisModule_CommandFilterArgsCount,,false,1257,1257,RedisModule_CommandFilterArgsCount,,,469,int RedisModule_CommandFilterArgsCount (RedisModuleCommandFilterCtx*)
316697,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_CommandFilterArgGet)(RedisModuleCommandFilterCtx *fctx, int pos) REDISMODULE_ATTR;",35,114,redismodule.h,RedisModule_CommandFilterArgGet,,false,1258,1258,RedisModule_CommandFilterArgGet,,,470,"RedisModuleString* RedisModule_CommandFilterArgGet (RedisModuleCommandFilterCtx*,int)"
316703,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CommandFilterArgInsert)(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg) REDISMODULE_ATTR;",21,125,redismodule.h,RedisModule_CommandFilterArgInsert,,false,1259,1259,RedisModule_CommandFilterArgInsert,,,471,"int RedisModule_CommandFilterArgInsert (RedisModuleCommandFilterCtx*,int,RedisModuleString*)"
316710,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CommandFilterArgReplace)(RedisModuleCommandFilterCtx *fctx, int pos, RedisModuleString *arg) REDISMODULE_ATTR;",21,126,redismodule.h,RedisModule_CommandFilterArgReplace,,false,1260,1260,RedisModule_CommandFilterArgReplace,,,472,"int RedisModule_CommandFilterArgReplace (RedisModuleCommandFilterCtx*,int,RedisModuleString*)"
316717,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_CommandFilterArgDelete)(RedisModuleCommandFilterCtx *fctx, int pos) REDISMODULE_ATTR;",21,101,redismodule.h,RedisModule_CommandFilterArgDelete,,false,1261,1261,RedisModule_CommandFilterArgDelete,,,473,"int RedisModule_CommandFilterArgDelete (RedisModuleCommandFilterCtx*,int)"
316723,METHOD,redismodule.h:<global>,TYPE_DECL,unsigned long long (*RedisModule_CommandFilterGetClientId)(RedisModuleCommandFilterCtx *fctx) REDISMODULE_ATTR;,36,109,redismodule.h,RedisModule_CommandFilterGetClientId,,false,1262,1262,RedisModule_CommandFilterGetClientId,,,474,long long unsigned RedisModule_CommandFilterGetClientId (RedisModuleCommandFilterCtx*)
316728,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_Fork)(RedisModuleForkDoneHandler cb, void *user_data) REDISMODULE_ATTR;",21,87,redismodule.h,RedisModule_Fork,,false,1263,1263,RedisModule_Fork,,,475,"int RedisModule_Fork (RedisModuleForkDoneHandler,void*)"
316734,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_SendChildHeartbeat)(double progress) REDISMODULE_ATTR;,22,71,redismodule.h,RedisModule_SendChildHeartbeat,,false,1264,1264,RedisModule_SendChildHeartbeat,,,476,void RedisModule_SendChildHeartbeat (double)
316739,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_ExitFromChild)(int retcode) REDISMODULE_ATTR;,21,61,redismodule.h,RedisModule_ExitFromChild,,false,1265,1265,RedisModule_ExitFromChild,,,477,int RedisModule_ExitFromChild (int)
316744,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_KillForkChild)(int child_pid) REDISMODULE_ATTR;,21,63,redismodule.h,RedisModule_KillForkChild,,false,1266,1266,RedisModule_KillForkChild,,,478,int RedisModule_KillForkChild (int)
316749,METHOD,redismodule.h:<global>,TYPE_DECL,float (*RedisModule_GetUsedMemoryRatio)(void) REDISMODULE_ATTR;,23,61,redismodule.h,RedisModule_GetUsedMemoryRatio,,false,1267,1267,RedisModule_GetUsedMemoryRatio,,,479,float RedisModule_GetUsedMemoryRatio (void)
316754,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_MallocSize)(void* ptr) REDISMODULE_ATTR;,24,59,redismodule.h,RedisModule_MallocSize,,false,1268,1268,RedisModule_MallocSize,,,480,size_t RedisModule_MallocSize (void*)
316759,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_MallocUsableSize)(void *ptr) REDISMODULE_ATTR;,24,65,redismodule.h,RedisModule_MallocUsableSize,,false,1269,1269,RedisModule_MallocUsableSize,,,481,size_t RedisModule_MallocUsableSize (void*)
316764,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_MallocSizeString)(RedisModuleString* str) REDISMODULE_ATTR;,24,78,redismodule.h,RedisModule_MallocSizeString,,false,1270,1270,RedisModule_MallocSizeString,,,482,size_t RedisModule_MallocSizeString (RedisModuleString*)
316769,METHOD,redismodule.h:<global>,TYPE_DECL,size_t (*RedisModule_MallocSizeDict)(RedisModuleDict* dict) REDISMODULE_ATTR;,24,75,redismodule.h,RedisModule_MallocSizeDict,,false,1271,1271,RedisModule_MallocSizeDict,,,483,size_t RedisModule_MallocSizeDict (RedisModuleDict*)
316774,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleUser * (*RedisModule_CreateModuleUser)(const char *name) REDISMODULE_ATTR;,33,83,redismodule.h,RedisModule_CreateModuleUser,,false,1272,1272,RedisModule_CreateModuleUser,,,484,RedisModuleUser* RedisModule_CreateModuleUser (char*)
316779,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_FreeModuleUser)(RedisModuleUser *user) REDISMODULE_ATTR;,22,73,redismodule.h,RedisModule_FreeModuleUser,,false,1273,1273,RedisModule_FreeModuleUser,,,485,void RedisModule_FreeModuleUser (RedisModuleUser*)
316784,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_SetContextUser)(RedisModuleCtx *ctx, const RedisModuleUser *user) REDISMODULE_ATTR;",22,100,redismodule.h,RedisModule_SetContextUser,,false,1274,1274,RedisModule_SetContextUser,,,486,"void RedisModule_SetContextUser (RedisModuleCtx*,RedisModuleUser*)"
316790,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetModuleUserACL)(RedisModuleUser *user, const char* acl) REDISMODULE_ATTR;",21,91,redismodule.h,RedisModule_SetModuleUserACL,,false,1275,1275,RedisModule_SetModuleUserACL,,,487,"int RedisModule_SetModuleUserACL (RedisModuleUser*,char*)"
316796,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_SetModuleUserACLString)(RedisModuleCtx * ctx, RedisModuleUser *user, const char* acl, RedisModuleString **error) REDISMODULE_ATTR;",21,146,redismodule.h,RedisModule_SetModuleUserACLString,,false,1276,1276,RedisModule_SetModuleUserACLString,,,488,"int RedisModule_SetModuleUserACLString (RedisModuleCtx*,RedisModuleUser*,char*,RedisModuleString**)"
316804,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleString * (*RedisModule_GetModuleUserACLString)(RedisModuleUser *user) REDISMODULE_ATTR;,35,96,redismodule.h,RedisModule_GetModuleUserACLString,,false,1277,1277,RedisModule_GetModuleUserACLString,,,489,RedisModuleString* RedisModule_GetModuleUserACLString (RedisModuleUser*)
316809,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleString * (*RedisModule_GetCurrentUserName)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,35,90,redismodule.h,RedisModule_GetCurrentUserName,,false,1278,1278,RedisModule_GetCurrentUserName,,,490,RedisModuleString* RedisModule_GetCurrentUserName (RedisModuleCtx*)
316814,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleUser * (*RedisModule_GetModuleUserFromUserName)(RedisModuleString *name) REDISMODULE_ATTR;,33,99,redismodule.h,RedisModule_GetModuleUserFromUserName,,false,1279,1279,RedisModule_GetModuleUserFromUserName,,,491,RedisModuleUser* RedisModule_GetModuleUserFromUserName (RedisModuleString*)
316819,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ACLCheckCommandPermissions)(RedisModuleUser *user, RedisModuleString **argv, int argc) REDISMODULE_ATTR;",21,120,redismodule.h,RedisModule_ACLCheckCommandPermissions,,false,1280,1280,RedisModule_ACLCheckCommandPermissions,,,492,"int RedisModule_ACLCheckCommandPermissions (RedisModuleUser*,RedisModuleString**,int)"
316826,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ACLCheckKeyPermissions)(RedisModuleUser *user, RedisModuleString *key, int flags) REDISMODULE_ATTR;",21,115,redismodule.h,RedisModule_ACLCheckKeyPermissions,,false,1281,1281,RedisModule_ACLCheckKeyPermissions,,,493,"int RedisModule_ACLCheckKeyPermissions (RedisModuleUser*,RedisModuleString*,int)"
316833,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_ACLCheckChannelPermissions)(RedisModuleUser *user, RedisModuleString *ch, int literal) REDISMODULE_ATTR;",21,120,redismodule.h,RedisModule_ACLCheckChannelPermissions,,false,1282,1282,RedisModule_ACLCheckChannelPermissions,,,494,"int RedisModule_ACLCheckChannelPermissions (RedisModuleUser*,RedisModuleString*,int)"
316840,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ACLAddLogEntry)(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) REDISMODULE_ATTR;",22,158,redismodule.h,RedisModule_ACLAddLogEntry,,false,1283,1283,RedisModule_ACLAddLogEntry,,,495,"void RedisModule_ACLAddLogEntry (RedisModuleCtx*,RedisModuleUser*,RedisModuleString*,RedisModuleACLLogEntryReason)"
316848,METHOD,redismodule.h:<global>,TYPE_DECL,"void (*RedisModule_ACLAddLogEntryByUserName)(RedisModuleCtx *ctx, RedisModuleString *user, RedisModuleString *object, RedisModuleACLLogEntryReason reason) REDISMODULE_ATTR;",22,170,redismodule.h,RedisModule_ACLAddLogEntryByUserName,,false,1284,1284,RedisModule_ACLAddLogEntryByUserName,,,496,"void RedisModule_ACLAddLogEntryByUserName (RedisModuleCtx*,RedisModuleString*,RedisModuleString*,RedisModuleACLLogEntryReason)"
316856,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_AuthenticateClientWithACLUser)(RedisModuleCtx *ctx, const char *name, size_t len, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) REDISMODULE_ATTR;",21,189,redismodule.h,RedisModule_AuthenticateClientWithACLUser,,false,1285,1285,RedisModule_AuthenticateClientWithACLUser,,,497,"int RedisModule_AuthenticateClientWithACLUser (RedisModuleCtx*,char*,size_t,RedisModuleUserChangedFunc,void*,uint64_t*)"
316866,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_AuthenticateClientWithUser)(RedisModuleCtx *ctx, RedisModuleUser *user, RedisModuleUserChangedFunc callback, void *privdata, uint64_t *client_id) REDISMODULE_ATTR;",21,179,redismodule.h,RedisModule_AuthenticateClientWithUser,,false,1286,1286,RedisModule_AuthenticateClientWithUser,,,498,"int RedisModule_AuthenticateClientWithUser (RedisModuleCtx*,RedisModuleUser*,RedisModuleUserChangedFunc,void*,uint64_t*)"
316875,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DeauthenticateAndCloseClient)(RedisModuleCtx *ctx, uint64_t client_id) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_DeauthenticateAndCloseClient,,false,1287,1287,RedisModule_DeauthenticateAndCloseClient,,,499,"int RedisModule_DeauthenticateAndCloseClient (RedisModuleCtx*,uint64_t)"
316881,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RedactClientCommandArgument)(RedisModuleCtx *ctx, int pos) REDISMODULE_ATTR;",21,92,redismodule.h,RedisModule_RedactClientCommandArgument,,false,1288,1288,RedisModule_RedactClientCommandArgument,,,500,"int RedisModule_RedactClientCommandArgument (RedisModuleCtx*,int)"
316887,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString * (*RedisModule_GetClientCertificate)(RedisModuleCtx *ctx, uint64_t id) REDISMODULE_ATTR;",35,105,redismodule.h,RedisModule_GetClientCertificate,,false,1289,1289,RedisModule_GetClientCertificate,,,501,"RedisModuleString* RedisModule_GetClientCertificate (RedisModuleCtx*,uint64_t)"
316893,METHOD,redismodule.h:<global>,TYPE_DECL,"int *(*RedisModule_GetCommandKeys)(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys) REDISMODULE_ATTR;",21,122,redismodule.h,RedisModule_GetCommandKeys,,false,1290,1290,RedisModule_GetCommandKeys,,,502,"int* RedisModule_GetCommandKeys (RedisModuleCtx*,RedisModuleString**,int,int*)"
316901,METHOD,redismodule.h:<global>,TYPE_DECL,"int *(*RedisModule_GetCommandKeysWithFlags)(RedisModuleCtx *ctx, RedisModuleString **argv, int argc, int *num_keys, int **out_flags) REDISMODULE_ATTR;",21,148,redismodule.h,RedisModule_GetCommandKeysWithFlags,,false,1291,1291,RedisModule_GetCommandKeysWithFlags,,,503,"int* RedisModule_GetCommandKeysWithFlags (RedisModuleCtx*,RedisModuleString**,int,int*,int**)"
316910,METHOD,redismodule.h:<global>,TYPE_DECL,const char *(*RedisModule_GetCurrentCommandName)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,28,85,redismodule.h,RedisModule_GetCurrentCommandName,,false,1292,1292,RedisModule_GetCurrentCommandName,,,504,char* RedisModule_GetCurrentCommandName (RedisModuleCtx*)
316915,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RegisterDefragFunc)(RedisModuleCtx *ctx, RedisModuleDefragFunc func) REDISMODULE_ATTR;",21,102,redismodule.h,RedisModule_RegisterDefragFunc,,false,1293,1293,RedisModule_RegisterDefragFunc,,,505,"int RedisModule_RegisterDefragFunc (RedisModuleCtx*,RedisModuleDefragFunc)"
316921,METHOD,redismodule.h:<global>,TYPE_DECL,"void *(*RedisModule_DefragAlloc)(RedisModuleDefragCtx *ctx, void *ptr) REDISMODULE_ATTR;",22,86,redismodule.h,RedisModule_DefragAlloc,,false,1294,1294,RedisModule_DefragAlloc,,,506,"void* RedisModule_DefragAlloc (RedisModuleDefragCtx*,void*)"
316927,METHOD,redismodule.h:<global>,TYPE_DECL,"RedisModuleString *(*RedisModule_DefragRedisModuleString)(RedisModuleDefragCtx *ctx, RedisModuleString *str) REDISMODULE_ATTR;",35,124,redismodule.h,RedisModule_DefragRedisModuleString,,false,1295,1295,RedisModule_DefragRedisModuleString,,,507,"RedisModuleString* RedisModule_DefragRedisModuleString (RedisModuleDefragCtx*,RedisModuleString*)"
316933,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_DefragShouldStop)(RedisModuleDefragCtx *ctx) REDISMODULE_ATTR;,21,78,redismodule.h,RedisModule_DefragShouldStop,,false,1296,1296,RedisModule_DefragShouldStop,,,508,int RedisModule_DefragShouldStop (RedisModuleDefragCtx*)
316938,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DefragCursorSet)(RedisModuleDefragCtx *ctx, unsigned long cursor) REDISMODULE_ATTR;",21,99,redismodule.h,RedisModule_DefragCursorSet,,false,1297,1297,RedisModule_DefragCursorSet,,,509,"int RedisModule_DefragCursorSet (RedisModuleDefragCtx*,long unsigned)"
316944,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_DefragCursorGet)(RedisModuleDefragCtx *ctx, unsigned long *cursor) REDISMODULE_ATTR;",21,100,redismodule.h,RedisModule_DefragCursorGet,,false,1298,1298,RedisModule_DefragCursorGet,,,510,"int RedisModule_DefragCursorGet (RedisModuleDefragCtx*,long unsigned*)"
316950,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_GetDbIdFromDefragCtx)(RedisModuleDefragCtx *ctx) REDISMODULE_ATTR;,21,82,redismodule.h,RedisModule_GetDbIdFromDefragCtx,,false,1299,1299,RedisModule_GetDbIdFromDefragCtx,,,511,int RedisModule_GetDbIdFromDefragCtx (RedisModuleDefragCtx*)
316955,METHOD,redismodule.h:<global>,TYPE_DECL,const RedisModuleString * (*RedisModule_GetKeyNameFromDefragCtx)(RedisModuleDefragCtx *ctx) REDISMODULE_ATTR;,41,107,redismodule.h,RedisModule_GetKeyNameFromDefragCtx,,false,1300,1300,RedisModule_GetKeyNameFromDefragCtx,,,512,RedisModuleString* RedisModule_GetKeyNameFromDefragCtx (RedisModuleDefragCtx*)
316960,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_EventLoopAdd)(int fd, int mask, RedisModuleEventLoopFunc func, void *user_data) REDISMODULE_ATTR;",21,113,redismodule.h,RedisModule_EventLoopAdd,,false,1301,1301,RedisModule_EventLoopAdd,,,513,"int RedisModule_EventLoopAdd (int,int,RedisModuleEventLoopFunc,void*)"
316968,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_EventLoopDel)(int fd, int mask) REDISMODULE_ATTR;",21,65,redismodule.h,RedisModule_EventLoopDel,,false,1302,1302,RedisModule_EventLoopDel,,,514,"int RedisModule_EventLoopDel (int,int)"
316974,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_EventLoopAddOneShot)(RedisModuleEventLoopOneShotFunc func, void *user_data) REDISMODULE_ATTR;",21,109,redismodule.h,RedisModule_EventLoopAddOneShot,,false,1303,1303,RedisModule_EventLoopAddOneShot,,,515,"int RedisModule_EventLoopAddOneShot (RedisModuleEventLoopOneShotFunc,void*)"
316980,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RegisterBoolConfig)(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, RedisModuleConfigGetBoolFunc getfn, RedisModuleConfigSetBoolFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",21,253,redismodule.h,RedisModule_RegisterBoolConfig,,false,1304,1304,RedisModule_RegisterBoolConfig,,,516,"int RedisModule_RegisterBoolConfig (RedisModuleCtx*,char*,int,unsigned int,RedisModuleConfigGetBoolFunc,RedisModuleConfigSetBoolFunc,RedisModuleConfigApplyFunc,void*)"
316992,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RegisterNumericConfig)(RedisModuleCtx *ctx, const char *name, long long default_val, unsigned int flags, long long min, long long max, RedisModuleConfigGetNumericFunc getfn, RedisModuleConfigSetNumericFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",21,298,redismodule.h,RedisModule_RegisterNumericConfig,,false,1305,1305,RedisModule_RegisterNumericConfig,,,517,"int RedisModule_RegisterNumericConfig (RedisModuleCtx*,char*,long long,unsigned int,long long,long long,RedisModuleConfigGetNumericFunc,RedisModuleConfigSetNumericFunc,RedisModuleConfigApplyFunc,void*)"
317006,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RegisterStringConfig)(RedisModuleCtx *ctx, const char *name, const char *default_val, unsigned int flags, RedisModuleConfigGetStringFunc getfn, RedisModuleConfigSetStringFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",21,267,redismodule.h,RedisModule_RegisterStringConfig,,false,1306,1306,RedisModule_RegisterStringConfig,,,518,"int RedisModule_RegisterStringConfig (RedisModuleCtx*,char*,char*,unsigned int,RedisModuleConfigGetStringFunc,RedisModuleConfigSetStringFunc,RedisModuleConfigApplyFunc,void*)"
317018,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RegisterEnumConfig)(RedisModuleCtx *ctx, const char *name, int default_val, unsigned int flags, const char **enum_values, const int *int_values, int num_enum_vals, RedisModuleConfigGetEnumFunc getfn, RedisModuleConfigSetEnumFunc setfn, RedisModuleConfigApplyFunc applyfn, void *privdata) REDISMODULE_ATTR;",21,321,redismodule.h,RedisModule_RegisterEnumConfig,,false,1307,1307,RedisModule_RegisterEnumConfig,,,519,"int RedisModule_RegisterEnumConfig (RedisModuleCtx*,char*,int,unsigned int,char**,int*,int,RedisModuleConfigGetEnumFunc,RedisModuleConfigSetEnumFunc,RedisModuleConfigApplyFunc,void*)"
317033,METHOD,redismodule.h:<global>,TYPE_DECL,int (*RedisModule_LoadConfigs)(RedisModuleCtx *ctx) REDISMODULE_ATTR;,21,67,redismodule.h,RedisModule_LoadConfigs,,false,1308,1308,RedisModule_LoadConfigs,,,520,int RedisModule_LoadConfigs (RedisModuleCtx*)
317038,METHOD,redismodule.h:<global>,TYPE_DECL,RedisModuleRdbStream *(*RedisModule_RdbStreamCreateFromFile)(const char *filename) REDISMODULE_ATTR;,38,98,redismodule.h,RedisModule_RdbStreamCreateFromFile,,false,1309,1309,RedisModule_RdbStreamCreateFromFile,,,521,RedisModuleRdbStream* RedisModule_RdbStreamCreateFromFile (char*)
317043,METHOD,redismodule.h:<global>,TYPE_DECL,void (*RedisModule_RdbStreamFree)(RedisModuleRdbStream *stream) REDISMODULE_ATTR;,22,79,redismodule.h,RedisModule_RdbStreamFree,,false,1310,1310,RedisModule_RdbStreamFree,,,522,void RedisModule_RdbStreamFree (RedisModuleRdbStream*)
317048,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RdbLoad)(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_RdbLoad,,false,1311,1311,RedisModule_RdbLoad,,,523,"int RedisModule_RdbLoad (RedisModuleCtx*,RedisModuleRdbStream*,int)"
317055,METHOD,redismodule.h:<global>,TYPE_DECL,"int (*RedisModule_RdbSave)(RedisModuleCtx *ctx, RedisModuleRdbStream *stream, int flags) REDISMODULE_ATTR;",21,104,redismodule.h,RedisModule_RdbSave,,false,1312,1312,RedisModule_RdbSave,,,524,"int RedisModule_RdbSave (RedisModuleCtx*,RedisModuleRdbStream*,int)"
317062,METHOD,redismodule.h:<global>,TYPE_DECL,"static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) REDISMODULE_ATTR_UNUSED;",12,87,redismodule.h,RedisModule_Init,,false,1317,1317,RedisModule_Init,,,525,"int RedisModule_Init (RedisModuleCtx*,char*,int,int)"
317070,METHOD,redismodule.h:<global>,TYPE_DECL,"static int RedisModule_Init(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {
    void *getapifuncptr = ((void**)ctx)[0];
    RedisModule_GetApi = (int (*)(const char *, void *)) (unsigned long)getapifuncptr;
    REDISMODULE_GET_API(Alloc);
    REDISMODULE_GET_API(TryAlloc);
    REDISMODULE_GET_API(Calloc);
    REDISMODULE_GET_API(Free);
    REDISMODULE_GET_API(Realloc);
    REDISMODULE_GET_API(Strdup);
    REDISMODULE_GET_API(CreateCommand);
    REDISMODULE_GET_API(GetCommand);
    REDISMODULE_GET_API(CreateSubcommand);
    REDISMODULE_GET_API(SetCommandInfo);
    REDISMODULE_GET_API(SetCommandACLCategories);
    REDISMODULE_GET_API(SetModuleAttribs);
    REDISMODULE_GET_API(IsModuleNameBusy);
    REDISMODULE_GET_API(WrongArity);
    REDISMODULE_GET_API(ReplyWithLongLong);
    REDISMODULE_GET_API(ReplyWithError);
    REDISMODULE_GET_API(ReplyWithErrorFormat);
    REDISMODULE_GET_API(ReplyWithSimpleString);
    REDISMODULE_GET_API(ReplyWithArray);
    REDISMODULE_GET_API...",1,4,redismodule.h,RedisModule_Init,,false,1318,1678,RedisModule_Init,,,526,"int RedisModule_Init (RedisModuleCtx*,char*,int,int)"
319947,METHOD,release.c:<global>,TYPE_DECL,<global>,1,21,release.c,release.c:<global>,,false,1,69,<global>,,,1,
319949,METHOD,release.c:<global>,TYPE_DECL,"char *redisGitSHA1(void) {
    return REDIS_GIT_SHA1;
}",1,1,release.c,redisGitSHA1,,false,40,42,redisGitSHA1,,,1,char* redisGitSHA1 (void)
319956,METHOD,release.c:<global>,TYPE_DECL,"char *redisGitDirty(void) {
    return REDIS_GIT_DIRTY;
}",1,1,release.c,redisGitDirty,,false,44,46,redisGitDirty,,,2,char* redisGitDirty (void)
319963,METHOD,release.c:<global>,TYPE_DECL,"const char *redisBuildIdRaw(void) {
    return REDIS_BUILD_ID_RAW;
}",1,1,release.c,redisBuildIdRaw,,false,48,50,redisBuildIdRaw,,,3,const char* redisBuildIdRaw (void)
319970,METHOD,release.c:<global>,TYPE_DECL,"uint64_t redisBuildId(void) {
    char *buildid = REDIS_BUILD_ID_RAW;

    return crc64(0,(unsigned char*)buildid,strlen(buildid));
}",1,1,release.c,redisBuildId,,false,52,56,redisBuildId,,,4,uint64_t redisBuildId (void)
319987,METHOD,release.c:<global>,TYPE_DECL,"char *redisBuildIdString(void) {
    static char buf[32];
    static int cached = 0;
    if (!cached) {
        snprintf(buf,sizeof(buf),""%llx"",(unsigned long long) redisBuildId());
        cached = 1;
    }
    return buf;
}",1,1,release.c,redisBuildIdString,,false,61,69,redisBuildIdString,,,5,char* redisBuildIdString (void)
320041,METHOD,replication.c:<global>,TYPE_DECL,<global>,1,1,replication.c,replication.c:<global>,,false,1,4239,<global>,,,1,
320043,METHOD,replication.c:<global>,TYPE_DECL,void replicationDiscardCachedMaster(void);,6,41,replication.c,replicationDiscardCachedMaster,,false,45,45,replicationDiscardCachedMaster,,,1,void replicationDiscardCachedMaster (void)
320048,METHOD,replication.c:<global>,TYPE_DECL,void replicationResurrectCachedMaster(connection *conn);,6,55,replication.c,replicationResurrectCachedMaster,,false,46,46,replicationResurrectCachedMaster,,,2,void replicationResurrectCachedMaster (connection*)
320053,METHOD,replication.c:<global>,TYPE_DECL,void replicationSendAck(void);,6,29,replication.c,replicationSendAck,,false,47,47,replicationSendAck,,,3,void replicationSendAck (void)
320058,METHOD,replication.c:<global>,TYPE_DECL,int replicaPutOnline(client *slave);,5,35,replication.c,replicaPutOnline,,false,48,48,replicaPutOnline,,,4,int replicaPutOnline (client*)
320063,METHOD,replication.c:<global>,TYPE_DECL,void replicaStartCommandStream(client *slave);,6,45,replication.c,replicaStartCommandStream,,false,49,49,replicaStartCommandStream,,,5,void replicaStartCommandStream (client*)
320068,METHOD,replication.c:<global>,TYPE_DECL,int cancelReplicationHandshake(int reconnect);,5,45,replication.c,cancelReplicationHandshake,,false,50,50,cancelReplicationHandshake,,,6,int cancelReplicationHandshake (int)
320077,METHOD,replication.c:<global>,TYPE_DECL,"static ConnectionType *connTypeOfReplication(void) {
    if (server.tls_replication) {
        return connectionTypeTls();
    }

    return connectionTypeTcp();
}",1,1,replication.c,connTypeOfReplication,,false,58,64,connTypeOfReplication,,,9,ConnectionType connTypeOfReplication (void)
320091,METHOD,replication.c:<global>,TYPE_DECL,"char *replicationGetSlaveName(client *c) {
    static char buf[NET_HOST_PORT_STR_LEN];
    char ip[NET_IP_STR_LEN];

    ip[0] = '\0';
    buf[0] = '\0';
    if (c->slave_addr ||
        connAddrPeerName(c->conn,ip,sizeof(ip),NULL) != -1)
    {
        char *addr = c->slave_addr ? c->slave_addr : ip;
        if (c->slave_listening_port)
            formatAddr(buf,sizeof(buf),addr,c->slave_listening_port);
        else
            snprintf(buf,sizeof(buf),""%s:<unknown-replica-port>"",addr);
    } else {
        snprintf(buf,sizeof(buf),""client id #%llu"",
            (unsigned long long) c->id);
    }
    return buf;
}",1,20,replication.c,replicationGetSlaveName,,false,70,89,replicationGetSlaveName,,,10,char* replicationGetSlaveName (client*)
320171,METHOD,replication.c:<global>,TYPE_DECL,"int bg_unlink(const char *filename) {
    int fd = open(filename,O_RDONLY|O_NONBLOCK);
    if (fd == -1) {
        /* Can't open the file? Fall back to unlinking in the main thread. */
        return unlink(filename);
    } else {
        /* The following unlink() removes the name but doesn't free the
         * file contents because a process still has it open. */
        int retval = unlink(filename);
        if (retval == -1) {
            /* If we got an unlink error, we just return it, closing the
             * new reference we have to the file. */
            int old_errno = errno;
            close(fd);  /* This would overwrite our errno. So we saved it. */
            errno = old_errno;
            return -1;
        }
        bioCreateCloseJob(fd, 0, 0);
        return 0; /* Success. */
    }
}",1,1,replication.c,bg_unlink,,false,97,117,bg_unlink,,,11,int bg_unlink (char*)
320224,METHOD,replication.c:<global>,TYPE_DECL,"void createReplicationBacklog(void) {
    serverAssert(server.repl_backlog == NULL);
    server.repl_backlog = zmalloc(sizeof(replBacklog));
    server.repl_backlog->ref_repl_buf_node = NULL;
    server.repl_backlog->unindexed_count = 0;
    server.repl_backlog->blocks_index = raxNew();
    server.repl_backlog->histlen = 0;
    /* We don't have any data inside our buffer, but virtually the first
     * byte we have is the next byte that will be generated for the
     * replication stream. */
    server.repl_backlog->offset = server.master_repl_offset+1;
}",1,4,replication.c,createReplicationBacklog,,false,121,132,createReplicationBacklog,,,12,void createReplicationBacklog (void)
320293,METHOD,replication.c:<global>,TYPE_DECL,"void resizeReplicationBacklog(void) {
    if (server.repl_backlog_size < CONFIG_REPL_BACKLOG_MIN_SIZE)
        server.repl_backlog_size = CONFIG_REPL_BACKLOG_MIN_SIZE;
    if (server.repl_backlog)
        incrementalTrimReplicationBacklog(REPL_BACKLOG_TRIM_BLOCKS_PER_CALL);
}",1,35,replication.c,resizeReplicationBacklog,,false,139,144,resizeReplicationBacklog,,,13,void resizeReplicationBacklog (void)
320327,METHOD,replication.c:<global>,TYPE_DECL,"void freeReplicationBacklog(void) {
    serverAssert(listLength(server.slaves) == 0);
    if (server.repl_backlog == NULL) return;

    /* Decrease the start buffer node reference count. */
    if (server.repl_backlog->ref_repl_buf_node) {
        replBufBlock *o = listNodeValue(
            server.repl_backlog->ref_repl_buf_node);
        serverAssert(o->refcount == 1); /* Last reference. */
        o->refcount--;
    }

    /* Replication buffer blocks are completely released when we free the
     * backlog, since the backlog is released only when there are no replicas
     * and the backlog keeps the last reference of all blocks. */
    freeReplicationBacklogRefMemAsync(server.repl_buffer_blocks,
                            server.repl_backlog->blocks_index);
    resetReplicationBuffer();
    zfree(server.repl_backlog);
    server.repl_backlog = NULL;
}",1,4,replication.c,freeReplicationBacklog,,false,146,166,freeReplicationBacklog,,,14,void freeReplicationBacklog (void)
320425,METHOD,replication.c:<global>,TYPE_DECL,"void createReplicationBacklogIndex(listNode *ln) {
    server.repl_backlog->unindexed_count++;
    if (server.repl_backlog->unindexed_count >= REPL_BACKLOG_INDEX_PER_BLOCKS) {
        replBufBlock *o = listNodeValue(ln);
        uint64_t encoded_offset = htonu64(o->repl_offset);
        raxInsert(server.repl_backlog->blocks_index,
                  (unsigned char*)&encoded_offset, sizeof(uint64_t),
                  ln, NULL);
        server.repl_backlog->unindexed_count = 0;
    }
}",1,48,replication.c,createReplicationBacklogIndex,,false,171,181,createReplicationBacklogIndex,,,15,void createReplicationBacklogIndex (listNode*)
320489,METHOD,replication.c:<global>,TYPE_DECL,"void rebaseReplicationBuffer(long long base_repl_offset) {
    raxFree(server.repl_backlog->blocks_index);
    server.repl_backlog->blocks_index = raxNew();
    server.repl_backlog->unindexed_count = 0;

    listIter li;
    listNode *ln;
    listRewind(server.repl_buffer_blocks, &li);
    while ((ln = listNext(&li))) {
        replBufBlock *o = listNodeValue(ln);
        o->repl_offset += base_repl_offset;
        createReplicationBacklogIndex(ln);
    }
}",1,26,replication.c,rebaseReplicationBuffer,,false,185,198,rebaseReplicationBuffer,,,16,void rebaseReplicationBuffer (long long)
320545,METHOD,replication.c:<global>,TYPE_DECL,"void resetReplicationBuffer(void) {
    server.repl_buffer_mem = 0;
    server.repl_buffer_blocks = listCreate();
    listSetFreeMethod(server.repl_buffer_blocks, (void (*)(void*))zfree);
}",1,4,replication.c,resetReplicationBuffer,,false,200,204,resetReplicationBuffer,,,17,void resetReplicationBuffer (void)
320574,METHOD,replication.c:<global>,TYPE_DECL,"int canFeedReplicaReplBuffer(client *replica) {
    /* Don't feed replicas that only want the RDB. */
    if (replica->flags & CLIENT_REPL_RDBONLY) return 0;

    /* Don't feed replicas that are still waiting for BGSAVE to start. */
    if (replica->replstate == SLAVE_STATE_WAIT_BGSAVE_START) return 0;

    return 1;
}",1,25,replication.c,canFeedReplicaReplBuffer,,false,206,214,canFeedReplicaReplBuffer,,,18,int canFeedReplicaReplBuffer (client*)
320605,METHOD,replication.c:<global>,TYPE_DECL,"int prepareReplicasToWrite(void) {
    listIter li;
    listNode *ln;
    int prepared = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (!canFeedReplicaReplBuffer(slave)) continue;
        if (prepareClientToWrite(slave) == C_ERR) continue;
        prepared++;
    }

    return prepared;
}",1,43,replication.c,prepareReplicasToWrite,,false,220,234,prepareReplicasToWrite,,,19,int prepareReplicasToWrite (void)
320655,METHOD,replication.c:<global>,TYPE_DECL,"void feedReplicationBufferWithObject(robj *o) {
    char llstr[LONG_STR_SIZE];
    void *p;
    size_t len;

    if (o->encoding == OBJ_ENCODING_INT) {
        len = ll2string(llstr,sizeof(llstr),(long)o->ptr);
        p = llstr;
    } else {
        len = sdslen(o->ptr);
        p = o->ptr;
    }
    feedReplicationBuffer(p,len);
}",1,15,replication.c,feedReplicationBufferWithObject,,false,238,251,feedReplicationBufferWithObject,,,20,void feedReplicationBufferWithObject (robj*)
320702,METHOD,replication.c:<global>,TYPE_DECL,"void incrementalTrimReplicationBacklog(size_t max_blocks) {
    serverAssert(server.repl_backlog != NULL);

    size_t trimmed_blocks = 0;
    while (server.repl_backlog->histlen > server.repl_backlog_size &&
           trimmed_blocks < max_blocks)
    {
        /* We never trim backlog to less than one block. */
        if (listLength(server.repl_buffer_blocks) <= 1) break;

        /* Replicas increment the refcount of the first replication buffer block
         * they refer to, in that case, we don't trim the backlog even if
         * backlog_histlen exceeds backlog_size. This implicitly makes backlog
         * bigger than our setting, but makes the master accept partial resync as
         * much as possible. So that backlog must be the last reference of
         * replication buffer blocks. */
        listNode *first = listFirst(server.repl_buffer_blocks);
        serverAssert(first == server.repl_backlog->ref_repl_buf_node);
        replBufBlock *fo = listNodeValue(first);
  ...",1,4,replication.c,incrementalTrimReplicationBacklog,,false,258,311,incrementalTrimReplicationBacklog,,,21,void incrementalTrimReplicationBacklog (size_t)
320975,METHOD,replication.c:<global>,TYPE_DECL,"void freeReplicaReferencedReplBuffer(client *replica) {
    if (replica->ref_repl_buf_node != NULL) {
        /* Decrease the start buffer node reference count. */
        replBufBlock *o = listNodeValue(replica->ref_repl_buf_node);
        serverAssert(o->refcount > 0);
        o->refcount--;
        incrementalTrimReplicationBacklog(REPL_BACKLOG_TRIM_BLOCKS_PER_CALL);
    }
    replica->ref_repl_buf_node = NULL;
    replica->ref_block_pos = 0;
}",1,26,replication.c,freeReplicaReferencedReplBuffer,,false,314,324,freeReplicaReferencedReplBuffer,,,22,void freeReplicaReferencedReplBuffer (client*)
321036,METHOD,replication.c:<global>,TYPE_DECL,"void feedReplicationBuffer(char *s, size_t len) {
    static long long repl_block_id = 0;

    if (server.repl_backlog == NULL) return;

    while(len > 0) {
        size_t start_pos = 0; /* The position of referenced block to start sending. */
        listNode *start_node = NULL; /* Replica/backlog starts referenced node. */
        int add_new_block = 0; /* Create new block if current block is total used. */
        listNode *ln = listLast(server.repl_buffer_blocks);
        replBufBlock *tail = ln ? listNodeValue(ln) : NULL;

        /* Append to tail string when possible. */
        if (tail && tail->size > tail->used) {
            start_node = listLast(server.repl_buffer_blocks);
            start_pos = tail->used;
            /* Copy the part we can fit into the tail, and leave the rest for a
             * new node */
            size_t avail = tail->size - tail->used;
            size_t copy = (avail >= len) ? len : avail;
            memcpy(tail->buf + tail->used, s, copy)...",1,23,replication.c,feedReplicationBuffer,,false,331,429,feedReplicationBuffer,,,23,"void feedReplicationBuffer (char*,size_t)"
321483,METHOD,replication.c:<global>,TYPE_DECL,"void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {
    int j, len;
    char llstr[LONG_STR_SIZE];

    /* In case we propagate a command that doesn't touch keys (PING, REPLCONF) we
     * pass dbid=-1 that indicate there is no need to replicate `select` command. */
    serverAssert(dictid == -1 || (dictid >= 0 && dictid < server.dbnum));

    /* If the instance is not a top level master, return ASAP: we'll just proxy
     * the stream of data we receive from our master instead, in order to
     * propagate *identical* replication stream. In this way this slave can
     * advertise the same replication ID as the master (since it shares the
     * master replication history and has the same backlog and offsets). */
    if (server.masterhost != NULL) return;

    /* If there aren't slaves, and there is no backlog buffer to populate,
     * we can return ASAP. */
    if (server.repl_backlog == NULL && listLength(slaves) == 0) {
        /* We increment the repl...",1,15,replication.c,replicationFeedSlaves,,false,437,518,replicationFeedSlaves,,,24,"void replicationFeedSlaves (list*,int,robj**,int)"
321749,METHOD,replication.c:<global>,TYPE_DECL,"void showLatestBacklog(void) {
    if (server.repl_backlog == NULL) return;
    if (listLength(server.repl_buffer_blocks) == 0) return;

    size_t dumplen = 256;
    if (server.repl_backlog->histlen < (long long)dumplen)
        dumplen = server.repl_backlog->histlen;

    sds dump = sdsempty();
    listNode *node = listLast(server.repl_buffer_blocks);
    while(dumplen) {
        if (node == NULL) break;
        replBufBlock *o = listNodeValue(node);
        size_t thislen = o->used >= dumplen ? dumplen : o->used;
        sds head = sdscatrepr(sdsempty(), o->buf+o->used-thislen, thislen);
        sds tmp = sdscatsds(head, dump);
        sdsfree(dump);
        dump = tmp;
        dumplen -= thislen;
        node = listPrevNode(node);
    }

    /* Finally log such bytes: this is vital debugging info to
     * understand what happened. */
    serverLog(LL_NOTICE,""Latest backlog is: '%s'"", dump);
    sdsfree(dump);
}",1,8,replication.c,showLatestBacklog,,false,524,550,showLatestBacklog,,,25,void showLatestBacklog (void)
321905,METHOD,replication.c:<global>,TYPE_DECL,"void replicationFeedStreamFromMasterStream(char *buf, size_t buflen) {
    /* Debugging: this is handy to see the stream sent from master
     * to slaves. Disabled with if(0). */
    if (0) {
        printf(""%zu:"",buflen);
        for (size_t j = 0; j < buflen; j++) {
            printf(""%c"", isprint(buf[j]) ? buf[j] : '.');
        }
        printf(""\n"");
    }

    /* There must be replication backlog if having attached slaves. */
    if (listLength(server.slaves)) serverAssert(server.repl_backlog != NULL);
    if (server.repl_backlog) {
        /* Must install write handler for all replicas first before feeding
         * replication stream. */
        prepareReplicasToWrite();
        feedReplicationBuffer(buf,buflen);
    }
}",1,8,replication.c,replicationFeedStreamFromMasterStream,,false,555,574,replicationFeedStreamFromMasterStream,,,26,"void replicationFeedStreamFromMasterStream (char*,size_t)"
321981,METHOD,replication.c:<global>,TYPE_DECL,"void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc) {
    /* Fast path to return if the monitors list is empty or the server is in loading. */
    if (monitors == NULL || listLength(monitors) == 0 || server.loading) return;
    listNode *ln;
    listIter li;
    int j;
    sds cmdrepr = sdsnew(""+"");
    robj *cmdobj;
    struct timeval tv;

    gettimeofday(&tv,NULL);
    cmdrepr = sdscatprintf(cmdrepr,""%ld.%06ld "",(long)tv.tv_sec,(long)tv.tv_usec);
    if (c->flags & CLIENT_SCRIPT) {
        cmdrepr = sdscatprintf(cmdrepr,""[%d lua] "",dictid);
    } else if (c->flags & CLIENT_UNIX_SOCKET) {
        cmdrepr = sdscatprintf(cmdrepr,""[%d unix:%s] "",dictid,server.unixsocket);
    } else {
        cmdrepr = sdscatprintf(cmdrepr,""[%d %s] "",dictid,getClientPeerId(c));
    }

    for (j = 0; j < argc; j++) {
        if (argv[j]->encoding == OBJ_ENCODING_INT) {
            cmdrepr = sdscatprintf(cmdrepr, ""\""%ld\"""", (long)argv[j]->ptr);
        } else {
 ...",1,28,replication.c,replicationFeedMonitors,,false,576,615,replicationFeedMonitors,,,27,"void replicationFeedMonitors (client*,list*,int,robj**,int)"
322188,METHOD,replication.c:<global>,TYPE_DECL,"long long addReplyReplicationBacklog(client *c, long long offset) {
    long long skip;

    serverLog(LL_DEBUG, ""[PSYNC] Replica request offset: %lld"", offset);

    if (server.repl_backlog->histlen == 0) {
        serverLog(LL_DEBUG, ""[PSYNC] Backlog history len is zero"");
        return 0;
    }

    serverLog(LL_DEBUG, ""[PSYNC] Backlog size: %lld"",
             server.repl_backlog_size);
    serverLog(LL_DEBUG, ""[PSYNC] First byte: %lld"",
             server.repl_backlog->offset);
    serverLog(LL_DEBUG, ""[PSYNC] History len: %lld"",
             server.repl_backlog->histlen);

    /* Compute the amount of bytes we need to discard. */
    skip = offset - server.repl_backlog->offset;
    serverLog(LL_DEBUG, ""[PSYNC] Skipping: %lld"", skip);

    /* Iterate recorded blocks, quickly search the approximate node. */
    listNode *node = NULL;
    if (raxSize(server.repl_backlog->blocks_index) > 0) {
        uint64_t encoded_offset = htonu64(offset);
        raxIterator ri;
        raxS...",1,4,replication.c,addReplyReplicationBacklog,,false,619,684,addReplyReplicationBacklog,,,28,"long long addReplyReplicationBacklog (client*,long long)"
322527,METHOD,replication.c:<global>,TYPE_DECL,"long long getPsyncInitialOffset(void) {
    return server.master_repl_offset;
}",1,1,replication.c,getPsyncInitialOffset,,false,690,692,getPsyncInitialOffset,,,29,long long getPsyncInitialOffset (void)
322536,METHOD,replication.c:<global>,TYPE_DECL,"int replicationSetupSlaveForFullResync(client *slave, long long offset) {
    char buf[128];
    int buflen;

    slave->psync_initial_offset = offset;
    slave->replstate = SLAVE_STATE_WAIT_BGSAVE_END;
    /* We are going to accumulate the incremental changes for this
     * slave as well. Set slaveseldb to -1 in order to force to re-emit
     * a SELECT statement in the replication stream. */
    server.slaveseldb = -1;

    /* Don't send this reply to slaves that approached us with
     * the old SYNC command. */
    if (!(slave->flags & CLIENT_PRE_PSYNC)) {
        buflen = snprintf(buf,sizeof(buf),""+FULLRESYNC %s %lld\r\n"",
                          server.replid,offset);
        if (connWrite(slave->conn,buf,buflen) != buflen) {
            freeClientAsync(slave);
            return C_ERR;
        }
    }
    return C_OK;
}",1,23,replication.c,replicationSetupSlaveForFullResync,,false,710,732,replicationSetupSlaveForFullResync,,,30,"int replicationSetupSlaveForFullResync (client*,long long)"
322606,METHOD,replication.c:<global>,TYPE_DECL,"int masterTryPartialResynchronization(client *c, long long psync_offset) {
    long long psync_len;
    char *master_replid = c->argv[1]->ptr;
    char buf[128];
    int buflen;

    /* Is the replication ID of this master the same advertised by the wannabe
     * slave via PSYNC? If the replication ID changed this master has a
     * different replication history, and there is no way to continue.
     *
     * Note that there are two potentially valid replication IDs: the ID1
     * and the ID2. The ID2 however is only valid up to a specific offset. */
    if (strcasecmp(master_replid, server.replid) &&
        (strcasecmp(master_replid, server.replid2) ||
         psync_offset > server.second_replid_offset))
    {
        /* Replid ""?"" is used by slaves that want to force a full resync. */
        if (master_replid[0] != '?') {
            if (strcasecmp(master_replid, server.replid) &&
                strcasecmp(master_replid, server.replid2))
            {
                server...",1,16,replication.c,masterTryPartialResynchronization,,false,739,835,masterTryPartialResynchronization,,,31,"int masterTryPartialResynchronization (client*,long long)"
322938,METHOD,replication.c:<global>,TYPE_DECL,"int startBgsaveForReplication(int mincapa, int req) {
    int retval;
    int socket_target = 0;
    listIter li;
    listNode *ln;

    /* We use a socket target if slave can handle the EOF marker and we're configured to do diskless syncs.
     * Note that in case we're creating a ""filtered"" RDB (functions-only, for example) we also force socket replication
     * to avoid overwriting the snapshot RDB file with filtered data. */
    socket_target = (server.repl_diskless_sync || req & SLAVE_REQ_RDB_MASK) && (mincapa & SLAVE_CAPA_EOF);
    /* `SYNC` should have failed with error if we don't support socket and require a filter, assert this here */
    serverAssert(socket_target || !(req & SLAVE_REQ_RDB_MASK));

    serverLog(LL_NOTICE,""Starting BGSAVE for SYNC with target: %s"",
        socket_target ? ""replicas sockets"" : ""disk"");

    rdbSaveInfo rsi, *rsiptr;
    rsiptr = rdbPopulateSaveInfo(&rsi);
    /* Only do rdbSave* when rsiptr is not NULL,
     * otherwise slave will miss rep...",1,56,replication.c,startBgsaveForReplication,,false,855,933,startBgsaveForReplication,,,32,"int startBgsaveForReplication (int,int)"
323232,METHOD,replication.c:<global>,TYPE_DECL,"void syncCommand(client *c) {
    /* ignore SYNC if already slave or in monitor mode */
    if (c->flags & CLIENT_SLAVE) return;

    /* Check if this is a failover request to a replica with the same replid and
     * become a master if so. */
    if (c->argc > 3 && !strcasecmp(c->argv[0]->ptr,""psync"") && 
        !strcasecmp(c->argv[3]->ptr,""failover""))
    {
        serverLog(LL_NOTICE, ""Failover request received for replid %s."",
            (unsigned char *)c->argv[1]->ptr);
        if (!server.masterhost) {
            addReplyError(c, ""PSYNC FAILOVER can't be sent to a master."");
            return;
        }

        if (!strcasecmp(c->argv[1]->ptr,server.replid)) {
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,
                ""MASTER MODE enabled (failover request from '%s')"",client);
            sdsfree(client);
        } else {
            addReplyError(c, ""PSYNC FAILOVER replid must match ...",1,19,replication.c,syncCommand,,false,936,1128,syncCommand,,,33,void syncCommand (client*)
323892,METHOD,replication.c:<global>,TYPE_DECL,"void replconfCommand(client *c) {
    int j;

    if ((c->argc % 2) == 0) {
        /* Number of arguments must be odd to make sure that every
         * option has a corresponding value. */
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Process every option-value pair. */
    for (j = 1; j < c->argc; j+=2) {
        if (!strcasecmp(c->argv[j]->ptr,""listening-port"")) {
            long port;

            if ((getLongFromObjectOrReply(c,c->argv[j+1],
                    &port,NULL) != C_OK))
                return;
            c->slave_listening_port = port;
        } else if (!strcasecmp(c->argv[j]->ptr,""ip-address"")) {
            sds addr = c->argv[j+1]->ptr;
            if (sdslen(addr) < NET_HOST_STR_LEN) {
                if (c->slave_addr) sdsfree(c->slave_addr);
                c->slave_addr = sdsdup(addr);
            } else {
                addReplyErrorFormat(c,""REPLCONF ip-address provided by ""
                    ""replica instance is too ...",1,35,replication.c,replconfCommand,,false,1165,1280,replconfCommand,,,34,void replconfCommand (client*)
324444,METHOD,replication.c:<global>,TYPE_DECL,"int replicaPutOnline(client *slave) {
    if (slave->flags & CLIENT_REPL_RDBONLY) {
        slave->replstate = SLAVE_STATE_RDB_TRANSMITTED;
        /* The client asked for RDB only so we should close it ASAP */
        serverLog(LL_NOTICE,
                  ""RDB transfer completed, rdb only replica (%s) should be disconnected asap"",
                  replicationGetSlaveName(slave));
        return 0;
    }
    slave->replstate = SLAVE_STATE_ONLINE;
    slave->repl_ack_time = server.unixtime; /* Prevent false timeout. */

    refreshGoodSlavesCount();
    /* Fire the replica change modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,
                          REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,
                          NULL);
    serverLog(LL_NOTICE,""Synchronization with replica %s succeeded"",
        replicationGetSlaveName(slave));
    return 1;
}",1,23,replication.c,replicaPutOnline,,false,1292,1312,replicaPutOnline,,,35,int replicaPutOnline (client*)
324534,METHOD,replication.c:<global>,TYPE_DECL,"void replicaStartCommandStream(client *slave) {
    serverAssert(!(slave->flags & CLIENT_REPL_RDBONLY));
    slave->repl_start_cmd_stream_on_ack = 0;

    putClientInPendingWriteQueue(slave);
}",1,4,replication.c,replicaStartCommandStream,,false,1325,1330,replicaStartCommandStream,,,36,void replicaStartCommandStream (client*)
324567,METHOD,replication.c:<global>,TYPE_DECL,"void removeRDBUsedToSyncReplicas(void) {
    /* If the feature is disabled, return ASAP but also clear the
     * RDBGeneratedByReplication flag in case it was set. Otherwise if the
     * feature was enabled, but gets disabled later with CONFIG SET, the
     * flag may remain set to one: then next time the feature is re-enabled
     * via CONFIG SET we have it set even if no RDB was generated
     * because of replication recently. */
    if (!server.rdb_del_sync_files) {
        RDBGeneratedByReplication = 0;
        return;
    }

    if (allPersistenceDisabled() && RDBGeneratedByReplication) {
        client *slave;
        listNode *ln;
        listIter li;

        int delrdb = 1;
        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
                slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END ||
                slave->replstate == SLAVE_STATE_SEND_BULK...",1,36,replication.c,removeRDBUsedToSyncReplicas,,false,1337,1377,removeRDBUsedToSyncReplicas,,,37,void removeRDBUsedToSyncReplicas (void)
324681,METHOD,replication.c:<global>,TYPE_DECL,"void closeRepldbfd(client *myself) {
    listNode *ln;
    listIter li;
    int reclaim = 1;
    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        if (slave != myself && slave->replstate == SLAVE_STATE_SEND_BULK) {
            reclaim = 0;
            break;
        }
    }

    if (reclaim) {
        bioCreateCloseJob(myself->repldbfd, 0, 1);
    } else {
        close(myself->repldbfd);
    }
    myself->repldbfd = -1;
}",1,51,replication.c,closeRepldbfd,,false,1381,1400,closeRepldbfd,,,38,void closeRepldbfd (client*)
324749,METHOD,replication.c:<global>,TYPE_DECL,"void sendBulkToSlave(connection *conn) {
    client *slave = connGetPrivateData(conn);
    char buf[PROTO_IOBUF_LEN];
    ssize_t nwritten, buflen;

    /* Before sending the RDB file, we send the preamble as configured by the
     * replication process. Currently the preamble is just the bulk count of
     * the file in the form ""$<length>\r\n"". */
    if (slave->replpreamble) {
        nwritten = connWrite(conn,slave->replpreamble,sdslen(slave->replpreamble));
        if (nwritten == -1) {
            serverLog(LL_WARNING,
                ""Write error sending RDB preamble to replica: %s"",
                connGetLastError(conn));
            freeClient(slave);
            return;
        }
        atomicIncr(server.stat_net_repl_output_bytes, nwritten);
        sdsrange(slave->replpreamble,nwritten,-1);
        if (sdslen(slave->replpreamble) == 0) {
            sdsfree(slave->replpreamble);
            slave->replpreamble = NULL;
            /* fall through sending data. */
      ...",1,13,replication.c,sendBulkToSlave,,false,1402,1458,sendBulkToSlave,,,39,void sendBulkToSlave (connection*)
324968,METHOD,replication.c:<global>,TYPE_DECL,"void rdbPipeWriteHandlerConnRemoved(struct connection *conn) {
    if (!connHasWriteHandler(conn))
        return;
    connSetWriteHandler(conn, NULL);
    client *slave = connGetPrivateData(conn);
    slave->repl_last_partial_write = 0;
    server.rdb_pipe_numconns_writing--;
    /* if there are no more writes for now for this conn, or write error: */
    if (server.rdb_pipe_numconns_writing == 0) {
        if (aeCreateFileEvent(server.el, server.rdb_pipe_read, AE_READABLE, rdbPipeReadHandler,NULL) == AE_ERR) {
            serverPanic(""Unrecoverable error creating server.rdb_pipe_read file event."");
        }
    }
}",1,63,replication.c,rdbPipeWriteHandlerConnRemoved,,false,1462,1475,rdbPipeWriteHandlerConnRemoved,,,40,void rdbPipeWriteHandlerConnRemoved (connection*)
325030,METHOD,replication.c:<global>,TYPE_DECL,"void rdbPipeWriteHandler(struct connection *conn) {
    serverAssert(server.rdb_pipe_bufflen>0);
    client *slave = connGetPrivateData(conn);
    ssize_t nwritten;
    if ((nwritten = connWrite(conn, server.rdb_pipe_buff + slave->repldboff,
                              server.rdb_pipe_bufflen - slave->repldboff)) == -1)
    {
        if (connGetState(conn) == CONN_STATE_CONNECTED)
            return; /* equivalent to EAGAIN */
        serverLog(LL_WARNING,""Write error sending DB to replica: %s"",
            connGetLastError(conn));
        freeClient(slave);
        return;
    } else {
        slave->repldboff += nwritten;
        atomicIncr(server.stat_net_repl_output_bytes, nwritten);
        if (slave->repldboff < server.rdb_pipe_bufflen) {
            slave->repl_last_partial_write = server.unixtime;
            return; /* more data to write.. */
        }
    }
    rdbPipeWriteHandlerConnRemoved(conn);
}",1,4,replication.c,rdbPipeWriteHandler,,false,1479,1501,rdbPipeWriteHandler,,,41,void rdbPipeWriteHandler (connection*)
325143,METHOD,replication.c:<global>,TYPE_DECL,"void rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask) {
    UNUSED(mask);
    UNUSED(clientData);
    UNUSED(eventLoop);
    int i;
    if (!server.rdb_pipe_buff)
        server.rdb_pipe_buff = zmalloc(PROTO_IOBUF_LEN);
    serverAssert(server.rdb_pipe_numconns_writing==0);

    while (1) {
        server.rdb_pipe_bufflen = read(fd, server.rdb_pipe_buff, PROTO_IOBUF_LEN);
        if (server.rdb_pipe_bufflen < 0) {
            if (errno == EAGAIN || errno == EWOULDBLOCK)
                return;
            serverLog(LL_WARNING,""Diskless rdb transfer, read error sending DB to replicas: %s"", strerror(errno));
            for (i=0; i < server.rdb_pipe_numconns; i++) {
                connection *conn = server.rdb_pipe_conns[i];
                if (!conn)
                    continue;
                client *slave = connGetPrivateData(conn);
                freeClient(slave);
                server.rdb_pipe_conns[i] = NULL;
            }
            k...",1,4,replication.c,rdbPipeReadHandler,,false,1504,1596,rdbPipeReadHandler,,,42,"void rdbPipeReadHandler (aeEventLoop*,int,void*,int)"
325550,METHOD,replication.c:<global>,TYPE_DECL,"void updateSlavesWaitingBgsave(int bgsaveerr, int type) {
    listNode *ln;
    listIter li;

    /* Note: there's a chance we got here from within the REPLCONF ACK command
     * so we must avoid using freeClient, otherwise we'll crash on our way up. */

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
            struct redis_stat buf;

            if (bgsaveerr != C_OK) {
                freeClientAsync(slave);
                serverLog(LL_WARNING,""SYNC failed. BGSAVE child returned an error"");
                continue;
            }

            /* If this was an RDB on disk save, we have to prepare to send
             * the RDB from disk to the slave socket. Otherwise if this was
             * already an RDB -> Slaves socket transfer, used in the case of
             * diskless replication, our work is trivial, we can just put
             * the slave online....",1,32,replication.c,updateSlavesWaitingBgsave,,false,1604,1684,updateSlavesWaitingBgsave,,,43,"void updateSlavesWaitingBgsave (int,int)"
325757,METHOD,replication.c:<global>,TYPE_DECL,"void changeReplicationId(void) {
    getRandomHexChars(server.replid,CONFIG_RUN_ID_SIZE);
    server.replid[CONFIG_RUN_ID_SIZE] = '\0';
}",1,36,replication.c,changeReplicationId,,false,1690,1693,changeReplicationId,,,44,void changeReplicationId (void)
325778,METHOD,replication.c:<global>,TYPE_DECL,"void clearReplicationId2(void) {
    memset(server.replid2,'0',sizeof(server.replid));
    server.replid2[CONFIG_RUN_ID_SIZE] = '\0';
    server.second_replid_offset = -1;
}",1,19,replication.c,clearReplicationId2,,false,1698,1702,clearReplicationId2,,,45,void clearReplicationId2 (void)
325807,METHOD,replication.c:<global>,TYPE_DECL,"void shiftReplicationId(void) {
    memcpy(server.replid2,server.replid,sizeof(server.replid));
    /* We set the second replid offset to the master offset + 1, since
     * the slave will ask for the first byte it has not yet received, so
     * we need to add one to the offset: for example if, as a slave, we are
     * sure we have the same history as the master for 50 bytes, after we
     * are turned into a master, we can accept a PSYNC request with offset
     * 51, since the slave asking has the same history up to the 50th
     * byte, and is asking for the new bytes starting at offset 51. */
    server.second_replid_offset = server.master_repl_offset+1;
    changeReplicationId();
    serverLog(LL_NOTICE,""Setting secondary replication ID to %s, valid up to offset: %lld. New replication ID is %s"", server.replid2, server.second_replid_offset, server.replid);
}",1,4,replication.c,shiftReplicationId,,false,1709,1721,shiftReplicationId,,,46,void shiftReplicationId (void)
325860,METHOD,replication.c:<global>,TYPE_DECL,"int slaveIsInHandshakeState(void) {
    return server.repl_state >= REPL_STATE_RECEIVE_PING_REPLY &&
           server.repl_state <= REPL_STATE_RECEIVE_PSYNC_REPLY;
}",1,1,replication.c,slaveIsInHandshakeState,,false,1727,1730,slaveIsInHandshakeState,,,47,int slaveIsInHandshakeState (void)
325877,METHOD,replication.c:<global>,TYPE_DECL,"void replicationSendNewlineToMaster(void) {
    static time_t newline_sent;
    if (time(NULL) != newline_sent) {
        newline_sent = time(NULL);
        /* Pinging back in this stage is best-effort. */
        if (server.repl_transfer_s) connWrite(server.repl_transfer_s, ""\n"", 1);
    }
}",1,1,replication.c,replicationSendNewlineToMaster,,false,1740,1747,replicationSendNewlineToMaster,,,48,void replicationSendNewlineToMaster (void)
325904,METHOD,replication.c:<global>,TYPE_DECL,"void replicationEmptyDbCallback(dict *d) {
    UNUSED(d);
    if (server.repl_state == REPL_STATE_TRANSFER)
        replicationSendNewlineToMaster();
}",1,4,replication.c,replicationEmptyDbCallback,,false,1752,1756,replicationEmptyDbCallback,,,49,void replicationEmptyDbCallback (dict*)
325923,METHOD,replication.c:<global>,TYPE_DECL,"void replicationCreateMasterClient(connection *conn, int dbid) {
    server.master = createClient(conn);
    if (conn)
        connSetReadHandler(server.master->conn, readQueryFromClient);

    /**
     * Important note:
     * The CLIENT_DENY_BLOCKING flag is not, and should not, be set here.
     * For commands like BLPOP, it makes no sense to block the master
     * connection, and such blocking attempt will probably cause deadlock and
     * break the replication. We consider such a thing as a bug because
     * commands as BLPOP should never be sent on the replication link.
     * A possible use-case for blocking the replication link is if a module wants
     * to pass the execution to a background thread and unblock after the
     * execution is done. This is the reason why we allow blocking the replication
     * connection. */
    server.master->flags |= CLIENT_MASTER;

    server.master->authenticated = 1;
    server.master->reploff = server.master_initial_offset;
    serve...",1,28,replication.c,replicationCreateMasterClient,,false,1761,1790,replicationCreateMasterClient,,,50,"void replicationCreateMasterClient (connection*,int)"
326035,METHOD,replication.c:<global>,TYPE_DECL,"void restartAOFAfterSYNC(void) {
    unsigned int tries, max_tries = 10;
    for (tries = 0; tries < max_tries; ++tries) {
        if (startAppendOnly() == C_OK) break;
        serverLog(LL_WARNING,
            ""Failed enabling the AOF after successful master synchronization! ""
            ""Trying it again in one second."");
        sleep(1);
    }
    if (tries == max_tries) {
        serverLog(LL_WARNING,
            ""FATAL: this replica instance finished the synchronization with ""
            ""its master, but the AOF can't be turned on. Exiting now."");
        exit(1);
    }
}",1,33,replication.c,restartAOFAfterSYNC,,false,1796,1811,restartAOFAfterSYNC,,,51,void restartAOFAfterSYNC (void)
326109,METHOD,replication.c:<global>,TYPE_DECL,"static int useDisklessLoad(void) {
    /* compute boolean decision to use diskless load */
    int enabled = server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB ||
           (server.repl_diskless_load == REPL_DISKLESS_LOAD_WHEN_DB_EMPTY && dbTotalServerKeyCount()==0);

    if (enabled) {
        /* Check all modules handle read errors, otherwise it's not safe to use diskless load. */
        if (!moduleAllDatatypesHandleErrors()) {
            serverLog(LL_NOTICE,
                ""Skipping diskless-load because there are modules that don't handle read errors."");
            enabled = 0;
        }
        /* Check all modules handle async replication, otherwise it's not safe to use diskless load. */
        else if (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB && !moduleAllModulesHandleReplAsyncLoad()) {
            serverLog(LL_NOTICE,
                ""Skipping diskless-load because there are modules that are not aware of async replication."");
            enabled = 0;
...",1,47,replication.c,useDisklessLoad,,false,1813,1833,useDisklessLoad,,,52,int useDisklessLoad (void)
326201,METHOD,replication.c:<global>,TYPE_DECL,"redisDb *disklessLoadInitTempDb(void) {
    return initTempDb();
}",1,1,replication.c,disklessLoadInitTempDb,,false,1838,1840,disklessLoadInitTempDb,,,53,redisDb disklessLoadInitTempDb (void)
326208,METHOD,replication.c:<global>,TYPE_DECL,"void disklessLoadDiscardTempDb(redisDb *tempDb) {
    discardTempDb(tempDb, replicationEmptyDbCallback);
}",1,1,replication.c,disklessLoadDiscardTempDb,,false,1844,1846,disklessLoadDiscardTempDb,,,54,void disklessLoadDiscardTempDb (redisDb*)
326216,METHOD,replication.c:<global>,TYPE_DECL,"void replicationAttachToNewMaster(void) { 
    /* Replica starts to apply data from new master, we must discard the cached
     * master structure. */
    serverAssert(server.master == NULL);
    replicationDiscardCachedMaster();

    disconnectSlaves(); /* Force our replicas to resync with us as well. */
    freeReplicationBacklog(); /* Don't allow our chained replicas to PSYNC. */
}",1,4,replication.c,replicationAttachToNewMaster,,false,1852,1860,replicationAttachToNewMaster,,,55,void replicationAttachToNewMaster (void)
326242,METHOD,replication.c:<global>,TYPE_DECL,"void readSyncBulkPayload(connection *conn) {
    char buf[PROTO_IOBUF_LEN];
    ssize_t nread, readlen, nwritten;
    int use_diskless_load = useDisklessLoad();
    redisDb *diskless_load_tempDb = NULL;
    functionsLibCtx* temp_functions_lib_ctx = NULL;
    int empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :
                                                        EMPTYDB_NO_FLAGS;
    off_t left;

    /* Static vars used to hold the EOF mark, and the last bytes received
     * from the server: when they match, we reached the end of the transfer. */
    static char eofmark[CONFIG_RUN_ID_SIZE];
    static char lastbytes[CONFIG_RUN_ID_SIZE];
    static int usemark = 0;

    /* If repl_transfer_size == -1 we still have to read the bulk length
     * from the master reply. */
    if (server.repl_transfer_size == -1) {
        nread = connSyncReadLine(conn,buf,1024,server.repl_syncio_timeout*1000);
        if (nread == -1) {
            serverLog(LL_WARNING,
             ...",1,13,replication.c,readSyncBulkPayload,,false,1864,2296,readSyncBulkPayload,,,56,void readSyncBulkPayload (connection*)
327613,METHOD,replication.c:<global>,TYPE_DECL,"char *receiveSynchronousResponse(connection *conn) {
    char buf[256];
    /* Read the reply from the server. */
    if (connSyncReadLine(conn,buf,sizeof(buf),server.repl_syncio_timeout*1000) == -1)
    {
        serverLog(LL_WARNING, ""Failed to read response from the server: %s"", connGetLastError(conn));
        return NULL;
    }
    server.repl_transfer_lastio = server.unixtime;
    return sdsnew(buf);
}",1,8,replication.c,receiveSynchronousResponse,,false,2298,2308,receiveSynchronousResponse,,,57,char* receiveSynchronousResponse (connection*)
327666,METHOD,replication.c:<global>,TYPE_DECL,"char* sendCommandRaw(connection *conn, sds cmd) {
    if (connSyncWrite(conn,cmd,sdslen(cmd),server.repl_syncio_timeout*1000) == -1) {
        return sdscatprintf(sdsempty(),""-Writing to master: %s"",
                connGetLastError(conn));
    }
    return NULL;
}",1,1,replication.c,sendCommandRaw,,false,2311,2317,sendCommandRaw,,,58,"char* sendCommandRaw (connection*,sds)"
327695,METHOD,replication.c:<global>,TYPE_DECL,"char *sendCommand(connection *conn, ...) {
    va_list ap;
    sds cmd = sdsempty();
    sds cmdargs = sdsempty();
    size_t argslen = 0;
    char *arg;

    /* Create the command to send to the master, we use redis binary
     * protocol to make sure correct arguments are sent. This function
     * is not safe for all binary data. */
    va_start(ap,conn);
    while(1) {
        arg = va_arg(ap, char*);
        if (arg == NULL) break;
        cmdargs = sdscatprintf(cmdargs,""$%zu\r\n%s\r\n"",strlen(arg),arg);
        argslen++;
    }

    cmd = sdscatprintf(cmd,""*%zu\r\n"",argslen);
    cmd = sdscatsds(cmd,cmdargs);
    sdsfree(cmdargs);

    va_end(ap);
    char* err = sendCommandRaw(conn, cmd);
    sdsfree(cmd);
    if(err)
        return err;
    return NULL;
}",1,1,replication.c,sendCommand,,false,2328,2356,sendCommand,,,59,char* sendCommand (connection*...)
327767,METHOD,replication.c:<global>,TYPE_DECL,"char *sendCommandArgv(connection *conn, int argc, char **argv, size_t *argv_lens) {
    sds cmd = sdsempty();
    char *arg;
    int i;

    /* Create the command to send to the master. */
    cmd = sdscatfmt(cmd,""*%i\r\n"",argc);
    for (i=0; i<argc; i++) {
        int len;
        arg = argv[i];
        len = argv_lens ? argv_lens[i] : strlen(arg);
        cmd = sdscatfmt(cmd,""$%i\r\n"",len);
        cmd = sdscatlen(cmd,arg,len);
        cmd = sdscatlen(cmd,""\r\n"",2);
    }
    char* err = sendCommandRaw(conn, cmd);
    sdsfree(cmd);
    if (err)
        return err;
    return NULL;
}",1,1,replication.c,sendCommandArgv,,false,2367,2387,sendCommandArgv,,,60,"char* sendCommandArgv (connection*,int,char**,size_t*)"
327846,METHOD,replication.c:<global>,TYPE_DECL,"int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    char *psync_replid;
    char psync_offset[32];
    sds reply;

    /* Writing half */
    if (!read_reply) {
        /* Initially set master_initial_offset to -1 to mark the current
         * master replid and offset as not valid. Later if we'll be able to do
         * a FULL resync using the PSYNC command we'll set the offset at the
         * right value, so that this information will be propagated to the
         * client structure representing the master into server.master. */
        server.master_initial_offset = -1;

        if (server.cached_master) {
            psync_replid = server.cached_master->replid;
            snprintf(psync_offset,sizeof(psync_offset),""%lld"", server.cached_master->reploff+1);
            serverLog(LL_NOTICE,""Trying a partial resynchronization (request %s:%s)."", psync_replid, psync_offset);
        } else {
            serverLog(LL_NOTICE,""Partial resynchronization not po...",1,12,replication.c,slaveTryPartialResynchronization,,false,2443,2610,slaveTryPartialResynchronization,,,61,"int slaveTryPartialResynchronization (connection*,int)"
328444,METHOD,replication.c:<global>,TYPE_DECL,"void syncWithMaster(connection *conn) {
    char tmpfile[256], *err = NULL;
    int dfd = -1, maxtries = 5;
    int psync_result;

    /* If this event fired after the user turned the instance into a master
     * with SLAVEOF NO ONE we must just return ASAP. */
    if (server.repl_state == REPL_STATE_NONE) {
        connClose(conn);
        return;
    }

    /* Check for errors in the socket: after a non blocking connect() we
     * may find that the socket is in error state. */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {
        serverLog(LL_WARNING,""Error condition on socket for SYNC: %s"",
                connGetLastError(conn));
        goto error;
    }

    /* Send a PING to check the master is able to reply without errors. */
    if (server.repl_state == REPL_STATE_CONNECTING) {
        serverLog(LL_NOTICE,""Non blocking connect for SYNC fired the event."");
        /* Delete the writable event so that the readable event remains
         * registered and we can wait ...",1,8,replication.c,syncWithMaster,,false,2614,2925,syncWithMaster,,,62,void syncWithMaster (connection*)
329505,METHOD,replication.c:<global>,TYPE_DECL,"int connectWithMaster(void) {
    server.repl_transfer_s = connCreate(connTypeOfReplication());
    if (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,
                server.bind_source_addr, syncWithMaster) == C_ERR) {
        serverLog(LL_WARNING,""Unable to connect to MASTER: %s"",
                connGetLastError(server.repl_transfer_s));
        connClose(server.repl_transfer_s);
        server.repl_transfer_s = NULL;
        return C_ERR;
    }


    server.repl_transfer_lastio = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTING;
    serverLog(LL_NOTICE,""MASTER <-> REPLICA sync started"");
    return C_OK;
}",1,60,replication.c,connectWithMaster,,false,2927,2943,connectWithMaster,,,63,int connectWithMaster (void)
329607,METHOD,replication.c:<global>,TYPE_DECL,"void undoConnectWithMaster(void) {
    connClose(server.repl_transfer_s);
    server.repl_transfer_s = NULL;
}",1,1,replication.c,undoConnectWithMaster,,false,2949,2952,undoConnectWithMaster,,,64,void undoConnectWithMaster (void)
329621,METHOD,replication.c:<global>,TYPE_DECL,"void replicationAbortSyncTransfer(void) {
    serverAssert(server.repl_state == REPL_STATE_TRANSFER);
    undoConnectWithMaster();
    if (server.repl_transfer_fd!=-1) {
        close(server.repl_transfer_fd);
        bg_unlink(server.repl_transfer_tmpfile);
        zfree(server.repl_transfer_tmpfile);
        server.repl_transfer_tmpfile = NULL;
        server.repl_transfer_fd = -1;
    }
}",1,4,replication.c,replicationAbortSyncTransfer,,false,2957,2967,replicationAbortSyncTransfer,,,65,void replicationAbortSyncTransfer (void)
329676,METHOD,replication.c:<global>,TYPE_DECL,"int cancelReplicationHandshake(int reconnect) {
    if (server.repl_state == REPL_STATE_TRANSFER) {
        replicationAbortSyncTransfer();
        server.repl_state = REPL_STATE_CONNECT;
    } else if (server.repl_state == REPL_STATE_CONNECTING ||
               slaveIsInHandshakeState())
    {
        undoConnectWithMaster();
        server.repl_state = REPL_STATE_CONNECT;
    } else {
        return 0;
    }

    if (!reconnect)
        return 1;

    /* try to re-connect without waiting for replicationCron, this is needed
     * for the ""diskless loading short read"" test. */
    serverLog(LL_NOTICE,""Reconnecting to MASTER %s:%d after failure"",
        server.masterhost, server.masterport);
    connectWithMaster();

    return 1;
}",1,4,replication.c,cancelReplicationHandshake,,false,2977,3000,cancelReplicationHandshake,,,66,int cancelReplicationHandshake (int)
329748,METHOD,replication.c:<global>,TYPE_DECL,"void replicationSetMaster(char *ip, int port) {
    int was_master = server.masterhost == NULL;

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) {
        freeClient(server.master);
    }
    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. */

    /* Setting masterhost only after the call to freeClient since it calls
     * replicationHandleMasterDisconnection which can trigger a re-connect
     * directly from within that call. */
    server.masterhost = sdsnew(ip);
    server.masterport = port;

    /* Update oom_score_adj */
    setOOMScoreAdj(-1);

    /* Here we don't disconnect with replicas, since they may hopefully be able
     * to partially resync with us. We will disconnect with replicas and force
     * them to resync with us when changing replid on partially resync with new
     * master, or finishing transferring RDB and preparing loading DB on full
     * sync with new master. */

    cancelReplicationHandsh...",1,26,replication.c,replicationSetMaster,,false,3003,3051,replicationSetMaster,,,67,"void replicationSetMaster (char*,int)"
329855,METHOD,replication.c:<global>,TYPE_DECL,"void replicationUnsetMaster(void) {
    if (server.masterhost == NULL) return; /* Nothing to do. */

    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    /* Clear masterhost first, since the freeClient calls
     * replicationHandleMasterDisconnection which can attempt to re-connect. */
    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) freeClient(server.master);
    replicationDiscardCachedMaster();
    cancelReplicationHandshake(0);
    /* When a slave is turned into a master, the current replication ID
     * (that was inherited from the master at synchronization time) is
     * used as secondary ID up to the current offset, and a new replication
     * ID is created to continue with a new replication history. */
    shiftRepli...",1,30,replication.c,replicationUnsetMaster,,false,3054,3108,replicationUnsetMaster,,,68,void replicationUnsetMaster (void)
329954,METHOD,replication.c:<global>,TYPE_DECL,"void replicationHandleMasterDisconnection(void) {
    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    server.master = NULL;
    server.repl_state = REPL_STATE_CONNECT;
    server.repl_down_since = server.unixtime;
    /* We lost connection with our master, don't disconnect slaves yet,
     * maybe we'll be able to PSYNC with our master later. We'll disconnect
     * the slaves only if we'll have to do a full resync with our master. */

    /* Try to re-connect immediately rather than wait for replicationCron
     * waiting 1 second may risk backlog being recycled. */
    if (server.masterhost) {
        serverLog(LL_NOTICE,""Reconnecting to MASTER %s:%d"",
            server.masterhost, server.masterport);
        connectWithMaster();
    }
}",1,30,replication.c,replicationHandleMasterDisconnection,,false,3112,3133,replicationHandleMasterDisconnection,,,69,void replicationHandleMasterDisconnection (void)
330021,METHOD,replication.c:<global>,TYPE_DECL,"void replicaofCommand(client *c) {
    /* SLAVEOF is not allowed in cluster mode as replication is automatically
     * configured using the current address of the master node. */
    if (server.cluster_enabled) {
        addReplyError(c,""REPLICAOF not allowed in cluster mode."");
        return;
    }

    if (server.failover_state != NO_FAILOVER) {
        addReplyError(c,""REPLICAOF not allowed while failing over."");
        return;
    }

    /* The special host/port combination ""NO"" ""ONE"" turns the instance
     * into a master. Otherwise the new master address is set. */
    if (!strcasecmp(c->argv[1]->ptr,""no"") &&
        !strcasecmp(c->argv[2]->ptr,""one"")) {
        if (server.masterhost) {
            replicationUnsetMaster();
            sds client = catClientInfoString(sdsempty(),c);
            serverLog(LL_NOTICE,""MASTER MODE enabled (user request from '%s')"",
                client);
            sdsfree(client);
        }
    } else {
        long port;

        if (c->f...",1,12,replication.c,replicaofCommand,,false,3135,3194,replicaofCommand,,,70,void replicaofCommand (client*)
330233,METHOD,replication.c:<global>,TYPE_DECL,"void roleCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelRoleCommand(c);
        return;
    }

    if (server.masterhost == NULL) {
        listIter li;
        listNode *ln;
        void *mbcount;
        int slaves = 0;

        addReplyArrayLen(c,3);
        addReplyBulkCBuffer(c,""master"",6);
        addReplyLongLong(c,server.master_repl_offset);
        mbcount = addReplyDeferredLen(c);
        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            char ip[NET_IP_STR_LEN], *slaveaddr = slave->slave_addr;

            if (!slaveaddr) {
                if (connAddrPeerName(slave->conn,ip,sizeof(ip),NULL) == -1)
                    continue;
                slaveaddr = ip;
            }
            if (slave->replstate != SLAVE_STATE_ONLINE) continue;
            addReplyArrayLen(c,3);
            addReplyBulkCString(c,slaveaddr);
            addReplyBulkLongLong(c,slave->slave_listening_port);
 ...",1,20,replication.c,roleCommand,,false,3199,3255,roleCommand,,,71,void roleCommand (client*)
330442,METHOD,replication.c:<global>,TYPE_DECL,"void replicationSendAck(void) {
    client *c = server.master;

    if (c != NULL) {
        int send_fack = server.fsynced_reploff != -1;
        c->flags |= CLIENT_MASTER_FORCE_REPLY;
        addReplyArrayLen(c,send_fack ? 5 : 3);
        addReplyBulkCString(c,""REPLCONF"");
        addReplyBulkCString(c,""ACK"");
        addReplyBulkLongLong(c,c->reploff);
        if (send_fack) {
            addReplyBulkCString(c,""FACK"");
            addReplyBulkLongLong(c,server.fsynced_reploff);
        }
        c->flags &= ~CLIENT_MASTER_FORCE_REPLY;
    }
}",1,20,replication.c,replicationSendAck,,false,3260,3276,replicationSendAck,,,72,void replicationSendAck (void)
330514,METHOD,replication.c:<global>,TYPE_DECL,"void replicationCacheMaster(client *c) {
    serverAssert(server.master != NULL && server.cached_master == NULL);
    serverLog(LL_NOTICE,""Caching the disconnected master state."");

    /* Unlink the client from the server structures. */
    unlinkClient(c);

    /* Reset the master client so that's ready to accept new commands:
     * we want to discard the non processed query buffers and non processed
     * offsets, including pending transactions, already populated arguments,
     * pending outputs to the master. */
    sdsclear(server.master->querybuf);
    server.master->qb_pos = 0;
    server.master->repl_applied = 0;
    server.master->read_reploff = server.master->reploff;
    if (c->flags & CLIENT_MULTI) discardTransaction(c);
    listEmpty(c->reply);
    c->sentlen = 0;
    c->reply_bytes = 0;
    c->bufpos = 0;
    resetClient(c);

    /* Save the master. Server.master will be set to null later by
     * replicationHandleMasterDisconnection(). */
    server.cached_master ...",1,4,replication.c,replicationCacheMaster,,false,3298,3339,replicationCacheMaster,,,73,void replicationCacheMaster (client*)
330664,METHOD,replication.c:<global>,TYPE_DECL,"void replicationCacheMasterUsingMyself(void) {
    serverLog(LL_NOTICE,
        ""Before turning into a replica, using my own master parameters ""
        ""to synthesize a cached master: I may be able to synchronize with ""
        ""the new master with just a partial transfer."");

    /* This will be used to populate the field server.master->reploff
     * by replicationCreateMasterClient(). We'll later set the created
     * master as server.cached_master, so the replica will use such
     * offset for PSYNC. */
    server.master_initial_offset = server.master_repl_offset;

    /* The master client we create can be set to any DBID, because
     * the new master will start its replication stream with SELECT. */
    replicationCreateMasterClient(NULL,-1);

    /* Use our own ID / offset. */
    memcpy(server.master->replid, server.replid, sizeof(server.replid));

    /* Set as cached master. */
    unlinkClient(server.master);
    server.cached_master = server.master;
    server.master ...",1,4,replication.c,replicationCacheMasterUsingMyself,,false,3350,3373,replicationCacheMasterUsingMyself,,,74,void replicationCacheMasterUsingMyself (void)
330727,METHOD,replication.c:<global>,TYPE_DECL,"void replicationDiscardCachedMaster(void) {
    if (server.cached_master == NULL) return;

    serverLog(LL_NOTICE,""Discarding previously cached master state."");
    server.cached_master->flags &= ~CLIENT_MASTER;
    freeClient(server.cached_master);
    server.cached_master = NULL;
}",1,4,replication.c,replicationDiscardCachedMaster,,false,3377,3384,replicationDiscardCachedMaster,,,75,void replicationDiscardCachedMaster (void)
330779,METHOD,replication.c:<global>,TYPE_DECL,"void replicationResurrectCachedMaster(connection *conn) {
    server.master = server.cached_master;
    server.cached_master = NULL;
    server.master->conn = conn;
    connSetPrivateData(server.master->conn, server.master);
    server.master->flags &= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);
    server.master->authenticated = 1;
    server.master->lastinteraction = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTED;
    server.repl_down_since = 0;

    /* Fire the master link modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,
                          NULL);

    /* Re-add to the list of clients. */
    linkClient(server.master);
    if (connSetReadHandler(server.master->conn, readQueryFromClient)) {
        serverLog(LL_WARNING,""Error resurrecting the cached master, impossible to add the readable handler: %s"", strerror(errno));
        freeClientAsync(server.master); /* C...",1,30,replication.c,replicationResurrectCachedMaster,,false,3392,3423,replicationResurrectCachedMaster,,,76,void replicationResurrectCachedMaster (connection*)
330940,METHOD,replication.c:<global>,TYPE_DECL,"void refreshGoodSlavesCount(void) {
    listIter li;
    listNode *ln;
    int good = 0;

    if (!server.repl_min_slaves_to_write ||
        !server.repl_min_slaves_max_lag) return;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;
        time_t lag = server.unixtime - slave->repl_ack_time;

        if (slave->replstate == SLAVE_STATE_ONLINE &&
            lag <= server.repl_min_slaves_max_lag) good++;
    }
    server.repl_good_slaves_count = good;
}",1,32,replication.c,refreshGoodSlavesCount,,false,3430,3447,refreshGoodSlavesCount,,,77,void refreshGoodSlavesCount (void)
331014,METHOD,replication.c:<global>,TYPE_DECL,"int checkGoodReplicasStatus(void) {
    return server.masterhost || /* not a primary status should be OK */
           !server.repl_min_slaves_max_lag || /* Min slave max lag not configured */
           !server.repl_min_slaves_to_write || /* Min slave to write not configured */
           server.repl_good_slaves_count >= server.repl_min_slaves_to_write; /* check if we have enough slaves */
}",1,1,replication.c,checkGoodReplicasStatus,,false,3450,3455,checkGoodReplicasStatus,,,78,int checkGoodReplicasStatus (void)
331041,METHOD,replication.c:<global>,TYPE_DECL,"void replicationRequestAckFromSlaves(void) {
    server.get_ack_from_slaves = 1;
}",1,1,replication.c,replicationRequestAckFromSlaves,,false,3487,3489,replicationRequestAckFromSlaves,,,79,void replicationRequestAckFromSlaves (void)
331051,METHOD,replication.c:<global>,TYPE_DECL,"int replicationCountAcksByOffset(long long offset) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        if (slave->repl_ack_off >= offset) count++;
    }
    return count;
}",1,32,replication.c,replicationCountAcksByOffset,,false,3493,3506,replicationCountAcksByOffset,,,80,int replicationCountAcksByOffset (long long)
331102,METHOD,replication.c:<global>,TYPE_DECL,"int replicationCountAOFAcksByOffset(long long offset) {
    listIter li;
    listNode *ln;
    int count = 0;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        client *slave = ln->value;

        if (slave->replstate != SLAVE_STATE_ONLINE) continue;
        if (slave->repl_aof_off >= offset) count++;
    }
    return count;
}",1,32,replication.c,replicationCountAOFAcksByOffset,,false,3510,3523,replicationCountAOFAcksByOffset,,,81,int replicationCountAOFAcksByOffset (long long)
331153,METHOD,replication.c:<global>,TYPE_DECL,"void waitCommand(client *c) {
    mstime_t timeout;
    long numreplicas, ackreplicas;
    long long offset = c->woff;

    if (server.masterhost) {
        addReplyError(c,""WAIT cannot be used with replica instances. Please also note that since Redis 4.0 if a replica is configured to be writable (which is not the default) writes to replicas are just local and are not propagated."");
        return;
    }

    /* Argument parsing. */
    if (getLongFromObjectOrReply(c,c->argv[1],&numreplicas,NULL) != C_OK)
        return;
    if (getTimeoutFromObjectOrReply(c,c->argv[2],&timeout,UNIT_MILLISECONDS)
        != C_OK) return;

    /* First try without blocking at all. */
    ackreplicas = replicationCountAcksByOffset(c->woff);
    if (ackreplicas >= numreplicas || c->flags & CLIENT_DENY_BLOCKING) {
        addReplyLongLong(c,ackreplicas);
        return;
    }

    /* Otherwise block the client and put it into our list of clients
     * waiting for ack from slaves. */
    blockForReplica...",1,68,replication.c,waitCommand,,false,3527,3557,waitCommand,,,82,void waitCommand (client*)
331243,METHOD,replication.c:<global>,TYPE_DECL,"void waitaofCommand(client *c) {
    mstime_t timeout;
    long numreplicas, numlocal, ackreplicas, acklocal;

    /* Argument parsing. */
    if (getRangeLongFromObjectOrReply(c,c->argv[1],0,1,&numlocal,NULL) != C_OK)
        return;
    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&numreplicas,NULL) != C_OK)
        return;
    if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_MILLISECONDS) != C_OK)
        return;

    if (server.masterhost) {
        addReplyError(c,""WAITAOF cannot be used with replica instances. Please also note that writes to replicas are just local and are not propagated."");
        return;
    }
    if (numlocal && !server.aof_enabled) {
        addReplyError(c, ""WAITAOF cannot be used when numlocal is set but appendonly is disabled."");
        return;
    }

    /* First try without blocking at all. */
    ackreplicas = replicationCountAOFAcksByOffset(c->woff);
    acklocal = server.fsynced_reploff >= c->woff;
    if ((ackreplicas >= numreplic...",1,74,replication.c,waitaofCommand,,false,3561,3599,waitaofCommand,,,83,void waitaofCommand (client*)
331382,METHOD,replication.c:<global>,TYPE_DECL,"void unblockClientWaitingReplicas(client *c) {
    listNode *ln = listSearchKey(server.clients_waiting_acks,c);
    serverAssert(ln != NULL);
    listDelNode(server.clients_waiting_acks,ln);
    updateStatsOnUnblock(c, 0, 0, 0);
}",1,4,replication.c,unblockClientWaitingReplicas,,false,3605,3610,unblockClientWaitingReplicas,,,84,void unblockClientWaitingReplicas (client*)
331421,METHOD,replication.c:<global>,TYPE_DECL,"void processClientsWaitingReplicas(void) {
    long long last_offset = 0;
    long long last_aof_offset = 0;
    int last_numreplicas = 0;
    int last_aof_numreplicas = 0;

    listIter li;
    listNode *ln;

    listRewind(server.clients_waiting_acks,&li);
    while((ln = listNext(&li))) {
        int numlocal = 0;
        int numreplicas = 0;

        client *c = ln->value;
        int is_wait_aof = c->bstate.btype == BLOCKED_WAITAOF;

        if (is_wait_aof && c->bstate.numlocal && !server.aof_enabled) {
            addReplyError(c, ""WAITAOF cannot be used when numlocal is set but appendonly is disabled."");
            unblockClient(c, 1);
            continue;
        }

        /* Every time we find a client that is satisfied for a given
         * offset and number of replicas, we remember it so the next client
         * may be unblocked without calling replicationCountAcksByOffset()
         * or calling replicationCountAOFAcksByOffset()
         * if the requested offset ...",1,1,replication.c,processClientsWaitingReplicas,,false,3614,3685,processClientsWaitingReplicas,,,85,void processClientsWaitingReplicas (void)
331650,METHOD,replication.c:<global>,TYPE_DECL,"long long replicationGetSlaveOffset(void) {
    long long offset = 0;

    if (server.masterhost != NULL) {
        if (server.master) {
            offset = server.master->reploff;
        } else if (server.cached_master) {
            offset = server.cached_master->reploff;
        }
    }
    /* offset may be -1 when the master does not support it at all, however
     * this function is designed to return an offset that can express the
     * amount of data processed by the master, so we return a positive
     * integer. */
    if (offset < 0) offset = 0;
    return offset;
}",1,1,replication.c,replicationGetSlaveOffset,,false,3689,3705,replicationGetSlaveOffset,,,86,long long replicationGetSlaveOffset (void)
331702,METHOD,replication.c:<global>,TYPE_DECL,"void replicationCron(void) {
    static long long replication_cron_loops = 0;

    /* Check failover status first, to see if we need to start
     * handling the failover. */
    updateFailoverStatus();

    /* Non blocking connection timeout? */
    if (server.masterhost &&
        (server.repl_state == REPL_STATE_CONNECTING ||
         slaveIsInHandshakeState()) &&
         (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
    {
        serverLog(LL_WARNING,""Timeout connecting to the MASTER..."");
        cancelReplicationHandshake(1);
    }

    /* Bulk transfer I/O timeout? */
    if (server.masterhost && server.repl_state == REPL_STATE_TRANSFER &&
        (time(NULL)-server.repl_transfer_lastio) > server.repl_timeout)
    {
        serverLog(LL_WARNING,""Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."");
        cancelReplicationHandshake(1);
    }

    /* Timed out master wh...",1,8,replication.c,replicationCron,,false,3710,3905,replicationCron,,,87,void replicationCron (void)
332301,METHOD,replication.c:<global>,TYPE_DECL,"int shouldStartChildReplication(int *mincapa_out, int *req_out) {
    /* We should start a BGSAVE good for replication if we have slaves in
     * WAIT_BGSAVE_START state.
     *
     * In case of diskless replication, we make sure to wait the specified
     * number of seconds (according to configuration) so that other slaves
     * have the time to arrive before we start streaming. */
    if (!hasActiveChildProcess()) {
        time_t idle, max_idle = 0;
        int slaves_waiting = 0;
        int mincapa;
        int req;
        int first = 1;
        listNode *ln;
        listIter li;

        listRewind(server.slaves,&li);
        while((ln = listNext(&li))) {
            client *slave = ln->value;
            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START) {
                if (first) {
                    /* Get first slave's requirements */
                    req = slave->slave_req;
                } else if (req != slave->slave_req) {
                    /* Skip sl...",1,36,replication.c,shouldStartChildReplication,,false,3907,3957,shouldStartChildReplication,,,88,"int shouldStartChildReplication (int*,int*)"
332452,METHOD,replication.c:<global>,TYPE_DECL,"void replicationStartPendingFork(void) {
    int mincapa = -1;
    int req = -1;

    if (shouldStartChildReplication(&mincapa, &req)) {
        /* Start the BGSAVE. The called function may start a
         * BGSAVE with socket target or disk target depending on the
         * configuration and slaves capabilities and requirements. */
        startBgsaveForReplication(mincapa, req);
    }
}",1,1,replication.c,replicationStartPendingFork,,false,3959,3969,replicationStartPendingFork,,,89,void replicationStartPendingFork (void)
332477,METHOD,replication.c:<global>,TYPE_DECL,"static client *findReplica(char *host, int port) {
    listIter li;
    listNode *ln;
    client *replica;

    listRewind(server.slaves,&li);
    while((ln = listNext(&li))) {
        replica = ln->value;
        char ip[NET_IP_STR_LEN], *replicaip = replica->slave_addr;

        if (!replicaip) {
            if (connAddrPeerName(replica->conn, ip, sizeof(ip), NULL) == -1)
                continue;
            replicaip = ip;
        }

        if (!strcasecmp(host, replicaip) &&
                (port == replica->slave_listening_port))
            return replica;
    }

    return NULL;
}",1,16,replication.c,findReplica,,false,3972,3994,findReplica,,,90,"client findReplica (char*,int)"
332548,METHOD,replication.c:<global>,TYPE_DECL,"const char *getFailoverStateString(void) {
    switch(server.failover_state) {
        case NO_FAILOVER: return ""no-failover"";
        case FAILOVER_IN_PROGRESS: return ""failover-in-progress"";
        case FAILOVER_WAIT_FOR_SYNC: return ""waiting-for-sync"";
        default: return ""unknown"";
    }
}",1,1,replication.c,getFailoverStateString,,false,3996,4003,getFailoverStateString,,,91,const char* getFailoverStateString (void)
332573,METHOD,replication.c:<global>,TYPE_DECL,"void clearFailoverState(void) {
    server.failover_end_time = 0;
    server.force_failover = 0;
    zfree(server.target_replica_host);
    server.target_replica_host = NULL;
    server.target_replica_port = 0;
    server.failover_state = NO_FAILOVER;
    unpauseActions(PAUSE_DURING_FAILOVER);
}",1,1,replication.c,clearFailoverState,,false,4008,4016,clearFailoverState,,,92,void clearFailoverState (void)
332609,METHOD,replication.c:<global>,TYPE_DECL,"void abortFailover(const char *err) {
    if (server.failover_state == NO_FAILOVER) return;

    if (server.target_replica_host) {
        serverLog(LL_NOTICE,""FAILOVER to %s:%d aborted: %s"",
            server.target_replica_host,server.target_replica_port,err);  
    } else {
        serverLog(LL_NOTICE,""FAILOVER to any replica aborted: %s"",err);  
    }
    if (server.failover_state == FAILOVER_IN_PROGRESS) {
        replicationUnsetMaster();
    }
    clearFailoverState();
}",1,8,replication.c,abortFailover,,false,4019,4032,abortFailover,,,93,void abortFailover (char*)
332682,METHOD,replication.c:<global>,TYPE_DECL,"void failoverCommand(client *c) {
    if (server.cluster_enabled) {
        addReplyError(c,""FAILOVER not allowed in cluster mode. ""
                        ""Use CLUSTER FAILOVER command instead."");
        return;
    }
    
    /* Handle special case for abort */
    if ((c->argc == 2) && !strcasecmp(c->argv[1]->ptr,""abort"")) {
        if (server.failover_state == NO_FAILOVER) {
            addReplyError(c, ""No failover in progress."");
            return;
        }

        abortFailover(""Failover manually aborted"");
        addReply(c,shared.ok);
        return;
    }

    long timeout_in_ms = 0;
    int force_flag = 0;
    long port = 0;
    char *host = NULL;

    /* Parse the command for syntax and arguments. */
    for (int j = 1; j < c->argc; j++) {
        if (!strcasecmp(c->argv[j]->ptr,""timeout"") && (j + 1 < c->argc) &&
            timeout_in_ms == 0)
        {
            if (getLongFromObjectOrReply(c,c->argv[j + 1],
                        &timeout_in_ms,NULL) != C_OK)...",1,48,replication.c,failoverCommand,,false,4061,4168,failoverCommand,,,94,void failoverCommand (client*)
333085,METHOD,replication.c:<global>,TYPE_DECL,"void updateFailoverStatus(void) {
    if (server.failover_state != FAILOVER_WAIT_FOR_SYNC) return;
    mstime_t now = server.mstime;

    /* Check if failover operation has timed out */
    if (server.failover_end_time && server.failover_end_time <= now) {
        if (server.force_failover) {
            serverLog(LL_NOTICE,
                ""FAILOVER to %s:%d time out exceeded, failing over."",
                server.target_replica_host, server.target_replica_port);
            server.failover_state = FAILOVER_IN_PROGRESS;
            /* If timeout has expired force a failover if requested. */
            replicationSetMaster(server.target_replica_host,
                server.target_replica_port);
            return;
        } else {
            /* Force was not requested, so timeout. */
            abortFailover(""Replica never caught up before timeout"");
            return;
        }
    }

    /* Check to see if the replica has caught up so failover can start */
    client *replica...",1,12,replication.c,updateFailoverStatus,,false,4177,4239,updateFailoverStatus,,,95,void updateFailoverStatus (void)
333307,METHOD,resp_parser.c:<global>,TYPE_DECL,<global>,1,1,resp_parser.c,resp_parser.c:<global>,,false,1,228,<global>,,,1,
333309,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseBulk(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long bulklen;
    parser->curr_location = p + 2; /* for \r\n */

    string2ll(proto+1,p-proto-1,&bulklen);
    if (bulklen == -1) {
        parser->callbacks.null_bulk_string_callback(p_ctx, proto, parser->curr_location - proto);
    } else {
        const char *str = parser->curr_location;
        parser->curr_location += bulklen;
        parser->curr_location += 2; /* for \r\n */
        parser->callbacks.bulk_string_callback(p_ctx, str, bulklen, proto, parser->curr_location - proto);
    }

    return C_OK;
}",1,11,resp_parser.c,parseBulk,,false,61,78,parseBulk,,,1,"int parseBulk (ReplyParser*,void*)"
333404,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseSimpleString(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.simple_str_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseSimpleString,,false,80,86,parseSimpleString,,,2,"int parseSimpleString (ReplyParser*,void*)"
333456,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseError(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; // for \r\n
    parser->callbacks.error_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseError,,false,88,94,parseError,,,3,"int parseError (ReplyParser*,void*)"
333508,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseLong(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    long long val;
    string2ll(proto+1,p-proto-1,&val);
    parser->callbacks.long_callback(p_ctx, val, proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseLong,,false,96,104,parseLong,,,4,"int parseLong (ReplyParser*,void*)"
333565,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseAttributes(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.attribute_callback(parser, p_ctx, len, proto);
    return C_OK;
}",1,11,resp_parser.c,parseAttributes,,false,106,115,parseAttributes,,,5,"int parseAttributes (ReplyParser*,void*)"
333619,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseVerbatimString(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long bulklen;
    parser->curr_location = p + 2; /* for \r\n */
    string2ll(proto+1,p-proto-1,&bulklen);
    const char *format = parser->curr_location;
    parser->curr_location += bulklen;
    parser->curr_location += 2; /* for \r\n */
    parser->callbacks.verbatim_string_callback(p_ctx, format, format + 4, bulklen - 4, proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseVerbatimString,,false,117,128,parseVerbatimString,,,6,"int parseVerbatimString (ReplyParser*,void*)"
333698,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseBigNumber(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.big_number_callback(p_ctx, proto+1, p-proto-1, proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseBigNumber,,false,130,136,parseBigNumber,,,7,"int parseBigNumber (ReplyParser*,void*)"
333750,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseNull(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.null_callback(p_ctx, proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseNull,,false,138,144,parseNull,,,8,"int parseNull (ReplyParser*,void*)"
333794,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseDouble(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    char buf[MAX_LONG_DOUBLE_CHARS+1];
    size_t len = p-proto-1;
    double d;
    if (len <= MAX_LONG_DOUBLE_CHARS) {
        memcpy(buf,proto+1,len);
        buf[len] = '\0';
        d = strtod(buf,NULL); /* We expect a valid representation. */
    } else {
        d = 0;
    }
    parser->callbacks.double_callback(p_ctx, d, proto, parser->curr_location - proto);
    return C_OK;
}",1,13,resp_parser.c,parseDouble,,false,146,162,parseDouble,,,9,"int parseDouble (ReplyParser*,void*)"
333879,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseBool(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    parser->curr_location = p + 2; /* for \r\n */
    parser->callbacks.bool_callback(p_ctx, proto[1] == 't', proto, parser->curr_location - proto);
    return C_OK;
}",1,11,resp_parser.c,parseBool,,false,164,170,parseBool,,,10,"int parseBool (ReplyParser*,void*)"
333928,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseArray(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    if (len == -1) {
        parser->callbacks.null_array_callback(p_ctx, proto, parser->curr_location - proto);
    } else {
        parser->callbacks.array_callback(parser, p_ctx, len, proto);
    }
    return C_OK;
}",1,11,resp_parser.c,parseArray,,false,172,185,parseArray,,,11,"int parseArray (ReplyParser*,void*)"
334003,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseSet(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.set_callback(parser, p_ctx, len, proto);
    return C_OK;
}",1,11,resp_parser.c,parseSet,,false,187,196,parseSet,,,12,"int parseSet (ReplyParser*,void*)"
334057,METHOD,resp_parser.c:<global>,TYPE_DECL,"static int parseMap(ReplyParser *parser, void *p_ctx) {
    const char *proto = parser->curr_location;
    char *p = strchr(proto+1,'\r');
    long long len;
    string2ll(proto+1,p-proto-1,&len);
    p += 2;
    parser->curr_location = p;
    parser->callbacks.map_callback(parser, p_ctx, len, proto);
    return C_OK;
}",1,11,resp_parser.c,parseMap,,false,198,207,parseMap,,,13,"int parseMap (ReplyParser*,void*)"
334111,METHOD,resp_parser.c:<global>,TYPE_DECL,"int parseReply(ReplyParser *parser, void *p_ctx) {
    switch (parser->curr_location[0]) {
        case '$': return parseBulk(parser, p_ctx);
        case '+': return parseSimpleString(parser, p_ctx);
        case '-': return parseError(parser, p_ctx);
        case ':': return parseLong(parser, p_ctx);
        case '*': return parseArray(parser, p_ctx);
        case '~': return parseSet(parser, p_ctx);
        case '%': return parseMap(parser, p_ctx);
        case '#': return parseBool(parser, p_ctx);
        case ',': return parseDouble(parser, p_ctx);
        case '_': return parseNull(parser, p_ctx);
        case '(': return parseBigNumber(parser, p_ctx);
        case '=': return parseVerbatimString(parser, p_ctx);
        case '|': return parseAttributes(parser, p_ctx);
        default: if (parser->callbacks.error) parser->callbacks.error(p_ctx);
    }
    return C_ERR;
}",1,11,resp_parser.c,parseReply,,false,210,228,parseReply,,,14,"int parseReply (ReplyParser*,void*)"
334227,METHOD,resp_parser.h:<global>,TYPE_DECL,<global>,1,31,resp_parser.h,resp_parser.h:<global>,,false,1,94,<global>,,,1,
334232,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*null_array_callback)(void *ctx, const char *proto, size_t proto_len);",10,79,resp_parser.h,ReplyParserCallbacks.null_array_callback,,false,39,39,null_array_callback,,,1,"void ReplyParserCallbacks.null_array_callback (void*,char*,size_t)"
334239,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*null_bulk_string_callback)(void *ctx, const char *proto, size_t proto_len);",10,85,resp_parser.h,ReplyParserCallbacks.null_bulk_string_callback,,false,42,42,null_bulk_string_callback,,,2,"void ReplyParserCallbacks.null_bulk_string_callback (void*,char*,size_t)"
334246,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*bulk_string_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",10,109,resp_parser.h,ReplyParserCallbacks.bulk_string_callback,,false,45,45,bulk_string_callback,,,3,"void ReplyParserCallbacks.bulk_string_callback (void*,char*,size_t,char*,size_t)"
334255,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*error_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",10,103,resp_parser.h,ReplyParserCallbacks.error_callback,,false,48,48,error_callback,,,4,"void ReplyParserCallbacks.error_callback (void*,char*,size_t,char*,size_t)"
334264,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*simple_str_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",10,108,resp_parser.h,ReplyParserCallbacks.simple_str_callback,,false,51,51,simple_str_callback,,,5,"void ReplyParserCallbacks.simple_str_callback (void*,char*,size_t,char*,size_t)"
334273,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*long_callback)(void *ctx, long long val, const char *proto, size_t proto_len);",10,88,resp_parser.h,ReplyParserCallbacks.long_callback,,false,54,54,long_callback,,,6,"void ReplyParserCallbacks.long_callback (void*,long long,char*,size_t)"
334281,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*array_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",10,96,resp_parser.h,ReplyParserCallbacks.array_callback,,false,57,57,array_callback,,,7,"void ReplyParserCallbacks.array_callback (ReplyParser*,void*,size_t,char*)"
334289,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*set_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",10,94,resp_parser.h,ReplyParserCallbacks.set_callback,,false,60,60,set_callback,,,8,"void ReplyParserCallbacks.set_callback (ReplyParser*,void*,size_t,char*)"
334297,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*map_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",10,94,resp_parser.h,ReplyParserCallbacks.map_callback,,false,63,63,map_callback,,,9,"void ReplyParserCallbacks.map_callback (ReplyParser*,void*,size_t,char*)"
334305,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*bool_callback)(void *ctx, int val, const char *proto, size_t proto_len);",10,82,resp_parser.h,ReplyParserCallbacks.bool_callback,,false,66,66,bool_callback,,,10,"void ReplyParserCallbacks.bool_callback (void*,int,char*,size_t)"
334313,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*double_callback)(void *ctx, double val, const char *proto, size_t proto_len);",10,87,resp_parser.h,ReplyParserCallbacks.double_callback,,false,69,69,double_callback,,,11,"void ReplyParserCallbacks.double_callback (void*,double,char*,size_t)"
334321,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*big_number_callback)(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",10,108,resp_parser.h,ReplyParserCallbacks.big_number_callback,,false,72,72,big_number_callback,,,12,"void ReplyParserCallbacks.big_number_callback (void*,char*,size_t,char*,size_t)"
334330,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*verbatim_string_callback)(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len);",10,133,resp_parser.h,ReplyParserCallbacks.verbatim_string_callback,,false,75,75,verbatim_string_callback,,,13,"void ReplyParserCallbacks.verbatim_string_callback (void*,char*,char*,size_t,char*,size_t)"
334340,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*attribute_callback)(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",10,100,resp_parser.h,ReplyParserCallbacks.attribute_callback,,false,78,78,attribute_callback,,,14,"void ReplyParserCallbacks.attribute_callback (ReplyParser*,void*,size_t,char*)"
334348,METHOD,ReplyParserCallbacks,TYPE_DECL,"void (*null_callback)(void *ctx, const char *proto, size_t proto_len);",10,73,resp_parser.h,ReplyParserCallbacks.null_callback,,false,81,81,null_callback,,,15,"void ReplyParserCallbacks.null_callback (void*,char*,size_t)"
334355,METHOD,ReplyParserCallbacks,TYPE_DECL,void (*error)(void *ctx);,10,28,resp_parser.h,ReplyParserCallbacks.error,,false,83,83,error,,,16,void ReplyParserCallbacks.error (void*)
334364,METHOD,resp_parser.h:<global>,TYPE_DECL,"int parseReply(ReplyParser *parser, void *p_ctx);",5,48,resp_parser.h,parseReply,,false,92,92,parseReply,,,6,"int parseReply (ReplyParser*,void*)"
334393,METHOD,rio.c:<global>,TYPE_DECL,<global>,1,1,rio.c,rio.c:<global>,,false,1,520,<global>,,,1,
334395,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {
    r->io.buffer.ptr = sdscatlen(r->io.buffer.ptr,(char*)buf,len);
    r->io.buffer.pos += len;
    return 1;
}",1,1,rio.c,rioBufferWrite,,false,62,66,rioBufferWrite,,,1,"size_t rioBufferWrite (rio*,void*,size_t)"
334433,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioBufferRead(rio *r, void *buf, size_t len) {
    if (sdslen(r->io.buffer.ptr)-r->io.buffer.pos < len)
        return 0; /* not enough buffer to return len bytes. */
    memcpy(buf,r->io.buffer.ptr+r->io.buffer.pos,len);
    r->io.buffer.pos += len;
    return 1;
}",1,1,rio.c,rioBufferRead,,false,69,75,rioBufferRead,,,2,"size_t rioBufferRead (rio*,void*,size_t)"
334491,METHOD,rio.c:<global>,TYPE_DECL,"static off_t rioBufferTell(rio *r) {
    return r->io.buffer.pos;
}",1,1,rio.c,rioBufferTell,,false,78,80,rioBufferTell,,,3,off_t rioBufferTell (rio*)
334504,METHOD,rio.c:<global>,TYPE_DECL,"static int rioBufferFlush(rio *r) {
    UNUSED(r);
    return 1; /* Nothing to do, our write just appends to the buffer. */
}",1,4,rio.c,rioBufferFlush,,false,84,87,rioBufferFlush,,,4,int rioBufferFlush (rio*)
334534,METHOD,rio.c:<global>,TYPE_DECL,"void rioInitWithBuffer(rio *r, sds s) {
    *r = rioBufferIO;
    r->io.buffer.ptr = s;
    r->io.buffer.pos = 0;
}",1,1,rio.c,rioInitWithBuffer,,false,102,106,rioInitWithBuffer,,,7,"void rioInitWithBuffer (rio*,sds)"
334562,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioFileWrite(rio *r, const void *buf, size_t len) {
    if (!r->io.file.autosync) return fwrite(buf,len,1,r->io.file.fp);

    size_t nwritten = 0;
    /* Incrementally write data to the file, avoid a single write larger than
     * the autosync threshold (so that the kernel's buffer cache never has too
     * many dirty pages at once). */
    while (len != nwritten) {
        serverAssert(r->io.file.autosync > r->io.file.buffered);
        size_t nalign = (size_t)(r->io.file.autosync - r->io.file.buffered);
        size_t towrite = nalign > len-nwritten ? len-nwritten : nalign;

        if (fwrite((char*)buf+nwritten,towrite,1,r->io.file.fp) == 0) return 0;
        nwritten += towrite;
        r->io.file.buffered += towrite;

        if (r->io.file.buffered >= r->io.file.autosync) {
            fflush(r->io.file.fp);

            size_t processed = r->processed_bytes + nwritten;
            serverAssert(processed % r->io.file.autosync == 0);
            serverAssert(r...",1,8,rio.c,rioFileWrite,,false,111,168,rioFileWrite,,,8,"size_t rioFileWrite (rio*,void*,size_t)"
334835,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioFileRead(rio *r, void *buf, size_t len) {
    return fread(buf,len,1,r->io.file.fp);
}",1,1,rio.c,rioFileRead,,false,171,173,rioFileRead,,,9,"size_t rioFileRead (rio*,void*,size_t)"
334854,METHOD,rio.c:<global>,TYPE_DECL,"static off_t rioFileTell(rio *r) {
    return ftello(r->io.file.fp);
}",1,1,rio.c,rioFileTell,,false,176,178,rioFileTell,,,10,off_t rioFileTell (rio*)
334868,METHOD,rio.c:<global>,TYPE_DECL,"static int rioFileFlush(rio *r) {
    return (fflush(r->io.file.fp) == 0) ? 1 : 0;
}",1,1,rio.c,rioFileFlush,,false,182,184,rioFileFlush,,,11,int rioFileFlush (rio*)
334904,METHOD,rio.c:<global>,TYPE_DECL,"void rioInitWithFile(rio *r, FILE *fp) {
    *r = rioFileIO;
    r->io.file.fp = fp;
    r->io.file.buffered = 0;
    r->io.file.autosync = 0;
    r->io.file.reclaim_cache = 0;
}",1,1,rio.c,rioInitWithFile,,false,199,205,rioInitWithFile,,,14,"void rioInitWithFile (rio*,FILE*)"
334950,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioConnWrite(rio *r, const void *buf, size_t len) {
    UNUSED(r);
    UNUSED(buf);
    UNUSED(len);
    return 0; /* Error, this target does not yet support writing. */
}",1,4,rio.c,rioConnWrite,,false,213,218,rioConnWrite,,,15,"size_t rioConnWrite (rio*,void*,size_t)"
334977,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioConnRead(rio *r, void *buf, size_t len) {
    size_t avail = sdslen(r->io.conn.buf)-r->io.conn.pos;

    /* If the buffer is too small for the entire request: realloc. */
    if (sdslen(r->io.conn.buf) + sdsavail(r->io.conn.buf) < len)
        r->io.conn.buf = sdsMakeRoomFor(r->io.conn.buf, len - sdslen(r->io.conn.buf));

    /* If the remaining unused buffer is not large enough: memmove so that we
     * can read the rest. */
    if (len > avail && sdsavail(r->io.conn.buf) < len - avail) {
        sdsrange(r->io.conn.buf, r->io.conn.pos, -1);
        r->io.conn.pos = 0;
    }

    /* Make sure the caller didn't request to read past the limit.
     * If they didn't we'll buffer till the limit, if they did, we'll
     * return an error. */
    if (r->io.conn.read_limit != 0 && r->io.conn.read_limit < r->io.conn.read_so_far + len) {
        errno = EOVERFLOW;
        return 0;
    }

    /* If we don't already have all the data in the sds, read more */
    while (len ...",1,32,rio.c,rioConnRead,,false,221,273,rioConnRead,,,16,"size_t rioConnRead (rio*,void*,size_t)"
335376,METHOD,rio.c:<global>,TYPE_DECL,"static off_t rioConnTell(rio *r) {
    return r->io.conn.read_so_far;
}",1,1,rio.c,rioConnTell,,false,276,278,rioConnTell,,,17,off_t rioConnTell (rio*)
335389,METHOD,rio.c:<global>,TYPE_DECL,"static int rioConnFlush(rio *r) {
    /* Our flush is implemented by the write method, that recognizes a
     * buffer set to NULL with a count of zero as a flush request. */
    return rioConnWrite(r,NULL,0);
}",1,1,rio.c,rioConnFlush,,false,282,286,rioConnFlush,,,18,int rioConnFlush (rio*)
335416,METHOD,rio.c:<global>,TYPE_DECL,"void rioInitWithConn(rio *r, connection *conn, size_t read_limit) {
    *r = rioConnIO;
    r->io.conn.conn = conn;
    r->io.conn.pos = 0;
    r->io.conn.read_limit = read_limit;
    r->io.conn.read_so_far = 0;
    r->io.conn.buf = sdsnewlen(NULL, PROTO_IOBUF_LEN);
    sdsclear(r->io.conn.buf);
}",1,37,rio.c,rioInitWithConn,,false,303,311,rioInitWithConn,,,21,"void rioInitWithConn (rio*,connection*,size_t)"
335486,METHOD,rio.c:<global>,TYPE_DECL,"void rioFreeConn(rio *r, sds *remaining) {
    if (remaining && (size_t)r->io.conn.pos < sdslen(r->io.conn.buf)) {
        if (r->io.conn.pos > 0) sdsrange(r->io.conn.buf, r->io.conn.pos, -1);
        *remaining = r->io.conn.buf;
    } else {
        sdsfree(r->io.conn.buf);
        if (remaining) *remaining = NULL;
    }
    r->io.conn.buf = NULL;
}",1,1,rio.c,rioFreeConn,,false,315,324,rioFreeConn,,,22,"void rioFreeConn (rio*,sds*)"
335578,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioFdWrite(rio *r, const void *buf, size_t len) {
    ssize_t retval;
    unsigned char *p = (unsigned char*) buf;
    int doflush = (buf == NULL && len == 0);

    /* For small writes, we rather keep the data in user-space buffer, and flush
     * it only when it grows. however for larger writes, we prefer to flush
     * any pre-existing buffer, and write the new one directly without reallocs
     * and memory copying. */
    if (len > PROTO_IOBUF_LEN) {
        /* First, flush any pre-existing buffered data. */
        if (sdslen(r->io.fd.buf)) {
            if (rioFdWrite(r, NULL, 0) == 0)
                return 0;
        }
        /* Write the new data, keeping 'p' and 'len' from the input. */
    } else {
        if (len) {
            r->io.fd.buf = sdscatlen(r->io.fd.buf,buf,len);
            if (sdslen(r->io.fd.buf) > PROTO_IOBUF_LEN)
                doflush = 1;
            if (!doflush)
                return 1;
        }
        /* Flushing the buffered da...",1,14,rio.c,rioFdWrite,,false,337,384,rioFdWrite,,,23,"size_t rioFdWrite (rio*,void*,size_t)"
335778,METHOD,rio.c:<global>,TYPE_DECL,"static size_t rioFdRead(rio *r, void *buf, size_t len) {
    UNUSED(r);
    UNUSED(buf);
    UNUSED(len);
    return 0; /* Error, this target does not support reading. */
}",1,4,rio.c,rioFdRead,,false,387,392,rioFdRead,,,24,"size_t rioFdRead (rio*,void*,size_t)"
335805,METHOD,rio.c:<global>,TYPE_DECL,"static off_t rioFdTell(rio *r) {
    return r->io.fd.pos;
}",1,1,rio.c,rioFdTell,,false,395,397,rioFdTell,,,25,off_t rioFdTell (rio*)
335818,METHOD,rio.c:<global>,TYPE_DECL,"static int rioFdFlush(rio *r) {
    /* Our flush is implemented by the write method, that recognizes a
     * buffer set to NULL with a count of zero as a flush request. */
    return rioFdWrite(r,NULL,0);
}",1,1,rio.c,rioFdFlush,,false,401,405,rioFdFlush,,,26,int rioFdFlush (rio*)
335845,METHOD,rio.c:<global>,TYPE_DECL,"void rioInitWithFd(rio *r, int fd) {
    *r = rioFdIO;
    r->io.fd.fd = fd;
    r->io.fd.pos = 0;
    r->io.fd.buf = sdsempty();
}",1,1,rio.c,rioInitWithFd,,false,420,425,rioInitWithFd,,,29,"void rioInitWithFd (rio*,int)"
335882,METHOD,rio.c:<global>,TYPE_DECL,"void rioFreeFd(rio *r) {
    sdsfree(r->io.fd.buf);
}",1,1,rio.c,rioFreeFd,,false,428,430,rioFreeFd,,,30,void rioFreeFd (rio*)
335895,METHOD,rio.c:<global>,TYPE_DECL,"void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {
    r->cksum = crc64(r->cksum,buf,len);
}",1,1,rio.c,rioGenericUpdateChecksum,,false,436,438,rioGenericUpdateChecksum,,,31,"void rioGenericUpdateChecksum (rio*,void*,size_t)"
335912,METHOD,rio.c:<global>,TYPE_DECL,"void rioSetAutoSync(rio *r, off_t bytes) {
    if(r->write != rioFileIO.write) return;
    r->io.file.autosync = bytes;
}",1,1,rio.c,rioSetAutoSync,,false,448,451,rioSetAutoSync,,,32,"void rioSetAutoSync (rio*,off_t)"
335937,METHOD,rio.c:<global>,TYPE_DECL,"void rioSetReclaimCache(rio *r, int enabled) {
    r->io.file.reclaim_cache = enabled;
}",1,1,rio.c,rioSetReclaimCache,,false,458,460,rioSetReclaimCache,,,33,"void rioSetReclaimCache (rio*,int)"
335952,METHOD,rio.c:<global>,TYPE_DECL,"uint8_t rioCheckType(rio *r) {
    if (r->read == rioFileRead) {
        return RIO_TYPE_FILE;
    } else if (r->read == rioBufferRead) {
        return RIO_TYPE_BUFFER;
    } else if (r->read == rioConnRead) {
        return RIO_TYPE_CONN;
    } else {
        /* r->read == rioFdRead */
        return RIO_TYPE_FD;
    }
}",1,15,rio.c,rioCheckType,,false,463,474,rioCheckType,,,34,uint8_t rioCheckType (rio*)
336008,METHOD,rio.c:<global>,TYPE_DECL,"size_t rioWriteBulkCount(rio *r, char prefix, long count) {
    char cbuf[128];
    int clen;

    cbuf[0] = prefix;
    clen = 1+ll2string(cbuf+1,sizeof(cbuf)-1,count);
    cbuf[clen++] = '\r';
    cbuf[clen++] = '\n';
    if (rioWrite(r,cbuf,clen) == 0) return 0;
    return clen;
}",1,1,rio.c,rioWriteBulkCount,,false,482,492,rioWriteBulkCount,,,35,"size_t rioWriteBulkCount (rio*,char,long)"
336059,METHOD,rio.c:<global>,TYPE_DECL,"size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {
    size_t nwritten;

    if ((nwritten = rioWriteBulkCount(r,'$',len)) == 0) return 0;
    if (len > 0 && rioWrite(r,buf,len) == 0) return 0;
    if (rioWrite(r,""\r\n"",2) == 0) return 0;
    return nwritten+len+2;
}",1,1,rio.c,rioWriteBulkString,,false,495,502,rioWriteBulkString,,,36,"size_t rioWriteBulkString (rio*,char*,size_t)"
336109,METHOD,rio.c:<global>,TYPE_DECL,"size_t rioWriteBulkLongLong(rio *r, long long l) {
    char lbuf[32];
    unsigned int llen;

    llen = ll2string(lbuf,sizeof(lbuf),l);
    return rioWriteBulkString(r,lbuf,llen);
}",1,1,rio.c,rioWriteBulkLongLong,,false,505,511,rioWriteBulkLongLong,,,37,"size_t rioWriteBulkLongLong (rio*,long long)"
336129,METHOD,rio.c:<global>,TYPE_DECL,"size_t rioWriteBulkDouble(rio *r, double d) {
    char dbuf[128];
    unsigned int dlen;
    dlen = fpconv_dtoa(d, dbuf);
    dbuf[dlen] = '\0';
    return rioWriteBulkString(r,dbuf,dlen);
}",1,1,rio.c,rioWriteBulkDouble,,false,514,520,rioWriteBulkDouble,,,38,"size_t rioWriteBulkDouble (rio*,double)"
336163,METHOD,rio.h:<global>,TYPE_DECL,<global>,1,20,rio.h,rio.h:<global>,,false,1,185,<global>,,,1,
336166,METHOD,_rio,TYPE_DECL,"size_t (*read)(struct _rio *, void *buf, size_t len);",12,56,rio.h,_rio.read,,false,52,52,read,,,1,"size_t _rio.read (_rio*,void*,size_t)"
336173,METHOD,_rio,TYPE_DECL,"size_t (*write)(struct _rio *, const void *buf, size_t len);",12,63,rio.h,_rio.write,,false,53,53,write,,,2,"size_t _rio.write (_rio*,void*,size_t)"
336180,METHOD,_rio,TYPE_DECL,off_t (*tell)(struct _rio *);,11,32,rio.h,_rio.tell,,false,54,54,tell,,,3,off_t _rio.tell (_rio*)
336185,METHOD,_rio,TYPE_DECL,int (*flush)(struct _rio *);,9,31,rio.h,_rio.flush,,false,55,55,flush,,,4,int _rio.flush (_rio*)
336190,METHOD,_rio,TYPE_DECL,"void (*update_cksum)(struct _rio *, const void *buf, size_t len);",10,68,rio.h,_rio.update_cksum,,false,61,61,update_cksum,,,5,"void _rio.update_cksum (_rio*,void*,size_t)"
336227,METHOD,rio.h:<global>,TYPE_DECL,"static inline size_t rioWrite(rio *r, const void *buf, size_t len) {
    if (r->flags & RIO_FLAG_WRITE_ERROR) return 0;
    while (len) {
        size_t bytes_to_write = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_write);
        if (r->write(r,buf,bytes_to_write) == 0) {
            r->flags |= RIO_FLAG_WRITE_ERROR;
            return 0;
        }
        buf = (char*)buf + bytes_to_write;
        len -= bytes_to_write;
        r->processed_bytes += bytes_to_write;
    }
    return 1;
}",1,19,rio.h,rioWrite,,false,109,123,rioWrite,,,4,"size_t rioWrite (rio*,void*,size_t)"
336318,METHOD,rio.h:<global>,TYPE_DECL,"static inline size_t rioRead(rio *r, void *buf, size_t len) {
    if (r->flags & RIO_FLAG_READ_ERROR) return 0;
    while (len) {
        size_t bytes_to_read = (r->max_processing_chunk && r->max_processing_chunk < len) ? r->max_processing_chunk : len;
        if (r->read(r,buf,bytes_to_read) == 0) {
            r->flags |= RIO_FLAG_READ_ERROR;
            return 0;
        }
        if (r->update_cksum) r->update_cksum(r,buf,bytes_to_read);
        buf = (char*)buf + bytes_to_read;
        len -= bytes_to_read;
        r->processed_bytes += bytes_to_read;
    }
    return 1;
}",1,19,rio.h,rioRead,,false,125,139,rioRead,,,5,"size_t rioRead (rio*,void*,size_t)"
336409,METHOD,rio.h:<global>,TYPE_DECL,"static inline off_t rioTell(rio *r) {
    return r->tell(r);
}",1,1,rio.h,rioTell,,false,141,143,rioTell,,,6,off_t rioTell (rio*)
336420,METHOD,rio.h:<global>,TYPE_DECL,"static inline int rioFlush(rio *r) {
    return r->flush(r);
}",1,1,rio.h,rioFlush,,false,145,147,rioFlush,,,7,int rioFlush (rio*)
336431,METHOD,rio.h:<global>,TYPE_DECL,"static inline int rioGetReadError(rio *r) {
    return (r->flags & RIO_FLAG_READ_ERROR) != 0;
}",1,23,rio.h,rioGetReadError,,false,152,154,rioGetReadError,,,8,int rioGetReadError (rio*)
336448,METHOD,rio.h:<global>,TYPE_DECL,"static inline int rioGetWriteError(rio *r) {
    return (r->flags & RIO_FLAG_WRITE_ERROR) != 0;
}",1,23,rio.h,rioGetWriteError,,false,157,159,rioGetWriteError,,,9,int rioGetWriteError (rio*)
336465,METHOD,rio.h:<global>,TYPE_DECL,"static inline void rioClearErrors(rio *r) {
    r->flags &= ~(RIO_FLAG_READ_ERROR|RIO_FLAG_WRITE_ERROR);
}",1,18,rio.h,rioClearErrors,,false,161,163,rioClearErrors,,,10,void rioClearErrors (rio*)
336486,METHOD,rio.h:<global>,TYPE_DECL,"void rioInitWithFile(rio *r, FILE *fp);",6,38,rio.h,rioInitWithFile,,false,165,165,rioInitWithFile,,,11,"void rioInitWithFile (rio*,FILE*)"
336492,METHOD,rio.h:<global>,TYPE_DECL,"void rioInitWithBuffer(rio *r, sds s);",6,37,rio.h,rioInitWithBuffer,,false,166,166,rioInitWithBuffer,,,12,"void rioInitWithBuffer (rio*,sds)"
336498,METHOD,rio.h:<global>,TYPE_DECL,"void rioInitWithConn(rio *r, connection *conn, size_t read_limit);",6,65,rio.h,rioInitWithConn,,false,167,167,rioInitWithConn,,,13,"void rioInitWithConn (rio*,connection*,size_t)"
336505,METHOD,rio.h:<global>,TYPE_DECL,"void rioInitWithFd(rio *r, int fd);",6,34,rio.h,rioInitWithFd,,false,168,168,rioInitWithFd,,,14,"void rioInitWithFd (rio*,int)"
336511,METHOD,rio.h:<global>,TYPE_DECL,void rioFreeFd(rio *r);,6,22,rio.h,rioFreeFd,,false,170,170,rioFreeFd,,,15,void rioFreeFd (rio*)
336516,METHOD,rio.h:<global>,TYPE_DECL,"void rioFreeConn(rio *r, sds* out_remainingBufferedData);",6,56,rio.h,rioFreeConn,,false,171,171,rioFreeConn,,,16,"void rioFreeConn (rio*,sds*)"
336522,METHOD,rio.h:<global>,TYPE_DECL,"size_t rioWriteBulkCount(rio *r, char prefix, long count);",8,57,rio.h,rioWriteBulkCount,,false,173,173,rioWriteBulkCount,,,17,"size_t rioWriteBulkCount (rio*,char,long)"
336529,METHOD,rio.h:<global>,TYPE_DECL,"size_t rioWriteBulkString(rio *r, const char *buf, size_t len);",8,62,rio.h,rioWriteBulkString,,false,174,174,rioWriteBulkString,,,18,"size_t rioWriteBulkString (rio*,char*,size_t)"
336536,METHOD,rio.h:<global>,TYPE_DECL,"size_t rioWriteBulkLongLong(rio *r, long long l);",8,48,rio.h,rioWriteBulkLongLong,,false,175,175,rioWriteBulkLongLong,,,19,"size_t rioWriteBulkLongLong (rio*,long long)"
336542,METHOD,rio.h:<global>,TYPE_DECL,"size_t rioWriteBulkDouble(rio *r, double d);",8,43,rio.h,rioWriteBulkDouble,,false,176,176,rioWriteBulkDouble,,,20,"size_t rioWriteBulkDouble (rio*,double)"
336549,METHOD,rio.h:<global>,TYPE_DECL,"int rioWriteBulkObject(rio *r, struct redisObject *obj);",5,55,rio.h,rioWriteBulkObject,,false,179,179,rioWriteBulkObject,,,22,"int rioWriteBulkObject (rio*,redisObject*)"
336555,METHOD,rio.h:<global>,TYPE_DECL,"void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len);",6,66,rio.h,rioGenericUpdateChecksum,,false,181,181,rioGenericUpdateChecksum,,,23,"void rioGenericUpdateChecksum (rio*,void*,size_t)"
336562,METHOD,rio.h:<global>,TYPE_DECL,"void rioSetAutoSync(rio *r, off_t bytes);",6,40,rio.h,rioSetAutoSync,,false,182,182,rioSetAutoSync,,,24,"void rioSetAutoSync (rio*,off_t)"
336568,METHOD,rio.h:<global>,TYPE_DECL,"void rioSetReclaimCache(rio *r, int enabled);",6,44,rio.h,rioSetReclaimCache,,false,183,183,rioSetReclaimCache,,,25,"void rioSetReclaimCache (rio*,int)"
336574,METHOD,rio.h:<global>,TYPE_DECL,uint8_t rioCheckType(rio *r);,9,28,rio.h,rioCheckType,,false,184,184,rioCheckType,,,26,uint8_t rioCheckType (rio*)
336588,METHOD,script.c:<global>,TYPE_DECL,<global>,1,1,script.c,script.c:<global>,,false,1,578,<global>,,,1,
336672,METHOD,script.c:<global>,TYPE_DECL,"static void exitScriptTimedoutMode(scriptRunCtx *run_ctx) {
    serverAssert(run_ctx == curr_run_ctx);
    serverAssert(scriptIsTimedout());
    run_ctx->flags &= ~SCRIPT_TIMEDOUT;
    blockingOperationEnds();
    /* if we are a replica and we have an active master, set it for continue processing */
    if (server.masterhost && server.master) queueClientForReprocessing(server.master);
}",1,4,script.c,exitScriptTimedoutMode,,false,46,53,exitScriptTimedoutMode,,,5,void exitScriptTimedoutMode (scriptRunCtx*)
336732,METHOD,script.c:<global>,TYPE_DECL,"static void enterScriptTimedoutMode(scriptRunCtx *run_ctx) {
    serverAssert(run_ctx == curr_run_ctx);
    serverAssert(!scriptIsTimedout());
    /* Mark script as timedout */
    run_ctx->flags |= SCRIPT_TIMEDOUT;
    blockingOperationStarts();
}",1,4,script.c,enterScriptTimedoutMode,,false,55,61,enterScriptTimedoutMode,,,6,void enterScriptTimedoutMode (scriptRunCtx*)
336780,METHOD,script.c:<global>,TYPE_DECL,"int scriptIsTimedout(void) {
    return scriptIsRunning() && (curr_run_ctx->flags & SCRIPT_TIMEDOUT);
}",1,55,script.c,scriptIsTimedout,,false,63,65,scriptIsTimedout,,,7,int scriptIsTimedout (void)
336797,METHOD,script.c:<global>,TYPE_DECL,"client* scriptGetClient(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->c;
}",1,4,script.c,scriptGetClient,,false,67,70,scriptGetClient,,,8,client scriptGetClient (void)
336821,METHOD,script.c:<global>,TYPE_DECL,"client* scriptGetCaller(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->original_client;
}",1,4,script.c,scriptGetCaller,,false,72,75,scriptGetCaller,,,9,client scriptGetCaller (void)
336845,METHOD,script.c:<global>,TYPE_DECL,"int scriptInterrupt(scriptRunCtx *run_ctx) {
    if (run_ctx->flags & SCRIPT_TIMEDOUT) {
        /* script already timedout
           we just need to precess some events and return */
        processEventsWhileBlocked();
        return (run_ctx->flags & SCRIPT_KILLED) ? SCRIPT_KILL : SCRIPT_CONTINUE;
    }

    long long elapsed = elapsedMs(run_ctx->start_time);
    if (elapsed < server.busy_reply_threshold) {
        return SCRIPT_CONTINUE;
    }

    serverLog(LL_WARNING,
            ""Slow script detected: still in execution after %lld milliseconds. ""
                    ""You can try killing the script using the %s command. Script name is: %s."",
            elapsed, (run_ctx->flags & SCRIPT_EVAL_MODE) ? ""SCRIPT KILL"" : ""FUNCTION KILL"", run_ctx->funcname);

    enterScriptTimedoutMode(run_ctx);
    /* Once the script timeouts we reenter the event loop to permit others
     * some commands execution. For this reason
     * we need to mask the client executing the script from the ev...",1,25,script.c,scriptInterrupt,,false,80,109,scriptInterrupt,,,10,int scriptInterrupt (scriptRunCtx*)
336953,METHOD,script.c:<global>,TYPE_DECL,"uint64_t scriptFlagsToCmdFlags(uint64_t cmd_flags, uint64_t script_flags) {
    /* If the script declared flags, clear the ones from the command and use the ones it declared.*/
    cmd_flags &= ~(CMD_STALE | CMD_DENYOOM | CMD_WRITE);

    /* NO_WRITES implies ALLOW_OOM */
    if (!(script_flags & (SCRIPT_FLAG_ALLOW_OOM | SCRIPT_FLAG_NO_WRITES)))
        cmd_flags |= CMD_DENYOOM;
    if (!(script_flags & SCRIPT_FLAG_NO_WRITES))
        cmd_flags |= CMD_WRITE;
    if (script_flags & SCRIPT_FLAG_ALLOW_STALE)
        cmd_flags |= CMD_STALE;

    /* In addition the MAY_REPLICATE flag is set for these commands, but
     * if we have flags we know if it's gonna do any writes or not. */
    cmd_flags &= ~CMD_MAY_REPLICATE;

    return cmd_flags;
}",1,19,script.c,scriptFlagsToCmdFlags,,false,111,128,scriptFlagsToCmdFlags,,,11,"uint64_t scriptFlagsToCmdFlags (uint64_t,uint64_t)"
337045,METHOD,script.c:<global>,TYPE_DECL,"int scriptPrepareForRun(scriptRunCtx *run_ctx, client *engine_client, client *caller, const char *funcname, uint64_t script_flags, int ro) {
    serverAssert(!curr_run_ctx);
    int client_allow_oom = !!(caller->flags & CLIENT_ALLOW_OOM);

    int running_stale = server.masterhost &&
            server.repl_state != REPL_STATE_CONNECTED &&
            server.repl_serve_stale_data == 0;
    int obey_client = mustObeyClient(caller);

    if (!(script_flags & SCRIPT_FLAG_EVAL_COMPAT_MODE)) {
        if ((script_flags & SCRIPT_FLAG_NO_CLUSTER) && server.cluster_enabled) {
            addReplyError(caller, ""Can not run script on cluster, 'no-cluster' flag is set."");
            return C_ERR;
        }

        if (running_stale && !(script_flags & SCRIPT_FLAG_ALLOW_STALE)) {
            addReplyError(caller, ""-MASTERDOWN Link with MASTER is down, ""
                             ""replica-serve-stale-data is set to 'no' ""
                             ""and 'allow-stale' flag is not set on th...",1,4,script.c,scriptPrepareForRun,,false,131,249,scriptPrepareForRun,,,12,"int scriptPrepareForRun (scriptRunCtx*,client*,client*,char*,uint64_t,int)"
337474,METHOD,script.c:<global>,TYPE_DECL,"void scriptResetRun(scriptRunCtx *run_ctx) {
    serverAssert(curr_run_ctx);

    /* After the script done, remove the MULTI state. */
    run_ctx->c->flags &= ~CLIENT_MULTI;

    if (scriptIsTimedout()) {
        exitScriptTimedoutMode(run_ctx);
        /* Restore the client that was protected when the script timeout
         * was detected. */
        unprotectClient(run_ctx->original_client);
    }

    preventCommandPropagation(run_ctx->original_client);

    /*  unset curr_run_ctx so we will know there is no running script */
    curr_run_ctx = NULL;
}",1,4,script.c,scriptResetRun,,false,252,269,scriptResetRun,,,13,void scriptResetRun (scriptRunCtx*)
337522,METHOD,script.c:<global>,TYPE_DECL,"int scriptIsRunning(void) {
    return curr_run_ctx != NULL;
}",1,1,script.c,scriptIsRunning,,false,272,274,scriptIsRunning,,,14,int scriptIsRunning (void)
337531,METHOD,script.c:<global>,TYPE_DECL,"const char* scriptCurrFunction(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->funcname;
}",1,4,script.c,scriptCurrFunction,,false,276,279,scriptCurrFunction,,,15,const char* scriptCurrFunction (void)
337555,METHOD,script.c:<global>,TYPE_DECL,"int scriptIsEval(void) {
    serverAssert(scriptIsRunning());
    return curr_run_ctx->flags & SCRIPT_EVAL_MODE;
}",1,4,script.c,scriptIsEval,,false,281,284,scriptIsEval,,,16,int scriptIsEval (void)
337585,METHOD,script.c:<global>,TYPE_DECL,"void scriptKill(client *c, int is_eval) {
    if (!curr_run_ctx) {
        addReplyError(c, ""-NOTBUSY No scripts in execution right now."");
        return;
    }
    if (mustObeyClient(curr_run_ctx->original_client)) {
        addReplyError(c,
                ""-UNKILLABLE The busy script was sent by a master instance in the context of replication and cannot be killed."");
        return;
    }
    if (curr_run_ctx->flags & SCRIPT_WRITE_DIRTY) {
        addReplyError(c,
                ""-UNKILLABLE Sorry the script already executed write ""
                        ""commands against the dataset. You can either wait the ""
                        ""script termination or kill the server in a hard way ""
                        ""using the SHUTDOWN NOSAVE command."");
        return;
    }
    if (is_eval && !(curr_run_ctx->flags & SCRIPT_EVAL_MODE)) {
        /* Kill a function with 'SCRIPT KILL' is not allow */
        addReplyErrorObject(c, shared.slowscripterr);
        return;
    }
    if...",1,30,script.c,scriptKill,,false,287,317,scriptKill,,,17,"void scriptKill (client*,int)"
337678,METHOD,script.c:<global>,TYPE_DECL,"static int scriptVerifyCommandArity(struct redisCommand *cmd, int argc, sds *err) {
    if (!cmd || ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity))) {
        if (cmd)
            *err = sdsnew(""Wrong number of args calling Redis command from script"");
        else
            *err = sdsnew(""Unknown Redis command called from script"");
        return C_ERR;
    }
    return C_OK;
}",1,15,script.c,scriptVerifyCommandArity,,false,319,328,scriptVerifyCommandArity,,,18,"int scriptVerifyCommandArity (redisCommand*,int,sds*)"
337732,METHOD,script.c:<global>,TYPE_DECL,"static int scriptVerifyACL(client *c, sds *err) {
    /* Check the ACLs. */
    int acl_errpos;
    int acl_retval = ACLCheckAllPerm(c, &acl_errpos);
    if (acl_retval != ACL_OK) {
        addACLLogEntry(c,acl_retval,ACL_LOG_CTX_LUA,acl_errpos,NULL,NULL);
        sds msg = getAclErrorMessage(acl_retval, c->user, c->cmd, c->argv[acl_errpos]->ptr, 0);
        *err = sdscatsds(sdsnew(""ACL failure in script: ""), msg);
        sdsfree(msg);
        return C_ERR;
    }
    return C_OK;
}",1,22,script.c,scriptVerifyACL,,false,330,342,scriptVerifyACL,,,19,"int scriptVerifyACL (client*,sds*)"
337799,METHOD,script.c:<global>,TYPE_DECL,"static int scriptVerifyWriteCommandAllow(scriptRunCtx *run_ctx, char **err) {

    /* A write command, on an RO command or an RO script is rejected ASAP.
     * Note: For scripts, we consider may-replicate commands as write commands.
     * This also makes it possible to allow read-only scripts to be run during
     * CLIENT PAUSE WRITE. */
    if (run_ctx->flags & SCRIPT_READ_ONLY &&
        (run_ctx->c->cmd->flags & (CMD_WRITE|CMD_MAY_REPLICATE)))
    {
        *err = sdsnew(""Write commands are not allowed from read-only scripts."");
        return C_ERR;
    }

    /* The other checks below are on the server state and are only relevant for
     *  write commands, return if this is not a write command. */
    if (!(run_ctx->c->cmd->flags & CMD_WRITE))
        return C_OK;

    /* If the script already made a modification to the dataset, we can't
     * fail it on unpredictable error state. */
    if ((run_ctx->flags & SCRIPT_WRITE_DIRTY))
        return C_OK;

    /* Write commands...",1,25,script.c,scriptVerifyWriteCommandAllow,,false,344,394,scriptVerifyWriteCommandAllow,,,20,"int scriptVerifyWriteCommandAllow (scriptRunCtx*,char**)"
337953,METHOD,script.c:<global>,TYPE_DECL,"static int scriptVerifyOOM(scriptRunCtx *run_ctx, char **err) {
    if (run_ctx->flags & SCRIPT_ALLOW_OOM) {
        /* Allow running any command even if OOM reached */
        return C_OK;
    }

    /* If we reached the memory limit configured via maxmemory, commands that
     * could enlarge the memory usage are not allowed, but only if this is the
     * first write in the context of this script, otherwise we can't stop
     * in the middle. */

    if (server.maxmemory &&                            /* Maxmemory is actually enabled. */
        !mustObeyClient(run_ctx->original_client) &&   /* Don't care about mem for replicas or AOF. */
        !(run_ctx->flags & SCRIPT_WRITE_DIRTY) &&      /* Script had no side effects so far. */
        server.pre_command_oom_state &&                /* Detected OOM when script start. */
        (run_ctx->c->cmd->flags & CMD_DENYOOM))
    {
        *err = sdsdup(shared.oomerr->ptr);
        return C_ERR;
    }

    return C_OK;
}",1,25,script.c,scriptVerifyOOM,,false,396,418,scriptVerifyOOM,,,21,"int scriptVerifyOOM (scriptRunCtx*,char**)"
338032,METHOD,script.c:<global>,TYPE_DECL,"static int scriptVerifyClusterState(scriptRunCtx *run_ctx, client *c, client *original_c, sds *err) {
    if (!server.cluster_enabled || mustObeyClient(original_c)) {
        return C_OK;
    }
    /* If this is a Redis Cluster node, we need to make sure the script is not
     * trying to access non-local keys, with the exception of commands
     * received from our master or when loading the AOF back in memory. */
    int error_code;
    /* Duplicate relevant flags in the script client. */
    c->flags &= ~(CLIENT_READONLY | CLIENT_ASKING);
    c->flags |= original_c->flags & (CLIENT_READONLY | CLIENT_ASKING);
    int hashslot = -1;
    if (getNodeByQuery(c, c->cmd, c->argv, c->argc, &hashslot, &error_code) != server.cluster->myself) {
        if (error_code == CLUSTER_REDIR_DOWN_RO_STATE) {
            *err = sdsnew(
                    ""Script attempted to execute a write command while the ""
                            ""cluster is down and readonly"");
        } else if (error_cod...",1,15,script.c,scriptVerifyClusterState,,false,420,460,scriptVerifyClusterState,,,22,"int scriptVerifyClusterState (scriptRunCtx*,client*,client*,sds*)"
338208,METHOD,script.c:<global>,TYPE_DECL,"int scriptSetResp(scriptRunCtx *run_ctx, int resp) {
    if (resp != 2 && resp != 3) {
        return C_ERR;
    }

    run_ctx->c->resp = resp;
    return C_OK;
}",1,15,script.c,scriptSetResp,,false,463,470,scriptSetResp,,,23,"int scriptSetResp (scriptRunCtx*,int)"
338239,METHOD,script.c:<global>,TYPE_DECL,"int scriptSetRepl(scriptRunCtx *run_ctx, int repl) {
    if ((repl & ~(PROPAGATE_AOF | PROPAGATE_REPL)) != 0) {
        return C_ERR;
    }
    run_ctx->repl_flags = repl;
    return C_OK;
}",1,18,script.c,scriptSetRepl,,false,474,480,scriptSetRepl,,,24,"int scriptSetRepl (scriptRunCtx*,int)"
338273,METHOD,script.c:<global>,TYPE_DECL,"static int scriptVerifyAllowStale(client *c, sds *err) {
    if (!server.masterhost) {
        /* Not a replica, stale is irrelevant */
        return C_OK;
    }

    if (server.repl_state == REPL_STATE_CONNECTED) {
        /* Connected to replica, stale is irrelevant */
        return C_OK;
    }

    if (server.repl_serve_stale_data == 1) {
        /* Disconnected from replica but allow to serve data */
        return C_OK;
    }

    if (c->cmd->flags & CMD_STALE) {
        /* Command is allow while stale */
        return C_OK;
    }

    /* On stale replica, can not run the command */
    *err = sdsnew(""Can not execute the command on a stale replica"");
    return C_ERR;
}",1,15,script.c,scriptVerifyAllowStale,,false,482,506,scriptVerifyAllowStale,,,25,"int scriptVerifyAllowStale (client*,sds*)"
338338,METHOD,script.c:<global>,TYPE_DECL,"void scriptCall(scriptRunCtx *run_ctx, sds *err) {
    client *c = run_ctx->c;

    /* Setup our fake client for command execution */
    c->user = run_ctx->original_client->user;

    /* Process module hooks */
    moduleCallCommandFilters(c);

    struct redisCommand *cmd = lookupCommand(c->argv, c->argc);
    c->cmd = c->lastcmd = c->realcmd = cmd;
    if (scriptVerifyCommandArity(cmd, c->argc, err) != C_OK) {
        goto error;
    }

    /* There are commands that are not allowed inside scripts. */
    if (!server.script_disable_deny_script && (cmd->flags & CMD_NOSCRIPT)) {
        *err = sdsnew(""This Redis command is not allowed from script"");
        goto error;
    }

    if (scriptVerifyAllowStale(c, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyACL(c, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyWriteCommandAllow(run_ctx, err) != C_OK) {
        goto error;
    }

    if (scriptVerifyOOM(run_ctx, err) != C_OK) {
        goto error;
    }...",1,55,script.c,scriptCall,,false,513,573,scriptCall,,,26,"void scriptCall (scriptRunCtx*,sds*)"
338573,METHOD,script.c:<global>,TYPE_DECL,"long long scriptRunDuration(void) {
    serverAssert(scriptIsRunning());
    return elapsedMs(curr_run_ctx->start_time);
}",1,4,script.c,scriptRunDuration,,false,575,578,scriptRunDuration,,,27,long long scriptRunDuration (void)
338601,METHOD,script.h:<global>,TYPE_DECL,<global>,1,24,script.h,script.h:<global>,,false,1,111,<global>,,,1,
338618,METHOD,script.h:<global>,TYPE_DECL,"uint64_t scriptFlagsToCmdFlags(uint64_t cmd_flags, uint64_t script_flags);",10,73,script.h,scriptFlagsToCmdFlags,,false,95,95,scriptFlagsToCmdFlags,,,8,"uint64_t scriptFlagsToCmdFlags (uint64_t,uint64_t)"
338624,METHOD,script.h:<global>,TYPE_DECL,"int scriptPrepareForRun(scriptRunCtx *r_ctx, client *engine_client, client *caller, const char *funcname, uint64_t script_flags, int ro);",5,136,script.h,scriptPrepareForRun,,false,96,96,scriptPrepareForRun,,,9,"int scriptPrepareForRun (scriptRunCtx*,client*,client*,char*,uint64_t,int)"
338634,METHOD,script.h:<global>,TYPE_DECL,void scriptResetRun(scriptRunCtx *r_ctx);,6,40,script.h,scriptResetRun,,false,97,97,scriptResetRun,,,10,void scriptResetRun (scriptRunCtx*)
338639,METHOD,script.h:<global>,TYPE_DECL,"int scriptSetResp(scriptRunCtx *r_ctx, int resp);",5,48,script.h,scriptSetResp,,false,98,98,scriptSetResp,,,11,"int scriptSetResp (scriptRunCtx*,int)"
338645,METHOD,script.h:<global>,TYPE_DECL,"int scriptSetRepl(scriptRunCtx *r_ctx, int repl);",5,48,script.h,scriptSetRepl,,false,99,99,scriptSetRepl,,,12,"int scriptSetRepl (scriptRunCtx*,int)"
338651,METHOD,script.h:<global>,TYPE_DECL,"void scriptCall(scriptRunCtx *r_ctx, sds *err);",6,46,script.h,scriptCall,,false,100,100,scriptCall,,,13,"void scriptCall (scriptRunCtx*,sds*)"
338657,METHOD,script.h:<global>,TYPE_DECL,int scriptInterrupt(scriptRunCtx *r_ctx);,5,40,script.h,scriptInterrupt,,false,101,101,scriptInterrupt,,,14,int scriptInterrupt (scriptRunCtx*)
338662,METHOD,script.h:<global>,TYPE_DECL,"void scriptKill(client *c, int is_eval);",6,39,script.h,scriptKill,,false,102,102,scriptKill,,,15,"void scriptKill (client*,int)"
338668,METHOD,script.h:<global>,TYPE_DECL,int scriptIsRunning(void);,5,25,script.h,scriptIsRunning,,false,103,103,scriptIsRunning,,,16,int scriptIsRunning (void)
338673,METHOD,script.h:<global>,TYPE_DECL,const char* scriptCurrFunction(void);,11,36,script.h,scriptCurrFunction,,false,104,104,scriptCurrFunction,,,17,char* scriptCurrFunction (void)
338678,METHOD,script.h:<global>,TYPE_DECL,int scriptIsEval(void);,5,22,script.h,scriptIsEval,,false,105,105,scriptIsEval,,,18,int scriptIsEval (void)
338683,METHOD,script.h:<global>,TYPE_DECL,int scriptIsTimedout(void);,5,26,script.h,scriptIsTimedout,,false,106,106,scriptIsTimedout,,,19,int scriptIsTimedout (void)
338688,METHOD,script.h:<global>,TYPE_DECL,client* scriptGetClient(void);,7,29,script.h,scriptGetClient,,false,107,107,scriptGetClient,,,20,client* scriptGetClient (void)
338693,METHOD,script.h:<global>,TYPE_DECL,client* scriptGetCaller(void);,7,29,script.h,scriptGetCaller,,false,108,108,scriptGetCaller,,,21,client* scriptGetCaller (void)
338698,METHOD,script.h:<global>,TYPE_DECL,long long scriptRunDuration(void);,11,33,script.h,scriptRunDuration,,false,109,109,scriptRunDuration,,,22,long long scriptRunDuration (void)
338732,METHOD,script_lua.c:<global>,TYPE_DECL,<global>,1,1,script_lua.c,script_lua.c:<global>,,false,1,1722,<global>,,,1,
338814,METHOD,script_lua.c:<global>,TYPE_DECL,static int redis_math_random (lua_State *L);,12,43,script_lua.c,redis_math_random,,false,136,136,redis_math_random,,,15,int redis_math_random (lua_State*)
338819,METHOD,script_lua.c:<global>,TYPE_DECL,static int redis_math_randomseed (lua_State *L);,12,47,script_lua.c,redis_math_randomseed,,false,137,137,redis_math_randomseed,,,16,int redis_math_randomseed (lua_State*)
338824,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Int(void *ctx, long long val, const char *proto, size_t proto_len);",13,101,script_lua.c,redisProtocolToLuaType_Int,,false,138,138,redisProtocolToLuaType_Int,,,17,"void redisProtocolToLuaType_Int (void*,long long,char*,size_t)"
338832,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_BulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",13,122,script_lua.c,redisProtocolToLuaType_BulkString,,false,139,139,redisProtocolToLuaType_BulkString,,,18,"void redisProtocolToLuaType_BulkString (void*,char*,size_t,char*,size_t)"
338841,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_NullBulkString(void *ctx, const char *proto, size_t proto_len);",13,97,script_lua.c,redisProtocolToLuaType_NullBulkString,,false,140,140,redisProtocolToLuaType_NullBulkString,,,19,"void redisProtocolToLuaType_NullBulkString (void*,char*,size_t)"
338848,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_NullArray(void *ctx, const char *proto, size_t proto_len);",13,92,script_lua.c,redisProtocolToLuaType_NullArray,,false,141,141,redisProtocolToLuaType_NullArray,,,20,"void redisProtocolToLuaType_NullArray (void*,char*,size_t)"
338855,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Status(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",13,118,script_lua.c,redisProtocolToLuaType_Status,,false,142,142,redisProtocolToLuaType_Status,,,21,"void redisProtocolToLuaType_Status (void*,char*,size_t,char*,size_t)"
338864,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Error(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",13,117,script_lua.c,redisProtocolToLuaType_Error,,false,143,143,redisProtocolToLuaType_Error,,,22,"void redisProtocolToLuaType_Error (void*,char*,size_t,char*,size_t)"
338873,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Array(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",13,110,script_lua.c,redisProtocolToLuaType_Array,,false,144,144,redisProtocolToLuaType_Array,,,23,"void redisProtocolToLuaType_Array (ReplyParser*,void*,size_t,char*)"
338881,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Map(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",13,108,script_lua.c,redisProtocolToLuaType_Map,,false,145,145,redisProtocolToLuaType_Map,,,24,"void redisProtocolToLuaType_Map (ReplyParser*,void*,size_t,char*)"
338889,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Set(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",13,108,script_lua.c,redisProtocolToLuaType_Set,,false,146,146,redisProtocolToLuaType_Set,,,25,"void redisProtocolToLuaType_Set (ReplyParser*,void*,size_t,char*)"
338897,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Null(void *ctx, const char *proto, size_t proto_len);",13,87,script_lua.c,redisProtocolToLuaType_Null,,false,147,147,redisProtocolToLuaType_Null,,,26,"void redisProtocolToLuaType_Null (void*,char*,size_t)"
338904,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Bool(void *ctx, int val, const char *proto, size_t proto_len);",13,96,script_lua.c,redisProtocolToLuaType_Bool,,false,148,148,redisProtocolToLuaType_Bool,,,27,"void redisProtocolToLuaType_Bool (void*,int,char*,size_t)"
338912,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Double(void *ctx, double d, const char *proto, size_t proto_len);",13,99,script_lua.c,redisProtocolToLuaType_Double,,false,149,149,redisProtocolToLuaType_Double,,,28,"void redisProtocolToLuaType_Double (void*,double,char*,size_t)"
338920,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_BigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len);",13,121,script_lua.c,redisProtocolToLuaType_BigNumber,,false,150,150,redisProtocolToLuaType_BigNumber,,,29,"void redisProtocolToLuaType_BigNumber (void*,char*,size_t,char*,size_t)"
338929,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_VerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len);",13,146,script_lua.c,redisProtocolToLuaType_VerbatimString,,false,151,151,redisProtocolToLuaType_VerbatimString,,,30,"void redisProtocolToLuaType_VerbatimString (void*,char*,char*,size_t,char*,size_t)"
338939,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Attribute(struct ReplyParser *parser, void *ctx, size_t len, const char *proto);",13,114,script_lua.c,redisProtocolToLuaType_Attribute,,false,152,152,redisProtocolToLuaType_Attribute,,,31,"void redisProtocolToLuaType_Attribute (ReplyParser*,void*,size_t,char*)"
338947,METHOD,script_lua.c:<global>,TYPE_DECL,"static void luaReplyToRedisReply(client *c, client* script_client, lua_State *lua);",13,82,script_lua.c,luaReplyToRedisReply,,false,153,153,luaReplyToRedisReply,,,32,"void luaReplyToRedisReply (client*,client*,lua_State*)"
338954,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr) {
    lua_pushstring(lua, name);
    if (ptr) {
        lua_pushlightuserdata(lua, ptr);
    } else {
        lua_pushnil(lua);
    }
    lua_settable(lua, LUA_REGISTRYINDEX);
}",1,1,script_lua.c,luaSaveOnRegistry,,false,159,167,luaSaveOnRegistry,,,33,"void luaSaveOnRegistry (lua_State*,char*,void*)"
338977,METHOD,script_lua.c:<global>,TYPE_DECL,"void* luaGetFromRegistry(lua_State* lua, const char* name) {
    lua_pushstring(lua, name);
    lua_gettable(lua, LUA_REGISTRYINDEX);

    if (lua_isnil(lua, -1)) {
        lua_pop(lua, 1); /* pops the value */
        return NULL;
    }
    /* must be light user data */
    serverAssert(lua_islightuserdata(lua, -1));

    void* ptr = (void*) lua_topointer(lua, -1);
    serverAssert(ptr);

    /* pops the value */
    lua_pop(lua, 1);

    return ptr;
}",1,4,script_lua.c,luaGetFromRegistry,,false,172,190,luaGetFromRegistry,,,34,"void* luaGetFromRegistry (lua_State*,char*)"
339114,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType(lua_State *lua, char* reply) {
    ReplyParser parser = {.curr_location = reply, .callbacks = DefaultLuaTypeParserCallbacks};

    parseReply(&parser, lua);
}",1,1,script_lua.c,redisProtocolToLuaType,,false,232,236,redisProtocolToLuaType,,,37,"void redisProtocolToLuaType (lua_State*,char*)"
339136,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Int(void *ctx, long long val, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushnumber(lua,(lua_Number)val);
}",1,4,script_lua.c,redisProtocolToLuaType_Int,,false,238,252,redisProtocolToLuaType_Int,,,38,"void redisProtocolToLuaType_Int (void*,long long,char*,size_t)"
339184,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_NullBulkString(void *ctx, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushboolean(lua,0);
}",1,4,script_lua.c,redisProtocolToLuaType_NullBulkString,,false,254,268,redisProtocolToLuaType_NullBulkString,,,39,"void redisProtocolToLuaType_NullBulkString (void*,char*,size_t)"
339229,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_NullArray(void *ctx, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }
    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushboolean(lua,0);
}",1,4,script_lua.c,redisProtocolToLuaType_NullArray,,false,270,283,redisProtocolToLuaType_NullArray,,,40,"void redisProtocolToLuaType_NullArray (void*,char*,size_t)"
339274,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_BulkString(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushlstring(lua,str,len);
}",1,4,script_lua.c,redisProtocolToLuaType_BulkString,,false,286,300,redisProtocolToLuaType_BulkString,,,41,"void redisProtocolToLuaType_BulkString (void*,char*,size_t,char*,size_t)"
339322,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Status(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""ok"");
    lua_pushlstring(lua,str,len);
    lua_settable(lua,-3);
}",1,4,script_lua.c,redisProtocolToLuaType_Status,,false,302,319,redisProtocolToLuaType_Status,,,42,"void redisProtocolToLuaType_Status (void*,char*,size_t,char*,size_t)"
339379,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Error(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    sds err_msg = sdscatlen(sdsnew(""-""), str, len);
    luaPushErrorBuff(lua,err_msg);
    /* push a field indicate to ignore updating the stats on this error
     * because it was already updated when executing the command. */
    lua_pushstring(lua,""ignore_error_stats_update"");
    lua_pushboolean(lua, 1);
    lua_settable(lua,-3);
}",1,4,script_lua.c,redisProtocolToLuaType_Error,,false,321,341,redisProtocolToLuaType_Error,,,43,"void redisProtocolToLuaType_Error (void*,char*,size_t,char*,size_t)"
339444,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Map(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);
    lua_State *lua = ctx;
    if (lua) {
        if (!lua_checkstack(lua, 3)) {
            /* Increase the Lua stack if needed, to make sure there is enough room
             * to push elements to the stack. On failure, exit with panic. */
            serverPanic(""lua stack limit reach when parsing redis.call reply"");
        }
        lua_newtable(lua);
        lua_pushstring(lua, ""map"");
        lua_newtable(lua);
    }
    for (size_t j = 0; j < len; j++) {
        parseReply(parser,lua);
        parseReply(parser,lua);
        if (lua) lua_settable(lua,-3);
    }
    if (lua) lua_settable(lua,-3);
}",1,4,script_lua.c,redisProtocolToLuaType_Map,,false,343,362,redisProtocolToLuaType_Map,,,44,"void redisProtocolToLuaType_Map (ReplyParser*,void*,size_t,char*)"
339518,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Set(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);

    lua_State *lua = ctx;
    if (lua) {
        if (!lua_checkstack(lua, 3)) {
            /* Increase the Lua stack if needed, to make sure there is enough room
             * to push elements to the stack. On failure, exit with panic. */
            serverPanic(""lua stack limit reach when parsing redis.call reply"");
        }
        lua_newtable(lua);
        lua_pushstring(lua, ""set"");
        lua_newtable(lua);
    }
    for (size_t j = 0; j < len; j++) {
        parseReply(parser,lua);
        if (lua) {
            if (!lua_checkstack(lua, 1)) {
                /* Increase the Lua stack if needed, to make sure there is enough room
                 * to push elements to the stack. On failure, exit with panic.
                 * Notice that here we need to check the stack again because the recursive
                 * call to redisProtocolToLuaType...",1,4,script_lua.c,redisProtocolToLuaType_Set,,false,364,393,redisProtocolToLuaType_Set,,,45,"void redisProtocolToLuaType_Set (ReplyParser*,void*,size_t,char*)"
339606,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Array(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);

    lua_State *lua = ctx;
    if (lua){
        if (!lua_checkstack(lua, 2)) {
            /* Increase the Lua stack if needed, to make sure there is enough room
             * to push elements to the stack. On failure, exit with panic. */
            serverPanic(""lua stack limit reach when parsing redis.call reply"");
        }
        lua_newtable(lua);
    }
    for (size_t j = 0; j < len; j++) {
        if (lua) lua_pushnumber(lua,j+1);
        parseReply(parser,lua);
        if (lua) lua_settable(lua,-3);
    }
}",1,4,script_lua.c,redisProtocolToLuaType_Array,,false,395,412,redisProtocolToLuaType_Array,,,46,"void redisProtocolToLuaType_Array (ReplyParser*,void*,size_t,char*)"
339673,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Attribute(struct ReplyParser *parser, void *ctx, size_t len, const char *proto) {
    UNUSED(proto);

    /* Parse the attribute reply.
     * Currently, we do not expose the attribute to the Lua script so
     * we just need to continue parsing and ignore it (the NULL ensures that the
     * reply will be ignored). */
    for (size_t j = 0; j < len; j++) {
        parseReply(parser,NULL);
        parseReply(parser,NULL);
    }

    /* Parse the reply itself. */
    parseReply(parser,ctx);
}",1,4,script_lua.c,redisProtocolToLuaType_Attribute,,false,414,428,redisProtocolToLuaType_Attribute,,,47,"void redisProtocolToLuaType_Attribute (ReplyParser*,void*,size_t,char*)"
339708,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_VerbatimString(void *ctx, const char *format, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 5)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""verbatim_string"");
    lua_newtable(lua);
    lua_pushstring(lua,""string"");
    lua_pushlstring(lua,str,len);
    lua_settable(lua,-3);
    lua_pushstring(lua,""format"");
    lua_pushlstring(lua,format,3);
    lua_settable(lua,-3);
    lua_settable(lua,-3);
}",1,4,script_lua.c,redisProtocolToLuaType_VerbatimString,,false,430,453,redisProtocolToLuaType_VerbatimString,,,48,"void redisProtocolToLuaType_VerbatimString (void*,char*,char*,size_t,char*,size_t)"
339786,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_BigNumber(void *ctx, const char *str, size_t len, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""big_number"");
    lua_pushlstring(lua,str,len);
    lua_settable(lua,-3);
}",1,4,script_lua.c,redisProtocolToLuaType_BigNumber,,false,455,472,redisProtocolToLuaType_BigNumber,,,49,"void redisProtocolToLuaType_BigNumber (void*,char*,size_t,char*,size_t)"
339843,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Null(void *ctx, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushnil(lua);
}",1,4,script_lua.c,redisProtocolToLuaType_Null,,false,474,488,redisProtocolToLuaType_Null,,,50,"void redisProtocolToLuaType_Null (void*,char*,size_t)"
339887,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Bool(void *ctx, int val, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 1)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_pushboolean(lua,val);
}",1,4,script_lua.c,redisProtocolToLuaType_Bool,,false,490,504,redisProtocolToLuaType_Bool,,,51,"void redisProtocolToLuaType_Bool (void*,int,char*,size_t)"
339933,METHOD,script_lua.c:<global>,TYPE_DECL,"static void redisProtocolToLuaType_Double(void *ctx, double d, const char *proto, size_t proto_len) {
    UNUSED(proto);
    UNUSED(proto_len);
    if (!ctx) {
        return;
    }

    lua_State *lua = ctx;
    if (!lua_checkstack(lua, 3)) {
        /* Increase the Lua stack if needed, to make sure there is enough room
         * to push elements to the stack. On failure, exit with panic. */
        serverPanic(""lua stack limit reach when parsing redis.call reply"");
    }
    lua_newtable(lua);
    lua_pushstring(lua,""double"");
    lua_pushnumber(lua,d);
    lua_settable(lua,-3);
}",1,4,script_lua.c,redisProtocolToLuaType_Double,,false,506,523,redisProtocolToLuaType_Double,,,52,"void redisProtocolToLuaType_Double (void*,double,char*,size_t)"
339988,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaPushErrorBuff(lua_State *lua, sds err_buffer) {
    sds msg;
    sds error_code;

    /* If debugging is active and in step mode, log errors resulting from
     * Redis commands. */
    if (ldbIsEnabled()) {
        ldbLog(sdscatprintf(sdsempty(),""<error> %s"",err_buffer));
    }

    /* There are two possible formats for the received `error` string:
     * 1) ""-CODE msg"": in this case we remove the leading '-' since we don't store it as part of the lua error format.
     * 2) ""msg"": in this case we prepend a generic 'ERR' code since all error statuses need some error code.
     * We support format (1) so this function can reuse the error messages used in other places in redis.
     * We support format (2) so it'll be easy to pass descriptive errors to this function without worrying about format.
     */
    if (err_buffer[0] == '-') {
        /* derive error code from the message */
        char *err_msg = strstr(err_buffer, "" "");
        if (!err_msg) {
            msg = sd...",1,1,script_lua.c,luaPushErrorBuff,,false,532,576,luaPushErrorBuff,,,53,"void luaPushErrorBuff (lua_State*,sds)"
340088,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaPushError(lua_State *lua, const char *error) {
    luaPushErrorBuff(lua, sdsnew(error));
}",1,1,script_lua.c,luaPushError,,false,578,580,luaPushError,,,54,"void luaPushError (lua_State*,char*)"
340098,METHOD,script_lua.c:<global>,TYPE_DECL,"int luaError(lua_State *lua) {
    return lua_error(lua);
}",1,1,script_lua.c,luaError,,false,586,588,luaError,,,55,int luaError (lua_State*)
340106,METHOD,script_lua.c:<global>,TYPE_DECL,"static void luaReplyToRedisReply(client *c, client* script_client, lua_State *lua) {
    int t = lua_type(lua,-1);

    if (!lua_checkstack(lua, 4)) {
        /* Increase the Lua stack if needed to make sure there is enough room
         * to push 4 elements to the stack. On failure, return error.
         * Notice that we need, in the worst case, 4 elements because returning a map might
         * require push 4 elements to the Lua stack.*/
        addReplyErrorFormat(c, ""reached lua stack limit"");
        lua_pop(lua,1); /* pop the element from the stack */
        return;
    }

    switch(t) {
    case LUA_TSTRING:
        addReplyBulkCBuffer(c,(char*)lua_tostring(lua,-1),lua_strlen(lua,-1));
        break;
    case LUA_TBOOLEAN:
        if (script_client->resp == 2)
            addReply(c,lua_toboolean(lua,-1) ? shared.cone :
                                               shared.null[c->resp]);
        else
            addReplyBool(c,lua_toboolean(lua,-1));
        break;
    c...",1,68,script_lua.c,luaReplyToRedisReply,,false,597,781,luaReplyToRedisReply,,,56,"void luaReplyToRedisReply (client*,client*,lua_State*)"
340648,METHOD,script_lua.c:<global>,TYPE_DECL,"void freeLuaRedisArgv(robj **argv, int argc, int argv_len);",6,58,script_lua.c,freeLuaRedisArgv,,false,786,786,freeLuaRedisArgv,,,57,"void freeLuaRedisArgv (robj**,int,int)"
340673,METHOD,script_lua.c:<global>,TYPE_DECL,"static robj **luaArgsToRedisArgv(lua_State *lua, int *argc, int *argv_len) {
    int j;
    /* Require at least one argument */
    *argc = lua_gettop(lua);
    if (*argc == 0) {
        luaPushError(lua, ""Please specify at least one argument for this redis lib call"");
        return NULL;
    }

    /* Build the arguments vector (reuse a cached argv from last call) */
    if (lua_argv_size < *argc) {
        lua_argv = zrealloc(lua_argv,sizeof(robj*)* *argc);
        lua_argv_size = *argc;
    }
    *argv_len = lua_argv_size;

    for (j = 0; j < *argc; j++) {
        char *obj_s;
        size_t obj_len;
        char dbuf[64];

        if (lua_type(lua,j+1) == LUA_TNUMBER) {
            /* We can't use lua_tolstring() for number -> string conversion
             * since Lua uses a format specifier that loses precision. */
            lua_Number num = lua_tonumber(lua,j+1);
            obj_len = fpconv_dtoa((double)num, dbuf);
            dbuf[obj_len] = '\0';
            obj_s = db...",1,16,script_lua.c,luaArgsToRedisArgv,,false,796,856,luaArgsToRedisArgv,,,66,"robj luaArgsToRedisArgv (lua_State*,int*,int*)"
340862,METHOD,script_lua.c:<global>,TYPE_DECL,"void freeLuaRedisArgv(robj **argv, int argc, int argv_len) {
    int j;
    for (j = 0; j < argc; j++) {
        robj *o = argv[j];

        /* Try to cache the object in the lua_args_cached_objects array.
         * The object must be small, SDS-encoded, and with refcount = 1
         * (we must be the only owner) for us to cache it. */
        if (j < LUA_CMD_OBJCACHE_SIZE &&
            o->refcount == 1 &&
            (o->encoding == OBJ_ENCODING_RAW ||
             o->encoding == OBJ_ENCODING_EMBSTR) &&
            sdslen(o->ptr) <= LUA_CMD_OBJCACHE_MAX_LEN)
        {
            sds s = o->ptr;
            if (lua_args_cached_objects[j]) decrRefCount(lua_args_cached_objects[j]);
            lua_args_cached_objects[j] = o;
            lua_args_cached_objects_len[j] = sdsalloc(s);
        } else {
            decrRefCount(o);
        }
    }
    if (argv != lua_argv || argv_len != lua_argv_size) {
        /* The command changed argv, scrap the cache and start over. */
        zfr...",1,16,script_lua.c,freeLuaRedisArgv,,false,858,886,freeLuaRedisArgv,,,67,"void freeLuaRedisArgv (robj**,int,int)"
340972,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisGenericCommand(lua_State *lua, int raise_error) {
    int j;
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    sds err = NULL;
    client* c = rctx->c;
    sds reply;

    c->argv = luaArgsToRedisArgv(lua, &c->argc, &c->argv_len);
    if (c->argv == NULL) {
        return raise_error ? luaError(lua) : 1;
    }

    static int inuse = 0;   /* Recursive calls detection. */

    /* By using Lua debug hooks it is possible to trigger a recursive call
     * to luaRedisGenericCommand(), which normally should never happen.
     * To make this function reentrant is futile and makes it slower, but
     * we should at least detect such a misuse, and abort. */
    if (inuse) {
        char *recursion_warning =
                ""luaRedisGenericCommand() recursive call detected. ""
                ""Are you doing funny stuff with Lua debug hooks?"";
        serverLog(LL_WARNING,""%s"",re...",1,49,script_lua.c,luaRedisGenericCommand,,false,888,992,luaRedisGenericCommand,,,68,"int luaRedisGenericCommand (lua_State*,int)"
341343,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisPcall(lua_State *lua) {
    int argc = lua_gettop(lua);
    lua_pushboolean(lua, 1); /* result place holder */
    lua_insert(lua, 1);
    if (lua_pcall(lua, argc - 1, LUA_MULTRET, 0)) {
        /* Error */
        lua_remove(lua, 1); /* remove the result place holder, now we have room for at least one element */
        if (lua_istable(lua, -1)) {
            lua_getfield(lua, -1, ""err"");
            if (lua_isstring(lua, -1)) {
                lua_replace(lua, -2); /* replace the error message with the table */
            }
        }
        lua_pushboolean(lua, 0); /* push result */
        lua_insert(lua, 1);
    }
    return lua_gettop(lua);

}",1,1,script_lua.c,luaRedisPcall,,false,1003,1021,luaRedisPcall,,,69,int luaRedisPcall (lua_State*)
341401,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisCallCommand(lua_State *lua) {
    return luaRedisGenericCommand(lua,1);
}",1,1,script_lua.c,luaRedisCallCommand,,false,1024,1026,luaRedisCallCommand,,,70,int luaRedisCallCommand (lua_State*)
341410,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisPCallCommand(lua_State *lua) {
    return luaRedisGenericCommand(lua,0);
}",1,1,script_lua.c,luaRedisPCallCommand,,false,1029,1031,luaRedisPCallCommand,,,71,int luaRedisPCallCommand (lua_State*)
341419,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisSha1hexCommand(lua_State *lua) {
    int argc = lua_gettop(lua);
    char digest[41];
    size_t len;
    char *s;

    if (argc != 1) {
        luaPushError(lua, ""wrong number of arguments"");
        return luaError(lua);
    }

    s = (char*)lua_tolstring(lua,1,&len);
    sha1hex(digest,s,len);
    lua_pushstring(lua,digest);
    return 1;
}",1,1,script_lua.c,luaRedisSha1hexCommand,,false,1035,1050,luaRedisSha1hexCommand,,,72,int luaRedisSha1hexCommand (lua_State*)
341461,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {
    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
        luaPushError(lua, ""wrong number or type of arguments"");
        return 1;
    }

    lua_newtable(lua);
    lua_pushstring(lua, field);
    lua_pushvalue(lua, -3);
    lua_settable(lua, -3);
    return 1;
}",1,1,script_lua.c,luaRedisReturnSingleFieldTable,,false,1059,1070,luaRedisReturnSingleFieldTable,,,73,"int luaRedisReturnSingleFieldTable (lua_State*,char*)"
341500,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisErrorReplyCommand(lua_State *lua) {
    if (lua_gettop(lua) != 1 || lua_type(lua,-1) != LUA_TSTRING) {
        luaPushError(lua, ""wrong number or type of arguments"");
        return 1;
    }

    /* add '-' if not exists */
    const char *err = lua_tostring(lua, -1);
    sds err_buff = NULL;
    if (err[0] != '-') {
        err_buff = sdscatfmt(sdsempty(), ""-%s"", err);
    } else {
        err_buff = sdsnew(err);
    }
    luaPushErrorBuff(lua, err_buff);
    return 1;
}",1,1,script_lua.c,luaRedisErrorReplyCommand,,false,1073,1089,luaRedisErrorReplyCommand,,,74,int luaRedisErrorReplyCommand (lua_State*)
341558,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisStatusReplyCommand(lua_State *lua) {
    return luaRedisReturnSingleFieldTable(lua,""ok"");
}",1,1,script_lua.c,luaRedisStatusReplyCommand,,false,1092,1094,luaRedisStatusReplyCommand,,,75,int luaRedisStatusReplyCommand (lua_State*)
341567,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisSetReplCommand(lua_State *lua) {
    int flags, argc = lua_gettop(lua);

    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */

    if (argc != 1) {
        luaPushError(lua, ""redis.set_repl() requires one argument."");
         return luaError(lua);
    }

    flags = lua_tonumber(lua,-1);
    if ((flags & ~(PROPAGATE_AOF|PROPAGATE_REPL)) != 0) {
        luaPushError(lua, ""Invalid replication flags. Use REPL_AOF, REPL_REPLICA, REPL_ALL or REPL_NONE."");
        return luaError(lua);
    }

    scriptSetRepl(rctx, flags);
    return 0;
}",1,49,script_lua.c,luaRedisSetReplCommand,,false,1100,1119,luaRedisSetReplCommand,,,76,int luaRedisSetReplCommand (lua_State*)
341643,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaRedisAclCheckCmdPermissionsCommand(lua_State *lua) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    int raise_error = 0;

    int argc, argv_len;
    robj **argv = luaArgsToRedisArgv(lua, &argc, &argv_len);

    /* Require at least one argument */
    if (argv == NULL) return luaError(lua);

    /* Find command */
    struct redisCommand *cmd;
    if ((cmd = lookupCommand(argv, argc)) == NULL) {
        luaPushError(lua, ""Invalid command passed to redis.acl_check_cmd()"");
        raise_error = 1;
    } else {
        int keyidxptr;
        if (ACLCheckAllUserCommandPerm(rctx->original_client->user, cmd, argv, argc, &keyidxptr) != ACL_OK) {
            lua_pushboolean(lua, 0);
        } else {
            lua_pushboolean(lua, 1);
        }
    }

    freeLuaRedisArgv(argv, argc, argv_len);
    if (raise_error)
        return luaError(lua);
    else
        return 1;
}",1,49,script_lua.c,luaRedisAclCheckCmdPermissionsCommand,,false,1124,1154,luaRedisAclCheckCmdPermissionsCommand,,,77,int luaRedisAclCheckCmdPermissionsCommand (lua_State*)
341752,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaLogCommand(lua_State *lua) {
    int j, argc = lua_gettop(lua);
    int level;
    sds log;

    if (argc < 2) {
        luaPushError(lua, ""redis.log() requires two arguments or more."");
        return luaError(lua);
    } else if (!lua_isnumber(lua,-argc)) {
        luaPushError(lua, ""First argument must be a number (log level)."");
        return luaError(lua);
    }
    level = lua_tonumber(lua,-argc);
    if (level < LL_DEBUG || level > LL_WARNING) {
        luaPushError(lua, ""Invalid debug level."");
        return luaError(lua);
    }
    if (level < server.verbosity) return 0;

    /* Glue together all the arguments */
    log = sdsempty();
    for (j = 1; j < argc; j++) {
        size_t len;
        char *s;

        s = (char*)lua_tolstring(lua,(-argc)+j,&len);
        if (s) {
            if (j != 1) log = sdscatlen(log,"" "",1);
            log = sdscatlen(log,s,len);
        }
    }
    serverLogRaw(level,log);
    sdsfree(log);
    return 0;
}",1,16,script_lua.c,luaLogCommand,,false,1158,1192,luaLogCommand,,,78,int luaLogCommand (lua_State*)
341880,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaSetResp(lua_State *lua) {
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    int argc = lua_gettop(lua);

    if (argc != 1) {
        luaPushError(lua, ""redis.setresp() requires one argument."");
        return luaError(lua);
    }

    int resp = lua_tonumber(lua,-argc);
    if (resp != 2 && resp != 3) {
        luaPushError(lua, ""RESP version must be 2 or 3."");
        return luaError(lua);
    }
    scriptSetResp(rctx, resp);
    return 0;
}",1,49,script_lua.c,luaSetResp,,false,1195,1212,luaSetResp,,,79,int luaSetResp (lua_State*)
341951,METHOD,script_lua.c:<global>,TYPE_DECL,"static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {
  lua_pushcfunction(lua, luafunc);
  lua_pushstring(lua, libname);
  lua_call(lua, 1, 0);
}",1,1,script_lua.c,luaLoadLib,,false,1218,1222,luaLoadLib,,,80,"void luaLoadLib (lua_State*,char*,lua_CFunction)"
341969,METHOD,script_lua.c:<global>,TYPE_DECL,int (luaopen_cjson) (lua_State *L);,16,45,script_lua.c,luaopen_cjson,,false,1224,1224,luaopen_cjson,,,82,int luaopen_cjson (lua_State*)
341975,METHOD,script_lua.c:<global>,TYPE_DECL,int (luaopen_struct) (lua_State *L);,16,46,script_lua.c,luaopen_struct,,false,1225,1225,luaopen_struct,,,84,int luaopen_struct (lua_State*)
341981,METHOD,script_lua.c:<global>,TYPE_DECL,int (luaopen_cmsgpack) (lua_State *L);,16,48,script_lua.c,luaopen_cmsgpack,,false,1226,1226,luaopen_cmsgpack,,,86,int luaopen_cmsgpack (lua_State*)
341987,METHOD,script_lua.c:<global>,TYPE_DECL,int (luaopen_bit) (lua_State *L);,16,43,script_lua.c,luaopen_bit,,false,1227,1227,luaopen_bit,,,88,int luaopen_bit (lua_State*)
341992,METHOD,script_lua.c:<global>,TYPE_DECL,"static void luaLoadLibraries(lua_State *lua) {
    luaLoadLib(lua, """", luaopen_base);
    luaLoadLib(lua, LUA_TABLIBNAME, luaopen_table);
    luaLoadLib(lua, LUA_STRLIBNAME, luaopen_string);
    luaLoadLib(lua, LUA_MATHLIBNAME, luaopen_math);
    luaLoadLib(lua, LUA_DBLIBNAME, luaopen_debug);
    luaLoadLib(lua, ""cjson"", luaopen_cjson);
    luaLoadLib(lua, ""struct"", luaopen_struct);
    luaLoadLib(lua, ""cmsgpack"", luaopen_cmsgpack);
    luaLoadLib(lua, ""bit"", luaopen_bit);

#if 0 /* Stuff that we don't load currently, for sandboxing concerns. */
    luaLoadLib(lua, LUA_LOADLIBNAME, luaopen_package);
    luaLoadLib(lua, LUA_OSLIBNAME, luaopen_os);
#endif
}",1,1,script_lua.c,luaLoadLibraries,,false,1229,1244,luaLoadLibraries,,,89,void luaLoadLibraries (lua_State*)
342033,METHOD,script_lua.c:<global>,TYPE_DECL,"sds luaGetStringSds(lua_State *lua, int index) {
    if (!lua_isstring(lua, index)) {
        return NULL;
    }

    size_t len;
    const char *str = lua_tolstring(lua, index, &len);
    sds str_sds = sdsnewlen(str, len);
    return str_sds;
}",1,1,script_lua.c,luaGetStringSds,,false,1248,1257,luaGetStringSds,,,90,"sds luaGetStringSds (lua_State*,int)"
342064,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaProtectedTableError(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 2) {
        serverLog(LL_WARNING, ""malicious code trying to call luaProtectedTableError with wrong arguments"");
        luaL_error(lua, ""Wrong number of arguments to luaProtectedTableError"");
    }
    if (!lua_isstring(lua, -1) && !lua_isnumber(lua, -1)) {
        luaL_error(lua, ""Second argument to luaProtectedTableError must be a string or number"");
    }
    const char *variable_name = lua_tostring(lua, -1);
    luaL_error(lua, ""Script attempted to access nonexistent global variable '%s'"", variable_name);
    return 0;
}",1,8,script_lua.c,luaProtectedTableError,,false,1259,1271,luaProtectedTableError,,,91,int luaProtectedTableError (lua_State*)
342129,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaSetErrorMetatable(lua_State *lua) {
    lua_newtable(lua); /* push metatable */
    lua_pushcfunction(lua, luaProtectedTableError); /* push get error handler */
    lua_setfield(lua, -2, ""__index"");
    lua_setmetatable(lua, -2);
}",1,1,script_lua.c,luaSetErrorMetatable,,false,1280,1285,luaSetErrorMetatable,,,92,void luaSetErrorMetatable (lua_State*)
342148,METHOD,script_lua.c:<global>,TYPE_DECL,"static int luaNewIndexAllowList(lua_State *lua) {
    int argc = lua_gettop(lua);
    if (argc != 3) {
        serverLog(LL_WARNING, ""malicious code trying to call luaNewIndexAllowList with wrong arguments"");
        luaL_error(lua, ""Wrong number of arguments to luaNewIndexAllowList"");
    }
    if (!lua_istable(lua, -3)) {
        luaL_error(lua, ""first argument to luaNewIndexAllowList must be a table"");
    }
    if (!lua_isstring(lua, -2) && !lua_isnumber(lua, -2)) {
        luaL_error(lua, ""Second argument to luaNewIndexAllowList must be a string or number"");
    }
    const char *variable_name = lua_tostring(lua, -2);
    /* check if the key is in our allow list */

    char ***allow_l = allow_lists;
    for (; *allow_l ; ++allow_l){
        char **c = *allow_l;
        for (; *c ; ++c) {
            if (strcmp(*c, variable_name) == 0) {
                break;
            }
        }
        if (*c) {
            break;
        }
    }
    if (!*allow_l) {
        /* Search the...",1,8,script_lua.c,luaNewIndexAllowList,,false,1287,1330,luaNewIndexAllowList,,,93,int luaNewIndexAllowList (lua_State*)
342311,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaSetAllowListProtection(lua_State *lua) {
    lua_newtable(lua); /* push metatable */
    lua_pushcfunction(lua, luaNewIndexAllowList); /* push get error handler */
    lua_setfield(lua, -2, ""__newindex"");
    lua_setmetatable(lua, -2);
}",1,1,script_lua.c,luaSetAllowListProtection,,false,1338,1343,luaSetAllowListProtection,,,94,void luaSetAllowListProtection (lua_State*)
342330,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaSetTableProtectionRecursively(lua_State *lua) {
    /* This protect us from a loop in case we already visited the table
     * For example, globals has '_G' key which is pointing back to globals. */
    if (lua_isreadonlytable(lua, -1)) {
        return;
    }

    /* protect the current table */
    lua_enablereadonlytable(lua, -1, 1);

    lua_checkstack(lua, 2);
    lua_pushnil(lua); /* Use nil to start iteration. */
    while (lua_next(lua,-2)) {
        /* Stack now: table, key, value */
        if (lua_istable(lua, -1)) {
            luaSetTableProtectionRecursively(lua);
        }
        lua_pop(lua, 1);
    }

    /* protect the metatable if exists */
    if (lua_getmetatable(lua, -1)) {
        luaSetTableProtectionRecursively(lua);
        lua_pop(lua, 1); /* pop the metatable */
    }
}",1,1,script_lua.c,luaSetTableProtectionRecursively,,false,1348,1373,luaSetTableProtectionRecursively,,,95,void luaSetTableProtectionRecursively (lua_State*)
342380,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaRegisterVersion(lua_State* lua) {
    lua_pushstring(lua,""REDIS_VERSION_NUM"");
    lua_pushnumber(lua,REDIS_VERSION_NUM);
    lua_settable(lua,-3);

    lua_pushstring(lua,""REDIS_VERSION"");
    lua_pushstring(lua,REDIS_VERSION);
    lua_settable(lua,-3);
}",1,23,script_lua.c,luaRegisterVersion,,false,1375,1383,luaRegisterVersion,,,96,void luaRegisterVersion (lua_State*)
342409,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaRegisterLogFunction(lua_State* lua) {
    /* redis.log and log levels. */
    lua_pushstring(lua,""log"");
    lua_pushcfunction(lua,luaLogCommand);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_DEBUG"");
    lua_pushnumber(lua,LL_DEBUG);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_VERBOSE"");
    lua_pushnumber(lua,LL_VERBOSE);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_NOTICE"");
    lua_pushnumber(lua,LL_NOTICE);
    lua_settable(lua,-3);

    lua_pushstring(lua,""LOG_WARNING"");
    lua_pushnumber(lua,LL_WARNING);
    lua_settable(lua,-3);
}",1,23,script_lua.c,luaRegisterLogFunction,,false,1385,1406,luaRegisterLogFunction,,,97,void luaRegisterLogFunction (lua_State*)
342472,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaRegisterRedisAPI(lua_State* lua) {
    lua_pushvalue(lua, LUA_GLOBALSINDEX);
    luaSetAllowListProtection(lua);
    lua_pop(lua, 1);

    luaLoadLibraries(lua);

    lua_pushcfunction(lua,luaRedisPcall);
    lua_setglobal(lua, ""pcall"");

    /* Register the redis commands table and fields */
    lua_newtable(lua);

    /* redis.call */
    lua_pushstring(lua,""call"");
    lua_pushcfunction(lua,luaRedisCallCommand);
    lua_settable(lua,-3);

    /* redis.pcall */
    lua_pushstring(lua,""pcall"");
    lua_pushcfunction(lua,luaRedisPCallCommand);
    lua_settable(lua,-3);

    luaRegisterLogFunction(lua);

    luaRegisterVersion(lua);

    /* redis.setresp */
    lua_pushstring(lua,""setresp"");
    lua_pushcfunction(lua,luaSetResp);
    lua_settable(lua,-3);

    /* redis.sha1hex */
    lua_pushstring(lua, ""sha1hex"");
    lua_pushcfunction(lua, luaRedisSha1hexCommand);
    lua_settable(lua, -3);

    /* redis.error_reply and redis.status_reply */
    lua_pushstring(lua, ""error_r...",1,23,script_lua.c,luaRegisterRedisAPI,,false,1408,1498,luaRegisterRedisAPI,,,98,void luaRegisterRedisAPI (lua_State*)
342674,METHOD,script_lua.c:<global>,TYPE_DECL,"static void luaCreateArray(lua_State *lua, robj **elev, int elec) {
    int j;

    lua_newtable(lua);
    for (j = 0; j < elec; j++) {
        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));
        lua_rawseti(lua,-2,j+1);
    }
}",1,1,script_lua.c,luaCreateArray,,false,1502,1510,luaCreateArray,,,99,"void luaCreateArray (lua_State*,robj**,int)"
342717,METHOD,script_lua.c:<global>,TYPE_DECL,"static int redis_math_random (lua_State *L) {
  /* the `%' avoids the (rare) case of r==1, and is needed also because on
     some systems (SunOS!) `rand()' may return a value larger than RAND_MAX */
  lua_Number r = (lua_Number)(redisLrand48()%REDIS_LRAND48_MAX) /
                                (lua_Number)REDIS_LRAND48_MAX;
  switch (lua_gettop(L)) {  /* check number of arguments */
    case 0: {  /* no arguments */
      lua_pushnumber(L, r);  /* Number between 0 and 1 */
      break;
    }
    case 1: {  /* only upper limit */
      int u = luaL_checkint(L, 1);
      luaL_argcheck(L, 1<=u, 1, ""interval is empty"");
      lua_pushnumber(L, floor(r*u)+1);  /* int between 1 and `u' */
      break;
    }
    case 2: {  /* lower and upper limits */
      int l = luaL_checkint(L, 1);
      int u = luaL_checkint(L, 2);
      luaL_argcheck(L, l<=u, 2, ""interval is empty"");
      lua_pushnumber(L, floor(r*(u-l+1))+l);  /* int between `l' and `u' */
      break;
    }
    default: return ...",1,45,script_lua.c,redis_math_random,,false,1522,1548,redis_math_random,,,100,int redis_math_random (lua_State*)
342815,METHOD,script_lua.c:<global>,TYPE_DECL,"static int redis_math_randomseed (lua_State *L) {
  redisSrand48(luaL_checkint(L, 1));
  return 0;
}",1,1,script_lua.c,redis_math_randomseed,,false,1550,1553,redis_math_randomseed,,,101,int redis_math_randomseed (lua_State*)
342826,METHOD,script_lua.c:<global>,TYPE_DECL,"static void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {
    UNUSED(ar);
    scriptRunCtx* rctx = luaGetFromRegistry(lua, REGISTRY_RUN_CTX_NAME);
    serverAssert(rctx); /* Only supported inside script invocation */
    if (scriptInterrupt(rctx) == SCRIPT_KILL) {
        serverLog(LL_NOTICE,""Lua script killed by user with SCRIPT KILL."");

        /*
         * Set the hook to invoke all the time so the user
         * will not be able to catch the error with pcall and invoke
         * pcall again which will prevent the script from ever been killed
         */
        lua_sethook(lua, luaMaskCountHook, LUA_MASKLINE, 0);

        luaPushError(lua,""Script killed by user with SCRIPT KILL..."");
        luaError(lua);
    }
}",1,4,script_lua.c,luaMaskCountHook,,false,1556,1573,luaMaskCountHook,,,102,"void luaMaskCountHook (lua_State*,lua_Debug*)"
342897,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaErrorInformationDiscard(errorInfo *err_info) {
    if (err_info->msg) sdsfree(err_info->msg);
    if (err_info->source) sdsfree(err_info->source);
    if (err_info->line) sdsfree(err_info->line);
}",1,1,script_lua.c,luaErrorInformationDiscard,,false,1575,1579,luaErrorInformationDiscard,,,103,void luaErrorInformationDiscard (errorInfo*)
342929,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaExtractErrorInformation(lua_State *lua, errorInfo *err_info) {
    if (lua_isstring(lua, -1)) {
        err_info->msg = sdscatfmt(sdsempty(), ""ERR %s"", lua_tostring(lua, -1));
        err_info->line = NULL;
        err_info->source = NULL;
        err_info->ignore_err_stats_update = 0;
        return;
    }

    lua_getfield(lua, -1, ""err"");
    if (lua_isstring(lua, -1)) {
        err_info->msg = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""source"");
    if (lua_isstring(lua, -1)) {
        err_info->source = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""line"");
    if (lua_isstring(lua, -1)) {
        err_info->line = sdsnew(lua_tostring(lua, -1));
    }
    lua_pop(lua, 1);

    lua_getfield(lua, -1, ""ignore_error_stats_update"");
    if (lua_isboolean(lua, -1)) {
        err_info->ignore_err_stats_update = lua_toboolean(lua, -1);
    }
    lua_pop(lua, 1);
}",1,1,script_lua.c,luaExtractErrorInformation,,false,1581,1613,luaExtractErrorInformation,,,104,"void luaExtractErrorInformation (lua_State*,errorInfo*)"
343059,METHOD,script_lua.c:<global>,TYPE_DECL,"void luaCallFunction(scriptRunCtx* run_ctx, lua_State *lua, robj** keys, size_t nkeys, robj** args, size_t nargs, int debug_enabled) {
    client* c = run_ctx->original_client;
    int delhook = 0;

    /* We must set it before we set the Lua hook, theoretically the
     * Lua hook might be called wheneven we run any Lua instruction
     * such as 'luaSetGlobalArray' and we want the run_ctx to be available
     * each time the Lua hook is invoked. */
    luaSaveOnRegistry(lua, REGISTRY_RUN_CTX_NAME, run_ctx);

    if (server.busy_reply_threshold > 0 && !debug_enabled) {
        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);
        delhook = 1;
    } else if (debug_enabled) {
        lua_sethook(lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);
        delhook = 1;
    }

    /* Populate the argv and keys table accordingly to the arguments that
     * EVAL received. */
    luaCreateArray(lua,keys,nkeys);
    /* On eval, keys and arguments are globals. */
    if (run_ct...",1,27,script_lua.c,luaCallFunction,,false,1615,1718,luaCallFunction,,,105,"void luaCallFunction (scriptRunCtx*,lua_State*,robj**,size_t,robj**,size_t,int)"
343344,METHOD,script_lua.c:<global>,TYPE_DECL,"unsigned long luaMemory(lua_State *lua) {
    return lua_gc(lua, LUA_GCCOUNT, 0) * 1024LL;
}",1,1,script_lua.c,luaMemory,,false,1720,1722,luaMemory,,,106,unsigned long luaMemory (lua_State*)
343369,METHOD,script_lua.h:<global>,TYPE_DECL,<global>,1,1,script_lua.h,script_lua.h:<global>,,false,1,87,<global>,,,1,
343377,METHOD,script_lua.h:<global>,TYPE_DECL,void luaRegisterRedisAPI(lua_State* lua);,6,40,script_lua.h,luaRegisterRedisAPI,,false,68,68,luaRegisterRedisAPI,,,3,void luaRegisterRedisAPI (lua_State*)
343382,METHOD,script_lua.h:<global>,TYPE_DECL,"sds luaGetStringSds(lua_State *lua, int index);",5,46,script_lua.h,luaGetStringSds,,false,69,69,luaGetStringSds,,,4,"sds luaGetStringSds (lua_State*,int)"
343388,METHOD,script_lua.h:<global>,TYPE_DECL,void luaRegisterGlobalProtectionFunction(lua_State *lua);,6,56,script_lua.h,luaRegisterGlobalProtectionFunction,,false,70,70,luaRegisterGlobalProtectionFunction,,,5,void luaRegisterGlobalProtectionFunction (lua_State*)
343393,METHOD,script_lua.h:<global>,TYPE_DECL,void luaSetErrorMetatable(lua_State *lua);,6,41,script_lua.h,luaSetErrorMetatable,,false,71,71,luaSetErrorMetatable,,,6,void luaSetErrorMetatable (lua_State*)
343398,METHOD,script_lua.h:<global>,TYPE_DECL,void luaSetAllowListProtection(lua_State *lua);,6,46,script_lua.h,luaSetAllowListProtection,,false,72,72,luaSetAllowListProtection,,,7,void luaSetAllowListProtection (lua_State*)
343403,METHOD,script_lua.h:<global>,TYPE_DECL,void luaSetTableProtectionRecursively(lua_State *lua);,6,53,script_lua.h,luaSetTableProtectionRecursively,,false,73,73,luaSetTableProtectionRecursively,,,8,void luaSetTableProtectionRecursively (lua_State*)
343408,METHOD,script_lua.h:<global>,TYPE_DECL,void luaRegisterLogFunction(lua_State* lua);,6,43,script_lua.h,luaRegisterLogFunction,,false,74,74,luaRegisterLogFunction,,,9,void luaRegisterLogFunction (lua_State*)
343413,METHOD,script_lua.h:<global>,TYPE_DECL,void luaRegisterVersion(lua_State* lua);,6,39,script_lua.h,luaRegisterVersion,,false,75,75,luaRegisterVersion,,,10,void luaRegisterVersion (lua_State*)
343418,METHOD,script_lua.h:<global>,TYPE_DECL,"void luaPushErrorBuff(lua_State *lua, sds err_buff);",6,51,script_lua.h,luaPushErrorBuff,,false,76,76,luaPushErrorBuff,,,11,"void luaPushErrorBuff (lua_State*,sds)"
343424,METHOD,script_lua.h:<global>,TYPE_DECL,"void luaPushError(lua_State *lua, const char *error);",6,52,script_lua.h,luaPushError,,false,77,77,luaPushError,,,12,"void luaPushError (lua_State*,char*)"
343430,METHOD,script_lua.h:<global>,TYPE_DECL,int luaError(lua_State *lua);,5,28,script_lua.h,luaError,,false,78,78,luaError,,,13,int luaError (lua_State*)
343435,METHOD,script_lua.h:<global>,TYPE_DECL,"void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr);",6,67,script_lua.h,luaSaveOnRegistry,,false,79,79,luaSaveOnRegistry,,,14,"void luaSaveOnRegistry (lua_State*,char*,void*)"
343442,METHOD,script_lua.h:<global>,TYPE_DECL,"void* luaGetFromRegistry(lua_State* lua, const char* name);",5,58,script_lua.h,luaGetFromRegistry,,false,80,80,luaGetFromRegistry,,,15,"void* luaGetFromRegistry (lua_State*,char*)"
343448,METHOD,script_lua.h:<global>,TYPE_DECL,"void luaCallFunction(scriptRunCtx* r_ctx, lua_State *lua, robj** keys, size_t nkeys, robj** args, size_t nargs, int debug_enabled);",6,130,script_lua.h,luaCallFunction,,false,81,81,luaCallFunction,,,16,"void luaCallFunction (scriptRunCtx*,lua_State*,robj**,size_t,robj**,size_t,int)"
343459,METHOD,script_lua.h:<global>,TYPE_DECL,"void luaExtractErrorInformation(lua_State *lua, errorInfo *err_info);",6,68,script_lua.h,luaExtractErrorInformation,,false,82,82,luaExtractErrorInformation,,,17,"void luaExtractErrorInformation (lua_State*,errorInfo*)"
343465,METHOD,script_lua.h:<global>,TYPE_DECL,void luaErrorInformationDiscard(errorInfo *err_info);,6,52,script_lua.h,luaErrorInformationDiscard,,false,83,83,luaErrorInformationDiscard,,,18,void luaErrorInformationDiscard (errorInfo*)
343470,METHOD,script_lua.h:<global>,TYPE_DECL,unsigned long luaMemory(lua_State *lua);,15,39,script_lua.h,luaMemory,,false,84,84,luaMemory,,,19,long unsigned luaMemory (lua_State*)
343502,METHOD,sds.c:<global>,TYPE_DECL,<global>,1,20,sds.c,sds.c:<global>,,false,1,1494,<global>,,,1,
343508,METHOD,sds.c:<global>,TYPE_DECL,"static inline int sdsHdrSize(char type) {
    switch(type&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return sizeof(struct sdshdr5);
        case SDS_TYPE_8:
            return sizeof(struct sdshdr8);
        case SDS_TYPE_16:
            return sizeof(struct sdshdr16);
        case SDS_TYPE_32:
            return sizeof(struct sdshdr32);
        case SDS_TYPE_64:
            return sizeof(struct sdshdr64);
    }
    return 0;
}",1,16,sds.c,sdsHdrSize,,false,45,59,sdsHdrSize,,,3,int sdsHdrSize (char)
343557,METHOD,sds.c:<global>,TYPE_DECL,"static inline char sdsReqType(size_t string_size) {
    if (string_size < 1<<5)
        return SDS_TYPE_5;
    if (string_size < 1<<8)
        return SDS_TYPE_8;
    if (string_size < 1<<16)
        return SDS_TYPE_16;
#if (LONG_MAX == LLONG_MAX)
    if (string_size < 1ll<<32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
#else
    return SDS_TYPE_32;
#endif
}",1,15,sds.c,sdsReqType,,false,61,75,sdsReqType,,,4,char sdsReqType (size_t)
343610,METHOD,sds.c:<global>,TYPE_DECL,"static inline size_t sdsTypeMaxSize(char type) {
    if (type == SDS_TYPE_5)
        return (1<<5) - 1;
    if (type == SDS_TYPE_8)
        return (1<<8) - 1;
    if (type == SDS_TYPE_16)
        return (1<<16) - 1;
#if (LONG_MAX == LLONG_MAX)
    if (type == SDS_TYPE_32)
        return (1ll<<32) - 1;
#endif
    return -1; /* this is equivalent to the max SDS_TYPE_64 or SDS_TYPE_32 */
}",1,16,sds.c,sdsTypeMaxSize,,false,77,89,sdsTypeMaxSize,,,5,size_t sdsTypeMaxSize (char)
343670,METHOD,sds.c:<global>,TYPE_DECL,"sds _sdsnewlen(const void *init, size_t initlen, int trymalloc) {
    void *sh;
    sds s;
    char type = sdsReqType(initlen);
    /* Empty strings are usually created in order to append. Use type 8
     * since type 5 is not good at this. */
    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;
    int hdrlen = sdsHdrSize(type);
    unsigned char *fp; /* flags pointer. */
    size_t usable;

    assert(initlen + hdrlen + 1 > initlen); /* Catch size_t overflow */
    sh = trymalloc?
        s_trymalloc_usable(hdrlen+initlen+1, &usable) :
        s_malloc_usable(hdrlen+initlen+1, &usable);
    if (sh == NULL) return NULL;
    if (init==SDS_NOINIT)
        init = NULL;
    else if (!init)
        memset(sh, 0, hdrlen+initlen+1);
    s = (char*)sh+hdrlen;
    fp = ((unsigned char*)s)-1;
    usable = usable-hdrlen-1;
    if (usable > sdsTypeMaxSize(type))
        usable = sdsTypeMaxSize(type);
    switch(type) {
        case SDS_TYPE_5: {
            *fp = type | (initlen << S...",1,16,sds.c,_sdsnewlen,,false,104,167,_sdsnewlen,,,6,"sds _sdsnewlen (void*,size_t,int)"
343962,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsnewlen(const void *init, size_t initlen) {
    return _sdsnewlen(init, initlen, 0);
}",1,1,sds.c,sdsnewlen,,false,169,171,sdsnewlen,,,7,"sds sdsnewlen (void*,size_t)"
343973,METHOD,sds.c:<global>,TYPE_DECL,"sds sdstrynewlen(const void *init, size_t initlen) {
    return _sdsnewlen(init, initlen, 1);
}",1,1,sds.c,sdstrynewlen,,false,173,175,sdstrynewlen,,,8,"sds sdstrynewlen (void*,size_t)"
343984,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsempty(void) {
    return sdsnewlen("""",0);
}",1,1,sds.c,sdsempty,,false,179,181,sdsempty,,,9,sds sdsempty (void)
343993,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsnew(const char *init) {
    size_t initlen = (init == NULL) ? 0 : strlen(init);
    return sdsnewlen(init, initlen);
}",1,1,sds.c,sdsnew,,false,184,187,sdsnew,,,10,sds sdsnew (char*)
344012,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsdup(const sds s) {
    return sdsnewlen(s, sdslen(s));
}",1,1,sds.c,sdsdup,,false,190,192,sdsdup,,,11,sds sdsdup (sds)
344022,METHOD,sds.c:<global>,TYPE_DECL,"void sdsfree(sds s) {
    if (s == NULL) return;
    s_free((char*)s-sdsHdrSize(s[-1]));
}",1,4,sds.c,sdsfree,,false,195,198,sdsfree,,,12,void sdsfree (sds)
344045,METHOD,sds.c:<global>,TYPE_DECL,"void sdsupdatelen(sds s) {
    size_t reallen = strlen(s);
    sdssetlen(s, reallen);
}",1,1,sds.c,sdsupdatelen,,false,214,217,sdsupdatelen,,,13,void sdsupdatelen (sds)
344058,METHOD,sds.c:<global>,TYPE_DECL,"void sdsclear(sds s) {
    sdssetlen(s, 0);
    s[0] = '\0';
}",1,1,sds.c,sdsclear,,false,223,226,sdsclear,,,14,void sdsclear (sds)
344071,METHOD,sds.c:<global>,TYPE_DECL,"sds _sdsMakeRoomFor(sds s, size_t addlen, int greedy) {
    void *sh, *newsh;
    size_t avail = sdsavail(s);
    size_t len, newlen, reqlen;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;
    size_t usable;

    /* Return ASAP if there is enough space left. */
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s-sdsHdrSize(oldtype);
    reqlen = newlen = (len+addlen);
    assert(newlen > len);   /* Catch size_t overflow */
    if (greedy == 1) {
        if (newlen < SDS_MAX_PREALLOC)
            newlen *= 2;
        else
            newlen += SDS_MAX_PREALLOC;
    }

    type = sdsReqType(newlen);

    /* Don't use type 5: the user is appending to the string and type 5 is
     * not able to remember empty space, so sdsMakeRoomFor() must be called
     * at every appending operation. */
    if (type == SDS_TYPE_5) type = SDS_TYPE_8;

    hdrlen = sdsHdrSize(type);
    assert(hdrlen + newlen + 1 > reqlen);  /* Catch size_t overflow */
    if (ol...",1,33,sds.c,_sdsMakeRoomFor,,false,240,291,_sdsMakeRoomFor,,,15,"sds _sdsMakeRoomFor (sds,size_t,int)"
344291,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsMakeRoomFor(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 1);
}",1,1,sds.c,sdsMakeRoomFor,,false,295,297,sdsMakeRoomFor,,,16,"sds sdsMakeRoomFor (sds,size_t)"
344302,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsMakeRoomForNonGreedy(sds s, size_t addlen) {
    return _sdsMakeRoomFor(s, addlen, 0);
}",1,1,sds.c,sdsMakeRoomForNonGreedy,,false,300,302,sdsMakeRoomForNonGreedy,,,17,"sds sdsMakeRoomForNonGreedy (sds,size_t)"
344313,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsRemoveFreeSpace(sds s, int would_regrow) {
    return sdsResize(s, sdslen(s), would_regrow);
}",1,1,sds.c,sdsRemoveFreeSpace,,false,310,312,sdsRemoveFreeSpace,,,18,"sds sdsRemoveFreeSpace (sds,int)"
344325,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsResize(sds s, size_t size, int would_regrow) {
    void *sh, *newsh;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);
    size_t len = sdslen(s);
    sh = (char*)s-oldhdrlen;

    /* Return ASAP if the size is already good. */
    if (sdsalloc(s) == size) return s;

    /* Truncate len if needed. */
    if (size < len) len = size;

    /* Check what would be the minimum SDS header that is just good enough to
     * fit this string. */
    type = sdsReqType(size);
    if (would_regrow) {
        /* Don't use type 5, it is not good for strings that are expected to grow back. */
        if (type == SDS_TYPE_5) type = SDS_TYPE_8;
    }
    hdrlen = sdsHdrSize(type);

    /* If the type is the same, or can hold the size in it with low overhead
     * (larger than SDS_TYPE_8), we just realloc(), letting the allocator
     * to do the copy only if really needed. Otherwise if the change is
     * huge, we manually reallocate the string ...",1,33,sds.c,sdsResize,,false,323,377,sdsResize,,,19,"sds sdsResize (sds,size_t,int)"
344522,METHOD,sds.c:<global>,TYPE_DECL,"size_t sdsAllocSize(sds s) {
    size_t alloc = sdsalloc(s);
    return sdsHdrSize(s[-1])+alloc+1;
}",1,1,sds.c,sdsAllocSize,,false,386,389,sdsAllocSize,,,20,size_t sdsAllocSize (sds)
344542,METHOD,sds.c:<global>,TYPE_DECL,"void *sdsAllocPtr(sds s) {
    return (void*) (s-sdsHdrSize(s[-1]));
}",1,1,sds.c,sdsAllocPtr,,false,393,395,sdsAllocPtr,,,21,void* sdsAllocPtr (sds)
344557,METHOD,sds.c:<global>,TYPE_DECL,"void sdsIncrLen(sds s, ssize_t incr) {
    unsigned char flags = s[-1];
    size_t len;
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            unsigned char *fp = ((unsigned char*)s)-1;
            unsigned char oldlen = SDS_TYPE_5_LEN(flags);
            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));
            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);
            len = oldlen+incr;
            break;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
            len = (sh->len += incr);
            break;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));
            len = (sh->len += incr);
            break;
        }
        case SDS_TYPE_32: {
         ...",1,17,sds.c,sdsIncrLen,,false,420,459,sdsIncrLen,,,22,"void sdsIncrLen (sds,ssize_t)"
344861,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsgrowzero(sds s, size_t len) {
    size_t curlen = sdslen(s);

    if (len <= curlen) return s;
    s = sdsMakeRoomFor(s,len-curlen);
    if (s == NULL) return NULL;

    /* Make sure added region doesn't contain garbage */
    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \0 byte */
    sdssetlen(s, len);
    return s;
}",1,1,sds.c,sdsgrowzero,,false,466,477,sdsgrowzero,,,23,"sds sdsgrowzero (sds,size_t)"
344908,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscatlen(sds s, const void *t, size_t len) {
    size_t curlen = sdslen(s);

    s = sdsMakeRoomFor(s,len);
    if (s == NULL) return NULL;
    memcpy(s+curlen, t, len);
    sdssetlen(s, curlen+len);
    s[curlen+len] = '\0';
    return s;
}",1,1,sds.c,sdscatlen,,false,484,493,sdscatlen,,,24,"sds sdscatlen (sds,void*,size_t)"
344952,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscat(sds s, const char *t) {
    return sdscatlen(s, t, strlen(t));
}",1,1,sds.c,sdscat,,false,499,501,sdscat,,,25,"sds sdscat (sds,char*)"
344964,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscatsds(sds s, const sds t) {
    return sdscatlen(s, t, sdslen(t));
}",1,1,sds.c,sdscatsds,,false,507,509,sdscatsds,,,26,"sds sdscatsds (sds,sds)"
344976,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscpylen(sds s, const char *t, size_t len) {
    if (sdsalloc(s) < len) {
        s = sdsMakeRoomFor(s,len-sdslen(s));
        if (s == NULL) return NULL;
    }
    memcpy(s, t, len);
    s[len] = '\0';
    sdssetlen(s, len);
    return s;
}",1,1,sds.c,sdscpylen,,false,513,522,sdscpylen,,,27,"sds sdscpylen (sds,char*,size_t)"
345018,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscpy(sds s, const char *t) {
    return sdscpylen(s, t, strlen(t));
}",1,1,sds.c,sdscpy,,false,526,528,sdscpy,,,28,"sds sdscpy (sds,char*)"
345030,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsfromlonglong(long long value) {
    char buf[LONG_STR_SIZE];
    int len = ll2string(buf,sizeof(buf),value);

    return sdsnewlen(buf,len);
}",1,13,sds.c,sdsfromlonglong,,false,534,539,sdsfromlonglong,,,29,sds sdsfromlonglong (long long)
345048,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscatvprintf(sds s, const char *fmt, va_list ap) {
    va_list cpy;
    char staticbuf[1024], *buf = staticbuf, *t;
    size_t buflen = strlen(fmt)*2;
    int bufstrlen;

    /* We try to start using a static buffer for speed.
     * If not possible we revert to heap allocation. */
    if (buflen > sizeof(staticbuf)) {
        buf = s_malloc(buflen);
        if (buf == NULL) return NULL;
    } else {
        buflen = sizeof(staticbuf);
    }

    /* Alloc enough space for buffer and \0 after failing to
     * fit the string in the current buffer size. */
    while(1) {
        va_copy(cpy,ap);
        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);
        va_end(cpy);
        if (bufstrlen < 0) {
            if (buf != staticbuf) s_free(buf);
            return NULL;
        }
        if (((size_t)bufstrlen) >= buflen) {
            if (buf != staticbuf) s_free(buf);
            buflen = ((size_t)bufstrlen) + 1;
            buf = s_malloc(buflen);
            if (buf == NULL) re...",1,14,sds.c,sdscatvprintf,,false,542,581,sdscatvprintf,,,30,"sds sdscatvprintf (sds,char*,va_list)"
345181,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscatprintf(sds s, const char *fmt, ...) {
    va_list ap;
    char *t;
    va_start(ap, fmt);
    t = sdscatvprintf(s,fmt,ap);
    va_end(ap);
    return t;
}",1,1,sds.c,sdscatprintf,,false,599,606,sdscatprintf,,,31,"sds sdscatprintf (sds,char*...)"
345202,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscatfmt(sds s, char const *fmt, ...) {
    size_t initlen = sdslen(s);
    const char *f = fmt;
    long i;
    va_list ap;

    /* To avoid continuous reallocations, let's start with a buffer that
     * can hold at least two times the format string itself. It's not the
     * best heuristic but seems to work in practice. */
    s = sdsMakeRoomFor(s, strlen(fmt)*2);
    va_start(ap,fmt);
    f = fmt;    /* Next format specifier byte to process. */
    i = initlen; /* Position of the next byte to write to dest str. */
    while(*f) {
        char next, *str;
        size_t l;
        long long num;
        unsigned long long unum;

        /* Make sure there is always space for at least 1 char. */
        if (sdsavail(s)==0) {
            s = sdsMakeRoomFor(s,1);
        }

        switch(*f) {
        case '%':
            next = *(f+1);
            if (next == '\0') break;
            f++;
            switch(next) {
            case 's':
            case 'S':
               ...",1,29,sds.c,sdscatfmt,,false,624,717,sdscatfmt,,,32,"sds sdscatfmt (sds,char*...)"
345431,METHOD,sds.c:<global>,TYPE_DECL,"sds sdstrim(sds s, const char *cset) {
    char *end, *sp, *ep;
    size_t len;

    sp = s;
    ep = end = s+sdslen(s)-1;
    while(sp <= end && strchr(cset, *sp)) sp++;
    while(ep > sp && strchr(cset, *ep)) ep--;
    len = (ep-sp)+1;
    if (s != sp) memmove(s, sp, len);
    s[len] = '\0';
    sdssetlen(s,len);
    return s;
}",1,1,sds.c,sdstrim,,false,733,746,sdstrim,,,33,"sds sdstrim (sds,char*)"
345502,METHOD,sds.c:<global>,TYPE_DECL,"void sdssubstr(sds s, size_t start, size_t len) {
    /* Clamp out of range input */
    size_t oldlen = sdslen(s);
    if (start >= oldlen) start = len = 0;
    if (len > oldlen-start) len = oldlen-start;

    /* Move the data */
    if (len) memmove(s, s+start, len);
    s[len] = 0;
    sdssetlen(s,len);
}",1,1,sds.c,sdssubstr,,false,751,761,sdssubstr,,,34,"void sdssubstr (sds,size_t,size_t)"
345553,METHOD,sds.c:<global>,TYPE_DECL,"void sdsrange(sds s, ssize_t start, ssize_t end) {
    size_t newlen, len = sdslen(s);
    if (len == 0) return;
    if (start < 0)
        start = len + start;
    if (end < 0)
        end = len + end;
    newlen = (start > end) ? 0 : (end-start)+1;
    sdssubstr(s, start, newlen);
}",1,1,sds.c,sdsrange,,false,784,793,sdsrange,,,35,"void sdsrange (sds,ssize_t,ssize_t)"
345608,METHOD,sds.c:<global>,TYPE_DECL,"void sdstolower(sds s) {
    size_t len = sdslen(s), j;

    for (j = 0; j < len; j++) s[j] = tolower(s[j]);
}",1,1,sds.c,sdstolower,,false,796,800,sdstolower,,,36,void sdstolower (sds)
345637,METHOD,sds.c:<global>,TYPE_DECL,"void sdstoupper(sds s) {
    size_t len = sdslen(s), j;

    for (j = 0; j < len; j++) s[j] = toupper(s[j]);
}",1,1,sds.c,sdstoupper,,false,803,807,sdstoupper,,,37,void sdstoupper (sds)
345666,METHOD,sds.c:<global>,TYPE_DECL,"int sdscmp(const sds s1, const sds s2) {
    size_t l1, l2, minlen;
    int cmp;

    l1 = sdslen(s1);
    l2 = sdslen(s2);
    minlen = (l1 < l2) ? l1 : l2;
    cmp = memcmp(s1,s2,minlen);
    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);
    return cmp;
}",1,1,sds.c,sdscmp,,false,820,830,sdscmp,,,38,"int sdscmp (sds,sds)"
345718,METHOD,sds.c:<global>,TYPE_DECL,"sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {
    int elements = 0, slots = 5;
    long start = 0, j;
    sds *tokens;

    if (seplen < 1 || len <= 0) {
        *count = 0;
        return NULL;
    }
    tokens = s_malloc(sizeof(sds)*slots);
    if (tokens == NULL) return NULL;

    for (j = 0; j < (len-(seplen-1)); j++) {
        /* make sure there is room for the next element and the final one */
        if (slots < elements+2) {
            sds *newtokens;

            slots *= 2;
            newtokens = s_realloc(tokens,sizeof(sds)*slots);
            if (newtokens == NULL) goto cleanup;
            tokens = newtokens;
        }
        /* search the separator */
        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {
            tokens[elements] = sdsnewlen(s+start,j-start);
            if (tokens[elements] == NULL) goto cleanup;
            elements++;
            start = j+seplen;
            j = j+seplen-1;...",1,13,sds.c,sdssplitlen,,false,848,894,sdssplitlen,,,39,"sds sdssplitlen (char*,ssize_t,char*,int,int*)"
345927,METHOD,sds.c:<global>,TYPE_DECL,"void sdsfreesplitres(sds *tokens, int count) {
    if (!tokens) return;
    while(count--)
        sdsfree(tokens[count]);
    s_free(tokens);
}",1,4,sds.c,sdsfreesplitres,,false,897,902,sdsfreesplitres,,,40,"void sdsfreesplitres (sds*,int)"
345949,METHOD,sds.c:<global>,TYPE_DECL,"sds sdscatrepr(sds s, const char *p, size_t len) {
    s = sdsMakeRoomFor(s, len + 2);
    s = sdscatlen(s,""\"""",1);
    while(len--) {
        switch(*p) {
        case '\\':
        case '""':
            s = sdscatprintf(s,""\\%c"",*p);
            break;
        case '\n': s = sdscatlen(s,""\\n"",2); break;
        case '\r': s = sdscatlen(s,""\\r"",2); break;
        case '\t': s = sdscatlen(s,""\\t"",2); break;
        case '\a': s = sdscatlen(s,""\\a"",2); break;
        case '\b': s = sdscatlen(s,""\\b"",2); break;
        default:
            if (isprint(*p))
                s = sdscatlen(s, p, 1);
            else
                s = sdscatprintf(s,""\\x%02x"",(unsigned char)*p);
            break;
        }
        p++;
    }
    return sdscatlen(s,""\"""",1);
}",1,1,sds.c,sdscatrepr,,false,910,934,sdscatrepr,,,41,"sds sdscatrepr (sds,char*,size_t)"
346065,METHOD,sds.c:<global>,TYPE_DECL,"int sdsneedsrepr(const sds s) {
    size_t len = sdslen(s);
    const char *p = s;

    while (len--) {
        if (*p == '\\' || *p == '""' || *p == '\n' || *p == '\r' ||
            *p == '\t' || *p == '\a' || *p == '\b' || !isprint(*p) || isspace(*p)) return 1;
        p++;
    }

    return 0;
}",1,1,sds.c,sdsneedsrepr,,false,943,954,sdsneedsrepr,,,42,int sdsneedsrepr (sds)
346134,METHOD,sds.c:<global>,TYPE_DECL,"int is_hex_digit(char c) {
    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||
           (c >= 'A' && c <= 'F');
}",1,1,sds.c,is_hex_digit,,false,958,961,is_hex_digit,,,43,int is_hex_digit (char)
346163,METHOD,sds.c:<global>,TYPE_DECL,"int hex_digit_to_int(char c) {
    switch(c) {
    case '0': return 0;
    case '1': return 1;
    case '2': return 2;
    case '3': return 3;
    case '4': return 4;
    case '5': return 5;
    case '6': return 6;
    case '7': return 7;
    case '8': return 8;
    case '9': return 9;
    case 'a': case 'A': return 10;
    case 'b': case 'B': return 11;
    case 'c': case 'C': return 12;
    case 'd': case 'D': return 13;
    case 'e': case 'E': return 14;
    case 'f': case 'F': return 15;
    default: return 0;
    }
}",1,1,sds.c,hex_digit_to_int,,false,965,985,hex_digit_to_int,,,44,int hex_digit_to_int (char)
346250,METHOD,sds.c:<global>,TYPE_DECL,"sds *sdssplitargs(const char *line, int *argc) {
    const char *p = line;
    char *current = NULL;
    char **vector = NULL;

    *argc = 0;
    while(1) {
        /* skip blanks */
        while(*p && isspace(*p)) p++;
        if (*p) {
            /* get a token */
            int inq=0;  /* set to 1 if we are in ""quotes"" */
            int insq=0; /* set to 1 if we are in 'single quotes' */
            int done=0;

            if (current == NULL) current = sdsempty();
            while(!done) {
                if (inq) {
                    if (*p == '\\' && *(p+1) == 'x' &&
                                             is_hex_digit(*(p+2)) &&
                                             is_hex_digit(*(p+3)))
                    {
                        unsigned char byte;

                        byte = (hex_digit_to_int(*(p+2))*16)+
                                hex_digit_to_int(*(p+3));
                        current = sdscatlen(current,(char*)&byte,1);
                 ...",1,21,sds.c,sdssplitargs,,false,1006,1114,sdssplitargs,,,45,"sds sdssplitargs (char*,int*)"
346651,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {
    size_t j, i, l = sdslen(s);

    for (j = 0; j < l; j++) {
        for (i = 0; i < setlen; i++) {
            if (s[j] == from[i]) {
                s[j] = to[i];
                break;
            }
        }
    }
    return s;
}",1,1,sds.c,sdsmapchars,,false,1125,1137,sdsmapchars,,,46,"sds sdsmapchars (sds,char*,char*,size_t)"
346707,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsjoin(char **argv, int argc, char *sep) {
    sds join = sdsempty();
    int j;

    for (j = 0; j < argc; j++) {
        join = sdscat(join, argv[j]);
        if (j != argc-1) join = sdscat(join,sep);
    }
    return join;
}",1,1,sds.c,sdsjoin,,false,1141,1150,sdsjoin,,,47,"sds sdsjoin (char**,int,char*)"
346751,METHOD,sds.c:<global>,TYPE_DECL,"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {
    sds join = sdsempty();
    int j;

    for (j = 0; j < argc; j++) {
        join = sdscatsds(join, argv[j]);
        if (j != argc-1) join = sdscatlen(join,sep,seplen);
    }
    return join;
}",1,1,sds.c,sdsjoinsds,,false,1153,1162,sdsjoinsds,,,48,"sds sdsjoinsds (sds*,int,char*,size_t)"
346797,METHOD,sds.c:<global>,TYPE_DECL,void *sds_malloc(size_t size) { return s_malloc(size); },1,39,sds.c,sds_malloc,,false,1169,1169,sds_malloc,,,49,void* sds_malloc (size_t)
346807,METHOD,sds.c:<global>,TYPE_DECL,"void *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }",1,51,sds.c,sds_realloc,,false,1170,1170,sds_realloc,,,50,"void* sds_realloc (void*,size_t)"
346819,METHOD,sds.c:<global>,TYPE_DECL,void sds_free(void *ptr) { s_free(ptr); },1,27,sds.c,sds_free,,false,1171,1171,sds_free,,,51,void sds_free (void*)
346828,METHOD,sds.c:<global>,TYPE_DECL,"sds sdstemplate(const char *template, sdstemplate_callback_t cb_func, void *cb_arg)
{
    sds res = sdsempty();
    const char *p = template;

    while (*p) {
        /* Find next variable, copy everything until there */
        const char *sv = strchr(p, '{');
        if (!sv) {
            /* Not found: copy till rest of template and stop */
            res = sdscat(res, p);
            break;
        } else if (sv > p) {
            /* Found: copy anything up to the beginning of the variable */
            res = sdscatlen(res, p, sv - p);
        }

        /* Skip into variable name, handle premature end or quoting */
        sv++;
        if (!*sv) goto error;       /* Premature end of template */
        if (*sv == '{') {
            /* Quoted '{' */
            p = sv + 1;
            res = sdscat(res, ""{"");
            continue;
        }

        /* Find end of variable name, handle premature end of template */
        const char *ev = strchr(sv, '}');
        if (!ev) got...",1,1,sds.c,sdstemplate,,false,1179,1228,sdstemplate,,,52,"sds sdstemplate (char*,sdstemplate_callback_t,void*)"
346963,METHOD,sds.h:<global>,TYPE_DECL,<global>,1,17,sds.h,sds.h:<global>,,false,1,287,<global>,,,1,
346970,METHOD,<empty>,<empty>,<empty>,1,,sds.h,sdshdr5:<clinit>,,false,47,,<clinit>,,,3,
346980,METHOD,<empty>,<empty>,<empty>,1,,sds.h,sdshdr8:<clinit>,,false,51,,<clinit>,,,5,
346990,METHOD,<empty>,<empty>,<empty>,1,,sds.h,sdshdr16:<clinit>,,false,57,,<clinit>,,,5,
347000,METHOD,<empty>,<empty>,<empty>,1,,sds.h,sdshdr32:<clinit>,,false,63,,<clinit>,,,5,
347010,METHOD,<empty>,<empty>,<empty>,1,,sds.h,sdshdr64:<clinit>,,false,69,,<clinit>,,,5,
347015,METHOD,sds.h:<global>,TYPE_DECL,"static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}",1,17,sds.h,sdslen,,false,87,102,sdslen,,,8,size_t sdslen (sds)
347111,METHOD,sds.h:<global>,TYPE_DECL,"static inline size_t sdsavail(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5: {
            return 0;
        }
        case SDS_TYPE_8: {
            SDS_HDR_VAR(8,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_16: {
            SDS_HDR_VAR(16,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_32: {
            SDS_HDR_VAR(32,s);
            return sh->alloc - sh->len;
        }
        case SDS_TYPE_64: {
            SDS_HDR_VAR(64,s);
            return sh->alloc - sh->len;
        }
    }
    return 0;
}",1,17,sds.h,sdsavail,,false,104,128,sdsavail,,,9,size_t sdsavail (sds)
347239,METHOD,sds.h:<global>,TYPE_DECL,"static inline void sdssetlen(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len = newlen;
            break;
    }
}",1,17,sds.h,sdssetlen,,false,130,152,sdssetlen,,,10,"void sdssetlen (sds,size_t)"
347357,METHOD,sds.h:<global>,TYPE_DECL,"static inline void sdsinclen(sds s, size_t inc) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len += inc;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len += inc;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len += inc;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len += inc;
            break;
    }
}",1,17,sds.h,sdsinclen,,false,154,177,sdsinclen,,,11,"void sdsinclen (sds,size_t)"
347486,METHOD,sds.h:<global>,TYPE_DECL,"static inline size_t sdsalloc(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->alloc;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->alloc;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->alloc;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->alloc;
    }
    return 0;
}",1,17,sds.h,sdsalloc,,false,180,195,sdsalloc,,,12,size_t sdsalloc (sds)
347582,METHOD,sds.h:<global>,TYPE_DECL,"static inline void sdssetalloc(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            /* Nothing to do, this type has no total allocation info. */
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->alloc = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->alloc = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->alloc = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->alloc = newlen;
            break;
    }
}",1,17,sds.h,sdssetalloc,,false,197,216,sdssetalloc,,,13,"void sdssetalloc (sds,size_t)"
347679,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsnewlen(const void *init, size_t initlen);",5,47,sds.h,sdsnewlen,,false,218,218,sdsnewlen,,,14,"sds sdsnewlen (void*,size_t)"
347685,METHOD,sds.h:<global>,TYPE_DECL,"sds sdstrynewlen(const void *init, size_t initlen);",5,50,sds.h,sdstrynewlen,,false,219,219,sdstrynewlen,,,15,"sds sdstrynewlen (void*,size_t)"
347691,METHOD,sds.h:<global>,TYPE_DECL,sds sdsnew(const char *init);,5,28,sds.h,sdsnew,,false,220,220,sdsnew,,,16,sds sdsnew (char*)
347696,METHOD,sds.h:<global>,TYPE_DECL,sds sdsempty(void);,5,18,sds.h,sdsempty,,false,221,221,sdsempty,,,17,sds sdsempty (void)
347701,METHOD,sds.h:<global>,TYPE_DECL,sds sdsdup(const sds s);,5,23,sds.h,sdsdup,,false,222,222,sdsdup,,,18,sds sdsdup (sds)
347706,METHOD,sds.h:<global>,TYPE_DECL,void sdsfree(sds s);,6,19,sds.h,sdsfree,,false,223,223,sdsfree,,,19,void sdsfree (sds)
347711,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsgrowzero(sds s, size_t len);",5,34,sds.h,sdsgrowzero,,false,224,224,sdsgrowzero,,,20,"sds sdsgrowzero (sds,size_t)"
347717,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscatlen(sds s, const void *t, size_t len);",5,47,sds.h,sdscatlen,,false,225,225,sdscatlen,,,21,"sds sdscatlen (sds,void*,size_t)"
347724,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscat(sds s, const char *t);",5,32,sds.h,sdscat,,false,226,226,sdscat,,,22,"sds sdscat (sds,char*)"
347730,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscatsds(sds s, const sds t);",5,33,sds.h,sdscatsds,,false,227,227,sdscatsds,,,23,"sds sdscatsds (sds,sds)"
347736,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscpylen(sds s, const char *t, size_t len);",5,47,sds.h,sdscpylen,,false,228,228,sdscpylen,,,24,"sds sdscpylen (sds,char*,size_t)"
347743,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscpy(sds s, const char *t);",5,32,sds.h,sdscpy,,false,229,229,sdscpy,,,25,"sds sdscpy (sds,char*)"
347749,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscatvprintf(sds s, const char *fmt, va_list ap);",5,53,sds.h,sdscatvprintf,,false,231,231,sdscatvprintf,,,26,"sds sdscatvprintf (sds,char*,va_list)"
347756,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscatprintf(sds s, const char *fmt, ...);",5,45,sds.h,sdscatprintf,,false,236,236,sdscatprintf,,,27,"sds sdscatprintf (sds,char*...)"
347762,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscatfmt(sds s, char const *fmt, ...);",5,42,sds.h,sdscatfmt,,false,239,239,sdscatfmt,,,28,"sds sdscatfmt (sds,char*...)"
347768,METHOD,sds.h:<global>,TYPE_DECL,"sds sdstrim(sds s, const char *cset);",5,36,sds.h,sdstrim,,false,240,240,sdstrim,,,29,"sds sdstrim (sds,char*)"
347774,METHOD,sds.h:<global>,TYPE_DECL,"void sdssubstr(sds s, size_t start, size_t len);",6,47,sds.h,sdssubstr,,false,241,241,sdssubstr,,,30,"void sdssubstr (sds,size_t,size_t)"
347781,METHOD,sds.h:<global>,TYPE_DECL,"void sdsrange(sds s, ssize_t start, ssize_t end);",6,48,sds.h,sdsrange,,false,242,242,sdsrange,,,31,"void sdsrange (sds,ssize_t,ssize_t)"
347788,METHOD,sds.h:<global>,TYPE_DECL,void sdsupdatelen(sds s);,6,24,sds.h,sdsupdatelen,,false,243,243,sdsupdatelen,,,32,void sdsupdatelen (sds)
347793,METHOD,sds.h:<global>,TYPE_DECL,void sdsclear(sds s);,6,20,sds.h,sdsclear,,false,244,244,sdsclear,,,33,void sdsclear (sds)
347798,METHOD,sds.h:<global>,TYPE_DECL,"int sdscmp(const sds s1, const sds s2);",5,38,sds.h,sdscmp,,false,245,245,sdscmp,,,34,"int sdscmp (sds,sds)"
347804,METHOD,sds.h:<global>,TYPE_DECL,"sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count);",5,85,sds.h,sdssplitlen,,false,246,246,sdssplitlen,,,35,"sds* sdssplitlen (char*,ssize_t,char*,int,int*)"
347813,METHOD,sds.h:<global>,TYPE_DECL,"void sdsfreesplitres(sds *tokens, int count);",6,44,sds.h,sdsfreesplitres,,false,247,247,sdsfreesplitres,,,36,"void sdsfreesplitres (sds*,int)"
347819,METHOD,sds.h:<global>,TYPE_DECL,void sdstolower(sds s);,6,22,sds.h,sdstolower,,false,248,248,sdstolower,,,37,void sdstolower (sds)
347824,METHOD,sds.h:<global>,TYPE_DECL,void sdstoupper(sds s);,6,22,sds.h,sdstoupper,,false,249,249,sdstoupper,,,38,void sdstoupper (sds)
347829,METHOD,sds.h:<global>,TYPE_DECL,sds sdsfromlonglong(long long value);,5,36,sds.h,sdsfromlonglong,,false,250,250,sdsfromlonglong,,,39,sds sdsfromlonglong (long long)
347834,METHOD,sds.h:<global>,TYPE_DECL,"sds sdscatrepr(sds s, const char *p, size_t len);",5,48,sds.h,sdscatrepr,,false,251,251,sdscatrepr,,,40,"sds sdscatrepr (sds,char*,size_t)"
347841,METHOD,sds.h:<global>,TYPE_DECL,"sds *sdssplitargs(const char *line, int *argc);",5,46,sds.h,sdssplitargs,,false,252,252,sdssplitargs,,,41,"sds* sdssplitargs (char*,int*)"
347847,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);",5,71,sds.h,sdsmapchars,,false,253,253,sdsmapchars,,,42,"sds sdsmapchars (sds,char*,char*,size_t)"
347855,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsjoin(char **argv, int argc, char *sep);",5,45,sds.h,sdsjoin,,false,254,254,sdsjoin,,,43,"sds sdsjoin (char**,int,char*)"
347862,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);",5,67,sds.h,sdsjoinsds,,false,255,255,sdsjoinsds,,,44,"sds sdsjoinsds (sds*,int,char*,size_t)"
347870,METHOD,sds.h:<global>,TYPE_DECL,int sdsneedsrepr(const sds s);,5,29,sds.h,sdsneedsrepr,,false,256,256,sdsneedsrepr,,,45,int sdsneedsrepr (sds)
347875,METHOD,sds.h:<global>,TYPE_DECL,"typedef sds (*sdstemplate_callback_t)(const sds variable, void *arg);",13,68,sds.h,sdstemplate_callback_t,,false,263,263,sdstemplate_callback_t,,,46,"sds sdstemplate_callback_t (sds,void*)"
347881,METHOD,sds.h:<global>,TYPE_DECL,"sds sdstemplate(const char *template, sdstemplate_callback_t cb_func, void *cb_arg);",5,83,sds.h,sdstemplate,,false,264,264,sdstemplate,,,47,"sds sdstemplate (char*,sdstemplate_callback_t,void*)"
347888,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsMakeRoomFor(sds s, size_t addlen);",5,40,sds.h,sdsMakeRoomFor,,false,267,267,sdsMakeRoomFor,,,48,"sds sdsMakeRoomFor (sds,size_t)"
347894,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsMakeRoomForNonGreedy(sds s, size_t addlen);",5,49,sds.h,sdsMakeRoomForNonGreedy,,false,268,268,sdsMakeRoomForNonGreedy,,,49,"sds sdsMakeRoomForNonGreedy (sds,size_t)"
347900,METHOD,sds.h:<global>,TYPE_DECL,"void sdsIncrLen(sds s, ssize_t incr);",6,36,sds.h,sdsIncrLen,,false,269,269,sdsIncrLen,,,50,"void sdsIncrLen (sds,ssize_t)"
347906,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsRemoveFreeSpace(sds s, int would_regrow);",5,47,sds.h,sdsRemoveFreeSpace,,false,270,270,sdsRemoveFreeSpace,,,51,"sds sdsRemoveFreeSpace (sds,int)"
347912,METHOD,sds.h:<global>,TYPE_DECL,"sds sdsResize(sds s, size_t size, int would_regrow);",5,51,sds.h,sdsResize,,false,271,271,sdsResize,,,52,"sds sdsResize (sds,size_t,int)"
347919,METHOD,sds.h:<global>,TYPE_DECL,size_t sdsAllocSize(sds s);,8,26,sds.h,sdsAllocSize,,false,272,272,sdsAllocSize,,,53,size_t sdsAllocSize (sds)
347924,METHOD,sds.h:<global>,TYPE_DECL,void *sdsAllocPtr(sds s);,6,24,sds.h,sdsAllocPtr,,false,273,273,sdsAllocPtr,,,54,void* sdsAllocPtr (sds)
347929,METHOD,sds.h:<global>,TYPE_DECL,void *sds_malloc(size_t size);,6,29,sds.h,sds_malloc,,false,279,279,sds_malloc,,,55,void* sds_malloc (size_t)
347934,METHOD,sds.h:<global>,TYPE_DECL,"void *sds_realloc(void *ptr, size_t size);",6,41,sds.h,sds_realloc,,false,280,280,sds_realloc,,,56,"void* sds_realloc (void*,size_t)"
347940,METHOD,sds.h:<global>,TYPE_DECL,void sds_free(void *ptr);,6,24,sds.h,sds_free,,false,281,281,sds_free,,,57,void sds_free (void*)
347950,METHOD,sdsalloc.h:<global>,TYPE_DECL,<global>,1,1,sdsalloc.h,sdsalloc.h:<global>,,false,1,54,<global>,,,1,
347975,METHOD,sentinel.c:<global>,TYPE_DECL,<global>,1,1,sentinel.c,sentinel.c:<global>,,false,1,5484,<global>,,,1,
348127,METHOD,<empty>,<empty>,<empty>,1,,sentinel.c,sentinelState:<clinit>,,false,255,,<clinit>,,,17,
348152,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
    ((void)el); ((void)fd); ((void)mask);

    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAsyncHandleRead(e->context);
}",1,1,sentinel.c,redisAeReadEvent,,false,304,309,redisAeReadEvent,,,40,"void redisAeReadEvent (aeEventLoop*,int,void*,int)"
348179,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {
    ((void)el); ((void)fd); ((void)mask);

    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAsyncHandleWrite(e->context);
}",1,1,sentinel.c,redisAeWriteEvent,,false,311,316,redisAeWriteEvent,,,41,"void redisAeWriteEvent (aeEventLoop*,int,void*,int)"
348206,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeAddRead(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (!e->reading) {
        e->reading = 1;
        aeCreateFileEvent(loop,e->fd,AE_READABLE,redisAeReadEvent,e);
    }
}",1,37,sentinel.c,redisAeAddRead,,false,318,325,redisAeAddRead,,,42,void redisAeAddRead (void*)
348244,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeDelRead(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (e->reading) {
        e->reading = 0;
        aeDeleteFileEvent(loop,e->fd,AE_READABLE);
    }
}",1,37,sentinel.c,redisAeDelRead,,false,327,334,redisAeDelRead,,,43,void redisAeDelRead (void*)
348279,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeAddWrite(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (!e->writing) {
        e->writing = 1;
        aeCreateFileEvent(loop,e->fd,AE_WRITABLE,redisAeWriteEvent,e);
    }
}",1,37,sentinel.c,redisAeAddWrite,,false,336,343,redisAeAddWrite,,,44,void redisAeAddWrite (void*)
348317,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeDelWrite(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    aeEventLoop *loop = e->loop;
    if (e->writing) {
        e->writing = 0;
        aeDeleteFileEvent(loop,e->fd,AE_WRITABLE);
    }
}",1,37,sentinel.c,redisAeDelWrite,,false,345,352,redisAeDelWrite,,,45,void redisAeDelWrite (void*)
348352,METHOD,sentinel.c:<global>,TYPE_DECL,"static void redisAeCleanup(void *privdata) {
    redisAeEvents *e = (redisAeEvents*)privdata;
    redisAeDelRead(privdata);
    redisAeDelWrite(privdata);
    zfree(e);
}",1,1,sentinel.c,redisAeCleanup,,false,354,359,redisAeCleanup,,,46,void redisAeCleanup (void*)
348369,METHOD,sentinel.c:<global>,TYPE_DECL,"static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {
    redisContext *c = &(ac->c);
    redisAeEvents *e;

    /* Nothing should be attached when something is already attached */
    if (ac->ev.data != NULL)
        return C_ERR;

    /* Create container for context and r/w events */
    e = (redisAeEvents*)zmalloc(sizeof(*e));
    e->context = ac;
    e->loop = loop;
    e->fd = c->fd;
    e->reading = e->writing = 0;

    /* Register functions to start/stop listening for events */
    ac->ev.addRead = redisAeAddRead;
    ac->ev.delRead = redisAeDelRead;
    ac->ev.addWrite = redisAeAddWrite;
    ac->ev.delWrite = redisAeDelWrite;
    ac->ev.cleanup = redisAeCleanup;
    ac->ev.data = e;

    return C_OK;
}",1,15,sentinel.c,redisAeAttach,,false,361,385,redisAeAttach,,,47,"int redisAeAttach (aeEventLoop*,redisAsyncContext*)"
348477,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);",6,76,sentinel.c,sentinelLinkEstablishedCallback,,false,389,389,sentinelLinkEstablishedCallback,,,48,"void sentinelLinkEstablishedCallback (redisAsyncContext*,int)"
348483,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelDisconnectCallback(const redisAsyncContext *c, int status);",6,71,sentinel.c,sentinelDisconnectCallback,,false,390,390,sentinelDisconnectCallback,,,49,"void sentinelDisconnectCallback (redisAsyncContext*,int)"
348489,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);",6,84,sentinel.c,sentinelReceiveHelloMessages,,false,391,391,sentinelReceiveHelloMessages,,,50,"void sentinelReceiveHelloMessages (redisAsyncContext*,void*,void*)"
348496,METHOD,sentinel.c:<global>,TYPE_DECL,sentinelRedisInstance *sentinelGetMasterByName(char *name);,23,58,sentinel.c,sentinelGetMasterByName,,false,392,392,sentinelGetMasterByName,,,51,sentinelRedisInstance* sentinelGetMasterByName (char*)
348501,METHOD,sentinel.c:<global>,TYPE_DECL,char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);,6,64,sentinel.c,sentinelGetSubjectiveLeader,,false,393,393,sentinelGetSubjectiveLeader,,,52,char* sentinelGetSubjectiveLeader (sentinelRedisInstance*)
348506,METHOD,sentinel.c:<global>,TYPE_DECL,char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);,6,63,sentinel.c,sentinelGetObjectiveLeader,,false,394,394,sentinelGetObjectiveLeader,,,53,char* sentinelGetObjectiveLeader (sentinelRedisInstance*)
348511,METHOD,sentinel.c:<global>,TYPE_DECL,void instanceLinkConnectionError(const redisAsyncContext *c);,6,60,sentinel.c,instanceLinkConnectionError,,false,395,395,instanceLinkConnectionError,,,54,void instanceLinkConnectionError (redisAsyncContext*)
348516,METHOD,sentinel.c:<global>,TYPE_DECL,const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);,12,67,sentinel.c,sentinelRedisInstanceTypeStr,,false,396,396,sentinelRedisInstanceTypeStr,,,55,char* sentinelRedisInstanceTypeStr (sentinelRedisInstance*)
348521,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelAbortFailover(sentinelRedisInstance *ri);,6,53,sentinel.c,sentinelAbortFailover,,false,397,397,sentinelAbortFailover,,,56,void sentinelAbortFailover (sentinelRedisInstance*)
348526,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);",6,90,sentinel.c,sentinelEvent,,false,398,398,sentinelEvent,,,57,"void sentinelEvent (int,char*,sentinelRedisInstance*,char*...)"
348534,METHOD,sentinel.c:<global>,TYPE_DECL,sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);,23,73,sentinel.c,sentinelSelectSlave,,false,399,399,sentinelSelectSlave,,,58,sentinelRedisInstance* sentinelSelectSlave (sentinelRedisInstance*)
348539,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelScheduleScriptExecution(char *path, ...);",6,53,sentinel.c,sentinelScheduleScriptExecution,,false,400,400,sentinelScheduleScriptExecution,,,59,void sentinelScheduleScriptExecution (char*...)
348544,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelStartFailover(sentinelRedisInstance *master);,6,57,sentinel.c,sentinelStartFailover,,false,401,401,sentinelStartFailover,,,60,void sentinelStartFailover (sentinelRedisInstance*)
348549,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);",6,84,sentinel.c,sentinelDiscardReplyCallback,,false,402,402,sentinelDiscardReplyCallback,,,61,"void sentinelDiscardReplyCallback (redisAsyncContext*,void*,void*)"
348556,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelSendSlaveOf(sentinelRedisInstance *ri, const sentinelAddr *addr);",5,76,sentinel.c,sentinelSendSlaveOf,,false,403,403,sentinelSendSlaveOf,,,62,"int sentinelSendSlaveOf (sentinelRedisInstance*,sentinelAddr*)"
348562,METHOD,sentinel.c:<global>,TYPE_DECL,"char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);",6,116,sentinel.c,sentinelVoteLeader,,false,404,404,sentinelVoteLeader,,,63,"char* sentinelVoteLeader (sentinelRedisInstance*,uint64_t,char*,uint64_t*)"
348570,METHOD,sentinel.c:<global>,TYPE_DECL,int sentinelFlushConfig(void);,5,29,sentinel.c,sentinelFlushConfig,,false,405,405,sentinelFlushConfig,,,64,int sentinelFlushConfig (void)
348575,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelGenerateInitialMonitorEvents(void);,6,47,sentinel.c,sentinelGenerateInitialMonitorEvents,,false,406,406,sentinelGenerateInitialMonitorEvents,,,65,void sentinelGenerateInitialMonitorEvents (void)
348580,METHOD,sentinel.c:<global>,TYPE_DECL,int sentinelSendPing(sentinelRedisInstance *ri);,5,47,sentinel.c,sentinelSendPing,,false,407,407,sentinelSendPing,,,66,int sentinelSendPing (sentinelRedisInstance*)
348585,METHOD,sentinel.c:<global>,TYPE_DECL,int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);,5,68,sentinel.c,sentinelForceHelloUpdateForMaster,,false,408,408,sentinelForceHelloUpdateForMaster,,,67,int sentinelForceHelloUpdateForMaster (sentinelRedisInstance*)
348590,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid);",23,111,sentinel.c,getSentinelRedisInstanceByAddrAndRunID,,false,409,409,getSentinelRedisInstanceByAddrAndRunID,,,68,"sentinelRedisInstance* getSentinelRedisInstanceByAddrAndRunID (dict*,char*,int,char*)"
348598,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelSimFailureCrash(void);,6,34,sentinel.c,sentinelSimFailureCrash,,false,410,410,sentinelSimFailureCrash,,,69,void sentinelSimFailureCrash (void)
348603,METHOD,sentinel.c:<global>,TYPE_DECL,void releaseSentinelRedisInstance(sentinelRedisInstance *ri);,6,60,sentinel.c,releaseSentinelRedisInstance,,false,414,414,releaseSentinelRedisInstance,,,70,void releaseSentinelRedisInstance (sentinelRedisInstance*)
348608,METHOD,sentinel.c:<global>,TYPE_DECL,"void dictInstancesValDestructor (dict *d, void *obj) {
    UNUSED(d);
    releaseSentinelRedisInstance(obj);
}",1,4,sentinel.c,dictInstancesValDestructor,,false,416,419,dictInstancesValDestructor,,,71,"void dictInstancesValDestructor (dict*,void*)"
348655,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelSetCommand(client *c);,6,34,sentinel.c,sentinelSetCommand,,false,462,462,sentinelSetCommand,,,78,void sentinelSetCommand (client*)
348660,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelConfigGetCommand(client *c);,6,40,sentinel.c,sentinelConfigGetCommand,,false,463,463,sentinelConfigGetCommand,,,79,void sentinelConfigGetCommand (client*)
348665,METHOD,sentinel.c:<global>,TYPE_DECL,void sentinelConfigSetCommand(client *c);,6,40,sentinel.c,sentinelConfigSetCommand,,false,464,464,sentinelConfigSetCommand,,,80,void sentinelConfigSetCommand (client*)
348683,METHOD,sentinel.c:<global>,TYPE_DECL,"void initSentinelConfig(void) {
    server.port = REDIS_SENTINEL_PORT;
    server.protected_mode = 0; /* Sentinel must be exposed. */
}",1,18,sentinel.c,initSentinelConfig,,false,482,485,initSentinelConfig,,,83,void initSentinelConfig (void)
348700,METHOD,sentinel.c:<global>,TYPE_DECL,void freeSentinelLoadQueueEntry(void *item);,6,43,sentinel.c,freeSentinelLoadQueueEntry,,false,487,487,freeSentinelLoadQueueEntry,,,84,void freeSentinelLoadQueueEntry (void*)
348705,METHOD,sentinel.c:<global>,TYPE_DECL,"void initSentinel(void) {
    /* Initialize various data structures. */
    sentinel.current_epoch = 0;
    sentinel.masters = dictCreate(&instancesDictType);
    sentinel.tilt = 0;
    sentinel.tilt_start_time = 0;
    sentinel.previous_time = mstime();
    sentinel.running_scripts = 0;
    sentinel.scripts_queue = listCreate();
    sentinel.announce_ip = NULL;
    sentinel.announce_port = 0;
    sentinel.simfailure_flags = SENTINEL_SIMFAILURE_NONE;
    sentinel.deny_scripts_reconfig = SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG;
    sentinel.sentinel_auth_pass = NULL;
    sentinel.sentinel_auth_user = NULL;
    sentinel.resolve_hostnames = SENTINEL_DEFAULT_RESOLVE_HOSTNAMES;
    sentinel.announce_hostnames = SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES;
    memset(sentinel.myid,0,sizeof(sentinel.myid));
    server.sentinel_config = NULL;
}",1,32,sentinel.c,initSentinel,,false,490,509,initSentinel,,,85,void initSentinel (void)
348809,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCheckConfigFile(void) {
    if (server.configfile == NULL) {
        serverLog(LL_WARNING,
            ""Sentinel needs config file on disk to save state. Exiting..."");
        exit(1);
    } else if (access(server.configfile,W_OK) == -1) {
        serverLog(LL_WARNING,
            ""Sentinel config file %s is not writable: %s. Exiting..."",
            server.configfile,strerror(errno));
        exit(1);
    }
}",1,8,sentinel.c,sentinelCheckConfigFile,,false,513,524,sentinelCheckConfigFile,,,86,void sentinelCheckConfigFile (void)
348878,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelIsRunning(void) {
    int j;

    /* If this Sentinel has yet no ID set in the configuration file, we
     * pick a random one and persist the config on disk. From now on this
     * will be this Sentinel ID across restarts. */
    for (j = 0; j < CONFIG_RUN_ID_SIZE; j++)
        if (sentinel.myid[j] != 0) break;

    if (j == CONFIG_RUN_ID_SIZE) {
        /* Pick ID and persist the config. */
        getRandomHexChars(sentinel.myid,CONFIG_RUN_ID_SIZE);
        sentinelFlushConfig();
    }

    /* Log its ID to make debugging of issues simpler. */
    serverLog(LL_NOTICE,""Sentinel ID is %s"", sentinel.myid);

    /* We want to generate a +monitor event for every configured master
     * at startup. */
    sentinelGenerateInitialMonitorEvents();
}",1,20,sentinel.c,sentinelIsRunning,,false,528,549,sentinelIsRunning,,,87,void sentinelIsRunning (void)
348943,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelAddr *createSentinelAddr(char *hostname, int port, int is_accept_unresolved) {
    char ip[NET_IP_STR_LEN];
    sentinelAddr *sa;

    if (port < 0 || port > 65535) {
        errno = EINVAL;
        return NULL;
    }
    if (anetResolve(NULL,hostname,ip,sizeof(ip),
                    sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR) {
        serverLog(LL_WARNING, ""Failed to resolve hostname '%s'"", hostname);
        if (sentinel.resolve_hostnames && is_accept_unresolved) {
            ip[0] = '\0';
        }
        else {
            errno = ENOENT;
            return NULL;
        }
    }
    sa = zmalloc(sizeof(*sa));
    sa->hostname = sdsnew(hostname);
    sa->ip = sdsnew(ip);
    sa->port = port;
    return sa;
}",1,12,sentinel.c,createSentinelAddr,,false,558,582,createSentinelAddr,,,88,"sentinelAddr createSentinelAddr (char*,int,int)"
349054,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelAddr *dupSentinelAddr(sentinelAddr *src) {
    sentinelAddr *sa;

    sa = zmalloc(sizeof(*sa));
    sa->hostname = sdsnew(src->hostname);
    sa->ip = sdsnew(src->ip);
    sa->port = src->port;
    return sa;
}",1,1,sentinel.c,dupSentinelAddr,,false,585,593,dupSentinelAddr,,,89,sentinelAddr dupSentinelAddr (sentinelAddr*)
349091,METHOD,sentinel.c:<global>,TYPE_DECL,"void releaseSentinelAddr(sentinelAddr *sa) {
    sdsfree(sa->hostname);
    sdsfree(sa->ip);
    zfree(sa);
}",1,1,sentinel.c,releaseSentinelAddr,,false,596,600,releaseSentinelAddr,,,90,void releaseSentinelAddr (sentinelAddr*)
349106,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelAddrOrHostnameEqual(sentinelAddr *a, sentinelAddr *b) {
    return a->port == b->port &&
            (!strcmp(a->ip, b->ip)  ||
            !strcasecmp(a->hostname, b->hostname));
}",1,1,sentinel.c,sentinelAddrOrHostnameEqual,,false,605,609,sentinelAddrOrHostnameEqual,,,91,"int sentinelAddrOrHostnameEqual (sentinelAddr*,sentinelAddr*)"
349138,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelAddrEqualsHostname(sentinelAddr *a, char *hostname) {
    char ip[NET_IP_STR_LEN];

    /* Try resolve the hostname and compare it to the address */
    if (anetResolve(NULL, hostname, ip, sizeof(ip),
                    sentinel.resolve_hostnames ? ANET_NONE : ANET_IP_ONLY) == ANET_ERR) {

        /* If failed resolve then compare based on hostnames. That is our best effort as
         * long as the server is unavailable for some reason. It is fine since Redis 
         * instance cannot have multiple hostnames for a given setup */
        return !strcasecmp(sentinel.resolve_hostnames ? a->hostname : a->ip, hostname);
    }
    /* Compare based on address */
    return !strcasecmp(a->ip, ip);
}",1,12,sentinel.c,sentinelAddrEqualsHostname,,false,612,626,sentinelAddrEqualsHostname,,,92,"int sentinelAddrEqualsHostname (sentinelAddr*,char*)"
349191,METHOD,sentinel.c:<global>,TYPE_DECL,"const char *announceSentinelAddr(const sentinelAddr *a) {
    return sentinel.announce_hostnames ? a->hostname : a->ip;
}",1,1,sentinel.c,announceSentinelAddr,,false,628,630,announceSentinelAddr,,,93,const char* announceSentinelAddr (sentinelAddr*)
349207,METHOD,sentinel.c:<global>,TYPE_DECL,"sds announceSentinelAddrAndPort(const sentinelAddr *a) {
    const char *addr = announceSentinelAddr(a);
    if (strchr(addr, ':') != NULL)
        return sdscatprintf(sdsempty(), ""[%s]:%d"", addr, a->port);
    else
        return sdscatprintf(sdsempty(), ""%s:%d"", addr, a->port);
}",1,1,sentinel.c,announceSentinelAddrAndPort,,false,635,641,announceSentinelAddrAndPort,,,94,sds announceSentinelAddrAndPort (sentinelAddr*)
349242,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,
                   const char *fmt, ...) {
    va_list ap;
    char msg[LOG_MAX_LEN];
    robj *channel, *payload;

    /* Handle %@ */
    if (fmt[0] == '%' && fmt[1] == '@') {
        sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ?
                                         NULL : ri->master;

        if (master) {
            snprintf(msg, sizeof(msg), ""%s %s %s %d @ %s %s %d"",
                sentinelRedisInstanceTypeStr(ri),
                ri->name, announceSentinelAddr(ri->addr), ri->addr->port,
                master->name, announceSentinelAddr(master->addr), master->addr->port);
        } else {
            snprintf(msg, sizeof(msg), ""%s %s %s %d"",
                sentinelRedisInstanceTypeStr(ri),
                ri->name, announceSentinelAddr(ri->addr), ri->addr->port);
        }
        fmt += 2;
    } else {
        msg[0] = '\0';
    }

    /* Use vsprintf for the rest of the formatting if any...",1,13,sentinel.c,sentinelEvent,,false,669,724,sentinelEvent,,,95,"void sentinelEvent (int,char*,sentinelRedisInstance*,char*...)"
349470,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelGenerateInitialMonitorEvents(void) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        sentinelEvent(LL_WARNING,""+monitor"",ri,""%@ quorum %d"",ri->quorum);
    }
    dictReleaseIterator(di);
}",1,22,sentinel.c,sentinelGenerateInitialMonitorEvents,,false,730,740,sentinelGenerateInitialMonitorEvents,,,96,void sentinelGenerateInitialMonitorEvents (void)
349508,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelReleaseScriptJob(sentinelScriptJob *sj) {
    int j = 0;

    while(sj->argv[j]) sdsfree(sj->argv[j++]);
    zfree(sj->argv);
    zfree(sj);
}",1,1,sentinel.c,sentinelReleaseScriptJob,,false,745,751,sentinelReleaseScriptJob,,,97,void sentinelReleaseScriptJob (sentinelScriptJob*)
349536,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelScheduleScriptExecution(char *path, ...) {
    va_list ap;
    char *argv[SENTINEL_SCRIPT_MAX_ARGS+1];
    int argc = 1;
    sentinelScriptJob *sj;

    va_start(ap, path);
    while(argc < SENTINEL_SCRIPT_MAX_ARGS) {
        argv[argc] = va_arg(ap,char*);
        if (!argv[argc]) break;
        argv[argc] = sdsnew(argv[argc]); /* Copy the string. */
        argc++;
    }
    va_end(ap);
    argv[0] = sdsnew(path);

    sj = zmalloc(sizeof(*sj));
    sj->flags = SENTINEL_SCRIPT_NONE;
    sj->retry_num = 0;
    sj->argv = zmalloc(sizeof(char*)*(argc+1));
    sj->start_time = 0;
    sj->pid = 0;
    memcpy(sj->argv,argv,sizeof(char*)*(argc+1));

    listAddNodeTail(sentinel.scripts_queue,sj);

    /* Remove the oldest non running script if we already hit the limit. */
    if (listLength(sentinel.scripts_queue) > SENTINEL_SCRIPT_MAX_QUEUE) {
        listNode *ln;
        listIter li;

        listRewind(sentinel.scripts_queue,&li);
        while ((ln = listNext(&li)) != NU...",1,15,sentinel.c,sentinelScheduleScriptExecution,,false,754,798,sentinelScheduleScriptExecution,,,98,void sentinelScheduleScriptExecution (char*...)
349715,METHOD,sentinel.c:<global>,TYPE_DECL,"listNode *sentinelGetScriptListNodeByPid(pid_t pid) {
    listNode *ln;
    listIter li;

    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;

        if ((sj->flags & SENTINEL_SCRIPT_RUNNING) && sj->pid == pid)
            return ln;
    }
    return NULL;
}",1,25,sentinel.c,sentinelGetScriptListNodeByPid,,false,802,814,sentinelGetScriptListNodeByPid,,,99,listNode sentinelGetScriptListNodeByPid (pid_t)
349762,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelRunPendingScripts(void) {
    listNode *ln;
    listIter li;
    mstime_t now = mstime();

    /* Find jobs that are not running and run them, from the top to the
     * tail of the queue, so we run older jobs first. */
    listRewind(sentinel.scripts_queue,&li);
    while (sentinel.running_scripts < SENTINEL_SCRIPT_MAX_RUNNING &&
           (ln = listNext(&li)) != NULL)
    {
        sentinelScriptJob *sj = ln->value;
        pid_t pid;

        /* Skip if already running. */
        if (sj->flags & SENTINEL_SCRIPT_RUNNING) continue;

        /* Skip if it's a retry, but not enough time has elapsed. */
        if (sj->start_time && sj->start_time > now) continue;

        sj->flags |= SENTINEL_SCRIPT_RUNNING;
        sj->start_time = mstime();
        sj->retry_num++;
        pid = fork();

        if (pid == -1) {
            /* Parent (fork error).
             * We report fork errors as signal 99, in order to unify the
             * reporting with other kind of err...",1,38,sentinel.c,sentinelRunPendingScripts,,false,818,863,sentinelRunPendingScripts,,,100,void sentinelRunPendingScripts (void)
349918,METHOD,sentinel.c:<global>,TYPE_DECL,"mstime_t sentinelScriptRetryDelay(int retry_num) {
    mstime_t delay = sentinel_script_retry_delay;

    while (retry_num-- > 1) delay *= 2;
    return delay;
}",1,1,sentinel.c,sentinelScriptRetryDelay,,false,872,877,sentinelScriptRetryDelay,,,101,mstime_t sentinelScriptRetryDelay (int)
349937,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCollectTerminatedScripts(void) {
    int statloc;
    pid_t pid;

    while ((pid = waitpid(-1, &statloc, WNOHANG)) > 0) {
        int exitcode = WEXITSTATUS(statloc);
        int bysignal = 0;
        listNode *ln;
        sentinelScriptJob *sj;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);
        sentinelEvent(LL_DEBUG,""-script-child"",NULL,""%ld %d %d"",
            (long)pid, exitcode, bysignal);

        ln = sentinelGetScriptListNodeByPid(pid);
        if (ln == NULL) {
            serverLog(LL_WARNING,""waitpid() returned a pid (%ld) we can't find in our scripts execution queue!"", (long)pid);
            continue;
        }
        sj = ln->value;

        /* If the script was terminated by a signal or returns an
         * exit code of ""1"" (that means: please retry), we reschedule it
         * if the max number of retries is not already reached. */
        if ((bysignal || exitcode == 1) &&
            sj->retry_num != SENTINEL_SCRIPT_MAX_RETRY)...",1,22,sentinel.c,sentinelCollectTerminatedScripts,,false,883,926,sentinelCollectTerminatedScripts,,,102,void sentinelCollectTerminatedScripts (void)
350095,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelKillTimedoutScripts(void) {
    listNode *ln;
    listIter li;
    mstime_t now = mstime();

    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;

        if (sj->flags & SENTINEL_SCRIPT_RUNNING &&
            (now - sj->start_time) > sentinel_script_max_runtime)
        {
            sentinelEvent(LL_WARNING,""-script-timeout"",NULL,""%s %ld"",
                sj->argv[0], (long)sj->pid);
            kill(sj->pid,SIGKILL);
        }
    }
}",1,24,sentinel.c,sentinelKillTimedoutScripts,,false,930,947,sentinelKillTimedoutScripts,,,103,void sentinelKillTimedoutScripts (void)
350166,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelPendingScriptsCommand(client *c) {
    listNode *ln;
    listIter li;

    addReplyArrayLen(c,listLength(sentinel.scripts_queue));
    listRewind(sentinel.scripts_queue,&li);
    while ((ln = listNext(&li)) != NULL) {
        sentinelScriptJob *sj = ln->value;
        int j = 0;

        addReplyMapLen(c,5);

        addReplyBulkCString(c,""argv"");
        while (sj->argv[j]) j++;
        addReplyArrayLen(c,j);
        j = 0;
        while (sj->argv[j]) addReplyBulkCString(c,sj->argv[j++]);

        addReplyBulkCString(c,""flags"");
        addReplyBulkCString(c,
            (sj->flags & SENTINEL_SCRIPT_RUNNING) ? ""running"" : ""scheduled"");

        addReplyBulkCString(c,""pid"");
        addReplyBulkLongLong(c,sj->pid);

        if (sj->flags & SENTINEL_SCRIPT_RUNNING) {
            addReplyBulkCString(c,""run-time"");
            addReplyBulkLongLong(c,mstime() - sj->start_time);
        } else {
            mstime_t delay = sj->start_time ? (sj->start_time-mstime()) : 0;
   ...",1,23,sentinel.c,sentinelPendingScriptsCommand,,false,950,988,sentinelPendingScriptsCommand,,,104,void sentinelPendingScriptsCommand (client*)
350323,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {
    char fromport[32], toport[32];

    if (master->client_reconfig_script == NULL) return;
    ll2string(fromport,sizeof(fromport),from->port);
    ll2string(toport,sizeof(toport),to->port);
    sentinelScheduleScriptExecution(master->client_reconfig_script,
        master->name,
        (role == SENTINEL_LEADER) ? ""leader"" : ""observer"",
        state, announceSentinelAddr(from), fromport,
        announceSentinelAddr(to), toport, NULL);
}",1,17,sentinel.c,sentinelCallClientReconfScript,,false,1002,1013,sentinelCallClientReconfScript,,,105,"void sentinelCallClientReconfScript (sentinelRedisInstance*,int,char*,sentinelAddr*,sentinelAddr*)"
350381,METHOD,sentinel.c:<global>,TYPE_DECL,"instanceLink *createInstanceLink(void) {
    instanceLink *link = zmalloc(sizeof(*link));

    link->refcount = 1;
    link->disconnected = 1;
    link->pending_commands = 0;
    link->cc = NULL;
    link->pc = NULL;
    link->cc_conn_time = 0;
    link->pc_conn_time = 0;
    link->last_reconn_time = 0;
    link->pc_last_activity = 0;
    /* We set the act_ping_time to ""now"" even if we actually don't have yet
     * a connection with the node, nor we sent a ping.
     * This is useful to detect a timeout in case we'll not be able to connect
     * with the node at all. */
    link->act_ping_time = mstime();
    link->last_ping_time = 0;
    link->last_avail_time = mstime();
    link->last_pong_time = mstime();
    return link;
}",1,1,sentinel.c,createInstanceLink,,false,1018,1039,createInstanceLink,,,106,instanceLink createInstanceLink (void)
350460,METHOD,sentinel.c:<global>,TYPE_DECL,"void instanceLinkCloseConnection(instanceLink *link, redisAsyncContext *c) {
    if (c == NULL) return;

    if (link->cc == c) {
        link->cc = NULL;
        link->pending_commands = 0;
    }
    if (link->pc == c) link->pc = NULL;
    c->data = NULL;
    link->disconnected = 1;
    redisAsyncFree(c);
}",1,1,sentinel.c,instanceLinkCloseConnection,,false,1042,1053,instanceLinkCloseConnection,,,107,"void instanceLinkCloseConnection (instanceLink*,redisAsyncContext*)"
350513,METHOD,sentinel.c:<global>,TYPE_DECL,"instanceLink *releaseInstanceLink(instanceLink *link, sentinelRedisInstance *ri)
{
    serverAssert(link->refcount > 0);
    link->refcount--;
    if (link->refcount != 0) {
        if (ri && ri->link->cc) {
            /* This instance may have pending callbacks in the hiredis async
             * context, having as 'privdata' the instance that we are going to
             * free. Let's rewrite the callback list, directly exploiting
             * hiredis internal data structures, in order to bind them with
             * a callback that will ignore the reply at all. */
            redisCallback *cb;
            redisCallbackList *callbacks = &link->cc->replies;

            cb = callbacks->head;
            while(cb) {
                if (cb->privdata == ri) {
                    cb->fn = sentinelDiscardReplyCallback;
                    cb->privdata = NULL; /* Not strictly needed. */
                }
                cb = cb->next;
            }
        }
        return link; /* ...",1,4,sentinel.c,releaseInstanceLink,,false,1063,1093,releaseInstanceLink,,,108,"instanceLink releaseInstanceLink (instanceLink*,sentinelRedisInstance*)"
350613,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelTryConnectionSharing(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_SENTINEL);
    dictIterator *di;
    dictEntry *de;

    if (ri->runid == NULL) return C_ERR; /* No way to identify it. */
    if (ri->link->refcount > 1) return C_ERR; /* Already shared. */

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *master = dictGetVal(de), *match;
        /* We want to share with the same physical Sentinel referenced
         * in other masters, so skip our master. */
        if (master == ri->master) continue;
        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
                                                       NULL,0,ri->runid);
        if (match == NULL) continue; /* No match. */
        if (match == ri) continue; /* Should never happen but... safer. */

        /* We identified a matching Sentinel, great! Let's free our link
         * and use the one of the matching S...",1,4,sentinel.c,sentinelTryConnectionSharing,,false,1107,1136,sentinelTryConnectionSharing,,,109,int sentinelTryConnectionSharing (sentinelRedisInstance*)
350748,METHOD,sentinel.c:<global>,TYPE_DECL,"void dropInstanceConnections(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    /* Disconnect with the master. */
    instanceLinkCloseConnection(ri->link, ri->link->cc);
    instanceLinkCloseConnection(ri->link, ri->link->pc);
    
    /* Disconnect with all replicas. */
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *repl_ri;
    di = dictGetIterator(ri->slaves);
    while ((de = dictNext(di)) != NULL) {
        repl_ri = dictGetVal(de);
        instanceLinkCloseConnection(repl_ri->link, repl_ri->link->cc);
        instanceLinkCloseConnection(repl_ri->link, repl_ri->link->pc);
    }
    dictReleaseIterator(di);
}",1,4,sentinel.c,dropInstanceConnections,,false,1139,1157,dropInstanceConnections,,,110,void dropInstanceConnections (sentinelRedisInstance*)
350832,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelDropConnections(void) {
    dictIterator *di;
    dictEntry *de;
    int dropped = 0;

    di = dictGetIterator(sentinel.masters);
    while ((de = dictNext(di)) != NULL) {
        dictIterator *sdi;
        dictEntry *sde;

        sentinelRedisInstance *ri = dictGetVal(de);
        sdi = dictGetIterator(ri->sentinels);
        while ((sde = dictNext(sdi)) != NULL) {
            sentinelRedisInstance *si = dictGetVal(sde);
            if (!si->link->disconnected) {
                instanceLinkCloseConnection(si->link, si->link->pc);
                instanceLinkCloseConnection(si->link, si->link->cc);
                dropped++;
            }
        }
        dictReleaseIterator(sdi);
    }
    dictReleaseIterator(di);

    return dropped;
}",1,1,sentinel.c,sentinelDropConnections,,false,1161,1186,sentinelDropConnections,,,111,int sentinelDropConnections (void)
350917,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelUpdateSentinelAddressInAllMasters(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_SENTINEL);
    dictIterator *di;
    dictEntry *de;
    int reconfigured = 0;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *master = dictGetVal(de), *match;
        match = getSentinelRedisInstanceByAddrAndRunID(master->sentinels,
                                                       NULL,0,ri->runid);
        /* If there is no match, this master does not know about this
         * Sentinel, try with the next one. */
        if (match == NULL) continue;

        /* Disconnect the old links if connected. */
        if (match->link->cc != NULL)
            instanceLinkCloseConnection(match->link,match->link->cc);
        if (match->link->pc != NULL)
            instanceLinkCloseConnection(match->link,match->link->pc);

        if (match == ri) continue; /* Address already updated for it. */

        /* Updat...",1,4,sentinel.c,sentinelUpdateSentinelAddressInAllMasters,,false,1194,1228,sentinelUpdateSentinelAddressInAllMasters,,,112,int sentinelUpdateSentinelAddressInAllMasters (sentinelRedisInstance*)
351056,METHOD,sentinel.c:<global>,TYPE_DECL,"void instanceLinkConnectionError(const redisAsyncContext *c) {
    instanceLink *link = c->data;
    int pubsub;

    if (!link) return;

    pubsub = (link->pc == c);
    if (pubsub)
        link->pc = NULL;
    else
        link->cc = NULL;
    link->disconnected = 1;
}",1,1,sentinel.c,instanceLinkConnectionError,,false,1236,1248,instanceLinkConnectionError,,,113,void instanceLinkConnectionError (redisAsyncContext*)
351100,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {
    if (status != C_OK) instanceLinkConnectionError(c);
}",1,18,sentinel.c,sentinelLinkEstablishedCallback,,false,1252,1254,sentinelLinkEstablishedCallback,,,114,"void sentinelLinkEstablishedCallback (redisAsyncContext*,int)"
351115,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {
    UNUSED(status);
    instanceLinkConnectionError(c);
}",1,4,sentinel.c,sentinelDisconnectCallback,,false,1256,1259,sentinelDisconnectCallback,,,115,"void sentinelDisconnectCallback (redisAsyncContext*,int)"
351129,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {
    sentinelRedisInstance *ri;
    sentinelAddr *addr;
    dict *table = NULL;
    sds sdsname;

    serverAssert(flags & (SRI_MASTER|SRI_SLAVE|SRI_SENTINEL));
    serverAssert((flags & SRI_MASTER) || master != NULL);

    /* Check address validity. */
    addr = createSentinelAddr(hostname,port,1);
    if (addr == NULL) return NULL;

    /* For slaves use ip/host:port as name. */
    if (flags & SRI_SLAVE)
        sdsname = announceSentinelAddrAndPort(addr);
    else
        sdsname = sdsnew(name);

    /* Make sure the entry is not duplicated. This may happen when the same
     * name for a master is used multiple times inside the configuration or
     * if we try to add multiple times a slave or sentinel with same ip/port
     * to a master. */
    if (flags & SRI_MASTER) table = sentinel.masters;
    else if (flags & SRI_SLAVE) table = ...",1,4,sentinel.c,createSentinelRedisInstance,,false,1285,1375,createSentinelRedisInstance,,,116,"sentinelRedisInstance createSentinelRedisInstance (char*,int,char*,int,int,sentinelRedisInstance*)"
351558,METHOD,sentinel.c:<global>,TYPE_DECL,"void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {
    /* Release all its slaves or sentinels if any. */
    dictRelease(ri->sentinels);
    dictRelease(ri->slaves);

    /* Disconnect the instance. */
    releaseInstanceLink(ri->link,ri);

    /* Free other resources. */
    sdsfree(ri->name);
    sdsfree(ri->runid);
    sdsfree(ri->notification_script);
    sdsfree(ri->client_reconfig_script);
    sdsfree(ri->slave_master_host);
    sdsfree(ri->leader);
    sdsfree(ri->auth_pass);
    sdsfree(ri->auth_user);
    sdsfree(ri->info);
    releaseSentinelAddr(ri->addr);
    dictRelease(ri->renamed_commands);

    /* Clear state into the master if needed. */
    if ((ri->flags & SRI_SLAVE) && (ri->flags & SRI_PROMOTED) && ri->master)
        ri->master->promoted_slave = NULL;

    zfree(ri);
}",1,21,sentinel.c,releaseSentinelRedisInstance,,false,1381,1407,releaseSentinelRedisInstance,,,117,void releaseSentinelRedisInstance (sentinelRedisInstance*)
351654,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *sentinelRedisInstanceLookupSlave(
                sentinelRedisInstance *ri, char *slave_addr, int port)
{
    sds key;
    sentinelRedisInstance *slave;
    sentinelAddr *addr;

    serverAssert(ri->flags & SRI_MASTER);

    /* We need to handle a slave_addr that is potentially a hostname.
     * If that is the case, depending on configuration we either resolve
     * it and use the IP address or fail.
     */
    addr = createSentinelAddr(slave_addr, port, 0);
    if (!addr) return NULL;
    key = announceSentinelAddrAndPort(addr);
    releaseSentinelAddr(addr);

    slave = dictFetchValue(ri->slaves,key);
    sdsfree(key);
    return slave;
}",1,4,sentinel.c,sentinelRedisInstanceLookupSlave,,false,1410,1431,sentinelRedisInstanceLookupSlave,,,118,"sentinelRedisInstance sentinelRedisInstanceLookupSlave (sentinelRedisInstance*,char*,int)"
351713,METHOD,sentinel.c:<global>,TYPE_DECL,"const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {
    if (ri->flags & SRI_MASTER) return ""master"";
    else if (ri->flags & SRI_SLAVE) return ""slave"";
    else if (ri->flags & SRI_SENTINEL) return ""sentinel"";
    else return ""unknown"";
}",1,20,sentinel.c,sentinelRedisInstanceTypeStr,,false,1434,1439,sentinelRedisInstanceTypeStr,,,119,const char* sentinelRedisInstanceTypeStr (sentinelRedisInstance*)
351765,METHOD,sentinel.c:<global>,TYPE_DECL,"int removeMatchingSentinelFromMaster(sentinelRedisInstance *master, char *runid) {
    dictIterator *di;
    dictEntry *de;
    int removed = 0;

    if (runid == NULL) return 0;

    di = dictGetSafeIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->runid && strcmp(ri->runid,runid) == 0) {
            dictDelete(master->sentinels,ri->name);
            removed++;
        }
    }
    dictReleaseIterator(di);
    return removed;
}",1,1,sentinel.c,removeMatchingSentinelFromMaster,,false,1452,1470,removeMatchingSentinelFromMaster,,,120,"int removeMatchingSentinelFromMaster (sentinelRedisInstance*,char*)"
351829,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *addr, int port, char *runid) {
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *instance = NULL;
    sentinelAddr *ri_addr = NULL;

    serverAssert(addr || runid);   /* User must pass at least one search param. */
    if (addr != NULL) {
        /* Try to resolve addr. If hostnames are used, we're accepting an ri_addr
         * that contains an hostname only and can still be matched based on that.
         */
        ri_addr = createSentinelAddr(addr,port,1);
        if (!ri_addr) return NULL;
    }
    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (runid && !ri->runid) continue;
        if ((runid == NULL || strcmp(ri->runid, runid) == 0) &&
            (addr == NULL || sentinelAddrOrHostnameEqual(ri->addr, ri_addr)))
        {
            instance = ri;
            break;
        }
    ...",1,4,sentinel.c,getSentinelRedisInstanceByAddrAndRunID,,false,1478,1509,getSentinelRedisInstanceByAddrAndRunID,,,121,"sentinelRedisInstance getSentinelRedisInstanceByAddrAndRunID (dict*,char*,int,char*)"
351944,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *sentinelGetMasterByName(char *name) {
    sentinelRedisInstance *ri;
    sds sdsname = sdsnew(name);

    ri = dictFetchValue(sentinel.masters,sdsname);
    sdsfree(sdsname);
    return ri;
}",1,1,sentinel.c,sentinelGetMasterByName,,false,1512,1519,sentinelGetMasterByName,,,122,sentinelRedisInstance sentinelGetMasterByName (char*)
351966,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {
    serverAssert(ri->flags & SRI_MASTER);
    dictRelease(ri->slaves);
    ri->slaves = dictCreate(&instancesDictType);
    if (!(flags & SENTINEL_RESET_NO_SENTINELS)) {
        dictRelease(ri->sentinels);
        ri->sentinels = dictCreate(&instancesDictType);
    }
    instanceLinkCloseConnection(ri->link,ri->link->cc);
    instanceLinkCloseConnection(ri->link,ri->link->pc);
    ri->flags &= SRI_MASTER;
    if (ri->leader) {
        sdsfree(ri->leader);
        ri->leader = NULL;
    }
    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
    ri->failover_state_change_time = 0;
    ri->failover_start_time = 0; /* We can failover again ASAP. */
    ri->promoted_slave = NULL;
    sdsfree(ri->runid);
    sdsfree(ri->slave_master_host);
    ri->runid = NULL;
    ri->slave_master_host = NULL;
    ri->link->act_ping_time = mstime();
    ri->link->last_ping_time = 0;
    ri->link->last_avail_time = mstime();
    ri->link->...",1,4,sentinel.c,sentinelResetMaster,,false,1533,1564,sentinelResetMaster,,,123,"void sentinelResetMaster (sentinelRedisInstance*,int)"
352163,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelResetMastersByPattern(char *pattern, int flags) {
    dictIterator *di;
    dictEntry *de;
    int reset = 0;

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->name) {
            if (stringmatch(pattern,ri->name,0)) {
                sentinelResetMaster(ri,flags);
                reset++;
            }
        }
    }
    dictReleaseIterator(di);
    return reset;
}",1,1,sentinel.c,sentinelResetMastersByPattern,,false,1568,1586,sentinelResetMastersByPattern,,,124,"int sentinelResetMastersByPattern (char*,int)"
352216,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *hostname, int port) {
    sentinelAddr *oldaddr, *newaddr;
    sentinelAddr **slaves = NULL;
    int numslaves = 0, j;
    dictIterator *di;
    dictEntry *de;

    newaddr = createSentinelAddr(hostname,port,0);
    if (newaddr == NULL) return C_ERR;

    /* There can be only 0 or 1 slave that has the newaddr.
     * and It can add old master 1 more slave. 
     * so It allocates dictSize(master->slaves) + 1          */
    slaves = zmalloc(sizeof(sentinelAddr*)*(dictSize(master->slaves) + 1));
    
    /* Don't include the one having the address we are switching to. */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (sentinelAddrOrHostnameEqual(slave->addr,newaddr)) continue;
        slaves[numslaves++] = dupSentinelAddr(slave->addr);
    }
    dictReleaseIterator(di);

    /* If we are switching to a diff...",1,32,sentinel.c,sentinelResetMasterAndChangeAddress,,false,1595,1650,sentinelResetMasterAndChangeAddress,,,125,"int sentinelResetMasterAndChangeAddress (sentinelRedisInstance*,char*,int)"
352420,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {
    mstime_t most_recent;

    most_recent = ri->s_down_since_time;
    if (ri->o_down_since_time > most_recent)
        most_recent = ri->o_down_since_time;
    return most_recent == 0 || (mstime() - most_recent) > ms;
}",1,1,sentinel.c,sentinelRedisInstanceNoDownFor,,false,1654,1661,sentinelRedisInstanceNoDownFor,,,126,"int sentinelRedisInstanceNoDownFor (sentinelRedisInstance*,mstime_t)"
352454,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {
    /* If we are failing over the master, and the state is already
     * SENTINEL_FAILOVER_STATE_RECONF_SLAVES or greater, it means that we
     * already have the new configuration epoch in the master, and the
     * slave acknowledged the configuration switch. Advertise the new
     * address. */
    if ((master->flags & SRI_FAILOVER_IN_PROGRESS) &&
        master->promoted_slave &&
        master->failover_state >= SENTINEL_FAILOVER_STATE_RECONF_SLAVES)
    {
        return master->promoted_slave->addr;
    } else {
        return master->addr;
    }
}",1,25,sentinel.c,sentinelGetCurrentMasterAddress,,false,1665,1679,sentinelGetCurrentMasterAddress,,,127,sentinelAddr sentinelGetCurrentMasterAddress (sentinelRedisInstance*)
352494,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int j;
    dict *d[] = {master->slaves, master->sentinels, NULL};

    for (j = 0; d[j]; j++) {
        di = dictGetIterator(d[j]);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);
            ri->down_after_period = master->down_after_period;
        }
        dictReleaseIterator(di);
    }
}",1,1,sentinel.c,sentinelPropagateDownAfterPeriod,,false,1683,1697,sentinelPropagateDownAfterPeriod,,,128,void sentinelPropagateDownAfterPeriod (sentinelRedisInstance*)
352552,METHOD,sentinel.c:<global>,TYPE_DECL,"char *sentinelInstanceMapCommand(sentinelRedisInstance *ri, char *command) {
    sds sc = sdsnew(command);
    if (ri->master) ri = ri->master;
    char *retval = dictFetchValue(ri->renamed_commands, sc);
    sdsfree(sc);
    return retval ? retval : command;
}",1,1,sentinel.c,sentinelInstanceMapCommand,,false,1706,1712,sentinelInstanceMapCommand,,,129,"char* sentinelInstanceMapCommand (sentinelRedisInstance*,char*)"
352588,METHOD,sentinel.c:<global>,TYPE_DECL,"const char *sentinelCheckCreateInstanceErrors(int role) {
    switch(errno) {
    case EBUSY:
        switch (role) {
        case SRI_MASTER:
            return ""Duplicate master name."";
        case SRI_SLAVE:
            return ""Duplicate hostname and port for replica."";
        case SRI_SENTINEL:
            return ""Duplicate runid for sentinel."";
        default:
            serverAssert(0);
            break;
        }
        break;
    case ENOENT:
        return ""Can't resolve instance hostname."";
    case EINVAL:
        return ""Invalid port number."";
    default:
        return ""Unknown Error for creating instances."";
    }
}",1,13,sentinel.c,sentinelCheckCreateInstanceErrors,,false,1718,1740,sentinelCheckCreateInstanceErrors,,,130,const char* sentinelCheckCreateInstanceErrors (int)
352654,METHOD,sentinel.c:<global>,TYPE_DECL,"void initializeSentinelConfig(void) {
    server.sentinel_config = zmalloc(sizeof(struct sentinelConfig));
    server.sentinel_config->monitor_cfg = listCreate();
    server.sentinel_config->pre_monitor_cfg = listCreate();
    server.sentinel_config->post_monitor_cfg = listCreate();
    listSetFreeMethod(server.sentinel_config->monitor_cfg,freeSentinelLoadQueueEntry);
    listSetFreeMethod(server.sentinel_config->pre_monitor_cfg,freeSentinelLoadQueueEntry);
    listSetFreeMethod(server.sentinel_config->post_monitor_cfg,freeSentinelLoadQueueEntry);
}",1,4,sentinel.c,initializeSentinelConfig,,false,1743,1751,initializeSentinelConfig,,,131,void initializeSentinelConfig (void)
352738,METHOD,sentinel.c:<global>,TYPE_DECL,"void freeSentinelConfig(void) {
    /* release these three config queues since we will not use it anymore */
    listRelease(server.sentinel_config->pre_monitor_cfg);
    listRelease(server.sentinel_config->monitor_cfg);
    listRelease(server.sentinel_config->post_monitor_cfg);
    zfree(server.sentinel_config);
    server.sentinel_config = NULL;
}",1,1,sentinel.c,freeSentinelConfig,,false,1754,1761,freeSentinelConfig,,,132,void freeSentinelConfig (void)
352770,METHOD,sentinel.c:<global>,TYPE_DECL,"int searchPreMonitorCfgName(const char *name) {
    for (unsigned int i = 0; i < sizeof(preMonitorCfgName)/sizeof(preMonitorCfgName[0]); i++) {
        if (!strcasecmp(preMonitorCfgName[i],name)) return 1;
    }
    return 0;
}",1,1,sentinel.c,searchPreMonitorCfgName,,false,1765,1770,searchPreMonitorCfgName,,,133,int searchPreMonitorCfgName (char*)
352805,METHOD,sentinel.c:<global>,TYPE_DECL,"void freeSentinelLoadQueueEntry(void *item) {
    struct sentinelLoadQueueEntry *entry = item;
    sdsfreesplitres(entry->argv,entry->argc);
    sdsfree(entry->line);
    zfree(entry);
}",1,1,sentinel.c,freeSentinelLoadQueueEntry,,false,1773,1778,freeSentinelLoadQueueEntry,,,134,void freeSentinelLoadQueueEntry (void*)
352827,METHOD,sentinel.c:<global>,TYPE_DECL,"void queueSentinelConfig(sds *argv, int argc, int linenum, sds line) {
    int i;
    struct sentinelLoadQueueEntry *entry;

    /* initialize sentinel_config for the first call */
    if (server.sentinel_config == NULL) initializeSentinelConfig();

    entry = zmalloc(sizeof(struct sentinelLoadQueueEntry));
    entry->argv = zmalloc(sizeof(char*)*argc);
    entry->argc = argc;
    entry->linenum = linenum;
    entry->line = sdsdup(line);
    for (i = 0; i < argc; i++) {
        entry->argv[i] = sdsdup(argv[i]);
    }
    /*  Separate config lines with pre monitor config, monitor config and
     *  post monitor config, in order to parsing config dependencies
     *  correctly. */
    if (!strcasecmp(argv[0],""monitor"")) {
        listAddNodeTail(server.sentinel_config->monitor_cfg,entry);
    } else if (searchPreMonitorCfgName(argv[0])) {
        listAddNodeTail(server.sentinel_config->pre_monitor_cfg,entry);
    } else{
        listAddNodeTail(server.sentinel_config->post_monitor_cf...",1,1,sentinel.c,queueSentinelConfig,,false,1783,1808,queueSentinelConfig,,,135,"void queueSentinelConfig (sds*,int,int,sds)"
352935,METHOD,sentinel.c:<global>,TYPE_DECL,"void loadSentinelConfigFromQueue(void) {
    const char *err = NULL;
    listIter li;
    listNode *ln;
    int linenum = 0;
    sds line = NULL;
    unsigned int j;

    /* if there is no sentinel_config entry, we can return immediately */
    if (server.sentinel_config == NULL) return;

    list *sentinel_configs[3] = {
        server.sentinel_config->pre_monitor_cfg,
        server.sentinel_config->monitor_cfg,
        server.sentinel_config->post_monitor_cfg
    };
    /* loading from pre monitor config queue first to avoid dependency issues
     * loading from monitor config queue
     * loading from the post monitor config queue */
    for (j = 0; j < sizeof(sentinel_configs) / sizeof(sentinel_configs[0]); j++) {
        listRewind(sentinel_configs[j],&li);
        while((ln = listNext(&li))) {
            struct sentinelLoadQueueEntry *entry = ln->value;
            err = sentinelHandleConfiguration(entry->argv,entry->argc);
            if (err) {
                linenum = en...",1,8,sentinel.c,loadSentinelConfigFromQueue,,false,1812,1855,loadSentinelConfigFromQueue,,,136,void loadSentinelConfigFromQueue (void)
353064,METHOD,sentinel.c:<global>,TYPE_DECL,"const char *sentinelHandleConfiguration(char **argv, int argc) {

    sentinelRedisInstance *ri;

    if (!strcasecmp(argv[0],""monitor"") && argc == 5) {
        /* monitor <name> <host> <port> <quorum> */
        int quorum = atoi(argv[4]);

        if (quorum <= 0) return ""Quorum must be 1 or greater."";
        if (createSentinelRedisInstance(argv[1],SRI_MASTER,argv[2],
                                        atoi(argv[3]),quorum,NULL) == NULL)
        {
            return sentinelCheckCreateInstanceErrors(SRI_MASTER);
        }
    } else if (!strcasecmp(argv[0],""down-after-milliseconds"") && argc == 3) {
        /* down-after-milliseconds <name> <milliseconds> */
        ri = sentinelGetMasterByName(argv[1]);
        if (!ri) return ""No such master with specified name."";
        ri->down_after_period = atoi(argv[2]);
        if (ri->down_after_period <= 0)
            return ""negative or zero time parameter."";
        sentinelPropagateDownAfterPeriod(ri);
    } else if (!strcasecm...",1,48,sentinel.c,sentinelHandleConfiguration,,false,1857,2022,sentinelHandleConfiguration,,,137,"const char* sentinelHandleConfiguration (char**,int)"
354011,METHOD,sentinel.c:<global>,TYPE_DECL,"void rewriteConfigSentinelOption(struct rewriteConfigState *state) {
    dictIterator *di, *di2;
    dictEntry *de;
    sds line;

    /* sentinel unique ID. */
    line = sdscatprintf(sdsempty(), ""sentinel myid %s"", sentinel.myid);
    rewriteConfigRewriteLine(state,""sentinel myid"",line,1);

    /* sentinel deny-scripts-reconfig. */
    line = sdscatprintf(sdsempty(), ""sentinel deny-scripts-reconfig %s"",
        sentinel.deny_scripts_reconfig ? ""yes"" : ""no"");
    rewriteConfigRewriteLine(state,""sentinel deny-scripts-reconfig"",line,
        sentinel.deny_scripts_reconfig != SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG);

    /* sentinel resolve-hostnames.
     * This must be included early in the file so it is already in effect
     * when reading the file.
     */
    line = sdscatprintf(sdsempty(), ""sentinel resolve-hostnames %s"",
                        sentinel.resolve_hostnames ? ""yes"" : ""no"");
    rewriteConfigRewriteLine(state,""sentinel resolve-hostnames"",line,
                    ...",1,42,sentinel.c,rewriteConfigSentinelOption,,false,2029,2276,rewriteConfigSentinelOption,,,138,void rewriteConfigSentinelOption (rewriteConfigState*)
354685,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelFlushConfig(void) {
    int saved_hz = server.hz;
    int rewrite_status;

    server.hz = CONFIG_DEFAULT_HZ;
    rewrite_status = rewriteConfig(server.configfile, 0);
    server.hz = saved_hz;

    if (rewrite_status == -1) {
        serverLog(LL_WARNING,""WARNING: Sentinel was not able to save the new configuration on disk!!!: %s"", strerror(errno));
        return C_ERR;
    } else {
        serverLog(LL_NOTICE,""Sentinel new configuration saved on disk"");
        return C_OK;
    }
}",1,16,sentinel.c,sentinelFlushConfig,,false,2282,2297,sentinelFlushConfig,,,139,int sentinelFlushConfig (void)
354771,METHOD,sentinel.c:<global>,TYPE_DECL,"static void sentinelFlushConfigAndReply(client *c) {
    if (sentinelFlushConfig() == C_ERR)
        addReplyError(c, ""Failed to save config file. Check server logs."");
    else
        addReply(c, shared.ok);
}",1,33,sentinel.c,sentinelFlushConfigAndReply,,false,2302,2307,sentinelFlushConfigAndReply,,,140,void sentinelFlushConfigAndReply (client*)
354794,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {
    char *auth_pass = NULL;
    char *auth_user = NULL;

    if (ri->flags & SRI_MASTER) {
        auth_pass = ri->auth_pass;
        auth_user = ri->auth_user;
    } else if (ri->flags & SRI_SLAVE) {
        auth_pass = ri->master->auth_pass;
        auth_user = ri->master->auth_user;
    } else if (ri->flags & SRI_SENTINEL) {
        /* If sentinel_auth_user is NULL, AUTH will use default user
           with sentinel_auth_pass to authenticate */
        if (sentinel.sentinel_auth_pass) {
            auth_pass = sentinel.sentinel_auth_pass;
            auth_user = sentinel.sentinel_auth_user;
        } else {
            /* Compatibility with old configs. requirepass is used
             * for both incoming and outgoing authentication. */
            auth_pass = server.requirepass;
            auth_user = NULL;
        }
    }

    if (auth_pass && auth_user == NULL) {
        if (redisAsyncCommand(c,...",1,20,sentinel.c,sentinelSendAuthIfNeeded,,false,2323,2358,sentinelSendAuthIfNeeded,,,141,"void sentinelSendAuthIfNeeded (sentinelRedisInstance*,redisAsyncContext*)"
354951,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {
    char name[64];

    snprintf(name,sizeof(name),""sentinel-%.8s-%s"",sentinel.myid,type);
    if (redisAsyncCommand(c, sentinelDiscardReplyCallback, ri,
        ""%s SETNAME %s"",
        sentinelInstanceMapCommand(ri,""CLIENT""),
        name) == C_OK)
    {
        ri->link->pending_commands++;
    }
}",1,17,sentinel.c,sentinelSetClientName,,false,2366,2377,sentinelSetClientName,,,142,"void sentinelSetClientName (sentinelRedisInstance*,redisAsyncContext*,char*)"
354989,METHOD,sentinel.c:<global>,TYPE_DECL,"static int instanceLinkNegotiateTLS(redisAsyncContext *context) {
#if USE_OPENSSL == 1 /* BUILD_YES */
    if (!redis_tls_ctx) return C_ERR;
    SSL *ssl = SSL_new(redis_tls_client_ctx ? redis_tls_client_ctx : redis_tls_ctx);
    if (!ssl) return C_ERR;

    if (redisInitiateSSL(&context->c, ssl) == REDIS_ERR) {
        SSL_free(ssl);
        return C_ERR;
    }
#else
    UNUSED(context);
#endif
    return C_OK;
}",1,4,sentinel.c,instanceLinkNegotiateTLS,,false,2379,2393,instanceLinkNegotiateTLS,,,143,int instanceLinkNegotiateTLS (redisAsyncContext*)
355004,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelReconnectInstance(sentinelRedisInstance *ri) {

    if (ri->link->disconnected == 0) return;
    if (ri->addr->port == 0) return; /* port == 0 means invalid address. */
    instanceLink *link = ri->link;
    mstime_t now = mstime();

    if (now - ri->link->last_reconn_time < sentinel_ping_period) return;
    ri->link->last_reconn_time = now;

    /* Commands connection. */
    if (link->cc == NULL) {

        /* It might be that the instance is disconnected because it wasn't available earlier when the instance
         * allocated, say during failover, and therefore we failed to resolve its ip.
         * Another scenario is that the instance restarted with new ip, and we should resolve its new ip based on
         * its hostname */
        if (sentinel.resolve_hostnames) {
            sentinelAddr *tryResolveAddr = createSentinelAddr(ri->addr->hostname, ri->addr->port, 0);
            if (tryResolveAddr != NULL) {
                releaseSentinelAddr(ri->addr);
       ...",1,26,sentinel.c,sentinelReconnectInstance,,false,2398,2493,sentinelReconnectInstance,,,144,void sentinelReconnectInstance (sentinelRedisInstance*)
355487,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelMasterLooksSane(sentinelRedisInstance *master) {
    return
        master->flags & SRI_MASTER &&
        master->role_reported == SRI_MASTER &&
        (master->flags & (SRI_S_DOWN|SRI_O_DOWN)) == 0 &&
        (mstime() - master->info_refresh) < sentinel_info_period*2;
}",1,24,sentinel.c,sentinelMasterLooksSane,,false,2502,2508,sentinelMasterLooksSane,,,145,int sentinelMasterLooksSane (sentinelRedisInstance*)
355540,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {
    sds *lines;
    int numlines, j;
    int role = 0;

    /* cache full INFO output for instance */
    sdsfree(ri->info);
    ri->info = sdsnew(info);

    /* The following fields must be reset to a given value in the case they
     * are not found at all in the INFO output. */
    ri->master_link_down_time = 0;

    /* Process line by line. */
    lines = sdssplitlen(info,strlen(info),""\r\n"",2,&numlines);
    for (j = 0; j < numlines; j++) {
        sentinelRedisInstance *slave;
        sds l = lines[j];

        /* run_id:<40 hex chars>*/
        if (sdslen(l) >= 47 && !memcmp(l,""run_id:"",7)) {
            if (ri->runid == NULL) {
                ri->runid = sdsnewlen(l+7,40);
            } else {
                if (strncmp(ri->runid,l+7,40) != 0) {
                    sentinelEvent(LL_NOTICE,""+reboot"",ri,""%@"");

                    if (ri->flags & SRI_MASTER && ri->master_reboot_down_after_period ...",1,34,sentinel.c,sentinelRefreshInstanceInfo,,false,2511,2766,sentinelRefreshInstanceInfo,,,146,"void sentinelRefreshInstanceInfo (sentinelRedisInstance*,char*)"
356632,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* INFO reply type is verbatim in resp3. Normally, sentinel will not use
     * resp3 but this is required for testing (see logreqres.c). */
    if (r->type == REDIS_REPLY_STRING || r->type == REDIS_REPLY_VERB)
        sentinelRefreshInstanceInfo(ri,r->str);
}",1,1,sentinel.c,sentinelInfoReplyCallback,,false,2768,2781,sentinelInfoReplyCallback,,,147,"void sentinelInfoReplyCallback (redisAsyncContext*,void*,void*)"
356683,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    instanceLink *link = c->data;
    UNUSED(reply);
    UNUSED(privdata);

    if (link) link->pending_commands--;
}",1,4,sentinel.c,sentinelDiscardReplyCallback,,false,2785,2791,sentinelDiscardReplyCallback,,,148,"void sentinelDiscardReplyCallback (redisAsyncContext*,void*,void*)"
356715,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    if (r->type == REDIS_REPLY_STATUS ||
        r->type == REDIS_REPLY_ERROR) {
        /* Update the ""instance available"" field only if this is an
         * acceptable reply. */
        if (strncmp(r->str,""PONG"",4) == 0 ||
            strncmp(r->str,""LOADING"",7) == 0 ||
            strncmp(r->str,""MASTERDOWN"",10) == 0)
        {
            link->last_avail_time = mstime();
            link->act_ping_time = 0; /* Flag the pong as received. */

            if (ri->flags & SRI_MASTER_REBOOT && strncmp(r->str,""PONG"",4) == 0)
                ri->flags &= ~SRI_MASTER_REBOOT;

        } else {
            /* Send a SCRIPT KILL command if the instance appears to be
             * down because of a busy script. */
            if (str...",1,28,sentinel.c,sentinelPingReplyCallback,,false,2793,2835,sentinelPingReplyCallback,,,149,"void sentinelPingReplyCallback (redisAsyncContext*,void*,void*)"
356900,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* Only update pub_time if we actually published our message. Otherwise
     * we'll retry again in 100 milliseconds. */
    if (r->type != REDIS_REPLY_ERROR)
        ri->last_pub_time = mstime();
}",1,1,sentinel.c,sentinelPublishReplyCallback,,false,2839,2852,sentinelPublishReplyCallback,,,150,"void sentinelPublishReplyCallback (redisAsyncContext*,void*,void*)"
356945,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelProcessHelloMessage(char *hello, int hello_len) {
    /* Format is composed of 8 tokens:
     * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,
     * 5=master_ip,6=master_port,7=master_config_epoch. */
    int numtokens, port, removed, master_port;
    uint64_t current_epoch, master_config_epoch;
    char **token = sdssplitlen(hello, hello_len, "","", 1, &numtokens);
    sentinelRedisInstance *si, *master;

    if (numtokens == 8) {
        /* Obtain a reference to the master this hello message is about */
        master = sentinelGetMasterByName(token[4]);
        if (!master) goto cleanup; /* Unknown master, skip the message. */

        /* First, try to see if we already have this sentinel. */
        port = atoi(token[1]);
        master_port = atoi(token[6]);
        si = getSentinelRedisInstanceByAddrAndRunID(
                        master->sentinels,token[0],port,token[2]);
        current_epoch = strtoull(token[3],NULL,10);
        master_config_epoch = strto...",1,30,sentinel.c,sentinelProcessHelloMessage,,false,2859,2971,sentinelProcessHelloMessage,,,151,"void sentinelProcessHelloMessage (char*,int)"
357288,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    redisReply *r;
    UNUSED(c);

    if (!reply || !ri) return;
    r = reply;

    /* Update the last activity in the pubsub channel. Note that since we
     * receive our messages as well this timestamp can be used to detect
     * if the link is probably disconnected even if it seems otherwise. */
    ri->link->pc_last_activity = mstime();

    /* Sanity check in the reply we expect, so that the code that follows
     * can avoid to check for details.
     * Note: Reply type is PUSH in resp3. Normally, sentinel will not use
     * resp3 but this is required for testing (see logreqres.c). */
    if ((r->type != REDIS_REPLY_ARRAY && r->type != REDIS_REPLY_PUSH) ||
        r->elements != 3 ||
        r->element[0]->type != REDIS_REPLY_STRING ||
        r->element[1]->type != REDIS_REPLY_STRING ||
        r->element[2]->type != REDIS_REPLY_STRING ||
     ...",1,4,sentinel.c,sentinelReceiveHelloMessages,,false,2976,3004,sentinelReceiveHelloMessages,,,152,"void sentinelReceiveHelloMessages (redisAsyncContext*,void*,void*)"
357417,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelSendHello(sentinelRedisInstance *ri) {
    char ip[NET_IP_STR_LEN];
    char payload[NET_IP_STR_LEN+1024];
    int retval;
    char *announce_ip;
    int announce_port;
    sentinelRedisInstance *master = (ri->flags & SRI_MASTER) ? ri : ri->master;
    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);

    if (ri->link->disconnected) return C_ERR;

    /* Use the specified announce address if specified, otherwise try to
     * obtain our own IP address. */
    if (sentinel.announce_ip) {
        announce_ip = sentinel.announce_ip;
    } else {
        if (anetFdToString(ri->link->cc->c.fd,ip,sizeof(ip),NULL,0) == -1)
            return C_ERR;
        announce_ip = ip;
    }
    if (sentinel.announce_port) announce_port = sentinel.announce_port;
    else if (server.tls_replication && server.tls_port) announce_port = server.tls_port;
    else announce_port = server.port;

    /* Format and send the Hello message. */
    snprintf(payload,sizeof(payload),
...",1,12,sentinel.c,sentinelSendHello,,false,3017,3057,sentinelSendHello,,,153,int sentinelSendHello (sentinelRedisInstance*)
357602,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetSafeIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->last_pub_time >= (sentinel_publish_period+1))
            ri->last_pub_time -= (sentinel_publish_period+1);
    }
    dictReleaseIterator(di);
}",1,1,sentinel.c,sentinelForceHelloUpdateDictOfRedisInstances,,false,3061,3072,sentinelForceHelloUpdateDictOfRedisInstances,,,154,void sentinelForceHelloUpdateDictOfRedisInstances (dict*)
357644,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {
    if (!(master->flags & SRI_MASTER)) return C_ERR;
    if (master->last_pub_time >= (sentinel_publish_period+1))
        master->last_pub_time -= (sentinel_publish_period+1);
    sentinelForceHelloUpdateDictOfRedisInstances(master->sentinels);
    sentinelForceHelloUpdateDictOfRedisInstances(master->slaves);
    return C_OK;
}",1,26,sentinel.c,sentinelForceHelloUpdateForMaster,,false,3082,3089,sentinelForceHelloUpdateForMaster,,,155,int sentinelForceHelloUpdateForMaster (sentinelRedisInstance*)
357694,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelSendPing(sentinelRedisInstance *ri) {
    int retval = redisAsyncCommand(ri->link->cc,
        sentinelPingReplyCallback, ri, ""%s"",
        sentinelInstanceMapCommand(ri,""PING""));
    if (retval == C_OK) {
        ri->link->pending_commands++;
        ri->link->last_ping_time = mstime();
        /* We update the active ping time only if we received the pong for
         * the previous ping, otherwise we are technically waiting since the
         * first ping that did not receive a reply. */
        if (ri->link->act_ping_time == 0)
            ri->link->act_ping_time = ri->link->last_ping_time;
        return 1;
    } else {
        return 0;
    }
}",1,18,sentinel.c,sentinelSendPing,,false,3096,3112,sentinelSendPing,,,156,int sentinelSendPing (sentinelRedisInstance*)
357760,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {
    mstime_t now = mstime();
    mstime_t info_period, ping_period;
    int retval;

    /* Return ASAP if we have already a PING or INFO already pending, or
     * in the case the instance is not properly connected. */
    if (ri->link->disconnected) return;

    /* For INFO, PING, PUBLISH that are not critical commands to send we
     * also have a limit of SENTINEL_MAX_PENDING_COMMANDS. We don't
     * want to use a lot of memory just because a link is not working
     * properly (note that anyway there is a redundant protection about this,
     * that is, the link will be disconnected and reconnected if a long
     * timeout condition is detected. */
    if (ri->link->pending_commands >=
        SENTINEL_MAX_PENDING_COMMANDS * ri->link->refcount) return;

    /* If this is a slave of a master in O_DOWN condition we start sending
     * it INFO every second, instead of the usual SENTINEL_INFO_PERIOD
     * period. In ...",1,8,sentinel.c,sentinelSendPeriodicCommands,,false,3116,3178,sentinelSendPeriodicCommands,,,157,void sentinelSendPeriodicCommands (sentinelRedisInstance*)
357944,METHOD,sentinel.c:<global>,TYPE_DECL,"static void populateDict(dict *options_dict, char **options) {
    for (int i=0; options[i]; i++) {
        sds option = sdsnew(options[i]);
        if (dictAdd(options_dict, option, NULL)==DICT_ERR)
            sdsfree(option);
    }
}",1,49,sentinel.c,populateDict,,false,3181,3187,populateDict,,,158,"void populateDict (dict*,char**)"
357981,METHOD,sentinel.c:<global>,TYPE_DECL,"const char* getLogLevel(void) {
   switch (server.verbosity) {
    case LL_DEBUG: return ""debug"";
    case LL_VERBOSE: return ""verbose"";
    case LL_NOTICE: return ""notice"";
    case LL_WARNING: return ""warning"";
    case LL_NOTHING: return ""nothing"";
    }
    return ""unknown"";
}",1,9,sentinel.c,getLogLevel,,false,3189,3198,getLogLevel,,,159,const char* getLogLevel (void)
358023,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelConfigSetCommand(client *c) {
    long long numval;
    int drop_conns = 0;
    char *option;
    robj *val;
    char *options[] = {
        ""announce-ip"",
        ""sentinel-user"",
        ""sentinel-pass"",
        ""resolve-hostnames"",
        ""announce-port"",
        ""announce-hostnames"",
        ""loglevel"",
        NULL};
    static dict *options_dict = NULL;
    if (!options_dict) {
        options_dict = dictCreate(&stringSetDictType);
        populateDict(options_dict, options);
    }
    dict *set_configs = dictCreate(&stringSetDictType);

    /* Validate arguments are valid */
    for (int i = 3; i < c->argc; i++) {
        option = c->argv[i]->ptr;

        /* Validate option is valid */
        if (dictFind(options_dict, option) == NULL) {
            addReplyErrorFormat(c, ""Invalid argument '%s' to SENTINEL CONFIG SET"", option);
            goto exit;
        }

        /* Check duplicates */
        if (dictFind(set_configs, option) != NULL) {
            addR...",1,8,sentinel.c,sentinelConfigSetCommand,,false,3201,3325,sentinelConfigSetCommand,,,160,void sentinelConfigSetCommand (client*)
358653,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelConfigGetCommand(client *c) {
    char *pattern;
    void *replylen = addReplyDeferredLen(c);
    int matches = 0;
    /* Create a dictionary to store the input configs,to avoid adding duplicate twice */
    dict *d = dictCreate(&externalStringType);
    for (int i = 3; i < c->argc; i++) {
        pattern = c->argv[i]->ptr;
        /* If the string doesn't contain glob patterns and available in dictionary, don't look further, just continue. */
        if (!strpbrk(pattern, ""[*?"") && dictFind(d, pattern)) continue;
        /* we want to print all the matched patterns and avoid printing duplicates twice */
        if (stringmatch(pattern,""resolve-hostnames"",1) && !dictFind(d, ""resolve-hostnames"")) {
            addReplyBulkCString(c,""resolve-hostnames"");
            addReplyBulkCString(c,sentinel.resolve_hostnames ? ""yes"" : ""no"");
            dictAdd(d, ""resolve-hostnames"", NULL);
            matches++;
        }
        if (stringmatch(pattern, ""announce-hostnames"", 1) &...",1,1,sentinel.c,sentinelConfigGetCommand,,false,3328,3384,sentinelConfigGetCommand,,,161,void sentinelConfigGetCommand (client*)
358908,METHOD,sentinel.c:<global>,TYPE_DECL,"const char *sentinelFailoverStateStr(int state) {
    switch(state) {
    case SENTINEL_FAILOVER_STATE_NONE: return ""none"";
    case SENTINEL_FAILOVER_STATE_WAIT_START: return ""wait_start"";
    case SENTINEL_FAILOVER_STATE_SELECT_SLAVE: return ""select_slave"";
    case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE: return ""send_slaveof_noone"";
    case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION: return ""wait_promotion"";
    case SENTINEL_FAILOVER_STATE_RECONF_SLAVES: return ""reconf_slaves"";
    case SENTINEL_FAILOVER_STATE_UPDATE_CONFIG: return ""update_config"";
    default: return ""unknown"";
    }
}",1,9,sentinel.c,sentinelFailoverStateStr,,false,3386,3397,sentinelFailoverStateStr,,,162,const char* sentinelFailoverStateStr (int)
358961,METHOD,sentinel.c:<global>,TYPE_DECL,"void addReplySentinelRedisInstance(client *c, sentinelRedisInstance *ri) {
    char *flags = sdsempty();
    void *mbl;
    int fields = 0;

    mbl = addReplyDeferredLen(c);

    addReplyBulkCString(c,""name"");
    addReplyBulkCString(c,ri->name);
    fields++;

    addReplyBulkCString(c,""ip"");
    addReplyBulkCString(c,announceSentinelAddr(ri->addr));
    fields++;

    addReplyBulkCString(c,""port"");
    addReplyBulkLongLong(c,ri->addr->port);
    fields++;

    addReplyBulkCString(c,""runid"");
    addReplyBulkCString(c,ri->runid ? ri->runid : """");
    fields++;

    addReplyBulkCString(c,""flags"");
    if (ri->flags & SRI_S_DOWN) flags = sdscat(flags,""s_down,"");
    if (ri->flags & SRI_O_DOWN) flags = sdscat(flags,""o_down,"");
    if (ri->flags & SRI_MASTER) flags = sdscat(flags,""master,"");
    if (ri->flags & SRI_SLAVE) flags = sdscat(flags,""slave,"");
    if (ri->flags & SRI_SENTINEL) flags = sdscat(flags,""sentinel,"");
    if (ri->link->disconnected) flags = sdscat(flags,""disconnect...",1,20,sentinel.c,addReplySentinelRedisInstance,,false,3400,3595,addReplySentinelRedisInstance,,,163,"void addReplySentinelRedisInstance (client*,sentinelRedisInstance*)"
359783,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelSetDebugConfigParameters(client *c){
    int j;
    int badarg = 0; /* Bad argument position for error reporting. */
    char *option;

    /* Process option - value pairs. */
    for (j = 2; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        option = c->argv[j]->ptr;
        long long ll;

        if (!strcasecmp(option,""info-period"") && moreargs > 0) {
            /* info-period <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            sentinel_info_period = ll;

        } else if (!strcasecmp(option,""ping-period"") && moreargs > 0) {
            /* ping-period <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            sentinel_ping_period = ll;

        } else if ...",1,48,sentinel.c,sentinelSetDebugConfigParameters,,false,3597,3740,sentinelSetDebugConfigParameters,,,164,void sentinelSetDebugConfigParameters (client*)
360412,METHOD,sentinel.c:<global>,TYPE_DECL,"void addReplySentinelDebugInfo(client *c) {
    void *mbl;
    int fields = 0;

    mbl = addReplyDeferredLen(c);

    addReplyBulkCString(c,""INFO-PERIOD"");
    addReplyBulkLongLong(c,sentinel_info_period);
    fields++;

    addReplyBulkCString(c,""PING-PERIOD"");
    addReplyBulkLongLong(c,sentinel_ping_period);
    fields++;

    addReplyBulkCString(c,""ASK-PERIOD"");
    addReplyBulkLongLong(c,sentinel_ask_period);
    fields++;

    addReplyBulkCString(c,""PUBLISH-PERIOD"");
    addReplyBulkLongLong(c,sentinel_publish_period);
    fields++;

    addReplyBulkCString(c,""DEFAULT-DOWN-AFTER"");
    addReplyBulkLongLong(c,sentinel_default_down_after);
    fields++;

    addReplyBulkCString(c,""DEFAULT-FAILOVER-TIMEOUT"");
    addReplyBulkLongLong(c,sentinel_default_failover_timeout);
    fields++;

    addReplyBulkCString(c,""TILT-TRIGGER"");
    addReplyBulkLongLong(c,sentinel_tilt_trigger);
    fields++;

    addReplyBulkCString(c,""TILT-PERIOD"");
    addReplyBulkLongLong(c,sentinel_tilt_peri...",1,1,sentinel.c,addReplySentinelDebugInfo,,false,3742,3801,addReplySentinelDebugInfo,,,165,void addReplySentinelDebugInfo (client*)
360534,METHOD,sentinel.c:<global>,TYPE_DECL,"void addReplyDictOfRedisInstances(client *c, dict *instances) {
    dictIterator *di;
    dictEntry *de;
    long slaves = 0;
    void *replylen = addReplyDeferredLen(c);

    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        /* don't announce unannounced replicas */
        if (ri->flags & SRI_SLAVE && !ri->replica_announced) continue;
        addReplySentinelRedisInstance(c,ri);
        slaves++;
    }
    dictReleaseIterator(di);
    setDeferredArrayLen(c, replylen, slaves);
}",1,24,sentinel.c,addReplyDictOfRedisInstances,,false,3805,3822,addReplyDictOfRedisInstances,,,166,"void addReplyDictOfRedisInstances (client*,dict*)"
360596,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(client *c,
                        robj *name)
{
    sentinelRedisInstance *ri;

    ri = dictFetchValue(sentinel.masters,name->ptr);
    if (!ri) {
        addReplyError(c,""No such master with that name"");
        return NULL;
    }
    return ri;
}",1,1,sentinel.c,sentinelGetMasterByNameOrReplyError,,false,3827,3838,sentinelGetMasterByNameOrReplyError,,,167,"sentinelRedisInstance sentinelGetMasterByNameOrReplyError (client*,robj*)"
360623,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {
    dictIterator *di;
    dictEntry *de;
    int usable = 1; /* Number of usable Sentinels. Init to 1 to count myself. */
    int result = SENTINEL_ISQR_OK;
    int voters = dictSize(master->sentinels)+1; /* Known Sentinels + myself. */

    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        if (ri->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        usable++;
    }
    dictReleaseIterator(di);

    if (usable < (int)master->quorum) result |= SENTINEL_ISQR_NOQUORUM;
    if (usable < voters/2+1) result |= SENTINEL_ISQR_NOAUTH;
    if (usableptr) *usableptr = usable;
    return result;
}",1,17,sentinel.c,sentinelIsQuorumReachable,,false,3843,3863,sentinelIsQuorumReachable,,,168,"int sentinelIsQuorumReachable (sentinelRedisInstance*,int*)"
360748,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""CKQUORUM <master-name>"",
""    Check if the current Sentinel configuration is able to reach the quorum"",
""    needed to failover a master and the majority needed to authorize the"",
""    failover."",
""CONFIG SET param value [param value ...]"",
""    Set a global Sentinel configuration parameter."",
""CONFIG GET <param> [param param param ...]"",
""    Get global Sentinel configuration parameter."",
""DEBUG [<param> <value> ...]"",
""    Show a list of configurable time parameters and their values (milliseconds)."",
""    Or update current configurable parameters values (one or more)."",
""GET-MASTER-ADDR-BY-NAME <master-name>"",
""    Return the ip and port number of the master with that name."",
""FAILOVER <master-name>"",
""    Manually failover a master node without asking for agreement from other"",
""    Sentinels"",
""FLUSHCONFIG"",
""    Force Sentinel to rewrite its configura...",1,44,sentinel.c,sentinelCommand,,false,3865,4241,sentinelCommand,,,169,void sentinelCommand (client*)
362296,METHOD,sentinel.c:<global>,TYPE_DECL,"void addInfoSectionsToDict(dict *section_dict, char **sections);",6,63,sentinel.c,addInfoSectionsToDict,,false,4243,4243,addInfoSectionsToDict,,,170,"void addInfoSectionsToDict (dict*,char**)"
362302,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelInfoCommand(client *c) {
    char *sentinel_sections[] = {""server"", ""clients"", ""cpu"", ""stats"", ""sentinel"", NULL};
    int sec_all = 0, sec_everything = 0;
    static dict *cached_all_info_sections = NULL;

    /* Get requested section list. */
    dict *sections_dict = genInfoSectionDict(c->argv+1, c->argc-1, sentinel_sections, &sec_all, &sec_everything);

    /* Purge unsupported sections from the requested ones. */
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(sections_dict);
    while((de = dictNext(di)) != NULL) {
        int i;
        sds sec = dictGetKey(de);
        for (i=0; sentinel_sections[i]; i++)
            if (!strcasecmp(sentinel_sections[i], sec))
                break;
        /* section not found? remove it */
        if (!sentinel_sections[i])
            dictDelete(sections_dict, sec);
    }
    dictReleaseIterator(di);

    /* Insert explicit all sections (don't pass these vars to genRedisInfoString) */
    if (sec_all || sec_every...",1,12,sentinel.c,sentinelInfoCommand,,false,4246,4323,sentinelInfoCommand,,,171,void sentinelInfoCommand (client*)
362638,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelRoleCommand(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c,2);
    addReplyBulkCBuffer(c,""sentinel"",8);
    addReplyArrayLen(c,dictSize(sentinel.masters));

    di = dictGetIterator(sentinel.masters);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        addReplyBulkCString(c,ri->name);
    }
    dictReleaseIterator(di);
}",1,23,sentinel.c,sentinelRoleCommand,,false,4327,4342,sentinelRoleCommand,,,172,void sentinelRoleCommand (client*)
362700,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelSetCommand(client *c) {
    sentinelRedisInstance *ri;
    int j, changes = 0;
    int badarg = 0; /* Bad argument position for error reporting. */
    char *option;
    int redacted;

    if ((ri = sentinelGetMasterByNameOrReplyError(c,c->argv[2]))
        == NULL) return;

    /* Process option - value pairs. */
    for (j = 3; j < c->argc; j++) {
        int moreargs = (c->argc-1) - j;
        option = c->argv[j]->ptr;
        long long ll;
        int old_j = j; /* Used to know what to log as an event. */
        redacted = 0;

        if (!strcasecmp(option,""down-after-milliseconds"") && moreargs > 0) {
            /* down-after-milliseconds <milliseconds> */
            robj *o = c->argv[++j];
            if (getLongLongFromObject(o,&ll) == C_ERR || ll <= 0) {
                badarg = j;
                goto badfmt;
            }
            ri->down_after_period = ll;
            sentinelPropagateDownAfterPeriod(ri);
            changes++;
        } else if (!strc...",1,48,sentinel.c,sentinelSetCommand,,false,4345,4517,sentinelSetCommand,,,173,void sentinelSetCommand (client*)
363437,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelPublishCommand(client *c) {
    if (strcmp(c->argv[1]->ptr,SENTINEL_HELLO_CHANNEL)) {
        addReplyError(c, ""Only HELLO messages are accepted by Sentinel instances."");
        return;
    }
    sentinelProcessHelloMessage(c->argv[2]->ptr,sdslen(c->argv[2]->ptr));
    addReplyLongLong(c,1);
}",1,31,sentinel.c,sentinelPublishCommand,,false,4525,4532,sentinelPublishCommand,,,174,void sentinelPublishCommand (client*)
363478,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
    mstime_t elapsed = 0;

    if (ri->link->act_ping_time)
        elapsed = mstime() - ri->link->act_ping_time;
    else if (ri->link->disconnected)
        elapsed = mstime() - ri->link->last_avail_time;

    /* Check if we are in need for a reconnection of one of the
     * links, because we are detecting low activity.
     *
     * 1) Check if the command link seems connected, was connected not less
     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a
     *    pending ping for more than half the timeout. */
    if (ri->link->cc &&
        (mstime() - ri->link->cc_conn_time) >
        sentinel_min_link_reconnect_period &&
        ri->link->act_ping_time != 0 && /* There is a pending ping... */
        /* The pending ping is delayed, and we did not receive
         * error replies as well. */
        (mstime() - ri->link->act_ping_time) > (ri->down_after_period/2) &&
        (mstime() - ri->link->l...",1,21,sentinel.c,sentinelCheckSubjectivelyDown,,false,4537,4603,sentinelCheckSubjectivelyDown,,,175,void sentinelCheckSubjectivelyDown (sentinelRedisInstance*)
363752,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    unsigned int quorum = 0, odown = 0;

    if (master->flags & SRI_S_DOWN) {
        /* Is down for enough sentinels? */
        quorum = 1; /* the current sentinel. */
        /* Count all the other sentinels. */
        di = dictGetIterator(master->sentinels);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);

            if (ri->flags & SRI_MASTER_DOWN) quorum++;
        }
        dictReleaseIterator(di);
        if (quorum >= master->quorum) odown = 1;
    }

    /* Set the flag accordingly to the outcome. */
    if (odown) {
        if ((master->flags & SRI_O_DOWN) == 0) {
            sentinelEvent(LL_WARNING,""+odown"",master,""%@ #quorum %d/%d"",
                quorum, master->quorum);
            master->flags |= SRI_O_DOWN;
            master->o_down_since_time = mstime();
        }
    } else {
        if (master->fla...",1,24,sentinel.c,sentinelCheckObjectivelyDown,,false,4611,4644,sentinelCheckObjectivelyDown,,,176,void sentinelCheckObjectivelyDown (sentinelRedisInstance*)
363896,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {
    sentinelRedisInstance *ri = privdata;
    instanceLink *link = c->data;
    redisReply *r;

    if (!reply || !link) return;
    link->pending_commands--;
    r = reply;

    /* Ignore every error or unexpected reply.
     * Note that if the command returns an error for any reason we'll
     * end clearing the SRI_MASTER_DOWN flag for timeout anyway. */
    if (r->type == REDIS_REPLY_ARRAY && r->elements == 3 &&
        r->element[0]->type == REDIS_REPLY_INTEGER &&
        r->element[1]->type == REDIS_REPLY_STRING &&
        r->element[2]->type == REDIS_REPLY_INTEGER)
    {
        ri->last_master_down_reply_time = mstime();
        if (r->element[0]->integer == 1) {
            ri->flags |= SRI_MASTER_DOWN;
        } else {
            ri->flags &= ~SRI_MASTER_DOWN;
        }
        if (strcmp(r->element[1]->str,""*"")) {
            /* If the runid in the reply is not ""*"" the Sentinel act...",1,25,sentinel.c,sentinelReceiveIsMasterDownReply,,false,4648,4684,sentinelReceiveIsMasterDownReply,,,177,"void sentinelReceiveIsMasterDownReply (redisAsyncContext*,void*,void*)"
364099,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {
    dictIterator *di;
    dictEntry *de;

    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        mstime_t elapsed = mstime() - ri->last_master_down_reply_time;
        char port[32];
        int retval;

        /* If the master state from other sentinel is too old, we clear it. */
        if (elapsed > sentinel_ask_period*5) {
            ri->flags &= ~SRI_MASTER_DOWN;
            sdsfree(ri->leader);
            ri->leader = NULL;
        }

        /* Only ask if master is down to other sentinels if:
         *
         * 1) We believe it is down, or there is a failover in progress.
         * 2) Sentinel is connected.
         * 3) We did not receive the info within SENTINEL_ASK_PERIOD ms. */
        if ((master->flags & SRI_S_DOWN) == 0) continue;
        if (ri->link->disconnected) continue;
        i...",1,26,sentinel.c,sentinelAskMasterStateToOtherSentinels,,false,4691,4733,sentinelAskMasterStateToOtherSentinels,,,178,"void sentinelAskMasterStateToOtherSentinels (sentinelRedisInstance*,int)"
364261,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelSimFailureCrash(void) {
    serverLog(LL_WARNING,
        ""Sentinel CRASH because of SENTINEL simulate-failure"");
    exit(99);
}",1,4,sentinel.c,sentinelSimFailureCrash,,false,4738,4742,sentinelSimFailureCrash,,,179,void sentinelSimFailureCrash (void)
364286,METHOD,sentinel.c:<global>,TYPE_DECL,"char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {
    if (req_epoch > sentinel.current_epoch) {
        sentinel.current_epoch = req_epoch;
        sentinelFlushConfig();
        sentinelEvent(LL_WARNING,""+new-epoch"",master,""%llu"",
            (unsigned long long) sentinel.current_epoch);
    }

    if (master->leader_epoch < req_epoch && sentinel.current_epoch <= req_epoch)
    {
        sdsfree(master->leader);
        master->leader = sdsnew(req_runid);
        master->leader_epoch = sentinel.current_epoch;
        sentinelFlushConfig();
        sentinelEvent(LL_WARNING,""+vote-for-leader"",master,""%s %llu"",
            master->leader, (unsigned long long) master->leader_epoch);
        /* If we did not voted for ourselves, set the master failover start
         * time to now, in order to force a delay before we can start a
         * failover for the same master. */
        if (strcasecmp(master->leader,sentinel....",1,22,sentinel.c,sentinelVoteLeader,,false,4749,4774,sentinelVoteLeader,,,180,"char* sentinelVoteLeader (sentinelRedisInstance*,uint64_t,char*,uint64_t*)"
364404,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelLeaderIncr(dict *counters, char *runid) {
    dictEntry *existing, *de;
    uint64_t oldval;

    de = dictAddRaw(counters,runid,&existing);
    if (existing) {
        oldval = dictGetUnsignedIntegerVal(existing);
        dictSetUnsignedIntegerVal(existing,oldval+1);
        return oldval+1;
    } else {
        serverAssert(de != NULL);
        dictSetUnsignedIntegerVal(de,1);
        return 1;
    }
}",1,8,sentinel.c,sentinelLeaderIncr,,false,4783,4797,sentinelLeaderIncr,,,182,"int sentinelLeaderIncr (dict*,char*)"
364459,METHOD,sentinel.c:<global>,TYPE_DECL,"char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {
    dict *counters;
    dictIterator *di;
    dictEntry *de;
    unsigned int voters = 0, voters_quorum;
    char *myvote;
    char *winner = NULL;
    uint64_t leader_epoch;
    uint64_t max_votes = 0;

    serverAssert(master->flags & (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS));
    counters = dictCreate(&leaderVotesDictType);

    voters = dictSize(master->sentinels)+1; /* All the other sentinels and me.*/

    /* Count other sentinels votes */
    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->leader != NULL && ri->leader_epoch == sentinel.current_epoch)
            sentinelLeaderIncr(counters,ri->leader);
    }
    dictReleaseIterator(di);

    /* Check what's the winner. For the winner to win, it needs two conditions:
     * 1) Absolute majority between voters (50% + 1).
     * 2) And anyway at least master->...",1,4,sentinel.c,sentinelGetLeader,,false,4805,4868,sentinelGetLeader,,,183,"char* sentinelGetLeader (sentinelRedisInstance*,uint64_t)"
364691,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelSendSlaveOf(sentinelRedisInstance *ri, const sentinelAddr *addr) {
    char portstr[32];
    const char *host;
    int retval;

    /* If host is NULL we send SLAVEOF NO ONE that will turn the instance
    * into a master. */
    if (!addr) {
        host = ""NO"";
        memcpy(portstr,""ONE"",4);
    } else {
        host = announceSentinelAddr(addr);
        ll2string(portstr,sizeof(portstr),addr->port);
    }

    /* In order to send SLAVEOF in a safe way, we send a transaction performing
     * the following tasks:
     * 1) Reconfigure the instance according to the specified host/port params.
     * 2) Rewrite the configuration.
     * 3) Disconnect all clients (but this one sending the command) in order
     *    to trigger the ask-master-on-reconnection protocol for connected
     *    clients.
     *
     * Note that we don't check the replies returned by commands, since we
     * will observe instead the effects in the next INFO output. */
    retval = redisAsyncC...",1,18,sentinel.c,sentinelSendSlaveOf,,false,4880,4945,sentinelSendSlaveOf,,,184,"int sentinelSendSlaveOf (sentinelRedisInstance*,sentinelAddr*)"
364898,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelStartFailover(sentinelRedisInstance *master) {
    serverAssert(master->flags & SRI_MASTER);

    master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
    master->flags |= SRI_FAILOVER_IN_PROGRESS;
    master->failover_epoch = ++sentinel.current_epoch;
    sentinelEvent(LL_WARNING,""+new-epoch"",master,""%llu"",
        (unsigned long long) sentinel.current_epoch);
    sentinelEvent(LL_WARNING,""+try-failover"",master,""%@"");
    master->failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;
    master->failover_state_change_time = mstime();
}",1,4,sentinel.c,sentinelStartFailover,,false,4948,4959,sentinelStartFailover,,,185,void sentinelStartFailover (sentinelRedisInstance*)
364982,METHOD,sentinel.c:<global>,TYPE_DECL,"int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
    /* We can't failover if the master is not in O_DOWN state. */
    if (!(master->flags & SRI_O_DOWN)) return 0;

    /* Failover already in progress? */
    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return 0;

    /* Last failover attempt started too little time ago? */
    if (mstime() - master->failover_start_time <
        master->failover_timeout*2)
    {
        if (master->failover_delay_logged != master->failover_start_time) {
            time_t clock = (master->failover_start_time +
                            master->failover_timeout*2) / 1000;
            char ctimebuf[26];

            ctime_r(&clock,ctimebuf);
            ctimebuf[24] = '\0'; /* Remove newline. */
            master->failover_delay_logged = master->failover_start_time;
            serverLog(LL_NOTICE,
                ""Next failover delay: I will not start a failover before %s"",
                ctimebuf);
        }
        return 0;...",1,26,sentinel.c,sentinelStartFailoverIfNeeded,,false,4972,5000,sentinelStartFailoverIfNeeded,,,186,int sentinelStartFailoverIfNeeded (sentinelRedisInstance*)
365092,METHOD,sentinel.c:<global>,TYPE_DECL,"int compareSlavesForPromotion(const void *a, const void *b) {
    sentinelRedisInstance **sa = (sentinelRedisInstance **)a,
                          **sb = (sentinelRedisInstance **)b;
    char *sa_runid, *sb_runid;

    if ((*sa)->slave_priority != (*sb)->slave_priority)
        return (*sa)->slave_priority - (*sb)->slave_priority;

    /* If priority is the same, select the slave with greater replication
     * offset (processed more data from the master). */
    if ((*sa)->slave_repl_offset > (*sb)->slave_repl_offset) {
        return -1; /* a < b */
    } else if ((*sa)->slave_repl_offset < (*sb)->slave_repl_offset) {
        return 1; /* a > b */
    }

    /* If the replication offset is the same select the slave with that has
     * the lexicographically smaller runid. Note that we try to handle runid
     * == NULL as there are old Redis versions that don't publish runid in
     * INFO. A NULL runid is considered bigger than any other runid. */
    sa_runid = (*sa)->runid;
...",1,1,sentinel.c,compareSlavesForPromotion,,false,5034,5060,compareSlavesForPromotion,,,187,"int compareSlavesForPromotion (void*,void*)"
365208,METHOD,sentinel.c:<global>,TYPE_DECL,"sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance **instance =
        zmalloc(sizeof(instance[0])*dictSize(master->slaves));
    sentinelRedisInstance *selected = NULL;
    int instances = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t max_master_down_time = 0;

    if (master->flags & SRI_S_DOWN)
        max_master_down_time += mstime() - master->s_down_since_time;
    max_master_down_time += master->down_after_period * 10;

    di = dictGetIterator(master->slaves);

    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);
        mstime_t info_validity_time;

        if (slave->flags & (SRI_S_DOWN|SRI_O_DOWN)) continue;
        if (slave->link->disconnected) continue;
        if (mstime() - slave->link->last_avail_time > sentinel_ping_period*5) continue;
        if (slave->slave_priority == 0) continue;

        /* If the master is in SDOWN state we get INFO for slaves every secon...",1,36,sentinel.c,sentinelSelectSlave,,false,5062,5105,sentinelSelectSlave,,,188,sentinelRedisInstance sentinelSelectSlave (sentinelRedisInstance*)
365416,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
    char *leader;
    int isleader;

    /* Check if we are the leader for the failover epoch. */
    leader = sentinelGetLeader(ri, ri->failover_epoch);
    isleader = leader && strcasecmp(leader,sentinel.myid) == 0;
    sdsfree(leader);

    /* If I'm not the leader, and it is not a forced failover via
     * SENTINEL FAILOVER, then I can't continue with the failover. */
    if (!isleader && !(ri->flags & SRI_FORCE_FAILOVER)) {
        mstime_t election_timeout = sentinel_election_timeout;

        /* The election timeout is the MIN between SENTINEL_ELECTION_TIMEOUT
         * and the configured failover timeout. */
        if (election_timeout > ri->failover_timeout)
            election_timeout = ri->failover_timeout;
        /* Abort the failover if I'm not the leader after some time. */
        if (mstime() - ri->failover_start_time > election_timeout) {
            sentinelEvent(LL_WARNING,""-failover-abort-not-electe...",1,35,sentinel.c,sentinelFailoverWaitStart,,false,5108,5139,sentinelFailoverWaitStart,,,189,void sentinelFailoverWaitStart (sentinelRedisInstance*)
365531,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {
    sentinelRedisInstance *slave = sentinelSelectSlave(ri);

    /* We don't handle the timeout in this state as the function aborts
     * the failover or go forward in the next state. */
    if (slave == NULL) {
        sentinelEvent(LL_WARNING,""-failover-abort-no-good-slave"",ri,""%@"");
        sentinelAbortFailover(ri);
    } else {
        sentinelEvent(LL_WARNING,""+selected-slave"",slave,""%@"");
        slave->flags |= SRI_PROMOTED;
        ri->promoted_slave = slave;
        ri->failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
        ri->failover_state_change_time = mstime();
        sentinelEvent(LL_NOTICE,""+failover-state-send-slaveof-noone"",
            slave, ""%@"");
    }
}",1,22,sentinel.c,sentinelFailoverSelectSlave,,false,5141,5158,sentinelFailoverSelectSlave,,,190,void sentinelFailoverSelectSlave (sentinelRedisInstance*)
365597,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {
    int retval;

    /* We can't send the command to the promoted slave if it is now
     * disconnected. Retry again and again with this state until the timeout
     * is reached, then abort the failover. */
    if (ri->promoted_slave->link->disconnected) {
        if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
            sentinelEvent(LL_WARNING,""-failover-abort-slave-timeout"",ri,""%@"");
            sentinelAbortFailover(ri);
        }
        return;
    }

    /* Send SLAVEOF NO ONE command to turn the slave into a master.
     * We actually register a generic callback for this command as we don't
     * really care about the reply. We check if it worked indirectly observing
     * if INFO returns a different role (master instead of slave). */
    retval = sentinelSendSlaveOf(ri->promoted_slave,NULL);
    if (retval != C_OK) return;
    sentinelEvent(LL_NOTICE, ""+failover-state-wait-promo...",1,26,sentinel.c,sentinelFailoverSendSlaveOfNoOne,,false,5160,5184,sentinelFailoverSendSlaveOfNoOne,,,191,void sentinelFailoverSendSlaveOfNoOne (sentinelRedisInstance*)
365669,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
    /* Just handle the timeout. Switching to the next state is handled
     * by the function parsing the INFO command of the promoted slave. */
    if (mstime() - ri->failover_state_change_time > ri->failover_timeout) {
        sentinelEvent(LL_WARNING,""-failover-abort-slave-timeout"",ri,""%@"");
        sentinelAbortFailover(ri);
    }
}",1,22,sentinel.c,sentinelFailoverWaitPromotion,,false,5188,5195,sentinelFailoverWaitPromotion,,,192,void sentinelFailoverWaitPromotion (sentinelRedisInstance*)
365694,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {
    int not_reconfigured = 0, timeout = 0;
    dictIterator *di;
    dictEntry *de;
    mstime_t elapsed = mstime() - master->failover_state_change_time;

    /* We can't consider failover finished if the promoted slave is
     * not reachable. */
    if (master->promoted_slave == NULL ||
        master->promoted_slave->flags & SRI_S_DOWN) return;

    /* The failover terminates once all the reachable slaves are properly
     * configured. */
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;
        if (slave->flags & SRI_S_DOWN) continue;
        not_reconfigured++;
    }
    dictReleaseIterator(di);

    /* Force end of failover on timeout. */
    if (elapsed > master->failover_timeout) {
        not_reconfigured = 0;
        timeout = 1;
        sentinelEvent(LL...",1,40,sentinel.c,sentinelFailoverDetectEnd,,false,5197,5256,sentinelFailoverDetectEnd,,,193,void sentinelFailoverDetectEnd (sentinelRedisInstance*)
365925,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int in_progress = 0;

    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & (SRI_RECONF_SENT|SRI_RECONF_INPROG))
            in_progress++;
    }
    dictReleaseIterator(di);

    di = dictGetIterator(master->slaves);
    while(in_progress < master->parallel_syncs &&
          (de = dictNext(di)) != NULL)
    {
        sentinelRedisInstance *slave = dictGetVal(de);
        int retval;

        /* Skip the promoted slave, and already configured slaves. */
        if (slave->flags & (SRI_PROMOTED|SRI_RECONF_DONE)) continue;

        /* If too much time elapsed without the slave moving forward to
         * the next state, consider it reconfigured even if it is not.
         * Sentinels will detect the slave as misconfigured and fix its
         * configuration l...",1,28,sentinel.c,sentinelFailoverReconfNextSlave,,false,5260,5315,sentinelFailoverReconfNextSlave,,,194,void sentinelFailoverReconfNextSlave (sentinelRedisInstance*)
366134,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance *ref = master->promoted_slave ?
                                 master->promoted_slave : master;

    sentinelEvent(LL_WARNING,""+switch-master"",master,""%s %s %d %s %d"",
        master->name, announceSentinelAddr(master->addr), master->addr->port,
        announceSentinelAddr(ref->addr), ref->addr->port);

    sentinelResetMasterAndChangeAddress(master,ref->addr->hostname,ref->addr->port);
}",1,18,sentinel.c,sentinelFailoverSwitchToPromotedSlave,,false,5320,5329,sentinelFailoverSwitchToPromotedSlave,,,195,void sentinelFailoverSwitchToPromotedSlave (sentinelRedisInstance*)
366190,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;

    switch(ri->failover_state) {
        case SENTINEL_FAILOVER_STATE_WAIT_START:
            sentinelFailoverWaitStart(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
            sentinelFailoverSelectSlave(ri);
            break;
        case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
            sentinelFailoverSendSlaveOfNoOne(ri);
            break;
        case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
            sentinelFailoverWaitPromotion(ri);
            break;
        case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
            sentinelFailoverReconfNextSlave(ri);
            break;
    }
}",1,4,sentinel.c,sentinelFailoverStateMachine,,false,5331,5353,sentinelFailoverStateMachine,,,196,void sentinelFailoverStateMachine (sentinelRedisInstance*)
366268,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelAbortFailover(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_FAILOVER_IN_PROGRESS);
    serverAssert(ri->failover_state <= SENTINEL_FAILOVER_STATE_WAIT_PROMOTION);

    ri->flags &= ~(SRI_FAILOVER_IN_PROGRESS|SRI_FORCE_FAILOVER);
    ri->failover_state = SENTINEL_FAILOVER_STATE_NONE;
    ri->failover_state_change_time = mstime();
    if (ri->promoted_slave) {
        ri->promoted_slave->flags &= ~SRI_PROMOTED;
        ri->promoted_slave = NULL;
    }
}",1,4,sentinel.c,sentinelAbortFailover,,false,5360,5371,sentinelAbortFailover,,,197,void sentinelAbortFailover (sentinelRedisInstance*)
366361,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {
    /* ========== MONITORING HALF ============ */
    /* Every kind of instance */
    sentinelReconnectInstance(ri);
    sentinelSendPeriodicCommands(ri);

    /* ============== ACTING HALF ============= */
    /* We don't proceed with the acting half if we are in TILT mode.
     * TILT happens when we find something odd with the time, like a
     * sudden change in the clock. */
    if (sentinel.tilt) {
        if (mstime()-sentinel.tilt_start_time < sentinel_tilt_period) return;
        sentinel.tilt = 0;
        sentinelEvent(LL_WARNING,""-tilt"",NULL,""#tilt mode exited"");
    }

    /* Every kind of instance */
    sentinelCheckSubjectivelyDown(ri);

    /* Masters and slaves */
    if (ri->flags & (SRI_MASTER|SRI_SLAVE)) {
        /* Nothing so far. */
    }

    /* Only masters */
    if (ri->flags & SRI_MASTER) {
        sentinelCheckObjectivelyDown(ri);
        if (sentinelStartFailoverIfNeeded(ri))
            sen...",1,22,sentinel.c,sentinelHandleRedisInstance,,false,5379,5411,sentinelHandleRedisInstance,,,198,void sentinelHandleRedisInstance (sentinelRedisInstance*)
366447,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelHandleDictOfRedisInstances(dict *instances) {
    dictIterator *di;
    dictEntry *de;
    sentinelRedisInstance *switch_to_promoted = NULL;

    /* There are a number of things we need to perform against every master. */
    di = dictGetIterator(instances);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);

        sentinelHandleRedisInstance(ri);
        if (ri->flags & SRI_MASTER) {
            sentinelHandleDictOfRedisInstances(ri->slaves);
            sentinelHandleDictOfRedisInstances(ri->sentinels);
            if (ri->failover_state == SENTINEL_FAILOVER_STATE_UPDATE_CONFIG) {
                switch_to_promoted = ri;
            }
        }
    }
    if (switch_to_promoted)
        sentinelFailoverSwitchToPromotedSlave(switch_to_promoted);
    dictReleaseIterator(di);
}",1,24,sentinel.c,sentinelHandleDictOfRedisInstances,,false,5415,5437,sentinelHandleDictOfRedisInstances,,,199,void sentinelHandleDictOfRedisInstances (dict*)
366515,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelCheckTiltCondition(void) {
    mstime_t now = mstime();
    mstime_t delta = now - sentinel.previous_time;

    if (delta < 0 || delta > sentinel_tilt_trigger) {
        sentinel.tilt = 1;
        sentinel.tilt_start_time = mstime();
        sentinelEvent(LL_WARNING,""+tilt"",NULL,""#tilt mode entered"");
    }
    sentinel.previous_time = mstime();
}",1,22,sentinel.c,sentinelCheckTiltCondition,,false,5458,5468,sentinelCheckTiltCondition,,,200,void sentinelCheckTiltCondition (void)
366563,METHOD,sentinel.c:<global>,TYPE_DECL,"void sentinelTimer(void) {
    sentinelCheckTiltCondition();
    sentinelHandleDictOfRedisInstances(sentinel.masters);
    sentinelRunPendingScripts();
    sentinelCollectTerminatedScripts();
    sentinelKillTimedoutScripts();

    /* We continuously change the frequency of the Redis ""timer interrupt""
     * in order to desynchronize every Sentinel from every other.
     * This non-determinism avoids that Sentinels started at the same time
     * exactly continue to stay synchronized asking to be voted at the
     * same time again and again (resulting in nobody likely winning the
     * election because of split brain voting). */
    server.hz = CONFIG_DEFAULT_HZ + rand() % CONFIG_DEFAULT_HZ;
}",1,16,sentinel.c,sentinelTimer,,false,5470,5484,sentinelTimer,,,201,void sentinelTimer (void)
366668,METHOD,server.c:<global>,TYPE_DECL,<global>,1,1,server.c,server.c:<global>,,false,1,7367,<global>,,,1,
366678,METHOD,server.c:<global>,TYPE_DECL,static inline int isShutdownInitiated(void);,19,43,server.c,isShutdownInitiated,,false,89,89,isShutdownInitiated,,,9,int isShutdownInitiated (void)
366683,METHOD,server.c:<global>,TYPE_DECL,int isReadyToShutdown(void);,5,27,server.c,isReadyToShutdown,,false,90,90,isReadyToShutdown,,,10,int isReadyToShutdown (void)
366688,METHOD,server.c:<global>,TYPE_DECL,int finishShutdown(void);,5,24,server.c,finishShutdown,,false,91,91,finishShutdown,,,11,int finishShutdown (void)
366693,METHOD,server.c:<global>,TYPE_DECL,const char *replstateToString(int replstate);,12,44,server.c,replstateToString,,false,92,92,replstateToString,,,12,char* replstateToString (int)
366698,METHOD,server.c:<global>,TYPE_DECL,"void nolocks_localtime(struct tm *tmp, time_t t, time_t tz, int dst);",6,68,server.c,nolocks_localtime,,false,102,102,nolocks_localtime,,,13,"void nolocks_localtime (tm*,time_t,time_t,int)"
366706,METHOD,server.c:<global>,TYPE_DECL,"void serverLogRaw(int level, const char *msg) {
    const int syslogLevelMap[] = { LOG_DEBUG, LOG_INFO, LOG_NOTICE, LOG_WARNING };
    const char *c = "".-*#"";
    FILE *fp;
    char buf[64];
    int rawmode = (level & LL_RAW);
    int log_to_stdout = server.logfile[0] == '\0';

    level &= 0xff; /* clear flags */
    if (level < server.verbosity) return;

    fp = log_to_stdout ? stdout : fopen(server.logfile,""a"");
    if (!fp) return;

    if (rawmode) {
        fprintf(fp,""%s"",msg);
    } else {
        int off;
        struct timeval tv;
        int role_char;
        pid_t pid = getpid();

        gettimeofday(&tv,NULL);
        struct tm tm;
        nolocks_localtime(&tm,tv.tv_sec,server.timezone,server.daylight_active);
        off = strftime(buf,sizeof(buf),""%d %b %Y %H:%M:%S."",&tm);
        snprintf(buf+off,sizeof(buf)-off,""%03d"",(int)tv.tv_usec/1000);
        if (server.sentinel_mode) {
            role_char = 'X'; /* Sentinel. */
        } else if (pid != server.pid) {
  ...",1,27,server.c,serverLogRaw,,false,106,147,serverLogRaw,,,14,"void serverLogRaw (int,char*)"
366891,METHOD,server.c:<global>,TYPE_DECL,"void _serverLog(int level, const char *fmt, ...) {
    va_list ap;
    char msg[LOG_MAX_LEN];

    va_start(ap, fmt);
    vsnprintf(msg, sizeof(msg), fmt, ap);
    va_end(ap);

    serverLogRaw(level,msg);
}",1,13,server.c,_serverLog,,false,152,161,_serverLog,,,15,"void _serverLog (int,char*...)"
366913,METHOD,server.c:<global>,TYPE_DECL,"void serverLogFromHandler(int level, const char *msg) {
    int fd;
    int log_to_stdout = server.logfile[0] == '\0';
    char buf[64];

    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))
        return;
    fd = log_to_stdout ? STDOUT_FILENO :
                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);
    if (fd == -1) return;
    ll2string(buf,sizeof(buf),getpid());
    if (write(fd,buf,strlen(buf)) == -1) goto err;
    if (write(fd,"":signal-handler ("",17) == -1) goto err;
    ll2string(buf,sizeof(buf),time(NULL));
    if (write(fd,buf,strlen(buf)) == -1) goto err;
    if (write(fd,"") "",2) == -1) goto err;
    if (write(fd,msg,strlen(msg)) == -1) goto err;
    if (write(fd,""\n"",1) == -1) goto err;
err:
    if (!log_to_stdout) close(fd);
}",1,1,server.c,serverLogFromHandler,,false,169,189,serverLogFromHandler,,,16,"void serverLogFromHandler (int,char*)"
367050,METHOD,server.c:<global>,TYPE_DECL,"long long ustime(void) {
    struct timeval tv;
    long long ust;

    gettimeofday(&tv, NULL);
    ust = ((long long)tv.tv_sec)*1000000;
    ust += tv.tv_usec;
    return ust;
}",1,1,server.c,ustime,,false,192,200,ustime,,,17,long long ustime (void)
367077,METHOD,server.c:<global>,TYPE_DECL,"mstime_t mstime(void) {
    return ustime()/1000;
}",1,1,server.c,mstime,,false,203,205,mstime,,,18,mstime_t mstime (void)
367086,METHOD,server.c:<global>,TYPE_DECL,"mstime_t commandTimeSnapshot(void) {
    /* When we are in the middle of a command execution, we want to use a
     * reference time that does not change: in that case we just use the
     * cached time, that we update before each call in the call() function.
     * This way we avoid that commands such as RPOPLPUSH or similar, that
     * may re-open the same key multiple times, can invalidate an already
     * open object in a next call, if the next call will see the key expired,
     * while the first did not.
     * This is specifically important in the context of scripts, where we
     * pretend that time freezes. This way a key can expire only the first time
     * it is accessed and not in the middle of the script execution, making
     * propagation to slaves / AOF consistent. See issue #1525 for more info.
     * Note that we cannot use the cached server.mstime because it can change
     * in processEventsWhileBlocked etc. */
    return server.cmd_time_snapshot;
}",1,1,server.c,commandTimeSnapshot,,false,212,227,commandTimeSnapshot,,,19,mstime_t commandTimeSnapshot (void)
367095,METHOD,server.c:<global>,TYPE_DECL,"void exitFromChild(int retcode) {
#ifdef COVERAGE_TEST
    exit(retcode);
#else
    _exit(retcode);
#endif
}",1,1,server.c,exitFromChild,,false,233,239,exitFromChild,,,20,void exitFromChild (int)
367102,METHOD,server.c:<global>,TYPE_DECL,"void dictVanillaFree(dict *d, void *val)
{
    UNUSED(d);
    zfree(val);
}",1,4,server.c,dictVanillaFree,,false,247,251,dictVanillaFree,,,21,"void dictVanillaFree (dict*,void*)"
367116,METHOD,server.c:<global>,TYPE_DECL,"void dictListDestructor(dict *d, void *val)
{
    UNUSED(d);
    listRelease((list*)val);
}",1,4,server.c,dictListDestructor,,false,253,257,dictListDestructor,,,22,"void dictListDestructor (dict*,void*)"
367132,METHOD,server.c:<global>,TYPE_DECL,"int dictSdsKeyCompare(dict *d, const void *key1,
        const void *key2)
{
    int l1,l2;
    UNUSED(d);

    l1 = sdslen((sds)key1);
    l2 = sdslen((sds)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",1,4,server.c,dictSdsKeyCompare,,false,259,269,dictSdsKeyCompare,,,23,"int dictSdsKeyCompare (dict*,void*,void*)"
367173,METHOD,server.c:<global>,TYPE_DECL,"int dictSdsKeyCaseCompare(dict *d, const void *key1,
        const void *key2)
{
    UNUSED(d);
    return strcasecmp(key1, key2) == 0;
}",1,4,server.c,dictSdsKeyCaseCompare,,false,273,278,dictSdsKeyCaseCompare,,,24,"int dictSdsKeyCaseCompare (dict*,void*,void*)"
367192,METHOD,server.c:<global>,TYPE_DECL,"void dictObjectDestructor(dict *d, void *val)
{
    UNUSED(d);
    if (val == NULL) return; /* Lazy freeing will set value to NULL. */
    decrRefCount(val);
}",1,4,server.c,dictObjectDestructor,,false,280,285,dictObjectDestructor,,,25,"void dictObjectDestructor (dict*,void*)"
367212,METHOD,server.c:<global>,TYPE_DECL,"void dictSdsDestructor(dict *d, void *val)
{
    UNUSED(d);
    sdsfree(val);
}",1,4,server.c,dictSdsDestructor,,false,287,291,dictSdsDestructor,,,26,"void dictSdsDestructor (dict*,void*)"
367226,METHOD,server.c:<global>,TYPE_DECL,"void *dictSdsDup(dict *d, const void *key) {
    UNUSED(d);
    return sdsdup((const sds) key);
}",1,4,server.c,dictSdsDup,,false,293,296,dictSdsDup,,,27,"void* dictSdsDup (dict*,void*)"
367243,METHOD,server.c:<global>,TYPE_DECL,"int dictObjKeyCompare(dict *d, const void *key1,
        const void *key2)
{
    const robj *o1 = key1, *o2 = key2;
    return dictSdsKeyCompare(d, o1->ptr,o2->ptr);
}",1,1,server.c,dictObjKeyCompare,,false,298,303,dictObjKeyCompare,,,28,"int dictObjKeyCompare (dict*,void*,void*)"
367267,METHOD,server.c:<global>,TYPE_DECL,"uint64_t dictObjHash(const void *key) {
    const robj *o = key;
    return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
}",1,1,server.c,dictObjHash,,false,305,308,dictObjHash,,,29,uint64_t dictObjHash (void*)
367287,METHOD,server.c:<global>,TYPE_DECL,"uint64_t dictSdsHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, sdslen((char*)key));
}",1,1,server.c,dictSdsHash,,false,310,312,dictSdsHash,,,30,uint64_t dictSdsHash (void*)
367301,METHOD,server.c:<global>,TYPE_DECL,"uint64_t dictSdsCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, sdslen((char*)key));
}",1,1,server.c,dictSdsCaseHash,,false,314,316,dictSdsCaseHash,,,31,uint64_t dictSdsCaseHash (void*)
367315,METHOD,server.c:<global>,TYPE_DECL,"uint64_t dictCStrHash(const void *key) {
    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));
}",1,1,server.c,dictCStrHash,,false,319,321,dictCStrHash,,,32,uint64_t dictCStrHash (void*)
367329,METHOD,server.c:<global>,TYPE_DECL,"uint64_t dictCStrCaseHash(const void *key) {
    return dictGenCaseHashFunction((unsigned char*)key, strlen((char*)key));
}",1,1,server.c,dictCStrCaseHash,,false,324,326,dictCStrCaseHash,,,33,uint64_t dictCStrCaseHash (void*)
367343,METHOD,server.c:<global>,TYPE_DECL,"int dictCStrKeyCompare(dict *d, const void *key1, const void *key2) {
    int l1,l2;
    UNUSED(d);

    l1 = strlen((char*)key1);
    l2 = strlen((char*)key2);
    if (l1 != l2) return 0;
    return memcmp(key1, key2, l1) == 0;
}",1,4,server.c,dictCStrKeyCompare,,false,329,337,dictCStrKeyCompare,,,34,"int dictCStrKeyCompare (dict*,void*,void*)"
367384,METHOD,server.c:<global>,TYPE_DECL,"int dictCStrKeyCaseCompare(dict *d, const void *key1, const void *key2) {
    UNUSED(d);
    return strcasecmp(key1, key2) == 0;
}",1,4,server.c,dictCStrKeyCaseCompare,,false,340,343,dictCStrKeyCaseCompare,,,35,"int dictCStrKeyCaseCompare (dict*,void*,void*)"
367403,METHOD,server.c:<global>,TYPE_DECL,"int dictEncObjKeyCompare(dict *d, const void *key1, const void *key2)
{
    robj *o1 = (robj*) key1, *o2 = (robj*) key2;
    int cmp;

    if (o1->encoding == OBJ_ENCODING_INT &&
        o2->encoding == OBJ_ENCODING_INT)
            return o1->ptr == o2->ptr;

    /* Due to OBJ_STATIC_REFCOUNT, we avoid calling getDecodedObject() without
     * good reasons, because it would incrRefCount() the object, which
     * is invalid. So we check to make sure dictFind() works with static
     * objects as well. */
    if (o1->refcount != OBJ_STATIC_REFCOUNT) o1 = getDecodedObject(o1);
    if (o2->refcount != OBJ_STATIC_REFCOUNT) o2 = getDecodedObject(o2);
    cmp = dictSdsKeyCompare(d,o1->ptr,o2->ptr);
    if (o1->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o1);
    if (o2->refcount != OBJ_STATIC_REFCOUNT) decrRefCount(o2);
    return cmp;
}",1,24,server.c,dictEncObjKeyCompare,,false,345,364,dictEncObjKeyCompare,,,36,"int dictEncObjKeyCompare (dict*,void*,void*)"
367516,METHOD,server.c:<global>,TYPE_DECL,"uint64_t dictEncObjHash(const void *key) {
    robj *o = (robj*) key;

    if (sdsEncodedObject(o)) {
        return dictGenHashFunction(o->ptr, sdslen((sds)o->ptr));
    } else if (o->encoding == OBJ_ENCODING_INT) {
        char buf[32];
        int len;

        len = ll2string(buf,32,(long)o->ptr);
        return dictGenHashFunction((unsigned char*)buf, len);
    } else {
        serverPanic(""Unknown string encoding"");
    }
}",1,8,server.c,dictEncObjHash,,false,366,380,dictEncObjHash,,,37,uint64_t dictEncObjHash (void*)
367593,METHOD,server.c:<global>,TYPE_DECL,"int dictExpandAllowed(size_t moreMem, double usedRatio) {
    if (usedRatio <= HASHTABLE_MAX_LOAD_FACTOR) {
        return !overMaxmemoryAfterAlloc(moreMem);
    } else {
        return 1;
    }
}",1,21,server.c,dictExpandAllowed,,false,388,394,dictExpandAllowed,,,38,"int dictExpandAllowed (size_t,double)"
367614,METHOD,server.c:<global>,TYPE_DECL,"size_t dbDictEntryMetadataSize(dict *d) {
    UNUSED(d);
    /* NOTICE: this also affects overhead_ht_slot_to_keys in getMemoryOverheadData.
     * If we ever add non-cluster related data here, that code must be modified too. */
    return server.cluster_enabled ? sizeof(clusterDictEntryMetadata) : 0;
}",1,4,server.c,dbDictEntryMetadataSize,,false,399,404,dbDictEntryMetadataSize,,,39,size_t dbDictEntryMetadataSize (dict*)
367633,METHOD,server.c:<global>,TYPE_DECL,"size_t dbDictMetadataSize(void) {
    return server.cluster_enabled ? sizeof(clusterDictMetadata) : 0;
}",1,1,server.c,dbDictMetadataSize,,false,409,411,dbDictMetadataSize,,,40,size_t dbDictMetadataSize (void)
367646,METHOD,server.c:<global>,TYPE_DECL,"void dbDictAfterReplaceEntry(dict *d, dictEntry *de) {
    if (server.cluster_enabled) slotToKeyReplaceEntry(d, de);
}",1,1,server.c,dbDictAfterReplaceEntry,,false,413,415,dbDictAfterReplaceEntry,,,41,"void dbDictAfterReplaceEntry (dict*,dictEntry*)"
367843,METHOD,server.c:<global>,TYPE_DECL,"int htNeedsResize(dict *dict) {
    long long size, used;

    size = dictSlots(dict);
    used = dictSize(dict);
    return (size > DICT_HT_INITIAL_SIZE &&
            (used*100/size < HASHTABLE_MIN_FILL));
}",1,11,server.c,htNeedsResize,,false,593,600,htNeedsResize,,,72,int htNeedsResize (dict*)
367928,METHOD,server.c:<global>,TYPE_DECL,"void tryResizeHashTables(int dbid) {
    if (htNeedsResize(server.db[dbid].dict))
        dictResize(server.db[dbid].dict);
    if (htNeedsResize(server.db[dbid].expires))
        dictResize(server.db[dbid].expires);
}",1,1,server.c,tryResizeHashTables,,false,604,609,tryResizeHashTables,,,73,void tryResizeHashTables (int)
367969,METHOD,server.c:<global>,TYPE_DECL,"int incrementallyRehash(int dbid) {
    /* Keys dictionary */
    if (dictIsRehashing(server.db[dbid].dict)) {
        dictRehashMilliseconds(server.db[dbid].dict,1);
        return 1; /* already used our millisecond for this loop... */
    }
    /* Expires */
    if (dictIsRehashing(server.db[dbid].expires)) {
        dictRehashMilliseconds(server.db[dbid].expires,1);
        return 1; /* already used our millisecond for this loop... */
    }
    return 0;
}",1,8,server.c,incrementallyRehash,,false,618,630,incrementallyRehash,,,74,int incrementallyRehash (int)
368044,METHOD,server.c:<global>,TYPE_DECL,"void updateDictResizePolicy(void) {
    if (server.in_fork_child != CHILD_TYPE_NONE)
        dictSetResizeEnabled(DICT_RESIZE_FORBID);
    else if (hasActiveChildProcess())
        dictSetResizeEnabled(DICT_RESIZE_AVOID);
    else
        dictSetResizeEnabled(DICT_RESIZE_ENABLE);
}",1,32,server.c,updateDictResizePolicy,,false,638,645,updateDictResizePolicy,,,75,void updateDictResizePolicy (void)
368071,METHOD,server.c:<global>,TYPE_DECL,"const char *strChildType(int type) {
    switch(type) {
        case CHILD_TYPE_RDB: return ""RDB"";
        case CHILD_TYPE_AOF: return ""AOF"";
        case CHILD_TYPE_LDB: return ""LDB"";
        case CHILD_TYPE_MODULE: return ""MODULE"";
        default: return ""Unknown"";
    }
}",1,13,server.c,strChildType,,false,647,655,strChildType,,,76,const char* strChildType (int)
368106,METHOD,server.c:<global>,TYPE_DECL,"int hasActiveChildProcess(void) {
    return server.child_pid != -1;
}",1,1,server.c,hasActiveChildProcess,,false,659,661,hasActiveChildProcess,,,77,int hasActiveChildProcess (void)
368118,METHOD,server.c:<global>,TYPE_DECL,"void resetChildState(void) {
    server.child_type = CHILD_TYPE_NONE;
    server.child_pid = -1;
    server.stat_current_cow_peak = 0;
    server.stat_current_cow_bytes = 0;
    server.stat_current_cow_updated = 0;
    server.stat_current_save_keys_processed = 0;
    server.stat_module_progress = 0;
    server.stat_current_save_keys_total = 0;
    updateDictResizePolicy();
    closeChildInfoPipe();
    moduleFireServerEvent(REDISMODULE_EVENT_FORK_CHILD,
                          REDISMODULE_SUBEVENT_FORK_CHILD_DIED,
                          NULL);
}",1,24,server.c,resetChildState,,false,663,677,resetChildState,,,78,void resetChildState (void)
368176,METHOD,server.c:<global>,TYPE_DECL,"int isMutuallyExclusiveChildType(int type) {
    return type == CHILD_TYPE_RDB || type == CHILD_TYPE_AOF || type == CHILD_TYPE_MODULE;
}",1,19,server.c,isMutuallyExclusiveChildType,,false,680,682,isMutuallyExclusiveChildType,,,79,int isMutuallyExclusiveChildType (int)
368199,METHOD,server.c:<global>,TYPE_DECL,"int isInsideYieldingLongCommand(void) {
    return scriptIsTimedout() || server.busy_module_yield_flags;
}",1,1,server.c,isInsideYieldingLongCommand,,false,685,687,isInsideYieldingLongCommand,,,80,int isInsideYieldingLongCommand (void)
368210,METHOD,server.c:<global>,TYPE_DECL,"int allPersistenceDisabled(void) {
    return server.saveparamslen == 0 && server.aof_state == AOF_OFF;
}",1,60,server.c,allPersistenceDisabled,,false,691,693,allPersistenceDisabled,,,81,int allPersistenceDisabled (void)
368229,METHOD,server.c:<global>,TYPE_DECL,"void trackInstantaneousMetric(int metric, long long current_value, long long current_base, long long factor) {
    if (server.inst_metric[metric].last_sample_base > 0) {
        long long base = current_base - server.inst_metric[metric].last_sample_base;
        long long value = current_value - server.inst_metric[metric].last_sample_value;
        long long avg = base > 0 ? (value * factor / base) : 0;
        server.inst_metric[metric].samples[server.inst_metric[metric].idx] = avg;
        server.inst_metric[metric].idx++;
        server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;
    }
    server.inst_metric[metric].last_sample_base = current_base;
    server.inst_metric[metric].last_sample_value = current_value;
}",1,42,server.c,trackInstantaneousMetric,,false,704,715,trackInstantaneousMetric,,,82,"void trackInstantaneousMetric (int,long long,long long,long long)"
368339,METHOD,server.c:<global>,TYPE_DECL,"long long getInstantaneousMetric(int metric) {
    int j;
    long long sum = 0;

    for (j = 0; j < STATS_METRIC_SAMPLES; j++)
        sum += server.inst_metric[metric].samples[j];
    return sum / STATS_METRIC_SAMPLES;
}",1,20,server.c,getInstantaneousMetric,,false,718,725,getInstantaneousMetric,,,83,long long getInstantaneousMetric (int)
368378,METHOD,server.c:<global>,TYPE_DECL,"int clientsCronResizeQueryBuffer(client *c) {
    size_t querybuf_size = sdsalloc(c->querybuf);
    time_t idletime = server.unixtime - c->lastinteraction;

    /* Only resize the query buffer if the buffer is actually wasting at least a
     * few kbytes */
    if (sdsavail(c->querybuf) > 1024*4) {
        /* There are two conditions to resize the query buffer: */
        if (idletime > 2) {
            /* 1) Query is idle for a long time. */
            c->querybuf = sdsRemoveFreeSpace(c->querybuf, 1);
        } else if (querybuf_size > PROTO_RESIZE_THRESHOLD && querybuf_size/2 > c->querybuf_peak) {
            /* 2) Query buffer is too big for latest peak and is larger than
             *    resize threshold. Trim excess space but only up to a limit,
             *    not below the recent peak and current c->querybuf (which will
             *    be soon get used). If we're in the middle of a bulk then make
             *    sure not to resize to less than the bulk length. */
   ...",1,35,server.c,clientsCronResizeQueryBuffer,,false,731,762,clientsCronResizeQueryBuffer,,,84,int clientsCronResizeQueryBuffer (client*)
368536,METHOD,server.c:<global>,TYPE_DECL,"int clientsCronResizeOutputBuffer(client *c, mstime_t now_ms) {

    size_t new_buffer_size = 0;
    char *oldbuf = NULL;
    const size_t buffer_target_shrink_size = c->buf_usable_size/2;
    const size_t buffer_target_expand_size = c->buf_usable_size*2;

    /* in case the resizing is disabled return immediately */
    if(!server.reply_buffer_resizing_enabled)
        return 0;

    if (buffer_target_shrink_size >= PROTO_REPLY_MIN_BYTES &&
        c->buf_peak < buffer_target_shrink_size )
    {
        new_buffer_size = max(PROTO_REPLY_MIN_BYTES,c->buf_peak+1);
        server.stat_reply_buffer_shrinks++;
    } else if (buffer_target_expand_size < PROTO_REPLY_CHUNK_BYTES*2 &&
        c->buf_peak == c->buf_usable_size)
    {
        new_buffer_size = min(PROTO_REPLY_CHUNK_BYTES,buffer_target_expand_size);
        server.stat_reply_buffer_expands++;
    }

    serverAssertWithInfo(c, NULL, (!new_buffer_size) || (new_buffer_size >= (size_t)c->bufpos));

    /* reset the peak value eac...",1,37,server.c,clientsCronResizeOutputBuffer,,false,771,813,clientsCronResizeOutputBuffer,,,85,"int clientsCronResizeOutputBuffer (client*,mstime_t)"
368745,METHOD,server.c:<global>,TYPE_DECL,"int clientsCronTrackExpansiveClients(client *c, int time_idx) {
    size_t in_usage = sdsZmallocSize(c->querybuf) + c->argv_len_sum +
	              (c->argv ? zmalloc_size(c->argv) : 0);
    size_t out_usage = getClientOutputBufferMemoryUsage(c);

    /* Track the biggest values observed so far in this slot. */
    if (in_usage > ClientsPeakMemInput[time_idx]) ClientsPeakMemInput[time_idx] = in_usage;
    if (out_usage > ClientsPeakMemOutput[time_idx]) ClientsPeakMemOutput[time_idx] = out_usage;

    return 0; /* This function never terminates the client. */
}",1,1,server.c,clientsCronTrackExpansiveClients,,false,831,841,clientsCronTrackExpansiveClients,,,90,"int clientsCronTrackExpansiveClients (client*,int)"
368803,METHOD,server.c:<global>,TYPE_DECL,"static inline clientMemUsageBucket *getMemUsageBucket(size_t mem) {
    int size_in_bits = 8*(int)sizeof(mem);
    int clz = mem > 0 ? __builtin_clzl(mem) : size_in_bits;
    int bucket_idx = size_in_bits - clz;
    if (bucket_idx > CLIENT_MEM_USAGE_BUCKET_MAX_LOG)
        bucket_idx = CLIENT_MEM_USAGE_BUCKET_MAX_LOG;
    else if (bucket_idx < CLIENT_MEM_USAGE_BUCKET_MIN_LOG)
        bucket_idx = CLIENT_MEM_USAGE_BUCKET_MIN_LOG;
    bucket_idx -= CLIENT_MEM_USAGE_BUCKET_MIN_LOG;
    return &server.client_mem_usage_buckets[bucket_idx];
}",1,21,server.c,getMemUsageBucket,,false,850,860,getMemUsageBucket,,,91,clientMemUsageBucket getMemUsageBucket (size_t)
368871,METHOD,server.c:<global>,TYPE_DECL,"void updateClientMemoryUsage(client *c) {
    size_t mem = getClientMemoryUsage(c, NULL);
    int type = getClientType(c);
    /* Now that we have the memory used by the client, remove the old
     * value from the old category, and add it back. */
    server.stat_clients_type_memory[c->last_memory_type] -= c->last_memory_usage;
    server.stat_clients_type_memory[type] += mem;
    /* Remember what we added and where, to remove it next time. */
    c->last_memory_type = type;
    c->last_memory_usage = mem;
}",1,1,server.c,updateClientMemoryUsage,,false,874,884,updateClientMemoryUsage,,,92,void updateClientMemoryUsage (client*)
368915,METHOD,server.c:<global>,TYPE_DECL,"int clientEvictionAllowed(client *c) {
    if (server.maxmemory_clients == 0 || c->flags & CLIENT_NO_EVICT) {
        return 0;
    }
    int type = getClientType(c);
    return (type == CLIENT_TYPE_NORMAL || type == CLIENT_TYPE_PUBSUB);
}",1,52,server.c,clientEvictionAllowed,,false,886,892,clientEvictionAllowed,,,93,int clientEvictionAllowed (client*)
368956,METHOD,server.c:<global>,TYPE_DECL,"void removeClientFromMemUsageBucket(client *c, int allow_eviction) {
    if (c->mem_usage_bucket) {
        c->mem_usage_bucket->mem_usage_sum -= c->last_memory_usage;
        /* If this client can't be evicted then remove it from the mem usage
         * buckets */
        if (!allow_eviction) {
            listDelNode(c->mem_usage_bucket->clients, c->mem_usage_bucket_node);
            c->mem_usage_bucket = NULL;
            c->mem_usage_bucket_node = NULL;
        }
    }
}",1,1,server.c,removeClientFromMemUsageBucket,,false,899,910,removeClientFromMemUsageBucket,,,94,"void removeClientFromMemUsageBucket (client*,int)"
368999,METHOD,server.c:<global>,TYPE_DECL,"int updateClientMemUsageAndBucket(client *c) {
    serverAssert(io_threads_op == IO_THREADS_OP_IDLE);
    int allow_eviction = clientEvictionAllowed(c);
    removeClientFromMemUsageBucket(c, allow_eviction);

    if (!allow_eviction) {
        return 0;
    }

    /* Update client memory usage. */
    updateClientMemoryUsage(c);

    /* Update the client in the mem usage buckets */
    clientMemUsageBucket *bucket = getMemUsageBucket(c->last_memory_usage);
    bucket->mem_usage_sum += c->last_memory_usage;
    if (bucket != c->mem_usage_bucket) {
        if (c->mem_usage_bucket)
            listDelNode(c->mem_usage_bucket->clients,
                        c->mem_usage_bucket_node);
        c->mem_usage_bucket = bucket;
        listAddNodeTail(bucket->clients, c);
        c->mem_usage_bucket_node = listLast(bucket->clients);
    }
    return 1;
}",1,4,server.c,updateClientMemUsageAndBucket,,false,928,952,updateClientMemUsageAndBucket,,,95,int updateClientMemUsageAndBucket (client*)
369097,METHOD,server.c:<global>,TYPE_DECL,"void getExpansiveClientsInfo(size_t *in_usage, size_t *out_usage) {
    size_t i = 0, o = 0;
    for (int j = 0; j < CLIENTS_PEAK_MEM_USAGE_SLOTS; j++) {
        if (ClientsPeakMemInput[j] > i) i = ClientsPeakMemInput[j];
        if (ClientsPeakMemOutput[j] > o) o = ClientsPeakMemOutput[j];
    }
    *in_usage = i;
    *out_usage = o;
}",1,24,server.c,getExpansiveClientsInfo,,false,956,964,getExpansiveClientsInfo,,,96,"void getExpansiveClientsInfo (size_t*,size_t*)"
369157,METHOD,server.c:<global>,TYPE_DECL,"void clientsCron(void) {
    /* Try to process at least numclients/server.hz of clients
     * per call. Since normally (if there are no big latency events) this
     * function is called server.hz times per second, in the average case we
     * process all the clients in 1 second. */
    int numclients = listLength(server.clients);
    int iterations = numclients/server.hz;
    mstime_t now = mstime();

    /* Process at least a few clients while we are at it, even if we need
     * to process less than CLIENTS_CRON_MIN_ITERATIONS to meet our contract
     * of processing each client once per second. */
    if (iterations < CLIENTS_CRON_MIN_ITERATIONS)
        iterations = (numclients < CLIENTS_CRON_MIN_ITERATIONS) ?
                     numclients : CLIENTS_CRON_MIN_ITERATIONS;


    int curr_peak_mem_usage_slot = server.unixtime % CLIENTS_PEAK_MEM_USAGE_SLOTS;
    /* Always zero the next sample, so that when we switch to that second, we'll
     * only register samples that are gr...",1,21,server.c,clientsCron,,false,982,1045,clientsCron,,,97,void clientsCron (void)
369313,METHOD,server.c:<global>,TYPE_DECL,"void databasesCron(void) {
    /* Expire keys by random sampling. Not required for slaves
     * as master will synthesize DELs for us. */
    if (server.active_expire_enabled) {
        if (iAmMaster()) {
            activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
        } else {
            expireSlaveKeys();
        }
    }

    /* Defrag keys gradually. */
    activeDefragCycle();

    /* Perform hash tables rehashing if needed, but only if there are no
     * other processes saving the DB on disk. Otherwise rehashing is bad
     * as will cause a lot of copy-on-write of memory pages. */
    if (!hasActiveChildProcess()) {
        /* We use global counters so if we stop the computation at a given
         * DB we'll be able to start from the successive in the next
         * cron loop iteration. */
        static unsigned int resize_db = 0;
        static unsigned int rehash_db = 0;
        int dbs_per_call = CRON_DBS_PER_CALL;
        int j;

        /* Don't test more DBs than w...",1,30,server.c,databasesCron,,false,1050,1101,databasesCron,,,98,void databasesCron (void)
369418,METHOD,server.c:<global>,TYPE_DECL,"static inline void updateCachedTimeWithUs(int update_daylight_info, const long long ustime) {
    server.ustime = ustime;
    server.mstime = server.ustime / 1000;
    time_t unixtime = server.mstime / 1000;
    atomicSet(server.unixtime, unixtime);

    /* To get information about daylight saving time, we need to call
     * localtime_r and cache the result. However calling localtime_r in this
     * context is safe since we will never fork() while here, in the main
     * thread. The logging function will call a thread safe version of
     * localtime that has no locks. */
    if (update_daylight_info) {
        struct tm tm;
        time_t ut = server.unixtime;
        localtime_r(&ut,&tm);
        server.daylight_active = tm.tm_isdst;
    }
}",1,1,server.c,updateCachedTimeWithUs,,false,1103,1120,updateCachedTimeWithUs,,,99,"void updateCachedTimeWithUs (int,long long)"
369473,METHOD,server.c:<global>,TYPE_DECL,"void updateCachedTime(int update_daylight_info) {
    const long long us = ustime();
    updateCachedTimeWithUs(update_daylight_info, us);
}",1,1,server.c,updateCachedTime,,false,1132,1135,updateCachedTime,,,100,void updateCachedTime (int)
369485,METHOD,server.c:<global>,TYPE_DECL,"void enterExecutionUnit(int update_cached_time, long long us) {
    if (server.execution_nesting++ == 0 && update_cached_time) {
        if (us == 0) {
            us = ustime();
        }
        updateCachedTimeWithUs(0, us);
        server.cmd_time_snapshot = server.mstime;
    }
}",1,1,server.c,enterExecutionUnit,,false,1143,1151,enterExecutionUnit,,,101,"void enterExecutionUnit (int,long long)"
369519,METHOD,server.c:<global>,TYPE_DECL,"void exitExecutionUnit(void) {
    --server.execution_nesting;
}",1,1,server.c,exitExecutionUnit,,false,1153,1155,exitExecutionUnit,,,102,void exitExecutionUnit (void)
369528,METHOD,server.c:<global>,TYPE_DECL,"void checkChildrenDone(void) {
    int statloc = 0;
    pid_t pid;

    if ((pid = waitpid(-1, &statloc, WNOHANG)) != 0) {
        int exitcode = WIFEXITED(statloc) ? WEXITSTATUS(statloc) : -1;
        int bysignal = 0;

        if (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);

        /* sigKillChildHandler catches the signal and calls exit(), but we
         * must make sure not to flag lastbgsave_status, etc incorrectly.
         * We could directly terminate the child process via SIGUSR1
         * without handling it */
        if (exitcode == SERVER_CHILD_NOERROR_RETVAL) {
            bysignal = SIGUSR1;
            exitcode = 1;
        }

        if (pid == -1) {
            serverLog(LL_WARNING,""waitpid() returned an error: %s. ""
                ""child_type: %s, child_pid = %d"",
                strerror(errno),
                strChildType(server.child_type),
                (int) server.child_pid);
        } else if (pid == server.child_pid) {
            if (server...",1,24,server.c,checkChildrenDone,,false,1157,1206,checkChildrenDone,,,103,void checkChildrenDone (void)
369726,METHOD,server.c:<global>,TYPE_DECL,"void cronUpdateMemoryStats(void) {
    /* Record the max memory used since the server was started. */
    if (zmalloc_used_memory() > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used_memory();

    run_with_period(100) {
        /* Sample the RSS and other metrics here since this is a relatively slow call.
         * We must sample the zmalloc_used at the same time we take the rss, otherwise
         * the frag ratio calculate may be off (ratio of two samples at different times) */
        server.cron_malloc_stats.process_rss = zmalloc_get_rss();
        server.cron_malloc_stats.zmalloc_used = zmalloc_used_memory();
        /* Sampling the allocator info can be slow too.
         * The fragmentation ratio it'll show is potentially more accurate
         * it excludes other RSS pages such as: shared libraries, LUA and other non-zmalloc
         * allocations, and allocator reserved pages that can be pursed (all not actual frag) */
        zmalloc_get_allocator_...",1,4,server.c,cronUpdateMemoryStats,,false,1209,1241,cronUpdateMemoryStats,,,104,void cronUpdateMemoryStats (void)
369865,METHOD,server.c:<global>,TYPE_DECL,"int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    int j;
    UNUSED(eventLoop);
    UNUSED(id);
    UNUSED(clientData);

    /* Software watchdog: deliver the SIGALRM that will reach the signal
     * handler if we don't return here fast enough. */
    if (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);

    server.hz = server.config_hz;
    /* Adapt the server.hz value to the number of configured clients. If we have
     * many clients, we want to call serverCron() with an higher frequency. */
    if (server.dynamic_hz) {
        while (listLength(server.clients) / server.hz >
               MAX_CLIENTS_PER_CLOCK_TICK)
        {
            server.hz *= 2;
            if (server.hz > CONFIG_MAX_HZ) {
                server.hz = CONFIG_MAX_HZ;
                break;
            }
        }
    }

    /* for debug purposes: skip actual cron work if pause_cron is on */
    if (server.pause_cron) return 1000/server.hz;

    mono...",1,4,server.c,serverCron,,false,1262,1529,serverCron,,,105,"int serverCron (aeEventLoop*,long long,void*)"
371022,METHOD,server.c:<global>,TYPE_DECL,"void blockingOperationStarts(void) {
    if(!server.blocking_op_nesting++){
        updateCachedTime(0);
        server.blocked_last_cron = server.mstime;
    }
}",1,1,server.c,blockingOperationStarts,,false,1532,1537,blockingOperationStarts,,,106,void blockingOperationStarts (void)
371043,METHOD,server.c:<global>,TYPE_DECL,"void blockingOperationEnds(void) {
    if(!(--server.blocking_op_nesting)){
        server.blocked_last_cron = 0;
    }
}",1,1,server.c,blockingOperationEnds,,false,1539,1543,blockingOperationEnds,,,107,void blockingOperationEnds (void)
371060,METHOD,server.c:<global>,TYPE_DECL,"void whileBlockedCron(void) {
    /* Here we may want to perform some cron jobs (normally done server.hz times
     * per second). */

    /* Since this function depends on a call to blockingOperationStarts, let's
     * make sure it was done. */
    serverAssert(server.blocked_last_cron);

    /* In case we where called too soon, leave right away. This way one time
     * jobs after the loop below don't need an if. and we don't bother to start
     * latency monitor if this function is called too often. */
    if (server.blocked_last_cron >= server.mstime)
        return;

    mstime_t latency;
    latencyStartMonitor(latency);

    /* In some cases we may be called with big intervals, so we may need to do
     * extra work here. This is because some of the functions in serverCron rely
     * on the fact that it is performed every 10 ms or so. For instance, if
     * activeDefragCycle needs to utilize 25% cpu, it will utilize 2.5ms, so we
     * need to call it multiple times. */
 ...",1,4,server.c,whileBlockedCron,,false,1550,1601,whileBlockedCron,,,108,void whileBlockedCron (void)
371224,METHOD,server.c:<global>,TYPE_DECL,"static void sendGetackToReplicas(void) {
    robj *argv[3];
    argv[0] = shared.replconf;
    argv[1] = shared.getack;
    argv[2] = shared.special_asterick; /* Not used argument. */
    replicationFeedSlaves(server.slaves, -1, argv, 3);
}",1,1,server.c,sendGetackToReplicas,,false,1603,1609,sendGetackToReplicas,,,109,void sendGetackToReplicas (void)
371260,METHOD,server.c:<global>,TYPE_DECL,"void beforeSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);

    size_t zmalloc_used = zmalloc_used_memory();
    if (zmalloc_used > server.stat_peak_memory)
        server.stat_peak_memory = zmalloc_used;

    /* Just call a subset of vital functions in case we are re-entering
     * the event loop from processEventsWhileBlocked(). Note that in this
     * case we keep track of the number of events we are processing, since
     * processEventsWhileBlocked() wants to stop ASAP if there are no longer
     * events to handle. */
    if (ProcessingEventsWhileBlocked) {
        uint64_t processed = 0;
        processed += handleClientsWithPendingReadsUsingThreads();
        processed += connTypeProcessPendingData();
        if (server.aof_state == AOF_ON || server.aof_state == AOF_WAIT_REWRITE)
            flushAppendOnlyFile(0);
        processed += handleClientsWithPendingWrites();
        processed += freeClientsInAsyncFreeQueue();
        server.events_processed_while_b...",1,4,server.c,beforeSleep,,false,1627,1782,beforeSleep,,,111,void beforeSleep (aeEventLoop*)
371587,METHOD,server.c:<global>,TYPE_DECL,"void afterSleep(struct aeEventLoop *eventLoop) {
    UNUSED(eventLoop);
    /********************* WARNING ********************
     * Do NOT add anything above moduleAcquireGIL !!! *
     ***************************** ********************/
    if (!ProcessingEventsWhileBlocked) {
        /* Acquire the modules GIL so that their threads won't touch anything. */
        if (moduleCount()) {
            mstime_t latency;
            latencyStartMonitor(latency);

            moduleAcquireGIL();
            moduleFireServerEvent(REDISMODULE_EVENT_EVENTLOOP,
                                  REDISMODULE_SUBEVENT_EVENTLOOP_AFTER_SLEEP,
                                  NULL);
            latencyEndMonitor(latency);
            latencyAddSampleIfNeeded(""module-acquire-GIL"",latency);
        }
        /* Set the eventloop start time. */
        server.el_start = getMonotonicUs();
        /* Set the eventloop command count at start. */
        server.el_cmd_cnt_start = server.stat_numcomman...",1,4,server.c,afterSleep,,false,1787,1820,afterSleep,,,112,void afterSleep (aeEventLoop*)
371687,METHOD,server.c:<global>,TYPE_DECL,"void createSharedObjects(void) {
    int j;

    /* Shared command responses */
    shared.ok = createObject(OBJ_STRING,sdsnew(""+OK\r\n""));
    shared.emptybulk = createObject(OBJ_STRING,sdsnew(""$0\r\n\r\n""));
    shared.czero = createObject(OBJ_STRING,sdsnew("":0\r\n""));
    shared.cone = createObject(OBJ_STRING,sdsnew("":1\r\n""));
    shared.emptyarray = createObject(OBJ_STRING,sdsnew(""*0\r\n""));
    shared.pong = createObject(OBJ_STRING,sdsnew(""+PONG\r\n""));
    shared.queued = createObject(OBJ_STRING,sdsnew(""+QUEUED\r\n""));
    shared.emptyscan = createObject(OBJ_STRING,sdsnew(""*2\r\n$1\r\n0\r\n*0\r\n""));
    shared.space = createObject(OBJ_STRING,sdsnew("" ""));
    shared.plus = createObject(OBJ_STRING,sdsnew(""+""));

    /* Shared command error responses */
    shared.wrongtypeerr = createObject(OBJ_STRING,sdsnew(
        ""-WRONGTYPE Operation against a key holding the wrong kind of value\r\n""));
    shared.err = createObject(OBJ_STRING,sdsnew(""-ERR\r\n""));
    shared.nokeyerr = c...",1,29,server.c,createSharedObjects,,false,1824,1988,createSharedObjects,,,113,void createSharedObjects (void)
372664,METHOD,server.c:<global>,TYPE_DECL,"void initServerClientMemUsageBuckets(void) {
    if (server.client_mem_usage_buckets)
        return;
    server.client_mem_usage_buckets = zmalloc(sizeof(clientMemUsageBucket)*CLIENT_MEM_USAGE_BUCKETS);
    for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++) {
        server.client_mem_usage_buckets[j].mem_usage_sum = 0;
        server.client_mem_usage_buckets[j].clients = listCreate();
    }
}",1,75,server.c,initServerClientMemUsageBuckets,,false,1990,1998,initServerClientMemUsageBuckets,,,114,void initServerClientMemUsageBuckets (void)
372726,METHOD,server.c:<global>,TYPE_DECL,"void freeServerClientMemUsageBuckets(void) {
    if (!server.client_mem_usage_buckets)
        return;
    for (int j = 0; j < CLIENT_MEM_USAGE_BUCKETS; j++)
        listRelease(server.client_mem_usage_buckets[j].clients);
    zfree(server.client_mem_usage_buckets);
    server.client_mem_usage_buckets = NULL;
}",1,24,server.c,freeServerClientMemUsageBuckets,,false,2000,2007,freeServerClientMemUsageBuckets,,,115,void freeServerClientMemUsageBuckets (void)
372772,METHOD,server.c:<global>,TYPE_DECL,"void initServerConfig(void) {
    int j;
    char *default_bindaddr[CONFIG_DEFAULT_BINDADDR_COUNT] = CONFIG_DEFAULT_BINDADDR;

    initConfigValues();
    updateCachedTime(1);
    server.cmd_time_snapshot = server.mstime;
    getRandomHexChars(server.runid,CONFIG_RUN_ID_SIZE);
    server.runid[CONFIG_RUN_ID_SIZE] = '\0';
    changeReplicationId();
    clearReplicationId2();
    server.hz = CONFIG_DEFAULT_HZ; /* Initialize it ASAP, even if it may get
                                      updated later after loading the config.
                                      This value may be used before the server
                                      is initialized. */
    server.timezone = getTimeZone(); /* Initialized by tzset(). */
    server.configfile = NULL;
    server.executable = NULL;
    server.arch_bits = (sizeof(long) == 8) ? 64 : 32;
    server.bindaddr_count = CONFIG_DEFAULT_BINDADDR_COUNT;
    for (j = 0; j < CONFIG_DEFAULT_BINDADDR_COUNT; j++)
        server.bindaddr[j] = zstr...",1,27,server.c,initServerConfig,,false,2009,2130,initServerConfig,,,116,void initServerConfig (void)
373314,METHOD,server.c:<global>,TYPE_DECL,"int restartServer(int flags, mstime_t delay) {
    int j;

    /* Check if we still have accesses to the executable that started this
     * server instance. */
    if (access(server.executable,X_OK) == -1) {
        serverLog(LL_WARNING,""Can't restart: this process has no ""
                             ""permissions to execute %s"", server.executable);
        return C_ERR;
    }

    /* Config rewriting. */
    if (flags & RESTART_SERVER_CONFIG_REWRITE &&
        server.configfile &&
        rewriteConfig(server.configfile, 0) == -1)
    {
        serverLog(LL_WARNING,""Can't restart: configuration rewrite process ""
                             ""failed: %s"", strerror(errno));
        return C_ERR;
    }

    /* Perform a proper shutdown. We don't wait for lagging replicas though. */
    if (flags & RESTART_SERVER_GRACEFULLY &&
        prepareForShutdown(SHUTDOWN_NOW) != C_OK)
    {
        serverLog(LL_WARNING,""Can't restart: error preparing for shutdown"");
        return C_ERR;
    ...",1,8,server.c,restartServer,,false,2149,2196,restartServer,,,118,"int restartServer (int,mstime_t)"
373510,METHOD,server.c:<global>,TYPE_DECL,"int setOOMScoreAdj(int process_class) {
    if (process_class == -1)
        process_class = (server.masterhost ? CONFIG_OOM_REPLICA : CONFIG_OOM_MASTER);

    serverAssert(process_class >= 0 && process_class < CONFIG_OOM_COUNT);

#ifdef HAVE_PROC_OOM_SCORE_ADJ
    /* The following statics are used to indicate Redis has changed the process's oom score.
     * And to save the original score so we can restore it later if needed.
     * We need this so when we disabled oom-score-adj (also during configuration rollback
     * when another configuration parameter was invalid and causes a rollback after
     * applying a new oom-score) we can return to the oom-score value from before our
     * adjustments. */
    static int oom_score_adjusted_by_redis = 0;
    static int oom_score_adj_base = 0;

    int fd;
    int val;
    char buf[64];

    if (server.oom_score_adj != OOM_SCORE_ADJ_NO) {
        if (!oom_score_adjusted_by_redis) {
            oom_score_adjusted_by_redis = 1;
          ...",1,45,server.c,setOOMScoreAdj,,false,2205,2267,setOOMScoreAdj,,,119,int setOOMScoreAdj (int)
373558,METHOD,server.c:<global>,TYPE_DECL,"void adjustOpenFilesLimit(void) {
    rlim_t maxfiles = server.maxclients+CONFIG_MIN_RESERVED_FDS;
    struct rlimit limit;

    if (getrlimit(RLIMIT_NOFILE,&limit) == -1) {
        serverLog(LL_WARNING,""Unable to obtain the current NOFILE limit (%s), assuming 1024 and setting the max clients configuration accordingly."",
            strerror(errno));
        server.maxclients = 1024-CONFIG_MIN_RESERVED_FDS;
    } else {
        rlim_t oldlimit = limit.rlim_cur;

        /* Set the max number of files if the current limit is not enough
         * for our needs. */
        if (oldlimit < maxfiles) {
            rlim_t bestlimit;
            int setrlimit_error = 0;

            /* Try to set the file limit to match 'maxfiles' or at least
             * to the higher value supported less than maxfiles. */
            bestlimit = maxfiles;
            while(bestlimit > oldlimit) {
                rlim_t decr_step = 16;

                limit.rlim_cur = bestlimit;
                limit.r...",1,40,server.c,adjustOpenFilesLimit,,false,2277,2353,adjustOpenFilesLimit,,,120,void adjustOpenFilesLimit (void)
373833,METHOD,server.c:<global>,TYPE_DECL,"void checkTcpBacklogSettings(void) {
#if defined(HAVE_PROC_SOMAXCONN)
    FILE *fp = fopen(""/proc/sys/net/core/somaxconn"",""r"");
    char buf[1024];
    if (!fp) return;
    if (fgets(buf,sizeof(buf),fp) != NULL) {
        int somaxconn = atoi(buf);
        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {
            serverLog(LL_WARNING,""WARNING: The TCP backlog setting of %d cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of %d."", server.tcp_backlog, somaxconn);
        }
    }
    fclose(fp);
#elif defined(HAVE_SYSCTL_KIPC_SOMAXCONN)
    int somaxconn, mib[3];
    size_t len = sizeof(int);

    mib[0] = CTL_KERN;
    mib[1] = KERN_IPC;
    mib[2] = KIPC_SOMAXCONN;

    if (sysctl(mib, 3, &somaxconn, &len, NULL, 0) == 0) {
        if (somaxconn > 0 && somaxconn < server.tcp_backlog) {
            serverLog(LL_WARNING,""WARNING: The TCP backlog setting of %d cannot be enforced because kern.ipc.somaxconn is set to the lower value of %d."", server...",1,1,server.c,checkTcpBacklogSettings,,false,2357,2399,checkTcpBacklogSettings,,,121,void checkTcpBacklogSettings (void)
373838,METHOD,server.c:<global>,TYPE_DECL,"void closeListener(connListener *sfd) {
    int j;

    for (j = 0; j < sfd->count; j++) {
        if (sfd->fd[j] == -1) continue;

        aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);
        close(sfd->fd[j]);
    }

    sfd->count = 0;
}",1,49,server.c,closeListener,,false,2401,2412,closeListener,,,122,void closeListener (connListener*)
373891,METHOD,server.c:<global>,TYPE_DECL,"int createSocketAcceptHandler(connListener *sfd, aeFileProc *accept_handler) {
    int j;

    for (j = 0; j < sfd->count; j++) {
        if (aeCreateFileEvent(server.el, sfd->fd[j], AE_READABLE, accept_handler,sfd) == AE_ERR) {
            /* Rollback */
            for (j = j-1; j >= 0; j--) aeDeleteFileEvent(server.el, sfd->fd[j], AE_READABLE);
            return C_ERR;
        }
    }
    return C_OK;
}",1,53,server.c,createSocketAcceptHandler,,false,2416,2427,createSocketAcceptHandler,,,123,"int createSocketAcceptHandler (connListener*,aeFileProc*)"
373965,METHOD,server.c:<global>,TYPE_DECL,"int listenToPort(connListener *sfd) {
    int j;
    int port = sfd->port;
    char **bindaddr = sfd->bindaddr;

    /* If we have no bind address, we don't listen on a TCP socket */
    if (sfd->bindaddr_count == 0) return C_OK;

    for (j = 0; j < sfd->bindaddr_count; j++) {
        char* addr = bindaddr[j];
        int optional = *addr == '-';
        if (optional) addr++;
        if (strchr(addr,':')) {
            /* Bind IPv6 address. */
            sfd->fd[sfd->count] = anetTcp6Server(server.neterr,port,addr,server.tcp_backlog);
        } else {
            /* Bind IPv4 address. */
            sfd->fd[sfd->count] = anetTcpServer(server.neterr,port,addr,server.tcp_backlog);
        }
        if (sfd->fd[sfd->count] == ANET_ERR) {
            int net_errno = errno;
            serverLog(LL_WARNING,
                ""Warning: Could not create server TCP listening socket %s:%d: %s"",
                addr, port, server.neterr);
            if (net_errno == EADDRNOTAVAIL && optional...",1,41,server.c,listenToPort,,false,2448,2489,listenToPort,,,124,int listenToPort (connListener*)
374188,METHOD,server.c:<global>,TYPE_DECL,"void resetServerStats(void) {
    int j;

    server.stat_numcommands = 0;
    server.stat_numconnections = 0;
    server.stat_expiredkeys = 0;
    server.stat_expired_stale_perc = 0;
    server.stat_expired_time_cap_reached_count = 0;
    server.stat_expire_cycle_time_used = 0;
    server.stat_evictedkeys = 0;
    server.stat_evictedclients = 0;
    server.stat_total_eviction_exceeded_time = 0;
    server.stat_last_eviction_exceeded_time = 0;
    server.stat_keyspace_misses = 0;
    server.stat_keyspace_hits = 0;
    server.stat_active_defrag_hits = 0;
    server.stat_active_defrag_misses = 0;
    server.stat_active_defrag_key_hits = 0;
    server.stat_active_defrag_key_misses = 0;
    server.stat_active_defrag_scanned = 0;
    server.stat_total_active_defrag_time = 0;
    server.stat_last_active_defrag_time = 0;
    server.stat_fork_time = 0;
    server.stat_fork_rate = 0;
    server.stat_total_forks = 0;
    server.stat_rejected_conn = 0;
    server.stat_sync_full = 0;
    server...",1,20,server.c,resetServerStats,,false,2494,2550,resetServerStats,,,125,void resetServerStats (void)
374481,METHOD,server.c:<global>,TYPE_DECL,"void makeThreadKillable(void) {
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
}",1,1,server.c,makeThreadKillable,,false,2555,2558,makeThreadKillable,,,126,void makeThreadKillable (void)
374492,METHOD,server.c:<global>,TYPE_DECL,"void initServer(void) {
    int j;

    signal(SIGHUP, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);
    setupSignalHandlers();
    makeThreadKillable();

    if (server.syslog_enabled) {
        openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
            server.syslog_facility);
    }

    /* Initialization after setting defaults from the config system. */
    server.aof_state = server.aof_enabled ? AOF_ON : AOF_OFF;
    server.fsynced_reploff = server.aof_enabled ? 0 : -1;
    server.hz = server.config_hz;
    server.pid = getpid();
    server.in_fork_child = CHILD_TYPE_NONE;
    server.main_thread_id = pthread_self();
    server.current_client = NULL;
    server.errors = raxNew();
    server.execution_nesting = 0;
    server.clients = listCreate();
    server.clients_index = raxNew();
    server.clients_to_close = listCreate();
    server.slaves = listCreate();
    server.monitors = listCreate();
    server.clients_pending_write = listCreate();
    server.clients_pendin...",1,44,server.c,initServer,,false,2560,2753,initServer,,,127,void initServer (void)
375458,METHOD,server.c:<global>,TYPE_DECL,"void initListeners(void) {
    /* Setup listeners from server config for TCP/TLS/Unix */
    int conn_index;
    connListener *listener;
    if (server.port != 0) {
        conn_index = connectionIndexByType(CONN_TYPE_SOCKET);
        if (conn_index < 0)
            serverPanic(""Failed finding connection listener of %s"", CONN_TYPE_SOCKET);
        listener = &server.listeners[conn_index];
        listener->bindaddr = server.bindaddr;
        listener->bindaddr_count = server.bindaddr_count;
        listener->port = server.port;
        listener->ct = connectionByType(CONN_TYPE_SOCKET);
    }

    if (server.tls_port || server.tls_replication || server.tls_cluster) {
        ConnectionType *ct_tls = connectionTypeTls();
        if (!ct_tls) {
            serverLog(LL_WARNING, ""Failed finding TLS support."");
            exit(1);
        }
        if (connTypeConfigure(ct_tls, &server.tls_ctx_config, 1) == C_ERR) {
            serverLog(LL_WARNING, ""Failed to configure TLS. Check logs ...",1,43,server.c,initListeners,,false,2755,2825,initListeners,,,128,void initListeners (void)
375862,METHOD,server.c:<global>,TYPE_DECL,"void InitServerLast(void) {
    bioInit();
    initThreadedIO();
    set_jemalloc_bg_thread(server.jemalloc_bg_thread);
    server.initial_memory_usage = zmalloc_used_memory();
}",1,1,server.c,InitServerLast,,false,2832,2837,InitServerLast,,,129,void InitServerLast (void)
375878,METHOD,server.c:<global>,TYPE_DECL,"void populateCommandLegacyRangeSpec(struct redisCommand *c) {
    memset(&c->legacy_range_key_spec, 0, sizeof(c->legacy_range_key_spec));

    /* Set the movablekeys flag if we have a GETKEYS flag for modules.
     * Note that for native redis commands, we always have keyspecs,
     * with enough information to rely on for movablekeys. */
    if (c->flags & CMD_MODULE_GETKEYS)
        c->flags |= CMD_MOVABLE_KEYS;

    /* no key-specs, no keys, exit. */
    if (c->key_specs_num == 0) {
        return;
    }

    if (c->key_specs_num == 1 &&
        c->key_specs[0].begin_search_type == KSPEC_BS_INDEX &&
        c->key_specs[0].find_keys_type == KSPEC_FK_RANGE)
    {
        /* Quick win, exactly one range spec. */
        c->legacy_range_key_spec = c->key_specs[0];
        /* If it has the incomplete flag, set the movablekeys flag on the command. */
        if (c->key_specs[0].flags & CMD_KEY_INCOMPLETE)
            c->flags |= CMD_MOVABLE_KEYS;
        return;
    }

    int firstke...",1,19,server.c,populateCommandLegacyRangeSpec,,false,2869,2942,populateCommandLegacyRangeSpec,,,130,void populateCommandLegacyRangeSpec (redisCommand*)
376319,METHOD,server.c:<global>,TYPE_DECL,"sds catSubCommandFullname(const char *parent_name, const char *sub_name) {
    return sdscatfmt(sdsempty(), ""%s|%s"", parent_name, sub_name);
}",1,1,server.c,catSubCommandFullname,,false,2944,2946,catSubCommandFullname,,,131,"sds catSubCommandFullname (char*,char*)"
376331,METHOD,server.c:<global>,TYPE_DECL,"void commandAddSubcommand(struct redisCommand *parent, struct redisCommand *subcommand, const char *declared_name) {
    if (!parent->subcommands_dict)
        parent->subcommands_dict = dictCreate(&commandTableDictType);

    subcommand->parent = parent; /* Assign the parent command */
    subcommand->id = ACLGetCommandID(subcommand->fullname); /* Assign the ID used for ACL. */

    serverAssert(dictAdd(parent->subcommands_dict, sdsnew(declared_name), subcommand) == DICT_OK);
}",1,4,server.c,commandAddSubcommand,,false,2948,2956,commandAddSubcommand,,,132,"void commandAddSubcommand (redisCommand*,redisCommand*,char*)"
376386,METHOD,server.c:<global>,TYPE_DECL,"void setImplicitACLCategories(struct redisCommand *c) {
    if (c->flags & CMD_WRITE)
        c->acl_categories |= ACL_CATEGORY_WRITE;
    /* Exclude scripting commands from the RO category. */
    if (c->flags & CMD_READONLY && !(c->acl_categories & ACL_CATEGORY_SCRIPTING))
        c->acl_categories |= ACL_CATEGORY_READ;
    if (c->flags & CMD_ADMIN)
        c->acl_categories |= ACL_CATEGORY_ADMIN|ACL_CATEGORY_DANGEROUS;
    if (c->flags & CMD_PUBSUB)
        c->acl_categories |= ACL_CATEGORY_PUBSUB;
    if (c->flags & CMD_FAST)
        c->acl_categories |= ACL_CATEGORY_FAST;
    if (c->flags & CMD_BLOCKING)
        c->acl_categories |= ACL_CATEGORY_BLOCKING;

    /* If it's not @fast is @slow in this binary world. */
    if (!(c->acl_categories & ACL_CATEGORY_FAST))
        c->acl_categories |= ACL_CATEGORY_SLOW;
}",1,19,server.c,setImplicitACLCategories,,false,2960,2978,setImplicitACLCategories,,,133,void setImplicitACLCategories (redisCommand*)
376549,METHOD,server.c:<global>,TYPE_DECL,"int populateCommandStructure(struct redisCommand *c) {
    /* If the command marks with CMD_SENTINEL, it exists in sentinel. */
    if (!(c->flags & CMD_SENTINEL) && server.sentinel_mode)
        return C_ERR;

    /* If the command marks with CMD_ONLY_SENTINEL, it only exists in sentinel. */
    if (c->flags & CMD_ONLY_SENTINEL && !server.sentinel_mode)
        return C_ERR;

    /* Translate the command string flags description into an actual
     * set of flags. */
    setImplicitACLCategories(c);

    /* We start with an unallocated histogram and only allocate memory when a command
     * has been issued for the first time */
    c->latency_histogram = NULL;

    /* Handle the legacy range spec and the ""movablekeys"" flag (must be done after populating all key specs). */
    populateCommandLegacyRangeSpec(c);

    /* Assign the ID used for ACL. */
    c->id = ACLGetCommandID(c->fullname);

    /* Handle subcommands */
    if (c->subcommands) {
        for (int j = 0; c->subcomman...",1,21,server.c,populateCommandStructure,,false,2984,3021,populateCommandStructure,,,134,int populateCommandStructure (redisCommand*)
376676,METHOD,server.c:<global>,TYPE_DECL,"void populateCommandTable(void) {
    int j;
    struct redisCommand *c;

    for (j = 0;; j++) {
        c = redisCommandTable + j;
        if (c->declared_name == NULL)
            break;

        int retval1, retval2;

        c->fullname = sdsnew(c->declared_name);
        if (populateCommandStructure(c) == C_ERR)
            continue;

        retval1 = dictAdd(server.commands, sdsdup(c->fullname), c);
        /* Populate an additional dictionary that will be unaffected
         * by rename-command statements in redis.conf. */
        retval2 = dictAdd(server.orig_commands, sdsdup(c->fullname), c);
        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
    }
}",1,43,server.c,populateCommandTable,,false,3027,3048,populateCommandTable,,,138,void populateCommandTable (void)
376766,METHOD,server.c:<global>,TYPE_DECL,"void resetCommandTableStats(dict* commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;

    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        c = (struct redisCommand *) dictGetVal(de);
        c->microseconds = 0;
        c->calls = 0;
        c->rejected_calls = 0;
        c->failed_calls = 0;
        if(c->latency_histogram) {
            hdr_close(c->latency_histogram);
            c->latency_histogram = NULL;
        }
        if (c->subcommands_dict)
            resetCommandTableStats(c->subcommands_dict);
    }
    dictReleaseIterator(di);
}",1,1,server.c,resetCommandTableStats,,false,3050,3070,resetCommandTableStats,,,139,void resetCommandTableStats (dict*)
376837,METHOD,server.c:<global>,TYPE_DECL,"void resetErrorTableStats(void) {
    raxFreeWithCallback(server.errors, zfree);
    server.errors = raxNew();
}",1,1,server.c,resetErrorTableStats,,false,3072,3075,resetErrorTableStats,,,140,void resetErrorTableStats (void)
376852,METHOD,server.c:<global>,TYPE_DECL,"int redisOpArrayAppend(redisOpArray *oa, int dbid, robj **argv, int argc, int target) {
    redisOp *op;
    int prev_capacity = oa->capacity;

    if (oa->numops == 0) {
        oa->capacity = 16;
    } else if (oa->numops >= oa->capacity) {
        oa->capacity *= 2;
    }

    if (prev_capacity != oa->capacity)
        oa->ops = zrealloc(oa->ops,sizeof(redisOp)*oa->capacity);
    op = oa->ops+oa->numops;
    op->dbid = dbid;
    op->argv = argv;
    op->argc = argc;
    op->target = target;
    oa->numops++;
    return oa->numops;
}",1,1,server.c,redisOpArrayAppend,,false,3079,3098,redisOpArrayAppend,,,141,"int redisOpArrayAppend (redisOpArray*,int,robj**,int,int)"
376954,METHOD,server.c:<global>,TYPE_DECL,"void redisOpArrayFree(redisOpArray *oa) {
    while(oa->numops) {
        int j;
        redisOp *op;

        oa->numops--;
        op = oa->ops+oa->numops;
        for (j = 0; j < op->argc; j++)
            decrRefCount(op->argv[j]);
        zfree(op->argv);
    }
    /* no need to free the actual op array, we reuse the memory for future commands */
    serverAssert(!oa->numops);
}",1,4,server.c,redisOpArrayFree,,false,3100,3113,redisOpArrayFree,,,142,void redisOpArrayFree (redisOpArray*)
377022,METHOD,server.c:<global>,TYPE_DECL,"int isContainerCommandBySds(sds s) {
    struct redisCommand *base_cmd = dictFetchValue(server.commands, s);
    int has_subcommands = base_cmd && base_cmd->subcommands_dict;
    return has_subcommands;
}",1,1,server.c,isContainerCommandBySds,,false,3117,3121,isContainerCommandBySds,,,143,int isContainerCommandBySds (sds)
377045,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupSubcommand(struct redisCommand *container, sds sub_name) {
    return dictFetchValue(container->subcommands_dict, sub_name);
}",1,1,server.c,lookupSubcommand,,false,3123,3125,lookupSubcommand,,,144,"struct redisCommand lookupSubcommand (redisCommand*,sds)"
377057,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommandLogic(dict *commands, robj **argv, int argc, int strict) {
    struct redisCommand *base_cmd = dictFetchValue(commands, argv[0]->ptr);
    int has_subcommands = base_cmd && base_cmd->subcommands_dict;
    if (argc == 1 || !has_subcommands) {
        if (strict && argc != 1)
            return NULL;
        /* Note: It is possible that base_cmd->proc==NULL (e.g. CONFIG) */
        return base_cmd;
    } else { /* argc > 1 && has_subcommands */
        if (strict && argc != 2)
            return NULL;
        /* Note: Currently we support just one level of subcommands */
        return lookupSubcommand(base_cmd, argv[1]->ptr);
    }
}",1,1,server.c,lookupCommandLogic,,false,3135,3149,lookupCommandLogic,,,145,"struct redisCommand lookupCommandLogic (dict*,robj**,int,int)"
377121,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommand(robj **argv, int argc) {
    return lookupCommandLogic(server.commands,argv,argc,0);
}",1,1,server.c,lookupCommand,,false,3151,3153,lookupCommand,,,146,"struct redisCommand lookupCommand (robj**,int)"
377135,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommandBySdsLogic(dict *commands, sds s) {
    int argc, j;
    sds *strings = sdssplitlen(s,sdslen(s),""|"",1,&argc);
    if (strings == NULL)
        return NULL;
    if (argc < 1 || argc > 2) {
        /* Currently we support just one level of subcommands */
        sdsfreesplitres(strings,argc);
        return NULL;
    }

    serverAssert(argc > 0); /* Avoid warning `-Wmaybe-uninitialized` in lookupCommandLogic() */
    robj objects[argc];
    robj *argv[argc];
    for (j = 0; j < argc; j++) {
        initStaticStringObject(objects[j],strings[j]);
        argv[j] = &objects[j];
    }

    struct redisCommand *cmd = lookupCommandLogic(commands,argv,argc,1);
    sdsfreesplitres(strings,argc);
    return cmd;
}",1,4,server.c,lookupCommandBySdsLogic,,false,3155,3177,lookupCommandBySdsLogic,,,147,"struct redisCommand lookupCommandBySdsLogic (dict*,sds)"
377268,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommandBySds(sds s) {
    return lookupCommandBySdsLogic(server.commands,s);
}",1,1,server.c,lookupCommandBySds,,false,3179,3181,lookupCommandBySds,,,148,struct redisCommand lookupCommandBySds (sds)
377279,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommandByCStringLogic(dict *commands, const char *s) {
    struct redisCommand *cmd;
    sds name = sdsnew(s);

    cmd = lookupCommandBySdsLogic(commands,name);
    sdsfree(name);
    return cmd;
}",1,1,server.c,lookupCommandByCStringLogic,,false,3183,3190,lookupCommandByCStringLogic,,,149,"struct redisCommand lookupCommandByCStringLogic (dict*,char*)"
377300,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommandByCString(const char *s) {
    return lookupCommandByCStringLogic(server.commands,s);
}",1,1,server.c,lookupCommandByCString,,false,3192,3194,lookupCommandByCString,,,150,struct redisCommand lookupCommandByCString (char*)
377311,METHOD,server.c:<global>,TYPE_DECL,"struct redisCommand *lookupCommandOrOriginal(robj **argv ,int argc) {
    struct redisCommand *cmd = lookupCommandLogic(server.commands, argv, argc, 0);

    if (!cmd) cmd = lookupCommandLogic(server.orig_commands, argv, argc, 0);
    return cmd;
}",1,1,server.c,lookupCommandOrOriginal,,false,3203,3208,lookupCommandOrOriginal,,,151,"struct redisCommand lookupCommandOrOriginal (robj**,int)"
377342,METHOD,server.c:<global>,TYPE_DECL,"int mustObeyClient(client *c) {
    return c->id == CLIENT_ID_AOF || c->flags & CLIENT_MASTER;
}",1,20,server.c,mustObeyClient,,false,3211,3213,mustObeyClient,,,152,int mustObeyClient (client*)
377365,METHOD,server.c:<global>,TYPE_DECL,"static int shouldPropagate(int target) {
    if (!server.replication_allowed || target == PROPAGATE_NONE || server.loading)
        return 0;

    if (target & PROPAGATE_AOF) {
        if (server.aof_state != AOF_OFF)
            return 1;
    }
    if (target & PROPAGATE_REPL) {
        if (server.masterhost == NULL && (server.repl_backlog || listLength(server.slaves) != 0))
            return 1;
    }

    return 0;
}",1,49,server.c,shouldPropagate,,false,3215,3229,shouldPropagate,,,153,int shouldPropagate (int)
377441,METHOD,server.c:<global>,TYPE_DECL,"static void propagateNow(int dbid, robj **argv, int argc, int target) {
    if (!shouldPropagate(target))
        return;

    /* This needs to be unreachable since the dataset should be fixed during
     * replica pause (otherwise data may be lost during a failover) */
    serverAssert(!(isPausedActions(PAUSE_ACTION_REPLICA) &&
                   (!server.client_pause_in_transaction)));

    if (server.aof_state != AOF_OFF && target & PROPAGATE_AOF)
        feedAppendOnlyFile(dbid,argv,argc);
    if (target & PROPAGATE_REPL)
        replicationFeedSlaves(server.slaves,dbid,argv,argc);
}",1,4,server.c,propagateNow,,false,3246,3259,propagateNow,,,154,"void propagateNow (int,robj**,int,int)"
377511,METHOD,server.c:<global>,TYPE_DECL,"void alsoPropagate(int dbid, robj **argv, int argc, int target) {
    robj **argvcopy;
    int j;

    if (!shouldPropagate(target))
        return;

    argvcopy = zmalloc(sizeof(robj*)*argc);
    for (j = 0; j < argc; j++) {
        argvcopy[j] = argv[j];
        incrRefCount(argv[j]);
    }
    redisOpArrayAppend(&server.also_propagate,dbid,argvcopy,argc,target);
}",1,1,server.c,alsoPropagate,,false,3272,3285,alsoPropagate,,,155,"void alsoPropagate (int,robj**,int,int)"
377565,METHOD,server.c:<global>,TYPE_DECL,"void forceCommandPropagation(client *c, int flags) {
    serverAssert(c->cmd->flags & (CMD_WRITE | CMD_MAY_REPLICATE));
    if (flags & PROPAGATE_REPL) c->flags |= CLIENT_FORCE_REPL;
    if (flags & PROPAGATE_AOF) c->flags |= CLIENT_FORCE_AOF;
}",1,4,server.c,forceCommandPropagation,,false,3290,3294,forceCommandPropagation,,,156,"void forceCommandPropagation (client*,int)"
377629,METHOD,server.c:<global>,TYPE_DECL,"void preventCommandPropagation(client *c) {
    c->flags |= CLIENT_PREVENT_PROP;
}",1,16,server.c,preventCommandPropagation,,false,3299,3301,preventCommandPropagation,,,157,void preventCommandPropagation (client*)
377647,METHOD,server.c:<global>,TYPE_DECL,"void preventCommandAOF(client *c) {
    c->flags |= CLIENT_PREVENT_AOF_PROP;
}",1,16,server.c,preventCommandAOF,,false,3304,3306,preventCommandAOF,,,158,void preventCommandAOF (client*)
377661,METHOD,server.c:<global>,TYPE_DECL,"void preventCommandReplication(client *c) {
    c->flags |= CLIENT_PREVENT_REPL_PROP;
}",1,16,server.c,preventCommandReplication,,false,3309,3311,preventCommandReplication,,,159,void preventCommandReplication (client*)
377675,METHOD,server.c:<global>,TYPE_DECL,"void slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration) {
    /* Some commands may contain sensitive data that should not be available in the slowlog. */
    if (cmd->flags & CMD_SKIP_SLOWLOG)
        return;

    /* If command argument vector was rewritten, use the original
     * arguments. */
    robj **argv = c->original_argv ? c->original_argv : c->argv;
    int argc = c->original_argv ? c->original_argc : c->argc;
    slowlogPushEntryIfNeeded(c,argv,argc,duration);
}",1,21,server.c,slowlogPushCurrentCommand,,false,3314,3324,slowlogPushCurrentCommand,,,160,"void slowlogPushCurrentCommand (client*,redisCommand*,ustime_t)"
377725,METHOD,server.c:<global>,TYPE_DECL,"void updateCommandLatencyHistogram(struct hdr_histogram **latency_histogram, int64_t duration_hist){
    if (duration_hist < LATENCY_HISTOGRAM_MIN_VALUE)
        duration_hist=LATENCY_HISTOGRAM_MIN_VALUE;
    if (duration_hist>LATENCY_HISTOGRAM_MAX_VALUE)
        duration_hist=LATENCY_HISTOGRAM_MAX_VALUE;
    if (*latency_histogram==NULL)
        hdr_init(LATENCY_HISTOGRAM_MIN_VALUE,LATENCY_HISTOGRAM_MAX_VALUE,LATENCY_HISTOGRAM_PRECISION,latency_histogram);
    hdr_record_value(*latency_histogram,duration_hist);
}",1,24,server.c,updateCommandLatencyHistogram,,false,3329,3337,updateCommandLatencyHistogram,,,161,"void updateCommandLatencyHistogram (hdr_histogram**,int64_t)"
377776,METHOD,server.c:<global>,TYPE_DECL,"static void propagatePendingCommands(void) {
    if (server.also_propagate.numops == 0)
        return;

    int j;
    redisOp *rop;

    /* If we got here it means we have finished an execution-unit.
     * If that unit has caused propagation of multiple commands, they
     * should be propagated as a transaction */
    int transaction = server.also_propagate.numops > 1;

    /* In case a command that may modify random keys was run *directly*
     * (i.e. not from within a script, MULTI/EXEC, RM_Call, etc.) we want
     * to avoid using a transaction (much like active-expire) */
    if (server.current_client &&
        server.current_client->cmd &&
        server.current_client->cmd->flags & CMD_TOUCHES_ARBITRARY_KEYS)
    {
        transaction = 0;
    }

    if (transaction) {
        /* We use dbid=-1 to indicate we do not want to replicate SELECT.
         * It'll be inserted together with the next command (inside the MULTI) */
        propagateNow(-1,&shared.multi,1,PROPAGATE...",1,44,server.c,propagatePendingCommands,,false,3342,3382,propagatePendingCommands,,,162,void propagatePendingCommands (void)
377929,METHOD,server.c:<global>,TYPE_DECL,"void postExecutionUnitOperations(void) {
    if (server.execution_nesting)
        return;

    firePostExecutionUnitJobs();

    /* If we are at the top-most call() and not inside a an active module
     * context (e.g. within a module timer) we can propagate what we accumulated. */
    propagatePendingCommands();

    /* Module subsystem post-execution-unit logic */
    modulePostExecutionUnitOperations();
}",1,1,server.c,postExecutionUnitOperations,,false,3398,3410,postExecutionUnitOperations,,,163,void postExecutionUnitOperations (void)
377943,METHOD,server.c:<global>,TYPE_DECL,"int incrCommandStatsOnError(struct redisCommand *cmd, int flags) {
    /* hold the prev error count captured on the last command execution */
    static long long prev_err_count = 0;
    int res = 0;
    if (cmd) {
        if ((server.stat_total_error_replies - prev_err_count) > 0) {
            if (flags & ERROR_COMMAND_REJECTED) {
                cmd->rejected_calls++;
                res = 1;
            } else if (flags & ERROR_COMMAND_FAILED) {
                cmd->failed_calls++;
                res = 1;
            }
        }
    }
    prev_err_count = server.stat_total_error_replies;
    return res;
}",1,24,server.c,incrCommandStatsOnError,,false,3421,3438,incrCommandStatsOnError,,,164,"int incrCommandStatsOnError (redisCommand*,int)"
378010,METHOD,server.c:<global>,TYPE_DECL,"void call(client *c, int flags) {
    long long dirty;
    uint64_t client_old_flags = c->flags;
    struct redisCommand *real_cmd = c->realcmd;
    client *prev_client = server.executing_client;
    server.executing_client = c;

    /* When call() is issued during loading the AOF we don't want commands called
     * from module, exec or LUA to go into the slowlog or to populate statistics. */
    int update_command_stats = !isAOFLoadingContext();

    /* We want to be aware of a client which is making a first time attempt to execute this command
     * and a client which is reprocessing command again (after being unblocked).
     * Blocked clients can be blocked in different places and not always it means the call() function has been
     * called. For example this is required for avoiding double logging to monitors.*/
    int reprocessing_command = flags & CMD_CALL_REPROCESSING;

    /* Initialization: clear the flags that must be set by the command on
     * demand, and initializ...",1,32,server.c,call,,false,3475,3694,call,,,165,"void call (client*,int)"
378861,METHOD,server.c:<global>,TYPE_DECL,"void rejectCommand(client *c, robj *reply) {
    flagTransaction(c);
    c->duration = 0;
    if (c->cmd) c->cmd->rejected_calls++;
    if (c->cmd && c->cmd->proc == execCommand) {
        execCommandAbort(c, reply->ptr);
    } else {
        /* using addReplyError* rather than addReply so that the error can be logged. */
        addReplyErrorObject(c, reply);
    }
}",1,1,server.c,rejectCommand,,false,3702,3712,rejectCommand,,,166,"void rejectCommand (client*,robj*)"
378908,METHOD,server.c:<global>,TYPE_DECL,"void rejectCommandSds(client *c, sds s) {
    flagTransaction(c);
    c->duration = 0;
    if (c->cmd) c->cmd->rejected_calls++;
    if (c->cmd && c->cmd->proc == execCommand) {
        execCommandAbort(c, s);
        sdsfree(s);
    } else {
        /* The following frees 's'. */
        addReplyErrorSds(c, s);
    }
}",1,1,server.c,rejectCommandSds,,false,3714,3725,rejectCommandSds,,,167,"void rejectCommandSds (client*,sds)"
378955,METHOD,server.c:<global>,TYPE_DECL,"void rejectCommandFormat(client *c, const char *fmt, ...) {
    va_list ap;
    va_start(ap,fmt);
    sds s = sdscatvprintf(sdsempty(),fmt,ap);
    va_end(ap);
    /* Make sure there are no newlines in the string, otherwise invalid protocol
     * is emitted (The args come from the user, they may contain any character). */
    sdsmapchars(s, ""\r\n"", ""  "",  2);
    rejectCommandSds(c, s);
}",1,1,server.c,rejectCommandFormat,,false,3727,3736,rejectCommandFormat,,,168,"void rejectCommandFormat (client*,char*...)"
378982,METHOD,server.c:<global>,TYPE_DECL,"void afterCommand(client *c) {
    UNUSED(c);
    /* Should be done before trackingHandlePendingKeyInvalidations so that we
     * reply to client before invalidating cache (makes more sense) */
    postExecutionUnitOperations();

    /* Flush pending tracking invalidations. */
    trackingHandlePendingKeyInvalidations();

    /* Flush other pending push messages. only when we are not in nested call.
     * So the messages are not interleaved with transaction response. */
    if (!server.execution_nesting)
        listJoin(c->reply, server.pending_push_messages);
}",1,4,server.c,afterCommand,,false,3739,3752,afterCommand,,,169,void afterCommand (client*)
379008,METHOD,server.c:<global>,TYPE_DECL,"int commandCheckExistence(client *c, sds *err) {
    if (c->cmd)
        return 1;
    if (!err)
        return 0;
    if (isContainerCommandBySds(c->argv[0]->ptr)) {
        /* If we can't find the command but argv[0] by itself is a command
         * it means we're dealing with an invalid subcommand. Print Help. */
        sds cmd = sdsnew((char *)c->argv[0]->ptr);
        sdstoupper(cmd);
        *err = sdsnew(NULL);
        *err = sdscatprintf(*err, ""unknown subcommand '%.128s'. Try %s HELP."",
                            (char *)c->argv[1]->ptr, cmd);
        sdsfree(cmd);
    } else {
        sds args = sdsempty();
        int i;
        for (i=1; i < c->argc && sdslen(args) < 128; i++)
            args = sdscatprintf(args, ""'%.*s' "", 128-(int)sdslen(args), (char*)c->argv[i]->ptr);
        *err = sdsnew(NULL);
        *err = sdscatprintf(*err, ""unknown command '%.128s', with args beginning with: %s"",
                            (char*)c->argv[0]->ptr, args);
        sdsfree(arg...",1,1,server.c,commandCheckExistence,,false,3756,3784,commandCheckExistence,,,170,"int commandCheckExistence (client*,sds*)"
379152,METHOD,server.c:<global>,TYPE_DECL,"int commandCheckArity(client *c, sds *err) {
    if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
        (c->argc < -c->cmd->arity))
    {
        if (err) {
            *err = sdsnew(NULL);
            *err = sdscatprintf(*err, ""wrong number of arguments for '%s' command"", c->cmd->fullname);
        }
        return 0;
    }

    return 1;
}",1,1,server.c,commandCheckArity,,false,3788,3800,commandCheckArity,,,171,"int commandCheckArity (client*,sds*)"
379212,METHOD,server.c:<global>,TYPE_DECL,"uint64_t getCommandFlags(client *c) {
    uint64_t cmd_flags = c->cmd->flags;

    if (c->cmd->proc == fcallCommand || c->cmd->proc == fcallroCommand) {
        cmd_flags = fcallGetCommandFlags(c, cmd_flags);
    } else if (c->cmd->proc == evalCommand || c->cmd->proc == evalRoCommand ||
               c->cmd->proc == evalShaCommand || c->cmd->proc == evalShaRoCommand)
    {
        cmd_flags = evalGetCommandFlags(c, cmd_flags);
    }

    return cmd_flags;
}",1,1,server.c,getCommandFlags,,false,3805,3817,getCommandFlags,,,172,uint64_t getCommandFlags (client*)
379289,METHOD,server.c:<global>,TYPE_DECL,"int processCommand(client *c) {
    if (!scriptIsTimedout()) {
        /* Both EXEC and scripts call call() directly so there should be
         * no way in_exec or scriptIsRunning() is 1.
         * That is unless lua_timedout, in which case client may run
         * some commands. */
        serverAssert(!server.in_exec);
        serverAssert(!scriptIsRunning());
    }

    /* in case we are starting to ProcessCommand and we already have a command we assume
     * this is a reprocessing of this command, so we do not want to perform some of the actions again. */
    int client_reprocessing_command = c->cmd ? 1 : 0;

    /* only run command filter if not reprocessing command */
    if (!client_reprocessing_command) {
        moduleCallCommandFilters(c);
        reqresAppendRequest(c);
    }

    /* Handle possible security attacks. */
    if (!strcasecmp(c->argv[0]->ptr,""host:"") || !strcasecmp(c->argv[0]->ptr,""post"")) {
        securityWarningCommand(c);
        return C_ERR;
    }
...",1,8,server.c,processCommand,,false,3827,4168,processCommand,,,173,int processCommand (client*)
380657,METHOD,server.c:<global>,TYPE_DECL,"void incrementErrorCount(const char *fullerr, size_t namelen) {
    struct redisError *error = raxFind(server.errors,(unsigned char*)fullerr,namelen);
    if (error == raxNotFound) {
        error = zmalloc(sizeof(*error));
        error->count = 0;
        raxInsert(server.errors,(unsigned char*)fullerr,namelen,error,NULL);
    }
    error->count++;
}",1,1,server.c,incrementErrorCount,,false,4172,4180,incrementErrorCount,,,174,"void incrementErrorCount (char*,size_t)"
380704,METHOD,server.c:<global>,TYPE_DECL,"void closeListeningSockets(int unlink_unix_socket) {
    int j;

    for (int i = 0; i < CONN_TYPE_MAX; i++) {
        connListener *listener = &server.listeners[i];
        if (listener->ct == NULL)
            continue;

        for (j = 0; j < listener->count; j++) close(listener->fd[j]);
    }

    if (server.cluster_enabled)
        for (j = 0; j < server.clistener.count; j++) close(server.clistener.fd[j]);
    if (unlink_unix_socket && server.unixsocket) {
        serverLog(LL_NOTICE,""Removing the unix socket file."");
        if (unlink(server.unixsocket) != 0)
            serverLog(LL_WARNING,""Error removing the unix socket file: %s"",strerror(errno));
    }
}",1,24,server.c,closeListeningSockets,,false,4186,4204,closeListeningSockets,,,175,void closeListeningSockets (int)
380839,METHOD,server.c:<global>,TYPE_DECL,"int prepareForShutdown(int flags) {
    if (isShutdownInitiated()) return C_ERR;

    /* When SHUTDOWN is called while the server is loading a dataset in
     * memory we need to make sure no attempt is performed to save
     * the dataset on shutdown (otherwise it could overwrite the current DB
     * with half-read data).
     *
     * Also when in Sentinel mode clear the SAVE flag and force NOSAVE. */
    if (server.loading || server.sentinel_mode)
        flags = (flags & ~SHUTDOWN_SAVE) | SHUTDOWN_NOSAVE;

    server.shutdown_flags = flags;

    serverLog(LL_NOTICE,""User requested shutdown..."");
    if (server.supervised_mode == SUPERVISED_SYSTEMD)
        redisCommunicateSystemd(""STOPPING=1\n"");

    /* If we have any replicas, let them catch up the replication offset before
     * we shut down, to avoid data loss. */
    if (!(flags & SHUTDOWN_NOW) &&
        server.shutdown_timeout != 0 &&
        !isReadyToShutdown())
    {
        server.shutdown_mstime = server.mstime + s...",1,38,server.c,prepareForShutdown,,false,4229,4263,prepareForShutdown,,,176,int prepareForShutdown (int)
380992,METHOD,server.c:<global>,TYPE_DECL,"static inline int isShutdownInitiated(void) {
    return server.shutdown_mstime != 0;
}",1,1,server.c,isShutdownInitiated,,false,4265,4267,isShutdownInitiated,,,177,int isShutdownInitiated (void)
381003,METHOD,server.c:<global>,TYPE_DECL,"int isReadyToShutdown(void) {
    if (listLength(server.slaves) == 0) return 1;  /* No replicas. */

    listIter li;
    listNode *ln;
    listRewind(server.slaves, &li);
    while ((ln = listNext(&li)) != NULL) {
        client *replica = listNodeValue(ln);
        if (replica->repl_ack_off != server.master_repl_offset) return 0;
    }
    return 1;
}",1,8,server.c,isReadyToShutdown,,false,4272,4283,isReadyToShutdown,,,178,int isReadyToShutdown (void)
381063,METHOD,server.c:<global>,TYPE_DECL,"static void cancelShutdown(void) {
    server.shutdown_asap = 0;
    server.shutdown_flags = 0;
    server.shutdown_mstime = 0;
    server.last_sig_received = 0;
    replyToClientsBlockedOnShutdown();
    unpauseActions(PAUSE_DURING_SHUTDOWN);
}",1,1,server.c,cancelShutdown,,false,4285,4292,cancelShutdown,,,179,void cancelShutdown (void)
381091,METHOD,server.c:<global>,TYPE_DECL,"int abortShutdown(void) {
    if (isShutdownInitiated()) {
        cancelShutdown();
    } else if (server.shutdown_asap) {
        /* Signal handler has requested shutdown, but it hasn't been initiated
         * yet. Just clear the flag. */
        server.shutdown_asap = 0;
    } else {
        /* Shutdown neither initiated nor requested. */
        return C_ERR;
    }
    serverLog(LL_NOTICE, ""Shutdown manually aborted."");
    return C_OK;
}",1,15,server.c,abortShutdown,,false,4295,4308,abortShutdown,,,180,int abortShutdown (void)
381141,METHOD,server.c:<global>,TYPE_DECL,"int finishShutdown(void) {

    int save = server.shutdown_flags & SHUTDOWN_SAVE;
    int nosave = server.shutdown_flags & SHUTDOWN_NOSAVE;
    int force = server.shutdown_flags & SHUTDOWN_FORCE;

    /* Log a warning for each replica that is lagging. */
    listIter replicas_iter;
    listNode *replicas_list_node;
    int num_replicas = 0, num_lagging_replicas = 0;
    listRewind(server.slaves, &replicas_iter);
    while ((replicas_list_node = listNext(&replicas_iter)) != NULL) {
        client *replica = listNodeValue(replicas_list_node);
        num_replicas++;
        if (replica->repl_ack_off != server.master_repl_offset) {
            num_lagging_replicas++;
            long lag = replica->replstate == SLAVE_STATE_ONLINE ?
                time(NULL) - replica->repl_ack_time : 0;
            serverLog(LL_NOTICE,
                      ""Lagging replica %s reported offset %lld behind master, lag=%ld, state=%s."",
                      replicationGetSlaveName(replica),
             ...",1,39,server.c,finishShutdown,,false,4313,4460,finishShutdown,,,181,int finishShutdown (void)
381760,METHOD,server.c:<global>,TYPE_DECL,"int writeCommandsDeniedByDiskError(void) {
    if (server.stop_writes_on_bgsave_err &&
        server.saveparamslen > 0 &&
        server.lastbgsave_status == C_ERR)
    {
        return DISK_ERROR_TYPE_RDB;
    } else if (server.aof_state != AOF_OFF) {
        if (server.aof_last_write_status == C_ERR) {
            return DISK_ERROR_TYPE_AOF;
        }
        /* AOF fsync error. */
        int aof_bio_fsync_status;
        atomicGet(server.aof_bio_fsync_status,aof_bio_fsync_status);
        if (aof_bio_fsync_status == C_ERR) {
            atomicGet(server.aof_bio_fsync_errno,server.aof_last_write_errno);
            return DISK_ERROR_TYPE_AOF;
        }
    }

    return DISK_ERROR_TYPE_NONE;
}",1,36,server.c,writeCommandsDeniedByDiskError,,false,4475,4495,writeCommandsDeniedByDiskError,,,182,int writeCommandsDeniedByDiskError (void)
381843,METHOD,server.c:<global>,TYPE_DECL,"sds writeCommandsGetDiskErrorMessage(int error_code) {
    sds ret = NULL;
    if (error_code == DISK_ERROR_TYPE_RDB) {
        ret = sdsdup(shared.bgsaveerr->ptr);
    } else {
        ret = sdscatfmt(sdsempty(),
                ""-MISCONF Errors writing to the AOF file: %s\r\n"",
                strerror(server.aof_last_write_errno));
    }
    return ret;
}",1,22,server.c,writeCommandsGetDiskErrorMessage,,false,4497,4507,writeCommandsGetDiskErrorMessage,,,183,sds writeCommandsGetDiskErrorMessage (int)
381880,METHOD,server.c:<global>,TYPE_DECL,"void pingCommand(client *c) {
    /* The command takes zero or one arguments. */
    if (c->argc > 2) {
        addReplyErrorArity(c);
        return;
    }

    if (c->flags & CLIENT_PUBSUB && c->resp == 2) {
        addReply(c,shared.mbulkhdr[2]);
        addReplyBulkCBuffer(c,""pong"",4);
        if (c->argc == 1)
            addReplyBulkCBuffer(c,"""",0);
        else
            addReplyBulk(c,c->argv[1]);
    } else {
        if (c->argc == 1)
            addReply(c,shared.pong);
        else
            addReplyBulk(c,c->argv[1]);
    }
}",1,19,server.c,pingCommand,,false,4511,4531,pingCommand,,,184,void pingCommand (client*)
381966,METHOD,server.c:<global>,TYPE_DECL,"void echoCommand(client *c) {
    addReplyBulk(c,c->argv[1]);
}",1,1,server.c,echoCommand,,false,4533,4535,echoCommand,,,185,void echoCommand (client*)
381978,METHOD,server.c:<global>,TYPE_DECL,"void timeCommand(client *c) {
    addReplyArrayLen(c,2);
    addReplyBulkLongLong(c, server.unixtime);
    addReplyBulkLongLong(c, server.ustime-((long long)server.unixtime)*1000000);
}",1,1,server.c,timeCommand,,false,4537,4541,timeCommand,,,186,void timeCommand (client*)
382008,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandFlags(client *c, uint64_t flags, replyFlagNames *replyFlags) {
    int count = 0, j=0;
    /* Count them so we don't have to use deferred reply. */
    while (replyFlags[j].name) {
        if (flags & replyFlags[j].flag)
            count++;
        j++;
    }

    addReplySetLen(c, count);
    j = 0;
    while (replyFlags[j].name) {
        if (flags & replyFlags[j].flag)
            addReplyStatus(c, replyFlags[j].name);
        j++;
    }
}",1,1,server.c,addReplyCommandFlags,,false,4549,4565,addReplyCommandFlags,,,189,"void addReplyCommandFlags (client*,uint64_t,replyFlagNames*)"
382074,METHOD,server.c:<global>,TYPE_DECL,"void addReplyFlagsForCommand(client *c, struct redisCommand *cmd) {
    replyFlagNames flagNames[] = {
        {CMD_WRITE,             ""write""},
        {CMD_READONLY,          ""readonly""},
        {CMD_DENYOOM,           ""denyoom""},
        {CMD_MODULE,            ""module""},
        {CMD_ADMIN,             ""admin""},
        {CMD_PUBSUB,            ""pubsub""},
        {CMD_NOSCRIPT,          ""noscript""},
        {CMD_BLOCKING,          ""blocking""},
        {CMD_LOADING,           ""loading""},
        {CMD_STALE,             ""stale""},
        {CMD_SKIP_MONITOR,      ""skip_monitor""},
        {CMD_SKIP_SLOWLOG,      ""skip_slowlog""},
        {CMD_ASKING,            ""asking""},
        {CMD_FAST,              ""fast""},
        {CMD_NO_AUTH,           ""no_auth""},
        /* {CMD_MAY_REPLICATE,     ""may_replicate""},, Hidden on purpose */
        /* {CMD_SENTINEL,          ""sentinel""}, Hidden on purpose */
        /* {CMD_ONLY_SENTINEL,     ""only_sentinel""}, Hidden on purpose */
        {CMD_NO...",1,9,server.c,addReplyFlagsForCommand,,false,4567,4597,addReplyFlagsForCommand,,,190,"void addReplyFlagsForCommand (client*,redisCommand*)"
382233,METHOD,server.c:<global>,TYPE_DECL,"void addReplyDocFlagsForCommand(client *c, struct redisCommand *cmd) {
    replyFlagNames docFlagNames[] = {
        {CMD_DOC_DEPRECATED,         ""deprecated""},
        {CMD_DOC_SYSCMD,             ""syscmd""},
        {0,NULL}
    };
    addReplyCommandFlags(c, cmd->doc_flags, docFlagNames);
}",1,9,server.c,addReplyDocFlagsForCommand,,false,4599,4606,addReplyDocFlagsForCommand,,,191,"void addReplyDocFlagsForCommand (client*,redisCommand*)"
382266,METHOD,server.c:<global>,TYPE_DECL,"void addReplyFlagsForKeyArgs(client *c, uint64_t flags) {
    replyFlagNames docFlagNames[] = {
        {CMD_KEY_RO,              ""RO""},
        {CMD_KEY_RW,              ""RW""},
        {CMD_KEY_OW,              ""OW""},
        {CMD_KEY_RM,              ""RM""},
        {CMD_KEY_ACCESS,          ""access""},
        {CMD_KEY_UPDATE,          ""update""},
        {CMD_KEY_INSERT,          ""insert""},
        {CMD_KEY_DELETE,          ""delete""},
        {CMD_KEY_NOT_KEY,         ""not_key""},
        {CMD_KEY_INCOMPLETE,      ""incomplete""},
        {CMD_KEY_VARIABLE_FLAGS,  ""variable_flags""},
        {0,NULL}
    };
    addReplyCommandFlags(c, flags, docFlagNames);
}",1,9,server.c,addReplyFlagsForKeyArgs,,false,4608,4624,addReplyFlagsForKeyArgs,,,192,"void addReplyFlagsForKeyArgs (client*,uint64_t)"
382373,METHOD,server.c:<global>,TYPE_DECL,"void addReplyFlagsForArg(client *c, uint64_t flags) {
    replyFlagNames argFlagNames[] = {
        {CMD_ARG_OPTIONAL,          ""optional""},
        {CMD_ARG_MULTIPLE,          ""multiple""},
        {CMD_ARG_MULTIPLE_TOKEN,    ""multiple_token""},
        {0,NULL}
    };
    addReplyCommandFlags(c, flags, argFlagNames);
}",1,9,server.c,addReplyFlagsForArg,,false,4639,4647,addReplyFlagsForArg,,,195,"void addReplyFlagsForArg (client*,uint64_t)"
382411,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandArgList(client *c, struct redisCommandArg *args, int num_args) {
    addReplyArrayLen(c, num_args);
    for (int j = 0; j<num_args; j++) {
        /* Count our reply len so we don't have to use deferred reply. */
        int has_display_text = 1;
        long maplen = 2;
        if (args[j].key_spec_index != -1) maplen++;
        if (args[j].token) maplen++;
        if (args[j].summary) maplen++;
        if (args[j].since) maplen++;
        if (args[j].deprecated_since) maplen++;
        if (args[j].flags) maplen++;
        if (args[j].type == ARG_TYPE_ONEOF || args[j].type == ARG_TYPE_BLOCK) {
            has_display_text = 0;
            maplen++;
        }
        if (has_display_text) maplen++;
        addReplyMapLen(c, maplen);

        addReplyBulkCString(c, ""name"");
        addReplyBulkCString(c, args[j].name);

        addReplyBulkCString(c, ""type"");
        addReplyBulkCString(c, ARG_TYPE_STR[args[j].type]);

        if (has_display_text) {
            a...",1,1,server.c,addReplyCommandArgList,,false,4649,4707,addReplyCommandArgList,,,196,"void addReplyCommandArgList (client*,redisCommandArg*,int)"
382711,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandHistory(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->num_history);
    for (int j = 0; j<cmd->num_history; j++) {
        addReplyArrayLen(c, 2);
        addReplyBulkCString(c, cmd->history[j].since);
        addReplyBulkCString(c, cmd->history[j].changes);
    }
}",1,1,server.c,addReplyCommandHistory,,false,4745,4752,addReplyCommandHistory,,,197,"void addReplyCommandHistory (client*,redisCommand*)"
382757,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandTips(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->num_tips);
    for (int j = 0; j<cmd->num_tips; j++) {
        addReplyBulkCString(c, cmd->tips[j]);
    }
}",1,1,server.c,addReplyCommandTips,,false,4754,4759,addReplyCommandTips,,,198,"void addReplyCommandTips (client*,redisCommand*)"
382789,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandKeySpecs(client *c, struct redisCommand *cmd) {
    addReplySetLen(c, cmd->key_specs_num);
    for (int i = 0; i < cmd->key_specs_num; i++) {
        int maplen = 3;
        if (cmd->key_specs[i].notes) maplen++;

        addReplyMapLen(c, maplen);

        if (cmd->key_specs[i].notes) {
            addReplyBulkCString(c, ""notes"");
            addReplyBulkCString(c,cmd->key_specs[i].notes);
        }

        addReplyBulkCString(c, ""flags"");
        addReplyFlagsForKeyArgs(c,cmd->key_specs[i].flags);

        addReplyBulkCString(c, ""begin_search"");
        switch (cmd->key_specs[i].begin_search_type) {
            case KSPEC_BS_UNKNOWN:
                addReplyMapLen(c, 2);
                addReplyBulkCString(c, ""type"");
                addReplyBulkCString(c, ""unknown"");

                addReplyBulkCString(c, ""spec"");
                addReplyMapLen(c, 0);
                break;
            case KSPEC_BS_INDEX:
                addReplyMapLen(c, 2);
              ...",1,16,server.c,addReplyCommandKeySpecs,,false,4761,4855,addReplyCommandKeySpecs,,,199,"void addReplyCommandKeySpecs (client*,redisCommand*)"
383173,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandSubCommands(client *c, struct redisCommand *cmd, void (*reply_function)(client*, struct redisCommand*), int use_map) {
    if (!cmd->subcommands_dict) {
        addReplySetLen(c, 0);
        return;
    }

    if (use_map)
        addReplyMapLen(c, dictSize(cmd->subcommands_dict));
    else
        addReplyArrayLen(c, dictSize(cmd->subcommands_dict));
    dictEntry *de;
    dictIterator *di = dictGetSafeIterator(cmd->subcommands_dict);
    while((de = dictNext(di)) != NULL) {
        struct redisCommand *sub = (struct redisCommand *)dictGetVal(de);
        if (use_map)
            addReplyBulkCBuffer(c, sub->fullname, sdslen(sub->fullname));
        reply_function(c, sub);
    }
    dictReleaseIterator(di);
}",1,26,server.c,addReplyCommandSubCommands,,false,4858,4877,addReplyCommandSubCommands,,,200,"void addReplyCommandSubCommands (client*,redisCommand*,void,int)"
383280,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandInfo(client *c, struct redisCommand *cmd) {
    if (!cmd) {
        addReplyNull(c);
    } else {
        int firstkey = 0, lastkey = 0, keystep = 0;
        if (cmd->legacy_range_key_spec.begin_search_type != KSPEC_BS_INVALID) {
            firstkey = cmd->legacy_range_key_spec.bs.index.pos;
            lastkey = cmd->legacy_range_key_spec.fk.range.lastkey;
            if (lastkey >= 0)
                lastkey += firstkey;
            keystep = cmd->legacy_range_key_spec.fk.range.keystep;
        }

        addReplyArrayLen(c, 10);
        addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
        addReplyLongLong(c, cmd->arity);
        addReplyFlagsForCommand(c, cmd);
        addReplyLongLong(c, firstkey);
        addReplyLongLong(c, lastkey);
        addReplyLongLong(c, keystep);
        addReplyCommandCategories(c, cmd);
        addReplyCommandTips(c, cmd);
        addReplyCommandKeySpecs(c, cmd);
        addReplyCommandSubCommands(c, cmd, addRepl...",1,1,server.c,addReplyCommandInfo,,false,4880,4905,addReplyCommandInfo,,,201,"void addReplyCommandInfo (client*,redisCommand*)"
383399,METHOD,server.c:<global>,TYPE_DECL,"void addReplyCommandDocs(client *c, struct redisCommand *cmd) {
    /* Count our reply len so we don't have to use deferred reply. */
    long maplen = 1;
    if (cmd->summary) maplen++;
    if (cmd->since) maplen++;
    if (cmd->flags & CMD_MODULE) maplen++;
    if (cmd->complexity) maplen++;
    if (cmd->doc_flags) maplen++;
    if (cmd->deprecated_since) maplen++;
    if (cmd->replaced_by) maplen++;
    if (cmd->history) maplen++;
#ifdef LOG_REQ_RES
    if (cmd->reply_schema) maplen++;
#endif
    if (cmd->args) maplen++;
    if (cmd->subcommands_dict) maplen++;
    addReplyMapLen(c, maplen);

    if (cmd->summary) {
        addReplyBulkCString(c, ""summary"");
        addReplyBulkCString(c, cmd->summary);
    }
    if (cmd->since) {
        addReplyBulkCString(c, ""since"");
        addReplyBulkCString(c, cmd->since);
    }

    /* Always have the group, for module commands the group is always ""module"". */
    addReplyBulkCString(c, ""group"");
    addReplyBulkCString(c, commandGroupSt...",1,21,server.c,addReplyCommandDocs,,false,4908,4977,addReplyCommandDocs,,,202,"void addReplyCommandDocs (client*,redisCommand*)"
383631,METHOD,server.c:<global>,TYPE_DECL,"void getKeysSubcommandImpl(client *c, int with_flags) {
    struct redisCommand *cmd = lookupCommand(c->argv+2,c->argc-2);
    getKeysResult result = GETKEYS_RESULT_INIT;
    int j;

    if (!cmd) {
        addReplyError(c,""Invalid command specified"");
        return;
    } else if (!doesCommandHaveKeys(cmd)) {
        addReplyError(c,""The command has no key arguments"");
        return;
    } else if ((cmd->arity > 0 && cmd->arity != c->argc-2) ||
               ((c->argc-2) < -cmd->arity))
    {
        addReplyError(c,""Invalid number of arguments specified for command"");
        return;
    }

    if (!getKeysFromCommandWithSpecs(cmd,c->argv+2,c->argc-2,GET_KEYSPEC_DEFAULT,&result)) {
        if (cmd->flags & CMD_NO_MANDATORY_KEYS) {
            addReplyArrayLen(c,0);
        } else {
            addReplyError(c,""Invalid arguments specified for command"");
        }
    } else {
        addReplyArrayLen(c,result.numkeys);
        for (j = 0; j < result.numkeys; j++) {
            i...",1,27,server.c,getKeysSubcommandImpl,,false,4980,5017,getKeysSubcommandImpl,,,203,"void getKeysSubcommandImpl (client*,int)"
383825,METHOD,server.c:<global>,TYPE_DECL,"void commandGetKeysAndFlagsCommand(client *c) {
    getKeysSubcommandImpl(c, 1);
}",1,1,server.c,commandGetKeysAndFlagsCommand,,false,5020,5022,commandGetKeysAndFlagsCommand,,,204,void commandGetKeysAndFlagsCommand (client*)
383833,METHOD,server.c:<global>,TYPE_DECL,"void getKeysSubcommand(client *c) {
    getKeysSubcommandImpl(c, 0);
}",1,1,server.c,getKeysSubcommand,,false,5025,5027,getKeysSubcommand,,,205,void getKeysSubcommand (client*)
383841,METHOD,server.c:<global>,TYPE_DECL,"void commandCommand(client *c) {
    dictIterator *di;
    dictEntry *de;

    addReplyArrayLen(c, dictSize(server.commands));
    di = dictGetIterator(server.commands);
    while ((de = dictNext(di)) != NULL) {
        addReplyCommandInfo(c, dictGetVal(de));
    }
    dictReleaseIterator(di);
}",1,24,server.c,commandCommand,,false,5030,5040,commandCommand,,,206,void commandCommand (client*)
383890,METHOD,server.c:<global>,TYPE_DECL,"void commandCountCommand(client *c) {
    addReplyLongLong(c, dictSize(server.commands));
}",1,24,server.c,commandCountCommand,,false,5043,5045,commandCountCommand,,,207,void commandCountCommand (client*)
383933,METHOD,server.c:<global>,TYPE_DECL,"int shouldFilterFromCommandList(struct redisCommand *cmd, commandListFilter *filter) {
    switch (filter->type) {
        case (COMMAND_LIST_FILTER_MODULE):
            if (!filter->cache.valid) {
                filter->cache.u.module_handle = moduleGetHandleByName(filter->arg);
                filter->cache.valid = 1;
            }
            return !moduleIsModuleCommand(filter->cache.u.module_handle, cmd);
        case (COMMAND_LIST_FILTER_ACLCAT): {
            if (!filter->cache.valid) {
                filter->cache.u.aclcat = ACLGetCommandCategoryFlagByName(filter->arg);
                filter->cache.valid = 1;
            }
            uint64_t cat = filter->cache.u.aclcat;
            if (cat == 0)
                return 1; /* Invalid ACL category */
            return (!(cmd->acl_categories & cat));
            break;
        }
        case (COMMAND_LIST_FILTER_PATTERN):
            return !stringmatchlen(filter->arg, sdslen(filter->arg), cmd->fullname, sdslen(cmd->full...",1,12,server.c,shouldFilterFromCommandList,,false,5065,5089,shouldFilterFromCommandList,,,212,"int shouldFilterFromCommandList (redisCommand*,commandListFilter*)"
384071,METHOD,server.c:<global>,TYPE_DECL,"void commandListWithFilter(client *c, dict *commands, commandListFilter filter, int *numcmds) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        if (!shouldFilterFromCommandList(cmd,&filter)) {
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            (*numcmds)++;
        }

        if (cmd->subcommands_dict) {
            commandListWithFilter(c, cmd->subcommands_dict, filter, numcmds);
        }
    }
    dictReleaseIterator(di);
}",1,1,server.c,commandListWithFilter,,false,5092,5108,commandListWithFilter,,,213,"void commandListWithFilter (client*,dict*,commandListFilter,int*)"
384131,METHOD,server.c:<global>,TYPE_DECL,"void commandListWithoutFilter(client *c, dict *commands, int *numcmds) {
    dictEntry *de;
    dictIterator *di = dictGetIterator(commands);

    while ((de = dictNext(di)) != NULL) {
        struct redisCommand *cmd = dictGetVal(de);
        addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
        (*numcmds)++;

        if (cmd->subcommands_dict) {
            commandListWithoutFilter(c, cmd->subcommands_dict, numcmds);
        }
    }
    dictReleaseIterator(di);
}",1,1,server.c,commandListWithoutFilter,,false,5111,5125,commandListWithoutFilter,,,214,"void commandListWithoutFilter (client*,dict*,int*)"
384182,METHOD,server.c:<global>,TYPE_DECL,"void commandListCommand(client *c) {

    /* Parse options. */
    int i = 2, got_filter = 0;
    commandListFilter filter = {0};
    for (; i < c->argc; i++) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (!strcasecmp(opt,""filterby"") && moreargs == 2) {
            char *filtertype = c->argv[i+1]->ptr;
            if (!strcasecmp(filtertype,""module"")) {
                filter.type = COMMAND_LIST_FILTER_MODULE;
            } else if (!strcasecmp(filtertype,""aclcat"")) {
                filter.type = COMMAND_LIST_FILTER_ACLCAT;
            } else if (!strcasecmp(filtertype,""pattern"")) {
                filter.type = COMMAND_LIST_FILTER_PATTERN;
            } else {
                addReplyErrorObject(c,shared.syntaxerr);
                return;
            }
            got_filter = 1;
            filter.arg = c->argv[i+2]->ptr;
            i += 2;
        } else {
            addReplyErrorObject(c,shared...",1,1,server.c,commandListCommand,,false,5128,5167,commandListCommand,,,215,void commandListCommand (client*)
384357,METHOD,server.c:<global>,TYPE_DECL,"void commandInfoCommand(client *c) {
    int i;

    if (c->argc == 2) {
        dictIterator *di;
        dictEntry *de;
        addReplyArrayLen(c, dictSize(server.commands));
        di = dictGetIterator(server.commands);
        while ((de = dictNext(di)) != NULL) {
            addReplyCommandInfo(c, dictGetVal(de));
        }
        dictReleaseIterator(di);
    } else {
        addReplyArrayLen(c, c->argc-2);
        for (i = 2; i < c->argc; i++) {
            addReplyCommandInfo(c, lookupCommandBySds(c->argv[i]->ptr));
        }
    }
}",1,28,server.c,commandInfoCommand,,false,5170,5188,commandInfoCommand,,,216,void commandInfoCommand (client*)
384446,METHOD,server.c:<global>,TYPE_DECL,"void commandDocsCommand(client *c) {
    int i;
    if (c->argc == 2) {
        /* Reply with an array of all commands */
        dictIterator *di;
        dictEntry *de;
        addReplyMapLen(c, dictSize(server.commands));
        di = dictGetIterator(server.commands);
        while ((de = dictNext(di)) != NULL) {
            struct redisCommand *cmd = dictGetVal(de);
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            addReplyCommandDocs(c, cmd);
        }
        dictReleaseIterator(di);
    } else {
        /* Reply with an array of the requested commands (if we find them) */
        int numcmds = 0;
        void *replylen = addReplyDeferredLen(c);
        for (i = 2; i < c->argc; i++) {
            struct redisCommand *cmd = lookupCommandBySds(c->argv[i]->ptr);
            if (!cmd)
                continue;
            addReplyBulkCBuffer(c, cmd->fullname, sdslen(cmd->fullname));
            addReplyCommandDocs(c, cmd);
            numcmds++;...",1,26,server.c,commandDocsCommand,,false,5191,5219,commandDocsCommand,,,217,void commandDocsCommand (client*)
384574,METHOD,server.c:<global>,TYPE_DECL,"void commandGetKeysCommand(client *c) {
    getKeysSubcommand(c);
}",1,1,server.c,commandGetKeysCommand,,false,5222,5224,commandGetKeysCommand,,,218,void commandGetKeysCommand (client*)
384581,METHOD,server.c:<global>,TYPE_DECL,"void commandHelpCommand(client *c) {
    const char *help[] = {
""(no subcommand)"",
""    Return details about all Redis commands."",
""COUNT"",
""    Return the total number of commands in this Redis server."",
""LIST"",
""    Return a list of all commands in this Redis server."",
""INFO [<command-name> ...]"",
""    Return details about multiple Redis commands."",
""    If no command names are given, documentation details for all"",
""    commands are returned."",
""DOCS [<command-name> ...]"",
""    Return documentation details about multiple Redis commands."",
""    If no command names are given, documentation details for all"",
""    commands are returned."",
""GETKEYS <full-command>"",
""    Return the keys from a full Redis command."",
""GETKEYSANDFLAGS <full-command>"",
""    Return the keys and the access flags from a full Redis command."",
NULL
    };

    addReplyHelp(c, help);
}",1,1,server.c,commandHelpCommand,,false,5227,5251,commandHelpCommand,,,219,void commandHelpCommand (client*)
384612,METHOD,server.c:<global>,TYPE_DECL,"void bytesToHuman(char *s, size_t size, unsigned long long n) {
    double d;

    if (n < 1024) {
        /* Bytes */
        snprintf(s,size,""%lluB"",n);
    } else if (n < (1024*1024)) {
        d = (double)n/(1024);
        snprintf(s,size,""%.2fK"",d);
    } else if (n < (1024LL*1024*1024)) {
        d = (double)n/(1024*1024);
        snprintf(s,size,""%.2fM"",d);
    } else if (n < (1024LL*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024);
        snprintf(s,size,""%.2fG"",d);
    } else if (n < (1024LL*1024*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024*1024);
        snprintf(s,size,""%.2fT"",d);
    } else if (n < (1024LL*1024*1024*1024*1024*1024)) {
        d = (double)n/(1024LL*1024*1024*1024*1024);
        snprintf(s,size,""%.2fP"",d);
    } else {
        /* Let's hope we never need this */
        snprintf(s,size,""%lluB"",n);
    }
}",1,1,server.c,bytesToHuman,,false,5255,5280,bytesToHuman,,,220,"void bytesToHuman (char*,size_t,long long unsigned)"
384782,METHOD,server.c:<global>,TYPE_DECL,"sds fillPercentileDistributionLatencies(sds info, const char* histogram_name, struct hdr_histogram* histogram) {
    info = sdscatfmt(info,""latency_percentiles_usec_%s:"",histogram_name);
    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {
        char fbuf[128];
        size_t len = snprintf(fbuf, sizeof(fbuf), ""%f"", server.latency_tracking_info_percentiles[j]);
        trimDoubleString(fbuf, len);
        info = sdscatprintf(info,""p%s=%.3f"", fbuf,
            ((double)hdr_value_at_percentile(histogram,server.latency_tracking_info_percentiles[j]))/1000.0f);
        if (j != server.latency_tracking_info_percentiles_len-1)
            info = sdscatlen(info,"","",1);
        }
    info = sdscatprintf(info,""\r\n"");
    return info;
}",1,1,server.c,fillPercentileDistributionLatencies,,false,5283,5296,fillPercentileDistributionLatencies,,,221,"sds fillPercentileDistributionLatencies (sds,char*,hdr_histogram*)"
384865,METHOD,server.c:<global>,TYPE_DECL,"const char *replstateToString(int replstate) {
    switch (replstate) {
    case SLAVE_STATE_WAIT_BGSAVE_START:
    case SLAVE_STATE_WAIT_BGSAVE_END:
        return ""wait_bgsave"";
    case SLAVE_STATE_SEND_BULK:
        return ""send_bulk"";
    case SLAVE_STATE_ONLINE:
        return ""online"";
    default:
        return """";
    }
}",1,9,server.c,replstateToString,,false,5298,5310,replstateToString,,,222,const char* replstateToString (int)
384906,METHOD,server.c:<global>,TYPE_DECL,"const char *getSafeInfoString(const char *s, size_t len, char **tmp) {
    *tmp = NULL;
    if (mempbrk(s, len, unsafe_info_chars,sizeof(unsafe_info_chars)-1)
        == NULL) return s;
    char *new = *tmp = zmalloc(len + 1);
    memcpy(new, s, len);
    new[len] = '\0';
    return memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,
                       sizeof(unsafe_info_chars)-1);
}",1,1,server.c,getSafeInfoString,,false,5320,5329,getSafeInfoString,,,227,"const char* getSafeInfoString (char*,size_t,char**)"
384960,METHOD,server.c:<global>,TYPE_DECL,"sds genRedisInfoStringCommandStats(sds info, dict *commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;
    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        char *tmpsafe;
        c = (struct redisCommand *) dictGetVal(de);
        if (c->calls || c->failed_calls || c->rejected_calls) {
            info = sdscatprintf(info,
                ""cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f""
                "",rejected_calls=%lld,failed_calls=%lld\r\n"",
                getSafeInfoString(c->fullname, sdslen(c->fullname), &tmpsafe), c->calls, c->microseconds,
                (c->calls == 0) ? 0 : ((float)c->microseconds/c->calls),
                c->rejected_calls, c->failed_calls);
            if (tmpsafe != NULL) zfree(tmpsafe);
        }
        if (c->subcommands_dict) {
            info = genRedisInfoStringCommandStats(info, c->subcommands_dict);
        }
    }
    dictReleaseIterator(di);

    return info;
}",1,1,server.c,genRedisInfoStringCommandStats,,false,5331,5355,genRedisInfoStringCommandStats,,,228,"sds genRedisInfoStringCommandStats (sds,dict*)"
385067,METHOD,server.c:<global>,TYPE_DECL,"sds genRedisInfoStringACLStats(sds info) {
    info = sdscatprintf(info,
         ""acl_access_denied_auth:%lld\r\n""
         ""acl_access_denied_cmd:%lld\r\n""
         ""acl_access_denied_key:%lld\r\n""
         ""acl_access_denied_channel:%lld\r\n"",
         server.acl_info.user_auth_failures,
         server.acl_info.invalid_cmd_accesses,
         server.acl_info.invalid_key_accesses,
         server.acl_info.invalid_channel_accesses);
    return info;
}",1,1,server.c,genRedisInfoStringACLStats,,false,5358,5369,genRedisInfoStringACLStats,,,229,sds genRedisInfoStringACLStats (sds)
385099,METHOD,server.c:<global>,TYPE_DECL,"sds genRedisInfoStringLatencyStats(sds info, dict *commands) {
    struct redisCommand *c;
    dictEntry *de;
    dictIterator *di;
    di = dictGetSafeIterator(commands);
    while((de = dictNext(di)) != NULL) {
        char *tmpsafe;
        c = (struct redisCommand *) dictGetVal(de);
        if (c->latency_histogram) {
            info = fillPercentileDistributionLatencies(info,
                getSafeInfoString(c->fullname, sdslen(c->fullname), &tmpsafe),
                c->latency_histogram);
            if (tmpsafe != NULL) zfree(tmpsafe);
        }
        if (c->subcommands_dict) {
            info = genRedisInfoStringLatencyStats(info, c->subcommands_dict);
        }
    }
    dictReleaseIterator(di);

    return info;
}",1,1,server.c,genRedisInfoStringLatencyStats,,false,5371,5392,genRedisInfoStringLatencyStats,,,230,"sds genRedisInfoStringLatencyStats (sds,dict*)"
385172,METHOD,server.c:<global>,TYPE_DECL,"void addInfoSectionsToDict(dict *section_dict, char **sections) {
    while (*sections) {
        sds section = sdsnew(*sections);
        if (dictAdd(section_dict, section, NULL)==DICT_ERR)
            sdsfree(section);
        sections++;
    }
}",1,50,server.c,addInfoSectionsToDict,,false,5395,5402,addInfoSectionsToDict,,,231,"void addInfoSectionsToDict (dict*,char**)"
385206,METHOD,server.c:<global>,TYPE_DECL,"void releaseInfoSectionDict(dict *sec) {
    if (sec != cached_default_info_sections)
        dictRelease(sec);
}",1,1,server.c,releaseInfoSectionDict,,false,5407,5410,releaseInfoSectionDict,,,234,void releaseInfoSectionDict (dict*)
385218,METHOD,server.c:<global>,TYPE_DECL,"dict *genInfoSectionDict(robj **argv, int argc, char **defaults, int *out_all, int *out_everything) {
    char *default_sections[] = {
        ""server"", ""clients"", ""memory"", ""persistence"", ""stats"", ""replication"",
        ""cpu"", ""module_list"", ""errorstats"", ""cluster"", ""keyspace"", NULL};
    if (!defaults)
        defaults = default_sections;

    if (argc == 0) {
        /* In this case we know the dict is not gonna be modified, so we cache
         * it as an optimization for a common case. */
        if (cached_default_info_sections)
            return cached_default_info_sections;
        cached_default_info_sections = dictCreate(&stringSetDictType);
        dictExpand(cached_default_info_sections, 16);
        addInfoSectionsToDict(cached_default_info_sections, defaults);
        return cached_default_info_sections;
    }

    dict *section_dict = dictCreate(&stringSetDictType);
    dictExpand(section_dict, min(argc,16));
    for (int i = 0; i < argc; i++) {
        if (!strcasec...",1,29,server.c,genInfoSectionDict,,false,5417,5452,genInfoSectionDict,,,235,"dict genInfoSectionDict (robj**,int,char**,int*,int*)"
385386,METHOD,server.c:<global>,TYPE_DECL,"sds genRedisInfoString(dict *section_dict, int all_sections, int everything) {
    sds info = sdsempty();
    time_t uptime = server.unixtime-server.stat_starttime;
    int j;
    int sections = 0;
    if (everything) all_sections = 1;

    /* Server */
    if (all_sections || (dictFind(section_dict,""server"") != NULL)) {
        static int call_uname = 1;
        static struct utsname name;
        char *mode;
        char *supervised;

        if (server.cluster_enabled) mode = ""cluster"";
        else if (server.sentinel_mode) mode = ""sentinel"";
        else mode = ""standalone"";

        if (server.supervised) {
            if (server.supervised_mode == SUPERVISED_UPSTART) supervised = ""upstart"";
            else if (server.supervised_mode == SUPERVISED_SYSTEMD) supervised = ""systemd"";
            else supervised = ""unknown"";
        } else {
            supervised = ""no"";
        }

        if (sections++) info = sdscat(info,""\r\n"");

        if (call_uname) {
            /* Uname...",1,42,server.c,genRedisInfoString,,false,5457,6261,genRedisInfoString,,,236,"sds genRedisInfoString (dict*,int,int)"
387730,METHOD,server.c:<global>,TYPE_DECL,"void infoCommand(client *c) {
    if (server.sentinel_mode) {
        sentinelInfoCommand(c);
        return;
    }
    int all_sections = 0;
    int everything = 0;
    dict *sections_dict = genInfoSectionDict(c->argv+1, c->argc-1, NULL, &all_sections, &everything);
    sds info = genRedisInfoString(sections_dict, all_sections, everything);
    addReplyVerbatim(c,info,sdslen(info),""txt"");
    sdsfree(info);
    releaseInfoSectionDict(sections_dict);
    return;
}",1,1,server.c,infoCommand,,false,6264,6277,infoCommand,,,237,void infoCommand (client*)
387788,METHOD,server.c:<global>,TYPE_DECL,"void monitorCommand(client *c) {
    if (c->flags & CLIENT_DENY_BLOCKING) {
        /**
         * A client that has CLIENT_DENY_BLOCKING flag on
         * expects a reply per command and so can't execute MONITOR. */
        addReplyError(c, ""MONITOR isn't allowed for DENY BLOCKING client"");
        return;
    }

    /* ignore MONITOR if already slave or in monitor mode */
    if (c->flags & CLIENT_SLAVE) return;

    c->flags |= (CLIENT_SLAVE|CLIENT_MONITOR);
    listAddNodeTail(server.monitors,c);
    addReply(c,shared.ok);
}",1,19,server.c,monitorCommand,,false,6279,6294,monitorCommand,,,238,void monitorCommand (client*)
387845,METHOD,server.c:<global>,TYPE_DECL,"int checkIgnoreWarning(const char *warning) {
    int argc, j;
    sds *argv = sdssplitargs(server.ignore_warnings, &argc);
    if (argv == NULL)
        return 0;

    for (j = 0; j < argc; j++) {
        char *flag = argv[j];
        if (!strcasecmp(flag, warning))
            break;
    }
    sdsfreesplitres(argv,argc);
    return j < argc;
}",1,1,server.c,checkIgnoreWarning,,false,6298,6311,checkIgnoreWarning,,,239,int checkIgnoreWarning (char*)
387899,METHOD,server.c:<global>,TYPE_DECL,"void createPidFile(void) {
    /* If pidfile requested, but no pidfile defined, use
     * default pidfile path */
    if (!server.pidfile) server.pidfile = zstrdup(CONFIG_DEFAULT_PID_FILE);

    /* Try to write the pid file in a best-effort way. */
    FILE *fp = fopen(server.pidfile,""w"");
    if (fp) {
        fprintf(fp,""%d\n"",(int)getpid());
        fclose(fp);
    } else {
        serverLog(LL_WARNING, ""Failed to write PID file: %s"", strerror(errno));
    }
}",1,50,server.c,createPidFile,,false,6348,6361,createPidFile,,,240,void createPidFile (void)
387959,METHOD,server.c:<global>,TYPE_DECL,"void daemonize(void) {
    int fd;

    if (fork() != 0) exit(0); /* parent exits */
    setsid(); /* create a new session */

    /* Every output goes to /dev/null. If Redis is daemonized but
     * the 'logfile' is set to 'stdout' in the configuration file
     * it will not log at all. */
    if ((fd = open(""/dev/null"", O_RDWR, 0)) != -1) {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
        if (fd > STDERR_FILENO) close(fd);
    }
}",1,1,server.c,daemonize,,false,6363,6378,daemonize,,,241,void daemonize (void)
388000,METHOD,server.c:<global>,TYPE_DECL,"void version(void) {
    printf(""Redis server v=%s sha=%s:%d malloc=%s bits=%d build=%llx\n"",
        REDIS_VERSION,
        redisGitSHA1(),
        atoi(redisGitDirty()) > 0,
        ZMALLOC_LIB,
        sizeof(long) == 4 ? 32 : 64,
        (unsigned long long) redisBuildId());
    exit(0);
}",1,8,server.c,version,,false,6380,6389,version,,,242,void version (void)
388030,METHOD,server.c:<global>,TYPE_DECL,"void usage(void) {
    fprintf(stderr,""Usage: ./redis-server [/path/to/redis.conf] [options] [-]\n"");
    fprintf(stderr,""       ./redis-server - (read config from stdin)\n"");
    fprintf(stderr,""       ./redis-server -v or --version\n"");
    fprintf(stderr,""       ./redis-server -h or --help\n"");
    fprintf(stderr,""       ./redis-server --test-memory <megabytes>\n"");
    fprintf(stderr,""       ./redis-server --check-system\n"");
    fprintf(stderr,""\n"");
    fprintf(stderr,""Examples:\n"");
    fprintf(stderr,""       ./redis-server (run the server with default conf)\n"");
    fprintf(stderr,""       echo 'maxmemory 128mb' | ./redis-server -\n"");
    fprintf(stderr,""       ./redis-server /etc/redis/6379.conf\n"");
    fprintf(stderr,""       ./redis-server --port 7777\n"");
    fprintf(stderr,""       ./redis-server --port 7777 --replicaof 127.0.0.1 8888\n"");
    fprintf(stderr,""       ./redis-server /etc/myredis.conf --loglevel verbose -\n"");
    fprintf(stderr,""       ./redis-server /etc/...",1,1,server.c,usage,,false,6391,6410,usage,,,243,void usage (void)
388088,METHOD,server.c:<global>,TYPE_DECL,"void redisAsciiArt(void) {
#include ""asciilogo.h""
    char *buf = zmalloc(1024*16);
    char *mode;

    if (server.cluster_enabled) mode = ""cluster"";
    else if (server.sentinel_mode) mode = ""sentinel"";
    else mode = ""standalone"";

    /* Show the ASCII logo if: log file is stdout AND stdout is a
     * tty AND syslog logging is disabled. Also show logo if the user
     * forced us to do so via redis.conf. */
    int show_logo = ((!server.syslog_enabled &&
                      server.logfile[0] == '\0' &&
                      isatty(fileno(stdout))) ||
                     server.always_show_logo);

    if (!show_logo) {
        serverLog(LL_NOTICE,
            ""Running mode=%s, port=%d."",
            mode, server.port ? server.port : server.tls_port
        );
    } else {
        snprintf(buf,1024*16,ascii_logo,
            REDIS_VERSION,
            redisGitSHA1(),
            strtol(redisGitDirty(),NULL,10) > 0,
            (sizeof(long) == 8) ? ""64"" : ""32"",
            mo...",1,27,server.c,redisAsciiArt,,false,6412,6446,redisAsciiArt,,,244,void redisAsciiArt (void)
388236,METHOD,server.c:<global>,TYPE_DECL,"connListener *listenerByType(const char *typename) {
    int conn_index;

    conn_index = connectionIndexByType(typename);
    if (conn_index < 0)
        return NULL;

    return &server.listeners[conn_index];
}",1,1,server.c,listenerByType,,false,6449,6457,listenerByType,,,245,connListener listenerByType (char*)
388260,METHOD,server.c:<global>,TYPE_DECL,"int changeListener(connListener *listener) {
    /* Close old servers */
    closeListener(listener);

    /* Just close the server if port disabled */
    if (listener->port == 0) {
        if (server.set_proc_title) redisSetProcTitle(NULL);
        return C_OK;
    }

    /* Re-create listener */
    if (connListen(listener) != C_OK) {
        return C_ERR;
    }

    /* Create event handlers */
    if (createSocketAcceptHandler(listener, listener->ct->accept_handler) != C_OK) {
        serverPanic(""Unrecoverable error creating %s accept handler."", listener->ct->get_type(NULL));
    }

    if (server.set_proc_title) redisSetProcTitle(NULL);

    return C_OK;
}",1,15,server.c,changeListener,,false,6460,6483,changeListener,,,246,int changeListener (connListener*)
388337,METHOD,server.c:<global>,TYPE_DECL,"static void sigShutdownHandler(int sig) {
    char *msg;

    switch (sig) {
    case SIGINT:
        msg = ""Received SIGINT scheduling shutdown..."";
        break;
    case SIGTERM:
        msg = ""Received SIGTERM scheduling shutdown..."";
        break;
    default:
        msg = ""Received shutdown signal, scheduling shutdown..."";
    };

    /* SIGINT is often delivered via Ctrl+C in an interactive session.
     * If we receive the signal the second time, we interpret this as
     * the user really wanting to quit ASAP without waiting to persist
     * on disk and without waiting for lagging replicas. */
    if (server.shutdown_asap && sig == SIGINT) {
        serverLogFromHandler(LL_WARNING, ""You insist... exiting now."");
        rdbRemoveTempFile(getpid(), 1);
        exit(1); /* Exit with an error since this was not a clean shutdown. */
    } else if (server.loading) {
        msg = ""Received shutdown signal during loading, scheduling shutdown."";
    }

    serverLogFromHandler...",1,29,server.c,sigShutdownHandler,,false,6485,6514,sigShutdownHandler,,,247,void sigShutdownHandler (int)
388406,METHOD,server.c:<global>,TYPE_DECL,"void setupSignalHandlers(void) {
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = sigShutdownHandler;
    sigaction(SIGTERM, &act, NULL);
    sigaction(SIGINT, &act, NULL);

    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = sigsegvHandler;
    if(server.crashlog_enabled) {
        sigaction(SIGSEGV, &act, NULL);
        sigaction(SIGBUS, &act, NULL);
        sigaction(SIGFPE, &act, NULL);
        sigaction(SIGILL, &act, NULL);
        sigaction(SIGABRT, &act, NULL);
    }
    return;
}",1,1,server.c,setupSignalHandlers,,false,6516,6538,setupSignalHandlers,,,248,void setupSignalHandlers (void)
388487,METHOD,server.c:<global>,TYPE_DECL,"void removeSignalHandlers(void) {
    struct sigaction act;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_RESETHAND;
    act.sa_handler = SIG_DFL;
    sigaction(SIGSEGV, &act, NULL);
    sigaction(SIGBUS, &act, NULL);
    sigaction(SIGFPE, &act, NULL);
    sigaction(SIGILL, &act, NULL);
    sigaction(SIGABRT, &act, NULL);
}",1,1,server.c,removeSignalHandlers,,false,6540,6550,removeSignalHandlers,,,249,void removeSignalHandlers (void)
388535,METHOD,server.c:<global>,TYPE_DECL,"static void sigKillChildHandler(int sig) {
    UNUSED(sig);
    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;
    serverLogFromHandler(level, ""Received SIGUSR1 in child, exiting now."");
    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);
}",1,4,server.c,sigKillChildHandler,,false,6556,6561,sigKillChildHandler,,,250,void sigKillChildHandler (int)
388570,METHOD,server.c:<global>,TYPE_DECL,"void setupChildSignalHandlers(void) {
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
    act.sa_handler = sigKillChildHandler;
    sigaction(SIGUSR1, &act, NULL);
}",1,1,server.c,setupChildSignalHandlers,,false,6563,6572,setupChildSignalHandlers,,,251,void setupChildSignalHandlers (void)
388596,METHOD,server.c:<global>,TYPE_DECL,"void closeChildUnusedResourceAfterFork(void) {
    closeListeningSockets(0);
    if (server.cluster_enabled && server.cluster_config_file_lock_fd != -1)
        close(server.cluster_config_file_lock_fd);  /* don't care if this fails */

    /* Clear server.pidfile, this is the parent pidfile which should not
     * be touched (or deleted) by the child (on exit / crash) */
    zfree(server.pidfile);
    server.pidfile = NULL;
}",1,1,server.c,closeChildUnusedResourceAfterFork,,false,6578,6587,closeChildUnusedResourceAfterFork,,,252,void closeChildUnusedResourceAfterFork (void)
388628,METHOD,server.c:<global>,TYPE_DECL,"int redisFork(int purpose) {
    if (isMutuallyExclusiveChildType(purpose)) {
        if (hasActiveChildProcess()) {
            errno = EEXIST;
            return -1;
        }

        openChildInfoPipe();
    }

    int childpid;
    long long start = ustime();
    if ((childpid = fork()) == 0) {
        /* Child.
         *
         * The order of setting things up follows some reasoning:
         * Setup signal handlers first because a signal could fire at any time.
         * Adjust OOM score before everything else to assist the OOM killer if
         * memory resources are low.
         */
        server.in_fork_child = purpose;
        setupChildSignalHandlers();
        setOOMScoreAdj(CONFIG_OOM_BGCHILD);
        updateDictResizePolicy();
        dismissMemoryInChild();
        closeChildUnusedResourceAfterFork();
        /* Close the reading part, so that if the parent crashes, the child will
         * get a write error and exit. */
        if (server.child_info_pipe[0] !...",1,23,server.c,redisFork,,false,6590,6658,redisFork,,,253,int redisFork (int)
388821,METHOD,server.c:<global>,TYPE_DECL,"void sendChildCowInfo(childInfoType info_type, char *pname) {
    sendChildInfoGeneric(info_type, 0, -1, pname);
}",1,1,server.c,sendChildCowInfo,,false,6660,6662,sendChildCowInfo,,,254,"void sendChildCowInfo (childInfoType,char*)"
388833,METHOD,server.c:<global>,TYPE_DECL,"void sendChildInfo(childInfoType info_type, size_t keys, char *pname) {
    sendChildInfoGeneric(info_type, keys, -1, pname);
}",1,1,server.c,sendChildInfo,,false,6664,6666,sendChildInfo,,,255,"void sendChildInfo (childInfoType,size_t,char*)"
388846,METHOD,server.c:<global>,TYPE_DECL,"void dismissMemory(void* ptr, size_t size_hint) {
    if (ptr == NULL) return;

    /* madvise(MADV_DONTNEED) can not release pages if the size of memory
     * is too small, we try to release only for the memory which the size
     * is more than half of page size. */
    if (size_hint && size_hint <= server.page_size/2) return;

    zmadvise_dontneed(ptr);
}",1,1,server.c,dismissMemory,,false,6677,6686,dismissMemory,,,256,"void dismissMemory (void*,size_t)"
388872,METHOD,server.c:<global>,TYPE_DECL,"void dismissClientMemory(client *c) {
    /* Dismiss client query buffer and static reply buffer. */
    dismissMemory(c->buf, c->buf_usable_size);
    dismissSds(c->querybuf);
    /* Dismiss argv array only if we estimate it contains a big buffer. */
    if (c->argc && c->argv_len_sum/c->argc >= server.page_size) {
        for (int i = 0; i < c->argc; i++) {
            dismissObject(c->argv[i], 0);
        }
    }
    if (c->argc) dismissMemory(c->argv, c->argc*sizeof(robj*));

    /* Dismiss the reply array only if the average buffer size is bigger
     * than a page. */
    if (listLength(c->reply) &&
        c->reply_bytes/listLength(c->reply) >= server.page_size)
    {
        listIter li;
        listNode *ln;
        listRewind(c->reply, &li);
        while ((ln = listNext(&li))) {
            clientReplyBlock *bulk = listNodeValue(ln);
            /* Default bulk size is 16k, actually it has extra data, maybe it
             * occupies 20k according to jemalloc bin size if ...",1,8,server.c,dismissClientMemory,,false,6689,6716,dismissClientMemory,,,257,void dismissClientMemory (client*)
389004,METHOD,server.c:<global>,TYPE_DECL,"void dismissMemoryInChild(void) {
    /* madvise(MADV_DONTNEED) may not work if Transparent Huge Pages is enabled. */
    if (server.thp_enabled) return;

    /* Currently we use zmadvise_dontneed only when we use jemalloc with Linux.
     * so we avoid these pointless loops when they're not going to do anything. */
#if defined(USE_JEMALLOC) && defined(__linux__)
    listIter li;
    listNode *ln;

    /* Dismiss replication buffer. We don't need to separately dismiss replication
     * backlog and replica' output buffer, because they just reference the global
     * replication buffer but don't cost real memory. */
    listRewind(server.repl_buffer_blocks, &li);
    while((ln = listNext(&li))) {
        replBufBlock *o = listNodeValue(ln);
        dismissMemory(o, o->size);
    }

    /* Dismiss all clients memory. */
    listRewind(server.clients, &li);
    while((ln = listNext(&li))) {
        client *c = listNodeValue(ln);
        dismissClientMemory(c);
    }
#endif
}",1,1,server.c,dismissMemoryInChild,,false,6722,6748,dismissMemoryInChild,,,258,void dismissMemoryInChild (void)
389015,METHOD,server.c:<global>,TYPE_DECL,"void memtest(size_t megabytes, int passes);",6,42,server.c,memtest,,false,6750,6750,memtest,,,259,"void memtest (size_t,int)"
389021,METHOD,server.c:<global>,TYPE_DECL,"int checkForSentinelMode(int argc, char **argv, char *exec_name) {
    if (strstr(exec_name,""redis-sentinel"") != NULL) return 1;

    for (int j = 1; j < argc; j++)
        if (!strcmp(argv[j],""--sentinel"")) return 1;
    return 0;
}",1,1,server.c,checkForSentinelMode,,false,6754,6760,checkForSentinelMode,,,260,"int checkForSentinelMode (int,char**,char*)"
389060,METHOD,server.c:<global>,TYPE_DECL,"void loadDataFromDisk(void) {
    long long start = ustime();
    if (server.aof_state == AOF_ON) {
        int ret = loadAppendOnlyFiles(server.aof_manifest);
        if (ret == AOF_FAILED || ret == AOF_OPEN_ERR)
            exit(1);
        if (ret != AOF_NOT_EXIST)
            serverLog(LL_NOTICE, ""DB loaded from append only file: %.3f seconds"", (float)(ustime()-start)/1000000);
    } else {
        rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;
        int rsi_is_valid = 0;
        errno = 0; /* Prevent a stale value from affecting error checking */
        int rdb_flags = RDBFLAGS_NONE;
        if (iAmMaster()) {
            /* Master may delete expired keys when loading, we should
             * propagate expire to replication backlog. */
            createReplicationBacklog();
            rdb_flags |= RDBFLAGS_FEED_REPL;
        }
        int rdb_load_ret = rdbLoad(server.rdb_filename, &rsi, rdb_flags);
        if (rdb_load_ret == RDB_OK) {
            serverLog(LL_NOTICE,""DB loaded f...",1,28,server.c,loadDataFromDisk,,false,6763,6832,loadDataFromDisk,,,261,void loadDataFromDisk (void)
389375,METHOD,server.c:<global>,TYPE_DECL,"void redisOutOfMemoryHandler(size_t allocation_size) {
    serverLog(LL_WARNING,""Out Of Memory allocating %zu bytes!"",
        allocation_size);
    serverPanic(""Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"",
        allocation_size);
}",1,4,server.c,redisOutOfMemoryHandler,,false,6834,6839,redisOutOfMemoryHandler,,,262,void redisOutOfMemoryHandler (size_t)
389408,METHOD,server.c:<global>,TYPE_DECL,"static sds redisProcTitleGetVariable(const sds varname, void *arg)
{
    if (!strcmp(varname, ""title"")) {
        return sdsnew(arg);
    } else if (!strcmp(varname, ""listen-addr"")) {
        if (server.port || server.tls_port)
            return sdscatprintf(sdsempty(), ""%s:%u"",
                                server.bindaddr_count ? server.bindaddr[0] : ""*"",
                                server.port ? server.port : server.tls_port);
        else
            return sdscatprintf(sdsempty(), ""unixsocket:%s"", server.unixsocket);
    } else if (!strcmp(varname, ""server-mode"")) {
        if (server.cluster_enabled) return sdsnew(""[cluster]"");
        else if (server.sentinel_mode) return sdsnew(""[sentinel]"");
        else return sdsempty();
    } else if (!strcmp(varname, ""config-file"")) {
        return sdsnew(server.configfile ? server.configfile : ""-"");
    } else if (!strcmp(varname, ""port"")) {
        return sdscatprintf(sdsempty(), ""%u"", server.port);
    } else if (!strcmp(varn...",1,1,server.c,redisProcTitleGetVariable,,false,6844,6869,redisProcTitleGetVariable,,,263,"sds redisProcTitleGetVariable (sds,void*)"
389568,METHOD,server.c:<global>,TYPE_DECL,"static sds expandProcTitleTemplate(const char *template, const char *title) {
    sds res = sdstemplate(template, redisProcTitleGetVariable, (void *) title);
    if (!res)
        return NULL;
    return sdstrim(res, "" "");
}",1,1,server.c,expandProcTitleTemplate,,false,6873,6878,expandProcTitleTemplate,,,264,"sds expandProcTitleTemplate (char*,char*)"
389593,METHOD,server.c:<global>,TYPE_DECL,"int validateProcTitleTemplate(const char *template) {
    int ok = 1;
    sds res = expandProcTitleTemplate(template, """");
    if (!res)
        return 0;
    if (sdslen(res) == 0) ok = 0;
    sdsfree(res);
    return ok;
}",1,1,server.c,validateProcTitleTemplate,,false,6880,6888,validateProcTitleTemplate,,,265,int validateProcTitleTemplate (char*)
389627,METHOD,server.c:<global>,TYPE_DECL,"int redisSetProcTitle(char *title) {
#ifdef USE_SETPROCTITLE
    if (!title) title = server.exec_argv[0];
    sds proc_title = expandProcTitleTemplate(server.proc_title_template, title);
    if (!proc_title) return C_ERR;  /* Not likely, proc_title_template is validated */

    setproctitle(""%s"", proc_title);
    sdsfree(proc_title);
#else
    UNUSED(title);
#endif

    return C_OK;
}",1,4,server.c,redisSetProcTitle,,false,6890,6903,redisSetProcTitle,,,266,int redisSetProcTitle (char*)
389642,METHOD,server.c:<global>,TYPE_DECL,"void redisSetCpuAffinity(const char *cpulist) {
#ifdef USE_SETCPUAFFINITY
    setcpuaffinity(cpulist);
#else
    UNUSED(cpulist);
#endif
}",1,4,server.c,redisSetCpuAffinity,,false,6905,6911,redisSetCpuAffinity,,,267,void redisSetCpuAffinity (char*)
389653,METHOD,server.c:<global>,TYPE_DECL,"int redisCommunicateSystemd(const char *sd_notify_msg) {
#ifdef HAVE_LIBSYSTEMD
    int ret = sd_notify(0, sd_notify_msg);

    if (ret == 0)
        serverLog(LL_WARNING, ""systemd supervision error: NOTIFY_SOCKET not found!"");
    else if (ret < 0)
        serverLog(LL_WARNING, ""systemd supervision error: sd_notify: %d"", ret);
    return ret;
#else
    UNUSED(sd_notify_msg);
    return 0;
#endif
}",1,4,server.c,redisCommunicateSystemd,,false,6915,6928,redisCommunicateSystemd,,,268,int redisCommunicateSystemd (char*)
389666,METHOD,server.c:<global>,TYPE_DECL,"static int redisSupervisedUpstart(void) {
    const char *upstart_job = getenv(""UPSTART_JOB"");

    if (!upstart_job) {
        serverLog(LL_WARNING,
                ""upstart supervision requested, but UPSTART_JOB not found!"");
        return 0;
    }

    serverLog(LL_NOTICE, ""supervised by upstart, will stop to signal readiness."");
    raise(SIGSTOP);
    unsetenv(""UPSTART_JOB"");
    return 1;
}",1,8,server.c,redisSupervisedUpstart,,false,6931,6944,redisSupervisedUpstart,,,269,int redisSupervisedUpstart (void)
389724,METHOD,server.c:<global>,TYPE_DECL,"static int redisSupervisedSystemd(void) {
#ifndef HAVE_LIBSYSTEMD
    serverLog(LL_WARNING,
            ""systemd supervision requested or auto-detected, but Redis is compiled without libsystemd support!"");
    return 0;
#else
    if (redisCommunicateSystemd(""STATUS=Redis is loading...\n"") <= 0)
        return 0;
    serverLog(LL_NOTICE,
        ""Supervised by systemd. Please make sure you set appropriate values for TimeoutStartSec and TimeoutStopSec in your service unit."");
    return 1;
#endif
}",1,4,server.c,redisSupervisedSystemd,,false,6947,6959,redisSupervisedSystemd,,,270,int redisSupervisedSystemd (void)
389749,METHOD,server.c:<global>,TYPE_DECL,"int redisIsSupervised(int mode) {
    int ret = 0;

    if (mode == SUPERVISED_AUTODETECT) {
        if (getenv(""UPSTART_JOB"")) {
            serverLog(LL_VERBOSE, ""Upstart supervision detected."");
            mode = SUPERVISED_UPSTART;
        } else if (getenv(""NOTIFY_SOCKET"")) {
            serverLog(LL_VERBOSE, ""Systemd supervision detected."");
            mode = SUPERVISED_SYSTEMD;
        }
    }

    switch (mode) {
        case SUPERVISED_UPSTART:
            ret = redisSupervisedUpstart();
            break;
        case SUPERVISED_SYSTEMD:
            ret = redisSupervisedSystemd();
            break;
        default:
            break;
    }

    if (ret)
        server.supervised_mode = mode;

    return ret;
}",1,16,server.c,redisIsSupervised,,false,6961,6989,redisIsSupervised,,,271,int redisIsSupervised (int)
389852,METHOD,server.c:<global>,TYPE_DECL,"int iAmMaster(void) {
    return ((!server.cluster_enabled && server.masterhost == NULL) ||
            (server.cluster_enabled && nodeIsMaster(server.cluster->myself)));
}",1,39,server.c,iAmMaster,,false,6991,6994,iAmMaster,,,272,int iAmMaster (void)
389889,METHOD,server.c:<global>,TYPE_DECL,"int main(int argc, char **argv) {
    struct timeval tv;
    int j;
    char config_from_stdin = 0;

#ifdef REDIS_TEST
    if (argc >= 3 && !strcasecmp(argv[1], ""test"")) {
        int flags = 0;
        for (j = 3; j < argc; j++) {
            char *arg = argv[j];
            if (!strcasecmp(arg, ""--accurate"")) flags |= REDIS_TEST_ACCURATE;
            else if (!strcasecmp(arg, ""--large-memory"")) flags |= REDIS_TEST_LARGE_MEMORY;
            else if (!strcasecmp(arg, ""--valgrind"")) flags |= REDIS_TEST_VALGRIND;
        }

        if (!strcasecmp(argv[2], ""all"")) {
            int numtests = sizeof(redisTests)/sizeof(struct redisTest);
            for (j = 0; j < numtests; j++) {
                redisTests[j].failed = (redisTests[j].proc(argc,argv,flags) != 0);
            }

            /* Report tests result */
            int failed_num = 0;
            for (j = 0; j < numtests; j++) {
                if (redisTests[j].failed) {
                    failed_num++;
                  ...",1,4,server.c,main,,false,7036,7365,main,,,273,"int main (int,char**)"
390922,METHOD,server.h:<global>,TYPE_DECL,<global>,1,1,server.h,server.h:<global>,,false,1,3744,<global>,,,1,
390961,METHOD,<empty>,<empty>,<empty>,1,,server.h,repl_state:<clinit>,,false,437,,<clinit>,,,14,
390973,METHOD,<empty>,<empty>,<empty>,1,,server.h,failover_state:<clinit>,,false,456,,<clinit>,,,4,
390986,METHOD,<empty>,<empty>,<empty>,1,,server.h,pause_purpose:<clinit>,,false,622,,<clinit>,,,5,
391002,METHOD,<empty>,<empty>,<empty>,1,,server.h,cluster_endpoint_type:<clinit>,,false,635,,<clinit>,,,4,
391017,METHOD,server.h:<global>,TYPE_DECL,"typedef void *(*moduleTypeLoadFunc)(struct RedisModuleIO *io, int encver);",14,73,server.h,moduleTypeLoadFunc,,false,737,737,moduleTypeLoadFunc,,,27,"void* moduleTypeLoadFunc (RedisModuleIO*,int)"
391023,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeSaveFunc)(struct RedisModuleIO *io, void *value);",14,73,server.h,moduleTypeSaveFunc,,false,738,738,moduleTypeSaveFunc,,,28,"void moduleTypeSaveFunc (RedisModuleIO*,void*)"
391029,METHOD,server.h:<global>,TYPE_DECL,"typedef int (*moduleTypeAuxLoadFunc)(struct RedisModuleIO *rdb, int encver, int when);",13,85,server.h,moduleTypeAuxLoadFunc,,false,739,739,moduleTypeAuxLoadFunc,,,29,"int moduleTypeAuxLoadFunc (RedisModuleIO*,int,int)"
391036,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeAuxSaveFunc)(struct RedisModuleIO *rdb, int when);",14,74,server.h,moduleTypeAuxSaveFunc,,false,740,740,moduleTypeAuxSaveFunc,,,30,"void moduleTypeAuxSaveFunc (RedisModuleIO*,int)"
391042,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeRewriteFunc)(struct RedisModuleIO *io, struct redisObject *key, void *value);",14,101,server.h,moduleTypeRewriteFunc,,false,741,741,moduleTypeRewriteFunc,,,31,"void moduleTypeRewriteFunc (RedisModuleIO*,redisObject*,void*)"
391049,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeDigestFunc)(struct RedisModuleDigest *digest, void *value);",14,83,server.h,moduleTypeDigestFunc,,false,742,742,moduleTypeDigestFunc,,,32,"void moduleTypeDigestFunc (RedisModuleDigest*,void*)"
391055,METHOD,server.h:<global>,TYPE_DECL,typedef size_t (*moduleTypeMemUsageFunc)(const void *value);,16,59,server.h,moduleTypeMemUsageFunc,,false,743,743,moduleTypeMemUsageFunc,,,33,size_t moduleTypeMemUsageFunc (void*)
391060,METHOD,server.h:<global>,TYPE_DECL,typedef void (*moduleTypeFreeFunc)(void *value);,14,47,server.h,moduleTypeFreeFunc,,false,744,744,moduleTypeFreeFunc,,,34,void moduleTypeFreeFunc (void*)
391065,METHOD,server.h:<global>,TYPE_DECL,"typedef size_t (*moduleTypeFreeEffortFunc)(struct redisObject *key, const void *value);",16,86,server.h,moduleTypeFreeEffortFunc,,false,745,745,moduleTypeFreeEffortFunc,,,35,"size_t moduleTypeFreeEffortFunc (redisObject*,void*)"
391071,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeUnlinkFunc)(struct redisObject *key, void *value);",14,74,server.h,moduleTypeUnlinkFunc,,false,746,746,moduleTypeUnlinkFunc,,,36,"void moduleTypeUnlinkFunc (redisObject*,void*)"
391077,METHOD,server.h:<global>,TYPE_DECL,"typedef void *(*moduleTypeCopyFunc)(struct redisObject *fromkey, struct redisObject *tokey, const void *value);",14,110,server.h,moduleTypeCopyFunc,,false,747,747,moduleTypeCopyFunc,,,37,"void* moduleTypeCopyFunc (redisObject*,redisObject*,void*)"
391084,METHOD,server.h:<global>,TYPE_DECL,"typedef int (*moduleTypeDefragFunc)(struct RedisModuleDefragCtx *ctx, struct redisObject *key, void **value);",13,108,server.h,moduleTypeDefragFunc,,false,748,748,moduleTypeDefragFunc,,,38,"int moduleTypeDefragFunc (RedisModuleDefragCtx*,redisObject*,void**)"
391091,METHOD,server.h:<global>,TYPE_DECL,"typedef size_t (*moduleTypeMemUsageFunc2)(struct RedisModuleKeyOptCtx *ctx, const void *value, size_t sample_size);",16,114,server.h,moduleTypeMemUsageFunc2,,false,749,749,moduleTypeMemUsageFunc2,,,39,"size_t moduleTypeMemUsageFunc2 (RedisModuleKeyOptCtx*,void*,size_t)"
391098,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeFreeFunc2)(struct RedisModuleKeyOptCtx *ctx, void *value);",14,82,server.h,moduleTypeFreeFunc2,,false,750,750,moduleTypeFreeFunc2,,,40,"void moduleTypeFreeFunc2 (RedisModuleKeyOptCtx*,void*)"
391104,METHOD,server.h:<global>,TYPE_DECL,"typedef size_t (*moduleTypeFreeEffortFunc2)(struct RedisModuleKeyOptCtx *ctx, const void *value);",16,96,server.h,moduleTypeFreeEffortFunc2,,false,751,751,moduleTypeFreeEffortFunc2,,,41,"size_t moduleTypeFreeEffortFunc2 (RedisModuleKeyOptCtx*,void*)"
391110,METHOD,server.h:<global>,TYPE_DECL,"typedef void (*moduleTypeUnlinkFunc2)(struct RedisModuleKeyOptCtx *ctx, void *value);",14,84,server.h,moduleTypeUnlinkFunc2,,false,752,752,moduleTypeUnlinkFunc2,,,42,"void moduleTypeUnlinkFunc2 (RedisModuleKeyOptCtx*,void*)"
391116,METHOD,server.h:<global>,TYPE_DECL,"typedef void *(*moduleTypeCopyFunc2)(struct RedisModuleKeyOptCtx *ctx, const void *value);",14,89,server.h,moduleTypeCopyFunc2,,false,753,753,moduleTypeCopyFunc2,,,43,"void* moduleTypeCopyFunc2 (RedisModuleKeyOptCtx*,void*)"
391122,METHOD,server.h:<global>,TYPE_DECL,"typedef int (*moduleTypeAuthCallback)(struct RedisModuleCtx *ctx, void *username, void *password, const char **err);",13,115,server.h,moduleTypeAuthCallback,,false,754,754,moduleTypeAuthCallback,,,44,"int moduleTypeAuthCallback (RedisModuleCtx*,void*,void*,char**)"
391153,METHOD,<empty>,<empty>,<empty>,1,,server.h,RedisModuleType:<clinit>,,false,759,,<clinit>,,,23,
391204,METHOD,<empty>,<empty>,<empty>,1,,server.h,RedisModuleDigest:<clinit>,,false,860,,<clinit>,,,6,
391218,METHOD,server.h:<global>,TYPE_DECL,char *getObjectTypeName(robj*);,6,30,server.h,getObjectTypeName,,false,912,912,getObjectTypeName,,,55,char* getObjectTypeName (robj*)
391228,METHOD,<empty>,<empty>,<empty>,1,,server.h,clientReplyBlock:<clinit>,,false,929,,<clinit>,,,4,
391241,METHOD,<empty>,<empty>,<empty>,1,,server.h,replBufBlock:<clinit>,,false,953,,<clinit>,,,7,
391405,METHOD,<empty>,<empty>,<empty>,1,,server.h,client:<clinit>,,false,1153,,<clinit>,,,89,
391532,METHOD,<empty>,<empty>,<empty>,1,,server.h,sharedObjectsStruct:<clinit>,,false,1310,,<clinit>,,,94,
391578,METHOD,<empty>,<empty>,<empty>,1,,server.h,zskiplistNode:<clinit>,,false,1336,,<clinit>,,,7,
391652,METHOD,<empty>,<empty>,<empty>,1,,server.h,replicationErrorBehavior:<clinit>,,false,1427,,<clinit>,,,4,
391665,METHOD,<empty>,<empty>,<empty>,1,,server.h,rdbSaveInfo:<clinit>,,false,1441,,<clinit>,,,5,
391704,METHOD,<empty>,<empty>,<empty>,1,,server.h,aof_file_type:<clinit>,,false,1487,,<clinit>,,,4,
391891,METHOD,<empty>,<empty>,<empty>,5,,server.h,redisServer.inst_metric:<clinit>,,false,1700,,<clinit>,,,5,
392173,METHOD,<empty>,<empty>,<empty>,1,,server.h,redisServer:<clinit>,,false,1534,,<clinit>,,,424,
392248,METHOD,<empty>,<empty>,<empty>,1,,server.h,getKeysResult:<clinit>,,false,2064,,<clinit>,,,5,
392262,METHOD,<empty>,<empty>,<empty>,1,,server.h,kspec_bs_type:<clinit>,,false,2092,,<clinit>,,,5,
392275,METHOD,<empty>,<empty>,<empty>,1,,server.h,kspec_fk_type:<clinit>,,false,2100,,<clinit>,,,5,
392334,METHOD,server.h:<global>,TYPE_DECL,typedef void redisCommandProc(client *c);,14,40,server.h,redisCommandProc,,false,2215,2215,redisCommandProc,,,137,void redisCommandProc (client*)
392339,METHOD,server.h:<global>,TYPE_DECL,"typedef int redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",13,100,server.h,redisGetKeysProc,,false,2216,2216,redisGetKeysProc,,,138,"int redisGetKeysProc (redisCommand*,robj**,int,getKeysResult*)"
392454,METHOD,server.h:<global>,TYPE_DECL,void populateCommandLegacyRangeSpec(struct redisCommand *c);,6,59,server.h,populateCommandLegacyRangeSpec,,false,2463,2463,populateCommandLegacyRangeSpec,,,177,void populateCommandLegacyRangeSpec (redisCommand*)
392459,METHOD,server.h:<global>,TYPE_DECL,void moduleInitModulesSystem(void);,6,34,server.h,moduleInitModulesSystem,,false,2466,2466,moduleInitModulesSystem,,,178,void moduleInitModulesSystem (void)
392464,METHOD,server.h:<global>,TYPE_DECL,void moduleInitModulesSystemLast(void);,6,38,server.h,moduleInitModulesSystemLast,,false,2467,2467,moduleInitModulesSystemLast,,,179,void moduleInitModulesSystemLast (void)
392469,METHOD,server.h:<global>,TYPE_DECL,void modulesCron(void);,6,22,server.h,modulesCron,,false,2468,2468,modulesCron,,,180,void modulesCron (void)
392474,METHOD,server.h:<global>,TYPE_DECL,"int moduleLoad(const char *path, void **argv, int argc, int is_loadex);",5,70,server.h,moduleLoad,,false,2469,2469,moduleLoad,,,181,"int moduleLoad (char*,void**,int,int)"
392482,METHOD,server.h:<global>,TYPE_DECL,"int moduleUnload(sds name, const char **errmsg);",5,47,server.h,moduleUnload,,false,2470,2470,moduleUnload,,,182,"int moduleUnload (sds,char**)"
392488,METHOD,server.h:<global>,TYPE_DECL,void moduleLoadFromQueue(void);,6,30,server.h,moduleLoadFromQueue,,false,2471,2471,moduleLoadFromQueue,,,183,void moduleLoadFromQueue (void)
392493,METHOD,server.h:<global>,TYPE_DECL,"int moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,102,server.h,moduleGetCommandKeysViaAPI,,false,2472,2472,moduleGetCommandKeysViaAPI,,,184,"int moduleGetCommandKeysViaAPI (redisCommand*,robj**,int,getKeysResult*)"
392501,METHOD,server.h:<global>,TYPE_DECL,"int moduleGetCommandChannelsViaAPI(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,106,server.h,moduleGetCommandChannelsViaAPI,,false,2473,2473,moduleGetCommandChannelsViaAPI,,,185,"int moduleGetCommandChannelsViaAPI (redisCommand*,robj**,int,getKeysResult*)"
392509,METHOD,server.h:<global>,TYPE_DECL,moduleType *moduleTypeLookupModuleByID(uint64_t id);,12,51,server.h,moduleTypeLookupModuleByID,,false,2474,2474,moduleTypeLookupModuleByID,,,186,moduleType* moduleTypeLookupModuleByID (uint64_t)
392514,METHOD,server.h:<global>,TYPE_DECL,moduleType *moduleTypeLookupModuleByName(const char *name);,12,58,server.h,moduleTypeLookupModuleByName,,false,2475,2475,moduleTypeLookupModuleByName,,,187,moduleType* moduleTypeLookupModuleByName (char*)
392519,METHOD,server.h:<global>,TYPE_DECL,moduleType *moduleTypeLookupModuleByNameIgnoreCase(const char *name);,12,68,server.h,moduleTypeLookupModuleByNameIgnoreCase,,false,2476,2476,moduleTypeLookupModuleByNameIgnoreCase,,,188,moduleType* moduleTypeLookupModuleByNameIgnoreCase (char*)
392524,METHOD,server.h:<global>,TYPE_DECL,"void moduleTypeNameByID(char *name, uint64_t moduleid);",6,54,server.h,moduleTypeNameByID,,false,2477,2477,moduleTypeNameByID,,,189,"void moduleTypeNameByID (char*,uint64_t)"
392530,METHOD,server.h:<global>,TYPE_DECL,const char *moduleTypeModuleName(moduleType *mt);,12,48,server.h,moduleTypeModuleName,,false,2478,2478,moduleTypeModuleName,,,190,char* moduleTypeModuleName (moduleType*)
392535,METHOD,server.h:<global>,TYPE_DECL,const char *moduleNameFromCommand(struct redisCommand *cmd);,12,59,server.h,moduleNameFromCommand,,false,2479,2479,moduleNameFromCommand,,,191,char* moduleNameFromCommand (redisCommand*)
392540,METHOD,server.h:<global>,TYPE_DECL,void moduleFreeContext(struct RedisModuleCtx *ctx);,6,50,server.h,moduleFreeContext,,false,2480,2480,moduleFreeContext,,,192,void moduleFreeContext (RedisModuleCtx*)
392545,METHOD,server.h:<global>,TYPE_DECL,void moduleCallCommandUnblockedHandler(client *c);,6,49,server.h,moduleCallCommandUnblockedHandler,,false,2481,2481,moduleCallCommandUnblockedHandler,,,193,void moduleCallCommandUnblockedHandler (client*)
392550,METHOD,server.h:<global>,TYPE_DECL,void unblockClientFromModule(client *c);,6,39,server.h,unblockClientFromModule,,false,2482,2482,unblockClientFromModule,,,194,void unblockClientFromModule (client*)
392555,METHOD,server.h:<global>,TYPE_DECL,void moduleHandleBlockedClients(void);,6,37,server.h,moduleHandleBlockedClients,,false,2483,2483,moduleHandleBlockedClients,,,195,void moduleHandleBlockedClients (void)
392560,METHOD,server.h:<global>,TYPE_DECL,void moduleBlockedClientTimedOut(client *c);,6,43,server.h,moduleBlockedClientTimedOut,,false,2484,2484,moduleBlockedClientTimedOut,,,196,void moduleBlockedClientTimedOut (client*)
392565,METHOD,server.h:<global>,TYPE_DECL,"void modulePipeReadable(aeEventLoop *el, int fd, void *privdata, int mask);",6,74,server.h,modulePipeReadable,,false,2485,2485,modulePipeReadable,,,197,"void modulePipeReadable (aeEventLoop*,int,void*,int)"
392573,METHOD,server.h:<global>,TYPE_DECL,size_t moduleCount(void);,8,24,server.h,moduleCount,,false,2486,2486,moduleCount,,,198,size_t moduleCount (void)
392578,METHOD,server.h:<global>,TYPE_DECL,void moduleAcquireGIL(void);,6,27,server.h,moduleAcquireGIL,,false,2487,2487,moduleAcquireGIL,,,199,void moduleAcquireGIL (void)
392583,METHOD,server.h:<global>,TYPE_DECL,int moduleTryAcquireGIL(void);,5,29,server.h,moduleTryAcquireGIL,,false,2488,2488,moduleTryAcquireGIL,,,200,int moduleTryAcquireGIL (void)
392588,METHOD,server.h:<global>,TYPE_DECL,void moduleReleaseGIL(void);,6,27,server.h,moduleReleaseGIL,,false,2489,2489,moduleReleaseGIL,,,201,void moduleReleaseGIL (void)
392593,METHOD,server.h:<global>,TYPE_DECL,"void moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid);",6,80,server.h,moduleNotifyKeyspaceEvent,,false,2490,2490,moduleNotifyKeyspaceEvent,,,202,"void moduleNotifyKeyspaceEvent (int,char*,robj*,int)"
392601,METHOD,server.h:<global>,TYPE_DECL,void firePostExecutionUnitJobs(void);,6,36,server.h,firePostExecutionUnitJobs,,false,2491,2491,firePostExecutionUnitJobs,,,203,void firePostExecutionUnitJobs (void)
392606,METHOD,server.h:<global>,TYPE_DECL,void moduleCallCommandFilters(client *c);,6,40,server.h,moduleCallCommandFilters,,false,2492,2492,moduleCallCommandFilters,,,204,void moduleCallCommandFilters (client*)
392611,METHOD,server.h:<global>,TYPE_DECL,void modulePostExecutionUnitOperations(void);,6,44,server.h,modulePostExecutionUnitOperations,,false,2493,2493,modulePostExecutionUnitOperations,,,205,void modulePostExecutionUnitOperations (void)
392616,METHOD,server.h:<global>,TYPE_DECL,"void ModuleForkDoneHandler(int exitcode, int bysignal);",6,54,server.h,ModuleForkDoneHandler,,false,2494,2494,ModuleForkDoneHandler,,,206,"void ModuleForkDoneHandler (int,int)"
392622,METHOD,server.h:<global>,TYPE_DECL,"int TerminateModuleForkChild(int child_pid, int wait);",5,53,server.h,TerminateModuleForkChild,,false,2495,2495,TerminateModuleForkChild,,,207,"int TerminateModuleForkChild (int,int)"
392628,METHOD,server.h:<global>,TYPE_DECL,"ssize_t rdbSaveModulesAux(rio *rdb, int when);",9,45,server.h,rdbSaveModulesAux,,false,2496,2496,rdbSaveModulesAux,,,208,"ssize_t rdbSaveModulesAux (rio*,int)"
392634,METHOD,server.h:<global>,TYPE_DECL,int moduleAllDatatypesHandleErrors(void);,5,40,server.h,moduleAllDatatypesHandleErrors,,false,2497,2497,moduleAllDatatypesHandleErrors,,,209,int moduleAllDatatypesHandleErrors (void)
392639,METHOD,server.h:<global>,TYPE_DECL,int moduleAllModulesHandleReplAsyncLoad(void);,5,45,server.h,moduleAllModulesHandleReplAsyncLoad,,false,2498,2498,moduleAllModulesHandleReplAsyncLoad,,,210,int moduleAllModulesHandleReplAsyncLoad (void)
392644,METHOD,server.h:<global>,TYPE_DECL,"sds modulesCollectInfo(sds info, dict *sections_dict, int for_crash_report, int sections);",5,89,server.h,modulesCollectInfo,,false,2499,2499,modulesCollectInfo,,,211,"sds modulesCollectInfo (sds,dict*,int,int)"
392652,METHOD,server.h:<global>,TYPE_DECL,"void moduleFireServerEvent(uint64_t eid, int subid, void *data);",6,63,server.h,moduleFireServerEvent,,false,2500,2500,moduleFireServerEvent,,,212,"void moduleFireServerEvent (uint64_t,int,void*)"
392659,METHOD,server.h:<global>,TYPE_DECL,void processModuleLoadingProgressEvent(int is_aof);,6,50,server.h,processModuleLoadingProgressEvent,,false,2501,2501,processModuleLoadingProgressEvent,,,213,void processModuleLoadingProgressEvent (int)
392664,METHOD,server.h:<global>,TYPE_DECL,"int moduleTryServeClientBlockedOnKey(client *c, robj *key);",5,58,server.h,moduleTryServeClientBlockedOnKey,,false,2502,2502,moduleTryServeClientBlockedOnKey,,,214,"int moduleTryServeClientBlockedOnKey (client*,robj*)"
392670,METHOD,server.h:<global>,TYPE_DECL,void moduleUnblockClient(client *c);,6,35,server.h,moduleUnblockClient,,false,2503,2503,moduleUnblockClient,,,215,void moduleUnblockClient (client*)
392675,METHOD,server.h:<global>,TYPE_DECL,int moduleBlockedClientMayTimeout(client *c);,5,44,server.h,moduleBlockedClientMayTimeout,,false,2504,2504,moduleBlockedClientMayTimeout,,,216,int moduleBlockedClientMayTimeout (client*)
392680,METHOD,server.h:<global>,TYPE_DECL,int moduleClientIsBlockedOnKeys(client *c);,5,42,server.h,moduleClientIsBlockedOnKeys,,false,2505,2505,moduleClientIsBlockedOnKeys,,,217,int moduleClientIsBlockedOnKeys (client*)
392685,METHOD,server.h:<global>,TYPE_DECL,void moduleNotifyUserChanged(client *c);,6,39,server.h,moduleNotifyUserChanged,,false,2506,2506,moduleNotifyUserChanged,,,218,void moduleNotifyUserChanged (client*)
392690,METHOD,server.h:<global>,TYPE_DECL,"void moduleNotifyKeyUnlink(robj *key, robj *val, int dbid, int flags);",6,69,server.h,moduleNotifyKeyUnlink,,false,2507,2507,moduleNotifyKeyUnlink,,,219,"void moduleNotifyKeyUnlink (robj*,robj*,int,int)"
392698,METHOD,server.h:<global>,TYPE_DECL,"size_t moduleGetFreeEffort(robj *key, robj *val, int dbid);",8,58,server.h,moduleGetFreeEffort,,false,2508,2508,moduleGetFreeEffort,,,220,"size_t moduleGetFreeEffort (robj*,robj*,int)"
392705,METHOD,server.h:<global>,TYPE_DECL,"size_t moduleGetMemUsage(robj *key, robj *val, size_t sample_size, int dbid);",8,76,server.h,moduleGetMemUsage,,false,2509,2509,moduleGetMemUsage,,,221,"size_t moduleGetMemUsage (robj*,robj*,size_t,int)"
392713,METHOD,server.h:<global>,TYPE_DECL,"robj *moduleTypeDupOrReply(client *c, robj *fromkey, robj *tokey, int todb, robj *value);",6,88,server.h,moduleTypeDupOrReply,,false,2510,2510,moduleTypeDupOrReply,,,222,"robj* moduleTypeDupOrReply (client*,robj*,robj*,int,robj*)"
392722,METHOD,server.h:<global>,TYPE_DECL,"int moduleDefragValue(robj *key, robj *obj, int dbid);",5,53,server.h,moduleDefragValue,,false,2511,2511,moduleDefragValue,,,223,"int moduleDefragValue (robj*,robj*,int)"
392729,METHOD,server.h:<global>,TYPE_DECL,"int moduleLateDefrag(robj *key, robj *value, unsigned long *cursor, long long endtime, int dbid);",5,96,server.h,moduleLateDefrag,,false,2512,2512,moduleLateDefrag,,,224,"int moduleLateDefrag (robj*,robj*,long unsigned*,long long,int)"
392738,METHOD,server.h:<global>,TYPE_DECL,void moduleDefragGlobals(void);,6,30,server.h,moduleDefragGlobals,,false,2513,2513,moduleDefragGlobals,,,225,void moduleDefragGlobals (void)
392743,METHOD,server.h:<global>,TYPE_DECL,void *moduleGetHandleByName(char *modulename);,6,45,server.h,moduleGetHandleByName,,false,2514,2514,moduleGetHandleByName,,,226,void* moduleGetHandleByName (char*)
392748,METHOD,server.h:<global>,TYPE_DECL,"int moduleIsModuleCommand(void *module_handle, struct redisCommand *cmd);",5,72,server.h,moduleIsModuleCommand,,false,2515,2515,moduleIsModuleCommand,,,227,"int moduleIsModuleCommand (void*,redisCommand*)"
392754,METHOD,server.h:<global>,TYPE_DECL,long long ustime(void);,11,22,server.h,ustime,,false,2518,2518,ustime,,,228,long long ustime (void)
392759,METHOD,server.h:<global>,TYPE_DECL,mstime_t mstime(void);,10,21,server.h,mstime,,false,2519,2519,mstime,,,229,mstime_t mstime (void)
392764,METHOD,server.h:<global>,TYPE_DECL,mstime_t commandTimeSnapshot(void);,10,34,server.h,commandTimeSnapshot,,false,2520,2520,commandTimeSnapshot,,,230,mstime_t commandTimeSnapshot (void)
392769,METHOD,server.h:<global>,TYPE_DECL,"void getRandomHexChars(char *p, size_t len);",6,43,server.h,getRandomHexChars,,false,2521,2521,getRandomHexChars,,,231,"void getRandomHexChars (char*,size_t)"
392775,METHOD,server.h:<global>,TYPE_DECL,"void getRandomBytes(unsigned char *p, size_t len);",6,49,server.h,getRandomBytes,,false,2522,2522,getRandomBytes,,,232,"void getRandomBytes (unsigned char*,size_t)"
392781,METHOD,server.h:<global>,TYPE_DECL,"uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);",10,64,server.h,crc64,,false,2523,2523,crc64,,,233,"uint64_t crc64 (uint64_t,unsigned char*,uint64_t)"
392788,METHOD,server.h:<global>,TYPE_DECL,void exitFromChild(int retcode);,6,31,server.h,exitFromChild,,false,2524,2524,exitFromChild,,,234,void exitFromChild (int)
392793,METHOD,server.h:<global>,TYPE_DECL,"long long redisPopcount(void *s, long count);",11,44,server.h,redisPopcount,,false,2525,2525,redisPopcount,,,235,"long long redisPopcount (void*,long)"
392799,METHOD,server.h:<global>,TYPE_DECL,int redisSetProcTitle(char *title);,5,34,server.h,redisSetProcTitle,,false,2526,2526,redisSetProcTitle,,,236,int redisSetProcTitle (char*)
392804,METHOD,server.h:<global>,TYPE_DECL,int validateProcTitleTemplate(const char *template);,5,51,server.h,validateProcTitleTemplate,,false,2527,2527,validateProcTitleTemplate,,,237,int validateProcTitleTemplate (char*)
392809,METHOD,server.h:<global>,TYPE_DECL,int redisCommunicateSystemd(const char *sd_notify_msg);,5,54,server.h,redisCommunicateSystemd,,false,2528,2528,redisCommunicateSystemd,,,238,int redisCommunicateSystemd (char*)
392814,METHOD,server.h:<global>,TYPE_DECL,void redisSetCpuAffinity(const char *cpulist);,6,45,server.h,redisSetCpuAffinity,,false,2529,2529,redisSetCpuAffinity,,,239,void redisSetCpuAffinity (char*)
392819,METHOD,server.h:<global>,TYPE_DECL,client *createClient(connection *conn);,8,38,server.h,createClient,,false,2535,2535,createClient,,,240,client* createClient (connection*)
392824,METHOD,server.h:<global>,TYPE_DECL,void freeClient(client *c);,6,26,server.h,freeClient,,false,2536,2536,freeClient,,,241,void freeClient (client*)
392829,METHOD,server.h:<global>,TYPE_DECL,void freeClientAsync(client *c);,6,31,server.h,freeClientAsync,,false,2537,2537,freeClientAsync,,,242,void freeClientAsync (client*)
392834,METHOD,server.h:<global>,TYPE_DECL,"void logInvalidUseAndFreeClientAsync(client *c, const char *fmt, ...);",6,69,server.h,logInvalidUseAndFreeClientAsync,,false,2538,2538,logInvalidUseAndFreeClientAsync,,,243,"void logInvalidUseAndFreeClientAsync (client*,char*...)"
392840,METHOD,server.h:<global>,TYPE_DECL,int beforeNextClient(client *c);,5,31,server.h,beforeNextClient,,false,2539,2539,beforeNextClient,,,244,int beforeNextClient (client*)
392845,METHOD,server.h:<global>,TYPE_DECL,void clearClientConnectionState(client *c);,6,42,server.h,clearClientConnectionState,,false,2540,2540,clearClientConnectionState,,,245,void clearClientConnectionState (client*)
392850,METHOD,server.h:<global>,TYPE_DECL,void resetClient(client *c);,6,27,server.h,resetClient,,false,2541,2541,resetClient,,,246,void resetClient (client*)
392855,METHOD,server.h:<global>,TYPE_DECL,void freeClientOriginalArgv(client *c);,6,38,server.h,freeClientOriginalArgv,,false,2542,2542,freeClientOriginalArgv,,,247,void freeClientOriginalArgv (client*)
392860,METHOD,server.h:<global>,TYPE_DECL,void freeClientArgv(client *c);,6,30,server.h,freeClientArgv,,false,2543,2543,freeClientArgv,,,248,void freeClientArgv (client*)
392865,METHOD,server.h:<global>,TYPE_DECL,void sendReplyToClient(connection *conn);,6,40,server.h,sendReplyToClient,,false,2544,2544,sendReplyToClient,,,249,void sendReplyToClient (connection*)
392870,METHOD,server.h:<global>,TYPE_DECL,void *addReplyDeferredLen(client *c);,6,36,server.h,addReplyDeferredLen,,false,2545,2545,addReplyDeferredLen,,,250,void* addReplyDeferredLen (client*)
392875,METHOD,server.h:<global>,TYPE_DECL,"void setDeferredArrayLen(client *c, void *node, long length);",6,60,server.h,setDeferredArrayLen,,false,2546,2546,setDeferredArrayLen,,,251,"void setDeferredArrayLen (client*,void*,long)"
392882,METHOD,server.h:<global>,TYPE_DECL,"void setDeferredMapLen(client *c, void *node, long length);",6,58,server.h,setDeferredMapLen,,false,2547,2547,setDeferredMapLen,,,252,"void setDeferredMapLen (client*,void*,long)"
392889,METHOD,server.h:<global>,TYPE_DECL,"void setDeferredSetLen(client *c, void *node, long length);",6,58,server.h,setDeferredSetLen,,false,2548,2548,setDeferredSetLen,,,253,"void setDeferredSetLen (client*,void*,long)"
392896,METHOD,server.h:<global>,TYPE_DECL,"void setDeferredAttributeLen(client *c, void *node, long length);",6,64,server.h,setDeferredAttributeLen,,false,2549,2549,setDeferredAttributeLen,,,254,"void setDeferredAttributeLen (client*,void*,long)"
392903,METHOD,server.h:<global>,TYPE_DECL,"void setDeferredPushLen(client *c, void *node, long length);",6,59,server.h,setDeferredPushLen,,false,2550,2550,setDeferredPushLen,,,255,"void setDeferredPushLen (client*,void*,long)"
392910,METHOD,server.h:<global>,TYPE_DECL,int processInputBuffer(client *c);,5,33,server.h,processInputBuffer,,false,2551,2551,processInputBuffer,,,256,int processInputBuffer (client*)
392915,METHOD,server.h:<global>,TYPE_DECL,"void acceptCommonHandler(connection *conn, int flags, char *ip);",6,63,server.h,acceptCommonHandler,,false,2552,2552,acceptCommonHandler,,,257,"void acceptCommonHandler (connection*,int,char*)"
392922,METHOD,server.h:<global>,TYPE_DECL,void readQueryFromClient(connection *conn);,6,42,server.h,readQueryFromClient,,false,2553,2553,readQueryFromClient,,,258,void readQueryFromClient (connection*)
392927,METHOD,server.h:<global>,TYPE_DECL,int prepareClientToWrite(client *c);,5,35,server.h,prepareClientToWrite,,false,2554,2554,prepareClientToWrite,,,259,int prepareClientToWrite (client*)
392932,METHOD,server.h:<global>,TYPE_DECL,void addReplyNull(client *c);,6,28,server.h,addReplyNull,,false,2555,2555,addReplyNull,,,260,void addReplyNull (client*)
392937,METHOD,server.h:<global>,TYPE_DECL,void addReplyNullArray(client *c);,6,33,server.h,addReplyNullArray,,false,2556,2556,addReplyNullArray,,,261,void addReplyNullArray (client*)
392942,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBool(client *c, int b);",6,35,server.h,addReplyBool,,false,2557,2557,addReplyBool,,,262,"void addReplyBool (client*,int)"
392948,METHOD,server.h:<global>,TYPE_DECL,"void addReplyVerbatim(client *c, const char *s, size_t len, const char *ext);",6,76,server.h,addReplyVerbatim,,false,2558,2558,addReplyVerbatim,,,263,"void addReplyVerbatim (client*,char*,size_t,char*)"
392956,METHOD,server.h:<global>,TYPE_DECL,"void addReplyProto(client *c, const char *s, size_t len);",6,56,server.h,addReplyProto,,false,2559,2559,addReplyProto,,,264,"void addReplyProto (client*,char*,size_t)"
392963,METHOD,server.h:<global>,TYPE_DECL,"void AddReplyFromClient(client *c, client *src);",6,47,server.h,AddReplyFromClient,,false,2560,2560,AddReplyFromClient,,,265,"void AddReplyFromClient (client*,client*)"
392969,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBulk(client *c, robj *obj);",6,39,server.h,addReplyBulk,,false,2561,2561,addReplyBulk,,,266,"void addReplyBulk (client*,robj*)"
392975,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBulkCString(client *c, const char *s);",6,50,server.h,addReplyBulkCString,,false,2562,2562,addReplyBulkCString,,,267,"void addReplyBulkCString (client*,char*)"
392981,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBulkCBuffer(client *c, const void *p, size_t len);",6,62,server.h,addReplyBulkCBuffer,,false,2563,2563,addReplyBulkCBuffer,,,268,"void addReplyBulkCBuffer (client*,void*,size_t)"
392988,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBulkLongLong(client *c, long long ll);",6,50,server.h,addReplyBulkLongLong,,false,2564,2564,addReplyBulkLongLong,,,269,"void addReplyBulkLongLong (client*,long long)"
392994,METHOD,server.h:<global>,TYPE_DECL,"void addReply(client *c, robj *obj);",6,35,server.h,addReply,,false,2565,2565,addReply,,,270,"void addReply (client*,robj*)"
393000,METHOD,server.h:<global>,TYPE_DECL,"void addReplyStatusLength(client *c, const char *s, size_t len);",6,63,server.h,addReplyStatusLength,,false,2566,2566,addReplyStatusLength,,,271,"void addReplyStatusLength (client*,char*,size_t)"
393007,METHOD,server.h:<global>,TYPE_DECL,"void addReplySds(client *c, sds s);",6,34,server.h,addReplySds,,false,2567,2567,addReplySds,,,272,"void addReplySds (client*,sds)"
393013,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBulkSds(client *c, sds s);",6,38,server.h,addReplyBulkSds,,false,2568,2568,addReplyBulkSds,,,273,"void addReplyBulkSds (client*,sds)"
393019,METHOD,server.h:<global>,TYPE_DECL,"void setDeferredReplyBulkSds(client *c, void *node, sds s);",6,58,server.h,setDeferredReplyBulkSds,,false,2569,2569,setDeferredReplyBulkSds,,,274,"void setDeferredReplyBulkSds (client*,void*,sds)"
393026,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorObject(client *c, robj *err);",6,46,server.h,addReplyErrorObject,,false,2570,2570,addReplyErrorObject,,,275,"void addReplyErrorObject (client*,robj*)"
393032,METHOD,server.h:<global>,TYPE_DECL,"void addReplyOrErrorObject(client *c, robj *reply);",6,50,server.h,addReplyOrErrorObject,,false,2571,2571,addReplyOrErrorObject,,,276,"void addReplyOrErrorObject (client*,robj*)"
393038,METHOD,server.h:<global>,TYPE_DECL,"void afterErrorReply(client *c, const char *s, size_t len, int flags);",6,69,server.h,afterErrorReply,,false,2572,2572,afterErrorReply,,,277,"void afterErrorReply (client*,char*,size_t,int)"
393046,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorFormatInternal(client *c, int flags, const char *fmt, va_list ap);",6,83,server.h,addReplyErrorFormatInternal,,false,2573,2573,addReplyErrorFormatInternal,,,278,"void addReplyErrorFormatInternal (client*,int,char*,va_list)"
393054,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorSdsEx(client *c, sds err, int flags);",6,54,server.h,addReplyErrorSdsEx,,false,2574,2574,addReplyErrorSdsEx,,,279,"void addReplyErrorSdsEx (client*,sds,int)"
393061,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorSds(client *c, sds err);",6,41,server.h,addReplyErrorSds,,false,2575,2575,addReplyErrorSds,,,280,"void addReplyErrorSds (client*,sds)"
393067,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorSdsSafe(client *c, sds err);",6,45,server.h,addReplyErrorSdsSafe,,false,2576,2576,addReplyErrorSdsSafe,,,281,"void addReplyErrorSdsSafe (client*,sds)"
393073,METHOD,server.h:<global>,TYPE_DECL,"void addReplyError(client *c, const char *err);",6,46,server.h,addReplyError,,false,2577,2577,addReplyError,,,282,"void addReplyError (client*,char*)"
393079,METHOD,server.h:<global>,TYPE_DECL,void addReplyErrorArity(client *c);,6,34,server.h,addReplyErrorArity,,false,2578,2578,addReplyErrorArity,,,283,void addReplyErrorArity (client*)
393084,METHOD,server.h:<global>,TYPE_DECL,void addReplyErrorExpireTime(client *c);,6,39,server.h,addReplyErrorExpireTime,,false,2579,2579,addReplyErrorExpireTime,,,284,void addReplyErrorExpireTime (client*)
393089,METHOD,server.h:<global>,TYPE_DECL,"void addReplyStatus(client *c, const char *status);",6,50,server.h,addReplyStatus,,false,2580,2580,addReplyStatus,,,285,"void addReplyStatus (client*,char*)"
393095,METHOD,server.h:<global>,TYPE_DECL,"void addReplyDouble(client *c, double d);",6,40,server.h,addReplyDouble,,false,2581,2581,addReplyDouble,,,286,"void addReplyDouble (client*,double)"
393101,METHOD,server.h:<global>,TYPE_DECL,"void addReplyLongLongWithPrefix(client *c, long long ll, char prefix);",6,69,server.h,addReplyLongLongWithPrefix,,false,2582,2582,addReplyLongLongWithPrefix,,,287,"void addReplyLongLongWithPrefix (client*,long long,char)"
393108,METHOD,server.h:<global>,TYPE_DECL,"void addReplyBigNum(client *c, const char* num, size_t len);",6,59,server.h,addReplyBigNum,,false,2583,2583,addReplyBigNum,,,288,"void addReplyBigNum (client*,char*,size_t)"
393115,METHOD,server.h:<global>,TYPE_DECL,"void addReplyHumanLongDouble(client *c, long double d);",6,54,server.h,addReplyHumanLongDouble,,false,2584,2584,addReplyHumanLongDouble,,,289,"void addReplyHumanLongDouble (client*,long double)"
393121,METHOD,server.h:<global>,TYPE_DECL,"void addReplyLongLong(client *c, long long ll);",6,46,server.h,addReplyLongLong,,false,2585,2585,addReplyLongLong,,,290,"void addReplyLongLong (client*,long long)"
393127,METHOD,server.h:<global>,TYPE_DECL,"void addReplyArrayLen(client *c, long length);",6,45,server.h,addReplyArrayLen,,false,2586,2586,addReplyArrayLen,,,291,"void addReplyArrayLen (client*,long)"
393133,METHOD,server.h:<global>,TYPE_DECL,"void addReplyMapLen(client *c, long length);",6,43,server.h,addReplyMapLen,,false,2587,2587,addReplyMapLen,,,292,"void addReplyMapLen (client*,long)"
393139,METHOD,server.h:<global>,TYPE_DECL,"void addReplySetLen(client *c, long length);",6,43,server.h,addReplySetLen,,false,2588,2588,addReplySetLen,,,293,"void addReplySetLen (client*,long)"
393145,METHOD,server.h:<global>,TYPE_DECL,"void addReplyAttributeLen(client *c, long length);",6,49,server.h,addReplyAttributeLen,,false,2589,2589,addReplyAttributeLen,,,294,"void addReplyAttributeLen (client*,long)"
393151,METHOD,server.h:<global>,TYPE_DECL,"void addReplyPushLen(client *c, long length);",6,44,server.h,addReplyPushLen,,false,2590,2590,addReplyPushLen,,,295,"void addReplyPushLen (client*,long)"
393157,METHOD,server.h:<global>,TYPE_DECL,"void addReplyHelp(client *c, const char **help);",6,47,server.h,addReplyHelp,,false,2591,2591,addReplyHelp,,,296,"void addReplyHelp (client*,char**)"
393163,METHOD,server.h:<global>,TYPE_DECL,void addReplySubcommandSyntaxError(client *c);,6,45,server.h,addReplySubcommandSyntaxError,,false,2592,2592,addReplySubcommandSyntaxError,,,297,void addReplySubcommandSyntaxError (client*)
393168,METHOD,server.h:<global>,TYPE_DECL,void addReplyLoadedModules(client *c);,6,37,server.h,addReplyLoadedModules,,false,2593,2593,addReplyLoadedModules,,,298,void addReplyLoadedModules (client*)
393173,METHOD,server.h:<global>,TYPE_DECL,"void copyReplicaOutputBuffer(client *dst, client *src);",6,54,server.h,copyReplicaOutputBuffer,,false,2594,2594,copyReplicaOutputBuffer,,,299,"void copyReplicaOutputBuffer (client*,client*)"
393179,METHOD,server.h:<global>,TYPE_DECL,"void addListRangeReply(client *c, robj *o, long start, long end, int reverse);",6,77,server.h,addListRangeReply,,false,2595,2595,addListRangeReply,,,300,"void addListRangeReply (client*,robj*,long,long,int)"
393188,METHOD,server.h:<global>,TYPE_DECL,"void deferredAfterErrorReply(client *c, list *errors);",6,53,server.h,deferredAfterErrorReply,,false,2596,2596,deferredAfterErrorReply,,,301,"void deferredAfterErrorReply (client*,list*)"
393194,METHOD,server.h:<global>,TYPE_DECL,size_t sdsZmallocSize(sds s);,8,28,server.h,sdsZmallocSize,,false,2597,2597,sdsZmallocSize,,,302,size_t sdsZmallocSize (sds)
393199,METHOD,server.h:<global>,TYPE_DECL,size_t getStringObjectSdsUsedMemory(robj *o);,8,44,server.h,getStringObjectSdsUsedMemory,,false,2598,2598,getStringObjectSdsUsedMemory,,,303,size_t getStringObjectSdsUsedMemory (robj*)
393204,METHOD,server.h:<global>,TYPE_DECL,void freeClientReplyValue(void *o);,6,34,server.h,freeClientReplyValue,,false,2599,2599,freeClientReplyValue,,,304,void freeClientReplyValue (void*)
393209,METHOD,server.h:<global>,TYPE_DECL,void *dupClientReplyValue(void *o);,6,34,server.h,dupClientReplyValue,,false,2600,2600,dupClientReplyValue,,,305,void* dupClientReplyValue (void*)
393214,METHOD,server.h:<global>,TYPE_DECL,char *getClientPeerId(client *client);,6,37,server.h,getClientPeerId,,false,2601,2601,getClientPeerId,,,306,char* getClientPeerId (client*)
393219,METHOD,server.h:<global>,TYPE_DECL,char *getClientSockName(client *client);,6,39,server.h,getClientSockName,,false,2602,2602,getClientSockName,,,307,char* getClientSockName (client*)
393224,METHOD,server.h:<global>,TYPE_DECL,"sds catClientInfoString(sds s, client *client);",5,46,server.h,catClientInfoString,,false,2603,2603,catClientInfoString,,,308,"sds catClientInfoString (sds,client*)"
393230,METHOD,server.h:<global>,TYPE_DECL,sds getAllClientsInfoString(int type);,5,37,server.h,getAllClientsInfoString,,false,2604,2604,getAllClientsInfoString,,,309,sds getAllClientsInfoString (int)
393235,METHOD,server.h:<global>,TYPE_DECL,"int clientSetName(client *c, robj *name, const char **err);",5,58,server.h,clientSetName,,false,2605,2605,clientSetName,,,310,"int clientSetName (client*,robj*,char**)"
393242,METHOD,server.h:<global>,TYPE_DECL,"void rewriteClientCommandVector(client *c, int argc, ...);",6,57,server.h,rewriteClientCommandVector,,false,2606,2606,rewriteClientCommandVector,,,311,"void rewriteClientCommandVector (client*,int...)"
393248,METHOD,server.h:<global>,TYPE_DECL,"void rewriteClientCommandArgument(client *c, int i, robj *newval);",6,65,server.h,rewriteClientCommandArgument,,false,2607,2607,rewriteClientCommandArgument,,,312,"void rewriteClientCommandArgument (client*,int,robj*)"
393255,METHOD,server.h:<global>,TYPE_DECL,"void replaceClientCommandVector(client *c, int argc, robj **argv);",6,65,server.h,replaceClientCommandVector,,false,2608,2608,replaceClientCommandVector,,,313,"void replaceClientCommandVector (client*,int,robj**)"
393262,METHOD,server.h:<global>,TYPE_DECL,"void redactClientCommandArgument(client *c, int argc);",6,53,server.h,redactClientCommandArgument,,false,2609,2609,redactClientCommandArgument,,,314,"void redactClientCommandArgument (client*,int)"
393268,METHOD,server.h:<global>,TYPE_DECL,size_t getClientOutputBufferMemoryUsage(client *c);,8,50,server.h,getClientOutputBufferMemoryUsage,,false,2610,2610,getClientOutputBufferMemoryUsage,,,315,size_t getClientOutputBufferMemoryUsage (client*)
393273,METHOD,server.h:<global>,TYPE_DECL,"size_t getClientMemoryUsage(client *c, size_t *output_buffer_mem_usage);",8,71,server.h,getClientMemoryUsage,,false,2611,2611,getClientMemoryUsage,,,316,"size_t getClientMemoryUsage (client*,size_t*)"
393279,METHOD,server.h:<global>,TYPE_DECL,int freeClientsInAsyncFreeQueue(void);,5,37,server.h,freeClientsInAsyncFreeQueue,,false,2612,2612,freeClientsInAsyncFreeQueue,,,317,int freeClientsInAsyncFreeQueue (void)
393284,METHOD,server.h:<global>,TYPE_DECL,"int closeClientOnOutputBufferLimitReached(client *c, int async);",5,63,server.h,closeClientOnOutputBufferLimitReached,,false,2613,2613,closeClientOnOutputBufferLimitReached,,,318,"int closeClientOnOutputBufferLimitReached (client*,int)"
393290,METHOD,server.h:<global>,TYPE_DECL,int getClientType(client *c);,5,28,server.h,getClientType,,false,2614,2614,getClientType,,,319,int getClientType (client*)
393295,METHOD,server.h:<global>,TYPE_DECL,int getClientTypeByName(char *name);,5,35,server.h,getClientTypeByName,,false,2615,2615,getClientTypeByName,,,320,int getClientTypeByName (char*)
393300,METHOD,server.h:<global>,TYPE_DECL,char *getClientTypeName(int class);,6,34,server.h,getClientTypeName,,false,2616,2616,getClientTypeName,,,321,char* getClientTypeName (int)
393305,METHOD,server.h:<global>,TYPE_DECL,void flushSlavesOutputBuffers(void);,6,35,server.h,flushSlavesOutputBuffers,,false,2617,2617,flushSlavesOutputBuffers,,,322,void flushSlavesOutputBuffers (void)
393310,METHOD,server.h:<global>,TYPE_DECL,void disconnectSlaves(void);,6,27,server.h,disconnectSlaves,,false,2618,2618,disconnectSlaves,,,323,void disconnectSlaves (void)
393315,METHOD,server.h:<global>,TYPE_DECL,void evictClients(void);,6,23,server.h,evictClients,,false,2619,2619,evictClients,,,324,void evictClients (void)
393320,METHOD,server.h:<global>,TYPE_DECL,int listenToPort(connListener *fds);,5,35,server.h,listenToPort,,false,2620,2620,listenToPort,,,325,int listenToPort (connListener*)
393325,METHOD,server.h:<global>,TYPE_DECL,"void pauseActions(pause_purpose purpose, mstime_t end, uint32_t actions_bitmask);",6,80,server.h,pauseActions,,false,2621,2621,pauseActions,,,326,"void pauseActions (pause_purpose,mstime_t,uint32_t)"
393332,METHOD,server.h:<global>,TYPE_DECL,void unpauseActions(pause_purpose purpose);,6,42,server.h,unpauseActions,,false,2622,2622,unpauseActions,,,327,void unpauseActions (pause_purpose)
393337,METHOD,server.h:<global>,TYPE_DECL,uint32_t isPausedActions(uint32_t action_bitmask);,10,49,server.h,isPausedActions,,false,2623,2623,isPausedActions,,,328,uint32_t isPausedActions (uint32_t)
393342,METHOD,server.h:<global>,TYPE_DECL,uint32_t isPausedActionsWithUpdate(uint32_t action_bitmask);,10,59,server.h,isPausedActionsWithUpdate,,false,2624,2624,isPausedActionsWithUpdate,,,329,uint32_t isPausedActionsWithUpdate (uint32_t)
393347,METHOD,server.h:<global>,TYPE_DECL,void updatePausedActions(void);,6,30,server.h,updatePausedActions,,false,2625,2625,updatePausedActions,,,330,void updatePausedActions (void)
393352,METHOD,server.h:<global>,TYPE_DECL,void unblockPostponedClients(void);,6,34,server.h,unblockPostponedClients,,false,2626,2626,unblockPostponedClients,,,331,void unblockPostponedClients (void)
393357,METHOD,server.h:<global>,TYPE_DECL,void processEventsWhileBlocked(void);,6,36,server.h,processEventsWhileBlocked,,false,2627,2627,processEventsWhileBlocked,,,332,void processEventsWhileBlocked (void)
393362,METHOD,server.h:<global>,TYPE_DECL,void whileBlockedCron(void);,6,27,server.h,whileBlockedCron,,false,2628,2628,whileBlockedCron,,,333,void whileBlockedCron (void)
393367,METHOD,server.h:<global>,TYPE_DECL,void blockingOperationStarts(void);,6,34,server.h,blockingOperationStarts,,false,2629,2629,blockingOperationStarts,,,334,void blockingOperationStarts (void)
393372,METHOD,server.h:<global>,TYPE_DECL,void blockingOperationEnds(void);,6,32,server.h,blockingOperationEnds,,false,2630,2630,blockingOperationEnds,,,335,void blockingOperationEnds (void)
393377,METHOD,server.h:<global>,TYPE_DECL,int handleClientsWithPendingWrites(void);,5,40,server.h,handleClientsWithPendingWrites,,false,2631,2631,handleClientsWithPendingWrites,,,336,int handleClientsWithPendingWrites (void)
393382,METHOD,server.h:<global>,TYPE_DECL,int handleClientsWithPendingWritesUsingThreads(void);,5,52,server.h,handleClientsWithPendingWritesUsingThreads,,false,2632,2632,handleClientsWithPendingWritesUsingThreads,,,337,int handleClientsWithPendingWritesUsingThreads (void)
393387,METHOD,server.h:<global>,TYPE_DECL,int handleClientsWithPendingReadsUsingThreads(void);,5,51,server.h,handleClientsWithPendingReadsUsingThreads,,false,2633,2633,handleClientsWithPendingReadsUsingThreads,,,338,int handleClientsWithPendingReadsUsingThreads (void)
393392,METHOD,server.h:<global>,TYPE_DECL,int stopThreadedIOIfNeeded(void);,5,32,server.h,stopThreadedIOIfNeeded,,false,2634,2634,stopThreadedIOIfNeeded,,,339,int stopThreadedIOIfNeeded (void)
393397,METHOD,server.h:<global>,TYPE_DECL,int clientHasPendingReplies(client *c);,5,38,server.h,clientHasPendingReplies,,false,2635,2635,clientHasPendingReplies,,,340,int clientHasPendingReplies (client*)
393402,METHOD,server.h:<global>,TYPE_DECL,int updateClientMemUsageAndBucket(client *c);,5,44,server.h,updateClientMemUsageAndBucket,,false,2636,2636,updateClientMemUsageAndBucket,,,341,int updateClientMemUsageAndBucket (client*)
393407,METHOD,server.h:<global>,TYPE_DECL,"void removeClientFromMemUsageBucket(client *c, int allow_eviction);",6,66,server.h,removeClientFromMemUsageBucket,,false,2637,2637,removeClientFromMemUsageBucket,,,342,"void removeClientFromMemUsageBucket (client*,int)"
393413,METHOD,server.h:<global>,TYPE_DECL,void unlinkClient(client *c);,6,28,server.h,unlinkClient,,false,2638,2638,unlinkClient,,,343,void unlinkClient (client*)
393418,METHOD,server.h:<global>,TYPE_DECL,"int writeToClient(client *c, int handler_installed);",5,51,server.h,writeToClient,,false,2639,2639,writeToClient,,,344,"int writeToClient (client*,int)"
393424,METHOD,server.h:<global>,TYPE_DECL,void linkClient(client *c);,6,26,server.h,linkClient,,false,2640,2640,linkClient,,,345,void linkClient (client*)
393429,METHOD,server.h:<global>,TYPE_DECL,void protectClient(client *c);,6,29,server.h,protectClient,,false,2641,2641,protectClient,,,346,void protectClient (client*)
393434,METHOD,server.h:<global>,TYPE_DECL,void unprotectClient(client *c);,6,31,server.h,unprotectClient,,false,2642,2642,unprotectClient,,,347,void unprotectClient (client*)
393439,METHOD,server.h:<global>,TYPE_DECL,void initThreadedIO(void);,6,25,server.h,initThreadedIO,,false,2643,2643,initThreadedIO,,,348,void initThreadedIO (void)
393444,METHOD,server.h:<global>,TYPE_DECL,client *lookupClientByID(uint64_t id);,8,37,server.h,lookupClientByID,,false,2644,2644,lookupClientByID,,,349,client* lookupClientByID (uint64_t)
393449,METHOD,server.h:<global>,TYPE_DECL,int authRequired(client *c);,5,27,server.h,authRequired,,false,2645,2645,authRequired,,,350,int authRequired (client*)
393454,METHOD,server.h:<global>,TYPE_DECL,void putClientInPendingWriteQueue(client *c);,6,44,server.h,putClientInPendingWriteQueue,,false,2646,2646,putClientInPendingWriteQueue,,,351,void putClientInPendingWriteQueue (client*)
393459,METHOD,server.h:<global>,TYPE_DECL,"void reqresReset(client *c, int free_buf);",6,41,server.h,reqresReset,,false,2649,2649,reqresReset,,,352,"void reqresReset (client*,int)"
393465,METHOD,server.h:<global>,TYPE_DECL,void reqresSaveClientReplyOffset(client *c);,6,43,server.h,reqresSaveClientReplyOffset,,false,2650,2650,reqresSaveClientReplyOffset,,,353,void reqresSaveClientReplyOffset (client*)
393470,METHOD,server.h:<global>,TYPE_DECL,size_t reqresAppendRequest(client *c);,8,37,server.h,reqresAppendRequest,,false,2651,2651,reqresAppendRequest,,,354,size_t reqresAppendRequest (client*)
393475,METHOD,server.h:<global>,TYPE_DECL,size_t reqresAppendResponse(client *c);,8,38,server.h,reqresAppendResponse,,false,2652,2652,reqresAppendResponse,,,355,size_t reqresAppendResponse (client*)
393480,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorFormatEx(client *c, int flags, const char *fmt, ...);",6,70,server.h,addReplyErrorFormatEx,,false,2662,2662,addReplyErrorFormatEx,,,356,"void addReplyErrorFormatEx (client*,int,char*...)"
393487,METHOD,server.h:<global>,TYPE_DECL,"void addReplyErrorFormat(client *c, const char *fmt, ...);",6,57,server.h,addReplyErrorFormat,,false,2663,2663,addReplyErrorFormat,,,357,"void addReplyErrorFormat (client*,char*...)"
393493,METHOD,server.h:<global>,TYPE_DECL,"void addReplyStatusFormat(client *c, const char *fmt, ...);",6,58,server.h,addReplyStatusFormat,,false,2664,2664,addReplyStatusFormat,,,358,"void addReplyStatusFormat (client*,char*...)"
393499,METHOD,server.h:<global>,TYPE_DECL,"void enableTracking(client *c, uint64_t redirect_to, uint64_t options, robj **prefix, size_t numprefix);",6,103,server.h,enableTracking,,false,2668,2668,enableTracking,,,359,"void enableTracking (client*,uint64_t,uint64_t,robj**,size_t)"
393508,METHOD,server.h:<global>,TYPE_DECL,void disableTracking(client *c);,6,31,server.h,disableTracking,,false,2669,2669,disableTracking,,,360,void disableTracking (client*)
393513,METHOD,server.h:<global>,TYPE_DECL,"void trackingRememberKeys(client *tracking, client *executing);",6,62,server.h,trackingRememberKeys,,false,2670,2670,trackingRememberKeys,,,361,"void trackingRememberKeys (client*,client*)"
393519,METHOD,server.h:<global>,TYPE_DECL,"void trackingInvalidateKey(client *c, robj *keyobj, int bcast);",6,62,server.h,trackingInvalidateKey,,false,2671,2671,trackingInvalidateKey,,,362,"void trackingInvalidateKey (client*,robj*,int)"
393526,METHOD,server.h:<global>,TYPE_DECL,"void trackingScheduleKeyInvalidation(uint64_t client_id, robj *keyobj);",6,70,server.h,trackingScheduleKeyInvalidation,,false,2672,2672,trackingScheduleKeyInvalidation,,,363,"void trackingScheduleKeyInvalidation (uint64_t,robj*)"
393532,METHOD,server.h:<global>,TYPE_DECL,void trackingHandlePendingKeyInvalidations(void);,6,48,server.h,trackingHandlePendingKeyInvalidations,,false,2673,2673,trackingHandlePendingKeyInvalidations,,,364,void trackingHandlePendingKeyInvalidations (void)
393537,METHOD,server.h:<global>,TYPE_DECL,void trackingInvalidateKeysOnFlush(int async);,6,45,server.h,trackingInvalidateKeysOnFlush,,false,2674,2674,trackingInvalidateKeysOnFlush,,,365,void trackingInvalidateKeysOnFlush (int)
393542,METHOD,server.h:<global>,TYPE_DECL,void freeTrackingRadixTree(rax *rt);,6,35,server.h,freeTrackingRadixTree,,false,2675,2675,freeTrackingRadixTree,,,366,void freeTrackingRadixTree (rax*)
393547,METHOD,server.h:<global>,TYPE_DECL,void freeTrackingRadixTreeAsync(rax *rt);,6,40,server.h,freeTrackingRadixTreeAsync,,false,2676,2676,freeTrackingRadixTreeAsync,,,367,void freeTrackingRadixTreeAsync (rax*)
393552,METHOD,server.h:<global>,TYPE_DECL,void trackingLimitUsedSlots(void);,6,33,server.h,trackingLimitUsedSlots,,false,2677,2677,trackingLimitUsedSlots,,,368,void trackingLimitUsedSlots (void)
393557,METHOD,server.h:<global>,TYPE_DECL,uint64_t trackingGetTotalItems(void);,10,36,server.h,trackingGetTotalItems,,false,2678,2678,trackingGetTotalItems,,,369,uint64_t trackingGetTotalItems (void)
393562,METHOD,server.h:<global>,TYPE_DECL,uint64_t trackingGetTotalKeys(void);,10,35,server.h,trackingGetTotalKeys,,false,2679,2679,trackingGetTotalKeys,,,370,uint64_t trackingGetTotalKeys (void)
393567,METHOD,server.h:<global>,TYPE_DECL,uint64_t trackingGetTotalPrefixes(void);,10,39,server.h,trackingGetTotalPrefixes,,false,2680,2680,trackingGetTotalPrefixes,,,371,uint64_t trackingGetTotalPrefixes (void)
393572,METHOD,server.h:<global>,TYPE_DECL,void trackingBroadcastInvalidationMessages(void);,6,48,server.h,trackingBroadcastInvalidationMessages,,false,2681,2681,trackingBroadcastInvalidationMessages,,,372,void trackingBroadcastInvalidationMessages (void)
393577,METHOD,server.h:<global>,TYPE_DECL,"int checkPrefixCollisionsOrReply(client *c, robj **prefix, size_t numprefix);",5,76,server.h,checkPrefixCollisionsOrReply,,false,2682,2682,checkPrefixCollisionsOrReply,,,373,"int checkPrefixCollisionsOrReply (client*,robj**,size_t)"
393584,METHOD,server.h:<global>,TYPE_DECL,"void listTypePush(robj *subject, robj *value, int where);",6,56,server.h,listTypePush,,false,2685,2685,listTypePush,,,374,"void listTypePush (robj*,robj*,int)"
393591,METHOD,server.h:<global>,TYPE_DECL,"robj *listTypePop(robj *subject, int where);",6,43,server.h,listTypePop,,false,2686,2686,listTypePop,,,375,"robj* listTypePop (robj*,int)"
393597,METHOD,server.h:<global>,TYPE_DECL,unsigned long listTypeLength(const robj *subject);,15,49,server.h,listTypeLength,,false,2687,2687,listTypeLength,,,376,long unsigned listTypeLength (robj*)
393602,METHOD,server.h:<global>,TYPE_DECL,"listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction);",18,90,server.h,listTypeInitIterator,,false,2688,2688,listTypeInitIterator,,,377,"listTypeIterator* listTypeInitIterator (robj*,long,unsigned char)"
393609,METHOD,server.h:<global>,TYPE_DECL,void listTypeReleaseIterator(listTypeIterator *li);,6,50,server.h,listTypeReleaseIterator,,false,2689,2689,listTypeReleaseIterator,,,378,void listTypeReleaseIterator (listTypeIterator*)
393614,METHOD,server.h:<global>,TYPE_DECL,"void listTypeSetIteratorDirection(listTypeIterator *li, listTypeEntry *entry, unsigned char direction);",6,102,server.h,listTypeSetIteratorDirection,,false,2690,2690,listTypeSetIteratorDirection,,,379,"void listTypeSetIteratorDirection (listTypeIterator*,listTypeEntry*,unsigned char)"
393621,METHOD,server.h:<global>,TYPE_DECL,"int listTypeNext(listTypeIterator *li, listTypeEntry *entry);",5,60,server.h,listTypeNext,,false,2691,2691,listTypeNext,,,380,"int listTypeNext (listTypeIterator*,listTypeEntry*)"
393627,METHOD,server.h:<global>,TYPE_DECL,robj *listTypeGet(listTypeEntry *entry);,6,39,server.h,listTypeGet,,false,2692,2692,listTypeGet,,,381,robj* listTypeGet (listTypeEntry*)
393632,METHOD,server.h:<global>,TYPE_DECL,"unsigned char *listTypeGetValue(listTypeEntry *entry, size_t *vlen, long long *lval);",15,84,server.h,listTypeGetValue,,false,2693,2693,listTypeGetValue,,,382,"unsigned char* listTypeGetValue (listTypeEntry*,size_t*,long long*)"
393639,METHOD,server.h:<global>,TYPE_DECL,"void listTypeInsert(listTypeEntry *entry, robj *value, int where);",6,65,server.h,listTypeInsert,,false,2694,2694,listTypeInsert,,,383,"void listTypeInsert (listTypeEntry*,robj*,int)"
393646,METHOD,server.h:<global>,TYPE_DECL,"void listTypeReplace(listTypeEntry *entry, robj *value);",6,55,server.h,listTypeReplace,,false,2695,2695,listTypeReplace,,,384,"void listTypeReplace (listTypeEntry*,robj*)"
393652,METHOD,server.h:<global>,TYPE_DECL,"int listTypeEqual(listTypeEntry *entry, robj *o);",5,48,server.h,listTypeEqual,,false,2696,2696,listTypeEqual,,,385,"int listTypeEqual (listTypeEntry*,robj*)"
393658,METHOD,server.h:<global>,TYPE_DECL,"void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry);",6,65,server.h,listTypeDelete,,false,2697,2697,listTypeDelete,,,386,"void listTypeDelete (listTypeIterator*,listTypeEntry*)"
393664,METHOD,server.h:<global>,TYPE_DECL,robj *listTypeDup(robj *o);,6,26,server.h,listTypeDup,,false,2698,2698,listTypeDup,,,387,robj* listTypeDup (robj*)
393669,METHOD,server.h:<global>,TYPE_DECL,"void listTypeDelRange(robj *o, long start, long stop);",6,53,server.h,listTypeDelRange,,false,2699,2699,listTypeDelRange,,,388,"void listTypeDelRange (robj*,long,long)"
393676,METHOD,server.h:<global>,TYPE_DECL,"void popGenericCommand(client *c, int where);",6,44,server.h,popGenericCommand,,false,2700,2700,popGenericCommand,,,389,"void popGenericCommand (client*,int)"
393682,METHOD,server.h:<global>,TYPE_DECL,"void listElementsRemoved(client *c, robj *key, int where, robj *o, long count, int signal, int *deleted);",6,104,server.h,listElementsRemoved,,false,2701,2701,listElementsRemoved,,,390,"void listElementsRemoved (client*,robj*,int,robj*,long,int,int*)"
393698,METHOD,server.h:<global>,TYPE_DECL,typedef void (*beforeConvertCB)(void *data);,14,43,server.h,beforeConvertCB,,false,2707,2707,beforeConvertCB,,,393,void beforeConvertCB (void*)
393703,METHOD,server.h:<global>,TYPE_DECL,"void listTypeTryConversion(robj *o, list_conv_type lct, beforeConvertCB fn, void *data);",6,87,server.h,listTypeTryConversion,,false,2708,2708,listTypeTryConversion,,,394,"void listTypeTryConversion (robj*,list_conv_type,beforeConvertCB,void*)"
393711,METHOD,server.h:<global>,TYPE_DECL,"void listTypeTryConversionAppend(robj *o, robj **argv, int start, int end, beforeConvertCB fn, void *data);",6,106,server.h,listTypeTryConversionAppend,,false,2709,2709,listTypeTryConversionAppend,,,395,"void listTypeTryConversionAppend (robj*,robj**,int,int,beforeConvertCB,void*)"
393721,METHOD,server.h:<global>,TYPE_DECL,void unwatchAllKeys(client *c);,6,30,server.h,unwatchAllKeys,,false,2712,2712,unwatchAllKeys,,,396,void unwatchAllKeys (client*)
393726,METHOD,server.h:<global>,TYPE_DECL,void initClientMultiState(client *c);,6,36,server.h,initClientMultiState,,false,2713,2713,initClientMultiState,,,397,void initClientMultiState (client*)
393731,METHOD,server.h:<global>,TYPE_DECL,void freeClientMultiState(client *c);,6,36,server.h,freeClientMultiState,,false,2714,2714,freeClientMultiState,,,398,void freeClientMultiState (client*)
393736,METHOD,server.h:<global>,TYPE_DECL,"void queueMultiCommand(client *c, uint64_t cmd_flags);",6,53,server.h,queueMultiCommand,,false,2715,2715,queueMultiCommand,,,399,"void queueMultiCommand (client*,uint64_t)"
393742,METHOD,server.h:<global>,TYPE_DECL,size_t multiStateMemOverhead(client *c);,8,39,server.h,multiStateMemOverhead,,false,2716,2716,multiStateMemOverhead,,,400,size_t multiStateMemOverhead (client*)
393747,METHOD,server.h:<global>,TYPE_DECL,"void touchWatchedKey(redisDb *db, robj *key);",6,44,server.h,touchWatchedKey,,false,2717,2717,touchWatchedKey,,,401,"void touchWatchedKey (redisDb*,robj*)"
393753,METHOD,server.h:<global>,TYPE_DECL,int isWatchedKeyExpired(client *c);,5,34,server.h,isWatchedKeyExpired,,false,2718,2718,isWatchedKeyExpired,,,402,int isWatchedKeyExpired (client*)
393758,METHOD,server.h:<global>,TYPE_DECL,"void touchAllWatchedKeysInDb(redisDb *emptied, redisDb *replaced_with);",6,70,server.h,touchAllWatchedKeysInDb,,false,2719,2719,touchAllWatchedKeysInDb,,,403,"void touchAllWatchedKeysInDb (redisDb*,redisDb*)"
393764,METHOD,server.h:<global>,TYPE_DECL,void discardTransaction(client *c);,6,34,server.h,discardTransaction,,false,2720,2720,discardTransaction,,,404,void discardTransaction (client*)
393769,METHOD,server.h:<global>,TYPE_DECL,void flagTransaction(client *c);,6,31,server.h,flagTransaction,,false,2721,2721,flagTransaction,,,405,void flagTransaction (client*)
393774,METHOD,server.h:<global>,TYPE_DECL,"void execCommandAbort(client *c, sds error);",6,43,server.h,execCommandAbort,,false,2722,2722,execCommandAbort,,,406,"void execCommandAbort (client*,sds)"
393780,METHOD,server.h:<global>,TYPE_DECL,void decrRefCount(robj *o);,6,26,server.h,decrRefCount,,false,2725,2725,decrRefCount,,,407,void decrRefCount (robj*)
393785,METHOD,server.h:<global>,TYPE_DECL,void decrRefCountVoid(void *o);,6,30,server.h,decrRefCountVoid,,false,2726,2726,decrRefCountVoid,,,408,void decrRefCountVoid (void*)
393790,METHOD,server.h:<global>,TYPE_DECL,void incrRefCount(robj *o);,6,26,server.h,incrRefCount,,false,2727,2727,incrRefCount,,,409,void incrRefCount (robj*)
393795,METHOD,server.h:<global>,TYPE_DECL,robj *makeObjectShared(robj *o);,6,31,server.h,makeObjectShared,,false,2728,2728,makeObjectShared,,,410,robj* makeObjectShared (robj*)
393800,METHOD,server.h:<global>,TYPE_DECL,void freeStringObject(robj *o);,6,30,server.h,freeStringObject,,false,2729,2729,freeStringObject,,,411,void freeStringObject (robj*)
393805,METHOD,server.h:<global>,TYPE_DECL,void freeListObject(robj *o);,6,28,server.h,freeListObject,,false,2730,2730,freeListObject,,,412,void freeListObject (robj*)
393810,METHOD,server.h:<global>,TYPE_DECL,void freeSetObject(robj *o);,6,27,server.h,freeSetObject,,false,2731,2731,freeSetObject,,,413,void freeSetObject (robj*)
393815,METHOD,server.h:<global>,TYPE_DECL,void freeZsetObject(robj *o);,6,28,server.h,freeZsetObject,,false,2732,2732,freeZsetObject,,,414,void freeZsetObject (robj*)
393820,METHOD,server.h:<global>,TYPE_DECL,void freeHashObject(robj *o);,6,28,server.h,freeHashObject,,false,2733,2733,freeHashObject,,,415,void freeHashObject (robj*)
393825,METHOD,server.h:<global>,TYPE_DECL,"void dismissObject(robj *o, size_t dump_size);",6,45,server.h,dismissObject,,false,2734,2734,dismissObject,,,416,"void dismissObject (robj*,size_t)"
393831,METHOD,server.h:<global>,TYPE_DECL,"robj *createObject(int type, void *ptr);",6,39,server.h,createObject,,false,2735,2735,createObject,,,417,"robj* createObject (int,void*)"
393837,METHOD,server.h:<global>,TYPE_DECL,void initObjectLRUOrLFU(robj *o);,6,32,server.h,initObjectLRUOrLFU,,false,2736,2736,initObjectLRUOrLFU,,,418,void initObjectLRUOrLFU (robj*)
393842,METHOD,server.h:<global>,TYPE_DECL,"robj *createStringObject(const char *ptr, size_t len);",6,53,server.h,createStringObject,,false,2737,2737,createStringObject,,,419,"robj* createStringObject (char*,size_t)"
393848,METHOD,server.h:<global>,TYPE_DECL,"robj *createRawStringObject(const char *ptr, size_t len);",6,56,server.h,createRawStringObject,,false,2738,2738,createRawStringObject,,,420,"robj* createRawStringObject (char*,size_t)"
393854,METHOD,server.h:<global>,TYPE_DECL,"robj *createEmbeddedStringObject(const char *ptr, size_t len);",6,61,server.h,createEmbeddedStringObject,,false,2739,2739,createEmbeddedStringObject,,,421,"robj* createEmbeddedStringObject (char*,size_t)"
393860,METHOD,server.h:<global>,TYPE_DECL,"robj *tryCreateRawStringObject(const char *ptr, size_t len);",6,59,server.h,tryCreateRawStringObject,,false,2740,2740,tryCreateRawStringObject,,,422,"robj* tryCreateRawStringObject (char*,size_t)"
393866,METHOD,server.h:<global>,TYPE_DECL,"robj *tryCreateStringObject(const char *ptr, size_t len);",6,56,server.h,tryCreateStringObject,,false,2741,2741,tryCreateStringObject,,,423,"robj* tryCreateStringObject (char*,size_t)"
393872,METHOD,server.h:<global>,TYPE_DECL,robj *dupStringObject(const robj *o);,6,36,server.h,dupStringObject,,false,2742,2742,dupStringObject,,,424,robj* dupStringObject (robj*)
393877,METHOD,server.h:<global>,TYPE_DECL,"int isSdsRepresentableAsLongLong(sds s, long long *llval);",5,57,server.h,isSdsRepresentableAsLongLong,,false,2743,2743,isSdsRepresentableAsLongLong,,,425,"int isSdsRepresentableAsLongLong (sds,long long*)"
393883,METHOD,server.h:<global>,TYPE_DECL,"int isObjectRepresentableAsLongLong(robj *o, long long *llongval);",5,65,server.h,isObjectRepresentableAsLongLong,,false,2744,2744,isObjectRepresentableAsLongLong,,,426,"int isObjectRepresentableAsLongLong (robj*,long long*)"
393889,METHOD,server.h:<global>,TYPE_DECL,robj *tryObjectEncoding(robj *o);,6,32,server.h,tryObjectEncoding,,false,2745,2745,tryObjectEncoding,,,427,robj* tryObjectEncoding (robj*)
393894,METHOD,server.h:<global>,TYPE_DECL,"robj *tryObjectEncodingEx(robj *o, int try_trim);",6,48,server.h,tryObjectEncodingEx,,false,2746,2746,tryObjectEncodingEx,,,428,"robj* tryObjectEncodingEx (robj*,int)"
393900,METHOD,server.h:<global>,TYPE_DECL,robj *getDecodedObject(robj *o);,6,31,server.h,getDecodedObject,,false,2747,2747,getDecodedObject,,,429,robj* getDecodedObject (robj*)
393905,METHOD,server.h:<global>,TYPE_DECL,size_t stringObjectLen(robj *o);,8,31,server.h,stringObjectLen,,false,2748,2748,stringObjectLen,,,430,size_t stringObjectLen (robj*)
393910,METHOD,server.h:<global>,TYPE_DECL,robj *createStringObjectFromLongLong(long long value);,6,53,server.h,createStringObjectFromLongLong,,false,2749,2749,createStringObjectFromLongLong,,,431,robj* createStringObjectFromLongLong (long long)
393915,METHOD,server.h:<global>,TYPE_DECL,robj *createStringObjectFromLongLongForValue(long long value);,6,61,server.h,createStringObjectFromLongLongForValue,,false,2750,2750,createStringObjectFromLongLongForValue,,,432,robj* createStringObjectFromLongLongForValue (long long)
393920,METHOD,server.h:<global>,TYPE_DECL,robj *createStringObjectFromLongLongWithSds(long long value);,6,60,server.h,createStringObjectFromLongLongWithSds,,false,2751,2751,createStringObjectFromLongLongWithSds,,,433,robj* createStringObjectFromLongLongWithSds (long long)
393925,METHOD,server.h:<global>,TYPE_DECL,"robj *createStringObjectFromLongDouble(long double value, int humanfriendly);",6,76,server.h,createStringObjectFromLongDouble,,false,2752,2752,createStringObjectFromLongDouble,,,434,"robj* createStringObjectFromLongDouble (long double,int)"
393931,METHOD,server.h:<global>,TYPE_DECL,robj *createQuicklistObject(void);,6,33,server.h,createQuicklistObject,,false,2753,2753,createQuicklistObject,,,435,robj* createQuicklistObject (void)
393936,METHOD,server.h:<global>,TYPE_DECL,robj *createListListpackObject(void);,6,36,server.h,createListListpackObject,,false,2754,2754,createListListpackObject,,,436,robj* createListListpackObject (void)
393941,METHOD,server.h:<global>,TYPE_DECL,robj *createSetObject(void);,6,27,server.h,createSetObject,,false,2755,2755,createSetObject,,,437,robj* createSetObject (void)
393946,METHOD,server.h:<global>,TYPE_DECL,robj *createIntsetObject(void);,6,30,server.h,createIntsetObject,,false,2756,2756,createIntsetObject,,,438,robj* createIntsetObject (void)
393951,METHOD,server.h:<global>,TYPE_DECL,robj *createSetListpackObject(void);,6,35,server.h,createSetListpackObject,,false,2757,2757,createSetListpackObject,,,439,robj* createSetListpackObject (void)
393956,METHOD,server.h:<global>,TYPE_DECL,robj *createHashObject(void);,6,28,server.h,createHashObject,,false,2758,2758,createHashObject,,,440,robj* createHashObject (void)
393961,METHOD,server.h:<global>,TYPE_DECL,robj *createZsetObject(void);,6,28,server.h,createZsetObject,,false,2759,2759,createZsetObject,,,441,robj* createZsetObject (void)
393966,METHOD,server.h:<global>,TYPE_DECL,robj *createZsetListpackObject(void);,6,36,server.h,createZsetListpackObject,,false,2760,2760,createZsetListpackObject,,,442,robj* createZsetListpackObject (void)
393971,METHOD,server.h:<global>,TYPE_DECL,robj *createStreamObject(void);,6,30,server.h,createStreamObject,,false,2761,2761,createStreamObject,,,443,robj* createStreamObject (void)
393976,METHOD,server.h:<global>,TYPE_DECL,"robj *createModuleObject(moduleType *mt, void *value);",6,53,server.h,createModuleObject,,false,2762,2762,createModuleObject,,,444,"robj* createModuleObject (moduleType*,void*)"
393982,METHOD,server.h:<global>,TYPE_DECL,"int getLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg);",5,79,server.h,getLongFromObjectOrReply,,false,2763,2763,getLongFromObjectOrReply,,,445,"int getLongFromObjectOrReply (client*,robj*,long*,char*)"
393990,METHOD,server.h:<global>,TYPE_DECL,"int getPositiveLongFromObjectOrReply(client *c, robj *o, long *target, const char *msg);",5,87,server.h,getPositiveLongFromObjectOrReply,,false,2764,2764,getPositiveLongFromObjectOrReply,,,446,"int getPositiveLongFromObjectOrReply (client*,robj*,long*,char*)"
393998,METHOD,server.h:<global>,TYPE_DECL,"int getRangeLongFromObjectOrReply(client *c, robj *o, long min, long max, long *target, const char *msg);",5,104,server.h,getRangeLongFromObjectOrReply,,false,2765,2765,getRangeLongFromObjectOrReply,,,447,"int getRangeLongFromObjectOrReply (client*,robj*,long,long,long*,char*)"
394008,METHOD,server.h:<global>,TYPE_DECL,"int checkType(client *c, robj *o, int type);",5,43,server.h,checkType,,false,2766,2766,checkType,,,448,"int checkType (client*,robj*,int)"
394015,METHOD,server.h:<global>,TYPE_DECL,"int getLongLongFromObjectOrReply(client *c, robj *o, long long *target, const char *msg);",5,88,server.h,getLongLongFromObjectOrReply,,false,2767,2767,getLongLongFromObjectOrReply,,,449,"int getLongLongFromObjectOrReply (client*,robj*,long long*,char*)"
394023,METHOD,server.h:<global>,TYPE_DECL,"int getDoubleFromObjectOrReply(client *c, robj *o, double *target, const char *msg);",5,83,server.h,getDoubleFromObjectOrReply,,false,2768,2768,getDoubleFromObjectOrReply,,,450,"int getDoubleFromObjectOrReply (client*,robj*,double*,char*)"
394031,METHOD,server.h:<global>,TYPE_DECL,"int getDoubleFromObject(const robj *o, double *target);",5,54,server.h,getDoubleFromObject,,false,2769,2769,getDoubleFromObject,,,451,"int getDoubleFromObject (robj*,double*)"
394037,METHOD,server.h:<global>,TYPE_DECL,"int getLongLongFromObject(robj *o, long long *target);",5,53,server.h,getLongLongFromObject,,false,2770,2770,getLongLongFromObject,,,452,"int getLongLongFromObject (robj*,long long*)"
394043,METHOD,server.h:<global>,TYPE_DECL,"int getLongDoubleFromObject(robj *o, long double *target);",5,57,server.h,getLongDoubleFromObject,,false,2771,2771,getLongDoubleFromObject,,,453,"int getLongDoubleFromObject (robj*,long double*)"
394049,METHOD,server.h:<global>,TYPE_DECL,"int getLongDoubleFromObjectOrReply(client *c, robj *o, long double *target, const char *msg);",5,92,server.h,getLongDoubleFromObjectOrReply,,false,2772,2772,getLongDoubleFromObjectOrReply,,,454,"int getLongDoubleFromObjectOrReply (client*,robj*,long double*,char*)"
394057,METHOD,server.h:<global>,TYPE_DECL,"int getIntFromObjectOrReply(client *c, robj *o, int *target, const char *msg);",5,77,server.h,getIntFromObjectOrReply,,false,2773,2773,getIntFromObjectOrReply,,,455,"int getIntFromObjectOrReply (client*,robj*,int*,char*)"
394065,METHOD,server.h:<global>,TYPE_DECL,char *strEncoding(int encoding);,6,31,server.h,strEncoding,,false,2774,2774,strEncoding,,,456,char* strEncoding (int)
394070,METHOD,server.h:<global>,TYPE_DECL,"int compareStringObjects(const robj *a, const robj *b);",5,54,server.h,compareStringObjects,,false,2775,2775,compareStringObjects,,,457,"int compareStringObjects (robj*,robj*)"
394076,METHOD,server.h:<global>,TYPE_DECL,"int collateStringObjects(const robj *a, const robj *b);",5,54,server.h,collateStringObjects,,false,2776,2776,collateStringObjects,,,458,"int collateStringObjects (robj*,robj*)"
394082,METHOD,server.h:<global>,TYPE_DECL,"int equalStringObjects(robj *a, robj *b);",5,40,server.h,equalStringObjects,,false,2777,2777,equalStringObjects,,,459,"int equalStringObjects (robj*,robj*)"
394088,METHOD,server.h:<global>,TYPE_DECL,unsigned long long estimateObjectIdleTime(robj *o);,20,50,server.h,estimateObjectIdleTime,,false,2778,2778,estimateObjectIdleTime,,,460,long long unsigned estimateObjectIdleTime (robj*)
394093,METHOD,server.h:<global>,TYPE_DECL,"void trimStringObjectIfNeeded(robj *o, int trim_small_values);",6,61,server.h,trimStringObjectIfNeeded,,false,2779,2779,trimStringObjectIfNeeded,,,461,"void trimStringObjectIfNeeded (robj*,int)"
394099,METHOD,server.h:<global>,TYPE_DECL,"ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);",9,69,server.h,syncWrite,,false,2783,2783,syncWrite,,,462,"ssize_t syncWrite (int,char*,ssize_t,long long)"
394107,METHOD,server.h:<global>,TYPE_DECL,"ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);",9,68,server.h,syncRead,,false,2784,2784,syncRead,,,463,"ssize_t syncRead (int,char*,ssize_t,long long)"
394115,METHOD,server.h:<global>,TYPE_DECL,"ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout);",9,72,server.h,syncReadLine,,false,2785,2785,syncReadLine,,,464,"ssize_t syncReadLine (int,char*,ssize_t,long long)"
394123,METHOD,server.h:<global>,TYPE_DECL,"void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);",6,75,server.h,replicationFeedSlaves,,false,2788,2788,replicationFeedSlaves,,,465,"void replicationFeedSlaves (list*,int,robj**,int)"
394131,METHOD,server.h:<global>,TYPE_DECL,"void replicationFeedStreamFromMasterStream(char *buf, size_t buflen);",6,68,server.h,replicationFeedStreamFromMasterStream,,false,2789,2789,replicationFeedStreamFromMasterStream,,,466,"void replicationFeedStreamFromMasterStream (char*,size_t)"
394137,METHOD,server.h:<global>,TYPE_DECL,void resetReplicationBuffer(void);,6,33,server.h,resetReplicationBuffer,,false,2790,2790,resetReplicationBuffer,,,467,void resetReplicationBuffer (void)
394142,METHOD,server.h:<global>,TYPE_DECL,"void feedReplicationBuffer(char *buf, size_t len);",6,49,server.h,feedReplicationBuffer,,false,2791,2791,feedReplicationBuffer,,,468,"void feedReplicationBuffer (char*,size_t)"
394148,METHOD,server.h:<global>,TYPE_DECL,void freeReplicaReferencedReplBuffer(client *replica);,6,53,server.h,freeReplicaReferencedReplBuffer,,false,2792,2792,freeReplicaReferencedReplBuffer,,,469,void freeReplicaReferencedReplBuffer (client*)
394153,METHOD,server.h:<global>,TYPE_DECL,"void replicationFeedMonitors(client *c, list *monitors, int dictid, robj **argv, int argc);",6,90,server.h,replicationFeedMonitors,,false,2793,2793,replicationFeedMonitors,,,470,"void replicationFeedMonitors (client*,list*,int,robj**,int)"
394162,METHOD,server.h:<global>,TYPE_DECL,"void updateSlavesWaitingBgsave(int bgsaveerr, int type);",6,55,server.h,updateSlavesWaitingBgsave,,false,2794,2794,updateSlavesWaitingBgsave,,,471,"void updateSlavesWaitingBgsave (int,int)"
394168,METHOD,server.h:<global>,TYPE_DECL,void replicationCron(void);,6,26,server.h,replicationCron,,false,2795,2795,replicationCron,,,472,void replicationCron (void)
394173,METHOD,server.h:<global>,TYPE_DECL,void replicationStartPendingFork(void);,6,38,server.h,replicationStartPendingFork,,false,2796,2796,replicationStartPendingFork,,,473,void replicationStartPendingFork (void)
394178,METHOD,server.h:<global>,TYPE_DECL,void replicationHandleMasterDisconnection(void);,6,47,server.h,replicationHandleMasterDisconnection,,false,2797,2797,replicationHandleMasterDisconnection,,,474,void replicationHandleMasterDisconnection (void)
394183,METHOD,server.h:<global>,TYPE_DECL,void replicationCacheMaster(client *c);,6,38,server.h,replicationCacheMaster,,false,2798,2798,replicationCacheMaster,,,475,void replicationCacheMaster (client*)
394188,METHOD,server.h:<global>,TYPE_DECL,void resizeReplicationBacklog(void);,6,35,server.h,resizeReplicationBacklog,,false,2799,2799,resizeReplicationBacklog,,,476,void resizeReplicationBacklog (void)
394193,METHOD,server.h:<global>,TYPE_DECL,"void replicationSetMaster(char *ip, int port);",6,45,server.h,replicationSetMaster,,false,2800,2800,replicationSetMaster,,,477,"void replicationSetMaster (char*,int)"
394199,METHOD,server.h:<global>,TYPE_DECL,void replicationUnsetMaster(void);,6,33,server.h,replicationUnsetMaster,,false,2801,2801,replicationUnsetMaster,,,478,void replicationUnsetMaster (void)
394204,METHOD,server.h:<global>,TYPE_DECL,void refreshGoodSlavesCount(void);,6,33,server.h,refreshGoodSlavesCount,,false,2802,2802,refreshGoodSlavesCount,,,479,void refreshGoodSlavesCount (void)
394209,METHOD,server.h:<global>,TYPE_DECL,int checkGoodReplicasStatus(void);,5,33,server.h,checkGoodReplicasStatus,,false,2803,2803,checkGoodReplicasStatus,,,480,int checkGoodReplicasStatus (void)
394214,METHOD,server.h:<global>,TYPE_DECL,void processClientsWaitingReplicas(void);,6,40,server.h,processClientsWaitingReplicas,,false,2804,2804,processClientsWaitingReplicas,,,481,void processClientsWaitingReplicas (void)
394219,METHOD,server.h:<global>,TYPE_DECL,void unblockClientWaitingReplicas(client *c);,6,44,server.h,unblockClientWaitingReplicas,,false,2805,2805,unblockClientWaitingReplicas,,,482,void unblockClientWaitingReplicas (client*)
394224,METHOD,server.h:<global>,TYPE_DECL,int replicationCountAcksByOffset(long long offset);,5,50,server.h,replicationCountAcksByOffset,,false,2806,2806,replicationCountAcksByOffset,,,483,int replicationCountAcksByOffset (long long)
394229,METHOD,server.h:<global>,TYPE_DECL,int replicationCountAOFAcksByOffset(long long offset);,5,53,server.h,replicationCountAOFAcksByOffset,,false,2807,2807,replicationCountAOFAcksByOffset,,,484,int replicationCountAOFAcksByOffset (long long)
394234,METHOD,server.h:<global>,TYPE_DECL,void replicationSendNewlineToMaster(void);,6,41,server.h,replicationSendNewlineToMaster,,false,2808,2808,replicationSendNewlineToMaster,,,485,void replicationSendNewlineToMaster (void)
394239,METHOD,server.h:<global>,TYPE_DECL,long long replicationGetSlaveOffset(void);,11,41,server.h,replicationGetSlaveOffset,,false,2809,2809,replicationGetSlaveOffset,,,486,long long replicationGetSlaveOffset (void)
394244,METHOD,server.h:<global>,TYPE_DECL,char *replicationGetSlaveName(client *c);,6,40,server.h,replicationGetSlaveName,,false,2810,2810,replicationGetSlaveName,,,487,char* replicationGetSlaveName (client*)
394249,METHOD,server.h:<global>,TYPE_DECL,long long getPsyncInitialOffset(void);,11,37,server.h,getPsyncInitialOffset,,false,2811,2811,getPsyncInitialOffset,,,488,long long getPsyncInitialOffset (void)
394254,METHOD,server.h:<global>,TYPE_DECL,"int replicationSetupSlaveForFullResync(client *slave, long long offset);",5,71,server.h,replicationSetupSlaveForFullResync,,false,2812,2812,replicationSetupSlaveForFullResync,,,489,"int replicationSetupSlaveForFullResync (client*,long long)"
394260,METHOD,server.h:<global>,TYPE_DECL,void changeReplicationId(void);,6,30,server.h,changeReplicationId,,false,2813,2813,changeReplicationId,,,490,void changeReplicationId (void)
394265,METHOD,server.h:<global>,TYPE_DECL,void clearReplicationId2(void);,6,30,server.h,clearReplicationId2,,false,2814,2814,clearReplicationId2,,,491,void clearReplicationId2 (void)
394270,METHOD,server.h:<global>,TYPE_DECL,void createReplicationBacklog(void);,6,35,server.h,createReplicationBacklog,,false,2815,2815,createReplicationBacklog,,,492,void createReplicationBacklog (void)
394275,METHOD,server.h:<global>,TYPE_DECL,void freeReplicationBacklog(void);,6,33,server.h,freeReplicationBacklog,,false,2816,2816,freeReplicationBacklog,,,493,void freeReplicationBacklog (void)
394280,METHOD,server.h:<global>,TYPE_DECL,void replicationCacheMasterUsingMyself(void);,6,44,server.h,replicationCacheMasterUsingMyself,,false,2817,2817,replicationCacheMasterUsingMyself,,,494,void replicationCacheMasterUsingMyself (void)
394285,METHOD,server.h:<global>,TYPE_DECL,"void feedReplicationBacklog(void *ptr, size_t len);",6,50,server.h,feedReplicationBacklog,,false,2818,2818,feedReplicationBacklog,,,495,"void feedReplicationBacklog (void*,size_t)"
394291,METHOD,server.h:<global>,TYPE_DECL,void incrementalTrimReplicationBacklog(size_t blocks);,6,53,server.h,incrementalTrimReplicationBacklog,,false,2819,2819,incrementalTrimReplicationBacklog,,,496,void incrementalTrimReplicationBacklog (size_t)
394296,METHOD,server.h:<global>,TYPE_DECL,int canFeedReplicaReplBuffer(client *replica);,5,45,server.h,canFeedReplicaReplBuffer,,false,2820,2820,canFeedReplicaReplBuffer,,,497,int canFeedReplicaReplBuffer (client*)
394301,METHOD,server.h:<global>,TYPE_DECL,void rebaseReplicationBuffer(long long base_repl_offset);,6,56,server.h,rebaseReplicationBuffer,,false,2821,2821,rebaseReplicationBuffer,,,498,void rebaseReplicationBuffer (long long)
394306,METHOD,server.h:<global>,TYPE_DECL,void showLatestBacklog(void);,6,28,server.h,showLatestBacklog,,false,2822,2822,showLatestBacklog,,,499,void showLatestBacklog (void)
394311,METHOD,server.h:<global>,TYPE_DECL,"void rdbPipeReadHandler(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);",6,90,server.h,rdbPipeReadHandler,,false,2823,2823,rdbPipeReadHandler,,,500,"void rdbPipeReadHandler (aeEventLoop*,int,void*,int)"
394319,METHOD,server.h:<global>,TYPE_DECL,void rdbPipeWriteHandlerConnRemoved(struct connection *conn);,6,60,server.h,rdbPipeWriteHandlerConnRemoved,,false,2824,2824,rdbPipeWriteHandlerConnRemoved,,,501,void rdbPipeWriteHandlerConnRemoved (connection*)
394324,METHOD,server.h:<global>,TYPE_DECL,void clearFailoverState(void);,6,29,server.h,clearFailoverState,,false,2825,2825,clearFailoverState,,,502,void clearFailoverState (void)
394329,METHOD,server.h:<global>,TYPE_DECL,void updateFailoverStatus(void);,6,31,server.h,updateFailoverStatus,,false,2826,2826,updateFailoverStatus,,,503,void updateFailoverStatus (void)
394334,METHOD,server.h:<global>,TYPE_DECL,void abortFailover(const char *err);,6,35,server.h,abortFailover,,false,2827,2827,abortFailover,,,504,void abortFailover (char*)
394339,METHOD,server.h:<global>,TYPE_DECL,const char *getFailoverStateString(void);,12,40,server.h,getFailoverStateString,,false,2828,2828,getFailoverStateString,,,505,char* getFailoverStateString (void)
394344,METHOD,server.h:<global>,TYPE_DECL,"void startLoadingFile(size_t size, char* filename, int rdbflags);",6,64,server.h,startLoadingFile,,false,2831,2831,startLoadingFile,,,506,"void startLoadingFile (size_t,char*,int)"
394351,METHOD,server.h:<global>,TYPE_DECL,"void startLoading(size_t size, int rdbflags, int async);",6,55,server.h,startLoading,,false,2832,2832,startLoading,,,507,"void startLoading (size_t,int,int)"
394358,METHOD,server.h:<global>,TYPE_DECL,void loadingAbsProgress(off_t pos);,6,34,server.h,loadingAbsProgress,,false,2833,2833,loadingAbsProgress,,,508,void loadingAbsProgress (off_t)
394363,METHOD,server.h:<global>,TYPE_DECL,void loadingIncrProgress(off_t size);,6,36,server.h,loadingIncrProgress,,false,2834,2834,loadingIncrProgress,,,509,void loadingIncrProgress (off_t)
394368,METHOD,server.h:<global>,TYPE_DECL,void stopLoading(int success);,6,29,server.h,stopLoading,,false,2835,2835,stopLoading,,,510,void stopLoading (int)
394373,METHOD,server.h:<global>,TYPE_DECL,void updateLoadingFileName(char* filename);,6,42,server.h,updateLoadingFileName,,false,2836,2836,updateLoadingFileName,,,511,void updateLoadingFileName (char*)
394378,METHOD,server.h:<global>,TYPE_DECL,void startSaving(int rdbflags);,6,30,server.h,startSaving,,false,2837,2837,startSaving,,,512,void startSaving (int)
394383,METHOD,server.h:<global>,TYPE_DECL,void stopSaving(int success);,6,28,server.h,stopSaving,,false,2838,2838,stopSaving,,,513,void stopSaving (int)
394388,METHOD,server.h:<global>,TYPE_DECL,int allPersistenceDisabled(void);,5,32,server.h,allPersistenceDisabled,,false,2839,2839,allPersistenceDisabled,,,514,int allPersistenceDisabled (void)
394393,METHOD,server.h:<global>,TYPE_DECL,int writeCommandsDeniedByDiskError(void);,5,40,server.h,writeCommandsDeniedByDiskError,,false,2844,2844,writeCommandsDeniedByDiskError,,,515,int writeCommandsDeniedByDiskError (void)
394398,METHOD,server.h:<global>,TYPE_DECL,sds writeCommandsGetDiskErrorMessage(int);,5,41,server.h,writeCommandsGetDiskErrorMessage,,false,2845,2845,writeCommandsGetDiskErrorMessage,,,516,sds writeCommandsGetDiskErrorMessage (int)
394403,METHOD,server.h:<global>,TYPE_DECL,void killRDBChild(void);,6,23,server.h,killRDBChild,,false,2849,2849,killRDBChild,,,517,void killRDBChild (void)
394408,METHOD,server.h:<global>,TYPE_DECL,int bg_unlink(const char *filename);,5,35,server.h,bg_unlink,,false,2850,2850,bg_unlink,,,518,int bg_unlink (char*)
394413,METHOD,server.h:<global>,TYPE_DECL,void flushAppendOnlyFile(int force);,6,35,server.h,flushAppendOnlyFile,,false,2853,2853,flushAppendOnlyFile,,,519,void flushAppendOnlyFile (int)
394418,METHOD,server.h:<global>,TYPE_DECL,"void feedAppendOnlyFile(int dictid, robj **argv, int argc);",6,58,server.h,feedAppendOnlyFile,,false,2854,2854,feedAppendOnlyFile,,,520,"void feedAppendOnlyFile (int,robj**,int)"
394425,METHOD,server.h:<global>,TYPE_DECL,void aofRemoveTempFile(pid_t childpid);,6,38,server.h,aofRemoveTempFile,,false,2855,2855,aofRemoveTempFile,,,521,void aofRemoveTempFile (pid_t)
394430,METHOD,server.h:<global>,TYPE_DECL,int rewriteAppendOnlyFileBackground(void);,5,41,server.h,rewriteAppendOnlyFileBackground,,false,2856,2856,rewriteAppendOnlyFileBackground,,,522,int rewriteAppendOnlyFileBackground (void)
394435,METHOD,server.h:<global>,TYPE_DECL,int loadAppendOnlyFiles(aofManifest *am);,5,40,server.h,loadAppendOnlyFiles,,false,2857,2857,loadAppendOnlyFiles,,,523,int loadAppendOnlyFiles (aofManifest*)
394440,METHOD,server.h:<global>,TYPE_DECL,void stopAppendOnly(void);,6,25,server.h,stopAppendOnly,,false,2858,2858,stopAppendOnly,,,524,void stopAppendOnly (void)
394445,METHOD,server.h:<global>,TYPE_DECL,int startAppendOnly(void);,5,25,server.h,startAppendOnly,,false,2859,2859,startAppendOnly,,,525,int startAppendOnly (void)
394450,METHOD,server.h:<global>,TYPE_DECL,"void backgroundRewriteDoneHandler(int exitcode, int bysignal);",6,61,server.h,backgroundRewriteDoneHandler,,false,2860,2860,backgroundRewriteDoneHandler,,,526,"void backgroundRewriteDoneHandler (int,int)"
394456,METHOD,server.h:<global>,TYPE_DECL,void killAppendOnlyChild(void);,6,30,server.h,killAppendOnlyChild,,false,2861,2861,killAppendOnlyChild,,,527,void killAppendOnlyChild (void)
394461,METHOD,server.h:<global>,TYPE_DECL,void restartAOFAfterSYNC(void);,6,30,server.h,restartAOFAfterSYNC,,false,2862,2862,restartAOFAfterSYNC,,,528,void restartAOFAfterSYNC (void)
394466,METHOD,server.h:<global>,TYPE_DECL,void aofLoadManifestFromDisk(void);,6,34,server.h,aofLoadManifestFromDisk,,false,2863,2863,aofLoadManifestFromDisk,,,529,void aofLoadManifestFromDisk (void)
394471,METHOD,server.h:<global>,TYPE_DECL,void aofOpenIfNeededOnServerStart(void);,6,39,server.h,aofOpenIfNeededOnServerStart,,false,2864,2864,aofOpenIfNeededOnServerStart,,,530,void aofOpenIfNeededOnServerStart (void)
394476,METHOD,server.h:<global>,TYPE_DECL,void aofManifestFree(aofManifest *am);,6,37,server.h,aofManifestFree,,false,2865,2865,aofManifestFree,,,531,void aofManifestFree (aofManifest*)
394481,METHOD,server.h:<global>,TYPE_DECL,int aofDelHistoryFiles(void);,5,28,server.h,aofDelHistoryFiles,,false,2866,2866,aofDelHistoryFiles,,,532,int aofDelHistoryFiles (void)
394486,METHOD,server.h:<global>,TYPE_DECL,int aofRewriteLimited(void);,5,27,server.h,aofRewriteLimited,,false,2867,2867,aofRewriteLimited,,,533,int aofRewriteLimited (void)
394491,METHOD,server.h:<global>,TYPE_DECL,void openChildInfoPipe(void);,6,28,server.h,openChildInfoPipe,,false,2870,2870,openChildInfoPipe,,,534,void openChildInfoPipe (void)
394496,METHOD,server.h:<global>,TYPE_DECL,void closeChildInfoPipe(void);,6,29,server.h,closeChildInfoPipe,,false,2871,2871,closeChildInfoPipe,,,535,void closeChildInfoPipe (void)
394501,METHOD,server.h:<global>,TYPE_DECL,"void sendChildInfoGeneric(childInfoType info_type, size_t keys, double progress, char *pname);",6,93,server.h,sendChildInfoGeneric,,false,2872,2872,sendChildInfoGeneric,,,536,"void sendChildInfoGeneric (childInfoType,size_t,double,char*)"
394509,METHOD,server.h:<global>,TYPE_DECL,"void sendChildCowInfo(childInfoType info_type, char *pname);",6,59,server.h,sendChildCowInfo,,false,2873,2873,sendChildCowInfo,,,537,"void sendChildCowInfo (childInfoType,char*)"
394515,METHOD,server.h:<global>,TYPE_DECL,"void sendChildInfo(childInfoType info_type, size_t keys, char *pname);",6,69,server.h,sendChildInfo,,false,2874,2874,sendChildInfo,,,538,"void sendChildInfo (childInfoType,size_t,char*)"
394522,METHOD,server.h:<global>,TYPE_DECL,void receiveChildInfo(void);,6,27,server.h,receiveChildInfo,,false,2875,2875,receiveChildInfo,,,539,void receiveChildInfo (void)
394527,METHOD,server.h:<global>,TYPE_DECL,int redisFork(int purpose);,5,26,server.h,redisFork,,false,2878,2878,redisFork,,,540,int redisFork (int)
394532,METHOD,server.h:<global>,TYPE_DECL,int hasActiveChildProcess(void);,5,31,server.h,hasActiveChildProcess,,false,2879,2879,hasActiveChildProcess,,,541,int hasActiveChildProcess (void)
394537,METHOD,server.h:<global>,TYPE_DECL,void resetChildState(void);,6,26,server.h,resetChildState,,false,2880,2880,resetChildState,,,542,void resetChildState (void)
394542,METHOD,server.h:<global>,TYPE_DECL,int isMutuallyExclusiveChildType(int type);,5,42,server.h,isMutuallyExclusiveChildType,,false,2881,2881,isMutuallyExclusiveChildType,,,543,int isMutuallyExclusiveChildType (int)
394549,METHOD,server.h:<global>,TYPE_DECL,void ACLInit(void);,6,18,server.h,ACLInit,,false,2886,2886,ACLInit,,,546,void ACLInit (void)
394559,METHOD,<empty>,<empty>,<empty>,1,,server.h,AuthResult:<clinit>,,false,2906,,<clinit>,,,5,
394567,METHOD,server.h:<global>,TYPE_DECL,"int ACLCheckUserCredentials(robj *username, robj *password);",5,59,server.h,ACLCheckUserCredentials,,false,2913,2913,ACLCheckUserCredentials,,,549,"int ACLCheckUserCredentials (robj*,robj*)"
394573,METHOD,server.h:<global>,TYPE_DECL,"int ACLAuthenticateUser(client *c, robj *username, robj *password, robj **err);",5,78,server.h,ACLAuthenticateUser,,false,2914,2914,ACLAuthenticateUser,,,550,"int ACLAuthenticateUser (client*,robj*,robj*,robj**)"
394581,METHOD,server.h:<global>,TYPE_DECL,"int checkModuleAuthentication(client *c, robj *username, robj *password, robj **err);",5,84,server.h,checkModuleAuthentication,,false,2915,2915,checkModuleAuthentication,,,551,"int checkModuleAuthentication (client*,robj*,robj*,robj**)"
394589,METHOD,server.h:<global>,TYPE_DECL,"void addAuthErrReply(client *c, robj *err);",6,42,server.h,addAuthErrReply,,false,2916,2916,addAuthErrReply,,,552,"void addAuthErrReply (client*,robj*)"
394595,METHOD,server.h:<global>,TYPE_DECL,unsigned long ACLGetCommandID(sds cmdname);,15,42,server.h,ACLGetCommandID,,false,2917,2917,ACLGetCommandID,,,553,long unsigned ACLGetCommandID (sds)
394600,METHOD,server.h:<global>,TYPE_DECL,void ACLClearCommandID(void);,6,28,server.h,ACLClearCommandID,,false,2918,2918,ACLClearCommandID,,,554,void ACLClearCommandID (void)
394605,METHOD,server.h:<global>,TYPE_DECL,"user *ACLGetUserByName(const char *name, size_t namelen);",6,56,server.h,ACLGetUserByName,,false,2919,2919,ACLGetUserByName,,,555,"user* ACLGetUserByName (char*,size_t)"
394611,METHOD,server.h:<global>,TYPE_DECL,"int ACLUserCheckKeyPerm(user *u, const char *key, int keylen, int flags);",5,72,server.h,ACLUserCheckKeyPerm,,false,2920,2920,ACLUserCheckKeyPerm,,,556,"int ACLUserCheckKeyPerm (user*,char*,int,int)"
394619,METHOD,server.h:<global>,TYPE_DECL,"int ACLUserCheckChannelPerm(user *u, sds channel, int literal);",5,62,server.h,ACLUserCheckChannelPerm,,false,2921,2921,ACLUserCheckChannelPerm,,,557,"int ACLUserCheckChannelPerm (user*,sds,int)"
394626,METHOD,server.h:<global>,TYPE_DECL,"int ACLCheckAllUserCommandPerm(user *u, struct redisCommand *cmd, robj **argv, int argc, int *idxptr);",5,101,server.h,ACLCheckAllUserCommandPerm,,false,2922,2922,ACLCheckAllUserCommandPerm,,,558,"int ACLCheckAllUserCommandPerm (user*,redisCommand*,robj**,int,int*)"
394635,METHOD,server.h:<global>,TYPE_DECL,"int ACLUserCheckCmdWithUnrestrictedKeyAccess(user *u, struct redisCommand *cmd, robj **argv, int argc, int flags);",5,113,server.h,ACLUserCheckCmdWithUnrestrictedKeyAccess,,false,2923,2923,ACLUserCheckCmdWithUnrestrictedKeyAccess,,,559,"int ACLUserCheckCmdWithUnrestrictedKeyAccess (user*,redisCommand*,robj**,int,int)"
394644,METHOD,server.h:<global>,TYPE_DECL,"int ACLCheckAllPerm(client *c, int *idxptr);",5,43,server.h,ACLCheckAllPerm,,false,2924,2924,ACLCheckAllPerm,,,560,"int ACLCheckAllPerm (client*,int*)"
394650,METHOD,server.h:<global>,TYPE_DECL,"int ACLSetUser(user *u, const char *op, ssize_t oplen);",5,54,server.h,ACLSetUser,,false,2925,2925,ACLSetUser,,,561,"int ACLSetUser (user*,char*,ssize_t)"
394657,METHOD,server.h:<global>,TYPE_DECL,"sds ACLStringSetUser(user *u, sds username, sds *argv, int argc);",5,64,server.h,ACLStringSetUser,,false,2926,2926,ACLStringSetUser,,,562,"sds ACLStringSetUser (user*,sds,sds*,int)"
394665,METHOD,server.h:<global>,TYPE_DECL,uint64_t ACLGetCommandCategoryFlagByName(const char *name);,10,58,server.h,ACLGetCommandCategoryFlagByName,,false,2927,2927,ACLGetCommandCategoryFlagByName,,,563,uint64_t ACLGetCommandCategoryFlagByName (char*)
394670,METHOD,server.h:<global>,TYPE_DECL,"int ACLAppendUserForLoading(sds *argv, int argc, int *argc_err);",5,63,server.h,ACLAppendUserForLoading,,false,2928,2928,ACLAppendUserForLoading,,,564,"int ACLAppendUserForLoading (sds*,int,int*)"
394677,METHOD,server.h:<global>,TYPE_DECL,const char *ACLSetUserStringError(void);,12,39,server.h,ACLSetUserStringError,,false,2929,2929,ACLSetUserStringError,,,565,char* ACLSetUserStringError (void)
394682,METHOD,server.h:<global>,TYPE_DECL,int ACLLoadConfiguredUsers(void);,5,32,server.h,ACLLoadConfiguredUsers,,false,2930,2930,ACLLoadConfiguredUsers,,,566,int ACLLoadConfiguredUsers (void)
394687,METHOD,server.h:<global>,TYPE_DECL,robj *ACLDescribeUser(user *u);,6,30,server.h,ACLDescribeUser,,false,2931,2931,ACLDescribeUser,,,567,robj* ACLDescribeUser (user*)
394692,METHOD,server.h:<global>,TYPE_DECL,void ACLLoadUsersAtStartup(void);,6,32,server.h,ACLLoadUsersAtStartup,,false,2932,2932,ACLLoadUsersAtStartup,,,568,void ACLLoadUsersAtStartup (void)
394697,METHOD,server.h:<global>,TYPE_DECL,"void addReplyCommandCategories(client *c, struct redisCommand *cmd);",6,67,server.h,addReplyCommandCategories,,false,2933,2933,addReplyCommandCategories,,,569,"void addReplyCommandCategories (client*,redisCommand*)"
394703,METHOD,server.h:<global>,TYPE_DECL,user *ACLCreateUnlinkedUser(void);,6,33,server.h,ACLCreateUnlinkedUser,,false,2934,2934,ACLCreateUnlinkedUser,,,570,user* ACLCreateUnlinkedUser (void)
394708,METHOD,server.h:<global>,TYPE_DECL,void ACLFreeUserAndKillClients(user *u);,6,39,server.h,ACLFreeUserAndKillClients,,false,2935,2935,ACLFreeUserAndKillClients,,,571,void ACLFreeUserAndKillClients (user*)
394713,METHOD,server.h:<global>,TYPE_DECL,"void addACLLogEntry(client *c, int reason, int context, int argpos, sds username, sds object);",6,93,server.h,addACLLogEntry,,false,2936,2936,addACLLogEntry,,,572,"void addACLLogEntry (client*,int,int,int,sds,sds)"
394723,METHOD,server.h:<global>,TYPE_DECL,"sds getAclErrorMessage(int acl_res, user *user, struct redisCommand *cmd, sds errored_val, int verbose);",5,103,server.h,getAclErrorMessage,,false,2937,2937,getAclErrorMessage,,,573,"sds getAclErrorMessage (int,user*,redisCommand*,sds,int)"
394732,METHOD,server.h:<global>,TYPE_DECL,void ACLUpdateDefaultUserPassword(sds password);,6,47,server.h,ACLUpdateDefaultUserPassword,,false,2938,2938,ACLUpdateDefaultUserPassword,,,574,void ACLUpdateDefaultUserPassword (sds)
394737,METHOD,server.h:<global>,TYPE_DECL,sds genRedisInfoStringACLStats(sds info);,5,40,server.h,genRedisInfoStringACLStats,,false,2939,2939,genRedisInfoStringACLStats,,,575,sds genRedisInfoStringACLStats (sds)
394742,METHOD,server.h:<global>,TYPE_DECL,void ACLRecomputeCommandBitsFromCommandRulesAllUsers(void);,6,58,server.h,ACLRecomputeCommandBitsFromCommandRulesAllUsers,,false,2940,2940,ACLRecomputeCommandBitsFromCommandRulesAllUsers,,,576,void ACLRecomputeCommandBitsFromCommandRulesAllUsers (void)
394759,METHOD,server.h:<global>,TYPE_DECL,zskiplist *zslCreate(void);,11,26,server.h,zslCreate,,false,2974,2974,zslCreate,,,581,zskiplist* zslCreate (void)
394764,METHOD,server.h:<global>,TYPE_DECL,void zslFree(zskiplist *zsl);,6,28,server.h,zslFree,,false,2975,2975,zslFree,,,582,void zslFree (zskiplist*)
394769,METHOD,server.h:<global>,TYPE_DECL,"zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele);",15,63,server.h,zslInsert,,false,2976,2976,zslInsert,,,583,"zskiplistNode* zslInsert (zskiplist*,double,sds)"
394776,METHOD,server.h:<global>,TYPE_DECL,"unsigned char *zzlInsert(unsigned char *zl, sds ele, double score);",15,66,server.h,zzlInsert,,false,2977,2977,zzlInsert,,,584,"unsigned char* zzlInsert (unsigned char*,sds,double)"
394783,METHOD,server.h:<global>,TYPE_DECL,"int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node);",5,74,server.h,zslDelete,,false,2978,2978,zslDelete,,,585,"int zslDelete (zskiplist*,double,sds,zskiplistNode**)"
394791,METHOD,server.h:<global>,TYPE_DECL,"zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);",15,65,server.h,zslFirstInRange,,false,2979,2979,zslFirstInRange,,,586,"zskiplistNode* zslFirstInRange (zskiplist*,zrangespec*)"
394797,METHOD,server.h:<global>,TYPE_DECL,"zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);",15,64,server.h,zslLastInRange,,false,2980,2980,zslLastInRange,,,587,"zskiplistNode* zslLastInRange (zskiplist*,zrangespec*)"
394803,METHOD,server.h:<global>,TYPE_DECL,double zzlGetScore(unsigned char *sptr);,8,39,server.h,zzlGetScore,,false,2981,2981,zzlGetScore,,,588,double zzlGetScore (unsigned char*)
394808,METHOD,server.h:<global>,TYPE_DECL,"void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);",6,75,server.h,zzlNext,,false,2982,2982,zzlNext,,,589,"void zzlNext (unsigned char*,unsigned char**,unsigned char**)"
394815,METHOD,server.h:<global>,TYPE_DECL,"void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);",6,75,server.h,zzlPrev,,false,2983,2983,zzlPrev,,,590,"void zzlPrev (unsigned char*,unsigned char**,unsigned char**)"
394822,METHOD,server.h:<global>,TYPE_DECL,"unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range);",15,68,server.h,zzlFirstInRange,,false,2984,2984,zzlFirstInRange,,,591,"unsigned char* zzlFirstInRange (unsigned char*,zrangespec*)"
394828,METHOD,server.h:<global>,TYPE_DECL,"unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range);",15,67,server.h,zzlLastInRange,,false,2985,2985,zzlLastInRange,,,592,"unsigned char* zzlLastInRange (unsigned char*,zrangespec*)"
394834,METHOD,server.h:<global>,TYPE_DECL,unsigned long zsetLength(const robj *zobj);,15,42,server.h,zsetLength,,false,2986,2986,zsetLength,,,593,long unsigned zsetLength (robj*)
394839,METHOD,server.h:<global>,TYPE_DECL,"void zsetConvert(robj *zobj, int encoding);",6,42,server.h,zsetConvert,,false,2987,2987,zsetConvert,,,594,"void zsetConvert (robj*,int)"
394845,METHOD,server.h:<global>,TYPE_DECL,"void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen);",6,82,server.h,zsetConvertToListpackIfNeeded,,false,2988,2988,zsetConvertToListpackIfNeeded,,,595,"void zsetConvertToListpackIfNeeded (robj*,size_t,size_t)"
394852,METHOD,server.h:<global>,TYPE_DECL,"int zsetScore(robj *zobj, sds member, double *score);",5,52,server.h,zsetScore,,false,2989,2989,zsetScore,,,596,"int zsetScore (robj*,sds,double*)"
394859,METHOD,server.h:<global>,TYPE_DECL,"unsigned long zslGetRank(zskiplist *zsl, double score, sds o);",15,61,server.h,zslGetRank,,false,2990,2990,zslGetRank,,,597,"long unsigned zslGetRank (zskiplist*,double,sds)"
394866,METHOD,server.h:<global>,TYPE_DECL,"int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore);",5,94,server.h,zsetAdd,,false,2991,2991,zsetAdd,,,598,"int zsetAdd (robj*,double,sds,int,int*,double*)"
394876,METHOD,server.h:<global>,TYPE_DECL,"long zsetRank(robj *zobj, sds ele, int reverse, double *score);",6,62,server.h,zsetRank,,false,2992,2992,zsetRank,,,599,"long zsetRank (robj*,sds,int,double*)"
394884,METHOD,server.h:<global>,TYPE_DECL,"int zsetDel(robj *zobj, sds ele);",5,32,server.h,zsetDel,,false,2993,2993,zsetDel,,,600,"int zsetDel (robj*,sds)"
394890,METHOD,server.h:<global>,TYPE_DECL,robj *zsetDup(robj *o);,6,22,server.h,zsetDup,,false,2994,2994,zsetDup,,,601,robj* zsetDup (robj*)
394895,METHOD,server.h:<global>,TYPE_DECL,"void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey, long count, int use_nested_array, int reply_nil_when_empty, int *deleted);",6,155,server.h,genericZpopCommand,,false,2995,2995,genericZpopCommand,,,602,"void genericZpopCommand (client*,robj**,int,int,int,long,int,int,int*)"
394908,METHOD,server.h:<global>,TYPE_DECL,sds lpGetObject(unsigned char *sptr);,5,36,server.h,lpGetObject,,false,2996,2996,lpGetObject,,,603,sds lpGetObject (unsigned char*)
394913,METHOD,server.h:<global>,TYPE_DECL,"int zslValueGteMin(double value, zrangespec *spec);",5,50,server.h,zslValueGteMin,,false,2997,2997,zslValueGteMin,,,604,"int zslValueGteMin (double,zrangespec*)"
394919,METHOD,server.h:<global>,TYPE_DECL,"int zslValueLteMax(double value, zrangespec *spec);",5,50,server.h,zslValueLteMax,,false,2998,2998,zslValueLteMax,,,605,"int zslValueLteMax (double,zrangespec*)"
394925,METHOD,server.h:<global>,TYPE_DECL,void zslFreeLexRange(zlexrangespec *spec);,6,41,server.h,zslFreeLexRange,,false,2999,2999,zslFreeLexRange,,,606,void zslFreeLexRange (zlexrangespec*)
394930,METHOD,server.h:<global>,TYPE_DECL,"int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec);",5,63,server.h,zslParseLexRange,,false,3000,3000,zslParseLexRange,,,607,"int zslParseLexRange (robj*,robj*,zlexrangespec*)"
394937,METHOD,server.h:<global>,TYPE_DECL,"unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range);",15,74,server.h,zzlFirstInLexRange,,false,3001,3001,zzlFirstInLexRange,,,608,"unsigned char* zzlFirstInLexRange (unsigned char*,zlexrangespec*)"
394943,METHOD,server.h:<global>,TYPE_DECL,"unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range);",15,73,server.h,zzlLastInLexRange,,false,3002,3002,zzlLastInLexRange,,,609,"unsigned char* zzlLastInLexRange (unsigned char*,zlexrangespec*)"
394949,METHOD,server.h:<global>,TYPE_DECL,"zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range);",15,71,server.h,zslFirstInLexRange,,false,3003,3003,zslFirstInLexRange,,,610,"zskiplistNode* zslFirstInLexRange (zskiplist*,zlexrangespec*)"
394955,METHOD,server.h:<global>,TYPE_DECL,"zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range);",15,70,server.h,zslLastInLexRange,,false,3004,3004,zslLastInLexRange,,,611,"zskiplistNode* zslLastInLexRange (zskiplist*,zlexrangespec*)"
394961,METHOD,server.h:<global>,TYPE_DECL,"int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec);",5,60,server.h,zzlLexValueGteMin,,false,3005,3005,zzlLexValueGteMin,,,612,"int zzlLexValueGteMin (unsigned char*,zlexrangespec*)"
394967,METHOD,server.h:<global>,TYPE_DECL,"int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec);",5,60,server.h,zzlLexValueLteMax,,false,3006,3006,zzlLexValueLteMax,,,613,"int zzlLexValueLteMax (unsigned char*,zlexrangespec*)"
394973,METHOD,server.h:<global>,TYPE_DECL,"int zslLexValueGteMin(sds value, zlexrangespec *spec);",5,53,server.h,zslLexValueGteMin,,false,3007,3007,zslLexValueGteMin,,,614,"int zslLexValueGteMin (sds,zlexrangespec*)"
394979,METHOD,server.h:<global>,TYPE_DECL,"int zslLexValueLteMax(sds value, zlexrangespec *spec);",5,53,server.h,zslLexValueLteMax,,false,3008,3008,zslLexValueLteMax,,,615,"int zslLexValueLteMax (sds,zlexrangespec*)"
394985,METHOD,server.h:<global>,TYPE_DECL,"int getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level);",5,83,server.h,getMaxmemoryState,,false,3011,3011,getMaxmemoryState,,,616,"int getMaxmemoryState (size_t*,size_t*,size_t*,float*)"
394993,METHOD,server.h:<global>,TYPE_DECL,size_t freeMemoryGetNotCountedMemory(void);,8,42,server.h,freeMemoryGetNotCountedMemory,,false,3012,3012,freeMemoryGetNotCountedMemory,,,617,size_t freeMemoryGetNotCountedMemory (void)
394998,METHOD,server.h:<global>,TYPE_DECL,int overMaxmemoryAfterAlloc(size_t moremem);,5,43,server.h,overMaxmemoryAfterAlloc,,false,3013,3013,overMaxmemoryAfterAlloc,,,618,int overMaxmemoryAfterAlloc (size_t)
395003,METHOD,server.h:<global>,TYPE_DECL,uint64_t getCommandFlags(client *c);,10,35,server.h,getCommandFlags,,false,3014,3014,getCommandFlags,,,619,uint64_t getCommandFlags (client*)
395008,METHOD,server.h:<global>,TYPE_DECL,int processCommand(client *c);,5,29,server.h,processCommand,,false,3015,3015,processCommand,,,620,int processCommand (client*)
395013,METHOD,server.h:<global>,TYPE_DECL,int processPendingCommandAndInputBuffer(client *c);,5,50,server.h,processPendingCommandAndInputBuffer,,false,3016,3016,processPendingCommandAndInputBuffer,,,621,int processPendingCommandAndInputBuffer (client*)
395018,METHOD,server.h:<global>,TYPE_DECL,int processCommandAndResetClient(client *c);,5,43,server.h,processCommandAndResetClient,,false,3017,3017,processCommandAndResetClient,,,622,int processCommandAndResetClient (client*)
395023,METHOD,server.h:<global>,TYPE_DECL,void setupSignalHandlers(void);,6,30,server.h,setupSignalHandlers,,false,3018,3018,setupSignalHandlers,,,623,void setupSignalHandlers (void)
395028,METHOD,server.h:<global>,TYPE_DECL,void removeSignalHandlers(void);,6,31,server.h,removeSignalHandlers,,false,3019,3019,removeSignalHandlers,,,624,void removeSignalHandlers (void)
395033,METHOD,server.h:<global>,TYPE_DECL,"int createSocketAcceptHandler(connListener *sfd, aeFileProc *accept_handler);",5,76,server.h,createSocketAcceptHandler,,false,3020,3020,createSocketAcceptHandler,,,625,"int createSocketAcceptHandler (connListener*,aeFileProc*)"
395039,METHOD,server.h:<global>,TYPE_DECL,connListener *listenerByType(const char *typename);,14,50,server.h,listenerByType,,false,3021,3021,listenerByType,,,626,connListener* listenerByType (char*)
395044,METHOD,server.h:<global>,TYPE_DECL,int changeListener(connListener *listener);,5,42,server.h,changeListener,,false,3022,3022,changeListener,,,627,int changeListener (connListener*)
395049,METHOD,server.h:<global>,TYPE_DECL,void closeListener(connListener *listener);,6,42,server.h,closeListener,,false,3023,3023,closeListener,,,628,void closeListener (connListener*)
395068,METHOD,server.h:<global>,TYPE_DECL,"int commandCheckExistence(client *c, sds *err);",5,46,server.h,commandCheckExistence,,false,3031,3031,commandCheckExistence,,,643,"int commandCheckExistence (client*,sds*)"
395074,METHOD,server.h:<global>,TYPE_DECL,"int commandCheckArity(client *c, sds *err);",5,42,server.h,commandCheckArity,,false,3032,3032,commandCheckArity,,,644,"int commandCheckArity (client*,sds*)"
395080,METHOD,server.h:<global>,TYPE_DECL,void startCommandExecution(void);,6,32,server.h,startCommandExecution,,false,3033,3033,startCommandExecution,,,645,void startCommandExecution (void)
395085,METHOD,server.h:<global>,TYPE_DECL,"int incrCommandStatsOnError(struct redisCommand *cmd, int flags);",5,64,server.h,incrCommandStatsOnError,,false,3034,3034,incrCommandStatsOnError,,,646,"int incrCommandStatsOnError (redisCommand*,int)"
395091,METHOD,server.h:<global>,TYPE_DECL,"void call(client *c, int flags);",6,31,server.h,call,,false,3035,3035,call,,,647,"void call (client*,int)"
395097,METHOD,server.h:<global>,TYPE_DECL,"void alsoPropagate(int dbid, robj **argv, int argc, int target);",6,63,server.h,alsoPropagate,,false,3036,3036,alsoPropagate,,,648,"void alsoPropagate (int,robj**,int,int)"
395105,METHOD,server.h:<global>,TYPE_DECL,void postExecutionUnitOperations(void);,6,38,server.h,postExecutionUnitOperations,,false,3037,3037,postExecutionUnitOperations,,,649,void postExecutionUnitOperations (void)
395110,METHOD,server.h:<global>,TYPE_DECL,void redisOpArrayFree(redisOpArray *oa);,6,39,server.h,redisOpArrayFree,,false,3038,3038,redisOpArrayFree,,,650,void redisOpArrayFree (redisOpArray*)
395115,METHOD,server.h:<global>,TYPE_DECL,"void forceCommandPropagation(client *c, int flags);",6,50,server.h,forceCommandPropagation,,false,3039,3039,forceCommandPropagation,,,651,"void forceCommandPropagation (client*,int)"
395121,METHOD,server.h:<global>,TYPE_DECL,void preventCommandPropagation(client *c);,6,41,server.h,preventCommandPropagation,,false,3040,3040,preventCommandPropagation,,,652,void preventCommandPropagation (client*)
395126,METHOD,server.h:<global>,TYPE_DECL,void preventCommandAOF(client *c);,6,33,server.h,preventCommandAOF,,false,3041,3041,preventCommandAOF,,,653,void preventCommandAOF (client*)
395131,METHOD,server.h:<global>,TYPE_DECL,void preventCommandReplication(client *c);,6,41,server.h,preventCommandReplication,,false,3042,3042,preventCommandReplication,,,654,void preventCommandReplication (client*)
395136,METHOD,server.h:<global>,TYPE_DECL,"void slowlogPushCurrentCommand(client *c, struct redisCommand *cmd, ustime_t duration);",6,86,server.h,slowlogPushCurrentCommand,,false,3043,3043,slowlogPushCurrentCommand,,,655,"void slowlogPushCurrentCommand (client*,redisCommand*,ustime_t)"
395143,METHOD,server.h:<global>,TYPE_DECL,"void updateCommandLatencyHistogram(struct hdr_histogram** latency_histogram, int64_t duration_hist);",6,99,server.h,updateCommandLatencyHistogram,,false,3044,3044,updateCommandLatencyHistogram,,,656,"void updateCommandLatencyHistogram (hdr_histogram**,int64_t)"
395149,METHOD,server.h:<global>,TYPE_DECL,int prepareForShutdown(int flags);,5,33,server.h,prepareForShutdown,,false,3045,3045,prepareForShutdown,,,657,int prepareForShutdown (int)
395154,METHOD,server.h:<global>,TYPE_DECL,void replyToClientsBlockedOnShutdown(void);,6,42,server.h,replyToClientsBlockedOnShutdown,,false,3046,3046,replyToClientsBlockedOnShutdown,,,658,void replyToClientsBlockedOnShutdown (void)
395159,METHOD,server.h:<global>,TYPE_DECL,int abortShutdown(void);,5,23,server.h,abortShutdown,,false,3047,3047,abortShutdown,,,659,int abortShutdown (void)
395164,METHOD,server.h:<global>,TYPE_DECL,void afterCommand(client *c);,6,28,server.h,afterCommand,,false,3048,3048,afterCommand,,,660,void afterCommand (client*)
395169,METHOD,server.h:<global>,TYPE_DECL,int mustObeyClient(client *c);,5,29,server.h,mustObeyClient,,false,3049,3049,mustObeyClient,,,661,int mustObeyClient (client*)
395174,METHOD,server.h:<global>,TYPE_DECL,"void _serverLog(int level, const char *fmt, ...);",6,48,server.h,_serverLog,,false,3054,3054,_serverLog,,,662,"void _serverLog (int,char*...)"
395180,METHOD,server.h:<global>,TYPE_DECL,"void serverLogRaw(int level, const char *msg);",6,45,server.h,serverLogRaw,,false,3056,3056,serverLogRaw,,,663,"void serverLogRaw (int,char*)"
395186,METHOD,server.h:<global>,TYPE_DECL,"void serverLogFromHandler(int level, const char *msg);",6,53,server.h,serverLogFromHandler,,false,3057,3057,serverLogFromHandler,,,664,"void serverLogFromHandler (int,char*)"
395192,METHOD,server.h:<global>,TYPE_DECL,void usage(void);,6,16,server.h,usage,,false,3058,3058,usage,,,665,void usage (void)
395197,METHOD,server.h:<global>,TYPE_DECL,void updateDictResizePolicy(void);,6,33,server.h,updateDictResizePolicy,,false,3059,3059,updateDictResizePolicy,,,666,void updateDictResizePolicy (void)
395202,METHOD,server.h:<global>,TYPE_DECL,int htNeedsResize(dict *dict);,5,29,server.h,htNeedsResize,,false,3060,3060,htNeedsResize,,,667,int htNeedsResize (dict*)
395207,METHOD,server.h:<global>,TYPE_DECL,void populateCommandTable(void);,6,31,server.h,populateCommandTable,,false,3061,3061,populateCommandTable,,,668,void populateCommandTable (void)
395212,METHOD,server.h:<global>,TYPE_DECL,void resetCommandTableStats(dict* commands);,6,43,server.h,resetCommandTableStats,,false,3062,3062,resetCommandTableStats,,,669,void resetCommandTableStats (dict*)
395217,METHOD,server.h:<global>,TYPE_DECL,void resetErrorTableStats(void);,6,31,server.h,resetErrorTableStats,,false,3063,3063,resetErrorTableStats,,,670,void resetErrorTableStats (void)
395222,METHOD,server.h:<global>,TYPE_DECL,void adjustOpenFilesLimit(void);,6,31,server.h,adjustOpenFilesLimit,,false,3064,3064,adjustOpenFilesLimit,,,671,void adjustOpenFilesLimit (void)
395227,METHOD,server.h:<global>,TYPE_DECL,"void incrementErrorCount(const char *fullerr, size_t namelen);",6,61,server.h,incrementErrorCount,,false,3065,3065,incrementErrorCount,,,672,"void incrementErrorCount (char*,size_t)"
395233,METHOD,server.h:<global>,TYPE_DECL,void closeListeningSockets(int unlink_unix_socket);,6,50,server.h,closeListeningSockets,,false,3066,3066,closeListeningSockets,,,673,void closeListeningSockets (int)
395238,METHOD,server.h:<global>,TYPE_DECL,void updateCachedTime(int update_daylight_info);,6,47,server.h,updateCachedTime,,false,3067,3067,updateCachedTime,,,674,void updateCachedTime (int)
395243,METHOD,server.h:<global>,TYPE_DECL,"void enterExecutionUnit(int update_cached_time, long long us);",6,61,server.h,enterExecutionUnit,,false,3068,3068,enterExecutionUnit,,,675,"void enterExecutionUnit (int,long long)"
395249,METHOD,server.h:<global>,TYPE_DECL,void exitExecutionUnit(void);,6,28,server.h,exitExecutionUnit,,false,3069,3069,exitExecutionUnit,,,676,void exitExecutionUnit (void)
395254,METHOD,server.h:<global>,TYPE_DECL,void resetServerStats(void);,6,27,server.h,resetServerStats,,false,3070,3070,resetServerStats,,,677,void resetServerStats (void)
395259,METHOD,server.h:<global>,TYPE_DECL,void activeDefragCycle(void);,6,28,server.h,activeDefragCycle,,false,3071,3071,activeDefragCycle,,,678,void activeDefragCycle (void)
395264,METHOD,server.h:<global>,TYPE_DECL,unsigned int getLRUClock(void);,14,30,server.h,getLRUClock,,false,3072,3072,getLRUClock,,,679,unsigned int getLRUClock (void)
395269,METHOD,server.h:<global>,TYPE_DECL,unsigned int LRU_CLOCK(void);,14,28,server.h,LRU_CLOCK,,false,3073,3073,LRU_CLOCK,,,680,unsigned int LRU_CLOCK (void)
395274,METHOD,server.h:<global>,TYPE_DECL,const char *evictPolicyToString(void);,12,37,server.h,evictPolicyToString,,false,3074,3074,evictPolicyToString,,,681,char* evictPolicyToString (void)
395281,METHOD,server.h:<global>,TYPE_DECL,void freeMemoryOverheadData(struct redisMemOverhead *mh);,6,56,server.h,freeMemoryOverheadData,,false,3076,3076,freeMemoryOverheadData,,,684,void freeMemoryOverheadData (redisMemOverhead*)
395286,METHOD,server.h:<global>,TYPE_DECL,void checkChildrenDone(void);,6,28,server.h,checkChildrenDone,,false,3077,3077,checkChildrenDone,,,685,void checkChildrenDone (void)
395291,METHOD,server.h:<global>,TYPE_DECL,int setOOMScoreAdj(int process_class);,5,37,server.h,setOOMScoreAdj,,false,3078,3078,setOOMScoreAdj,,,686,int setOOMScoreAdj (int)
395296,METHOD,server.h:<global>,TYPE_DECL,"void rejectCommandFormat(client *c, const char *fmt, ...);",6,57,server.h,rejectCommandFormat,,false,3079,3079,rejectCommandFormat,,,687,"void rejectCommandFormat (client*,char*...)"
395302,METHOD,server.h:<global>,TYPE_DECL,void *activeDefragAlloc(void *ptr);,6,34,server.h,activeDefragAlloc,,false,3080,3080,activeDefragAlloc,,,688,void* activeDefragAlloc (void*)
395307,METHOD,server.h:<global>,TYPE_DECL,robj *activeDefragStringOb(robj* ob);,6,36,server.h,activeDefragStringOb,,false,3081,3081,activeDefragStringOb,,,689,robj* activeDefragStringOb (robj*)
395312,METHOD,server.h:<global>,TYPE_DECL,void dismissSds(sds s);,6,22,server.h,dismissSds,,false,3082,3082,dismissSds,,,690,void dismissSds (sds)
395317,METHOD,server.h:<global>,TYPE_DECL,"void dismissMemory(void* ptr, size_t size_hint);",6,47,server.h,dismissMemory,,false,3083,3083,dismissMemory,,,691,"void dismissMemory (void*,size_t)"
395323,METHOD,server.h:<global>,TYPE_DECL,void dismissMemoryInChild(void);,6,31,server.h,dismissMemoryInChild,,false,3084,3084,dismissMemoryInChild,,,692,void dismissMemoryInChild (void)
395328,METHOD,server.h:<global>,TYPE_DECL,"int restartServer(int flags, mstime_t delay);",5,44,server.h,restartServer,,false,3089,3089,restartServer,,,693,"int restartServer (int,mstime_t)"
395334,METHOD,server.h:<global>,TYPE_DECL,"robj *setTypeCreate(sds value, size_t size_hint);",6,48,server.h,setTypeCreate,,false,3092,3092,setTypeCreate,,,694,"robj* setTypeCreate (sds,size_t)"
395340,METHOD,server.h:<global>,TYPE_DECL,"int setTypeAdd(robj *subject, sds value);",5,40,server.h,setTypeAdd,,false,3093,3093,setTypeAdd,,,695,"int setTypeAdd (robj*,sds)"
395346,METHOD,server.h:<global>,TYPE_DECL,"int setTypeAddAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds);",5,82,server.h,setTypeAddAux,,false,3094,3094,setTypeAddAux,,,696,"int setTypeAddAux (robj*,char*,size_t,int64_t,int)"
395355,METHOD,server.h:<global>,TYPE_DECL,"int setTypeRemove(robj *subject, sds value);",5,43,server.h,setTypeRemove,,false,3095,3095,setTypeRemove,,,697,"int setTypeRemove (robj*,sds)"
395361,METHOD,server.h:<global>,TYPE_DECL,"int setTypeRemoveAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds);",5,85,server.h,setTypeRemoveAux,,false,3096,3096,setTypeRemoveAux,,,698,"int setTypeRemoveAux (robj*,char*,size_t,int64_t,int)"
395370,METHOD,server.h:<global>,TYPE_DECL,"int setTypeIsMember(robj *subject, sds value);",5,45,server.h,setTypeIsMember,,false,3097,3097,setTypeIsMember,,,699,"int setTypeIsMember (robj*,sds)"
395376,METHOD,server.h:<global>,TYPE_DECL,"int setTypeIsMemberAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds);",5,87,server.h,setTypeIsMemberAux,,false,3098,3098,setTypeIsMemberAux,,,700,"int setTypeIsMemberAux (robj*,char*,size_t,int64_t,int)"
395385,METHOD,server.h:<global>,TYPE_DECL,setTypeIterator *setTypeInitIterator(robj *subject);,17,51,server.h,setTypeInitIterator,,false,3099,3099,setTypeInitIterator,,,701,setTypeIterator* setTypeInitIterator (robj*)
395390,METHOD,server.h:<global>,TYPE_DECL,void setTypeReleaseIterator(setTypeIterator *si);,6,48,server.h,setTypeReleaseIterator,,false,3100,3100,setTypeReleaseIterator,,,702,void setTypeReleaseIterator (setTypeIterator*)
395395,METHOD,server.h:<global>,TYPE_DECL,"int setTypeNext(setTypeIterator *si, char **str, size_t *len, int64_t *llele);",5,77,server.h,setTypeNext,,false,3101,3101,setTypeNext,,,703,"int setTypeNext (setTypeIterator*,char**,size_t*,int64_t*)"
395403,METHOD,server.h:<global>,TYPE_DECL,sds setTypeNextObject(setTypeIterator *si);,5,42,server.h,setTypeNextObject,,false,3102,3102,setTypeNextObject,,,704,sds setTypeNextObject (setTypeIterator*)
395408,METHOD,server.h:<global>,TYPE_DECL,"int setTypeRandomElement(robj *setobj, char **str, size_t *len, int64_t *llele);",5,79,server.h,setTypeRandomElement,,false,3103,3103,setTypeRandomElement,,,705,"int setTypeRandomElement (robj*,char**,size_t*,int64_t*)"
395416,METHOD,server.h:<global>,TYPE_DECL,unsigned long setTypeSize(const robj *subject);,15,46,server.h,setTypeSize,,false,3104,3104,setTypeSize,,,706,long unsigned setTypeSize (robj*)
395421,METHOD,server.h:<global>,TYPE_DECL,"void setTypeConvert(robj *subject, int enc);",6,43,server.h,setTypeConvert,,false,3105,3105,setTypeConvert,,,707,"void setTypeConvert (robj*,int)"
395427,METHOD,server.h:<global>,TYPE_DECL,"int setTypeConvertAndExpand(robj *setobj, int enc, unsigned long cap, int panic);",5,80,server.h,setTypeConvertAndExpand,,false,3106,3106,setTypeConvertAndExpand,,,708,"int setTypeConvertAndExpand (robj*,int,long unsigned,int)"
395435,METHOD,server.h:<global>,TYPE_DECL,robj *setTypeDup(robj *o);,6,25,server.h,setTypeDup,,false,3107,3107,setTypeDup,,,709,robj* setTypeDup (robj*)
395440,METHOD,server.h:<global>,TYPE_DECL,"void hashTypeConvert(robj *o, int enc);",6,38,server.h,hashTypeConvert,,false,3114,3114,hashTypeConvert,,,710,"void hashTypeConvert (robj*,int)"
395446,METHOD,server.h:<global>,TYPE_DECL,"void hashTypeTryConversion(robj *subject, robj **argv, int start, int end);",6,74,server.h,hashTypeTryConversion,,false,3115,3115,hashTypeTryConversion,,,711,"void hashTypeTryConversion (robj*,robj**,int,int)"
395454,METHOD,server.h:<global>,TYPE_DECL,"int hashTypeExists(robj *o, sds key);",5,36,server.h,hashTypeExists,,false,3116,3116,hashTypeExists,,,712,"int hashTypeExists (robj*,sds)"
395460,METHOD,server.h:<global>,TYPE_DECL,"int hashTypeDelete(robj *o, sds key);",5,36,server.h,hashTypeDelete,,false,3117,3117,hashTypeDelete,,,713,"int hashTypeDelete (robj*,sds)"
395466,METHOD,server.h:<global>,TYPE_DECL,unsigned long hashTypeLength(const robj *o);,15,43,server.h,hashTypeLength,,false,3118,3118,hashTypeLength,,,714,long unsigned hashTypeLength (robj*)
395471,METHOD,server.h:<global>,TYPE_DECL,hashTypeIterator *hashTypeInitIterator(robj *subject);,18,53,server.h,hashTypeInitIterator,,false,3119,3119,hashTypeInitIterator,,,715,hashTypeIterator* hashTypeInitIterator (robj*)
395476,METHOD,server.h:<global>,TYPE_DECL,void hashTypeReleaseIterator(hashTypeIterator *hi);,6,50,server.h,hashTypeReleaseIterator,,false,3120,3120,hashTypeReleaseIterator,,,716,void hashTypeReleaseIterator (hashTypeIterator*)
395481,METHOD,server.h:<global>,TYPE_DECL,int hashTypeNext(hashTypeIterator *hi);,5,38,server.h,hashTypeNext,,false,3121,3121,hashTypeNext,,,717,int hashTypeNext (hashTypeIterator*)
395486,METHOD,server.h:<global>,TYPE_DECL,"void hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,
                                 unsigned char **vstr,
                                 unsigned int *vlen,
                                 long long *vll);",6,48,server.h,hashTypeCurrentFromListpack,,false,3122,3125,hashTypeCurrentFromListpack,,,718,"void hashTypeCurrentFromListpack (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)"
395495,METHOD,server.h:<global>,TYPE_DECL,"sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what);",5,64,server.h,hashTypeCurrentFromHashTable,,false,3126,3126,hashTypeCurrentFromHashTable,,,719,"sds hashTypeCurrentFromHashTable (hashTypeIterator*,int)"
395501,METHOD,server.h:<global>,TYPE_DECL,"void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll);",6,116,server.h,hashTypeCurrentObject,,false,3127,3127,hashTypeCurrentObject,,,720,"void hashTypeCurrentObject (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)"
395510,METHOD,server.h:<global>,TYPE_DECL,"sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what);",5,63,server.h,hashTypeCurrentObjectNewSds,,false,3128,3128,hashTypeCurrentObjectNewSds,,,721,"sds hashTypeCurrentObjectNewSds (hashTypeIterator*,int)"
395516,METHOD,server.h:<global>,TYPE_DECL,"robj *hashTypeLookupWriteOrCreate(client *c, robj *key);",6,55,server.h,hashTypeLookupWriteOrCreate,,false,3129,3129,hashTypeLookupWriteOrCreate,,,722,"robj* hashTypeLookupWriteOrCreate (client*,robj*)"
395522,METHOD,server.h:<global>,TYPE_DECL,"robj *hashTypeGetValueObject(robj *o, sds field);",6,48,server.h,hashTypeGetValueObject,,false,3130,3130,hashTypeGetValueObject,,,723,"robj* hashTypeGetValueObject (robj*,sds)"
395528,METHOD,server.h:<global>,TYPE_DECL,"int hashTypeSet(robj *o, sds field, sds value, int flags);",5,57,server.h,hashTypeSet,,false,3131,3131,hashTypeSet,,,724,"int hashTypeSet (robj*,sds,sds,int)"
395536,METHOD,server.h:<global>,TYPE_DECL,robj *hashTypeDup(robj *o);,6,26,server.h,hashTypeDup,,false,3132,3132,hashTypeDup,,,725,robj* hashTypeDup (robj*)
395541,METHOD,server.h:<global>,TYPE_DECL,"int pubsubUnsubscribeAllChannels(client *c, int notify);",5,55,server.h,pubsubUnsubscribeAllChannels,,false,3135,3135,pubsubUnsubscribeAllChannels,,,726,"int pubsubUnsubscribeAllChannels (client*,int)"
395547,METHOD,server.h:<global>,TYPE_DECL,"int pubsubUnsubscribeShardAllChannels(client *c, int notify);",5,60,server.h,pubsubUnsubscribeShardAllChannels,,false,3136,3136,pubsubUnsubscribeShardAllChannels,,,727,"int pubsubUnsubscribeShardAllChannels (client*,int)"
395553,METHOD,server.h:<global>,TYPE_DECL,"void pubsubUnsubscribeShardChannels(robj **channels, unsigned int count);",6,72,server.h,pubsubUnsubscribeShardChannels,,false,3137,3137,pubsubUnsubscribeShardChannels,,,728,"void pubsubUnsubscribeShardChannels (robj**,unsigned int)"
395559,METHOD,server.h:<global>,TYPE_DECL,"int pubsubUnsubscribeAllPatterns(client *c, int notify);",5,55,server.h,pubsubUnsubscribeAllPatterns,,false,3138,3138,pubsubUnsubscribeAllPatterns,,,729,"int pubsubUnsubscribeAllPatterns (client*,int)"
395565,METHOD,server.h:<global>,TYPE_DECL,"int pubsubPublishMessage(robj *channel, robj *message, int sharded);",5,67,server.h,pubsubPublishMessage,,false,3139,3139,pubsubPublishMessage,,,730,"int pubsubPublishMessage (robj*,robj*,int)"
395572,METHOD,server.h:<global>,TYPE_DECL,"int pubsubPublishMessageAndPropagateToCluster(robj *channel, robj *message, int sharded);",5,88,server.h,pubsubPublishMessageAndPropagateToCluster,,false,3140,3140,pubsubPublishMessageAndPropagateToCluster,,,731,"int pubsubPublishMessageAndPropagateToCluster (robj*,robj*,int)"
395579,METHOD,server.h:<global>,TYPE_DECL,"void addReplyPubsubMessage(client *c, robj *channel, robj *msg, robj *message_bulk);",6,83,server.h,addReplyPubsubMessage,,false,3141,3141,addReplyPubsubMessage,,,732,"void addReplyPubsubMessage (client*,robj*,robj*,robj*)"
395587,METHOD,server.h:<global>,TYPE_DECL,int serverPubsubSubscriptionCount(void);,5,39,server.h,serverPubsubSubscriptionCount,,false,3142,3142,serverPubsubSubscriptionCount,,,733,int serverPubsubSubscriptionCount (void)
395592,METHOD,server.h:<global>,TYPE_DECL,int serverPubsubShardSubscriptionCount(void);,5,44,server.h,serverPubsubShardSubscriptionCount,,false,3143,3143,serverPubsubShardSubscriptionCount,,,734,int serverPubsubShardSubscriptionCount (void)
395597,METHOD,server.h:<global>,TYPE_DECL,size_t pubsubMemOverhead(client *c);,8,35,server.h,pubsubMemOverhead,,false,3144,3144,pubsubMemOverhead,,,735,size_t pubsubMemOverhead (client*)
395602,METHOD,server.h:<global>,TYPE_DECL,"void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);",6,68,server.h,notifyKeyspaceEvent,,false,3147,3147,notifyKeyspaceEvent,,,736,"void notifyKeyspaceEvent (int,char*,robj*,int)"
395610,METHOD,server.h:<global>,TYPE_DECL,int keyspaceEventsStringToFlags(char *classes);,5,46,server.h,keyspaceEventsStringToFlags,,false,3148,3148,keyspaceEventsStringToFlags,,,737,int keyspaceEventsStringToFlags (char*)
395615,METHOD,server.h:<global>,TYPE_DECL,sds keyspaceEventsFlagsToString(int flags);,5,42,server.h,keyspaceEventsFlagsToString,,false,3149,3149,keyspaceEventsFlagsToString,,,738,sds keyspaceEventsFlagsToString (int)
395632,METHOD,server.h:<global>,TYPE_DECL,"void loadServerConfig(char *filename, char config_from_stdin, char *options);",6,76,server.h,loadServerConfig,,false,3190,3190,loadServerConfig,,,743,"void loadServerConfig (char*,char,char*)"
395639,METHOD,server.h:<global>,TYPE_DECL,"void appendServerSaveParams(time_t seconds, int changes);",6,56,server.h,appendServerSaveParams,,false,3191,3191,appendServerSaveParams,,,744,"void appendServerSaveParams (time_t,int)"
395645,METHOD,server.h:<global>,TYPE_DECL,void resetServerSaveParams(void);,6,32,server.h,resetServerSaveParams,,false,3192,3192,resetServerSaveParams,,,745,void resetServerSaveParams (void)
395651,METHOD,server.h:<global>,TYPE_DECL,"int rewriteConfigRewriteLine(struct rewriteConfigState *state, const char *option, sds line, int force);",5,103,server.h,rewriteConfigRewriteLine,,false,3194,3194,rewriteConfigRewriteLine,,,747,"int rewriteConfigRewriteLine (rewriteConfigState*,char*,sds,int)"
395659,METHOD,server.h:<global>,TYPE_DECL,"void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, const char *option);",6,87,server.h,rewriteConfigMarkAsProcessed,,false,3195,3195,rewriteConfigMarkAsProcessed,,,748,"void rewriteConfigMarkAsProcessed (rewriteConfigState*,char*)"
395665,METHOD,server.h:<global>,TYPE_DECL,"int rewriteConfig(char *path, int force_write);",5,46,server.h,rewriteConfig,,false,3196,3196,rewriteConfig,,,749,"int rewriteConfig (char*,int)"
395671,METHOD,server.h:<global>,TYPE_DECL,void initConfigValues(void);,6,27,server.h,initConfigValues,,false,3197,3197,initConfigValues,,,750,void initConfigValues (void)
395676,METHOD,server.h:<global>,TYPE_DECL,void removeConfig(sds name);,6,27,server.h,removeConfig,,false,3198,3198,removeConfig,,,751,void removeConfig (sds)
395681,METHOD,server.h:<global>,TYPE_DECL,sds getConfigDebugInfo(void);,5,28,server.h,getConfigDebugInfo,,false,3199,3199,getConfigDebugInfo,,,752,sds getConfigDebugInfo (void)
395686,METHOD,server.h:<global>,TYPE_DECL,"int allowProtectedAction(int config, client *c);",5,47,server.h,allowProtectedAction,,false,3200,3200,allowProtectedAction,,,753,"int allowProtectedAction (int,client*)"
395692,METHOD,server.h:<global>,TYPE_DECL,void initServerClientMemUsageBuckets(void);,6,42,server.h,initServerClientMemUsageBuckets,,false,3201,3201,initServerClientMemUsageBuckets,,,754,void initServerClientMemUsageBuckets (void)
395697,METHOD,server.h:<global>,TYPE_DECL,void freeServerClientMemUsageBuckets(void);,6,42,server.h,freeServerClientMemUsageBuckets,,false,3202,3202,freeServerClientMemUsageBuckets,,,755,void freeServerClientMemUsageBuckets (void)
395704,METHOD,server.h:<global>,TYPE_DECL,"int performModuleConfigSetFromName(sds name, sds value, const char **err);",5,73,server.h,performModuleConfigSetFromName,,false,3206,3206,performModuleConfigSetFromName,,,758,"int performModuleConfigSetFromName (sds,sds,char**)"
395711,METHOD,server.h:<global>,TYPE_DECL,"int performModuleConfigSetDefaultFromName(sds name, const char **err);",5,69,server.h,performModuleConfigSetDefaultFromName,,false,3207,3207,performModuleConfigSetDefaultFromName,,,759,"int performModuleConfigSetDefaultFromName (sds,char**)"
395717,METHOD,server.h:<global>,TYPE_DECL,"void addModuleBoolConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val);",6,111,server.h,addModuleBoolConfig,,false,3208,3208,addModuleBoolConfig,,,760,"void addModuleBoolConfig (char*,char*,int,void*,int)"
395726,METHOD,server.h:<global>,TYPE_DECL,"void addModuleStringConfig(const char *module_name, const char *name, int flags, void *privdata, sds default_val);",6,113,server.h,addModuleStringConfig,,false,3209,3209,addModuleStringConfig,,,761,"void addModuleStringConfig (char*,char*,int,void*,sds)"
395735,METHOD,server.h:<global>,TYPE_DECL,"void addModuleEnumConfig(const char *module_name, const char *name, int flags, void *privdata, int default_val, configEnum *enum_vals);",6,134,server.h,addModuleEnumConfig,,false,3210,3210,addModuleEnumConfig,,,762,"void addModuleEnumConfig (char*,char*,int,void*,int,configEnum*)"
395745,METHOD,server.h:<global>,TYPE_DECL,"void addModuleNumericConfig(const char *module_name, const char *name, int flags, void *privdata, long long default_val, int conf_flags, long long lower, long long upper);",6,170,server.h,addModuleNumericConfig,,false,3211,3211,addModuleNumericConfig,,,763,"void addModuleNumericConfig (char*,char*,int,void*,long long,int,long long,long long)"
395757,METHOD,server.h:<global>,TYPE_DECL,"void addModuleConfigApply(list *module_configs, ModuleConfig *module_config);",6,76,server.h,addModuleConfigApply,,false,3212,3212,addModuleConfigApply,,,764,"void addModuleConfigApply (list*,ModuleConfig*)"
395763,METHOD,server.h:<global>,TYPE_DECL,"int moduleConfigApplyConfig(list *module_configs, const char **err, const char **err_arg_name);",5,94,server.h,moduleConfigApplyConfig,,false,3213,3213,moduleConfigApplyConfig,,,765,"int moduleConfigApplyConfig (list*,char**,char**)"
395770,METHOD,server.h:<global>,TYPE_DECL,int getModuleBoolConfig(ModuleConfig *module_config);,5,52,server.h,getModuleBoolConfig,,false,3214,3214,getModuleBoolConfig,,,766,int getModuleBoolConfig (ModuleConfig*)
395775,METHOD,server.h:<global>,TYPE_DECL,"int setModuleBoolConfig(ModuleConfig *config, int val, const char **err);",5,72,server.h,setModuleBoolConfig,,false,3215,3215,setModuleBoolConfig,,,767,"int setModuleBoolConfig (ModuleConfig*,int,char**)"
395782,METHOD,server.h:<global>,TYPE_DECL,sds getModuleStringConfig(ModuleConfig *module_config);,5,54,server.h,getModuleStringConfig,,false,3216,3216,getModuleStringConfig,,,768,sds getModuleStringConfig (ModuleConfig*)
395787,METHOD,server.h:<global>,TYPE_DECL,"int setModuleStringConfig(ModuleConfig *config, sds strval, const char **err);",5,77,server.h,setModuleStringConfig,,false,3217,3217,setModuleStringConfig,,,769,"int setModuleStringConfig (ModuleConfig*,sds,char**)"
395794,METHOD,server.h:<global>,TYPE_DECL,int getModuleEnumConfig(ModuleConfig *module_config);,5,52,server.h,getModuleEnumConfig,,false,3218,3218,getModuleEnumConfig,,,770,int getModuleEnumConfig (ModuleConfig*)
395799,METHOD,server.h:<global>,TYPE_DECL,"int setModuleEnumConfig(ModuleConfig *config, int val, const char **err);",5,72,server.h,setModuleEnumConfig,,false,3219,3219,setModuleEnumConfig,,,771,"int setModuleEnumConfig (ModuleConfig*,int,char**)"
395806,METHOD,server.h:<global>,TYPE_DECL,long long getModuleNumericConfig(ModuleConfig *module_config);,11,61,server.h,getModuleNumericConfig,,false,3220,3220,getModuleNumericConfig,,,772,long long getModuleNumericConfig (ModuleConfig*)
395811,METHOD,server.h:<global>,TYPE_DECL,"int setModuleNumericConfig(ModuleConfig *config, long long val, const char **err);",5,81,server.h,setModuleNumericConfig,,false,3221,3221,setModuleNumericConfig,,,773,"int setModuleNumericConfig (ModuleConfig*,long long,char**)"
395818,METHOD,server.h:<global>,TYPE_DECL,"int removeExpire(redisDb *db, robj *key);",5,40,server.h,removeExpire,,false,3224,3224,removeExpire,,,774,"int removeExpire (redisDb*,robj*)"
395824,METHOD,server.h:<global>,TYPE_DECL,"void deleteExpiredKeyAndPropagate(redisDb *db, robj *keyobj);",6,60,server.h,deleteExpiredKeyAndPropagate,,false,3225,3225,deleteExpiredKeyAndPropagate,,,775,"void deleteExpiredKeyAndPropagate (redisDb*,robj*)"
395830,METHOD,server.h:<global>,TYPE_DECL,"void propagateDeletion(redisDb *db, robj *key, int lazy);",6,56,server.h,propagateDeletion,,false,3226,3226,propagateDeletion,,,776,"void propagateDeletion (redisDb*,robj*,int)"
395837,METHOD,server.h:<global>,TYPE_DECL,"int keyIsExpired(redisDb *db, robj *key);",5,40,server.h,keyIsExpired,,false,3227,3227,keyIsExpired,,,777,"int keyIsExpired (redisDb*,robj*)"
395843,METHOD,server.h:<global>,TYPE_DECL,"long long getExpire(redisDb *db, robj *key);",11,43,server.h,getExpire,,false,3228,3228,getExpire,,,778,"long long getExpire (redisDb*,robj*)"
395849,METHOD,server.h:<global>,TYPE_DECL,"void setExpire(client *c, redisDb *db, robj *key, long long when);",6,65,server.h,setExpire,,false,3229,3229,setExpire,,,779,"void setExpire (client*,redisDb*,robj*,long long)"
395857,METHOD,server.h:<global>,TYPE_DECL,int checkAlreadyExpired(long long when);,5,39,server.h,checkAlreadyExpired,,false,3230,3230,checkAlreadyExpired,,,780,int checkAlreadyExpired (long long)
395862,METHOD,server.h:<global>,TYPE_DECL,"robj *lookupKeyRead(redisDb *db, robj *key);",6,43,server.h,lookupKeyRead,,false,3231,3231,lookupKeyRead,,,781,"robj* lookupKeyRead (redisDb*,robj*)"
395868,METHOD,server.h:<global>,TYPE_DECL,"robj *lookupKeyWrite(redisDb *db, robj *key);",6,44,server.h,lookupKeyWrite,,false,3232,3232,lookupKeyWrite,,,782,"robj* lookupKeyWrite (redisDb*,robj*)"
395874,METHOD,server.h:<global>,TYPE_DECL,"robj *lookupKeyReadOrReply(client *c, robj *key, robj *reply);",6,61,server.h,lookupKeyReadOrReply,,false,3233,3233,lookupKeyReadOrReply,,,783,"robj* lookupKeyReadOrReply (client*,robj*,robj*)"
395881,METHOD,server.h:<global>,TYPE_DECL,"robj *lookupKeyWriteOrReply(client *c, robj *key, robj *reply);",6,62,server.h,lookupKeyWriteOrReply,,false,3234,3234,lookupKeyWriteOrReply,,,784,"robj* lookupKeyWriteOrReply (client*,robj*,robj*)"
395888,METHOD,server.h:<global>,TYPE_DECL,"robj *lookupKeyReadWithFlags(redisDb *db, robj *key, int flags);",6,63,server.h,lookupKeyReadWithFlags,,false,3235,3235,lookupKeyReadWithFlags,,,785,"robj* lookupKeyReadWithFlags (redisDb*,robj*,int)"
395895,METHOD,server.h:<global>,TYPE_DECL,"robj *lookupKeyWriteWithFlags(redisDb *db, robj *key, int flags);",6,64,server.h,lookupKeyWriteWithFlags,,false,3236,3236,lookupKeyWriteWithFlags,,,786,"robj* lookupKeyWriteWithFlags (redisDb*,robj*,int)"
395902,METHOD,server.h:<global>,TYPE_DECL,"robj *objectCommandLookup(client *c, robj *key);",6,47,server.h,objectCommandLookup,,false,3237,3237,objectCommandLookup,,,787,"robj* objectCommandLookup (client*,robj*)"
395908,METHOD,server.h:<global>,TYPE_DECL,"robj *objectCommandLookupOrReply(client *c, robj *key, robj *reply);",6,67,server.h,objectCommandLookupOrReply,,false,3238,3238,objectCommandLookupOrReply,,,788,"robj* objectCommandLookupOrReply (client*,robj*,robj*)"
395915,METHOD,server.h:<global>,TYPE_DECL,"int objectSetLRUOrLFU(robj *val, long long lfu_freq, long long lru_idle,
                       long long lru_clock, int lru_multiplier);",5,63,server.h,objectSetLRUOrLFU,,false,3239,3240,objectSetLRUOrLFU,,,789,"int objectSetLRUOrLFU (robj*,long long,long long,long long,int)"
395924,METHOD,server.h:<global>,TYPE_DECL,"void dbAdd(redisDb *db, robj *key, robj *val);",6,45,server.h,dbAdd,,false,3249,3249,dbAdd,,,790,"void dbAdd (redisDb*,robj*,robj*)"
395931,METHOD,server.h:<global>,TYPE_DECL,"int dbAddRDBLoad(redisDb *db, sds key, robj *val);",5,49,server.h,dbAddRDBLoad,,false,3250,3250,dbAddRDBLoad,,,791,"int dbAddRDBLoad (redisDb*,sds,robj*)"
395938,METHOD,server.h:<global>,TYPE_DECL,"void dbReplaceValue(redisDb *db, robj *key, robj *val);",6,54,server.h,dbReplaceValue,,false,3251,3251,dbReplaceValue,,,792,"void dbReplaceValue (redisDb*,robj*,robj*)"
395945,METHOD,server.h:<global>,TYPE_DECL,"void setKey(client *c, redisDb *db, robj *key, robj *val, int flags);",6,68,server.h,setKey,,false,3258,3258,setKey,,,793,"void setKey (client*,redisDb*,robj*,robj*,int)"
395954,METHOD,server.h:<global>,TYPE_DECL,robj *dbRandomKey(redisDb *db);,6,30,server.h,dbRandomKey,,false,3259,3259,dbRandomKey,,,794,robj* dbRandomKey (redisDb*)
395959,METHOD,server.h:<global>,TYPE_DECL,"int dbGenericDelete(redisDb *db, robj *key, int async, int flags);",5,65,server.h,dbGenericDelete,,false,3260,3260,dbGenericDelete,,,795,"int dbGenericDelete (redisDb*,robj*,int,int)"
395967,METHOD,server.h:<global>,TYPE_DECL,"int dbSyncDelete(redisDb *db, robj *key);",5,40,server.h,dbSyncDelete,,false,3261,3261,dbSyncDelete,,,796,"int dbSyncDelete (redisDb*,robj*)"
395973,METHOD,server.h:<global>,TYPE_DECL,"int dbDelete(redisDb *db, robj *key);",5,36,server.h,dbDelete,,false,3262,3262,dbDelete,,,797,"int dbDelete (redisDb*,robj*)"
395979,METHOD,server.h:<global>,TYPE_DECL,"robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);",6,59,server.h,dbUnshareStringValue,,false,3263,3263,dbUnshareStringValue,,,798,"robj* dbUnshareStringValue (redisDb*,robj*,robj*)"
395986,METHOD,server.h:<global>,TYPE_DECL,"long long emptyData(int dbnum, int flags, void(callback)(dict*));",11,64,server.h,emptyData,,false,3268,3268,emptyData,,,799,"long long emptyData (int,int,void)"
395993,METHOD,server.h:<global>,TYPE_DECL,"long long emptyDbStructure(redisDb *dbarray, int dbnum, int async, void(callback)(dict*));",11,89,server.h,emptyDbStructure,,false,3269,3269,emptyDbStructure,,,800,"long long emptyDbStructure (redisDb*,int,int,void)"
396001,METHOD,server.h:<global>,TYPE_DECL,void flushAllDataAndResetRDB(int flags);,6,39,server.h,flushAllDataAndResetRDB,,false,3270,3270,flushAllDataAndResetRDB,,,801,void flushAllDataAndResetRDB (int)
396006,METHOD,server.h:<global>,TYPE_DECL,long long dbTotalServerKeyCount(void);,11,37,server.h,dbTotalServerKeyCount,,false,3271,3271,dbTotalServerKeyCount,,,802,long long dbTotalServerKeyCount (void)
396011,METHOD,server.h:<global>,TYPE_DECL,redisDb *initTempDb(void);,9,25,server.h,initTempDb,,false,3272,3272,initTempDb,,,803,redisDb* initTempDb (void)
396016,METHOD,server.h:<global>,TYPE_DECL,"void discardTempDb(redisDb *tempDb, void(callback)(dict*));",6,58,server.h,discardTempDb,,false,3273,3273,discardTempDb,,,804,"void discardTempDb (redisDb*,void)"
396022,METHOD,server.h:<global>,TYPE_DECL,"int selectDb(client *c, int id);",5,31,server.h,selectDb,,false,3276,3276,selectDb,,,805,"int selectDb (client*,int)"
396028,METHOD,server.h:<global>,TYPE_DECL,"void signalModifiedKey(client *c, redisDb *db, robj *key);",6,57,server.h,signalModifiedKey,,false,3277,3277,signalModifiedKey,,,806,"void signalModifiedKey (client*,redisDb*,robj*)"
396035,METHOD,server.h:<global>,TYPE_DECL,"void signalFlushedDb(int dbid, int async);",6,41,server.h,signalFlushedDb,,false,3278,3278,signalFlushedDb,,,807,"void signalFlushedDb (int,int)"
396041,METHOD,server.h:<global>,TYPE_DECL,"void scanGenericCommand(client *c, robj *o, unsigned long cursor);",6,65,server.h,scanGenericCommand,,false,3279,3279,scanGenericCommand,,,808,"void scanGenericCommand (client*,robj*,long unsigned)"
396048,METHOD,server.h:<global>,TYPE_DECL,"int parseScanCursorOrReply(client *c, robj *o, unsigned long *cursor);",5,69,server.h,parseScanCursorOrReply,,false,3280,3280,parseScanCursorOrReply,,,809,"int parseScanCursorOrReply (client*,robj*,long unsigned*)"
396055,METHOD,server.h:<global>,TYPE_DECL,"int dbAsyncDelete(redisDb *db, robj *key);",5,41,server.h,dbAsyncDelete,,false,3281,3281,dbAsyncDelete,,,810,"int dbAsyncDelete (redisDb*,robj*)"
396061,METHOD,server.h:<global>,TYPE_DECL,void emptyDbAsync(redisDb *db);,6,30,server.h,emptyDbAsync,,false,3282,3282,emptyDbAsync,,,811,void emptyDbAsync (redisDb*)
396066,METHOD,server.h:<global>,TYPE_DECL,size_t lazyfreeGetPendingObjectsCount(void);,8,43,server.h,lazyfreeGetPendingObjectsCount,,false,3283,3283,lazyfreeGetPendingObjectsCount,,,812,size_t lazyfreeGetPendingObjectsCount (void)
396071,METHOD,server.h:<global>,TYPE_DECL,size_t lazyfreeGetFreedObjectsCount(void);,8,41,server.h,lazyfreeGetFreedObjectsCount,,false,3284,3284,lazyfreeGetFreedObjectsCount,,,813,size_t lazyfreeGetFreedObjectsCount (void)
396076,METHOD,server.h:<global>,TYPE_DECL,void lazyfreeResetStats(void);,6,29,server.h,lazyfreeResetStats,,false,3285,3285,lazyfreeResetStats,,,814,void lazyfreeResetStats (void)
396081,METHOD,server.h:<global>,TYPE_DECL,"void freeObjAsync(robj *key, robj *obj, int dbid);",6,49,server.h,freeObjAsync,,false,3286,3286,freeObjAsync,,,815,"void freeObjAsync (robj*,robj*,int)"
396088,METHOD,server.h:<global>,TYPE_DECL,"void freeReplicationBacklogRefMemAsync(list *blocks, rax *index);",6,64,server.h,freeReplicationBacklogRefMemAsync,,false,3287,3287,freeReplicationBacklogRefMemAsync,,,816,"void freeReplicationBacklogRefMemAsync (list*,rax*)"
396094,METHOD,server.h:<global>,TYPE_DECL,"int getKeysFromCommandWithSpecs(struct redisCommand *cmd, robj **argv, int argc, int search_flags, getKeysResult *result);",5,121,server.h,getKeysFromCommandWithSpecs,,false,3294,3294,getKeysFromCommandWithSpecs,,,817,"int getKeysFromCommandWithSpecs (redisCommand*,robj**,int,int,getKeysResult*)"
396103,METHOD,server.h:<global>,TYPE_DECL,"keyReference *getKeysPrepareResult(getKeysResult *result, int numkeys);",14,70,server.h,getKeysPrepareResult,,false,3295,3295,getKeysPrepareResult,,,818,"keyReference* getKeysPrepareResult (getKeysResult*,int)"
396109,METHOD,server.h:<global>,TYPE_DECL,"int getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,94,server.h,getKeysFromCommand,,false,3296,3296,getKeysFromCommand,,,819,"int getKeysFromCommand (redisCommand*,robj**,int,getKeysResult*)"
396117,METHOD,server.h:<global>,TYPE_DECL,int doesCommandHaveKeys(struct redisCommand *cmd);,5,49,server.h,doesCommandHaveKeys,,false,3297,3297,doesCommandHaveKeys,,,820,int doesCommandHaveKeys (redisCommand*)
396122,METHOD,server.h:<global>,TYPE_DECL,"int getChannelsFromCommand(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,98,server.h,getChannelsFromCommand,,false,3298,3298,getChannelsFromCommand,,,821,"int getChannelsFromCommand (redisCommand*,robj**,int,getKeysResult*)"
396130,METHOD,server.h:<global>,TYPE_DECL,"int doesCommandHaveChannelsWithFlags(struct redisCommand *cmd, int flags);",5,73,server.h,doesCommandHaveChannelsWithFlags,,false,3299,3299,doesCommandHaveChannelsWithFlags,,,822,"int doesCommandHaveChannelsWithFlags (redisCommand*,int)"
396136,METHOD,server.h:<global>,TYPE_DECL,void getKeysFreeResult(getKeysResult *result);,6,45,server.h,getKeysFreeResult,,false,3300,3300,getKeysFreeResult,,,823,void getKeysFreeResult (getKeysResult*)
396141,METHOD,server.h:<global>,TYPE_DECL,"int sintercardGetKeys(struct redisCommand *cmd,robj **argv, int argc, getKeysResult *result);",5,92,server.h,sintercardGetKeys,,false,3301,3301,sintercardGetKeys,,,824,"int sintercardGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396149,METHOD,server.h:<global>,TYPE_DECL,"int zunionInterDiffGetKeys(struct redisCommand *cmd,robj **argv, int argc, getKeysResult *result);",5,97,server.h,zunionInterDiffGetKeys,,false,3302,3302,zunionInterDiffGetKeys,,,825,"int zunionInterDiffGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396157,METHOD,server.h:<global>,TYPE_DECL,"int zunionInterDiffStoreGetKeys(struct redisCommand *cmd,robj **argv, int argc, getKeysResult *result);",5,102,server.h,zunionInterDiffStoreGetKeys,,false,3303,3303,zunionInterDiffStoreGetKeys,,,826,"int zunionInterDiffStoreGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396165,METHOD,server.h:<global>,TYPE_DECL,"int evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,87,server.h,evalGetKeys,,false,3304,3304,evalGetKeys,,,827,"int evalGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396173,METHOD,server.h:<global>,TYPE_DECL,"int functionGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,91,server.h,functionGetKeys,,false,3305,3305,functionGetKeys,,,828,"int functionGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396181,METHOD,server.h:<global>,TYPE_DECL,"int sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,87,server.h,sortGetKeys,,false,3306,3306,sortGetKeys,,,829,"int sortGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396189,METHOD,server.h:<global>,TYPE_DECL,"int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,89,server.h,sortROGetKeys,,false,3307,3307,sortROGetKeys,,,830,"int sortROGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396197,METHOD,server.h:<global>,TYPE_DECL,"int migrateGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,90,server.h,migrateGetKeys,,false,3308,3308,migrateGetKeys,,,831,"int migrateGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396205,METHOD,server.h:<global>,TYPE_DECL,"int georadiusGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,92,server.h,georadiusGetKeys,,false,3309,3309,georadiusGetKeys,,,832,"int georadiusGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396213,METHOD,server.h:<global>,TYPE_DECL,"int xreadGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,88,server.h,xreadGetKeys,,false,3310,3310,xreadGetKeys,,,833,"int xreadGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396221,METHOD,server.h:<global>,TYPE_DECL,"int lmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,88,server.h,lmpopGetKeys,,false,3311,3311,lmpopGetKeys,,,834,"int lmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396229,METHOD,server.h:<global>,TYPE_DECL,"int blmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,89,server.h,blmpopGetKeys,,false,3312,3312,blmpopGetKeys,,,835,"int blmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396237,METHOD,server.h:<global>,TYPE_DECL,"int zmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,88,server.h,zmpopGetKeys,,false,3313,3313,zmpopGetKeys,,,836,"int zmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396245,METHOD,server.h:<global>,TYPE_DECL,"int bzmpopGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,89,server.h,bzmpopGetKeys,,false,3314,3314,bzmpopGetKeys,,,837,"int bzmpopGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396253,METHOD,server.h:<global>,TYPE_DECL,"int setGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,86,server.h,setGetKeys,,false,3315,3315,setGetKeys,,,838,"int setGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396261,METHOD,server.h:<global>,TYPE_DECL,"int bitfieldGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result);",5,91,server.h,bitfieldGetKeys,,false,3316,3316,bitfieldGetKeys,,,839,"int bitfieldGetKeys (redisCommand*,robj**,int,getKeysResult*)"
396269,METHOD,server.h:<global>,TYPE_DECL,"unsigned short crc16(const char *buf, int len);",16,46,server.h,crc16,,false,3318,3318,crc16,,,840,"short unsigned crc16 (char*,int)"
396275,METHOD,server.h:<global>,TYPE_DECL,void initSentinelConfig(void);,6,29,server.h,initSentinelConfig,,false,3321,3321,initSentinelConfig,,,841,void initSentinelConfig (void)
396280,METHOD,server.h:<global>,TYPE_DECL,void initSentinel(void);,6,23,server.h,initSentinel,,false,3322,3322,initSentinel,,,842,void initSentinel (void)
396285,METHOD,server.h:<global>,TYPE_DECL,void sentinelTimer(void);,6,24,server.h,sentinelTimer,,false,3323,3323,sentinelTimer,,,843,void sentinelTimer (void)
396290,METHOD,server.h:<global>,TYPE_DECL,"const char *sentinelHandleConfiguration(char **argv, int argc);",12,62,server.h,sentinelHandleConfiguration,,false,3324,3324,sentinelHandleConfiguration,,,844,"char* sentinelHandleConfiguration (char**,int)"
396296,METHOD,server.h:<global>,TYPE_DECL,"void queueSentinelConfig(sds *argv, int argc, int linenum, sds line);",6,68,server.h,queueSentinelConfig,,false,3325,3325,queueSentinelConfig,,,845,"void queueSentinelConfig (sds*,int,int,sds)"
396304,METHOD,server.h:<global>,TYPE_DECL,void loadSentinelConfigFromQueue(void);,6,38,server.h,loadSentinelConfigFromQueue,,false,3326,3326,loadSentinelConfigFromQueue,,,846,void loadSentinelConfigFromQueue (void)
396309,METHOD,server.h:<global>,TYPE_DECL,void sentinelIsRunning(void);,6,28,server.h,sentinelIsRunning,,false,3327,3327,sentinelIsRunning,,,847,void sentinelIsRunning (void)
396314,METHOD,server.h:<global>,TYPE_DECL,void sentinelCheckConfigFile(void);,6,34,server.h,sentinelCheckConfigFile,,false,3328,3328,sentinelCheckConfigFile,,,848,void sentinelCheckConfigFile (void)
396319,METHOD,server.h:<global>,TYPE_DECL,void sentinelCommand(client *c);,6,31,server.h,sentinelCommand,,false,3329,3329,sentinelCommand,,,849,void sentinelCommand (client*)
396324,METHOD,server.h:<global>,TYPE_DECL,void sentinelInfoCommand(client *c);,6,35,server.h,sentinelInfoCommand,,false,3330,3330,sentinelInfoCommand,,,850,void sentinelInfoCommand (client*)
396329,METHOD,server.h:<global>,TYPE_DECL,void sentinelPublishCommand(client *c);,6,38,server.h,sentinelPublishCommand,,false,3331,3331,sentinelPublishCommand,,,851,void sentinelPublishCommand (client*)
396334,METHOD,server.h:<global>,TYPE_DECL,void sentinelRoleCommand(client *c);,6,35,server.h,sentinelRoleCommand,,false,3332,3332,sentinelRoleCommand,,,852,void sentinelRoleCommand (client*)
396339,METHOD,server.h:<global>,TYPE_DECL,"int redis_check_rdb(char *rdbfilename, FILE *fp);",5,48,server.h,redis_check_rdb,,false,3335,3335,redis_check_rdb,,,853,"int redis_check_rdb (char*,FILE*)"
396345,METHOD,server.h:<global>,TYPE_DECL,"int redis_check_rdb_main(int argc, char **argv, FILE *fp);",5,57,server.h,redis_check_rdb_main,,false,3336,3336,redis_check_rdb_main,,,854,"int redis_check_rdb_main (int,char**,FILE*)"
396352,METHOD,server.h:<global>,TYPE_DECL,"int redis_check_aof_main(int argc, char **argv);",5,47,server.h,redis_check_aof_main,,false,3337,3337,redis_check_aof_main,,,855,"int redis_check_aof_main (int,char**)"
396358,METHOD,server.h:<global>,TYPE_DECL,void scriptingInit(int setup);,6,29,server.h,scriptingInit,,false,3340,3340,scriptingInit,,,856,void scriptingInit (int)
396363,METHOD,server.h:<global>,TYPE_DECL,int ldbRemoveChild(pid_t pid);,5,29,server.h,ldbRemoveChild,,false,3341,3341,ldbRemoveChild,,,857,int ldbRemoveChild (pid_t)
396368,METHOD,server.h:<global>,TYPE_DECL,void ldbKillForkedSessions(void);,6,32,server.h,ldbKillForkedSessions,,false,3342,3342,ldbKillForkedSessions,,,858,void ldbKillForkedSessions (void)
396373,METHOD,server.h:<global>,TYPE_DECL,int ldbPendingChildren(void);,5,28,server.h,ldbPendingChildren,,false,3343,3343,ldbPendingChildren,,,859,int ldbPendingChildren (void)
396378,METHOD,server.h:<global>,TYPE_DECL,"sds luaCreateFunction(client *c, robj *body);",5,44,server.h,luaCreateFunction,,false,3344,3344,luaCreateFunction,,,860,"sds luaCreateFunction (client*,robj*)"
396384,METHOD,server.h:<global>,TYPE_DECL,"void luaLdbLineHook(lua_State *lua, lua_Debug *ar);",6,50,server.h,luaLdbLineHook,,false,3345,3345,luaLdbLineHook,,,861,"void luaLdbLineHook (lua_State*,lua_Debug*)"
396390,METHOD,server.h:<global>,TYPE_DECL,void freeLuaScriptsAsync(dict *lua_scripts);,6,43,server.h,freeLuaScriptsAsync,,false,3346,3346,freeLuaScriptsAsync,,,862,void freeLuaScriptsAsync (dict*)
396395,METHOD,server.h:<global>,TYPE_DECL,void freeFunctionsAsync(functionsLibCtx *lib_ctx);,6,49,server.h,freeFunctionsAsync,,false,3347,3347,freeFunctionsAsync,,,863,void freeFunctionsAsync (functionsLibCtx*)
396400,METHOD,server.h:<global>,TYPE_DECL,int ldbIsEnabled(void);,5,22,server.h,ldbIsEnabled,,false,3348,3348,ldbIsEnabled,,,864,int ldbIsEnabled (void)
396405,METHOD,server.h:<global>,TYPE_DECL,void ldbLog(sds entry);,6,22,server.h,ldbLog,,false,3349,3349,ldbLog,,,865,void ldbLog (sds)
396410,METHOD,server.h:<global>,TYPE_DECL,void ldbLogRedisReply(char *reply);,6,34,server.h,ldbLogRedisReply,,false,3350,3350,ldbLogRedisReply,,,866,void ldbLogRedisReply (char*)
396415,METHOD,server.h:<global>,TYPE_DECL,"void sha1hex(char *digest, char *script, size_t len);",6,52,server.h,sha1hex,,false,3351,3351,sha1hex,,,867,"void sha1hex (char*,char*,size_t)"
396422,METHOD,server.h:<global>,TYPE_DECL,unsigned long evalMemory(void);,15,30,server.h,evalMemory,,false,3352,3352,evalMemory,,,868,long unsigned evalMemory (void)
396427,METHOD,server.h:<global>,TYPE_DECL,dict* evalScriptsDict(void);,5,27,server.h,evalScriptsDict,,false,3353,3353,evalScriptsDict,,,869,dict* evalScriptsDict (void)
396432,METHOD,server.h:<global>,TYPE_DECL,unsigned long evalScriptsMemory(void);,15,37,server.h,evalScriptsMemory,,false,3354,3354,evalScriptsMemory,,,870,long unsigned evalScriptsMemory (void)
396437,METHOD,server.h:<global>,TYPE_DECL,"uint64_t evalGetCommandFlags(client *c, uint64_t orig_flags);",10,60,server.h,evalGetCommandFlags,,false,3355,3355,evalGetCommandFlags,,,871,"uint64_t evalGetCommandFlags (client*,uint64_t)"
396443,METHOD,server.h:<global>,TYPE_DECL,"uint64_t fcallGetCommandFlags(client *c, uint64_t orig_flags);",10,61,server.h,fcallGetCommandFlags,,false,3356,3356,fcallGetCommandFlags,,,872,"uint64_t fcallGetCommandFlags (client*,uint64_t)"
396449,METHOD,server.h:<global>,TYPE_DECL,int isInsideYieldingLongCommand(void);,5,37,server.h,isInsideYieldingLongCommand,,false,3357,3357,isInsideYieldingLongCommand,,,873,int isInsideYieldingLongCommand (void)
396458,METHOD,server.h:<global>,TYPE_DECL,void processUnblockedClients(void);,6,34,server.h,processUnblockedClients,,false,3368,3368,processUnblockedClients,,,876,void processUnblockedClients (void)
396463,METHOD,server.h:<global>,TYPE_DECL,void initClientBlockingState(client *c);,6,39,server.h,initClientBlockingState,,false,3369,3369,initClientBlockingState,,,877,void initClientBlockingState (client*)
396468,METHOD,server.h:<global>,TYPE_DECL,"void blockClient(client *c, int btype);",6,38,server.h,blockClient,,false,3370,3370,blockClient,,,878,"void blockClient (client*,int)"
396474,METHOD,server.h:<global>,TYPE_DECL,"void unblockClient(client *c, int queue_for_reprocessing);",6,57,server.h,unblockClient,,false,3371,3371,unblockClient,,,879,"void unblockClient (client*,int)"
396480,METHOD,server.h:<global>,TYPE_DECL,void unblockClientOnTimeout(client *c);,6,38,server.h,unblockClientOnTimeout,,false,3372,3372,unblockClientOnTimeout,,,880,void unblockClientOnTimeout (client*)
396485,METHOD,server.h:<global>,TYPE_DECL,"void unblockClientOnError(client *c, const char *err_str);",6,57,server.h,unblockClientOnError,,false,3373,3373,unblockClientOnError,,,881,"void unblockClientOnError (client*,char*)"
396491,METHOD,server.h:<global>,TYPE_DECL,void queueClientForReprocessing(client *c);,6,42,server.h,queueClientForReprocessing,,false,3374,3374,queueClientForReprocessing,,,882,void queueClientForReprocessing (client*)
396496,METHOD,server.h:<global>,TYPE_DECL,void replyToBlockedClientTimedOut(client *c);,6,44,server.h,replyToBlockedClientTimedOut,,false,3375,3375,replyToBlockedClientTimedOut,,,883,void replyToBlockedClientTimedOut (client*)
396501,METHOD,server.h:<global>,TYPE_DECL,"int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit);",5,85,server.h,getTimeoutFromObjectOrReply,,false,3376,3376,getTimeoutFromObjectOrReply,,,884,"int getTimeoutFromObjectOrReply (client*,robj*,mstime_t*,int)"
396509,METHOD,server.h:<global>,TYPE_DECL,void disconnectAllBlockedClients(void);,6,38,server.h,disconnectAllBlockedClients,,false,3377,3377,disconnectAllBlockedClients,,,885,void disconnectAllBlockedClients (void)
396514,METHOD,server.h:<global>,TYPE_DECL,void handleClientsBlockedOnKeys(void);,6,37,server.h,handleClientsBlockedOnKeys,,false,3378,3378,handleClientsBlockedOnKeys,,,886,void handleClientsBlockedOnKeys (void)
396519,METHOD,server.h:<global>,TYPE_DECL,"void signalKeyAsReady(redisDb *db, robj *key, int type);",6,55,server.h,signalKeyAsReady,,false,3379,3379,signalKeyAsReady,,,887,"void signalKeyAsReady (redisDb*,robj*,int)"
396526,METHOD,server.h:<global>,TYPE_DECL,"void blockForKeys(client *c, int btype, robj **keys, int numkeys, mstime_t timeout, int unblock_on_nokey);",6,105,server.h,blockForKeys,,false,3380,3380,blockForKeys,,,888,"void blockForKeys (client*,int,robj**,int,mstime_t,int)"
396536,METHOD,server.h:<global>,TYPE_DECL,void blockClientShutdown(client *c);,6,35,server.h,blockClientShutdown,,false,3381,3381,blockClientShutdown,,,889,void blockClientShutdown (client*)
396541,METHOD,server.h:<global>,TYPE_DECL,void blockPostponeClient(client *c);,6,35,server.h,blockPostponeClient,,false,3382,3382,blockPostponeClient,,,890,void blockPostponeClient (client*)
396546,METHOD,server.h:<global>,TYPE_DECL,"void blockForReplication(client *c, mstime_t timeout, long long offset, long numreplicas);",6,89,server.h,blockForReplication,,false,3383,3383,blockForReplication,,,891,"void blockForReplication (client*,mstime_t,long long,long)"
396554,METHOD,server.h:<global>,TYPE_DECL,"void blockForAofFsync(client *c, mstime_t timeout, long long offset, int numlocal, long numreplicas);",6,100,server.h,blockForAofFsync,,false,3384,3384,blockForAofFsync,,,892,"void blockForAofFsync (client*,mstime_t,long long,int,long)"
396563,METHOD,server.h:<global>,TYPE_DECL,"void signalDeletedKeyAsReady(redisDb *db, robj *key, int type);",6,62,server.h,signalDeletedKeyAsReady,,false,3385,3385,signalDeletedKeyAsReady,,,893,"void signalDeletedKeyAsReady (redisDb*,robj*,int)"
396570,METHOD,server.h:<global>,TYPE_DECL,"void updateStatsOnUnblock(client *c, long blocked_us, long reply_us, int had_errors);",6,84,server.h,updateStatsOnUnblock,,false,3386,3386,updateStatsOnUnblock,,,894,"void updateStatsOnUnblock (client*,long,long,int)"
396578,METHOD,server.h:<global>,TYPE_DECL,"void scanDatabaseForDeletedKeys(redisDb *emptied, redisDb *replaced_with);",6,73,server.h,scanDatabaseForDeletedKeys,,false,3387,3387,scanDatabaseForDeletedKeys,,,895,"void scanDatabaseForDeletedKeys (redisDb*,redisDb*)"
396584,METHOD,server.h:<global>,TYPE_DECL,"void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey);",6,98,server.h,totalNumberOfBlockingKeys,,false,3388,3388,totalNumberOfBlockingKeys,,,896,"void totalNumberOfBlockingKeys (long unsigned*,long unsigned*)"
396590,METHOD,server.h:<global>,TYPE_DECL,void blockedBeforeSleep(void);,6,29,server.h,blockedBeforeSleep,,false,3389,3389,blockedBeforeSleep,,,897,void blockedBeforeSleep (void)
396595,METHOD,server.h:<global>,TYPE_DECL,void addClientToTimeoutTable(client *c);,6,39,server.h,addClientToTimeoutTable,,false,3392,3392,addClientToTimeoutTable,,,898,void addClientToTimeoutTable (client*)
396600,METHOD,server.h:<global>,TYPE_DECL,void removeClientFromTimeoutTable(client *c);,6,44,server.h,removeClientFromTimeoutTable,,false,3393,3393,removeClientFromTimeoutTable,,,899,void removeClientFromTimeoutTable (client*)
396605,METHOD,server.h:<global>,TYPE_DECL,void handleBlockedClientsTimeout(void);,6,38,server.h,handleBlockedClientsTimeout,,false,3394,3394,handleBlockedClientsTimeout,,,900,void handleBlockedClientsTimeout (void)
396610,METHOD,server.h:<global>,TYPE_DECL,"int clientsCronHandleTimeout(client *c, mstime_t now_ms);",5,56,server.h,clientsCronHandleTimeout,,false,3395,3395,clientsCronHandleTimeout,,,901,"int clientsCronHandleTimeout (client*,mstime_t)"
396616,METHOD,server.h:<global>,TYPE_DECL,void activeExpireCycle(int type);,6,32,server.h,activeExpireCycle,,false,3398,3398,activeExpireCycle,,,902,void activeExpireCycle (int)
396621,METHOD,server.h:<global>,TYPE_DECL,void expireSlaveKeys(void);,6,26,server.h,expireSlaveKeys,,false,3399,3399,expireSlaveKeys,,,903,void expireSlaveKeys (void)
396626,METHOD,server.h:<global>,TYPE_DECL,"void rememberSlaveKeyWithExpire(redisDb *db, robj *key);",6,55,server.h,rememberSlaveKeyWithExpire,,false,3400,3400,rememberSlaveKeyWithExpire,,,904,"void rememberSlaveKeyWithExpire (redisDb*,robj*)"
396632,METHOD,server.h:<global>,TYPE_DECL,void flushSlaveKeysWithExpireList(void);,6,39,server.h,flushSlaveKeysWithExpireList,,false,3401,3401,flushSlaveKeysWithExpireList,,,905,void flushSlaveKeysWithExpireList (void)
396637,METHOD,server.h:<global>,TYPE_DECL,size_t getSlaveKeyWithExpireCount(void);,8,39,server.h,getSlaveKeyWithExpireCount,,false,3402,3402,getSlaveKeyWithExpireCount,,,906,size_t getSlaveKeyWithExpireCount (void)
396642,METHOD,server.h:<global>,TYPE_DECL,void evictionPoolAlloc(void);,6,28,server.h,evictionPoolAlloc,,false,3405,3405,evictionPoolAlloc,,,907,void evictionPoolAlloc (void)
396647,METHOD,server.h:<global>,TYPE_DECL,unsigned long LFUGetTimeInMinutes(void);,15,39,server.h,LFUGetTimeInMinutes,,false,3407,3407,LFUGetTimeInMinutes,,,908,long unsigned LFUGetTimeInMinutes (void)
396652,METHOD,server.h:<global>,TYPE_DECL,uint8_t LFULogIncr(uint8_t value);,9,33,server.h,LFULogIncr,,false,3408,3408,LFULogIncr,,,909,uint8_t LFULogIncr (uint8_t)
396657,METHOD,server.h:<global>,TYPE_DECL,unsigned long LFUDecrAndReturn(robj *o);,15,39,server.h,LFUDecrAndReturn,,false,3409,3409,LFUDecrAndReturn,,,910,long unsigned LFUDecrAndReturn (robj*)
396662,METHOD,server.h:<global>,TYPE_DECL,int performEvictions(void);,5,26,server.h,performEvictions,,false,3413,3413,performEvictions,,,911,int performEvictions (void)
396667,METHOD,server.h:<global>,TYPE_DECL,void startEvictionTimeProc(void);,6,32,server.h,startEvictionTimeProc,,false,3414,3414,startEvictionTimeProc,,,912,void startEvictionTimeProc (void)
396672,METHOD,server.h:<global>,TYPE_DECL,uint64_t dictSdsHash(const void *key);,10,37,server.h,dictSdsHash,,false,3417,3417,dictSdsHash,,,913,uint64_t dictSdsHash (void*)
396677,METHOD,server.h:<global>,TYPE_DECL,uint64_t dictSdsCaseHash(const void *key);,10,41,server.h,dictSdsCaseHash,,false,3418,3418,dictSdsCaseHash,,,914,uint64_t dictSdsCaseHash (void*)
396682,METHOD,server.h:<global>,TYPE_DECL,"int dictSdsKeyCompare(dict *d, const void *key1, const void *key2);",5,66,server.h,dictSdsKeyCompare,,false,3419,3419,dictSdsKeyCompare,,,915,"int dictSdsKeyCompare (dict*,void*,void*)"
396689,METHOD,server.h:<global>,TYPE_DECL,"int dictSdsKeyCaseCompare(dict *d, const void *key1, const void *key2);",5,70,server.h,dictSdsKeyCaseCompare,,false,3420,3420,dictSdsKeyCaseCompare,,,916,"int dictSdsKeyCaseCompare (dict*,void*,void*)"
396696,METHOD,server.h:<global>,TYPE_DECL,"void dictSdsDestructor(dict *d, void *val);",6,42,server.h,dictSdsDestructor,,false,3421,3421,dictSdsDestructor,,,917,"void dictSdsDestructor (dict*,void*)"
396702,METHOD,server.h:<global>,TYPE_DECL,"void dictListDestructor(dict *d, void *val);",6,43,server.h,dictListDestructor,,false,3422,3422,dictListDestructor,,,918,"void dictListDestructor (dict*,void*)"
396708,METHOD,server.h:<global>,TYPE_DECL,"void *dictSdsDup(dict *d, const void *key);",6,42,server.h,dictSdsDup,,false,3423,3423,dictSdsDup,,,919,"void* dictSdsDup (dict*,void*)"
396714,METHOD,server.h:<global>,TYPE_DECL,char *redisGitSHA1(void);,6,24,server.h,redisGitSHA1,,false,3426,3426,redisGitSHA1,,,920,char* redisGitSHA1 (void)
396719,METHOD,server.h:<global>,TYPE_DECL,char *redisGitDirty(void);,6,25,server.h,redisGitDirty,,false,3427,3427,redisGitDirty,,,921,char* redisGitDirty (void)
396724,METHOD,server.h:<global>,TYPE_DECL,uint64_t redisBuildId(void);,10,27,server.h,redisBuildId,,false,3428,3428,redisBuildId,,,922,uint64_t redisBuildId (void)
396729,METHOD,server.h:<global>,TYPE_DECL,const char *redisBuildIdRaw(void);,12,33,server.h,redisBuildIdRaw,,false,3429,3429,redisBuildIdRaw,,,923,char* redisBuildIdRaw (void)
396734,METHOD,server.h:<global>,TYPE_DECL,char *redisBuildIdString(void);,6,30,server.h,redisBuildIdString,,false,3430,3430,redisBuildIdString,,,924,char* redisBuildIdString (void)
396739,METHOD,server.h:<global>,TYPE_DECL,void authCommand(client *c);,6,27,server.h,authCommand,,false,3433,3433,authCommand,,,925,void authCommand (client*)
396744,METHOD,server.h:<global>,TYPE_DECL,void pingCommand(client *c);,6,27,server.h,pingCommand,,false,3434,3434,pingCommand,,,926,void pingCommand (client*)
396749,METHOD,server.h:<global>,TYPE_DECL,void echoCommand(client *c);,6,27,server.h,echoCommand,,false,3435,3435,echoCommand,,,927,void echoCommand (client*)
396754,METHOD,server.h:<global>,TYPE_DECL,void commandCommand(client *c);,6,30,server.h,commandCommand,,false,3436,3436,commandCommand,,,928,void commandCommand (client*)
396759,METHOD,server.h:<global>,TYPE_DECL,void commandCountCommand(client *c);,6,35,server.h,commandCountCommand,,false,3437,3437,commandCountCommand,,,929,void commandCountCommand (client*)
396764,METHOD,server.h:<global>,TYPE_DECL,void commandListCommand(client *c);,6,34,server.h,commandListCommand,,false,3438,3438,commandListCommand,,,930,void commandListCommand (client*)
396769,METHOD,server.h:<global>,TYPE_DECL,void commandInfoCommand(client *c);,6,34,server.h,commandInfoCommand,,false,3439,3439,commandInfoCommand,,,931,void commandInfoCommand (client*)
396774,METHOD,server.h:<global>,TYPE_DECL,void commandGetKeysCommand(client *c);,6,37,server.h,commandGetKeysCommand,,false,3440,3440,commandGetKeysCommand,,,932,void commandGetKeysCommand (client*)
396779,METHOD,server.h:<global>,TYPE_DECL,void commandGetKeysAndFlagsCommand(client *c);,6,45,server.h,commandGetKeysAndFlagsCommand,,false,3441,3441,commandGetKeysAndFlagsCommand,,,933,void commandGetKeysAndFlagsCommand (client*)
396784,METHOD,server.h:<global>,TYPE_DECL,void commandHelpCommand(client *c);,6,34,server.h,commandHelpCommand,,false,3442,3442,commandHelpCommand,,,934,void commandHelpCommand (client*)
396789,METHOD,server.h:<global>,TYPE_DECL,void commandDocsCommand(client *c);,6,34,server.h,commandDocsCommand,,false,3443,3443,commandDocsCommand,,,935,void commandDocsCommand (client*)
396794,METHOD,server.h:<global>,TYPE_DECL,void setCommand(client *c);,6,26,server.h,setCommand,,false,3444,3444,setCommand,,,936,void setCommand (client*)
396799,METHOD,server.h:<global>,TYPE_DECL,void setnxCommand(client *c);,6,28,server.h,setnxCommand,,false,3445,3445,setnxCommand,,,937,void setnxCommand (client*)
396804,METHOD,server.h:<global>,TYPE_DECL,void setexCommand(client *c);,6,28,server.h,setexCommand,,false,3446,3446,setexCommand,,,938,void setexCommand (client*)
396809,METHOD,server.h:<global>,TYPE_DECL,void psetexCommand(client *c);,6,29,server.h,psetexCommand,,false,3447,3447,psetexCommand,,,939,void psetexCommand (client*)
396814,METHOD,server.h:<global>,TYPE_DECL,void getCommand(client *c);,6,26,server.h,getCommand,,false,3448,3448,getCommand,,,940,void getCommand (client*)
396819,METHOD,server.h:<global>,TYPE_DECL,void getexCommand(client *c);,6,28,server.h,getexCommand,,false,3449,3449,getexCommand,,,941,void getexCommand (client*)
396824,METHOD,server.h:<global>,TYPE_DECL,void getdelCommand(client *c);,6,29,server.h,getdelCommand,,false,3450,3450,getdelCommand,,,942,void getdelCommand (client*)
396829,METHOD,server.h:<global>,TYPE_DECL,void delCommand(client *c);,6,26,server.h,delCommand,,false,3451,3451,delCommand,,,943,void delCommand (client*)
396834,METHOD,server.h:<global>,TYPE_DECL,void unlinkCommand(client *c);,6,29,server.h,unlinkCommand,,false,3452,3452,unlinkCommand,,,944,void unlinkCommand (client*)
396839,METHOD,server.h:<global>,TYPE_DECL,void existsCommand(client *c);,6,29,server.h,existsCommand,,false,3453,3453,existsCommand,,,945,void existsCommand (client*)
396844,METHOD,server.h:<global>,TYPE_DECL,void setbitCommand(client *c);,6,29,server.h,setbitCommand,,false,3454,3454,setbitCommand,,,946,void setbitCommand (client*)
396849,METHOD,server.h:<global>,TYPE_DECL,void getbitCommand(client *c);,6,29,server.h,getbitCommand,,false,3455,3455,getbitCommand,,,947,void getbitCommand (client*)
396854,METHOD,server.h:<global>,TYPE_DECL,void bitfieldCommand(client *c);,6,31,server.h,bitfieldCommand,,false,3456,3456,bitfieldCommand,,,948,void bitfieldCommand (client*)
396859,METHOD,server.h:<global>,TYPE_DECL,void bitfieldroCommand(client *c);,6,33,server.h,bitfieldroCommand,,false,3457,3457,bitfieldroCommand,,,949,void bitfieldroCommand (client*)
396864,METHOD,server.h:<global>,TYPE_DECL,void setrangeCommand(client *c);,6,31,server.h,setrangeCommand,,false,3458,3458,setrangeCommand,,,950,void setrangeCommand (client*)
396869,METHOD,server.h:<global>,TYPE_DECL,void getrangeCommand(client *c);,6,31,server.h,getrangeCommand,,false,3459,3459,getrangeCommand,,,951,void getrangeCommand (client*)
396874,METHOD,server.h:<global>,TYPE_DECL,void incrCommand(client *c);,6,27,server.h,incrCommand,,false,3460,3460,incrCommand,,,952,void incrCommand (client*)
396879,METHOD,server.h:<global>,TYPE_DECL,void decrCommand(client *c);,6,27,server.h,decrCommand,,false,3461,3461,decrCommand,,,953,void decrCommand (client*)
396884,METHOD,server.h:<global>,TYPE_DECL,void incrbyCommand(client *c);,6,29,server.h,incrbyCommand,,false,3462,3462,incrbyCommand,,,954,void incrbyCommand (client*)
396889,METHOD,server.h:<global>,TYPE_DECL,void decrbyCommand(client *c);,6,29,server.h,decrbyCommand,,false,3463,3463,decrbyCommand,,,955,void decrbyCommand (client*)
396894,METHOD,server.h:<global>,TYPE_DECL,void incrbyfloatCommand(client *c);,6,34,server.h,incrbyfloatCommand,,false,3464,3464,incrbyfloatCommand,,,956,void incrbyfloatCommand (client*)
396899,METHOD,server.h:<global>,TYPE_DECL,void selectCommand(client *c);,6,29,server.h,selectCommand,,false,3465,3465,selectCommand,,,957,void selectCommand (client*)
396904,METHOD,server.h:<global>,TYPE_DECL,void swapdbCommand(client *c);,6,29,server.h,swapdbCommand,,false,3466,3466,swapdbCommand,,,958,void swapdbCommand (client*)
396909,METHOD,server.h:<global>,TYPE_DECL,void randomkeyCommand(client *c);,6,32,server.h,randomkeyCommand,,false,3467,3467,randomkeyCommand,,,959,void randomkeyCommand (client*)
396914,METHOD,server.h:<global>,TYPE_DECL,void keysCommand(client *c);,6,27,server.h,keysCommand,,false,3468,3468,keysCommand,,,960,void keysCommand (client*)
396919,METHOD,server.h:<global>,TYPE_DECL,void scanCommand(client *c);,6,27,server.h,scanCommand,,false,3469,3469,scanCommand,,,961,void scanCommand (client*)
396924,METHOD,server.h:<global>,TYPE_DECL,void dbsizeCommand(client *c);,6,29,server.h,dbsizeCommand,,false,3470,3470,dbsizeCommand,,,962,void dbsizeCommand (client*)
396929,METHOD,server.h:<global>,TYPE_DECL,void lastsaveCommand(client *c);,6,31,server.h,lastsaveCommand,,false,3471,3471,lastsaveCommand,,,963,void lastsaveCommand (client*)
396934,METHOD,server.h:<global>,TYPE_DECL,void saveCommand(client *c);,6,27,server.h,saveCommand,,false,3472,3472,saveCommand,,,964,void saveCommand (client*)
396939,METHOD,server.h:<global>,TYPE_DECL,void bgsaveCommand(client *c);,6,29,server.h,bgsaveCommand,,false,3473,3473,bgsaveCommand,,,965,void bgsaveCommand (client*)
396944,METHOD,server.h:<global>,TYPE_DECL,void bgrewriteaofCommand(client *c);,6,35,server.h,bgrewriteaofCommand,,false,3474,3474,bgrewriteaofCommand,,,966,void bgrewriteaofCommand (client*)
396949,METHOD,server.h:<global>,TYPE_DECL,void shutdownCommand(client *c);,6,31,server.h,shutdownCommand,,false,3475,3475,shutdownCommand,,,967,void shutdownCommand (client*)
396954,METHOD,server.h:<global>,TYPE_DECL,void slowlogCommand(client *c);,6,30,server.h,slowlogCommand,,false,3476,3476,slowlogCommand,,,968,void slowlogCommand (client*)
396959,METHOD,server.h:<global>,TYPE_DECL,void moveCommand(client *c);,6,27,server.h,moveCommand,,false,3477,3477,moveCommand,,,969,void moveCommand (client*)
396964,METHOD,server.h:<global>,TYPE_DECL,void copyCommand(client *c);,6,27,server.h,copyCommand,,false,3478,3478,copyCommand,,,970,void copyCommand (client*)
396969,METHOD,server.h:<global>,TYPE_DECL,void renameCommand(client *c);,6,29,server.h,renameCommand,,false,3479,3479,renameCommand,,,971,void renameCommand (client*)
396974,METHOD,server.h:<global>,TYPE_DECL,void renamenxCommand(client *c);,6,31,server.h,renamenxCommand,,false,3480,3480,renamenxCommand,,,972,void renamenxCommand (client*)
396979,METHOD,server.h:<global>,TYPE_DECL,void lpushCommand(client *c);,6,28,server.h,lpushCommand,,false,3481,3481,lpushCommand,,,973,void lpushCommand (client*)
396984,METHOD,server.h:<global>,TYPE_DECL,void rpushCommand(client *c);,6,28,server.h,rpushCommand,,false,3482,3482,rpushCommand,,,974,void rpushCommand (client*)
396989,METHOD,server.h:<global>,TYPE_DECL,void lpushxCommand(client *c);,6,29,server.h,lpushxCommand,,false,3483,3483,lpushxCommand,,,975,void lpushxCommand (client*)
396994,METHOD,server.h:<global>,TYPE_DECL,void rpushxCommand(client *c);,6,29,server.h,rpushxCommand,,false,3484,3484,rpushxCommand,,,976,void rpushxCommand (client*)
396999,METHOD,server.h:<global>,TYPE_DECL,void linsertCommand(client *c);,6,30,server.h,linsertCommand,,false,3485,3485,linsertCommand,,,977,void linsertCommand (client*)
397004,METHOD,server.h:<global>,TYPE_DECL,void lpopCommand(client *c);,6,27,server.h,lpopCommand,,false,3486,3486,lpopCommand,,,978,void lpopCommand (client*)
397009,METHOD,server.h:<global>,TYPE_DECL,void rpopCommand(client *c);,6,27,server.h,rpopCommand,,false,3487,3487,rpopCommand,,,979,void rpopCommand (client*)
397014,METHOD,server.h:<global>,TYPE_DECL,void lmpopCommand(client *c);,6,28,server.h,lmpopCommand,,false,3488,3488,lmpopCommand,,,980,void lmpopCommand (client*)
397019,METHOD,server.h:<global>,TYPE_DECL,void llenCommand(client *c);,6,27,server.h,llenCommand,,false,3489,3489,llenCommand,,,981,void llenCommand (client*)
397024,METHOD,server.h:<global>,TYPE_DECL,void lindexCommand(client *c);,6,29,server.h,lindexCommand,,false,3490,3490,lindexCommand,,,982,void lindexCommand (client*)
397029,METHOD,server.h:<global>,TYPE_DECL,void lrangeCommand(client *c);,6,29,server.h,lrangeCommand,,false,3491,3491,lrangeCommand,,,983,void lrangeCommand (client*)
397034,METHOD,server.h:<global>,TYPE_DECL,void ltrimCommand(client *c);,6,28,server.h,ltrimCommand,,false,3492,3492,ltrimCommand,,,984,void ltrimCommand (client*)
397039,METHOD,server.h:<global>,TYPE_DECL,void typeCommand(client *c);,6,27,server.h,typeCommand,,false,3493,3493,typeCommand,,,985,void typeCommand (client*)
397044,METHOD,server.h:<global>,TYPE_DECL,void lsetCommand(client *c);,6,27,server.h,lsetCommand,,false,3494,3494,lsetCommand,,,986,void lsetCommand (client*)
397049,METHOD,server.h:<global>,TYPE_DECL,void saddCommand(client *c);,6,27,server.h,saddCommand,,false,3495,3495,saddCommand,,,987,void saddCommand (client*)
397054,METHOD,server.h:<global>,TYPE_DECL,void sremCommand(client *c);,6,27,server.h,sremCommand,,false,3496,3496,sremCommand,,,988,void sremCommand (client*)
397059,METHOD,server.h:<global>,TYPE_DECL,void smoveCommand(client *c);,6,28,server.h,smoveCommand,,false,3497,3497,smoveCommand,,,989,void smoveCommand (client*)
397064,METHOD,server.h:<global>,TYPE_DECL,void sismemberCommand(client *c);,6,32,server.h,sismemberCommand,,false,3498,3498,sismemberCommand,,,990,void sismemberCommand (client*)
397069,METHOD,server.h:<global>,TYPE_DECL,void smismemberCommand(client *c);,6,33,server.h,smismemberCommand,,false,3499,3499,smismemberCommand,,,991,void smismemberCommand (client*)
397074,METHOD,server.h:<global>,TYPE_DECL,void scardCommand(client *c);,6,28,server.h,scardCommand,,false,3500,3500,scardCommand,,,992,void scardCommand (client*)
397079,METHOD,server.h:<global>,TYPE_DECL,void spopCommand(client *c);,6,27,server.h,spopCommand,,false,3501,3501,spopCommand,,,993,void spopCommand (client*)
397084,METHOD,server.h:<global>,TYPE_DECL,void srandmemberCommand(client *c);,6,34,server.h,srandmemberCommand,,false,3502,3502,srandmemberCommand,,,994,void srandmemberCommand (client*)
397089,METHOD,server.h:<global>,TYPE_DECL,void sinterCommand(client *c);,6,29,server.h,sinterCommand,,false,3503,3503,sinterCommand,,,995,void sinterCommand (client*)
397094,METHOD,server.h:<global>,TYPE_DECL,void sinterCardCommand(client *c);,6,33,server.h,sinterCardCommand,,false,3504,3504,sinterCardCommand,,,996,void sinterCardCommand (client*)
397099,METHOD,server.h:<global>,TYPE_DECL,void sinterstoreCommand(client *c);,6,34,server.h,sinterstoreCommand,,false,3505,3505,sinterstoreCommand,,,997,void sinterstoreCommand (client*)
397104,METHOD,server.h:<global>,TYPE_DECL,void sunionCommand(client *c);,6,29,server.h,sunionCommand,,false,3506,3506,sunionCommand,,,998,void sunionCommand (client*)
397109,METHOD,server.h:<global>,TYPE_DECL,void sunionstoreCommand(client *c);,6,34,server.h,sunionstoreCommand,,false,3507,3507,sunionstoreCommand,,,999,void sunionstoreCommand (client*)
397114,METHOD,server.h:<global>,TYPE_DECL,void sdiffCommand(client *c);,6,28,server.h,sdiffCommand,,false,3508,3508,sdiffCommand,,,1000,void sdiffCommand (client*)
397119,METHOD,server.h:<global>,TYPE_DECL,void sdiffstoreCommand(client *c);,6,33,server.h,sdiffstoreCommand,,false,3509,3509,sdiffstoreCommand,,,1001,void sdiffstoreCommand (client*)
397124,METHOD,server.h:<global>,TYPE_DECL,void sscanCommand(client *c);,6,28,server.h,sscanCommand,,false,3510,3510,sscanCommand,,,1002,void sscanCommand (client*)
397129,METHOD,server.h:<global>,TYPE_DECL,void syncCommand(client *c);,6,27,server.h,syncCommand,,false,3511,3511,syncCommand,,,1003,void syncCommand (client*)
397134,METHOD,server.h:<global>,TYPE_DECL,void flushdbCommand(client *c);,6,30,server.h,flushdbCommand,,false,3512,3512,flushdbCommand,,,1004,void flushdbCommand (client*)
397139,METHOD,server.h:<global>,TYPE_DECL,void flushallCommand(client *c);,6,31,server.h,flushallCommand,,false,3513,3513,flushallCommand,,,1005,void flushallCommand (client*)
397144,METHOD,server.h:<global>,TYPE_DECL,void sortCommand(client *c);,6,27,server.h,sortCommand,,false,3514,3514,sortCommand,,,1006,void sortCommand (client*)
397149,METHOD,server.h:<global>,TYPE_DECL,void sortroCommand(client *c);,6,29,server.h,sortroCommand,,false,3515,3515,sortroCommand,,,1007,void sortroCommand (client*)
397154,METHOD,server.h:<global>,TYPE_DECL,void lremCommand(client *c);,6,27,server.h,lremCommand,,false,3516,3516,lremCommand,,,1008,void lremCommand (client*)
397159,METHOD,server.h:<global>,TYPE_DECL,void lposCommand(client *c);,6,27,server.h,lposCommand,,false,3517,3517,lposCommand,,,1009,void lposCommand (client*)
397164,METHOD,server.h:<global>,TYPE_DECL,void rpoplpushCommand(client *c);,6,32,server.h,rpoplpushCommand,,false,3518,3518,rpoplpushCommand,,,1010,void rpoplpushCommand (client*)
397169,METHOD,server.h:<global>,TYPE_DECL,void lmoveCommand(client *c);,6,28,server.h,lmoveCommand,,false,3519,3519,lmoveCommand,,,1011,void lmoveCommand (client*)
397174,METHOD,server.h:<global>,TYPE_DECL,void infoCommand(client *c);,6,27,server.h,infoCommand,,false,3520,3520,infoCommand,,,1012,void infoCommand (client*)
397179,METHOD,server.h:<global>,TYPE_DECL,void mgetCommand(client *c);,6,27,server.h,mgetCommand,,false,3521,3521,mgetCommand,,,1013,void mgetCommand (client*)
397184,METHOD,server.h:<global>,TYPE_DECL,void monitorCommand(client *c);,6,30,server.h,monitorCommand,,false,3522,3522,monitorCommand,,,1014,void monitorCommand (client*)
397189,METHOD,server.h:<global>,TYPE_DECL,void expireCommand(client *c);,6,29,server.h,expireCommand,,false,3523,3523,expireCommand,,,1015,void expireCommand (client*)
397194,METHOD,server.h:<global>,TYPE_DECL,void expireatCommand(client *c);,6,31,server.h,expireatCommand,,false,3524,3524,expireatCommand,,,1016,void expireatCommand (client*)
397199,METHOD,server.h:<global>,TYPE_DECL,void pexpireCommand(client *c);,6,30,server.h,pexpireCommand,,false,3525,3525,pexpireCommand,,,1017,void pexpireCommand (client*)
397204,METHOD,server.h:<global>,TYPE_DECL,void pexpireatCommand(client *c);,6,32,server.h,pexpireatCommand,,false,3526,3526,pexpireatCommand,,,1018,void pexpireatCommand (client*)
397209,METHOD,server.h:<global>,TYPE_DECL,void getsetCommand(client *c);,6,29,server.h,getsetCommand,,false,3527,3527,getsetCommand,,,1019,void getsetCommand (client*)
397214,METHOD,server.h:<global>,TYPE_DECL,void ttlCommand(client *c);,6,26,server.h,ttlCommand,,false,3528,3528,ttlCommand,,,1020,void ttlCommand (client*)
397219,METHOD,server.h:<global>,TYPE_DECL,void touchCommand(client *c);,6,28,server.h,touchCommand,,false,3529,3529,touchCommand,,,1021,void touchCommand (client*)
397224,METHOD,server.h:<global>,TYPE_DECL,void pttlCommand(client *c);,6,27,server.h,pttlCommand,,false,3530,3530,pttlCommand,,,1022,void pttlCommand (client*)
397229,METHOD,server.h:<global>,TYPE_DECL,void expiretimeCommand(client *c);,6,33,server.h,expiretimeCommand,,false,3531,3531,expiretimeCommand,,,1023,void expiretimeCommand (client*)
397234,METHOD,server.h:<global>,TYPE_DECL,void pexpiretimeCommand(client *c);,6,34,server.h,pexpiretimeCommand,,false,3532,3532,pexpiretimeCommand,,,1024,void pexpiretimeCommand (client*)
397239,METHOD,server.h:<global>,TYPE_DECL,void persistCommand(client *c);,6,30,server.h,persistCommand,,false,3533,3533,persistCommand,,,1025,void persistCommand (client*)
397244,METHOD,server.h:<global>,TYPE_DECL,void replicaofCommand(client *c);,6,32,server.h,replicaofCommand,,false,3534,3534,replicaofCommand,,,1026,void replicaofCommand (client*)
397249,METHOD,server.h:<global>,TYPE_DECL,void roleCommand(client *c);,6,27,server.h,roleCommand,,false,3535,3535,roleCommand,,,1027,void roleCommand (client*)
397254,METHOD,server.h:<global>,TYPE_DECL,void debugCommand(client *c);,6,28,server.h,debugCommand,,false,3536,3536,debugCommand,,,1028,void debugCommand (client*)
397259,METHOD,server.h:<global>,TYPE_DECL,void msetCommand(client *c);,6,27,server.h,msetCommand,,false,3537,3537,msetCommand,,,1029,void msetCommand (client*)
397264,METHOD,server.h:<global>,TYPE_DECL,void msetnxCommand(client *c);,6,29,server.h,msetnxCommand,,false,3538,3538,msetnxCommand,,,1030,void msetnxCommand (client*)
397269,METHOD,server.h:<global>,TYPE_DECL,void zaddCommand(client *c);,6,27,server.h,zaddCommand,,false,3539,3539,zaddCommand,,,1031,void zaddCommand (client*)
397274,METHOD,server.h:<global>,TYPE_DECL,void zincrbyCommand(client *c);,6,30,server.h,zincrbyCommand,,false,3540,3540,zincrbyCommand,,,1032,void zincrbyCommand (client*)
397279,METHOD,server.h:<global>,TYPE_DECL,void zrangeCommand(client *c);,6,29,server.h,zrangeCommand,,false,3541,3541,zrangeCommand,,,1033,void zrangeCommand (client*)
397284,METHOD,server.h:<global>,TYPE_DECL,void zrangebyscoreCommand(client *c);,6,36,server.h,zrangebyscoreCommand,,false,3542,3542,zrangebyscoreCommand,,,1034,void zrangebyscoreCommand (client*)
397289,METHOD,server.h:<global>,TYPE_DECL,void zrevrangebyscoreCommand(client *c);,6,39,server.h,zrevrangebyscoreCommand,,false,3543,3543,zrevrangebyscoreCommand,,,1035,void zrevrangebyscoreCommand (client*)
397294,METHOD,server.h:<global>,TYPE_DECL,void zrangebylexCommand(client *c);,6,34,server.h,zrangebylexCommand,,false,3544,3544,zrangebylexCommand,,,1036,void zrangebylexCommand (client*)
397299,METHOD,server.h:<global>,TYPE_DECL,void zrevrangebylexCommand(client *c);,6,37,server.h,zrevrangebylexCommand,,false,3545,3545,zrevrangebylexCommand,,,1037,void zrevrangebylexCommand (client*)
397304,METHOD,server.h:<global>,TYPE_DECL,void zcountCommand(client *c);,6,29,server.h,zcountCommand,,false,3546,3546,zcountCommand,,,1038,void zcountCommand (client*)
397309,METHOD,server.h:<global>,TYPE_DECL,void zlexcountCommand(client *c);,6,32,server.h,zlexcountCommand,,false,3547,3547,zlexcountCommand,,,1039,void zlexcountCommand (client*)
397314,METHOD,server.h:<global>,TYPE_DECL,void zrevrangeCommand(client *c);,6,32,server.h,zrevrangeCommand,,false,3548,3548,zrevrangeCommand,,,1040,void zrevrangeCommand (client*)
397319,METHOD,server.h:<global>,TYPE_DECL,void zcardCommand(client *c);,6,28,server.h,zcardCommand,,false,3549,3549,zcardCommand,,,1041,void zcardCommand (client*)
397324,METHOD,server.h:<global>,TYPE_DECL,void zremCommand(client *c);,6,27,server.h,zremCommand,,false,3550,3550,zremCommand,,,1042,void zremCommand (client*)
397329,METHOD,server.h:<global>,TYPE_DECL,void zscoreCommand(client *c);,6,29,server.h,zscoreCommand,,false,3551,3551,zscoreCommand,,,1043,void zscoreCommand (client*)
397334,METHOD,server.h:<global>,TYPE_DECL,void zmscoreCommand(client *c);,6,30,server.h,zmscoreCommand,,false,3552,3552,zmscoreCommand,,,1044,void zmscoreCommand (client*)
397339,METHOD,server.h:<global>,TYPE_DECL,void zremrangebyscoreCommand(client *c);,6,39,server.h,zremrangebyscoreCommand,,false,3553,3553,zremrangebyscoreCommand,,,1045,void zremrangebyscoreCommand (client*)
397344,METHOD,server.h:<global>,TYPE_DECL,void zremrangebylexCommand(client *c);,6,37,server.h,zremrangebylexCommand,,false,3554,3554,zremrangebylexCommand,,,1046,void zremrangebylexCommand (client*)
397349,METHOD,server.h:<global>,TYPE_DECL,void zpopminCommand(client *c);,6,30,server.h,zpopminCommand,,false,3555,3555,zpopminCommand,,,1047,void zpopminCommand (client*)
397354,METHOD,server.h:<global>,TYPE_DECL,void zpopmaxCommand(client *c);,6,30,server.h,zpopmaxCommand,,false,3556,3556,zpopmaxCommand,,,1048,void zpopmaxCommand (client*)
397359,METHOD,server.h:<global>,TYPE_DECL,void zmpopCommand(client *c);,6,28,server.h,zmpopCommand,,false,3557,3557,zmpopCommand,,,1049,void zmpopCommand (client*)
397364,METHOD,server.h:<global>,TYPE_DECL,void bzpopminCommand(client *c);,6,31,server.h,bzpopminCommand,,false,3558,3558,bzpopminCommand,,,1050,void bzpopminCommand (client*)
397369,METHOD,server.h:<global>,TYPE_DECL,void bzpopmaxCommand(client *c);,6,31,server.h,bzpopmaxCommand,,false,3559,3559,bzpopmaxCommand,,,1051,void bzpopmaxCommand (client*)
397374,METHOD,server.h:<global>,TYPE_DECL,void bzmpopCommand(client *c);,6,29,server.h,bzmpopCommand,,false,3560,3560,bzmpopCommand,,,1052,void bzmpopCommand (client*)
397379,METHOD,server.h:<global>,TYPE_DECL,void zrandmemberCommand(client *c);,6,34,server.h,zrandmemberCommand,,false,3561,3561,zrandmemberCommand,,,1053,void zrandmemberCommand (client*)
397384,METHOD,server.h:<global>,TYPE_DECL,void multiCommand(client *c);,6,28,server.h,multiCommand,,false,3562,3562,multiCommand,,,1054,void multiCommand (client*)
397389,METHOD,server.h:<global>,TYPE_DECL,void execCommand(client *c);,6,27,server.h,execCommand,,false,3563,3563,execCommand,,,1055,void execCommand (client*)
397394,METHOD,server.h:<global>,TYPE_DECL,void discardCommand(client *c);,6,30,server.h,discardCommand,,false,3564,3564,discardCommand,,,1056,void discardCommand (client*)
397399,METHOD,server.h:<global>,TYPE_DECL,void blpopCommand(client *c);,6,28,server.h,blpopCommand,,false,3565,3565,blpopCommand,,,1057,void blpopCommand (client*)
397404,METHOD,server.h:<global>,TYPE_DECL,void brpopCommand(client *c);,6,28,server.h,brpopCommand,,false,3566,3566,brpopCommand,,,1058,void brpopCommand (client*)
397409,METHOD,server.h:<global>,TYPE_DECL,void blmpopCommand(client *c);,6,29,server.h,blmpopCommand,,false,3567,3567,blmpopCommand,,,1059,void blmpopCommand (client*)
397414,METHOD,server.h:<global>,TYPE_DECL,void brpoplpushCommand(client *c);,6,33,server.h,brpoplpushCommand,,false,3568,3568,brpoplpushCommand,,,1060,void brpoplpushCommand (client*)
397419,METHOD,server.h:<global>,TYPE_DECL,void blmoveCommand(client *c);,6,29,server.h,blmoveCommand,,false,3569,3569,blmoveCommand,,,1061,void blmoveCommand (client*)
397424,METHOD,server.h:<global>,TYPE_DECL,void appendCommand(client *c);,6,29,server.h,appendCommand,,false,3570,3570,appendCommand,,,1062,void appendCommand (client*)
397429,METHOD,server.h:<global>,TYPE_DECL,void strlenCommand(client *c);,6,29,server.h,strlenCommand,,false,3571,3571,strlenCommand,,,1063,void strlenCommand (client*)
397434,METHOD,server.h:<global>,TYPE_DECL,void zrankCommand(client *c);,6,28,server.h,zrankCommand,,false,3572,3572,zrankCommand,,,1064,void zrankCommand (client*)
397439,METHOD,server.h:<global>,TYPE_DECL,void zrevrankCommand(client *c);,6,31,server.h,zrevrankCommand,,false,3573,3573,zrevrankCommand,,,1065,void zrevrankCommand (client*)
397444,METHOD,server.h:<global>,TYPE_DECL,void hsetCommand(client *c);,6,27,server.h,hsetCommand,,false,3574,3574,hsetCommand,,,1066,void hsetCommand (client*)
397449,METHOD,server.h:<global>,TYPE_DECL,void hsetnxCommand(client *c);,6,29,server.h,hsetnxCommand,,false,3575,3575,hsetnxCommand,,,1067,void hsetnxCommand (client*)
397454,METHOD,server.h:<global>,TYPE_DECL,void hgetCommand(client *c);,6,27,server.h,hgetCommand,,false,3576,3576,hgetCommand,,,1068,void hgetCommand (client*)
397459,METHOD,server.h:<global>,TYPE_DECL,void hmgetCommand(client *c);,6,28,server.h,hmgetCommand,,false,3577,3577,hmgetCommand,,,1069,void hmgetCommand (client*)
397464,METHOD,server.h:<global>,TYPE_DECL,void hdelCommand(client *c);,6,27,server.h,hdelCommand,,false,3578,3578,hdelCommand,,,1070,void hdelCommand (client*)
397469,METHOD,server.h:<global>,TYPE_DECL,void hlenCommand(client *c);,6,27,server.h,hlenCommand,,false,3579,3579,hlenCommand,,,1071,void hlenCommand (client*)
397474,METHOD,server.h:<global>,TYPE_DECL,void hstrlenCommand(client *c);,6,30,server.h,hstrlenCommand,,false,3580,3580,hstrlenCommand,,,1072,void hstrlenCommand (client*)
397479,METHOD,server.h:<global>,TYPE_DECL,void zremrangebyrankCommand(client *c);,6,38,server.h,zremrangebyrankCommand,,false,3581,3581,zremrangebyrankCommand,,,1073,void zremrangebyrankCommand (client*)
397484,METHOD,server.h:<global>,TYPE_DECL,void zunionstoreCommand(client *c);,6,34,server.h,zunionstoreCommand,,false,3582,3582,zunionstoreCommand,,,1074,void zunionstoreCommand (client*)
397489,METHOD,server.h:<global>,TYPE_DECL,void zinterstoreCommand(client *c);,6,34,server.h,zinterstoreCommand,,false,3583,3583,zinterstoreCommand,,,1075,void zinterstoreCommand (client*)
397494,METHOD,server.h:<global>,TYPE_DECL,void zdiffstoreCommand(client *c);,6,33,server.h,zdiffstoreCommand,,false,3584,3584,zdiffstoreCommand,,,1076,void zdiffstoreCommand (client*)
397499,METHOD,server.h:<global>,TYPE_DECL,void zunionCommand(client *c);,6,29,server.h,zunionCommand,,false,3585,3585,zunionCommand,,,1077,void zunionCommand (client*)
397504,METHOD,server.h:<global>,TYPE_DECL,void zinterCommand(client *c);,6,29,server.h,zinterCommand,,false,3586,3586,zinterCommand,,,1078,void zinterCommand (client*)
397509,METHOD,server.h:<global>,TYPE_DECL,void zinterCardCommand(client *c);,6,33,server.h,zinterCardCommand,,false,3587,3587,zinterCardCommand,,,1079,void zinterCardCommand (client*)
397514,METHOD,server.h:<global>,TYPE_DECL,void zrangestoreCommand(client *c);,6,34,server.h,zrangestoreCommand,,false,3588,3588,zrangestoreCommand,,,1080,void zrangestoreCommand (client*)
397519,METHOD,server.h:<global>,TYPE_DECL,void zdiffCommand(client *c);,6,28,server.h,zdiffCommand,,false,3589,3589,zdiffCommand,,,1081,void zdiffCommand (client*)
397524,METHOD,server.h:<global>,TYPE_DECL,void zscanCommand(client *c);,6,28,server.h,zscanCommand,,false,3590,3590,zscanCommand,,,1082,void zscanCommand (client*)
397529,METHOD,server.h:<global>,TYPE_DECL,void hkeysCommand(client *c);,6,28,server.h,hkeysCommand,,false,3591,3591,hkeysCommand,,,1083,void hkeysCommand (client*)
397534,METHOD,server.h:<global>,TYPE_DECL,void hvalsCommand(client *c);,6,28,server.h,hvalsCommand,,false,3592,3592,hvalsCommand,,,1084,void hvalsCommand (client*)
397539,METHOD,server.h:<global>,TYPE_DECL,void hgetallCommand(client *c);,6,30,server.h,hgetallCommand,,false,3593,3593,hgetallCommand,,,1085,void hgetallCommand (client*)
397544,METHOD,server.h:<global>,TYPE_DECL,void hexistsCommand(client *c);,6,30,server.h,hexistsCommand,,false,3594,3594,hexistsCommand,,,1086,void hexistsCommand (client*)
397549,METHOD,server.h:<global>,TYPE_DECL,void hscanCommand(client *c);,6,28,server.h,hscanCommand,,false,3595,3595,hscanCommand,,,1087,void hscanCommand (client*)
397554,METHOD,server.h:<global>,TYPE_DECL,void hrandfieldCommand(client *c);,6,33,server.h,hrandfieldCommand,,false,3596,3596,hrandfieldCommand,,,1088,void hrandfieldCommand (client*)
397559,METHOD,server.h:<global>,TYPE_DECL,void configSetCommand(client *c);,6,32,server.h,configSetCommand,,false,3597,3597,configSetCommand,,,1089,void configSetCommand (client*)
397564,METHOD,server.h:<global>,TYPE_DECL,void configGetCommand(client *c);,6,32,server.h,configGetCommand,,false,3598,3598,configGetCommand,,,1090,void configGetCommand (client*)
397569,METHOD,server.h:<global>,TYPE_DECL,void configResetStatCommand(client *c);,6,38,server.h,configResetStatCommand,,false,3599,3599,configResetStatCommand,,,1091,void configResetStatCommand (client*)
397574,METHOD,server.h:<global>,TYPE_DECL,void configRewriteCommand(client *c);,6,36,server.h,configRewriteCommand,,false,3600,3600,configRewriteCommand,,,1092,void configRewriteCommand (client*)
397579,METHOD,server.h:<global>,TYPE_DECL,void configHelpCommand(client *c);,6,33,server.h,configHelpCommand,,false,3601,3601,configHelpCommand,,,1093,void configHelpCommand (client*)
397584,METHOD,server.h:<global>,TYPE_DECL,void hincrbyCommand(client *c);,6,30,server.h,hincrbyCommand,,false,3602,3602,hincrbyCommand,,,1094,void hincrbyCommand (client*)
397589,METHOD,server.h:<global>,TYPE_DECL,void hincrbyfloatCommand(client *c);,6,35,server.h,hincrbyfloatCommand,,false,3603,3603,hincrbyfloatCommand,,,1095,void hincrbyfloatCommand (client*)
397594,METHOD,server.h:<global>,TYPE_DECL,void subscribeCommand(client *c);,6,32,server.h,subscribeCommand,,false,3604,3604,subscribeCommand,,,1096,void subscribeCommand (client*)
397599,METHOD,server.h:<global>,TYPE_DECL,void unsubscribeCommand(client *c);,6,34,server.h,unsubscribeCommand,,false,3605,3605,unsubscribeCommand,,,1097,void unsubscribeCommand (client*)
397604,METHOD,server.h:<global>,TYPE_DECL,void psubscribeCommand(client *c);,6,33,server.h,psubscribeCommand,,false,3606,3606,psubscribeCommand,,,1098,void psubscribeCommand (client*)
397609,METHOD,server.h:<global>,TYPE_DECL,void punsubscribeCommand(client *c);,6,35,server.h,punsubscribeCommand,,false,3607,3607,punsubscribeCommand,,,1099,void punsubscribeCommand (client*)
397614,METHOD,server.h:<global>,TYPE_DECL,void publishCommand(client *c);,6,30,server.h,publishCommand,,false,3608,3608,publishCommand,,,1100,void publishCommand (client*)
397619,METHOD,server.h:<global>,TYPE_DECL,void pubsubCommand(client *c);,6,29,server.h,pubsubCommand,,false,3609,3609,pubsubCommand,,,1101,void pubsubCommand (client*)
397624,METHOD,server.h:<global>,TYPE_DECL,void spublishCommand(client *c);,6,31,server.h,spublishCommand,,false,3610,3610,spublishCommand,,,1102,void spublishCommand (client*)
397629,METHOD,server.h:<global>,TYPE_DECL,void ssubscribeCommand(client *c);,6,33,server.h,ssubscribeCommand,,false,3611,3611,ssubscribeCommand,,,1103,void ssubscribeCommand (client*)
397634,METHOD,server.h:<global>,TYPE_DECL,void sunsubscribeCommand(client *c);,6,35,server.h,sunsubscribeCommand,,false,3612,3612,sunsubscribeCommand,,,1104,void sunsubscribeCommand (client*)
397639,METHOD,server.h:<global>,TYPE_DECL,void watchCommand(client *c);,6,28,server.h,watchCommand,,false,3613,3613,watchCommand,,,1105,void watchCommand (client*)
397644,METHOD,server.h:<global>,TYPE_DECL,void unwatchCommand(client *c);,6,30,server.h,unwatchCommand,,false,3614,3614,unwatchCommand,,,1106,void unwatchCommand (client*)
397649,METHOD,server.h:<global>,TYPE_DECL,void clusterCommand(client *c);,6,30,server.h,clusterCommand,,false,3615,3615,clusterCommand,,,1107,void clusterCommand (client*)
397654,METHOD,server.h:<global>,TYPE_DECL,void restoreCommand(client *c);,6,30,server.h,restoreCommand,,false,3616,3616,restoreCommand,,,1108,void restoreCommand (client*)
397659,METHOD,server.h:<global>,TYPE_DECL,void migrateCommand(client *c);,6,30,server.h,migrateCommand,,false,3617,3617,migrateCommand,,,1109,void migrateCommand (client*)
397664,METHOD,server.h:<global>,TYPE_DECL,void askingCommand(client *c);,6,29,server.h,askingCommand,,false,3618,3618,askingCommand,,,1110,void askingCommand (client*)
397669,METHOD,server.h:<global>,TYPE_DECL,void readonlyCommand(client *c);,6,31,server.h,readonlyCommand,,false,3619,3619,readonlyCommand,,,1111,void readonlyCommand (client*)
397674,METHOD,server.h:<global>,TYPE_DECL,void readwriteCommand(client *c);,6,32,server.h,readwriteCommand,,false,3620,3620,readwriteCommand,,,1112,void readwriteCommand (client*)
397679,METHOD,server.h:<global>,TYPE_DECL,"int verifyDumpPayload(unsigned char *p, size_t len, uint16_t *rdbver_ptr);",5,73,server.h,verifyDumpPayload,,false,3621,3621,verifyDumpPayload,,,1113,"int verifyDumpPayload (unsigned char*,size_t,uint16_t*)"
397686,METHOD,server.h:<global>,TYPE_DECL,void dumpCommand(client *c);,6,27,server.h,dumpCommand,,false,3622,3622,dumpCommand,,,1114,void dumpCommand (client*)
397691,METHOD,server.h:<global>,TYPE_DECL,void objectCommand(client *c);,6,29,server.h,objectCommand,,false,3623,3623,objectCommand,,,1115,void objectCommand (client*)
397696,METHOD,server.h:<global>,TYPE_DECL,void memoryCommand(client *c);,6,29,server.h,memoryCommand,,false,3624,3624,memoryCommand,,,1116,void memoryCommand (client*)
397701,METHOD,server.h:<global>,TYPE_DECL,void clientCommand(client *c);,6,29,server.h,clientCommand,,false,3625,3625,clientCommand,,,1117,void clientCommand (client*)
397706,METHOD,server.h:<global>,TYPE_DECL,void helloCommand(client *c);,6,28,server.h,helloCommand,,false,3626,3626,helloCommand,,,1118,void helloCommand (client*)
397711,METHOD,server.h:<global>,TYPE_DECL,void clientSetinfoCommand(client *c);,6,36,server.h,clientSetinfoCommand,,false,3627,3627,clientSetinfoCommand,,,1119,void clientSetinfoCommand (client*)
397716,METHOD,server.h:<global>,TYPE_DECL,void evalCommand(client *c);,6,27,server.h,evalCommand,,false,3628,3628,evalCommand,,,1120,void evalCommand (client*)
397721,METHOD,server.h:<global>,TYPE_DECL,void evalRoCommand(client *c);,6,29,server.h,evalRoCommand,,false,3629,3629,evalRoCommand,,,1121,void evalRoCommand (client*)
397726,METHOD,server.h:<global>,TYPE_DECL,void evalShaCommand(client *c);,6,30,server.h,evalShaCommand,,false,3630,3630,evalShaCommand,,,1122,void evalShaCommand (client*)
397731,METHOD,server.h:<global>,TYPE_DECL,void evalShaRoCommand(client *c);,6,32,server.h,evalShaRoCommand,,false,3631,3631,evalShaRoCommand,,,1123,void evalShaRoCommand (client*)
397736,METHOD,server.h:<global>,TYPE_DECL,void scriptCommand(client *c);,6,29,server.h,scriptCommand,,false,3632,3632,scriptCommand,,,1124,void scriptCommand (client*)
397741,METHOD,server.h:<global>,TYPE_DECL,void fcallCommand(client *c);,6,28,server.h,fcallCommand,,false,3633,3633,fcallCommand,,,1125,void fcallCommand (client*)
397746,METHOD,server.h:<global>,TYPE_DECL,void fcallroCommand(client *c);,6,30,server.h,fcallroCommand,,false,3634,3634,fcallroCommand,,,1126,void fcallroCommand (client*)
397751,METHOD,server.h:<global>,TYPE_DECL,void functionLoadCommand(client *c);,6,35,server.h,functionLoadCommand,,false,3635,3635,functionLoadCommand,,,1127,void functionLoadCommand (client*)
397756,METHOD,server.h:<global>,TYPE_DECL,void functionDeleteCommand(client *c);,6,37,server.h,functionDeleteCommand,,false,3636,3636,functionDeleteCommand,,,1128,void functionDeleteCommand (client*)
397761,METHOD,server.h:<global>,TYPE_DECL,void functionKillCommand(client *c);,6,35,server.h,functionKillCommand,,false,3637,3637,functionKillCommand,,,1129,void functionKillCommand (client*)
397766,METHOD,server.h:<global>,TYPE_DECL,void functionStatsCommand(client *c);,6,36,server.h,functionStatsCommand,,false,3638,3638,functionStatsCommand,,,1130,void functionStatsCommand (client*)
397771,METHOD,server.h:<global>,TYPE_DECL,void functionListCommand(client *c);,6,35,server.h,functionListCommand,,false,3639,3639,functionListCommand,,,1131,void functionListCommand (client*)
397776,METHOD,server.h:<global>,TYPE_DECL,void functionHelpCommand(client *c);,6,35,server.h,functionHelpCommand,,false,3640,3640,functionHelpCommand,,,1132,void functionHelpCommand (client*)
397781,METHOD,server.h:<global>,TYPE_DECL,void functionFlushCommand(client *c);,6,36,server.h,functionFlushCommand,,false,3641,3641,functionFlushCommand,,,1133,void functionFlushCommand (client*)
397786,METHOD,server.h:<global>,TYPE_DECL,void functionRestoreCommand(client *c);,6,38,server.h,functionRestoreCommand,,false,3642,3642,functionRestoreCommand,,,1134,void functionRestoreCommand (client*)
397791,METHOD,server.h:<global>,TYPE_DECL,void functionDumpCommand(client *c);,6,35,server.h,functionDumpCommand,,false,3643,3643,functionDumpCommand,,,1135,void functionDumpCommand (client*)
397796,METHOD,server.h:<global>,TYPE_DECL,void timeCommand(client *c);,6,27,server.h,timeCommand,,false,3644,3644,timeCommand,,,1136,void timeCommand (client*)
397801,METHOD,server.h:<global>,TYPE_DECL,void bitopCommand(client *c);,6,28,server.h,bitopCommand,,false,3645,3645,bitopCommand,,,1137,void bitopCommand (client*)
397806,METHOD,server.h:<global>,TYPE_DECL,void bitcountCommand(client *c);,6,31,server.h,bitcountCommand,,false,3646,3646,bitcountCommand,,,1138,void bitcountCommand (client*)
397811,METHOD,server.h:<global>,TYPE_DECL,void bitposCommand(client *c);,6,29,server.h,bitposCommand,,false,3647,3647,bitposCommand,,,1139,void bitposCommand (client*)
397816,METHOD,server.h:<global>,TYPE_DECL,void replconfCommand(client *c);,6,31,server.h,replconfCommand,,false,3648,3648,replconfCommand,,,1140,void replconfCommand (client*)
397821,METHOD,server.h:<global>,TYPE_DECL,void waitCommand(client *c);,6,27,server.h,waitCommand,,false,3649,3649,waitCommand,,,1141,void waitCommand (client*)
397826,METHOD,server.h:<global>,TYPE_DECL,void waitaofCommand(client *c);,6,30,server.h,waitaofCommand,,false,3650,3650,waitaofCommand,,,1142,void waitaofCommand (client*)
397831,METHOD,server.h:<global>,TYPE_DECL,void georadiusbymemberCommand(client *c);,6,40,server.h,georadiusbymemberCommand,,false,3651,3651,georadiusbymemberCommand,,,1143,void georadiusbymemberCommand (client*)
397836,METHOD,server.h:<global>,TYPE_DECL,void georadiusbymemberroCommand(client *c);,6,42,server.h,georadiusbymemberroCommand,,false,3652,3652,georadiusbymemberroCommand,,,1144,void georadiusbymemberroCommand (client*)
397841,METHOD,server.h:<global>,TYPE_DECL,void georadiusCommand(client *c);,6,32,server.h,georadiusCommand,,false,3653,3653,georadiusCommand,,,1145,void georadiusCommand (client*)
397846,METHOD,server.h:<global>,TYPE_DECL,void georadiusroCommand(client *c);,6,34,server.h,georadiusroCommand,,false,3654,3654,georadiusroCommand,,,1146,void georadiusroCommand (client*)
397851,METHOD,server.h:<global>,TYPE_DECL,void geoaddCommand(client *c);,6,29,server.h,geoaddCommand,,false,3655,3655,geoaddCommand,,,1147,void geoaddCommand (client*)
397856,METHOD,server.h:<global>,TYPE_DECL,void geohashCommand(client *c);,6,30,server.h,geohashCommand,,false,3656,3656,geohashCommand,,,1148,void geohashCommand (client*)
397861,METHOD,server.h:<global>,TYPE_DECL,void geoposCommand(client *c);,6,29,server.h,geoposCommand,,false,3657,3657,geoposCommand,,,1149,void geoposCommand (client*)
397866,METHOD,server.h:<global>,TYPE_DECL,void geodistCommand(client *c);,6,30,server.h,geodistCommand,,false,3658,3658,geodistCommand,,,1150,void geodistCommand (client*)
397871,METHOD,server.h:<global>,TYPE_DECL,void geosearchCommand(client *c);,6,32,server.h,geosearchCommand,,false,3659,3659,geosearchCommand,,,1151,void geosearchCommand (client*)
397876,METHOD,server.h:<global>,TYPE_DECL,void geosearchstoreCommand(client *c);,6,37,server.h,geosearchstoreCommand,,false,3660,3660,geosearchstoreCommand,,,1152,void geosearchstoreCommand (client*)
397881,METHOD,server.h:<global>,TYPE_DECL,void pfselftestCommand(client *c);,6,33,server.h,pfselftestCommand,,false,3661,3661,pfselftestCommand,,,1153,void pfselftestCommand (client*)
397886,METHOD,server.h:<global>,TYPE_DECL,void pfaddCommand(client *c);,6,28,server.h,pfaddCommand,,false,3662,3662,pfaddCommand,,,1154,void pfaddCommand (client*)
397891,METHOD,server.h:<global>,TYPE_DECL,void pfcountCommand(client *c);,6,30,server.h,pfcountCommand,,false,3663,3663,pfcountCommand,,,1155,void pfcountCommand (client*)
397896,METHOD,server.h:<global>,TYPE_DECL,void pfmergeCommand(client *c);,6,30,server.h,pfmergeCommand,,false,3664,3664,pfmergeCommand,,,1156,void pfmergeCommand (client*)
397901,METHOD,server.h:<global>,TYPE_DECL,void pfdebugCommand(client *c);,6,30,server.h,pfdebugCommand,,false,3665,3665,pfdebugCommand,,,1157,void pfdebugCommand (client*)
397906,METHOD,server.h:<global>,TYPE_DECL,void latencyCommand(client *c);,6,30,server.h,latencyCommand,,false,3666,3666,latencyCommand,,,1158,void latencyCommand (client*)
397911,METHOD,server.h:<global>,TYPE_DECL,void moduleCommand(client *c);,6,29,server.h,moduleCommand,,false,3667,3667,moduleCommand,,,1159,void moduleCommand (client*)
397916,METHOD,server.h:<global>,TYPE_DECL,void securityWarningCommand(client *c);,6,38,server.h,securityWarningCommand,,false,3668,3668,securityWarningCommand,,,1160,void securityWarningCommand (client*)
397921,METHOD,server.h:<global>,TYPE_DECL,void xaddCommand(client *c);,6,27,server.h,xaddCommand,,false,3669,3669,xaddCommand,,,1161,void xaddCommand (client*)
397926,METHOD,server.h:<global>,TYPE_DECL,void xrangeCommand(client *c);,6,29,server.h,xrangeCommand,,false,3670,3670,xrangeCommand,,,1162,void xrangeCommand (client*)
397931,METHOD,server.h:<global>,TYPE_DECL,void xrevrangeCommand(client *c);,6,32,server.h,xrevrangeCommand,,false,3671,3671,xrevrangeCommand,,,1163,void xrevrangeCommand (client*)
397936,METHOD,server.h:<global>,TYPE_DECL,void xlenCommand(client *c);,6,27,server.h,xlenCommand,,false,3672,3672,xlenCommand,,,1164,void xlenCommand (client*)
397941,METHOD,server.h:<global>,TYPE_DECL,void xreadCommand(client *c);,6,28,server.h,xreadCommand,,false,3673,3673,xreadCommand,,,1165,void xreadCommand (client*)
397946,METHOD,server.h:<global>,TYPE_DECL,void xgroupCommand(client *c);,6,29,server.h,xgroupCommand,,false,3674,3674,xgroupCommand,,,1166,void xgroupCommand (client*)
397951,METHOD,server.h:<global>,TYPE_DECL,void xsetidCommand(client *c);,6,29,server.h,xsetidCommand,,false,3675,3675,xsetidCommand,,,1167,void xsetidCommand (client*)
397956,METHOD,server.h:<global>,TYPE_DECL,void xackCommand(client *c);,6,27,server.h,xackCommand,,false,3676,3676,xackCommand,,,1168,void xackCommand (client*)
397961,METHOD,server.h:<global>,TYPE_DECL,void xpendingCommand(client *c);,6,31,server.h,xpendingCommand,,false,3677,3677,xpendingCommand,,,1169,void xpendingCommand (client*)
397966,METHOD,server.h:<global>,TYPE_DECL,void xclaimCommand(client *c);,6,29,server.h,xclaimCommand,,false,3678,3678,xclaimCommand,,,1170,void xclaimCommand (client*)
397971,METHOD,server.h:<global>,TYPE_DECL,void xautoclaimCommand(client *c);,6,33,server.h,xautoclaimCommand,,false,3679,3679,xautoclaimCommand,,,1171,void xautoclaimCommand (client*)
397976,METHOD,server.h:<global>,TYPE_DECL,void xinfoCommand(client *c);,6,28,server.h,xinfoCommand,,false,3680,3680,xinfoCommand,,,1172,void xinfoCommand (client*)
397981,METHOD,server.h:<global>,TYPE_DECL,void xdelCommand(client *c);,6,27,server.h,xdelCommand,,false,3681,3681,xdelCommand,,,1173,void xdelCommand (client*)
397986,METHOD,server.h:<global>,TYPE_DECL,void xtrimCommand(client *c);,6,28,server.h,xtrimCommand,,false,3682,3682,xtrimCommand,,,1174,void xtrimCommand (client*)
397991,METHOD,server.h:<global>,TYPE_DECL,void lolwutCommand(client *c);,6,29,server.h,lolwutCommand,,false,3683,3683,lolwutCommand,,,1175,void lolwutCommand (client*)
397996,METHOD,server.h:<global>,TYPE_DECL,void aclCommand(client *c);,6,26,server.h,aclCommand,,false,3684,3684,aclCommand,,,1176,void aclCommand (client*)
398001,METHOD,server.h:<global>,TYPE_DECL,void lcsCommand(client *c);,6,26,server.h,lcsCommand,,false,3685,3685,lcsCommand,,,1177,void lcsCommand (client*)
398006,METHOD,server.h:<global>,TYPE_DECL,void quitCommand(client *c);,6,27,server.h,quitCommand,,false,3686,3686,quitCommand,,,1178,void quitCommand (client*)
398011,METHOD,server.h:<global>,TYPE_DECL,void resetCommand(client *c);,6,28,server.h,resetCommand,,false,3687,3687,resetCommand,,,1179,void resetCommand (client*)
398016,METHOD,server.h:<global>,TYPE_DECL,void failoverCommand(client *c);,6,31,server.h,failoverCommand,,false,3688,3688,failoverCommand,,,1180,void failoverCommand (client*)
398021,METHOD,server.h:<global>,TYPE_DECL,"void _serverAssertWithInfo(const client *c, const robj *o, const char *estr, const char *file, int line);",6,104,server.h,_serverAssertWithInfo,,false,3698,3698,_serverAssertWithInfo,,,1181,"void _serverAssertWithInfo (client*,robj*,char*,char*,int)"
398030,METHOD,server.h:<global>,TYPE_DECL,"void _serverAssert(const char *estr, const char *file, int line);",6,64,server.h,_serverAssert,,false,3699,3699,_serverAssert,,,1182,"void _serverAssert (char*,char*,int)"
398037,METHOD,server.h:<global>,TYPE_DECL,"void _serverPanic(const char *file, int line, const char *msg, ...);",6,67,server.h,_serverPanic,,false,3704,3704,_serverPanic,,,1183,"void _serverPanic (char*,int,char*...)"
398044,METHOD,server.h:<global>,TYPE_DECL,void serverLogObjectDebugInfo(const robj *o);,6,44,server.h,serverLogObjectDebugInfo,,false,3706,3706,serverLogObjectDebugInfo,,,1184,void serverLogObjectDebugInfo (robj*)
398049,METHOD,server.h:<global>,TYPE_DECL,"void sigsegvHandler(int sig, siginfo_t *info, void *secret);",6,59,server.h,sigsegvHandler,,false,3707,3707,sigsegvHandler,,,1185,"void sigsegvHandler (int,siginfo_t*,void*)"
398056,METHOD,server.h:<global>,TYPE_DECL,"const char *getSafeInfoString(const char *s, size_t len, char **tmp);",12,68,server.h,getSafeInfoString,,false,3708,3708,getSafeInfoString,,,1186,"char* getSafeInfoString (char*,size_t,char**)"
398063,METHOD,server.h:<global>,TYPE_DECL,"dict *genInfoSectionDict(robj **argv, int argc, char **defaults, int *out_all, int *out_everything);",6,99,server.h,genInfoSectionDict,,false,3709,3709,genInfoSectionDict,,,1187,"dict* genInfoSectionDict (robj**,int,char**,int*,int*)"
398072,METHOD,server.h:<global>,TYPE_DECL,void releaseInfoSectionDict(dict *sec);,6,38,server.h,releaseInfoSectionDict,,false,3710,3710,releaseInfoSectionDict,,,1188,void releaseInfoSectionDict (dict*)
398077,METHOD,server.h:<global>,TYPE_DECL,"sds genRedisInfoString(dict *section_dict, int all_sections, int everything);",5,76,server.h,genRedisInfoString,,false,3711,3711,genRedisInfoString,,,1189,"sds genRedisInfoString (dict*,int,int)"
398084,METHOD,server.h:<global>,TYPE_DECL,sds genModulesInfoString(sds info);,5,34,server.h,genModulesInfoString,,false,3712,3712,genModulesInfoString,,,1190,sds genModulesInfoString (sds)
398089,METHOD,server.h:<global>,TYPE_DECL,void applyWatchdogPeriod(void);,6,30,server.h,applyWatchdogPeriod,,false,3713,3713,applyWatchdogPeriod,,,1191,void applyWatchdogPeriod (void)
398094,METHOD,server.h:<global>,TYPE_DECL,void watchdogScheduleSignal(int period);,6,39,server.h,watchdogScheduleSignal,,false,3714,3714,watchdogScheduleSignal,,,1192,void watchdogScheduleSignal (int)
398099,METHOD,server.h:<global>,TYPE_DECL,"void serverLogHexDump(int level, char *descr, void *value, size_t len);",6,70,server.h,serverLogHexDump,,false,3715,3715,serverLogHexDump,,,1193,"void serverLogHexDump (int,char*,void*,size_t)"
398107,METHOD,server.h:<global>,TYPE_DECL,"int memtest_preserving_test(unsigned long *m, size_t bytes, int passes);",5,71,server.h,memtest_preserving_test,,false,3716,3716,memtest_preserving_test,,,1194,"int memtest_preserving_test (long unsigned*,size_t,int)"
398114,METHOD,server.h:<global>,TYPE_DECL,"void mixDigest(unsigned char *digest, const void *ptr, size_t len);",6,66,server.h,mixDigest,,false,3717,3717,mixDigest,,,1195,"void mixDigest (unsigned char*,void*,size_t)"
398121,METHOD,server.h:<global>,TYPE_DECL,"void xorDigest(unsigned char *digest, const void *ptr, size_t len);",6,66,server.h,xorDigest,,false,3718,3718,xorDigest,,,1196,"void xorDigest (unsigned char*,void*,size_t)"
398128,METHOD,server.h:<global>,TYPE_DECL,"sds catSubCommandFullname(const char *parent_name, const char *sub_name);",5,72,server.h,catSubCommandFullname,,false,3719,3719,catSubCommandFullname,,,1197,"sds catSubCommandFullname (char*,char*)"
398134,METHOD,server.h:<global>,TYPE_DECL,"void commandAddSubcommand(struct redisCommand *parent, struct redisCommand *subcommand, const char *declared_name);",6,114,server.h,commandAddSubcommand,,false,3720,3720,commandAddSubcommand,,,1198,"void commandAddSubcommand (redisCommand*,redisCommand*,char*)"
398141,METHOD,server.h:<global>,TYPE_DECL,void debugDelay(int usec);,6,25,server.h,debugDelay,,false,3721,3721,debugDelay,,,1199,void debugDelay (int)
398146,METHOD,server.h:<global>,TYPE_DECL,void killIOThreads(void);,6,24,server.h,killIOThreads,,false,3722,3722,killIOThreads,,,1200,void killIOThreads (void)
398151,METHOD,server.h:<global>,TYPE_DECL,void killThreads(void);,6,22,server.h,killThreads,,false,3723,3723,killThreads,,,1201,void killThreads (void)
398156,METHOD,server.h:<global>,TYPE_DECL,void makeThreadKillable(void);,6,29,server.h,makeThreadKillable,,false,3724,3724,makeThreadKillable,,,1202,void makeThreadKillable (void)
398161,METHOD,server.h:<global>,TYPE_DECL,void swapMainDbWithTempDb(redisDb *tempDb);,6,42,server.h,swapMainDbWithTempDb,,false,3725,3725,swapMainDbWithTempDb,,,1203,void swapMainDbWithTempDb (redisDb*)
398166,METHOD,server.h:<global>,TYPE_DECL,int iAmMaster(void);,5,19,server.h,iAmMaster,,false,3739,3739,iAmMaster,,,1204,int iAmMaster (void)
398196,METHOD,setcpuaffinity.c:<global>,TYPE_DECL,<global>,1,7,setcpuaffinity.c,setcpuaffinity.c:<global>,,false,1,155,<global>,,,1,
398213,METHOD,setproctitle.c:<global>,TYPE_DECL,<global>,1,5,setproctitle.c,setproctitle.c:<global>,,false,1,331,<global>,,,1,
398230,METHOD,sha1.c:<global>,TYPE_DECL,<global>,1,20,sha1.c,sha1.c:<global>,,false,1,239,<global>,,,1,
398232,METHOD,sha1.c:<global>,TYPE_DECL,"void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])
{
    uint32_t a, b, c, d, e;
    typedef union {
        unsigned char c[64];
        uint32_t l[16];
    } CHAR64LONG16;
#ifdef SHA1HANDSOFF
    CHAR64LONG16 block[1];  /* use array to appear as a pointer */
    memcpy(block, buffer, 64);
#else
    /* The following had better never be used because it causes the
     * pointer-to-const buffer to be cast into a pointer to non-const.
     * And the result is written through.  I threw a ""const"" in, hoping
     * this will cause a diagnostic.
     */
    CHAR64LONG16* block = (const CHAR64LONG16*)buffer;
#endif
    /* Copy context->state[] to working vars */
    a = state[0];
    b = state[1];
    c = state[2];
    d = state[3];
    e = state[4];
    /* 4 rounds of 20 operations each. Loop unrolled. */
    R0(a,b,c,d,e, 0); R0(e,a,b,c,d, 1); R0(d,e,a,b,c, 2); R0(c,d,e,a,b, 3);
    R0(b,c,d,e,a, 4); R0(a,b,c,d,e, 5); R0(e,a,b,c,d, 6); R0(d,e,a,b,c, 7);
    R0(c,d,e,a,...",1,4,sha1.c,SHA1Transform,,false,56,112,SHA1Transform,,,1,"void SHA1Transform (uint32_t[5],unsigned char[64])"
407283,METHOD,sha1.c:<global>,TYPE_DECL,"void SHA1Init(SHA1_CTX* context)
{
    /* SHA1 initialization constants */
    context->state[0] = 0x67452301;
    context->state[1] = 0xEFCDAB89;
    context->state[2] = 0x98BADCFE;
    context->state[3] = 0x10325476;
    context->state[4] = 0xC3D2E1F0;
    context->count[0] = context->count[1] = 0;
}",1,1,sha1.c,SHA1Init,,false,117,126,SHA1Init,,,2,void SHA1Init (SHA1_CTX*)
407336,METHOD,sha1.c:<global>,TYPE_DECL,"void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)
{
    uint32_t i, j;

    j = context->count[0];
    if ((context->count[0] += len << 3) < j)
        context->count[1]++;
    context->count[1] += (len>>29);
    j = (j >> 3) & 63;
    if ((j + len) > 63) {
        memcpy(&context->buffer[j], data, (i = 64-j));
        SHA1Transform(context->state, context->buffer);
        for ( ; i + 63 < len; i += 64) {
            SHA1Transform(context->state, &data[i]);
        }
        j = 0;
    }
    else i = 0;
    memcpy(&context->buffer[j], &data[i], len - i);
}",1,1,sha1.c,SHA1Update,,false,139,158,SHA1Update,,,3,"void SHA1Update (SHA1_CTX*,unsigned char*,uint32_t)"
407455,METHOD,sha1.c:<global>,TYPE_DECL,"void SHA1Final(unsigned char digest[20], SHA1_CTX* context)
{
    unsigned i;
    unsigned char finalcount[8];
    unsigned char c;

#if 0	/* untested ""improvement"" by DHR */
    /* Convert context->count to a sequence of bytes
     * in finalcount.  Second element first, but
     * big-endian order within element.
     * But we do it all backwards.
     */
    unsigned char *fcp = &finalcount[8];

    for (i = 0; i < 2; i++)
       {
        uint32_t t = context->count[i];
        int j;

        for (j = 0; j < 4; t >>= 8, j++)
	          *--fcp = (unsigned char) t;
    }
#else
    for (i = 0; i < 8; i++) {
        finalcount[i] = (unsigned char)((context->count[(i >= 4 ? 0 : 1)]
         >> ((3-(i & 3)) * 8) ) & 255);  /* Endian independent */
    }
#endif
    c = 0200;
    SHA1Update(context, &c, 1);
    while ((context->count[0] & 504) != 448) {
	c = 0000;
        SHA1Update(context, &c, 1);
    }
    SHA1Update(context, finalcount, 8);  /* Should cause a SHA1Transform() */
   ...",1,1,sha1.c,SHA1Final,,false,166,208,SHA1Final,,,4,"void SHA1Final (unsigned char[20],SHA1_CTX*)"
407581,METHOD,sha1.h:<global>,TYPE_DECL,<global>,1,6,sha1.h,sha1.h:<global>,,false,1,27,<global>,,,1,
407587,METHOD,<empty>,<empty>,<empty>,1,,sha1.h,SHA1_CTX:<clinit>,,false,10,,<clinit>,,,4,
407598,METHOD,sha1.h:<global>,TYPE_DECL,"void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]);",6,69,sha1.h,SHA1Transform,,false,16,16,SHA1Transform,,,3,"void SHA1Transform (uint32_t[5],unsigned char[64])"
407604,METHOD,sha1.h:<global>,TYPE_DECL,void SHA1Init(SHA1_CTX* context);,6,32,sha1.h,SHA1Init,,false,17,17,SHA1Init,,,4,void SHA1Init (SHA1_CTX*)
407609,METHOD,sha1.h:<global>,TYPE_DECL,"__attribute__((noinline)) void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len);",32,101,sha1.h,SHA1Update,,false,21,21,SHA1Update,,,5,"void SHA1Update (SHA1_CTX*,unsigned char*,uint32_t)"
407616,METHOD,sha1.h:<global>,TYPE_DECL,"void SHA1Final(unsigned char digest[20], SHA1_CTX* context);",6,59,sha1.h,SHA1Final,,false,22,22,SHA1Final,,,6,"void SHA1Final (unsigned char[20],SHA1_CTX*)"
407631,METHOD,sha256.c:<global>,TYPE_DECL,<global>,1,20,sha256.c,sha256.c:<global>,,false,1,163,<global>,,,1,
407701,METHOD,sha256.c:<global>,TYPE_DECL,"void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
{
	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];

    for (i = 0, j = 0; i < 16; ++i, j += 4) {
        m[i] = ((WORD) data[j + 0] << 24) |
               ((WORD) data[j + 1] << 16) |
               ((WORD) data[j + 2] << 8) |
               ((WORD) data[j + 3]);
    }

	for ( ; i < 64; ++i)
		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];

	a = ctx->state[0];
	b = ctx->state[1];
	c = ctx->state[2];
	d = ctx->state[3];
	e = ctx->state[4];
	f = ctx->state[5];
	g = ctx->state[6];
	h = ctx->state[7];

	for (i = 0; i < 64; ++i) {
		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
		t2 = EP0(a) + MAJ(a,b,c);
		h = g;
		g = f;
		f = e;
		e = d + t1;
		d = c;
		c = b;
		b = a;
		a = t1 + t2;
	}

	ctx->state[0] += a;
	ctx->state[1] += b;
	ctx->state[2] += c;
	ctx->state[3] += d;
	ctx->state[4] += e;
	ctx->state[5] += f;
	ctx->state[6] += g;
	ctx->state[7] += h;
}",1,9,sha256.c,sha256_transform,,false,44,88,sha256_transform,,,3,"void sha256_transform (SHA256_CTX*,BYTE[])"
408154,METHOD,sha256.c:<global>,TYPE_DECL,"void sha256_init(SHA256_CTX *ctx)
{
	ctx->datalen = 0;
	ctx->bitlen = 0;
	ctx->state[0] = 0x6a09e667;
	ctx->state[1] = 0xbb67ae85;
	ctx->state[2] = 0x3c6ef372;
	ctx->state[3] = 0xa54ff53a;
	ctx->state[4] = 0x510e527f;
	ctx->state[5] = 0x9b05688c;
	ctx->state[6] = 0x1f83d9ab;
	ctx->state[7] = 0x5be0cd19;
}",1,1,sha256.c,sha256_init,,false,90,102,sha256_init,,,4,void sha256_init (SHA256_CTX*)
408225,METHOD,sha256.c:<global>,TYPE_DECL,"void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
{
	WORD i;

	for (i = 0; i < len; ++i) {
		ctx->data[ctx->datalen] = data[i];
		ctx->datalen++;
		if (ctx->datalen == 64) {
			sha256_transform(ctx, ctx->data);
			ctx->bitlen += 512;
			ctx->datalen = 0;
		}
	}
}",1,1,sha256.c,sha256_update,,false,104,117,sha256_update,,,5,"void sha256_update (SHA256_CTX*,BYTE[],size_t)"
408281,METHOD,sha256.c:<global>,TYPE_DECL,"void sha256_final(SHA256_CTX *ctx, BYTE hash[])
{
	WORD i;

	i = ctx->datalen;

	// Pad whatever data is left in the buffer.
	if (ctx->datalen < 56) {
		ctx->data[i++] = 0x80;
		while (i < 56)
			ctx->data[i++] = 0x00;
	}
	else {
		ctx->data[i++] = 0x80;
		while (i < 64)
			ctx->data[i++] = 0x00;
		sha256_transform(ctx, ctx->data);
		memset(ctx->data, 0, 56);
	}

	// Append to the padding the total message's length in bits and transform.
	ctx->bitlen += ctx->datalen * 8;
	ctx->data[63] = ctx->bitlen;
	ctx->data[62] = ctx->bitlen >> 8;
	ctx->data[61] = ctx->bitlen >> 16;
	ctx->data[60] = ctx->bitlen >> 24;
	ctx->data[59] = ctx->bitlen >> 32;
	ctx->data[58] = ctx->bitlen >> 40;
	ctx->data[57] = ctx->bitlen >> 48;
	ctx->data[56] = ctx->bitlen >> 56;
	sha256_transform(ctx, ctx->data);

	// Since this implementation uses little endian byte ordering and SHA uses big endian,
	// reverse all the bytes when copying the final state to the output hash.
	for (i = 0; i < 4; ++i) {
		hash[i]     ...",1,1,sha256.c,sha256_final,,false,119,163,sha256_final,,,6,"void sha256_final (SHA256_CTX*,BYTE[])"
408621,METHOD,sha256.h:<global>,TYPE_DECL,<global>,1,20,sha256.h,sha256.h:<global>,,false,1,35,<global>,,,1,
408630,METHOD,<empty>,<empty>,<empty>,1,,sha256.h,SHA256_CTX:<clinit>,,false,23,,<clinit>,,,5,
408639,METHOD,sha256.h:<global>,TYPE_DECL,void sha256_init(SHA256_CTX *ctx);,6,33,sha256.h,sha256_init,,false,31,31,sha256_init,,,5,void sha256_init (SHA256_CTX*)
408644,METHOD,sha256.h:<global>,TYPE_DECL,"void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len);",6,66,sha256.h,sha256_update,,false,32,32,sha256_update,,,6,"void sha256_update (SHA256_CTX*,BYTE[],size_t)"
408651,METHOD,sha256.h:<global>,TYPE_DECL,"void sha256_final(SHA256_CTX *ctx, BYTE hash[]);",6,47,sha256.h,sha256_final,,false,33,33,sha256_final,,,7,"void sha256_final (SHA256_CTX*,BYTE[])"
408670,METHOD,siphash.c:<global>,TYPE_DECL,<global>,1,1,siphash.c,siphash.c:<global>,,false,1,373,<global>,,,1,
408672,METHOD,siphash.c:<global>,TYPE_DECL,"int siptlw(int c) {
    if (c >= 'A' && c <= 'Z') {
        return c+('a'-'A');
    } else {
        return c;
    }
}",1,1,siphash.c,siptlw,,false,50,56,siptlw,,,1,int siptlw (int)
408696,METHOD,siphash.c:<global>,TYPE_DECL,"uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out = (uint8_t*) &hash;
#endif
    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;
    uint64_t k0 = U8TO64_LE(k);
    uint64_t k1 = U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
    const int left = inlen & 7;
    uint64_t b = ((uint64_t)inlen) << 56;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 8) {
        m = U8TO64_LE(in);
        v3 ^= m;

        SIPROUND;

        v0 ^= m;
    }

    switch (left) {
    case 7: b |= ((uint64_t)in[6]) << 48; /* fall-thru */
    case 6: b |= ((uint64_t)in[5]) << 40; /* fall-thru */
    case 5: b |= ((uint64_t)in[4]) << 32; /* fall-thru */
    case 4: b |= ((uint64_t)in[3]) << 24; /* fall-thru */
    case 3: b |...",1,18,siphash.c,siphash,,false,127,184,siphash,,,2,"uint64_t siphash (uint8_t*,size_t,uint8_t*)"
409565,METHOD,siphash.c:<global>,TYPE_DECL,"uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)
{
#ifndef UNALIGNED_LE_CPU
    uint64_t hash;
    uint8_t *out = (uint8_t*) &hash;
#endif
    uint64_t v0 = 0x736f6d6570736575ULL;
    uint64_t v1 = 0x646f72616e646f6dULL;
    uint64_t v2 = 0x6c7967656e657261ULL;
    uint64_t v3 = 0x7465646279746573ULL;
    uint64_t k0 = U8TO64_LE(k);
    uint64_t k1 = U8TO64_LE(k + 8);
    uint64_t m;
    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
    const int left = inlen & 7;
    uint64_t b = ((uint64_t)inlen) << 56;
    v3 ^= k1;
    v2 ^= k0;
    v1 ^= k1;
    v0 ^= k0;

    for (; in != end; in += 8) {
        m = U8TO64_LE_NOCASE(in);
        v3 ^= m;

        SIPROUND;

        v0 ^= m;
    }

    switch (left) {
    case 7: b |= ((uint64_t)siptlw(in[6])) << 48; /* fall-thru */
    case 6: b |= ((uint64_t)siptlw(in[5])) << 40; /* fall-thru */
    case 5: b |= ((uint64_t)siptlw(in[4])) << 32; /* fall-thru */
    case 4: b |= ((uint64_t)siptlw(...",1,18,siphash.c,siphash_nocase,,false,187,245,siphash_nocase,,,3,"uint64_t siphash_nocase (uint8_t*,size_t,uint8_t*)"
410456,METHOD,slowlog.c:<global>,TYPE_DECL,<global>,1,1,slowlog.c,slowlog.c:<global>,,false,1,206,<global>,,,1,
410458,METHOD,slowlog.c:<global>,TYPE_DECL,"slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {
    slowlogEntry *se = zmalloc(sizeof(*se));
    int j, slargc = argc;

    if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;
    se->argc = slargc;
    se->argv = zmalloc(sizeof(robj*)*slargc);
    for (j = 0; j < slargc; j++) {
        /* Logging too many arguments is a useless memory waste, so we stop
         * at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify
         * how many remaining arguments there were in the original command. */
        if (slargc != argc && j == slargc-1) {
            se->argv[j] = createObject(OBJ_STRING,
                sdscatprintf(sdsempty(),""... (%d more arguments)"",
                argc-slargc+1));
        } else {
            /* Trim too long strings as well... */
            if (argv[j]->type == OBJ_STRING &&
                sdsEncodedObject(argv[j]) &&
                sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)
     ...",1,17,slowlog.c,slowlogCreateEntry,,false,48,94,slowlogCreateEntry,,,1,"slowlogEntry slowlogCreateEntry (client*,robj**,int,long long)"
410706,METHOD,slowlog.c:<global>,TYPE_DECL,"void slowlogFreeEntry(void *septr) {
    slowlogEntry *se = septr;
    int j;

    for (j = 0; j < se->argc; j++)
        decrRefCount(se->argv[j]);
    zfree(se->argv);
    sdsfree(se->peerid);
    sdsfree(se->cname);
    zfree(se);
}",1,1,slowlog.c,slowlogFreeEntry,,false,100,110,slowlogFreeEntry,,,2,void slowlogFreeEntry (void*)
410748,METHOD,slowlog.c:<global>,TYPE_DECL,"void slowlogInit(void) {
    server.slowlog = listCreate();
    server.slowlog_entry_id = 0;
    listSetFreeMethod(server.slowlog,slowlogFreeEntry);
}",1,4,slowlog.c,slowlogInit,,false,114,118,slowlogInit,,,3,void slowlogInit (void)
410776,METHOD,slowlog.c:<global>,TYPE_DECL,"void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {
    if (server.slowlog_log_slower_than < 0) return; /* Slowlog disabled */
    if (duration >= server.slowlog_log_slower_than)
        listAddNodeHead(server.slowlog,
                        slowlogCreateEntry(c,argv,argc,duration));

    /* Remove old entries if needed. */
    while (listLength(server.slowlog) > server.slowlog_max_len)
        listDelNode(server.slowlog,listLast(server.slowlog));
}",1,11,slowlog.c,slowlogPushEntryIfNeeded,,false,123,132,slowlogPushEntryIfNeeded,,,4,"void slowlogPushEntryIfNeeded (client*,robj**,int,long long)"
410837,METHOD,slowlog.c:<global>,TYPE_DECL,"void slowlogReset(void) {
    while (listLength(server.slowlog) > 0)
        listDelNode(server.slowlog,listLast(server.slowlog));
}",1,11,slowlog.c,slowlogReset,,false,135,138,slowlogReset,,,5,void slowlogReset (void)
410869,METHOD,slowlog.c:<global>,TYPE_DECL,"void slowlogCommand(client *c) {
    if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""help"")) {
        const char *help[] = {
""GET [<count>]"",
""    Return top <count> entries from the slowlog (default: 10, -1 mean all)."",
""    Entries are made of:"",
""    id, timestamp, time in microseconds, arguments array, client IP and port,"",
""    client name"",
""LEN"",
""    Return the length of the slowlog."",
""RESET"",
""    Reset the slowlog."",
NULL
        };
        addReplyHelp(c, help);
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""reset"")) {
        slowlogReset();
        addReply(c,shared.ok);
    } else if (c->argc == 2 && !strcasecmp(c->argv[1]->ptr,""len"")) {
        addReplyLongLong(c,listLength(server.slowlog));
    } else if ((c->argc == 2 || c->argc == 3) &&
               !strcasecmp(c->argv[1]->ptr,""get""))
    {
        long count = 10;
        listIter li;
        listNode *ln;
        slowlogEntry *se;

        if (c->argc == 3) {
            /* Consume count arg. */...",1,27,slowlog.c,slowlogCommand,,false,142,206,slowlogCommand,,,6,void slowlogCommand (client*)
411164,METHOD,slowlog.h:<global>,TYPE_DECL,<global>,1,26,slowlog.h,slowlog.h:<global>,,false,1,51,<global>,,,1,
411175,METHOD,slowlog.h:<global>,TYPE_DECL,void slowlogInit(void);,6,22,slowlog.h,slowlogInit,,false,48,48,slowlogInit,,,3,void slowlogInit (void)
411180,METHOD,slowlog.h:<global>,TYPE_DECL,"void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration);",6,83,slowlog.h,slowlogPushEntryIfNeeded,,false,49,49,slowlogPushEntryIfNeeded,,,4,"void slowlogPushEntryIfNeeded (client*,robj**,int,long long)"
411195,METHOD,socket.c:<global>,TYPE_DECL,<global>,1,1,socket.c,socket.c:<global>,,false,1,471,<global>,,,1,
411198,METHOD,socket.c:<global>,TYPE_DECL,"static connection *connCreateSocket(void) {
    connection *conn = zcalloc(sizeof(connection));
    conn->type = &CT_Socket;
    conn->fd = -1;
    conn->iovcnt = IOV_MAX;

    return conn;
}",1,1,socket.c,connCreateSocket,,false,77,84,connCreateSocket,,,2,connection connCreateSocket (void)
411228,METHOD,socket.c:<global>,TYPE_DECL,"static connection *connCreateAcceptedSocket(int fd, void *priv) {
    UNUSED(priv);
    connection *conn = connCreateSocket();
    conn->fd = fd;
    conn->state = CONN_STATE_ACCEPTING;
    return conn;
}",1,4,socket.c,connCreateAcceptedSocket,,false,96,102,connCreateAcceptedSocket,,,3,"connection connCreateAcceptedSocket (int,void*)"
411256,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketConnect(connection *conn, const char *addr, int port, const char *src_addr,
        ConnectionCallbackFunc connect_handler) {
    int fd = anetTcpNonBlockBestEffortBindConnect(NULL,addr,port,src_addr);
    if (fd == -1) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = errno;
        return C_ERR;
    }

    conn->fd = fd;
    conn->state = CONN_STATE_CONNECTING;

    conn->conn_handler = connect_handler;
    aeCreateFileEvent(server.el, conn->fd, AE_WRITABLE,
            conn->type->ae_handler, conn);

    return C_OK;
}",1,15,socket.c,connSocketConnect,,false,104,121,connSocketConnect,,,4,"int connSocketConnect (connection*,char*,int,char*,ConnectionCallbackFunc)"
411329,METHOD,socket.c:<global>,TYPE_DECL,"static void connSocketShutdown(connection *conn) {
    if (conn->fd == -1) return;

    shutdown(conn->fd, SHUT_RDWR);
}",1,1,socket.c,connSocketShutdown,,false,129,133,connSocketShutdown,,,5,void connSocketShutdown (connection*)
411348,METHOD,socket.c:<global>,TYPE_DECL,"static void connSocketClose(connection *conn) {
    if (conn->fd != -1) {
        aeDeleteFileEvent(server.el,conn->fd, AE_READABLE | AE_WRITABLE);
        close(conn->fd);
        conn->fd = -1;
    }

    /* If called from within a handler, schedule the close but
     * keep the connection until the handler returns.
     */
    if (connHasRefs(conn)) {
        conn->flags |= CONN_FLAG_CLOSE_SCHEDULED;
        return;
    }

    zfree(conn);
}",1,46,socket.c,connSocketClose,,false,136,152,connSocketClose,,,6,void connSocketClose (connection*)
411401,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketWrite(connection *conn, const void *data, size_t data_len) {
    int ret = write(conn->fd, data, data_len);
    if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",1,1,socket.c,connSocketWrite,,false,154,167,connSocketWrite,,,7,"int connSocketWrite (connection*,void*,size_t)"
411449,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    int ret = writev(conn->fd, iov, iovcnt);
    if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",1,1,socket.c,connSocketWritev,,false,169,182,connSocketWritev,,,8,"int connSocketWritev (connection*,iovec*,int)"
411497,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketRead(connection *conn, void *buf, size_t buf_len) {
    int ret = read(conn->fd, buf, buf_len);
    if (!ret) {
        conn->state = CONN_STATE_CLOSED;
    } else if (ret < 0 && errno != EAGAIN) {
        conn->last_errno = errno;

        /* Don't overwrite the state of a connection that is not already
         * connected, not to mess with handler callbacks.
         */
        if (errno != EINTR && conn->state == CONN_STATE_CONNECTED)
            conn->state = CONN_STATE_ERROR;
    }

    return ret;
}",1,1,socket.c,connSocketRead,,false,184,199,connSocketRead,,,9,"int connSocketRead (connection*,void*,size_t)"
411556,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    int ret = C_OK;

    if (conn->state != CONN_STATE_ACCEPTING) return C_ERR;
    conn->state = CONN_STATE_CONNECTED;

    connIncrRefs(conn);
    if (!callHandler(conn, accept_handler)) ret = C_ERR;
    connDecrRefs(conn);

    return ret;
}",1,14,socket.c,connSocketAccept,,false,201,212,connSocketAccept,,,10,"int connSocketAccept (connection*,ConnectionCallbackFunc)"
411603,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {
    if (func == conn->write_handler) return C_OK;

    conn->write_handler = func;
    if (barrier)
        conn->flags |= CONN_FLAG_WRITE_BARRIER;
    else
        conn->flags &= ~CONN_FLAG_WRITE_BARRIER;
    if (!conn->write_handler)
        aeDeleteFileEvent(server.el,conn->fd,AE_WRITABLE);
    else
        if (aeCreateFileEvent(server.el,conn->fd,AE_WRITABLE,
                    conn->type->ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
}",1,44,socket.c,connSocketSetWriteHandler,,false,222,236,connSocketSetWriteHandler,,,11,"int connSocketSetWriteHandler (connection*,ConnectionCallbackFunc,int)"
411700,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    if (func == conn->read_handler) return C_OK;

    conn->read_handler = func;
    if (!conn->read_handler)
        aeDeleteFileEvent(server.el,conn->fd,AE_READABLE);
    else
        if (aeCreateFileEvent(server.el,conn->fd,
                    AE_READABLE,conn->type->ae_handler,conn) == AE_ERR) return C_ERR;
    return C_OK;
}",1,43,socket.c,connSocketSetReadHandler,,false,241,251,connSocketSetReadHandler,,,12,"int connSocketSetReadHandler (connection*,ConnectionCallbackFunc)"
411772,METHOD,socket.c:<global>,TYPE_DECL,"static const char *connSocketGetLastError(connection *conn) {
    return strerror(conn->last_errno);
}",1,1,socket.c,connSocketGetLastError,,false,253,255,connSocketGetLastError,,,13,const char* connSocketGetLastError (connection*)
411782,METHOD,socket.c:<global>,TYPE_DECL,"static void connSocketEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask)
{
    UNUSED(el);
    UNUSED(fd);
    connection *conn = clientData;

    if (conn->state == CONN_STATE_CONNECTING &&
            (mask & AE_WRITABLE) && conn->conn_handler) {

        int conn_error = anetGetError(conn->fd);
        if (conn_error) {
            conn->last_errno = conn_error;
            conn->state = CONN_STATE_ERROR;
        } else {
            conn->state = CONN_STATE_CONNECTED;
        }

        if (!conn->write_handler) aeDeleteFileEvent(server.el,conn->fd,AE_WRITABLE);

        if (!callHandler(conn, conn->conn_handler)) return;
        conn->conn_handler = NULL;
    }

    /* Normally we execute the readable event first, and the writable
     * event later. This is useful as sometimes we may be able
     * to serve the reply of a query immediately after processing the
     * query.
     *
     * However if WRITE_BARRIER is set in the mask, our application is
    ...",1,4,socket.c,connSocketEventHandler,,false,257,309,connSocketEventHandler,,,14,"void connSocketEventHandler (aeEventLoop*,int,void*,int)"
411957,METHOD,socket.c:<global>,TYPE_DECL,"static void connSocketAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
    char cip[NET_IP_STR_LEN];
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) {
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    ""Accepting client connection: %s"", server.neterr);
            return;
        }
        serverLog(LL_VERBOSE,""Accepted %s:%d"", cip, cport);
        acceptCommonHandler(connCreateAcceptedSocket(cfd, NULL),0,cip);
    }
}",1,26,socket.c,connSocketAcceptHandler,,false,311,329,connSocketAcceptHandler,,,15,"void connSocketAcceptHandler (aeEventLoop*,int,void*,int)"
412069,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    if (anetFdToString(conn->fd, ip, ip_len, port, remote) == 0)
        return C_OK;

    conn->last_errno = errno;
    return C_ERR;
}",1,15,socket.c,connSocketAddr,,false,331,337,connSocketAddr,,,16,"int connSocketAddr (connection*,char*,size_t,int*,int)"
412104,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketIsLocal(connection *conn) {
    char cip[NET_IP_STR_LEN + 1] = { 0 };

    if (connSocketAddr(conn, cip, sizeof(cip) - 1, NULL, 1) == C_ERR)
        return -1;

    return !strncmp(cip, ""127."", 4) || !strcmp(cip, ""::1"");
}",1,13,socket.c,connSocketIsLocal,,false,339,346,connSocketIsLocal,,,17,int connSocketIsLocal (connection*)
412144,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketListen(connListener *listener) {
    return listenToPort(listener);
}",1,1,socket.c,connSocketListen,,false,348,350,connSocketListen,,,18,int connSocketListen (connListener*)
412152,METHOD,socket.c:<global>,TYPE_DECL,"static int connSocketBlockingConnect(connection *conn, const char *addr, int port, long long timeout) {
    int fd = anetTcpNonBlockConnect(NULL,addr,port);
    if (fd == -1) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = errno;
        return C_ERR;
    }

    if ((aeWait(fd, AE_WRITABLE, timeout) & AE_WRITABLE) == 0) {
        conn->state = CONN_STATE_ERROR;
        conn->last_errno = ETIMEDOUT;
    }

    conn->fd = fd;
    conn->state = CONN_STATE_CONNECTED;
    return C_OK;
}",1,15,socket.c,connSocketBlockingConnect,,false,352,368,connSocketBlockingConnect,,,19,"int connSocketBlockingConnect (connection*,char*,int,long long)"
412226,METHOD,socket.c:<global>,TYPE_DECL,"static ssize_t connSocketSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncWrite(conn->fd, ptr, size, timeout);
}",1,1,socket.c,connSocketSyncWrite,,false,374,376,connSocketSyncWrite,,,20,"ssize_t connSocketSyncWrite (connection*,char*,ssize_t,long long)"
412242,METHOD,socket.c:<global>,TYPE_DECL,"static ssize_t connSocketSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncRead(conn->fd, ptr, size, timeout);
}",1,1,socket.c,connSocketSyncRead,,false,378,380,connSocketSyncRead,,,21,"ssize_t connSocketSyncRead (connection*,char*,ssize_t,long long)"
412258,METHOD,socket.c:<global>,TYPE_DECL,"static ssize_t connSocketSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncReadLine(conn->fd, ptr, size, timeout);
}",1,1,socket.c,connSocketSyncReadLine,,false,382,384,connSocketSyncReadLine,,,22,"ssize_t connSocketSyncReadLine (connection*,char*,ssize_t,long long)"
412274,METHOD,socket.c:<global>,TYPE_DECL,"static const char *connSocketGetType(connection *conn) {
    (void) conn;

    return CONN_TYPE_SOCKET;
}",1,11,socket.c,connSocketGetType,,false,386,390,connSocketGetType,,,23,const char* connSocketGetType (connection*)
412398,METHOD,socket.c:<global>,TYPE_DECL,"int connBlock(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetBlock(NULL, conn->fd);
}",1,31,socket.c,connBlock,,false,435,438,connBlock,,,26,int connBlock (connection*)
412422,METHOD,socket.c:<global>,TYPE_DECL,"int connNonBlock(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetNonBlock(NULL, conn->fd);
}",1,31,socket.c,connNonBlock,,false,440,443,connNonBlock,,,27,int connNonBlock (connection*)
412446,METHOD,socket.c:<global>,TYPE_DECL,"int connEnableTcpNoDelay(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetEnableTcpNoDelay(NULL, conn->fd);
}",1,31,socket.c,connEnableTcpNoDelay,,false,445,448,connEnableTcpNoDelay,,,28,int connEnableTcpNoDelay (connection*)
412470,METHOD,socket.c:<global>,TYPE_DECL,"int connDisableTcpNoDelay(connection *conn) {
    if (conn->fd == -1) return C_ERR;
    return anetDisableTcpNoDelay(NULL, conn->fd);
}",1,31,socket.c,connDisableTcpNoDelay,,false,450,453,connDisableTcpNoDelay,,,29,int connDisableTcpNoDelay (connection*)
412494,METHOD,socket.c:<global>,TYPE_DECL,"int connKeepAlive(connection *conn, int interval) {
    if (conn->fd == -1) return C_ERR;
    return anetKeepAlive(NULL, conn->fd, interval);
}",1,31,socket.c,connKeepAlive,,false,455,458,connKeepAlive,,,30,"int connKeepAlive (connection*,int)"
412520,METHOD,socket.c:<global>,TYPE_DECL,"int connSendTimeout(connection *conn, long long ms) {
    return anetSendTimeout(NULL, conn->fd, ms);
}",1,1,socket.c,connSendTimeout,,false,460,462,connSendTimeout,,,31,"int connSendTimeout (connection*,long long)"
412533,METHOD,socket.c:<global>,TYPE_DECL,"int connRecvTimeout(connection *conn, long long ms) {
    return anetRecvTimeout(NULL, conn->fd, ms);
}",1,1,socket.c,connRecvTimeout,,false,464,466,connRecvTimeout,,,32,"int connRecvTimeout (connection*,long long)"
412546,METHOD,socket.c:<global>,TYPE_DECL,"int RedisRegisterConnectionTypeSocket(void)
{
    return connTypeRegister(&CT_Socket);
}",1,1,socket.c,RedisRegisterConnectionTypeSocket,,false,468,471,RedisRegisterConnectionTypeSocket,,,33,int RedisRegisterConnectionTypeSocket (void)
412560,METHOD,solarisfixes.h:<global>,TYPE_DECL,<global>,1,18,solarisfixes.h,solarisfixes.h:<global>,,false,1,54,<global>,,,1,
412571,METHOD,sort.c:<global>,TYPE_DECL,<global>,1,1,sort.c,sort.c:<global>,,false,1,619,<global>,,,1,
412573,METHOD,sort.c:<global>,TYPE_DECL,"zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);",14,70,sort.c,zslGetElementByRank,,false,36,36,zslGetElementByRank,,,1,"zskiplistNode* zslGetElementByRank (zskiplist*,long unsigned)"
412579,METHOD,sort.c:<global>,TYPE_DECL,"redisSortOperation *createSortOperation(int type, robj *pattern) {
    redisSortOperation *so = zmalloc(sizeof(*so));
    so->type = type;
    so->pattern = pattern;
    return so;
}",1,1,sort.c,createSortOperation,,false,38,43,createSortOperation,,,2,"redisSortOperation createSortOperation (int,robj*)"
412604,METHOD,sort.c:<global>,TYPE_DECL,"robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {
    char *p, *f, *k;
    sds spat, ssub;
    robj *keyobj, *fieldobj = NULL, *o;
    int prefixlen, sublen, postfixlen, fieldlen;

    /* If the pattern is ""#"" return the substitution object itself in order
     * to implement the ""SORT ... GET #"" feature. */
    spat = pattern->ptr;
    if (spat[0] == '#' && spat[1] == '\0') {
        incrRefCount(subst);
        return subst;
    }

    /* The substitution object may be specially encoded. If so we create
     * a decoded object on the fly. Otherwise getDecodedObject will just
     * increment the ref count, that we'll decrement later. */
    subst = getDecodedObject(subst);
    ssub = subst->ptr;

    /* If we can't find '*' in the pattern we return NULL as to GET a
     * fixed key does not make sense. */
    p = strchr(spat,'*');
    if (!p) {
        decrRefCount(subst);
        return NULL;
    }

    /* Find out if we're dealing with a hash dereference. */
  ...",1,23,sort.c,lookupKeyByPattern,,false,61,133,lookupKeyByPattern,,,3,"robj lookupKeyByPattern (redisDb*,robj*,robj*)"
412834,METHOD,sort.c:<global>,TYPE_DECL,"int sortCompare(const void *s1, const void *s2) {
    const redisSortObject *so1 = s1, *so2 = s2;
    int cmp;

    if (!server.sort_alpha) {
        /* Numeric sorting. Here it's trivial as we precomputed scores */
        if (so1->u.score > so2->u.score) {
            cmp = 1;
        } else if (so1->u.score < so2->u.score) {
            cmp = -1;
        } else {
            /* Objects have the same score, but we don't want the comparison
             * to be undefined, so we compare objects lexicographically.
             * This way the result of SORT is deterministic. */
            cmp = compareStringObjects(so1->obj,so2->obj);
        }
    } else {
        /* Alphanumeric sorting */
        if (server.sort_bypattern) {
            if (!so1->u.cmpobj || !so2->u.cmpobj) {
                /* At least one compare object is NULL */
                if (so1->u.cmpobj == so2->u.cmpobj)
                    cmp = 0;
                else if (so1->u.cmpobj == NULL)
                    c...",1,1,sort.c,sortCompare,,false,138,185,sortCompare,,,4,"int sortCompare (void*,void*)"
413033,METHOD,sort.c:<global>,TYPE_DECL,"void sortCommandGeneric(client *c, int readonly) {
    list *operations;
    unsigned int outputlen = 0;
    int desc = 0, alpha = 0;
    long limit_start = 0, limit_count = -1, start, end;
    int j, dontsort = 0, vectorlen;
    int getop = 0; /* GET operation counter */
    int int_conversion_error = 0;
    int syntax_error = 0;
    robj *sortval, *sortby = NULL, *storekey = NULL;
    redisSortObject *vector; /* Resulting vector to sort */
    int user_has_full_key_access = 0; /* ACL - used in order to verify 'get' and 'by' options can be used */
    /* Create a list of operations to perform for every sorted element.
     * Operations can be GET */
    operations = listCreate();
    listSetFreeMethod(operations,zfree);
    j = 2; /* options start at argv[2] */

    user_has_full_key_access = ACLUserCheckCmdWithUnrestrictedKeyAccess(c->user, c->cmd, c->argv, c->argc, CMD_KEY_ACCESS);

    /* The SORT command has an SQL-alike syntax, parse it */
    while(j < c->argc) {
        int ...",1,4,sort.c,sortCommandGeneric,,false,189,610,sortCommandGeneric,,,5,"void sortCommandGeneric (client*,int)"
414818,METHOD,sort.c:<global>,TYPE_DECL,"void sortroCommand(client *c) {
    sortCommandGeneric(c, 1);
}",1,1,sort.c,sortroCommand,,false,613,615,sortroCommand,,,6,void sortroCommand (client*)
414826,METHOD,sort.c:<global>,TYPE_DECL,"void sortCommand(client *c) {
    sortCommandGeneric(c, 0);
}",1,1,sort.c,sortCommand,,false,617,619,sortCommand,,,7,void sortCommand (client*)
414841,METHOD,sparkline.c:<global>,TYPE_DECL,<global>,1,1,sparkline.c,sparkline.c:<global>,,false,1,178,<global>,,,1,
414862,METHOD,sparkline.c:<global>,TYPE_DECL,"struct sequence *createSparklineSequence(void) {
    struct sequence *seq = zmalloc(sizeof(*seq));
    seq->length = 0;
    seq->labels = 0;
    seq->samples = NULL;
    seq->min = 0.0f;
    seq->max = 0.0f;
    return seq;
}",1,1,sparkline.c,createSparklineSequence,,false,57,65,createSparklineSequence,,,9,struct sequence createSparklineSequence (void)
414901,METHOD,sparkline.c:<global>,TYPE_DECL,"void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {
    label = (label == NULL || label[0] == '\0') ? NULL : zstrdup(label);
    if (seq->length == 0) {
        seq->min = seq->max = value;
    } else {
        if (value < seq->min) seq->min = value;
        else if (value > seq->max) seq->max = value;
    }
    seq->samples = zrealloc(seq->samples,sizeof(struct sample)*(seq->length+1));
    seq->samples[seq->length].value = value;
    seq->samples[seq->length].label = label;
    seq->length++;
    if (label) seq->labels++;
}",1,1,sparkline.c,sparklineSequenceAddSample,,false,68,81,sparklineSequenceAddSample,,,10,"void sparklineSequenceAddSample (sequence*,double,char*)"
415016,METHOD,sparkline.c:<global>,TYPE_DECL,"void freeSparklineSequence(struct sequence *seq) {
    int j;

    for (j = 0; j < seq->length; j++)
        zfree(seq->samples[j].label);
    zfree(seq->samples);
    zfree(seq);
}",1,1,sparkline.c,freeSparklineSequence,,false,84,91,freeSparklineSequence,,,11,void freeSparklineSequence (sequence*)
415048,METHOD,sparkline.c:<global>,TYPE_DECL,"sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {
    int j;
    double relmax = seq->max - seq->min;
    int steps = charset_len*rows;
    int row = 0;
    char *chars = zmalloc(len);
    int loop = 1;
    int opt_fill = flags & SPARKLINE_FILL;
    int opt_log = flags & SPARKLINE_LOG_SCALE;

    if (opt_log) {
        relmax = log(relmax+1);
    } else if (relmax == 0) {
        relmax = 1;
    }

    while(loop) {
        loop = 0;
        memset(chars,' ',len);
        for (j = 0; j < len; j++) {
            struct sample *s = &seq->samples[j+offset];
            double relval = s->value - seq->min;
            int step;

            if (opt_log) relval = log(relval+1);
            step = (int) (relval*steps)/relmax;
            if (step < 0) step = 0;
            if (step >= steps) step = steps-1;

            if (row < rows) {
                /* Print the character needed to create the sparkline */
                int charidx...",1,27,sparkline.c,sparklineRenderRange,,false,100,165,sparklineRenderRange,,,12,"sds sparklineRenderRange (sds,sequence*,int,int,int,int)"
415332,METHOD,sparkline.c:<global>,TYPE_DECL,"sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {
    int j;

    for (j = 0; j < seq->length; j += columns) {
        int sublen = (seq->length-j) < columns ? (seq->length-j) : columns;

        if (j != 0) output = sdscatlen(output,""\n"",1);
        output = sparklineRenderRange(output, seq, rows, j, sublen, flags);
    }
    return output;
}",1,1,sparkline.c,sparklineRender,,false,168,178,sparklineRender,,,13,"sds sparklineRender (sds,sequence*,int,int,int)"
415398,METHOD,sparkline.h:<global>,TYPE_DECL,<global>,1,26,sparkline.h,sparkline.h:<global>,,false,1,56,<global>,,,1,
415412,METHOD,sparkline.h:<global>,TYPE_DECL,"void sparklineSequenceAddSample(struct sequence *seq, double value, char *label);",6,80,sparkline.h,sparklineSequenceAddSample,,false,51,51,sparklineSequenceAddSample,,,5,"void sparklineSequenceAddSample (sequence*,double,char*)"
415419,METHOD,sparkline.h:<global>,TYPE_DECL,void freeSparklineSequence(struct sequence *seq);,6,48,sparkline.h,freeSparklineSequence,,false,52,52,freeSparklineSequence,,,6,void freeSparklineSequence (sequence*)
415424,METHOD,sparkline.h:<global>,TYPE_DECL,"sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags);",5,100,sparkline.h,sparklineRenderRange,,false,53,53,sparklineRenderRange,,,7,"sds sparklineRenderRange (sds,sequence*,int,int,int,int)"
415434,METHOD,sparkline.h:<global>,TYPE_DECL,"sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags);",5,87,sparkline.h,sparklineRender,,false,54,54,sparklineRender,,,8,"sds sparklineRender (sds,sequence*,int,int,int)"
415450,METHOD,stream.h:<global>,TYPE_DECL,<global>,1,1,stream.h,stream.h:<global>,,false,1,147,<global>,,,1,
415482,METHOD,<empty>,<empty>,<empty>,1,,stream.h,streamIterator:<clinit>,,false,32,,<clinit>,,,17,
415521,METHOD,stream.h:<global>,TYPE_DECL,stream *streamNew(void);,8,23,stream.h,streamNew,,false,116,116,streamNew,,,16,stream* streamNew (void)
415526,METHOD,stream.h:<global>,TYPE_DECL,void freeStream(stream *s);,6,26,stream.h,freeStream,,false,117,117,freeStream,,,17,void freeStream (stream*)
415531,METHOD,stream.h:<global>,TYPE_DECL,unsigned long streamLength(const robj *subject);,15,47,stream.h,streamLength,,false,118,118,streamLength,,,18,long unsigned streamLength (robj*)
415536,METHOD,stream.h:<global>,TYPE_DECL,"size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi);",8,179,stream.h,streamReplyWithRange,,false,119,119,streamReplyWithRange,,,19,"size_t streamReplyWithRange (client*,stream*,streamID*,streamID*,size_t,int,streamCG*,streamConsumer*,int,streamPropInfo*)"
415550,METHOD,stream.h:<global>,TYPE_DECL,"void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev);",6,96,stream.h,streamIteratorStart,,false,120,120,streamIteratorStart,,,20,"void streamIteratorStart (streamIterator*,stream*,streamID*,streamID*,int)"
415559,METHOD,stream.h:<global>,TYPE_DECL,"int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields);",5,77,stream.h,streamIteratorGetID,,false,121,121,streamIteratorGetID,,,21,"int streamIteratorGetID (streamIterator*,streamID*,int64_t*)"
415566,METHOD,stream.h:<global>,TYPE_DECL,"void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen);",6,137,stream.h,streamIteratorGetField,,false,122,122,streamIteratorGetField,,,22,"void streamIteratorGetField (streamIterator*,unsigned char**,unsigned char**,int64_t*,int64_t*)"
415575,METHOD,stream.h:<global>,TYPE_DECL,"void streamIteratorRemoveEntry(streamIterator *si, streamID *current);",6,69,stream.h,streamIteratorRemoveEntry,,false,123,123,streamIteratorRemoveEntry,,,23,"void streamIteratorRemoveEntry (streamIterator*,streamID*)"
415581,METHOD,stream.h:<global>,TYPE_DECL,void streamIteratorStop(streamIterator *si);,6,43,stream.h,streamIteratorStop,,false,124,124,streamIteratorStop,,,24,void streamIteratorStop (streamIterator*)
415586,METHOD,stream.h:<global>,TYPE_DECL,"streamCG *streamLookupCG(stream *s, sds groupname);",10,50,stream.h,streamLookupCG,,false,125,125,streamLookupCG,,,25,"streamCG* streamLookupCG (stream*,sds)"
415592,METHOD,stream.h:<global>,TYPE_DECL,"streamConsumer *streamLookupConsumer(streamCG *cg, sds name);",16,60,stream.h,streamLookupConsumer,,false,126,126,streamLookupConsumer,,,26,"streamConsumer* streamLookupConsumer (streamCG*,sds)"
415598,METHOD,stream.h:<global>,TYPE_DECL,"streamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags);",16,92,stream.h,streamCreateConsumer,,false,127,127,streamCreateConsumer,,,27,"streamConsumer* streamCreateConsumer (streamCG*,sds,robj*,int,int)"
415607,METHOD,stream.h:<global>,TYPE_DECL,"streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read);",10,101,stream.h,streamCreateCG,,false,128,128,streamCreateCG,,,28,"streamCG* streamCreateCG (stream*,char*,size_t,streamID*,long long)"
415616,METHOD,stream.h:<global>,TYPE_DECL,streamNACK *streamCreateNACK(streamConsumer *consumer);,12,54,stream.h,streamCreateNACK,,false,129,129,streamCreateNACK,,,29,streamNACK* streamCreateNACK (streamConsumer*)
415621,METHOD,stream.h:<global>,TYPE_DECL,"void streamDecodeID(void *buf, streamID *id);",6,44,stream.h,streamDecodeID,,false,130,130,streamDecodeID,,,30,"void streamDecodeID (void*,streamID*)"
415627,METHOD,stream.h:<global>,TYPE_DECL,"int streamCompareID(streamID *a, streamID *b);",5,45,stream.h,streamCompareID,,false,131,131,streamCompareID,,,31,"int streamCompareID (streamID*,streamID*)"
415633,METHOD,stream.h:<global>,TYPE_DECL,void streamFreeNACK(streamNACK *na);,6,35,stream.h,streamFreeNACK,,false,132,132,streamFreeNACK,,,32,void streamFreeNACK (streamNACK*)
415638,METHOD,stream.h:<global>,TYPE_DECL,int streamIncrID(streamID *id);,5,30,stream.h,streamIncrID,,false,133,133,streamIncrID,,,33,int streamIncrID (streamID*)
415643,METHOD,stream.h:<global>,TYPE_DECL,int streamDecrID(streamID *id);,5,30,stream.h,streamDecrID,,false,134,134,streamDecrID,,,34,int streamDecrID (streamID*)
415648,METHOD,stream.h:<global>,TYPE_DECL,"void streamPropagateConsumerCreation(client *c, robj *key, robj *groupname, sds consumername);",6,93,stream.h,streamPropagateConsumerCreation,,false,135,135,streamPropagateConsumerCreation,,,35,"void streamPropagateConsumerCreation (client*,robj*,robj*,sds)"
415656,METHOD,stream.h:<global>,TYPE_DECL,robj *streamDup(robj *o);,6,24,stream.h,streamDup,,false,136,136,streamDup,,,36,robj* streamDup (robj*)
415661,METHOD,stream.h:<global>,TYPE_DECL,"int streamValidateListpackIntegrity(unsigned char *lp, size_t size, int deep);",5,77,stream.h,streamValidateListpackIntegrity,,false,137,137,streamValidateListpackIntegrity,,,37,"int streamValidateListpackIntegrity (unsigned char*,size_t,int)"
415668,METHOD,stream.h:<global>,TYPE_DECL,"int streamParseID(const robj *o, streamID *id);",5,46,stream.h,streamParseID,,false,138,138,streamParseID,,,38,"int streamParseID (robj*,streamID*)"
415674,METHOD,stream.h:<global>,TYPE_DECL,robj *createObjectFromStreamID(streamID *id);,6,44,stream.h,createObjectFromStreamID,,false,139,139,createObjectFromStreamID,,,39,robj* createObjectFromStreamID (streamID*)
415679,METHOD,stream.h:<global>,TYPE_DECL,"int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given);",5,116,stream.h,streamAppendItem,,false,140,140,streamAppendItem,,,40,"int streamAppendItem (stream*,robj**,int64_t,streamID*,streamID*,int)"
415689,METHOD,stream.h:<global>,TYPE_DECL,"int streamDeleteItem(stream *s, streamID *id);",5,45,stream.h,streamDeleteItem,,false,141,141,streamDeleteItem,,,41,"int streamDeleteItem (stream*,streamID*)"
415695,METHOD,stream.h:<global>,TYPE_DECL,"void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id);",6,82,stream.h,streamGetEdgeID,,false,142,142,streamGetEdgeID,,,42,"void streamGetEdgeID (stream*,int,int,streamID*)"
415703,METHOD,stream.h:<global>,TYPE_DECL,"long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id);",11,75,stream.h,streamEstimateDistanceFromFirstEverEntry,,false,143,143,streamEstimateDistanceFromFirstEverEntry,,,43,"long long streamEstimateDistanceFromFirstEverEntry (stream*,streamID*)"
415709,METHOD,stream.h:<global>,TYPE_DECL,"int64_t streamTrimByLength(stream *s, long long maxlen, int approx);",9,67,stream.h,streamTrimByLength,,false,144,144,streamTrimByLength,,,44,"int64_t streamTrimByLength (stream*,long long,int)"
415716,METHOD,stream.h:<global>,TYPE_DECL,"int64_t streamTrimByID(stream *s, streamID minid, int approx);",9,61,stream.h,streamTrimByID,,false,145,145,streamTrimByID,,,45,"int64_t streamTrimByID (stream*,streamID,int)"
415728,METHOD,strl.c:<global>,TYPE_DECL,<global>,1,1,strl.c,strl.c:<global>,,false,1,85,<global>,,,1,
415730,METHOD,strl.c:<global>,TYPE_DECL,"size_t
redis_strlcpy(char *dst, const char *src, size_t dsize)
{
    const char *osrc = src;
    size_t nleft = dsize;

    /* Copy as many bytes as will fit. */
    if (nleft != 0) {
        while (--nleft != 0) {
            if ((*dst++ = *src++) == '\0')
                break;
        }
    }

    /* Not enough room in dst, add NUL and traverse rest of src. */
    if (nleft == 0) {
        if (dsize != 0)
            *dst = '\0';        /* NUL-terminate dst */
        while (*src++)
            ;
    }

    return(src - osrc - 1); /* count does not include NUL */
}",1,1,strl.c,redis_strlcpy,,false,23,46,redis_strlcpy,,,1,"size_t redis_strlcpy (char*,char*,size_t)"
415792,METHOD,strl.c:<global>,TYPE_DECL,"size_t
redis_strlcat(char *dst, const char *src, size_t dsize)
{
    const char *odst = dst;
    const char *osrc = src;
    size_t n = dsize;
    size_t dlen;

    /* Find the end of dst and adjust bytes left but don't go past end. */
    while (n-- != 0 && *dst != '\0')
        dst++;
    dlen = dst - odst;
    n = dsize - dlen;

    if (n-- == 0)
        return(dlen + strlen(src));
    while (*src != '\0') {
        if (n != 0) {
            *dst++ = *src;
            n--;
        }
        src++;
    }
    *dst = '\0';

    return(dlen + (src - osrc));    /* count does not include NUL */
}",1,1,strl.c,redis_strlcat,,false,55,81,redis_strlcat,,,2,"size_t redis_strlcat (char*,char*,size_t)"
415881,METHOD,syncio.c:<global>,TYPE_DECL,<global>,1,1,syncio.c,syncio.c:<global>,,false,1,145,<global>,,,1,
415883,METHOD,syncio.c:<global>,TYPE_DECL,"ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nwritten, ret = size;
    long long start = mstime();
    long long remaining = timeout;

    while(1) {
        long long wait = (remaining > SYNCIO__RESOLUTION) ?
                          remaining : SYNCIO__RESOLUTION;
        long long elapsed;

        /* Optimistically try to write before checking if the file descriptor
         * is actually writable. At worst we get EAGAIN. */
        nwritten = write(fd,ptr,size);
        if (nwritten == -1) {
            if (errno != EAGAIN) return -1;
        } else {
            ptr += nwritten;
            size -= nwritten;
        }
        if (size == 0) return ret;

        /* Wait */
        aeWait(fd,AE_WRITABLE,wait);
        elapsed = mstime() - start;
        if (elapsed >= timeout) {
            errno = ETIMEDOUT;
            return -1;
        }
        remaining = timeout - elapsed;
    }
}",1,38,syncio.c,syncWrite,,false,49,79,syncWrite,,,1,"ssize_t syncWrite (int,char*,ssize_t,long long)"
415983,METHOD,syncio.c:<global>,TYPE_DECL,"ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nread, totread = 0;
    long long start = mstime();
    long long remaining = timeout;

    if (size == 0) return 0;
    while(1) {
        long long wait = (remaining > SYNCIO__RESOLUTION) ?
                          remaining : SYNCIO__RESOLUTION;
        long long elapsed;

        /* Optimistically try to read before checking if the file descriptor
         * is actually readable. At worst we get EAGAIN. */
        nread = read(fd,ptr,size);
        if (nread == 0) return -1; /* short read. */
        if (nread == -1) {
            if (errno != EAGAIN) return -1;
        } else {
            ptr += nread;
            size -= nread;
            totread += nread;
        }
        if (size == 0) return totread;

        /* Wait */
        aeWait(fd,AE_READABLE,wait);
        elapsed = mstime() - start;
        if (elapsed >= timeout) {
            errno = ETIMEDOUT;
            return -1;
        }
...",1,38,syncio.c,syncRead,,false,85,118,syncRead,,,2,"ssize_t syncRead (int,char*,ssize_t,long long)"
416101,METHOD,syncio.c:<global>,TYPE_DECL,"ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {
    ssize_t nread = 0;

    size--;
    while(size) {
        char c;

        if (syncRead(fd,&c,1,timeout) == -1) return -1;
        if (c == '\n') {
            *ptr = '\0';
            if (nread && *(ptr-1) == '\r') *(ptr-1) = '\0';
            return nread;
        } else {
            *ptr++ = c;
            *ptr = '\0';
            nread++;
        }
        size--;
    }
    return nread;
}",1,1,syncio.c,syncReadLine,,false,125,145,syncReadLine,,,3,"ssize_t syncReadLine (int,char*,ssize_t,long long)"
416208,METHOD,syscheck.c:<global>,TYPE_DECL,<global>,1,4,syscheck.c,syscheck.c:<global>,,false,1,375,<global>,,,1,
416212,METHOD,check,TYPE_DECL,int (*check_fn)(sds*);,9,25,syscheck.c,check.check_fn,,false,337,337,check_fn,,,2,int check.check_fn (sds*)
416231,METHOD,syscheck.c:<global>,TYPE_DECL,"int syscheck(void) {
    check *cur_check = checks;
    int ret = 1;
    sds err_msg = NULL;
    while (cur_check->check_fn) {
        int res = cur_check->check_fn(&err_msg);
        printf(""[%s]..."", cur_check->name);
        if (res == 0) {
            printf(""skipped\n"");
        } else if (res == 1) {
            printf(""OK\n"");
        } else {
            printf(""WARNING:\n"");
            printf(""%s\n"", err_msg);
            sdsfree(err_msg);
            ret = 0;
        }
        cur_check++;
    }

    return ret;
}",1,1,syscheck.c,syscheck,,false,354,375,syscheck,,,5,int syscheck (void)
416306,METHOD,syscheck.h:<global>,TYPE_DECL,<global>,1,1,syscheck.h,syscheck.h:<global>,,false,1,46,<global>,,,1,
416308,METHOD,syscheck.h:<global>,TYPE_DECL,int syscheck(void);,5,18,syscheck.h,syscheck,,false,36,36,syscheck,,,1,int syscheck (void)
416320,METHOD,t_hash.c:<global>,TYPE_DECL,<global>,1,1,t_hash.c,t_hash.c:<global>,,false,1,1163,<global>,,,1,
416322,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {
    int i;
    size_t sum = 0;

    if (o->encoding != OBJ_ENCODING_LISTPACK) return;

    /* We guess that most of the values in the input are unique, so
     * if there are enough arguments we create a pre-sized hash, which
     * might over allocate memory if there are duplicates. */
    size_t new_fields = (end - start + 1) / 2;
    if (new_fields > server.hash_max_listpack_entries) {
        hashTypeConvert(o, OBJ_ENCODING_HT);
        dictExpand(o->ptr, new_fields);
        return;
    }

    for (i = start; i <= end; i++) {
        if (!sdsEncodedObject(argv[i]))
            continue;
        size_t len = sdslen(argv[i]->ptr);
        if (len > server.hash_max_listpack_value) {
            hashTypeConvert(o, OBJ_ENCODING_HT);
            return;
        }
        sum += len;
    }
    if (!lpSafeToAdd(o->ptr, sum))
        hashTypeConvert(o, OBJ_ENCODING_HT);
}",1,23,t_hash.c,hashTypeTryConversion,,false,40,68,hashTypeTryConversion,,,1,"void hashTypeTryConversion (robj*,robj**,int,int)"
416446,METHOD,t_hash.c:<global>,TYPE_DECL,"int hashTypeGetFromListpack(robj *o, sds field,
                            unsigned char **vstr,
                            unsigned int *vlen,
                            long long *vll)
{
    unsigned char *zl, *fptr = NULL, *vptr = NULL;

    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    zl = o->ptr;
    fptr = lpFirst(zl);
    if (fptr != NULL) {
        fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
        if (fptr != NULL) {
            /* Grab pointer to the value (fptr points to the field) */
            vptr = lpNext(zl, fptr);
            serverAssert(vptr != NULL);
        }
    }

    if (vptr != NULL) {
        *vstr = lpGetValue(vptr, vlen, vll);
        return 0;
    }

    return -1;
}",1,4,t_hash.c,hashTypeGetFromListpack,,false,72,98,hashTypeGetFromListpack,,,2,"int hashTypeGetFromListpack (robj*,sds,unsigned char**,unsigned int*,long long*)"
416550,METHOD,t_hash.c:<global>,TYPE_DECL,"sds hashTypeGetFromHashTable(robj *o, sds field) {
    dictEntry *de;

    serverAssert(o->encoding == OBJ_ENCODING_HT);

    de = dictFind(o->ptr, field);
    if (de == NULL) return NULL;
    return dictGetVal(de);
}",1,4,t_hash.c,hashTypeGetFromHashTable,,false,103,111,hashTypeGetFromHashTable,,,3,"sds hashTypeGetFromHashTable (robj*,sds)"
416592,METHOD,t_hash.c:<global>,TYPE_DECL,"int hashTypeGetValue(robj *o, sds field, unsigned char **vstr, unsigned int *vlen, long long *vll) {
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        *vstr = NULL;
        if (hashTypeGetFromListpack(o, field, vstr, vlen, vll) == 0)
            return C_OK;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        sds value;
        if ((value = hashTypeGetFromHashTable(o, field)) != NULL) {
            *vstr = (unsigned char*) value;
            *vlen = sdslen(value);
            return C_OK;
        }
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return C_ERR;
}",1,23,t_hash.c,hashTypeGetValue,,false,122,138,hashTypeGetValue,,,4,"int hashTypeGetValue (robj*,sds,unsigned char**,unsigned int*,long long*)"
416679,METHOD,t_hash.c:<global>,TYPE_DECL,"robj *hashTypeGetValueObject(robj *o, sds field) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vll;

    if (hashTypeGetValue(o,field,&vstr,&vlen,&vll) == C_ERR) return NULL;
    if (vstr) return createStringObject((char*)vstr,vlen);
    else return createStringObjectFromLongLong(vll);
}",1,54,t_hash.c,hashTypeGetValueObject,,false,144,152,hashTypeGetValueObject,,,5,"robj hashTypeGetValueObject (robj*,sds)"
416720,METHOD,t_hash.c:<global>,TYPE_DECL,"size_t hashTypeGetValueLength(robj *o, sds field) {
    size_t len = 0;
    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK)
        len = vstr ? vlen : sdigits10(vll);

    return len;
}",1,58,t_hash.c,hashTypeGetValueLength,,false,157,167,hashTypeGetValueLength,,,6,"size_t hashTypeGetValueLength (robj*,sds)"
416766,METHOD,t_hash.c:<global>,TYPE_DECL,"int hashTypeExists(robj *o, sds field) {
    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    return hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK;
}",1,61,t_hash.c,hashTypeExists,,false,171,177,hashTypeExists,,,7,"int hashTypeExists (robj*,sds)"
416798,METHOD,t_hash.c:<global>,TYPE_DECL,"int hashTypeSet(robj *o, sds field, sds value, int flags) {
    int update = 0;

    /* Check if the field is too long for listpack, and convert before adding the item.
     * This is needed for HINCRBY* case since in other commands this is handled early by
     * hashTypeTryConversion, so this check will be a NOP. */
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        if (sdslen(field) > server.hash_max_listpack_value || sdslen(value) > server.hash_max_listpack_value)
            hashTypeConvert(o, OBJ_ENCODING_HT);
    }
    
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl, *fptr, *vptr;

        zl = o->ptr;
        fptr = lpFirst(zl);
        if (fptr != NULL) {
            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
            if (fptr != NULL) {
                /* Grab pointer to the value (fptr points to the field) */
                vptr = lpNext(zl, fptr);
                serverAssert(vptr != NULL);
                update...",1,23,t_hash.c,hashTypeSet,,false,200,271,hashTypeSet,,,8,"int hashTypeSet (robj*,sds,sds,int)"
417080,METHOD,t_hash.c:<global>,TYPE_DECL,"int hashTypeDelete(robj *o, sds field) {
    int deleted = 0;

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl, *fptr;

        zl = o->ptr;
        fptr = lpFirst(zl);
        if (fptr != NULL) {
            fptr = lpFind(zl, fptr, (unsigned char*)field, sdslen(field), 1);
            if (fptr != NULL) {
                /* Delete both of the key and the value. */
                zl = lpDeleteRangeWithEntry(zl,&fptr,2);
                o->ptr = zl;
                deleted = 1;
            }
        }
    } else if (o->encoding == OBJ_ENCODING_HT) {
        if (dictDelete((dict*)o->ptr, field) == C_OK) {
            deleted = 1;

            /* Always check if the dictionary needs a resize after a delete. */
            if (htNeedsResize(o->ptr)) dictResize(o->ptr);
        }

    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return deleted;
}",1,23,t_hash.c,hashTypeDelete,,false,275,304,hashTypeDelete,,,9,"int hashTypeDelete (robj*,sds)"
417195,METHOD,t_hash.c:<global>,TYPE_DECL,"unsigned long hashTypeLength(const robj *o) {
    unsigned long length = ULONG_MAX;

    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        length = lpLength(o->ptr) / 2;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        length = dictSize((const dict*)o->ptr);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return length;
}",1,23,t_hash.c,hashTypeLength,,false,307,318,hashTypeLength,,,10,unsigned long hashTypeLength (robj*)
417267,METHOD,t_hash.c:<global>,TYPE_DECL,"hashTypeIterator *hashTypeInitIterator(robj *subject) {
    hashTypeIterator *hi = zmalloc(sizeof(hashTypeIterator));
    hi->subject = subject;
    hi->encoding = subject->encoding;

    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        hi->fptr = NULL;
        hi->vptr = NULL;
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        hi->di = dictGetIterator(subject->ptr);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return hi;
}",1,24,t_hash.c,hashTypeInitIterator,,false,320,334,hashTypeInitIterator,,,11,hashTypeIterator hashTypeInitIterator (robj*)
417340,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeReleaseIterator(hashTypeIterator *hi) {
    if (hi->encoding == OBJ_ENCODING_HT)
        dictReleaseIterator(hi->di);
    zfree(hi);
}",1,24,t_hash.c,hashTypeReleaseIterator,,false,336,340,hashTypeReleaseIterator,,,12,void hashTypeReleaseIterator (hashTypeIterator*)
417360,METHOD,t_hash.c:<global>,TYPE_DECL,"int hashTypeNext(hashTypeIterator *hi) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl;
        unsigned char *fptr, *vptr;

        zl = hi->subject->ptr;
        fptr = hi->fptr;
        vptr = hi->vptr;

        if (fptr == NULL) {
            /* Initialize cursor */
            serverAssert(vptr == NULL);
            fptr = lpFirst(zl);
        } else {
            /* Advance cursor */
            serverAssert(vptr != NULL);
            fptr = lpNext(zl, vptr);
        }
        if (fptr == NULL) return C_ERR;

        /* Grab pointer to the value (fptr points to the field) */
        vptr = lpNext(zl, fptr);
        serverAssert(vptr != NULL);

        /* fptr, vptr now point to the first or next pair */
        hi->fptr = fptr;
        hi->vptr = vptr;
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        if ((hi->de = dictNext(hi->di)) == NULL) return C_ERR;
    } else {
        serverPanic(""Unknown hash encoding"");
    }
    return C_OK;
}",1,24,t_hash.c,hashTypeNext,,false,344,377,hashTypeNext,,,13,int hashTypeNext (hashTypeIterator*)
417525,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeCurrentFromListpack(hashTypeIterator *hi, int what,
                                 unsigned char **vstr,
                                 unsigned int *vlen,
                                 long long *vll)
{
    serverAssert(hi->encoding == OBJ_ENCODING_LISTPACK);

    if (what & OBJ_HASH_KEY) {
        *vstr = lpGetValue(hi->fptr, vlen, vll);
    } else {
        *vstr = lpGetValue(hi->vptr, vlen, vll);
    }
}",1,4,t_hash.c,hashTypeCurrentFromListpack,,false,381,393,hashTypeCurrentFromListpack,,,14,"void hashTypeCurrentFromListpack (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)"
417579,METHOD,t_hash.c:<global>,TYPE_DECL,"sds hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what) {
    serverAssert(hi->encoding == OBJ_ENCODING_HT);

    if (what & OBJ_HASH_KEY) {
        return dictGetKey(hi->de);
    } else {
        return dictGetVal(hi->de);
    }
}",1,4,t_hash.c,hashTypeCurrentFromHashTable,,false,398,406,hashTypeCurrentFromHashTable,,,15,"sds hashTypeCurrentFromHashTable (hashTypeIterator*,int)"
417622,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeCurrentObject(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        *vstr = NULL;
        hashTypeCurrentFromListpack(hi, what, vstr, vlen, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds ele = hashTypeCurrentFromHashTable(hi, what);
        *vstr = (unsigned char*) ele;
        *vlen = sdslen(ele);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",1,24,t_hash.c,hashTypeCurrentObject,,false,418,429,hashTypeCurrentObject,,,16,"void hashTypeCurrentObject (hashTypeIterator*,int,unsigned char**,unsigned int*,long long*)"
417688,METHOD,t_hash.c:<global>,TYPE_DECL,"sds hashTypeCurrentObjectNewSds(hashTypeIterator *hi, int what) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vll;

    hashTypeCurrentObject(hi,what,&vstr,&vlen,&vll);
    if (vstr) return sdsnewlen(vstr,vlen);
    return sdsfromlonglong(vll);
}",1,1,t_hash.c,hashTypeCurrentObjectNewSds,,false,433,441,hashTypeCurrentObjectNewSds,,,17,"sds hashTypeCurrentObjectNewSds (hashTypeIterator*,int)"
417716,METHOD,t_hash.c:<global>,TYPE_DECL,"robj *hashTypeLookupWriteOrCreate(client *c, robj *key) {
    robj *o = lookupKeyWrite(c->db,key);
    if (checkType(c,o,OBJ_HASH)) return NULL;

    if (o == NULL) {
        o = createHashObject();
        dbAdd(c->db,key,o);
    }
    return o;
}",1,22,t_hash.c,hashTypeLookupWriteOrCreate,,false,443,452,hashTypeLookupWriteOrCreate,,,18,"robj hashTypeLookupWriteOrCreate (client*,robj*)"
417756,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeConvertListpack(robj *o, int enc) {
    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    if (enc == OBJ_ENCODING_LISTPACK) {
        /* Nothing to do... */

    } else if (enc == OBJ_ENCODING_HT) {
        hashTypeIterator *hi;
        dict *dict;
        int ret;

        hi = hashTypeInitIterator(o);
        dict = dictCreate(&hashDictType);

        /* Presize the dict to avoid rehashing */
        dictExpand(dict,hashTypeLength(o));

        while (hashTypeNext(hi) != C_ERR) {
            sds key, value;

            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);
            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);
            ret = dictAdd(dict, key, value);
            if (ret != DICT_OK) {
                sdsfree(key); sdsfree(value); /* Needed for gcc ASAN */
                hashTypeReleaseIterator(hi);  /* Needed for gcc ASAN */
                serverLogHexDump(LL_WARNING,""listpack with dup elements dump"",
                    o->ptr,...",1,4,t_hash.c,hashTypeConvertListpack,,false,455,493,hashTypeConvertListpack,,,19,"void hashTypeConvertListpack (robj*,int)"
417904,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeConvert(robj *o, int enc) {
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        hashTypeConvertListpack(o, enc);
    } else if (o->encoding == OBJ_ENCODING_HT) {
        serverPanic(""Not implemented"");
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",1,23,t_hash.c,hashTypeConvert,,false,495,503,hashTypeConvert,,,20,"void hashTypeConvert (robj*,int)"
417951,METHOD,t_hash.c:<global>,TYPE_DECL,"robj *hashTypeDup(robj *o) {
    robj *hobj;
    hashTypeIterator *hi;

    serverAssert(o->type == OBJ_HASH);

    if(o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        size_t sz = lpBytes(zl);
        unsigned char *new_zl = zmalloc(sz);
        memcpy(new_zl, zl, sz);
        hobj = createObject(OBJ_HASH, new_zl);
        hobj->encoding = OBJ_ENCODING_LISTPACK;
    } else if(o->encoding == OBJ_ENCODING_HT){
        dict *d = dictCreate(&hashDictType);
        dictExpand(d, dictSize((const dict*)o->ptr));

        hi = hashTypeInitIterator(o);
        while (hashTypeNext(hi) != C_ERR) {
            sds field, value;
            sds newfield, newvalue;
            /* Extract a field-value pair from an original hash object.*/
            field = hashTypeCurrentFromHashTable(hi, OBJ_HASH_KEY);
            value = hashTypeCurrentFromHashTable(hi, OBJ_HASH_VALUE);
            newfield = sdsdup(field);
            newvalue = sdsdup(value);

            /...",1,4,t_hash.c,hashTypeDup,,false,510,548,hashTypeDup,,,21,robj hashTypeDup (robj*)
418130,METHOD,t_hash.c:<global>,TYPE_DECL,"sds hashSdsFromListpackEntry(listpackEntry *e) {
    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);
}",1,1,t_hash.c,hashSdsFromListpackEntry,,false,551,553,hashSdsFromListpackEntry,,,22,sds hashSdsFromListpackEntry (listpackEntry*)
418151,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashReplyFromListpackEntry(client *c, listpackEntry *e) {
    if (e->sval)
        addReplyBulkCBuffer(c, e->sval, e->slen);
    else
        addReplyBulkLongLong(c, e->lval);
}",1,1,t_hash.c,hashReplyFromListpackEntry,,false,556,561,hashReplyFromListpackEntry,,,23,"void hashReplyFromListpackEntry (client*,listpackEntry*)"
418177,METHOD,t_hash.c:<global>,TYPE_DECL,"void hashTypeRandomElement(robj *hashobj, unsigned long hashsize, listpackEntry *key, listpackEntry *val) {
    if (hashobj->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictGetFairRandomKey(hashobj->ptr);
        sds s = dictGetKey(de);
        key->sval = (unsigned char*)s;
        key->slen = sdslen(s);
        if (val) {
            sds s = dictGetVal(de);
            val->sval = (unsigned char*)s;
            val->slen = sdslen(s);
        }
    } else if (hashobj->encoding == OBJ_ENCODING_LISTPACK) {
        lpRandomPair(hashobj->ptr, hashsize, key, val);
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",1,29,t_hash.c,hashTypeRandomElement,,false,567,583,hashTypeRandomElement,,,24,"void hashTypeRandomElement (robj*,long unsigned,listpackEntry*,listpackEntry*)"
418268,METHOD,t_hash.c:<global>,TYPE_DECL,"void hsetnxCommand(client *c) {
    robj *o;
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;

    if (hashTypeExists(o, c->argv[2]->ptr)) {
        addReply(c, shared.czero);
    } else {
        hashTypeTryConversion(o,c->argv,2,3);
        hashTypeSet(o,c->argv[2]->ptr,c->argv[3]->ptr,HASH_SET_COPY);
        addReply(c, shared.cone);
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_HASH,""hset"",c->argv[1],c->db->id);
        server.dirty++;
    }
}",1,54,t_hash.c,hsetnxCommand,,false,590,604,hsetnxCommand,,,25,void hsetnxCommand (client*)
418368,METHOD,t_hash.c:<global>,TYPE_DECL,"void hsetCommand(client *c) {
    int i, created = 0;
    robj *o;

    if ((c->argc % 2) == 1) {
        addReplyErrorArity(c);
        return;
    }

    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    hashTypeTryConversion(o,c->argv,2,c->argc-1);

    for (i = 2; i < c->argc; i += 2)
        created += !hashTypeSet(o,c->argv[i]->ptr,c->argv[i+1]->ptr,HASH_SET_COPY);

    /* HMSET (deprecated) and HSET return value is different. */
    char *cmdname = c->argv[0]->ptr;
    if (cmdname[1] == 's' || cmdname[1] == 'S') {
        /* HSET */
        addReplyLongLong(c, created);
    } else {
        /* HMSET */
        addReply(c, shared.ok);
    }
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_HASH,""hset"",c->argv[1],c->db->id);
    server.dirty += (c->argc - 2)/2;
}",1,68,t_hash.c,hsetCommand,,false,606,633,hsetCommand,,,26,void hsetCommand (client*)
418524,METHOD,t_hash.c:<global>,TYPE_DECL,"void hincrbyCommand(client *c) {
    long long value, incr, oldvalue;
    robj *o;
    sds new;
    unsigned char *vstr;
    unsigned int vlen;

    if (getLongLongFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&value) == C_OK) {
        if (vstr) {
            if (string2ll((char*)vstr,vlen,&value) == 0) {
                addReplyError(c,""hash value is not an integer"");
                return;
            }
        } /* Else hashTypeGetValue() already stored it into &value */
    } else {
        value = 0;
    }

    oldvalue = value;
    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
        addReplyError(c,""increment or decrement would overflow"");
        return;
    }
    value += incr;
    new = sdsfromlonglong(value);
    hashTypeSet(o,c->argv[2]->ptr,...",1,65,t_hash.c,hincrbyCommand,,false,635,668,hincrbyCommand,,,27,void hincrbyCommand (client*)
418703,METHOD,t_hash.c:<global>,TYPE_DECL,"void hincrbyfloatCommand(client *c) {
    long double value, incr;
    long long ll;
    robj *o;
    sds new;
    unsigned char *vstr;
    unsigned int vlen;

    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;
    if (isnan(incr) || isinf(incr)) {
        addReplyError(c,""value is NaN or Infinity"");
        return;
    }
    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;
    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {
        if (vstr) {
            if (string2ld((char*)vstr,vlen,&value) == 0) {
                addReplyError(c,""hash value is not a float"");
                return;
            }
        } else {
            value = (long double)ll;
        }
    } else {
        value = 0;
    }

    value += incr;
    if (isnan(value) || isinf(value)) {
        addReplyError(c,""increment would produce NaN or Infinity"");
        return;
    }

    char buf[MAX_LONG_DOUBLE_CHARS];
    int len = ld2string(buf,si...",1,67,t_hash.c,hincrbyfloatCommand,,false,670,720,hincrbyfloatCommand,,,28,void hincrbyfloatCommand (client*)
418905,METHOD,t_hash.c:<global>,TYPE_DECL,"static void addHashFieldToReply(client *c, robj *o, sds field) {
    if (o == NULL) {
        addReplyNull(c);
        return;
    }

    unsigned char *vstr = NULL;
    unsigned int vlen = UINT_MAX;
    long long vll = LLONG_MAX;

    if (hashTypeGetValue(o, field, &vstr, &vlen, &vll) == C_OK) {
        if (vstr) {
            addReplyBulkCBuffer(c, vstr, vlen);
        } else {
            addReplyBulkLongLong(c, vll);
        }
    } else {
        addReplyNull(c);
    }
}",1,58,t_hash.c,addHashFieldToReply,,false,722,741,addHashFieldToReply,,,29,"void addHashFieldToReply (client*,robj*,sds)"
418963,METHOD,t_hash.c:<global>,TYPE_DECL,"void hgetCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    addHashFieldToReply(c, o, c->argv[2]->ptr);
}",1,22,t_hash.c,hgetCommand,,false,743,750,hgetCommand,,,30,void hgetCommand (client*)
419007,METHOD,t_hash.c:<global>,TYPE_DECL,"void hmgetCommand(client *c) {
    robj *o;
    int i;

    /* Don't abort when the key cannot be found. Non-existing keys are empty
     * hashes, where HMGET should respond with a series of null bulks. */
    o = lookupKeyRead(c->db, c->argv[1]);
    if (checkType(c,o,OBJ_HASH)) return;

    addReplyArrayLen(c, c->argc-2);
    for (i = 2; i < c->argc; i++) {
        addHashFieldToReply(c, o, c->argv[i]->ptr);
    }
}",1,22,t_hash.c,hmgetCommand,,false,752,765,hmgetCommand,,,31,void hmgetCommand (client*)
419064,METHOD,t_hash.c:<global>,TYPE_DECL,"void hdelCommand(client *c) {
    robj *o;
    int j, deleted = 0, keyremoved = 0;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    for (j = 2; j < c->argc; j++) {
        if (hashTypeDelete(o,c->argv[j]->ptr)) {
            deleted++;
            if (hashTypeLength(o) == 0) {
                dbDelete(c->db,c->argv[1]);
                keyremoved = 1;
                break;
            }
        }
    }
    if (deleted) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_HASH,""hdel"",c->argv[1],c->db->id);
        if (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",c->argv[1],
                                c->db->id);
        server.dirty += deleted;
    }
    addReplyLongLong(c,deleted);
}",1,22,t_hash.c,hdelCommand,,false,767,793,hdelCommand,,,32,void hdelCommand (client*)
419206,METHOD,t_hash.c:<global>,TYPE_DECL,"void hlenCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    addReplyLongLong(c,hashTypeLength(o));
}",1,22,t_hash.c,hlenCommand,,false,795,802,hlenCommand,,,33,void hlenCommand (client*)
419240,METHOD,t_hash.c:<global>,TYPE_DECL,"void hstrlenCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;
    addReplyLongLong(c,hashTypeGetValueLength(o,c->argv[2]->ptr));
}",1,22,t_hash.c,hstrlenCommand,,false,804,810,hstrlenCommand,,,34,void hstrlenCommand (client*)
419281,METHOD,t_hash.c:<global>,TYPE_DECL,"static void addHashIteratorCursorToReply(client *c, hashTypeIterator *hi, int what) {
    if (hi->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *vstr = NULL;
        unsigned int vlen = UINT_MAX;
        long long vll = LLONG_MAX;

        hashTypeCurrentFromListpack(hi, what, &vstr, &vlen, &vll);
        if (vstr)
            addReplyBulkCBuffer(c, vstr, vlen);
        else
            addReplyBulkLongLong(c, vll);
    } else if (hi->encoding == OBJ_ENCODING_HT) {
        sds value = hashTypeCurrentFromHashTable(hi, what);
        addReplyBulkCBuffer(c, value, sdslen(value));
    } else {
        serverPanic(""Unknown hash encoding"");
    }
}",1,24,t_hash.c,addHashIteratorCursorToReply,,false,812,829,addHashIteratorCursorToReply,,,35,"void addHashIteratorCursorToReply (client*,hashTypeIterator*,int)"
419362,METHOD,t_hash.c:<global>,TYPE_DECL,"void genericHgetallCommand(client *c, int flags) {
    robj *o;
    hashTypeIterator *hi;
    int length, count = 0;

    robj *emptyResp = (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) ?
        shared.emptymap[c->resp] : shared.emptyarray;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],emptyResp))
        == NULL || checkType(c,o,OBJ_HASH)) return;

    /* We return a map if the user requested keys and values, like in the
     * HGETALL case. Otherwise to use a flat array makes more sense. */
    length = hashTypeLength(o);
    if (flags & OBJ_HASH_KEY && flags & OBJ_HASH_VALUE) {
        addReplyMapLen(c, length);
    } else {
        addReplyArrayLen(c, length);
    }

    hi = hashTypeInitIterator(o);
    while (hashTypeNext(hi) != C_ERR) {
        if (flags & OBJ_HASH_KEY) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);
            count++;
        }
        if (flags & OBJ_HASH_VALUE) {
            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);
     ...",1,31,t_hash.c,genericHgetallCommand,,false,831,867,genericHgetallCommand,,,36,"void genericHgetallCommand (client*,int)"
419524,METHOD,t_hash.c:<global>,TYPE_DECL,"void hkeysCommand(client *c) {
    genericHgetallCommand(c,OBJ_HASH_KEY);
}",1,28,t_hash.c,hkeysCommand,,false,869,871,hkeysCommand,,,37,void hkeysCommand (client*)
419534,METHOD,t_hash.c:<global>,TYPE_DECL,"void hvalsCommand(client *c) {
    genericHgetallCommand(c,OBJ_HASH_VALUE);
}",1,28,t_hash.c,hvalsCommand,,false,873,875,hvalsCommand,,,38,void hvalsCommand (client*)
419544,METHOD,t_hash.c:<global>,TYPE_DECL,"void hgetallCommand(client *c) {
    genericHgetallCommand(c,OBJ_HASH_KEY|OBJ_HASH_VALUE);
}",1,28,t_hash.c,hgetallCommand,,false,877,879,hgetallCommand,,,39,void hgetallCommand (client*)
419558,METHOD,t_hash.c:<global>,TYPE_DECL,"void hexistsCommand(client *c) {
    robj *o;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;

    addReply(c, hashTypeExists(o,c->argv[2]->ptr) ? shared.cone : shared.czero);
}",1,22,t_hash.c,hexistsCommand,,false,881,887,hexistsCommand,,,40,void hexistsCommand (client*)
419606,METHOD,t_hash.c:<global>,TYPE_DECL,"void hscanCommand(client *c) {
    robj *o;
    unsigned long cursor;

    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
        checkType(c,o,OBJ_HASH)) return;
    scanGenericCommand(c,o,cursor);
}",1,56,t_hash.c,hscanCommand,,false,889,897,hscanCommand,,,41,void hscanCommand (client*)
419658,METHOD,t_hash.c:<global>,TYPE_DECL,"static void hrandfieldReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    for (unsigned long i = 0; i < count; i++) {
        if (vals && c->resp > 2)
            addReplyArrayLen(c,2);
        if (keys[i].sval)
            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);
        else
            addReplyBulkLongLong(c, keys[i].lval);
        if (vals) {
            if (vals[i].sval)
                addReplyBulkCBuffer(c, vals[i].sval, vals[i].slen);
            else
                addReplyBulkLongLong(c, vals[i].lval);
        }
    }
}",1,1,t_hash.c,hrandfieldReplyWithListpack,,false,899,914,hrandfieldReplyWithListpack,,,42,"void hrandfieldReplyWithListpack (client*,unsigned int,listpackEntry*,listpackEntry*)"
419749,METHOD,t_hash.c:<global>,TYPE_DECL,"void hrandfieldWithCountCommand(client *c, long l, int withvalues) {
    unsigned long count, size;
    int uniq = 1;
    robj *hash;

    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))
        == NULL || checkType(c,hash,OBJ_HASH)) return;
    size = hashTypeLength(hash);

    if(l >= 0) {
        count = (unsigned long) l;
    } else {
        count = -l;
        uniq = 0;
    }

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. This case is the only one that also needs to return the
     * elements in random order. */
    if (!uniq || count == 1) {
        if (withvalues && c->resp == 2)
            addReplyArrayLen(c, count*2);
  ...",1,36,t_hash.c,hrandfieldWithCountCommand,,false,926,1130,hrandfieldWithCountCommand,,,43,"void hrandfieldWithCountCommand (client*,long,int)"
420407,METHOD,t_hash.c:<global>,TYPE_DECL,"void hrandfieldCommand(client *c) {
    long l;
    int withvalues = 0;
    robj *hash;
    listpackEntry ele;

    if (c->argc >= 3) {
        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,""withvalues""))) {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        } else if (c->argc == 4) {
            withvalues = 1;
            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {
                addReplyError(c,""value is out of range"");
                return;
            }
        }
        hrandfieldWithCountCommand(c, l, withvalues);
        return;
    }

    /* Handle variant without <count> argument. Reply with simple bulk string */
    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||
        checkType(c,hash,OBJ_HASH)) {
        return;
    }

    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);
    hashRep...",1,86,t_hash.c,hrandfieldCommand,,false,1133,1163,hrandfieldCommand,,,44,void hrandfieldCommand (client*)
420554,METHOD,t_list.c:<global>,TYPE_DECL,<global>,1,1,t_list.c,t_list.c:<global>,,false,1,1388,<global>,,,1,
420556,METHOD,t_list.c:<global>,TYPE_DECL,"static void listTypeTryConvertListpack(robj *o, robj **argv, int start, int end,
                                       beforeConvertCB fn, void *data)
{
    serverAssert(o->encoding == OBJ_ENCODING_LISTPACK);

    size_t add_bytes = 0;
    size_t add_length = 0;

    if (argv) {
        for (int i = start; i <= end; i++) {
            if (!sdsEncodedObject(argv[i]))
                continue;
            add_bytes += sdslen(argv[i]->ptr);
        }
        add_length = end - start + 1;
    }

    if (quicklistNodeExceedsLimit(server.list_max_listpack_size,
            lpBytes(o->ptr) + add_bytes, lpLength(o->ptr) + add_length))
    {
        /* Invoke callback before conversion. */
        if (fn) fn(data);

        quicklist *ql = quicklistCreate();
        quicklistSetOptions(ql, server.list_max_listpack_size, server.list_compress_depth);

        /* Append listpack to quicklist if it's not empty, otherwise release it. */
        if (lpLength(o->ptr))
            quicklistAppendLi...",1,4,t_list.c,listTypeTryConvertListpack,,false,42,76,listTypeTryConvertListpack,,,1,"void listTypeTryConvertListpack (robj*,robj**,int,int,beforeConvertCB,void*)"
420710,METHOD,t_list.c:<global>,TYPE_DECL,"static void listTypeTryConvertQuicklist(robj *o, int shrinking, beforeConvertCB fn, void *data) {
    serverAssert(o->encoding == OBJ_ENCODING_QUICKLIST);

    size_t sz_limit;
    unsigned int count_limit;
    quicklist *ql = o->ptr;

    /* A quicklist can be converted to listpack only if it has only one packed node. */
    if (ql->len != 1 || ql->head->container != QUICKLIST_NODE_CONTAINER_PACKED)
        return;

    /* Check the length or size of the quicklist is below the limit. */
    quicklistNodeLimit(server.list_max_listpack_size, &sz_limit, &count_limit);
    if (shrinking) {
        sz_limit /= 2;
        count_limit /= 2;
    }
    if (ql->head->sz > sz_limit || ql->count > count_limit) return;

    /* Invoke callback before conversion. */
    if (fn) fn(data);

    /* Extract the listpack from the unique quicklist node,
     * then reset it and release the quicklist. */
    o->ptr = ql->head->entry;
    ql->head->entry = NULL;
    quicklistRelease(ql);
    o->encoding ...",1,4,t_list.c,listTypeTryConvertQuicklist,,false,87,115,listTypeTryConvertQuicklist,,,2,"void listTypeTryConvertQuicklist (robj*,int,beforeConvertCB,void*)"
420825,METHOD,t_list.c:<global>,TYPE_DECL,"static void listTypeTryConversionRaw(robj *o, list_conv_type lct,
                                     robj **argv, int start, int end,
                                     beforeConvertCB fn, void *data)
{
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        if (lct == LIST_CONV_GROWING) return; /* Growing has nothing to do with quicklist */
        listTypeTryConvertQuicklist(o, lct == LIST_CONV_SHRINKING, fn, data);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        if (lct == LIST_CONV_SHRINKING) return; /* Shrinking has nothing to do with listpack */
        listTypeTryConvertListpack(o, argv, start, end, fn, data);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",1,23,t_list.c,listTypeTryConversionRaw,,false,132,145,listTypeTryConversionRaw,,,3,"void listTypeTryConversionRaw (robj*,list_conv_type,robj**,int,int,beforeConvertCB,void*)"
420892,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeTryConversion(robj *o, list_conv_type lct, beforeConvertCB fn, void *data) {
    listTypeTryConversionRaw(o, lct, NULL, 0, 0, fn, data);
}",1,1,t_list.c,listTypeTryConversion,,false,149,151,listTypeTryConversion,,,4,"void listTypeTryConversion (robj*,list_conv_type,beforeConvertCB,void*)"
420908,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeTryConversionAppend(robj *o, robj **argv, int start, int end,
                                 beforeConvertCB fn, void *data)
{
    listTypeTryConversionRaw(o, LIST_CONV_GROWING, argv, start, end, fn, data);
}",1,1,t_list.c,listTypeTryConversionAppend,,false,155,159,listTypeTryConversionAppend,,,5,"void listTypeTryConversionAppend (robj*,robj**,int,int,beforeConvertCB,void*)"
420926,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypePush(robj *subject, robj *value, int where) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        int pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;
        if (value->encoding == OBJ_ENCODING_INT) {
            char buf[32];
            ll2string(buf, 32, (long)value->ptr);
            quicklistPush(subject->ptr, buf, strlen(buf), pos);
        } else {
            quicklistPush(subject->ptr, value->ptr, sdslen(value->ptr), pos);
        }
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        if (value->encoding == OBJ_ENCODING_INT) {
            subject->ptr = (where == LIST_HEAD) ?
                lpPrependInteger(subject->ptr, (long)value->ptr) :
                lpAppendInteger(subject->ptr, (long)value->ptr);
        } else {
            subject->ptr = (where == LIST_HEAD) ?
                lpPrepend(subject->ptr, value->ptr, sdslen(value->ptr)) :
                lpAppend(subject->ptr, value->ptr, sdslen(value->ptr));
      ...",1,29,t_list.c,listTypePush,,false,166,189,listTypePush,,,6,"void listTypePush (robj*,robj*,int)"
421090,METHOD,t_list.c:<global>,TYPE_DECL,"void *listPopSaver(unsigned char *data, size_t sz) {
    return createStringObject((char*)data,sz);
}",1,1,t_list.c,listPopSaver,,false,191,193,listPopSaver,,,7,"void* listPopSaver (unsigned char*,size_t)"
421102,METHOD,t_list.c:<global>,TYPE_DECL,"robj *listTypePop(robj *subject, int where) {
    robj *value = NULL;

    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        long long vlong;
        int ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;
        if (quicklistPopCustom(subject->ptr, ql_where, (unsigned char **)&value,
                               NULL, &vlong, listPopSaver)) {
            if (!value)
                value = createStringObjectFromLongLong(vlong);
        }
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p;
        unsigned char *vstr;
        int64_t vlen;
        unsigned char intbuf[LP_INTBUF_SIZE];

        p = (where == LIST_HEAD) ? lpFirst(subject->ptr) : lpLast(subject->ptr);
        if (p) {
            vstr = lpGet(p, &vlen, intbuf);
            value = createStringObject((char*)vstr, vlen);
            subject->ptr = lpDelete(subject->ptr, p, NULL);
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
    retu...",1,29,t_list.c,listTypePop,,false,195,222,listTypePop,,,8,"robj listTypePop (robj*,int)"
421231,METHOD,t_list.c:<global>,TYPE_DECL,"unsigned long listTypeLength(const robj *subject) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistCount(subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        return lpLength(subject->ptr);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",1,29,t_list.c,listTypeLength,,false,224,232,listTypeLength,,,9,unsigned long listTypeLength (robj*)
421276,METHOD,t_list.c:<global>,TYPE_DECL,"listTypeIterator *listTypeInitIterator(robj *subject, long index,
                                       unsigned char direction) {
    listTypeIterator *li = zmalloc(sizeof(listTypeIterator));
    li->subject = subject;
    li->encoding = subject->encoding;
    li->direction = direction;
    li->iter = NULL;
    /* LIST_HEAD means start at TAIL and move *towards* head.
     * LIST_TAIL means start at HEAD and move *towards* tail. */
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        int iter_direction = direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
        li->iter = quicklistGetIteratorAtIdx(li->subject->ptr,
                                             iter_direction, index);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        li->lpi = lpSeek(subject->ptr, index);
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return li;
}",1,24,t_list.c,listTypeInitIterator,,false,235,254,listTypeInitIterator,,,10,"listTypeIterator listTypeInitIterator (robj*,long,unsigned char)"
421379,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeSetIteratorDirection(listTypeIterator *li, listTypeEntry *entry, unsigned char direction) {
    if (li->direction == direction) return;

    li->direction = direction;
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        int dir = direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;
        quicklistSetDirection(li->iter, dir);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = li->subject->ptr;
        /* Note that the iterator for listpack always points to the next of the current entry,
         * so we need to update position of the iterator depending on the direction. */
        li->lpi = (direction == LIST_TAIL) ? lpNext(lp, entry->lpe) : lpPrev(lp, entry->lpe);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",1,24,t_list.c,listTypeSetIteratorDirection,,false,257,272,listTypeSetIteratorDirection,,,11,"void listTypeSetIteratorDirection (listTypeIterator*,listTypeEntry*,unsigned char)"
421477,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeReleaseIterator(listTypeIterator *li) {
    if (li->encoding == OBJ_ENCODING_QUICKLIST)
        quicklistReleaseIterator(li->iter);
    zfree(li);
}",1,24,t_list.c,listTypeReleaseIterator,,false,275,279,listTypeReleaseIterator,,,12,void listTypeReleaseIterator (listTypeIterator*)
421497,METHOD,t_list.c:<global>,TYPE_DECL,"int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {
    /* Protect from converting when iterating */
    serverAssert(li->subject->encoding == li->encoding);

    entry->li = li;
    if (li->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistNext(li->iter, &entry->entry);
    } else if (li->encoding == OBJ_ENCODING_LISTPACK) {
        entry->lpe = li->lpi;
        if (entry->lpe != NULL) {
            li->lpi = (li->direction == LIST_TAIL) ?
                lpNext(li->subject->ptr,li->lpi) : lpPrev(li->subject->ptr,li->lpi);
            return 1;
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return 0;
}",1,4,t_list.c,listTypeNext,,false,284,302,listTypeNext,,,13,"int listTypeNext (listTypeIterator*,listTypeEntry*)"
421617,METHOD,t_list.c:<global>,TYPE_DECL,"unsigned char *listTypeGetValue(listTypeEntry *entry, size_t *vlen, long long *lval) {
    unsigned char *vstr = NULL;
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        if (entry->entry.value) {
            vstr = entry->entry.value;
            *vlen = entry->entry.sz;
        } else {
            *lval = entry->entry.longval;
        }
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned int slen;
        vstr = lpGetValue(entry->lpe, &slen, lval);
        *vlen = slen;
    } else {
        serverPanic(""Unknown list encoding"");
    }
    return vstr;
}",1,31,t_list.c,listTypeGetValue,,false,308,325,listTypeGetValue,,,14,"unsigned char* listTypeGetValue (listTypeEntry*,size_t*,long long*)"
421710,METHOD,t_list.c:<global>,TYPE_DECL,"robj *listTypeGet(listTypeEntry *entry) {
    unsigned char *vstr;
    size_t vlen;
    long long lval;

    vstr = listTypeGetValue(entry, &vlen, &lval);
    if (vstr) 
        return createStringObject((char *)vstr, vlen);
    else
        return createStringObjectFromLongLong(lval);
}",1,1,t_list.c,listTypeGet,,false,328,338,listTypeGet,,,15,robj listTypeGet (listTypeEntry*)
421740,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeInsert(listTypeEntry *entry, robj *value, int where) {
    robj *subject = entry->li->subject;
    value = getDecodedObject(value);
    sds str = value->ptr;
    size_t len = sdslen(str);

    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        if (where == LIST_TAIL) {
            quicklistInsertAfter(entry->li->iter, &entry->entry, str, len);
        } else if (where == LIST_HEAD) {
            quicklistInsertBefore(entry->li->iter, &entry->entry, str, len);
        }
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        int lpw = (where == LIST_TAIL) ? LP_AFTER : LP_BEFORE;
        subject->ptr = lpInsertString(subject->ptr, (unsigned char *)str,
                                      len, entry->lpe, lpw, &entry->lpe);
    } else {
        serverPanic(""Unknown list encoding"");
    }
    decrRefCount(value);
}",1,31,t_list.c,listTypeInsert,,false,340,360,listTypeInsert,,,16,"void listTypeInsert (listTypeEntry*,robj*,int)"
421881,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeReplace(listTypeEntry *entry, robj *value) {
    robj *subject = entry->li->subject;
    value = getDecodedObject(value);
    sds str = value->ptr;
    size_t len = sdslen(str);

    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistReplaceEntry(entry->li->iter, &entry->entry, str, len);
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        subject->ptr = lpReplace(subject->ptr, &entry->lpe, (unsigned char *)str, len);
    } else {
        serverPanic(""Unknown list encoding"");
    }

    decrRefCount(value);
}",1,31,t_list.c,listTypeReplace,,false,363,378,listTypeReplace,,,17,"void listTypeReplace (listTypeEntry*,robj*)"
421974,METHOD,t_list.c:<global>,TYPE_DECL,"int listTypeReplaceAtIndex(robj *o, int index, robj *value) {
    value = getDecodedObject(value);
    sds vstr = value->ptr;
    size_t vlen = sdslen(vstr);
    int replaced = 0;

    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        replaced = quicklistReplaceAtIndex(ql, index, vstr, vlen);
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p = lpSeek(o->ptr,index);
        if (p) {
            o->ptr = lpReplace(o->ptr, &p, (unsigned char *)vstr, vlen);
            replaced = 1;
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }

    decrRefCount(value);
    return replaced;
}",1,23,t_list.c,listTypeReplaceAtIndex,,false,384,405,listTypeReplaceAtIndex,,,18,"int listTypeReplaceAtIndex (robj*,int,robj*)"
422075,METHOD,t_list.c:<global>,TYPE_DECL,"int listTypeEqual(listTypeEntry *entry, robj *o) {
    serverAssertWithInfo(NULL,o,sdsEncodedObject(o));
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        return quicklistCompare(&entry->entry,o->ptr,sdslen(o->ptr));
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        return lpCompare(entry->lpe,o->ptr,sdslen(o->ptr));
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",1,4,t_list.c,listTypeEqual,,false,408,417,listTypeEqual,,,19,"int listTypeEqual (listTypeEntry*,robj*)"
422168,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeDelete(listTypeIterator *iter, listTypeEntry *entry) {
    if (entry->li->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistDelEntry(iter->iter, &entry->entry);
    } else if (entry->li->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *p = entry->lpe;
        iter->subject->ptr = lpDelete(iter->subject->ptr,p,&p);

        /* Update position of the iterator depending on the direction */
        if (iter->direction == LIST_TAIL)
            iter->lpi = p;
        else {
            if (p) {
                iter->lpi = lpPrev(iter->subject->ptr,p);
            } else {
                /* We deleted the last element, so we need to set the
                 * iterator to the last element. */
                iter->lpi = lpLast(iter->subject->ptr);
            }
        }
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",1,31,t_list.c,listTypeDelete,,false,420,442,listTypeDelete,,,20,"void listTypeDelete (listTypeIterator*,listTypeEntry*)"
422279,METHOD,t_list.c:<global>,TYPE_DECL,"robj *listTypeDup(robj *o) {
    robj *lobj;

    serverAssert(o->type == OBJ_LIST);

    switch (o->encoding) {
        case OBJ_ENCODING_LISTPACK:
            lobj = createObject(OBJ_LIST, lpDup(o->ptr));
            break;
        case OBJ_ENCODING_QUICKLIST:
            lobj = createObject(OBJ_LIST, quicklistDup(o->ptr));
            break;
        default:
            serverPanic(""Unknown list encoding"");
            break;
    }
    lobj->encoding = o->encoding;
    return lobj;
}",1,4,t_list.c,listTypeDup,,false,449,467,listTypeDup,,,21,robj listTypeDup (robj*)
422357,METHOD,t_list.c:<global>,TYPE_DECL,"void listTypeDelRange(robj *subject, long start, long count) {
    if (subject->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistDelRange(subject->ptr, start, count);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        subject->ptr = lpDeleteRange(subject->ptr, start, count);
    } else {
        serverPanic(""Unknown list encoding"");
    }
}",1,29,t_list.c,listTypeDelRange,,false,470,478,listTypeDelRange,,,22,"void listTypeDelRange (robj*,long,long)"
422410,METHOD,t_list.c:<global>,TYPE_DECL,"void pushGenericCommand(client *c, int where, int xx) {
    int j;

    robj *lobj = lookupKeyWrite(c->db, c->argv[1]);
    if (checkType(c,lobj,OBJ_LIST)) return;
    if (!lobj) {
        if (xx) {
            addReply(c, shared.czero);
            return;
        }

        lobj = createListListpackObject();
        dbAdd(c->db,c->argv[1],lobj);
    }

    listTypeTryConversionAppend(lobj,c->argv,2,c->argc-1,NULL,NULL);
    for (j = 2; j < c->argc; j++) {
        listTypePush(lobj,c->argv[j],where);
        server.dirty++;
    }

    addReplyLongLong(c, listTypeLength(lobj));

    char *event = (where == LIST_HEAD) ? ""lpush"" : ""rpush"";
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);
}",1,25,t_list.c,pushGenericCommand,,false,486,512,pushGenericCommand,,,23,"void pushGenericCommand (client*,int,int)"
422545,METHOD,t_list.c:<global>,TYPE_DECL,"void lpushCommand(client *c) {
    pushGenericCommand(c,LIST_HEAD,0);
}",1,25,t_list.c,lpushCommand,,false,515,517,lpushCommand,,,24,void lpushCommand (client*)
422556,METHOD,t_list.c:<global>,TYPE_DECL,"void rpushCommand(client *c) {
    pushGenericCommand(c,LIST_TAIL,0);
}",1,25,t_list.c,rpushCommand,,false,520,522,rpushCommand,,,25,void rpushCommand (client*)
422567,METHOD,t_list.c:<global>,TYPE_DECL,"void lpushxCommand(client *c) {
    pushGenericCommand(c,LIST_HEAD,1);
}",1,25,t_list.c,lpushxCommand,,false,525,527,lpushxCommand,,,26,void lpushxCommand (client*)
422578,METHOD,t_list.c:<global>,TYPE_DECL,"void rpushxCommand(client *c) {
    pushGenericCommand(c,LIST_TAIL,1);
}",1,25,t_list.c,rpushxCommand,,false,530,532,rpushxCommand,,,27,void rpushxCommand (client*)
422589,METHOD,t_list.c:<global>,TYPE_DECL,"void linsertCommand(client *c) {
    int where;
    robj *subject;
    listTypeIterator *iter;
    listTypeEntry entry;
    int inserted = 0;

    if (strcasecmp(c->argv[2]->ptr,""after"") == 0) {
        where = LIST_TAIL;
    } else if (strcasecmp(c->argv[2]->ptr,""before"") == 0) {
        where = LIST_HEAD;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,subject,OBJ_LIST)) return;

    /* We're not sure if this value can be inserted yet, but we cannot
     * convert the list inside the iterator. We don't want to loop over
     * the list twice (once to see if the value can be inserted and once
     * to do the actual insert), so we assume this value can be inserted
     * and convert the listpack to a regular list if necessary. */
    listTypeTryConversionAppend(subject,c->argv,4,4,NULL,NULL);

    /* Seek pivot from head to tail */
    iter = list...",1,16,t_list.c,linsertCommand,,false,535,584,linsertCommand,,,28,void linsertCommand (client*)
422765,METHOD,t_list.c:<global>,TYPE_DECL,"void llenCommand(client *c) {
    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.czero);
    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
    addReplyLongLong(c,listTypeLength(o));
}",1,35,t_list.c,llenCommand,,false,587,591,llenCommand,,,29,void llenCommand (client*)
422800,METHOD,t_list.c:<global>,TYPE_DECL,"void lindexCommand(client *c) {
    robj *o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]);
    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
    long index;

    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
        return;

    listTypeIterator *iter = listTypeInitIterator(o,index,LIST_TAIL);
    listTypeEntry entry;
    unsigned char *vstr;
    size_t vlen;
    long long lval;

    if (listTypeNext(iter,&entry)) {
        vstr = listTypeGetValue(&entry,&vlen,&lval);
        if (vstr) {
            addReplyBulkCBuffer(c, vstr, vlen);
        } else {
            addReplyBulkLongLong(c, lval);
        }
    } else {
        addReplyNull(c);
    }

    listTypeReleaseIterator(iter);
}",1,35,t_list.c,lindexCommand,,false,594,620,lindexCommand,,,30,void lindexCommand (client*)
422899,METHOD,t_list.c:<global>,TYPE_DECL,"void lsetCommand(client *c) {
    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);
    if (o == NULL || checkType(c,o,OBJ_LIST)) return;
    long index;
    robj *value = c->argv[3];

    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))
        return;

    listTypeTryConversionAppend(o,c->argv,3,3,NULL,NULL);
    if (listTypeReplaceAtIndex(o,index,value)) {
        addReply(c,shared.ok);
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_LIST,""lset"",c->argv[1],c->db->id);
        server.dirty++;

        /* We might replace a big item with a small one or vice versa, but we've
         * already handled the growing case in listTypeTryConversionAppend()
         * above, so here we just need to try the conversion for shrinking. */
        listTypeTryConversion(o,LIST_CONV_SHRINKING,NULL,NULL);
    } else {
        addReplyErrorObject(c,shared.outofrangeerr);
    }
}",1,35,t_list.c,lsetCommand,,false,623,646,lsetCommand,,,31,void lsetCommand (client*)
423019,METHOD,t_list.c:<global>,TYPE_DECL,"void listPopRangeAndReplyWithKey(client *c, robj *o, robj *key, int where, long count, int signal, int *deleted) {
    long llen = listTypeLength(o);
    long rangelen = (count > llen) ? llen : count;
    long rangestart = (where == LIST_HEAD) ? 0 : -rangelen;
    long rangeend = (where == LIST_HEAD) ? rangelen - 1 : -1;
    int reverse = (where == LIST_HEAD) ? 0 : 1;

    /* We return key-name just once, and an array of elements */
    addReplyArrayLen(c, 2);
    addReplyBulk(c, key);
    addListRangeReply(c, o, rangestart, rangeend, reverse);

    /* Pop these elements. */
    listTypeDelRange(o, rangestart, rangelen);
    /* Maintain the notifications and dirty. */
    listElementsRemoved(c, key, where, o, rangelen, signal, deleted);
}",1,32,t_list.c,listPopRangeAndReplyWithKey,,false,659,675,listPopRangeAndReplyWithKey,,,32,"void listPopRangeAndReplyWithKey (client*,robj*,robj*,int,long,int,int*)"
423105,METHOD,t_list.c:<global>,TYPE_DECL,"void addListQuicklistRangeReply(client *c, robj *o, int from, int rangelen, int reverse) {
    /* Return the result in form of a multi-bulk reply */
    addReplyArrayLen(c,rangelen);

    int direction = reverse ? AL_START_TAIL : AL_START_HEAD;
    quicklistIter *iter = quicklistGetIteratorAtIdx(o->ptr, direction, from);
    while(rangelen--) {
        quicklistEntry qe;
        serverAssert(quicklistNext(iter, &qe)); /* fail on corrupt data */
        if (qe.value) {
            addReplyBulkCBuffer(c,qe.value,qe.sz);
        } else {
            addReplyBulkLongLong(c,qe.longval);
        }
    }
    quicklistReleaseIterator(iter);
}",1,30,t_list.c,addListQuicklistRangeReply,,false,680,696,addListQuicklistRangeReply,,,33,"void addListQuicklistRangeReply (client*,robj*,int,int,int)"
423181,METHOD,t_list.c:<global>,TYPE_DECL,"void addListListpackRangeReply(client *c, robj *o, int from, int rangelen, int reverse) {
    unsigned char *p = lpSeek(o->ptr, from);
    unsigned char *vstr;
    unsigned int vlen;
    long long lval;

    /* Return the result in form of a multi-bulk reply */
    addReplyArrayLen(c,rangelen);

    while(rangelen--) {
        serverAssert(p); /* fail on corrupt data */
        vstr = lpGetValue(p, &vlen, &lval);
        if (vstr) {
            addReplyBulkCBuffer(c,vstr,vlen);
        } else {
            addReplyBulkLongLong(c,lval);
        }
        p = reverse ? lpPrev(o->ptr,p) : lpNext(o->ptr,p);
    }
}",1,8,t_list.c,addListListpackRangeReply,,false,701,720,addListListpackRangeReply,,,34,"void addListListpackRangeReply (client*,robj*,int,int,int)"
423257,METHOD,t_list.c:<global>,TYPE_DECL,"void addListRangeReply(client *c, robj *o, long start, long end, int reverse) {
    long rangelen, llen = listTypeLength(o);

    /* Convert negative indexes. */
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;

    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        addReply(c,shared.emptyarray);
        return;
    }
    if (end >= llen) end = llen-1;
    rangelen = (end-start)+1;

    int from = reverse ? end : start;
    if (o->encoding == OBJ_ENCODING_QUICKLIST)
        addListQuicklistRangeReply(c, o, from, rangelen, reverse);
    else if (o->encoding == OBJ_ENCODING_LISTPACK)
        addListListpackRangeReply(c, o, from, rangelen, reverse);
    else
        serverPanic(""Unknown list encoding"");
}",1,23,t_list.c,addListRangeReply,,false,727,751,addListRangeReply,,,35,"void addListRangeReply (client*,robj*,long,long,int)"
423381,METHOD,t_list.c:<global>,TYPE_DECL,"void listElementsRemoved(client *c, robj *key, int where, robj *o, long count, int signal, int *deleted) {
    char *event = (where == LIST_HEAD) ? ""lpop"" : ""rpop"";

    notifyKeyspaceEvent(NOTIFY_LIST, event, key, c->db->id);
    if (listTypeLength(o) == 0) {
        if (deleted) *deleted = 1;

        dbDelete(c->db, key);
        notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", key, c->db->id);
    } else {
        listTypeTryConversion(o, LIST_CONV_SHRINKING, NULL, NULL);
        if (deleted) *deleted = 0;
    }
    if (signal) signalModifiedKey(c, c->db, key);
    server.dirty += count;
}",1,28,t_list.c,listElementsRemoved,,false,759,774,listElementsRemoved,,,36,"void listElementsRemoved (client*,robj*,int,robj*,long,int,int*)"
423475,METHOD,t_list.c:<global>,TYPE_DECL,"void popGenericCommand(client *c, int where) {
    int hascount = (c->argc == 3);
    long count = 0;
    robj *value;

    if (c->argc > 3) {
        addReplyErrorArity(c);
        return;
    } else if (hascount) {
        /* Parse the optional count argument. */
        if (getPositiveLongFromObjectOrReply(c,c->argv[2],&count,NULL) != C_OK) 
            return;
    }

    robj *o = lookupKeyWriteOrReply(c, c->argv[1], hascount ? shared.nullarray[c->resp]: shared.null[c->resp]);
    if (o == NULL || checkType(c, o, OBJ_LIST))
        return;

    if (hascount && !count) {
        /* Fast exit path. */
        addReply(c,shared.emptyarray);
        return;
    }

    if (!count) {
        /* Pop a single element. This is POP's original behavior that replies
         * with a bulk string. */
        value = listTypePop(o,where);
        serverAssert(value != NULL);
        addReplyBulk(c,value);
        decrRefCount(value);
        listElementsRemoved(c,c->argv[1],where,o,1,1,NULL);...",1,74,t_list.c,popGenericCommand,,false,780,825,popGenericCommand,,,37,"void popGenericCommand (client*,int)"
423694,METHOD,t_list.c:<global>,TYPE_DECL,"void mpopGenericCommand(client *c, robj **keys, int numkeys, int where, long count) {
    int j;
    robj *o;
    robj *key;

    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db, key);

        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c, o, OBJ_LIST)) return;

        long llen = listTypeLength(o);
        /* Empty list, move to next key. */
        if (llen == 0) continue;

        /* Pop a range of elements in a nested arrays way. */
        listPopRangeAndReplyWithKey(c, o, key, where, count, 1, NULL);

        /* Replicate it as [LR]POP COUNT. */
        robj *count_obj = createStringObjectFromLongLong((count > llen) ? llen : count);
        rewriteClientCommandVector(c, 3,
                                   (where == LIST_HEAD) ? shared.lpop : shared.rpop,
                                   key, count_obj);
        decrRefCount(count_obj);
        return;
    }

    /* Look like we ...",1,28,t_list.c,mpopGenericCommand,,false,834,866,mpopGenericCommand,,,38,"void mpopGenericCommand (client*,robj**,int,int,long)"
423795,METHOD,t_list.c:<global>,TYPE_DECL,"void lpopCommand(client *c) {
    popGenericCommand(c,LIST_HEAD);
}",1,24,t_list.c,lpopCommand,,false,869,871,lpopCommand,,,39,void lpopCommand (client*)
423805,METHOD,t_list.c:<global>,TYPE_DECL,"void rpopCommand(client *c) {
    popGenericCommand(c,LIST_TAIL);
}",1,24,t_list.c,rpopCommand,,false,874,876,rpopCommand,,,40,void rpopCommand (client*)
423815,METHOD,t_list.c:<global>,TYPE_DECL,"void lrangeCommand(client *c) {
    robj *o;
    long start, end;

    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray)) == NULL
         || checkType(c,o,OBJ_LIST)) return;

    addListRangeReply(c,o,start,end,0);
}",1,66,t_list.c,lrangeCommand,,false,879,890,lrangeCommand,,,41,void lrangeCommand (client*)
423885,METHOD,t_list.c:<global>,TYPE_DECL,"void ltrimCommand(client *c) {
    robj *o;
    long start, end, llen, ltrim, rtrim;

    if ((getLongFromObjectOrReply(c, c->argv[2], &start, NULL) != C_OK) ||
        (getLongFromObjectOrReply(c, c->argv[3], &end, NULL) != C_OK)) return;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.ok)) == NULL ||
        checkType(c,o,OBJ_LIST)) return;
    llen = listTypeLength(o);

    /* convert negative indexes */
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;

    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        /* Out of range start or start > end result in empty list */
        ltrim = llen;
        rtrim = 0;
    } else {
        if (end >= llen) end = llen-1;
        ltrim = start;
        rtrim = llen-end-1;
    }

    /* Remove list elements to perform the trim */
    if (o->encoding == OBJ_E...",1,66,t_list.c,ltrimCommand,,false,893,942,ltrimCommand,,,42,void ltrimCommand (client*)
424163,METHOD,t_list.c:<global>,TYPE_DECL,"void lposCommand(client *c) {
    robj *o, *ele;
    ele = c->argv[2];
    int direction = LIST_TAIL;
    long rank = 1, count = -1, maxlen = 0; /* Count -1: option not given. */

    /* Parse the optional arguments. */
    for (int j = 3; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->argc-1)-j;

        if (!strcasecmp(opt,""RANK"") && moreargs) {
            j++;
            if (getRangeLongFromObjectOrReply(c, c->argv[j], -LONG_MAX, LONG_MAX, &rank, NULL) != C_OK)
                return;
            if (rank == 0) {
                addReplyError(c,""RANK can't be zero: use 1 to start from ""
                                ""the first match, 2 from the second ... ""
                                ""or use negative to start from the end of the list"");
                return;
            }
        } else if (!strcasecmp(opt,""COUNT"") && moreargs) {
            j++;
            if (getPositiveLongFromObjectOrReply(c, c->argv[j], &count,
              ""...",1,20,t_list.c,lposCommand,,false,961,1054,lposCommand,,,43,void lposCommand (client*)
424551,METHOD,t_list.c:<global>,TYPE_DECL,"void lremCommand(client *c) {
    robj *subject, *obj;
    obj = c->argv[3];
    long toremove;
    long removed = 0;

    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))
        return;

    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);
    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;

    listTypeIterator *li;
    if (toremove < 0) {
        toremove = -toremove;
        li = listTypeInitIterator(subject,-1,LIST_HEAD);
    } else {
        li = listTypeInitIterator(subject,0,LIST_TAIL);
    }

    listTypeEntry entry;
    while (listTypeNext(li,&entry)) {
        if (listTypeEqual(&entry,obj)) {
            listTypeDelete(li, &entry);
            server.dirty++;
            removed++;
            if (toremove && removed == toremove) break;
        }
    }
    listTypeReleaseIterator(li);

    if (removed) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_LIST,""lrem"",c->argv[1],c->db->id);
    ...",1,69,t_list.c,lremCommand,,false,1057,1101,lremCommand,,,44,void lremCommand (client*)
424749,METHOD,t_list.c:<global>,TYPE_DECL,"void lmoveHandlePush(client *c, robj *dstkey, robj *dstobj, robj *value,
                     int where) {
    /* Create the list if the key does not exist */
    if (!dstobj) {
        dstobj = createListListpackObject();
        dbAdd(c->db,dstkey,dstobj);
    }
    signalModifiedKey(c,c->db,dstkey);
    listTypeTryConversionAppend(dstobj,&value,0,0,NULL,NULL);
    listTypePush(dstobj,value,where);
    notifyKeyspaceEvent(NOTIFY_LIST,
                        where == LIST_HEAD ? ""lpush"" : ""rpush"",
                        dstkey,
                        c->db->id);
    /* Always send the pushed value to the client. */
    addReplyBulk(c,value);
}",1,24,t_list.c,lmoveHandlePush,,false,1103,1119,lmoveHandlePush,,,45,"void lmoveHandlePush (client*,robj*,robj*,robj*,int)"
424812,METHOD,t_list.c:<global>,TYPE_DECL,"int getListPositionFromObjectOrReply(client *c, robj *arg, int *position) {
    if (strcasecmp(arg->ptr,""right"") == 0) {
        *position = LIST_TAIL;
    } else if (strcasecmp(arg->ptr,""left"") == 0) {
        *position = LIST_HEAD;
    } else {
        addReplyErrorObject(c,shared.syntaxerr);
        return C_ERR;
    }
    return C_OK;
}",1,20,t_list.c,getListPositionFromObjectOrReply,,false,1121,1131,getListPositionFromObjectOrReply,,,46,"int getListPositionFromObjectOrReply (client*,robj*,int*)"
424867,METHOD,t_list.c:<global>,TYPE_DECL,"robj *getStringObjectFromListPosition(int position) {
    if (position == LIST_HEAD) {
        return shared.left;
    } else {
        // LIST_TAIL
        return shared.right;
    }
}",1,20,t_list.c,getStringObjectFromListPosition,,false,1133,1140,getStringObjectFromListPosition,,,47,robj getStringObjectFromListPosition (int)
424889,METHOD,t_list.c:<global>,TYPE_DECL,"void lmoveGenericCommand(client *c, int wherefrom, int whereto) {
    robj *sobj, *value;
    if ((sobj = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))
        == NULL || checkType(c,sobj,OBJ_LIST)) return;

    if (listTypeLength(sobj) == 0) {
        /* This may only happen after loading very old RDB files. Recent
         * versions of Redis delete keys of empty lists. */
        addReplyNull(c);
    } else {
        robj *dobj = lookupKeyWrite(c->db,c->argv[2]);
        robj *touchedkey = c->argv[1];

        if (checkType(c,dobj,OBJ_LIST)) return;
        value = listTypePop(sobj,wherefrom);
        serverAssert(value); /* assertion for valgrind (avoid NPD) */
        lmoveHandlePush(c,c->argv[2],dobj,value,whereto);
        listElementsRemoved(c,touchedkey,wherefrom,sobj,1,1,NULL);

        /* listTypePop returns an object with its refcount incremented */
        decrRefCount(value);

        if (c->cmd->proc == blmoveCommand) {
            rewriteClientCommandVect...",1,36,t_list.c,lmoveGenericCommand,,false,1142,1172,lmoveGenericCommand,,,48,"void lmoveGenericCommand (client*,int,int)"
425067,METHOD,t_list.c:<global>,TYPE_DECL,"void lmoveCommand(client *c) {
    int wherefrom, whereto;
    if (getListPositionFromObjectOrReply(c,c->argv[3],&wherefrom)
        != C_OK) return;
    if (getListPositionFromObjectOrReply(c,c->argv[4],&whereto)
        != C_OK) return;
    lmoveGenericCommand(c, wherefrom, whereto);
}",1,11,t_list.c,lmoveCommand,,false,1175,1182,lmoveCommand,,,49,void lmoveCommand (client*)
425110,METHOD,t_list.c:<global>,TYPE_DECL,"void rpoplpushCommand(client *c) {
    lmoveGenericCommand(c, LIST_TAIL, LIST_HEAD);
}",1,27,t_list.c,rpoplpushCommand,,false,1199,1201,rpoplpushCommand,,,50,void rpoplpushCommand (client*)
425123,METHOD,t_list.c:<global>,TYPE_DECL,"void blockingPopGenericCommand(client *c, robj **keys, int numkeys, int where, int timeout_idx, long count) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;

    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;

    /* Traverse all input keys, we take action only based on one key. */
    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db, key);

        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c, o, OBJ_LIST)) return;

        long llen = listTypeLength(o);
        /* Empty list, move to next key. */
        if (llen == 0) continue;

        if (count != -1) {
            /* BLMPOP, non empty list, like a normal [LR]POP with count option.
             * The difference here we pop a range of elements in a nested arrays way. */
            listPopRangeAndReplyWithKey(c, o, key, where, count, 1, NULL);

            /* Replicat...",1,68,t_list.c,blockingPopGenericCommand,,false,1212,1275,blockingPopGenericCommand,,,51,"void blockingPopGenericCommand (client*,robj**,int,int,int,long)"
425328,METHOD,t_list.c:<global>,TYPE_DECL,"void blpopCommand(client *c) {
    blockingPopGenericCommand(c,c->argv+1,c->argc-2,LIST_HEAD,c->argc-1,-1);
}",1,52,t_list.c,blpopCommand,,false,1278,1280,blpopCommand,,,52,void blpopCommand (client*)
425355,METHOD,t_list.c:<global>,TYPE_DECL,"void brpopCommand(client *c) {
    blockingPopGenericCommand(c,c->argv+1,c->argc-2,LIST_TAIL,c->argc-1,-1);
}",1,52,t_list.c,brpopCommand,,false,1283,1285,brpopCommand,,,53,void brpopCommand (client*)
425382,METHOD,t_list.c:<global>,TYPE_DECL,"void blmoveGenericCommand(client *c, int wherefrom, int whereto, mstime_t timeout) {
    robj *key = lookupKeyWrite(c->db, c->argv[1]);
    if (checkType(c,key,OBJ_LIST)) return;

    if (key == NULL) {
        if (c->flags & CLIENT_DENY_BLOCKING) {
            /* Blocking against an empty list when blocking is not allowed
             * returns immediately. */
            addReplyNull(c);
        } else {
            /* The list is empty and the client blocks. */
            blockForKeys(c,BLOCKED_LIST,c->argv + 1,1,timeout,0);
        }
    } else {
        /* The list exists and has elements, so
         * the regular lmoveCommand is executed. */
        serverAssertWithInfo(c,key,listTypeLength(key) > 0);
        lmoveGenericCommand(c,wherefrom,whereto);
    }
}",1,24,t_list.c,blmoveGenericCommand,,false,1287,1306,blmoveGenericCommand,,,54,"void blmoveGenericCommand (client*,int,int,mstime_t)"
425469,METHOD,t_list.c:<global>,TYPE_DECL,"void blmoveCommand(client *c) {
    mstime_t timeout;
    int wherefrom, whereto;
    if (getListPositionFromObjectOrReply(c,c->argv[3],&wherefrom)
        != C_OK) return;
    if (getListPositionFromObjectOrReply(c,c->argv[4],&whereto)
        != C_OK) return;
    if (getTimeoutFromObjectOrReply(c,c->argv[5],&timeout,UNIT_SECONDS)
        != C_OK) return;
    blmoveGenericCommand(c,wherefrom,whereto,timeout);
}",1,11,t_list.c,blmoveCommand,,false,1309,1319,blmoveCommand,,,55,void blmoveCommand (client*)
425533,METHOD,t_list.c:<global>,TYPE_DECL,"void brpoplpushCommand(client *c) {
    mstime_t timeout;
    if (getTimeoutFromObjectOrReply(c,c->argv[3],&timeout,UNIT_SECONDS)
        != C_OK) return;
    blmoveGenericCommand(c, LIST_TAIL, LIST_HEAD, timeout);
}",1,58,t_list.c,brpoplpushCommand,,false,1322,1327,brpoplpushCommand,,,56,void brpoplpushCommand (client*)
425567,METHOD,t_list.c:<global>,TYPE_DECL,"void lmpopGenericCommand(client *c, int numkeys_idx, int is_block) {
    long j;
    long numkeys = 0;      /* Number of keys. */
    int where = 0;         /* HEAD for LEFT, TAIL for RIGHT. */
    long count = -1;       /* Reply will consist of up to count elements, depending on the list's length. */

    /* Parse the numkeys. */
    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;

    /* Parse the where. where_idx: the index of where in the c->argv. */
    long where_idx = numkeys_idx + numkeys + 1;
    if (where_idx >= c->argc) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    if (getListPositionFromObjectOrReply(c, c->argv[where_idx], &where) != C_OK)
        return;

    /* Parse the optional arguments. */
    for (j = where_idx + 1; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->arg...",1,87,t_list.c,lmpopGenericCommand,,false,1333,1378,lmpopGenericCommand,,,57,"void lmpopGenericCommand (client*,int,int)"
425760,METHOD,t_list.c:<global>,TYPE_DECL,"void lmpopCommand(client *c) {
    lmpopGenericCommand(c, 1, 0);
}",1,1,t_list.c,lmpopCommand,,false,1381,1383,lmpopCommand,,,58,void lmpopCommand (client*)
425769,METHOD,t_list.c:<global>,TYPE_DECL,"void blmpopCommand(client *c) {
    lmpopGenericCommand(c, 2, 1);
}",1,1,t_list.c,blmpopCommand,,false,1386,1388,blmpopCommand,,,59,void blmpopCommand (client*)
425785,METHOD,t_set.c:<global>,TYPE_DECL,<global>,1,1,t_set.c,t_set.c:<global>,,false,1,1680,<global>,,,1,
425787,METHOD,t_set.c:<global>,TYPE_DECL,"void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                              robj *dstkey, int op);",6,51,t_set.c,sunionDiffGenericCommand,,false,37,38,sunionDiffGenericCommand,,,1,"void sunionDiffGenericCommand (client*,robj**,int,robj*,int)"
425796,METHOD,t_set.c:<global>,TYPE_DECL,"robj *setTypeCreate(sds value, size_t size_hint) {
    if (isSdsRepresentableAsLongLong(value,NULL) == C_OK && size_hint <= server.set_max_intset_entries)
        return createIntsetObject();
    if (size_hint <= server.set_max_listpack_entries)
        return createSetListpackObject();

    /* We may oversize the set by using the hint if the hint is not accurate,
     * but we will assume this is acceptable to maximize performance. */
    robj *o = createSetObject();
    dictExpand(o->ptr, size_hint);
    return o;
}",1,52,t_set.c,setTypeCreate,,false,46,57,setTypeCreate,,,2,"robj setTypeCreate (sds,size_t)"
425839,METHOD,t_set.c:<global>,TYPE_DECL,"void setTypeMaybeConvert(robj *set, size_t size_hint) {
    if ((set->encoding == OBJ_ENCODING_LISTPACK && size_hint > server.set_max_listpack_entries)
        || (set->encoding == OBJ_ENCODING_INTSET && size_hint > server.set_max_intset_entries))
    {
        setTypeConvertAndExpand(set, OBJ_ENCODING_HT, size_hint, 1);
    }
}",1,26,t_set.c,setTypeMaybeConvert,,false,61,67,setTypeMaybeConvert,,,3,"void setTypeMaybeConvert (robj*,size_t)"
425881,METHOD,t_set.c:<global>,TYPE_DECL,"static size_t intsetMaxEntries(void) {
    size_t max_entries = server.set_max_intset_entries;
    /* limit to 1G entries due to intset internals. */
    if (max_entries >= 1<<30) max_entries = 1<<30;
    return max_entries;
}",1,1,t_set.c,intsetMaxEntries,,false,70,75,intsetMaxEntries,,,4,size_t intsetMaxEntries (void)
425906,METHOD,t_set.c:<global>,TYPE_DECL,"static void maybeConvertIntset(robj *subject) {
    serverAssert(subject->encoding == OBJ_ENCODING_INTSET);
    if (intsetLen(subject->ptr) > intsetMaxEntries())
        setTypeConvert(subject,OBJ_ENCODING_HT);
}",1,4,t_set.c,maybeConvertIntset,,false,78,82,maybeConvertIntset,,,5,void maybeConvertIntset (robj*)
425942,METHOD,t_set.c:<global>,TYPE_DECL,"static void maybeConvertToIntset(robj *set) {
    if (set->encoding == OBJ_ENCODING_INTSET) return; /* already intset */
    if (setTypeSize(set) > intsetMaxEntries()) return; /* can't use intset */
    intset *is = intsetNew();
    char *str;
    size_t len;
    int64_t llval;
    setTypeIterator *si = setTypeInitIterator(set);
    while (setTypeNext(si, &str, &len, &llval) != -1) {
        if (str) {
            /* If the element is returned as a string, we may be able to convert
             * it to integer. This happens for OBJ_ENCODING_HT. */
            serverAssert(string2ll(str, len, (long long *)&llval));
        }
        uint8_t success = 0;
        is = intsetAdd(is, llval, &success);
        serverAssert(success);
    }
    setTypeReleaseIterator(si);
    freeSetObject(set); /* frees the internals but not robj itself */
    set->ptr = is;
    set->encoding = OBJ_ENCODING_INTSET;
}",1,25,t_set.c,maybeConvertToIntset,,false,87,109,maybeConvertToIntset,,,6,void maybeConvertToIntset (robj*)
426054,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeAdd(robj *subject, sds value) {
    return setTypeAddAux(subject, value, sdslen(value), 0, 1);
}",1,1,t_set.c,setTypeAdd,,false,115,117,setTypeAdd,,,7,"int setTypeAdd (robj*,sds)"
426068,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeAddAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (set->encoding == OBJ_ENCODING_INTSET) {
            uint8_t success = 0;
            set->ptr = intsetAdd(set->ptr, llval, &success);
            if (success) maybeConvertIntset(set);
            return success;
        }
        /* Convert int to string. */
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    serverAssert(str);
    if (set->encoding == OBJ_ENCODING_HT) {
        /* Avoid duping the string if it is an sds string. */
        sds sdsval = str_is_sds ? (sds)str : sdsnewlen(str, len);
        dict *ht = set->ptr;
        void *position = dictFindPositionForInsert(ht, sdsval, NULL);
        if (position) {
            /* Key doesn't already exist in the set. Add it but dup the key. */
            if (sdsval == str) sdsval = sdsdup(sdsval);
            dictInsertAtPositio...",1,16,t_set.c,setTypeAddAux,,false,125,229,setTypeAddAux,,,8,"int setTypeAddAux (robj*,char*,size_t,int64_t,int)"
426564,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeRemove(robj *setobj, sds value) {
    return setTypeRemoveAux(setobj, value, sdslen(value), 0, 1);
}",1,1,t_set.c,setTypeRemove,,false,233,235,setTypeRemove,,,9,"int setTypeRemove (robj*,sds)"
426578,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeRemoveAux(robj *setobj, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (setobj->encoding == OBJ_ENCODING_INTSET) {
            int success;
            setobj->ptr = intsetRemove(setobj->ptr,llval,&success);
            return success;
        }
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    if (setobj->encoding == OBJ_ENCODING_HT) {
        sds sdsval = str_is_sds ? (sds)str : sdsnewlen(str, len);
        int deleted = (dictDelete(setobj->ptr, sdsval) == DICT_OK);
        if (deleted && htNeedsResize(setobj->ptr)) dictResize(setobj->ptr);
        if (sdsval != str) sdsfree(sdsval); /* free temp copy */
        return deleted;
    } else if (setobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = setobj->ptr;
        unsigned char *p = lpFirst(lp);
        if (p == NULL) return 0;
        p = lpFind(lp, p, (unsigned char*)st...",1,16,t_set.c,setTypeRemoveAux,,false,243,283,setTypeRemoveAux,,,10,"int setTypeRemoveAux (robj*,char*,size_t,int64_t,int)"
426786,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeIsMember(robj *subject, sds value) {
    return setTypeIsMemberAux(subject, value, sdslen(value), 0, 1);
}",1,1,t_set.c,setTypeIsMember,,false,287,289,setTypeIsMember,,,11,"int setTypeIsMember (robj*,sds)"
426800,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeIsMemberAux(robj *set, char *str, size_t len, int64_t llval, int str_is_sds) {
    char tmpbuf[LONG_STR_SIZE];
    if (!str) {
        if (set->encoding == OBJ_ENCODING_INTSET)
            return intsetFind(set->ptr, llval);
        len = ll2string(tmpbuf, sizeof tmpbuf, llval);
        str = tmpbuf;
        str_is_sds = 0;
    }

    if (set->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = set->ptr;
        unsigned char *p = lpFirst(lp);
        return p && lpFind(lp, p, (unsigned char*)str, len, 0);
    } else if (set->encoding == OBJ_ENCODING_INTSET) {
        long long llval;
        return string2ll(str, len, &llval) && intsetFind(set->ptr, llval);
    } else if (set->encoding == OBJ_ENCODING_HT && str_is_sds) {
        return dictFind(set->ptr, (sds)str) != NULL;
    } else if (set->encoding == OBJ_ENCODING_HT) {
        sds sdsval = sdsnewlen(str, len);
        int result = dictFind(set->ptr, sdsval) != NULL;
        sdsfree(sdsval);
        retur...",1,16,t_set.c,setTypeIsMemberAux,,false,297,324,setTypeIsMemberAux,,,12,"int setTypeIsMemberAux (robj*,char*,size_t,int64_t,int)"
426961,METHOD,t_set.c:<global>,TYPE_DECL,"setTypeIterator *setTypeInitIterator(robj *subject) {
    setTypeIterator *si = zmalloc(sizeof(setTypeIterator));
    si->subject = subject;
    si->encoding = subject->encoding;
    if (si->encoding == OBJ_ENCODING_HT) {
        si->di = dictGetIterator(subject->ptr);
    } else if (si->encoding == OBJ_ENCODING_INTSET) {
        si->ii = 0;
    } else if (si->encoding == OBJ_ENCODING_LISTPACK) {
        si->lpi = NULL;
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return si;
}",1,24,t_set.c,setTypeInitIterator,,false,326,340,setTypeInitIterator,,,13,setTypeIterator setTypeInitIterator (robj*)
427045,METHOD,t_set.c:<global>,TYPE_DECL,"void setTypeReleaseIterator(setTypeIterator *si) {
    if (si->encoding == OBJ_ENCODING_HT)
        dictReleaseIterator(si->di);
    zfree(si);
}",1,24,t_set.c,setTypeReleaseIterator,,false,342,346,setTypeReleaseIterator,,,14,void setTypeReleaseIterator (setTypeIterator*)
427065,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeNext(setTypeIterator *si, char **str, size_t *len, int64_t *llele) {
    if (si->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictNext(si->di);
        if (de == NULL) return -1;
        *str = dictGetKey(de);
        *len = sdslen(*str);
        *llele = -123456789; /* Not needed. Defensive. */
    } else if (si->encoding == OBJ_ENCODING_INTSET) {
        if (!intsetGet(si->subject->ptr,si->ii++,llele))
            return -1;
        *str = NULL;
    } else if (si->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = si->subject->ptr;
        unsigned char *lpi = si->lpi;
        if (lpi == NULL) {
            lpi = lpFirst(lp);
        } else {
            lpi = lpNext(lp, lpi);
        }
        if (lpi == NULL) return -1;
        si->lpi = lpi;
        unsigned int l;
        *str = (char *)lpGetValue(lpi, &l, (long long *)llele);
        *len = (size_t)l;
    } else {
        serverPanic(""Wrong set encoding in setTypeNext"");
    }
    return si-...",1,24,t_set.c,setTypeNext,,false,369,397,setTypeNext,,,15,"int setTypeNext (setTypeIterator*,char**,size_t*,int64_t*)"
427232,METHOD,t_set.c:<global>,TYPE_DECL,"sds setTypeNextObject(setTypeIterator *si) {
    int64_t intele;
    char *str;
    size_t len;

    if (setTypeNext(si, &str, &len, &intele) == -1) return NULL;
    if (str != NULL) return sdsnewlen(str, len);
    return sdsfromlonglong(intele);
}",1,1,t_set.c,setTypeNextObject,,false,406,414,setTypeNextObject,,,16,sds setTypeNextObject (setTypeIterator*)
427267,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeRandomElement(robj *setobj, char **str, size_t *len, int64_t *llele) {
    if (setobj->encoding == OBJ_ENCODING_HT) {
        dictEntry *de = dictGetFairRandomKey(setobj->ptr);
        *str = dictGetKey(de);
        *len = sdslen(*str);
        *llele = -123456789; /* Not needed. Defensive. */
    } else if (setobj->encoding == OBJ_ENCODING_INTSET) {
        *llele = intsetRandom(setobj->ptr);
        *str = NULL; /* Not needed. Defensive. */
    } else if (setobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = setobj->ptr;
        int r = rand() % lpLength(lp);
        unsigned char *p = lpSeek(lp, r);
        unsigned int l;
        *str = (char *)lpGetValue(p, &l, (long long *)llele);
        *len = (size_t)l;
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return setobj->encoding;
}",1,28,t_set.c,setTypeRandomElement,,false,429,449,setTypeRandomElement,,,17,"int setTypeRandomElement (robj*,char**,size_t*,int64_t*)"
427392,METHOD,t_set.c:<global>,TYPE_DECL,"robj *setTypePopRandom(robj *set) {
    robj *obj;
    if (set->encoding == OBJ_ENCODING_LISTPACK) {
        /* Find random and delete it without re-seeking the listpack. */
        unsigned int i = 0;
        unsigned char *p = lpNextRandom(set->ptr, lpFirst(set->ptr), &i, 1, 0);
        unsigned int len = 0; /* initialize to silence warning */
        long long llele = 0; /* initialize to silence warning */
        char *str = (char *)lpGetValue(p, &len, &llele);
        if (str)
            obj = createStringObject(str, len);
        else
            obj = createStringObjectFromLongLong(llele);
        set->ptr = lpDelete(set->ptr, p, NULL);
    } else {
        char *str;
        size_t len = 0;
        int64_t llele = 0;
        int encoding = setTypeRandomElement(set, &str, &len, &llele);
        if (str)
            obj = createStringObject(str, len);
        else
            obj = createStringObjectFromLongLong(llele);
        setTypeRemoveAux(set, str, len, llele, encoding ...",1,25,t_set.c,setTypePopRandom,,false,452,478,setTypePopRandom,,,18,robj setTypePopRandom (robj*)
427517,METHOD,t_set.c:<global>,TYPE_DECL,"unsigned long setTypeSize(const robj *subject) {
    if (subject->encoding == OBJ_ENCODING_HT) {
        return dictSize((const dict*)subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        return intsetLen((const intset*)subject->ptr);
    } else if (subject->encoding == OBJ_ENCODING_LISTPACK) {
        return lpLength((unsigned char *)subject->ptr);
    } else {
        serverPanic(""Unknown set encoding"");
    }
}",1,29,t_set.c,setTypeSize,,false,480,490,setTypeSize,,,19,unsigned long setTypeSize (robj*)
427599,METHOD,t_set.c:<global>,TYPE_DECL,"void setTypeConvert(robj *setobj, int enc) {
    setTypeConvertAndExpand(setobj, enc, setTypeSize(setobj), 1);
}",1,1,t_set.c,setTypeConvert,,false,495,497,setTypeConvert,,,20,"void setTypeConvert (robj*,int)"
427611,METHOD,t_set.c:<global>,TYPE_DECL,"int setTypeConvertAndExpand(robj *setobj, int enc, unsigned long cap, int panic) {
    setTypeIterator *si;
    serverAssertWithInfo(NULL,setobj,setobj->type == OBJ_SET &&
                             setobj->encoding != enc);

    if (enc == OBJ_ENCODING_HT) {
        dict *d = dictCreate(&setDictType);
        sds element;

        /* Presize the dict to avoid rehashing */
        if (panic) {
            dictExpand(d, cap);
        } else if (dictTryExpand(d, cap) != DICT_OK) {
            dictRelease(d);
            return C_ERR;
        }

        /* To add the elements we extract integers and create redis objects */
        si = setTypeInitIterator(setobj);
        while ((element = setTypeNextObject(si)) != NULL) {
            serverAssert(dictAdd(d,element,NULL) == DICT_OK);
        }
        setTypeReleaseIterator(si);

        freeSetObject(setobj); /* frees the internals but not setobj itself */
        setobj->encoding = OBJ_ENCODING_HT;
        setobj->ptr = d;
    } el...",1,4,t_set.c,setTypeConvertAndExpand,,false,503,559,setTypeConvertAndExpand,,,21,"int setTypeConvertAndExpand (robj*,int,long unsigned,int)"
427867,METHOD,t_set.c:<global>,TYPE_DECL,"robj *setTypeDup(robj *o) {
    robj *set;
    setTypeIterator *si;

    serverAssert(o->type == OBJ_SET);

    /* Create a new set object that have the same encoding as the original object's encoding */
    if (o->encoding == OBJ_ENCODING_INTSET) {
        intset *is = o->ptr;
        size_t size = intsetBlobLen(is);
        intset *newis = zmalloc(size);
        memcpy(newis,is,size);
        set = createObject(OBJ_SET, newis);
        set->encoding = OBJ_ENCODING_INTSET;
    } else if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *lp = o->ptr;
        size_t sz = lpBytes(lp);
        unsigned char *new_lp = zmalloc(sz);
        memcpy(new_lp, lp, sz);
        set = createObject(OBJ_SET, new_lp);
        set->encoding = OBJ_ENCODING_LISTPACK;
    } else if (o->encoding == OBJ_ENCODING_HT) {
        set = createSetObject();
        dict *d = o->ptr;
        dictExpand(set->ptr, dictSize(d));
        si = setTypeInitIterator(o);
        char *str;
        size_t len...",1,4,t_set.c,setTypeDup,,false,566,603,setTypeDup,,,22,robj setTypeDup (robj*)
428057,METHOD,t_set.c:<global>,TYPE_DECL,"void saddCommand(client *c) {
    robj *set;
    int j, added = 0;

    set = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,set,OBJ_SET)) return;
    
    if (set == NULL) {
        set = setTypeCreate(c->argv[2]->ptr, c->argc - 2);
        dbAdd(c->db,c->argv[1],set);
    } else {
        setTypeMaybeConvert(set, c->argc - 2);
    }

    for (j = 2; j < c->argc; j++) {
        if (setTypeAdd(set,c->argv[j]->ptr)) added++;
    }
    if (added) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_SET,""sadd"",c->argv[1],c->db->id);
    }
    server.dirty += added;
    addReplyLongLong(c,added);
}",1,24,t_set.c,saddCommand,,false,605,628,saddCommand,,,23,void saddCommand (client*)
428191,METHOD,t_set.c:<global>,TYPE_DECL,"void sremCommand(client *c) {
    robj *set;
    int j, deleted = 0, keyremoved = 0;

    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,set,OBJ_SET)) return;

    for (j = 2; j < c->argc; j++) {
        if (setTypeRemove(set,c->argv[j]->ptr)) {
            deleted++;
            if (setTypeSize(set) == 0) {
                dbDelete(c->db,c->argv[1]);
                keyremoved = 1;
                break;
            }
        }
    }
    if (deleted) {
        signalModifiedKey(c,c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_SET,""srem"",c->argv[1],c->db->id);
        if (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",c->argv[1],
                                c->db->id);
        server.dirty += deleted;
    }
    addReplyLongLong(c,deleted);
}",1,24,t_set.c,sremCommand,,false,630,656,sremCommand,,,24,void sremCommand (client*)
428333,METHOD,t_set.c:<global>,TYPE_DECL,"void smoveCommand(client *c) {
    robj *srcset, *dstset, *ele;
    srcset = lookupKeyWrite(c->db,c->argv[1]);
    dstset = lookupKeyWrite(c->db,c->argv[2]);
    ele = c->argv[3];

    /* If the source key does not exist return 0 */
    if (srcset == NULL) {
        addReply(c,shared.czero);
        return;
    }

    /* If the source key has the wrong type, or the destination key
     * is set and has the wrong type, return with an error. */
    if (checkType(c,srcset,OBJ_SET) ||
        checkType(c,dstset,OBJ_SET)) return;

    /* If srcset and dstset are equal, SMOVE is a no-op */
    if (srcset == dstset) {
        addReply(c,setTypeIsMember(srcset,ele->ptr) ?
            shared.cone : shared.czero);
        return;
    }

    /* If the element cannot be removed from the src set, return 0. */
    if (!setTypeRemove(srcset,ele->ptr)) {
        addReply(c,shared.czero);
        return;
    }
    notifyKeyspaceEvent(NOTIFY_SET,""srem"",c->argv[1],c->db->id);

    /* Remove the src se...",1,27,t_set.c,smoveCommand,,false,658,711,smoveCommand,,,25,void smoveCommand (client*)
428558,METHOD,t_set.c:<global>,TYPE_DECL,"void sismemberCommand(client *c) {
    robj *set;

    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,set,OBJ_SET)) return;

    if (setTypeIsMember(set,c->argv[2]->ptr))
        addReply(c,shared.cone);
    else
        addReply(c,shared.czero);
}",1,24,t_set.c,sismemberCommand,,false,713,723,sismemberCommand,,,26,void sismemberCommand (client*)
428611,METHOD,t_set.c:<global>,TYPE_DECL,"void smismemberCommand(client *c) {
    robj *set;
    int j;

    /* Don't abort when the key cannot be found. Non-existing keys are empty
     * sets, where SMISMEMBER should respond with a series of zeros. */
    set = lookupKeyRead(c->db,c->argv[1]);
    if (set && checkType(c,set,OBJ_SET)) return;

    addReplyArrayLen(c,c->argc - 2);

    for (j = 2; j < c->argc; j++) {
        if (set && setTypeIsMember(set,c->argv[j]->ptr))
            addReply(c,shared.cone);
        else
            addReply(c,shared.czero);
    }
}",1,31,t_set.c,smismemberCommand,,false,725,742,smismemberCommand,,,27,void smismemberCommand (client*)
428685,METHOD,t_set.c:<global>,TYPE_DECL,"void scardCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_SET)) return;

    addReplyLongLong(c,setTypeSize(o));
}",1,22,t_set.c,scardCommand,,false,744,751,scardCommand,,,28,void scardCommand (client*)
428719,METHOD,t_set.c:<global>,TYPE_DECL,"void spopWithCountCommand(client *c) {
    long l;
    unsigned long count, size;
    robj *set;

    /* Get the count argument */
    if (getPositiveLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;
    count = (unsigned long) l;

    /* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set. Otherwise, return nil */
    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.emptyset[c->resp]))
        == NULL || checkType(c,set,OBJ_SET)) return;

    /* If count is zero, serve an empty set ASAP to avoid special
     * cases later. */
    if (count == 0) {
        addReply(c,shared.emptyset[c->resp]);
        return;
    }

    size = setTypeSize(set);

    /* Generate an SPOP keyspace notification */
    notifyKeyspaceEvent(NOTIFY_SET,""spop"",c->argv[1],c->db->id);
    server.dirty += (count >= size) ? size : count;

    /* CASE 1:
     * The number of requested elements is greater than or equal to
     * the number of elements inside the ...",1,66,t_set.c,spopWithCountCommand,,false,761,966,spopWithCountCommand,,,29,void spopWithCountCommand (client*)
429505,METHOD,t_set.c:<global>,TYPE_DECL,"void spopCommand(client *c) {
    robj *set, *ele;

    if (c->argc == 3) {
        spopWithCountCommand(c);
        return;
    } else if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Make sure a key with the name inputted exists, and that it's type is
     * indeed a set */
    if ((set = lookupKeyWriteOrReply(c,c->argv[1],shared.null[c->resp]))
         == NULL || checkType(c,set,OBJ_SET)) return;

    /* Pop a random element from the set */
    ele = setTypePopRandom(set);

    notifyKeyspaceEvent(NOTIFY_SET,""spop"",c->argv[1],c->db->id);

    /* Replicate/AOF this command as an SREM operation */
    rewriteClientCommandVector(c,3,shared.srem,c->argv[1],ele);

    /* Add the element to the reply */
    addReplyBulk(c, ele);
    decrRefCount(ele);

    /* Delete the set if it's empty */
    if (setTypeSize(set) == 0) {
        dbDelete(c->db,c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",c->argv[1],c->db->id);
    }

...",1,36,t_set.c,spopCommand,,false,968,1005,spopCommand,,,30,void spopCommand (client*)
429649,METHOD,t_set.c:<global>,TYPE_DECL,"void srandmemberWithCountCommand(client *c) {
    long l;
    unsigned long count, size;
    int uniq = 1;
    robj *set;
    char *str;
    size_t len;
    int64_t llele;

    dict *d;

    if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
    if (l >= 0) {
        count = (unsigned long) l;
    } else {
        /* A negative count means: return the same elements multiple times
         * (i.e. don't remove the extracted element after every extraction). */
        count = -l;
        uniq = 0;
    }

    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyarray))
        == NULL || checkType(c,set,OBJ_SET)) return;
    size = setTypeSize(set);

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time...",1,82,t_set.c,srandmemberWithCountCommand,,false,1020,1222,srandmemberWithCountCommand,,,31,void srandmemberWithCountCommand (client*)
430249,METHOD,t_set.c:<global>,TYPE_DECL,"void srandmemberCommand(client *c) {
    robj *set;
    char *str;
    size_t len;
    int64_t llele;

    if (c->argc == 3) {
        srandmemberWithCountCommand(c);
        return;
    } else if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Handle variant without <count> argument. Reply with simple bulk string */
    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))
        == NULL || checkType(c,set,OBJ_SET)) return;

    setTypeRandomElement(set, &str, &len, &llele);
    if (str == NULL) {
        addReplyBulkLongLong(c,llele);
    } else {
        addReplyBulkCBuffer(c, str, len);
    }
}",1,35,t_set.c,srandmemberCommand,,false,1225,1249,srandmemberCommand,,,32,void srandmemberCommand (client*)
430333,METHOD,t_set.c:<global>,TYPE_DECL,"int qsortCompareSetsByCardinality(const void *s1, const void *s2) {
    if (setTypeSize(*(robj**)s1) > setTypeSize(*(robj**)s2)) return 1;
    if (setTypeSize(*(robj**)s1) < setTypeSize(*(robj**)s2)) return -1;
    return 0;
}",1,1,t_set.c,qsortCompareSetsByCardinality,,false,1251,1255,qsortCompareSetsByCardinality,,,33,"int qsortCompareSetsByCardinality (void*,void*)"
430372,METHOD,t_set.c:<global>,TYPE_DECL,"int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {
    robj *o1 = *(robj**)s1, *o2 = *(robj**)s2;
    unsigned long first = o1 ? setTypeSize(o1) : 0;
    unsigned long second = o2 ? setTypeSize(o2) : 0;

    if (first < second) return 1;
    if (first > second) return -1;
    return 0;
}",1,1,t_set.c,qsortCompareSetsByRevCardinality,,false,1259,1267,qsortCompareSetsByRevCardinality,,,34,"int qsortCompareSetsByRevCardinality (void*,void*)"
430425,METHOD,t_set.c:<global>,TYPE_DECL,"void sinterGenericCommand(client *c, robj **setkeys,
                          unsigned long setnum, robj *dstkey,
                          int cardinality_only, unsigned long limit) {
    robj **sets = zmalloc(sizeof(robj*)*setnum);
    setTypeIterator *si;
    robj *dstset = NULL;
    char *str;
    size_t len;
    int64_t intobj;
    void *replylen = NULL;
    unsigned long j, cardinality = 0;
    int encoding, empty = 0;

    for (j = 0; j < setnum; j++) {
        robj *setobj = lookupKeyRead(c->db, setkeys[j]);
        if (!setobj) {
            /* A NULL is considered an empty set */
            empty += 1;
            sets[j] = NULL;
            continue;
        }
        if (checkType(c,setobj,OBJ_SET)) {
            zfree(sets);
            return;
        }
        sets[j] = setobj;
    }

    /* Set intersection with an empty set always results in an empty set.
     * Return ASAP if there is an empty set. */
    if (empty > 0) {
        zfree(sets);
        if (dstkey) ...",1,31,t_set.c,sinterGenericCommand,,false,1277,1438,sinterGenericCommand,,,35,"void sinterGenericCommand (client*,robj**,long unsigned,robj*,int,long unsigned)"
430931,METHOD,t_set.c:<global>,TYPE_DECL,"void sinterCommand(client *c) {
    sinterGenericCommand(c, c->argv+1,  c->argc-1, NULL, 0, 0);
}",1,1,t_set.c,sinterCommand,,false,1441,1443,sinterCommand,,,36,void sinterCommand (client*)
430951,METHOD,t_set.c:<global>,TYPE_DECL,"void sinterCardCommand(client *c) {
    long j;
    long numkeys = 0; /* Number of keys. */
    long limit = 0;   /* 0 means not limit. */

    if (getRangeLongFromObjectOrReply(c, c->argv[1], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;
    if (numkeys > (c->argc - 2)) {
        addReplyError(c, ""Number of keys can't be greater than number of args"");
        return;
    }

    for (j = 2 + numkeys; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->argc - 1) - j;

        if (!strcasecmp(opt, ""LIMIT"") && moreargs) {
            j++;
            if (getPositiveLongFromObjectOrReply(c, c->argv[j], &limit,
                                                 ""LIMIT can't be negative"") != C_OK)
                return;
        } else {
            addReplyErrorObject(c, shared.syntaxerr);
            return;
        }
    }

    sinterGenericCommand(c, c->argv+2, numkeys, NULL, 1, l...",1,87,t_set.c,sinterCardCommand,,false,1446,1475,sinterCardCommand,,,37,void sinterCardCommand (client*)
431078,METHOD,t_set.c:<global>,TYPE_DECL,"void sinterstoreCommand(client *c) {
    sinterGenericCommand(c, c->argv+2, c->argc-2, c->argv[1], 0, 0);
}",1,1,t_set.c,sinterstoreCommand,,false,1478,1480,sinterstoreCommand,,,38,void sinterstoreCommand (client*)
431102,METHOD,t_set.c:<global>,TYPE_DECL,"void sunionDiffGenericCommand(client *c, robj **setkeys, int setnum,
                              robj *dstkey, int op) {
    robj **sets = zmalloc(sizeof(robj*)*setnum);
    setTypeIterator *si;
    robj *dstset = NULL;
    char *str;
    size_t len;
    int64_t llval;
    int encoding;
    int j, cardinality = 0;
    int diff_algo = 1;
    int sameset = 0; 

    for (j = 0; j < setnum; j++) {
        robj *setobj = lookupKeyRead(c->db, setkeys[j]);
        if (!setobj) {
            sets[j] = NULL;
            continue;
        }
        if (checkType(c,setobj,OBJ_SET)) {
            zfree(sets);
            return;
        }
        sets[j] = setobj;
        if (j > 0 && sets[0] == sets[j]) {
            sameset = 1; 
        }
    }

    /* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M) where N is the size of the element first set
     * and M the total number of sets.
     *
     * Algorithm 2 is O(N) where N is the total number of elements in all
     ...",1,31,t_set.c,sunionDiffGenericCommand,,false,1482,1650,sunionDiffGenericCommand,,,39,"void sunionDiffGenericCommand (client*,robj**,int,robj*,int)"
431690,METHOD,t_set.c:<global>,TYPE_DECL,"void sunionCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_UNION);
}",1,56,t_set.c,sunionCommand,,false,1653,1655,sunionCommand,,,40,void sunionCommand (client*)
431711,METHOD,t_set.c:<global>,TYPE_DECL,"void sunionstoreCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_UNION);
}",1,62,t_set.c,sunionstoreCommand,,false,1658,1660,sunionstoreCommand,,,41,void sunionstoreCommand (client*)
431736,METHOD,t_set.c:<global>,TYPE_DECL,"void sdiffCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+1,c->argc-1,NULL,SET_OP_DIFF);
}",1,56,t_set.c,sdiffCommand,,false,1663,1665,sdiffCommand,,,42,void sdiffCommand (client*)
431757,METHOD,t_set.c:<global>,TYPE_DECL,"void sdiffstoreCommand(client *c) {
    sunionDiffGenericCommand(c,c->argv+2,c->argc-2,c->argv[1],SET_OP_DIFF);
}",1,62,t_set.c,sdiffstoreCommand,,false,1668,1670,sdiffstoreCommand,,,43,void sdiffstoreCommand (client*)
431782,METHOD,t_set.c:<global>,TYPE_DECL,"void sscanCommand(client *c) {
    robj *set;
    unsigned long cursor;

    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
    if ((set = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
        checkType(c,set,OBJ_SET)) return;
    scanGenericCommand(c,set,cursor);
}",1,56,t_set.c,sscanCommand,,false,1672,1680,sscanCommand,,,44,void sscanCommand (client*)
431843,METHOD,t_stream.c:<global>,TYPE_DECL,<global>,1,1,t_stream.c,t_stream.c:<global>,,false,1,4038,<global>,,,1,
431845,METHOD,t_stream.c:<global>,TYPE_DECL,void streamFreeCG(streamCG *cg);,6,31,t_stream.c,streamFreeCG,,false,56,56,streamFreeCG,,,1,void streamFreeCG (streamCG*)
431850,METHOD,t_stream.c:<global>,TYPE_DECL,void streamFreeNACK(streamNACK *na);,6,35,t_stream.c,streamFreeNACK,,false,57,57,streamFreeNACK,,,2,void streamFreeNACK (streamNACK*)
431855,METHOD,t_stream.c:<global>,TYPE_DECL,"size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer);",8,136,t_stream.c,streamReplyWithRangeFromConsumerPEL,,false,58,58,streamReplyWithRangeFromConsumerPEL,,,3,"size_t streamReplyWithRangeFromConsumerPEL (client*,stream*,streamID*,streamID*,size_t,streamConsumer*)"
431865,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given);",5,102,t_stream.c,streamParseStrictIDOrReply,,false,59,59,streamParseStrictIDOrReply,,,4,"int streamParseStrictIDOrReply (client*,robj*,streamID*,uint64_t,int*)"
431874,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq);",5,80,t_stream.c,streamParseIDOrReply,,false,60,60,streamParseIDOrReply,,,5,"int streamParseIDOrReply (client*,robj*,streamID*,uint64_t)"
431882,METHOD,t_stream.c:<global>,TYPE_DECL,"stream *streamNew(void) {
    stream *s = zmalloc(sizeof(*s));
    s->rax = raxNew();
    s->length = 0;
    s->first_id.ms = 0;
    s->first_id.seq = 0;
    s->last_id.ms = 0;
    s->last_id.seq = 0;
    s->max_deleted_entry_id.seq = 0;
    s->max_deleted_entry_id.ms = 0;
    s->entries_added = 0;
    s->cgroups = NULL; /* Created on demand to save memory when not used. */
    return s;
}",1,1,t_stream.c,streamNew,,false,67,80,streamNew,,,6,stream streamNew (void)
431958,METHOD,t_stream.c:<global>,TYPE_DECL,"void freeStream(stream *s) {
    raxFreeWithCallback(s->rax,(void(*)(void*))lpFree);
    if (s->cgroups)
        raxFreeWithCallback(s->cgroups,(void(*)(void*))streamFreeCG);
    zfree(s);
}",1,1,t_stream.c,freeStream,,false,83,88,freeStream,,,7,void freeStream (stream*)
431984,METHOD,t_stream.c:<global>,TYPE_DECL,"unsigned long streamLength(const robj *subject) {
    stream *s = subject->ptr;
    return s->length;
}",1,1,t_stream.c,streamLength,,false,91,94,streamLength,,,8,unsigned long streamLength (robj*)
431999,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamIncrID(streamID *id) {
    int ret = C_OK;
    if (id->seq == UINT64_MAX) {
        if (id->ms == UINT64_MAX) {
            /* Special case where 'id' is the last possible streamID... */
            id->ms = id->seq = 0;
            ret = C_ERR;
        } else {
            id->ms++;
            id->seq = 0;
        }
    } else {
        id->seq++;
    }
    return ret;
}",1,14,t_stream.c,streamIncrID,,false,99,114,streamIncrID,,,9,int streamIncrID (streamID*)
432058,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamDecrID(streamID *id) {
    int ret = C_OK;
    if (id->seq == 0) {
        if (id->ms == 0) {
            /* Special case where 'id' is the first possible streamID... */
            id->ms = id->seq = UINT64_MAX;
            ret = C_ERR;
        } else {
            id->ms--;
            id->seq = UINT64_MAX;
        }
    } else {
        id->seq--;
    }
    return ret;
}",1,14,t_stream.c,streamDecrID,,false,119,134,streamDecrID,,,10,int streamDecrID (streamID*)
432117,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamNextID(streamID *last_id, streamID *new_id) {
    uint64_t ms = commandTimeSnapshot();
    if (ms > last_id->ms) {
        new_id->ms = ms;
        new_id->seq = 0;
    } else {
        *new_id = *last_id;
        streamIncrID(new_id);
    }
}",1,1,t_stream.c,streamNextID,,false,140,149,streamNextID,,,11,"void streamNextID (streamID*,streamID*)"
432153,METHOD,t_stream.c:<global>,TYPE_DECL,"robj *streamDup(robj *o) {
    robj *sobj;

    serverAssert(o->type == OBJ_STREAM);

    switch (o->encoding) {
        case OBJ_ENCODING_STREAM:
            sobj = createStreamObject();
            break;
        default:
            serverPanic(""Wrong encoding."");
            break;
    }

    stream *s;
    stream *new_s;
    s = o->ptr;
    new_s = sobj->ptr;

    raxIterator ri;
    uint64_t rax_key[2];
    raxStart(&ri, s->rax);
    raxSeek(&ri, ""^"", NULL, 0);
    size_t lp_bytes = 0;      /* Total bytes in the listpack. */
    unsigned char *lp = NULL; /* listpack pointer. */
    /* Get a reference to the listpack node. */
    while (raxNext(&ri)) {
        lp = ri.data;
        lp_bytes = lpBytes(lp);
        unsigned char *new_lp = zmalloc(lp_bytes);
        memcpy(new_lp, lp, lp_bytes);
        memcpy(rax_key, ri.key, sizeof(rax_key));
        raxInsert(new_s->rax, (unsigned char *)&rax_key, sizeof(rax_key),
                  new_lp, NULL);
    }
    new_s->length = s->le...",1,4,t_stream.c,streamDup,,false,156,258,streamDup,,,12,robj streamDup (robj*)
432586,METHOD,t_stream.c:<global>,TYPE_DECL,"static inline int64_t lpGetIntegerIfValid(unsigned char *ele, int *valid) {
    int64_t v;
    unsigned char *e = lpGet(ele,&v,NULL);
    if (e == NULL) {
        if (valid)
            *valid = 1;
        return v;
    }
    /* The following code path should never be used for how listpacks work:
     * they should always be able to store an int64_t value in integer
     * encoded form. However the implementation may change. */
    long long ll;
    int ret = string2ll((char*)e,v,&ll);
    if (valid)
        *valid = ret;
    else
        serverAssert(ret != 0);
    v = ll;
    return v;
}",1,8,t_stream.c,lpGetIntegerIfValid,,false,266,285,lpGetIntegerIfValid,,,13,"int64_t lpGetIntegerIfValid (unsigned char*,int*)"
432656,METHOD,t_stream.c:<global>,TYPE_DECL,"int lpGetEdgeStreamID(unsigned char *lp, int first, streamID *master_id, streamID *edge_id)
{
   if (lp == NULL)
       return 0;

   unsigned char *lp_ele;

   /* We need to seek either the first or the last entry depending
    * on the direction of the iteration. */
   if (first) {
       /* Get the master fields count. */
       lp_ele = lpFirst(lp);        /* Seek items count */
       lp_ele = lpNext(lp, lp_ele); /* Seek deleted count. */
       lp_ele = lpNext(lp, lp_ele); /* Seek num fields. */
       int64_t master_fields_count = lpGetInteger(lp_ele);
       lp_ele = lpNext(lp, lp_ele); /* Seek first field. */

       /* If we are iterating in normal order, skip the master fields
        * to seek the first actual entry. */
       for (int64_t i = 0; i < master_fields_count; i++)
           lp_ele = lpNext(lp, lp_ele);

       /* If we are going forward, skip the previous entry's
        * lp-count field (or in case of the master entry, the zero
        * term field) */
    ...",1,37,t_stream.c,lpGetEdgeStreamID,,false,291,346,lpGetEdgeStreamID,,,14,"int lpGetEdgeStreamID (unsigned char*,int,streamID*,streamID*)"
432802,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamLogListpackContent(unsigned char *lp) {
    unsigned char *p = lpFirst(lp);
    while(p) {
        unsigned char buf[LP_INTBUF_SIZE];
        int64_t v;
        unsigned char *ele = lpGet(p,&v,buf);
        serverLog(LL_WARNING,""- [%d] '%.*s'"", (int)v, (int)v, ele);
        p = lpNext(lp,p);
    }
}",1,26,t_stream.c,streamLogListpackContent,,false,350,359,streamLogListpackContent,,,15,void streamLogListpackContent (unsigned char*)
432855,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamEncodeID(void *buf, streamID *id) {
    uint64_t e[2];
    e[0] = htonu64(id->ms);
    e[1] = htonu64(id->seq);
    memcpy(buf,e,sizeof(e));
}",1,11,t_stream.c,streamEncodeID,,false,363,368,streamEncodeID,,,16,"void streamEncodeID (void*,streamID*)"
432893,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamDecodeID(void *buf, streamID *id) {
    uint64_t e[2];
    memcpy(e,buf,sizeof(e));
    id->ms = ntohu64(e[0]);
    id->seq = ntohu64(e[1]);
}",1,13,t_stream.c,streamDecodeID,,false,373,378,streamDecodeID,,,17,"void streamDecodeID (void*,streamID*)"
432931,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamCompareID(streamID *a, streamID *b) {
    if (a->ms > b->ms) return 1;
    else if (a->ms < b->ms) return -1;
    /* The ms part is the same. Check the sequence part. */
    else if (a->seq > b->seq) return 1;
    else if (a->seq < b->seq) return -1;
    /* Everything is the same: IDs are equal. */
    return 0;
}",1,1,t_stream.c,streamCompareID,,false,381,389,streamCompareID,,,18,"int streamCompareID (streamID*,streamID*)"
432991,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)
{
    streamIterator si;
    int64_t numfields;
    streamIteratorStart(&si,s,NULL,NULL,!first);
    si.skip_tombstones = skip_tombstones;
    int found = streamIteratorGetID(&si,edge_id,&numfields);
    if (!found) {
        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};
        *edge_id = first ? max_id : min_id;
    }
    streamIteratorStop(&si);
}",1,1,t_stream.c,streamGetEdgeID,,false,394,406,streamGetEdgeID,,,19,"void streamGetEdgeID (stream*,int,int,streamID*)"
433049,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id, int seq_given) {

    /* Generate the new entry ID. */
    streamID id;
    if (use_id) {
        if (seq_given) {
            id = *use_id;
        } else {
            /* The automatically generated sequence can be either zero (new
             * timestamps) or the incremented sequence of the last ID. In the
             * latter case, we need to prevent an overflow/advancing forward
             * in time. */
            if (s->last_id.ms == use_id->ms) {
                if (s->last_id.seq == UINT64_MAX) {
                    errno = EDOM;
                    return C_ERR;
                }
                id = s->last_id;
                id.seq++;
            } else {
                id = *use_id;
            }
        }
    } else {
        streamNextID(&s->last_id,&id);
    }

    /* Check that the new ID is greater than the last entry ID
     * or return an error. Automatical...",1,27,t_stream.c,streamAppendItem,,false,427,670,streamAppendItem,,,20,"int streamAppendItem (stream*,robj**,int64_t,streamID*,streamID*,int)"
433807,METHOD,t_stream.c:<global>,TYPE_DECL,"int64_t streamTrim(stream *s, streamAddTrimArgs *args) {
    size_t maxlen = args->maxlen;
    streamID *id = &args->minid;
    int approx = args->approx_trim;
    int64_t limit = args->limit;
    int trim_strategy = args->trim_strategy;

    if (trim_strategy == TRIM_STRATEGY_NONE)
        return 0;

    raxIterator ri;
    raxStart(&ri,s->rax);
    raxSeek(&ri,""^"",NULL,0);

    int64_t deleted = 0;
    while (raxNext(&ri)) {
        if (trim_strategy == TRIM_STRATEGY_MAXLEN && s->length <= maxlen)
            break;

        unsigned char *lp = ri.data, *p = lpFirst(lp);
        int64_t entries = lpGetInteger(p);

        /* Check if we exceeded the amount of work we could do */
        if (limit && (deleted + entries) > limit)
            break;

        /* Check if we can remove the whole node. */
        int remove_node;
        streamID master_id = {0}; /* For MINID */
        if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
            remove_node = s->length - entries >= maxlen;...",1,25,t_stream.c,streamTrim,,false,719,878,streamTrim,,,23,"int64_t streamTrim (stream*,streamAddTrimArgs*)"
434366,METHOD,t_stream.c:<global>,TYPE_DECL,"int64_t streamTrimByLength(stream *s, long long maxlen, int approx) {
    streamAddTrimArgs args = {
        .trim_strategy = TRIM_STRATEGY_MAXLEN,
        .approx_trim = approx,
        .limit = approx ? 100 * server.stream_node_max_entries : 0,
        .maxlen = maxlen
    };
    return streamTrim(s, &args);
}",1,25,t_stream.c,streamTrimByLength,,false,881,889,streamTrimByLength,,,24,"int64_t streamTrimByLength (stream*,long long,int)"
434407,METHOD,t_stream.c:<global>,TYPE_DECL,"int64_t streamTrimByID(stream *s, streamID minid, int approx) {
    streamAddTrimArgs args = {
        .trim_strategy = TRIM_STRATEGY_MINID,
        .approx_trim = approx,
        .limit = approx ? 100 * server.stream_node_max_entries : 0,
        .minid = minid
    };
    return streamTrim(s, &args);
}",1,25,t_stream.c,streamTrimByID,,false,892,900,streamTrimByID,,,25,"int64_t streamTrimByID (stream*,streamID,int)"
434448,METHOD,t_stream.c:<global>,TYPE_DECL,"static int streamParseAddOrTrimArgsOrReply(client *c, streamAddTrimArgs *args, int xadd) {
    /* Initialize arguments to defaults */
    memset(args, 0, sizeof(*args));

    /* Parse options. */
    int i = 2; /* This is the first argument position where we could
                  find an option, or the ID. */
    int limit_given = 0;
    for (; i < c->argc; i++) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (xadd && opt[0] == '*' && opt[1] == '\0') {
            /* This is just a fast path for the common case of auto-ID
             * creation. */
            break;
        } else if (!strcasecmp(opt,""maxlen"") && moreargs) {
            if (args->trim_strategy != TRIM_STRATEGY_NONE) {
                addReplyError(c,""syntax error, MAXLEN and MINID options at the same time are not compatible"");
                return -1;
            }
            args->approx_trim = 0;
            char *next = c->argv...",1,39,t_stream.c,streamParseAddOrTrimArgsOrReply,,false,908,1040,streamParseAddOrTrimArgsOrReply,,,26,"int streamParseAddOrTrimArgsOrReply (client*,streamAddTrimArgs*,int)"
435001,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamIteratorStart(streamIterator *si, stream *s, streamID *start, streamID *end, int rev) {
    /* Initialize the iterator and translates the iteration start/stop
     * elements into a 128 big big-endian number. */
    if (start) {
        streamEncodeID(si->start_key,start);
    } else {
        si->start_key[0] = 0;
        si->start_key[1] = 0;
    }

    if (end) {
        streamEncodeID(si->end_key,end);
    } else {
        si->end_key[0] = UINT64_MAX;
        si->end_key[1] = UINT64_MAX;
    }

    /* Seek the correct node in the radix tree. */
    raxStart(&si->ri,s->rax);
    if (!rev) {
        if (start && (start->ms || start->seq)) {
            raxSeek(&si->ri,""<="",(unsigned char*)si->start_key,
                    sizeof(si->start_key));
            if (raxEOF(&si->ri)) raxSeek(&si->ri,""^"",NULL,0);
        } else {
            raxSeek(&si->ri,""^"",NULL,0);
        }
    } else {
        if (end && (end->ms || end->seq)) {
            raxSeek(&si->ri,""<="",(unsign...",1,1,t_stream.c,streamIteratorStart,,false,1063,1104,streamIteratorStart,,,27,"void streamIteratorStart (streamIterator*,stream*,streamID*,streamID*,int)"
435199,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamIteratorGetID(streamIterator *si, streamID *id, int64_t *numfields) {
    while(1) { /* Will stop when element > stop_key or end of radix tree. */
        /* If the current listpack is set to NULL, this is the start of the
         * iteration or the previous listpack was completely iterated.
         * Go to the next node. */
        if (si->lp == NULL || si->lp_ele == NULL) {
            if (!si->rev && !raxNext(&si->ri)) return 0;
            else if (si->rev && !raxPrev(&si->ri)) return 0;
            serverAssert(si->ri.key_len == sizeof(streamID));
            /* Get the master ID. */
            streamDecodeID(si->ri.key,&si->master_id);
            /* Get the master fields count. */
            si->lp = si->ri.data;
            si->lp_ele = lpFirst(si->lp);           /* Seek items count */
            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek deleted count. */
            si->lp_ele = lpNext(si->lp,si->lp_ele); /* Seek num fields. */
            si->master_fi...",1,12,t_stream.c,streamIteratorGetID,,false,1109,1247,streamIteratorGetID,,,28,"int streamIteratorGetID (streamIterator*,streamID*,int64_t*)"
435869,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamIteratorGetField(streamIterator *si, unsigned char **fieldptr, unsigned char **valueptr, int64_t *fieldlen, int64_t *valuelen) {
    if (si->entry_flags & STREAM_ITEM_FLAG_SAMEFIELDS) {
        *fieldptr = lpGet(si->master_fields_ptr,fieldlen,si->field_buf);
        si->master_fields_ptr = lpNext(si->lp,si->master_fields_ptr);
    } else {
        *fieldptr = lpGet(si->lp_ele,fieldlen,si->field_buf);
        si->lp_ele = lpNext(si->lp,si->lp_ele);
    }
    *valueptr = lpGet(si->lp_ele,valuelen,si->value_buf);
    si->lp_ele = lpNext(si->lp,si->lp_ele);
}",1,26,t_stream.c,streamIteratorGetField,,false,1255,1265,streamIteratorGetField,,,29,"void streamIteratorGetField (streamIterator*,unsigned char**,unsigned char**,int64_t*,int64_t*)"
435957,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
    unsigned char *lp = si->lp;
    int64_t aux;

    /* We do not really delete the entry here. Instead we mark it as
     * deleted by flagging it, and also incrementing the count of the
     * deleted entries in the listpack header.
     *
     * We start flagging: */
    int64_t flags = lpGetInteger(si->lp_flags);
    flags |= STREAM_ITEM_FLAG_DELETED;
    lp = lpReplaceInteger(lp,&si->lp_flags,flags);

    /* Change the valid/deleted entries count in the master entry. */
    unsigned char *p = lpFirst(lp);
    aux = lpGetInteger(p);

    if (aux == 1) {
        /* If this is the last element in the listpack, we can remove the whole
         * node. */
        lpFree(lp);
        raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);
    } else {
        /* In the base case we alter the counters of valid/deleted entries. */
        lp = lpReplaceInteger(lp,&p,aux-1);
        p = lpNext(lp,p); /* Seek del...",1,20,t_stream.c,streamIteratorRemoveEntry,,false,1277,1328,streamIteratorRemoveEntry,,,30,"void streamIteratorRemoveEntry (streamIterator*,streamID*)"
436143,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamIteratorStop(streamIterator *si) {
    raxStop(&si->ri);
}",1,1,t_stream.c,streamIteratorStop,,false,1333,1335,streamIteratorStop,,,31,void streamIteratorStop (streamIterator*)
436153,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamEntryExists(stream *s, streamID *id) {
    streamIterator si;
    streamIteratorStart(&si,s,id,id,0);
    streamID myid;
    int64_t numfields;
    int found = streamIteratorGetID(&si,&myid,&numfields);
    streamIteratorStop(&si);
    if (!found)
        return 0;
    serverAssert(streamCompareID(id,&myid) == 0);
    return 1;
}",1,4,t_stream.c,streamEntryExists,,false,1338,1349,streamEntryExists,,,32,"int streamEntryExists (stream*,streamID*)"
436209,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamDeleteItem(stream *s, streamID *id) {
    int deleted = 0;
    streamIterator si;
    streamIteratorStart(&si,s,id,id,0);
    streamID myid;
    int64_t numfields;
    if (streamIteratorGetID(&si,&myid,&numfields)) {
        streamIteratorRemoveEntry(&si,&myid);
        deleted = 1;
    }
    streamIteratorStop(&si);
    return deleted;
}",1,1,t_stream.c,streamDeleteItem,,false,1353,1365,streamDeleteItem,,,33,"int streamDeleteItem (stream*,streamID*)"
436251,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamLastValidID(stream *s, streamID *maxid)
{
    streamIterator si;
    streamIteratorStart(&si,s,NULL,NULL,1);
    int64_t numfields;
    if (!streamIteratorGetID(&si,maxid,&numfields) && s->length)
        serverPanic(""Corrupt stream, length is %llu, but no max id"", (unsigned long long)s->length);
    streamIteratorStop(&si);
}",1,8,t_stream.c,streamLastValidID,,false,1368,1376,streamLastValidID,,,34,"void streamLastValidID (stream*,streamID*)"
436295,METHOD,t_stream.c:<global>,TYPE_DECL,"sds createStreamIDString(streamID *id) {
    /* Optimization: pre-allocate a big enough buffer to avoid reallocs. */
    sds str = sdsnewlen(SDS_NOINIT, STREAM_ID_STR_LEN);
    sdssetlen(str, 0);
    return sdscatfmt(str,""%U-%U"", id->ms,id->seq);
}",1,36,t_stream.c,createStreamIDString,,false,1385,1390,createStreamIDString,,,35,sds createStreamIDString (streamID*)
436321,METHOD,t_stream.c:<global>,TYPE_DECL,"void addReplyStreamID(client *c, streamID *id) {
    addReplyBulkSds(c,createStreamIDString(id));
}",1,1,t_stream.c,addReplyStreamID,,false,1395,1397,addReplyStreamID,,,36,"void addReplyStreamID (client*,streamID*)"
436331,METHOD,t_stream.c:<global>,TYPE_DECL,"void setDeferredReplyStreamID(client *c, void *dr, streamID *id) {
    setDeferredReplyBulkSds(c, dr, createStreamIDString(id));
}",1,1,t_stream.c,setDeferredReplyStreamID,,false,1399,1401,setDeferredReplyStreamID,,,37,"void setDeferredReplyStreamID (client*,void*,streamID*)"
436343,METHOD,t_stream.c:<global>,TYPE_DECL,"robj *createObjectFromStreamID(streamID *id) {
    return createObject(OBJ_STRING, createStreamIDString(id));
}",1,24,t_stream.c,createObjectFromStreamID,,false,1405,1407,createObjectFromStreamID,,,38,robj createObjectFromStreamID (streamID*)
436355,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamIDEqZero(streamID *id) {
    return !(id->ms || id->seq);
}",1,1,t_stream.c,streamIDEqZero,,false,1410,1412,streamIDEqZero,,,39,int streamIDEqZero (streamID*)
436369,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamRangeHasTombstones(stream *s, streamID *start, streamID *end) {
    streamID start_id, end_id;

    if (!s->length || streamIDEqZero(&s->max_deleted_entry_id)) {
        /* The stream is empty or has no tombstones. */
        return 0;
    }

    if (streamCompareID(&s->first_id,&s->max_deleted_entry_id) > 0) {
        /* The latest tombstone is before the first entry. */
        return 0;
    }

    if (start) {
        start_id = *start;
    } else {
        start_id.ms = 0;
        start_id.seq = 0;
    }

    if (end) {
        end_id = *end;
    } else {
        end_id.ms = UINT64_MAX;
        end_id.seq = UINT64_MAX;
    }

    if (streamCompareID(&start_id,&s->max_deleted_entry_id) <= 0 &&
        streamCompareID(&s->max_deleted_entry_id,&end_id) <= 0)
    {
        /* start_id <= max_deleted_entry_id <= end_id: The range does include a tombstone. */
        return 1;
    }

    /* The range doesn't includes a tombstone. */
    return 0;
}",1,1,t_stream.c,streamRangeHasTombstones,,false,1419,1455,streamRangeHasTombstones,,,40,"int streamRangeHasTombstones (stream*,streamID*,streamID*)"
436470,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamReplyWithCGLag(client *c, stream *s, streamCG *cg) {
    int valid = 0;
    long long lag = 0;

    if (!s->entries_added) {
        /* The lag of a newly-initialized stream is 0. */
        lag = 0;
        valid = 1;
    } else if (cg->entries_read != SCG_INVALID_ENTRIES_READ && !streamRangeHasTombstones(s,&cg->last_id,NULL)) {
        /* No fragmentation ahead means that the group's logical reads counter
         * is valid for performing the lag calculation. */
        lag = (long long)s->entries_added - cg->entries_read;
        valid = 1;
    } else {
        /* Attempt to retrieve the group's last ID logical read counter. */
        long long entries_read = streamEstimateDistanceFromFirstEverEntry(s,&cg->last_id);
        if (entries_read != SCG_INVALID_ENTRIES_READ) {
            /* A valid counter was obtained. */
            lag = (long long)s->entries_added - entries_read;
            valid = 1;
        }
    }

    if (valid) {
        addReplyLongLong(c,lag);...",1,35,t_stream.c,streamReplyWithCGLag,,false,1460,1488,streamReplyWithCGLag,,,41,"void streamReplyWithCGLag (client*,stream*,streamCG*)"
436573,METHOD,t_stream.c:<global>,TYPE_DECL,"long long streamEstimateDistanceFromFirstEverEntry(stream *s, streamID *id) {
    /* The counter of any ID in an empty, never-before-used stream is 0. */
    if (!s->entries_added) {
        return 0;
    }

    /* In the empty stream, if the ID is smaller or equal to the last ID,
     * it can set to the current added_entries value. */
    if (!s->length && streamCompareID(id,&s->last_id) < 1) {
        return s->entries_added;
    }

    int cmp_last = streamCompareID(id,&s->last_id);
    if (cmp_last == 0) {
        /* Return the exact counter of the last entry in the stream. */
        return s->entries_added;
    } else if (cmp_last > 0) {
        /* The counter of a future ID is unknown. */
        return SCG_INVALID_ENTRIES_READ;
    }

    int cmp_id_first = streamCompareID(id,&s->first_id);
    int cmp_xdel_first = streamCompareID(&s->max_deleted_entry_id,&s->first_id);
    if (streamIDEqZero(&s->max_deleted_entry_id) || cmp_xdel_first < 0) {
        /* There's definitely n...",1,15,t_stream.c,streamEstimateDistanceFromFirstEverEntry,,false,1512,1549,streamEstimateDistanceFromFirstEverEntry,,,42,"long long streamEstimateDistanceFromFirstEverEntry (stream*,streamID*)"
436703,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamPropagateXCLAIM(client *c, robj *key, streamCG *group, robj *groupname, robj *id, streamNACK *nack) {
    /* We need to generate an XCLAIM that will work in a idempotent fashion:
     *
     * XCLAIM <key> <group> <consumer> 0 <id> TIME <milliseconds-unix-time>
     *        RETRYCOUNT <count> FORCE JUSTID LASTID <id>.
     *
     * Note that JUSTID is useful in order to avoid that XCLAIM will do
     * useless work in the slave side, trying to fetch the stream item. */
    robj *argv[14];
    argv[0] = shared.xclaim;
    argv[1] = key;
    argv[2] = groupname;
    argv[3] = createStringObject(nack->consumer->name,sdslen(nack->consumer->name));
    argv[4] = shared.integers[0];
    argv[5] = id;
    argv[6] = shared.time;
    argv[7] = createStringObjectFromLongLong(nack->delivery_time);
    argv[8] = shared.retrycount;
    argv[9] = createStringObjectFromLongLong(nack->delivery_count);
    argv[10] = shared.force;
    argv[11] = shared.justid;
    argv[12] = shared.lasti...",1,36,t_stream.c,streamPropagateXCLAIM,,false,1554,1584,streamPropagateXCLAIM,,,43,"void streamPropagateXCLAIM (client*,robj*,streamCG*,robj*,robj*,streamNACK*)"
436852,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamPropagateGroupID(client *c, robj *key, streamCG *group, robj *groupname) {
    robj *argv[7];
    argv[0] = shared.xgroup;
    argv[1] = shared.setid;
    argv[2] = key;
    argv[3] = groupname;
    argv[4] = createObjectFromStreamID(&group->last_id);
    argv[5] = shared.entriesread;
    argv[6] = createStringObjectFromLongLong(group->entries_read);

    alsoPropagate(c->db->id,argv,7,PROPAGATE_AOF|PROPAGATE_REPL);

    decrRefCount(argv[4]);
    decrRefCount(argv[6]);
}",1,35,t_stream.c,streamPropagateGroupID,,false,1592,1606,streamPropagateGroupID,,,44,"void streamPropagateGroupID (client*,robj*,streamCG*,robj*)"
436932,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamPropagateConsumerCreation(client *c, robj *key, robj *groupname, sds consumername) {
    robj *argv[5];
    argv[0] = shared.xgroup;
    argv[1] = shared.createconsumer;
    argv[2] = key;
    argv[3] = groupname;
    argv[4] = createObject(OBJ_STRING,sdsdup(consumername));

    alsoPropagate(c->db->id,argv,5,PROPAGATE_AOF|PROPAGATE_REPL);

    decrRefCount(argv[4]);
}",1,27,t_stream.c,streamPropagateConsumerCreation,,false,1614,1625,streamPropagateConsumerCreation,,,45,"void streamPropagateConsumerCreation (client*,robj*,robj*,sds)"
436994,METHOD,t_stream.c:<global>,TYPE_DECL,"size_t streamReplyWithRange(client *c, stream *s, streamID *start, streamID *end, size_t count, int rev, streamCG *group, streamConsumer *consumer, int flags, streamPropInfo *spi) {
    void *arraylen_ptr = NULL;
    size_t arraylen = 0;
    streamIterator si;
    int64_t numfields;
    streamID id;
    int propagate_last_id = 0;
    int noack = flags & STREAM_RWR_NOACK;

    /* If the client is asking for some history, we serve it using a
     * different function, so that we return entries *solely* from its
     * own PEL. This ensures each consumer will always and only see
     * the history of messages delivered to it and not yet confirmed
     * as delivered. */
    if (group && (flags & STREAM_RWR_HISTORY)) {
        return streamReplyWithRangeFromConsumerPEL(c,s,start,end,count,
                                                   consumer);
    }

    if (!(flags & STREAM_RWR_RAWENTRIES))
        arraylen_ptr = addReplyDeferredLen(c);
    streamIteratorStart(&si,s,start,end,re...",1,24,t_stream.c,streamReplyWithRange,,false,1679,1796,streamReplyWithRange,,,46,"size_t streamReplyWithRange (client*,stream*,streamID*,streamID*,size_t,int,streamCG*,streamConsumer*,int,streamPropInfo*)"
437369,METHOD,t_stream.c:<global>,TYPE_DECL,"size_t streamReplyWithRangeFromConsumerPEL(client *c, stream *s, streamID *start, streamID *end, size_t count, streamConsumer *consumer) {
    raxIterator ri;
    unsigned char startkey[sizeof(streamID)];
    unsigned char endkey[sizeof(streamID)];
    streamEncodeID(startkey,start);
    if (end) streamEncodeID(endkey,end);

    size_t arraylen = 0;
    void *arraylen_ptr = addReplyDeferredLen(c);
    raxStart(&ri,consumer->pel);
    raxSeek(&ri,"">="",startkey,sizeof(startkey));
    while(raxNext(&ri) && (!count || arraylen < count)) {
        if (end && memcmp(ri.key,end,ri.key_len) > 0) break;
        streamID thisid;
        streamDecodeID(ri.key,&thisid);
        if (streamReplyWithRange(c,s,&thisid,&thisid,1,0,NULL,NULL,
                                 STREAM_RWR_RAWENTRIES,NULL) == 0)
        {
            /* Note that we may have a not acknowledged entry in the PEL
             * about a message that's no longer here because was removed
             * by the user by other mea...",1,33,t_stream.c,streamReplyWithRangeFromConsumerPEL,,false,1811,1846,streamReplyWithRangeFromConsumerPEL,,,47,"size_t streamReplyWithRangeFromConsumerPEL (client*,stream*,streamID*,streamID*,size_t,streamConsumer*)"
437505,METHOD,t_stream.c:<global>,TYPE_DECL,"robj *streamTypeLookupWriteOrCreate(client *c, robj *key, int no_create) {
    robj *o = lookupKeyWrite(c->db,key);
    if (checkType(c,o,OBJ_STREAM)) return NULL;
    if (o == NULL) {
        if (no_create) {
            addReplyNull(c);
            return NULL;
        }
        o = createStreamObject();
        dbAdd(c->db,key,o);
    }
    return o;
}",1,22,t_stream.c,streamTypeLookupWriteOrCreate,,false,1854,1866,streamTypeLookupWriteOrCreate,,,48,"robj streamTypeLookupWriteOrCreate (client*,robj*,int)"
437553,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamGenericParseIDOrReply(client *c, const robj *o, streamID *id, uint64_t missing_seq, int strict, int *seq_given) {
    char buf[128];
    if (sdslen(o->ptr) > sizeof(buf)-1) goto invalid;
    memcpy(buf,o->ptr,sdslen(o->ptr)+1);

    if (strict && (buf[0] == '-' || buf[0] == '+') && buf[1] == '\0')
        goto invalid;

    if (seq_given != NULL) {
        *seq_given = 1;
    }

    /* Handle the ""-"" and ""+"" special cases. */
    if (buf[0] == '-' && buf[1] == '\0') {
        id->ms = 0;
        id->seq = 0;
        return C_OK;
    } else if (buf[0] == '+' && buf[1] == '\0') {
        id->ms = UINT64_MAX;
        id->seq = UINT64_MAX;
        return C_OK;
    }

    /* Parse <ms>-<seq> form. */
    unsigned long long ms, seq;
    char *dot = strchr(buf,'-');
    if (dot) *dot = '\0';
    if (string2ull(buf,&ms) == 0) goto invalid;
    if (dot) {
        size_t seqlen = strlen(dot+1);
        if (seq_given != NULL && seqlen == 1 && *(dot + 1) == '*') {
            /* Handl...",1,15,t_stream.c,streamGenericParseIDOrReply,,false,1885,1933,streamGenericParseIDOrReply,,,49,"int streamGenericParseIDOrReply (client*,robj*,streamID*,uint64_t,int,int*)"
437775,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamParseID(const robj *o, streamID *id) {
    return streamGenericParseIDOrReply(NULL,o,id,0,0,NULL);
}",1,1,t_stream.c,streamParseID,,false,1936,1938,streamParseID,,,50,"int streamParseID (robj*,streamID*)"
437789,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamParseIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq) {
    return streamGenericParseIDOrReply(c,o,id,missing_seq,0,NULL);
}",1,1,t_stream.c,streamParseIDOrReply,,false,1942,1944,streamParseIDOrReply,,,51,"int streamParseIDOrReply (client*,robj*,streamID*,uint64_t)"
437805,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamParseStrictIDOrReply(client *c, robj *o, streamID *id, uint64_t missing_seq, int *seq_given) {
    return streamGenericParseIDOrReply(c,o,id,missing_seq,1,seq_given);
}",1,1,t_stream.c,streamParseStrictIDOrReply,,false,1949,1951,streamParseStrictIDOrReply,,,52,"int streamParseStrictIDOrReply (client*,robj*,streamID*,uint64_t,int*)"
437822,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamParseIntervalIDOrReply(client *c, robj *o, streamID *id, int *exclude, uint64_t missing_seq) {
    char *p = o->ptr;
    size_t len = sdslen(p);
    int invalid = 0;
    
    if (exclude != NULL) *exclude = (len > 1 && p[0] == '(');
    if (exclude != NULL && *exclude) {
        robj *t = createStringObject(p+1,len-1);
        invalid = (streamParseStrictIDOrReply(c,t,id,missing_seq,NULL) == C_ERR);
        decrRefCount(t);
    } else 
        invalid = (streamParseIDOrReply(c,o,id,missing_seq) == C_ERR);
    if (invalid)
        return C_ERR;
    return C_OK;
}",1,74,t_stream.c,streamParseIntervalIDOrReply,,false,1959,1974,streamParseIntervalIDOrReply,,,53,"int streamParseIntervalIDOrReply (client*,robj*,streamID*,int*,uint64_t)"
437922,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamRewriteApproxSpecifier(client *c, int idx) {
    rewriteClientCommandArgument(c,idx,shared.special_equals);
}",1,1,t_stream.c,streamRewriteApproxSpecifier,,false,1976,1978,streamRewriteApproxSpecifier,,,54,"void streamRewriteApproxSpecifier (client*,int)"
437934,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamRewriteTrimArgument(client *c, stream *s, int trim_strategy, int idx) {
    robj *arg;
    if (trim_strategy == TRIM_STRATEGY_MAXLEN) {
        arg = createStringObjectFromLongLong(s->length);
    } else {
        streamID first_id;
        streamGetEdgeID(s,1,0,&first_id);
        arg = createObjectFromStreamID(&first_id);
    }

    rewriteClientCommandArgument(c,idx,arg);
    decrRefCount(arg);
}",1,25,t_stream.c,streamRewriteTrimArgument,,false,1982,1994,streamRewriteTrimArgument,,,55,"void streamRewriteTrimArgument (client*,stream*,int,int)"
437976,METHOD,t_stream.c:<global>,TYPE_DECL,"void xaddCommand(client *c) {
    /* Parse options. */
    streamAddTrimArgs parsed_args;
    int idpos = streamParseAddOrTrimArgsOrReply(c, &parsed_args, 1);
    if (idpos < 0)
        return; /* streamParseAddOrTrimArgsOrReply already replied. */
    int field_pos = idpos+1; /* The ID is always one argument before the first field */

    /* Check arity. */
    if ((c->argc - field_pos) < 2 || ((c->argc-field_pos) % 2) == 1) {
        addReplyErrorArity(c);
        return;
    }

    /* Return ASAP if minimal ID (0-0) was given so we avoid possibly creating
     * a new stream and have streamAppendItem fail, leaving an empty key in the
     * database. */
    if (parsed_args.id_given && parsed_args.seq_given &&
        parsed_args.id.ms == 0 && parsed_args.id.seq == 0)
    {
        addReplyError(c,""The ID specified in XADD must be greater than 0-0"");
        return;
    }

    /* Lookup the stream at key. */
    robj *o;
    stream *s;
    if ((o = streamTypeLookupWriteOrCreate(c,...",1,84,t_stream.c,xaddCommand,,false,1997,2084,xaddCommand,,,56,void xaddCommand (client*)
438303,METHOD,t_stream.c:<global>,TYPE_DECL,"void xrangeGenericCommand(client *c, int rev) {
    robj *o;
    stream *s;
    streamID startid, endid;
    long long count = -1;
    robj *startarg = rev ? c->argv[3] : c->argv[2];
    robj *endarg = rev ? c->argv[2] : c->argv[3];
    int startex = 0, endex = 0;
    
    /* Parse start and end IDs. */
    if (streamParseIntervalIDOrReply(c,startarg,&startid,&startex,0) != C_OK)
        return;
    if (startex && streamIncrID(&startid) != C_OK) {
        addReplyError(c,""invalid start ID for the interval"");
        return;
    }
    if (streamParseIntervalIDOrReply(c,endarg,&endid,&endex,UINT64_MAX) != C_OK)
        return;
    if (endex && streamDecrID(&endid) != C_OK) {
        addReplyError(c,""invalid end ID for the interval"");
        return;
    }

    /* Parse the COUNT option if any. */
    if (c->argc > 4) {
        for (int j = 4; j < c->argc; j++) {
            int additional = c->argc-j-1;
            if (strcasecmp(c->argv[j]->ptr,""COUNT"") == 0 && additional >= 1) {
   ...",1,72,t_stream.c,xrangeGenericCommand,,false,2093,2144,xrangeGenericCommand,,,57,"void xrangeGenericCommand (client*,int)"
438561,METHOD,t_stream.c:<global>,TYPE_DECL,"void xrangeCommand(client *c) {
    xrangeGenericCommand(c,0);
}",1,1,t_stream.c,xrangeCommand,,false,2147,2149,xrangeCommand,,,58,void xrangeCommand (client*)
438569,METHOD,t_stream.c:<global>,TYPE_DECL,"void xrevrangeCommand(client *c) {
    xrangeGenericCommand(c,1);
}",1,1,t_stream.c,xrevrangeCommand,,false,2152,2154,xrevrangeCommand,,,59,void xrevrangeCommand (client*)
438577,METHOD,t_stream.c:<global>,TYPE_DECL,"void xlenCommand(client *c) {
    robj *o;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    stream *s = o->ptr;
    addReplyLongLong(c,s->length);
}",1,25,t_stream.c,xlenCommand,,false,2157,2163,xlenCommand,,,60,void xlenCommand (client*)
438618,METHOD,t_stream.c:<global>,TYPE_DECL,"void xreadCommand(client *c) {
    long long timeout = -1; /* -1 means, no BLOCK argument given. */
    long long count = 0;
    int streams_count = 0;
    int streams_arg = 0;
    int noack = 0;          /* True if NOACK option was specified. */
    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
    streamID *ids = static_ids;
    streamCG **groups = NULL;
    int xreadgroup = sdslen(c->argv[0]->ptr) == 10; /* XREAD or XREADGROUP? */
    robj *groupname = NULL;
    robj *consumername = NULL;

    /* Parse arguments. */
    for (int i = 1; i < c->argc; i++) {
        int moreargs = c->argc-i-1;
        char *o = c->argv[i]->ptr;
        if (!strcasecmp(o,""BLOCK"") && moreargs) {
            if (c->flags & CLIENT_SCRIPT) {
                /*
                 * Although the CLIENT_DENY_BLOCKING flag should protect from blocking the client
                 * on Lua/MULTI/RM_Call we want special treatment for Lua to keep backward compatibility.
                 * There is no sense to u...",1,24,t_stream.c,xreadCommand,,false,2173,2444,xreadCommand,,,61,void xreadCommand (client*)
439585,METHOD,t_stream.c:<global>,TYPE_DECL,"streamNACK *streamCreateNACK(streamConsumer *consumer) {
    streamNACK *nack = zmalloc(sizeof(*nack));
    nack->delivery_time = commandTimeSnapshot();
    nack->delivery_count = 1;
    nack->consumer = consumer;
    return nack;
}",1,1,t_stream.c,streamCreateNACK,,false,2453,2459,streamCreateNACK,,,62,streamNACK streamCreateNACK (streamConsumer*)
439614,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamFreeNACK(streamNACK *na) {
    zfree(na);
}",1,1,t_stream.c,streamFreeNACK,,false,2462,2464,streamFreeNACK,,,63,void streamFreeNACK (streamNACK*)
439621,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamFreeConsumer(streamConsumer *sc) {
    raxFree(sc->pel); /* No value free callback: the PEL entries are shared
                         between the consumer and the main stream PEL. */
    sdsfree(sc->name);
    zfree(sc);
}",1,1,t_stream.c,streamFreeConsumer,,false,2471,2476,streamFreeConsumer,,,64,void streamFreeConsumer (streamConsumer*)
439636,METHOD,t_stream.c:<global>,TYPE_DECL,"streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {
    if (s->cgroups == NULL) s->cgroups = raxNew();
    if (raxFind(s->cgroups,(unsigned char*)name,namelen) != raxNotFound)
        return NULL;

    streamCG *cg = zmalloc(sizeof(*cg));
    cg->pel = raxNew();
    cg->consumers = raxNew();
    cg->last_id = *id;
    cg->entries_read = entries_read;
    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);
    return cg;
}",1,1,t_stream.c,streamCreateCG,,false,2482,2494,streamCreateCG,,,65,"streamCG streamCreateCG (stream*,char*,size_t,streamID*,long long)"
439711,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}",1,1,t_stream.c,streamFreeCG,,false,2497,2501,streamFreeCG,,,66,void streamFreeCG (streamCG*)
439732,METHOD,t_stream.c:<global>,TYPE_DECL,"streamCG *streamLookupCG(stream *s, sds groupname) {
    if (s->cgroups == NULL) return NULL;
    streamCG *cg = raxFind(s->cgroups,(unsigned char*)groupname,
                           sdslen(groupname));
    return (cg == raxNotFound) ? NULL : cg;
}",1,1,t_stream.c,streamLookupCG,,false,2505,2510,streamLookupCG,,,67,"streamCG streamLookupCG (stream*,sds)"
439766,METHOD,t_stream.c:<global>,TYPE_DECL,"streamConsumer *streamCreateConsumer(streamCG *cg, sds name, robj *key, int dbid, int flags) {
    if (cg == NULL) return NULL;
    int notify = !(flags & SCC_NO_NOTIFY);
    int dirty = !(flags & SCC_NO_DIRTIFY);
    streamConsumer *consumer = zmalloc(sizeof(*consumer));
    int success = raxTryInsert(cg->consumers,(unsigned char*)name,
                               sdslen(name),consumer,NULL);
    if (!success) {
        zfree(consumer);
        return NULL;
    }
    consumer->name = sdsdup(name);
    consumer->pel = raxNew();
    consumer->active_time = -1;
    consumer->seen_time = commandTimeSnapshot();
    if (dirty) server.dirty++;
    if (notify) notifyKeyspaceEvent(NOTIFY_STREAM,""xgroup-createconsumer"",key,dbid);
    return consumer;
}",1,27,t_stream.c,streamCreateConsumer,,false,2516,2534,streamCreateConsumer,,,68,"streamConsumer streamCreateConsumer (streamCG*,sds,robj*,int,int)"
439876,METHOD,t_stream.c:<global>,TYPE_DECL,"streamConsumer *streamLookupConsumer(streamCG *cg, sds name) {
    if (cg == NULL) return NULL;
    streamConsumer *consumer = raxFind(cg->consumers,(unsigned char*)name,
                                       sdslen(name));
    if (consumer == raxNotFound) return NULL;
    return consumer;
}",1,1,t_stream.c,streamLookupConsumer,,false,2537,2543,streamLookupConsumer,,,69,"streamConsumer streamLookupConsumer (streamCG*,sds)"
439910,METHOD,t_stream.c:<global>,TYPE_DECL,"void streamDelConsumer(streamCG *cg, streamConsumer *consumer) {
    /* Iterate all the consumer pending messages, deleting every corresponding
     * entry from the global entry. */
    raxIterator ri;
    raxStart(&ri,consumer->pel);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        streamNACK *nack = ri.data;
        raxRemove(cg->pel,ri.key,ri.key_len,NULL);
        streamFreeNACK(nack);
    }
    raxStop(&ri);

    /* Deallocate the consumer. */
    raxRemove(cg->consumers,(unsigned char*)consumer->name,
              sdslen(consumer->name),NULL);
    streamFreeConsumer(consumer);
}",1,1,t_stream.c,streamDelConsumer,,false,2546,2563,streamDelConsumer,,,70,"void streamDelConsumer (streamCG*,streamConsumer*)"
439972,METHOD,t_stream.c:<global>,TYPE_DECL,"void xgroupCommand(client *c) {
    stream *s = NULL;
    sds grpname = NULL;
    streamCG *cg = NULL;
    char *opt = c->argv[1]->ptr; /* Subcommand name. */
    int mkstream = 0;
    long long entries_read = SCG_INVALID_ENTRIES_READ;
    robj *o;

    /* Everything but the ""HELP"" option requires a key and group name. */
    if (c->argc >= 4) {
        /* Parse optional arguments for CREATE and SETID */
        int i = 5;
        int create_subcmd = !strcasecmp(opt,""CREATE"");
        int setid_subcmd = !strcasecmp(opt,""SETID"");
        while (i < c->argc) {
            if (create_subcmd && !strcasecmp(c->argv[i]->ptr,""MKSTREAM"")) {
                mkstream = 1;
                i++;
            } else if ((create_subcmd || setid_subcmd) && !strcasecmp(c->argv[i]->ptr,""ENTRIESREAD"") && i + 1 < c->argc) {
                if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_read,NULL) != C_OK)
                    return;
                if (entries_read < 0 && entries_read != SCG_I...",1,29,t_stream.c,xgroupCommand,,false,2574,2735,xgroupCommand,,,71,void xgroupCommand (client*)
440709,METHOD,t_stream.c:<global>,TYPE_DECL,"void xsetidCommand(client *c) {
    streamID id, max_xdel_id = {0, 0};
    long long entries_added = -1;

    if (streamParseStrictIDOrReply(c,c->argv[2],&id,0,NULL) != C_OK)
        return;

    int i = 3;
    while (i < c->argc) {
        int moreargs = (c->argc-1) - i; /* Number of additional arguments. */
        char *opt = c->argv[i]->ptr;
        if (!strcasecmp(opt,""ENTRIESADDED"") && moreargs) {
            if (getLongLongFromObjectOrReply(c,c->argv[i+1],&entries_added,NULL) != C_OK) {
                return;
            } else if (entries_added < 0) {
                addReplyError(c,""entries_added must be positive"");
                return;
            }
            i += 2;
        } else if (!strcasecmp(opt,""MAXDELETEDID"") && moreargs) {
            if (streamParseStrictIDOrReply(c,c->argv[i+1],&max_xdel_id,0,NULL) != C_OK) {
                return;
            } else if (streamCompareID(&id,&max_xdel_id) < 0) {
                addReplyError(c,""The ID specified in XSETID i...",1,63,t_stream.c,xsetidCommand,,false,2741,2810,xsetidCommand,,,72,void xsetidCommand (client*)
441015,METHOD,t_stream.c:<global>,TYPE_DECL,"void xackCommand(client *c) {
    streamCG *group = NULL;
    robj *o = lookupKeyRead(c->db,c->argv[1]);
    if (o) {
        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */
        group = streamLookupCG(o->ptr,c->argv[2]->ptr);
    }

    /* No key or group? Nothing to ack. */
    if (o == NULL || group == NULL) {
        addReply(c,shared.czero);
        return;
    }

    /* Start parsing the IDs, so that we abort ASAP if there is a syntax
     * error: the return value of this command cannot be an error in case
     * the client successfully acknowledged some messages, so it should be
     * executed in a ""all or nothing"" fashion. */
    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
    streamID *ids = static_ids;
    int id_count = c->argc-3;
    if (id_count > STREAMID_STATIC_VECTOR_LEN)
        ids = zmalloc(sizeof(streamID)*id_count);
    for (int j = 3; j < c->argc; j++) {
        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-3],0,NULL) != C_OK) goto clean...",1,26,t_stream.c,xackCommand,,false,2820,2867,xackCommand,,,73,void xackCommand (client*)
441218,METHOD,t_stream.c:<global>,TYPE_DECL,"void xpendingCommand(client *c) {
    int justinfo = c->argc == 3; /* Without the range just outputs general
                                    information about the PEL. */
    robj *key = c->argv[1];
    robj *groupname = c->argv[2];
    robj *consumername = NULL;
    streamID startid, endid;
    long long count = 0;
    long long minidle = 0;
    int startex = 0, endex = 0;

    /* Start and stop, and the consumer, can be omitted. Also the IDLE modifier. */
    if (c->argc != 3 && (c->argc < 6 || c->argc > 9)) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    /* Parse start/end/count arguments ASAP if needed, in order to report
     * syntax errors before any other error. */
    if (c->argc >= 6) {
        int startidx = 3; /* Without IDLE */

        if (!strcasecmp(c->argv[3]->ptr, ""IDLE"")) {
            if (getLongLongFromObjectOrReply(c, c->argv[4], &minidle, NULL) == C_ERR)
                return;
            if (c->argc < 8) {
                /*...",1,79,t_stream.c,xpendingCommand,,false,2878,3051,xpendingCommand,,,74,void xpendingCommand (client*)
441837,METHOD,t_stream.c:<global>,TYPE_DECL,"void xclaimCommand(client *c) {
    streamCG *group = NULL;
    robj *o = lookupKeyRead(c->db,c->argv[1]);
    long long minidle; /* Minimum idle time argument. */
    long long retrycount = -1;   /* -1 means RETRYCOUNT option not given. */
    mstime_t deliverytime = -1;  /* -1 means IDLE/TIME options not given. */
    int force = 0;
    int justid = 0;

    if (o) {
        if (checkType(c,o,OBJ_STREAM)) return; /* Type error. */
        group = streamLookupCG(o->ptr,c->argv[2]->ptr);
    }

    /* No key or group? Send an error given that the group creation
     * is mandatory. */
    if (o == NULL || group == NULL) {
        addReplyErrorFormat(c,""-NOGROUP No such key '%s' or ""
                              ""consumer group '%s'"", (char*)c->argv[1]->ptr,
                              (char*)c->argv[2]->ptr);
        return;
    }

    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,
        ""Invalid min-idle-time argument for XCLAIM"")
        != C_OK) return;
    if (minid...",1,26,t_stream.c,xclaimCommand,,false,3119,3320,xclaimCommand,,,75,void xclaimCommand (client*)
442635,METHOD,t_stream.c:<global>,TYPE_DECL,"void xautoclaimCommand(client *c) {
    streamCG *group = NULL;
    robj *o = lookupKeyRead(c->db,c->argv[1]);
    long long minidle; /* Minimum idle time argument, in milliseconds. */
    long count = 100; /* Maximum entries to claim. */
    const unsigned attempts_factor = 10;
    streamID startid;
    int startex;
    int justid = 0;

    /* Parse idle/start/end/count arguments ASAP if needed, in order to report
     * syntax errors before any other error. */
    if (getLongLongFromObjectOrReply(c,c->argv[4],&minidle,""Invalid min-idle-time argument for XAUTOCLAIM"") != C_OK)
        return;
    if (minidle < 0) minidle = 0;

    if (streamParseIntervalIDOrReply(c,c->argv[5],&startid,&startex,0) != C_OK)
        return;
    if (startex && streamIncrID(&startid) != C_OK) {
        addReplyError(c,""invalid start ID for the interval"");
        return;
    }

    int j = 6; /* options start at argv[6] */
    while(j < c->argc) {
        int moreargs = (c->argc-1) - j; /* Number of addi...",1,111,t_stream.c,xautoclaimCommand,,false,3338,3510,xautoclaimCommand,,,76,void xautoclaimCommand (client*)
443320,METHOD,t_stream.c:<global>,TYPE_DECL,"void xdelCommand(client *c) {
    robj *o;

    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    stream *s = o->ptr;

    /* We need to sanity check the IDs passed to start. Even if not
     * a big issue, it is not great that the command is only partially
     * executed because at some point an invalid ID is parsed. */
    streamID static_ids[STREAMID_STATIC_VECTOR_LEN];
    streamID *ids = static_ids;
    int id_count = c->argc-2;
    if (id_count > STREAMID_STATIC_VECTOR_LEN)
        ids = zmalloc(sizeof(streamID)*id_count);
    for (int j = 2; j < c->argc; j++) {
        if (streamParseStrictIDOrReply(c,c->argv[j],&ids[j-2],0,NULL) != C_OK) goto cleanup;
    }

    /* Actually apply the command. */
    int deleted = 0;
    int first_entry = 0;
    for (int j = 2; j < c->argc; j++) {
        streamID *id = &ids[j-2];
        if (streamDeleteItem(s,id)) {
            /* We want to know if the first entry in the s...",1,25,t_stream.c,xdelCommand,,false,3517,3574,xdelCommand,,,77,void xdelCommand (client*)
443569,METHOD,t_stream.c:<global>,TYPE_DECL,"void xtrimCommand(client *c) {
    robj *o;

    /* Argument parsing. */
    streamAddTrimArgs parsed_args;
    if (streamParseAddOrTrimArgsOrReply(c, &parsed_args, 0) < 0)
        return; /* streamParseAddOrTrimArgsOrReply already replied. */

    /* If the key does not exist, we are ok returning zero, that is, the
     * number of elements removed from the stream. */
    if ((o = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL
        || checkType(c,o,OBJ_STREAM)) return;
    stream *s = o->ptr;

    /* Perform the trimming. */
    int64_t deleted = streamTrim(s, &parsed_args);
    if (deleted) {
        notifyKeyspaceEvent(NOTIFY_STREAM,""xtrim"",c->argv[1],c->db->id);
        if (parsed_args.approx_trim) {
            /* In case our trimming was limited (by LIMIT or by ~) we must
             * re-write the relevant trim argument to make sure there will be
             * no inconsistencies in AOF loading or in the replica.
             * It's enough to check only args->a...",1,25,t_stream.c,xtrimCommand,,false,3599,3632,xtrimCommand,,,78,void xtrimCommand (client*)
443682,METHOD,t_stream.c:<global>,TYPE_DECL,"void xinfoReplyWithStreamInfo(client *c, stream *s) {
    int full = 1;
    long long count = 10; /* Default COUNT is 10 so we don't block the server */
    robj **optv = c->argv + 3; /* Options start after XINFO STREAM <key> */
    int optc = c->argc - 3;

    /* Parse options. */
    if (optc == 0) {
        full = 0;
    } else {
        /* Valid options are [FULL] or [FULL COUNT <count>] */
        if (optc != 1 && optc != 3) {
            addReplySubcommandSyntaxError(c);
            return;
        }

        /* First option must be ""FULL"" */
        if (strcasecmp(optv[0]->ptr,""full"")) {
            addReplySubcommandSyntaxError(c);
            return;
        }

        if (optc == 3) {
            /* First option must be ""FULL"" */
            if (strcasecmp(optv[1]->ptr,""count"")) {
                addReplySubcommandSyntaxError(c);
                return;
            }
            if (getLongLongFromObjectOrReply(c,optv[2],&count,NULL) == C_ERR)
                return;
     ...",1,71,t_stream.c,xinfoReplyWithStreamInfo,,false,3636,3839,xinfoReplyWithStreamInfo,,,79,"void xinfoReplyWithStreamInfo (client*,stream*)"
444335,METHOD,t_stream.c:<global>,TYPE_DECL,"void xinfoCommand(client *c) {
    stream *s = NULL;
    char *opt;
    robj *key;

    /* HELP is special. Handle it ASAP. */
    if (!strcasecmp(c->argv[1]->ptr,""HELP"")) {
        const char *help[] = {
""CONSUMERS <key> <groupname>"",
""    Show consumers of <groupname>."",
""GROUPS <key>"",
""    Show the stream consumer groups."",
""STREAM <key> [FULL [COUNT <count>]"",
""    Show information about the stream."",
NULL
        };
        addReplyHelp(c, help);
        return;
    }

    /* With the exception of HELP handled before any other sub commands, all
     * the ones are in the form of ""<subcommand> <key>"". */
    opt = c->argv[1]->ptr;
    key = c->argv[2];

    /* Lookup the key now, this is common for all the subcommands but HELP. */
    robj *o = lookupKeyReadOrReply(c,key,shared.nokeyerr);
    if (o == NULL || checkType(c,o,OBJ_STREAM)) return;
    s = o->ptr;

    /* Dispatch the different subcommands. */
    if (!strcasecmp(opt,""CONSUMERS"") && c->argc == 4) {
        /* XINFO ...",1,35,t_stream.c,xinfoCommand,,false,3845,3946,xinfoCommand,,,80,void xinfoCommand (client*)
444713,METHOD,t_stream.c:<global>,TYPE_DECL,"int streamValidateListpackIntegrity(unsigned char *lp, size_t size, int deep) {
    int valid_record;
    unsigned char *p, *next;

    /* Since we don't want to run validation of all records twice, we'll
     * run the listpack validation of just the header and do the rest here. */
    if (!lpValidateIntegrity(lp, size, 0, NULL, NULL))
        return 0;

    /* In non-deep mode we just validated the listpack header (encoded size) */
    if (!deep) return 1;

    next = p = lpValidateFirst(lp);
    if (!lpValidateNext(lp, &next, size)) return 0;
    if (!p) return 0;

    /* entry count */
    int64_t entry_count = lpGetIntegerIfValid(p, &valid_record);
    if (!valid_record) return 0;
    p = next; if (!lpValidateNext(lp, &next, size)) return 0;

    /* deleted */
    int64_t deleted_count = lpGetIntegerIfValid(p, &valid_record);
    if (!valid_record) return 0;
    p = next; if (!lpValidateNext(lp, &next, size)) return 0;

    /* num-of-fields */
    int64_t master_fields = lpGetI...",1,22,t_stream.c,streamValidateListpackIntegrity,,false,3951,4038,streamValidateListpackIntegrity,,,81,"int streamValidateListpackIntegrity (unsigned char*,size_t,int)"
445127,METHOD,t_string.c:<global>,TYPE_DECL,<global>,1,1,t_string.c,t_string.c:<global>,,false,1,950,<global>,,,1,
445129,METHOD,t_string.c:<global>,TYPE_DECL,int getGenericCommand(client *c);,5,32,t_string.c,getGenericCommand,,false,34,34,getGenericCommand,,,1,int getGenericCommand (client*)
445134,METHOD,t_string.c:<global>,TYPE_DECL,"static int checkStringLength(client *c, long long size, long long append) {
    if (mustObeyClient(c))
        return C_OK;
    /* 'uint64_t' cast is there just to prevent undefined behavior on overflow */
    long long total = (uint64_t)size + append;
    /* Test configured max-bulk-len represending a limit of the biggest string object,
     * and also test for overflow. */
    if (total > server.proto_max_bulk_len || total < size || total < append) {
        addReplyError(c,""string exceeds maximum allowed size (proto-max-bulk-len)"");
        return C_ERR;
    }
    return C_OK;
}",1,15,t_string.c,checkStringLength,,false,40,52,checkStringLength,,,2,"int checkStringLength (client*,long long,long long)"
445184,METHOD,t_string.c:<global>,TYPE_DECL,"static int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds);",12,110,t_string.c,getExpireMillisecondsOrReply,,false,82,82,getExpireMillisecondsOrReply,,,3,"int getExpireMillisecondsOrReply (client*,robj*,int,int,long long*)"
445193,METHOD,t_string.c:<global>,TYPE_DECL,"void setGenericCommand(client *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {
    long long milliseconds = 0; /* initialized to avoid any harmness warning */
    int found = 0;
    int setkey_flags = 0;

    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {
        return;
    }

    if (flags & OBJ_SET_GET) {
        if (getGenericCommand(c) == C_ERR) return;
    }

    found = (lookupKeyWrite(c->db,key) != NULL);

    if ((flags & OBJ_SET_NX && found) ||
        (flags & OBJ_SET_XX && !found))
    {
        if (!(flags & OBJ_SET_GET)) {
            addReply(c, abort_reply ? abort_reply : shared.null[c->resp]);
        }
        return;
    }

    /* When expire is not NULL, we avoid deleting the TTL so it can be updated later instead of being deleted and then created again. */
    setkey_flags |= ((flags & OBJ_KEEPTTL) || expire) ? SETKEY_KEEPTTL : 0;
    setkey_flags |= found ? SETKEY_ALR...",1,89,t_string.c,setGenericCommand,,false,84,150,setGenericCommand,,,4,"void setGenericCommand (client*,int,robj*,robj*,robj*,int,robj*,robj*)"
445547,METHOD,t_string.c:<global>,TYPE_DECL,"static int getExpireMillisecondsOrReply(client *c, robj *expire, int flags, int unit, long long *milliseconds) {
    int ret = getLongLongFromObjectOrReply(c, expire, milliseconds, NULL);
    if (ret != C_OK) {
        return ret;
    }

    if (*milliseconds <= 0 || (unit == UNIT_SECONDS && *milliseconds > LLONG_MAX / 1000)) {
        /* Negative value provided or multiplication is gonna overflow. */
        addReplyErrorExpireTime(c);
        return C_ERR;
    }

    if (unit == UNIT_SECONDS) *milliseconds *= 1000;

    if ((flags & OBJ_PX) || (flags & OBJ_EX)) {
        *milliseconds += commandTimeSnapshot();
    }

    if (*milliseconds <= 0) {
        /* Overflow detected. */
        addReplyErrorExpireTime(c);
        return C_ERR;
    }

    return C_OK;
}",1,15,t_string.c,getExpireMillisecondsOrReply,,false,164,189,getExpireMillisecondsOrReply,,,5,"int getExpireMillisecondsOrReply (client*,robj*,int,int,long long*)"
445648,METHOD,t_string.c:<global>,TYPE_DECL,"int parseExtendedStringArgumentsOrReply(client *c, int *flags, int *unit, robj **expire, int command_type) {

    int j = command_type == COMMAND_GET ? 2 : 3;
    for (; j < c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        robj *next = (j == c->argc-1) ? NULL : c->argv[j+1];

        if ((opt[0] == 'n' || opt[0] == 'N') &&
            (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\0' &&
            !(*flags & OBJ_SET_XX) && (command_type == COMMAND_SET))
        {
            *flags |= OBJ_SET_NX;
        } else if ((opt[0] == 'x' || opt[0] == 'X') &&
                   (opt[1] == 'x' || opt[1] == 'X') && opt[2] == '\0' &&
                   !(*flags & OBJ_SET_NX) && (command_type == COMMAND_SET))
        {
            *flags |= OBJ_SET_XX;
        } else if ((opt[0] == 'g' || opt[0] == 'G') &&
                   (opt[1] == 'e' || opt[1] == 'E') &&
                   (opt[2] == 't' || opt[2] == 'T') && opt[3] == '\0' &&
                   (command_type == COMMAND_SET))
...",1,28,t_string.c,parseExtendedStringArgumentsOrReply,,false,209,291,parseExtendedStringArgumentsOrReply,,,6,"int parseExtendedStringArgumentsOrReply (client*,int*,int*,robj**,int)"
446494,METHOD,t_string.c:<global>,TYPE_DECL,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",1,15,t_string.c,setCommand,,false,295,306,setCommand,,,7,void setCommand (client*)
446562,METHOD,t_string.c:<global>,TYPE_DECL,"void setnxCommand(client *c) {
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,OBJ_SET_NX,c->argv[1],c->argv[2],NULL,0,shared.cone,shared.czero);
}",1,24,t_string.c,setnxCommand,,false,308,311,setnxCommand,,,8,void setnxCommand (client*)
446604,METHOD,t_string.c:<global>,TYPE_DECL,"void setexCommand(client *c) {
    c->argv[3] = tryObjectEncoding(c->argv[3]);
    setGenericCommand(c,OBJ_EX,c->argv[1],c->argv[3],c->argv[2],UNIT_SECONDS,NULL,NULL);
}",1,24,t_string.c,setexCommand,,false,313,316,setexCommand,,,9,void setexCommand (client*)
446648,METHOD,t_string.c:<global>,TYPE_DECL,"void psetexCommand(client *c) {
    c->argv[3] = tryObjectEncoding(c->argv[3]);
    setGenericCommand(c,OBJ_PX,c->argv[1],c->argv[3],c->argv[2],UNIT_MILLISECONDS,NULL,NULL);
}",1,24,t_string.c,psetexCommand,,false,318,321,psetexCommand,,,10,void psetexCommand (client*)
446692,METHOD,t_string.c:<global>,TYPE_DECL,"int getGenericCommand(client *c) {
    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)
        return C_OK;

    if (checkType(c,o,OBJ_STRING)) {
        return C_ERR;
    }

    addReplyBulk(c,o);
    return C_OK;
}",1,15,t_string.c,getGenericCommand,,false,323,335,getGenericCommand,,,11,int getGenericCommand (client*)
446742,METHOD,t_string.c:<global>,TYPE_DECL,"void getCommand(client *c) {
    getGenericCommand(c);
}",1,1,t_string.c,getCommand,,false,337,339,getCommand,,,12,void getCommand (client*)
446749,METHOD,t_string.c:<global>,TYPE_DECL,"void getexCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_GET) != C_OK) {
        return;
    }

    robj *o;

    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp])) == NULL)
        return;

    if (checkType(c,o,OBJ_STRING)) {
        return;
    }

    /* Validate the expiration time value first */
    long long milliseconds = 0;
    if (expire && getExpireMillisecondsOrReply(c, expire, flags, unit, &milliseconds) != C_OK) {
        return;
    }

    /* We need to do this before we expire the key or delete it */
    addReplyBulk(c,o);

    /* This command is never propagated as is. It is either propagated as PEXPIRE[AT],DEL,UNLINK or PERSIST.
     * This why it doesn't need special handling in feedAppendOnlyFile to convert relative expire time to absolute one. */
    if (((flags & OBJ_PXAT) || (flags & OBJ_EXAT)) && checkAlreadyExpir...",1,15,t_string.c,getexCommand,,false,361,418,getexCommand,,,13,void getexCommand (client*)
447080,METHOD,t_string.c:<global>,TYPE_DECL,"void getdelCommand(client *c) {
    if (getGenericCommand(c) == C_ERR) return;
    if (dbSyncDelete(c->db, c->argv[1])) {
        /* Propagate as DEL command */
        rewriteClientCommandVector(c,2,shared.del,c->argv[1]);
        signalModifiedKey(c, c->db, c->argv[1]);
        notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", c->argv[1], c->db->id);
        server.dirty++;
    }
}",1,32,t_string.c,getdelCommand,,false,420,429,getdelCommand,,,14,void getdelCommand (client*)
447148,METHOD,t_string.c:<global>,TYPE_DECL,"void getsetCommand(client *c) {
    if (getGenericCommand(c) == C_ERR) return;
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setKey(c,c->db,c->argv[1],c->argv[2],0);
    notifyKeyspaceEvent(NOTIFY_STRING,""set"",c->argv[1],c->db->id);
    server.dirty++;

    /* Propagate as SET command */
    rewriteClientCommandArgument(c,0,shared.set);
}",1,32,t_string.c,getsetCommand,,false,431,440,getsetCommand,,,15,void getsetCommand (client*)
447218,METHOD,t_string.c:<global>,TYPE_DECL,"void setrangeCommand(client *c) {
    robj *o;
    long offset;
    sds value = c->argv[3]->ptr;

    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)
        return;

    if (offset < 0) {
        addReplyError(c,""offset is out of range"");
        return;
    }

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (o == NULL) {
        /* Return 0 when setting nothing on a non-existing string */
        if (sdslen(value) == 0) {
            addReply(c,shared.czero);
            return;
        }

        /* Return when the resulting string exceeds allowed size */
        if (checkStringLength(c,offset,sdslen(value)) != C_OK)
            return;

        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));
        dbAdd(c->db,c->argv[1],o);
    } else {
        size_t olen;

        /* Key exists, check type */
        if (checkType(c,o,OBJ_STRING))
            return;

        /* Return existing string length when setting nothing */
        olen = stringO...",1,63,t_string.c,setrangeCommand,,false,442,500,setrangeCommand,,,16,void setrangeCommand (client*)
447439,METHOD,t_string.c:<global>,TYPE_DECL,"void getrangeCommand(client *c) {
    robj *o;
    long long start, end;
    char *str, llbuf[32];
    size_t strlen;

    if (getLongLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK)
        return;
    if (getLongLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK)
        return;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptybulk)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;

    if (o->encoding == OBJ_ENCODING_INT) {
        str = llbuf;
        strlen = ll2string(llbuf,sizeof(llbuf),(long)o->ptr);
    } else {
        str = o->ptr;
        strlen = sdslen(str);
    }

    /* Convert negative indexes */
    if (start < 0 && end < 0 && start > end) {
        addReply(c,shared.emptybulk);
        return;
    }
    if (start < 0) start = strlen+start;
    if (end < 0) end = strlen+end;
    if (start < 0) start = 0;
    if (end < 0) end = 0;
    if ((unsigned long long)end >= strlen) end = strlen-1;

    /* Precondition: end >= 0 && end < strlen, so t...",1,66,t_string.c,getrangeCommand,,false,502,541,getrangeCommand,,,17,void getrangeCommand (client*)
447637,METHOD,t_string.c:<global>,TYPE_DECL,"void mgetCommand(client *c) {
    int j;

    addReplyArrayLen(c,c->argc-1);
    for (j = 1; j < c->argc; j++) {
        robj *o = lookupKeyRead(c->db,c->argv[j]);
        if (o == NULL) {
            addReplyNull(c);
        } else {
            if (o->type != OBJ_STRING) {
                addReplyNull(c);
            } else {
                addReplyBulk(c,o);
            }
        }
    }
}",1,27,t_string.c,mgetCommand,,false,543,559,mgetCommand,,,18,void mgetCommand (client*)
447700,METHOD,t_string.c:<global>,TYPE_DECL,"void msetGenericCommand(client *c, int nx) {
    int j;

    if ((c->argc % 2) == 0) {
        addReplyErrorArity(c);
        return;
    }

    /* Handle the NX flag. The MSETNX semantic is to return zero and don't
     * set anything if at least one key already exists. */
    if (nx) {
        for (j = 1; j < c->argc; j += 2) {
            if (lookupKeyWrite(c->db,c->argv[j]) != NULL) {
                addReply(c, shared.czero);
                return;
            }
        }
    }

    int setkey_flags = nx ? SETKEY_DOESNT_EXIST : 0;
    for (j = 1; j < c->argc; j += 2) {
        c->argv[j+1] = tryObjectEncoding(c->argv[j+1]);
        setKey(c, c->db, c->argv[j], c->argv[j + 1], setkey_flags);
        notifyKeyspaceEvent(NOTIFY_STRING,""set"",c->argv[j],c->db->id);
        /* In MSETNX, It could be that we're overriding the same key, we can't be sure it doesn't exist. */
        if (nx)
            setkey_flags = SETKEY_ADD_OR_UPDATE;
    }
    server.dirty += (c->argc-1)/2;
    ad...",1,28,t_string.c,msetGenericCommand,,false,561,591,msetGenericCommand,,,19,"void msetGenericCommand (client*,int)"
447858,METHOD,t_string.c:<global>,TYPE_DECL,"void msetCommand(client *c) {
    msetGenericCommand(c,0);
}",1,1,t_string.c,msetCommand,,false,593,595,msetCommand,,,20,void msetCommand (client*)
447866,METHOD,t_string.c:<global>,TYPE_DECL,"void msetnxCommand(client *c) {
    msetGenericCommand(c,1);
}",1,1,t_string.c,msetnxCommand,,false,597,599,msetnxCommand,,,21,void msetnxCommand (client*)
447874,METHOD,t_string.c:<global>,TYPE_DECL,"void incrDecrCommand(client *c, long long incr) {
    long long value, oldvalue;
    robj *o, *new;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return;
    if (getLongLongFromObjectOrReply(c,o,&value,NULL) != C_OK) return;

    oldvalue = value;
    if ((incr < 0 && oldvalue < 0 && incr < (LLONG_MIN-oldvalue)) ||
        (incr > 0 && oldvalue > 0 && incr > (LLONG_MAX-oldvalue))) {
        addReplyError(c,""increment or decrement would overflow"");
        return;
    }
    value += incr;

    if (o && o->refcount == 1 && o->encoding == OBJ_ENCODING_INT &&
        (value < 0 || value >= OBJ_SHARED_INTEGERS) &&
        value >= LONG_MIN && value <= LONG_MAX)
    {
        new = o;
        o->ptr = (void*)((long)value);
    } else {
        new = createStringObjectFromLongLongForValue(value);
        if (o) {
            dbReplaceValue(c->db,c->argv[1],new);
        } else {
            dbAdd(c->db,c->argv[1],new);
        }
    }
    signalModifiedKey(c...",1,22,t_string.c,incrDecrCommand,,false,601,635,incrDecrCommand,,,22,"void incrDecrCommand (client*,long long)"
448068,METHOD,t_string.c:<global>,TYPE_DECL,"void incrCommand(client *c) {
    incrDecrCommand(c,1);
}",1,1,t_string.c,incrCommand,,false,637,639,incrCommand,,,23,void incrCommand (client*)
448076,METHOD,t_string.c:<global>,TYPE_DECL,"void decrCommand(client *c) {
    incrDecrCommand(c,-1);
}",1,1,t_string.c,decrCommand,,false,641,643,decrCommand,,,24,void decrCommand (client*)
448085,METHOD,t_string.c:<global>,TYPE_DECL,"void incrbyCommand(client *c) {
    long long incr;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
    incrDecrCommand(c,incr);
}",1,68,t_string.c,incrbyCommand,,false,645,650,incrbyCommand,,,25,void incrbyCommand (client*)
448111,METHOD,t_string.c:<global>,TYPE_DECL,"void decrbyCommand(client *c) {
    long long incr;

    if (getLongLongFromObjectOrReply(c, c->argv[2], &incr, NULL) != C_OK) return;
    /* Overflow check: negating LLONG_MIN will cause an overflow */
    if (incr == LLONG_MIN) {
        addReplyError(c, ""decrement would overflow"");
        return;
    }
    incrDecrCommand(c,-incr);
}",1,68,t_string.c,decrbyCommand,,false,652,662,decrbyCommand,,,26,void decrbyCommand (client*)
448147,METHOD,t_string.c:<global>,TYPE_DECL,"void incrbyfloatCommand(client *c) {
    long double incr, value;
    robj *o, *new;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (checkType(c,o,OBJ_STRING)) return;
    if (getLongDoubleFromObjectOrReply(c,o,&value,NULL) != C_OK ||
        getLongDoubleFromObjectOrReply(c,c->argv[2],&incr,NULL) != C_OK)
        return;

    value += incr;
    if (isnan(value) || isinf(value)) {
        addReplyError(c,""increment would produce NaN or Infinity"");
        return;
    }
    new = createStringObjectFromLongDouble(value,1);
    if (o)
        dbReplaceValue(c->db,c->argv[1],new);
    else
        dbAdd(c->db,c->argv[1],new);
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,""incrbyfloat"",c->argv[1],c->db->id);
    server.dirty++;
    addReplyBulk(c,new);

    /* Always replicate INCRBYFLOAT as a SET command with the final value
     * in order to make sure that differences in float precision or formatting
     * will not create differences in replicas ...",1,22,t_string.c,incrbyfloatCommand,,false,664,695,incrbyfloatCommand,,,27,void incrbyfloatCommand (client*)
448298,METHOD,t_string.c:<global>,TYPE_DECL,"void appendCommand(client *c) {
    size_t totlen;
    robj *o, *append;

    o = lookupKeyWrite(c->db,c->argv[1]);
    if (o == NULL) {
        /* Create the key */
        c->argv[2] = tryObjectEncoding(c->argv[2]);
        dbAdd(c->db,c->argv[1],c->argv[2]);
        incrRefCount(c->argv[2]);
        totlen = stringObjectLen(c->argv[2]);
    } else {
        /* Key exists, check type */
        if (checkType(c,o,OBJ_STRING))
            return;

        /* ""append"" is an argument, so always an sds */
        append = c->argv[2];
        if (checkStringLength(c,stringObjectLen(o),sdslen(append->ptr)) != C_OK)
            return;

        /* Append the value */
        o = dbUnshareStringValue(c->db,c->argv[1],o);
        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));
        totlen = sdslen(o->ptr);
    }
    signalModifiedKey(c,c->db,c->argv[1]);
    notifyKeyspaceEvent(NOTIFY_STRING,""append"",c->argv[1],c->db->id);
    server.dirty++;
    addReplyLongLong(c,totlen);
}",1,26,t_string.c,appendCommand,,false,697,727,appendCommand,,,28,void appendCommand (client*)
448462,METHOD,t_string.c:<global>,TYPE_DECL,"void strlenCommand(client *c) {
    robj *o;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.czero)) == NULL ||
        checkType(c,o,OBJ_STRING)) return;
    addReplyLongLong(c,stringObjectLen(o));
}",1,22,t_string.c,strlenCommand,,false,729,734,strlenCommand,,,29,void strlenCommand (client*)
448496,METHOD,t_string.c:<global>,TYPE_DECL,"void lcsCommand(client *c) {
    uint32_t i, j;
    long long minmatchlen = 0;
    sds a = NULL, b = NULL;
    int getlen = 0, getidx = 0, withmatchlen = 0;
    robj *obja = NULL, *objb = NULL;

    obja = lookupKeyRead(c->db,c->argv[1]);
    objb = lookupKeyRead(c->db,c->argv[2]);
    if ((obja && obja->type != OBJ_STRING) ||
        (objb && objb->type != OBJ_STRING))
    {
        addReplyError(c,
            ""The specified keys must contain string values"");
        /* Don't cleanup the objects, we need to do that
         * only after calling getDecodedObject(). */
        obja = NULL;
        objb = NULL;
        goto cleanup;
    }
    obja = obja ? getDecodedObject(obja) : createStringObject("""",0);
    objb = objb ? getDecodedObject(objb) : createStringObject("""",0);
    a = obja->ptr;
    b = objb->ptr;

    for (j = 3; j < (uint32_t)c->argc; j++) {
        char *opt = c->argv[j]->ptr;
        int moreargs = (c->argc-1) - j;

        if (!strcasecmp(opt,""IDX"")) {
            ...",1,31,t_string.c,lcsCommand,,false,737,950,lcsCommand,,,30,void lcsCommand (client*)
449348,METHOD,t_zset.c:<global>,TYPE_DECL,<global>,1,1,t_zset.c,t_zset.c:<global>,,false,1,4460,<global>,,,1,
449350,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslLexValueGteMin(sds value, zlexrangespec *spec);",5,53,t_zset.c,zslLexValueGteMin,,false,67,67,zslLexValueGteMin,,,1,"int zslLexValueGteMin (sds,zlexrangespec*)"
449356,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslLexValueLteMax(sds value, zlexrangespec *spec);",5,53,t_zset.c,zslLexValueLteMax,,false,68,68,zslLexValueLteMax,,,2,"int zslLexValueLteMax (sds,zlexrangespec*)"
449362,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetConvertAndExpand(robj *zobj, int encoding, unsigned long cap);",6,70,t_zset.c,zsetConvertAndExpand,,false,69,69,zsetConvertAndExpand,,,3,"void zsetConvertAndExpand (robj*,int,long unsigned)"
449369,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslCreateNode(int level, double score, sds ele) {
    zskiplistNode *zn =
        zmalloc(sizeof(*zn)+level*sizeof(struct zskiplistLevel));
    zn->score = score;
    zn->ele = ele;
    return zn;
}",1,1,t_zset.c,zslCreateNode,,false,73,79,zslCreateNode,,,4,"zskiplistNode zslCreateNode (int,double,sds)"
449400,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplist *zslCreate(void) {
    int j;
    zskiplist *zsl;

    zsl = zmalloc(sizeof(*zsl));
    zsl->level = 1;
    zsl->length = 0;
    zsl->header = zslCreateNode(ZSKIPLIST_MAXLEVEL,0,NULL);
    for (j = 0; j < ZSKIPLIST_MAXLEVEL; j++) {
        zsl->header->level[j].forward = NULL;
        zsl->header->level[j].span = 0;
    }
    zsl->header->backward = NULL;
    zsl->tail = NULL;
    return zsl;
}",1,32,t_zset.c,zslCreate,,false,82,97,zslCreate,,,5,zskiplist zslCreate (void)
449482,METHOD,t_zset.c:<global>,TYPE_DECL,"void zslFreeNode(zskiplistNode *node) {
    sdsfree(node->ele);
    zfree(node);
}",1,1,t_zset.c,zslFreeNode,,false,102,105,zslFreeNode,,,6,void zslFreeNode (zskiplistNode*)
449493,METHOD,t_zset.c:<global>,TYPE_DECL,"void zslFree(zskiplist *zsl) {
    zskiplistNode *node = zsl->header->level[0].forward, *next;

    zfree(zsl->header);
    while(node) {
        next = node->level[0].forward;
        zslFreeNode(node);
        node = next;
    }
    zfree(zsl);
}",1,1,t_zset.c,zslFree,,false,108,118,zslFree,,,7,void zslFree (zskiplist*)
449534,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslRandomLevel(void) {
    static const int threshold = ZSKIPLIST_P*RAND_MAX;
    int level = 1;
    while (random() < threshold)
        level += 1;
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}",1,33,t_zset.c,zslRandomLevel,,false,124,130,zslRandomLevel,,,8,int zslRandomLevel (void)
449569,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* store rank that is crossed to reach the insert position */
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                    sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    /* we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside o...",1,26,t_zset.c,zslInsert,,false,135,190,zslInsert,,,9,"zskiplistNode zslInsert (zskiplist*,double,sds)"
449924,METHOD,t_zset.c:<global>,TYPE_DECL,"void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {
    int i;
    for (i = 0; i < zsl->level; i++) {
        if (update[i]->level[i].forward == x) {
            update[i]->level[i].span += x->level[i].span - 1;
            update[i]->level[i].forward = x->level[i].forward;
        } else {
            update[i]->level[i].span -= 1;
        }
    }
    if (x->level[0].forward) {
        x->level[0].forward->backward = x->backward;
    } else {
        zsl->tail = x->backward;
    }
    while(zsl->level > 1 && zsl->header->level[zsl->level-1].forward == NULL)
        zsl->level--;
    zsl->length--;
}",1,1,t_zset.c,zslDeleteNode,,false,194,212,zslDeleteNode,,,10,"void zslDeleteNode (zskiplist*,zskiplistNode*,zskiplistNode**)"
450068,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < score ||
                    (x->level[i].forward->score == score &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }
    /* We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. */
    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele,ele) == 0) {
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    return 0; /* not found */
}",1,26,t_zset.c,zslDelete,,false,222,249,zslDelete,,,11,"int zslDelete (zskiplist*,double,sds,zskiplistNode**)"
450206,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslUpdateScore(zskiplist *zsl, double curscore, sds ele, double newscore) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    /* We need to seek to element to update to start: this is useful anyway,
     * we'll have to update or remove it. */
    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
                (x->level[i].forward->score < curscore ||
                    (x->level[i].forward->score == curscore &&
                     sdscmp(x->level[i].forward->ele,ele) < 0)))
        {
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    /* Jump to our element: note that this function assumes that the
     * element with the matching score exists. */
    x = x->level[0].forward;
    serverAssert(x && curscore == x->score && sdscmp(x->ele,ele) == 0);

    /* If the node, after the score update, would be still exactly
     * at the same position, we can just update the score w...",1,26,t_zset.c,zslUpdateScore,,false,262,304,zslUpdateScore,,,12,"zskiplistNode zslUpdateScore (zskiplist*,double,sds,double)"
450401,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslValueGteMin(double value, zrangespec *spec) {
    return spec->minex ? (value > spec->min) : (value >= spec->min);
}",1,1,t_zset.c,zslValueGteMin,,false,306,308,zslValueGteMin,,,13,"int zslValueGteMin (double,zrangespec*)"
450422,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslValueLteMax(double value, zrangespec *spec) {
    return spec->maxex ? (value < spec->max) : (value <= spec->max);
}",1,1,t_zset.c,zslValueLteMax,,false,310,312,zslValueLteMax,,,14,"int zslValueLteMax (double,zrangespec*)"
450443,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslIsInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;

    /* Test for ranges that will always be empty. */
    if (range->min > range->max ||
            (range->min == range->max && (range->minex || range->maxex)))
        return 0;
    x = zsl->tail;
    if (x == NULL || !zslValueGteMin(x->score,range))
        return 0;
    x = zsl->header->level[0].forward;
    if (x == NULL || !zslValueLteMax(x->score,range))
        return 0;
    return 1;
}",1,1,t_zset.c,zslIsInRange,,false,315,329,zslIsInRange,,,15,"int zslIsInRange (zskiplist*,zrangespec*)"
450523,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *OUT* of range. */
        while (x->level[i].forward &&
            !zslValueGteMin(x->level[i].forward->score,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so the next node cannot be NULL. */
    x = x->level[0].forward;
    serverAssert(x != NULL);

    /* Check if score <= max. */
    if (!zslValueLteMax(x->score,range)) return NULL;
    return x;
}",1,4,t_zset.c,zslFirstInRange,,false,333,355,zslFirstInRange,,,16,"zskiplistNode zslFirstInRange (zskiplist*,zrangespec*)"
450626,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *IN* range. */
        while (x->level[i].forward &&
            zslValueLteMax(x->level[i].forward->score,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so this node cannot be NULL. */
    serverAssert(x != NULL);

    /* Check if score >= min. */
    if (!zslValueGteMin(x->score,range)) return NULL;
    return x;
}",1,4,t_zset.c,zslLastInRange,,false,359,380,zslLastInRange,,,17,"zskiplistNode zslLastInRange (zskiplist*,zrangespec*)"
450719,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long removed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            !zslValueGteMin(x->level[i].forward->score, range))
                x = x->level[i].forward;
        update[i] = x;
    }

    /* Current node is the last with score < or <= min. */
    x = x->level[0].forward;

    /* Delete nodes while in range. */
    while (x && zslValueLteMax(x->score, range)) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x); /* Here is where x->ele is actually released. */
        removed++;
        x = next;
    }
    return removed;
}",1,26,t_zset.c,zslDeleteRangeByScore,,false,387,413,zslDeleteRangeByScore,,,18,"unsigned long zslDeleteRangeByScore (zskiplist*,zrangespec*,dict*)"
450834,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long removed = 0;
    int i;


    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            !zslLexValueGteMin(x->level[i].forward->ele,range))
                x = x->level[i].forward;
        update[i] = x;
    }

    /* Current node is the last with score < or <= min. */
    x = x->level[0].forward;

    /* Delete nodes while in range. */
    while (x && zslLexValueLteMax(x->ele,range)) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x); /* Here is where x->ele is actually released. */
        removed++;
        x = next;
    }
    return removed;
}",1,26,t_zset.c,zslDeleteRangeByLex,,false,415,442,zslDeleteRangeByLex,,,19,"unsigned long zslDeleteRangeByLex (zskiplist*,zlexrangespec*,dict*)"
450949,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned long traversed = 0, removed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward && (traversed + x->level[i].span) < start) {
            traversed += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    traversed++;
    x = x->level[0].forward;
    while (x && traversed <= end) {
        zskiplistNode *next = x->level[0].forward;
        zslDeleteNode(zsl,x,update);
        dictDelete(dict,x->ele);
        zslFreeNode(x);
        removed++;
        traversed++;
        x = next;
    }
    return removed;
}",1,26,t_zset.c,zslDeleteRangeByRank,,false,446,472,zslDeleteRangeByRank,,,20,"unsigned long zslDeleteRangeByRank (zskiplist*,unsigned int,unsigned int,dict*)"
451080,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    unsigned long rank = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
            (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                sdscmp(x->level[i].forward->ele,ele) <= 0))) {
            rank += x->level[i].span;
            x = x->level[i].forward;
        }

        /* x might be equal to zsl->header, so test if obj is non-NULL */
        if (x->ele && x->score == score && sdscmp(x->ele,ele) == 0) {
            return rank;
        }
    }
    return 0;
}",1,1,t_zset.c,zslGetRank,,false,478,499,zslGetRank,,,21,"unsigned long zslGetRank (zskiplist*,double,sds)"
451201,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
    zskiplistNode *x;
    unsigned long traversed = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward && (traversed + x->level[i].span) <= rank)
        {
            traversed += x->level[i].span;
            x = x->level[i].forward;
        }
        if (traversed == rank) {
            return x;
        }
    }
    return NULL;
}",1,1,t_zset.c,zslGetElementByRank,,false,502,519,zslGetElementByRank,,,22,"zskiplistNode zslGetElementByRank (zskiplist*,long unsigned)"
451281,METHOD,t_zset.c:<global>,TYPE_DECL,"static int zslParseRange(robj *min, robj *max, zrangespec *spec) {
    char *eptr;
    spec->minex = spec->maxex = 0;

    /* Parse the min-max interval. If one of the values is prefixed
     * by the ""("" character, it's considered ""open"". For instance
     * ZRANGEBYSCORE zset (1.5 (2.5 will match min < x < max
     * ZRANGEBYSCORE zset 1.5 2.5 will instead match min <= x <= max */
    if (min->encoding == OBJ_ENCODING_INT) {
        spec->min = (long)min->ptr;
    } else {
        if (((char*)min->ptr)[0] == '(') {
            spec->min = strtod((char*)min->ptr+1,&eptr);
            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
            spec->minex = 1;
        } else {
            spec->min = strtod((char*)min->ptr,&eptr);
            if (eptr[0] != '\0' || isnan(spec->min)) return C_ERR;
        }
    }
    if (max->encoding == OBJ_ENCODING_INT) {
        spec->max = (long)max->ptr;
    } else {
        if (((char*)max->ptr)[0] == '(') {
            spec->max = strto...",1,25,t_zset.c,zslParseRange,,false,522,556,zslParseRange,,,23,"int zslParseRange (robj*,robj*,zrangespec*)"
451498,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslParseLexRangeItem(robj *item, sds *dest, int *ex) {
    char *c = item->ptr;

    switch(c[0]) {
    case '+':
        if (c[1] != '\0') return C_ERR;
        *ex = 1;
        *dest = shared.maxstring;
        return C_OK;
    case '-':
        if (c[1] != '\0') return C_ERR;
        *ex = 1;
        *dest = shared.minstring;
        return C_OK;
    case '(':
        *ex = 1;
        *dest = sdsnewlen(c+1,sdslen(c)-1);
        return C_OK;
    case '[':
        *ex = 0;
        *dest = sdsnewlen(c+1,sdslen(c)-1);
        return C_OK;
    default:
        return C_ERR;
    }
}",1,33,t_zset.c,zslParseLexRangeItem,,false,573,598,zslParseLexRangeItem,,,24,"int zslParseLexRangeItem (robj*,sds*,int*)"
451620,METHOD,t_zset.c:<global>,TYPE_DECL,"void zslFreeLexRange(zlexrangespec *spec) {
    if (spec->min != shared.minstring &&
        spec->min != shared.maxstring) sdsfree(spec->min);
    if (spec->max != shared.minstring &&
        spec->max != shared.maxstring) sdsfree(spec->max);
}",1,1,t_zset.c,zslFreeLexRange,,false,602,607,zslFreeLexRange,,,25,void zslFreeLexRange (zlexrangespec*)
451667,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {
    /* The range can't be valid if objects are integer encoded.
     * Every item must start with ( or [. */
    if (min->encoding == OBJ_ENCODING_INT ||
        max->encoding == OBJ_ENCODING_INT) return C_ERR;

    spec->min = spec->max = NULL;
    if (zslParseLexRangeItem(min, &spec->min, &spec->minex) == C_ERR ||
        zslParseLexRangeItem(max, &spec->max, &spec->maxex) == C_ERR) {
        zslFreeLexRange(spec);
        return C_ERR;
    } else {
        return C_OK;
    }
}",1,25,t_zset.c,zslParseLexRange,,false,614,628,zslParseLexRange,,,26,"int zslParseLexRange (robj*,robj*,zlexrangespec*)"
451751,METHOD,t_zset.c:<global>,TYPE_DECL,"int sdscmplex(sds a, sds b) {
    if (a == b) return 0;
    if (a == shared.minstring || b == shared.maxstring) return -1;
    if (a == shared.maxstring || b == shared.minstring) return 1;
    return sdscmp(a,b);
}",1,1,t_zset.c,sdscmplex,,false,633,638,sdscmplex,,,27,"int sdscmplex (sds,sds)"
451799,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslLexValueGteMin(sds value, zlexrangespec *spec) {
    return spec->minex ?
        (sdscmplex(value,spec->min) > 0) :
        (sdscmplex(value,spec->min) >= 0);
}",1,1,t_zset.c,zslLexValueGteMin,,false,640,644,zslLexValueGteMin,,,28,"int zslLexValueGteMin (sds,zlexrangespec*)"
451824,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslLexValueLteMax(sds value, zlexrangespec *spec) {
    return spec->maxex ?
        (sdscmplex(value,spec->max) < 0) :
        (sdscmplex(value,spec->max) <= 0);
}",1,1,t_zset.c,zslLexValueLteMax,,false,646,650,zslLexValueLteMax,,,29,"int zslLexValueLteMax (sds,zlexrangespec*)"
451849,METHOD,t_zset.c:<global>,TYPE_DECL,"int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;

    /* Test for ranges that will always be empty. */
    int cmp = sdscmplex(range->min,range->max);
    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
        return 0;
    x = zsl->tail;
    if (x == NULL || !zslLexValueGteMin(x->ele,range))
        return 0;
    x = zsl->header->level[0].forward;
    if (x == NULL || !zslLexValueLteMax(x->ele,range))
        return 0;
    return 1;
}",1,1,t_zset.c,zslIsInLexRange,,false,653,667,zslIsInLexRange,,,30,"int zslIsInLexRange (zskiplist*,zlexrangespec*)"
451931,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInLexRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *OUT* of range. */
        while (x->level[i].forward &&
            !zslLexValueGteMin(x->level[i].forward->ele,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so the next node cannot be NULL. */
    x = x->level[0].forward;
    serverAssert(x != NULL);

    /* Check if score <= max. */
    if (!zslLexValueLteMax(x->ele,range)) return NULL;
    return x;
}",1,4,t_zset.c,zslFirstInLexRange,,false,671,693,zslFirstInLexRange,,,31,"zskiplistNode zslFirstInLexRange (zskiplist*,zlexrangespec*)"
452034,METHOD,t_zset.c:<global>,TYPE_DECL,"zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {
    zskiplistNode *x;
    int i;

    /* If everything is out of range, return early. */
    if (!zslIsInLexRange(zsl,range)) return NULL;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        /* Go forward while *IN* range. */
        while (x->level[i].forward &&
            zslLexValueLteMax(x->level[i].forward->ele,range))
                x = x->level[i].forward;
    }

    /* This is an inner range, so this node cannot be NULL. */
    serverAssert(x != NULL);

    /* Check if score >= min. */
    if (!zslLexValueGteMin(x->ele,range)) return NULL;
    return x;
}",1,4,t_zset.c,zslLastInLexRange,,false,697,718,zslLastInLexRange,,,32,"zskiplistNode zslLastInLexRange (zskiplist*,zlexrangespec*)"
452127,METHOD,t_zset.c:<global>,TYPE_DECL,"double zzlStrtod(unsigned char *vstr, unsigned int vlen) {
    char buf[128];
    if (vlen > sizeof(buf) - 1)
        vlen = sizeof(buf) - 1;
    memcpy(buf,vstr,vlen);
    buf[vlen] = '\0';
    return strtod(buf,NULL);
 }",1,2,t_zset.c,zzlStrtod,,false,724,731,zzlStrtod,,,33,"double zzlStrtod (unsigned char*,unsigned int)"
452161,METHOD,t_zset.c:<global>,TYPE_DECL,"double zzlGetScore(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    double score;

    serverAssert(sptr != NULL);
    vstr = lpGetValue(sptr,&vlen,&vlong);

    if (vstr) {
        score = zzlStrtod(vstr,vlen);
    } else {
        score = vlong;
    }

    return score;
}",1,4,t_zset.c,zzlGetScore,,false,733,749,zzlGetScore,,,34,double zzlGetScore (unsigned char*)
452209,METHOD,t_zset.c:<global>,TYPE_DECL,"sds lpGetObject(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;

    serverAssert(sptr != NULL);
    vstr = lpGetValue(sptr,&vlen,&vlong);

    if (vstr) {
        return sdsnewlen((char*)vstr,vlen);
    } else {
        return sdsfromlonglong(vlong);
    }
}",1,4,t_zset.c,lpGetObject,,false,752,765,lpGetObject,,,35,sds lpGetObject (unsigned char*)
452255,METHOD,t_zset.c:<global>,TYPE_DECL,"int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    unsigned char vbuf[32];
    int minlen, cmp;

    vstr = lpGetValue(eptr,&vlen,&vlong);
    if (vstr == NULL) {
        /* Store string representation of long long in buf. */
        vlen = ll2string((char*)vbuf,sizeof(vbuf),vlong);
        vstr = vbuf;
    }

    minlen = (vlen < clen) ? vlen : clen;
    cmp = memcmp(vstr,cstr,minlen);
    if (cmp == 0) return vlen-clen;
    return cmp;
}",1,1,t_zset.c,zzlCompareElements,,false,768,786,zzlCompareElements,,,36,"int zzlCompareElements (unsigned char*,unsigned char*,unsigned int)"
452318,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned int zzlLength(unsigned char *zl) {
    return lpLength(zl)/2;
}",1,1,t_zset.c,zzlLength,,false,788,790,zzlLength,,,37,unsigned int zzlLength (unsigned char*)
452328,METHOD,t_zset.c:<global>,TYPE_DECL,"void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
    unsigned char *_eptr, *_sptr;
    serverAssert(*eptr != NULL && *sptr != NULL);

    _eptr = lpNext(zl,*sptr);
    if (_eptr != NULL) {
        _sptr = lpNext(zl,_eptr);
        serverAssert(_sptr != NULL);
    } else {
        /* No next entry. */
        _sptr = NULL;
    }

    *eptr = _eptr;
    *sptr = _sptr;
}",1,4,t_zset.c,zzlNext,,false,794,809,zzlNext,,,38,"void zzlNext (unsigned char*,unsigned char**,unsigned char**)"
452404,METHOD,t_zset.c:<global>,TYPE_DECL,"void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {
    unsigned char *_eptr, *_sptr;
    serverAssert(*eptr != NULL && *sptr != NULL);

    _sptr = lpPrev(zl,*eptr);
    if (_sptr != NULL) {
        _eptr = lpPrev(zl,_sptr);
        serverAssert(_eptr != NULL);
    } else {
        /* No previous entry. */
        _eptr = NULL;
    }

    *eptr = _eptr;
    *sptr = _sptr;
}",1,4,t_zset.c,zzlPrev,,false,813,828,zzlPrev,,,39,"void zzlPrev (unsigned char*,unsigned char**,unsigned char**)"
452480,METHOD,t_zset.c:<global>,TYPE_DECL,"int zzlIsInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *p;
    double score;

    /* Test for ranges that will always be empty. */
    if (range->min > range->max ||
            (range->min == range->max && (range->minex || range->maxex)))
        return 0;

    p = lpSeek(zl,-1); /* Last score. */
    if (p == NULL) return 0; /* Empty sorted set */
    score = zzlGetScore(p);
    if (!zslValueGteMin(score,range))
        return 0;

    p = lpSeek(zl,1); /* First score. */
    serverAssert(p != NULL);
    score = zzlGetScore(p);
    if (!zslValueLteMax(score,range))
        return 0;

    return 1;
}",1,4,t_zset.c,zzlIsInRange,,false,832,854,zzlIsInRange,,,40,"int zzlIsInRange (unsigned char*,zrangespec*)"
452575,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;
    double score;

    /* If everything is out of range, return early. */
    if (!zzlIsInRange(zl,range)) return NULL;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueGteMin(score,range)) {
            /* Check if score <= max. */
            if (zslValueLteMax(score,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        eptr = lpNext(zl,sptr);
    }

    return NULL;
}",1,8,t_zset.c,zzlFirstInRange,,false,858,882,zzlFirstInRange,,,41,"unsigned char* zzlFirstInRange (unsigned char*,zrangespec*)"
452648,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {
    unsigned char *eptr = lpSeek(zl,-2), *sptr;
    double score;

    /* If everything is out of range, return early. */
    if (!zzlIsInRange(zl,range)) return NULL;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        score = zzlGetScore(sptr);
        if (zslValueLteMax(score,range)) {
            /* Check if score >= min. */
            if (zslValueGteMin(score,range))
                return eptr;
            return NULL;
        }

        /* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */
        sptr = lpPrev(zl,eptr);
        if (sptr != NULL)
            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);
        else
            eptr = NULL;
    }

    return NULL;
}",1,8,t_zset.c,zzlLastInRange,,false,886,915,zzlLastInRange,,,42,"unsigned char* zzlLastInRange (unsigned char*,zrangespec*)"
452752,METHOD,t_zset.c:<global>,TYPE_DECL,"int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {
    sds value = lpGetObject(p);
    int res = zslLexValueGteMin(value,spec);
    sdsfree(value);
    return res;
}",1,1,t_zset.c,zzlLexValueGteMin,,false,917,922,zzlLexValueGteMin,,,43,"int zzlLexValueGteMin (unsigned char*,zlexrangespec*)"
452773,METHOD,t_zset.c:<global>,TYPE_DECL,"int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {
    sds value = lpGetObject(p);
    int res = zslLexValueLteMax(value,spec);
    sdsfree(value);
    return res;
}",1,1,t_zset.c,zzlLexValueLteMax,,false,924,929,zzlLexValueLteMax,,,44,"int zzlLexValueLteMax (unsigned char*,zlexrangespec*)"
452794,METHOD,t_zset.c:<global>,TYPE_DECL,"int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *p;

    /* Test for ranges that will always be empty. */
    int cmp = sdscmplex(range->min,range->max);
    if (cmp > 0 || (cmp == 0 && (range->minex || range->maxex)))
        return 0;

    p = lpSeek(zl,-2); /* Last element. */
    if (p == NULL) return 0;
    if (!zzlLexValueGteMin(p,range))
        return 0;

    p = lpSeek(zl,0); /* First element. */
    serverAssert(p != NULL);
    if (!zzlLexValueLteMax(p,range))
        return 0;

    return 1;
}",1,4,t_zset.c,zzlIsInLexRange,,false,933,952,zzlIsInLexRange,,,45,"int zzlIsInLexRange (unsigned char*,zlexrangespec*)"
452882,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;

    /* If everything is out of range, return early. */
    if (!zzlIsInLexRange(zl,range)) return NULL;

    while (eptr != NULL) {
        if (zzlLexValueGteMin(eptr,range)) {
            /* Check if score <= max. */
            if (zzlLexValueLteMax(eptr,range))
                return eptr;
            return NULL;
        }

        /* Move to next element. */
        sptr = lpNext(zl,eptr); /* This element score. Skip it. */
        serverAssert(sptr != NULL);
        eptr = lpNext(zl,sptr); /* Next element. */
    }

    return NULL;
}",1,8,t_zset.c,zzlFirstInLexRange,,false,956,977,zzlFirstInLexRange,,,46,"unsigned char* zzlFirstInLexRange (unsigned char*,zlexrangespec*)"
452950,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {
    unsigned char *eptr = lpSeek(zl,-2), *sptr;

    /* If everything is out of range, return early. */
    if (!zzlIsInLexRange(zl,range)) return NULL;

    while (eptr != NULL) {
        if (zzlLexValueLteMax(eptr,range)) {
            /* Check if score >= min. */
            if (zzlLexValueGteMin(eptr,range))
                return eptr;
            return NULL;
        }

        /* Move to previous element by moving to the score of previous element.
         * When this returns NULL, we know there also is no element. */
        sptr = lpPrev(zl,eptr);
        if (sptr != NULL)
            serverAssert((eptr = lpPrev(zl,sptr)) != NULL);
        else
            eptr = NULL;
    }

    return NULL;
}",1,12,t_zset.c,zzlLastInLexRange,,false,981,1005,zzlLastInLexRange,,,47,"unsigned char* zzlLastInLexRange (unsigned char*,zlexrangespec*)"
453028,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlFind(unsigned char *lp, sds ele, double *score) {
    unsigned char *eptr, *sptr;

    if ((eptr = lpFirst(lp)) == NULL) return NULL;
    eptr = lpFind(lp, eptr, (unsigned char*)ele, sdslen(ele), 1);
    if (eptr) {
        sptr = lpNext(lp,eptr);
        serverAssert(sptr != NULL);

        /* Matching element, pull out score. */
        if (score != NULL) *score = zzlGetScore(sptr);
        return eptr;
    }

    return NULL;
}",1,8,t_zset.c,zzlFind,,false,1007,1022,zzlFind,,,48,"unsigned char* zzlFind (unsigned char*,sds,double*)"
453096,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {
    return lpDeleteRangeWithEntry(zl,&eptr,2);
}",1,1,t_zset.c,zzlDelete,,false,1026,1028,zzlDelete,,,49,"unsigned char* zzlDelete (unsigned char*,unsigned char*)"
453108,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, sds ele, double score) {
    unsigned char *sptr;
    char scorebuf[MAX_D2STRING_CHARS];
    int scorelen = 0;
    long long lscore;
    int score_is_long = double2ll(score, &lscore);
    if (!score_is_long)
        scorelen = d2string(scorebuf,sizeof(scorebuf),score);
    if (eptr == NULL) {
        zl = lpAppend(zl,(unsigned char*)ele,sdslen(ele));
        if (score_is_long)
            zl = lpAppendInteger(zl,lscore);
        else
            zl = lpAppend(zl,(unsigned char*)scorebuf,scorelen);
    } else {
        /* Insert member before the element 'eptr'. */
        zl = lpInsertString(zl,(unsigned char*)ele,sdslen(ele),eptr,LP_BEFORE,&sptr);

        /* Insert score after the member. */
        if (score_is_long)
            zl = lpInsertInteger(zl,lscore,sptr,LP_AFTER,NULL);
        else
            zl = lpInsertString(zl,(unsigned char*)scorebuf,scorelen,sptr,LP_AFTER,NULL);
    }
    return zl;
}",1,18,t_zset.c,zzlInsertAt,,false,1030,1055,zzlInsertAt,,,50,"unsigned char* zzlInsertAt (unsigned char*,unsigned char*,sds,double)"
453220,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlInsert(unsigned char *zl, sds ele, double score) {
    unsigned char *eptr = lpSeek(zl,0), *sptr;
    double s;

    while (eptr != NULL) {
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);
        s = zzlGetScore(sptr);

        if (s > score) {
            /* First element with score larger than score for element to be
             * inserted. This means we should take its spot in the list to
             * maintain ordering. */
            zl = zzlInsertAt(zl,eptr,ele,score);
            break;
        } else if (s == score) {
            /* Ensure lexicographical ordering for elements. */
            if (zzlCompareElements(eptr,(unsigned char*)ele,sdslen(ele)) > 0) {
                zl = zzlInsertAt(zl,eptr,ele,score);
                break;
            }
        }

        /* Move to next element. */
        eptr = lpNext(zl,sptr);
    }

    /* Push on tail of list when it was not yet inserted. */
    if (eptr == NULL)
        zl = zzlInsert...",1,8,t_zset.c,zzlInsert,,false,1059,1090,zzlInsert,,,51,"unsigned char* zzlInsert (unsigned char*,sds,double)"
453323,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {
    unsigned char *eptr, *sptr;
    double score;
    unsigned long num = 0;

    if (deleted != NULL) *deleted = 0;

    eptr = zzlFirstInRange(zl,range);
    if (eptr == NULL) return zl;

    /* When the tail of the listpack is deleted, eptr will be NULL. */
    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {
        score = zzlGetScore(sptr);
        if (zslValueLteMax(score,range)) {
            /* Delete both the element and the score. */
            zl = lpDeleteRangeWithEntry(zl,&eptr,2);
            num++;
        } else {
            /* No longer in range. */
            break;
        }
    }

    if (deleted != NULL) *deleted = num;
    return zl;
}",1,1,t_zset.c,zzlDeleteRangeByScore,,false,1092,1117,zzlDeleteRangeByScore,,,52,"unsigned char* zzlDeleteRangeByScore (unsigned char*,zrangespec*,long unsigned*)"
453401,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {
    unsigned char *eptr, *sptr;
    unsigned long num = 0;

    if (deleted != NULL) *deleted = 0;

    eptr = zzlFirstInLexRange(zl,range);
    if (eptr == NULL) return zl;

    /* When the tail of the listpack is deleted, eptr will be NULL. */
    while (eptr && (sptr = lpNext(zl,eptr)) != NULL) {
        if (zzlLexValueLteMax(eptr,range)) {
            /* Delete both the element and the score. */
            zl = lpDeleteRangeWithEntry(zl,&eptr,2);
            num++;
        } else {
            /* No longer in range. */
            break;
        }
    }

    if (deleted != NULL) *deleted = num;
    return zl;
}",1,1,t_zset.c,zzlDeleteRangeByLex,,false,1119,1142,zzlDeleteRangeByLex,,,53,"unsigned char* zzlDeleteRangeByLex (unsigned char*,zlexrangespec*,long unsigned*)"
453474,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {
    unsigned int num = (end-start)+1;
    if (deleted) *deleted = num;
    zl = lpDeleteRange(zl,2*(start-1),2*num);
    return zl;
}",1,1,t_zset.c,zzlDeleteRangeByRank,,false,1146,1151,zzlDeleteRangeByRank,,,54,"unsigned char* zzlDeleteRangeByRank (unsigned char*,unsigned int,unsigned int,long unsigned*)"
453511,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned long zsetLength(const robj *zobj) {
    unsigned long length = 0;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        length = zzlLength(zobj->ptr);
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        length = ((const zset*)zobj->ptr)->zsl->length;
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return length;
}",1,26,t_zset.c,zsetLength,,false,1157,1167,zsetLength,,,55,unsigned long zsetLength (robj*)
453569,METHOD,t_zset.c:<global>,TYPE_DECL,"robj *zsetTypeCreate(size_t size_hint, size_t val_len_hint) {
    if (size_hint <= server.zset_max_listpack_entries &&
        val_len_hint <= server.zset_max_listpack_value)
    {
        return createZsetListpackObject();
    }

    robj *zobj = createZsetObject();
    zset *zs = zobj->ptr;
    dictExpand(zs->dict, size_hint);
    return zobj;
}",1,1,t_zset.c,zsetTypeCreate,,false,1176,1187,zsetTypeCreate,,,56,"robj zsetTypeCreate (size_t,size_t)"
453607,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetTypeMaybeConvert(robj *zobj, size_t size_hint) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK &&
        size_hint > server.zset_max_listpack_entries)
    {
        zsetConvertAndExpand(zobj, OBJ_ENCODING_SKIPLIST, size_hint);
    }
}",1,26,t_zset.c,zsetTypeMaybeConvert,,false,1191,1197,zsetTypeMaybeConvert,,,57,"void zsetTypeMaybeConvert (robj*,size_t)"
453634,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetConvert(robj *zobj, int encoding) {
    zsetConvertAndExpand(zobj, encoding, zsetLength(zobj));
}",1,1,t_zset.c,zsetConvert,,false,1202,1204,zsetConvert,,,58,"void zsetConvert (robj*,int)"
453645,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetConvertAndExpand(robj *zobj, int encoding, unsigned long cap) {
    zset *zs;
    zskiplistNode *node, *next;
    sds ele;
    double score;

    if (zobj->encoding == encoding) return;
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        if (encoding != OBJ_ENCODING_SKIPLIST)
            serverPanic(""Unknown target encoding"");

        zs = zmalloc(sizeof(*zs));
        zs->dict = dictCreate(&zsetDictType);
        zs->zsl = zslCreate();

        /* Presize the dict to avoid rehashing */
        dictExpand(zs->dict, cap);

        eptr = lpSeek(zl,0);
        if (eptr != NULL) {
            sptr = lpNext(zl,eptr);
            serverAssertWithInfo(NULL,zobj,sptr != NULL);
        }

        while (eptr != NULL) {
            score = zzlGetScore(sptr);
            vstr = lpGetValue(eptr,&vlen,&vlong);
            i...",1,26,t_zset.c,zsetConvertAndExpand,,false,1207,1280,zsetConvertAndExpand,,,59,"void zsetConvertAndExpand (robj*,int,long unsigned)"
453962,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetConvertToListpackIfNeeded(robj *zobj, size_t maxelelen, size_t totelelen) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) return;
    zset *zset = zobj->ptr;

    if (zset->zsl->length <= server.zset_max_listpack_entries &&
        maxelelen <= server.zset_max_listpack_value &&
        lpSafeToAdd(NULL, totelelen))
    {
        zsetConvert(zobj,OBJ_ENCODING_LISTPACK);
    }
}",1,26,t_zset.c,zsetConvertToListpackIfNeeded,,false,1285,1295,zsetConvertToListpackIfNeeded,,,60,"void zsetConvertToListpackIfNeeded (robj*,size_t,size_t)"
454011,METHOD,t_zset.c:<global>,TYPE_DECL,"int zsetScore(robj *zobj, sds member, double *score) {
    if (!zobj || !member) return C_ERR;

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        if (zzlFind(zobj->ptr, member, score) == NULL) return C_ERR;
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        dictEntry *de = dictFind(zs->dict, member);
        if (de == NULL) return C_ERR;
        *score = *(double*)dictGetVal(de);
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return C_OK;
}",1,33,t_zset.c,zsetScore,,false,1301,1315,zsetScore,,,61,"int zsetScore (robj*,sds,double*)"
454111,METHOD,t_zset.c:<global>,TYPE_DECL,"int zsetAdd(robj *zobj, double score, sds ele, int in_flags, int *out_flags, double *newscore) {
    /* Turn options into simple to check vars. */
    int incr = (in_flags & ZADD_IN_INCR) != 0;
    int nx = (in_flags & ZADD_IN_NX) != 0;
    int xx = (in_flags & ZADD_IN_XX) != 0;
    int gt = (in_flags & ZADD_IN_GT) != 0;
    int lt = (in_flags & ZADD_IN_LT) != 0;
    *out_flags = 0; /* We'll return our response flags. */
    double curscore;

    /* NaN as input is an error regardless of all the other parameters. */
    if (isnan(score)) {
        *out_flags = ZADD_OUT_NAN;
        return 0;
    }

    /* Update the sorted set according to its encoding. */
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr;

        if ((eptr = zzlFind(zobj->ptr,ele,&curscore)) != NULL) {
            /* NX? Return, same element already exists. */
            if (nx) {
                *out_flags |= ZADD_OUT_NOP;
                return 1;
            }

            /* Prepa...",1,27,t_zset.c,zsetAdd,,false,1362,1492,zsetAdd,,,62,"int zsetAdd (robj*,double,sds,int,int*,double*)"
454618,METHOD,t_zset.c:<global>,TYPE_DECL,"static int zsetRemoveFromSkiplist(zset *zs, sds ele) {
    dictEntry *de;
    double score;

    de = dictUnlink(zs->dict,ele);
    if (de != NULL) {
        /* Get the score in order to delete from the skiplist later. */
        score = *(double*)dictGetVal(de);

        /* Delete from the hash table and later from the skiplist.
         * Note that the order is important: deleting from the skiplist
         * actually releases the SDS string representing the element,
         * which is shared between the skiplist and the hash table, so
         * we need to delete from the skiplist as the final step. */
        dictFreeUnlinkedEntry(zs->dict,de);

        /* Delete from skiplist. */
        int retval = zslDelete(zs->zsl,score,ele,NULL);
        serverAssert(retval);

        return 1;
    }

    return 0;
}",1,8,t_zset.c,zsetRemoveFromSkiplist,,false,1498,1522,zsetRemoveFromSkiplist,,,63,"int zsetRemoveFromSkiplist (zset*,sds)"
454679,METHOD,t_zset.c:<global>,TYPE_DECL,"int zsetDel(robj *zobj, sds ele) {
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *eptr;

        if ((eptr = zzlFind(zobj->ptr,ele,NULL)) != NULL) {
            zobj->ptr = zzlDelete(zobj->ptr,eptr);
            return 1;
        }
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        if (zsetRemoveFromSkiplist(zs, ele)) {
            if (htNeedsResize(zs->dict)) dictResize(zs->dict);
            return 1;
        }
    } else {
        serverPanic(""Unknown sorted set encoding"");
    }
    return 0; /* No such element found. */
}",1,26,t_zset.c,zsetDel,,false,1526,1544,zsetDel,,,64,"int zsetDel (robj*,sds)"
454764,METHOD,t_zset.c:<global>,TYPE_DECL,"long zsetRank(robj *zobj, sds ele, int reverse, double *output_score) {
    unsigned long llen;
    unsigned long rank;

    llen = zsetLength(zobj);

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;

        eptr = lpSeek(zl,0);
        serverAssert(eptr != NULL);
        sptr = lpNext(zl,eptr);
        serverAssert(sptr != NULL);

        rank = 1;
        while(eptr != NULL) {
            if (lpCompare(eptr,(unsigned char*)ele,sdslen(ele)))
                break;
            rank++;
            zzlNext(zl,&eptr,&sptr);
        }

        if (eptr != NULL) {
            if (output_score) 
                *output_score = zzlGetScore(sptr);
            if (reverse)
                return llen-rank;
            else
                return rank-1;
        } else {
            return -1;
        }
    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj->ptr;
        zskiplist *zsl = z...",1,26,t_zset.c,zsetRank,,false,1557,1614,zsetRank,,,65,"long zsetRank (robj*,sds,int,double*)"
454995,METHOD,t_zset.c:<global>,TYPE_DECL,"robj *zsetDup(robj *o) {
    robj *zobj;
    zset *zs;
    zset *new_zs;

    serverAssert(o->type == OBJ_ZSET);

    /* Create a new sorted set object that have the same encoding as the original object's encoding */
    if (o->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = o->ptr;
        size_t sz = lpBytes(zl);
        unsigned char *new_zl = zmalloc(sz);
        memcpy(new_zl, zl, sz);
        zobj = createObject(OBJ_ZSET, new_zl);
        zobj->encoding = OBJ_ENCODING_LISTPACK;
    } else if (o->encoding == OBJ_ENCODING_SKIPLIST) {
        zobj = createZsetObject();
        zs = o->ptr;
        new_zs = zobj->ptr;
        dictExpand(new_zs->dict,dictSize(zs->dict));
        zskiplist *zsl = zs->zsl;
        zskiplistNode *ln;
        sds ele;
        long llen = zsetLength(o);

        /* We copy the skiplist elements from the greatest to the
         * smallest (that's trivial since the elements are already ordered in
         * the skiplist): this improves t...",1,4,t_zset.c,zsetDup,,false,1621,1664,zsetDup,,,66,robj zsetDup (robj*)
455181,METHOD,t_zset.c:<global>,TYPE_DECL,"sds zsetSdsFromListpackEntry(listpackEntry *e) {
    return e->sval ? sdsnewlen(e->sval, e->slen) : sdsfromlonglong(e->lval);
}",1,1,t_zset.c,zsetSdsFromListpackEntry,,false,1667,1669,zsetSdsFromListpackEntry,,,67,sds zsetSdsFromListpackEntry (listpackEntry*)
455202,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetReplyFromListpackEntry(client *c, listpackEntry *e) {
    if (e->sval)
        addReplyBulkCBuffer(c, e->sval, e->slen);
    else
        addReplyBulkLongLong(c, e->lval);
}",1,1,t_zset.c,zsetReplyFromListpackEntry,,false,1672,1677,zsetReplyFromListpackEntry,,,68,"void zsetReplyFromListpackEntry (client*,listpackEntry*)"
455228,METHOD,t_zset.c:<global>,TYPE_DECL,"void zsetTypeRandomElement(robj *zsetobj, unsigned long zsetsize, listpackEntry *key, double *score) {
    if (zsetobj->encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zsetobj->ptr;
        dictEntry *de = dictGetFairRandomKey(zs->dict);
        sds s = dictGetKey(de);
        key->sval = (unsigned char*)s;
        key->slen = sdslen(s);
        if (score)
            *score = *(double*)dictGetVal(de);
    } else if (zsetobj->encoding == OBJ_ENCODING_LISTPACK) {
        listpackEntry val;
        lpRandomPair(zsetobj->ptr, zsetsize, key, &val);
        if (score) {
            if (val.sval) {
                *score = zzlStrtod(val.sval,val.slen);
            } else {
                *score = (double)val.lval;
            }
        }
    } else {
        serverPanic(""Unknown zset encoding"");
    }
}",1,29,t_zset.c,zsetTypeRandomElement,,false,1684,1706,zsetTypeRandomElement,,,69,"void zsetTypeRandomElement (robj*,long unsigned,listpackEntry*,double*)"
455345,METHOD,t_zset.c:<global>,TYPE_DECL,"void zaddGenericCommand(client *c, int flags) {
    static char *nanerr = ""resulting score is not a number (NaN)"";
    robj *key = c->argv[1];
    robj *zobj;
    sds ele;
    double score = 0, *scores = NULL;
    int j, elements, ch = 0;
    int scoreidx = 0;
    /* The following vars are used in order to track what the command actually
     * did during the execution, to reply to the client and to trigger the
     * notification of keyspace change. */
    int added = 0;      /* Number of new elements added. */
    int updated = 0;    /* Number of elements with updated score. */
    int processed = 0;  /* Number of elements processed, may remain zero with
                           options like XX. */

    /* Parse options. At the end 'scoreidx' is set to the argument position
     * of the score of the first score-element pair. */
    scoreidx = 2;
    while(scoreidx < c->argc) {
        char *opt = c->argv[scoreidx]->ptr;
        if (!strcasecmp(opt,""nx"")) flags |= ZADD_IN_NX;
  ...",1,44,t_zset.c,zaddGenericCommand,,false,1713,1835,zaddGenericCommand,,,70,"void zaddGenericCommand (client*,int)"
455871,METHOD,t_zset.c:<global>,TYPE_DECL,"void zaddCommand(client *c) {
    zaddGenericCommand(c,ZADD_IN_NONE);
}",1,25,t_zset.c,zaddCommand,,false,1837,1839,zaddCommand,,,71,void zaddCommand (client*)
455881,METHOD,t_zset.c:<global>,TYPE_DECL,"void zincrbyCommand(client *c) {
    zaddGenericCommand(c,ZADD_IN_INCR);
}",1,25,t_zset.c,zincrbyCommand,,false,1841,1843,zincrbyCommand,,,72,void zincrbyCommand (client*)
455893,METHOD,t_zset.c:<global>,TYPE_DECL,"void zremCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    int deleted = 0, keyremoved = 0, j;

    if ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||
        checkType(c,zobj,OBJ_ZSET)) return;

    for (j = 2; j < c->argc; j++) {
        if (zsetDel(zobj,c->argv[j]->ptr)) deleted++;
        if (zsetLength(zobj) == 0) {
            dbDelete(c->db,key);
            keyremoved = 1;
            break;
        }
    }

    if (deleted) {
        notifyKeyspaceEvent(NOTIFY_ZSET,""zrem"",key,c->db->id);
        if (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,""del"",key,c->db->id);
        signalModifiedKey(c,c->db,key);
        server.dirty += deleted;
    }
    addReplyLongLong(c,deleted);
}",1,25,t_zset.c,zremCommand,,false,1845,1870,zremCommand,,,73,void zremCommand (client*)
456028,METHOD,<empty>,<empty>,<empty>,1,,t_zset.c,zrange_type:<clinit>,,false,1872,,<clinit>,,,5,
456036,METHOD,t_zset.c:<global>,TYPE_DECL,"void zremrangeGenericCommand(client *c, zrange_type rangetype) {
    robj *key = c->argv[1];
    robj *zobj;
    int keyremoved = 0;
    unsigned long deleted = 0;
    zrangespec range;
    zlexrangespec lexrange;
    long start, end, llen;
    char *notify_type = NULL;

    /* Step 1: Parse the range. */
    if (rangetype == ZRANGE_RANK) {
        notify_type = ""zremrangebyrank"";
        if ((getLongFromObjectOrReply(c,c->argv[2],&start,NULL) != C_OK) ||
            (getLongFromObjectOrReply(c,c->argv[3],&end,NULL) != C_OK))
            return;
    } else if (rangetype == ZRANGE_SCORE) {
        notify_type = ""zremrangebyscore"";
        if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
            addReplyError(c,""min or max is not a float"");
            return;
        }
    } else if (rangetype == ZRANGE_LEX) {
        notify_type = ""zremrangebylex"";
        if (zslParseLexRange(c->argv[2],c->argv[3],&lexrange) != C_OK) {
            addReplyError(c,""min or max not valid...",1,67,t_zset.c,zremrangeGenericCommand,,false,1880,1985,zremrangeGenericCommand,,,76,"void zremrangeGenericCommand (client*,zrange_type)"
456523,METHOD,t_zset.c:<global>,TYPE_DECL,"void zremrangebyrankCommand(client *c) {
    zremrangeGenericCommand(c,ZRANGE_RANK);
}",1,1,t_zset.c,zremrangebyrankCommand,,false,1987,1989,zremrangebyrankCommand,,,77,void zremrangebyrankCommand (client*)
456531,METHOD,t_zset.c:<global>,TYPE_DECL,"void zremrangebyscoreCommand(client *c) {
    zremrangeGenericCommand(c,ZRANGE_SCORE);
}",1,1,t_zset.c,zremrangebyscoreCommand,,false,1991,1993,zremrangebyscoreCommand,,,78,void zremrangebyscoreCommand (client*)
456539,METHOD,t_zset.c:<global>,TYPE_DECL,"void zremrangebylexCommand(client *c) {
    zremrangeGenericCommand(c,ZRANGE_LEX);
}",1,1,t_zset.c,zremrangebylexCommand,,false,1995,1997,zremrangebylexCommand,,,79,void zremrangebylexCommand (client*)
456589,METHOD,<empty>,<empty>,<empty>,1,,t_zset.c,zsetopval:<clinit>,,false,2049,,<clinit>,,,8,
456600,METHOD,t_zset.c:<global>,TYPE_DECL,"void zuiInitIterator(zsetopsrc *op) {
    if (op->subject == NULL)
        return;

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            it->is.is = op->subject->ptr;
            it->is.ii = 0;
        } else if (op->encoding == OBJ_ENCODING_HT) {
            it->ht.dict = op->subject->ptr;
            it->ht.di = dictGetIterator(op->subject->ptr);
            it->ht.de = dictNext(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            it->lp.lp = op->subject->ptr;
            it->lp.p = lpFirst(it->lp.lp);
        } else {
            serverPanic(""Unknown set encoding"");
        }
    } else if (op->type == OBJ_ZSET) {
        /* Sorted sets are traversed in reverse order to optimize for
         * the insertion of the elements in a new list as in
         * ZDIFF/ZINTER/ZUNION */
        iterzset *it = &op->iter.zset;
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
      ...",1,20,t_zset.c,zuiInitIterator,,false,2062,2102,zuiInitIterator,,,88,void zuiInitIterator (zsetopsrc*)
456905,METHOD,t_zset.c:<global>,TYPE_DECL,"void zuiClearIterator(zsetopsrc *op) {
    if (op->subject == NULL)
        return;

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            UNUSED(it); /* skip */
        } else if (op->encoding == OBJ_ENCODING_HT) {
            dictReleaseIterator(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            UNUSED(it);
        } else {
            serverPanic(""Unknown set encoding"");
        }
    } else if (op->type == OBJ_ZSET) {
        iterzset *it = &op->iter.zset;
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            UNUSED(it); /* skip */
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            UNUSED(it); /* skip */
        } else {
            serverPanic(""Unknown sorted set encoding"");
        }
    } else {
        serverPanic(""Unsupported type"");
    }
}",1,20,t_zset.c,zuiClearIterator,,false,2104,2131,zuiClearIterator,,,89,void zuiClearIterator (zsetopsrc*)
457067,METHOD,t_zset.c:<global>,TYPE_DECL,"void zuiDiscardDirtyValue(zsetopval *val) {
    if (val->flags & OPVAL_DIRTY_SDS) {
        sdsfree(val->ele);
        val->ele = NULL;
        val->flags &= ~OPVAL_DIRTY_SDS;
    }
}",1,21,t_zset.c,zuiDiscardDirtyValue,,false,2133,2139,zuiDiscardDirtyValue,,,90,void zuiDiscardDirtyValue (zsetopval*)
457098,METHOD,t_zset.c:<global>,TYPE_DECL,"unsigned long zuiLength(zsetopsrc *op) {
    if (op->subject == NULL)
        return 0;

    if (op->type == OBJ_SET) {
        return setTypeSize(op->subject);
    } else if (op->type == OBJ_ZSET) {
        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            return zzlLength(op->subject->ptr);
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            zset *zs = op->subject->ptr;
            return zs->zsl->length;
        } else {
            serverPanic(""Unknown sorted set encoding"");
        }
    } else {
        serverPanic(""Unsupported type"");
    }
}",1,20,t_zset.c,zuiLength,,false,2141,2159,zuiLength,,,91,unsigned long zuiLength (zsetopsrc*)
457198,METHOD,t_zset.c:<global>,TYPE_DECL,"int zuiNext(zsetopsrc *op, zsetopval *val) {
    if (op->subject == NULL)
        return 0;

    zuiDiscardDirtyValue(val);

    memset(val,0,sizeof(zsetopval));

    if (op->type == OBJ_SET) {
        iterset *it = &op->iter.set;
        if (op->encoding == OBJ_ENCODING_INTSET) {
            int64_t ell;

            if (!intsetGet(it->is.is,it->is.ii,&ell))
                return 0;
            val->ell = ell;
            val->score = 1.0;

            /* Move to next element. */
            it->is.ii++;
        } else if (op->encoding == OBJ_ENCODING_HT) {
            if (it->ht.de == NULL)
                return 0;
            val->ele = dictGetKey(it->ht.de);
            val->score = 1.0;

            /* Move to next element. */
            it->ht.de = dictNext(it->ht.di);
        } else if (op->encoding == OBJ_ENCODING_LISTPACK) {
            if (it->lp.p == NULL)
                return 0;
            val->estr = lpGetValue(it->lp.p, &val->elen, &val->ell);
            val->sc...",1,20,t_zset.c,zuiNext,,false,2164,2229,zuiNext,,,92,"int zuiNext (zsetopsrc*,zsetopval*)"
457576,METHOD,t_zset.c:<global>,TYPE_DECL,"int zuiLongLongFromValue(zsetopval *val) {
    if (!(val->flags & OPVAL_DIRTY_LL)) {
        val->flags |= OPVAL_DIRTY_LL;

        if (val->ele != NULL) {
            if (string2ll(val->ele,sdslen(val->ele),&val->ell))
                val->flags |= OPVAL_VALID_LL;
        } else if (val->estr != NULL) {
            if (string2ll((char*)val->estr,val->elen,&val->ell))
                val->flags |= OPVAL_VALID_LL;
        } else {
            /* The long long was already set, flag as valid. */
            val->flags |= OPVAL_VALID_LL;
        }
    }
    return val->flags & OPVAL_VALID_LL;
}",1,23,t_zset.c,zuiLongLongFromValue,,false,2231,2247,zuiLongLongFromValue,,,93,int zuiLongLongFromValue (zsetopval*)
457674,METHOD,t_zset.c:<global>,TYPE_DECL,"sds zuiSdsFromValue(zsetopval *val) {
    if (val->ele == NULL) {
        if (val->estr != NULL) {
            val->ele = sdsnewlen((char*)val->estr,val->elen);
        } else {
            val->ele = sdsfromlonglong(val->ell);
        }
        val->flags |= OPVAL_DIRTY_SDS;
    }
    return val->ele;
}",1,22,t_zset.c,zuiSdsFromValue,,false,2249,2259,zuiSdsFromValue,,,94,sds zuiSdsFromValue (zsetopval*)
457727,METHOD,t_zset.c:<global>,TYPE_DECL,"sds zuiNewSdsFromValue(zsetopval *val) {
    if (val->flags & OPVAL_DIRTY_SDS) {
        /* We have already one to return! */
        sds ele = val->ele;
        val->flags &= ~OPVAL_DIRTY_SDS;
        val->ele = NULL;
        return ele;
    } else if (val->ele) {
        return sdsdup(val->ele);
    } else if (val->estr) {
        return sdsnewlen((char*)val->estr,val->elen);
    } else {
        return sdsfromlonglong(val->ell);
    }
}",1,21,t_zset.c,zuiNewSdsFromValue,,false,2263,2277,zuiNewSdsFromValue,,,95,sds zuiNewSdsFromValue (zsetopval*)
457798,METHOD,t_zset.c:<global>,TYPE_DECL,"int zuiBufferFromValue(zsetopval *val) {
    if (val->estr == NULL) {
        if (val->ele != NULL) {
            val->elen = sdslen(val->ele);
            val->estr = (unsigned char*)val->ele;
        } else {
            val->elen = ll2string((char*)val->_buf,sizeof(val->_buf),val->ell);
            val->estr = val->_buf;
        }
    }
    return 1;
}",1,1,t_zset.c,zuiBufferFromValue,,false,2279,2290,zuiBufferFromValue,,,96,int zuiBufferFromValue (zsetopval*)
457862,METHOD,t_zset.c:<global>,TYPE_DECL,"int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {
    if (op->subject == NULL)
        return 0;

    if (op->type == OBJ_SET) {
        char *str = val->ele ? val->ele : (char *)val->estr;
        size_t len = val->ele ? sdslen(val->ele) : val->elen;
        if (setTypeIsMemberAux(op->subject, str, len, val->ell, val->ele != NULL)) {
            *score = 1.0;
            return 1;
        } else {
            return 0;
        }
    } else if (op->type == OBJ_ZSET) {
        zuiSdsFromValue(val);

        if (op->encoding == OBJ_ENCODING_LISTPACK) {
            if (zzlFind(op->subject->ptr,val->ele,score) != NULL) {
                /* Score is already set by zzlFind. */
                return 1;
            } else {
                return 0;
            }
        } else if (op->encoding == OBJ_ENCODING_SKIPLIST) {
            zset *zs = op->subject->ptr;
            dictEntry *de;
            if ((de = dictFind(zs->dict,val->ele)) != NULL) {
                *score = *(dou...",1,20,t_zset.c,zuiFind,,false,2294,2332,zuiFind,,,97,"int zuiFind (zsetopsrc*,zsetopval*,double*)"
458051,METHOD,t_zset.c:<global>,TYPE_DECL,"int zuiCompareByCardinality(const void *s1, const void *s2) {
    unsigned long first = zuiLength((zsetopsrc*)s1);
    unsigned long second = zuiLength((zsetopsrc*)s2);
    if (first > second) return 1;
    if (first < second) return -1;
    return 0;
}",1,1,t_zset.c,zuiCompareByCardinality,,false,2334,2340,zuiCompareByCardinality,,,98,"int zuiCompareByCardinality (void*,void*)"
458088,METHOD,t_zset.c:<global>,TYPE_DECL,"static int zuiCompareByRevCardinality(const void *s1, const void *s2) {
    return zuiCompareByCardinality(s1, s2) * -1;
}",1,1,t_zset.c,zuiCompareByRevCardinality,,false,2342,2344,zuiCompareByRevCardinality,,,99,"int zuiCompareByRevCardinality (void*,void*)"
458101,METHOD,t_zset.c:<global>,TYPE_DECL,"inline static void zunionInterAggregate(double *target, double val, int aggregate) {
    if (aggregate == REDIS_AGGR_SUM) {
        *target = *target + val;
        /* The result of adding two doubles is NaN when one variable
         * is +inf and the other is -inf. When these numbers are added,
         * we maintain the convention of the result being 0.0. */
        if (isnan(*target)) *target = 0.0;
    } else if (aggregate == REDIS_AGGR_MIN) {
        *target = val < *target ? val : *target;
    } else if (aggregate == REDIS_AGGR_MAX) {
        *target = val > *target ? val : *target;
    } else {
        /* safety net */
        serverPanic(""Unknown ZUNION/INTER aggregate type"");
    }
}",1,21,t_zset.c,zunionInterAggregate,,false,2351,2366,zunionInterAggregate,,,100,"void zunionInterAggregate (double*,double,int)"
458181,METHOD,t_zset.c:<global>,TYPE_DECL,"static size_t zsetDictGetMaxElementLength(dict *d, size_t *totallen) {
    dictIterator *di;
    dictEntry *de;
    size_t maxelelen = 0;

    di = dictGetIterator(d);

    while((de = dictNext(di)) != NULL) {
        sds ele = dictGetKey(de);
        if (sdslen(ele) > maxelelen) maxelelen = sdslen(ele);
        if (totallen)
            (*totallen) += sdslen(ele);
    }

    dictReleaseIterator(di);

    return maxelelen;
}",1,1,t_zset.c,zsetDictGetMaxElementLength,,false,2368,2385,zsetDictGetMaxElementLength,,,101,"size_t zsetDictGetMaxElementLength (dict*,size_t*)"
458232,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zdiffAlgorithm1(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* DIFF Algorithm 1:
     *
     * We perform the diff by iterating all the elements of the first set,
     * and only adding it to the target set if the element does not exist
     * into all the other sets.
     *
     * This way we perform at max N*M operations, where N is the size of
     * the first set, and M the number of sets.
     *
     * There is also a O(K*log(K)) cost for adding the resulting elements
     * to the target set, where K is the final size of the target set.
     *
     * The final complexity of this algorithm is O(N*M + K*log(K)). */
    int j;
    zsetopval zval;
    zskiplistNode *znode;
    sds tmp;

    /* With algorithm 1 it is better to order the sets to subtract
     * by decreasing size, so that we are more likely to find
     * duplicated elements ASAP. */
    qsort(src+1,setnum-1,sizeof(zsetopsrc),zuiCompareByRevCardinality);

    m...",1,1,t_zset.c,zdiffAlgorithm1,,false,2387,2439,zdiffAlgorithm1,,,102,"void zdiffAlgorithm1 (zsetopsrc*,long,zset*,size_t*,size_t*)"
458368,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zdiffAlgorithm2(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* DIFF Algorithm 2:
     *
     * Add all the elements of the first set to the auxiliary set.
     * Then remove all the elements of all the next sets from it.
     *

     * This is O(L + (N-K)log(N)) where L is the sum of all the elements in every
     * set, N is the size of the first set, and K is the size of the result set.
     *
     * Note that from the (L-N) dict searches, (N-K) got to the zsetRemoveFromSkiplist
     * which costs log(N)
     *
     * There is also a O(K) cost at the end for finding the largest element
     * size, but this doesn't change the algorithm complexity since K < L, and
     * O(2L) is the same as O(L). */
    int j;
    int cardinality = 0;
    zsetopval zval;
    zskiplistNode *znode;
    sds tmp;

    for (j = 0; j < setnum; j++) {
        if (zuiLength(&src[j]) == 0) continue;

        memset(&zval, 0, sizeof(zval));
        zui...",1,1,t_zset.c,zdiffAlgorithm2,,false,2442,2497,zdiffAlgorithm2,,,103,"void zdiffAlgorithm2 (zsetopsrc*,long,zset*,size_t*,size_t*)"
458506,METHOD,t_zset.c:<global>,TYPE_DECL,"static int zsetChooseDiffAlgorithm(zsetopsrc *src, long setnum) {
    int j;

    /* Select what DIFF algorithm to use.
     *
     * Algorithm 1 is O(N*M + K*log(K)) where N is the size of the
     * first set, M the total number of sets, and K is the size of the
     * result set.
     *
     * Algorithm 2 is O(L + (N-K)log(N)) where L is the total number of elements
     * in all the sets, N is the size of the first set, and K is the size of the
     * result set.
     *
     * We compute what is the best bet with the current input here. */
    long long algo_one_work = 0;
    long long algo_two_work = 0;

    for (j = 0; j < setnum; j++) {
        /* If any other set is equal to the first set, there is nothing to be
         * done, since we would remove all elements anyway. */
        if (j > 0 && src[0].subject == src[j].subject) {
            return 0;
        }

        algo_one_work += zuiLength(&src[0]);
        algo_two_work += zuiLength(&src[j]);
    }

    /* Algorithm ...",1,1,t_zset.c,zsetChooseDiffAlgorithm,,false,2499,2531,zsetChooseDiffAlgorithm,,,104,"int zsetChooseDiffAlgorithm (zsetopsrc*,long)"
458575,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zdiff(zsetopsrc *src, long setnum, zset *dstzset, size_t *maxelelen, size_t *totelelen) {
    /* Skip everything if the smallest input is empty. */
    if (zuiLength(&src[0]) > 0) {
        int diff_algo = zsetChooseDiffAlgorithm(src, setnum);
        if (diff_algo == 1) {
            zdiffAlgorithm1(src, setnum, dstzset, maxelelen, totelelen);
        } else if (diff_algo == 2) {
            zdiffAlgorithm2(src, setnum, dstzset, maxelelen, totelelen);
        } else if (diff_algo != 0) {
            serverPanic(""Unknown algorithm"");
        }
    }
}",1,12,t_zset.c,zdiff,,false,2533,2545,zdiff,,,105,"void zdiff (zsetopsrc*,long,zset*,size_t*,size_t*)"
458649,METHOD,t_zset.c:<global>,TYPE_DECL,"void zunionInterDiffGenericCommand(client *c, robj *dstkey, int numkeysIndex, int op,
                                   int cardinality_only) {
    int i, j;
    long setnum;
    int aggregate = REDIS_AGGR_SUM;
    zsetopsrc *src;
    zsetopval zval;
    sds tmp;
    size_t maxelelen = 0, totelelen = 0;
    robj *dstobj = NULL;
    zset *dstzset = NULL;
    zskiplistNode *znode;
    int withscores = 0;
    unsigned long cardinality = 0;
    long limit = 0; /* Stop searching after reaching the limit. 0 means unlimited. */

    /* expect setnum input keys to be given */
    if ((getLongFromObjectOrReply(c, c->argv[numkeysIndex], &setnum, NULL) != C_OK))
        return;

    if (setnum < 1) {
        addReplyErrorFormat(c,
            ""at least 1 input key is needed for '%s' command"", c->cmd->fullname);
        return;
    }

    /* test if the expected number of keys would overflow */
    if (setnum > (c->argc-(numkeysIndex+1))) {
        addReplyErrorObject(c,shared.syntaxerr);
    ...",1,20,t_zset.c,zunionInterDiffGenericCommand,,false,2569,2860,zunionInterDiffGenericCommand,,,108,"void zunionInterDiffGenericCommand (client*,robj*,int,int,int)"
459785,METHOD,t_zset.c:<global>,TYPE_DECL,"void zunionstoreCommand(client *c) {
    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_UNION, 0);
}",1,52,t_zset.c,zunionstoreCommand,,false,2863,2865,zunionstoreCommand,,,109,void zunionstoreCommand (client*)
459802,METHOD,t_zset.c:<global>,TYPE_DECL,"void zinterstoreCommand(client *c) {
    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_INTER, 0);
}",1,52,t_zset.c,zinterstoreCommand,,false,2868,2870,zinterstoreCommand,,,110,void zinterstoreCommand (client*)
459819,METHOD,t_zset.c:<global>,TYPE_DECL,"void zdiffstoreCommand(client *c) {
    zunionInterDiffGenericCommand(c, c->argv[1], 2, SET_OP_DIFF, 0);
}",1,52,t_zset.c,zdiffstoreCommand,,false,2873,2875,zdiffstoreCommand,,,111,void zdiffstoreCommand (client*)
459836,METHOD,t_zset.c:<global>,TYPE_DECL,"void zunionCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_UNION, 0);
}",1,46,t_zset.c,zunionCommand,,false,2878,2880,zunionCommand,,,112,void zunionCommand (client*)
459849,METHOD,t_zset.c:<global>,TYPE_DECL,"void zinterCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 0);
}",1,46,t_zset.c,zinterCommand,,false,2883,2885,zinterCommand,,,113,void zinterCommand (client*)
459862,METHOD,t_zset.c:<global>,TYPE_DECL,"void zinterCardCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_INTER, 1);
}",1,46,t_zset.c,zinterCardCommand,,false,2888,2890,zinterCardCommand,,,114,void zinterCardCommand (client*)
459875,METHOD,t_zset.c:<global>,TYPE_DECL,"void zdiffCommand(client *c) {
    zunionInterDiffGenericCommand(c, NULL, 1, SET_OP_DIFF, 0);
}",1,46,t_zset.c,zdiffCommand,,false,2893,2895,zdiffCommand,,,115,void zdiffCommand (client*)
459892,METHOD,<empty>,<empty>,<empty>,1,,t_zset.c,zrange_direction:<clinit>,,false,2897,,<clinit>,,,4,
459903,METHOD,<empty>,<empty>,<empty>,1,,t_zset.c,zrange_consumer_type:<clinit>,,false,2903,,<clinit>,,,3,
459913,METHOD,t_zset.c:<global>,TYPE_DECL,"typedef void (*zrangeResultBeginFunction)(zrange_result_handler *c, long length);",14,80,t_zset.c,zrangeResultBeginFunction,,false,2910,2910,zrangeResultBeginFunction,,,122,"void zrangeResultBeginFunction (zrange_result_handler*,long)"
459919,METHOD,t_zset.c:<global>,TYPE_DECL,"typedef void (*zrangeResultFinalizeFunction)(
    zrange_result_handler *c, size_t result_count);",14,50,t_zset.c,zrangeResultFinalizeFunction,,false,2911,2912,zrangeResultFinalizeFunction,,,123,"void zrangeResultFinalizeFunction (zrange_result_handler*,size_t)"
459925,METHOD,t_zset.c:<global>,TYPE_DECL,"typedef void (*zrangeResultEmitCBufferFunction)(
    zrange_result_handler *c, const void *p, size_t len, double score);",14,70,t_zset.c,zrangeResultEmitCBufferFunction,,false,2913,2914,zrangeResultEmitCBufferFunction,,,124,"void zrangeResultEmitCBufferFunction (zrange_result_handler*,void*,size_t,double)"
459933,METHOD,t_zset.c:<global>,TYPE_DECL,"typedef void (*zrangeResultEmitLongLongFunction)(
    zrange_result_handler *c, long long ll, double score);",14,57,t_zset.c,zrangeResultEmitLongLongFunction,,false,2915,2916,zrangeResultEmitLongLongFunction,,,125,"void zrangeResultEmitLongLongFunction (zrange_result_handler*,long long,double)"
459940,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrangeGenericCommand (zrange_result_handler *handler, int argc_start, int store,
                           zrange_type rangetype, zrange_direction direction);",6,77,t_zset.c,zrangeGenericCommand,,false,2918,2919,zrangeGenericCommand,,,126,"void zrangeGenericCommand (zrange_result_handler*,int,int,zrange_type,zrange_direction)"
459961,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultBeginClient(zrange_result_handler *handler, long length) {
    if (length > 0) {
        /* In case of WITHSCORES, respond with a single array in RESP2, and
        * nested arrays in RESP3. We can't use a map response type since the
        * client library needs to know to respect the order. */
        if (handler->withscores && (handler->client->resp == 2)) {
            length *= 2;
        }
        addReplyArrayLen(handler->client, length);
        handler->userdata = NULL;
        return;
    }
    handler->userdata = addReplyDeferredLen(handler->client);
}",1,1,t_zset.c,zrangeResultBeginClient,,false,2942,2955,zrangeResultBeginClient,,,128,"void zrangeResultBeginClient (zrange_result_handler*,long)"
460007,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultEmitCBufferToClient(zrange_result_handler *handler,
    const void *value, size_t value_length_in_bytes, double score)
{
    if (handler->should_emit_array_length) {
        addReplyArrayLen(handler->client, 2);
    }

    addReplyBulkCBuffer(handler->client, value, value_length_in_bytes);

    if (handler->withscores) {
        addReplyDouble(handler->client, score);
    }
}",1,1,t_zset.c,zrangeResultEmitCBufferToClient,,false,2957,2969,zrangeResultEmitCBufferToClient,,,129,"void zrangeResultEmitCBufferToClient (zrange_result_handler*,void*,size_t,double)"
460041,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultEmitLongLongToClient(zrange_result_handler *handler,
    long long value, double score)
{
    if (handler->should_emit_array_length) {
        addReplyArrayLen(handler->client, 2);
    }

    addReplyBulkLongLong(handler->client, value);

    if (handler->withscores) {
        addReplyDouble(handler->client, score);
    }
}",1,1,t_zset.c,zrangeResultEmitLongLongToClient,,false,2971,2983,zrangeResultEmitLongLongToClient,,,130,"void zrangeResultEmitLongLongToClient (zrange_result_handler*,long long,double)"
460073,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultFinalizeClient(zrange_result_handler *handler,
    size_t result_count)
{
    /* If the reply size was know at start there's nothing left to do */
    if (!handler->userdata)
        return;
    /* In case of WITHSCORES, respond with a single array in RESP2, and
     * nested arrays in RESP3. We can't use a map response type since the
     * client library needs to know to respect the order. */
    if (handler->withscores && (handler->client->resp == 2)) {
        result_count *= 2;
    }

    setDeferredArrayLen(handler->client, handler->userdata, result_count);
}",1,1,t_zset.c,zrangeResultFinalizeClient,,false,2985,2999,zrangeResultFinalizeClient,,,131,"void zrangeResultFinalizeClient (zrange_result_handler*,size_t)"
460110,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultBeginStore(zrange_result_handler *handler, long length)
{
    handler->dstobj = zsetTypeCreate(length, 0);
}",1,1,t_zset.c,zrangeResultBeginStore,,false,3002,3005,zrangeResultBeginStore,,,132,"void zrangeResultBeginStore (zrange_result_handler*,long)"
460123,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultEmitCBufferForStore(zrange_result_handler *handler,
    const void *value, size_t value_length_in_bytes, double score)
{
    double newscore;
    int retflags = 0;
    sds ele = sdsnewlen(value, value_length_in_bytes);
    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);
    sdsfree(ele);
    serverAssert(retval);
}",1,54,t_zset.c,zrangeResultEmitCBufferForStore,,false,3007,3016,zrangeResultEmitCBufferForStore,,,133,"void zrangeResultEmitCBufferForStore (zrange_result_handler*,void*,size_t,double)"
460175,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultEmitLongLongForStore(zrange_result_handler *handler,
    long long value, double score)
{
    double newscore;
    int retflags = 0;
    sds ele = sdsfromlonglong(value);
    int retval = zsetAdd(handler->dstobj, score, ele, ZADD_IN_NONE, &retflags, &newscore);
    sdsfree(ele);
    serverAssert(retval);
}",1,54,t_zset.c,zrangeResultEmitLongLongForStore,,false,3018,3027,zrangeResultEmitLongLongForStore,,,134,"void zrangeResultEmitLongLongForStore (zrange_result_handler*,long long,double)"
460225,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultFinalizeStore(zrange_result_handler *handler, size_t result_count)
{
    if (result_count) {
        setKey(handler->client, handler->client->db, handler->dstkey, handler->dstobj, 0);
        addReplyLongLong(handler->client, result_count);
        notifyKeyspaceEvent(NOTIFY_ZSET, ""zrangestore"", handler->dstkey, handler->client->db->id);
        server.dirty++;
    } else {
        addReply(handler->client, shared.czero);
        if (dbDelete(handler->client->db, handler->dstkey)) {
            signalModifiedKey(handler->client, handler->client->db, handler->dstkey);
            notifyKeyspaceEvent(NOTIFY_GENERIC, ""del"", handler->dstkey, handler->client->db->id);
            server.dirty++;
        }
    }
    decrRefCount(handler->dstobj);
}",1,28,t_zset.c,zrangeResultFinalizeStore,,false,3029,3045,zrangeResultFinalizeStore,,,135,"void zrangeResultFinalizeStore (zrange_result_handler*,size_t)"
460333,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultHandlerInit(zrange_result_handler *handler,
    client *client, zrange_consumer_type type)
{
    memset(handler, 0, sizeof(*handler));

    handler->client = client;

    switch (type) {
    case ZRANGE_CONSUMER_TYPE_CLIENT:
        handler->beginResultEmission = zrangeResultBeginClient;
        handler->finalizeResultEmission = zrangeResultFinalizeClient;
        handler->emitResultFromCBuffer = zrangeResultEmitCBufferToClient;
        handler->emitResultFromLongLong = zrangeResultEmitLongLongToClient;
        break;

    case ZRANGE_CONSUMER_TYPE_INTERNAL:
        handler->beginResultEmission = zrangeResultBeginStore;
        handler->finalizeResultEmission = zrangeResultFinalizeStore;
        handler->emitResultFromCBuffer = zrangeResultEmitCBufferForStore;
        handler->emitResultFromLongLong = zrangeResultEmitLongLongForStore;
        break;
    }
}",1,1,t_zset.c,zrangeResultHandlerInit,,false,3048,3070,zrangeResultHandlerInit,,,136,"void zrangeResultHandlerInit (zrange_result_handler*,client*,zrange_consumer_type)"
460400,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultHandlerScoreEmissionEnable(zrange_result_handler *handler) {
    handler->withscores = 1;
    handler->should_emit_array_length = (handler->client->resp > 2);
}",1,1,t_zset.c,zrangeResultHandlerScoreEmissionEnable,,false,3072,3075,zrangeResultHandlerScoreEmissionEnable,,,137,void zrangeResultHandlerScoreEmissionEnable (zrange_result_handler*)
460421,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrangeResultHandlerDestinationKeySet (zrange_result_handler *handler,
    robj *dstkey)
{
    handler->dstkey = dstkey;
}",1,1,t_zset.c,zrangeResultHandlerDestinationKeySet,,false,3077,3081,zrangeResultHandlerDestinationKeySet,,,138,"void zrangeResultHandlerDestinationKeySet (zrange_result_handler*,robj*)"
460432,METHOD,t_zset.c:<global>,TYPE_DECL,"void genericZrangebyrankCommand(zrange_result_handler *handler,
    robj *zobj, long start, long end, int withscores, int reverse) {

    client *c = handler->client;
    long llen;
    long rangelen;
    size_t result_cardinality;

    /* Sanitize indexes. */
    llen = zsetLength(zobj);
    if (start < 0) start = llen+start;
    if (end < 0) end = llen+end;
    if (start < 0) start = 0;


    /* Invariant: start >= 0, so this test will be true when end < 0.
     * The range is empty when start > end or start >= length. */
    if (start > end || start >= llen) {
        handler->beginResultEmission(handler, 0);
        handler->finalizeResultEmission(handler, 0);
        return;
    }
    if (end >= llen) end = llen-1;
    rangelen = (end-start)+1;
    result_cardinality = rangelen;

    handler->beginResultEmission(handler, rangelen);
    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char ...",1,26,t_zset.c,genericZrangebyrankCommand,,false,3084,3173,genericZrangebyrankCommand,,,139,"void genericZrangebyrankCommand (zrange_result_handler*,robj*,long,long,int,int)"
460824,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrangestoreCommand (client *c) {
    robj *dstkey = c->argv[1];
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_INTERNAL);
    zrangeResultHandlerDestinationKeySet(&handler, dstkey);
    zrangeGenericCommand(&handler, 2, 1, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);
}",1,1,t_zset.c,zrangestoreCommand,,false,3176,3182,zrangestoreCommand,,,140,void zrangestoreCommand (client*)
460854,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrangeCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_AUTO, ZRANGE_DIRECTION_AUTO);
}",1,1,t_zset.c,zrangeCommand,,false,3185,3189,zrangeCommand,,,141,void zrangeCommand (client*)
460872,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrevrangeCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_RANK, ZRANGE_DIRECTION_REVERSE);
}",1,1,t_zset.c,zrevrangeCommand,,false,3192,3196,zrevrangeCommand,,,142,void zrevrangeCommand (client*)
460890,METHOD,t_zset.c:<global>,TYPE_DECL,"void genericZrangebyscoreCommand(zrange_result_handler *handler,
    zrangespec *range, robj *zobj, long offset, long limit, 
    int reverse) {
    unsigned long rangelen = 0;

    handler->beginResultEmission(handler, -1);

    /* For invalid offset, return directly. */
    if (offset > 0 && offset >= (long)zsetLength(zobj)) {
        handler->finalizeResultEmission(handler, 0);
        return;
    }

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        /* If reversed, get the last node in range as starting point. */
        if (reverse) {
            eptr = zzlLastInRange(zl,range);
        } else {
            eptr = zzlFirstInRange(zl,range);
        }

        /* Get score pointer for the first element. */
        if (eptr)
            sptr = lpNext(zl,eptr);

        /* If there is an offset, just traverse the numbe...",1,26,t_zset.c,genericZrangebyscoreCommand,,false,3199,3310,genericZrangebyscoreCommand,,,143,"void genericZrangebyscoreCommand (zrange_result_handler*,zrangespec*,robj*,long,long,int)"
461220,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrangebyscoreCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_FORWARD);
}",1,1,t_zset.c,zrangebyscoreCommand,,false,3313,3317,zrangebyscoreCommand,,,144,void zrangebyscoreCommand (client*)
461238,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrevrangebyscoreCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_SCORE, ZRANGE_DIRECTION_REVERSE);
}",1,1,t_zset.c,zrevrangebyscoreCommand,,false,3320,3324,zrevrangebyscoreCommand,,,145,void zrevrangebyscoreCommand (client*)
461256,METHOD,t_zset.c:<global>,TYPE_DECL,"void zcountCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    zrangespec range;
    unsigned long count = 0;

    /* Parse the range arguments */
    if (zslParseRange(c->argv[2],c->argv[3],&range) != C_OK) {
        addReplyError(c,""min or max is not a float"");
        return;
    }

    /* Lookup the sorted set */
    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
        checkType(c, zobj, OBJ_ZSET)) return;

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        double score;

        /* Use the first element in range as the starting point */
        eptr = zzlFirstInRange(zl,&range);

        /* No ""first"" element */
        if (eptr == NULL) {
            addReply(c, shared.czero);
            return;
        }

        /* First element is in range */
        sptr = lpNext(zl,eptr);
        score = zzlGetScore(sptr);
        serverAssertWithInfo(c,zobj,zslValueL...",1,55,t_zset.c,zcountCommand,,false,3326,3401,zcountCommand,,,146,void zcountCommand (client*)
461504,METHOD,t_zset.c:<global>,TYPE_DECL,"void zlexcountCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    zlexrangespec range;
    unsigned long count = 0;

    /* Parse the range arguments */
    if (zslParseLexRange(c->argv[2],c->argv[3],&range) != C_OK) {
        addReplyError(c,""min or max not valid string range item"");
        return;
    }

    /* Lookup the sorted set */
    if ((zobj = lookupKeyReadOrReply(c, key, shared.czero)) == NULL ||
        checkType(c, zobj, OBJ_ZSET))
    {
        zslFreeLexRange(&range);
        return;
    }

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;

        /* Use the first element in range as the starting point */
        eptr = zzlFirstInLexRange(zl,&range);

        /* No ""first"" element */
        if (eptr == NULL) {
            zslFreeLexRange(&range);
            addReply(c, shared.czero);
            return;
        }

        /* First element is in range */
        sptr = lpNe...",1,58,t_zset.c,zlexcountCommand,,false,3403,3480,zlexcountCommand,,,147,void zlexcountCommand (client*)
461752,METHOD,t_zset.c:<global>,TYPE_DECL,"void genericZrangebylexCommand(zrange_result_handler *handler,
    zlexrangespec *range, robj *zobj, int withscores, long offset, long limit,
    int reverse)
{
    unsigned long rangelen = 0;

    handler->beginResultEmission(handler, -1);

    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {
        unsigned char *zl = zobj->ptr;
        unsigned char *eptr, *sptr;
        unsigned char *vstr;
        unsigned int vlen;
        long long vlong;

        /* If reversed, get the last node in range as starting point. */
        if (reverse) {
            eptr = zzlLastInLexRange(zl,range);
        } else {
            eptr = zzlFirstInLexRange(zl,range);
        }

        /* Get score pointer for the first element. */
        if (eptr)
            sptr = lpNext(zl,eptr);

        /* If there is an offset, just traverse the number of elements without
         * checking the score because that is done in the next loop. */
        while (eptr && offset--) {
            if (reverse) {
   ...",1,26,t_zset.c,genericZrangebylexCommand,,false,3483,3591,genericZrangebylexCommand,,,148,"void genericZrangebylexCommand (zrange_result_handler*,zlexrangespec*,robj*,int,long,long,int)"
462070,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrangebylexCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_FORWARD);
}",1,1,t_zset.c,zrangebylexCommand,,false,3594,3598,zrangebylexCommand,,,149,void zrangebylexCommand (client*)
462088,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrevrangebylexCommand(client *c) {
    zrange_result_handler handler;
    zrangeResultHandlerInit(&handler, c, ZRANGE_CONSUMER_TYPE_CLIENT);
    zrangeGenericCommand(&handler, 1, 0, ZRANGE_LEX, ZRANGE_DIRECTION_REVERSE);
}",1,1,t_zset.c,zrevrangebylexCommand,,false,3601,3605,zrevrangebylexCommand,,,150,void zrevrangebylexCommand (client*)
462106,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrangeGenericCommand(zrange_result_handler *handler, int argc_start, int store,
                          zrange_type rangetype, zrange_direction direction)
{
    client *c = handler->client;
    robj *key = c->argv[argc_start];
    robj *zobj;
    zrangespec range;
    zlexrangespec lexrange;
    int minidx = argc_start + 1;
    int maxidx = argc_start + 2;

    /* Options common to all */
    long opt_start = 0;
    long opt_end = 0;
    int opt_withscores = 0;
    long opt_offset = 0;
    long opt_limit = -1;

    /* Step 1: Skip the <src> <min> <max> args and parse remaining optional arguments. */
    for (int j=argc_start + 3; j < c->argc; j++) {
        int leftargs = c->argc-j-1;
        if (!store && !strcasecmp(c->argv[j]->ptr,""withscores"")) {
            opt_withscores = 1;
        } else if (!strcasecmp(c->argv[j]->ptr,""limit"") && leftargs >= 2) {
            if ((getLongFromObjectOrReply(c, c->argv[j+1], &opt_offset, NULL) != C_OK) ||
                (getLongFromObj...",1,81,t_zset.c,zrangeGenericCommand,,false,3617,3763,zrangeGenericCommand,,,151,"void zrangeGenericCommand (zrange_result_handler*,int,int,zrange_type,zrange_direction)"
462602,METHOD,t_zset.c:<global>,TYPE_DECL,"void zcardCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;

    if ((zobj = lookupKeyReadOrReply(c,key,shared.czero)) == NULL ||
        checkType(c,zobj,OBJ_ZSET)) return;

    addReplyLongLong(c,zsetLength(zobj));
}",1,25,t_zset.c,zcardCommand,,false,3765,3773,zcardCommand,,,152,void zcardCommand (client*)
462640,METHOD,t_zset.c:<global>,TYPE_DECL,"void zscoreCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    double score;

    if ((zobj = lookupKeyReadOrReply(c,key,shared.null[c->resp])) == NULL ||
        checkType(c,zobj,OBJ_ZSET)) return;

    if (zsetScore(zobj,c->argv[2]->ptr,&score) == C_ERR) {
        addReplyNull(c);
    } else {
        addReplyDouble(c,score);
    }
}",1,25,t_zset.c,zscoreCommand,,false,3775,3788,zscoreCommand,,,153,void zscoreCommand (client*)
462704,METHOD,t_zset.c:<global>,TYPE_DECL,"void zmscoreCommand(client *c) {
    robj *key = c->argv[1];
    robj *zobj;
    double score;
    zobj = lookupKeyRead(c->db,key);
    if (checkType(c,zobj,OBJ_ZSET)) return;

    addReplyArrayLen(c,c->argc - 2);
    for (int j = 2; j < c->argc; j++) {
        /* Treat a missing set the same way as an empty set */
        if (zobj == NULL || zsetScore(zobj,c->argv[j]->ptr,&score) == C_ERR) {
            addReplyNull(c);
        } else {
            addReplyDouble(c,score);
        }
    }
}",1,25,t_zset.c,zmscoreCommand,,false,3790,3806,zmscoreCommand,,,154,void zmscoreCommand (client*)
462785,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrankGenericCommand(client *c, int reverse) {
    robj *key = c->argv[1];
    robj *ele = c->argv[2];
    robj *zobj;
    robj* reply;
    long rank;
    int opt_withscore = 0;
    double score;

    if (c->argc > 4) {
        addReplyErrorArity(c);
        return;
    }
    if (c->argc > 3) {
        if (!strcasecmp(c->argv[3]->ptr, ""withscore"")) {
            opt_withscore = 1;
        } else {
            addReplyErrorObject(c, shared.syntaxerr);
            return;
        }
    }
    reply = opt_withscore ? shared.nullarray[c->resp] : shared.null[c->resp];
    if ((zobj = lookupKeyReadOrReply(c, key, reply)) == NULL || checkType(c, zobj, OBJ_ZSET)) {
        return;
    }
    serverAssertWithInfo(c, ele, sdsEncodedObject(ele));
    rank = zsetRank(zobj, ele->ptr, reverse, opt_withscore ? &score : NULL);
    if (rank >= 0) {
        if (opt_withscore) {
            addReplyArrayLen(c, 2);
        }
        addReplyLongLong(c, rank);
        if (opt_withscore) {
            ...",1,83,t_zset.c,zrankGenericCommand,,false,3808,3850,zrankGenericCommand,,,155,"void zrankGenericCommand (client*,int)"
462963,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrankCommand(client *c) {
    zrankGenericCommand(c, 0);
}",1,1,t_zset.c,zrankCommand,,false,3852,3854,zrankCommand,,,156,void zrankCommand (client*)
462971,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrevrankCommand(client *c) {
    zrankGenericCommand(c, 1);
}",1,1,t_zset.c,zrevrankCommand,,false,3856,3858,zrevrankCommand,,,157,void zrevrankCommand (client*)
462979,METHOD,t_zset.c:<global>,TYPE_DECL,"void zscanCommand(client *c) {
    robj *o;
    unsigned long cursor;

    if (parseScanCursorOrReply(c,c->argv[2],&cursor) == C_ERR) return;
    if ((o = lookupKeyReadOrReply(c,c->argv[1],shared.emptyscan)) == NULL ||
        checkType(c,o,OBJ_ZSET)) return;
    scanGenericCommand(c,o,cursor);
}",1,56,t_zset.c,zscanCommand,,false,3860,3868,zscanCommand,,,158,void zscanCommand (client*)
463031,METHOD,t_zset.c:<global>,TYPE_DECL,"void genericZpopCommand(client *c, robj **keyv, int keyc, int where, int emitkey,
                        long count, int use_nested_array, int reply_nil_when_empty, int *deleted) {
    int idx;
    robj *key = NULL;
    robj *zobj = NULL;
    sds ele;
    double score;

    if (deleted) *deleted = 0;

    /* Check type and break on the first error, otherwise identify candidate. */
    idx = 0;
    while (idx < keyc) {
        key = keyv[idx++];
        zobj = lookupKeyWrite(c->db,key);
        if (!zobj) continue;
        if (checkType(c,zobj,OBJ_ZSET)) return;
        break;
    }

    /* No candidate for zpopping, return empty. */
    if (!zobj) {
        if (reply_nil_when_empty) {
            addReplyNullArray(c);
        } else {
            addReply(c,shared.emptyarray);
        }
        return;
    }

    if (count == 0) {
        /* ZPOPMIN/ZPOPMAX with count 0. */
        addReply(c, shared.emptyarray);
        return;
    }

    long result_count = 0;

    /* When count ...",1,29,t_zset.c,genericZpopCommand,,false,3891,4025,genericZpopCommand,,,159,"void genericZpopCommand (client*,robj**,int,int,int,long,int,int,int*)"
463548,METHOD,t_zset.c:<global>,TYPE_DECL,"void zpopMinMaxCommand(client *c, int where) {
    if (c->argc > 3) {
        addReplyErrorObject(c,shared.syntaxerr);
        return;
    }

    long count = -1; /* -1 for plain single pop. */
    if (c->argc == 3 && getPositiveLongFromObjectOrReply(c, c->argv[2], &count, NULL) != C_OK)
        return;

    /* Respond with a single (flat) array in RESP2 or if count is -1
     * (returning a single element). In RESP3, when count > 0 use nested array. */
    int use_nested_array = (c->resp > 2 && count != -1);

    genericZpopCommand(c, &c->argv[1], 1, where, 0, count, use_nested_array, 0, NULL);
}",1,89,t_zset.c,zpopMinMaxCommand,,false,4028,4043,zpopMinMaxCommand,,,160,"void zpopMinMaxCommand (client*,int)"
463623,METHOD,t_zset.c:<global>,TYPE_DECL,"void zpopminCommand(client *c) {
    zpopMinMaxCommand(c, ZSET_MIN);
}",1,25,t_zset.c,zpopminCommand,,false,4046,4048,zpopminCommand,,,161,void zpopminCommand (client*)
463633,METHOD,t_zset.c:<global>,TYPE_DECL,"void zpopmaxCommand(client *c) {
    zpopMinMaxCommand(c, ZSET_MAX);
}",1,25,t_zset.c,zpopmaxCommand,,false,4051,4053,zpopmaxCommand,,,162,void zpopmaxCommand (client*)
463643,METHOD,t_zset.c:<global>,TYPE_DECL,"void blockingGenericZpopCommand(client *c, robj **keys, int numkeys, int where,
                                int timeout_idx, long count, int use_nested_array, int reply_nil_when_empty) {
    robj *o;
    robj *key;
    mstime_t timeout;
    int j;

    if (getTimeoutFromObjectOrReply(c,c->argv[timeout_idx],&timeout,UNIT_SECONDS)
        != C_OK) return;

    for (j = 0; j < numkeys; j++) {
        key = keys[j];
        o = lookupKeyWrite(c->db,key);
        /* Non-existing key, move to next key. */
        if (o == NULL) continue;

        if (checkType(c,o,OBJ_ZSET)) return;

        long llen = zsetLength(o);
        /* Empty zset, move to next key. */
        if (llen == 0) continue;

        /* Non empty zset, this is like a normal ZPOP[MIN|MAX]. */
        genericZpopCommand(c, &key, 1, where, 1, count, use_nested_array, reply_nil_when_empty, NULL);

        if (count == -1) {
            /* Replicate it as ZPOP[MIN|MAX] instead of BZPOP[MIN|MAX]. */
            rewriteCli...",1,68,t_zset.c,blockingGenericZpopCommand,,false,4068,4119,blockingGenericZpopCommand,,,163,"void blockingGenericZpopCommand (client*,robj**,int,int,int,long,int,int)"
463813,METHOD,t_zset.c:<global>,TYPE_DECL,"void bzpopminCommand(client *c) {
    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MIN, c->argc-1, -1, 0, 0);
}",1,56,t_zset.c,bzpopminCommand,,false,4122,4124,bzpopminCommand,,,164,void bzpopminCommand (client*)
463842,METHOD,t_zset.c:<global>,TYPE_DECL,"void bzpopmaxCommand(client *c) {
    blockingGenericZpopCommand(c, c->argv+1, c->argc-2, ZSET_MAX, c->argc-1, -1, 0, 0);
}",1,56,t_zset.c,bzpopmaxCommand,,false,4127,4129,bzpopmaxCommand,,,165,void bzpopmaxCommand (client*)
463871,METHOD,t_zset.c:<global>,TYPE_DECL,"static void zrandmemberReplyWithListpack(client *c, unsigned int count, listpackEntry *keys, listpackEntry *vals) {
    for (unsigned long i = 0; i < count; i++) {
        if (vals && c->resp > 2)
            addReplyArrayLen(c,2);
        if (keys[i].sval)
            addReplyBulkCBuffer(c, keys[i].sval, keys[i].slen);
        else
            addReplyBulkLongLong(c, keys[i].lval);
        if (vals) {
            if (vals[i].sval) {
                addReplyDouble(c, zzlStrtod(vals[i].sval,vals[i].slen));
            } else
                addReplyDouble(c, vals[i].lval);
        }
    }
}",1,1,t_zset.c,zrandmemberReplyWithListpack,,false,4131,4146,zrandmemberReplyWithListpack,,,166,"void zrandmemberReplyWithListpack (client*,unsigned int,listpackEntry*,listpackEntry*)"
463963,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrandmemberWithCountCommand(client *c, long l, int withscores) {
    unsigned long count, size;
    int uniq = 1;
    robj *zsetobj;

    if ((zsetobj = lookupKeyReadOrReply(c, c->argv[1], shared.emptyarray))
        == NULL || checkType(c, zsetobj, OBJ_ZSET)) return;
    size = zsetLength(zsetobj);

    if(l >= 0) {
        count = (unsigned long) l;
    } else {
        count = -l;
        uniq = 0;
    }

    /* If count is zero, serve it ASAP to avoid special cases later. */
    if (count == 0) {
        addReply(c,shared.emptyarray);
        return;
    }

    /* CASE 1: The count was negative, so the extraction method is just:
     * ""return N random elements"" sampling the whole set every time.
     * This case is trivial and can be served without auxiliary data
     * structures. This case is the only one that also needs to return the
     * elements in random order. */
    if (!uniq || count == 1) {
        if (withscores && c->resp == 2)
            addReplyArrayLen(c,...",1,41,t_zset.c,zrandmemberWithCountCommand,,false,4158,4360,zrandmemberWithCountCommand,,,167,"void zrandmemberWithCountCommand (client*,long,int)"
464617,METHOD,t_zset.c:<global>,TYPE_DECL,"void zrandmemberCommand(client *c) {
    long l;
    int withscores = 0;
    robj *zset;
    listpackEntry ele;

    if (c->argc >= 3) {
        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;
        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,""withscores""))) {
            addReplyErrorObject(c,shared.syntaxerr);
            return;
        } else if (c->argc == 4) {
            withscores = 1;
            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {
                addReplyError(c,""value is out of range"");
                return;
            }
        }
        zrandmemberWithCountCommand(c, l, withscores);
        return;
    }

    /* Handle variant without <count> argument. Reply with simple bulk string */
    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||
        checkType(c,zset,OBJ_ZSET)) {
        return;
    }

    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);
    zsetRep...",1,86,t_zset.c,zrandmemberCommand,,false,4363,4393,zrandmemberCommand,,,168,void zrandmemberCommand (client*)
464759,METHOD,t_zset.c:<global>,TYPE_DECL,"void zmpopGenericCommand(client *c, int numkeys_idx, int is_block) {
    long j;
    long numkeys = 0;      /* Number of keys. */
    int where = 0;         /* ZSET_MIN or ZSET_MAX. */
    long count = -1;       /* Reply will consist of up to count elements, depending on the zset's length. */

    /* Parse the numkeys. */
    if (getRangeLongFromObjectOrReply(c, c->argv[numkeys_idx], 1, LONG_MAX,
                                      &numkeys, ""numkeys should be greater than 0"") != C_OK)
        return;

    /* Parse the where. where_idx: the index of where in the c->argv. */
    long where_idx = numkeys_idx + numkeys + 1;
    if (where_idx >= c->argc) {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }
    if (!strcasecmp(c->argv[where_idx]->ptr, ""MIN"")) {
        where = ZSET_MIN;
    } else if (!strcasecmp(c->argv[where_idx]->ptr, ""MAX"")) {
        where = ZSET_MAX;
    } else {
        addReplyErrorObject(c, shared.syntaxerr);
        return;
    }

    /* ...",1,87,t_zset.c,zmpopGenericCommand,,false,4399,4450,zmpopGenericCommand,,,169,"void zmpopGenericCommand (client*,int,int)"
464986,METHOD,t_zset.c:<global>,TYPE_DECL,"void zmpopCommand(client *c) {
    zmpopGenericCommand(c, 1, 0);
}",1,1,t_zset.c,zmpopCommand,,false,4453,4455,zmpopCommand,,,170,void zmpopCommand (client*)
464995,METHOD,t_zset.c:<global>,TYPE_DECL,"void bzmpopCommand(client *c) {
    zmpopGenericCommand(c, 2, 1);
}",1,1,t_zset.c,bzmpopCommand,,false,4458,4460,bzmpopCommand,,,171,void bzmpopCommand (client*)
465007,METHOD,testhelp.h:<global>,TYPE_DECL,<global>,1,6,testhelp.h,testhelp.h:<global>,,false,1,62,<global>,,,1,
465020,METHOD,timeout.c:<global>,TYPE_DECL,<global>,1,1,timeout.c,timeout.c:<global>,,false,1,202,<global>,,,1,
465022,METHOD,timeout.c:<global>,TYPE_DECL,"int checkBlockedClientTimeout(client *c, mstime_t now) {
    if (c->flags & CLIENT_BLOCKED &&
        c->bstate.timeout != 0
        && c->bstate.timeout < now)
    {
        /* Handle blocking operation specific timeout. */
        unblockClientOnTimeout(c);
        return 1;
    } else {
        return 0;
    }
}",1,19,timeout.c,checkBlockedClientTimeout,,false,39,50,checkBlockedClientTimeout,,,1,"int checkBlockedClientTimeout (client*,mstime_t)"
465063,METHOD,timeout.c:<global>,TYPE_DECL,"int clientsCronHandleTimeout(client *c, mstime_t now_ms) {
    time_t now = now_ms/1000;

    if (server.maxidletime &&
        /* This handles the idle clients connection timeout if set. */
        !(c->flags & CLIENT_SLAVE) &&   /* No timeout for slaves and monitors */
        !mustObeyClient(c) &&         /* No timeout for masters and AOF */
        !(c->flags & CLIENT_BLOCKED) && /* No timeout for BLPOP */
        !(c->flags & CLIENT_PUBSUB) &&  /* No timeout for Pub/Sub clients */
        (now - c->lastinteraction > server.maxidletime))
    {
        serverLog(LL_VERBOSE,""Closing idle client"");
        freeClient(c);
        return 1;
    } else if (c->flags & CLIENT_BLOCKED) {
        /* Cluster: handle unblock & redirect of clients blocked
         * into keys no longer served by this server. */
        if (server.cluster_enabled) {
            if (clusterRedirectBlockedClientIfNeeded(c))
                unblockClientOnError(c, NULL);
        }
    }
    return 0;
}",1,21,timeout.c,clientsCronHandleTimeout,,false,56,79,clientsCronHandleTimeout,,,2,"int clientsCronHandleTimeout (client*,mstime_t)"
465176,METHOD,timeout.c:<global>,TYPE_DECL,"void encodeTimeoutKey(unsigned char *buf, uint64_t timeout, client *c) {
    timeout = htonu64(timeout);
    memcpy(buf,&timeout,sizeof(timeout));
    memcpy(buf+8,&c,sizeof(c));
    if (sizeof(c) == 4) memset(buf+12,0,4); /* Zero padding for 32bit target. */
}",1,14,timeout.c,encodeTimeoutKey,,false,97,102,encodeTimeoutKey,,,3,"void encodeTimeoutKey (unsigned char*,uint64_t,client*)"
465216,METHOD,timeout.c:<global>,TYPE_DECL,"void decodeTimeoutKey(unsigned char *buf, uint64_t *toptr, client **cptr) {
    memcpy(toptr,buf,sizeof(*toptr));
    *toptr = ntohu64(*toptr);
    memcpy(cptr,buf+8,sizeof(*cptr));
}",1,13,timeout.c,decodeTimeoutKey,,false,106,110,decodeTimeoutKey,,,4,"void decodeTimeoutKey (unsigned char*,uint64_t*,client**)"
465247,METHOD,timeout.c:<global>,TYPE_DECL,"void addClientToTimeoutTable(client *c) {
    if (c->bstate.timeout == 0) return;
    uint64_t timeout = c->bstate.timeout;
    unsigned char buf[CLIENT_ST_KEYLEN];
    encodeTimeoutKey(buf,timeout,c);
    if (raxTryInsert(server.clients_timeout_table,buf,sizeof(buf),NULL,NULL))
        c->flags |= CLIENT_IN_TO_TABLE;
}",1,22,timeout.c,addClientToTimeoutTable,,false,115,122,addClientToTimeoutTable,,,5,void addClientToTimeoutTable (client*)
465295,METHOD,timeout.c:<global>,TYPE_DECL,"void removeClientFromTimeoutTable(client *c) {
    if (!(c->flags & CLIENT_IN_TO_TABLE)) return;
    c->flags &= ~CLIENT_IN_TO_TABLE;
    uint64_t timeout = c->bstate.timeout;
    unsigned char buf[CLIENT_ST_KEYLEN];
    encodeTimeoutKey(buf,timeout,c);
    raxRemove(server.clients_timeout_table,buf,sizeof(buf),NULL);
}",1,21,timeout.c,removeClientFromTimeoutTable,,false,126,133,removeClientFromTimeoutTable,,,6,void removeClientFromTimeoutTable (client*)
465344,METHOD,timeout.c:<global>,TYPE_DECL,"void handleBlockedClientsTimeout(void) {
    if (raxSize(server.clients_timeout_table) == 0) return;
    uint64_t now = mstime();
    raxIterator ri;
    raxStart(&ri,server.clients_timeout_table);
    raxSeek(&ri,""^"",NULL,0);

    while(raxNext(&ri)) {
        uint64_t timeout;
        client *c;
        decodeTimeoutKey(ri.key,&timeout,&c);
        if (timeout >= now) break; /* All the timeouts are in the future. */
        c->flags &= ~CLIENT_IN_TO_TABLE;
        checkBlockedClientTimeout(c,now);
        raxRemove(server.clients_timeout_table,ri.key,ri.key_len,NULL);
        raxSeek(&ri,""^"",NULL,0);
    }
    raxStop(&ri);
}",1,21,timeout.c,handleBlockedClientsTimeout,,false,137,155,handleBlockedClientsTimeout,,,7,void handleBlockedClientsTimeout (void)
465429,METHOD,timeout.c:<global>,TYPE_DECL,"int getTimeoutFromObjectOrReply(client *c, robj *object, mstime_t *timeout, int unit) {
    long long tval;
    long double ftval;
    mstime_t now = commandTimeSnapshot();

    if (unit == UNIT_SECONDS) {
        if (getLongDoubleFromObjectOrReply(c,object,&ftval,
            ""timeout is not a float or out of range"") != C_OK)
            return C_ERR;

        ftval *= 1000.0;  /* seconds => millisec */
        if (ftval > LLONG_MAX) {
            addReplyError(c, ""timeout is out of range"");
            return C_ERR;
        }
        tval = (long long) ceill(ftval);
    } else {
        if (getLongLongFromObjectOrReply(c,object,&tval,
            ""timeout is not an integer or out of range"") != C_OK)
            return C_ERR;
    }

    if (tval < 0) {
        addReplyError(c,""timeout is negative"");
        return C_ERR;
    }

    if (tval > 0) {
        if  (tval > LLONG_MAX - now) {
            addReplyError(c,""timeout is out of range""); /* 'tval+now' would overflow */
         ...",1,16,timeout.c,getTimeoutFromObjectOrReply,,false,165,202,getTimeoutFromObjectOrReply,,,8,"int getTimeoutFromObjectOrReply (client*,robj*,mstime_t*,int)"
465579,METHOD,tls.c:<global>,TYPE_DECL,<global>,1,1,tls.c,tls.c:<global>,,false,1,1204,<global>,,,1,
465581,METHOD,tls.c:<global>,TYPE_DECL,"int RedisRegisterConnectionTypeTLS(void) {
    serverLog(LL_VERBOSE, ""Connection type %s not builtin"", CONN_TYPE_TLS);
    return C_ERR;
}",1,4,tls.c,RedisRegisterConnectionTypeTLS,,false,1161,1164,RedisRegisterConnectionTypeTLS,,,1,int RedisRegisterConnectionTypeTLS (void)
465615,METHOD,tracking.c:<global>,TYPE_DECL,<global>,1,1,tracking.c,tracking.c:<global>,,false,1,660,<global>,,,1,
465634,METHOD,tracking.c:<global>,TYPE_DECL,"void disableTracking(client *c) {
    /* If this client is in broadcasting mode, we need to unsubscribe it
     * from all the prefixes it is registered to. */
    if (c->flags & CLIENT_TRACKING_BCAST) {
        raxIterator ri;
        raxStart(&ri,c->client_tracking_prefixes);
        raxSeek(&ri,""^"",NULL,0);
        while(raxNext(&ri)) {
            bcastState *bs = raxFind(PrefixTable,ri.key,ri.key_len);
            serverAssert(bs != raxNotFound);
            raxRemove(bs->clients,(unsigned char*)&c,sizeof(c),NULL);
            /* Was it the last client? Remove the prefix from the
             * table. */
            if (raxSize(bs->clients) == 0) {
                raxFree(bs->clients);
                raxFree(bs->keys);
                zfree(bs);
                raxRemove(PrefixTable,ri.key,ri.key_len,NULL);
            }
        }
        raxStop(&ri);
        raxFree(c->client_tracking_prefixes);
        c->client_tracking_prefixes = NULL;
    }

    /* Clear flags and adjust...",1,19,tracking.c,disableTracking,,false,67,100,disableTracking,,,10,void disableTracking (client*)
465806,METHOD,tracking.c:<global>,TYPE_DECL,"static int stringCheckPrefix(unsigned char *s1, size_t s1_len, unsigned char *s2, size_t s2_len) {
    size_t min_length = s1_len < s2_len ? s1_len : s2_len;
    return memcmp(s1,s2,min_length) == 0;   
}",1,1,tracking.c,stringCheckPrefix,,false,102,105,stringCheckPrefix,,,11,"int stringCheckPrefix (unsigned char*,size_t,unsigned char*,size_t)"
465830,METHOD,tracking.c:<global>,TYPE_DECL,"int checkPrefixCollisionsOrReply(client *c, robj **prefixes, size_t numprefix) {
    for (size_t i = 0; i < numprefix; i++) {
        /* Check input list has no overlap with existing prefixes. */
        if (c->client_tracking_prefixes) {
            raxIterator ri;
            raxStart(&ri,c->client_tracking_prefixes);
            raxSeek(&ri,""^"",NULL,0);
            while(raxNext(&ri)) {
                if (stringCheckPrefix(ri.key,ri.key_len,
                    prefixes[i]->ptr,sdslen(prefixes[i]->ptr))) 
                {
                    sds collision = sdsnewlen(ri.key,ri.key_len);
                    addReplyErrorFormat(c,
                        ""Prefix '%s' overlaps with an existing prefix '%s'. ""
                        ""Prefixes for a single client must not overlap."",
                        (unsigned char *)prefixes[i]->ptr,
                        (unsigned char *)collision);
                    sdsfree(collision);
                    raxStop(&ri);
                 ...",1,1,tracking.c,checkPrefixCollisionsOrReply,,false,112,151,checkPrefixCollisionsOrReply,,,12,"int checkPrefixCollisionsOrReply (client*,robj**,size_t)"
465985,METHOD,tracking.c:<global>,TYPE_DECL,"void enableBcastTrackingForPrefix(client *c, char *prefix, size_t plen) {
    bcastState *bs = raxFind(PrefixTable,(unsigned char*)prefix,plen);
    /* If this is the first client subscribing to such prefix, create
     * the prefix in the table. */
    if (bs == raxNotFound) {
        bs = zmalloc(sizeof(*bs));
        bs->keys = raxNew();
        bs->clients = raxNew();
        raxInsert(PrefixTable,(unsigned char*)prefix,plen,bs,NULL);
    }
    if (raxTryInsert(bs->clients,(unsigned char*)&c,sizeof(c),NULL,NULL)) {
        if (c->client_tracking_prefixes == NULL)
            c->client_tracking_prefixes = raxNew();
        raxInsert(c->client_tracking_prefixes,
                  (unsigned char*)prefix,plen,NULL,NULL);
    }
}",1,1,tracking.c,enableBcastTrackingForPrefix,,false,155,171,enableBcastTrackingForPrefix,,,13,"void enableBcastTrackingForPrefix (client*,char*,size_t)"
466066,METHOD,tracking.c:<global>,TYPE_DECL,"void enableTracking(client *c, uint64_t redirect_to, uint64_t options, robj **prefix, size_t numprefix) {
    if (!(c->flags & CLIENT_TRACKING)) server.tracking_clients++;
    c->flags |= CLIENT_TRACKING;
    c->flags &= ~(CLIENT_TRACKING_BROKEN_REDIR|CLIENT_TRACKING_BCAST|
                  CLIENT_TRACKING_OPTIN|CLIENT_TRACKING_OPTOUT|
                  CLIENT_TRACKING_NOLOOP);
    c->client_tracking_redirection = redirect_to;

    /* This may be the first client we ever enable. Create the tracking
     * table if it does not exist. */
    if (TrackingTable == NULL) {
        TrackingTable = raxNew();
        PrefixTable = raxNew();
        TrackingChannelName = createStringObject(""__redis__:invalidate"",20);
    }

    /* For broadcasting, set the list of prefixes in the client. */
    if (options & CLIENT_TRACKING_BCAST) {
        c->flags |= CLIENT_TRACKING_BCAST;
        if (numprefix == 0) enableBcastTrackingForPrefix(c,"""",0);
        for (size_t j = 0; j < numprefix; j++) {
  ...",1,21,tracking.c,enableTracking,,false,180,209,enableTracking,,,14,"void enableTracking (client*,uint64_t,uint64_t,robj**,size_t)"
466230,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingRememberKeys(client *tracking, client *executing) {
    /* Return if we are in optin/out mode and the right CACHING command
     * was/wasn't given in order to modify the default behavior. */
    uint64_t optin = tracking->flags & CLIENT_TRACKING_OPTIN;
    uint64_t optout = tracking->flags & CLIENT_TRACKING_OPTOUT;
    uint64_t caching_given = tracking->flags & CLIENT_TRACKING_CACHING;
    if ((optin && !caching_given) || (optout && caching_given)) return;

    getKeysResult result = GETKEYS_RESULT_INIT;
    int numkeys = getKeysFromCommand(executing->cmd,executing->argv,executing->argc,&result);
    if (!numkeys) {
        getKeysFreeResult(&result);
        return;
    }
    /* Shard channels are treated as special keys for client
     * library to rely on `COMMAND` command to discover the node
     * to connect to. These channels doesn't need to be tracked. */
    if (executing->cmd->flags & CMD_PUBSUB) {
        return;
    }

    keyReference *keys = result.keys;
...",1,39,tracking.c,trackingRememberKeys,,false,217,254,trackingRememberKeys,,,15,"void trackingRememberKeys (client*,client*)"
466433,METHOD,tracking.c:<global>,TYPE_DECL,"void sendTrackingMessage(client *c, char *keyname, size_t keylen, int proto) {
    uint64_t old_flags = c->flags;
    c->flags |= CLIENT_PUSHING;

    int using_redirection = 0;
    if (c->client_tracking_redirection) {
        client *redir = lookupClientByID(c->client_tracking_redirection);
        if (!redir) {
            c->flags |= CLIENT_TRACKING_BROKEN_REDIR;
            /* We need to signal to the original connection that we
             * are unable to send invalidation messages to the redirected
             * connection, because the client no longer exist. */
            if (c->resp > 2) {
                addReplyPushLen(c,2);
                addReplyBulkCBuffer(c,""tracking-redir-broken"",21);
                addReplyLongLong(c,c->client_tracking_redirection);
            }
            if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
            return;
        }
        if (!(old_flags & CLIENT_PUSHING)) c->flags &= ~CLIENT_PUSHING;
        c = redir;
    ...",1,16,tracking.c,sendTrackingMessage,,false,268,324,sendTrackingMessage,,,16,"void sendTrackingMessage (client*,char*,size_t,int)"
466662,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingRememberKeyToBroadcast(client *c, char *keyname, size_t keylen) {
    raxIterator ri;
    raxStart(&ri,PrefixTable);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        if (ri.key_len > keylen) continue;
        if (ri.key_len != 0 && memcmp(ri.key,keyname,ri.key_len) != 0)
            continue;
        bcastState *bs = ri.data;
        /* We insert the client pointer as associated value in the radix
         * tree. This way we know who was the client that did the last
         * change to the key, and can avoid sending the notification in the
         * case the client is in NOLOOP mode. */
        raxInsert(bs->keys,(unsigned char*)keyname,keylen,c,NULL);
    }
    raxStop(&ri);
}",1,1,tracking.c,trackingRememberKeyToBroadcast,,false,332,348,trackingRememberKeyToBroadcast,,,17,"void trackingRememberKeyToBroadcast (client*,char*,size_t)"
466731,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingInvalidateKey(client *c, robj *keyobj, int bcast) {
    if (TrackingTable == NULL) return;

    unsigned char *key = (unsigned char*)keyobj->ptr;
    size_t keylen = sdslen(keyobj->ptr);

    if (bcast && raxSize(PrefixTable) > 0)
        trackingRememberKeyToBroadcast(c,(char *)key,keylen);

    rax *ids = raxFind(TrackingTable,key,keylen);
    if (ids == raxNotFound) return;

    raxIterator ri;
    raxStart(&ri,ids);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        uint64_t id;
        memcpy(&id,ri.key,sizeof(id));
        client *target = lookupClientByID(id);
        /* Note that if the client is in BCAST mode, we don't want to
         * send invalidation messages that were pending in the case
         * previously the client was not in BCAST mode. This can happen if
         * TRACKING is enabled normally, and then the client switches to
         * BCAST mode. */
        if (target == NULL ||
            !(target->flags & CLIENT_TRACKING)||
       ...",1,30,tracking.c,trackingInvalidateKey,,false,366,422,trackingInvalidateKey,,,18,"void trackingInvalidateKey (client*,robj*,int)"
466917,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingHandlePendingKeyInvalidations(void) {
    if (!listLength(server.tracking_pending_keys)) return;

    /* Flush pending invalidation messages only when we are not in nested call.
     * So the messages are not interleaved with transaction response. */
    if (server.execution_nesting) return;

    listNode *ln;
    listIter li;

    listRewind(server.tracking_pending_keys,&li);
    while ((ln = listNext(&li)) != NULL) {
        robj *key = listNodeValue(ln);
        /* current_client maybe freed, so we need to send invalidation
         * message only when current_client is still alive */
        if (server.current_client != NULL) {
            if (key != NULL) {
                sendTrackingMessage(server.current_client,(char *)key->ptr,sdslen(key->ptr),0);
            } else {
                sendTrackingMessage(server.current_client,shared.null[server.current_client->resp]->ptr,
                    sdslen(shared.null[server.current_client->resp]->ptr),1);
            }...",1,9,tracking.c,trackingHandlePendingKeyInvalidations,,false,424,450,trackingHandlePendingKeyInvalidations,,,19,void trackingHandlePendingKeyInvalidations (void)
467035,METHOD,tracking.c:<global>,TYPE_DECL,"void freeTrackingRadixTreeCallback(void *rt) {
    raxFree(rt);
}",1,1,tracking.c,freeTrackingRadixTreeCallback,,false,459,461,freeTrackingRadixTreeCallback,,,20,void freeTrackingRadixTreeCallback (void*)
467042,METHOD,tracking.c:<global>,TYPE_DECL,"void freeTrackingRadixTree(rax *rt) {
    raxFreeWithCallback(rt,freeTrackingRadixTreeCallback);
}",1,1,tracking.c,freeTrackingRadixTree,,false,463,465,freeTrackingRadixTree,,,21,void freeTrackingRadixTree (rax*)
467050,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingInvalidateKeysOnFlush(int async) {
    if (server.tracking_clients) {
        listNode *ln;
        listIter li;
        listRewind(server.clients,&li);
        while ((ln = listNext(&li)) != NULL) {
            client *c = listNodeValue(ln);
            if (c->flags & CLIENT_TRACKING) {
                if (c == server.current_client) {
                    /* We use a special NULL to indicate that we should send null */
                    listAddNodeTail(server.tracking_pending_keys,NULL);
                } else {
                    sendTrackingMessage(c,shared.null[c->resp]->ptr,sdslen(shared.null[c->resp]->ptr),1);
                }
            }
        }
    }

    /* In case of FLUSHALL, reclaim all the memory used by tracking. */
    if (TrackingTable) {
        if (async) {
            freeTrackingRadixTreeAsync(TrackingTable);
        } else {
            freeTrackingRadixTree(TrackingTable);
        }
        TrackingTable = raxNew();
        TrackingTableTot...",1,24,tracking.c,trackingInvalidateKeysOnFlush,,false,468,496,trackingInvalidateKeysOnFlush,,,22,void trackingInvalidateKeysOnFlush (int)
467151,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingLimitUsedSlots(void) {
    static unsigned int timeout_counter = 0;
    if (TrackingTable == NULL) return;
    if (server.tracking_table_max_keys == 0) return; /* No limits set. */
    size_t max_keys = server.tracking_table_max_keys;
    if (raxSize(TrackingTable) <= max_keys) {
        timeout_counter = 0;
        return; /* Limit not reached. */
    }

    /* We have to invalidate a few keys to reach the limit again. The effort
     * we do here is proportional to the number of times we entered this
     * function and found that we are still over the limit. */
    int effort = 100 * (timeout_counter+1);

    /* We just remove one key after another by using a random walk. */
    raxIterator ri;
    raxStart(&ri,TrackingTable);
    while(effort > 0) {
        effort--;
        raxSeek(&ri,""^"",NULL,0);
        raxRandomWalk(&ri,0);
        if (raxEOF(&ri)) break;
        robj *keyobj = createStringObject((char*)ri.key,ri.key_len);
        trackingInvalidateKey(NULL,key...",1,1,tracking.c,trackingLimitUsedSlots,,false,508,545,trackingLimitUsedSlots,,,23,void trackingLimitUsedSlots (void)
467262,METHOD,tracking.c:<global>,TYPE_DECL,"sds trackingBuildBroadcastReply(client *c, rax *keys) {
    raxIterator ri;
    uint64_t count;

    if (c == NULL) {
        count = raxSize(keys);
    } else {
        count = 0;
        raxStart(&ri,keys);
        raxSeek(&ri,""^"",NULL,0);
        while(raxNext(&ri)) {
            if (ri.data != c) count++;
        }
        raxStop(&ri);

        if (count == 0) return NULL;
    }

    /* Create the array reply with the list of keys once, then send
    * it to all the clients subscribed to this prefix. */
    char buf[32];
    size_t len = ll2string(buf,sizeof(buf),count);
    sds proto = sdsempty();
    proto = sdsMakeRoomFor(proto,count*15);
    proto = sdscatlen(proto,""*"",1);
    proto = sdscatlen(proto,buf,len);
    proto = sdscatlen(proto,""\r\n"",2);
    raxStart(&ri,keys);
    raxSeek(&ri,""^"",NULL,0);
    while(raxNext(&ri)) {
        if (c && ri.data == c) continue;
        len = ll2string(buf,sizeof(buf),ri.key_len);
        proto = sdscatlen(proto,""$"",1);
        proto = ...",1,1,tracking.c,trackingBuildBroadcastReply,,false,553,593,trackingBuildBroadcastReply,,,24,"sds trackingBuildBroadcastReply (client*,rax*)"
467429,METHOD,tracking.c:<global>,TYPE_DECL,"void trackingBroadcastInvalidationMessages(void) {
    raxIterator ri, ri2;

    /* Return ASAP if there is nothing to do here. */
    if (TrackingTable == NULL || !server.tracking_clients) return;

    raxStart(&ri,PrefixTable);
    raxSeek(&ri,""^"",NULL,0);

    /* For each prefix... */
    while(raxNext(&ri)) {
        bcastState *bs = ri.data;

        if (raxSize(bs->keys)) {
            /* Generate the common protocol for all the clients that are
             * not using the NOLOOP option. */
            sds proto = trackingBuildBroadcastReply(NULL,bs->keys);

            /* Send this array of keys to every client in the list. */
            raxStart(&ri2,bs->clients);
            raxSeek(&ri2,""^"",NULL,0);
            while(raxNext(&ri2)) {
                client *c;
                memcpy(&c,ri2.key,sizeof(c));
                if (c->flags & CLIENT_TRACKING_NOLOOP) {
                    /* This client may have certain keys excluded. */
                    sds adhoc = trackingB...",1,31,tracking.c,trackingBroadcastInvalidationMessages,,false,598,644,trackingBroadcastInvalidationMessages,,,25,void trackingBroadcastInvalidationMessages (void)
467563,METHOD,tracking.c:<global>,TYPE_DECL,"uint64_t trackingGetTotalItems(void) {
    return TrackingTableTotalItems;
}",1,1,tracking.c,trackingGetTotalItems,,false,648,650,trackingGetTotalItems,,,26,uint64_t trackingGetTotalItems (void)
467570,METHOD,tracking.c:<global>,TYPE_DECL,"uint64_t trackingGetTotalKeys(void) {
    if (TrackingTable == NULL) return 0;
    return raxSize(TrackingTable);
}",1,1,tracking.c,trackingGetTotalKeys,,false,652,655,trackingGetTotalKeys,,,27,uint64_t trackingGetTotalKeys (void)
467585,METHOD,tracking.c:<global>,TYPE_DECL,"uint64_t trackingGetTotalPrefixes(void) {
    if (PrefixTable == NULL) return 0;
    return raxSize(PrefixTable);
}",1,1,tracking.c,trackingGetTotalPrefixes,,false,657,660,trackingGetTotalPrefixes,,,28,uint64_t trackingGetTotalPrefixes (void)
467607,METHOD,unix.c:<global>,TYPE_DECL,<global>,1,1,unix.c,unix.c:<global>,,false,1,207,<global>,,,1,
467610,METHOD,unix.c:<global>,TYPE_DECL,"static const char *connUnixGetType(connection *conn) {
    UNUSED(conn);

    return CONN_TYPE_UNIX;
}",1,4,unix.c,connUnixGetType,,false,32,36,connUnixGetType,,,2,const char* connUnixGetType (connection*)
467625,METHOD,unix.c:<global>,TYPE_DECL,"static void connUnixEventHandler(struct aeEventLoop *el, int fd, void *clientData, int mask) {
    connectionTypeTcp()->ae_handler(el, fd, clientData, mask);
}",1,1,unix.c,connUnixEventHandler,,false,38,40,connUnixEventHandler,,,3,"void connUnixEventHandler (aeEventLoop*,int,void*,int)"
467641,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixAddr(connection *conn, char *ip, size_t ip_len, int *port, int remote) {
    return connectionTypeTcp()->addr(conn, ip, ip_len, port, remote);
}",1,1,unix.c,connUnixAddr,,false,42,44,connUnixAddr,,,4,"int connUnixAddr (connection*,char*,size_t,int*,int)"
467660,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixIsLocal(connection *conn) {
    UNUSED(conn);

    return 1; /* Unix socket is always local connection */
}",1,4,unix.c,connUnixIsLocal,,false,46,50,connUnixIsLocal,,,5,int connUnixIsLocal (connection*)
467673,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixListen(connListener *listener) {
    int fd;
    mode_t *perm = (mode_t *)listener->priv;

    if (listener->bindaddr_count == 0)
        return C_OK;

    /* currently listener->bindaddr_count is always 1, we still use a loop here in case Redis supports multi Unix socket in the future */
    for (int j = 0; j < listener->bindaddr_count; j++) {
        char *addr = listener->bindaddr[j];

        unlink(addr); /* don't care if this fails */
        fd = anetUnixServer(server.neterr, addr, *perm, server.tcp_backlog);
        if (fd == ANET_ERR) {
            serverLog(LL_WARNING, ""Failed opening Unix socket: %s"", server.neterr);
            exit(1);
        }
        anetNonBlock(NULL, fd);
        anetCloexec(fd);
        listener->fd[listener->count++] = fd;
    }

    return C_OK;
}",1,15,unix.c,connUnixListen,,false,52,75,connUnixListen,,,6,int connUnixListen (connListener*)
467784,METHOD,unix.c:<global>,TYPE_DECL,"static connection *connCreateUnix(void) {
    connection *conn = zcalloc(sizeof(connection));
    conn->type = &CT_Unix;
    conn->fd = -1;
    conn->iovcnt = IOV_MAX;

    return conn;
}",1,1,unix.c,connCreateUnix,,false,77,84,connCreateUnix,,,7,connection connCreateUnix (void)
467814,METHOD,unix.c:<global>,TYPE_DECL,"static connection *connCreateAcceptedUnix(int fd, void *priv) {
    UNUSED(priv);
    connection *conn = connCreateUnix();
    conn->fd = fd;
    conn->state = CONN_STATE_ACCEPTING;
    return conn;
}",1,4,unix.c,connCreateAcceptedUnix,,false,86,92,connCreateAcceptedUnix,,,8,"connection connCreateAcceptedUnix (int,void*)"
467842,METHOD,unix.c:<global>,TYPE_DECL,"static void connUnixAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cfd, max = MAX_ACCEPTS_PER_CALL;
    UNUSED(el);
    UNUSED(mask);
    UNUSED(privdata);

    while(max--) {
        cfd = anetUnixAccept(server.neterr, fd);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                serverLog(LL_WARNING,
                    ""Accepting client connection: %s"", server.neterr);
            return;
        }
        serverLog(LL_VERBOSE,""Accepted connection to %s"", server.unixsocket);
        acceptCommonHandler(connCreateAcceptedUnix(cfd, NULL),CLIENT_UNIX_SOCKET,NULL);
    }
}",1,19,unix.c,connUnixAcceptHandler,,false,94,111,connUnixAcceptHandler,,,9,"void connUnixAcceptHandler (aeEventLoop*,int,void*,int)"
467952,METHOD,unix.c:<global>,TYPE_DECL,"static void connUnixShutdown(connection *conn) {
    connectionTypeTcp()->shutdown(conn);
}",1,1,unix.c,connUnixShutdown,,false,113,115,connUnixShutdown,,,10,void connUnixShutdown (connection*)
467962,METHOD,unix.c:<global>,TYPE_DECL,"static void connUnixClose(connection *conn) {
    connectionTypeTcp()->close(conn);
}",1,1,unix.c,connUnixClose,,false,117,119,connUnixClose,,,11,void connUnixClose (connection*)
467972,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixAccept(connection *conn, ConnectionCallbackFunc accept_handler) {
    return connectionTypeTcp()->accept(conn, accept_handler);
}",1,1,unix.c,connUnixAccept,,false,121,123,connUnixAccept,,,12,"int connUnixAccept (connection*,ConnectionCallbackFunc)"
467985,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixWrite(connection *conn, const void *data, size_t data_len) {
    return connectionTypeTcp()->write(conn, data, data_len);
}",1,1,unix.c,connUnixWrite,,false,125,127,connUnixWrite,,,13,"int connUnixWrite (connection*,void*,size_t)"
468000,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixWritev(connection *conn, const struct iovec *iov, int iovcnt) {
    return connectionTypeTcp()->writev(conn, iov, iovcnt);
}",1,1,unix.c,connUnixWritev,,false,129,131,connUnixWritev,,,14,"int connUnixWritev (connection*,iovec*,int)"
468015,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixRead(connection *conn, void *buf, size_t buf_len) {
    return connectionTypeTcp()->read(conn, buf, buf_len);
}",1,1,unix.c,connUnixRead,,false,133,135,connUnixRead,,,15,"int connUnixRead (connection*,void*,size_t)"
468030,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixSetWriteHandler(connection *conn, ConnectionCallbackFunc func, int barrier) {
    return connectionTypeTcp()->set_write_handler(conn, func, barrier);
}",1,1,unix.c,connUnixSetWriteHandler,,false,137,139,connUnixSetWriteHandler,,,16,"int connUnixSetWriteHandler (connection*,ConnectionCallbackFunc,int)"
468045,METHOD,unix.c:<global>,TYPE_DECL,"static int connUnixSetReadHandler(connection *conn, ConnectionCallbackFunc func) {
    return connectionTypeTcp()->set_read_handler(conn, func);
}",1,1,unix.c,connUnixSetReadHandler,,false,141,143,connUnixSetReadHandler,,,17,"int connUnixSetReadHandler (connection*,ConnectionCallbackFunc)"
468058,METHOD,unix.c:<global>,TYPE_DECL,"static const char *connUnixGetLastError(connection *conn) {
    return strerror(conn->last_errno);
}",1,1,unix.c,connUnixGetLastError,,false,145,147,connUnixGetLastError,,,18,const char* connUnixGetLastError (connection*)
468068,METHOD,unix.c:<global>,TYPE_DECL,"static ssize_t connUnixSyncWrite(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncWrite(conn->fd, ptr, size, timeout);
}",1,1,unix.c,connUnixSyncWrite,,false,149,151,connUnixSyncWrite,,,19,"ssize_t connUnixSyncWrite (connection*,char*,ssize_t,long long)"
468084,METHOD,unix.c:<global>,TYPE_DECL,"static ssize_t connUnixSyncRead(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncRead(conn->fd, ptr, size, timeout);
}",1,1,unix.c,connUnixSyncRead,,false,153,155,connUnixSyncRead,,,20,"ssize_t connUnixSyncRead (connection*,char*,ssize_t,long long)"
468100,METHOD,unix.c:<global>,TYPE_DECL,"static ssize_t connUnixSyncReadLine(connection *conn, char *ptr, ssize_t size, long long timeout) {
    return syncReadLine(conn->fd, ptr, size, timeout);
}",1,1,unix.c,connUnixSyncReadLine,,false,157,159,connUnixSyncReadLine,,,21,"ssize_t connUnixSyncReadLine (connection*,char*,ssize_t,long long)"
468228,METHOD,unix.c:<global>,TYPE_DECL,"int RedisRegisterConnectionTypeUnix(void)
{
    return connTypeRegister(&CT_Unix);
}",1,1,unix.c,RedisRegisterConnectionTypeUnix,,false,204,207,RedisRegisterConnectionTypeUnix,,,24,int RedisRegisterConnectionTypeUnix (void)
468288,METHOD,util.c:<global>,TYPE_DECL,<global>,1,1,util.c,util.c:<global>,,false,1,1430,<global>,,,1,
468290,METHOD,util.c:<global>,TYPE_DECL,"static int stringmatchlen_impl(const char *pattern, int patternLen,
        const char *string, int stringLen, int nocase, int *skipLongerMatches)
{
    while(patternLen && stringLen) {
        switch(pattern[0]) {
        case '*':
            while (patternLen && pattern[1] == '*') {
                pattern++;
                patternLen--;
            }
            if (patternLen == 1)
                return 1; /* match */
            while(stringLen) {
                if (stringmatchlen_impl(pattern+1, patternLen-1,
                            string, stringLen, nocase, skipLongerMatches))
                    return 1; /* match */
                if (*skipLongerMatches)
                    return 0; /* no match */
                string++;
                stringLen--;
            }
            /* There was no match for the rest of the pattern starting
             * from anywhere in the rest of the string. If there were
             * any '*' earlier in the pattern, we can termin...",1,1,util.c,stringmatchlen_impl,,false,56,187,stringmatchlen_impl,,,1,"int stringmatchlen_impl (char*,int,char*,int,int,int*)"
468675,METHOD,util.c:<global>,TYPE_DECL,"int stringmatchlen(const char *pattern, int patternLen,
        const char *string, int stringLen, int nocase) {
    int skipLongerMatches = 0;
    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches);
}",1,1,util.c,stringmatchlen,,false,189,193,stringmatchlen,,,2,"int stringmatchlen (char*,int,char*,int,int)"
468697,METHOD,util.c:<global>,TYPE_DECL,"int stringmatch(const char *pattern, const char *string, int nocase) {
    return stringmatchlen(pattern,strlen(pattern),string,strlen(string),nocase);
}",1,1,util.c,stringmatch,,false,195,197,stringmatch,,,3,"int stringmatch (char*,char*,int)"
468713,METHOD,util.c:<global>,TYPE_DECL,"int stringmatchlen_fuzz_test(void) {
    char str[32];
    char pat[32];
    int cycles = 10000000;
    int total_matches = 0;
    while(cycles--) {
        int strlen = rand() % sizeof(str);
        int patlen = rand() % sizeof(pat);
        for (int j = 0; j < strlen; j++) str[j] = rand() % 128;
        for (int j = 0; j < patlen; j++) pat[j] = rand() % 128;
        total_matches += stringmatchlen(pat, patlen, str, strlen, 0);
    }
    return total_matches;
}",1,1,util.c,stringmatchlen_fuzz_test,,false,200,213,stringmatchlen_fuzz_test,,,4,int stringmatchlen_fuzz_test (void)
468792,METHOD,util.c:<global>,TYPE_DECL,"unsigned long long memtoull(const char *p, int *err) {
    const char *u;
    char buf[128];
    long mul; /* unit multiplier */
    unsigned long long val;
    unsigned int digits;

    if (err) *err = 0;

    /* Search the first non digit character. */
    u = p;
    if (*u == '-') {
        if (err) *err = 1;
        return 0;
    }
    while(*u && isdigit(*u)) u++;
    if (*u == '\0' || !strcasecmp(u,""b"")) {
        mul = 1;
    } else if (!strcasecmp(u,""k"")) {
        mul = 1000;
    } else if (!strcasecmp(u,""kb"")) {
        mul = 1024;
    } else if (!strcasecmp(u,""m"")) {
        mul = 1000*1000;
    } else if (!strcasecmp(u,""mb"")) {
        mul = 1024*1024;
    } else if (!strcasecmp(u,""g"")) {
        mul = 1000L*1000*1000;
    } else if (!strcasecmp(u,""gb"")) {
        mul = 1024L*1024*1024;
    } else {
        if (err) *err = 1;
        return 0;
    }

    /* Copy the digits into a buffer, we'll use strtoll() to convert
     * the digit (without the unit) into a number. */...",1,1,util.c,memtoull,,false,223,276,memtoull,,,5,"unsigned long long memtoull (char*,int*)"
469007,METHOD,util.c:<global>,TYPE_DECL,"const char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen) {
    for (size_t j = 0; j < len; j++) {
        for (size_t n = 0; n < charslen; n++)
            if (s[j] == chars[n]) return &s[j];
    }

    return NULL;
}",1,1,util.c,mempbrk,,false,281,288,mempbrk,,,6,"const char* mempbrk (char*,size_t,char*,size_t)"
469054,METHOD,util.c:<global>,TYPE_DECL,"char *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen) {
    for (size_t j = 0; j < len; j++) {
        for (size_t i = 0; i < setlen; i++) {
            if (s[j] == from[i]) {
                s[j] = to[i];
                break;
            }
        }
    }
    return s;
}",1,1,util.c,memmapchars,,false,293,303,memmapchars,,,7,"char* memmapchars (char*,size_t,char*,char*,size_t)"
469106,METHOD,util.c:<global>,TYPE_DECL,"uint32_t digits10(uint64_t v) {
    if (v < 10) return 1;
    if (v < 100) return 2;
    if (v < 1000) return 3;
    if (v < 1000000000000UL) {
        if (v < 100000000UL) {
            if (v < 1000000) {
                if (v < 10000) return 4;
                return 5 + (v >= 100000);
            }
            return 7 + (v >= 10000000UL);
        }
        if (v < 10000000000UL) {
            return 9 + (v >= 1000000000UL);
        }
        return 11 + (v >= 100000000000UL);
    }
    return 12 + digits10(v / 1000000000000UL);
}",1,1,util.c,digits10,,false,307,325,digits10,,,8,uint32_t digits10 (uint64_t)
469190,METHOD,util.c:<global>,TYPE_DECL,"uint32_t sdigits10(int64_t v) {
    if (v < 0) {
        /* Abs value of LLONG_MIN requires special handling. */
        uint64_t uv = (v != LLONG_MIN) ?
                      (uint64_t)-v : ((uint64_t) LLONG_MAX)+1;
        return digits10(uv)+1; /* +1 for the minus. */
    } else {
        return digits10(v);
    }
}",1,1,util.c,sdigits10,,false,328,337,sdigits10,,,9,uint32_t sdigits10 (int64_t)
469225,METHOD,util.c:<global>,TYPE_DECL,"int ll2string(char *dst, size_t dstlen, long long svalue) {
    unsigned long long value;
    int negative = 0;

    /* The ull2string function with 64bit unsigned integers for simplicity, so
     * we convert the number here and remember if it is negative. */
    if (svalue < 0) {
        if (svalue != LLONG_MIN) {
            value = -svalue;
        } else {
            value = ((unsigned long long) LLONG_MAX)+1;
        }
        if (dstlen < 2)
            goto err;
        negative = 1;
        dst[0] = '-';
        dst++;
        dstlen--;
    } else {
        value = svalue;
    }

    /* Converts the unsigned long long value to string*/
    int length = ull2string(dst, dstlen, value);
    if (length == 0) return 0;
    return length + negative;

err:
    /* force add Null termination */
    if (dstlen > 0)
        dst[0] = '\0';
    return 0;
}",1,1,util.c,ll2string,,false,342,374,ll2string,,,10,"int ll2string (char*,size_t,long long)"
469314,METHOD,util.c:<global>,TYPE_DECL,"int ull2string(char *dst, size_t dstlen, unsigned long long value) {
    static const char digits[201] =
        ""0001020304050607080910111213141516171819""
        ""2021222324252627282930313233343536373839""
        ""4041424344454647484950515253545556575859""
        ""6061626364656667686970717273747576777879""
        ""8081828384858687888990919293949596979899"";

    /* Check length. */
    uint32_t length = digits10(value);
    if (length >= dstlen) goto err;;

    /* Null term. */
    uint32_t next = length - 1;
    dst[next + 1] = '\0';
    while (value >= 100) {
        int const i = (value % 100) * 2;
        value /= 100;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
        next -= 2;
    }

    /* Handle last 1-2 digits. */
    if (value < 10) {
        dst[next] = '0' + (uint32_t) value;
    } else {
        int i = (uint32_t) value * 2;
        dst[next] = digits[i + 1];
        dst[next - 1] = digits[i];
    }
    return length;
err:
    /* force add N...",1,1,util.c,ull2string,,false,384,421,ull2string,,,11,"int ull2string (char*,size_t,long long unsigned)"
469443,METHOD,util.c:<global>,TYPE_DECL,"int string2ll(const char *s, size_t slen, long long *value) {
    const char *p = s;
    size_t plen = 0;
    int negative = 0;
    unsigned long long v;

    /* A string of zero length or excessive length is not a valid number. */
    if (plen == slen || slen >= LONG_STR_SIZE)
        return 0;

    /* Special case: first and only digit is 0. */
    if (slen == 1 && p[0] == '0') {
        if (value != NULL) *value = 0;
        return 1;
    }

    /* Handle negative numbers: just set a flag and continue like if it
     * was a positive number. Later convert into negative. */
    if (p[0] == '-') {
        negative = 1;
        p++; plen++;

        /* Abort on only a negative sign. */
        if (plen == slen)
            return 0;
    }

    /* First digit should be 1-9, otherwise the string should just be 0. */
    if (p[0] >= '1' && p[0] <= '9') {
        v = p[0]-'0';
        p++; plen++;
    } else {
        return 0;
    }

    /* Parse all the other digits, checking for over...",1,32,util.c,string2ll,,false,435,499,string2ll,,,12,"int string2ll (char*,size_t,long long*)"
469654,METHOD,util.c:<global>,TYPE_DECL,"int string2ull(const char *s, unsigned long long *value) {
    long long ll;
    if (string2ll(s,strlen(s),&ll)) {
        if (ll < 0) return 0; /* Negative values are out of range. */
        *value = ll;
        return 1;
    }
    errno = 0;
    char *endptr = NULL;
    *value = strtoull(s,&endptr,10);
    if (errno == EINVAL || errno == ERANGE || !(*s != '\0' && *endptr == '\0'))
        return 0; /* strtoull() failed. */
    return 1; /* Conversion done! */
}",1,1,util.c,string2ull,,false,506,519,string2ull,,,13,"int string2ull (char*,long long unsigned*)"
469721,METHOD,util.c:<global>,TYPE_DECL,"int string2l(const char *s, size_t slen, long *lval) {
    long long llval;

    if (!string2ll(s,slen,&llval))
        return 0;

    if (llval < LONG_MIN || llval > LONG_MAX)
        return 0;

    *lval = (long)llval;
    return 1;
}",1,1,util.c,string2l,,false,524,535,string2l,,,14,"int string2l (char*,size_t,long*)"
469758,METHOD,util.c:<global>,TYPE_DECL,"int string2ld(const char *s, size_t slen, long double *dp) {
    char buf[MAX_LONG_DOUBLE_CHARS];
    long double value;
    char *eptr;

    if (slen == 0 || slen >= sizeof(buf)) return 0;
    memcpy(buf,s,slen);
    buf[slen] = '\0';

    errno = 0;
    value = strtold(buf, &eptr);
    if (isspace(buf[0]) || eptr[0] != '\0' ||
        (size_t)(eptr-buf) != slen ||
        (errno == ERANGE &&
            (value == HUGE_VAL || value == -HUGE_VAL || fpclassify(value) == FP_ZERO)) ||
        errno == EINVAL ||
        isnan(value))
        return 0;

    if (dp) *dp = value;
    return 1;
}",1,13,util.c,string2ld,,false,544,565,string2ld,,,15,"int string2ld (char*,size_t,long double*)"
469853,METHOD,util.c:<global>,TYPE_DECL,"int string2d(const char *s, size_t slen, double *dp) {
    errno = 0;
    char *eptr;
    *dp = strtod(s, &eptr);
    if (slen == 0 ||
        isspace(((const char*)s)[0]) ||
        (size_t)(eptr-(char*)s) != slen ||
        (errno == ERANGE &&
            (*dp == HUGE_VAL || *dp == -HUGE_VAL || fpclassify(*dp) == FP_ZERO)) ||
        isnan(*dp))
        return 0;
    return 1;
}",1,1,util.c,string2d,,false,574,586,string2d,,,16,"int string2d (char*,size_t,double*)"
469921,METHOD,util.c:<global>,TYPE_DECL,"int double2ll(double d, long long *out) {
#if (DBL_MANT_DIG >= 52) && (DBL_MANT_DIG <= 63) && (LLONG_MAX == 0x7fffffffffffffffLL)
    /* Check if the float is in a safe range to be casted into a
     * long long. We are assuming that long long is 64 bit here.
     * Also we are assuming that there are no implementations around where
     * double has precision < 52 bit.
     *
     * Under this assumptions we test if a double is inside a range
     * where casting to long long is safe. Then using two castings we
     * make sure the decimal part is zero. If all this is true we can use
     * integer without precision loss.
     *
     * Note that numbers above 2^52 and below 2^63 use all the fraction bits as real part,
     * and the exponent bits are positive, which means the ""decimal"" part must be 0.
     * i.e. all double values in that range are representable as a long without precision loss,
     * but not all long values in that range can be represented as a double.
     * we ...",1,1,util.c,double2ll,,false,590,616,double2ll,,,17,"int double2ll (double,long long*)"
469929,METHOD,util.c:<global>,TYPE_DECL,"int d2string(char *buf, size_t len, double value) {
    if (isnan(value)) {
        /* Libc in some systems will format nan in a different way,
         * like nan, -nan, NAN, nan(char-sequence).
         * So we normalize it and create a single nan form in an explicit way. */
        len = snprintf(buf,len,""nan"");
    } else if (isinf(value)) {
        /* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */
        if (value < 0)
            len = snprintf(buf,len,""-inf"");
        else
            len = snprintf(buf,len,""inf"");
    } else if (value == 0) {
        /* See: http://en.wikipedia.org/wiki/Signed_zero, ""Comparisons"". */
        if (1.0/value < 0)
            len = snprintf(buf,len,""-0"");
        else
            len = snprintf(buf,len,""0"");
    } else {
        long long lvalue;
        /* Integer printing function is much faster, check if we can safely use it. */
        if (double2ll(value, ...",1,1,util.c,d2string,,false,623,654,d2string,,,18,"int d2string (char*,size_t,double)"
470028,METHOD,util.c:<global>,TYPE_DECL,"int fixedpoint_d2string(char *dst, size_t dstlen, double dvalue, int fractional_digits) {
    if (fractional_digits < 1 || fractional_digits > 17)
        goto err;
    /* min size of 2 ( due to 0. ) + n fractional_digitits + \0 */
    if ((int)dstlen < (fractional_digits+3))
        goto err;
    if (dvalue == 0) {
        dst[0] = '0';
        dst[1] = '.';
        memset(dst + 2, '0', fractional_digits);
        dst[fractional_digits+2] = '\0';
        return fractional_digits + 2;
    }
    /* scale and round */
    static double powers_of_ten[] = {1.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0,
    10000000.0, 100000000.0, 1000000000.0, 10000000000.0, 100000000000.0, 1000000000000.0,
    10000000000000.0, 100000000000000.0, 1000000000000000.0, 10000000000000000.0,
    100000000000000000.0 };
    long long svalue = llrint(dvalue * powers_of_ten[fractional_digits]);
    unsigned long long value;
    /* write sign */
    int negative = 0;
    if (svalue < 0) {
        if (...",1,1,util.c,fixedpoint_d2string,,false,676,765,fixedpoint_d2string,,,19,"int fixedpoint_d2string (char*,size_t,double,int)"
470339,METHOD,util.c:<global>,TYPE_DECL,"int trimDoubleString(char *buf, size_t len) {
    if (strchr(buf,'.') != NULL) {
        char *p = buf+len-1;
        while(*p == '0') {
            p--;
            len--;
        }
        if (*p == '.') len--;
    }
    buf[len] = '\0';
    return len;
}",1,1,util.c,trimDoubleString,,false,768,779,trimDoubleString,,,20,"int trimDoubleString (char*,size_t)"
470385,METHOD,util.c:<global>,TYPE_DECL,"int ld2string(char *buf, size_t len, long double value, ld2string_mode mode) {
    size_t l = 0;

    if (isinf(value)) {
        /* Libc in odd systems (Hi Solaris!) will format infinite in a
         * different way, so better to handle it in an explicit way. */
        if (len < 5) goto err; /* No room. 5 is ""-inf\0"" */
        if (value > 0) {
            memcpy(buf,""inf"",3);
            l = 3;
        } else {
            memcpy(buf,""-inf"",4);
            l = 4;
        }
    } else if (isnan(value)) {
        /* Libc in some systems will format nan in a different way,
         * like nan, -nan, NAN, nan(char-sequence).
         * So we normalize it and create a single nan form in an explicit way. */
        if (len < 4) goto err; /* No room. 4 is ""nan\0"" */
        memcpy(buf, ""nan"", 3);
        l = 3;
    } else {
        switch (mode) {
        case LD_STR_AUTO:
            l = snprintf(buf,len,""%.17Lg"",value);
            if (l+1 > len) goto err;; /* No room. */
           ...",1,1,util.c,ld2string,,false,790,853,ld2string,,,21,"int ld2string (char*,size_t,long double,ld2string_mode)"
470586,METHOD,util.c:<global>,TYPE_DECL,"void getRandomBytes(unsigned char *p, size_t len) {
    /* Global state. */
    static int seed_initialized = 0;
    static unsigned char seed[64]; /* 512 bit internal block size. */
    static uint64_t counter = 0; /* The counter we hash with the seed. */

    if (!seed_initialized) {
        /* Initialize a seed and use SHA1 in counter mode, where we hash
         * the same seed with a progressive counter. For the goals of this
         * function we just need non-colliding strings, there are no
         * cryptographic security needs. */
        FILE *fp = fopen(""/dev/urandom"",""r"");
        if (fp == NULL || fread(seed,sizeof(seed),1,fp) != 1) {
            /* Revert to a weaker seed, and in this case reseed again
             * at every call.*/
            for (unsigned int j = 0; j < sizeof(seed); j++) {
                struct timeval tv;
                gettimeofday(&tv,NULL);
                pid_t pid = getpid();
                seed[j] = tv.tv_sec ^ tv.tv_usec ^ pid ^ (long...",1,29,util.c,getRandomBytes,,false,860,922,getRandomBytes,,,22,"void getRandomBytes (unsigned char*,size_t)"
470791,METHOD,util.c:<global>,TYPE_DECL,"void getRandomHexChars(char *p, size_t len) {
    char *charset = ""0123456789abcdef"";
    size_t j;

    getRandomBytes((unsigned char*)p,len);
    for (j = 0; j < len; j++) p[j] = charset[p[j] & 0x0F];
}",1,1,util.c,getRandomHexChars,,false,928,934,getRandomHexChars,,,23,"void getRandomHexChars (char*,size_t)"
470828,METHOD,util.c:<global>,TYPE_DECL,"sds getAbsolutePath(char *filename) {
    char cwd[1024];
    sds abspath;
    sds relpath = sdsnew(filename);

    relpath = sdstrim(relpath,"" \r\n\t"");
    if (relpath[0] == '/') return relpath; /* Path is already absolute. */

    /* If path is relative, join cwd and relative path. */
    if (getcwd(cwd,sizeof(cwd)) == NULL) {
        sdsfree(relpath);
        return NULL;
    }
    abspath = sdsnew(cwd);
    if (sdslen(abspath) && abspath[sdslen(abspath)-1] != '/')
        abspath = sdscat(abspath,""/"");

    /* At this point we have the current path always ending with ""/"", and
     * the trimmed relative path. Try to normalize the obvious case of
     * trailing ../ elements at the start of the path.
     *
     * For every ""../"" we find in the filename, we remove it and also remove
     * the last element of the cwd, unless the current cwd is ""/"". */
    while (sdslen(relpath) >= 3 &&
           relpath[0] == '.' && relpath[1] == '.' && relpath[2] == '/')
    {
        sdsrange...",1,1,util.c,getAbsolutePath,,false,943,986,getAbsolutePath,,,24,sds getAbsolutePath (char*)
470962,METHOD,util.c:<global>,TYPE_DECL,"long getTimeZone(void) {
#if defined(__linux__) || defined(__sun)
    return timezone;
#else
    struct timeval tv;
    struct timezone tz;

    gettimeofday(&tv, &tz);

    return tz.tz_minuteswest * 60L;
#endif
}",1,1,util.c,getTimeZone,,false,992,1003,getTimeZone,,,25,long getTimeZone (void)
470980,METHOD,util.c:<global>,TYPE_DECL,"int pathIsBaseName(char *path) {
    return strchr(path,'/') == NULL && strchr(path,'\\') == NULL;
}",1,1,util.c,pathIsBaseName,,false,1009,1011,pathIsBaseName,,,26,int pathIsBaseName (char*)
470997,METHOD,util.c:<global>,TYPE_DECL,"int fileExist(char *filename) {
    struct stat statbuf;
    return stat(filename, &statbuf) == 0 && S_ISREG(statbuf.st_mode);
}",1,1,util.c,fileExist,,false,1013,1016,fileExist,,,27,int fileExist (char*)
471015,METHOD,util.c:<global>,TYPE_DECL,"int dirExists(char *dname) {
    struct stat statbuf;
    return stat(dname, &statbuf) == 0 && S_ISDIR(statbuf.st_mode);
}",1,1,util.c,dirExists,,false,1018,1021,dirExists,,,28,int dirExists (char*)
471033,METHOD,util.c:<global>,TYPE_DECL,"int dirCreateIfMissing(char *dname) {
    if (mkdir(dname, 0755) != 0) {
        if (errno != EEXIST) {
            return -1;
        } else if (!dirExists(dname)) {
            errno = ENOTDIR;
            return -1;
        }
    }
    return 0;
}",1,1,util.c,dirCreateIfMissing,,false,1023,1033,dirCreateIfMissing,,,29,int dirCreateIfMissing (char*)
471068,METHOD,util.c:<global>,TYPE_DECL,"int dirRemove(char *dname) {
    DIR *dir;
    struct stat stat_entry;
    struct dirent *entry;
    char full_path[PATH_MAX + 1];

    if ((dir = opendir(dname)) == NULL) {
        return -1;
    }

    while ((entry = readdir(dir)) != NULL) {
        if (!strcmp(entry->d_name, ""."") || !strcmp(entry->d_name, "".."")) continue;

        snprintf(full_path, sizeof(full_path), ""%s/%s"", dname, entry->d_name);

        int fd = open(full_path, O_RDONLY|O_NONBLOCK);
        if (fd == -1) {
            closedir(dir);
            return -1;
        }

        if (fstat(fd, &stat_entry) == -1) {
            close(fd);
            closedir(dir);
            return -1;
        }
        close(fd);

        if (S_ISDIR(stat_entry.st_mode) != 0) {
            if (dirRemove(full_path) == -1) {
                return -1;
            }
            continue;
        }

        if (unlink(full_path) != 0) {
            closedir(dir);
            return -1;
        }
    }

    if (rmdir(dname) != 0) {...",1,1,util.c,dirRemove,,false,1035,1083,dirRemove,,,30,int dirRemove (char*)
471203,METHOD,util.c:<global>,TYPE_DECL,"sds makePath(char *path, char *filename) {
    return sdscatfmt(sdsempty(), ""%s/%s"", path, filename);
}",1,1,util.c,makePath,,false,1085,1087,makePath,,,31,"sds makePath (char*,char*)"
471215,METHOD,util.c:<global>,TYPE_DECL,"int fsyncFileDir(const char *filename) {
#ifdef _AIX
    /* AIX is unable to fsync a directory */
    return 0;
#endif
    char temp_filename[PATH_MAX + 1];
    char *dname;
    int dir_fd;

    if (strlen(filename) > PATH_MAX) {
        errno = ENAMETOOLONG;
        return -1;
    }

    /* In the glibc implementation dirname may modify their argument. */
    memcpy(temp_filename, filename, strlen(filename) + 1);
    dname = dirname(temp_filename);

    dir_fd = open(dname, O_RDONLY);
    if (dir_fd == -1) {
        /* Some OSs don't allow us to open directories at all, just
         * ignore the error in that case */
        if (errno == EISDIR) {
            return 0;
        }
        return -1;
    }
    /* Some OSs don't allow us to fsync directories at all, so we can ignore
     * those errors. */
    if (redis_fsync(dir_fd) == -1 && !(errno == EBADF || errno == EINVAL)) {
        int save_errno = errno;
        close(dir_fd);
        errno = save_errno;
        return -1;
  ...",1,8,util.c,fsyncFileDir,,false,1097,1135,fsyncFileDir,,,32,int fsyncFileDir (char*)
471302,METHOD,util.c:<global>,TYPE_DECL,"int reclaimFilePageCache(int fd, size_t offset, size_t length) {
#ifdef HAVE_FADVISE
    int ret = posix_fadvise(fd, offset, length, POSIX_FADV_DONTNEED);
    if (ret) return -1;
    return 0;
#else
    UNUSED(fd);
    UNUSED(offset);
    UNUSED(length);
    return 0;
#endif
}",1,4,util.c,reclaimFilePageCache,,false,1138,1149,reclaimFilePageCache,,,33,"int reclaimFilePageCache (int,size_t,size_t)"
471336,METHOD,util.h:<global>,TYPE_DECL,<global>,1,20,util.h,util.h:<global>,,false,1,99,<global>,,,1,
471343,METHOD,util.h:<global>,TYPE_DECL,"int stringmatchlen(const char *p, int plen, const char *s, int slen, int nocase);",5,80,util.h,stringmatchlen,,false,60,60,stringmatchlen,,,3,"int stringmatchlen (char*,int,char*,int,int)"
471352,METHOD,util.h:<global>,TYPE_DECL,"int stringmatch(const char *p, const char *s, int nocase);",5,57,util.h,stringmatch,,false,61,61,stringmatch,,,4,"int stringmatch (char*,char*,int)"
471359,METHOD,util.h:<global>,TYPE_DECL,int stringmatchlen_fuzz_test(void);,5,34,util.h,stringmatchlen_fuzz_test,,false,62,62,stringmatchlen_fuzz_test,,,5,int stringmatchlen_fuzz_test (void)
471364,METHOD,util.h:<global>,TYPE_DECL,"unsigned long long memtoull(const char *p, int *err);",20,52,util.h,memtoull,,false,63,63,memtoull,,,6,"long long unsigned memtoull (char*,int*)"
471370,METHOD,util.h:<global>,TYPE_DECL,"const char *mempbrk(const char *s, size_t len, const char *chars, size_t charslen);",12,82,util.h,mempbrk,,false,64,64,mempbrk,,,7,"char* mempbrk (char*,size_t,char*,size_t)"
471378,METHOD,util.h:<global>,TYPE_DECL,"char *memmapchars(char *s, size_t len, const char *from, const char *to, size_t setlen);",6,87,util.h,memmapchars,,false,65,65,memmapchars,,,8,"char* memmapchars (char*,size_t,char*,char*,size_t)"
471387,METHOD,util.h:<global>,TYPE_DECL,uint32_t digits10(uint64_t v);,10,29,util.h,digits10,,false,66,66,digits10,,,9,uint32_t digits10 (uint64_t)
471392,METHOD,util.h:<global>,TYPE_DECL,uint32_t sdigits10(int64_t v);,10,29,util.h,sdigits10,,false,67,67,sdigits10,,,10,uint32_t sdigits10 (int64_t)
471397,METHOD,util.h:<global>,TYPE_DECL,"int ll2string(char *s, size_t len, long long value);",5,51,util.h,ll2string,,false,68,68,ll2string,,,11,"int ll2string (char*,size_t,long long)"
471404,METHOD,util.h:<global>,TYPE_DECL,"int ull2string(char *s, size_t len, unsigned long long value);",5,61,util.h,ull2string,,false,69,69,ull2string,,,12,"int ull2string (char*,size_t,long long unsigned)"
471411,METHOD,util.h:<global>,TYPE_DECL,"int string2ll(const char *s, size_t slen, long long *value);",5,59,util.h,string2ll,,false,70,70,string2ll,,,13,"int string2ll (char*,size_t,long long*)"
471418,METHOD,util.h:<global>,TYPE_DECL,"int string2ull(const char *s, unsigned long long *value);",5,56,util.h,string2ull,,false,71,71,string2ull,,,14,"int string2ull (char*,long long unsigned*)"
471424,METHOD,util.h:<global>,TYPE_DECL,"int string2l(const char *s, size_t slen, long *value);",5,53,util.h,string2l,,false,72,72,string2l,,,15,"int string2l (char*,size_t,long*)"
471431,METHOD,util.h:<global>,TYPE_DECL,"int string2ld(const char *s, size_t slen, long double *dp);",5,58,util.h,string2ld,,false,73,73,string2ld,,,16,"int string2ld (char*,size_t,long double*)"
471438,METHOD,util.h:<global>,TYPE_DECL,"int string2d(const char *s, size_t slen, double *dp);",5,52,util.h,string2d,,false,74,74,string2d,,,17,"int string2d (char*,size_t,double*)"
471445,METHOD,util.h:<global>,TYPE_DECL,"int trimDoubleString(char *buf, size_t len);",5,43,util.h,trimDoubleString,,false,75,75,trimDoubleString,,,18,"int trimDoubleString (char*,size_t)"
471451,METHOD,util.h:<global>,TYPE_DECL,"int d2string(char *buf, size_t len, double value);",5,49,util.h,d2string,,false,76,76,d2string,,,19,"int d2string (char*,size_t,double)"
471458,METHOD,util.h:<global>,TYPE_DECL,"int fixedpoint_d2string(char *dst, size_t dstlen, double dvalue, int fractional_digits);",5,87,util.h,fixedpoint_d2string,,false,77,77,fixedpoint_d2string,,,20,"int fixedpoint_d2string (char*,size_t,double,int)"
471466,METHOD,util.h:<global>,TYPE_DECL,"int ld2string(char *buf, size_t len, long double value, ld2string_mode mode);",5,76,util.h,ld2string,,false,78,78,ld2string,,,21,"int ld2string (char*,size_t,long double,ld2string_mode)"
471474,METHOD,util.h:<global>,TYPE_DECL,"int double2ll(double d, long long *out);",5,39,util.h,double2ll,,false,79,79,double2ll,,,22,"int double2ll (double,long long*)"
471480,METHOD,util.h:<global>,TYPE_DECL,int yesnotoi(char *s);,5,21,util.h,yesnotoi,,false,80,80,yesnotoi,,,23,int yesnotoi (char*)
471485,METHOD,util.h:<global>,TYPE_DECL,sds getAbsolutePath(char *filename);,5,35,util.h,getAbsolutePath,,false,81,81,getAbsolutePath,,,24,sds getAbsolutePath (char*)
471490,METHOD,util.h:<global>,TYPE_DECL,long getTimeZone(void);,6,22,util.h,getTimeZone,,false,82,82,getTimeZone,,,25,long getTimeZone (void)
471495,METHOD,util.h:<global>,TYPE_DECL,int pathIsBaseName(char *path);,5,30,util.h,pathIsBaseName,,false,83,83,pathIsBaseName,,,26,int pathIsBaseName (char*)
471500,METHOD,util.h:<global>,TYPE_DECL,int dirCreateIfMissing(char *dname);,5,35,util.h,dirCreateIfMissing,,false,84,84,dirCreateIfMissing,,,27,int dirCreateIfMissing (char*)
471505,METHOD,util.h:<global>,TYPE_DECL,int dirExists(char *dname);,5,26,util.h,dirExists,,false,85,85,dirExists,,,28,int dirExists (char*)
471510,METHOD,util.h:<global>,TYPE_DECL,int dirRemove(char *dname);,5,26,util.h,dirRemove,,false,86,86,dirRemove,,,29,int dirRemove (char*)
471515,METHOD,util.h:<global>,TYPE_DECL,int fileExist(char *filename);,5,29,util.h,fileExist,,false,87,87,fileExist,,,30,int fileExist (char*)
471520,METHOD,util.h:<global>,TYPE_DECL,"sds makePath(char *path, char *filename);",5,40,util.h,makePath,,false,88,88,makePath,,,31,"sds makePath (char*,char*)"
471526,METHOD,util.h:<global>,TYPE_DECL,int fsyncFileDir(const char *filename);,5,38,util.h,fsyncFileDir,,false,89,89,fsyncFileDir,,,32,int fsyncFileDir (char*)
471531,METHOD,util.h:<global>,TYPE_DECL,"int reclaimFilePageCache(int fd, size_t offset, size_t length);",5,62,util.h,reclaimFilePageCache,,false,90,90,reclaimFilePageCache,,,33,"int reclaimFilePageCache (int,size_t,size_t)"
471538,METHOD,util.h:<global>,TYPE_DECL,"size_t redis_strlcpy(char *dst, const char *src, size_t dsize);",8,62,util.h,redis_strlcpy,,false,92,92,redis_strlcpy,,,34,"size_t redis_strlcpy (char*,char*,size_t)"
471545,METHOD,util.h:<global>,TYPE_DECL,"size_t redis_strlcat(char *dst, const char *src, size_t dsize);",8,62,util.h,redis_strlcat,,false,93,93,redis_strlcat,,,35,"size_t redis_strlcat (char*,char*,size_t)"
471555,METHOD,version.h:<global>,TYPE_DECL,<global>,1,36,version.h,version.h:<global>,,false,1,2,<global>,,,1,
471590,METHOD,ziplist.c:<global>,TYPE_DECL,<global>,1,20,ziplist.c,ziplist.c:<global>,,false,1,2666,<global>,,,1,
471592,METHOD,ziplist.c:<global>,TYPE_DECL,"int ziplistSafeToAdd(unsigned char* zl, size_t add) {
    size_t len = zl? ziplistBlobLen(zl): 0;
    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)
        return 0;
    return 1;
}",1,20,ziplist.c,ziplistSafeToAdd,,false,273,278,ziplistSafeToAdd,,,1,"int ziplistSafeToAdd (unsigned char*,size_t)"
471630,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline unsigned int zipEncodingLenSize(unsigned char encoding) {
    if (encoding == ZIP_INT_16B || encoding == ZIP_INT_32B ||
        encoding == ZIP_INT_24B || encoding == ZIP_INT_64B ||
        encoding == ZIP_INT_8B)
        return 1;
    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
        return 1;
    if (encoding == ZIP_STR_06B)
        return 1;
    if (encoding == ZIP_STR_14B)
        return 2;
    if (encoding == ZIP_STR_32B)
        return 5;
    return ZIP_ENCODING_SIZE_INVALID;
}",1,20,ziplist.c,zipEncodingLenSize,,false,321,335,zipEncodingLenSize,,,4,unsigned int zipEncodingLenSize (unsigned char)
471736,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline unsigned int zipIntSize(unsigned char encoding) {
    switch(encoding) {
    case ZIP_INT_8B:  return 1;
    case ZIP_INT_16B: return 2;
    case ZIP_INT_24B: return 3;
    case ZIP_INT_32B: return 4;
    case ZIP_INT_64B: return 8;
    }
    if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX)
        return 0; /* 4 bit immediate */
    /* bad encoding, covered by a previous call to ZIP_ASSERT_ENCODING */
    redis_unreachable();
    return 0;
}",1,9,ziplist.c,zipIntSize,,false,342,355,zipIntSize,,,5,unsigned int zipIntSize (unsigned char)
471810,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned int zipStoreEntryEncoding(unsigned char *p, unsigned char encoding, unsigned int rawlen) {
    unsigned char len = 1, buf[5];

    if (ZIP_IS_STR(encoding)) {
        /* Although encoding is given it may not be set for strings,
         * so we determine it here using the raw length. */
        if (rawlen <= 0x3f) {
            if (!p) return len;
            buf[0] = ZIP_STR_06B | rawlen;
        } else if (rawlen <= 0x3fff) {
            len += 1;
            if (!p) return len;
            buf[0] = ZIP_STR_14B | ((rawlen >> 8) & 0x3f);
            buf[1] = rawlen & 0xff;
        } else {
            len += 4;
            if (!p) return len;
            buf[0] = ZIP_STR_32B;
            buf[1] = (rawlen >> 24) & 0xff;
            buf[2] = (rawlen >> 16) & 0xff;
            buf[3] = (rawlen >> 8) & 0xff;
            buf[4] = rawlen & 0xff;
        }
    } else {
        /* Implies integer encoding, so length is always 1. */
        if (!p) return len;
        buf[0] = enco...",1,8,ziplist.c,zipStoreEntryEncoding,,false,369,401,zipStoreEntryEncoding,,,6,"unsigned int zipStoreEntryEncoding (unsigned char*,unsigned char,unsigned int)"
471965,METHOD,ziplist.c:<global>,TYPE_DECL,"int zipStorePrevEntryLengthLarge(unsigned char *p, unsigned int len) {
    uint32_t u32;
    if (p != NULL) {
        p[0] = ZIP_BIG_PREVLEN;
        u32 = len;
        memcpy(p+1,&u32,sizeof(u32));
        memrev32ifbe(p+1);
    }
    return 1 + sizeof(uint32_t);
}",1,15,ziplist.c,zipStorePrevEntryLengthLarge,,false,444,453,zipStorePrevEntryLengthLarge,,,7,"int zipStorePrevEntryLengthLarge (unsigned char*,unsigned int)"
472006,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned int zipStorePrevEntryLength(unsigned char *p, unsigned int len) {
    if (p == NULL) {
        return (len < ZIP_BIG_PREVLEN) ? 1 : sizeof(uint32_t) + 1;
    } else {
        if (len < ZIP_BIG_PREVLEN) {
            p[0] = len;
            return 1;
        } else {
            return zipStorePrevEntryLengthLarge(p,len);
        }
    }
}",1,22,ziplist.c,zipStorePrevEntryLength,,false,457,468,zipStorePrevEntryLength,,,8,"unsigned int zipStorePrevEntryLength (unsigned char*,unsigned int)"
472051,METHOD,ziplist.c:<global>,TYPE_DECL,"int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {
    unsigned int prevlensize;
    ZIP_DECODE_PREVLENSIZE(p, prevlensize);
    return zipStorePrevEntryLength(NULL, len) - prevlensize;
}",1,4,ziplist.c,zipPrevLenByteDiff,,false,514,518,zipPrevLenByteDiff,,,9,"int zipPrevLenByteDiff (unsigned char*,unsigned int)"
472086,METHOD,ziplist.c:<global>,TYPE_DECL,"int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {
    long long value;

    if (entrylen >= 32 || entrylen == 0) return 0;
    if (string2ll((char*)entry,entrylen,&value)) {
        /* Great, the string can be encoded. Check what's the smallest
         * of our encoding types that can hold this value. */
        if (value >= 0 && value <= 12) {
            *encoding = ZIP_INT_IMM_MIN+value;
        } else if (value >= INT8_MIN && value <= INT8_MAX) {
            *encoding = ZIP_INT_8B;
        } else if (value >= INT16_MIN && value <= INT16_MAX) {
            *encoding = ZIP_INT_16B;
        } else if (value >= INT24_MIN && value <= INT24_MAX) {
            *encoding = ZIP_INT_24B;
        } else if (value >= INT32_MIN && value <= INT32_MAX) {
            *encoding = ZIP_INT_32B;
        } else {
            *encoding = ZIP_INT_64B;
        }
        *v = value;
        return 1;
    }
    return 0;
}",1,24,ziplist.c,zipTryEncoding,,false,522,546,zipTryEncoding,,,10,"int zipTryEncoding (unsigned char*,unsigned int,long long*,unsigned char*)"
472239,METHOD,ziplist.c:<global>,TYPE_DECL,"void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {
    int16_t i16;
    int32_t i32;
    int64_t i64;
    if (encoding == ZIP_INT_8B) {
        ((int8_t*)p)[0] = (int8_t)value;
    } else if (encoding == ZIP_INT_16B) {
        i16 = value;
        memcpy(p,&i16,sizeof(i16));
        memrev16ifbe(p);
    } else if (encoding == ZIP_INT_24B) {
        i32 = ((uint64_t)value)<<8;
        memrev32ifbe(&i32);
        memcpy(p,((uint8_t*)&i32)+1,sizeof(i32)-sizeof(uint8_t));
    } else if (encoding == ZIP_INT_32B) {
        i32 = value;
        memcpy(p,&i32,sizeof(i32));
        memrev32ifbe(p);
    } else if (encoding == ZIP_INT_64B) {
        i64 = value;
        memcpy(p,&i64,sizeof(i64));
        memrev64ifbe(p);
    } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
        /* Nothing to do, the value is stored in the encoding itself. */
    } else {
        assert(NULL);
    }
}",1,20,ziplist.c,zipSaveInteger,,false,549,576,zipSaveInteger,,,11,"void zipSaveInteger (unsigned char*,int64_t,unsigned char)"
472418,METHOD,ziplist.c:<global>,TYPE_DECL,"int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {
    int16_t i16;
    int32_t i32;
    int64_t i64, ret = 0;
    if (encoding == ZIP_INT_8B) {
        ret = ((int8_t*)p)[0];
    } else if (encoding == ZIP_INT_16B) {
        memcpy(&i16,p,sizeof(i16));
        memrev16ifbe(&i16);
        ret = i16;
    } else if (encoding == ZIP_INT_32B) {
        memcpy(&i32,p,sizeof(i32));
        memrev32ifbe(&i32);
        ret = i32;
    } else if (encoding == ZIP_INT_24B) {
        i32 = 0;
        memcpy(((uint8_t*)&i32)+1,p,sizeof(i32)-sizeof(uint8_t));
        memrev32ifbe(&i32);
        ret = i32>>8;
    } else if (encoding == ZIP_INT_64B) {
        memcpy(&i64,p,sizeof(i64));
        memrev64ifbe(&i64);
        ret = i64;
    } else if (encoding >= ZIP_INT_IMM_MIN && encoding <= ZIP_INT_IMM_MAX) {
        ret = (encoding & ZIP_INT_IMM_MASK)-1;
    } else {
        assert(NULL);
    }
    return ret;
}",1,20,ziplist.c,zipLoadInteger,,false,579,608,zipLoadInteger,,,12,"int64_t zipLoadInteger (unsigned char*,unsigned char)"
472616,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline void zipEntry(unsigned char *p, zlentry *e) {
    ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
    ZIP_ENTRY_ENCODING(p + e->prevrawlensize, e->encoding);
    ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
    assert(e->lensize != 0); /* check that encoding was valid. */
    e->headersize = e->prevrawlensize + e->lensize;
    e->p = p;
}",1,4,ziplist.c,zipEntry,,false,616,623,zipEntry,,,13,"void zipEntry (unsigned char*,zlentry*)"
473044,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline int zipEntrySafe(unsigned char* zl, size_t zlbytes, unsigned char *p, zlentry *e, int validate_prevlen) {
    unsigned char *zlfirst = zl + ZIPLIST_HEADER_SIZE;
    unsigned char *zllast = zl + zlbytes - ZIPLIST_END_SIZE;
#define OUT_OF_RANGE(p) (unlikely((p) < zlfirst || (p) > zllast))

    /* If there's no possibility for the header to reach outside the ziplist,
     * take the fast path. (max lensize and prevrawlensize are both 5 bytes) */
    if (p >= zlfirst && p + 10 < zllast) {
        ZIP_DECODE_PREVLEN(p, e->prevrawlensize, e->prevrawlen);
        ZIP_ENTRY_ENCODING(p + e->prevrawlensize, e->encoding);
        ZIP_DECODE_LENGTH(p + e->prevrawlensize, e->encoding, e->lensize, e->len);
        e->headersize = e->prevrawlensize + e->lensize;
        e->p = p;
        /* We didn't call ZIP_ASSERT_ENCODING, so we check lensize was set to 0. */
        if (unlikely(e->lensize == 0))
            return 0;
        /* Make sure the entry doesn't reach outside the edge ...",1,34,ziplist.c,zipEntrySafe,,false,629,689,zipEntrySafe,,,14,"int zipEntrySafe (unsigned char*,size_t,unsigned char*,zlentry*,int)"
474127,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline unsigned int zipRawEntryLengthSafe(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &e, 0));
    return e.headersize + e.len;
}",1,4,ziplist.c,zipRawEntryLengthSafe,,false,692,696,zipRawEntryLengthSafe,,,15,"unsigned int zipRawEntryLengthSafe (unsigned char*,size_t,unsigned char*)"
474163,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline unsigned int zipRawEntryLength(unsigned char *p) {
    zlentry e;
    zipEntry(p, &e);
    return e.headersize + e.len;
}",1,1,ziplist.c,zipRawEntryLength,,false,699,703,zipRawEntryLength,,,16,unsigned int zipRawEntryLength (unsigned char*)
474181,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline void zipAssertValidEntry(unsigned char* zl, size_t zlbytes, unsigned char *p) {
    zlentry e;
    assert(zipEntrySafe(zl, zlbytes, p, &e, 1));
}",1,4,ziplist.c,zipAssertValidEntry,,false,706,709,zipAssertValidEntry,,,17,"void zipAssertValidEntry (unsigned char*,size_t,unsigned char*)"
474209,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    unsigned char *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    ZIPLIST_LENGTH(zl) = 0;
    zl[bytes-1] = ZIP_END;
    return zl;
}",1,25,ziplist.c,ziplistNew,,false,712,720,ziplistNew,,,18,unsigned char* ziplistNew (void)
474295,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistResize(unsigned char *zl, size_t len) {
    assert(len < UINT32_MAX);
    zl = zrealloc(zl,len);
    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
    zl[len-1] = ZIP_END;
    return zl;
}",1,4,ziplist.c,ziplistResize,,false,723,729,ziplistResize,,,19,"unsigned char* ziplistResize (unsigned char*,size_t)"
474346,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    zlentry cur;
    size_t prevlen, prevlensize, prevoffset; /* Informat of the last changed entry. */
    size_t firstentrylen; /* Used to handle insert at head. */
    size_t rawlen, curlen = intrev32ifbe(ZIPLIST_BYTES(zl));
    size_t extra = 0, cnt = 0, offset;
    size_t delta = 4; /* Extra bytes needed to update a entry's prevlen (5-1). */
    unsigned char *tail = zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl));

    /* Empty ziplist */
    if (p[0] == ZIP_END) return zl;

    zipEntry(p, &cur); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    firstentrylen = prevlen = cur.headersize + cur.len;
    prevlensize = zipStorePrevEntryLength(NULL, prevlen);
    prevoffset = p - zl;
    p += prevlen;

    /* Iterate ziplist to find out how many extra bytes do we need to update it. */
    while (p[0] != ZIP_END) {
        assert(zipEntrySafe(zl, curlen,...",1,28,ziplist.c,__ziplistCascadeUpdate,,false,751,847,__ziplistCascadeUpdate,,,20,"unsigned char* __ziplistCascadeUpdate (unsigned char*,unsigned char*)"
474727,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
    unsigned int i, totlen, deleted = 0;
    size_t offset;
    int nextdiff = 0;
    zlentry first, tail;
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));

    zipEntry(p, &first); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    for (i = 0; p[0] != ZIP_END && i < num; i++) {
        p += zipRawEntryLengthSafe(zl, zlbytes, p);
        deleted++;
    }

    assert(p >= first.p);
    totlen = p-first.p; /* Bytes taken by the element(s) to delete. */
    if (totlen > 0) {
        uint32_t set_tail;
        if (p[0] != ZIP_END) {
            /* Storing `prevrawlen` in this entry may increase or decrease the
             * number of bytes required compare to the current `prevrawlen`.
             * There always is room to store this, because it was previously
             * stored by an entry that is now being deleted. */
            ne...",1,21,ziplist.c,__ziplistDelete,,false,850,923,__ziplistDelete,,,21,"unsigned char* __ziplistDelete (unsigned char*,unsigned char*,unsigned int)"
475064,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, newlen;
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */
    zlentry tail;

    /* Find out prevlen for the entry that is inserted. */
    if (p[0] != ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } else {
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            prevlen = zipRawEntryLengthSafe(zl, curlen, ptail);
        }
    }

    /* See if the entry can be encoded */
    if (zipTryEncoding(s,slen,&value,&encoding)) {
        /* 'encoding' is set to the appropriate int...",1,20,ziplist.c,__ziplistInsert,,false,926,1023,__ziplistInsert,,,22,"unsigned char* __ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)"
475531,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {
    /* If any params are null, we can't merge, so NULL. */
    if (first == NULL || *first == NULL || second == NULL || *second == NULL)
        return NULL;

    /* Can't merge same list into itself. */
    if (*first == *second)
        return NULL;

    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));
    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));

    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));
    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));

    int append;
    unsigned char *source, *target;
    size_t target_bytes, source_bytes;
    /* Pick the largest ziplist so we can resize easily in-place.
     * We must also track if we are now appending or prepending to
     * the target ziplist. */
    if (first_len >= second_len) {
        /* retain first, append second to first. */
        target = *first;
        target_bytes = first_bytes;
        sourc...",1,25,ziplist.c,ziplistMerge,,false,1040,1141,ziplistMerge,,,23,"unsigned char* ziplistMerge (unsigned char**,unsigned char**)"
475922,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {
    unsigned char *p;
    p = (where == ZIPLIST_HEAD) ? ZIPLIST_ENTRY_HEAD(zl) : ZIPLIST_ENTRY_END(zl);
    return __ziplistInsert(zl,p,s,slen);
}",1,18,ziplist.c,ziplistPush,,false,1143,1147,ziplistPush,,,24,"unsigned char* ziplistPush (unsigned char*,unsigned char*,unsigned int,int)"
475970,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistIndex(unsigned char *zl, int index) {
    unsigned char *p;
    unsigned int prevlensize, prevlen = 0;
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
    if (index < 0) {
        index = (-index)-1;
        p = ZIPLIST_ENTRY_TAIL(zl);
        if (p[0] != ZIP_END) {
            /* No need for ""safe"" check: when going backwards, we know the header
             * we're parsing is in the range, we just need to assert (below) that
             * the size we take doesn't cause p to go outside the allocation. */
            ZIP_DECODE_PREVLENSIZE(p, prevlensize);
            assert(p + prevlensize < zl + zlbytes - ZIPLIST_END_SIZE);
            ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            while (prevlen > 0 && index--) {
                p -= prevlen;
                assert(p >= zl + ZIPLIST_HEADER_SIZE && p < zl + zlbytes - ZIPLIST_END_SIZE);
                ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
            }
        }
    } else {
        p ...",1,21,ziplist.c,ziplistIndex,,false,1152,1186,ziplistIndex,,,25,"unsigned char* ziplistIndex (unsigned char*,int)"
476295,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {
    ((void) zl);
    size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));

    /* ""p"" could be equal to ZIP_END, caused by ziplistDelete,
     * and we should return NULL. Otherwise, we should return NULL
     * when the *next* element is ZIP_END (there is no next entry). */
    if (p[0] == ZIP_END) {
        return NULL;
    }

    p += zipRawEntryLength(p);
    if (p[0] == ZIP_END) {
        return NULL;
    }

    zipAssertValidEntry(zl, zlbytes, p);
    return p;
}",1,21,ziplist.c,ziplistNext,,false,1194,1212,ziplistNext,,,26,"unsigned char* ziplistNext (unsigned char*,unsigned char*)"
476346,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {
    unsigned int prevlensize, prevlen = 0;

    /* Iterating backwards from ZIP_END should return the tail. When ""p"" is
     * equal to the first element of the list, we're already at the head,
     * and should return NULL. */
    if (p[0] == ZIP_END) {
        p = ZIPLIST_ENTRY_TAIL(zl);
        return (p[0] == ZIP_END) ? NULL : p;
    } else if (p == ZIPLIST_ENTRY_HEAD(zl)) {
        return NULL;
    } else {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
        assert(prevlen > 0);
        p-=prevlen;
        size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
        zipAssertValidEntry(zl, zlbytes, p);
        return p;
    }
}",1,16,ziplist.c,ziplistPrev,,false,1215,1234,ziplistPrev,,,27,"unsigned char* ziplistPrev (unsigned char*,unsigned char*)"
476510,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {
    zlentry entry;
    if (p == NULL || p[0] == ZIP_END) return 0;
    if (sstr) *sstr = NULL;

    zipEntry(p, &entry); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    if (ZIP_IS_STR(entry.encoding)) {
        if (sstr) {
            *slen = entry.len;
            *sstr = p+entry.headersize;
        }
    } else {
        if (sval) {
            *sval = zipLoadInteger(p+entry.headersize,entry.encoding);
        }
    }
    return 1;
}",1,29,ziplist.c,ziplistGet,,false,1240,1257,ziplistGet,,,28,"unsigned int ziplistGet (unsigned char*,unsigned char**,unsigned int*,long long*)"
476595,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl,p,s,slen);
}",1,1,ziplist.c,ziplistInsert,,false,1260,1262,ziplistInsert,,,29,"unsigned char* ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)"
476609,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p-zl;
    zl = __ziplistDelete(zl,*p,1);

    /* Store pointer to current element in p, because ziplistDelete will
     * do a realloc which might result in a different ""zl""-pointer.
     * When the delete direction is back to front, we might delete the last
     * entry and end up with ""p"" pointing to ZIP_END, so check this. */
    *p = zl+offset;
    return zl;
}",1,1,ziplist.c,ziplistDelete,,false,1267,1277,ziplistDelete,,,30,"unsigned char* ziplistDelete (unsigned char*,unsigned char**)"
476637,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num) {
    unsigned char *p = ziplistIndex(zl,index);
    return (p == NULL) ? zl : __ziplistDelete(zl,p,num);
}",1,1,ziplist.c,ziplistDeleteRange,,false,1280,1283,ziplistDeleteRange,,,31,"unsigned char* ziplistDeleteRange (unsigned char*,int,unsigned int)"
476660,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistReplace(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {

    /* get metadata of the current entry */
    zlentry entry;
    zipEntry(p, &entry);

    /* compute length of entry to store, excluding prevlen */
    unsigned int reqlen;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. */
    if (zipTryEncoding(s,slen,&value,&encoding)) {
        reqlen = zipIntSize(encoding); /* encoding is set */
    } else {
        reqlen = slen; /* encoding == 0 */
    }
    reqlen += zipStoreEntryEncoding(NULL,encoding,slen);

    if (reqlen == entry.lensize + entry.len) {
        /* Simply overwrite the element. */
        p += entry.prevrawlensize;
        p += zipStoreEntryEncoding(p,encoding,slen);
        if (ZIP_IS_STR(encoding)) {
            memcpy(p,s,slen);
        } else {
            zipSaveInteger(p,value,encoding);
        }
    } else {
        /* Fallback. */
        zl = ziplistDelete...",1,12,ziplist.c,ziplistReplace,,false,1287,1319,ziplistReplace,,,32,"unsigned char* ziplistReplace (unsigned char*,unsigned char*,unsigned char*,unsigned int)"
476765,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {
    zlentry entry;
    unsigned char sencoding;
    long long zval, sval;
    if (p[0] == ZIP_END) return 0;

    zipEntry(p, &entry); /* no need for ""safe"" variant since the input pointer was validated by the function that returned it. */
    if (ZIP_IS_STR(entry.encoding)) {
        /* Raw compare */
        if (entry.len == slen) {
            return memcmp(p+entry.headersize,sstr,slen) == 0;
        } else {
            return 0;
        }
    } else {
        /* Try to compare encoded values. Don't compare encoding because
         * different implementations may encoded integers differently. */
        if (zipTryEncoding(sstr,slen,&sval,&sencoding)) {
          zval = zipLoadInteger(p+entry.headersize,entry.encoding);
          return zval == sval;
        }
    }
    return 0;
}",1,16,ziplist.c,ziplistCompare,,false,1323,1346,ziplistCompare,,,33,"unsigned int ziplistCompare (unsigned char*,unsigned char*,unsigned int)"
476855,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned char *ziplistFind(unsigned char *zl, unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {
    int skipcnt = 0;
    unsigned char vencoding = 0;
    long long vll = 0;
    size_t zlbytes = ziplistBlobLen(zl);

    while (p[0] != ZIP_END) {
        struct zlentry e;
        unsigned char *q;

        assert(zipEntrySafe(zl, zlbytes, p, &e, 1));
        q = p + e.prevrawlensize + e.lensize;

        if (skipcnt == 0) {
            /* Compare current entry with specified entry */
            if (ZIP_IS_STR(e.encoding)) {
                if (e.len == vlen && memcmp(q, vstr, vlen) == 0) {
                    return p;
                }
            } else {
                /* Find out if the searched field can be encoded. Note that
                 * we do it only the first time, once done vencoding is set
                 * to non-zero and vll is set to the integer value. */
                if (vencoding == 0) {
                    if (!zipTryEncoding(vs...",1,19,ziplist.c,ziplistFind,,false,1350,1407,ziplistFind,,,34,"unsigned char* ziplistFind (unsigned char*,unsigned char*,unsigned char*,unsigned int,unsigned int)"
477029,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned int ziplistLen(unsigned char *zl) {
    unsigned int len = 0;
    if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
        len = intrev16ifbe(ZIPLIST_LENGTH(zl));
    } else {
        unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
        size_t zlbytes = intrev32ifbe(ZIPLIST_BYTES(zl));
        while (*p != ZIP_END) {
            p += zipRawEntryLengthSafe(zl, zlbytes, p);
            len++;
        }

        /* Re-store length if small enough */
        if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
    }
    return len;
}",1,8,ziplist.c,ziplistLen,,false,1410,1426,ziplistLen,,,35,unsigned int ziplistLen (unsigned char*)
477135,METHOD,ziplist.c:<global>,TYPE_DECL,"size_t ziplistBlobLen(unsigned char *zl) {
    return intrev32ifbe(ZIPLIST_BYTES(zl));
}",1,11,ziplist.c,ziplistBlobLen,,false,1429,1431,ziplistBlobLen,,,36,size_t ziplistBlobLen (unsigned char*)
477148,METHOD,ziplist.c:<global>,TYPE_DECL,"void ziplistRepr(unsigned char *zl) {
    unsigned char *p;
    int index = 0;
    zlentry entry;
    size_t zlbytes = ziplistBlobLen(zl);

    printf(
        ""{total bytes %u} ""
        ""{num entries %u}\n""
        ""{tail offset %u}\n"",
        intrev32ifbe(ZIPLIST_BYTES(zl)),
        intrev16ifbe(ZIPLIST_LENGTH(zl)),
        intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)));
    p = ZIPLIST_ENTRY_HEAD(zl);
    while(*p != ZIP_END) {
        assert(zipEntrySafe(zl, zlbytes, p, &entry, 1));
        printf(
            ""{\n""
                ""\taddr 0x%08lx,\n""
                ""\tindex %2d,\n""
                ""\toffset %5lu,\n""
                ""\thdr+entry len: %5u,\n""
                ""\thdr len%2u,\n""
                ""\tprevrawlen: %5u,\n""
                ""\tprevrawlensize: %2u,\n""
                ""\tpayload %5u\n"",
            (long unsigned)p,
            index,
            (unsigned long) (p-zl),
            entry.headersize+entry.len,
            entry.headersize,
            entry.prevraw...",1,8,ziplist.c,ziplistRepr,,false,1433,1490,ziplistRepr,,,37,void ziplistRepr (unsigned char*)
477376,METHOD,ziplist.c:<global>,TYPE_DECL,"int ziplistValidateIntegrity(unsigned char *zl, size_t size, int deep,
    ziplistValidateEntryCB entry_cb, void *cb_userdata) {
    /* check that we can actually read the header. (and ZIP_END) */
    if (size < ZIPLIST_HEADER_SIZE + ZIPLIST_END_SIZE)
        return 0;

    /* check that the encoded size in the header must match the allocated size. */
    size_t bytes = intrev32ifbe(ZIPLIST_BYTES(zl));
    if (bytes != size)
        return 0;

    /* the last byte must be the terminator. */
    if (zl[size - ZIPLIST_END_SIZE] != ZIP_END)
        return 0;

    /* make sure the tail offset isn't reaching outside the allocation. */
    if (intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) > size - ZIPLIST_END_SIZE)
        return 0;

    if (!deep)
        return 1;

    unsigned int count = 0;
    unsigned int header_count = intrev16ifbe(ZIPLIST_LENGTH(zl));
    unsigned char *p = ZIPLIST_ENTRY_HEAD(zl);
    unsigned char *prev = NULL;
    size_t prev_raw_size = 0;
    while(*p != ZIP_END) {
   ...",1,15,ziplist.c,ziplistValidateIntegrity,,false,1495,1556,ziplistValidateIntegrity,,,38,"int ziplistValidateIntegrity (unsigned char*,size_t,int,ziplistValidateEntryCB,void*)"
477621,METHOD,ziplist.c:<global>,TYPE_DECL,"void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val) {
    int ret;
    unsigned char *p;

    /* Avoid div by zero on corrupt ziplist */
    assert(total_count);

    /* Generate even numbers, because ziplist saved K-V pair */
    int r = (rand() % total_count) * 2;
    p = ziplistIndex(zl, r);
    ret = ziplistGet(p, &key->sval, &key->slen, &key->lval);
    assert(ret != 0);

    if (!val)
        return;
    p = ziplistNext(zl, p);
    ret = ziplistGet(p, &val->sval, &val->slen, &val->lval);
    assert(ret != 0);
}",1,4,ziplist.c,ziplistRandomPair,,false,1562,1580,ziplistRandomPair,,,39,"void ziplistRandomPair (unsigned char*,long unsigned,ziplistEntry*,ziplistEntry*)"
477733,METHOD,ziplist.c:<global>,TYPE_DECL,"int uintCompare(const void *a, const void *b) {
    return (*(unsigned int *) a - *(unsigned int *) b);
}",1,1,ziplist.c,uintCompare,,false,1583,1585,uintCompare,,,40,"int uintCompare (void*,void*)"
477749,METHOD,ziplist.c:<global>,TYPE_DECL,"static inline void ziplistSaveValue(unsigned char *val, unsigned int len, long long lval, ziplistEntry *dest) {
    dest->sval = val;
    dest->slen = len;
    dest->lval = lval;
}",1,1,ziplist.c,ziplistSaveValue,,false,1588,1592,ziplistSaveValue,,,41,"void ziplistSaveValue (unsigned char*,unsigned int,long long,ziplistEntry*)"
477772,METHOD,ziplist.c:<global>,TYPE_DECL,"void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {
    unsigned char *p, *key, *value;
    unsigned int klen = 0, vlen = 0;
    long long klval = 0, vlval = 0;

    /* Notice: the index member must be first due to the use in uintCompare */
    typedef struct {
        unsigned int index;
        unsigned int order;
    } rand_pick;
    rand_pick *picks = zmalloc(sizeof(rand_pick)*count);
    unsigned int total_size = ziplistLen(zl)/2;

    /* Avoid div by zero on corrupt ziplist */
    assert(total_size);

    /* create a pool of random indexes (some may be duplicate). */
    for (unsigned int i = 0; i < count; i++) {
        picks[i].index = (rand() % total_size) * 2; /* Generate even indexes */
        /* keep track of the order we picked them */
        picks[i].order = i;
    }

    /* sort by indexes. */
    qsort(picks, count, sizeof(rand_pick), uintCompare);

    /* fetch the elements form the ziplist into a output array r...",1,4,ziplist.c,ziplistRandomPairs,,false,1598,1642,ziplistRandomPairs,,,42,"void ziplistRandomPairs (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)"
477975,METHOD,ziplist.c:<global>,TYPE_DECL,"unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals) {
    unsigned char *p, *key;
    unsigned int klen = 0;
    long long klval = 0;
    unsigned int total_size = ziplistLen(zl)/2;
    unsigned int index = 0;
    if (count > total_size)
        count = total_size;

    /* To only iterate once, every time we try to pick a member, the probability
     * we pick it is the quotient of the count left we want to pick and the
     * count still we haven't visited in the dict, this way, we could make every
     * member be equally picked.*/
    p = ziplistIndex(zl, 0);
    unsigned int picked = 0, remaining = count;
    while (picked < count && p) {
        double randomDouble = ((double)rand()) / RAND_MAX;
        double threshold = ((double)remaining) / (total_size - index);
        if (randomDouble <= threshold) {
            assert(ziplistGet(p, &key, &klen, &klval));
            ziplistSaveValue(key, klen, klval, &keys[p...",1,12,ziplist.c,ziplistRandomPairsUnique,,false,1650,1687,ziplistRandomPairsUnique,,,43,"unsigned int ziplistRandomPairsUnique (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)"
478174,METHOD,ziplist.h:<global>,TYPE_DECL,<global>,1,23,ziplist.h,ziplist.h:<global>,,false,1,74,<global>,,,1,
478181,METHOD,ziplist.h:<global>,TYPE_DECL,unsigned char *ziplistNew(void);,15,31,ziplist.h,ziplistNew,,false,46,46,ziplistNew,,,3,unsigned char* ziplistNew (void)
478186,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistMerge(unsigned char **first, unsigned char **second);",15,74,ziplist.h,ziplistMerge,,false,47,47,ziplistMerge,,,4,"unsigned char* ziplistMerge (unsigned char**,unsigned char**)"
478192,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);",15,93,ziplist.h,ziplistPush,,false,48,48,ziplistPush,,,5,"unsigned char* ziplistPush (unsigned char*,unsigned char*,unsigned int,int)"
478200,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistIndex(unsigned char *zl, int index);",15,57,ziplist.h,ziplistIndex,,false,49,49,ziplistIndex,,,6,"unsigned char* ziplistIndex (unsigned char*,int)"
478206,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);",15,63,ziplist.h,ziplistNext,,false,50,50,ziplistNext,,,7,"unsigned char* ziplistNext (unsigned char*,unsigned char*)"
478212,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);",15,63,ziplist.h,ziplistPrev,,false,51,51,ziplistPrev,,,8,"unsigned char* ziplistPrev (unsigned char*,unsigned char*)"
478218,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned int ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval);",14,100,ziplist.h,ziplistGet,,false,52,52,ziplistGet,,,9,"unsigned int ziplistGet (unsigned char*,unsigned char**,unsigned int*,long long*)"
478226,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);",15,102,ziplist.h,ziplistInsert,,false,53,53,ziplistInsert,,,10,"unsigned char* ziplistInsert (unsigned char*,unsigned char*,unsigned char*,unsigned int)"
478234,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);",15,66,ziplist.h,ziplistDelete,,false,54,54,ziplistDelete,,,11,"unsigned char* ziplistDelete (unsigned char*,unsigned char**)"
478240,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistDeleteRange(unsigned char *zl, int index, unsigned int num);",15,81,ziplist.h,ziplistDeleteRange,,false,55,55,ziplistDeleteRange,,,12,"unsigned char* ziplistDeleteRange (unsigned char*,int,unsigned int)"
478247,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistReplace(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);",15,103,ziplist.h,ziplistReplace,,false,56,56,ziplistReplace,,,13,"unsigned char* ziplistReplace (unsigned char*,unsigned char*,unsigned char*,unsigned int)"
478255,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen);",14,82,ziplist.h,ziplistCompare,,false,57,57,ziplistCompare,,,14,"unsigned int ziplistCompare (unsigned char*,unsigned char*,unsigned int)"
478262,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned char *ziplistFind(unsigned char *zl, unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);",15,122,ziplist.h,ziplistFind,,false,58,58,ziplistFind,,,15,"unsigned char* ziplistFind (unsigned char*,unsigned char*,unsigned char*,unsigned int,unsigned int)"
478271,METHOD,ziplist.h:<global>,TYPE_DECL,unsigned int ziplistLen(unsigned char *zl);,14,42,ziplist.h,ziplistLen,,false,59,59,ziplistLen,,,16,unsigned int ziplistLen (unsigned char*)
478276,METHOD,ziplist.h:<global>,TYPE_DECL,size_t ziplistBlobLen(unsigned char *zl);,8,40,ziplist.h,ziplistBlobLen,,false,60,60,ziplistBlobLen,,,17,size_t ziplistBlobLen (unsigned char*)
478281,METHOD,ziplist.h:<global>,TYPE_DECL,void ziplistRepr(unsigned char *zl);,6,35,ziplist.h,ziplistRepr,,false,61,61,ziplistRepr,,,18,void ziplistRepr (unsigned char*)
478286,METHOD,ziplist.h:<global>,TYPE_DECL,"typedef int (*ziplistValidateEntryCB)(unsigned char* p, unsigned int head_count, void* userdata);",13,96,ziplist.h,ziplistValidateEntryCB,,false,62,62,ziplistValidateEntryCB,,,19,"int ziplistValidateEntryCB (unsigned char*,unsigned int,void*)"
478293,METHOD,ziplist.h:<global>,TYPE_DECL,"int ziplistValidateIntegrity(unsigned char *zl, size_t size, int deep,
                             ziplistValidateEntryCB entry_cb, void *cb_userdata);",5,80,ziplist.h,ziplistValidateIntegrity,,false,63,64,ziplistValidateIntegrity,,,20,"int ziplistValidateIntegrity (unsigned char*,size_t,int,ziplistValidateEntryCB,void*)"
478302,METHOD,ziplist.h:<global>,TYPE_DECL,"void ziplistRandomPair(unsigned char *zl, unsigned long total_count, ziplistEntry *key, ziplistEntry *val);",6,106,ziplist.h,ziplistRandomPair,,false,65,65,ziplistRandomPair,,,21,"void ziplistRandomPair (unsigned char*,long unsigned,ziplistEntry*,ziplistEntry*)"
478310,METHOD,ziplist.h:<global>,TYPE_DECL,"void ziplistRandomPairs(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals);",6,102,ziplist.h,ziplistRandomPairs,,false,66,66,ziplistRandomPairs,,,22,"void ziplistRandomPairs (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)"
478318,METHOD,ziplist.h:<global>,TYPE_DECL,"unsigned int ziplistRandomPairsUnique(unsigned char *zl, unsigned int count, ziplistEntry *keys, ziplistEntry *vals);",14,116,ziplist.h,ziplistRandomPairsUnique,,false,67,67,ziplistRandomPairsUnique,,,23,"unsigned int ziplistRandomPairsUnique (unsigned char*,unsigned int,ziplistEntry*,ziplistEntry*)"
478326,METHOD,ziplist.h:<global>,TYPE_DECL,"int ziplistSafeToAdd(unsigned char* zl, size_t add);",5,51,ziplist.h,ziplistSafeToAdd,,false,68,68,ziplistSafeToAdd,,,24,"int ziplistSafeToAdd (unsigned char*,size_t)"
478343,METHOD,zipmap.c:<global>,TYPE_DECL,<global>,1,20,zipmap.c,zipmap.c:<global>,,false,1,542,<global>,,,1,
478345,METHOD,zipmap.c:<global>,TYPE_DECL,"unsigned char *zipmapNew(void) {
    unsigned char *zm = zmalloc(2);

    zm[0] = 0; /* Length */
    zm[1] = ZIPMAP_END;
    return zm;
}",1,12,zipmap.c,zipmapNew,,false,96,102,zipmapNew,,,1,unsigned char* zipmapNew (void)
478369,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned int zipmapDecodeLength(unsigned char *p) {
    unsigned int len = *p;

    if (len < ZIPMAP_BIGLEN) return len;
    memcpy(&len,p+1,sizeof(unsigned int));
    memrev32ifbe(&len);
    return len;
}",1,14,zipmap.c,zipmapDecodeLength,,false,105,112,zipmapDecodeLength,,,2,unsigned int zipmapDecodeLength (unsigned char*)
478405,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned int zipmapGetEncodedLengthSize(unsigned char *p) {
    return (*p < ZIPMAP_BIGLEN) ? 1: 5;
}",1,17,zipmap.c,zipmapGetEncodedLengthSize,,false,114,116,zipmapGetEncodedLengthSize,,,3,unsigned int zipmapGetEncodedLengthSize (unsigned char*)
478420,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {
    if (p == NULL) {
        return ZIPMAP_LEN_BYTES(len);
    } else {
        if (len < ZIPMAP_BIGLEN) {
            p[0] = len;
            return 1;
        } else {
            p[0] = ZIPMAP_BIGLEN;
            memcpy(p+1,&len,sizeof(len));
            memrev32ifbe(p+1);
            return 1+sizeof(len);
        }
    }
}",1,15,zipmap.c,zipmapEncodeLength,,false,120,134,zipmapEncodeLength,,,4,"unsigned int zipmapEncodeLength (unsigned char*,unsigned int)"
478488,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {
    unsigned char *p = zm+1, *k = NULL;
    unsigned int l,llen;

    while(*p != ZIPMAP_END) {
        unsigned char free;

        /* Match or skip the key */
        l = zipmapDecodeLength(p);
        llen = zipmapEncodeLength(NULL,l);
        if (key != NULL && k == NULL && l == klen && !memcmp(p+llen,key,l)) {
            /* Only return when the user doesn't care
             * for the total length of the zipmap. */
            if (totlen != NULL) {
                k = p;
            } else {
                return p;
            }
        }
        p += llen+l;
        /* Skip the value as well */
        l = zipmapDecodeLength(p);
        p += zipmapEncodeLength(NULL,l);
        free = p[0];
        p += l+1+free; /* +1 to skip the free byte */
    }
    if (totlen != NULL) *totlen = (unsigned int)(p-zm)+1;
    return k;
}",1,16,zipmap.c,zipmapLookupRaw,,false,142,170,zipmapLookupRaw,,,5,"unsigned char* zipmapLookupRaw (unsigned char*,unsigned char*,unsigned int,unsigned int*)"
478602,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {
    unsigned int l;

    l = klen+vlen+3;
    if (klen >= ZIPMAP_BIGLEN) l += 4;
    if (vlen >= ZIPMAP_BIGLEN) l += 4;
    return l;
}",1,16,zipmap.c,zipmapRequiredLength,,false,172,179,zipmapRequiredLength,,,6,"unsigned long zipmapRequiredLength (unsigned int,unsigned int)"
478638,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned int zipmapRawKeyLength(unsigned char *p) {
    unsigned int l = zipmapDecodeLength(p);
    return zipmapEncodeLength(NULL,l) + l;
}",1,1,zipmap.c,zipmapRawKeyLength,,false,182,185,zipmapRawKeyLength,,,7,unsigned int zipmapRawKeyLength (unsigned char*)
478654,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned int zipmapRawValueLength(unsigned char *p) {
    unsigned int l = zipmapDecodeLength(p);
    unsigned int used;

    used = zipmapEncodeLength(NULL,l);
    used += p[used] + 1 + l;
    return used;
}",1,1,zipmap.c,zipmapRawValueLength,,false,189,196,zipmapRawValueLength,,,8,unsigned int zipmapRawValueLength (unsigned char*)
478681,METHOD,zipmap.c:<global>,TYPE_DECL,"static unsigned int zipmapRawEntryLength(unsigned char *p) {
    unsigned int l = zipmapRawKeyLength(p);
    return l + zipmapRawValueLength(p+l);
}",1,1,zipmap.c,zipmapRawEntryLength,,false,201,204,zipmapRawEntryLength,,,9,unsigned int zipmapRawEntryLength (unsigned char*)
478698,METHOD,zipmap.c:<global>,TYPE_DECL,"static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {
    zm = zrealloc(zm, len);
    zm[len-1] = ZIPMAP_END;
    return zm;
}",1,16,zipmap.c,zipmapResize,,false,206,210,zipmapResize,,,10,"unsigned char* zipmapResize (unsigned char*,unsigned int)"
478720,METHOD,zipmap.c:<global>,TYPE_DECL,"unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {
    unsigned int zmlen, offset;
    unsigned int freelen, reqlen = zipmapRequiredLength(klen,vlen);
    unsigned int empty, vempty;
    unsigned char *p;

    freelen = reqlen;
    if (update) *update = 0;
    p = zipmapLookupRaw(zm,key,klen,&zmlen);
    if (p == NULL) {
        /* Key not found: enlarge */
        zm = zipmapResize(zm, zmlen+reqlen);
        p = zm+zmlen-1;
        zmlen = zmlen+reqlen;

        /* Increase zipmap length (this is an insert) */
        if (zm[0] < ZIPMAP_BIGLEN) zm[0]++;
    } else {
        /* Key found. Is there enough space for the new value? */
        /* Compute the total length: */
        if (update) *update = 1;
        freelen = zipmapRawEntryLength(p);
        if (freelen < reqlen) {
            /* Store the offset of this key within the current zipmap, so
             * it can be resized. Then, move the ...",1,20,zipmap.c,zipmapSet,,false,215,281,zipmapSet,,,11,"unsigned char* zipmapSet (unsigned char*,unsigned char*,unsigned int,unsigned char*,unsigned int,int*)"
478938,METHOD,zipmap.c:<global>,TYPE_DECL,"unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {
    unsigned int zmlen, freelen;
    unsigned char *p = zipmapLookupRaw(zm,key,klen,&zmlen);
    if (p) {
        freelen = zipmapRawEntryLength(p);
        memmove(p, p+freelen, zmlen-((p-zm)+freelen+1));
        zm = zipmapResize(zm, zmlen-freelen);

        /* Decrease zipmap length */
        if (zm[0] < ZIPMAP_BIGLEN) zm[0]--;

        if (deleted) *deleted = 1;
    } else {
        if (deleted) *deleted = 0;
    }
    return zm;
}",1,20,zipmap.c,zipmapDel,,false,285,301,zipmapDel,,,12,"unsigned char* zipmapDel (unsigned char*,unsigned char*,unsigned int,int*)"
479016,METHOD,zipmap.c:<global>,TYPE_DECL,"unsigned char *zipmapRewind(unsigned char *zm) {
    return zm+1;
}",1,1,zipmap.c,zipmapRewind,,false,304,306,zipmapRewind,,,13,unsigned char* zipmapRewind (unsigned char*)
479025,METHOD,zipmap.c:<global>,TYPE_DECL,"unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {
    if (zm[0] == ZIPMAP_END) return NULL;
    if (key) {
        *key = zm;
        *klen = zipmapDecodeLength(zm);
        *key += ZIPMAP_LEN_BYTES(*klen);
    }
    zm += zipmapRawKeyLength(zm);
    if (value) {
        *value = zm+1;
        *vlen = zipmapDecodeLength(zm);
        *value += ZIPMAP_LEN_BYTES(*vlen);
    }
    zm += zipmapRawValueLength(zm);
    return zm;
}",1,17,zipmap.c,zipmapNext,,false,319,334,zipmapNext,,,14,"unsigned char* zipmapNext (unsigned char*,unsigned char**,unsigned int*,unsigned char**,unsigned int*)"
479115,METHOD,zipmap.c:<global>,TYPE_DECL,"int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {
    unsigned char *p;

    if ((p = zipmapLookupRaw(zm,key,klen,NULL)) == NULL) return 0;
    p += zipmapRawKeyLength(p);
    *vlen = zipmapDecodeLength(p);
    *value = p + ZIPMAP_LEN_BYTES(*vlen) + 1;
    return 1;
}",1,17,zipmap.c,zipmapGet,,false,338,346,zipmapGet,,,15,"int zipmapGet (unsigned char*,unsigned char*,unsigned int,unsigned char**,unsigned int*)"
479170,METHOD,zipmap.c:<global>,TYPE_DECL,"int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {
    return zipmapLookupRaw(zm,key,klen,NULL) != NULL;
}",1,1,zipmap.c,zipmapExists,,false,349,351,zipmapExists,,,16,"int zipmapExists (unsigned char*,unsigned char*,unsigned int)"
479185,METHOD,zipmap.c:<global>,TYPE_DECL,"unsigned int zipmapLen(unsigned char *zm) {
    unsigned int len = 0;
    if (zm[0] < ZIPMAP_BIGLEN) {
        len = zm[0];
    } else {
        unsigned char *p = zipmapRewind(zm);
        while((p = zipmapNext(p,NULL,NULL,NULL,NULL)) != NULL) len++;

        /* Re-store length if small enough */
        if (len < ZIPMAP_BIGLEN) zm[0] = len;
    }
    return len;
}",1,16,zipmap.c,zipmapLen,,false,354,366,zipmapLen,,,17,unsigned int zipmapLen (unsigned char*)
479242,METHOD,zipmap.c:<global>,TYPE_DECL,"size_t zipmapBlobLen(unsigned char *zm) {
    unsigned int totlen;
    zipmapLookupRaw(zm,NULL,0,&totlen);
    return totlen;
}",1,1,zipmap.c,zipmapBlobLen,,false,371,375,zipmapBlobLen,,,18,size_t zipmapBlobLen (unsigned char*)
479256,METHOD,zipmap.c:<global>,TYPE_DECL,"int zipmapValidateIntegrity(unsigned char *zm, size_t size, int deep) {
#define OUT_OF_RANGE(p) ( \
        (p) < zm + 2 || \
        (p) > zm + size - 1)
    unsigned int l, s, e;

    /* check that we can actually read the header (or ZIPMAP_END). */
    if (size < 2)
        return 0;

    /* the last byte must be the terminator. */
    if (zm[size-1] != ZIPMAP_END)
        return 0;

    if (!deep)
        return 1;

    unsigned int count = 0;
    unsigned char *p = zm + 1; /* skip the count */
    while(*p != ZIPMAP_END) {
        /* read the field name length encoding type */
        s = zipmapGetEncodedLengthSize(p);
        /* make sure the entry length doesn't reach outside the edge of the zipmap */
        if (OUT_OF_RANGE(p+s))
            return 0;

        /* read the field name length */
        l = zipmapDecodeLength(p);
        p += s; /* skip the encoded field size */
        p += l; /* skip the field */

        /* make sure the entry doesn't reach outside the edge...",1,22,zipmap.c,zipmapValidateIntegrity,,false,380,442,zipmapValidateIntegrity,,,19,"int zipmapValidateIntegrity (unsigned char*,size_t,int)"
479462,METHOD,zipmap.h:<global>,TYPE_DECL,<global>,1,6,zipmap.h,zipmap.h:<global>,,false,1,54,<global>,,,1,
479464,METHOD,zipmap.h:<global>,TYPE_DECL,unsigned char *zipmapNew(void);,15,30,zipmap.h,zipmapNew,,false,38,38,zipmapNew,,,1,unsigned char* zipmapNew (void)
479469,METHOD,zipmap.h:<global>,TYPE_DECL,"unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);",15,134,zipmap.h,zipmapSet,,false,39,39,zipmapSet,,,2,"unsigned char* zipmapSet (unsigned char*,unsigned char*,unsigned int,unsigned char*,unsigned int,int*)"
479479,METHOD,zipmap.h:<global>,TYPE_DECL,"unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);",15,96,zipmap.h,zipmapDel,,false,40,40,zipmapDel,,,3,"unsigned char* zipmapDel (unsigned char*,unsigned char*,unsigned int,int*)"
479487,METHOD,zipmap.h:<global>,TYPE_DECL,unsigned char *zipmapRewind(unsigned char *zm);,15,46,zipmap.h,zipmapRewind,,false,41,41,zipmapRewind,,,4,unsigned char* zipmapRewind (unsigned char*)
479492,METHOD,zipmap.h:<global>,TYPE_DECL,"unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);",15,128,zipmap.h,zipmapNext,,false,42,42,zipmapNext,,,5,"unsigned char* zipmapNext (unsigned char*,unsigned char**,unsigned int*,unsigned char**,unsigned int*)"
479501,METHOD,zipmap.h:<global>,TYPE_DECL,"int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);",5,114,zipmap.h,zipmapGet,,false,43,43,zipmapGet,,,6,"int zipmapGet (unsigned char*,unsigned char*,unsigned int,unsigned char**,unsigned int*)"
479510,METHOD,zipmap.h:<global>,TYPE_DECL,"int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);",5,74,zipmap.h,zipmapExists,,false,44,44,zipmapExists,,,7,"int zipmapExists (unsigned char*,unsigned char*,unsigned int)"
479517,METHOD,zipmap.h:<global>,TYPE_DECL,unsigned int zipmapLen(unsigned char *zm);,14,41,zipmap.h,zipmapLen,,false,45,45,zipmapLen,,,8,unsigned int zipmapLen (unsigned char*)
479522,METHOD,zipmap.h:<global>,TYPE_DECL,size_t zipmapBlobLen(unsigned char *zm);,8,39,zipmap.h,zipmapBlobLen,,false,46,46,zipmapBlobLen,,,9,size_t zipmapBlobLen (unsigned char*)
479527,METHOD,zipmap.h:<global>,TYPE_DECL,void zipmapRepr(unsigned char *p);,6,33,zipmap.h,zipmapRepr,,false,47,47,zipmapRepr,,,10,void zipmapRepr (unsigned char*)
479532,METHOD,zipmap.h:<global>,TYPE_DECL,"int zipmapValidateIntegrity(unsigned char *zm, size_t size, int deep);",5,69,zipmap.h,zipmapValidateIntegrity,,false,48,48,zipmapValidateIntegrity,,,11,"int zipmapValidateIntegrity (unsigned char*,size_t,int)"
479602,METHOD,zmalloc.c:<global>,TYPE_DECL,<global>,1,1,zmalloc.c,zmalloc.c:<global>,,false,1,851,<global>,,,1,
479604,METHOD,zmalloc.c:<global>,TYPE_DECL,"void zlibc_free(void *ptr) {
    free(ptr);
}",1,1,zmalloc.c,zlibc_free,,false,49,51,zlibc_free,,,1,void zlibc_free (void*)
479615,METHOD,zmalloc.c:<global>,TYPE_DECL,"static void zmalloc_default_oom(size_t size) {
    fprintf(stderr, ""zmalloc: Out of memory trying to allocate %zu bytes\n"",
        size);
    fflush(stderr);
    abort();
}",1,1,zmalloc.c,zmalloc_default_oom,,false,96,101,zmalloc_default_oom,,,4,void zmalloc_default_oom (size_t)
479627,METHOD,zmalloc.c:<global>,TYPE_DECL,static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;,13,64,zmalloc.c,zmalloc_oom_handler,,false,103,103,zmalloc_oom_handler,,,5,void zmalloc_oom_handler (ANY)
479635,METHOD,zmalloc.c:<global>,TYPE_DECL,"static inline void *ztrymalloc_usable_internal(size_t size, size_t *usable) {
    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) return NULL;
    void *ptr = malloc(MALLOC_MIN_SIZE(size)+PREFIX_SIZE);

    if (!ptr) return NULL;
#ifdef HAVE_MALLOC_SIZE
    size = zmalloc_size(ptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *usable = size;
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    if (usable) *usable = size;
    return (char*)ptr+PREFIX_SIZE;
#endif
}",1,23,zmalloc.c,ztrymalloc_usable_internal,,false,114,131,ztrymalloc_usable_internal,,,7,"void* ztrymalloc_usable_internal (size_t,size_t*)"
479705,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *ztrymalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrymalloc_usable_internal(size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",1,1,zmalloc.c,ztrymalloc_usable,,false,133,141,ztrymalloc_usable,,,8,"void* ztrymalloc_usable (size_t,size_t*)"
479731,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zmalloc(size_t size) {
    void *ptr = ztrymalloc_usable_internal(size, NULL);
    if (!ptr) zmalloc_oom_handler(size);
    return ptr;
}",1,1,zmalloc.c,zmalloc,,false,144,148,zmalloc,,,9,void* zmalloc (size_t)
479750,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *ztrymalloc(size_t size) {
    void *ptr = ztrymalloc_usable_internal(size, NULL);
    return ptr;
}",1,1,zmalloc.c,ztrymalloc,,false,151,154,ztrymalloc,,,10,void* ztrymalloc (size_t)
479763,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zmalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrymalloc_usable_internal(size, &usable_size);
    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",1,1,zmalloc.c,zmalloc_usable,,false,158,167,zmalloc_usable,,,11,"void* zmalloc_usable (size_t,size_t*)"
479795,METHOD,zmalloc.c:<global>,TYPE_DECL,"static inline void *ztrycalloc_usable_internal(size_t size, size_t *usable) {
    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) return NULL;
    void *ptr = calloc(1, MALLOC_MIN_SIZE(size)+PREFIX_SIZE);
    if (ptr == NULL) return NULL;

#ifdef HAVE_MALLOC_SIZE
    size = zmalloc_size(ptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *usable = size;
    return ptr;
#else
    *((size_t*)ptr) = size;
    update_zmalloc_stat_alloc(size+PREFIX_SIZE);
    if (usable) *usable = size;
    return (char*)ptr+PREFIX_SIZE;
#endif
}",1,26,zmalloc.c,ztrycalloc_usable_internal,,false,190,207,ztrycalloc_usable_internal,,,12,"void* ztrycalloc_usable_internal (size_t,size_t*)"
479867,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *ztrycalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrycalloc_usable_internal(size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",1,1,zmalloc.c,ztrycalloc_usable,,false,209,217,ztrycalloc_usable,,,13,"void* ztrycalloc_usable (size_t,size_t*)"
479893,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zcalloc_num(size_t num, size_t size) {
    /* Ensure that the arguments to calloc(), when multiplied, do not wrap.
     * Division operations are susceptible to divide-by-zero errors so we also check it. */
    if ((size == 0) || (num > SIZE_MAX/size)) {
        zmalloc_oom_handler(SIZE_MAX);
        return NULL;
    }
    void *ptr = ztrycalloc_usable_internal(num*size, NULL);
    if (!ptr) zmalloc_oom_handler(num*size);
    return ptr;
}",1,1,zmalloc.c,zcalloc_num,,false,221,231,zcalloc_num,,,14,"void* zcalloc_num (size_t,size_t)"
479932,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zcalloc(size_t size) {
    void *ptr = ztrycalloc_usable_internal(size, NULL);
    if (!ptr) zmalloc_oom_handler(size);
    return ptr;
}",1,1,zmalloc.c,zcalloc,,false,234,238,zcalloc,,,15,void* zcalloc (size_t)
479951,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *ztrycalloc(size_t size) {
    void *ptr = ztrycalloc_usable_internal(size, NULL);
    return ptr;
}",1,1,zmalloc.c,ztrycalloc,,false,241,244,ztrycalloc,,,16,void* ztrycalloc (size_t)
479964,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zcalloc_usable(size_t size, size_t *usable) {
    size_t usable_size = 0;
    void *ptr = ztrycalloc_usable_internal(size, &usable_size);
    if (!ptr) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",1,1,zmalloc.c,zcalloc_usable,,false,248,257,zcalloc_usable,,,17,"void* zcalloc_usable (size_t,size_t*)"
479996,METHOD,zmalloc.c:<global>,TYPE_DECL,"static inline void *ztryrealloc_usable_internal(void *ptr, size_t size, size_t *usable) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
#endif
    size_t oldsize;
    void *newptr;

    /* not allocating anything, just redirect to free. */
    if (size == 0 && ptr != NULL) {
        zfree(ptr);
        if (usable) *usable = 0;
        return NULL;
    }
    /* Not freeing anything, just redirect to malloc. */
    if (ptr == NULL)
        return ztrymalloc_usable(size, usable);

    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */
    if (size >= SIZE_MAX/2) {
        zfree(ptr);
        if (usable) *usable = 0;
        return NULL;
    }

#ifdef HAVE_MALLOC_SIZE
    oldsize = zmalloc_size(ptr);
    newptr = realloc(ptr,size);
    if (newptr == NULL) {
        if (usable) *usable = 0;
        return NULL;
    }

    update_zmalloc_stat_free(oldsize);
    size = zmalloc_size(newptr);
    update_zmalloc_stat_alloc(size);
    if (usable) *u...",1,25,zmalloc.c,ztryrealloc_usable_internal,,false,261,313,ztryrealloc_usable_internal,,,18,"void* ztryrealloc_usable_internal (void*,size_t,size_t*)"
480127,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *ztryrealloc_usable(void *ptr, size_t size, size_t *usable) {
    size_t usable_size = 0;
    ptr = ztryrealloc_usable_internal(ptr, size, &usable_size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",1,1,zmalloc.c,ztryrealloc_usable,,false,315,323,ztryrealloc_usable,,,19,"void* ztryrealloc_usable (void*,size_t,size_t*)"
480154,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zrealloc(void *ptr, size_t size) {
    ptr = ztryrealloc_usable_internal(ptr, size, NULL);
    if (!ptr && size != 0) zmalloc_oom_handler(size);
    return ptr;
}",1,1,zmalloc.c,zrealloc,,false,326,330,zrealloc,,,20,"void* zrealloc (void*,size_t)"
480178,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *ztryrealloc(void *ptr, size_t size) {
    ptr = ztryrealloc_usable_internal(ptr, size, NULL);
    return ptr;
}",1,1,zmalloc.c,ztryrealloc,,false,333,336,ztryrealloc,,,21,"void* ztryrealloc (void*,size_t)"
480192,METHOD,zmalloc.c:<global>,TYPE_DECL,"void *zrealloc_usable(void *ptr, size_t size, size_t *usable) {
    size_t usable_size = 0;
    ptr = ztryrealloc_usable(ptr, size, &usable_size);
    if (!ptr && size != 0) zmalloc_oom_handler(size);
#ifdef HAVE_MALLOC_SIZE
    ptr = extend_to_usable(ptr, usable_size);
#endif
    if (usable) *usable = usable_size;
    return ptr;
}",1,1,zmalloc.c,zrealloc_usable,,false,340,349,zrealloc_usable,,,22,"void* zrealloc_usable (void*,size_t,size_t*)"
480229,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_size(void *ptr) {
    void *realptr = (char*)ptr-PREFIX_SIZE;
    size_t size = *((size_t*)realptr);
    return size+PREFIX_SIZE;
}",1,31,zmalloc.c,zmalloc_size,,false,355,359,zmalloc_size,,,23,size_t zmalloc_size (void*)
480259,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_usable_size(void *ptr) {
    return zmalloc_size(ptr)-PREFIX_SIZE;
}",1,29,zmalloc.c,zmalloc_usable_size,,false,360,362,zmalloc_usable_size,,,24,size_t zmalloc_usable_size (void*)
480272,METHOD,zmalloc.c:<global>,TYPE_DECL,"void zfree(void *ptr) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char*)ptr-PREFIX_SIZE;
    oldsize = *((size_t*)realptr);
    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
    free(realptr);
#endif
}",1,25,zmalloc.c,zfree,,false,365,381,zfree,,,25,void zfree (void*)
480311,METHOD,zmalloc.c:<global>,TYPE_DECL,"void zfree_usable(void *ptr, size_t *usable) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;
#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(*usable = zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char*)ptr-PREFIX_SIZE;
    *usable = oldsize = *((size_t*)realptr);
    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
    free(realptr);
#endif
}",1,25,zmalloc.c,zfree_usable,,false,384,400,zfree_usable,,,26,"void zfree_usable (void*,size_t*)"
480354,METHOD,zmalloc.c:<global>,TYPE_DECL,"char *zstrdup(const char *s) {
    size_t l = strlen(s)+1;
    char *p = zmalloc(l);

    memcpy(p,s,l);
    return p;
}",1,1,zmalloc.c,zstrdup,,false,402,408,zstrdup,,,27,char* zstrdup (char*)
480377,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_used_memory(void) {
    size_t um;
    atomicGet(used_memory,um);
    return um;
}",1,1,zmalloc.c,zmalloc_used_memory,,false,410,414,zmalloc_used_memory,,,28,size_t zmalloc_used_memory (void)
480388,METHOD,zmalloc.c:<global>,TYPE_DECL,"void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {
    zmalloc_oom_handler = oom_handler;
}",1,1,zmalloc.c,zmalloc_set_oom_handler,,false,416,418,zmalloc_set_oom_handler,,,29,void zmalloc_set_oom_handler (void)
480396,METHOD,zmalloc.c:<global>,TYPE_DECL,"void zmadvise_dontneed(void *ptr) {
#if defined(USE_JEMALLOC) && defined(__linux__)
    static size_t page_size = 0;
    if (page_size == 0) page_size = sysconf(_SC_PAGESIZE);
    size_t page_size_mask = page_size - 1;

    size_t real_size = zmalloc_size(ptr);
    if (real_size < page_size) return;

    /* We need to align the pointer upwards according to page size, because
     * the memory address is increased upwards and we only can free memory
     * based on page. */
    char *aligned_ptr = (char *)(((size_t)ptr+page_size_mask) & ~page_size_mask);
    real_size -= (aligned_ptr-(char*)ptr);
    if (real_size >= page_size) {
        madvise((void *)aligned_ptr, real_size&~page_size_mask, MADV_DONTNEED);
    }
#else
    (void)(ptr);
#endif
}",1,1,zmalloc.c,zmadvise_dontneed,,false,423,443,zmadvise_dontneed,,,30,void zmadvise_dontneed (void*)
480404,METHOD,zmalloc.c:<global>,TYPE_DECL,"int get_proc_stat_ll(int i, long long *res) {
#if defined(HAVE_PROC_STAT)
    char buf[4096];
    int fd, l;
    char *p, *x;

    if ((fd = open(""/proc/self/stat"",O_RDONLY)) == -1) return 0;
    if ((l = read(fd,buf,sizeof(buf)-1)) <= 0) {
        close(fd);
        return 0;
    }
    close(fd);
    buf[l] = '\0';
    if (buf[l-1] == '\n') buf[l-1] = '\0';

    /* Skip pid and process name (surrounded with parentheses) */
    p = strrchr(buf, ')');
    if (!p) return 0;
    p++;
    while (*p == ' ') p++;
    if (*p == '\0') return 0;
    i -= 3;
    if (i < 0) return 0;

    while (p && i--) {
        p = strchr(p, ' ');
        if (p) p++;
        else return 0;
    }
    x = strchr(p,' ');
    if (x) *x = '\0';

    *res = strtoll(p,&x,10);
    if (*x != '\0') return 0;
    return 1;
#else
    UNUSED(i);
    UNUSED(res);
    return 0;
#endif
}",1,4,zmalloc.c,get_proc_stat_ll,,false,462,502,get_proc_stat_ll,,,31,"int get_proc_stat_ll (int,long long*)"
480424,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_get_rss(void) {
    /* If we can't get the RSS in an OS-specific way for this system just
     * return the memory usage we estimated in zmalloc()..
     *
     * Fragmentation will appear to be always 1 (no fragmentation)
     * of course... */
    return zmalloc_used_memory();
}",1,1,zmalloc.c,zmalloc_get_rss,,false,618,625,zmalloc_get_rss,,,32,size_t zmalloc_get_rss (void)
480431,METHOD,zmalloc.c:<global>,TYPE_DECL,"int zmalloc_get_allocator_info(size_t *allocated,
                               size_t *active,
                               size_t *resident) {
    *allocated = *resident = *active = 0;
    return 1;
}",1,1,zmalloc.c,zmalloc_get_allocator_info,,false,674,679,zmalloc_get_allocator_info,,,33,"int zmalloc_get_allocator_info (size_t*,size_t*,size_t*)"
480450,METHOD,zmalloc.c:<global>,TYPE_DECL,"void set_jemalloc_bg_thread(int enable) {
    ((void)(enable));
}",1,1,zmalloc.c,set_jemalloc_bg_thread,,false,681,683,set_jemalloc_bg_thread,,,34,void set_jemalloc_bg_thread (int)
480458,METHOD,zmalloc.c:<global>,TYPE_DECL,"int jemalloc_purge(void) {
    return 0;
}",1,1,zmalloc.c,jemalloc_purge,,false,685,687,jemalloc_purge,,,35,int jemalloc_purge (void)
480465,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_get_smap_bytes_by_field(char *field, long pid) {
#if defined(__APPLE__)
    struct proc_regioninfo pri;
    if (pid == -1) pid = getpid();
    if (proc_pidinfo(pid, PROC_PIDREGIONINFO, 0, &pri,
                     PROC_PIDREGIONINFO_SIZE) == PROC_PIDREGIONINFO_SIZE)
    {
        int pagesize = getpagesize();
        if (!strcmp(field, ""Private_Dirty:"")) {
            return (size_t)pri.pri_pages_dirtied * pagesize;
        } else if (!strcmp(field, ""Rss:"")) {
            return (size_t)pri.pri_pages_resident * pagesize;
        } else if (!strcmp(field, ""AnonHugePages:"")) {
            return 0;
        }
    }
    return 0;
#endif
    ((void) field);
    ((void) pid);
    return 0;
}",1,1,zmalloc.c,zmalloc_get_smap_bytes_by_field,,false,745,766,zmalloc_get_smap_bytes_by_field,,,36,"size_t zmalloc_get_smap_bytes_by_field (char*,long)"
480479,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_get_private_dirty(long pid) {
    return zmalloc_get_smap_bytes_by_field(""Private_Dirty:"",pid);
}",1,1,zmalloc.c,zmalloc_get_private_dirty,,false,774,776,zmalloc_get_private_dirty,,,37,size_t zmalloc_get_private_dirty (long)
480488,METHOD,zmalloc.c:<global>,TYPE_DECL,"size_t zmalloc_get_memory_size(void) {
#if defined(__unix__) || defined(__unix) || defined(unix) || \
    (defined(__APPLE__) && defined(__MACH__))
#if defined(CTL_HW) && (defined(HW_MEMSIZE) || defined(HW_PHYSMEM64))
    int mib[2];
    mib[0] = CTL_HW;
#if defined(HW_MEMSIZE)
    mib[1] = HW_MEMSIZE;            /* OSX. --------------------- */
#elif defined(HW_PHYSMEM64)
    mib[1] = HW_PHYSMEM64;          /* NetBSD, OpenBSD. --------- */
#endif
    int64_t size = 0;               /* 64-bit */
    size_t len = sizeof(size);
    if (sysctl( mib, 2, &size, &len, NULL, 0) == 0)
        return (size_t)size;
    return 0L;          /* Failed? */

#elif defined(_SC_PHYS_PAGES) && defined(_SC_PAGESIZE)
    /* FreeBSD, Linux, OpenBSD, and Solaris. -------------------- */
    return (size_t)sysconf(_SC_PHYS_PAGES) * (size_t)sysconf(_SC_PAGESIZE);

#elif defined(CTL_HW) && (defined(HW_PHYSMEM) || defined(HW_REALMEM))
    /* DragonFly BSD, FreeBSD, NetBSD, OpenBSD, and OSX. -------- */
    i...",1,1,zmalloc.c,zmalloc_get_memory_size,,false,791,832,zmalloc_get_memory_size,,,38,size_t zmalloc_get_memory_size (void)
480508,METHOD,zmalloc.h:<global>,TYPE_DECL,<global>,1,24,zmalloc.h,zmalloc.h:<global>,,false,1,167,<global>,,,1,
480510,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((malloc,alloc_size(1),noinline)) void *zmalloc(size_t size);",53,73,zmalloc.h,zmalloc,,false,106,106,zmalloc,,,1,void* zmalloc (size_t)
480515,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((malloc,alloc_size(1),noinline)) void *zcalloc(size_t size);",53,73,zmalloc.h,zcalloc,,false,107,107,zcalloc,,,2,void* zcalloc (size_t)
480520,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((malloc,alloc_size(1,2),noinline)) void *zcalloc_num(size_t num, size_t size);",55,91,zmalloc.h,zcalloc_num,,false,108,108,zcalloc_num,,,3,"void* zcalloc_num (size_t,size_t)"
480526,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((alloc_size(2),noinline)) void *zrealloc(void *ptr, size_t size);",46,78,zmalloc.h,zrealloc,,false,109,109,zrealloc,,,4,"void* zrealloc (void*,size_t)"
480532,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((malloc,alloc_size(1),noinline)) void *ztrymalloc(size_t size);",53,76,zmalloc.h,ztrymalloc,,false,110,110,ztrymalloc,,,5,void* ztrymalloc (size_t)
480537,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((malloc,alloc_size(1),noinline)) void *ztrycalloc(size_t size);",53,76,zmalloc.h,ztrycalloc,,false,111,111,ztrycalloc,,,6,void* ztrycalloc (size_t)
480542,METHOD,zmalloc.h:<global>,TYPE_DECL,"__attribute__((alloc_size(2),noinline)) void *ztryrealloc(void *ptr, size_t size);",46,81,zmalloc.h,ztryrealloc,,false,112,112,ztryrealloc,,,7,"void* ztryrealloc (void*,size_t)"
480548,METHOD,zmalloc.h:<global>,TYPE_DECL,void zfree(void *ptr);,6,21,zmalloc.h,zfree,,false,113,113,zfree,,,8,void zfree (void*)
480553,METHOD,zmalloc.h:<global>,TYPE_DECL,"void *zmalloc_usable(size_t size, size_t *usable);",6,49,zmalloc.h,zmalloc_usable,,false,114,114,zmalloc_usable,,,9,"void* zmalloc_usable (size_t,size_t*)"
480559,METHOD,zmalloc.h:<global>,TYPE_DECL,"void *zcalloc_usable(size_t size, size_t *usable);",6,49,zmalloc.h,zcalloc_usable,,false,115,115,zcalloc_usable,,,10,"void* zcalloc_usable (size_t,size_t*)"
480565,METHOD,zmalloc.h:<global>,TYPE_DECL,"void *zrealloc_usable(void *ptr, size_t size, size_t *usable);",6,61,zmalloc.h,zrealloc_usable,,false,116,116,zrealloc_usable,,,11,"void* zrealloc_usable (void*,size_t,size_t*)"
480572,METHOD,zmalloc.h:<global>,TYPE_DECL,"void *ztrymalloc_usable(size_t size, size_t *usable);",6,52,zmalloc.h,ztrymalloc_usable,,false,117,117,ztrymalloc_usable,,,12,"void* ztrymalloc_usable (size_t,size_t*)"
480578,METHOD,zmalloc.h:<global>,TYPE_DECL,"void *ztrycalloc_usable(size_t size, size_t *usable);",6,52,zmalloc.h,ztrycalloc_usable,,false,118,118,ztrycalloc_usable,,,13,"void* ztrycalloc_usable (size_t,size_t*)"
480584,METHOD,zmalloc.h:<global>,TYPE_DECL,"void *ztryrealloc_usable(void *ptr, size_t size, size_t *usable);",6,64,zmalloc.h,ztryrealloc_usable,,false,119,119,ztryrealloc_usable,,,14,"void* ztryrealloc_usable (void*,size_t,size_t*)"
480591,METHOD,zmalloc.h:<global>,TYPE_DECL,"void zfree_usable(void *ptr, size_t *usable);",6,44,zmalloc.h,zfree_usable,,false,120,120,zfree_usable,,,15,"void zfree_usable (void*,size_t*)"
480597,METHOD,zmalloc.h:<global>,TYPE_DECL,__attribute__((malloc)) char *zstrdup(const char *s);,30,52,zmalloc.h,zstrdup,,false,121,121,zstrdup,,,16,char* zstrdup (char*)
480602,METHOD,zmalloc.h:<global>,TYPE_DECL,size_t zmalloc_used_memory(void);,8,32,zmalloc.h,zmalloc_used_memory,,false,122,122,zmalloc_used_memory,,,17,size_t zmalloc_used_memory (void)
480607,METHOD,zmalloc.h:<global>,TYPE_DECL,void zmalloc_set_oom_handler(void (*oom_handler)(size_t));,6,57,zmalloc.h,zmalloc_set_oom_handler,,false,123,123,zmalloc_set_oom_handler,,,18,void zmalloc_set_oom_handler (void)
480612,METHOD,zmalloc.h:<global>,TYPE_DECL,size_t zmalloc_get_rss(void);,8,28,zmalloc.h,zmalloc_get_rss,,false,124,124,zmalloc_get_rss,,,19,size_t zmalloc_get_rss (void)
480617,METHOD,zmalloc.h:<global>,TYPE_DECL,"int zmalloc_get_allocator_info(size_t *allocated, size_t *active, size_t *resident);",5,83,zmalloc.h,zmalloc_get_allocator_info,,false,125,125,zmalloc_get_allocator_info,,,20,"int zmalloc_get_allocator_info (size_t*,size_t*,size_t*)"
480624,METHOD,zmalloc.h:<global>,TYPE_DECL,void set_jemalloc_bg_thread(int enable);,6,39,zmalloc.h,set_jemalloc_bg_thread,,false,126,126,set_jemalloc_bg_thread,,,21,void set_jemalloc_bg_thread (int)
480629,METHOD,zmalloc.h:<global>,TYPE_DECL,int jemalloc_purge(void);,5,24,zmalloc.h,jemalloc_purge,,false,127,127,jemalloc_purge,,,22,int jemalloc_purge (void)
480634,METHOD,zmalloc.h:<global>,TYPE_DECL,size_t zmalloc_get_private_dirty(long pid);,8,42,zmalloc.h,zmalloc_get_private_dirty,,false,128,128,zmalloc_get_private_dirty,,,23,size_t zmalloc_get_private_dirty (long)
480639,METHOD,zmalloc.h:<global>,TYPE_DECL,"size_t zmalloc_get_smap_bytes_by_field(char *field, long pid);",8,61,zmalloc.h,zmalloc_get_smap_bytes_by_field,,false,129,129,zmalloc_get_smap_bytes_by_field,,,24,"size_t zmalloc_get_smap_bytes_by_field (char*,long)"
480645,METHOD,zmalloc.h:<global>,TYPE_DECL,size_t zmalloc_get_memory_size(void);,8,36,zmalloc.h,zmalloc_get_memory_size,,false,130,130,zmalloc_get_memory_size,,,25,size_t zmalloc_get_memory_size (void)
480650,METHOD,zmalloc.h:<global>,TYPE_DECL,void zlibc_free(void *ptr);,6,26,zmalloc.h,zlibc_free,,false,131,131,zlibc_free,,,26,void zlibc_free (void*)
480655,METHOD,zmalloc.h:<global>,TYPE_DECL,void zmadvise_dontneed(void *ptr);,6,33,zmalloc.h,zmadvise_dontneed,,false,132,132,zmadvise_dontneed,,,27,void zmadvise_dontneed (void*)
480660,METHOD,zmalloc.h:<global>,TYPE_DECL,size_t zmalloc_size(void *ptr);,8,30,zmalloc.h,zmalloc_size,,false,140,140,zmalloc_size,,,28,size_t zmalloc_size (void*)
480665,METHOD,zmalloc.h:<global>,TYPE_DECL,size_t zmalloc_usable_size(void *ptr);,8,37,zmalloc.h,zmalloc_usable_size,,false,141,141,zmalloc_usable_size,,,29,size_t zmalloc_usable_size (void*)
480670,METHOD,zmalloc.h:<global>,TYPE_DECL,"int get_proc_stat_ll(int i, long long *res);",5,43,zmalloc.h,get_proc_stat_ll,,false,161,161,get_proc_stat_ll,,,30,"int get_proc_stat_ll (int,long long*)"
482789,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,,false,1,,<global>,,,1,
482967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,,true,,,<operator>.assignment,,,0,
482972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,,true,,,<operator>.arrayInitializer,,,0,
482993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:237:237:ACL_CATEGORY_KEYSPACE:0,,true,237,237,ACL_CATEGORY_KEYSPACE,,,0,
482996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,,true,,,<operator>.shiftLeft,,,0,
483001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:238:238:ACL_CATEGORY_READ:0,,true,238,238,ACL_CATEGORY_READ,,,0,
483004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:239:239:ACL_CATEGORY_WRITE:0,,true,239,239,ACL_CATEGORY_WRITE,,,0,
483007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:240:240:ACL_CATEGORY_SET:0,,true,240,240,ACL_CATEGORY_SET,,,0,
483010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:241:241:ACL_CATEGORY_SORTEDSET:0,,true,241,241,ACL_CATEGORY_SORTEDSET,,,0,
483013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:242:242:ACL_CATEGORY_LIST:0,,true,242,242,ACL_CATEGORY_LIST,,,0,
483016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:243:243:ACL_CATEGORY_HASH:0,,true,243,243,ACL_CATEGORY_HASH,,,0,
483019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:244:244:ACL_CATEGORY_STRING:0,,true,244,244,ACL_CATEGORY_STRING,,,0,
483022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:245:245:ACL_CATEGORY_BITMAP:0,,true,245,245,ACL_CATEGORY_BITMAP,,,0,
483025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:246:246:ACL_CATEGORY_HYPERLOGLOG:0,,true,246,246,ACL_CATEGORY_HYPERLOGLOG,,,0,
483028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:247:247:ACL_CATEGORY_GEO:0,,true,247,247,ACL_CATEGORY_GEO,,,0,
483031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:248:248:ACL_CATEGORY_STREAM:0,,true,248,248,ACL_CATEGORY_STREAM,,,0,
483034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:249:249:ACL_CATEGORY_PUBSUB:0,,true,249,249,ACL_CATEGORY_PUBSUB,,,0,
483037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:250:250:ACL_CATEGORY_ADMIN:0,,true,250,250,ACL_CATEGORY_ADMIN,,,0,
483040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:251:251:ACL_CATEGORY_FAST:0,,true,251,251,ACL_CATEGORY_FAST,,,0,
483043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:252:252:ACL_CATEGORY_SLOW:0,,true,252,252,ACL_CATEGORY_SLOW,,,0,
483046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:253:253:ACL_CATEGORY_BLOCKING:0,,true,253,253,ACL_CATEGORY_BLOCKING,,,0,
483049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:254:254:ACL_CATEGORY_DANGEROUS:0,,true,254,254,ACL_CATEGORY_DANGEROUS,,,0,
483052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:255:255:ACL_CATEGORY_CONNECTION:0,,true,255,255,ACL_CATEGORY_CONNECTION,,,0,
483055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:256:256:ACL_CATEGORY_TRANSACTION:0,,true,256,256,ACL_CATEGORY_TRANSACTION,,,0,
483058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:257:257:ACL_CATEGORY_SCRIPTING:0,,true,257,257,ACL_CATEGORY_SCRIPTING,,,0,
483061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1067:1067:USER_FLAG_ENABLED:0,,true,1067,1067,USER_FLAG_ENABLED,,,0,
483064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1068:1068:USER_FLAG_DISABLED:0,,true,1068,1068,USER_FLAG_DISABLED,,,0,
483067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1069:1069:USER_FLAG_NOPASS:0,,true,1069,1069,USER_FLAG_NOPASS,,,0,
483070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1077:1077:USER_FLAG_SANITIZE_PAYLOAD_SKIP:0,,true,1077,1077,USER_FLAG_SANITIZE_PAYLOAD_SKIP,,,0,
483073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1075:1075:USER_FLAG_SANITIZE_PAYLOAD:0,,true,1075,1075,USER_FLAG_SANITIZE_PAYLOAD,,,0,
483076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1083:1083:SELECTOR_FLAG_ALLKEYS:0,,true,1083,1083,SELECTOR_FLAG_ALLKEYS,,,0,
483079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1085:1085:SELECTOR_FLAG_ALLCHANNELS:0,,true,1085,1085,SELECTOR_FLAG_ALLCHANNELS,,,0,
483082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1084:1084:SELECTOR_FLAG_ALLCOMMANDS:0,,true,1084,1084,SELECTOR_FLAG_ALLCOMMANDS,,,0,
483085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,,true,,,<operator>.division,,,0,
483090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1063:1063:USER_COMMAND_BITS_COUNT:0,,true,1063,1063,USER_COMMAND_BITS_COUNT,,,0,
483093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,,true,,,<operator>.lessThan,,,0,
483098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,,true,,,<operator>.postIncrement,,,0,
483102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,,true,,,<operators>.assignmentOr,,,0,
483107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,,true,,,<operator>.xor,,,0,
483112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,,true,,,<operator>.indirectIndexAccess,,,0,
483117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,,true,,,<operator>.addressOf,,,0,
483121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,,true,,,<operator>.cast,,,0,
483126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.h,sha256.h:17:17:SHA256_BLOCK_SIZE:0,,true,17,17,SHA256_BLOCK_SIZE,,,0,
483129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,,true,,,<operator>.multiplication,,,0,
483134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,,true,,,<operator>.arithmeticShiftRight,,,0,
483139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,,true,,,<operator>.and,,,0,
483144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,,true,,,<operator>.addition,,,0,
483149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,acl.c,acl.c:151:151:HASH_PASSWORD_LEN:0,,true,151,151,HASH_PASSWORD_LEN,,,0,
483152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,,true,,,<operator>.notEquals,,,0,
483157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:111:111:C_ERR:0,,true,111,111,C_ERR,,,0,
483160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,,true,,,<operator>.minus,,,0,
483164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,,true,,,<operator>.logicalAnd,,,0,
483169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,,true,,,<operator>.logicalOr,,,0,
483174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,,true,,,<operator>.greaterThan,,,0,
483179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:110:110:C_OK:0,,true,110,110,C_OK,,,0,
483182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isspace,,true,,,isspace,,,0,
483186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,,true,,,<operator>.equals,,,0,
483191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,,true,,,<operator>.fieldAccess,,,0,
483196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,,true,,,<operator>.logicalNot,,,0,
483200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcasecmp,,true,,,strcasecmp,,,0,
483205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,,true,,,<operator>.sizeOf,,,0,
483209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,,true,,,<operator>.indirectFieldAccess,,,0,
483214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2903:2903:ACL_ALL_PERMISSION:0,,true,2903,2903,ACL_ALL_PERMISSION,,,0,
483217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,,true,,,<operator>.or,,,0,
483222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2901:2901:ACL_READ_PERMISSION:0,,true,2901,2901,ACL_READ_PERMISSION,,,0,
483225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2902:2902:ACL_WRITE_PERMISSION:0,,true,2902,2902,ACL_WRITE_PERMISSION,,,0,
483228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:673:673:serverPanic:1,,true,673,673,serverPanic,,,0,
483231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.expressionList,,true,,,<operator>.expressionList,,,0,
483236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abort,,true,,,abort,,,0,
483239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:66:66:listSetMatchMethod:2,,true,66,66,listSetMatchMethod,,,0,
483244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:65:65:listSetFreeMethod:2,,true,65,65,listSetFreeMethod,,,0,
483249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:64:64:listSetDupMethod:2,,true,64,64,listSetDupMethod,,,0,
483254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memset,,true,,,memset,,,0,
483260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcpy,,true,,,memcpy,,,0,
483266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:672:672:serverAssert:1,,true,672,672,serverAssert,,,0,
483269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,,true,,,<operator>.conditional,,,0,
483275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.bracketedPrimary,,true,,,<operator>.bracketedPrimary,,,0,
483279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:62:62:listNodeValue:1,,true,62,62,listNodeValue,,,0,
483283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,,true,,,<operator>.indirection,,,0,
483287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1081:1081:SELECTOR_FLAG_ROOT:0,,true,1081,1081,SELECTOR_FLAG_ROOT,,,0,
483290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snprintf,,true,,,snprintf,,,0,
483298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strlen,,true,,,strlen,,,0,
483302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:386:386:CLIENT_CLOSE_AFTER_COMMAND:0,,true,386,386,CLIENT_CLOSE_AFTER_COMMAND,,,0,
483305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,,true,,,<operator>.greaterEqualsThan,,,0,
483310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,,true,,,<operator>.modulo,,,0,
483315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,,true,,,<operator>.subtraction,,,0,
483320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentAnd,,true,,,<operators>.assignmentAnd,,,0,
483325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,,true,,,<operator>.not,,,0,
483329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,,true,,,<operator>.assignmentPlus,,,0,
483334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strchr,,true,,,strchr,,,0,
483339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,,true,,,<operator>.assignmentMinus,,,0,
483344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcmp,,true,,,memcmp,,,0,
483350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:102:102:min:2,,true,102,102,min,,,0,
483354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memmove,,true,,,memmove,,,0,
483360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3729:3732:serverLog:2,,true,3729,3732,serverLog,,,0,
483363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:694:694:OBJ_STRING:0,,true,694,694,OBJ_STRING,,,0,
483366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,toupper,,true,,,toupper,,,0,
483370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strrchr,,true,,,strrchr,,,0,
483375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2891:2891:ACL_DENIED_AUTH:0,,true,2891,2891,ACL_DENIED_AUTH,,,0,
483378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:338:338:CLIENT_MULTI:0,,true,338,338,CLIENT_MULTI,,,0,
483381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2897:2897:ACL_LOG_CTX_MULTI:0,,true,2897,2897,ACL_LOG_CTX_MULTI,,,0,
483384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2895:2895:ACL_LOG_CTX_TOPLEVEL:0,,true,2895,2895,ACL_LOG_CTX_TOPLEVEL,,,0,
483387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2888:2888:ACL_OK:0,,true,2888,2888,ACL_OK,,,0,
483390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:278:278:CMD_KEY_ACCESS:0,,true,278,278,CMD_KEY_ACCESS,,,0,
483393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:282:282:CMD_KEY_INSERT:0,,true,282,282,CMD_KEY_INSERT,,,0,
483396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:284:284:CMD_KEY_DELETE:0,,true,284,284,CMD_KEY_DELETE,,,0,
483399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:280:280:CMD_KEY_UPDATE:0,,true,280,280,CMD_KEY_UPDATE,,,0,
483402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2890:2890:ACL_DENIED_KEY:0,,true,2890,2890,ACL_DENIED_KEY,,,0,
483405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcmp,,true,,,strcmp,,,0,
483410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2892:2892:ACL_DENIED_CHANNEL:0,,true,2892,2892,ACL_DENIED_CHANNEL,,,0,
483413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:220:220:CMD_NO_AUTH:0,,true,220,220,CMD_NO_AUTH,,,0,
483416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2889:2889:ACL_DENIED_CMD:0,,true,2889,2889,ACL_DENIED_CMD,,,0,
483419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3290:3290:GET_KEYSPEC_DEFAULT:0,,true,3290,3290,GET_KEYSPEC_DEFAULT,,,0,
483422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:309:309:CMD_CHANNEL_PUBLISH:0,,true,309,309,CMD_CHANNEL_PUBLISH,,,0,
483425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:307:307:CMD_CHANNEL_SUBSCRIBE:0,,true,307,307,CMD_CHANNEL_SUBSCRIBE,,,0,
483428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:306:306:CMD_CHANNEL_PATTERN:0,,true,306,306,CMD_CHANNEL_PATTERN,,,0,
483431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:428:428:CLIENT_TYPE_PUBSUB:0,,true,428,428,CLIENT_TYPE_PUBSUB,,,0,
483434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fopen,,true,,,fopen,,,0,
483439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror,,true,,,strerror,,,0,
483443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fgets,,true,,,fgets,,,0,
483449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fclose,,true,,,fclose,,,0,
483453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpid,,true,,,getpid,,,0,
483456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,open,,true,,,open,,,0,
483461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write,,true,,,write,,,0,
483467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,,true,,,<operator>.lessEqualsThan,,,0,
483472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:117:117:redis_fsync:1,,true,117,117,redis_fsync,,,0,
483476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fsync,,true,,,fsync,,,0,
483480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,close,,true,,,close,,,0,
483484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rename,,true,,,rename,,,0,
483489,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlink,,true,,,unlink,,,0,
483493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:57:57:listLength:1,,true,57,57,listLength,,,0,
483497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit,,true,,,exit,,,0,
483501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,acl.c,acl.c:2498:2498:ACL_LOG_GROUPING_MAX_TIME_DELTA:0,,true,2498,2498,ACL_LOG_GROUPING_MAX_TIME_DELTA,,,0,
483504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,,true,,,<operator>.postDecrement,,,0,
483508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:59:59:listLast:1,,true,59,59,listLast,,,0,
483512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:209:209:CMD_MODULE:0,,true,209,209,CMD_MODULE,,,0,
483515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:58:58:listFirst:1,,true,58,58,listFirst,,,0,
483519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,acl.c,acl.c:2916:2916:GENPASS_MAX_BITS:0,,true,2916,2916,GENPASS_MAX_BITS,,,0,
483522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2896:2896:ACL_LOG_CTX_LUA:0,,true,2896,2896,ACL_LOG_CTX_LUA,,,0,
483525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2898:2898:ACL_LOG_CTX_MODULE:0,,true,2898,2898,ACL_LOG_CTX_MODULE,,,0,
483528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:97:97:AL_START_HEAD:0,,true,97,97,AL_START_HEAD,,,0,
483531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:98:98:AL_START_TAIL:0,,true,98,98,AL_START_TAIL,,,0,
483534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:41:41:AE_NONE:0,,true,41,41,AE_NONE,,,0,
483537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:53:53:AE_DONT_WAIT:0,,true,53,53,AE_DONT_WAIT,,,0,
483540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:38:38:AE_OK:0,,true,38,38,AE_OK,,,0,
483543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:39:39:AE_ERR:0,,true,39,39,AE_ERR,,,0,
483546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:42:42:AE_READABLE:0,,true,42,42,AE_READABLE,,,0,
483549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:43:43:AE_WRITABLE:0,,true,43,43,AE_WRITABLE,,,0,
483552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:44:44:AE_BARRIER:0,,true,44,44,AE_BARRIER,,,0,
483555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:58:58:AE_DELETED_EVENT_ID:0,,true,58,58,AE_DELETED_EVENT_ID,,,0,
483558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aeTimeEvent.finalizerProc,,true,,,finalizerProc,,,0,
483564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aeTimeEvent.timeProc,,true,,,timeProc,,,0,
483571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:57:57:AE_NOMORE:0,,true,57,57,AE_NOMORE,,,0,
483574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:51:51:AE_TIME_EVENTS:0,,true,51,51,AE_TIME_EVENTS,,,0,
483577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:50:50:AE_FILE_EVENTS:0,,true,50,50,AE_FILE_EVENTS,,,0,
483580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:54:54:AE_CALL_BEFORE_SLEEP:0,,true,54,54,AE_CALL_BEFORE_SLEEP,,,0,
483583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aeEventLoop.beforesleep,,true,,,beforesleep,,,0,
483588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:55:55:AE_CALL_AFTER_SLEEP:0,,true,55,55,AE_CALL_AFTER_SLEEP,,,0,
483591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aeEventLoop.aftersleep,,true,,,aftersleep,,,0,
483596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aeFileEvent.rfileProc,,true,,,rfileProc,,,0,
483604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,aeFileEvent.wfileProc,,true,,,wfileProc,,,0,
483612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,poll,,true,,,poll,,,0,
483618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae.h,ae.h:52:52:AE_ALL_EVENTS:0,,true,52,52,AE_ALL_EVENTS,,,0,
483621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epoll_create,,true,,,epoll_create,,,0,
483625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epoll_ctl,,true,,,epoll_ctl,,,0,
483632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,epoll_wait,,true,,,epoll_wait,,,0,
483639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,panic,,true,,,panic,,,0,
483644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae_evport.c,ae_evport.c:65:65:MAX_EVENT_BATCHSZ:0,,true,65,65,MAX_EVENT_BATCHSZ,,,0,
483647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_create,,true,,,port_create,,,0,
483650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fprintf,,true,,,fprintf,,,0,
483656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_associate,,true,,,port_associate,,,0,
483664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_dissociate,,true,,,port_dissociate,,,0,
483670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,perror,,true,,,perror,,,0,
483674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port_getn,,true,,,port_getn,,,0,
483682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae_kqueue.c,ae_kqueue.c:47:47:EVENT_MASK_OFFSET:1,,true,47,47,EVENT_MASK_OFFSET,,,0,
483686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae_kqueue.c,ae_kqueue.c:48:48:EVENT_MASK_ENCODE:2,,true,48,48,EVENT_MASK_ENCODE,,,0,
483691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kqueue,,true,,,kqueue,,,0,
483694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ae_kqueue.c,ae_kqueue.c:46:46:EVENT_MASK_MALLOC_SIZE:1,,true,46,46,EVENT_MASK_MALLOC_SIZE,,,0,
483698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EV_SET,,true,,,EV_SET,,,0,
483708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kevent,,true,,,kevent,,,0,
483717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_ZERO,,true,,,FD_ZERO,,,0,
483721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AE_NOTUSED,,true,,,AE_NOTUSED,,,0,
483725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_SET,,true,,,FD_SET,,,0,
483730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_CLR,,true,,,FD_CLR,,,0,
483735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,select,,true,,,select,,,0,
483743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FD_ISSET,,true,,,FD_ISSET,,,0,
483748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_start,,true,,,va_start,,,0,
483753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vsnprintf,,true,,,vsnprintf,,,0,
483760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.h,anet.h:38:38:ANET_ERR_LEN:0,,true,38,38,ANET_ERR_LEN,,,0,
483763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_end,,true,,,va_end,,,0,
483767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockopt,,true,,,getsockopt,,,0,
483775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fcntl,,true,,,fcntl,,,0,
483780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.h,anet.h:37:37:ANET_ERR:0,,true,37,37,ANET_ERR,,,0,
483783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.h,anet.h:36:36:ANET_OK:0,,true,36,36,ANET_OK,,,0,
483786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsockopt,,true,,,setsockopt,,,0,
483794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.h,anet.h:42:42:ANET_IP_ONLY:0,,true,42,42,ANET_IP_ONLY,,,0,
483797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getaddrinfo,,true,,,getaddrinfo,,,0,
483804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gai_strerror,,true,,,gai_strerror,,,0,
483808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inet_ntop,,true,,,inet_ntop,,,0,
483815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,freeaddrinfo,,true,,,freeaddrinfo,,,0,
483819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,socket,,true,,,socket,,,0,
483825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.c,anet.c:298:298:ANET_CONNECT_NONBLOCK:0,,true,298,298,ANET_CONNECT_NONBLOCK,,,0,
483828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,bind,,true,,,bind,,,0,
483834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,connect,,true,,,connect,,,0,
483840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.c,anet.c:299:299:ANET_CONNECT_BE_BINDING:0,,true,299,299,ANET_CONNECT_BE_BINDING,,,0,
483843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,listen,,true,,,listen,,,0,
483848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chmod,,true,,,chmod,,,0,
483853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,accept,,true,,,accept,,,0,
483859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohs,,true,,,ntohs,,,0,
483863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getpeername,,true,,,getpeername,,,0,
483869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getsockname,,true,,,getsockname,,,0,
483875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pipe,,true,,,pipe,,,0,
483879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.c,anet.c:53:53:UNUSED:1,,true,53,53,UNUSED,,,0,
483883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stat,,true,,,stat,,,0,
483888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISFIFO,,true,,,S_ISFIFO,,,0,
483892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:94:94:AOF_MANIFEST_KEY_FILE_NAME:0,,true,94,94,AOF_MANIFEST_KEY_FILE_NAME,,,0,
483895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:95:95:AOF_MANIFEST_KEY_FILE_SEQ:0,,true,95,95,AOF_MANIFEST_KEY_FILE_SEQ,,,0,
483898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:96:96:AOF_MANIFEST_KEY_FILE_TYPE:0,,true,96,96,AOF_MANIFEST_KEY_FILE_TYPE,,,0,
483901,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:90:90:MANIFEST_NAME_SUFFIX:0,,true,90,90,MANIFEST_NAME_SUFFIX,,,0,
483904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:91:91:TEMP_FILE_NAME_PREFIX:0,,true,91,91,TEMP_FILE_NAME_PREFIX,,,0,
483907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:255:255:MANIFEST_MAX_LINE:0,,true,255,255,MANIFEST_MAX_LINE,,,0,
483910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,feof,,true,,,feof,,,0,
483914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atoll,,true,,,atoll,,,0,
483918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:88:88:RDB_FORMAT_SUFFIX:0,,true,88,88,RDB_FORMAT_SUFFIX,,,0,
483921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:89:89:AOF_FORMAT_SUFFIX:0,,true,89,89,AOF_FORMAT_SUFFIX,,,0,
483924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,,true,,,<operator>.preIncrement,,,0,
483928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:86:86:BASE_FILE_SUFFIX:0,,true,86,86,BASE_FILE_SUFFIX,,,0,
483931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:87:87:INCR_FILE_SUFFIX:0,,true,87,87,INCR_FILE_SUFFIX,,,0,
483934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:313:313:AOF_ON:0,,true,313,313,AOF_ON,,,0,
483937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:312:312:AOF_OFF:0,,true,312,312,AOF_OFF,,,0,
483940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:314:314:AOF_WAIT_REWRITE:0,,true,314,314,AOF_WAIT_REWRITE,,,0,
483943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:875:875:AOF_REWRITE_LIMITE_THRESHOLD:0,,true,875,875,AOF_REWRITE_LIMITE_THRESHOLD,,,0,
483946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:876:876:AOF_REWRITE_LIMITE_MAX_MINUTES:0,,true,876,876,AOF_REWRITE_LIMITE_MAX_MINUTES,,,0,
483949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1523:1523:CHILD_TYPE_AOF:0,,true,1523,1523,CHILD_TYPE_AOF,,,0,
483952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,kill,,true,,,kill,,,0,
483957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,waitpid,,true,,,waitpid,,,0,
483963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicSet,,true,,,atomicSet,,,0,
483968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicGet,,true,,,atomicGet,,,0,
483973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:528:528:AOF_FSYNC_EVERYSEC:0,,true,528,528,AOF_FSYNC_EVERYSEC,,,0,
483976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:527:527:AOF_FSYNC_ALWAYS:0,,true,527,527,AOF_FSYNC_ALWAYS,,,0,
483979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,usleep,,true,,,usleep,,,0,
483983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,latency.h,latency.h:70:74:latencyStartMonitor:1,,true,70,74,latencyStartMonitor,,,0,
483987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,latency.h,latency.h:78:80:latencyEndMonitor:1,,true,78,80,latencyEndMonitor,,,0,
483991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,latency.h,latency.h:83:86:latencyAddSampleIfNeeded:2,,true,83,86,latencyAddSampleIfNeeded,,,0,
483995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,aof.c,aof.c:1075:1075:AOF_WRITE_LOG_ERROR_RATE:0,,true,1075,1075,AOF_WRITE_LOG_ERROR_RATE,,,0,
483998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ftruncate,,true,,,ftruncate,,,0,
484003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,time,,true,,,time,,,0,
484007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1101:1101:CLIENT_ID_AOF:0,,true,1101,1101,CLIENT_ID_AOF,,,0,
484010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:388:388:CLIENT_DENY_BLOCKING:0,,true,388,388,CLIENT_DENY_BLOCKING,,,0,
484013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:467:467:SLAVE_STATE_WAIT_BGSAVE_START:0,,true,467,467,SLAVE_STATE_WAIT_BGSAVE_START,,,0,
484016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:317:317:AOF_OK:0,,true,317,317,AOF_OK,,,0,
484019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:49:49:redis_stat:0,,true,49,49,redis_stat,,,0,
484022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:320:320:AOF_OPEN_ERR:0,,true,320,320,AOF_OPEN_ERR,,,0,
484025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:318:318:AOF_NOT_EXIST:0,,true,318,318,AOF_NOT_EXIST,,,0,
484028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:48:48:redis_fstat:0,,true,48,48,redis_fstat,,,0,
484031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fstat,,true,,,fstat,,,0,
484036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fileno,,true,,,fileno,,,0,
484040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:319:319:AOF_EMPTY:0,,true,319,319,AOF_EMPTY,,,0,
484043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fread,,true,,,fread,,,0,
484050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fseek,,true,,,fseek,,,0,
484056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:134:134:RDBFLAGS_AOF_PREAMBLE:0,,true,134,134,RDBFLAGS_AOF_PREAMBLE,,,0,
484059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:321:321:AOF_FAILED:0,,true,321,321,AOF_FAILED,,,0,
484062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ftello,,true,,,ftello,,,0,
484066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atoi,,true,,,atoi,,,0,
484070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtol,,true,,,strtol,,,0,
484076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisCommand.proc,,true,,,proc,,,0,
484081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,truncate,,true,,,truncate,,,0,
484086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lseek,,true,,,lseek,,,0,
484092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:322:322:AOF_TRUNCATED:0,,true,322,322,AOF_TRUNCATED,,,0,
484095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:880:880:OBJ_ENCODING_INT:0,,true,880,880,OBJ_ENCODING_INT,,,0,
484098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2780:2780:sdsEncodedObject:1,,true,2780,2780,sdsEncodedObject,,,0,
484102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:498:498:LIST_TAIL:0,,true,498,498,LIST_TAIL,,,0,
484105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:125:125:AOF_REWRITE_ITEMS_PER_CMD:0,,true,125,125,AOF_REWRITE_ITEMS_PER_CMD,,,0,
484108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:890:890:OBJ_ENCODING_LISTPACK:0,,true,890,890,OBJ_ENCODING_LISTPACK,,,0,
484111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:886:886:OBJ_ENCODING_SKIPLIST:0,,true,886,886,OBJ_ENCODING_SKIPLIST,,,0,
484114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:881:881:OBJ_ENCODING_HT:0,,true,881,881,OBJ_ENCODING_HT,,,0,
484117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2428:2428:OBJ_HASH_KEY:0,,true,2428,2428,OBJ_HASH_KEY,,,0,
484120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2429:2429:OBJ_HASH_VALUE:0,,true,2429,2429,OBJ_HASH_VALUE,,,0,
484123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:844:853:moduleInitIOContext:5,,true,844,853,moduleInitIOContext,,,0,
484131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.aof_rewrite,,true,,,aof_rewrite,,,0,
484138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:148:148:dictSize:1,,true,148,148,dictSize,,,0,
484142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:918:923:initStaticStringObject:2,,true,918,923,initStaticStringObject,,,0,
484147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:695:695:OBJ_LIST:0,,true,695,695,OBJ_LIST,,,0,
484150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:696:696:OBJ_SET:0,,true,696,696,OBJ_SET,,,0,
484153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:697:697:OBJ_ZSET:0,,true,697,697,OBJ_ZSET,,,0,
484156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:698:698:OBJ_HASH:0,,true,698,698,OBJ_HASH,,,0,
484159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:712:712:OBJ_STREAM:0,,true,712,712,OBJ_STREAM,,,0,
484162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:711:711:OBJ_MODULE:0,,true,711,711,OBJ_MODULE,,,0,
484165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:182:182:REDIS_AUTOSYNC_BYTES:0,,true,182,182,REDIS_AUTOSYNC_BYTES,,,0,
484168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:480:480:SLAVE_REQ_NONE:0,,true,480,480,SLAVE_REQ_NONE,,,0,
484171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fflush,,true,,,fflush,,,0,
484175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bio.c,bio.c:72:72:BIO_WORKER_NUM:0,,true,72,72,BIO_WORKER_NUM,,,0,
484178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_init,,true,,,pthread_mutex_init,,,0,
484183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_init,,true,,,pthread_cond_init,,,0,
484188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_init,,true,,,pthread_attr_init,,,0,
484192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_getstacksize,,true,,,pthread_attr_getstacksize,,,0,
484197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bio.c,bio.c:116:116:REDIS_THREAD_STACK_SIZE:0,,true,116,116,REDIS_THREAD_STACK_SIZE,,,0,
484200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,,true,,,<operator>.assignmentMultiplication,,,0,
484205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_attr_setstacksize,,true,,,pthread_attr_setstacksize,,,0,
484210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_create,,true,,,pthread_create,,,0,
484217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_lock,,true,,,pthread_mutex_lock,,,0,
484221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_signal,,true,,,pthread_cond_signal,,,0,
484225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_unlock,,true,,,pthread_mutex_unlock,,,0,
484229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigemptyset,,true,,,sigemptyset,,,0,
484233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigaddset,,true,,,sigaddset,,,0,
484238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_sigmask,,true,,,pthread_sigmask,,,0,
484244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_wait,,true,,,pthread_cond_wait,,,0,
484249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.free_fn,,true,,,free_fn,,,0,
484254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_self,,true,,,pthread_self,,,0,
484257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cancel,,true,,,pthread_cancel,,,0,
484261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_join,,true,,,pthread_join,,,0,
484266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentShiftLeft,,true,,,<operators>.assignmentShiftLeft,,,0,
484271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentArithmeticShiftRight,,true,,,<operators>.assignmentArithmeticShiftRight,,,0,
484276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:284:284:BFOVERFLOW_WRAP:0,,true,284,284,BFOVERFLOW_WRAP,,,0,
484279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:285:285:BFOVERFLOW_SAT:0,,true,285,285,BFOVERFLOW_SAT,,,0,
484282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentDivision,,true,,,<operator>.assignmentDivision,,,0,
484287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,printf,,true,,,printf,,,0,
484291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util.h,util.h:51:51:LONG_STR_SIZE:0,,true,51,51,LONG_STR_SIZE,,,0,
484294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:651:651:NOTIFY_STRING:0,,true,651,651,NOTIFY_STRING,,,0,
484297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:398:398:BITOP_AND:0,,true,398,398,BITOP_AND,,,0,
484300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:399:399:BITOP_OR:0,,true,399,399,BITOP_OR,,,0,
484303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:400:400:BITOP_XOR:0,,true,400,400,BITOP_XOR,,,0,
484306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:401:401:BITOP_NOT:0,,true,401,401,BITOP_NOT,,,0,
484309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentXor,,true,,,<operators>.assignmentXor,,,0,
484314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:650:650:NOTIFY_GENERIC:0,,true,650,650,NOTIFY_GENERIC,,,0,
484317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:403:403:BITFIELDOP_GET:0,,true,403,403,BITFIELDOP_GET,,,0,
484320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:404:404:BITFIELDOP_SET:0,,true,404,404,BITFIELDOP_SET,,,0,
484323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:405:405:BITFIELDOP_INCRBY:0,,true,405,405,BITFIELDOP_INCRBY,,,0,
484326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:286:286:BFOVERFLOW_FAIL:0,,true,286,286,BFOVERFLOW_FAIL,,,0,
484329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:1016:1016:BITFIELD_FLAG_READONLY:0,,true,1016,1016,BITFIELD_FLAG_READONLY,,,0,
484332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,bitops.c,bitops.c:1015:1015:BITFIELD_FLAG_NONE:0,,true,1015,1015,BITFIELD_FLAG_NONE,,,0,
484335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:339:339:CLIENT_BLOCKED:0,,true,339,339,CLIENT_BLOCKED,,,0,
484338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:365:365:CLIENT_MODULE:0,,true,365,365,CLIENT_MODULE,,,0,
484341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:342:342:CLIENT_UNBLOCKED:0,,true,342,342,CLIENT_UNBLOCKED,,,0,
484344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:372:372:CLIENT_PENDING_COMMAND:0,,true,372,372,CLIENT_PENDING_COMMAND,,,0,
484347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:341:341:CLIENT_CLOSE_AFTER_REPLY:0,,true,341,341,CLIENT_CLOSE_AFTER_REPLY,,,0,
484350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:671:671:serverAssertWithInfo:3,,true,671,671,serverAssertWithInfo,,,0,
484355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3247:3247:LOOKUP_NOEFFECTS:0,,true,3247,3247,LOOKUP_NOEFFECTS,,,0,
484358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:88:88:REDISMODULE_REPLY_NULL:0,,true,88,88,REDISMODULE_REPLY_NULL,,,0,
484361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,call_reply.c,call_reply.c:35:35:REPLY_FLAG_RESP3:0,,true,35,35,REPLY_FLAG_RESP3,,,0,
484364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:84:84:REDISMODULE_REPLY_STRING:0,,true,84,84,REDISMODULE_REPLY_STRING,,,0,
484367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:85:85:REDISMODULE_REPLY_ERROR:0,,true,85,85,REDISMODULE_REPLY_ERROR,,,0,
484370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:86:86:REDISMODULE_REPLY_INTEGER:0,,true,86,86,REDISMODULE_REPLY_INTEGER,,,0,
484373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:92:92:REDISMODULE_REPLY_DOUBLE:0,,true,92,92,REDISMODULE_REPLY_DOUBLE,,,0,
484376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:94:94:REDISMODULE_REPLY_VERBATIM_STRING:0,,true,94,94,REDISMODULE_REPLY_VERBATIM_STRING,,,0,
484379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:93:93:REDISMODULE_REPLY_BIG_NUMBER:0,,true,93,93,REDISMODULE_REPLY_BIG_NUMBER,,,0,
484382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:91:91:REDISMODULE_REPLY_BOOL:0,,true,91,91,REDISMODULE_REPLY_BOOL,,,0,
484385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,call_reply.c,call_reply.c:34:34:REPLY_FLAG_PARSED:0,,true,34,34,REPLY_FLAG_PARSED,,,0,
484388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:95:95:REDISMODULE_REPLY_ATTRIBUTE:0,,true,95,95,REDISMODULE_REPLY_ATTRIBUTE,,,0,
484391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:87:87:REDISMODULE_REPLY_ARRAY:0,,true,87,87,REDISMODULE_REPLY_ARRAY,,,0,
484394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:90:90:REDISMODULE_REPLY_SET:0,,true,90,90,REDISMODULE_REPLY_SET,,,0,
484397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:89:89:REDISMODULE_REPLY_MAP:0,,true,89,89,REDISMODULE_REPLY_MAP,,,0,
484400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:83:83:REDISMODULE_REPLY_UNKNOWN:0,,true,83,83,REDISMODULE_REPLY_UNKNOWN,,,0,
484403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,call_reply.c,call_reply.c:33:33:REPLY_FLAG_ROOT:0,,true,33,33,REPLY_FLAG_ROOT,,,0,
484406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:96:96:REDISMODULE_REPLY_PROMISE:0,,true,96,96,REDISMODULE_REPLY_PROMISE,,,0,
484409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:162:162:CHILD_COW_DUTY_CYCLE:0,,true,162,162,CHILD_COW_DUTY_CYCLE,,,0,
484412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read,,true,,,read,,,0,
484418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisBufferWrite,,true,,,redisBufferWrite,,,0,
484423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,,true,,,<operator>.preDecrement,,,0,
484427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tolower,,true,,,tolower,,,0,
484431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cli_common.c,cli_common.c:268:268:isHexChar:1,,true,268,268,isHexChar,,,0,
484435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isdigit,,true,,,isdigit,,,0,
484439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cli_common.c,cli_common.c:270:270:decodeHex:2,,true,270,270,decodeHex,,,0,
484444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cli_common.c,cli_common.c:49:49:UNUSED:1,,true,49,49,UNUSED,,,0,
484448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncasecmp,,true,,,strncasecmp,,,0,
484454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isalnum,,true,,,isalnum,,,0,
484458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:11:11:CLUSTER_NAMELEN:0,,true,11,11,CLUSTER_NAMELEN,,,0,
484461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncmp,,true,,,strncmp,,,0,
484467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:8:8:CLUSTER_SLOTS:0,,true,8,8,CLUSTER_SLOTS,,,0,
484470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoull,,true,,,strtoull,,,0,
484476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:97:97:numElements:1,,true,97,97,numElements,,,0,
484480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1.setter,,true,,,setter,,,0,
484487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:12:12:CLUSTER_PORT_INCR:0,,true,12,12,CLUSTER_PORT_INCR,,,0,
484490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:53:53:CLUSTER_NODE_MYSELF:0,,true,53,53,CLUSTER_NODE_MYSELF,,,0,
484493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:49:49:CLUSTER_NODE_MASTER:0,,true,49,49,CLUSTER_NODE_MASTER,,,0,
484496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:50:50:CLUSTER_NODE_SLAVE:0,,true,50,50,CLUSTER_NODE_SLAVE,,,0,
484499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:51:51:CLUSTER_NODE_PFAIL:0,,true,51,51,CLUSTER_NODE_PFAIL,,,0,
484502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:52:52:CLUSTER_NODE_FAIL:0,,true,52,52,CLUSTER_NODE_FAIL,,,0,
484505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:54:54:CLUSTER_NODE_HANDSHAKE:0,,true,54,54,CLUSTER_NODE_HANDSHAKE,,,0,
484508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:55:55:CLUSTER_NODE_NOADDR:0,,true,55,55,CLUSTER_NODE_NOADDR,,,0,
484511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:58:58:CLUSTER_NODE_NOFAILOVER:0,,true,58,58,CLUSTER_NODE_NOFAILOVER,,,0,
484514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_2.isPresent,,true,,,isPresent,,,0,
484519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_3.isPresent,,true,,,isPresent,,,0,
484524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:62:62:nodeIsSlave:1,,true,62,62,nodeIsSlave,,,0,
484528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:81:81:CLUSTER_TODO_SAVE_CONFIG:0,,true,81,81,CLUSTER_TODO_SAVE_CONFIG,,,0,
484531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:82:82:CLUSTER_TODO_FSYNC_CONFIG:0,,true,82,82,CLUSTER_TODO_FSYNC_CONFIG,,,0,
484534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,flock,,true,,,flock,,,0,
484539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:80:80:CLUSTER_TODO_UPDATE_STATE:0,,true,80,80,CLUSTER_TODO_UPDATE_STATE,,,0,
484542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:135:135:NET_IP_STR_LEN:0,,true,135,135,NET_IP_STR_LEN,,,0,
484545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:10:10:CLUSTER_FAIL:0,,true,10,10,CLUSTER_FAIL,,,0,
484548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:71:71:CLUSTER_CANT_FAILOVER_NONE:0,,true,71,71,CLUSTER_CANT_FAILOVER_NONE,,,0,
484551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:102:102:CLUSTERMSG_TYPE_COUNT:0,,true,102,102,CLUSTERMSG_TYPE_COUNT,,,0,
484554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConnectionType.serverLog(LL_WARNING, ""Missing connection type %s, but it is required for the Cluster bus."", connTypeOfCluster()->get_type(NULL))",,true,,,"serverLog(LL_WARNING, ""Missing connection type %s, but it is required for the Cluster bus."", connTypeOfCluster()->get_type(NULL))",,,0,
484559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3265:3265:EMPTYDB_NO_FLAGS:0,,true,3265,3265,EMPTYDB_NO_FLAGS,,,0,
484562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:133:133:RCVBUF_INIT_LEN:0,,true,133,133,RCVBUF_INIT_LEN,,,0,
484565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:1262:1262:MAX_CLUSTER_ACCEPTS_PER_CALL:0,,true,1262,1262,MAX_CLUSTER_ACCEPTS_PER_CALL,,,0,
484568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:537:537:TLS_CLIENT_AUTH_YES:0,,true,537,537,TLS_CLIENT_AUTH_YES,,,0,
484571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:520:520:UNUSED:1,,true,520,520,UNUSED,,,0,
484575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:16:16:CLUSTER_FAIL_REPORT_VALIDITY_MULT:0,,true,16,16,CLUSTER_FAIL_REPORT_VALIDITY_MULT,,,0,
484578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:57:57:CLUSTER_NODE_MIGRATE_TO:0,,true,57,57,CLUSTER_NODE_MIGRATE_TO,,,0,
484581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:67:67:nodeFailed:1,,true,67,67,nodeFailed,,,0,
484585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:61:61:nodeIsMaster:1,,true,61,61,nodeIsMaster,,,0,
484589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:44:44:DICT_OK:0,,true,44,44,DICT_OK,,,0,
484592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:1861:1861:CLUSTER_BLACKLIST_TTL:0,,true,1861,1861,CLUSTER_BLACKLIST_TTL,,,0,
484595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:66:66:nodeTimedOut:1,,true,66,66,nodeTimedOut,,,0,
484599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:17:17:CLUSTER_FAIL_UNDO_TIME_MULT:0,,true,17,17,CLUSTER_FAIL_UNDO_TIME_MULT,,,0,
484602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:63:63:nodeInHandshake:1,,true,63,63,nodeInHandshake,,,0,
484606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,inet_pton,,true,,,inet_pton,,,0,
484612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:56:56:CLUSTER_NODE_MEET:0,,true,56,56,CLUSTER_NODE_MEET,,,0,
484615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:506:506:LL_DEBUG:0,,true,506,506,LL_DEBUG,,,0,
484618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ntohl,,true,,,ntohl,,,0,
484622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:129:131:isSlotUnclaimed:1,,true,129,131,isSlotUnclaimed,,,0,
484626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:109:109:CLUSTER_MODULE_FLAG_NO_REDIRECTION:0,,true,109,109,CLUSTER_MODULE_FLAG_NO_REDIRECTION,,,0,
484629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:276:276:EIGHT_BYTE_ALIGN:1,,true,276,276,EIGHT_BYTE_ALIGN,,,0,
484633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htons,,true,,,htons,,,0,
484637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,htonl,,true,,,htonl,,,0,
484641,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:70:70:htonu64:1,,true,70,70,htonu64,,,0,
484645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:409:409:CLUSTERMSG_FLAG0_EXT_DATA:0,,true,409,409,CLUSTERMSG_FLAG0_EXT_DATA,,,0,
484648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:71:71:ntohu64:1,,true,71,71,ntohu64,,,0,
484652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:341:341:CLUSTER_PROTO_VER:0,,true,341,341,CLUSTER_PROTO_VER,,,0,
484655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:91:91:CLUSTERMSG_TYPE_PING:0,,true,91,91,CLUSTERMSG_TYPE_PING,,,0,
484658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:92:92:CLUSTERMSG_TYPE_PONG:0,,true,92,92,CLUSTERMSG_TYPE_PONG,,,0,
484661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:93:93:CLUSTERMSG_TYPE_MEET:0,,true,93,93,CLUSTERMSG_TYPE_MEET,,,0,
484664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:94:94:CLUSTERMSG_TYPE_FAIL:0,,true,94,94,CLUSTERMSG_TYPE_FAIL,,,0,
484667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:95:95:CLUSTERMSG_TYPE_PUBLISH:0,,true,95,95,CLUSTERMSG_TYPE_PUBLISH,,,0,
484670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:101:101:CLUSTERMSG_TYPE_PUBLISHSHARD:0,,true,101,101,CLUSTERMSG_TYPE_PUBLISHSHARD,,,0,
484673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:96:96:CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST:0,,true,96,96,CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST,,,0,
484676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:97:97:CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK:0,,true,97,97,CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK,,,0,
484679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:99:99:CLUSTERMSG_TYPE_MFSTART:0,,true,99,99,CLUSTERMSG_TYPE_MFSTART,,,0,
484682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:98:98:CLUSTERMSG_TYPE_UPDATE:0,,true,98,98,CLUSTERMSG_TYPE_UPDATE,,,0,
484685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:100:100:CLUSTERMSG_TYPE_MODULE:0,,true,100,100,CLUSTERMSG_TYPE_MODULE,,,0,
484688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:406:406:CLUSTERMSG_FLAG0_PAUSED:0,,true,406,406,CLUSTERMSG_FLAG0_PAUSED,,,0,
484691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:83:83:CLUSTER_TODO_HANDLE_MANUALFAILOVER:0,,true,83,83,CLUSTER_TODO_HANDLE_MANUALFAILOVER,,,0,
484694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:59:59:CLUSTER_NODE_NULL_NAME:0,,true,59,59,CLUSTER_NODE_NULL_NAME,,,0,
484697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:79:79:CLUSTER_TODO_HANDLE_FAILOVER:0,,true,79,79,CLUSTER_TODO_HANDLE_FAILOVER,,,0,
484700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:18:18:CLUSTER_MF_TIMEOUT:0,,true,18,18,CLUSTER_MF_TIMEOUT,,,0,
484703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:19:19:CLUSTER_MF_PAUSE_MULT:0,,true,19,19,CLUSTER_MF_PAUSE_MULT,,,0,
484706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:612:615:PAUSE_ACTIONS_CLIENT_WRITE_SET:0,,true,612,615,PAUSE_ACTIONS_CLIENT_WRITE_SET,,,0,
484709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:119:119:NET_MAX_WRITES_PER_EVENT:0,,true,119,119,NET_MAX_WRITES_PER_EVENT,,,0,
484712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:402:402:CLUSTERMSG_MIN_LEN:0,,true,402,402,CLUSTERMSG_MIN_LEN,,,0,
484715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:134:134:RCVBUF_MAX_PREALLOC:0,,true,134,134,RCVBUF_MAX_PREALLOC,,,0,
484718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,floor,,true,,,floor,,,0,
484722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:3684:3684:CLUSTER_BROADCAST_LOCAL_SLAVES:0,,true,3684,3684,CLUSTER_BROADCAST_LOCAL_SLAVES,,,0,
484725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:407:407:CLUSTERMSG_FLAG0_FORCEACK:0,,true,407,407,CLUSTERMSG_FLAG0_FORCEACK,,,0,
484728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:68:68:nodeCantFailover:1,,true,68,68,nodeCantFailover,,,0,
484732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:76:76:CLUSTER_CANT_FAILOVER_RELOG_PERIOD:0,,true,76,76,CLUSTER_CANT_FAILOVER_RELOG_PERIOD,,,0,
484735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:72:72:CLUSTER_CANT_FAILOVER_DATA_AGE:0,,true,72,72,CLUSTER_CANT_FAILOVER_DATA_AGE,,,0,
484738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:73:73:CLUSTER_CANT_FAILOVER_WAITING_DELAY:0,,true,73,73,CLUSTER_CANT_FAILOVER_WAITING_DELAY,,,0,
484741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:74:74:CLUSTER_CANT_FAILOVER_EXPIRED:0,,true,74,74,CLUSTER_CANT_FAILOVER_EXPIRED,,,0,
484744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:75:75:CLUSTER_CANT_FAILOVER_WAITING_VOTES:0,,true,75,75,CLUSTER_CANT_FAILOVER_WAITING_VOTES,,,0,
484747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:3683:3683:CLUSTER_BROADCAST_ALL:0,,true,3683,3683,CLUSTER_BROADCAST_ALL,,,0,
484750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,random,,true,,,random,,,0,
484753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:9:9:CLUSTER_OK:0,,true,9,9,CLUSTER_OK,,,0,
484756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:20:20:CLUSTER_SLAVE_MIGRATION_DELAY:0,,true,20,20,CLUSTER_SLAVE_MIGRATION_DELAY,,,0,
484759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:108:108:CLUSTER_MODULE_FLAG_NO_FAILOVER:0,,true,108,108,CLUSTER_MODULE_FLAG_NO_FAILOVER,,,0,
484762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:64:64:nodeHasAddr:1,,true,64,64,nodeHasAddr,,,0,
484766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:4969:4969:CLUSTER_WRITABLE_DELAY:0,,true,4969,4969,CLUSTER_WRITABLE_DELAY,,,0,
484769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:4967:4967:CLUSTER_MAX_REJOIN_DELAY:0,,true,4967,4967,CLUSTER_MAX_REJOIN_DELAY,,,0,
484772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:4968:4968:CLUSTER_MIN_REJOIN_DELAY:0,,true,4968,4968,CLUSTER_MIN_REJOIN_DELAY,,,0,
484775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_4.isPresent,,true,,,isPresent,,,0,
484780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_5.getter,,true,,,getter,,,0,
484786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:124:125:dictEntryNextInSlot:1,,true,124,125,dictEntryNextInSlot,,,0,
484790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:41:41:RDB_VERSION:0,,true,41,41,RDB_VERSION,,,0,
484793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:58:58:memrev64ifbe:1,,true,58,58,memrev64ifbe,,,0,
484797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:6682:6682:MIGRATE_SOCKET_CACHE_ITEMS:0,,true,6682,6682,MIGRATE_SOCKET_CACHE_ITEMS,,,0,
484800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:6683:6683:MIGRATE_SOCKET_CACHE_TTL:0,,true,6683,6683,MIGRATE_SOCKET_CACHE_TTL,,,0,
484803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:345:345:CLIENT_ASKING:0,,true,345,345,CLIENT_ASKING,,,0,
484806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:353:353:CLIENT_READONLY:0,,true,353,353,CLIENT_READONLY,,,0,
484809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:23:23:CLUSTER_REDIR_NONE:0,,true,23,23,CLUSTER_REDIR_NONE,,,0,
484812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:29:29:CLUSTER_REDIR_DOWN_UNBOUND:0,,true,29,29,CLUSTER_REDIR_DOWN_UNBOUND,,,0,
484815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:24:24:CLUSTER_REDIR_CROSS_SLOT:0,,true,24,24,CLUSTER_REDIR_CROSS_SLOT,,,0,
484818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3242:3242:LOOKUP_NOTOUCH:0,,true,3242,3242,LOOKUP_NOTOUCH,,,0,
484821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3244:3244:LOOKUP_NOSTATS:0,,true,3244,3244,LOOKUP_NOSTATS,,,0,
484824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3243:3243:LOOKUP_NONOTIFY:0,,true,3243,3243,LOOKUP_NONOTIFY,,,0,
484827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3246:3246:LOOKUP_NOEXPIRE:0,,true,3246,3246,LOOKUP_NOEXPIRE,,,0,
484830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:28:28:CLUSTER_REDIR_DOWN_STATE:0,,true,28,28,CLUSTER_REDIR_DOWN_STATE,,,0,
484833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:206:206:CMD_WRITE:0,,true,206,206,CMD_WRITE,,,0,
484836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:30:30:CLUSTER_REDIR_DOWN_RO_STATE:0,,true,30,30,CLUSTER_REDIR_DOWN_RO_STATE,,,0,
484839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:25:25:CLUSTER_REDIR_UNSTABLE:0,,true,25,25,CLUSTER_REDIR_UNSTABLE,,,0,
484842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:26:26:CLUSTER_REDIR_ASK:0,,true,26,26,CLUSTER_REDIR_ASK,,,0,
484845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:218:218:CMD_ASKING:0,,true,218,218,CMD_ASKING,,,0,
484848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:27:27:CLUSTER_REDIR_MOVED:0,,true,27,27,CLUSTER_REDIR_MOVED,,,0,
484851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.c,cluster.c:126:127:dictEntryPrevInSlot:1,,true,126,127,dictEntryPrevInSlot,,,0,
484855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:569:569:MAXMEMORY_VOLATILE_LRU:0,,true,569,569,MAXMEMORY_VOLATILE_LRU,,,0,
484858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:570:570:MAXMEMORY_VOLATILE_LFU:0,,true,570,570,MAXMEMORY_VOLATILE_LFU,,,0,
484861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:572:572:MAXMEMORY_VOLATILE_RANDOM:0,,true,572,572,MAXMEMORY_VOLATILE_RANDOM,,,0,
484864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:571:571:MAXMEMORY_VOLATILE_TTL:0,,true,571,571,MAXMEMORY_VOLATILE_TTL,,,0,
484867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:573:573:MAXMEMORY_ALLKEYS_LRU:0,,true,573,573,MAXMEMORY_ALLKEYS_LRU,,,0,
484870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:574:574:MAXMEMORY_ALLKEYS_LFU:0,,true,574,574,MAXMEMORY_ALLKEYS_LFU,,,0,
484873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:575:575:MAXMEMORY_ALLKEYS_RANDOM:0,,true,575,575,MAXMEMORY_ALLKEYS_RANDOM,,,0,
484876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:576:576:MAXMEMORY_NO_EVICTION:0,,true,576,576,MAXMEMORY_NO_EVICTION,,,0,
484879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:507:507:LL_VERBOSE:0,,true,507,507,LL_VERBOSE,,,0,
484882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:508:508:LL_NOTICE:0,,true,508,508,LL_NOTICE,,,0,
484885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:509:509:LL_WARNING:0,,true,509,509,LL_WARNING,,,0,
484888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:510:510:LL_NOTHING:0,,true,510,510,LL_NOTHING,,,0,
484891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:517:517:SUPERVISED_UPSTART:0,,true,517,517,SUPERVISED_UPSTART,,,0,
484894,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:516:516:SUPERVISED_SYSTEMD:0,,true,516,516,SUPERVISED_SYSTEMD,,,0,
484897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:515:515:SUPERVISED_AUTODETECT:0,,true,515,515,SUPERVISED_AUTODETECT,,,0,
484900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:514:514:SUPERVISED_NONE:0,,true,514,514,SUPERVISED_NONE,,,0,
484903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:526:526:AOF_FSYNC_NO:0,,true,526,526,AOF_FSYNC_NO,,,0,
484906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:584:584:SHUTDOWN_SAVE:0,,true,584,584,SHUTDOWN_SAVE,,,0,
484909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:586:586:SHUTDOWN_NOSAVE:0,,true,586,586,SHUTDOWN_NOSAVE,,,0,
484912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:587:587:SHUTDOWN_NOW:0,,true,587,587,SHUTDOWN_NOW,,,0,
484915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:588:588:SHUTDOWN_FORCE:0,,true,588,588,SHUTDOWN_FORCE,,,0,
484918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:531:531:REPL_DISKLESS_LOAD_DISABLED:0,,true,531,531,REPL_DISKLESS_LOAD_DISABLED,,,0,
484921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:532:532:REPL_DISKLESS_LOAD_WHEN_DB_EMPTY:0,,true,532,532,REPL_DISKLESS_LOAD_WHEN_DB_EMPTY,,,0,
484924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:533:533:REPL_DISKLESS_LOAD_SWAPDB:0,,true,533,533,REPL_DISKLESS_LOAD_SWAPDB,,,0,
484927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:536:536:TLS_CLIENT_AUTH_NO:0,,true,536,536,TLS_CLIENT_AUTH_NO,,,0,
484930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:538:538:TLS_CLIENT_AUTH_OPTIONAL:0,,true,538,538,TLS_CLIENT_AUTH_OPTIONAL,,,0,
484933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:556:556:OOM_SCORE_ADJ_NO:0,,true,556,556,OOM_SCORE_ADJ_NO,,,0,
484936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:557:557:OOM_SCORE_RELATIVE:0,,true,557,557,OOM_SCORE_RELATIVE,,,0,
484939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:558:558:OOM_SCORE_ADJ_ABSOLUTE:0,,true,558,558,OOM_SCORE_ADJ_ABSOLUTE,,,0,
484942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:541:541:SANITIZE_DUMP_NO:0,,true,541,541,SANITIZE_DUMP_NO,,,0,
484945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:542:542:SANITIZE_DUMP_YES:0,,true,542,542,SANITIZE_DUMP_YES,,,0,
484948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:543:543:SANITIZE_DUMP_CLIENTS:0,,true,543,543,SANITIZE_DUMP_CLIENTS,,,0,
484951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:546:546:PROTECTED_ACTION_ALLOWED_NO:0,,true,546,546,PROTECTED_ACTION_ALLOWED_NO,,,0,
484954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:547:547:PROTECTED_ACTION_ALLOWED_YES:0,,true,547,547,PROTECTED_ACTION_ALLOWED_YES,,,0,
484957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:548:548:PROTECTED_ACTION_ALLOWED_LOCAL:0,,true,548,548,PROTECTED_ACTION_ALLOWED_LOCAL,,,0,
484960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:429:429:CLIENT_TYPE_MASTER:0,,true,429,429,CLIENT_TYPE_MASTER,,,0,
484963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoll,,true,,,strtoll,,,0,
484969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:431:431:CLIENT_TYPE_OBUF_COUNT:0,,true,431,431,CLIENT_TYPE_OBUF_COUNT,,,0,
484972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3158:3158:MULTI_ARG_CONFIG:0,,true,3158,3158,MULTI_ARG_CONFIG,,,0,
484975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:115:115:CONFIG_MIN_HZ:0,,true,115,115,CONFIG_MIN_HZ,,,0,
484978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:116:116:CONFIG_MAX_HZ:0,,true,116,116,CONFIG_MAX_HZ,,,0,
484981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,version.h,version.h:1:1:REDIS_VERSION:0,,true,1,1,REDIS_VERSION,,,0,
484984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,glob,,true,,,glob,,,0,
484991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.c,config.c:654:654:CONFIG_READ_LEN:0,,true,654,654,CONFIG_READ_LEN,,,0,
484994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,globfree,,true,,,globfree,,,0,
484998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3163:3163:MODULE_CONFIG:0,,true,3163,3163,MODULE_CONFIG,,,0,
485001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,apply_fns[i],,true,,,apply_fns[i],,,0,
485006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3156:3156:SENSITIVE_CONFIG:0,,true,3156,3156,SENSITIVE_CONFIG,,,0,
485009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3155:3155:IMMUTABLE_CONFIG:0,,true,3155,3155,IMMUTABLE_CONFIG,,,0,
485012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3160:3160:PROTECTED_CONFIG:0,,true,3160,3160,PROTECTED_CONFIG,,,0,
485015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3161:3161:DENY_LOADING_CONFIG:0,,true,3161,3161,DENY_LOADING_CONFIG,,,0,
485018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:499:499:REDISMODULE_EVENT_CONFIG:0,,true,499,499,REDISMODULE_EVENT_CONFIG,,,0,
485021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:654:654:REDISMODULE_SUBEVENT_CONFIG_CHANGE:0,,true,654,654,REDISMODULE_SUBEVENT_CONFIG_CHANGE,,,0,
485024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strpbrk,,true,,,strpbrk,,,0,
485029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3159:3159:HIDDEN_CONFIG:0,,true,3159,3159,HIDDEN_CONFIG,,,0,
485032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.c,config.c:1022:1022:REDIS_CONFIG_REWRITE_SIGNATURE:0,,true,1022,1022,REDIS_CONFIG_REWRITE_SIGNATURE,,,0,
485035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3162:3162:ALIAS_CONFIG:0,,true,3162,3162,ALIAS_CONFIG,,,0,
485038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getcwd,,true,,,getcwd,,,0,
485043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:196:196:CONFIG_OOM_COUNT:0,,true,196,196,CONFIG_OOM_COUNT,,,0,
485046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:132:132:CONFIG_DEFAULT_BINDADDR_COUNT:0,,true,132,132,CONFIG_DEFAULT_BINDADDR_COUNT,,,0,
485049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3157:3157:DEBUG_CONFIG:0,,true,3157,3157,DEBUG_CONFIG,,,0,
485052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mkstemp,,true,,,mkstemp,,,0,
485056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fchmod,,true,,,fchmod,,,0,
485061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.c,config.c:1794:1794:LOADBUF_SIZE:0,,true,1794,1794,LOADBUF_SIZE,,,0,
485064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3164:3164:VOLATILE_CONFIG:0,,true,3164,3164,VOLATILE_CONFIG,,,0,
485067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3172:3172:OCTAL_CONFIG:0,,true,3172,3172,OCTAL_CONFIG,,,0,
485070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3171:3171:PERCENT_CONFIG:0,,true,3171,3171,PERCENT_CONFIG,,,0,
485073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3170:3170:MEMORY_CONFIG:0,,true,3170,3170,MEMORY_CONFIG,,,0,
485076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.c,config.c:2063:2085:GET_NUMERIC_TYPE:1,,true,2063,2085,GET_NUMERIC_TYPE,,,0,
485080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:134:134:NET_HOST_STR_LEN:0,,true,134,134,NET_HOST_STR_LEN,,,0,
485083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setlocale,,true,,,setlocale,,,0,
485088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:61:61:CONN_TYPE_SOCKET:0,,true,61,61,CONN_TYPE_SOCKET,,,0,
485091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:190:190:CONFIG_FDSET_INCR:0,,true,190,190,CONFIG_FDSET_INCR,,,0,
485094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:63:63:CONN_TYPE_TLS:0,,true,63,63,CONN_TYPE_TLS,,,0,
485097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,chdir,,true,,,chdir,,,0,
485101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:194:194:CONFIG_OOM_REPLICA:0,,true,194,194,CONFIG_OOM_REPLICA,,,0,
485104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:193:193:CONFIG_OOM_MASTER:0,,true,193,193,CONFIG_OOM_MASTER,,,0,
485107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:195:195:CONFIG_OOM_BGCHILD:0,,true,195,195,CONFIG_OOM_BGCHILD,,,0,
485110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:138:138:CONFIG_BINDADDR_MAX:0,,true,138,138,CONFIG_BINDADDR_MAX,,,0,
485113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:64:64:CONN_TYPE_MAX:0,,true,64,64,CONN_TYPE_MAX,,,0,
485116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:62:62:CONN_TYPE_UNIX:0,,true,62,62,CONN_TYPE_UNIX,,,0,
485119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:128:128:CONFIG_BINDADDR_MAX:0,,true,128,128,CONFIG_BINDADDR_MAX,,,0,
485122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,handler,,true,,,handler,,,0,
485126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:58:58:CONN_FLAG_CLOSE_SCHEDULED:0,,true,58,58,CONN_FLAG_CLOSE_SCHEDULED,,,0,
485129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,crc64.c,crc64.c:33:33:POLY:0,,true,33,33,POLY,,,0,
485132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UINT64_C,,true,,,UINT64_C,,,0,
485136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crcfn,,true,,,crcfn,,,0,
485142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3245:3245:LOOKUP_WRITE:0,,true,3245,3245,LOOKUP_WRITE,,,0,
485145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,db.c,db.c:45:45:EXPIRE_FORCE_DELETE_EXPIRED:0,,true,45,45,EXPIRE_FORCE_DELETE_EXPIRED,,,0,
485148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,db.c,db.c:46:46:EXPIRE_AVOID_DELETE_EXPIRED:0,,true,46,46,EXPIRE_AVOID_DELETE_EXPIRED,,,0,
485151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:397:397:CLIENT_NO_TOUCH:0,,true,397,397,CLIENT_NO_TOUCH,,,0,
485154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:564:564:MAXMEMORY_FLAG_LFU:0,,true,564,564,MAXMEMORY_FLAG_LFU,,,0,
485157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:659:659:NOTIFY_KEY_MISS:0,,true,659,659,NOTIFY_KEY_MISS,,,0,
485160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3241:3241:LOOKUP_NONE:0,,true,3241,3241,LOOKUP_NONE,,,0,
485163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:662:662:NOTIFY_NEW:0,,true,662,662,NOTIFY_NEW,,,0,
485166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:303:303:DB_FLAG_KEY_OVERWRITE:0,,true,303,303,DB_FLAG_KEY_OVERWRITE,,,0,
485169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3255:3255:SETKEY_ALREADY_EXIST:0,,true,3255,3255,SETKEY_ALREADY_EXIST,,,0,
485172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3257:3257:SETKEY_ADD_OR_UPDATE:0,,true,3257,3257,SETKEY_ADD_OR_UPDATE,,,0,
485175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3256:3256:SETKEY_DOESNT_EXIST:0,,true,3256,3256,SETKEY_DOESNT_EXIST,,,0,
485178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3253:3253:SETKEY_KEEPTTL:0,,true,3253,3253,SETKEY_KEEPTTL,,,0,
485181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3254:3254:SETKEY_NO_SIGNAL:0,,true,3254,3254,SETKEY_NO_SIGNAL,,,0,
485184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:300:300:DB_FLAG_KEY_DELETED:0,,true,300,300,DB_FLAG_KEY_DELETED,,,0,
485187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:879:879:OBJ_ENCODING_RAW:0,,true,879,879,OBJ_ENCODING_RAW,,,0,
485190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3266:3266:EMPTYDB_ASYNC:0,,true,3266,3266,EMPTYDB_ASYNC,,,0,
485193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3267:3267:EMPTYDB_NOFUNCTIONS:0,,true,3267,3267,EMPTYDB_NOFUNCTIONS,,,0,
485196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:743:743:REDISMODULE_FLUSHINFO_VERSION:0,,true,743,743,REDISMODULE_FLUSHINFO_VERSION,,,0,
485199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:485:485:REDISMODULE_EVENT_FLUSHDB:0,,true,485,485,REDISMODULE_EVENT_FLUSHDB,,,0,
485202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:646:646:REDISMODULE_SUBEVENT_FLUSHDB_START:0,,true,646,646,REDISMODULE_SUBEVENT_FLUSHDB_START,,,0,
485205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:647:647:REDISMODULE_SUBEVENT_FLUSHDB_END:0,,true,647,647,REDISMODULE_SUBEVENT_FLUSHDB_END,,,0,
485208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1522:1522:CHILD_TYPE_RDB:0,,true,1522,1522,CHILD_TYPE_RDB,,,0,
485211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:133:133:RDBFLAGS_NONE:0,,true,133,133,RDBFLAGS_NONE,,,0,
485214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:602:602:PROPAGATE_REPL:0,,true,602,602,PROPAGATE_REPL,,,0,
485217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:601:601:PROPAGATE_AOF:0,,true,601,601,PROPAGATE_AOF,,,0,
485220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:346:346:CLIENT_CLOSE_ASAP:0,,true,346,346,CLIENT_CLOSE_ASAP,,,0,
485223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:719:719:REDISMODULE_TYPE_SIGN:1,,true,719,719,REDISMODULE_TYPE_SIGN,,,0,
485227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint64_t,,true,,,uint64_t,,,0,
485231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtoul,,true,,,strtoul,,,0,
485237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:713:713:OBJ_TYPE_MAX:0,,true,713,713,OBJ_TYPE_MAX,,,0,
485240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:583:583:SHUTDOWN_NOFLAGS:0,,true,583,583,SHUTDOWN_NOFLAGS,,,0,
485243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:798:798:REDISMODULE_SWAPDBINFO_VERSION:0,,true,798,798,REDISMODULE_SWAPDBINFO_VERSION,,,0,
485246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:494:494:REDISMODULE_EVENT_SWAPDB:0,,true,494,494,REDISMODULE_EVENT_SWAPDB,,,0,
485249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:336:336:CLIENT_MASTER:0,,true,336,336,CLIENT_MASTER,,,0,
485252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:301:301:DB_FLAG_KEY_EXPIRED:0,,true,301,301,DB_FLAG_KEY_EXPIRED,,,0,
485255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:656:656:NOTIFY_EXPIRED:0,,true,656,656,NOTIFY_EXPIRED,,,0,
485258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:607:607:PAUSE_ACTION_EXPIRE:0,,true,607,607,PAUSE_ACTION_EXPIRE,,,0,
485261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:897:897:OBJ_STATIC_REFCOUNT:0,,true,897,897,OBJ_STATIC_REFCOUNT,,,0,
485264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:287:287:CMD_KEY_NOT_KEY:0,,true,287,287,CMD_KEY_NOT_KEY,,,0,
485267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3291:3291:GET_KEYSPEC_INCLUDE_NOT_KEYS:0,,true,3291,3291,GET_KEYSPEC_INCLUDE_NOT_KEYS,,,0,
485270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:290:290:CMD_KEY_INCOMPLETE:0,,true,290,290,CMD_KEY_INCOMPLETE,,,0,
485273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3292:3292:GET_KEYSPEC_RETURN_PARTIAL:0,,true,3292,3292,GET_KEYSPEC_RETURN_PARTIAL,,,0,
485276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:292:292:CMD_KEY_VARIABLE_FLAGS:0,,true,292,292,CMD_KEY_VARIABLE_FLAGS,,,0,
485279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:226:226:CMD_MODULE_GETKEYS:0,,true,226,226,CMD_MODULE_GETKEYS,,,0,
485282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisCommand.getkeys_proc,,true,,,getkeys_proc,,,0,
485290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:308:308:CMD_CHANNEL_UNSUBSCRIBE:0,,true,308,308,CMD_CHANNEL_UNSUBSCRIBE,,,0,
485293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:233:233:CMD_MODULE_GETCHANNELS:0,,true,233,233,CMD_MODULE_GETCHANNELS,,,0,
485296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:265:265:CMD_KEY_RO:0,,true,265,265,CMD_KEY_RO,,,0,
485299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:269:269:CMD_KEY_OW:0,,true,269,269,CMD_KEY_OW,,,0,
485302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:267:267:CMD_KEY_RW:0,,true,267,267,CMD_KEY_RW,,,0,
485305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fpconv_dtoa,,true,,,fpconv_dtoa,,,0,
485310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:868:871:moduleInitDigestContext:1,,true,868,871,moduleInitDigestContext,,,0,
485314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.digest,,true,,,digest,,,0,
485320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mmap,,true,,,mmap,,,0,
485329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3087:3087:RESTART_SERVER_GRACEFULLY:0,,true,3087,3087,RESTART_SERVER_GRACEFULLY,,,0,
485332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3088:3088:RESTART_SERVER_CONFIG_REWRITE:0,,true,3088,3088,RESTART_SERVER_CONFIG_REWRITE,,,0,
485335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3086:3086:RESTART_SERVER_NONE:0,,true,3086,3086,RESTART_SERVER_NONE,,,0,
485338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:136:136:RDBFLAGS_ALLOW_DUP:0,,true,136,136,RDBFLAGS_ALLOW_DUP,,,0,
485341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:325:325:RDB_OK:0,,true,325,325,RDB_OK,,,0,
485344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:888:888:OBJ_ENCODING_QUICKLIST:0,,true,888,888,OBJ_ENCODING_QUICKLIST,,,0,
485347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:398:398:CLIENT_PUSHING:0,,true,398,398,CLIENT_PUSHING,,,0,
485350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtod,,true,,,strtod,,,0,
485355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nanosleep,,true,,,nanosleep,,,0,
485360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:146:146:CLIENT_MEM_USAGE_BUCKETS:0,,true,146,146,CLIENT_MEM_USAGE_BUCKETS,,,0,
485363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:144:144:CLIENT_MEM_USAGE_BUCKET_MIN_LOG:0,,true,144,144,CLIENT_MEM_USAGE_BUCKET_MIN_LOG,,,0,
485366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:184:184:REPLY_BUFFER_DEFAULT_PEAK_RESET_TIME:0,,true,184,184,REPLY_BUFFER_DEFAULT_PEAK_RESET_TIME,,,0,
485369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:511:511:LL_RAW:0,,true,511,511,LL_RAW,,,0,
485372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dladdr,,true,,,dladdr,,,0,
485377,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sysconf,,true,,,sysconf,,,0,
485381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_exit,,true,,,_exit,,,0,
485385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sigaction,,true,,,sigaction,,,0,
485391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setitimer,,true,,,setitimer,,,0,
485397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rand,,true,,,rand,,,0,
485400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.c,dict.c:123:123:ENTRY_PTR_MASK:0,,true,123,123,ENTRY_PTR_MASK,,,0,
485403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.c,dict.c:124:124:ENTRY_PTR_NORMAL:0,,true,124,124,ENTRY_PTR_NORMAL,,,0,
485406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.c,dict.c:125:125:ENTRY_PTR_NO_VALUE:0,,true,125,125,ENTRY_PTR_NO_VALUE,,,0,
485409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redisassert.h,redisassert.h:43:43:assert:1,,true,43,43,assert,,,0,
485413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:149:149:dictIsRehashing:1,,true,149,149,dictIsRehashing,,,0,
485417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:45:45:DICT_ERR:0,,true,45,45,DICT_ERR,,,0,
485420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:124:124:DICT_HT_INITIAL_SIZE:0,,true,124,124,DICT_HT_INITIAL_SIZE,,,0,
485423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:81:81:DICTHT_SIZE:1,,true,81,81,DICTHT_SIZE,,,0,
485427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:146:146:dictHashKey:2,,true,146,146,dictHashKey,,,0,
485432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"dictType.dictHashKey(d, key)",,true,,,"dictHashKey(d, key)",,,0,
485437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:82:82:DICTHT_SIZE_MASK:1,,true,82,82,DICTHT_SIZE_MASK,,,0,
485441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gettimeofday,,true,,,gettimeofday,,,0,
485446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:141:142:dictEntryMetadataSize:1,,true,141,142,dictEntryMetadataSize,,,0,
485450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dictType.dictEntryMetadataSize(d),,true,,,dictEntryMetadataSize(d),,,0,
485455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:136:139:dictCompareKeys:3,,true,136,139,dictCompareKeys,,,0,
485461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"dictType.dictCompareKeys(d, key, he_key)",,true,,,"dictCompareKeys(d, key, he_key)",,,0,
485468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:132:134:dictFreeKey:2,,true,132,134,dictFreeKey,,,0,
485473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"dictType.dictFreeKey(d, he)",,true,,,"dictFreeKey(d, he)",,,0,
485479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:127:130:dictFreeVal:2,,true,127,130,dictFreeVal,,,0,
485484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"dictType.dictFreeVal(d, he)",,true,,,"dictFreeVal(d, he)",,,0,
485490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,callback,,true,,,callback,,,0,
485494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"dictType.dictCompareKeys(d, key, de_key)",,true,,,"dictCompareKeys(d, key, de_key)",,,0,
485501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:150:150:dictPauseRehashing:1,,true,150,150,dictPauseRehashing,,,0,
485505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:151:151:dictResumeRehashing:1,,true,151,151,dictResumeRehashing,,,0,
485509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:147:147:dictSlots:1,,true,147,147,dictSlots,,,0,
485513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:155:155:randomULong:0,,true,155,155,randomULong,,,0,
485516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,defragkey,,true,,,defragkey,,,0,
485520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,defragval,,true,,,defragval,,,0,
485524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,defragalloc,,true,,,defragalloc,,,0,
485528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.c,dict.c:1175:1175:GETFAIR_NUM_ENTRIES:0,,true,1175,1175,GETFAIR_NUM_ENTRIES,,,0,
485531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fn,,true,,,fn,,,0,
485535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:123:123:DICT_HT_INITIAL_EXP:0,,true,123,123,DICT_HT_INITIAL_EXP,,,0,
485538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.c,dict.c:1518:1518:DICT_STATS_VECTLEN:0,,true,1518,1518,DICT_STATS_VECTLEN,,,0,
485541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,eval.c,eval.c:81:81:LDB_BREAKPOINTS_MAX:0,,true,81,81,LDB_BREAKPOINTS_MAX,,,0,
485544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushboolean,,true,,,lua_pushboolean,,,0,
485549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_gettop,,true,,,lua_gettop,,,0,
485553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_open,,true,,,lua_open,,,0,
485556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getglobal,,true,,,lua_getglobal,,,0,
485561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushstring,,true,,,lua_pushstring,,,0,
485566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushcfunction,,true,,,lua_pushcfunction,,,0,
485571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_settable,,true,,,lua_settable,,,0,
485576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_setglobal,,true,,,lua_setglobal,,,0,
485581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_loadbuffer,,true,,,luaL_loadbuffer,,,0,
485588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pcall,,true,,,lua_pcall,,,0,
485595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:344:344:CLIENT_SCRIPT:0,,true,344,344,CLIENT_SCRIPT,,,0,
485598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushvalue,,true,,,lua_pushvalue,,,0,
485603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pop,,true,,,lua_pop,,,0,
485608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_close,,true,,,lua_close,,,0,
485612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:84:84:SCRIPT_FLAG_EVAL_COMPAT_MODE:0,,true,84,84,SCRIPT_FLAG_EVAL_COMPAT_MODE,,,0,
485615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tostring,,true,,,lua_tostring,,,0,
485620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isfunction,,true,,,lua_isfunction,,,0,
485625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_setfield,,true,,,lua_setfield,,,0,
485631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getfield,,true,,,lua_getfield,,,0,
485637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isnil,,true,,,lua_isnil,,,0,
485642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:66:66:SCRIPT_EVAL_MODE:0,,true,66,66,SCRIPT_EVAL_MODE,,,0,
485645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:363:363:CLIENT_LUA_DEBUG:0,,true,363,363,CLIENT_LUA_DEBUG,,,0,
485648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:364:364:CLIENT_LUA_DEBUG_SYNC:0,,true,364,364,CLIENT_LUA_DEBUG_SYNC,,,0,
485651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,eval.c,eval.c:82:82:LDB_MAX_LEN_DEFAULT:0,,true,82,82,LDB_MAX_LEN_DEFAULT,,,0,
485654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1524:1524:CHILD_TYPE_LDB:0,,true,1524,1524,CHILD_TYPE_LDB,,,0,
485657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strstr,,true,,,strstr,,,0,
485662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size_t,,true,,,size_t,,,0,
485666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abs,,true,,,abs,,,0,
485670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_type,,true,,,lua_type,,,0,
485675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,eval.c,eval.c:1040:1040:LDB_MAX_VALUES_DEPTH:0,,true,1040,1040,LDB_MAX_VALUES_DEPTH,,,0,
485678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tolstring,,true,,,lua_tolstring,,,0,
485684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_toboolean,,true,,,lua_toboolean,,,0,
485689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_tonumber,,true,,,lua_tonumber,,,0,
485694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushnil,,true,,,lua_pushnil,,,0,
485698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_next,,true,,,lua_next,,,0,
485703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_topointer,,true,,,lua_topointer,,,0,
485708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getstack,,true,,,lua_getstack,,,0,
485714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getlocal,,true,,,lua_getlocal,,,0,
485720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_checkstack,,true,,,lua_checkstack,,,0,
485725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_gettable,,true,,,lua_gettable,,,0,
485730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushlstring,,true,,,lua_pushlstring,,,0,
485736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getinfo,,true,,,lua_getinfo,,,0,
485742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script_lua.h,script_lua.h:57:57:REGISTRY_RUN_CTX_NAME:0,,true,57,57,REGISTRY_RUN_CTX_NAME,,,0,
485745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:894:894:LRU_CLOCK_RESOLUTION:0,,true,894,894,LRU_CLOCK_RESOLUTION,,,0,
485748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:893:893:LRU_CLOCK_MAX:0,,true,893,893,LRU_CLOCK_MAX,,,0,
485751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,evict.c,evict.c:54:54:EVPOOL_SIZE:0,,true,54,54,EVPOOL_SIZE,,,0,
485754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,evict.c,evict.c:55:55:EVPOOL_CACHED_SDS_SIZE:0,,true,55,55,EVPOOL_CACHED_SDS_SIZE,,,0,
485757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:563:563:MAXMEMORY_FLAG_LRU:0,,true,563,563,MAXMEMORY_FLAG_LRU,,,0,
485760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3406:3406:LFU_INIT_VAL:0,,true,3406,3406,LFU_INIT_VAL,,,0,
485763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:177:177:PROTO_REPLY_CHUNK_BYTES:0,,true,177,177,PROTO_REPLY_CHUNK_BYTES,,,0,
485766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3411:3411:EVICT_RUNNING:0,,true,3411,3411,EVICT_RUNNING,,,0,
485769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:608:608:PAUSE_ACTION_EVICT:0,,true,608,608,PAUSE_ACTION_EVICT,,,0,
485772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pow,,true,,,pow,,,0,
485777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3410:3410:EVICT_OK:0,,true,3410,3410,EVICT_OK,,,0,
485780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3412:3412:EVICT_FAIL:0,,true,3412,3412,EVICT_FAIL,,,0,
485783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:565:565:MAXMEMORY_FLAG_ALLKEYS:0,,true,565,565,MAXMEMORY_FLAG_ALLKEYS,,,0,
485786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:302:302:DB_FLAG_KEY_EVICTED:0,,true,302,302,DB_FLAG_KEY_EVICTED,,,0,
485789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:657:657:NOTIFY_EVICTED:0,,true,657,657,NOTIFY_EVICTED,,,0,
485792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:107:107:ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP:0,,true,107,107,ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP,,,0,
485795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:108:108:ACTIVE_EXPIRE_CYCLE_FAST_DURATION:0,,true,108,108,ACTIVE_EXPIRE_CYCLE_FAST_DURATION,,,0,
485798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:109:109:ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC:0,,true,109,109,ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC,,,0,
485801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:110:110:ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE:0,,true,110,110,ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE,,,0,
485804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:118:118:CRON_DBS_PER_CALL:0,,true,118,118,CRON_DBS_PER_CALL,,,0,
485807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:149:149:ACTIVE_EXPIRE_CYCLE_FAST:0,,true,149,149,ACTIVE_EXPIRE_CYCLE_FAST,,,0,
485810,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:486:486:EXPIRE_NX:0,,true,486,486,EXPIRE_NX,,,0,
485813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:487:487:EXPIRE_XX:0,,true,487,487,EXPIRE_XX,,,0,
485816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:488:488:EXPIRE_GT:0,,true,488,488,EXPIRE_GT,,,0,
485819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,expire.c,expire.c:489:489:EXPIRE_LT:0,,true,489,489,EXPIRE_LT,,,0,
485822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:579:579:UNIT_SECONDS:0,,true,579,579,UNIT_SECONDS,,,0,
485825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:580:580:UNIT_MILLISECONDS:0,,true,580,580,UNIT_MILLISECONDS,,,0,
485828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:51:51:REGISTRY_LOAD_CTX_NAME:0,,true,51,51,REGISTRY_LOAD_CTX_NAME,,,0,
485831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:54:54:LOAD_TIMEOUT_MS:0,,true,54,54,LOAD_TIMEOUT_MS,,,0,
485834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_sethook,,true,,,lua_sethook,,,0,
485841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_getmetatable,,true,,,lua_getmetatable,,,0,
485846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_enablereadonlytable,,true,,,lua_enablereadonlytable,,,0,
485852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:52:52:LIBRARY_API_NAME:0,,true,52,52,LIBRARY_API_NAME,,,0,
485855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:53:53:GLOBALS_API_NAME:0,,true,53,53,GLOBALS_API_NAME,,,0,
485858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:50:50:REGISTRY_ERROR_HANDLER_NAME:0,,true,50,50,REGISTRY_ERROR_HANDLER_NAME,,,0,
485861,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawgeti,,true,,,lua_rawgeti,,,0,
485867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_unref,,true,,,lua_unref,,,0,
485872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushnumber,,true,,,lua_pushnumber,,,0,
485877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isstring,,true,,,lua_isstring,,,0,
485882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_istable,,true,,,lua_istable,,,0,
485887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_ref,,true,,,luaL_ref,,,0,
485892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_newtable,,true,,,lua_newtable,,,0,
485896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script_lua.h,script_lua.h:59:59:REDIS_API_NAME:0,,true,59,59,REDIS_API_NAME,,,0,
485899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:49:49:REGISTRY_ENGINE_CTX_NAME:0,,true,49,49,REGISTRY_ENGINE_CTX_NAME,,,0,
485902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_setmetatable,,true,,,lua_setmetatable,,,0,
485907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_replace,,true,,,lua_replace,,,0,
485912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,function_lua.c,function_lua.c:48:48:LUA_ENGINE_NAME:0,,true,48,48,LUA_ENGINE_NAME,,,0,
485915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:107:107:RDB_OPCODE_FUNCTION_PRE_GA:0,,true,107,107,RDB_OPCODE_FUNCTION_PRE_GA,,,0,
485918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:106:106:RDB_OPCODE_FUNCTION2:0,,true,106,106,RDB_OPCODE_FUNCTION2,,,0,
485921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:46:46:GEO_STEP_MAX:0,,true,46,46,GEO_STEP_MAX,,,0,
485924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:51:51:GEO_LONG_MIN:0,,true,51,51,GEO_LONG_MIN,,,0,
485927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:52:52:GEO_LONG_MAX:0,,true,52,52,GEO_LONG_MAX,,,0,
485930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:49:49:GEO_LAT_MIN:0,,true,49,49,GEO_LAT_MIN,,,0,
485933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:50:50:GEO_LAT_MAX:0,,true,50,50,GEO_LAT_MAX,,,0,
485936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:92:92:CIRCULAR_TYPE:0,,true,92,92,CIRCULAR_TYPE,,,0,
485939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:93:93:RECTANGLE_TYPE:0,,true,93,93,RECTANGLE_TYPE,,,0,
485942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:42:42:HASHISZERO:1,,true,42,42,HASHISZERO,,,0,
485946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,debugmacro.h,debugmacro.h:37:44:D:1,,true,37,44,D,,,0,
485949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:509:509:RADIUS_COORDS:0,,true,509,509,RADIUS_COORDS,,,0,
485952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:510:510:RADIUS_MEMBER:0,,true,510,510,RADIUS_MEMBER,,,0,
485955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:512:512:GEOSEARCH:0,,true,512,512,GEOSEARCH,,,0,
485958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:513:513:GEOSEARCHSTORE:0,,true,513,513,GEOSEARCHSTORE,,,0,
485961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:505:505:SORT_NONE:0,,true,505,505,SORT_NONE,,,0,
485964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:506:506:SORT_ASC:0,,true,506,506,SORT_ASC,,,0,
485967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:507:507:SORT_DESC:0,,true,507,507,SORT_DESC,,,0,
485970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geo.c,geo.c:511:511:RADIUS_NOSTORE:0,,true,511,511,RADIUS_NOSTORE,,,0,
485973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,qsort,,true,,,qsort,,,0,
485980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:655:655:NOTIFY_ZSET:0,,true,655,655,NOTIFY_ZSET,,,0,
485983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:44:44:RANGEPISZERO:1,,true,44,44,RANGEPISZERO,,,0,
485987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash.h,geohash.h:43:43:RANGEISZERO:1,,true,43,43,RANGEISZERO,,,0,
485991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash_helper.c,geohash_helper.c:42:42:D_R:0,,true,42,42,D_R,,,0,
485994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cos,,true,,,cos,,,0,
485998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqrt,,true,,,sqrt,,,0,
486002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,geohash_helper.h,geohash_helper.h:37:37:GZERO:1,,true,37,37,GZERO,,,0,
486006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fabs,,true,,,fabs,,,0,
486010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sin,,true,,,sin,,,0,
486014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,asin,,true,,,asin,,,0,
486018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:198:198:HLL_P_MASK:0,,true,198,198,HLL_P_MASK,,,0,
486021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:194:194:HLL_P:0,,true,194,194,HLL_P,,,0,
486024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:195:195:HLL_Q:0,,true,195,195,HLL_Q,,,0,
486027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:339:347:HLL_DENSE_GET_REGISTER:3,,true,339,347,HLL_DENSE_GET_REGISTER,,,0,
486033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:351:361:HLL_DENSE_SET_REGISTER:3,,true,351,361,HLL_DENSE_SET_REGISTER,,,0,
486039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:197:197:HLL_REGISTERS:0,,true,197,197,HLL_REGISTERS,,,0,
486042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:199:199:HLL_BITS:0,,true,199,199,HLL_BITS,,,0,
486045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:203:203:HLL_DENSE:0,,true,203,203,HLL_DENSE,,,0,
486048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:202:202:HLL_DENSE_SIZE:0,,true,202,202,HLL_DENSE_SIZE,,,0,
486051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:201:201:HLL_HDR_SIZE:0,,true,201,201,HLL_HDR_SIZE,,,0,
486054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:367:367:HLL_SPARSE_IS_ZERO:1,,true,367,367,HLL_SPARSE_IS_ZERO,,,0,
486058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:370:370:HLL_SPARSE_ZERO_LEN:1,,true,370,370,HLL_SPARSE_ZERO_LEN,,,0,
486062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:368:368:HLL_SPARSE_IS_XZERO:1,,true,368,368,HLL_SPARSE_IS_XZERO,,,0,
486066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:371:371:HLL_SPARSE_XZERO_LEN:1,,true,371,371,HLL_SPARSE_XZERO_LEN,,,0,
486070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:373:373:HLL_SPARSE_VAL_LEN:1,,true,373,373,HLL_SPARSE_VAL_LEN,,,0,
486074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:372:372:HLL_SPARSE_VAL_VALUE:1,,true,372,372,HLL_SPARSE_VAL_VALUE,,,0,
486078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:374:374:HLL_SPARSE_VAL_MAX_VALUE:0,,true,374,374,HLL_SPARSE_VAL_MAX_VALUE,,,0,
486081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:369:369:HLL_SPARSE_IS_VAL:1,,true,369,369,HLL_SPARSE_IS_VAL,,,0,
486084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:378:380:HLL_SPARSE_VAL_SET:3,,true,378,380,HLL_SPARSE_VAL_SET,,,0,
486089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:376:376:HLL_SPARSE_ZERO_MAX_LEN:0,,true,376,376,HLL_SPARSE_ZERO_MAX_LEN,,,0,
486092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:384:388:HLL_SPARSE_XZERO_SET:2,,true,384,388,HLL_SPARSE_XZERO_SET,,,0,
486097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:381:383:HLL_SPARSE_ZERO_SET:2,,true,381,383,HLL_SPARSE_ZERO_SET,,,0,
486102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:375:375:HLL_SPARSE_VAL_MAX_LEN:0,,true,375,375,HLL_SPARSE_VAL_MAX_LEN,,,0,
486105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:191:191:HLL_INVALIDATE_CACHE:1,,true,191,191,HLL_INVALIDATE_CACHE,,,0,
486109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:204:204:HLL_SPARSE:0,,true,204,204,HLL_SPARSE,,,0,
486112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:205:205:HLL_RAW:0,,true,205,205,HLL_RAW,,,0,
486115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llroundl,,true,,,llroundl,,,0,
486119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:389:389:HLL_ALPHA_INF:0,,true,389,389,HLL_ALPHA_INF,,,0,
486122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:377:377:HLL_SPARSE_XZERO_MAX_LEN:0,,true,377,377,HLL_SPARSE_XZERO_MAX_LEN,,,0,
486125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:206:206:HLL_MAX_ENCODING:0,,true,206,206,HLL_MAX_ENCODING,,,0,
486128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:192:192:HLL_VALID_CACHE:1,,true,192,192,HLL_VALID_CACHE,,,0,
486132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:1406:1406:HLL_TEST_CYCLES:0,,true,1406,1406,HLL_TEST_CYCLES,,,0,
486135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,hyperloglog.c,hyperloglog.c:200:200:HLL_REGISTER_MAX:0,,true,200,200,HLL_REGISTER_MAX,,,0,
486138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ceil,,true,,,ceil,,,0,
486142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,intset.c,intset.c:43:43:INTSET_ENC_INT64:0,,true,43,43,INTSET_ENC_INT64,,,0,
486145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,intset.c,intset.c:42:42:INTSET_ENC_INT32:0,,true,42,42,INTSET_ENC_INT32,,,0,
486148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,intset.c,intset.c:41:41:INTSET_ENC_INT16:0,,true,41,41,INTSET_ENC_INT16,,,0,
486151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:57:57:memrev32ifbe:1,,true,57,57,memrev32ifbe,,,0,
486154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:56:56:memrev16ifbe:1,,true,56,56,memrev16ifbe,,,0,
486158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:60:60:intrev32ifbe:1,,true,60,60,intrev32ifbe,,,0,
486161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:60:60:intrev32ifbe:2,,true,60,60,intrev32ifbe,,,0,
486164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,latency.h,latency.h:37:37:LATENCY_TS_LEN:0,,true,37,37,LATENCY_TS_LEN,,,0,
486167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_iter_log_init,,true,,,hdr_iter_log_init,,,0,
486174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_iter_next,,true,,,hdr_iter_next,,,0,
486178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,latency.c,latency.c:589:589:LATENCY_GRAPH_COLS:0,,true,589,589,LATENCY_GRAPH_COLS,,,0,
486181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sparkline.h,sparkline.h:47:47:SPARKLINE_FILL:0,,true,47,47,SPARKLINE_FILL,,,0,
486184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicDecr,,true,,,atomicDecr,,,0,
486189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicIncr,,true,,,atomicIncr,,,0,
486194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lazyfree.c,lazyfree.c:156:156:LAZYFREE_THRESHOLD:0,,true,156,156,LAZYFREE_THRESHOLD,,,0,
486197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:106:109:lpGetTotalBytes:1,,true,106,109,lpGetTotalBytes,,,0,
486201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint32_t,,true,,,uint32_t,,,0,
486205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:144:144:LISTPACK_MAX_SAFETY_SIZE:0,,true,144,144,LISTPACK_MAX_SAFETY_SIZE,,,0,
486208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack_malloc.h,listpack_malloc.h:45:45:lp_malloc:1,,true,45,45,lp_malloc,,,0,
486211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:113:118:lpSetTotalBytes:2,,true,113,118,lpSetTotalBytes,,,0,
486216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:120:123:lpSetNumElements:2,,true,120,123,lpSetNumElements,,,0,
486221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:48:48:LP_HDR_SIZE:0,,true,48,48,LP_HDR_SIZE,,,0,
486224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:97:97:LP_EOF:0,,true,97,97,LP_EOF,,,0,
486227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack_malloc.h,listpack_malloc.h:47:47:lp_free:0,,true,47,47,lp_free,,,0,
486230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack_malloc.h,listpack_malloc.h:48:48:lp_malloc_size:0,,true,48,48,lp_malloc_size,,,0,
486233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack_malloc.h,listpack_malloc.h:46:46:lp_realloc:2,,true,46,46,lp_realloc,,,0,
486238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:64:64:LP_ENCODING_13BIT_INT:0,,true,64,64,LP_ENCODING_13BIT_INT,,,0,
486241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:73:73:LP_ENCODING_16BIT_INT:0,,true,73,73,LP_ENCODING_16BIT_INT,,,0,
486244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:78:78:LP_ENCODING_24BIT_INT:0,,true,78,78,LP_ENCODING_24BIT_INT,,,0,
486247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:83:83:LP_ENCODING_32BIT_INT:0,,true,83,83,LP_ENCODING_32BIT_INT,,,0,
486250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:88:88:LP_ENCODING_64BIT_INT:0,,true,88,88,LP_ENCODING_64BIT_INT,,,0,
486253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:52:52:LP_ENCODING_INT:0,,true,52,52,LP_ENCODING_INT,,,0,
486256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:53:53:LP_ENCODING_STRING:0,,true,53,53,LP_ENCODING_STRING,,,0,
486259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:60:60:LP_ENCODING_6BIT_STR:0,,true,60,60,LP_ENCODING_6BIT_STR,,,0,
486262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:69:69:LP_ENCODING_12BIT_STR:0,,true,69,69,LP_ENCODING_12BIT_STR,,,0,
486265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:93:93:LP_ENCODING_32BIT_STR:0,,true,93,93,LP_ENCODING_32BIT_STR,,,0,
486268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:57:57:LP_ENCODING_IS_7BIT_UINT:1,,true,57,57,LP_ENCODING_IS_7BIT_UINT,,,0,
486272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:62:62:LP_ENCODING_IS_6BIT_STR:1,,true,62,62,LP_ENCODING_IS_6BIT_STR,,,0,
486276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:99:99:LP_ENCODING_6BIT_STR_LEN:1,,true,99,99,LP_ENCODING_6BIT_STR_LEN,,,0,
486280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:66:66:LP_ENCODING_IS_13BIT_INT:1,,true,66,66,LP_ENCODING_IS_13BIT_INT,,,0,
486284,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:75:75:LP_ENCODING_IS_16BIT_INT:1,,true,75,75,LP_ENCODING_IS_16BIT_INT,,,0,
486288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:80:80:LP_ENCODING_IS_24BIT_INT:1,,true,80,80,LP_ENCODING_IS_24BIT_INT,,,0,
486292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:85:85:LP_ENCODING_IS_32BIT_INT:1,,true,85,85,LP_ENCODING_IS_32BIT_INT,,,0,
486296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:90:90:LP_ENCODING_IS_64BIT_INT:1,,true,90,90,LP_ENCODING_IS_64BIT_INT,,,0,
486300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:71:71:LP_ENCODING_IS_12BIT_STR:1,,true,71,71,LP_ENCODING_IS_12BIT_STR,,,0,
486304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:100:100:LP_ENCODING_12BIT_STR_LEN:1,,true,100,100,LP_ENCODING_12BIT_STR_LEN,,,0,
486308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:95:95:LP_ENCODING_IS_32BIT_STR:1,,true,95,95,LP_ENCODING_IS_32BIT_STR,,,0,
486312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:101:104:LP_ENCODING_32BIT_STR_LEN:1,,true,101,104,LP_ENCODING_32BIT_STR_LEN,,,0,
486316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:111:112:lpGetNumElements:1,,true,111,112,lpGetNumElements,,,0,
486320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:49:49:LP_HDR_NUMELE_UNKNOWN:0,,true,49,49,LP_HDR_NUMELE_UNKNOWN,,,0,
486323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:58:58:LP_ENCODING_7BIT_UINT_ENTRY_SIZE:0,,true,58,58,LP_ENCODING_7BIT_UINT_ENTRY_SIZE,,,0,
486326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:67:67:LP_ENCODING_13BIT_INT_ENTRY_SIZE:0,,true,67,67,LP_ENCODING_13BIT_INT_ENTRY_SIZE,,,0,
486329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:76:76:LP_ENCODING_16BIT_INT_ENTRY_SIZE:0,,true,76,76,LP_ENCODING_16BIT_INT_ENTRY_SIZE,,,0,
486332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:81:81:LP_ENCODING_24BIT_INT_ENTRY_SIZE:0,,true,81,81,LP_ENCODING_24BIT_INT_ENTRY_SIZE,,,0,
486335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:86:86:LP_ENCODING_32BIT_INT_ENTRY_SIZE:0,,true,86,86,LP_ENCODING_32BIT_INT_ENTRY_SIZE,,,0,
486338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:91:91:LP_ENCODING_64BIT_INT_ENTRY_SIZE:0,,true,91,91,LP_ENCODING_64BIT_INT_ENTRY_SIZE,,,0,
486341,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.h,listpack.h:41:41:LP_INTBUF_SIZE:0,,true,41,41,LP_INTBUF_SIZE,,,0,
486344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.h,listpack.h:46:46:LP_REPLACE:0,,true,46,46,LP_REPLACE,,,0,
486347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.h,listpack.h:45:45:LP_AFTER:0,,true,45,45,LP_AFTER,,,0,
486350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.h,listpack.h:44:44:LP_BEFORE:0,,true,44,44,LP_BEFORE,,,0,
486353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:130:132:ASSERT_INTEGRITY:2,,true,130,132,ASSERT_INTEGRITY,,,0,
486358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:136:138:ASSERT_INTEGRITY_LEN:3,,true,136,138,ASSERT_INTEGRITY_LEN,,,0,
486364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:137:137:redis_unreachable:0,,true,137,137,redis_unreachable,,,0,
486367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,listpack.c,listpack.c:1293:1295:OUT_OF_RANGE:1,,true,1293,1295,OUT_OF_RANGE,,,0,
486370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,entry_cb,,true,,,entry_cb,,,0,
486376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fwrite,,true,,,fwrite,,,0,
486383,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,round,,true,,,round,,,0,
486387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzfP.h,lzfP.h:55:55:HLOG:0,,true,55,55,HLOG,,,0,
486390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:48:48:FRST:1,,true,48,48,FRST,,,0,
486394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:49:49:NEXT:2,,true,49,49,NEXT,,,0,
486399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:53:53:IDX:1,,true,53,53,IDX,,,0,
486403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzfP.h,lzfP.h:167:167:LZF_HSLOT_BIAS:0,,true,167,167,LZF_HSLOT_BIAS,,,0,
486406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:75:75:MAX_OFF:0,,true,75,75,MAX_OFF,,,0,
486409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:76:76:MAX_REF:0,,true,76,76,MAX_REF,,,0,
486412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:86:86:expect_false:1,,true,86,86,expect_false,,,0,
486415,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_c.c,lzf_c.c:87:87:expect_true:1,,true,87,87,expect_true,,,0,
486418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,lzf_d.c,lzf_d.c:43:43:SET_ERRNO:1,,true,43,43,SET_ERRNO,,,0,
486422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assert,,true,,,assert,,,0,
486426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memtest.c,memtest.c:141:146:xorshift64star_next:0,,true,141,146,xorshift64star_next,,,0,
486429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memtest.c,memtest.c:55:55:ULONG_ONEZERO:0,,true,55,55,ULONG_ONEZERO,,,0,
486432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memtest.c,memtest.c:56:56:ULONG_ZEROONE:0,,true,56,56,ULONG_ZEROONE,,,0,
486435,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,memtest.c,memtest.c:289:289:MEMTEST_DECACHE_SIZE:0,,true,289,289,MEMTEST_DECACHE_SIZE,,,0,
486438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloc,,true,,,malloc,,,0,
486442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,,true,,,free,,,0,
486446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ioctl,,true,,,ioctl,,,0,
486452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:124:124:REDISMODULE_POOL_ALLOC_ALIGN:0,,true,124,124,REDISMODULE_POOL_ALLOC_ALIGN,,,0,
486455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:123:123:REDISMODULE_POOL_ALLOC_MIN_SIZE:0,,true,123,123,REDISMODULE_POOL_ALLOC_MIN_SIZE,,,0,
486458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:50:50:REDISMODULE_WRITE:0,,true,50,50,REDISMODULE_WRITE,,,0,
486461,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:35:35:REDISMODULE_ERR:0,,true,35,35,REDISMODULE_ERR,,,0,
486464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:75:75:REDISMODULE_KEYTYPE_LIST:0,,true,75,75,REDISMODULE_KEYTYPE_LIST,,,0,
486467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:78:78:REDISMODULE_KEYTYPE_ZSET:0,,true,78,78,REDISMODULE_KEYTYPE_ZSET,,,0,
486470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:76:76:REDISMODULE_KEYTYPE_HASH:0,,true,76,76,REDISMODULE_KEYTYPE_HASH,,,0,
486473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:80:80:REDISMODULE_KEYTYPE_STREAM:0,,true,80,80,REDISMODULE_KEYTYPE_STREAM,,,0,
486476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:34:34:REDISMODULE_OK:0,,true,34,34,REDISMODULE_OK,,,0,
486479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:683:683:BUSY_MODULE_YIELD_NONE:0,,true,683,683,BUSY_MODULE_YIELD_NONE,,,0,
486482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:178:178:REDISMODULE_CTX_THREAD_SAFE:0,,true,178,178,REDISMODULE_CTX_THREAD_SAFE,,,0,
486485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:185:185:REDISMODULE_CTX_COMMAND:0,,true,185,185,REDISMODULE_CTX_COMMAND,,,0,
486488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:180:180:REDISMODULE_CTX_TEMP_CLIENT:0,,true,180,180,REDISMODULE_CTX_TEMP_CLIENT,,,0,
486491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:182:182:REDISMODULE_CTX_NEW_CLIENT:0,,true,182,182,REDISMODULE_CTX_NEW_CLIENT,,,0,
486494,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleAsyncRMCallPromise.on_unblocked,,true,,,on_unblocked,,,0,
486501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleCommand.func,,true,,,func,,,0,
486508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:175:175:REDISMODULE_CTX_KEYS_POS_REQUEST:0,,true,175,175,REDISMODULE_CTX_KEYS_POS_REQUEST,,,0,
486511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2052:2052:MAX_KEYS_BUFFER:0,,true,2052,2052,MAX_KEYS_BUFFER,,,0,
486514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:184:184:REDISMODULE_CTX_CHANNELS_POS_REQUEST:0,,true,184,184,REDISMODULE_CTX_CHANNELS_POS_REQUEST,,,0,
486517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:296:296:CMD_KEY_FULL_ACCESS:0,,true,296,296,CMD_KEY_FULL_ACCESS,,,0,
486520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:368:368:REDISMODULE_CMD_CHANNEL_SUBSCRIBE:0,,true,368,368,REDISMODULE_CMD_CHANNEL_SUBSCRIBE,,,0,
486523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:369:369:REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE:0,,true,369,369,REDISMODULE_CMD_CHANNEL_UNSUBSCRIBE,,,0,
486526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:367:367:REDISMODULE_CMD_CHANNEL_PUBLISH:0,,true,367,367,REDISMODULE_CMD_CHANNEL_PUBLISH,,,0,
486529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:366:366:REDISMODULE_CMD_CHANNEL_PATTERN:0,,true,366,366,REDISMODULE_CMD_CHANNEL_PATTERN,,,0,
486532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:207:207:CMD_READONLY:0,,true,207,207,CMD_READONLY,,,0,
486535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:210:210:CMD_ADMIN:0,,true,210,210,CMD_ADMIN,,,0,
486538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:208:208:CMD_DENYOOM:0,,true,208,208,CMD_DENYOOM,,,0,
486541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:212:212:CMD_NOSCRIPT:0,,true,212,212,CMD_NOSCRIPT,,,0,
486544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:214:214:CMD_LOADING:0,,true,214,214,CMD_LOADING,,,0,
486547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:211:211:CMD_PUBSUB:0,,true,211,211,CMD_PUBSUB,,,0,
486550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:213:213:CMD_BLOCKING:0,,true,213,213,CMD_BLOCKING,,,0,
486553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:215:215:CMD_STALE:0,,true,215,215,CMD_STALE,,,0,
486556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:216:216:CMD_SKIP_MONITOR:0,,true,216,216,CMD_SKIP_MONITOR,,,0,
486559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:217:217:CMD_SKIP_SLOWLOG:0,,true,217,217,CMD_SKIP_SLOWLOG,,,0,
486562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:219:219:CMD_FAST:0,,true,219,219,CMD_FAST,,,0,
486565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:221:221:CMD_MAY_REPLICATE:0,,true,221,221,CMD_MAY_REPLICATE,,,0,
486568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:227:227:CMD_MODULE_NO_CLUSTER:0,,true,227,227,CMD_MODULE_NO_CLUSTER,,,0,
486571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:224:224:CMD_NO_MANDATORY_KEYS:0,,true,224,224,CMD_NO_MANDATORY_KEYS,,,0,
486574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:232:232:CMD_ALLOW_BUSY:0,,true,232,232,CMD_ALLOW_BUSY,,,0,
486577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:352:352:REDISMODULE_CMD_KEY_RO:0,,true,352,352,REDISMODULE_CMD_KEY_RO,,,0,
486580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:353:353:REDISMODULE_CMD_KEY_RW:0,,true,353,353,REDISMODULE_CMD_KEY_RW,,,0,
486583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:354:354:REDISMODULE_CMD_KEY_OW:0,,true,354,354,REDISMODULE_CMD_KEY_OW,,,0,
486586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:355:355:REDISMODULE_CMD_KEY_RM:0,,true,355,355,REDISMODULE_CMD_KEY_RM,,,0,
486589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:358:358:REDISMODULE_CMD_KEY_INSERT:0,,true,358,358,REDISMODULE_CMD_KEY_INSERT,,,0,
486592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:359:359:REDISMODULE_CMD_KEY_DELETE:0,,true,359,359,REDISMODULE_CMD_KEY_DELETE,,,0,
486595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:357:357:REDISMODULE_CMD_KEY_UPDATE:0,,true,357,357,REDISMODULE_CMD_KEY_UPDATE,,,0,
486598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:271:271:CMD_KEY_RM:0,,true,271,271,CMD_KEY_RM,,,0,
486601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:356:356:REDISMODULE_CMD_KEY_ACCESS:0,,true,356,356,REDISMODULE_CMD_KEY_ACCESS,,,0,
486604,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:360:360:REDISMODULE_CMD_KEY_NOT_KEY:0,,true,360,360,REDISMODULE_CMD_KEY_NOT_KEY,,,0,
486607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:361:361:REDISMODULE_CMD_KEY_INCOMPLETE:0,,true,361,361,REDISMODULE_CMD_KEY_INCOMPLETE,,,0,
486610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:362:362:REDISMODULE_CMD_KEY_VARIABLE_FLAGS:0,,true,362,362,REDISMODULE_CMD_KEY_VARIABLE_FLAGS,,,0,
486613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:330:330:_REDISMODULE_CMD_ARG_NEXT:0,,true,330,330,_REDISMODULE_CMD_ARG_NEXT,,,0,
486616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:327:327:REDISMODULE_CMD_ARG_OPTIONAL:0,,true,327,327,REDISMODULE_CMD_ARG_OPTIONAL,,,0,
486619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,commands.h,commands.h:18:18:CMD_ARG_OPTIONAL:0,,true,18,18,CMD_ARG_OPTIONAL,,,0,
486622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:328:328:REDISMODULE_CMD_ARG_MULTIPLE:0,,true,328,328,REDISMODULE_CMD_ARG_MULTIPLE,,,0,
486625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,commands.h,commands.h:19:19:CMD_ARG_MULTIPLE:0,,true,19,19,CMD_ARG_MULTIPLE,,,0,
486628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:329:329:REDISMODULE_CMD_ARG_MULTIPLE_TOKEN:0,,true,329,329,REDISMODULE_CMD_ARG_MULTIPLE_TOKEN,,,0,
486631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,commands.h,commands.h:20:20:CMD_ARG_MULTIPLE_TOKEN:0,,true,20,20,CMD_ARG_MULTIPLE_TOKEN,,,0,
486634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:684:684:BUSY_MODULE_YIELD_EVENTS:0,,true,684,684,BUSY_MODULE_YIELD_EVENTS,,,0,
486637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:275:275:REDISMODULE_YIELD_FLAG_CLIENTS:0,,true,275,275,REDISMODULE_YIELD_FLAG_CLIENTS,,,0,
486640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:685:685:BUSY_MODULE_YIELD_CLIENTS:0,,true,685,685,BUSY_MODULE_YIELD_CLIENTS,,,0,
486643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:174:174:REDISMODULE_CTX_AUTO_MEMORY:0,,true,174,174,REDISMODULE_CTX_AUTO_MEMORY,,,0,
486646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:106:106:REDISMODULE_AM_FREED:0,,true,106,106,REDISMODULE_AM_FREED,,,0,
486649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:104:104:REDISMODULE_AM_STRING:0,,true,104,104,REDISMODULE_AM_STRING,,,0,
486652,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:105:105:REDISMODULE_AM_REPLY:0,,true,105,105,REDISMODULE_AM_REPLY,,,0,
486655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:103:103:REDISMODULE_AM_KEY:0,,true,103,103,REDISMODULE_AM_KEY,,,0,
486658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:107:107:REDISMODULE_AM_DICT:0,,true,107,107,REDISMODULE_AM_DICT,,,0,
486661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:108:108:REDISMODULE_AM_INFO:0,,true,108,108,REDISMODULE_AM_INFO,,,0,
486664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:19:19:RedisModuleString:0,,true,19,19,RedisModuleString,,,0,
486667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:887:887:OBJ_ENCODING_EMBSTR:0,,true,887,887,OBJ_ENCODING_EMBSTR,,,0,
486670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:100:100:REDISMODULE_POSTPONED_LEN:0,,true,100,100,REDISMODULE_POSTPONED_LEN,,,0,
486673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:3045:3045:COLLECTION_REPLY_ARRAY:0,,true,3045,3045,COLLECTION_REPLY_ARRAY,,,0,
486676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:3046:3046:COLLECTION_REPLY_MAP:0,,true,3046,3046,COLLECTION_REPLY_MAP,,,0,
486679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:3047:3047:COLLECTION_REPLY_SET:0,,true,3047,3047,COLLECTION_REPLY_SET,,,0,
486682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:3048:3048:COLLECTION_REPLY_ATTRIBUTE:0,,true,3048,3048,COLLECTION_REPLY_ATTRIBUTE,,,0,
486685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:389:389:REDISMODULE_ARGV_NO_AOF:0,,true,389,389,REDISMODULE_ARGV_NO_AOF,,,0,
486688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:390:390:REDISMODULE_ARGV_NO_REPLICAS:0,,true,390,390,REDISMODULE_ARGV_NO_REPLICAS,,,0,
486691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:696:696:REDISMODULE_CLIENTINFO_FLAG_MULTI:0,,true,696,696,REDISMODULE_CLIENTINFO_FLAG_MULTI,,,0,
486694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:354:354:CLIENT_PUBSUB:0,,true,354,354,CLIENT_PUBSUB,,,0,
486697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:692:692:REDISMODULE_CLIENTINFO_FLAG_PUBSUB:0,,true,692,692,REDISMODULE_CLIENTINFO_FLAG_PUBSUB,,,0,
486700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:347:347:CLIENT_UNIX_SOCKET:0,,true,347,347,CLIENT_UNIX_SOCKET,,,0,
486703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:695:695:REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET:0,,true,695,695,REDISMODULE_CLIENTINFO_FLAG_UNIXSOCKET,,,0,
486706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:374:374:CLIENT_TRACKING:0,,true,374,374,CLIENT_TRACKING,,,0,
486709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:694:694:REDISMODULE_CLIENTINFO_FLAG_TRACKING:0,,true,694,694,REDISMODULE_CLIENTINFO_FLAG_TRACKING,,,0,
486712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:693:693:REDISMODULE_CLIENTINFO_FLAG_BLOCKED:0,,true,693,693,REDISMODULE_CLIENTINFO_FLAG_BLOCKED,,,0,
486715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:691:691:REDISMODULE_CLIENTINFO_FLAG_SSL:0,,true,691,691,REDISMODULE_CLIENTINFO_FLAG_SSL,,,0,
486718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:199:199:REDISMODULE_CTX_FLAGS_DENY_BLOCKING:0,,true,199,199,REDISMODULE_CTX_FLAGS_DENY_BLOCKING,,,0,
486721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:174:174:REDISMODULE_CTX_FLAGS_REPLICATED:0,,true,174,174,REDISMODULE_CTX_FLAGS_REPLICATED,,,0,
486724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:201:201:REDISMODULE_CTX_FLAGS_RESP3:0,,true,201,201,REDISMODULE_CTX_FLAGS_RESP3,,,0,
486727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:340:340:CLIENT_DIRTY_CAS:0,,true,340,340,CLIENT_DIRTY_CAS,,,0,
486730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:348:348:CLIENT_DIRTY_EXEC:0,,true,348,348,CLIENT_DIRTY_EXEC,,,0,
486733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:194:194:REDISMODULE_CTX_FLAGS_MULTI_DIRTY:0,,true,194,194,REDISMODULE_CTX_FLAGS_MULTI_DIRTY,,,0,
486736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:150:150:REDISMODULE_CTX_FLAGS_LUA:0,,true,150,150,REDISMODULE_CTX_FLAGS_LUA,,,0,
486739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:152:152:REDISMODULE_CTX_FLAGS_MULTI:0,,true,152,152,REDISMODULE_CTX_FLAGS_MULTI,,,0,
486742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:160:160:REDISMODULE_CTX_FLAGS_CLUSTER:0,,true,160,160,REDISMODULE_CTX_FLAGS_CLUSTER,,,0,
486745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:203:203:REDISMODULE_CTX_FLAGS_ASYNC_LOADING:0,,true,203,203,REDISMODULE_CTX_FLAGS_ASYNC_LOADING,,,0,
486748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:176:176:REDISMODULE_CTX_FLAGS_LOADING:0,,true,176,176,REDISMODULE_CTX_FLAGS_LOADING,,,0,
486751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:166:166:REDISMODULE_CTX_FLAGS_MAXMEMORY:0,,true,166,166,REDISMODULE_CTX_FLAGS_MAXMEMORY,,,0,
486754,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:168:168:REDISMODULE_CTX_FLAGS_EVICT:0,,true,168,168,REDISMODULE_CTX_FLAGS_EVICT,,,0,
486757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:162:162:REDISMODULE_CTX_FLAGS_AOF:0,,true,162,162,REDISMODULE_CTX_FLAGS_AOF,,,0,
486760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:164:164:REDISMODULE_CTX_FLAGS_RDB:0,,true,164,164,REDISMODULE_CTX_FLAGS_RDB,,,0,
486763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:154:154:REDISMODULE_CTX_FLAGS_MASTER:0,,true,154,154,REDISMODULE_CTX_FLAGS_MASTER,,,0,
486766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:156:156:REDISMODULE_CTX_FLAGS_SLAVE:0,,true,156,156,REDISMODULE_CTX_FLAGS_SLAVE,,,0,
486769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:158:158:REDISMODULE_CTX_FLAGS_READONLY:0,,true,158,158,REDISMODULE_CTX_FLAGS_READONLY,,,0,
486772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:186:186:REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING:0,,true,186,186,REDISMODULE_CTX_FLAGS_REPLICA_IS_CONNECTING,,,0,
486775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:188:188:REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING:0,,true,188,188,REDISMODULE_CTX_FLAGS_REPLICA_IS_TRANSFERRING,,,0,
486778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:190:190:REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE:0,,true,190,190,REDISMODULE_CTX_FLAGS_REPLICA_IS_ONLINE,,,0,
486781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:183:183:REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE:0,,true,183,183,REDISMODULE_CTX_FLAGS_REPLICA_IS_STALE,,,0,
486784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:170:170:REDISMODULE_CTX_FLAGS_OOM:0,,true,170,170,REDISMODULE_CTX_FLAGS_OOM,,,0,
486787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:172:172:REDISMODULE_CTX_FLAGS_OOM_WARNING:0,,true,172,172,REDISMODULE_CTX_FLAGS_OOM_WARNING,,,0,
486790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:192:192:REDISMODULE_CTX_FLAGS_ACTIVE_CHILD:0,,true,192,192,REDISMODULE_CTX_FLAGS_ACTIVE_CHILD,,,0,
486793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:196:196:REDISMODULE_CTX_FLAGS_IS_CHILD:0,,true,196,196,REDISMODULE_CTX_FLAGS_IS_CHILD,,,0,
486796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:205:205:REDISMODULE_CTX_FLAGS_SERVER_STARTUP:0,,true,205,205,REDISMODULE_CTX_FLAGS_SERVER_STARTUP,,,0,
486799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:609:609:PAUSE_ACTION_REPLICA:0,,true,609,609,PAUSE_ACTION_REPLICA,,,0,
486802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:54:54:REDISMODULE_OPEN_KEY_NOTOUCH:0,,true,54,54,REDISMODULE_OPEN_KEY_NOTOUCH,,,0,
486805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:56:56:REDISMODULE_OPEN_KEY_NONOTIFY:0,,true,56,56,REDISMODULE_OPEN_KEY_NONOTIFY,,,0,
486808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:58:58:REDISMODULE_OPEN_KEY_NOSTATS:0,,true,58,58,REDISMODULE_OPEN_KEY_NOSTATS,,,0,
486811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:60:60:REDISMODULE_OPEN_KEY_NOEXPIRE:0,,true,60,60,REDISMODULE_OPEN_KEY_NOEXPIRE,,,0,
486814,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:62:62:REDISMODULE_OPEN_KEY_NOEFFECTS:0,,true,62,62,REDISMODULE_OPEN_KEY_NOEFFECTS,,,0,
486817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:66:66:_REDISMODULE_OPEN_KEY_ALL:0,,true,66,66,_REDISMODULE_OPEN_KEY_ALL,,,0,
486820,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:405:406:SHOULD_SIGNAL_MODIFIED_KEYS:1,,true,405,406,SHOULD_SIGNAL_MODIFIED_KEYS,,,0,
486824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:73:73:REDISMODULE_KEYTYPE_EMPTY:0,,true,73,73,REDISMODULE_KEYTYPE_EMPTY,,,0,
486827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:74:74:REDISMODULE_KEYTYPE_STRING:0,,true,74,74,REDISMODULE_KEYTYPE_STRING,,,0,
486830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:77:77:REDISMODULE_KEYTYPE_SET:0,,true,77,77,REDISMODULE_KEYTYPE_SET,,,0,
486833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:79:79:REDISMODULE_KEYTYPE_MODULE:0,,true,79,79,REDISMODULE_KEYTYPE_MODULE,,,0,
486836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:103:103:REDISMODULE_NO_EXPIRE:0,,true,103,103,REDISMODULE_NO_EXPIRE,,,0,
486839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:497:497:LIST_HEAD:0,,true,497,497,LIST_HEAD,,,0,
486842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:69:69:REDISMODULE_LIST_HEAD:0,,true,69,69,REDISMODULE_LIST_HEAD,,,0,
486845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:49:49:REDISMODULE_READ:0,,true,49,49,REDISMODULE_READ,,,0,
486848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:70:70:REDISMODULE_LIST_TAIL:0,,true,70,70,REDISMODULE_LIST_TAIL,,,0,
486851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:106:106:REDISMODULE_ZADD_XX:0,,true,106,106,REDISMODULE_ZADD_XX,,,0,
486854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2948:2948:ZADD_IN_XX:0,,true,2948,2948,ZADD_IN_XX,,,0,
486857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:107:107:REDISMODULE_ZADD_NX:0,,true,107,107,REDISMODULE_ZADD_NX,,,0,
486860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2947:2947:ZADD_IN_NX:0,,true,2947,2947,ZADD_IN_NX,,,0,
486863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:111:111:REDISMODULE_ZADD_GT:0,,true,111,111,REDISMODULE_ZADD_GT,,,0,
486866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2949:2949:ZADD_IN_GT:0,,true,2949,2949,ZADD_IN_GT,,,0,
486869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:112:112:REDISMODULE_ZADD_LT:0,,true,112,112,REDISMODULE_ZADD_LT,,,0,
486872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2950:2950:ZADD_IN_LT:0,,true,2950,2950,ZADD_IN_LT,,,0,
486875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2955:2955:ZADD_OUT_ADDED:0,,true,2955,2955,ZADD_OUT_ADDED,,,0,
486878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:108:108:REDISMODULE_ZADD_ADDED:0,,true,108,108,REDISMODULE_ZADD_ADDED,,,0,
486881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2956:2956:ZADD_OUT_UPDATED:0,,true,2956,2956,ZADD_OUT_UPDATED,,,0,
486884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:109:109:REDISMODULE_ZADD_UPDATED:0,,true,109,109,REDISMODULE_ZADD_UPDATED,,,0,
486887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2953:2953:ZADD_OUT_NOP:0,,true,2953,2953,ZADD_OUT_NOP,,,0,
486890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:110:110:REDISMODULE_ZADD_NOP:0,,true,110,110,REDISMODULE_ZADD_NOP,,,0,
486893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2946:2946:ZADD_IN_INCR:0,,true,2946,2946,ZADD_IN_INCR,,,0,
486896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:224:224:REDISMODULE_ZSET_RANGE_NONE:0,,true,224,224,REDISMODULE_ZSET_RANGE_NONE,,,0,
486899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:225:225:REDISMODULE_ZSET_RANGE_LEX:0,,true,225,225,REDISMODULE_ZSET_RANGE_LEX,,,0,
486902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:226:226:REDISMODULE_ZSET_RANGE_SCORE:0,,true,226,226,REDISMODULE_ZSET_RANGE_SCORE,,,0,
486905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:116:116:REDISMODULE_HASH_NX:0,,true,116,116,REDISMODULE_HASH_NX,,,0,
486908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:117:117:REDISMODULE_HASH_XX:0,,true,117,117,REDISMODULE_HASH_XX,,,0,
486911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:118:118:REDISMODULE_HASH_CFIELDS:0,,true,118,118,REDISMODULE_HASH_CFIELDS,,,0,
486914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:120:120:REDISMODULE_HASH_COUNT_ALL:0,,true,120,120,REDISMODULE_HASH_COUNT_ALL,,,0,
486917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:240:240:REDISMODULE_HASH_DELETE:0,,true,240,240,REDISMODULE_HASH_DELETE,,,0,
486920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3112:3112:HASH_SET_COPY:0,,true,3112,3112,HASH_SET_COPY,,,0,
486923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3110:3110:HASH_SET_TAKE_FIELD:0,,true,3110,3110,HASH_SET_TAKE_FIELD,,,0,
486926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:119:119:REDISMODULE_HASH_EXISTS:0,,true,119,119,REDISMODULE_HASH_EXISTS,,,0,
486929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:139:139:REDISMODULE_STREAM_ADD_AUTOID:0,,true,139,139,REDISMODULE_STREAM_ADD_AUTOID,,,0,
486932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:141:141:REDISMODULE_STREAM_ITERATOR_EXCLUSIVE:0,,true,141,141,REDISMODULE_STREAM_ITERATOR_EXCLUSIVE,,,0,
486935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:142:142:REDISMODULE_STREAM_ITERATOR_REVERSE:0,,true,142,142,REDISMODULE_STREAM_ITERATOR_REVERSE,,,0,
486938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:144:144:REDISMODULE_STREAM_TRIM_APPROX:0,,true,144,144,REDISMODULE_STREAM_TRIM_APPROX,,,0,
486941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_arg,,true,,,va_arg,,,0,
486946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:388:388:REDISMODULE_ARGV_REPLICATE:0,,true,388,388,REDISMODULE_ARGV_REPLICATE,,,0,
486949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:391:391:REDISMODULE_ARGV_RESP_3:0,,true,391,391,REDISMODULE_ARGV_RESP_3,,,0,
486952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:392:392:REDISMODULE_ARGV_RESP_AUTO:0,,true,392,392,REDISMODULE_ARGV_RESP_AUTO,,,0,
486955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:393:393:REDISMODULE_ARGV_RUN_AS_USER:0,,true,393,393,REDISMODULE_ARGV_RUN_AS_USER,,,0,
486958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:394:394:REDISMODULE_ARGV_SCRIPT_MODE:0,,true,394,394,REDISMODULE_ARGV_SCRIPT_MODE,,,0,
486961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:395:395:REDISMODULE_ARGV_NO_WRITES:0,,true,395,395,REDISMODULE_ARGV_NO_WRITES,,,0,
486964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:397:397:REDISMODULE_ARGV_RESPECT_DENY_OOM:0,,true,397,397,REDISMODULE_ARGV_RESPECT_DENY_OOM,,,0,
486967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:396:396:REDISMODULE_ARGV_CALL_REPLIES_AS_ERRORS:0,,true,396,396,REDISMODULE_ARGV_CALL_REPLIES_AS_ERRORS,,,0,
486970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:398:398:REDISMODULE_ARGV_DRY_RUN:0,,true,398,398,REDISMODULE_ARGV_DRY_RUN,,,0,
486973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:399:399:REDISMODULE_ARGV_ALLOW_BLOCK:0,,true,399,399,REDISMODULE_ARGV_ALLOW_BLOCK,,,0,
486976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:395:395:CLIENT_ALLOW_OOM:0,,true,395,395,CLIENT_ALLOW_OOM,,,0,
486979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2843:2843:DISK_ERROR_TYPE_NONE:0,,true,2843,2843,DISK_ERROR_TYPE_NONE,,,0,
486982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:595:595:CMD_CALL_FROM_MODULE:0,,true,595,595,CMD_CALL_FROM_MODULE,,,0,
486985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:592:592:CMD_CALL_PROPAGATE_AOF:0,,true,592,592,CMD_CALL_PROPAGATE_AOF,,,0,
486988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:593:593:CMD_CALL_PROPAGATE_REPL:0,,true,593,593,CMD_CALL_PROPAGATE_REPL,,,0,
486991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:401:401:CLIENT_MODULE_PREVENT_AOF_PROP:0,,true,401,401,CLIENT_MODULE_PREVENT_AOF_PROP,,,0,
486994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:402:402:CLIENT_MODULE_PREVENT_REPL_PROP:0,,true,402,402,CLIENT_MODULE_PREVENT_REPL_PROP,,,0,
486997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:6612:6612:MODULE_LOOKUP_CACHE_SIZE:0,,true,6612,6612,MODULE_LOOKUP_CACHE_SIZE,,,0,
487000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.copy2,,true,,,copy2,,,0,
487006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.copy,,true,,,copy,,,0,
487013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:293:293:REDISMODULE_OPTIONS_HANDLE_IO_ERRORS:0,,true,293,293,REDISMODULE_OPTIONS_HANDLE_IO_ERRORS,,,0,
487016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:301:301:REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD:0,,true,301,301,REDISMODULE_OPTIONS_HANDLE_REPL_ASYNC_LOAD,,,0,
487019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:121:121:RDB_MODULE_OPCODE_UINT:0,,true,121,121,RDB_MODULE_OPCODE_UINT,,,0,
487022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:124:124:RDB_MODULE_OPCODE_STRING:0,,true,124,124,RDB_MODULE_OPCODE_STRING,,,0,
487025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:129:129:RDB_LOAD_PLAIN:0,,true,129,129,RDB_LOAD_PLAIN,,,0,
487028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:127:127:RDB_LOAD_NONE:0,,true,127,127,RDB_LOAD_NONE,,,0,
487031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:123:123:RDB_MODULE_OPCODE_DOUBLE:0,,true,123,123,RDB_MODULE_OPCODE_DOUBLE,,,0,
487034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:122:122:RDB_MODULE_OPCODE_FLOAT:0,,true,122,122,RDB_MODULE_OPCODE_FLOAT,,,0,
487037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.rdb_load,,true,,,rdb_load,,,0,
487043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.rdb_save,,true,,,rdb_save,,,0,
487049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:173:173:REDISMODULE_CTX_NONE:0,,true,173,173,REDISMODULE_CTX_NONE,,,0,
487052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleBlockedClient.disconnect_callback,,true,,,disconnect_callback,,,0,
487058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:176:176:REDISMODULE_CTX_BLOCKED_REPLY:0,,true,176,176,REDISMODULE_CTX_BLOCKED_REPLY,,,0,
487061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:874:874:clientHasModuleAuthInProgress:1,,true,874,874,clientHasModuleAuthInProgress,,,0,
487065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:279:279:REDISMODULE_BLOCK_UNBLOCK_DELETED:0,,true,279,279,REDISMODULE_BLOCK_UNBLOCK_DELETED,,,0,
487068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:179:179:REDISMODULE_CTX_BLOCKED_DISCONNECTED:0,,true,179,179,REDISMODULE_CTX_BLOCKED_DISCONNECTED,,,0,
487071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:39:39:REDISMODULE_AUTH_NOT_HANDLED:0,,true,39,39,REDISMODULE_AUTH_NOT_HANDLED,,,0,
487074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:399:399:CLIENT_MODULE_AUTH_HAS_RESULT:0,,true,399,399,CLIENT_MODULE_AUTH_HAS_RESULT,,,0,
487077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleAuthCtx.auth_cb,,true,,,auth_cb,,,0,
487085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:38:38:REDISMODULE_AUTH_HANDLED:0,,true,38,38,REDISMODULE_AUTH_HANDLED,,,0,
487088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleBlockedClient.auth_reply_cb,,true,,,auth_reply_cb,,,0,
487096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleBlockedClient.reply_callback,,true,,,reply_callback,,,0,
487103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:358:358:CLIENT_PENDING_WRITE:0,,true,358,358,CLIENT_PENDING_WRITE,,,0,
487106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:177:177:REDISMODULE_CTX_BLOCKED_TIMEOUT:0,,true,177,177,REDISMODULE_CTX_BLOCKED_TIMEOUT,,,0,
487109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleBlockedClient.timeout_callback,,true,,,timeout_callback,,,0,
487116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_trylock,,true,,,pthread_mutex_trylock,,,0,
487120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModulePostExecUnitJob.callback,,true,,,callback,,,0,
487126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:649:649:NOTIFY_KEYEVENT:0,,true,649,649,NOTIFY_KEYEVENT,,,0,
487129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:648:648:NOTIFY_KEYSPACE:0,,true,648,648,NOTIFY_KEYSPACE,,,0,
487132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:305:305:REDISMODULE_OPTIONS_ALLOW_NESTED_KEYSPACE_NOTIFICATIONS:0,,true,305,305,REDISMODULE_OPTIONS_ALLOW_NESTED_KEYSPACE_NOTIFICATIONS,,,0,
487135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleKeyspaceSubscriber.notify_callback,,true,,,notify_callback,,,0,
487143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,moduleClusterReceiver.callback,,true,,,callback,,,0,
487152,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:249:249:REDISMODULE_NODE_ID_LEN:0,,true,249,249,REDISMODULE_NODE_ID_LEN,,,0,
487155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:250:250:REDISMODULE_NODE_MYSELF:0,,true,250,250,REDISMODULE_NODE_MYSELF,,,0,
487158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:251:251:REDISMODULE_NODE_MASTER:0,,true,251,251,REDISMODULE_NODE_MASTER,,,0,
487161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:252:252:REDISMODULE_NODE_SLAVE:0,,true,252,252,REDISMODULE_NODE_SLAVE,,,0,
487164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:253:253:REDISMODULE_NODE_PFAIL:0,,true,253,253,REDISMODULE_NODE_PFAIL,,,0,
487167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:254:254:REDISMODULE_NODE_FAIL:0,,true,254,254,REDISMODULE_NODE_FAIL,,,0,
487170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:255:255:REDISMODULE_NODE_NOFAILOVER:0,,true,255,255,REDISMODULE_NODE_NOFAILOVER,,,0,
487173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:258:258:REDISMODULE_CLUSTER_FLAG_NO_FAILOVER:0,,true,258,258,REDISMODULE_CLUSTER_FLAG_NO_FAILOVER,,,0,
487176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:259:259:REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION:0,,true,259,259,REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION,,,0,
487179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleTimer.callback,,true,,,callback,,,0,
487185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:474:474:REDISMODULE_EVENTLOOP_READABLE:0,,true,474,474,REDISMODULE_EVENTLOOP_READABLE,,,0,
487188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:475:475:REDISMODULE_EVENTLOOP_WRITABLE:0,,true,475,475,REDISMODULE_EVENTLOOP_WRITABLE,,,0,
487191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EventLoopData.rFunc,,true,,,rFunc,,,0,
487198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EventLoopData.wFunc,,true,,,wFunc,,,0,
487205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EventLoopOneShot.func,,true,,,func,,,0,
487210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,client.auth_callback,,true,,,auth_callback,,,0,
487216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModule.info_cb,,true,,,info_cb,,,0,
487222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:290:290:REDISMODULE_CMDFILTER_NOSELF:0,,true,290,290,REDISMODULE_CMDFILTER_NOSELF,,,0,
487225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleCommandFilter.callback,,true,,,callback,,,0,
487230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.fn,,true,,,fn,,,0,
487238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_1.fn,,true,,,fn,,,0,
487246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1525:1525:CHILD_TYPE_MODULE:0,,true,1525,1525,CHILD_TYPE_MODULE,,,0,
487249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleForkInfo.done_handler,,true,,,done_handler,,,0,
487256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:727:727:REDISMODULE_REPLICATIONINFO_VERSION:0,,true,727,727,REDISMODULE_REPLICATIONINFO_VERSION,,,0,
487259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:713:713:REDISMODULE_CLIENTINFO_VERSION:0,,true,713,713,REDISMODULE_CLIENTINFO_VERSION,,,0,
487262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:776:776:REDISMODULE_CRON_LOOP_VERSION:0,,true,776,776,REDISMODULE_CRON_LOOP_VERSION,,,0,
487265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:754:754:REDISMODULE_MODULE_CHANGE_VERSION:0,,true,754,754,REDISMODULE_MODULE_CHANGE_VERSION,,,0,
487268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:786:786:REDISMODULE_LOADING_PROGRESS_VERSION:0,,true,786,786,REDISMODULE_LOADING_PROGRESS_VERSION,,,0,
487271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:809:809:REDISMODULE_KEYINFO_VERSION:0,,true,809,809,REDISMODULE_KEYINFO_VERSION,,,0,
487274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:501:501:_REDISMODULE_EVENT_NEXT:0,,true,501,501,_REDISMODULE_EVENT_NEXT,,,0,
487277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:483:483:REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED:0,,true,483,483,REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED,,,0,
487280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:644:644:_REDISMODULE_EVENT_REPLROLECHANGED_NEXT:0,,true,644,644,_REDISMODULE_EVENT_REPLROLECHANGED_NEXT,,,0,
487283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:484:484:REDISMODULE_EVENT_PERSISTENCE:0,,true,484,484,REDISMODULE_EVENT_PERSISTENCE,,,0,
487286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:621:621:_REDISMODULE_SUBEVENT_PERSISTENCE_NEXT:0,,true,621,621,_REDISMODULE_SUBEVENT_PERSISTENCE_NEXT,,,0,
487289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:648:648:_REDISMODULE_SUBEVENT_FLUSHDB_NEXT:0,,true,648,648,_REDISMODULE_SUBEVENT_FLUSHDB_NEXT,,,0,
487292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:486:486:REDISMODULE_EVENT_LOADING:0,,true,486,486,REDISMODULE_EVENT_LOADING,,,0,
487295,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:628:628:_REDISMODULE_SUBEVENT_LOADING_NEXT:0,,true,628,628,_REDISMODULE_SUBEVENT_LOADING_NEXT,,,0,
487298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:487:487:REDISMODULE_EVENT_CLIENT_CHANGE:0,,true,487,487,REDISMODULE_EVENT_CLIENT_CHANGE,,,0,
487301,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:632:632:_REDISMODULE_SUBEVENT_CLIENT_CHANGE_NEXT:0,,true,632,632,_REDISMODULE_SUBEVENT_CLIENT_CHANGE_NEXT,,,0,
487304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:488:488:REDISMODULE_EVENT_SHUTDOWN:0,,true,488,488,REDISMODULE_EVENT_SHUTDOWN,,,0,
487307,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:686:686:_REDISMODULE_SUBEVENT_SHUTDOWN_NEXT:0,,true,686,686,_REDISMODULE_SUBEVENT_SHUTDOWN_NEXT,,,0,
487310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:489:489:REDISMODULE_EVENT_REPLICA_CHANGE:0,,true,489,489,REDISMODULE_EVENT_REPLICA_CHANGE,,,0,
487313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:490:490:REDISMODULE_EVENT_MASTER_LINK_CHANGE:0,,true,490,490,REDISMODULE_EVENT_MASTER_LINK_CHANGE,,,0,
487316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:636:636:_REDISMODULE_SUBEVENT_MASTER_NEXT:0,,true,636,636,_REDISMODULE_SUBEVENT_MASTER_NEXT,,,0,
487319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:491:491:REDISMODULE_EVENT_CRON_LOOP:0,,true,491,491,REDISMODULE_EVENT_CRON_LOOP,,,0,
487322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:687:687:_REDISMODULE_SUBEVENT_CRON_LOOP_NEXT:0,,true,687,687,_REDISMODULE_SUBEVENT_CRON_LOOP_NEXT,,,0,
487325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:492:492:REDISMODULE_EVENT_MODULE_CHANGE:0,,true,492,492,REDISMODULE_EVENT_MODULE_CHANGE,,,0,
487328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:652:652:_REDISMODULE_SUBEVENT_MODULE_NEXT:0,,true,652,652,_REDISMODULE_SUBEVENT_MODULE_NEXT,,,0,
487331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:493:493:REDISMODULE_EVENT_LOADING_PROGRESS:0,,true,493,493,REDISMODULE_EVENT_LOADING_PROGRESS,,,0,
487334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:659:659:_REDISMODULE_SUBEVENT_LOADING_PROGRESS_NEXT:0,,true,659,659,_REDISMODULE_SUBEVENT_LOADING_PROGRESS_NEXT,,,0,
487337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:688:688:_REDISMODULE_SUBEVENT_SWAPDB_NEXT:0,,true,688,688,_REDISMODULE_SUBEVENT_SWAPDB_NEXT,,,0,
487340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:497:497:REDISMODULE_EVENT_REPL_ASYNC_LOAD:0,,true,497,497,REDISMODULE_EVENT_REPL_ASYNC_LOAD,,,0,
487343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:670:670:_REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_NEXT:0,,true,670,670,_REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_NEXT,,,0,
487346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:496:496:REDISMODULE_EVENT_FORK_CHILD:0,,true,496,496,REDISMODULE_EVENT_FORK_CHILD,,,0,
487349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:674:674:_REDISMODULE_SUBEVENT_FORK_CHILD_NEXT:0,,true,674,674,_REDISMODULE_SUBEVENT_FORK_CHILD_NEXT,,,0,
487352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:498:498:REDISMODULE_EVENT_EVENTLOOP:0,,true,498,498,REDISMODULE_EVENT_EVENTLOOP,,,0,
487355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:678:678:_REDISMODULE_SUBEVENT_EVENTLOOP_NEXT:0,,true,678,678,_REDISMODULE_SUBEVENT_EVENTLOOP_NEXT,,,0,
487358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:655:655:_REDISMODULE_SUBEVENT_CONFIG_NEXT:0,,true,655,655,_REDISMODULE_SUBEVENT_CONFIG_NEXT,,,0,
487361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:500:500:REDISMODULE_EVENT_KEY:0,,true,500,500,REDISMODULE_EVENT_KEY,,,0,
487364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:684:684:_REDISMODULE_SUBEVENT_KEY_NEXT:0,,true,684,684,_REDISMODULE_SUBEVENT_KEY_NEXT,,,0,
487367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleEventListener.callback,,true,,,callback,,,0,
487375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:658:658:REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF:0,,true,658,658,REDISMODULE_SUBEVENT_LOADING_PROGRESS_AOF,,,0,
487378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:657:657:REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB:0,,true,657,657,REDISMODULE_SUBEVENT_LOADING_PROGRESS_RDB,,,0,
487381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:680:680:REDISMODULE_SUBEVENT_KEY_DELETED:0,,true,680,680,REDISMODULE_SUBEVENT_KEY_DELETED,,,0,
487384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:681:681:REDISMODULE_SUBEVENT_KEY_EXPIRED:0,,true,681,681,REDISMODULE_SUBEVENT_KEY_EXPIRED,,,0,
487387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:682:682:REDISMODULE_SUBEVENT_KEY_EVICTED:0,,true,682,682,REDISMODULE_SUBEVENT_KEY_EVICTED,,,0,
487390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:683:683:REDISMODULE_SUBEVENT_KEY_OVERWRITTEN:0,,true,683,683,REDISMODULE_SUBEVENT_KEY_OVERWRITTEN,,,0,
487393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.unlink2,,true,,,unlink2,,,0,
487399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.unlink,,true,,,unlink,,,0,
487405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.free_effort2,,true,,,free_effort2,,,0,
487411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.free_effort,,true,,,free_effort,,,0,
487417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.mem_usage2,,true,,,mem_usage2,,,0,
487424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.mem_usage,,true,,,mem_usage,,,0,
487429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_close,,true,,,hdr_close,,,0,
487433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlopen,,true,,,dlopen,,,0,
487438,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlerror,,true,,,dlerror,,,0,
487441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlsym,,true,,,dlsym,,,0,
487446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dlclose,,true,,,dlclose,,,0,
487450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onload,,true,,,onload,,,0,
487456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:650:650:REDISMODULE_SUBEVENT_MODULE_LOADED:0,,true,650,650,REDISMODULE_SUBEVENT_MODULE_LOADED,,,0,
487459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onunload,,true,,,onunload,,,0,
487463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:651:651:REDISMODULE_SUBEVENT_MODULE_UNLOADED:0,,true,651,651,REDISMODULE_SUBEVENT_MODULE_UNLOADED,,,0,
487466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:298:298:REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED:0,,true,298,298,REDISMODULE_OPTION_NO_IMPLICIT_SIGNAL_MODIFIED,,,0,
487469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:122:122:REDISMODULE_CONFIG_DEFAULT:0,,true,122,122,REDISMODULE_CONFIG_DEFAULT,,,0,
487472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:123:123:REDISMODULE_CONFIG_IMMUTABLE:0,,true,123,123,REDISMODULE_CONFIG_IMMUTABLE,,,0,
487475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:124:124:REDISMODULE_CONFIG_SENSITIVE:0,,true,124,124,REDISMODULE_CONFIG_SENSITIVE,,,0,
487478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:125:125:REDISMODULE_CONFIG_HIDDEN:0,,true,125,125,REDISMODULE_CONFIG_HIDDEN,,,0,
487481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:126:126:REDISMODULE_CONFIG_PROTECTED:0,,true,126,126,REDISMODULE_CONFIG_PROTECTED,,,0,
487484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:127:127:REDISMODULE_CONFIG_DENY_LOADING:0,,true,127,127,REDISMODULE_CONFIG_DENY_LOADING,,,0,
487487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:130:130:REDISMODULE_CONFIG_BITFLAGS:0,,true,130,130,REDISMODULE_CONFIG_BITFLAGS,,,0,
487490,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:129:129:REDISMODULE_CONFIG_MEMORY:0,,true,129,129,REDISMODULE_CONFIG_MEMORY,,,0,
487493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:12449:12449:CONFIG_ERR_SIZE:0,,true,12449,12449,CONFIG_ERR_SIZE,,,0,
487496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fn.set_bool,,true,,,set_bool,,,0,
487504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fn.set_string,,true,,,set_string,,,0,
487512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fn.set_enum,,true,,,set_enum,,,0,
487520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_fn.set_numeric,,true,,,set_numeric,,,0,
487528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_fn.get_bool,,true,,,get_bool,,,0,
487534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_fn.get_string,,true,,,get_string,,,0,
487540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_fn.get_enum,,true,,,get_enum,,,0,
487546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get_fn.get_numeric,,true,,,get_numeric,,,0,
487552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModuleConfig.apply_fn,,true,,,apply_fn,,,0,
487559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3153:3153:MODIFIABLE_CONFIG:0,,true,3153,3153,MODIFIABLE_CONFIG,,,0,
487562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:12840:12840:REDISMODULE_RDB_STREAM_FILE:0,,true,12840,12840,REDISMODULE_RDB_STREAM_FILE,,,0,
487565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:326:326:RDB_NOT_EXIST:0,,true,326,326,RDB_NOT_EXIST,,,0,
487568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:310:310:_REDISMODULE_OPTIONS_FLAGS_NEXT:0,,true,310,310,_REDISMODULE_OPTIONS_FLAGS_NEXT,,,0,
487571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:210:210:_REDISMODULE_CTX_FLAGS_NEXT:0,,true,210,210,_REDISMODULE_CTX_FLAGS_NEXT,,,0,
487574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:234:234:_REDISMODULE_NOTIFY_NEXT:0,,true,234,234,_REDISMODULE_NOTIFY_NEXT,,,0,
487577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,version.h,version.h:2:2:REDIS_VERSION_NUM:0,,true,2,2,REDIS_VERSION_NUM,,,0,
487580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:46:46:REDISMODULE_TYPE_METHOD_VERSION:0,,true,46,46,REDISMODULE_TYPE_METHOD_VERSION,,,0,
487583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.defrag,,true,,,defrag,,,0,
487590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModule.defrag_cb,,true,,,defrag_cb,,,0,
487595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,module.c,module.c:11823:11824:REGISTER_API:1,,true,11823,11824,REGISTER_API,,,0,
487598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:261:261:REDISMODULE_NOT_USED:1,,true,261,261,REDISMODULE_NOT_USED,,,0,
487602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,modules\helloacl.c,modules\helloacl.c:94:94:TIMEOUT_TIME:0,,true,94,94,TIMEOUT_TIME,,,0,
487605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:42:42:REDISMODULE_APIVER_1:0,,true,42,42,REDISMODULE_APIVER_1,,,0,
487608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sleep,,true,,,sleep,,,0,
487612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,modules\hellocluster.c,modules\hellocluster.c:39:39:MSGTYPE_PING:0,,true,39,39,MSGTYPE_PING,,,0,
487615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,modules\hellocluster.c,modules\hellocluster.c:40:40:MSGTYPE_PONG:0,,true,40,40,MSGTYPE_PONG,,,0,
487618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:723:723:RedisModuleClientInfo:0,,true,723,723,RedisModuleClientInfo,,,0,
487621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:630:630:REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED:0,,true,630,630,REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED,,,0,
487624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:752:752:RedisModuleFlushInfo:0,,true,752,752,RedisModuleFlushInfo,,,0,
487627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:243:243:REDISMODULE_ERRORMSG_WRONGTYPE:0,,true,243,243,REDISMODULE_ERRORMSG_WRONGTYPE,,,0,
487630,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isupper,,true,,,isupper,,,0,
487634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:115:115:REDISMODULE_HASH_NONE:0,,true,115,115,REDISMODULE_HASH_NONE,,,0,
487637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clock_gettime,,true,,,clock_gettime,,,0,
487642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mt19937-64.c,mt19937-64.c:60:60:NN:0,,true,60,60,NN,,,0,
487645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mt19937-64.c,mt19937-64.c:62:62:MATRIX_A:0,,true,62,62,MATRIX_A,,,0,
487648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mt19937-64.c,mt19937-64.c:61:61:MM:0,,true,61,61,MM,,,0,
487651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mt19937-64.c,mt19937-64.c:63:63:UM:0,,true,63,63,UM,,,0,
487654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,mt19937-64.c,mt19937-64.c:64:64:LM:0,,true,64,64,LM,,,0,
487657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:591:591:CMD_CALL_NONE:0,,true,591,591,CMD_CALL_NONE,,,0,
487660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:597:597:CMD_CALL_FULL:0,,true,597,597,CMD_CALL_FULL,,,0,
487663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:106:107:redis_member2struct:3,,true,106,107,redis_member2struct,,,0,
487669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,offsetof,,true,,,offsetof,,,0,
487674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicGetIncr,,true,,,atomicGetIncr,,,0,
487680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:475:475:SLAVE_CAPA_NONE:0,,true,475,475,SLAVE_CAPA_NONE,,,0,
487683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:426:426:CLIENT_TYPE_NORMAL:0,,true,426,426,CLIENT_TYPE_NORMAL,,,0,
487686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:470:470:SLAVE_STATE_ONLINE:0,,true,470,470,SLAVE_STATE_ONLINE,,,0,
487689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:360:360:CLIENT_REPLY_OFF:0,,true,360,360,CLIENT_REPLY_OFF,,,0,
487692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:362:362:CLIENT_REPLY_SKIP:0,,true,362,362,CLIENT_REPLY_SKIP,,,0,
487695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:349:349:CLIENT_MASTER_FORCE_REPLY:0,,true,349,349,CLIENT_MASTER_FORCE_REPLY,,,0,
487698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2431:2431:IO_THREADS_OP_IDLE:0,,true,2431,2431,IO_THREADS_OP_IDLE,,,0,
487701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:427:427:CLIENT_TYPE_SLAVE:0,,true,427,427,CLIENT_TYPE_SLAVE,,,0,
487704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2532:2532:ERR_REPLY_FLAG_NO_STATS_UPDATE:0,,true,2532,2532,ERR_REPLY_FLAG_NO_STATS_UPDATE,,,0,
487707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memchr,,true,,,memchr,,,0,
487713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_copy,,true,,,va_copy,,,0,
487718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:123:123:OBJ_SHARED_HDR_STRLEN:1,,true,123,123,OBJ_SHARED_HDR_STRLEN,,,0,
487722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:122:122:OBJ_SHARED_BULKHDR_LEN:0,,true,122,122,OBJ_SHARED_BULKHDR_LEN,,,0,
487725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:468:468:SLAVE_STATE_WAIT_BGSAVE_END:0,,true,468,468,SLAVE_STATE_WAIT_BGSAVE_END,,,0,
487728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:335:335:CLIENT_SLAVE:0,,true,335,335,CLIENT_SLAVE,,,0,
487731,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:337:337:CLIENT_MONITOR:0,,true,337,337,CLIENT_MONITOR,,,0,
487734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:361:361:CLIENT_REPLY_SKIP_NEXT:0,,true,361,361,CLIENT_REPLY_SKIP_NEXT,,,0,
487737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:393:393:CLIENT_NO_EVICT:0,,true,393,393,CLIENT_NO_EVICT,,,0,
487740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:366:366:CLIENT_PROTECTED:0,,true,366,366,CLIENT_PROTECTED,,,0,
487743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:631:631:REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED:0,,true,631,631,REDISMODULE_SUBEVENT_CLIENT_CHANGE_DISCONNECTED,,,0,
487746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:385:385:CLIENT_PROTOCOL_ERROR:0,,true,385,385,CLIENT_PROTOCOL_ERROR,,,0,
487749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:643:643:RDB_CHILD_TYPE_DISK:0,,true,643,643,RDB_CHILD_TYPE_DISK,,,0,
487752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:469:469:SLAVE_STATE_SEND_BULK:0,,true,469,469,SLAVE_STATE_SEND_BULK,,,0,
487755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:639:639:REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE:0,,true,639,639,REDISMODULE_SUBEVENT_REPLICA_CHANGE_OFFLINE,,,0,
487758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ssize_t,,true,,,ssize_t,,,0,
487762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:61:61:listNextNode:1,,true,61,61,listNextNode,,,0,
487766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:490:490:REPL_BACKLOG_TRIM_BLOCKS_PER_CALL:0,,true,490,490,REPL_BACKLOG_TRIM_BLOCKS_PER_CALL,,,0,
487769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:367:367:CLIENT_EXECUTING_COMMAND:0,,true,367,367,CLIENT_EXECUTING_COMMAND,,,0,
487772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:380:380:CLIENT_TRACKING_CACHING:0,,true,380,380,CLIENT_TRACKING_CACHING,,,0,
487775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:178:178:PROTO_INLINE_MAX_SIZE:0,,true,178,178,PROTO_INLINE_MAX_SIZE,,,0,
487778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,networking.c,networking.c:2212:2212:PROTO_DUMP_LEN:0,,true,2212,2212,PROTO_DUMP_LEN,,,0,
487781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isprint,,true,,,isprint,,,0,
487785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:179:179:PROTO_MBULK_BIG_ARG:0,,true,179,179,PROTO_MBULK_BIG_ARG,,,0,
487788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:422:422:PROTO_REQ_MULTIBULK:0,,true,422,422,PROTO_REQ_MULTIBULK,,,0,
487791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:421:421:PROTO_REQ_INLINE:0,,true,421,421,PROTO_REQ_INLINE,,,0,
487794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:176:176:PROTO_IOBUF_LEN:0,,true,176,176,PROTO_IOBUF_LEN,,,0,
487797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:376:376:CLIENT_TRACKING_BROKEN_REDIR:0,,true,376,376,CLIENT_TRACKING_BROKEN_REDIR,,,0,
487800,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:377:377:CLIENT_TRACKING_BCAST:0,,true,377,377,CLIENT_TRACKING_BCAST,,,0,
487803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:378:378:CLIENT_TRACKING_OPTIN:0,,true,378,378,CLIENT_TRACKING_OPTIN,,,0,
487806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:379:379:CLIENT_TRACKING_OPTOUT:0,,true,379,379,CLIENT_TRACKING_OPTOUT,,,0,
487809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:382:382:CLIENT_TRACKING_NOLOOP:0,,true,382,382,CLIENT_TRACKING_NOLOOP,,,0,
487812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llabs,,true,,,llabs,,,0,
487816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:605:605:PAUSE_ACTION_CLIENT_WRITE:0,,true,605,605,PAUSE_ACTION_CLIENT_WRITE,,,0,
487819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:606:606:PAUSE_ACTION_CLIENT_ALL:0,,true,606,606,PAUSE_ACTION_CLIENT_ALL,,,0,
487822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:616:619:PAUSE_ACTIONS_CLIENT_ALL_SET:0,,true,616,619,PAUSE_ACTIONS_CLIENT_ALL_SET,,,0,
487825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,networking.c,networking.c:4140:4140:IO_THREADS_MAX_NUM:0,,true,4140,4140,IO_THREADS_MAX_NUM,,,0,
487828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicGetWithSync,,true,,,atomicGetWithSync,,,0,
487833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atomicSetWithSync,,true,,,atomicSetWithSync,,,0,
487838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2433:2433:IO_THREADS_OP_WRITE:0,,true,2433,2433,IO_THREADS_OP_WRITE,,,0,
487841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2432:2432:IO_THREADS_OP_READ:0,,true,2432,2432,IO_THREADS_OP_READ,,,0,
487844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:663:663:NOTIFY_ALL:0,,true,663,663,NOTIFY_ALL,,,0,
487847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:652:652:NOTIFY_LIST:0,,true,652,652,NOTIFY_LIST,,,0,
487850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:653:653:NOTIFY_SET:0,,true,653,653,NOTIFY_SET,,,0,
487853,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:654:654:NOTIFY_HASH:0,,true,654,654,NOTIFY_HASH,,,0,
487856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:658:658:NOTIFY_STREAM:0,,true,658,658,NOTIFY_STREAM,,,0,
487859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:661:661:NOTIFY_MODULE:0,,true,661,661,NOTIFY_MODULE,,,0,
487862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:896:896:OBJ_SHARED_REFCOUNT:0,,true,896,896,OBJ_SHARED_REFCOUNT,,,0,
487865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:77:77:SDS_TYPE_8:0,,true,77,77,SDS_TYPE_8,,,0,
487868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:122:122:OBJ_ENCODING_EMBSTR_SIZE_LIMIT:0,,true,122,122,OBJ_ENCODING_EMBSTR_SIZE_LIMIT,,,0,
487871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:121:121:OBJ_SHARED_INTEGERS:0,,true,121,121,OBJ_SHARED_INTEGERS,,,0,
487874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:146:146:LL2STROBJ_AUTO:0,,true,146,146,LL2STROBJ_AUTO,,,0,
487877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:148:148:LL2STROBJ_NO_INT_ENC:0,,true,148,148,LL2STROBJ_NO_INT_ENC,,,0,
487880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:566:567:MAXMEMORY_FLAG_NO_SHARED_INTEGERS:0,,true,566,567,MAXMEMORY_FLAG_NO_SHARED_INTEGERS,,,0,
487883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:147:147:LL2STROBJ_NO_SHARED:0,,true,147,147,LL2STROBJ_NO_SHARED,,,0,
487886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:885:885:OBJ_ENCODING_INTSET:0,,true,885,885,OBJ_ENCODING_INTSET,,,0,
487889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:889:889:OBJ_ENCODING_STREAM:0,,true,889,889,OBJ_ENCODING_STREAM,,,0,
487892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.free,,true,,,free,,,0,
487897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:898:898:OBJ_FIRST_SPECIAL_REFCOUNT:0,,true,898,898,OBJ_FIRST_SPECIAL_REFCOUNT,,,0,
487900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:151:152:quicklistNodeIsCompressed:1,,true,151,152,quicklistNodeIsCompressed,,,0,
487904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3365:3365:LUA_CMD_OBJCACHE_MAX_LEN:0,,true,3365,3365,LUA_CMD_OBJCACHE_MAX_LEN,,,0,
487907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:740:740:REDIS_COMPARE_COLL:0,,true,740,740,REDIS_COMPARE_COLL,,,0,
487910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strcoll,,true,,,strcoll,,,0,
487915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:739:739:REDIS_COMPARE_BINARY:0,,true,739,739,REDIS_COMPARE_BINARY,,,0,
487918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dictType.dictEntryMetadataSize(db->dict),,true,,,dictEntryMetadataSize(db->dict),,,0,
487923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,dict.h,dict.h:143:144:dictMetadataSize:1,,true,143,144,dictMetadataSize,,,0,
487927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dictType.dictMetadataSize(db->dict),,true,,,dictMetadataSize(db->dict),,,0,
487931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zmalloc.h,zmalloc.h:73:73:ZMALLOC_LIB:0,,true,73,73,ZMALLOC_LIB,,,0,
487934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,object.c,object.c:1001:1001:OBJ_COMPUTE_SIZE_DEF_SAMPLES:0,,true,1001,1001,OBJ_COMPUTE_SIZE_DEF_SAMPLES,,,0,
487937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dictType.dictMetadataSize(c->db->dict),,true,,,dictMetadataSize(c->db->dict),,,0,
487941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cmp,,true,,,cmp,,,0,
487946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,pqsort.c,pqsort.c:65:66:SWAPINIT:2,,true,65,66,SWAPINIT,,,0,
487951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,pqsort.c,pqsort.c:78:84:swap:2,,true,78,84,swap,,,0,
487956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,pqsort.c,pqsort.c:49:49:min:2,,true,49,49,min,,,0,
487959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,pqsort.c,pqsort.c:86:86:vecswap:3,,true,86,86,vecswap,,,0,
487964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pubsubtype.dictSize(type.clientPubSubChannels(c)),,true,,,dictSize(type.clientPubSubChannels(c)),,,0,
487969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:141:141:COMPRESS_MAX:0,,true,141,141,COMPRESS_MAX,,,0,
487972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:151:151:FILL_MAX:0,,true,151,151,FILL_MAX,,,0,
487975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:139:139:QUICKLIST_NODE_ENCODING_RAW:0,,true,139,139,QUICKLIST_NODE_ENCODING_RAW,,,0,
487978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:147:147:QUICKLIST_NODE_CONTAINER_PACKED:0,,true,147,147,QUICKLIST_NODE_CONTAINER_PACKED,,,0,
487981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:82:82:MIN_COMPRESS_BYTES:0,,true,82,82,MIN_COMPRESS_BYTES,,,0,
487984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:87:87:MIN_COMPRESS_IMPROVE:0,,true,87,87,MIN_COMPRESS_IMPROVE,,,0,
487987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:140:140:QUICKLIST_NODE_ENCODING_LZF:0,,true,140,140,QUICKLIST_NODE_ENCODING_LZF,,,0,
487990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:302:302:quicklistAllowsCompression:1,,true,302,302,quicklistAllowsCompression,,,0,
487994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:277:282:quicklistDecompressNode:1,,true,277,282,quicklistDecompressNode,,,0,
487998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:248:253:quicklistCompressNode:1,,true,248,253,quicklistCompressNode,,,0,
488002,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:381:387:quicklistCompress:2,,true,381,387,quicklistCompress,,,0,
488007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:144:144:likely:1,,true,144,144,likely,,,0,
488011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:451:451:sizeMeetsSafetyLimit:1,,true,451,451,sizeMeetsSafetyLimit,,,0,
488015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:145:145:unlikely:1,,true,145,145,unlikely,,,0,
488018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:79:79:SIZE_ESTIMATE_OVERHEAD:0,,true,79,79,SIZE_ESTIMATE_OVERHEAD,,,0,
488021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:146:146:QUICKLIST_NODE_CONTAINER_PLAIN:0,,true,146,146,QUICKLIST_NODE_CONTAINER_PLAIN,,,0,
488024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:527:530:quicklistNodeUpdateSz:1,,true,527,530,quicklistNodeUpdateSz,,,0,
488028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:211:211:AL_START_HEAD:0,,true,211,211,AL_START_HEAD,,,0,
488031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:212:212:AL_START_TAIL:0,,true,212,212,AL_START_TAIL,,,0,
488034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:149:149:QL_NODE_IS_PLAIN:1,,true,149,149,QL_NODE_IS_PLAIN,,,0,
488038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:55:55:isLargeElement:1,,true,55,55,isLargeElement,,,0,
488042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:120:124:resetIterator:1,,true,120,124,resetIterator,,,0,
488046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:285:291:quicklistDecompressNodeForUse:1,,true,285,291,quicklistDecompressNodeForUse,,,0,
488050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:390:394:quicklistRecompressOnly:1,,true,390,394,quicklistRecompressOnly,,,0,
488054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:633:639:quicklistDeleteIfEmpty:2,,true,633,639,quicklistDeleteIfEmpty,,,0,
488059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:108:116:initEntry:1,,true,108,116,initEntry,,,0,
488063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,nextFn,,true,,,nextFn,,,0,
488068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:135:135:QUICKLIST_HEAD:0,,true,135,135,QUICKLIST_HEAD,,,0,
488071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.h,quicklist.h:136:136:QUICKLIST_TAIL:0,,true,136,136,QUICKLIST_TAIL,,,0,
488074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,saver,,true,,,saver,,,0,
488079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,quicklist.c,quicklist.c:102:102:QL_MAX_BM:0,,true,102,102,QL_MAX_BM,,,0,
488082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:54:54:X0:0,,true,54,54,X0,,,0,
488085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:55:55:X1:0,,true,55,55,X1,,,0,
488088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:56:56:X2:0,,true,56,56,X2,,,0,
488091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:57:57:A0:0,,true,57,57,A0,,,0,
488094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:58:58:A1:0,,true,58,58,A1,,,0,
488097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:59:59:A2:0,,true,59,59,A2,,,0,
488100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:60:60:C:0,,true,60,60,C,,,0,
488103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:46:46:N:0,,true,46,46,N,,,0,
488106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:63:63:SEED:3,,true,63,63,SEED,,,0,
488109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:50:51:MUL:3,,true,50,51,MUL,,,0,
488115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:53:53:ADDEQU:3,,true,53,53,ADDEQU,,,0,
488121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,int32_t,,true,,,int32_t,,,0,
488125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.c,rand.c:48:48:LOW:1,,true,48,48,LOW,,,0,
488129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.h,rax.h:142:142:RAX_STACK_STATIC_ITEMS:0,,true,142,142,RAX_STACK_STATIC_ITEMS,,,0,
488132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax_malloc.h,rax_malloc.h:41:41:rax_malloc:0,,true,41,41,rax_malloc,,,0,
488135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax_malloc.h,rax_malloc.h:42:42:rax_realloc:0,,true,42,42,rax_realloc,,,0,
488138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax_malloc.h,rax_malloc.h:43:43:rax_free:0,,true,43,43,rax_free,,,0,
488141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.c,rax.c:157:157:raxPadding:1,,true,157,157,raxPadding,,,0,
488145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.c,rax.c:177:182:raxNodeCurrentLength:1,,true,177,182,raxNodeCurrentLength,,,0,
488149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.c,rax.c:169:172:raxNodeFirstChildPtr:1,,true,169,172,raxNodeFirstChildPtr,,,0,
488153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.c,rax.c:161:166:raxNodeLastChildPtr:1,,true,161,166,raxNodeLastChildPtr,,,0,
488157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.h,rax.h:97:97:RAX_NODE_MAX_SIZE:0,,true,97,97,RAX_NODE_MAX_SIZE,,,0,
488160,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free_callback,,true,,,free_callback,,,0,
488164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.h,rax.h:172:172:RAX_ITER_EOF:0,,true,172,172,RAX_ITER_EOF,,,0,
488167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.h,rax.h:168:168:RAX_ITER_STATIC_LEN:0,,true,168,168,RAX_ITER_STATIC_LEN,,,0,
488170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rax.h,rax.h:169:169:RAX_ITER_JUST_SEEKED:0,,true,169,169,RAX_ITER_JUST_SEEKED,,,0,
488173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,raxIterator.node_cb,,true,,,node_cb,,,0,
488178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,log,,true,,,log,,,0,
488182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,putchar,,true,,,putchar,,,0,
488186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.c,rdb.c:56:57:isRestoreContext:0,,true,56,57,isRestoreContext,,,0,
488189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:57:57:RDB_6BITLEN:0,,true,57,57,RDB_6BITLEN,,,0,
488192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:58:58:RDB_14BITLEN:0,,true,58,58,RDB_14BITLEN,,,0,
488195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:59:59:RDB_32BITLEN:0,,true,59,59,RDB_32BITLEN,,,0,
488198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:60:60:RDB_64BITLEN:0,,true,60,60,RDB_64BITLEN,,,0,
488201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:61:61:RDB_ENCVAL:0,,true,61,61,RDB_ENCVAL,,,0,
488204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.c,rdb.c:51:51:rdbReportCorruptRDB:1,,true,51,51,rdbReportCorruptRDB,,,0,
488207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:62:62:RDB_LENERR:0,,true,62,62,RDB_LENERR,,,0,
488210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:67:67:RDB_ENC_INT8:0,,true,67,67,RDB_ENC_INT8,,,0,
488213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:68:68:RDB_ENC_INT16:0,,true,68,68,RDB_ENC_INT16,,,0,
488216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:69:69:RDB_ENC_INT32:0,,true,69,69,RDB_ENC_INT32,,,0,
488219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:130:130:RDB_LOAD_SDS:0,,true,130,130,RDB_LOAD_SDS,,,0,
488222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:128:128:RDB_LOAD_ENC:0,,true,128,128,RDB_LOAD_ENC,,,0,
488225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:70:70:RDB_ENC_LZF:0,,true,70,70,RDB_ENC_LZF,,,0,
488228,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isnan,,true,,,isnan,,,0,
488232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isfinite,,true,,,isfinite,,,0,
488236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sscanf,,true,,,sscanf,,,0,
488242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:75:75:RDB_TYPE_STRING:0,,true,75,75,RDB_TYPE_STRING,,,0,
488245,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:96:96:RDB_TYPE_LIST_QUICKLIST_2:0,,true,96,96,RDB_TYPE_LIST_QUICKLIST_2,,,0,
488248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:89:89:RDB_TYPE_SET_INTSET:0,,true,89,89,RDB_TYPE_SET_INTSET,,,0,
488251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:77:77:RDB_TYPE_SET:0,,true,77,77,RDB_TYPE_SET,,,0,
488254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:98:98:RDB_TYPE_SET_LISTPACK:0,,true,98,98,RDB_TYPE_SET_LISTPACK,,,0,
488257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:95:95:RDB_TYPE_ZSET_LISTPACK:0,,true,95,95,RDB_TYPE_ZSET_LISTPACK,,,0,
488260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:80:80:RDB_TYPE_ZSET_2:0,,true,80,80,RDB_TYPE_ZSET_2,,,0,
488263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:94:94:RDB_TYPE_HASH_LISTPACK:0,,true,94,94,RDB_TYPE_HASH_LISTPACK,,,0,
488266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:79:79:RDB_TYPE_HASH:0,,true,79,79,RDB_TYPE_HASH,,,0,
488269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:99:99:RDB_TYPE_STREAM_LISTPACKS_3:0,,true,99,99,RDB_TYPE_STREAM_LISTPACKS_3,,,0,
488272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:82:82:RDB_TYPE_MODULE_2:0,,true,82,82,RDB_TYPE_MODULE_2,,,0,
488275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:103:103:rdbIsObjectType:1,,true,103,103,rdbIsObjectType,,,0,
488279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:119:119:RDB_MODULE_OPCODE_EOF:0,,true,119,119,RDB_MODULE_OPCODE_EOF,,,0,
488282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:113:113:RDB_OPCODE_EXPIRETIME_MS:0,,true,113,113,RDB_OPCODE_EXPIRETIME_MS,,,0,
488285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:109:109:RDB_OPCODE_IDLE:0,,true,109,109,RDB_OPCODE_IDLE,,,0,
488288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:110:110:RDB_OPCODE_FREQ:0,,true,110,110,RDB_OPCODE_FREQ,,,0,
488291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:111:111:RDB_OPCODE_AUX:0,,true,111,111,RDB_OPCODE_AUX,,,0,
488294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:108:108:RDB_OPCODE_MODULE_AUX:0,,true,108,108,RDB_OPCODE_MODULE_AUX,,,0,
488297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.aux_save2,,true,,,aux_save2,,,0,
488303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.aux_save,,true,,,aux_save,,,0,
488309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:115:115:RDB_OPCODE_SELECTDB:0,,true,115,115,RDB_OPCODE_SELECTDB,,,0,
488312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:112:112:RDB_OPCODE_RESIZEDB:0,,true,112,112,RDB_OPCODE_RESIZEDB,,,0,
488315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:481:481:SLAVE_REQ_RDB_EXCLUDE_DATA:0,,true,481,481,SLAVE_REQ_RDB_EXCLUDE_DATA,,,0,
488318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:722:722:REDISMODULE_AUX_BEFORE_RDB:0,,true,722,722,REDISMODULE_AUX_BEFORE_RDB,,,0,
488321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:482:482:SLAVE_REQ_RDB_EXCLUDE_FUNCTIONS:0,,true,482,482,SLAVE_REQ_RDB_EXCLUDE_FUNCTIONS,,,0,
488324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:723:723:REDISMODULE_AUX_AFTER_RDB:0,,true,723,723,REDISMODULE_AUX_AFTER_RDB,,,0,
488327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:116:116:RDB_OPCODE_EOF:0,,true,116,116,RDB_OPCODE_EOF,,,0,
488330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:135:135:RDBFLAGS_REPLICATION:0,,true,135,135,RDBFLAGS_REPLICATION,,,0,
488333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:128:128:RDB_EOF_MARK_SIZE:0,,true,128,128,RDB_EOF_MARK_SIZE,,,0,
488336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:138:138:RDBFLAGS_KEEP_CACHE:0,,true,138,138,RDBFLAGS_KEEP_CACHE,,,0,
488339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:120:120:RDB_MODULE_OPCODE_SINT:0,,true,120,120,RDB_MODULE_OPCODE_SINT,,,0,
488342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:143:143:RDB_LOAD_ERR_OTHER:0,,true,143,143,RDB_LOAD_ERR_OTHER,,,0,
488345,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:76:76:RDB_TYPE_LIST:0,,true,76,76,RDB_TYPE_LIST,,,0,
488348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:78:78:RDB_TYPE_ZSET:0,,true,78,78,RDB_TYPE_ZSET,,,0,
488351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:92:92:RDB_TYPE_LIST_QUICKLIST:0,,true,92,92,RDB_TYPE_LIST_QUICKLIST,,,0,
488354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:87:87:RDB_TYPE_HASH_ZIPMAP:0,,true,87,87,RDB_TYPE_HASH_ZIPMAP,,,0,
488357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:88:88:RDB_TYPE_LIST_ZIPLIST:0,,true,88,88,RDB_TYPE_LIST_ZIPLIST,,,0,
488360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:90:90:RDB_TYPE_ZSET_ZIPLIST:0,,true,90,90,RDB_TYPE_ZSET_ZIPLIST,,,0,
488363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:91:91:RDB_TYPE_HASH_ZIPLIST:0,,true,91,91,RDB_TYPE_HASH_ZIPLIST,,,0,
488366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:93:93:RDB_TYPE_STREAM_LISTPACKS:0,,true,93,93,RDB_TYPE_STREAM_LISTPACKS,,,0,
488369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:97:97:RDB_TYPE_STREAM_LISTPACKS_2:0,,true,97,97,RDB_TYPE_STREAM_LISTPACKS_2,,,0,
488372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.c,rdb.c:53:53:rdbReportReadError:1,,true,53,53,rdbReportReadError,,,0,
488375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream.h,stream.h:111:111:SCC_NO_NOTIFY:0,,true,111,111,SCC_NO_NOTIFY,,,0,
488378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream.h,stream.h:112:112:SCC_NO_DIRTIFY:0,,true,112,112,SCC_NO_DIRTIFY,,,0,
488381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:81:81:RDB_TYPE_MODULE_PRE_GA:0,,true,81,81,RDB_TYPE_MODULE_PRE_GA,,,0,
488384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:142:142:RDB_LOAD_ERR_EMPTY_KEY:0,,true,142,142,RDB_LOAD_ERR_EMPTY_KEY,,,0,
488387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:624:624:REDISMODULE_SUBEVENT_LOADING_AOF_START:0,,true,624,624,REDISMODULE_SUBEVENT_LOADING_AOF_START,,,0,
488390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:625:625:REDISMODULE_SUBEVENT_LOADING_REPL_START:0,,true,625,625,REDISMODULE_SUBEVENT_LOADING_REPL_START,,,0,
488393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:623:623:REDISMODULE_SUBEVENT_LOADING_RDB_START:0,,true,623,623,REDISMODULE_SUBEVENT_LOADING_RDB_START,,,0,
488396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:626:626:REDISMODULE_SUBEVENT_LOADING_ENDED:0,,true,626,626,REDISMODULE_SUBEVENT_LOADING_ENDED,,,0,
488399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:627:627:REDISMODULE_SUBEVENT_LOADING_FAILED:0,,true,627,627,REDISMODULE_SUBEVENT_LOADING_FAILED,,,0,
488402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:616:616:REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START:0,,true,616,616,REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START,,,0,
488405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:620:620:REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START:0,,true,620,620,REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_AOF_START,,,0,
488408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:615:615:REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START:0,,true,615,615,REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START,,,0,
488411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:617:617:REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START:0,,true,617,617,REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START,,,0,
488414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:618:618:REDISMODULE_SUBEVENT_PERSISTENCE_ENDED:0,,true,618,618,REDISMODULE_SUBEVENT_PERSISTENCE_ENDED,,,0,
488417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:619:619:REDISMODULE_SUBEVENT_PERSISTENCE_FAILED:0,,true,619,619,REDISMODULE_SUBEVENT_PERSISTENCE_FAILED,,,0,
488420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rio.h,rio.h:45:45:RIO_TYPE_CONN:0,,true,45,45,RIO_TYPE_CONN,,,0,
488423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:114:114:RDB_OPCODE_EXPIRETIME:0,,true,114,114,RDB_OPCODE_EXPIRETIME,,,0,
488426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:127:127:CONFIG_RUN_ID_SIZE:0,,true,127,127,CONFIG_RUN_ID_SIZE,,,0,
488429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RedisModuleType.aux_load,,true,,,aux_load,,,0,
488436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rdb.h,rdb.h:137:137:RDBFLAGS_FEED_REPL:0,,true,137,137,RDBFLAGS_FEED_REPL,,,0,
488439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:660:660:NOTIFY_LOADED:0,,true,660,660,NOTIFY_LOADED,,,0,
488442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:327:327:RDB_FAILED:0,,true,327,327,RDB_FAILED,,,0,
488445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:644:644:RDB_CHILD_TYPE_SOCKET:0,,true,644,644,RDB_CHILD_TYPE_SOCKET,,,0,
488448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:642:642:RDB_CHILD_TYPE_NONE:0,,true,642,642,RDB_CHILD_TYPE_NONE,,,0,
488451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:64:64:UNUSED:1,,true,64,64,UNUSED,,,0,
488455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisConnect,,true,,,redisConnect,,,0,
488460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisConnectUnix,,true,,,redisConnectUnix,,,0,
488464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisCommand,,true,,,redisCommand,,,0,
488469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,freeReplyObject,,true,,,freeReplyObject,,,0,
488473,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisFree,,true,,,redisFree,,,0,
488477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAppendCommand,,true,,,redisAppendCommand,,,0,
488483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisGetReply,,true,,,redisGetReply,,,0,
488488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:75:76:CLIENT_GET_EVENTLOOP:1,,true,75,76,CLIENT_GET_EVENTLOOP,,,0,
488492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisBufferRead,,true,,,redisBufferRead,,,0,
488496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_record_value,,true,,,hdr_record_value,,,0,
488501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:71:71:CONFIG_LATENCY_HISTOGRAM_MAX_VALUE:0,,true,71,71,CONFIG_LATENCY_HISTOGRAM_MAX_VALUE,,,0,
488504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:72:72:CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE:0,,true,72,72,CONFIG_LATENCY_HISTOGRAM_INSTANT_MAX_VALUE,,,0,
488507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_record_value_atomic,,true,,,hdr_record_value_atomic,,,0,
488512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisConnectNonBlock,,true,,,redisConnectNonBlock,,,0,
488517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisConnectUnixNonBlock,,true,,,redisConnectUnixNonBlock,,,0,
488521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisFormatCommand,,true,,,redisFormatCommand,,,0,
488528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:65:65:RANDPTR_INITIAL_SIZE:0,,true,65,65,RANDPTR_INITIAL_SIZE,,,0,
488531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_min,,true,,,hdr_min,,,0,
488535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_value_at_percentile,,true,,,hdr_value_at_percentile,,,0,
488540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_max,,true,,,hdr_max,,,0,
488544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_mean,,true,,,hdr_mean,,,0,
488548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_iter_percentile_init,,true,,,hdr_iter_percentile_init,,,0,
488554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_iter_linear_init,,true,,,hdr_iter_linear_init,,,0,
488560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_iter_linear_set_value_units_per_bucket,,true,,,hdr_iter_linear_set_value_units_per_bucket,,,0,
488565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_init,,true,,,hdr_init,,,0,
488572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:70:70:CONFIG_LATENCY_HISTOGRAM_MIN_VALUE:0,,true,70,70,CONFIG_LATENCY_HISTOGRAM_MIN_VALUE,,,0,
488575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:69:69:CLUSTER_SLOTS:0,,true,69,69,CLUSTER_SLOTS,,,0,
488578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strdup,,true,,,strdup,,,0,
488582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,srandom,,true,,,srandom,,,0,
488586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:66:66:DEFAULT_LATENCY_PRECISION:0,,true,66,66,DEFAULT_LATENCY_PRECISION,,,0,
488589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:67:67:MAX_LATENCY_PRECISION:0,,true,67,67,MAX_LATENCY_PRECISION,,,0,
488592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:68:68:MAX_THREADS:0,,true,68,68,MAX_THREADS,,,0,
488595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-benchmark.c,redis-benchmark.c:73:73:SHOW_THROUGHPUT_INTERVAL:0,,true,73,73,SHOW_THROUGHPUT_INTERVAL,,,0,
488598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,hdr_reset,,true,,,hdr_reset,,,0,
488602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,signal,,true,,,signal,,,0,
488607,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisFormatCommandArgv,,true,,,redisFormatCommandArgv,,,0,
488614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-aof.c,redis-check-aof.c:52:56:ERROR:1,,true,52,56,ERROR,,,0,
488617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-aof.c,redis-check-aof.c:38:38:AOF_CHECK_EMPTY:0,,true,38,38,AOF_CHECK_EMPTY,,,0,
488620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-aof.c,redis-check-aof.c:40:40:AOF_CHECK_TIMESTAMP_TRUNCATED:0,,true,40,40,AOF_CHECK_TIMESTAMP_TRUNCATED,,,0,
488623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-aof.c,redis-check-aof.c:37:37:AOF_CHECK_OK:0,,true,37,37,AOF_CHECK_OK,,,0,
488626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-aof.c,redis-check-aof.c:39:39:AOF_CHECK_TRUNCATED:0,,true,39,39,AOF_CHECK_TRUNCATED,,,0,
488629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-aof.c,redis-check-aof.c:370:370:MANIFEST_MAX_LINE:0,,true,370,370,MANIFEST_MAX_LINE,,,0,
488632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dirname,,true,,,dirname,,,0,
488636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:58:58:RDB_CHECK_DOING_READ_TYPE:0,,true,58,58,RDB_CHECK_DOING_READ_TYPE,,,0,
488639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:59:59:RDB_CHECK_DOING_READ_EXPIRE:0,,true,59,59,RDB_CHECK_DOING_READ_EXPIRE,,,0,
488642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:63:63:RDB_CHECK_DOING_READ_LEN:0,,true,63,63,RDB_CHECK_DOING_READ_LEN,,,0,
488645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:64:64:RDB_CHECK_DOING_READ_AUX:0,,true,64,64,RDB_CHECK_DOING_READ_AUX,,,0,
488648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:65:65:RDB_CHECK_DOING_READ_MODULE_AUX:0,,true,65,65,RDB_CHECK_DOING_READ_MODULE_AUX,,,0,
488651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:66:66:RDB_CHECK_DOING_READ_FUNCTIONS:0,,true,66,66,RDB_CHECK_DOING_READ_FUNCTIONS,,,0,
488654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:60:60:RDB_CHECK_DOING_READ_KEY:0,,true,60,60,RDB_CHECK_DOING_READ_KEY,,,0,
488657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:61:61:RDB_CHECK_DOING_READ_OBJECT_VALUE:0,,true,61,61,RDB_CHECK_DOING_READ_OBJECT_VALUE,,,0,
488660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-check-rdb.c,redis-check-rdb.c:62:62:RDB_CHECK_DOING_CHECK_SUM:0,,true,62,62,RDB_CHECK_DOING_CHECK_SUM,,,0,
488663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getenv,,true,,,getenv,,,0,
488667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:70:70:UNUSED:1,,true,70,70,UNUSED,,,0,
488671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:161:161:CC_QUIET:0,,true,161,161,CC_QUIET,,,0,
488674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:411:411:CLI_HELP_COMMAND:0,,true,411,411,CLI_HELP_COMMAND,,,0,
488677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:412:412:CLI_HELP_GROUP:0,,true,412,412,CLI_HELP_GROUP,,,0,
488680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseAddCompletion,,true,,,linenoiseAddCompletion,,,0,
488685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tcsetattr,,true,,,tcsetattr,,,0,
488691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isatty,,true,,,isatty,,,0,
488695,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tcgetattr,,true,,,tcgetattr,,,0,
488700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atexit,,true,,,atexit,,,0,
488704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:160:160:CC_FORCE:0,,true,160,160,CC_FORCE,,,0,
488707,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:77:77:REDIS_CLI_KEEPALIVE_INTERVAL:0,,true,77,77,REDIS_CLI_KEEPALIVE_INTERVAL,,,0,
488710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisSetPushCallback,,true,,,redisSetPushCallback,,,0,
488715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:72:72:OUTPUT_STANDARD:0,,true,72,72,OUTPUT_STANDARD,,,0,
488718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:75:75:OUTPUT_JSON:0,,true,75,75,OUTPUT_JSON,,,0,
488721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:76:76:OUTPUT_QUOTED_JSON:0,,true,76,76,OUTPUT_QUOTED_JSON,,,0,
488724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:73:73:OUTPUT_RAW:0,,true,73,73,OUTPUT_RAW,,,0,
488727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:74:74:OUTPUT_CSV:0,,true,74,74,OUTPUT_CSV,,,0,
488730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisGetReplyFromReader,,true,,,redisGetReplyFromReader,,,0,
488735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAppendCommandArgv,,true,,,redisAppendCommandArgv,,,0,
488742,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisvCommand,,true,,,redisvCommand,,,0,
488748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atof,,true,,,atof,,,0,
488752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:96:96:CLUSTER_MANAGER_MODE:0,,true,96,96,CLUSTER_MANAGER_MODE,,,0,
488755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:137:137:CLUSTER_MANAGER_CMD_FLAG_MASTERS_ONLY:0,,true,137,137,CLUSTER_MANAGER_CMD_FLAG_MASTERS_ONLY,,,0,
488758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:138:138:CLUSTER_MANAGER_CMD_FLAG_SLAVES_ONLY:0,,true,138,138,CLUSTER_MANAGER_CMD_FLAG_SLAVES_ONLY,,,0,
488761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:128:128:CLUSTER_MANAGER_CMD_FLAG_YES:0,,true,128,128,CLUSTER_MANAGER_CMD_FLAG_YES,,,0,
488764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:131:131:CLUSTER_MANAGER_CMD_FLAG_SIMULATE:0,,true,131,131,CLUSTER_MANAGER_CMD_FLAG_SIMULATE,,,0,
488767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:132:132:CLUSTER_MANAGER_CMD_FLAG_REPLACE:0,,true,132,132,CLUSTER_MANAGER_CMD_FLAG_REPLACE,,,0,
488770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:133:133:CLUSTER_MANAGER_CMD_FLAG_COPY:0,,true,133,133,CLUSTER_MANAGER_CMD_FLAG_COPY,,,0,
488773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:127:127:CLUSTER_MANAGER_CMD_FLAG_SLAVE:0,,true,127,127,CLUSTER_MANAGER_CMD_FLAG_SLAVE,,,0,
488776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:130:130:CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER:0,,true,130,130,CLUSTER_MANAGER_CMD_FLAG_EMPTYMASTER,,,0,
488779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:135:135:CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS:0,,true,135,135,CLUSTER_MANAGER_CMD_FLAG_CHECK_OWNERS,,,0,
488782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:136:136:CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS:0,,true,136,136,CLUSTER_MANAGER_CMD_FLAG_FIX_WITH_UNREACHABLE_MASTERS,,,0,
488785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fputs,,true,,,fputs,,,0,
488790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:83:83:REDIS_CLI_AUTH_ENV:0,,true,83,83,REDIS_CLI_AUTH_ENV,,,0,
488793,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:84:84:REDIS_CLI_CLUSTER_YES_ENV:0,,true,84,84,REDIS_CLI_CLUSTER_YES_ENV,,,0,
488796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:78:78:REDIS_CLI_DEFAULT_PIPE_TIMEOUT:0,,true,78,78,REDIS_CLI_DEFAULT_PIPE_TIMEOUT,,,0,
488799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:81:81:REDIS_CLI_RCFILE_ENV:0,,true,81,81,REDIS_CLI_RCFILE_ENV,,,0,
488802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:82:82:REDIS_CLI_RCFILE_DEFAULT:0,,true,82,82,REDIS_CLI_RCFILE_DEFAULT,,,0,
488805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseSetMultiLine,,true,,,linenoiseSetMultiLine,,,0,
488809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseSetCompletionCallback,,true,,,linenoiseSetCompletionCallback,,,0,
488813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseSetHintsCallback,,true,,,linenoiseSetHintsCallback,,,0,
488817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseSetFreeHintsCallback,,true,,,linenoiseSetFreeHintsCallback,,,0,
488821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:79:79:REDIS_CLI_HISTFILE_ENV:0,,true,79,79,REDIS_CLI_HISTFILE_ENV,,,0,
488824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:80:80:REDIS_CLI_HISTFILE_DEFAULT:0,,true,80,80,REDIS_CLI_HISTFILE_DEFAULT,,,0,
488827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseHistoryLoad,,true,,,linenoiseHistoryLoad,,,0,
488831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoise,,true,,,linenoise,,,0,
488835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseHistoryAdd,,true,,,linenoiseHistoryAdd,,,0,
488839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseHistorySave,,true,,,linenoiseHistorySave,,,0,
488843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseFree,,true,,,linenoiseFree,,,0,
488847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseClearScreen,,true,,,linenoiseClearScreen,,,0,
488850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncpy,,true,,,strncpy,,,0,
488856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:86:86:CLUSTER_MANAGER_SLOTS:0,,true,86,86,CLUSTER_MANAGER_SLOTS,,,0,
488859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:134:134:CLUSTER_MANAGER_CMD_FLAG_COLOR:0,,true,134,134,CLUSTER_MANAGER_CMD_FLAG_COLOR,,,0,
488862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:121:121:CLUSTER_MANAGER_FLAG_FRIEND:0,,true,121,121,CLUSTER_MANAGER_FLAG_FRIEND,,,0,
488865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:87:87:CLUSTER_MANAGER_PORT_INCR:0,,true,87,87,CLUSTER_MANAGER_PORT_INCR,,,0,
488868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:103:105:CLUSTER_MANAGER_PRINT_REPLY_ERROR:2,,true,103,105,CLUSTER_MANAGER_PRINT_REPLY_ERROR,,,0,
488873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:98:99:CLUSTER_MANAGER_COMMAND:2,,true,98,99,CLUSTER_MANAGER_COMMAND,,,0,
488877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,onerror,,true,,,onerror,,,0,
488883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:107:108:clusterManagerLogInfo:1,,true,107,108,clusterManagerLogInfo,,,0,
488886,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,srand,,true,,,srand,,,0,
488890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:149:149:CLUSTER_MANAGER_LOG_LVL_SUCCESS:0,,true,149,149,CLUSTER_MANAGER_LOG_LVL_SUCCESS,,,0,
488893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:147:147:CLUSTER_MANAGER_LOG_LVL_WARN:0,,true,147,147,CLUSTER_MANAGER_LOG_LVL_WARN,,,0,
488896,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:120:120:CLUSTER_MANAGER_FLAG_SLAVE:0,,true,120,120,CLUSTER_MANAGER_FLAG_SLAVE,,,0,
488899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:116:117:clusterManagerLogOk:1,,true,116,117,clusterManagerLogOk,,,0,
488902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:126:126:CLUSTER_MANAGER_CMD_FLAG_FIX:0,,true,126,126,CLUSTER_MANAGER_CMD_FLAG_FIX,,,0,
488905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:113:114:clusterManagerLogWarn:1,,true,113,114,clusterManagerLogWarn,,,0,
488908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:110:111:clusterManagerLogErr:1,,true,110,111,clusterManagerLogErr,,,0,
488911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:143:143:CLUSTER_MANAGER_OPT_QUIET:0,,true,143,143,CLUSTER_MANAGER_OPT_QUIET,,,0,
488914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:144:144:CLUSTER_MANAGER_OPT_VERBOSE:0,,true,144,144,CLUSTER_MANAGER_OPT_VERBOSE,,,0,
488917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:141:141:CLUSTER_MANAGER_OPT_COLD:0,,true,141,141,CLUSTER_MANAGER_OPT_COLD,,,0,
488920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:142:142:CLUSTER_MANAGER_OPT_UPDATE:0,,true,142,142,CLUSTER_MANAGER_OPT_UPDATE,,,0,
488923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:151:151:CLUSTER_JOIN_CHECK_AFTER:0,,true,151,151,CLUSTER_JOIN_CHECK_AFTER,,,0,
488926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:140:140:CLUSTER_MANAGER_OPT_GETFRIENDS:0,,true,140,140,CLUSTER_MANAGER_OPT_GETFRIENDS,,,0,
488929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:119:119:CLUSTER_MANAGER_FLAG_MYSELF:0,,true,119,119,CLUSTER_MANAGER_FLAG_MYSELF,,,0,
488932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:122:122:CLUSTER_MANAGER_FLAG_NOADDR:0,,true,122,122,CLUSTER_MANAGER_FLAG_NOADDR,,,0,
488935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:123:123:CLUSTER_MANAGER_FLAG_DISCONNECT:0,,true,123,123,CLUSTER_MANAGER_FLAG_DISCONNECT,,,0,
488938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:124:124:CLUSTER_MANAGER_FLAG_FAIL:0,,true,124,124,CLUSTER_MANAGER_FLAG_FAIL,,,0,
488941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:146:146:CLUSTER_MANAGER_LOG_LVL_INFO:0,,true,146,146,CLUSTER_MANAGER_LOG_LVL_INFO,,,0,
488944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:153:153:LOG_COLOR_BOLD:0,,true,153,153,LOG_COLOR_BOLD,,,0,
488947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:156:156:LOG_COLOR_YELLOW:0,,true,156,156,LOG_COLOR_YELLOW,,,0,
488950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:148:148:CLUSTER_MANAGER_LOG_LVL_ERR:0,,true,148,148,CLUSTER_MANAGER_LOG_LVL_ERR,,,0,
488953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:154:154:LOG_COLOR_RED:0,,true,154,154,LOG_COLOR_RED,,,0,
488956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:155:155:LOG_COLOR_GREEN:0,,true,155,155,LOG_COLOR_GREEN,,,0,
488959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:157:157:LOG_COLOR_RESET:0,,true,157,157,LOG_COLOR_RESET,,,0,
488962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vprintf,,true,,,vprintf,,,0,
488967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,proc,,true,,,proc,,,0,
488972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:97:97:CLUSTER_MANAGER_MASTERS_COUNT:2,,true,97,97,CLUSTER_MANAGER_MASTERS_COUNT,,,0,
488977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lround,,true,,,lround,,,0,
488981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,anet.h,anet.h:41:41:ANET_NONE:0,,true,41,41,ANET_NONE,,,0,
488984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:101:101:CLUSTER_MANAGER_NODE_ARRAY_FREE:1,,true,101,101,CLUSTER_MANAGER_NODE_ARRAY_FREE,,,0,
488988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:92:95:CLUSTER_MANAGER_INVALID_HOST_ARG:0,,true,92,95,CLUSTER_MANAGER_INVALID_HOST_ARG,,,0,
488991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getchar,,true,,,getchar,,,0,
488994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:8172:8172:LATENCY_HISTORY_DEFAULT_INTERVAL:0,,true,8172,8172,LATENCY_HISTORY_DEFAULT_INTERVAL,,,0,
488997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:8171:8171:LATENCY_SAMPLE_RATE:0,,true,8171,8171,LATENCY_SAMPLE_RATE,,,0,
489000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:8237:8237:LATENCY_DIST_DEFAULT_INTERVAL:0,,true,8237,8237,LATENCY_DIST_DEFAULT_INTERVAL,,,0,
489003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:8379:8379:RDB_EOF_MARK_SIZE:0,,true,8379,8379,RDB_EOF_MARK_SIZE,,,0,
489006,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:8671:8671:PIPEMODE_WRITE_LOOP_MAX_BYTES:0,,true,8671,8671,PIPEMODE_WRITE_LOOP_MAX_BYTES,,,0,
489009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:9211:9211:HOTKEYS_SAMPLE:0,,true,9211,9211,HOTKEYS_SAMPLE,,,0,
489012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:9511:9511:LRU_CYCLE_PERIOD:0,,true,9511,9511,LRU_CYCLE_PERIOD,,,0,
489015,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:9512:9512:LRU_CYCLE_PIPELINE_SIZE:0,,true,9512,9512,LRU_CYCLE_PIPELINE_SIZE,,,0,
489018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseMaskModeEnable,,true,,,linenoiseMaskModeEnable,,,0,
489021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,linenoiseMaskModeDisable,,true,,,linenoiseMaskModeDisable,,,0,
489024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:88:88:CLUSTER_MANAGER_MIGRATE_TIMEOUT:0,,true,88,88,CLUSTER_MANAGER_MIGRATE_TIMEOUT,,,0,
489027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:89:89:CLUSTER_MANAGER_MIGRATE_PIPELINE:0,,true,89,89,CLUSTER_MANAGER_MIGRATE_PIPELINE,,,0,
489030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redis-cli.c,redis-cli.c:90:90:CLUSTER_MANAGER_REBALANCE_THRESHOLD:0,,true,90,90,CLUSTER_MANAGER_REBALANCE_THRESHOLD,,,0,
489033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,raise,,true,,,raise,,,0,
489037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:495:495:REDISMODULE_EVENT_REPL_BACKUP:0,,true,495,495,REDISMODULE_EVENT_REPL_BACKUP,,,0,
489040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:946:947:REDISMODULE_GET_API:1,,true,946,947,REDISMODULE_GET_API,,,0,
489043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:129:129:CONFIG_REPL_BACKLOG_MIN_SIZE:0,,true,129,129,CONFIG_REPL_BACKLOG_MIN_SIZE,,,0,
489046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:494:494:REPL_BACKLOG_INDEX_PER_BLOCKS:0,,true,494,494,REPL_BACKLOG_INDEX_PER_BLOCKS,,,0,
489049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:391:391:CLIENT_REPL_RDBONLY:0,,true,391,391,CLIENT_REPL_RDBONLY,,,0,
489052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:103:103:max:2,,true,103,103,max,,,0,
489056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:120:120:PROTO_SHARED_SELECT_CMDS:0,,true,120,120,PROTO_SHARED_SELECT_CMDS,,,0,
489059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,adlist.h,adlist.h:60:60:listPrevNode:1,,true,60,60,listPrevNode,,,0,
489063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:352:352:CLIENT_PRE_PSYNC:0,,true,352,352,CLIENT_PRE_PSYNC,,,0,
489066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:477:477:SLAVE_CAPA_PSYNC2:0,,true,477,477,SLAVE_CAPA_PSYNC2,,,0,
489069,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:638:638:REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE:0,,true,638,638,REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,,,0,
489072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:484:484:SLAVE_REQ_RDB_MASK:0,,true,484,484,SLAVE_REQ_RDB_MASK,,,0,
489075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:476:476:SLAVE_CAPA_EOF:0,,true,476,476,SLAVE_CAPA_EOF,,,0,
489078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:471:471:SLAVE_STATE_RDB_TRANSMITTED:0,,true,471,471,SLAVE_STATE_RDB_TRANSMITTED,,,0,
489081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lstat,,true,,,lstat,,,0,
489086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:1863:1863:REPL_MAX_WRITTEN_BEFORE_FSYNC:0,,true,1863,1863,REPL_MAX_WRITTEN_BEFORE_FSYNC,,,0,
489089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,config.h,config.h:165:165:rdb_fsync_range:3,,true,165,165,rdb_fsync_range,,,0,
489093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:667:667:REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_STARTED:0,,true,667,667,REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_STARTED,,,0,
489096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:668:668:REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_ABORTED:0,,true,668,668,REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_ABORTED,,,0,
489099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:669:669:REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_COMPLETED:0,,true,669,669,REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_COMPLETED,,,0,
489102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:634:634:REDISMODULE_SUBEVENT_MASTER_LINK_UP:0,,true,634,634,REDISMODULE_SUBEVENT_MASTER_LINK_UP,,,0,
489105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:2437:2437:PSYNC_WRITE_ERROR:0,,true,2437,2437,PSYNC_WRITE_ERROR,,,0,
489108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:2438:2438:PSYNC_WAIT_REPLY:0,,true,2438,2438,PSYNC_WAIT_REPLY,,,0,
489111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:2442:2442:PSYNC_TRY_LATER:0,,true,2442,2442,PSYNC_TRY_LATER,,,0,
489114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:2440:2440:PSYNC_FULLRESYNC:0,,true,2440,2440,PSYNC_FULLRESYNC,,,0,
489117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:2439:2439:PSYNC_CONTINUE:0,,true,2439,2439,PSYNC_CONTINUE,,,0,
489120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,replication.c,replication.c:2441:2441:PSYNC_NOT_SUPPORTED:0,,true,2441,2441,PSYNC_NOT_SUPPORTED,,,0,
489123,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:643:643:REDISMODULE_EVENT_REPLROLECHANGED_NOW_REPLICA:0,,true,643,643,REDISMODULE_EVENT_REPLROLECHANGED_NOW_REPLICA,,,0,
489126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:635:635:REDISMODULE_SUBEVENT_MASTER_LINK_DOWN:0,,true,635,635,REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,,,0,
489129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:642:642:REDISMODULE_EVENT_REPLROLECHANGED_NOW_MASTER:0,,true,642,642,REDISMODULE_EVENT_REPLROLECHANGED_NOW_MASTER,,,0,
489132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util.h,util.h:39:39:MAX_LONG_DOUBLE_CHARS:0,,true,39,39,MAX_LONG_DOUBLE_CHARS,,,0,
489135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rio.h,rio.h:43:43:RIO_TYPE_FILE:0,,true,43,43,RIO_TYPE_FILE,,,0,
489138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rio.h,rio.h:44:44:RIO_TYPE_BUFFER:0,,true,44,44,RIO_TYPE_BUFFER,,,0,
489141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rio.h,rio.h:46:46:RIO_TYPE_FD:0,,true,46,46,RIO_TYPE_FD,,,0,
489144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rio.h,rio.h:41:41:RIO_FLAG_WRITE_ERROR:0,,true,41,41,RIO_FLAG_WRITE_ERROR,,,0,
489147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rio.h,rio.h:40:40:RIO_FLAG_READ_ERROR:0,,true,40,40,RIO_FLAG_READ_ERROR,,,0,
489150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:80:80:SCRIPT_FLAG_NO_WRITES:0,,true,80,80,SCRIPT_FLAG_NO_WRITES,,,0,
489153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:81:81:SCRIPT_FLAG_ALLOW_OOM:0,,true,81,81,SCRIPT_FLAG_ALLOW_OOM,,,0,
489156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:82:82:SCRIPT_FLAG_ALLOW_STALE:0,,true,82,82,SCRIPT_FLAG_ALLOW_STALE,,,0,
489159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:83:83:SCRIPT_FLAG_NO_CLUSTER:0,,true,83,83,SCRIPT_FLAG_NO_CLUSTER,,,0,
489162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:85:85:SCRIPT_FLAG_ALLOW_CROSS_SLOT:0,,true,85,85,SCRIPT_FLAG_ALLOW_CROSS_SLOT,,,0,
489165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:62:62:SCRIPT_TIMEDOUT:0,,true,62,62,SCRIPT_TIMEDOUT,,,0,
489168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:63:63:SCRIPT_KILLED:0,,true,63,63,SCRIPT_KILLED,,,0,
489171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:57:57:SCRIPT_KILL:0,,true,57,57,SCRIPT_KILL,,,0,
489174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:58:58:SCRIPT_CONTINUE:0,,true,58,58,SCRIPT_CONTINUE,,,0,
489177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2842:2842:DISK_ERROR_TYPE_RDB:0,,true,2842,2842,DISK_ERROR_TYPE_RDB,,,0,
489180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:64:64:SCRIPT_READ_ONLY:0,,true,64,64,SCRIPT_READ_ONLY,,,0,
489183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:65:65:SCRIPT_ALLOW_OOM:0,,true,65,65,SCRIPT_ALLOW_OOM,,,0,
489186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:67:67:SCRIPT_ALLOW_CROSS_SLOT:0,,true,67,67,SCRIPT_ALLOW_CROSS_SLOT,,,0,
489189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script.h,script.h:61:61:SCRIPT_WRITE_DIRTY:0,,true,61,61,SCRIPT_WRITE_DIRTY,,,0,
489192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2971:2971:ERROR_COMMAND_REJECTED:0,,true,2971,2971,ERROR_COMMAND_REJECTED,,,0,
489195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_pushlightuserdata,,true,,,lua_pushlightuserdata,,,0,
489200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_islightuserdata,,true,,,lua_islightuserdata,,,0,
489205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_error,,true,,,lua_error,,,0,
489209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_strlen,,true,,,lua_strlen,,,0,
489214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawget,,true,,,lua_rawget,,,0,
489219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:3364:3364:LUA_CMD_OBJCACHE_SIZE:0,,true,3364,3364,LUA_CMD_OBJCACHE_SIZE,,,0,
489222,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_insert,,true,,,lua_insert,,,0,
489227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_remove,,true,,,lua_remove,,,0,
489232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isnumber,,true,,,lua_isnumber,,,0,
489237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_call,,true,,,lua_call,,,0,
489243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_error,,true,,,luaL_error,,,0,
489248,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawset,,true,,,lua_rawset,,,0,
489253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isreadonlytable,,true,,,lua_isreadonlytable,,,0,
489258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:600:600:PROPAGATE_NONE:0,,true,600,600,PROPAGATE_NONE,,,0,
489261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_rawseti,,true,,,lua_rawseti,,,0,
489267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_Number,,true,,,lua_Number,,,0,
489271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,rand.h,rand.h:36:36:REDIS_LRAND48_MAX:0,,true,36,36,REDIS_LRAND48_MAX,,,0,
489274,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_checkint,,true,,,luaL_checkint,,,0,
489279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,luaL_argcheck,,true,,,luaL_argcheck,,,0,
489286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_isboolean,,true,,,lua_isboolean,,,0,
489291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,script_lua.c,script_lua.c:1670:1670:LUA_GC_CYCLE_PERIOD:0,,true,1670,1670,LUA_GC_CYCLE_PERIOD,,,0,
489294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lua_gc,,true,,,lua_gc,,,0,
489300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:81:81:SDS_TYPE_MASK:0,,true,81,81,SDS_TYPE_MASK,,,0,
489303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:76:76:SDS_TYPE_5:0,,true,76,76,SDS_TYPE_5,,,0,
489306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:78:78:SDS_TYPE_16:0,,true,78,78,SDS_TYPE_16,,,0,
489309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:79:79:SDS_TYPE_32:0,,true,79,79,SDS_TYPE_32,,,0,
489312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:80:80:SDS_TYPE_64:0,,true,80,80,SDS_TYPE_64,,,0,
489315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sdsalloc.h,sdsalloc.h:50:50:s_trymalloc_usable:0,,true,50,50,s_trymalloc_usable,,,0,
489318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sdsalloc.h,sdsalloc.h:48:48:s_malloc_usable:0,,true,48,48,s_malloc_usable,,,0,
489321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:82:82:SDS_TYPE_BITS:0,,true,82,82,SDS_TYPE_BITS,,,0,
489324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:83:83:SDS_HDR_VAR:2,,true,83,83,SDS_HDR_VAR,,,0,
489328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sdsalloc.h,sdsalloc.h:47:47:s_free:0,,true,47,47,s_free,,,0,
489331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:36:36:SDS_MAX_PREALLOC:0,,true,36,36,SDS_MAX_PREALLOC,,,0,
489334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sdsalloc.h,sdsalloc.h:49:49:s_realloc_usable:0,,true,49,49,s_realloc_usable,,,0,
489337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sdsalloc.h,sdsalloc.h:44:44:s_realloc:0,,true,44,44,s_realloc,,,0,
489340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sdsalloc.h,sdsalloc.h:43:43:s_malloc:0,,true,43,43,s_malloc,,,0,
489343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:85:85:SDS_TYPE_5_LEN:1,,true,85,85,SDS_TYPE_5_LEN,,,0,
489347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb_func,,true,,,cb_func,,,0,
489352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sds.h,sds.h:84:84:SDS_HDR:2,,true,84,84,SDS_HDR,,,0,
489356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:83:83:SENTINEL_PING_PERIOD:0,,true,83,83,SENTINEL_PING_PERIOD,,,0,
489359,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncHandleRead,,true,,,redisAsyncHandleRead,,,0,
489363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncHandleWrite,,true,,,redisAsyncHandleWrite,,,0,
489367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:52:52:REDIS_SENTINEL_PORT:0,,true,52,52,REDIS_SENTINEL_PORT,,,0,
489370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:137:137:SENTINEL_SIMFAILURE_NONE:0,,true,137,137,SENTINEL_SIMFAILURE_NONE,,,0,
489373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:105:105:SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG:0,,true,105,105,SENTINEL_DEFAULT_DENY_SCRIPTS_RECONFIG,,,0,
489376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:106:106:SENTINEL_DEFAULT_RESOLVE_HOSTNAMES:0,,true,106,106,SENTINEL_DEFAULT_RESOLVE_HOSTNAMES,,,0,
489379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:107:107:SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES:0,,true,107,107,SENTINEL_DEFAULT_ANNOUNCE_HOSTNAMES,,,0,
489382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,access,,true,,,access,,,0,
489387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:64:64:SRI_MASTER:0,,true,64,64,SRI_MASTER,,,0,
489390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:753:753:SENTINEL_SCRIPT_MAX_ARGS:0,,true,753,753,SENTINEL_SCRIPT_MAX_ARGS,,,0,
489393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:130:130:SENTINEL_SCRIPT_NONE:0,,true,130,130,SENTINEL_SCRIPT_NONE,,,0,
489396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:132:132:SENTINEL_SCRIPT_MAX_QUEUE:0,,true,132,132,SENTINEL_SCRIPT_MAX_QUEUE,,,0,
489399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:131:131:SENTINEL_SCRIPT_RUNNING:0,,true,131,131,SENTINEL_SCRIPT_RUNNING,,,0,
489402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:133:133:SENTINEL_SCRIPT_MAX_RUNNING:0,,true,133,133,SENTINEL_SCRIPT_MAX_RUNNING,,,0,
489405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fork,,true,,,fork,,,0,
489408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,execve,,true,,,execve,,,0,
489414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WEXITSTATUS,,true,,,WEXITSTATUS,,,0,
489418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WIFSIGNALED,,true,,,WIFSIGNALED,,,0,
489422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WTERMSIG,,true,,,WTERMSIG,,,0,
489426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:134:134:SENTINEL_SCRIPT_MAX_RETRY:0,,true,134,134,SENTINEL_SCRIPT_MAX_RETRY,,,0,
489429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:126:126:SENTINEL_LEADER:0,,true,126,126,SENTINEL_LEADER,,,0,
489432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncFree,,true,,,redisAsyncFree,,,0,
489436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:65:65:SRI_SLAVE:0,,true,65,65,SRI_SLAVE,,,0,
489439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:66:66:SRI_SENTINEL:0,,true,66,66,SRI_SENTINEL,,,0,
489442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:100:100:SENTINEL_DEFAULT_SLAVE_PRIORITY:0,,true,100,100,SENTINEL_DEFAULT_SLAVE_PRIORITY,,,0,
489445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:119:119:SENTINEL_MASTER_LINK_STATUS_DOWN:0,,true,119,119,SENTINEL_MASTER_LINK_STATUS_DOWN,,,0,
489448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:101:101:SENTINEL_DEFAULT_PARALLEL_SYNCS:0,,true,101,101,SENTINEL_DEFAULT_PARALLEL_SYNCS,,,0,
489451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:110:110:SENTINEL_FAILOVER_STATE_NONE:0,,true,110,110,SENTINEL_FAILOVER_STATE_NONE,,,0,
489454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:73:73:SRI_PROMOTED:0,,true,73,73,SRI_PROMOTED,,,0,
489457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:1532:1532:SENTINEL_RESET_NO_SENTINELS:0,,true,1532,1532,SENTINEL_RESET_NO_SENTINELS,,,0,
489460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:125:125:SENTINEL_GENERATE_EVENT:0,,true,125,125,SENTINEL_GENERATE_EVENT,,,0,
489463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:71:71:SRI_FAILOVER_IN_PROGRESS:0,,true,71,71,SRI_FAILOVER_IN_PROGRESS,,,0,
489466,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:115:115:SENTINEL_FAILOVER_STATE_RECONF_SLAVES:0,,true,115,115,SENTINEL_FAILOVER_STATE_RECONF_SLAVES,,,0,
489469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:114:114:CONFIG_DEFAULT_HZ:0,,true,114,114,CONFIG_DEFAULT_HZ,,,0,
489472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncCommand,,true,,,redisAsyncCommand,,,0,
489480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncConnectBind,,true,,,redisAsyncConnectBind,,,0,
489486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncSetConnectCallback,,true,,,redisAsyncSetConnectCallback,,,0,
489491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,redisAsyncSetDisconnectCallback,,true,,,redisAsyncSetDisconnectCallback,,,0,
489496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:99:99:SENTINEL_HELLO_CHANNEL:0,,true,99,99,SENTINEL_HELLO_CHANNEL,,,0,
489499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:67:67:SRI_S_DOWN:0,,true,67,67,SRI_S_DOWN,,,0,
489502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:68:68:SRI_O_DOWN:0,,true,68,68,SRI_O_DOWN,,,0,
489505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:79:79:SRI_MASTER_REBOOT:0,,true,79,79,SRI_MASTER_REBOOT,,,0,
489508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:118:118:SENTINEL_MASTER_LINK_STATUS_UP:0,,true,118,118,SENTINEL_MASTER_LINK_STATUS_UP,,,0,
489511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:114:114:SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:0,,true,114,114,SENTINEL_FAILOVER_STATE_WAIT_PROMOTION,,,0,
489514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:139:139:SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION:0,,true,139,139,SENTINEL_SIMFAILURE_CRASH_AFTER_PROMOTION,,,0,
489517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:74:74:SRI_RECONF_SENT:0,,true,74,74,SRI_RECONF_SENT,,,0,
489520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:75:75:SRI_RECONF_INPROG:0,,true,75,75,SRI_RECONF_INPROG,,,0,
489523,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:76:76:SRI_RECONF_DONE:0,,true,76,76,SRI_RECONF_DONE,,,0,
489526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:78:78:SRI_SCRIPT_KILL_SENT:0,,true,78,78,SRI_SCRIPT_KILL_SENT,,,0,
489529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:127:127:SENTINEL_OBSERVER:0,,true,127,127,SENTINEL_OBSERVER,,,0,
489532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:102:102:SENTINEL_MAX_PENDING_COMMANDS:0,,true,102,102,SENTINEL_MAX_PENDING_COMMANDS,,,0,
489535,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:111:111:SENTINEL_FAILOVER_STATE_WAIT_START:0,,true,111,111,SENTINEL_FAILOVER_STATE_WAIT_START,,,0,
489538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:112:112:SENTINEL_FAILOVER_STATE_SELECT_SLAVE:0,,true,112,112,SENTINEL_FAILOVER_STATE_SELECT_SLAVE,,,0,
489541,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:113:113:SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:0,,true,113,113,SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE,,,0,
489544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:116:116:SENTINEL_FAILOVER_STATE_UPDATE_CONFIG:0,,true,116,116,SENTINEL_FAILOVER_STATE_UPDATE_CONFIG,,,0,
489547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:69:69:SRI_MASTER_DOWN:0,,true,69,69,SRI_MASTER_DOWN,,,0,
489550,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:77:77:SRI_FORCE_FAILOVER:0,,true,77,77,SRI_FORCE_FAILOVER,,,0,
489553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:3840:3840:SENTINEL_ISQR_OK:0,,true,3840,3840,SENTINEL_ISQR_OK,,,0,
489556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:3841:3841:SENTINEL_ISQR_NOQUORUM:0,,true,3841,3841,SENTINEL_ISQR_NOQUORUM,,,0,
489559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:3842:3842:SENTINEL_ISQR_NOAUTH:0,,true,3842,3842,SENTINEL_ISQR_NOAUTH,,,0,
489562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:138:138:SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION:0,,true,138,138,SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION,,,0,
489565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,intmax_t,,true,,,intmax_t,,,0,
489569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:4690:4690:SENTINEL_ASK_FORCED:0,,true,4690,4690,SENTINEL_ASK_FORCED,,,0,
489572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:104:104:SENTINEL_MAX_DESYNC:0,,true,104,104,SENTINEL_MAX_DESYNC,,,0,
489575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ctime_r,,true,,,ctime_r,,,0,
489580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sentinel.c,sentinel.c:124:124:SENTINEL_NO_FLAGS:0,,true,124,124,SENTINEL_NO_FLAGS,,,0,
489583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strftime,,true,,,strftime,,,0,
489590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,syslog,,true,,,syslog,,,0,
489596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:202:202:HASHTABLE_MAX_LOAD_FACTOR:0,,true,202,202,HASHTABLE_MAX_LOAD_FACTOR,,,0,
489599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:201:201:HASHTABLE_MIN_FILL:0,,true,201,201,HASHTABLE_MIN_FILL,,,0,
489602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:1521:1521:CHILD_TYPE_NONE:0,,true,1521,1521,CHILD_TYPE_NONE,,,0,
489605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:673:673:REDISMODULE_SUBEVENT_FORK_CHILD_DIED:0,,true,673,673,REDISMODULE_SUBEVENT_FORK_CHILD_DIED,,,0,
489608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentModulo,,true,,,<operators>.assignmentModulo,,,0,
489613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:165:165:STATS_METRIC_SAMPLES:0,,true,165,165,STATS_METRIC_SAMPLES,,,0,
489616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:180:180:PROTO_RESIZE_THRESHOLD:0,,true,180,180,PROTO_RESIZE_THRESHOLD,,,0,
489619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:181:181:PROTO_REPLY_MIN_BYTES:0,,true,181,181,PROTO_REPLY_MIN_BYTES,,,0,
489622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,__builtin_clzl,,true,,,__builtin_clzl,,,0,
489626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:145:145:CLIENT_MEM_USAGE_BUCKET_MAX_LOG:0,,true,145,145,CLIENT_MEM_USAGE_BUCKET_MAX_LOG,,,0,
489629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.c,server.c:827:827:CLIENTS_PEAK_MEM_USAGE_SLOTS:0,,true,827,827,CLIENTS_PEAK_MEM_USAGE_SLOTS,,,0,
489632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.c,server.c:981:981:CLIENTS_CRON_MIN_ITERATIONS:0,,true,981,981,CLIENTS_CRON_MIN_ITERATIONS,,,0,
489635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:148:148:ACTIVE_EXPIRE_CYCLE_SLOW:0,,true,148,148,ACTIVE_EXPIRE_CYCLE_SLOW,,,0,
489638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,localtime_r,,true,,,localtime_r,,,0,
489643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WIFEXITED,,true,,,WIFEXITED,,,0,
489647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:157:157:SERVER_CHILD_NOERROR_RETVAL:0,,true,157,157,SERVER_CHILD_NOERROR_RETVAL,,,0,
489650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:668:668:run_with_period:1,,true,668,668,run_with_period,,,0,
489654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:117:117:MAX_CLIENTS_PER_CLOCK_TICK:0,,true,117,117,MAX_CLIENTS_PER_CLOCK_TICK,,,0,
489657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:166:166:STATS_METRIC_COMMAND:0,,true,166,166,STATS_METRIC_COMMAND,,,0,
489660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:167:167:STATS_METRIC_NET_INPUT:0,,true,167,167,STATS_METRIC_NET_INPUT,,,0,
489663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:168:168:STATS_METRIC_NET_OUTPUT:0,,true,168,168,STATS_METRIC_NET_OUTPUT,,,0,
489666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:169:169:STATS_METRIC_NET_INPUT_REPLICATION:0,,true,169,169,STATS_METRIC_NET_INPUT_REPLICATION,,,0,
489669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:170:170:STATS_METRIC_NET_OUTPUT_REPLICATION:0,,true,170,170,STATS_METRIC_NET_OUTPUT_REPLICATION,,,0,
489672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:171:171:STATS_METRIC_EL_CYCLE:0,,true,171,171,STATS_METRIC_EL_CYCLE,,,0,
489675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:172:172:STATS_METRIC_EL_DURATION:0,,true,172,172,STATS_METRIC_EL_DURATION,,,0,
489678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:130:130:CONFIG_BGSAVE_RETRY_DELAY:0,,true,130,130,CONFIG_BGSAVE_RETRY_DELAY,,,0,
489681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:676:676:REDISMODULE_SUBEVENT_EVENTLOOP_BEFORE_SLEEP:0,,true,676,676,REDISMODULE_SUBEVENT_EVENTLOOP_BEFORE_SLEEP,,,0,
489684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:677:677:REDISMODULE_SUBEVENT_EVENTLOOP_AFTER_SLEEP:0,,true,677,677,REDISMODULE_SUBEVENT_EVENTLOOP_AFTER_SLEEP,,,0,
489687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,cluster.h,cluster.h:107:107:CLUSTER_MODULE_FLAG_NONE:0,,true,107,107,CLUSTER_MODULE_FLAG_NONE,,,0,
489690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:487:487:CONFIG_REPL_SYNCIO_TIMEOUT:0,,true,487,487,CONFIG_REPL_SYNCIO_TIMEOUT,,,0,
489693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:139:139:CONFIG_MIN_RESERVED_FDS:0,,true,139,139,CONFIG_MIN_RESERVED_FDS,,,0,
489696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrlimit,,true,,,getrlimit,,,0,
489701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setrlimit,,true,,,setrlimit,,,0,
489706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:173:173:STATS_METRIC_COUNT:0,,true,173,173,STATS_METRIC_COUNT,,,0,
489709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_setcancelstate,,true,,,pthread_setcancelstate,,,0,
489714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_setcanceltype,,true,,,pthread_setcanceltype,,,0,
489719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,openlog,,true,,,openlog,,,0,
489725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:430:430:CLIENT_TYPE_COUNT:0,,true,430,430,CLIENT_TYPE_COUNT,,,0,
489728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConnectionType.serverLog(LL_WARNING, ""Failed listening on port %u (%s), aborting."", listener->port, listener->ct->get_type(NULL))",,true,,,"serverLog(LL_WARNING, ""Failed listening on port %u (%s), aborting."", listener->port, listener->ct->get_type(NULL))",,,0,
489733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConnectionType.serverPanic(""Unrecoverable error creating %s listener accept handler."", listener->ct->get_type(NULL))",,true,,,"serverPanic(""Unrecoverable error creating %s listener accept handler."", listener->ct->get_type(NULL))",,,0,
489738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:230:230:CMD_MOVABLE_KEYS:0,,true,230,230,CMD_MOVABLE_KEYS,,,0,
489741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:222:222:CMD_SENTINEL:0,,true,222,222,CMD_SENTINEL,,,0,
489744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:223:223:CMD_ONLY_SENTINEL:0,,true,223,223,CMD_ONLY_SENTINEL,,,0,
489747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:351:351:CLIENT_FORCE_REPL:0,,true,351,351,CLIENT_FORCE_REPL,,,0,
489750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:350:350:CLIENT_FORCE_AOF:0,,true,350,350,CLIENT_FORCE_AOF,,,0,
489753,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:357:357:CLIENT_PREVENT_PROP:0,,true,357,357,CLIENT_PREVENT_PROP,,,0,
489756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:355:355:CLIENT_PREVENT_AOF_PROP:0,,true,355,355,CLIENT_PREVENT_AOF_PROP,,,0,
489759,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:356:356:CLIENT_PREVENT_REPL_PROP:0,,true,356,356,CLIENT_PREVENT_REPL_PROP,,,0,
489762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:676:676:LATENCY_HISTOGRAM_MIN_VALUE:0,,true,676,676,LATENCY_HISTOGRAM_MIN_VALUE,,,0,
489765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:677:677:LATENCY_HISTOGRAM_MAX_VALUE:0,,true,677,677,LATENCY_HISTOGRAM_MAX_VALUE,,,0,
489768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:678:678:LATENCY_HISTOGRAM_PRECISION:0,,true,678,678,LATENCY_HISTOGRAM_PRECISION,,,0,
489771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:234:234:CMD_TOUCHES_ARBITRARY_KEYS:0,,true,234,234,CMD_TOUCHES_ARBITRARY_KEYS,,,0,
489774,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2972:2972:ERROR_COMMAND_FAILED:0,,true,2972,2972,ERROR_COMMAND_FAILED,,,0,
489777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.c,server.c:97:98:isAOFLoadingContext:0,,true,97,98,isAOFLoadingContext,,,0,
489780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:594:594:CMD_CALL_REPROCESSING:0,,true,594,594,CMD_CALL_REPROCESSING,,,0,
489783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:596:596:CMD_CALL_PROPAGATE:0,,true,596,596,CMD_CALL_PROPAGATE,,,0,
489786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:225:225:CMD_PROTECTED:0,,true,225,225,CMD_PROTECTED,,,0,
489789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:228:228:CMD_NO_ASYNC_LOADING:0,,true,228,228,CMD_NO_ASYNC_LOADING,,,0,
489792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:229:229:CMD_NO_MULTI:0,,true,229,229,CMD_NO_MULTI,,,0,
489795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2841:2841:DISK_ERROR_TYPE_AOF:0,,true,2841,2841,DISK_ERROR_TYPE_AOF,,,0,
489798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:331:331:CMD_DOC_DEPRECATED:0,,true,331,331,CMD_DOC_DEPRECATED,,,0,
489801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:332:332:CMD_DOC_SYSCMD:0,,true,332,332,CMD_DOC_SYSCMD,,,0,
489804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reply_function,,true,,,reply_function,,,0,
489809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uname,,true,,,uname,,,0,
489813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,int64_t,,true,,,int64_t,,,0,
489817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrusage,,true,,,getrusage,,,0,
489822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:131:131:CONFIG_DEFAULT_PID_FILE:0,,true,131,131,CONFIG_DEFAULT_PID_FILE,,,0,
489825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,setsid,,true,,,setsid,,,0,
489828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,dup2,,true,,,dup2,,,0,
489833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConnectionType.serverPanic(""Unrecoverable error creating %s accept handler."", listener->ct->get_type(NULL))",,true,,,"serverPanic(""Unrecoverable error creating %s accept handler."", listener->ct->get_type(NULL))",,,0,
489838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,redismodule.h,redismodule.h:672:672:REDISMODULE_SUBEVENT_FORK_CHILD_BORN:0,,true,672,672,REDISMODULE_SUBEVENT_FORK_CHILD_BORN,,,0,
489841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unsetenv,,true,,,unsetenv,,,0,
489845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tzset,,true,,,tzset,,,0,
489848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,umask,,true,,,umask,,,0,
489852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ConnectionType.serverLog(LL_NOTICE,""Ready to accept connections %s"", listener->ct->get_type(NULL))",,true,,,"serverLog(LL_NOTICE,""Ready to accept connections %s"", listener->ct->get_type(NULL))",,,0,
489857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha1.c,sha1.c:47:47:R0:6,,true,47,47,R0,,,0,
489866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,blk0,,true,,,blk0,,,0,
489870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha1.c,sha1.c:48:48:R1:6,,true,48,48,R1,,,0,
489879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha1.c,sha1.c:49:49:R2:6,,true,49,49,R2,,,0,
489888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha1.c,sha1.c:50:50:R3:6,,true,50,50,R3,,,0,
489897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha1.c,sha1.c:51:51:R4:6,,true,51,51,R4,,,0,
489906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.c,sha256.c:29:29:SIG1:1,,true,29,29,SIG1,,,0,
489909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.c,sha256.c:28:28:SIG0:1,,true,28,28,SIG0,,,0,
489912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.c,sha256.c:27:27:EP1:1,,true,27,27,EP1,,,0,
489916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.c,sha256.c:24:24:CH:3,,true,24,24,CH,,,0,
489922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.c,sha256.c:26:26:EP0:1,,true,26,26,EP0,,,0,
489926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sha256.c,sha256.c:25:25:MAJ:3,,true,25,25,MAJ,,,0,
489932,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,siphash.c,siphash.c:91:95:U8TO64_LE:1,,true,91,95,U8TO64_LE,,,0,
489935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,siphash.c,siphash.c:108:124:SIPROUND:0,,true,108,124,SIPROUND,,,0,
489938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,siphash.c,siphash.c:84:86:U64TO8_LE:2,,true,84,86,U64TO8_LE,,,0,
489943,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,uint8_t,,true,,,uint8_t,,,0,
489947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,siphash.c,siphash.c:98:106:U8TO64_LE_NOCASE:1,,true,98,106,U8TO64_LE_NOCASE,,,0,
489951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slowlog.h,slowlog.h:33:33:SLOWLOG_ENTRY_MAX_ARGC:0,,true,33,33,SLOWLOG_ENTRY_MAX_ARGC,,,0,
489954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,slowlog.h,slowlog.h:34:34:SLOWLOG_ENTRY_MAX_STRING:0,,true,34,34,SLOWLOG_ENTRY_MAX_STRING,,,0,
489957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,shutdown,,true,,,shutdown,,,0,
489962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writev,,true,,,writev,,,0,
489968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:59:59:CONN_FLAG_WRITE_BARRIER:0,,true,59,59,CONN_FLAG_WRITE_BARRIER,,,0,
489971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,connection.h,connection.h:43:43:MAX_ACCEPTS_PER_CALL:0,,true,43,43,MAX_ACCEPTS_PER_CALL,,,0,
489974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:503:503:SORT_OP_GET:0,,true,503,503,SORT_OP_GET,,,0,
489977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,sparkline.h,sparkline.h:48:48:SPARKLINE_LOG_SCALE:0,,true,48,48,SPARKLINE_LOG_SCALE,,,0,
489980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,syncio.c,syncio.c:43:43:SYNCIO__RESOLUTION:0,,true,43,43,SYNCIO__RESOLUTION,,,0,
489983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,anonymous_type_0.check_fn,,true,,,check_fn,,,0,
489988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_hash.c,t_hash.c:198:198:HASH_SET_TAKE_VALUE:0,,true,198,198,HASH_SET_TAKE_VALUE,,,0,
489991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_hash.c,t_hash.c:197:197:HASH_SET_TAKE_FIELD:0,,true,197,197,HASH_SET_TAKE_FIELD,,,0,
489994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_hash.c,t_hash.c:199:199:HASH_SET_COPY:0,,true,199,199,HASH_SET_COPY,,,0,
489997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isinf,,true,,,isinf,,,0,
490001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_hash.c,t_hash.c:924:924:HRANDFIELD_RANDOM_SAMPLE_LIMIT:0,,true,924,924,HRANDFIELD_RANDOM_SAMPLE_LIMIT,,,0,
490004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_hash.c,t_hash.c:919:919:HRANDFIELD_SUB_STRATEGY_MUL:0,,true,919,919,HRANDFIELD_SUB_STRATEGY_MUL,,,0,
490007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:551:551:SET_OP_UNION:0,,true,551,551,SET_OP_UNION,,,0,
490010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_set.c,t_set.c:759:759:SPOP_MOVE_STRATEGY_MUL:0,,true,759,759,SPOP_MOVE_STRATEGY_MUL,,,0,
490013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_set.c,t_set.c:1018:1018:SRANDFIELD_RANDOM_SAMPLE_LIMIT:0,,true,1018,1018,SRANDFIELD_RANDOM_SAMPLE_LIMIT,,,0,
490016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_set.c,t_set.c:1013:1013:SRANDMEMBER_SUB_STRATEGY_MUL:0,,true,1013,1013,SRANDMEMBER_SUB_STRATEGY_MUL,,,0,
490019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:552:552:SET_OP_DIFF:0,,true,552,552,SET_OP_DIFF,,,0,
490022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:287:287:lpGetInteger:1,,true,287,287,lpGetInteger,,,0,
490026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:54:54:STREAM_LISTPACK_MAX_SIZE:0,,true,54,54,STREAM_LISTPACK_MAX_SIZE,,,0,
490029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:37:37:STREAM_ITEM_FLAG_NONE:0,,true,37,37,STREAM_ITEM_FLAG_NONE,,,0,
490032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:48:48:STREAM_LISTPACK_MAX_PRE_ALLOCATE:0,,true,48,48,STREAM_LISTPACK_MAX_PRE_ALLOCATE,,,0,
490035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:39:39:STREAM_ITEM_FLAG_SAMEFIELDS:0,,true,39,39,STREAM_ITEM_FLAG_SAMEFIELDS,,,0,
490038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:692:692:TRIM_STRATEGY_NONE:0,,true,692,692,TRIM_STRATEGY_NONE,,,0,
490041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:693:693:TRIM_STRATEGY_MAXLEN:0,,true,693,693,TRIM_STRATEGY_MAXLEN,,,0,
490044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:694:694:TRIM_STRATEGY_MINID:0,,true,694,694,TRIM_STRATEGY_MINID,,,0,
490047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:38:38:STREAM_ITEM_FLAG_DELETED:0,,true,38,38,STREAM_ITEM_FLAG_DELETED,,,0,
490050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:1383:1383:STREAM_ID_STR_LEN:0,,true,1383,1383,STREAM_ID_STR_LEN,,,0,
490053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream.h,stream.h:114:114:SCG_INVALID_ENTRIES_READ:0,,true,114,114,SCG_INVALID_ENTRIES_READ,,,0,
490056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:1675:1675:STREAM_RWR_NOACK:0,,true,1675,1675,STREAM_RWR_NOACK,,,0,
490059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:1678:1678:STREAM_RWR_HISTORY:0,,true,1678,1678,STREAM_RWR_HISTORY,,,0,
490062,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:1676:1676:STREAM_RWR_RAWENTRIES:0,,true,1676,1676,STREAM_RWR_RAWENTRIES,,,0,
490065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_stream.c,t_stream.c:44:44:STREAMID_STATIC_VECTOR_LEN:0,,true,44,44,STREAMID_STATIC_VECTOR_LEN,,,0,
490068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,stream.h,stream.h:110:110:SCC_DEFAULT:0,,true,110,110,SCC_DEFAULT,,,0,
490071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:76:76:OBJ_SET_GET:0,,true,76,76,OBJ_SET_GET,,,0,
490074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:71:71:OBJ_SET_NX:0,,true,71,71,OBJ_SET_NX,,,0,
490077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:72:72:OBJ_SET_XX:0,,true,72,72,OBJ_SET_XX,,,0,
490080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:75:75:OBJ_KEEPTTL:0,,true,75,75,OBJ_KEEPTTL,,,0,
490083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:78:78:OBJ_PXAT:0,,true,78,78,OBJ_PXAT,,,0,
490086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:74:74:OBJ_PX:0,,true,74,74,OBJ_PX,,,0,
490089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:73:73:OBJ_EX:0,,true,73,73,OBJ_EX,,,0,
490092,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:191:191:COMMAND_GET:0,,true,191,191,COMMAND_GET,,,0,
490095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:192:192:COMMAND_SET:0,,true,192,192,COMMAND_SET,,,0,
490098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:79:79:OBJ_PERSIST:0,,true,79,79,OBJ_PERSIST,,,0,
490101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:77:77:OBJ_EXAT:0,,true,77,77,OBJ_EXAT,,,0,
490104,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:70:70:OBJ_NO_FLAGS:0,,true,70,70,OBJ_NO_FLAGS,,,0,
490107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_string.c,t_string.c:804:804:LCS:2,,true,804,804,LCS,,,0,
490112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:522:522:ZSKIPLIST_MAXLEVEL:0,,true,522,522,ZSKIPLIST_MAXLEVEL,,,0,
490115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:523:523:ZSKIPLIST_P:0,,true,523,523,ZSKIPLIST_P,,,0,
490118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2954:2954:ZADD_OUT_NAN:0,,true,2954,2954,ZADD_OUT_NAN,,,0,
490121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:2945:2945:ZADD_IN_NONE:0,,true,2945,2945,ZADD_IN_NONE,,,0,
490124,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:2044:2044:OPVAL_DIRTY_SDS:0,,true,2044,2044,OPVAL_DIRTY_SDS,,,0,
490127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:2045:2045:OPVAL_DIRTY_LL:0,,true,2045,2045,OPVAL_DIRTY_LL,,,0,
490130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:2046:2046:OPVAL_VALID_LL:0,,true,2046,2046,OPVAL_VALID_LL,,,0,
490133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:2346:2346:REDIS_AGGR_SUM:0,,true,2346,2346,REDIS_AGGR_SUM,,,0,
490136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:2347:2347:REDIS_AGGR_MIN:0,,true,2347,2347,REDIS_AGGR_MIN,,,0,
490139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:2348:2348:REDIS_AGGR_MAX:0,,true,2348,2348,REDIS_AGGR_MAX,,,0,
490142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:553:553:SET_OP_INTER:0,,true,553,553,SET_OP_INTER,,,0,
490145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,zrange_result_handler.beginResultEmission,,true,,,beginResultEmission,,,0,
490151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,zrange_result_handler.finalizeResultEmission,,true,,,finalizeResultEmission,,,0,
490157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,zrange_result_handler.emitResultFromLongLong,,true,,,emitResultFromLongLong,,,0,
490164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,zrange_result_handler.emitResultFromCBuffer,,true,,,emitResultFromCBuffer,,,0,
490172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:500:500:ZSET_MAX:0,,true,500,500,ZSET_MAX,,,0,
490175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:499:499:ZSET_MIN:0,,true,499,499,ZSET_MIN,,,0,
490178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:4156:4156:ZRANDMEMBER_RANDOM_SAMPLE_LIMIT:0,,true,4156,4156,ZRANDMEMBER_RANDOM_SAMPLE_LIMIT,,,0,
490181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,t_zset.c,t_zset.c:4151:4151:ZRANDMEMBER_SUB_STRATEGY_MUL:0,,true,4151,4151,ZRANDMEMBER_SUB_STRATEGY_MUL,,,0,
490184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,server.h,server.h:384:384:CLIENT_IN_TO_TABLE:0,,true,384,384,CLIENT_IN_TO_TABLE,,,0,
490187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ceill,,true,,,ceill,,,0,
490191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strtold,,true,,,strtold,,,0,
490196,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fpclassify,,true,,,fpclassify,,,0,
490200,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,llrint,,true,,,llrint,,,0,
490204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISREG,,true,,,S_ISREG,,,0,
490208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,S_ISDIR,,true,,,S_ISDIR,,,0,
490212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mkdir,,true,,,mkdir,,,0,
490217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,opendir,,true,,,opendir,,,0,
490221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readdir,,true,,,readdir,,,0,
490225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,closedir,,true,,,closedir,,,0,
490229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rmdir,,true,,,rmdir,,,0,
490233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util.c,util.c:53:53:UNUSED:1,,true,53,53,UNUSED,,,0,
490237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:272:272:ZIPLIST_MAX_SAFETY_SIZE:0,,true,272,272,ZIPLIST_MAX_SAFETY_SIZE,,,0,
490240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:209:209:ZIP_INT_16B:0,,true,209,209,ZIP_INT_16B,,,0,
490243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:210:210:ZIP_INT_32B:0,,true,210,210,ZIP_INT_32B,,,0,
490246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:212:212:ZIP_INT_24B:0,,true,212,212,ZIP_INT_24B,,,0,
490249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:211:211:ZIP_INT_64B:0,,true,211,211,ZIP_INT_64B,,,0,
490252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:213:213:ZIP_INT_8B:0,,true,213,213,ZIP_INT_8B,,,0,
490255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:219:219:ZIP_INT_IMM_MIN:0,,true,219,219,ZIP_INT_IMM_MIN,,,0,
490258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:220:220:ZIP_INT_IMM_MAX:0,,true,220,220,ZIP_INT_IMM_MAX,,,0,
490261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:206:206:ZIP_STR_06B:0,,true,206,206,ZIP_STR_06B,,,0,
490264,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:207:207:ZIP_STR_14B:0,,true,207,207,ZIP_STR_14B,,,0,
490267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:208:208:ZIP_STR_32B:0,,true,208,208,ZIP_STR_32B,,,0,
490270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:318:318:ZIP_ENCODING_SIZE_INVALID:0,,true,318,318,ZIP_ENCODING_SIZE_INVALID,,,0,
490273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:227:227:ZIP_IS_STR:1,,true,227,227,ZIP_IS_STR,,,0,
490277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:196:196:ZIP_BIG_PREVLEN:0,,true,196,196,ZIP_BIG_PREVLEN,,,0,
490280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:472:478:ZIP_DECODE_PREVLENSIZE:2,,true,472,478,ZIP_DECODE_PREVLENSIZE,,,0,
490285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:223:223:INT24_MIN:0,,true,223,223,INT24_MIN,,,0,
490288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:222:222:INT24_MAX:0,,true,222,222,INT24_MAX,,,0,
490291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:217:217:ZIP_INT_IMM_MASK:0,,true,217,217,ZIP_INT_IMM_MASK,,,0,
490294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:487:497:ZIP_DECODE_PREVLEN:3,,true,487,497,ZIP_DECODE_PREVLEN,,,0,
490300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:313:316:ZIP_ENTRY_ENCODING:2,,true,313,316,ZIP_ENTRY_ENCODING,,,0,
490304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:409:440:ZIP_DECODE_LENGTH:4,,true,409,440,ZIP_DECODE_LENGTH,,,0,
490310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:244:244:ZIPLIST_HEADER_SIZE:0,,true,244,244,ZIPLIST_HEADER_SIZE,,,0,
490313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:247:247:ZIPLIST_END_SIZE:0,,true,247,247,ZIPLIST_END_SIZE,,,0,
490316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:632:632:OUT_OF_RANGE:1,,true,632,632,OUT_OF_RANGE,,,0,
490319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:232:232:ZIPLIST_BYTES:1,,true,232,232,ZIPLIST_BYTES,,,0,
490323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:235:235:ZIPLIST_TAIL_OFFSET:1,,true,235,235,ZIPLIST_TAIL_OFFSET,,,0,
490327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:239:239:ZIPLIST_LENGTH:1,,true,239,239,ZIPLIST_LENGTH,,,0,
490331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:195:195:ZIP_END:0,,true,195,195,ZIP_END,,,0,
490334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:265:268:ZIPLIST_INCR_LENGTH:2,,true,265,268,ZIPLIST_INCR_LENGTH,,,0,
490339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:254:254:ZIPLIST_ENTRY_TAIL:1,,true,254,254,ZIPLIST_ENTRY_TAIL,,,0,
490343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,endianconv.h,endianconv.h:59:59:intrev16ifbe:1,,true,59,59,intrev16ifbe,,,0,
490346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.h,ziplist.h:34:34:ZIPLIST_HEAD:0,,true,34,34,ZIPLIST_HEAD,,,0,
490349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:250:250:ZIPLIST_ENTRY_HEAD:1,,true,250,250,ZIPLIST_ENTRY_HEAD,,,0,
490353,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,ziplist.c,ziplist.c:258:258:ZIPLIST_ENTRY_END:1,,true,258,258,ZIPLIST_ENTRY_END,,,0,
490357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zipmap.c,zipmap.c:84:84:ZIPMAP_END:0,,true,84,84,ZIPMAP_END,,,0,
490360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zipmap.c,zipmap.c:83:83:ZIPMAP_BIGLEN:0,,true,83,83,ZIPMAP_BIGLEN,,,0,
490363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zipmap.c,zipmap.c:93:93:ZIPMAP_LEN_BYTES:1,,true,93,93,ZIPMAP_LEN_BYTES,,,0,
490367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zipmap.c,zipmap.c:88:88:ZIPMAP_VALUE_MAX_FREE:0,,true,88,88,ZIPMAP_VALUE_MAX_FREE,,,0,
490370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zipmap.c,zipmap.c:381:383:OUT_OF_RANGE:1,,true,381,383,OUT_OF_RANGE,,,0,
490374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zmalloc.c,zmalloc.c:74:74:MALLOC_MIN_SIZE:1,,true,74,74,MALLOC_MIN_SIZE,,,0,
490378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zmalloc.c,zmalloc.c:67:67:PREFIX_SIZE:0,,true,67,67,PREFIX_SIZE,,,0,
490381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zmalloc.c,zmalloc.c:91:91:update_zmalloc_stat_alloc:1,,true,91,91,update_zmalloc_stat_alloc,,,0,
490385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,calloc,,true,,,calloc,,,0,
490390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,realloc,,true,,,realloc,,,0,
490395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zmalloc.c,zmalloc.c:92:92:update_zmalloc_stat_free:1,,true,92,92,update_zmalloc_stat_free,,,0,
490398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,zmalloc.c,zmalloc.c:58:58:UNUSED:1,,true,58,58,UNUSED,,,0,
