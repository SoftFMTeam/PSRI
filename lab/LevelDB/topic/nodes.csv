,Id,Name,NodeType,Fullname,Signature,Filename,Code,LineNumber,LineNumberEnd,ColumnNumber,ColumnNumberEnd,LineOfCode,NumberOfOperators,SetOfOperators,NumberOfOperands,SetOfOperands,FanIn,FanOut,McCabe,AccCyc,ConCf,ConDf,ConZc,ConRf,ConVal,Parma,ParmaIn,ParmaOut,RetType
0,19,dbname_,3,leveldb.AutoCompactTest.dbname_,,db\autocompact_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1,20,tiny_cache_,3,leveldb.AutoCompactTest.tiny_cache_,,db\autocompact_test.cc,* tiny_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
2,21,options_,3,leveldb.AutoCompactTest.options_,,db\autocompact_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
3,22,db_,3,leveldb.AutoCompactTest.db_,,db\autocompact_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
4,846,rep,3,leveldb_t.rep,,db\c.cc,*               rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
5,848,rep,3,leveldb_iterator_t.rep,,db\c.cc,*         rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
6,850,rep,3,leveldb_writebatch_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
7,852,rep,3,leveldb_snapshot_t.rep,,db\c.cc,*   rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
8,854,rep,3,leveldb_readoptions_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
9,856,rep,3,leveldb_writeoptions_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
10,858,rep,3,leveldb_options_t.rep,,db\c.cc,rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
11,860,rep,3,leveldb_cache_t.rep,,db\c.cc,*            rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
12,868,rep,3,leveldb_logger_t.rep,,db\c.cc,*           rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
13,872,state_,3,leveldb_comparator_t.state_,,db\c.cc,* state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
14,948,state_,3,leveldb_filterpolicy_t.state_,,db\c.cc,* state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
15,1099,rep,3,leveldb_env_t.rep,,db\c.cc,* rep,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
16,1100,is_default,3,leveldb_env_t.is_default,,db\c.cc,is_default,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
17,3870,env_,3,leveldb.CorruptionTest.env_,,db\corruption_test.cc,env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
18,3871,dbname_,3,leveldb.CorruptionTest.dbname_,,db\corruption_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
19,3872,tiny_cache_,3,leveldb.CorruptionTest.tiny_cache_,,db\corruption_test.cc,* tiny_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
20,3873,options_,3,leveldb.CorruptionTest.options_,,db\corruption_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
21,3874,db_,3,leveldb.CorruptionTest.db_,,db\corruption_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
22,6027,data_,3,leveldb.anonymous_namespace_1.RandomGenerator.data_,,db\db_bench.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
23,6028,pos_,3,leveldb.anonymous_namespace_1.RandomGenerator.pos_,,db\db_bench.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
24,6140,start_,3,leveldb.anonymous_namespace_5.Stats.start_,,db\db_bench.cc,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
25,6141,finish_,3,leveldb.anonymous_namespace_5.Stats.finish_,,db\db_bench.cc,finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
26,6142,seconds_,3,leveldb.anonymous_namespace_5.Stats.seconds_,,db\db_bench.cc,seconds_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
27,6143,done_,3,leveldb.anonymous_namespace_5.Stats.done_,,db\db_bench.cc,done_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
28,6144,next_report_,3,leveldb.anonymous_namespace_5.Stats.next_report_,,db\db_bench.cc,next_report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
29,6145,bytes_,3,leveldb.anonymous_namespace_5.Stats.bytes_,,db\db_bench.cc,bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
30,6146,last_op_finish_,3,leveldb.anonymous_namespace_5.Stats.last_op_finish_,,db\db_bench.cc,last_op_finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
31,6147,hist_,3,leveldb.anonymous_namespace_5.Stats.hist_,,db\db_bench.cc,hist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
32,6148,message_,3,leveldb.anonymous_namespace_5.Stats.message_,,db\db_bench.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
33,6487,mu,3,leveldb.anonymous_namespace_17.SharedState.mu,,db\db_bench.cc,mu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
34,6488,cv,3,leveldb.anonymous_namespace_17.SharedState.cv,,db\db_bench.cc,cv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
35,6489,total,3,leveldb.anonymous_namespace_17.SharedState.total,,db\db_bench.cc,total,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
36,6490,num_initialized,3,leveldb.anonymous_namespace_17.SharedState.num_initialized,,db\db_bench.cc,num_initialized,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
37,6491,num_done,3,leveldb.anonymous_namespace_17.SharedState.num_done,,db\db_bench.cc,num_done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
38,6492,start,3,leveldb.anonymous_namespace_17.SharedState.start,,db\db_bench.cc,start,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
39,6498,tid,3,leveldb.anonymous_namespace_19.ThreadState.tid,,db\db_bench.cc,tid,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
40,6499,rand,3,leveldb.anonymous_namespace_19.ThreadState.rand,,db\db_bench.cc,rand,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
41,6500,stats,3,leveldb.anonymous_namespace_19.ThreadState.stats,,db\db_bench.cc,stats,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
42,6510,db_,3,leveldb.Benchmark.db_,,db\db_bench.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
43,6511,num_,3,leveldb.Benchmark.num_,,db\db_bench.cc,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
44,6512,value_size_,3,leveldb.Benchmark.value_size_,,db\db_bench.cc,value_size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
45,6513,entries_per_batch_,3,leveldb.Benchmark.entries_per_batch_,,db\db_bench.cc,entries_per_batch_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
46,6514,write_options_,3,leveldb.Benchmark.write_options_,,db\db_bench.cc,write_options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
47,6515,reads_,3,leveldb.Benchmark.reads_,,db\db_bench.cc,reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
48,6516,heap_counter_,3,leveldb.Benchmark.heap_counter_,,db\db_bench.cc,heap_counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
49,7225,bm,3,leveldb.Benchmark.ThreadArg.bm,,db\db_bench.cc,* bm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
50,7226,shared,3,leveldb.Benchmark.ThreadArg.shared,,db\db_bench.cc,* shared,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
51,7227,thread,3,leveldb.Benchmark.ThreadArg.thread,,db\db_bench.cc,* thread,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
52,9409,status,3,leveldb.Writer.status,,db\db_impl.cc,status,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
53,9410,batch,3,leveldb.Writer.batch,,db\db_impl.cc,* batch,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
54,9411,sync,3,leveldb.Writer.sync,,db\db_impl.cc,sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
55,9412,done,3,leveldb.Writer.done,,db\db_impl.cc,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
56,9413,cv,3,leveldb.Writer.cv,,db\db_impl.cc,cv,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
57,9420,compaction,3,leveldb.CompactionState.compaction,,db\db_impl.cc,* const compaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
58,9421,smallest_snapshot,3,leveldb.CompactionState.smallest_snapshot,,db\db_impl.cc,smallest_snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
59,9427,outputs,3,leveldb.CompactionState.outputs,,db\db_impl.cc,outputs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
60,9428,outfile,3,leveldb.CompactionState.outfile,,db\db_impl.cc,* outfile,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
61,9429,builder,3,leveldb.CompactionState.builder,,db\db_impl.cc,* builder,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
62,9430,total_bytes,3,leveldb.CompactionState.total_bytes,,db\db_impl.cc,total_bytes,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
63,12877,mu,3,leveldb.anonymous_namespace_1.IterState.mu,,db\db_impl.cc,* mu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
64,12878,version,3,leveldb.anonymous_namespace_1.IterState.version,,db\db_impl.cc,* version,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
65,12879,mem,3,leveldb.anonymous_namespace_1.IterState.mem,,db\db_impl.cc,* mem,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
66,12880,imm,3,leveldb.anonymous_namespace_1.IterState.imm,,db\db_impl.cc,* imm,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
67,14946,env_,3,leveldb.DBImpl.env_,,db\db_impl.hpp,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,21,0,1,1,0,0,,0,0,0,0,0,
68,14947,internal_comparator_,3,leveldb.DBImpl.internal_comparator_,,db\db_impl.hpp,internal_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
69,14949,options_,3,leveldb.DBImpl.options_,,db\db_impl.hpp,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
70,14950,owns_info_log_,3,leveldb.DBImpl.owns_info_log_,,db\db_impl.hpp,owns_info_log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
71,14951,owns_cache_,3,leveldb.DBImpl.owns_cache_,,db\db_impl.hpp,owns_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
72,14952,dbname_,3,leveldb.DBImpl.dbname_,,db\db_impl.hpp,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
73,14953,table_cache_,3,leveldb.DBImpl.table_cache_,,db\db_impl.hpp,* table_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
74,14954,db_lock_,3,leveldb.DBImpl.db_lock_,,db\db_impl.hpp,* db_lock_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
75,14955,mutex_,3,leveldb.DBImpl.mutex_,,db\db_impl.hpp,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,46,0,1,1,0,0,,0,0,0,0,0,
76,14956,shutting_down_,3,leveldb.DBImpl.shutting_down_,,db\db_impl.hpp,shutting_down_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
77,14957,bg_cv_,3,leveldb.DBImpl.bg_cv_,,db\db_impl.hpp,bg_cv_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
78,14958,mem_,3,leveldb.DBImpl.mem_,,db\db_impl.hpp,* mem_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
79,14959,imm_,3,leveldb.DBImpl.imm_,,db\db_impl.hpp,* imm_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
80,14960,has_imm_,3,leveldb.DBImpl.has_imm_,,db\db_impl.hpp,has_imm_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
81,14961,logfile_,3,leveldb.DBImpl.logfile_,,db\db_impl.hpp,* logfile_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
82,14962,logfile_number_,3,leveldb.DBImpl.logfile_number_,,db\db_impl.hpp,logfile_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
83,14963,log_,3,leveldb.DBImpl.log_,,db\db_impl.hpp,* log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
84,14964,seed_,3,leveldb.DBImpl.seed_,,db\db_impl.hpp,seed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
85,14965,writers_,3,leveldb.DBImpl.writers_,,db\db_impl.hpp,writers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
86,14966,tmp_batch_,3,leveldb.DBImpl.tmp_batch_,,db\db_impl.hpp,* tmp_batch_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
87,14967,snapshots_,3,leveldb.DBImpl.snapshots_,,db\db_impl.hpp,snapshots_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
88,14968,pending_outputs_,3,leveldb.DBImpl.pending_outputs_,,db\db_impl.hpp,pending_outputs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
89,14969,bg_compaction_scheduled_,3,leveldb.DBImpl.bg_compaction_scheduled_,,db\db_impl.hpp,bg_compaction_scheduled_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
90,14971,level,3,leveldb.DBImpl.ManualCompaction.level,,db\db_impl.hpp,level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
91,14972,done,3,leveldb.DBImpl.ManualCompaction.done,,db\db_impl.hpp,done,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
92,14973,begin,3,leveldb.DBImpl.ManualCompaction.begin,,db\db_impl.hpp,* begin,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
93,14974,end,3,leveldb.DBImpl.ManualCompaction.end,,db\db_impl.hpp,* end,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
94,14975,tmp_storage,3,leveldb.DBImpl.ManualCompaction.tmp_storage,,db\db_impl.hpp,tmp_storage,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
95,14976,manual_compaction_,3,leveldb.DBImpl.manual_compaction_,,db\db_impl.hpp,* manual_compaction_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
96,14977,versions_,3,leveldb.DBImpl.versions_,,db\db_impl.hpp,* versions_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,40,0,1,1,0,0,,0,0,0,0,0,
97,14978,bg_error_,3,leveldb.DBImpl.bg_error_,,db\db_impl.hpp,bg_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
98,14980,micros,3,leveldb.DBImpl.CompactionStats.micros,,db\db_impl.hpp,micros,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
99,14981,bytes_read,3,leveldb.DBImpl.CompactionStats.bytes_read,,db\db_impl.hpp,bytes_read,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
100,14982,bytes_written,3,leveldb.DBImpl.CompactionStats.bytes_written,,db\db_impl.hpp,bytes_written,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
101,15013,stats_,3,leveldb.DBImpl.stats_,,db\db_impl.hpp,stats_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
102,15078,kForward,3,leveldb.anonymous_namespace_2.DBIter.Direction.kForward,,db\db_iter.cc,kForward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
103,15245,iter_,3,leveldb.anonymous_namespace_1.DBIter.iter_,,db\db_iter.cc,* const iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
104,15247,status_,3,leveldb.anonymous_namespace_1.DBIter.status_,,db\db_iter.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
105,15248,saved_key_,3,leveldb.anonymous_namespace_1.DBIter.saved_key_,,db\db_iter.cc,saved_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
106,15249,saved_value_,3,leveldb.anonymous_namespace_1.DBIter.saved_value_,,db\db_iter.cc,saved_value_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
107,15250,direction_,3,leveldb.anonymous_namespace_1.DBIter.direction_,,db\db_iter.cc,direction_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
108,15251,valid_,3,leveldb.anonymous_namespace_1.DBIter.valid_,,db\db_iter.cc,valid_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
109,15252,rnd_,3,leveldb.anonymous_namespace_1.DBIter.rnd_,,db\db_iter.cc,rnd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
110,15851,mu_,3,leveldb.anonymous_namespace_1.AtomicCounter.mu_,,db\db_test.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
111,15852,count_,3,leveldb.anonymous_namespace_1.AtomicCounter.count_,,db\db_test.cc,count_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
112,15912,delay_data_sync_,3,leveldb.SpecialEnv.delay_data_sync_,,db\db_test.cc,delay_data_sync_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
113,15913,data_sync_error_,3,leveldb.SpecialEnv.data_sync_error_,,db\db_test.cc,data_sync_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
114,15914,no_space_,3,leveldb.SpecialEnv.no_space_,,db\db_test.cc,no_space_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
115,15915,non_writable_,3,leveldb.SpecialEnv.non_writable_,,db\db_test.cc,non_writable_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
116,15916,manifest_sync_error_,3,leveldb.SpecialEnv.manifest_sync_error_,,db\db_test.cc,manifest_sync_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
117,15917,manifest_write_error_,3,leveldb.SpecialEnv.manifest_write_error_,,db\db_test.cc,manifest_write_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
118,15918,count_random_reads_,3,leveldb.SpecialEnv.count_random_reads_,,db\db_test.cc,count_random_reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
119,15919,random_read_counter_,3,leveldb.SpecialEnv.random_read_counter_,,db\db_test.cc,random_read_counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
120,16077,filter_policy_,3,leveldb.DBTest.filter_policy_,,db\db_test.cc,* filter_policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
121,16080,kReuse,3,leveldb.DBTest.OptionConfig.kReuse,,db\db_test.cc,kReuse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
122,16081,kFilter,3,leveldb.DBTest.OptionConfig.kFilter,,db\db_test.cc,kFilter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
123,16082,kUncompressed,3,leveldb.DBTest.OptionConfig.kUncompressed,,db\db_test.cc,kUncompressed,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
124,16083,kEnd,3,leveldb.DBTest.OptionConfig.kEnd,,db\db_test.cc,kEnd,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
125,16084,option_config_,3,leveldb.DBTest.option_config_,,db\db_test.cc,option_config_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
126,16085,dbname_,3,leveldb.DBTest.dbname_,,db\db_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
127,16086,env_,3,leveldb.DBTest.env_,,db\db_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
128,16087,db_,3,leveldb.DBTest.db_,,db\db_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
129,16088,last_options_,3,leveldb.DBTest.last_options_,,db\db_test.cc,last_options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
130,27493,state,3,leveldb.anonymous_namespace_16.MTThread.state,,db\db_test.cc,* state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
131,27494,id,3,leveldb.anonymous_namespace_16.MTThread.id,,db\db_test.cc,id,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
132,27957,map_,3,leveldb.ModelDB.ModelSnapshot.map_,,db\db_test.cc,map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
133,28256,map_,3,leveldb.ModelDB.ModelIter.map_,,db\db_test.cc,* const map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
134,28257,owned_,3,leveldb.ModelDB.ModelIter.owned_,,db\db_test.cc,owned_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
135,28258,iter_,3,leveldb.ModelDB.ModelIter.iter_,,db\db_test.cc,iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
136,29875,user_key,3,leveldb.ParsedInternalKey.user_key,,db\dbformat.hpp,user_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
137,29876,sequence,3,leveldb.ParsedInternalKey.sequence,,db\dbformat.hpp,sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
138,29877,type,3,leveldb.ParsedInternalKey.type,,db\dbformat.hpp,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
139,29985,user_comparator_,3,leveldb.InternalKeyComparator.user_comparator_,,db\dbformat.hpp,* user_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
140,30025,user_policy_,3,leveldb.InternalFilterPolicy.user_policy_,,db\dbformat.hpp,* const user_policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
141,30049,rep_,3,leveldb.InternalKey.rep_,,db\dbformat.hpp,rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
142,30258,start_,3,leveldb.LookupKey.start_,,db\dbformat.hpp,* start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
143,30259,kstart_,3,leveldb.LookupKey.kstart_,,db\dbformat.hpp,* kstart_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
144,30260,end_,3,leveldb.LookupKey.end_,,db\dbformat.hpp,* end_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
145,30261,space_,3,leveldb.LookupKey.space_,,db\dbformat.hpp,space_[200],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
146,31044,dst_,3,leveldb.anonymous_namespace_2.CorruptionReporter.dst_,,db\dumpfile.cc,* dst_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
147,31148,dst_,3,leveldb.anonymous_namespace_5.WriteBatchItemPrinter.dst_,,db\dumpfile.cc,* dst_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
148,31911,pos_,3,leveldb.anonymous_namespace_5.FileState.pos_,,db\fault_injection_test.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
149,31912,pos_at_last_sync_,3,leveldb.anonymous_namespace_5.FileState.pos_at_last_sync_,,db\fault_injection_test.cc,pos_at_last_sync_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
150,32056,filesystem_active_,3,leveldb.FaultInjectionTestEnv.filesystem_active_,,db\fault_injection_test.cc,filesystem_active_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
151,32703,VAL_EXPECT_NO_ERROR,3,leveldb.FaultInjectionTest.ExpectedVerifResult.VAL_EXPECT_NO_ERROR,,db\fault_injection_test.cc,VAL_EXPECT_NO_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
152,32704,VAL_EXPECT_ERROR,3,leveldb.FaultInjectionTest.ExpectedVerifResult.VAL_EXPECT_ERROR,,db\fault_injection_test.cc,VAL_EXPECT_ERROR,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
153,32706,RESET_DROP_UNSYNCED_DATA,3,leveldb.FaultInjectionTest.ResetMethod.RESET_DROP_UNSYNCED_DATA,,db\fault_injection_test.cc,RESET_DROP_UNSYNCED_DATA,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
154,32707,RESET_DELETE_UNSYNCED_FILES,3,leveldb.FaultInjectionTest.ResetMethod.RESET_DELETE_UNSYNCED_FILES,,db\fault_injection_test.cc,RESET_DELETE_UNSYNCED_FILES,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
155,32708,env_,3,leveldb.FaultInjectionTest.env_,,db\fault_injection_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
156,32709,dbname_,3,leveldb.FaultInjectionTest.dbname_,,db\fault_injection_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
157,32710,tiny_cache_,3,leveldb.FaultInjectionTest.tiny_cache_,,db\fault_injection_test.cc,* tiny_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
158,32711,options_,3,leveldb.FaultInjectionTest.options_,,db\fault_injection_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
159,32712,db_,3,leveldb.FaultInjectionTest.db_,,db\fault_injection_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
160,35752,file_,3,leveldb.log.Reader.file_,,db\log_reader.hpp,* const file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
161,35753,reporter_,3,leveldb.log.Reader.reporter_,,db\log_reader.hpp,* const reporter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
162,35754,checksum_,3,leveldb.log.Reader.checksum_,,db\log_reader.hpp,checksum_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
163,35755,backing_store_,3,leveldb.log.Reader.backing_store_,,db\log_reader.hpp,* const backing_store_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
164,35756,buffer_,3,leveldb.log.Reader.buffer_,,db\log_reader.hpp,buffer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
165,35757,eof_,3,leveldb.log.Reader.eof_,,db\log_reader.hpp,eof_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
166,35758,last_record_offset_,3,leveldb.log.Reader.last_record_offset_,,db\log_reader.hpp,last_record_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
167,35759,end_of_buffer_offset_,3,leveldb.log.Reader.end_of_buffer_offset_,,db\log_reader.hpp,end_of_buffer_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
168,35760,initial_offset_,3,leveldb.log.Reader.initial_offset_,,db\log_reader.hpp,initial_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
169,35761,resyncing_,3,leveldb.log.Reader.resyncing_,,db\log_reader.hpp,resyncing_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
170,35763,kEof,3,leveldb.log.Reader.anonymous_enum_0.kEof,,db\log_reader.hpp,kEof = kMaxRecordType + 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
171,35764,kBadRecord,3,leveldb.log.Reader.anonymous_enum_0.kBadRecord,,db\log_reader.hpp,kBadRecord = kMaxRecordType + 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
172,35893,contents_,3,leveldb.log.LogTest.StringDest.contents_,,db\log_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
173,35944,contents_,3,leveldb.log.LogTest.StringSource.contents_,,db\log_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
174,35945,force_error_,3,leveldb.log.LogTest.StringSource.force_error_,,db\log_test.cc,force_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
175,35946,returned_partial_,3,leveldb.log.LogTest.StringSource.returned_partial_,,db\log_test.cc,returned_partial_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
176,36063,dropped_bytes_,3,leveldb.log.LogTest.ReportCollector.dropped_bytes_,,db\log_test.cc,dropped_bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
177,36064,message_,3,leveldb.log.LogTest.ReportCollector.message_,,db\log_test.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
178,36086,dest_,3,leveldb.log.LogTest.dest_,,db\log_test.cc,dest_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
179,36087,source_,3,leveldb.log.LogTest.source_,,db\log_test.cc,source_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
180,36088,report_,3,leveldb.log.LogTest.report_,,db\log_test.cc,report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
181,36089,reading_,3,leveldb.log.LogTest.reading_,,db\log_test.cc,reading_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
182,36090,writer_,3,leveldb.log.LogTest.writer_,,db\log_test.cc,* writer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
183,36091,reader_,3,leveldb.log.LogTest.reader_,,db\log_test.cc,* reader_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
184,36092,initial_offset_record_sizes_,3,leveldb.log.LogTest.initial_offset_record_sizes_,,db\log_test.cc,initial_offset_record_sizes_[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
185,36093,initial_offset_last_record_offsets_,3,leveldb.log.LogTest.initial_offset_last_record_offsets_,,db\log_test.cc,initial_offset_last_record_offsets_[],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
186,36094,num_initial_offset_records_,3,leveldb.log.LogTest.num_initial_offset_records_,,db\log_test.cc,num_initial_offset_records_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
187,40124,dest_,3,leveldb.log.Writer.dest_,,db\log_writer.hpp,* dest_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
188,40125,block_offset_,3,leveldb.log.Writer.block_offset_,,db\log_writer.hpp,block_offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
189,40126,type_crc_,3,leveldb.log.Writer.type_crc_,,db\log_writer.hpp,type_crc_[kMaxRecordType + 1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
190,40373,iter_,3,leveldb.MemTableIterator.iter_,,db\memtable.cc,iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
191,40374,tmp_,3,leveldb.MemTableIterator.tmp_,,db\memtable.cc,tmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
192,40695,comparator,3,leveldb.MemTable.KeyComparator.comparator,,db\memtable.hpp,comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
193,40710,comparator_,3,leveldb.MemTable.comparator_,,db\memtable.hpp,comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
194,40711,refs_,3,leveldb.MemTable.refs_,,db\memtable.hpp,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
195,40712,arena_,3,leveldb.MemTable.arena_,,db\memtable.hpp,arena_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
196,40713,table_,3,leveldb.MemTable.table_,,db\memtable.hpp,table_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
197,41352,dbname_,3,leveldb.RecoveryTest.dbname_,,db\recovery_test.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
198,41353,env_,3,leveldb.RecoveryTest.env_,,db\recovery_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
199,41354,db_,3,leveldb.RecoveryTest.db_,,db\recovery_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
200,42925,meta,3,leveldb.anonymous_namespace_9.Repairer.TableInfo.meta,,db\repair.cc,meta,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,16,0,1,1,0,0,,0,0,0,0,0,
201,42926,max_sequence,3,leveldb.anonymous_namespace_9.Repairer.TableInfo.max_sequence,,db\repair.cc,max_sequence,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
202,42927,dbname_,3,leveldb.anonymous_namespace_1.Repairer.dbname_,,db\repair.cc,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
203,42928,env_,3,leveldb.anonymous_namespace_1.Repairer.env_,,db\repair.cc,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
204,42929,icmp_,3,leveldb.anonymous_namespace_1.Repairer.icmp_,,db\repair.cc,icmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
205,42931,options_,3,leveldb.anonymous_namespace_1.Repairer.options_,,db\repair.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
206,42932,owns_info_log_,3,leveldb.anonymous_namespace_1.Repairer.owns_info_log_,,db\repair.cc,owns_info_log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
207,42933,owns_cache_,3,leveldb.anonymous_namespace_1.Repairer.owns_cache_,,db\repair.cc,owns_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
208,42934,table_cache_,3,leveldb.anonymous_namespace_1.Repairer.table_cache_,,db\repair.cc,* table_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
209,42935,edit_,3,leveldb.anonymous_namespace_1.Repairer.edit_,,db\repair.cc,edit_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
210,42936,manifests_,3,leveldb.anonymous_namespace_1.Repairer.manifests_,,db\repair.cc,manifests_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
211,42937,table_numbers_,3,leveldb.anonymous_namespace_1.Repairer.table_numbers_,,db\repair.cc,table_numbers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
212,42938,logs_,3,leveldb.anonymous_namespace_1.Repairer.logs_,,db\repair.cc,logs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
213,42939,tables_,3,leveldb.anonymous_namespace_1.Repairer.tables_,,db\repair.cc,tables_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
214,42940,next_file_number_,3,leveldb.anonymous_namespace_1.Repairer.next_file_number_,,db\repair.cc,next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
215,44313,max_height_,3,leveldb.SkipList.max_height_,,db\skiplist.hpp,max_height_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
216,44387,key,3,leveldb.Node.key,,db\skiplist.hpp,key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
217,44458,next_,3,leveldb.Node.next_,,db\skiplist.hpp,next_[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
218,45798,K,3,leveldb.ConcurrentTest.K,,db\skiplist_test.cc,K = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
219,45934,generation,3,leveldb.ConcurrentTest.State.generation,,db\skiplist_test.cc,generation[K],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
220,45989,current_,3,leveldb.ConcurrentTest.current_,,db\skiplist_test.cc,current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
221,45991,list_,3,leveldb.ConcurrentTest.list_,,db\skiplist_test.cc,list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
222,46365,t_,3,leveldb.TestState.t_,,db\skiplist_test.cc,t_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
223,46366,seed_,3,leveldb.TestState.seed_,,db\skiplist_test.cc,seed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
224,46367,quit_flag_,3,leveldb.TestState.quit_flag_,,db\skiplist_test.cc,quit_flag_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
225,46370,RUNNING,3,leveldb.TestState.ReaderState.RUNNING,,db\skiplist_test.cc,RUNNING,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
226,46371,DONE,3,leveldb.TestState.ReaderState.DONE,,db\skiplist_test.cc,DONE,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
227,46419,mu_,3,leveldb.TestState.mu_,,db\skiplist_test.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
228,46420,state_,3,leveldb.TestState.state_,,db\skiplist_test.cc,state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
229,46421,state_cv_,3,leveldb.TestState.state_cv_,,db\skiplist_test.cc,state_cv_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
230,46783,number_,3,leveldb.SnapshotImpl.number_,,db\snapshot.hpp,number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
231,46785,prev_,3,leveldb.SnapshotImpl.prev_,,db\snapshot.hpp,* prev_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
232,46786,next_,3,leveldb.SnapshotImpl.next_,,db\snapshot.hpp,* next_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
233,46787,list_,3,leveldb.SnapshotImpl.list_,,db\snapshot.hpp,* list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
234,46918,list_,3,leveldb.SnapshotList.list_,,db\snapshot.hpp,list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
235,46936,file,3,leveldb.TableAndFile.file,,db\table_cache.cc,* file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
236,46937,table,3,leveldb.TableAndFile.table,,db\table_cache.cc,* table,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
237,47349,env_,3,leveldb.TableCache.env_,,db\table_cache.hpp,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
238,47350,dbname_,3,leveldb.TableCache.dbname_,,db\table_cache.hpp,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
239,47351,options_,3,leveldb.TableCache.options_,,db\table_cache.hpp,* options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
240,47352,cache_,3,leveldb.TableCache.cache_,,db\table_cache.hpp,* cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
241,48231,refs,3,leveldb.FileMetaData.refs,,db\version_edit.hpp,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
242,48232,allowed_seeks,3,leveldb.FileMetaData.allowed_seeks,,db\version_edit.hpp,allowed_seeks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
243,48233,number,3,leveldb.FileMetaData.number,,db\version_edit.hpp,number,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,23,0,1,1,0,0,,0,0,0,0,0,
244,48234,file_size,3,leveldb.FileMetaData.file_size,,db\version_edit.hpp,file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
245,48235,smallest,3,leveldb.FileMetaData.smallest,,db\version_edit.hpp,smallest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
246,48236,largest,3,leveldb.FileMetaData.largest,,db\version_edit.hpp,largest,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,18,0,1,1,0,0,,0,0,0,0,0,
247,48401,comparator_,3,leveldb.VersionEdit.comparator_,,db\version_edit.hpp,comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
248,48402,log_number_,3,leveldb.VersionEdit.log_number_,,db\version_edit.hpp,log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
249,48403,prev_log_number_,3,leveldb.VersionEdit.prev_log_number_,,db\version_edit.hpp,prev_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
250,48404,next_file_number_,3,leveldb.VersionEdit.next_file_number_,,db\version_edit.hpp,next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
251,48405,last_sequence_,3,leveldb.VersionEdit.last_sequence_,,db\version_edit.hpp,last_sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
252,48406,has_comparator_,3,leveldb.VersionEdit.has_comparator_,,db\version_edit.hpp,has_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
253,48407,has_log_number_,3,leveldb.VersionEdit.has_log_number_,,db\version_edit.hpp,has_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
254,48408,has_prev_log_number_,3,leveldb.VersionEdit.has_prev_log_number_,,db\version_edit.hpp,has_prev_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
255,48409,has_next_file_number_,3,leveldb.VersionEdit.has_next_file_number_,,db\version_edit.hpp,has_next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
256,48410,has_last_sequence_,3,leveldb.VersionEdit.has_last_sequence_,,db\version_edit.hpp,has_last_sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
257,48411,compact_pointers_,3,leveldb.VersionEdit.compact_pointers_,,db\version_edit.hpp,compact_pointers_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
258,48412,deleted_files_,3,leveldb.VersionEdit.deleted_files_,,db\version_edit.hpp,deleted_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
259,48413,new_files_,3,leveldb.VersionEdit.new_files_,,db\version_edit.hpp,new_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
260,49205,icmp_,3,leveldb.LevelFileNumIterator.icmp_,,db\version_set.cc,icmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
261,49206,flist_,3,leveldb.LevelFileNumIterator.flist_,,db\version_set.cc,* const flist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
262,49207,index_,3,leveldb.LevelFileNumIterator.index_,,db\version_set.cc,index_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
263,49208,value_buf_,3,leveldb.LevelFileNumIterator.value_buf_,,db\version_set.cc,value_buf_[16],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
264,49371,state,3,leveldb.anonymous_namespace_2.Saver.state,,db\version_set.cc,state,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
265,49372,ucmp,3,leveldb.anonymous_namespace_2.Saver.ucmp,,db\version_set.cc,* ucmp,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
266,49373,user_key,3,leveldb.anonymous_namespace_2.Saver.user_key,,db\version_set.cc,user_key,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
267,49374,value,3,leveldb.anonymous_namespace_2.Saver.value,,db\version_set.cc,* value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
268,50600,internal_comparator,3,leveldb.Builder.BySmallestKey.internal_comparator,,db\version_set.cc,* internal_comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
269,50643,vset_,3,leveldb.Builder.vset_,,db\version_set.cc,* vset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
270,50644,base_,3,leveldb.Builder.base_,,db\version_set.cc,* base_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
271,50645,levels_,3,leveldb.Builder.levels_,,db\version_set.cc,levels_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
272,54044,seek_file,3,leveldb.Version.GetStats.seek_file,,db\version_set.hpp,* seek_file,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
273,54045,seek_file_level,3,leveldb.Version.GetStats.seek_file_level,,db\version_set.hpp,seek_file_level,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
274,54126,vset_,3,leveldb.Version.vset_,,db\version_set.hpp,* vset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
275,54127,next_,3,leveldb.Version.next_,,db\version_set.hpp,* next_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
276,54128,prev_,3,leveldb.Version.prev_,,db\version_set.hpp,* prev_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
277,54129,refs_,3,leveldb.Version.refs_,,db\version_set.hpp,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
278,54130,files_,3,leveldb.Version.files_,,db\version_set.hpp,files_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,26,0,1,1,0,0,,0,0,0,0,0,
279,54131,file_to_compact_,3,leveldb.Version.file_to_compact_,,db\version_set.hpp,* file_to_compact_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
280,54132,file_to_compact_level_,3,leveldb.Version.file_to_compact_level_,,db\version_set.hpp,file_to_compact_level_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
281,54133,compaction_score_,3,leveldb.Version.compaction_score_,,db\version_set.hpp,compaction_score_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
282,54134,compaction_level_,3,leveldb.Version.compaction_level_,,db\version_set.hpp,compaction_level_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
283,54317,buffer,3,leveldb.VersionSet.LevelSummaryStorage.buffer,,db\version_set.hpp,buffer[100],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
284,54373,env_,3,leveldb.VersionSet.env_,,db\version_set.hpp,* const env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
285,54374,dbname_,3,leveldb.VersionSet.dbname_,,db\version_set.hpp,dbname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
286,54375,options_,3,leveldb.VersionSet.options_,,db\version_set.hpp,* const options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,14,0,1,1,0,0,,0,0,0,0,0,
287,54376,table_cache_,3,leveldb.VersionSet.table_cache_,,db\version_set.hpp,* const table_cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
288,54377,icmp_,3,leveldb.VersionSet.icmp_,,db\version_set.hpp,icmp_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
289,54378,next_file_number_,3,leveldb.VersionSet.next_file_number_,,db\version_set.hpp,next_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
290,54379,manifest_file_number_,3,leveldb.VersionSet.manifest_file_number_,,db\version_set.hpp,manifest_file_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
291,54380,last_sequence_,3,leveldb.VersionSet.last_sequence_,,db\version_set.hpp,last_sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
292,54381,log_number_,3,leveldb.VersionSet.log_number_,,db\version_set.hpp,log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
293,54382,prev_log_number_,3,leveldb.VersionSet.prev_log_number_,,db\version_set.hpp,prev_log_number_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
294,54383,descriptor_file_,3,leveldb.VersionSet.descriptor_file_,,db\version_set.hpp,* descriptor_file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
295,54384,descriptor_log_,3,leveldb.VersionSet.descriptor_log_,,db\version_set.hpp,* descriptor_log_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
296,54385,dummy_versions_,3,leveldb.VersionSet.dummy_versions_,,db\version_set.hpp,dummy_versions_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
297,54386,current_,3,leveldb.VersionSet.current_,,db\version_set.hpp,* current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,36,0,1,1,0,0,,0,0,0,0,0,
298,54387,compact_pointer_,3,leveldb.VersionSet.compact_pointer_,,db\version_set.hpp,compact_pointer_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
299,54485,level_,3,leveldb.Compaction.level_,,db\version_set.hpp,level_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
300,54486,max_output_file_size_,3,leveldb.Compaction.max_output_file_size_,,db\version_set.hpp,max_output_file_size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
301,54487,input_version_,3,leveldb.Compaction.input_version_,,db\version_set.hpp,* input_version_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
302,54488,edit_,3,leveldb.Compaction.edit_,,db\version_set.hpp,edit_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
303,54489,inputs_,3,leveldb.Compaction.inputs_,,db\version_set.hpp,inputs_[2],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,29,0,1,1,0,0,,0,0,0,0,0,
304,54490,grandparents_,3,leveldb.Compaction.grandparents_,,db\version_set.hpp,grandparents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
305,54491,grandparent_index_,3,leveldb.Compaction.grandparent_index_,,db\version_set.hpp,grandparent_index_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
306,54492,seen_key_,3,leveldb.Compaction.seen_key_,,db\version_set.hpp,seen_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
307,54493,overlapped_bytes_,3,leveldb.Compaction.overlapped_bytes_,,db\version_set.hpp,overlapped_bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
308,54494,level_ptrs_,3,leveldb.Compaction.level_ptrs_,,db\version_set.hpp,level_ptrs_[config::kNumLevels],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
309,54520,files_,3,leveldb.FindFileTest.files_,,db\version_set_test.cc,files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
310,54521,disjoint_sorted_files_,3,leveldb.FindFileTest.disjoint_sorted_files_,,db\version_set_test.cc,disjoint_sorted_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
311,56778,sequence_,3,leveldb.anonymous_namespace_1.MemTableInserter.sequence_,,db\write_batch.cc,sequence_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
312,56779,mem_,3,leveldb.anonymous_namespace_1.MemTableInserter.mem_,,db\write_batch.cc,* mem_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
313,57981,db_,3,leveldb.Benchmark.db_,,doc\bench\db_bench_sqlite3.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
314,57983,num_,3,leveldb.Benchmark.num_,,doc\bench\db_bench_sqlite3.cc,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
315,57984,reads_,3,leveldb.Benchmark.reads_,,doc\bench\db_bench_sqlite3.cc,reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
316,57985,start_,3,leveldb.Benchmark.start_,,doc\bench\db_bench_sqlite3.cc,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
317,57986,last_op_finish_,3,leveldb.Benchmark.last_op_finish_,,doc\bench\db_bench_sqlite3.cc,last_op_finish_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
318,57987,bytes_,3,leveldb.Benchmark.bytes_,,doc\bench\db_bench_sqlite3.cc,bytes_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
319,57988,message_,3,leveldb.Benchmark.message_,,doc\bench\db_bench_sqlite3.cc,message_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
320,57989,hist_,3,leveldb.Benchmark.hist_,,doc\bench\db_bench_sqlite3.cc,hist_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
321,57990,gen_,3,leveldb.Benchmark.gen_,,doc\bench\db_bench_sqlite3.cc,gen_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
322,57991,rand_,3,leveldb.Benchmark.rand_,,doc\bench\db_bench_sqlite3.cc,rand_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
323,57992,done_,3,leveldb.Benchmark.done_,,doc\bench\db_bench_sqlite3.cc,done_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
324,57993,next_report_,3,leveldb.Benchmark.next_report_,,doc\bench\db_bench_sqlite3.cc,next_report_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
325,58312,SEQUENTIAL,3,leveldb.Benchmark.Order.SEQUENTIAL,,doc\bench\db_bench_sqlite3.cc,SEQUENTIAL,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
326,58315,FRESH,3,leveldb.Benchmark.DBState.FRESH,,doc\bench\db_bench_sqlite3.cc,FRESH,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
327,59996,db_,3,leveldb.Benchmark.db_,,doc\bench\db_bench_tree_db.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
328,59998,num_,3,leveldb.Benchmark.num_,,doc\bench\db_bench_tree_db.cc,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
329,59999,reads_,3,leveldb.Benchmark.reads_,,doc\bench\db_bench_tree_db.cc,reads_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
330,61683,refs_mutex_,3,leveldb.anonymous_namespace_1.FileState.refs_mutex_,,helpers\memenv\memenv.cc,refs_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
331,61684,refs_,3,leveldb.anonymous_namespace_1.FileState.refs_,,helpers\memenv\memenv.cc,refs_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
332,61685,blocks_,3,leveldb.anonymous_namespace_1.FileState.blocks_,,helpers\memenv\memenv.cc,blocks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
333,61686,size_,3,leveldb.anonymous_namespace_1.FileState.size_,,helpers\memenv\memenv.cc,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
334,61688,kBlockSize,3,leveldb.anonymous_namespace_11.FileState.anonymous_enum_12.kBlockSize,,helpers\memenv\memenv.cc,kBlockSize = 8 * 1024,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
335,61792,file_,3,leveldb.anonymous_namespace_13.SequentialFileImpl.file_,,helpers\memenv\memenv.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
336,61793,pos_,3,leveldb.anonymous_namespace_13.SequentialFileImpl.pos_,,helpers\memenv\memenv.cc,pos_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
337,61829,file_,3,leveldb.anonymous_namespace_18.RandomAccessFileImpl.file_,,helpers\memenv\memenv.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
338,61886,file_,3,leveldb.anonymous_namespace_22.WritableFileImpl.file_,,helpers\memenv\memenv.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
339,62456,mutex_,3,leveldb.anonymous_namespace_31.InMemoryEnv.mutex_,,helpers\memenv\memenv.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
340,62457,file_map_,3,leveldb.anonymous_namespace_31.InMemoryEnv.file_map_,,helpers\memenv\memenv.cc,file_map_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,30,0,1,1,0,0,,0,0,0,0,0,
341,62500,env_,3,leveldb.MemEnvTest.env_,,helpers\memenv\memenv_test.cc,* env_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
342,66154,target_,3,leveldb.EnvWrapper.target_,,include\leveldb\env.hpp,* target_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
343,66313,comparator,3,leveldb.Options.comparator,,include\leveldb\options.hpp,* comparator,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
344,66314,create_if_missing,3,leveldb.Options.create_if_missing,,include\leveldb\options.hpp,create_if_missing,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
345,66315,error_if_exists,3,leveldb.Options.error_if_exists,,include\leveldb\options.hpp,error_if_exists,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
346,66317,env,3,leveldb.Options.env,,include\leveldb\options.hpp,* env,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
347,66318,info_log,3,leveldb.Options.info_log,,include\leveldb\options.hpp,* info_log,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
348,66319,write_buffer_size,3,leveldb.Options.write_buffer_size,,include\leveldb\options.hpp,write_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
349,66320,max_open_files,3,leveldb.Options.max_open_files,,include\leveldb\options.hpp,max_open_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
350,66321,block_cache,3,leveldb.Options.block_cache,,include\leveldb\options.hpp,* block_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
351,66322,block_size,3,leveldb.Options.block_size,,include\leveldb\options.hpp,block_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
352,66323,block_restart_interval,3,leveldb.Options.block_restart_interval,,include\leveldb\options.hpp,block_restart_interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
353,66324,max_file_size,3,leveldb.Options.max_file_size,,include\leveldb\options.hpp,max_file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
354,66325,compression,3,leveldb.Options.compression,,include\leveldb\options.hpp,compression,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
355,66326,reuse_logs,3,leveldb.Options.reuse_logs,,include\leveldb\options.hpp,reuse_logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
356,66327,filter_policy,3,leveldb.Options.filter_policy,,include\leveldb\options.hpp,* filter_policy,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
357,66333,verify_checksums,3,leveldb.ReadOptions.verify_checksums,,include\leveldb\options.hpp,verify_checksums,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
358,66334,fill_cache,3,leveldb.ReadOptions.fill_cache,,include\leveldb\options.hpp,fill_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
359,66335,snapshot,3,leveldb.ReadOptions.snapshot,,include\leveldb\options.hpp,* snapshot,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
360,66341,sync,3,leveldb.WriteOptions.sync,,include\leveldb\options.hpp,sync,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
361,66477,data_,3,leveldb.Slice.data_,,include\leveldb\slice.hpp,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
362,66478,size_,3,leveldb.Slice.size_,,include\leveldb\slice.hpp,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
363,66724,state_,3,leveldb.Status.state_,,include\leveldb\status.hpp,* state_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
364,66726,kOk,3,leveldb.Status.Code.kOk,,include\leveldb\status.hpp,kOk = 0,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
365,66727,kNotFound,3,leveldb.Status.Code.kNotFound,,include\leveldb\status.hpp,kNotFound = 1,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
366,66728,kCorruption,3,leveldb.Status.Code.kCorruption,,include\leveldb\status.hpp,kCorruption = 2,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
367,66729,kNotSupported,3,leveldb.Status.Code.kNotSupported,,include\leveldb\status.hpp,kNotSupported = 3,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
368,66730,kInvalidArgument,3,leveldb.Status.Code.kInvalidArgument,,include\leveldb\status.hpp,kInvalidArgument = 4,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
369,66731,kIOError,3,leveldb.Status.Code.kIOError,,include\leveldb\status.hpp,kIOError = 5,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
370,66867,rep_,3,leveldb.Table.rep_,,include\leveldb\table.hpp,* rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
371,67064,rep_,3,leveldb.WriteBatch.rep_,,include\leveldb\write_batch.hpp,rep_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,19,0,1,1,0,0,,0,0,0,0,0,
372,68222,cv_,3,leveldb.port.CondVar.cv_,,port\port_posix.hpp,cv_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
373,68524,comparator_,3,leveldb.Iter.comparator_,,table\block.cc,* const comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
374,68525,data_,3,leveldb.Iter.data_,,table\block.cc,* const data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
375,68526,restarts_,3,leveldb.Iter.restarts_,,table\block.cc,restarts_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
376,68527,num_restarts_,3,leveldb.Iter.num_restarts_,,table\block.cc,num_restarts_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
377,68528,current_,3,leveldb.Iter.current_,,table\block.cc,current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
378,68529,restart_index_,3,leveldb.Iter.restart_index_,,table\block.cc,restart_index_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
379,68530,key_,3,leveldb.Iter.key_,,table\block.cc,key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
380,68531,value_,3,leveldb.Iter.value_,,table\block.cc,value_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
381,68532,status_,3,leveldb.Iter.status_,,table\block.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
382,69020,data_,3,leveldb.Block.data_,,table\block.hpp,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
383,69021,size_,3,leveldb.Block.size_,,table\block.hpp,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
384,69023,owned_,3,leveldb.Block.owned_,,table\block.hpp,owned_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
385,69358,options_,3,leveldb.BlockBuilder.options_,,table\block_builder.hpp,*        options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
386,69359,buffer_,3,leveldb.BlockBuilder.buffer_,,table\block_builder.hpp,buffer_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,12,0,1,1,0,0,,0,0,0,0,0,
387,69360,restarts_,3,leveldb.BlockBuilder.restarts_,,table\block_builder.hpp,restarts_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
388,69361,counter_,3,leveldb.BlockBuilder.counter_,,table\block_builder.hpp,counter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
389,69362,finished_,3,leveldb.BlockBuilder.finished_,,table\block_builder.hpp,finished_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
390,69363,last_key_,3,leveldb.BlockBuilder.last_key_,,table\block_builder.hpp,last_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
391,69809,policy_,3,leveldb.FilterBlockBuilder.policy_,,table\filter_block.hpp,* policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
392,69810,keys_,3,leveldb.FilterBlockBuilder.keys_,,table\filter_block.hpp,keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
393,69811,start_,3,leveldb.FilterBlockBuilder.start_,,table\filter_block.hpp,start_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
394,69812,result_,3,leveldb.FilterBlockBuilder.result_,,table\filter_block.hpp,result_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
395,69813,tmp_keys_,3,leveldb.FilterBlockBuilder.tmp_keys_,,table\filter_block.hpp,tmp_keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
396,69814,filter_offsets_,3,leveldb.FilterBlockBuilder.filter_offsets_,,table\filter_block.hpp,filter_offsets_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
397,69838,policy_,3,leveldb.FilterBlockReader.policy_,,table\filter_block.hpp,* policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
398,69839,data_,3,leveldb.FilterBlockReader.data_,,table\filter_block.hpp,* data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
399,69840,offset_,3,leveldb.FilterBlockReader.offset_,,table\filter_block.hpp,* offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
400,69841,num_,3,leveldb.FilterBlockReader.num_,,table\filter_block.hpp,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
401,69842,base_lg_,3,leveldb.FilterBlockReader.base_lg_,,table\filter_block.hpp,base_lg_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
402,71306,kMaxEncodedLength,3,leveldb.BlockHandle.anonymous_enum_0.kMaxEncodedLength,,table\format.hpp,kMaxEncodedLength = 10 + 10,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
403,71316,offset_,3,leveldb.BlockHandle.offset_,,table\format.hpp,offset_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
404,71317,size_,3,leveldb.BlockHandle.size_,,table\format.hpp,size_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
405,71362,kEncodedLength,3,leveldb.Footer.anonymous_enum_1.kEncodedLength,,table\format.hpp,kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
406,71376,metaindex_handle_,3,leveldb.Footer.metaindex_handle_,,table\format.hpp,metaindex_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
407,71377,index_handle_,3,leveldb.Footer.index_handle_,,table\format.hpp,index_handle_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
408,71387,data,3,leveldb.BlockContents.data,,table\format.hpp,data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
409,71388,cachable,3,leveldb.BlockContents.cachable,,table\format.hpp,cachable,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
410,71389,heap_allocated,3,leveldb.BlockContents.heap_allocated,,table\format.hpp,heap_allocated,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
411,71596,status_,3,leveldb.anonymous_namespace_1.EmptyIterator.status_,,table\iterator.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
412,71784,iter_,3,leveldb.IteratorWrapper.iter_,,table\iterator_wrapper.hpp,* iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,20,0,1,1,0,0,,0,0,0,0,0,
413,71785,valid_,3,leveldb.IteratorWrapper.valid_,,table\iterator_wrapper.hpp,valid_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
414,71786,key_,3,leveldb.IteratorWrapper.key_,,table\iterator_wrapper.hpp,key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
415,72124,comparator_,3,leveldb.anonymous_namespace_1.MergingIterator.comparator_,,table\merger.cc,* comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
416,72125,children_,3,leveldb.anonymous_namespace_1.MergingIterator.children_,,table\merger.cc,* children_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
417,72126,n_,3,leveldb.anonymous_namespace_1.MergingIterator.n_,,table\merger.cc,n_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
418,72127,current_,3,leveldb.anonymous_namespace_1.MergingIterator.current_,,table\merger.cc,* current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
419,72129,kForward,3,leveldb.anonymous_namespace_22.MergingIterator.Direction.kForward,,table\merger.cc,kForward,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
420,72130,kReverse,3,leveldb.anonymous_namespace_22.MergingIterator.Direction.kReverse,,table\merger.cc,kReverse,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
421,72131,direction_,3,leveldb.anonymous_namespace_1.MergingIterator.direction_,,table\merger.cc,direction_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
422,72359,filter,3,leveldb.Rep.filter,,table\table.cc,* filter,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
423,72360,filter_data,3,leveldb.Rep.filter_data,,table\table.cc,* filter_data,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
424,72362,index_block,3,leveldb.Rep.index_block,,table\table.cc,* index_block,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
425,73290,index_block_options,3,leveldb.Rep.index_block_options,,table\table_builder.cc,index_block_options,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
426,74358,contents_,3,leveldb.StringSink.contents_,,table\table_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
427,74436,contents_,3,leveldb.StringSource.contents_,,table\table_test.cc,contents_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
428,74562,data_,3,leveldb.Constructor.data_,,table\table_test.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
429,74663,comparator_,3,leveldb.BlockConstructor.comparator_,,table\table_test.cc,* comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
430,74664,data_,3,leveldb.BlockConstructor.data_,,table\table_test.cc,data_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
431,74665,block_,3,leveldb.BlockConstructor.block_,,table\table_test.cc,* block_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
432,74886,source_,3,leveldb.TableConstructor.source_,,table\table_test.cc,* source_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
433,74887,table_,3,leveldb.TableConstructor.table_,,table\table_test.cc,* table_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
434,75020,status_,3,leveldb.KeyConvertingIterator.status_,,table\table_test.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
435,75021,iter_,3,leveldb.KeyConvertingIterator.iter_,,table\table_test.cc,* iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
436,75126,internal_comparator_,3,leveldb.MemTableConstructor.internal_comparator_,,table\table_test.cc,internal_comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
437,75127,memtable_,3,leveldb.MemTableConstructor.memtable_,,table\table_test.cc,* memtable_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
438,75334,comparator_,3,leveldb.DBConstructor.comparator_,,table\table_test.cc,* comparator_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
439,75335,db_,3,leveldb.DBConstructor.db_,,table\table_test.cc,* db_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
440,75342,type,3,leveldb.TestArgs.type,,table\table_test.cc,type,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
441,75343,reverse_compare,3,leveldb.TestArgs.reverse_compare,,table\table_test.cc,reverse_compare,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
442,75344,restart_interval,3,leveldb.TestArgs.restart_interval,,table\table_test.cc,restart_interval,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
443,76315,options_,3,leveldb.Harness.options_,,table\table_test.cc,options_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
444,76316,constructor_,3,leveldb.Harness.constructor_,,table\table_test.cc,* constructor_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,13,0,1,1,0,0,,0,0,0,0,0,
445,78174,status_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.status_,,table\two_level_iterator.cc,status_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
446,78175,index_iter_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.index_iter_,,table\two_level_iterator.cc,index_iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
447,78176,data_iter_,3,leveldb.anonymous_namespace_2.TwoLevelIterator.data_iter_,,table\two_level_iterator.cc,data_iter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
448,78742,alloc_ptr_,3,leveldb.Arena.alloc_ptr_,,util\arena.hpp,* alloc_ptr_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
449,78743,alloc_bytes_remaining_,3,leveldb.Arena.alloc_bytes_remaining_,,util\arena.hpp,alloc_bytes_remaining_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
450,78744,blocks_,3,leveldb.Arena.blocks_,,util\arena.hpp,blocks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
451,78745,memory_usage_,3,leveldb.Arena.memory_usage_,,util\arena.hpp,memory_usage_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
452,79169,bits_per_key_,3,leveldb.anonymous_namespace_2.BloomFilterPolicy.bits_per_key_,,util\bloom.cc,bits_per_key_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
453,79170,k_,3,leveldb.anonymous_namespace_2.BloomFilterPolicy.k_,,util\bloom.cc,k_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
454,79479,policy_,3,leveldb.BloomTest.policy_,,util\bloom_test.cc,* policy_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
455,79480,filter_,3,leveldb.BloomTest.filter_,,util\bloom_test.cc,filter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
456,79481,keys_,3,leveldb.BloomTest.keys_,,util\bloom_test.cc,keys_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
457,80175,value,3,leveldb.anonymous_namespace_1.LRUHandle.value,,util\cache.cc,* value,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
458,80182,next_hash,3,leveldb.anonymous_namespace_1.LRUHandle.next_hash,,util\cache.cc,* next_hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
459,80183,next,3,leveldb.anonymous_namespace_1.LRUHandle.next,,util\cache.cc,* next,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
460,80184,prev,3,leveldb.anonymous_namespace_1.LRUHandle.prev,,util\cache.cc,* prev,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
461,80185,charge,3,leveldb.anonymous_namespace_1.LRUHandle.charge,,util\cache.cc,charge,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
462,80186,key_length,3,leveldb.anonymous_namespace_1.LRUHandle.key_length,,util\cache.cc,key_length,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
463,80187,in_cache,3,leveldb.anonymous_namespace_1.LRUHandle.in_cache,,util\cache.cc,in_cache,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
464,80188,refs,3,leveldb.anonymous_namespace_1.LRUHandle.refs,,util\cache.cc,refs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
465,80189,hash,3,leveldb.anonymous_namespace_1.LRUHandle.hash,,util\cache.cc,hash,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
466,80190,key_data,3,leveldb.anonymous_namespace_1.LRUHandle.key_data,,util\cache.cc,key_data[1],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
467,80324,length_,3,leveldb.anonymous_namespace_4.HandleTable.length_,,util\cache.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
468,80325,elems_,3,leveldb.anonymous_namespace_4.HandleTable.elems_,,util\cache.cc,elems_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
469,80326,list_,3,leveldb.anonymous_namespace_4.HandleTable.list_,,util\cache.cc,** list_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
470,80564,capacity_,3,leveldb.anonymous_namespace_17.LRUCache.capacity_,,util\cache.cc,capacity_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
471,80565,mutex_,3,leveldb.anonymous_namespace_17.LRUCache.mutex_,,util\cache.cc,mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
472,80566,usage_,3,leveldb.anonymous_namespace_17.LRUCache.usage_,,util\cache.cc,usage_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
473,81095,shard_,3,leveldb.anonymous_namespace_54.ShardedLRUCache.shard_,,util\cache.cc,shard_[kNumShards],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
474,81096,id_mutex_,3,leveldb.anonymous_namespace_54.ShardedLRUCache.id_mutex_,,util\cache.cc,id_mutex_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
475,81097,last_id_,3,leveldb.anonymous_namespace_54.ShardedLRUCache.last_id_,,util\cache.cc,last_id_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
476,81401,current_,3,leveldb.CacheTest.current_,,util\cache_test.cc,* current_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
477,81427,cache_,3,leveldb.CacheTest.cache_,,util\cache_test.cc,* cache_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
478,88540,mu_,3,leveldb.anonymous_namespace_2.Limiter.mu_,,util\env_posix.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
479,88541,allowed_,3,leveldb.anonymous_namespace_2.Limiter.allowed_,,util\env_posix.cc,allowed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
480,88576,filename_,3,leveldb.anonymous_namespace_16.PosixSequentialFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
481,88577,file_,3,leveldb.anonymous_namespace_16.PosixSequentialFile.file_,,util\env_posix.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
482,88651,filename_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
483,88652,temporary_fd_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.temporary_fd_,,util\env_posix.cc,temporary_fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
484,88653,fd_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.fd_,,util\env_posix.cc,fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
485,88654,limiter_,3,leveldb.anonymous_namespace_21.PosixRandomAccessFile.limiter_,,util\env_posix.cc,* limiter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
486,88764,filename_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
487,88765,mmapped_region_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.mmapped_region_,,util\env_posix.cc,* mmapped_region_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
488,88766,length_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.length_,,util\env_posix.cc,length_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
489,88767,limiter_,3,leveldb.anonymous_namespace_25.PosixMmapReadableFile.limiter_,,util\env_posix.cc,* limiter_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
490,88827,filename_,3,leveldb.anonymous_namespace_29.PosixWritableFile.filename_,,util\env_posix.cc,filename_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
491,88828,file_,3,leveldb.anonymous_namespace_29.PosixWritableFile.file_,,util\env_posix.cc,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
492,89099,fd_,3,leveldb.anonymous_namespace_39.PosixFileLock.fd_,,util\env_posix.cc,fd_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
493,89100,name_,3,leveldb.anonymous_namespace_39.PosixFileLock.name_,,util\env_posix.cc,name_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
494,89102,mu_,3,leveldb.anonymous_namespace_40.PosixLockTable.mu_,,util\env_posix.cc,mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
495,89103,locked_files_,3,leveldb.anonymous_namespace_40.PosixLockTable.locked_files_,,util\env_posix.cc,locked_files_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
496,89934,locks_,3,leveldb.anonymous_namespace_43.PosixEnv.locks_,,util\env_posix.cc,locks_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
497,90149,arg,3,leveldb.anonymous_namespace_83.anonymous_namespace_84.StartThreadState.arg,,util\env_posix.cc,* arg,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
498,90835,mu,3,leveldb.State.mu,,util\env_test.cc,mu,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
499,90836,val,3,leveldb.State.val,,util\env_test.cc,val,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
500,90837,num_running,3,leveldb.State.num_running,,util\env_test.cc,num_running,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
501,92083,min_,3,leveldb.Histogram.min_,,util\histogram.hpp,min_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
502,92084,max_,3,leveldb.Histogram.max_,,util\histogram.hpp,max_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
503,92085,num_,3,leveldb.Histogram.num_,,util\histogram.hpp,num_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,15,0,1,1,0,0,,0,0,0,0,0,
504,92086,sum_,3,leveldb.Histogram.sum_,,util\histogram.hpp,sum_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,7,0,1,1,0,0,,0,0,0,0,0,
505,92087,sum_squares_,3,leveldb.Histogram.sum_squares_,,util\histogram.hpp,sum_squares_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
506,92089,kNumBuckets,3,leveldb.Histogram.anonymous_enum_0.kNumBuckets,,util\histogram.hpp,kNumBuckets = 154,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
507,92098,buckets_,3,leveldb.Histogram.buckets_,,util\histogram.hpp,buckets_[kNumBuckets],-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,11,0,1,1,0,0,,0,0,0,0,0,
508,92419,mu_,3,leveldb.MutexLock.mu_,,util\mutexlock.hpp,*const mu_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
509,92463,file_,3,leveldb.PosixLogger.file_,,util\posix_logger.hpp,* file_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
510,92678,seed_,3,leveldb.Random.seed_,,util\random.hpp,seed_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,8,0,1,1,0,0,,0,0,0,0,0,
511,93005,base,3,leveldb.test.anonymous_namespace_1.Test.base,,util\testharness.cc,* base,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
512,93006,name,3,leveldb.test.anonymous_namespace_1.Test.name,,util\testharness.cc,* name,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
513,93254,ok_,3,leveldb.test.Tester.ok_,,util\testharness.hpp,ok_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
514,93255,fname_,3,leveldb.test.Tester.fname_,,util\testharness.hpp,* fname_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
515,93256,line_,3,leveldb.test.Tester.line_,,util\testharness.hpp,line_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
516,93257,ss_,3,leveldb.test.Tester.ss_,,util\testharness.hpp,ss_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,10,0,1,1,0,0,,0,0,0,0,0,
517,93708,writable_file_error_,3,leveldb.test.ErrorEnv.writable_file_error_,,util\testutil.hpp,writable_file_error_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
518,93709,num_writable_file_errors_,3,leveldb.test.ErrorEnv.num_writable_file_errors_,,util\testutil.hpp,num_writable_file_errors_,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
519,23,AutoCompactTest,1,leveldb.AutoCompactTest.AutoCompactTest,ANY leveldb.AutoCompactTest.AutoCompactTest (),db\autocompact_test.cc,"AutoCompactTest() {
    dbname_ = test::TmpDir() + ""/autocompact_test"";
    tiny_cache_ = NewLRUCache(100);
    options_.block_cache = tiny_cache_;
    DestroyDB(dbname_, options_);
    options_.create_if_missing = true;
    options_.compression = kNoCompression;
    ASSERT_OK(DB::Open(options_, dbname_, &db_));
  }",20.0,28.0,3.0,4.0,9.0,15,4,16,7,0,11,1,1,0,0,,0,11,0,0,0,ANY
520,78,~AutoCompactTest,1,leveldb.AutoCompactTest.~AutoCompactTest,ANY leveldb.AutoCompactTest.~AutoCompactTest (),db\autocompact_test.cc,"~AutoCompactTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
  }",30.0,34.0,3.0,3.0,5.0,2,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
521,107,Size,1,leveldb.AutoCompactTest.Size,"uint64_t leveldb.AutoCompactTest.Size (Slice,Slice)",db\autocompact_test.cc,"uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",42.0,47.0,3.0,3.0,6.0,3,2,6,5,0,1,1,1,0,0,,0,1,4,2,2,uint64_t
522,519,main,1,main,"int main (int,char**)",util\hash_test.cc,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",52.0,54.0,1.0,1.0,3.0,2,1,2,2,0,1,1,1,0,0,,0,0,4,2,2,int
523,554,BuildTable,1,leveldb.BuildTable,"Status leveldb.BuildTable (ANY,Env*,Options,TableCache*,Iterator*,FileMetaData*)",db\builder.cc,"Status BuildTable(const std::string& dbname,
                  Env* env,
                  const Options& options,
                  TableCache* table_cache,
                  Iterator* iter,
                  FileMetaData* meta) {
  Status s;
  meta->file_size = 0;
  iter->SeekToFirst();

  std::string fname = TableFileName(dbname, meta->number);
  if (iter->Valid()) {
    WritableFile* file;
    s = env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      return s;
    }

    TableBuilder* builder = new TableBuilder(options, file);
    meta->smallest.DecodeFrom(iter->key());
    for (; iter->Valid(); iter->Next()) {
      Slice key = iter->key();
      meta->largest.DecodeFrom(key);
      builder->Add(key, iter->value());
    }

    // Finish and check for builder errors
    if (s.ok()) {
      s = builder->Finish();
      if (s.ok()) {
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }
    } else {
      builder->Abandon();
    }
    d...",17.0,86.0,1.0,1.0,70.0,58,9,57,14,0,9,11,19,1,0,,0,9,12,6,6,Status
524,892,~leveldb_comparator_t,1,leveldb_comparator_t.~leveldb_comparator_t,ANY leveldb_comparator_t.~leveldb_comparator_t (),db\c.cc,"virtual ~leveldb_comparator_t() {
    (*destructor_)(state_);
  }",69.0,71.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,ANY
525,900,Compare,1,leveldb_comparator_t.Compare,"int leveldb_comparator_t.Compare (Slice,Slice)",db\c.cc,"virtual int Compare(const Slice& a, const Slice& b) const {
    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
  }",73.0,75.0,3.0,3.0,3.0,5,2,6,4,0,1,1,1,0,0,,0,1,4,2,2,int
526,927,Name,1,leveldb_comparator_t.Name,const char* leveldb_comparator_t.Name (),db\c.cc,"virtual const char* Name() const {
    return (*name_)(state_);
  }",77.0,79.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,const char*
527,977,~leveldb_filterpolicy_t,1,leveldb_filterpolicy_t.~leveldb_filterpolicy_t,ANY leveldb_filterpolicy_t.~leveldb_filterpolicy_t (),db\c.cc,"virtual ~leveldb_filterpolicy_t() {
    (*destructor_)(state_);
  }",100.0,102.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,ANY
528,985,Name,1,leveldb_filterpolicy_t.Name,const char* leveldb_filterpolicy_t.Name (),db\c.cc,"virtual const char* Name() const {
    return (*name_)(state_);
  }",104.0,106.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,const char*
529,994,CreateFilter,1,leveldb_filterpolicy_t.CreateFilter,"void leveldb_filterpolicy_t.CreateFilter (Slice*,int,ANY*)",db\c.cc,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    std::vector<const char*> key_pointers(n);
    std::vector<size_t> key_sizes(n);
    for (int i = 0; i < n; i++) {
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }
    size_t len;
    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
    dst->append(filter, len);
    free(filter);
  }",108.0,119.0,3.0,3.0,12.0,21,8,26,12,0,1,2,2,0,0,,0,1,6,3,3,void
530,1071,KeyMayMatch,1,leveldb_filterpolicy_t.KeyMayMatch,"bool leveldb_filterpolicy_t.KeyMayMatch (Slice,Slice)",db\c.cc,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    return (*key_match_)(state_, key.data(), key.size(),
                         filter.data(), filter.size());
  }",121.0,124.0,3.0,3.0,4.0,5,2,6,4,0,1,1,1,0,0,,0,1,4,2,2,bool
531,1101,SaveError,1,SaveError,"bool SaveError (char**,Status)",db\c.cc,"static bool SaveError(char** errptr, const Status& s) {
  assert(errptr != NULL);
  if (s.ok()) {
    return false;
  } else if (*errptr == NULL) {
    *errptr = strdup(s.ToString().c_str());
  } else {
    // TODO(sanjay): Merge with existing error?
    free(*errptr);
    *errptr = strdup(s.ToString().c_str());
  }
  return true;
}",132.0,144.0,1.0,1.0,13.0,2,2,3,3,7,0,2,2,0,0,,0,0,4,2,2,bool
532,1156,CopyString,1,CopyString,char* CopyString (ANY),db\c.cc,"static char* CopyString(const std::string& str) {
  char* result = reinterpret_cast<char*>(malloc(sizeof(char) * str.size()));
  memcpy(result, str.data(), sizeof(char) * str.size());
  return result;
}",146.0,150.0,1.0,1.0,5.0,9,5,8,3,1,0,1,1,0,0,,0,0,2,1,1,char*
533,1189,leveldb_open,1,leveldb_open,"leveldb_t leveldb_open (leveldb_options_t*,char*,char**)",db\c.cc,"leveldb_t* leveldb_open(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  DB* db;
  if (SaveError(errptr, DB::Open(options->rep, std::string(name), &db))) {
    return NULL;
  }
  leveldb_t* result = new leveldb_t;
  result->rep = db;
  return result;
}",152.0,163.0,1.0,1.0,12.0,8,5,12,9,0,3,2,2,2,1,,0,3,6,3,3,leveldb_t
534,1229,leveldb_close,1,leveldb_close,void leveldb_close (leveldb_t*),db\c.cc,"void leveldb_close(leveldb_t* db) {
  delete db->rep;
  delete db;
}",165.0,168.0,1.0,1.0,4.0,3,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,void
535,1240,leveldb_put,1,leveldb_put,"void leveldb_put (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char*,size_t,char**)",db\c.cc,"void leveldb_put(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    const char* val, size_t vallen,
    char** errptr) {
  SaveError(errptr,
            db->rep->Put(options->rep, Slice(key, keylen), Slice(val, vallen)));
}",170.0,178.0,1.0,1.0,9.0,3,1,7,7,0,3,1,1,0,1,,0,2,14,7,7,void
536,1268,leveldb_delete,1,leveldb_delete,"void leveldb_delete (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char**)",db\c.cc,"void leveldb_delete(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    char** errptr) {
  SaveError(errptr, db->rep->Delete(options->rep, Slice(key, keylen)));
}",180.0,186.0,1.0,1.0,7.0,3,1,5,5,0,3,1,1,0,1,,0,2,10,5,5,void
537,1291,leveldb_write,1,leveldb_write,"void leveldb_write (leveldb_t*,leveldb_writeoptions_t*,leveldb_writebatch_t*,char**)",db\c.cc,"void leveldb_write(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    leveldb_writebatch_t* batch,
    char** errptr) {
  SaveError(errptr, db->rep->Write(options->rep, &batch->rep));
}",189.0,195.0,1.0,1.0,7.0,5,2,4,4,0,4,1,1,0,1,,0,3,8,4,4,void
538,1314,leveldb_get,1,leveldb_get,"char* leveldb_get (leveldb_t*,leveldb_readoptions_t*,char*,size_t,size_t*,char**)",db\c.cc,"char* leveldb_get(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key, size_t keylen,
    size_t* vallen,
    char** errptr) {
  char* result = NULL;
  std::string tmp;
  Status s = db->rep->Get(options->rep, Slice(key, keylen), &tmp);
  if (s.ok()) {
    *vallen = tmp.size();
    result = CopyString(tmp);
  } else {
    *vallen = 0;
    if (!s.IsNotFound()) {
      SaveError(errptr, s);
    }
  }
  return result;
}",197.0,216.0,1.0,1.0,20.0,11,5,14,9,1,3,2,2,0,1,,0,3,12,6,6,char*
539,1381,leveldb_create_iterator,1,leveldb_create_iterator,"leveldb_iterator_t leveldb_create_iterator (leveldb_t*,leveldb_readoptions_t*)",db\c.cc,"leveldb_iterator_t* leveldb_create_iterator(
    leveldb_t* db,
    const leveldb_readoptions_t* options) {
  leveldb_iterator_t* result = new leveldb_iterator_t;
  result->rep = db->rep->NewIterator(options->rep);
  return result;
}",218.0,224.0,1.0,1.0,7.0,7,3,6,4,0,3,1,1,0,0,,0,3,4,2,2,leveldb_iterator_t
540,1407,leveldb_create_snapshot,1,leveldb_create_snapshot,leveldb_snapshot_t leveldb_create_snapshot (leveldb_t*),db\c.cc,"const leveldb_snapshot_t* leveldb_create_snapshot(
    leveldb_t* db) {
  leveldb_snapshot_t* result = new leveldb_snapshot_t;
  result->rep = db->rep->GetSnapshot();
  return result;
}",226.0,231.0,1.0,1.0,6.0,6,3,5,3,0,2,1,1,0,0,,0,2,2,1,1,leveldb_snapshot_t
541,1429,leveldb_release_snapshot,1,leveldb_release_snapshot,"void leveldb_release_snapshot (leveldb_t*,leveldb_snapshot_t*)",db\c.cc,"void leveldb_release_snapshot(
    leveldb_t* db,
    const leveldb_snapshot_t* snapshot) {
  db->rep->ReleaseSnapshot(snapshot->rep);
  delete snapshot;
}",233.0,238.0,1.0,1.0,6.0,4,2,3,2,0,2,1,1,0,0,,0,2,4,2,2,void
542,1446,leveldb_property_value,1,leveldb_property_value,"char* leveldb_property_value (leveldb_t*,char*)",db\c.cc,"char* leveldb_property_value(
    leveldb_t* db,
    const char* propname) {
  std::string tmp;
  if (db->rep->GetProperty(Slice(propname), &tmp)) {
    // We use strdup() since we expect human readable output.
    return strdup(tmp.c_str());
  } else {
    return NULL;
  }
}",240.0,250.0,1.0,1.0,11.0,4,3,4,3,0,1,2,2,1,0,,0,1,4,2,2,char*
543,1475,leveldb_approximate_sizes,1,leveldb_approximate_sizes,"void leveldb_approximate_sizes (leveldb_t*,int,char**,size_t*,char**,size_t*,uint64_t*)",db\c.cc,"void leveldb_approximate_sizes(
    leveldb_t* db,
    int num_ranges,
    const char* const* range_start_key, const size_t* range_start_key_len,
    const char* const* range_limit_key, const size_t* range_limit_key_len,
    uint64_t* sizes) {
  Range* ranges = new Range[num_ranges];
  for (int i = 0; i < num_ranges; i++) {
    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);
    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);
  }
  db->rep->GetApproximateSizes(ranges, num_ranges, sizes);
  delete[] ranges;
}",252.0,265.0,1.0,1.0,14.0,17,7,22,10,0,1,2,2,0,0,,0,1,14,7,7,void
544,1540,leveldb_compact_range,1,leveldb_compact_range,"void leveldb_compact_range (leveldb_t*,char*,size_t,char*,size_t)",db\c.cc,"void leveldb_compact_range(
    leveldb_t* db,
    const char* start_key, size_t start_key_len,
    const char* limit_key, size_t limit_key_len) {
  Slice a, b;
  db->rep->CompactRange(
      // Pass NULL Slice if corresponding ""const char*"" is NULL
      (start_key ? (a = Slice(start_key, start_key_len), &a) : NULL),
      (limit_key ? (b = Slice(limit_key, limit_key_len), &b) : NULL));
}",267.0,276.0,1.0,1.0,10.0,12,6,13,8,0,1,1,1,0,0,,0,1,10,5,5,void
545,1581,leveldb_destroy_db,1,leveldb_destroy_db,"void leveldb_destroy_db (leveldb_options_t*,char*,char**)",db\c.cc,"void leveldb_destroy_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  SaveError(errptr, DestroyDB(name, options->rep));
}",278.0,283.0,1.0,1.0,6.0,1,1,3,3,0,2,1,1,0,1,,0,1,6,3,3,void
546,1595,leveldb_repair_db,1,leveldb_repair_db,"void leveldb_repair_db (leveldb_options_t*,char*,char**)",db\c.cc,"void leveldb_repair_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  SaveError(errptr, RepairDB(name, options->rep));
}",285.0,290.0,1.0,1.0,6.0,1,1,3,3,0,2,1,1,0,1,,0,1,6,3,3,void
547,1609,leveldb_iter_destroy,1,leveldb_iter_destroy,void leveldb_iter_destroy (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_destroy(leveldb_iterator_t* iter) {
  delete iter->rep;
  delete iter;
}",292.0,295.0,1.0,1.0,4.0,3,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,void
548,1620,leveldb_iter_valid,1,leveldb_iter_valid,unsigned char leveldb_iter_valid (leveldb_iterator_t*),db\c.cc,"unsigned char leveldb_iter_valid(const leveldb_iterator_t* iter) {
  return iter->rep->Valid();
}",297.0,299.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,unsigned char
549,1632,leveldb_iter_seek_to_first,1,leveldb_iter_seek_to_first,void leveldb_iter_seek_to_first (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_seek_to_first(leveldb_iterator_t* iter) {
  iter->rep->SeekToFirst();
}",301.0,303.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
550,1643,leveldb_iter_seek_to_last,1,leveldb_iter_seek_to_last,void leveldb_iter_seek_to_last (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_seek_to_last(leveldb_iterator_t* iter) {
  iter->rep->SeekToLast();
}",305.0,307.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
551,1654,leveldb_iter_seek,1,leveldb_iter_seek,"void leveldb_iter_seek (leveldb_iterator_t*,char*,size_t)",db\c.cc,"void leveldb_iter_seek(leveldb_iterator_t* iter, const char* k, size_t klen) {
  iter->rep->Seek(Slice(k, klen));
}",309.0,311.0,1.0,1.0,3.0,2,1,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
552,1670,leveldb_iter_next,1,leveldb_iter_next,void leveldb_iter_next (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_next(leveldb_iterator_t* iter) {
  iter->rep->Next();
}",313.0,315.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
553,1681,leveldb_iter_prev,1,leveldb_iter_prev,void leveldb_iter_prev (leveldb_iterator_t*),db\c.cc,"void leveldb_iter_prev(leveldb_iterator_t* iter) {
  iter->rep->Prev();
}",317.0,319.0,1.0,1.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
554,1692,leveldb_iter_key,1,leveldb_iter_key,"const char* leveldb_iter_key (leveldb_iterator_t*,size_t*)",db\c.cc,"const char* leveldb_iter_key(const leveldb_iterator_t* iter, size_t* klen) {
  Slice s = iter->rep->key();
  *klen = s.size();
  return s.data();
}",321.0,325.0,1.0,1.0,5.0,7,4,5,3,1,1,1,1,0,0,,0,1,4,2,2,const char*
555,1719,leveldb_iter_value,1,leveldb_iter_value,"const char* leveldb_iter_value (leveldb_iterator_t*,size_t*)",db\c.cc,"const char* leveldb_iter_value(const leveldb_iterator_t* iter, size_t* vlen) {
  Slice s = iter->rep->value();
  *vlen = s.size();
  return s.data();
}",327.0,331.0,1.0,1.0,5.0,7,4,5,3,1,1,1,1,0,0,,0,1,4,2,2,const char*
556,1746,leveldb_iter_get_error,1,leveldb_iter_get_error,"void leveldb_iter_get_error (leveldb_iterator_t*,char**)",db\c.cc,"void leveldb_iter_get_error(const leveldb_iterator_t* iter, char** errptr) {
  SaveError(errptr, iter->rep->status());
}",333.0,335.0,1.0,1.0,3.0,2,1,2,2,0,2,1,1,0,1,,0,1,4,2,2,void
557,1774,leveldb_writebatch_clear,1,leveldb_writebatch_clear,void leveldb_writebatch_clear (leveldb_writebatch_t*),db\c.cc,"void leveldb_writebatch_clear(leveldb_writebatch_t* b) {
  b->rep.Clear();
}",345.0,347.0,1.0,1.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,void
558,1785,leveldb_writebatch_put,1,leveldb_writebatch_put,"void leveldb_writebatch_put (leveldb_writebatch_t*,char*,size_t,char*,size_t)",db\c.cc,"void leveldb_writebatch_put(
    leveldb_writebatch_t* b,
    const char* key, size_t klen,
    const char* val, size_t vlen) {
  b->rep.Put(Slice(key, klen), Slice(val, vlen));
}",349.0,354.0,1.0,1.0,6.0,2,2,5,5,0,1,1,1,0,0,,0,1,10,5,5,void
559,1806,leveldb_writebatch_delete,1,leveldb_writebatch_delete,"void leveldb_writebatch_delete (leveldb_writebatch_t*,char*,size_t)",db\c.cc,"void leveldb_writebatch_delete(
    leveldb_writebatch_t* b,
    const char* key, size_t klen) {
  b->rep.Delete(Slice(key, klen));
}",356.0,360.0,1.0,1.0,5.0,2,2,3,3,0,1,1,1,0,0,,0,1,6,3,3,void
560,1822,leveldb_writebatch_iterate,1,leveldb_writebatch_iterate,"void leveldb_writebatch_iterate (leveldb_writebatch_t*,void*,void,void)",db\c.cc,"void leveldb_writebatch_iterate(
    leveldb_writebatch_t* b,
    void* state,
    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),
    void (*deleted)(void*, const char* k, size_t klen)) {
  class H : public WriteBatch::Handler {
   public:
    void* state_;
    void (*put_)(void*, const char* k, size_t klen, const char* v, size_t vlen);
    void (*deleted_)(void*, const char* k, size_t klen);
    virtual void Put(const Slice& key, const Slice& value) {
      (*put_)(state_, key.data(), key.size(), value.data(), value.size());
    }
    virtual void Delete(const Slice& key) {
      (*deleted_)(state_, key.data(), key.size());
    }
  };
  H handler;
  handler.state_ = state;
  handler.put_ = put;
  handler.deleted_ = deleted;
  b->rep.Iterate(&handler);
}",362.0,384.0,1.0,1.0,23.0,9,4,8,5,0,1,1,1,0,0,,0,1,8,4,4,void
561,1868,leveldb_options_set_comparator,1,leveldb_options_set_comparator,"void leveldb_options_set_comparator (leveldb_options_t*,leveldb_comparator_t*)",db\c.cc,"void leveldb_options_set_comparator(
    leveldb_options_t* opt,
    leveldb_comparator_t* cmp) {
  opt->rep.comparator = cmp;
}",394.0,398.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
562,1881,leveldb_options_set_filter_policy,1,leveldb_options_set_filter_policy,"void leveldb_options_set_filter_policy (leveldb_options_t*,leveldb_filterpolicy_t*)",db\c.cc,"void leveldb_options_set_filter_policy(
    leveldb_options_t* opt,
    leveldb_filterpolicy_t* policy) {
  opt->rep.filter_policy = policy;
}",400.0,404.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
563,1894,leveldb_options_set_create_if_missing,1,leveldb_options_set_create_if_missing,"void leveldb_options_set_create_if_missing (leveldb_options_t*,unsigned char)",db\c.cc,"void leveldb_options_set_create_if_missing(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.create_if_missing = v;
}",406.0,409.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
564,1907,leveldb_options_set_error_if_exists,1,leveldb_options_set_error_if_exists,"void leveldb_options_set_error_if_exists (leveldb_options_t*,unsigned char)",db\c.cc,"void leveldb_options_set_error_if_exists(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.error_if_exists = v;
}",411.0,414.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
565,1920,leveldb_options_set_paranoid_checks,1,leveldb_options_set_paranoid_checks,"void leveldb_options_set_paranoid_checks (leveldb_options_t*,unsigned char)",db\c.cc,"void leveldb_options_set_paranoid_checks(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.paranoid_checks = v;
}",416.0,419.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
566,1933,leveldb_options_set_env,1,leveldb_options_set_env,"void leveldb_options_set_env (leveldb_options_t*,leveldb_env_t*)",db\c.cc,"void leveldb_options_set_env(leveldb_options_t* opt, leveldb_env_t* env) {
  opt->rep.env = (env ? env->rep : NULL);
}",421.0,423.0,1.0,1.0,3.0,5,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
567,1951,leveldb_options_set_info_log,1,leveldb_options_set_info_log,"void leveldb_options_set_info_log (leveldb_options_t*,leveldb_logger_t*)",db\c.cc,"void leveldb_options_set_info_log(leveldb_options_t* opt, leveldb_logger_t* l) {
  opt->rep.info_log = (l ? l->rep : NULL);
}",425.0,427.0,1.0,1.0,3.0,5,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
568,1969,leveldb_options_set_write_buffer_size,1,leveldb_options_set_write_buffer_size,"void leveldb_options_set_write_buffer_size (leveldb_options_t*,size_t)",db\c.cc,"void leveldb_options_set_write_buffer_size(leveldb_options_t* opt, size_t s) {
  opt->rep.write_buffer_size = s;
}",429.0,431.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
569,1982,leveldb_options_set_max_open_files,1,leveldb_options_set_max_open_files,"void leveldb_options_set_max_open_files (leveldb_options_t*,int)",db\c.cc,"void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {
  opt->rep.max_open_files = n;
}",433.0,435.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
570,1995,leveldb_options_set_cache,1,leveldb_options_set_cache,"void leveldb_options_set_cache (leveldb_options_t*,leveldb_cache_t*)",db\c.cc,"void leveldb_options_set_cache(leveldb_options_t* opt, leveldb_cache_t* c) {
  opt->rep.block_cache = c->rep;
}",437.0,439.0,1.0,1.0,3.0,4,3,2,2,0,2,1,1,0,0,,0,2,4,2,2,void
571,2010,leveldb_options_set_block_size,1,leveldb_options_set_block_size,"void leveldb_options_set_block_size (leveldb_options_t*,size_t)",db\c.cc,"void leveldb_options_set_block_size(leveldb_options_t* opt, size_t s) {
  opt->rep.block_size = s;
}",441.0,443.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
572,2023,leveldb_options_set_block_restart_interval,1,leveldb_options_set_block_restart_interval,"void leveldb_options_set_block_restart_interval (leveldb_options_t*,int)",db\c.cc,"void leveldb_options_set_block_restart_interval(leveldb_options_t* opt, int n) {
  opt->rep.block_restart_interval = n;
}",445.0,447.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
573,2036,leveldb_options_set_compression,1,leveldb_options_set_compression,"void leveldb_options_set_compression (leveldb_options_t*,int)",db\c.cc,"void leveldb_options_set_compression(leveldb_options_t* opt, int t) {
  opt->rep.compression = static_cast<CompressionType>(t);
}",449.0,451.0,1.0,1.0,3.0,4,4,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
574,2051,leveldb_comparator_create,1,leveldb_comparator_create,"leveldb_comparator_t leveldb_comparator_create (void*,void,int,char*)",db\c.cc,"leveldb_comparator_t* leveldb_comparator_create(
    void* state,
    void (*destructor)(void*),
    int (*compare)(
        void*,
        const char* a, size_t alen,
        const char* b, size_t blen),
    const char* (*name)(void*)) {
  leveldb_comparator_t* result = new leveldb_comparator_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->compare_ = compare;
  result->name_ = name;
  return result;
}",453.0,467.0,1.0,1.0,15.0,10,3,11,6,0,1,1,1,0,0,,0,1,8,4,4,leveldb_comparator_t
575,2093,leveldb_filterpolicy_create,1,leveldb_filterpolicy_create,"leveldb_filterpolicy_t leveldb_filterpolicy_create (void*,void,char*,unsigned char,char*)",db\c.cc,"leveldb_filterpolicy_t* leveldb_filterpolicy_create(
    void* state,
    void (*destructor)(void*),
    char* (*create_filter)(
        void*,
        const char* const* key_array, const size_t* key_length_array,
        int num_keys,
        size_t* filter_length),
    unsigned char (*key_may_match)(
        void*,
        const char* key, size_t length,
        const char* filter, size_t filter_length),
    const char* (*name)(void*)) {
  leveldb_filterpolicy_t* result = new leveldb_filterpolicy_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->create_ = create_filter;
  result->key_match_ = key_may_match;
  result->name_ = name;
  return result;
}",473.0,493.0,1.0,1.0,21.0,12,3,13,7,0,1,1,1,0,0,,0,1,10,5,5,leveldb_filterpolicy_t
576,2186,leveldb_readoptions_set_verify_checksums,1,leveldb_readoptions_set_verify_checksums,"void leveldb_readoptions_set_verify_checksums (leveldb_readoptions_t*,unsigned char)",db\c.cc,"void leveldb_readoptions_set_verify_checksums(
    leveldb_readoptions_t* opt,
    unsigned char v) {
  opt->rep.verify_checksums = v;
}",530.0,534.0,1.0,1.0,5.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
577,2199,leveldb_readoptions_set_fill_cache,1,leveldb_readoptions_set_fill_cache,"void leveldb_readoptions_set_fill_cache (leveldb_readoptions_t*,unsigned char)",db\c.cc,"void leveldb_readoptions_set_fill_cache(
    leveldb_readoptions_t* opt, unsigned char v) {
  opt->rep.fill_cache = v;
}",536.0,539.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
578,2212,leveldb_readoptions_set_snapshot,1,leveldb_readoptions_set_snapshot,"void leveldb_readoptions_set_snapshot (leveldb_readoptions_t*,leveldb_snapshot_t*)",db\c.cc,"void leveldb_readoptions_set_snapshot(
    leveldb_readoptions_t* opt,
    const leveldb_snapshot_t* snap) {
  opt->rep.snapshot = (snap ? snap->rep : NULL);
}",541.0,545.0,1.0,1.0,5.0,5,4,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
579,2244,leveldb_writeoptions_set_sync,1,leveldb_writeoptions_set_sync,"void leveldb_writeoptions_set_sync (leveldb_writeoptions_t*,unsigned char)",db\c.cc,"void leveldb_writeoptions_set_sync(
    leveldb_writeoptions_t* opt, unsigned char v) {
  opt->rep.sync = v;
}",555.0,558.0,1.0,1.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
580,2257,leveldb_cache_create_lru,1,leveldb_cache_create_lru,leveldb_cache_t leveldb_cache_create_lru (size_t),db\c.cc,"leveldb_cache_t* leveldb_cache_create_lru(size_t capacity) {
  leveldb_cache_t* c = new leveldb_cache_t;
  c->rep = NewLRUCache(capacity);
  return c;
}",560.0,564.0,1.0,1.0,5.0,4,3,5,3,0,1,1,1,0,0,,0,1,2,1,1,leveldb_cache_t
581,2275,leveldb_cache_destroy,1,leveldb_cache_destroy,void leveldb_cache_destroy (leveldb_cache_t*),db\c.cc,"void leveldb_cache_destroy(leveldb_cache_t* cache) {
  delete cache->rep;
  delete cache;
}",566.0,569.0,1.0,1.0,4.0,3,2,2,1,0,1,1,1,0,0,,0,1,2,1,1,void
582,2286,leveldb_create_default_env,1,leveldb_create_default_env,leveldb_env_t leveldb_create_default_env (),db\c.cc,"leveldb_env_t* leveldb_create_default_env() {
  leveldb_env_t* result = new leveldb_env_t;
  result->rep = Env::Default();
  result->is_default = true;
  return result;
}",571.0,576.0,1.0,1.0,6.0,7,4,6,3,0,2,1,1,0,0,,0,2,0,0,0,leveldb_env_t
583,2310,leveldb_env_destroy,1,leveldb_env_destroy,void leveldb_env_destroy (leveldb_env_t*),db\c.cc,"void leveldb_env_destroy(leveldb_env_t* env) {
  if (!env->is_default) delete env->rep;
  delete env;
}",578.0,581.0,1.0,1.0,4.0,5,3,3,1,0,2,2,2,1,0,,0,2,2,1,1,void
584,2372,StartPhase,1,StartPhase,void StartPhase (char*),db\c_test.c,"static void StartPhase(const char* name) {
  fprintf(stderr, ""=== Test %s\n"", name);
  phase = name;
}",17.0,20.0,1.0,1.0,4.0,1,1,4,3,0,1,1,1,0,0,,0,1,2,1,1,void
585,2410,CheckEqual,1,CheckEqual,"void CheckEqual (char*,char*,size_t)",db\c_test.c,"static void CheckEqual(const char* expected, const char* v, size_t n) {
  if (expected == NULL && v == NULL) {
    // ok
  } else if (expected != NULL && v != NULL && n == strlen(expected) &&
             memcmp(expected, v, n) == 0) {
    // ok
    return;
  } else {
    fprintf(stderr, ""%s: expected '%s', got '%s'\n"",
            phase,
            (expected ? expected : ""(null)""),
            (v ? v : ""(null""));
    abort();
  }
}",41.0,55.0,1.0,1.0,15.0,3,2,4,3,8,0,2,2,0,0,,0,0,6,3,3,void
586,2465,Free,1,Free,void Free (char**),db\c_test.c,"static void Free(char** ptr) {
  if (*ptr) {
    free(*ptr);
    *ptr = NULL;
  }
}",57.0,62.0,1.0,1.0,6.0,4,2,4,2,1,0,2,2,0,0,,0,0,2,1,1,void
587,2481,CheckGet,1,CheckGet,"void CheckGet (leveldb_t*,leveldb_readoptions_t*,char*,char*)",db\c_test.c,"static void CheckGet(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key,
    const char* expected) {
  char* err = NULL;
  size_t val_len;
  char* val;
  val = leveldb_get(db, options, key, strlen(key), &val_len, &err);
  CheckNoError(err);
  CheckEqual(expected, val, val_len);
  Free(&val);
}",64.0,76.0,1.0,2.0,13.0,6,3,19,10,0,4,1,1,0,3,,0,2,8,4,4,void
588,2530,CheckIter,1,CheckIter,"void CheckIter (leveldb_iterator_t*,char*,char*)",db\c_test.c,"static void CheckIter(leveldb_iterator_t* iter,
                      const char* key, const char* val) {
  size_t len;
  const char* str;
  str = leveldb_iter_key(iter, &len);
  CheckEqual(key, str, len);
  str = leveldb_iter_value(iter, &len);
  CheckEqual(val, str, len);
}",78.0,86.0,1.0,1.0,9.0,4,2,12,5,0,4,1,1,0,4,,0,2,6,3,3,void
589,2559,CheckPut,1,CheckPut,"void CheckPut (void*,char*,size_t,char*,size_t)",db\c_test.c,"static void CheckPut(void* ptr,
                     const char* k, size_t klen,
                     const char* v, size_t vlen) {
  int* state = (int*) ptr;
  CheckCondition(*state < 2);
  switch (*state) {
    case 0:
      CheckEqual(""bar"", k, klen);
      CheckEqual(""b"", v, vlen);
      break;
    case 1:
      CheckEqual(""box"", k, klen);
      CheckEqual(""c"", v, vlen);
      break;
  }
  (*state)++;
}",89.0,105.0,1.0,2.0,17.0,8,6,15,8,0,5,4,2,0,4,,0,1,10,5,5,void
590,2620,CheckDel,1,CheckDel,"void CheckDel (void*,char*,size_t)",db\c_test.c,"static void CheckDel(void* ptr, const char* k, size_t klen) {
  int* state = (int*) ptr;
  CheckCondition(*state == 2);
  CheckEqual(""bar"", k, klen);
  (*state)++;
}",108.0,113.0,1.0,2.0,6.0,7,6,8,6,0,2,1,1,0,1,,0,1,6,3,3,void
591,2761,FilterKeyMatch,1,FilterKeyMatch,"unsigned char FilterKeyMatch (void*,char*,size_t,char*,size_t)",db\c_test.c,"unsigned char FilterKeyMatch(
    void* arg,
    const char* key, size_t length,
    const char* filter, size_t filter_length) {
  CheckCondition(filter_length == 4);
  CheckCondition(memcmp(filter, ""fake"", 4) == 0);
  return fake_filter_result;
}",148.0,155.0,1.0,2.0,8.0,4,2,7,5,0,3,1,1,0,0,,0,3,10,5,5,unsigned char
592,3875,CorruptionTest,1,leveldb.CorruptionTest.CorruptionTest,ANY leveldb.CorruptionTest.CorruptionTest (),db\corruption_test.cc,"CorruptionTest() {
    tiny_cache_ = NewLRUCache(100);
    options_.env = &env_;
    options_.block_cache = tiny_cache_;
    dbname_ = test::TmpDir() + ""/corruption_test"";
    DestroyDB(dbname_, options_);

    db_ = NULL;
    options_.create_if_missing = true;
    Reopen();
    options_.create_if_missing = false;
  }",35.0,46.0,3.0,3.0,12.0,14,4,13,7,0,11,1,1,0,0,,0,11,0,0,0,ANY
593,3919,~CorruptionTest,1,leveldb.CorruptionTest.~CorruptionTest,ANY leveldb.CorruptionTest.~CorruptionTest (),db\corruption_test.cc,"~CorruptionTest() {
     delete db_;
     DestroyDB(dbname_, Options());
     delete tiny_cache_;
  }",48.0,52.0,3.0,3.0,5.0,2,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
594,3930,TryReopen,1,leveldb.CorruptionTest.TryReopen,Status leveldb.CorruptionTest.TryReopen (),db\corruption_test.cc,"Status TryReopen() {
    delete db_;
    db_ = NULL;
    return DB::Open(options_, dbname_, &db_);
  }",54.0,58.0,3.0,3.0,5.0,4,4,7,5,0,5,1,1,0,0,,0,5,0,0,0,Status
595,3967,RepairDB,1,leveldb.CorruptionTest.RepairDB,void leveldb.CorruptionTest.RepairDB (),db\corruption_test.cc,"void RepairDB() {
    delete db_;
    db_ = NULL;
    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));
  }",64.0,68.0,3.0,4.0,5.0,6,3,8,5,0,4,1,1,0,0,,0,4,0,0,0,void
596,3995,Build,1,leveldb.CorruptionTest.Build,void leveldb.CorruptionTest.Build (int),db\corruption_test.cc,"void Build(int n) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = 0; i < n; i++) {
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d of %d\n"", i, n);
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      // Corrupt() doesn't work without this sync on windows; stat reports 0 for
      // the file size.
      if (i == n - 1) {
        options.sync = true;
      }
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",70.0,86.0,3.0,6.0,17.0,16,7,19,9,0,2,3,4,0,0,,0,2,2,1,1,void
597,4068,Check,1,leveldb.CorruptionTest.Check,"void leveldb.CorruptionTest.Check (int,int)",db\corruption_test.cc,"void Check(int min_expected, int max_expected) {
    int next_expected = 0;
    int missed = 0;
    int bad_keys = 0;
    int bad_values = 0;
    int correct = 0;
    std::string value_space;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      uint64_t key;
      Slice in(iter->key());
      if (in == """" || in == ""~"") {
        // Ignore boundary keys.
        continue;
      }
      if (!ConsumeDecimalNumber(&in, &key) ||
          !in.empty() ||
          key < next_expected) {
        bad_keys++;
        continue;
      }
      missed += (key - next_expected);
      next_expected = key + 1;
      if (iter->value() != Value(key, &value_space)) {
        bad_values++;
      } else {
        correct++;
      }
    }
    delete iter;

    fprintf(stderr,
            ""expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\n"",
            min_expected, max_expected, correct, bad_keys, bad_values, missed);
    ...",88.0,124.0,3.0,4.0,37.0,37,14,47,15,0,1,7,8,0,0,,0,1,4,2,2,void
598,4228,Corrupt,1,leveldb.CorruptionTest.Corrupt,"void leveldb.CorruptionTest.Corrupt (FileType,int,int)",db\corruption_test.cc,"void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {
    // Pick file to corrupt
    std::vector<std::string> filenames;
    ASSERT_OK(env_.GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    std::string fname;
    int picked_number = -1;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type == filetype &&
          int(number) > picked_number) {  // Pick latest file
        fname = dbname_ + ""/"" + filenames[i];
        picked_number = number;
      }
    }
    ASSERT_TRUE(!fname.empty()) << filetype;

    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      const char* msg = strerror(errno);
      ASSERT_TRUE(false) << fname << "": "" << msg;
    }

    if (offset < 0) {
      // Relative to end of file; make it absolute
      if (-offset > sbuf.st_size) {
        offset = 0;
      } else {
        offset = sbuf.st_size + offset;
      }
    }
    if (offset >...",126.0,174.0,3.0,4.0,49.0,83,15,77,22,0,3,9,11,0,0,,0,3,6,3,3,void
599,4531,Property,1,leveldb.CorruptionTest.Property,int leveldb.CorruptionTest.Property (ANY),db\corruption_test.cc,"int Property(const std::string& name) {
    std::string property;
    int result;
    if (db_->GetProperty(name, &property) &&
        sscanf(property.c_str(), ""%d"", &result) == 1) {
      return result;
    } else {
      return -1;
    }
  }",176.0,185.0,3.0,3.0,10.0,6,5,6,4,0,1,2,2,1,0,,0,1,2,1,1,int
600,6029,RandomGenerator,1,leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator,ANY leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator (),doc\bench\db_bench_tree_db.cc,"RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",93.0,106.0,3.0,3.0,14.0,7,4,8,6,0,4,2,2,1,0,,0,4,0,0,0,ANY
601,6063,Generate,1,leveldb.anonymous_namespace_3.RandomGenerator.Generate,Slice leveldb.anonymous_namespace_3.RandomGenerator.Generate (size_t),doc\bench\db_bench_tree_db.cc,"Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",108.0,115.0,3.0,3.0,8.0,10,7,12,3,0,7,2,2,2,0,,0,7,2,1,1,Slice
602,6154,Start,1,leveldb.anonymous_namespace_8.Stats.Start,void leveldb.anonymous_namespace_8.Stats.Start (),db\db_bench.cc,"void Start() {
    next_report_ = 100;
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    bytes_ = 0;
    seconds_ = 0;
    start_ = g_env->NowMicros();
    finish_ = start_;
    message_.clear();
  }",191.0,201.0,3.0,3.0,11.0,10,3,12,10,0,11,1,1,0,0,,0,11,0,0,0,void
603,6190,Merge,1,leveldb.anonymous_namespace_9.Stats.Merge,void leveldb.anonymous_namespace_9.Stats.Merge (Stats),db\db_bench.cc,"void Merge(const Stats& other) {
    hist_.Merge(other.hist_);
    done_ += other.done_;
    bytes_ += other.bytes_;
    seconds_ += other.seconds_;
    if (other.start_ < start_) start_ = other.start_;
    if (other.finish_ > finish_) finish_ = other.finish_;

    // Just keep the messages from one thread
    if (message_.empty()) message_ = other.message_;
  }",203.0,213.0,3.0,3.0,11.0,19,5,19,8,0,19,4,4,5,0,,0,19,2,1,1,void
604,6252,Stop,1,leveldb.anonymous_namespace_10.Stats.Stop,void leveldb.anonymous_namespace_10.Stats.Stop (),db\db_bench.cc,"void Stop() {
    finish_ = g_env->NowMicros();
    seconds_ = (finish_ - start_) * 1e-6;
  }",215.0,218.0,3.0,3.0,4.0,5,4,5,4,0,4,1,1,0,0,,0,4,0,0,0,void
605,6269,AddMessage,1,leveldb.anonymous_namespace_11.Stats.AddMessage,void leveldb.anonymous_namespace_11.Stats.AddMessage (Slice),db\db_bench.cc,"void AddMessage(Slice msg) {
    AppendWithSpace(&message_, msg);
  }",220.0,222.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
606,6278,FinishedSingleOp,1,leveldb.anonymous_namespace_13.Stats.FinishedSingleOp,void leveldb.anonymous_namespace_13.Stats.FinishedSingleOp (),db\db_bench.cc,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = g_env->NowMicros();
      double micros = now - last_op_finish_;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",224.0,248.0,3.0,3.0,25.0,11,9,20,9,0,10,5,7,4,0,,0,10,0,0,0,void
607,6393,AddBytes,1,leveldb.anonymous_namespace_14.Stats.AddBytes,void leveldb.anonymous_namespace_14.Stats.AddBytes (int64_t),db\db_bench.cc,"void AddBytes(int64_t n) {
    bytes_ += n;
  }",250.0,252.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
608,6401,Report,1,leveldb.anonymous_namespace_15.Stats.Report,void leveldb.anonymous_namespace_15.Stats.Report (Slice),db\db_bench.cc,"void Report(const Slice& name) {
    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    std::string extra;
    if (bytes_ > 0) {
      // Rate is computed on actual elapsed time, not the sum of per-thread
      // elapsed times.
      double elapsed = (finish_ - start_) * 1e-6;
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / elapsed);
      extra = rate;
    }
    AppendWithSpace(&extra, message_);

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            seconds_ * 1e6 / done_,
            (extra.empty() ? """" : "" ""),
            extra.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",254.0,280.0,3.0,3.0,27.0,20,10,23,13,0,11,4,4,3,0,,0,11,2,1,1,void
609,6517,PrintHeader,1,leveldb.Benchmark.PrintHeader,void leveldb.Benchmark.PrintHeader (),doc\bench\db_bench_tree_db.cc,"void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",151.0,167.0,3.0,3.0,17.0,12,5,19,5,0,9,1,1,0,0,,0,9,0,0,0,void
610,6623,Benchmark,1,leveldb.Benchmark.Benchmark,ANY leveldb.Benchmark.Benchmark (),doc\bench\db_bench_tree_db.cc,"Benchmark()
  : db_(NULL),
    num_(FLAGS_num),
    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),
    bytes_(0),
    rand_(301) {
    std::vector<std::string> files;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    Env::Default()->GetChildren(test_dir.c_str(), &files);
    if (!FLAGS_use_existing_db) {
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_polyDB"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }
  }",291.0,311.0,3.0,3.0,21.0,17,9,18,6,0,4,4,5,1,0,,0,4,0,0,0,ANY
611,6690,~Benchmark,1,leveldb.Benchmark.~Benchmark,ANY leveldb.Benchmark.~Benchmark (),doc\bench\db_bench_tree_db.cc,"~Benchmark() {
    if (!db_->close()) {
      fprintf(stderr, ""close error: %s\n"", db_->error().name());
    }
  }",313.0,317.0,3.0,3.0,5.0,3,1,3,3,0,1,1,1,0,0,,0,1,0,0,0,ANY
612,6700,Run,1,leveldb.Benchmark.Run,void leveldb.Benchmark.Run (),doc\bench\db_bench_tree_db.cc,"void Run() {
    PrintHeader();
    Open(false);

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""overwrite"")) {
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandsync"")) {
        write_sync = true;
        Write(write_sync, RANDOM, F...",319.0,386.0,3.0,3.0,68.0,26,8,42,20,0,13,8,16,2,0,,0,13,0,0,0,void
613,7233,ThreadBody,1,leveldb.Benchmark.ThreadBody,void leveldb.Benchmark.ThreadBody (void*),db\db_bench.cc,"static void ThreadBody(void* v) {
    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);
    SharedState* shared = arg->shared;
    ThreadState* thread = arg->thread;
    {
      MutexLock l(&shared->mu);
      shared->num_initialized++;
      if (shared->num_initialized >= shared->total) {
        shared->cv.SignalAll();
      }
      while (!shared->start) {
        shared->cv.Wait();
      }
    }

    thread->stats.Start();
    (arg->bm->*(arg->method))(thread);
    thread->stats.Stop();

    {
      MutexLock l(&shared->mu);
      shared->num_done++;
      if (shared->num_done >= shared->total) {
        shared->cv.SignalAll();
      }
    }
  }",558.0,584.0,3.0,3.0,27.0,35,8,23,4,0,17,4,4,5,0,,0,17,2,1,1,void
614,7341,RunBenchmark,1,leveldb.Benchmark.RunBenchmark,"void leveldb.Benchmark.RunBenchmark (int,Slice,void)",db\db_bench.cc,"void RunBenchmark(int n, Slice name,
                    void (Benchmark::*method)(ThreadState*)) {
    SharedState shared;
    shared.total = n;
    shared.num_initialized = 0;
    shared.num_done = 0;
    shared.start = false;

    ThreadArg* arg = new ThreadArg[n];
    for (int i = 0; i < n; i++) {
      arg[i].bm = this;
      arg[i].method = method;
      arg[i].shared = &shared;
      arg[i].thread = new ThreadState(i);
      arg[i].thread->shared = &shared;
      g_env->StartThread(ThreadBody, &arg[i]);
    }

    shared.mu.Lock();
    while (shared.num_initialized < n) {
      shared.cv.Wait();
    }

    shared.start = true;
    shared.cv.SignalAll();
    while (shared.num_done < n) {
      shared.cv.Wait();
    }
    shared.mu.Unlock();

    for (int i = 1; i < n; i++) {
      arg[0].thread->stats.Merge(arg[i].thread->stats);
    }
    arg[0].thread->stats.Report(name);

    for (int i = 0; i < n; i++) {
      delete arg[i].thread;
    }
    delete[] arg;
  }",586.0,625.0,3.0,3.0,40.0,69,8,52,9,0,12,6,6,2,0,,0,12,6,3,3,void
615,7545,Crc32c,1,leveldb.Benchmark.Crc32c,void leveldb.Benchmark.Crc32c (ThreadState*),db\db_bench.cc,"void Crc32c(ThreadState* thread) {
    // Checksum about 500MB of data total
    const int size = 4096;
    const char* label = ""(4K per op)"";
    std::string data(size, 'x');
    int64_t bytes = 0;
    uint32_t crc = 0;
    while (bytes < 500 * 1048576) {
      crc = crc32c::Value(data.data(), size);
      thread->stats.FinishedSingleOp();
      bytes += size;
    }
    // Print so result is not dead
    fprintf(stderr, ""... crc=0x%x\r"", static_cast<unsigned int>(crc));

    thread->stats.AddBytes(bytes);
    thread->stats.AddMessage(label);
  }",627.0,644.0,3.0,3.0,18.0,17,7,19,8,0,3,2,2,0,0,,0,3,2,1,1,void
616,7617,AcquireLoad,1,leveldb.Benchmark.AcquireLoad,void leveldb.Benchmark.AcquireLoad (ThreadState*),db\db_bench.cc,"void AcquireLoad(ThreadState* thread) {
    int dummy;
    port::AtomicPointer ap(&dummy);
    int count = 0;
    void *ptr = NULL;
    thread->stats.AddMessage(""(each op is 1000 loads)"");
    while (count < 100000) {
      for (int i = 0; i < 1000; i++) {
        ptr = ap.Acquire_Load();
      }
      count++;
      thread->stats.FinishedSingleOp();
    }
    if (ptr == NULL) exit(1); // Disable unused variable warning.
  }",646.0,660.0,3.0,3.0,15.0,14,7,14,7,0,2,4,5,0,0,,0,2,2,1,1,void
617,7680,SnappyCompress,1,leveldb.Benchmark.SnappyCompress,void leveldb.Benchmark.SnappyCompress (ThreadState*),db\db_bench.cc,"void SnappyCompress(ThreadState* thread) {
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    int64_t bytes = 0;
    int64_t produced = 0;
    bool ok = true;
    std::string compressed;
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
      produced += compressed.size();
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""(output: %.1f%%)"",
               (produced * 100.0) / bytes);
      thread->stats.AddMessage(buf);
      thread->stats.AddBytes(bytes);
    }
  }",662.0,685.0,3.0,3.0,24.0,23,9,19,8,0,2,3,3,0,0,,0,2,2,1,1,void
618,7790,SnappyUncompress,1,leveldb.Benchmark.SnappyUncompress,void leveldb.Benchmark.SnappyUncompress (ThreadState*),db\db_bench.cc,"void SnappyUncompress(ThreadState* thread) {
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    std::string compressed;
    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
    int64_t bytes = 0;
    char* uncompressed = new char[input.size()];
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),
                                    uncompressed);
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }
    delete[] uncompressed;

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      thread->stats.AddBytes(bytes);
    }
  }",687.0,707.0,3.0,3.0,21.0,26,11,23,9,0,2,3,3,0,0,,0,2,2,1,1,void
619,7891,Open,1,leveldb.Benchmark.Open,void leveldb.Benchmark.Open (),doc\bench\db_bench_tree_db.cc,"void Open(bool sync) {
    assert(db_ == NULL);

    // Initialize db_
    db_ = new kyotocabinet::TreeDB();
    char file_name[100];
    db_num_++;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    snprintf(file_name, sizeof(file_name),
             ""%s/dbbench_polyDB-%d.kct"",
             test_dir.c_str(),
             db_num_);

    // Create tuning options and open the database
    int open_options = kyotocabinet::PolyDB::OWRITER |
                       kyotocabinet::PolyDB::OCREATE;
    int tune_options = kyotocabinet::TreeDB::TSMALL |
        kyotocabinet::TreeDB::TLINEAR;
    if (FLAGS_compression) {
      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;
      db_->tune_compressor(&comp_);
    }
    db_->tune_options(tune_options);
    db_->tune_page_cache(FLAGS_cache_size);
    db_->tune_page(FLAGS_page_size);
    db_->tune_map(256LL<<20);
    if (sync) {
      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;
    }
    if (!db_->open(file_name, ...",389.0,422.0,5.0,3.0,34.0,27,5,28,16,0,18,2,2,0,0,,0,18,2,1,1,void
620,7976,OpenBench,1,leveldb.Benchmark.OpenBench,void leveldb.Benchmark.OpenBench (ThreadState*),db\db_bench.cc,"void OpenBench(ThreadState* thread) {
    for (int i = 0; i < num_; i++) {
      delete db_;
      Open();
      thread->stats.FinishedSingleOp();
    }
  }",728.0,734.0,3.0,3.0,7.0,5,5,5,4,0,3,2,2,1,0,,0,3,2,1,1,void
621,8018,DoWrite,1,leveldb.Benchmark.DoWrite,"void leveldb.Benchmark.DoWrite (ThreadState*,bool)",db\db_bench.cc,"void DoWrite(ThreadState* thread, bool seq) {
    if (num_ != FLAGS_num) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_);
      thread->stats.AddMessage(msg);
    }

    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    int64_t bytes = 0;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Put(key, gen.Generate(value_size_));
        bytes += value_size_ + strlen(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
    thread->stats.AddBytes(bytes);
  }",744.0,772.0,3.0,3.0,29.0,32,12,41,18,0,14,5,7,4,0,,0,14,4,2,2,void
622,8159,ReadSequential,1,leveldb.Benchmark.ReadSequential,void leveldb.Benchmark.ReadSequential (ThreadState*),doc\bench\db_bench_tree_db.cc,"void ReadSequential() {
    kyotocabinet::DB::Cursor* cur = db_->cursor();
    cur->jump();
    std::string ckey, cvalue;
    while (cur->get(&ckey, &cvalue, true)) {
      bytes_ += ckey.size() + cvalue.size();
      FinishedSingleOp();
    }
    delete cur;
  }",459.0,468.0,3.0,3.0,10.0,20,9,16,6,0,4,2,2,1,0,,0,4,0,0,0,void
623,8233,ReadReverse,1,leveldb.Benchmark.ReadReverse,void leveldb.Benchmark.ReadReverse (ThreadState*),db\db_bench.cc,"void ReadReverse(ThreadState* thread) {
    Iterator* iter = db_->NewIterator(ReadOptions());
    int i = 0;
    int64_t bytes = 0;
    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }
    delete iter;
    thread->stats.AddBytes(bytes);
  }",787.0,798.0,3.0,3.0,12.0,20,9,16,6,0,4,2,2,1,0,,0,4,2,1,1,void
624,8307,ReadRandom,1,leveldb.Benchmark.ReadRandom,void leveldb.Benchmark.ReadRandom (ThreadState*),doc\bench\db_bench_tree_db.cc,"void ReadRandom() {
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = rand_.Next() % reads_;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->get(key, &value);
      FinishedSingleOp();
    }
  }",470.0,479.0,3.0,3.0,10.0,17,8,22,12,0,7,3,4,2,0,,0,7,0,0,0,void
625,8384,ReadMissing,1,leveldb.Benchmark.ReadMissing,void leveldb.Benchmark.ReadMissing (ThreadState*),db\db_bench.cc,"void ReadMissing(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d."", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",818.0,828.0,3.0,3.0,11.0,11,7,14,9,0,5,2,2,1,0,,0,5,2,1,1,void
626,8435,ReadHot,1,leveldb.Benchmark.ReadHot,void leveldb.Benchmark.ReadHot (ThreadState*),db\db_bench.cc,"void ReadHot(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    const int range = (FLAGS_num + 99) / 100;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % range;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",830.0,841.0,3.0,3.0,12.0,14,9,16,10,0,5,2,2,1,0,,0,5,2,1,1,void
627,8494,SeekRandom,1,leveldb.Benchmark.SeekRandom,void leveldb.Benchmark.SeekRandom (ThreadState*),db\db_bench.cc,"void SeekRandom(ThreadState* thread) {
    ReadOptions options;
    int found = 0;
    for (int i = 0; i < reads_; i++) {
      Iterator* iter = db_->NewIterator(options);
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      iter->Seek(key);
      if (iter->Valid() && iter->key() == key) found++;
      delete iter;
      thread->stats.FinishedSingleOp();
    }
    char msg[100];
    snprintf(msg, sizeof(msg), ""(%d of %d found)"", found, num_);
    thread->stats.AddMessage(msg);
  }",843.0,859.0,3.0,3.0,17.0,22,10,27,12,0,7,3,4,1,0,,0,7,2,1,1,void
628,8585,DoDelete,1,leveldb.Benchmark.DoDelete,"void leveldb.Benchmark.DoDelete (ThreadState*,bool)",db\db_bench.cc,"void DoDelete(ThreadState* thread, bool seq) {
    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Delete(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""del error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
  }",861.0,880.0,3.0,3.0,20.0,22,10,26,14,0,7,4,6,2,0,,0,7,4,2,2,void
629,8701,ReadWhileWriting,1,leveldb.Benchmark.ReadWhileWriting,void leveldb.Benchmark.ReadWhileWriting (ThreadState*),db\db_bench.cc,"void ReadWhileWriting(ThreadState* thread) {
    if (thread->tid > 0) {
      ReadRandom(thread);
    } else {
      // Special thread that keeps writing until other threads are done.
      RandomGenerator gen;
      while (true) {
        {
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }

        const int k = thread->rand.Next() % FLAGS_num;
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
        if (!s.ok()) {
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }
      }

      // Do not count any of the preceding work/delay in stats.
      thread->stats.Start();
    }
  }",890.0,918.0,3.0,3.0,29.0,2,2,2,1,0,1,2,2,1,0,,0,1,2,1,1,void
630,8803,Compact,1,leveldb.Benchmark.Compact,void leveldb.Benchmark.Compact (ThreadState*),db\db_bench.cc,"void Compact(ThreadState* thread) {
    db_->CompactRange(NULL, NULL);
  }",920.0,922.0,3.0,3.0,3.0,1,1,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
631,8814,PrintStats,1,leveldb.Benchmark.PrintStats,void leveldb.Benchmark.PrintStats (char*),db\db_bench.cc,"void PrintStats(const char* key) {
    std::string stats;
    if (!db_->GetProperty(key, &stats)) {
      stats = ""(failed)"";
    }
    fprintf(stdout, ""\n%s\n"", stats.c_str());
  }",924.0,930.0,3.0,3.0,7.0,5,5,6,4,0,1,2,2,1,0,,0,1,2,1,1,void
632,8856,HeapProfile,1,leveldb.Benchmark.HeapProfile,void leveldb.Benchmark.HeapProfile (),db\db_bench.cc,"void HeapProfile() {
    char fname[100];
    snprintf(fname, sizeof(fname), ""%s/heap-%04d"", FLAGS_db, ++heap_counter_);
    WritableFile* file;
    Status s = g_env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      return;
    }
    bool ok = port::GetHeapProfile(WriteToFile, file);
    delete file;
    if (!ok) {
      fprintf(stderr, ""heap profiling not supported\n"");
      g_env->DeleteFile(fname);
    }
  }",936.0,951.0,3.0,3.0,16.0,14,8,19,9,0,2,3,3,0,0,,0,2,0,0,0,void
633,9431,current_output,1,leveldb.CompactionState.current_output,Output leveldb.CompactionState.current_output (),db\db_impl.cc,Output* current_output() { return &outputs[outputs.size()-1]; },74.0,74.0,3.0,65.0,1.0,4,4,2,1,0,2,1,1,0,0,,0,2,0,0,0,Output
634,9481,SanitizeOptions,1,leveldb.SanitizeOptions,"Options leveldb.SanitizeOptions (ANY,InternalKeyComparator*,InternalFilterPolicy*,Options)",db\db_impl.cc,"Options SanitizeOptions(const std::string& dbname,
                        const InternalKeyComparator* icmp,
                        const InternalFilterPolicy* ipolicy,
                        const Options& src) {
  Options result = src;
  result.comparator = icmp;
  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;
  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);
  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);
  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);
  ClipToRange(&result.block_size,        1<<10,                       4<<20);
  if (result.info_log == NULL) {
    // Open a log file in the same directory as the db
    src.env->CreateDir(dbname);  // In case it does not exist
    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
    if (!s.ok()) {
      // No place su...",90.0,115.0,1.0,1.0,26.0,43,10,32,8,0,15,4,5,2,0,,0,15,8,4,4,Options
635,9620,DBImpl,1,leveldb.DBImpl.DBImpl,"ANY leveldb.DBImpl.DBImpl (Options,ANY)",db\db_impl.cc,"DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)
    : env_(raw_options.env),
      internal_comparator_(raw_options.comparator),
      internal_filter_policy_(raw_options.filter_policy),
      options_(SanitizeOptions(dbname, &internal_comparator_,
                               &internal_filter_policy_, raw_options)),
      owns_info_log_(options_.info_log != raw_options.info_log),
      owns_cache_(options_.block_cache != raw_options.block_cache),
      dbname_(dbname),
      db_lock_(NULL),
      shutting_down_(NULL),
      bg_cv_(&mutex_),
      mem_(NULL),
      imm_(NULL),
      logfile_(NULL),
      logfile_number_(0),
      log_(NULL),
      seed_(0),
      tmp_batch_(new WriteBatch),
      bg_compaction_scheduled_(false),
      manual_compaction_(NULL) {
  has_imm_.Release_Store(NULL);

  // Reserve ten files or so for other uses and give the rest to TableCache.
  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;
  table_ca...",117.0,146.0,1.0,1.0,30.0,11,5,16,11,0,10,1,1,0,0,,0,10,4,2,2,ANY
636,9657,~DBImpl,1,leveldb.DBImpl.~DBImpl,ANY leveldb.DBImpl.~DBImpl (),db\db_impl.cc,"DBImpl::~DBImpl() {
  // Wait for background work to finish
  mutex_.Lock();
  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
  while (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  if (db_lock_ != NULL) {
    env_->UnlockFile(db_lock_);
  }

  delete versions_;
  if (mem_ != NULL) mem_->Unref();
  if (imm_ != NULL) imm_->Unref();
  delete tmp_batch_;
  delete log_;
  delete logfile_;
  delete table_cache_;

  if (owns_info_log_) {
    delete options_.info_log;
  }
  if (owns_cache_) {
    delete options_.block_cache;
  }
}",148.0,175.0,1.0,1.0,28.0,19,4,24,17,0,21,7,7,6,0,,0,21,0,0,0,ANY
637,9733,NewDB,1,leveldb.DBImpl.NewDB,Status leveldb.DBImpl.NewDB (),db\db_impl.cc,"Status DBImpl::NewDB() {
  VersionEdit new_db;
  new_db.SetComparatorName(user_comparator()->Name());
  new_db.SetLogNumber(0);
  new_db.SetNextFile(2);
  new_db.SetLastSequence(0);

  const std::string manifest = DescriptorFileName(dbname_, 1);
  WritableFile* file;
  Status s = env_->NewWritableFile(manifest, &file);
  if (!s.ok()) {
    return s;
  }
  {
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file->Close();
    }
  }
  delete file;
  if (s.ok()) {
    // Make ""CURRENT"" file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  } else {
    env_->DeleteFile(manifest);
  }
  return s;
}",177.0,207.0,1.0,1.0,31.0,21,6,27,8,0,4,4,4,0,0,,0,4,0,0,0,Status
638,9840,MaybeIgnoreError,1,leveldb.DBImpl.MaybeIgnoreError,void leveldb.DBImpl.MaybeIgnoreError (Status*),db\db_impl.cc,"void DBImpl::MaybeIgnoreError(Status* s) const {
  if (s->ok() || options_.paranoid_checks) {
    // No change needed
  } else {
    Log(options_.info_log, ""Ignoring error %s"", s->ToString().c_str());
    *s = Status::OK();
  }
}",209.0,216.0,1.0,1.0,8.0,3,3,2,2,0,1,2,2,1,0,,0,1,2,1,1,void
639,9876,DeleteObsoleteFiles,1,leveldb.DBImpl.DeleteObsoleteFiles,void leveldb.DBImpl.DeleteObsoleteFiles (),db\db_impl.cc,"void DBImpl::DeleteObsoleteFiles() {
  if (!bg_error_.ok()) {
    // After a background error, we don't know whether a new version may
    // or may not have been committed, so we cannot safely garbage collect.
    return;
  }

  // Make a set of all of the live files
  std::set<uint64_t> live = pending_outputs_;
  versions_->AddLiveFiles(&live);

  std::vector<std::string> filenames;
  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose
  uint64_t number;
  FileType type;
  for (size_t i = 0; i < filenames.size(); i++) {
    if (ParseFileName(filenames[i], &number, &type)) {
      bool keep = true;
      switch (type) {
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= ver...",218.0,272.0,1.0,1.0,55.0,49,15,58,22,0,12,12,15,1,0,,0,12,0,0,0,void
640,10058,Recover,1,leveldb.DBImpl.Recover,"Status leveldb.DBImpl.Recover (VersionEdit*,bool*)",db\db_impl.cc,"Status DBImpl::Recover(VersionEdit* edit, bool *save_manifest) {
  mutex_.AssertHeld();

  // Ignore error from CreateDir since the creation of the DB is
  // committed only when the descriptor is created, and this directory
  // may already exist from a previous failed creation attempt.
  env_->CreateDir(dbname_);
  assert(db_lock_ == NULL);
  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);
  if (!s.ok()) {
    return s;
  }

  if (!env_->FileExists(CurrentFileName(dbname_))) {
    if (options_.create_if_missing) {
      s = NewDB();
      if (!s.ok()) {
        return s;
      }
    } else {
      return Status::InvalidArgument(
          dbname_, ""does not exist (create_if_missing is false)"");
    }
  } else {
    if (options_.error_if_exists) {
      return Status::InvalidArgument(
          dbname_, ""exists (error_if_exists is true)"");
    }
  }

  s = versions_->Recover(save_manifest);
  if (!s.ok()) {
    return s;
  }
  SequenceNumber max_sequence(0);

  // Reco...",274.0,363.0,1.0,1.0,90.0,80,16,92,24,0,21,14,21,4,0,,0,20,4,2,2,Status
641,10387,RecoverLogFile,1,leveldb.DBImpl.RecoverLogFile,"Status leveldb.DBImpl.RecoverLogFile (uint64_t,bool,bool*,VersionEdit*,SequenceNumber*)",db\db_impl.cc,"Status DBImpl::RecoverLogFile(uint64_t log_number, bool last_log,
                              bool* save_manifest, VersionEdit* edit,
                              SequenceNumber* max_sequence) {
  struct LogReporter : public log::Reader::Reporter {
    Env* env;
    Logger* info_log;
    const char* fname;
    Status* status;  // NULL if options_.paranoid_checks==false
    virtual void Corruption(size_t bytes, const Status& s) {
      Log(info_log, ""%s%s: dropping %d bytes; %s"",
          (this->status == NULL ? ""(ignoring error) "" : """"),
          fname, static_cast<int>(bytes), s.ToString().c_str());
      if (this->status != NULL && this->status->ok()) *this->status = s;
    }
  };

  mutex_.AssertHeld();

  // Open the log file
  std::string fname = LogFileName(dbname_, log_number);
  SequentialFile* file;
  Status status = env_->NewSequentialFile(fname, &file);
  if (!status.ok()) {
    MaybeIgnoreError(&status);
    return status;
  }

  // Create the log reader.
  LogRepor...",365.0,486.0,1.0,1.0,122.0,101,18,113,31,0,22,17,25,5,1,,0,21,10,5,5,Status
642,10751,WriteLevel0Table,1,leveldb.DBImpl.WriteLevel0Table,"Status leveldb.DBImpl.WriteLevel0Table (MemTable*,VersionEdit*,Version*)",db\db_impl.cc,"Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
                                Version* base) {
  mutex_.AssertHeld();
  const uint64_t start_micros = env_->NowMicros();
  FileMetaData meta;
  meta.number = versions_->NewFileNumber();
  pending_outputs_.insert(meta.number);
  Iterator* iter = mem->NewIterator();
  Log(options_.info_log, ""Level-0 table #%llu: started"",
      (unsigned long long) meta.number);

  Status s;
  {
    mutex_.Unlock();
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
    mutex_.Lock();
  }

  Log(options_.info_log, ""Level-0 table #%llu: %lld bytes %s"",
      (unsigned long long) meta.number,
      (unsigned long long) meta.file_size,
      s.ToString().c_str());
  delete iter;
  pending_outputs_.erase(meta.number);


  // Note that if file_size is zero, the file has been deleted and
  // should not be added to the manifest.
  int level = 0;
  if (s.ok() && meta.file_size > 0) {
    const Slice min_user_key = meta.s...",488.0,532.0,1.0,1.0,45.0,55,11,55,20,0,31,3,4,1,0,,0,31,6,3,3,Status
643,10944,CompactMemTable,1,leveldb.DBImpl.CompactMemTable,void leveldb.DBImpl.CompactMemTable (),db\db_impl.cc,"void DBImpl::CompactMemTable() {
  mutex_.AssertHeld();
  assert(imm_ != NULL);

  // Save the contents of the memtable as a new Table
  VersionEdit edit;
  Version* base = versions_->current();
  base->Ref();
  Status s = WriteLevel0Table(imm_, &edit, base);
  base->Unref();

  if (s.ok() && shutting_down_.Acquire_Load()) {
    s = Status::IOError(""Deleting DB during memtable compaction"");
  }

  // Replace immutable memtable with the generated Table
  if (s.ok()) {
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
    s = versions_->LogAndApply(&edit, &mutex_);
  }

  if (s.ok()) {
    // Commit to the new state
    imm_->Unref();
    imm_ = NULL;
    has_imm_.Release_Store(NULL);
    DeleteObsoleteFiles();
  } else {
    RecordBackgroundError(s);
  }
}",534.0,565.0,1.0,1.0,32.0,24,6,29,11,0,12,4,4,1,1,,0,12,0,0,0,void
644,11047,CompactRange,1,leveldb.DBImpl.CompactRange,"void leveldb.DBImpl.CompactRange (Slice*,Slice*)",db\db_impl.cc,"void DBImpl::CompactRange(const Slice* begin, const Slice* end) {
  int max_level_with_files = 1;
  {
    MutexLock l(&mutex_);
    Version* base = versions_->current();
    for (int level = 1; level < config::kNumLevels; level++) {
      if (base->OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap
  for (int level = 0; level < max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}",567.0,582.0,1.0,1.0,16.0,11,5,19,8,0,7,4,5,3,0,,0,7,4,2,2,void
645,11112,TEST_CompactRange,1,leveldb.DBImpl.TEST_CompactRange,"void leveldb.DBImpl.TEST_CompactRange (int,Slice*,Slice*)",db\db_impl.cc,"void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {
  assert(level >= 0);
  assert(level + 1 < config::kNumLevels);

  InternalKey begin_storage, end_storage;

  ManualCompaction manual;
  manual.level = level;
  manual.done = false;
  if (begin == NULL) {
    manual.begin = NULL;
  } else {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &begin_storage;
  }
  if (end == NULL) {
    manual.end = NULL;
  } else {
    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
    manual.end = &end_storage;
  }

  MutexLock l(&mutex_);
  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {
    if (manual_compaction_ == NULL) {  // Idle
      manual_compaction_ = &manual;
      MaybeScheduleCompaction();
    } else {  // Running either my compaction or another compaction.
      bg_cv_.Wait();
    }
  }
  if (manual_compaction_ == &manual) {
    // Cancel my manual compaction since w...",584.0,619.0,1.0,1.0,36.0,28,9,26,10,0,12,6,7,5,0,,0,12,6,3,3,void
646,11242,TEST_CompactMemTable,1,leveldb.DBImpl.TEST_CompactMemTable,Status leveldb.DBImpl.TEST_CompactMemTable (),db\db_impl.cc,"Status DBImpl::TEST_CompactMemTable() {
  // NULL batch means just wait for earlier writes to be done
  Status s = Write(WriteOptions(), NULL);
  if (s.ok()) {
    // Wait until the compaction completes
    MutexLock l(&mutex_);
    while (imm_ != NULL && bg_error_.ok()) {
      bg_cv_.Wait();
    }
    if (imm_ != NULL) {
      s = bg_error_;
    }
  }
  return s;
}",621.0,635.0,1.0,1.0,15.0,9,5,13,6,0,6,4,6,3,0,,0,6,0,0,0,Status
647,11286,RecordBackgroundError,1,leveldb.DBImpl.RecordBackgroundError,void leveldb.DBImpl.RecordBackgroundError (Status),db\db_impl.cc,"void DBImpl::RecordBackgroundError(const Status& s) {
  mutex_.AssertHeld();
  if (bg_error_.ok()) {
    bg_error_ = s;
    bg_cv_.SignalAll();
  }
}",637.0,643.0,1.0,1.0,7.0,4,2,5,4,0,4,2,2,1,0,,0,4,2,1,1,void
648,11308,MaybeScheduleCompaction,1,leveldb.DBImpl.MaybeScheduleCompaction,void leveldb.DBImpl.MaybeScheduleCompaction (),db\db_impl.cc,"void DBImpl::MaybeScheduleCompaction() {
  mutex_.AssertHeld();
  if (bg_compaction_scheduled_) {
    // Already scheduled
  } else if (shutting_down_.Acquire_Load()) {
    // DB is being deleted; no more background compactions
  } else if (!bg_error_.ok()) {
    // Already got an error; no more changes
  } else if (imm_ == NULL &&
             manual_compaction_ == NULL &&
             !versions_->NeedsCompaction()) {
    // No work to be done
  } else {
    bg_compaction_scheduled_ = true;
    env_->Schedule(&DBImpl::BGWork, this);
  }
}",645.0,661.0,1.0,1.0,17.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,void
649,11378,BackgroundCall,1,leveldb.DBImpl.BackgroundCall,void leveldb.DBImpl.BackgroundCall (),db\db_impl.cc,"void DBImpl::BackgroundCall() {
  MutexLock l(&mutex_);
  assert(bg_compaction_scheduled_);
  if (shutting_down_.Acquire_Load()) {
    // No more background work when shutting down.
  } else if (!bg_error_.ok()) {
    // No more background work after a background error.
  } else {
    BackgroundCompaction();
  }

  bg_compaction_scheduled_ = false;

  // Previous compaction may have produced too many files in a level,
  // so reschedule another compaction if needed.
  MaybeScheduleCompaction();
  bg_cv_.SignalAll();
}",667.0,684.0,1.0,1.0,18.0,4,3,5,4,0,5,2,2,1,0,,0,5,0,0,0,void
650,11414,BackgroundCompaction,1,leveldb.DBImpl.BackgroundCompaction,void leveldb.DBImpl.BackgroundCompaction (),db\db_impl.cc,"void DBImpl::BackgroundCompaction() {
  mutex_.AssertHeld();

  if (imm_ != NULL) {
    CompactMemTable();
    return;
  }

  Compaction* c;
  bool is_manual = (manual_compaction_ != NULL);
  InternalKey manual_end;
  if (is_manual) {
    ManualCompaction* m = manual_compaction_;
    c = versions_->CompactRange(m->level, m->begin, m->end);
    m->done = (c == NULL);
    if (c != NULL) {
      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
    }
    Log(options_.info_log,
        ""Manual compaction at level-%d from %s .. %s; will stop at %s\n"",
        m->level,
        (m->begin ? m->begin->DebugString().c_str() : ""(begin)""),
        (m->end ? m->end->DebugString().c_str() : ""(end)""),
        (m->done ? ""(end)"" : manual_end.DebugString().c_str()));
  } else {
    c = versions_->PickCompaction();
  }

  Status status;
  if (c == NULL) {
    // Nothing to do
  } else if (!is_manual && c->IsTrivialMove()) {
    // Move file to next level
    assert(c->num_input_files(0) ...",686.0,769.0,1.0,1.0,84.0,52,10,46,11,0,23,9,12,2,0,,0,23,0,0,0,void
651,11771,CleanupCompaction,1,leveldb.DBImpl.CleanupCompaction,void leveldb.DBImpl.CleanupCompaction (CompactionState*),db\db_impl.cc,"void DBImpl::CleanupCompaction(CompactionState* compact) {
  mutex_.AssertHeld();
  if (compact->builder != NULL) {
    // May happen if we get a shutdown call in the middle of compaction
    compact->builder->Abandon();
    delete compact->builder;
  } else {
    assert(compact->outfile == NULL);
  }
  delete compact->outfile;
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    pending_outputs_.erase(out.number);
  }
  delete compact;
}",771.0,786.0,1.0,1.0,16.0,19,7,15,6,0,8,3,3,2,0,,0,8,2,1,1,void
652,11843,OpenCompactionOutputFile,1,leveldb.DBImpl.OpenCompactionOutputFile,Status leveldb.DBImpl.OpenCompactionOutputFile (CompactionState*),db\db_impl.cc,"Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {
  assert(compact != NULL);
  assert(compact->builder == NULL);
  uint64_t file_number;
  {
    mutex_.Lock();
    file_number = versions_->NewFileNumber();
    pending_outputs_.insert(file_number);
    CompactionState::Output out;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact->outputs.push_back(out);
    mutex_.Unlock();
  }

  // Make the output file
  std::string fname = TableFileName(dbname_, file_number);
  Status s = env_->NewWritableFile(fname, &compact->outfile);
  if (s.ok()) {
    compact->builder = new TableBuilder(options_, compact->outfile);
  }
  return s;
}",788.0,811.0,1.0,1.0,24.0,26,7,29,13,0,12,2,2,0,0,,0,12,2,1,1,Status
653,11940,FinishCompactionOutputFile,1,leveldb.DBImpl.FinishCompactionOutputFile,"Status leveldb.DBImpl.FinishCompactionOutputFile (CompactionState*,Iterator*)",db\db_impl.cc,"Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
                                          Iterator* input) {
  assert(compact != NULL);
  assert(compact->outfile != NULL);
  assert(compact->builder != NULL);

  const uint64_t output_number = compact->current_output()->number;
  assert(output_number != 0);

  // Check for iterator errors
  Status s = input->status();
  const uint64_t current_entries = compact->builder->NumEntries();
  if (s.ok()) {
    s = compact->builder->Finish();
  } else {
    compact->builder->Abandon();
  }
  const uint64_t current_bytes = compact->builder->FileSize();
  compact->current_output()->file_size = current_bytes;
  compact->total_bytes += current_bytes;
  delete compact->builder;
  compact->builder = NULL;

  // Finish and check for file errors
  if (s.ok()) {
    s = compact->outfile->Sync();
  }
  if (s.ok()) {
    s = compact->outfile->Close();
  }
  delete compact->outfile;
  compact->outfile = NULL;

  if (s.ok() && current_...",813.0,863.0,1.0,1.0,51.0,57,9,50,10,0,15,6,7,0,0,,0,15,4,2,2,Status
654,12137,InstallCompactionResults,1,leveldb.DBImpl.InstallCompactionResults,Status leveldb.DBImpl.InstallCompactionResults (CompactionState*),db\db_impl.cc,"Status DBImpl::InstallCompactionResults(CompactionState* compact) {
  mutex_.AssertHeld();
  Log(options_.info_log,  ""Compacted %d@%d + %d@%d files => %lld bytes"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1,
      static_cast<long long>(compact->total_bytes));

  // Add compaction outputs
  compact->compaction->AddInputDeletions(compact->compaction->edit());
  const int level = compact->compaction->level();
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    compact->compaction->edit()->AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
  }
  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);
}",866.0,885.0,1.0,1.0,20.0,39,8,26,7,0,16,2,2,1,0,,0,16,2,1,1,Status
655,12267,DoCompactionWork,1,leveldb.DBImpl.DoCompactionWork,Status leveldb.DBImpl.DoCompactionWork (CompactionState*),db\db_impl.cc,"Status DBImpl::DoCompactionWork(CompactionState* compact) {
  const uint64_t start_micros = env_->NowMicros();
  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions

  Log(options_.info_log,  ""Compacting %d@%d + %d@%d files"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1);

  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);
  assert(compact->builder == NULL);
  assert(compact->outfile == NULL);
  if (snapshots_.empty()) {
    compact->smallest_snapshot = versions_->LastSequence();
  } else {
    compact->smallest_snapshot = snapshots_.oldest()->number_;
  }

  // Release mutex while we're actually doing the compaction work
  mutex_.Unlock();

  Iterator* input = versions_->MakeInputIterator(compact->compaction);
  input->SeekToFirst();
  Status status;
  ParsedInternalKey ikey;
  std::string current_user_key;
  bool has_current_use...",887.0,1046.0,1.0,1.0,160.0,143,16,126,29,0,47,25,43,14,1,,0,47,2,1,1,Status
656,12881,CleanupIteratorState,1,leveldb.anonymous_namespace_2.CleanupIteratorState,"void leveldb.anonymous_namespace_2.CleanupIteratorState (void*,void*)",db\db_impl.cc,"static void CleanupIteratorState(void* arg1, void* arg2) {
  IterState* state = reinterpret_cast<IterState*>(arg1);
  state->mu->Lock();
  state->mem->Unref();
  if (state->imm != NULL) state->imm->Unref();
  state->version->Unref();
  state->mu->Unlock();
  delete state;
}",1056.0,1064.0,1.0,1.0,9.0,15,5,10,3,0,6,2,2,1,0,,0,6,4,2,2,void
657,12932,NewInternalIterator,1,leveldb.DBImpl.NewInternalIterator,"Iterator leveldb.DBImpl.NewInternalIterator (ReadOptions,SequenceNumber*,uint32_t*)",db\db_impl.cc,"Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,
                                      SequenceNumber* latest_snapshot,
                                      uint32_t* seed) {
  IterState* cleanup = new IterState;
  mutex_.Lock();
  *latest_snapshot = versions_->LastSequence();

  // Collect together all needed child iterators
  std::vector<Iterator*> list;
  list.push_back(mem_->NewIterator());
  mem_->Ref();
  if (imm_ != NULL) {
    list.push_back(imm_->NewIterator());
    imm_->Ref();
  }
  versions_->current()->AddIterators(options, &list);
  Iterator* internal_iter =
      NewMergingIterator(&internal_comparator_, &list[0], list.size());
  versions_->current()->Ref();

  cleanup->mu = &mutex_;
  cleanup->mem = mem_;
  cleanup->imm = imm_;
  cleanup->version = versions_->current();
  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);

  *seed = ++seed_;
  mutex_.Unlock();
  return internal_iter;
}",1067.0,1096.0,1.0,1.0,30.0,38,9,36,14,0,20,2,2,1,0,,0,20,6,3,3,Iterator
658,13071,TEST_MaxNextLevelOverlappingBytes,1,leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes,int64_t leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes (),db\db_impl.cc,"int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {
  MutexLock l(&mutex_);
  return versions_->MaxNextLevelOverlappingBytes();
}",1104.0,1107.0,1.0,1.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,int64_t
659,13084,Get,1,leveldb.DBImpl.Get,"Status leveldb.DBImpl.Get (ReadOptions,Slice,ANY*)",db\db_impl.cc,"Status DBImpl::Get(const ReadOptions& options,
                   const Slice& key,
                   std::string* value) {
  Status s;
  MutexLock l(&mutex_);
  SequenceNumber snapshot;
  if (options.snapshot != NULL) {
    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;
  } else {
    snapshot = versions_->LastSequence();
  }

  MemTable* mem = mem_;
  MemTable* imm = imm_;
  Version* current = versions_->current();
  mem->Ref();
  if (imm != NULL) imm->Ref();
  current->Ref();

  bool have_stat_update = false;
  Version::GetStats stats;

  // Unlock while reading from files and memtables
  {
    mutex_.Unlock();
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem->Get(lkey, value, &s)) {
      // Done
    } else if (imm != NULL && imm->Get(lkey, value, &s)) {
      // Done
    } else {
      s = current->Get(options, lkey, value, &stats);
      have_stat_update = true;
    }
    m...",1109.0,1154.0,1.0,1.0,46.0,26,7,34,16,0,8,6,6,1,0,,0,8,6,3,3,Status
660,13242,NewIterator,1,leveldb.DBImpl.NewIterator,Iterator leveldb.DBImpl.NewIterator (ReadOptions),db\db_impl.cc,"Iterator* DBImpl::NewIterator(const ReadOptions& options) {
  SequenceNumber latest_snapshot;
  uint32_t seed;
  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);
  return NewDBIterator(
      this, user_comparator(), iter,
      (options.snapshot != NULL
       ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_
       : latest_snapshot),
      seed);
}",1156.0,1166.0,1.0,1.0,11.0,9,7,10,5,0,2,1,1,0,0,,0,2,2,1,1,Iterator
661,13278,RecordReadSample,1,leveldb.DBImpl.RecordReadSample,void leveldb.DBImpl.RecordReadSample (Slice),db\db_impl.cc,"void DBImpl::RecordReadSample(Slice key) {
  MutexLock l(&mutex_);
  if (versions_->current()->RecordReadSample(key)) {
    MaybeScheduleCompaction();
  }
}",1168.0,1173.0,1.0,1.0,6.0,3,2,3,3,0,2,2,2,1,0,,0,2,2,1,1,void
662,13298,GetSnapshot,1,leveldb.DBImpl.GetSnapshot,Snapshot leveldb.DBImpl.GetSnapshot (),db\db_impl.cc,"const Snapshot* DBImpl::GetSnapshot() {
  MutexLock l(&mutex_);
  return snapshots_.New(versions_->LastSequence());
}",1175.0,1178.0,1.0,1.0,4.0,3,3,3,3,0,3,1,1,0,0,,0,3,0,0,0,Snapshot
663,13315,ReleaseSnapshot,1,leveldb.DBImpl.ReleaseSnapshot,void leveldb.DBImpl.ReleaseSnapshot (Snapshot*),db\db_impl.cc,"void DBImpl::ReleaseSnapshot(const Snapshot* s) {
  MutexLock l(&mutex_);
  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));
}",1180.0,1183.0,1.0,1.0,4.0,3,3,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
664,13359,Write,1,leveldb.DBImpl.Write,"Status leveldb.DBImpl.Write (WriteOptions,WriteBatch*)",db\db_impl.cc,"Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {
  Writer w(&mutex_);
  w.batch = my_batch;
  w.sync = options.sync;
  w.done = false;

  MutexLock l(&mutex_);
  writers_.push_back(&w);
  while (!w.done && &w != writers_.front()) {
    w.cv.Wait();
  }
  if (w.done) {
    return w.status;
  }

  // May temporarily unlock and wait.
  Status status = MakeRoomForWrite(my_batch == NULL);
  uint64_t last_sequence = versions_->LastSequence();
  Writer* last_writer = &w;
  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions
    WriteBatch* updates = BuildBatchGroup(&last_writer);
    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
    last_sequence += WriteBatchInternal::Count(updates);

    // Add to log and apply to memtable.  We can release the lock
    // during this phase since &w is currently responsible for logging
    // and protects against concurrent loggers and concurrent writes
    // into mem_.
    {
      mutex_.Unloc...",1194.0,1265.0,1.0,1.0,72.0,73,10,72,18,0,30,14,21,6,1,,0,30,4,2,2,Status
665,13618,BuildBatchGroup,1,leveldb.DBImpl.BuildBatchGroup,WriteBatch leveldb.DBImpl.BuildBatchGroup (Writer**),db\db_impl.cc,"WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {
  assert(!writers_.empty());
  Writer* first = writers_.front();
  WriteBatch* result = first->batch;
  assert(result != NULL);

  size_t size = WriteBatchInternal::ByteSize(first->batch);

  // Allow the group to grow up to a maximum size, but if the
  // original write is small, limit the growth so we do not slow
  // down the small write too much.
  size_t max_size = 1 << 20;
  if (size <= (128<<10)) {
    max_size = size + (128<<10);
  }

  *last_writer = first;
  std::deque<Writer*>::iterator iter = writers_.begin();
  ++iter;  // Advance past ""first""
  for (; iter != writers_.end(); ++iter) {
    Writer* w = *iter;
    if (w->sync && !first->sync) {
      // Do not include a sync write into a batch handled by a non-sync write.
      break;
    }

    if (w->batch != NULL) {
      size += WriteBatchInternal::ByteSize(w->batch);
      if (size > max_size) {
        // Do not make batch too big
        break;
      }

  ...",1269.0,1314.0,1.0,1.0,46.0,47,14,47,11,0,18,9,13,6,2,,0,17,2,1,1,WriteBatch
666,13778,MakeRoomForWrite,1,leveldb.DBImpl.MakeRoomForWrite,Status leveldb.DBImpl.MakeRoomForWrite (bool),db\db_impl.cc,"Status DBImpl::MakeRoomForWrite(bool force) {
  mutex_.AssertHeld();
  assert(!writers_.empty());
  bool allow_delay = !force;
  Status s;
  while (true) {
    if (!bg_error_.ok()) {
      // Yield previous error
      s = bg_error_;
      break;
    } else if (
        allow_delay &&
        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_->SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &&
               (mem_->ApproximateMemoryUsage() <= option...",1318.0,1379.0,1.0,1.0,62.0,8,3,8,6,0,4,4,4,1,0,,0,4,2,1,1,Status
667,13980,GetProperty,1,leveldb.DBImpl.GetProperty,"bool leveldb.DBImpl.GetProperty (Slice,ANY*)",db\db_impl.cc,"bool DBImpl::GetProperty(const Slice& property, std::string* value) {
  value->clear();

  MutexLock l(&mutex_);
  Slice in = property;
  Slice prefix(""leveldb."");
  if (!in.starts_with(prefix)) return false;
  in.remove_prefix(prefix.size());

  if (in.starts_with(""num-files-at-level"")) {
    in.remove_prefix(strlen(""num-files-at-level""));
    uint64_t level;
    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
    if (!ok || level >= config::kNumLevels) {
      return false;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""%d"",
               versions_->NumLevelFiles(static_cast<int>(level)));
      *value = buf;
      return true;
    }
  } else if (in == ""stats"") {
    char buf[200];
    snprintf(buf, sizeof(buf),
             ""                               Compactions\n""
             ""Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n""
             ""--------------------------------------------------\n""
             );
    value->append(buf);
    ...",1381.0,1446.0,1.0,1.0,66.0,18,8,17,8,0,1,4,5,0,0,,0,1,4,2,2,bool
668,14245,GetApproximateSizes,1,leveldb.DBImpl.GetApproximateSizes,"void leveldb.DBImpl.GetApproximateSizes (Range*,int,uint64_t*)",db\db_impl.cc,"void DBImpl::GetApproximateSizes(
    const Range* range, int n,
    uint64_t* sizes) {
  // TODO(opt): better implementation
  Version* v;
  {
    MutexLock l(&mutex_);
    versions_->current()->Ref();
    v = versions_->current();
  }

  for (int i = 0; i < n; i++) {
    // Convert user_key into a corresponding internal key.
    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
    sizes[i] = (limit >= start ? limit - start : 0);
  }

  {
    MutexLock l(&mutex_);
    v->Unref();
  }
}",1448.0,1472.0,1.0,1.0,25.0,22,9,31,13,0,6,2,2,0,0,,0,6,6,3,3,void
669,14380,Open,1,leveldb.DB.Open,"Status leveldb.DB.Open (Options,ANY,DB**)",db\db_impl.cc,"Status DB::Open(const Options& options, const std::string& dbname,
                DB** dbptr) {
  *dbptr = NULL;

  DBImpl* impl = new DBImpl(options, dbname);
  impl->mutex_.Lock();
  VersionEdit edit;
  // Recover handles create_if_missing, error_if_exists
  bool save_manifest = false;
  Status s = impl->Recover(&edit, &save_manifest);
  if (s.ok() && impl->mem_ == NULL) {
    // Create new log and a corresponding memtable.
    uint64_t new_log_number = impl->versions_->NewFileNumber();
    WritableFile* lfile;
    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
                                     &lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl->logfile_ = lfile;
      impl->logfile_number_ = new_log_number;
      impl->log_ = new log::Writer(lfile);
      impl->mem_ = new MemTable(impl->internal_comparator_);
      impl->mem_->Ref();
    }
  }
  if (s.ok() && save_manifest) {
    edit.SetPrevLogNumber(0);  // No older logs ne...",1490.0,1532.0,1.0,1.0,43.0,58,9,55,13,0,15,6,7,1,0,,0,15,6,3,3,Status
670,14578,DestroyDB,1,leveldb.DestroyDB,"Status leveldb.DestroyDB (ANY,Options)",db\db_impl.cc,"Status DestroyDB(const std::string& dbname, const Options& options) {
  Env* env = options.env;
  std::vector<std::string> filenames;
  // Ignore error in case directory does not exist
  env->GetChildren(dbname, &filenames);
  if (filenames.empty()) {
    return Status::OK();
  }

  FileLock* lock;
  const std::string lockname = LockFileName(dbname);
  Status result = env->LockFile(lockname, &lock);
  if (result.ok()) {
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type != kDBLockFile) {  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }
    }
    env->UnlockFile(lock);  // Ignore error since state is already gone
    env->DeleteFile(lockname);
    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
  }
  return resul...",1537.0,1566.0,1.0,1.0,30.0,36,11,42,14,0,2,6,12,0,0,,0,1,4,2,2,Status
671,14987,Add,1,leveldb.DBImpl.CompactionStats.Add,void leveldb.DBImpl.CompactionStats.Add (CompactionStats),db\db_impl.hpp,"void Add(const CompactionStats& c) {
      this->micros += c.micros;
      this->bytes_read += c.bytes_read;
      this->bytes_written += c.bytes_written;
    }",185.0,189.0,5.0,5.0,5.0,9,3,3,1,0,6,1,1,0,0,,0,6,2,1,1,void
672,15024,user_comparator,1,leveldb.DBImpl.user_comparator,Comparator leveldb.DBImpl.user_comparator (),db\db_impl.hpp,"const Comparator* user_comparator() const {
    return internal_comparator_.user_comparator();
  }",197.0,199.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Comparator
673,15089,~DBIter,1,leveldb.anonymous_namespace_4.DBIter.~DBIter,ANY leveldb.anonymous_namespace_4.DBIter.~DBIter (),db\db_iter.cc,"virtual ~DBIter() {
    delete iter_;
  }",62.0,64.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
674,15095,Valid,1,leveldb.anonymous_namespace_5.DBIter.Valid,bool leveldb.anonymous_namespace_5.DBIter.Valid (),db\db_iter.cc,virtual bool Valid() const { return valid_; },65.0,65.0,3.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
675,15101,key,1,leveldb.anonymous_namespace_6.DBIter.key,Slice leveldb.anonymous_namespace_6.DBIter.key (),db\db_iter.cc,"virtual Slice key() const {
    assert(valid_);
    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
  }",66.0,69.0,3.0,3.0,4.0,3,3,5,5,0,5,1,1,0,0,,0,5,0,0,0,Slice
676,15118,value,1,leveldb.anonymous_namespace_7.DBIter.value,Slice leveldb.anonymous_namespace_7.DBIter.value (),db\db_iter.cc,"virtual Slice value() const {
    assert(valid_);
    return (direction_ == kForward) ? iter_->value() : saved_value_;
  }",70.0,73.0,3.0,3.0,4.0,3,3,5,5,0,5,1,1,0,0,,0,5,0,0,0,Slice
677,15134,status,1,leveldb.anonymous_namespace_8.DBIter.status,Status leveldb.anonymous_namespace_8.DBIter.status (),db\db_iter.cc,"virtual Status status() const {
    if (status_.ok()) {
      return iter_->status();
    } else {
      return status_;
    }
  }",74.0,80.0,3.0,3.0,7.0,2,2,2,2,0,2,2,2,1,0,,0,2,0,0,0,Status
678,15207,ClearSavedValue,1,leveldb.anonymous_namespace_18.DBIter.ClearSavedValue,void leveldb.anonymous_namespace_18.DBIter.ClearSavedValue (),db\db_iter.cc,"inline void ClearSavedValue() {
    if (saved_value_.capacity() > 1048576) {
      std::string empty;
      swap(empty, saved_value_);
    } else {
      saved_value_.clear();
    }
  }",97.0,104.0,3.0,3.0,8.0,2,2,3,2,0,2,2,2,1,0,,0,2,0,0,0,void
679,15229,RandomPeriod,1,leveldb.anonymous_namespace_19.DBIter.RandomPeriod,ssize_t leveldb.anonymous_namespace_19.DBIter.RandomPeriod (),db\db_iter.cc,"ssize_t RandomPeriod() {
    return rnd_.Uniform(2*config::kReadBytesPeriod);
  }",107.0,109.0,3.0,3.0,3.0,3,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,ssize_t
680,15264,ParseKey,1,leveldb.anonymous_namespace_22.DBIter.ParseKey,bool leveldb.anonymous_namespace_22.DBIter.ParseKey (ParsedInternalKey*),db\db_iter.cc,"inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
  Slice k = iter_->key();
  ssize_t n = k.size() + iter_->value().size();
  bytes_counter_ -= n;
  while (bytes_counter_ < 0) {
    bytes_counter_ += RandomPeriod();
    db_->RecordReadSample(k);
  }
  if (!ParseInternalKey(k, ikey)) {
    status_ = Status::Corruption(""corrupted internal key in DBIter"");
    return false;
  } else {
    return true;
  }
}",130.0,144.0,1.0,1.0,15.0,14,8,15,8,0,1,3,3,0,1,,0,1,2,1,1,bool
681,15386,FindNextUserEntry,1,leveldb.anonymous_namespace_26.DBIter.FindNextUserEntry,"void leveldb.anonymous_namespace_26.DBIter.FindNextUserEntry (bool,ANY*)",db\db_iter.cc,"void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
  // Loop until we hit an acceptable entry to yield
  assert(iter_->Valid());
  assert(direction_ == kForward);
  do {
    ParsedInternalKey ikey;
    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_->Next();
  } while (iter_->Valid());
  saved_key_.clear();
  valid_ = false;
}",173.0,203.0,1.0,1.0,31.0,18,8,20,12,0,4,7,11,3,0,,0,4,4,2,2,void
682,15540,FindPrevUserEntry,1,leveldb.anonymous_namespace_32.DBIter.FindPrevUserEntry,void leveldb.anonymous_namespace_32.DBIter.FindPrevUserEntry (),db\db_iter.cc,"void DBIter::FindPrevUserEntry() {
  assert(direction_ == kReverse);

  ValueType value_type = kTypeDeletion;
  if (iter_->Valid()) {
    do {
      ParsedInternalKey ikey;
      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_->Prev();
    } while (iter_->Valid())...",232.0,272.0,1.0,1.0,41.0,22,9,26,11,0,3,8,16,2,0,,0,3,0,0,0,void
683,15863,IncrementBy,1,leveldb.anonymous_namespace_5.AtomicCounter.IncrementBy,void leveldb.anonymous_namespace_5.AtomicCounter.IncrementBy (int),db\db_test.cc,"void IncrementBy(int count) {
    MutexLock l(&mu_);
    count_ += count;
  }",38.0,41.0,3.0,3.0,4.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
684,15875,Read,1,leveldb.anonymous_namespace_6.AtomicCounter.Read,int leveldb.anonymous_namespace_6.AtomicCounter.Read (),db\db_test.cc,"int Read() {
    MutexLock l(&mu_);
    return count_;
  }",42.0,45.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,int
685,15885,Reset,1,leveldb.anonymous_namespace_7.AtomicCounter.Reset,void leveldb.anonymous_namespace_7.AtomicCounter.Reset (),db\db_test.cc,"void Reset() {
    MutexLock l(&mu_);
    count_ = 0;
  }",46.0,49.0,3.0,3.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
686,15920,SpecialEnv,1,leveldb.SpecialEnv.SpecialEnv,ANY leveldb.SpecialEnv.SpecialEnv (Env*),db\db_test.cc,"explicit SpecialEnv(Env* base) : EnvWrapper(base) {
    delay_data_sync_.Release_Store(NULL);
    data_sync_error_.Release_Store(NULL);
    no_space_.Release_Store(NULL);
    non_writable_.Release_Store(NULL);
    count_random_reads_ = false;
    manifest_sync_error_.Release_Store(NULL);
    manifest_write_error_.Release_Store(NULL);
  }",81.0,89.0,3.0,3.0,9.0,7,2,13,8,0,7,1,1,0,0,,0,7,2,1,1,ANY
687,15958,NewWritableFile,1,leveldb.SpecialEnv.NewWritableFile,"Status leveldb.SpecialEnv.NewWritableFile (ANY,WritableFile**)",db\db_test.cc,"Status NewWritableFile(const std::string& f, WritableFile** r) {
    class DataFile : public WritableFile {
     private:
      SpecialEnv* env_;
      WritableFile* base_;

     public:
      DataFile(SpecialEnv* env, WritableFile* base)
          : env_(env),
            base_(base) {
      }
      ~DataFile() { delete base_; }
      Status Append(const Slice& data) {
        if (env_->no_space_.Acquire_Load() != NULL) {
          // Drop writes on the floor
          return Status::OK();
        } else {
          return base_->Append(data);
        }
      }
      Status Close() { return base_->Close(); }
      Status Flush() { return base_->Flush(); }
      Status Sync() {
        if (env_->data_sync_error_.Acquire_Load() != NULL) {
          return Status::IOError(""simulated data sync error"");
        }
        while (env_->delay_data_sync_.Acquire_Load() != NULL) {
          DelayMilliseconds(100);
        }
        return base_->Sync();
      }
    };
    class ManifestFile ...",91.0,162.0,3.0,3.0,72.0,15,7,15,7,0,2,4,5,1,1,,0,1,4,2,2,Status
688,16042,NewRandomAccessFile,1,leveldb.SpecialEnv.NewRandomAccessFile,"Status leveldb.SpecialEnv.NewRandomAccessFile (ANY,RandomAccessFile**)",db\db_test.cc,"Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    class CountingFile : public RandomAccessFile {
     private:
      RandomAccessFile* target_;
      AtomicCounter* counter_;
     public:
      CountingFile(RandomAccessFile* target, AtomicCounter* counter)
          : target_(target), counter_(counter) {
      }
      virtual ~CountingFile() { delete target_; }
      virtual Status Read(uint64_t offset, size_t n, Slice* result,
                          char* scratch) const {
        counter_->Increment();
        return target_->Read(offset, n, result, scratch);
      }
    };

    Status s = target()->NewRandomAccessFile(f, r);
    if (s.ok() && count_random_reads_) {
      *r = new CountingFile(*r, &random_read_counter_);
    }
    return s;
  }",164.0,186.0,3.0,3.0,23.0,9,7,10,6,0,2,2,2,1,0,,0,2,4,2,2,Status
689,16089,DBTest,1,leveldb.DBTest.DBTest,ANY leveldb.DBTest.DBTest (),db\db_test.cc,"DBTest() : option_config_(kDefault),
             env_(new SpecialEnv(Env::Default())) {
    filter_policy_ = NewBloomFilterPolicy(10);
    dbname_ = test::TmpDir() + ""/db_test"";
    DestroyDB(dbname_, Options());
    db_ = NULL;
    Reopen();
  }",210.0,217.0,3.0,3.0,8.0,5,3,6,5,0,4,1,1,0,0,,0,4,0,0,0,ANY
690,16112,~DBTest,1,leveldb.DBTest.~DBTest,ANY leveldb.DBTest.~DBTest (),db\db_test.cc,"~DBTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete env_;
    delete filter_policy_;
  }",219.0,224.0,3.0,3.0,6.0,3,1,4,4,0,4,1,1,0,0,,0,4,0,0,0,ANY
691,16125,ChangeOptions,1,leveldb.DBTest.ChangeOptions,bool leveldb.DBTest.ChangeOptions (),db\db_test.cc,"bool ChangeOptions() {
    option_config_++;
    if (option_config_ >= kEnd) {
      return false;
    } else {
      DestroyAndReopen();
      return true;
    }
  }",228.0,236.0,3.0,3.0,9.0,2,2,3,2,0,3,2,2,2,0,,0,3,0,0,0,bool
692,16143,CurrentOptions,1,leveldb.DBTest.CurrentOptions,Options leveldb.DBTest.CurrentOptions (),db\db_test.cc,"Options CurrentOptions() {
    Options options;
    options.reuse_logs = false;
    switch (option_config_) {
      case kReuse:
        options.reuse_logs = true;
        break;
      case kFilter:
        options.filter_policy = filter_policy_;
        break;
      case kUncompressed:
        options.compression = kNoCompression;
        break;
      default:
        break;
    }
    return options;
  }",239.0,256.0,3.0,3.0,18.0,8,2,11,7,0,9,6,2,1,0,,0,9,0,0,0,Options
693,16184,dbfull,1,leveldb.DBTest.dbfull,DBImpl leveldb.DBTest.dbfull (),db\db_test.cc,"DBImpl* dbfull() {
    return reinterpret_cast<DBImpl*>(db_);
  }",258.0,260.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DBImpl
694,16214,Close,1,leveldb.DBTest.Close,void leveldb.DBTest.Close (),db\db_test.cc,"void Close() {
    delete db_;
    db_ = NULL;
  }",266.0,269.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
695,16223,DestroyAndReopen,1,leveldb.DBTest.DestroyAndReopen,void leveldb.DBTest.DestroyAndReopen (Options*),db\db_test.cc,"void DestroyAndReopen(Options* options = NULL) {
    delete db_;
    db_ = NULL;
    DestroyDB(dbname_, Options());
    ASSERT_OK(TryReopen(options));
  }",271.0,276.0,3.0,4.0,6.0,5,3,8,5,0,3,1,1,0,0,,0,3,2,1,1,void
696,16253,TryReopen,1,leveldb.DBTest.TryReopen,Status leveldb.DBTest.TryReopen (Options*),db\db_test.cc,"Status TryReopen(Options* options) {
    delete db_;
    db_ = NULL;
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts = CurrentOptions();
      opts.create_if_missing = true;
    }
    last_options_ = opts;

    return DB::Open(opts, dbname_, &db_);
  }",278.0,291.0,3.0,3.0,14.0,8,6,13,7,0,5,2,2,0,0,,0,5,2,1,1,Status
697,16295,Put,1,leveldb.DBTest.Put,"Status leveldb.DBTest.Put (ANY,ANY)",db\db_test.cc,"Status Put(const std::string& k, const std::string& v) {
    return db_->Put(WriteOptions(), k, v);
  }",293.0,295.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
698,16309,Delete,1,leveldb.DBTest.Delete,Status leveldb.DBTest.Delete (ANY),db\db_test.cc,"Status Delete(const std::string& k) {
    return db_->Delete(WriteOptions(), k);
  }",297.0,299.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
699,16321,Get,1,leveldb.DBTest.Get,"string leveldb.DBTest.Get (ANY,Snapshot*)",db\db_test.cc,"std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {
    ReadOptions options;
    options.snapshot = snapshot;
    std::string result;
    Status s = db_->Get(options, k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",301.0,312.0,3.0,3.0,12.0,7,4,10,6,0,2,2,2,0,0,,0,2,4,2,2,string
700,16371,Contents,1,leveldb.DBTest.Contents,string leveldb.DBTest.Contents (),db\db_test.cc,"std::string Contents() {
    std::vector<std::string> forward;
    std::string result;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      std::string s = IterStatus(iter);
      result.push_back('(');
      result.append(s);
      result.push_back(')');
      forward.push_back(s);
    }

    // Check reverse iteration results are the reverse of forward results
    size_t matched = 0;
    for (iter->SeekToLast(); iter->Valid(); iter->Prev()) {
      ASSERT_LT(matched, forward.size());
      ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);
      matched++;
    }
    ASSERT_EQ(matched, forward.size());

    delete iter;
    return result;
  }",316.0,339.0,3.0,6.0,24.0,35,9,40,10,0,1,3,3,0,0,,0,1,0,0,0,string
701,16673,NumTableFilesAtLevel,1,leveldb.DBTest.NumTableFilesAtLevel,int leveldb.DBTest.NumTableFilesAtLevel (int),db\db_test.cc,"int NumTableFilesAtLevel(int level) {
    std::string property;
    ASSERT_TRUE(
        db_->GetProperty(""leveldb.num-files-at-level"" + NumberToString(level),
                         &property));
    return atoi(property.c_str());
  }",383.0,389.0,3.0,4.0,7.0,7,4,6,4,0,1,1,1,0,0,,0,1,2,1,1,int
702,16797,CountFiles,1,leveldb.DBTest.CountFiles,int leveldb.DBTest.CountFiles (),db\db_test.cc,"int CountFiles() {
    std::vector<std::string> files;
    env_->GetChildren(dbname_, &files);
    return static_cast<int>(files.size());
  }",416.0,420.0,3.0,3.0,5.0,8,6,7,4,0,2,1,1,0,0,,0,2,0,0,0,int
703,16824,Size,1,leveldb.DBTest.Size,"uint64_t leveldb.DBTest.Size (Slice,Slice)",db\db_test.cc,"uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",422.0,427.0,3.0,3.0,6.0,3,2,6,5,0,1,1,1,0,0,,0,1,4,2,2,uint64_t
704,16846,Compact,1,leveldb.DBTest.Compact,"void leveldb.DBTest.Compact (Slice,Slice)",db\db_test.cc,"void Compact(const Slice& start, const Slice& limit) {
    db_->CompactRange(&start, &limit);
  }",429.0,431.0,3.0,3.0,3.0,3,2,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
705,16948,DumpSSTableList,1,leveldb.DBTest.DumpSSTableList,string leveldb.DBTest.DumpSSTableList (),db\db_test.cc,"std::string DumpSSTableList() {
    std::string property;
    db_->GetProperty(""leveldb.sstables"", &property);
    return property;
  }",462.0,466.0,3.0,3.0,5.0,2,2,3,2,0,1,1,1,0,0,,0,1,0,0,0,string
706,17000,DeleteAnSSTFile,1,leveldb.DBTest.DeleteAnSSTFile,bool leveldb.DBTest.DeleteAnSSTFile (),db\db_test.cc,"bool DeleteAnSSTFile() {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)));
        return true;
      }
    }
    return false;
  }",478.0,490.0,3.0,4.0,13.0,21,9,22,10,0,4,3,4,0,0,,0,4,0,0,0,bool
707,17088,RenameLDBToSST,1,leveldb.DBTest.RenameLDBToSST,int leveldb.DBTest.RenameLDBToSST (),db\db_test.cc,"int RenameLDBToSST() {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    int files_renamed = 0;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        const std::string from = TableFileName(dbname_, number);
        const std::string to = SSTTableFileName(dbname_, number);
        ASSERT_OK(env_->RenameFile(from, to));
        files_renamed++;
      }
    }
    return files_renamed;
  }",493.0,508.0,3.0,4.0,16.0,25,10,31,13,0,5,3,4,0,0,,0,5,0,0,0,int
708,27495,MTThreadBody,1,leveldb.anonymous_namespace_17.MTThreadBody,void leveldb.anonymous_namespace_17.MTThreadBody (void*),db\db_test.cc,"static void MTThreadBody(void* arg) {
  MTThread* t = reinterpret_cast<MTThread*>(arg);
  int id = t->id;
  DB* db = t->state->test->db_;
  uintptr_t counter = 0;
  fprintf(stderr, ""... starting thread %d\n"", id);
  Random rnd(1000 + id);
  std::string value;
  char valbuf[1500];
  while (t->state->stop.Acquire_Load() == NULL) {
    t->state->counter[id].Release_Store(reinterpret_cast<void*>(counter));

    int key = rnd.Uniform(kNumKeys);
    char keybuf[20];
    snprintf(keybuf, sizeof(keybuf), ""%016d"", key);

    if (rnd.OneIn(2)) {
      // Write values of the form <key, my id, counter>.
      // We add some padding for force compactions.
      snprintf(valbuf, sizeof(valbuf), ""%d.%d.%-1000d"",
               key, id, static_cast<int>(counter));
      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));
    } else {
      // Read a value and verify that it matches the pattern written above.
      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);
      if (s.I...",1777.0,1820.0,1.0,6.0,44.0,35,10,39,13,0,5,3,4,1,0,,0,5,2,1,1,void
709,27995,Get,1,leveldb.ModelDB.Get,"Status leveldb.ModelDB.Get (ReadOptions,Slice,ANY*)",db\db_test.cc,"virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) {
    assert(false);      // Not implemented
    return Status::NotFound(key);
  }",1875.0,1879.0,3.0,3.0,5.0,1,1,2,2,0,1,1,1,0,1,,0,0,6,3,3,Status
710,28010,NewIterator,1,leveldb.ModelDB.NewIterator,Iterator leveldb.ModelDB.NewIterator (ReadOptions),db\db_test.cc,"virtual Iterator* NewIterator(const ReadOptions& options) {
    if (options.snapshot == NULL) {
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    } else {
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }
  }",1880.0,1890.0,3.0,3.0,11.0,7,5,8,6,0,2,2,2,1,0,,0,2,2,1,1,Iterator
711,28054,GetSnapshot,1,leveldb.ModelDB.GetSnapshot,Snapshot leveldb.ModelDB.GetSnapshot (),db\db_test.cc,"virtual const Snapshot* GetSnapshot() {
    ModelSnapshot* snapshot = new ModelSnapshot;
    snapshot->map_ = map_;
    return snapshot;
  }",1891.0,1895.0,3.0,3.0,5.0,4,3,5,3,0,2,1,1,0,0,,0,2,0,0,0,Snapshot
712,28079,Write,1,leveldb.ModelDB.Write,"Status leveldb.ModelDB.Write (WriteOptions,WriteBatch*)",db\db_test.cc,"virtual Status Write(const WriteOptions& options, WriteBatch* batch) {
    class Handler : public WriteBatch::Handler {
     public:
      KVMap* map_;
      virtual void Put(const Slice& key, const Slice& value) {
        (*map_)[key.ToString()] = value.ToString();
      }
      virtual void Delete(const Slice& key) {
        map_->erase(key.ToString());
      }
    };
    Handler handler;
    handler.map_ = &map_;
    return batch->Iterate(&handler);
  }",1900.0,1914.0,3.0,3.0,15.0,5,4,4,3,0,1,1,1,0,0,,0,1,4,2,2,Status
713,28144,~ModelIter,1,leveldb.ModelDB.ModelIter.~ModelIter,ANY leveldb.ModelDB.ModelIter.~ModelIter (),db\db_test.cc,"~ModelIter() {
      if (owned_) delete map_;
    }",1933.0,1935.0,5.0,5.0,3.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
714,28153,Valid,1,leveldb.ModelDB.ModelIter.Valid,bool leveldb.ModelDB.ModelIter.Valid (),db\db_test.cc,virtual bool Valid() const { return iter_ != map_->end(); },1936.0,1936.0,5.0,63.0,1.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
715,28164,SeekToFirst,1,leveldb.ModelDB.ModelIter.SeekToFirst,void leveldb.ModelDB.ModelIter.SeekToFirst (),db\db_test.cc,virtual void SeekToFirst() { iter_ = map_->begin(); },1937.0,1937.0,5.0,57.0,1.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
716,28174,SeekToLast,1,leveldb.ModelDB.ModelIter.SeekToLast,void leveldb.ModelDB.ModelIter.SeekToLast (),db\db_test.cc,"virtual void SeekToLast() {
      if (map_->empty()) {
        iter_ = map_->end();
      } else {
        iter_ = map_->find(map_->rbegin()->first);
      }
    }",1938.0,1944.0,5.0,5.0,7.0,3,2,3,2,0,3,2,2,1,0,,0,3,0,0,0,void
717,28204,Seek,1,leveldb.ModelDB.ModelIter.Seek,void leveldb.ModelDB.ModelIter.Seek (Slice),db\db_test.cc,"virtual void Seek(const Slice& k) {
      iter_ = map_->lower_bound(k.ToString());
    }",1945.0,1947.0,5.0,5.0,3.0,3,3,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
718,28219,Next,1,leveldb.ModelDB.ModelIter.Next,void leveldb.ModelDB.ModelIter.Next (),db\db_test.cc,virtual void Next() { ++iter_; },1948.0,1948.0,5.0,36.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
719,28225,Prev,1,leveldb.ModelDB.ModelIter.Prev,void leveldb.ModelDB.ModelIter.Prev (),db\db_test.cc,virtual void Prev() { --iter_; },1949.0,1949.0,5.0,36.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
720,28231,key,1,leveldb.ModelDB.ModelIter.key,Slice leveldb.ModelDB.ModelIter.key (),db\db_test.cc,virtual Slice key() const { return iter_->first; },1950.0,1950.0,5.0,54.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
721,28239,value,1,leveldb.ModelDB.ModelIter.value,Slice leveldb.ModelDB.ModelIter.value (),db\db_test.cc,virtual Slice value() const { return iter_->second; },1951.0,1951.0,5.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
722,28247,status,1,leveldb.ModelDB.ModelIter.status,Status leveldb.ModelDB.ModelIter.status (),db\db_test.cc,virtual Status status() const { return Status::OK(); },1952.0,1952.0,5.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
723,28299,CompareIterators,1,leveldb.CompareIterators,"bool leveldb.CompareIterators (int,DB*,DB*,Snapshot*,Snapshot*)",db\db_test.cc,"static bool CompareIterators(int step,
                             DB* model,
                             DB* db,
                             const Snapshot* model_snap,
                             const Snapshot* db_snap) {
  ReadOptions options;
  options.snapshot = model_snap;
  Iterator* miter = model->NewIterator(options);
  options.snapshot = db_snap;
  Iterator* dbiter = db->NewIterator(options);
  bool ok = true;
  int count = 0;
  for (miter->SeekToFirst(), dbiter->SeekToFirst();
       ok && miter->Valid() && dbiter->Valid();
       miter->Next(), dbiter->Next()) {
    count++;
    if (miter->key().compare(dbiter->key()) != 0) {
      fprintf(stderr, ""step %d: Key mismatch: '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(dbiter->key()).c_str());
      ok = false;
      break;
    }

    if (miter->value().compare(dbiter->value()) != 0) {
      fprintf(stderr, ""step %d: Value mismatch for key '%s': '%s' ...",1969.0,2015.0,1.0,1.0,47.0,46,8,47,11,0,2,7,9,0,0,,0,2,10,5,5,bool
724,28969,BM_LogAndApply,1,leveldb.BM_LogAndApply,"void leveldb.BM_LogAndApply (int,int)",db\db_test.cc,"void BM_LogAndApply(int iters, int num_base_files) {
  std::string dbname = test::TmpDir() + ""/leveldb_test_benchmark"";
  DestroyDB(dbname, Options());

  DB* db = NULL;
  Options opts;
  opts.create_if_missing = true;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  Env* env = Env::Default();

  port::Mutex mu;
  MutexLock l(&mu);

  InternalKeyComparator cmp(BytewiseComparator());
  Options options;
  VersionSet vset(dbname, &options, NULL, &cmp);
  bool save_manifest;
  ASSERT_OK(vset.Recover(&save_manifest));
  VersionEdit vbase;
  uint64_t fnum = 1;
  for (int i = 0; i < num_base_files; i++) {
    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);
    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);
    vbase.AddFile(2, fnum++, 1 /* file size */, start, limit);
  }
  ASSERT_OK(vset.LogAndApply(&vbase, &mu));

  uint64_t start_micros = env->NowMicros();

  for (int i = 0; i < iters; i++) {
    VersionEdit v...",2094.0,2144.0,1.0,2.0,51.0,64,14,84,33,0,1,3,3,0,0,,0,1,4,2,2,void
725,29342,AppendInternalKey,1,leveldb.AppendInternalKey,"void leveldb.AppendInternalKey (ANY*,ParsedInternalKey)",db\dbformat.cc,"void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {
  result->append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}",18.0,21.0,1.0,1.0,4.0,7,2,6,2,0,4,1,1,0,0,,0,4,4,2,2,void
726,29373,DebugString,1,leveldb.ParsedInternalKey.DebugString,string leveldb.ParsedInternalKey.DebugString (),db\dbformat.cc,"std::string ParsedInternalKey::DebugString() const {
  char buf[50];
  snprintf(buf, sizeof(buf), ""' @ %llu : %d"",
           (unsigned long long) sequence,
           int(type));
  std::string result = ""'"";
  result += EscapeString(user_key.ToString());
  result += buf;
  return result;
}",23.0,32.0,1.0,1.0,10.0,7,6,10,5,0,3,1,1,0,0,,0,3,0,0,0,string
727,29405,DebugString,1,leveldb.InternalKey.DebugString,string leveldb.InternalKey.DebugString (),db\dbformat.cc,"std::string InternalKey::DebugString() const {
  std::string result;
  ParsedInternalKey parsed;
  if (ParseInternalKey(rep_, &parsed)) {
    result = parsed.DebugString();
  } else {
    result = ""(bad)"";
    result.append(EscapeString(rep_));
  }
  return result;
}",34.0,44.0,1.0,1.0,11.0,3,3,5,3,0,1,2,2,1,0,,0,1,0,0,0,string
728,29442,Compare,1,leveldb.InternalKeyComparator.Compare,"int leveldb.InternalKeyComparator.Compare (Slice,Slice)",db\dbformat.hpp,"inline int InternalKeyComparator::Compare(
    const InternalKey& a, const InternalKey& b) const {
  return Compare(a.Encode(), b.Encode());
}",171.0,174.0,1.0,1.0,4.0,16,8,15,6,0,1,3,4,0,0,,0,1,4,2,2,int
729,29516,FindShortestSeparator,1,leveldb.InternalKeyComparator.FindShortestSeparator,"void leveldb.InternalKeyComparator.FindShortestSeparator (ANY*,Slice)",db\dbformat.cc,"void InternalKeyComparator::FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
  // Attempt to shorten the user portion of the key
  Slice user_start = ExtractUserKey(*start);
  Slice user_limit = ExtractUserKey(limit);
  std::string tmp(user_start.data(), user_start.size());
  user_comparator_->FindShortestSeparator(&tmp, user_limit);
  if (tmp.size() < user_start.size() &&
      user_comparator_->Compare(user_start, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*start, tmp) < 0);
    assert(this->Compare(tmp, limit) < 0);
    start->swap(tmp);
  }
}",68.0,85.0,1.0,1.0,18.0,20,7,23,8,0,2,2,2,1,0,,0,2,4,2,2,void
730,29600,FindShortSuccessor,1,leveldb.InternalKeyComparator.FindShortSuccessor,void leveldb.InternalKeyComparator.FindShortSuccessor (ANY*),db\dbformat.cc,"void InternalKeyComparator::FindShortSuccessor(std::string* key) const {
  Slice user_key = ExtractUserKey(*key);
  std::string tmp(user_key.data(), user_key.size());
  user_comparator_->FindShortSuccessor(&tmp);
  if (tmp.size() < user_key.size() &&
      user_comparator_->Compare(user_key, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*key, tmp) < 0);
    key->swap(tmp);
  }
}",87.0,99.0,1.0,1.0,13.0,17,7,18,6,0,2,2,2,1,0,,0,2,2,1,1,void
731,29668,Name,1,leveldb.InternalFilterPolicy.Name,const char* leveldb.InternalFilterPolicy.Name (),db\dbformat.cc,"const char* InternalFilterPolicy::Name() const {
  return user_policy_->Name();
}",101.0,103.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
732,29677,CreateFilter,1,leveldb.InternalFilterPolicy.CreateFilter,"void leveldb.InternalFilterPolicy.CreateFilter (Slice*,int,ANY*)",db\dbformat.cc,"void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,
                                        std::string* dst) const {
  // We rely on the fact that the code in table.cc does not mind us
  // adjusting keys[].
  Slice* mkey = const_cast<Slice*>(keys);
  for (int i = 0; i < n; i++) {
    mkey[i] = ExtractUserKey(keys[i]);
    // TODO(sanjay): Suppress dups?
  }
  user_policy_->CreateFilter(keys, n, dst);
}",105.0,115.0,1.0,1.0,11.0,8,5,13,6,0,1,2,2,0,0,,0,1,6,3,3,void
733,29717,KeyMayMatch,1,leveldb.InternalFilterPolicy.KeyMayMatch,"bool leveldb.InternalFilterPolicy.KeyMayMatch (Slice,Slice)",db\dbformat.cc,"bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {
  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);
}",117.0,119.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,bool
734,29731,LookupKey,1,leveldb.LookupKey.LookupKey,"ANY leveldb.LookupKey.LookupKey (Slice,SequenceNumber)",db\dbformat.cc,"LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
  size_t usize = user_key.size();
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed <= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}",121.0,138.0,1.0,1.0,18.0,15,6,26,10,0,5,2,2,1,0,,0,5,4,2,2,ANY
735,29893,InternalKeyEncodingLength,1,leveldb.InternalKeyEncodingLength,size_t leveldb.InternalKeyEncodingLength (ParsedInternalKey),db\dbformat.hpp,"inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {
  return key.user_key.size() + 8;
}",82.0,84.0,1.0,1.0,3.0,3,2,1,1,0,1,1,1,0,0,,0,1,2,1,1,size_t
736,30012,user_comparator,1,leveldb.InternalKeyComparator.user_comparator,Comparator leveldb.InternalKeyComparator.user_comparator (),db\dbformat.hpp,const Comparator* user_comparator() const { return user_comparator_; },125.0,125.0,3.0,72.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Comparator
737,30068,DecodeFrom,1,leveldb.InternalKey.DecodeFrom,void leveldb.InternalKey.DecodeFrom (Slice),db\dbformat.hpp,"void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",153.0,153.0,3.0,70.0,1.0,3,1,3,2,0,1,1,1,0,0,,0,1,2,1,1,void
738,30085,Encode,1,leveldb.InternalKey.Encode,Slice leveldb.InternalKey.Encode (),db\dbformat.hpp,"Slice Encode() const {
    assert(!rep_.empty());
    return rep_;
  }",154.0,157.0,3.0,3.0,4.0,2,2,2,1,0,2,1,1,0,0,,0,2,0,0,0,Slice
739,30097,user_key,1,leveldb.InternalKey.user_key,Slice leveldb.InternalKey.user_key (),db\dbformat.hpp,Slice user_key() const { return ExtractUserKey(rep_); },159.0,159.0,3.0,57.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
740,30104,SetFrom,1,leveldb.InternalKey.SetFrom,void leveldb.InternalKey.SetFrom (ParsedInternalKey),db\dbformat.hpp,"void SetFrom(const ParsedInternalKey& p) {
    rep_.clear();
    AppendInternalKey(&rep_, p);
  }",161.0,164.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,2,1,1,void
741,30117,Clear,1,leveldb.InternalKey.Clear,void leveldb.InternalKey.Clear (),db\dbformat.hpp,void Clear() { rep_.clear(); },166.0,166.0,3.0,32.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
742,30226,memtable_key,1,leveldb.LookupKey.memtable_key,Slice leveldb.LookupKey.memtable_key (),db\dbformat.hpp,"Slice memtable_key() const { return Slice(start_, end_ - start_); }",198.0,198.0,3.0,69.0,1.0,1,1,3,2,0,3,1,1,0,0,,0,3,0,0,0,Slice
743,30236,internal_key,1,leveldb.LookupKey.internal_key,Slice leveldb.LookupKey.internal_key (),db\dbformat.hpp,"Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }",201.0,201.0,3.0,71.0,1.0,1,1,3,2,0,3,1,1,0,0,,0,3,0,0,0,Slice
744,30246,user_key,1,leveldb.LookupKey.user_key,Slice leveldb.LookupKey.user_key (),db\dbformat.hpp,"Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",204.0,204.0,3.0,71.0,1.0,2,1,3,2,0,3,1,1,0,0,,0,3,0,0,0,Slice
745,30356,TestKey,1,leveldb.TestKey,"void leveldb.TestKey (ANY,uint64_t,ValueType)",db\dbformat_test.cc,"static void TestKey(const std::string& key,
                    uint64_t seq,
                    ValueType vt) {
  std::string encoded = IKey(key, seq, vt);

  Slice in(encoded);
  ParsedInternalKey decoded("""", 0, kTypeValue);

  ASSERT_TRUE(ParseInternalKey(in, &decoded));
  ASSERT_EQ(key, decoded.user_key.ToString());
  ASSERT_EQ(seq, decoded.sequence);
  ASSERT_EQ(vt, decoded.type);

  ASSERT_TRUE(!ParseInternalKey(Slice(""bar""), &decoded));
}",31.0,45.0,1.0,2.0,15.0,27,4,31,12,0,6,1,1,0,0,,0,6,6,3,3,void
746,31045,Corruption,1,leveldb.anonymous_namespace_3.CorruptionReporter.Corruption,"void leveldb.anonymous_namespace_3.CorruptionReporter.Corruption (size_t,Status)",db\dumpfile.cc,"virtual void Corruption(size_t bytes, const Status& status) {
    std::string r = ""corruption: "";
    AppendNumberTo(&r, bytes);
    r += "" bytes; "";
    r += status.ToString();
    r.push_back('\n');
    dst_->Append(r);
  }",39.0,46.0,3.0,3.0,8.0,7,5,9,4,0,1,1,1,0,0,,0,1,4,2,2,void
747,31078,PrintLogContents,1,leveldb.anonymous_namespace_4.PrintLogContents,"Status leveldb.anonymous_namespace_4.PrintLogContents (Env*,ANY,void,WritableFile*)",db\dumpfile.cc,"Status PrintLogContents(Env* env, const std::string& fname,
                        void (*func)(uint64_t, Slice, WritableFile*),
                        WritableFile* dst) {
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  CorruptionReporter reporter;
  reporter.dst_ = dst;
  log::Reader reader(file, &reporter, true, 0);
  Slice record;
  std::string scratch;
  while (reader.ReadRecord(&record, &scratch)) {
    (*func)(reader.LastRecordOffset(), record, dst);
  }
  delete file;
  return Status::OK();
}",50.0,68.0,1.0,1.0,19.0,15,7,19,11,0,2,3,3,0,0,,0,1,8,4,4,Status
748,31149,Put,1,leveldb.anonymous_namespace_6.WriteBatchItemPrinter.Put,"void leveldb.anonymous_namespace_6.WriteBatchItemPrinter.Put (Slice,Slice)",db\dumpfile.cc,"virtual void Put(const Slice& key, const Slice& value) {
    std::string r = ""  put '"";
    AppendEscapedStringTo(&r, key);
    r += ""' '"";
    AppendEscapedStringTo(&r, value);
    r += ""'\n"";
    dst_->Append(r);
  }",74.0,81.0,3.0,3.0,8.0,6,4,9,4,0,1,1,1,0,0,,0,1,4,2,2,void
749,31178,Delete,1,leveldb.anonymous_namespace_7.WriteBatchItemPrinter.Delete,void leveldb.anonymous_namespace_7.WriteBatchItemPrinter.Delete (Slice),db\dumpfile.cc,"virtual void Delete(const Slice& key) {
    std::string r = ""  del '"";
    AppendEscapedStringTo(&r, key);
    r += ""'\n"";
    dst_->Append(r);
  }",82.0,87.0,3.0,3.0,6.0,4,4,6,3,0,1,1,1,0,0,,0,1,2,1,1,void
750,31199,WriteBatchPrinter,1,leveldb.anonymous_namespace_8.WriteBatchPrinter,"void leveldb.anonymous_namespace_8.WriteBatchPrinter (uint64_t,Slice,WritableFile*)",db\dumpfile.cc,"static void WriteBatchPrinter(uint64_t pos, Slice record, WritableFile* dst) {
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  if (record.size() < 12) {
    r += ""log record length "";
    AppendNumberTo(&r, record.size());
    r += "" is too small\n"";
    dst->Append(r);
    return;
  }
  WriteBatch batch;
  WriteBatchInternal::SetContents(&batch, record);
  r += ""sequence "";
  AppendNumberTo(&r, WriteBatchInternal::Sequence(&batch));
  r.push_back('\n');
  dst->Append(r);
  WriteBatchItemPrinter batch_item_printer;
  batch_item_printer.dst_ = dst;
  Status s = batch.Iterate(&batch_item_printer);
  if (!s.ok()) {
    dst->Append(""  error: "" + s.ToString() + ""\n"");
  }
}",93.0,116.0,1.0,1.0,24.0,29,8,29,8,0,1,3,3,0,0,,0,1,6,3,3,void
751,31392,DumpTable,1,leveldb.anonymous_namespace_16.DumpTable,"Status leveldb.anonymous_namespace_16.DumpTable (Env*,ANY,WritableFile*)",db\dumpfile.cc,"Status DumpTable(Env* env, const std::string& fname, WritableFile* dst) {
  uint64_t file_size;
  RandomAccessFile* file = NULL;
  Table* table = NULL;
  Status s = env->GetFileSize(fname, &file_size);
  if (s.ok()) {
    s = env->NewRandomAccessFile(fname, &file);
  }
  if (s.ok()) {
    // We use the default comparator, which may or may not match the
    // comparator used in this database. However this should not cause
    // problems since we only use Table operations that do not require
    // any comparisons.  In particular, we do not call Seek or Prev.
    s = Table::Open(Options(), file, file_size, &table);
  }
  if (!s.ok()) {
    delete table;
    delete file;
    return s;
  }

  ReadOptions ro;
  ro.fill_cache = false;
  Iterator* iter = table->NewIterator(ro);
  std::string r;
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    r.clear();
    ParsedInternalKey key;
    if (!ParseInternalKey(iter->key(), &key)) {
      r = ""badkey '"";
      AppendEscapedString...",143.0,206.0,1.0,1.0,64.0,47,8,50,14,0,2,7,8,0,0,,0,1,6,3,3,Status
752,31643,DumpFile,1,leveldb.DumpFile,"Status leveldb.DumpFile (Env*,ANY,WritableFile*)",db\dumpfile.cc,"Status DumpFile(Env* env, const std::string& fname, WritableFile* dst) {
  FileType ftype;
  if (!GuessType(fname, &ftype)) {
    return Status::InvalidArgument(fname + "": unknown file type"");
  }
  switch (ftype) {
    case kLogFile:         return DumpLog(env, fname, dst);
    case kDescriptorFile:  return DumpDescriptor(env, fname, dst);
    case kTableFile:       return DumpTable(env, fname, dst);
    default:
      break;
  }
  return Status::InvalidArgument(fname + "": not a dump-able file type"");
}",210.0,223.0,1.0,1.0,14.0,6,4,19,8,0,2,4,3,0,2,,0,0,6,3,3,Status
753,31783,SyncDir,1,leveldb.anonymous_namespace_2.SyncDir,Status leveldb.anonymous_namespace_2.SyncDir (ANY),db\fault_injection_test.cc,"Status SyncDir(const std::string& dir) {
  // As this is a test it isn't required to *actually* sync this directory.
  return Status::OK();
}",46.0,49.0,1.0,1.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,Status
754,31793,Truncate,1,leveldb.anonymous_namespace_3.Truncate,"Status leveldb.anonymous_namespace_3.Truncate (ANY,uint64_t)",db\fault_injection_test.cc,"Status Truncate(const std::string& filename, uint64_t length) {
  leveldb::Env* env = leveldb::Env::Default();

  SequentialFile* orig_file;
  Status s = env->NewSequentialFile(filename, &orig_file);
  if (!s.ok())
    return s;

  char* scratch = new char[length];
  leveldb::Slice result;
  s = orig_file->Read(length, &result, scratch);
  delete orig_file;
  if (s.ok()) {
    std::string tmp_name = GetDirName(filename) + ""/truncate.tmp"";
    WritableFile* tmp_file;
    s = env->NewWritableFile(tmp_name, &tmp_file);
    if (s.ok()) {
      s = tmp_file->Append(result);
      delete tmp_file;
      if (s.ok()) {
        s = env->RenameFile(tmp_name, filename);
      } else {
        env->DeleteFile(tmp_name);
      }
    }
  }

  delete[] scratch;

  return s;
}",52.0,82.0,1.0,1.0,31.0,28,8,36,12,0,1,5,8,0,0,,0,1,4,2,2,Status
755,31923,IsFullySynced,1,leveldb.anonymous_namespace_8.FileState.IsFullySynced,bool leveldb.anonymous_namespace_8.FileState.IsFullySynced (),db\fault_injection_test.cc,bool IsFullySynced() const { return pos_ <= 0 || pos_ == pos_at_last_sync_; },98.0,98.0,3.0,79.0,1.0,3,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,bool
756,32039,IsFilesystemActive,1,leveldb.FaultInjectionTestEnv.IsFilesystemActive,bool leveldb.FaultInjectionTestEnv.IsFilesystemActive (),db\fault_injection_test.cc,bool IsFilesystemActive() const { return filesystem_active_; },149.0,149.0,3.0,64.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
757,32045,SetFilesystemActive,1,leveldb.FaultInjectionTestEnv.SetFilesystemActive,void leveldb.FaultInjectionTestEnv.SetFilesystemActive (bool),db\fault_injection_test.cc,void SetFilesystemActive(bool active) { filesystem_active_ = active; },150.0,150.0,3.0,72.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
758,32713,FaultInjectionTest,1,leveldb.FaultInjectionTest.FaultInjectionTest,ANY leveldb.FaultInjectionTest.FaultInjectionTest (),db\fault_injection_test.cc,"FaultInjectionTest()
      : env_(new FaultInjectionTestEnv),
        tiny_cache_(NewLRUCache(100)),
        db_(NULL) {
    dbname_ = test::TmpDir() + ""/fault_test"";
    DestroyDB(dbname_, Options());  // Destroy any db from earlier run
    options_.reuse_logs = true;
    options_.env = env_;
    options_.paranoid_checks = true;
    options_.block_cache = tiny_cache_;
    options_.create_if_missing = true;
  }",370.0,381.0,3.0,3.0,12.0,13,3,10,5,0,9,1,1,0,0,,0,9,0,0,0,ANY
759,32753,~FaultInjectionTest,1,leveldb.FaultInjectionTest.~FaultInjectionTest,ANY leveldb.FaultInjectionTest.~FaultInjectionTest (),db\fault_injection_test.cc,"~FaultInjectionTest() {
    CloseDB();
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
    delete env_;
  }",383.0,388.0,3.0,3.0,6.0,2,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
760,32765,ReuseLogs,1,leveldb.FaultInjectionTest.ReuseLogs,void leveldb.FaultInjectionTest.ReuseLogs (bool),db\fault_injection_test.cc,"void ReuseLogs(bool reuse) {
    options_.reuse_logs = reuse;
  }",390.0,392.0,3.0,3.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
761,32775,Build,1,leveldb.FaultInjectionTest.Build,"void leveldb.FaultInjectionTest.Build (int,int)",db\fault_injection_test.cc,"void Build(int start_idx, int num_vals) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = start_idx; i < start_idx + num_vals; i++) {
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",394.0,404.0,3.0,6.0,11.0,13,6,18,10,0,1,2,2,0,0,,0,1,4,2,2,void
762,32839,ReadValue,1,leveldb.FaultInjectionTest.ReadValue,"Status leveldb.FaultInjectionTest.ReadValue (int,ANY*)",db\fault_injection_test.cc,"Status ReadValue(int i, std::string* val) const {
    std::string key_space, value_space;
    Slice key = Key(i, &key_space);
    Value(i, &value_space);
    ReadOptions options;
    return db_->Get(options, key, val);
  }",406.0,412.0,3.0,3.0,7.0,4,3,9,7,0,1,1,1,0,0,,0,1,4,2,2,Status
763,32867,Verify,1,leveldb.FaultInjectionTest.Verify,"Status leveldb.FaultInjectionTest.Verify (int,int,ExpectedVerifResult)",db\fault_injection_test.cc,"Status Verify(int start_idx, int num_vals,
                ExpectedVerifResult expected) const {
    std::string val;
    std::string value_space;
    Status s;
    for (int i = start_idx; i < start_idx + num_vals && s.ok(); i++) {
      Value(i, &value_space);
      s = ReadValue(i, &val);
      if (expected == VAL_EXPECT_NO_ERROR) {
        if (s.ok()) {
          ASSERT_EQ(value_space, val);
        }
      } else if (s.ok()) {
        fprintf(stderr, ""Expected an error at %d, but was OK\n"", i);
        s = Status::IOError(dbname_, ""Expected value error:"");
      } else {
        s = Status::OK();  // An expected error
      }
    }
    return s;
  }",414.0,434.0,3.0,10.0,21.0,13,7,21,9,0,1,4,7,1,0,,0,1,6,3,3,Status
764,33006,OpenDB,1,leveldb.FaultInjectionTest.OpenDB,Status leveldb.FaultInjectionTest.OpenDB (),db\fault_injection_test.cc,"Status OpenDB() {
    delete db_;
    db_ = NULL;
    env_->ResetState();
    return DB::Open(options_, dbname_, &db_);
  }",450.0,455.0,3.0,3.0,6.0,5,5,8,6,0,6,1,1,0,0,,0,6,0,0,0,Status
765,33028,CloseDB,1,leveldb.FaultInjectionTest.CloseDB,void leveldb.FaultInjectionTest.CloseDB (),db\fault_injection_test.cc,"void CloseDB() {
    delete db_;
    db_ = NULL;
  }",457.0,460.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
766,33037,DeleteAllData,1,leveldb.FaultInjectionTest.DeleteAllData,void leveldb.FaultInjectionTest.DeleteAllData (),db\fault_injection_test.cc,"void DeleteAllData() {
    Iterator* iter = db_->NewIterator(ReadOptions());
    WriteOptions options;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      ASSERT_OK(db_->Delete(WriteOptions(), iter->key()));
    }

    delete iter;
  }",462.0,470.0,3.0,6.0,9.0,10,4,9,3,0,2,2,2,0,0,,0,2,0,0,0,void
767,33089,ResetDBState,1,leveldb.FaultInjectionTest.ResetDBState,void leveldb.FaultInjectionTest.ResetDBState (ResetMethod),db\fault_injection_test.cc,"void ResetDBState(ResetMethod reset_method) {
    switch (reset_method) {
      case RESET_DROP_UNSYNCED_DATA:
        ASSERT_OK(env_->DropUnsyncedFileData());
        break;
      case RESET_DELETE_UNSYNCED_FILES:
        ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync());
        break;
      default:
        assert(false);
    }
  }",472.0,483.0,3.0,8.0,12.0,10,2,11,6,0,6,4,2,0,0,,0,6,2,1,1,void
768,33148,PartialCompactTestPreFault,1,leveldb.FaultInjectionTest.PartialCompactTestPreFault,"void leveldb.FaultInjectionTest.PartialCompactTestPreFault (int,int)",db\fault_injection_test.cc,"void PartialCompactTestPreFault(int num_pre_sync, int num_post_sync) {
    DeleteAllData();
    Build(0, num_pre_sync);
    db_->CompactRange(NULL, NULL);
    Build(num_pre_sync, num_post_sync);
  }",485.0,490.0,3.0,3.0,6.0,1,1,6,4,0,1,1,1,0,0,,0,1,4,2,2,void
769,33167,PartialCompactTestReopenWithFault,1,leveldb.FaultInjectionTest.PartialCompactTestReopenWithFault,"void leveldb.FaultInjectionTest.PartialCompactTestReopenWithFault (ResetMethod,int,int)",db\fault_injection_test.cc,"void PartialCompactTestReopenWithFault(ResetMethod reset_method,
                                         int num_pre_sync,
                                         int num_post_sync) {
    env_->SetFilesystemActive(false);
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
    ASSERT_OK(Verify(0, num_pre_sync, FaultInjectionTest::VAL_EXPECT_NO_ERROR));
    ASSERT_OK(Verify(num_pre_sync, num_post_sync, FaultInjectionTest::VAL_EXPECT_ERROR));
  }",492.0,501.0,3.0,4.0,10.0,12,2,13,7,0,3,1,1,0,0,,0,3,6,3,3,void
770,33262,DoTest,1,leveldb.FaultInjectionTest.DoTest,void leveldb.FaultInjectionTest.DoTest (),db\fault_injection_test.cc,"void DoTest() {
    Random rnd(0);
    ASSERT_OK(OpenDB());
    for (size_t idx = 0; idx < kNumIterations; idx++) {
      int num_pre_sync = rnd.Uniform(kMaxNumValues);
      int num_post_sync = rnd.Uniform(kMaxNumValues);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      PartialCompactTestReopenWithFault(RESET_DROP_UNSYNCED_DATA,
                                        num_pre_sync,
                                        num_post_sync);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DROP_UNSYNCED_DATA);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      // No new files created so we expect all values since no files will be
      // dropped.
      PartialCompactTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES,
                                        num_pre_sync + num_post_sync,
                                        0);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES);
    }
  }",512.0,537.0,3.0,4.0,26.0,10,4,23,9,0,4,2,2,0,0,,0,4,0,0,0,void
771,34788,Append,1,leveldb.anonymous_namespace_2.StdoutPrinter.Append,Status leveldb.anonymous_namespace_2.StdoutPrinter.Append (Slice),db\leveldbutil.cc,"virtual Status Append(const Slice& data) {
    fwrite(data.data(), 1, data.size(), stdout);
    return Status::OK();
  }",15.0,18.0,3.0,3.0,4.0,3,1,4,3,0,1,1,1,0,0,,0,0,2,1,1,Status
772,34809,Close,1,leveldb.anonymous_namespace_3.StdoutPrinter.Close,Status leveldb.anonymous_namespace_3.StdoutPrinter.Close (),db\leveldbutil.cc,virtual Status Close() { return Status::OK(); },19.0,19.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
773,34818,Flush,1,leveldb.anonymous_namespace_4.StdoutPrinter.Flush,Status leveldb.anonymous_namespace_4.StdoutPrinter.Flush (),db\leveldbutil.cc,virtual Status Flush() { return Status::OK(); },20.0,20.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
774,34827,Sync,1,leveldb.anonymous_namespace_5.StdoutPrinter.Sync,Status leveldb.anonymous_namespace_5.StdoutPrinter.Sync (),db\leveldbutil.cc,virtual Status Sync() { return Status::OK(); },21.0,21.0,3.0,48.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
775,35041,~Reader,1,leveldb.log.Reader.~Reader,ANY leveldb.log.Reader.~Reader (),db\log_reader.cc,"Reader::~Reader() {
  delete[] backing_store_;
}",32.0,34.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
776,35047,SkipToInitialBlock,1,leveldb.log.Reader.SkipToInitialBlock,bool leveldb.log.Reader.SkipToInitialBlock (),db\log_reader.cc,"bool Reader::SkipToInitialBlock() {
  size_t offset_in_block = initial_offset_ % kBlockSize;
  uint64_t block_start_location = initial_offset_ - offset_in_block;

  // Don't search a block if we'd be in the trailer
  if (offset_in_block > kBlockSize - 6) {
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  // Skip to start of first block that can contain the initial record
  if (block_start_location > 0) {
    Status skip_status = file_->Skip(block_start_location);
    if (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status);
      return false;
    }
  }

  return true;
}",36.0,58.0,1.0,1.0,23.0,14,8,20,7,0,4,4,5,0,0,,0,4,0,0,0,bool
777,35106,ReadRecord,1,leveldb.log.Reader.ReadRecord,"bool leveldb.log.Reader.ReadRecord (Slice*,ANY*)",db\log_reader.cc,"bool Reader::ReadRecord(Slice* record, std::string* scratch) {
  if (last_record_offset_ < initial_offset_) {
    if (!SkipToInitialBlock()) {
      return false;
    }
  }

  scratch->clear();
  record->clear();
  bool in_fragmented_record = false;
  // Record offset of the logical record that we're reading
  // 0 is a dummy value to make compilers happy
  uint64_t prospective_record_offset = 0;

  Slice fragment;
  while (true) {
    const unsigned int record_type = ReadPhysicalRecord(&fragment);

    // ReadPhysicalRecord may have only had an empty trailer remaining in its
    // internal buffer. Calculate the offset of the next physical record now
    // that it has returned, properly accounting for its header size.
    uint64_t physical_record_offset =
        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size();

    if (resyncing_) {
      if (record_type == kMiddleType) {
        continue;
      } else if (record_type == kLastType) {
        resyncing_ = fa...",60.0,182.0,1.0,1.0,123.0,44,12,61,20,0,8,21,38,3,0,,0,8,4,2,2,bool
778,35400,LastRecordOffset,1,leveldb.log.Reader.LastRecordOffset,uint64_t leveldb.log.Reader.LastRecordOffset (),db\log_reader.cc,"uint64_t Reader::LastRecordOffset() {
  return last_record_offset_;
}",184.0,186.0,1.0,1.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
779,35406,ReportCorruption,1,leveldb.log.Reader.ReportCorruption,"void leveldb.log.Reader.ReportCorruption (uint64_t,char*)",db\log_reader.cc,"void Reader::ReportCorruption(uint64_t bytes, const char* reason) {
  ReportDrop(bytes, Status::Corruption(reason));
}",188.0,190.0,1.0,1.0,3.0,1,1,3,3,0,1,1,1,0,1,,0,0,4,2,2,void
780,35419,ReportDrop,1,leveldb.log.Reader.ReportDrop,"void leveldb.log.Reader.ReportDrop (uint64_t,Status)",db\log_reader.cc,"void Reader::ReportDrop(uint64_t bytes, const Status& reason) {
  if (reporter_ != NULL &&
      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {
    reporter_->Corruption(static_cast<size_t>(bytes), reason);
  }
}",192.0,197.0,1.0,1.0,6.0,8,7,9,7,0,5,2,2,4,0,,0,5,4,2,2,void
781,35449,ReadPhysicalRecord,1,leveldb.log.Reader.ReadPhysicalRecord,unsigned int leveldb.log.Reader.ReadPhysicalRecord (Slice*),db\log_reader.cc,"unsigned int Reader::ReadPhysicalRecord(Slice* result) {
  while (true) {
    if (buffer_.size() < kHeaderSize) {
      if (!eof_) {
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      } else {
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }
    }

    // Parse the header
    const char* header = buffer_.data()...",199.0,281.0,1.0,1.0,83.0,60,19,73,23,0,29,12,25,8,0,,0,29,2,1,1,unsigned int
782,35894,Close,1,leveldb.log.LogTest.StringDest.Close,Status leveldb.log.LogTest.StringDest.Close (),db\log_test.cc,virtual Status Close() { return Status::OK(); },45.0,45.0,5.0,51.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
783,35903,Flush,1,leveldb.log.LogTest.StringDest.Flush,Status leveldb.log.LogTest.StringDest.Flush (),db\log_test.cc,virtual Status Flush() { return Status::OK(); },46.0,46.0,5.0,51.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
784,35912,Sync,1,leveldb.log.LogTest.StringDest.Sync,Status leveldb.log.LogTest.StringDest.Sync (),db\log_test.cc,virtual Status Sync() { return Status::OK(); },47.0,47.0,5.0,50.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
785,35921,Append,1,leveldb.log.LogTest.StringDest.Append,Status leveldb.log.LogTest.StringDest.Append (Slice),db\log_test.cc,"virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }",48.0,51.0,5.0,5.0,4.0,4,1,4,3,0,2,1,1,0,0,,0,1,2,1,1,Status
786,35951,Read,1,leveldb.log.LogTest.StringSource.Read,"Status leveldb.log.LogTest.StringSource.Read (size_t,Slice*,char*)",db\log_test.cc,"virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
      }
      *result = Slice(contents_.data(), n);
      contents_.remove_prefix(n);
      return Status::OK();
    }",61.0,77.0,5.0,6.0,17.0,19,6,19,7,0,12,3,3,2,1,,0,10,6,3,3,Status
787,36029,Skip,1,leveldb.log.LogTest.StringSource.Skip,Status leveldb.log.LogTest.StringSource.Skip (uint64_t),db\log_test.cc,"virtual Status Skip(uint64_t n) {
      if (n > contents_.size()) {
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }

      contents_.remove_prefix(n);

      return Status::OK();
    }",79.0,88.0,5.0,5.0,10.0,6,2,7,3,0,5,2,2,1,1,,0,3,2,1,1,Status
788,36069,Corruption,1,leveldb.log.LogTest.ReportCollector.Corruption,"void leveldb.log.LogTest.ReportCollector.Corruption (size_t,Status)",db\log_test.cc,"virtual void Corruption(size_t bytes, const Status& status) {
      dropped_bytes_ += bytes;
      message_.append(status.ToString());
    }",97.0,100.0,5.0,5.0,4.0,3,2,4,4,0,2,1,1,0,0,,0,2,4,2,2,void
789,36099,~LogTest,1,leveldb.log.LogTest.~LogTest,ANY leveldb.log.LogTest.~LogTest (),db\log_test.cc,"~LogTest() {
    delete writer_;
    delete reader_;
  }",122.0,125.0,3.0,3.0,4.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
790,36107,ReopenForAppend,1,leveldb.log.LogTest.ReopenForAppend,void leveldb.log.LogTest.ReopenForAppend (),db\log_test.cc,"void ReopenForAppend() {
    delete writer_;
    writer_ = new Writer(&dest_, dest_.contents_.size());
  }",127.0,130.0,3.0,3.0,4.0,6,5,5,3,0,5,1,1,0,0,,0,5,0,0,0,void
791,36125,Write,1,leveldb.log.LogTest.Write,void leveldb.log.LogTest.Write (ANY),db\log_test.cc,"void Write(const std::string& msg) {
    ASSERT_TRUE(!reading_) << ""Write() after starting to read"";
    writer_->AddRecord(Slice(msg));
  }",132.0,135.0,3.0,4.0,4.0,7,4,6,4,0,3,1,1,0,0,,0,3,2,1,1,void
792,36156,WrittenBytes,1,leveldb.log.LogTest.WrittenBytes,size_t leveldb.log.LogTest.WrittenBytes (),db\log_test.cc,"size_t WrittenBytes() const {
    return dest_.contents_.size();
  }",137.0,139.0,3.0,3.0,3.0,2,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
793,36167,Read,1,leveldb.log.LogTest.Read,string leveldb.log.LogTest.Read (),db\log_test.cc,"std::string Read() {
    if (!reading_) {
      reading_ = true;
      source_.contents_ = Slice(dest_.contents_);
    }
    std::string scratch;
    Slice record;
    if (reader_->ReadRecord(&record, &scratch)) {
      return record.ToString();
    } else {
      return ""EOF"";
    }
  }",141.0,153.0,3.0,3.0,13.0,9,5,8,6,0,7,3,3,2,0,,0,7,0,0,0,string
794,36207,IncrementByte,1,leveldb.log.LogTest.IncrementByte,"void leveldb.log.LogTest.IncrementByte (int,int)",db\log_test.cc,"void IncrementByte(int offset, int delta) {
    dest_.contents_[offset] += delta;
  }",155.0,157.0,3.0,3.0,3.0,3,3,3,3,0,2,1,1,0,0,,0,2,4,2,2,void
795,36220,SetByte,1,leveldb.log.LogTest.SetByte,"void leveldb.log.LogTest.SetByte (int,char)",db\log_test.cc,"void SetByte(int offset, char new_byte) {
    dest_.contents_[offset] = new_byte;
  }",159.0,161.0,3.0,3.0,3.0,3,3,3,3,0,2,1,1,0,0,,0,2,4,2,2,void
796,36233,ShrinkSize,1,leveldb.log.LogTest.ShrinkSize,void leveldb.log.LogTest.ShrinkSize (int),db\log_test.cc,"void ShrinkSize(int bytes) {
    dest_.contents_.resize(dest_.contents_.size() - bytes);
  }",163.0,165.0,3.0,3.0,3.0,5,2,3,2,0,4,1,1,0,0,,0,4,2,1,1,void
797,36252,FixChecksum,1,leveldb.log.LogTest.FixChecksum,"void leveldb.log.LogTest.FixChecksum (int,int)",db\log_test.cc,"void FixChecksum(int header_offset, int len) {
    // Compute crc of type/len/data
    uint32_t crc = crc32c::Value(&dest_.contents_[header_offset+6], 1 + len);
    crc = crc32c::Mask(crc);
    EncodeFixed32(&dest_.contents_[header_offset], crc);
  }",167.0,172.0,3.0,3.0,6.0,12,5,11,5,0,4,1,1,0,0,,0,4,4,2,2,void
798,36291,ForceError,1,leveldb.log.LogTest.ForceError,void leveldb.log.LogTest.ForceError (),db\log_test.cc,"void ForceError() {
    source_.force_error_ = true;
  }",174.0,176.0,3.0,3.0,3.0,2,2,1,1,0,2,1,1,0,0,,0,2,0,0,0,void
799,36300,DroppedBytes,1,leveldb.log.LogTest.DroppedBytes,size_t leveldb.log.LogTest.DroppedBytes (),db\log_test.cc,"size_t DroppedBytes() const {
    return report_.dropped_bytes_;
  }",178.0,180.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
800,36308,ReportMessage,1,leveldb.log.LogTest.ReportMessage,string leveldb.log.LogTest.ReportMessage (),db\log_test.cc,"std::string ReportMessage() const {
    return report_.message_;
  }",182.0,184.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,string
801,36316,MatchError,1,leveldb.log.LogTest.MatchError,string leveldb.log.LogTest.MatchError (ANY),db\log_test.cc,"std::string MatchError(const std::string& msg) const {
    if (report_.message_.find(msg) == std::string::npos) {
      return report_.message_;
    } else {
      return ""OK"";
    }
  }",187.0,193.0,3.0,3.0,7.0,6,2,5,4,0,2,2,2,1,0,,0,2,2,1,1,string
802,36344,WriteInitialOffsetLog,1,leveldb.log.LogTest.WriteInitialOffsetLog,void leveldb.log.LogTest.WriteInitialOffsetLog (),db\log_test.cc,"void WriteInitialOffsetLog() {
    for (int i = 0; i < num_initial_offset_records_; i++) {
      std::string record(initial_offset_record_sizes_[i],
                         static_cast<char>('a' + i));
      Write(record);
    }
  }",195.0,201.0,3.0,3.0,7.0,5,5,7,4,0,2,2,2,1,0,,0,2,0,0,0,void
803,36372,StartReadingAt,1,leveldb.log.LogTest.StartReadingAt,void leveldb.log.LogTest.StartReadingAt (uint64_t),db\log_test.cc,"void StartReadingAt(uint64_t initial_offset) {
    delete reader_;
    reader_ = new Reader(&source_, &report_, true/*checksum*/, initial_offset);
  }",203.0,206.0,3.0,3.0,4.0,5,4,6,5,0,4,1,1,0,0,,0,4,2,1,1,void
804,36389,CheckOffsetPastEndReturnsNoRecords,1,leveldb.log.LogTest.CheckOffsetPastEndReturnsNoRecords,void leveldb.log.LogTest.CheckOffsetPastEndReturnsNoRecords (uint64_t),db\log_test.cc,"void CheckOffsetPastEndReturnsNoRecords(uint64_t offset_past_end) {
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       WrittenBytes() + offset_past_end);
    Slice record;
    std::string scratch;
    ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch));
    delete offset_reader;
  }",208.0,218.0,3.0,4.0,11.0,17,8,14,10,0,7,1,1,0,0,,0,7,2,1,1,void
805,36446,CheckInitialOffsetRecord,1,leveldb.log.LogTest.CheckInitialOffsetRecord,"void leveldb.log.LogTest.CheckInitialOffsetRecord (uint64_t,int)",db\log_test.cc,"void CheckInitialOffsetRecord(uint64_t initial_offset,
                                int expected_record_offset) {
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       initial_offset);

    // Read all records from expected_record_offset through the last one.
    ASSERT_LT(expected_record_offset, num_initial_offset_records_);
    for (; expected_record_offset < num_initial_offset_records_;
         ++expected_record_offset) {
      Slice record;
      std::string scratch;
      ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch));
      ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size());
      ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset());
      ASSERT_EQ((char)('a' + expected_record_offset), record....",220.0,242.0,3.0,4.0,23.0,42,10,43,18,0,14,2,2,1,0,,0,14,4,2,2,void
806,39811,Writer,1,leveldb.log.Writer.Writer,ANY leveldb.log.Writer.Writer (WritableFile*),db\log_writer.cc,"Writer::Writer(WritableFile* dest, uint64_t dest_length)
    : dest_(dest), block_offset_(dest_length % kBlockSize) {
  InitTypeCrc(type_crc_);
}",28.0,31.0,1.0,1.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,4,2,2,ANY
807,39830,AddRecord,1,leveldb.log.Writer.AddRecord,Status leveldb.log.Writer.AddRecord (Slice),db\log_writer.cc,"Status Writer::AddRecord(const Slice& slice) {
  const char* ptr = slice.data();
  size_t left = slice.size();

  // Fragment the record if necessary and emit it.  Note that if slice
  // is empty, we still want to iterate once to emit a single
  // zero-length record
  Status s;
  bool begin = true;
  do {
    const int leftover = kBlockSize - block_offset_;
    assert(leftover >= 0);
    if (leftover < kHeaderSize) {
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }
      block_offset_ = 0;
    }

    // Invariant: we never leave < kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left < avail) ? left : avail;

    RecordType type;
    const bool end = ...",36.0,82.0,1.0,1.0,47.0,33,12,47,15,0,5,5,9,0,0,,0,5,2,1,1,Status
808,39976,EmitPhysicalRecord,1,leveldb.log.Writer.EmitPhysicalRecord,"Status leveldb.log.Writer.EmitPhysicalRecord (RecordType,char*,size_t)",db\log_writer.cc,"Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {
  assert(n <= 0xffff);  // Must fit in two bytes
  assert(block_offset_ + kHeaderSize + n <= kBlockSize);

  // Format the header
  char buf[kHeaderSize];
  buf[4] = static_cast<char>(n & 0xff);
  buf[5] = static_cast<char>(n >> 8);
  buf[6] = static_cast<char>(t);

  // Compute the crc of the record type and the payload.
  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);
  crc = crc32c::Mask(crc);                 // Adjust for storage
  EncodeFixed32(buf, crc);

  // Write the header and the payload
  Status s = dest_->Append(Slice(buf, kHeaderSize));
  if (s.ok()) {
    s = dest_->Append(Slice(ptr, n));
    if (s.ok()) {
      s = dest_->Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  return s;
}",84.0,109.0,1.0,1.0,26.0,30,10,38,12,0,6,3,4,0,0,,0,6,6,3,3,Status
809,40198,~MemTable,1,leveldb.MemTable.~MemTable,ANY leveldb.MemTable.~MemTable (),db\memtable.cc,"MemTable::~MemTable() {
  assert(refs_ == 0);
}",27.0,29.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
810,40206,ApproximateMemoryUsage,1,leveldb.MemTable.ApproximateMemoryUsage,size_t leveldb.MemTable.ApproximateMemoryUsage (),db\memtable.cc,size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); },31.0,31.0,1.0,74.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
811,40277,Valid,1,leveldb.MemTableIterator.Valid,bool leveldb.MemTableIterator.Valid (),db\memtable.cc,virtual bool Valid() const { return iter_.Valid(); },55.0,55.0,3.0,54.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
812,40286,Seek,1,leveldb.MemTableIterator.Seek,void leveldb.MemTableIterator.Seek (Slice),db\memtable.cc,"virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }",56.0,56.0,3.0,72.0,1.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
813,40299,SeekToFirst,1,leveldb.MemTableIterator.SeekToFirst,void leveldb.MemTableIterator.SeekToFirst (),db\memtable.cc,virtual void SeekToFirst() { iter_.SeekToFirst(); },57.0,57.0,3.0,53.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
814,40307,SeekToLast,1,leveldb.MemTableIterator.SeekToLast,void leveldb.MemTableIterator.SeekToLast (),db\memtable.cc,virtual void SeekToLast() { iter_.SeekToLast(); },58.0,58.0,3.0,51.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
815,40315,Next,1,leveldb.MemTableIterator.Next,void leveldb.MemTableIterator.Next (),db\memtable.cc,virtual void Next() { iter_.Next(); },59.0,59.0,3.0,39.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
816,40323,Prev,1,leveldb.MemTableIterator.Prev,void leveldb.MemTableIterator.Prev (),db\memtable.cc,virtual void Prev() { iter_.Prev(); },60.0,60.0,3.0,39.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
817,40331,key,1,leveldb.MemTableIterator.key,Slice leveldb.MemTableIterator.key (),db\memtable.cc,virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); },61.0,61.0,3.0,75.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
818,40341,value,1,leveldb.MemTableIterator.value,Slice leveldb.MemTableIterator.value (),db\memtable.cc,"virtual Slice value() const {
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }",62.0,65.0,3.0,3.0,4.0,5,3,4,2,0,1,1,1,0,0,,0,1,0,0,0,Slice
819,40364,status,1,leveldb.MemTableIterator.status,Status leveldb.MemTableIterator.status (),db\memtable.cc,virtual Status status() const { return Status::OK(); },67.0,67.0,3.0,56.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
820,40385,NewIterator,1,leveldb.MemTable.NewIterator,Iterator leveldb.MemTable.NewIterator (),db\memtable.cc,"Iterator* MemTable::NewIterator() {
  return new MemTableIterator(&table_);
}",78.0,80.0,1.0,1.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,Iterator
821,40394,Add,1,leveldb.MemTable.Add,"void leveldb.MemTable.Add (SequenceNumber,ValueType,Slice,Slice)",db\memtable.cc,"void MemTable::Add(SequenceNumber s, ValueType type,
                   const Slice& key,
                   const Slice& value) {
  // Format of an entry is concatenation of:
  //  key_size     : varint32 of internal_key.size()
  //  key bytes    : char[internal_key.size()]
  //  value_size   : varint32 of value.size()
  //  value bytes  : char[value.size()]
  size_t key_size = key.size();
  size_t val_size = value.size();
  size_t internal_key_size = key_size + 8;
  const size_t encoded_len =
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  char* buf = arena_.Allocate(encoded_len);
  char* p = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s << 8) | type);
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf);
}",82.0,106.0,1.0,1.0,25.0,24,8,38,12,0,2,1,1,0,0,,0,2,8,4,4,void
822,40493,Get,1,leveldb.MemTable.Get,"bool leveldb.MemTable.Get (LookupKey,ANY*,Status*)",db\memtable.cc,"bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {
  Slice memkey = key.memtable_key();
  Table::Iterator iter(&table_);
  iter.Seek(memkey.data());
  if (iter.Valid()) {
    // entry format is:
    //    klength  varint32
    //    userkey  char[klength]
    //    tag      uint64
    //    vlength  varint32
    //    value    char[vlength]
    // Check that it belongs to same user key.  We do not check the
    // sequence number since the Seek() call above should have skipped
    // all entries with overly large sequence numbers.
    const char* entry = iter.key();
    uint32_t key_length;
    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);
    if (comparator_.comparator.user_comparator()->Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast<ValueType>(tag & 0xff)) {
        case kTypeVa...",108.0,143.0,1.0,1.0,36.0,30,10,30,15,0,4,4,7,2,1,,0,4,6,3,3,bool
823,40644,Ref,1,leveldb.MemTable.Ref,void leveldb.MemTable.Ref (),db\memtable.hpp,void Ref() { ++refs_; },27.0,27.0,3.0,25.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
824,40650,Unref,1,leveldb.MemTable.Unref,void leveldb.MemTable.Unref (),db\memtable.hpp,"void Unref() {
    --refs_;
    assert(refs_ >= 0);
    if (refs_ <= 0) {
      delete this;
    }
  }",30.0,36.0,3.0,3.0,7.0,4,4,3,1,0,3,2,2,1,0,,0,3,0,0,0,void
825,40751,RecoveryTest,1,leveldb.RecoveryTest.RecoveryTest,ANY leveldb.RecoveryTest.RecoveryTest (),db\recovery_test.cc,"RecoveryTest() : env_(Env::Default()), db_(NULL) {
    dbname_ = test::TmpDir() + ""/recovery_test"";
    DestroyDB(dbname_, Options());
    Open();
  }",20.0,24.0,3.0,3.0,5.0,3,3,3,2,0,2,1,1,0,0,,0,2,0,0,0,ANY
826,40767,~RecoveryTest,1,leveldb.RecoveryTest.~RecoveryTest,ANY leveldb.RecoveryTest.~RecoveryTest (),db\recovery_test.cc,"~RecoveryTest() {
    Close();
    DestroyDB(dbname_, Options());
  }",26.0,29.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
827,40775,dbfull,1,leveldb.RecoveryTest.dbfull,DBImpl leveldb.RecoveryTest.dbfull (),db\recovery_test.cc,DBImpl* dbfull() const { return reinterpret_cast<DBImpl*>(db_); },31.0,31.0,3.0,67.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DBImpl
828,40783,env,1,leveldb.RecoveryTest.env,Env leveldb.RecoveryTest.env (),db\recovery_test.cc,Env* env() const { return env_; },32.0,32.0,3.0,35.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Env
829,40789,CanAppend,1,leveldb.RecoveryTest.CanAppend,bool leveldb.RecoveryTest.CanAppend (),db\recovery_test.cc,"bool CanAppend() {
    WritableFile* tmp;
    Status s = env_->NewAppendableFile(CurrentFileName(dbname_), &tmp);
    delete tmp;
    if (s.IsNotSupportedError()) {
      return false;
    } else {
      return true;
    }
  }",34.0,43.0,3.0,3.0,10.0,5,5,6,4,0,2,2,2,0,0,,0,2,0,0,0,bool
830,40819,Close,1,leveldb.RecoveryTest.Close,void leveldb.RecoveryTest.Close (),db\recovery_test.cc,"void Close() {
    delete db_;
    db_ = NULL;
  }",45.0,48.0,3.0,3.0,4.0,2,2,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
831,40828,Open,1,leveldb.RecoveryTest.Open,void leveldb.RecoveryTest.Open (Options*),db\recovery_test.cc,"void Open(Options* options = NULL) {
    Close();
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }
    if (opts.env == NULL) {
      opts.env = env_;
    }
    ASSERT_OK(DB::Open(opts, dbname_, &db_));
    ASSERT_EQ(1, NumLogs());
  }",50.0,64.0,3.0,4.0,15.0,15,6,16,8,0,5,3,3,1,0,,0,5,2,1,1,void
832,40906,Put,1,leveldb.RecoveryTest.Put,"Status leveldb.RecoveryTest.Put (ANY,ANY)",db\recovery_test.cc,"Status Put(const std::string& k, const std::string& v) {
    return db_->Put(WriteOptions(), k, v);
  }",66.0,68.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
833,40920,Get,1,leveldb.RecoveryTest.Get,"string leveldb.RecoveryTest.Get (ANY,Snapshot*)",db\recovery_test.cc,"std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {
    std::string result;
    Status s = db_->Get(ReadOptions(), k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",70.0,79.0,3.0,3.0,10.0,5,4,7,4,0,1,2,2,0,0,,0,1,4,2,2,string
834,40964,ManifestFileName,1,leveldb.RecoveryTest.ManifestFileName,string leveldb.RecoveryTest.ManifestFileName (),db\recovery_test.cc,"std::string ManifestFileName() {
    std::string current;
    ASSERT_OK(ReadFileToString(env_, CurrentFileName(dbname_), &current));
    size_t len = current.size();
    if (len > 0 && current[len-1] == '\n') {
      current.resize(len - 1);
    }
    return dbname_ + ""/"" + current;
  }",81.0,89.0,3.0,4.0,9.0,15,9,14,5,0,3,2,2,0,0,,0,3,0,0,0,string
835,41021,LogName,1,leveldb.RecoveryTest.LogName,string leveldb.RecoveryTest.LogName (uint64_t),db\recovery_test.cc,"std::string LogName(uint64_t number) {
    return LogFileName(dbname_, number);
  }",91.0,93.0,3.0,3.0,3.0,0,0,2,2,0,1,1,1,0,0,,0,1,2,1,1,string
836,41030,DeleteLogFiles,1,leveldb.RecoveryTest.DeleteLogFiles,size_t leveldb.RecoveryTest.DeleteLogFiles (),db\recovery_test.cc,"size_t DeleteLogFiles() {
    std::vector<uint64_t> logs = GetFiles(kLogFile);
    for (size_t i = 0; i < logs.size(); i++) {
      ASSERT_OK(env_->DeleteFile(LogName(logs[i]))) << LogName(logs[i]);
    }
    return logs.size();
  }",95.0,101.0,3.0,6.0,7.0,17,7,18,7,0,2,2,2,0,0,,0,2,0,0,0,size_t
837,41107,GetFiles,1,leveldb.RecoveryTest.GetFiles,vector<uint64_t> leveldb.RecoveryTest.GetFiles (FileType),db\recovery_test.cc,"std::vector<uint64_t> GetFiles(FileType t) {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    std::vector<uint64_t> result;
    for (size_t i = 0; i < filenames.size(); i++) {
      uint64_t number;
      FileType type;
      if (ParseFileName(filenames[i], &number, &type) && type == t) {
        result.push_back(number);
      }
    }
    return result;
  }",107.0,119.0,3.0,4.0,13.0,21,9,23,11,0,2,3,4,0,0,,0,2,2,1,1,vector<uint64_t>
838,41206,FileSize,1,leveldb.RecoveryTest.FileSize,uint64_t leveldb.RecoveryTest.FileSize (ANY),db\recovery_test.cc,"uint64_t FileSize(const std::string& fname) {
    uint64_t result;
    ASSERT_OK(env_->GetFileSize(fname, &result)) << fname;
    return result;
  }",129.0,133.0,3.0,4.0,5.0,6,4,7,4,0,1,1,1,0,0,,0,1,2,1,1,uint64_t
839,41244,MakeLogFile,1,leveldb.RecoveryTest.MakeLogFile,"void leveldb.RecoveryTest.MakeLogFile (uint64_t,SequenceNumber,Slice,Slice)",db\recovery_test.cc,"void MakeLogFile(uint64_t lognum, SequenceNumber seq, Slice key, Slice val) {
    std::string fname = LogFileName(dbname_, lognum);
    WritableFile* file;
    ASSERT_OK(env_->NewWritableFile(fname, &file));
    log::Writer writer(file);
    WriteBatch batch;
    batch.Put(key, val);
    WriteBatchInternal::SetSequence(&batch, seq);
    ASSERT_OK(writer.AddRecord(WriteBatchInternal::Contents(&batch)));
    ASSERT_OK(file->Flush());
    delete file;
  }",140.0,151.0,3.0,4.0,12.0,24,5,28,14,0,2,1,1,0,0,,0,2,8,4,4,void
840,42819,Repairer,1,leveldb.anonymous_namespace_2.Repairer.Repairer,"ANY leveldb.anonymous_namespace_2.Repairer.Repairer (ANY,Options)",db\repair.cc,"Repairer(const std::string& dbname, const Options& options)
      : dbname_(dbname),
        env_(options.env),
        icmp_(options.comparator),
        ipolicy_(options.filter_policy),
        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),
        owns_info_log_(options_.info_log != options.info_log),
        owns_cache_(options_.block_cache != options.block_cache),
        next_file_number_(1) {
    // TableCache can be small since we expect each table to be opened once.
    table_cache_ = new TableCache(dbname_, &options_, 10);
  }",47.0,58.0,3.0,3.0,12.0,3,3,4,4,0,3,1,1,0,0,,0,3,4,2,2,ANY
841,42833,~Repairer,1,leveldb.anonymous_namespace_3.Repairer.~Repairer,ANY leveldb.anonymous_namespace_3.Repairer.~Repairer (),db\repair.cc,"~Repairer() {
    delete table_cache_;
    if (owns_info_log_) {
      delete options_.info_log;
    }
    if (owns_cache_) {
      delete options_.block_cache;
    }
  }",60.0,68.0,3.0,3.0,9.0,5,2,5,4,0,5,3,3,2,0,,0,5,0,0,0,ANY
842,42853,Run,1,leveldb.anonymous_namespace_4.Repairer.Run,Status leveldb.anonymous_namespace_4.Repairer.Run (),db\repair.cc,"Status Run() {
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }
    if (status.ok()) {
      unsigned long long bytes = 0;
      for (size_t i = 0; i < tables_.size(); i++) {
        bytes += tables_[i].meta.file_size;
      }
      Log(options_.info_log,
          ""**** Repaired leveldb %s; ""
          ""recovered %d files; %llu bytes. ""
          ""Some data may have been lost. ""
          ""****"",
          dbname_.c_str(),
          static_cast<int>(tables_.size()),
          bytes);
    }
    return status;
  }",70.0,92.0,3.0,3.0,23.0,16,6,16,6,0,5,4,5,1,0,,0,5,0,0,0,Status
843,42941,FindFiles,1,leveldb.anonymous_namespace_10.Repairer.FindFiles,Status leveldb.anonymous_namespace_10.Repairer.FindFiles (),db\repair.cc,"Status FindFiles() {
    std::vector<std::string> filenames;
    Status status = env_->GetChildren(dbname_, &filenames);
    if (!status.ok()) {
      return status;
    }
    if (filenames.empty()) {
      return Status::IOError(dbname_, ""repair found no files"");
    }

    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type)) {
        if (type == kDescriptorFile) {
          manifests_.push_back(filenames[i]);
        } else {
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }
      }
    }
    return status;
  }",116.0,147.0,3.0,3.0,32.0,20,9,25,11,0,5,6,9,0,1,,0,4,0,0,0,Status
844,43065,ConvertLogFilesToTables,1,leveldb.anonymous_namespace_11.Repairer.ConvertLogFilesToTables,void leveldb.anonymous_namespace_11.Repairer.ConvertLogFilesToTables (),db\repair.cc,"void ConvertLogFilesToTables() {
    for (size_t i = 0; i < logs_.size(); i++) {
      std::string logname = LogFileName(dbname_, logs_[i]);
      Status status = ConvertLogToTable(logs_[i]);
      if (!status.ok()) {
        Log(options_.info_log, ""Log #%llu: ignoring conversion error: %s"",
            (unsigned long long) logs_[i],
            status.ToString().c_str());
      }
      ArchiveFile(logname);
    }
  }",149.0,160.0,3.0,3.0,12.0,14,6,16,6,0,6,3,4,1,0,,0,6,0,0,0,void
845,43125,ConvertLogToTable,1,leveldb.anonymous_namespace_14.Repairer.ConvertLogToTable,Status leveldb.anonymous_namespace_14.Repairer.ConvertLogToTable (uint64_t),db\repair.cc,"Status ConvertLogToTable(uint64_t log) {
    struct LogReporter : public log::Reader::Reporter {
      Env* env;
      Logger* info_log;
      uint64_t lognum;
      virtual void Corruption(size_t bytes, const Status& s) {
        // We print error messages for corruption, but continue repairing.
        Log(info_log, ""Log #%llu: dropping %d bytes; %s"",
            (unsigned long long) lognum,
            static_cast<int>(bytes),
            s.ToString().c_str());
      }
    };

    // Open the log file
    std::string logname = LogFileName(dbname_, log);
    SequentialFile* lfile;
    Status status = env_->NewSequentialFile(logname, &lfile);
    if (!status.ok()) {
      return status;
    }

    // Create the log reader.
    LogReporter reporter;
    reporter.env = env_;
    reporter.info_log = options_.info_log;
    reporter.lognum = log;
    // We intentionally make log::Reader do checksumming so that
    // corruptions cause entire commits to be skipped instead of
    // propa...",162.0,242.0,3.0,3.0,81.0,57,12,66,24,0,17,8,10,1,1,,0,16,2,1,1,Status
846,43361,ExtractMetaData,1,leveldb.anonymous_namespace_15.Repairer.ExtractMetaData,void leveldb.anonymous_namespace_15.Repairer.ExtractMetaData (),db\repair.cc,"void ExtractMetaData() {
    for (size_t i = 0; i < table_numbers_.size(); i++) {
      ScanTable(table_numbers_[i]);
    }
  }",244.0,248.0,3.0,3.0,5.0,4,4,5,2,0,2,2,2,1,0,,0,2,0,0,0,void
847,43384,NewTableIterator,1,leveldb.anonymous_namespace_17.Repairer.NewTableIterator,Iterator leveldb.anonymous_namespace_17.Repairer.NewTableIterator (FileMetaData),db\repair.cc,"Iterator* NewTableIterator(const FileMetaData& meta) {
    // Same as compaction iterators: if paranoid_checks are on, turn
    // on checksum verification.
    ReadOptions r;
    r.verify_checksums = options_.paranoid_checks;
    return table_cache_->NewIterator(r, meta.number, meta.file_size);
  }",250.0,256.0,3.0,3.0,7.0,6,3,6,4,0,5,1,1,0,0,,0,5,2,1,1,Iterator
848,43409,ScanTable,1,leveldb.anonymous_namespace_18.Repairer.ScanTable,void leveldb.anonymous_namespace_18.Repairer.ScanTable (uint64_t),db\repair.cc,"void ScanTable(uint64_t number) {
    TableInfo t;
    t.meta.number = number;
    std::string fname = TableFileName(dbname_, number);
    Status status = env_->GetFileSize(fname, &t.meta.file_size);
    if (!status.ok()) {
      // Try alternate file name.
      fname = SSTTableFileName(dbname_, number);
      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);
      if (s2.ok()) {
        status = Status::OK();
      }
    }
    if (!status.ok()) {
      ArchiveFile(TableFileName(dbname_, number));
      ArchiveFile(SSTTableFileName(dbname_, number));
      Log(options_.info_log, ""Table #%llu: dropped: %s"",
          (unsigned long long) t.meta.number,
          status.ToString().c_str());
      return;
    }

    // Extract metadata by scanning through table.
    int counter = 0;
    Iterator* iter = NewTableIterator(t.meta);
    bool empty = true;
    ParsedInternalKey parsed;
    t.max_sequence = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      Slice k...",258.0,319.0,3.0,3.0,62.0,73,9,64,15,0,25,11,14,2,0,,0,25,2,1,1,void
849,43679,RepairTable,1,leveldb.anonymous_namespace_23.Repairer.RepairTable,"void leveldb.anonymous_namespace_23.Repairer.RepairTable (ANY,TableInfo)",db\repair.cc,"void RepairTable(const std::string& src, TableInfo t) {
    // We will copy src contents to a new table and then rename the
    // new table over the source.

    // Create builder.
    std::string copy = TableFileName(dbname_, next_file_number_++);
    WritableFile* file;
    Status s = env_->NewWritableFile(copy, &file);
    if (!s.ok()) {
      return;
    }
    TableBuilder* builder = new TableBuilder(options_, file);

    // Copy data.
    Iterator* iter = NewTableIterator(t.meta);
    int counter = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      builder->Add(iter->key(), iter->value());
      counter++;
    }
    delete iter;

    ArchiveFile(src);
    if (counter == 0) {
      builder->Abandon();  // Nothing to save
    } else {
      s = builder->Finish();
      if (s.ok()) {
        t.meta.file_size = builder->FileSize();
      }
    }
    delete builder;
    builder = NULL;

    if (s.ok()) {
      s = file->Close();
    }
    delete file;
    file = ...",321.0,373.0,3.0,3.0,53.0,45,12,52,16,0,12,8,9,0,0,,0,12,4,2,2,void
850,43881,WriteDescriptor,1,leveldb.anonymous_namespace_26.Repairer.WriteDescriptor,Status leveldb.anonymous_namespace_26.Repairer.WriteDescriptor (),db\repair.cc,"Status WriteDescriptor() {
    std::string tmp = TempFileName(dbname_, 1);
    WritableFile* file;
    Status status = env_->NewWritableFile(tmp, &file);
    if (!status.ok()) {
      return status;
    }

    SequenceNumber max_sequence = 0;
    for (size_t i = 0; i < tables_.size(); i++) {
      if (max_sequence < tables_[i].max_sequence) {
        max_sequence = tables_[i].max_sequence;
      }
    }

    edit_.SetComparatorName(icmp_.user_comparator()->Name());
    edit_.SetLogNumber(0);
    edit_.SetNextFile(next_file_number_);
    edit_.SetLastSequence(max_sequence);

    for (size_t i = 0; i < tables_.size(); i++) {
      // TODO(opt): separate out into multiple levels
      const TableInfo& t = tables_[i];
      edit_.AddFile(0, t.meta.number, t.meta.file_size,
                    t.meta.smallest, t.meta.largest);
    }

    //fprintf(stderr, ""NewDescriptor:\n%s\n"", edit_.DebugString().c_str());
    {
      log::Writer log(file);
      std::string record;
      edit_.EncodeT...",375.0,432.0,3.0,3.0,58.0,48,8,52,15,0,20,7,8,3,0,,0,20,0,0,0,Status
851,44121,ArchiveFile,1,leveldb.anonymous_namespace_28.Repairer.ArchiveFile,void leveldb.anonymous_namespace_28.Repairer.ArchiveFile (ANY),db\repair.cc,"void ArchiveFile(const std::string& fname) {
    // Move into another directory.  E.g., for
    //    dir/foo
    // rename to
    //    dir/lost/foo
    const char* slash = strrchr(fname.c_str(), '/');
    std::string new_dir;
    if (slash != NULL) {
      new_dir.assign(fname.data(), slash - fname.data());
    }
    new_dir.append(""/lost"");
    env_->CreateDir(new_dir);  // Ignore error
    std::string new_file = new_dir;
    new_file.append(""/"");
    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);
    Status s = env_->RenameFile(fname, new_file);
    Log(options_.info_log, ""Archiving %s: %s\n"",
        fname.c_str(), s.ToString().c_str());
  }",434.0,452.0,3.0,3.0,19.0,22,8,26,8,0,3,2,2,0,0,,0,3,2,1,1,void
852,44314,GetMaxHeight,1,leveldb.SkipList.GetMaxHeight,int leveldb.SkipList.GetMaxHeight (),db\skiplist.hpp,"inline int GetMaxHeight() const {
    return static_cast<int>(
        reinterpret_cast<intptr_t>(max_height_.NoBarrier_Load()));
  }",110.0,113.0,3.0,3.0,4.0,3,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
853,44388,Next,1,leveldb.Node.Next,Node leveldb.Node.Next (int),db\skiplist.hpp,"Node* Next(int n) {
    assert(n >= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
  }",154.0,159.0,3.0,3.0,6.0,4,4,3,2,0,1,1,1,0,0,,0,1,2,1,1,Node
854,44406,SetNext,1,leveldb.Node.SetNext,"void leveldb.Node.SetNext (int,Node*)",db\skiplist.hpp,"void SetNext(int n, Node* x) {
    assert(n >= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }",160.0,165.0,3.0,3.0,6.0,3,3,4,3,0,1,1,1,0,0,,0,1,4,2,2,void
855,44423,NoBarrier_Next,1,leveldb.Node.NoBarrier_Next,Node leveldb.Node.NoBarrier_Next (int),db\skiplist.hpp,"Node* NoBarrier_Next(int n) {
    assert(n >= 0);
    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
  }",168.0,171.0,3.0,3.0,4.0,4,4,3,2,0,1,1,1,0,0,,0,1,2,1,1,Node
856,44441,NoBarrier_SetNext,1,leveldb.Node.NoBarrier_SetNext,"void leveldb.Node.NoBarrier_SetNext (int,Node*)",db\skiplist.hpp,"void NoBarrier_SetNext(int n, Node* x) {
    assert(n >= 0);
    next_[n].NoBarrier_Store(x);
  }",172.0,175.0,3.0,3.0,4.0,3,3,4,3,0,1,1,1,0,0,,0,1,4,2,2,void
857,44643,KeyIsAfterNode,1,"leveldb.SkipList<Key,Comparator>.KeyIsAfterNode","bool leveldb.SkipList<Key,Comparator>.KeyIsAfterNode<Key,Comparator> (Key,Node*)",db\skiplist.hpp,"bool SkipList<Key,Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {
  // NULL n is considered infinite
  return (n != NULL) && (compare_(n->key, key) < 0);
}",256.0,259.0,1.0,1.0,4.0,4,4,4,3,0,1,1,1,0,0,,0,1,4,2,2,bool
858,44719,FindLessThan,1,"leveldb.SkipList<Key,Comparator>.FindLessThan","Node leveldb.SkipList<Key,Comparator>.FindLessThan<Key,Comparator> (Key)",db\skiplist.hpp,"typename SkipList<Key,Comparator>::Node*
SkipList<Key,Comparator>::FindLessThan(const Key& key) const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    assert(x == head_ || compare_(x->key, key) < 0);
    Node* next = x->Next(level);
    if (next == NULL || compare_(next->key, key) >= 0) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",284.0,302.0,1.0,1.0,19.0,14,7,16,6,0,2,4,7,1,0,,0,2,2,1,1,Node
859,44856,Insert,1,"leveldb.SkipList<Key,Comparator>.Insert","void leveldb.SkipList<Key,Comparator>.Insert<Key,Comparator> (Key)",db\skiplist.hpp,"void SkipList<Key,Comparator>::Insert(const Key& key) {
  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  // here since Insert() is externally synchronized.
  Node* prev[kMaxHeight];
  Node* x = FindGreaterOrEqual(key, prev);

  // Our data structure does not allow duplicate insertion
  assert(x == NULL || !Equal(key, x->key));

  int height = RandomHeight();
  if (height > GetMaxHeight()) {
    for (int i = GetMaxHeight(); i < height; i++) {
      prev[i] = head_;
    }
    //fprintf(stderr, ""Change height from %d to %d\n"", max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the...",337.0,370.0,1.0,1.0,34.0,21,10,32,8,0,1,4,5,0,0,,0,1,2,1,1,void
860,44949,Contains,1,"leveldb.SkipList<Key,Comparator>.Contains","bool leveldb.SkipList<Key,Comparator>.Contains<Key,Comparator> (Key)",db\skiplist.hpp,"bool SkipList<Key,Comparator>::Contains(const Key& key) const {
  Node* x = FindGreaterOrEqual(key, NULL);
  if (x != NULL && Equal(key, x->key)) {
    return true;
  } else {
    return false;
  }
}",373.0,380.0,1.0,1.0,8.0,4,4,7,3,0,1,2,2,1,0,,0,1,2,1,1,bool
861,45799,key,1,leveldb.ConcurrentTest.key,uint64_t leveldb.ConcurrentTest.key (Key),db\skiplist_test.cc,static uint64_t key(Key key) { return (key >> 40); },153.0,153.0,3.0,54.0,1.0,1,1,1,1,10,0,1,1,0,0,,0,0,2,1,1,uint64_t
862,45808,gen,1,leveldb.ConcurrentTest.gen,uint64_t leveldb.ConcurrentTest.gen (Key),db\skiplist_test.cc,static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; },154.0,154.0,3.0,67.0,1.0,2,2,1,1,5,0,1,1,0,0,,0,0,2,1,1,uint64_t
863,45819,hash,1,leveldb.ConcurrentTest.hash,uint64_t leveldb.ConcurrentTest.hash (Key),db\skiplist_test.cc,static uint64_t hash(Key key) { return key & 0xff; },155.0,155.0,3.0,54.0,1.0,1,1,1,1,1,0,1,1,0,0,,0,0,2,1,1,uint64_t
864,45828,HashNumbers,1,leveldb.ConcurrentTest.HashNumbers,"uint64_t leveldb.ConcurrentTest.HashNumbers (uint64_t,uint64_t)",db\skiplist_test.cc,"static uint64_t HashNumbers(uint64_t k, uint64_t g) {
    uint64_t data[2] = { k, g };
    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);
  }",157.0,160.0,3.0,3.0,4.0,4,4,5,3,2,0,1,1,0,0,,0,0,4,2,2,uint64_t
865,45848,MakeKey,1,leveldb.ConcurrentTest.MakeKey,"Key leveldb.ConcurrentTest.MakeKey (uint64_t,uint64_t)",db\skiplist_test.cc,"static Key MakeKey(uint64_t k, uint64_t g) {
    assert(sizeof(Key) == sizeof(uint64_t));
    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist
    assert(g <= 0xffffffffu);
    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));
  }",162.0,167.0,3.0,3.0,6.0,10,6,9,5,2,2,1,1,0,1,,0,1,4,2,2,Key
866,45882,IsValidKey,1,leveldb.ConcurrentTest.IsValidKey,bool leveldb.ConcurrentTest.IsValidKey (Key),db\skiplist_test.cc,"static bool IsValidKey(Key k) {
    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);
  }",169.0,171.0,3.0,3.0,3.0,2,2,3,1,0,4,1,1,0,4,,0,2,2,1,1,bool
867,45898,RandomTarget,1,leveldb.ConcurrentTest.RandomTarget,Key leveldb.ConcurrentTest.RandomTarget (Random*),db\skiplist_test.cc,"static Key RandomTarget(Random* rnd) {
    switch (rnd->Next() % 10) {
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      default:
        // Seek to middle
        return MakeKey(rnd->Next() % K, 0);
    }
  }",173.0,185.0,3.0,3.0,13.0,4,2,4,2,1,2,2,2,0,0,,0,2,2,1,1,Key
868,45935,Set,1,leveldb.ConcurrentTest.State.Set,"void leveldb.ConcurrentTest.State.Set (int,intptr_t)",db\skiplist_test.cc,"void Set(int k, intptr_t v) {
      generation[k].Release_Store(reinterpret_cast<void*>(v));
    }",190.0,192.0,5.0,5.0,3.0,3,3,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
869,45950,Get,1,leveldb.ConcurrentTest.State.Get,intptr_t leveldb.ConcurrentTest.State.Get (int),db\skiplist_test.cc,"intptr_t Get(int k) {
      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());
    }",193.0,195.0,5.0,5.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,2,1,1,intptr_t
870,45996,WriteStep,1,leveldb.ConcurrentTest.WriteStep,void leveldb.ConcurrentTest.WriteStep (Random*),db\skiplist_test.cc,"void WriteStep(Random* rnd) {
    const uint32_t k = rnd->Next() % K;
    const intptr_t g = current_.Get(k) + 1;
    const Key key = MakeKey(k, g);
    list_.Insert(key);
    current_.Set(k, g);
  }",217.0,223.0,3.0,3.0,7.0,9,5,14,7,0,5,1,1,0,1,,0,5,2,1,1,void
871,46037,ReadStep,1,leveldb.ConcurrentTest.ReadStep,void leveldb.ConcurrentTest.ReadStep (Random*),db\skiplist_test.cc,"void ReadStep(Random* rnd) {
    // Remember the initial committed state of the skiplist.
    State initial_state;
    for (int k = 0; k < K; k++) {
      initial_state.Set(k, current_.Get(k));
    }

    Key pos = RandomTarget(rnd);
    SkipList<Key, Comparator>::Iterator iter(&list_);
    iter.Seek(pos);
    while (true) {
      Key current;
      if (!iter.Valid()) {
        current = MakeKey(K, 0);
      } else {
        current = iter.key();
        ASSERT_TRUE(IsValidKey(current)) << current;
      }
      ASSERT_LE(pos, current) << ""should not go backwards"";

      // Verify that everything in [pos,current) was not present in
      // initial_state.
      while (pos < current) {
        ASSERT_LT(key(pos), K) << pos;

        // Note that generation 0 is never inserted, so it is ok if
        // <*,0,*> is missing.
        ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    ) << ""key: "" << key(pos)
...",225.0,282.0,3.0,8.0,58.0,44,13,50,12,0,21,9,14,3,15,,0,13,2,1,1,void
872,46377,Wait,1,leveldb.TestState.Wait,void leveldb.TestState.Wait (ReaderState),db\skiplist_test.cc,"void Wait(ReaderState s) {
    mu_.Lock();
    while (state_ != s) {
      state_cv_.Wait();
    }
    mu_.Unlock();
  }",315.0,321.0,3.0,3.0,7.0,4,2,5,4,0,4,2,2,1,0,,0,4,2,1,1,void
873,46399,Change,1,leveldb.TestState.Change,void leveldb.TestState.Change (ReaderState),db\skiplist_test.cc,"void Change(ReaderState s) {
    mu_.Lock();
    state_ = s;
    state_cv_.Signal();
    mu_.Unlock();
  }",323.0,328.0,3.0,3.0,6.0,4,2,5,4,0,4,1,1,0,0,,0,4,2,1,1,void
874,46422,ConcurrentReader,1,leveldb.ConcurrentReader,void leveldb.ConcurrentReader (void*),db\skiplist_test.cc,"static void ConcurrentReader(void* arg) {
  TestState* state = reinterpret_cast<TestState*>(arg);
  Random rnd(state->seed_);
  int64_t reads = 0;
  state->Change(TestState::RUNNING);
  while (!state->quit_flag_.Acquire_Load()) {
    state->t_.ReadStep(&rnd);
    ++reads;
  }
  state->Change(TestState::DONE);
}",336.0,346.0,1.0,1.0,11.0,15,7,12,5,0,5,2,2,1,0,,0,5,2,1,1,void
875,46475,RunConcurrent,1,leveldb.RunConcurrent,void leveldb.RunConcurrent (int),db\skiplist_test.cc,"static void RunConcurrent(int run) {
  const int seed = test::RandomSeed() + (run * 100);
  Random rnd(seed);
  const int N = 1000;
  const int kSize = 1000;
  for (int i = 0; i < N; i++) {
    if ((i % 100) == 0) {
      fprintf(stderr, ""Run %d of %d\n"", i, N);
    }
    TestState state(seed + 1);
    Env::Default()->Schedule(ConcurrentReader, &state);
    state.Wait(TestState::RUNNING);
    for (int i = 0; i < kSize; i++) {
      state.t_.WriteStep(&rnd);
    }
    state.quit_flag_.Release_Store(&state);  // Any non-NULL arg will do
    state.Wait(TestState::DONE);
  }
}",348.0,366.0,1.0,1.0,19.0,26,9,27,11,0,4,4,6,0,0,,0,4,2,1,1,void
876,46789,SnapshotList,1,leveldb.SnapshotList.SnapshotList,ANY leveldb.SnapshotList.SnapshotList (),db\snapshot.hpp,"SnapshotList() {
    list_.prev_ = &list_;
    list_.next_ = &list_;
  }",33.0,36.0,3.0,3.0,4.0,6,3,4,1,0,4,1,1,0,0,,0,4,0,0,0,ANY
877,46805,empty,1,leveldb.SnapshotList.empty,bool leveldb.SnapshotList.empty (),db\snapshot.hpp,bool empty() const { return list_.next_ == &list_; },38.0,38.0,3.0,54.0,1.0,3,3,2,1,0,2,1,1,0,0,,0,2,0,0,0,bool
878,46816,oldest,1,leveldb.SnapshotList.oldest,SnapshotImpl leveldb.SnapshotList.oldest (),db\snapshot.hpp,SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; },39.0,39.0,3.0,72.0,1.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,SnapshotImpl
879,46827,newest,1,leveldb.SnapshotList.newest,SnapshotImpl leveldb.SnapshotList.newest (),db\snapshot.hpp,SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; },40.0,40.0,3.0,72.0,1.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,SnapshotImpl
880,46838,New,1,leveldb.SnapshotList.New,SnapshotImpl leveldb.SnapshotList.New (SequenceNumber),db\snapshot.hpp,"const SnapshotImpl* New(SequenceNumber seq) {
    SnapshotImpl* s = new SnapshotImpl;
    s->number_ = seq;
    s->list_ = this;
    s->next_ = &list_;
    s->prev_ = list_.prev_;
    s->prev_->next_ = s;
    s->next_->prev_ = s;
    return s;
  }",42.0,51.0,3.0,3.0,10.0,18,5,14,4,0,8,1,1,0,0,,0,8,2,1,1,SnapshotImpl
881,46887,Delete,1,leveldb.SnapshotList.Delete,void leveldb.SnapshotList.Delete (SnapshotImpl*),db\snapshot.hpp,"void Delete(const SnapshotImpl* s) {
    assert(s->list_ == this);
    s->prev_->next_ = s->next_;
    s->next_->prev_ = s->prev_;
    delete s;
  }",53.0,58.0,3.0,3.0,6.0,11,4,6,1,0,5,1,1,0,0,,0,5,2,1,1,void
882,46938,DeleteEntry,1,leveldb.DeleteEntry,"void leveldb.DeleteEntry (Slice,void*)",db\table_cache.cc,"static void DeleteEntry(const Slice& key, void* value) {
  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);
  delete tf->table;
  delete tf->file;
  delete tf;
}",19.0,24.0,1.0,1.0,6.0,7,4,5,2,0,2,1,1,0,0,,0,2,4,2,2,void
883,46990,~TableCache,1,leveldb.TableCache.~TableCache,ANY leveldb.TableCache.~TableCache (),db\table_cache.cc,"TableCache::~TableCache() {
  delete cache_;
}",41.0,43.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
884,46996,FindTable,1,leveldb.TableCache.FindTable,"Status leveldb.TableCache.FindTable (uint64_t,uint64_t,ANY**)",db\table_cache.cc,"Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,
                             Cache::Handle** handle) {
  Status s;
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  Slice key(buf, sizeof(buf));
  *handle = cache_->Lookup(key);
  if (*handle == NULL) {
    std::string fname = TableFileName(dbname_, file_number);
    RandomAccessFile* file = NULL;
    Table* table = NULL;
    s = env_->NewRandomAccessFile(fname, &file);
    if (!s.ok()) {
      std::string old_fname = SSTTableFileName(dbname_, file_number);
      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
        s = Status::OK();
      }
    }
    if (s.ok()) {
      s = Table::Open(*options_, file, file_size, &table);
    }

    if (!s.ok()) {
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
    } else {
      TableAndFile* tf = new TableAndF...",45.0,80.0,1.0,1.0,36.0,29,9,41,17,0,7,6,11,1,0,,0,7,6,3,3,Status
885,47143,NewIterator,1,leveldb.TableCache.NewIterator,"Iterator leveldb.TableCache.NewIterator (ReadOptions,uint64_t,uint64_t,Table**)",db\table_cache.cc,"Iterator* TableCache::NewIterator(const ReadOptions& options,
                                  uint64_t file_number,
                                  uint64_t file_size,
                                  Table** tableptr) {
  if (tableptr != NULL) {
    *tableptr = NULL;
  }

  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (!s.ok()) {
    return NewErrorIterator(s);
  }

  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
  Iterator* result = table->NewIterator(options);
  result->RegisterCleanup(&UnrefEntry, cache_, handle);
  if (tableptr != NULL) {
    *tableptr = table;
  }
  return result;
}",82.0,103.0,1.0,1.0,22.0,19,8,26,10,0,2,4,4,0,0,,0,2,8,4,4,Iterator
886,47221,Get,1,leveldb.TableCache.Get,"Status leveldb.TableCache.Get (ReadOptions,uint64_t,uint64_t,Slice,void*,void)",db\table_cache.cc,"Status TableCache::Get(const ReadOptions& options,
                       uint64_t file_number,
                       uint64_t file_size,
                       const Slice& k,
                       void* arg,
                       void (*saver)(void*, const Slice&, const Slice&)) {
  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (s.ok()) {
    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
    s = t->InternalGet(options, k, arg, saver);
    cache_->Release(handle);
  }
  return s;
}",105.0,119.0,1.0,1.0,15.0,11,5,19,11,0,2,2,2,0,0,,0,2,12,6,6,Status
887,47278,Evict,1,leveldb.TableCache.Evict,void leveldb.TableCache.Evict (uint64_t),db\table_cache.cc,"void TableCache::Evict(uint64_t file_number) {
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  cache_->Erase(Slice(buf, sizeof(buf)));
}",121.0,125.0,1.0,1.0,5.0,2,2,5,3,0,1,1,1,0,0,,0,1,2,1,1,void
888,47409,Clear,1,leveldb.VersionEdit.Clear,void leveldb.VersionEdit.Clear (),db\version_edit.cc,"void VersionEdit::Clear() {
  comparator_.clear();
  log_number_ = 0;
  prev_log_number_ = 0;
  last_sequence_ = 0;
  next_file_number_ = 0;
  has_comparator_ = false;
  has_log_number_ = false;
  has_prev_log_number_ = false;
  has_next_file_number_ = false;
  has_last_sequence_ = false;
  deleted_files_.clear();
  new_files_.clear();
}",26.0,39.0,1.0,1.0,14.0,12,2,12,12,0,12,1,1,0,0,,0,12,0,0,0,void
889,47452,EncodeTo,1,leveldb.VersionEdit.EncodeTo,void leveldb.VersionEdit.EncodeTo (ANY*),db\version_edit.cc,"void VersionEdit::EncodeTo(std::string* dst) const {
  if (has_comparator_) {
    PutVarint32(dst, kComparator);
    PutLengthPrefixedSlice(dst, comparator_);
  }
  if (has_log_number_) {
    PutVarint32(dst, kLogNumber);
    PutVarint64(dst, log_number_);
  }
  if (has_prev_log_number_) {
    PutVarint32(dst, kPrevLogNumber);
    PutVarint64(dst, prev_log_number_);
  }
  if (has_next_file_number_) {
    PutVarint32(dst, kNextFileNumber);
    PutVarint64(dst, next_file_number_);
  }
  if (has_last_sequence_) {
    PutVarint32(dst, kLastSequence);
    PutVarint64(dst, last_sequence_);
  }

  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    PutVarint32(dst, kCompactPointer);
    PutVarint32(dst, compact_pointers_[i].first);  // level
    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
  }

  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    PutVarint32(dst, kDeletedFile);
    PutVa...",41.0,86.0,1.0,1.0,46.0,28,6,65,25,0,22,9,9,8,0,,0,22,2,1,1,void
890,47680,DecodeFrom,1,leveldb.VersionEdit.DecodeFrom,Status leveldb.VersionEdit.DecodeFrom (Slice),db\version_edit.cc,"Status VersionEdit::DecodeFrom(const Slice& src) {
  Clear();
  Slice input = src;
  const char* msg = NULL;
  uint32_t tag;

  // Temporary storage for parsing
  int level;
  uint64_t number;
  FileMetaData f;
  Slice str;
  InternalKey key;

  while (msg == NULL && GetVarint32(&input, &tag)) {
    switch (tag) {
      case kComparator:
        if (GetLengthPrefixedSlice(&input, &str)) {
          comparator_ = str.ToString();
          has_comparator_ = true;
        } else {
          msg = ""comparator name"";
        }
        break;

      case kLogNumber:
        if (GetVarint64(&input, &log_number_)) {
          has_log_number_ = true;
        } else {
          msg = ""log number"";
        }
        break;

      case kPrevLogNumber:
        if (GetVarint64(&input, &prev_log_number_)) {
          has_prev_log_number_ = true;
        } else {
          msg = ""previous log number"";
        }
        break;

      case kNextFileNumber:
        if (GetVarint64(&input, &next_file_n...",109.0,210.0,1.0,1.0,102.0,66,7,75,34,0,18,22,30,8,1,,0,18,2,1,1,Status
891,47964,DebugString,1,leveldb.VersionEdit.DebugString,string leveldb.VersionEdit.DebugString (),db\version_edit.cc,"std::string VersionEdit::DebugString() const {
  std::string r;
  r.append(""VersionEdit {"");
  if (has_comparator_) {
    r.append(""\n  Comparator: "");
    r.append(comparator_);
  }
  if (has_log_number_) {
    r.append(""\n  LogNumber: "");
    AppendNumberTo(&r, log_number_);
  }
  if (has_prev_log_number_) {
    r.append(""\n  PrevLogNumber: "");
    AppendNumberTo(&r, prev_log_number_);
  }
  if (has_next_file_number_) {
    r.append(""\n  NextFile: "");
    AppendNumberTo(&r, next_file_number_);
  }
  if (has_last_sequence_) {
    r.append(""\n  LastSeq: "");
    AppendNumberTo(&r, last_sequence_);
  }
  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    r.append(""\n  CompactPointer: "");
    AppendNumberTo(&r, compact_pointers_[i].first);
    r.append("" "");
    r.append(compact_pointers_[i].second.DebugString());
  }
  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    r.append(""\n  DeleteFile: "");
    ...",212.0,264.0,1.0,1.0,53.0,58,7,66,17,0,22,9,9,8,0,,0,22,0,0,0,string
892,48255,SetComparatorName,1,leveldb.VersionEdit.SetComparatorName,void leveldb.VersionEdit.SetComparatorName (Slice),db\version_edit.hpp,"void SetComparatorName(const Slice& name) {
    has_comparator_ = true;
    comparator_ = name.ToString();
  }",35.0,38.0,3.0,3.0,4.0,3,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
893,48269,SetLogNumber,1,leveldb.VersionEdit.SetLogNumber,void leveldb.VersionEdit.SetLogNumber (uint64_t),db\version_edit.hpp,"void SetLogNumber(uint64_t num) {
    has_log_number_ = true;
    log_number_ = num;
  }",39.0,42.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
894,48280,SetPrevLogNumber,1,leveldb.VersionEdit.SetPrevLogNumber,void leveldb.VersionEdit.SetPrevLogNumber (uint64_t),db\version_edit.hpp,"void SetPrevLogNumber(uint64_t num) {
    has_prev_log_number_ = true;
    prev_log_number_ = num;
  }",43.0,46.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
895,48291,SetNextFile,1,leveldb.VersionEdit.SetNextFile,void leveldb.VersionEdit.SetNextFile (uint64_t),db\version_edit.hpp,"void SetNextFile(uint64_t num) {
    has_next_file_number_ = true;
    next_file_number_ = num;
  }",47.0,50.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
896,48302,SetLastSequence,1,leveldb.VersionEdit.SetLastSequence,void leveldb.VersionEdit.SetLastSequence (SequenceNumber),db\version_edit.hpp,"void SetLastSequence(SequenceNumber seq) {
    has_last_sequence_ = true;
    last_sequence_ = seq;
  }",51.0,54.0,3.0,3.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
897,48313,SetCompactPointer,1,leveldb.VersionEdit.SetCompactPointer,"void leveldb.VersionEdit.SetCompactPointer (int,InternalKey)",db\version_edit.hpp,"void SetCompactPointer(int level, const InternalKey& key) {
    compact_pointers_.push_back(std::make_pair(level, key));
  }",55.0,57.0,3.0,3.0,3.0,2,1,4,4,0,1,1,1,0,0,,0,1,4,2,2,void
898,48329,AddFile,1,leveldb.VersionEdit.AddFile,"void leveldb.VersionEdit.AddFile (int,uint64_t,uint64_t,InternalKey,InternalKey)",db\version_edit.hpp,"void AddFile(int level, uint64_t file,
               uint64_t file_size,
               const InternalKey& smallest,
               const InternalKey& largest) {
    FileMetaData f;
    f.number = file;
    f.file_size = file_size;
    f.smallest = smallest;
    f.largest = largest;
    new_files_.push_back(std::make_pair(level, f));
  }",62.0,72.0,3.0,3.0,11.0,10,2,12,8,0,5,1,1,0,0,,0,5,10,5,5,void
899,48369,DeleteFile,1,leveldb.VersionEdit.DeleteFile,"void leveldb.VersionEdit.DeleteFile (int,uint64_t)",db\version_edit.hpp,"void DeleteFile(int level, uint64_t file) {
    deleted_files_.insert(std::make_pair(level, file));
  }",75.0,77.0,3.0,3.0,3.0,2,1,4,4,0,1,1,1,0,0,,0,1,4,2,2,void
900,48680,TargetFileSize,1,leveldb.TargetFileSize,int leveldb.TargetFileSize (Options*),db\version_set.cc,"static int TargetFileSize(const Options* options) {
  return options->max_file_size;
}",23.0,25.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,int
901,48775,~Version,1,leveldb.Version.~Version,ANY leveldb.Version.~Version (),db\version_set.cc,"Version::~Version() {
  assert(refs_ == 0);

  // Remove from linked list
  prev_->next_ = next_;
  next_->prev_ = prev_;

  // Drop references to files
  for (int level = 0; level < config::kNumLevels; level++) {
    for (size_t i = 0; i < files_[level].size(); i++) {
      FileMetaData* f = files_[level][i];
      assert(f->refs > 0);
      f->refs--;
      if (f->refs <= 0) {
        delete f;
      }
    }
  }
}",66.0,84.0,1.0,1.0,19.0,22,10,20,8,0,12,4,7,2,0,,0,12,0,0,0,ANY
902,48851,FindFile,1,leveldb.FindFile,"int leveldb.FindFile (InternalKeyComparator,ANY,Slice)",db\version_set.cc,"int FindFile(const InternalKeyComparator& icmp,
             const std::vector<FileMetaData*>& files,
             const Slice& key) {
  uint32_t left = 0;
  uint32_t right = files.size();
  while (left < right) {
    uint32_t mid = (left + right) / 2;
    const FileMetaData* f = files[mid];
    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
      // Key at ""mid.largest"" is < ""target"".  Therefore all
      // files at or before ""mid"" are uninteresting.
      left = mid + 1;
    } else {
      // Key at ""mid.largest"" is >= ""target"".  Therefore all files
      // after ""mid"" are uninteresting.
      right = mid;
    }
  }
  return right;
}",86.0,105.0,1.0,1.0,20.0,15,7,17,7,0,1,3,4,1,0,,0,1,6,3,3,int
903,48915,AfterFile,1,leveldb.AfterFile,"bool leveldb.AfterFile (Comparator*,Slice*,FileMetaData*)",db\version_set.cc,"static bool AfterFile(const Comparator* ucmp,
                      const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs before all keys and is therefore never after *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->largest.user_key()) > 0);
}",107.0,112.0,1.0,1.0,6.0,7,6,5,4,0,1,1,1,0,0,,0,1,6,3,3,bool
904,48941,BeforeFile,1,leveldb.BeforeFile,"bool leveldb.BeforeFile (Comparator*,Slice*,FileMetaData*)",db\version_set.cc,"static bool BeforeFile(const Comparator* ucmp,
                       const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs after all keys and is therefore never before *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);
}",114.0,119.0,1.0,1.0,6.0,7,6,5,4,0,1,1,1,0,0,,0,1,6,3,3,bool
905,49074,Valid,1,leveldb.LevelFileNumIterator.Valid,bool leveldb.LevelFileNumIterator.Valid (),db\version_set.cc,"virtual bool Valid() const {
    return index_ < flist_->size();
  }",171.0,173.0,3.0,3.0,3.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
906,49085,Seek,1,leveldb.LevelFileNumIterator.Seek,void leveldb.LevelFileNumIterator.Seek (Slice),db\version_set.cc,"virtual void Seek(const Slice& target) {
    index_ = FindFile(icmp_, *flist_, target);
  }",174.0,176.0,3.0,3.0,3.0,2,2,4,4,0,3,1,1,0,0,,0,3,2,1,1,void
907,49097,SeekToFirst,1,leveldb.LevelFileNumIterator.SeekToFirst,void leveldb.LevelFileNumIterator.SeekToFirst (),db\version_set.cc,virtual void SeekToFirst() { index_ = 0; },177.0,177.0,3.0,44.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
908,49104,SeekToLast,1,leveldb.LevelFileNumIterator.SeekToLast,void leveldb.LevelFileNumIterator.SeekToLast (),db\version_set.cc,"virtual void SeekToLast() {
    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  }",178.0,180.0,3.0,3.0,3.0,5,4,3,2,0,3,1,1,0,0,,0,3,0,0,0,void
909,49122,Next,1,leveldb.LevelFileNumIterator.Next,void leveldb.LevelFileNumIterator.Next (),db\version_set.cc,"virtual void Next() {
    assert(Valid());
    index_++;
  }",181.0,184.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
910,49130,Prev,1,leveldb.LevelFileNumIterator.Prev,void leveldb.LevelFileNumIterator.Prev (),db\version_set.cc,"virtual void Prev() {
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_->size();  // Marks as invalid
    } else {
      index_--;
    }
  }",185.0,192.0,3.0,3.0,8.0,3,3,3,2,0,3,2,2,1,0,,0,3,0,0,0,void
911,49151,key,1,leveldb.LevelFileNumIterator.key,Slice leveldb.LevelFileNumIterator.key (),db\version_set.cc,"Slice key() const {
    assert(Valid());
    return (*flist_)[index_]->largest.Encode();
  }",193.0,196.0,3.0,3.0,4.0,4,4,2,2,0,2,1,1,0,0,,0,2,0,0,0,Slice
912,49167,value,1,leveldb.LevelFileNumIterator.value,Slice leveldb.LevelFileNumIterator.value (),db\version_set.cc,"Slice value() const {
    assert(Valid());
    EncodeFixed64(value_buf_, (*flist_)[index_]->number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);
    return Slice(value_buf_, sizeof(value_buf_));
  }",197.0,202.0,3.0,3.0,6.0,8,5,8,3,0,8,1,1,0,0,,0,8,0,0,0,Slice
913,49196,status,1,leveldb.LevelFileNumIterator.status,Status leveldb.LevelFileNumIterator.status (),db\version_set.cc,virtual Status status() const { return Status::OK(); },203.0,203.0,3.0,56.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
914,49215,GetFileIterator,1,leveldb.GetFileIterator,"Iterator leveldb.GetFileIterator (void*,ReadOptions,Slice)",db\version_set.cc,"static Iterator* GetFileIterator(void* arg,
                                 const ReadOptions& options,
                                 const Slice& file_value) {
  TableCache* cache = reinterpret_cast<TableCache*>(arg);
  if (file_value.size() != 16) {
    return NewErrorIterator(
        Status::Corruption(""FileReader invoked with unexpected value""));
  } else {
    return cache->NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}",213.0,225.0,1.0,1.0,13.0,5,4,4,4,0,1,2,2,0,1,,0,0,6,3,3,Iterator
915,49263,NewConcatenatingIterator,1,leveldb.Version.NewConcatenatingIterator,"Iterator leveldb.Version.NewConcatenatingIterator (ReadOptions,int)",db\version_set.cc,"Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,
                                            int level) const {
  return NewTwoLevelIterator(
      new LevelFileNumIterator(vset_->icmp_, &files_[level]),
      &GetFileIterator, vset_->table_cache_, options);
}",227.0,232.0,1.0,1.0,6.0,6,4,6,5,0,3,1,1,0,0,,0,3,4,2,2,Iterator
916,49286,AddIterators,1,leveldb.Version.AddIterators,"void leveldb.Version.AddIterators (ReadOptions,ANY*)",db\version_set.cc,"void Version::AddIterators(const ReadOptions& options,
                           std::vector<Iterator*>* iters) {
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i < files_[0].size(); i++) {
    iters->push_back(
        vset_->table_cache_->NewIterator(
            options, files_[0][i]->number, files_[0][i]->file_size));
  }

  // For levels > 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level < config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters->push_back(NewConcatenatingIterator(options, level));
    }
  }
}",234.0,251.0,1.0,1.0,18.0,20,6,18,7,0,5,4,5,2,0,,0,5,4,2,2,void
917,49375,SaveValue,1,leveldb.SaveValue,"void leveldb.SaveValue (void*,Slice,Slice)",db\version_set.cc,"static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {
  Saver* s = reinterpret_cast<Saver*>(arg);
  ParsedInternalKey parsed_key;
  if (!ParseInternalKey(ikey, &parsed_key)) {
    s->state = kCorrupt;
  } else {
    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
      if (s->state == kFound) {
        s->value->assign(v.data(), v.size());
      }
    }
  }
}",268.0,281.0,1.0,1.0,14.0,6,5,6,5,0,1,2,2,0,0,,0,1,6,3,3,void
918,49452,NewestFirst,1,leveldb.NewestFirst,"bool leveldb.NewestFirst (FileMetaData*,FileMetaData*)",db\version_set.cc,"static bool NewestFirst(FileMetaData* a, FileMetaData* b) {
  return a->number > b->number;
}",283.0,285.0,1.0,1.0,3.0,3,2,2,2,0,2,1,1,0,0,,0,2,4,2,2,bool
919,49466,ForEachOverlapping,1,leveldb.Version.ForEachOverlapping,"void leveldb.Version.ForEachOverlapping (Slice,Slice,void*,bool)",db\version_set.cc,"void Version::ForEachOverlapping(Slice user_key, Slice internal_key,
                                 void* arg,
                                 bool (*func)(void*, int, FileMetaData*)) {
  // TODO(sanjay): Change Version::Get() to use this function.
  const Comparator* ucmp = vset_->icmp_.user_comparator();

  // Search level-0 in order from newest to oldest.
  std::vector<FileMetaData*> tmp;
  tmp.reserve(files_[0].size());
  for (uint32_t i = 0; i < files_[0].size(); i++) {
    FileMetaData* f = files_[0][i];
    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
      tmp.push_back(f);
    }
  }
  if (!tmp.empty()) {
    std::sort(tmp.begin(), tmp.end(), NewestFirst);
    for (uint32_t i = 0; i < tmp.size(); i++) {
      if (!(*func)(arg, 0, tmp[i])) {
        return;
      }
    }
  }

  // Search other levels.
  for (int level = 1; level < config::kNumLevels; level++) {
    size_t num_files = files_[level...",287.0,330.0,1.0,1.0,44.0,52,11,50,15,0,11,11,18,4,0,,0,11,8,4,4,void
920,49680,Get,1,leveldb.Version.Get,"Status leveldb.Version.Get (ReadOptions,LookupKey,ANY*,GetStats*)",db\version_set.cc,"Status Version::Get(const ReadOptions& options,
                    const LookupKey& k,
                    std::string* value,
                    GetStats* stats) {
  Slice ikey = k.internal_key();
  Slice user_key = k.user_key();
  const Comparator* ucmp = vset_->icmp_.user_comparator();
  Status s;

  stats->seek_file = NULL;
  stats->seek_file_level = -1;
  FileMetaData* last_file_read = NULL;
  int last_file_read_level = -1;

  // We can search level-by-level since entries never hop across
  // levels.  Therefore we are guaranteed that if we find data
  // in an smaller level, later levels are irrelevant.
  std::vector<FileMetaData*> tmp;
  FileMetaData* tmp2;
  for (int level = 0; level < config::kNumLevels; level++) {
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Get the list of files to search in this level
    FileMetaData* const* files = &files_[level][0];
    if (level == 0) {
      // Level-0 files may overlap each other.  Find a...",332.0,429.0,1.0,1.0,98.0,87,13,96,27,0,21,14,27,4,3,,0,20,8,4,4,Status
921,50062,UpdateStats,1,leveldb.Version.UpdateStats,bool leveldb.Version.UpdateStats (GetStats),db\version_set.cc,"bool Version::UpdateStats(const GetStats& stats) {
  FileMetaData* f = stats.seek_file;
  if (f != NULL) {
    f->allowed_seeks--;
    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }
  }
  return false;
}",431.0,442.0,1.0,1.0,12.0,12,8,12,5,0,7,3,4,2,0,,0,7,2,1,1,bool
922,50105,RecordReadSample,1,leveldb.Version.RecordReadSample,bool leveldb.Version.RecordReadSample (Slice),db\version_set.cc,"bool Version::RecordReadSample(Slice internal_key) {
  ParsedInternalKey ikey;
  if (!ParseInternalKey(internal_key, &ikey)) {
    return false;
  }

  struct State {
    GetStats stats;  // Holds first matching file
    int matches;

    static bool Match(void* arg, int level, FileMetaData* f) {
      State* state = reinterpret_cast<State*>(arg);
      state->matches++;
      if (state->matches == 1) {
        // Remember first match.
        state->stats.seek_file = f;
        state->stats.seek_file_level = level;
      }
      // We can stop iterating once we have a second match.
      return state->matches < 2;
    }
  };

  State state;
  state.matches = 0;
  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);

  // Must have at least two matches since we want to merge across
  // files. But what if we have a single file that contains many
  // overwrites and deletions?  Should we have another mechanism for
  // finding such files?
  if (state.matches >= 2) ...",444.0,480.0,1.0,1.0,37.0,11,5,9,4,0,1,3,3,0,0,,0,1,2,1,1,bool
923,50151,Ref,1,leveldb.Version.Ref,void leveldb.Version.Ref (),db\version_set.cc,"void Version::Ref() {
  ++refs_;
}",482.0,484.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
924,50157,Unref,1,leveldb.Version.Unref,void leveldb.Version.Unref (),db\version_set.cc,"void Version::Unref() {
  assert(this != &vset_->dummy_versions_);
  assert(refs_ >= 1);
  --refs_;
  if (refs_ == 0) {
    delete this;
  }
}",486.0,493.0,1.0,1.0,8.0,7,7,4,2,0,4,2,2,1,0,,0,4,0,0,0,void
925,50181,OverlapInLevel,1,leveldb.Version.OverlapInLevel,"bool leveldb.Version.OverlapInLevel (int,Slice*,Slice*)",db\version_set.cc,"bool Version::OverlapInLevel(int level,
                             const Slice* smallest_user_key,
                             const Slice* largest_user_key) {
  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],
                               smallest_user_key, largest_user_key);
}",495.0,500.0,1.0,1.0,6.0,3,3,6,5,0,2,1,1,0,0,,0,2,6,3,3,bool
926,50201,PickLevelForMemTableOutput,1,leveldb.Version.PickLevelForMemTableOutput,"int leveldb.Version.PickLevelForMemTableOutput (Slice,Slice)",db\version_set.cc,"int Version::PickLevelForMemTableOutput(
    const Slice& smallest_user_key,
    const Slice& largest_user_key) {
  int level = 0;
  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
    std::vector<FileMetaData*> overlaps;
    while (level < config::kMaxMemCompactLevel) {
      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
        break;
      }
      if (level + 2 < config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
 ...",502.0,528.0,1.0,1.0,27.0,21,10,24,11,0,1,8,14,1,0,,0,1,4,2,2,int
927,50288,GetOverlappingInputs,1,leveldb.Version.GetOverlappingInputs,"void leveldb.Version.GetOverlappingInputs (int,InternalKey*,InternalKey*,ANY*)",db\version_set.cc,"void Version::GetOverlappingInputs(
    int level,
    const InternalKey* begin,
    const InternalKey* end,
    std::vector<FileMetaData*>* inputs) {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  inputs->clear();
  Slice user_begin, user_end;
  if (begin != NULL) {
    user_begin = begin->user_key();
  }
  if (end != NULL) {
    user_end = end->user_key();
  }
  const Comparator* user_cmp = vset_->icmp_.user_comparator();
  for (size_t i = 0; i < files_[level].size(); ) {
    FileMetaData* f = files_[level][i++];
    const Slice file_start = f->smallest.user_key();
    const Slice file_limit = f->largest.user_key();
    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {
      // ""f"" is completely before specified range; skip it
    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {
      // ""f"" is completely after specified range; skip it
    } else {
      inputs->push_back(f);
      if (level == 0) {
        // Level-0 file...",531.0,572.0,1.0,1.0,42.0,31,9,31,15,0,5,5,6,1,0,,0,5,8,4,4,void
928,50477,DebugString,1,leveldb.Version.DebugString,string leveldb.Version.DebugString (),db\version_set.cc,"std::string Version::DebugString() const {
  std::string r;
  for (int level = 0; level < config::kNumLevels; level++) {
    // E.g.,
    //   --- level 1 ---
    //   17:123['a' .. 'd']
    //   20:43['e' .. 'g']
    r.append(""--- level "");
    AppendNumberTo(&r, level);
    r.append("" ---\n"");
    const std::vector<FileMetaData*>& files = files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      r.push_back(' ');
      AppendNumberTo(&r, files[i]->number);
      r.push_back(':');
      AppendNumberTo(&r, files[i]->file_size);
      r.append(""["");
      r.append(files[i]->smallest.DebugString());
      r.append("" .. "");
      r.append(files[i]->largest.DebugString());
      r.append(""]\n"");
    }
  }
  return r;
}",574.0,598.0,1.0,1.0,25.0,30,6,31,6,0,1,3,4,0,0,,0,1,0,0,0,string
929,50601,operator (),1,leveldb.Builder.BySmallestKey.operator (),"bool leveldb.Builder.BySmallestKey.operator () (FileMetaData*,FileMetaData*)",db\version_set.cc,"bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }",609.0,617.0,5.0,5.0,9.0,6,4,6,4,0,2,2,2,0,0,,0,2,4,2,2,bool
930,50646,Builder,1,leveldb.Builder.Builder,"ANY leveldb.Builder.Builder (VersionSet*,Version*)",db\version_set.cc,"Builder(VersionSet* vset, Version* base)
      : vset_(vset),
        base_(base) {
    base_->Ref();
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      levels_[level].added_files = new FileSet(cmp);
    }
  }",632.0,641.0,3.0,3.0,10.0,12,7,10,7,0,4,2,2,0,0,,0,4,4,2,2,ANY
931,50688,~Builder,1,leveldb.Builder.~Builder,ANY leveldb.Builder.~Builder (),db\version_set.cc,"~Builder() {
    for (int level = 0; level < config::kNumLevels; level++) {
      const FileSet* added = levels_[level].added_files;
      std::vector<FileMetaData*> to_unref;
      to_unref.reserve(added->size());
      for (FileSet::const_iterator it = added->begin();
          it != added->end(); ++it) {
        to_unref.push_back(*it);
      }
      delete added;
      for (uint32_t i = 0; i < to_unref.size(); i++) {
        FileMetaData* f = to_unref[i];
        f->refs--;
        if (f->refs <= 0) {
          delete f;
        }
      }
    }
    base_->Unref();
  }",643.0,662.0,3.0,3.0,20.0,26,10,25,9,0,4,5,9,1,0,,0,4,0,0,0,ANY
932,50787,Apply,1,leveldb.Builder.Apply,void leveldb.Builder.Apply (VersionEdit*),db\version_set.cc,"void Apply(VersionEdit* edit) {
    // Update compaction pointers
    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {
      const int level = edit->compact_pointers_[i].first;
      vset_->compact_pointer_[level] =
          edit->compact_pointers_[i].second.Encode().ToString();
    }

    // Delete files
    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;
    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
         iter != del.end();
         ++iter) {
      const int level = iter->first;
      const uint64_t number = iter->second;
      levels_[level].deleted_files.insert(number);
    }

    // Add new files
    for (size_t i = 0; i < edit->new_files_.size(); i++) {
      const int level = edit->new_files_[i].first;
      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
      f->refs = 1;

      // We arrange to automatically compact this file after
      // a certain number of seeks.  Let's assume:
      //   (1) On...",665.0,708.0,3.0,3.0,44.0,59,8,44,10,0,17,5,6,3,0,,0,17,2,1,1,void
933,50968,SaveTo,1,leveldb.Builder.SaveTo,void leveldb.Builder.SaveTo (Version*),db\version_set.cc,"void SaveTo(Version* v) {
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      // Merge the set of added files with the set of pre-existing files.
      // Drop any deleted files.  Store the result in *v.
      const std::vector<FileMetaData*>& base_files = base_->files_[level];
      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
      const FileSet* added = levels_[level].added_files;
      v->files_[level].reserve(base_files.size() + added->size());
      for (FileSet::const_iterator added_iter = added->begin();
           added_iter != added->end();
           ++added_iter) {
        // Add all smaller files listed in base_
        for (std::vector<FileMetaData*>::const_iterator bpos
                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
             base_iter != bpos;
  ...",711.0,757.0,3.0,3.0,47.0,59,12,61,18,0,9,8,18,2,0,,0,9,2,1,1,void
934,51184,MaybeAddFile,1,leveldb.Builder.MaybeAddFile,"void leveldb.Builder.MaybeAddFile (Version*,int,FileMetaData*)",db\version_set.cc,"void MaybeAddFile(Version* v, int level, FileMetaData* f) {
    if (levels_[level].deleted_files.count(f->number) > 0) {
      // File is deleted: do nothing
    } else {
      std::vector<FileMetaData*>* files = &v->files_[level];
      if (level > 0 && !files->empty()) {
        // Must not overlap
        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
                                    f->smallest) < 0);
      }
      f->refs++;
      files->push_back(f);
    }
  }",759.0,772.0,3.0,3.0,14.0,5,4,3,3,0,2,2,2,2,0,,0,2,6,3,3,void
935,51280,~VersionSet,1,leveldb.VersionSet.~VersionSet,ANY leveldb.VersionSet.~VersionSet (),db\version_set.cc,"VersionSet::~VersionSet() {
  current_->Unref();
  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty
  delete descriptor_log_;
  delete descriptor_file_;
}",796.0,801.0,1.0,1.0,6.0,6,5,5,4,0,5,1,1,0,0,,0,5,0,0,0,ANY
936,51299,AppendVersion,1,leveldb.VersionSet.AppendVersion,void leveldb.VersionSet.AppendVersion (Version*),db\version_set.cc,"void VersionSet::AppendVersion(Version* v) {
  // Make ""v"" current
  assert(v->refs_ == 0);
  assert(v != current_);
  if (current_ != NULL) {
    current_->Unref();
  }
  current_ = v;
  v->Ref();

  // Append to linked list
  v->prev_ = dummy_versions_.prev_;
  v->next_ = &dummy_versions_;
  v->prev_->next_ = v;
  v->next_->prev_ = v;
}",803.0,818.0,1.0,1.0,16.0,19,6,17,4,0,11,2,2,1,0,,0,11,2,1,1,void
937,51357,LogAndApply,1,leveldb.VersionSet.LogAndApply,"Status leveldb.VersionSet.LogAndApply (VersionEdit*,ANY*)",db\version_set.cc,"Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {
  if (edit->has_log_number_) {
    assert(edit->log_number_ >= log_number_);
    assert(edit->log_number_ < next_file_number_);
  } else {
    edit->SetLogNumber(log_number_);
  }

  if (!edit->has_prev_log_number_) {
    edit->SetPrevLogNumber(prev_log_number_);
  }

  edit->SetNextFile(next_file_number_);
  edit->SetLastSequence(last_sequence_);

  Version* v = new Version(this);
  {
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  // Initialize new descriptor log file if necessary by creating
  // a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s;
  if (descriptor_log_ == NULL) {
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname...",820.0,903.0,1.0,1.0,84.0,50,10,66,21,0,30,10,13,3,0,,0,30,4,2,2,Status
938,51600,Recover,1,leveldb.VersionSet.Recover,Status leveldb.VersionSet.Recover (bool*),db\version_set.cc,"Status VersionSet::Recover(bool *save_manifest) {
  struct LogReporter : public log::Reader::Reporter {
    Status* status;
    virtual void Corruption(size_t bytes, const Status& s) {
      if (this->status->ok()) *this->status = s;
    }
  };

  // Read ""CURRENT"" file, which contains a pointer to the current manifest file
  std::string current;
  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);
  if (!s.ok()) {
    return s;
  }
  if (current.empty() || current[current.size()-1] != '\n') {
    return Status::Corruption(""CURRENT file does not end with newline"");
  }
  current.resize(current.size() - 1);

  std::string dscname = dbname_ + ""/"" + current;
  SequentialFile* file;
  s = env_->NewSequentialFile(dscname, &file);
  if (!s.ok()) {
    return s;
  }

  bool have_log_number = false;
  bool have_prev_log_number = false;
  bool have_next_file = false;
  bool have_last_sequence = false;
  uint64_t next_file = 0;
  uint64_t last_sequence = 0;
  uint64_t log_...",905.0,1025.0,1.0,1.0,121.0,91,13,99,31,0,26,17,28,7,3,,0,25,2,1,1,Status
939,51975,ReuseManifest,1,leveldb.VersionSet.ReuseManifest,"bool leveldb.VersionSet.ReuseManifest (ANY,ANY)",db\version_set.cc,"bool VersionSet::ReuseManifest(const std::string& dscname,
                               const std::string& dscbase) {
  if (!options_->reuse_logs) {
    return false;
  }
  FileType manifest_type;
  uint64_t manifest_number;
  uint64_t manifest_size;
  if (!ParseFileName(dscbase, &manifest_number, &manifest_type) ||
      manifest_type != kDescriptorFile ||
      !env_->GetFileSize(dscname, &manifest_size).ok() ||
      // Make new compacted MANIFEST if old one is too big
      manifest_size >= TargetFileSize(options_)) {
    return false;
  }

  assert(descriptor_file_ == NULL);
  assert(descriptor_log_ == NULL);
  Status r = env_->NewAppendableFile(dscname, &descriptor_file_);
  if (!r.ok()) {
    Log(options_->info_log, ""Reuse MANIFEST: %s\n"", r.ToString().c_str());
    assert(descriptor_file_ == NULL);
    return false;
  }

  Log(options_->info_log, ""Reusing MANIFEST %s\n"", dscname.c_str());
  descriptor_log_ = new log::Writer(descriptor_file_, manifest_size);
  manifest_file...",1027.0,1056.0,1.0,1.0,30.0,30,10,32,14,0,13,4,4,3,0,,0,13,4,2,2,bool
940,52087,MarkFileNumberUsed,1,leveldb.VersionSet.MarkFileNumberUsed,void leveldb.VersionSet.MarkFileNumberUsed (uint64_t),db\version_set.cc,"void VersionSet::MarkFileNumberUsed(uint64_t number) {
  if (next_file_number_ <= number) {
    next_file_number_ = number + 1;
  }
}",1058.0,1062.0,1.0,1.0,5.0,3,3,4,2,0,2,2,2,1,0,,0,2,2,1,1,void
941,52102,Finalize,1,leveldb.VersionSet.Finalize,void leveldb.VersionSet.Finalize (Version*),db\version_set.cc,"void VersionSet::Finalize(Version* v) {
  // Precomputed best level for next compaction
  int best_level = -1;
  double best_score = -1;

  for (int level = 0; level < config::kNumLevels-1; level++) {
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v->files_[level].size() /
          static_cast<double>(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFi...",1064.0,1100.0,1.0,1.0,37.0,23,11,20,6,0,3,4,6,0,0,,0,3,2,1,1,void
942,52196,WriteSnapshot,1,leveldb.VersionSet.WriteSnapshot,Status leveldb.VersionSet.WriteSnapshot (ANY*),db\version_set.cc,"Status VersionSet::WriteSnapshot(log::Writer* log) {
  // TODO: Break up into multiple records to reduce memory usage on recovery?

  // Save metadata
  VersionEdit edit;
  edit.SetComparatorName(icmp_.user_comparator()->Name());

  // Save compaction pointers
  for (int level = 0; level < config::kNumLevels; level++) {
    if (!compact_pointer_[level].empty()) {
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  // Save files
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = current_->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
    }
  }

  std::string record;
  edit.EncodeTo(&record);
  return log->AddRecord(record);
}",1102.0,1130.0,1.0,1.0,29.0,31,7,35,12,0,8,5,7,1,0,,0,8,2,1,1,Status
943,52323,NumLevelFiles,1,leveldb.VersionSet.NumLevelFiles,int leveldb.VersionSet.NumLevelFiles (int),db\version_set.cc,"int VersionSet::NumLevelFiles(int level) const {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return current_->files_[level].size();
}",1132.0,1136.0,1.0,1.0,5.0,6,5,5,3,0,1,1,1,0,0,,0,1,2,1,1,int
944,52347,LevelSummary,1,leveldb.VersionSet.LevelSummary,const char* leveldb.VersionSet.LevelSummary (LevelSummaryStorage*),db\version_set.cc,"const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {
  // Update code if kNumLevels changes
  assert(config::kNumLevels == 7);
  snprintf(scratch->buffer, sizeof(scratch->buffer),
           ""files[ %d %d %d %d %d %d %d ]"",
           int(current_->files_[0].size()),
           int(current_->files_[1].size()),
           int(current_->files_[2].size()),
           int(current_->files_[3].size()),
           int(current_->files_[4].size()),
           int(current_->files_[5].size()),
           int(current_->files_[6].size()));
  return scratch->buffer;
}",1138.0,1151.0,1.0,1.0,14.0,34,6,11,3,0,10,1,1,0,0,,0,10,2,1,1,const char*
945,52441,ApproximateOffsetOf,1,leveldb.VersionSet.ApproximateOffsetOf,"uint64_t leveldb.VersionSet.ApproximateOffsetOf (Version*,InternalKey)",db\version_set.cc,"uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {
  uint64_t result = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = v->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      } else {
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOption...",1153.0,1183.0,1.0,1.0,31.0,17,7,18,8,0,2,4,7,1,0,,0,2,4,2,2,uint64_t
946,52573,AddLiveFiles,1,leveldb.VersionSet.AddLiveFiles,void leveldb.VersionSet.AddLiveFiles (ANY*),db\version_set.cc,"void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {
  for (Version* v = dummy_versions_.next_;
       v != &dummy_versions_;
       v = v->next_) {
    for (int level = 0; level < config::kNumLevels; level++) {
      const std::vector<FileMetaData*>& files = v->files_[level];
      for (size_t i = 0; i < files.size(); i++) {
        live->insert(files[i]->number);
      }
    }
  }
}",1185.0,1196.0,1.0,1.0,12.0,16,7,16,7,0,2,4,7,1,0,,0,2,2,1,1,void
947,52642,NumLevelBytes,1,leveldb.VersionSet.NumLevelBytes,int64_t leveldb.VersionSet.NumLevelBytes (int),db\version_set.cc,"int64_t VersionSet::NumLevelBytes(int level) const {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return TotalFileSize(current_->files_[level]);
}",1198.0,1202.0,1.0,1.0,5.0,5,5,5,3,0,1,1,1,0,0,,0,1,2,1,1,int64_t
948,52664,MaxNextLevelOverlappingBytes,1,leveldb.VersionSet.MaxNextLevelOverlappingBytes,int64_t leveldb.VersionSet.MaxNextLevelOverlappingBytes (),db\version_set.cc,"int64_t VersionSet::MaxNextLevelOverlappingBytes() {
  int64_t result = 0;
  std::vector<FileMetaData*> overlaps;
  for (int level = 1; level < config::kNumLevels - 1; level++) {
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      const FileMetaData* f = current_->files_[level][i];
      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
                                     &overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum > result) {
        result = sum;
      }
    }
  }
  return result;
}",1204.0,1219.0,1.0,1.0,16.0,24,9,24,8,0,5,4,7,1,0,,0,5,0,0,0,int64_t
949,52750,GetRange,1,leveldb.VersionSet.GetRange,"void leveldb.VersionSet.GetRange (ANY,InternalKey*,InternalKey*)",db\version_set.cc,"void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,
                          InternalKey* smallest,
                          InternalKey* largest) {
  assert(!inputs.empty());
  smallest->Clear();
  largest->Clear();
  for (size_t i = 0; i < inputs.size(); i++) {
    FileMetaData* f = inputs[i];
    if (i == 0) {
      *smallest = f->smallest;
      *largest = f->largest;
    } else {
      if (icmp_.Compare(f->smallest, *smallest) < 0) {
        *smallest = f->smallest;
      }
      if (icmp_.Compare(f->largest, *largest) > 0) {
        *largest = f->largest;
      }
    }
  }
}",1224.0,1244.0,1.0,1.0,21.0,16,8,14,5,0,2,3,4,0,0,,0,2,6,3,3,void
950,52881,MakeInputIterator,1,leveldb.VersionSet.MakeInputIterator,Iterator leveldb.VersionSet.MakeInputIterator (Compaction*),db\version_set.cc,"Iterator* VersionSet::MakeInputIterator(Compaction* c) {
  ReadOptions options;
  options.verify_checksums = options_->paranoid_checks;
  options.fill_cache = false;

  // Level-0 files have to be merged together.  For other levels,
  // we will make a concatenating iterator per level.
  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);
  Iterator** list = new Iterator*[space];
  int num = 0;
  for (int which = 0; which < 2; which++) {
    if (!c->inputs_[which].empty()) {
      if (c->level() + which == 0) {
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            ...",1258.0,1289.0,1.0,1.0,32.0,43,14,37,13,0,8,5,11,1,0,,0,8,2,1,1,Iterator
951,53042,PickCompaction,1,leveldb.VersionSet.PickCompaction,Compaction leveldb.VersionSet.PickCompaction (),db\version_set.cc,"Compaction* VersionSet::PickCompaction() {
  Compaction* c;
  int level;

  // We prefer compactions triggered by too much data in a level over
  // the compactions triggered by seeks.
  const bool size_compaction = (current_->compaction_score_ >= 1);
  const bool seek_compaction = (current_->file_to_compact_ != NULL);
  if (size_compaction) {
    level = current_->compaction_level_;
    assert(level >= 0);
    assert(level+1 < config::kNumLevels);
    c = new Compaction(options_, level);

    // Pick the first file that comes after compact_pointer_[level]
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      FileMetaData* f = current_->files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
        c->inputs_[0].push_back(f);
        break;
      }
    }
    if (c->inputs_[0].empty()) {
      // Wrap-around to the beginning of the key space
      c->inputs_[0].push_back(current_->f...",1291.0,1343.0,1.0,1.0,53.0,62,14,49,15,0,21,7,10,6,0,,0,21,0,0,0,Compaction
952,53266,SetupOtherInputs,1,leveldb.VersionSet.SetupOtherInputs,void leveldb.VersionSet.SetupOtherInputs (Compaction*),db\version_set.cc,"void VersionSet::SetupOtherInputs(Compaction* c) {
  const int level = c->level();
  InternalKey smallest, largest;
  GetRange(c->inputs_[0], &smallest, &largest);

  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);

  // Get entire range covered by compaction
  InternalKey all_start, all_limit;
  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);

  // See if we can grow the number of inputs in ""level"" without
  // changing the number of ""level+1"" files we pick up.
  if (!c->inputs_[1].empty()) {
    std::vector<FileMetaData*> expanded0;
    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
    const int64_t expanded0_size = TotalFileSize(expanded0);
    if (expanded0.size() > c->inputs_[0].size() &&
        inputs1_size + expanded0_size <
            ExpandedCompactionByteSizeLimit(options_...",1345.0,1411.0,1.0,1.0,67.0,105,12,80,17,0,25,6,9,4,0,,0,25,2,1,1,void
953,53580,CompactRange,1,leveldb.VersionSet.CompactRange,"Compaction leveldb.VersionSet.CompactRange (int,InternalKey*,InternalKey*)",db\version_set.cc,"Compaction* VersionSet::CompactRange(
    int level,
    const InternalKey* begin,
    const InternalKey* end) {
  std::vector<FileMetaData*> inputs;
  current_->GetOverlappingInputs(level, begin, end, &inputs);
  if (inputs.empty()) {
    return NULL;
  }

  // Avoid compacting too much in one shot in case the range is large.
  // But we cannot do this for level-0 since level-0 files can overlap
  // and we must not pick one file and drop another older file if the
  // two files overlap.
  if (level > 0) {
    const uint64_t limit = MaxFileSizeForLevel(options_, level);
    uint64_t total = 0;
    for (size_t i = 0; i < inputs.size(); i++) {
      uint64_t s = inputs[i]->file_size;
      total += s;
      if (total >= limit) {
        inputs.resize(i + 1);
        break;
      }
    }
  }

  Compaction* c = new Compaction(options_, level);
  c->input_version_ = current_;
  c->input_version_->Ref();
  c->inputs_[0] = inputs;
  SetupOtherInputs(c);
  return c;
}",1413.0,1446.0,1.0,1.0,34.0,25,11,35,13,0,7,6,8,0,0,,0,7,6,3,3,Compaction
954,53688,Compaction,1,leveldb.Compaction.Compaction,"ANY leveldb.Compaction.Compaction (Options*,int)",db\version_set.cc,"Compaction::Compaction(const Options* options, int level)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(options, level)),
      input_version_(NULL),
      grandparent_index_(0),
      seen_key_(false),
      overlapped_bytes_(0) {
  for (int i = 0; i < config::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}",1448.0,1458.0,1.0,1.0,11.0,5,4,5,3,0,1,2,2,0,0,,0,1,4,2,2,ANY
955,53713,~Compaction,1,leveldb.Compaction.~Compaction,ANY leveldb.Compaction.~Compaction (),db\version_set.cc,"Compaction::~Compaction() {
  if (input_version_ != NULL) {
    input_version_->Unref();
  }
}",1460.0,1464.0,1.0,1.0,5.0,2,2,3,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
956,53726,IsTrivialMove,1,leveldb.Compaction.IsTrivialMove,bool leveldb.Compaction.IsTrivialMove (),db\version_set.cc,"bool Compaction::IsTrivialMove() const {
  const VersionSet* vset = input_version_->vset_;
  // Avoid a move if there is lots of overlapping grandparent data.
  // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&
          TotalFileSize(grandparents_) <=
              MaxGrandParentOverlapBytes(vset->options_));
}",1466.0,1474.0,1.0,1.0,9.0,8,5,4,3,0,3,1,1,0,0,,0,3,0,0,0,bool
957,53754,AddInputDeletions,1,leveldb.Compaction.AddInputDeletions,void leveldb.Compaction.AddInputDeletions (VersionEdit*),db\version_set.cc,"void Compaction::AddInputDeletions(VersionEdit* edit) {
  for (int which = 0; which < 2; which++) {
    for (size_t i = 0; i < inputs_[which].size(); i++) {
      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
    }
  }
}",1476.0,1482.0,1.0,1.0,7.0,11,6,12,5,0,3,3,4,1,0,,0,3,2,1,1,void
958,53802,IsBaseLevelForKey,1,leveldb.Compaction.IsBaseLevelForKey,bool leveldb.Compaction.IsBaseLevelForKey (Slice),db\version_set.cc,"bool Compaction::IsBaseLevelForKey(const Slice& user_key) {
  // Maybe use binary search to find right entry instead of linear search?
  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();
  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {
    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
    for (; level_ptrs_[lvl] < files.size(); ) {
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }
  }
  return true;
}",1484.0,1503.0,1.0,1.0,20.0,27,9,24,9,0,8,6,11,3,0,,0,8,2,1,1,bool
959,53900,ShouldStopBefore,1,leveldb.Compaction.ShouldStopBefore,bool leveldb.Compaction.ShouldStopBefore (Slice),db\version_set.cc,"bool Compaction::ShouldStopBefore(const Slice& internal_key) {
  const VersionSet* vset = input_version_->vset_;
  // Scan to find earliest grandparent file that contains key.
  const InternalKeyComparator* icmp = &vset->icmp_;
  while (grandparent_index_ < grandparents_.size() &&
      icmp->Compare(internal_key,
                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = true;

  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0;
    return true;
  } else {
    return false;
  }
}",1505.0,1526.0,1.0,1.0,22.0,21,10,19,8,0,15,4,5,7,0,,0,15,2,1,1,bool
960,53974,ReleaseInputs,1,leveldb.Compaction.ReleaseInputs,void leveldb.Compaction.ReleaseInputs (),db\version_set.cc,"void Compaction::ReleaseInputs() {
  if (input_version_ != NULL) {
    input_version_->Unref();
    input_version_ = NULL;
  }
}",1528.0,1533.0,1.0,1.0,6.0,3,3,5,2,0,3,2,2,1,0,,0,3,0,0,0,void
961,54093,NumFiles,1,leveldb.Version.NumFiles,int leveldb.Version.NumFiles (int),db\version_set.hpp,int NumFiles(int level) const { return files_[level].size(); },111.0,111.0,3.0,64.0,1.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
962,54186,current,1,leveldb.VersionSet.current,Version leveldb.VersionSet.current (),db\version_set.hpp,Version* current() const { return current_; },185.0,185.0,3.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Version
963,54192,ManifestFileNumber,1,leveldb.VersionSet.ManifestFileNumber,uint64_t leveldb.VersionSet.ManifestFileNumber (),db\version_set.hpp,uint64_t ManifestFileNumber() const { return manifest_file_number_; },188.0,188.0,3.0,71.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
964,54198,NewFileNumber,1,leveldb.VersionSet.NewFileNumber,uint64_t leveldb.VersionSet.NewFileNumber (),db\version_set.hpp,uint64_t NewFileNumber() { return next_file_number_++; },191.0,191.0,3.0,58.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
965,54205,ReuseFileNumber,1,leveldb.VersionSet.ReuseFileNumber,void leveldb.VersionSet.ReuseFileNumber (uint64_t),db\version_set.hpp,"void ReuseFileNumber(uint64_t file_number) {
    if (next_file_number_ == file_number + 1) {
      next_file_number_ = file_number;
    }
  }",196.0,200.0,3.0,3.0,5.0,3,3,4,2,0,2,2,2,1,0,,0,2,2,1,1,void
966,54230,LastSequence,1,leveldb.VersionSet.LastSequence,uint64_t leveldb.VersionSet.LastSequence (),db\version_set.hpp,uint64_t LastSequence() const { return last_sequence_; },209.0,209.0,3.0,58.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
967,54236,SetLastSequence,1,leveldb.VersionSet.SetLastSequence,void leveldb.VersionSet.SetLastSequence (uint64_t),db\version_set.hpp,"void SetLastSequence(uint64_t s) {
    assert(s >= last_sequence_);
    last_sequence_ = s;
  }",212.0,215.0,3.0,3.0,4.0,2,2,4,2,0,2,1,1,0,0,,0,2,2,1,1,void
968,54253,LogNumber,1,leveldb.VersionSet.LogNumber,uint64_t leveldb.VersionSet.LogNumber (),db\version_set.hpp,uint64_t LogNumber() const { return log_number_; },221.0,221.0,3.0,52.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
969,54259,PrevLogNumber,1,leveldb.VersionSet.PrevLogNumber,uint64_t leveldb.VersionSet.PrevLogNumber (),db\version_set.hpp,uint64_t PrevLogNumber() const { return prev_log_number_; },225.0,225.0,3.0,61.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
970,54285,NeedsCompaction,1,leveldb.VersionSet.NeedsCompaction,bool leveldb.VersionSet.NeedsCompaction (),db\version_set.hpp,"bool NeedsCompaction() const {
    Version* v = current_;
    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);
  }",251.0,254.0,3.0,3.0,4.0,6,5,5,3,0,3,1,1,0,0,,0,3,0,0,0,bool
971,54411,level,1,leveldb.Compaction.level,int leveldb.Compaction.level (),db\version_set.hpp,int level() const { return level_; },330.0,330.0,3.0,38.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,int
972,54417,edit,1,leveldb.Compaction.edit,VersionEdit leveldb.Compaction.edit (),db\version_set.hpp,VersionEdit* edit() { return &edit_; },334.0,334.0,3.0,40.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,VersionEdit
973,54424,num_input_files,1,leveldb.Compaction.num_input_files,int leveldb.Compaction.num_input_files (int),db\version_set.hpp,int num_input_files(int which) const { return inputs_[which].size(); },337.0,337.0,3.0,72.0,1.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,int
974,54436,input,1,leveldb.Compaction.input,"FileMetaData leveldb.Compaction.input (int,int)",db\version_set.hpp,"FileMetaData* input(int which, int i) const { return inputs_[which][i]; }",340.0,340.0,3.0,75.0,1.0,2,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,FileMetaData
975,54448,MaxOutputFileSize,1,leveldb.Compaction.MaxOutputFileSize,uint64_t leveldb.Compaction.MaxOutputFileSize (),db\version_set.hpp,uint64_t MaxOutputFileSize() const { return max_output_file_size_; },343.0,343.0,3.0,70.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
976,54526,~FindFileTest,1,leveldb.FindFileTest.~FindFileTest,ANY leveldb.FindFileTest.~FindFileTest (),db\version_set_test.cc,"~FindFileTest() {
    for (int i = 0; i < files_.size(); i++) {
      delete files_[i];
    }
  }",19.0,23.0,3.0,3.0,5.0,5,5,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
977,54549,Add,1,leveldb.FindFileTest.Add,"void leveldb.FindFileTest.Add (char*,char*,SequenceNumber,SequenceNumber)",db\version_set_test.cc,"void Add(const char* smallest, const char* largest,
           SequenceNumber smallest_seq = 100,
           SequenceNumber largest_seq = 100) {
    FileMetaData* f = new FileMetaData;
    f->number = files_.size() + 1;
    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);
    f->largest = InternalKey(largest, largest_seq, kTypeValue);
    files_.push_back(f);
  }",25.0,33.0,3.0,3.0,9.0,11,5,14,8,0,5,1,1,0,0,,0,5,8,4,4,void
978,54593,Find,1,leveldb.FindFileTest.Find,int leveldb.FindFileTest.Find (char*),db\version_set_test.cc,"int Find(const char* key) {
    InternalKey target(key, 100, kTypeValue);
    InternalKeyComparator cmp(BytewiseComparator());
    return FindFile(cmp, files_, target.Encode());
  }",35.0,39.0,3.0,3.0,5.0,1,1,5,5,0,1,1,1,0,0,,0,1,2,1,1,int
979,54614,Overlaps,1,leveldb.FindFileTest.Overlaps,"bool leveldb.FindFileTest.Overlaps (char*,char*)",db\version_set_test.cc,"bool Overlaps(const char* smallest, const char* largest) {
    InternalKeyComparator cmp(BytewiseComparator());
    Slice s(smallest != NULL ? smallest : """");
    Slice l(largest != NULL ? largest : """");
    return SomeFileOverlapsRange(cmp, disjoint_sorted_files_, files_,
                                 (smallest != NULL ? &s : NULL),
                                 (largest != NULL ? &l : NULL));
  }",41.0,48.0,3.0,3.0,8.0,10,3,17,8,0,2,1,1,0,0,,0,2,4,2,2,bool
980,56507,Clear,1,leveldb.WriteBatch.Clear,void leveldb.WriteBatch.Clear (),db\write_batch.cc,"void WriteBatch::Clear() {
  rep_.clear();
  rep_.resize(kHeader);
}",37.0,40.0,1.0,1.0,4.0,2,1,3,2,0,2,1,1,0,0,,0,2,0,0,0,void
981,56520,Iterate,1,leveldb.WriteBatch.Iterate,Status leveldb.WriteBatch.Iterate (Handler*),db\write_batch.cc,"Status WriteBatch::Iterate(Handler* handler) const {
  Slice input(rep_);
  if (input.size() < kHeader) {
    return Status::Corruption(""malformed WriteBatch (too small)"");
  }

  input.remove_prefix(kHeader);
  Slice key, value;
  int found = 0;
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption(""bad WriteBatch Put"");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption(""bad WriteBatch Delete"");
        }
        break;
      default:
        return Status::Corruption(""unknown WriteBatch tag"");
    }
  }
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Cor...",42.0,80.0,1.0,1.0,39.0,24,10,30,12,0,4,9,12,0,3,,0,1,2,1,1,Status
982,56658,Count,1,leveldb.WriteBatchInternal.Count,int leveldb.WriteBatchInternal.Count (WriteBatch*),db\write_batch.cc,"int WriteBatchInternal::Count(const WriteBatch* b) {
  return DecodeFixed32(b->rep_.data() + 8);
}",82.0,84.0,1.0,1.0,3.0,3,3,1,1,4,1,1,1,0,0,,0,1,2,1,1,int
983,56673,SetCount,1,leveldb.WriteBatchInternal.SetCount,"void leveldb.WriteBatchInternal.SetCount (WriteBatch*,int)",db\write_batch.cc,"void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
  EncodeFixed32(&b->rep_[8], n);
}",86.0,88.0,1.0,1.0,3.0,3,3,2,2,3,1,1,1,0,0,,0,1,4,2,2,void
984,56687,Sequence,1,leveldb.WriteBatchInternal.Sequence,SequenceNumber leveldb.WriteBatchInternal.Sequence (WriteBatch*),db\write_batch.cc,"SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
  return SequenceNumber(DecodeFixed64(b->rep_.data()));
}",90.0,92.0,1.0,1.0,3.0,2,2,1,1,1,1,1,1,0,0,,0,1,2,1,1,SequenceNumber
985,56701,SetSequence,1,leveldb.WriteBatchInternal.SetSequence,"void leveldb.WriteBatchInternal.SetSequence (WriteBatch*,SequenceNumber)",db\write_batch.cc,"void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
  EncodeFixed64(&b->rep_[0], seq);
}",94.0,96.0,1.0,1.0,3.0,3,3,2,2,0,1,1,1,0,0,,0,1,4,2,2,void
986,56715,Put,1,leveldb.WriteBatch.Put,"void leveldb.WriteBatch.Put (Slice,Slice)",db\write_batch.cc,"void WriteBatch::Put(const Slice& key, const Slice& value) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeValue));
  PutLengthPrefixedSlice(&rep_, key);
  PutLengthPrefixedSlice(&rep_, value);
}",98.0,103.0,1.0,1.0,6.0,7,4,8,5,0,5,1,1,0,2,,0,4,4,2,2,void
987,56748,Delete,1,leveldb.WriteBatch.Delete,void leveldb.WriteBatch.Delete (Slice),db\write_batch.cc,"void WriteBatch::Delete(const Slice& key) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeDeletion));
  PutLengthPrefixedSlice(&rep_, key);
}",105.0,109.0,1.0,1.0,5.0,6,4,6,4,0,4,1,1,0,2,,0,3,2,1,1,void
988,56780,Put,1,leveldb.anonymous_namespace_2.MemTableInserter.Put,"void leveldb.anonymous_namespace_2.MemTableInserter.Put (Slice,Slice)",db\write_batch.cc,"virtual void Put(const Slice& key, const Slice& value) {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }",117.0,120.0,3.0,3.0,4.0,2,2,6,5,0,3,1,1,0,0,,0,3,4,2,2,void
989,56796,Delete,1,leveldb.anonymous_namespace_3.MemTableInserter.Delete,void leveldb.anonymous_namespace_3.MemTableInserter.Delete (Slice),db\write_batch.cc,"virtual void Delete(const Slice& key) {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }",121.0,124.0,3.0,3.0,4.0,2,2,5,4,0,3,1,1,0,0,,0,3,2,1,1,void
990,56811,InsertInto,1,leveldb.WriteBatchInternal.InsertInto,"Status leveldb.WriteBatchInternal.InsertInto (WriteBatch*,MemTable*)",db\write_batch.cc,"Status WriteBatchInternal::InsertInto(const WriteBatch* b,
                                      MemTable* memtable) {
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b->Iterate(&inserter);
}",128.0,134.0,1.0,1.0,7.0,7,4,7,4,0,3,1,1,0,1,,0,3,4,2,2,Status
991,56839,SetContents,1,leveldb.WriteBatchInternal.SetContents,"void leveldb.WriteBatchInternal.SetContents (WriteBatch*,Slice)",db\write_batch.cc,"void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
  assert(contents.size() >= kHeader);
  b->rep_.assign(contents.data(), contents.size());
}",136.0,139.0,1.0,1.0,4.0,6,3,5,3,0,1,1,1,0,0,,0,1,4,2,2,void
992,56866,Append,1,leveldb.WriteBatchInternal.Append,"void leveldb.WriteBatchInternal.Append (WriteBatch*,WriteBatch*)",db\write_batch.cc,"void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
  SetCount(dst, Count(dst) + Count(src));
  assert(src->rep_.size() >= kHeader);
  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
}",141.0,145.0,1.0,1.0,5.0,12,5,10,3,0,7,1,1,0,3,,0,6,4,2,2,void
993,56944,Contents,1,leveldb.WriteBatchInternal.Contents,Slice leveldb.WriteBatchInternal.Contents (WriteBatch*),db\write_batch_internal.hpp,"static Slice Contents(const WriteBatch* batch) {
    return Slice(batch->rep_);
  }",32.0,34.0,3.0,3.0,3.0,1,1,1,1,1,1,1,1,0,0,,0,1,2,1,1,Slice
994,56954,ByteSize,1,leveldb.WriteBatchInternal.ByteSize,size_t leveldb.WriteBatchInternal.ByteSize (WriteBatch*),db\write_batch_internal.hpp,"static size_t ByteSize(const WriteBatch* batch) {
    return batch->rep_.size();
  }",36.0,38.0,3.0,3.0,3.0,2,2,1,1,2,1,1,1,0,0,,0,1,2,1,1,size_t
995,57002,PrintContents,1,leveldb.PrintContents,string leveldb.PrintContents (WriteBatch*),db\write_batch_test.cc,"static std::string PrintContents(WriteBatch* b) {
  InternalKeyComparator cmp(BytewiseComparator());
  MemTable* mem = new MemTable(cmp);
  mem->Ref();
  std::string state;
  Status s = WriteBatchInternal::InsertInto(b, mem);
  int count = 0;
  Iterator* iter = mem->NewIterator();
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    ParsedInternalKey ikey;
    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));
    switch (ikey.type) {
      case kTypeValue:
        state.append(""Put("");
        state.append(ikey.user_key.ToString());
        state.append("", "");
        state.append(iter->value().ToString());
        state.append("")"");
        count++;
        break;
      case kTypeDeletion:
        state.append(""Delete("");
        state.append(ikey.user_key.ToString());
        state.append("")"");
        count++;
        break;
    }
    state.append(""@"");
    state.append(NumberToString(ikey.sequence));
  }
  delete iter;
  if (!s.ok()) {
    state.append(""ParseError()"")...",15.0,53.0,1.0,4.0,39.0,40,8,41,13,0,4,6,5,1,0,,0,4,2,1,1,string
996,57781,ExecErrorCheck,1,ExecErrorCheck,"void ExecErrorCheck (int,char*)",doc\bench\db_bench_sqlite3.cc,"inline
static void ExecErrorCheck(int status, char *err_msg) {
  if (status != SQLITE_OK) {
    fprintf(stderr, ""SQL error: %s\n"", err_msg);
    sqlite3_free(err_msg);
    exit(1);
  }
}",81.0,88.0,1.0,1.0,8.0,1,1,5,4,1,0,2,2,0,0,,0,0,4,2,2,void
997,57800,StepErrorCheck,1,StepErrorCheck,void StepErrorCheck (int),doc\bench\db_bench_sqlite3.cc,"inline
static void StepErrorCheck(int status) {
  if (status != SQLITE_DONE) {
    fprintf(stderr, ""SQL step error: status = %d\n"", status);
    exit(1);
  }
}",90.0,96.0,1.0,1.0,7.0,1,1,4,3,6,0,2,2,0,0,,0,0,2,1,1,void
998,57816,ErrorCheck,1,ErrorCheck,void ErrorCheck (int),doc\bench\db_bench_sqlite3.cc,"inline
static void ErrorCheck(int status) {
  if (status != SQLITE_OK) {
    fprintf(stderr, ""sqlite3 error: status = %d\n"", status);
    exit(1);
  }
}",98.0,104.0,1.0,1.0,7.0,1,1,4,3,23,0,2,2,0,0,,0,0,2,1,1,void
999,57832,WalCheckpoint,1,WalCheckpoint,void WalCheckpoint (sqlite3*),doc\bench\db_bench_sqlite3.cc,"inline
static void WalCheckpoint(sqlite3* db_) {
  // Flush all writes to disk
  if (FLAGS_WAL_enabled) {
    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);
  }
}",106.0,112.0,1.0,1.0,7.0,0,0,6,4,0,1,2,2,1,0,,0,1,2,1,1,void
1000,58046,Start,1,leveldb.Benchmark.Start,void leveldb.Benchmark.Start (),doc\bench\db_bench_tree_db.cc,"void Start() {
    start_ = Env::Default()->NowMicros() * 1e-6;
    bytes_ = 0;
    message_.clear();
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    next_report_ = 100;
  }",216.0,224.0,3.0,3.0,9.0,10,4,9,8,0,8,1,1,0,0,,0,8,0,0,0,void
1001,58081,FinishedSingleOp,1,leveldb.Benchmark.FinishedSingleOp,void leveldb.Benchmark.FinishedSingleOp (),doc\bench\db_bench_tree_db.cc,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",226.0,250.0,3.0,3.0,25.0,14,10,20,9,0,10,5,7,4,0,,0,10,0,0,0,void
1002,58203,Stop,1,leveldb.Benchmark.Stop,void leveldb.Benchmark.Stop (Slice),doc\bench\db_bench_tree_db.cc,"void Stop(const Slice& name) {
    double finish = Env::Default()->NowMicros() * 1e-6;

    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    if (bytes_ > 0) {
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            (finish - start_) * 1e6 / done_,
            (message_.empty() ? """" : "" ""),
            message_.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",252.0,279.0,3.0,3.0,28.0,27,12,25,12,0,14,5,6,4,0,,0,14,2,1,1,void
1003,58910,Write,1,leveldb.Benchmark.Write,"void leveldb.Benchmark.Write (bool,Order,DBState,int,int,int)",doc\bench\db_bench_tree_db.cc,"void Write(bool sync, Order order, DBState state,
             int num_entries, int value_size, int entries_per_batch) {
    // Create new database if state == FRESH
    if (state == FRESH) {
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      delete db_;
      db_ = NULL;
      Open(sync);
      Start();  // Do not count time taken to destroy/open
    }

    if (num_entries != num_) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }

    // Write to database
    for (int i = 0; i < num_entries; i++)
    {
      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);
      char key[100];
      snprintf(key, sizeof(key), ""%016d"", k);
      bytes_ += value_size + strlen(key);
      std::string cpp_key = key;
      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {
        fprintf(stderr, ""set error: %s\n"", db_->error().name());...",424.0,457.0,3.0,3.0,34.0,59,14,116,34,0,33,8,12,5,16,,0,17,12,6,6,void
1004,59203,Read,1,leveldb.Benchmark.Read,"void leveldb.Benchmark.Read (Order,int)",doc\bench\db_bench_sqlite3.cc,"void Read(Order order, int entries_per_batch) {
    int status;
    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;

    std::string read_str = ""SELECT * FROM test WHERE key = ?"";
    std::string begin_trans_str = ""BEGIN TRANSACTION;"";
    std::string end_trans_str = ""END TRANSACTION;"";

    // Preparing sqlite3 statements
    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,
                                &begin_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,
                                &end_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);
    ErrorCheck(status);

    bool transaction = (entries_per_batch > 1);
    for (int i = 0; i < reads_; i += entries_per_batch) {
      // Begin read transaction
      if (FLAGS_transaction && transaction) {
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);...",581.0,647.0,3.0,3.0,67.0,42,12,79,22,0,23,6,11,3,14,,0,9,4,2,2,void
1005,61369,Ref,1,leveldb.anonymous_namespace_3.FileState.Ref,void leveldb.anonymous_namespace_3.FileState.Ref (),helpers\memenv\memenv.cc,"void Ref() {
    MutexLock lock(&refs_mutex_);
    ++refs_;
  }",27.0,30.0,3.0,3.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1006,61379,Unref,1,leveldb.anonymous_namespace_4.FileState.Unref,void leveldb.anonymous_namespace_4.FileState.Unref (),helpers\memenv\memenv.cc,"void Unref() {
    bool do_delete = false;

    {
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }

    if (do_delete) {
      delete this;
    }
  }",33.0,48.0,3.0,3.0,16.0,7,6,7,3,0,4,3,3,1,0,,0,4,0,0,0,void
1007,61411,Size,1,leveldb.anonymous_namespace_5.FileState.Size,uint64_t leveldb.anonymous_namespace_5.FileState.Size (),helpers\memenv\memenv.cc,uint64_t Size() const { return size_; },50.0,50.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1008,61417,Read,1,leveldb.anonymous_namespace_6.FileState.Read,"Status leveldb.anonymous_namespace_6.FileState.Read (uint64_t,size_t,Slice*,char*)",helpers\memenv\memenv.cc,"Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
    if (offset > size_) {
      return Status::IOError(""Offset greater than file size."");
    }
    const uint64_t available = size_ - offset;
    if (n > available) {
      n = static_cast<size_t>(available);
    }
    if (n == 0) {
      *result = Slice();
      return Status::OK();
    }

    assert(offset / kBlockSize <= SIZE_MAX);
    size_t block = static_cast<size_t>(offset / kBlockSize);
    size_t block_offset = offset % kBlockSize;

    if (n <= kBlockSize - block_offset) {
      // The requested bytes are all in the first block.
      *result = Slice(blocks_[block] + block_offset, n);
      return Status::OK();
    }

    size_t bytes_to_copy = n;
    char* dst = scratch;

    while (bytes_to_copy > 0) {
      size_t avail = kBlockSize - block_offset;
      if (avail > bytes_to_copy) {
        avail = bytes_to_copy;
      }
      memcpy(dst, blocks_[block] + block_offset, avail);

      bytes_to_...",52.0,93.0,3.0,3.0,42.0,41,15,58,15,0,13,7,8,2,1,,0,9,8,4,4,Status
1009,61565,Append,1,leveldb.anonymous_namespace_7.FileState.Append,Status leveldb.anonymous_namespace_7.FileState.Append (Slice),helpers\memenv\memenv.cc,"Status Append(const Slice& data) {
    const char* src = data.data();
    size_t src_len = data.size();

    while (src_len > 0) {
      size_t avail;
      size_t offset = size_ % kBlockSize;

      if (offset != 0) {
        // There is some room in the last block.
        avail = kBlockSize - offset;
      } else {
        // No room in the last block; push new one.
        blocks_.push_back(new char[kBlockSize]);
        avail = kBlockSize;
      }

      if (avail > src_len) {
        avail = src_len;
      }
      memcpy(blocks_.back() + offset, src, avail);
      src_len -= avail;
      src += avail;
      size_ += avail;
    }

    return Status::OK();
  }",95.0,122.0,3.0,3.0,28.0,18,9,27,9,0,6,4,6,0,0,,0,5,2,1,1,Status
1010,61648,~FileState,1,leveldb.anonymous_namespace_8.FileState.~FileState,ANY leveldb.anonymous_namespace_8.FileState.~FileState (),helpers\memenv\memenv.cc,"~FileState() {
    for (std::vector<char*>::iterator i = blocks_.begin(); i != blocks_.end();
         ++i) {
      delete [] *i;
    }
  }",126.0,131.0,3.0,3.0,6.0,6,5,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1011,61699,SequentialFileImpl,1,leveldb.anonymous_namespace_14.SequentialFileImpl.SequentialFileImpl,ANY leveldb.anonymous_namespace_14.SequentialFileImpl.SequentialFileImpl (FileState*),helpers\memenv\memenv.cc,"explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {
    file_->Ref();
  }",151.0,153.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
1012,61708,~SequentialFileImpl,1,leveldb.anonymous_namespace_15.SequentialFileImpl.~SequentialFileImpl,ANY leveldb.anonymous_namespace_15.SequentialFileImpl.~SequentialFileImpl (),helpers\memenv\memenv.cc,"~SequentialFileImpl() {
    file_->Unref();
  }",155.0,157.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1013,61716,Read,1,leveldb.anonymous_namespace_16.SequentialFileImpl.Read,"Status leveldb.anonymous_namespace_16.SequentialFileImpl.Read (size_t,Slice*,char*)",helpers\memenv\memenv.cc,"virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s = file_->Read(pos_, n, result, scratch);
    if (s.ok()) {
      pos_ += result->size();
    }
    return s;
  }",159.0,165.0,3.0,3.0,7.0,5,4,10,6,0,3,2,2,0,0,,0,3,6,3,3,Status
1014,61748,Skip,1,leveldb.anonymous_namespace_17.SequentialFileImpl.Skip,Status leveldb.anonymous_namespace_17.SequentialFileImpl.Skip (uint64_t),helpers\memenv\memenv.cc,"virtual Status Skip(uint64_t n) {
    if (pos_ > file_->Size()) {
      return Status::IOError(""pos_ > file_->Size()"");
    }
    const uint64_t available = file_->Size() - pos_;
    if (n > available) {
      n = available;
    }
    pos_ += n;
    return Status::OK();
  }",167.0,177.0,3.0,3.0,11.0,10,6,13,5,0,7,3,3,2,1,,0,5,2,1,1,Status
1015,61795,RandomAccessFileImpl,1,leveldb.anonymous_namespace_19.RandomAccessFileImpl.RandomAccessFileImpl,ANY leveldb.anonymous_namespace_19.RandomAccessFileImpl.RandomAccessFileImpl (FileState*),helpers\memenv\memenv.cc,"explicit RandomAccessFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }",186.0,188.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
1016,61804,~RandomAccessFileImpl,1,leveldb.anonymous_namespace_20.RandomAccessFileImpl.~RandomAccessFileImpl,ANY leveldb.anonymous_namespace_20.RandomAccessFileImpl.~RandomAccessFileImpl (),helpers\memenv\memenv.cc,"~RandomAccessFileImpl() {
    file_->Unref();
  }",190.0,192.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1017,61812,Read,1,leveldb.anonymous_namespace_21.RandomAccessFileImpl.Read,"Status leveldb.anonymous_namespace_21.RandomAccessFileImpl.Read (uint64_t,size_t,Slice*,char*)",helpers\memenv\memenv.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    return file_->Read(offset, n, result, scratch);
  }",194.0,197.0,3.0,3.0,4.0,1,1,5,5,0,1,1,1,0,0,,0,1,8,4,4,Status
1018,61831,WritableFileImpl,1,leveldb.anonymous_namespace_23.WritableFileImpl.WritableFileImpl,ANY leveldb.anonymous_namespace_23.WritableFileImpl.WritableFileImpl (FileState*),helpers\memenv\memenv.cc,"WritableFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }",205.0,207.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,2,1,1,ANY
1019,61840,~WritableFileImpl,1,leveldb.anonymous_namespace_24.WritableFileImpl.~WritableFileImpl,ANY leveldb.anonymous_namespace_24.WritableFileImpl.~WritableFileImpl (),helpers\memenv\memenv.cc,"~WritableFileImpl() {
    file_->Unref();
  }",209.0,211.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1020,61848,Append,1,leveldb.anonymous_namespace_25.WritableFileImpl.Append,Status leveldb.anonymous_namespace_25.WritableFileImpl.Append (Slice),helpers\memenv\memenv.cc,"virtual Status Append(const Slice& data) {
    return file_->Append(data);
  }",213.0,215.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1021,61859,Close,1,leveldb.anonymous_namespace_26.WritableFileImpl.Close,Status leveldb.anonymous_namespace_26.WritableFileImpl.Close (),helpers\memenv\memenv.cc,virtual Status Close() { return Status::OK(); },217.0,217.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1022,61868,Flush,1,leveldb.anonymous_namespace_27.WritableFileImpl.Flush,Status leveldb.anonymous_namespace_27.WritableFileImpl.Flush (),helpers\memenv\memenv.cc,virtual Status Flush() { return Status::OK(); },218.0,218.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1023,61877,Sync,1,leveldb.anonymous_namespace_28.WritableFileImpl.Sync,Status leveldb.anonymous_namespace_28.WritableFileImpl.Sync (),helpers\memenv\memenv.cc,virtual Status Sync() { return Status::OK(); },219.0,219.0,3.0,48.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1024,61900,~InMemoryEnv,1,leveldb.anonymous_namespace_33.InMemoryEnv.~InMemoryEnv,ANY leveldb.anonymous_namespace_33.InMemoryEnv.~InMemoryEnv (),helpers\memenv\memenv.cc,"virtual ~InMemoryEnv() {
    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      i->second->Unref();
    }
  }",234.0,238.0,3.0,3.0,5.0,6,4,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1025,61928,NewSequentialFile,1,leveldb.anonymous_namespace_34.InMemoryEnv.NewSequentialFile,"Status leveldb.anonymous_namespace_34.InMemoryEnv.NewSequentialFile (ANY,SequentialFile**)",helpers\memenv\memenv.cc,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new SequentialFileImpl(file_map_[fname]);
    return Status::OK();
  }",241.0,251.0,3.0,3.0,11.0,12,7,13,7,0,6,2,2,2,1,,0,4,4,2,2,Status
1026,61974,NewRandomAccessFile,1,leveldb.anonymous_namespace_35.InMemoryEnv.NewRandomAccessFile,"Status leveldb.anonymous_namespace_35.InMemoryEnv.NewRandomAccessFile (ANY,RandomAccessFile**)",helpers\memenv\memenv.cc,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new RandomAccessFileImpl(file_map_[fname]);
    return Status::OK();
  }",253.0,263.0,3.0,3.0,11.0,12,7,13,7,0,6,2,2,2,1,,0,4,4,2,2,Status
1027,62020,NewWritableFile,1,leveldb.anonymous_namespace_36.InMemoryEnv.NewWritableFile,"Status leveldb.anonymous_namespace_36.InMemoryEnv.NewWritableFile (ANY,WritableFile**)",helpers\memenv\memenv.cc,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) != file_map_.end()) {
      DeleteFileInternal(fname);
    }

    FileState* file = new FileState();
    file->Ref();
    file_map_[fname] = file;

    *result = new WritableFileImpl(file);
    return Status::OK();
  }",265.0,278.0,3.0,3.0,14.0,13,8,15,8,0,5,2,2,2,0,,0,4,4,2,2,Status
1028,62069,NewAppendableFile,1,leveldb.anonymous_namespace_38.InMemoryEnv.NewAppendableFile,"Status leveldb.anonymous_namespace_38.InMemoryEnv.NewAppendableFile (ANY,WritableFile**)",helpers\memenv\memenv.cc,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    MutexLock lock(&mutex_);
    FileState** sptr = &file_map_[fname];
    FileState* file = *sptr;
    if (file == NULL) {
      file = new FileState();
      file->Ref();
    }
    *result = new WritableFileImpl(file);
    return Status::OK();
  }",280.0,291.0,3.0,3.0,12.0,14,8,15,10,0,3,2,2,0,0,,0,2,4,2,2,Status
1029,62115,FileExists,1,leveldb.anonymous_namespace_39.InMemoryEnv.FileExists,bool leveldb.anonymous_namespace_39.InMemoryEnv.FileExists (ANY),helpers\memenv\memenv.cc,"virtual bool FileExists(const std::string& fname) {
    MutexLock lock(&mutex_);
    return file_map_.find(fname) != file_map_.end();
  }",293.0,296.0,3.0,3.0,4.0,4,3,4,3,0,3,1,1,0,0,,0,3,2,1,1,bool
1030,62135,GetChildren,1,leveldb.anonymous_namespace_40.InMemoryEnv.GetChildren,"Status leveldb.anonymous_namespace_40.InMemoryEnv.GetChildren (ANY,ANY*)",helpers\memenv\memenv.cc,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) {
    MutexLock lock(&mutex_);
    result->clear();

    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      const std::string& filename = i->first;

      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&
          Slice(filename).starts_with(Slice(dir))) {
        result->push_back(filename.substr(dir.size() + 1));
      }
    }

    return Status::OK();
  }",298.0,313.0,3.0,3.0,16.0,23,10,18,7,0,4,3,4,1,0,,0,3,4,2,2,Status
1031,62222,DeleteFileInternal,1,leveldb.anonymous_namespace_41.InMemoryEnv.DeleteFileInternal,void leveldb.anonymous_namespace_41.InMemoryEnv.DeleteFileInternal (ANY),helpers\memenv\memenv.cc,"void DeleteFileInternal(const std::string& fname) {
    if (file_map_.find(fname) == file_map_.end()) {
      return;
    }

    file_map_[fname]->Unref();
    file_map_.erase(fname);
  }",315.0,322.0,3.0,3.0,8.0,6,4,7,2,0,4,2,2,2,0,,0,4,2,1,1,void
1032,62251,DeleteFile,1,leveldb.anonymous_namespace_42.InMemoryEnv.DeleteFile,Status leveldb.anonymous_namespace_42.InMemoryEnv.DeleteFile (ANY),helpers\memenv\memenv.cc,"virtual Status DeleteFile(const std::string& fname) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    DeleteFileInternal(fname);
    return Status::OK();
  }",324.0,332.0,3.0,3.0,9.0,6,3,8,4,0,5,2,2,2,1,,0,3,2,1,1,Status
1033,62286,CreateDir,1,leveldb.anonymous_namespace_44.InMemoryEnv.CreateDir,Status leveldb.anonymous_namespace_44.InMemoryEnv.CreateDir (ANY),helpers\memenv\memenv.cc,"virtual Status CreateDir(const std::string& dirname) {
    return Status::OK();
  }",334.0,336.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,Status
1034,62296,DeleteDir,1,leveldb.anonymous_namespace_45.InMemoryEnv.DeleteDir,Status leveldb.anonymous_namespace_45.InMemoryEnv.DeleteDir (ANY),helpers\memenv\memenv.cc,"virtual Status DeleteDir(const std::string& dirname) {
    return Status::OK();
  }",338.0,340.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,0,2,1,1,Status
1035,62306,GetFileSize,1,leveldb.anonymous_namespace_46.InMemoryEnv.GetFileSize,"Status leveldb.anonymous_namespace_46.InMemoryEnv.GetFileSize (ANY,uint64_t*)",helpers\memenv\memenv.cc,"virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    *file_size = file_map_[fname]->Size();
    return Status::OK();
  }",342.0,350.0,3.0,3.0,9.0,10,7,10,5,0,6,2,2,2,1,,0,4,4,2,2,Status
1036,62349,RenameFile,1,leveldb.anonymous_namespace_47.InMemoryEnv.RenameFile,"Status leveldb.anonymous_namespace_47.InMemoryEnv.RenameFile (ANY,ANY)",helpers\memenv\memenv.cc,"virtual Status RenameFile(const std::string& src,
                            const std::string& target) {
    MutexLock lock(&mutex_);
    if (file_map_.find(src) == file_map_.end()) {
      return Status::IOError(src, ""File not found"");
    }

    DeleteFileInternal(target);
    file_map_[target] = file_map_[src];
    file_map_.erase(src);
    return Status::OK();
  }",352.0,363.0,3.0,3.0,12.0,10,5,14,5,0,8,2,2,2,1,,0,6,4,2,2,Status
1037,62397,LockFile,1,leveldb.anonymous_namespace_49.InMemoryEnv.LockFile,"Status leveldb.anonymous_namespace_49.InMemoryEnv.LockFile (ANY,FileLock**)",helpers\memenv\memenv.cc,"virtual Status LockFile(const std::string& fname, FileLock** lock) {
    *lock = new FileLock;
    return Status::OK();
  }",365.0,368.0,3.0,3.0,4.0,4,4,3,3,0,1,1,1,0,0,,0,0,4,2,2,Status
1038,62413,UnlockFile,1,leveldb.anonymous_namespace_50.InMemoryEnv.UnlockFile,Status leveldb.anonymous_namespace_50.InMemoryEnv.UnlockFile (FileLock*),helpers\memenv\memenv.cc,"virtual Status UnlockFile(FileLock* lock) {
    delete lock;
    return Status::OK();
  }",370.0,373.0,3.0,3.0,4.0,2,2,2,2,0,1,1,1,0,0,,0,0,2,1,1,Status
1039,62425,GetTestDirectory,1,leveldb.anonymous_namespace_51.InMemoryEnv.GetTestDirectory,Status leveldb.anonymous_namespace_51.InMemoryEnv.GetTestDirectory (ANY*),helpers\memenv\memenv.cc,"virtual Status GetTestDirectory(std::string* path) {
    *path = ""/test"";
    return Status::OK();
  }",375.0,378.0,3.0,3.0,4.0,3,3,2,2,0,1,1,1,0,0,,0,0,2,1,1,Status
1040,62439,NewLogger,1,leveldb.anonymous_namespace_52.InMemoryEnv.NewLogger,"Status leveldb.anonymous_namespace_52.InMemoryEnv.NewLogger (ANY,Logger**)",helpers\memenv\memenv.cc,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    *result = new NoOpLogger;
    return Status::OK();
  }",380.0,383.0,3.0,3.0,4.0,4,4,3,3,0,1,1,1,0,0,,0,0,4,2,2,Status
1041,62505,~MemEnvTest,1,leveldb.MemEnvTest.~MemEnvTest,ANY leveldb.MemEnvTest.~MemEnvTest (),helpers\memenv\memenv_test.cc,"~MemEnvTest() {
    delete env_;
  }",23.0,25.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1042,65633,Default,1,leveldb.Env.Default,Env* leveldb.Env.Default (),util\env_posix.cc,"Env* Env::Default() {
  pthread_once(&once, InitDefaultEnv);
  return default_env;
}",690.0,693.0,1.0,1.0,4.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,Env
1043,65920,target,1,leveldb.EnvWrapper.target,Env leveldb.EnvWrapper.target (),include\leveldb\env.hpp,Env* target() const { return target_; },295.0,295.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Env
1044,65926,NewSequentialFile,1,leveldb.EnvWrapper.NewSequentialFile,"Status leveldb.EnvWrapper.NewSequentialFile (ANY,SequentialFile**)",include\leveldb\env.hpp,"Status NewSequentialFile(const std::string& f, SequentialFile** r) {
    return target_->NewSequentialFile(f, r);
  }",298.0,300.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1045,65939,NewRandomAccessFile,1,leveldb.EnvWrapper.NewRandomAccessFile,"Status leveldb.EnvWrapper.NewRandomAccessFile (ANY,RandomAccessFile**)",include\leveldb\env.hpp,"Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    return target_->NewRandomAccessFile(f, r);
  }",301.0,303.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1046,65952,NewWritableFile,1,leveldb.EnvWrapper.NewWritableFile,"Status leveldb.EnvWrapper.NewWritableFile (ANY,WritableFile**)",include\leveldb\env.hpp,"Status NewWritableFile(const std::string& f, WritableFile** r) {
    return target_->NewWritableFile(f, r);
  }",304.0,306.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1047,65965,NewAppendableFile,1,leveldb.EnvWrapper.NewAppendableFile,"Status leveldb.EnvWrapper.NewAppendableFile (ANY,WritableFile**)",include\leveldb\env.hpp,"Status NewAppendableFile(const std::string& f, WritableFile** r) {
    return target_->NewAppendableFile(f, r);
  }",307.0,309.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1048,65978,FileExists,1,leveldb.EnvWrapper.FileExists,bool leveldb.EnvWrapper.FileExists (ANY),include\leveldb\env.hpp,bool FileExists(const std::string& f) { return target_->FileExists(f); },310.0,310.0,3.0,74.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,bool
1049,65989,GetChildren,1,leveldb.EnvWrapper.GetChildren,"Status leveldb.EnvWrapper.GetChildren (ANY,ANY*)",include\leveldb\env.hpp,"Status GetChildren(const std::string& dir, std::vector<std::string>* r) {
    return target_->GetChildren(dir, r);
  }",311.0,313.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1050,66002,DeleteFile,1,leveldb.EnvWrapper.DeleteFile,Status leveldb.EnvWrapper.DeleteFile (ANY),include\leveldb\env.hpp,Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); },314.0,314.0,3.0,76.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1051,66013,CreateDir,1,leveldb.EnvWrapper.CreateDir,Status leveldb.EnvWrapper.CreateDir (ANY),include\leveldb\env.hpp,Status CreateDir(const std::string& d) { return target_->CreateDir(d); },315.0,315.0,3.0,74.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1052,66024,DeleteDir,1,leveldb.EnvWrapper.DeleteDir,Status leveldb.EnvWrapper.DeleteDir (ANY),include\leveldb\env.hpp,Status DeleteDir(const std::string& d) { return target_->DeleteDir(d); },316.0,316.0,3.0,74.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1053,66035,GetFileSize,1,leveldb.EnvWrapper.GetFileSize,"Status leveldb.EnvWrapper.GetFileSize (ANY,uint64_t*)",include\leveldb\env.hpp,"Status GetFileSize(const std::string& f, uint64_t* s) {
    return target_->GetFileSize(f, s);
  }",317.0,319.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1054,66048,RenameFile,1,leveldb.EnvWrapper.RenameFile,"Status leveldb.EnvWrapper.RenameFile (ANY,ANY)",include\leveldb\env.hpp,"Status RenameFile(const std::string& s, const std::string& t) {
    return target_->RenameFile(s, t);
  }",320.0,322.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1055,66061,LockFile,1,leveldb.EnvWrapper.LockFile,"Status leveldb.EnvWrapper.LockFile (ANY,FileLock**)",include\leveldb\env.hpp,"Status LockFile(const std::string& f, FileLock** l) {
    return target_->LockFile(f, l);
  }",323.0,325.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1056,66074,UnlockFile,1,leveldb.EnvWrapper.UnlockFile,Status leveldb.EnvWrapper.UnlockFile (FileLock*),include\leveldb\env.hpp,Status UnlockFile(FileLock* l) { return target_->UnlockFile(l); },326.0,326.0,3.0,67.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1057,66085,Schedule,1,leveldb.EnvWrapper.Schedule,"void leveldb.EnvWrapper.Schedule (void,void*)",include\leveldb\env.hpp,"void Schedule(void (*f)(void*), void* a) {
    return target_->Schedule(f, a);
  }",327.0,329.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1058,66098,StartThread,1,leveldb.EnvWrapper.StartThread,"void leveldb.EnvWrapper.StartThread (void,void*)",include\leveldb\env.hpp,"void StartThread(void (*f)(void*), void* a) {
    return target_->StartThread(f, a);
  }",330.0,332.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1059,66111,GetTestDirectory,1,leveldb.EnvWrapper.GetTestDirectory,Status leveldb.EnvWrapper.GetTestDirectory (ANY*),include\leveldb\env.hpp,"virtual Status GetTestDirectory(std::string* path) {
    return target_->GetTestDirectory(path);
  }",333.0,335.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,Status
1060,66122,NewLogger,1,leveldb.EnvWrapper.NewLogger,"Status leveldb.EnvWrapper.NewLogger (ANY,Logger**)",include\leveldb\env.hpp,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    return target_->NewLogger(fname, result);
  }",336.0,338.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1061,66135,NowMicros,1,leveldb.EnvWrapper.NowMicros,uint64_t leveldb.EnvWrapper.NowMicros (),include\leveldb\env.hpp,"uint64_t NowMicros() {
    return target_->NowMicros();
  }",339.0,341.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1062,66144,SleepForMicroseconds,1,leveldb.EnvWrapper.SleepForMicroseconds,void leveldb.EnvWrapper.SleepForMicroseconds (int),include\leveldb\env.hpp,"void SleepForMicroseconds(int micros) {
    target_->SleepForMicroseconds(micros);
  }",342.0,344.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1063,66381,data,1,leveldb.Slice.data,const char* leveldb.Slice.data (),include\leveldb\slice.hpp,const char* data() const { return data_; },40.0,40.0,3.0,44.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,const char*
1064,66387,size,1,leveldb.Slice.size,size_t leveldb.Slice.size (),include\leveldb\slice.hpp,size_t size() const { return size_; },43.0,43.0,3.0,39.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1065,66393,empty,1,leveldb.Slice.empty,bool leveldb.Slice.empty (),include\leveldb\slice.hpp,bool empty() const { return size_ == 0; },46.0,46.0,3.0,43.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1066,66401,operator [],1,leveldb.Slice.operator [],char leveldb.Slice.operator [] (size_t),include\leveldb\slice.hpp,"char operator[](size_t n) const {
    assert(n < size());
    return data_[n];
  }",50.0,53.0,3.0,3.0,4.0,2,2,3,2,0,1,1,1,0,0,,0,1,2,1,1,char
1067,66414,clear,1,leveldb.Slice.clear,void leveldb.Slice.clear (),include\leveldb\slice.hpp,"void clear() { data_ = """"; size_ = 0; }",56.0,56.0,3.0,41.0,1.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1068,66424,remove_prefix,1,leveldb.Slice.remove_prefix,void leveldb.Slice.remove_prefix (size_t),include\leveldb\slice.hpp,"void remove_prefix(size_t n) {
    assert(n <= size());
    data_ += n;
    size_ -= n;
  }",59.0,63.0,3.0,3.0,5.0,3,3,5,3,0,2,1,1,0,0,,0,2,2,1,1,void
1069,66439,ToString,1,leveldb.Slice.ToString,string leveldb.Slice.ToString (),include\leveldb\slice.hpp,"std::string ToString() const { return std::string(data_, size_); }",66.0,66.0,3.0,68.0,1.0,1,1,3,3,0,2,1,1,0,0,,0,2,0,0,0,string
1070,66455,starts_with,1,leveldb.Slice.starts_with,bool leveldb.Slice.starts_with (Slice),include\leveldb\slice.hpp,"bool starts_with(const Slice& x) const {
    return ((size_ >= x.size_) &&
            (memcmp(data_, x.data_, x.size_) == 0));
  }",75.0,78.0,3.0,3.0,4.0,6,4,5,3,0,5,1,1,0,0,,0,5,2,1,1,bool
1071,66595,~Status,1,leveldb.Status.~Status,ANY leveldb.Status.~Status (),include\leveldb\status.hpp,~Status() { delete[] state_; },25.0,25.0,3.0,32.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1072,66611,OK,1,leveldb.Status.OK,Status leveldb.Status.OK (),include\leveldb\status.hpp,static Status OK() { return Status(); },32.0,32.0,3.0,41.0,1.0,0,0,0,0,57,0,1,1,0,0,,0,0,0,0,0,Status
1073,66617,NotFound,1,leveldb.Status.NotFound,"Status leveldb.Status.NotFound (Slice,Slice)",include\leveldb\status.hpp,"static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotFound, msg, msg2);
  }",35.0,37.0,3.0,3.0,3.0,0,0,3,3,5,1,1,1,0,0,,0,1,4,2,2,Status
1074,66628,Corruption,1,leveldb.Status.Corruption,"Status leveldb.Status.Corruption (Slice,Slice)",include\leveldb\status.hpp,"static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kCorruption, msg, msg2);
  }",38.0,40.0,3.0,3.0,3.0,0,0,3,3,22,1,1,1,0,0,,0,1,4,2,2,Status
1075,66639,NotSupported,1,leveldb.Status.NotSupported,"Status leveldb.Status.NotSupported (Slice,Slice)",include\leveldb\status.hpp,"static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotSupported, msg, msg2);
  }",41.0,43.0,3.0,3.0,3.0,0,0,3,3,0,1,1,1,0,0,,0,1,4,2,2,Status
1076,66650,InvalidArgument,1,leveldb.Status.InvalidArgument,"Status leveldb.Status.InvalidArgument (Slice,Slice)",include\leveldb\status.hpp,"static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kInvalidArgument, msg, msg2);
  }",44.0,46.0,3.0,3.0,3.0,0,0,3,3,4,1,1,1,0,0,,0,1,4,2,2,Status
1077,66661,IOError,1,leveldb.Status.IOError,"Status leveldb.Status.IOError (Slice,Slice)",include\leveldb\status.hpp,"static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kIOError, msg, msg2);
  }",47.0,49.0,3.0,3.0,3.0,0,0,3,3,13,1,1,1,0,0,,0,1,4,2,2,Status
1078,66672,ok,1,leveldb.Status.ok,bool leveldb.Status.ok (),include\leveldb\status.hpp,bool ok() const { return (state_ == NULL); },52.0,52.0,3.0,46.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,bool
1079,66680,IsNotFound,1,leveldb.Status.IsNotFound,bool leveldb.Status.IsNotFound (),include\leveldb\status.hpp,bool IsNotFound() const { return code() == kNotFound; },55.0,55.0,3.0,57.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1080,66688,IsCorruption,1,leveldb.Status.IsCorruption,bool leveldb.Status.IsCorruption (),include\leveldb\status.hpp,bool IsCorruption() const { return code() == kCorruption; },58.0,58.0,3.0,61.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1081,66696,IsIOError,1,leveldb.Status.IsIOError,bool leveldb.Status.IsIOError (),include\leveldb\status.hpp,bool IsIOError() const { return code() == kIOError; },61.0,61.0,3.0,55.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1082,66704,IsNotSupportedError,1,leveldb.Status.IsNotSupportedError,bool leveldb.Status.IsNotSupportedError (),include\leveldb\status.hpp,bool IsNotSupportedError() const { return code() == kNotSupported; },64.0,64.0,3.0,70.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1083,66712,IsInvalidArgument,1,leveldb.Status.IsInvalidArgument,bool leveldb.Status.IsInvalidArgument (),include\leveldb\status.hpp,bool IsInvalidArgument() const { return code() == kInvalidArgument; },67.0,67.0,3.0,71.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1084,66754,code,1,leveldb.Status.code,Code leveldb.Status.code (),include\leveldb\status.hpp,"Code code() const {
    return (state_ == NULL) ? kOk : static_cast<Code>(state_[4]);
  }",90.0,92.0,3.0,3.0,3.0,4,4,4,3,0,3,1,1,0,0,,0,3,0,0,0,Code
1085,66868,Table,1,leveldb.Table.Table,ANY leveldb.Table.Table (Rep*),include\leveldb\table.hpp,explicit Table(Rep* rep) { rep_ = rep; },62.0,62.0,3.0,42.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,ANY
1086,67141,_Run,1,anonymous_namespace_8._Test_Test._Run,void anonymous_namespace_8._Test_Test._Run (),issues\issue178_test.cc,"TEST(Issue178, Test) {
  // Get rid of any state from an old run.
  std::string dbpath = leveldb::test::TmpDir() + ""/leveldb_cbug_test"";
  DestroyDB(dbpath, leveldb::Options());

  // Open database.  Disable compression since it affects the creation
  // of layers and the code below is trying to test against a very
  // specific scenario.
  leveldb::DB* db;
  leveldb::Options db_options;
  db_options.create_if_missing = true;
  db_options.compression = leveldb::kNoCompression;
  ASSERT_OK(leveldb::DB::Open(db_options, dbpath, &db));

  // create first key range
  leveldb::WriteBatch batch;
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key1(i), ""value for range 1 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // create second key range
  batch.Clear();
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key2(i), ""value for range 2 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // delete second key range
  batch.Clear();
  ...",30.0,86.0,1.0,20.0,57.0,69,10,74,17,0,1,5,5,0,0,,0,1,0,0,0,void
1087,68109,SignalAll,1,leveldb.port.CondVar.SignalAll,void leveldb.port.CondVar.SignalAll (),port\port_posix.cc,"void CondVar::SignalAll() {
  PthreadCall(""broadcast"", pthread_cond_broadcast(&cv_));
}",44.0,46.0,1.0,1.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1088,68339,NumRestarts,1,leveldb.Block.NumRestarts,uint32_t leveldb.Block.NumRestarts (),table\block.cc,"inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}",18.0,21.0,1.0,1.0,4.0,5,4,5,3,0,3,1,1,0,0,,0,3,0,0,0,uint32_t
1089,68356,Block,1,leveldb.Block.Block,ANY leveldb.Block.Block (BlockContents),table\block.cc,"Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}",23.0,38.0,1.0,1.0,16.0,3,3,3,2,0,2,2,2,1,0,,0,2,2,1,1,ANY
1090,68402,~Block,1,leveldb.Block.~Block,ANY leveldb.Block.~Block (),table\block.cc,"Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}",40.0,44.0,1.0,1.0,5.0,1,1,2,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1091,68533,Compare,1,leveldb.Iter.Compare,"int leveldb.Iter.Compare (Slice,Slice)",table\block.cc,"inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }",90.0,92.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,int
1092,68546,NextEntryOffset,1,leveldb.Iter.NextEntryOffset,uint32_t leveldb.Iter.NextEntryOffset (),table\block.cc,"inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }",95.0,97.0,3.0,3.0,3.0,4,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,uint32_t
1093,68562,GetRestartPoint,1,leveldb.Iter.GetRestartPoint,uint32_t leveldb.Iter.GetRestartPoint (uint32_t),table\block.cc,"uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }",99.0,102.0,3.0,3.0,4.0,5,4,6,5,0,3,1,1,0,0,,0,3,2,1,1,uint32_t
1094,68581,SeekToRestartPoint,1,leveldb.Iter.SeekToRestartPoint,void leveldb.Iter.SeekToRestartPoint (uint32_t),table\block.cc,"void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }",104.0,112.0,3.0,3.0,9.0,5,3,8,6,0,4,1,1,0,0,,0,4,2,1,1,void
1095,68605,Iter,1,leveldb.Iter.Iter,"ANY leveldb.Iter.Iter (Comparator*,char*,uint32_t,uint32_t)",table\block.cc,"Iter(const Comparator* comparator,
       const char* data,
       uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }",115.0,126.0,3.0,3.0,12.0,1,1,1,1,0,1,1,1,0,0,,0,1,8,4,4,ANY
1096,68617,Valid,1,leveldb.Iter.Valid,bool leveldb.Iter.Valid (),table\block.cc,virtual bool Valid() const { return current_ < restarts_; },128.0,128.0,3.0,61.0,1.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,bool
1097,68625,status,1,leveldb.Iter.status,Status leveldb.Iter.status (),table\block.cc,virtual Status status() const { return status_; },129.0,129.0,3.0,51.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Status
1098,68631,key,1,leveldb.Iter.key,Slice leveldb.Iter.key (),table\block.cc,"virtual Slice key() const {
    assert(Valid());
    return key_;
  }",130.0,133.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1099,68639,value,1,leveldb.Iter.value,Slice leveldb.Iter.value (),table\block.cc,"virtual Slice value() const {
    assert(Valid());
    return value_;
  }",134.0,137.0,3.0,3.0,4.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1100,68654,Prev,1,leveldb.Iter.Prev,void leveldb.Iter.Prev (),table\block.cc,"virtual void Prev() {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }",144.0,163.0,3.0,3.0,20.0,8,6,12,5,0,9,4,5,2,0,,0,9,0,0,0,void
1101,68693,Seek,1,leveldb.Iter.Seek,void leveldb.Iter.Seek (Slice),table\block.cc,"virtual void Seek(const Slice& target) {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at ""mid"" is smaller than ""target"".  Therefore all
        // blocks before ""mid"" are uninteresting.
        left = mid;
      } else {
        // Key at ""mid"" is >= ""target"".  Therefore all blocks at or
        // after ""mid"" a...",165.0,203.0,3.0,3.0,39.0,22,11,30,15,0,5,7,11,1,0,,0,5,2,1,1,void
1102,68804,SeekToLast,1,leveldb.Iter.SeekToLast,void leveldb.Iter.SeekToLast (),table\block.cc,"virtual void SeekToLast() {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }",210.0,215.0,3.0,3.0,6.0,3,3,2,2,0,2,2,2,1,0,,0,2,0,0,0,void
1103,68819,CorruptionError,1,leveldb.Iter.CorruptionError,void leveldb.Iter.CorruptionError (),table\block.cc,"void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption(""bad entry in block"");
    key_.clear();
    value_.clear();
  }",218.0,224.0,3.0,3.0,7.0,6,2,8,8,0,8,1,1,0,1,,0,8,0,0,0,void
1104,68844,ParseNextKey,1,leveldb.Iter.ParseNextKey,bool leveldb.Iter.ParseNextKey (),table\block.cc,"bool ParseNextKey() {
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == NULL || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }",226.0,253.0,3.0,3.0,28.0,16,8,23,12,0,10,3,3,1,0,,0,10,0,0,0,bool
1105,68943,NewIterator,1,leveldb.Block.NewIterator,Iterator leveldb.Block.NewIterator (Comparator*),table\block.cc,"Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption(""bad block contents""));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }
}",256.0,266.0,1.0,1.0,11.0,5,5,5,4,0,2,3,3,1,1,,0,1,2,1,1,Iterator
1106,69005,size,1,leveldb.Block.size,size_t leveldb.Block.size (),table\block.hpp,size_t size() const { return size_; },24.0,24.0,3.0,39.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1107,69053,BlockBuilder,1,leveldb.BlockBuilder.BlockBuilder,ANY leveldb.BlockBuilder.BlockBuilder (Options*),table\block_builder.cc,"BlockBuilder::BlockBuilder(const Options* options)
    : options_(options),
      restarts_(),
      counter_(0),
      finished_(false) {
  assert(options->block_restart_interval >= 1);
  restarts_.push_back(0);       // First restart point is at offset 0
}",39.0,46.0,1.0,1.0,8.0,3,3,2,2,0,2,1,1,0,0,,0,2,2,1,1,ANY
1108,69069,Reset,1,leveldb.BlockBuilder.Reset,void leveldb.BlockBuilder.Reset (),table\block_builder.cc,"void BlockBuilder::Reset() {
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       // First restart point is at offset 0
  counter_ = 0;
  finished_ = false;
  last_key_.clear();
}",48.0,55.0,1.0,1.0,8.0,6,2,6,5,0,6,1,1,0,0,,0,6,0,0,0,void
1109,69096,CurrentSizeEstimate,1,leveldb.BlockBuilder.CurrentSizeEstimate,size_t leveldb.BlockBuilder.CurrentSizeEstimate (),table\block_builder.cc,"size_t BlockBuilder::CurrentSizeEstimate() const {
  return (buffer_.size() +                        // Raw data buffer
          restarts_.size() * sizeof(uint32_t) +   // Restart array
          sizeof(uint32_t));                      // Restart array length
}",57.0,61.0,1.0,1.0,5.0,7,4,4,3,0,2,1,1,0,0,,0,2,0,0,0,size_t
1110,69116,Finish,1,leveldb.BlockBuilder.Finish,Slice leveldb.BlockBuilder.Finish (),table\block_builder.cc,"Slice BlockBuilder::Finish() {
  // Append restart array
  for (size_t i = 0; i < restarts_.size(); i++) {
    PutFixed32(&buffer_, restarts_[i]);
  }
  PutFixed32(&buffer_, restarts_.size());
  finished_ = true;
  return Slice(buffer_);
}",63.0,71.0,1.0,1.0,9.0,8,5,10,4,0,7,2,2,1,0,,0,7,0,0,0,Slice
1111,69154,Add,1,leveldb.BlockBuilder.Add,"void leveldb.BlockBuilder.Add (Slice,Slice)",table\block_builder.cc,"void BlockBuilder::Add(const Slice& key, const Slice& value) {
  Slice last_key_piece(last_key_);
  assert(!finished_);
  assert(counter_ <= options_->block_restart_interval);
  assert(buffer_.empty() // No values yet?
         || options_->comparator->Compare(key, last_key_piece) > 0);
  size_t shared = 0;
  if (counter_ < options_->block_restart_interval) {
    // See how much sharing to do with previous string
    const size_t min_length = std::min(last_key_piece.size(), key.size());
    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } else {
    // Restart compression
    restarts_.push_back(buffer_.size());
    counter_ = 0;
  }
  const size_t non_shared = key.size() - shared;

  // Add ""<shared><non_shared><value_size>"" to buffer_
  PutVarint32(&buffer_, shared);
  PutVarint32(&buffer_, non_shared);
  PutVarint32(&buffer_, value.size());

  // Add string delta to buffer_ followed by value
  buffer_.append(key.data() + shared,...",73.0,107.0,1.0,1.0,35.0,40,15,47,12,0,17,3,4,2,0,,0,17,4,2,2,void
1112,69349,empty,1,leveldb.BlockBuilder.empty,bool leveldb.BlockBuilder.empty (),table\block_builder.hpp,"bool empty() const {
    return buffer_.empty();
  }",38.0,40.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1113,69401,StartBlock,1,leveldb.FilterBlockBuilder.StartBlock,void leveldb.FilterBlockBuilder.StartBlock (uint64_t),table\filter_block.cc,"void FilterBlockBuilder::StartBlock(uint64_t block_offset) {
  uint64_t filter_index = (block_offset / kFilterBase);
  assert(filter_index >= filter_offsets_.size());
  while (filter_index > filter_offsets_.size()) {
    GenerateFilter();
  }
}",22.0,28.0,1.0,1.0,7.0,6,5,7,4,0,2,2,2,1,0,,0,2,2,1,1,void
1114,69428,AddKey,1,leveldb.FilterBlockBuilder.AddKey,void leveldb.FilterBlockBuilder.AddKey (Slice),table\filter_block.cc,"void FilterBlockBuilder::AddKey(const Slice& key) {
  Slice k = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}",30.0,34.0,1.0,1.0,5.0,6,2,7,4,0,3,1,1,0,0,,0,3,2,1,1,void
1115,69457,Finish,1,leveldb.FilterBlockBuilder.Finish,Slice leveldb.FilterBlockBuilder.Finish (),table\filter_block.cc,"Slice FilterBlockBuilder::Finish() {
  if (!start_.empty()) {
    GenerateFilter();
  }

  // Append array of per-filter offsets
  const uint32_t array_offset = result_.size();
  for (size_t i = 0; i < filter_offsets_.size(); i++) {
    PutFixed32(&result_, filter_offsets_[i]);
  }

  PutFixed32(&result_, array_offset);
  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
  return Slice(result_);
}",36.0,50.0,1.0,1.0,15.0,11,6,14,6,0,8,3,3,2,0,,0,8,0,0,0,Slice
1116,69509,GenerateFilter,1,leveldb.FilterBlockBuilder.GenerateFilter,void leveldb.FilterBlockBuilder.GenerateFilter (),table\filter_block.cc,"void FilterBlockBuilder::GenerateFilter() {
  const size_t num_keys = start_.size();
  if (num_keys == 0) {
    // Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  }

  // Make list of keys from flattened key structure
  start_.push_back(keys_.size());  // Simplify length computation
  tmp_keys_.resize(num_keys);
  for (size_t i = 0; i < num_keys; i++) {
    const char* base = keys_.data() + start_[i];
    size_t length = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  // Generate filter for current set of keys and append to result_.
  filter_offsets_.push_back(result_.size());
  policy_->CreateFilter(&tmp_keys_[0], static_cast<int>(num_keys), &result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}",52.0,76.0,1.0,1.0,25.0,31,10,34,10,0,19,3,3,0,0,,0,19,0,0,0,void
1117,69622,FilterBlockReader,1,leveldb.FilterBlockReader.FilterBlockReader,"ANY leveldb.FilterBlockReader.FilterBlockReader (FilterPolicy*,Slice)",table\filter_block.cc,"FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
                                     const Slice& contents)
    : policy_(policy),
      data_(NULL),
      offset_(NULL),
      num_(0),
      base_lg_(0) {
  size_t n = contents.size();
  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
  base_lg_ = contents[n-1];
  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
  if (last_word > n - 5) return;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}",78.0,93.0,1.0,1.0,16.0,20,8,19,7,0,5,3,3,0,0,,0,5,4,2,2,ANY
1118,69688,KeyMayMatch,1,leveldb.FilterBlockReader.KeyMayMatch,"bool leveldb.FilterBlockReader.KeyMayMatch (uint64_t,Slice)",table\filter_block.cc,"bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {
  uint64_t index = block_offset >> base_lg_;
  if (index < num_) {
    uint32_t start = DecodeFixed32(offset_ + index*4);
    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);
    if (start <= limit && limit <= static_cast<size_t>(offset_ - data_)) {
      Slice filter = Slice(data_ + start, limit - start);
      return policy_->KeyMayMatch(key, filter);
    } else if (start == limit) {
      // Empty filters do not match any keys
      return false;
    }
  }
  return true;  // Errors are treated as potential matches
}",95.0,109.0,1.0,1.0,15.0,19,10,24,11,0,8,3,4,3,0,,0,8,4,2,2,bool
1119,70758,EncodeTo,1,leveldb.BlockHandle.EncodeTo,void leveldb.BlockHandle.EncodeTo (ANY*),table\format.cc,"void BlockHandle::EncodeTo(std::string* dst) const {
  // Sanity check that all fields have been set
  assert(offset_ != ~static_cast<uint64_t>(0));
  assert(size_ != ~static_cast<uint64_t>(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}",15.0,21.0,1.0,1.0,7.0,6,3,6,3,0,4,1,1,0,0,,0,4,2,1,1,void
1120,70783,DecodeFrom,1,leveldb.BlockHandle.DecodeFrom,Status leveldb.BlockHandle.DecodeFrom (Slice*),table\format.cc,"Status BlockHandle::DecodeFrom(Slice* input) {
  if (GetVarint64(input, &offset_) &&
      GetVarint64(input, &size_)) {
    return Status::OK();
  } else {
    return Status::Corruption(""bad block handle"");
  }
}",23.0,30.0,1.0,1.0,8.0,4,3,5,4,0,3,2,2,2,0,,0,2,2,1,1,Status
1121,70812,EncodeTo,1,leveldb.Footer.EncodeTo,void leveldb.Footer.EncodeTo (ANY*),table\format.cc,"void Footer::EncodeTo(std::string* dst) const {
  const size_t original_size = dst->size();
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));
  assert(dst->size() == original_size + kEncodedLength);
  (void)original_size;  // Disable unused variable warning.
}",32.0,41.0,1.0,1.0,10.0,15,9,16,7,0,4,1,1,0,0,,0,4,2,1,1,void
1122,70869,DecodeFrom,1,leveldb.Footer.DecodeFrom,Status leveldb.Footer.DecodeFrom (Slice*),table\format.cc,"Status Footer::DecodeFrom(Slice* input) {
  const char* magic_ptr = input->data() + kEncodedLength - 8;
  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |
                          (static_cast<uint64_t>(magic_lo)));
  if (magic != kTableMagicNumber) {
    return Status::Corruption(""not an sstable (bad magic number)"");
  }

  Status result = metaindex_handle_.DecodeFrom(input);
  if (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  if (result.ok()) {
    // We skip over any leftover data (just padding for now) in ""input""
    const char* end = magic_ptr + 8;
    *input = Slice(end, input->data() + input->size() - end);
  }
  return result;
}",43.0,63.0,1.0,1.0,21.0,28,10,29,12,0,4,4,4,0,1,,0,3,2,1,1,Status
1123,70971,ReadBlock,1,leveldb.ReadBlock,"Status leveldb.ReadBlock (RandomAccessFile*,ReadOptions,BlockHandle,BlockContents*)",table\format.cc,"Status ReadBlock(RandomAccessFile* file,
                 const ReadOptions& options,
                 const BlockHandle& handle,
                 BlockContents* result) {
  result->data = Slice();
  result->cachable = false;
  result->heap_allocated = false;

  // Read the block contents as well as the type/crc footer.
  // See table_builder.cc for the code that built this structure.
  size_t n = static_cast<size_t>(handle.size());
  char* buf = new char[n + kBlockTrailerSize];
  Slice contents;
  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);
  if (!s.ok()) {
    delete[] buf;
    return s;
  }
  if (contents.size() != n + kBlockTrailerSize) {
    delete[] buf;
    return Status::Corruption(""truncated block read"");
  }

  // Check the crc of the type and the block contents
  const char* data = contents.data();    // Pointer to where Read put the data
  if (options.verify_checksums) {
    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1...",65.0,142.0,1.0,1.0,78.0,70,11,76,20,0,16,11,13,1,5,,0,11,8,4,4,Status
1124,71267,offset,1,leveldb.BlockHandle.offset,uint64_t leveldb.BlockHandle.offset (),table\format.hpp,uint64_t offset() const { return offset_; },27.0,27.0,3.0,45.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1125,71273,set_offset,1,leveldb.BlockHandle.set_offset,void leveldb.BlockHandle.set_offset (uint64_t),table\format.hpp,void set_offset(uint64_t offset) { offset_ = offset; },28.0,28.0,3.0,56.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1126,71281,size,1,leveldb.BlockHandle.size,uint64_t leveldb.BlockHandle.size (),table\format.hpp,uint64_t size() const { return size_; },31.0,31.0,3.0,41.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1127,71287,set_size,1,leveldb.BlockHandle.set_size,void leveldb.BlockHandle.set_size (uint64_t),table\format.hpp,void set_size(uint64_t size) { size_ = size; },32.0,32.0,3.0,48.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1128,71323,metaindex_handle,1,leveldb.Footer.metaindex_handle,BlockHandle leveldb.Footer.metaindex_handle (),table\format.hpp,const BlockHandle& metaindex_handle() const { return metaindex_handle_; },52.0,52.0,3.0,75.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,BlockHandle
1129,71329,set_metaindex_handle,1,leveldb.Footer.set_metaindex_handle,void leveldb.Footer.set_metaindex_handle (BlockHandle),table\format.hpp,void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; },53.0,53.0,3.0,76.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1130,71337,index_handle,1,leveldb.Footer.index_handle,BlockHandle leveldb.Footer.index_handle (),table\format.hpp,"const BlockHandle& index_handle() const {
    return index_handle_;
  }",56.0,58.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,BlockHandle
1131,71343,set_index_handle,1,leveldb.Footer.set_index_handle,void leveldb.Footer.set_index_handle (BlockHandle),table\format.hpp,"void set_index_handle(const BlockHandle& h) {
    index_handle_ = h;
  }",59.0,61.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1132,71590,status,1,leveldb.anonymous_namespace_11.EmptyIterator.status,Status leveldb.anonymous_namespace_11.EmptyIterator.status (),table\iterator.cc,virtual Status status() const { return status_; },53.0,53.0,3.0,51.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Status
1133,71639,~IteratorWrapper,1,leveldb.IteratorWrapper.~IteratorWrapper,ANY leveldb.IteratorWrapper.~IteratorWrapper (),table\iterator_wrapper.hpp,~IteratorWrapper() { delete iter_; },23.0,23.0,3.0,38.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1134,71645,iter,1,leveldb.IteratorWrapper.iter,Iterator leveldb.IteratorWrapper.iter (),table\iterator_wrapper.hpp,Iterator* iter() const { return iter_; },24.0,24.0,3.0,42.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Iterator
1135,71651,Set,1,leveldb.IteratorWrapper.Set,void leveldb.IteratorWrapper.Set (Iterator*),table\iterator_wrapper.hpp,"void Set(Iterator* iter) {
    delete iter_;
    iter_ = iter;
    if (iter_ == NULL) {
      valid_ = false;
    } else {
      Update();
    }
  }",28.0,36.0,3.0,3.0,9.0,4,3,6,4,0,4,2,2,1,0,,0,4,2,1,1,void
1136,71672,Valid,1,leveldb.IteratorWrapper.Valid,bool leveldb.IteratorWrapper.Valid (),table\iterator_wrapper.hpp,bool Valid() const        { return valid_; },40.0,40.0,3.0,46.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1137,71678,key,1,leveldb.IteratorWrapper.key,Slice leveldb.IteratorWrapper.key (),table\iterator_wrapper.hpp,Slice key() const         { assert(Valid()); return key_; },41.0,41.0,3.0,61.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1138,71686,value,1,leveldb.IteratorWrapper.value,Slice leveldb.IteratorWrapper.value (),table\iterator_wrapper.hpp,Slice value() const       { assert(Valid()); return iter_->value(); },42.0,42.0,3.0,71.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1139,71697,status,1,leveldb.IteratorWrapper.status,Status leveldb.IteratorWrapper.status (),table\iterator_wrapper.hpp,Status status() const     { assert(iter_); return iter_->status(); },44.0,44.0,3.0,70.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,Status
1140,71708,Next,1,leveldb.IteratorWrapper.Next,void leveldb.IteratorWrapper.Next (),table\iterator_wrapper.hpp,void Next()               { assert(iter_); iter_->Next();        Update(); },45.0,45.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
1141,71719,Prev,1,leveldb.IteratorWrapper.Prev,void leveldb.IteratorWrapper.Prev (),table\iterator_wrapper.hpp,void Prev()               { assert(iter_); iter_->Prev();        Update(); },46.0,46.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
1142,71730,Seek,1,leveldb.IteratorWrapper.Seek,void leveldb.IteratorWrapper.Seek (Slice),table\iterator_wrapper.hpp,void Seek(const Slice& k) { assert(iter_); iter_->Seek(k);       Update(); },47.0,47.0,3.0,78.0,1.0,1,1,3,2,0,2,1,1,0,0,,0,2,2,1,1,void
1143,71743,SeekToFirst,1,leveldb.IteratorWrapper.SeekToFirst,void leveldb.IteratorWrapper.SeekToFirst (),table\iterator_wrapper.hpp,void SeekToFirst()        { assert(iter_); iter_->SeekToFirst(); Update(); },48.0,48.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
1144,71754,SeekToLast,1,leveldb.IteratorWrapper.SeekToLast,void leveldb.IteratorWrapper.SeekToLast (),table\iterator_wrapper.hpp,void SeekToLast()         { assert(iter_); iter_->SeekToLast();  Update(); },49.0,49.0,3.0,78.0,1.0,1,1,2,1,0,2,1,1,0,0,,0,2,0,0,0,void
1145,71765,Update,1,leveldb.IteratorWrapper.Update,void leveldb.IteratorWrapper.Update (),table\iterator_wrapper.hpp,"void Update() {
    valid_ = iter_->Valid();
    if (valid_) {
      key_ = iter_->key();
    }
  }",52.0,57.0,3.0,3.0,6.0,4,2,5,3,0,5,2,2,1,0,,0,5,0,0,0,void
1146,71803,MergingIterator,1,leveldb.anonymous_namespace_2.MergingIterator.MergingIterator,"ANY leveldb.anonymous_namespace_2.MergingIterator.MergingIterator (Comparator*,Iterator**,int)",table\merger.cc,"MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(NULL),
        direction_(kForward) {
    for (int i = 0; i < n; i++) {
      children_[i].Set(children[i]);
    }
  }",16.0,25.0,3.0,3.0,10.0,5,4,7,4,0,1,2,2,0,0,,0,1,6,3,3,ANY
1147,71831,~MergingIterator,1,leveldb.anonymous_namespace_3.MergingIterator.~MergingIterator,ANY leveldb.anonymous_namespace_3.MergingIterator.~MergingIterator (),table\merger.cc,"virtual ~MergingIterator() {
    delete[] children_;
  }",27.0,29.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1148,71837,Valid,1,leveldb.anonymous_namespace_4.MergingIterator.Valid,bool leveldb.anonymous_namespace_4.MergingIterator.Valid (),table\merger.cc,"virtual bool Valid() const {
    return (current_ != NULL);
  }",31.0,33.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,0,0,0,bool
1149,71845,SeekToFirst,1,leveldb.anonymous_namespace_5.MergingIterator.SeekToFirst,void leveldb.anonymous_namespace_5.MergingIterator.SeekToFirst (),table\merger.cc,"virtual void SeekToFirst() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }",35.0,41.0,3.0,3.0,7.0,5,4,7,5,0,4,2,2,1,0,,0,4,0,0,0,void
1150,71871,SeekToLast,1,leveldb.anonymous_namespace_6.MergingIterator.SeekToLast,void leveldb.anonymous_namespace_6.MergingIterator.SeekToLast (),table\merger.cc,"virtual void SeekToLast() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToLast();
    }
    FindLargest();
    direction_ = kReverse;
  }",43.0,49.0,3.0,3.0,7.0,5,4,7,5,0,4,2,2,1,0,,0,4,0,0,0,void
1151,71897,Seek,1,leveldb.anonymous_namespace_7.MergingIterator.Seek,void leveldb.anonymous_namespace_7.MergingIterator.Seek (Slice),table\merger.cc,"virtual void Seek(const Slice& target) {
    for (int i = 0; i < n_; i++) {
      children_[i].Seek(target);
    }
    FindSmallest();
    direction_ = kForward;
  }",51.0,57.0,3.0,3.0,7.0,5,4,8,6,0,4,2,2,1,0,,0,4,2,1,1,void
1152,71925,Next,1,leveldb.anonymous_namespace_8.MergingIterator.Next,void leveldb.anonymous_namespace_8.MergingIterator.Next (),table\merger.cc,"virtual void Next() {
    assert(Valid());

    // Ensure that all children are positioned after key().
    // If we are moving in the forward direction, it is already
    // true for all of the non-current_ children since current_ is
    // the smallest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kForward) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }
      }
      direction_ = kForward;
    }

    current_->Next();
    FindSmallest();
  }",59.0,83.0,3.0,3.0,25.0,16,8,18,8,0,9,5,11,5,0,,0,9,0,0,0,void
1153,71995,Prev,1,leveldb.anonymous_namespace_12.MergingIterator.Prev,void leveldb.anonymous_namespace_12.MergingIterator.Prev (),table\merger.cc,"virtual void Prev() {
    assert(Valid());

    // Ensure that all children are positioned before key().
    // If we are moving in the reverse direction, it is already
    // true for all of the non-current_ children since current_ is
    // the largest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kReverse) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }
      }
      direction_ = kReverse;
    }

    current_->Prev();
    FindLargest();
  }",85.0,112.0,3.0,3.0,28.0,12,6,16,7,0,8,5,11,4,0,,0,8,0,0,0,void
1154,72059,key,1,leveldb.anonymous_namespace_15.MergingIterator.key,Slice leveldb.anonymous_namespace_15.MergingIterator.key (),table\merger.cc,"virtual Slice key() const {
    assert(Valid());
    return current_->key();
  }",114.0,117.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1155,72070,value,1,leveldb.anonymous_namespace_17.MergingIterator.value,Slice leveldb.anonymous_namespace_17.MergingIterator.value (),table\merger.cc,"virtual Slice value() const {
    assert(Valid());
    return current_->value();
  }",119.0,122.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1156,72081,status,1,leveldb.anonymous_namespace_19.MergingIterator.status,Status leveldb.anonymous_namespace_19.MergingIterator.status (),table\merger.cc,"virtual Status status() const {
    Status status;
    for (int i = 0; i < n_; i++) {
      status = children_[i].status();
      if (!status.ok()) {
        break;
      }
    }
    return status;
  }",124.0,133.0,3.0,3.0,10.0,7,5,8,4,0,2,4,4,1,0,,0,2,0,0,0,Status
1157,72345,~Rep,1,leveldb.Rep.~Rep,ANY leveldb.Rep.~Rep (),table\table.cc,"~Rep() {
    delete filter;
    delete [] filter_data;
    delete index_block;
  }",21.0,25.0,3.0,3.0,5.0,3,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
1158,73303,Rep,1,leveldb.Rep.Rep,"ANY leveldb.Rep.Rep (Options,WritableFile*)",table\table_builder.cc,"Rep(const Options& opt, WritableFile* f)
      : options(opt),
        index_block_options(opt),
        file(f),
        offset(0),
        data_block(&options),
        index_block(&index_block_options),
        num_entries(0),
        closed(false),
        filter_block(opt.filter_policy == NULL ? NULL
                     : new FilterBlockBuilder(opt.filter_policy)),
        pending_index_entry(false) {
    index_block_options.block_restart_interval = 1;
  }",47.0,60.0,3.0,3.0,14.0,2,2,1,1,0,1,1,1,0,0,,0,1,4,2,2,ANY
1159,74303,contents,1,leveldb.StringSink.contents,string leveldb.StringSink.contents (),table\table_test.cc,const std::string& contents() const { return contents_; },94.0,94.0,3.0,59.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,string
1160,74309,Close,1,leveldb.StringSink.Close,Status leveldb.StringSink.Close (),table\table_test.cc,virtual Status Close() { return Status::OK(); },96.0,96.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1161,74318,Flush,1,leveldb.StringSink.Flush,Status leveldb.StringSink.Flush (),table\table_test.cc,virtual Status Flush() { return Status::OK(); },97.0,97.0,3.0,49.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1162,74327,Sync,1,leveldb.StringSink.Sync,Status leveldb.StringSink.Sync (),table\table_test.cc,virtual Status Sync() { return Status::OK(); },98.0,98.0,3.0,48.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,0,0,0,0,Status
1163,74336,Append,1,leveldb.StringSink.Append,Status leveldb.StringSink.Append (Slice),table\table_test.cc,"virtual Status Append(const Slice& data) {
    contents_.append(data.data(), data.size());
    return Status::OK();
  }",100.0,103.0,3.0,3.0,4.0,4,1,4,3,0,2,1,1,0,0,,0,1,2,1,1,Status
1164,74369,Size,1,leveldb.StringSource.Size,uint64_t leveldb.StringSource.Size (),table\table_test.cc,uint64_t Size() const { return contents_.size(); },118.0,118.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,uint64_t
1165,74378,Read,1,leveldb.StringSource.Read,"Status leveldb.StringSource.Read (uint64_t,size_t,Slice*,char*)",table\table_test.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                       char* scratch) const {
    if (offset > contents_.size()) {
      return Status::InvalidArgument(""invalid Read offset"");
    }
    if (offset + n > contents_.size()) {
      n = contents_.size() - offset;
    }
    memcpy(scratch, &contents_[offset], n);
    *result = Slice(scratch, n);
    return Status::OK();
  }",120.0,131.0,3.0,3.0,12.0,14,8,17,6,0,6,3,3,2,1,,0,4,8,4,4,Status
1166,74448,Add,1,leveldb.Constructor.Add,"void leveldb.Constructor.Add (ANY,Slice)",table\table_test.cc,"void Add(const std::string& key, const Slice& value) {
    data_[key] = value.ToString();
  }",146.0,148.0,3.0,3.0,3.0,3,3,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1167,74462,Finish,1,leveldb.Constructor.Finish,"void leveldb.Constructor.Finish (Options,ANY*,KVMap*)",table\table_test.cc,"void Finish(const Options& options,
              std::vector<std::string>* keys,
              KVMap* kvmap) {
    *kvmap = data_;
    keys->clear();
    for (KVMap::const_iterator it = data_.begin();
         it != data_.end();
         ++it) {
      keys->push_back(it->first);
    }
    data_.clear();
    Status s = FinishImpl(options, *kvmap);
    ASSERT_TRUE(s.ok()) << s.ToString();
  }",153.0,166.0,3.0,4.0,14.0,19,6,18,7,0,4,2,2,1,0,,0,4,6,3,3,void
1168,74550,data,1,leveldb.Constructor.data,KVMap leveldb.Constructor.data (),table\table_test.cc,virtual const KVMap& data() { return data_; },173.0,173.0,3.0,47.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,KVMap
1169,74569,~BlockConstructor,1,leveldb.BlockConstructor.~BlockConstructor,ANY leveldb.BlockConstructor.~BlockConstructor (),table\table_test.cc,"~BlockConstructor() {
    delete block_;
  }",187.0,189.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1170,74575,FinishImpl,1,leveldb.BlockConstructor.FinishImpl,"Status leveldb.BlockConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete block_;
    block_ = NULL;
    BlockBuilder builder(&options);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
    }
    // Open the block
    data_ = builder.Finish().ToString();
    BlockContents contents;
    contents.data = data_;
    contents.cachable = false;
    contents.heap_allocated = false;
    block_ = new Block(contents);
    return Status::OK();
  }",190.0,208.0,3.0,3.0,19.0,22,7,21,10,0,9,2,2,0,0,,0,8,4,2,2,Status
1171,74653,NewIterator,1,leveldb.BlockConstructor.NewIterator,Iterator leveldb.BlockConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return block_->NewIterator(comparator_);
  }",209.0,211.0,3.0,3.0,3.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,Iterator
1172,74681,FinishImpl,1,leveldb.TableConstructor.FinishImpl,"Status leveldb.TableConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    Reset();
    StringSink sink;
    TableBuilder builder(options, &sink);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }
    Status s = builder.Finish();
    ASSERT_TRUE(s.ok()) << s.ToString();

    ASSERT_EQ(sink.contents().size(), builder.FileSize());

    // Open the table
    source_ = new StringSource(sink.contents());
    Options table_options;
    table_options.comparator = options.comparator;
    return Table::Open(table_options, source_, sink.contents().size(), &table_);
  }",230.0,251.0,3.0,6.0,22.0,43,7,36,14,0,5,2,2,0,0,,0,5,4,2,2,Status
1173,74851,NewIterator,1,leveldb.TableConstructor.NewIterator,Iterator leveldb.TableConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return table_->NewIterator(ReadOptions());
  }",253.0,255.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Iterator
1174,74861,ApproximateOffsetOf,1,leveldb.TableConstructor.ApproximateOffsetOf,uint64_t leveldb.TableConstructor.ApproximateOffsetOf (Slice),table\table_test.cc,"uint64_t ApproximateOffsetOf(const Slice& key) const {
    return table_->ApproximateOffsetOf(key);
  }",257.0,259.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,uint64_t
1175,74872,Reset,1,leveldb.TableConstructor.Reset,void leveldb.TableConstructor.Reset (),table\table_test.cc,"void Reset() {
    delete table_;
    delete source_;
    table_ = NULL;
    source_ = NULL;
  }",262.0,267.0,3.0,3.0,6.0,4,2,6,3,0,4,1,1,0,0,,0,4,0,0,0,void
1176,74898,~KeyConvertingIterator,1,leveldb.KeyConvertingIterator.~KeyConvertingIterator,ANY leveldb.KeyConvertingIterator.~KeyConvertingIterator (),table\table_test.cc,virtual ~KeyConvertingIterator() { delete iter_; },279.0,279.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1177,74904,Valid,1,leveldb.KeyConvertingIterator.Valid,bool leveldb.KeyConvertingIterator.Valid (),table\table_test.cc,virtual bool Valid() const { return iter_->Valid(); },280.0,280.0,3.0,55.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1178,74913,Seek,1,leveldb.KeyConvertingIterator.Seek,void leveldb.KeyConvertingIterator.Seek (Slice),table\table_test.cc,"virtual void Seek(const Slice& target) {
    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);
    std::string encoded;
    AppendInternalKey(&encoded, ikey);
    iter_->Seek(encoded);
  }",281.0,286.0,3.0,3.0,6.0,2,2,7,6,0,1,1,1,0,0,,0,1,2,1,1,void
1179,74933,SeekToFirst,1,leveldb.KeyConvertingIterator.SeekToFirst,void leveldb.KeyConvertingIterator.SeekToFirst (),table\table_test.cc,virtual void SeekToFirst() { iter_->SeekToFirst(); },287.0,287.0,3.0,54.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1180,74941,SeekToLast,1,leveldb.KeyConvertingIterator.SeekToLast,void leveldb.KeyConvertingIterator.SeekToLast (),table\table_test.cc,virtual void SeekToLast() { iter_->SeekToLast(); },288.0,288.0,3.0,52.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1181,74949,Next,1,leveldb.KeyConvertingIterator.Next,void leveldb.KeyConvertingIterator.Next (),table\table_test.cc,virtual void Next() { iter_->Next(); },289.0,289.0,3.0,40.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1182,74957,Prev,1,leveldb.KeyConvertingIterator.Prev,void leveldb.KeyConvertingIterator.Prev (),table\table_test.cc,virtual void Prev() { iter_->Prev(); },290.0,290.0,3.0,40.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1183,74965,key,1,leveldb.KeyConvertingIterator.key,Slice leveldb.KeyConvertingIterator.key (),table\table_test.cc,"virtual Slice key() const {
    assert(Valid());
    ParsedInternalKey key;
    if (!ParseInternalKey(iter_->key(), &key)) {
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }
    return key.user_key;
  }",292.0,300.0,3.0,3.0,9.0,6,5,5,4,0,4,2,2,1,1,,0,4,0,0,0,Slice
1184,74996,value,1,leveldb.KeyConvertingIterator.value,Slice leveldb.KeyConvertingIterator.value (),table\table_test.cc,virtual Slice value() const { return iter_->value(); },302.0,302.0,3.0,56.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1185,75005,status,1,leveldb.KeyConvertingIterator.status,Status leveldb.KeyConvertingIterator.status (),table\table_test.cc,"virtual Status status() const {
    return status_.ok() ? iter_->status() : status_;
  }",303.0,305.0,3.0,3.0,3.0,3,3,3,2,0,3,1,1,0,0,,0,3,0,0,0,Status
1186,75033,MemTableConstructor,1,leveldb.MemTableConstructor.MemTableConstructor,ANY leveldb.MemTableConstructor.MemTableConstructor (Comparator*),table\table_test.cc,"explicit MemTableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        internal_comparator_(cmp) {
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
  }",318.0,323.0,3.0,3.0,6.0,3,3,4,3,0,3,1,1,0,0,,0,3,2,1,1,ANY
1187,75047,~MemTableConstructor,1,leveldb.MemTableConstructor.~MemTableConstructor,ANY leveldb.MemTableConstructor.~MemTableConstructor (),table\table_test.cc,"~MemTableConstructor() {
    memtable_->Unref();
  }",324.0,326.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1188,75055,FinishImpl,1,leveldb.MemTableConstructor.FinishImpl,"Status leveldb.MemTableConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    memtable_->Unref();
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
    int seq = 1;
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }
    return Status::OK();
  }",327.0,339.0,3.0,3.0,13.0,14,6,17,8,0,6,2,2,0,0,,0,5,4,2,2,Status
1189,75115,NewIterator,1,leveldb.MemTableConstructor.NewIterator,Iterator leveldb.MemTableConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return new KeyConvertingIterator(memtable_->NewIterator());
  }",340.0,342.0,3.0,3.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,0,0,0,Iterator
1190,75129,DBConstructor,1,leveldb.DBConstructor.DBConstructor,ANY leveldb.DBConstructor.DBConstructor (Comparator*),table\table_test.cc,"explicit DBConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp) {
    db_ = NULL;
    NewDB();
  }",351.0,356.0,3.0,3.0,6.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,ANY
1191,75138,~DBConstructor,1,leveldb.DBConstructor.~DBConstructor,ANY leveldb.DBConstructor.~DBConstructor (),table\table_test.cc,"~DBConstructor() {
    delete db_;
  }",357.0,359.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1192,75144,FinishImpl,1,leveldb.DBConstructor.FinishImpl,"Status leveldb.DBConstructor.FinishImpl (Options,KVMap)",table\table_test.cc,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete db_;
    db_ = NULL;
    NewDB();
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }
    return Status::OK();
  }",360.0,372.0,3.0,6.0,13.0,16,6,15,7,0,4,2,2,0,0,,0,3,4,2,2,Status
1193,75214,NewIterator,1,leveldb.DBConstructor.NewIterator,Iterator leveldb.DBConstructor.NewIterator (),table\table_test.cc,"virtual Iterator* NewIterator() const {
    return db_->NewIterator(ReadOptions());
  }",373.0,375.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Iterator
1194,75224,db,1,leveldb.DBConstructor.db,DB leveldb.DBConstructor.db (),table\table_test.cc,virtual DB* db() const { return db_; },377.0,377.0,3.0,40.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,DB
1195,75230,NewDB,1,leveldb.DBConstructor.NewDB,void leveldb.DBConstructor.NewDB (),table\table_test.cc,"void NewDB() {
    std::string name = test::TmpDir() + ""/table_testdb"";

    Options options;
    options.comparator = comparator_;
    Status status = DestroyDB(name, options);
    ASSERT_TRUE(status.ok()) << status.ToString();

    options.create_if_missing = true;
    options.error_if_exists = true;
    options.write_buffer_size = 10000;  // Something small to force merging
    status = DB::Open(options, name, &db_);
    ASSERT_TRUE(status.ok()) << status.ToString();
  }",380.0,393.0,3.0,4.0,14.0,29,5,25,8,0,6,1,1,0,0,,0,6,0,0,0,void
1196,75428,Init,1,leveldb.Harness.Init,void leveldb.Harness.Init (TestArgs),table\table_test.cc,"void Init(const TestArgs& args) {
    delete constructor_;
    constructor_ = NULL;
    options_ = Options();

    options_.block_restart_interval = args.restart_interval;
    // Use shorter block size for tests to exercise block boundary
    // conditions more.
    options_.block_size = 256;
    if (args.reverse_compare) {
      options_.comparator = &reverse_key_comparator;
    }
    switch (args.type) {
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }
  }",441.0,467.0,3.0,3.0,27.0,25,5,27,13,0,17,7,3,2,0,,0,17,2,1,1,void
1197,75509,~Harness,1,leveldb.Harness.~Harness,ANY leveldb.Harness.~Harness (),table\table_test.cc,"~Harness() {
    delete constructor_;
  }",469.0,471.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1198,75515,Add,1,leveldb.Harness.Add,"void leveldb.Harness.Add (ANY,ANY)",table\table_test.cc,"void Add(const std::string& key, const std::string& value) {
    constructor_->Add(key, value);
  }",473.0,475.0,3.0,3.0,3.0,1,1,3,3,0,1,1,1,0,0,,0,1,4,2,2,void
1199,75527,Test,1,leveldb.Harness.Test,void leveldb.Harness.Test (Random*),table\table_test.cc,"void Test(Random* rnd) {
    std::vector<std::string> keys;
    KVMap data;
    constructor_->Finish(options_, &keys, &data);

    TestForwardScan(keys, data);
    TestBackwardScan(keys, data);
    TestRandomAccess(rnd, keys, data);
  }",477.0,485.0,3.0,3.0,9.0,7,5,14,6,0,2,1,1,0,0,,0,2,2,1,1,void
1200,75561,TestForwardScan,1,leveldb.Harness.TestForwardScan,"void leveldb.Harness.TestForwardScan (ANY,KVMap)",table\table_test.cc,"void TestForwardScan(const std::vector<std::string>& keys,
                       const KVMap& data) {
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToFirst();
    for (KVMap::const_iterator model_iter = data.begin();
         model_iter != data.end();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Next();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",487.0,500.0,3.0,4.0,14.0,26,6,23,6,0,1,2,2,0,0,,0,1,4,2,2,void
1201,75670,TestBackwardScan,1,leveldb.Harness.TestBackwardScan,"void leveldb.Harness.TestBackwardScan (ANY,KVMap)",table\table_test.cc,"void TestBackwardScan(const std::vector<std::string>& keys,
                        const KVMap& data) {
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToLast();
    for (KVMap::const_reverse_iterator model_iter = data.rbegin();
         model_iter != data.rend();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Prev();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",502.0,515.0,3.0,4.0,14.0,26,6,23,6,0,1,2,2,0,0,,0,1,4,2,2,void
1202,75779,TestRandomAccess,1,leveldb.Harness.TestRandomAccess,"void leveldb.Harness.TestRandomAccess (Random*,ANY,KVMap)",table\table_test.cc,"void TestRandomAccess(Random* rnd,
                        const std::vector<std::string>& keys,
                        const KVMap& data) {
    static const bool kVerbose = false;
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    KVMap::const_iterator model_iter = data.begin();
    if (kVerbose) fprintf(stderr, ""---\n"");
    for (int i = 0; i < 200; i++) {
      const int toss = rnd->Uniform(5);
      switch (toss) {
        case 0: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }

        case 1: {
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 2: {
          std::string...",517.0,585.0,3.0,4.0,69.0,53,8,82,13,0,1,18,35,0,0,,0,1,6,3,3,void
1203,76306,db,1,leveldb.Harness.db,DB leveldb.Harness.db (),table\table_test.cc,DB* db() const { return constructor_->db(); },640.0,640.0,3.0,47.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,DB
1204,78056,Valid,1,leveldb.anonymous_namespace_10.TwoLevelIterator.Valid,bool leveldb.anonymous_namespace_10.TwoLevelIterator.Valid (),table\two_level_iterator.cc,"virtual bool Valid() const {
    return data_iter_.Valid();
  }",34.0,36.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,bool
1205,78065,key,1,leveldb.anonymous_namespace_11.TwoLevelIterator.key,Slice leveldb.anonymous_namespace_11.TwoLevelIterator.key (),table\two_level_iterator.cc,"virtual Slice key() const {
    assert(Valid());
    return data_iter_.key();
  }",37.0,40.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1206,78076,value,1,leveldb.anonymous_namespace_13.TwoLevelIterator.value,Slice leveldb.anonymous_namespace_13.TwoLevelIterator.value (),table\two_level_iterator.cc,"virtual Slice value() const {
    assert(Valid());
    return data_iter_.value();
  }",41.0,44.0,3.0,3.0,4.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,Slice
1207,78087,status,1,leveldb.anonymous_namespace_15.TwoLevelIterator.status,Status leveldb.anonymous_namespace_15.TwoLevelIterator.status (),table\two_level_iterator.cc,"virtual Status status() const {
    // It'd be nice if status() returned a const Status& instead of a Status
    if (!index_iter_.status().ok()) {
      return index_iter_.status();
    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
      return data_iter_.status();
    } else {
      return status_;
    }
  }",45.0,54.0,3.0,3.0,10.0,4,2,2,1,0,2,2,2,1,0,,0,2,0,0,0,Status
1208,78134,SaveError,1,leveldb.anonymous_namespace_16.TwoLevelIterator.SaveError,void leveldb.anonymous_namespace_16.TwoLevelIterator.SaveError (Status),table\two_level_iterator.cc,"void SaveError(const Status& s) {
    if (status_.ok() && !s.ok()) status_ = s;
  }",57.0,59.0,3.0,3.0,3.0,5,4,4,2,0,2,2,2,1,0,,0,2,2,1,1,void
1209,78500,Arena,1,leveldb.Arena.Arena,ANY leveldb.Arena.Arena (),util\arena.cc,"Arena::Arena() : memory_usage_(0) {
  alloc_ptr_ = NULL;  // First allocation will allocate a block
  alloc_bytes_remaining_ = 0;
}",12.0,15.0,1.0,1.0,4.0,2,1,3,3,0,2,1,1,0,0,,0,2,0,0,0,ANY
1210,78510,~Arena,1,leveldb.Arena.~Arena,ANY leveldb.Arena.~Arena (),util\arena.cc,"Arena::~Arena() {
  for (size_t i = 0; i < blocks_.size(); i++) {
    delete[] blocks_[i];
  }
}",17.0,21.0,1.0,1.0,5.0,5,5,5,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1211,78533,AllocateFallback,1,leveldb.Arena.AllocateFallback,char* leveldb.Arena.AllocateFallback (size_t),util\arena.cc,"char* Arena::AllocateFallback(size_t bytes) {
  if (bytes > kBlockSize / 4) {
    // Object is more than a quarter of our block size.  Allocate it separately
    // to avoid wasting too much space in leftover bytes.
    char* result = AllocateNewBlock(bytes);
    return result;
  }

  // We waste the remaining space in the current block.
  alloc_ptr_ = AllocateNewBlock(kBlockSize);
  alloc_bytes_remaining_ = kBlockSize;

  char* result = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  return result;
}",23.0,39.0,1.0,1.0,17.0,8,5,16,5,0,5,2,2,0,0,,0,5,2,1,1,char*
1212,78571,AllocateAligned,1,leveldb.Arena.AllocateAligned,char* leveldb.Arena.AllocateAligned (size_t),util\arena.cc,"char* Arena::AllocateAligned(size_t bytes) {
  const int align = (sizeof(void*) > 8) ? sizeof(void*) : 8;
  assert((align & (align-1)) == 0);   // Pointer size should be a power of 2
  size_t current_mod = reinterpret_cast<uintptr_t>(alloc_ptr_) & (align-1);
  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
  size_t needed = bytes + slop;
  char* result;
  if (needed <= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } else {
    // AllocateFallback always returned aligned memory
    result = AllocateFallback(bytes);
  }
  assert((reinterpret_cast<uintptr_t>(result) & (align-1)) == 0);
  return result;
}",41.0,58.0,1.0,1.0,18.0,27,12,27,9,0,5,2,2,1,0,,0,5,2,1,1,char*
1213,78657,AllocateNewBlock,1,leveldb.Arena.AllocateNewBlock,char* leveldb.Arena.AllocateNewBlock (size_t),util\arena.cc,"char* Arena::AllocateNewBlock(size_t block_bytes) {
  char* result = new char[block_bytes];
  blocks_.push_back(result);
  memory_usage_.NoBarrier_Store(
      reinterpret_cast<void*>(MemoryUsage() + block_bytes + sizeof(char*)));
  return result;
}",60.0,66.0,1.0,1.0,7.0,8,6,8,5,0,2,1,1,0,0,,0,2,2,1,1,char*
1214,78721,MemoryUsage,1,leveldb.Arena.MemoryUsage,size_t leveldb.Arena.MemoryUsage (),util\arena.hpp,"size_t MemoryUsage() const {
    return reinterpret_cast<uintptr_t>(memory_usage_.NoBarrier_Load());
  }",29.0,31.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1215,79171,BloomFilterPolicy,1,leveldb.anonymous_namespace_3.BloomFilterPolicy.BloomFilterPolicy,ANY leveldb.anonymous_namespace_3.BloomFilterPolicy.BloomFilterPolicy (int),util\bloom.cc,"explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }",23.0,29.0,3.0,3.0,7.0,7,5,6,2,0,5,3,3,2,0,,0,5,2,1,1,ANY
1216,79205,CreateFilter,1,leveldb.anonymous_namespace_5.BloomFilterPolicy.CreateFilter,"void leveldb.anonymous_namespace_5.BloomFilterPolicy.CreateFilter (Slice*,int,ANY*)",util\bloom.cc,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (int i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += d...",35.0,61.0,3.0,3.0,27.0,36,15,39,14,0,3,4,5,1,0,,0,3,6,3,3,void
1217,79486,~BloomTest,1,leveldb.BloomTest.~BloomTest,ANY leveldb.BloomTest.~BloomTest (),util\bloom_test.cc,"~BloomTest() {
    delete policy_;
  }",30.0,32.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1218,79492,Reset,1,leveldb.BloomTest.Reset,void leveldb.BloomTest.Reset (),util\bloom_test.cc,"void Reset() {
    keys_.clear();
    filter_.clear();
  }",34.0,37.0,3.0,3.0,4.0,2,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,void
1219,79504,Add,1,leveldb.BloomTest.Add,void leveldb.BloomTest.Add (Slice),util\bloom_test.cc,"void Add(const Slice& s) {
    keys_.push_back(s.ToString());
  }",39.0,41.0,3.0,3.0,3.0,2,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1220,79517,Build,1,leveldb.BloomTest.Build,void leveldb.BloomTest.Build (),util\bloom_test.cc,"void Build() {
    std::vector<Slice> key_slices;
    for (size_t i = 0; i < keys_.size(); i++) {
      key_slices.push_back(Slice(keys_[i]));
    }
    filter_.clear();
    policy_->CreateFilter(&key_slices[0], static_cast<int>(key_slices.size()),
                          &filter_);
    keys_.clear();
    if (kVerbose >= 2) DumpFilter();
  }",43.0,53.0,3.0,3.0,11.0,14,8,13,6,0,6,3,3,1,0,,0,6,0,0,0,void
1221,79575,FilterSize,1,leveldb.BloomTest.FilterSize,size_t leveldb.BloomTest.FilterSize (),util\bloom_test.cc,"size_t FilterSize() const {
    return filter_.size();
  }",55.0,57.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,size_t
1222,79584,DumpFilter,1,leveldb.BloomTest.DumpFilter,void leveldb.BloomTest.DumpFilter (),util\bloom_test.cc,"void DumpFilter() {
    fprintf(stderr, ""F("");
    for (size_t i = 0; i+1 < filter_.size(); i++) {
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c"", (c & (1 <<j)) ? '1' : '.');
      }
    }
    fprintf(stderr, "")\n"");
  }",59.0,68.0,3.0,3.0,10.0,12,9,13,5,0,2,3,4,1,0,,0,2,0,0,0,void
1223,79642,Matches,1,leveldb.BloomTest.Matches,bool leveldb.BloomTest.Matches (Slice),util\bloom_test.cc,"bool Matches(const Slice& s) {
    if (!keys_.empty()) {
      Build();
    }
    return policy_->KeyMayMatch(s, filter_);
  }",70.0,75.0,3.0,3.0,6.0,3,3,4,4,0,3,2,2,1,0,,0,3,2,1,1,bool
1224,80191,key,1,leveldb.anonymous_namespace_3.LRUHandle.key,Slice leveldb.anonymous_namespace_3.LRUHandle.key (),util\cache.cc,"Slice key() const {
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in ""value"".
    if (next == this) {
      return *(reinterpret_cast<Slice*>(value));
    } else {
      return Slice(key_data, key_length);
    }
  }",55.0,63.0,3.0,3.0,9.0,3,3,2,2,0,2,2,2,1,0,,0,2,0,0,0,Slice
1225,80223,~HandleTable,1,leveldb.anonymous_namespace_7.HandleTable.~HandleTable,ANY leveldb.anonymous_namespace_7.HandleTable.~HandleTable (),util\cache.cc,~HandleTable() { delete[] list_; },74.0,74.0,3.0,36.0,1.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1226,80240,Insert,1,leveldb.anonymous_namespace_10.HandleTable.Insert,LRUHandle leveldb.anonymous_namespace_10.HandleTable.Insert (LRUHandle*),util\cache.cc,"LRUHandle* Insert(LRUHandle* h) {
    LRUHandle** ptr = FindPointer(h->key(), h->hash);
    LRUHandle* old = *ptr;
    h->next_hash = (old == NULL ? NULL : old->next_hash);
    *ptr = h;
    if (old == NULL) {
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }
    return old;
  }",80.0,94.0,3.0,3.0,15.0,15,7,18,6,0,6,3,4,2,0,,0,6,2,1,1,LRUHandle
1227,80292,Remove,1,leveldb.anonymous_namespace_13.HandleTable.Remove,"LRUHandle leveldb.anonymous_namespace_13.HandleTable.Remove (Slice,uint32_t)",util\cache.cc,"LRUHandle* Remove(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = FindPointer(key, hash);
    LRUHandle* result = *ptr;
    if (result != NULL) {
      *ptr = result->next_hash;
      --elems_;
    }
    return result;
  }",96.0,104.0,3.0,3.0,9.0,8,5,11,6,0,2,2,2,0,0,,0,2,4,2,2,LRUHandle
1228,80327,FindPointer,1,leveldb.anonymous_namespace_15.HandleTable.FindPointer,"LRUHandle leveldb.anonymous_namespace_15.HandleTable.FindPointer (Slice,uint32_t)",util\cache.cc,"LRUHandle** FindPointer(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = &list_[hash & (length_ - 1)];
    while (*ptr != NULL &&
           ((*ptr)->hash != hash || key != (*ptr)->key())) {
      ptr = &(*ptr)->next_hash;
    }
    return ptr;
  }",116.0,123.0,3.0,3.0,8.0,19,10,13,6,0,2,2,2,0,0,,0,2,4,2,2,LRUHandle
1229,80374,Resize,1,leveldb.anonymous_namespace_16.HandleTable.Resize,void leveldb.anonymous_namespace_16.HandleTable.Resize (),util\cache.cc,"void Resize() {
    uint32_t new_length = 4;
    while (new_length < elems_) {
      new_length *= 2;
    }
    LRUHandle** new_list = new LRUHandle*[new_length];
    memset(new_list, 0, sizeof(new_list[0]) * new_length);
    uint32_t count = 0;
    for (uint32_t i = 0; i < length_; i++) {
      LRUHandle* h = list_[i];
      while (h != NULL) {
        LRUHandle* next = h->next_hash;
        uint32_t hash = h->hash;
        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
        h->next_hash = *ptr;
        *ptr = h;
        h = next;
        count++;
      }
    }
    assert(elems_ == count);
    delete[] list_;
    list_ = new_list;
    length_ = new_length;
  }",125.0,149.0,3.0,3.0,25.0,34,16,40,13,0,10,4,5,2,0,,0,10,0,0,0,void
1230,80490,SetCapacity,1,leveldb.anonymous_namespace_20.LRUCache.SetCapacity,void leveldb.anonymous_namespace_20.LRUCache.SetCapacity (size_t),util\cache.cc,void SetCapacity(size_t capacity) { capacity_ = capacity; },159.0,159.0,3.0,61.0,1.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1231,80528,TotalCharge,1,leveldb.anonymous_namespace_26.LRUCache.TotalCharge,size_t leveldb.anonymous_namespace_26.LRUCache.TotalCharge (),util\cache.cc,"size_t TotalCharge() const {
    MutexLock l(&mutex_);
    return usage_;
  }",169.0,172.0,3.0,3.0,4.0,1,1,2,2,0,2,1,1,0,0,,0,2,0,0,0,size_t
1232,80648,Ref,1,leveldb.anonymous_namespace_35.LRUCache.Ref,void leveldb.anonymous_namespace_35.LRUCache.Ref (LRUHandle*),util\cache.cc,"void LRUCache::Ref(LRUHandle* e) {
  if (e->refs == 1 && e->in_cache) {  // If on lru_ list, move to in_use_ list.
    LRU_Remove(e);
    LRU_Append(&in_use_, e);
  }
  e->refs++;
}",221.0,227.0,1.0,1.0,7.0,7,5,6,2,0,3,2,2,2,0,,0,3,2,1,1,void
1233,80674,Unref,1,leveldb.anonymous_namespace_36.LRUCache.Unref,void leveldb.anonymous_namespace_36.LRUCache.Unref (LRUHandle*),util\cache.cc,"void LRUCache::Unref(LRUHandle* e) {
  assert(e->refs > 0);
  e->refs--;
  if (e->refs == 0) { // Deallocate.
    assert(!e->in_cache);
    (*e->deleter)(e->key(), e->value);
    free(e);
  } else if (e->in_cache && e->refs == 1) {  // No longer in use; move to lru_ list.
    LRU_Remove(e);
    LRU_Append(&lru_, e);
  }
}",229.0,240.0,1.0,1.0,12.0,12,6,8,1,0,5,2,2,1,0,,0,5,2,1,1,void
1234,80734,LRU_Remove,1,leveldb.anonymous_namespace_37.LRUCache.LRU_Remove,void leveldb.anonymous_namespace_37.LRUCache.LRU_Remove (LRUHandle*),util\cache.cc,"void LRUCache::LRU_Remove(LRUHandle* e) {
  e->next->prev = e->prev;
  e->prev->next = e->next;
}",242.0,245.0,1.0,1.0,4.0,8,2,4,1,0,4,1,1,0,0,,0,4,2,1,1,void
1235,80757,LRU_Append,1,leveldb.anonymous_namespace_38.LRUCache.LRU_Append,"void leveldb.anonymous_namespace_38.LRUCache.LRU_Append (LRUHandle*,LRUHandle*)",util\cache.cc,"void LRUCache::LRU_Append(LRUHandle* list, LRUHandle* e) {
  // Make ""e"" newest entry by inserting just before *list
  e->next = list;
  e->prev = list->prev;
  e->prev->next = e;
  e->next->prev = e;
}",247.0,253.0,1.0,1.0,7.0,11,2,8,2,0,5,1,1,0,0,,0,5,4,2,2,void
1236,80832,Insert,1,leveldb.anonymous_namespace_43.LRUCache.Insert,"Handle leveldb.anonymous_namespace_43.LRUCache.Insert (Slice,uint32_t,void*,size_t,void)",util\cache.cc,"Cache::Handle* LRUCache::Insert(
    const Slice& key, uint32_t hash, void* value, size_t charge,
    void (*deleter)(const Slice& key, void* value)) {
  MutexLock l(&mutex_);

  LRUHandle* e = reinterpret_cast<LRUHandle*>(
      malloc(sizeof(LRUHandle)-1 + key.size()));
  e->value = value;
  e->deleter = deleter;
  e->charge = charge;
  e->key_length = key.size();
  e->hash = hash;
  e->in_cache = false;
  e->refs = 1;  // for the returned handle.
  memcpy(e->key_data, key.data(), key.size());

  if (capacity_ > 0) {
    e->refs++;  // for the cache's reference.
    e->in_cache = true;
    LRU_Append(&in_use_, e);
    usage_ += charge;
    FinishErase(table_.Insert(e));
  } // else don't cache.  (Tests use capacity_==0 to turn off caching.)

  while (usage_ > capacity_ && lru_.next != &lru_) {
    LRUHandle* old = lru_.next;
    assert(old->refs == 1);
    bool erased = FinishErase(table_.Remove(old->key(), old->hash));
    if (!erased) {  // to avoid unused variable when compiled...",269.0,303.0,1.0,1.0,35.0,48,15,42,15,0,11,4,5,0,0,,0,11,10,5,5,Handle
1237,80986,FinishErase,1,leveldb.anonymous_namespace_47.LRUCache.FinishErase,bool leveldb.anonymous_namespace_47.LRUCache.FinishErase (LRUHandle*),util\cache.cc,"bool LRUCache::FinishErase(LRUHandle* e) {
  if (e != NULL) {
    assert(e->in_cache);
    LRU_Remove(e);
    e->in_cache = false;
    usage_ -= e->charge;
    Unref(e);
  }
  return e != NULL;
}",307.0,316.0,1.0,1.0,10.0,7,4,10,3,0,3,2,2,0,0,,0,3,2,1,1,bool
1238,81035,Prune,1,leveldb.anonymous_namespace_52.LRUCache.Prune,void leveldb.anonymous_namespace_52.LRUCache.Prune (),util\cache.cc,"void LRUCache::Prune() {
  MutexLock l(&mutex_);
  while (lru_.next != &lru_) {
    LRUHandle* e = lru_.next;
    assert(e->refs == 1);
    bool erased = FinishErase(table_.Remove(e->key(), e->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }
}",323.0,333.0,1.0,1.0,11.0,13,7,12,5,0,2,3,4,0,0,,0,2,0,0,0,void
1239,81125,ShardedLRUCache,1,leveldb.anonymous_namespace_57.ShardedLRUCache.ShardedLRUCache,ANY leveldb.anonymous_namespace_57.ShardedLRUCache.ShardedLRUCache (size_t),util\cache.cc,"explicit ShardedLRUCache(size_t capacity)
      : last_id_(0) {
    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].SetCapacity(per_shard);
    }
  }",353.0,359.0,3.0,3.0,7.0,8,7,10,5,0,1,2,2,0,0,,0,1,2,1,1,ANY
1240,81163,Insert,1,leveldb.anonymous_namespace_59.ShardedLRUCache.Insert,"Handle leveldb.anonymous_namespace_59.ShardedLRUCache.Insert (Slice,void*,size_t,void)",util\cache.cc,"virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  }",361.0,365.0,3.0,3.0,5.0,3,3,9,6,0,1,1,1,0,0,,0,1,8,4,4,Handle
1241,81189,Lookup,1,leveldb.anonymous_namespace_64.ShardedLRUCache.Lookup,Handle leveldb.anonymous_namespace_64.ShardedLRUCache.Lookup (Slice),util\cache.cc,"virtual Handle* Lookup(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Lookup(key, hash);
  }",366.0,369.0,3.0,3.0,4.0,3,3,6,3,0,1,1,1,0,0,,0,1,2,1,1,Handle
1242,81209,Release,1,leveldb.anonymous_namespace_69.ShardedLRUCache.Release,void leveldb.anonymous_namespace_69.ShardedLRUCache.Release (Handle*),util\cache.cc,"virtual void Release(Handle* handle) {
    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);
    shard_[Shard(h->hash)].Release(handle);
  }",370.0,373.0,3.0,3.0,4.0,5,5,5,3,0,2,1,1,0,0,,0,2,2,1,1,void
1243,81230,Erase,1,leveldb.anonymous_namespace_72.ShardedLRUCache.Erase,void leveldb.anonymous_namespace_72.ShardedLRUCache.Erase (Slice),util\cache.cc,"virtual void Erase(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    shard_[Shard(hash)].Erase(key, hash);
  }",374.0,377.0,3.0,3.0,4.0,3,3,6,3,0,1,1,1,0,0,,0,1,2,1,1,void
1244,81260,NewId,1,leveldb.anonymous_namespace_78.ShardedLRUCache.NewId,uint64_t leveldb.anonymous_namespace_78.ShardedLRUCache.NewId (),util\cache.cc,"virtual uint64_t NewId() {
    MutexLock l(&id_mutex_);
    return ++(last_id_);
  }",381.0,384.0,3.0,3.0,4.0,2,2,2,2,0,2,1,1,0,0,,0,2,0,0,0,uint64_t
1245,81271,Prune,1,leveldb.anonymous_namespace_79.ShardedLRUCache.Prune,void leveldb.anonymous_namespace_79.ShardedLRUCache.Prune (),util\cache.cc,"virtual void Prune() {
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].Prune();
    }
  }",385.0,389.0,3.0,3.0,5.0,4,4,5,3,0,1,2,2,0,0,,0,1,0,0,0,void
1246,81293,TotalCharge,1,leveldb.anonymous_namespace_80.ShardedLRUCache.TotalCharge,size_t leveldb.anonymous_namespace_80.ShardedLRUCache.TotalCharge (),util\cache.cc,"virtual size_t TotalCharge() const {
    size_t total = 0;
    for (int s = 0; s < kNumShards; s++) {
      total += shard_[s].TotalCharge();
    }
    return total;
  }",390.0,396.0,3.0,3.0,7.0,6,5,8,4,0,1,2,2,0,0,,0,1,0,0,0,size_t
1247,81402,Deleter,1,leveldb.CacheTest.Deleter,"void leveldb.CacheTest.Deleter (Slice,void*)",util\cache_test.cc,"static void Deleter(const Slice& key, void* v) {
    current_->deleted_keys_.push_back(DecodeKey(key));
    current_->deleted_values_.push_back(DecodeValue(v));
  }",30.0,33.0,3.0,3.0,4.0,4,2,4,3,0,2,1,1,0,0,,0,2,4,2,2,void
1248,81428,CacheTest,1,leveldb.CacheTest.CacheTest,ANY leveldb.CacheTest.CacheTest (),util\cache_test.cc,"CacheTest() : cache_(NewLRUCache(kCacheSize)) {
    current_ = this;
  }",40.0,42.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1249,81435,~CacheTest,1,leveldb.CacheTest.~CacheTest,ANY leveldb.CacheTest.~CacheTest (),util\cache_test.cc,"~CacheTest() {
    delete cache_;
  }",44.0,46.0,3.0,3.0,3.0,1,1,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1250,81441,Lookup,1,leveldb.CacheTest.Lookup,int leveldb.CacheTest.Lookup (int),util\cache_test.cc,"int Lookup(int key) {
    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));
    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));
    if (handle != NULL) {
      cache_->Release(handle);
    }
    return r;
  }",48.0,55.0,3.0,3.0,8.0,9,6,13,5,0,3,2,2,0,0,,0,3,2,1,1,int
1251,81482,Insert,1,leveldb.CacheTest.Insert,"void leveldb.CacheTest.Insert (int,int,int)",util\cache_test.cc,"void Insert(int key, int value, int charge = 1) {
    cache_->Release(cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                                   &CacheTest::Deleter));
  }",57.0,60.0,3.0,3.0,4.0,4,3,6,5,0,2,1,1,0,0,,0,2,6,3,3,void
1252,81506,InsertAndReturnHandle,1,leveldb.CacheTest.InsertAndReturnHandle,"Handle leveldb.CacheTest.InsertAndReturnHandle (int,int,int)",util\cache_test.cc,"Cache::Handle* InsertAndReturnHandle(int key, int value, int charge = 1) {
    return cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                          &CacheTest::Deleter);
  }",62.0,65.0,3.0,3.0,4.0,3,3,5,5,0,1,1,1,0,0,,0,1,6,3,3,Handle
1253,81527,Erase,1,leveldb.CacheTest.Erase,void leveldb.CacheTest.Erase (int),util\cache_test.cc,"void Erase(int key) {
    cache_->Erase(EncodeKey(key));
  }",67.0,69.0,3.0,3.0,3.0,1,1,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1254,88494,Acquire,1,leveldb.anonymous_namespace_5.Limiter.Acquire,bool leveldb.anonymous_namespace_5.Limiter.Acquire (),util\env_posix.cc,"bool Acquire() {
    if (GetAllowed() <= 0) {
      return false;
    }
    MutexLock l(&mu_);
    intptr_t x = GetAllowed();
    if (x <= 0) {
      return false;
    } else {
      SetAllowed(x - 1);
      return true;
    }
  }",54.0,66.0,3.0,3.0,13.0,4,3,3,2,0,1,3,3,0,0,,0,1,0,0,0,bool
1255,88528,Release,1,leveldb.anonymous_namespace_9.Limiter.Release,void leveldb.anonymous_namespace_9.Limiter.Release (),util\env_posix.cc,"void Release() {
    MutexLock l(&mu_);
    SetAllowed(GetAllowed() + 1);
  }",70.0,73.0,3.0,3.0,4.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,void
1256,88542,GetAllowed,1,leveldb.anonymous_namespace_12.Limiter.GetAllowed,intptr_t leveldb.anonymous_namespace_12.Limiter.GetAllowed (),util\env_posix.cc,"intptr_t GetAllowed() const {
    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
  }",79.0,81.0,3.0,3.0,3.0,2,2,1,1,0,1,1,1,0,0,,0,1,0,0,0,intptr_t
1257,88553,SetAllowed,1,leveldb.anonymous_namespace_13.Limiter.SetAllowed,void leveldb.anonymous_namespace_13.Limiter.SetAllowed (intptr_t),util\env_posix.cc,"void SetAllowed(intptr_t v) {
    allowed_.Release_Store(reinterpret_cast<void*>(v));
  }",84.0,86.0,3.0,3.0,3.0,2,2,2,2,0,1,1,1,0,0,,0,1,2,1,1,void
1258,88584,~PosixSequentialFile,1,leveldb.anonymous_namespace_18.PosixSequentialFile.~PosixSequentialFile,ANY leveldb.anonymous_namespace_18.PosixSequentialFile.~PosixSequentialFile (),util\env_posix.cc,virtual ~PosixSequentialFile() { fclose(file_); },100.0,100.0,3.0,51.0,1.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1259,88590,Read,1,leveldb.anonymous_namespace_19.PosixSequentialFile.Read,"Status leveldb.anonymous_namespace_19.PosixSequentialFile.Read (size_t,Slice*,char*)",util\env_posix.cc,"virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s;
    size_t r = fread_unlocked(scratch, 1, n, file_);
    *result = Slice(scratch, r);
    if (r < n) {
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }
    return s;
  }",102.0,115.0,3.0,3.0,14.0,4,3,11,6,0,2,3,4,1,0,,0,2,6,3,3,Status
1260,88630,Skip,1,leveldb.anonymous_namespace_20.PosixSequentialFile.Skip,Status leveldb.anonymous_namespace_20.PosixSequentialFile.Skip (uint64_t),util\env_posix.cc,"virtual Status Skip(uint64_t n) {
    if (fseek(file_, n, SEEK_CUR)) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",117.0,122.0,3.0,3.0,6.0,1,1,6,6,0,3,2,2,1,0,,0,2,2,1,1,Status
1261,88655,PosixRandomAccessFile,1,leveldb.anonymous_namespace_22.PosixRandomAccessFile.PosixRandomAccessFile,"ANY leveldb.anonymous_namespace_22.PosixRandomAccessFile.PosixRandomAccessFile (ANY,int,Limiter*)",util\env_posix.cc,"PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)
      : filename_(fname), fd_(fd), limiter_(limiter) {
    temporary_fd_ = !limiter->Acquire();
    if (temporary_fd_) {
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }
  }",134.0,142.0,3.0,3.0,9.0,5,4,5,3,0,4,2,2,1,0,,0,4,6,3,3,ANY
1262,88678,~PosixRandomAccessFile,1,leveldb.anonymous_namespace_23.PosixRandomAccessFile.~PosixRandomAccessFile,ANY leveldb.anonymous_namespace_23.PosixRandomAccessFile.~PosixRandomAccessFile (),util\env_posix.cc,"virtual ~PosixRandomAccessFile() {
    if (!temporary_fd_) {
      close(fd_);
      limiter_->Release();
    }
  }",144.0,149.0,3.0,3.0,6.0,2,2,3,3,0,3,2,2,1,0,,0,3,0,0,0,ANY
1263,88692,Read,1,leveldb.anonymous_namespace_24.PosixRandomAccessFile.Read,"Status leveldb.anonymous_namespace_24.PosixRandomAccessFile.Read (uint64_t,size_t,Slice*,char*)",util\env_posix.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    int fd = fd_;
    if (temporary_fd_) {
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }

    Status s;
    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));
    *result = Slice(scratch, (r < 0) ? 0 : r);
    if (r < 0) {
      // An error: return a non-ok status
      s = IOError(filename_, errno);
    }
    if (temporary_fd_) {
      // Close the temporary file descriptor opened earlier.
      close(fd);
    }
    return s;
  }",151.0,173.0,3.0,3.0,23.0,12,6,25,12,0,6,5,6,2,0,,0,6,8,4,4,Status
1264,88776,~PosixMmapReadableFile,1,leveldb.anonymous_namespace_27.PosixMmapReadableFile.~PosixMmapReadableFile,ANY leveldb.anonymous_namespace_27.PosixMmapReadableFile.~PosixMmapReadableFile (),util\env_posix.cc,"virtual ~PosixMmapReadableFile() {
    munmap(mmapped_region_, length_);
    limiter_->Release();
  }",192.0,195.0,3.0,3.0,4.0,1,1,3,3,0,3,1,1,0,0,,0,3,0,0,0,ANY
1265,88787,Read,1,leveldb.anonymous_namespace_28.PosixMmapReadableFile.Read,"Status leveldb.anonymous_namespace_28.PosixMmapReadableFile.Read (uint64_t,size_t,Slice*,char*)",util\env_posix.cc,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    Status s;
    if (offset + n > length_) {
      *result = Slice();
      s = IOError(filename_, EINVAL);
    } else {
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }
    return s;
  }",197.0,207.0,3.0,3.0,11.0,5,4,8,7,0,2,2,2,1,0,,0,2,8,4,4,Status
1266,88835,~PosixWritableFile,1,leveldb.anonymous_namespace_31.PosixWritableFile.~PosixWritableFile,ANY leveldb.anonymous_namespace_31.PosixWritableFile.~PosixWritableFile (),util\env_posix.cc,"~PosixWritableFile() {
    if (file_ != NULL) {
      // Ignoring any potential errors
      fclose(file_);
    }
  }",219.0,224.0,3.0,3.0,6.0,1,1,3,2,0,2,2,2,1,0,,0,2,0,0,0,ANY
1267,88846,Append,1,leveldb.anonymous_namespace_32.PosixWritableFile.Append,Status leveldb.anonymous_namespace_32.PosixWritableFile.Append (Slice),util\env_posix.cc,"virtual Status Append(const Slice& data) {
    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
    if (r != data.size()) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",226.0,232.0,3.0,3.0,7.0,6,3,9,6,0,3,2,2,0,0,,0,2,2,1,1,Status
1268,88882,Close,1,leveldb.anonymous_namespace_33.PosixWritableFile.Close,Status leveldb.anonymous_namespace_33.PosixWritableFile.Close (),util\env_posix.cc,"virtual Status Close() {
    Status result;
    if (fclose(file_) != 0) {
      result = IOError(filename_, errno);
    }
    file_ = NULL;
    return result;
  }",234.0,241.0,3.0,3.0,8.0,3,2,7,5,0,3,2,2,1,0,,0,3,0,0,0,Status
1269,88903,Flush,1,leveldb.anonymous_namespace_34.PosixWritableFile.Flush,Status leveldb.anonymous_namespace_34.PosixWritableFile.Flush (),util\env_posix.cc,"virtual Status Flush() {
    if (fflush_unlocked(file_) != 0) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",243.0,248.0,3.0,3.0,6.0,2,2,4,4,0,3,2,2,1,0,,0,2,0,0,0,Status
1270,88922,SyncDirIfManifest,1,leveldb.anonymous_namespace_35.PosixWritableFile.SyncDirIfManifest,Status leveldb.anonymous_namespace_35.PosixWritableFile.SyncDirIfManifest (),util\env_posix.cc,"Status SyncDirIfManifest() {
    const char* f = filename_.c_str();
    const char* sep = strrchr(f, '/');
    Slice basename;
    std::string dir;
    if (sep == NULL) {
      dir = ""."";
      basename = f;
    } else {
      dir = std::string(f, sep - f);
      basename = sep + 1;
    }
    Status s;
    if (basename.starts_with(""MANIFEST"")) {
      int fd = open(dir.c_str(), O_RDONLY);
      if (fd < 0) {
        s = IOError(dir, errno);
      } else {
        if (fsync(fd) < 0) {
          s = IOError(dir, errno);
        }
        close(fd);
      }
    }
    return s;
  }",250.0,275.0,3.0,3.0,26.0,11,4,18,10,0,1,4,5,0,0,,0,1,0,0,0,Status
1271,89013,Sync,1,leveldb.anonymous_namespace_36.PosixWritableFile.Sync,Status leveldb.anonymous_namespace_36.PosixWritableFile.Sync (),util\env_posix.cc,"virtual Status Sync() {
    // Ensure new files referred to by the manifest are in the filesystem.
    Status s = SyncDirIfManifest();
    if (!s.ok()) {
      return s;
    }
    if (fflush_unlocked(file_) != 0 ||
        fdatasync(fileno(file_)) != 0) {
      s = Status::IOError(filename_, strerror(errno));
    }
    return s;
  }",277.0,288.0,3.0,3.0,12.0,8,5,10,5,0,3,3,3,2,0,,0,3,0,0,0,Status
1272,89104,Insert,1,leveldb.anonymous_namespace_41.PosixLockTable.Insert,bool leveldb.anonymous_namespace_41.PosixLockTable.Insert (ANY),util\env_posix.cc,"bool Insert(const std::string& fname) {
    MutexLock l(&mu_);
    return locked_files_.insert(fname).second;
  }",316.0,319.0,3.0,3.0,4.0,3,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,bool
1273,89121,Remove,1,leveldb.anonymous_namespace_42.PosixLockTable.Remove,void leveldb.anonymous_namespace_42.PosixLockTable.Remove (ANY),util\env_posix.cc,"void Remove(const std::string& fname) {
    MutexLock l(&mu_);
    locked_files_.erase(fname);
  }",320.0,323.0,3.0,3.0,4.0,2,2,3,3,0,2,1,1,0,0,,0,2,2,1,1,void
1274,89402,GetChildren,1,leveldb.anonymous_namespace_52.PosixEnv.GetChildren,"Status leveldb.anonymous_namespace_52.PosixEnv.GetChildren (ANY,ANY*)",util\env_posix.cc,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) {
    result->clear();
    DIR* d = opendir(dir.c_str());
    if (d == NULL) {
      return IOError(dir, errno);
    }
    struct dirent* entry;
    while ((entry = readdir(d)) != NULL) {
      result->push_back(entry->d_name);
    }
    closedir(d);
    return Status::OK();
  }",405.0,418.0,3.0,3.0,14.0,9,5,14,7,0,1,3,3,0,0,,0,0,4,2,2,Status
1275,89686,UnlockFile,1,leveldb.anonymous_namespace_60.PosixEnv.UnlockFile,Status leveldb.anonymous_namespace_60.PosixEnv.UnlockFile (FileLock*),util\env_posix.cc,"virtual Status UnlockFile(FileLock* lock) {
    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);
    Status result;
    if (LockOrUnlock(my_lock->fd_, false) == -1) {
      result = IOError(""unlock"", errno);
    }
    locks_.Remove(my_lock->name_);
    close(my_lock->fd_);
    delete my_lock;
    return result;
  }",486.0,496.0,3.0,3.0,11.0,10,7,10,5,0,4,2,2,1,0,,0,4,2,1,1,Status
1276,89740,GetTestDirectory,1,leveldb.anonymous_namespace_64.PosixEnv.GetTestDirectory,Status leveldb.anonymous_namespace_64.PosixEnv.GetTestDirectory (ANY*),util\env_posix.cc,"virtual Status GetTestDirectory(std::string* result) {
    const char* env = getenv(""TEST_TMPDIR"");
    if (env && env[0] != '\0') {
      *result = env;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""/tmp/leveldbtest-%d"", int(geteuid()));
      *result = buf;
    }
    // Directory may already exist
    CreateDir(*result);
    return Status::OK();
  }",502.0,514.0,3.0,3.0,13.0,8,6,7,3,0,1,2,2,0,0,,0,0,2,1,1,Status
1277,90150,StartThreadWrapper,1,leveldb.anonymous_namespace_87.StartThreadWrapper,void* leveldb.anonymous_namespace_87.StartThreadWrapper (void*),util\env_posix.cc,"static void* StartThreadWrapper(void* arg) {
  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);
  state->user_function(state->arg);
  delete state;
  return NULL;
}",658.0,663.0,1.0,1.0,6.0,5,4,6,3,0,1,1,1,0,0,,0,1,2,1,1,void*
1278,90172,StartThread,1,leveldb.anonymous_namespace_88.PosixEnv.StartThread,"void leveldb.anonymous_namespace_88.PosixEnv.StartThread (void,void*)",util\env_posix.cc,"void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {
  pthread_t t;
  StartThreadState* state = new StartThreadState;
  state->user_function = function;
  state->arg = arg;
  PthreadCall(""start thread"",
              pthread_create(&t, NULL,  &StartThreadWrapper, state));
}",665.0,672.0,1.0,1.0,8.0,8,4,9,6,0,1,1,1,0,0,,0,1,4,2,2,void
1279,90838,ThreadBody,1,leveldb.ThreadBody,void leveldb.ThreadBody (void*),util\env_test.cc,"static void ThreadBody(void* arg) {
  State* s = reinterpret_cast<State*>(arg);
  s->mu.Lock();
  s->val += 1;
  s->num_running -= 1;
  s->mu.Unlock();
}",75.0,81.0,1.0,1.0,7.0,10,6,6,2,0,4,1,1,0,0,,0,4,2,1,1,void
1280,91590,Clear,1,leveldb.Histogram.Clear,void leveldb.Histogram.Clear (),util\histogram.cc,"void Histogram::Clear() {
  min_ = kBucketLimit[kNumBuckets-1];
  max_ = 0;
  num_ = 0;
  sum_ = 0;
  sum_squares_ = 0;
  for (int i = 0; i < kNumBuckets; i++) {
    buckets_[i] = 0;
  }
}",33.0,42.0,1.0,1.0,10.0,11,4,12,9,0,8,2,2,1,0,,0,8,0,0,0,void
1281,91630,Add,1,leveldb.Histogram.Add,void leveldb.Histogram.Add (double),util\histogram.cc,"void Histogram::Add(double value) {
  // Linear search is fast enough for our usage in db_bench
  int b = 0;
  while (b < kNumBuckets - 1 && kBucketLimit[b] <= value) {
    b++;
  }
  buckets_[b] += 1.0;
  if (min_ > value) min_ = value;
  if (max_ < value) max_ = value;
  num_++;
  sum_ += value;
  sum_squares_ += (value * value);
}",44.0,56.0,1.0,1.0,13.0,17,10,23,10,0,9,4,4,3,0,,0,9,2,1,1,void
1282,91685,Merge,1,leveldb.Histogram.Merge,void leveldb.Histogram.Merge (Histogram),util\histogram.cc,"void Histogram::Merge(const Histogram& other) {
  if (other.min_ < min_) min_ = other.min_;
  if (other.max_ > max_) max_ = other.max_;
  num_ += other.num_;
  sum_ += other.sum_;
  sum_squares_ += other.sum_squares_;
  for (int b = 0; b < kNumBuckets; b++) {
    buckets_[b] += other.buckets_[b];
  }
}",58.0,67.0,1.0,1.0,10.0,20,6,21,9,0,17,4,4,5,0,,0,17,2,1,1,void
1283,91757,Percentile,1,leveldb.Histogram.Percentile,double leveldb.Histogram.Percentile (double),util\histogram.cc,"double Histogram::Percentile(double p) const {
  double threshold = num_ * (p / 100.0);
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    sum += buckets_[b];
    if (sum >= threshold) {
      // Scale linearly within this bucket
      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
      double right_point = kBucketLimit[b];
      double left_sum = sum - buckets_[b];
      double right_sum = sum;
      double pos = (threshold - left_sum) / (right_sum - left_sum);
      double r = left_point + (right_point - left_point) * pos;
      if (r < min_) r = min_;
      if (r > max_) r = max_;
      return r;
    }
  }
  return max_;
}",73.0,92.0,1.0,1.0,20.0,32,12,45,16,0,9,5,10,3,0,,0,9,2,1,1,double
1284,91867,Average,1,leveldb.Histogram.Average,double leveldb.Histogram.Average (),util\histogram.cc,"double Histogram::Average() const {
  if (num_ == 0.0) return 0;
  return sum_ / num_;
}",94.0,97.0,1.0,1.0,4.0,2,2,3,2,0,3,2,2,1,0,,0,3,0,0,0,double
1285,91882,StandardDeviation,1,leveldb.Histogram.StandardDeviation,double leveldb.Histogram.StandardDeviation (),util\histogram.cc,"double Histogram::StandardDeviation() const {
  if (num_ == 0.0) return 0;
  double variance = (sum_squares_ * num_ - sum_ * sum_) / (num_ * num_);
  return sqrt(variance);
}",99.0,103.0,1.0,1.0,5.0,7,5,9,4,0,7,2,2,1,0,,0,7,0,0,0,double
1286,91910,ToString,1,leveldb.Histogram.ToString,string leveldb.Histogram.ToString (),util\histogram.cc,"std::string Histogram::ToString() const {
  std::string r;
  char buf[200];
  snprintf(buf, sizeof(buf),
           ""Count: %.0f  Average: %.4f  StdDev: %.2f\n"",
           num_, Average(), StandardDeviation());
  r.append(buf);
  snprintf(buf, sizeof(buf),
           ""Min: %.4f  Median: %.4f  Max: %.4f\n"",
           (num_ == 0.0 ? 0.0 : min_), Median(), max_);
  r.append(buf);
  r.append(""------------------------------------------------------\n"");
  const double mult = 100.0 / num_;
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    if (buckets_[b] <= 0.0) continue;
    sum += buckets_[b];
    snprintf(buf, sizeof(buf),
             ""[ %7.0f, %7.0f ) %7.0f %7.3f%% %7.3f%% "",
             ((b == 0) ? 0.0 : kBucketLimit[b-1]),      // left
             kBucketLimit[b],                           // right
             buckets_[b],                               // count
             mult * buckets_[b],                        // percentage
             mult * sum);         ...",105.0,137.0,1.0,1.0,33.0,35,14,48,12,0,12,4,4,2,0,,0,12,0,0,0,string
1287,92398,MutexLock,1,leveldb.MutexLock.MutexLock,ANY leveldb.MutexLock.MutexLock (ANY*),util\mutexlock.hpp,"explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)
      : mu_(mu)  {
    this->mu_->Lock();
  }",25.0,28.0,3.0,38.0,4.0,2,1,0,0,0,1,1,1,0,0,,0,1,2,1,1,ANY
1288,92409,~MutexLock,1,leveldb.MutexLock.~MutexLock,ANY leveldb.MutexLock.~MutexLock (),util\mutexlock.hpp,~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); },29.0,29.0,3.0,15.0,1.0,2,1,0,0,0,1,1,1,0,0,,0,1,0,0,0,ANY
1289,92474,~PosixLogger,1,leveldb.PosixLogger.~PosixLogger,ANY leveldb.PosixLogger.~PosixLogger (),util\posix_logger.hpp,"virtual ~PosixLogger() {
    fclose(file_);
  }",25.0,27.0,3.0,3.0,3.0,0,0,1,1,0,1,1,1,0,0,,0,1,0,0,0,ANY
1290,92480,Logv,1,leveldb.PosixLogger.Logv,"void leveldb.PosixLogger.Logv (char*,va_list)",util\posix_logger.hpp,"virtual void Logv(const char* format, va_list ap) {
    const uint64_t thread_id = (*gettid_)();

    // We try twice: the first time with a fixed-size stack allocated buffer,
    // and the second time with a much larger dynamically allocated buffer.
    char buffer[500];
    for (int iter = 0; iter < 2; iter++) {
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seconds, &t);
      p += snprintf(p, limit - p,
                    ""%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "",
                    t.tm_year + 1900,
                    t.tm_mon + 1,
                    t.tm_mday,
                    t.tm_hour,
                    t.tm_min,
...",28.0,93.0,3.0,3.0,66.0,46,19,60,16,0,2,10,15,0,0,,0,2,4,2,2,void
1291,92679,Random,1,leveldb.Random.Random,ANY leveldb.Random.Random (uint32_t),util\random.hpp,"explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
    // Avoid bad seeds.
    if (seed_ == 0 || seed_ == 2147483647L) {
      seed_ = 1;
    }
  }",19.0,24.0,3.0,3.0,6.0,4,3,3,1,0,3,2,2,2,0,,0,3,2,1,1,ANY
1292,92696,Next,1,leveldb.Random.Next,uint32_t leveldb.Random.Next (),util\random.hpp,"uint32_t Next() {
    static const uint32_t M = 2147483647L;   // 2^31-1
    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
    // We are computing
    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
    //
    // seed_ must not be zero or M, or else all subsequent computed values
    // will be zero or M respectively.  For all other values, seed_ will end
    // up cycling through every number in [1,M-1]
    uint64_t product = seed_ * A;

    // Compute (product % M) using the fact that ((x << 31) % M) == x.
    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
    // The first reduction may overflow by 1 bit, so we may need to
    // repeat.  mod == M is not possible; using > allows the faster
    // sign-bit-based test.
    if (seed_ > M) {
      seed_ -= M;
    }
    return seed_;
  }",25.0,45.0,3.0,3.0,21.0,11,8,14,4,0,5,2,2,1,0,,0,5,0,0,0,uint32_t
1293,93012,RegisterTest,1,leveldb.test.RegisterTest,"bool leveldb.test.RegisterTest (char*,char*,void)",util\testharness.cc,"bool RegisterTest(const char* base, const char* name, void (*func)()) {
  if (tests == NULL) {
    tests = new std::vector<Test>;
  }
  Test t;
  t.base = base;
  t.name = name;
  t.func = func;
  tests->push_back(t);
  return true;
}",24.0,34.0,1.0,1.0,11.0,10,5,12,7,0,2,2,2,0,0,,0,2,6,3,3,bool
1294,93051,RunAllTests,1,leveldb.test.RunAllTests,int leveldb.test.RunAllTests (),util\testharness.cc,"int RunAllTests() {
  const char* matcher = getenv(""LEVELDB_TESTS"");

  int num = 0;
  if (tests != NULL) {
    for (size_t i = 0; i < tests->size(); i++) {
      const Test& t = (*tests)[i];
      if (matcher != NULL) {
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }
      fprintf(stderr, ""==== Test %s.%s\n"", t.base, t.name);
      (*t.func)();
      ++num;
    }
  }
  fprintf(stderr, ""==== PASSED %d tests\n"", num);
  return 0;
}",36.0,58.0,1.0,1.0,23.0,22,9,27,8,1,4,6,11,0,0,,0,4,0,0,0,int
1295,93147,TmpDir,1,leveldb.test.TmpDir,string leveldb.test.TmpDir (),util\testharness.cc,"std::string TmpDir() {
  std::string dir;
  Status s = Env::Default()->GetTestDirectory(&dir);
  ASSERT_TRUE(s.ok()) << s.ToString();
  return dir;
}",60.0,65.0,1.0,2.0,6.0,11,5,9,4,1,0,1,1,0,0,,0,0,0,0,0,string
1296,93264,~Tester,1,leveldb.test.Tester.~Tester,ANY leveldb.test.Tester.~Tester (),util\testharness.hpp,"~Tester() {
    if (!ok_) {
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }
  }",54.0,59.0,3.0,3.0,6.0,3,2,5,5,0,4,2,2,1,0,,0,4,0,0,0,ANY
1297,93286,Is,1,leveldb.test.Tester.Is,"Tester leveldb.test.Tester.Is (bool,char*)",util\testharness.hpp,"Tester& Is(bool b, const char* msg) {
    if (!b) {
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }
    return *this;
  }",61.0,67.0,3.0,3.0,7.0,5,4,4,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1298,93307,IsOk,1,leveldb.test.Tester.IsOk,Tester leveldb.test.Tester.IsOk (Status),util\testharness.hpp,"Tester& IsOk(const Status& s) {
    if (!s.ok()) {
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }
    return *this;
  }",69.0,75.0,3.0,3.0,7.0,7,5,4,3,0,2,2,2,0,0,,0,2,2,1,1,Tester
1299,93333,IsEq,1,leveldb.test.Tester.IsEq,"Tester leveldb.test.Tester.IsEq<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsEq, ==)",87.0,87.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1300,93360,IsNe,1,leveldb.test.Tester.IsNe,"Tester leveldb.test.Tester.IsNe<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsNe, !=)",88.0,88.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1301,93387,IsGe,1,leveldb.test.Tester.IsGe,"Tester leveldb.test.Tester.IsGe<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsGe, >=)",89.0,89.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1302,93414,IsGt,1,leveldb.test.Tester.IsGt,"Tester leveldb.test.Tester.IsGt<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsGt, >)",90.0,90.0,3.0,20.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1303,93441,IsLe,1,leveldb.test.Tester.IsLe,"Tester leveldb.test.Tester.IsLe<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsLe, <=)",91.0,91.0,3.0,21.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1304,93468,IsLt,1,leveldb.test.Tester.IsLt,"Tester leveldb.test.Tester.IsLt<X,Y> (X,Y)",util\testharness.hpp,"BINARY_OP(IsLt, <)",92.0,92.0,3.0,20.0,1.0,8,5,6,4,0,2,2,2,0,0,,0,2,4,2,2,Tester
1305,93495,operator <<,1,leveldb.test.Tester.operator <<,Tester leveldb.test.Tester.operator <<<V> (V),util\testharness.hpp,"Tester& operator<<(const V& value) {
    if (!ok_) {
      ss_ << "" "" << value;
    }
    return *this;
  }",97.0,102.0,3.0,3.0,6.0,4,3,3,3,0,2,2,2,1,0,,0,2,2,1,1,Tester
1306,93714,NewWritableFile,1,leveldb.test.ErrorEnv.NewWritableFile,"Status leveldb.test.ErrorEnv.NewWritableFile (ANY,WritableFile**)",util\testutil.hpp,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewWritableFile(fname, result);
  }",39.0,47.0,3.0,3.0,9.0,5,5,8,6,0,3,2,2,1,1,,0,2,4,2,2,Status
1307,93743,NewAppendableFile,1,leveldb.test.ErrorEnv.NewAppendableFile,"Status leveldb.test.ErrorEnv.NewAppendableFile (ANY,WritableFile**)",util\testutil.hpp,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewAppendableFile(fname, result);
  }",49.0,57.0,3.0,3.0,9.0,5,5,8,6,0,3,2,2,1,1,,0,2,4,2,2,Status
1308,2365,phase,2,db\c_test.c.phase,,db\c_test.c,const char* phase,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,6,0,1,1,0,0,,0,0,0,0,0,
1309,2721,fake_filter_result,2,db\c_test.c.fake_filter_result,,db\c_test.c,static unsigned char fake_filter_result,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1310,5953,FLAGS_benchmarks,2,db\db_bench.cc.FLAGS_benchmarks,,db\db_bench.cc,static const char* FLAGS_benchmarks,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1311,5957,FLAGS_num,2,db\db_bench.cc.FLAGS_num,,db\db_bench.cc,static int FLAGS_num,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,9,0,1,1,0,0,,0,0,0,0,0,
1312,5961,FLAGS_reads,2,db\db_bench.cc.FLAGS_reads,,db\db_bench.cc,static int FLAGS_reads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1313,5966,FLAGS_threads,2,db\db_bench.cc.FLAGS_threads,,db\db_bench.cc,static int FLAGS_threads,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1314,5970,FLAGS_value_size,2,db\db_bench.cc.FLAGS_value_size,,db\db_bench.cc,static int FLAGS_value_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1315,5974,FLAGS_compression_ratio,2,db\db_bench.cc.FLAGS_compression_ratio,,db\db_bench.cc,static double FLAGS_compression_ratio,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1316,5978,FLAGS_histogram,2,db\db_bench.cc.FLAGS_histogram,,db\db_bench.cc,static bool FLAGS_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1317,5982,FLAGS_write_buffer_size,2,db\db_bench.cc.FLAGS_write_buffer_size,,db\db_bench.cc,static int FLAGS_write_buffer_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1318,5986,FLAGS_max_file_size,2,db\db_bench.cc.FLAGS_max_file_size,,db\db_bench.cc,static int FLAGS_max_file_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1319,5990,FLAGS_block_size,2,db\db_bench.cc.FLAGS_block_size,,db\db_bench.cc,static int FLAGS_block_size,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1320,5999,FLAGS_open_files,2,db\db_bench.cc.FLAGS_open_files,,db\db_bench.cc,static int FLAGS_open_files,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1321,6008,FLAGS_use_existing_db,2,db\db_bench.cc.FLAGS_use_existing_db,,db\db_bench.cc,static bool FLAGS_use_existing_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,3,0,1,1,0,0,,0,0,0,0,0,
1322,6012,FLAGS_reuse_logs,2,db\db_bench.cc.FLAGS_reuse_logs,,db\db_bench.cc,static bool FLAGS_reuse_logs,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1323,6016,FLAGS_db,2,db\db_bench.cc.FLAGS_db,,db\db_bench.cc,static const char* FLAGS_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,5,0,1,1,0,0,,0,0,0,0,0,
1324,57749,FLAGS_histogram,2,doc\bench\db_bench_sqlite3.cc.FLAGS_histogram,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_histogram,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,2,0,1,1,0,0,,0,0,0,0,0,
1325,57765,FLAGS_use_existing_db,2,doc\bench\db_bench_sqlite3.cc.FLAGS_use_existing_db,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_use_existing_db,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
1326,57769,FLAGS_transaction,2,doc\bench\db_bench_sqlite3.cc.FLAGS_transaction,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_transaction,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,4,0,1,1,0,0,,0,0,0,0,0,
1327,57773,FLAGS_WAL_enabled,2,doc\bench\db_bench_sqlite3.cc.FLAGS_WAL_enabled,,doc\bench\db_bench_sqlite3.cc,static bool FLAGS_WAL_enabled,-1.0,-1.0,-1.0,-1.0,0.0,0,0,0,0,1,0,1,1,0,0,,0,0,0,0,0,
