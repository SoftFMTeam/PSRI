15,METHOD,db\autocompact_test.cc:<global>,TYPE_DECL,<global>,1,1,db\autocompact_test.cc,db\autocompact_test.cc:<global>,,false,1,118,<global>,,,1,
23,METHOD,leveldb.AutoCompactTest,TYPE_DECL,"AutoCompactTest() {
    dbname_ = test::TmpDir() + ""/autocompact_test"";
    tiny_cache_ = NewLRUCache(100);
    options_.block_cache = tiny_cache_;
    DestroyDB(dbname_, options_);
    options_.create_if_missing = true;
    options_.compression = kNoCompression;
    ASSERT_OK(DB::Open(options_, dbname_, &db_));
  }",3,4,db\autocompact_test.cc,leveldb.AutoCompactTest.AutoCompactTest,,false,20,28,AutoCompactTest,,,5,ANY leveldb.AutoCompactTest.AutoCompactTest ()
78,METHOD,leveldb.AutoCompactTest,TYPE_DECL,"~AutoCompactTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
  }",3,3,db\autocompact_test.cc,leveldb.AutoCompactTest.~AutoCompactTest,,false,30,34,~AutoCompactTest,,,6,ANY leveldb.AutoCompactTest.~AutoCompactTest ()
89,METHOD,leveldb.AutoCompactTest,TYPE_DECL,"std::string Key(int i) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""key%06d"", i);
    return std::string(buf);
  }",3,3,db\autocompact_test.cc,leveldb.AutoCompactTest.Key,,false,36,40,Key,,,7,string leveldb.AutoCompactTest.Key (int)
107,METHOD,leveldb.AutoCompactTest,TYPE_DECL,"uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",3,3,db\autocompact_test.cc,leveldb.AutoCompactTest.Size,,false,42,47,Size,,,8,"uint64_t leveldb.AutoCompactTest.Size (Slice,Slice)"
129,METHOD,leveldb.AutoCompactTest,TYPE_DECL,void DoReads(int n);,8,21,db\autocompact_test.cc,leveldb.AutoCompactTest.DoReads,,false,49,49,DoReads,,,9,void leveldb.AutoCompactTest.DoReads (int)
154,METHOD,db\autocompact_test.cc:<global>,TYPE_DECL,"void AutoCompactTest::DoReads(int n) {
  std::string value(kValueSize, 'x');
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);

  // Fill database
  for (int i = 0; i < kCount; i++) {
    ASSERT_OK(db_->Put(WriteOptions(), Key(i), value));
  }
  ASSERT_OK(dbi->TEST_CompactMemTable());

  // Delete everything
  for (int i = 0; i < kCount; i++) {
    ASSERT_OK(db_->Delete(WriteOptions(), Key(i)));
  }
  ASSERT_OK(dbi->TEST_CompactMemTable());

  // Get initial measurement of the space we will be reading.
  const int64_t initial_size = Size(Key(0), Key(n));
  const int64_t initial_other_size = Size(Key(n), Key(kCount));

  // Read until size drops significantly.
  std::string limit_key = Key(n);
  for (int read = 0; true; read++) {
    ASSERT_LT(read, 100) << ""Taking too long to compact"";
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst();
         iter->Valid() && iter->key().ToString() < limit_key;
         iter->Next()) {
      // Drop data
    }
    de...",1,4,db\autocompact_test.cc,leveldb.AutoCompactTest.DoReads,,false,58,104,DoReads,,,8,void leveldb.AutoCompactTest.DoReads (int)
448,METHOD,leveldb._Test_ReadAll,TYPE_DECL,void void ();,1,30,db\autocompact_test.cc,leveldb._Test_ReadAll._Run,,false,106,106,_Run,,,1,void leveldb._Test_ReadAll._Run ()
452,METHOD,leveldb._Test_ReadAll,TYPE_DECL,"TEST(AutoCompactTest, ReadAll)",1,30,db\autocompact_test.cc,leveldb._Test_ReadAll._RunIt,,false,106,106,_RunIt,,,2,void leveldb._Test_ReadAll._RunIt ()
476,METHOD,db\autocompact_test.cc:<global>,TYPE_DECL,"TEST(AutoCompactTest, ReadAll) {
  DoReads(kCount);
}",1,30,db\autocompact_test.cc,leveldb._Test_ReadAll._Run,,false,106,108,_Run,,,12,void leveldb._Test_ReadAll._Run ()
483,METHOD,leveldb._Test_ReadHalf,TYPE_DECL,void void ();,1,31,db\autocompact_test.cc,leveldb._Test_ReadHalf._Run,,false,110,110,_Run,,,1,void leveldb._Test_ReadHalf._Run ()
487,METHOD,leveldb._Test_ReadHalf,TYPE_DECL,"TEST(AutoCompactTest, ReadHalf)",1,31,db\autocompact_test.cc,leveldb._Test_ReadHalf._RunIt,,false,110,110,_RunIt,,,2,void leveldb._Test_ReadHalf._RunIt ()
511,METHOD,db\autocompact_test.cc:<global>,TYPE_DECL,"TEST(AutoCompactTest, ReadHalf) {
  DoReads(kCount/2);
}",1,31,db\autocompact_test.cc,leveldb._Test_ReadHalf._Run,,false,110,112,_Run,,,16,void leveldb._Test_ReadHalf._Run ()
519,METHOD,db\autocompact_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\autocompact_test.cc,main,,false,116,118,main,,,2,"int main (int,char**)"
551,METHOD,db\builder.cc:<global>,TYPE_DECL,<global>,1,1,db\builder.cc,db\builder.cc:<global>,,false,1,88,<global>,,,1,
554,METHOD,db\builder.cc:<global>,TYPE_DECL,"Status BuildTable(const std::string& dbname,
                  Env* env,
                  const Options& options,
                  TableCache* table_cache,
                  Iterator* iter,
                  FileMetaData* meta) {
  Status s;
  meta->file_size = 0;
  iter->SeekToFirst();

  std::string fname = TableFileName(dbname, meta->number);
  if (iter->Valid()) {
    WritableFile* file;
    s = env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      return s;
    }

    TableBuilder* builder = new TableBuilder(options, file);
    meta->smallest.DecodeFrom(iter->key());
    for (; iter->Valid(); iter->Next()) {
      Slice key = iter->key();
      meta->largest.DecodeFrom(key);
      builder->Add(key, iter->value());
    }

    // Finish and check for builder errors
    if (s.ok()) {
      s = builder->Finish();
      if (s.ok()) {
        meta->file_size = builder->FileSize();
        assert(meta->file_size > 0);
      }
    } else {
      builder->Abandon();
    }
    d...",1,1,db\builder.cc,leveldb.BuildTable,,false,17,86,BuildTable,,,1,"Status leveldb.BuildTable (ANY,Env*,Options,TableCache*,Iterator*,FileMetaData*)"
797,METHOD,db\builder.hpp:<global>,TYPE_DECL,<global>,1,1,db\builder.hpp,db\builder.hpp:<global>,,false,1,34,<global>,,,1,
806,METHOD,db\builder.hpp:<global>,TYPE_DECL,"extern Status BuildTable(const std::string& dbname,
                         Env* env,
                         const Options& options,
                         TableCache* table_cache,
                         Iterator* iter,
                         FileMetaData* meta);",15,44,db\builder.hpp,leveldb.BuildTable,,false,25,30,BuildTable,,,7,"Status leveldb.BuildTable (ANY,Env*,Options,TableCache*,Iterator*,FileMetaData*)"
843,METHOD,db\c.cc:<global>,TYPE_DECL,<global>,1,1,db\c.cc,db\c.cc:<global>,,false,1,595,<global>,,,1,
873,METHOD,leveldb_comparator_t,TYPE_DECL,void (*destructor_)(void*);,8,28,db\c.cc,leveldb_comparator_t.destructor_,,false,62,62,destructor_,,,2,void leveldb_comparator_t.destructor_ (void*)
878,METHOD,leveldb_comparator_t,TYPE_DECL,"int (*compare_)(
      void*,
      const char* a, size_t alen,
      const char* b, size_t blen);",7,33,db\c.cc,leveldb_comparator_t.compare_,,false,63,66,compare_,,,3,"int leveldb_comparator_t.compare_ (void*,char*,size_t,char*,size_t)"
887,METHOD,leveldb_comparator_t,TYPE_DECL,const char* (*name_)(void*);,13,29,db\c.cc,leveldb_comparator_t.name_,,false,67,67,name_,,,4,char* leveldb_comparator_t.name_ (void*)
892,METHOD,leveldb_comparator_t,TYPE_DECL,"virtual ~leveldb_comparator_t() {
    (*destructor_)(state_);
  }",3,3,db\c.cc,leveldb_comparator_t.~leveldb_comparator_t,,false,69,71,~leveldb_comparator_t,,,5,ANY leveldb_comparator_t.~leveldb_comparator_t ()
900,METHOD,leveldb_comparator_t,TYPE_DECL,"virtual int Compare(const Slice& a, const Slice& b) const {
    return (*compare_)(state_, a.data(), a.size(), b.data(), b.size());
  }",3,3,db\c.cc,leveldb_comparator_t.Compare,,false,73,75,Compare,,,6,"int leveldb_comparator_t.Compare (Slice,Slice)"
927,METHOD,leveldb_comparator_t,TYPE_DECL,"virtual const char* Name() const {
    return (*name_)(state_);
  }",3,3,db\c.cc,leveldb_comparator_t.Name,,false,77,79,Name,,,7,const char* leveldb_comparator_t.Name ()
936,METHOD,leveldb_comparator_t,TYPE_DECL,"virtual void FindShortestSeparator(std::string*, const Slice&) const { }",3,74,db\c.cc,leveldb_comparator_t.FindShortestSeparator,,false,82,82,FindShortestSeparator,,,8,"void leveldb_comparator_t.FindShortestSeparator (ANY*,Slice)"
942,METHOD,leveldb_comparator_t,TYPE_DECL,virtual void FindShortSuccessor(std::string* key) const { },3,61,db\c.cc,leveldb_comparator_t.FindShortSuccessor,,false,83,83,FindShortSuccessor,,,9,void leveldb_comparator_t.FindShortSuccessor (ANY*)
949,METHOD,leveldb_filterpolicy_t,TYPE_DECL,void (*destructor_)(void*);,8,28,db\c.cc,leveldb_filterpolicy_t.destructor_,,false,88,88,destructor_,,,2,void leveldb_filterpolicy_t.destructor_ (void*)
954,METHOD,leveldb_filterpolicy_t,TYPE_DECL,const char* (*name_)(void*);,13,29,db\c.cc,leveldb_filterpolicy_t.name_,,false,89,89,name_,,,3,char* leveldb_filterpolicy_t.name_ (void*)
959,METHOD,leveldb_filterpolicy_t,TYPE_DECL,"char* (*create_)(
      void*,
      const char* const* key_array, const size_t* key_length_array,
      int num_keys,
      size_t* filter_length);",7,28,db\c.cc,leveldb_filterpolicy_t.create_,,false,90,94,create_,,,4,"char* leveldb_filterpolicy_t.create_ (void*,char**,size_t*,int,size_t*)"
968,METHOD,leveldb_filterpolicy_t,TYPE_DECL,"unsigned char (*key_match_)(
      void*,
      const char* key, size_t length,
      const char* filter, size_t filter_length);",17,47,db\c.cc,leveldb_filterpolicy_t.key_match_,,false,95,98,key_match_,,,5,"unsigned char leveldb_filterpolicy_t.key_match_ (void*,char*,size_t,char*,size_t)"
977,METHOD,leveldb_filterpolicy_t,TYPE_DECL,"virtual ~leveldb_filterpolicy_t() {
    (*destructor_)(state_);
  }",3,3,db\c.cc,leveldb_filterpolicy_t.~leveldb_filterpolicy_t,,false,100,102,~leveldb_filterpolicy_t,,,6,ANY leveldb_filterpolicy_t.~leveldb_filterpolicy_t ()
985,METHOD,leveldb_filterpolicy_t,TYPE_DECL,"virtual const char* Name() const {
    return (*name_)(state_);
  }",3,3,db\c.cc,leveldb_filterpolicy_t.Name,,false,104,106,Name,,,7,const char* leveldb_filterpolicy_t.Name ()
994,METHOD,leveldb_filterpolicy_t,TYPE_DECL,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    std::vector<const char*> key_pointers(n);
    std::vector<size_t> key_sizes(n);
    for (int i = 0; i < n; i++) {
      key_pointers[i] = keys[i].data();
      key_sizes[i] = keys[i].size();
    }
    size_t len;
    char* filter = (*create_)(state_, &key_pointers[0], &key_sizes[0], n, &len);
    dst->append(filter, len);
    free(filter);
  }",3,3,db\c.cc,leveldb_filterpolicy_t.CreateFilter,,false,108,119,CreateFilter,,,8,"void leveldb_filterpolicy_t.CreateFilter (Slice*,int,ANY*)"
1071,METHOD,leveldb_filterpolicy_t,TYPE_DECL,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    return (*key_match_)(state_, key.data(), key.size(),
                         filter.data(), filter.size());
  }",3,3,db\c.cc,leveldb_filterpolicy_t.KeyMayMatch,,false,121,124,KeyMayMatch,,,9,"bool leveldb_filterpolicy_t.KeyMayMatch (Slice,Slice)"
1101,METHOD,db\c.cc:<global>,TYPE_DECL,"static bool SaveError(char** errptr, const Status& s) {
  assert(errptr != NULL);
  if (s.ok()) {
    return false;
  } else if (*errptr == NULL) {
    *errptr = strdup(s.ToString().c_str());
  } else {
    // TODO(sanjay): Merge with existing error?
    free(*errptr);
    *errptr = strdup(s.ToString().c_str());
  }
  return true;
}",1,1,db\c.cc,SaveError,,false,132,144,SaveError,,,17,"bool SaveError (char**,Status)"
1156,METHOD,db\c.cc:<global>,TYPE_DECL,"static char* CopyString(const std::string& str) {
  char* result = reinterpret_cast<char*>(malloc(sizeof(char) * str.size()));
  memcpy(result, str.data(), sizeof(char) * str.size());
  return result;
}",1,1,db\c.cc,CopyString,,false,146,150,CopyString,,,18,char* CopyString (ANY)
1189,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_t* leveldb_open(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  DB* db;
  if (SaveError(errptr, DB::Open(options->rep, std::string(name), &db))) {
    return NULL;
  }
  leveldb_t* result = new leveldb_t;
  result->rep = db;
  return result;
}",1,1,db\c.cc,leveldb_open,,false,152,163,leveldb_open,,,19,"leveldb_t leveldb_open (leveldb_options_t*,char*,char**)"
1229,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_close(leveldb_t* db) {
  delete db->rep;
  delete db;
}",1,1,db\c.cc,leveldb_close,,false,165,168,leveldb_close,,,20,void leveldb_close (leveldb_t*)
1240,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_put(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    const char* val, size_t vallen,
    char** errptr) {
  SaveError(errptr,
            db->rep->Put(options->rep, Slice(key, keylen), Slice(val, vallen)));
}",1,1,db\c.cc,leveldb_put,,false,170,178,leveldb_put,,,21,"void leveldb_put (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char*,size_t,char**)"
1268,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_delete(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    char** errptr) {
  SaveError(errptr, db->rep->Delete(options->rep, Slice(key, keylen)));
}",1,1,db\c.cc,leveldb_delete,,false,180,186,leveldb_delete,,,22,"void leveldb_delete (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char**)"
1291,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_write(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    leveldb_writebatch_t* batch,
    char** errptr) {
  SaveError(errptr, db->rep->Write(options->rep, &batch->rep));
}",1,1,db\c.cc,leveldb_write,,false,189,195,leveldb_write,,,23,"void leveldb_write (leveldb_t*,leveldb_writeoptions_t*,leveldb_writebatch_t*,char**)"
1314,METHOD,db\c.cc:<global>,TYPE_DECL,"char* leveldb_get(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key, size_t keylen,
    size_t* vallen,
    char** errptr) {
  char* result = NULL;
  std::string tmp;
  Status s = db->rep->Get(options->rep, Slice(key, keylen), &tmp);
  if (s.ok()) {
    *vallen = tmp.size();
    result = CopyString(tmp);
  } else {
    *vallen = 0;
    if (!s.IsNotFound()) {
      SaveError(errptr, s);
    }
  }
  return result;
}",1,1,db\c.cc,leveldb_get,,false,197,216,leveldb_get,,,24,"char* leveldb_get (leveldb_t*,leveldb_readoptions_t*,char*,size_t,size_t*,char**)"
1381,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_iterator_t* leveldb_create_iterator(
    leveldb_t* db,
    const leveldb_readoptions_t* options) {
  leveldb_iterator_t* result = new leveldb_iterator_t;
  result->rep = db->rep->NewIterator(options->rep);
  return result;
}",1,1,db\c.cc,leveldb_create_iterator,,false,218,224,leveldb_create_iterator,,,25,"leveldb_iterator_t leveldb_create_iterator (leveldb_t*,leveldb_readoptions_t*)"
1407,METHOD,db\c.cc:<global>,TYPE_DECL,"const leveldb_snapshot_t* leveldb_create_snapshot(
    leveldb_t* db) {
  leveldb_snapshot_t* result = new leveldb_snapshot_t;
  result->rep = db->rep->GetSnapshot();
  return result;
}",1,1,db\c.cc,leveldb_create_snapshot,,false,226,231,leveldb_create_snapshot,,,26,leveldb_snapshot_t leveldb_create_snapshot (leveldb_t*)
1429,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_release_snapshot(
    leveldb_t* db,
    const leveldb_snapshot_t* snapshot) {
  db->rep->ReleaseSnapshot(snapshot->rep);
  delete snapshot;
}",1,1,db\c.cc,leveldb_release_snapshot,,false,233,238,leveldb_release_snapshot,,,27,"void leveldb_release_snapshot (leveldb_t*,leveldb_snapshot_t*)"
1446,METHOD,db\c.cc:<global>,TYPE_DECL,"char* leveldb_property_value(
    leveldb_t* db,
    const char* propname) {
  std::string tmp;
  if (db->rep->GetProperty(Slice(propname), &tmp)) {
    // We use strdup() since we expect human readable output.
    return strdup(tmp.c_str());
  } else {
    return NULL;
  }
}",1,1,db\c.cc,leveldb_property_value,,false,240,250,leveldb_property_value,,,28,"char* leveldb_property_value (leveldb_t*,char*)"
1475,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_approximate_sizes(
    leveldb_t* db,
    int num_ranges,
    const char* const* range_start_key, const size_t* range_start_key_len,
    const char* const* range_limit_key, const size_t* range_limit_key_len,
    uint64_t* sizes) {
  Range* ranges = new Range[num_ranges];
  for (int i = 0; i < num_ranges; i++) {
    ranges[i].start = Slice(range_start_key[i], range_start_key_len[i]);
    ranges[i].limit = Slice(range_limit_key[i], range_limit_key_len[i]);
  }
  db->rep->GetApproximateSizes(ranges, num_ranges, sizes);
  delete[] ranges;
}",1,1,db\c.cc,leveldb_approximate_sizes,,false,252,265,leveldb_approximate_sizes,,,29,"void leveldb_approximate_sizes (leveldb_t*,int,char**,size_t*,char**,size_t*,uint64_t*)"
1540,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_compact_range(
    leveldb_t* db,
    const char* start_key, size_t start_key_len,
    const char* limit_key, size_t limit_key_len) {
  Slice a, b;
  db->rep->CompactRange(
      // Pass NULL Slice if corresponding ""const char*"" is NULL
      (start_key ? (a = Slice(start_key, start_key_len), &a) : NULL),
      (limit_key ? (b = Slice(limit_key, limit_key_len), &b) : NULL));
}",1,1,db\c.cc,leveldb_compact_range,,false,267,276,leveldb_compact_range,,,30,"void leveldb_compact_range (leveldb_t*,char*,size_t,char*,size_t)"
1581,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_destroy_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  SaveError(errptr, DestroyDB(name, options->rep));
}",1,1,db\c.cc,leveldb_destroy_db,,false,278,283,leveldb_destroy_db,,,31,"void leveldb_destroy_db (leveldb_options_t*,char*,char**)"
1595,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_repair_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr) {
  SaveError(errptr, RepairDB(name, options->rep));
}",1,1,db\c.cc,leveldb_repair_db,,false,285,290,leveldb_repair_db,,,32,"void leveldb_repair_db (leveldb_options_t*,char*,char**)"
1609,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_destroy(leveldb_iterator_t* iter) {
  delete iter->rep;
  delete iter;
}",1,1,db\c.cc,leveldb_iter_destroy,,false,292,295,leveldb_iter_destroy,,,33,void leveldb_iter_destroy (leveldb_iterator_t*)
1620,METHOD,db\c.cc:<global>,TYPE_DECL,"unsigned char leveldb_iter_valid(const leveldb_iterator_t* iter) {
  return iter->rep->Valid();
}",1,1,db\c.cc,leveldb_iter_valid,,false,297,299,leveldb_iter_valid,,,34,unsigned char leveldb_iter_valid (leveldb_iterator_t*)
1632,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_seek_to_first(leveldb_iterator_t* iter) {
  iter->rep->SeekToFirst();
}",1,1,db\c.cc,leveldb_iter_seek_to_first,,false,301,303,leveldb_iter_seek_to_first,,,35,void leveldb_iter_seek_to_first (leveldb_iterator_t*)
1643,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_seek_to_last(leveldb_iterator_t* iter) {
  iter->rep->SeekToLast();
}",1,1,db\c.cc,leveldb_iter_seek_to_last,,false,305,307,leveldb_iter_seek_to_last,,,36,void leveldb_iter_seek_to_last (leveldb_iterator_t*)
1654,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_seek(leveldb_iterator_t* iter, const char* k, size_t klen) {
  iter->rep->Seek(Slice(k, klen));
}",1,1,db\c.cc,leveldb_iter_seek,,false,309,311,leveldb_iter_seek,,,37,"void leveldb_iter_seek (leveldb_iterator_t*,char*,size_t)"
1670,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_next(leveldb_iterator_t* iter) {
  iter->rep->Next();
}",1,1,db\c.cc,leveldb_iter_next,,false,313,315,leveldb_iter_next,,,38,void leveldb_iter_next (leveldb_iterator_t*)
1681,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_prev(leveldb_iterator_t* iter) {
  iter->rep->Prev();
}",1,1,db\c.cc,leveldb_iter_prev,,false,317,319,leveldb_iter_prev,,,39,void leveldb_iter_prev (leveldb_iterator_t*)
1692,METHOD,db\c.cc:<global>,TYPE_DECL,"const char* leveldb_iter_key(const leveldb_iterator_t* iter, size_t* klen) {
  Slice s = iter->rep->key();
  *klen = s.size();
  return s.data();
}",1,1,db\c.cc,leveldb_iter_key,,false,321,325,leveldb_iter_key,,,40,"const char* leveldb_iter_key (leveldb_iterator_t*,size_t*)"
1719,METHOD,db\c.cc:<global>,TYPE_DECL,"const char* leveldb_iter_value(const leveldb_iterator_t* iter, size_t* vlen) {
  Slice s = iter->rep->value();
  *vlen = s.size();
  return s.data();
}",1,1,db\c.cc,leveldb_iter_value,,false,327,331,leveldb_iter_value,,,41,"const char* leveldb_iter_value (leveldb_iterator_t*,size_t*)"
1746,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_iter_get_error(const leveldb_iterator_t* iter, char** errptr) {
  SaveError(errptr, iter->rep->status());
}",1,1,db\c.cc,leveldb_iter_get_error,,false,333,335,leveldb_iter_get_error,,,42,"void leveldb_iter_get_error (leveldb_iterator_t*,char**)"
1760,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_writebatch_t* leveldb_writebatch_create() {
  return new leveldb_writebatch_t;
}",1,1,db\c.cc,leveldb_writebatch_create,,false,337,339,leveldb_writebatch_create,,,43,leveldb_writebatch_t leveldb_writebatch_create ()
1767,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writebatch_destroy(leveldb_writebatch_t* b) {
  delete b;
}",1,1,db\c.cc,leveldb_writebatch_destroy,,false,341,343,leveldb_writebatch_destroy,,,44,void leveldb_writebatch_destroy (leveldb_writebatch_t*)
1774,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writebatch_clear(leveldb_writebatch_t* b) {
  b->rep.Clear();
}",1,1,db\c.cc,leveldb_writebatch_clear,,false,345,347,leveldb_writebatch_clear,,,45,void leveldb_writebatch_clear (leveldb_writebatch_t*)
1785,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writebatch_put(
    leveldb_writebatch_t* b,
    const char* key, size_t klen,
    const char* val, size_t vlen) {
  b->rep.Put(Slice(key, klen), Slice(val, vlen));
}",1,1,db\c.cc,leveldb_writebatch_put,,false,349,354,leveldb_writebatch_put,,,46,"void leveldb_writebatch_put (leveldb_writebatch_t*,char*,size_t,char*,size_t)"
1806,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writebatch_delete(
    leveldb_writebatch_t* b,
    const char* key, size_t klen) {
  b->rep.Delete(Slice(key, klen));
}",1,1,db\c.cc,leveldb_writebatch_delete,,false,356,360,leveldb_writebatch_delete,,,47,"void leveldb_writebatch_delete (leveldb_writebatch_t*,char*,size_t)"
1822,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writebatch_iterate(
    leveldb_writebatch_t* b,
    void* state,
    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),
    void (*deleted)(void*, const char* k, size_t klen)) {
  class H : public WriteBatch::Handler {
   public:
    void* state_;
    void (*put_)(void*, const char* k, size_t klen, const char* v, size_t vlen);
    void (*deleted_)(void*, const char* k, size_t klen);
    virtual void Put(const Slice& key, const Slice& value) {
      (*put_)(state_, key.data(), key.size(), value.data(), value.size());
    }
    virtual void Delete(const Slice& key) {
      (*deleted_)(state_, key.data(), key.size());
    }
  };
  H handler;
  handler.state_ = state;
  handler.put_ = put;
  handler.deleted_ = deleted;
  b->rep.Iterate(&handler);
}",1,1,db\c.cc,leveldb_writebatch_iterate,,false,362,384,leveldb_writebatch_iterate,,,48,"void leveldb_writebatch_iterate (leveldb_writebatch_t*,void*,void,void)"
1854,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_options_t* leveldb_options_create() {
  return new leveldb_options_t;
}",1,1,db\c.cc,leveldb_options_create,,false,386,388,leveldb_options_create,,,49,leveldb_options_t leveldb_options_create ()
1861,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_destroy(leveldb_options_t* options) {
  delete options;
}",1,1,db\c.cc,leveldb_options_destroy,,false,390,392,leveldb_options_destroy,,,50,void leveldb_options_destroy (leveldb_options_t*)
1868,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_comparator(
    leveldb_options_t* opt,
    leveldb_comparator_t* cmp) {
  opt->rep.comparator = cmp;
}",1,1,db\c.cc,leveldb_options_set_comparator,,false,394,398,leveldb_options_set_comparator,,,51,"void leveldb_options_set_comparator (leveldb_options_t*,leveldb_comparator_t*)"
1881,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_filter_policy(
    leveldb_options_t* opt,
    leveldb_filterpolicy_t* policy) {
  opt->rep.filter_policy = policy;
}",1,1,db\c.cc,leveldb_options_set_filter_policy,,false,400,404,leveldb_options_set_filter_policy,,,52,"void leveldb_options_set_filter_policy (leveldb_options_t*,leveldb_filterpolicy_t*)"
1894,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_create_if_missing(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.create_if_missing = v;
}",1,1,db\c.cc,leveldb_options_set_create_if_missing,,false,406,409,leveldb_options_set_create_if_missing,,,53,"void leveldb_options_set_create_if_missing (leveldb_options_t*,unsigned char)"
1907,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_error_if_exists(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.error_if_exists = v;
}",1,1,db\c.cc,leveldb_options_set_error_if_exists,,false,411,414,leveldb_options_set_error_if_exists,,,54,"void leveldb_options_set_error_if_exists (leveldb_options_t*,unsigned char)"
1920,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_paranoid_checks(
    leveldb_options_t* opt, unsigned char v) {
  opt->rep.paranoid_checks = v;
}",1,1,db\c.cc,leveldb_options_set_paranoid_checks,,false,416,419,leveldb_options_set_paranoid_checks,,,55,"void leveldb_options_set_paranoid_checks (leveldb_options_t*,unsigned char)"
1933,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_env(leveldb_options_t* opt, leveldb_env_t* env) {
  opt->rep.env = (env ? env->rep : NULL);
}",1,1,db\c.cc,leveldb_options_set_env,,false,421,423,leveldb_options_set_env,,,56,"void leveldb_options_set_env (leveldb_options_t*,leveldb_env_t*)"
1951,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_info_log(leveldb_options_t* opt, leveldb_logger_t* l) {
  opt->rep.info_log = (l ? l->rep : NULL);
}",1,1,db\c.cc,leveldb_options_set_info_log,,false,425,427,leveldb_options_set_info_log,,,57,"void leveldb_options_set_info_log (leveldb_options_t*,leveldb_logger_t*)"
1969,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_write_buffer_size(leveldb_options_t* opt, size_t s) {
  opt->rep.write_buffer_size = s;
}",1,1,db\c.cc,leveldb_options_set_write_buffer_size,,false,429,431,leveldb_options_set_write_buffer_size,,,58,"void leveldb_options_set_write_buffer_size (leveldb_options_t*,size_t)"
1982,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {
  opt->rep.max_open_files = n;
}",1,1,db\c.cc,leveldb_options_set_max_open_files,,false,433,435,leveldb_options_set_max_open_files,,,59,"void leveldb_options_set_max_open_files (leveldb_options_t*,int)"
1995,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_cache(leveldb_options_t* opt, leveldb_cache_t* c) {
  opt->rep.block_cache = c->rep;
}",1,1,db\c.cc,leveldb_options_set_cache,,false,437,439,leveldb_options_set_cache,,,60,"void leveldb_options_set_cache (leveldb_options_t*,leveldb_cache_t*)"
2010,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_block_size(leveldb_options_t* opt, size_t s) {
  opt->rep.block_size = s;
}",1,1,db\c.cc,leveldb_options_set_block_size,,false,441,443,leveldb_options_set_block_size,,,61,"void leveldb_options_set_block_size (leveldb_options_t*,size_t)"
2023,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_block_restart_interval(leveldb_options_t* opt, int n) {
  opt->rep.block_restart_interval = n;
}",1,1,db\c.cc,leveldb_options_set_block_restart_interval,,false,445,447,leveldb_options_set_block_restart_interval,,,62,"void leveldb_options_set_block_restart_interval (leveldb_options_t*,int)"
2036,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_options_set_compression(leveldb_options_t* opt, int t) {
  opt->rep.compression = static_cast<CompressionType>(t);
}",1,1,db\c.cc,leveldb_options_set_compression,,false,449,451,leveldb_options_set_compression,,,63,"void leveldb_options_set_compression (leveldb_options_t*,int)"
2051,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_comparator_t* leveldb_comparator_create(
    void* state,
    void (*destructor)(void*),
    int (*compare)(
        void*,
        const char* a, size_t alen,
        const char* b, size_t blen),
    const char* (*name)(void*)) {
  leveldb_comparator_t* result = new leveldb_comparator_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->compare_ = compare;
  result->name_ = name;
  return result;
}",1,1,db\c.cc,leveldb_comparator_create,,false,453,467,leveldb_comparator_create,,,64,"leveldb_comparator_t leveldb_comparator_create (void*,void,int,char*)"
2086,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_comparator_destroy(leveldb_comparator_t* cmp) {
  delete cmp;
}",1,1,db\c.cc,leveldb_comparator_destroy,,false,469,471,leveldb_comparator_destroy,,,65,void leveldb_comparator_destroy (leveldb_comparator_t*)
2093,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_filterpolicy_t* leveldb_filterpolicy_create(
    void* state,
    void (*destructor)(void*),
    char* (*create_filter)(
        void*,
        const char* const* key_array, const size_t* key_length_array,
        int num_keys,
        size_t* filter_length),
    unsigned char (*key_may_match)(
        void*,
        const char* key, size_t length,
        const char* filter, size_t filter_length),
    const char* (*name)(void*)) {
  leveldb_filterpolicy_t* result = new leveldb_filterpolicy_t;
  result->state_ = state;
  result->destructor_ = destructor;
  result->create_ = create_filter;
  result->key_match_ = key_may_match;
  result->name_ = name;
  return result;
}",1,1,db\c.cc,leveldb_filterpolicy_create,,false,473,493,leveldb_filterpolicy_create,,,66,"leveldb_filterpolicy_t leveldb_filterpolicy_create (void*,void,char*,unsigned char,char*)"
2134,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t* filter) {
  delete filter;
}",1,1,db\c.cc,leveldb_filterpolicy_destroy,,false,495,497,leveldb_filterpolicy_destroy,,,67,void leveldb_filterpolicy_destroy (leveldb_filterpolicy_t*)
2141,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(int bits_per_key) {
  // Make a leveldb_filterpolicy_t, but override all of its methods so
  // they delegate to a NewBloomFilterPolicy() instead of user
  // supplied C functions.
  struct Wrapper : public leveldb_filterpolicy_t {
    const FilterPolicy* rep_;
    ~Wrapper() { delete rep_; }
    const char* Name() const { return rep_->Name(); }
    void CreateFilter(const Slice* keys, int n, std::string* dst) const {
      return rep_->CreateFilter(keys, n, dst);
    }
    bool KeyMayMatch(const Slice& key, const Slice& filter) const {
      return rep_->KeyMayMatch(key, filter);
    }
    static void DoNothing(void*) { }
  };
  Wrapper* wrapper = new Wrapper;
  wrapper->rep_ = NewBloomFilterPolicy(bits_per_key);
  wrapper->state_ = NULL;
  wrapper->destructor_ = &Wrapper::DoNothing;
  return wrapper;
}",1,1,db\c.cc,leveldb_filterpolicy_create_bloom,,false,499,520,leveldb_filterpolicy_create_bloom,,,68,leveldb_filterpolicy_t leveldb_filterpolicy_create_bloom (int)
2172,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_readoptions_t* leveldb_readoptions_create() {
  return new leveldb_readoptions_t;
}",1,1,db\c.cc,leveldb_readoptions_create,,false,522,524,leveldb_readoptions_create,,,69,leveldb_readoptions_t leveldb_readoptions_create ()
2179,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_readoptions_destroy(leveldb_readoptions_t* opt) {
  delete opt;
}",1,1,db\c.cc,leveldb_readoptions_destroy,,false,526,528,leveldb_readoptions_destroy,,,70,void leveldb_readoptions_destroy (leveldb_readoptions_t*)
2186,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_readoptions_set_verify_checksums(
    leveldb_readoptions_t* opt,
    unsigned char v) {
  opt->rep.verify_checksums = v;
}",1,1,db\c.cc,leveldb_readoptions_set_verify_checksums,,false,530,534,leveldb_readoptions_set_verify_checksums,,,71,"void leveldb_readoptions_set_verify_checksums (leveldb_readoptions_t*,unsigned char)"
2199,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_readoptions_set_fill_cache(
    leveldb_readoptions_t* opt, unsigned char v) {
  opt->rep.fill_cache = v;
}",1,1,db\c.cc,leveldb_readoptions_set_fill_cache,,false,536,539,leveldb_readoptions_set_fill_cache,,,72,"void leveldb_readoptions_set_fill_cache (leveldb_readoptions_t*,unsigned char)"
2212,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_readoptions_set_snapshot(
    leveldb_readoptions_t* opt,
    const leveldb_snapshot_t* snap) {
  opt->rep.snapshot = (snap ? snap->rep : NULL);
}",1,1,db\c.cc,leveldb_readoptions_set_snapshot,,false,541,545,leveldb_readoptions_set_snapshot,,,73,"void leveldb_readoptions_set_snapshot (leveldb_readoptions_t*,leveldb_snapshot_t*)"
2230,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_writeoptions_t* leveldb_writeoptions_create() {
  return new leveldb_writeoptions_t;
}",1,1,db\c.cc,leveldb_writeoptions_create,,false,547,549,leveldb_writeoptions_create,,,74,leveldb_writeoptions_t leveldb_writeoptions_create ()
2237,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writeoptions_destroy(leveldb_writeoptions_t* opt) {
  delete opt;
}",1,1,db\c.cc,leveldb_writeoptions_destroy,,false,551,553,leveldb_writeoptions_destroy,,,75,void leveldb_writeoptions_destroy (leveldb_writeoptions_t*)
2244,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_writeoptions_set_sync(
    leveldb_writeoptions_t* opt, unsigned char v) {
  opt->rep.sync = v;
}",1,1,db\c.cc,leveldb_writeoptions_set_sync,,false,555,558,leveldb_writeoptions_set_sync,,,76,"void leveldb_writeoptions_set_sync (leveldb_writeoptions_t*,unsigned char)"
2257,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_cache_t* leveldb_cache_create_lru(size_t capacity) {
  leveldb_cache_t* c = new leveldb_cache_t;
  c->rep = NewLRUCache(capacity);
  return c;
}",1,1,db\c.cc,leveldb_cache_create_lru,,false,560,564,leveldb_cache_create_lru,,,77,leveldb_cache_t leveldb_cache_create_lru (size_t)
2275,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_cache_destroy(leveldb_cache_t* cache) {
  delete cache->rep;
  delete cache;
}",1,1,db\c.cc,leveldb_cache_destroy,,false,566,569,leveldb_cache_destroy,,,78,void leveldb_cache_destroy (leveldb_cache_t*)
2286,METHOD,db\c.cc:<global>,TYPE_DECL,"leveldb_env_t* leveldb_create_default_env() {
  leveldb_env_t* result = new leveldb_env_t;
  result->rep = Env::Default();
  result->is_default = true;
  return result;
}",1,1,db\c.cc,leveldb_create_default_env,,false,571,576,leveldb_create_default_env,,,79,leveldb_env_t leveldb_create_default_env ()
2310,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_env_destroy(leveldb_env_t* env) {
  if (!env->is_default) delete env->rep;
  delete env;
}",1,1,db\c.cc,leveldb_env_destroy,,false,578,581,leveldb_env_destroy,,,80,void leveldb_env_destroy (leveldb_env_t*)
2327,METHOD,db\c.cc:<global>,TYPE_DECL,"void leveldb_free(void* ptr) {
  free(ptr);
}",1,1,db\c.cc,leveldb_free,,false,583,585,leveldb_free,,,81,void leveldb_free (void*)
2334,METHOD,db\c.cc:<global>,TYPE_DECL,"int leveldb_major_version() {
  return kMajorVersion;
}",1,1,db\c.cc,leveldb_major_version,,false,587,589,leveldb_major_version,,,82,int leveldb_major_version ()
2340,METHOD,db\c.cc:<global>,TYPE_DECL,"int leveldb_minor_version() {
  return kMinorVersion;
}",1,1,db\c.cc,leveldb_minor_version,,false,591,593,leveldb_minor_version,,,83,int leveldb_minor_version ()
2363,METHOD,db\c_test.c:<global>,TYPE_DECL,<global>,1,1,db\c_test.c,db\c_test.c:<global>,,false,1,390,<global>,,,1,
2372,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void StartPhase(const char* name) {
  fprintf(stderr, ""=== Test %s\n"", name);
  phase = name;
}",1,1,db\c_test.c,StartPhase,,false,17,20,StartPhase,,,5,void StartPhase (char*)
2384,METHOD,db\c_test.c:<global>,TYPE_DECL,"static const char* GetTempDir(void) {
    const char* ret = getenv(""TEST_TMPDIR"");
    if (ret == NULL || ret[0] == '\0')
        ret = ""/tmp"";
    return ret;
}",1,1,db\c_test.c,GetTempDir,,false,22,27,GetTempDir,,,6,const char* GetTempDir (void)
2410,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void CheckEqual(const char* expected, const char* v, size_t n) {
  if (expected == NULL && v == NULL) {
    // ok
  } else if (expected != NULL && v != NULL && n == strlen(expected) &&
             memcmp(expected, v, n) == 0) {
    // ok
    return;
  } else {
    fprintf(stderr, ""%s: expected '%s', got '%s'\n"",
            phase,
            (expected ? expected : ""(null)""),
            (v ? v : ""(null""));
    abort();
  }
}",1,1,db\c_test.c,CheckEqual,,false,41,55,CheckEqual,,,7,"void CheckEqual (char*,char*,size_t)"
2465,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void Free(char** ptr) {
  if (*ptr) {
    free(*ptr);
    *ptr = NULL;
  }
}",1,1,db\c_test.c,Free,,false,57,62,Free,,,8,void Free (char**)
2481,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void CheckGet(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key,
    const char* expected) {
  char* err = NULL;
  size_t val_len;
  char* val;
  val = leveldb_get(db, options, key, strlen(key), &val_len, &err);
  CheckNoError(err);
  CheckEqual(expected, val, val_len);
  Free(&val);
}",1,2,db\c_test.c,CheckGet,,false,64,76,CheckGet,,,9,"void CheckGet (leveldb_t*,leveldb_readoptions_t*,char*,char*)"
2530,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void CheckIter(leveldb_iterator_t* iter,
                      const char* key, const char* val) {
  size_t len;
  const char* str;
  str = leveldb_iter_key(iter, &len);
  CheckEqual(key, str, len);
  str = leveldb_iter_value(iter, &len);
  CheckEqual(val, str, len);
}",1,1,db\c_test.c,CheckIter,,false,78,86,CheckIter,,,10,"void CheckIter (leveldb_iterator_t*,char*,char*)"
2559,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void CheckPut(void* ptr,
                     const char* k, size_t klen,
                     const char* v, size_t vlen) {
  int* state = (int*) ptr;
  CheckCondition(*state < 2);
  switch (*state) {
    case 0:
      CheckEqual(""bar"", k, klen);
      CheckEqual(""b"", v, vlen);
      break;
    case 1:
      CheckEqual(""box"", k, klen);
      CheckEqual(""c"", v, vlen);
      break;
  }
  (*state)++;
}",1,2,db\c_test.c,CheckPut,,false,89,105,CheckPut,,,11,"void CheckPut (void*,char*,size_t,char*,size_t)"
2620,METHOD,db\c_test.c:<global>,TYPE_DECL,"static void CheckDel(void* ptr, const char* k, size_t klen) {
  int* state = (int*) ptr;
  CheckCondition(*state == 2);
  CheckEqual(""bar"", k, klen);
  (*state)++;
}",1,2,db\c_test.c,CheckDel,,false,108,113,CheckDel,,,12,"void CheckDel (void*,char*,size_t)"
2657,METHOD,db\c_test.c:<global>,TYPE_DECL,static void CmpDestroy(void* arg) { },1,37,db\c_test.c,CmpDestroy,,false,115,115,CmpDestroy,,,13,void CmpDestroy (void*)
2662,METHOD,db\c_test.c:<global>,TYPE_DECL,"static int CmpCompare(void* arg, const char* a, size_t alen,
                      const char* b, size_t blen) {
  int n = (alen < blen) ? alen : blen;
  int r = memcmp(a, b, n);
  if (r == 0) {
    if (alen < blen) r = -1;
    else if (alen > blen) r = +1;
  }
  return r;
}",1,1,db\c_test.c,CmpCompare,,false,117,126,CmpCompare,,,14,"int CmpCompare (void*,char*,size_t,char*,size_t)"
2714,METHOD,db\c_test.c:<global>,TYPE_DECL,"static const char* CmpName(void* arg) {
  return ""foo"";
}",1,1,db\c_test.c,CmpName,,false,128,130,CmpName,,,15,const char* CmpName (void*)
2725,METHOD,db\c_test.c:<global>,TYPE_DECL,static void FilterDestroy(void* arg) { },1,40,db\c_test.c,FilterDestroy,,false,134,134,FilterDestroy,,,18,void FilterDestroy (void*)
2730,METHOD,db\c_test.c:<global>,TYPE_DECL,"static const char* FilterName(void* arg) {
  return ""TestFilter"";
}",1,1,db\c_test.c,FilterName,,false,135,137,FilterName,,,19,const char* FilterName (void*)
2737,METHOD,db\c_test.c:<global>,TYPE_DECL,"static char* FilterCreate(
    void* arg,
    const char* const* key_array, const size_t* key_length_array,
    int num_keys,
    size_t* filter_length) {
  *filter_length = 4;
  char* result = malloc(4);
  memcpy(result, ""fake"", 4);
  return result;
}",1,1,db\c_test.c,FilterCreate,,false,138,147,FilterCreate,,,20,"char* FilterCreate (void*,char**,size_t*,int,size_t*)"
2761,METHOD,db\c_test.c:<global>,TYPE_DECL,"unsigned char FilterKeyMatch(
    void* arg,
    const char* key, size_t length,
    const char* filter, size_t filter_length) {
  CheckCondition(filter_length == 4);
  CheckCondition(memcmp(filter, ""fake"", 4) == 0);
  return fake_filter_result;
}",1,2,db\c_test.c,FilterKeyMatch,,false,148,155,FilterKeyMatch,,,21,"unsigned char FilterKeyMatch (void*,char*,size_t,char*,size_t)"
2807,METHOD,db\c_test.c:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  leveldb_t* db;
  leveldb_comparator_t* cmp;
  leveldb_cache_t* cache;
  leveldb_env_t* env;
  leveldb_options_t* options;
  leveldb_readoptions_t* roptions;
  leveldb_writeoptions_t* woptions;
  char* err = NULL;
  int run = -1;

  CheckCondition(leveldb_major_version() >= 1);
  CheckCondition(leveldb_minor_version() >= 1);

  snprintf(dbname, sizeof(dbname),
           ""%s/leveldb_c_test-%d"",
           GetTempDir(),
           ((int) geteuid()));

  StartPhase(""create_objects"");
  cmp = leveldb_comparator_create(NULL, CmpDestroy, CmpCompare, CmpName);
  env = leveldb_create_default_env();
  cache = leveldb_cache_create_lru(100000);

  options = leveldb_options_create();
  leveldb_options_set_comparator(options, cmp);
  leveldb_options_set_error_if_exists(options, 1);
  leveldb_options_set_cache(options, cache);
  leveldb_options_set_env(options, env);
  leveldb_options_set_info_log(options, NULL);
  leveldb_options_set_write_buffer_size(options,...",1,2,db\c_test.c,main,,false,157,390,main,,,22,"int main (int,char**)"
3862,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,<global>,1,1,db\corruption_test.cc,db\corruption_test.cc:<global>,,false,1,374,<global>,,,1,
3875,METHOD,leveldb.CorruptionTest,TYPE_DECL,"CorruptionTest() {
    tiny_cache_ = NewLRUCache(100);
    options_.env = &env_;
    options_.block_cache = tiny_cache_;
    dbname_ = test::TmpDir() + ""/corruption_test"";
    DestroyDB(dbname_, options_);

    db_ = NULL;
    options_.create_if_missing = true;
    Reopen();
    options_.create_if_missing = false;
  }",3,3,db\corruption_test.cc,leveldb.CorruptionTest.CorruptionTest,,false,35,46,CorruptionTest,,,6,ANY leveldb.CorruptionTest.CorruptionTest ()
3919,METHOD,leveldb.CorruptionTest,TYPE_DECL,"~CorruptionTest() {
     delete db_;
     DestroyDB(dbname_, Options());
     delete tiny_cache_;
  }",3,3,db\corruption_test.cc,leveldb.CorruptionTest.~CorruptionTest,,false,48,52,~CorruptionTest,,,7,ANY leveldb.CorruptionTest.~CorruptionTest ()
3930,METHOD,leveldb.CorruptionTest,TYPE_DECL,"Status TryReopen() {
    delete db_;
    db_ = NULL;
    return DB::Open(options_, dbname_, &db_);
  }",3,3,db\corruption_test.cc,leveldb.CorruptionTest.TryReopen,,false,54,58,TryReopen,,,8,Status leveldb.CorruptionTest.TryReopen ()
3948,METHOD,leveldb.CorruptionTest,TYPE_DECL,"void Reopen() {
    ASSERT_OK(TryReopen());
  }",3,4,db\corruption_test.cc,leveldb.CorruptionTest.Reopen,,false,60,62,Reopen,,,9,void leveldb.CorruptionTest.Reopen ()
3967,METHOD,leveldb.CorruptionTest,TYPE_DECL,"void RepairDB() {
    delete db_;
    db_ = NULL;
    ASSERT_OK(::leveldb::RepairDB(dbname_, options_));
  }",3,4,db\corruption_test.cc,leveldb.CorruptionTest.RepairDB,,false,64,68,RepairDB,,,10,void leveldb.CorruptionTest.RepairDB ()
3995,METHOD,leveldb.CorruptionTest,TYPE_DECL,"void Build(int n) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = 0; i < n; i++) {
      //if ((i % 100) == 0) fprintf(stderr, ""@ %d of %d\n"", i, n);
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      // Corrupt() doesn't work without this sync on windows; stat reports 0 for
      // the file size.
      if (i == n - 1) {
        options.sync = true;
      }
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",3,6,db\corruption_test.cc,leveldb.CorruptionTest.Build,,false,70,86,Build,,,11,void leveldb.CorruptionTest.Build (int)
4068,METHOD,leveldb.CorruptionTest,TYPE_DECL,"void Check(int min_expected, int max_expected) {
    int next_expected = 0;
    int missed = 0;
    int bad_keys = 0;
    int bad_values = 0;
    int correct = 0;
    std::string value_space;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      uint64_t key;
      Slice in(iter->key());
      if (in == """" || in == ""~"") {
        // Ignore boundary keys.
        continue;
      }
      if (!ConsumeDecimalNumber(&in, &key) ||
          !in.empty() ||
          key < next_expected) {
        bad_keys++;
        continue;
      }
      missed += (key - next_expected);
      next_expected = key + 1;
      if (iter->value() != Value(key, &value_space)) {
        bad_values++;
      } else {
        correct++;
      }
    }
    delete iter;

    fprintf(stderr,
            ""expected=%d..%d; got=%d; bad_keys=%d; bad_values=%d; missed=%d\n"",
            min_expected, max_expected, correct, bad_keys, bad_values, missed);
    ...",3,4,db\corruption_test.cc,leveldb.CorruptionTest.Check,,false,88,124,Check,,,12,"void leveldb.CorruptionTest.Check (int,int)"
4228,METHOD,leveldb.CorruptionTest,TYPE_DECL,"void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {
    // Pick file to corrupt
    std::vector<std::string> filenames;
    ASSERT_OK(env_.GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    std::string fname;
    int picked_number = -1;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type == filetype &&
          int(number) > picked_number) {  // Pick latest file
        fname = dbname_ + ""/"" + filenames[i];
        picked_number = number;
      }
    }
    ASSERT_TRUE(!fname.empty()) << filetype;

    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      const char* msg = strerror(errno);
      ASSERT_TRUE(false) << fname << "": "" << msg;
    }

    if (offset < 0) {
      // Relative to end of file; make it absolute
      if (-offset > sbuf.st_size) {
        offset = 0;
      } else {
        offset = sbuf.st_size + offset;
      }
    }
    if (offset >...",3,4,db\corruption_test.cc,leveldb.CorruptionTest.Corrupt,,false,126,174,Corrupt,,,13,"void leveldb.CorruptionTest.Corrupt (FileType,int,int)"
4531,METHOD,leveldb.CorruptionTest,TYPE_DECL,"int Property(const std::string& name) {
    std::string property;
    int result;
    if (db_->GetProperty(name, &property) &&
        sscanf(property.c_str(), ""%d"", &result) == 1) {
      return result;
    } else {
      return -1;
    }
  }",3,3,db\corruption_test.cc,leveldb.CorruptionTest.Property,,false,176,185,Property,,,14,int leveldb.CorruptionTest.Property (ANY)
4565,METHOD,leveldb.CorruptionTest,TYPE_DECL,"Slice Key(int i, std::string* storage) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%016d"", i);
    storage->assign(buf, strlen(buf));
    return Slice(*storage);
  }",3,3,db\corruption_test.cc,leveldb.CorruptionTest.Key,,false,188,193,Key,,,15,"Slice leveldb.CorruptionTest.Key (int,ANY*)"
4589,METHOD,leveldb.CorruptionTest,TYPE_DECL,"Slice Value(int k, std::string* storage) {
    Random r(k);
    return test::RandomString(&r, kValueSize, storage);
  }",3,3,db\corruption_test.cc,leveldb.CorruptionTest.Value,,false,196,199,Value,,,16,"Slice leveldb.CorruptionTest.Value (int,ANY*)"
4608,METHOD,leveldb._Test_Recovery,TYPE_DECL,void void ();,1,30,db\corruption_test.cc,leveldb._Test_Recovery._Run,,false,202,202,_Run,,,1,void leveldb._Test_Recovery._Run ()
4612,METHOD,leveldb._Test_Recovery,TYPE_DECL,"TEST(CorruptionTest, Recovery)",1,30,db\corruption_test.cc,leveldb._Test_Recovery._RunIt,,false,202,202,_RunIt,,,2,void leveldb._Test_Recovery._RunIt ()
4636,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, Recovery) {
  Build(100);
  Check(100, 100);
  Corrupt(kLogFile, 19, 1);      // WriteBatch tag for first record
  Corrupt(kLogFile, log::kBlockSize + 1000, 1);  // Somewhere in second block
  Reopen();

  // The 64 records in the first two log blocks are completely lost.
  Check(36, 36);
}",1,30,db\corruption_test.cc,leveldb._Test_Recovery._Run,,false,202,211,_Run,,,7,void leveldb._Test_Recovery._Run ()
4662,METHOD,leveldb._Test_RecoverWriteError,TYPE_DECL,void void ();,1,39,db\corruption_test.cc,leveldb._Test_RecoverWriteError._Run,,false,213,213,_Run,,,1,void leveldb._Test_RecoverWriteError._Run ()
4666,METHOD,leveldb._Test_RecoverWriteError,TYPE_DECL,"TEST(CorruptionTest, RecoverWriteError)",1,39,db\corruption_test.cc,leveldb._Test_RecoverWriteError._RunIt,,false,213,213,_RunIt,,,2,void leveldb._Test_RecoverWriteError._RunIt ()
4690,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, RecoverWriteError) {
  env_.writable_file_error_ = true;
  Status s = TryReopen();
  ASSERT_TRUE(!s.ok());
}",1,39,db\corruption_test.cc,leveldb._Test_RecoverWriteError._Run,,false,213,217,_Run,,,11,void leveldb._Test_RecoverWriteError._Run ()
4728,METHOD,leveldb._Test_NewFileErrorDuringWrite,TYPE_DECL,void void ();,1,45,db\corruption_test.cc,leveldb._Test_NewFileErrorDuringWrite._Run,,false,219,219,_Run,,,1,void leveldb._Test_NewFileErrorDuringWrite._Run ()
4732,METHOD,leveldb._Test_NewFileErrorDuringWrite,TYPE_DECL,"TEST(CorruptionTest, NewFileErrorDuringWrite)",1,45,db\corruption_test.cc,leveldb._Test_NewFileErrorDuringWrite._RunIt,,false,219,219,_RunIt,,,2,void leveldb._Test_NewFileErrorDuringWrite._RunIt ()
4756,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, NewFileErrorDuringWrite) {
  // Do enough writing to force minor compaction
  env_.writable_file_error_ = true;
  const int num = 3 + (Options().write_buffer_size / kValueSize);
  std::string value_storage;
  Status s;
  for (int i = 0; s.ok() && i < num; i++) {
    WriteBatch batch;
    batch.Put(""a"", Value(100, &value_storage));
    s = db_->Write(WriteOptions(), &batch);
  }
  ASSERT_TRUE(!s.ok());
  ASSERT_GE(env_.num_writable_file_errors_, 1);
  env_.writable_file_error_ = false;
  Reopen();
}",1,45,db\corruption_test.cc,leveldb._Test_NewFileErrorDuringWrite._Run,,false,219,234,_Run,,,15,void leveldb._Test_NewFileErrorDuringWrite._Run ()
4865,METHOD,leveldb._Test_TableFile,TYPE_DECL,void void ();,1,31,db\corruption_test.cc,leveldb._Test_TableFile._Run,,false,236,236,_Run,,,1,void leveldb._Test_TableFile._Run ()
4869,METHOD,leveldb._Test_TableFile,TYPE_DECL,"TEST(CorruptionTest, TableFile)",1,31,db\corruption_test.cc,leveldb._Test_TableFile._RunIt,,false,236,236,_RunIt,,,2,void leveldb._Test_TableFile._RunIt ()
4893,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, TableFile) {
  Build(100);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);
  dbi->TEST_CompactRange(1, NULL, NULL);

  Corrupt(kTableFile, 100, 1);
  Check(90, 99);
}",1,31,db\corruption_test.cc,leveldb._Test_TableFile._Run,,false,236,245,_Run,,,19,void leveldb._Test_TableFile._Run ()
4931,METHOD,leveldb._Test_TableFileRepair,TYPE_DECL,void void ();,1,37,db\corruption_test.cc,leveldb._Test_TableFileRepair._Run,,false,247,247,_Run,,,1,void leveldb._Test_TableFileRepair._Run ()
4935,METHOD,leveldb._Test_TableFileRepair,TYPE_DECL,"TEST(CorruptionTest, TableFileRepair)",1,37,db\corruption_test.cc,leveldb._Test_TableFileRepair._RunIt,,false,247,247,_RunIt,,,2,void leveldb._Test_TableFileRepair._RunIt ()
4959,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, TableFileRepair) {
  options_.block_size = 2 * kValueSize;  // Limit scope of corruption
  options_.paranoid_checks = true;
  Reopen();
  Build(100);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);
  dbi->TEST_CompactRange(1, NULL, NULL);

  Corrupt(kTableFile, 100, 1);
  RepairDB();
  Reopen();
  Check(95, 99);
}",1,37,db\corruption_test.cc,leveldb._Test_TableFileRepair._Run,,false,247,261,_Run,,,23,void leveldb._Test_TableFileRepair._Run ()
5012,METHOD,leveldb._Test_TableFileIndexData,TYPE_DECL,void void ();,1,40,db\corruption_test.cc,leveldb._Test_TableFileIndexData._Run,,false,263,263,_Run,,,1,void leveldb._Test_TableFileIndexData._Run ()
5016,METHOD,leveldb._Test_TableFileIndexData,TYPE_DECL,"TEST(CorruptionTest, TableFileIndexData)",1,40,db\corruption_test.cc,leveldb._Test_TableFileIndexData._RunIt,,false,263,263,_RunIt,,,2,void leveldb._Test_TableFileIndexData._RunIt ()
5040,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, TableFileIndexData) {
  Build(10000);  // Enough to build multiple Tables
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();

  Corrupt(kTableFile, -2000, 500);
  Reopen();
  Check(5000, 9999);
}",1,40,db\corruption_test.cc,leveldb._Test_TableFileIndexData._Run,,false,263,271,_Run,,,27,void leveldb._Test_TableFileIndexData._Run ()
5066,METHOD,leveldb._Test_MissingDescriptor,TYPE_DECL,void void ();,1,39,db\corruption_test.cc,leveldb._Test_MissingDescriptor._Run,,false,273,273,_Run,,,1,void leveldb._Test_MissingDescriptor._Run ()
5070,METHOD,leveldb._Test_MissingDescriptor,TYPE_DECL,"TEST(CorruptionTest, MissingDescriptor)",1,39,db\corruption_test.cc,leveldb._Test_MissingDescriptor._RunIt,,false,273,273,_RunIt,,,2,void leveldb._Test_MissingDescriptor._RunIt ()
5094,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, MissingDescriptor) {
  Build(1000);
  RepairDB();
  Reopen();
  Check(1000, 1000);
}",1,39,db\corruption_test.cc,leveldb._Test_MissingDescriptor._Run,,false,273,278,_Run,,,31,void leveldb._Test_MissingDescriptor._Run ()
5106,METHOD,leveldb._Test_SequenceNumberRecovery,TYPE_DECL,void void ();,1,44,db\corruption_test.cc,leveldb._Test_SequenceNumberRecovery._Run,,false,280,280,_Run,,,1,void leveldb._Test_SequenceNumberRecovery._Run ()
5110,METHOD,leveldb._Test_SequenceNumberRecovery,TYPE_DECL,"TEST(CorruptionTest, SequenceNumberRecovery)",1,44,db\corruption_test.cc,leveldb._Test_SequenceNumberRecovery._RunIt,,false,280,280,_RunIt,,,2,void leveldb._Test_SequenceNumberRecovery._RunIt ()
5134,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, SequenceNumberRecovery) {
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v3""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v4""));
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v5""));
  RepairDB();
  Reopen();
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v5"", v);
  // Write something.  If sequence number was not recovered properly,
  // it will be hidden by an earlier write.
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v6""));
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v6"", v);
  Reopen();
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""v6"", v);
}",1,44,db\corruption_test.cc,leveldb._Test_SequenceNumberRecovery._Run,,false,280,299,_Run,,,35,void leveldb._Test_SequenceNumberRecovery._Run ()
5377,METHOD,leveldb._Test_CorruptedDescriptor,TYPE_DECL,void void ();,1,41,db\corruption_test.cc,leveldb._Test_CorruptedDescriptor._Run,,false,301,301,_Run,,,1,void leveldb._Test_CorruptedDescriptor._Run ()
5381,METHOD,leveldb._Test_CorruptedDescriptor,TYPE_DECL,"TEST(CorruptionTest, CorruptedDescriptor)",1,41,db\corruption_test.cc,leveldb._Test_CorruptedDescriptor._RunIt,,false,301,301,_RunIt,,,2,void leveldb._Test_CorruptedDescriptor._RunIt ()
5405,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, CorruptedDescriptor) {
  ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""hello""));
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  dbi->TEST_CompactRange(0, NULL, NULL);

  Corrupt(kDescriptorFile, 0, 1000);
  Status s = TryReopen();
  ASSERT_TRUE(!s.ok());

  RepairDB();
  Reopen();
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v));
  ASSERT_EQ(""hello"", v);
}",1,41,db\corruption_test.cc,leveldb._Test_CorruptedDescriptor._Run,,false,301,316,_Run,,,39,void leveldb._Test_CorruptedDescriptor._Run ()
5520,METHOD,leveldb._Test_CompactionInputError,TYPE_DECL,void void ();,1,42,db\corruption_test.cc,leveldb._Test_CompactionInputError._Run,,false,318,318,_Run,,,1,void leveldb._Test_CompactionInputError._Run ()
5524,METHOD,leveldb._Test_CompactionInputError,TYPE_DECL,"TEST(CorruptionTest, CompactionInputError)",1,42,db\corruption_test.cc,leveldb._Test_CompactionInputError._RunIt,,false,318,318,_RunIt,,,2,void leveldb._Test_CompactionInputError._RunIt ()
5548,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, CompactionInputError) {
  Build(10);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(1, Property(""leveldb.num-files-at-level"" + NumberToString(last)));

  Corrupt(kTableFile, 100, 1);
  Check(5, 9);

  // Force compactions by writing lots of values
  Build(10000);
  Check(10000, 10000);
}",1,42,db\corruption_test.cc,leveldb._Test_CompactionInputError._Run,,false,318,331,_Run,,,43,void leveldb._Test_CompactionInputError._Run ()
5603,METHOD,leveldb._Test_CompactionInputErrorParanoid,TYPE_DECL,void void ();,1,50,db\corruption_test.cc,leveldb._Test_CompactionInputErrorParanoid._Run,,false,333,333,_Run,,,1,void leveldb._Test_CompactionInputErrorParanoid._Run ()
5607,METHOD,leveldb._Test_CompactionInputErrorParanoid,TYPE_DECL,"TEST(CorruptionTest, CompactionInputErrorParanoid)",1,50,db\corruption_test.cc,leveldb._Test_CompactionInputErrorParanoid._RunIt,,false,333,333,_RunIt,,,2,void leveldb._Test_CompactionInputErrorParanoid._RunIt ()
5631,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, CompactionInputErrorParanoid) {
  options_.paranoid_checks = true;
  options_.write_buffer_size = 512 << 10;
  Reopen();
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);

  // Make multiple inputs so we need to compact.
  for (int i = 0; i < 2; i++) {
    Build(10);
    dbi->TEST_CompactMemTable();
    Corrupt(kTableFile, 100, 1);
    env_.SleepForMicroseconds(100000);
  }
  dbi->CompactRange(NULL, NULL);

  // Write must fail because of corrupted table
  std::string tmp1, tmp2;
  Status s = db_->Put(WriteOptions(), Key(5, &tmp1), Value(5, &tmp2));
  ASSERT_TRUE(!s.ok()) << ""write did not fail in corrupted paranoid db"";
}",1,50,db\corruption_test.cc,leveldb._Test_CompactionInputErrorParanoid._Run,,false,333,352,_Run,,,47,void leveldb._Test_CompactionInputErrorParanoid._Run ()
5732,METHOD,leveldb._Test_UnrelatedKeys,TYPE_DECL,void void ();,1,35,db\corruption_test.cc,leveldb._Test_UnrelatedKeys._Run,,false,354,354,_Run,,,1,void leveldb._Test_UnrelatedKeys._Run ()
5736,METHOD,leveldb._Test_UnrelatedKeys,TYPE_DECL,"TEST(CorruptionTest, UnrelatedKeys)",1,35,db\corruption_test.cc,leveldb._Test_UnrelatedKeys._RunIt,,false,354,354,_RunIt,,,2,void leveldb._Test_UnrelatedKeys._RunIt ()
5760,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"TEST(CorruptionTest, UnrelatedKeys) {
  Build(10);
  DBImpl* dbi = reinterpret_cast<DBImpl*>(db_);
  dbi->TEST_CompactMemTable();
  Corrupt(kTableFile, 100, 1);

  std::string tmp1, tmp2;
  ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)));
  std::string v;
  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));
  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);
  dbi->TEST_CompactMemTable();
  ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v));
  ASSERT_EQ(Value(1000, &tmp2).ToString(), v);
}",1,35,db\corruption_test.cc,leveldb._Test_UnrelatedKeys._Run,,false,354,368,_Run,,,51,void leveldb._Test_UnrelatedKeys._Run ()
5905,METHOD,db\corruption_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\corruption_test.cc,main,,false,372,374,main,,,2,"int main (int,char**)"
5951,METHOD,db\db_bench.cc:<global>,TYPE_DECL,<global>,1,22,db\db_bench.cc,db\db_bench.cc:<global>,,false,1,1020,<global>,,,1,
6029,METHOD,leveldb.anonymous_namespace_1.RandomGenerator,TYPE_DECL,"RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator,,false,129,142,RandomGenerator,,,3,ANY leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator ()
6063,METHOD,leveldb.anonymous_namespace_1.RandomGenerator,TYPE_DECL,"Slice Generate(size_t len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_3.RandomGenerator.Generate,,false,144,151,Generate,,,4,Slice leveldb.anonymous_namespace_3.RandomGenerator.Generate (size_t)
6102,METHOD,db\db_bench.cc:<global>,TYPE_DECL,"static void AppendWithSpace(std::string* str, Slice msg) {
  if (msg.empty()) return;
  if (!str->empty()) {
    str->push_back(' ');
  }
  str->append(msg.data(), msg.size());
}",1,1,db\db_bench.cc,leveldb.anonymous_namespace_4.AppendWithSpace,,false,168,174,AppendWithSpace,,,4,"void leveldb.anonymous_namespace_4.AppendWithSpace (ANY*,Slice)"
6149,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,Stats() { Start(); },3,22,db\db_bench.cc,leveldb.anonymous_namespace_6.Stats.Stats,,false,189,189,Stats,,,10,ANY leveldb.anonymous_namespace_6.Stats.Stats ()
6154,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void Start() {
    next_report_ = 100;
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    bytes_ = 0;
    seconds_ = 0;
    start_ = g_env->NowMicros();
    finish_ = start_;
    message_.clear();
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_8.Stats.Start,,false,191,201,Start,,,11,void leveldb.anonymous_namespace_8.Stats.Start ()
6190,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void Merge(const Stats& other) {
    hist_.Merge(other.hist_);
    done_ += other.done_;
    bytes_ += other.bytes_;
    seconds_ += other.seconds_;
    if (other.start_ < start_) start_ = other.start_;
    if (other.finish_ > finish_) finish_ = other.finish_;

    // Just keep the messages from one thread
    if (message_.empty()) message_ = other.message_;
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_9.Stats.Merge,,false,203,213,Merge,,,12,void leveldb.anonymous_namespace_9.Stats.Merge (Stats)
6252,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void Stop() {
    finish_ = g_env->NowMicros();
    seconds_ = (finish_ - start_) * 1e-6;
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_10.Stats.Stop,,false,215,218,Stop,,,13,void leveldb.anonymous_namespace_10.Stats.Stop ()
6269,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void AddMessage(Slice msg) {
    AppendWithSpace(&message_, msg);
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_11.Stats.AddMessage,,false,220,222,AddMessage,,,14,void leveldb.anonymous_namespace_11.Stats.AddMessage (Slice)
6278,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = g_env->NowMicros();
      double micros = now - last_op_finish_;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_13.Stats.FinishedSingleOp,,false,224,248,FinishedSingleOp,,,15,void leveldb.anonymous_namespace_13.Stats.FinishedSingleOp ()
6393,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void AddBytes(int64_t n) {
    bytes_ += n;
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_14.Stats.AddBytes,,false,250,252,AddBytes,,,16,void leveldb.anonymous_namespace_14.Stats.AddBytes (int64_t)
6401,METHOD,leveldb.anonymous_namespace_5.Stats,TYPE_DECL,"void Report(const Slice& name) {
    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    std::string extra;
    if (bytes_ > 0) {
      // Rate is computed on actual elapsed time, not the sum of per-thread
      // elapsed times.
      double elapsed = (finish_ - start_) * 1e-6;
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / elapsed);
      extra = rate;
    }
    AppendWithSpace(&extra, message_);

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            seconds_ * 1e6 / done_,
            (extra.empty() ? """" : "" ""),
            extra.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_15.Stats.Report,,false,254,280,Report,,,17,void leveldb.anonymous_namespace_15.Stats.Report (Slice)
6493,METHOD,leveldb.anonymous_namespace_17.SharedState,TYPE_DECL,SharedState() : cv(&mu) { },3,29,db\db_bench.cc,leveldb.anonymous_namespace_18.SharedState.SharedState,,false,299,299,SharedState,,,7,ANY leveldb.anonymous_namespace_18.SharedState.SharedState ()
6502,METHOD,leveldb.anonymous_namespace_19.ThreadState,TYPE_DECL,"ThreadState(int index)
      : tid(index),
        rand(1000 + index) {
  }",3,3,db\db_bench.cc,leveldb.anonymous_namespace_20.ThreadState.ThreadState,,false,309,312,ThreadState,,,5,ANY leveldb.anonymous_namespace_20.ThreadState.ThreadState (int)
6517,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",3,3,db\db_bench.cc,leveldb.Benchmark.PrintHeader,,false,329,345,PrintHeader,,,10,void leveldb.Benchmark.PrintHeader ()
6573,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintWarnings() {
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif

    // See if snappy is working by attempting to compress a compressible string
    const char text[] = ""yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"";
    std::string compressed;
    if (!port::Snappy_Compress(text, sizeof(text), &compressed)) {
      fprintf(stdout, ""WARNING: Snappy compression is not enabled\n"");
    } else if (compressed.size() >= sizeof(text)) {
      fprintf(stdout, ""WARNING: Snappy compression is not effective\n"");
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.PrintWarnings,,false,347,366,PrintWarnings,,,11,void leveldb.Benchmark.PrintWarnings ()
6614,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintEnvironment() {
    fprintf(stderr, ""LevelDB:    version %d.%d\n"",
            kMajorVersion, kMinorVersion);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:       %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(stderr, ""CPU:        %d * %s\n"", num_cpus, cpu_type.c_str());
      f...",3,3,db\db_bench.cc,leveldb.Benchmark.PrintEnvironment,,false,368,401,PrintEnvironment,,,12,void leveldb.Benchmark.PrintEnvironment ()
6623,METHOD,leveldb.Benchmark,TYPE_DECL,"Benchmark()
  : cache_(FLAGS_cache_size >= 0 ? NewLRUCache(FLAGS_cache_size) : NULL),
    filter_policy_(FLAGS_bloom_bits >= 0
                   ? NewBloomFilterPolicy(FLAGS_bloom_bits)
                   : NULL),
    db_(NULL),
    num_(FLAGS_num),
    value_size_(FLAGS_value_size),
    entries_per_batch_(1),
    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),
    heap_counter_(0) {
    std::vector<std::string> files;
    g_env->GetChildren(FLAGS_db, &files);
    for (size_t i = 0; i < files.size(); i++) {
      if (Slice(files[i]).starts_with(""heap-"")) {
        g_env->DeleteFile(std::string(FLAGS_db) + ""/"" + files[i]);
      }
    }
    if (!FLAGS_use_existing_db) {
      DestroyDB(FLAGS_db, Options());
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.Benchmark,,false,404,425,Benchmark,,,13,ANY leveldb.Benchmark.Benchmark ()
6690,METHOD,leveldb.Benchmark,TYPE_DECL,"~Benchmark() {
    delete db_;
    delete cache_;
    delete filter_policy_;
  }",3,3,db\db_bench.cc,leveldb.Benchmark.~Benchmark,,false,427,431,~Benchmark,,,14,ANY leveldb.Benchmark.~Benchmark ()
6700,METHOD,leveldb.Benchmark,TYPE_DECL,"void Run() {
    PrintHeader();
    Open();

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      // Reset parameters that may be overridden below
      num_ = FLAGS_num;
      reads_ = (FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads);
      value_size_ = FLAGS_value_size;
      entries_per_batch_ = 1;
      write_options_ = WriteOptions();

      void (Benchmark::*method)(ThreadState*) = NULL;
      bool fresh_db = false;
      int num_threads = FLAGS_threads;

      if (name == Slice(""open"")) {
        method = &Benchmark::OpenBench;
        num_ /= 10000;
        if (num_ < 1) num_ = 1;
      } else if (name == Slice(""fillseq"")) {
        fresh_db = true;
        method = &Benchmark::WriteSeq;
      } els...",3,3,db\db_bench.cc,leveldb.Benchmark.Run,,false,433,548,Run,,,15,void leveldb.Benchmark.Run ()
6765,METHOD,leveldb.Benchmark,TYPE_DECL,void (Benchmark::*method)(ThreadState*) = NULL;,12,52,db\db_bench.cc,leveldb.Benchmark.Run.method,,false,456,456,method,,,10,void leveldb.Benchmark.Run.method (ThreadState*)
7228,METHOD,leveldb.Benchmark.ThreadArg,TYPE_DECL,void (Benchmark::*method)(ThreadState*);,10,43,db\db_bench.cc,leveldb.Benchmark.ThreadArg.method,,false,555,555,method,,,4,void leveldb.Benchmark.ThreadArg.method (ThreadState*)
7233,METHOD,leveldb.Benchmark,TYPE_DECL,"static void ThreadBody(void* v) {
    ThreadArg* arg = reinterpret_cast<ThreadArg*>(v);
    SharedState* shared = arg->shared;
    ThreadState* thread = arg->thread;
    {
      MutexLock l(&shared->mu);
      shared->num_initialized++;
      if (shared->num_initialized >= shared->total) {
        shared->cv.SignalAll();
      }
      while (!shared->start) {
        shared->cv.Wait();
      }
    }

    thread->stats.Start();
    (arg->bm->*(arg->method))(thread);
    thread->stats.Stop();

    {
      MutexLock l(&shared->mu);
      shared->num_done++;
      if (shared->num_done >= shared->total) {
        shared->cv.SignalAll();
      }
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ThreadBody,,false,558,584,ThreadBody,,,17,void leveldb.Benchmark.ThreadBody (void*)
7341,METHOD,leveldb.Benchmark,TYPE_DECL,"void RunBenchmark(int n, Slice name,
                    void (Benchmark::*method)(ThreadState*)) {
    SharedState shared;
    shared.total = n;
    shared.num_initialized = 0;
    shared.num_done = 0;
    shared.start = false;

    ThreadArg* arg = new ThreadArg[n];
    for (int i = 0; i < n; i++) {
      arg[i].bm = this;
      arg[i].method = method;
      arg[i].shared = &shared;
      arg[i].thread = new ThreadState(i);
      arg[i].thread->shared = &shared;
      g_env->StartThread(ThreadBody, &arg[i]);
    }

    shared.mu.Lock();
    while (shared.num_initialized < n) {
      shared.cv.Wait();
    }

    shared.start = true;
    shared.cv.SignalAll();
    while (shared.num_done < n) {
      shared.cv.Wait();
    }
    shared.mu.Unlock();

    for (int i = 1; i < n; i++) {
      arg[0].thread->stats.Merge(arg[i].thread->stats);
    }
    arg[0].thread->stats.Report(name);

    for (int i = 0; i < n; i++) {
      delete arg[i].thread;
    }
    delete[] arg;
  }",3,3,db\db_bench.cc,leveldb.Benchmark.RunBenchmark,,false,586,625,RunBenchmark,,,18,"void leveldb.Benchmark.RunBenchmark (int,Slice,void)"
7545,METHOD,leveldb.Benchmark,TYPE_DECL,"void Crc32c(ThreadState* thread) {
    // Checksum about 500MB of data total
    const int size = 4096;
    const char* label = ""(4K per op)"";
    std::string data(size, 'x');
    int64_t bytes = 0;
    uint32_t crc = 0;
    while (bytes < 500 * 1048576) {
      crc = crc32c::Value(data.data(), size);
      thread->stats.FinishedSingleOp();
      bytes += size;
    }
    // Print so result is not dead
    fprintf(stderr, ""... crc=0x%x\r"", static_cast<unsigned int>(crc));

    thread->stats.AddBytes(bytes);
    thread->stats.AddMessage(label);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.Crc32c,,false,627,644,Crc32c,,,19,void leveldb.Benchmark.Crc32c (ThreadState*)
7617,METHOD,leveldb.Benchmark,TYPE_DECL,"void AcquireLoad(ThreadState* thread) {
    int dummy;
    port::AtomicPointer ap(&dummy);
    int count = 0;
    void *ptr = NULL;
    thread->stats.AddMessage(""(each op is 1000 loads)"");
    while (count < 100000) {
      for (int i = 0; i < 1000; i++) {
        ptr = ap.Acquire_Load();
      }
      count++;
      thread->stats.FinishedSingleOp();
    }
    if (ptr == NULL) exit(1); // Disable unused variable warning.
  }",3,3,db\db_bench.cc,leveldb.Benchmark.AcquireLoad,,false,646,660,AcquireLoad,,,20,void leveldb.Benchmark.AcquireLoad (ThreadState*)
7680,METHOD,leveldb.Benchmark,TYPE_DECL,"void SnappyCompress(ThreadState* thread) {
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    int64_t bytes = 0;
    int64_t produced = 0;
    bool ok = true;
    std::string compressed;
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
      produced += compressed.size();
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""(output: %.1f%%)"",
               (produced * 100.0) / bytes);
      thread->stats.AddMessage(buf);
      thread->stats.AddBytes(bytes);
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.SnappyCompress,,false,662,685,SnappyCompress,,,21,void leveldb.Benchmark.SnappyCompress (ThreadState*)
7790,METHOD,leveldb.Benchmark,TYPE_DECL,"void SnappyUncompress(ThreadState* thread) {
    RandomGenerator gen;
    Slice input = gen.Generate(Options().block_size);
    std::string compressed;
    bool ok = port::Snappy_Compress(input.data(), input.size(), &compressed);
    int64_t bytes = 0;
    char* uncompressed = new char[input.size()];
    while (ok && bytes < 1024 * 1048576) {  // Compress 1G
      ok =  port::Snappy_Uncompress(compressed.data(), compressed.size(),
                                    uncompressed);
      bytes += input.size();
      thread->stats.FinishedSingleOp();
    }
    delete[] uncompressed;

    if (!ok) {
      thread->stats.AddMessage(""(snappy failure)"");
    } else {
      thread->stats.AddBytes(bytes);
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.SnappyUncompress,,false,687,707,SnappyUncompress,,,22,void leveldb.Benchmark.SnappyUncompress (ThreadState*)
7891,METHOD,leveldb.Benchmark,TYPE_DECL,"void Open() {
    assert(db_ == NULL);
    Options options;
    options.env = g_env;
    options.create_if_missing = !FLAGS_use_existing_db;
    options.block_cache = cache_;
    options.write_buffer_size = FLAGS_write_buffer_size;
    options.max_file_size = FLAGS_max_file_size;
    options.block_size = FLAGS_block_size;
    options.max_open_files = FLAGS_open_files;
    options.filter_policy = filter_policy_;
    options.reuse_logs = FLAGS_reuse_logs;
    Status s = DB::Open(options, FLAGS_db, &db_);
    if (!s.ok()) {
      fprintf(stderr, ""open error: %s\n"", s.ToString().c_str());
      exit(1);
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.Open,,false,709,726,Open,,,23,void leveldb.Benchmark.Open ()
7976,METHOD,leveldb.Benchmark,TYPE_DECL,"void OpenBench(ThreadState* thread) {
    for (int i = 0; i < num_; i++) {
      delete db_;
      Open();
      thread->stats.FinishedSingleOp();
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.OpenBench,,false,728,734,OpenBench,,,24,void leveldb.Benchmark.OpenBench (ThreadState*)
8002,METHOD,leveldb.Benchmark,TYPE_DECL,"void WriteSeq(ThreadState* thread) {
    DoWrite(thread, true);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.WriteSeq,,false,736,738,WriteSeq,,,25,void leveldb.Benchmark.WriteSeq (ThreadState*)
8010,METHOD,leveldb.Benchmark,TYPE_DECL,"void WriteRandom(ThreadState* thread) {
    DoWrite(thread, false);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.WriteRandom,,false,740,742,WriteRandom,,,26,void leveldb.Benchmark.WriteRandom (ThreadState*)
8018,METHOD,leveldb.Benchmark,TYPE_DECL,"void DoWrite(ThreadState* thread, bool seq) {
    if (num_ != FLAGS_num) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_);
      thread->stats.AddMessage(msg);
    }

    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    int64_t bytes = 0;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Put(key, gen.Generate(value_size_));
        bytes += value_size_ + strlen(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
    thread->stats.AddBytes(bytes);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.DoWrite,,false,744,772,DoWrite,,,27,"void leveldb.Benchmark.DoWrite (ThreadState*,bool)"
8159,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadSequential(ThreadState* thread) {
    Iterator* iter = db_->NewIterator(ReadOptions());
    int i = 0;
    int64_t bytes = 0;
    for (iter->SeekToFirst(); i < reads_ && iter->Valid(); iter->Next()) {
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }
    delete iter;
    thread->stats.AddBytes(bytes);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ReadSequential,,false,774,785,ReadSequential,,,28,void leveldb.Benchmark.ReadSequential (ThreadState*)
8233,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadReverse(ThreadState* thread) {
    Iterator* iter = db_->NewIterator(ReadOptions());
    int i = 0;
    int64_t bytes = 0;
    for (iter->SeekToLast(); i < reads_ && iter->Valid(); iter->Prev()) {
      bytes += iter->key().size() + iter->value().size();
      thread->stats.FinishedSingleOp();
      ++i;
    }
    delete iter;
    thread->stats.AddBytes(bytes);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ReadReverse,,false,787,798,ReadReverse,,,29,void leveldb.Benchmark.ReadReverse (ThreadState*)
8307,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadRandom(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    int found = 0;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      if (db_->Get(options, key, &value).ok()) {
        found++;
      }
      thread->stats.FinishedSingleOp();
    }
    char msg[100];
    snprintf(msg, sizeof(msg), ""(%d of %d found)"", found, num_);
    thread->stats.AddMessage(msg);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ReadRandom,,false,800,816,ReadRandom,,,30,void leveldb.Benchmark.ReadRandom (ThreadState*)
8384,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadMissing(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d."", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ReadMissing,,false,818,828,ReadMissing,,,31,void leveldb.Benchmark.ReadMissing (ThreadState*)
8435,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadHot(ThreadState* thread) {
    ReadOptions options;
    std::string value;
    const int range = (FLAGS_num + 99) / 100;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = thread->rand.Next() % range;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->Get(options, key, &value);
      thread->stats.FinishedSingleOp();
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ReadHot,,false,830,841,ReadHot,,,32,void leveldb.Benchmark.ReadHot (ThreadState*)
8494,METHOD,leveldb.Benchmark,TYPE_DECL,"void SeekRandom(ThreadState* thread) {
    ReadOptions options;
    int found = 0;
    for (int i = 0; i < reads_; i++) {
      Iterator* iter = db_->NewIterator(options);
      char key[100];
      const int k = thread->rand.Next() % FLAGS_num;
      snprintf(key, sizeof(key), ""%016d"", k);
      iter->Seek(key);
      if (iter->Valid() && iter->key() == key) found++;
      delete iter;
      thread->stats.FinishedSingleOp();
    }
    char msg[100];
    snprintf(msg, sizeof(msg), ""(%d of %d found)"", found, num_);
    thread->stats.AddMessage(msg);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.SeekRandom,,false,843,859,SeekRandom,,,33,void leveldb.Benchmark.SeekRandom (ThreadState*)
8585,METHOD,leveldb.Benchmark,TYPE_DECL,"void DoDelete(ThreadState* thread, bool seq) {
    RandomGenerator gen;
    WriteBatch batch;
    Status s;
    for (int i = 0; i < num_; i += entries_per_batch_) {
      batch.Clear();
      for (int j = 0; j < entries_per_batch_; j++) {
        const int k = seq ? i+j : (thread->rand.Next() % FLAGS_num);
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        batch.Delete(key);
        thread->stats.FinishedSingleOp();
      }
      s = db_->Write(write_options_, &batch);
      if (!s.ok()) {
        fprintf(stderr, ""del error: %s\n"", s.ToString().c_str());
        exit(1);
      }
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.DoDelete,,false,861,880,DoDelete,,,34,"void leveldb.Benchmark.DoDelete (ThreadState*,bool)"
8685,METHOD,leveldb.Benchmark,TYPE_DECL,"void DeleteSeq(ThreadState* thread) {
    DoDelete(thread, true);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.DeleteSeq,,false,882,884,DeleteSeq,,,35,void leveldb.Benchmark.DeleteSeq (ThreadState*)
8693,METHOD,leveldb.Benchmark,TYPE_DECL,"void DeleteRandom(ThreadState* thread) {
    DoDelete(thread, false);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.DeleteRandom,,false,886,888,DeleteRandom,,,36,void leveldb.Benchmark.DeleteRandom (ThreadState*)
8701,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadWhileWriting(ThreadState* thread) {
    if (thread->tid > 0) {
      ReadRandom(thread);
    } else {
      // Special thread that keeps writing until other threads are done.
      RandomGenerator gen;
      while (true) {
        {
          MutexLock l(&thread->shared->mu);
          if (thread->shared->num_done + 1 >= thread->shared->num_initialized) {
            // Other threads have finished
            break;
          }
        }

        const int k = thread->rand.Next() % FLAGS_num;
        char key[100];
        snprintf(key, sizeof(key), ""%016d"", k);
        Status s = db_->Put(write_options_, key, gen.Generate(value_size_));
        if (!s.ok()) {
          fprintf(stderr, ""put error: %s\n"", s.ToString().c_str());
          exit(1);
        }
      }

      // Do not count any of the preceding work/delay in stats.
      thread->stats.Start();
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.ReadWhileWriting,,false,890,918,ReadWhileWriting,,,37,void leveldb.Benchmark.ReadWhileWriting (ThreadState*)
8803,METHOD,leveldb.Benchmark,TYPE_DECL,"void Compact(ThreadState* thread) {
    db_->CompactRange(NULL, NULL);
  }",3,3,db\db_bench.cc,leveldb.Benchmark.Compact,,false,920,922,Compact,,,38,void leveldb.Benchmark.Compact (ThreadState*)
8814,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintStats(const char* key) {
    std::string stats;
    if (!db_->GetProperty(key, &stats)) {
      stats = ""(failed)"";
    }
    fprintf(stdout, ""\n%s\n"", stats.c_str());
  }",3,3,db\db_bench.cc,leveldb.Benchmark.PrintStats,,false,924,930,PrintStats,,,39,void leveldb.Benchmark.PrintStats (char*)
8840,METHOD,leveldb.Benchmark,TYPE_DECL,"static void WriteToFile(void* arg, const char* buf, int n) {
    reinterpret_cast<WritableFile*>(arg)->Append(Slice(buf, n));
  }",3,3,db\db_bench.cc,leveldb.Benchmark.WriteToFile,,false,932,934,WriteToFile,,,40,"void leveldb.Benchmark.WriteToFile (void*,char*,int)"
8856,METHOD,leveldb.Benchmark,TYPE_DECL,"void HeapProfile() {
    char fname[100];
    snprintf(fname, sizeof(fname), ""%s/heap-%04d"", FLAGS_db, ++heap_counter_);
    WritableFile* file;
    Status s = g_env->NewWritableFile(fname, &file);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      return;
    }
    bool ok = port::GetHeapProfile(WriteToFile, file);
    delete file;
    if (!ok) {
      fprintf(stderr, ""heap profiling not supported\n"");
      g_env->DeleteFile(fname);
    }
  }",3,3,db\db_bench.cc,leveldb.Benchmark.HeapProfile,,false,936,951,HeapProfile,,,41,void leveldb.Benchmark.HeapProfile ()
8921,METHOD,db\db_bench.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;
  FLAGS_max_file_size = leveldb::Options().max_file_size;
  FLAGS_block_size = leveldb::Options().block_size;
  FLAGS_open_files = leveldb::Options().max_open_files;
  std::string default_db_path;

  for (int i = 1; i < argc; i++) {
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--use_existing_db=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_use_existing_db = n;
    } else if (sscanf(argv[i], ""--reuse_logs=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) ...",1,1,db\db_bench.cc,main,,false,956,1020,main,,,34,"int main (int,char**)"
9401,METHOD,db\db_impl.cc:<global>,TYPE_DECL,<global>,1,1,db\db_impl.cc,db\db_impl.cc:<global>,,false,1,1568,<global>,,,1,
9414,METHOD,leveldb.Writer,TYPE_DECL,explicit Writer(port::Mutex* mu) : cv(mu) { },3,47,db\db_impl.cc,leveldb.Writer.Writer,,false,48,48,Writer,,,6,ANY leveldb.Writer.Writer (ANY*)
9431,METHOD,leveldb.CompactionState,TYPE_DECL,Output* current_output() { return &outputs[outputs.size()-1]; },3,65,db\db_impl.cc,leveldb.CompactionState.current_output,,false,74,74,current_output,,,8,Output leveldb.CompactionState.current_output ()
9445,METHOD,leveldb.CompactionState,TYPE_DECL,"explicit CompactionState(Compaction* c)
      : compaction(c),
        outfile(NULL),
        builder(NULL),
        total_bytes(0) {
  }",3,3,db\db_impl.cc,leveldb.CompactionState.CompactionState,,false,76,81,CompactionState,,,9,ANY leveldb.CompactionState.CompactionState (Compaction*)
9450,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"static void ClipToRange(T* ptr, V minvalue, V maxvalue) {
  if (static_cast<V>(*ptr) > maxvalue) *ptr = maxvalue;
  if (static_cast<V>(*ptr) < minvalue) *ptr = minvalue;
}",1,1,db\db_impl.cc,leveldb.ClipToRange,,false,86,89,ClipToRange,,,5,"void leveldb.ClipToRange<T,V> (T*,V,V)"
9481,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Options SanitizeOptions(const std::string& dbname,
                        const InternalKeyComparator* icmp,
                        const InternalFilterPolicy* ipolicy,
                        const Options& src) {
  Options result = src;
  result.comparator = icmp;
  result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;
  ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);
  ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);
  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);
  ClipToRange(&result.block_size,        1<<10,                       4<<20);
  if (result.info_log == NULL) {
    // Open a log file in the same directory as the db
    src.env->CreateDir(dbname);  // In case it does not exist
    src.env->RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    Status s = src.env->NewLogger(InfoLogFileName(dbname), &result.info_log);
    if (!s.ok()) {
      // No place su...",1,1,db\db_impl.cc,leveldb.SanitizeOptions,,false,90,115,SanitizeOptions,,,6,"Options leveldb.SanitizeOptions (ANY,InternalKeyComparator*,InternalFilterPolicy*,Options)"
9620,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)
    : env_(raw_options.env),
      internal_comparator_(raw_options.comparator),
      internal_filter_policy_(raw_options.filter_policy),
      options_(SanitizeOptions(dbname, &internal_comparator_,
                               &internal_filter_policy_, raw_options)),
      owns_info_log_(options_.info_log != raw_options.info_log),
      owns_cache_(options_.block_cache != raw_options.block_cache),
      dbname_(dbname),
      db_lock_(NULL),
      shutting_down_(NULL),
      bg_cv_(&mutex_),
      mem_(NULL),
      imm_(NULL),
      logfile_(NULL),
      logfile_number_(0),
      log_(NULL),
      seed_(0),
      tmp_batch_(new WriteBatch),
      bg_compaction_scheduled_(false),
      manual_compaction_(NULL) {
  has_imm_.Release_Store(NULL);

  // Reserve ten files or so for other uses and give the rest to TableCache.
  const int table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;
  table_ca...",1,1,db\db_impl.cc,leveldb.DBImpl.DBImpl,,false,117,146,DBImpl,,,7,"ANY leveldb.DBImpl.DBImpl (Options,ANY)"
9657,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"DBImpl::~DBImpl() {
  // Wait for background work to finish
  mutex_.Lock();
  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
  while (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  if (db_lock_ != NULL) {
    env_->UnlockFile(db_lock_);
  }

  delete versions_;
  if (mem_ != NULL) mem_->Unref();
  if (imm_ != NULL) imm_->Unref();
  delete tmp_batch_;
  delete log_;
  delete logfile_;
  delete table_cache_;

  if (owns_info_log_) {
    delete options_.info_log;
  }
  if (owns_cache_) {
    delete options_.block_cache;
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.~DBImpl,,false,148,175,~DBImpl,,,8,ANY leveldb.DBImpl.~DBImpl ()
9733,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::NewDB() {
  VersionEdit new_db;
  new_db.SetComparatorName(user_comparator()->Name());
  new_db.SetLogNumber(0);
  new_db.SetNextFile(2);
  new_db.SetLastSequence(0);

  const std::string manifest = DescriptorFileName(dbname_, 1);
  WritableFile* file;
  Status s = env_->NewWritableFile(manifest, &file);
  if (!s.ok()) {
    return s;
  }
  {
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file->Close();
    }
  }
  delete file;
  if (s.ok()) {
    // Make ""CURRENT"" file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  } else {
    env_->DeleteFile(manifest);
  }
  return s;
}",1,1,db\db_impl.cc,leveldb.DBImpl.NewDB,,false,177,207,NewDB,,,9,Status leveldb.DBImpl.NewDB ()
9840,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::MaybeIgnoreError(Status* s) const {
  if (s->ok() || options_.paranoid_checks) {
    // No change needed
  } else {
    Log(options_.info_log, ""Ignoring error %s"", s->ToString().c_str());
    *s = Status::OK();
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.MaybeIgnoreError,,false,209,216,MaybeIgnoreError,,,10,void leveldb.DBImpl.MaybeIgnoreError (Status*)
9876,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::DeleteObsoleteFiles() {
  if (!bg_error_.ok()) {
    // After a background error, we don't know whether a new version may
    // or may not have been committed, so we cannot safely garbage collect.
    return;
  }

  // Make a set of all of the live files
  std::set<uint64_t> live = pending_outputs_;
  versions_->AddLiveFiles(&live);

  std::vector<std::string> filenames;
  env_->GetChildren(dbname_, &filenames); // Ignoring errors on purpose
  uint64_t number;
  FileType type;
  for (size_t i = 0; i < filenames.size(); i++) {
    if (ParseFileName(filenames[i], &number, &type)) {
      bool keep = true;
      switch (type) {
        case kLogFile:
          keep = ((number >= versions_->LogNumber()) ||
                  (number == versions_->PrevLogNumber()));
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number >= ver...",1,1,db\db_impl.cc,leveldb.DBImpl.DeleteObsoleteFiles,,false,218,272,DeleteObsoleteFiles,,,11,void leveldb.DBImpl.DeleteObsoleteFiles ()
10058,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::Recover(VersionEdit* edit, bool *save_manifest) {
  mutex_.AssertHeld();

  // Ignore error from CreateDir since the creation of the DB is
  // committed only when the descriptor is created, and this directory
  // may already exist from a previous failed creation attempt.
  env_->CreateDir(dbname_);
  assert(db_lock_ == NULL);
  Status s = env_->LockFile(LockFileName(dbname_), &db_lock_);
  if (!s.ok()) {
    return s;
  }

  if (!env_->FileExists(CurrentFileName(dbname_))) {
    if (options_.create_if_missing) {
      s = NewDB();
      if (!s.ok()) {
        return s;
      }
    } else {
      return Status::InvalidArgument(
          dbname_, ""does not exist (create_if_missing is false)"");
    }
  } else {
    if (options_.error_if_exists) {
      return Status::InvalidArgument(
          dbname_, ""exists (error_if_exists is true)"");
    }
  }

  s = versions_->Recover(save_manifest);
  if (!s.ok()) {
    return s;
  }
  SequenceNumber max_sequence(0);

  // Reco...",1,1,db\db_impl.cc,leveldb.DBImpl.Recover,,false,274,363,Recover,,,12,"Status leveldb.DBImpl.Recover (VersionEdit*,bool*)"
10387,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::RecoverLogFile(uint64_t log_number, bool last_log,
                              bool* save_manifest, VersionEdit* edit,
                              SequenceNumber* max_sequence) {
  struct LogReporter : public log::Reader::Reporter {
    Env* env;
    Logger* info_log;
    const char* fname;
    Status* status;  // NULL if options_.paranoid_checks==false
    virtual void Corruption(size_t bytes, const Status& s) {
      Log(info_log, ""%s%s: dropping %d bytes; %s"",
          (this->status == NULL ? ""(ignoring error) "" : """"),
          fname, static_cast<int>(bytes), s.ToString().c_str());
      if (this->status != NULL && this->status->ok()) *this->status = s;
    }
  };

  mutex_.AssertHeld();

  // Open the log file
  std::string fname = LogFileName(dbname_, log_number);
  SequentialFile* file;
  Status status = env_->NewSequentialFile(fname, &file);
  if (!status.ok()) {
    MaybeIgnoreError(&status);
    return status;
  }

  // Create the log reader.
  LogRepor...",1,1,db\db_impl.cc,leveldb.DBImpl.RecoverLogFile,,false,365,486,RecoverLogFile,,,13,"Status leveldb.DBImpl.RecoverLogFile (uint64_t,bool,bool*,VersionEdit*,SequenceNumber*)"
10751,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
                                Version* base) {
  mutex_.AssertHeld();
  const uint64_t start_micros = env_->NowMicros();
  FileMetaData meta;
  meta.number = versions_->NewFileNumber();
  pending_outputs_.insert(meta.number);
  Iterator* iter = mem->NewIterator();
  Log(options_.info_log, ""Level-0 table #%llu: started"",
      (unsigned long long) meta.number);

  Status s;
  {
    mutex_.Unlock();
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &meta);
    mutex_.Lock();
  }

  Log(options_.info_log, ""Level-0 table #%llu: %lld bytes %s"",
      (unsigned long long) meta.number,
      (unsigned long long) meta.file_size,
      s.ToString().c_str());
  delete iter;
  pending_outputs_.erase(meta.number);


  // Note that if file_size is zero, the file has been deleted and
  // should not be added to the manifest.
  int level = 0;
  if (s.ok() && meta.file_size > 0) {
    const Slice min_user_key = meta.s...",1,1,db\db_impl.cc,leveldb.DBImpl.WriteLevel0Table,,false,488,532,WriteLevel0Table,,,14,"Status leveldb.DBImpl.WriteLevel0Table (MemTable*,VersionEdit*,Version*)"
10944,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::CompactMemTable() {
  mutex_.AssertHeld();
  assert(imm_ != NULL);

  // Save the contents of the memtable as a new Table
  VersionEdit edit;
  Version* base = versions_->current();
  base->Ref();
  Status s = WriteLevel0Table(imm_, &edit, base);
  base->Unref();

  if (s.ok() && shutting_down_.Acquire_Load()) {
    s = Status::IOError(""Deleting DB during memtable compaction"");
  }

  // Replace immutable memtable with the generated Table
  if (s.ok()) {
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
    s = versions_->LogAndApply(&edit, &mutex_);
  }

  if (s.ok()) {
    // Commit to the new state
    imm_->Unref();
    imm_ = NULL;
    has_imm_.Release_Store(NULL);
    DeleteObsoleteFiles();
  } else {
    RecordBackgroundError(s);
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.CompactMemTable,,false,534,565,CompactMemTable,,,15,void leveldb.DBImpl.CompactMemTable ()
11047,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::CompactRange(const Slice* begin, const Slice* end) {
  int max_level_with_files = 1;
  {
    MutexLock l(&mutex_);
    Version* base = versions_->current();
    for (int level = 1; level < config::kNumLevels; level++) {
      if (base->OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap
  for (int level = 0; level < max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.CompactRange,,false,567,582,CompactRange,,,16,"void leveldb.DBImpl.CompactRange (Slice*,Slice*)"
11112,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {
  assert(level >= 0);
  assert(level + 1 < config::kNumLevels);

  InternalKey begin_storage, end_storage;

  ManualCompaction manual;
  manual.level = level;
  manual.done = false;
  if (begin == NULL) {
    manual.begin = NULL;
  } else {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &begin_storage;
  }
  if (end == NULL) {
    manual.end = NULL;
  } else {
    end_storage = InternalKey(*end, 0, static_cast<ValueType>(0));
    manual.end = &end_storage;
  }

  MutexLock l(&mutex_);
  while (!manual.done && !shutting_down_.Acquire_Load() && bg_error_.ok()) {
    if (manual_compaction_ == NULL) {  // Idle
      manual_compaction_ = &manual;
      MaybeScheduleCompaction();
    } else {  // Running either my compaction or another compaction.
      bg_cv_.Wait();
    }
  }
  if (manual_compaction_ == &manual) {
    // Cancel my manual compaction since w...",1,1,db\db_impl.cc,leveldb.DBImpl.TEST_CompactRange,,false,584,619,TEST_CompactRange,,,17,"void leveldb.DBImpl.TEST_CompactRange (int,Slice*,Slice*)"
11242,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::TEST_CompactMemTable() {
  // NULL batch means just wait for earlier writes to be done
  Status s = Write(WriteOptions(), NULL);
  if (s.ok()) {
    // Wait until the compaction completes
    MutexLock l(&mutex_);
    while (imm_ != NULL && bg_error_.ok()) {
      bg_cv_.Wait();
    }
    if (imm_ != NULL) {
      s = bg_error_;
    }
  }
  return s;
}",1,1,db\db_impl.cc,leveldb.DBImpl.TEST_CompactMemTable,,false,621,635,TEST_CompactMemTable,,,18,Status leveldb.DBImpl.TEST_CompactMemTable ()
11286,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::RecordBackgroundError(const Status& s) {
  mutex_.AssertHeld();
  if (bg_error_.ok()) {
    bg_error_ = s;
    bg_cv_.SignalAll();
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.RecordBackgroundError,,false,637,643,RecordBackgroundError,,,19,void leveldb.DBImpl.RecordBackgroundError (Status)
11308,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::MaybeScheduleCompaction() {
  mutex_.AssertHeld();
  if (bg_compaction_scheduled_) {
    // Already scheduled
  } else if (shutting_down_.Acquire_Load()) {
    // DB is being deleted; no more background compactions
  } else if (!bg_error_.ok()) {
    // Already got an error; no more changes
  } else if (imm_ == NULL &&
             manual_compaction_ == NULL &&
             !versions_->NeedsCompaction()) {
    // No work to be done
  } else {
    bg_compaction_scheduled_ = true;
    env_->Schedule(&DBImpl::BGWork, this);
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.MaybeScheduleCompaction,,false,645,661,MaybeScheduleCompaction,,,20,void leveldb.DBImpl.MaybeScheduleCompaction ()
11367,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::BGWork(void* db) {
  reinterpret_cast<DBImpl*>(db)->BackgroundCall();
}",1,1,db\db_impl.cc,leveldb.DBImpl.BGWork,,false,663,665,BGWork,,,21,void leveldb.DBImpl.BGWork (void*)
11378,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::BackgroundCall() {
  MutexLock l(&mutex_);
  assert(bg_compaction_scheduled_);
  if (shutting_down_.Acquire_Load()) {
    // No more background work when shutting down.
  } else if (!bg_error_.ok()) {
    // No more background work after a background error.
  } else {
    BackgroundCompaction();
  }

  bg_compaction_scheduled_ = false;

  // Previous compaction may have produced too many files in a level,
  // so reschedule another compaction if needed.
  MaybeScheduleCompaction();
  bg_cv_.SignalAll();
}",1,1,db\db_impl.cc,leveldb.DBImpl.BackgroundCall,,false,667,684,BackgroundCall,,,22,void leveldb.DBImpl.BackgroundCall ()
11414,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::BackgroundCompaction() {
  mutex_.AssertHeld();

  if (imm_ != NULL) {
    CompactMemTable();
    return;
  }

  Compaction* c;
  bool is_manual = (manual_compaction_ != NULL);
  InternalKey manual_end;
  if (is_manual) {
    ManualCompaction* m = manual_compaction_;
    c = versions_->CompactRange(m->level, m->begin, m->end);
    m->done = (c == NULL);
    if (c != NULL) {
      manual_end = c->input(0, c->num_input_files(0) - 1)->largest;
    }
    Log(options_.info_log,
        ""Manual compaction at level-%d from %s .. %s; will stop at %s\n"",
        m->level,
        (m->begin ? m->begin->DebugString().c_str() : ""(begin)""),
        (m->end ? m->end->DebugString().c_str() : ""(end)""),
        (m->done ? ""(end)"" : manual_end.DebugString().c_str()));
  } else {
    c = versions_->PickCompaction();
  }

  Status status;
  if (c == NULL) {
    // Nothing to do
  } else if (!is_manual && c->IsTrivialMove()) {
    // Move file to next level
    assert(c->num_input_files(0) ...",1,1,db\db_impl.cc,leveldb.DBImpl.BackgroundCompaction,,false,686,769,BackgroundCompaction,,,23,void leveldb.DBImpl.BackgroundCompaction ()
11771,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::CleanupCompaction(CompactionState* compact) {
  mutex_.AssertHeld();
  if (compact->builder != NULL) {
    // May happen if we get a shutdown call in the middle of compaction
    compact->builder->Abandon();
    delete compact->builder;
  } else {
    assert(compact->outfile == NULL);
  }
  delete compact->outfile;
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    pending_outputs_.erase(out.number);
  }
  delete compact;
}",1,1,db\db_impl.cc,leveldb.DBImpl.CleanupCompaction,,false,771,786,CleanupCompaction,,,24,void leveldb.DBImpl.CleanupCompaction (CompactionState*)
11843,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {
  assert(compact != NULL);
  assert(compact->builder == NULL);
  uint64_t file_number;
  {
    mutex_.Lock();
    file_number = versions_->NewFileNumber();
    pending_outputs_.insert(file_number);
    CompactionState::Output out;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact->outputs.push_back(out);
    mutex_.Unlock();
  }

  // Make the output file
  std::string fname = TableFileName(dbname_, file_number);
  Status s = env_->NewWritableFile(fname, &compact->outfile);
  if (s.ok()) {
    compact->builder = new TableBuilder(options_, compact->outfile);
  }
  return s;
}",1,1,db\db_impl.cc,leveldb.DBImpl.OpenCompactionOutputFile,,false,788,811,OpenCompactionOutputFile,,,25,Status leveldb.DBImpl.OpenCompactionOutputFile (CompactionState*)
11940,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
                                          Iterator* input) {
  assert(compact != NULL);
  assert(compact->outfile != NULL);
  assert(compact->builder != NULL);

  const uint64_t output_number = compact->current_output()->number;
  assert(output_number != 0);

  // Check for iterator errors
  Status s = input->status();
  const uint64_t current_entries = compact->builder->NumEntries();
  if (s.ok()) {
    s = compact->builder->Finish();
  } else {
    compact->builder->Abandon();
  }
  const uint64_t current_bytes = compact->builder->FileSize();
  compact->current_output()->file_size = current_bytes;
  compact->total_bytes += current_bytes;
  delete compact->builder;
  compact->builder = NULL;

  // Finish and check for file errors
  if (s.ok()) {
    s = compact->outfile->Sync();
  }
  if (s.ok()) {
    s = compact->outfile->Close();
  }
  delete compact->outfile;
  compact->outfile = NULL;

  if (s.ok() && current_...",1,1,db\db_impl.cc,leveldb.DBImpl.FinishCompactionOutputFile,,false,813,863,FinishCompactionOutputFile,,,26,"Status leveldb.DBImpl.FinishCompactionOutputFile (CompactionState*,Iterator*)"
12137,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::InstallCompactionResults(CompactionState* compact) {
  mutex_.AssertHeld();
  Log(options_.info_log,  ""Compacted %d@%d + %d@%d files => %lld bytes"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1,
      static_cast<long long>(compact->total_bytes));

  // Add compaction outputs
  compact->compaction->AddInputDeletions(compact->compaction->edit());
  const int level = compact->compaction->level();
  for (size_t i = 0; i < compact->outputs.size(); i++) {
    const CompactionState::Output& out = compact->outputs[i];
    compact->compaction->edit()->AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
  }
  return versions_->LogAndApply(compact->compaction->edit(), &mutex_);
}",1,1,db\db_impl.cc,leveldb.DBImpl.InstallCompactionResults,,false,866,885,InstallCompactionResults,,,27,Status leveldb.DBImpl.InstallCompactionResults (CompactionState*)
12267,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::DoCompactionWork(CompactionState* compact) {
  const uint64_t start_micros = env_->NowMicros();
  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions

  Log(options_.info_log,  ""Compacting %d@%d + %d@%d files"",
      compact->compaction->num_input_files(0),
      compact->compaction->level(),
      compact->compaction->num_input_files(1),
      compact->compaction->level() + 1);

  assert(versions_->NumLevelFiles(compact->compaction->level()) > 0);
  assert(compact->builder == NULL);
  assert(compact->outfile == NULL);
  if (snapshots_.empty()) {
    compact->smallest_snapshot = versions_->LastSequence();
  } else {
    compact->smallest_snapshot = snapshots_.oldest()->number_;
  }

  // Release mutex while we're actually doing the compaction work
  mutex_.Unlock();

  Iterator* input = versions_->MakeInputIterator(compact->compaction);
  input->SeekToFirst();
  Status status;
  ParsedInternalKey ikey;
  std::string current_user_key;
  bool has_current_use...",1,1,db\db_impl.cc,leveldb.DBImpl.DoCompactionWork,,false,887,1046,DoCompactionWork,,,28,Status leveldb.DBImpl.DoCompactionWork (CompactionState*)
12881,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"static void CleanupIteratorState(void* arg1, void* arg2) {
  IterState* state = reinterpret_cast<IterState*>(arg1);
  state->mu->Lock();
  state->mem->Unref();
  if (state->imm != NULL) state->imm->Unref();
  state->version->Unref();
  state->mu->Unlock();
  delete state;
}",1,1,db\db_impl.cc,leveldb.anonymous_namespace_2.CleanupIteratorState,,false,1056,1064,CleanupIteratorState,,,2,"void leveldb.anonymous_namespace_2.CleanupIteratorState (void*,void*)"
12932,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,
                                      SequenceNumber* latest_snapshot,
                                      uint32_t* seed) {
  IterState* cleanup = new IterState;
  mutex_.Lock();
  *latest_snapshot = versions_->LastSequence();

  // Collect together all needed child iterators
  std::vector<Iterator*> list;
  list.push_back(mem_->NewIterator());
  mem_->Ref();
  if (imm_ != NULL) {
    list.push_back(imm_->NewIterator());
    imm_->Ref();
  }
  versions_->current()->AddIterators(options, &list);
  Iterator* internal_iter =
      NewMergingIterator(&internal_comparator_, &list[0], list.size());
  versions_->current()->Ref();

  cleanup->mu = &mutex_;
  cleanup->mem = mem_;
  cleanup->imm = imm_;
  cleanup->version = versions_->current();
  internal_iter->RegisterCleanup(CleanupIteratorState, cleanup, NULL);

  *seed = ++seed_;
  mutex_.Unlock();
  return internal_iter;
}",1,1,db\db_impl.cc,leveldb.DBImpl.NewInternalIterator,,false,1067,1096,NewInternalIterator,,,30,"Iterator leveldb.DBImpl.NewInternalIterator (ReadOptions,SequenceNumber*,uint32_t*)"
13058,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Iterator* DBImpl::TEST_NewInternalIterator() {
  SequenceNumber ignored;
  uint32_t ignored_seed;
  return NewInternalIterator(ReadOptions(), &ignored, &ignored_seed);
}",1,1,db\db_impl.cc,leveldb.DBImpl.TEST_NewInternalIterator,,false,1098,1102,TEST_NewInternalIterator,,,31,Iterator leveldb.DBImpl.TEST_NewInternalIterator ()
13071,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {
  MutexLock l(&mutex_);
  return versions_->MaxNextLevelOverlappingBytes();
}",1,1,db\db_impl.cc,leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes,,false,1104,1107,TEST_MaxNextLevelOverlappingBytes,,,32,int64_t leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes ()
13084,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::Get(const ReadOptions& options,
                   const Slice& key,
                   std::string* value) {
  Status s;
  MutexLock l(&mutex_);
  SequenceNumber snapshot;
  if (options.snapshot != NULL) {
    snapshot = reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_;
  } else {
    snapshot = versions_->LastSequence();
  }

  MemTable* mem = mem_;
  MemTable* imm = imm_;
  Version* current = versions_->current();
  mem->Ref();
  if (imm != NULL) imm->Ref();
  current->Ref();

  bool have_stat_update = false;
  Version::GetStats stats;

  // Unlock while reading from files and memtables
  {
    mutex_.Unlock();
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem->Get(lkey, value, &s)) {
      // Done
    } else if (imm != NULL && imm->Get(lkey, value, &s)) {
      // Done
    } else {
      s = current->Get(options, lkey, value, &stats);
      have_stat_update = true;
    }
    m...",1,1,db\db_impl.cc,leveldb.DBImpl.Get,,false,1109,1154,Get,,,33,"Status leveldb.DBImpl.Get (ReadOptions,Slice,ANY*)"
13242,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Iterator* DBImpl::NewIterator(const ReadOptions& options) {
  SequenceNumber latest_snapshot;
  uint32_t seed;
  Iterator* iter = NewInternalIterator(options, &latest_snapshot, &seed);
  return NewDBIterator(
      this, user_comparator(), iter,
      (options.snapshot != NULL
       ? reinterpret_cast<const SnapshotImpl*>(options.snapshot)->number_
       : latest_snapshot),
      seed);
}",1,1,db\db_impl.cc,leveldb.DBImpl.NewIterator,,false,1156,1166,NewIterator,,,34,Iterator leveldb.DBImpl.NewIterator (ReadOptions)
13278,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::RecordReadSample(Slice key) {
  MutexLock l(&mutex_);
  if (versions_->current()->RecordReadSample(key)) {
    MaybeScheduleCompaction();
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.RecordReadSample,,false,1168,1173,RecordReadSample,,,35,void leveldb.DBImpl.RecordReadSample (Slice)
13298,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"const Snapshot* DBImpl::GetSnapshot() {
  MutexLock l(&mutex_);
  return snapshots_.New(versions_->LastSequence());
}",1,1,db\db_impl.cc,leveldb.DBImpl.GetSnapshot,,false,1175,1178,GetSnapshot,,,36,Snapshot leveldb.DBImpl.GetSnapshot ()
13315,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::ReleaseSnapshot(const Snapshot* s) {
  MutexLock l(&mutex_);
  snapshots_.Delete(reinterpret_cast<const SnapshotImpl*>(s));
}",1,1,db\db_impl.cc,leveldb.DBImpl.ReleaseSnapshot,,false,1180,1183,ReleaseSnapshot,,,37,void leveldb.DBImpl.ReleaseSnapshot (Snapshot*)
13331,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {
  return DB::Put(o, key, val);
}",1,1,db\db_impl.cc,leveldb.DBImpl.Put,,false,1186,1188,Put,,,38,"Status leveldb.DBImpl.Put (WriteOptions,Slice,Slice)"
13346,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {
  return DB::Delete(options, key);
}",1,1,db\db_impl.cc,leveldb.DBImpl.Delete,,false,1190,1192,Delete,,,39,"Status leveldb.DBImpl.Delete (WriteOptions,Slice)"
13359,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {
  Writer w(&mutex_);
  w.batch = my_batch;
  w.sync = options.sync;
  w.done = false;

  MutexLock l(&mutex_);
  writers_.push_back(&w);
  while (!w.done && &w != writers_.front()) {
    w.cv.Wait();
  }
  if (w.done) {
    return w.status;
  }

  // May temporarily unlock and wait.
  Status status = MakeRoomForWrite(my_batch == NULL);
  uint64_t last_sequence = versions_->LastSequence();
  Writer* last_writer = &w;
  if (status.ok() && my_batch != NULL) {  // NULL batch is for compactions
    WriteBatch* updates = BuildBatchGroup(&last_writer);
    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
    last_sequence += WriteBatchInternal::Count(updates);

    // Add to log and apply to memtable.  We can release the lock
    // during this phase since &w is currently responsible for logging
    // and protects against concurrent loggers and concurrent writes
    // into mem_.
    {
      mutex_.Unloc...",1,1,db\db_impl.cc,leveldb.DBImpl.Write,,false,1194,1265,Write,,,40,"Status leveldb.DBImpl.Write (WriteOptions,WriteBatch*)"
13618,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {
  assert(!writers_.empty());
  Writer* first = writers_.front();
  WriteBatch* result = first->batch;
  assert(result != NULL);

  size_t size = WriteBatchInternal::ByteSize(first->batch);

  // Allow the group to grow up to a maximum size, but if the
  // original write is small, limit the growth so we do not slow
  // down the small write too much.
  size_t max_size = 1 << 20;
  if (size <= (128<<10)) {
    max_size = size + (128<<10);
  }

  *last_writer = first;
  std::deque<Writer*>::iterator iter = writers_.begin();
  ++iter;  // Advance past ""first""
  for (; iter != writers_.end(); ++iter) {
    Writer* w = *iter;
    if (w->sync && !first->sync) {
      // Do not include a sync write into a batch handled by a non-sync write.
      break;
    }

    if (w->batch != NULL) {
      size += WriteBatchInternal::ByteSize(w->batch);
      if (size > max_size) {
        // Do not make batch too big
        break;
      }

  ...",1,1,db\db_impl.cc,leveldb.DBImpl.BuildBatchGroup,,false,1269,1314,BuildBatchGroup,,,41,WriteBatch leveldb.DBImpl.BuildBatchGroup (Writer**)
13778,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DBImpl::MakeRoomForWrite(bool force) {
  mutex_.AssertHeld();
  assert(!writers_.empty());
  bool allow_delay = !force;
  Status s;
  while (true) {
    if (!bg_error_.ok()) {
      // Yield previous error
      s = bg_error_;
      break;
    } else if (
        allow_delay &&
        versions_->NumLevelFiles(0) >= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_->SleepForMicroseconds(1000);
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &&
               (mem_->ApproximateMemoryUsage() <= option...",1,1,db\db_impl.cc,leveldb.DBImpl.MakeRoomForWrite,,false,1318,1379,MakeRoomForWrite,,,42,Status leveldb.DBImpl.MakeRoomForWrite (bool)
13980,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"bool DBImpl::GetProperty(const Slice& property, std::string* value) {
  value->clear();

  MutexLock l(&mutex_);
  Slice in = property;
  Slice prefix(""leveldb."");
  if (!in.starts_with(prefix)) return false;
  in.remove_prefix(prefix.size());

  if (in.starts_with(""num-files-at-level"")) {
    in.remove_prefix(strlen(""num-files-at-level""));
    uint64_t level;
    bool ok = ConsumeDecimalNumber(&in, &level) && in.empty();
    if (!ok || level >= config::kNumLevels) {
      return false;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""%d"",
               versions_->NumLevelFiles(static_cast<int>(level)));
      *value = buf;
      return true;
    }
  } else if (in == ""stats"") {
    char buf[200];
    snprintf(buf, sizeof(buf),
             ""                               Compactions\n""
             ""Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n""
             ""--------------------------------------------------\n""
             );
    value->append(buf);
    ...",1,1,db\db_impl.cc,leveldb.DBImpl.GetProperty,,false,1381,1446,GetProperty,,,43,"bool leveldb.DBImpl.GetProperty (Slice,ANY*)"
14245,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"void DBImpl::GetApproximateSizes(
    const Range* range, int n,
    uint64_t* sizes) {
  // TODO(opt): better implementation
  Version* v;
  {
    MutexLock l(&mutex_);
    versions_->current()->Ref();
    v = versions_->current();
  }

  for (int i = 0; i < n; i++) {
    // Convert user_key into a corresponding internal key.
    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    uint64_t start = versions_->ApproximateOffsetOf(v, k1);
    uint64_t limit = versions_->ApproximateOffsetOf(v, k2);
    sizes[i] = (limit >= start ? limit - start : 0);
  }

  {
    MutexLock l(&mutex_);
    v->Unref();
  }
}",1,1,db\db_impl.cc,leveldb.DBImpl.GetApproximateSizes,,false,1448,1472,GetApproximateSizes,,,44,"void leveldb.DBImpl.GetApproximateSizes (Range*,int,uint64_t*)"
14340,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {
  WriteBatch batch;
  batch.Put(key, value);
  return Write(opt, &batch);
}",1,1,db\db_impl.cc,leveldb.DB.Put,,false,1476,1480,Put,,,45,"Status leveldb.DB.Put (WriteOptions,Slice,Slice)"
14359,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DB::Delete(const WriteOptions& opt, const Slice& key) {
  WriteBatch batch;
  batch.Delete(key);
  return Write(opt, &batch);
}",1,1,db\db_impl.cc,leveldb.DB.Delete,,false,1482,1486,Delete,,,46,"Status leveldb.DB.Delete (WriteOptions,Slice)"
14376,METHOD,db\db_impl.cc:<global>,TYPE_DECL,DB::~DB() { },1,13,db\db_impl.cc,leveldb.DB.~DB,,false,1488,1488,~DB,,,47,ANY leveldb.DB.~DB ()
14380,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DB::Open(const Options& options, const std::string& dbname,
                DB** dbptr) {
  *dbptr = NULL;

  DBImpl* impl = new DBImpl(options, dbname);
  impl->mutex_.Lock();
  VersionEdit edit;
  // Recover handles create_if_missing, error_if_exists
  bool save_manifest = false;
  Status s = impl->Recover(&edit, &save_manifest);
  if (s.ok() && impl->mem_ == NULL) {
    // Create new log and a corresponding memtable.
    uint64_t new_log_number = impl->versions_->NewFileNumber();
    WritableFile* lfile;
    s = options.env->NewWritableFile(LogFileName(dbname, new_log_number),
                                     &lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl->logfile_ = lfile;
      impl->logfile_number_ = new_log_number;
      impl->log_ = new log::Writer(lfile);
      impl->mem_ = new MemTable(impl->internal_comparator_);
      impl->mem_->Ref();
    }
  }
  if (s.ok() && save_manifest) {
    edit.SetPrevLogNumber(0);  // No older logs ne...",1,1,db\db_impl.cc,leveldb.DB.Open,,false,1490,1532,Open,,,48,"Status leveldb.DB.Open (Options,ANY,DB**)"
14574,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Snapshot::~Snapshot() {
}",1,1,db\db_impl.cc,leveldb.Snapshot.~Snapshot,,false,1534,1535,~Snapshot,,,49,ANY leveldb.Snapshot.~Snapshot ()
14578,METHOD,db\db_impl.cc:<global>,TYPE_DECL,"Status DestroyDB(const std::string& dbname, const Options& options) {
  Env* env = options.env;
  std::vector<std::string> filenames;
  // Ignore error in case directory does not exist
  env->GetChildren(dbname, &filenames);
  if (filenames.empty()) {
    return Status::OK();
  }

  FileLock* lock;
  const std::string lockname = LockFileName(dbname);
  Status result = env->LockFile(lockname, &lock);
  if (result.ok()) {
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) &&
          type != kDBLockFile) {  // Lock file will be deleted at end
        Status del = env->DeleteFile(dbname + ""/"" + filenames[i]);
        if (result.ok() && !del.ok()) {
          result = del;
        }
      }
    }
    env->UnlockFile(lock);  // Ignore error since state is already gone
    env->DeleteFile(lockname);
    env->DeleteDir(dbname);  // Ignore error in case dir contains other files
  }
  return resul...",1,1,db\db_impl.cc,leveldb.DestroyDB,,false,1537,1566,DestroyDB,,,50,"Status leveldb.DestroyDB (ANY,Options)"
14737,METHOD,db\db_impl.hpp:<global>,TYPE_DECL,<global>,1,15,db\db_impl.hpp,db\db_impl.hpp:<global>,,false,1,211,<global>,,,1,
14746,METHOD,leveldb.DBImpl,TYPE_DECL,"DBImpl(const Options& options, const std::string& dbname);",3,59,db\db_impl.hpp,leveldb.DBImpl.DBImpl,,false,28,28,DBImpl,,,1,"ANY leveldb.DBImpl.DBImpl (Options,ANY)"
14752,METHOD,leveldb.DBImpl,TYPE_DECL,virtual ~DBImpl();,11,19,db\db_impl.hpp,leveldb.DBImpl.~DBImpl,,false,29,29,~DBImpl,,,2,virtual leveldb.DBImpl.~DBImpl ()
14756,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);",18,79,db\db_impl.hpp,leveldb.DBImpl.Put,,false,32,32,Put,,,3,"Status leveldb.DBImpl.Put (WriteOptions,Slice,Slice)"
14763,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual Status Delete(const WriteOptions&, const Slice& key);",18,62,db\db_impl.hpp,leveldb.DBImpl.Delete,,false,33,33,Delete,,,4,"Status leveldb.DBImpl.Delete (WriteOptions,Slice)"
14769,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual Status Write(const WriteOptions& options, WriteBatch* updates);",18,72,db\db_impl.hpp,leveldb.DBImpl.Write,,false,34,34,Write,,,5,"Status leveldb.DBImpl.Write (WriteOptions,WriteBatch*)"
14775,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual Status Get(const ReadOptions& options,
                     const Slice& key,
                     std::string* value);",18,40,db\db_impl.hpp,leveldb.DBImpl.Get,,false,35,37,Get,,,6,"Status leveldb.DBImpl.Get (ReadOptions,Slice,ANY*)"
14782,METHOD,leveldb.DBImpl,TYPE_DECL,virtual Iterator* NewIterator(const ReadOptions&);,19,51,db\db_impl.hpp,leveldb.DBImpl.NewIterator,,false,38,38,NewIterator,,,7,Iterator* leveldb.DBImpl.NewIterator (ReadOptions)
14787,METHOD,leveldb.DBImpl,TYPE_DECL,virtual const Snapshot* GetSnapshot();,25,39,db\db_impl.hpp,leveldb.DBImpl.GetSnapshot,,false,39,39,GetSnapshot,,,8,Snapshot* leveldb.DBImpl.GetSnapshot ()
14791,METHOD,leveldb.DBImpl,TYPE_DECL,virtual void ReleaseSnapshot(const Snapshot* snapshot);,16,56,db\db_impl.hpp,leveldb.DBImpl.ReleaseSnapshot,,false,40,40,ReleaseSnapshot,,,9,void leveldb.DBImpl.ReleaseSnapshot (Snapshot*)
14796,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual bool GetProperty(const Slice& property, std::string* value);",16,69,db\db_impl.hpp,leveldb.DBImpl.GetProperty,,false,41,41,GetProperty,,,10,"bool leveldb.DBImpl.GetProperty (Slice,ANY*)"
14802,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual void GetApproximateSizes(const Range* range, int n, uint64_t* sizes);",16,78,db\db_impl.hpp,leveldb.DBImpl.GetApproximateSizes,,false,42,42,GetApproximateSizes,,,11,"void leveldb.DBImpl.GetApproximateSizes (Range*,int,uint64_t*)"
14809,METHOD,leveldb.DBImpl,TYPE_DECL,"virtual void CompactRange(const Slice* begin, const Slice* end);",16,65,db\db_impl.hpp,leveldb.DBImpl.CompactRange,,false,43,43,CompactRange,,,12,"void leveldb.DBImpl.CompactRange (Slice*,Slice*)"
14815,METHOD,leveldb.DBImpl,TYPE_DECL,"void TEST_CompactRange(int level, const Slice* begin, const Slice* end);",8,73,db\db_impl.hpp,leveldb.DBImpl.TEST_CompactRange,,false,48,48,TEST_CompactRange,,,13,"void leveldb.DBImpl.TEST_CompactRange (int,Slice*,Slice*)"
14822,METHOD,leveldb.DBImpl,TYPE_DECL,Status TEST_CompactMemTable();,10,31,db\db_impl.hpp,leveldb.DBImpl.TEST_CompactMemTable,,false,51,51,TEST_CompactMemTable,,,14,Status leveldb.DBImpl.TEST_CompactMemTable ()
14826,METHOD,leveldb.DBImpl,TYPE_DECL,Iterator* TEST_NewInternalIterator();,11,38,db\db_impl.hpp,leveldb.DBImpl.TEST_NewInternalIterator,,false,56,56,TEST_NewInternalIterator,,,15,Iterator* leveldb.DBImpl.TEST_NewInternalIterator ()
14830,METHOD,leveldb.DBImpl,TYPE_DECL,int64_t TEST_MaxNextLevelOverlappingBytes();,11,45,db\db_impl.hpp,leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes,,false,60,60,TEST_MaxNextLevelOverlappingBytes,,,16,int64_t leveldb.DBImpl.TEST_MaxNextLevelOverlappingBytes ()
14834,METHOD,leveldb.DBImpl,TYPE_DECL,void RecordReadSample(Slice key);,8,34,db\db_impl.hpp,leveldb.DBImpl.RecordReadSample,,false,65,65,RecordReadSample,,,17,void leveldb.DBImpl.RecordReadSample (Slice)
14842,METHOD,leveldb.DBImpl,TYPE_DECL,"Iterator* NewInternalIterator(const ReadOptions&,
                                SequenceNumber* latest_snapshot,
                                uint32_t* seed);",11,47,db\db_impl.hpp,leveldb.DBImpl.NewInternalIterator,,false,72,74,NewInternalIterator,,,21,"Iterator* leveldb.DBImpl.NewInternalIterator (ReadOptions,SequenceNumber*,uint32_t*)"
14849,METHOD,leveldb.DBImpl,TYPE_DECL,Status NewDB();,10,16,db\db_impl.hpp,leveldb.DBImpl.NewDB,,false,76,76,NewDB,,,22,Status leveldb.DBImpl.NewDB ()
14853,METHOD,leveldb.DBImpl,TYPE_DECL,"Status Recover(VersionEdit* edit, bool* save_manifest)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",10,56,db\db_impl.hpp,leveldb.DBImpl.Recover,,false,81,81,Recover,,,23,"Status leveldb.DBImpl.Recover (VersionEdit*,bool*)"
14859,METHOD,leveldb.DBImpl,TYPE_DECL,void MaybeIgnoreError(Status* s) const;,8,40,db\db_impl.hpp,leveldb.DBImpl.MaybeIgnoreError,,false,84,84,MaybeIgnoreError,,,24,void leveldb.DBImpl.MaybeIgnoreError (Status*)
14864,METHOD,leveldb.DBImpl,TYPE_DECL,void DeleteObsoleteFiles();,8,28,db\db_impl.hpp,leveldb.DBImpl.DeleteObsoleteFiles,,false,87,87,DeleteObsoleteFiles,,,25,void leveldb.DBImpl.DeleteObsoleteFiles ()
14868,METHOD,leveldb.DBImpl,TYPE_DECL,void CompactMemTable() EXCLUSIVE_LOCKS_REQUIRED(mutex_);,8,24,db\db_impl.hpp,leveldb.DBImpl.CompactMemTable,,false,92,92,CompactMemTable,,,26,void leveldb.DBImpl.CompactMemTable ()
14872,METHOD,leveldb.DBImpl,TYPE_DECL,"Status RecoverLogFile(uint64_t log_number, bool last_log, bool* save_manifest,
                        VersionEdit* edit, SequenceNumber* max_sequence)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",10,72,db\db_impl.hpp,leveldb.DBImpl.RecoverLogFile,,false,94,95,RecoverLogFile,,,27,"Status leveldb.DBImpl.RecoverLogFile (uint64_t,bool,bool*,VersionEdit*,SequenceNumber*)"
14881,METHOD,leveldb.DBImpl,TYPE_DECL,"Status WriteLevel0Table(MemTable* mem, VersionEdit* edit, Version* base)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",10,74,db\db_impl.hpp,leveldb.DBImpl.WriteLevel0Table,,false,98,98,WriteLevel0Table,,,28,"Status leveldb.DBImpl.WriteLevel0Table (MemTable*,VersionEdit*,Version*)"
14888,METHOD,leveldb.DBImpl,TYPE_DECL,"Status MakeRoomForWrite(bool force /* compact even if there is room? */)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",10,74,db\db_impl.hpp,leveldb.DBImpl.MakeRoomForWrite,,false,101,101,MakeRoomForWrite,,,29,Status leveldb.DBImpl.MakeRoomForWrite (bool)
14893,METHOD,leveldb.DBImpl,TYPE_DECL,WriteBatch* BuildBatchGroup(Writer** last_writer);,13,51,db\db_impl.hpp,leveldb.DBImpl.BuildBatchGroup,,false,103,103,BuildBatchGroup,,,30,WriteBatch* leveldb.DBImpl.BuildBatchGroup (Writer**)
14898,METHOD,leveldb.DBImpl,TYPE_DECL,void RecordBackgroundError(const Status& s);,8,45,db\db_impl.hpp,leveldb.DBImpl.RecordBackgroundError,,false,105,105,RecordBackgroundError,,,31,void leveldb.DBImpl.RecordBackgroundError (Status)
14903,METHOD,leveldb.DBImpl,TYPE_DECL,void MaybeScheduleCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);,8,32,db\db_impl.hpp,leveldb.DBImpl.MaybeScheduleCompaction,,false,107,107,MaybeScheduleCompaction,,,32,void leveldb.DBImpl.MaybeScheduleCompaction ()
14907,METHOD,leveldb.DBImpl,TYPE_DECL,static void BGWork(void* db);,15,30,db\db_impl.hpp,leveldb.DBImpl.BGWork,,false,108,108,BGWork,,,33,void leveldb.DBImpl.BGWork (void*)
14912,METHOD,leveldb.DBImpl,TYPE_DECL,void BackgroundCall();,8,23,db\db_impl.hpp,leveldb.DBImpl.BackgroundCall,,false,109,109,BackgroundCall,,,34,void leveldb.DBImpl.BackgroundCall ()
14916,METHOD,leveldb.DBImpl,TYPE_DECL,void  BackgroundCompaction() EXCLUSIVE_LOCKS_REQUIRED(mutex_);,9,30,db\db_impl.hpp,leveldb.DBImpl.BackgroundCompaction,,false,110,110,BackgroundCompaction,,,35,void leveldb.DBImpl.BackgroundCompaction ()
14920,METHOD,leveldb.DBImpl,TYPE_DECL,"void CleanupCompaction(CompactionState* compact)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",8,50,db\db_impl.hpp,leveldb.DBImpl.CleanupCompaction,,false,111,111,CleanupCompaction,,,36,void leveldb.DBImpl.CleanupCompaction (CompactionState*)
14925,METHOD,leveldb.DBImpl,TYPE_DECL,"Status DoCompactionWork(CompactionState* compact)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",10,51,db\db_impl.hpp,leveldb.DBImpl.DoCompactionWork,,false,113,113,DoCompactionWork,,,37,Status leveldb.DBImpl.DoCompactionWork (CompactionState*)
14930,METHOD,leveldb.DBImpl,TYPE_DECL,Status OpenCompactionOutputFile(CompactionState* compact);,10,59,db\db_impl.hpp,leveldb.DBImpl.OpenCompactionOutputFile,,false,116,116,OpenCompactionOutputFile,,,38,Status leveldb.DBImpl.OpenCompactionOutputFile (CompactionState*)
14935,METHOD,leveldb.DBImpl,TYPE_DECL,"Status FinishCompactionOutputFile(CompactionState* compact, Iterator* input);",10,78,db\db_impl.hpp,leveldb.DBImpl.FinishCompactionOutputFile,,false,117,117,FinishCompactionOutputFile,,,39,"Status leveldb.DBImpl.FinishCompactionOutputFile (CompactionState*,Iterator*)"
14941,METHOD,leveldb.DBImpl,TYPE_DECL,"Status InstallCompactionResults(CompactionState* compact)
      EXCLUSIVE_LOCKS_REQUIRED(mutex_);",10,59,db\db_impl.hpp,leveldb.DBImpl.InstallCompactionResults,,false,118,118,InstallCompactionResults,,,40,Status leveldb.DBImpl.InstallCompactionResults (CompactionState*)
14983,METHOD,leveldb.DBImpl.CompactionStats,TYPE_DECL,"CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }",5,70,db\db_impl.hpp,leveldb.DBImpl.CompactionStats.CompactionStats,,false,183,183,CompactionStats,,,4,ANY leveldb.DBImpl.CompactionStats.CompactionStats ()
14987,METHOD,leveldb.DBImpl.CompactionStats,TYPE_DECL,"void Add(const CompactionStats& c) {
      this->micros += c.micros;
      this->bytes_read += c.bytes_read;
      this->bytes_written += c.bytes_written;
    }",5,5,db\db_impl.hpp,leveldb.DBImpl.CompactionStats.Add,,false,185,189,Add,,,5,void leveldb.DBImpl.CompactionStats.Add (CompactionStats)
15014,METHOD,leveldb.DBImpl,TYPE_DECL,DBImpl(const DBImpl&);,3,23,db\db_impl.hpp,leveldb.DBImpl.DBImpl,,false,194,194,DBImpl,,,71,ANY leveldb.DBImpl.DBImpl (DBImpl)
15019,METHOD,leveldb.DBImpl,TYPE_DECL,void operator=(const DBImpl&);,8,31,db\db_impl.hpp,leveldb.DBImpl.operator =,,false,195,195,operator =,,,72,void leveldb.DBImpl.operator = (DBImpl)
15024,METHOD,leveldb.DBImpl,TYPE_DECL,"const Comparator* user_comparator() const {
    return internal_comparator_.user_comparator();
  }",3,3,db\db_impl.hpp,leveldb.DBImpl.user_comparator,,false,197,199,user_comparator,,,73,Comparator leveldb.DBImpl.user_comparator ()
15033,METHOD,<empty>,<empty>,<empty>,1,,db\db_impl.hpp,leveldb.DBImpl:<clinit>,,false,26,,<clinit>,,,74,
15041,METHOD,db\db_impl.hpp:<global>,TYPE_DECL,"extern Options SanitizeOptions(const std::string& db,
                               const InternalKeyComparator* icmp,
                               const InternalFilterPolicy* ipolicy,
                               const Options& src);",16,50,db\db_impl.hpp,leveldb.SanitizeOptions,,false,204,207,SanitizeOptions,,,7,"Options leveldb.SanitizeOptions (ANY,InternalKeyComparator*,InternalFilterPolicy*,Options)"
15072,METHOD,db\db_iter.cc:<global>,TYPE_DECL,<global>,1,1,db\db_iter.cc,db\db_iter.cc:<global>,,false,1,317,<global>,,,1,
15080,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,
         uint32_t seed)
      : db_(db),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward),
        valid_(false),
        rnd_(seed),
        bytes_counter_(RandomPeriod()) {
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_3.DBIter.DBIter,,false,51,61,DBIter,,,2,"ANY leveldb.anonymous_namespace_3.DBIter.DBIter (DBImpl*,Comparator*,Iterator*,SequenceNumber,uint32_t)"
15089,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"virtual ~DBIter() {
    delete iter_;
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_4.DBIter.~DBIter,,false,62,64,~DBIter,,,3,ANY leveldb.anonymous_namespace_4.DBIter.~DBIter ()
15095,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,virtual bool Valid() const { return valid_; },3,47,db\db_iter.cc,leveldb.anonymous_namespace_5.DBIter.Valid,,false,65,65,Valid,,,4,bool leveldb.anonymous_namespace_5.DBIter.Valid ()
15101,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"virtual Slice key() const {
    assert(valid_);
    return (direction_ == kForward) ? ExtractUserKey(iter_->key()) : saved_key_;
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_6.DBIter.key,,false,66,69,key,,,5,Slice leveldb.anonymous_namespace_6.DBIter.key ()
15118,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"virtual Slice value() const {
    assert(valid_);
    return (direction_ == kForward) ? iter_->value() : saved_value_;
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_7.DBIter.value,,false,70,73,value,,,6,Slice leveldb.anonymous_namespace_7.DBIter.value ()
15134,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"virtual Status status() const {
    if (status_.ok()) {
      return iter_->status();
    } else {
      return status_;
    }
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_8.DBIter.status,,false,74,80,status,,,7,Status leveldb.anonymous_namespace_8.DBIter.status ()
15153,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,virtual void Next();,16,21,db\db_iter.cc,leveldb.anonymous_namespace_9.DBIter.Next,,false,82,82,Next,,,8,void leveldb.anonymous_namespace_9.DBIter.Next ()
15157,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,virtual void Prev();,16,21,db\db_iter.cc,leveldb.anonymous_namespace_10.DBIter.Prev,,false,83,83,Prev,,,9,void leveldb.anonymous_namespace_10.DBIter.Prev ()
15161,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,virtual void Seek(const Slice& target);,16,40,db\db_iter.cc,leveldb.anonymous_namespace_11.DBIter.Seek,,false,84,84,Seek,,,10,void leveldb.anonymous_namespace_11.DBIter.Seek (Slice)
15166,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,virtual void SeekToFirst();,16,28,db\db_iter.cc,leveldb.anonymous_namespace_12.DBIter.SeekToFirst,,false,85,85,SeekToFirst,,,11,void leveldb.anonymous_namespace_12.DBIter.SeekToFirst ()
15170,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,virtual void SeekToLast();,16,27,db\db_iter.cc,leveldb.anonymous_namespace_13.DBIter.SeekToLast,,false,86,86,SeekToLast,,,12,void leveldb.anonymous_namespace_13.DBIter.SeekToLast ()
15174,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"void FindNextUserEntry(bool skipping, std::string* skip);",8,58,db\db_iter.cc,leveldb.anonymous_namespace_14.DBIter.FindNextUserEntry,,false,89,89,FindNextUserEntry,,,13,"void leveldb.anonymous_namespace_14.DBIter.FindNextUserEntry (bool,ANY*)"
15180,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,void FindPrevUserEntry();,8,26,db\db_iter.cc,leveldb.anonymous_namespace_15.DBIter.FindPrevUserEntry,,false,90,90,FindPrevUserEntry,,,14,void leveldb.anonymous_namespace_15.DBIter.FindPrevUserEntry ()
15184,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,bool ParseKey(ParsedInternalKey* key);,8,39,db\db_iter.cc,leveldb.anonymous_namespace_16.DBIter.ParseKey,,false,91,91,ParseKey,,,15,bool leveldb.anonymous_namespace_16.DBIter.ParseKey (ParsedInternalKey*)
15189,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"inline void SaveKey(const Slice& k, std::string* dst) {
    dst->assign(k.data(), k.size());
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_17.DBIter.SaveKey,,false,93,95,SaveKey,,,16,"void leveldb.anonymous_namespace_17.DBIter.SaveKey (Slice,ANY*)"
15207,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"inline void ClearSavedValue() {
    if (saved_value_.capacity() > 1048576) {
      std::string empty;
      swap(empty, saved_value_);
    } else {
      saved_value_.clear();
    }
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_18.DBIter.ClearSavedValue,,false,97,104,ClearSavedValue,,,17,void leveldb.anonymous_namespace_18.DBIter.ClearSavedValue ()
15229,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,"ssize_t RandomPeriod() {
    return rnd_.Uniform(2*config::kReadBytesPeriod);
  }",3,3,db\db_iter.cc,leveldb.anonymous_namespace_19.DBIter.RandomPeriod,,false,107,109,RandomPeriod,,,18,ssize_t leveldb.anonymous_namespace_19.DBIter.RandomPeriod ()
15254,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,DBIter(const DBIter&);,3,23,db\db_iter.cc,leveldb.anonymous_namespace_20.DBIter.DBIter,,false,126,126,DBIter,,,30,ANY leveldb.anonymous_namespace_20.DBIter.DBIter (DBIter)
15259,METHOD,leveldb.anonymous_namespace_1.DBIter,TYPE_DECL,void operator=(const DBIter&);,8,31,db\db_iter.cc,leveldb.anonymous_namespace_21.DBIter.operator =,,false,127,127,operator =,,,31,void leveldb.anonymous_namespace_21.DBIter.operator = (DBIter)
15264,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
  Slice k = iter_->key();
  ssize_t n = k.size() + iter_->value().size();
  bytes_counter_ -= n;
  while (bytes_counter_ < 0) {
    bytes_counter_ += RandomPeriod();
    db_->RecordReadSample(k);
  }
  if (!ParseInternalKey(k, ikey)) {
    status_ = Status::Corruption(""corrupted internal key in DBIter"");
    return false;
  } else {
    return true;
  }
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_22.DBIter.ParseKey,,false,130,144,ParseKey,,,2,bool leveldb.anonymous_namespace_22.DBIter.ParseKey (ParsedInternalKey*)
15326,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::Next() {
  assert(valid_);

  if (direction_ == kReverse) {  // Switch directions?
    direction_ = kForward;
    // iter_ is pointing just before the entries for this->key(),
    // so advance into the range of entries for this->key() and then
    // use the normal skipping code below.
    if (!iter_->Valid()) {
      iter_->SeekToFirst();
    } else {
      iter_->Next();
    }
    if (!iter_->Valid()) {
      valid_ = false;
      saved_key_.clear();
      return;
    }
    // saved_key_ already contains the key to skip past.
  } else {
    // Store in saved_key_ the current key so we skip it below.
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
  }

  FindNextUserEntry(true, &saved_key_);
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_24.DBIter.Next,,false,146,171,Next,,,3,void leveldb.anonymous_namespace_24.DBIter.Next ()
15386,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
  // Loop until we hit an acceptable entry to yield
  assert(iter_->Valid());
  assert(direction_ == kForward);
  do {
    ParsedInternalKey ikey;
    if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
      switch (ikey.type) {
        case kTypeDeletion:
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &&
              user_comparator_->Compare(ikey.user_key, *skip) <= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_->Next();
  } while (iter_->Valid());
  saved_key_.clear();
  valid_ = false;
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_26.DBIter.FindNextUserEntry,,false,173,203,FindNextUserEntry,,,4,"void leveldb.anonymous_namespace_26.DBIter.FindNextUserEntry (bool,ANY*)"
15474,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::Prev() {
  assert(valid_);

  if (direction_ == kForward) {  // Switch directions?
    // iter_ is pointing at the current entry.  Scan backwards until
    // the key changes so we can use the normal reverse scanning code.
    assert(iter_->Valid());  // Otherwise valid_ would have been false
    SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
    while (true) {
      iter_->Prev();
      if (!iter_->Valid()) {
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }
      if (user_comparator_->Compare(ExtractUserKey(iter_->key()),
                                    saved_key_) < 0) {
        break;
      }
    }
    direction_ = kReverse;
  }

  FindPrevUserEntry();
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_29.DBIter.Prev,,false,205,230,Prev,,,5,void leveldb.anonymous_namespace_29.DBIter.Prev ()
15540,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::FindPrevUserEntry() {
  assert(direction_ == kReverse);

  ValueType value_type = kTypeDeletion;
  if (iter_->Valid()) {
    do {
      ParsedInternalKey ikey;
      if (ParseKey(&ikey) && ikey.sequence <= sequence_) {
        if ((value_type != kTypeDeletion) &&
            user_comparator_->Compare(ikey.user_key, saved_key_) < 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_->value();
          if (saved_value_.capacity() > raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_->key()), &saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_->Prev();
    } while (iter_->Valid())...",1,1,db\db_iter.cc,leveldb.anonymous_namespace_32.DBIter.FindPrevUserEntry,,false,232,272,FindPrevUserEntry,,,6,void leveldb.anonymous_namespace_32.DBIter.FindPrevUserEntry ()
15679,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::Seek(const Slice& target) {
  direction_ = kForward;
  ClearSavedValue();
  saved_key_.clear();
  AppendInternalKey(
      &saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  iter_->Seek(saved_key_);
  if (iter_->Valid()) {
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_37.DBIter.Seek,,false,274,286,Seek,,,7,void leveldb.anonymous_namespace_37.DBIter.Seek (Slice)
15719,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::SeekToFirst() {
  direction_ = kForward;
  ClearSavedValue();
  iter_->SeekToFirst();
  if (iter_->Valid()) {
    FindNextUserEntry(false, &saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_40.DBIter.SeekToFirst,,false,288,297,SeekToFirst,,,8,void leveldb.anonymous_namespace_40.DBIter.SeekToFirst ()
15746,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"void DBIter::SeekToLast() {
  direction_ = kReverse;
  ClearSavedValue();
  iter_->SeekToLast();
  FindPrevUserEntry();
}",1,1,db\db_iter.cc,leveldb.anonymous_namespace_43.DBIter.SeekToLast,,false,299,304,SeekToLast,,,9,void leveldb.anonymous_namespace_43.DBIter.SeekToLast ()
15759,METHOD,db\db_iter.cc:<global>,TYPE_DECL,"Iterator* NewDBIterator(
    DBImpl* db,
    const Comparator* user_key_comparator,
    Iterator* internal_iter,
    SequenceNumber sequence,
    uint32_t seed) {
  return new DBIter(db, user_key_comparator, internal_iter, sequence, seed);
}",1,1,db\db_iter.cc,leveldb.NewDBIterator,,false,308,315,NewDBIterator,,,2,"Iterator leveldb.NewDBIterator (DBImpl*,Comparator*,Iterator*,SequenceNumber,uint32_t)"
15785,METHOD,db\db_iter.hpp:<global>,TYPE_DECL,<global>,1,22,db\db_iter.hpp,db\db_iter.hpp:<global>,,false,1,28,<global>,,,1,
15789,METHOD,db\db_iter.hpp:<global>,TYPE_DECL,"extern Iterator* NewDBIterator(
    DBImpl* db,
    const Comparator* user_key_comparator,
    Iterator* internal_iter,
    SequenceNumber sequence,
    uint32_t seed);",16,18,db\db_iter.hpp,leveldb.NewDBIterator,,false,19,24,NewDBIterator,,,2,"Iterator* leveldb.NewDBIterator (DBImpl*,Comparator*,Iterator*,SequenceNumber,uint32_t)"
15829,METHOD,db\db_test.cc:<global>,TYPE_DECL,<global>,1,1,db\db_test.cc,db\db_test.cc:<global>,,false,1,2158,<global>,,,1,
15832,METHOD,db\db_test.cc:<global>,TYPE_DECL,"static std::string RandomString(Random* rnd, int len) {
  std::string r;
  test::RandomString(rnd, len, &r);
  return r;
}",1,1,db\db_test.cc,leveldb.RandomString,,false,22,26,RandomString,,,1,"string leveldb.RandomString (Random*,int)"
15853,METHOD,leveldb.anonymous_namespace_1.AtomicCounter,TYPE_DECL,AtomicCounter() : count_(0) { },3,33,db\db_test.cc,leveldb.anonymous_namespace_2.AtomicCounter.AtomicCounter,,false,34,34,AtomicCounter,,,3,ANY leveldb.anonymous_namespace_2.AtomicCounter.AtomicCounter ()
15857,METHOD,leveldb.anonymous_namespace_1.AtomicCounter,TYPE_DECL,"void Increment() {
    IncrementBy(1);
  }",3,3,db\db_test.cc,leveldb.anonymous_namespace_3.AtomicCounter.Increment,,false,35,37,Increment,,,4,void leveldb.anonymous_namespace_3.AtomicCounter.Increment ()
15863,METHOD,leveldb.anonymous_namespace_1.AtomicCounter,TYPE_DECL,"void IncrementBy(int count) {
    MutexLock l(&mu_);
    count_ += count;
  }",3,3,db\db_test.cc,leveldb.anonymous_namespace_5.AtomicCounter.IncrementBy,,false,38,41,IncrementBy,,,5,void leveldb.anonymous_namespace_5.AtomicCounter.IncrementBy (int)
15875,METHOD,leveldb.anonymous_namespace_1.AtomicCounter,TYPE_DECL,"int Read() {
    MutexLock l(&mu_);
    return count_;
  }",3,3,db\db_test.cc,leveldb.anonymous_namespace_6.AtomicCounter.Read,,false,42,45,Read,,,6,int leveldb.anonymous_namespace_6.AtomicCounter.Read ()
15885,METHOD,leveldb.anonymous_namespace_1.AtomicCounter,TYPE_DECL,"void Reset() {
    MutexLock l(&mu_);
    count_ = 0;
  }",3,3,db\db_test.cc,leveldb.anonymous_namespace_7.AtomicCounter.Reset,,false,46,49,Reset,,,7,void leveldb.anonymous_namespace_7.AtomicCounter.Reset ()
15896,METHOD,db\db_test.cc:<global>,TYPE_DECL,"void DelayMilliseconds(int millis) {
  Env::Default()->SleepForMicroseconds(millis * 1000);
}",1,1,db\db_test.cc,leveldb.anonymous_namespace_8.DelayMilliseconds,,false,52,54,DelayMilliseconds,,,2,void leveldb.anonymous_namespace_8.DelayMilliseconds (int)
15920,METHOD,leveldb.SpecialEnv,TYPE_DECL,"explicit SpecialEnv(Env* base) : EnvWrapper(base) {
    delay_data_sync_.Release_Store(NULL);
    data_sync_error_.Release_Store(NULL);
    no_space_.Release_Store(NULL);
    non_writable_.Release_Store(NULL);
    count_random_reads_ = false;
    manifest_sync_error_.Release_Store(NULL);
    manifest_write_error_.Release_Store(NULL);
  }",3,3,db\db_test.cc,leveldb.SpecialEnv.SpecialEnv,,false,81,89,SpecialEnv,,,9,ANY leveldb.SpecialEnv.SpecialEnv (Env*)
15958,METHOD,leveldb.SpecialEnv,TYPE_DECL,"Status NewWritableFile(const std::string& f, WritableFile** r) {
    class DataFile : public WritableFile {
     private:
      SpecialEnv* env_;
      WritableFile* base_;

     public:
      DataFile(SpecialEnv* env, WritableFile* base)
          : env_(env),
            base_(base) {
      }
      ~DataFile() { delete base_; }
      Status Append(const Slice& data) {
        if (env_->no_space_.Acquire_Load() != NULL) {
          // Drop writes on the floor
          return Status::OK();
        } else {
          return base_->Append(data);
        }
      }
      Status Close() { return base_->Close(); }
      Status Flush() { return base_->Flush(); }
      Status Sync() {
        if (env_->data_sync_error_.Acquire_Load() != NULL) {
          return Status::IOError(""simulated data sync error"");
        }
        while (env_->delay_data_sync_.Acquire_Load() != NULL) {
          DelayMilliseconds(100);
        }
        return base_->Sync();
      }
    };
    class ManifestFile ...",3,3,db\db_test.cc,leveldb.SpecialEnv.NewWritableFile,,false,91,162,NewWritableFile,,,10,"Status leveldb.SpecialEnv.NewWritableFile (ANY,WritableFile**)"
16042,METHOD,leveldb.SpecialEnv,TYPE_DECL,"Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    class CountingFile : public RandomAccessFile {
     private:
      RandomAccessFile* target_;
      AtomicCounter* counter_;
     public:
      CountingFile(RandomAccessFile* target, AtomicCounter* counter)
          : target_(target), counter_(counter) {
      }
      virtual ~CountingFile() { delete target_; }
      virtual Status Read(uint64_t offset, size_t n, Slice* result,
                          char* scratch) const {
        counter_->Increment();
        return target_->Read(offset, n, result, scratch);
      }
    };

    Status s = target()->NewRandomAccessFile(f, r);
    if (s.ok() && count_random_reads_) {
      *r = new CountingFile(*r, &random_read_counter_);
    }
    return s;
  }",3,3,db\db_test.cc,leveldb.SpecialEnv.NewRandomAccessFile,,false,164,186,NewRandomAccessFile,,,11,"Status leveldb.SpecialEnv.NewRandomAccessFile (ANY,RandomAccessFile**)"
16089,METHOD,leveldb.DBTest,TYPE_DECL,"DBTest() : option_config_(kDefault),
             env_(new SpecialEnv(Env::Default())) {
    filter_policy_ = NewBloomFilterPolicy(10);
    dbname_ = test::TmpDir() + ""/db_test"";
    DestroyDB(dbname_, Options());
    db_ = NULL;
    Reopen();
  }",3,3,db\db_test.cc,leveldb.DBTest.DBTest,,false,210,217,DBTest,,,8,ANY leveldb.DBTest.DBTest ()
16112,METHOD,leveldb.DBTest,TYPE_DECL,"~DBTest() {
    delete db_;
    DestroyDB(dbname_, Options());
    delete env_;
    delete filter_policy_;
  }",3,3,db\db_test.cc,leveldb.DBTest.~DBTest,,false,219,224,~DBTest,,,9,ANY leveldb.DBTest.~DBTest ()
16125,METHOD,leveldb.DBTest,TYPE_DECL,"bool ChangeOptions() {
    option_config_++;
    if (option_config_ >= kEnd) {
      return false;
    } else {
      DestroyAndReopen();
      return true;
    }
  }",3,3,db\db_test.cc,leveldb.DBTest.ChangeOptions,,false,228,236,ChangeOptions,,,10,bool leveldb.DBTest.ChangeOptions ()
16143,METHOD,leveldb.DBTest,TYPE_DECL,"Options CurrentOptions() {
    Options options;
    options.reuse_logs = false;
    switch (option_config_) {
      case kReuse:
        options.reuse_logs = true;
        break;
      case kFilter:
        options.filter_policy = filter_policy_;
        break;
      case kUncompressed:
        options.compression = kNoCompression;
        break;
      default:
        break;
    }
    return options;
  }",3,3,db\db_test.cc,leveldb.DBTest.CurrentOptions,,false,239,256,CurrentOptions,,,11,Options leveldb.DBTest.CurrentOptions ()
16184,METHOD,leveldb.DBTest,TYPE_DECL,"DBImpl* dbfull() {
    return reinterpret_cast<DBImpl*>(db_);
  }",3,3,db\db_test.cc,leveldb.DBTest.dbfull,,false,258,260,dbfull,,,12,DBImpl leveldb.DBTest.dbfull ()
16192,METHOD,leveldb.DBTest,TYPE_DECL,"void Reopen(Options* options = NULL) {
    ASSERT_OK(TryReopen(options));
  }",3,4,db\db_test.cc,leveldb.DBTest.Reopen,,false,262,264,Reopen,,,13,void leveldb.DBTest.Reopen (Options*)
16214,METHOD,leveldb.DBTest,TYPE_DECL,"void Close() {
    delete db_;
    db_ = NULL;
  }",3,3,db\db_test.cc,leveldb.DBTest.Close,,false,266,269,Close,,,14,void leveldb.DBTest.Close ()
16223,METHOD,leveldb.DBTest,TYPE_DECL,"void DestroyAndReopen(Options* options = NULL) {
    delete db_;
    db_ = NULL;
    DestroyDB(dbname_, Options());
    ASSERT_OK(TryReopen(options));
  }",3,4,db\db_test.cc,leveldb.DBTest.DestroyAndReopen,,false,271,276,DestroyAndReopen,,,15,void leveldb.DBTest.DestroyAndReopen (Options*)
16253,METHOD,leveldb.DBTest,TYPE_DECL,"Status TryReopen(Options* options) {
    delete db_;
    db_ = NULL;
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts = CurrentOptions();
      opts.create_if_missing = true;
    }
    last_options_ = opts;

    return DB::Open(opts, dbname_, &db_);
  }",3,3,db\db_test.cc,leveldb.DBTest.TryReopen,,false,278,291,TryReopen,,,16,Status leveldb.DBTest.TryReopen (Options*)
16295,METHOD,leveldb.DBTest,TYPE_DECL,"Status Put(const std::string& k, const std::string& v) {
    return db_->Put(WriteOptions(), k, v);
  }",3,3,db\db_test.cc,leveldb.DBTest.Put,,false,293,295,Put,,,17,"Status leveldb.DBTest.Put (ANY,ANY)"
16309,METHOD,leveldb.DBTest,TYPE_DECL,"Status Delete(const std::string& k) {
    return db_->Delete(WriteOptions(), k);
  }",3,3,db\db_test.cc,leveldb.DBTest.Delete,,false,297,299,Delete,,,18,Status leveldb.DBTest.Delete (ANY)
16321,METHOD,leveldb.DBTest,TYPE_DECL,"std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {
    ReadOptions options;
    options.snapshot = snapshot;
    std::string result;
    Status s = db_->Get(options, k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",3,3,db\db_test.cc,leveldb.DBTest.Get,,false,301,312,Get,,,19,"string leveldb.DBTest.Get (ANY,Snapshot*)"
16371,METHOD,leveldb.DBTest,TYPE_DECL,"std::string Contents() {
    std::vector<std::string> forward;
    std::string result;
    Iterator* iter = db_->NewIterator(ReadOptions());
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      std::string s = IterStatus(iter);
      result.push_back('(');
      result.append(s);
      result.push_back(')');
      forward.push_back(s);
    }

    // Check reverse iteration results are the reverse of forward results
    size_t matched = 0;
    for (iter->SeekToLast(); iter->Valid(); iter->Prev()) {
      ASSERT_LT(matched, forward.size());
      ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1]);
      matched++;
    }
    ASSERT_EQ(matched, forward.size());

    delete iter;
    return result;
  }",3,6,db\db_test.cc,leveldb.DBTest.Contents,,false,316,339,Contents,,,20,string leveldb.DBTest.Contents ()
16531,METHOD,leveldb.DBTest,TYPE_DECL,"std::string AllEntriesFor(const Slice& user_key) {
    Iterator* iter = dbfull()->TEST_NewInternalIterator();
    InternalKey target(user_key, kMaxSequenceNumber, kTypeValue);
    iter->Seek(target.Encode());
    std::string result;
    if (!iter->status().ok()) {
      result = iter->status().ToString();
    } else {
      result = ""[ "";
      bool first = true;
      while (iter->Valid()) {
        ParsedInternalKey ikey;
        if (!ParseInternalKey(iter->key(), &ikey)) {
          result += ""CORRUPTED"";
        } else {
          if (last_options_.comparator->Compare(ikey.user_key, user_key) != 0) {
            break;
          }
          if (!first) {
            result += "", "";
          }
          first = false;
          switch (ikey.type) {
            case kTypeValue:
              result += iter->value().ToString();
              break;
            case kTypeDeletion:
              result += ""DEL"";
              break;
          }
        }
        iter->Next();
      ...",3,3,db\db_test.cc,leveldb.DBTest.AllEntriesFor,,false,341,381,AllEntriesFor,,,21,string leveldb.DBTest.AllEntriesFor (Slice)
16673,METHOD,leveldb.DBTest,TYPE_DECL,"int NumTableFilesAtLevel(int level) {
    std::string property;
    ASSERT_TRUE(
        db_->GetProperty(""leveldb.num-files-at-level"" + NumberToString(level),
                         &property));
    return atoi(property.c_str());
  }",3,4,db\db_test.cc,leveldb.DBTest.NumTableFilesAtLevel,,false,383,389,NumTableFilesAtLevel,,,22,int leveldb.DBTest.NumTableFilesAtLevel (int)
16709,METHOD,leveldb.DBTest,TYPE_DECL,"int TotalTableFiles() {
    int result = 0;
    for (int level = 0; level < config::kNumLevels; level++) {
      result += NumTableFilesAtLevel(level);
    }
    return result;
  }",3,3,db\db_test.cc,leveldb.DBTest.TotalTableFiles,,false,391,397,TotalTableFiles,,,23,int leveldb.DBTest.TotalTableFiles ()
16737,METHOD,leveldb.DBTest,TYPE_DECL,"std::string FilesPerLevel() {
    std::string result;
    int last_non_zero_offset = 0;
    for (int level = 0; level < config::kNumLevels; level++) {
      int f = NumTableFilesAtLevel(level);
      char buf[100];
      snprintf(buf, sizeof(buf), ""%s%d"", (level ? "","" : """"), f);
      result += buf;
      if (f > 0) {
        last_non_zero_offset = result.size();
      }
    }
    result.resize(last_non_zero_offset);
    return result;
  }",3,3,db\db_test.cc,leveldb.DBTest.FilesPerLevel,,false,400,414,FilesPerLevel,,,24,string leveldb.DBTest.FilesPerLevel ()
16797,METHOD,leveldb.DBTest,TYPE_DECL,"int CountFiles() {
    std::vector<std::string> files;
    env_->GetChildren(dbname_, &files);
    return static_cast<int>(files.size());
  }",3,3,db\db_test.cc,leveldb.DBTest.CountFiles,,false,416,420,CountFiles,,,25,int leveldb.DBTest.CountFiles ()
16824,METHOD,leveldb.DBTest,TYPE_DECL,"uint64_t Size(const Slice& start, const Slice& limit) {
    Range r(start, limit);
    uint64_t size;
    db_->GetApproximateSizes(&r, 1, &size);
    return size;
  }",3,3,db\db_test.cc,leveldb.DBTest.Size,,false,422,427,Size,,,26,"uint64_t leveldb.DBTest.Size (Slice,Slice)"
16846,METHOD,leveldb.DBTest,TYPE_DECL,"void Compact(const Slice& start, const Slice& limit) {
    db_->CompactRange(&start, &limit);
  }",3,3,db\db_test.cc,leveldb.DBTest.Compact,,false,429,431,Compact,,,27,"void leveldb.DBTest.Compact (Slice,Slice)"
16860,METHOD,leveldb.DBTest,TYPE_DECL,"void MakeTables(int n, const std::string& small, const std::string& large) {
    for (int i = 0; i < n; i++) {
      Put(small, ""begin"");
      Put(large, ""end"");
      dbfull()->TEST_CompactMemTable();
    }
  }",3,3,db\db_test.cc,leveldb.DBTest.MakeTables,,false,435,441,MakeTables,,,28,"void leveldb.DBTest.MakeTables (int,ANY,ANY)"
16889,METHOD,leveldb.DBTest,TYPE_DECL,"void FillLevels(const std::string& smallest, const std::string& largest) {
    MakeTables(config::kNumLevels, smallest, largest);
  }",3,3,db\db_test.cc,leveldb.DBTest.FillLevels,,false,445,447,FillLevels,,,29,"void leveldb.DBTest.FillLevels (ANY,ANY)"
16901,METHOD,leveldb.DBTest,TYPE_DECL,"void DumpFileCounts(const char* label) {
    fprintf(stderr, ""---\n%s:\n"", label);
    fprintf(stderr, ""maxoverlap: %lld\n"",
            static_cast<long long>(
                dbfull()->TEST_MaxNextLevelOverlappingBytes()));
    for (int level = 0; level < config::kNumLevels; level++) {
      int num = NumTableFilesAtLevel(level);
      if (num > 0) {
        fprintf(stderr, ""  level %3d : %d files\n"", level, num);
      }
    }
  }",3,3,db\db_test.cc,leveldb.DBTest.DumpFileCounts,,false,449,460,DumpFileCounts,,,30,void leveldb.DBTest.DumpFileCounts (char*)
16948,METHOD,leveldb.DBTest,TYPE_DECL,"std::string DumpSSTableList() {
    std::string property;
    db_->GetProperty(""leveldb.sstables"", &property);
    return property;
  }",3,3,db\db_test.cc,leveldb.DBTest.DumpSSTableList,,false,462,466,DumpSSTableList,,,31,string leveldb.DBTest.DumpSSTableList ()
16962,METHOD,leveldb.DBTest,TYPE_DECL,"std::string IterStatus(Iterator* iter) {
    std::string result;
    if (iter->Valid()) {
      result = iter->key().ToString() + ""->"" + iter->value().ToString();
    } else {
      result = ""(invalid)"";
    }
    return result;
  }",3,3,db\db_test.cc,leveldb.DBTest.IterStatus,,false,468,476,IterStatus,,,32,string leveldb.DBTest.IterStatus (Iterator*)
17000,METHOD,leveldb.DBTest,TYPE_DECL,"bool DeleteAnSSTFile() {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)));
        return true;
      }
    }
    return false;
  }",3,4,db\db_test.cc,leveldb.DBTest.DeleteAnSSTFile,,false,478,490,DeleteAnSSTFile,,,33,bool leveldb.DBTest.DeleteAnSSTFile ()
17088,METHOD,leveldb.DBTest,TYPE_DECL,"int RenameLDBToSST() {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    uint64_t number;
    FileType type;
    int files_renamed = 0;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type) && type == kTableFile) {
        const std::string from = TableFileName(dbname_, number);
        const std::string to = SSTTableFileName(dbname_, number);
        ASSERT_OK(env_->RenameFile(from, to));
        files_renamed++;
      }
    }
    return files_renamed;
  }",3,4,db\db_test.cc,leveldb.DBTest.RenameLDBToSST,,false,493,508,RenameLDBToSST,,,34,int leveldb.DBTest.RenameLDBToSST ()
17192,METHOD,leveldb._Test_Empty,TYPE_DECL,void void ();,1,19,db\db_test.cc,leveldb._Test_Empty._Run,,false,511,511,_Run,,,1,void leveldb._Test_Empty._Run ()
17196,METHOD,leveldb._Test_Empty,TYPE_DECL,"TEST(DBTest, Empty)",1,19,db\db_test.cc,leveldb._Test_Empty._RunIt,,false,511,511,_RunIt,,,2,void leveldb._Test_Empty._RunIt ()
17220,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, Empty) {
  do {
    ASSERT_TRUE(db_ != NULL);
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  } while (ChangeOptions());
}",1,19,db\db_test.cc,leveldb._Test_Empty._Run,,false,511,516,_Run,,,8,void leveldb._Test_Empty._Run ()
17264,METHOD,leveldb._Test_ReadWrite,TYPE_DECL,void void ();,1,23,db\db_test.cc,leveldb._Test_ReadWrite._Run,,false,518,518,_Run,,,1,void leveldb._Test_ReadWrite._Run ()
17268,METHOD,leveldb._Test_ReadWrite,TYPE_DECL,"TEST(DBTest, ReadWrite)",1,23,db\db_test.cc,leveldb._Test_ReadWrite._RunIt,,false,518,518,_RunIt,,,2,void leveldb._Test_ReadWrite._RunIt ()
17292,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, ReadWrite) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
  } while (ChangeOptions());
}",1,23,db\db_test.cc,leveldb._Test_ReadWrite._Run,,false,518,527,_Run,,,12,void leveldb._Test_ReadWrite._Run ()
17405,METHOD,leveldb._Test_PutDeleteGet,TYPE_DECL,void void ();,1,26,db\db_test.cc,leveldb._Test_PutDeleteGet._Run,,false,529,529,_Run,,,1,void leveldb._Test_PutDeleteGet._Run ()
17409,METHOD,leveldb._Test_PutDeleteGet,TYPE_DECL,"TEST(DBTest, PutDeleteGet)",1,26,db\db_test.cc,leveldb._Test_PutDeleteGet._RunIt,,false,529,529,_RunIt,,,2,void leveldb._Test_PutDeleteGet._RunIt ()
17433,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, PutDeleteGet) {
  do {
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    ASSERT_OK(db_->Delete(WriteOptions(), ""foo""));
    ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  } while (ChangeOptions());
}",1,26,db\db_test.cc,leveldb._Test_PutDeleteGet._Run,,false,529,538,_Run,,,16,void leveldb._Test_PutDeleteGet._Run ()
17557,METHOD,leveldb._Test_GetFromImmutableLayer,TYPE_DECL,void void ();,1,35,db\db_test.cc,leveldb._Test_GetFromImmutableLayer._Run,,false,540,540,_Run,,,1,void leveldb._Test_GetFromImmutableLayer._Run ()
17561,METHOD,leveldb._Test_GetFromImmutableLayer,TYPE_DECL,"TEST(DBTest, GetFromImmutableLayer)",1,35,db\db_test.cc,leveldb._Test_GetFromImmutableLayer._RunIt,,false,540,540,_RunIt,,,2,void leveldb._Test_GetFromImmutableLayer._RunIt ()
17585,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetFromImmutableLayer) {
  do {
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 100000;  // Small write buffer
    Reopen(&options);

    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_EQ(""v1"", Get(""foo""));

    env_->delay_data_sync_.Release_Store(env_);      // Block sync calls
    Put(""k1"", std::string(100000, 'x'));             // Fill memtable
    Put(""k2"", std::string(100000, 'y'));             // Trigger compaction
    ASSERT_EQ(""v1"", Get(""foo""));
    env_->delay_data_sync_.Release_Store(NULL);      // Release sync calls
  } while (ChangeOptions());
}",1,35,db\db_test.cc,leveldb._Test_GetFromImmutableLayer._Run,,false,540,556,_Run,,,20,void leveldb._Test_GetFromImmutableLayer._Run ()
17694,METHOD,leveldb._Test_GetFromVersions,TYPE_DECL,void void ();,1,29,db\db_test.cc,leveldb._Test_GetFromVersions._Run,,false,558,558,_Run,,,1,void leveldb._Test_GetFromVersions._Run ()
17698,METHOD,leveldb._Test_GetFromVersions,TYPE_DECL,"TEST(DBTest, GetFromVersions)",1,29,db\db_test.cc,leveldb._Test_GetFromVersions._RunIt,,false,558,558,_RunIt,,,2,void leveldb._Test_GetFromVersions._RunIt ()
17722,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetFromVersions) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v1"", Get(""foo""));
  } while (ChangeOptions());
}",1,29,db\db_test.cc,leveldb._Test_GetFromVersions._Run,,false,558,564,_Run,,,24,void leveldb._Test_GetFromVersions._Run ()
17769,METHOD,leveldb._Test_GetMemUsage,TYPE_DECL,void void ();,1,25,db\db_test.cc,leveldb._Test_GetMemUsage._Run,,false,566,566,_Run,,,1,void leveldb._Test_GetMemUsage._Run ()
17773,METHOD,leveldb._Test_GetMemUsage,TYPE_DECL,"TEST(DBTest, GetMemUsage)",1,25,db\db_test.cc,leveldb._Test_GetMemUsage._RunIt,,false,566,566,_RunIt,,,2,void leveldb._Test_GetMemUsage._RunIt ()
17797,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetMemUsage) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    std::string val;
    ASSERT_TRUE(db_->GetProperty(""leveldb.approximate-memory-usage"", &val));
    int mem_usage = atoi(val.c_str());
    ASSERT_GT(mem_usage, 0);
    ASSERT_LT(mem_usage, 5*1024*1024);
  } while (ChangeOptions());
}",1,25,db\db_test.cc,leveldb._Test_GetMemUsage._Run,,false,566,575,_Run,,,28,void leveldb._Test_GetMemUsage._Run ()
17888,METHOD,leveldb._Test_GetSnapshot,TYPE_DECL,void void ();,1,25,db\db_test.cc,leveldb._Test_GetSnapshot._Run,,false,577,577,_Run,,,1,void leveldb._Test_GetSnapshot._Run ()
17892,METHOD,leveldb._Test_GetSnapshot,TYPE_DECL,"TEST(DBTest, GetSnapshot)",1,25,db\db_test.cc,leveldb._Test_GetSnapshot._RunIt,,false,577,577,_RunIt,,,2,void leveldb._Test_GetSnapshot._RunIt ()
17916,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetSnapshot) {
  do {
    // Try with both a short key and a long key
    for (int i = 0; i < 2; i++) {
      std::string key = (i == 0) ? std::string(""foo"") : std::string(200, 'x');
      ASSERT_OK(Put(key, ""v1""));
      const Snapshot* s1 = db_->GetSnapshot();
      ASSERT_OK(Put(key, ""v2""));
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      dbfull()->TEST_CompactMemTable();
      ASSERT_EQ(""v2"", Get(key));
      ASSERT_EQ(""v1"", Get(key, s1));
      db_->ReleaseSnapshot(s1);
    }
  } while (ChangeOptions());
}",1,25,db\db_test.cc,leveldb._Test_GetSnapshot._Run,,false,577,593,_Run,,,32,void leveldb._Test_GetSnapshot._Run ()
18076,METHOD,leveldb._Test_GetLevel0Ordering,TYPE_DECL,void void ();,1,31,db\db_test.cc,leveldb._Test_GetLevel0Ordering._Run,,false,595,595,_Run,,,1,void leveldb._Test_GetLevel0Ordering._Run ()
18080,METHOD,leveldb._Test_GetLevel0Ordering,TYPE_DECL,"TEST(DBTest, GetLevel0Ordering)",1,31,db\db_test.cc,leveldb._Test_GetLevel0Ordering._RunIt,,false,595,595,_RunIt,,,2,void leveldb._Test_GetLevel0Ordering._RunIt ()
18104,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetLevel0Ordering) {
  do {
    // Check that we process level-0 files in correct order.  The code
    // below generates two level-0 files where the earlier one comes
    // before the later one in the level-0 file list since the earlier
    // one has a smaller ""smallest"" key.
    ASSERT_OK(Put(""bar"", ""b""));
    ASSERT_OK(Put(""foo"", ""v1""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""foo"", ""v2""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  } while (ChangeOptions());
}",1,31,db\db_test.cc,leveldb._Test_GetLevel0Ordering._Run,,false,595,608,_Run,,,36,void leveldb._Test_GetLevel0Ordering._Run ()
18187,METHOD,leveldb._Test_GetOrderedByLevels,TYPE_DECL,void void ();,1,32,db\db_test.cc,leveldb._Test_GetOrderedByLevels._Run,,false,610,610,_Run,,,1,void leveldb._Test_GetOrderedByLevels._Run ()
18191,METHOD,leveldb._Test_GetOrderedByLevels,TYPE_DECL,"TEST(DBTest, GetOrderedByLevels)",1,32,db\db_test.cc,leveldb._Test_GetOrderedByLevels._RunIt,,false,610,610,_RunIt,,,2,void leveldb._Test_GetOrderedByLevels._RunIt ()
18215,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetOrderedByLevels) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    Compact(""a"", ""z"");
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v2""));
    ASSERT_EQ(""v2"", Get(""foo""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""v2"", Get(""foo""));
  } while (ChangeOptions());
}",1,32,db\db_test.cc,leveldb._Test_GetOrderedByLevels._Run,,false,610,620,_Run,,,40,void leveldb._Test_GetOrderedByLevels._Run ()
18319,METHOD,leveldb._Test_GetPicksCorrectFile,TYPE_DECL,void void ();,1,33,db\db_test.cc,leveldb._Test_GetPicksCorrectFile._Run,,false,622,622,_Run,,,1,void leveldb._Test_GetPicksCorrectFile._Run ()
18323,METHOD,leveldb._Test_GetPicksCorrectFile,TYPE_DECL,"TEST(DBTest, GetPicksCorrectFile)",1,33,db\db_test.cc,leveldb._Test_GetPicksCorrectFile._RunIt,,false,622,622,_RunIt,,,2,void leveldb._Test_GetPicksCorrectFile._RunIt ()
18347,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetPicksCorrectFile) {
  do {
    // Arrange to have multiple files in a non-level-0 level.
    ASSERT_OK(Put(""a"", ""va""));
    Compact(""a"", ""b"");
    ASSERT_OK(Put(""x"", ""vx""));
    Compact(""x"", ""y"");
    ASSERT_OK(Put(""f"", ""vf""));
    Compact(""f"", ""g"");
    ASSERT_EQ(""va"", Get(""a""));
    ASSERT_EQ(""vf"", Get(""f""));
    ASSERT_EQ(""vx"", Get(""x""));
  } while (ChangeOptions());
}",1,33,db\db_test.cc,leveldb._Test_GetPicksCorrectFile._Run,,false,622,635,_Run,,,44,void leveldb._Test_GetPicksCorrectFile._Run ()
18469,METHOD,leveldb._Test_GetEncountersEmptyLevel,TYPE_DECL,void void ();,1,37,db\db_test.cc,leveldb._Test_GetEncountersEmptyLevel._Run,,false,637,637,_Run,,,1,void leveldb._Test_GetEncountersEmptyLevel._Run ()
18473,METHOD,leveldb._Test_GetEncountersEmptyLevel,TYPE_DECL,"TEST(DBTest, GetEncountersEmptyLevel)",1,37,db\db_test.cc,leveldb._Test_GetEncountersEmptyLevel._RunIt,,false,637,637,_RunIt,,,2,void leveldb._Test_GetEncountersEmptyLevel._RunIt ()
18497,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, GetEncountersEmptyLevel) {
  do {
    // Arrange for the following to happen:
    //   * sstable A in level 0
    //   * nothing in level 1
    //   * sstable B in level 2
    // Then do enough Get() calls to arrange for an automatic compaction
    // of sstable A.  A bug would cause the compaction to be marked as
    // occurring at level 1 (instead of the correct level 0).

    // Step 1: First place sstables in levels 0 and 2
    int compaction_count = 0;
    while (NumTableFilesAtLevel(0) == 0 ||
           NumTableFilesAtLevel(2) == 0) {
      ASSERT_LE(compaction_count, 100) << ""could not fill levels 0 and 2"";
      compaction_count++;
      Put(""a"", ""begin"");
      Put(""z"", ""end"");
      dbfull()->TEST_CompactMemTable();
    }

    // Step 2: clear level 1 if necessary.
    dbfull()->TEST_CompactRange(1, NULL, NULL);
    ASSERT_EQ(NumTableFilesAtLevel(0), 1);
    ASSERT_EQ(NumTableFilesAtLevel(1), 0);
    ASSERT_EQ(NumTableFilesAtLevel(2), 1);

    // Step 3: rea...",1,37,db\db_test.cc,leveldb._Test_GetEncountersEmptyLevel._Run,,false,637,674,_Run,,,48,void leveldb._Test_GetEncountersEmptyLevel._Run ()
18667,METHOD,leveldb._Test_IterEmpty,TYPE_DECL,void void ();,1,23,db\db_test.cc,leveldb._Test_IterEmpty._Run,,false,676,676,_Run,,,1,void leveldb._Test_IterEmpty._Run ()
18671,METHOD,leveldb._Test_IterEmpty,TYPE_DECL,"TEST(DBTest, IterEmpty)",1,23,db\db_test.cc,leveldb._Test_IterEmpty._RunIt,,false,676,676,_RunIt,,,2,void leveldb._Test_IterEmpty._RunIt ()
18695,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, IterEmpty) {
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""foo"");
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  delete iter;
}",1,23,db\db_test.cc,leveldb._Test_IterEmpty._Run,,false,676,689,_Run,,,52,void leveldb._Test_IterEmpty._Run ()
18780,METHOD,leveldb._Test_IterSingle,TYPE_DECL,void void ();,1,24,db\db_test.cc,leveldb._Test_IterSingle._Run,,false,691,691,_Run,,,1,void leveldb._Test_IterSingle._Run ()
18784,METHOD,leveldb._Test_IterSingle,TYPE_DECL,"TEST(DBTest, IterSingle)",1,24,db\db_test.cc,leveldb._Test_IterSingle._RunIt,,false,691,691,_RunIt,,,2,void leveldb._Test_IterSingle._RunIt ()
18808,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, IterSingle) {
  ASSERT_OK(Put(""a"", ""va""));
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek("""");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""a"");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek(""b"");
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  delete iter;
}",1,24,db\db_test.cc,leveldb._Test_IterSingle._Run,,false,691,727,_Run,,,56,void leveldb._Test_IterSingle._Run ()
19141,METHOD,leveldb._Test_IterMulti,TYPE_DECL,void void ();,1,23,db\db_test.cc,leveldb._Test_IterMulti._Run,,false,729,729,_Run,,,1,void leveldb._Test_IterMulti._Run ()
19145,METHOD,leveldb._Test_IterMulti,TYPE_DECL,"TEST(DBTest, IterMulti)",1,23,db\db_test.cc,leveldb._Test_IterMulti._RunIt,,false,729,729,_RunIt,,,2,void leveldb._Test_IterMulti._RunIt ()
19169,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, IterMulti) {
  ASSERT_OK(Put(""a"", ""va""));
  ASSERT_OK(Put(""b"", ""vb""));
  ASSERT_OK(Put(""c"", ""vc""));
  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""b->vb"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""b->vb"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");
  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->Seek("""");
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Seek(""a"");
  ASSERT_EQ(IterStatus(iter), ""a->va"")...",1,23,db\db_test.cc,leveldb._Test_IterMulti._Run,,false,729,810,_Run,,,60,void leveldb._Test_IterMulti._Run ()
19963,METHOD,leveldb._Test_IterSmallAndLargeMix,TYPE_DECL,void void ();,1,34,db\db_test.cc,leveldb._Test_IterSmallAndLargeMix._Run,,false,812,812,_Run,,,1,void leveldb._Test_IterSmallAndLargeMix._Run ()
19967,METHOD,leveldb._Test_IterSmallAndLargeMix,TYPE_DECL,"TEST(DBTest, IterSmallAndLargeMix)",1,34,db\db_test.cc,leveldb._Test_IterSmallAndLargeMix._RunIt,,false,812,812,_RunIt,,,2,void leveldb._Test_IterSmallAndLargeMix._RunIt ()
19991,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, IterSmallAndLargeMix) {
  ASSERT_OK(Put(""a"", ""va""));
  ASSERT_OK(Put(""b"", std::string(100000, 'b')));
  ASSERT_OK(Put(""c"", ""vc""));
  ASSERT_OK(Put(""d"", std::string(100000, 'd')));
  ASSERT_OK(Put(""e"", std::string(100000, 'e')));

  Iterator* iter = db_->NewIterator(ReadOptions());

  iter->SeekToFirst();
  ASSERT_EQ(IterStatus(iter), ""a->va"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""b->"" + std::string(100000, 'b'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""d->"" + std::string(100000, 'd'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""e->"" + std::string(100000, 'e'));
  iter->Next();
  ASSERT_EQ(IterStatus(iter), ""(invalid)"");

  iter->SeekToLast();
  ASSERT_EQ(IterStatus(iter), ""e->"" + std::string(100000, 'e'));
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""d->"" + std::string(100000, 'd'));
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""c->vc"");
  iter->Prev();
  ASSERT_EQ(IterStatus(iter), ""b->"" + ...",1,34,db\db_test.cc,leveldb._Test_IterSmallAndLargeMix._Run,,false,812,848,_Run,,,64,void leveldb._Test_IterSmallAndLargeMix._Run ()
20413,METHOD,leveldb._Test_IterMultiWithDelete,TYPE_DECL,void void ();,1,33,db\db_test.cc,leveldb._Test_IterMultiWithDelete._Run,,false,850,850,_Run,,,1,void leveldb._Test_IterMultiWithDelete._Run ()
20417,METHOD,leveldb._Test_IterMultiWithDelete,TYPE_DECL,"TEST(DBTest, IterMultiWithDelete)",1,33,db\db_test.cc,leveldb._Test_IterMultiWithDelete._RunIt,,false,850,850,_RunIt,,,2,void leveldb._Test_IterMultiWithDelete._RunIt ()
20441,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, IterMultiWithDelete) {
  do {
    ASSERT_OK(Put(""a"", ""va""));
    ASSERT_OK(Put(""b"", ""vb""));
    ASSERT_OK(Put(""c"", ""vc""));
    ASSERT_OK(Delete(""b""));
    ASSERT_EQ(""NOT_FOUND"", Get(""b""));

    Iterator* iter = db_->NewIterator(ReadOptions());
    iter->Seek(""c"");
    ASSERT_EQ(IterStatus(iter), ""c->vc"");
    iter->Prev();
    ASSERT_EQ(IterStatus(iter), ""a->va"");
    delete iter;
  } while (ChangeOptions());
}",1,33,db\db_test.cc,leveldb._Test_IterMultiWithDelete._Run,,false,850,865,_Run,,,68,void leveldb._Test_IterMultiWithDelete._Run ()
20590,METHOD,leveldb._Test_Recover,TYPE_DECL,void void ();,1,21,db\db_test.cc,leveldb._Test_Recover._Run,,false,867,867,_Run,,,1,void leveldb._Test_Recover._Run ()
20594,METHOD,leveldb._Test_Recover,TYPE_DECL,"TEST(DBTest, Recover)",1,21,db\db_test.cc,leveldb._Test_Recover._RunIt,,false,867,867,_RunIt,,,2,void leveldb._Test_Recover._RunIt ()
20618,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, Recover) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""baz"", ""v5""));

    Reopen();
    ASSERT_EQ(""v1"", Get(""foo""));

    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v5"", Get(""baz""));
    ASSERT_OK(Put(""bar"", ""v2""));
    ASSERT_OK(Put(""foo"", ""v3""));

    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
    ASSERT_OK(Put(""foo"", ""v4""));
    ASSERT_EQ(""v4"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(""v5"", Get(""baz""));
  } while (ChangeOptions());
}",1,21,db\db_test.cc,leveldb._Test_Recover._Run,,false,867,887,_Run,,,72,void leveldb._Test_Recover._Run ()
20841,METHOD,leveldb._Test_RecoveryWithEmptyLog,TYPE_DECL,void void ();,1,34,db\db_test.cc,leveldb._Test_RecoveryWithEmptyLog._Run,,false,889,889,_Run,,,1,void leveldb._Test_RecoveryWithEmptyLog._Run ()
20845,METHOD,leveldb._Test_RecoveryWithEmptyLog,TYPE_DECL,"TEST(DBTest, RecoveryWithEmptyLog)",1,34,db\db_test.cc,leveldb._Test_RecoveryWithEmptyLog._RunIt,,false,889,889,_RunIt,,,2,void leveldb._Test_RecoveryWithEmptyLog._RunIt ()
20869,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, RecoveryWithEmptyLog) {
  do {
    ASSERT_OK(Put(""foo"", ""v1""));
    ASSERT_OK(Put(""foo"", ""v2""));
    Reopen();
    Reopen();
    ASSERT_OK(Put(""foo"", ""v3""));
    Reopen();
    ASSERT_EQ(""v3"", Get(""foo""));
  } while (ChangeOptions());
}",1,34,db\db_test.cc,leveldb._Test_RecoveryWithEmptyLog._Run,,false,889,899,_Run,,,76,void leveldb._Test_RecoveryWithEmptyLog._Run ()
20947,METHOD,leveldb._Test_RecoverDuringMemtableCompaction,TYPE_DECL,void void ();,1,45,db\db_test.cc,leveldb._Test_RecoverDuringMemtableCompaction._Run,,false,903,903,_Run,,,1,void leveldb._Test_RecoverDuringMemtableCompaction._Run ()
20951,METHOD,leveldb._Test_RecoverDuringMemtableCompaction,TYPE_DECL,"TEST(DBTest, RecoverDuringMemtableCompaction)",1,45,db\db_test.cc,leveldb._Test_RecoverDuringMemtableCompaction._RunIt,,false,903,903,_RunIt,,,2,void leveldb._Test_RecoverDuringMemtableCompaction._RunIt ()
20975,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, RecoverDuringMemtableCompaction) {
  do {
    Options options = CurrentOptions();
    options.env = env_;
    options.write_buffer_size = 1000000;
    Reopen(&options);

    // Trigger a long memtable compaction and reopen the database during it
    ASSERT_OK(Put(""foo"", ""v1""));                         // Goes to 1st log file
    ASSERT_OK(Put(""big1"", std::string(10000000, 'x')));  // Fills memtable
    ASSERT_OK(Put(""big2"", std::string(1000, 'y')));      // Triggers compaction
    ASSERT_OK(Put(""bar"", ""v2""));                         // Goes to new log file

    Reopen(&options);
    ASSERT_EQ(""v1"", Get(""foo""));
    ASSERT_EQ(""v2"", Get(""bar""));
    ASSERT_EQ(std::string(10000000, 'x'), Get(""big1""));
    ASSERT_EQ(std::string(1000, 'y'), Get(""big2""));
  } while (ChangeOptions());
}",1,45,db\db_test.cc,leveldb._Test_RecoverDuringMemtableCompaction._Run,,false,903,922,_Run,,,80,void leveldb._Test_RecoverDuringMemtableCompaction._Run ()
21160,METHOD,db\db_test.cc:<global>,TYPE_DECL,"static std::string Key(int i) {
  char buf[100];
  snprintf(buf, sizeof(buf), ""key%06d"", i);
  return std::string(buf);
}",1,1,db\db_test.cc,leveldb.Key,,false,924,928,Key,,,81,string leveldb.Key (int)
21179,METHOD,leveldb._Test_MinorCompactionsHappen,TYPE_DECL,void void ();,1,36,db\db_test.cc,leveldb._Test_MinorCompactionsHappen._Run,,false,930,930,_Run,,,1,void leveldb._Test_MinorCompactionsHappen._Run ()
21183,METHOD,leveldb._Test_MinorCompactionsHappen,TYPE_DECL,"TEST(DBTest, MinorCompactionsHappen)",1,36,db\db_test.cc,leveldb._Test_MinorCompactionsHappen._RunIt,,false,930,930,_RunIt,,,2,void leveldb._Test_MinorCompactionsHappen._RunIt ()
21207,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, MinorCompactionsHappen) {
  Options options = CurrentOptions();
  options.write_buffer_size = 10000;
  Reopen(&options);

  const int N = 500;

  int starting_num_tables = TotalTableFiles();
  for (int i = 0; i < N; i++) {
    ASSERT_OK(Put(Key(i), Key(i) + std::string(1000, 'v')));
  }
  int ending_num_tables = TotalTableFiles();
  ASSERT_GT(ending_num_tables, starting_num_tables);

  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }

  Reopen();

  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i) + std::string(1000, 'v'), Get(Key(i)));
  }
}",1,36,db\db_test.cc,leveldb._Test_MinorCompactionsHappen._Run,,false,930,953,_Run,,,85,void leveldb._Test_MinorCompactionsHappen._Run ()
21371,METHOD,leveldb._Test_RecoverWithLargeLog,TYPE_DECL,void void ();,1,33,db\db_test.cc,leveldb._Test_RecoverWithLargeLog._Run,,false,955,955,_Run,,,1,void leveldb._Test_RecoverWithLargeLog._Run ()
21375,METHOD,leveldb._Test_RecoverWithLargeLog,TYPE_DECL,"TEST(DBTest, RecoverWithLargeLog)",1,33,db\db_test.cc,leveldb._Test_RecoverWithLargeLog._RunIt,,false,955,955,_RunIt,,,2,void leveldb._Test_RecoverWithLargeLog._RunIt ()
21399,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, RecoverWithLargeLog) {
  {
    Options options = CurrentOptions();
    Reopen(&options);
    ASSERT_OK(Put(""big1"", std::string(200000, '1')));
    ASSERT_OK(Put(""big2"", std::string(200000, '2')));
    ASSERT_OK(Put(""small3"", std::string(10, '3')));
    ASSERT_OK(Put(""small4"", std::string(10, '4')));
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  }

  // Make sure that if we re-open with a small write buffer size that
  // we flush table files in the middle of a large log file.
  Options options = CurrentOptions();
  options.write_buffer_size = 100000;
  Reopen(&options);
  ASSERT_EQ(NumTableFilesAtLevel(0), 3);
  ASSERT_EQ(std::string(200000, '1'), Get(""big1""));
  ASSERT_EQ(std::string(200000, '2'), Get(""big2""));
  ASSERT_EQ(std::string(10, '3'), Get(""small3""));
  ASSERT_EQ(std::string(10, '4'), Get(""small4""));
  ASSERT_GT(NumTableFilesAtLevel(0), 1);
}",1,33,db\db_test.cc,leveldb._Test_RecoverWithLargeLog._Run,,false,955,977,_Run,,,89,void leveldb._Test_RecoverWithLargeLog._Run ()
21657,METHOD,leveldb._Test_CompactionsGenerateMultipleFiles,TYPE_DECL,void void ();,1,46,db\db_test.cc,leveldb._Test_CompactionsGenerateMultipleFiles._Run,,false,979,979,_Run,,,1,void leveldb._Test_CompactionsGenerateMultipleFiles._Run ()
21661,METHOD,leveldb._Test_CompactionsGenerateMultipleFiles,TYPE_DECL,"TEST(DBTest, CompactionsGenerateMultipleFiles)",1,46,db\db_test.cc,leveldb._Test_CompactionsGenerateMultipleFiles._RunIt,,false,979,979,_RunIt,,,2,void leveldb._Test_CompactionsGenerateMultipleFiles._RunIt ()
21685,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, CompactionsGenerateMultipleFiles) {
  Options options = CurrentOptions();
  options.write_buffer_size = 100000000;        // Large write buffer
  Reopen(&options);

  Random rnd(301);

  // Write 8MB (80 values, each 100K)
  ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  std::vector<std::string> values;
  for (int i = 0; i < 80; i++) {
    values.push_back(RandomString(&rnd, 100000));
    ASSERT_OK(Put(Key(i), values[i]));
  }

  // Reopening moves updates to level-0
  Reopen(&options);
  dbfull()->TEST_CompactRange(0, NULL, NULL);

  ASSERT_EQ(NumTableFilesAtLevel(0), 0);
  ASSERT_GT(NumTableFilesAtLevel(1), 1);
  for (int i = 0; i < 80; i++) {
    ASSERT_EQ(Get(Key(i)), values[i]);
  }
}",1,46,db\db_test.cc,leveldb._Test_CompactionsGenerateMultipleFiles._Run,,false,979,1003,_Run,,,93,void leveldb._Test_CompactionsGenerateMultipleFiles._Run ()
21857,METHOD,leveldb._Test_RepeatedWritesToSameKey,TYPE_DECL,void void ();,1,37,db\db_test.cc,leveldb._Test_RepeatedWritesToSameKey._Run,,false,1005,1005,_Run,,,1,void leveldb._Test_RepeatedWritesToSameKey._Run ()
21861,METHOD,leveldb._Test_RepeatedWritesToSameKey,TYPE_DECL,"TEST(DBTest, RepeatedWritesToSameKey)",1,37,db\db_test.cc,leveldb._Test_RepeatedWritesToSameKey._RunIt,,false,1005,1005,_RunIt,,,2,void leveldb._Test_RepeatedWritesToSameKey._RunIt ()
21885,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, RepeatedWritesToSameKey) {
  Options options = CurrentOptions();
  options.env = env_;
  options.write_buffer_size = 100000;  // Small write buffer
  Reopen(&options);

  // We must have at most one file per level except for level-0,
  // which may have up to kL0_StopWritesTrigger files.
  const int kMaxFiles = config::kNumLevels + config::kL0_StopWritesTrigger;

  Random rnd(301);
  std::string value = RandomString(&rnd, 2 * options.write_buffer_size);
  for (int i = 0; i < 5 * kMaxFiles; i++) {
    Put(""key"", value);
    ASSERT_LE(TotalTableFiles(), kMaxFiles);
    fprintf(stderr, ""after %d: %d files\n"", int(i+1), TotalTableFiles());
  }
}",1,37,db\db_test.cc,leveldb._Test_RepeatedWritesToSameKey._Run,,false,1005,1022,_Run,,,97,void leveldb._Test_RepeatedWritesToSameKey._Run ()
21974,METHOD,leveldb._Test_SparseMerge,TYPE_DECL,void void ();,1,25,db\db_test.cc,leveldb._Test_SparseMerge._Run,,false,1024,1024,_Run,,,1,void leveldb._Test_SparseMerge._Run ()
21978,METHOD,leveldb._Test_SparseMerge,TYPE_DECL,"TEST(DBTest, SparseMerge)",1,25,db\db_test.cc,leveldb._Test_SparseMerge._RunIt,,false,1024,1024,_RunIt,,,2,void leveldb._Test_SparseMerge._RunIt ()
22002,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, SparseMerge) {
  Options options = CurrentOptions();
  options.compression = kNoCompression;
  Reopen(&options);

  FillLevels(""A"", ""Z"");

  // Suppose there is:
  //    small amount of data with prefix A
  //    large amount of data with prefix B
  //    small amount of data with prefix C
  // and that recent updates have made small changes to all three prefixes.
  // Check that we do not do a compaction that merges all of B in one shot.
  const std::string value(1000, 'x');
  Put(""A"", ""va"");
  // Write approximately 100MB of ""B"" values
  for (int i = 0; i < 100000; i++) {
    char key[100];
    snprintf(key, sizeof(key), ""B%010d"", i);
    Put(key, value);
  }
  Put(""C"", ""vc"");
  dbfull()->TEST_CompactMemTable();
  dbfull()->TEST_CompactRange(0, NULL, NULL);

  // Make sparse update
  Put(""A"",    ""va2"");
  Put(""B100"", ""bvalue2"");
  Put(""C"",    ""vc2"");
  dbfull()->TEST_CompactMemTable();

  // Compactions should not cause us to create a situation where
  // a file overl...",1,25,db\db_test.cc,leveldb._Test_SparseMerge._Run,,false,1024,1062,_Run,,,101,void leveldb._Test_SparseMerge._Run ()
22163,METHOD,db\db_test.cc:<global>,TYPE_DECL,"static bool Between(uint64_t val, uint64_t low, uint64_t high) {
  bool result = (val >= low) && (val <= high);
  if (!result) {
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }
  return result;
}",1,1,db\db_test.cc,leveldb.Between,,false,1064,1073,Between,,,102,"bool leveldb.Between (uint64_t,uint64_t,uint64_t)"
22199,METHOD,leveldb._Test_ApproximateSizes,TYPE_DECL,void void ();,1,30,db\db_test.cc,leveldb._Test_ApproximateSizes._Run,,false,1075,1075,_Run,,,1,void leveldb._Test_ApproximateSizes._Run ()
22203,METHOD,leveldb._Test_ApproximateSizes,TYPE_DECL,"TEST(DBTest, ApproximateSizes)",1,30,db\db_test.cc,leveldb._Test_ApproximateSizes._RunIt,,false,1075,1075,_RunIt,,,2,void leveldb._Test_ApproximateSizes._RunIt ()
22227,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, ApproximateSizes) {
  do {
    Options options = CurrentOptions();
    options.write_buffer_size = 100000000;        // Large write buffer
    options.compression = kNoCompression;
    DestroyAndReopen();

    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));
    Reopen(&options);
    ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0));

    // Write 8MB (80 values, each 100K)
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    const int N = 80;
    static const int S1 = 100000;
    static const int S2 = 105000;  // Allow some expansion from metadata
    Random rnd(301);
    for (int i = 0; i < N; i++) {
      ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)));
    }

    // 0 because GetApproximateSizes() does not account for memtable space
    ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0));

    if (options.reuse_logs) {
      // Recovery will reuse memtable, and GetApproximateSizes() does not
      // account for memtable usage;
      Reopen(&options);
      ASSERT_TRUE(Between(Size("""", Ke...",1,30,db\db_test.cc,leveldb._Test_ApproximateSizes._Run,,false,1075,1131,_Run,,,106,void leveldb._Test_ApproximateSizes._Run ()
22654,METHOD,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge,TYPE_DECL,void void ();,1,49,db\db_test.cc,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._Run,,false,1133,1133,_Run,,,1,void leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._Run ()
22658,METHOD,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge,TYPE_DECL,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",1,49,db\db_test.cc,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._RunIt,,false,1133,1133,_RunIt,,,2,void leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._RunIt ()
22682,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge) {
  do {
    Options options = CurrentOptions();
    options.compression = kNoCompression;
    Reopen();

    Random rnd(301);
    std::string big1 = RandomString(&rnd, 100000);
    ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(2), big1));
    ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(4), big1));
    ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)));
    ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)));
    ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)));

    if (options.reuse_logs) {
      // Need to force a memtable compaction since recovery does not do so.
      ASSERT_OK(dbfull()->TEST_CompactMemTable());
    }

    // Check sizes across recovery by reopening a few times
    for (int run = 0; run < 3; run++) {
      Reopen(&options);

      ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0));
      ASSERT_TRUE(Between(Si...",1,49,db\db_test.cc,leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._Run,,false,1133,1174,_Run,,,110,void leveldb._Test_ApproximateSizes_MixOfSmallAndLarge._Run ()
23123,METHOD,leveldb._Test_IteratorPinsRef,TYPE_DECL,void void ();,1,29,db\db_test.cc,leveldb._Test_IteratorPinsRef._Run,,false,1176,1176,_Run,,,1,void leveldb._Test_IteratorPinsRef._Run ()
23127,METHOD,leveldb._Test_IteratorPinsRef,TYPE_DECL,"TEST(DBTest, IteratorPinsRef)",1,29,db\db_test.cc,leveldb._Test_IteratorPinsRef._RunIt,,false,1176,1176,_RunIt,,,2,void leveldb._Test_IteratorPinsRef._RunIt ()
23151,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, IteratorPinsRef) {
  Put(""foo"", ""hello"");

  // Get iterator that will yield the current contents of the DB.
  Iterator* iter = db_->NewIterator(ReadOptions());

  // Write to force compactions
  Put(""foo"", ""newvalue1"");
  for (int i = 0; i < 100; i++) {
    ASSERT_OK(Put(Key(i), Key(i) + std::string(100000, 'v'))); // 100K values
  }
  Put(""foo"", ""newvalue2"");

  iter->SeekToFirst();
  ASSERT_TRUE(iter->Valid());
  ASSERT_EQ(""foo"", iter->key().ToString());
  ASSERT_EQ(""hello"", iter->value().ToString());
  iter->Next();
  ASSERT_TRUE(!iter->Valid());
  delete iter;
}",1,29,db\db_test.cc,leveldb._Test_IteratorPinsRef._Run,,false,1176,1196,_Run,,,114,void leveldb._Test_IteratorPinsRef._Run ()
23324,METHOD,leveldb._Test_Snapshot,TYPE_DECL,void void ();,1,22,db\db_test.cc,leveldb._Test_Snapshot._Run,,false,1198,1198,_Run,,,1,void leveldb._Test_Snapshot._Run ()
23328,METHOD,leveldb._Test_Snapshot,TYPE_DECL,"TEST(DBTest, Snapshot)",1,22,db\db_test.cc,leveldb._Test_Snapshot._RunIt,,false,1198,1198,_RunIt,,,2,void leveldb._Test_Snapshot._RunIt ()
23352,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, Snapshot) {
  do {
    Put(""foo"", ""v1"");
    const Snapshot* s1 = db_->GetSnapshot();
    Put(""foo"", ""v2"");
    const Snapshot* s2 = db_->GetSnapshot();
    Put(""foo"", ""v3"");
    const Snapshot* s3 = db_->GetSnapshot();

    Put(""foo"", ""v4"");
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v3"", Get(""foo"", s3));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s3);
    ASSERT_EQ(""v1"", Get(""foo"", s1));
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s1);
    ASSERT_EQ(""v2"", Get(""foo"", s2));
    ASSERT_EQ(""v4"", Get(""foo""));

    db_->ReleaseSnapshot(s2);
    ASSERT_EQ(""v4"", Get(""foo""));
  } while (ChangeOptions());
}",1,22,db\db_test.cc,leveldb._Test_Snapshot._Run,,false,1198,1225,_Run,,,118,void leveldb._Test_Snapshot._Run ()
23592,METHOD,leveldb._Test_HiddenValuesAreRemoved,TYPE_DECL,void void ();,1,36,db\db_test.cc,leveldb._Test_HiddenValuesAreRemoved._Run,,false,1227,1227,_Run,,,1,void leveldb._Test_HiddenValuesAreRemoved._Run ()
23596,METHOD,leveldb._Test_HiddenValuesAreRemoved,TYPE_DECL,"TEST(DBTest, HiddenValuesAreRemoved)",1,36,db\db_test.cc,leveldb._Test_HiddenValuesAreRemoved._RunIt,,false,1227,1227,_RunIt,,,2,void leveldb._Test_HiddenValuesAreRemoved._RunIt ()
23620,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, HiddenValuesAreRemoved) {
  do {
    Random rnd(301);
    FillLevels(""a"", ""z"");

    std::string big = RandomString(&rnd, 50000);
    Put(""foo"", big);
    Put(""pastfoo"", ""v"");
    const Snapshot* snapshot = db_->GetSnapshot();
    Put(""foo"", ""tiny"");
    Put(""pastfoo2"", ""v2"");        // Advance sequence number one more

    ASSERT_OK(dbfull()->TEST_CompactMemTable());
    ASSERT_GT(NumTableFilesAtLevel(0), 0);

    ASSERT_EQ(big, Get(""foo"", snapshot));
    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 50000, 60000));
    db_->ReleaseSnapshot(snapshot);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny, "" + big + "" ]"");
    Slice x(""x"");
    dbfull()->TEST_CompactRange(0, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");
    ASSERT_EQ(NumTableFilesAtLevel(0), 0);
    ASSERT_GE(NumTableFilesAtLevel(1), 1);
    dbfull()->TEST_CompactRange(1, NULL, &x);
    ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"");

    ASSERT_TRUE(Between(Size("""", ""pastfoo""), 0, 1000));
  } while (Change...",1,36,db\db_test.cc,leveldb._Test_HiddenValuesAreRemoved._Run,,false,1227,1256,_Run,,,122,void leveldb._Test_HiddenValuesAreRemoved._Run ()
23878,METHOD,leveldb._Test_DeletionMarkers1,TYPE_DECL,void void ();,1,30,db\db_test.cc,leveldb._Test_DeletionMarkers1._Run,,false,1258,1258,_Run,,,1,void leveldb._Test_DeletionMarkers1._Run ()
23882,METHOD,leveldb._Test_DeletionMarkers1,TYPE_DECL,"TEST(DBTest, DeletionMarkers1)",1,30,db\db_test.cc,leveldb._Test_DeletionMarkers1._RunIt,,false,1258,1258,_RunIt,,,2,void leveldb._Test_DeletionMarkers1._RunIt ()
23906,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, DeletionMarkers1) {
  Put(""foo"", ""v1"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level

  // Place a table at level last-1 to prevent merging with preceding mutation
  Put(""a"", ""begin"");
  Put(""z"", ""end"");
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);
  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);

  Delete(""foo"");
  Put(""foo"", ""v2"");
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"");
  Slice z(""z"");
  dbfull()->TEST_CompactRange(last-2, NULL, &z);
  // DEL eliminated, but v1 remains because we aren't compacting that level
  // (DEL can be eliminated because v2 hides v1).
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, v1 ]"");
  dbfull()->TEST_CompactRange(last-1, NULL, NULL);
  // Merging l...",1,30,db\db_test.cc,leveldb._Test_DeletionMarkers1._Run,,false,1258,1285,_Run,,,126,void leveldb._Test_DeletionMarkers1._Run ()
24128,METHOD,leveldb._Test_DeletionMarkers2,TYPE_DECL,void void ();,1,30,db\db_test.cc,leveldb._Test_DeletionMarkers2._Run,,false,1287,1287,_Run,,,1,void leveldb._Test_DeletionMarkers2._Run ()
24132,METHOD,leveldb._Test_DeletionMarkers2,TYPE_DECL,"TEST(DBTest, DeletionMarkers2)",1,30,db\db_test.cc,leveldb._Test_DeletionMarkers2._RunIt,,false,1287,1287,_RunIt,,,2,void leveldb._Test_DeletionMarkers2._RunIt ()
24156,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, DeletionMarkers2) {
  Put(""foo"", ""v1"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());
  const int last = config::kMaxMemCompactLevel;
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);   // foo => v1 is now in last level

  // Place a table at level last-1 to prevent merging with preceding mutation
  Put(""a"", ""begin"");
  Put(""z"", ""end"");
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(NumTableFilesAtLevel(last), 1);
  ASSERT_EQ(NumTableFilesAtLevel(last-1), 1);

  Delete(""foo"");
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  ASSERT_OK(dbfull()->TEST_CompactMemTable());  // Moves to level last-2
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  dbfull()->TEST_CompactRange(last-2, NULL, NULL);
  // DEL kept: ""last"" file overlaps
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"");
  dbfull()->TEST_CompactRange(last-1, NULL, NULL);
  // Merging last-1 w/ last, so we are the base level for ""foo"", so
  // DEL is removed.  (as is v1).
  ASSERT_EQ(AllEntriesFor(""foo""), ""[ ]"");
}",1,30,db\db_test.cc,leveldb._Test_DeletionMarkers2._Run,,false,1287,1311,_Run,,,130,void leveldb._Test_DeletionMarkers2._Run ()
24371,METHOD,leveldb._Test_OverlapInLevel0,TYPE_DECL,void void ();,1,29,db\db_test.cc,leveldb._Test_OverlapInLevel0._Run,,false,1313,1313,_Run,,,1,void leveldb._Test_OverlapInLevel0._Run ()
24375,METHOD,leveldb._Test_OverlapInLevel0,TYPE_DECL,"TEST(DBTest, OverlapInLevel0)",1,29,db\db_test.cc,leveldb._Test_OverlapInLevel0._RunIt,,false,1313,1313,_RunIt,,,2,void leveldb._Test_OverlapInLevel0._RunIt ()
24399,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, OverlapInLevel0) {
  do {
    ASSERT_EQ(config::kMaxMemCompactLevel, 2) << ""Fix test to match config"";

    // Fill levels 1 and 2 to disable the pushing of new memtables to levels > 0.
    ASSERT_OK(Put(""100"", ""v100""));
    ASSERT_OK(Put(""999"", ""v999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Delete(""100""));
    ASSERT_OK(Delete(""999""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""0,1,1"", FilesPerLevel());

    // Make files spanning the following ranges in level-0:
    //  files[0]  200 .. 900
    //  files[1]  300 .. 500
    // Note that files are sorted by smallest key.
    ASSERT_OK(Put(""300"", ""v300""));
    ASSERT_OK(Put(""500"", ""v500""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_OK(Put(""200"", ""v200""));
    ASSERT_OK(Put(""600"", ""v600""));
    ASSERT_OK(Put(""900"", ""v900""));
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""2,1,1"", FilesPerLevel());

    // Compact away the placeholder files we created initially
    dbfull()->TEST_Compac...",1,29,db\db_test.cc,leveldb._Test_OverlapInLevel0._Run,,false,1313,1352,_Run,,,134,void leveldb._Test_OverlapInLevel0._Run ()
24711,METHOD,leveldb._Test_L0_CompactionBug_Issue44_a,TYPE_DECL,void void ();,1,40,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_a._Run,,false,1354,1354,_Run,,,1,void leveldb._Test_L0_CompactionBug_Issue44_a._Run ()
24715,METHOD,leveldb._Test_L0_CompactionBug_Issue44_a,TYPE_DECL,"TEST(DBTest, L0_CompactionBug_Issue44_a)",1,40,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_a._RunIt,,false,1354,1354,_RunIt,,,2,void leveldb._Test_L0_CompactionBug_Issue44_a._RunIt ()
24739,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, L0_CompactionBug_Issue44_a) {
  Reopen();
  ASSERT_OK(Put(""b"", ""v""));
  Reopen();
  ASSERT_OK(Delete(""b""));
  ASSERT_OK(Delete(""a""));
  Reopen();
  ASSERT_OK(Delete(""a""));
  Reopen();
  ASSERT_OK(Put(""a"", ""v""));
  Reopen();
  Reopen();
  ASSERT_EQ(""(a->v)"", Contents());
  DelayMilliseconds(1000);  // Wait for compaction to finish
  ASSERT_EQ(""(a->v)"", Contents());
}",1,40,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_a._Run,,false,1354,1369,_Run,,,138,void leveldb._Test_L0_CompactionBug_Issue44_a._Run ()
24869,METHOD,leveldb._Test_L0_CompactionBug_Issue44_b,TYPE_DECL,void void ();,1,40,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_b._Run,,false,1371,1371,_Run,,,1,void leveldb._Test_L0_CompactionBug_Issue44_b._Run ()
24873,METHOD,leveldb._Test_L0_CompactionBug_Issue44_b,TYPE_DECL,"TEST(DBTest, L0_CompactionBug_Issue44_b)",1,40,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_b._RunIt,,false,1371,1371,_RunIt,,,2,void leveldb._Test_L0_CompactionBug_Issue44_b._RunIt ()
24897,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, L0_CompactionBug_Issue44_b) {
  Reopen();
  Put("""","""");
  Reopen();
  Delete(""e"");
  Put("""","""");
  Reopen();
  Put(""c"", ""cv"");
  Reopen();
  Put("""","""");
  Reopen();
  Put("""","""");
  DelayMilliseconds(1000);  // Wait for compaction to finish
  Reopen();
  Put(""d"",""dv"");
  Reopen();
  Put("""","""");
  Reopen();
  Delete(""d"");
  Delete(""b"");
  Reopen();
  ASSERT_EQ(""(->)(c->cv)"", Contents());
  DelayMilliseconds(1000);  // Wait for compaction to finish
  ASSERT_EQ(""(->)(c->cv)"", Contents());
}",1,40,db\db_test.cc,leveldb._Test_L0_CompactionBug_Issue44_b._Run,,false,1371,1395,_Run,,,142,void leveldb._Test_L0_CompactionBug_Issue44_b._Run ()
24976,METHOD,leveldb._Test_ComparatorCheck,TYPE_DECL,void void ();,1,29,db\db_test.cc,leveldb._Test_ComparatorCheck._Run,,false,1397,1397,_Run,,,1,void leveldb._Test_ComparatorCheck._Run ()
24980,METHOD,leveldb._Test_ComparatorCheck,TYPE_DECL,"TEST(DBTest, ComparatorCheck)",1,29,db\db_test.cc,leveldb._Test_ComparatorCheck._RunIt,,false,1397,1397,_RunIt,,,2,void leveldb._Test_ComparatorCheck._RunIt ()
25004,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, ComparatorCheck) {
  class NewComparator : public Comparator {
   public:
    virtual const char* Name() const { return ""leveldb.NewComparator""; }
    virtual int Compare(const Slice& a, const Slice& b) const {
      return BytewiseComparator()->Compare(a, b);
    }
    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {
      BytewiseComparator()->FindShortestSeparator(s, l);
    }
    virtual void FindShortSuccessor(std::string* key) const {
      BytewiseComparator()->FindShortSuccessor(key);
    }
  };
  NewComparator cmp;
  Options new_options = CurrentOptions();
  new_options.comparator = &cmp;
  Status s = TryReopen(&new_options);
  ASSERT_TRUE(!s.ok());
  ASSERT_TRUE(s.ToString().find(""comparator"") != std::string::npos)
      << s.ToString();
}",1,29,db\db_test.cc,leveldb._Test_ComparatorCheck._Run,,false,1397,1418,_Run,,,146,void leveldb._Test_ComparatorCheck._Run ()
25083,METHOD,leveldb._Test_CustomComparator,TYPE_DECL,void void ();,1,30,db\db_test.cc,leveldb._Test_CustomComparator._Run,,false,1420,1420,_Run,,,1,void leveldb._Test_CustomComparator._Run ()
25087,METHOD,leveldb._Test_CustomComparator,TYPE_DECL,"TEST(DBTest, CustomComparator)",1,30,db\db_test.cc,leveldb._Test_CustomComparator._RunIt,,false,1420,1420,_RunIt,,,2,void leveldb._Test_CustomComparator._RunIt ()
25111,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, CustomComparator) {
  class NumberComparator : public Comparator {
   public:
    virtual const char* Name() const { return ""test.NumberComparator""; }
    virtual int Compare(const Slice& a, const Slice& b) const {
      return ToNumber(a) - ToNumber(b);
    }
    virtual void FindShortestSeparator(std::string* s, const Slice& l) const {
      ToNumber(*s);     // Check format
      ToNumber(l);      // Check format
    }
    virtual void FindShortSuccessor(std::string* key) const {
      ToNumber(*key);   // Check format
    }
   private:
    static int ToNumber(const Slice& x) {
      // Check that there are no extra characters.
      ASSERT_TRUE(x.size() >= 2 && x[0] == '[' && x[x.size()-1] == ']')
          << EscapeString(x);
      int val;
      char ignored;
      ASSERT_TRUE(sscanf(x.ToString().c_str(), ""[%i]%c"", &val, &ignored) == 1)
          << EscapeString(x);
      return val;
    }
  };
  NumberComparator cmp;
  Options new_options = CurrentOptions();
  ne...",1,30,db\db_test.cc,leveldb._Test_CustomComparator._Run,,false,1420,1473,_Run,,,150,void leveldb._Test_CustomComparator._Run ()
25358,METHOD,leveldb._Test_ManualCompaction,TYPE_DECL,void void ();,1,30,db\db_test.cc,leveldb._Test_ManualCompaction._Run,,false,1475,1475,_Run,,,1,void leveldb._Test_ManualCompaction._Run ()
25362,METHOD,leveldb._Test_ManualCompaction,TYPE_DECL,"TEST(DBTest, ManualCompaction)",1,30,db\db_test.cc,leveldb._Test_ManualCompaction._RunIt,,false,1475,1475,_RunIt,,,2,void leveldb._Test_ManualCompaction._RunIt ()
25386,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, ManualCompaction) {
  ASSERT_EQ(config::kMaxMemCompactLevel, 2)
      << ""Need to update this test to match kMaxMemCompactLevel"";

  MakeTables(3, ""p"", ""q"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range falls before files
  Compact("""", ""c"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range falls after files
  Compact(""r"", ""z"");
  ASSERT_EQ(""1,1,1"", FilesPerLevel());

  // Compaction range overlaps files
  Compact(""p1"", ""p9"");
  ASSERT_EQ(""0,0,1"", FilesPerLevel());

  // Populate a different range
  MakeTables(3, ""c"", ""e"");
  ASSERT_EQ(""1,1,2"", FilesPerLevel());

  // Compact just the new range
  Compact(""b"", ""f"");
  ASSERT_EQ(""0,0,2"", FilesPerLevel());

  // Compact all
  MakeTables(1, ""a"", ""z"");
  ASSERT_EQ(""0,1,2"", FilesPerLevel());
  db_->CompactRange(NULL, NULL);
  ASSERT_EQ(""0,0,1"", FilesPerLevel());
}",1,30,db\db_test.cc,leveldb._Test_ManualCompaction._Run,,false,1475,1507,_Run,,,154,void leveldb._Test_ManualCompaction._Run ()
25577,METHOD,leveldb._Test_DBOpen_Options,TYPE_DECL,void void ();,1,28,db\db_test.cc,leveldb._Test_DBOpen_Options._Run,,false,1509,1509,_Run,,,1,void leveldb._Test_DBOpen_Options._Run ()
25581,METHOD,leveldb._Test_DBOpen_Options,TYPE_DECL,"TEST(DBTest, DBOpen_Options)",1,28,db\db_test.cc,leveldb._Test_DBOpen_Options._RunIt,,false,1509,1509,_RunIt,,,2,void leveldb._Test_DBOpen_Options._RunIt ()
25605,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, DBOpen_Options) {
  std::string dbname = test::TmpDir() + ""/db_options_test"";
  DestroyDB(dbname, Options());

  // Does not exist, and create_if_missing == false: error
  DB* db = NULL;
  Options opts;
  opts.create_if_missing = false;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL);
  ASSERT_TRUE(db == NULL);

  // Does not exist, and create_if_missing == true: OK
  opts.create_if_missing = true;
  s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  // Does exist, and error_if_exists == true: error
  opts.create_if_missing = false;
  opts.error_if_exists = true;
  s = DB::Open(opts, dbname, &db);
  ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL);
  ASSERT_TRUE(db == NULL);

  // Does exist, and error_if_exists == false: OK
  opts.create_if_missing = true;
  opts.error_if_exists = false;
  s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  A...",1,28,db\db_test.cc,leveldb._Test_DBOpen_Options._Run,,false,1509,1546,_Run,,,158,void leveldb._Test_DBOpen_Options._Run ()
25856,METHOD,leveldb._Test_Locking,TYPE_DECL,void void ();,1,21,db\db_test.cc,leveldb._Test_Locking._Run,,false,1548,1548,_Run,,,1,void leveldb._Test_Locking._Run ()
25860,METHOD,leveldb._Test_Locking,TYPE_DECL,"TEST(DBTest, Locking)",1,21,db\db_test.cc,leveldb._Test_Locking._RunIt,,false,1548,1548,_RunIt,,,2,void leveldb._Test_Locking._RunIt ()
25884,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, Locking) {
  DB* db2 = NULL;
  Status s = DB::Open(CurrentOptions(), dbname_, &db2);
  ASSERT_TRUE(!s.ok()) << ""Locking did not prevent re-opening db"";
}",1,21,db\db_test.cc,leveldb._Test_Locking._Run,,false,1548,1552,_Run,,,162,void leveldb._Test_Locking._Run ()
25930,METHOD,leveldb._Test_NoSpace,TYPE_DECL,void void ();,1,21,db\db_test.cc,leveldb._Test_NoSpace._Run,,false,1555,1555,_Run,,,1,void leveldb._Test_NoSpace._Run ()
25934,METHOD,leveldb._Test_NoSpace,TYPE_DECL,"TEST(DBTest, NoSpace)",1,21,db\db_test.cc,leveldb._Test_NoSpace._RunIt,,false,1555,1555,_RunIt,,,2,void leveldb._Test_NoSpace._RunIt ()
25958,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, NoSpace) {
  Options options = CurrentOptions();
  options.env = env_;
  Reopen(&options);

  ASSERT_OK(Put(""foo"", ""v1""));
  ASSERT_EQ(""v1"", Get(""foo""));
  Compact(""a"", ""z"");
  const int num_files = CountFiles();
  env_->no_space_.Release_Store(env_);   // Force out-of-space errors
  for (int i = 0; i < 10; i++) {
    for (int level = 0; level < config::kNumLevels-1; level++) {
      dbfull()->TEST_CompactRange(level, NULL, NULL);
    }
  }
  env_->no_space_.Release_Store(NULL);
  ASSERT_LT(CountFiles(), num_files + 3);
}",1,21,db\db_test.cc,leveldb._Test_NoSpace._Run,,false,1555,1572,_Run,,,166,void leveldb._Test_NoSpace._Run ()
26084,METHOD,leveldb._Test_NonWritableFileSystem,TYPE_DECL,void void ();,1,35,db\db_test.cc,leveldb._Test_NonWritableFileSystem._Run,,false,1574,1574,_Run,,,1,void leveldb._Test_NonWritableFileSystem._Run ()
26088,METHOD,leveldb._Test_NonWritableFileSystem,TYPE_DECL,"TEST(DBTest, NonWritableFileSystem)",1,35,db\db_test.cc,leveldb._Test_NonWritableFileSystem._RunIt,,false,1574,1574,_RunIt,,,2,void leveldb._Test_NonWritableFileSystem._RunIt ()
26112,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, NonWritableFileSystem) {
  Options options = CurrentOptions();
  options.write_buffer_size = 1000;
  options.env = env_;
  Reopen(&options);
  ASSERT_OK(Put(""foo"", ""v1""));
  env_->non_writable_.Release_Store(env_);  // Force errors for new files
  std::string big(100000, 'x');
  int errors = 0;
  for (int i = 0; i < 20; i++) {
    fprintf(stderr, ""iter %d; errors %d\n"", i, errors);
    if (!Put(""foo"", big).ok()) {
      errors++;
      DelayMilliseconds(100);
    }
  }
  ASSERT_GT(errors, 0);
  env_->non_writable_.Release_Store(NULL);
}",1,35,db\db_test.cc,leveldb._Test_NonWritableFileSystem._Run,,false,1574,1592,_Run,,,170,void leveldb._Test_NonWritableFileSystem._Run ()
26219,METHOD,leveldb._Test_WriteSyncError,TYPE_DECL,void void ();,1,28,db\db_test.cc,leveldb._Test_WriteSyncError._Run,,false,1594,1594,_Run,,,1,void leveldb._Test_WriteSyncError._Run ()
26223,METHOD,leveldb._Test_WriteSyncError,TYPE_DECL,"TEST(DBTest, WriteSyncError)",1,28,db\db_test.cc,leveldb._Test_WriteSyncError._RunIt,,false,1594,1594,_RunIt,,,2,void leveldb._Test_WriteSyncError._RunIt ()
26247,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, WriteSyncError) {
  // Check that log sync errors cause the DB to disallow future writes.

  // (a) Cause log sync calls to fail
  Options options = CurrentOptions();
  options.env = env_;
  Reopen(&options);
  env_->data_sync_error_.Release_Store(env_);

  // (b) Normal write should succeed
  WriteOptions w;
  ASSERT_OK(db_->Put(w, ""k1"", ""v1""));
  ASSERT_EQ(""v1"", Get(""k1""));

  // (c) Do a sync write; should fail
  w.sync = true;
  ASSERT_TRUE(!db_->Put(w, ""k2"", ""v2"").ok());
  ASSERT_EQ(""v1"", Get(""k1""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k2""));

  // (d) make sync behave normally
  env_->data_sync_error_.Release_Store(NULL);

  // (e) Do a non-sync write; should fail
  w.sync = false;
  ASSERT_TRUE(!db_->Put(w, ""k3"", ""v3"").ok());
  ASSERT_EQ(""v1"", Get(""k1""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k2""));
  ASSERT_EQ(""NOT_FOUND"", Get(""k3""));
}",1,28,db\db_test.cc,leveldb._Test_WriteSyncError._Run,,false,1594,1623,_Run,,,174,void leveldb._Test_WriteSyncError._Run ()
26473,METHOD,leveldb._Test_ManifestWriteError,TYPE_DECL,void void ();,1,32,db\db_test.cc,leveldb._Test_ManifestWriteError._Run,,false,1625,1625,_Run,,,1,void leveldb._Test_ManifestWriteError._Run ()
26477,METHOD,leveldb._Test_ManifestWriteError,TYPE_DECL,"TEST(DBTest, ManifestWriteError)",1,32,db\db_test.cc,leveldb._Test_ManifestWriteError._RunIt,,false,1625,1625,_RunIt,,,2,void leveldb._Test_ManifestWriteError._RunIt ()
26501,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, ManifestWriteError) {
  // Test for the following problem:
  // (a) Compaction produces file F
  // (b) Log record containing F is written to MANIFEST file, but Sync() fails
  // (c) GC deletes F
  // (d) After reopening DB, reads fail since deleted F is named in log record

  // We iterate twice.  In the second iteration, everything is the
  // same except the log record never makes it to the MANIFEST file.
  for (int iter = 0; iter < 2; iter++) {
    port::AtomicPointer* error_type = (iter == 0)
        ? &env_->manifest_sync_error_
        : &env_->manifest_write_error_;

    // Insert foo=>bar mapping
    Options options = CurrentOptions();
    options.env = env_;
    options.create_if_missing = true;
    options.error_if_exists = false;
    DestroyAndReopen(&options);
    ASSERT_OK(Put(""foo"", ""bar""));
    ASSERT_EQ(""bar"", Get(""foo""));

    // Memtable compaction (will succeed)
    dbfull()->TEST_CompactMemTable();
    ASSERT_EQ(""bar"", Get(""foo""));
    const int las...",1,32,db\db_test.cc,leveldb._Test_ManifestWriteError._Run,,false,1625,1664,_Run,,,178,void leveldb._Test_ManifestWriteError._Run ()
26696,METHOD,leveldb._Test_MissingSSTFile,TYPE_DECL,void void ();,1,28,db\db_test.cc,leveldb._Test_MissingSSTFile._Run,,false,1666,1666,_Run,,,1,void leveldb._Test_MissingSSTFile._Run ()
26700,METHOD,leveldb._Test_MissingSSTFile,TYPE_DECL,"TEST(DBTest, MissingSSTFile)",1,28,db\db_test.cc,leveldb._Test_MissingSSTFile._RunIt,,false,1666,1666,_RunIt,,,2,void leveldb._Test_MissingSSTFile._RunIt ()
26724,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, MissingSSTFile) {
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(""bar"", Get(""foo""));

  // Dump the memtable to disk.
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(""bar"", Get(""foo""));

  Close();
  ASSERT_TRUE(DeleteAnSSTFile());
  Options options = CurrentOptions();
  options.paranoid_checks = true;
  Status s = TryReopen(&options);
  ASSERT_TRUE(!s.ok());
  ASSERT_TRUE(s.ToString().find(""issing"") != std::string::npos)
      << s.ToString();
}",1,28,db\db_test.cc,leveldb._Test_MissingSSTFile._Run,,false,1666,1682,_Run,,,182,void leveldb._Test_MissingSSTFile._Run ()
26876,METHOD,leveldb._Test_StillReadSST,TYPE_DECL,void void ();,1,26,db\db_test.cc,leveldb._Test_StillReadSST._Run,,false,1684,1684,_Run,,,1,void leveldb._Test_StillReadSST._Run ()
26880,METHOD,leveldb._Test_StillReadSST,TYPE_DECL,"TEST(DBTest, StillReadSST)",1,26,db\db_test.cc,leveldb._Test_StillReadSST._RunIt,,false,1684,1684,_RunIt,,,2,void leveldb._Test_StillReadSST._RunIt ()
26904,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, StillReadSST) {
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(""bar"", Get(""foo""));

  // Dump the memtable to disk.
  dbfull()->TEST_CompactMemTable();
  ASSERT_EQ(""bar"", Get(""foo""));
  Close();
  ASSERT_GT(RenameLDBToSST(), 0);
  Options options = CurrentOptions();
  options.paranoid_checks = true;
  Status s = TryReopen(&options);
  ASSERT_TRUE(s.ok());
  ASSERT_EQ(""bar"", Get(""foo""));
}",1,26,db\db_test.cc,leveldb._Test_StillReadSST._Run,,false,1684,1698,_Run,,,186,void leveldb._Test_StillReadSST._Run ()
27041,METHOD,leveldb._Test_FilesDeletedAfterCompaction,TYPE_DECL,void void ();,1,41,db\db_test.cc,leveldb._Test_FilesDeletedAfterCompaction._Run,,false,1700,1700,_Run,,,1,void leveldb._Test_FilesDeletedAfterCompaction._Run ()
27045,METHOD,leveldb._Test_FilesDeletedAfterCompaction,TYPE_DECL,"TEST(DBTest, FilesDeletedAfterCompaction)",1,41,db\db_test.cc,leveldb._Test_FilesDeletedAfterCompaction._RunIt,,false,1700,1700,_RunIt,,,2,void leveldb._Test_FilesDeletedAfterCompaction._RunIt ()
27069,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, FilesDeletedAfterCompaction) {
  ASSERT_OK(Put(""foo"", ""v2""));
  Compact(""a"", ""z"");
  const int num_files = CountFiles();
  for (int i = 0; i < 10; i++) {
    ASSERT_OK(Put(""foo"", ""v2""));
    Compact(""a"", ""z"");
  }
  ASSERT_EQ(CountFiles(), num_files);
}",1,41,db\db_test.cc,leveldb._Test_FilesDeletedAfterCompaction._Run,,false,1700,1709,_Run,,,190,void leveldb._Test_FilesDeletedAfterCompaction._Run ()
27145,METHOD,leveldb._Test_BloomFilter,TYPE_DECL,void void ();,1,25,db\db_test.cc,leveldb._Test_BloomFilter._Run,,false,1711,1711,_Run,,,1,void leveldb._Test_BloomFilter._Run ()
27149,METHOD,leveldb._Test_BloomFilter,TYPE_DECL,"TEST(DBTest, BloomFilter)",1,25,db\db_test.cc,leveldb._Test_BloomFilter._RunIt,,false,1711,1711,_RunIt,,,2,void leveldb._Test_BloomFilter._RunIt ()
27173,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, BloomFilter) {
  env_->count_random_reads_ = true;
  Options options = CurrentOptions();
  options.env = env_;
  options.block_cache = NewLRUCache(0);  // Prevent cache hits
  options.filter_policy = NewBloomFilterPolicy(10);
  Reopen(&options);

  // Populate multiple layers
  const int N = 10000;
  for (int i = 0; i < N; i++) {
    ASSERT_OK(Put(Key(i), Key(i)));
  }
  Compact(""a"", ""z"");
  for (int i = 0; i < N; i += 100) {
    ASSERT_OK(Put(Key(i), Key(i)));
  }
  dbfull()->TEST_CompactMemTable();

  // Prevent auto compactions triggered by seeks
  env_->delay_data_sync_.Release_Store(env_);

  // Lookup present keys.  Should rarely read from small sstable.
  env_->random_read_counter_.Reset();
  for (int i = 0; i < N; i++) {
    ASSERT_EQ(Key(i), Get(Key(i)));
  }
  int reads = env_->random_read_counter_.Read();
  fprintf(stderr, ""%d present => %d reads\n"", N, reads);
  ASSERT_GE(reads, N);
  ASSERT_LE(reads, N + 2*N/100);

  // Lookup present keys.  Should rarely r...",1,25,db\db_test.cc,leveldb._Test_BloomFilter._Run,,false,1711,1756,_Run,,,194,void leveldb._Test_BloomFilter._Run ()
27484,METHOD,<empty>,<empty>,<empty>,1,,db\db_test.cc,leveldb.anonymous_namespace_15.MTState:<clinit>,,false,1765,,<clinit>,,,5,
27495,METHOD,db\db_test.cc:<global>,TYPE_DECL,"static void MTThreadBody(void* arg) {
  MTThread* t = reinterpret_cast<MTThread*>(arg);
  int id = t->id;
  DB* db = t->state->test->db_;
  uintptr_t counter = 0;
  fprintf(stderr, ""... starting thread %d\n"", id);
  Random rnd(1000 + id);
  std::string value;
  char valbuf[1500];
  while (t->state->stop.Acquire_Load() == NULL) {
    t->state->counter[id].Release_Store(reinterpret_cast<void*>(counter));

    int key = rnd.Uniform(kNumKeys);
    char keybuf[20];
    snprintf(keybuf, sizeof(keybuf), ""%016d"", key);

    if (rnd.OneIn(2)) {
      // Write values of the form <key, my id, counter>.
      // We add some padding for force compactions.
      snprintf(valbuf, sizeof(valbuf), ""%d.%d.%-1000d"",
               key, id, static_cast<int>(counter));
      ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)));
    } else {
      // Read a value and verify that it matches the pattern written above.
      Status s = db->Get(ReadOptions(), Slice(keybuf), &value);
      if (s.I...",1,6,db\db_test.cc,leveldb.anonymous_namespace_17.MTThreadBody,,false,1777,1820,MTThreadBody,,,9,void leveldb.anonymous_namespace_17.MTThreadBody (void*)
27800,METHOD,leveldb._Test_MultiThreaded,TYPE_DECL,void void ();,1,27,db\db_test.cc,leveldb._Test_MultiThreaded._Run,,false,1824,1824,_Run,,,1,void leveldb._Test_MultiThreaded._Run ()
27804,METHOD,leveldb._Test_MultiThreaded,TYPE_DECL,"TEST(DBTest, MultiThreaded)",1,27,db\db_test.cc,leveldb._Test_MultiThreaded._RunIt,,false,1824,1824,_RunIt,,,2,void leveldb._Test_MultiThreaded._RunIt ()
27828,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, MultiThreaded) {
  do {
    // Initialize state
    MTState mt;
    mt.test = this;
    mt.stop.Release_Store(0);
    for (int id = 0; id < kNumThreads; id++) {
      mt.counter[id].Release_Store(0);
      mt.thread_done[id].Release_Store(0);
    }

    // Start threads
    MTThread thread[kNumThreads];
    for (int id = 0; id < kNumThreads; id++) {
      thread[id].state = &mt;
      thread[id].id = id;
      env_->StartThread(MTThreadBody, &thread[id]);
    }

    // Let them run for a while
    DelayMilliseconds(kTestSeconds * 1000);

    // Stop the threads and wait for them to finish
    mt.stop.Release_Store(&mt);
    for (int id = 0; id < kNumThreads; id++) {
      while (mt.thread_done[id].Acquire_Load() == NULL) {
        DelayMilliseconds(100);
      }
    }
  } while (ChangeOptions());
}",1,27,db\db_test.cc,leveldb._Test_MultiThreaded._Run,,false,1824,1854,_Run,,,199,void leveldb._Test_MultiThreaded._Run ()
27958,METHOD,leveldb.ModelDB,TYPE_DECL,explicit ModelDB(const Options& options): options_(options) { },3,65,db\db_test.cc,leveldb.ModelDB.ModelDB,,false,1867,1867,ModelDB,,,2,ANY leveldb.ModelDB.ModelDB (Options)
27963,METHOD,leveldb.ModelDB,TYPE_DECL,~ModelDB() { },3,16,db\db_test.cc,leveldb.ModelDB.~ModelDB,,false,1868,1868,~ModelDB,,,3,ANY leveldb.ModelDB.~ModelDB ()
27967,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual Status Put(const WriteOptions& o, const Slice& k, const Slice& v) {
    return DB::Put(o, k, v);
  }",3,3,db\db_test.cc,leveldb.ModelDB.Put,,false,1869,1871,Put,,,4,"Status leveldb.ModelDB.Put (WriteOptions,Slice,Slice)"
27982,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual Status Delete(const WriteOptions& o, const Slice& key) {
    return DB::Delete(o, key);
  }",3,3,db\db_test.cc,leveldb.ModelDB.Delete,,false,1872,1874,Delete,,,5,"Status leveldb.ModelDB.Delete (WriteOptions,Slice)"
27995,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) {
    assert(false);      // Not implemented
    return Status::NotFound(key);
  }",3,3,db\db_test.cc,leveldb.ModelDB.Get,,false,1875,1879,Get,,,6,"Status leveldb.ModelDB.Get (ReadOptions,Slice,ANY*)"
28010,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual Iterator* NewIterator(const ReadOptions& options) {
    if (options.snapshot == NULL) {
      KVMap* saved = new KVMap;
      *saved = map_;
      return new ModelIter(saved, true);
    } else {
      const KVMap* snapshot_state =
          &(reinterpret_cast<const ModelSnapshot*>(options.snapshot)->map_);
      return new ModelIter(snapshot_state, false);
    }
  }",3,3,db\db_test.cc,leveldb.ModelDB.NewIterator,,false,1880,1890,NewIterator,,,7,Iterator leveldb.ModelDB.NewIterator (ReadOptions)
28054,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual const Snapshot* GetSnapshot() {
    ModelSnapshot* snapshot = new ModelSnapshot;
    snapshot->map_ = map_;
    return snapshot;
  }",3,3,db\db_test.cc,leveldb.ModelDB.GetSnapshot,,false,1891,1895,GetSnapshot,,,8,Snapshot leveldb.ModelDB.GetSnapshot ()
28070,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual void ReleaseSnapshot(const Snapshot* snapshot) {
    delete reinterpret_cast<const ModelSnapshot*>(snapshot);
  }",3,3,db\db_test.cc,leveldb.ModelDB.ReleaseSnapshot,,false,1897,1899,ReleaseSnapshot,,,9,void leveldb.ModelDB.ReleaseSnapshot (Snapshot*)
28079,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual Status Write(const WriteOptions& options, WriteBatch* batch) {
    class Handler : public WriteBatch::Handler {
     public:
      KVMap* map_;
      virtual void Put(const Slice& key, const Slice& value) {
        (*map_)[key.ToString()] = value.ToString();
      }
      virtual void Delete(const Slice& key) {
        map_->erase(key.ToString());
      }
    };
    Handler handler;
    handler.map_ = &map_;
    return batch->Iterate(&handler);
  }",3,3,db\db_test.cc,leveldb.ModelDB.Write,,false,1900,1914,Write,,,10,"Status leveldb.ModelDB.Write (WriteOptions,WriteBatch*)"
28099,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual bool GetProperty(const Slice& property, std::string* value) {
    return false;
  }",3,3,db\db_test.cc,leveldb.ModelDB.GetProperty,,false,1916,1918,GetProperty,,,11,"bool leveldb.ModelDB.GetProperty (Slice,ANY*)"
28107,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual void GetApproximateSizes(const Range* r, int n, uint64_t* sizes) {
    for (int i = 0; i < n; i++) {
      sizes[i] = 0;
    }
  }",3,3,db\db_test.cc,leveldb.ModelDB.GetApproximateSizes,,false,1919,1923,GetApproximateSizes,,,12,"void leveldb.ModelDB.GetApproximateSizes (Range*,int,uint64_t*)"
28131,METHOD,leveldb.ModelDB,TYPE_DECL,"virtual void CompactRange(const Slice* start, const Slice* end) {
  }",3,3,db\db_test.cc,leveldb.ModelDB.CompactRange,,false,1924,1925,CompactRange,,,13,"void leveldb.ModelDB.CompactRange (Slice*,Slice*)"
28138,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,"ModelIter(const KVMap* map, bool owned)
        : map_(map), owned_(owned), iter_(map_->end()) {
    }",5,5,db\db_test.cc,leveldb.ModelDB.ModelIter.ModelIter,,false,1930,1932,ModelIter,,,1,"ANY leveldb.ModelDB.ModelIter.ModelIter (KVMap*,bool)"
28144,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,"~ModelIter() {
      if (owned_) delete map_;
    }",5,5,db\db_test.cc,leveldb.ModelDB.ModelIter.~ModelIter,,false,1933,1935,~ModelIter,,,2,ANY leveldb.ModelDB.ModelIter.~ModelIter ()
28153,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual bool Valid() const { return iter_ != map_->end(); },5,63,db\db_test.cc,leveldb.ModelDB.ModelIter.Valid,,false,1936,1936,Valid,,,3,bool leveldb.ModelDB.ModelIter.Valid ()
28164,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual void SeekToFirst() { iter_ = map_->begin(); },5,57,db\db_test.cc,leveldb.ModelDB.ModelIter.SeekToFirst,,false,1937,1937,SeekToFirst,,,4,void leveldb.ModelDB.ModelIter.SeekToFirst ()
28174,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,"virtual void SeekToLast() {
      if (map_->empty()) {
        iter_ = map_->end();
      } else {
        iter_ = map_->find(map_->rbegin()->first);
      }
    }",5,5,db\db_test.cc,leveldb.ModelDB.ModelIter.SeekToLast,,false,1938,1944,SeekToLast,,,5,void leveldb.ModelDB.ModelIter.SeekToLast ()
28204,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,"virtual void Seek(const Slice& k) {
      iter_ = map_->lower_bound(k.ToString());
    }",5,5,db\db_test.cc,leveldb.ModelDB.ModelIter.Seek,,false,1945,1947,Seek,,,6,void leveldb.ModelDB.ModelIter.Seek (Slice)
28219,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual void Next() { ++iter_; },5,36,db\db_test.cc,leveldb.ModelDB.ModelIter.Next,,false,1948,1948,Next,,,7,void leveldb.ModelDB.ModelIter.Next ()
28225,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual void Prev() { --iter_; },5,36,db\db_test.cc,leveldb.ModelDB.ModelIter.Prev,,false,1949,1949,Prev,,,8,void leveldb.ModelDB.ModelIter.Prev ()
28231,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual Slice key() const { return iter_->first; },5,54,db\db_test.cc,leveldb.ModelDB.ModelIter.key,,false,1950,1950,key,,,9,Slice leveldb.ModelDB.ModelIter.key ()
28239,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual Slice value() const { return iter_->second; },5,57,db\db_test.cc,leveldb.ModelDB.ModelIter.value,,false,1951,1951,value,,,10,Slice leveldb.ModelDB.ModelIter.value ()
28247,METHOD,leveldb.ModelDB.ModelIter,TYPE_DECL,virtual Status status() const { return Status::OK(); },5,58,db\db_test.cc,leveldb.ModelDB.ModelIter.status,,false,1952,1952,status,,,11,Status leveldb.ModelDB.ModelIter.status ()
28261,METHOD,db\db_test.cc:<global>,TYPE_DECL,"static std::string RandomKey(Random* rnd) {
  int len = (rnd->OneIn(3)
             ? 1                // Short sometimes to encourage collisions
             : (rnd->OneIn(100) ? rnd->Skewed(10) : rnd->Uniform(10)));
  return test::RandomKey(rnd, len);
}",1,1,db\db_test.cc,leveldb.RandomKey,,false,1962,1967,RandomKey,,,202,string leveldb.RandomKey (Random*)
28299,METHOD,db\db_test.cc:<global>,TYPE_DECL,"static bool CompareIterators(int step,
                             DB* model,
                             DB* db,
                             const Snapshot* model_snap,
                             const Snapshot* db_snap) {
  ReadOptions options;
  options.snapshot = model_snap;
  Iterator* miter = model->NewIterator(options);
  options.snapshot = db_snap;
  Iterator* dbiter = db->NewIterator(options);
  bool ok = true;
  int count = 0;
  for (miter->SeekToFirst(), dbiter->SeekToFirst();
       ok && miter->Valid() && dbiter->Valid();
       miter->Next(), dbiter->Next()) {
    count++;
    if (miter->key().compare(dbiter->key()) != 0) {
      fprintf(stderr, ""step %d: Key mismatch: '%s' vs. '%s'\n"",
              step,
              EscapeString(miter->key()).c_str(),
              EscapeString(dbiter->key()).c_str());
      ok = false;
      break;
    }

    if (miter->value().compare(dbiter->value()) != 0) {
      fprintf(stderr, ""step %d: Value mismatch for key '%s': '%s' ...",1,1,db\db_test.cc,leveldb.CompareIterators,,false,1969,2015,CompareIterators,,,203,"bool leveldb.CompareIterators (int,DB*,DB*,Snapshot*,Snapshot*)"
28503,METHOD,leveldb._Test_Randomized,TYPE_DECL,void void ();,1,24,db\db_test.cc,leveldb._Test_Randomized._Run,,false,2017,2017,_Run,,,1,void leveldb._Test_Randomized._Run ()
28507,METHOD,leveldb._Test_Randomized,TYPE_DECL,"TEST(DBTest, Randomized)",1,24,db\db_test.cc,leveldb._Test_Randomized._RunIt,,false,2017,2017,_RunIt,,,2,void leveldb._Test_Randomized._RunIt ()
28531,METHOD,db\db_test.cc:<global>,TYPE_DECL,"TEST(DBTest, Randomized) {
  Random rnd(test::RandomSeed());
  do {
    ModelDB model(CurrentOptions());
    const int N = 10000;
    const Snapshot* model_snap = NULL;
    const Snapshot* db_snap = NULL;
    std::string k, v;
    for (int step = 0; step < N; step++) {
      if (step % 100 == 0) {
        fprintf(stderr, ""Step %d of %d\n"", step, N);
      }
      // TODO(sanjay): Test Get() works
      int p = rnd.Uniform(100);
      if (p < 45) {                               // Put
        k = RandomKey(&rnd);
        v = RandomString(&rnd,
                         rnd.OneIn(20)
                         ? 100 + rnd.Uniform(100)
                         : rnd.Uniform(8));
        ASSERT_OK(model.Put(WriteOptions(), k, v));
        ASSERT_OK(db_->Put(WriteOptions(), k, v));

      } else if (p < 90) {                        // Delete
        k = RandomKey(&rnd);
        ASSERT_OK(model.Delete(WriteOptions(), k));
        ASSERT_OK(db_->Delete(WriteOptions(), k));


      } else {   ...",1,24,db\db_test.cc,leveldb._Test_Randomized._Run,,false,2017,2086,_Run,,,207,void leveldb._Test_Randomized._Run ()
28951,METHOD,db\db_test.cc:<global>,TYPE_DECL,"std::string MakeKey(unsigned int num) {
  char buf[30];
  snprintf(buf, sizeof(buf), ""%016u"", num);
  return std::string(buf);
}",1,1,db\db_test.cc,leveldb.MakeKey,,false,2088,2092,MakeKey,,,208,string leveldb.MakeKey (unsigned int)
28969,METHOD,db\db_test.cc:<global>,TYPE_DECL,"void BM_LogAndApply(int iters, int num_base_files) {
  std::string dbname = test::TmpDir() + ""/leveldb_test_benchmark"";
  DestroyDB(dbname, Options());

  DB* db = NULL;
  Options opts;
  opts.create_if_missing = true;
  Status s = DB::Open(opts, dbname, &db);
  ASSERT_OK(s);
  ASSERT_TRUE(db != NULL);

  delete db;
  db = NULL;

  Env* env = Env::Default();

  port::Mutex mu;
  MutexLock l(&mu);

  InternalKeyComparator cmp(BytewiseComparator());
  Options options;
  VersionSet vset(dbname, &options, NULL, &cmp);
  bool save_manifest;
  ASSERT_OK(vset.Recover(&save_manifest));
  VersionEdit vbase;
  uint64_t fnum = 1;
  for (int i = 0; i < num_base_files; i++) {
    InternalKey start(MakeKey(2*fnum), 1, kTypeValue);
    InternalKey limit(MakeKey(2*fnum+1), 1, kTypeDeletion);
    vbase.AddFile(2, fnum++, 1 /* file size */, start, limit);
  }
  ASSERT_OK(vset.LogAndApply(&vbase, &mu));

  uint64_t start_micros = env->NowMicros();

  for (int i = 0; i < iters; i++) {
    VersionEdit v...",1,2,db\db_test.cc,leveldb.BM_LogAndApply,,false,2094,2144,BM_LogAndApply,,,209,"void leveldb.BM_LogAndApply (int,int)"
29254,METHOD,db\db_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  if (argc > 1 && std::string(argv[1]) == ""--benchmark"") {
    leveldb::BM_LogAndApply(1000, 1);
    leveldb::BM_LogAndApply(1000, 100);
    leveldb::BM_LogAndApply(1000, 10000);
    leveldb::BM_LogAndApply(100, 100000);
    return 0;
  }

  return leveldb::test::RunAllTests();
}",1,1,db\db_test.cc,main,,false,2148,2158,main,,,2,"int main (int,char**)"
29319,METHOD,db\dbformat.cc:<global>,TYPE_DECL,<global>,1,21,db\dbformat.cc,db\dbformat.cc:<global>,,false,1,140,<global>,,,1,
29322,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  assert(seq <= kMaxSequenceNumber);
  assert(t <= kValueTypeForSeek);
  return (seq << 8) | t;
}",1,1,db\dbformat.cc,leveldb.PackSequenceAndType,,false,12,16,PackSequenceAndType,,,1,"uint64_t leveldb.PackSequenceAndType (uint64_t,ValueType)"
29342,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {
  result->append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}",1,1,db\dbformat.cc,leveldb.AppendInternalKey,,false,18,21,AppendInternalKey,,,2,"void leveldb.AppendInternalKey (ANY*,ParsedInternalKey)"
29373,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"std::string ParsedInternalKey::DebugString() const {
  char buf[50];
  snprintf(buf, sizeof(buf), ""' @ %llu : %d"",
           (unsigned long long) sequence,
           int(type));
  std::string result = ""'"";
  result += EscapeString(user_key.ToString());
  result += buf;
  return result;
}",1,1,db\dbformat.cc,leveldb.ParsedInternalKey.DebugString,,false,23,32,DebugString,,,3,string leveldb.ParsedInternalKey.DebugString ()
29405,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"std::string InternalKey::DebugString() const {
  std::string result;
  ParsedInternalKey parsed;
  if (ParseInternalKey(rep_, &parsed)) {
    result = parsed.DebugString();
  } else {
    result = ""(bad)"";
    result.append(EscapeString(rep_));
  }
  return result;
}",1,1,db\dbformat.cc,leveldb.InternalKey.DebugString,,false,34,44,DebugString,,,4,string leveldb.InternalKey.DebugString ()
29436,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"const char* InternalKeyComparator::Name() const {
  return ""leveldb.InternalKeyComparator"";
}",1,1,db\dbformat.cc,leveldb.InternalKeyComparator.Name,,false,46,48,Name,,,5,const char* leveldb.InternalKeyComparator.Name ()
29442,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {
  // Order by:
  //    increasing user key (according to user-supplied comparator)
  //    decreasing sequence number
  //    decreasing type (though sequence# should be enough to disambiguate)
  int r = user_comparator_->Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  if (r == 0) {
    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
    if (anum > bnum) {
      r = -1;
    } else if (anum < bnum) {
      r = +1;
    }
  }
  return r;
}",1,1,db\dbformat.cc,leveldb.InternalKeyComparator.Compare,,false,50,66,Compare,,,6,"int leveldb.InternalKeyComparator.Compare (Slice,Slice)"
29516,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"void InternalKeyComparator::FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
  // Attempt to shorten the user portion of the key
  Slice user_start = ExtractUserKey(*start);
  Slice user_limit = ExtractUserKey(limit);
  std::string tmp(user_start.data(), user_start.size());
  user_comparator_->FindShortestSeparator(&tmp, user_limit);
  if (tmp.size() < user_start.size() &&
      user_comparator_->Compare(user_start, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*start, tmp) < 0);
    assert(this->Compare(tmp, limit) < 0);
    start->swap(tmp);
  }
}",1,1,db\dbformat.cc,leveldb.InternalKeyComparator.FindShortestSeparator,,false,68,85,FindShortestSeparator,,,7,"void leveldb.InternalKeyComparator.FindShortestSeparator (ANY*,Slice)"
29600,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"void InternalKeyComparator::FindShortSuccessor(std::string* key) const {
  Slice user_key = ExtractUserKey(*key);
  std::string tmp(user_key.data(), user_key.size());
  user_comparator_->FindShortSuccessor(&tmp);
  if (tmp.size() < user_key.size() &&
      user_comparator_->Compare(user_key, tmp) < 0) {
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this->Compare(*key, tmp) < 0);
    key->swap(tmp);
  }
}",1,1,db\dbformat.cc,leveldb.InternalKeyComparator.FindShortSuccessor,,false,87,99,FindShortSuccessor,,,8,void leveldb.InternalKeyComparator.FindShortSuccessor (ANY*)
29668,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"const char* InternalFilterPolicy::Name() const {
  return user_policy_->Name();
}",1,1,db\dbformat.cc,leveldb.InternalFilterPolicy.Name,,false,101,103,Name,,,9,const char* leveldb.InternalFilterPolicy.Name ()
29677,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,
                                        std::string* dst) const {
  // We rely on the fact that the code in table.cc does not mind us
  // adjusting keys[].
  Slice* mkey = const_cast<Slice*>(keys);
  for (int i = 0; i < n; i++) {
    mkey[i] = ExtractUserKey(keys[i]);
    // TODO(sanjay): Suppress dups?
  }
  user_policy_->CreateFilter(keys, n, dst);
}",1,1,db\dbformat.cc,leveldb.InternalFilterPolicy.CreateFilter,,false,105,115,CreateFilter,,,10,"void leveldb.InternalFilterPolicy.CreateFilter (Slice*,int,ANY*)"
29717,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {
  return user_policy_->KeyMayMatch(ExtractUserKey(key), f);
}",1,1,db\dbformat.cc,leveldb.InternalFilterPolicy.KeyMayMatch,,false,117,119,KeyMayMatch,,,11,"bool leveldb.InternalFilterPolicy.KeyMayMatch (Slice,Slice)"
29731,METHOD,db\dbformat.cc:<global>,TYPE_DECL,"LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
  size_t usize = user_key.size();
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed <= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}",1,1,db\dbformat.cc,leveldb.LookupKey.LookupKey,,false,121,138,LookupKey,,,12,"ANY leveldb.LookupKey.LookupKey (Slice,SequenceNumber)"
29819,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,<global>,1,21,db\dbformat.hpp,db\dbformat.hpp:<global>,,false,1,230,<global>,,,1,
29851,METHOD,<empty>,<empty>,<empty>,1,,db\dbformat.hpp,leveldb.ValueType:<clinit>,,false,51,,<clinit>,,,3,
29878,METHOD,leveldb.ParsedInternalKey,TYPE_DECL,ParsedInternalKey() { },3,25,db\dbformat.hpp,leveldb.ParsedInternalKey.ParsedInternalKey,,false,75,75,ParsedInternalKey,,,4,ANY leveldb.ParsedInternalKey.ParsedInternalKey ()
29882,METHOD,leveldb.ParsedInternalKey,TYPE_DECL,"ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)
      : user_key(u), sequence(seq), type(t) { }",3,47,db\dbformat.hpp,leveldb.ParsedInternalKey.ParsedInternalKey,,false,76,77,ParsedInternalKey,,,5,"ANY leveldb.ParsedInternalKey.ParsedInternalKey (Slice,SequenceNumber,ValueType)"
29889,METHOD,leveldb.ParsedInternalKey,TYPE_DECL,std::string DebugString() const;,15,33,db\dbformat.hpp,leveldb.ParsedInternalKey.DebugString,,false,78,78,DebugString,,,6,ANY leveldb.ParsedInternalKey.DebugString ()
29893,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {
  return key.user_key.size() + 8;
}",1,1,db\dbformat.hpp,leveldb.InternalKeyEncodingLength,,false,82,84,InternalKeyEncodingLength,,,10,size_t leveldb.InternalKeyEncodingLength (ParsedInternalKey)
29907,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"extern void AppendInternalKey(std::string* result,
                              const ParsedInternalKey& key);",13,59,db\dbformat.hpp,leveldb.AppendInternalKey,,false,87,88,AppendInternalKey,,,11,"void leveldb.AppendInternalKey (ANY*,ParsedInternalKey)"
29913,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"extern bool ParseInternalKey(const Slice& internal_key,
                             ParsedInternalKey* result);",13,55,db\dbformat.hpp,leveldb.ParseInternalKey,,false,94,95,ParseInternalKey,,,12,"bool leveldb.ParseInternalKey (Slice,ParsedInternalKey*)"
29919,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"inline Slice ExtractUserKey(const Slice& internal_key) {
  assert(internal_key.size() >= 8);
  return Slice(internal_key.data(), internal_key.size() - 8);
}",1,1,db\dbformat.hpp,leveldb.ExtractUserKey,,false,98,101,ExtractUserKey,,,13,Slice leveldb.ExtractUserKey (Slice)
29943,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"inline ValueType ExtractValueType(const Slice& internal_key) {
  assert(internal_key.size() >= 8);
  const size_t n = internal_key.size();
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num & 0xff;
  return static_cast<ValueType>(c);
}",1,1,db\dbformat.hpp,leveldb.ExtractValueType,,false,103,109,ExtractValueType,,,14,ValueType leveldb.ExtractValueType (Slice)
29986,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { },3,79,db\dbformat.hpp,leveldb.InternalKeyComparator.InternalKeyComparator,,false,117,117,InternalKeyComparator,,,2,ANY leveldb.InternalKeyComparator.InternalKeyComparator (Comparator*)
29991,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,virtual const char* Name() const;,21,34,db\dbformat.hpp,leveldb.InternalKeyComparator.Name,,false,118,118,Name,,,3,char* leveldb.InternalKeyComparator.Name ()
29995,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,"virtual int Compare(const Slice& a, const Slice& b) const;",15,59,db\dbformat.hpp,leveldb.InternalKeyComparator.Compare,,false,119,119,Compare,,,4,"int leveldb.InternalKeyComparator.Compare (Slice,Slice)"
30001,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const;",16,31,db\dbformat.hpp,leveldb.InternalKeyComparator.FindShortestSeparator,,false,120,122,FindShortestSeparator,,,5,"void leveldb.InternalKeyComparator.FindShortestSeparator (ANY*,Slice)"
30007,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,virtual void FindShortSuccessor(std::string* key) const;,16,57,db\dbformat.hpp,leveldb.InternalKeyComparator.FindShortSuccessor,,false,123,123,FindShortSuccessor,,,6,void leveldb.InternalKeyComparator.FindShortSuccessor (ANY*)
30012,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,const Comparator* user_comparator() const { return user_comparator_; },3,72,db\dbformat.hpp,leveldb.InternalKeyComparator.user_comparator,,false,125,125,user_comparator,,,7,Comparator leveldb.InternalKeyComparator.user_comparator ()
30018,METHOD,leveldb.InternalKeyComparator,TYPE_DECL,"int Compare(const InternalKey& a, const InternalKey& b) const;",7,63,db\dbformat.hpp,leveldb.InternalKeyComparator.Compare,,false,127,127,Compare,,,8,"int leveldb.InternalKeyComparator.Compare (InternalKey,InternalKey)"
30026,METHOD,leveldb.InternalFilterPolicy,TYPE_DECL,explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { },3,76,db\dbformat.hpp,leveldb.InternalFilterPolicy.InternalFilterPolicy,,false,135,135,InternalFilterPolicy,,,2,ANY leveldb.InternalFilterPolicy.InternalFilterPolicy (FilterPolicy*)
30031,METHOD,leveldb.InternalFilterPolicy,TYPE_DECL,virtual const char* Name() const;,21,34,db\dbformat.hpp,leveldb.InternalFilterPolicy.Name,,false,136,136,Name,,,3,char* leveldb.InternalFilterPolicy.Name ()
30035,METHOD,leveldb.InternalFilterPolicy,TYPE_DECL,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const;",16,77,db\dbformat.hpp,leveldb.InternalFilterPolicy.CreateFilter,,false,137,137,CreateFilter,,,4,"void leveldb.InternalFilterPolicy.CreateFilter (Slice*,int,ANY*)"
30042,METHOD,leveldb.InternalFilterPolicy,TYPE_DECL,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const;",16,71,db\dbformat.hpp,leveldb.InternalFilterPolicy.KeyMayMatch,,false,138,138,KeyMayMatch,,,5,"bool leveldb.InternalFilterPolicy.KeyMayMatch (Slice,Slice)"
30050,METHOD,leveldb.InternalKey,TYPE_DECL,InternalKey() { },3,19,db\dbformat.hpp,leveldb.InternalKey.InternalKey,,false,148,148,InternalKey,,,2,ANY leveldb.InternalKey.InternalKey ()
30054,METHOD,leveldb.InternalKey,TYPE_DECL,"InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {
    AppendInternalKey(&rep_, ParsedInternalKey(user_key, s, t));
  }",3,3,db\dbformat.hpp,leveldb.InternalKey.InternalKey,,false,149,151,InternalKey,,,3,"ANY leveldb.InternalKey.InternalKey (Slice,SequenceNumber,ValueType)"
30068,METHOD,leveldb.InternalKey,TYPE_DECL,"void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }",3,70,db\dbformat.hpp,leveldb.InternalKey.DecodeFrom,,false,153,153,DecodeFrom,,,4,void leveldb.InternalKey.DecodeFrom (Slice)
30085,METHOD,leveldb.InternalKey,TYPE_DECL,"Slice Encode() const {
    assert(!rep_.empty());
    return rep_;
  }",3,3,db\dbformat.hpp,leveldb.InternalKey.Encode,,false,154,157,Encode,,,5,Slice leveldb.InternalKey.Encode ()
30097,METHOD,leveldb.InternalKey,TYPE_DECL,Slice user_key() const { return ExtractUserKey(rep_); },3,57,db\dbformat.hpp,leveldb.InternalKey.user_key,,false,159,159,user_key,,,6,Slice leveldb.InternalKey.user_key ()
30104,METHOD,leveldb.InternalKey,TYPE_DECL,"void SetFrom(const ParsedInternalKey& p) {
    rep_.clear();
    AppendInternalKey(&rep_, p);
  }",3,3,db\dbformat.hpp,leveldb.InternalKey.SetFrom,,false,161,164,SetFrom,,,7,void leveldb.InternalKey.SetFrom (ParsedInternalKey)
30117,METHOD,leveldb.InternalKey,TYPE_DECL,void Clear() { rep_.clear(); },3,32,db\dbformat.hpp,leveldb.InternalKey.Clear,,false,166,166,Clear,,,8,void leveldb.InternalKey.Clear ()
30125,METHOD,leveldb.InternalKey,TYPE_DECL,std::string DebugString() const;,15,33,db\dbformat.hpp,leveldb.InternalKey.DebugString,,false,168,168,DebugString,,,9,ANY leveldb.InternalKey.DebugString ()
30129,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"inline int InternalKeyComparator::Compare(
    const InternalKey& a, const InternalKey& b) const {
  return Compare(a.Encode(), b.Encode());
}",1,1,db\dbformat.hpp,leveldb.InternalKeyComparator.Compare,,false,171,174,Compare,,,18,"int leveldb.InternalKeyComparator.Compare (InternalKey,InternalKey)"
30145,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"inline bool ParseInternalKey(const Slice& internal_key,
                             ParsedInternalKey* result) {
  const size_t n = internal_key.size();
  if (n < 8) return false;
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num & 0xff;
  result->sequence = num >> 8;
  result->type = static_cast<ValueType>(c);
  result->user_key = Slice(internal_key.data(), n - 8);
  return (c <= static_cast<unsigned char>(kTypeValue));
}",1,1,db\dbformat.hpp,leveldb.ParseInternalKey,,false,176,186,ParseInternalKey,,,19,"bool leveldb.ParseInternalKey (Slice,ParsedInternalKey*)"
30216,METHOD,leveldb.LookupKey,TYPE_DECL,"LookupKey(const Slice& user_key, SequenceNumber sequence);",3,59,db\dbformat.hpp,leveldb.LookupKey.LookupKey,,false,193,193,LookupKey,,,1,"ANY leveldb.LookupKey.LookupKey (Slice,SequenceNumber)"
30222,METHOD,leveldb.LookupKey,TYPE_DECL,~LookupKey();,3,14,db\dbformat.hpp,leveldb.LookupKey.~LookupKey,,false,195,195,~LookupKey,,,2,ANY leveldb.LookupKey.~LookupKey ()
30226,METHOD,leveldb.LookupKey,TYPE_DECL,"Slice memtable_key() const { return Slice(start_, end_ - start_); }",3,69,db\dbformat.hpp,leveldb.LookupKey.memtable_key,,false,198,198,memtable_key,,,3,Slice leveldb.LookupKey.memtable_key ()
30236,METHOD,leveldb.LookupKey,TYPE_DECL,"Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }",3,71,db\dbformat.hpp,leveldb.LookupKey.internal_key,,false,201,201,internal_key,,,4,Slice leveldb.LookupKey.internal_key ()
30246,METHOD,leveldb.LookupKey,TYPE_DECL,"Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }",3,71,db\dbformat.hpp,leveldb.LookupKey.user_key,,false,204,204,user_key,,,5,Slice leveldb.LookupKey.user_key ()
30262,METHOD,leveldb.LookupKey,TYPE_DECL,LookupKey(const LookupKey&);,3,29,db\dbformat.hpp,leveldb.LookupKey.LookupKey,,false,220,220,LookupKey,,,10,ANY leveldb.LookupKey.LookupKey (LookupKey)
30267,METHOD,leveldb.LookupKey,TYPE_DECL,void operator=(const LookupKey&);,8,34,db\dbformat.hpp,leveldb.LookupKey.operator =,,false,221,221,operator =,,,11,void leveldb.LookupKey.operator = (LookupKey)
30272,METHOD,<empty>,<empty>,<empty>,1,,db\dbformat.hpp,leveldb.LookupKey:<clinit>,,false,189,,<clinit>,,,12,
30278,METHOD,db\dbformat.hpp:<global>,TYPE_DECL,"inline LookupKey::~LookupKey() {
  if (start_ != space_) delete[] start_;
}",1,1,db\dbformat.hpp,leveldb.LookupKey.~LookupKey,,false,224,226,~LookupKey,,,21,ANY leveldb.LookupKey.~LookupKey ()
30298,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,<global>,1,1,db\dbformat_test.cc,db\dbformat_test.cc:<global>,,false,1,112,<global>,,,1,
30301,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"static std::string IKey(const std::string& user_key,
                        uint64_t seq,
                        ValueType vt) {
  std::string encoded;
  AppendInternalKey(&encoded, ParsedInternalKey(user_key, seq, vt));
  return encoded;
}",1,1,db\dbformat_test.cc,leveldb.IKey,,false,11,17,IKey,,,1,"string leveldb.IKey (ANY,uint64_t,ValueType)"
30318,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"static std::string Shorten(const std::string& s, const std::string& l) {
  std::string result = s;
  InternalKeyComparator(BytewiseComparator()).FindShortestSeparator(&result, l);
  return result;
}",1,1,db\dbformat_test.cc,leveldb.Shorten,,false,19,23,Shorten,,,2,"string leveldb.Shorten (ANY,ANY)"
30338,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"static std::string ShortSuccessor(const std::string& s) {
  std::string result = s;
  InternalKeyComparator(BytewiseComparator()).FindShortSuccessor(&result);
  return result;
}",1,1,db\dbformat_test.cc,leveldb.ShortSuccessor,,false,25,29,ShortSuccessor,,,3,string leveldb.ShortSuccessor (ANY)
30356,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"static void TestKey(const std::string& key,
                    uint64_t seq,
                    ValueType vt) {
  std::string encoded = IKey(key, seq, vt);

  Slice in(encoded);
  ParsedInternalKey decoded("""", 0, kTypeValue);

  ASSERT_TRUE(ParseInternalKey(in, &decoded));
  ASSERT_EQ(key, decoded.user_key.ToString());
  ASSERT_EQ(seq, decoded.sequence);
  ASSERT_EQ(vt, decoded.type);

  ASSERT_TRUE(!ParseInternalKey(Slice(""bar""), &decoded));
}",1,2,db\dbformat_test.cc,leveldb.TestKey,,false,31,45,TestKey,,,4,"void leveldb.TestKey (ANY,uint64_t,ValueType)"
30487,METHOD,leveldb._Test_InternalKey_EncodeDecode,TYPE_DECL,void void ();,1,42,db\dbformat_test.cc,leveldb._Test_InternalKey_EncodeDecode._Run,,false,49,49,_Run,,,1,void leveldb._Test_InternalKey_EncodeDecode._Run ()
30491,METHOD,leveldb._Test_InternalKey_EncodeDecode,TYPE_DECL,"TEST(FormatTest, InternalKey_EncodeDecode)",1,42,db\dbformat_test.cc,leveldb._Test_InternalKey_EncodeDecode._RunIt,,false,49,49,_RunIt,,,2,void leveldb._Test_InternalKey_EncodeDecode._RunIt ()
30515,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"TEST(FormatTest, InternalKey_EncodeDecode) {
  const char* keys[] = { """", ""k"", ""hello"", ""longggggggggggggggggggggg"" };
  const uint64_t seq[] = {
    1, 2, 3,
    (1ull << 8) - 1, 1ull << 8, (1ull << 8) + 1,
    (1ull << 16) - 1, 1ull << 16, (1ull << 16) + 1,
    (1ull << 32) - 1, 1ull << 32, (1ull << 32) + 1
  };
  for (int k = 0; k < sizeof(keys) / sizeof(keys[0]); k++) {
    for (int s = 0; s < sizeof(seq) / sizeof(seq[0]); s++) {
      TestKey(keys[k], seq[s], kTypeValue);
      TestKey(""hello"", 1, kTypeDeletion);
    }
  }
}",1,42,db\dbformat_test.cc,leveldb._Test_InternalKey_EncodeDecode._Run,,false,49,63,_Run,,,9,void leveldb._Test_InternalKey_EncodeDecode._Run ()
30622,METHOD,leveldb._Test_InternalKeyShortSeparator,TYPE_DECL,void void ();,1,43,db\dbformat_test.cc,leveldb._Test_InternalKeyShortSeparator._Run,,false,65,65,_Run,,,1,void leveldb._Test_InternalKeyShortSeparator._Run ()
30626,METHOD,leveldb._Test_InternalKeyShortSeparator,TYPE_DECL,"TEST(FormatTest, InternalKeyShortSeparator)",1,43,db\dbformat_test.cc,leveldb._Test_InternalKeyShortSeparator._RunIt,,false,65,65,_RunIt,,,2,void leveldb._Test_InternalKeyShortSeparator._RunIt ()
30650,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"TEST(FormatTest, InternalKeyShortSeparator) {
  // When user keys are same
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 99, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 101, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeValue)));
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeDeletion)));

  // When user keys are misordered
  ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""bar"", 99, kTypeValue)));

  // When user keys are different, but correctly ordered
  ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            Shorten(IKey(""foo"", 100, kTypeVal...",1,43,db\dbformat_test.cc,leveldb._Test_InternalKeyShortSeparator._Run,,false,65,99,_Run,,,13,void leveldb._Test_InternalKeyShortSeparator._Run ()
30863,METHOD,leveldb._Test_InternalKeyShortestSuccessor,TYPE_DECL,void void ();,1,46,db\dbformat_test.cc,leveldb._Test_InternalKeyShortestSuccessor._Run,,false,101,101,_Run,,,1,void leveldb._Test_InternalKeyShortestSuccessor._Run ()
30867,METHOD,leveldb._Test_InternalKeyShortestSuccessor,TYPE_DECL,"TEST(FormatTest, InternalKeyShortestSuccessor)",1,46,db\dbformat_test.cc,leveldb._Test_InternalKeyShortestSuccessor._RunIt,,false,101,101,_RunIt,,,2,void leveldb._Test_InternalKeyShortestSuccessor._RunIt ()
30891,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"TEST(FormatTest, InternalKeyShortestSuccessor) {
  ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            ShortSuccessor(IKey(""foo"", 100, kTypeValue)));
  ASSERT_EQ(IKey(""\xff\xff"", 100, kTypeValue),
            ShortSuccessor(IKey(""\xff\xff"", 100, kTypeValue)));
}",1,46,db\dbformat_test.cc,leveldb._Test_InternalKeyShortestSuccessor._Run,,false,101,106,_Run,,,17,void leveldb._Test_InternalKeyShortestSuccessor._Run ()
30939,METHOD,db\dbformat_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\dbformat_test.cc,main,,false,110,112,main,,,2,"int main (int,char**)"
30981,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,<global>,1,21,db\dumpfile.cc,db\dumpfile.cc:<global>,,false,1,225,<global>,,,1,
30985,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"bool GuessType(const std::string& fname, FileType* type) {
  size_t pos = fname.rfind('/');
  std::string basename;
  if (pos == std::string::npos) {
    basename = fname;
  } else {
    basename = std::string(fname.data() + pos + 1, fname.size() - pos - 1);
  }
  uint64_t ignored;
  return ParseFileName(basename, &ignored, type);
}",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_1.GuessType,,false,23,33,GuessType,,,1,"bool leveldb.anonymous_namespace_1.GuessType (ANY,FileType*)"
31045,METHOD,leveldb.anonymous_namespace_2.CorruptionReporter,TYPE_DECL,"virtual void Corruption(size_t bytes, const Status& status) {
    std::string r = ""corruption: "";
    AppendNumberTo(&r, bytes);
    r += "" bytes; "";
    r += status.ToString();
    r.push_back('\n');
    dst_->Append(r);
  }",3,3,db\dumpfile.cc,leveldb.anonymous_namespace_3.CorruptionReporter.Corruption,,false,39,46,Corruption,,,2,"void leveldb.anonymous_namespace_3.CorruptionReporter.Corruption (size_t,Status)"
31078,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"Status PrintLogContents(Env* env, const std::string& fname,
                        void (*func)(uint64_t, Slice, WritableFile*),
                        WritableFile* dst) {
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  CorruptionReporter reporter;
  reporter.dst_ = dst;
  log::Reader reader(file, &reporter, true, 0);
  Slice record;
  std::string scratch;
  while (reader.ReadRecord(&record, &scratch)) {
    (*func)(reader.LastRecordOffset(), record, dst);
  }
  delete file;
  return Status::OK();
}",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_4.PrintLogContents,,false,50,68,PrintLogContents,,,3,"Status leveldb.anonymous_namespace_4.PrintLogContents (Env*,ANY,void,WritableFile*)"
31149,METHOD,leveldb.anonymous_namespace_5.WriteBatchItemPrinter,TYPE_DECL,"virtual void Put(const Slice& key, const Slice& value) {
    std::string r = ""  put '"";
    AppendEscapedStringTo(&r, key);
    r += ""' '"";
    AppendEscapedStringTo(&r, value);
    r += ""'\n"";
    dst_->Append(r);
  }",3,3,db\dumpfile.cc,leveldb.anonymous_namespace_6.WriteBatchItemPrinter.Put,,false,74,81,Put,,,2,"void leveldb.anonymous_namespace_6.WriteBatchItemPrinter.Put (Slice,Slice)"
31178,METHOD,leveldb.anonymous_namespace_5.WriteBatchItemPrinter,TYPE_DECL,"virtual void Delete(const Slice& key) {
    std::string r = ""  del '"";
    AppendEscapedStringTo(&r, key);
    r += ""'\n"";
    dst_->Append(r);
  }",3,3,db\dumpfile.cc,leveldb.anonymous_namespace_7.WriteBatchItemPrinter.Delete,,false,82,87,Delete,,,3,void leveldb.anonymous_namespace_7.WriteBatchItemPrinter.Delete (Slice)
31199,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"static void WriteBatchPrinter(uint64_t pos, Slice record, WritableFile* dst) {
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  if (record.size() < 12) {
    r += ""log record length "";
    AppendNumberTo(&r, record.size());
    r += "" is too small\n"";
    dst->Append(r);
    return;
  }
  WriteBatch batch;
  WriteBatchInternal::SetContents(&batch, record);
  r += ""sequence "";
  AppendNumberTo(&r, WriteBatchInternal::Sequence(&batch));
  r.push_back('\n');
  dst->Append(r);
  WriteBatchItemPrinter batch_item_printer;
  batch_item_printer.dst_ = dst;
  Status s = batch.Iterate(&batch_item_printer);
  if (!s.ok()) {
    dst->Append(""  error: "" + s.ToString() + ""\n"");
  }
}",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_8.WriteBatchPrinter,,false,93,116,WriteBatchPrinter,,,5,"void leveldb.anonymous_namespace_8.WriteBatchPrinter (uint64_t,Slice,WritableFile*)"
31308,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"Status DumpLog(Env* env, const std::string& fname, WritableFile* dst) {
  return PrintLogContents(env, fname, WriteBatchPrinter, dst);
}",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_9.DumpLog,,false,118,120,DumpLog,,,6,"Status leveldb.anonymous_namespace_9.DumpLog (Env*,ANY,WritableFile*)"
31321,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"static void VersionEditPrinter(uint64_t pos, Slice record, WritableFile* dst) {
  std::string r = ""--- offset "";
  AppendNumberTo(&r, pos);
  r += ""; "";
  VersionEdit edit;
  Status s = edit.DecodeFrom(record);
  if (!s.ok()) {
    r += s.ToString();
    r.push_back('\n');
  } else {
    r += edit.DebugString();
  }
  dst->Append(r);
}",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_12.VersionEditPrinter,,false,124,137,VersionEditPrinter,,,7,"void leveldb.anonymous_namespace_12.VersionEditPrinter (uint64_t,Slice,WritableFile*)"
31379,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"Status DumpDescriptor(Env* env, const std::string& fname, WritableFile* dst) {
  return PrintLogContents(env, fname, VersionEditPrinter, dst);
}",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_13.DumpDescriptor,,false,139,141,DumpDescriptor,,,8,"Status leveldb.anonymous_namespace_13.DumpDescriptor (Env*,ANY,WritableFile*)"
31392,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"Status DumpTable(Env* env, const std::string& fname, WritableFile* dst) {
  uint64_t file_size;
  RandomAccessFile* file = NULL;
  Table* table = NULL;
  Status s = env->GetFileSize(fname, &file_size);
  if (s.ok()) {
    s = env->NewRandomAccessFile(fname, &file);
  }
  if (s.ok()) {
    // We use the default comparator, which may or may not match the
    // comparator used in this database. However this should not cause
    // problems since we only use Table operations that do not require
    // any comparisons.  In particular, we do not call Seek or Prev.
    s = Table::Open(Options(), file, file_size, &table);
  }
  if (!s.ok()) {
    delete table;
    delete file;
    return s;
  }

  ReadOptions ro;
  ro.fill_cache = false;
  Iterator* iter = table->NewIterator(ro);
  std::string r;
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    r.clear();
    ParsedInternalKey key;
    if (!ParseInternalKey(iter->key(), &key)) {
      r = ""badkey '"";
      AppendEscapedString...",1,1,db\dumpfile.cc,leveldb.anonymous_namespace_16.DumpTable,,false,143,206,DumpTable,,,9,"Status leveldb.anonymous_namespace_16.DumpTable (Env*,ANY,WritableFile*)"
31643,METHOD,db\dumpfile.cc:<global>,TYPE_DECL,"Status DumpFile(Env* env, const std::string& fname, WritableFile* dst) {
  FileType ftype;
  if (!GuessType(fname, &ftype)) {
    return Status::InvalidArgument(fname + "": unknown file type"");
  }
  switch (ftype) {
    case kLogFile:         return DumpLog(env, fname, dst);
    case kDescriptorFile:  return DumpDescriptor(env, fname, dst);
    case kTableFile:       return DumpTable(env, fname, dst);
    default:
      break;
  }
  return Status::InvalidArgument(fname + "": not a dump-able file type"");
}",1,1,db\dumpfile.cc,leveldb.DumpFile,,false,210,223,DumpFile,,,2,"Status leveldb.DumpFile (Env*,ANY,WritableFile*)"
31733,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,<global>,1,1,db\fault_injection_test.cc,db\fault_injection_test.cc:<global>,,false,1,554,<global>,,,1,
31750,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"static std::string GetDirName(const std::string filename) {
  size_t found = filename.find_last_of(""/\\"");
  if (found == std::string::npos) {
    return """";
  } else {
    return filename.substr(0, found);
  }
}",1,1,db\fault_injection_test.cc,leveldb.anonymous_namespace_1.GetDirName,,false,37,44,GetDirName,,,1,string leveldb.anonymous_namespace_1.GetDirName (ANY)
31783,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status SyncDir(const std::string& dir) {
  // As this is a test it isn't required to *actually* sync this directory.
  return Status::OK();
}",1,1,db\fault_injection_test.cc,leveldb.anonymous_namespace_2.SyncDir,,false,46,49,SyncDir,,,2,Status leveldb.anonymous_namespace_2.SyncDir (ANY)
31793,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status Truncate(const std::string& filename, uint64_t length) {
  leveldb::Env* env = leveldb::Env::Default();

  SequentialFile* orig_file;
  Status s = env->NewSequentialFile(filename, &orig_file);
  if (!s.ok())
    return s;

  char* scratch = new char[length];
  leveldb::Slice result;
  s = orig_file->Read(length, &result, scratch);
  delete orig_file;
  if (s.ok()) {
    std::string tmp_name = GetDirName(filename) + ""/truncate.tmp"";
    WritableFile* tmp_file;
    s = env->NewWritableFile(tmp_name, &tmp_file);
    if (s.ok()) {
      s = tmp_file->Append(result);
      delete tmp_file;
      if (s.ok()) {
        s = env->RenameFile(tmp_name, filename);
      } else {
        env->DeleteFile(tmp_name);
      }
    }
  }

  delete[] scratch;

  return s;
}",1,1,db\fault_injection_test.cc,leveldb.anonymous_namespace_3.Truncate,,false,52,82,Truncate,,,3,"Status leveldb.anonymous_namespace_3.Truncate (ANY,uint64_t)"
31914,METHOD,leveldb.anonymous_namespace_5.FileState,TYPE_DECL,"FileState(const std::string& filename)
      : filename_(filename),
        pos_(-1),
        pos_at_last_sync_(-1),
        pos_at_last_flush_(-1) { }",3,34,db\fault_injection_test.cc,leveldb.anonymous_namespace_6.FileState.FileState,,false,90,94,FileState,,,5,ANY leveldb.anonymous_namespace_6.FileState.FileState (ANY)
31919,METHOD,leveldb.anonymous_namespace_5.FileState,TYPE_DECL,"FileState() : pos_(-1), pos_at_last_sync_(-1), pos_at_last_flush_(-1) {}",3,74,db\fault_injection_test.cc,leveldb.anonymous_namespace_7.FileState.FileState,,false,96,96,FileState,,,6,ANY leveldb.anonymous_namespace_7.FileState.FileState ()
31923,METHOD,leveldb.anonymous_namespace_5.FileState,TYPE_DECL,bool IsFullySynced() const { return pos_ <= 0 || pos_ == pos_at_last_sync_; },3,79,db\fault_injection_test.cc,leveldb.anonymous_namespace_8.FileState.IsFullySynced,,false,98,98,IsFullySynced,,,7,bool leveldb.anonymous_namespace_8.FileState.IsFullySynced ()
31935,METHOD,leveldb.anonymous_namespace_5.FileState,TYPE_DECL,Status DropUnsyncedData() const;,10,33,db\fault_injection_test.cc,leveldb.anonymous_namespace_9.FileState.DropUnsyncedData,,false,100,100,DropUnsyncedData,,,8,Status leveldb.anonymous_namespace_9.FileState.DropUnsyncedData ()
31940,METHOD,leveldb.TestWritableFile,TYPE_DECL,"TestWritableFile(const FileState& state,
                   WritableFile* f,
                   FaultInjectionTestEnv* env);",3,46,db\fault_injection_test.cc,leveldb.TestWritableFile.TestWritableFile,,false,109,111,TestWritableFile,,,1,"ANY leveldb.TestWritableFile.TestWritableFile (FileState,WritableFile*,FaultInjectionTestEnv*)"
31947,METHOD,leveldb.TestWritableFile,TYPE_DECL,virtual ~TestWritableFile();,11,29,db\fault_injection_test.cc,leveldb.TestWritableFile.~TestWritableFile,,false,112,112,~TestWritableFile,,,2,virtual leveldb.TestWritableFile.~TestWritableFile ()
31951,METHOD,leveldb.TestWritableFile,TYPE_DECL,virtual Status Append(const Slice& data);,18,42,db\fault_injection_test.cc,leveldb.TestWritableFile.Append,,false,113,113,Append,,,3,Status leveldb.TestWritableFile.Append (Slice)
31956,METHOD,leveldb.TestWritableFile,TYPE_DECL,virtual Status Close();,18,24,db\fault_injection_test.cc,leveldb.TestWritableFile.Close,,false,114,114,Close,,,4,Status leveldb.TestWritableFile.Close ()
31960,METHOD,leveldb.TestWritableFile,TYPE_DECL,virtual Status Flush();,18,24,db\fault_injection_test.cc,leveldb.TestWritableFile.Flush,,false,115,115,Flush,,,5,Status leveldb.TestWritableFile.Flush ()
31964,METHOD,leveldb.TestWritableFile,TYPE_DECL,virtual Status Sync();,18,23,db\fault_injection_test.cc,leveldb.TestWritableFile.Sync,,false,116,116,Sync,,,6,Status leveldb.TestWritableFile.Sync ()
31972,METHOD,leveldb.TestWritableFile,TYPE_DECL,Status SyncParent();,10,21,db\fault_injection_test.cc,leveldb.TestWritableFile.SyncParent,,false,124,124,SyncParent,,,11,Status leveldb.TestWritableFile.SyncParent ()
31977,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,"FaultInjectionTestEnv() : EnvWrapper(Env::Default()), filesystem_active_(true) {}",3,83,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.FaultInjectionTestEnv,,false,129,129,FaultInjectionTestEnv,,,1,ANY leveldb.FaultInjectionTestEnv.FaultInjectionTestEnv ()
31981,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,virtual ~FaultInjectionTestEnv() { },3,38,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.~FaultInjectionTestEnv,,false,130,130,~FaultInjectionTestEnv,,,2,ANY leveldb.FaultInjectionTestEnv.~FaultInjectionTestEnv ()
31985,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result);",18,55,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.NewWritableFile,,false,131,132,NewWritableFile,,,3,"Status leveldb.FaultInjectionTestEnv.NewWritableFile (ANY,WritableFile**)"
31991,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result);",18,57,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.NewAppendableFile,,false,133,134,NewAppendableFile,,,4,"Status leveldb.FaultInjectionTestEnv.NewAppendableFile (ANY,WritableFile**)"
31997,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,virtual Status DeleteFile(const std::string& f);,18,49,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DeleteFile,,false,135,135,DeleteFile,,,5,Status leveldb.FaultInjectionTestEnv.DeleteFile (ANY)
32002,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,"virtual Status RenameFile(const std::string& s, const std::string& t);",18,71,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.RenameFile,,false,136,136,RenameFile,,,6,"Status leveldb.FaultInjectionTestEnv.RenameFile (ANY,ANY)"
32008,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,void WritableFileClosed(const FileState& state);,8,49,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.WritableFileClosed,,false,138,138,WritableFileClosed,,,7,void leveldb.FaultInjectionTestEnv.WritableFileClosed (FileState)
32013,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,Status DropUnsyncedFileData();,10,31,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DropUnsyncedFileData,,false,139,139,DropUnsyncedFileData,,,8,Status leveldb.FaultInjectionTestEnv.DropUnsyncedFileData ()
32017,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,Status DeleteFilesCreatedAfterLastDirSync();,10,45,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DeleteFilesCreatedAfterLastDirSync,,false,140,140,DeleteFilesCreatedAfterLastDirSync,,,9,Status leveldb.FaultInjectionTestEnv.DeleteFilesCreatedAfterLastDirSync ()
32021,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,void DirWasSynced();,8,21,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DirWasSynced,,false,141,141,DirWasSynced,,,10,void leveldb.FaultInjectionTestEnv.DirWasSynced ()
32025,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,bool IsFileCreatedSinceLastDirSync(const std::string& filename);,8,65,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.IsFileCreatedSinceLastDirSync,,false,142,142,IsFileCreatedSinceLastDirSync,,,11,bool leveldb.FaultInjectionTestEnv.IsFileCreatedSinceLastDirSync (ANY)
32030,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,void ResetState();,8,19,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.ResetState,,false,143,143,ResetState,,,12,void leveldb.FaultInjectionTestEnv.ResetState ()
32034,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,void UntrackFile(const std::string& f);,8,40,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.UntrackFile,,false,144,144,UntrackFile,,,13,void leveldb.FaultInjectionTestEnv.UntrackFile (ANY)
32039,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,bool IsFilesystemActive() const { return filesystem_active_; },3,64,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.IsFilesystemActive,,false,149,149,IsFilesystemActive,,,14,bool leveldb.FaultInjectionTestEnv.IsFilesystemActive ()
32045,METHOD,leveldb.FaultInjectionTestEnv,TYPE_DECL,void SetFilesystemActive(bool active) { filesystem_active_ = active; },3,72,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.SetFilesystemActive,,false,150,150,SetFilesystemActive,,,15,void leveldb.FaultInjectionTestEnv.SetFilesystemActive (bool)
32057,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"TestWritableFile::TestWritableFile(const FileState& state,
                                   WritableFile* f,
                                   FaultInjectionTestEnv* env)
    : state_(state),
      target_(f),
      writable_file_opened_(true),
      env_(env) {
  assert(f != NULL);
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.TestWritableFile,,false,159,167,TestWritableFile,,,11,"ANY leveldb.TestWritableFile.TestWritableFile (FileState,WritableFile*,FaultInjectionTestEnv*)"
32068,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"TestWritableFile::~TestWritableFile() {
  if (writable_file_opened_) {
    Close();
  }
  delete target_;
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.~TestWritableFile,,false,169,174,~TestWritableFile,,,12,ANY leveldb.TestWritableFile.~TestWritableFile ()
32078,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status TestWritableFile::Append(const Slice& data) {
  Status s = target_->Append(data);
  if (s.ok() && env_->IsFilesystemActive()) {
    state_.pos_ += data.size();
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.Append,,false,176,182,Append,,,13,Status leveldb.TestWritableFile.Append (Slice)
32112,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status TestWritableFile::Close() {
  writable_file_opened_ = false;
  Status s = target_->Close();
  if (s.ok()) {
    env_->WritableFileClosed(state_);
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.Close,,false,184,191,Close,,,14,Status leveldb.TestWritableFile.Close ()
32139,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status TestWritableFile::Flush() {
  Status s = target_->Flush();
  if (s.ok() && env_->IsFilesystemActive()) {
    state_.pos_at_last_flush_ = state_.pos_;
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.Flush,,false,193,199,Flush,,,15,Status leveldb.TestWritableFile.Flush ()
32170,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status TestWritableFile::SyncParent() {
  Status s = SyncDir(GetDirName(state_.filename_));
  if (s.ok()) {
    env_->DirWasSynced();
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.SyncParent,,false,201,207,SyncParent,,,16,Status leveldb.TestWritableFile.SyncParent ()
32194,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status TestWritableFile::Sync() {
  if (!env_->IsFilesystemActive()) {
    return Status::OK();
  }
  // Ensure new files referred to by the manifest are in the filesystem.
  Status s = target_->Sync();
  if (s.ok()) {
    state_.pos_at_last_sync_ = state_.pos_;
  }
  if (env_->IsFileCreatedSinceLastDirSync(state_.filename_)) {
    Status ps = SyncParent();
    if (s.ok() && !ps.ok()) {
      s = ps;
    }
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.TestWritableFile.Sync,,false,209,225,Sync,,,17,Status leveldb.TestWritableFile.Sync ()
32260,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FaultInjectionTestEnv::NewWritableFile(const std::string& fname,
                                              WritableFile** result) {
  WritableFile* actual_writable_file;
  Status s = target()->NewWritableFile(fname, &actual_writable_file);
  if (s.ok()) {
    FileState state(fname);
    state.pos_ = 0;
    *result = new TestWritableFile(state, actual_writable_file, this);
    // NewWritableFile doesn't append to files, so if the same file is
    // opened again then it will be truncated - so forget our saved
    // state.
    UntrackFile(fname);
    MutexLock l(&mutex_);
    new_files_since_last_dir_sync_.insert(fname);
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.NewWritableFile,,false,227,243,NewWritableFile,,,18,"Status leveldb.FaultInjectionTestEnv.NewWritableFile (ANY,WritableFile**)"
32312,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FaultInjectionTestEnv::NewAppendableFile(const std::string& fname,
                                                WritableFile** result) {
  WritableFile* actual_writable_file;
  Status s = target()->NewAppendableFile(fname, &actual_writable_file);
  if (s.ok()) {
    FileState state(fname);
    state.pos_ = 0;
    {
      MutexLock l(&mutex_);
      if (db_file_state_.count(fname) == 0) {
        new_files_since_last_dir_sync_.insert(fname);
      } else {
        state = db_file_state_[fname];
      }
    }
    *result = new TestWritableFile(state, actual_writable_file, this);
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.NewAppendableFile,,false,245,263,NewAppendableFile,,,19,"Status leveldb.FaultInjectionTestEnv.NewAppendableFile (ANY,WritableFile**)"
32379,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FaultInjectionTestEnv::DropUnsyncedFileData() {
  Status s;
  MutexLock l(&mutex_);
  for (std::map<std::string, FileState>::const_iterator it =
           db_file_state_.begin();
       s.ok() && it != db_file_state_.end(); ++it) {
    const FileState& state = it->second;
    if (!state.IsFullySynced()) {
      s = state.DropUnsyncedData();
    }
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DropUnsyncedFileData,,false,265,277,DropUnsyncedFileData,,,20,Status leveldb.FaultInjectionTestEnv.DropUnsyncedFileData ()
32432,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"void FaultInjectionTestEnv::DirWasSynced() {
  MutexLock l(&mutex_);
  new_files_since_last_dir_sync_.clear();
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DirWasSynced,,false,279,282,DirWasSynced,,,21,void leveldb.FaultInjectionTestEnv.DirWasSynced ()
32444,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"bool FaultInjectionTestEnv::IsFileCreatedSinceLastDirSync(
    const std::string& filename) {
  MutexLock l(&mutex_);
  return new_files_since_last_dir_sync_.find(filename) !=
         new_files_since_last_dir_sync_.end();
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.IsFileCreatedSinceLastDirSync,,false,284,289,IsFileCreatedSinceLastDirSync,,,22,bool leveldb.FaultInjectionTestEnv.IsFileCreatedSinceLastDirSync (ANY)
32464,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"void FaultInjectionTestEnv::UntrackFile(const std::string& f) {
  MutexLock l(&mutex_);
  db_file_state_.erase(f);
  new_files_since_last_dir_sync_.erase(f);
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.UntrackFile,,false,291,295,UntrackFile,,,23,void leveldb.FaultInjectionTestEnv.UntrackFile (ANY)
32483,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FaultInjectionTestEnv::DeleteFile(const std::string& f) {
  Status s = EnvWrapper::DeleteFile(f);
  ASSERT_OK(s);
  if (s.ok()) {
    UntrackFile(f);
  }
  return s;
}",1,2,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DeleteFile,,false,297,304,DeleteFile,,,24,Status leveldb.FaultInjectionTestEnv.DeleteFile (ANY)
32521,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FaultInjectionTestEnv::RenameFile(const std::string& s,
                                         const std::string& t) {
  Status ret = EnvWrapper::RenameFile(s, t);

  if (ret.ok()) {
    MutexLock l(&mutex_);
    if (db_file_state_.find(s) != db_file_state_.end()) {
      db_file_state_[t] = db_file_state_[s];
      db_file_state_.erase(s);
    }

    if (new_files_since_last_dir_sync_.erase(s) != 0) {
      assert(new_files_since_last_dir_sync_.find(t) ==
             new_files_since_last_dir_sync_.end());
      new_files_since_last_dir_sync_.insert(t);
    }
  }

  return ret;
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.RenameFile,,false,306,325,RenameFile,,,25,"Status leveldb.FaultInjectionTestEnv.RenameFile (ANY,ANY)"
32597,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"void FaultInjectionTestEnv::ResetState() {
  // Since we are not destroying the database, the existing files
  // should keep their recorded synced/flushed state. Therefore
  // we do not reset db_file_state_ and new_files_since_last_dir_sync_.
  MutexLock l(&mutex_);
  SetFilesystemActive(true);
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.ResetState,,false,327,333,ResetState,,,26,void leveldb.FaultInjectionTestEnv.ResetState ()
32607,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FaultInjectionTestEnv::DeleteFilesCreatedAfterLastDirSync() {
  // Because DeleteFile access this container make a copy to avoid deadlock
  mutex_.Lock();
  std::set<std::string> new_files(new_files_since_last_dir_sync_.begin(),
                                  new_files_since_last_dir_sync_.end());
  mutex_.Unlock();
  Status s;
  std::set<std::string>::const_iterator it;
  for (it = new_files.begin(); s.ok() && it != new_files.end(); ++it) {
    s = DeleteFile(*it);
  }
  return s;
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.DeleteFilesCreatedAfterLastDirSync,,false,335,347,DeleteFilesCreatedAfterLastDirSync,,,27,Status leveldb.FaultInjectionTestEnv.DeleteFilesCreatedAfterLastDirSync ()
32667,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"void FaultInjectionTestEnv::WritableFileClosed(const FileState& state) {
  MutexLock l(&mutex_);
  db_file_state_[state.filename_] = state;
}",1,1,db\fault_injection_test.cc,leveldb.FaultInjectionTestEnv.WritableFileClosed,,false,349,352,WritableFileClosed,,,28,void leveldb.FaultInjectionTestEnv.WritableFileClosed (FileState)
32683,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"Status FileState::DropUnsyncedData() const {
  ssize_t sync_pos = pos_at_last_sync_ == -1 ? 0 : pos_at_last_sync_;
  return Truncate(filename_, sync_pos);
}",1,1,db\fault_injection_test.cc,leveldb.FileState.DropUnsyncedData,,false,354,357,DropUnsyncedData,,,29,Status leveldb.FileState.DropUnsyncedData ()
32713,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"FaultInjectionTest()
      : env_(new FaultInjectionTestEnv),
        tiny_cache_(NewLRUCache(100)),
        db_(NULL) {
    dbname_ = test::TmpDir() + ""/fault_test"";
    DestroyDB(dbname_, Options());  // Destroy any db from earlier run
    options_.reuse_logs = true;
    options_.env = env_;
    options_.paranoid_checks = true;
    options_.block_cache = tiny_cache_;
    options_.create_if_missing = true;
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.FaultInjectionTest,,false,370,381,FaultInjectionTest,,,8,ANY leveldb.FaultInjectionTest.FaultInjectionTest ()
32753,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"~FaultInjectionTest() {
    CloseDB();
    DestroyDB(dbname_, Options());
    delete tiny_cache_;
    delete env_;
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.~FaultInjectionTest,,false,383,388,~FaultInjectionTest,,,9,ANY leveldb.FaultInjectionTest.~FaultInjectionTest ()
32765,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void ReuseLogs(bool reuse) {
    options_.reuse_logs = reuse;
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.ReuseLogs,,false,390,392,ReuseLogs,,,10,void leveldb.FaultInjectionTest.ReuseLogs (bool)
32775,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void Build(int start_idx, int num_vals) {
    std::string key_space, value_space;
    WriteBatch batch;
    for (int i = start_idx; i < start_idx + num_vals; i++) {
      Slice key = Key(i, &key_space);
      batch.Clear();
      batch.Put(key, Value(i, &value_space));
      WriteOptions options;
      ASSERT_OK(db_->Write(options, &batch));
    }
  }",3,6,db\fault_injection_test.cc,leveldb.FaultInjectionTest.Build,,false,394,404,Build,,,11,"void leveldb.FaultInjectionTest.Build (int,int)"
32839,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"Status ReadValue(int i, std::string* val) const {
    std::string key_space, value_space;
    Slice key = Key(i, &key_space);
    Value(i, &value_space);
    ReadOptions options;
    return db_->Get(options, key, val);
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.ReadValue,,false,406,412,ReadValue,,,12,"Status leveldb.FaultInjectionTest.ReadValue (int,ANY*)"
32867,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"Status Verify(int start_idx, int num_vals,
                ExpectedVerifResult expected) const {
    std::string val;
    std::string value_space;
    Status s;
    for (int i = start_idx; i < start_idx + num_vals && s.ok(); i++) {
      Value(i, &value_space);
      s = ReadValue(i, &val);
      if (expected == VAL_EXPECT_NO_ERROR) {
        if (s.ok()) {
          ASSERT_EQ(value_space, val);
        }
      } else if (s.ok()) {
        fprintf(stderr, ""Expected an error at %d, but was OK\n"", i);
        s = Status::IOError(dbname_, ""Expected value error:"");
      } else {
        s = Status::OK();  // An expected error
      }
    }
    return s;
  }",3,10,db\fault_injection_test.cc,leveldb.FaultInjectionTest.Verify,,false,414,434,Verify,,,13,"Status leveldb.FaultInjectionTest.Verify (int,int,ExpectedVerifResult)"
32964,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"Slice Key(int i, std::string* storage) const {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%016d"", i);
    storage->assign(buf, strlen(buf));
    return Slice(*storage);
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.Key,,false,437,442,Key,,,14,"Slice leveldb.FaultInjectionTest.Key (int,ANY*)"
32988,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"Slice Value(int k, std::string* storage) const {
    Random r(k);
    return test::RandomString(&r, kValueSize, storage);
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.Value,,false,445,448,Value,,,15,"Slice leveldb.FaultInjectionTest.Value (int,ANY*)"
33006,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"Status OpenDB() {
    delete db_;
    db_ = NULL;
    env_->ResetState();
    return DB::Open(options_, dbname_, &db_);
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.OpenDB,,false,450,455,OpenDB,,,16,Status leveldb.FaultInjectionTest.OpenDB ()
33028,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void CloseDB() {
    delete db_;
    db_ = NULL;
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.CloseDB,,false,457,460,CloseDB,,,17,void leveldb.FaultInjectionTest.CloseDB ()
33037,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void DeleteAllData() {
    Iterator* iter = db_->NewIterator(ReadOptions());
    WriteOptions options;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      ASSERT_OK(db_->Delete(WriteOptions(), iter->key()));
    }

    delete iter;
  }",3,6,db\fault_injection_test.cc,leveldb.FaultInjectionTest.DeleteAllData,,false,462,470,DeleteAllData,,,18,void leveldb.FaultInjectionTest.DeleteAllData ()
33089,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void ResetDBState(ResetMethod reset_method) {
    switch (reset_method) {
      case RESET_DROP_UNSYNCED_DATA:
        ASSERT_OK(env_->DropUnsyncedFileData());
        break;
      case RESET_DELETE_UNSYNCED_FILES:
        ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync());
        break;
      default:
        assert(false);
    }
  }",3,8,db\fault_injection_test.cc,leveldb.FaultInjectionTest.ResetDBState,,false,472,483,ResetDBState,,,19,void leveldb.FaultInjectionTest.ResetDBState (ResetMethod)
33148,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void PartialCompactTestPreFault(int num_pre_sync, int num_post_sync) {
    DeleteAllData();
    Build(0, num_pre_sync);
    db_->CompactRange(NULL, NULL);
    Build(num_pre_sync, num_post_sync);
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.PartialCompactTestPreFault,,false,485,490,PartialCompactTestPreFault,,,20,"void leveldb.FaultInjectionTest.PartialCompactTestPreFault (int,int)"
33167,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void PartialCompactTestReopenWithFault(ResetMethod reset_method,
                                         int num_pre_sync,
                                         int num_post_sync) {
    env_->SetFilesystemActive(false);
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
    ASSERT_OK(Verify(0, num_pre_sync, FaultInjectionTest::VAL_EXPECT_NO_ERROR));
    ASSERT_OK(Verify(num_pre_sync, num_post_sync, FaultInjectionTest::VAL_EXPECT_ERROR));
  }",3,4,db\fault_injection_test.cc,leveldb.FaultInjectionTest.PartialCompactTestReopenWithFault,,false,492,501,PartialCompactTestReopenWithFault,,,21,"void leveldb.FaultInjectionTest.PartialCompactTestReopenWithFault (ResetMethod,int,int)"
33235,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void NoWriteTestPreFault() {
  }",3,3,db\fault_injection_test.cc,leveldb.FaultInjectionTest.NoWriteTestPreFault,,false,503,504,NoWriteTestPreFault,,,22,void leveldb.FaultInjectionTest.NoWriteTestPreFault ()
33239,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void NoWriteTestReopenWithFault(ResetMethod reset_method) {
    CloseDB();
    ResetDBState(reset_method);
    ASSERT_OK(OpenDB());
  }",3,4,db\fault_injection_test.cc,leveldb.FaultInjectionTest.NoWriteTestReopenWithFault,,false,506,510,NoWriteTestReopenWithFault,,,23,void leveldb.FaultInjectionTest.NoWriteTestReopenWithFault (ResetMethod)
33262,METHOD,leveldb.FaultInjectionTest,TYPE_DECL,"void DoTest() {
    Random rnd(0);
    ASSERT_OK(OpenDB());
    for (size_t idx = 0; idx < kNumIterations; idx++) {
      int num_pre_sync = rnd.Uniform(kMaxNumValues);
      int num_post_sync = rnd.Uniform(kMaxNumValues);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      PartialCompactTestReopenWithFault(RESET_DROP_UNSYNCED_DATA,
                                        num_pre_sync,
                                        num_post_sync);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DROP_UNSYNCED_DATA);

      PartialCompactTestPreFault(num_pre_sync, num_post_sync);
      // No new files created so we expect all values since no files will be
      // dropped.
      PartialCompactTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES,
                                        num_pre_sync + num_post_sync,
                                        0);

      NoWriteTestPreFault();
      NoWriteTestReopenWithFault(RESET_DELETE_UNSYNCED_FILES);
    }
  }",3,4,db\fault_injection_test.cc,leveldb.FaultInjectionTest.DoTest,,false,512,537,DoTest,,,24,void leveldb.FaultInjectionTest.DoTest ()
33335,METHOD,leveldb._Test_FaultTestNoLogReuse,TYPE_DECL,void void ();,1,45,db\fault_injection_test.cc,leveldb._Test_FaultTestNoLogReuse._Run,,false,540,540,_Run,,,1,void leveldb._Test_FaultTestNoLogReuse._Run ()
33339,METHOD,leveldb._Test_FaultTestNoLogReuse,TYPE_DECL,"TEST(FaultInjectionTest, FaultTestNoLogReuse)",1,45,db\fault_injection_test.cc,leveldb._Test_FaultTestNoLogReuse._RunIt,,false,540,540,_RunIt,,,2,void leveldb._Test_FaultTestNoLogReuse._RunIt ()
33363,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"TEST(FaultInjectionTest, FaultTestNoLogReuse) {
  ReuseLogs(false);
  DoTest();
}",1,45,db\fault_injection_test.cc,leveldb._Test_FaultTestNoLogReuse._Run,,false,540,543,_Run,,,34,void leveldb._Test_FaultTestNoLogReuse._Run ()
33371,METHOD,leveldb._Test_FaultTestWithLogReuse,TYPE_DECL,void void ();,1,47,db\fault_injection_test.cc,leveldb._Test_FaultTestWithLogReuse._Run,,false,545,545,_Run,,,1,void leveldb._Test_FaultTestWithLogReuse._Run ()
33375,METHOD,leveldb._Test_FaultTestWithLogReuse,TYPE_DECL,"TEST(FaultInjectionTest, FaultTestWithLogReuse)",1,47,db\fault_injection_test.cc,leveldb._Test_FaultTestWithLogReuse._RunIt,,false,545,545,_RunIt,,,2,void leveldb._Test_FaultTestWithLogReuse._RunIt ()
33399,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"TEST(FaultInjectionTest, FaultTestWithLogReuse) {
  ReuseLogs(true);
  DoTest();
}",1,47,db\fault_injection_test.cc,leveldb._Test_FaultTestWithLogReuse._Run,,false,545,548,_Run,,,38,void leveldb._Test_FaultTestWithLogReuse._Run ()
33406,METHOD,db\fault_injection_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\fault_injection_test.cc,main,,false,552,554,main,,,2,"int main (int,char**)"
33434,METHOD,db\filename.cc:<global>,TYPE_DECL,<global>,1,21,db\filename.cc,db\filename.cc:<global>,,false,1,144,<global>,,,1,
33437,METHOD,db\filename.cc:<global>,TYPE_DECL,"extern Status WriteStringToFileSync(Env* env, const Slice& data,
                                    const std::string& fname);",15,61,db\filename.cc,leveldb.WriteStringToFileSync,,false,15,16,WriteStringToFileSync,,,1,"Status leveldb.WriteStringToFileSync (Env*,Slice,ANY)"
33444,METHOD,db\filename.cc:<global>,TYPE_DECL,"static std::string MakeFileName(const std::string& name, uint64_t number,
                                const char* suffix) {
  char buf[100];
  snprintf(buf, sizeof(buf), ""/%06llu.%s"",
           static_cast<unsigned long long>(number),
           suffix);
  return name + buf;
}",1,1,db\filename.cc,leveldb.MakeFileName,,false,18,25,MakeFileName,,,2,"string leveldb.MakeFileName (ANY,uint64_t,char*)"
33465,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string LogFileName(const std::string& name, uint64_t number) {
  assert(number > 0);
  return MakeFileName(name, number, ""log"");
}",1,1,db\filename.cc,leveldb.LogFileName,,false,27,30,LogFileName,,,3,"string leveldb.LogFileName (ANY,uint64_t)"
33480,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string TableFileName(const std::string& name, uint64_t number) {
  assert(number > 0);
  return MakeFileName(name, number, ""ldb"");
}",1,1,db\filename.cc,leveldb.TableFileName,,false,32,35,TableFileName,,,4,"string leveldb.TableFileName (ANY,uint64_t)"
33495,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string SSTTableFileName(const std::string& name, uint64_t number) {
  assert(number > 0);
  return MakeFileName(name, number, ""sst"");
}",1,1,db\filename.cc,leveldb.SSTTableFileName,,false,37,40,SSTTableFileName,,,5,"string leveldb.SSTTableFileName (ANY,uint64_t)"
33510,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string DescriptorFileName(const std::string& dbname, uint64_t number) {
  assert(number > 0);
  char buf[100];
  snprintf(buf, sizeof(buf), ""/MANIFEST-%06llu"",
           static_cast<unsigned long long>(number));
  return dbname + buf;
}",1,1,db\filename.cc,leveldb.DescriptorFileName,,false,42,48,DescriptorFileName,,,6,"string leveldb.DescriptorFileName (ANY,uint64_t)"
33533,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string CurrentFileName(const std::string& dbname) {
  return dbname + ""/CURRENT"";
}",1,1,db\filename.cc,leveldb.CurrentFileName,,false,50,52,CurrentFileName,,,7,string leveldb.CurrentFileName (ANY)
33542,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string LockFileName(const std::string& dbname) {
  return dbname + ""/LOCK"";
}",1,1,db\filename.cc,leveldb.LockFileName,,false,54,56,LockFileName,,,8,string leveldb.LockFileName (ANY)
33551,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string TempFileName(const std::string& dbname, uint64_t number) {
  assert(number > 0);
  return MakeFileName(dbname, number, ""dbtmp"");
}",1,1,db\filename.cc,leveldb.TempFileName,,false,58,61,TempFileName,,,9,"string leveldb.TempFileName (ANY,uint64_t)"
33566,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string InfoLogFileName(const std::string& dbname) {
  return dbname + ""/LOG"";
}",1,1,db\filename.cc,leveldb.InfoLogFileName,,false,63,65,InfoLogFileName,,,10,string leveldb.InfoLogFileName (ANY)
33575,METHOD,db\filename.cc:<global>,TYPE_DECL,"std::string OldInfoLogFileName(const std::string& dbname) {
  return dbname + ""/LOG.old"";
}",1,1,db\filename.cc,leveldb.OldInfoLogFileName,,false,68,70,OldInfoLogFileName,,,11,string leveldb.OldInfoLogFileName (ANY)
33584,METHOD,db\filename.cc:<global>,TYPE_DECL,"bool ParseFileName(const std::string& fname,
                   uint64_t* number,
                   FileType* type) {
  Slice rest(fname);
  if (rest == ""CURRENT"") {
    *number = 0;
    *type = kCurrentFile;
  } else if (rest == ""LOCK"") {
    *number = 0;
    *type = kDBLockFile;
  } else if (rest == ""LOG"" || rest == ""LOG.old"") {
    *number = 0;
    *type = kInfoLogFile;
  } else if (rest.starts_with(""MANIFEST-"")) {
    rest.remove_prefix(strlen(""MANIFEST-""));
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    if (!rest.empty()) {
      return false;
    }
    *type = kDescriptorFile;
    *number = num;
  } else {
    // Avoid strtoull() to keep filename format independent of the
    // current locale
    uint64_t num;
    if (!ConsumeDecimalNumber(&rest, &num)) {
      return false;
    }
    Slice suffix = rest;
    if (suffix == Slice("".log"")) {
      *type = kLogFile;
    } else if (suffix == Slice("".sst"") || suffix == Slice("".ldb""))...",1,1,db\filename.cc,leveldb.ParseFileName,,false,80,124,ParseFileName,,,12,"bool leveldb.ParseFileName (ANY,uint64_t*,FileType*)"
33750,METHOD,db\filename.cc:<global>,TYPE_DECL,"Status SetCurrentFile(Env* env, const std::string& dbname,
                      uint64_t descriptor_number) {
  // Remove leading ""dbname/"" and add newline to manifest file name
  std::string manifest = DescriptorFileName(dbname, descriptor_number);
  Slice contents = manifest;
  assert(contents.starts_with(dbname + ""/""));
  contents.remove_prefix(dbname.size() + 1);
  std::string tmp = TempFileName(dbname, descriptor_number);
  Status s = WriteStringToFileSync(env, contents.ToString() + ""\n"", tmp);
  if (s.ok()) {
    s = env->RenameFile(tmp, CurrentFileName(dbname));
  }
  if (!s.ok()) {
    env->DeleteFile(tmp);
  }
  return s;
}",1,1,db\filename.cc,leveldb.SetCurrentFile,,false,126,142,SetCurrentFile,,,13,"Status leveldb.SetCurrentFile (Env*,ANY,uint64_t)"
33845,METHOD,db\filename.hpp:<global>,TYPE_DECL,<global>,1,18,db\filename.hpp,db\filename.hpp:<global>,,false,1,85,<global>,,,1,
33857,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern std::string LogFileName(const std::string& dbname, uint64_t number);",20,74,db\filename.hpp,leveldb.LogFileName,,false,33,33,LogFileName,,,3,"ANY leveldb.LogFileName (ANY,uint64_t)"
33863,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern std::string TableFileName(const std::string& dbname, uint64_t number);",20,76,db\filename.hpp,leveldb.TableFileName,,false,38,38,TableFileName,,,4,"ANY leveldb.TableFileName (ANY,uint64_t)"
33869,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern std::string SSTTableFileName(const std::string& dbname, uint64_t number);",20,79,db\filename.hpp,leveldb.SSTTableFileName,,false,43,43,SSTTableFileName,,,5,"ANY leveldb.SSTTableFileName (ANY,uint64_t)"
33875,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern std::string DescriptorFileName(const std::string& dbname,
                                      uint64_t number);",20,54,db\filename.hpp,leveldb.DescriptorFileName,,false,48,49,DescriptorFileName,,,6,"ANY leveldb.DescriptorFileName (ANY,uint64_t)"
33881,METHOD,db\filename.hpp:<global>,TYPE_DECL,extern std::string CurrentFileName(const std::string& dbname);,20,61,db\filename.hpp,leveldb.CurrentFileName,,false,54,54,CurrentFileName,,,7,ANY leveldb.CurrentFileName (ANY)
33886,METHOD,db\filename.hpp:<global>,TYPE_DECL,extern std::string LockFileName(const std::string& dbname);,20,58,db\filename.hpp,leveldb.LockFileName,,false,58,58,LockFileName,,,8,ANY leveldb.LockFileName (ANY)
33891,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern std::string TempFileName(const std::string& dbname, uint64_t number);",20,75,db\filename.hpp,leveldb.TempFileName,,false,62,62,TempFileName,,,9,"ANY leveldb.TempFileName (ANY,uint64_t)"
33897,METHOD,db\filename.hpp:<global>,TYPE_DECL,extern std::string InfoLogFileName(const std::string& dbname);,20,61,db\filename.hpp,leveldb.InfoLogFileName,,false,65,65,InfoLogFileName,,,10,ANY leveldb.InfoLogFileName (ANY)
33902,METHOD,db\filename.hpp:<global>,TYPE_DECL,extern std::string OldInfoLogFileName(const std::string& dbname);,20,64,db\filename.hpp,leveldb.OldInfoLogFileName,,false,68,68,OldInfoLogFileName,,,11,ANY leveldb.OldInfoLogFileName (ANY)
33907,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern bool ParseFileName(const std::string& filename,
                          uint64_t* number,
                          FileType* type);",13,41,db\filename.hpp,leveldb.ParseFileName,,false,73,75,ParseFileName,,,12,"bool leveldb.ParseFileName (ANY,uint64_t*,FileType*)"
33914,METHOD,db\filename.hpp:<global>,TYPE_DECL,"extern Status SetCurrentFile(Env* env, const std::string& dbname,
                             uint64_t descriptor_number);",15,56,db\filename.hpp,leveldb.SetCurrentFile,,false,79,80,SetCurrentFile,,,13,"Status leveldb.SetCurrentFile (Env*,ANY,uint64_t)"
33934,METHOD,db\filename_test.cc:<global>,TYPE_DECL,<global>,1,1,db\filename_test.cc,db\filename_test.cc:<global>,,false,1,123,<global>,,,1,
33939,METHOD,leveldb._Test_Parse,TYPE_DECL,void void ();,1,25,db\filename_test.cc,leveldb._Test_Parse._Run,,false,16,16,_Run,,,1,void leveldb._Test_Parse._Run ()
33943,METHOD,leveldb._Test_Parse,TYPE_DECL,"TEST(FileNameTest, Parse)",1,25,db\filename_test.cc,leveldb._Test_Parse._RunIt,,false,16,16,_RunIt,,,2,void leveldb._Test_Parse._RunIt ()
33967,METHOD,db\filename_test.cc:<global>,TYPE_DECL,"TEST(FileNameTest, Parse) {
  Slice db;
  FileType type;
  uint64_t number;

  // Successful parses
  static struct {
    const char* fname;
    uint64_t number;
    FileType type;
  } cases[] = {
    { ""100.log"",            100,   kLogFile },
    { ""0.log"",              0,     kLogFile },
    { ""0.sst"",              0,     kTableFile },
    { ""0.ldb"",              0,     kTableFile },
    { ""CURRENT"",            0,     kCurrentFile },
    { ""LOCK"",               0,     kDBLockFile },
    { ""MANIFEST-2"",         2,     kDescriptorFile },
    { ""MANIFEST-7"",         7,     kDescriptorFile },
    { ""LOG"",                0,     kInfoLogFile },
    { ""LOG.old"",            0,     kInfoLogFile },
    { ""18446744073709551615.log"", 18446744073709551615ull, kLogFile },
  };
  for (int i = 0; i < sizeof(cases) / sizeof(cases[0]); i++) {
    std::string f = cases[i].fname;
    ASSERT_TRUE(ParseFileName(f, &number, &type)) << f;
    ASSERT_EQ(cases[i].type, type) << f;
    ASSERT_EQ(cases[i].nu...",1,25,db\filename_test.cc,leveldb._Test_Parse._Run,,false,16,75,_Run,,,5,void leveldb._Test_Parse._Run ()
34198,METHOD,leveldb._Test_Construction,TYPE_DECL,void void ();,1,32,db\filename_test.cc,leveldb._Test_Construction._Run,,false,77,77,_Run,,,1,void leveldb._Test_Construction._Run ()
34202,METHOD,leveldb._Test_Construction,TYPE_DECL,"TEST(FileNameTest, Construction)",1,32,db\filename_test.cc,leveldb._Test_Construction._RunIt,,false,77,77,_RunIt,,,2,void leveldb._Test_Construction._RunIt ()
34226,METHOD,db\filename_test.cc:<global>,TYPE_DECL,"TEST(FileNameTest, Construction) {
  uint64_t number;
  FileType type;
  std::string fname;

  fname = CurrentFileName(""foo"");
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(0, number);
  ASSERT_EQ(kCurrentFile, type);

  fname = LockFileName(""foo"");
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(0, number);
  ASSERT_EQ(kDBLockFile, type);

  fname = LogFileName(""foo"", 192);
  ASSERT_EQ(""foo/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(192, number);
  ASSERT_EQ(kLogFile, type);

  fname = TableFileName(""bar"", 200);
  ASSERT_EQ(""bar/"", std::string(fname.data(), 4));
  ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type));
  ASSERT_EQ(200, number);
  ASSERT_EQ(kTableFile, type);

  fname = DescriptorFileName(""bar"", 100);
  ASSERT_EQ(""bar/"", std::string(...",1,32,db\filename_test.cc,leveldb._Test_Construction._Run,,false,77,117,_Run,,,9,void leveldb._Test_Construction._Run ()
34759,METHOD,db\filename_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\filename_test.cc,main,,false,121,123,main,,,2,"int main (int,char**)"
34783,METHOD,db\leveldbutil.cc:<global>,TYPE_DECL,<global>,1,21,db\leveldbutil.cc,db\leveldbutil.cc:<global>,,false,1,64,<global>,,,1,
34788,METHOD,leveldb.anonymous_namespace_1.StdoutPrinter,TYPE_DECL,"virtual Status Append(const Slice& data) {
    fwrite(data.data(), 1, data.size(), stdout);
    return Status::OK();
  }",3,3,db\leveldbutil.cc,leveldb.anonymous_namespace_2.StdoutPrinter.Append,,false,15,18,Append,,,1,Status leveldb.anonymous_namespace_2.StdoutPrinter.Append (Slice)
34809,METHOD,leveldb.anonymous_namespace_1.StdoutPrinter,TYPE_DECL,virtual Status Close() { return Status::OK(); },3,49,db\leveldbutil.cc,leveldb.anonymous_namespace_3.StdoutPrinter.Close,,false,19,19,Close,,,2,Status leveldb.anonymous_namespace_3.StdoutPrinter.Close ()
34818,METHOD,leveldb.anonymous_namespace_1.StdoutPrinter,TYPE_DECL,virtual Status Flush() { return Status::OK(); },3,49,db\leveldbutil.cc,leveldb.anonymous_namespace_4.StdoutPrinter.Flush,,false,20,20,Flush,,,3,Status leveldb.anonymous_namespace_4.StdoutPrinter.Flush ()
34827,METHOD,leveldb.anonymous_namespace_1.StdoutPrinter,TYPE_DECL,virtual Status Sync() { return Status::OK(); },3,48,db\leveldbutil.cc,leveldb.anonymous_namespace_5.StdoutPrinter.Sync,,false,21,21,Sync,,,4,Status leveldb.anonymous_namespace_5.StdoutPrinter.Sync ()
34836,METHOD,db\leveldbutil.cc:<global>,TYPE_DECL,"bool HandleDumpCommand(Env* env, char** files, int num) {
  StdoutPrinter printer;
  bool ok = true;
  for (int i = 0; i < num; i++) {
    Status s = DumpFile(env, files[i], &printer);
    if (!s.ok()) {
      fprintf(stderr, ""%s\n"", s.ToString().c_str());
      ok = false;
    }
  }
  return ok;
}",1,1,db\leveldbutil.cc,leveldb.anonymous_namespace_6.HandleDumpCommand,,false,24,35,HandleDumpCommand,,,2,"bool leveldb.anonymous_namespace_6.HandleDumpCommand (Env*,char**,int)"
34892,METHOD,db\leveldbutil.cc:<global>,TYPE_DECL,"static void Usage() {
  fprintf(
      stderr,
      ""Usage: leveldbutil command...\n""
      ""   dump files...         -- dump contents of specified files\n""
      );
}",1,1,db\leveldbutil.cc,Usage,,false,40,46,Usage,,,2,void Usage ()
34899,METHOD,db\leveldbutil.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  leveldb::Env* env = leveldb::Env::Default();
  bool ok = true;
  if (argc < 2) {
    Usage();
    ok = false;
  } else {
    std::string command = argv[1];
    if (command == ""dump"") {
      ok = leveldb::HandleDumpCommand(env, argv+2, argc-2);
    } else {
      Usage();
      ok = false;
    }
  }
  return (ok ? 0 : 1);
}",1,1,db\leveldbutil.cc,main,,false,48,64,main,,,3,"int main (int,char**)"
34967,METHOD,db\log_format.hpp:<global>,TYPE_DECL,<global>,1,43,db\log_format.hpp,db\log_format.hpp:<global>,,false,1,35,<global>,,,1,
34977,METHOD,<empty>,<empty>,<empty>,1,,db\log_format.hpp,leveldb.log.RecordType:<clinit>,,false,14,,<clinit>,,,6,
35025,METHOD,db\log_reader.cc:<global>,TYPE_DECL,<global>,1,1,db\log_reader.cc,db\log_reader.cc:<global>,,false,1,284,<global>,,,1,
35029,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"Reader::Reporter::~Reporter() {
}",1,1,db\log_reader.cc,leveldb.log.Reader.Reporter.~Reporter,,false,15,16,~Reporter,,,1,ANY leveldb.log.Reader.Reporter.~Reporter ()
35033,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,
               uint64_t initial_offset)
    : file_(file),
      reporter_(reporter),
      checksum_(checksum),
      backing_store_(new char[kBlockSize]),
      buffer_(),
      eof_(false),
      last_record_offset_(0),
      end_of_buffer_offset_(0),
      initial_offset_(initial_offset),
      resyncing_(initial_offset > 0) {
}",1,1,db\log_reader.cc,leveldb.log.Reader.Reader,,false,18,30,Reader,,,2,"ANY leveldb.log.Reader.Reader (SequentialFile*,Reporter*,bool,uint64_t)"
35041,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"Reader::~Reader() {
  delete[] backing_store_;
}",1,1,db\log_reader.cc,leveldb.log.Reader.~Reader,,false,32,34,~Reader,,,3,ANY leveldb.log.Reader.~Reader ()
35047,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"bool Reader::SkipToInitialBlock() {
  size_t offset_in_block = initial_offset_ % kBlockSize;
  uint64_t block_start_location = initial_offset_ - offset_in_block;

  // Don't search a block if we'd be in the trailer
  if (offset_in_block > kBlockSize - 6) {
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  // Skip to start of first block that can contain the initial record
  if (block_start_location > 0) {
    Status skip_status = file_->Skip(block_start_location);
    if (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status);
      return false;
    }
  }

  return true;
}",1,1,db\log_reader.cc,leveldb.log.Reader.SkipToInitialBlock,,false,36,58,SkipToInitialBlock,,,4,bool leveldb.log.Reader.SkipToInitialBlock ()
35106,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"bool Reader::ReadRecord(Slice* record, std::string* scratch) {
  if (last_record_offset_ < initial_offset_) {
    if (!SkipToInitialBlock()) {
      return false;
    }
  }

  scratch->clear();
  record->clear();
  bool in_fragmented_record = false;
  // Record offset of the logical record that we're reading
  // 0 is a dummy value to make compilers happy
  uint64_t prospective_record_offset = 0;

  Slice fragment;
  while (true) {
    const unsigned int record_type = ReadPhysicalRecord(&fragment);

    // ReadPhysicalRecord may have only had an empty trailer remaining in its
    // internal buffer. Calculate the offset of the next physical record now
    // that it has returned, properly accounting for its header size.
    uint64_t physical_record_offset =
        end_of_buffer_offset_ - buffer_.size() - kHeaderSize - fragment.size();

    if (resyncing_) {
      if (record_type == kMiddleType) {
        continue;
      } else if (record_type == kLastType) {
        resyncing_ = fa...",1,1,db\log_reader.cc,leveldb.log.Reader.ReadRecord,,false,60,182,ReadRecord,,,5,"bool leveldb.log.Reader.ReadRecord (Slice*,ANY*)"
35400,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"uint64_t Reader::LastRecordOffset() {
  return last_record_offset_;
}",1,1,db\log_reader.cc,leveldb.log.Reader.LastRecordOffset,,false,184,186,LastRecordOffset,,,6,uint64_t leveldb.log.Reader.LastRecordOffset ()
35406,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"void Reader::ReportCorruption(uint64_t bytes, const char* reason) {
  ReportDrop(bytes, Status::Corruption(reason));
}",1,1,db\log_reader.cc,leveldb.log.Reader.ReportCorruption,,false,188,190,ReportCorruption,,,7,"void leveldb.log.Reader.ReportCorruption (uint64_t,char*)"
35419,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"void Reader::ReportDrop(uint64_t bytes, const Status& reason) {
  if (reporter_ != NULL &&
      end_of_buffer_offset_ - buffer_.size() - bytes >= initial_offset_) {
    reporter_->Corruption(static_cast<size_t>(bytes), reason);
  }
}",1,1,db\log_reader.cc,leveldb.log.Reader.ReportDrop,,false,192,197,ReportDrop,,,8,"void leveldb.log.Reader.ReportDrop (uint64_t,Status)"
35449,METHOD,db\log_reader.cc:<global>,TYPE_DECL,"unsigned int Reader::ReadPhysicalRecord(Slice* result) {
  while (true) {
    if (buffer_.size() < kHeaderSize) {
      if (!eof_) {
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        Status status = file_->Read(kBlockSize, &buffer_, backing_store_);
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) {
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() < kBlockSize) {
          eof_ = true;
        }
        continue;
      } else {
        // Note that if buffer_ is non-empty, we have a truncated header at the
        // end of the file, which can be caused by the writer crashing in the
        // middle of writing the header. Instead of considering this an error,
        // just report EOF.
        buffer_.clear();
        return kEof;
      }
    }

    // Parse the header
    const char* header = buffer_.data()...",1,1,db\log_reader.cc,leveldb.log.Reader.ReadPhysicalRecord,,false,199,281,ReadPhysicalRecord,,,9,unsigned int leveldb.log.Reader.ReadPhysicalRecord (Slice*)
35713,METHOD,db\log_reader.hpp:<global>,TYPE_DECL,<global>,1,1,db\log_reader.hpp,db\log_reader.hpp:<global>,,false,1,113,<global>,,,1,
35720,METHOD,leveldb.log.Reader.Reporter,TYPE_DECL,virtual ~Reporter();,13,23,db\log_reader.hpp,leveldb.log.Reader.Reporter.~Reporter,,false,25,25,~Reporter,,,1,virtual leveldb.log.Reader.Reporter.~Reporter ()
35724,METHOD,leveldb.log.Reader.Reporter,TYPE_DECL,"virtual void Corruption(size_t bytes, const Status& status) = 0;",18,67,db\log_reader.hpp,leveldb.log.Reader.Reporter.Corruption,,false,29,29,Corruption,,,2,"void leveldb.log.Reader.Reporter.Corruption (size_t,Status)"
35730,METHOD,leveldb.log.Reader,TYPE_DECL,"Reader(SequentialFile* file, Reporter* reporter, bool checksum,
         uint64_t initial_offset);",3,33,db\log_reader.hpp,leveldb.log.Reader.Reader,,false,43,44,Reader,,,2,"ANY leveldb.log.Reader.Reader (SequentialFile*,Reporter*,bool,uint64_t)"
35738,METHOD,leveldb.log.Reader,TYPE_DECL,~Reader();,3,11,db\log_reader.hpp,leveldb.log.Reader.~Reader,,false,46,46,~Reader,,,3,ANY leveldb.log.Reader.~Reader ()
35742,METHOD,leveldb.log.Reader,TYPE_DECL,"bool ReadRecord(Slice* record, std::string* scratch);",8,54,db\log_reader.hpp,leveldb.log.Reader.ReadRecord,,false,53,53,ReadRecord,,,4,"bool leveldb.log.Reader.ReadRecord (Slice*,ANY*)"
35748,METHOD,leveldb.log.Reader,TYPE_DECL,uint64_t LastRecordOffset();,12,29,db\log_reader.hpp,leveldb.log.Reader.LastRecordOffset,,false,58,58,LastRecordOffset,,,5,uint64_t leveldb.log.Reader.LastRecordOffset ()
35765,METHOD,<empty>,<empty>,<empty>,3,,db\log_reader.hpp,leveldb.log.Reader.anonymous_enum_0:<clinit>,,false,82,,<clinit>,,,3,
35779,METHOD,leveldb.log.Reader,TYPE_DECL,bool SkipToInitialBlock();,8,27,db\log_reader.hpp,leveldb.log.Reader.SkipToInitialBlock,,false,95,95,SkipToInitialBlock,,,17,bool leveldb.log.Reader.SkipToInitialBlock ()
35783,METHOD,leveldb.log.Reader,TYPE_DECL,unsigned int ReadPhysicalRecord(Slice* result);,16,48,db\log_reader.hpp,leveldb.log.Reader.ReadPhysicalRecord,,false,98,98,ReadPhysicalRecord,,,18,unsigned int leveldb.log.Reader.ReadPhysicalRecord (Slice*)
35788,METHOD,leveldb.log.Reader,TYPE_DECL,"void ReportCorruption(uint64_t bytes, const char* reason);",8,59,db\log_reader.hpp,leveldb.log.Reader.ReportCorruption,,false,102,102,ReportCorruption,,,19,"void leveldb.log.Reader.ReportCorruption (uint64_t,char*)"
35794,METHOD,leveldb.log.Reader,TYPE_DECL,"void ReportDrop(uint64_t bytes, const Status& reason);",8,55,db\log_reader.hpp,leveldb.log.Reader.ReportDrop,,false,103,103,ReportDrop,,,20,"void leveldb.log.Reader.ReportDrop (uint64_t,Status)"
35800,METHOD,leveldb.log.Reader,TYPE_DECL,Reader(const Reader&);,3,23,db\log_reader.hpp,leveldb.log.Reader.Reader,,false,106,106,Reader,,,21,ANY leveldb.log.Reader.Reader (Reader)
35805,METHOD,leveldb.log.Reader,TYPE_DECL,void operator=(const Reader&);,8,31,db\log_reader.hpp,leveldb.log.Reader.operator =,,false,107,107,operator =,,,22,void leveldb.log.Reader.operator = (Reader)
35827,METHOD,db\log_test.cc:<global>,TYPE_DECL,<global>,1,1,db\log_test.cc,db\log_test.cc:<global>,,false,1,591,<global>,,,1,
35831,METHOD,db\log_test.cc:<global>,TYPE_DECL,"static std::string BigString(const std::string& partial_string, size_t n) {
  std::string result;
  while (result.size() < n) {
    result.append(partial_string);
  }
  result.resize(n);
  return result;
}",1,1,db\log_test.cc,leveldb.log.BigString,,false,18,25,BigString,,,1,"string leveldb.log.BigString (ANY,size_t)"
35858,METHOD,db\log_test.cc:<global>,TYPE_DECL,"static std::string NumberString(int n) {
  char buf[50];
  snprintf(buf, sizeof(buf), ""%d."", n);
  return std::string(buf);
}",1,1,db\log_test.cc,leveldb.log.NumberString,,false,28,32,NumberString,,,2,string leveldb.log.NumberString (int)
35876,METHOD,db\log_test.cc:<global>,TYPE_DECL,"static std::string RandomSkewedString(int i, Random* rnd) {
  return BigString(NumberString(i), rnd->Skewed(17));
}",1,1,db\log_test.cc,leveldb.log.RandomSkewedString,,false,35,37,RandomSkewedString,,,3,"string leveldb.log.RandomSkewedString (int,Random*)"
35894,METHOD,leveldb.log.LogTest.StringDest,TYPE_DECL,virtual Status Close() { return Status::OK(); },5,51,db\log_test.cc,leveldb.log.LogTest.StringDest.Close,,false,45,45,Close,,,2,Status leveldb.log.LogTest.StringDest.Close ()
35903,METHOD,leveldb.log.LogTest.StringDest,TYPE_DECL,virtual Status Flush() { return Status::OK(); },5,51,db\log_test.cc,leveldb.log.LogTest.StringDest.Flush,,false,46,46,Flush,,,3,Status leveldb.log.LogTest.StringDest.Flush ()
35912,METHOD,leveldb.log.LogTest.StringDest,TYPE_DECL,virtual Status Sync() { return Status::OK(); },5,50,db\log_test.cc,leveldb.log.LogTest.StringDest.Sync,,false,47,47,Sync,,,4,Status leveldb.log.LogTest.StringDest.Sync ()
35921,METHOD,leveldb.log.LogTest.StringDest,TYPE_DECL,"virtual Status Append(const Slice& slice) {
      contents_.append(slice.data(), slice.size());
      return Status::OK();
    }",5,5,db\log_test.cc,leveldb.log.LogTest.StringDest.Append,,false,48,51,Append,,,5,Status leveldb.log.LogTest.StringDest.Append (Slice)
35947,METHOD,leveldb.log.LogTest.StringSource,TYPE_DECL,"StringSource() : force_error_(false), returned_partial_(false) { }",5,70,db\log_test.cc,leveldb.log.LogTest.StringSource.StringSource,,false,59,59,StringSource,,,4,ANY leveldb.log.LogTest.StringSource.StringSource ()
35951,METHOD,leveldb.log.LogTest.StringSource,TYPE_DECL,"virtual Status Read(size_t n, Slice* result, char* scratch) {
      ASSERT_TRUE(!returned_partial_) << ""must not Read() after eof/error"";

      if (force_error_) {
        force_error_ = false;
        returned_partial_ = true;
        return Status::Corruption(""read error"");
      }

      if (contents_.size() < n) {
        n = contents_.size();
        returned_partial_ = true;
      }
      *result = Slice(contents_.data(), n);
      contents_.remove_prefix(n);
      return Status::OK();
    }",5,6,db\log_test.cc,leveldb.log.LogTest.StringSource.Read,,false,61,77,Read,,,5,"Status leveldb.log.LogTest.StringSource.Read (size_t,Slice*,char*)"
36029,METHOD,leveldb.log.LogTest.StringSource,TYPE_DECL,"virtual Status Skip(uint64_t n) {
      if (n > contents_.size()) {
        contents_.clear();
        return Status::NotFound(""in-memory file skipped past end"");
      }

      contents_.remove_prefix(n);

      return Status::OK();
    }",5,5,db\log_test.cc,leveldb.log.LogTest.StringSource.Skip,,false,79,88,Skip,,,6,Status leveldb.log.LogTest.StringSource.Skip (uint64_t)
36065,METHOD,leveldb.log.LogTest.ReportCollector,TYPE_DECL,ReportCollector() : dropped_bytes_(0) { },5,45,db\log_test.cc,leveldb.log.LogTest.ReportCollector.ReportCollector,,false,96,96,ReportCollector,,,3,ANY leveldb.log.LogTest.ReportCollector.ReportCollector ()
36069,METHOD,leveldb.log.LogTest.ReportCollector,TYPE_DECL,"virtual void Corruption(size_t bytes, const Status& status) {
      dropped_bytes_ += bytes;
      message_.append(status.ToString());
    }",5,5,db\log_test.cc,leveldb.log.LogTest.ReportCollector.Corruption,,false,97,100,Corruption,,,4,"void leveldb.log.LogTest.ReportCollector.Corruption (size_t,Status)"
36095,METHOD,leveldb.log.LogTest,TYPE_DECL,"LogTest() : reading_(false),
              writer_(new Writer(&dest_)),
              reader_(new Reader(&source_, &report_, true/*checksum*/,
                      0/*initial_offset*/)) {
  }",3,3,db\log_test.cc,leveldb.log.LogTest.LogTest,,false,116,120,LogTest,,,13,ANY leveldb.log.LogTest.LogTest ()
36099,METHOD,leveldb.log.LogTest,TYPE_DECL,"~LogTest() {
    delete writer_;
    delete reader_;
  }",3,3,db\log_test.cc,leveldb.log.LogTest.~LogTest,,false,122,125,~LogTest,,,14,ANY leveldb.log.LogTest.~LogTest ()
36107,METHOD,leveldb.log.LogTest,TYPE_DECL,"void ReopenForAppend() {
    delete writer_;
    writer_ = new Writer(&dest_, dest_.contents_.size());
  }",3,3,db\log_test.cc,leveldb.log.LogTest.ReopenForAppend,,false,127,130,ReopenForAppend,,,15,void leveldb.log.LogTest.ReopenForAppend ()
36125,METHOD,leveldb.log.LogTest,TYPE_DECL,"void Write(const std::string& msg) {
    ASSERT_TRUE(!reading_) << ""Write() after starting to read"";
    writer_->AddRecord(Slice(msg));
  }",3,4,db\log_test.cc,leveldb.log.LogTest.Write,,false,132,135,Write,,,16,void leveldb.log.LogTest.Write (ANY)
36156,METHOD,leveldb.log.LogTest,TYPE_DECL,"size_t WrittenBytes() const {
    return dest_.contents_.size();
  }",3,3,db\log_test.cc,leveldb.log.LogTest.WrittenBytes,,false,137,139,WrittenBytes,,,17,size_t leveldb.log.LogTest.WrittenBytes ()
36167,METHOD,leveldb.log.LogTest,TYPE_DECL,"std::string Read() {
    if (!reading_) {
      reading_ = true;
      source_.contents_ = Slice(dest_.contents_);
    }
    std::string scratch;
    Slice record;
    if (reader_->ReadRecord(&record, &scratch)) {
      return record.ToString();
    } else {
      return ""EOF"";
    }
  }",3,3,db\log_test.cc,leveldb.log.LogTest.Read,,false,141,153,Read,,,18,string leveldb.log.LogTest.Read ()
36207,METHOD,leveldb.log.LogTest,TYPE_DECL,"void IncrementByte(int offset, int delta) {
    dest_.contents_[offset] += delta;
  }",3,3,db\log_test.cc,leveldb.log.LogTest.IncrementByte,,false,155,157,IncrementByte,,,19,"void leveldb.log.LogTest.IncrementByte (int,int)"
36220,METHOD,leveldb.log.LogTest,TYPE_DECL,"void SetByte(int offset, char new_byte) {
    dest_.contents_[offset] = new_byte;
  }",3,3,db\log_test.cc,leveldb.log.LogTest.SetByte,,false,159,161,SetByte,,,20,"void leveldb.log.LogTest.SetByte (int,char)"
36233,METHOD,leveldb.log.LogTest,TYPE_DECL,"void ShrinkSize(int bytes) {
    dest_.contents_.resize(dest_.contents_.size() - bytes);
  }",3,3,db\log_test.cc,leveldb.log.LogTest.ShrinkSize,,false,163,165,ShrinkSize,,,21,void leveldb.log.LogTest.ShrinkSize (int)
36252,METHOD,leveldb.log.LogTest,TYPE_DECL,"void FixChecksum(int header_offset, int len) {
    // Compute crc of type/len/data
    uint32_t crc = crc32c::Value(&dest_.contents_[header_offset+6], 1 + len);
    crc = crc32c::Mask(crc);
    EncodeFixed32(&dest_.contents_[header_offset], crc);
  }",3,3,db\log_test.cc,leveldb.log.LogTest.FixChecksum,,false,167,172,FixChecksum,,,22,"void leveldb.log.LogTest.FixChecksum (int,int)"
36291,METHOD,leveldb.log.LogTest,TYPE_DECL,"void ForceError() {
    source_.force_error_ = true;
  }",3,3,db\log_test.cc,leveldb.log.LogTest.ForceError,,false,174,176,ForceError,,,23,void leveldb.log.LogTest.ForceError ()
36300,METHOD,leveldb.log.LogTest,TYPE_DECL,"size_t DroppedBytes() const {
    return report_.dropped_bytes_;
  }",3,3,db\log_test.cc,leveldb.log.LogTest.DroppedBytes,,false,178,180,DroppedBytes,,,24,size_t leveldb.log.LogTest.DroppedBytes ()
36308,METHOD,leveldb.log.LogTest,TYPE_DECL,"std::string ReportMessage() const {
    return report_.message_;
  }",3,3,db\log_test.cc,leveldb.log.LogTest.ReportMessage,,false,182,184,ReportMessage,,,25,string leveldb.log.LogTest.ReportMessage ()
36316,METHOD,leveldb.log.LogTest,TYPE_DECL,"std::string MatchError(const std::string& msg) const {
    if (report_.message_.find(msg) == std::string::npos) {
      return report_.message_;
    } else {
      return ""OK"";
    }
  }",3,3,db\log_test.cc,leveldb.log.LogTest.MatchError,,false,187,193,MatchError,,,26,string leveldb.log.LogTest.MatchError (ANY)
36344,METHOD,leveldb.log.LogTest,TYPE_DECL,"void WriteInitialOffsetLog() {
    for (int i = 0; i < num_initial_offset_records_; i++) {
      std::string record(initial_offset_record_sizes_[i],
                         static_cast<char>('a' + i));
      Write(record);
    }
  }",3,3,db\log_test.cc,leveldb.log.LogTest.WriteInitialOffsetLog,,false,195,201,WriteInitialOffsetLog,,,27,void leveldb.log.LogTest.WriteInitialOffsetLog ()
36372,METHOD,leveldb.log.LogTest,TYPE_DECL,"void StartReadingAt(uint64_t initial_offset) {
    delete reader_;
    reader_ = new Reader(&source_, &report_, true/*checksum*/, initial_offset);
  }",3,3,db\log_test.cc,leveldb.log.LogTest.StartReadingAt,,false,203,206,StartReadingAt,,,28,void leveldb.log.LogTest.StartReadingAt (uint64_t)
36389,METHOD,leveldb.log.LogTest,TYPE_DECL,"void CheckOffsetPastEndReturnsNoRecords(uint64_t offset_past_end) {
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       WrittenBytes() + offset_past_end);
    Slice record;
    std::string scratch;
    ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch));
    delete offset_reader;
  }",3,4,db\log_test.cc,leveldb.log.LogTest.CheckOffsetPastEndReturnsNoRecords,,false,208,218,CheckOffsetPastEndReturnsNoRecords,,,29,void leveldb.log.LogTest.CheckOffsetPastEndReturnsNoRecords (uint64_t)
36446,METHOD,leveldb.log.LogTest,TYPE_DECL,"void CheckInitialOffsetRecord(uint64_t initial_offset,
                                int expected_record_offset) {
    WriteInitialOffsetLog();
    reading_ = true;
    source_.contents_ = Slice(dest_.contents_);
    Reader* offset_reader = new Reader(&source_, &report_, true/*checksum*/,
                                       initial_offset);

    // Read all records from expected_record_offset through the last one.
    ASSERT_LT(expected_record_offset, num_initial_offset_records_);
    for (; expected_record_offset < num_initial_offset_records_;
         ++expected_record_offset) {
      Slice record;
      std::string scratch;
      ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch));
      ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size());
      ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset());
      ASSERT_EQ((char)('a' + expected_record_offset), record....",3,4,db\log_test.cc,leveldb.log.LogTest.CheckInitialOffsetRecord,,false,220,242,CheckInitialOffsetRecord,,,30,"void leveldb.log.LogTest.CheckInitialOffsetRecord (uint64_t,int)"
36610,METHOD,<empty>,<empty>,<empty>,1,,db\log_test.cc,leveldb.log.LogTest:<clinit>,,false,39,,<clinit>,,,31,
36703,METHOD,leveldb.log._Test_Empty,TYPE_DECL,void void ();,1,20,db\log_test.cc,leveldb.log._Test_Empty._Run,,false,270,270,_Run,,,1,void leveldb.log._Test_Empty._Run ()
36707,METHOD,leveldb.log._Test_Empty,TYPE_DECL,"TEST(LogTest, Empty)",1,20,db\log_test.cc,leveldb.log._Test_Empty._RunIt,,false,270,270,_RunIt,,,2,void leveldb.log._Test_Empty._RunIt ()
36731,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, Empty) {
  ASSERT_EQ(""EOF"", Read());
}",1,20,db\log_test.cc,leveldb.log._Test_Empty._Run,,false,270,272,_Run,,,14,void leveldb.log._Test_Empty._Run ()
36753,METHOD,leveldb.log._Test_ReadWrite,TYPE_DECL,void void ();,1,24,db\log_test.cc,leveldb.log._Test_ReadWrite._Run,,false,274,274,_Run,,,1,void leveldb.log._Test_ReadWrite._Run ()
36757,METHOD,leveldb.log._Test_ReadWrite,TYPE_DECL,"TEST(LogTest, ReadWrite)",1,24,db\log_test.cc,leveldb.log._Test_ReadWrite._RunIt,,false,274,274,_RunIt,,,2,void leveldb.log._Test_ReadWrite._RunIt ()
36781,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadWrite) {
  Write(""foo"");
  Write(""bar"");
  Write("""");
  Write(""xxxx"");
  ASSERT_EQ(""foo"", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""xxxx"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(""EOF"", Read());  // Make sure reads at eof work
}",1,24,db\log_test.cc,leveldb.log._Test_ReadWrite._Run,,false,274,285,_Run,,,18,void leveldb.log._Test_ReadWrite._Run ()
36896,METHOD,leveldb.log._Test_ManyBlocks,TYPE_DECL,void void ();,1,25,db\log_test.cc,leveldb.log._Test_ManyBlocks._Run,,false,287,287,_Run,,,1,void leveldb.log._Test_ManyBlocks._Run ()
36900,METHOD,leveldb.log._Test_ManyBlocks,TYPE_DECL,"TEST(LogTest, ManyBlocks)",1,25,db\log_test.cc,leveldb.log._Test_ManyBlocks._RunIt,,false,287,287,_RunIt,,,2,void leveldb.log._Test_ManyBlocks._RunIt ()
36924,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ManyBlocks) {
  for (int i = 0; i < 100000; i++) {
    Write(NumberString(i));
  }
  for (int i = 0; i < 100000; i++) {
    ASSERT_EQ(NumberString(i), Read());
  }
  ASSERT_EQ(""EOF"", Read());
}",1,25,db\log_test.cc,leveldb.log._Test_ManyBlocks._Run,,false,287,295,_Run,,,22,void leveldb.log._Test_ManyBlocks._Run ()
36992,METHOD,leveldb.log._Test_Fragmentation,TYPE_DECL,void void ();,1,28,db\log_test.cc,leveldb.log._Test_Fragmentation._Run,,false,297,297,_Run,,,1,void leveldb.log._Test_Fragmentation._Run ()
36996,METHOD,leveldb.log._Test_Fragmentation,TYPE_DECL,"TEST(LogTest, Fragmentation)",1,28,db\log_test.cc,leveldb.log._Test_Fragmentation._RunIt,,false,297,297,_RunIt,,,2,void leveldb.log._Test_Fragmentation._RunIt ()
37020,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, Fragmentation) {
  Write(""small"");
  Write(BigString(""medium"", 50000));
  Write(BigString(""large"", 100000));
  ASSERT_EQ(""small"", Read());
  ASSERT_EQ(BigString(""medium"", 50000), Read());
  ASSERT_EQ(BigString(""large"", 100000), Read());
  ASSERT_EQ(""EOF"", Read());
}",1,28,db\log_test.cc,leveldb.log._Test_Fragmentation._Run,,false,297,305,_Run,,,26,void leveldb.log._Test_Fragmentation._Run ()
37105,METHOD,leveldb.log._Test_MarginalTrailer,TYPE_DECL,void void ();,1,30,db\log_test.cc,leveldb.log._Test_MarginalTrailer._Run,,false,307,307,_Run,,,1,void leveldb.log._Test_MarginalTrailer._Run ()
37109,METHOD,leveldb.log._Test_MarginalTrailer,TYPE_DECL,"TEST(LogTest, MarginalTrailer)",1,30,db\log_test.cc,leveldb.log._Test_MarginalTrailer._RunIt,,false,307,307,_RunIt,,,2,void leveldb.log._Test_MarginalTrailer._RunIt ()
37133,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, MarginalTrailer) {
  // Make a trailer that is exactly the same length as an empty record.
  const int n = kBlockSize - 2*kHeaderSize;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());
  Write("""");
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
}",1,30,db\log_test.cc,leveldb.log._Test_MarginalTrailer._Run,,false,307,318,_Run,,,30,void leveldb.log._Test_MarginalTrailer._Run ()
37241,METHOD,leveldb.log._Test_MarginalTrailer2,TYPE_DECL,void void ();,1,31,db\log_test.cc,leveldb.log._Test_MarginalTrailer2._Run,,false,320,320,_Run,,,1,void leveldb.log._Test_MarginalTrailer2._Run ()
37245,METHOD,leveldb.log._Test_MarginalTrailer2,TYPE_DECL,"TEST(LogTest, MarginalTrailer2)",1,31,db\log_test.cc,leveldb.log._Test_MarginalTrailer2._RunIt,,false,320,320,_RunIt,,,2,void leveldb.log._Test_MarginalTrailer2._RunIt ()
37269,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, MarginalTrailer2) {
  // Make a trailer that is exactly the same length as an empty record.
  const int n = kBlockSize - 2*kHeaderSize;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes());
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",1,31,db\log_test.cc,leveldb.log._Test_MarginalTrailer2._Run,,false,320,331,_Run,,,34,void leveldb.log._Test_MarginalTrailer2._Run ()
37392,METHOD,leveldb.log._Test_ShortTrailer,TYPE_DECL,void void ();,1,27,db\log_test.cc,leveldb.log._Test_ShortTrailer._Run,,false,333,333,_Run,,,1,void leveldb.log._Test_ShortTrailer._Run ()
37396,METHOD,leveldb.log._Test_ShortTrailer,TYPE_DECL,"TEST(LogTest, ShortTrailer)",1,27,db\log_test.cc,leveldb.log._Test_ShortTrailer._RunIt,,false,333,333,_RunIt,,,2,void leveldb.log._Test_ShortTrailer._RunIt ()
37420,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ShortTrailer) {
  const int n = kBlockSize - 2*kHeaderSize + 4;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());
  Write("""");
  Write(""bar"");
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ("""", Read());
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
}",1,27,db\log_test.cc,leveldb.log._Test_ShortTrailer._Run,,false,333,343,_Run,,,38,void leveldb.log._Test_ShortTrailer._Run ()
37532,METHOD,leveldb.log._Test_AlignedEof,TYPE_DECL,void void ();,1,25,db\log_test.cc,leveldb.log._Test_AlignedEof._Run,,false,345,345,_Run,,,1,void leveldb.log._Test_AlignedEof._Run ()
37536,METHOD,leveldb.log._Test_AlignedEof,TYPE_DECL,"TEST(LogTest, AlignedEof)",1,25,db\log_test.cc,leveldb.log._Test_AlignedEof._RunIt,,false,345,345,_RunIt,,,2,void leveldb.log._Test_AlignedEof._RunIt ()
37560,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, AlignedEof) {
  const int n = kBlockSize - 2*kHeaderSize + 4;
  Write(BigString(""foo"", n));
  ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes());
  ASSERT_EQ(BigString(""foo"", n), Read());
  ASSERT_EQ(""EOF"", Read());
}",1,25,db\log_test.cc,leveldb.log._Test_AlignedEof._Run,,false,345,351,_Run,,,42,void leveldb.log._Test_AlignedEof._Run ()
37634,METHOD,leveldb.log._Test_OpenForAppend,TYPE_DECL,void void ();,1,28,db\log_test.cc,leveldb.log._Test_OpenForAppend._Run,,false,353,353,_Run,,,1,void leveldb.log._Test_OpenForAppend._Run ()
37638,METHOD,leveldb.log._Test_OpenForAppend,TYPE_DECL,"TEST(LogTest, OpenForAppend)",1,28,db\log_test.cc,leveldb.log._Test_OpenForAppend._RunIt,,false,353,353,_RunIt,,,2,void leveldb.log._Test_OpenForAppend._RunIt ()
37662,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, OpenForAppend) {
  Write(""hello"");
  ReopenForAppend();
  Write(""world"");
  ASSERT_EQ(""hello"", Read());
  ASSERT_EQ(""world"", Read());
  ASSERT_EQ(""EOF"", Read());
}",1,28,db\log_test.cc,leveldb.log._Test_OpenForAppend._Run,,false,353,360,_Run,,,46,void leveldb.log._Test_OpenForAppend._Run ()
37723,METHOD,leveldb.log._Test_RandomRead,TYPE_DECL,void void ();,1,25,db\log_test.cc,leveldb.log._Test_RandomRead._Run,,false,362,362,_Run,,,1,void leveldb.log._Test_RandomRead._Run ()
37727,METHOD,leveldb.log._Test_RandomRead,TYPE_DECL,"TEST(LogTest, RandomRead)",1,25,db\log_test.cc,leveldb.log._Test_RandomRead._RunIt,,false,362,362,_RunIt,,,2,void leveldb.log._Test_RandomRead._RunIt ()
37751,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, RandomRead) {
  const int N = 500;
  Random write_rnd(301);
  for (int i = 0; i < N; i++) {
    Write(RandomSkewedString(i, &write_rnd));
  }
  Random read_rnd(301);
  for (int i = 0; i < N; i++) {
    ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read());
  }
  ASSERT_EQ(""EOF"", Read());
}",1,25,db\log_test.cc,leveldb.log._Test_RandomRead._Run,,false,362,373,_Run,,,50,void leveldb.log._Test_RandomRead._Run ()
37831,METHOD,leveldb.log._Test_ReadError,TYPE_DECL,void void ();,1,24,db\log_test.cc,leveldb.log._Test_ReadError._Run,,false,377,377,_Run,,,1,void leveldb.log._Test_ReadError._Run ()
37835,METHOD,leveldb.log._Test_ReadError,TYPE_DECL,"TEST(LogTest, ReadError)",1,24,db\log_test.cc,leveldb.log._Test_ReadError._RunIt,,false,377,377,_RunIt,,,2,void leveldb.log._Test_ReadError._RunIt ()
37859,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadError) {
  Write(""foo"");
  ForceError();
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(kBlockSize, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""read error""));
}",1,24,db\log_test.cc,leveldb.log._Test_ReadError._Run,,false,377,383,_Run,,,54,void leveldb.log._Test_ReadError._Run ()
37918,METHOD,leveldb.log._Test_BadRecordType,TYPE_DECL,void void ();,1,28,db\log_test.cc,leveldb.log._Test_BadRecordType._Run,,false,385,385,_Run,,,1,void leveldb.log._Test_BadRecordType._Run ()
37922,METHOD,leveldb.log._Test_BadRecordType,TYPE_DECL,"TEST(LogTest, BadRecordType)",1,28,db\log_test.cc,leveldb.log._Test_BadRecordType._RunIt,,false,385,385,_RunIt,,,2,void leveldb.log._Test_BadRecordType._RunIt ()
37946,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, BadRecordType) {
  Write(""foo"");
  // Type is stored in header[6]
  IncrementByte(6, 100);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""unknown record type""));
}",1,28,db\log_test.cc,leveldb.log._Test_BadRecordType._Run,,false,385,393,_Run,,,58,void leveldb.log._Test_BadRecordType._Run ()
38010,METHOD,leveldb.log._Test_TruncatedTrailingRecordIsIgnored,TYPE_DECL,void void ();,1,47,db\log_test.cc,leveldb.log._Test_TruncatedTrailingRecordIsIgnored._Run,,false,395,395,_Run,,,1,void leveldb.log._Test_TruncatedTrailingRecordIsIgnored._Run ()
38014,METHOD,leveldb.log._Test_TruncatedTrailingRecordIsIgnored,TYPE_DECL,"TEST(LogTest, TruncatedTrailingRecordIsIgnored)",1,47,db\log_test.cc,leveldb.log._Test_TruncatedTrailingRecordIsIgnored._RunIt,,false,395,395,_RunIt,,,2,void leveldb.log._Test_TruncatedTrailingRecordIsIgnored._RunIt ()
38038,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, TruncatedTrailingRecordIsIgnored) {
  Write(""foo"");
  ShrinkSize(4);   // Drop all payload as well as a header byte
  ASSERT_EQ(""EOF"", Read());
  // Truncated last record is ignored, not treated as an error.
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",1,47,db\log_test.cc,leveldb.log._Test_TruncatedTrailingRecordIsIgnored._Run,,false,395,402,_Run,,,62,void leveldb.log._Test_TruncatedTrailingRecordIsIgnored._Run ()
38098,METHOD,leveldb.log._Test_BadLength,TYPE_DECL,void void ();,1,24,db\log_test.cc,leveldb.log._Test_BadLength._Run,,false,404,404,_Run,,,1,void leveldb.log._Test_BadLength._Run ()
38102,METHOD,leveldb.log._Test_BadLength,TYPE_DECL,"TEST(LogTest, BadLength)",1,24,db\log_test.cc,leveldb.log._Test_BadLength._RunIt,,false,404,404,_RunIt,,,2,void leveldb.log._Test_BadLength._RunIt ()
38126,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, BadLength) {
  const int kPayloadSize = kBlockSize - kHeaderSize;
  Write(BigString(""bar"", kPayloadSize));
  Write(""foo"");
  // Least significant size byte is stored in header[4].
  IncrementByte(4, 1);
  ASSERT_EQ(""foo"", Read());
  ASSERT_EQ(kBlockSize, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""bad record length""));
}",1,24,db\log_test.cc,leveldb.log._Test_BadLength._Run,,false,404,413,_Run,,,66,void leveldb.log._Test_BadLength._Run ()
38197,METHOD,leveldb.log._Test_BadLengthAtEndIsIgnored,TYPE_DECL,void void ();,1,38,db\log_test.cc,leveldb.log._Test_BadLengthAtEndIsIgnored._Run,,false,415,415,_Run,,,1,void leveldb.log._Test_BadLengthAtEndIsIgnored._Run ()
38201,METHOD,leveldb.log._Test_BadLengthAtEndIsIgnored,TYPE_DECL,"TEST(LogTest, BadLengthAtEndIsIgnored)",1,38,db\log_test.cc,leveldb.log._Test_BadLengthAtEndIsIgnored._RunIt,,false,415,415,_RunIt,,,2,void leveldb.log._Test_BadLengthAtEndIsIgnored._RunIt ()
38225,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, BadLengthAtEndIsIgnored) {
  Write(""foo"");
  ShrinkSize(1);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ("""", ReportMessage());
}",1,38,db\log_test.cc,leveldb.log._Test_BadLengthAtEndIsIgnored._Run,,false,415,421,_Run,,,70,void leveldb.log._Test_BadLengthAtEndIsIgnored._Run ()
38285,METHOD,leveldb.log._Test_ChecksumMismatch,TYPE_DECL,void void ();,1,31,db\log_test.cc,leveldb.log._Test_ChecksumMismatch._Run,,false,423,423,_Run,,,1,void leveldb.log._Test_ChecksumMismatch._Run ()
38289,METHOD,leveldb.log._Test_ChecksumMismatch,TYPE_DECL,"TEST(LogTest, ChecksumMismatch)",1,31,db\log_test.cc,leveldb.log._Test_ChecksumMismatch._RunIt,,false,423,423,_RunIt,,,2,void leveldb.log._Test_ChecksumMismatch._RunIt ()
38313,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ChecksumMismatch) {
  Write(""foo"");
  IncrementByte(0, 10);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(10, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""checksum mismatch""));
}",1,31,db\log_test.cc,leveldb.log._Test_ChecksumMismatch._Run,,false,423,429,_Run,,,74,void leveldb.log._Test_ChecksumMismatch._Run ()
38374,METHOD,leveldb.log._Test_UnexpectedMiddleType,TYPE_DECL,void void ();,1,35,db\log_test.cc,leveldb.log._Test_UnexpectedMiddleType._Run,,false,431,431,_Run,,,1,void leveldb.log._Test_UnexpectedMiddleType._Run ()
38378,METHOD,leveldb.log._Test_UnexpectedMiddleType,TYPE_DECL,"TEST(LogTest, UnexpectedMiddleType)",1,35,db\log_test.cc,leveldb.log._Test_UnexpectedMiddleType._RunIt,,false,431,431,_RunIt,,,2,void leveldb.log._Test_UnexpectedMiddleType._RunIt ()
38402,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, UnexpectedMiddleType) {
  Write(""foo"");
  SetByte(6, kMiddleType);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""missing start""));
}",1,35,db\log_test.cc,leveldb.log._Test_UnexpectedMiddleType._Run,,false,431,438,_Run,,,78,void leveldb.log._Test_UnexpectedMiddleType._Run ()
38466,METHOD,leveldb.log._Test_UnexpectedLastType,TYPE_DECL,void void ();,1,33,db\log_test.cc,leveldb.log._Test_UnexpectedLastType._Run,,false,440,440,_Run,,,1,void leveldb.log._Test_UnexpectedLastType._Run ()
38470,METHOD,leveldb.log._Test_UnexpectedLastType,TYPE_DECL,"TEST(LogTest, UnexpectedLastType)",1,33,db\log_test.cc,leveldb.log._Test_UnexpectedLastType._RunIt,,false,440,440,_RunIt,,,2,void leveldb.log._Test_UnexpectedLastType._RunIt ()
38494,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, UnexpectedLastType) {
  Write(""foo"");
  SetByte(6, kLastType);
  FixChecksum(0, 3);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""missing start""));
}",1,33,db\log_test.cc,leveldb.log._Test_UnexpectedLastType._Run,,false,440,447,_Run,,,82,void leveldb.log._Test_UnexpectedLastType._Run ()
38558,METHOD,leveldb.log._Test_UnexpectedFullType,TYPE_DECL,void void ();,1,33,db\log_test.cc,leveldb.log._Test_UnexpectedFullType._Run,,false,449,449,_Run,,,1,void leveldb.log._Test_UnexpectedFullType._Run ()
38562,METHOD,leveldb.log._Test_UnexpectedFullType,TYPE_DECL,"TEST(LogTest, UnexpectedFullType)",1,33,db\log_test.cc,leveldb.log._Test_UnexpectedFullType._RunIt,,false,449,449,_RunIt,,,2,void leveldb.log._Test_UnexpectedFullType._RunIt ()
38586,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, UnexpectedFullType) {
  Write(""foo"");
  Write(""bar"");
  SetByte(6, kFirstType);
  FixChecksum(0, 3);
  ASSERT_EQ(""bar"", Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""partial record without end""));
}",1,33,db\log_test.cc,leveldb.log._Test_UnexpectedFullType._Run,,false,449,458,_Run,,,86,void leveldb.log._Test_UnexpectedFullType._Run ()
38669,METHOD,leveldb.log._Test_UnexpectedFirstType,TYPE_DECL,void void ();,1,34,db\log_test.cc,leveldb.log._Test_UnexpectedFirstType._Run,,false,460,460,_Run,,,1,void leveldb.log._Test_UnexpectedFirstType._Run ()
38673,METHOD,leveldb.log._Test_UnexpectedFirstType,TYPE_DECL,"TEST(LogTest, UnexpectedFirstType)",1,34,db\log_test.cc,leveldb.log._Test_UnexpectedFirstType._RunIt,,false,460,460,_RunIt,,,2,void leveldb.log._Test_UnexpectedFirstType._RunIt ()
38697,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, UnexpectedFirstType) {
  Write(""foo"");
  Write(BigString(""bar"", 100000));
  SetByte(6, kFirstType);
  FixChecksum(0, 3);
  ASSERT_EQ(BigString(""bar"", 100000), Read());
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ(3, DroppedBytes());
  ASSERT_EQ(""OK"", MatchError(""partial record without end""));
}",1,34,db\log_test.cc,leveldb.log._Test_UnexpectedFirstType._Run,,false,460,469,_Run,,,90,void leveldb.log._Test_UnexpectedFirstType._Run ()
38783,METHOD,leveldb.log._Test_MissingLastIsIgnored,TYPE_DECL,void void ();,1,35,db\log_test.cc,leveldb.log._Test_MissingLastIsIgnored._Run,,false,471,471,_Run,,,1,void leveldb.log._Test_MissingLastIsIgnored._Run ()
38787,METHOD,leveldb.log._Test_MissingLastIsIgnored,TYPE_DECL,"TEST(LogTest, MissingLastIsIgnored)",1,35,db\log_test.cc,leveldb.log._Test_MissingLastIsIgnored._RunIt,,false,471,471,_RunIt,,,2,void leveldb.log._Test_MissingLastIsIgnored._RunIt ()
38811,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, MissingLastIsIgnored) {
  Write(BigString(""bar"", kBlockSize));
  // Remove the LAST block, including header.
  ShrinkSize(14);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
}",1,35,db\log_test.cc,leveldb.log._Test_MissingLastIsIgnored._Run,,false,471,478,_Run,,,94,void leveldb.log._Test_MissingLastIsIgnored._Run ()
38873,METHOD,leveldb.log._Test_PartialLastIsIgnored,TYPE_DECL,void void ();,1,35,db\log_test.cc,leveldb.log._Test_PartialLastIsIgnored._Run,,false,480,480,_Run,,,1,void leveldb.log._Test_PartialLastIsIgnored._Run ()
38877,METHOD,leveldb.log._Test_PartialLastIsIgnored,TYPE_DECL,"TEST(LogTest, PartialLastIsIgnored)",1,35,db\log_test.cc,leveldb.log._Test_PartialLastIsIgnored._RunIt,,false,480,480,_RunIt,,,2,void leveldb.log._Test_PartialLastIsIgnored._RunIt ()
38901,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, PartialLastIsIgnored) {
  Write(BigString(""bar"", kBlockSize));
  // Cause a bad record length in the LAST block.
  ShrinkSize(1);
  ASSERT_EQ(""EOF"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
}",1,35,db\log_test.cc,leveldb.log._Test_PartialLastIsIgnored._Run,,false,480,487,_Run,,,98,void leveldb.log._Test_PartialLastIsIgnored._Run ()
38963,METHOD,leveldb.log._Test_SkipIntoMultiRecord,TYPE_DECL,void void ();,1,34,db\log_test.cc,leveldb.log._Test_SkipIntoMultiRecord._Run,,false,489,489,_Run,,,1,void leveldb.log._Test_SkipIntoMultiRecord._Run ()
38967,METHOD,leveldb.log._Test_SkipIntoMultiRecord,TYPE_DECL,"TEST(LogTest, SkipIntoMultiRecord)",1,34,db\log_test.cc,leveldb.log._Test_SkipIntoMultiRecord._RunIt,,false,489,489,_RunIt,,,2,void leveldb.log._Test_SkipIntoMultiRecord._RunIt ()
38991,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, SkipIntoMultiRecord) {
  // Consider a fragmented record:
  //    first(R1), middle(R1), last(R1), first(R2)
  // If initial_offset points to a record after first(R1) but before first(R2)
  // incomplete fragment errors are not actual errors, and must be suppressed
  // until a new first or full record is encountered.
  Write(BigString(""foo"", 3*kBlockSize));
  Write(""correct"");
  StartReadingAt(kBlockSize);

  ASSERT_EQ(""correct"", Read());
  ASSERT_EQ("""", ReportMessage());
  ASSERT_EQ(0, DroppedBytes());
  ASSERT_EQ(""EOF"", Read());
}",1,34,db\log_test.cc,leveldb.log._Test_SkipIntoMultiRecord._Run,,false,489,503,_Run,,,102,void leveldb.log._Test_SkipIntoMultiRecord._Run ()
39074,METHOD,leveldb.log._Test_ErrorJoinsRecords,TYPE_DECL,void void ();,1,32,db\log_test.cc,leveldb.log._Test_ErrorJoinsRecords._Run,,false,505,505,_Run,,,1,void leveldb.log._Test_ErrorJoinsRecords._Run ()
39078,METHOD,leveldb.log._Test_ErrorJoinsRecords,TYPE_DECL,"TEST(LogTest, ErrorJoinsRecords)",1,32,db\log_test.cc,leveldb.log._Test_ErrorJoinsRecords._RunIt,,false,505,505,_RunIt,,,2,void leveldb.log._Test_ErrorJoinsRecords._RunIt ()
39102,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ErrorJoinsRecords) {
  // Consider two fragmented records:
  //    first(R1) last(R1) first(R2) last(R2)
  // where the middle two fragments disappear.  We do not want
  // first(R1),last(R2) to get joined and returned as a valid record.

  // Write records that span two blocks
  Write(BigString(""foo"", kBlockSize));
  Write(BigString(""bar"", kBlockSize));
  Write(""correct"");

  // Wipe the middle block
  for (int offset = kBlockSize; offset < 2*kBlockSize; offset++) {
    SetByte(offset, 'x');
  }

  ASSERT_EQ(""correct"", Read());
  ASSERT_EQ(""EOF"", Read());
  const size_t dropped = DroppedBytes();
  ASSERT_LE(dropped, 2*kBlockSize + 100);
  ASSERT_GE(dropped, 2*kBlockSize);
}",1,32,db\log_test.cc,leveldb.log._Test_ErrorJoinsRecords._Run,,false,505,526,_Run,,,106,void leveldb.log._Test_ErrorJoinsRecords._Run ()
39210,METHOD,leveldb.log._Test_ReadStart,TYPE_DECL,void void ();,1,24,db\log_test.cc,leveldb.log._Test_ReadStart._Run,,false,528,528,_Run,,,1,void leveldb.log._Test_ReadStart._Run ()
39214,METHOD,leveldb.log._Test_ReadStart,TYPE_DECL,"TEST(LogTest, ReadStart)",1,24,db\log_test.cc,leveldb.log._Test_ReadStart._RunIt,,false,528,528,_RunIt,,,2,void leveldb.log._Test_ReadStart._RunIt ()
39238,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadStart) {
  CheckInitialOffsetRecord(0, 0);
}",1,24,db\log_test.cc,leveldb.log._Test_ReadStart._Run,,false,528,530,_Run,,,110,void leveldb.log._Test_ReadStart._Run ()
39246,METHOD,leveldb.log._Test_ReadSecondOneOff,TYPE_DECL,void void ();,1,31,db\log_test.cc,leveldb.log._Test_ReadSecondOneOff._Run,,false,532,532,_Run,,,1,void leveldb.log._Test_ReadSecondOneOff._Run ()
39250,METHOD,leveldb.log._Test_ReadSecondOneOff,TYPE_DECL,"TEST(LogTest, ReadSecondOneOff)",1,31,db\log_test.cc,leveldb.log._Test_ReadSecondOneOff._RunIt,,false,532,532,_RunIt,,,2,void leveldb.log._Test_ReadSecondOneOff._RunIt ()
39274,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadSecondOneOff) {
  CheckInitialOffsetRecord(1, 1);
}",1,31,db\log_test.cc,leveldb.log._Test_ReadSecondOneOff._Run,,false,532,534,_Run,,,114,void leveldb.log._Test_ReadSecondOneOff._Run ()
39282,METHOD,leveldb.log._Test_ReadSecondTenThousand,TYPE_DECL,void void ();,1,36,db\log_test.cc,leveldb.log._Test_ReadSecondTenThousand._Run,,false,536,536,_Run,,,1,void leveldb.log._Test_ReadSecondTenThousand._Run ()
39286,METHOD,leveldb.log._Test_ReadSecondTenThousand,TYPE_DECL,"TEST(LogTest, ReadSecondTenThousand)",1,36,db\log_test.cc,leveldb.log._Test_ReadSecondTenThousand._RunIt,,false,536,536,_RunIt,,,2,void leveldb.log._Test_ReadSecondTenThousand._RunIt ()
39310,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadSecondTenThousand) {
  CheckInitialOffsetRecord(10000, 1);
}",1,36,db\log_test.cc,leveldb.log._Test_ReadSecondTenThousand._Run,,false,536,538,_Run,,,118,void leveldb.log._Test_ReadSecondTenThousand._Run ()
39318,METHOD,leveldb.log._Test_ReadSecondStart,TYPE_DECL,void void ();,1,30,db\log_test.cc,leveldb.log._Test_ReadSecondStart._Run,,false,540,540,_Run,,,1,void leveldb.log._Test_ReadSecondStart._Run ()
39322,METHOD,leveldb.log._Test_ReadSecondStart,TYPE_DECL,"TEST(LogTest, ReadSecondStart)",1,30,db\log_test.cc,leveldb.log._Test_ReadSecondStart._RunIt,,false,540,540,_RunIt,,,2,void leveldb.log._Test_ReadSecondStart._RunIt ()
39346,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadSecondStart) {
  CheckInitialOffsetRecord(10007, 1);
}",1,30,db\log_test.cc,leveldb.log._Test_ReadSecondStart._Run,,false,540,542,_Run,,,122,void leveldb.log._Test_ReadSecondStart._Run ()
39354,METHOD,leveldb.log._Test_ReadThirdOneOff,TYPE_DECL,void void ();,1,30,db\log_test.cc,leveldb.log._Test_ReadThirdOneOff._Run,,false,544,544,_Run,,,1,void leveldb.log._Test_ReadThirdOneOff._Run ()
39358,METHOD,leveldb.log._Test_ReadThirdOneOff,TYPE_DECL,"TEST(LogTest, ReadThirdOneOff)",1,30,db\log_test.cc,leveldb.log._Test_ReadThirdOneOff._RunIt,,false,544,544,_RunIt,,,2,void leveldb.log._Test_ReadThirdOneOff._RunIt ()
39382,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadThirdOneOff) {
  CheckInitialOffsetRecord(10008, 2);
}",1,30,db\log_test.cc,leveldb.log._Test_ReadThirdOneOff._Run,,false,544,546,_Run,,,126,void leveldb.log._Test_ReadThirdOneOff._Run ()
39390,METHOD,leveldb.log._Test_ReadThirdStart,TYPE_DECL,void void ();,1,29,db\log_test.cc,leveldb.log._Test_ReadThirdStart._Run,,false,548,548,_Run,,,1,void leveldb.log._Test_ReadThirdStart._Run ()
39394,METHOD,leveldb.log._Test_ReadThirdStart,TYPE_DECL,"TEST(LogTest, ReadThirdStart)",1,29,db\log_test.cc,leveldb.log._Test_ReadThirdStart._RunIt,,false,548,548,_RunIt,,,2,void leveldb.log._Test_ReadThirdStart._RunIt ()
39418,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadThirdStart) {
  CheckInitialOffsetRecord(20014, 2);
}",1,29,db\log_test.cc,leveldb.log._Test_ReadThirdStart._Run,,false,548,550,_Run,,,130,void leveldb.log._Test_ReadThirdStart._Run ()
39426,METHOD,leveldb.log._Test_ReadFourthOneOff,TYPE_DECL,void void ();,1,31,db\log_test.cc,leveldb.log._Test_ReadFourthOneOff._Run,,false,552,552,_Run,,,1,void leveldb.log._Test_ReadFourthOneOff._Run ()
39430,METHOD,leveldb.log._Test_ReadFourthOneOff,TYPE_DECL,"TEST(LogTest, ReadFourthOneOff)",1,31,db\log_test.cc,leveldb.log._Test_ReadFourthOneOff._RunIt,,false,552,552,_RunIt,,,2,void leveldb.log._Test_ReadFourthOneOff._RunIt ()
39454,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadFourthOneOff) {
  CheckInitialOffsetRecord(20015, 3);
}",1,31,db\log_test.cc,leveldb.log._Test_ReadFourthOneOff._Run,,false,552,554,_Run,,,134,void leveldb.log._Test_ReadFourthOneOff._Run ()
39462,METHOD,leveldb.log._Test_ReadFourthFirstBlockTrailer,TYPE_DECL,void void ();,1,42,db\log_test.cc,leveldb.log._Test_ReadFourthFirstBlockTrailer._Run,,false,556,556,_Run,,,1,void leveldb.log._Test_ReadFourthFirstBlockTrailer._Run ()
39466,METHOD,leveldb.log._Test_ReadFourthFirstBlockTrailer,TYPE_DECL,"TEST(LogTest, ReadFourthFirstBlockTrailer)",1,42,db\log_test.cc,leveldb.log._Test_ReadFourthFirstBlockTrailer._RunIt,,false,556,556,_RunIt,,,2,void leveldb.log._Test_ReadFourthFirstBlockTrailer._RunIt ()
39490,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadFourthFirstBlockTrailer) {
  CheckInitialOffsetRecord(log::kBlockSize - 4, 3);
}",1,42,db\log_test.cc,leveldb.log._Test_ReadFourthFirstBlockTrailer._Run,,false,556,558,_Run,,,138,void leveldb.log._Test_ReadFourthFirstBlockTrailer._Run ()
39502,METHOD,leveldb.log._Test_ReadFourthMiddleBlock,TYPE_DECL,void void ();,1,36,db\log_test.cc,leveldb.log._Test_ReadFourthMiddleBlock._Run,,false,560,560,_Run,,,1,void leveldb.log._Test_ReadFourthMiddleBlock._Run ()
39506,METHOD,leveldb.log._Test_ReadFourthMiddleBlock,TYPE_DECL,"TEST(LogTest, ReadFourthMiddleBlock)",1,36,db\log_test.cc,leveldb.log._Test_ReadFourthMiddleBlock._RunIt,,false,560,560,_RunIt,,,2,void leveldb.log._Test_ReadFourthMiddleBlock._RunIt ()
39530,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadFourthMiddleBlock) {
  CheckInitialOffsetRecord(log::kBlockSize + 1, 3);
}",1,36,db\log_test.cc,leveldb.log._Test_ReadFourthMiddleBlock._Run,,false,560,562,_Run,,,142,void leveldb.log._Test_ReadFourthMiddleBlock._Run ()
39542,METHOD,leveldb.log._Test_ReadFourthLastBlock,TYPE_DECL,void void ();,1,34,db\log_test.cc,leveldb.log._Test_ReadFourthLastBlock._Run,,false,564,564,_Run,,,1,void leveldb.log._Test_ReadFourthLastBlock._Run ()
39546,METHOD,leveldb.log._Test_ReadFourthLastBlock,TYPE_DECL,"TEST(LogTest, ReadFourthLastBlock)",1,34,db\log_test.cc,leveldb.log._Test_ReadFourthLastBlock._RunIt,,false,564,564,_RunIt,,,2,void leveldb.log._Test_ReadFourthLastBlock._RunIt ()
39570,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadFourthLastBlock) {
  CheckInitialOffsetRecord(2 * log::kBlockSize + 1, 3);
}",1,34,db\log_test.cc,leveldb.log._Test_ReadFourthLastBlock._Run,,false,564,566,_Run,,,146,void leveldb.log._Test_ReadFourthLastBlock._Run ()
39584,METHOD,leveldb.log._Test_ReadFourthStart,TYPE_DECL,void void ();,1,30,db\log_test.cc,leveldb.log._Test_ReadFourthStart._Run,,false,568,568,_Run,,,1,void leveldb.log._Test_ReadFourthStart._Run ()
39588,METHOD,leveldb.log._Test_ReadFourthStart,TYPE_DECL,"TEST(LogTest, ReadFourthStart)",1,30,db\log_test.cc,leveldb.log._Test_ReadFourthStart._RunIt,,false,568,568,_RunIt,,,2,void leveldb.log._Test_ReadFourthStart._RunIt ()
39612,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadFourthStart) {
  CheckInitialOffsetRecord(
      2 * (kHeaderSize + 1000) + (2 * log::kBlockSize - 1000) + 3 * kHeaderSize,
      3);
}",1,30,db\log_test.cc,leveldb.log._Test_ReadFourthStart._Run,,false,568,572,_Run,,,150,void leveldb.log._Test_ReadFourthStart._Run ()
39636,METHOD,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding,TYPE_DECL,void void ();,1,48,db\log_test.cc,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._Run,,false,574,574,_Run,,,1,void leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._Run ()
39640,METHOD,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding,TYPE_DECL,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",1,48,db\log_test.cc,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._RunIt,,false,574,574,_RunIt,,,2,void leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._RunIt ()
39664,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding) {
  CheckInitialOffsetRecord(3 * log::kBlockSize - 3, 5);
}",1,48,db\log_test.cc,leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._Run,,false,574,576,_Run,,,154,void leveldb.log._Test_ReadInitialOffsetIntoBlockPadding._Run ()
39678,METHOD,leveldb.log._Test_ReadEnd,TYPE_DECL,void void ();,1,22,db\log_test.cc,leveldb.log._Test_ReadEnd._Run,,false,578,578,_Run,,,1,void leveldb.log._Test_ReadEnd._Run ()
39682,METHOD,leveldb.log._Test_ReadEnd,TYPE_DECL,"TEST(LogTest, ReadEnd)",1,22,db\log_test.cc,leveldb.log._Test_ReadEnd._RunIt,,false,578,578,_RunIt,,,2,void leveldb.log._Test_ReadEnd._RunIt ()
39706,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadEnd) {
  CheckOffsetPastEndReturnsNoRecords(0);
}",1,22,db\log_test.cc,leveldb.log._Test_ReadEnd._Run,,false,578,580,_Run,,,158,void leveldb.log._Test_ReadEnd._Run ()
39713,METHOD,leveldb.log._Test_ReadPastEnd,TYPE_DECL,void void ();,1,26,db\log_test.cc,leveldb.log._Test_ReadPastEnd._Run,,false,582,582,_Run,,,1,void leveldb.log._Test_ReadPastEnd._Run ()
39717,METHOD,leveldb.log._Test_ReadPastEnd,TYPE_DECL,"TEST(LogTest, ReadPastEnd)",1,26,db\log_test.cc,leveldb.log._Test_ReadPastEnd._RunIt,,false,582,582,_RunIt,,,2,void leveldb.log._Test_ReadPastEnd._RunIt ()
39741,METHOD,db\log_test.cc:<global>,TYPE_DECL,"TEST(LogTest, ReadPastEnd) {
  CheckOffsetPastEndReturnsNoRecords(5);
}",1,26,db\log_test.cc,leveldb.log._Test_ReadPastEnd._Run,,false,582,584,_Run,,,162,void leveldb.log._Test_ReadPastEnd._Run ()
39747,METHOD,db\log_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\log_test.cc,main,,false,589,591,main,,,2,"int main (int,char**)"
39773,METHOD,db\log_writer.cc:<global>,TYPE_DECL,<global>,1,1,db\log_writer.cc,db\log_writer.cc:<global>,,false,1,112,<global>,,,1,
39777,METHOD,db\log_writer.cc:<global>,TYPE_DECL,"static void InitTypeCrc(uint32_t* type_crc) {
  for (int i = 0; i <= kMaxRecordType; i++) {
    char t = static_cast<char>(i);
    type_crc[i] = crc32c::Value(&t, 1);
  }
}",1,1,db\log_writer.cc,leveldb.log.InitTypeCrc,,false,15,20,InitTypeCrc,,,1,void leveldb.log.InitTypeCrc (uint32_t*)
39811,METHOD,db\log_writer.cc:<global>,TYPE_DECL,"Writer::Writer(WritableFile* dest)
    : dest_(dest),
      block_offset_(0) {
  InitTypeCrc(type_crc_);
}",1,1,db\log_writer.cc,leveldb.log.Writer.Writer,,false,22,26,Writer,,,2,ANY leveldb.log.Writer.Writer (WritableFile*)
39818,METHOD,db\log_writer.cc:<global>,TYPE_DECL,"Writer::Writer(WritableFile* dest, uint64_t dest_length)
    : dest_(dest), block_offset_(dest_length % kBlockSize) {
  InitTypeCrc(type_crc_);
}",1,1,db\log_writer.cc,leveldb.log.Writer.Writer,,false,28,31,Writer,,,3,"ANY leveldb.log.Writer.Writer (WritableFile*,uint64_t)"
39826,METHOD,db\log_writer.cc:<global>,TYPE_DECL,"Writer::~Writer() {
}",1,1,db\log_writer.cc,leveldb.log.Writer.~Writer,,false,33,34,~Writer,,,4,ANY leveldb.log.Writer.~Writer ()
39830,METHOD,db\log_writer.cc:<global>,TYPE_DECL,"Status Writer::AddRecord(const Slice& slice) {
  const char* ptr = slice.data();
  size_t left = slice.size();

  // Fragment the record if necessary and emit it.  Note that if slice
  // is empty, we still want to iterate once to emit a single
  // zero-length record
  Status s;
  bool begin = true;
  do {
    const int leftover = kBlockSize - block_offset_;
    assert(leftover >= 0);
    if (leftover < kHeaderSize) {
      // Switch to a new block
      if (leftover > 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_->Append(Slice(""\x00\x00\x00\x00\x00\x00"", leftover));
      }
      block_offset_ = 0;
    }

    // Invariant: we never leave < kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize >= 0);

    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left < avail) ? left : avail;

    RecordType type;
    const bool end = ...",1,1,db\log_writer.cc,leveldb.log.Writer.AddRecord,,false,36,82,AddRecord,,,5,Status leveldb.log.Writer.AddRecord (Slice)
39976,METHOD,db\log_writer.cc:<global>,TYPE_DECL,"Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {
  assert(n <= 0xffff);  // Must fit in two bytes
  assert(block_offset_ + kHeaderSize + n <= kBlockSize);

  // Format the header
  char buf[kHeaderSize];
  buf[4] = static_cast<char>(n & 0xff);
  buf[5] = static_cast<char>(n >> 8);
  buf[6] = static_cast<char>(t);

  // Compute the crc of the record type and the payload.
  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n);
  crc = crc32c::Mask(crc);                 // Adjust for storage
  EncodeFixed32(buf, crc);

  // Write the header and the payload
  Status s = dest_->Append(Slice(buf, kHeaderSize));
  if (s.ok()) {
    s = dest_->Append(Slice(ptr, n));
    if (s.ok()) {
      s = dest_->Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  return s;
}",1,1,db\log_writer.cc,leveldb.log.Writer.EmitPhysicalRecord,,false,84,109,EmitPhysicalRecord,,,6,"Status leveldb.log.Writer.EmitPhysicalRecord (RecordType,char*,size_t)"
40098,METHOD,db\log_writer.hpp:<global>,TYPE_DECL,<global>,1,22,db\log_writer.hpp,db\log_writer.hpp:<global>,,false,1,54,<global>,,,1,
40104,METHOD,leveldb.log.Writer,TYPE_DECL,explicit Writer(WritableFile* dest);,12,37,db\log_writer.hpp,leveldb.log.Writer.Writer,,false,24,24,Writer,,,1,explicit leveldb.log.Writer.Writer (WritableFile*)
40109,METHOD,leveldb.log.Writer,TYPE_DECL,"Writer(WritableFile* dest, uint64_t dest_length);",3,50,db\log_writer.hpp,leveldb.log.Writer.Writer,,false,29,29,Writer,,,2,"ANY leveldb.log.Writer.Writer (WritableFile*,uint64_t)"
40115,METHOD,leveldb.log.Writer,TYPE_DECL,~Writer();,3,11,db\log_writer.hpp,leveldb.log.Writer.~Writer,,false,31,31,~Writer,,,3,ANY leveldb.log.Writer.~Writer ()
40119,METHOD,leveldb.log.Writer,TYPE_DECL,Status AddRecord(const Slice& slice);,10,38,db\log_writer.hpp,leveldb.log.Writer.AddRecord,,false,33,33,AddRecord,,,4,Status leveldb.log.Writer.AddRecord (Slice)
40127,METHOD,leveldb.log.Writer,TYPE_DECL,"Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);",10,76,db\log_writer.hpp,leveldb.log.Writer.EmitPhysicalRecord,,false,44,44,EmitPhysicalRecord,,,8,"Status leveldb.log.Writer.EmitPhysicalRecord (RecordType,char*,size_t)"
40134,METHOD,leveldb.log.Writer,TYPE_DECL,Writer(const Writer&);,3,23,db\log_writer.hpp,leveldb.log.Writer.Writer,,false,47,47,Writer,,,9,ANY leveldb.log.Writer.Writer (Writer)
40139,METHOD,leveldb.log.Writer,TYPE_DECL,void operator=(const Writer&);,8,31,db\log_writer.hpp,leveldb.log.Writer.operator =,,false,48,48,operator =,,,10,void leveldb.log.Writer.operator = (Writer)
40144,METHOD,<empty>,<empty>,<empty>,1,,db\log_writer.hpp,leveldb.log.Writer:<clinit>,,false,19,,<clinit>,,,11,
40167,METHOD,db\memtable.cc:<global>,TYPE_DECL,<global>,1,1,db\memtable.cc,db\memtable.cc:<global>,,false,1,145,<global>,,,1,
40170,METHOD,db\memtable.cc:<global>,TYPE_DECL,"static Slice GetLengthPrefixedSlice(const char* data) {
  uint32_t len;
  const char* p = data;
  p = GetVarint32Ptr(p, p + 5, &len);  // +5: we assume ""p"" is not corrupted
  return Slice(p, len);
}",1,1,db\memtable.cc,leveldb.GetLengthPrefixedSlice,,false,14,19,GetLengthPrefixedSlice,,,1,Slice leveldb.GetLengthPrefixedSlice (char*)
40193,METHOD,db\memtable.cc:<global>,TYPE_DECL,"MemTable::MemTable(const InternalKeyComparator& cmp)
    : comparator_(cmp),
      refs_(0),
      table_(comparator_, &arena_) {
}",1,1,db\memtable.cc,leveldb.MemTable.MemTable,,false,21,25,MemTable,,,2,ANY leveldb.MemTable.MemTable (InternalKeyComparator)
40198,METHOD,db\memtable.cc:<global>,TYPE_DECL,"MemTable::~MemTable() {
  assert(refs_ == 0);
}",1,1,db\memtable.cc,leveldb.MemTable.~MemTable,,false,27,29,~MemTable,,,3,ANY leveldb.MemTable.~MemTable ()
40206,METHOD,db\memtable.cc:<global>,TYPE_DECL,size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); },1,74,db\memtable.cc,leveldb.MemTable.ApproximateMemoryUsage,,false,31,31,ApproximateMemoryUsage,,,4,size_t leveldb.MemTable.ApproximateMemoryUsage ()
40215,METHOD,db\memtable.cc:<global>,TYPE_DECL,"int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)
    const {
  // Internal keys are encoded as length-prefixed strings.
  Slice a = GetLengthPrefixedSlice(aptr);
  Slice b = GetLengthPrefixedSlice(bptr);
  return comparator.Compare(a, b);
}",1,1,db\memtable.cc,leveldb.MemTable.KeyComparator.operator (),,false,33,39,operator (),,,5,"int leveldb.MemTable.KeyComparator.operator () (char*,char*)"
40238,METHOD,db\memtable.cc:<global>,TYPE_DECL,"static const char* EncodeKey(std::string* scratch, const Slice& target) {
  scratch->clear();
  PutVarint32(scratch, target.size());
  scratch->append(target.data(), target.size());
  return scratch->data();
}",1,1,db\memtable.cc,leveldb.EncodeKey,,false,44,49,EncodeKey,,,6,"const char* leveldb.EncodeKey (ANY*,Slice)"
40272,METHOD,leveldb.MemTableIterator,TYPE_DECL,explicit MemTableIterator(MemTable::Table* table) : iter_(table) { },3,70,db\memtable.cc,leveldb.MemTableIterator.MemTableIterator,,false,53,53,MemTableIterator,,,1,ANY leveldb.MemTableIterator.MemTableIterator (ANY*)
40277,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual bool Valid() const { return iter_.Valid(); },3,54,db\memtable.cc,leveldb.MemTableIterator.Valid,,false,55,55,Valid,,,2,bool leveldb.MemTableIterator.Valid ()
40286,METHOD,leveldb.MemTableIterator,TYPE_DECL,"virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }",3,72,db\memtable.cc,leveldb.MemTableIterator.Seek,,false,56,56,Seek,,,3,void leveldb.MemTableIterator.Seek (Slice)
40299,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual void SeekToFirst() { iter_.SeekToFirst(); },3,53,db\memtable.cc,leveldb.MemTableIterator.SeekToFirst,,false,57,57,SeekToFirst,,,4,void leveldb.MemTableIterator.SeekToFirst ()
40307,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual void SeekToLast() { iter_.SeekToLast(); },3,51,db\memtable.cc,leveldb.MemTableIterator.SeekToLast,,false,58,58,SeekToLast,,,5,void leveldb.MemTableIterator.SeekToLast ()
40315,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual void Next() { iter_.Next(); },3,39,db\memtable.cc,leveldb.MemTableIterator.Next,,false,59,59,Next,,,6,void leveldb.MemTableIterator.Next ()
40323,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual void Prev() { iter_.Prev(); },3,39,db\memtable.cc,leveldb.MemTableIterator.Prev,,false,60,60,Prev,,,7,void leveldb.MemTableIterator.Prev ()
40331,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); },3,75,db\memtable.cc,leveldb.MemTableIterator.key,,false,61,61,key,,,8,Slice leveldb.MemTableIterator.key ()
40341,METHOD,leveldb.MemTableIterator,TYPE_DECL,"virtual Slice value() const {
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }",3,3,db\memtable.cc,leveldb.MemTableIterator.value,,false,62,65,value,,,9,Slice leveldb.MemTableIterator.value ()
40364,METHOD,leveldb.MemTableIterator,TYPE_DECL,virtual Status status() const { return Status::OK(); },3,56,db\memtable.cc,leveldb.MemTableIterator.status,,false,67,67,status,,,10,Status leveldb.MemTableIterator.status ()
40375,METHOD,leveldb.MemTableIterator,TYPE_DECL,MemTableIterator(const MemTableIterator&);,3,43,db\memtable.cc,leveldb.MemTableIterator.MemTableIterator,,false,74,74,MemTableIterator,,,13,ANY leveldb.MemTableIterator.MemTableIterator (MemTableIterator)
40380,METHOD,leveldb.MemTableIterator,TYPE_DECL,void operator=(const MemTableIterator&);,8,41,db\memtable.cc,leveldb.MemTableIterator.operator =,,false,75,75,operator =,,,14,void leveldb.MemTableIterator.operator = (MemTableIterator)
40385,METHOD,db\memtable.cc:<global>,TYPE_DECL,"Iterator* MemTable::NewIterator() {
  return new MemTableIterator(&table_);
}",1,1,db\memtable.cc,leveldb.MemTable.NewIterator,,false,78,80,NewIterator,,,8,Iterator leveldb.MemTable.NewIterator ()
40394,METHOD,db\memtable.cc:<global>,TYPE_DECL,"void MemTable::Add(SequenceNumber s, ValueType type,
                   const Slice& key,
                   const Slice& value) {
  // Format of an entry is concatenation of:
  //  key_size     : varint32 of internal_key.size()
  //  key bytes    : char[internal_key.size()]
  //  value_size   : varint32 of value.size()
  //  value bytes  : char[value.size()]
  size_t key_size = key.size();
  size_t val_size = value.size();
  size_t internal_key_size = key_size + 8;
  const size_t encoded_len =
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  char* buf = arena_.Allocate(encoded_len);
  char* p = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s << 8) | type);
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf);
}",1,1,db\memtable.cc,leveldb.MemTable.Add,,false,82,106,Add,,,9,"void leveldb.MemTable.Add (SequenceNumber,ValueType,Slice,Slice)"
40493,METHOD,db\memtable.cc:<global>,TYPE_DECL,"bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {
  Slice memkey = key.memtable_key();
  Table::Iterator iter(&table_);
  iter.Seek(memkey.data());
  if (iter.Valid()) {
    // entry format is:
    //    klength  varint32
    //    userkey  char[klength]
    //    tag      uint64
    //    vlength  varint32
    //    value    char[vlength]
    // Check that it belongs to same user key.  We do not check the
    // sequence number since the Seek() call above should have skipped
    // all entries with overly large sequence numbers.
    const char* entry = iter.key();
    uint32_t key_length;
    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &key_length);
    if (comparator_.comparator.user_comparator()->Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast<ValueType>(tag & 0xff)) {
        case kTypeVa...",1,1,db\memtable.cc,leveldb.MemTable.Get,,false,108,143,Get,,,10,"bool leveldb.MemTable.Get (LookupKey,ANY*,Status*)"
40632,METHOD,db\memtable.hpp:<global>,TYPE_DECL,<global>,1,18,db\memtable.hpp,db\memtable.hpp:<global>,,false,1,88,<global>,,,1,
40639,METHOD,leveldb.MemTable,TYPE_DECL,explicit MemTable(const InternalKeyComparator& comparator);,12,60,db\memtable.hpp,leveldb.MemTable.MemTable,,false,24,24,MemTable,,,1,explicit leveldb.MemTable.MemTable (InternalKeyComparator)
40644,METHOD,leveldb.MemTable,TYPE_DECL,void Ref() { ++refs_; },3,25,db\memtable.hpp,leveldb.MemTable.Ref,,false,27,27,Ref,,,2,void leveldb.MemTable.Ref ()
40650,METHOD,leveldb.MemTable,TYPE_DECL,"void Unref() {
    --refs_;
    assert(refs_ >= 0);
    if (refs_ <= 0) {
      delete this;
    }
  }",3,3,db\memtable.hpp,leveldb.MemTable.Unref,,false,30,36,Unref,,,3,void leveldb.MemTable.Unref ()
40667,METHOD,leveldb.MemTable,TYPE_DECL,size_t ApproximateMemoryUsage();,10,33,db\memtable.hpp,leveldb.MemTable.ApproximateMemoryUsage,,false,40,40,ApproximateMemoryUsage,,,4,size_t leveldb.MemTable.ApproximateMemoryUsage ()
40671,METHOD,leveldb.MemTable,TYPE_DECL,Iterator* NewIterator();,11,25,db\memtable.hpp,leveldb.MemTable.NewIterator,,false,48,48,NewIterator,,,5,Iterator* leveldb.MemTable.NewIterator ()
40675,METHOD,leveldb.MemTable,TYPE_DECL,"void Add(SequenceNumber seq, ValueType type,
           const Slice& key,
           const Slice& value);",8,30,db\memtable.hpp,leveldb.MemTable.Add,,false,53,55,Add,,,6,"void leveldb.MemTable.Add (SequenceNumber,ValueType,Slice,Slice)"
40683,METHOD,leveldb.MemTable,TYPE_DECL,"bool Get(const LookupKey& key, std::string* value, Status* s);",8,63,db\memtable.hpp,leveldb.MemTable.Get,,false,61,61,Get,,,7,"bool leveldb.MemTable.Get (LookupKey,ANY*,Status*)"
40690,METHOD,leveldb.MemTable,TYPE_DECL,~MemTable();,3,13,db\memtable.hpp,leveldb.MemTable.~MemTable,,false,64,64,~MemTable,,,8,ANY leveldb.MemTable.~MemTable ()
40696,METHOD,leveldb.MemTable.KeyComparator,TYPE_DECL,explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { },5,78,db\memtable.hpp,leveldb.MemTable.KeyComparator.KeyComparator,,false,68,68,KeyComparator,,,2,ANY leveldb.MemTable.KeyComparator.KeyComparator (InternalKeyComparator)
40701,METHOD,leveldb.MemTable.KeyComparator,TYPE_DECL,"int operator()(const char* a, const char* b) const;",9,54,db\memtable.hpp,leveldb.MemTable.KeyComparator.operator (),,false,69,69,operator (),,,3,"int leveldb.MemTable.KeyComparator.operator () (char*,char*)"
40714,METHOD,leveldb.MemTable,TYPE_DECL,MemTable(const MemTable&);,3,27,db\memtable.hpp,leveldb.MemTable.MemTable,,false,82,82,MemTable,,,17,ANY leveldb.MemTable.MemTable (MemTable)
40719,METHOD,leveldb.MemTable,TYPE_DECL,void operator=(const MemTable&);,8,33,db\memtable.hpp,leveldb.MemTable.operator =,,false,83,83,operator =,,,18,void leveldb.MemTable.operator = (MemTable)
40747,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,<global>,1,1,db\recovery_test.cc,db\recovery_test.cc:<global>,,false,1,324,<global>,,,1,
40751,METHOD,leveldb.RecoveryTest,TYPE_DECL,"RecoveryTest() : env_(Env::Default()), db_(NULL) {
    dbname_ = test::TmpDir() + ""/recovery_test"";
    DestroyDB(dbname_, Options());
    Open();
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.RecoveryTest,,false,20,24,RecoveryTest,,,1,ANY leveldb.RecoveryTest.RecoveryTest ()
40767,METHOD,leveldb.RecoveryTest,TYPE_DECL,"~RecoveryTest() {
    Close();
    DestroyDB(dbname_, Options());
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.~RecoveryTest,,false,26,29,~RecoveryTest,,,2,ANY leveldb.RecoveryTest.~RecoveryTest ()
40775,METHOD,leveldb.RecoveryTest,TYPE_DECL,DBImpl* dbfull() const { return reinterpret_cast<DBImpl*>(db_); },3,67,db\recovery_test.cc,leveldb.RecoveryTest.dbfull,,false,31,31,dbfull,,,3,DBImpl leveldb.RecoveryTest.dbfull ()
40783,METHOD,leveldb.RecoveryTest,TYPE_DECL,Env* env() const { return env_; },3,35,db\recovery_test.cc,leveldb.RecoveryTest.env,,false,32,32,env,,,4,Env leveldb.RecoveryTest.env ()
40789,METHOD,leveldb.RecoveryTest,TYPE_DECL,"bool CanAppend() {
    WritableFile* tmp;
    Status s = env_->NewAppendableFile(CurrentFileName(dbname_), &tmp);
    delete tmp;
    if (s.IsNotSupportedError()) {
      return false;
    } else {
      return true;
    }
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.CanAppend,,false,34,43,CanAppend,,,5,bool leveldb.RecoveryTest.CanAppend ()
40819,METHOD,leveldb.RecoveryTest,TYPE_DECL,"void Close() {
    delete db_;
    db_ = NULL;
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.Close,,false,45,48,Close,,,6,void leveldb.RecoveryTest.Close ()
40828,METHOD,leveldb.RecoveryTest,TYPE_DECL,"void Open(Options* options = NULL) {
    Close();
    Options opts;
    if (options != NULL) {
      opts = *options;
    } else {
      opts.reuse_logs = true;  // TODO(sanjay): test both ways
      opts.create_if_missing = true;
    }
    if (opts.env == NULL) {
      opts.env = env_;
    }
    ASSERT_OK(DB::Open(opts, dbname_, &db_));
    ASSERT_EQ(1, NumLogs());
  }",3,4,db\recovery_test.cc,leveldb.RecoveryTest.Open,,false,50,64,Open,,,7,void leveldb.RecoveryTest.Open (Options*)
40906,METHOD,leveldb.RecoveryTest,TYPE_DECL,"Status Put(const std::string& k, const std::string& v) {
    return db_->Put(WriteOptions(), k, v);
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.Put,,false,66,68,Put,,,8,"Status leveldb.RecoveryTest.Put (ANY,ANY)"
40920,METHOD,leveldb.RecoveryTest,TYPE_DECL,"std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {
    std::string result;
    Status s = db_->Get(ReadOptions(), k, &result);
    if (s.IsNotFound()) {
      result = ""NOT_FOUND"";
    } else if (!s.ok()) {
      result = s.ToString();
    }
    return result;
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.Get,,false,70,79,Get,,,9,"string leveldb.RecoveryTest.Get (ANY,Snapshot*)"
40964,METHOD,leveldb.RecoveryTest,TYPE_DECL,"std::string ManifestFileName() {
    std::string current;
    ASSERT_OK(ReadFileToString(env_, CurrentFileName(dbname_), &current));
    size_t len = current.size();
    if (len > 0 && current[len-1] == '\n') {
      current.resize(len - 1);
    }
    return dbname_ + ""/"" + current;
  }",3,4,db\recovery_test.cc,leveldb.RecoveryTest.ManifestFileName,,false,81,89,ManifestFileName,,,10,string leveldb.RecoveryTest.ManifestFileName ()
41021,METHOD,leveldb.RecoveryTest,TYPE_DECL,"std::string LogName(uint64_t number) {
    return LogFileName(dbname_, number);
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.LogName,,false,91,93,LogName,,,11,string leveldb.RecoveryTest.LogName (uint64_t)
41030,METHOD,leveldb.RecoveryTest,TYPE_DECL,"size_t DeleteLogFiles() {
    std::vector<uint64_t> logs = GetFiles(kLogFile);
    for (size_t i = 0; i < logs.size(); i++) {
      ASSERT_OK(env_->DeleteFile(LogName(logs[i]))) << LogName(logs[i]);
    }
    return logs.size();
  }",3,6,db\recovery_test.cc,leveldb.RecoveryTest.DeleteLogFiles,,false,95,101,DeleteLogFiles,,,12,size_t leveldb.RecoveryTest.DeleteLogFiles ()
41098,METHOD,leveldb.RecoveryTest,TYPE_DECL,"uint64_t FirstLogFile() {
    return GetFiles(kLogFile)[0];
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.FirstLogFile,,false,103,105,FirstLogFile,,,13,uint64_t leveldb.RecoveryTest.FirstLogFile ()
41107,METHOD,leveldb.RecoveryTest,TYPE_DECL,"std::vector<uint64_t> GetFiles(FileType t) {
    std::vector<std::string> filenames;
    ASSERT_OK(env_->GetChildren(dbname_, &filenames));
    std::vector<uint64_t> result;
    for (size_t i = 0; i < filenames.size(); i++) {
      uint64_t number;
      FileType type;
      if (ParseFileName(filenames[i], &number, &type) && type == t) {
        result.push_back(number);
      }
    }
    return result;
  }",3,4,db\recovery_test.cc,leveldb.RecoveryTest.GetFiles,,false,107,119,GetFiles,,,14,vector<uint64_t> leveldb.RecoveryTest.GetFiles (FileType)
41186,METHOD,leveldb.RecoveryTest,TYPE_DECL,"int NumLogs() {
    return GetFiles(kLogFile).size();
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.NumLogs,,false,121,123,NumLogs,,,15,int leveldb.RecoveryTest.NumLogs ()
41196,METHOD,leveldb.RecoveryTest,TYPE_DECL,"int NumTables() {
    return GetFiles(kTableFile).size();
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.NumTables,,false,125,127,NumTables,,,16,int leveldb.RecoveryTest.NumTables ()
41206,METHOD,leveldb.RecoveryTest,TYPE_DECL,"uint64_t FileSize(const std::string& fname) {
    uint64_t result;
    ASSERT_OK(env_->GetFileSize(fname, &result)) << fname;
    return result;
  }",3,4,db\recovery_test.cc,leveldb.RecoveryTest.FileSize,,false,129,133,FileSize,,,17,uint64_t leveldb.RecoveryTest.FileSize (ANY)
41236,METHOD,leveldb.RecoveryTest,TYPE_DECL,"void CompactMemTable() {
    dbfull()->TEST_CompactMemTable();
  }",3,3,db\recovery_test.cc,leveldb.RecoveryTest.CompactMemTable,,false,135,137,CompactMemTable,,,18,void leveldb.RecoveryTest.CompactMemTable ()
41244,METHOD,leveldb.RecoveryTest,TYPE_DECL,"void MakeLogFile(uint64_t lognum, SequenceNumber seq, Slice key, Slice val) {
    std::string fname = LogFileName(dbname_, lognum);
    WritableFile* file;
    ASSERT_OK(env_->NewWritableFile(fname, &file));
    log::Writer writer(file);
    WriteBatch batch;
    batch.Put(key, val);
    WriteBatchInternal::SetSequence(&batch, seq);
    ASSERT_OK(writer.AddRecord(WriteBatchInternal::Contents(&batch)));
    ASSERT_OK(file->Flush());
    delete file;
  }",3,4,db\recovery_test.cc,leveldb.RecoveryTest.MakeLogFile,,false,140,151,MakeLogFile,,,19,"void leveldb.RecoveryTest.MakeLogFile (uint64_t,SequenceNumber,Slice,Slice)"
41356,METHOD,leveldb._Test_ManifestReused,TYPE_DECL,void void ();,1,34,db\recovery_test.cc,leveldb._Test_ManifestReused._Run,,false,159,159,_Run,,,1,void leveldb._Test_ManifestReused._Run ()
41360,METHOD,leveldb._Test_ManifestReused,TYPE_DECL,"TEST(RecoveryTest, ManifestReused)",1,34,db\recovery_test.cc,leveldb._Test_ManifestReused._RunIt,,false,159,159,_RunIt,,,2,void leveldb._Test_ManifestReused._RunIt ()
41384,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"TEST(RecoveryTest, ManifestReused) {
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  std::string old_manifest = ManifestFileName();
  Open();
  ASSERT_EQ(old_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
  Open();
  ASSERT_EQ(old_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
}",1,34,db\recovery_test.cc,leveldb._Test_ManifestReused._Run,,false,159,173,_Run,,,5,void leveldb._Test_ManifestReused._Run ()
41492,METHOD,leveldb._Test_LargeManifestCompacted,TYPE_DECL,void void ();,1,42,db\recovery_test.cc,leveldb._Test_LargeManifestCompacted._Run,,false,175,175,_Run,,,1,void leveldb._Test_LargeManifestCompacted._Run ()
41496,METHOD,leveldb._Test_LargeManifestCompacted,TYPE_DECL,"TEST(RecoveryTest, LargeManifestCompacted)",1,42,db\recovery_test.cc,leveldb._Test_LargeManifestCompacted._RunIt,,false,175,175,_RunIt,,,2,void leveldb._Test_LargeManifestCompacted._RunIt ()
41520,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"TEST(RecoveryTest, LargeManifestCompacted) {
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  std::string old_manifest = ManifestFileName();

  // Pad with zeroes to make manifest file very big.
  {
    uint64_t len = FileSize(old_manifest);
    WritableFile* file;
    ASSERT_OK(env()->NewAppendableFile(old_manifest, &file));
    std::string zeroes(3*1048576 - static_cast<size_t>(len), 0);
    ASSERT_OK(file->Append(zeroes));
    ASSERT_OK(file->Flush());
    delete file;
  }

  Open();
  std::string new_manifest = ManifestFileName();
  ASSERT_NE(old_manifest, new_manifest);
  ASSERT_GT(10000, FileSize(new_manifest));
  ASSERT_EQ(""bar"", Get(""foo""));

  Open();
  ASSERT_EQ(new_manifest, ManifestFileName());
  ASSERT_EQ(""bar"", Get(""foo""));
}",1,42,db\recovery_test.cc,leveldb._Test_LargeManifestCompacted._Run,,false,175,204,_Run,,,9,void leveldb._Test_LargeManifestCompacted._Run ()
41734,METHOD,leveldb._Test_NoLogFiles,TYPE_DECL,void void ();,1,30,db\recovery_test.cc,leveldb._Test_NoLogFiles._Run,,false,206,206,_Run,,,1,void leveldb._Test_NoLogFiles._Run ()
41738,METHOD,leveldb._Test_NoLogFiles,TYPE_DECL,"TEST(RecoveryTest, NoLogFiles)",1,30,db\recovery_test.cc,leveldb._Test_NoLogFiles._RunIt,,false,206,206,_RunIt,,,2,void leveldb._Test_NoLogFiles._RunIt ()
41762,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"TEST(RecoveryTest, NoLogFiles) {
  ASSERT_OK(Put(""foo"", ""bar""));
  ASSERT_EQ(1, DeleteLogFiles());
  Open();
  ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
  Open();
  ASSERT_EQ(""NOT_FOUND"", Get(""foo""));
}",1,30,db\recovery_test.cc,leveldb._Test_NoLogFiles._Run,,false,206,213,_Run,,,13,void leveldb._Test_NoLogFiles._Run ()
41840,METHOD,leveldb._Test_LogFileReuse,TYPE_DECL,void void ();,1,32,db\recovery_test.cc,leveldb._Test_LogFileReuse._Run,,false,215,215,_Run,,,1,void leveldb._Test_LogFileReuse._Run ()
41844,METHOD,leveldb._Test_LogFileReuse,TYPE_DECL,"TEST(RecoveryTest, LogFileReuse)",1,32,db\recovery_test.cc,leveldb._Test_LogFileReuse._RunIt,,false,215,215,_RunIt,,,2,void leveldb._Test_LogFileReuse._RunIt ()
41868,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"TEST(RecoveryTest, LogFileReuse) {
  if (!CanAppend()) {
    fprintf(stderr, ""skipping test because env does not support appending\n"");
    return;
  }
  for (int i = 0; i < 2; i++) {
    ASSERT_OK(Put(""foo"", ""bar""));
    if (i == 0) {
      // Compact to ensure current log is empty
      CompactMemTable();
    }
    Close();
    ASSERT_EQ(1, NumLogs());
    uint64_t number = FirstLogFile();
    if (i == 0) {
      ASSERT_EQ(0, FileSize(LogName(number)));
    } else {
      ASSERT_LT(0, FileSize(LogName(number)));
    }
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
    Open();
    ASSERT_EQ(1, NumLogs());
    ASSERT_EQ(number, FirstLogFile()) << ""did not reuse log file"";
    ASSERT_EQ(""bar"", Get(""foo""));
  }
}",1,32,db\recovery_test.cc,leveldb._Test_LogFileReuse._Run,,false,215,243,_Run,,,17,void leveldb._Test_LogFileReuse._Run ()
42098,METHOD,leveldb._Test_MultipleMemTables,TYPE_DECL,void void ();,1,37,db\recovery_test.cc,leveldb._Test_MultipleMemTables._Run,,false,245,245,_Run,,,1,void leveldb._Test_MultipleMemTables._Run ()
42102,METHOD,leveldb._Test_MultipleMemTables,TYPE_DECL,"TEST(RecoveryTest, MultipleMemTables)",1,37,db\recovery_test.cc,leveldb._Test_MultipleMemTables._RunIt,,false,245,245,_RunIt,,,2,void leveldb._Test_MultipleMemTables._RunIt ()
42126,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"TEST(RecoveryTest, MultipleMemTables) {
  // Make a large log.
  const int kNum = 1000;
  for (int i = 0; i < kNum; i++) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_OK(Put(buf, buf));
  }
  ASSERT_EQ(0, NumTables());
  Close();
  ASSERT_EQ(0, NumTables());
  ASSERT_EQ(1, NumLogs());
  uint64_t old_log_file = FirstLogFile();

  // Force creation of multiple memtables by reducing the write buffer size.
  Options opt;
  opt.reuse_logs = true;
  opt.write_buffer_size = (kNum*100) / 2;
  Open(&opt);
  ASSERT_LE(2, NumTables());
  ASSERT_EQ(1, NumLogs());
  ASSERT_NE(old_log_file, FirstLogFile()) << ""must not reuse log"";
  for (int i = 0; i < kNum; i++) {
    char buf[100];
    snprintf(buf, sizeof(buf), ""%050d"", i);
    ASSERT_EQ(buf, Get(buf));
  }
}",1,37,db\recovery_test.cc,leveldb._Test_MultipleMemTables._Run,,false,245,272,_Run,,,21,void leveldb._Test_MultipleMemTables._Run ()
42335,METHOD,leveldb._Test_MultipleLogFiles,TYPE_DECL,void void ();,1,36,db\recovery_test.cc,leveldb._Test_MultipleLogFiles._Run,,false,274,274,_Run,,,1,void leveldb._Test_MultipleLogFiles._Run ()
42339,METHOD,leveldb._Test_MultipleLogFiles,TYPE_DECL,"TEST(RecoveryTest, MultipleLogFiles)",1,36,db\recovery_test.cc,leveldb._Test_MultipleLogFiles._RunIt,,false,274,274,_RunIt,,,2,void leveldb._Test_MultipleLogFiles._RunIt ()
42363,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"TEST(RecoveryTest, MultipleLogFiles) {
  ASSERT_OK(Put(""foo"", ""bar""));
  Close();
  ASSERT_EQ(1, NumLogs());

  // Make a bunch of uncompacted log files.
  uint64_t old_log = FirstLogFile();
  MakeLogFile(old_log+1, 1000, ""hello"", ""world"");
  MakeLogFile(old_log+2, 1001, ""hi"", ""there"");
  MakeLogFile(old_log+3, 1002, ""foo"", ""bar2"");

  // Recover and check that all log files were processed.
  Open();
  ASSERT_LE(1, NumTables());
  ASSERT_EQ(1, NumLogs());
  uint64_t new_log = FirstLogFile();
  ASSERT_LE(old_log+3, new_log);
  ASSERT_EQ(""bar2"", Get(""foo""));
  ASSERT_EQ(""world"", Get(""hello""));
  ASSERT_EQ(""there"", Get(""hi""));

  // Test that previous recovery produced recoverable state.
  Open();
  ASSERT_LE(1, NumTables());
  ASSERT_EQ(1, NumLogs());
  if (CanAppend()) {
    ASSERT_EQ(new_log, FirstLogFile());
  }
  ASSERT_EQ(""bar2"", Get(""foo""));
  ASSERT_EQ(""world"", Get(""hello""));
  ASSERT_EQ(""there"", Get(""hi""));

  // Check that introducing an older log file does not cause it to be...",1,36,db\recovery_test.cc,leveldb._Test_MultipleLogFiles._Run,,false,274,318,_Run,,,25,void leveldb._Test_MultipleLogFiles._Run ()
42772,METHOD,db\recovery_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\recovery_test.cc,main,,false,322,324,main,,,2,"int main (int,char**)"
42814,METHOD,db\repair.cc:<global>,TYPE_DECL,<global>,1,1,db\repair.cc,db\repair.cc:<global>,,false,1,461,<global>,,,1,
42819,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"Repairer(const std::string& dbname, const Options& options)
      : dbname_(dbname),
        env_(options.env),
        icmp_(options.comparator),
        ipolicy_(options.filter_policy),
        options_(SanitizeOptions(dbname, &icmp_, &ipolicy_, options)),
        owns_info_log_(options_.info_log != options.info_log),
        owns_cache_(options_.block_cache != options.block_cache),
        next_file_number_(1) {
    // TableCache can be small since we expect each table to be opened once.
    table_cache_ = new TableCache(dbname_, &options_, 10);
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_2.Repairer.Repairer,,false,47,58,Repairer,,,1,"ANY leveldb.anonymous_namespace_2.Repairer.Repairer (ANY,Options)"
42833,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"~Repairer() {
    delete table_cache_;
    if (owns_info_log_) {
      delete options_.info_log;
    }
    if (owns_cache_) {
      delete options_.block_cache;
    }
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_3.Repairer.~Repairer,,false,60,68,~Repairer,,,2,ANY leveldb.anonymous_namespace_3.Repairer.~Repairer ()
42853,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"Status Run() {
    Status status = FindFiles();
    if (status.ok()) {
      ConvertLogFilesToTables();
      ExtractMetaData();
      status = WriteDescriptor();
    }
    if (status.ok()) {
      unsigned long long bytes = 0;
      for (size_t i = 0; i < tables_.size(); i++) {
        bytes += tables_[i].meta.file_size;
      }
      Log(options_.info_log,
          ""**** Repaired leveldb %s; ""
          ""recovered %d files; %llu bytes. ""
          ""Some data may have been lost. ""
          ""****"",
          dbname_.c_str(),
          static_cast<int>(tables_.size()),
          bytes);
    }
    return status;
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_4.Repairer.Run,,false,70,92,Run,,,3,Status leveldb.anonymous_namespace_4.Repairer.Run ()
42941,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"Status FindFiles() {
    std::vector<std::string> filenames;
    Status status = env_->GetChildren(dbname_, &filenames);
    if (!status.ok()) {
      return status;
    }
    if (filenames.empty()) {
      return Status::IOError(dbname_, ""repair found no files"");
    }

    uint64_t number;
    FileType type;
    for (size_t i = 0; i < filenames.size(); i++) {
      if (ParseFileName(filenames[i], &number, &type)) {
        if (type == kDescriptorFile) {
          manifests_.push_back(filenames[i]);
        } else {
          if (number + 1 > next_file_number_) {
            next_file_number_ = number + 1;
          }
          if (type == kLogFile) {
            logs_.push_back(number);
          } else if (type == kTableFile) {
            table_numbers_.push_back(number);
          } else {
            // Ignore other files
          }
        }
      }
    }
    return status;
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_10.Repairer.FindFiles,,false,116,147,FindFiles,,,19,Status leveldb.anonymous_namespace_10.Repairer.FindFiles ()
43065,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"void ConvertLogFilesToTables() {
    for (size_t i = 0; i < logs_.size(); i++) {
      std::string logname = LogFileName(dbname_, logs_[i]);
      Status status = ConvertLogToTable(logs_[i]);
      if (!status.ok()) {
        Log(options_.info_log, ""Log #%llu: ignoring conversion error: %s"",
            (unsigned long long) logs_[i],
            status.ToString().c_str());
      }
      ArchiveFile(logname);
    }
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_11.Repairer.ConvertLogFilesToTables,,false,149,160,ConvertLogFilesToTables,,,20,void leveldb.anonymous_namespace_11.Repairer.ConvertLogFilesToTables ()
43125,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"Status ConvertLogToTable(uint64_t log) {
    struct LogReporter : public log::Reader::Reporter {
      Env* env;
      Logger* info_log;
      uint64_t lognum;
      virtual void Corruption(size_t bytes, const Status& s) {
        // We print error messages for corruption, but continue repairing.
        Log(info_log, ""Log #%llu: dropping %d bytes; %s"",
            (unsigned long long) lognum,
            static_cast<int>(bytes),
            s.ToString().c_str());
      }
    };

    // Open the log file
    std::string logname = LogFileName(dbname_, log);
    SequentialFile* lfile;
    Status status = env_->NewSequentialFile(logname, &lfile);
    if (!status.ok()) {
      return status;
    }

    // Create the log reader.
    LogReporter reporter;
    reporter.env = env_;
    reporter.info_log = options_.info_log;
    reporter.lognum = log;
    // We intentionally make log::Reader do checksumming so that
    // corruptions cause entire commits to be skipped instead of
    // propa...",3,3,db\repair.cc,leveldb.anonymous_namespace_14.Repairer.ConvertLogToTable,,false,162,242,ConvertLogToTable,,,21,Status leveldb.anonymous_namespace_14.Repairer.ConvertLogToTable (uint64_t)
43361,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"void ExtractMetaData() {
    for (size_t i = 0; i < table_numbers_.size(); i++) {
      ScanTable(table_numbers_[i]);
    }
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_15.Repairer.ExtractMetaData,,false,244,248,ExtractMetaData,,,22,void leveldb.anonymous_namespace_15.Repairer.ExtractMetaData ()
43384,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"Iterator* NewTableIterator(const FileMetaData& meta) {
    // Same as compaction iterators: if paranoid_checks are on, turn
    // on checksum verification.
    ReadOptions r;
    r.verify_checksums = options_.paranoid_checks;
    return table_cache_->NewIterator(r, meta.number, meta.file_size);
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_17.Repairer.NewTableIterator,,false,250,256,NewTableIterator,,,23,Iterator leveldb.anonymous_namespace_17.Repairer.NewTableIterator (FileMetaData)
43409,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"void ScanTable(uint64_t number) {
    TableInfo t;
    t.meta.number = number;
    std::string fname = TableFileName(dbname_, number);
    Status status = env_->GetFileSize(fname, &t.meta.file_size);
    if (!status.ok()) {
      // Try alternate file name.
      fname = SSTTableFileName(dbname_, number);
      Status s2 = env_->GetFileSize(fname, &t.meta.file_size);
      if (s2.ok()) {
        status = Status::OK();
      }
    }
    if (!status.ok()) {
      ArchiveFile(TableFileName(dbname_, number));
      ArchiveFile(SSTTableFileName(dbname_, number));
      Log(options_.info_log, ""Table #%llu: dropped: %s"",
          (unsigned long long) t.meta.number,
          status.ToString().c_str());
      return;
    }

    // Extract metadata by scanning through table.
    int counter = 0;
    Iterator* iter = NewTableIterator(t.meta);
    bool empty = true;
    ParsedInternalKey parsed;
    t.max_sequence = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      Slice k...",3,3,db\repair.cc,leveldb.anonymous_namespace_18.Repairer.ScanTable,,false,258,319,ScanTable,,,24,void leveldb.anonymous_namespace_18.Repairer.ScanTable (uint64_t)
43679,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"void RepairTable(const std::string& src, TableInfo t) {
    // We will copy src contents to a new table and then rename the
    // new table over the source.

    // Create builder.
    std::string copy = TableFileName(dbname_, next_file_number_++);
    WritableFile* file;
    Status s = env_->NewWritableFile(copy, &file);
    if (!s.ok()) {
      return;
    }
    TableBuilder* builder = new TableBuilder(options_, file);

    // Copy data.
    Iterator* iter = NewTableIterator(t.meta);
    int counter = 0;
    for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
      builder->Add(iter->key(), iter->value());
      counter++;
    }
    delete iter;

    ArchiveFile(src);
    if (counter == 0) {
      builder->Abandon();  // Nothing to save
    } else {
      s = builder->Finish();
      if (s.ok()) {
        t.meta.file_size = builder->FileSize();
      }
    }
    delete builder;
    builder = NULL;

    if (s.ok()) {
      s = file->Close();
    }
    delete file;
    file = ...",3,3,db\repair.cc,leveldb.anonymous_namespace_23.Repairer.RepairTable,,false,321,373,RepairTable,,,25,"void leveldb.anonymous_namespace_23.Repairer.RepairTable (ANY,TableInfo)"
43881,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"Status WriteDescriptor() {
    std::string tmp = TempFileName(dbname_, 1);
    WritableFile* file;
    Status status = env_->NewWritableFile(tmp, &file);
    if (!status.ok()) {
      return status;
    }

    SequenceNumber max_sequence = 0;
    for (size_t i = 0; i < tables_.size(); i++) {
      if (max_sequence < tables_[i].max_sequence) {
        max_sequence = tables_[i].max_sequence;
      }
    }

    edit_.SetComparatorName(icmp_.user_comparator()->Name());
    edit_.SetLogNumber(0);
    edit_.SetNextFile(next_file_number_);
    edit_.SetLastSequence(max_sequence);

    for (size_t i = 0; i < tables_.size(); i++) {
      // TODO(opt): separate out into multiple levels
      const TableInfo& t = tables_[i];
      edit_.AddFile(0, t.meta.number, t.meta.file_size,
                    t.meta.smallest, t.meta.largest);
    }

    //fprintf(stderr, ""NewDescriptor:\n%s\n"", edit_.DebugString().c_str());
    {
      log::Writer log(file);
      std::string record;
      edit_.EncodeT...",3,3,db\repair.cc,leveldb.anonymous_namespace_26.Repairer.WriteDescriptor,,false,375,432,WriteDescriptor,,,26,Status leveldb.anonymous_namespace_26.Repairer.WriteDescriptor ()
44121,METHOD,leveldb.anonymous_namespace_1.Repairer,TYPE_DECL,"void ArchiveFile(const std::string& fname) {
    // Move into another directory.  E.g., for
    //    dir/foo
    // rename to
    //    dir/lost/foo
    const char* slash = strrchr(fname.c_str(), '/');
    std::string new_dir;
    if (slash != NULL) {
      new_dir.assign(fname.data(), slash - fname.data());
    }
    new_dir.append(""/lost"");
    env_->CreateDir(new_dir);  // Ignore error
    std::string new_file = new_dir;
    new_file.append(""/"");
    new_file.append((slash == NULL) ? fname.c_str() : slash + 1);
    Status s = env_->RenameFile(fname, new_file);
    Log(options_.info_log, ""Archiving %s: %s\n"",
        fname.c_str(), s.ToString().c_str());
  }",3,3,db\repair.cc,leveldb.anonymous_namespace_28.Repairer.ArchiveFile,,false,434,452,ArchiveFile,,,27,void leveldb.anonymous_namespace_28.Repairer.ArchiveFile (ANY)
44214,METHOD,db\repair.cc:<global>,TYPE_DECL,"Status RepairDB(const std::string& dbname, const Options& options) {
  Repairer repairer(dbname, options);
  return repairer.Run();
}",1,1,db\repair.cc,leveldb.RepairDB,,false,456,459,RepairDB,,,2,"Status leveldb.RepairDB (ANY,Options)"
44242,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,<global>,1,22,db\skiplist.hpp,db\skiplist.hpp:<global>,,false,1,384,<global>,,,1,
44248,METHOD,leveldb.SkipList,TYPE_DECL,"explicit SkipList(Comparator cmp, Arena* arena);",12,49,db\skiplist.hpp,leveldb.SkipList.SkipList,,false,49,49,SkipList,,,2,"explicit leveldb.SkipList.SkipList (Comparator,Arena*)"
44254,METHOD,leveldb.SkipList,TYPE_DECL,void Insert(const Key& key);,8,29,db\skiplist.hpp,leveldb.SkipList.Insert,,false,53,53,Insert,,,3,void leveldb.SkipList.Insert (Key)
44259,METHOD,leveldb.SkipList,TYPE_DECL,bool Contains(const Key& key) const;,8,37,db\skiplist.hpp,leveldb.SkipList.Contains,,false,56,56,Contains,,,4,bool leveldb.SkipList.Contains (Key)
44265,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,explicit Iterator(const SkipList* list);,14,43,db\skiplist.hpp,leveldb.SkipList.Iterator.Iterator,,false,63,63,Iterator,,,1,explicit leveldb.SkipList.Iterator.Iterator (SkipList*)
44270,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,bool Valid() const;,10,22,db\skiplist.hpp,leveldb.SkipList.Iterator.Valid,,false,66,66,Valid,,,2,bool leveldb.SkipList.Iterator.Valid ()
44274,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,const Key& key() const;,14,26,db\skiplist.hpp,leveldb.SkipList.Iterator.key,,false,70,70,key,,,3,Key leveldb.SkipList.Iterator.key ()
44278,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,void Next();,10,15,db\skiplist.hpp,leveldb.SkipList.Iterator.Next,,false,74,74,Next,,,4,void leveldb.SkipList.Iterator.Next ()
44282,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,void Prev();,10,15,db\skiplist.hpp,leveldb.SkipList.Iterator.Prev,,false,78,78,Prev,,,5,void leveldb.SkipList.Iterator.Prev ()
44286,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,void Seek(const Key& target);,10,32,db\skiplist.hpp,leveldb.SkipList.Iterator.Seek,,false,81,81,Seek,,,6,void leveldb.SkipList.Iterator.Seek (Key)
44291,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,void SeekToFirst();,10,22,db\skiplist.hpp,leveldb.SkipList.Iterator.SeekToFirst,,false,85,85,SeekToFirst,,,7,void leveldb.SkipList.Iterator.SeekToFirst ()
44295,METHOD,leveldb.SkipList.Iterator,TYPE_DECL,void SeekToLast();,10,21,db\skiplist.hpp,leveldb.SkipList.Iterator.SeekToLast,,false,89,89,SeekToLast,,,8,void leveldb.SkipList.Iterator.SeekToLast ()
44303,METHOD,<empty>,<empty>,<empty>,3,,db\skiplist.hpp,leveldb.SkipList.anonymous_enum_0:<clinit>,,false,98,,<clinit>,,,2,
44314,METHOD,leveldb.SkipList,TYPE_DECL,"inline int GetMaxHeight() const {
    return static_cast<int>(
        reinterpret_cast<intptr_t>(max_height_.NoBarrier_Load()));
  }",3,3,db\skiplist.hpp,leveldb.SkipList.GetMaxHeight,,false,110,113,GetMaxHeight,,,11,int leveldb.SkipList.GetMaxHeight ()
44328,METHOD,leveldb.SkipList,TYPE_DECL,"Node* NewNode(const Key& key, int height);",7,43,db\skiplist.hpp,leveldb.SkipList.NewNode,,false,118,118,NewNode,,,13,"Node* leveldb.SkipList.NewNode (Key,int)"
44334,METHOD,leveldb.SkipList,TYPE_DECL,int RandomHeight();,7,20,db\skiplist.hpp,leveldb.SkipList.RandomHeight,,false,119,119,RandomHeight,,,14,int leveldb.SkipList.RandomHeight ()
44338,METHOD,leveldb.SkipList,TYPE_DECL,"bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }",3,80,db\skiplist.hpp,leveldb.SkipList.Equal,,false,120,120,Equal,,,15,"bool leveldb.SkipList.Equal (Key,Key)"
44350,METHOD,leveldb.SkipList,TYPE_DECL,"bool KeyIsAfterNode(const Key& key, Node* n) const;",8,52,db\skiplist.hpp,leveldb.SkipList.KeyIsAfterNode,,false,123,123,KeyIsAfterNode,,,16,"bool leveldb.SkipList.KeyIsAfterNode (Key,Node*)"
44356,METHOD,leveldb.SkipList,TYPE_DECL,"Node* FindGreaterOrEqual(const Key& key, Node** prev) const;",7,61,db\skiplist.hpp,leveldb.SkipList.FindGreaterOrEqual,,false,130,130,FindGreaterOrEqual,,,17,"Node* leveldb.SkipList.FindGreaterOrEqual (Key,Node**)"
44362,METHOD,leveldb.SkipList,TYPE_DECL,Node* FindLessThan(const Key& key) const;,7,42,db\skiplist.hpp,leveldb.SkipList.FindLessThan,,false,134,134,FindLessThan,,,18,Node* leveldb.SkipList.FindLessThan (Key)
44367,METHOD,leveldb.SkipList,TYPE_DECL,Node* FindLast() const;,7,24,db\skiplist.hpp,leveldb.SkipList.FindLast,,false,138,138,FindLast,,,19,Node* leveldb.SkipList.FindLast ()
44371,METHOD,leveldb.SkipList,TYPE_DECL,SkipList(const SkipList&);,3,27,db\skiplist.hpp,leveldb.SkipList.SkipList,,false,141,141,SkipList,,,20,ANY leveldb.SkipList.SkipList (SkipList)
44376,METHOD,leveldb.SkipList,TYPE_DECL,void operator=(const SkipList&);,8,33,db\skiplist.hpp,leveldb.SkipList.operator =,,false,142,142,operator =,,,21,void leveldb.SkipList.operator = (SkipList)
44382,METHOD,leveldb.Node,TYPE_DECL,explicit Node(const Key& k) : key(k) { },3,42,db\skiplist.hpp,leveldb.Node.Node,,false,148,148,Node,,,1,ANY leveldb.Node.Node (Key)
44388,METHOD,leveldb.Node,TYPE_DECL,"Node* Next(int n) {
    assert(n >= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast<Node*>(next_[n].Acquire_Load());
  }",3,3,db\skiplist.hpp,leveldb.Node.Next,,false,154,159,Next,,,3,Node leveldb.Node.Next (int)
44406,METHOD,leveldb.Node,TYPE_DECL,"void SetNext(int n, Node* x) {
    assert(n >= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }",3,3,db\skiplist.hpp,leveldb.Node.SetNext,,false,160,165,SetNext,,,4,"void leveldb.Node.SetNext (int,Node*)"
44423,METHOD,leveldb.Node,TYPE_DECL,"Node* NoBarrier_Next(int n) {
    assert(n >= 0);
    return reinterpret_cast<Node*>(next_[n].NoBarrier_Load());
  }",3,3,db\skiplist.hpp,leveldb.Node.NoBarrier_Next,,false,168,171,NoBarrier_Next,,,5,Node leveldb.Node.NoBarrier_Next (int)
44441,METHOD,leveldb.Node,TYPE_DECL,"void NoBarrier_SetNext(int n, Node* x) {
    assert(n >= 0);
    next_[n].NoBarrier_Store(x);
  }",3,3,db\skiplist.hpp,leveldb.Node.NoBarrier_SetNext,,false,172,175,NoBarrier_SetNext,,,6,"void leveldb.Node.NoBarrier_SetNext (int,Node*)"
44459,METHOD,<empty>,<empty>,<empty>,1,,db\skiplist.hpp,leveldb.Node:<clinit>,,false,147,,<clinit>,,,8,
44465,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"typename SkipList<Key,Comparator>::Node*
SkipList<Key,Comparator>::NewNode(const Key& key, int height) {
  char* mem = arena_->AllocateAligned(
      sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1));
  return new (mem) Node(key);
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.NewNode",,false,183,188,NewNode,,,4,"Node leveldb.SkipList<Key,Comparator>.NewNode<Key,Comparator> (Key,int)"
44492,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline SkipList<Key,Comparator>::Iterator::Iterator(const SkipList* list) {
  list_ = list;
  node_ = NULL;
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.Iterator",,false,191,194,Iterator,,,5,"ANY leveldb.SkipList<Key,Comparator>.Iterator.Iterator<Key,Comparator> (SkipList*)"
44503,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline bool SkipList<Key,Comparator>::Iterator::Valid() const {
  return node_ != NULL;
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.Valid",,false,197,199,Valid,,,6,"bool leveldb.SkipList<Key,Comparator>.Iterator.Valid<Key,Comparator> ()"
44511,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline const Key& SkipList<Key,Comparator>::Iterator::key() const {
  assert(Valid());
  return node_->key;
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.key",,false,202,205,key,,,7,"Key leveldb.SkipList<Key,Comparator>.Iterator.key<Key,Comparator> ()"
44521,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline void SkipList<Key,Comparator>::Iterator::Next() {
  assert(Valid());
  node_ = node_->Next(0);
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.Next",,false,208,211,Next,,,8,"void leveldb.SkipList<Key,Comparator>.Iterator.Next<Key,Comparator> ()"
44534,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline void SkipList<Key,Comparator>::Iterator::Prev() {
  // Instead of using explicit ""prev"" links, we just search for the
  // last node that falls before key.
  assert(Valid());
  node_ = list_->FindLessThan(node_->key);
  if (node_ == list_->head_) {
    node_ = NULL;
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.Prev",,false,214,222,Prev,,,9,"void leveldb.SkipList<Key,Comparator>.Iterator.Prev<Key,Comparator> ()"
44559,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline void SkipList<Key,Comparator>::Iterator::Seek(const Key& target) {
  node_ = list_->FindGreaterOrEqual(target, NULL);
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.Seek",,false,225,227,Seek,,,10,"void leveldb.SkipList<Key,Comparator>.Iterator.Seek<Key,Comparator> (Key)"
44572,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline void SkipList<Key,Comparator>::Iterator::SeekToFirst() {
  node_ = list_->head_->Next(0);
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.SeekToFirst",,false,230,232,SeekToFirst,,,11,"void leveldb.SkipList<Key,Comparator>.Iterator.SeekToFirst<Key,Comparator> ()"
44585,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"inline void SkipList<Key,Comparator>::Iterator::SeekToLast() {
  node_ = list_->FindLast();
  if (node_ == list_->head_) {
    node_ = NULL;
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Iterator.SeekToLast",,false,235,240,SeekToLast,,,12,"void leveldb.SkipList<Key,Comparator>.Iterator.SeekToLast<Key,Comparator> ()"
44605,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"int SkipList<Key,Comparator>::RandomHeight() {
  // Increase height with probability 1 in kBranching
  static const unsigned int kBranching = 4;
  int height = 1;
  while (height < kMaxHeight && ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height > 0);
  assert(height <= kMaxHeight);
  return height;
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.RandomHeight",,false,243,253,RandomHeight,,,13,"int leveldb.SkipList<Key,Comparator>.RandomHeight<Key,Comparator> ()"
44643,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"bool SkipList<Key,Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {
  // NULL n is considered infinite
  return (n != NULL) && (compare_(n->key, key) < 0);
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.KeyIsAfterNode",,false,256,259,KeyIsAfterNode,,,14,"bool leveldb.SkipList<Key,Comparator>.KeyIsAfterNode<Key,Comparator> (Key,Node*)"
44661,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindGreaterOrEqual(const Key& key, Node** prev)
    const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (KeyIsAfterNode(key, next)) {
      // Keep searching in this list
      x = next;
    } else {
      if (prev != NULL) prev[level] = x;
      if (level == 0) {
        return next;
      } else {
        // Switch to next list
        level--;
      }
    }
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.FindGreaterOrEqual",,false,262,281,FindGreaterOrEqual,,,15,"Node leveldb.SkipList<Key,Comparator>.FindGreaterOrEqual<Key,Comparator> (Key,Node**)"
44719,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"typename SkipList<Key,Comparator>::Node*
SkipList<Key,Comparator>::FindLessThan(const Key& key) const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    assert(x == head_ || compare_(x->key, key) < 0);
    Node* next = x->Next(level);
    if (next == NULL || compare_(next->key, key) >= 0) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.FindLessThan",,false,284,302,FindLessThan,,,16,"Node leveldb.SkipList<Key,Comparator>.FindLessThan<Key,Comparator> (Key)"
44786,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindLast()
    const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x->Next(level);
    if (next == NULL) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.FindLast",,false,305,322,FindLast,,,17,"Node leveldb.SkipList<Key,Comparator>.FindLast<Key,Comparator> ()"
44832,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"SkipList<Key,Comparator>::SkipList(Comparator cmp, Arena* arena)
    : compare_(cmp),
      arena_(arena),
      head_(NewNode(0 /* any key will do */, kMaxHeight)),
      max_height_(reinterpret_cast<void*>(1)),
      rnd_(0xdeadbeef) {
  for (int i = 0; i < kMaxHeight; i++) {
    head_->SetNext(i, NULL);
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.SkipList",,false,325,334,SkipList,,,18,"ANY leveldb.SkipList<Key,Comparator>.SkipList<Key,Comparator> (Comparator,Arena*)"
44856,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"void SkipList<Key,Comparator>::Insert(const Key& key) {
  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  // here since Insert() is externally synchronized.
  Node* prev[kMaxHeight];
  Node* x = FindGreaterOrEqual(key, prev);

  // Our data structure does not allow duplicate insertion
  assert(x == NULL || !Equal(key, x->key));

  int height = RandomHeight();
  if (height > GetMaxHeight()) {
    for (int i = GetMaxHeight(); i < height; i++) {
      prev[i] = head_;
    }
    //fprintf(stderr, ""Change height from %d to %d\n"", max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the...",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Insert",,false,337,370,Insert,,,19,"void leveldb.SkipList<Key,Comparator>.Insert<Key,Comparator> (Key)"
44949,METHOD,db\skiplist.hpp:<global>,TYPE_DECL,"bool SkipList<Key,Comparator>::Contains(const Key& key) const {
  Node* x = FindGreaterOrEqual(key, NULL);
  if (x != NULL && Equal(key, x->key)) {
    return true;
  } else {
    return false;
  }
}",1,1,db\skiplist.hpp,"leveldb.SkipList<Key,Comparator>.Contains",,false,373,380,Contains,,,20,"bool leveldb.SkipList<Key,Comparator>.Contains<Key,Comparator> (Key)"
44994,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,<global>,1,1,db\skiplist_test.cc,db\skiplist_test.cc:<global>,,false,1,378,<global>,,,1,
44999,METHOD,leveldb.Comparator,TYPE_DECL,"int operator()(const Key& a, const Key& b) const {
    if (a < b) {
      return -1;
    } else if (a > b) {
      return +1;
    } else {
      return 0;
    }
  }",3,3,db\skiplist_test.cc,leveldb.Comparator.operator (),,false,18,26,operator (),,,1,"int leveldb.Comparator.operator () (Key,Key)"
45029,METHOD,leveldb._Test_Empty,TYPE_DECL,void void ();,1,21,db\skiplist_test.cc,leveldb._Test_Empty._Run,,false,31,31,_Run,,,1,void leveldb._Test_Empty._Run ()
45033,METHOD,leveldb._Test_Empty,TYPE_DECL,"TEST(SkipTest, Empty)",1,21,db\skiplist_test.cc,leveldb._Test_Empty._RunIt,,false,31,31,_RunIt,,,2,void leveldb._Test_Empty._RunIt ()
45057,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, Empty) {
  Arena arena;
  Comparator cmp;
  SkipList<Key, Comparator> list(cmp, &arena);
  ASSERT_TRUE(!list.Contains(10));

  SkipList<Key, Comparator>::Iterator iter(&list);
  ASSERT_TRUE(!iter.Valid());
  iter.SeekToFirst();
  ASSERT_TRUE(!iter.Valid());
  iter.Seek(100);
  ASSERT_TRUE(!iter.Valid());
  iter.SeekToLast();
  ASSERT_TRUE(!iter.Valid());
}",1,21,db\skiplist_test.cc,leveldb._Test_Empty._Run,,false,31,45,_Run,,,7,void leveldb._Test_Empty._Run ()
45208,METHOD,leveldb._Test_InsertAndLookup,TYPE_DECL,void void ();,1,31,db\skiplist_test.cc,leveldb._Test_InsertAndLookup._Run,,false,47,47,_Run,,,1,void leveldb._Test_InsertAndLookup._Run ()
45212,METHOD,leveldb._Test_InsertAndLookup,TYPE_DECL,"TEST(SkipTest, InsertAndLookup)",1,31,db\skiplist_test.cc,leveldb._Test_InsertAndLookup._RunIt,,false,47,47,_RunIt,,,2,void leveldb._Test_InsertAndLookup._RunIt ()
45236,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, InsertAndLookup) {
  const int N = 2000;
  const int R = 5000;
  Random rnd(1000);
  std::set<Key> keys;
  Arena arena;
  Comparator cmp;
  SkipList<Key, Comparator> list(cmp, &arena);
  for (int i = 0; i < N; i++) {
    Key key = rnd.Next() % R;
    if (keys.insert(key).second) {
      list.Insert(key);
    }
  }

  for (int i = 0; i < R; i++) {
    if (list.Contains(i)) {
      ASSERT_EQ(keys.count(i), 1);
    } else {
      ASSERT_EQ(keys.count(i), 0);
    }
  }

  // Simple iterator tests
  {
    SkipList<Key, Comparator>::Iterator iter(&list);
    ASSERT_TRUE(!iter.Valid());

    iter.Seek(0);
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToFirst();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.begin()), iter.key());

    iter.SeekToLast();
    ASSERT_TRUE(iter.Valid());
    ASSERT_EQ(*(keys.rbegin()), iter.key());
  }

  // Forward iteration test
  for (int i = 0; i < R; i++) {
    SkipList<Key, Comparator>::Itera...",1,31,db\skiplist_test.cc,leveldb._Test_InsertAndLookup._Run,,false,47,123,_Run,,,11,void leveldb._Test_InsertAndLookup._Run ()
45799,METHOD,leveldb.ConcurrentTest,TYPE_DECL,static uint64_t key(Key key) { return (key >> 40); },3,54,db\skiplist_test.cc,leveldb.ConcurrentTest.key,,false,153,153,key,,,2,uint64_t leveldb.ConcurrentTest.key (Key)
45808,METHOD,leveldb.ConcurrentTest,TYPE_DECL,static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; },3,67,db\skiplist_test.cc,leveldb.ConcurrentTest.gen,,false,154,154,gen,,,3,uint64_t leveldb.ConcurrentTest.gen (Key)
45819,METHOD,leveldb.ConcurrentTest,TYPE_DECL,static uint64_t hash(Key key) { return key & 0xff; },3,54,db\skiplist_test.cc,leveldb.ConcurrentTest.hash,,false,155,155,hash,,,4,uint64_t leveldb.ConcurrentTest.hash (Key)
45828,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"static uint64_t HashNumbers(uint64_t k, uint64_t g) {
    uint64_t data[2] = { k, g };
    return Hash(reinterpret_cast<char*>(data), sizeof(data), 0);
  }",3,3,db\skiplist_test.cc,leveldb.ConcurrentTest.HashNumbers,,false,157,160,HashNumbers,,,5,"uint64_t leveldb.ConcurrentTest.HashNumbers (uint64_t,uint64_t)"
45848,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"static Key MakeKey(uint64_t k, uint64_t g) {
    assert(sizeof(Key) == sizeof(uint64_t));
    assert(k <= K);  // We sometimes pass K to seek to the end of the skiplist
    assert(g <= 0xffffffffu);
    return ((k << 40) | (g << 8) | (HashNumbers(k, g) & 0xff));
  }",3,3,db\skiplist_test.cc,leveldb.ConcurrentTest.MakeKey,,false,162,167,MakeKey,,,6,"Key leveldb.ConcurrentTest.MakeKey (uint64_t,uint64_t)"
45882,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"static bool IsValidKey(Key k) {
    return hash(k) == (HashNumbers(key(k), gen(k)) & 0xff);
  }",3,3,db\skiplist_test.cc,leveldb.ConcurrentTest.IsValidKey,,false,169,171,IsValidKey,,,7,bool leveldb.ConcurrentTest.IsValidKey (Key)
45898,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"static Key RandomTarget(Random* rnd) {
    switch (rnd->Next() % 10) {
      case 0:
        // Seek to beginning
        return MakeKey(0, 0);
      case 1:
        // Seek to end
        return MakeKey(K, 0);
      default:
        // Seek to middle
        return MakeKey(rnd->Next() % K, 0);
    }
  }",3,3,db\skiplist_test.cc,leveldb.ConcurrentTest.RandomTarget,,false,173,185,RandomTarget,,,8,Key leveldb.ConcurrentTest.RandomTarget (Random*)
45935,METHOD,leveldb.ConcurrentTest.State,TYPE_DECL,"void Set(int k, intptr_t v) {
      generation[k].Release_Store(reinterpret_cast<void*>(v));
    }",5,5,db\skiplist_test.cc,leveldb.ConcurrentTest.State.Set,,false,190,192,Set,,,2,"void leveldb.ConcurrentTest.State.Set (int,intptr_t)"
45950,METHOD,leveldb.ConcurrentTest.State,TYPE_DECL,"intptr_t Get(int k) {
      return reinterpret_cast<intptr_t>(generation[k].Acquire_Load());
    }",5,5,db\skiplist_test.cc,leveldb.ConcurrentTest.State.Get,,false,193,195,Get,,,3,intptr_t leveldb.ConcurrentTest.State.Get (int)
45964,METHOD,leveldb.ConcurrentTest.State,TYPE_DECL,"State() {
      for (int k = 0; k < K; k++) {
        Set(k, 0);
      }
    }",5,5,db\skiplist_test.cc,leveldb.ConcurrentTest.State.State,,false,197,201,State,,,4,ANY leveldb.ConcurrentTest.State.State ()
45983,METHOD,<empty>,<empty>,<empty>,3,,db\skiplist_test.cc,leveldb.ConcurrentTest.State:<clinit>,,false,188,,<clinit>,,,5,
45992,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"ConcurrentTest() : list_(Comparator(), &arena_) { }",3,53,db\skiplist_test.cc,leveldb.ConcurrentTest.ConcurrentTest,,false,214,214,ConcurrentTest,,,13,ANY leveldb.ConcurrentTest.ConcurrentTest ()
45996,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"void WriteStep(Random* rnd) {
    const uint32_t k = rnd->Next() % K;
    const intptr_t g = current_.Get(k) + 1;
    const Key key = MakeKey(k, g);
    list_.Insert(key);
    current_.Set(k, g);
  }",3,3,db\skiplist_test.cc,leveldb.ConcurrentTest.WriteStep,,false,217,223,WriteStep,,,14,void leveldb.ConcurrentTest.WriteStep (Random*)
46037,METHOD,leveldb.ConcurrentTest,TYPE_DECL,"void ReadStep(Random* rnd) {
    // Remember the initial committed state of the skiplist.
    State initial_state;
    for (int k = 0; k < K; k++) {
      initial_state.Set(k, current_.Get(k));
    }

    Key pos = RandomTarget(rnd);
    SkipList<Key, Comparator>::Iterator iter(&list_);
    iter.Seek(pos);
    while (true) {
      Key current;
      if (!iter.Valid()) {
        current = MakeKey(K, 0);
      } else {
        current = iter.key();
        ASSERT_TRUE(IsValidKey(current)) << current;
      }
      ASSERT_LE(pos, current) << ""should not go backwards"";

      // Verify that everything in [pos,current) was not present in
      // initial_state.
      while (pos < current) {
        ASSERT_LT(key(pos), K) << pos;

        // Note that generation 0 is never inserted, so it is ok if
        // <*,0,*> is missing.
        ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    ) << ""key: "" << key(pos)
...",3,8,db\skiplist_test.cc,leveldb.ConcurrentTest.ReadStep,,false,225,282,ReadStep,,,15,void leveldb.ConcurrentTest.ReadStep (Random*)
46292,METHOD,<empty>,<empty>,<empty>,1,,db\skiplist_test.cc,leveldb.ConcurrentTest:<clinit>,,false,149,,<clinit>,,,16,
46301,METHOD,leveldb._Test_ConcurrentWithoutThreads,TYPE_DECL,void void ();,1,40,db\skiplist_test.cc,leveldb._Test_ConcurrentWithoutThreads._Run,,false,288,288,_Run,,,1,void leveldb._Test_ConcurrentWithoutThreads._Run ()
46305,METHOD,leveldb._Test_ConcurrentWithoutThreads,TYPE_DECL,"TEST(SkipTest, ConcurrentWithoutThreads)",1,40,db\skiplist_test.cc,leveldb._Test_ConcurrentWithoutThreads._RunIt,,false,288,288,_RunIt,,,2,void leveldb._Test_ConcurrentWithoutThreads._RunIt ()
46329,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, ConcurrentWithoutThreads) {
  ConcurrentTest test;
  Random rnd(test::RandomSeed());
  for (int i = 0; i < 10000; i++) {
    test.ReadStep(&rnd);
    test.WriteStep(&rnd);
  }
}",1,40,db\skiplist_test.cc,leveldb._Test_ConcurrentWithoutThreads._Run,,false,288,295,_Run,,,17,void leveldb._Test_ConcurrentWithoutThreads._Run ()
46372,METHOD,leveldb.TestState,TYPE_DECL,"explicit TestState(int s)
      : seed_(s),
        quit_flag_(NULL),
        state_(STARTING),
        state_cv_(&mu_) {}",3,26,db\skiplist_test.cc,leveldb.TestState.TestState,,false,309,313,TestState,,,5,ANY leveldb.TestState.TestState (int)
46377,METHOD,leveldb.TestState,TYPE_DECL,"void Wait(ReaderState s) {
    mu_.Lock();
    while (state_ != s) {
      state_cv_.Wait();
    }
    mu_.Unlock();
  }",3,3,db\skiplist_test.cc,leveldb.TestState.Wait,,false,315,321,Wait,,,6,void leveldb.TestState.Wait (ReaderState)
46399,METHOD,leveldb.TestState,TYPE_DECL,"void Change(ReaderState s) {
    mu_.Lock();
    state_ = s;
    state_cv_.Signal();
    mu_.Unlock();
  }",3,3,db\skiplist_test.cc,leveldb.TestState.Change,,false,323,328,Change,,,7,void leveldb.TestState.Change (ReaderState)
46422,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"static void ConcurrentReader(void* arg) {
  TestState* state = reinterpret_cast<TestState*>(arg);
  Random rnd(state->seed_);
  int64_t reads = 0;
  state->Change(TestState::RUNNING);
  while (!state->quit_flag_.Acquire_Load()) {
    state->t_.ReadStep(&rnd);
    ++reads;
  }
  state->Change(TestState::DONE);
}",1,1,db\skiplist_test.cc,leveldb.ConcurrentReader,,false,336,346,ConcurrentReader,,,19,void leveldb.ConcurrentReader (void*)
46475,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"static void RunConcurrent(int run) {
  const int seed = test::RandomSeed() + (run * 100);
  Random rnd(seed);
  const int N = 1000;
  const int kSize = 1000;
  for (int i = 0; i < N; i++) {
    if ((i % 100) == 0) {
      fprintf(stderr, ""Run %d of %d\n"", i, N);
    }
    TestState state(seed + 1);
    Env::Default()->Schedule(ConcurrentReader, &state);
    state.Wait(TestState::RUNNING);
    for (int i = 0; i < kSize; i++) {
      state.t_.WriteStep(&rnd);
    }
    state.quit_flag_.Release_Store(&state);  // Any non-NULL arg will do
    state.Wait(TestState::DONE);
  }
}",1,1,db\skiplist_test.cc,leveldb.RunConcurrent,,false,348,366,RunConcurrent,,,20,void leveldb.RunConcurrent (int)
46584,METHOD,leveldb._Test_Concurrent1,TYPE_DECL,void void ();,1,27,db\skiplist_test.cc,leveldb._Test_Concurrent1._Run,,false,368,368,_Run,,,1,void leveldb._Test_Concurrent1._Run ()
46588,METHOD,leveldb._Test_Concurrent1,TYPE_DECL,"TEST(SkipTest, Concurrent1)",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent1._RunIt,,false,368,368,_RunIt,,,2,void leveldb._Test_Concurrent1._RunIt ()
46612,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, Concurrent1) { RunConcurrent(1); }",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent1._Run,,false,368,368,_Run,,,24,void leveldb._Test_Concurrent1._Run ()
46619,METHOD,leveldb._Test_Concurrent2,TYPE_DECL,void void ();,1,27,db\skiplist_test.cc,leveldb._Test_Concurrent2._Run,,false,369,369,_Run,,,1,void leveldb._Test_Concurrent2._Run ()
46623,METHOD,leveldb._Test_Concurrent2,TYPE_DECL,"TEST(SkipTest, Concurrent2)",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent2._RunIt,,false,369,369,_RunIt,,,2,void leveldb._Test_Concurrent2._RunIt ()
46647,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, Concurrent2) { RunConcurrent(2); }",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent2._Run,,false,369,369,_Run,,,28,void leveldb._Test_Concurrent2._Run ()
46654,METHOD,leveldb._Test_Concurrent3,TYPE_DECL,void void ();,1,27,db\skiplist_test.cc,leveldb._Test_Concurrent3._Run,,false,370,370,_Run,,,1,void leveldb._Test_Concurrent3._Run ()
46658,METHOD,leveldb._Test_Concurrent3,TYPE_DECL,"TEST(SkipTest, Concurrent3)",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent3._RunIt,,false,370,370,_RunIt,,,2,void leveldb._Test_Concurrent3._RunIt ()
46682,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, Concurrent3) { RunConcurrent(3); }",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent3._Run,,false,370,370,_Run,,,32,void leveldb._Test_Concurrent3._Run ()
46689,METHOD,leveldb._Test_Concurrent4,TYPE_DECL,void void ();,1,27,db\skiplist_test.cc,leveldb._Test_Concurrent4._Run,,false,371,371,_Run,,,1,void leveldb._Test_Concurrent4._Run ()
46693,METHOD,leveldb._Test_Concurrent4,TYPE_DECL,"TEST(SkipTest, Concurrent4)",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent4._RunIt,,false,371,371,_RunIt,,,2,void leveldb._Test_Concurrent4._RunIt ()
46717,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, Concurrent4) { RunConcurrent(4); }",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent4._Run,,false,371,371,_Run,,,36,void leveldb._Test_Concurrent4._Run ()
46724,METHOD,leveldb._Test_Concurrent5,TYPE_DECL,void void ();,1,27,db\skiplist_test.cc,leveldb._Test_Concurrent5._Run,,false,372,372,_Run,,,1,void leveldb._Test_Concurrent5._Run ()
46728,METHOD,leveldb._Test_Concurrent5,TYPE_DECL,"TEST(SkipTest, Concurrent5)",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent5._RunIt,,false,372,372,_RunIt,,,2,void leveldb._Test_Concurrent5._RunIt ()
46752,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"TEST(SkipTest, Concurrent5) { RunConcurrent(5); }",1,27,db\skiplist_test.cc,leveldb._Test_Concurrent5._Run,,false,372,372,_Run,,,40,void leveldb._Test_Concurrent5._Run ()
46758,METHOD,db\skiplist_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\skiplist_test.cc,main,,false,376,378,main,,,2,"int main (int,char**)"
46778,METHOD,db\snapshot.hpp:<global>,TYPE_DECL,<global>,1,1,db\snapshot.hpp,db\snapshot.hpp:<global>,,false,1,67,<global>,,,1,
46789,METHOD,leveldb.SnapshotList,TYPE_DECL,"SnapshotList() {
    list_.prev_ = &list_;
    list_.next_ = &list_;
  }",3,3,db\snapshot.hpp,leveldb.SnapshotList.SnapshotList,,false,33,36,SnapshotList,,,1,ANY leveldb.SnapshotList.SnapshotList ()
46805,METHOD,leveldb.SnapshotList,TYPE_DECL,bool empty() const { return list_.next_ == &list_; },3,54,db\snapshot.hpp,leveldb.SnapshotList.empty,,false,38,38,empty,,,2,bool leveldb.SnapshotList.empty ()
46816,METHOD,leveldb.SnapshotList,TYPE_DECL,SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; },3,72,db\snapshot.hpp,leveldb.SnapshotList.oldest,,false,39,39,oldest,,,3,SnapshotImpl leveldb.SnapshotList.oldest ()
46827,METHOD,leveldb.SnapshotList,TYPE_DECL,SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; },3,72,db\snapshot.hpp,leveldb.SnapshotList.newest,,false,40,40,newest,,,4,SnapshotImpl leveldb.SnapshotList.newest ()
46838,METHOD,leveldb.SnapshotList,TYPE_DECL,"const SnapshotImpl* New(SequenceNumber seq) {
    SnapshotImpl* s = new SnapshotImpl;
    s->number_ = seq;
    s->list_ = this;
    s->next_ = &list_;
    s->prev_ = list_.prev_;
    s->prev_->next_ = s;
    s->next_->prev_ = s;
    return s;
  }",3,3,db\snapshot.hpp,leveldb.SnapshotList.New,,false,42,51,New,,,5,SnapshotImpl leveldb.SnapshotList.New (SequenceNumber)
46887,METHOD,leveldb.SnapshotList,TYPE_DECL,"void Delete(const SnapshotImpl* s) {
    assert(s->list_ == this);
    s->prev_->next_ = s->next_;
    s->next_->prev_ = s->prev_;
    delete s;
  }",3,3,db\snapshot.hpp,leveldb.SnapshotList.Delete,,false,53,58,Delete,,,6,void leveldb.SnapshotList.Delete (SnapshotImpl*)
46932,METHOD,db\table_cache.cc:<global>,TYPE_DECL,<global>,1,1,db\table_cache.cc,db\table_cache.cc:<global>,,false,1,127,<global>,,,1,
46938,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"static void DeleteEntry(const Slice& key, void* value) {
  TableAndFile* tf = reinterpret_cast<TableAndFile*>(value);
  delete tf->table;
  delete tf->file;
  delete tf;
}",1,1,db\table_cache.cc,leveldb.DeleteEntry,,false,19,24,DeleteEntry,,,2,"void leveldb.DeleteEntry (Slice,void*)"
46960,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"static void UnrefEntry(void* arg1, void* arg2) {
  Cache* cache = reinterpret_cast<Cache*>(arg1);
  Cache::Handle* h = reinterpret_cast<Cache::Handle*>(arg2);
  cache->Release(h);
}",1,1,db\table_cache.cc,leveldb.UnrefEntry,,false,26,30,UnrefEntry,,,3,"void leveldb.UnrefEntry (void*,void*)"
46983,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"TableCache::TableCache(const std::string& dbname,
                       const Options* options,
                       int entries)
    : env_(options->env),
      dbname_(dbname),
      options_(options),
      cache_(NewLRUCache(entries)) {
}",1,1,db\table_cache.cc,leveldb.TableCache.TableCache,,false,32,39,TableCache,,,4,"ANY leveldb.TableCache.TableCache (ANY,Options*,int)"
46990,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"TableCache::~TableCache() {
  delete cache_;
}",1,1,db\table_cache.cc,leveldb.TableCache.~TableCache,,false,41,43,~TableCache,,,5,ANY leveldb.TableCache.~TableCache ()
46996,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,
                             Cache::Handle** handle) {
  Status s;
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  Slice key(buf, sizeof(buf));
  *handle = cache_->Lookup(key);
  if (*handle == NULL) {
    std::string fname = TableFileName(dbname_, file_number);
    RandomAccessFile* file = NULL;
    Table* table = NULL;
    s = env_->NewRandomAccessFile(fname, &file);
    if (!s.ok()) {
      std::string old_fname = SSTTableFileName(dbname_, file_number);
      if (env_->NewRandomAccessFile(old_fname, &file).ok()) {
        s = Status::OK();
      }
    }
    if (s.ok()) {
      s = Table::Open(*options_, file, file_size, &table);
    }

    if (!s.ok()) {
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
    } else {
      TableAndFile* tf = new TableAndF...",1,1,db\table_cache.cc,leveldb.TableCache.FindTable,,false,45,80,FindTable,,,6,"Status leveldb.TableCache.FindTable (uint64_t,uint64_t,ANY**)"
47143,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"Iterator* TableCache::NewIterator(const ReadOptions& options,
                                  uint64_t file_number,
                                  uint64_t file_size,
                                  Table** tableptr) {
  if (tableptr != NULL) {
    *tableptr = NULL;
  }

  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (!s.ok()) {
    return NewErrorIterator(s);
  }

  Table* table = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
  Iterator* result = table->NewIterator(options);
  result->RegisterCleanup(&UnrefEntry, cache_, handle);
  if (tableptr != NULL) {
    *tableptr = table;
  }
  return result;
}",1,1,db\table_cache.cc,leveldb.TableCache.NewIterator,,false,82,103,NewIterator,,,7,"Iterator leveldb.TableCache.NewIterator (ReadOptions,uint64_t,uint64_t,Table**)"
47221,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"Status TableCache::Get(const ReadOptions& options,
                       uint64_t file_number,
                       uint64_t file_size,
                       const Slice& k,
                       void* arg,
                       void (*saver)(void*, const Slice&, const Slice&)) {
  Cache::Handle* handle = NULL;
  Status s = FindTable(file_number, file_size, &handle);
  if (s.ok()) {
    Table* t = reinterpret_cast<TableAndFile*>(cache_->Value(handle))->table;
    s = t->InternalGet(options, k, arg, saver);
    cache_->Release(handle);
  }
  return s;
}",1,1,db\table_cache.cc,leveldb.TableCache.Get,,false,105,119,Get,,,8,"Status leveldb.TableCache.Get (ReadOptions,uint64_t,uint64_t,Slice,void*,void)"
47278,METHOD,db\table_cache.cc:<global>,TYPE_DECL,"void TableCache::Evict(uint64_t file_number) {
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  cache_->Erase(Slice(buf, sizeof(buf)));
}",1,1,db\table_cache.cc,leveldb.TableCache.Evict,,false,121,125,Evict,,,9,void leveldb.TableCache.Evict (uint64_t)
47310,METHOD,db\table_cache.hpp:<global>,TYPE_DECL,<global>,1,22,db\table_cache.hpp,db\table_cache.hpp:<global>,,false,1,61,<global>,,,1,
47315,METHOD,leveldb.TableCache,TYPE_DECL,"TableCache(const std::string& dbname, const Options* options, int entries);",3,76,db\table_cache.hpp,leveldb.TableCache.TableCache,,false,23,23,TableCache,,,1,"ANY leveldb.TableCache.TableCache (ANY,Options*,int)"
47322,METHOD,leveldb.TableCache,TYPE_DECL,~TableCache();,3,15,db\table_cache.hpp,leveldb.TableCache.~TableCache,,false,24,24,~TableCache,,,2,ANY leveldb.TableCache.~TableCache ()
47326,METHOD,leveldb.TableCache,TYPE_DECL,"Iterator* NewIterator(const ReadOptions& options,
                        uint64_t file_number,
                        uint64_t file_size,
                        Table** tableptr = NULL);",11,48,db\table_cache.hpp,leveldb.TableCache.NewIterator,,false,33,36,NewIterator,,,3,"Iterator* leveldb.TableCache.NewIterator (ReadOptions,uint64_t,uint64_t,Table**)"
47334,METHOD,leveldb.TableCache,TYPE_DECL,"Status Get(const ReadOptions& options,
             uint64_t file_number,
             uint64_t file_size,
             const Slice& k,
             void* arg,
             void (*handle_result)(void*, const Slice&, const Slice&));",10,70,db\table_cache.hpp,leveldb.TableCache.Get,,false,40,45,Get,,,4,"Status leveldb.TableCache.Get (ReadOptions,uint64_t,uint64_t,Slice,void*,void)"
47344,METHOD,leveldb.TableCache,TYPE_DECL,void Evict(uint64_t file_number);,8,34,db\table_cache.hpp,leveldb.TableCache.Evict,,false,48,48,Evict,,,5,void leveldb.TableCache.Evict (uint64_t)
47353,METHOD,leveldb.TableCache,TYPE_DECL,"Status FindTable(uint64_t file_number, uint64_t file_size, Cache::Handle**);",10,77,db\table_cache.hpp,leveldb.TableCache.FindTable,,false,56,56,FindTable,,,10,"Status leveldb.TableCache.FindTable (uint64_t,uint64_t,ANY**)"
47369,METHOD,db\version_edit.cc:<global>,TYPE_DECL,<global>,1,1,db\version_edit.cc,db\version_edit.cc:<global>,,false,1,266,<global>,,,1,
47381,METHOD,<empty>,<empty>,<empty>,1,,db\version_edit.cc,leveldb.Tag:<clinit>,,false,14,,<clinit>,,,9,
47409,METHOD,db\version_edit.cc:<global>,TYPE_DECL,"void VersionEdit::Clear() {
  comparator_.clear();
  log_number_ = 0;
  prev_log_number_ = 0;
  last_sequence_ = 0;
  next_file_number_ = 0;
  has_comparator_ = false;
  has_log_number_ = false;
  has_prev_log_number_ = false;
  has_next_file_number_ = false;
  has_last_sequence_ = false;
  deleted_files_.clear();
  new_files_.clear();
}",1,1,db\version_edit.cc,leveldb.VersionEdit.Clear,,false,26,39,Clear,,,2,void leveldb.VersionEdit.Clear ()
47452,METHOD,db\version_edit.cc:<global>,TYPE_DECL,"void VersionEdit::EncodeTo(std::string* dst) const {
  if (has_comparator_) {
    PutVarint32(dst, kComparator);
    PutLengthPrefixedSlice(dst, comparator_);
  }
  if (has_log_number_) {
    PutVarint32(dst, kLogNumber);
    PutVarint64(dst, log_number_);
  }
  if (has_prev_log_number_) {
    PutVarint32(dst, kPrevLogNumber);
    PutVarint64(dst, prev_log_number_);
  }
  if (has_next_file_number_) {
    PutVarint32(dst, kNextFileNumber);
    PutVarint64(dst, next_file_number_);
  }
  if (has_last_sequence_) {
    PutVarint32(dst, kLastSequence);
    PutVarint64(dst, last_sequence_);
  }

  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    PutVarint32(dst, kCompactPointer);
    PutVarint32(dst, compact_pointers_[i].first);  // level
    PutLengthPrefixedSlice(dst, compact_pointers_[i].second.Encode());
  }

  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    PutVarint32(dst, kDeletedFile);
    PutVa...",1,1,db\version_edit.cc,leveldb.VersionEdit.EncodeTo,,false,41,86,EncodeTo,,,3,void leveldb.VersionEdit.EncodeTo (ANY*)
47627,METHOD,db\version_edit.cc:<global>,TYPE_DECL,"static bool GetInternalKey(Slice* input, InternalKey* dst) {
  Slice str;
  if (GetLengthPrefixedSlice(input, &str)) {
    dst->DecodeFrom(str);
    return true;
  } else {
    return false;
  }
}",1,1,db\version_edit.cc,leveldb.GetInternalKey,,false,88,96,GetInternalKey,,,4,"bool leveldb.GetInternalKey (Slice*,InternalKey*)"
47651,METHOD,db\version_edit.cc:<global>,TYPE_DECL,"static bool GetLevel(Slice* input, int* level) {
  uint32_t v;
  if (GetVarint32(input, &v) &&
      v < config::kNumLevels) {
    *level = v;
    return true;
  } else {
    return false;
  }
}",1,1,db\version_edit.cc,leveldb.GetLevel,,false,98,107,GetLevel,,,5,"bool leveldb.GetLevel (Slice*,int*)"
47680,METHOD,db\version_edit.cc:<global>,TYPE_DECL,"Status VersionEdit::DecodeFrom(const Slice& src) {
  Clear();
  Slice input = src;
  const char* msg = NULL;
  uint32_t tag;

  // Temporary storage for parsing
  int level;
  uint64_t number;
  FileMetaData f;
  Slice str;
  InternalKey key;

  while (msg == NULL && GetVarint32(&input, &tag)) {
    switch (tag) {
      case kComparator:
        if (GetLengthPrefixedSlice(&input, &str)) {
          comparator_ = str.ToString();
          has_comparator_ = true;
        } else {
          msg = ""comparator name"";
        }
        break;

      case kLogNumber:
        if (GetVarint64(&input, &log_number_)) {
          has_log_number_ = true;
        } else {
          msg = ""log number"";
        }
        break;

      case kPrevLogNumber:
        if (GetVarint64(&input, &prev_log_number_)) {
          has_prev_log_number_ = true;
        } else {
          msg = ""previous log number"";
        }
        break;

      case kNextFileNumber:
        if (GetVarint64(&input, &next_file_n...",1,1,db\version_edit.cc,leveldb.VersionEdit.DecodeFrom,,false,109,210,DecodeFrom,,,6,Status leveldb.VersionEdit.DecodeFrom (Slice)
47964,METHOD,db\version_edit.cc:<global>,TYPE_DECL,"std::string VersionEdit::DebugString() const {
  std::string r;
  r.append(""VersionEdit {"");
  if (has_comparator_) {
    r.append(""\n  Comparator: "");
    r.append(comparator_);
  }
  if (has_log_number_) {
    r.append(""\n  LogNumber: "");
    AppendNumberTo(&r, log_number_);
  }
  if (has_prev_log_number_) {
    r.append(""\n  PrevLogNumber: "");
    AppendNumberTo(&r, prev_log_number_);
  }
  if (has_next_file_number_) {
    r.append(""\n  NextFile: "");
    AppendNumberTo(&r, next_file_number_);
  }
  if (has_last_sequence_) {
    r.append(""\n  LastSeq: "");
    AppendNumberTo(&r, last_sequence_);
  }
  for (size_t i = 0; i < compact_pointers_.size(); i++) {
    r.append(""\n  CompactPointer: "");
    AppendNumberTo(&r, compact_pointers_[i].first);
    r.append("" "");
    r.append(compact_pointers_[i].second.DebugString());
  }
  for (DeletedFileSet::const_iterator iter = deleted_files_.begin();
       iter != deleted_files_.end();
       ++iter) {
    r.append(""\n  DeleteFile: "");
    ...",1,1,db\version_edit.cc,leveldb.VersionEdit.DebugString,,false,212,264,DebugString,,,7,string leveldb.VersionEdit.DebugString ()
48226,METHOD,db\version_edit.hpp:<global>,TYPE_DECL,<global>,1,18,db\version_edit.hpp,db\version_edit.hpp:<global>,,false,1,107,<global>,,,1,
48237,METHOD,leveldb.FileMetaData,TYPE_DECL,"FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0) { }",3,68,db\version_edit.hpp,leveldb.FileMetaData.FileMetaData,,false,25,25,FileMetaData,,,7,ANY leveldb.FileMetaData.FileMetaData ()
48242,METHOD,leveldb.VersionEdit,TYPE_DECL,VersionEdit() { Clear(); },3,28,db\version_edit.hpp,leveldb.VersionEdit.VersionEdit,,false,30,30,VersionEdit,,,1,ANY leveldb.VersionEdit.VersionEdit ()
48247,METHOD,leveldb.VersionEdit,TYPE_DECL,~VersionEdit() { },3,20,db\version_edit.hpp,leveldb.VersionEdit.~VersionEdit,,false,31,31,~VersionEdit,,,2,ANY leveldb.VersionEdit.~VersionEdit ()
48251,METHOD,leveldb.VersionEdit,TYPE_DECL,void Clear();,8,14,db\version_edit.hpp,leveldb.VersionEdit.Clear,,false,33,33,Clear,,,3,void leveldb.VersionEdit.Clear ()
48255,METHOD,leveldb.VersionEdit,TYPE_DECL,"void SetComparatorName(const Slice& name) {
    has_comparator_ = true;
    comparator_ = name.ToString();
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.SetComparatorName,,false,35,38,SetComparatorName,,,4,void leveldb.VersionEdit.SetComparatorName (Slice)
48269,METHOD,leveldb.VersionEdit,TYPE_DECL,"void SetLogNumber(uint64_t num) {
    has_log_number_ = true;
    log_number_ = num;
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.SetLogNumber,,false,39,42,SetLogNumber,,,5,void leveldb.VersionEdit.SetLogNumber (uint64_t)
48280,METHOD,leveldb.VersionEdit,TYPE_DECL,"void SetPrevLogNumber(uint64_t num) {
    has_prev_log_number_ = true;
    prev_log_number_ = num;
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.SetPrevLogNumber,,false,43,46,SetPrevLogNumber,,,6,void leveldb.VersionEdit.SetPrevLogNumber (uint64_t)
48291,METHOD,leveldb.VersionEdit,TYPE_DECL,"void SetNextFile(uint64_t num) {
    has_next_file_number_ = true;
    next_file_number_ = num;
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.SetNextFile,,false,47,50,SetNextFile,,,7,void leveldb.VersionEdit.SetNextFile (uint64_t)
48302,METHOD,leveldb.VersionEdit,TYPE_DECL,"void SetLastSequence(SequenceNumber seq) {
    has_last_sequence_ = true;
    last_sequence_ = seq;
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.SetLastSequence,,false,51,54,SetLastSequence,,,8,void leveldb.VersionEdit.SetLastSequence (SequenceNumber)
48313,METHOD,leveldb.VersionEdit,TYPE_DECL,"void SetCompactPointer(int level, const InternalKey& key) {
    compact_pointers_.push_back(std::make_pair(level, key));
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.SetCompactPointer,,false,55,57,SetCompactPointer,,,9,"void leveldb.VersionEdit.SetCompactPointer (int,InternalKey)"
48329,METHOD,leveldb.VersionEdit,TYPE_DECL,"void AddFile(int level, uint64_t file,
               uint64_t file_size,
               const InternalKey& smallest,
               const InternalKey& largest) {
    FileMetaData f;
    f.number = file;
    f.file_size = file_size;
    f.smallest = smallest;
    f.largest = largest;
    new_files_.push_back(std::make_pair(level, f));
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.AddFile,,false,62,72,AddFile,,,10,"void leveldb.VersionEdit.AddFile (int,uint64_t,uint64_t,InternalKey,InternalKey)"
48369,METHOD,leveldb.VersionEdit,TYPE_DECL,"void DeleteFile(int level, uint64_t file) {
    deleted_files_.insert(std::make_pair(level, file));
  }",3,3,db\version_edit.hpp,leveldb.VersionEdit.DeleteFile,,false,75,77,DeleteFile,,,11,"void leveldb.VersionEdit.DeleteFile (int,uint64_t)"
48385,METHOD,leveldb.VersionEdit,TYPE_DECL,void EncodeTo(std::string* dst) const;,8,39,db\version_edit.hpp,leveldb.VersionEdit.EncodeTo,,false,79,79,EncodeTo,,,12,void leveldb.VersionEdit.EncodeTo (ANY*)
48390,METHOD,leveldb.VersionEdit,TYPE_DECL,Status DecodeFrom(const Slice& src);,10,37,db\version_edit.hpp,leveldb.VersionEdit.DecodeFrom,,false,80,80,DecodeFrom,,,13,Status leveldb.VersionEdit.DecodeFrom (Slice)
48395,METHOD,leveldb.VersionEdit,TYPE_DECL,std::string DebugString() const;,15,33,db\version_edit.hpp,leveldb.VersionEdit.DebugString,,false,82,82,DebugString,,,14,ANY leveldb.VersionEdit.DebugString ()
48421,METHOD,db\version_edit_test.cc:<global>,TYPE_DECL,<global>,1,1,db\version_edit_test.cc,db\version_edit_test.cc:<global>,,false,1,46,<global>,,,1,
48424,METHOD,db\version_edit_test.cc:<global>,TYPE_DECL,"static void TestEncodeDecode(const VersionEdit& edit) {
  std::string encoded, encoded2;
  edit.EncodeTo(&encoded);
  VersionEdit parsed;
  Status s = parsed.DecodeFrom(encoded);
  ASSERT_TRUE(s.ok()) << s.ToString();
  parsed.EncodeTo(&encoded2);
  ASSERT_EQ(encoded, encoded2);
}",1,2,db\version_edit_test.cc,leveldb.TestEncodeDecode,,false,10,18,TestEncodeDecode,,,1,void leveldb.TestEncodeDecode (VersionEdit)
48498,METHOD,leveldb._Test_EncodeDecode,TYPE_DECL,void void ();,1,35,db\version_edit_test.cc,leveldb._Test_EncodeDecode._Run,,false,22,22,_Run,,,1,void leveldb._Test_EncodeDecode._Run ()
48502,METHOD,leveldb._Test_EncodeDecode,TYPE_DECL,"TEST(VersionEditTest, EncodeDecode)",1,35,db\version_edit_test.cc,leveldb._Test_EncodeDecode._RunIt,,false,22,22,_RunIt,,,2,void leveldb._Test_EncodeDecode._RunIt ()
48526,METHOD,db\version_edit_test.cc:<global>,TYPE_DECL,"TEST(VersionEditTest, EncodeDecode) {
  static const uint64_t kBig = 1ull << 50;

  VersionEdit edit;
  for (int i = 0; i < 4; i++) {
    TestEncodeDecode(edit);
    edit.AddFile(3, kBig + 300 + i, kBig + 400 + i,
                 InternalKey(""foo"", kBig + 500 + i, kTypeValue),
                 InternalKey(""zoo"", kBig + 600 + i, kTypeDeletion));
    edit.DeleteFile(4, kBig + 700 + i);
    edit.SetCompactPointer(i, InternalKey(""x"", kBig + 900 + i, kTypeValue));
  }

  edit.SetComparatorName(""foo"");
  edit.SetLogNumber(kBig + 100);
  edit.SetNextFile(kBig + 200);
  edit.SetLastSequence(kBig + 1000);
  TestEncodeDecode(edit);
}",1,35,db\version_edit_test.cc,leveldb._Test_EncodeDecode._Run,,false,22,40,_Run,,,6,void leveldb._Test_EncodeDecode._Run ()
48633,METHOD,db\version_edit_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\version_edit_test.cc,main,,false,44,46,main,,,2,"int main (int,char**)"
48677,METHOD,db\version_set.cc:<global>,TYPE_DECL,<global>,1,1,db\version_set.cc,db\version_set.cc:<global>,,false,1,1535,<global>,,,1,
48680,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static int TargetFileSize(const Options* options) {
  return options->max_file_size;
}",1,1,db\version_set.cc,leveldb.TargetFileSize,,false,23,25,TargetFileSize,,,1,int leveldb.TargetFileSize (Options*)
48689,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static int64_t MaxGrandParentOverlapBytes(const Options* options) {
  return 10 * TargetFileSize(options);
}",1,1,db\version_set.cc,leveldb.MaxGrandParentOverlapBytes,,false,29,31,MaxGrandParentOverlapBytes,,,2,int64_t leveldb.MaxGrandParentOverlapBytes (Options*)
48699,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {
  return 25 * TargetFileSize(options);
}",1,1,db\version_set.cc,leveldb.ExpandedCompactionByteSizeLimit,,false,36,38,ExpandedCompactionByteSizeLimit,,,3,int64_t leveldb.ExpandedCompactionByteSizeLimit (Options*)
48709,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static double MaxBytesForLevel(const Options* options, int level) {
  // Note: the result for level zero is not really used since we set
  // the level-0 compaction threshold based on number of files.

  // Result for both level-0 and level-1
  double result = 10. * 1048576.0;
  while (level > 1) {
    result *= 10;
    level--;
  }
  return result;
}",1,1,db\version_set.cc,leveldb.MaxBytesForLevel,,false,40,51,MaxBytesForLevel,,,4,"double leveldb.MaxBytesForLevel (Options*,int)"
48733,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static uint64_t MaxFileSizeForLevel(const Options* options, int level) {
  // We could vary per level to reduce number of files?
  return TargetFileSize(options);
}",1,1,db\version_set.cc,leveldb.MaxFileSizeForLevel,,false,53,56,MaxFileSizeForLevel,,,5,"uint64_t leveldb.MaxFileSizeForLevel (Options*,int)"
48742,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {
  int64_t sum = 0;
  for (size_t i = 0; i < files.size(); i++) {
    sum += files[i]->file_size;
  }
  return sum;
}",1,1,db\version_set.cc,leveldb.TotalFileSize,,false,58,64,TotalFileSize,,,6,int64_t leveldb.TotalFileSize (ANY)
48775,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Version::~Version() {
  assert(refs_ == 0);

  // Remove from linked list
  prev_->next_ = next_;
  next_->prev_ = prev_;

  // Drop references to files
  for (int level = 0; level < config::kNumLevels; level++) {
    for (size_t i = 0; i < files_[level].size(); i++) {
      FileMetaData* f = files_[level][i];
      assert(f->refs > 0);
      f->refs--;
      if (f->refs <= 0) {
        delete f;
      }
    }
  }
}",1,1,db\version_set.cc,leveldb.Version.~Version,,false,66,84,~Version,,,7,ANY leveldb.Version.~Version ()
48851,METHOD,db\version_set.cc:<global>,TYPE_DECL,"int FindFile(const InternalKeyComparator& icmp,
             const std::vector<FileMetaData*>& files,
             const Slice& key) {
  uint32_t left = 0;
  uint32_t right = files.size();
  while (left < right) {
    uint32_t mid = (left + right) / 2;
    const FileMetaData* f = files[mid];
    if (icmp.InternalKeyComparator::Compare(f->largest.Encode(), key) < 0) {
      // Key at ""mid.largest"" is < ""target"".  Therefore all
      // files at or before ""mid"" are uninteresting.
      left = mid + 1;
    } else {
      // Key at ""mid.largest"" is >= ""target"".  Therefore all files
      // after ""mid"" are uninteresting.
      right = mid;
    }
  }
  return right;
}",1,1,db\version_set.cc,leveldb.FindFile,,false,86,105,FindFile,,,8,"int leveldb.FindFile (InternalKeyComparator,ANY,Slice)"
48915,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static bool AfterFile(const Comparator* ucmp,
                      const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs before all keys and is therefore never after *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->largest.user_key()) > 0);
}",1,1,db\version_set.cc,leveldb.AfterFile,,false,107,112,AfterFile,,,9,"bool leveldb.AfterFile (Comparator*,Slice*,FileMetaData*)"
48941,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static bool BeforeFile(const Comparator* ucmp,
                       const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs after all keys and is therefore never before *f
  return (user_key != NULL &&
          ucmp->Compare(*user_key, f->smallest.user_key()) < 0);
}",1,1,db\version_set.cc,leveldb.BeforeFile,,false,114,119,BeforeFile,,,10,"bool leveldb.BeforeFile (Comparator*,Slice*,FileMetaData*)"
48967,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool SomeFileOverlapsRange(
    const InternalKeyComparator& icmp,
    bool disjoint_sorted_files,
    const std::vector<FileMetaData*>& files,
    const Slice* smallest_user_key,
    const Slice* largest_user_key) {
  const Comparator* ucmp = icmp.user_comparator();
  if (!disjoint_sorted_files) {
    // Need to check against all files
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      if (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        // No overlap
      } else {
        return true;  // Overlap
      }
    }
    return false;
  }

  // Binary search over file list
  uint32_t index = 0;
  if (smallest_user_key != NULL) {
    // Find the earliest possible internal key for smallest_user_key
    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }

  if (index >= files.size()) {
    // beginning of range is afte...",1,1,db\version_set.cc,leveldb.SomeFileOverlapsRange,,false,121,156,SomeFileOverlapsRange,,,11,"bool leveldb.SomeFileOverlapsRange (InternalKeyComparator,bool,ANY,Slice*,Slice*)"
49068,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"LevelFileNumIterator(const InternalKeyComparator& icmp,
                       const std::vector<FileMetaData*>* flist)
      : icmp_(icmp),
        flist_(flist),
        index_(flist->size()) {        // Marks as invalid
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.LevelFileNumIterator,,false,165,170,LevelFileNumIterator,,,1,"ANY leveldb.LevelFileNumIterator.LevelFileNumIterator (InternalKeyComparator,ANY*)"
49074,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"virtual bool Valid() const {
    return index_ < flist_->size();
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.Valid,,false,171,173,Valid,,,2,bool leveldb.LevelFileNumIterator.Valid ()
49085,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"virtual void Seek(const Slice& target) {
    index_ = FindFile(icmp_, *flist_, target);
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.Seek,,false,174,176,Seek,,,3,void leveldb.LevelFileNumIterator.Seek (Slice)
49097,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,virtual void SeekToFirst() { index_ = 0; },3,44,db\version_set.cc,leveldb.LevelFileNumIterator.SeekToFirst,,false,177,177,SeekToFirst,,,4,void leveldb.LevelFileNumIterator.SeekToFirst ()
49104,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"virtual void SeekToLast() {
    index_ = flist_->empty() ? 0 : flist_->size() - 1;
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.SeekToLast,,false,178,180,SeekToLast,,,5,void leveldb.LevelFileNumIterator.SeekToLast ()
49122,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"virtual void Next() {
    assert(Valid());
    index_++;
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.Next,,false,181,184,Next,,,6,void leveldb.LevelFileNumIterator.Next ()
49130,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"virtual void Prev() {
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_->size();  // Marks as invalid
    } else {
      index_--;
    }
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.Prev,,false,185,192,Prev,,,7,void leveldb.LevelFileNumIterator.Prev ()
49151,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"Slice key() const {
    assert(Valid());
    return (*flist_)[index_]->largest.Encode();
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.key,,false,193,196,key,,,8,Slice leveldb.LevelFileNumIterator.key ()
49167,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,"Slice value() const {
    assert(Valid());
    EncodeFixed64(value_buf_, (*flist_)[index_]->number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]->file_size);
    return Slice(value_buf_, sizeof(value_buf_));
  }",3,3,db\version_set.cc,leveldb.LevelFileNumIterator.value,,false,197,202,value,,,9,Slice leveldb.LevelFileNumIterator.value ()
49196,METHOD,leveldb.LevelFileNumIterator,TYPE_DECL,virtual Status status() const { return Status::OK(); },3,56,db\version_set.cc,leveldb.LevelFileNumIterator.status,,false,203,203,status,,,10,Status leveldb.LevelFileNumIterator.status ()
49209,METHOD,<empty>,<empty>,<empty>,1,,db\version_set.cc,leveldb.LevelFileNumIterator:<clinit>,,false,163,,<clinit>,,,15,
49215,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static Iterator* GetFileIterator(void* arg,
                                 const ReadOptions& options,
                                 const Slice& file_value) {
  TableCache* cache = reinterpret_cast<TableCache*>(arg);
  if (file_value.size() != 16) {
    return NewErrorIterator(
        Status::Corruption(""FileReader invoked with unexpected value""));
  } else {
    return cache->NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}",1,1,db\version_set.cc,leveldb.GetFileIterator,,false,213,225,GetFileIterator,,,13,"Iterator leveldb.GetFileIterator (void*,ReadOptions,Slice)"
49263,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,
                                            int level) const {
  return NewTwoLevelIterator(
      new LevelFileNumIterator(vset_->icmp_, &files_[level]),
      &GetFileIterator, vset_->table_cache_, options);
}",1,1,db\version_set.cc,leveldb.Version.NewConcatenatingIterator,,false,227,232,NewConcatenatingIterator,,,14,"Iterator leveldb.Version.NewConcatenatingIterator (ReadOptions,int)"
49286,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Version::AddIterators(const ReadOptions& options,
                           std::vector<Iterator*>* iters) {
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i < files_[0].size(); i++) {
    iters->push_back(
        vset_->table_cache_->NewIterator(
            options, files_[0][i]->number, files_[0][i]->file_size));
  }

  // For levels > 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level < config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters->push_back(NewConcatenatingIterator(options, level));
    }
  }
}",1,1,db\version_set.cc,leveldb.Version.AddIterators,,false,234,251,AddIterators,,,15,"void leveldb.Version.AddIterators (ReadOptions,ANY*)"
49375,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {
  Saver* s = reinterpret_cast<Saver*>(arg);
  ParsedInternalKey parsed_key;
  if (!ParseInternalKey(ikey, &parsed_key)) {
    s->state = kCorrupt;
  } else {
    if (s->ucmp->Compare(parsed_key.user_key, s->user_key) == 0) {
      s->state = (parsed_key.type == kTypeValue) ? kFound : kDeleted;
      if (s->state == kFound) {
        s->value->assign(v.data(), v.size());
      }
    }
  }
}",1,1,db\version_set.cc,leveldb.SaveValue,,false,268,281,SaveValue,,,17,"void leveldb.SaveValue (void*,Slice,Slice)"
49452,METHOD,db\version_set.cc:<global>,TYPE_DECL,"static bool NewestFirst(FileMetaData* a, FileMetaData* b) {
  return a->number > b->number;
}",1,1,db\version_set.cc,leveldb.NewestFirst,,false,283,285,NewestFirst,,,18,"bool leveldb.NewestFirst (FileMetaData*,FileMetaData*)"
49466,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Version::ForEachOverlapping(Slice user_key, Slice internal_key,
                                 void* arg,
                                 bool (*func)(void*, int, FileMetaData*)) {
  // TODO(sanjay): Change Version::Get() to use this function.
  const Comparator* ucmp = vset_->icmp_.user_comparator();

  // Search level-0 in order from newest to oldest.
  std::vector<FileMetaData*> tmp;
  tmp.reserve(files_[0].size());
  for (uint32_t i = 0; i < files_[0].size(); i++) {
    FileMetaData* f = files_[0][i];
    if (ucmp->Compare(user_key, f->smallest.user_key()) >= 0 &&
        ucmp->Compare(user_key, f->largest.user_key()) <= 0) {
      tmp.push_back(f);
    }
  }
  if (!tmp.empty()) {
    std::sort(tmp.begin(), tmp.end(), NewestFirst);
    for (uint32_t i = 0; i < tmp.size(); i++) {
      if (!(*func)(arg, 0, tmp[i])) {
        return;
      }
    }
  }

  // Search other levels.
  for (int level = 1; level < config::kNumLevels; level++) {
    size_t num_files = files_[level...",1,1,db\version_set.cc,leveldb.Version.ForEachOverlapping,,false,287,330,ForEachOverlapping,,,19,"void leveldb.Version.ForEachOverlapping (Slice,Slice,void*,bool)"
49680,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Status Version::Get(const ReadOptions& options,
                    const LookupKey& k,
                    std::string* value,
                    GetStats* stats) {
  Slice ikey = k.internal_key();
  Slice user_key = k.user_key();
  const Comparator* ucmp = vset_->icmp_.user_comparator();
  Status s;

  stats->seek_file = NULL;
  stats->seek_file_level = -1;
  FileMetaData* last_file_read = NULL;
  int last_file_read_level = -1;

  // We can search level-by-level since entries never hop across
  // levels.  Therefore we are guaranteed that if we find data
  // in an smaller level, later levels are irrelevant.
  std::vector<FileMetaData*> tmp;
  FileMetaData* tmp2;
  for (int level = 0; level < config::kNumLevels; level++) {
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Get the list of files to search in this level
    FileMetaData* const* files = &files_[level][0];
    if (level == 0) {
      // Level-0 files may overlap each other.  Find a...",1,1,db\version_set.cc,leveldb.Version.Get,,false,332,429,Get,,,20,"Status leveldb.Version.Get (ReadOptions,LookupKey,ANY*,GetStats*)"
50062,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool Version::UpdateStats(const GetStats& stats) {
  FileMetaData* f = stats.seek_file;
  if (f != NULL) {
    f->allowed_seeks--;
    if (f->allowed_seeks <= 0 && file_to_compact_ == NULL) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }
  }
  return false;
}",1,1,db\version_set.cc,leveldb.Version.UpdateStats,,false,431,442,UpdateStats,,,21,bool leveldb.Version.UpdateStats (GetStats)
50105,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool Version::RecordReadSample(Slice internal_key) {
  ParsedInternalKey ikey;
  if (!ParseInternalKey(internal_key, &ikey)) {
    return false;
  }

  struct State {
    GetStats stats;  // Holds first matching file
    int matches;

    static bool Match(void* arg, int level, FileMetaData* f) {
      State* state = reinterpret_cast<State*>(arg);
      state->matches++;
      if (state->matches == 1) {
        // Remember first match.
        state->stats.seek_file = f;
        state->stats.seek_file_level = level;
      }
      // We can stop iterating once we have a second match.
      return state->matches < 2;
    }
  };

  State state;
  state.matches = 0;
  ForEachOverlapping(ikey.user_key, internal_key, &state, &State::Match);

  // Must have at least two matches since we want to merge across
  // files. But what if we have a single file that contains many
  // overwrites and deletions?  Should we have another mechanism for
  // finding such files?
  if (state.matches >= 2) ...",1,1,db\version_set.cc,leveldb.Version.RecordReadSample,,false,444,480,RecordReadSample,,,22,bool leveldb.Version.RecordReadSample (Slice)
50151,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Version::Ref() {
  ++refs_;
}",1,1,db\version_set.cc,leveldb.Version.Ref,,false,482,484,Ref,,,23,void leveldb.Version.Ref ()
50157,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Version::Unref() {
  assert(this != &vset_->dummy_versions_);
  assert(refs_ >= 1);
  --refs_;
  if (refs_ == 0) {
    delete this;
  }
}",1,1,db\version_set.cc,leveldb.Version.Unref,,false,486,493,Unref,,,24,void leveldb.Version.Unref ()
50181,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool Version::OverlapInLevel(int level,
                             const Slice* smallest_user_key,
                             const Slice* largest_user_key) {
  return SomeFileOverlapsRange(vset_->icmp_, (level > 0), files_[level],
                               smallest_user_key, largest_user_key);
}",1,1,db\version_set.cc,leveldb.Version.OverlapInLevel,,false,495,500,OverlapInLevel,,,25,"bool leveldb.Version.OverlapInLevel (int,Slice*,Slice*)"
50201,METHOD,db\version_set.cc:<global>,TYPE_DECL,"int Version::PickLevelForMemTableOutput(
    const Slice& smallest_user_key,
    const Slice& largest_user_key) {
  int level = 0;
  if (!OverlapInLevel(0, &smallest_user_key, &largest_user_key)) {
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast<ValueType>(0));
    std::vector<FileMetaData*> overlaps;
    while (level < config::kMaxMemCompactLevel) {
      if (OverlapInLevel(level + 1, &smallest_user_key, &largest_user_key)) {
        break;
      }
      if (level + 2 < config::kNumLevels) {
        // Check that file does not overlap too many grandparent bytes.
        GetOverlappingInputs(level + 2, &start, &limit, &overlaps);
        const int64_t sum = TotalFileSize(overlaps);
        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {
          break;
 ...",1,1,db\version_set.cc,leveldb.Version.PickLevelForMemTableOutput,,false,502,528,PickLevelForMemTableOutput,,,26,"int leveldb.Version.PickLevelForMemTableOutput (Slice,Slice)"
50288,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Version::GetOverlappingInputs(
    int level,
    const InternalKey* begin,
    const InternalKey* end,
    std::vector<FileMetaData*>* inputs) {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  inputs->clear();
  Slice user_begin, user_end;
  if (begin != NULL) {
    user_begin = begin->user_key();
  }
  if (end != NULL) {
    user_end = end->user_key();
  }
  const Comparator* user_cmp = vset_->icmp_.user_comparator();
  for (size_t i = 0; i < files_[level].size(); ) {
    FileMetaData* f = files_[level][i++];
    const Slice file_start = f->smallest.user_key();
    const Slice file_limit = f->largest.user_key();
    if (begin != NULL && user_cmp->Compare(file_limit, user_begin) < 0) {
      // ""f"" is completely before specified range; skip it
    } else if (end != NULL && user_cmp->Compare(file_start, user_end) > 0) {
      // ""f"" is completely after specified range; skip it
    } else {
      inputs->push_back(f);
      if (level == 0) {
        // Level-0 file...",1,1,db\version_set.cc,leveldb.Version.GetOverlappingInputs,,false,531,572,GetOverlappingInputs,,,27,"void leveldb.Version.GetOverlappingInputs (int,InternalKey*,InternalKey*,ANY*)"
50477,METHOD,db\version_set.cc:<global>,TYPE_DECL,"std::string Version::DebugString() const {
  std::string r;
  for (int level = 0; level < config::kNumLevels; level++) {
    // E.g.,
    //   --- level 1 ---
    //   17:123['a' .. 'd']
    //   20:43['e' .. 'g']
    r.append(""--- level "");
    AppendNumberTo(&r, level);
    r.append("" ---\n"");
    const std::vector<FileMetaData*>& files = files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      r.push_back(' ');
      AppendNumberTo(&r, files[i]->number);
      r.push_back(':');
      AppendNumberTo(&r, files[i]->file_size);
      r.append(""["");
      r.append(files[i]->smallest.DebugString());
      r.append("" .. "");
      r.append(files[i]->largest.DebugString());
      r.append(""]\n"");
    }
  }
  return r;
}",1,1,db\version_set.cc,leveldb.Version.DebugString,,false,574,598,DebugString,,,28,string leveldb.Version.DebugString ()
50601,METHOD,leveldb.Builder.BySmallestKey,TYPE_DECL,"bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator->Compare(f1->smallest, f2->smallest);
      if (r != 0) {
        return (r < 0);
      } else {
        // Break ties by file number
        return (f1->number < f2->number);
      }
    }",5,5,db\version_set.cc,leveldb.Builder.BySmallestKey.operator (),,false,609,617,operator (),,,2,"bool leveldb.Builder.BySmallestKey.operator () (FileMetaData*,FileMetaData*)"
50646,METHOD,leveldb.Builder,TYPE_DECL,"Builder(VersionSet* vset, Version* base)
      : vset_(vset),
        base_(base) {
    base_->Ref();
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      levels_[level].added_files = new FileSet(cmp);
    }
  }",3,3,db\version_set.cc,leveldb.Builder.Builder,,false,632,641,Builder,,,7,"ANY leveldb.Builder.Builder (VersionSet*,Version*)"
50688,METHOD,leveldb.Builder,TYPE_DECL,"~Builder() {
    for (int level = 0; level < config::kNumLevels; level++) {
      const FileSet* added = levels_[level].added_files;
      std::vector<FileMetaData*> to_unref;
      to_unref.reserve(added->size());
      for (FileSet::const_iterator it = added->begin();
          it != added->end(); ++it) {
        to_unref.push_back(*it);
      }
      delete added;
      for (uint32_t i = 0; i < to_unref.size(); i++) {
        FileMetaData* f = to_unref[i];
        f->refs--;
        if (f->refs <= 0) {
          delete f;
        }
      }
    }
    base_->Unref();
  }",3,3,db\version_set.cc,leveldb.Builder.~Builder,,false,643,662,~Builder,,,8,ANY leveldb.Builder.~Builder ()
50787,METHOD,leveldb.Builder,TYPE_DECL,"void Apply(VersionEdit* edit) {
    // Update compaction pointers
    for (size_t i = 0; i < edit->compact_pointers_.size(); i++) {
      const int level = edit->compact_pointers_[i].first;
      vset_->compact_pointer_[level] =
          edit->compact_pointers_[i].second.Encode().ToString();
    }

    // Delete files
    const VersionEdit::DeletedFileSet& del = edit->deleted_files_;
    for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
         iter != del.end();
         ++iter) {
      const int level = iter->first;
      const uint64_t number = iter->second;
      levels_[level].deleted_files.insert(number);
    }

    // Add new files
    for (size_t i = 0; i < edit->new_files_.size(); i++) {
      const int level = edit->new_files_[i].first;
      FileMetaData* f = new FileMetaData(edit->new_files_[i].second);
      f->refs = 1;

      // We arrange to automatically compact this file after
      // a certain number of seeks.  Let's assume:
      //   (1) On...",3,3,db\version_set.cc,leveldb.Builder.Apply,,false,665,708,Apply,,,9,void leveldb.Builder.Apply (VersionEdit*)
50968,METHOD,leveldb.Builder,TYPE_DECL,"void SaveTo(Version* v) {
    BySmallestKey cmp;
    cmp.internal_comparator = &vset_->icmp_;
    for (int level = 0; level < config::kNumLevels; level++) {
      // Merge the set of added files with the set of pre-existing files.
      // Drop any deleted files.  Store the result in *v.
      const std::vector<FileMetaData*>& base_files = base_->files_[level];
      std::vector<FileMetaData*>::const_iterator base_iter = base_files.begin();
      std::vector<FileMetaData*>::const_iterator base_end = base_files.end();
      const FileSet* added = levels_[level].added_files;
      v->files_[level].reserve(base_files.size() + added->size());
      for (FileSet::const_iterator added_iter = added->begin();
           added_iter != added->end();
           ++added_iter) {
        // Add all smaller files listed in base_
        for (std::vector<FileMetaData*>::const_iterator bpos
                 = std::upper_bound(base_iter, base_end, *added_iter, cmp);
             base_iter != bpos;
  ...",3,3,db\version_set.cc,leveldb.Builder.SaveTo,,false,711,757,SaveTo,,,10,void leveldb.Builder.SaveTo (Version*)
51184,METHOD,leveldb.Builder,TYPE_DECL,"void MaybeAddFile(Version* v, int level, FileMetaData* f) {
    if (levels_[level].deleted_files.count(f->number) > 0) {
      // File is deleted: do nothing
    } else {
      std::vector<FileMetaData*>* files = &v->files_[level];
      if (level > 0 && !files->empty()) {
        // Must not overlap
        assert(vset_->icmp_.Compare((*files)[files->size()-1]->largest,
                                    f->smallest) < 0);
      }
      f->refs++;
      files->push_back(f);
    }
  }",3,3,db\version_set.cc,leveldb.Builder.MaybeAddFile,,false,759,772,MaybeAddFile,,,11,"void leveldb.Builder.MaybeAddFile (Version*,int,FileMetaData*)"
51260,METHOD,<empty>,<empty>,<empty>,1,,db\version_set.cc,leveldb.Builder:<clinit>,,false,603,,<clinit>,,,12,
51268,METHOD,db\version_set.cc:<global>,TYPE_DECL,"VersionSet::VersionSet(const std::string& dbname,
                       const Options* options,
                       TableCache* table_cache,
                       const InternalKeyComparator* cmp)
    : env_(options->env),
      dbname_(dbname),
      options_(options),
      table_cache_(table_cache),
      icmp_(*cmp),
      next_file_number_(2),
      manifest_file_number_(0),  // Filled by Recover()
      last_sequence_(0),
      log_number_(0),
      prev_log_number_(0),
      descriptor_file_(NULL),
      descriptor_log_(NULL),
      dummy_versions_(this),
      current_(NULL) {
  AppendVersion(new Version(this));
}",1,1,db\version_set.cc,leveldb.VersionSet.VersionSet,,false,775,794,VersionSet,,,30,"ANY leveldb.VersionSet.VersionSet (ANY,Options*,TableCache*,InternalKeyComparator*)"
51280,METHOD,db\version_set.cc:<global>,TYPE_DECL,"VersionSet::~VersionSet() {
  current_->Unref();
  assert(dummy_versions_.next_ == &dummy_versions_);  // List must be empty
  delete descriptor_log_;
  delete descriptor_file_;
}",1,1,db\version_set.cc,leveldb.VersionSet.~VersionSet,,false,796,801,~VersionSet,,,31,ANY leveldb.VersionSet.~VersionSet ()
51299,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::AppendVersion(Version* v) {
  // Make ""v"" current
  assert(v->refs_ == 0);
  assert(v != current_);
  if (current_ != NULL) {
    current_->Unref();
  }
  current_ = v;
  v->Ref();

  // Append to linked list
  v->prev_ = dummy_versions_.prev_;
  v->next_ = &dummy_versions_;
  v->prev_->next_ = v;
  v->next_->prev_ = v;
}",1,1,db\version_set.cc,leveldb.VersionSet.AppendVersion,,false,803,818,AppendVersion,,,32,void leveldb.VersionSet.AppendVersion (Version*)
51357,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {
  if (edit->has_log_number_) {
    assert(edit->log_number_ >= log_number_);
    assert(edit->log_number_ < next_file_number_);
  } else {
    edit->SetLogNumber(log_number_);
  }

  if (!edit->has_prev_log_number_) {
    edit->SetPrevLogNumber(prev_log_number_);
  }

  edit->SetNextFile(next_file_number_);
  edit->SetLastSequence(last_sequence_);

  Version* v = new Version(this);
  {
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  // Initialize new descriptor log file if necessary by creating
  // a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s;
  if (descriptor_log_ == NULL) {
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname...",1,1,db\version_set.cc,leveldb.VersionSet.LogAndApply,,false,820,903,LogAndApply,,,33,"Status leveldb.VersionSet.LogAndApply (VersionEdit*,ANY*)"
51600,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Status VersionSet::Recover(bool *save_manifest) {
  struct LogReporter : public log::Reader::Reporter {
    Status* status;
    virtual void Corruption(size_t bytes, const Status& s) {
      if (this->status->ok()) *this->status = s;
    }
  };

  // Read ""CURRENT"" file, which contains a pointer to the current manifest file
  std::string current;
  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &current);
  if (!s.ok()) {
    return s;
  }
  if (current.empty() || current[current.size()-1] != '\n') {
    return Status::Corruption(""CURRENT file does not end with newline"");
  }
  current.resize(current.size() - 1);

  std::string dscname = dbname_ + ""/"" + current;
  SequentialFile* file;
  s = env_->NewSequentialFile(dscname, &file);
  if (!s.ok()) {
    return s;
  }

  bool have_log_number = false;
  bool have_prev_log_number = false;
  bool have_next_file = false;
  bool have_last_sequence = false;
  uint64_t next_file = 0;
  uint64_t last_sequence = 0;
  uint64_t log_...",1,1,db\version_set.cc,leveldb.VersionSet.Recover,,false,905,1025,Recover,,,34,Status leveldb.VersionSet.Recover (bool*)
51975,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool VersionSet::ReuseManifest(const std::string& dscname,
                               const std::string& dscbase) {
  if (!options_->reuse_logs) {
    return false;
  }
  FileType manifest_type;
  uint64_t manifest_number;
  uint64_t manifest_size;
  if (!ParseFileName(dscbase, &manifest_number, &manifest_type) ||
      manifest_type != kDescriptorFile ||
      !env_->GetFileSize(dscname, &manifest_size).ok() ||
      // Make new compacted MANIFEST if old one is too big
      manifest_size >= TargetFileSize(options_)) {
    return false;
  }

  assert(descriptor_file_ == NULL);
  assert(descriptor_log_ == NULL);
  Status r = env_->NewAppendableFile(dscname, &descriptor_file_);
  if (!r.ok()) {
    Log(options_->info_log, ""Reuse MANIFEST: %s\n"", r.ToString().c_str());
    assert(descriptor_file_ == NULL);
    return false;
  }

  Log(options_->info_log, ""Reusing MANIFEST %s\n"", dscname.c_str());
  descriptor_log_ = new log::Writer(descriptor_file_, manifest_size);
  manifest_file...",1,1,db\version_set.cc,leveldb.VersionSet.ReuseManifest,,false,1027,1056,ReuseManifest,,,35,"bool leveldb.VersionSet.ReuseManifest (ANY,ANY)"
52087,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::MarkFileNumberUsed(uint64_t number) {
  if (next_file_number_ <= number) {
    next_file_number_ = number + 1;
  }
}",1,1,db\version_set.cc,leveldb.VersionSet.MarkFileNumberUsed,,false,1058,1062,MarkFileNumberUsed,,,36,void leveldb.VersionSet.MarkFileNumberUsed (uint64_t)
52102,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::Finalize(Version* v) {
  // Precomputed best level for next compaction
  int best_level = -1;
  double best_score = -1;

  for (int level = 0; level < config::kNumLevels-1; level++) {
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v->files_[level].size() /
          static_cast<double>(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFi...",1,1,db\version_set.cc,leveldb.VersionSet.Finalize,,false,1064,1100,Finalize,,,37,void leveldb.VersionSet.Finalize (Version*)
52196,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Status VersionSet::WriteSnapshot(log::Writer* log) {
  // TODO: Break up into multiple records to reduce memory usage on recovery?

  // Save metadata
  VersionEdit edit;
  edit.SetComparatorName(icmp_.user_comparator()->Name());

  // Save compaction pointers
  for (int level = 0; level < config::kNumLevels; level++) {
    if (!compact_pointer_[level].empty()) {
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  // Save files
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = current_->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      const FileMetaData* f = files[i];
      edit.AddFile(level, f->number, f->file_size, f->smallest, f->largest);
    }
  }

  std::string record;
  edit.EncodeTo(&record);
  return log->AddRecord(record);
}",1,1,db\version_set.cc,leveldb.VersionSet.WriteSnapshot,,false,1102,1130,WriteSnapshot,,,38,Status leveldb.VersionSet.WriteSnapshot (ANY*)
52323,METHOD,db\version_set.cc:<global>,TYPE_DECL,"int VersionSet::NumLevelFiles(int level) const {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return current_->files_[level].size();
}",1,1,db\version_set.cc,leveldb.VersionSet.NumLevelFiles,,false,1132,1136,NumLevelFiles,,,39,int leveldb.VersionSet.NumLevelFiles (int)
52347,METHOD,db\version_set.cc:<global>,TYPE_DECL,"const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {
  // Update code if kNumLevels changes
  assert(config::kNumLevels == 7);
  snprintf(scratch->buffer, sizeof(scratch->buffer),
           ""files[ %d %d %d %d %d %d %d ]"",
           int(current_->files_[0].size()),
           int(current_->files_[1].size()),
           int(current_->files_[2].size()),
           int(current_->files_[3].size()),
           int(current_->files_[4].size()),
           int(current_->files_[5].size()),
           int(current_->files_[6].size()));
  return scratch->buffer;
}",1,1,db\version_set.cc,leveldb.VersionSet.LevelSummary,,false,1138,1151,LevelSummary,,,40,const char* leveldb.VersionSet.LevelSummary (LevelSummaryStorage*)
52441,METHOD,db\version_set.cc:<global>,TYPE_DECL,"uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {
  uint64_t result = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    const std::vector<FileMetaData*>& files = v->files_[level];
    for (size_t i = 0; i < files.size(); i++) {
      if (icmp_.Compare(files[i]->largest, ikey) <= 0) {
        // Entire file is before ""ikey"", so just add the file size
        result += files[i]->file_size;
      } else if (icmp_.Compare(files[i]->smallest, ikey) > 0) {
        // Entire file is after ""ikey"", so ignore
        if (level > 0) {
          // Files other than level 0 are sorted by meta->smallest, so
          // no further files in this level will contain data for
          // ""ikey"".
          break;
        }
      } else {
        // ""ikey"" falls in the range for this table.  Add the
        // approximate offset of ""ikey"" within the table.
        Table* tableptr;
        Iterator* iter = table_cache_->NewIterator(
            ReadOption...",1,1,db\version_set.cc,leveldb.VersionSet.ApproximateOffsetOf,,false,1153,1183,ApproximateOffsetOf,,,41,"uint64_t leveldb.VersionSet.ApproximateOffsetOf (Version*,InternalKey)"
52573,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {
  for (Version* v = dummy_versions_.next_;
       v != &dummy_versions_;
       v = v->next_) {
    for (int level = 0; level < config::kNumLevels; level++) {
      const std::vector<FileMetaData*>& files = v->files_[level];
      for (size_t i = 0; i < files.size(); i++) {
        live->insert(files[i]->number);
      }
    }
  }
}",1,1,db\version_set.cc,leveldb.VersionSet.AddLiveFiles,,false,1185,1196,AddLiveFiles,,,42,void leveldb.VersionSet.AddLiveFiles (ANY*)
52642,METHOD,db\version_set.cc:<global>,TYPE_DECL,"int64_t VersionSet::NumLevelBytes(int level) const {
  assert(level >= 0);
  assert(level < config::kNumLevels);
  return TotalFileSize(current_->files_[level]);
}",1,1,db\version_set.cc,leveldb.VersionSet.NumLevelBytes,,false,1198,1202,NumLevelBytes,,,43,int64_t leveldb.VersionSet.NumLevelBytes (int)
52664,METHOD,db\version_set.cc:<global>,TYPE_DECL,"int64_t VersionSet::MaxNextLevelOverlappingBytes() {
  int64_t result = 0;
  std::vector<FileMetaData*> overlaps;
  for (int level = 1; level < config::kNumLevels - 1; level++) {
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      const FileMetaData* f = current_->files_[level][i];
      current_->GetOverlappingInputs(level+1, &f->smallest, &f->largest,
                                     &overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum > result) {
        result = sum;
      }
    }
  }
  return result;
}",1,1,db\version_set.cc,leveldb.VersionSet.MaxNextLevelOverlappingBytes,,false,1204,1219,MaxNextLevelOverlappingBytes,,,44,int64_t leveldb.VersionSet.MaxNextLevelOverlappingBytes ()
52750,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,
                          InternalKey* smallest,
                          InternalKey* largest) {
  assert(!inputs.empty());
  smallest->Clear();
  largest->Clear();
  for (size_t i = 0; i < inputs.size(); i++) {
    FileMetaData* f = inputs[i];
    if (i == 0) {
      *smallest = f->smallest;
      *largest = f->largest;
    } else {
      if (icmp_.Compare(f->smallest, *smallest) < 0) {
        *smallest = f->smallest;
      }
      if (icmp_.Compare(f->largest, *largest) > 0) {
        *largest = f->largest;
      }
    }
  }
}",1,1,db\version_set.cc,leveldb.VersionSet.GetRange,,false,1224,1244,GetRange,,,45,"void leveldb.VersionSet.GetRange (ANY,InternalKey*,InternalKey*)"
52849,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,
                           const std::vector<FileMetaData*>& inputs2,
                           InternalKey* smallest,
                           InternalKey* largest) {
  std::vector<FileMetaData*> all = inputs1;
  all.insert(all.end(), inputs2.begin(), inputs2.end());
  GetRange(all, smallest, largest);
}",1,1,db\version_set.cc,leveldb.VersionSet.GetRange2,,false,1249,1256,GetRange2,,,46,"void leveldb.VersionSet.GetRange2 (ANY,ANY,InternalKey*,InternalKey*)"
52881,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Iterator* VersionSet::MakeInputIterator(Compaction* c) {
  ReadOptions options;
  options.verify_checksums = options_->paranoid_checks;
  options.fill_cache = false;

  // Level-0 files have to be merged together.  For other levels,
  // we will make a concatenating iterator per level.
  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
  const int space = (c->level() == 0 ? c->inputs_[0].size() + 1 : 2);
  Iterator** list = new Iterator*[space];
  int num = 0;
  for (int which = 0; which < 2; which++) {
    if (!c->inputs_[which].empty()) {
      if (c->level() + which == 0) {
        const std::vector<FileMetaData*>& files = c->inputs_[which];
        for (size_t i = 0; i < files.size(); i++) {
          list[num++] = table_cache_->NewIterator(
              options, files[i]->number, files[i]->file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            ...",1,1,db\version_set.cc,leveldb.VersionSet.MakeInputIterator,,false,1258,1289,MakeInputIterator,,,47,Iterator leveldb.VersionSet.MakeInputIterator (Compaction*)
53042,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Compaction* VersionSet::PickCompaction() {
  Compaction* c;
  int level;

  // We prefer compactions triggered by too much data in a level over
  // the compactions triggered by seeks.
  const bool size_compaction = (current_->compaction_score_ >= 1);
  const bool seek_compaction = (current_->file_to_compact_ != NULL);
  if (size_compaction) {
    level = current_->compaction_level_;
    assert(level >= 0);
    assert(level+1 < config::kNumLevels);
    c = new Compaction(options_, level);

    // Pick the first file that comes after compact_pointer_[level]
    for (size_t i = 0; i < current_->files_[level].size(); i++) {
      FileMetaData* f = current_->files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f->largest.Encode(), compact_pointer_[level]) > 0) {
        c->inputs_[0].push_back(f);
        break;
      }
    }
    if (c->inputs_[0].empty()) {
      // Wrap-around to the beginning of the key space
      c->inputs_[0].push_back(current_->f...",1,1,db\version_set.cc,leveldb.VersionSet.PickCompaction,,false,1291,1343,PickCompaction,,,48,Compaction leveldb.VersionSet.PickCompaction ()
53266,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void VersionSet::SetupOtherInputs(Compaction* c) {
  const int level = c->level();
  InternalKey smallest, largest;
  GetRange(c->inputs_[0], &smallest, &largest);

  current_->GetOverlappingInputs(level+1, &smallest, &largest, &c->inputs_[1]);

  // Get entire range covered by compaction
  InternalKey all_start, all_limit;
  GetRange2(c->inputs_[0], c->inputs_[1], &all_start, &all_limit);

  // See if we can grow the number of inputs in ""level"" without
  // changing the number of ""level+1"" files we pick up.
  if (!c->inputs_[1].empty()) {
    std::vector<FileMetaData*> expanded0;
    current_->GetOverlappingInputs(level, &all_start, &all_limit, &expanded0);
    const int64_t inputs0_size = TotalFileSize(c->inputs_[0]);
    const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);
    const int64_t expanded0_size = TotalFileSize(expanded0);
    if (expanded0.size() > c->inputs_[0].size() &&
        inputs1_size + expanded0_size <
            ExpandedCompactionByteSizeLimit(options_...",1,1,db\version_set.cc,leveldb.VersionSet.SetupOtherInputs,,false,1345,1411,SetupOtherInputs,,,49,void leveldb.VersionSet.SetupOtherInputs (Compaction*)
53580,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Compaction* VersionSet::CompactRange(
    int level,
    const InternalKey* begin,
    const InternalKey* end) {
  std::vector<FileMetaData*> inputs;
  current_->GetOverlappingInputs(level, begin, end, &inputs);
  if (inputs.empty()) {
    return NULL;
  }

  // Avoid compacting too much in one shot in case the range is large.
  // But we cannot do this for level-0 since level-0 files can overlap
  // and we must not pick one file and drop another older file if the
  // two files overlap.
  if (level > 0) {
    const uint64_t limit = MaxFileSizeForLevel(options_, level);
    uint64_t total = 0;
    for (size_t i = 0; i < inputs.size(); i++) {
      uint64_t s = inputs[i]->file_size;
      total += s;
      if (total >= limit) {
        inputs.resize(i + 1);
        break;
      }
    }
  }

  Compaction* c = new Compaction(options_, level);
  c->input_version_ = current_;
  c->input_version_->Ref();
  c->inputs_[0] = inputs;
  SetupOtherInputs(c);
  return c;
}",1,1,db\version_set.cc,leveldb.VersionSet.CompactRange,,false,1413,1446,CompactRange,,,50,"Compaction leveldb.VersionSet.CompactRange (int,InternalKey*,InternalKey*)"
53688,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Compaction::Compaction(const Options* options, int level)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(options, level)),
      input_version_(NULL),
      grandparent_index_(0),
      seen_key_(false),
      overlapped_bytes_(0) {
  for (int i = 0; i < config::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}",1,1,db\version_set.cc,leveldb.Compaction.Compaction,,false,1448,1458,Compaction,,,51,"ANY leveldb.Compaction.Compaction (Options*,int)"
53713,METHOD,db\version_set.cc:<global>,TYPE_DECL,"Compaction::~Compaction() {
  if (input_version_ != NULL) {
    input_version_->Unref();
  }
}",1,1,db\version_set.cc,leveldb.Compaction.~Compaction,,false,1460,1464,~Compaction,,,52,ANY leveldb.Compaction.~Compaction ()
53726,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool Compaction::IsTrivialMove() const {
  const VersionSet* vset = input_version_->vset_;
  // Avoid a move if there is lots of overlapping grandparent data.
  // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&
          TotalFileSize(grandparents_) <=
              MaxGrandParentOverlapBytes(vset->options_));
}",1,1,db\version_set.cc,leveldb.Compaction.IsTrivialMove,,false,1466,1474,IsTrivialMove,,,53,bool leveldb.Compaction.IsTrivialMove ()
53754,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Compaction::AddInputDeletions(VersionEdit* edit) {
  for (int which = 0; which < 2; which++) {
    for (size_t i = 0; i < inputs_[which].size(); i++) {
      edit->DeleteFile(level_ + which, inputs_[which][i]->number);
    }
  }
}",1,1,db\version_set.cc,leveldb.Compaction.AddInputDeletions,,false,1476,1482,AddInputDeletions,,,54,void leveldb.Compaction.AddInputDeletions (VersionEdit*)
53802,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool Compaction::IsBaseLevelForKey(const Slice& user_key) {
  // Maybe use binary search to find right entry instead of linear search?
  const Comparator* user_cmp = input_version_->vset_->icmp_.user_comparator();
  for (int lvl = level_ + 2; lvl < config::kNumLevels; lvl++) {
    const std::vector<FileMetaData*>& files = input_version_->files_[lvl];
    for (; level_ptrs_[lvl] < files.size(); ) {
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp->Compare(user_key, f->largest.user_key()) <= 0) {
        // We've advanced far enough
        if (user_cmp->Compare(user_key, f->smallest.user_key()) >= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }
  }
  return true;
}",1,1,db\version_set.cc,leveldb.Compaction.IsBaseLevelForKey,,false,1484,1503,IsBaseLevelForKey,,,55,bool leveldb.Compaction.IsBaseLevelForKey (Slice)
53900,METHOD,db\version_set.cc:<global>,TYPE_DECL,"bool Compaction::ShouldStopBefore(const Slice& internal_key) {
  const VersionSet* vset = input_version_->vset_;
  // Scan to find earliest grandparent file that contains key.
  const InternalKeyComparator* icmp = &vset->icmp_;
  while (grandparent_index_ < grandparents_.size() &&
      icmp->Compare(internal_key,
                    grandparents_[grandparent_index_]->largest.Encode()) > 0) {
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]->file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = true;

  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0;
    return true;
  } else {
    return false;
  }
}",1,1,db\version_set.cc,leveldb.Compaction.ShouldStopBefore,,false,1505,1526,ShouldStopBefore,,,56,bool leveldb.Compaction.ShouldStopBefore (Slice)
53974,METHOD,db\version_set.cc:<global>,TYPE_DECL,"void Compaction::ReleaseInputs() {
  if (input_version_ != NULL) {
    input_version_->Unref();
    input_version_ = NULL;
  }
}",1,1,db\version_set.cc,leveldb.Compaction.ReleaseInputs,,false,1528,1533,ReleaseInputs,,,57,void leveldb.Compaction.ReleaseInputs ()
54007,METHOD,db\version_set.hpp:<global>,TYPE_DECL,<global>,1,18,db\version_set.hpp,db\version_set.hpp:<global>,,false,1,398,<global>,,,1,
54020,METHOD,db\version_set.hpp:<global>,TYPE_DECL,"extern int FindFile(const InternalKeyComparator& icmp,
                    const std::vector<FileMetaData*>& files,
                    const Slice& key);",12,37,db\version_set.hpp,leveldb.FindFile,,false,42,44,FindFile,,,10,"int leveldb.FindFile (InternalKeyComparator,ANY,Slice)"
54027,METHOD,db\version_set.hpp:<global>,TYPE_DECL,"extern bool SomeFileOverlapsRange(
    const InternalKeyComparator& icmp,
    bool disjoint_sorted_files,
    const std::vector<FileMetaData*>& files,
    const Slice* smallest_user_key,
    const Slice* largest_user_key);",13,34,db\version_set.hpp,leveldb.SomeFileOverlapsRange,,false,52,57,SomeFileOverlapsRange,,,11,"bool leveldb.SomeFileOverlapsRange (InternalKeyComparator,bool,ANY,Slice*,Slice*)"
54037,METHOD,leveldb.Version,TYPE_DECL,"void AddIterators(const ReadOptions&, std::vector<Iterator*>* iters);",8,70,db\version_set.hpp,leveldb.Version.AddIterators,,false,64,64,AddIterators,,,1,"void leveldb.Version.AddIterators (ReadOptions,ANY*)"
54046,METHOD,leveldb.Version,TYPE_DECL,"Status Get(const ReadOptions&, const LookupKey& key, std::string* val,
             GetStats* stats);",10,29,db\version_set.hpp,leveldb.Version.Get,,false,73,74,Get,,,3,"Status leveldb.Version.Get (ReadOptions,LookupKey,ANY*,GetStats*)"
54054,METHOD,leveldb.Version,TYPE_DECL,bool UpdateStats(const GetStats& stats);,8,41,db\version_set.hpp,leveldb.Version.UpdateStats,,false,79,79,UpdateStats,,,4,bool leveldb.Version.UpdateStats (GetStats)
54059,METHOD,leveldb.Version,TYPE_DECL,bool RecordReadSample(Slice key);,8,34,db\version_set.hpp,leveldb.Version.RecordReadSample,,false,85,85,RecordReadSample,,,5,bool leveldb.Version.RecordReadSample (Slice)
54064,METHOD,leveldb.Version,TYPE_DECL,void Ref();,8,12,db\version_set.hpp,leveldb.Version.Ref,,false,89,89,Ref,,,6,void leveldb.Version.Ref ()
54068,METHOD,leveldb.Version,TYPE_DECL,void Unref();,8,14,db\version_set.hpp,leveldb.Version.Unref,,false,90,90,Unref,,,7,void leveldb.Version.Unref ()
54072,METHOD,leveldb.Version,TYPE_DECL,"void GetOverlappingInputs(
      int level,
      const InternalKey* begin,         // NULL means before all keys
      const InternalKey* end,           // NULL means after all keys
      std::vector<FileMetaData*>* inputs);",8,41,db\version_set.hpp,leveldb.Version.GetOverlappingInputs,,false,92,96,GetOverlappingInputs,,,8,"void leveldb.Version.GetOverlappingInputs (int,InternalKey*,InternalKey*,ANY*)"
54080,METHOD,leveldb.Version,TYPE_DECL,"bool OverlapInLevel(int level,
                      const Slice* smallest_user_key,
                      const Slice* largest_user_key);",8,52,db\version_set.hpp,leveldb.Version.OverlapInLevel,,false,102,104,OverlapInLevel,,,9,"bool leveldb.Version.OverlapInLevel (int,Slice*,Slice*)"
54087,METHOD,leveldb.Version,TYPE_DECL,"int PickLevelForMemTableOutput(const Slice& smallest_user_key,
                                 const Slice& largest_user_key);",7,63,db\version_set.hpp,leveldb.Version.PickLevelForMemTableOutput,,false,108,109,PickLevelForMemTableOutput,,,10,"int leveldb.Version.PickLevelForMemTableOutput (Slice,Slice)"
54093,METHOD,leveldb.Version,TYPE_DECL,int NumFiles(int level) const { return files_[level].size(); },3,64,db\version_set.hpp,leveldb.Version.NumFiles,,false,111,111,NumFiles,,,11,int leveldb.Version.NumFiles (int)
54105,METHOD,leveldb.Version,TYPE_DECL,std::string DebugString() const;,15,33,db\version_set.hpp,leveldb.Version.DebugString,,false,114,114,DebugString,,,12,ANY leveldb.Version.DebugString ()
54112,METHOD,leveldb.Version,TYPE_DECL,"Iterator* NewConcatenatingIterator(const ReadOptions&, int level) const;",11,73,db\version_set.hpp,leveldb.Version.NewConcatenatingIterator,,false,121,121,NewConcatenatingIterator,,,16,"Iterator* leveldb.Version.NewConcatenatingIterator (ReadOptions,int)"
54118,METHOD,leveldb.Version,TYPE_DECL,"void ForEachOverlapping(Slice user_key, Slice internal_key,
                          void* arg,
                          bool (*func)(void*, int, FileMetaData*));",8,66,db\version_set.hpp,leveldb.Version.ForEachOverlapping,,false,128,130,ForEachOverlapping,,,17,"void leveldb.Version.ForEachOverlapping (Slice,Slice,void*,bool)"
54135,METHOD,leveldb.Version,TYPE_DECL,"explicit Version(VersionSet* vset)
      : vset_(vset), next_(this), prev_(this), refs_(0),
        file_to_compact_(NULL),
        file_to_compact_level_(-1),
        compaction_score_(-1),
        compaction_level_(-1) {
  }",3,3,db\version_set.hpp,leveldb.Version.Version,,false,150,156,Version,,,27,ANY leveldb.Version.Version (VersionSet*)
54140,METHOD,leveldb.Version,TYPE_DECL,~Version();,3,12,db\version_set.hpp,leveldb.Version.~Version,,false,158,158,~Version,,,28,ANY leveldb.Version.~Version ()
54144,METHOD,leveldb.Version,TYPE_DECL,Version(const Version&);,3,25,db\version_set.hpp,leveldb.Version.Version,,false,161,161,Version,,,29,ANY leveldb.Version.Version (Version)
54149,METHOD,leveldb.Version,TYPE_DECL,void operator=(const Version&);,8,32,db\version_set.hpp,leveldb.Version.operator =,,false,162,162,operator =,,,30,void leveldb.Version.operator = (Version)
54154,METHOD,<empty>,<empty>,<empty>,1,,db\version_set.hpp,leveldb.Version:<clinit>,,false,59,,<clinit>,,,31,
54163,METHOD,leveldb.VersionSet,TYPE_DECL,"VersionSet(const std::string& dbname,
             const Options* options,
             TableCache* table_cache,
             const InternalKeyComparator*);",3,42,db\version_set.hpp,leveldb.VersionSet.VersionSet,,false,167,170,VersionSet,,,1,"ANY leveldb.VersionSet.VersionSet (ANY,Options*,TableCache*,InternalKeyComparator*)"
54171,METHOD,leveldb.VersionSet,TYPE_DECL,~VersionSet();,3,15,db\version_set.hpp,leveldb.VersionSet.~VersionSet,,false,171,171,~VersionSet,,,2,ANY leveldb.VersionSet.~VersionSet ()
54175,METHOD,leveldb.VersionSet,TYPE_DECL,"Status LogAndApply(VersionEdit* edit, port::Mutex* mu)
      EXCLUSIVE_LOCKS_REQUIRED(mu);",10,56,db\version_set.hpp,leveldb.VersionSet.LogAndApply,,false,178,178,LogAndApply,,,3,"Status leveldb.VersionSet.LogAndApply (VersionEdit*,ANY*)"
54181,METHOD,leveldb.VersionSet,TYPE_DECL,Status Recover(bool *save_manifest);,10,37,db\version_set.hpp,leveldb.VersionSet.Recover,,false,182,182,Recover,,,4,Status leveldb.VersionSet.Recover (bool*)
54186,METHOD,leveldb.VersionSet,TYPE_DECL,Version* current() const { return current_; },3,47,db\version_set.hpp,leveldb.VersionSet.current,,false,185,185,current,,,5,Version leveldb.VersionSet.current ()
54192,METHOD,leveldb.VersionSet,TYPE_DECL,uint64_t ManifestFileNumber() const { return manifest_file_number_; },3,71,db\version_set.hpp,leveldb.VersionSet.ManifestFileNumber,,false,188,188,ManifestFileNumber,,,6,uint64_t leveldb.VersionSet.ManifestFileNumber ()
54198,METHOD,leveldb.VersionSet,TYPE_DECL,uint64_t NewFileNumber() { return next_file_number_++; },3,58,db\version_set.hpp,leveldb.VersionSet.NewFileNumber,,false,191,191,NewFileNumber,,,7,uint64_t leveldb.VersionSet.NewFileNumber ()
54205,METHOD,leveldb.VersionSet,TYPE_DECL,"void ReuseFileNumber(uint64_t file_number) {
    if (next_file_number_ == file_number + 1) {
      next_file_number_ = file_number;
    }
  }",3,3,db\version_set.hpp,leveldb.VersionSet.ReuseFileNumber,,false,196,200,ReuseFileNumber,,,8,void leveldb.VersionSet.ReuseFileNumber (uint64_t)
54220,METHOD,leveldb.VersionSet,TYPE_DECL,int NumLevelFiles(int level) const;,7,36,db\version_set.hpp,leveldb.VersionSet.NumLevelFiles,,false,203,203,NumLevelFiles,,,9,int leveldb.VersionSet.NumLevelFiles (int)
54225,METHOD,leveldb.VersionSet,TYPE_DECL,int64_t NumLevelBytes(int level) const;,11,40,db\version_set.hpp,leveldb.VersionSet.NumLevelBytes,,false,206,206,NumLevelBytes,,,10,int64_t leveldb.VersionSet.NumLevelBytes (int)
54230,METHOD,leveldb.VersionSet,TYPE_DECL,uint64_t LastSequence() const { return last_sequence_; },3,58,db\version_set.hpp,leveldb.VersionSet.LastSequence,,false,209,209,LastSequence,,,11,uint64_t leveldb.VersionSet.LastSequence ()
54236,METHOD,leveldb.VersionSet,TYPE_DECL,"void SetLastSequence(uint64_t s) {
    assert(s >= last_sequence_);
    last_sequence_ = s;
  }",3,3,db\version_set.hpp,leveldb.VersionSet.SetLastSequence,,false,212,215,SetLastSequence,,,12,void leveldb.VersionSet.SetLastSequence (uint64_t)
54248,METHOD,leveldb.VersionSet,TYPE_DECL,void MarkFileNumberUsed(uint64_t number);,8,42,db\version_set.hpp,leveldb.VersionSet.MarkFileNumberUsed,,false,218,218,MarkFileNumberUsed,,,13,void leveldb.VersionSet.MarkFileNumberUsed (uint64_t)
54253,METHOD,leveldb.VersionSet,TYPE_DECL,uint64_t LogNumber() const { return log_number_; },3,52,db\version_set.hpp,leveldb.VersionSet.LogNumber,,false,221,221,LogNumber,,,14,uint64_t leveldb.VersionSet.LogNumber ()
54259,METHOD,leveldb.VersionSet,TYPE_DECL,uint64_t PrevLogNumber() const { return prev_log_number_; },3,61,db\version_set.hpp,leveldb.VersionSet.PrevLogNumber,,false,225,225,PrevLogNumber,,,15,uint64_t leveldb.VersionSet.PrevLogNumber ()
54265,METHOD,leveldb.VersionSet,TYPE_DECL,Compaction* PickCompaction();,13,30,db\version_set.hpp,leveldb.VersionSet.PickCompaction,,false,231,231,PickCompaction,,,16,Compaction* leveldb.VersionSet.PickCompaction ()
54269,METHOD,leveldb.VersionSet,TYPE_DECL,"Compaction* CompactRange(
      int level,
      const InternalKey* begin,
      const InternalKey* end);",13,29,db\version_set.hpp,leveldb.VersionSet.CompactRange,,false,237,240,CompactRange,,,17,"Compaction* leveldb.VersionSet.CompactRange (int,InternalKey*,InternalKey*)"
54276,METHOD,leveldb.VersionSet,TYPE_DECL,int64_t MaxNextLevelOverlappingBytes();,11,40,db\version_set.hpp,leveldb.VersionSet.MaxNextLevelOverlappingBytes,,false,244,244,MaxNextLevelOverlappingBytes,,,18,int64_t leveldb.VersionSet.MaxNextLevelOverlappingBytes ()
54280,METHOD,leveldb.VersionSet,TYPE_DECL,Iterator* MakeInputIterator(Compaction* c);,11,44,db\version_set.hpp,leveldb.VersionSet.MakeInputIterator,,false,248,248,MakeInputIterator,,,19,Iterator* leveldb.VersionSet.MakeInputIterator (Compaction*)
54285,METHOD,leveldb.VersionSet,TYPE_DECL,"bool NeedsCompaction() const {
    Version* v = current_;
    return (v->compaction_score_ >= 1) || (v->file_to_compact_ != NULL);
  }",3,3,db\version_set.hpp,leveldb.VersionSet.NeedsCompaction,,false,251,254,NeedsCompaction,,,20,bool leveldb.VersionSet.NeedsCompaction ()
54305,METHOD,leveldb.VersionSet,TYPE_DECL,void AddLiveFiles(std::set<uint64_t>* live);,8,45,db\version_set.hpp,leveldb.VersionSet.AddLiveFiles,,false,258,258,AddLiveFiles,,,21,void leveldb.VersionSet.AddLiveFiles (ANY*)
54310,METHOD,leveldb.VersionSet,TYPE_DECL,"uint64_t ApproximateOffsetOf(Version* v, const InternalKey& key);",12,66,db\version_set.hpp,leveldb.VersionSet.ApproximateOffsetOf,,false,262,262,ApproximateOffsetOf,,,22,"uint64_t leveldb.VersionSet.ApproximateOffsetOf (Version*,InternalKey)"
54318,METHOD,<empty>,<empty>,<empty>,3,,db\version_set.hpp,leveldb.VersionSet.LevelSummaryStorage:<clinit>,,false,266,,<clinit>,,,2,
54324,METHOD,leveldb.VersionSet,TYPE_DECL,const char* LevelSummary(LevelSummaryStorage* scratch) const;,13,62,db\version_set.hpp,leveldb.VersionSet.LevelSummary,,false,269,269,LevelSummary,,,24,char* leveldb.VersionSet.LevelSummary (LevelSummaryStorage*)
54332,METHOD,leveldb.VersionSet,TYPE_DECL,"bool ReuseManifest(const std::string& dscname, const std::string& dscbase);",8,76,db\version_set.hpp,leveldb.VersionSet.ReuseManifest,,false,277,277,ReuseManifest,,,28,"bool leveldb.VersionSet.ReuseManifest (ANY,ANY)"
54338,METHOD,leveldb.VersionSet,TYPE_DECL,void Finalize(Version* v);,8,27,db\version_set.hpp,leveldb.VersionSet.Finalize,,false,279,279,Finalize,,,29,void leveldb.VersionSet.Finalize (Version*)
54343,METHOD,leveldb.VersionSet,TYPE_DECL,"void GetRange(const std::vector<FileMetaData*>& inputs,
                InternalKey* smallest,
                InternalKey* largest);",8,37,db\version_set.hpp,leveldb.VersionSet.GetRange,,false,281,283,GetRange,,,30,"void leveldb.VersionSet.GetRange (ANY,InternalKey*,InternalKey*)"
54350,METHOD,leveldb.VersionSet,TYPE_DECL,"void GetRange2(const std::vector<FileMetaData*>& inputs1,
                 const std::vector<FileMetaData*>& inputs2,
                 InternalKey* smallest,
                 InternalKey* largest);",8,38,db\version_set.hpp,leveldb.VersionSet.GetRange2,,false,285,288,GetRange2,,,31,"void leveldb.VersionSet.GetRange2 (ANY,ANY,InternalKey*,InternalKey*)"
54358,METHOD,leveldb.VersionSet,TYPE_DECL,void SetupOtherInputs(Compaction* c);,8,38,db\version_set.hpp,leveldb.VersionSet.SetupOtherInputs,,false,290,290,SetupOtherInputs,,,32,void leveldb.VersionSet.SetupOtherInputs (Compaction*)
54363,METHOD,leveldb.VersionSet,TYPE_DECL,Status WriteSnapshot(log::Writer* log);,10,40,db\version_set.hpp,leveldb.VersionSet.WriteSnapshot,,false,293,293,WriteSnapshot,,,33,Status leveldb.VersionSet.WriteSnapshot (ANY*)
54368,METHOD,leveldb.VersionSet,TYPE_DECL,void AppendVersion(Version* v);,8,32,db\version_set.hpp,leveldb.VersionSet.AppendVersion,,false,295,295,AppendVersion,,,34,void leveldb.VersionSet.AppendVersion (Version*)
54388,METHOD,leveldb.VersionSet,TYPE_DECL,VersionSet(const VersionSet&);,3,31,db\version_set.hpp,leveldb.VersionSet.VersionSet,,false,319,319,VersionSet,,,50,ANY leveldb.VersionSet.VersionSet (VersionSet)
54393,METHOD,leveldb.VersionSet,TYPE_DECL,void operator=(const VersionSet&);,8,35,db\version_set.hpp,leveldb.VersionSet.operator =,,false,320,320,operator =,,,51,void leveldb.VersionSet.operator = (VersionSet)
54398,METHOD,<empty>,<empty>,<empty>,1,,db\version_set.hpp,leveldb.VersionSet:<clinit>,,false,165,,<clinit>,,,52,
54407,METHOD,leveldb.Compaction,TYPE_DECL,~Compaction();,3,15,db\version_set.hpp,leveldb.Compaction.~Compaction,,false,326,326,~Compaction,,,1,ANY leveldb.Compaction.~Compaction ()
54411,METHOD,leveldb.Compaction,TYPE_DECL,int level() const { return level_; },3,38,db\version_set.hpp,leveldb.Compaction.level,,false,330,330,level,,,2,int leveldb.Compaction.level ()
54417,METHOD,leveldb.Compaction,TYPE_DECL,VersionEdit* edit() { return &edit_; },3,40,db\version_set.hpp,leveldb.Compaction.edit,,false,334,334,edit,,,3,VersionEdit leveldb.Compaction.edit ()
54424,METHOD,leveldb.Compaction,TYPE_DECL,int num_input_files(int which) const { return inputs_[which].size(); },3,72,db\version_set.hpp,leveldb.Compaction.num_input_files,,false,337,337,num_input_files,,,4,int leveldb.Compaction.num_input_files (int)
54436,METHOD,leveldb.Compaction,TYPE_DECL,"FileMetaData* input(int which, int i) const { return inputs_[which][i]; }",3,75,db\version_set.hpp,leveldb.Compaction.input,,false,340,340,input,,,5,"FileMetaData leveldb.Compaction.input (int,int)"
54448,METHOD,leveldb.Compaction,TYPE_DECL,uint64_t MaxOutputFileSize() const { return max_output_file_size_; },3,70,db\version_set.hpp,leveldb.Compaction.MaxOutputFileSize,,false,343,343,MaxOutputFileSize,,,6,uint64_t leveldb.Compaction.MaxOutputFileSize ()
54454,METHOD,leveldb.Compaction,TYPE_DECL,bool IsTrivialMove() const;,8,28,db\version_set.hpp,leveldb.Compaction.IsTrivialMove,,false,347,347,IsTrivialMove,,,7,bool leveldb.Compaction.IsTrivialMove ()
54458,METHOD,leveldb.Compaction,TYPE_DECL,void AddInputDeletions(VersionEdit* edit);,8,43,db\version_set.hpp,leveldb.Compaction.AddInputDeletions,,false,350,350,AddInputDeletions,,,8,void leveldb.Compaction.AddInputDeletions (VersionEdit*)
54463,METHOD,leveldb.Compaction,TYPE_DECL,bool IsBaseLevelForKey(const Slice& user_key);,8,47,db\version_set.hpp,leveldb.Compaction.IsBaseLevelForKey,,false,355,355,IsBaseLevelForKey,,,9,bool leveldb.Compaction.IsBaseLevelForKey (Slice)
54468,METHOD,leveldb.Compaction,TYPE_DECL,bool ShouldStopBefore(const Slice& internal_key);,8,50,db\version_set.hpp,leveldb.Compaction.ShouldStopBefore,,false,359,359,ShouldStopBefore,,,10,bool leveldb.Compaction.ShouldStopBefore (Slice)
54473,METHOD,leveldb.Compaction,TYPE_DECL,void ReleaseInputs();,8,22,db\version_set.hpp,leveldb.Compaction.ReleaseInputs,,false,363,363,ReleaseInputs,,,11,void leveldb.Compaction.ReleaseInputs ()
54479,METHOD,leveldb.Compaction,TYPE_DECL,"Compaction(const Options* options, int level);",3,47,db\version_set.hpp,leveldb.Compaction.Compaction,,false,369,369,Compaction,,,14,"ANY leveldb.Compaction.Compaction (Options*,int)"
54495,METHOD,<empty>,<empty>,<empty>,1,,db\version_set.hpp,leveldb.Compaction:<clinit>,,false,324,,<clinit>,,,25,
54516,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,<global>,1,1,db\version_set_test.cc,db\version_set_test.cc:<global>,,false,1,179,<global>,,,1,
54522,METHOD,leveldb.FindFileTest,TYPE_DECL,FindFileTest() : disjoint_sorted_files_(true) { },3,51,db\version_set_test.cc,leveldb.FindFileTest.FindFileTest,,false,17,17,FindFileTest,,,3,ANY leveldb.FindFileTest.FindFileTest ()
54526,METHOD,leveldb.FindFileTest,TYPE_DECL,"~FindFileTest() {
    for (int i = 0; i < files_.size(); i++) {
      delete files_[i];
    }
  }",3,3,db\version_set_test.cc,leveldb.FindFileTest.~FindFileTest,,false,19,23,~FindFileTest,,,4,ANY leveldb.FindFileTest.~FindFileTest ()
54549,METHOD,leveldb.FindFileTest,TYPE_DECL,"void Add(const char* smallest, const char* largest,
           SequenceNumber smallest_seq = 100,
           SequenceNumber largest_seq = 100) {
    FileMetaData* f = new FileMetaData;
    f->number = files_.size() + 1;
    f->smallest = InternalKey(smallest, smallest_seq, kTypeValue);
    f->largest = InternalKey(largest, largest_seq, kTypeValue);
    files_.push_back(f);
  }",3,3,db\version_set_test.cc,leveldb.FindFileTest.Add,,false,25,33,Add,,,5,"void leveldb.FindFileTest.Add (char*,char*,SequenceNumber,SequenceNumber)"
54593,METHOD,leveldb.FindFileTest,TYPE_DECL,"int Find(const char* key) {
    InternalKey target(key, 100, kTypeValue);
    InternalKeyComparator cmp(BytewiseComparator());
    return FindFile(cmp, files_, target.Encode());
  }",3,3,db\version_set_test.cc,leveldb.FindFileTest.Find,,false,35,39,Find,,,6,int leveldb.FindFileTest.Find (char*)
54614,METHOD,leveldb.FindFileTest,TYPE_DECL,"bool Overlaps(const char* smallest, const char* largest) {
    InternalKeyComparator cmp(BytewiseComparator());
    Slice s(smallest != NULL ? smallest : """");
    Slice l(largest != NULL ? largest : """");
    return SomeFileOverlapsRange(cmp, disjoint_sorted_files_, files_,
                                 (smallest != NULL ? &s : NULL),
                                 (largest != NULL ? &l : NULL));
  }",3,3,db\version_set_test.cc,leveldb.FindFileTest.Overlaps,,false,41,48,Overlaps,,,7,"bool leveldb.FindFileTest.Overlaps (char*,char*)"
54659,METHOD,leveldb._Test_Empty,TYPE_DECL,void void ();,1,25,db\version_set_test.cc,leveldb._Test_Empty._Run,,false,51,51,_Run,,,1,void leveldb._Test_Empty._Run ()
54663,METHOD,leveldb._Test_Empty,TYPE_DECL,"TEST(FindFileTest, Empty)",1,25,db\version_set_test.cc,leveldb._Test_Empty._RunIt,,false,51,51,_RunIt,,,2,void leveldb._Test_Empty._RunIt ()
54687,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"TEST(FindFileTest, Empty) {
  ASSERT_EQ(0, Find(""foo""));
  ASSERT_TRUE(! Overlaps(""a"", ""z""));
  ASSERT_TRUE(! Overlaps(NULL, ""z""));
  ASSERT_TRUE(! Overlaps(""a"", NULL));
  ASSERT_TRUE(! Overlaps(NULL, NULL));
}",1,25,db\version_set_test.cc,leveldb._Test_Empty._Run,,false,51,57,_Run,,,5,void leveldb._Test_Empty._Run ()
54783,METHOD,leveldb._Test_Single,TYPE_DECL,void void ();,1,26,db\version_set_test.cc,leveldb._Test_Single._Run,,false,59,59,_Run,,,1,void leveldb._Test_Single._Run ()
54787,METHOD,leveldb._Test_Single,TYPE_DECL,"TEST(FindFileTest, Single)",1,26,db\version_set_test.cc,leveldb._Test_Single._RunIt,,false,59,59,_RunIt,,,2,void leveldb._Test_Single._RunIt ()
54811,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"TEST(FindFileTest, Single) {
  Add(""p"", ""q"");
  ASSERT_EQ(0, Find(""a""));
  ASSERT_EQ(0, Find(""p""));
  ASSERT_EQ(0, Find(""p1""));
  ASSERT_EQ(0, Find(""q""));
  ASSERT_EQ(1, Find(""q1""));
  ASSERT_EQ(1, Find(""z""));

  ASSERT_TRUE(! Overlaps(""a"", ""b""));
  ASSERT_TRUE(! Overlaps(""z1"", ""z2""));
  ASSERT_TRUE(Overlaps(""a"", ""p""));
  ASSERT_TRUE(Overlaps(""a"", ""q""));
  ASSERT_TRUE(Overlaps(""a"", ""z""));
  ASSERT_TRUE(Overlaps(""p"", ""p1""));
  ASSERT_TRUE(Overlaps(""p"", ""q""));
  ASSERT_TRUE(Overlaps(""p"", ""z""));
  ASSERT_TRUE(Overlaps(""p1"", ""p2""));
  ASSERT_TRUE(Overlaps(""p1"", ""z""));
  ASSERT_TRUE(Overlaps(""q"", ""q""));
  ASSERT_TRUE(Overlaps(""q"", ""q1""));

  ASSERT_TRUE(! Overlaps(NULL, ""j""));
  ASSERT_TRUE(! Overlaps(""r"", NULL));
  ASSERT_TRUE(Overlaps(NULL, ""p""));
  ASSERT_TRUE(Overlaps(NULL, ""p1""));
  ASSERT_TRUE(Overlaps(""q"", NULL));
  ASSERT_TRUE(Overlaps(NULL, NULL));
}",1,26,db\version_set_test.cc,leveldb._Test_Single._Run,,false,59,87,_Run,,,9,void leveldb._Test_Single._Run ()
55243,METHOD,leveldb._Test_Multiple,TYPE_DECL,void void ();,1,28,db\version_set_test.cc,leveldb._Test_Multiple._Run,,false,90,90,_Run,,,1,void leveldb._Test_Multiple._Run ()
55247,METHOD,leveldb._Test_Multiple,TYPE_DECL,"TEST(FindFileTest, Multiple)",1,28,db\version_set_test.cc,leveldb._Test_Multiple._RunIt,,false,90,90,_RunIt,,,2,void leveldb._Test_Multiple._RunIt ()
55271,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"TEST(FindFileTest, Multiple) {
  Add(""150"", ""200"");
  Add(""200"", ""250"");
  Add(""300"", ""350"");
  Add(""400"", ""450"");
  ASSERT_EQ(0, Find(""100""));
  ASSERT_EQ(0, Find(""150""));
  ASSERT_EQ(0, Find(""151""));
  ASSERT_EQ(0, Find(""199""));
  ASSERT_EQ(0, Find(""200""));
  ASSERT_EQ(1, Find(""201""));
  ASSERT_EQ(1, Find(""249""));
  ASSERT_EQ(1, Find(""250""));
  ASSERT_EQ(2, Find(""251""));
  ASSERT_EQ(2, Find(""299""));
  ASSERT_EQ(2, Find(""300""));
  ASSERT_EQ(2, Find(""349""));
  ASSERT_EQ(2, Find(""350""));
  ASSERT_EQ(3, Find(""351""));
  ASSERT_EQ(3, Find(""400""));
  ASSERT_EQ(3, Find(""450""));
  ASSERT_EQ(4, Find(""451""));

  ASSERT_TRUE(! Overlaps(""100"", ""149""));
  ASSERT_TRUE(! Overlaps(""251"", ""299""));
  ASSERT_TRUE(! Overlaps(""451"", ""500""));
  ASSERT_TRUE(! Overlaps(""351"", ""399""));

  ASSERT_TRUE(Overlaps(""100"", ""150""));
  ASSERT_TRUE(Overlaps(""100"", ""200""));
  ASSERT_TRUE(Overlaps(""100"", ""300""));
  ASSERT_TRUE(Overlaps(""100"", ""400""));
  ASSERT_TRUE(Overlaps(""100"", ""500""));
  ASSERT_TRUE(Overlaps(""375""...",1,28,db\version_set_test.cc,leveldb._Test_Multiple._Run,,false,90,126,_Run,,,13,void leveldb._Test_Multiple._Run ()
55819,METHOD,leveldb._Test_MultipleNullBoundaries,TYPE_DECL,void void ();,1,42,db\version_set_test.cc,leveldb._Test_MultipleNullBoundaries._Run,,false,128,128,_Run,,,1,void leveldb._Test_MultipleNullBoundaries._Run ()
55823,METHOD,leveldb._Test_MultipleNullBoundaries,TYPE_DECL,"TEST(FindFileTest, MultipleNullBoundaries)",1,42,db\version_set_test.cc,leveldb._Test_MultipleNullBoundaries._RunIt,,false,128,128,_RunIt,,,2,void leveldb._Test_MultipleNullBoundaries._RunIt ()
55847,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"TEST(FindFileTest, MultipleNullBoundaries) {
  Add(""150"", ""200"");
  Add(""200"", ""250"");
  Add(""300"", ""350"");
  Add(""400"", ""450"");
  ASSERT_TRUE(! Overlaps(NULL, ""149""));
  ASSERT_TRUE(! Overlaps(""451"", NULL));
  ASSERT_TRUE(Overlaps(NULL, NULL));
  ASSERT_TRUE(Overlaps(NULL, ""150""));
  ASSERT_TRUE(Overlaps(NULL, ""199""));
  ASSERT_TRUE(Overlaps(NULL, ""200""));
  ASSERT_TRUE(Overlaps(NULL, ""201""));
  ASSERT_TRUE(Overlaps(NULL, ""400""));
  ASSERT_TRUE(Overlaps(NULL, ""800""));
  ASSERT_TRUE(Overlaps(""100"", NULL));
  ASSERT_TRUE(Overlaps(""200"", NULL));
  ASSERT_TRUE(Overlaps(""449"", NULL));
  ASSERT_TRUE(Overlaps(""450"", NULL));
}",1,42,db\version_set_test.cc,leveldb._Test_MultipleNullBoundaries._Run,,false,128,146,_Run,,,17,void leveldb._Test_MultipleNullBoundaries._Run ()
56087,METHOD,leveldb._Test_OverlapSequenceChecks,TYPE_DECL,void void ();,1,41,db\version_set_test.cc,leveldb._Test_OverlapSequenceChecks._Run,,false,148,148,_Run,,,1,void leveldb._Test_OverlapSequenceChecks._Run ()
56091,METHOD,leveldb._Test_OverlapSequenceChecks,TYPE_DECL,"TEST(FindFileTest, OverlapSequenceChecks)",1,41,db\version_set_test.cc,leveldb._Test_OverlapSequenceChecks._RunIt,,false,148,148,_RunIt,,,2,void leveldb._Test_OverlapSequenceChecks._RunIt ()
56115,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"TEST(FindFileTest, OverlapSequenceChecks) {
  Add(""200"", ""200"", 5000, 3000);
  ASSERT_TRUE(! Overlaps(""199"", ""199""));
  ASSERT_TRUE(! Overlaps(""201"", ""300""));
  ASSERT_TRUE(Overlaps(""200"", ""200""));
  ASSERT_TRUE(Overlaps(""190"", ""200""));
  ASSERT_TRUE(Overlaps(""200"", ""210""));
}",1,41,db\version_set_test.cc,leveldb._Test_OverlapSequenceChecks._Run,,false,148,155,_Run,,,21,void leveldb._Test_OverlapSequenceChecks._Run ()
56212,METHOD,leveldb._Test_OverlappingFiles,TYPE_DECL,void void ();,1,36,db\version_set_test.cc,leveldb._Test_OverlappingFiles._Run,,false,157,157,_Run,,,1,void leveldb._Test_OverlappingFiles._Run ()
56216,METHOD,leveldb._Test_OverlappingFiles,TYPE_DECL,"TEST(FindFileTest, OverlappingFiles)",1,36,db\version_set_test.cc,leveldb._Test_OverlappingFiles._RunIt,,false,157,157,_RunIt,,,2,void leveldb._Test_OverlappingFiles._RunIt ()
56240,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"TEST(FindFileTest, OverlappingFiles) {
  Add(""150"", ""600"");
  Add(""400"", ""500"");
  disjoint_sorted_files_ = false;
  ASSERT_TRUE(! Overlaps(""100"", ""149""));
  ASSERT_TRUE(! Overlaps(""601"", ""700""));
  ASSERT_TRUE(Overlaps(""100"", ""150""));
  ASSERT_TRUE(Overlaps(""100"", ""200""));
  ASSERT_TRUE(Overlaps(""100"", ""300""));
  ASSERT_TRUE(Overlaps(""100"", ""400""));
  ASSERT_TRUE(Overlaps(""100"", ""500""));
  ASSERT_TRUE(Overlaps(""375"", ""400""));
  ASSERT_TRUE(Overlaps(""450"", ""450""));
  ASSERT_TRUE(Overlaps(""450"", ""500""));
  ASSERT_TRUE(Overlaps(""450"", ""700""));
  ASSERT_TRUE(Overlaps(""600"", ""700""));
}",1,36,db\version_set_test.cc,leveldb._Test_OverlappingFiles._Run,,false,157,173,_Run,,,25,void leveldb._Test_OverlappingFiles._Run ()
56459,METHOD,db\version_set_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\version_set_test.cc,main,,false,177,179,main,,,2,"int main (int,char**)"
56487,METHOD,db\write_batch.cc:<global>,TYPE_DECL,<global>,1,1,db\write_batch.cc,db\write_batch.cc:<global>,,false,1,147,<global>,,,1,
56494,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"WriteBatch::WriteBatch() {
  Clear();
}",1,1,db\write_batch.cc,leveldb.WriteBatch.WriteBatch,,false,29,31,WriteBatch,,,3,ANY leveldb.WriteBatch.WriteBatch ()
56499,METHOD,db\write_batch.cc:<global>,TYPE_DECL,WriteBatch::~WriteBatch() { },1,29,db\write_batch.cc,leveldb.WriteBatch.~WriteBatch,,false,33,33,~WriteBatch,,,4,ANY leveldb.WriteBatch.~WriteBatch ()
56503,METHOD,db\write_batch.cc:<global>,TYPE_DECL,WriteBatch::Handler::~Handler() { },1,35,db\write_batch.cc,leveldb.WriteBatch.Handler.~Handler,,false,35,35,~Handler,,,5,ANY leveldb.WriteBatch.Handler.~Handler ()
56507,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatch::Clear() {
  rep_.clear();
  rep_.resize(kHeader);
}",1,1,db\write_batch.cc,leveldb.WriteBatch.Clear,,false,37,40,Clear,,,6,void leveldb.WriteBatch.Clear ()
56520,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"Status WriteBatch::Iterate(Handler* handler) const {
  Slice input(rep_);
  if (input.size() < kHeader) {
    return Status::Corruption(""malformed WriteBatch (too small)"");
  }

  input.remove_prefix(kHeader);
  Slice key, value;
  int found = 0;
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue:
        if (GetLengthPrefixedSlice(&input, &key) &&
            GetLengthPrefixedSlice(&input, &value)) {
          handler->Put(key, value);
        } else {
          return Status::Corruption(""bad WriteBatch Put"");
        }
        break;
      case kTypeDeletion:
        if (GetLengthPrefixedSlice(&input, &key)) {
          handler->Delete(key);
        } else {
          return Status::Corruption(""bad WriteBatch Delete"");
        }
        break;
      default:
        return Status::Corruption(""unknown WriteBatch tag"");
    }
  }
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Cor...",1,1,db\write_batch.cc,leveldb.WriteBatch.Iterate,,false,42,80,Iterate,,,7,Status leveldb.WriteBatch.Iterate (Handler*)
56658,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"int WriteBatchInternal::Count(const WriteBatch* b) {
  return DecodeFixed32(b->rep_.data() + 8);
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.Count,,false,82,84,Count,,,8,int leveldb.WriteBatchInternal.Count (WriteBatch*)
56673,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
  EncodeFixed32(&b->rep_[8], n);
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.SetCount,,false,86,88,SetCount,,,9,"void leveldb.WriteBatchInternal.SetCount (WriteBatch*,int)"
56687,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
  return SequenceNumber(DecodeFixed64(b->rep_.data()));
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.Sequence,,false,90,92,Sequence,,,10,SequenceNumber leveldb.WriteBatchInternal.Sequence (WriteBatch*)
56701,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
  EncodeFixed64(&b->rep_[0], seq);
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.SetSequence,,false,94,96,SetSequence,,,11,"void leveldb.WriteBatchInternal.SetSequence (WriteBatch*,SequenceNumber)"
56715,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatch::Put(const Slice& key, const Slice& value) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeValue));
  PutLengthPrefixedSlice(&rep_, key);
  PutLengthPrefixedSlice(&rep_, value);
}",1,1,db\write_batch.cc,leveldb.WriteBatch.Put,,false,98,103,Put,,,12,"void leveldb.WriteBatch.Put (Slice,Slice)"
56748,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatch::Delete(const Slice& key) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast<char>(kTypeDeletion));
  PutLengthPrefixedSlice(&rep_, key);
}",1,1,db\write_batch.cc,leveldb.WriteBatch.Delete,,false,105,109,Delete,,,13,void leveldb.WriteBatch.Delete (Slice)
56780,METHOD,leveldb.anonymous_namespace_1.MemTableInserter,TYPE_DECL,"virtual void Put(const Slice& key, const Slice& value) {
    mem_->Add(sequence_, kTypeValue, key, value);
    sequence_++;
  }",3,3,db\write_batch.cc,leveldb.anonymous_namespace_2.MemTableInserter.Put,,false,117,120,Put,,,3,"void leveldb.anonymous_namespace_2.MemTableInserter.Put (Slice,Slice)"
56796,METHOD,leveldb.anonymous_namespace_1.MemTableInserter,TYPE_DECL,"virtual void Delete(const Slice& key) {
    mem_->Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }",3,3,db\write_batch.cc,leveldb.anonymous_namespace_3.MemTableInserter.Delete,,false,121,124,Delete,,,4,void leveldb.anonymous_namespace_3.MemTableInserter.Delete (Slice)
56811,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"Status WriteBatchInternal::InsertInto(const WriteBatch* b,
                                      MemTable* memtable) {
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b->Iterate(&inserter);
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.InsertInto,,false,128,134,InsertInto,,,15,"Status leveldb.WriteBatchInternal.InsertInto (WriteBatch*,MemTable*)"
56839,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
  assert(contents.size() >= kHeader);
  b->rep_.assign(contents.data(), contents.size());
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.SetContents,,false,136,139,SetContents,,,16,"void leveldb.WriteBatchInternal.SetContents (WriteBatch*,Slice)"
56866,METHOD,db\write_batch.cc:<global>,TYPE_DECL,"void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {
  SetCount(dst, Count(dst) + Count(src));
  assert(src->rep_.size() >= kHeader);
  dst->rep_.append(src->rep_.data() + kHeader, src->rep_.size() - kHeader);
}",1,1,db\write_batch.cc,leveldb.WriteBatchInternal.Append,,false,141,145,Append,,,17,"void leveldb.WriteBatchInternal.Append (WriteBatch*,WriteBatch*)"
56917,METHOD,db\write_batch_internal.hpp:<global>,TYPE_DECL,<global>,1,1,db\write_batch_internal.hpp,db\write_batch_internal.hpp:<global>,,false,1,50,<global>,,,1,
56922,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,static int Count(const WriteBatch* batch);,14,43,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.Count,,false,20,20,Count,,,1,int leveldb.WriteBatchInternal.Count (WriteBatch*)
56927,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static void SetCount(WriteBatch* batch, int n);",15,48,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.SetCount,,false,23,23,SetCount,,,2,"void leveldb.WriteBatchInternal.SetCount (WriteBatch*,int)"
56933,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,static SequenceNumber Sequence(const WriteBatch* batch);,25,57,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.Sequence,,false,26,26,Sequence,,,3,SequenceNumber leveldb.WriteBatchInternal.Sequence (WriteBatch*)
56938,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static void SetSequence(WriteBatch* batch, SequenceNumber seq);",15,64,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.SetSequence,,false,30,30,SetSequence,,,4,"void leveldb.WriteBatchInternal.SetSequence (WriteBatch*,SequenceNumber)"
56944,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static Slice Contents(const WriteBatch* batch) {
    return Slice(batch->rep_);
  }",3,3,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.Contents,,false,32,34,Contents,,,5,Slice leveldb.WriteBatchInternal.Contents (WriteBatch*)
56954,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static size_t ByteSize(const WriteBatch* batch) {
    return batch->rep_.size();
  }",3,3,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.ByteSize,,false,36,38,ByteSize,,,6,size_t leveldb.WriteBatchInternal.ByteSize (WriteBatch*)
56966,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static void SetContents(WriteBatch* batch, const Slice& contents);",15,67,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.SetContents,,false,40,40,SetContents,,,7,"void leveldb.WriteBatchInternal.SetContents (WriteBatch*,Slice)"
56972,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static Status InsertInto(const WriteBatch* batch, MemTable* memtable);",17,71,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.InsertInto,,false,42,42,InsertInto,,,8,"Status leveldb.WriteBatchInternal.InsertInto (WriteBatch*,MemTable*)"
56978,METHOD,leveldb.WriteBatchInternal,TYPE_DECL,"static void Append(WriteBatch* dst, const WriteBatch* src);",15,60,db\write_batch_internal.hpp,leveldb.WriteBatchInternal.Append,,false,44,44,Append,,,9,"void leveldb.WriteBatchInternal.Append (WriteBatch*,WriteBatch*)"
56999,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,<global>,1,1,db\write_batch_test.cc,db\write_batch_test.cc:<global>,,false,1,120,<global>,,,1,
57002,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,"static std::string PrintContents(WriteBatch* b) {
  InternalKeyComparator cmp(BytewiseComparator());
  MemTable* mem = new MemTable(cmp);
  mem->Ref();
  std::string state;
  Status s = WriteBatchInternal::InsertInto(b, mem);
  int count = 0;
  Iterator* iter = mem->NewIterator();
  for (iter->SeekToFirst(); iter->Valid(); iter->Next()) {
    ParsedInternalKey ikey;
    ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey));
    switch (ikey.type) {
      case kTypeValue:
        state.append(""Put("");
        state.append(ikey.user_key.ToString());
        state.append("", "");
        state.append(iter->value().ToString());
        state.append("")"");
        count++;
        break;
      case kTypeDeletion:
        state.append(""Delete("");
        state.append(ikey.user_key.ToString());
        state.append("")"");
        count++;
        break;
    }
    state.append(""@"");
    state.append(NumberToString(ikey.sequence));
  }
  delete iter;
  if (!s.ok()) {
    state.append(""ParseError()"")...",1,4,db\write_batch_test.cc,leveldb.PrintContents,,false,15,53,PrintContents,,,1,string leveldb.PrintContents (WriteBatch*)
57200,METHOD,leveldb._Test_Empty,TYPE_DECL,void void ();,1,27,db\write_batch_test.cc,leveldb._Test_Empty._Run,,false,57,57,_Run,,,1,void leveldb._Test_Empty._Run ()
57204,METHOD,leveldb._Test_Empty,TYPE_DECL,"TEST(WriteBatchTest, Empty)",1,27,db\write_batch_test.cc,leveldb._Test_Empty._RunIt,,false,57,57,_RunIt,,,2,void leveldb._Test_Empty._RunIt ()
57228,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,"TEST(WriteBatchTest, Empty) {
  WriteBatch batch;
  ASSERT_EQ("""", PrintContents(&batch));
  ASSERT_EQ(0, WriteBatchInternal::Count(&batch));
}",1,27,db\write_batch_test.cc,leveldb._Test_Empty._Run,,false,57,61,_Run,,,6,void leveldb._Test_Empty._Run ()
57282,METHOD,leveldb._Test_Multiple,TYPE_DECL,void void ();,1,30,db\write_batch_test.cc,leveldb._Test_Multiple._Run,,false,63,63,_Run,,,1,void leveldb._Test_Multiple._Run ()
57286,METHOD,leveldb._Test_Multiple,TYPE_DECL,"TEST(WriteBatchTest, Multiple)",1,30,db\write_batch_test.cc,leveldb._Test_Multiple._RunIt,,false,63,63,_RunIt,,,2,void leveldb._Test_Multiple._RunIt ()
57310,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,"TEST(WriteBatchTest, Multiple) {
  WriteBatch batch;
  batch.Put(Slice(""foo""), Slice(""bar""));
  batch.Delete(Slice(""box""));
  batch.Put(Slice(""baz""), Slice(""boo""));
  WriteBatchInternal::SetSequence(&batch, 100);
  ASSERT_EQ(100, WriteBatchInternal::Sequence(&batch));
  ASSERT_EQ(3, WriteBatchInternal::Count(&batch));
  ASSERT_EQ(""Put(baz, boo)@102""
            ""Delete(box)@101""
            ""Put(foo, bar)@100"",
            PrintContents(&batch));
}",1,30,db\write_batch_test.cc,leveldb._Test_Multiple._Run,,false,63,75,_Run,,,10,void leveldb._Test_Multiple._Run ()
57419,METHOD,leveldb._Test_Corruption,TYPE_DECL,void void ();,1,32,db\write_batch_test.cc,leveldb._Test_Corruption._Run,,false,77,77,_Run,,,1,void leveldb._Test_Corruption._Run ()
57423,METHOD,leveldb._Test_Corruption,TYPE_DECL,"TEST(WriteBatchTest, Corruption)",1,32,db\write_batch_test.cc,leveldb._Test_Corruption._RunIt,,false,77,77,_RunIt,,,2,void leveldb._Test_Corruption._RunIt ()
57447,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,"TEST(WriteBatchTest, Corruption) {
  WriteBatch batch;
  batch.Put(Slice(""foo""), Slice(""bar""));
  batch.Delete(Slice(""box""));
  WriteBatchInternal::SetSequence(&batch, 200);
  Slice contents = WriteBatchInternal::Contents(&batch);
  WriteBatchInternal::SetContents(&batch,
                                  Slice(contents.data(),contents.size()-1));
  ASSERT_EQ(""Put(foo, bar)@200""
            ""ParseError()"",
            PrintContents(&batch));
}",1,32,db\write_batch_test.cc,leveldb._Test_Corruption._Run,,false,77,88,_Run,,,14,void leveldb._Test_Corruption._Run ()
57520,METHOD,leveldb._Test_Append,TYPE_DECL,void void ();,1,28,db\write_batch_test.cc,leveldb._Test_Append._Run,,false,90,90,_Run,,,1,void leveldb._Test_Append._Run ()
57524,METHOD,leveldb._Test_Append,TYPE_DECL,"TEST(WriteBatchTest, Append)",1,28,db\write_batch_test.cc,leveldb._Test_Append._RunIt,,false,90,90,_RunIt,,,2,void leveldb._Test_Append._RunIt ()
57548,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,"TEST(WriteBatchTest, Append) {
  WriteBatch b1, b2;
  WriteBatchInternal::SetSequence(&b1, 200);
  WriteBatchInternal::SetSequence(&b2, 300);
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ("""",
            PrintContents(&b1));
  b2.Put(""a"", ""va"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200"",
            PrintContents(&b1));
  b2.Clear();
  b2.Put(""b"", ""vb"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@201"",
            PrintContents(&b1));
  b2.Delete(""foo"");
  WriteBatchInternal::Append(&b1, &b2);
  ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@202""
            ""Put(b, vb)@201""
            ""Delete(foo)@203"",
            PrintContents(&b1));
}",1,28,db\write_batch_test.cc,leveldb._Test_Append._Run,,false,90,114,_Run,,,18,void leveldb._Test_Append._Run ()
57702,METHOD,db\write_batch_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,db\write_batch_test.cc,main,,false,118,120,main,,,2,"int main (int,char**)"
57730,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,<global>,1,23,doc\bench\db_bench_sqlite3.cc,doc\bench\db_bench_sqlite3.cc:<global>,,false,1,718,<global>,,,1,
57781,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,"inline
static void ExecErrorCheck(int status, char *err_msg) {
  if (status != SQLITE_OK) {
    fprintf(stderr, ""SQL error: %s\n"", err_msg);
    sqlite3_free(err_msg);
    exit(1);
  }
}",1,1,doc\bench\db_bench_sqlite3.cc,ExecErrorCheck,,false,81,88,ExecErrorCheck,,,25,"void ExecErrorCheck (int,char*)"
57800,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,"inline
static void StepErrorCheck(int status) {
  if (status != SQLITE_DONE) {
    fprintf(stderr, ""SQL step error: status = %d\n"", status);
    exit(1);
  }
}",1,1,doc\bench\db_bench_sqlite3.cc,StepErrorCheck,,false,90,96,StepErrorCheck,,,26,void StepErrorCheck (int)
57816,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,"inline
static void ErrorCheck(int status) {
  if (status != SQLITE_OK) {
    fprintf(stderr, ""sqlite3 error: status = %d\n"", status);
    exit(1);
  }
}",1,1,doc\bench\db_bench_sqlite3.cc,ErrorCheck,,false,98,104,ErrorCheck,,,27,void ErrorCheck (int)
57832,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,"inline
static void WalCheckpoint(sqlite3* db_) {
  // Flush all writes to disk
  if (FLAGS_WAL_enabled) {
    sqlite3_wal_checkpoint_v2(db_, NULL, SQLITE_CHECKPOINT_FULL, NULL, NULL);
  }
}",1,1,doc\bench\db_bench_sqlite3.cc,WalCheckpoint,,false,106,112,WalCheckpoint,,,28,void WalCheckpoint (sqlite3*)
57851,METHOD,leveldb.anonymous_namespace_1.RandomGenerator,TYPE_DECL,"RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator,,false,124,137,RandomGenerator,,,3,ANY leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator ()
57885,METHOD,leveldb.anonymous_namespace_1.RandomGenerator,TYPE_DECL,"Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.anonymous_namespace_3.RandomGenerator.Generate,,false,139,146,Generate,,,4,Slice leveldb.anonymous_namespace_3.RandomGenerator.Generate (int)
57924,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,"static Slice TrimSpace(Slice s) {
  int start = 0;
  while (start < s.size() && isspace(s[start])) {
    start++;
  }
  int limit = s.size();
  while (limit > start && isspace(s[limit-1])) {
    limit--;
  }
  return Slice(s.data() + start, limit - start);
}",1,1,doc\bench\db_bench_sqlite3.cc,leveldb.anonymous_namespace_4.TrimSpace,,false,149,159,TrimSpace,,,2,Slice leveldb.anonymous_namespace_4.TrimSpace (Slice)
57994,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each\n"", FLAGS_value_size);
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.PrintHeader,,false,181,192,PrintHeader,,,14,void leveldb.Benchmark.PrintHeader ()
58031,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintWarnings() {
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.PrintWarnings,,false,194,204,PrintWarnings,,,15,void leveldb.Benchmark.PrintWarnings ()
58038,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintEnvironment() {
    fprintf(stderr, ""SQLite:     version %s\n"", SQLITE_VERSION);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:       %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(stderr, ""CPU:        %d * %s\n"", num_cpus, cpu_type.c_str());
      fprintf(stderr, ""CPUCache:   %...",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.PrintEnvironment,,false,206,238,PrintEnvironment,,,16,void leveldb.Benchmark.PrintEnvironment ()
58046,METHOD,leveldb.Benchmark,TYPE_DECL,"void Start() {
    start_ = Env::Default()->NowMicros() * 1e-6;
    bytes_ = 0;
    message_.clear();
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    next_report_ = 100;
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Start,,false,240,248,Start,,,17,void leveldb.Benchmark.Start ()
58081,METHOD,leveldb.Benchmark,TYPE_DECL,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.FinishedSingleOp,,false,250,274,FinishedSingleOp,,,18,void leveldb.Benchmark.FinishedSingleOp ()
58203,METHOD,leveldb.Benchmark,TYPE_DECL,"void Stop(const Slice& name) {
    double finish = Env::Default()->NowMicros() * 1e-6;

    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    if (bytes_ > 0) {
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            (finish - start_) * 1e6 / done_,
            (message_.empty() ? """" : "" ""),
            message_.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Stop,,false,276,303,Stop,,,19,void leveldb.Benchmark.Stop (Slice)
58317,METHOD,leveldb.Benchmark,TYPE_DECL,"Benchmark()
  : db_(NULL),
    db_num_(0),
    num_(FLAGS_num),
    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),
    bytes_(0),
    rand_(301) {
    std::vector<std::string> files;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    Env::Default()->GetChildren(test_dir, &files);
    if (!FLAGS_use_existing_db) {
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_sqlite3"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Benchmark,,false,315,336,Benchmark,,,22,ANY leveldb.Benchmark.Benchmark ()
58401,METHOD,leveldb.Benchmark,TYPE_DECL,"~Benchmark() {
    int status = sqlite3_close(db_);
    ErrorCheck(status);
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.~Benchmark,,false,338,341,~Benchmark,,,23,ANY leveldb.Benchmark.~Benchmark ()
58412,METHOD,leveldb.Benchmark,TYPE_DECL,"void Run() {
    PrintHeader();
    Open();

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      bytes_ = 0;
      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillseqbatch"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1000);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        WalCheckpoint(db_);
      } else if (name == Slice(""fillrandbatch"")) {
        Write(write_sync, RANDOM, FRESH, ...",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Run,,false,343,415,Run,,,24,void leveldb.Benchmark.Run ()
58723,METHOD,leveldb.Benchmark,TYPE_DECL,"void Open() {
    assert(db_ == NULL);

    int status;
    char file_name[100];
    char* err_msg = NULL;
    db_num_++;

    // Open database
    std::string tmp_dir;
    Env::Default()->GetTestDirectory(&tmp_dir);
    snprintf(file_name, sizeof(file_name),
             ""%s/dbbench_sqlite3-%d.db"",
             tmp_dir.c_str(),
             db_num_);
    status = sqlite3_open(file_name, &db_);
    if (status) {
      fprintf(stderr, ""open error: %s\n"", sqlite3_errmsg(db_));
      exit(1);
    }

    // Change SQLite cache size
    char cache_size[100];
    snprintf(cache_size, sizeof(cache_size), ""PRAGMA cache_size = %d"",
             FLAGS_num_pages);
    status = sqlite3_exec(db_, cache_size, NULL, NULL, &err_msg);
    ExecErrorCheck(status, err_msg);

    // FLAGS_page_size is defaulted to 1024
    if (FLAGS_page_size != 1024) {
      char page_size[100];
      snprintf(page_size, sizeof(page_size), ""PRAGMA page_size = %d"",
               FLAGS_page_size);
      status = sqlite3...",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Open,,false,417,476,Open,,,25,void leveldb.Benchmark.Open ()
58910,METHOD,leveldb.Benchmark,TYPE_DECL,"void Write(bool write_sync, Order order, DBState state,
             int num_entries, int value_size, int entries_per_batch) {
    // Create new database if state == FRESH
    if (state == FRESH) {
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      sqlite3_close(db_);
      db_ = NULL;
      Open();
      Start();
    }

    if (num_entries != num_) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }

    char* err_msg = NULL;
    int status;

    sqlite3_stmt *replace_stmt, *begin_trans_stmt, *end_trans_stmt;
    std::string replace_str = ""REPLACE INTO test (key, value) VALUES (?, ?)"";
    std::string begin_trans_str = ""BEGIN TRANSACTION;"";
    std::string end_trans_str = ""END TRANSACTION;"";

    // Check for synchronous flag in options
    std::string sync_stmt = (write_sync) ? ""PRAGMA synchronous = FULL"" :
                                           ""P...",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Write,,false,478,579,Write,,,26,"void leveldb.Benchmark.Write (bool,Order,DBState,int,int,int)"
59203,METHOD,leveldb.Benchmark,TYPE_DECL,"void Read(Order order, int entries_per_batch) {
    int status;
    sqlite3_stmt *read_stmt, *begin_trans_stmt, *end_trans_stmt;

    std::string read_str = ""SELECT * FROM test WHERE key = ?"";
    std::string begin_trans_str = ""BEGIN TRANSACTION;"";
    std::string end_trans_str = ""END TRANSACTION;"";

    // Preparing sqlite3 statements
    status = sqlite3_prepare_v2(db_, begin_trans_str.c_str(), -1,
                                &begin_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, end_trans_str.c_str(), -1,
                                &end_trans_stmt, NULL);
    ErrorCheck(status);
    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &read_stmt, NULL);
    ErrorCheck(status);

    bool transaction = (entries_per_batch > 1);
    for (int i = 0; i < reads_; i += entries_per_batch) {
      // Begin read transaction
      if (FLAGS_transaction && transaction) {
        status = sqlite3_step(begin_trans_stmt);
        StepErrorCheck(status);...",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.Read,,false,581,647,Read,,,27,"void leveldb.Benchmark.Read (Order,int)"
59409,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadSequential() {
    int status;
    sqlite3_stmt *pStmt;
    std::string read_str = ""SELECT * FROM test ORDER BY key"";

    status = sqlite3_prepare_v2(db_, read_str.c_str(), -1, &pStmt, NULL);
    ErrorCheck(status);
    for (int i = 0; i < reads_ && SQLITE_ROW == sqlite3_step(pStmt); i++) {
      bytes_ += sqlite3_column_bytes(pStmt, 1) + sqlite3_column_bytes(pStmt, 2);
      FinishedSingleOp();
    }

    status = sqlite3_finalize(pStmt);
    ErrorCheck(status);
  }",3,3,doc\bench\db_bench_sqlite3.cc,leveldb.Benchmark.ReadSequential,,false,649,663,ReadSequential,,,28,void leveldb.Benchmark.ReadSequential ()
59467,METHOD,doc\bench\db_bench_sqlite3.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  std::string default_db_path;
  for (int i = 1; i < argc; i++) {
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--use_existing_db=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_use_existing_db = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--value_size=%d%c"", &n, &junk) == 1) {
      FLAGS_value_size = n;
    } else if (leveldb::Slice(argv[i]) == leveldb::Slice(""--no_tra...",1,1,doc\bench\db_bench_sqlite3.cc,main,,false,669,718,main,,,30,"int main (int,char**)"
59792,METHOD,doc\bench\db_bench_tree_db.cc:<global>,TYPE_DECL,<global>,1,24,doc\bench\db_bench_tree_db.cc,doc\bench\db_bench_tree_db.cc:<global>,,false,1,528,<global>,,,1,
59839,METHOD,doc\bench\db_bench_tree_db.cc:<global>,TYPE_DECL,"inline
static void DBSynchronize(kyotocabinet::TreeDB* db_)
{
  // Synchronize will flush writes to disk
  if (!db_->synchronize()) {
    fprintf(stderr, ""synchronize error: %s\n"", db_->error().name());
  }
}",1,1,doc\bench\db_bench_tree_db.cc,DBSynchronize,,false,74,81,DBSynchronize,,,23,void DBSynchronize (ANY*)
59866,METHOD,leveldb.anonymous_namespace_1.RandomGenerator,TYPE_DECL,"RandomGenerator() {
    // We use a limited amount of data over and over again and ensure
    // that it is larger than the compression window (32KB), and also
    // large enough to serve all typical value sizes we want to write.
    Random rnd(301);
    std::string piece;
    while (data_.size() < 1048576) {
      // Add a short fragment that is as compressible as specified
      // by FLAGS_compression_ratio.
      test::CompressibleString(&rnd, FLAGS_compression_ratio, 100, &piece);
      data_.append(piece);
    }
    pos_ = 0;
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator,,false,93,106,RandomGenerator,,,3,ANY leveldb.anonymous_namespace_2.RandomGenerator.RandomGenerator ()
59900,METHOD,leveldb.anonymous_namespace_1.RandomGenerator,TYPE_DECL,"Slice Generate(int len) {
    if (pos_ + len > data_.size()) {
      pos_ = 0;
      assert(len < data_.size());
    }
    pos_ += len;
    return Slice(data_.data() + pos_ - len, len);
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.anonymous_namespace_3.RandomGenerator.Generate,,false,108,115,Generate,,,4,Slice leveldb.anonymous_namespace_3.RandomGenerator.Generate (int)
59939,METHOD,doc\bench\db_bench_tree_db.cc:<global>,TYPE_DECL,"static Slice TrimSpace(Slice s) {
  int start = 0;
  while (start < s.size() && isspace(s[start])) {
    start++;
  }
  int limit = s.size();
  while (limit > start && isspace(s[limit-1])) {
    limit--;
  }
  return Slice(s.data() + start, limit - start);
}",1,1,doc\bench\db_bench_tree_db.cc,leveldb.anonymous_namespace_4.TrimSpace,,false,118,128,TrimSpace,,,2,Slice leveldb.anonymous_namespace_4.TrimSpace (Slice)
60010,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintHeader() {
    const int kKeySize = 16;
    PrintEnvironment();
    fprintf(stdout, ""Keys:       %d bytes each\n"", kKeySize);
    fprintf(stdout, ""Values:     %d bytes each (%d bytes after compression)\n"",
            FLAGS_value_size,
            static_cast<int>(FLAGS_value_size * FLAGS_compression_ratio + 0.5));
    fprintf(stdout, ""Entries:    %d\n"", num_);
    fprintf(stdout, ""RawSize:    %.1f MB (estimated)\n"",
            ((static_cast<int64_t>(kKeySize + FLAGS_value_size) * num_)
             / 1048576.0));
    fprintf(stdout, ""FileSize:   %.1f MB (estimated)\n"",
            (((kKeySize + FLAGS_value_size * FLAGS_compression_ratio) * num_)
             / 1048576.0));
    PrintWarnings();
    fprintf(stdout, ""------------------------------------------------\n"");
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.PrintHeader,,false,151,167,PrintHeader,,,15,void leveldb.Benchmark.PrintHeader ()
60066,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintWarnings() {
#if defined(__GNUC__) && !defined(__OPTIMIZE__)
    fprintf(stdout,
            ""WARNING: Optimization is disabled: benchmarks unnecessarily slow\n""
            );
#endif
#ifndef NDEBUG
    fprintf(stdout,
            ""WARNING: Assertions are enabled; benchmarks unnecessarily slow\n"");
#endif
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.PrintWarnings,,false,169,179,PrintWarnings,,,16,void leveldb.Benchmark.PrintWarnings ()
60073,METHOD,leveldb.Benchmark,TYPE_DECL,"void PrintEnvironment() {
    fprintf(stderr, ""Kyoto Cabinet:    version %s, lib ver %d, lib rev %d\n"",
            kyotocabinet::VERSION, kyotocabinet::LIBVER, kyotocabinet::LIBREV);

#if defined(__linux)
    time_t now = time(NULL);
    fprintf(stderr, ""Date:           %s"", ctime(&now));  // ctime() adds newline

    FILE* cpuinfo = fopen(""/proc/cpuinfo"", ""r"");
    if (cpuinfo != NULL) {
      char line[1000];
      int num_cpus = 0;
      std::string cpu_type;
      std::string cache_size;
      while (fgets(line, sizeof(line), cpuinfo) != NULL) {
        const char* sep = strchr(line, ':');
        if (sep == NULL) {
          continue;
        }
        Slice key = TrimSpace(Slice(line, sep - 1 - line));
        Slice val = TrimSpace(Slice(sep + 1));
        if (key == ""model name"") {
          ++num_cpus;
          cpu_type = val.ToString();
        } else if (key == ""cache size"") {
          cache_size = val.ToString();
        }
      }
      fclose(cpuinfo);
      fprintf(s...",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.PrintEnvironment,,false,181,214,PrintEnvironment,,,17,void leveldb.Benchmark.PrintEnvironment ()
60089,METHOD,leveldb.Benchmark,TYPE_DECL,"void Start() {
    start_ = Env::Default()->NowMicros() * 1e-6;
    bytes_ = 0;
    message_.clear();
    last_op_finish_ = start_;
    hist_.Clear();
    done_ = 0;
    next_report_ = 100;
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Start,,false,216,224,Start,,,18,void leveldb.Benchmark.Start ()
60124,METHOD,leveldb.Benchmark,TYPE_DECL,"void FinishedSingleOp() {
    if (FLAGS_histogram) {
      double now = Env::Default()->NowMicros() * 1e-6;
      double micros = (now - last_op_finish_) * 1e6;
      hist_.Add(micros);
      if (micros > 20000) {
        fprintf(stderr, ""long op: %.1f micros%30s\r"", micros, """");
        fflush(stderr);
      }
      last_op_finish_ = now;
    }

    done_++;
    if (done_ >= next_report_) {
      if      (next_report_ < 1000)   next_report_ += 100;
      else if (next_report_ < 5000)   next_report_ += 500;
      else if (next_report_ < 10000)  next_report_ += 1000;
      else if (next_report_ < 50000)  next_report_ += 5000;
      else if (next_report_ < 100000) next_report_ += 10000;
      else if (next_report_ < 500000) next_report_ += 50000;
      else                            next_report_ += 100000;
      fprintf(stderr, ""... finished %d ops%30s\r"", done_, """");
      fflush(stderr);
    }
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.FinishedSingleOp,,false,226,250,FinishedSingleOp,,,19,void leveldb.Benchmark.FinishedSingleOp ()
60246,METHOD,leveldb.Benchmark,TYPE_DECL,"void Stop(const Slice& name) {
    double finish = Env::Default()->NowMicros() * 1e-6;

    // Pretend at least one op was done in case we are running a benchmark
    // that does not call FinishedSingleOp().
    if (done_ < 1) done_ = 1;

    if (bytes_ > 0) {
      char rate[100];
      snprintf(rate, sizeof(rate), ""%6.1f MB/s"",
               (bytes_ / 1048576.0) / (finish - start_));
      if (!message_.empty()) {
        message_  = std::string(rate) + "" "" + message_;
      } else {
        message_ = rate;
      }
    }

    fprintf(stdout, ""%-12s : %11.3f micros/op;%s%s\n"",
            name.ToString().c_str(),
            (finish - start_) * 1e6 / done_,
            (message_.empty() ? """" : "" ""),
            message_.c_str());
    if (FLAGS_histogram) {
      fprintf(stdout, ""Microseconds per op:\n%s\n"", hist_.ToString().c_str());
    }
    fflush(stdout);
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Stop,,false,252,279,Stop,,,20,void leveldb.Benchmark.Stop (Slice)
60360,METHOD,leveldb.Benchmark,TYPE_DECL,"Benchmark()
  : db_(NULL),
    num_(FLAGS_num),
    reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),
    bytes_(0),
    rand_(301) {
    std::vector<std::string> files;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    Env::Default()->GetChildren(test_dir.c_str(), &files);
    if (!FLAGS_use_existing_db) {
      for (int i = 0; i < files.size(); i++) {
        if (Slice(files[i]).starts_with(""dbbench_polyDB"")) {
          std::string file_name(test_dir);
          file_name += ""/"";
          file_name += files[i];
          Env::Default()->DeleteFile(file_name.c_str());
        }
      }
    }
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Benchmark,,false,291,311,Benchmark,,,23,ANY leveldb.Benchmark.Benchmark ()
60447,METHOD,leveldb.Benchmark,TYPE_DECL,"~Benchmark() {
    if (!db_->close()) {
      fprintf(stderr, ""close error: %s\n"", db_->error().name());
    }
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.~Benchmark,,false,313,317,~Benchmark,,,24,ANY leveldb.Benchmark.~Benchmark ()
60468,METHOD,leveldb.Benchmark,TYPE_DECL,"void Run() {
    PrintHeader();
    Open(false);

    const char* benchmarks = FLAGS_benchmarks;
    while (benchmarks != NULL) {
      const char* sep = strchr(benchmarks, ',');
      Slice name;
      if (sep == NULL) {
        name = benchmarks;
        benchmarks = NULL;
      } else {
        name = Slice(benchmarks, sep - benchmarks);
        benchmarks = sep + 1;
      }

      Start();

      bool known = true;
      bool write_sync = false;
      if (name == Slice(""fillseq"")) {
        Write(write_sync, SEQUENTIAL, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandom"")) {
        Write(write_sync, RANDOM, FRESH, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""overwrite"")) {
        Write(write_sync, RANDOM, EXISTING, num_, FLAGS_value_size, 1);
        DBSynchronize(db_);
      } else if (name == Slice(""fillrandsync"")) {
        write_sync = true;
        Write(write_sync, RANDOM, F...",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Run,,false,319,386,Run,,,25,void leveldb.Benchmark.Run ()
60741,METHOD,leveldb.Benchmark,TYPE_DECL,"void Open(bool sync) {
    assert(db_ == NULL);

    // Initialize db_
    db_ = new kyotocabinet::TreeDB();
    char file_name[100];
    db_num_++;
    std::string test_dir;
    Env::Default()->GetTestDirectory(&test_dir);
    snprintf(file_name, sizeof(file_name),
             ""%s/dbbench_polyDB-%d.kct"",
             test_dir.c_str(),
             db_num_);

    // Create tuning options and open the database
    int open_options = kyotocabinet::PolyDB::OWRITER |
                       kyotocabinet::PolyDB::OCREATE;
    int tune_options = kyotocabinet::TreeDB::TSMALL |
        kyotocabinet::TreeDB::TLINEAR;
    if (FLAGS_compression) {
      tune_options |= kyotocabinet::TreeDB::TCOMPRESS;
      db_->tune_compressor(&comp_);
    }
    db_->tune_options(tune_options);
    db_->tune_page_cache(FLAGS_cache_size);
    db_->tune_page(FLAGS_page_size);
    db_->tune_map(256LL<<20);
    if (sync) {
      open_options |= kyotocabinet::PolyDB::OAUTOSYNC;
    }
    if (!db_->open(file_name, ...",5,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Open,,false,389,422,Open,,,26,void leveldb.Benchmark.Open (bool)
60872,METHOD,leveldb.Benchmark,TYPE_DECL,"void Write(bool sync, Order order, DBState state,
             int num_entries, int value_size, int entries_per_batch) {
    // Create new database if state == FRESH
    if (state == FRESH) {
      if (FLAGS_use_existing_db) {
        message_ = ""skipping (--use_existing_db is true)"";
        return;
      }
      delete db_;
      db_ = NULL;
      Open(sync);
      Start();  // Do not count time taken to destroy/open
    }

    if (num_entries != num_) {
      char msg[100];
      snprintf(msg, sizeof(msg), ""(%d ops)"", num_entries);
      message_ = msg;
    }

    // Write to database
    for (int i = 0; i < num_entries; i++)
    {
      const int k = (order == SEQUENTIAL) ? i : (rand_.Next() % num_entries);
      char key[100];
      snprintf(key, sizeof(key), ""%016d"", k);
      bytes_ += value_size + strlen(key);
      std::string cpp_key = key;
      if (!db_->set(cpp_key, gen_.Generate(value_size).ToString())) {
        fprintf(stderr, ""set error: %s\n"", db_->error().name());...",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.Write,,false,424,457,Write,,,27,"void leveldb.Benchmark.Write (bool,Order,DBState,int,int,int)"
60987,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadSequential() {
    kyotocabinet::DB::Cursor* cur = db_->cursor();
    cur->jump();
    std::string ckey, cvalue;
    while (cur->get(&ckey, &cvalue, true)) {
      bytes_ += ckey.size() + cvalue.size();
      FinishedSingleOp();
    }
    delete cur;
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.ReadSequential,,false,459,468,ReadSequential,,,28,void leveldb.Benchmark.ReadSequential ()
61029,METHOD,leveldb.Benchmark,TYPE_DECL,"void ReadRandom() {
    std::string value;
    for (int i = 0; i < reads_; i++) {
      char key[100];
      const int k = rand_.Next() % reads_;
      snprintf(key, sizeof(key), ""%016d"", k);
      db_->get(key, &value);
      FinishedSingleOp();
    }
  }",3,3,doc\bench\db_bench_tree_db.cc,leveldb.Benchmark.ReadRandom,,false,470,479,ReadRandom,,,29,void leveldb.Benchmark.ReadRandom ()
61070,METHOD,doc\bench\db_bench_tree_db.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  std::string default_db_path;
  for (int i = 1; i < argc; i++) {
    double d;
    int n;
    char junk;
    if (leveldb::Slice(argv[i]).starts_with(""--benchmarks="")) {
      FLAGS_benchmarks = argv[i] + strlen(""--benchmarks="");
    } else if (sscanf(argv[i], ""--compression_ratio=%lf%c"", &d, &junk) == 1) {
      FLAGS_compression_ratio = d;
    } else if (sscanf(argv[i], ""--histogram=%d%c"", &n, &junk) == 1 &&
               (n == 0 || n == 1)) {
      FLAGS_histogram = n;
    } else if (sscanf(argv[i], ""--num=%d%c"", &n, &junk) == 1) {
      FLAGS_num = n;
    } else if (sscanf(argv[i], ""--reads=%d%c"", &n, &junk) == 1) {
      FLAGS_reads = n;
    } else if (sscanf(argv[i], ""--value_size=%d%c"", &n, &junk) == 1) {
      FLAGS_value_size = n;
    } else if (sscanf(argv[i], ""--cache_size=%d%c"", &n, &junk) == 1) {
      FLAGS_cache_size = n;
    } else if (sscanf(argv[i], ""--page_size=%d%c"", &n, &junk) == 1) {
      FLAGS_page_size = n;
    } else if (s...",1,1,doc\bench\db_bench_tree_db.cc,main,,false,484,528,main,,,25,"int main (int,char**)"
61360,METHOD,helpers\memenv\memenv.cc:<global>,TYPE_DECL,<global>,1,1,helpers\memenv\memenv.cc,helpers\memenv\memenv.cc:<global>,,false,1,398,<global>,,,1,
61365,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,"FileState() : refs_(0), size_(0) {}",3,37,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_2.FileState.FileState,,false,24,24,FileState,,,1,ANY leveldb.anonymous_namespace_2.FileState.FileState ()
61369,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,"void Ref() {
    MutexLock lock(&refs_mutex_);
    ++refs_;
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_3.FileState.Ref,,false,27,30,Ref,,,2,void leveldb.anonymous_namespace_3.FileState.Ref ()
61379,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,"void Unref() {
    bool do_delete = false;

    {
      MutexLock lock(&refs_mutex_);
      --refs_;
      assert(refs_ >= 0);
      if (refs_ <= 0) {
        do_delete = true;
      }
    }

    if (do_delete) {
      delete this;
    }
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_4.FileState.Unref,,false,33,48,Unref,,,3,void leveldb.anonymous_namespace_4.FileState.Unref ()
61411,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,uint64_t Size() const { return size_; },3,41,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_5.FileState.Size,,false,50,50,Size,,,4,uint64_t leveldb.anonymous_namespace_5.FileState.Size ()
61417,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,"Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {
    if (offset > size_) {
      return Status::IOError(""Offset greater than file size."");
    }
    const uint64_t available = size_ - offset;
    if (n > available) {
      n = static_cast<size_t>(available);
    }
    if (n == 0) {
      *result = Slice();
      return Status::OK();
    }

    assert(offset / kBlockSize <= SIZE_MAX);
    size_t block = static_cast<size_t>(offset / kBlockSize);
    size_t block_offset = offset % kBlockSize;

    if (n <= kBlockSize - block_offset) {
      // The requested bytes are all in the first block.
      *result = Slice(blocks_[block] + block_offset, n);
      return Status::OK();
    }

    size_t bytes_to_copy = n;
    char* dst = scratch;

    while (bytes_to_copy > 0) {
      size_t avail = kBlockSize - block_offset;
      if (avail > bytes_to_copy) {
        avail = bytes_to_copy;
      }
      memcpy(dst, blocks_[block] + block_offset, avail);

      bytes_to_...",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_6.FileState.Read,,false,52,93,Read,,,5,"Status leveldb.anonymous_namespace_6.FileState.Read (uint64_t,size_t,Slice*,char*)"
61565,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,"Status Append(const Slice& data) {
    const char* src = data.data();
    size_t src_len = data.size();

    while (src_len > 0) {
      size_t avail;
      size_t offset = size_ % kBlockSize;

      if (offset != 0) {
        // There is some room in the last block.
        avail = kBlockSize - offset;
      } else {
        // No room in the last block; push new one.
        blocks_.push_back(new char[kBlockSize]);
        avail = kBlockSize;
      }

      if (avail > src_len) {
        avail = src_len;
      }
      memcpy(blocks_.back() + offset, src, avail);
      src_len -= avail;
      src += avail;
      size_ += avail;
    }

    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_7.FileState.Append,,false,95,122,Append,,,6,Status leveldb.anonymous_namespace_7.FileState.Append (Slice)
61648,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,"~FileState() {
    for (std::vector<char*>::iterator i = blocks_.begin(); i != blocks_.end();
         ++i) {
      delete [] *i;
    }
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_8.FileState.~FileState,,false,126,131,~FileState,,,7,ANY leveldb.anonymous_namespace_8.FileState.~FileState ()
61673,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,FileState(const FileState&);,3,29,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_9.FileState.FileState,,false,134,134,FileState,,,8,ANY leveldb.anonymous_namespace_9.FileState.FileState (FileState)
61678,METHOD,leveldb.anonymous_namespace_1.FileState,TYPE_DECL,void operator=(const FileState&);,8,34,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_10.FileState.operator =,,false,135,135,operator =,,,9,void leveldb.anonymous_namespace_10.FileState.operator = (FileState)
61689,METHOD,<empty>,<empty>,<empty>,3,,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_11.FileState.anonymous_enum_12:<clinit>,,false,146,,<clinit>,,,2,
61699,METHOD,leveldb.anonymous_namespace_13.SequentialFileImpl,TYPE_DECL,"explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {
    file_->Ref();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_14.SequentialFileImpl.SequentialFileImpl,,false,151,153,SequentialFileImpl,,,1,ANY leveldb.anonymous_namespace_14.SequentialFileImpl.SequentialFileImpl (FileState*)
61708,METHOD,leveldb.anonymous_namespace_13.SequentialFileImpl,TYPE_DECL,"~SequentialFileImpl() {
    file_->Unref();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_15.SequentialFileImpl.~SequentialFileImpl,,false,155,157,~SequentialFileImpl,,,2,ANY leveldb.anonymous_namespace_15.SequentialFileImpl.~SequentialFileImpl ()
61716,METHOD,leveldb.anonymous_namespace_13.SequentialFileImpl,TYPE_DECL,"virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s = file_->Read(pos_, n, result, scratch);
    if (s.ok()) {
      pos_ += result->size();
    }
    return s;
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_16.SequentialFileImpl.Read,,false,159,165,Read,,,3,"Status leveldb.anonymous_namespace_16.SequentialFileImpl.Read (size_t,Slice*,char*)"
61748,METHOD,leveldb.anonymous_namespace_13.SequentialFileImpl,TYPE_DECL,"virtual Status Skip(uint64_t n) {
    if (pos_ > file_->Size()) {
      return Status::IOError(""pos_ > file_->Size()"");
    }
    const uint64_t available = file_->Size() - pos_;
    if (n > available) {
      n = available;
    }
    pos_ += n;
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_17.SequentialFileImpl.Skip,,false,167,177,Skip,,,4,Status leveldb.anonymous_namespace_17.SequentialFileImpl.Skip (uint64_t)
61795,METHOD,leveldb.anonymous_namespace_18.RandomAccessFileImpl,TYPE_DECL,"explicit RandomAccessFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_19.RandomAccessFileImpl.RandomAccessFileImpl,,false,186,188,RandomAccessFileImpl,,,1,ANY leveldb.anonymous_namespace_19.RandomAccessFileImpl.RandomAccessFileImpl (FileState*)
61804,METHOD,leveldb.anonymous_namespace_18.RandomAccessFileImpl,TYPE_DECL,"~RandomAccessFileImpl() {
    file_->Unref();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_20.RandomAccessFileImpl.~RandomAccessFileImpl,,false,190,192,~RandomAccessFileImpl,,,2,ANY leveldb.anonymous_namespace_20.RandomAccessFileImpl.~RandomAccessFileImpl ()
61812,METHOD,leveldb.anonymous_namespace_18.RandomAccessFileImpl,TYPE_DECL,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    return file_->Read(offset, n, result, scratch);
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_21.RandomAccessFileImpl.Read,,false,194,197,Read,,,3,"Status leveldb.anonymous_namespace_21.RandomAccessFileImpl.Read (uint64_t,size_t,Slice*,char*)"
61831,METHOD,leveldb.anonymous_namespace_22.WritableFileImpl,TYPE_DECL,"WritableFileImpl(FileState* file) : file_(file) {
    file_->Ref();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_23.WritableFileImpl.WritableFileImpl,,false,205,207,WritableFileImpl,,,1,ANY leveldb.anonymous_namespace_23.WritableFileImpl.WritableFileImpl (FileState*)
61840,METHOD,leveldb.anonymous_namespace_22.WritableFileImpl,TYPE_DECL,"~WritableFileImpl() {
    file_->Unref();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_24.WritableFileImpl.~WritableFileImpl,,false,209,211,~WritableFileImpl,,,2,ANY leveldb.anonymous_namespace_24.WritableFileImpl.~WritableFileImpl ()
61848,METHOD,leveldb.anonymous_namespace_22.WritableFileImpl,TYPE_DECL,"virtual Status Append(const Slice& data) {
    return file_->Append(data);
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_25.WritableFileImpl.Append,,false,213,215,Append,,,3,Status leveldb.anonymous_namespace_25.WritableFileImpl.Append (Slice)
61859,METHOD,leveldb.anonymous_namespace_22.WritableFileImpl,TYPE_DECL,virtual Status Close() { return Status::OK(); },3,49,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_26.WritableFileImpl.Close,,false,217,217,Close,,,4,Status leveldb.anonymous_namespace_26.WritableFileImpl.Close ()
61868,METHOD,leveldb.anonymous_namespace_22.WritableFileImpl,TYPE_DECL,virtual Status Flush() { return Status::OK(); },3,49,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_27.WritableFileImpl.Flush,,false,218,218,Flush,,,5,Status leveldb.anonymous_namespace_27.WritableFileImpl.Flush ()
61877,METHOD,leveldb.anonymous_namespace_22.WritableFileImpl,TYPE_DECL,virtual Status Sync() { return Status::OK(); },3,48,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_28.WritableFileImpl.Sync,,false,219,219,Sync,,,6,Status leveldb.anonymous_namespace_28.WritableFileImpl.Sync ()
61888,METHOD,leveldb.anonymous_namespace_29.NoOpLogger,TYPE_DECL,"virtual void Logv(const char* format, va_list ap) { }",3,55,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_30.NoOpLogger.Logv,,false,227,227,Logv,,,1,"void leveldb.anonymous_namespace_30.NoOpLogger.Logv (char*,va_list)"
61895,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { },3,64,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_32.InMemoryEnv.InMemoryEnv,,false,232,232,InMemoryEnv,,,1,ANY leveldb.anonymous_namespace_32.InMemoryEnv.InMemoryEnv (Env*)
61900,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual ~InMemoryEnv() {
    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      i->second->Unref();
    }
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_33.InMemoryEnv.~InMemoryEnv,,false,234,238,~InMemoryEnv,,,2,ANY leveldb.anonymous_namespace_33.InMemoryEnv.~InMemoryEnv ()
61928,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new SequentialFileImpl(file_map_[fname]);
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_34.InMemoryEnv.NewSequentialFile,,false,241,251,NewSequentialFile,,,3,"Status leveldb.anonymous_namespace_34.InMemoryEnv.NewSequentialFile (ANY,SequentialFile**)"
61974,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      *result = NULL;
      return Status::IOError(fname, ""File not found"");
    }

    *result = new RandomAccessFileImpl(file_map_[fname]);
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_35.InMemoryEnv.NewRandomAccessFile,,false,253,263,NewRandomAccessFile,,,4,"Status leveldb.anonymous_namespace_35.InMemoryEnv.NewRandomAccessFile (ANY,RandomAccessFile**)"
62020,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) != file_map_.end()) {
      DeleteFileInternal(fname);
    }

    FileState* file = new FileState();
    file->Ref();
    file_map_[fname] = file;

    *result = new WritableFileImpl(file);
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_36.InMemoryEnv.NewWritableFile,,false,265,278,NewWritableFile,,,5,"Status leveldb.anonymous_namespace_36.InMemoryEnv.NewWritableFile (ANY,WritableFile**)"
62069,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    MutexLock lock(&mutex_);
    FileState** sptr = &file_map_[fname];
    FileState* file = *sptr;
    if (file == NULL) {
      file = new FileState();
      file->Ref();
    }
    *result = new WritableFileImpl(file);
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_38.InMemoryEnv.NewAppendableFile,,false,280,291,NewAppendableFile,,,6,"Status leveldb.anonymous_namespace_38.InMemoryEnv.NewAppendableFile (ANY,WritableFile**)"
62115,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual bool FileExists(const std::string& fname) {
    MutexLock lock(&mutex_);
    return file_map_.find(fname) != file_map_.end();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_39.InMemoryEnv.FileExists,,false,293,296,FileExists,,,7,bool leveldb.anonymous_namespace_39.InMemoryEnv.FileExists (ANY)
62135,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) {
    MutexLock lock(&mutex_);
    result->clear();

    for (FileSystem::iterator i = file_map_.begin(); i != file_map_.end(); ++i){
      const std::string& filename = i->first;

      if (filename.size() >= dir.size() + 1 && filename[dir.size()] == '/' &&
          Slice(filename).starts_with(Slice(dir))) {
        result->push_back(filename.substr(dir.size() + 1));
      }
    }

    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_40.InMemoryEnv.GetChildren,,false,298,313,GetChildren,,,8,"Status leveldb.anonymous_namespace_40.InMemoryEnv.GetChildren (ANY,ANY*)"
62222,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"void DeleteFileInternal(const std::string& fname) {
    if (file_map_.find(fname) == file_map_.end()) {
      return;
    }

    file_map_[fname]->Unref();
    file_map_.erase(fname);
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_41.InMemoryEnv.DeleteFileInternal,,false,315,322,DeleteFileInternal,,,9,void leveldb.anonymous_namespace_41.InMemoryEnv.DeleteFileInternal (ANY)
62251,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status DeleteFile(const std::string& fname) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    DeleteFileInternal(fname);
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_42.InMemoryEnv.DeleteFile,,false,324,332,DeleteFile,,,10,Status leveldb.anonymous_namespace_42.InMemoryEnv.DeleteFile (ANY)
62286,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status CreateDir(const std::string& dirname) {
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_44.InMemoryEnv.CreateDir,,false,334,336,CreateDir,,,11,Status leveldb.anonymous_namespace_44.InMemoryEnv.CreateDir (ANY)
62296,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status DeleteDir(const std::string& dirname) {
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_45.InMemoryEnv.DeleteDir,,false,338,340,DeleteDir,,,12,Status leveldb.anonymous_namespace_45.InMemoryEnv.DeleteDir (ANY)
62306,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {
    MutexLock lock(&mutex_);
    if (file_map_.find(fname) == file_map_.end()) {
      return Status::IOError(fname, ""File not found"");
    }

    *file_size = file_map_[fname]->Size();
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_46.InMemoryEnv.GetFileSize,,false,342,350,GetFileSize,,,13,"Status leveldb.anonymous_namespace_46.InMemoryEnv.GetFileSize (ANY,uint64_t*)"
62349,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status RenameFile(const std::string& src,
                            const std::string& target) {
    MutexLock lock(&mutex_);
    if (file_map_.find(src) == file_map_.end()) {
      return Status::IOError(src, ""File not found"");
    }

    DeleteFileInternal(target);
    file_map_[target] = file_map_[src];
    file_map_.erase(src);
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_47.InMemoryEnv.RenameFile,,false,352,363,RenameFile,,,14,"Status leveldb.anonymous_namespace_47.InMemoryEnv.RenameFile (ANY,ANY)"
62397,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status LockFile(const std::string& fname, FileLock** lock) {
    *lock = new FileLock;
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_49.InMemoryEnv.LockFile,,false,365,368,LockFile,,,15,"Status leveldb.anonymous_namespace_49.InMemoryEnv.LockFile (ANY,FileLock**)"
62413,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status UnlockFile(FileLock* lock) {
    delete lock;
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_50.InMemoryEnv.UnlockFile,,false,370,373,UnlockFile,,,16,Status leveldb.anonymous_namespace_50.InMemoryEnv.UnlockFile (FileLock*)
62425,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status GetTestDirectory(std::string* path) {
    *path = ""/test"";
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_51.InMemoryEnv.GetTestDirectory,,false,375,378,GetTestDirectory,,,17,Status leveldb.anonymous_namespace_51.InMemoryEnv.GetTestDirectory (ANY*)
62439,METHOD,leveldb.anonymous_namespace_31.InMemoryEnv,TYPE_DECL,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    *result = new NoOpLogger;
    return Status::OK();
  }",3,3,helpers\memenv\memenv.cc,leveldb.anonymous_namespace_52.InMemoryEnv.NewLogger,,false,380,383,NewLogger,,,18,"Status leveldb.anonymous_namespace_52.InMemoryEnv.NewLogger (ANY,Logger**)"
62458,METHOD,helpers\memenv\memenv.cc:<global>,TYPE_DECL,"Env* NewMemEnv(Env* base_env) {
  return new InMemoryEnv(base_env);
}",1,1,helpers\memenv\memenv.cc,leveldb.NewMemEnv,,false,394,396,NewMemEnv,,,2,Env leveldb.NewMemEnv (Env*)
62470,METHOD,helpers\memenv\memenv.hpp:<global>,TYPE_DECL,<global>,1,51,helpers\memenv\memenv.hpp,helpers\memenv\memenv.hpp:<global>,,false,1,20,<global>,,,1,
62474,METHOD,helpers\memenv\memenv.hpp:<global>,TYPE_DECL,Env* NewMemEnv(Env* base_env);,4,29,helpers\memenv\memenv.hpp,leveldb.NewMemEnv,,false,16,16,NewMemEnv,,,2,Env* leveldb.NewMemEnv (Env*)
62496,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,<global>,1,1,helpers\memenv\memenv_test.cc,helpers\memenv\memenv_test.cc:<global>,,false,1,241,<global>,,,1,
62501,METHOD,leveldb.MemEnvTest,TYPE_DECL,"MemEnvTest()
      : env_(NewMemEnv(Env::Default())) {
  }",3,3,helpers\memenv\memenv_test.cc,leveldb.MemEnvTest.MemEnvTest,,false,20,22,MemEnvTest,,,2,ANY leveldb.MemEnvTest.MemEnvTest ()
62505,METHOD,leveldb.MemEnvTest,TYPE_DECL,"~MemEnvTest() {
    delete env_;
  }",3,3,helpers\memenv\memenv_test.cc,leveldb.MemEnvTest.~MemEnvTest,,false,23,25,~MemEnvTest,,,3,ANY leveldb.MemEnvTest.~MemEnvTest ()
62512,METHOD,leveldb._Test_Basics,TYPE_DECL,void void ();,1,24,helpers\memenv\memenv_test.cc,leveldb._Test_Basics._Run,,false,28,28,_Run,,,1,void leveldb._Test_Basics._Run ()
62516,METHOD,leveldb._Test_Basics,TYPE_DECL,"TEST(MemEnvTest, Basics)",1,24,helpers\memenv\memenv_test.cc,leveldb._Test_Basics._RunIt,,false,28,28,_RunIt,,,2,void leveldb._Test_Basics._RunIt ()
62540,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"TEST(MemEnvTest, Basics) {
  uint64_t file_size;
  WritableFile* writable_file;
  std::vector<std::string> children;

  ASSERT_OK(env_->CreateDir(""/dir""));

  // Check that the directory is empty.
  ASSERT_TRUE(!env_->FileExists(""/dir/non_existent""));
  ASSERT_TRUE(!env_->GetFileSize(""/dir/non_existent"", &file_size).ok());
  ASSERT_OK(env_->GetChildren(""/dir"", &children));
  ASSERT_EQ(0, children.size());

  // Create a file.
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size));
  ASSERT_EQ(0, file_size);
  delete writable_file;

  // Check that the file exists.
  ASSERT_TRUE(env_->FileExists(""/dir/f""));
  ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size));
  ASSERT_EQ(0, file_size);
  ASSERT_OK(env_->GetChildren(""/dir"", &children));
  ASSERT_EQ(1, children.size());
  ASSERT_EQ(""f"", children[0]);

  // Write to the file.
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""abc"")...",1,24,helpers\memenv\memenv_test.cc,leveldb._Test_Basics._Run,,false,28,94,_Run,,,5,void leveldb._Test_Basics._Run ()
63386,METHOD,leveldb._Test_ReadWrite,TYPE_DECL,void void ();,1,27,helpers\memenv\memenv_test.cc,leveldb._Test_ReadWrite._Run,,false,96,96,_Run,,,1,void leveldb._Test_ReadWrite._Run ()
63390,METHOD,leveldb._Test_ReadWrite,TYPE_DECL,"TEST(MemEnvTest, ReadWrite)",1,27,helpers\memenv\memenv_test.cc,leveldb._Test_ReadWrite._RunIt,,false,96,96,_RunIt,,,2,void leveldb._Test_ReadWrite._RunIt ()
63414,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"TEST(MemEnvTest, ReadWrite) {
  WritableFile* writable_file;
  SequentialFile* seq_file;
  RandomAccessFile* rand_file;
  Slice result;
  char scratch[100];

  ASSERT_OK(env_->CreateDir(""/dir""));

  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""hello ""));
  ASSERT_OK(writable_file->Append(""world""));
  delete writable_file;

  // Read sequentially.
  ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file));
  ASSERT_OK(seq_file->Read(5, &result, scratch)); // Read ""hello"".
  ASSERT_EQ(0, result.compare(""hello""));
  ASSERT_OK(seq_file->Skip(1));
  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Read ""world"".
  ASSERT_EQ(0, result.compare(""world""));
  ASSERT_OK(seq_file->Read(1000, &result, scratch)); // Try reading past EOF.
  ASSERT_EQ(0, result.size());
  ASSERT_OK(seq_file->Skip(100)); // Try to skip past end of file.
  ASSERT_OK(seq_file->Read(1000, &result, scratch));
  ASSERT_EQ(0, result.size());
  delete seq_file;

  // Ran...",1,27,helpers\memenv\memenv_test.cc,leveldb._Test_ReadWrite._Run,,false,96,136,_Run,,,9,void leveldb._Test_ReadWrite._Run ()
63948,METHOD,leveldb._Test_Locks,TYPE_DECL,void void ();,1,23,helpers\memenv\memenv_test.cc,leveldb._Test_Locks._Run,,false,138,138,_Run,,,1,void leveldb._Test_Locks._Run ()
63952,METHOD,leveldb._Test_Locks,TYPE_DECL,"TEST(MemEnvTest, Locks)",1,23,helpers\memenv\memenv_test.cc,leveldb._Test_Locks._RunIt,,false,138,138,_RunIt,,,2,void leveldb._Test_Locks._RunIt ()
63976,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"TEST(MemEnvTest, Locks) {
  FileLock* lock;

  // These are no-ops, but we test they return success.
  ASSERT_OK(env_->LockFile(""some file"", &lock));
  ASSERT_OK(env_->UnlockFile(lock));
}",1,23,helpers\memenv\memenv_test.cc,leveldb._Test_Locks._Run,,false,138,144,_Run,,,13,void leveldb._Test_Locks._Run ()
64025,METHOD,leveldb._Test_Misc,TYPE_DECL,void void ();,1,22,helpers\memenv\memenv_test.cc,leveldb._Test_Misc._Run,,false,146,146,_Run,,,1,void leveldb._Test_Misc._Run ()
64029,METHOD,leveldb._Test_Misc,TYPE_DECL,"TEST(MemEnvTest, Misc)",1,22,helpers\memenv\memenv_test.cc,leveldb._Test_Misc._RunIt,,false,146,146,_RunIt,,,2,void leveldb._Test_Misc._RunIt ()
64053,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"TEST(MemEnvTest, Misc) {
  std::string test_dir;
  ASSERT_OK(env_->GetTestDirectory(&test_dir));
  ASSERT_TRUE(!test_dir.empty());

  WritableFile* writable_file;
  ASSERT_OK(env_->NewWritableFile(""/a/b"", &writable_file));

  // These are no-ops, but we test they return success.
  ASSERT_OK(writable_file->Sync());
  ASSERT_OK(writable_file->Flush());
  ASSERT_OK(writable_file->Close());
  delete writable_file;
}",1,22,helpers\memenv\memenv_test.cc,leveldb._Test_Misc._Run,,false,146,159,_Run,,,17,void leveldb._Test_Misc._Run ()
64194,METHOD,leveldb._Test_LargeWrite,TYPE_DECL,void void ();,1,28,helpers\memenv\memenv_test.cc,leveldb._Test_LargeWrite._Run,,false,161,161,_Run,,,1,void leveldb._Test_LargeWrite._Run ()
64198,METHOD,leveldb._Test_LargeWrite,TYPE_DECL,"TEST(MemEnvTest, LargeWrite)",1,28,helpers\memenv\memenv_test.cc,leveldb._Test_LargeWrite._RunIt,,false,161,161,_RunIt,,,2,void leveldb._Test_LargeWrite._RunIt ()
64222,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"TEST(MemEnvTest, LargeWrite) {
  const size_t kWriteSize = 300 * 1024;
  char* scratch = new char[kWriteSize * 2];

  std::string write_data;
  for (size_t i = 0; i < kWriteSize; ++i) {
    write_data.append(1, static_cast<char>(i));
  }

  WritableFile* writable_file;
  ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file));
  ASSERT_OK(writable_file->Append(""foo""));
  ASSERT_OK(writable_file->Append(write_data));
  delete writable_file;

  SequentialFile* seq_file;
  Slice result;
  ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file));
  ASSERT_OK(seq_file->Read(3, &result, scratch)); // Read ""foo"".
  ASSERT_EQ(0, result.compare(""foo""));

  size_t read = 0;
  std::string read_data;
  while (read < kWriteSize) {
    ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch));
    read_data.append(result.data(), result.size());
    read += result.size();
  }
  ASSERT_TRUE(write_data == read_data);
  delete seq_file;
  delete [] scratch;
}",1,28,helpers\memenv\memenv_test.cc,leveldb._Test_LargeWrite._Run,,false,161,192,_Run,,,21,void leveldb._Test_LargeWrite._Run ()
64468,METHOD,leveldb._Test_DBTest,TYPE_DECL,void void ();,1,24,helpers\memenv\memenv_test.cc,leveldb._Test_DBTest._Run,,false,194,194,_Run,,,1,void leveldb._Test_DBTest._Run ()
64472,METHOD,leveldb._Test_DBTest,TYPE_DECL,"TEST(MemEnvTest, DBTest)",1,24,helpers\memenv\memenv_test.cc,leveldb._Test_DBTest._RunIt,,false,194,194,_RunIt,,,2,void leveldb._Test_DBTest._RunIt ()
64496,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"TEST(MemEnvTest, DBTest) {
  Options options;
  options.create_if_missing = true;
  options.env = env_;
  DB* db;

  const Slice keys[] = {Slice(""aaa""), Slice(""bbb""), Slice(""ccc"")};
  const Slice vals[] = {Slice(""foo""), Slice(""bar""), Slice(""baz"")};

  ASSERT_OK(DB::Open(options, ""/dir/db"", &db));
  for (size_t i = 0; i < 3; ++i) {
    ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]));
  }

  for (size_t i = 0; i < 3; ++i) {
    std::string res;
    ASSERT_OK(db->Get(ReadOptions(), keys[i], &res));
    ASSERT_TRUE(res == vals[i]);
  }

  Iterator* iterator = db->NewIterator(ReadOptions());
  iterator->SeekToFirst();
  for (size_t i = 0; i < 3; ++i) {
    ASSERT_TRUE(iterator->Valid());
    ASSERT_TRUE(keys[i] == iterator->key());
    ASSERT_TRUE(vals[i] == iterator->value());
    iterator->Next();
  }
  ASSERT_TRUE(!iterator->Valid());
  delete iterator;

  DBImpl* dbi = reinterpret_cast<DBImpl*>(db);
  ASSERT_OK(dbi->TEST_CompactMemTable());

  for (size_t i = 0; i < 3; ++i) {
  ...",1,24,helpers\memenv\memenv_test.cc,leveldb._Test_DBTest._Run,,false,194,235,_Run,,,25,void leveldb._Test_DBTest._Run ()
64848,METHOD,helpers\memenv\memenv_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,helpers\memenv\memenv_test.cc,main,,false,239,241,main,,,2,"int main (int,char**)"
64870,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,<global>,1,42,include\leveldb\c.hpp,include\leveldb\c.hpp:<global>,,false,1,290,<global>,,,1,
64904,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern leveldb_t* leveldb_open(
    const leveldb_options_t* options,
    const char* name,
    char** errptr);",17,18,include\leveldb\c.hpp,leveldb_open,,false,72,75,leveldb_open,,,33,"leveldb_t* leveldb_open (leveldb_options_t*,char*,char**)"
64911,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_close(leveldb_t* db);,13,40,include\leveldb\c.hpp,leveldb_close,,false,77,77,leveldb_close,,,34,void leveldb_close (leveldb_t*)
64916,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_put(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    const char* val, size_t vallen,
    char** errptr);",13,18,include\leveldb\c.hpp,leveldb_put,,false,79,84,leveldb_put,,,35,"void leveldb_put (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char*,size_t,char**)"
64927,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_delete(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    const char* key, size_t keylen,
    char** errptr);",13,18,include\leveldb\c.hpp,leveldb_delete,,false,86,90,leveldb_delete,,,36,"void leveldb_delete (leveldb_t*,leveldb_writeoptions_t*,char*,size_t,char**)"
64936,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_write(
    leveldb_t* db,
    const leveldb_writeoptions_t* options,
    leveldb_writebatch_t* batch,
    char** errptr);",13,18,include\leveldb\c.hpp,leveldb_write,,false,92,96,leveldb_write,,,37,"void leveldb_write (leveldb_t*,leveldb_writeoptions_t*,leveldb_writebatch_t*,char**)"
64944,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern char* leveldb_get(
    leveldb_t* db,
    const leveldb_readoptions_t* options,
    const char* key, size_t keylen,
    size_t* vallen,
    char** errptr);",12,18,include\leveldb\c.hpp,leveldb_get,,false,100,105,leveldb_get,,,38,"char* leveldb_get (leveldb_t*,leveldb_readoptions_t*,char*,size_t,size_t*,char**)"
64954,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern leveldb_iterator_t* leveldb_create_iterator(
    leveldb_t* db,
    const leveldb_readoptions_t* options);",26,41,include\leveldb\c.hpp,leveldb_create_iterator,,false,107,109,leveldb_create_iterator,,,39,"leveldb_iterator_t* leveldb_create_iterator (leveldb_t*,leveldb_readoptions_t*)"
64960,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern const leveldb_snapshot_t* leveldb_create_snapshot(
    leveldb_t* db);",32,18,include\leveldb\c.hpp,leveldb_create_snapshot,,false,111,112,leveldb_create_snapshot,,,40,leveldb_snapshot_t* leveldb_create_snapshot (leveldb_t*)
64965,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_release_snapshot(
    leveldb_t* db,
    const leveldb_snapshot_t* snapshot);",13,39,include\leveldb\c.hpp,leveldb_release_snapshot,,false,114,116,leveldb_release_snapshot,,,41,"void leveldb_release_snapshot (leveldb_t*,leveldb_snapshot_t*)"
64971,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern char* leveldb_property_value(
    leveldb_t* db,
    const char* propname);",12,25,include\leveldb\c.hpp,leveldb_property_value,,false,120,122,leveldb_property_value,,,42,"char* leveldb_property_value (leveldb_t*,char*)"
64977,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_approximate_sizes(
    leveldb_t* db,
    int num_ranges,
    const char* const* range_start_key, const size_t* range_start_key_len,
    const char* const* range_limit_key, const size_t* range_limit_key_len,
    uint64_t* sizes);",13,20,include\leveldb\c.hpp,leveldb_approximate_sizes,,false,124,129,leveldb_approximate_sizes,,,43,"void leveldb_approximate_sizes (leveldb_t*,int,char**,size_t*,char**,size_t*,uint64_t*)"
64988,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_compact_range(
    leveldb_t* db,
    const char* start_key, size_t start_key_len,
    const char* limit_key, size_t limit_key_len);",13,48,include\leveldb\c.hpp,leveldb_compact_range,,false,131,134,leveldb_compact_range,,,44,"void leveldb_compact_range (leveldb_t*,char*,size_t,char*,size_t)"
64997,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_destroy_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr);",13,18,include\leveldb\c.hpp,leveldb_destroy_db,,false,138,141,leveldb_destroy_db,,,45,"void leveldb_destroy_db (leveldb_options_t*,char*,char**)"
65004,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_repair_db(
    const leveldb_options_t* options,
    const char* name,
    char** errptr);",13,18,include\leveldb\c.hpp,leveldb_repair_db,,false,143,146,leveldb_repair_db,,,46,"void leveldb_repair_db (leveldb_options_t*,char*,char**)"
65011,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_iter_destroy(leveldb_iterator_t*);,13,53,include\leveldb\c.hpp,leveldb_iter_destroy,,false,150,150,leveldb_iter_destroy,,,47,void leveldb_iter_destroy (leveldb_iterator_t*)
65016,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern unsigned char leveldb_iter_valid(const leveldb_iterator_t*);,22,66,include\leveldb\c.hpp,leveldb_iter_valid,,false,151,151,leveldb_iter_valid,,,48,unsigned char leveldb_iter_valid (leveldb_iterator_t*)
65021,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_iter_seek_to_first(leveldb_iterator_t*);,13,59,include\leveldb\c.hpp,leveldb_iter_seek_to_first,,false,152,152,leveldb_iter_seek_to_first,,,49,void leveldb_iter_seek_to_first (leveldb_iterator_t*)
65026,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_iter_seek_to_last(leveldb_iterator_t*);,13,58,include\leveldb\c.hpp,leveldb_iter_seek_to_last,,false,153,153,leveldb_iter_seek_to_last,,,50,void leveldb_iter_seek_to_last (leveldb_iterator_t*)
65031,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_iter_seek(leveldb_iterator_t*, const char* k, size_t klen);",13,78,include\leveldb\c.hpp,leveldb_iter_seek,,false,154,154,leveldb_iter_seek,,,51,"void leveldb_iter_seek (leveldb_iterator_t*,char*,size_t)"
65038,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_iter_next(leveldb_iterator_t*);,13,50,include\leveldb\c.hpp,leveldb_iter_next,,false,155,155,leveldb_iter_next,,,52,void leveldb_iter_next (leveldb_iterator_t*)
65043,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_iter_prev(leveldb_iterator_t*);,13,50,include\leveldb\c.hpp,leveldb_iter_prev,,false,156,156,leveldb_iter_prev,,,53,void leveldb_iter_prev (leveldb_iterator_t*)
65048,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern const char* leveldb_iter_key(const leveldb_iterator_t*, size_t* klen);",18,76,include\leveldb\c.hpp,leveldb_iter_key,,false,157,157,leveldb_iter_key,,,54,"char* leveldb_iter_key (leveldb_iterator_t*,size_t*)"
65054,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern const char* leveldb_iter_value(const leveldb_iterator_t*, size_t* vlen);",18,78,include\leveldb\c.hpp,leveldb_iter_value,,false,158,158,leveldb_iter_value,,,55,"char* leveldb_iter_value (leveldb_iterator_t*,size_t*)"
65060,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_iter_get_error(const leveldb_iterator_t*, char** errptr);",13,76,include\leveldb\c.hpp,leveldb_iter_get_error,,false,159,159,leveldb_iter_get_error,,,56,"void leveldb_iter_get_error (leveldb_iterator_t*,char**)"
65066,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern leveldb_writebatch_t* leveldb_writebatch_create();,28,56,include\leveldb\c.hpp,leveldb_writebatch_create,,false,163,163,leveldb_writebatch_create,,,57,leveldb_writebatch_t* leveldb_writebatch_create ()
65070,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_writebatch_destroy(leveldb_writebatch_t*);,13,61,include\leveldb\c.hpp,leveldb_writebatch_destroy,,false,164,164,leveldb_writebatch_destroy,,,58,void leveldb_writebatch_destroy (leveldb_writebatch_t*)
65075,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_writebatch_clear(leveldb_writebatch_t*);,13,59,include\leveldb\c.hpp,leveldb_writebatch_clear,,false,165,165,leveldb_writebatch_clear,,,59,void leveldb_writebatch_clear (leveldb_writebatch_t*)
65080,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_writebatch_put(
    leveldb_writebatch_t*,
    const char* key, size_t klen,
    const char* val, size_t vlen);",13,33,include\leveldb\c.hpp,leveldb_writebatch_put,,false,166,169,leveldb_writebatch_put,,,60,"void leveldb_writebatch_put (leveldb_writebatch_t*,char*,size_t,char*,size_t)"
65089,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_writebatch_delete(
    leveldb_writebatch_t*,
    const char* key, size_t klen);",13,33,include\leveldb\c.hpp,leveldb_writebatch_delete,,false,170,172,leveldb_writebatch_delete,,,61,"void leveldb_writebatch_delete (leveldb_writebatch_t*,char*,size_t)"
65096,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_writebatch_iterate(
    leveldb_writebatch_t*,
    void* state,
    void (*put)(void*, const char* k, size_t klen, const char* v, size_t vlen),
    void (*deleted)(void*, const char* k, size_t klen));",13,55,include\leveldb\c.hpp,leveldb_writebatch_iterate,,false,173,177,leveldb_writebatch_iterate,,,62,"void leveldb_writebatch_iterate (leveldb_writebatch_t*,void*,void,void)"
65104,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern leveldb_options_t* leveldb_options_create();,25,50,include\leveldb\c.hpp,leveldb_options_create,,false,181,181,leveldb_options_create,,,63,leveldb_options_t* leveldb_options_create ()
65108,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_options_destroy(leveldb_options_t*);,13,55,include\leveldb\c.hpp,leveldb_options_destroy,,false,182,182,leveldb_options_destroy,,,64,void leveldb_options_destroy (leveldb_options_t*)
65113,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_comparator(
    leveldb_options_t*,
    leveldb_comparator_t*);",13,26,include\leveldb\c.hpp,leveldb_options_set_comparator,,false,183,185,leveldb_options_set_comparator,,,65,"void leveldb_options_set_comparator (leveldb_options_t*,leveldb_comparator_t*)"
65119,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_filter_policy(
    leveldb_options_t*,
    leveldb_filterpolicy_t*);",13,28,include\leveldb\c.hpp,leveldb_options_set_filter_policy,,false,186,188,leveldb_options_set_filter_policy,,,66,"void leveldb_options_set_filter_policy (leveldb_options_t*,leveldb_filterpolicy_t*)"
65125,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_create_if_missing(
    leveldb_options_t*, unsigned char);",13,38,include\leveldb\c.hpp,leveldb_options_set_create_if_missing,,false,189,190,leveldb_options_set_create_if_missing,,,67,"void leveldb_options_set_create_if_missing (leveldb_options_t*,unsigned char)"
65131,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_error_if_exists(
    leveldb_options_t*, unsigned char);",13,38,include\leveldb\c.hpp,leveldb_options_set_error_if_exists,,false,191,192,leveldb_options_set_error_if_exists,,,68,"void leveldb_options_set_error_if_exists (leveldb_options_t*,unsigned char)"
65137,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_paranoid_checks(
    leveldb_options_t*, unsigned char);",13,38,include\leveldb\c.hpp,leveldb_options_set_paranoid_checks,,false,193,194,leveldb_options_set_paranoid_checks,,,69,"void leveldb_options_set_paranoid_checks (leveldb_options_t*,unsigned char)"
65143,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_env(leveldb_options_t*, leveldb_env_t*);",13,71,include\leveldb\c.hpp,leveldb_options_set_env,,false,195,195,leveldb_options_set_env,,,70,"void leveldb_options_set_env (leveldb_options_t*,leveldb_env_t*)"
65149,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_info_log(leveldb_options_t*, leveldb_logger_t*);",13,79,include\leveldb\c.hpp,leveldb_options_set_info_log,,false,196,196,leveldb_options_set_info_log,,,71,"void leveldb_options_set_info_log (leveldb_options_t*,leveldb_logger_t*)"
65155,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_write_buffer_size(leveldb_options_t*, size_t);",13,77,include\leveldb\c.hpp,leveldb_options_set_write_buffer_size,,false,197,197,leveldb_options_set_write_buffer_size,,,72,"void leveldb_options_set_write_buffer_size (leveldb_options_t*,size_t)"
65161,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_max_open_files(leveldb_options_t*, int);",13,71,include\leveldb\c.hpp,leveldb_options_set_max_open_files,,false,198,198,leveldb_options_set_max_open_files,,,73,"void leveldb_options_set_max_open_files (leveldb_options_t*,int)"
65167,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_cache(leveldb_options_t*, leveldb_cache_t*);",13,75,include\leveldb\c.hpp,leveldb_options_set_cache,,false,199,199,leveldb_options_set_cache,,,74,"void leveldb_options_set_cache (leveldb_options_t*,leveldb_cache_t*)"
65173,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_block_size(leveldb_options_t*, size_t);",13,70,include\leveldb\c.hpp,leveldb_options_set_block_size,,false,200,200,leveldb_options_set_block_size,,,75,"void leveldb_options_set_block_size (leveldb_options_t*,size_t)"
65179,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_block_restart_interval(leveldb_options_t*, int);",13,79,include\leveldb\c.hpp,leveldb_options_set_block_restart_interval,,false,201,201,leveldb_options_set_block_restart_interval,,,76,"void leveldb_options_set_block_restart_interval (leveldb_options_t*,int)"
65188,METHOD,<empty>,<empty>,<empty>,1,,include\leveldb\c.hpp,anonymous_enum_0:<clinit>,,false,203,,<clinit>,,,3,
65198,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_options_set_compression(leveldb_options_t*, int);",13,68,include\leveldb\c.hpp,leveldb_options_set_compression,,false,207,207,leveldb_options_set_compression,,,78,"void leveldb_options_set_compression (leveldb_options_t*,int)"
65204,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern leveldb_comparator_t* leveldb_comparator_create(
    void* state,
    void (*destructor)(void*),
    int (*compare)(
        void*,
        const char* a, size_t alen,
        const char* b, size_t blen),
    const char* (*name)(void*));",28,31,include\leveldb\c.hpp,leveldb_comparator_create,,false,211,218,leveldb_comparator_create,,,79,"leveldb_comparator_t* leveldb_comparator_create (void*,void,int,char*)"
65212,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_comparator_destroy(leveldb_comparator_t*);,13,61,include\leveldb\c.hpp,leveldb_comparator_destroy,,false,219,219,leveldb_comparator_destroy,,,80,void leveldb_comparator_destroy (leveldb_comparator_t*)
65217,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern leveldb_filterpolicy_t* leveldb_filterpolicy_create(
    void* state,
    void (*destructor)(void*),
    char* (*create_filter)(
        void*,
        const char* const* key_array, const size_t* key_length_array,
        int num_keys,
        size_t* filter_length),
    unsigned char (*key_may_match)(
        void*,
        const char* key, size_t length,
        const char* filter, size_t filter_length),
    const char* (*name)(void*));",30,31,include\leveldb\c.hpp,leveldb_filterpolicy_create,,false,223,235,leveldb_filterpolicy_create,,,81,"leveldb_filterpolicy_t* leveldb_filterpolicy_create (void*,void,char*,unsigned char,char*)"
65226,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t*);,13,65,include\leveldb\c.hpp,leveldb_filterpolicy_destroy,,false,236,236,leveldb_filterpolicy_destroy,,,82,void leveldb_filterpolicy_destroy (leveldb_filterpolicy_t*)
65231,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(
    int bits_per_key);",30,21,include\leveldb\c.hpp,leveldb_filterpolicy_create_bloom,,false,238,239,leveldb_filterpolicy_create_bloom,,,83,leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom (int)
65236,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern leveldb_readoptions_t* leveldb_readoptions_create();,29,58,include\leveldb\c.hpp,leveldb_readoptions_create,,false,243,243,leveldb_readoptions_create,,,84,leveldb_readoptions_t* leveldb_readoptions_create ()
65240,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_readoptions_destroy(leveldb_readoptions_t*);,13,63,include\leveldb\c.hpp,leveldb_readoptions_destroy,,false,244,244,leveldb_readoptions_destroy,,,85,void leveldb_readoptions_destroy (leveldb_readoptions_t*)
65245,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_readoptions_set_verify_checksums(
    leveldb_readoptions_t*,
    unsigned char);",13,18,include\leveldb\c.hpp,leveldb_readoptions_set_verify_checksums,,false,245,247,leveldb_readoptions_set_verify_checksums,,,86,"void leveldb_readoptions_set_verify_checksums (leveldb_readoptions_t*,unsigned char)"
65251,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_readoptions_set_fill_cache(
    leveldb_readoptions_t*, unsigned char);",13,42,include\leveldb\c.hpp,leveldb_readoptions_set_fill_cache,,false,248,249,leveldb_readoptions_set_fill_cache,,,87,"void leveldb_readoptions_set_fill_cache (leveldb_readoptions_t*,unsigned char)"
65257,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_readoptions_set_snapshot(
    leveldb_readoptions_t*,
    const leveldb_snapshot_t*);",13,30,include\leveldb\c.hpp,leveldb_readoptions_set_snapshot,,false,250,252,leveldb_readoptions_set_snapshot,,,88,"void leveldb_readoptions_set_snapshot (leveldb_readoptions_t*,leveldb_snapshot_t*)"
65263,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern leveldb_writeoptions_t* leveldb_writeoptions_create();,30,60,include\leveldb\c.hpp,leveldb_writeoptions_create,,false,256,256,leveldb_writeoptions_create,,,89,leveldb_writeoptions_t* leveldb_writeoptions_create ()
65267,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_writeoptions_destroy(leveldb_writeoptions_t*);,13,65,include\leveldb\c.hpp,leveldb_writeoptions_destroy,,false,257,257,leveldb_writeoptions_destroy,,,90,void leveldb_writeoptions_destroy (leveldb_writeoptions_t*)
65272,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,"extern void leveldb_writeoptions_set_sync(
    leveldb_writeoptions_t*, unsigned char);",13,43,include\leveldb\c.hpp,leveldb_writeoptions_set_sync,,false,258,259,leveldb_writeoptions_set_sync,,,91,"void leveldb_writeoptions_set_sync (leveldb_writeoptions_t*,unsigned char)"
65278,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern leveldb_cache_t* leveldb_cache_create_lru(size_t capacity);,23,65,include\leveldb\c.hpp,leveldb_cache_create_lru,,false,263,263,leveldb_cache_create_lru,,,92,leveldb_cache_t* leveldb_cache_create_lru (size_t)
65283,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_cache_destroy(leveldb_cache_t* cache);,13,57,include\leveldb\c.hpp,leveldb_cache_destroy,,false,264,264,leveldb_cache_destroy,,,93,void leveldb_cache_destroy (leveldb_cache_t*)
65288,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern leveldb_env_t* leveldb_create_default_env();,21,50,include\leveldb\c.hpp,leveldb_create_default_env,,false,268,268,leveldb_create_default_env,,,94,leveldb_env_t* leveldb_create_default_env ()
65292,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_env_destroy(leveldb_env_t*);,13,47,include\leveldb\c.hpp,leveldb_env_destroy,,false,269,269,leveldb_env_destroy,,,95,void leveldb_env_destroy (leveldb_env_t*)
65297,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern void leveldb_free(void* ptr);,13,35,include\leveldb\c.hpp,leveldb_free,,false,278,278,leveldb_free,,,96,void leveldb_free (void*)
65302,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern int leveldb_major_version();,12,34,include\leveldb\c.hpp,leveldb_major_version,,false,281,281,leveldb_major_version,,,97,int leveldb_major_version ()
65306,METHOD,include\leveldb\c.hpp:<global>,TYPE_DECL,extern int leveldb_minor_version();,12,34,include\leveldb\c.hpp,leveldb_minor_version,,false,284,284,leveldb_minor_version,,,98,int leveldb_minor_version ()
65317,METHOD,include\leveldb\cache.hpp:<global>,TYPE_DECL,<global>,1,22,include\leveldb\cache.hpp,include\leveldb\cache.hpp:<global>,,false,1,110,<global>,,,1,
65321,METHOD,include\leveldb\cache.hpp:<global>,TYPE_DECL,extern Cache* NewLRUCache(size_t capacity);,13,42,include\leveldb\cache.hpp,leveldb.NewLRUCache,,false,30,30,NewLRUCache,,,2,Cache* leveldb.NewLRUCache (size_t)
65327,METHOD,leveldb.Cache,TYPE_DECL,Cache() { },3,13,include\leveldb\cache.hpp,leveldb.Cache.Cache,,false,34,34,Cache,,,1,ANY leveldb.Cache.Cache ()
65331,METHOD,leveldb.Cache,TYPE_DECL,virtual ~Cache();,11,18,include\leveldb\cache.hpp,leveldb.Cache.~Cache,,false,38,38,~Cache,,,2,virtual leveldb.Cache.~Cache ()
65336,METHOD,leveldb.Cache,TYPE_DECL,"virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) = 0;",17,76,include\leveldb\cache.hpp,leveldb.Cache.Insert,,false,52,53,Insert,,,4,"Handle* leveldb.Cache.Insert (Slice,void*,size_t,void)"
65344,METHOD,leveldb.Cache,TYPE_DECL,virtual Handle* Lookup(const Slice& key) = 0;,17,46,include\leveldb\cache.hpp,leveldb.Cache.Lookup,,false,60,60,Lookup,,,5,Handle* leveldb.Cache.Lookup (Slice)
65349,METHOD,leveldb.Cache,TYPE_DECL,virtual void Release(Handle* handle) = 0;,16,42,include\leveldb\cache.hpp,leveldb.Cache.Release,,false,65,65,Release,,,6,void leveldb.Cache.Release (Handle*)
65354,METHOD,leveldb.Cache,TYPE_DECL,virtual void* Value(Handle* handle) = 0;,15,41,include\leveldb\cache.hpp,leveldb.Cache.Value,,false,71,71,Value,,,7,void* leveldb.Cache.Value (Handle*)
65359,METHOD,leveldb.Cache,TYPE_DECL,virtual void Erase(const Slice& key) = 0;,16,42,include\leveldb\cache.hpp,leveldb.Cache.Erase,,false,76,76,Erase,,,8,void leveldb.Cache.Erase (Slice)
65364,METHOD,leveldb.Cache,TYPE_DECL,virtual uint64_t NewId() = 0;,20,30,include\leveldb\cache.hpp,leveldb.Cache.NewId,,false,82,82,NewId,,,9,uint64_t leveldb.Cache.NewId ()
65368,METHOD,leveldb.Cache,TYPE_DECL,virtual void Prune() {},3,25,include\leveldb\cache.hpp,leveldb.Cache.Prune,,false,89,89,Prune,,,10,void leveldb.Cache.Prune ()
65372,METHOD,leveldb.Cache,TYPE_DECL,virtual size_t TotalCharge() const = 0;,18,40,include\leveldb\cache.hpp,leveldb.Cache.TotalCharge,,false,93,93,TotalCharge,,,11,size_t leveldb.Cache.TotalCharge ()
65376,METHOD,leveldb.Cache,TYPE_DECL,void LRU_Remove(Handle* e);,8,28,include\leveldb\cache.hpp,leveldb.Cache.LRU_Remove,,false,96,96,LRU_Remove,,,12,void leveldb.Cache.LRU_Remove (Handle*)
65381,METHOD,leveldb.Cache,TYPE_DECL,void LRU_Append(Handle* e);,8,28,include\leveldb\cache.hpp,leveldb.Cache.LRU_Append,,false,97,97,LRU_Append,,,13,void leveldb.Cache.LRU_Append (Handle*)
65386,METHOD,leveldb.Cache,TYPE_DECL,void Unref(Handle* e);,8,23,include\leveldb\cache.hpp,leveldb.Cache.Unref,,false,98,98,Unref,,,14,void leveldb.Cache.Unref (Handle*)
65393,METHOD,leveldb.Cache,TYPE_DECL,Cache(const Cache&);,3,21,include\leveldb\cache.hpp,leveldb.Cache.Cache,,false,104,104,Cache,,,17,ANY leveldb.Cache.Cache (Cache)
65398,METHOD,leveldb.Cache,TYPE_DECL,void operator=(const Cache&);,8,30,include\leveldb\cache.hpp,leveldb.Cache.operator =,,false,105,105,operator =,,,18,void leveldb.Cache.operator = (Cache)
65408,METHOD,include\leveldb\comparator.hpp:<global>,TYPE_DECL,<global>,1,48,include\leveldb\comparator.hpp,include\leveldb\comparator.hpp:<global>,,false,1,63,<global>,,,1,
65413,METHOD,leveldb.Comparator,TYPE_DECL,virtual ~Comparator();,11,23,include\leveldb\comparator.hpp,leveldb.Comparator.~Comparator,,false,20,20,~Comparator,,,1,virtual leveldb.Comparator.~Comparator ()
65417,METHOD,leveldb.Comparator,TYPE_DECL,"virtual int Compare(const Slice& a, const Slice& b) const = 0;",15,63,include\leveldb\comparator.hpp,leveldb.Comparator.Compare,,false,26,26,Compare,,,2,"int leveldb.Comparator.Compare (Slice,Slice)"
65423,METHOD,leveldb.Comparator,TYPE_DECL,virtual const char* Name() const = 0;,21,38,include\leveldb\comparator.hpp,leveldb.Comparator.Name,,false,38,38,Name,,,3,char* leveldb.Comparator.Name ()
65427,METHOD,leveldb.Comparator,TYPE_DECL,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const = 0;",16,35,include\leveldb\comparator.hpp,leveldb.Comparator.FindShortestSeparator,,false,46,48,FindShortestSeparator,,,4,"void leveldb.Comparator.FindShortestSeparator (ANY*,Slice)"
65433,METHOD,leveldb.Comparator,TYPE_DECL,virtual void FindShortSuccessor(std::string* key) const = 0;,16,61,include\leveldb\comparator.hpp,leveldb.Comparator.FindShortSuccessor,,false,53,53,FindShortSuccessor,,,5,void leveldb.Comparator.FindShortSuccessor (ANY*)
65438,METHOD,include\leveldb\comparator.hpp:<global>,TYPE_DECL,extern const Comparator* BytewiseComparator();,24,45,include\leveldb\comparator.hpp,leveldb.BytewiseComparator,,false,59,59,BytewiseComparator,,,3,Comparator* leveldb.BytewiseComparator ()
65453,METHOD,include\leveldb\db.hpp:<global>,TYPE_DECL,<global>,1,21,include\leveldb\db.hpp,include\leveldb\db.hpp:<global>,,false,1,163,<global>,,,1,
65469,METHOD,leveldb.Snapshot,TYPE_DECL,virtual ~Snapshot();,11,21,include\leveldb\db.hpp,leveldb.Snapshot.~Snapshot,,false,29,29,~Snapshot,,,1,virtual leveldb.Snapshot.~Snapshot ()
65476,METHOD,leveldb.Range,TYPE_DECL,Range() { },3,13,include\leveldb\db.hpp,leveldb.Range.Range,,false,37,37,Range,,,3,ANY leveldb.Range.Range ()
65480,METHOD,leveldb.Range,TYPE_DECL,"Range(const Slice& s, const Slice& l) : start(s), limit(l) { }",3,64,include\leveldb\db.hpp,leveldb.Range.Range,,false,38,38,Range,,,4,"ANY leveldb.Range.Range (Slice,Slice)"
65487,METHOD,leveldb.DB,TYPE_DECL,"static Status Open(const Options& options,
                     const std::string& name,
                     DB** dbptr);",17,32,include\leveldb\db.hpp,leveldb.DB.Open,,false,51,53,Open,,,1,"Status leveldb.DB.Open (Options,ANY,DB**)"
65494,METHOD,leveldb.DB,TYPE_DECL,DB() { },3,10,include\leveldb\db.hpp,leveldb.DB.DB,,false,55,55,DB,,,2,ANY leveldb.DB.DB ()
65498,METHOD,leveldb.DB,TYPE_DECL,virtual ~DB();,11,15,include\leveldb\db.hpp,leveldb.DB.~DB,,false,56,56,~DB,,,3,virtual leveldb.DB.~DB ()
65502,METHOD,leveldb.DB,TYPE_DECL,"virtual Status Put(const WriteOptions& options,
                     const Slice& key,
                     const Slice& value) = 0;",18,44,include\leveldb\db.hpp,leveldb.DB.Put,,false,61,63,Put,,,4,"Status leveldb.DB.Put (WriteOptions,Slice,Slice)"
65509,METHOD,leveldb.DB,TYPE_DECL,"virtual Status Delete(const WriteOptions& options, const Slice& key) = 0;",18,74,include\leveldb\db.hpp,leveldb.DB.Delete,,false,69,69,Delete,,,5,"Status leveldb.DB.Delete (WriteOptions,Slice)"
65515,METHOD,leveldb.DB,TYPE_DECL,"virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;",18,76,include\leveldb\db.hpp,leveldb.DB.Write,,false,74,74,Write,,,6,"Status leveldb.DB.Write (WriteOptions,WriteBatch*)"
65521,METHOD,leveldb.DB,TYPE_DECL,"virtual Status Get(const ReadOptions& options,
                     const Slice& key, std::string* value) = 0;",18,62,include\leveldb\db.hpp,leveldb.DB.Get,,false,83,84,Get,,,7,"Status leveldb.DB.Get (ReadOptions,Slice,ANY*)"
65528,METHOD,leveldb.DB,TYPE_DECL,virtual Iterator* NewIterator(const ReadOptions& options) = 0;,19,63,include\leveldb\db.hpp,leveldb.DB.NewIterator,,false,92,92,NewIterator,,,8,Iterator* leveldb.DB.NewIterator (ReadOptions)
65533,METHOD,leveldb.DB,TYPE_DECL,virtual const Snapshot* GetSnapshot() = 0;,25,43,include\leveldb\db.hpp,leveldb.DB.GetSnapshot,,false,98,98,GetSnapshot,,,9,Snapshot* leveldb.DB.GetSnapshot ()
65537,METHOD,leveldb.DB,TYPE_DECL,virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;,16,60,include\leveldb\db.hpp,leveldb.DB.ReleaseSnapshot,,false,102,102,ReleaseSnapshot,,,10,void leveldb.DB.ReleaseSnapshot (Snapshot*)
65542,METHOD,leveldb.DB,TYPE_DECL,"virtual bool GetProperty(const Slice& property, std::string* value) = 0;",16,73,include\leveldb\db.hpp,leveldb.DB.GetProperty,,false,120,120,GetProperty,,,11,"bool leveldb.DB.GetProperty (Slice,ANY*)"
65548,METHOD,leveldb.DB,TYPE_DECL,"virtual void GetApproximateSizes(const Range* range, int n,
                                   uint64_t* sizes) = 0;",16,55,include\leveldb\db.hpp,leveldb.DB.GetApproximateSizes,,false,130,131,GetApproximateSizes,,,12,"void leveldb.DB.GetApproximateSizes (Range*,int,uint64_t*)"
65555,METHOD,leveldb.DB,TYPE_DECL,"virtual void CompactRange(const Slice* begin, const Slice* end) = 0;",16,69,include\leveldb\db.hpp,leveldb.DB.CompactRange,,false,143,143,CompactRange,,,13,"void leveldb.DB.CompactRange (Slice*,Slice*)"
65561,METHOD,leveldb.DB,TYPE_DECL,DB(const DB&);,3,15,include\leveldb\db.hpp,leveldb.DB.DB,,false,147,147,DB,,,14,ANY leveldb.DB.DB (DB)
65566,METHOD,leveldb.DB,TYPE_DECL,void operator=(const DB&);,8,27,include\leveldb\db.hpp,leveldb.DB.operator =,,false,148,148,operator =,,,15,void leveldb.DB.operator = (DB)
65571,METHOD,include\leveldb\db.hpp:<global>,TYPE_DECL,"Status DestroyDB(const std::string& name, const Options& options);",8,65,include\leveldb\db.hpp,leveldb.DestroyDB,,false,153,153,DestroyDB,,,12,"Status leveldb.DestroyDB (ANY,Options)"
65577,METHOD,include\leveldb\db.hpp:<global>,TYPE_DECL,"Status RepairDB(const std::string& dbname, const Options& options);",8,66,include\leveldb\db.hpp,leveldb.RepairDB,,false,159,159,RepairDB,,,13,"Status leveldb.RepairDB (ANY,Options)"
65592,METHOD,include\leveldb\dumpfile.hpp:<global>,TYPE_DECL,<global>,1,18,include\leveldb\dumpfile.hpp,include\leveldb\dumpfile.hpp:<global>,,false,1,25,<global>,,,1,
65595,METHOD,include\leveldb\dumpfile.hpp:<global>,TYPE_DECL,"Status DumpFile(Env* env, const std::string& fname, WritableFile* dst);",8,70,include\leveldb\dumpfile.hpp,leveldb.DumpFile,,false,21,21,DumpFile,,,1,"Status leveldb.DumpFile (Env*,ANY,WritableFile*)"
65615,METHOD,include\leveldb\env.hpp:<global>,TYPE_DECL,<global>,1,22,include\leveldb\env.hpp,include\leveldb\env.hpp:<global>,,false,1,351,<global>,,,1,
65625,METHOD,leveldb.Env,TYPE_DECL,Env() { },3,11,include\leveldb\env.hpp,leveldb.Env.Env,,false,33,33,Env,,,1,ANY leveldb.Env.Env ()
65629,METHOD,leveldb.Env,TYPE_DECL,virtual ~Env();,11,16,include\leveldb\env.hpp,leveldb.Env.~Env,,false,34,34,~Env,,,2,virtual leveldb.Env.~Env ()
65633,METHOD,leveldb.Env,TYPE_DECL,static Env* Default();,13,23,include\leveldb\env.hpp,leveldb.Env.Default,,false,41,41,Default,,,3,Env* leveldb.Env.Default ()
65637,METHOD,leveldb.Env,TYPE_DECL,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) = 0;",18,63,include\leveldb\env.hpp,leveldb.Env.NewSequentialFile,,false,49,50,NewSequentialFile,,,4,"Status leveldb.Env.NewSequentialFile (ANY,SequentialFile**)"
65643,METHOD,leveldb.Env,TYPE_DECL,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) = 0;",18,67,include\leveldb\env.hpp,leveldb.Env.NewRandomAccessFile,,false,59,60,NewRandomAccessFile,,,5,"Status leveldb.Env.NewRandomAccessFile (ANY,RandomAccessFile**)"
65649,METHOD,leveldb.Env,TYPE_DECL,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) = 0;",18,59,include\leveldb\env.hpp,leveldb.Env.NewWritableFile,,false,69,70,NewWritableFile,,,6,"Status leveldb.Env.NewWritableFile (ANY,WritableFile**)"
65655,METHOD,leveldb.Env,TYPE_DECL,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result);",18,57,include\leveldb\env.hpp,leveldb.Env.NewAppendableFile,,false,84,85,NewAppendableFile,,,7,"Status leveldb.Env.NewAppendableFile (ANY,WritableFile**)"
65661,METHOD,leveldb.Env,TYPE_DECL,virtual bool FileExists(const std::string& fname) = 0;,16,55,include\leveldb\env.hpp,leveldb.Env.FileExists,,false,88,88,FileExists,,,8,bool leveldb.Env.FileExists (ANY)
65666,METHOD,leveldb.Env,TYPE_DECL,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) = 0;",18,66,include\leveldb\env.hpp,leveldb.Env.GetChildren,,false,93,94,GetChildren,,,9,"Status leveldb.Env.GetChildren (ANY,ANY*)"
65672,METHOD,leveldb.Env,TYPE_DECL,virtual Status DeleteFile(const std::string& fname) = 0;,18,57,include\leveldb\env.hpp,leveldb.Env.DeleteFile,,false,97,97,DeleteFile,,,10,Status leveldb.Env.DeleteFile (ANY)
65677,METHOD,leveldb.Env,TYPE_DECL,virtual Status CreateDir(const std::string& dirname) = 0;,18,58,include\leveldb\env.hpp,leveldb.Env.CreateDir,,false,100,100,CreateDir,,,11,Status leveldb.Env.CreateDir (ANY)
65682,METHOD,leveldb.Env,TYPE_DECL,virtual Status DeleteDir(const std::string& dirname) = 0;,18,58,include\leveldb\env.hpp,leveldb.Env.DeleteDir,,false,103,103,DeleteDir,,,12,Status leveldb.Env.DeleteDir (ANY)
65687,METHOD,leveldb.Env,TYPE_DECL,"virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) = 0;",18,79,include\leveldb\env.hpp,leveldb.Env.GetFileSize,,false,106,106,GetFileSize,,,13,"Status leveldb.Env.GetFileSize (ANY,uint64_t*)"
65693,METHOD,leveldb.Env,TYPE_DECL,"virtual Status RenameFile(const std::string& src,
                            const std::string& target) = 0;",18,58,include\leveldb\env.hpp,leveldb.Env.RenameFile,,false,109,110,RenameFile,,,14,"Status leveldb.Env.RenameFile (ANY,ANY)"
65699,METHOD,leveldb.Env,TYPE_DECL,"virtual Status LockFile(const std::string& fname, FileLock** lock) = 0;",18,72,include\leveldb\env.hpp,leveldb.Env.LockFile,,false,126,126,LockFile,,,15,"Status leveldb.Env.LockFile (ANY,FileLock**)"
65705,METHOD,leveldb.Env,TYPE_DECL,virtual Status UnlockFile(FileLock* lock) = 0;,18,47,include\leveldb\env.hpp,leveldb.Env.UnlockFile,,false,131,131,UnlockFile,,,16,Status leveldb.Env.UnlockFile (FileLock*)
65710,METHOD,leveldb.Env,TYPE_DECL,"virtual void Schedule(
      void (*function)(void* arg),
      void* arg) = 0;",16,20,include\leveldb\env.hpp,leveldb.Env.Schedule,,false,139,141,Schedule,,,17,"void leveldb.Env.Schedule (void,void*)"
65716,METHOD,leveldb.Env,TYPE_DECL,"virtual void StartThread(void (*function)(void* arg), void* arg) = 0;",16,70,include\leveldb\env.hpp,leveldb.Env.StartThread,,false,145,145,StartThread,,,18,"void leveldb.Env.StartThread (void,void*)"
65722,METHOD,leveldb.Env,TYPE_DECL,virtual Status GetTestDirectory(std::string* path) = 0;,18,56,include\leveldb\env.hpp,leveldb.Env.GetTestDirectory,,false,151,151,GetTestDirectory,,,19,Status leveldb.Env.GetTestDirectory (ANY*)
65727,METHOD,leveldb.Env,TYPE_DECL,"virtual Status NewLogger(const std::string& fname, Logger** result) = 0;",18,73,include\leveldb\env.hpp,leveldb.Env.NewLogger,,false,154,154,NewLogger,,,20,"Status leveldb.Env.NewLogger (ANY,Logger**)"
65733,METHOD,leveldb.Env,TYPE_DECL,virtual uint64_t NowMicros() = 0;,20,34,include\leveldb\env.hpp,leveldb.Env.NowMicros,,false,158,158,NowMicros,,,21,uint64_t leveldb.Env.NowMicros ()
65737,METHOD,leveldb.Env,TYPE_DECL,virtual void SleepForMicroseconds(int micros) = 0;,16,51,include\leveldb\env.hpp,leveldb.Env.SleepForMicroseconds,,false,161,161,SleepForMicroseconds,,,22,void leveldb.Env.SleepForMicroseconds (int)
65742,METHOD,leveldb.Env,TYPE_DECL,Env(const Env&);,3,17,include\leveldb\env.hpp,leveldb.Env.Env,,false,165,165,Env,,,23,ANY leveldb.Env.Env (Env)
65747,METHOD,leveldb.Env,TYPE_DECL,void operator=(const Env&);,8,28,include\leveldb\env.hpp,leveldb.Env.operator =,,false,166,166,operator =,,,24,void leveldb.Env.operator = (Env)
65753,METHOD,leveldb.SequentialFile,TYPE_DECL,SequentialFile() { },3,22,include\leveldb\env.hpp,leveldb.SequentialFile.SequentialFile,,false,172,172,SequentialFile,,,1,ANY leveldb.SequentialFile.SequentialFile ()
65757,METHOD,leveldb.SequentialFile,TYPE_DECL,virtual ~SequentialFile();,11,27,include\leveldb\env.hpp,leveldb.SequentialFile.~SequentialFile,,false,173,173,~SequentialFile,,,2,virtual leveldb.SequentialFile.~SequentialFile ()
65761,METHOD,leveldb.SequentialFile,TYPE_DECL,"virtual Status Read(size_t n, Slice* result, char* scratch) = 0;",18,65,include\leveldb\env.hpp,leveldb.SequentialFile.Read,,false,183,183,Read,,,3,"Status leveldb.SequentialFile.Read (size_t,Slice*,char*)"
65768,METHOD,leveldb.SequentialFile,TYPE_DECL,virtual Status Skip(uint64_t n) = 0;,18,37,include\leveldb\env.hpp,leveldb.SequentialFile.Skip,,false,192,192,Skip,,,4,Status leveldb.SequentialFile.Skip (uint64_t)
65773,METHOD,leveldb.SequentialFile,TYPE_DECL,SequentialFile(const SequentialFile&);,3,39,include\leveldb\env.hpp,leveldb.SequentialFile.SequentialFile,,false,196,196,SequentialFile,,,5,ANY leveldb.SequentialFile.SequentialFile (SequentialFile)
65778,METHOD,leveldb.SequentialFile,TYPE_DECL,void operator=(const SequentialFile&);,8,39,include\leveldb\env.hpp,leveldb.SequentialFile.operator =,,false,197,197,operator =,,,6,void leveldb.SequentialFile.operator = (SequentialFile)
65784,METHOD,leveldb.RandomAccessFile,TYPE_DECL,RandomAccessFile() { },3,24,include\leveldb\env.hpp,leveldb.RandomAccessFile.RandomAccessFile,,false,203,203,RandomAccessFile,,,1,ANY leveldb.RandomAccessFile.RandomAccessFile ()
65788,METHOD,leveldb.RandomAccessFile,TYPE_DECL,virtual ~RandomAccessFile();,11,29,include\leveldb\env.hpp,leveldb.RandomAccessFile.~RandomAccessFile,,false,204,204,~RandomAccessFile,,,2,virtual leveldb.RandomAccessFile.~RandomAccessFile ()
65792,METHOD,leveldb.RandomAccessFile,TYPE_DECL,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const = 0;",18,46,include\leveldb\env.hpp,leveldb.RandomAccessFile.Read,,false,215,216,Read,,,3,"Status leveldb.RandomAccessFile.Read (uint64_t,size_t,Slice*,char*)"
65800,METHOD,leveldb.RandomAccessFile,TYPE_DECL,RandomAccessFile(const RandomAccessFile&);,3,43,include\leveldb\env.hpp,leveldb.RandomAccessFile.RandomAccessFile,,false,220,220,RandomAccessFile,,,4,ANY leveldb.RandomAccessFile.RandomAccessFile (RandomAccessFile)
65805,METHOD,leveldb.RandomAccessFile,TYPE_DECL,void operator=(const RandomAccessFile&);,8,41,include\leveldb\env.hpp,leveldb.RandomAccessFile.operator =,,false,221,221,operator =,,,5,void leveldb.RandomAccessFile.operator = (RandomAccessFile)
65811,METHOD,leveldb.WritableFile,TYPE_DECL,WritableFile() { },3,20,include\leveldb\env.hpp,leveldb.WritableFile.WritableFile,,false,229,229,WritableFile,,,1,ANY leveldb.WritableFile.WritableFile ()
65815,METHOD,leveldb.WritableFile,TYPE_DECL,virtual ~WritableFile();,11,25,include\leveldb\env.hpp,leveldb.WritableFile.~WritableFile,,false,230,230,~WritableFile,,,2,virtual leveldb.WritableFile.~WritableFile ()
65819,METHOD,leveldb.WritableFile,TYPE_DECL,virtual Status Append(const Slice& data) = 0;,18,46,include\leveldb\env.hpp,leveldb.WritableFile.Append,,false,232,232,Append,,,3,Status leveldb.WritableFile.Append (Slice)
65824,METHOD,leveldb.WritableFile,TYPE_DECL,virtual Status Close() = 0;,18,28,include\leveldb\env.hpp,leveldb.WritableFile.Close,,false,233,233,Close,,,4,Status leveldb.WritableFile.Close ()
65828,METHOD,leveldb.WritableFile,TYPE_DECL,virtual Status Flush() = 0;,18,28,include\leveldb\env.hpp,leveldb.WritableFile.Flush,,false,234,234,Flush,,,5,Status leveldb.WritableFile.Flush ()
65832,METHOD,leveldb.WritableFile,TYPE_DECL,virtual Status Sync() = 0;,18,27,include\leveldb\env.hpp,leveldb.WritableFile.Sync,,false,235,235,Sync,,,6,Status leveldb.WritableFile.Sync ()
65836,METHOD,leveldb.WritableFile,TYPE_DECL,WritableFile(const WritableFile&);,3,35,include\leveldb\env.hpp,leveldb.WritableFile.WritableFile,,false,239,239,WritableFile,,,7,ANY leveldb.WritableFile.WritableFile (WritableFile)
65841,METHOD,leveldb.WritableFile,TYPE_DECL,void operator=(const WritableFile&);,8,37,include\leveldb\env.hpp,leveldb.WritableFile.operator =,,false,240,240,operator =,,,8,void leveldb.WritableFile.operator = (WritableFile)
65847,METHOD,leveldb.Logger,TYPE_DECL,Logger() { },3,14,include\leveldb\env.hpp,leveldb.Logger.Logger,,false,246,246,Logger,,,1,ANY leveldb.Logger.Logger ()
65851,METHOD,leveldb.Logger,TYPE_DECL,virtual ~Logger();,11,19,include\leveldb\env.hpp,leveldb.Logger.~Logger,,false,247,247,~Logger,,,2,virtual leveldb.Logger.~Logger ()
65855,METHOD,leveldb.Logger,TYPE_DECL,"virtual void Logv(const char* format, va_list ap) = 0;",16,55,include\leveldb\env.hpp,leveldb.Logger.Logv,,false,250,250,Logv,,,3,"void leveldb.Logger.Logv (char*,va_list)"
65861,METHOD,leveldb.Logger,TYPE_DECL,Logger(const Logger&);,3,23,include\leveldb\env.hpp,leveldb.Logger.Logger,,false,254,254,Logger,,,4,ANY leveldb.Logger.Logger (Logger)
65866,METHOD,leveldb.Logger,TYPE_DECL,void operator=(const Logger&);,8,31,include\leveldb\env.hpp,leveldb.Logger.operator =,,false,255,255,operator =,,,5,void leveldb.Logger.operator = (Logger)
65872,METHOD,leveldb.FileLock,TYPE_DECL,FileLock() { },3,16,include\leveldb\env.hpp,leveldb.FileLock.FileLock,,false,262,262,FileLock,,,1,ANY leveldb.FileLock.FileLock ()
65876,METHOD,leveldb.FileLock,TYPE_DECL,virtual ~FileLock();,11,21,include\leveldb\env.hpp,leveldb.FileLock.~FileLock,,false,263,263,~FileLock,,,2,virtual leveldb.FileLock.~FileLock ()
65880,METHOD,leveldb.FileLock,TYPE_DECL,FileLock(const FileLock&);,3,27,include\leveldb\env.hpp,leveldb.FileLock.FileLock,,false,266,266,FileLock,,,3,ANY leveldb.FileLock.FileLock (FileLock)
65885,METHOD,leveldb.FileLock,TYPE_DECL,void operator=(const FileLock&);,8,33,include\leveldb\env.hpp,leveldb.FileLock.operator =,,false,267,267,operator =,,,4,void leveldb.FileLock.operator = (FileLock)
65890,METHOD,include\leveldb\env.hpp:<global>,TYPE_DECL,"extern void Log(Logger* info_log, const char* format, ...)
#   if defined(__GNUC__) || defined(__clang__)
    __attribute__((__format__ (__printf__, 2, 3)))
#   endif
    ;",13,58,include\leveldb\env.hpp,leveldb.Log,,false,271,271,Log,,,13,"void leveldb.Log (Logger*,char*...)"
65896,METHOD,include\leveldb\env.hpp:<global>,TYPE_DECL,"extern Status WriteStringToFile(Env* env, const Slice& data,
                                const std::string& fname);",15,57,include\leveldb\env.hpp,leveldb.WriteStringToFile,,false,278,279,WriteStringToFile,,,14,"Status leveldb.WriteStringToFile (Env*,Slice,ANY)"
65903,METHOD,include\leveldb\env.hpp:<global>,TYPE_DECL,"extern Status ReadFileToString(Env* env, const std::string& fname,
                               std::string* data);",15,49,include\leveldb\env.hpp,leveldb.ReadFileToString,,false,282,283,ReadFileToString,,,15,"Status leveldb.ReadFileToString (Env*,ANY,ANY*)"
65911,METHOD,leveldb.EnvWrapper,TYPE_DECL,explicit EnvWrapper(Env* t) : target_(t) { },3,46,include\leveldb\env.hpp,leveldb.EnvWrapper.EnvWrapper,,false,291,291,EnvWrapper,,,1,ANY leveldb.EnvWrapper.EnvWrapper (Env*)
65916,METHOD,leveldb.EnvWrapper,TYPE_DECL,virtual ~EnvWrapper();,11,23,include\leveldb\env.hpp,leveldb.EnvWrapper.~EnvWrapper,,false,292,292,~EnvWrapper,,,2,virtual leveldb.EnvWrapper.~EnvWrapper ()
65920,METHOD,leveldb.EnvWrapper,TYPE_DECL,Env* target() const { return target_; },3,41,include\leveldb\env.hpp,leveldb.EnvWrapper.target,,false,295,295,target,,,3,Env leveldb.EnvWrapper.target ()
65926,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status NewSequentialFile(const std::string& f, SequentialFile** r) {
    return target_->NewSequentialFile(f, r);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.NewSequentialFile,,false,298,300,NewSequentialFile,,,4,"Status leveldb.EnvWrapper.NewSequentialFile (ANY,SequentialFile**)"
65939,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {
    return target_->NewRandomAccessFile(f, r);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.NewRandomAccessFile,,false,301,303,NewRandomAccessFile,,,5,"Status leveldb.EnvWrapper.NewRandomAccessFile (ANY,RandomAccessFile**)"
65952,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status NewWritableFile(const std::string& f, WritableFile** r) {
    return target_->NewWritableFile(f, r);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.NewWritableFile,,false,304,306,NewWritableFile,,,6,"Status leveldb.EnvWrapper.NewWritableFile (ANY,WritableFile**)"
65965,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status NewAppendableFile(const std::string& f, WritableFile** r) {
    return target_->NewAppendableFile(f, r);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.NewAppendableFile,,false,307,309,NewAppendableFile,,,7,"Status leveldb.EnvWrapper.NewAppendableFile (ANY,WritableFile**)"
65978,METHOD,leveldb.EnvWrapper,TYPE_DECL,bool FileExists(const std::string& f) { return target_->FileExists(f); },3,74,include\leveldb\env.hpp,leveldb.EnvWrapper.FileExists,,false,310,310,FileExists,,,8,bool leveldb.EnvWrapper.FileExists (ANY)
65989,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status GetChildren(const std::string& dir, std::vector<std::string>* r) {
    return target_->GetChildren(dir, r);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.GetChildren,,false,311,313,GetChildren,,,9,"Status leveldb.EnvWrapper.GetChildren (ANY,ANY*)"
66002,METHOD,leveldb.EnvWrapper,TYPE_DECL,Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); },3,76,include\leveldb\env.hpp,leveldb.EnvWrapper.DeleteFile,,false,314,314,DeleteFile,,,10,Status leveldb.EnvWrapper.DeleteFile (ANY)
66013,METHOD,leveldb.EnvWrapper,TYPE_DECL,Status CreateDir(const std::string& d) { return target_->CreateDir(d); },3,74,include\leveldb\env.hpp,leveldb.EnvWrapper.CreateDir,,false,315,315,CreateDir,,,11,Status leveldb.EnvWrapper.CreateDir (ANY)
66024,METHOD,leveldb.EnvWrapper,TYPE_DECL,Status DeleteDir(const std::string& d) { return target_->DeleteDir(d); },3,74,include\leveldb\env.hpp,leveldb.EnvWrapper.DeleteDir,,false,316,316,DeleteDir,,,12,Status leveldb.EnvWrapper.DeleteDir (ANY)
66035,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status GetFileSize(const std::string& f, uint64_t* s) {
    return target_->GetFileSize(f, s);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.GetFileSize,,false,317,319,GetFileSize,,,13,"Status leveldb.EnvWrapper.GetFileSize (ANY,uint64_t*)"
66048,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status RenameFile(const std::string& s, const std::string& t) {
    return target_->RenameFile(s, t);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.RenameFile,,false,320,322,RenameFile,,,14,"Status leveldb.EnvWrapper.RenameFile (ANY,ANY)"
66061,METHOD,leveldb.EnvWrapper,TYPE_DECL,"Status LockFile(const std::string& f, FileLock** l) {
    return target_->LockFile(f, l);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.LockFile,,false,323,325,LockFile,,,15,"Status leveldb.EnvWrapper.LockFile (ANY,FileLock**)"
66074,METHOD,leveldb.EnvWrapper,TYPE_DECL,Status UnlockFile(FileLock* l) { return target_->UnlockFile(l); },3,67,include\leveldb\env.hpp,leveldb.EnvWrapper.UnlockFile,,false,326,326,UnlockFile,,,16,Status leveldb.EnvWrapper.UnlockFile (FileLock*)
66085,METHOD,leveldb.EnvWrapper,TYPE_DECL,"void Schedule(void (*f)(void*), void* a) {
    return target_->Schedule(f, a);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.Schedule,,false,327,329,Schedule,,,17,"void leveldb.EnvWrapper.Schedule (void,void*)"
66098,METHOD,leveldb.EnvWrapper,TYPE_DECL,"void StartThread(void (*f)(void*), void* a) {
    return target_->StartThread(f, a);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.StartThread,,false,330,332,StartThread,,,18,"void leveldb.EnvWrapper.StartThread (void,void*)"
66111,METHOD,leveldb.EnvWrapper,TYPE_DECL,"virtual Status GetTestDirectory(std::string* path) {
    return target_->GetTestDirectory(path);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.GetTestDirectory,,false,333,335,GetTestDirectory,,,19,Status leveldb.EnvWrapper.GetTestDirectory (ANY*)
66122,METHOD,leveldb.EnvWrapper,TYPE_DECL,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    return target_->NewLogger(fname, result);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.NewLogger,,false,336,338,NewLogger,,,20,"Status leveldb.EnvWrapper.NewLogger (ANY,Logger**)"
66135,METHOD,leveldb.EnvWrapper,TYPE_DECL,"uint64_t NowMicros() {
    return target_->NowMicros();
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.NowMicros,,false,339,341,NowMicros,,,21,uint64_t leveldb.EnvWrapper.NowMicros ()
66144,METHOD,leveldb.EnvWrapper,TYPE_DECL,"void SleepForMicroseconds(int micros) {
    target_->SleepForMicroseconds(micros);
  }",3,3,include\leveldb\env.hpp,leveldb.EnvWrapper.SleepForMicroseconds,,false,342,344,SleepForMicroseconds,,,22,void leveldb.EnvWrapper.SleepForMicroseconds (int)
66160,METHOD,include\leveldb\filter_policy.hpp:<global>,TYPE_DECL,<global>,1,51,include\leveldb\filter_policy.hpp,include\leveldb\filter_policy.hpp:<global>,,false,1,70,<global>,,,1,
66165,METHOD,leveldb.FilterPolicy,TYPE_DECL,virtual ~FilterPolicy();,11,25,include\leveldb\filter_policy.hpp,leveldb.FilterPolicy.~FilterPolicy,,false,27,27,~FilterPolicy,,,1,virtual leveldb.FilterPolicy.~FilterPolicy ()
66169,METHOD,leveldb.FilterPolicy,TYPE_DECL,virtual const char* Name() const = 0;,21,38,include\leveldb\filter_policy.hpp,leveldb.FilterPolicy.Name,,false,33,33,Name,,,2,char* leveldb.FilterPolicy.Name ()
66173,METHOD,leveldb.FilterPolicy,TYPE_DECL,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst)
      const = 0;",16,15,include\leveldb\filter_policy.hpp,leveldb.FilterPolicy.CreateFilter,,false,41,42,CreateFilter,,,3,"void leveldb.FilterPolicy.CreateFilter (Slice*,int,ANY*)"
66180,METHOD,leveldb.FilterPolicy,TYPE_DECL,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const = 0;",16,75,include\leveldb\filter_policy.hpp,leveldb.FilterPolicy.KeyMayMatch,,false,49,49,KeyMayMatch,,,4,"bool leveldb.FilterPolicy.KeyMayMatch (Slice,Slice)"
66186,METHOD,include\leveldb\filter_policy.hpp:<global>,TYPE_DECL,extern const FilterPolicy* NewBloomFilterPolicy(int bits_per_key);,26,65,include\leveldb\filter_policy.hpp,leveldb.NewBloomFilterPolicy,,false,66,66,NewBloomFilterPolicy,,,3,FilterPolicy* leveldb.NewBloomFilterPolicy (int)
66198,METHOD,include\leveldb\iterator.hpp:<global>,TYPE_DECL,<global>,1,1,include\leveldb\iterator.hpp,include\leveldb\iterator.hpp:<global>,,false,1,100,<global>,,,1,
66202,METHOD,leveldb.Iterator,TYPE_DECL,Iterator();,3,12,include\leveldb\iterator.hpp,leveldb.Iterator.Iterator,,false,25,25,Iterator,,,1,ANY leveldb.Iterator.Iterator ()
66206,METHOD,leveldb.Iterator,TYPE_DECL,virtual ~Iterator();,11,21,include\leveldb\iterator.hpp,leveldb.Iterator.~Iterator,,false,26,26,~Iterator,,,2,virtual leveldb.Iterator.~Iterator ()
66210,METHOD,leveldb.Iterator,TYPE_DECL,virtual bool Valid() const = 0;,16,32,include\leveldb\iterator.hpp,leveldb.Iterator.Valid,,false,30,30,Valid,,,3,bool leveldb.Iterator.Valid ()
66214,METHOD,leveldb.Iterator,TYPE_DECL,virtual void SeekToFirst() = 0;,16,32,include\leveldb\iterator.hpp,leveldb.Iterator.SeekToFirst,,false,34,34,SeekToFirst,,,4,void leveldb.Iterator.SeekToFirst ()
66218,METHOD,leveldb.Iterator,TYPE_DECL,virtual void SeekToLast() = 0;,16,31,include\leveldb\iterator.hpp,leveldb.Iterator.SeekToLast,,false,38,38,SeekToLast,,,5,void leveldb.Iterator.SeekToLast ()
66222,METHOD,leveldb.Iterator,TYPE_DECL,virtual void Seek(const Slice& target) = 0;,16,44,include\leveldb\iterator.hpp,leveldb.Iterator.Seek,,false,43,43,Seek,,,6,void leveldb.Iterator.Seek (Slice)
66227,METHOD,leveldb.Iterator,TYPE_DECL,virtual void Next() = 0;,16,25,include\leveldb\iterator.hpp,leveldb.Iterator.Next,,false,48,48,Next,,,7,void leveldb.Iterator.Next ()
66231,METHOD,leveldb.Iterator,TYPE_DECL,virtual void Prev() = 0;,16,25,include\leveldb\iterator.hpp,leveldb.Iterator.Prev,,false,53,53,Prev,,,8,void leveldb.Iterator.Prev ()
66235,METHOD,leveldb.Iterator,TYPE_DECL,virtual Slice key() const = 0;,17,31,include\leveldb\iterator.hpp,leveldb.Iterator.key,,false,59,59,key,,,9,Slice leveldb.Iterator.key ()
66239,METHOD,leveldb.Iterator,TYPE_DECL,virtual Slice value() const = 0;,17,33,include\leveldb\iterator.hpp,leveldb.Iterator.value,,false,65,65,value,,,10,Slice leveldb.Iterator.value ()
66243,METHOD,leveldb.Iterator,TYPE_DECL,virtual Status status() const = 0;,18,35,include\leveldb\iterator.hpp,leveldb.Iterator.status,,false,68,68,status,,,11,Status leveldb.Iterator.status ()
66247,METHOD,leveldb.Iterator,TYPE_DECL,"typedef void (*CleanupFunction)(void* arg1, void* arg2);",16,57,include\leveldb\iterator.hpp,leveldb.Iterator.CleanupFunction,,false,75,75,CleanupFunction,,,12,"void leveldb.Iterator.CleanupFunction (void*,void*)"
66253,METHOD,leveldb.Iterator,TYPE_DECL,"void RegisterCleanup(CleanupFunction function, void* arg1, void* arg2);",8,72,include\leveldb\iterator.hpp,leveldb.Iterator.RegisterCleanup,,false,76,76,RegisterCleanup,,,13,"void leveldb.Iterator.RegisterCleanup (CleanupFunction,void*,void*)"
66266,METHOD,leveldb.Iterator,TYPE_DECL,Iterator(const Iterator&);,3,27,include\leveldb\iterator.hpp,leveldb.Iterator.Iterator,,false,88,88,Iterator,,,16,ANY leveldb.Iterator.Iterator (Iterator)
66271,METHOD,leveldb.Iterator,TYPE_DECL,void operator=(const Iterator&);,8,33,include\leveldb\iterator.hpp,leveldb.Iterator.operator =,,false,89,89,operator =,,,17,void leveldb.Iterator.operator = (Iterator)
66276,METHOD,include\leveldb\iterator.hpp:<global>,TYPE_DECL,extern Iterator* NewEmptyIterator();,16,35,include\leveldb\iterator.hpp,leveldb.NewEmptyIterator,,false,93,93,NewEmptyIterator,,,2,Iterator* leveldb.NewEmptyIterator ()
66280,METHOD,include\leveldb\iterator.hpp:<global>,TYPE_DECL,extern Iterator* NewErrorIterator(const Status& status);,16,55,include\leveldb\iterator.hpp,leveldb.NewErrorIterator,,false,96,96,NewErrorIterator,,,3,Iterator* leveldb.NewErrorIterator (Status)
66290,METHOD,include\leveldb\options.hpp:<global>,TYPE_DECL,<global>,1,45,include\leveldb\options.hpp,include\leveldb\options.hpp:<global>,,false,1,213,<global>,,,1,
66302,METHOD,<empty>,<empty>,<empty>,1,,include\leveldb\options.hpp,leveldb.CompressionType:<clinit>,,false,23,,<clinit>,,,3,
66328,METHOD,leveldb.Options,TYPE_DECL,Options();,3,11,include\leveldb\options.hpp,leveldb.Options.Options,,false,157,157,Options,,,16,ANY leveldb.Options.Options ()
66336,METHOD,leveldb.ReadOptions,TYPE_DECL,"ReadOptions()
      : verify_checksums(false),
        fill_cache(true),
        snapshot(NULL) {
  }",3,3,include\leveldb\options.hpp,leveldb.ReadOptions.ReadOptions,,false,179,183,ReadOptions,,,4,ANY leveldb.ReadOptions.ReadOptions ()
66342,METHOD,leveldb.WriteOptions,TYPE_DECL,"WriteOptions()
      : sync(false) {
  }",3,3,include\leveldb\options.hpp,leveldb.WriteOptions.WriteOptions,,false,206,208,WriteOptions,,,2,ANY leveldb.WriteOptions.WriteOptions ()
66357,METHOD,include\leveldb\slice.hpp:<global>,TYPE_DECL,<global>,1,43,include\leveldb\slice.hpp,include\leveldb\slice.hpp:<global>,,false,1,109,<global>,,,1,
66361,METHOD,leveldb.Slice,TYPE_DECL,"Slice() : data_(""""), size_(0) { }",3,35,include\leveldb\slice.hpp,leveldb.Slice.Slice,,false,28,28,Slice,,,1,ANY leveldb.Slice.Slice ()
66365,METHOD,leveldb.Slice,TYPE_DECL,"Slice(const char* d, size_t n) : data_(d), size_(n) { }",3,57,include\leveldb\slice.hpp,leveldb.Slice.Slice,,false,31,31,Slice,,,2,"ANY leveldb.Slice.Slice (char*,size_t)"
66371,METHOD,leveldb.Slice,TYPE_DECL,"Slice(const std::string& s) : data_(s.data()), size_(s.size()) { }",3,68,include\leveldb\slice.hpp,leveldb.Slice.Slice,,false,34,34,Slice,,,3,ANY leveldb.Slice.Slice (ANY)
66376,METHOD,leveldb.Slice,TYPE_DECL,"Slice(const char* s) : data_(s), size_(strlen(s)) { }",3,55,include\leveldb\slice.hpp,leveldb.Slice.Slice,,false,37,37,Slice,,,4,ANY leveldb.Slice.Slice (char*)
66381,METHOD,leveldb.Slice,TYPE_DECL,const char* data() const { return data_; },3,44,include\leveldb\slice.hpp,leveldb.Slice.data,,false,40,40,data,,,5,const char* leveldb.Slice.data ()
66387,METHOD,leveldb.Slice,TYPE_DECL,size_t size() const { return size_; },3,39,include\leveldb\slice.hpp,leveldb.Slice.size,,false,43,43,size,,,6,size_t leveldb.Slice.size ()
66393,METHOD,leveldb.Slice,TYPE_DECL,bool empty() const { return size_ == 0; },3,43,include\leveldb\slice.hpp,leveldb.Slice.empty,,false,46,46,empty,,,7,bool leveldb.Slice.empty ()
66401,METHOD,leveldb.Slice,TYPE_DECL,"char operator[](size_t n) const {
    assert(n < size());
    return data_[n];
  }",3,3,include\leveldb\slice.hpp,leveldb.Slice.operator [],,false,50,53,operator [],,,8,char leveldb.Slice.operator [] (size_t)
66414,METHOD,leveldb.Slice,TYPE_DECL,"void clear() { data_ = """"; size_ = 0; }",3,41,include\leveldb\slice.hpp,leveldb.Slice.clear,,false,56,56,clear,,,9,void leveldb.Slice.clear ()
66424,METHOD,leveldb.Slice,TYPE_DECL,"void remove_prefix(size_t n) {
    assert(n <= size());
    data_ += n;
    size_ -= n;
  }",3,3,include\leveldb\slice.hpp,leveldb.Slice.remove_prefix,,false,59,63,remove_prefix,,,10,void leveldb.Slice.remove_prefix (size_t)
66439,METHOD,leveldb.Slice,TYPE_DECL,"std::string ToString() const { return std::string(data_, size_); }",3,68,include\leveldb\slice.hpp,leveldb.Slice.ToString,,false,66,66,ToString,,,11,string leveldb.Slice.ToString ()
66450,METHOD,leveldb.Slice,TYPE_DECL,int compare(const Slice& b) const;,7,35,include\leveldb\slice.hpp,leveldb.Slice.compare,,false,72,72,compare,,,12,int leveldb.Slice.compare (Slice)
66455,METHOD,leveldb.Slice,TYPE_DECL,"bool starts_with(const Slice& x) const {
    return ((size_ >= x.size_) &&
            (memcmp(data_, x.data_, x.size_) == 0));
  }",3,3,include\leveldb\slice.hpp,leveldb.Slice.starts_with,,false,75,78,starts_with,,,13,bool leveldb.Slice.starts_with (Slice)
66479,METHOD,include\leveldb\slice.hpp:<global>,TYPE_DECL,"inline bool operator==(const Slice& x, const Slice& y) {
  return ((x.size() == y.size()) &&
          (memcmp(x.data(), y.data(), x.size()) == 0));
}",1,1,include\leveldb\slice.hpp,leveldb.operator ==,,false,87,90,operator ==,,,2,"bool leveldb.operator == (Slice,Slice)"
66511,METHOD,include\leveldb\slice.hpp:<global>,TYPE_DECL,"inline bool operator!=(const Slice& x, const Slice& y) {
  return !(x == y);
}",1,1,include\leveldb\slice.hpp,leveldb.operator !=,,false,92,94,operator !=,,,3,"bool leveldb.operator != (Slice,Slice)"
66522,METHOD,include\leveldb\slice.hpp:<global>,TYPE_DECL,"inline int Slice::compare(const Slice& b) const {
  const size_t min_len = (size_ < b.size_) ? size_ : b.size_;
  int r = memcmp(data_, b.data_, min_len);
  if (r == 0) {
    if (size_ < b.size_) r = -1;
    else if (size_ > b.size_) r = +1;
  }
  return r;
}",1,1,include\leveldb\slice.hpp,leveldb.Slice.compare,,false,96,104,compare,,,4,int leveldb.Slice.compare (Slice)
66587,METHOD,include\leveldb\status.hpp:<global>,TYPE_DECL,<global>,1,18,include\leveldb\status.hpp,include\leveldb\status.hpp:<global>,,false,1,112,<global>,,,1,
66591,METHOD,leveldb.Status,TYPE_DECL,Status() : state_(NULL) { },3,29,include\leveldb\status.hpp,leveldb.Status.Status,,false,24,24,Status,,,1,ANY leveldb.Status.Status ()
66595,METHOD,leveldb.Status,TYPE_DECL,~Status() { delete[] state_; },3,32,include\leveldb\status.hpp,leveldb.Status.~Status,,false,25,25,~Status,,,2,ANY leveldb.Status.~Status ()
66601,METHOD,leveldb.Status,TYPE_DECL,Status(const Status& s);,3,25,include\leveldb\status.hpp,leveldb.Status.Status,,false,28,28,Status,,,3,ANY leveldb.Status.Status (Status)
66606,METHOD,leveldb.Status,TYPE_DECL,void operator=(const Status& s);,8,33,include\leveldb\status.hpp,leveldb.Status.operator =,,false,29,29,operator =,,,4,void leveldb.Status.operator = (Status)
66611,METHOD,leveldb.Status,TYPE_DECL,static Status OK() { return Status(); },3,41,include\leveldb\status.hpp,leveldb.Status.OK,,false,32,32,OK,,,5,Status leveldb.Status.OK ()
66617,METHOD,leveldb.Status,TYPE_DECL,"static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotFound, msg, msg2);
  }",3,3,include\leveldb\status.hpp,leveldb.Status.NotFound,,false,35,37,NotFound,,,6,"Status leveldb.Status.NotFound (Slice,Slice)"
66628,METHOD,leveldb.Status,TYPE_DECL,"static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kCorruption, msg, msg2);
  }",3,3,include\leveldb\status.hpp,leveldb.Status.Corruption,,false,38,40,Corruption,,,7,"Status leveldb.Status.Corruption (Slice,Slice)"
66639,METHOD,leveldb.Status,TYPE_DECL,"static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kNotSupported, msg, msg2);
  }",3,3,include\leveldb\status.hpp,leveldb.Status.NotSupported,,false,41,43,NotSupported,,,8,"Status leveldb.Status.NotSupported (Slice,Slice)"
66650,METHOD,leveldb.Status,TYPE_DECL,"static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kInvalidArgument, msg, msg2);
  }",3,3,include\leveldb\status.hpp,leveldb.Status.InvalidArgument,,false,44,46,InvalidArgument,,,9,"Status leveldb.Status.InvalidArgument (Slice,Slice)"
66661,METHOD,leveldb.Status,TYPE_DECL,"static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {
    return Status(kIOError, msg, msg2);
  }",3,3,include\leveldb\status.hpp,leveldb.Status.IOError,,false,47,49,IOError,,,10,"Status leveldb.Status.IOError (Slice,Slice)"
66672,METHOD,leveldb.Status,TYPE_DECL,bool ok() const { return (state_ == NULL); },3,46,include\leveldb\status.hpp,leveldb.Status.ok,,false,52,52,ok,,,11,bool leveldb.Status.ok ()
66680,METHOD,leveldb.Status,TYPE_DECL,bool IsNotFound() const { return code() == kNotFound; },3,57,include\leveldb\status.hpp,leveldb.Status.IsNotFound,,false,55,55,IsNotFound,,,12,bool leveldb.Status.IsNotFound ()
66688,METHOD,leveldb.Status,TYPE_DECL,bool IsCorruption() const { return code() == kCorruption; },3,61,include\leveldb\status.hpp,leveldb.Status.IsCorruption,,false,58,58,IsCorruption,,,13,bool leveldb.Status.IsCorruption ()
66696,METHOD,leveldb.Status,TYPE_DECL,bool IsIOError() const { return code() == kIOError; },3,55,include\leveldb\status.hpp,leveldb.Status.IsIOError,,false,61,61,IsIOError,,,14,bool leveldb.Status.IsIOError ()
66704,METHOD,leveldb.Status,TYPE_DECL,bool IsNotSupportedError() const { return code() == kNotSupported; },3,70,include\leveldb\status.hpp,leveldb.Status.IsNotSupportedError,,false,64,64,IsNotSupportedError,,,15,bool leveldb.Status.IsNotSupportedError ()
66712,METHOD,leveldb.Status,TYPE_DECL,bool IsInvalidArgument() const { return code() == kInvalidArgument; },3,71,include\leveldb\status.hpp,leveldb.Status.IsInvalidArgument,,false,67,67,IsInvalidArgument,,,16,bool leveldb.Status.IsInvalidArgument ()
66720,METHOD,leveldb.Status,TYPE_DECL,std::string ToString() const;,15,30,include\leveldb\status.hpp,leveldb.Status.ToString,,false,71,71,ToString,,,17,ANY leveldb.Status.ToString ()
66732,METHOD,<empty>,<empty>,<empty>,3,,include\leveldb\status.hpp,leveldb.Status.Code:<clinit>,,false,81,,<clinit>,,,7,
66754,METHOD,leveldb.Status,TYPE_DECL,"Code code() const {
    return (state_ == NULL) ? kOk : static_cast<Code>(state_[4]);
  }",3,3,include\leveldb\status.hpp,leveldb.Status.code,,false,90,92,code,,,20,Code leveldb.Status.code ()
66769,METHOD,leveldb.Status,TYPE_DECL,"Status(Code code, const Slice& msg, const Slice& msg2);",3,56,include\leveldb\status.hpp,leveldb.Status.Status,,false,94,94,Status,,,21,"ANY leveldb.Status.Status (Code,Slice,Slice)"
66776,METHOD,leveldb.Status,TYPE_DECL,static const char* CopyState(const char* s);,20,45,include\leveldb\status.hpp,leveldb.Status.CopyState,,false,95,95,CopyState,,,22,char* leveldb.Status.CopyState (char*)
66781,METHOD,include\leveldb\status.hpp:<global>,TYPE_DECL,"inline Status::Status(const Status& s) {
  state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
}",1,1,include\leveldb\status.hpp,leveldb.Status.Status,,false,98,100,Status,,,2,ANY leveldb.Status.Status (Status)
66799,METHOD,include\leveldb\status.hpp:<global>,TYPE_DECL,"inline void Status::operator=(const Status& s) {
  // The following condition catches both aliasing (when this == &s),
  // and the common case where both s and *this are ok.
  if (state_ != s.state_) {
    delete[] state_;
    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
  }
}",1,1,include\leveldb\status.hpp,leveldb.Status.operator =,,false,101,108,operator =,,,3,void leveldb.Status.operator = (Status)
66833,METHOD,include\leveldb\table.hpp:<global>,TYPE_DECL,<global>,1,22,include\leveldb\table.hpp,include\leveldb\table.hpp:<global>,,false,1,85,<global>,,,1,
66844,METHOD,leveldb.Table,TYPE_DECL,"static Status Open(const Options& options,
                     RandomAccessFile* file,
                     uint64_t file_size,
                     Table** table);",17,35,include\leveldb\table.hpp,leveldb.Table.Open,,false,38,41,Open,,,1,"Status leveldb.Table.Open (Options,RandomAccessFile*,uint64_t,Table**)"
66852,METHOD,leveldb.Table,TYPE_DECL,~Table();,3,10,include\leveldb\table.hpp,leveldb.Table.~Table,,false,43,43,~Table,,,2,ANY leveldb.Table.~Table ()
66856,METHOD,leveldb.Table,TYPE_DECL,Iterator* NewIterator(const ReadOptions&) const;,11,49,include\leveldb\table.hpp,leveldb.Table.NewIterator,,false,48,48,NewIterator,,,3,Iterator* leveldb.Table.NewIterator (ReadOptions)
66861,METHOD,leveldb.Table,TYPE_DECL,uint64_t ApproximateOffsetOf(const Slice& key) const;,12,54,include\leveldb\table.hpp,leveldb.Table.ApproximateOffsetOf,,false,56,56,ApproximateOffsetOf,,,4,uint64_t leveldb.Table.ApproximateOffsetOf (Slice)
66868,METHOD,leveldb.Table,TYPE_DECL,explicit Table(Rep* rep) { rep_ = rep; },3,42,include\leveldb\table.hpp,leveldb.Table.Table,,false,62,62,Table,,,7,ANY leveldb.Table.Table (Rep*)
66876,METHOD,leveldb.Table,TYPE_DECL,"static Iterator* BlockReader(void*, const ReadOptions&, const Slice&);",18,71,include\leveldb\table.hpp,leveldb.Table.BlockReader,,false,63,63,BlockReader,,,8,"Iterator* leveldb.Table.BlockReader (void*,ReadOptions,Slice)"
66884,METHOD,leveldb.Table,TYPE_DECL,"Status InternalGet(
      const ReadOptions&, const Slice& key,
      void* arg,
      void (*handle_result)(void* arg, const Slice& k, const Slice& v));",10,71,include\leveldb\table.hpp,leveldb.Table.InternalGet,,false,69,72,InternalGet,,,10,"Status leveldb.Table.InternalGet (ReadOptions,Slice,void*,void)"
66892,METHOD,leveldb.Table,TYPE_DECL,void ReadMeta(const Footer& footer);,8,37,include\leveldb\table.hpp,leveldb.Table.ReadMeta,,false,75,75,ReadMeta,,,11,void leveldb.Table.ReadMeta (Footer)
66897,METHOD,leveldb.Table,TYPE_DECL,void ReadFilter(const Slice& filter_handle_value);,8,51,include\leveldb\table.hpp,leveldb.Table.ReadFilter,,false,76,76,ReadFilter,,,12,void leveldb.Table.ReadFilter (Slice)
66902,METHOD,leveldb.Table,TYPE_DECL,Table(const Table&);,3,21,include\leveldb\table.hpp,leveldb.Table.Table,,false,79,79,Table,,,13,ANY leveldb.Table.Table (Table)
66907,METHOD,leveldb.Table,TYPE_DECL,void operator=(const Table&);,8,30,include\leveldb\table.hpp,leveldb.Table.operator =,,false,80,80,operator =,,,14,void leveldb.Table.operator = (Table)
66921,METHOD,include\leveldb\table_builder.hpp:<global>,TYPE_DECL,<global>,1,22,include\leveldb\table_builder.hpp,include\leveldb\table_builder.hpp:<global>,,false,1,92,<global>,,,1,
66928,METHOD,leveldb.TableBuilder,TYPE_DECL,"TableBuilder(const Options& options, WritableFile* file);",3,58,include\leveldb\table_builder.hpp,leveldb.TableBuilder.TableBuilder,,false,31,31,TableBuilder,,,1,"ANY leveldb.TableBuilder.TableBuilder (Options,WritableFile*)"
66934,METHOD,leveldb.TableBuilder,TYPE_DECL,~TableBuilder();,3,17,include\leveldb\table_builder.hpp,leveldb.TableBuilder.~TableBuilder,,false,34,34,~TableBuilder,,,2,ANY leveldb.TableBuilder.~TableBuilder ()
66938,METHOD,leveldb.TableBuilder,TYPE_DECL,Status ChangeOptions(const Options& options);,10,46,include\leveldb\table_builder.hpp,leveldb.TableBuilder.ChangeOptions,,false,42,42,ChangeOptions,,,3,Status leveldb.TableBuilder.ChangeOptions (Options)
66943,METHOD,leveldb.TableBuilder,TYPE_DECL,"void Add(const Slice& key, const Slice& value);",8,48,include\leveldb\table_builder.hpp,leveldb.TableBuilder.Add,,false,47,47,Add,,,4,"void leveldb.TableBuilder.Add (Slice,Slice)"
66949,METHOD,leveldb.TableBuilder,TYPE_DECL,void Flush();,8,14,include\leveldb\table_builder.hpp,leveldb.TableBuilder.Flush,,false,53,53,Flush,,,5,void leveldb.TableBuilder.Flush ()
66953,METHOD,leveldb.TableBuilder,TYPE_DECL,Status status() const;,10,23,include\leveldb\table_builder.hpp,leveldb.TableBuilder.status,,false,56,56,status,,,6,Status leveldb.TableBuilder.status ()
66957,METHOD,leveldb.TableBuilder,TYPE_DECL,Status Finish();,10,17,include\leveldb\table_builder.hpp,leveldb.TableBuilder.Finish,,false,61,61,Finish,,,7,Status leveldb.TableBuilder.Finish ()
66961,METHOD,leveldb.TableBuilder,TYPE_DECL,void Abandon();,8,16,include\leveldb\table_builder.hpp,leveldb.TableBuilder.Abandon,,false,68,68,Abandon,,,8,void leveldb.TableBuilder.Abandon ()
66965,METHOD,leveldb.TableBuilder,TYPE_DECL,uint64_t NumEntries() const;,12,29,include\leveldb\table_builder.hpp,leveldb.TableBuilder.NumEntries,,false,71,71,NumEntries,,,9,uint64_t leveldb.TableBuilder.NumEntries ()
66969,METHOD,leveldb.TableBuilder,TYPE_DECL,uint64_t FileSize() const;,12,27,include\leveldb\table_builder.hpp,leveldb.TableBuilder.FileSize,,false,75,75,FileSize,,,10,uint64_t leveldb.TableBuilder.FileSize ()
66973,METHOD,leveldb.TableBuilder,TYPE_DECL,bool ok() const { return status().ok(); },3,43,include\leveldb\table_builder.hpp,leveldb.TableBuilder.ok,,false,78,78,ok,,,11,bool leveldb.TableBuilder.ok ()
66982,METHOD,leveldb.TableBuilder,TYPE_DECL,"void WriteBlock(BlockBuilder* block, BlockHandle* handle);",8,59,include\leveldb\table_builder.hpp,leveldb.TableBuilder.WriteBlock,,false,79,79,WriteBlock,,,12,"void leveldb.TableBuilder.WriteBlock (BlockBuilder*,BlockHandle*)"
66988,METHOD,leveldb.TableBuilder,TYPE_DECL,"void WriteRawBlock(const Slice& data, CompressionType, BlockHandle* handle);",8,77,include\leveldb\table_builder.hpp,leveldb.TableBuilder.WriteRawBlock,,false,80,80,WriteRawBlock,,,13,"void leveldb.TableBuilder.WriteRawBlock (Slice,CompressionType,BlockHandle*)"
66997,METHOD,leveldb.TableBuilder,TYPE_DECL,TableBuilder(const TableBuilder&);,3,35,include\leveldb\table_builder.hpp,leveldb.TableBuilder.TableBuilder,,false,86,86,TableBuilder,,,16,ANY leveldb.TableBuilder.TableBuilder (TableBuilder)
67002,METHOD,leveldb.TableBuilder,TYPE_DECL,void operator=(const TableBuilder&);,8,37,include\leveldb\table_builder.hpp,leveldb.TableBuilder.operator =,,false,87,87,operator =,,,17,void leveldb.TableBuilder.operator = (TableBuilder)
67014,METHOD,include\leveldb\write_batch.hpp:<global>,TYPE_DECL,<global>,1,18,include\leveldb\write_batch.hpp,include\leveldb\write_batch.hpp:<global>,,false,1,64,<global>,,,1,
67019,METHOD,leveldb.WriteBatch,TYPE_DECL,WriteBatch();,3,14,include\leveldb\write_batch.hpp,leveldb.WriteBatch.WriteBatch,,false,33,33,WriteBatch,,,1,ANY leveldb.WriteBatch.WriteBatch ()
67023,METHOD,leveldb.WriteBatch,TYPE_DECL,~WriteBatch();,3,15,include\leveldb\write_batch.hpp,leveldb.WriteBatch.~WriteBatch,,false,34,34,~WriteBatch,,,2,ANY leveldb.WriteBatch.~WriteBatch ()
67027,METHOD,leveldb.WriteBatch,TYPE_DECL,"void Put(const Slice& key, const Slice& value);",8,48,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Put,,false,37,37,Put,,,3,"void leveldb.WriteBatch.Put (Slice,Slice)"
67033,METHOD,leveldb.WriteBatch,TYPE_DECL,void Delete(const Slice& key);,8,31,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Delete,,false,40,40,Delete,,,4,void leveldb.WriteBatch.Delete (Slice)
67038,METHOD,leveldb.WriteBatch,TYPE_DECL,void Clear();,8,14,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Clear,,false,43,43,Clear,,,5,void leveldb.WriteBatch.Clear ()
67043,METHOD,leveldb.WriteBatch.Handler,TYPE_DECL,virtual ~Handler();,13,22,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Handler.~Handler,,false,48,48,~Handler,,,1,virtual leveldb.WriteBatch.Handler.~Handler ()
67047,METHOD,leveldb.WriteBatch.Handler,TYPE_DECL,"virtual void Put(const Slice& key, const Slice& value) = 0;",18,62,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Handler.Put,,false,49,49,Put,,,2,"void leveldb.WriteBatch.Handler.Put (Slice,Slice)"
67053,METHOD,leveldb.WriteBatch.Handler,TYPE_DECL,virtual void Delete(const Slice& key) = 0;,18,45,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Handler.Delete,,false,50,50,Delete,,,3,void leveldb.WriteBatch.Handler.Delete (Slice)
67058,METHOD,leveldb.WriteBatch,TYPE_DECL,Status Iterate(Handler* handler) const;,10,40,include\leveldb\write_batch.hpp,leveldb.WriteBatch.Iterate,,false,52,52,Iterate,,,7,Status leveldb.WriteBatch.Iterate (Handler*)
67080,METHOD,issues\issue178_test.cc:<global>,TYPE_DECL,<global>,1,1,issues\issue178_test.cc,issues\issue178_test.cc:<global>,,false,1,92,<global>,,,1,
67087,METHOD,issues\issue178_test.cc:<global>,TYPE_DECL,"std::string Key1(int i) {
  char buf[100];
  snprintf(buf, sizeof(buf), ""my_key_%d"", i);
  return buf;
}",1,1,issues\issue178_test.cc,anonymous_namespace_1.Key1,,false,18,22,Key1,,,3,string anonymous_namespace_1.Key1 (int)
67101,METHOD,issues\issue178_test.cc:<global>,TYPE_DECL,"std::string Key2(int i) {
  return Key1(i) + ""_xxx"";
}",1,1,issues\issue178_test.cc,anonymous_namespace_2.Key2,,false,24,26,Key2,,,4,string anonymous_namespace_2.Key2 (int)
67113,METHOD,anonymous_namespace_5._Test_Test,TYPE_DECL,void void ();,1,20,issues\issue178_test.cc,anonymous_namespace_6._Test_Test._Run,,false,30,30,_Run,,,1,void anonymous_namespace_6._Test_Test._Run ()
67117,METHOD,anonymous_namespace_5._Test_Test,TYPE_DECL,"TEST(Issue178, Test)",1,20,issues\issue178_test.cc,anonymous_namespace_7._Test_Test._RunIt,,false,30,30,_RunIt,,,2,void anonymous_namespace_7._Test_Test._RunIt ()
67141,METHOD,issues\issue178_test.cc:<global>,TYPE_DECL,"TEST(Issue178, Test) {
  // Get rid of any state from an old run.
  std::string dbpath = leveldb::test::TmpDir() + ""/leveldb_cbug_test"";
  DestroyDB(dbpath, leveldb::Options());

  // Open database.  Disable compression since it affects the creation
  // of layers and the code below is trying to test against a very
  // specific scenario.
  leveldb::DB* db;
  leveldb::Options db_options;
  db_options.create_if_missing = true;
  db_options.compression = leveldb::kNoCompression;
  ASSERT_OK(leveldb::DB::Open(db_options, dbpath, &db));

  // create first key range
  leveldb::WriteBatch batch;
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key1(i), ""value for range 1 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // create second key range
  batch.Clear();
  for (size_t i = 0; i < kNumKeys; i++) {
    batch.Put(Key2(i), ""value for range 2 key"");
  }
  ASSERT_OK(db->Write(leveldb::WriteOptions(), &batch));

  // delete second key range
  batch.Clear();
  ...",1,20,issues\issue178_test.cc,anonymous_namespace_8._Test_Test._Run,,false,30,86,_Run,,,9,void anonymous_namespace_8._Test_Test._Run ()
67434,METHOD,issues\issue178_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,issues\issue178_test.cc,main,,false,90,92,main,,,2,"int main (int,char**)"
67454,METHOD,issues\issue200_test.cc:<global>,TYPE_DECL,<global>,1,1,issues\issue200_test.cc,issues\issue200_test.cc:<global>,,false,1,59,<global>,,,1,
67459,METHOD,leveldb._Test_Test,TYPE_DECL,void void ();,1,20,issues\issue200_test.cc,leveldb._Test_Test._Run,,false,16,16,_Run,,,1,void leveldb._Test_Test._Run ()
67463,METHOD,leveldb._Test_Test,TYPE_DECL,"TEST(Issue200, Test)",1,20,issues\issue200_test.cc,leveldb._Test_Test._RunIt,,false,16,16,_RunIt,,,2,void leveldb._Test_Test._RunIt ()
67487,METHOD,issues\issue200_test.cc:<global>,TYPE_DECL,"TEST(Issue200, Test) {
  // Get rid of any state from an old run.
  std::string dbpath = test::TmpDir() + ""/leveldb_issue200_test"";
  DestroyDB(dbpath, Options());

  DB *db;
  Options options;
  options.create_if_missing = true;
  ASSERT_OK(DB::Open(options, dbpath, &db));

  WriteOptions write_options;
  ASSERT_OK(db->Put(write_options, ""1"", ""b""));
  ASSERT_OK(db->Put(write_options, ""2"", ""c""));
  ASSERT_OK(db->Put(write_options, ""3"", ""d""));
  ASSERT_OK(db->Put(write_options, ""4"", ""e""));
  ASSERT_OK(db->Put(write_options, ""5"", ""f""));

  ReadOptions read_options;
  Iterator *iter = db->NewIterator(read_options);

  // Add an element that should not be reflected in the iterator.
  ASSERT_OK(db->Put(write_options, ""25"", ""cd""));

  iter->Seek(""5"");
  ASSERT_EQ(iter->key().ToString(), ""5"");
  iter->Prev();
  ASSERT_EQ(iter->key().ToString(), ""4"");
  iter->Prev();
  ASSERT_EQ(iter->key().ToString(), ""3"");
  iter->Next();
  ASSERT_EQ(iter->key().ToString(), ""4"");
  iter->Next();
  ASSERT_...",1,20,issues\issue200_test.cc,leveldb._Test_Test._Run,,false,16,53,_Run,,,5,void leveldb._Test_Test._Run ()
67834,METHOD,issues\issue200_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,issues\issue200_test.cc,main,,false,57,59,main,,,2,"int main (int,char**)"
67858,METHOD,port\atomic_pointer.hpp:<global>,TYPE_DECL,<global>,1,33,port\atomic_pointer.hpp,port\atomic_pointer.hpp:<global>,,false,1,242,<global>,,,1,
67871,METHOD,port\port.hpp:<global>,TYPE_DECL,<global>,1,39,port\port.hpp,port\port.hpp:<global>,,false,1,19,<global>,,,1,
67876,METHOD,port\port_example.hpp:<global>,TYPE_DECL,<global>,1,47,port\port_example.hpp,port\port_example.hpp:<global>,,false,1,141,<global>,,,1,
67885,METHOD,leveldb.port.Mutex,TYPE_DECL,Mutex();,3,9,port\port_example.hpp,leveldb.port.Mutex.Mutex,,false,28,28,Mutex,,,1,ANY leveldb.port.Mutex.Mutex ()
67889,METHOD,leveldb.port.Mutex,TYPE_DECL,~Mutex();,3,10,port\port_example.hpp,leveldb.port.Mutex.~Mutex,,false,29,29,~Mutex,,,2,ANY leveldb.port.Mutex.~Mutex ()
67893,METHOD,leveldb.port.Mutex,TYPE_DECL,void Lock();,8,13,port\port_example.hpp,leveldb.port.Mutex.Lock,,false,33,33,Lock,,,3,void leveldb.port.Mutex.Lock ()
67897,METHOD,leveldb.port.Mutex,TYPE_DECL,void Unlock();,8,15,port\port_example.hpp,leveldb.port.Mutex.Unlock,,false,37,37,Unlock,,,4,void leveldb.port.Mutex.Unlock ()
67901,METHOD,leveldb.port.Mutex,TYPE_DECL,void AssertHeld();,8,19,port\port_example.hpp,leveldb.port.Mutex.AssertHeld,,false,42,42,AssertHeld,,,5,void leveldb.port.Mutex.AssertHeld ()
67906,METHOD,leveldb.port.CondVar,TYPE_DECL,explicit CondVar(Mutex* mu);,12,29,port\port_example.hpp,leveldb.port.CondVar.CondVar,,false,47,47,CondVar,,,1,explicit leveldb.port.CondVar.CondVar (Mutex*)
67911,METHOD,leveldb.port.CondVar,TYPE_DECL,~CondVar();,3,12,port\port_example.hpp,leveldb.port.CondVar.~CondVar,,false,48,48,~CondVar,,,2,ANY leveldb.port.CondVar.~CondVar ()
67915,METHOD,leveldb.port.CondVar,TYPE_DECL,void Wait();,8,13,port\port_example.hpp,leveldb.port.CondVar.Wait,,false,54,54,Wait,,,3,void leveldb.port.CondVar.Wait ()
67919,METHOD,leveldb.port.CondVar,TYPE_DECL,void Signal();,8,15,port\port_example.hpp,leveldb.port.CondVar.Signal,,false,57,57,Signal,,,4,void leveldb.port.CondVar.Signal ()
67923,METHOD,leveldb.port.CondVar,TYPE_DECL,void SignallAll();,8,19,port\port_example.hpp,leveldb.port.CondVar.SignallAll,,false,60,60,SignallAll,,,5,void leveldb.port.CondVar.SignallAll ()
67928,METHOD,port\port_example.hpp:<global>,TYPE_DECL,"extern void InitOnce(port::OnceType*, void (*initializer)());",13,60,port\port_example.hpp,leveldb.port.InitOnce,,false,71,71,InitOnce,,,6,"void leveldb.port.InitOnce (ANY*,void)"
67936,METHOD,leveldb.port.AtomicPointer,TYPE_DECL,AtomicPointer();,3,17,port\port_example.hpp,leveldb.port.AtomicPointer.AtomicPointer,,false,80,80,AtomicPointer,,,2,ANY leveldb.port.AtomicPointer.AtomicPointer ()
67940,METHOD,leveldb.port.AtomicPointer,TYPE_DECL,explicit AtomicPointer(void* v) : rep_(v) { },3,47,port\port_example.hpp,leveldb.port.AtomicPointer.AtomicPointer,,false,83,83,AtomicPointer,,,3,ANY leveldb.port.AtomicPointer.AtomicPointer (void*)
67945,METHOD,leveldb.port.AtomicPointer,TYPE_DECL,void* Acquire_Load() const;,7,28,port\port_example.hpp,leveldb.port.AtomicPointer.Acquire_Load,,false,88,88,Acquire_Load,,,4,void* leveldb.port.AtomicPointer.Acquire_Load ()
67949,METHOD,leveldb.port.AtomicPointer,TYPE_DECL,void Release_Store(void* v);,8,29,port\port_example.hpp,leveldb.port.AtomicPointer.Release_Store,,false,93,93,Release_Store,,,5,void leveldb.port.AtomicPointer.Release_Store (void*)
67954,METHOD,leveldb.port.AtomicPointer,TYPE_DECL,void* NoBarrier_Load() const;,7,30,port\port_example.hpp,leveldb.port.AtomicPointer.NoBarrier_Load,,false,96,96,NoBarrier_Load,,,6,void* leveldb.port.AtomicPointer.NoBarrier_Load ()
67958,METHOD,leveldb.port.AtomicPointer,TYPE_DECL,void NoBarrier_Store(void* v);,8,31,port\port_example.hpp,leveldb.port.AtomicPointer.NoBarrier_Store,,false,99,99,NoBarrier_Store,,,7,void leveldb.port.AtomicPointer.NoBarrier_Store (void*)
67963,METHOD,port\port_example.hpp:<global>,TYPE_DECL,"extern bool Snappy_Compress(const char* input, size_t input_length,
                            std::string* output);",13,48,port\port_example.hpp,leveldb.port.Snappy_Compress,,false,106,107,Snappy_Compress,,,8,"bool leveldb.port.Snappy_Compress (char*,size_t,ANY*)"
67970,METHOD,port\port_example.hpp:<global>,TYPE_DECL,"extern bool Snappy_GetUncompressedLength(const char* input, size_t length,
                                         size_t* result);",13,56,port\port_example.hpp,leveldb.port.Snappy_GetUncompressedLength,,false,112,113,Snappy_GetUncompressedLength,,,9,"bool leveldb.port.Snappy_GetUncompressedLength (char*,size_t,size_t*)"
67977,METHOD,port\port_example.hpp:<global>,TYPE_DECL,"extern bool Snappy_Uncompress(const char* input_data, size_t input_length,
                              char* output);",13,43,port\port_example.hpp,leveldb.port.Snappy_Uncompress,,false,122,123,Snappy_Uncompress,,,10,"bool leveldb.port.Snappy_Uncompress (char*,size_t,char*)"
67984,METHOD,port\port_example.hpp:<global>,TYPE_DECL,"extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);",13,76,port\port_example.hpp,leveldb.port.GetHeapProfile,,false,130,130,GetHeapProfile,,,11,"bool leveldb.port.GetHeapProfile (void,void*)"
67990,METHOD,port\port_example.hpp:<global>,TYPE_DECL,"uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);",10,70,port\port_example.hpp,leveldb.port.AcceleratedCRC32C,,false,136,136,AcceleratedCRC32C,,,12,"uint32_t leveldb.port.AcceleratedCRC32C (uint32_t,char*,size_t)"
68008,METHOD,port\port_posix.cc:<global>,TYPE_DECL,<global>,1,1,port\port_posix.cc,port\port_posix.cc:<global>,,false,1,53,<global>,,,1,
68012,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"static void PthreadCall(const char* label, int result) {
  if (result != 0) {
    fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
    abort();
  }
}",1,1,port\port_posix.cc,leveldb.port.PthreadCall,,false,14,19,PthreadCall,,,1,"void leveldb.port.PthreadCall (char*,int)"
68030,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"Mutex::Mutex() { PthreadCall(""init mutex"", pthread_mutex_init(&mu_, NULL)); }",1,77,port\port_posix.cc,leveldb.port.Mutex.Mutex,,false,21,21,Mutex,,,2,ANY leveldb.port.Mutex.Mutex ()
68040,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"Mutex::~Mutex() { PthreadCall(""destroy mutex"", pthread_mutex_destroy(&mu_)); }",1,78,port\port_posix.cc,leveldb.port.Mutex.~Mutex,,false,23,23,~Mutex,,,3,ANY leveldb.port.Mutex.~Mutex ()
68049,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"void Mutex::Lock() { PthreadCall(""lock"", pthread_mutex_lock(&mu_)); }",1,69,port\port_posix.cc,leveldb.port.Mutex.Lock,,false,25,25,Lock,,,4,void leveldb.port.Mutex.Lock ()
68058,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"void Mutex::Unlock() { PthreadCall(""unlock"", pthread_mutex_unlock(&mu_)); }",1,75,port\port_posix.cc,leveldb.port.Mutex.Unlock,,false,27,27,Unlock,,,5,void leveldb.port.Mutex.Unlock ()
68067,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"CondVar::CondVar(Mutex* mu)
    : mu_(mu) {
    PthreadCall(""init cv"", pthread_cond_init(&cv_, NULL));
}",1,1,port\port_posix.cc,leveldb.port.CondVar.CondVar,,false,29,32,CondVar,,,6,ANY leveldb.port.CondVar.CondVar (Mutex*)
68078,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"CondVar::~CondVar() { PthreadCall(""destroy cv"", pthread_cond_destroy(&cv_)); }",1,78,port\port_posix.cc,leveldb.port.CondVar.~CondVar,,false,34,34,~CondVar,,,7,ANY leveldb.port.CondVar.~CondVar ()
68087,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"void CondVar::Wait() {
  PthreadCall(""wait"", pthread_cond_wait(&cv_, &mu_->mu_));
}",1,1,port\port_posix.cc,leveldb.port.CondVar.Wait,,false,36,38,Wait,,,8,void leveldb.port.CondVar.Wait ()
68100,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"void CondVar::Signal() {
  PthreadCall(""signal"", pthread_cond_signal(&cv_));
}",1,1,port\port_posix.cc,leveldb.port.CondVar.Signal,,false,40,42,Signal,,,9,void leveldb.port.CondVar.Signal ()
68109,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"void CondVar::SignalAll() {
  PthreadCall(""broadcast"", pthread_cond_broadcast(&cv_));
}",1,1,port\port_posix.cc,leveldb.port.CondVar.SignalAll,,false,44,46,SignalAll,,,10,void leveldb.port.CondVar.SignalAll ()
68118,METHOD,port\port_posix.cc:<global>,TYPE_DECL,"void InitOnce(OnceType* once, void (*initializer)()) {
  PthreadCall(""once"", pthread_once(once, initializer));
}",1,1,port\port_posix.cc,leveldb.port.InitOnce,,false,48,50,InitOnce,,,11,"void leveldb.port.InitOnce (OnceType*,void)"
68154,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,<global>,1,18,port\port_posix.hpp,port\port_posix.hpp:<global>,,false,1,156,<global>,,,1,
68168,METHOD,leveldb.port.Mutex,TYPE_DECL,Mutex();,3,9,port\port_posix.hpp,leveldb.port.Mutex.Mutex,,false,84,84,Mutex,,,1,ANY leveldb.port.Mutex.Mutex ()
68172,METHOD,leveldb.port.Mutex,TYPE_DECL,~Mutex();,3,10,port\port_posix.hpp,leveldb.port.Mutex.~Mutex,,false,85,85,~Mutex,,,2,ANY leveldb.port.Mutex.~Mutex ()
68176,METHOD,leveldb.port.Mutex,TYPE_DECL,void Lock();,8,13,port\port_posix.hpp,leveldb.port.Mutex.Lock,,false,87,87,Lock,,,3,void leveldb.port.Mutex.Lock ()
68180,METHOD,leveldb.port.Mutex,TYPE_DECL,void Unlock();,8,15,port\port_posix.hpp,leveldb.port.Mutex.Unlock,,false,88,88,Unlock,,,4,void leveldb.port.Mutex.Unlock ()
68184,METHOD,leveldb.port.Mutex,TYPE_DECL,void AssertHeld() { },3,23,port\port_posix.hpp,leveldb.port.Mutex.AssertHeld,,false,89,89,AssertHeld,,,5,void leveldb.port.Mutex.AssertHeld ()
68190,METHOD,leveldb.port.Mutex,TYPE_DECL,Mutex(const Mutex&);,3,21,port\port_posix.hpp,leveldb.port.Mutex.Mutex,,false,96,96,Mutex,,,8,ANY leveldb.port.Mutex.Mutex (Mutex)
68195,METHOD,leveldb.port.Mutex,TYPE_DECL,void operator=(const Mutex&);,8,30,port\port_posix.hpp,leveldb.port.Mutex.operator =,,false,97,97,operator =,,,9,void leveldb.port.Mutex.operator = (Mutex)
68201,METHOD,leveldb.port.CondVar,TYPE_DECL,explicit CondVar(Mutex* mu);,12,29,port\port_posix.hpp,leveldb.port.CondVar.CondVar,,false,102,102,CondVar,,,1,explicit leveldb.port.CondVar.CondVar (Mutex*)
68206,METHOD,leveldb.port.CondVar,TYPE_DECL,~CondVar();,3,12,port\port_posix.hpp,leveldb.port.CondVar.~CondVar,,false,103,103,~CondVar,,,2,ANY leveldb.port.CondVar.~CondVar ()
68210,METHOD,leveldb.port.CondVar,TYPE_DECL,void Wait();,8,13,port\port_posix.hpp,leveldb.port.CondVar.Wait,,false,104,104,Wait,,,3,void leveldb.port.CondVar.Wait ()
68214,METHOD,leveldb.port.CondVar,TYPE_DECL,void Signal();,8,15,port\port_posix.hpp,leveldb.port.CondVar.Signal,,false,105,105,Signal,,,4,void leveldb.port.CondVar.Signal ()
68218,METHOD,leveldb.port.CondVar,TYPE_DECL,void SignalAll();,8,18,port\port_posix.hpp,leveldb.port.CondVar.SignalAll,,false,106,106,SignalAll,,,5,void leveldb.port.CondVar.SignalAll ()
68225,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,"extern void InitOnce(OnceType* once, void (*initializer)());",13,59,port\port_posix.hpp,leveldb.port.InitOnce,,false,114,114,InitOnce,,,7,"void leveldb.port.InitOnce (OnceType*,void)"
68231,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,"inline bool Snappy_Compress(const char* input, size_t length,
                            ::std::string* output) {
#ifdef SNAPPY
  output->resize(snappy::MaxCompressedLength(length));
  size_t outlen;
  snappy::RawCompress(input, length, &(*output)[0], &outlen);
  output->resize(outlen);
  return true;
#endif

  return false;
}",1,1,port\port_posix.hpp,leveldb.port.Snappy_Compress,,false,116,127,Snappy_Compress,,,8,"bool leveldb.port.Snappy_Compress (char*,size_t,ANY*)"
68240,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,"inline bool Snappy_GetUncompressedLength(const char* input, size_t length,
                                         size_t* result) {
#ifdef SNAPPY
  return snappy::GetUncompressedLength(input, length, result);
#else
  return false;
#endif
}",1,1,port\port_posix.hpp,leveldb.port.Snappy_GetUncompressedLength,,false,129,136,Snappy_GetUncompressedLength,,,9,"bool leveldb.port.Snappy_GetUncompressedLength (char*,size_t,size_t*)"
68249,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,"inline bool Snappy_Uncompress(const char* input, size_t length,
                              char* output) {
#ifdef SNAPPY
  return snappy::RawUncompress(input, length, output);
#else
  return false;
#endif
}",1,1,port\port_posix.hpp,leveldb.port.Snappy_Uncompress,,false,138,145,Snappy_Uncompress,,,10,"bool leveldb.port.Snappy_Uncompress (char*,size_t,char*)"
68258,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,"inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {
  return false;
}",1,1,port\port_posix.hpp,leveldb.port.GetHeapProfile,,false,147,149,GetHeapProfile,,,11,"bool leveldb.port.GetHeapProfile (void,void*)"
68266,METHOD,port\port_posix.hpp:<global>,TYPE_DECL,"uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);",10,70,port\port_posix.hpp,leveldb.port.AcceleratedCRC32C,,false,151,151,AcceleratedCRC32C,,,12,"uint32_t leveldb.port.AcceleratedCRC32C (uint32_t,char*,size_t)"
68288,METHOD,port\port_posix_sse.cc:<global>,TYPE_DECL,<global>,1,22,port\port_posix_sse.cc,port\port_posix_sse.cc:<global>,,false,1,129,<global>,,,1,
68292,METHOD,port\port_posix_sse.cc:<global>,TYPE_DECL,"uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {
#if !defined(LEVELDB_PLATFORM_POSIX_SSE)
  return 0;
#else
  static bool have = HaveSSE42();
  if (!have) {
    return 0;
  }

  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
  const uint8_t *e = p + size;
  uint32_t l = crc ^ 0xffffffffu;

#define STEP1 do {                              \
    l = _mm_crc32_u8(l, *p++);                  \
} while (0)
#define STEP4 do {                              \
    l = _mm_crc32_u32(l, LE_LOAD32(p));         \
    p += 4;                                     \
} while (0)
#define STEP8 do {                              \
    l = _mm_crc32_u64(l, LE_LOAD64(p));         \
    p += 8;                                     \
} while (0)

  if (size > 16) {
    // Process unaligned bytes
    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {
      STEP1;
    }

    // _mm_crc32_u64 is only available on x64.
#if defined(_M_X64) || defined(__x86_64__)
 ...",1,1,port\port_posix_sse.cc,leveldb.port.AcceleratedCRC32C,,false,69,126,AcceleratedCRC32C,,,1,"uint32_t leveldb.port.AcceleratedCRC32C (uint32_t,char*,size_t)"
68304,METHOD,port\thread_annotations.hpp:<global>,TYPE_DECL,<global>,1,53,port\thread_annotations.hpp,port\thread_annotations.hpp:<global>,,false,1,60,<global>,,,1,
68309,METHOD,port\win\stdint.hpp:<global>,TYPE_DECL,<global>,1,45,port\win\stdint.hpp,port\win\stdint.hpp:<global>,,false,1,24,<global>,,,1,
68336,METHOD,table\block.cc:<global>,TYPE_DECL,<global>,1,1,table\block.cc,table\block.cc:<global>,,false,1,268,<global>,,,1,
68339,METHOD,table\block.cc:<global>,TYPE_DECL,"inline uint32_t Block::NumRestarts() const {
  assert(size_ >= sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}",1,1,table\block.cc,leveldb.Block.NumRestarts,,false,18,21,NumRestarts,,,1,uint32_t leveldb.Block.NumRestarts ()
68356,METHOD,table\block.cc:<global>,TYPE_DECL,"Block::Block(const BlockContents& contents)
    : data_(contents.data.data()),
      size_(contents.data.size()),
      owned_(contents.heap_allocated) {
  if (size_ < sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    size_t max_restarts_allowed = (size_-sizeof(uint32_t)) / sizeof(uint32_t);
    if (NumRestarts() > max_restarts_allowed) {
      // The size is too small for NumRestarts()
      size_ = 0;
    } else {
      restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t);
    }
  }
}",1,1,table\block.cc,leveldb.Block.Block,,false,23,38,Block,,,2,ANY leveldb.Block.Block (BlockContents)
68402,METHOD,table\block.cc:<global>,TYPE_DECL,"Block::~Block() {
  if (owned_) {
    delete[] data_;
  }
}",1,1,table\block.cc,leveldb.Block.~Block,,false,40,44,~Block,,,3,ANY leveldb.Block.~Block ()
68411,METHOD,table\block.cc:<global>,TYPE_DECL,"static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared,
                                      uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p < 3) return NULL;
  *shared = reinterpret_cast<const unsigned char*>(p)[0];
  *non_shared = reinterpret_cast<const unsigned char*>(p)[1];
  *value_length = reinterpret_cast<const unsigned char*>(p)[2];
  if ((*shared | *non_shared | *value_length) < 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else {
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }

  if (static_cast<uint32_t>(limit - p) < (*non_shared + *value_length)) {
    return NULL;
  }
  return p;
}",1,1,table\block.cc,leveldb.DecodeEntry,,false,53,74,DecodeEntry,,,4,"const char* leveldb.DecodeEntry (char*,char*,uint32_t*,uint32_t*,uint32_t*)"
68533,METHOD,leveldb.Iter,TYPE_DECL,"inline int Compare(const Slice& a, const Slice& b) const {
    return comparator_->Compare(a, b);
  }",3,3,table\block.cc,leveldb.Iter.Compare,,false,90,92,Compare,,,10,"int leveldb.Iter.Compare (Slice,Slice)"
68546,METHOD,leveldb.Iter,TYPE_DECL,"inline uint32_t NextEntryOffset() const {
    return (value_.data() + value_.size()) - data_;
  }",3,3,table\block.cc,leveldb.Iter.NextEntryOffset,,false,95,97,NextEntryOffset,,,11,uint32_t leveldb.Iter.NextEntryOffset ()
68562,METHOD,leveldb.Iter,TYPE_DECL,"uint32_t GetRestartPoint(uint32_t index) {
    assert(index < num_restarts_);
    return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
  }",3,3,table\block.cc,leveldb.Iter.GetRestartPoint,,false,99,102,GetRestartPoint,,,12,uint32_t leveldb.Iter.GetRestartPoint (uint32_t)
68581,METHOD,leveldb.Iter,TYPE_DECL,"void SeekToRestartPoint(uint32_t index) {
    key_.clear();
    restart_index_ = index;
    // current_ will be fixed by ParseNextKey();

    // ParseNextKey() starts at the end of value_, so set value_ accordingly
    uint32_t offset = GetRestartPoint(index);
    value_ = Slice(data_ + offset, 0);
  }",3,3,table\block.cc,leveldb.Iter.SeekToRestartPoint,,false,104,112,SeekToRestartPoint,,,13,void leveldb.Iter.SeekToRestartPoint (uint32_t)
68605,METHOD,leveldb.Iter,TYPE_DECL,"Iter(const Comparator* comparator,
       const char* data,
       uint32_t restarts,
       uint32_t num_restarts)
      : comparator_(comparator),
        data_(data),
        restarts_(restarts),
        num_restarts_(num_restarts),
        current_(restarts_),
        restart_index_(num_restarts_) {
    assert(num_restarts_ > 0);
  }",3,3,table\block.cc,leveldb.Iter.Iter,,false,115,126,Iter,,,14,"ANY leveldb.Iter.Iter (Comparator*,char*,uint32_t,uint32_t)"
68617,METHOD,leveldb.Iter,TYPE_DECL,virtual bool Valid() const { return current_ < restarts_; },3,61,table\block.cc,leveldb.Iter.Valid,,false,128,128,Valid,,,15,bool leveldb.Iter.Valid ()
68625,METHOD,leveldb.Iter,TYPE_DECL,virtual Status status() const { return status_; },3,51,table\block.cc,leveldb.Iter.status,,false,129,129,status,,,16,Status leveldb.Iter.status ()
68631,METHOD,leveldb.Iter,TYPE_DECL,"virtual Slice key() const {
    assert(Valid());
    return key_;
  }",3,3,table\block.cc,leveldb.Iter.key,,false,130,133,key,,,17,Slice leveldb.Iter.key ()
68639,METHOD,leveldb.Iter,TYPE_DECL,"virtual Slice value() const {
    assert(Valid());
    return value_;
  }",3,3,table\block.cc,leveldb.Iter.value,,false,134,137,value,,,18,Slice leveldb.Iter.value ()
68647,METHOD,leveldb.Iter,TYPE_DECL,"virtual void Next() {
    assert(Valid());
    ParseNextKey();
  }",3,3,table\block.cc,leveldb.Iter.Next,,false,139,142,Next,,,19,void leveldb.Iter.Next ()
68654,METHOD,leveldb.Iter,TYPE_DECL,"virtual void Prev() {
    assert(Valid());

    // Scan backwards to a restart point before current_
    const uint32_t original = current_;
    while (GetRestartPoint(restart_index_) >= original) {
      if (restart_index_ == 0) {
        // No more entries
        current_ = restarts_;
        restart_index_ = num_restarts_;
        return;
      }
      restart_index_--;
    }

    SeekToRestartPoint(restart_index_);
    do {
      // Loop until end of current entry hits the start of original entry
    } while (ParseNextKey() && NextEntryOffset() < original);
  }",3,3,table\block.cc,leveldb.Iter.Prev,,false,144,163,Prev,,,20,void leveldb.Iter.Prev ()
68693,METHOD,leveldb.Iter,TYPE_DECL,"virtual void Seek(const Slice& target) {
    // Binary search in restart array to find the last restart point
    // with a key < target
    uint32_t left = 0;
    uint32_t right = num_restarts_ - 1;
    while (left < right) {
      uint32_t mid = (left + right + 1) / 2;
      uint32_t region_offset = GetRestartPoint(mid);
      uint32_t shared, non_shared, value_length;
      const char* key_ptr = DecodeEntry(data_ + region_offset,
                                        data_ + restarts_,
                                        &shared, &non_shared, &value_length);
      if (key_ptr == NULL || (shared != 0)) {
        CorruptionError();
        return;
      }
      Slice mid_key(key_ptr, non_shared);
      if (Compare(mid_key, target) < 0) {
        // Key at ""mid"" is smaller than ""target"".  Therefore all
        // blocks before ""mid"" are uninteresting.
        left = mid;
      } else {
        // Key at ""mid"" is >= ""target"".  Therefore all blocks at or
        // after ""mid"" a...",3,3,table\block.cc,leveldb.Iter.Seek,,false,165,203,Seek,,,21,void leveldb.Iter.Seek (Slice)
68797,METHOD,leveldb.Iter,TYPE_DECL,"virtual void SeekToFirst() {
    SeekToRestartPoint(0);
    ParseNextKey();
  }",3,3,table\block.cc,leveldb.Iter.SeekToFirst,,false,205,208,SeekToFirst,,,22,void leveldb.Iter.SeekToFirst ()
68804,METHOD,leveldb.Iter,TYPE_DECL,"virtual void SeekToLast() {
    SeekToRestartPoint(num_restarts_ - 1);
    while (ParseNextKey() && NextEntryOffset() < restarts_) {
      // Keep skipping
    }
  }",3,3,table\block.cc,leveldb.Iter.SeekToLast,,false,210,215,SeekToLast,,,23,void leveldb.Iter.SeekToLast ()
68819,METHOD,leveldb.Iter,TYPE_DECL,"void CorruptionError() {
    current_ = restarts_;
    restart_index_ = num_restarts_;
    status_ = Status::Corruption(""bad entry in block"");
    key_.clear();
    value_.clear();
  }",3,3,table\block.cc,leveldb.Iter.CorruptionError,,false,218,224,CorruptionError,,,24,void leveldb.Iter.CorruptionError ()
68844,METHOD,leveldb.Iter,TYPE_DECL,"bool ParseNextKey() {
    current_ = NextEntryOffset();
    const char* p = data_ + current_;
    const char* limit = data_ + restarts_;  // Restarts come right after data
    if (p >= limit) {
      // No more entries to return.  Mark as invalid.
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return false;
    }

    // Decode next entry
    uint32_t shared, non_shared, value_length;
    p = DecodeEntry(p, limit, &shared, &non_shared, &value_length);
    if (p == NULL || key_.size() < shared) {
      CorruptionError();
      return false;
    } else {
      key_.resize(shared);
      key_.append(p, non_shared);
      value_ = Slice(p + non_shared, value_length);
      while (restart_index_ + 1 < num_restarts_ &&
             GetRestartPoint(restart_index_ + 1) < current_) {
        ++restart_index_;
      }
      return true;
    }
  }",3,3,table\block.cc,leveldb.Iter.ParseNextKey,,false,226,253,ParseNextKey,,,25,bool leveldb.Iter.ParseNextKey ()
68943,METHOD,table\block.cc:<global>,TYPE_DECL,"Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ < sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption(""bad block contents""));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);
  }
}",1,1,table\block.cc,leveldb.Block.NewIterator,,false,256,266,NewIterator,,,6,Iterator leveldb.Block.NewIterator (Comparator*)
68990,METHOD,table\block.hpp:<global>,TYPE_DECL,<global>,1,22,table\block.hpp,table\block.hpp:<global>,,false,1,44,<global>,,,1,
68996,METHOD,leveldb.Block,TYPE_DECL,explicit Block(const BlockContents& contents);,12,47,table\block.hpp,leveldb.Block.Block,,false,20,20,Block,,,1,explicit leveldb.Block.Block (BlockContents)
69001,METHOD,leveldb.Block,TYPE_DECL,~Block();,3,10,table\block.hpp,leveldb.Block.~Block,,false,22,22,~Block,,,2,ANY leveldb.Block.~Block ()
69005,METHOD,leveldb.Block,TYPE_DECL,size_t size() const { return size_; },3,39,table\block.hpp,leveldb.Block.size,,false,24,24,size,,,3,size_t leveldb.Block.size ()
69011,METHOD,leveldb.Block,TYPE_DECL,Iterator* NewIterator(const Comparator* comparator);,11,53,table\block.hpp,leveldb.Block.NewIterator,,false,25,25,NewIterator,,,4,Iterator* leveldb.Block.NewIterator (Comparator*)
69016,METHOD,leveldb.Block,TYPE_DECL,uint32_t NumRestarts() const;,12,30,table\block.hpp,leveldb.Block.NumRestarts,,false,28,28,NumRestarts,,,5,uint32_t leveldb.Block.NumRestarts ()
69024,METHOD,leveldb.Block,TYPE_DECL,Block(const Block&);,3,21,table\block.hpp,leveldb.Block.Block,,false,36,36,Block,,,10,ANY leveldb.Block.Block (Block)
69029,METHOD,leveldb.Block,TYPE_DECL,void operator=(const Block&);,8,30,table\block.hpp,leveldb.Block.operator =,,false,37,37,operator =,,,11,void leveldb.Block.operator = (Block)
69050,METHOD,table\block_builder.cc:<global>,TYPE_DECL,<global>,1,1,table\block_builder.cc,table\block_builder.cc:<global>,,false,1,109,<global>,,,1,
69053,METHOD,table\block_builder.cc:<global>,TYPE_DECL,"BlockBuilder::BlockBuilder(const Options* options)
    : options_(options),
      restarts_(),
      counter_(0),
      finished_(false) {
  assert(options->block_restart_interval >= 1);
  restarts_.push_back(0);       // First restart point is at offset 0
}",1,1,table\block_builder.cc,leveldb.BlockBuilder.BlockBuilder,,false,39,46,BlockBuilder,,,1,ANY leveldb.BlockBuilder.BlockBuilder (Options*)
69069,METHOD,table\block_builder.cc:<global>,TYPE_DECL,"void BlockBuilder::Reset() {
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       // First restart point is at offset 0
  counter_ = 0;
  finished_ = false;
  last_key_.clear();
}",1,1,table\block_builder.cc,leveldb.BlockBuilder.Reset,,false,48,55,Reset,,,2,void leveldb.BlockBuilder.Reset ()
69096,METHOD,table\block_builder.cc:<global>,TYPE_DECL,"size_t BlockBuilder::CurrentSizeEstimate() const {
  return (buffer_.size() +                        // Raw data buffer
          restarts_.size() * sizeof(uint32_t) +   // Restart array
          sizeof(uint32_t));                      // Restart array length
}",1,1,table\block_builder.cc,leveldb.BlockBuilder.CurrentSizeEstimate,,false,57,61,CurrentSizeEstimate,,,3,size_t leveldb.BlockBuilder.CurrentSizeEstimate ()
69116,METHOD,table\block_builder.cc:<global>,TYPE_DECL,"Slice BlockBuilder::Finish() {
  // Append restart array
  for (size_t i = 0; i < restarts_.size(); i++) {
    PutFixed32(&buffer_, restarts_[i]);
  }
  PutFixed32(&buffer_, restarts_.size());
  finished_ = true;
  return Slice(buffer_);
}",1,1,table\block_builder.cc,leveldb.BlockBuilder.Finish,,false,63,71,Finish,,,4,Slice leveldb.BlockBuilder.Finish ()
69154,METHOD,table\block_builder.cc:<global>,TYPE_DECL,"void BlockBuilder::Add(const Slice& key, const Slice& value) {
  Slice last_key_piece(last_key_);
  assert(!finished_);
  assert(counter_ <= options_->block_restart_interval);
  assert(buffer_.empty() // No values yet?
         || options_->comparator->Compare(key, last_key_piece) > 0);
  size_t shared = 0;
  if (counter_ < options_->block_restart_interval) {
    // See how much sharing to do with previous string
    const size_t min_length = std::min(last_key_piece.size(), key.size());
    while ((shared < min_length) && (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } else {
    // Restart compression
    restarts_.push_back(buffer_.size());
    counter_ = 0;
  }
  const size_t non_shared = key.size() - shared;

  // Add ""<shared><non_shared><value_size>"" to buffer_
  PutVarint32(&buffer_, shared);
  PutVarint32(&buffer_, non_shared);
  PutVarint32(&buffer_, value.size());

  // Add string delta to buffer_ followed by value
  buffer_.append(key.data() + shared,...",1,1,table\block_builder.cc,leveldb.BlockBuilder.Add,,false,73,107,Add,,,5,"void leveldb.BlockBuilder.Add (Slice,Slice)"
69321,METHOD,table\block_builder.hpp:<global>,TYPE_DECL,<global>,1,22,table\block_builder.hpp,table\block_builder.hpp:<global>,,false,1,57,<global>,,,1,
69326,METHOD,leveldb.BlockBuilder,TYPE_DECL,explicit BlockBuilder(const Options* options);,12,47,table\block_builder.hpp,leveldb.BlockBuilder.BlockBuilder,,false,19,19,BlockBuilder,,,1,explicit leveldb.BlockBuilder.BlockBuilder (Options*)
69331,METHOD,leveldb.BlockBuilder,TYPE_DECL,void Reset();,8,14,table\block_builder.hpp,leveldb.BlockBuilder.Reset,,false,22,22,Reset,,,2,void leveldb.BlockBuilder.Reset ()
69335,METHOD,leveldb.BlockBuilder,TYPE_DECL,"void Add(const Slice& key, const Slice& value);",8,48,table\block_builder.hpp,leveldb.BlockBuilder.Add,,false,26,26,Add,,,3,"void leveldb.BlockBuilder.Add (Slice,Slice)"
69341,METHOD,leveldb.BlockBuilder,TYPE_DECL,Slice Finish();,9,16,table\block_builder.hpp,leveldb.BlockBuilder.Finish,,false,31,31,Finish,,,4,Slice leveldb.BlockBuilder.Finish ()
69345,METHOD,leveldb.BlockBuilder,TYPE_DECL,size_t CurrentSizeEstimate() const;,10,36,table\block_builder.hpp,leveldb.BlockBuilder.CurrentSizeEstimate,,false,35,35,CurrentSizeEstimate,,,5,size_t leveldb.BlockBuilder.CurrentSizeEstimate ()
69349,METHOD,leveldb.BlockBuilder,TYPE_DECL,"bool empty() const {
    return buffer_.empty();
  }",3,3,table\block_builder.hpp,leveldb.BlockBuilder.empty,,false,38,40,empty,,,6,bool leveldb.BlockBuilder.empty ()
69364,METHOD,leveldb.BlockBuilder,TYPE_DECL,BlockBuilder(const BlockBuilder&);,3,35,table\block_builder.hpp,leveldb.BlockBuilder.BlockBuilder,,false,51,51,BlockBuilder,,,13,ANY leveldb.BlockBuilder.BlockBuilder (BlockBuilder)
69369,METHOD,leveldb.BlockBuilder,TYPE_DECL,void operator=(const BlockBuilder&);,8,37,table\block_builder.hpp,leveldb.BlockBuilder.operator =,,false,52,52,operator =,,,14,void leveldb.BlockBuilder.operator = (BlockBuilder)
69383,METHOD,table\filter_block.cc:<global>,TYPE_DECL,<global>,1,1,table\filter_block.cc,table\filter_block.cc:<global>,,false,1,111,<global>,,,1,
69396,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)
    : policy_(policy) {
}",1,1,table\filter_block.cc,leveldb.FilterBlockBuilder.FilterBlockBuilder,,false,18,20,FilterBlockBuilder,,,5,ANY leveldb.FilterBlockBuilder.FilterBlockBuilder (FilterPolicy*)
69401,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"void FilterBlockBuilder::StartBlock(uint64_t block_offset) {
  uint64_t filter_index = (block_offset / kFilterBase);
  assert(filter_index >= filter_offsets_.size());
  while (filter_index > filter_offsets_.size()) {
    GenerateFilter();
  }
}",1,1,table\filter_block.cc,leveldb.FilterBlockBuilder.StartBlock,,false,22,28,StartBlock,,,6,void leveldb.FilterBlockBuilder.StartBlock (uint64_t)
69428,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"void FilterBlockBuilder::AddKey(const Slice& key) {
  Slice k = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}",1,1,table\filter_block.cc,leveldb.FilterBlockBuilder.AddKey,,false,30,34,AddKey,,,7,void leveldb.FilterBlockBuilder.AddKey (Slice)
69457,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"Slice FilterBlockBuilder::Finish() {
  if (!start_.empty()) {
    GenerateFilter();
  }

  // Append array of per-filter offsets
  const uint32_t array_offset = result_.size();
  for (size_t i = 0; i < filter_offsets_.size(); i++) {
    PutFixed32(&result_, filter_offsets_[i]);
  }

  PutFixed32(&result_, array_offset);
  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
  return Slice(result_);
}",1,1,table\filter_block.cc,leveldb.FilterBlockBuilder.Finish,,false,36,50,Finish,,,8,Slice leveldb.FilterBlockBuilder.Finish ()
69509,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"void FilterBlockBuilder::GenerateFilter() {
  const size_t num_keys = start_.size();
  if (num_keys == 0) {
    // Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  }

  // Make list of keys from flattened key structure
  start_.push_back(keys_.size());  // Simplify length computation
  tmp_keys_.resize(num_keys);
  for (size_t i = 0; i < num_keys; i++) {
    const char* base = keys_.data() + start_[i];
    size_t length = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  // Generate filter for current set of keys and append to result_.
  filter_offsets_.push_back(result_.size());
  policy_->CreateFilter(&tmp_keys_[0], static_cast<int>(num_keys), &result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}",1,1,table\filter_block.cc,leveldb.FilterBlockBuilder.GenerateFilter,,false,52,76,GenerateFilter,,,9,void leveldb.FilterBlockBuilder.GenerateFilter ()
69622,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
                                     const Slice& contents)
    : policy_(policy),
      data_(NULL),
      offset_(NULL),
      num_(0),
      base_lg_(0) {
  size_t n = contents.size();
  if (n < 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
  base_lg_ = contents[n-1];
  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
  if (last_word > n - 5) return;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}",1,1,table\filter_block.cc,leveldb.FilterBlockReader.FilterBlockReader,,false,78,93,FilterBlockReader,,,10,"ANY leveldb.FilterBlockReader.FilterBlockReader (FilterPolicy*,Slice)"
69688,METHOD,table\filter_block.cc:<global>,TYPE_DECL,"bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice& key) {
  uint64_t index = block_offset >> base_lg_;
  if (index < num_) {
    uint32_t start = DecodeFixed32(offset_ + index*4);
    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4);
    if (start <= limit && limit <= static_cast<size_t>(offset_ - data_)) {
      Slice filter = Slice(data_ + start, limit - start);
      return policy_->KeyMayMatch(key, filter);
    } else if (start == limit) {
      // Empty filters do not match any keys
      return false;
    }
  }
  return true;  // Errors are treated as potential matches
}",1,1,table\filter_block.cc,leveldb.FilterBlockReader.KeyMayMatch,,false,95,109,KeyMayMatch,,,11,"bool leveldb.FilterBlockReader.KeyMayMatch (uint64_t,Slice)"
69781,METHOD,table\filter_block.hpp:<global>,TYPE_DECL,<global>,1,18,table\filter_block.hpp,table\filter_block.hpp:<global>,,false,1,68,<global>,,,1,
69786,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,explicit FilterBlockBuilder(const FilterPolicy*);,12,50,table\filter_block.hpp,leveldb.FilterBlockBuilder.FilterBlockBuilder,,false,31,31,FilterBlockBuilder,,,1,explicit leveldb.FilterBlockBuilder.FilterBlockBuilder (FilterPolicy*)
69791,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,void StartBlock(uint64_t block_offset);,8,40,table\filter_block.hpp,leveldb.FilterBlockBuilder.StartBlock,,false,33,33,StartBlock,,,2,void leveldb.FilterBlockBuilder.StartBlock (uint64_t)
69796,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,void AddKey(const Slice& key);,8,31,table\filter_block.hpp,leveldb.FilterBlockBuilder.AddKey,,false,34,34,AddKey,,,3,void leveldb.FilterBlockBuilder.AddKey (Slice)
69801,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,Slice Finish();,9,16,table\filter_block.hpp,leveldb.FilterBlockBuilder.Finish,,false,35,35,Finish,,,4,Slice leveldb.FilterBlockBuilder.Finish ()
69805,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,void GenerateFilter();,8,23,table\filter_block.hpp,leveldb.FilterBlockBuilder.GenerateFilter,,false,38,38,GenerateFilter,,,5,void leveldb.FilterBlockBuilder.GenerateFilter ()
69815,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,FilterBlockBuilder(const FilterBlockBuilder&);,3,47,table\filter_block.hpp,leveldb.FilterBlockBuilder.FilterBlockBuilder,,false,48,48,FilterBlockBuilder,,,12,ANY leveldb.FilterBlockBuilder.FilterBlockBuilder (FilterBlockBuilder)
69820,METHOD,leveldb.FilterBlockBuilder,TYPE_DECL,void operator=(const FilterBlockBuilder&);,8,43,table\filter_block.hpp,leveldb.FilterBlockBuilder.operator =,,false,49,49,operator =,,,13,void leveldb.FilterBlockBuilder.operator = (FilterBlockBuilder)
69826,METHOD,leveldb.FilterBlockReader,TYPE_DECL,"FilterBlockReader(const FilterPolicy* policy, const Slice& contents);",3,70,table\filter_block.hpp,leveldb.FilterBlockReader.FilterBlockReader,,false,55,55,FilterBlockReader,,,1,"ANY leveldb.FilterBlockReader.FilterBlockReader (FilterPolicy*,Slice)"
69832,METHOD,leveldb.FilterBlockReader,TYPE_DECL,"bool KeyMayMatch(uint64_t block_offset, const Slice& key);",8,59,table\filter_block.hpp,leveldb.FilterBlockReader.KeyMayMatch,,false,56,56,KeyMayMatch,,,2,"bool leveldb.FilterBlockReader.KeyMayMatch (uint64_t,Slice)"
69860,METHOD,table\filter_block_test.cc:<global>,TYPE_DECL,<global>,1,1,table\filter_block_test.cc,table\filter_block_test.cc:<global>,,false,1,128,<global>,,,1,
69864,METHOD,leveldb.TestHashFilter,TYPE_DECL,"virtual const char* Name() const {
    return ""TestHashFilter"";
  }",3,3,table\filter_block_test.cc,leveldb.TestHashFilter.Name,,false,19,21,Name,,,1,const char* leveldb.TestHashFilter.Name ()
69870,METHOD,leveldb.TestHashFilter,TYPE_DECL,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    for (int i = 0; i < n; i++) {
      uint32_t h = Hash(keys[i].data(), keys[i].size(), 1);
      PutFixed32(dst, h);
    }
  }",3,3,table\filter_block_test.cc,leveldb.TestHashFilter.CreateFilter,,false,23,28,CreateFilter,,,2,"void leveldb.TestHashFilter.CreateFilter (Slice*,int,ANY*)"
69909,METHOD,leveldb.TestHashFilter,TYPE_DECL,"virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {
    uint32_t h = Hash(key.data(), key.size(), 1);
    for (size_t i = 0; i + 4 <= filter.size(); i += 4) {
      if (h == DecodeFixed32(filter.data() + i)) {
        return true;
      }
    }
    return false;
  }",3,3,table\filter_block_test.cc,leveldb.TestHashFilter.KeyMayMatch,,false,30,38,KeyMayMatch,,,3,"bool leveldb.TestHashFilter.KeyMayMatch (Slice,Slice)"
69964,METHOD,leveldb._Test_EmptyBuilder,TYPE_DECL,void void ();,1,35,table\filter_block_test.cc,leveldb._Test_EmptyBuilder._Run,,false,46,46,_Run,,,1,void leveldb._Test_EmptyBuilder._Run ()
69968,METHOD,leveldb._Test_EmptyBuilder,TYPE_DECL,"TEST(FilterBlockTest, EmptyBuilder)",1,35,table\filter_block_test.cc,leveldb._Test_EmptyBuilder._RunIt,,false,46,46,_RunIt,,,2,void leveldb._Test_EmptyBuilder._RunIt ()
69992,METHOD,table\filter_block_test.cc:<global>,TYPE_DECL,"TEST(FilterBlockTest, EmptyBuilder) {
  FilterBlockBuilder builder(&policy_);
  Slice block = builder.Finish();
  ASSERT_EQ(""\\x00\\x00\\x00\\x00\\x0b"", EscapeString(block));
  FilterBlockReader reader(&policy_, block);
  ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""));
}",1,35,table\filter_block_test.cc,leveldb._Test_EmptyBuilder._Run,,false,46,53,_Run,,,6,void leveldb._Test_EmptyBuilder._Run ()
70072,METHOD,leveldb._Test_SingleChunk,TYPE_DECL,void void ();,1,34,table\filter_block_test.cc,leveldb._Test_SingleChunk._Run,,false,55,55,_Run,,,1,void leveldb._Test_SingleChunk._Run ()
70076,METHOD,leveldb._Test_SingleChunk,TYPE_DECL,"TEST(FilterBlockTest, SingleChunk)",1,34,table\filter_block_test.cc,leveldb._Test_SingleChunk._RunIt,,false,55,55,_RunIt,,,2,void leveldb._Test_SingleChunk._RunIt ()
70100,METHOD,table\filter_block_test.cc:<global>,TYPE_DECL,"TEST(FilterBlockTest, SingleChunk) {
  FilterBlockBuilder builder(&policy_);
  builder.StartBlock(100);
  builder.AddKey(""foo"");
  builder.AddKey(""bar"");
  builder.AddKey(""box"");
  builder.StartBlock(200);
  builder.AddKey(""box"");
  builder.StartBlock(300);
  builder.AddKey(""hello"");
  Slice block = builder.Finish();
  FilterBlockReader reader(&policy_, block);
  ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""box""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""));
  ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""));
  ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""));
}",1,34,table\filter_block_test.cc,leveldb._Test_SingleChunk._Run,,false,55,74,_Run,,,10,void leveldb._Test_SingleChunk._Run ()
70303,METHOD,leveldb._Test_MultiChunk,TYPE_DECL,void void ();,1,33,table\filter_block_test.cc,leveldb._Test_MultiChunk._Run,,false,76,76,_Run,,,1,void leveldb._Test_MultiChunk._Run ()
70307,METHOD,leveldb._Test_MultiChunk,TYPE_DECL,"TEST(FilterBlockTest, MultiChunk)",1,33,table\filter_block_test.cc,leveldb._Test_MultiChunk._RunIt,,false,76,76,_RunIt,,,2,void leveldb._Test_MultiChunk._RunIt ()
70331,METHOD,table\filter_block_test.cc:<global>,TYPE_DECL,"TEST(FilterBlockTest, MultiChunk) {
  FilterBlockBuilder builder(&policy_);

  // First filter
  builder.StartBlock(0);
  builder.AddKey(""foo"");
  builder.StartBlock(2000);
  builder.AddKey(""bar"");

  // Second filter
  builder.StartBlock(3100);
  builder.AddKey(""box"");

  // Third filter is empty

  // Last filter
  builder.StartBlock(9000);
  builder.AddKey(""box"");
  builder.AddKey(""hello"");

  Slice block = builder.Finish();
  FilterBlockReader reader(&policy_, block);

  // Check first filter
  ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""));
  ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""));
  ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""));
  ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""));

  // Check second filter
  ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""));
  ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""));

  // Check third filter (empty)
  ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo"")...",1,33,table\filter_block_test.cc,leveldb._Test_MultiChunk._Run,,false,76,122,_Run,,,14,void leveldb._Test_MultiChunk._Run ()
70727,METHOD,table\filter_block_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,table\filter_block_test.cc,main,,false,126,128,main,,,2,"int main (int,char**)"
70755,METHOD,table\format.cc:<global>,TYPE_DECL,<global>,1,1,table\format.cc,table\format.cc:<global>,,false,1,144,<global>,,,1,
70758,METHOD,table\format.cc:<global>,TYPE_DECL,"void BlockHandle::EncodeTo(std::string* dst) const {
  // Sanity check that all fields have been set
  assert(offset_ != ~static_cast<uint64_t>(0));
  assert(size_ != ~static_cast<uint64_t>(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}",1,1,table\format.cc,leveldb.BlockHandle.EncodeTo,,false,15,21,EncodeTo,,,1,void leveldb.BlockHandle.EncodeTo (ANY*)
70783,METHOD,table\format.cc:<global>,TYPE_DECL,"Status BlockHandle::DecodeFrom(Slice* input) {
  if (GetVarint64(input, &offset_) &&
      GetVarint64(input, &size_)) {
    return Status::OK();
  } else {
    return Status::Corruption(""bad block handle"");
  }
}",1,1,table\format.cc,leveldb.BlockHandle.DecodeFrom,,false,23,30,DecodeFrom,,,2,Status leveldb.BlockHandle.DecodeFrom (Slice*)
70812,METHOD,table\format.cc:<global>,TYPE_DECL,"void Footer::EncodeTo(std::string* dst) const {
  const size_t original_size = dst->size();
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst->resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber & 0xffffffffu));
  PutFixed32(dst, static_cast<uint32_t>(kTableMagicNumber >> 32));
  assert(dst->size() == original_size + kEncodedLength);
  (void)original_size;  // Disable unused variable warning.
}",1,1,table\format.cc,leveldb.Footer.EncodeTo,,false,32,41,EncodeTo,,,3,void leveldb.Footer.EncodeTo (ANY*)
70869,METHOD,table\format.cc:<global>,TYPE_DECL,"Status Footer::DecodeFrom(Slice* input) {
  const char* magic_ptr = input->data() + kEncodedLength - 8;
  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
  const uint64_t magic = ((static_cast<uint64_t>(magic_hi) << 32) |
                          (static_cast<uint64_t>(magic_lo)));
  if (magic != kTableMagicNumber) {
    return Status::Corruption(""not an sstable (bad magic number)"");
  }

  Status result = metaindex_handle_.DecodeFrom(input);
  if (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  if (result.ok()) {
    // We skip over any leftover data (just padding for now) in ""input""
    const char* end = magic_ptr + 8;
    *input = Slice(end, input->data() + input->size() - end);
  }
  return result;
}",1,1,table\format.cc,leveldb.Footer.DecodeFrom,,false,43,63,DecodeFrom,,,4,Status leveldb.Footer.DecodeFrom (Slice*)
70971,METHOD,table\format.cc:<global>,TYPE_DECL,"Status ReadBlock(RandomAccessFile* file,
                 const ReadOptions& options,
                 const BlockHandle& handle,
                 BlockContents* result) {
  result->data = Slice();
  result->cachable = false;
  result->heap_allocated = false;

  // Read the block contents as well as the type/crc footer.
  // See table_builder.cc for the code that built this structure.
  size_t n = static_cast<size_t>(handle.size());
  char* buf = new char[n + kBlockTrailerSize];
  Slice contents;
  Status s = file->Read(handle.offset(), n + kBlockTrailerSize, &contents, buf);
  if (!s.ok()) {
    delete[] buf;
    return s;
  }
  if (contents.size() != n + kBlockTrailerSize) {
    delete[] buf;
    return Status::Corruption(""truncated block read"");
  }

  // Check the crc of the type and the block contents
  const char* data = contents.data();    // Pointer to where Read put the data
  if (options.verify_checksums) {
    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1...",1,1,table\format.cc,leveldb.ReadBlock,,false,65,142,ReadBlock,,,5,"Status leveldb.ReadBlock (RandomAccessFile*,ReadOptions,BlockHandle,BlockContents*)"
71256,METHOD,table\format.hpp:<global>,TYPE_DECL,<global>,1,22,table\format.hpp,table\format.hpp:<global>,,false,1,108,<global>,,,1,
71263,METHOD,leveldb.BlockHandle,TYPE_DECL,BlockHandle();,3,15,table\format.hpp,leveldb.BlockHandle.BlockHandle,,false,24,24,BlockHandle,,,1,ANY leveldb.BlockHandle.BlockHandle ()
71267,METHOD,leveldb.BlockHandle,TYPE_DECL,uint64_t offset() const { return offset_; },3,45,table\format.hpp,leveldb.BlockHandle.offset,,false,27,27,offset,,,2,uint64_t leveldb.BlockHandle.offset ()
71273,METHOD,leveldb.BlockHandle,TYPE_DECL,void set_offset(uint64_t offset) { offset_ = offset; },3,56,table\format.hpp,leveldb.BlockHandle.set_offset,,false,28,28,set_offset,,,3,void leveldb.BlockHandle.set_offset (uint64_t)
71281,METHOD,leveldb.BlockHandle,TYPE_DECL,uint64_t size() const { return size_; },3,41,table\format.hpp,leveldb.BlockHandle.size,,false,31,31,size,,,4,uint64_t leveldb.BlockHandle.size ()
71287,METHOD,leveldb.BlockHandle,TYPE_DECL,void set_size(uint64_t size) { size_ = size; },3,48,table\format.hpp,leveldb.BlockHandle.set_size,,false,32,32,set_size,,,5,void leveldb.BlockHandle.set_size (uint64_t)
71295,METHOD,leveldb.BlockHandle,TYPE_DECL,void EncodeTo(std::string* dst) const;,8,39,table\format.hpp,leveldb.BlockHandle.EncodeTo,,false,34,34,EncodeTo,,,6,void leveldb.BlockHandle.EncodeTo (ANY*)
71300,METHOD,leveldb.BlockHandle,TYPE_DECL,Status DecodeFrom(Slice* input);,10,33,table\format.hpp,leveldb.BlockHandle.DecodeFrom,,false,35,35,DecodeFrom,,,7,Status leveldb.BlockHandle.DecodeFrom (Slice*)
71307,METHOD,<empty>,<empty>,<empty>,3,,table\format.hpp,leveldb.BlockHandle.anonymous_enum_0:<clinit>,,false,38,,<clinit>,,,2,
71319,METHOD,leveldb.Footer,TYPE_DECL,Footer() { },3,14,table\format.hpp,leveldb.Footer.Footer,,false,49,49,Footer,,,1,ANY leveldb.Footer.Footer ()
71323,METHOD,leveldb.Footer,TYPE_DECL,const BlockHandle& metaindex_handle() const { return metaindex_handle_; },3,75,table\format.hpp,leveldb.Footer.metaindex_handle,,false,52,52,metaindex_handle,,,2,BlockHandle leveldb.Footer.metaindex_handle ()
71329,METHOD,leveldb.Footer,TYPE_DECL,void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; },3,76,table\format.hpp,leveldb.Footer.set_metaindex_handle,,false,53,53,set_metaindex_handle,,,3,void leveldb.Footer.set_metaindex_handle (BlockHandle)
71337,METHOD,leveldb.Footer,TYPE_DECL,"const BlockHandle& index_handle() const {
    return index_handle_;
  }",3,3,table\format.hpp,leveldb.Footer.index_handle,,false,56,58,index_handle,,,4,BlockHandle leveldb.Footer.index_handle ()
71343,METHOD,leveldb.Footer,TYPE_DECL,"void set_index_handle(const BlockHandle& h) {
    index_handle_ = h;
  }",3,3,table\format.hpp,leveldb.Footer.set_index_handle,,false,59,61,set_index_handle,,,5,void leveldb.Footer.set_index_handle (BlockHandle)
71351,METHOD,leveldb.Footer,TYPE_DECL,void EncodeTo(std::string* dst) const;,8,39,table\format.hpp,leveldb.Footer.EncodeTo,,false,63,63,EncodeTo,,,6,void leveldb.Footer.EncodeTo (ANY*)
71356,METHOD,leveldb.Footer,TYPE_DECL,Status DecodeFrom(Slice* input);,10,33,table\format.hpp,leveldb.Footer.DecodeFrom,,false,64,64,DecodeFrom,,,7,Status leveldb.Footer.DecodeFrom (Slice*)
71363,METHOD,<empty>,<empty>,<empty>,3,,table\format.hpp,leveldb.Footer.anonymous_enum_1:<clinit>,,false,69,,<clinit>,,,2,
71390,METHOD,table\format.hpp:<global>,TYPE_DECL,"extern Status ReadBlock(RandomAccessFile* file,
                        const ReadOptions& options,
                        const BlockHandle& handle,
                        BlockContents* result);",15,46,table\format.hpp,leveldb.ReadBlock,,false,94,97,ReadBlock,,,11,"Status leveldb.ReadBlock (RandomAccessFile*,ReadOptions,BlockHandle,BlockContents*)"
71398,METHOD,table\format.hpp:<global>,TYPE_DECL,"inline BlockHandle::BlockHandle()
    : offset_(~static_cast<uint64_t>(0)),
      size_(~static_cast<uint64_t>(0)) {
}",1,1,table\format.hpp,leveldb.BlockHandle.BlockHandle,,false,101,104,BlockHandle,,,12,ANY leveldb.BlockHandle.BlockHandle ()
71407,METHOD,table\iterator.cc:<global>,TYPE_DECL,<global>,1,1,table\iterator.cc,table\iterator.cc:<global>,,false,1,67,<global>,,,1,
71410,METHOD,table\iterator.cc:<global>,TYPE_DECL,"Iterator::Iterator() {
  cleanup_.function = NULL;
  cleanup_.next = NULL;
}",1,1,table\iterator.cc,leveldb.Iterator.Iterator,,false,9,12,Iterator,,,1,ANY leveldb.Iterator.Iterator ()
71424,METHOD,table\iterator.cc:<global>,TYPE_DECL,"Iterator::~Iterator() {
  if (cleanup_.function != NULL) {
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    for (Cleanup* c = cleanup_.next; c != NULL; ) {
      (*c->function)(c->arg1, c->arg2);
      Cleanup* next = c->next;
      delete c;
      c = next;
    }
  }
}",1,1,table\iterator.cc,leveldb.Iterator.~Iterator,,false,14,24,~Iterator,,,2,ANY leveldb.Iterator.~Iterator ()
71480,METHOD,table\iterator.cc:<global>,TYPE_DECL,"void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {
  assert(func != NULL);
  Cleanup* c;
  if (cleanup_.function == NULL) {
    c = &cleanup_;
  } else {
    c = new Cleanup;
    c->next = cleanup_.next;
    cleanup_.next = c;
  }
  c->function = func;
  c->arg1 = arg1;
  c->arg2 = arg2;
}",1,1,table\iterator.cc,leveldb.Iterator.RegisterCleanup,,false,26,39,RegisterCleanup,,,3,"void leveldb.Iterator.RegisterCleanup (CleanupFunction,void*,void*)"
71538,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,EmptyIterator(const Status& s) : status_(s) { },3,49,table\iterator.cc,leveldb.anonymous_namespace_2.EmptyIterator.EmptyIterator,,false,44,44,EmptyIterator,,,1,ANY leveldb.anonymous_namespace_2.EmptyIterator.EmptyIterator (Status)
71543,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual bool Valid() const { return false; },3,46,table\iterator.cc,leveldb.anonymous_namespace_3.EmptyIterator.Valid,,false,45,45,Valid,,,2,bool leveldb.anonymous_namespace_3.EmptyIterator.Valid ()
71549,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual void Seek(const Slice& target) { },3,44,table\iterator.cc,leveldb.anonymous_namespace_4.EmptyIterator.Seek,,false,46,46,Seek,,,3,void leveldb.anonymous_namespace_4.EmptyIterator.Seek (Slice)
71554,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual void SeekToFirst() { },3,32,table\iterator.cc,leveldb.anonymous_namespace_5.EmptyIterator.SeekToFirst,,false,47,47,SeekToFirst,,,4,void leveldb.anonymous_namespace_5.EmptyIterator.SeekToFirst ()
71558,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual void SeekToLast() { },3,31,table\iterator.cc,leveldb.anonymous_namespace_6.EmptyIterator.SeekToLast,,false,48,48,SeekToLast,,,5,void leveldb.anonymous_namespace_6.EmptyIterator.SeekToLast ()
71562,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual void Next() { assert(false); },3,40,table\iterator.cc,leveldb.anonymous_namespace_7.EmptyIterator.Next,,false,49,49,Next,,,6,void leveldb.anonymous_namespace_7.EmptyIterator.Next ()
71568,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual void Prev() { assert(false); },3,40,table\iterator.cc,leveldb.anonymous_namespace_8.EmptyIterator.Prev,,false,50,50,Prev,,,7,void leveldb.anonymous_namespace_8.EmptyIterator.Prev ()
71574,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,Slice key() const { assert(false); return Slice(); },3,54,table\iterator.cc,leveldb.anonymous_namespace_9.EmptyIterator.key,,false,51,51,key,,,8,Slice leveldb.anonymous_namespace_9.EmptyIterator.key ()
71582,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,Slice value() const { assert(false); return Slice(); },3,56,table\iterator.cc,leveldb.anonymous_namespace_10.EmptyIterator.value,,false,52,52,value,,,9,Slice leveldb.anonymous_namespace_10.EmptyIterator.value ()
71590,METHOD,leveldb.anonymous_namespace_1.EmptyIterator,TYPE_DECL,virtual Status status() const { return status_; },3,51,table\iterator.cc,leveldb.anonymous_namespace_11.EmptyIterator.status,,false,53,53,status,,,10,Status leveldb.anonymous_namespace_11.EmptyIterator.status ()
71597,METHOD,table\iterator.cc:<global>,TYPE_DECL,"Iterator* NewEmptyIterator() {
  return new EmptyIterator(Status::OK());
}",1,1,table\iterator.cc,leveldb.NewEmptyIterator,,false,59,61,NewEmptyIterator,,,5,Iterator leveldb.NewEmptyIterator ()
71608,METHOD,table\iterator.cc:<global>,TYPE_DECL,"Iterator* NewErrorIterator(const Status& status) {
  return new EmptyIterator(status);
}",1,1,table\iterator.cc,leveldb.NewErrorIterator,,false,63,65,NewErrorIterator,,,6,Iterator leveldb.NewErrorIterator (Status)
71624,METHOD,table\iterator_wrapper.hpp:<global>,TYPE_DECL,<global>,1,1,table\iterator_wrapper.hpp,table\iterator_wrapper.hpp:<global>,,false,1,66,<global>,,,1,
71628,METHOD,leveldb.IteratorWrapper,TYPE_DECL,"IteratorWrapper(): iter_(NULL), valid_(false) { }",3,51,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.IteratorWrapper,,false,19,19,IteratorWrapper,,,1,ANY leveldb.IteratorWrapper.IteratorWrapper ()
71632,METHOD,leveldb.IteratorWrapper,TYPE_DECL,"explicit IteratorWrapper(Iterator* iter): iter_(NULL) {
    Set(iter);
  }",3,3,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.IteratorWrapper,,false,20,22,IteratorWrapper,,,2,ANY leveldb.IteratorWrapper.IteratorWrapper (Iterator*)
71639,METHOD,leveldb.IteratorWrapper,TYPE_DECL,~IteratorWrapper() { delete iter_; },3,38,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.~IteratorWrapper,,false,23,23,~IteratorWrapper,,,3,ANY leveldb.IteratorWrapper.~IteratorWrapper ()
71645,METHOD,leveldb.IteratorWrapper,TYPE_DECL,Iterator* iter() const { return iter_; },3,42,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.iter,,false,24,24,iter,,,4,Iterator leveldb.IteratorWrapper.iter ()
71651,METHOD,leveldb.IteratorWrapper,TYPE_DECL,"void Set(Iterator* iter) {
    delete iter_;
    iter_ = iter;
    if (iter_ == NULL) {
      valid_ = false;
    } else {
      Update();
    }
  }",3,3,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.Set,,false,28,36,Set,,,5,void leveldb.IteratorWrapper.Set (Iterator*)
71672,METHOD,leveldb.IteratorWrapper,TYPE_DECL,bool Valid() const        { return valid_; },3,46,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.Valid,,false,40,40,Valid,,,6,bool leveldb.IteratorWrapper.Valid ()
71678,METHOD,leveldb.IteratorWrapper,TYPE_DECL,Slice key() const         { assert(Valid()); return key_; },3,61,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.key,,false,41,41,key,,,7,Slice leveldb.IteratorWrapper.key ()
71686,METHOD,leveldb.IteratorWrapper,TYPE_DECL,Slice value() const       { assert(Valid()); return iter_->value(); },3,71,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.value,,false,42,42,value,,,8,Slice leveldb.IteratorWrapper.value ()
71697,METHOD,leveldb.IteratorWrapper,TYPE_DECL,Status status() const     { assert(iter_); return iter_->status(); },3,70,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.status,,false,44,44,status,,,9,Status leveldb.IteratorWrapper.status ()
71708,METHOD,leveldb.IteratorWrapper,TYPE_DECL,void Next()               { assert(iter_); iter_->Next();        Update(); },3,78,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.Next,,false,45,45,Next,,,10,void leveldb.IteratorWrapper.Next ()
71719,METHOD,leveldb.IteratorWrapper,TYPE_DECL,void Prev()               { assert(iter_); iter_->Prev();        Update(); },3,78,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.Prev,,false,46,46,Prev,,,11,void leveldb.IteratorWrapper.Prev ()
71730,METHOD,leveldb.IteratorWrapper,TYPE_DECL,void Seek(const Slice& k) { assert(iter_); iter_->Seek(k);       Update(); },3,78,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.Seek,,false,47,47,Seek,,,12,void leveldb.IteratorWrapper.Seek (Slice)
71743,METHOD,leveldb.IteratorWrapper,TYPE_DECL,void SeekToFirst()        { assert(iter_); iter_->SeekToFirst(); Update(); },3,78,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.SeekToFirst,,false,48,48,SeekToFirst,,,13,void leveldb.IteratorWrapper.SeekToFirst ()
71754,METHOD,leveldb.IteratorWrapper,TYPE_DECL,void SeekToLast()         { assert(iter_); iter_->SeekToLast();  Update(); },3,78,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.SeekToLast,,false,49,49,SeekToLast,,,14,void leveldb.IteratorWrapper.SeekToLast ()
71765,METHOD,leveldb.IteratorWrapper,TYPE_DECL,"void Update() {
    valid_ = iter_->Valid();
    if (valid_) {
      key_ = iter_->key();
    }
  }",3,3,table\iterator_wrapper.hpp,leveldb.IteratorWrapper.Update,,false,52,57,Update,,,15,void leveldb.IteratorWrapper.Update ()
71798,METHOD,table\merger.cc:<global>,TYPE_DECL,<global>,1,1,table\merger.cc,table\merger.cc:<global>,,false,1,197,<global>,,,1,
71803,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(NULL),
        direction_(kForward) {
    for (int i = 0; i < n; i++) {
      children_[i].Set(children[i]);
    }
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_2.MergingIterator.MergingIterator,,false,16,25,MergingIterator,,,1,"ANY leveldb.anonymous_namespace_2.MergingIterator.MergingIterator (Comparator*,Iterator**,int)"
71831,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual ~MergingIterator() {
    delete[] children_;
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_3.MergingIterator.~MergingIterator,,false,27,29,~MergingIterator,,,2,ANY leveldb.anonymous_namespace_3.MergingIterator.~MergingIterator ()
71837,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual bool Valid() const {
    return (current_ != NULL);
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_4.MergingIterator.Valid,,false,31,33,Valid,,,3,bool leveldb.anonymous_namespace_4.MergingIterator.Valid ()
71845,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual void SeekToFirst() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToFirst();
    }
    FindSmallest();
    direction_ = kForward;
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_5.MergingIterator.SeekToFirst,,false,35,41,SeekToFirst,,,4,void leveldb.anonymous_namespace_5.MergingIterator.SeekToFirst ()
71871,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual void SeekToLast() {
    for (int i = 0; i < n_; i++) {
      children_[i].SeekToLast();
    }
    FindLargest();
    direction_ = kReverse;
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_6.MergingIterator.SeekToLast,,false,43,49,SeekToLast,,,5,void leveldb.anonymous_namespace_6.MergingIterator.SeekToLast ()
71897,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual void Seek(const Slice& target) {
    for (int i = 0; i < n_; i++) {
      children_[i].Seek(target);
    }
    FindSmallest();
    direction_ = kForward;
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_7.MergingIterator.Seek,,false,51,57,Seek,,,6,void leveldb.anonymous_namespace_7.MergingIterator.Seek (Slice)
71925,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual void Next() {
    assert(Valid());

    // Ensure that all children are positioned after key().
    // If we are moving in the forward direction, it is already
    // true for all of the non-current_ children since current_ is
    // the smallest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kForward) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid() &&
              comparator_->Compare(key(), child->key()) == 0) {
            child->Next();
          }
        }
      }
      direction_ = kForward;
    }

    current_->Next();
    FindSmallest();
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_8.MergingIterator.Next,,false,59,83,Next,,,7,void leveldb.anonymous_namespace_8.MergingIterator.Next ()
71995,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual void Prev() {
    assert(Valid());

    // Ensure that all children are positioned before key().
    // If we are moving in the reverse direction, it is already
    // true for all of the non-current_ children since current_ is
    // the largest child and key() == current_->key().  Otherwise,
    // we explicitly position the non-current_ children.
    if (direction_ != kReverse) {
      for (int i = 0; i < n_; i++) {
        IteratorWrapper* child = &children_[i];
        if (child != current_) {
          child->Seek(key());
          if (child->Valid()) {
            // Child is at first entry >= key().  Step back one to be < key()
            child->Prev();
          } else {
            // Child has no entries >= key().  Position at last entry.
            child->SeekToLast();
          }
        }
      }
      direction_ = kReverse;
    }

    current_->Prev();
    FindLargest();
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_12.MergingIterator.Prev,,false,85,112,Prev,,,8,void leveldb.anonymous_namespace_12.MergingIterator.Prev ()
72059,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual Slice key() const {
    assert(Valid());
    return current_->key();
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_15.MergingIterator.key,,false,114,117,key,,,9,Slice leveldb.anonymous_namespace_15.MergingIterator.key ()
72070,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual Slice value() const {
    assert(Valid());
    return current_->value();
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_17.MergingIterator.value,,false,119,122,value,,,10,Slice leveldb.anonymous_namespace_17.MergingIterator.value ()
72081,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,"virtual Status status() const {
    Status status;
    for (int i = 0; i < n_; i++) {
      status = children_[i].status();
      if (!status.ok()) {
        break;
      }
    }
    return status;
  }",3,3,table\merger.cc,leveldb.anonymous_namespace_19.MergingIterator.status,,false,124,133,status,,,11,Status leveldb.anonymous_namespace_19.MergingIterator.status ()
72116,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,void FindSmallest();,8,21,table\merger.cc,leveldb.anonymous_namespace_20.MergingIterator.FindSmallest,,false,136,136,FindSmallest,,,12,void leveldb.anonymous_namespace_20.MergingIterator.FindSmallest ()
72120,METHOD,leveldb.anonymous_namespace_1.MergingIterator,TYPE_DECL,void FindLargest();,8,20,table\merger.cc,leveldb.anonymous_namespace_21.MergingIterator.FindLargest,,false,137,137,FindLargest,,,13,void leveldb.anonymous_namespace_21.MergingIterator.FindLargest ()
72132,METHOD,table\merger.cc:<global>,TYPE_DECL,"void MergingIterator::FindSmallest() {
  IteratorWrapper* smallest = NULL;
  for (int i = 0; i < n_; i++) {
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (smallest == NULL) {
        smallest = child;
      } else if (comparator_->Compare(child->key(), smallest->key()) < 0) {
        smallest = child;
      }
    }
  }
  current_ = smallest;
}",1,1,table\merger.cc,leveldb.anonymous_namespace_23.MergingIterator.FindSmallest,,false,155,168,FindSmallest,,,2,void leveldb.anonymous_namespace_23.MergingIterator.FindSmallest ()
72197,METHOD,table\merger.cc:<global>,TYPE_DECL,"void MergingIterator::FindLargest() {
  IteratorWrapper* largest = NULL;
  for (int i = n_-1; i >= 0; i--) {
    IteratorWrapper* child = &children_[i];
    if (child->Valid()) {
      if (largest == NULL) {
        largest = child;
      } else if (comparator_->Compare(child->key(), largest->key()) > 0) {
        largest = child;
      }
    }
  }
  current_ = largest;
}",1,1,table\merger.cc,leveldb.anonymous_namespace_24.MergingIterator.FindLargest,,false,170,183,FindLargest,,,3,void leveldb.anonymous_namespace_24.MergingIterator.FindLargest ()
72264,METHOD,table\merger.cc:<global>,TYPE_DECL,"Iterator* NewMergingIterator(const Comparator* cmp, Iterator** list, int n) {
  assert(n >= 0);
  if (n == 0) {
    return NewEmptyIterator();
  } else if (n == 1) {
    return list[0];
  } else {
    return new MergingIterator(cmp, list, n);
  }
}",1,1,table\merger.cc,leveldb.NewMergingIterator,,false,186,195,NewMergingIterator,,,2,"Iterator leveldb.NewMergingIterator (Comparator*,Iterator**,int)"
72304,METHOD,table\merger.hpp:<global>,TYPE_DECL,<global>,1,42,table\merger.hpp,table\merger.hpp:<global>,,false,1,26,<global>,,,1,
72309,METHOD,table\merger.hpp:<global>,TYPE_DECL,"extern Iterator* NewMergingIterator(
    const Comparator* comparator, Iterator** children, int n);",16,61,table\merger.hpp,leveldb.NewMergingIterator,,false,21,22,NewMergingIterator,,,3,"Iterator* leveldb.NewMergingIterator (Comparator*,Iterator**,int)"
72341,METHOD,table\table.cc:<global>,TYPE_DECL,<global>,1,1,table\table.cc,table\table.cc:<global>,,false,1,285,<global>,,,1,
72345,METHOD,leveldb.Rep,TYPE_DECL,"~Rep() {
    delete filter;
    delete [] filter_data;
    delete index_block;
  }",3,3,table\table.cc,leveldb.Rep.~Rep,,false,21,25,~Rep,,,1,ANY leveldb.Rep.~Rep ()
72363,METHOD,table\table.cc:<global>,TYPE_DECL,"Status Table::Open(const Options& options,
                   RandomAccessFile* file,
                   uint64_t size,
                   Table** table) {
  *table = NULL;
  if (size < Footer::kEncodedLength) {
    return Status::Corruption(""file is too short to be an sstable"");
  }

  char footer_space[Footer::kEncodedLength];
  Slice footer_input;
  Status s = file->Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
                        &footer_input, footer_space);
  if (!s.ok()) return s;

  Footer footer;
  s = footer.DecodeFrom(&footer_input);
  if (!s.ok()) return s;

  // Read the index block
  BlockContents contents;
  Block* index_block = NULL;
  if (s.ok()) {
    ReadOptions opt;
    if (options.paranoid_checks) {
      opt.verify_checksums = true;
    }
    s = ReadBlock(file, opt, footer.index_handle(), &contents);
    if (s.ok()) {
      index_block = new Block(contents);
    }
  }

  if (s.ok()) {
    // We've successfully read the footer and the index bl...",1,1,table\table.cc,leveldb.Table.Open,,false,38,89,Open,,,2,"Status leveldb.Table.Open (Options,RandomAccessFile*,uint64_t,Table**)"
72556,METHOD,table\table.cc:<global>,TYPE_DECL,"void Table::ReadMeta(const Footer& footer) {
  if (rep_->options.filter_policy == NULL) {
    return;  // Do not need any metadata
  }

  // TODO(sanjay): Skip this if footer.metaindex_handle() size indicates
  // it is an empty block.
  ReadOptions opt;
  if (rep_->options.paranoid_checks) {
    opt.verify_checksums = true;
  }
  BlockContents contents;
  if (!ReadBlock(rep_->file, opt, footer.metaindex_handle(), &contents).ok()) {
    // Do not propagate errors since meta info is not needed for operation
    return;
  }
  Block* meta = new Block(contents);

  Iterator* iter = meta->NewIterator(BytewiseComparator());
  std::string key = ""filter."";
  key.append(rep_->options.filter_policy->Name());
  iter->Seek(key);
  if (iter->Valid() && iter->key() == Slice(key)) {
    ReadFilter(iter->value());
  }
  delete iter;
  delete meta;
}",1,1,table\table.cc,leveldb.Table.ReadMeta,,false,91,118,ReadMeta,,,3,void leveldb.Table.ReadMeta (Footer)
72661,METHOD,table\table.cc:<global>,TYPE_DECL,"void Table::ReadFilter(const Slice& filter_handle_value) {
  Slice v = filter_handle_value;
  BlockHandle filter_handle;
  if (!filter_handle.DecodeFrom(&v).ok()) {
    return;
  }

  // We might want to unify with ReadBlock() if we start
  // requiring checksum verification in Table::Open.
  ReadOptions opt;
  if (rep_->options.paranoid_checks) {
    opt.verify_checksums = true;
  }
  BlockContents block;
  if (!ReadBlock(rep_->file, opt, filter_handle, &block).ok()) {
    return;
  }
  if (block.heap_allocated) {
    rep_->filter_data = block.data.data();     // Will need to delete later
  }
  rep_->filter = new FilterBlockReader(rep_->options.filter_policy, block.data);
}",1,1,table\table.cc,leveldb.Table.ReadFilter,,false,120,141,ReadFilter,,,4,void leveldb.Table.ReadFilter (Slice)
72742,METHOD,table\table.cc:<global>,TYPE_DECL,"Table::~Table() {
  delete rep_;
}",1,1,table\table.cc,leveldb.Table.~Table,,false,143,145,~Table,,,5,ANY leveldb.Table.~Table ()
72748,METHOD,table\table.cc:<global>,TYPE_DECL,"static void DeleteBlock(void* arg, void* ignored) {
  delete reinterpret_cast<Block*>(arg);
}",1,1,table\table.cc,leveldb.DeleteBlock,,false,147,149,DeleteBlock,,,6,"void leveldb.DeleteBlock (void*,void*)"
72758,METHOD,table\table.cc:<global>,TYPE_DECL,"static void DeleteCachedBlock(const Slice& key, void* value) {
  Block* block = reinterpret_cast<Block*>(value);
  delete block;
}",1,1,table\table.cc,leveldb.DeleteCachedBlock,,false,151,154,DeleteCachedBlock,,,7,"void leveldb.DeleteCachedBlock (Slice,void*)"
72772,METHOD,table\table.cc:<global>,TYPE_DECL,"static void ReleaseBlock(void* arg, void* h) {
  Cache* cache = reinterpret_cast<Cache*>(arg);
  Cache::Handle* handle = reinterpret_cast<Cache::Handle*>(h);
  cache->Release(handle);
}",1,1,table\table.cc,leveldb.ReleaseBlock,,false,156,160,ReleaseBlock,,,8,"void leveldb.ReleaseBlock (void*,void*)"
72795,METHOD,table\table.cc:<global>,TYPE_DECL,"Iterator* Table::BlockReader(void* arg,
                             const ReadOptions& options,
                             const Slice& index_value) {
  Table* table = reinterpret_cast<Table*>(arg);
  Cache* block_cache = table->rep_->options.block_cache;
  Block* block = NULL;
  Cache::Handle* cache_handle = NULL;

  BlockHandle handle;
  Slice input = index_value;
  Status s = handle.DecodeFrom(&input);
  // We intentionally allow extra stuff in index_value so that we
  // can add more features in the future.

  if (s.ok()) {
    BlockContents contents;
    if (block_cache != NULL) {
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table->rep_->cache_id);
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle = block_cache->Lookup(key);
      if (cache_handle != NULL) {
        block = reinterpret_cast<Block*>(block_cache->Value(cache_handle));
      } else {
        s = Rea...",1,1,table\table.cc,leveldb.Table.BlockReader,,false,164,218,BlockReader,,,9,"Iterator leveldb.Table.BlockReader (void*,ReadOptions,Slice)"
73017,METHOD,table\table.cc:<global>,TYPE_DECL,"Iterator* Table::NewIterator(const ReadOptions& options) const {
  return NewTwoLevelIterator(
      rep_->index_block->NewIterator(rep_->options.comparator),
      &Table::BlockReader, const_cast<Table*>(this), options);
}",1,1,table\table.cc,leveldb.Table.NewIterator,,false,220,224,NewIterator,,,10,Iterator leveldb.Table.NewIterator (ReadOptions)
73043,METHOD,table\table.cc:<global>,TYPE_DECL,"Status Table::InternalGet(const ReadOptions& options, const Slice& k,
                          void* arg,
                          void (*saver)(void*, const Slice&, const Slice&)) {
  Status s;
  Iterator* iiter = rep_->index_block->NewIterator(rep_->options.comparator);
  iiter->Seek(k);
  if (iiter->Valid()) {
    Slice handle_value = iiter->value();
    FilterBlockReader* filter = rep_->filter;
    BlockHandle handle;
    if (filter != NULL &&
        handle.DecodeFrom(&handle_value).ok() &&
        !filter->KeyMayMatch(handle.offset(), k)) {
      // Not found
    } else {
      Iterator* block_iter = BlockReader(this, options, iiter->value());
      block_iter->Seek(k);
      if (block_iter->Valid()) {
        (*saver)(arg, block_iter->key(), block_iter->value());
      }
      s = block_iter->status();
      delete block_iter;
    }
  }
  if (s.ok()) {
    s = iiter->status();
  }
  delete iiter;
  return s;
}",1,1,table\table.cc,leveldb.Table.InternalGet,,false,226,255,InternalGet,,,11,"Status leveldb.Table.InternalGet (ReadOptions,Slice,void*,void)"
73176,METHOD,table\table.cc:<global>,TYPE_DECL,"uint64_t Table::ApproximateOffsetOf(const Slice& key) const {
  Iterator* index_iter =
      rep_->index_block->NewIterator(rep_->options.comparator);
  index_iter->Seek(key);
  uint64_t result;
  if (index_iter->Valid()) {
    BlockHandle handle;
    Slice input = index_iter->value();
    Status s = handle.DecodeFrom(&input);
    if (s.ok()) {
      result = handle.offset();
    } else {
      // Strange: we can't decode the block handle in the index block.
      // We'll just return the offset of the metaindex block, which is
      // close to the whole file size for this case.
      result = rep_->metaindex_handle.offset();
    }
  } else {
    // key is past the last key in the file.  Approximate the offset
    // by returning the offset of the metaindex block (which is
    // right near the end of the file).
    result = rep_->metaindex_handle.offset();
  }
  delete index_iter;
  return result;
}",1,1,table\table.cc,leveldb.Table.ApproximateOffsetOf,,false,258,283,ApproximateOffsetOf,,,12,uint64_t leveldb.Table.ApproximateOffsetOf (Slice)
73285,METHOD,table\table_builder.cc:<global>,TYPE_DECL,<global>,1,1,table\table_builder.cc,table\table_builder.cc:<global>,,false,1,270,<global>,,,1,
73303,METHOD,leveldb.Rep,TYPE_DECL,"Rep(const Options& opt, WritableFile* f)
      : options(opt),
        index_block_options(opt),
        file(f),
        offset(0),
        data_block(&options),
        index_block(&index_block_options),
        num_entries(0),
        closed(false),
        filter_block(opt.filter_policy == NULL ? NULL
                     : new FilterBlockBuilder(opt.filter_policy)),
        pending_index_entry(false) {
    index_block_options.block_restart_interval = 1;
  }",3,3,table\table_builder.cc,leveldb.Rep.Rep,,false,47,60,Rep,,,15,"ANY leveldb.Rep.Rep (Options,WritableFile*)"
73314,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"TableBuilder::TableBuilder(const Options& options, WritableFile* file)
    : rep_(new Rep(options, file)) {
  if (rep_->filter_block != NULL) {
    rep_->filter_block->StartBlock(0);
  }
}",1,1,table\table_builder.cc,leveldb.TableBuilder.TableBuilder,,false,63,68,TableBuilder,,,2,"ANY leveldb.TableBuilder.TableBuilder (Options,WritableFile*)"
73334,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"TableBuilder::~TableBuilder() {
  assert(rep_->closed);  // Catch errors where caller forgot to call Finish()
  delete rep_->filter_block;
  delete rep_;
}",1,1,table\table_builder.cc,leveldb.TableBuilder.~TableBuilder,,false,70,74,~TableBuilder,,,3,ANY leveldb.TableBuilder.~TableBuilder ()
73348,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"Status TableBuilder::ChangeOptions(const Options& options) {
  // Note: if more fields are added to Options, update
  // this function to catch changes that should not be allowed to
  // change in the middle of building a Table.
  if (options.comparator != rep_->options.comparator) {
    return Status::InvalidArgument(""changing comparator while building table"");
  }

  // Note that any live BlockBuilders point to rep_->options and therefore
  // will automatically pick up the updated options.
  rep_->options = options;
  rep_->index_block_options = options;
  rep_->index_block_options.block_restart_interval = 1;
  return Status::OK();
}",1,1,table\table_builder.cc,leveldb.TableBuilder.ChangeOptions,,false,76,90,ChangeOptions,,,4,Status leveldb.TableBuilder.ChangeOptions (Options)
73392,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"void TableBuilder::Add(const Slice& key, const Slice& value) {
  Rep* r = rep_;
  assert(!r->closed);
  if (!ok()) return;
  if (r->num_entries > 0) {
    assert(r->options.comparator->Compare(key, Slice(r->last_key)) > 0);
  }

  if (r->pending_index_entry) {
    assert(r->data_block.empty());
    r->options.comparator->FindShortestSeparator(&r->last_key, key);
    std::string handle_encoding;
    r->pending_handle.EncodeTo(&handle_encoding);
    r->index_block.Add(r->last_key, Slice(handle_encoding));
    r->pending_index_entry = false;
  }

  if (r->filter_block != NULL) {
    r->filter_block->AddKey(key);
  }

  r->last_key.assign(key.data(), key.size());
  r->num_entries++;
  r->data_block.Add(key, value);

  const size_t estimated_block_size = r->data_block.CurrentSizeEstimate();
  if (estimated_block_size >= r->options.block_size) {
    Flush();
  }
}",1,1,table\table_builder.cc,leveldb.TableBuilder.Add,,false,92,121,Add,,,5,"void leveldb.TableBuilder.Add (Slice,Slice)"
73544,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"void TableBuilder::Flush() {
  Rep* r = rep_;
  assert(!r->closed);
  if (!ok()) return;
  if (r->data_block.empty()) return;
  assert(!r->pending_index_entry);
  WriteBlock(&r->data_block, &r->pending_handle);
  if (ok()) {
    r->pending_index_entry = true;
    r->status = r->file->Flush();
  }
  if (r->filter_block != NULL) {
    r->filter_block->StartBlock(r->offset);
  }
}",1,1,table\table_builder.cc,leveldb.TableBuilder.Flush,,false,123,137,Flush,,,6,void leveldb.TableBuilder.Flush ()
73619,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {
  // File format contains a sequence of blocks where each block has:
  //    block_data: uint8[n]
  //    type: uint8
  //    crc: uint32
  assert(ok());
  Rep* r = rep_;
  Slice raw = block->Finish();

  Slice block_contents;
  CompressionType type = r->options.compression;
  // TODO(postrelease): Support more compression options: zlib?
  switch (type) {
    case kNoCompression:
      block_contents = raw;
      break;

    case kSnappyCompression: {
      std::string* compressed = &r->compressed_output;
      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&
          compressed->size() < raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } else {
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }
      break;
    }
  }
  WriteRawBlock(block_co...",1,1,table\table_builder.cc,leveldb.TableBuilder.WriteBlock,,false,139,173,WriteBlock,,,7,"void leveldb.TableBuilder.WriteBlock (BlockBuilder*,BlockHandle*)"
73725,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"void TableBuilder::WriteRawBlock(const Slice& block_contents,
                                 CompressionType type,
                                 BlockHandle* handle) {
  Rep* r = rep_;
  handle->set_offset(r->offset);
  handle->set_size(block_contents.size());
  r->status = r->file->Append(block_contents);
  if (r->status.ok()) {
    char trailer[kBlockTrailerSize];
    trailer[0] = type;
    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
    EncodeFixed32(trailer+1, crc32c::Mask(crc));
    r->status = r->file->Append(Slice(trailer, kBlockTrailerSize));
    if (r->status.ok()) {
      r->offset += block_contents.size() + kBlockTrailerSize;
    }
  }
}",1,1,table\table_builder.cc,leveldb.TableBuilder.WriteRawBlock,,false,175,193,WriteRawBlock,,,8,"void leveldb.TableBuilder.WriteRawBlock (Slice,CompressionType,BlockHandle*)"
73840,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"Status TableBuilder::status() const {
  return rep_->status;
}",1,1,table\table_builder.cc,leveldb.TableBuilder.status,,false,195,197,status,,,9,Status leveldb.TableBuilder.status ()
73848,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"Status TableBuilder::Finish() {
  Rep* r = rep_;
  Flush();
  assert(!r->closed);
  r->closed = true;

  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;

  // Write filter block
  if (ok() && r->filter_block != NULL) {
    WriteRawBlock(r->filter_block->Finish(), kNoCompression,
                  &filter_block_handle);
  }

  // Write metaindex block
  if (ok()) {
    BlockBuilder meta_index_block(&r->options);
    if (r->filter_block != NULL) {
      // Add mapping from ""filter.Name"" to location of filter data
      std::string key = ""filter."";
      key.append(r->options.filter_policy->Name());
      std::string handle_encoding;
      filter_block_handle.EncodeTo(&handle_encoding);
      meta_index_block.Add(key, handle_encoding);
    }

    // TODO(postrelease): Add stats and other meta blocks
    WriteBlock(&meta_index_block, &metaindex_block_handle);
  }

  // Write index block
  if (ok()) {
    if (r->pending_index_entry) {
      r->options.compara...",1,1,table\table_builder.cc,leveldb.TableBuilder.Finish,,false,199,254,Finish,,,10,Status leveldb.TableBuilder.Finish ()
74043,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"void TableBuilder::Abandon() {
  Rep* r = rep_;
  assert(!r->closed);
  r->closed = true;
}",1,1,table\table_builder.cc,leveldb.TableBuilder.Abandon,,false,256,260,Abandon,,,11,void leveldb.TableBuilder.Abandon ()
74061,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"uint64_t TableBuilder::NumEntries() const {
  return rep_->num_entries;
}",1,1,table\table_builder.cc,leveldb.TableBuilder.NumEntries,,false,262,264,NumEntries,,,12,uint64_t leveldb.TableBuilder.NumEntries ()
74069,METHOD,table\table_builder.cc:<global>,TYPE_DECL,"uint64_t TableBuilder::FileSize() const {
  return rep_->offset;
}",1,1,table\table_builder.cc,leveldb.TableBuilder.FileSize,,false,266,268,FileSize,,,13,uint64_t leveldb.TableBuilder.FileSize ()
74112,METHOD,table\table_test.cc:<global>,TYPE_DECL,<global>,1,1,table\table_test.cc,table\table_test.cc:<global>,,false,1,876,<global>,,,1,
74115,METHOD,table\table_test.cc:<global>,TYPE_DECL,"static std::string Reverse(const Slice& key) {
  std::string str(key.ToString());
  std::string rev("""");
  for (std::string::reverse_iterator rit = str.rbegin();
       rit != str.rend(); ++rit) {
    rev.push_back(*rit);
  }
  return rev;
}",1,1,table\table_test.cc,leveldb.Reverse,,false,27,35,Reverse,,,1,string leveldb.Reverse (Slice)
74157,METHOD,leveldb.anonymous_namespace_1.ReverseKeyComparator,TYPE_DECL,"virtual const char* Name() const {
    return ""leveldb.ReverseBytewiseComparator"";
  }",3,3,table\table_test.cc,leveldb.anonymous_namespace_2.ReverseKeyComparator.Name,,false,40,42,Name,,,1,const char* leveldb.anonymous_namespace_2.ReverseKeyComparator.Name ()
74163,METHOD,leveldb.anonymous_namespace_1.ReverseKeyComparator,TYPE_DECL,"virtual int Compare(const Slice& a, const Slice& b) const {
    return BytewiseComparator()->Compare(Reverse(a), Reverse(b));
  }",3,3,table\table_test.cc,leveldb.anonymous_namespace_3.ReverseKeyComparator.Compare,,false,44,46,Compare,,,2,"int leveldb.anonymous_namespace_3.ReverseKeyComparator.Compare (Slice,Slice)"
74178,METHOD,leveldb.anonymous_namespace_1.ReverseKeyComparator,TYPE_DECL,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    std::string s = Reverse(*start);
    std::string l = Reverse(limit);
    BytewiseComparator()->FindShortestSeparator(&s, l);
    *start = Reverse(s);
  }",3,3,table\table_test.cc,leveldb.anonymous_namespace_4.ReverseKeyComparator.FindShortestSeparator,,false,48,55,FindShortestSeparator,,,3,"void leveldb.anonymous_namespace_4.ReverseKeyComparator.FindShortestSeparator (ANY*,Slice)"
74207,METHOD,leveldb.anonymous_namespace_1.ReverseKeyComparator,TYPE_DECL,"virtual void FindShortSuccessor(std::string* key) const {
    std::string s = Reverse(*key);
    BytewiseComparator()->FindShortSuccessor(&s);
    *key = Reverse(s);
  }",3,3,table\table_test.cc,leveldb.anonymous_namespace_5.ReverseKeyComparator.FindShortSuccessor,,false,57,61,FindShortSuccessor,,,4,void leveldb.anonymous_namespace_5.ReverseKeyComparator.FindShortSuccessor (ANY*)
74230,METHOD,table\table_test.cc:<global>,TYPE_DECL,"static void Increment(const Comparator* cmp, std::string* key) {
  if (cmp == BytewiseComparator()) {
    key->push_back('\0');
  } else {
    assert(cmp == &reverse_key_comparator);
    std::string rev = Reverse(*key);
    rev.push_back('\0');
    *key = Reverse(rev);
  }
}",1,1,table\table_test.cc,leveldb.Increment,,false,66,75,Increment,,,4,"void leveldb.Increment (Comparator*,ANY*)"
74272,METHOD,leveldb.anonymous_namespace_7.STLLessThan,TYPE_DECL,STLLessThan() : cmp(BytewiseComparator()) { },3,47,table\table_test.cc,leveldb.anonymous_namespace_8.STLLessThan.STLLessThan,,false,82,82,STLLessThan,,,2,ANY leveldb.anonymous_namespace_8.STLLessThan.STLLessThan ()
74276,METHOD,leveldb.anonymous_namespace_7.STLLessThan,TYPE_DECL,STLLessThan(const Comparator* c) : cmp(c) { },3,47,table\table_test.cc,leveldb.anonymous_namespace_9.STLLessThan.STLLessThan,,false,83,83,STLLessThan,,,3,ANY leveldb.anonymous_namespace_9.STLLessThan.STLLessThan (Comparator*)
74281,METHOD,leveldb.anonymous_namespace_7.STLLessThan,TYPE_DECL,"bool operator()(const std::string& a, const std::string& b) const {
    return cmp->Compare(Slice(a), Slice(b)) < 0;
  }",3,3,table\table_test.cc,leveldb.anonymous_namespace_10.STLLessThan.operator (),,false,84,86,operator (),,,4,"bool leveldb.anonymous_namespace_10.STLLessThan.operator () (ANY,ANY)"
74299,METHOD,leveldb.StringSink,TYPE_DECL,~StringSink() { },3,19,table\table_test.cc,leveldb.StringSink.~StringSink,,false,92,92,~StringSink,,,1,ANY leveldb.StringSink.~StringSink ()
74303,METHOD,leveldb.StringSink,TYPE_DECL,const std::string& contents() const { return contents_; },3,59,table\table_test.cc,leveldb.StringSink.contents,,false,94,94,contents,,,2,string leveldb.StringSink.contents ()
74309,METHOD,leveldb.StringSink,TYPE_DECL,virtual Status Close() { return Status::OK(); },3,49,table\table_test.cc,leveldb.StringSink.Close,,false,96,96,Close,,,3,Status leveldb.StringSink.Close ()
74318,METHOD,leveldb.StringSink,TYPE_DECL,virtual Status Flush() { return Status::OK(); },3,49,table\table_test.cc,leveldb.StringSink.Flush,,false,97,97,Flush,,,4,Status leveldb.StringSink.Flush ()
74327,METHOD,leveldb.StringSink,TYPE_DECL,virtual Status Sync() { return Status::OK(); },3,48,table\table_test.cc,leveldb.StringSink.Sync,,false,98,98,Sync,,,5,Status leveldb.StringSink.Sync ()
74336,METHOD,leveldb.StringSink,TYPE_DECL,"virtual Status Append(const Slice& data) {
    contents_.append(data.data(), data.size());
    return Status::OK();
  }",3,3,table\table_test.cc,leveldb.StringSink.Append,,false,100,103,Append,,,6,Status leveldb.StringSink.Append (Slice)
74360,METHOD,leveldb.StringSource,TYPE_DECL,"StringSource(const Slice& contents)
      : contents_(contents.data(), contents.size()) {
  }",3,3,table\table_test.cc,leveldb.StringSource.StringSource,,false,112,114,StringSource,,,1,ANY leveldb.StringSource.StringSource (Slice)
74365,METHOD,leveldb.StringSource,TYPE_DECL,virtual ~StringSource() { },3,29,table\table_test.cc,leveldb.StringSource.~StringSource,,false,116,116,~StringSource,,,2,ANY leveldb.StringSource.~StringSource ()
74369,METHOD,leveldb.StringSource,TYPE_DECL,uint64_t Size() const { return contents_.size(); },3,52,table\table_test.cc,leveldb.StringSource.Size,,false,118,118,Size,,,3,uint64_t leveldb.StringSource.Size ()
74378,METHOD,leveldb.StringSource,TYPE_DECL,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                       char* scratch) const {
    if (offset > contents_.size()) {
      return Status::InvalidArgument(""invalid Read offset"");
    }
    if (offset + n > contents_.size()) {
      n = contents_.size() - offset;
    }
    memcpy(scratch, &contents_[offset], n);
    *result = Slice(scratch, n);
    return Status::OK();
  }",3,3,table\table_test.cc,leveldb.StringSource.Read,,false,120,131,Read,,,4,"Status leveldb.StringSource.Read (uint64_t,size_t,Slice*,char*)"
74439,METHOD,leveldb.Constructor,TYPE_DECL,explicit Constructor(const Comparator* cmp) : data_(STLLessThan(cmp)) { },3,75,table\table_test.cc,leveldb.Constructor.Constructor,,false,143,143,Constructor,,,1,ANY leveldb.Constructor.Constructor (Comparator*)
74444,METHOD,leveldb.Constructor,TYPE_DECL,virtual ~Constructor() { },3,28,table\table_test.cc,leveldb.Constructor.~Constructor,,false,144,144,~Constructor,,,2,ANY leveldb.Constructor.~Constructor ()
74448,METHOD,leveldb.Constructor,TYPE_DECL,"void Add(const std::string& key, const Slice& value) {
    data_[key] = value.ToString();
  }",3,3,table\table_test.cc,leveldb.Constructor.Add,,false,146,148,Add,,,3,"void leveldb.Constructor.Add (ANY,Slice)"
74462,METHOD,leveldb.Constructor,TYPE_DECL,"void Finish(const Options& options,
              std::vector<std::string>* keys,
              KVMap* kvmap) {
    *kvmap = data_;
    keys->clear();
    for (KVMap::const_iterator it = data_.begin();
         it != data_.end();
         ++it) {
      keys->push_back(it->first);
    }
    data_.clear();
    Status s = FinishImpl(options, *kvmap);
    ASSERT_TRUE(s.ok()) << s.ToString();
  }",3,4,table\table_test.cc,leveldb.Constructor.Finish,,false,153,166,Finish,,,4,"void leveldb.Constructor.Finish (Options,ANY*,KVMap*)"
74540,METHOD,leveldb.Constructor,TYPE_DECL,"virtual Status FinishImpl(const Options& options, const KVMap& data) = 0;",18,74,table\table_test.cc,leveldb.Constructor.FinishImpl,,false,169,169,FinishImpl,,,5,"Status leveldb.Constructor.FinishImpl (Options,KVMap)"
74546,METHOD,leveldb.Constructor,TYPE_DECL,virtual Iterator* NewIterator() const = 0;,19,43,table\table_test.cc,leveldb.Constructor.NewIterator,,false,171,171,NewIterator,,,6,Iterator* leveldb.Constructor.NewIterator ()
74550,METHOD,leveldb.Constructor,TYPE_DECL,virtual const KVMap& data() { return data_; },3,47,table\table_test.cc,leveldb.Constructor.data,,false,173,173,data,,,7,KVMap leveldb.Constructor.data ()
74556,METHOD,leveldb.Constructor,TYPE_DECL,virtual DB* db() const { return NULL; },3,41,table\table_test.cc,leveldb.Constructor.db,,false,175,175,db,,,8,DB leveldb.Constructor.db ()
74564,METHOD,leveldb.BlockConstructor,TYPE_DECL,"explicit BlockConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp),
        block_(NULL) { }",3,24,table\table_test.cc,leveldb.BlockConstructor.BlockConstructor,,false,183,186,BlockConstructor,,,1,ANY leveldb.BlockConstructor.BlockConstructor (Comparator*)
74569,METHOD,leveldb.BlockConstructor,TYPE_DECL,"~BlockConstructor() {
    delete block_;
  }",3,3,table\table_test.cc,leveldb.BlockConstructor.~BlockConstructor,,false,187,189,~BlockConstructor,,,2,ANY leveldb.BlockConstructor.~BlockConstructor ()
74575,METHOD,leveldb.BlockConstructor,TYPE_DECL,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete block_;
    block_ = NULL;
    BlockBuilder builder(&options);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
    }
    // Open the block
    data_ = builder.Finish().ToString();
    BlockContents contents;
    contents.data = data_;
    contents.cachable = false;
    contents.heap_allocated = false;
    block_ = new Block(contents);
    return Status::OK();
  }",3,3,table\table_test.cc,leveldb.BlockConstructor.FinishImpl,,false,190,208,FinishImpl,,,3,"Status leveldb.BlockConstructor.FinishImpl (Options,KVMap)"
74653,METHOD,leveldb.BlockConstructor,TYPE_DECL,"virtual Iterator* NewIterator() const {
    return block_->NewIterator(comparator_);
  }",3,3,table\table_test.cc,leveldb.BlockConstructor.NewIterator,,false,209,211,NewIterator,,,4,Iterator leveldb.BlockConstructor.NewIterator ()
74666,METHOD,leveldb.BlockConstructor,TYPE_DECL,BlockConstructor();,3,20,table\table_test.cc,leveldb.BlockConstructor.BlockConstructor,,false,218,218,BlockConstructor,,,8,ANY leveldb.BlockConstructor.BlockConstructor ()
74671,METHOD,leveldb.TableConstructor,TYPE_DECL,"TableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        source_(NULL), table_(NULL) {
  }",3,3,table\table_test.cc,leveldb.TableConstructor.TableConstructor,,false,223,226,TableConstructor,,,1,ANY leveldb.TableConstructor.TableConstructor (Comparator*)
74676,METHOD,leveldb.TableConstructor,TYPE_DECL,"~TableConstructor() {
    Reset();
  }",3,3,table\table_test.cc,leveldb.TableConstructor.~TableConstructor,,false,227,229,~TableConstructor,,,2,ANY leveldb.TableConstructor.~TableConstructor ()
74681,METHOD,leveldb.TableConstructor,TYPE_DECL,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    Reset();
    StringSink sink;
    TableBuilder builder(options, &sink);

    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      builder.Add(it->first, it->second);
      ASSERT_TRUE(builder.status().ok());
    }
    Status s = builder.Finish();
    ASSERT_TRUE(s.ok()) << s.ToString();

    ASSERT_EQ(sink.contents().size(), builder.FileSize());

    // Open the table
    source_ = new StringSource(sink.contents());
    Options table_options;
    table_options.comparator = options.comparator;
    return Table::Open(table_options, source_, sink.contents().size(), &table_);
  }",3,6,table\table_test.cc,leveldb.TableConstructor.FinishImpl,,false,230,251,FinishImpl,,,3,"Status leveldb.TableConstructor.FinishImpl (Options,KVMap)"
74851,METHOD,leveldb.TableConstructor,TYPE_DECL,"virtual Iterator* NewIterator() const {
    return table_->NewIterator(ReadOptions());
  }",3,3,table\table_test.cc,leveldb.TableConstructor.NewIterator,,false,253,255,NewIterator,,,4,Iterator leveldb.TableConstructor.NewIterator ()
74861,METHOD,leveldb.TableConstructor,TYPE_DECL,"uint64_t ApproximateOffsetOf(const Slice& key) const {
    return table_->ApproximateOffsetOf(key);
  }",3,3,table\table_test.cc,leveldb.TableConstructor.ApproximateOffsetOf,,false,257,259,ApproximateOffsetOf,,,5,uint64_t leveldb.TableConstructor.ApproximateOffsetOf (Slice)
74872,METHOD,leveldb.TableConstructor,TYPE_DECL,"void Reset() {
    delete table_;
    delete source_;
    table_ = NULL;
    source_ = NULL;
  }",3,3,table\table_test.cc,leveldb.TableConstructor.Reset,,false,262,267,Reset,,,6,void leveldb.TableConstructor.Reset ()
74888,METHOD,leveldb.TableConstructor,TYPE_DECL,TableConstructor();,3,20,table\table_test.cc,leveldb.TableConstructor.TableConstructor,,false,272,272,TableConstructor,,,9,ANY leveldb.TableConstructor.TableConstructor ()
74893,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,explicit KeyConvertingIterator(Iterator* iter) : iter_(iter) { },3,66,table\table_test.cc,leveldb.KeyConvertingIterator.KeyConvertingIterator,,false,278,278,KeyConvertingIterator,,,1,ANY leveldb.KeyConvertingIterator.KeyConvertingIterator (Iterator*)
74898,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual ~KeyConvertingIterator() { delete iter_; },3,52,table\table_test.cc,leveldb.KeyConvertingIterator.~KeyConvertingIterator,,false,279,279,~KeyConvertingIterator,,,2,ANY leveldb.KeyConvertingIterator.~KeyConvertingIterator ()
74904,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual bool Valid() const { return iter_->Valid(); },3,55,table\table_test.cc,leveldb.KeyConvertingIterator.Valid,,false,280,280,Valid,,,3,bool leveldb.KeyConvertingIterator.Valid ()
74913,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,"virtual void Seek(const Slice& target) {
    ParsedInternalKey ikey(target, kMaxSequenceNumber, kTypeValue);
    std::string encoded;
    AppendInternalKey(&encoded, ikey);
    iter_->Seek(encoded);
  }",3,3,table\table_test.cc,leveldb.KeyConvertingIterator.Seek,,false,281,286,Seek,,,4,void leveldb.KeyConvertingIterator.Seek (Slice)
74933,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual void SeekToFirst() { iter_->SeekToFirst(); },3,54,table\table_test.cc,leveldb.KeyConvertingIterator.SeekToFirst,,false,287,287,SeekToFirst,,,5,void leveldb.KeyConvertingIterator.SeekToFirst ()
74941,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual void SeekToLast() { iter_->SeekToLast(); },3,52,table\table_test.cc,leveldb.KeyConvertingIterator.SeekToLast,,false,288,288,SeekToLast,,,6,void leveldb.KeyConvertingIterator.SeekToLast ()
74949,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual void Next() { iter_->Next(); },3,40,table\table_test.cc,leveldb.KeyConvertingIterator.Next,,false,289,289,Next,,,7,void leveldb.KeyConvertingIterator.Next ()
74957,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual void Prev() { iter_->Prev(); },3,40,table\table_test.cc,leveldb.KeyConvertingIterator.Prev,,false,290,290,Prev,,,8,void leveldb.KeyConvertingIterator.Prev ()
74965,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,"virtual Slice key() const {
    assert(Valid());
    ParsedInternalKey key;
    if (!ParseInternalKey(iter_->key(), &key)) {
      status_ = Status::Corruption(""malformed internal key"");
      return Slice(""corrupted key"");
    }
    return key.user_key;
  }",3,3,table\table_test.cc,leveldb.KeyConvertingIterator.key,,false,292,300,key,,,9,Slice leveldb.KeyConvertingIterator.key ()
74996,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,virtual Slice value() const { return iter_->value(); },3,56,table\table_test.cc,leveldb.KeyConvertingIterator.value,,false,302,302,value,,,10,Slice leveldb.KeyConvertingIterator.value ()
75005,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,"virtual Status status() const {
    return status_.ok() ? iter_->status() : status_;
  }",3,3,table\table_test.cc,leveldb.KeyConvertingIterator.status,,false,303,305,status,,,11,Status leveldb.KeyConvertingIterator.status ()
75022,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,KeyConvertingIterator(const KeyConvertingIterator&);,3,53,table\table_test.cc,leveldb.KeyConvertingIterator.KeyConvertingIterator,,false,312,312,KeyConvertingIterator,,,14,ANY leveldb.KeyConvertingIterator.KeyConvertingIterator (KeyConvertingIterator)
75027,METHOD,leveldb.KeyConvertingIterator,TYPE_DECL,void operator=(const KeyConvertingIterator&);,8,46,table\table_test.cc,leveldb.KeyConvertingIterator.operator =,,false,313,313,operator =,,,15,void leveldb.KeyConvertingIterator.operator = (KeyConvertingIterator)
75033,METHOD,leveldb.MemTableConstructor,TYPE_DECL,"explicit MemTableConstructor(const Comparator* cmp)
      : Constructor(cmp),
        internal_comparator_(cmp) {
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
  }",3,3,table\table_test.cc,leveldb.MemTableConstructor.MemTableConstructor,,false,318,323,MemTableConstructor,,,1,ANY leveldb.MemTableConstructor.MemTableConstructor (Comparator*)
75047,METHOD,leveldb.MemTableConstructor,TYPE_DECL,"~MemTableConstructor() {
    memtable_->Unref();
  }",3,3,table\table_test.cc,leveldb.MemTableConstructor.~MemTableConstructor,,false,324,326,~MemTableConstructor,,,2,ANY leveldb.MemTableConstructor.~MemTableConstructor ()
75055,METHOD,leveldb.MemTableConstructor,TYPE_DECL,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    memtable_->Unref();
    memtable_ = new MemTable(internal_comparator_);
    memtable_->Ref();
    int seq = 1;
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      memtable_->Add(seq, kTypeValue, it->first, it->second);
      seq++;
    }
    return Status::OK();
  }",3,3,table\table_test.cc,leveldb.MemTableConstructor.FinishImpl,,false,327,339,FinishImpl,,,3,"Status leveldb.MemTableConstructor.FinishImpl (Options,KVMap)"
75115,METHOD,leveldb.MemTableConstructor,TYPE_DECL,"virtual Iterator* NewIterator() const {
    return new KeyConvertingIterator(memtable_->NewIterator());
  }",3,3,table\table_test.cc,leveldb.MemTableConstructor.NewIterator,,false,340,342,NewIterator,,,4,Iterator leveldb.MemTableConstructor.NewIterator ()
75129,METHOD,leveldb.DBConstructor,TYPE_DECL,"explicit DBConstructor(const Comparator* cmp)
      : Constructor(cmp),
        comparator_(cmp) {
    db_ = NULL;
    NewDB();
  }",3,3,table\table_test.cc,leveldb.DBConstructor.DBConstructor,,false,351,356,DBConstructor,,,1,ANY leveldb.DBConstructor.DBConstructor (Comparator*)
75138,METHOD,leveldb.DBConstructor,TYPE_DECL,"~DBConstructor() {
    delete db_;
  }",3,3,table\table_test.cc,leveldb.DBConstructor.~DBConstructor,,false,357,359,~DBConstructor,,,2,ANY leveldb.DBConstructor.~DBConstructor ()
75144,METHOD,leveldb.DBConstructor,TYPE_DECL,"virtual Status FinishImpl(const Options& options, const KVMap& data) {
    delete db_;
    db_ = NULL;
    NewDB();
    for (KVMap::const_iterator it = data.begin();
         it != data.end();
         ++it) {
      WriteBatch batch;
      batch.Put(it->first, it->second);
      ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok());
    }
    return Status::OK();
  }",3,6,table\table_test.cc,leveldb.DBConstructor.FinishImpl,,false,360,372,FinishImpl,,,3,"Status leveldb.DBConstructor.FinishImpl (Options,KVMap)"
75214,METHOD,leveldb.DBConstructor,TYPE_DECL,"virtual Iterator* NewIterator() const {
    return db_->NewIterator(ReadOptions());
  }",3,3,table\table_test.cc,leveldb.DBConstructor.NewIterator,,false,373,375,NewIterator,,,4,Iterator leveldb.DBConstructor.NewIterator ()
75224,METHOD,leveldb.DBConstructor,TYPE_DECL,virtual DB* db() const { return db_; },3,40,table\table_test.cc,leveldb.DBConstructor.db,,false,377,377,db,,,5,DB leveldb.DBConstructor.db ()
75230,METHOD,leveldb.DBConstructor,TYPE_DECL,"void NewDB() {
    std::string name = test::TmpDir() + ""/table_testdb"";

    Options options;
    options.comparator = comparator_;
    Status status = DestroyDB(name, options);
    ASSERT_TRUE(status.ok()) << status.ToString();

    options.create_if_missing = true;
    options.error_if_exists = true;
    options.write_buffer_size = 10000;  // Something small to force merging
    status = DB::Open(options, name, &db_);
    ASSERT_TRUE(status.ok()) << status.ToString();
  }",3,4,table\table_test.cc,leveldb.DBConstructor.NewDB,,false,380,393,NewDB,,,6,void leveldb.DBConstructor.NewDB ()
75424,METHOD,leveldb.Harness,TYPE_DECL,Harness() : constructor_(NULL) { },3,36,table\table_test.cc,leveldb.Harness.Harness,,false,439,439,Harness,,,1,ANY leveldb.Harness.Harness ()
75428,METHOD,leveldb.Harness,TYPE_DECL,"void Init(const TestArgs& args) {
    delete constructor_;
    constructor_ = NULL;
    options_ = Options();

    options_.block_restart_interval = args.restart_interval;
    // Use shorter block size for tests to exercise block boundary
    // conditions more.
    options_.block_size = 256;
    if (args.reverse_compare) {
      options_.comparator = &reverse_key_comparator;
    }
    switch (args.type) {
      case TABLE_TEST:
        constructor_ = new TableConstructor(options_.comparator);
        break;
      case BLOCK_TEST:
        constructor_ = new BlockConstructor(options_.comparator);
        break;
      case MEMTABLE_TEST:
        constructor_ = new MemTableConstructor(options_.comparator);
        break;
      case DB_TEST:
        constructor_ = new DBConstructor(options_.comparator);
        break;
    }
  }",3,3,table\table_test.cc,leveldb.Harness.Init,,false,441,467,Init,,,2,void leveldb.Harness.Init (TestArgs)
75509,METHOD,leveldb.Harness,TYPE_DECL,"~Harness() {
    delete constructor_;
  }",3,3,table\table_test.cc,leveldb.Harness.~Harness,,false,469,471,~Harness,,,3,ANY leveldb.Harness.~Harness ()
75515,METHOD,leveldb.Harness,TYPE_DECL,"void Add(const std::string& key, const std::string& value) {
    constructor_->Add(key, value);
  }",3,3,table\table_test.cc,leveldb.Harness.Add,,false,473,475,Add,,,4,"void leveldb.Harness.Add (ANY,ANY)"
75527,METHOD,leveldb.Harness,TYPE_DECL,"void Test(Random* rnd) {
    std::vector<std::string> keys;
    KVMap data;
    constructor_->Finish(options_, &keys, &data);

    TestForwardScan(keys, data);
    TestBackwardScan(keys, data);
    TestRandomAccess(rnd, keys, data);
  }",3,3,table\table_test.cc,leveldb.Harness.Test,,false,477,485,Test,,,5,void leveldb.Harness.Test (Random*)
75561,METHOD,leveldb.Harness,TYPE_DECL,"void TestForwardScan(const std::vector<std::string>& keys,
                       const KVMap& data) {
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToFirst();
    for (KVMap::const_iterator model_iter = data.begin();
         model_iter != data.end();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Next();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",3,4,table\table_test.cc,leveldb.Harness.TestForwardScan,,false,487,500,TestForwardScan,,,6,"void leveldb.Harness.TestForwardScan (ANY,KVMap)"
75670,METHOD,leveldb.Harness,TYPE_DECL,"void TestBackwardScan(const std::vector<std::string>& keys,
                        const KVMap& data) {
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    iter->SeekToLast();
    for (KVMap::const_reverse_iterator model_iter = data.rbegin();
         model_iter != data.rend();
         ++model_iter) {
      ASSERT_EQ(ToString(data, model_iter), ToString(iter));
      iter->Prev();
    }
    ASSERT_TRUE(!iter->Valid());
    delete iter;
  }",3,4,table\table_test.cc,leveldb.Harness.TestBackwardScan,,false,502,515,TestBackwardScan,,,7,"void leveldb.Harness.TestBackwardScan (ANY,KVMap)"
75779,METHOD,leveldb.Harness,TYPE_DECL,"void TestRandomAccess(Random* rnd,
                        const std::vector<std::string>& keys,
                        const KVMap& data) {
    static const bool kVerbose = false;
    Iterator* iter = constructor_->NewIterator();
    ASSERT_TRUE(!iter->Valid());
    KVMap::const_iterator model_iter = data.begin();
    if (kVerbose) fprintf(stderr, ""---\n"");
    for (int i = 0; i < 200; i++) {
      const int toss = rnd->Uniform(5);
      switch (toss) {
        case 0: {
          if (iter->Valid()) {
            if (kVerbose) fprintf(stderr, ""Next\n"");
            iter->Next();
            ++model_iter;
            ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          }
          break;
        }

        case 1: {
          if (kVerbose) fprintf(stderr, ""SeekToFirst\n"");
          iter->SeekToFirst();
          model_iter = data.begin();
          ASSERT_EQ(ToString(data, model_iter), ToString(iter));
          break;
        }

        case 2: {
          std::string...",3,4,table\table_test.cc,leveldb.Harness.TestRandomAccess,,false,517,585,TestRandomAccess,,,8,"void leveldb.Harness.TestRandomAccess (Random*,ANY,KVMap)"
76117,METHOD,leveldb.Harness,TYPE_DECL,"std::string ToString(const KVMap& data, const KVMap::const_iterator& it) {
    if (it == data.end()) {
      return ""END"";
    } else {
      return ""'"" + it->first + ""->"" + it->second + ""'"";
    }
  }",3,3,table\table_test.cc,leveldb.Harness.ToString,,false,587,593,ToString,,,9,"string leveldb.Harness.ToString (KVMap,ANY)"
76149,METHOD,leveldb.Harness,TYPE_DECL,"std::string ToString(const KVMap& data,
                       const KVMap::const_reverse_iterator& it) {
    if (it == data.rend()) {
      return ""END"";
    } else {
      return ""'"" + it->first + ""->"" + it->second + ""'"";
    }
  }",3,3,table\table_test.cc,leveldb.Harness.ToString,,false,595,602,ToString,,,10,"string leveldb.Harness.ToString (KVMap,ANY)"
76181,METHOD,leveldb.Harness,TYPE_DECL,"std::string ToString(const Iterator* it) {
    if (!it->Valid()) {
      return ""END"";
    } else {
      return ""'"" + it->key().ToString() + ""->"" + it->value().ToString() + ""'"";
    }
  }",3,3,table\table_test.cc,leveldb.Harness.ToString,,false,604,610,ToString,,,11,string leveldb.Harness.ToString (Iterator*)
76219,METHOD,leveldb.Harness,TYPE_DECL,"std::string PickRandomKey(Random* rnd, const std::vector<std::string>& keys) {
    if (keys.empty()) {
      return ""foo"";
    } else {
      const int index = rnd->Uniform(keys.size());
      std::string result = keys[index];
      switch (rnd->Uniform(3)) {
        case 0:
          // Return an existing key
          break;
        case 1: {
          // Attempt to return something smaller than an existing key
          if (result.size() > 0 && result[result.size()-1] > '\0') {
            result[result.size()-1]--;
          }
          break;
        }
        case 2: {
          // Return something larger than an existing key
          Increment(options_.comparator, &result);
          break;
        }
      }
      return result;
    }
  }",3,3,table\table_test.cc,leveldb.Harness.PickRandomKey,,false,612,637,PickRandomKey,,,12,"string leveldb.Harness.PickRandomKey (Random*,ANY)"
76306,METHOD,leveldb.Harness,TYPE_DECL,DB* db() const { return constructor_->db(); },3,47,table\table_test.cc,leveldb.Harness.db,,false,640,640,db,,,13,DB leveldb.Harness.db ()
76318,METHOD,leveldb._Test_Empty,TYPE_DECL,void void ();,1,20,table\table_test.cc,leveldb._Test_Empty._Run,,false,648,648,_Run,,,1,void leveldb._Test_Empty._Run ()
76322,METHOD,leveldb._Test_Empty,TYPE_DECL,"TEST(Harness, Empty)",1,20,table\table_test.cc,leveldb._Test_Empty._RunIt,,false,648,648,_RunIt,,,2,void leveldb._Test_Empty._RunIt ()
76346,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, Empty) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Test(&rnd);
  }
}",1,20,table\table_test.cc,leveldb._Test_Empty._Run,,false,648,654,_Run,,,25,void leveldb._Test_Empty._Run ()
76378,METHOD,leveldb._Test_ZeroRestartPointsInBlock,TYPE_DECL,void void ();,1,39,table\table_test.cc,leveldb._Test_ZeroRestartPointsInBlock._Run,,false,659,659,_Run,,,1,void leveldb._Test_ZeroRestartPointsInBlock._Run ()
76382,METHOD,leveldb._Test_ZeroRestartPointsInBlock,TYPE_DECL,"TEST(Harness, ZeroRestartPointsInBlock)",1,39,table\table_test.cc,leveldb._Test_ZeroRestartPointsInBlock._RunIt,,false,659,659,_RunIt,,,2,void leveldb._Test_ZeroRestartPointsInBlock._RunIt ()
76406,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, ZeroRestartPointsInBlock) {
  char data[sizeof(uint32_t)];
  memset(data, 0, sizeof(data));
  BlockContents contents;
  contents.data = Slice(data, sizeof(data));
  contents.cachable = false;
  contents.heap_allocated = false;
  Block block(contents);
  Iterator* iter = block.NewIterator(BytewiseComparator());
  iter->SeekToFirst();
  ASSERT_TRUE(!iter->Valid());
  iter->SeekToLast();
  ASSERT_TRUE(!iter->Valid());
  iter->Seek(""foo"");
  ASSERT_TRUE(!iter->Valid());
  delete iter;
}",1,39,table\table_test.cc,leveldb._Test_ZeroRestartPointsInBlock._Run,,false,659,675,_Run,,,29,void leveldb._Test_ZeroRestartPointsInBlock._Run ()
76534,METHOD,leveldb._Test_SimpleEmptyKey,TYPE_DECL,void void ();,1,29,table\table_test.cc,leveldb._Test_SimpleEmptyKey._Run,,false,678,678,_Run,,,1,void leveldb._Test_SimpleEmptyKey._Run ()
76538,METHOD,leveldb._Test_SimpleEmptyKey,TYPE_DECL,"TEST(Harness, SimpleEmptyKey)",1,29,table\table_test.cc,leveldb._Test_SimpleEmptyKey._RunIt,,false,678,678,_RunIt,,,2,void leveldb._Test_SimpleEmptyKey._RunIt ()
76562,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, SimpleEmptyKey) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 1);
    Add("""", ""v"");
    Test(&rnd);
  }
}",1,29,table\table_test.cc,leveldb._Test_SimpleEmptyKey._Run,,false,678,685,_Run,,,33,void leveldb._Test_SimpleEmptyKey._Run ()
76597,METHOD,leveldb._Test_SimpleSingle,TYPE_DECL,void void ();,1,27,table\table_test.cc,leveldb._Test_SimpleSingle._Run,,false,687,687,_Run,,,1,void leveldb._Test_SimpleSingle._Run ()
76601,METHOD,leveldb._Test_SimpleSingle,TYPE_DECL,"TEST(Harness, SimpleSingle)",1,27,table\table_test.cc,leveldb._Test_SimpleSingle._RunIt,,false,687,687,_RunIt,,,2,void leveldb._Test_SimpleSingle._RunIt ()
76625,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, SimpleSingle) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 2);
    Add(""abc"", ""v"");
    Test(&rnd);
  }
}",1,27,table\table_test.cc,leveldb._Test_SimpleSingle._Run,,false,687,694,_Run,,,37,void leveldb._Test_SimpleSingle._Run ()
76660,METHOD,leveldb._Test_SimpleMulti,TYPE_DECL,void void ();,1,26,table\table_test.cc,leveldb._Test_SimpleMulti._Run,,false,696,696,_Run,,,1,void leveldb._Test_SimpleMulti._Run ()
76664,METHOD,leveldb._Test_SimpleMulti,TYPE_DECL,"TEST(Harness, SimpleMulti)",1,26,table\table_test.cc,leveldb._Test_SimpleMulti._RunIt,,false,696,696,_RunIt,,,2,void leveldb._Test_SimpleMulti._RunIt ()
76688,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, SimpleMulti) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 3);
    Add(""abc"", ""v"");
    Add(""abcd"", ""v"");
    Add(""ac"", ""v2"");
    Test(&rnd);
  }
}",1,26,table\table_test.cc,leveldb._Test_SimpleMulti._Run,,false,696,705,_Run,,,41,void leveldb._Test_SimpleMulti._Run ()
76729,METHOD,leveldb._Test_SimpleSpecialKey,TYPE_DECL,void void ();,1,31,table\table_test.cc,leveldb._Test_SimpleSpecialKey._Run,,false,707,707,_Run,,,1,void leveldb._Test_SimpleSpecialKey._Run ()
76733,METHOD,leveldb._Test_SimpleSpecialKey,TYPE_DECL,"TEST(Harness, SimpleSpecialKey)",1,31,table\table_test.cc,leveldb._Test_SimpleSpecialKey._RunIt,,false,707,707,_RunIt,,,2,void leveldb._Test_SimpleSpecialKey._RunIt ()
76757,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, SimpleSpecialKey) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 4);
    Add(""\xff\xff"", ""v3"");
    Test(&rnd);
  }
}",1,31,table\table_test.cc,leveldb._Test_SimpleSpecialKey._Run,,false,707,714,_Run,,,45,void leveldb._Test_SimpleSpecialKey._Run ()
76792,METHOD,leveldb._Test_Randomized,TYPE_DECL,void void ();,1,25,table\table_test.cc,leveldb._Test_Randomized._Run,,false,716,716,_Run,,,1,void leveldb._Test_Randomized._Run ()
76796,METHOD,leveldb._Test_Randomized,TYPE_DECL,"TEST(Harness, Randomized)",1,25,table\table_test.cc,leveldb._Test_Randomized._RunIt,,false,716,716,_RunIt,,,2,void leveldb._Test_Randomized._RunIt ()
76820,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, Randomized) {
  for (int i = 0; i < kNumTestArgs; i++) {
    Init(kTestArgList[i]);
    Random rnd(test::RandomSeed() + 5);
    for (int num_entries = 0; num_entries < 2000;
         num_entries += (num_entries < 50 ? 1 : 200)) {
      if ((num_entries % 10) == 0) {
        fprintf(stderr, ""case %d of %d: num_entries = %d\n"",
                (i + 1), int(kNumTestArgs), num_entries);
      }
      for (int e = 0; e < num_entries; e++) {
        std::string v;
        Add(test::RandomKey(&rnd, rnd.Skewed(4)),
            test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
      }
      Test(&rnd);
    }
  }
}",1,25,table\table_test.cc,leveldb._Test_Randomized._Run,,false,716,734,_Run,,,49,void leveldb._Test_Randomized._Run ()
76928,METHOD,leveldb._Test_RandomizedLongDB,TYPE_DECL,void void ();,1,31,table\table_test.cc,leveldb._Test_RandomizedLongDB._Run,,false,736,736,_Run,,,1,void leveldb._Test_RandomizedLongDB._Run ()
76932,METHOD,leveldb._Test_RandomizedLongDB,TYPE_DECL,"TEST(Harness, RandomizedLongDB)",1,31,table\table_test.cc,leveldb._Test_RandomizedLongDB._RunIt,,false,736,736,_RunIt,,,2,void leveldb._Test_RandomizedLongDB._RunIt ()
76956,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(Harness, RandomizedLongDB) {
  Random rnd(test::RandomSeed());
  TestArgs args = { DB_TEST, false, 16 };
  Init(args);
  int num_entries = 100000;
  for (int e = 0; e < num_entries; e++) {
    std::string v;
    Add(test::RandomKey(&rnd, rnd.Skewed(4)),
        test::RandomString(&rnd, rnd.Skewed(5), &v).ToString());
  }
  Test(&rnd);

  // We must have created enough data to force merging
  int files = 0;
  for (int level = 0; level < config::kNumLevels; level++) {
    std::string value;
    char name[100];
    snprintf(name, sizeof(name), ""leveldb.num-files-at-level%d"", level);
    ASSERT_TRUE(db()->GetProperty(name, &value));
    files += atoi(value.c_str());
  }
  ASSERT_GT(files, 0);
}",1,31,table\table_test.cc,leveldb._Test_RandomizedLongDB._Run,,false,736,758,_Run,,,53,void leveldb._Test_RandomizedLongDB._Run ()
77096,METHOD,leveldb._Test_Simple,TYPE_DECL,void void ();,1,26,table\table_test.cc,leveldb._Test_Simple._Run,,false,762,762,_Run,,,1,void leveldb._Test_Simple._Run ()
77100,METHOD,leveldb._Test_Simple,TYPE_DECL,"TEST(MemTableTest, Simple)",1,26,table\table_test.cc,leveldb._Test_Simple._RunIt,,false,762,762,_RunIt,,,2,void leveldb._Test_Simple._RunIt ()
77124,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(MemTableTest, Simple) {
  InternalKeyComparator cmp(BytewiseComparator());
  MemTable* memtable = new MemTable(cmp);
  memtable->Ref();
  WriteBatch batch;
  WriteBatchInternal::SetSequence(&batch, 100);
  batch.Put(std::string(""k1""), std::string(""v1""));
  batch.Put(std::string(""k2""), std::string(""v2""));
  batch.Put(std::string(""k3""), std::string(""v3""));
  batch.Put(std::string(""largekey""), std::string(""vlarge""));
  ASSERT_TRUE(WriteBatchInternal::InsertInto(&batch, memtable).ok());

  Iterator* iter = memtable->NewIterator();
  iter->SeekToFirst();
  while (iter->Valid()) {
    fprintf(stderr, ""key: '%s' -> '%s'\n"",
            iter->key().ToString().c_str(),
            iter->value().ToString().c_str());
    iter->Next();
  }

  delete iter;
  memtable->Unref();
}",1,26,table\table_test.cc,leveldb._Test_Simple._Run,,false,762,785,_Run,,,58,void leveldb._Test_Simple._Run ()
77279,METHOD,table\table_test.cc:<global>,TYPE_DECL,"static bool Between(uint64_t val, uint64_t low, uint64_t high) {
  bool result = (val >= low) && (val <= high);
  if (!result) {
    fprintf(stderr, ""Value %llu is not in range [%llu, %llu]\n"",
            (unsigned long long)(val),
            (unsigned long long)(low),
            (unsigned long long)(high));
  }
  return result;
}",1,1,table\table_test.cc,leveldb.Between,,false,787,796,Between,,,59,"bool leveldb.Between (uint64_t,uint64_t,uint64_t)"
77316,METHOD,leveldb._Test_ApproximateOffsetOfPlain,TYPE_DECL,void void ();,1,41,table\table_test.cc,leveldb._Test_ApproximateOffsetOfPlain._Run,,false,800,800,_Run,,,1,void leveldb._Test_ApproximateOffsetOfPlain._Run ()
77320,METHOD,leveldb._Test_ApproximateOffsetOfPlain,TYPE_DECL,"TEST(TableTest, ApproximateOffsetOfPlain)",1,41,table\table_test.cc,leveldb._Test_ApproximateOffsetOfPlain._RunIt,,false,800,800,_RunIt,,,2,void leveldb._Test_ApproximateOffsetOfPlain._RunIt ()
77344,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(TableTest, ApproximateOffsetOfPlain) {
  TableConstructor c(BytewiseComparator());
  c.Add(""k01"", ""hello"");
  c.Add(""k02"", ""hello2"");
  c.Add(""k03"", std::string(10000, 'x'));
  c.Add(""k04"", std::string(200000, 'x'));
  c.Add(""k05"", std::string(300000, 'x'));
  c.Add(""k06"", ""hello3"");
  c.Add(""k07"", std::string(100000, 'x'));
  std::vector<std::string> keys;
  KVMap kvmap;
  Options options;
  options.block_size = 1024;
  options.compression = kNoCompression;
  c.Finish(options, &keys, &kvmap);

  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000));
  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 21100...",1,41,table\table_test.cc,leveldb._Test_ApproximateOffsetOfPlain._Run,,false,800,828,_Run,,,64,void leveldb._Test_ApproximateOffsetOfPlain._Run ()
77685,METHOD,table\table_test.cc:<global>,TYPE_DECL,"static bool SnappyCompressionSupported() {
  std::string out;
  Slice in = ""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"";
  return port::Snappy_Compress(in.data(), in.size(), &out);
}",1,1,table\table_test.cc,leveldb.SnappyCompressionSupported,,false,830,834,SnappyCompressionSupported,,,65,bool leveldb.SnappyCompressionSupported ()
77710,METHOD,leveldb._Test_ApproximateOffsetOfCompressed,TYPE_DECL,void void ();,1,46,table\table_test.cc,leveldb._Test_ApproximateOffsetOfCompressed._Run,,false,836,836,_Run,,,1,void leveldb._Test_ApproximateOffsetOfCompressed._Run ()
77714,METHOD,leveldb._Test_ApproximateOffsetOfCompressed,TYPE_DECL,"TEST(TableTest, ApproximateOffsetOfCompressed)",1,46,table\table_test.cc,leveldb._Test_ApproximateOffsetOfCompressed._RunIt,,false,836,836,_RunIt,,,2,void leveldb._Test_ApproximateOffsetOfCompressed._RunIt ()
77738,METHOD,table\table_test.cc:<global>,TYPE_DECL,"TEST(TableTest, ApproximateOffsetOfCompressed) {
  if (!SnappyCompressionSupported()) {
    fprintf(stderr, ""skipping compression tests\n"");
    return;
  }

  Random rnd(301);
  TableConstructor c(BytewiseComparator());
  std::string tmp;
  c.Add(""k01"", ""hello"");
  c.Add(""k02"", test::CompressibleString(&rnd, 0.25, 10000, &tmp));
  c.Add(""k03"", ""hello3"");
  c.Add(""k04"", test::CompressibleString(&rnd, 0.25, 10000, &tmp));
  std::vector<std::string> keys;
  KVMap kvmap;
  Options options;
  options.block_size = 1024;
  options.compression = kSnappyCompression;
  c.Finish(options, &keys, &kvmap);

  // Expected upper and lower bounds of space used by compressible strings.
  static const int kSlop = 1000;  // Compressor effectiveness varies.
  const int expected = 2500;  // 10000 * compression ratio (0.25)
  const int min_z = expected - kSlop;
  const int max_z = expected + kSlop;

  ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop));
  ASSERT_TRUE(Between(c.ApproximateOffsetO...",1,46,table\table_test.cc,leveldb._Test_ApproximateOffsetOfCompressed._Run,,false,836,870,_Run,,,69,void leveldb._Test_ApproximateOffsetOfCompressed._Run ()
77985,METHOD,table\table_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,table\table_test.cc,main,,false,874,876,main,,,2,"int main (int,char**)"
78011,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,<global>,1,1,table\two_level_iterator.cc,table\two_level_iterator.cc:<global>,,false,1,182,<global>,,,1,
78015,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"typedef Iterator* (*BlockFunction)(void*, const ReadOptions&, const Slice&);",17,75,table\two_level_iterator.cc,leveldb.anonymous_namespace_1.BlockFunction,,false,16,16,BlockFunction,,,1,"Iterator* leveldb.anonymous_namespace_1.BlockFunction (void*,ReadOptions,Slice)"
78023,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,"TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options);",3,31,table\two_level_iterator.cc,leveldb.anonymous_namespace_3.TwoLevelIterator.TwoLevelIterator,,false,20,24,TwoLevelIterator,,,1,"ANY leveldb.anonymous_namespace_3.TwoLevelIterator.TwoLevelIterator (Iterator*,BlockFunction,void*,ReadOptions)"
78031,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,virtual ~TwoLevelIterator();,11,29,table\two_level_iterator.cc,leveldb.anonymous_namespace_4.TwoLevelIterator.~TwoLevelIterator,,false,26,26,~TwoLevelIterator,,,2,virtual leveldb.anonymous_namespace_4.TwoLevelIterator.~TwoLevelIterator ()
78035,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,virtual void Seek(const Slice& target);,16,40,table\two_level_iterator.cc,leveldb.anonymous_namespace_5.TwoLevelIterator.Seek,,false,28,28,Seek,,,3,void leveldb.anonymous_namespace_5.TwoLevelIterator.Seek (Slice)
78040,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,virtual void SeekToFirst();,16,28,table\two_level_iterator.cc,leveldb.anonymous_namespace_6.TwoLevelIterator.SeekToFirst,,false,29,29,SeekToFirst,,,4,void leveldb.anonymous_namespace_6.TwoLevelIterator.SeekToFirst ()
78044,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,virtual void SeekToLast();,16,27,table\two_level_iterator.cc,leveldb.anonymous_namespace_7.TwoLevelIterator.SeekToLast,,false,30,30,SeekToLast,,,5,void leveldb.anonymous_namespace_7.TwoLevelIterator.SeekToLast ()
78048,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,virtual void Next();,16,21,table\two_level_iterator.cc,leveldb.anonymous_namespace_8.TwoLevelIterator.Next,,false,31,31,Next,,,6,void leveldb.anonymous_namespace_8.TwoLevelIterator.Next ()
78052,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,virtual void Prev();,16,21,table\two_level_iterator.cc,leveldb.anonymous_namespace_9.TwoLevelIterator.Prev,,false,32,32,Prev,,,7,void leveldb.anonymous_namespace_9.TwoLevelIterator.Prev ()
78056,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,"virtual bool Valid() const {
    return data_iter_.Valid();
  }",3,3,table\two_level_iterator.cc,leveldb.anonymous_namespace_10.TwoLevelIterator.Valid,,false,34,36,Valid,,,8,bool leveldb.anonymous_namespace_10.TwoLevelIterator.Valid ()
78065,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,"virtual Slice key() const {
    assert(Valid());
    return data_iter_.key();
  }",3,3,table\two_level_iterator.cc,leveldb.anonymous_namespace_11.TwoLevelIterator.key,,false,37,40,key,,,9,Slice leveldb.anonymous_namespace_11.TwoLevelIterator.key ()
78076,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,"virtual Slice value() const {
    assert(Valid());
    return data_iter_.value();
  }",3,3,table\two_level_iterator.cc,leveldb.anonymous_namespace_13.TwoLevelIterator.value,,false,41,44,value,,,10,Slice leveldb.anonymous_namespace_13.TwoLevelIterator.value ()
78087,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,"virtual Status status() const {
    // It'd be nice if status() returned a const Status& instead of a Status
    if (!index_iter_.status().ok()) {
      return index_iter_.status();
    } else if (data_iter_.iter() != NULL && !data_iter_.status().ok()) {
      return data_iter_.status();
    } else {
      return status_;
    }
  }",3,3,table\two_level_iterator.cc,leveldb.anonymous_namespace_15.TwoLevelIterator.status,,false,45,54,status,,,11,Status leveldb.anonymous_namespace_15.TwoLevelIterator.status ()
78134,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,"void SaveError(const Status& s) {
    if (status_.ok() && !s.ok()) status_ = s;
  }",3,3,table\two_level_iterator.cc,leveldb.anonymous_namespace_16.TwoLevelIterator.SaveError,,false,57,59,SaveError,,,12,void leveldb.anonymous_namespace_16.TwoLevelIterator.SaveError (Status)
78154,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,void SkipEmptyDataBlocksForward();,8,35,table\two_level_iterator.cc,leveldb.anonymous_namespace_17.TwoLevelIterator.SkipEmptyDataBlocksForward,,false,60,60,SkipEmptyDataBlocksForward,,,13,void leveldb.anonymous_namespace_17.TwoLevelIterator.SkipEmptyDataBlocksForward ()
78158,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,void SkipEmptyDataBlocksBackward();,8,36,table\two_level_iterator.cc,leveldb.anonymous_namespace_18.TwoLevelIterator.SkipEmptyDataBlocksBackward,,false,61,61,SkipEmptyDataBlocksBackward,,,14,void leveldb.anonymous_namespace_18.TwoLevelIterator.SkipEmptyDataBlocksBackward ()
78162,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,void SetDataIterator(Iterator* data_iter);,8,43,table\two_level_iterator.cc,leveldb.anonymous_namespace_19.TwoLevelIterator.SetDataIterator,,false,62,62,SetDataIterator,,,15,void leveldb.anonymous_namespace_19.TwoLevelIterator.SetDataIterator (Iterator*)
78167,METHOD,leveldb.anonymous_namespace_2.TwoLevelIterator,TYPE_DECL,void InitDataBlock();,8,22,table\two_level_iterator.cc,leveldb.anonymous_namespace_20.TwoLevelIterator.InitDataBlock,,false,63,63,InitDataBlock,,,16,void leveldb.anonymous_namespace_20.TwoLevelIterator.InitDataBlock ()
78178,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"TwoLevelIterator::TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options)
    : block_function_(block_function),
      arg_(arg),
      options_(options),
      index_iter_(index_iter),
      data_iter_(NULL) {
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_21.TwoLevelIterator.TwoLevelIterator,,false,76,86,TwoLevelIterator,,,3,"ANY leveldb.anonymous_namespace_21.TwoLevelIterator.TwoLevelIterator (Iterator*,BlockFunction,void*,ReadOptions)"
78186,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"TwoLevelIterator::~TwoLevelIterator() {
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_22.TwoLevelIterator.~TwoLevelIterator,,false,88,89,~TwoLevelIterator,,,4,ANY leveldb.anonymous_namespace_22.TwoLevelIterator.~TwoLevelIterator ()
78190,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::Seek(const Slice& target) {
  index_iter_.Seek(target);
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.Seek(target);
  SkipEmptyDataBlocksForward();
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_23.TwoLevelIterator.Seek,,false,91,96,Seek,,,5,void leveldb.anonymous_namespace_23.TwoLevelIterator.Seek (Slice)
78215,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::SeekToFirst() {
  index_iter_.SeekToFirst();
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  SkipEmptyDataBlocksForward();
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_24.TwoLevelIterator.SeekToFirst,,false,98,103,SeekToFirst,,,6,void leveldb.anonymous_namespace_24.TwoLevelIterator.SeekToFirst ()
78237,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::SeekToLast() {
  index_iter_.SeekToLast();
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  SkipEmptyDataBlocksBackward();
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_25.TwoLevelIterator.SeekToLast,,false,105,110,SeekToLast,,,7,void leveldb.anonymous_namespace_25.TwoLevelIterator.SeekToLast ()
78259,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::Next() {
  assert(Valid());
  data_iter_.Next();
  SkipEmptyDataBlocksForward();
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_26.TwoLevelIterator.Next,,false,112,116,Next,,,8,void leveldb.anonymous_namespace_26.TwoLevelIterator.Next ()
78270,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::Prev() {
  assert(Valid());
  data_iter_.Prev();
  SkipEmptyDataBlocksBackward();
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_28.TwoLevelIterator.Prev,,false,118,122,Prev,,,9,void leveldb.anonymous_namespace_28.TwoLevelIterator.Prev ()
78281,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::SkipEmptyDataBlocksForward() {
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Next();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  }
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_30.TwoLevelIterator.SkipEmptyDataBlocksForward,,false,125,136,SkipEmptyDataBlocksForward,,,10,void leveldb.anonymous_namespace_30.TwoLevelIterator.SkipEmptyDataBlocksForward ()
78325,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::SkipEmptyDataBlocksBackward() {
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Prev();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  }
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_31.TwoLevelIterator.SkipEmptyDataBlocksBackward,,false,138,149,SkipEmptyDataBlocksBackward,,,11,void leveldb.anonymous_namespace_31.TwoLevelIterator.SkipEmptyDataBlocksBackward ()
78369,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::SetDataIterator(Iterator* data_iter) {
  if (data_iter_.iter() != NULL) SaveError(data_iter_.status());
  data_iter_.Set(data_iter);
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_32.TwoLevelIterator.SetDataIterator,,false,151,154,SetDataIterator,,,12,void leveldb.anonymous_namespace_32.TwoLevelIterator.SetDataIterator (Iterator*)
78392,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"void TwoLevelIterator::InitDataBlock() {
  if (!index_iter_.Valid()) {
    SetDataIterator(NULL);
  } else {
    Slice handle = index_iter_.value();
    if (data_iter_.iter() != NULL && handle.compare(data_block_handle_) == 0) {
      // data_iter_ is already constructed with this iterator, so
      // no need to change anything
    } else {
      Iterator* iter = (*block_function_)(arg_, options_, handle);
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }
}",1,1,table\two_level_iterator.cc,leveldb.anonymous_namespace_34.TwoLevelIterator.InitDataBlock,,false,156,170,InitDataBlock,,,13,void leveldb.anonymous_namespace_34.TwoLevelIterator.InitDataBlock ()
78454,METHOD,table\two_level_iterator.cc:<global>,TYPE_DECL,"Iterator* NewTwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions& options) {
  return new TwoLevelIterator(index_iter, block_function, arg, options);
}",1,1,table\two_level_iterator.cc,leveldb.NewTwoLevelIterator,,false,174,180,NewTwoLevelIterator,,,2,"Iterator leveldb.NewTwoLevelIterator (Iterator*,BlockFunction,void*,ReadOptions)"
78474,METHOD,table\two_level_iterator.hpp:<global>,TYPE_DECL,<global>,1,1,table\two_level_iterator.hpp,table\two_level_iterator.hpp:<global>,,false,1,34,<global>,,,1,
78478,METHOD,table\two_level_iterator.hpp:<global>,TYPE_DECL,"extern Iterator* NewTwoLevelIterator(
    Iterator* index_iter,
    Iterator* (*block_function)(
        void* arg,
        const ReadOptions& options,
        const Slice& index_value),
    void* arg,
    const ReadOptions& options);",16,31,table\two_level_iterator.hpp,leveldb.NewTwoLevelIterator,,false,23,30,NewTwoLevelIterator,,,2,"Iterator* leveldb.NewTwoLevelIterator (Iterator*,Iterator*,void*,ReadOptions)"
78493,METHOD,util\arena.cc:<global>,TYPE_DECL,<global>,1,1,util\arena.cc,util\arena.cc:<global>,,false,1,68,<global>,,,1,
78500,METHOD,util\arena.cc:<global>,TYPE_DECL,"Arena::Arena() : memory_usage_(0) {
  alloc_ptr_ = NULL;  // First allocation will allocate a block
  alloc_bytes_remaining_ = 0;
}",1,1,util\arena.cc,leveldb.Arena.Arena,,false,12,15,Arena,,,3,ANY leveldb.Arena.Arena ()
78510,METHOD,util\arena.cc:<global>,TYPE_DECL,"Arena::~Arena() {
  for (size_t i = 0; i < blocks_.size(); i++) {
    delete[] blocks_[i];
  }
}",1,1,util\arena.cc,leveldb.Arena.~Arena,,false,17,21,~Arena,,,4,ANY leveldb.Arena.~Arena ()
78533,METHOD,util\arena.cc:<global>,TYPE_DECL,"char* Arena::AllocateFallback(size_t bytes) {
  if (bytes > kBlockSize / 4) {
    // Object is more than a quarter of our block size.  Allocate it separately
    // to avoid wasting too much space in leftover bytes.
    char* result = AllocateNewBlock(bytes);
    return result;
  }

  // We waste the remaining space in the current block.
  alloc_ptr_ = AllocateNewBlock(kBlockSize);
  alloc_bytes_remaining_ = kBlockSize;

  char* result = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  return result;
}",1,1,util\arena.cc,leveldb.Arena.AllocateFallback,,false,23,39,AllocateFallback,,,5,char* leveldb.Arena.AllocateFallback (size_t)
78571,METHOD,util\arena.cc:<global>,TYPE_DECL,"char* Arena::AllocateAligned(size_t bytes) {
  const int align = (sizeof(void*) > 8) ? sizeof(void*) : 8;
  assert((align & (align-1)) == 0);   // Pointer size should be a power of 2
  size_t current_mod = reinterpret_cast<uintptr_t>(alloc_ptr_) & (align-1);
  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
  size_t needed = bytes + slop;
  char* result;
  if (needed <= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } else {
    // AllocateFallback always returned aligned memory
    result = AllocateFallback(bytes);
  }
  assert((reinterpret_cast<uintptr_t>(result) & (align-1)) == 0);
  return result;
}",1,1,util\arena.cc,leveldb.Arena.AllocateAligned,,false,41,58,AllocateAligned,,,6,char* leveldb.Arena.AllocateAligned (size_t)
78657,METHOD,util\arena.cc:<global>,TYPE_DECL,"char* Arena::AllocateNewBlock(size_t block_bytes) {
  char* result = new char[block_bytes];
  blocks_.push_back(result);
  memory_usage_.NoBarrier_Store(
      reinterpret_cast<void*>(MemoryUsage() + block_bytes + sizeof(char*)));
  return result;
}",1,1,util\arena.cc,leveldb.Arena.AllocateNewBlock,,false,60,66,AllocateNewBlock,,,7,char* leveldb.Arena.AllocateNewBlock (size_t)
78699,METHOD,util\arena.hpp:<global>,TYPE_DECL,<global>,1,22,util\arena.hpp,util\arena.hpp:<global>,,false,1,68,<global>,,,1,
78703,METHOD,leveldb.Arena,TYPE_DECL,Arena();,3,9,util\arena.hpp,leveldb.Arena.Arena,,false,18,18,Arena,,,1,ANY leveldb.Arena.Arena ()
78707,METHOD,leveldb.Arena,TYPE_DECL,~Arena();,3,10,util\arena.hpp,leveldb.Arena.~Arena,,false,19,19,~Arena,,,2,ANY leveldb.Arena.~Arena ()
78711,METHOD,leveldb.Arena,TYPE_DECL,char* Allocate(size_t bytes);,7,30,util\arena.hpp,leveldb.Arena.Allocate,,false,22,22,Allocate,,,3,char* leveldb.Arena.Allocate (size_t)
78716,METHOD,leveldb.Arena,TYPE_DECL,char* AllocateAligned(size_t bytes);,7,37,util\arena.hpp,leveldb.Arena.AllocateAligned,,false,25,25,AllocateAligned,,,4,char* leveldb.Arena.AllocateAligned (size_t)
78721,METHOD,leveldb.Arena,TYPE_DECL,"size_t MemoryUsage() const {
    return reinterpret_cast<uintptr_t>(memory_usage_.NoBarrier_Load());
  }",3,3,util\arena.hpp,leveldb.Arena.MemoryUsage,,false,29,31,MemoryUsage,,,5,size_t leveldb.Arena.MemoryUsage ()
78732,METHOD,leveldb.Arena,TYPE_DECL,char* AllocateFallback(size_t bytes);,7,38,util\arena.hpp,leveldb.Arena.AllocateFallback,,false,34,34,AllocateFallback,,,6,char* leveldb.Arena.AllocateFallback (size_t)
78737,METHOD,leveldb.Arena,TYPE_DECL,char* AllocateNewBlock(size_t block_bytes);,7,44,util\arena.hpp,leveldb.Arena.AllocateNewBlock,,false,35,35,AllocateNewBlock,,,7,char* leveldb.Arena.AllocateNewBlock (size_t)
78746,METHOD,leveldb.Arena,TYPE_DECL,Arena(const Arena&);,3,21,util\arena.hpp,leveldb.Arena.Arena,,false,48,48,Arena,,,12,ANY leveldb.Arena.Arena (Arena)
78751,METHOD,leveldb.Arena,TYPE_DECL,void operator=(const Arena&);,8,30,util\arena.hpp,leveldb.Arena.operator =,,false,49,49,operator =,,,13,void leveldb.Arena.operator = (Arena)
78756,METHOD,util\arena.hpp:<global>,TYPE_DECL,"inline char* Arena::Allocate(size_t bytes) {
  // The semantics of what to return are a bit messy if we allow
  // 0-byte allocations, so we disallow them here (we don't need
  // them for our internal use).
  assert(bytes > 0);
  if (bytes <= alloc_bytes_remaining_) {
    char* result = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    return result;
  }
  return AllocateFallback(bytes);
}",1,1,util\arena.hpp,leveldb.Arena.Allocate,,false,52,64,Allocate,,,2,char* leveldb.Arena.Allocate (size_t)
78794,METHOD,util\arena_test.cc:<global>,TYPE_DECL,<global>,1,1,util\arena_test.cc,util\arena_test.cc:<global>,,false,1,68,<global>,,,1,
78799,METHOD,leveldb._Test_Empty,TYPE_DECL,void void ();,1,22,util\arena_test.cc,leveldb._Test_Empty._Run,,false,14,14,_Run,,,1,void leveldb._Test_Empty._Run ()
78803,METHOD,leveldb._Test_Empty,TYPE_DECL,"TEST(ArenaTest, Empty)",1,22,util\arena_test.cc,leveldb._Test_Empty._RunIt,,false,14,14,_RunIt,,,2,void leveldb._Test_Empty._RunIt ()
78827,METHOD,util\arena_test.cc:<global>,TYPE_DECL,"TEST(ArenaTest, Empty) {
  Arena arena;
}",1,22,util\arena_test.cc,leveldb._Test_Empty._Run,,false,14,16,_Run,,,5,void leveldb._Test_Empty._Run ()
78833,METHOD,leveldb._Test_Simple,TYPE_DECL,void void ();,1,23,util\arena_test.cc,leveldb._Test_Simple._Run,,false,18,18,_Run,,,1,void leveldb._Test_Simple._Run ()
78837,METHOD,leveldb._Test_Simple,TYPE_DECL,"TEST(ArenaTest, Simple)",1,23,util\arena_test.cc,leveldb._Test_Simple._RunIt,,false,18,18,_RunIt,,,2,void leveldb._Test_Simple._RunIt ()
78861,METHOD,util\arena_test.cc:<global>,TYPE_DECL,"TEST(ArenaTest, Simple) {
  std::vector<std::pair<size_t, char*> > allocated;
  Arena arena;
  const int N = 100000;
  size_t bytes = 0;
  Random rnd(301);
  for (int i = 0; i < N; i++) {
    size_t s;
    if (i % (N / 10) == 0) {
      s = i;
    } else {
      s = rnd.OneIn(4000) ? rnd.Uniform(6000) :
          (rnd.OneIn(10) ? rnd.Uniform(100) : rnd.Uniform(20));
    }
    if (s == 0) {
      // Our arena disallows size 0 allocations.
      s = 1;
    }
    char* r;
    if (rnd.OneIn(10)) {
      r = arena.AllocateAligned(s);
    } else {
      r = arena.Allocate(s);
    }

    for (size_t b = 0; b < s; b++) {
      // Fill the ""i""th allocation with a known bit pattern
      r[b] = i % 256;
    }
    bytes += s;
    allocated.push_back(std::make_pair(s, r));
    ASSERT_GE(arena.MemoryUsage(), bytes);
    if (i > N/10) {
      ASSERT_LE(arena.MemoryUsage(), bytes * 1.10);
    }
  }
  for (size_t i = 0; i < allocated.size(); i++) {
    size_t num_bytes = allocated[i].first;
    con...",1,23,util\arena_test.cc,leveldb._Test_Simple._Run,,false,18,62,_Run,,,9,void leveldb._Test_Simple._Run ()
79126,METHOD,util\arena_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\arena_test.cc,main,,false,66,68,main,,,2,"int main (int,char**)"
79148,METHOD,util\bloom.cc:<global>,TYPE_DECL,<global>,1,1,util\bloom.cc,util\bloom.cc:<global>,,false,1,95,<global>,,,1,
79152,METHOD,util\bloom.cc:<global>,TYPE_DECL,"static uint32_t BloomHash(const Slice& key) {
  return Hash(key.data(), key.size(), 0xbc9f1d34);
}",1,1,util\bloom.cc,leveldb.anonymous_namespace_1.BloomHash,,false,13,15,BloomHash,,,1,uint32_t leveldb.anonymous_namespace_1.BloomHash (Slice)
79171,METHOD,leveldb.anonymous_namespace_2.BloomFilterPolicy,TYPE_DECL,"explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }",3,3,util\bloom.cc,leveldb.anonymous_namespace_3.BloomFilterPolicy.BloomFilterPolicy,,false,23,29,BloomFilterPolicy,,,3,ANY leveldb.anonymous_namespace_3.BloomFilterPolicy.BloomFilterPolicy (int)
79199,METHOD,leveldb.anonymous_namespace_2.BloomFilterPolicy,TYPE_DECL,"virtual const char* Name() const {
    return ""leveldb.BuiltinBloomFilter2"";
  }",3,3,util\bloom.cc,leveldb.anonymous_namespace_4.BloomFilterPolicy.Name,,false,31,33,Name,,,4,const char* leveldb.anonymous_namespace_4.BloomFilterPolicy.Name ()
79205,METHOD,leveldb.anonymous_namespace_2.BloomFilterPolicy,TYPE_DECL,"virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (int i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += d...",3,3,util\bloom.cc,leveldb.anonymous_namespace_5.BloomFilterPolicy.CreateFilter,,false,35,61,CreateFilter,,,5,"void leveldb.anonymous_namespace_5.BloomFilterPolicy.CreateFilter (Slice*,int,ANY*)"
79330,METHOD,leveldb.anonymous_namespace_2.BloomFilterPolicy,TYPE_DECL,"virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }
    return true;
  }",3,3,util\bloom.cc,leveldb.anonymous_namespace_7.BloomFilterPolicy.KeyMayMatch,,false,63,87,KeyMayMatch,,,6,"bool leveldb.anonymous_namespace_7.BloomFilterPolicy.KeyMayMatch (Slice,Slice)"
79435,METHOD,util\bloom.cc:<global>,TYPE_DECL,"const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) {
  return new BloomFilterPolicy(bits_per_key);
}",1,1,util\bloom.cc,leveldb.NewBloomFilterPolicy,,false,91,93,NewBloomFilterPolicy,,,2,FilterPolicy leveldb.NewBloomFilterPolicy (int)
79457,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,<global>,1,1,util\bloom_test.cc,util\bloom_test.cc:<global>,,false,1,162,<global>,,,1,
79464,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,"static Slice Key(int i, char* buffer) {
  EncodeFixed32(buffer, i);
  return Slice(buffer, sizeof(uint32_t));
}",1,1,util\bloom_test.cc,leveldb.Key,,false,16,19,Key,,,3,"Slice leveldb.Key (int,char*)"
79482,METHOD,leveldb.BloomTest,TYPE_DECL,BloomTest() : policy_(NewBloomFilterPolicy(10)) { },3,53,util\bloom_test.cc,leveldb.BloomTest.BloomTest,,false,28,28,BloomTest,,,4,ANY leveldb.BloomTest.BloomTest ()
79486,METHOD,leveldb.BloomTest,TYPE_DECL,"~BloomTest() {
    delete policy_;
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.~BloomTest,,false,30,32,~BloomTest,,,5,ANY leveldb.BloomTest.~BloomTest ()
79492,METHOD,leveldb.BloomTest,TYPE_DECL,"void Reset() {
    keys_.clear();
    filter_.clear();
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.Reset,,false,34,37,Reset,,,6,void leveldb.BloomTest.Reset ()
79504,METHOD,leveldb.BloomTest,TYPE_DECL,"void Add(const Slice& s) {
    keys_.push_back(s.ToString());
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.Add,,false,39,41,Add,,,7,void leveldb.BloomTest.Add (Slice)
79517,METHOD,leveldb.BloomTest,TYPE_DECL,"void Build() {
    std::vector<Slice> key_slices;
    for (size_t i = 0; i < keys_.size(); i++) {
      key_slices.push_back(Slice(keys_[i]));
    }
    filter_.clear();
    policy_->CreateFilter(&key_slices[0], static_cast<int>(key_slices.size()),
                          &filter_);
    keys_.clear();
    if (kVerbose >= 2) DumpFilter();
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.Build,,false,43,53,Build,,,8,void leveldb.BloomTest.Build ()
79575,METHOD,leveldb.BloomTest,TYPE_DECL,"size_t FilterSize() const {
    return filter_.size();
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.FilterSize,,false,55,57,FilterSize,,,9,size_t leveldb.BloomTest.FilterSize ()
79584,METHOD,leveldb.BloomTest,TYPE_DECL,"void DumpFilter() {
    fprintf(stderr, ""F("");
    for (size_t i = 0; i+1 < filter_.size(); i++) {
      const unsigned int c = static_cast<unsigned int>(filter_[i]);
      for (int j = 0; j < 8; j++) {
        fprintf(stderr, ""%c"", (c & (1 <<j)) ? '1' : '.');
      }
    }
    fprintf(stderr, "")\n"");
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.DumpFilter,,false,59,68,DumpFilter,,,10,void leveldb.BloomTest.DumpFilter ()
79642,METHOD,leveldb.BloomTest,TYPE_DECL,"bool Matches(const Slice& s) {
    if (!keys_.empty()) {
      Build();
    }
    return policy_->KeyMayMatch(s, filter_);
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.Matches,,false,70,75,Matches,,,11,bool leveldb.BloomTest.Matches (Slice)
79662,METHOD,leveldb.BloomTest,TYPE_DECL,"double FalsePositiveRate() {
    char buffer[sizeof(int)];
    int result = 0;
    for (int i = 0; i < 10000; i++) {
      if (Matches(Key(i + 1000000000, buffer))) {
        result++;
      }
    }
    return result / 10000.0;
  }",3,3,util\bloom_test.cc,leveldb.BloomTest.FalsePositiveRate,,false,77,86,FalsePositiveRate,,,12,double leveldb.BloomTest.FalsePositiveRate ()
79698,METHOD,leveldb._Test_EmptyFilter,TYPE_DECL,void void ();,1,28,util\bloom_test.cc,leveldb._Test_EmptyFilter._Run,,false,89,89,_Run,,,1,void leveldb._Test_EmptyFilter._Run ()
79702,METHOD,leveldb._Test_EmptyFilter,TYPE_DECL,"TEST(BloomTest, EmptyFilter)",1,28,util\bloom_test.cc,leveldb._Test_EmptyFilter._RunIt,,false,89,89,_RunIt,,,2,void leveldb._Test_EmptyFilter._RunIt ()
79726,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,"TEST(BloomTest, EmptyFilter) {
  ASSERT_TRUE(! Matches(""hello""));
  ASSERT_TRUE(! Matches(""world""));
}",1,28,util\bloom_test.cc,leveldb._Test_EmptyFilter._Run,,false,89,92,_Run,,,8,void leveldb._Test_EmptyFilter._Run ()
79771,METHOD,leveldb._Test_Small,TYPE_DECL,void void ();,1,22,util\bloom_test.cc,leveldb._Test_Small._Run,,false,94,94,_Run,,,1,void leveldb._Test_Small._Run ()
79775,METHOD,leveldb._Test_Small,TYPE_DECL,"TEST(BloomTest, Small)",1,22,util\bloom_test.cc,leveldb._Test_Small._RunIt,,false,94,94,_RunIt,,,2,void leveldb._Test_Small._RunIt ()
79799,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,"TEST(BloomTest, Small) {
  Add(""hello"");
  Add(""world"");
  ASSERT_TRUE(Matches(""hello""));
  ASSERT_TRUE(Matches(""world""));
  ASSERT_TRUE(! Matches(""x""));
  ASSERT_TRUE(! Matches(""foo""));
}",1,22,util\bloom_test.cc,leveldb._Test_Small._Run,,false,94,101,_Run,,,12,void leveldb._Test_Small._Run ()
79883,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,"static int NextLength(int length) {
  if (length < 10) {
    length += 1;
  } else if (length < 100) {
    length += 10;
  } else if (length < 1000) {
    length += 100;
  } else {
    length += 1000;
  }
  return length;
}",1,1,util\bloom_test.cc,leveldb.NextLength,,false,103,114,NextLength,,,13,int leveldb.NextLength (int)
79924,METHOD,leveldb._Test_VaryingLengths,TYPE_DECL,void void ();,1,31,util\bloom_test.cc,leveldb._Test_VaryingLengths._Run,,false,116,116,_Run,,,1,void leveldb._Test_VaryingLengths._Run ()
79928,METHOD,leveldb._Test_VaryingLengths,TYPE_DECL,"TEST(BloomTest, VaryingLengths)",1,31,util\bloom_test.cc,leveldb._Test_VaryingLengths._RunIt,,false,116,116,_RunIt,,,2,void leveldb._Test_VaryingLengths._RunIt ()
79952,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,"TEST(BloomTest, VaryingLengths) {
  char buffer[sizeof(int)];

  // Count number of filters that significantly exceed the false positive rate
  int mediocre_filters = 0;
  int good_filters = 0;

  for (int length = 1; length <= 10000; length = NextLength(length)) {
    Reset();
    for (int i = 0; i < length; i++) {
      Add(Key(i, buffer));
    }
    Build();

    ASSERT_LE(FilterSize(), static_cast<size_t>((length * 10 / 8) + 40))
        << length;

    // All added keys must match
    for (int i = 0; i < length; i++) {
      ASSERT_TRUE(Matches(Key(i, buffer)))
          << ""Length "" << length << ""; key "" << i;
    }

    // Check false positive rate
    double rate = FalsePositiveRate();
    if (kVerbose >= 1) {
      fprintf(stderr, ""False positives: %5.2f%% @ length = %6d ; bytes = %6d\n"",
              rate*100.0, length, static_cast<int>(FilterSize()));
    }
    ASSERT_LE(rate, 0.02);   // Must not be over 2%
    if (rate > 0.0125) mediocre_filters++;  // Allowed, but not...",1,31,util\bloom_test.cc,leveldb._Test_VaryingLengths._Run,,false,116,154,_Run,,,17,void leveldb._Test_VaryingLengths._Run ()
80136,METHOD,util\bloom_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\bloom_test.cc,main,,false,160,162,main,,,2,"int main (int,char**)"
80166,METHOD,util\cache.cc:<global>,TYPE_DECL,<global>,1,1,util\cache.cc,util\cache.cc:<global>,,false,1,405,<global>,,,1,
80169,METHOD,util\cache.cc:<global>,TYPE_DECL,"Cache::~Cache() {
}",1,1,util\cache.cc,leveldb.Cache.~Cache,,false,16,17,~Cache,,,1,ANY leveldb.Cache.~Cache ()
80176,METHOD,leveldb.anonymous_namespace_1.LRUHandle,TYPE_DECL,"void (*deleter)(const Slice&, void* value);",8,44,util\cache.cc,leveldb.anonymous_namespace_2.LRUHandle.deleter,,false,44,44,deleter,,,2,"void leveldb.anonymous_namespace_2.LRUHandle.deleter (Slice,void*)"
80191,METHOD,leveldb.anonymous_namespace_1.LRUHandle,TYPE_DECL,"Slice key() const {
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in ""value"".
    if (next == this) {
      return *(reinterpret_cast<Slice*>(value));
    } else {
      return Slice(key_data, key_length);
    }
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_3.LRUHandle.key,,false,55,63,key,,,12,Slice leveldb.anonymous_namespace_3.LRUHandle.key ()
80211,METHOD,<empty>,<empty>,<empty>,1,,util\cache.cc,leveldb.anonymous_namespace_1.LRUHandle:<clinit>,,false,42,,<clinit>,,,13,
80218,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,"HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }",3,66,util\cache.cc,leveldb.anonymous_namespace_5.HandleTable.HandleTable,,false,73,73,HandleTable,,,1,ANY leveldb.anonymous_namespace_5.HandleTable.HandleTable ()
80223,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,~HandleTable() { delete[] list_; },3,36,util\cache.cc,leveldb.anonymous_namespace_7.HandleTable.~HandleTable,,false,74,74,~HandleTable,,,2,ANY leveldb.anonymous_namespace_7.HandleTable.~HandleTable ()
80229,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,"LRUHandle* Lookup(const Slice& key, uint32_t hash) {
    return *FindPointer(key, hash);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_8.HandleTable.Lookup,,false,76,78,Lookup,,,3,"LRUHandle leveldb.anonymous_namespace_8.HandleTable.Lookup (Slice,uint32_t)"
80240,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,"LRUHandle* Insert(LRUHandle* h) {
    LRUHandle** ptr = FindPointer(h->key(), h->hash);
    LRUHandle* old = *ptr;
    h->next_hash = (old == NULL ? NULL : old->next_hash);
    *ptr = h;
    if (old == NULL) {
      ++elems_;
      if (elems_ > length_) {
        // Since each cache entry is fairly large, we aim for a small
        // average linked list length (<= 1).
        Resize();
      }
    }
    return old;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_10.HandleTable.Insert,,false,80,94,Insert,,,4,LRUHandle leveldb.anonymous_namespace_10.HandleTable.Insert (LRUHandle*)
80292,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,"LRUHandle* Remove(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = FindPointer(key, hash);
    LRUHandle* result = *ptr;
    if (result != NULL) {
      *ptr = result->next_hash;
      --elems_;
    }
    return result;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_13.HandleTable.Remove,,false,96,104,Remove,,,5,"LRUHandle leveldb.anonymous_namespace_13.HandleTable.Remove (Slice,uint32_t)"
80327,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,"LRUHandle** FindPointer(const Slice& key, uint32_t hash) {
    LRUHandle** ptr = &list_[hash & (length_ - 1)];
    while (*ptr != NULL &&
           ((*ptr)->hash != hash || key != (*ptr)->key())) {
      ptr = &(*ptr)->next_hash;
    }
    return ptr;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_15.HandleTable.FindPointer,,false,116,123,FindPointer,,,9,"LRUHandle leveldb.anonymous_namespace_15.HandleTable.FindPointer (Slice,uint32_t)"
80374,METHOD,leveldb.anonymous_namespace_4.HandleTable,TYPE_DECL,"void Resize() {
    uint32_t new_length = 4;
    while (new_length < elems_) {
      new_length *= 2;
    }
    LRUHandle** new_list = new LRUHandle*[new_length];
    memset(new_list, 0, sizeof(new_list[0]) * new_length);
    uint32_t count = 0;
    for (uint32_t i = 0; i < length_; i++) {
      LRUHandle* h = list_[i];
      while (h != NULL) {
        LRUHandle* next = h->next_hash;
        uint32_t hash = h->hash;
        LRUHandle** ptr = &new_list[hash & (new_length - 1)];
        h->next_hash = *ptr;
        *ptr = h;
        h = next;
        count++;
      }
    }
    assert(elems_ == count);
    delete[] list_;
    list_ = new_list;
    length_ = new_length;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_16.HandleTable.Resize,,false,125,149,Resize,,,10,void leveldb.anonymous_namespace_16.HandleTable.Resize ()
80482,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,LRUCache();,3,12,util\cache.cc,leveldb.anonymous_namespace_18.LRUCache.LRUCache,,false,155,155,LRUCache,,,1,ANY leveldb.anonymous_namespace_18.LRUCache.LRUCache ()
80486,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,~LRUCache();,3,13,util\cache.cc,leveldb.anonymous_namespace_19.LRUCache.~LRUCache,,false,156,156,~LRUCache,,,2,ANY leveldb.anonymous_namespace_19.LRUCache.~LRUCache ()
80490,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,void SetCapacity(size_t capacity) { capacity_ = capacity; },3,61,util\cache.cc,leveldb.anonymous_namespace_20.LRUCache.SetCapacity,,false,159,159,SetCapacity,,,3,void leveldb.anonymous_namespace_20.LRUCache.SetCapacity (size_t)
80498,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,"Cache::Handle* Insert(const Slice& key, uint32_t hash,
                        void* value, size_t charge,
                        void (*deleter)(const Slice& key, void* value));",16,71,util\cache.cc,leveldb.anonymous_namespace_21.LRUCache.Insert,,false,162,164,Insert,,,4,"ANY* leveldb.anonymous_namespace_21.LRUCache.Insert (Slice,uint32_t,void*,size_t,void)"
80507,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,"Cache::Handle* Lookup(const Slice& key, uint32_t hash);",16,56,util\cache.cc,leveldb.anonymous_namespace_22.LRUCache.Lookup,,false,165,165,Lookup,,,5,"ANY* leveldb.anonymous_namespace_22.LRUCache.Lookup (Slice,uint32_t)"
80513,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,void Release(Cache::Handle* handle);,8,37,util\cache.cc,leveldb.anonymous_namespace_23.LRUCache.Release,,false,166,166,Release,,,6,void leveldb.anonymous_namespace_23.LRUCache.Release (ANY*)
80518,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,"void Erase(const Slice& key, uint32_t hash);",8,45,util\cache.cc,leveldb.anonymous_namespace_24.LRUCache.Erase,,false,167,167,Erase,,,7,"void leveldb.anonymous_namespace_24.LRUCache.Erase (Slice,uint32_t)"
80524,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,void Prune();,8,14,util\cache.cc,leveldb.anonymous_namespace_25.LRUCache.Prune,,false,168,168,Prune,,,8,void leveldb.anonymous_namespace_25.LRUCache.Prune ()
80528,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,"size_t TotalCharge() const {
    MutexLock l(&mutex_);
    return usage_;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_26.LRUCache.TotalCharge,,false,169,172,TotalCharge,,,9,size_t leveldb.anonymous_namespace_26.LRUCache.TotalCharge ()
80538,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,void LRU_Remove(LRUHandle* e);,8,31,util\cache.cc,leveldb.anonymous_namespace_27.LRUCache.LRU_Remove,,false,175,175,LRU_Remove,,,10,void leveldb.anonymous_namespace_27.LRUCache.LRU_Remove (LRUHandle*)
80543,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,"void LRU_Append(LRUHandle*list, LRUHandle* e);",8,47,util\cache.cc,leveldb.anonymous_namespace_28.LRUCache.LRU_Append,,false,176,176,LRU_Append,,,11,"void leveldb.anonymous_namespace_28.LRUCache.LRU_Append (LRUHandle*,LRUHandle*)"
80549,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,void Ref(LRUHandle* e);,8,24,util\cache.cc,leveldb.anonymous_namespace_29.LRUCache.Ref,,false,177,177,Ref,,,12,void leveldb.anonymous_namespace_29.LRUCache.Ref (LRUHandle*)
80554,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,void Unref(LRUHandle* e);,8,26,util\cache.cc,leveldb.anonymous_namespace_30.LRUCache.Unref,,false,178,178,Unref,,,13,void leveldb.anonymous_namespace_30.LRUCache.Unref (LRUHandle*)
80559,METHOD,leveldb.anonymous_namespace_17.LRUCache,TYPE_DECL,bool FinishErase(LRUHandle* e);,8,32,util\cache.cc,leveldb.anonymous_namespace_31.LRUCache.FinishErase,,false,179,179,FinishErase,,,14,bool leveldb.anonymous_namespace_31.LRUCache.FinishErase (LRUHandle*)
80570,METHOD,util\cache.cc:<global>,TYPE_DECL,"LRUCache::LRUCache()
    : usage_(0) {
  // Make empty circular linked lists.
  lru_.next = &lru_;
  lru_.prev = &lru_;
  in_use_.next = &in_use_;
  in_use_.prev = &in_use_;
}",1,1,util\cache.cc,leveldb.anonymous_namespace_32.LRUCache.LRUCache,,false,200,207,LRUCache,,,4,ANY leveldb.anonymous_namespace_32.LRUCache.LRUCache ()
80598,METHOD,util\cache.cc:<global>,TYPE_DECL,"LRUCache::~LRUCache() {
  assert(in_use_.next == &in_use_);  // Error if caller has an unreleased handle
  for (LRUHandle* e = lru_.next; e != &lru_; ) {
    LRUHandle* next = e->next;
    assert(e->in_cache);
    e->in_cache = false;
    assert(e->refs == 1);  // Invariant of lru_ list.
    Unref(e);
    e = next;
  }
}",1,1,util\cache.cc,leveldb.anonymous_namespace_33.LRUCache.~LRUCache,,false,209,219,~LRUCache,,,5,ANY leveldb.anonymous_namespace_33.LRUCache.~LRUCache ()
80648,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::Ref(LRUHandle* e) {
  if (e->refs == 1 && e->in_cache) {  // If on lru_ list, move to in_use_ list.
    LRU_Remove(e);
    LRU_Append(&in_use_, e);
  }
  e->refs++;
}",1,1,util\cache.cc,leveldb.anonymous_namespace_35.LRUCache.Ref,,false,221,227,Ref,,,6,void leveldb.anonymous_namespace_35.LRUCache.Ref (LRUHandle*)
80674,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::Unref(LRUHandle* e) {
  assert(e->refs > 0);
  e->refs--;
  if (e->refs == 0) { // Deallocate.
    assert(!e->in_cache);
    (*e->deleter)(e->key(), e->value);
    free(e);
  } else if (e->in_cache && e->refs == 1) {  // No longer in use; move to lru_ list.
    LRU_Remove(e);
    LRU_Append(&lru_, e);
  }
}",1,1,util\cache.cc,leveldb.anonymous_namespace_36.LRUCache.Unref,,false,229,240,Unref,,,7,void leveldb.anonymous_namespace_36.LRUCache.Unref (LRUHandle*)
80734,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::LRU_Remove(LRUHandle* e) {
  e->next->prev = e->prev;
  e->prev->next = e->next;
}",1,1,util\cache.cc,leveldb.anonymous_namespace_37.LRUCache.LRU_Remove,,false,242,245,LRU_Remove,,,8,void leveldb.anonymous_namespace_37.LRUCache.LRU_Remove (LRUHandle*)
80757,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::LRU_Append(LRUHandle* list, LRUHandle* e) {
  // Make ""e"" newest entry by inserting just before *list
  e->next = list;
  e->prev = list->prev;
  e->prev->next = e;
  e->next->prev = e;
}",1,1,util\cache.cc,leveldb.anonymous_namespace_38.LRUCache.LRU_Append,,false,247,253,LRU_Append,,,9,"void leveldb.anonymous_namespace_38.LRUCache.LRU_Append (LRUHandle*,LRUHandle*)"
80789,METHOD,util\cache.cc:<global>,TYPE_DECL,"Cache::Handle* LRUCache::Lookup(const Slice& key, uint32_t hash) {
  MutexLock l(&mutex_);
  LRUHandle* e = table_.Lookup(key, hash);
  if (e != NULL) {
    Ref(e);
  }
  return reinterpret_cast<Cache::Handle*>(e);
}",1,1,util\cache.cc,leveldb.anonymous_namespace_39.LRUCache.Lookup,,false,255,262,Lookup,,,10,"Handle leveldb.anonymous_namespace_39.LRUCache.Lookup (Slice,uint32_t)"
80819,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::Release(Cache::Handle* handle) {
  MutexLock l(&mutex_);
  Unref(reinterpret_cast<LRUHandle*>(handle));
}",1,1,util\cache.cc,leveldb.anonymous_namespace_41.LRUCache.Release,,false,264,267,Release,,,11,void leveldb.anonymous_namespace_41.LRUCache.Release (ANY*)
80832,METHOD,util\cache.cc:<global>,TYPE_DECL,"Cache::Handle* LRUCache::Insert(
    const Slice& key, uint32_t hash, void* value, size_t charge,
    void (*deleter)(const Slice& key, void* value)) {
  MutexLock l(&mutex_);

  LRUHandle* e = reinterpret_cast<LRUHandle*>(
      malloc(sizeof(LRUHandle)-1 + key.size()));
  e->value = value;
  e->deleter = deleter;
  e->charge = charge;
  e->key_length = key.size();
  e->hash = hash;
  e->in_cache = false;
  e->refs = 1;  // for the returned handle.
  memcpy(e->key_data, key.data(), key.size());

  if (capacity_ > 0) {
    e->refs++;  // for the cache's reference.
    e->in_cache = true;
    LRU_Append(&in_use_, e);
    usage_ += charge;
    FinishErase(table_.Insert(e));
  } // else don't cache.  (Tests use capacity_==0 to turn off caching.)

  while (usage_ > capacity_ && lru_.next != &lru_) {
    LRUHandle* old = lru_.next;
    assert(old->refs == 1);
    bool erased = FinishErase(table_.Remove(old->key(), old->hash));
    if (!erased) {  // to avoid unused variable when compiled...",1,1,util\cache.cc,leveldb.anonymous_namespace_43.LRUCache.Insert,,false,269,303,Insert,,,12,"Handle leveldb.anonymous_namespace_43.LRUCache.Insert (Slice,uint32_t,void*,size_t,void)"
80986,METHOD,util\cache.cc:<global>,TYPE_DECL,"bool LRUCache::FinishErase(LRUHandle* e) {
  if (e != NULL) {
    assert(e->in_cache);
    LRU_Remove(e);
    e->in_cache = false;
    usage_ -= e->charge;
    Unref(e);
  }
  return e != NULL;
}",1,1,util\cache.cc,leveldb.anonymous_namespace_47.LRUCache.FinishErase,,false,307,316,FinishErase,,,13,bool leveldb.anonymous_namespace_47.LRUCache.FinishErase (LRUHandle*)
81018,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::Erase(const Slice& key, uint32_t hash) {
  MutexLock l(&mutex_);
  FinishErase(table_.Remove(key, hash));
}",1,1,util\cache.cc,leveldb.anonymous_namespace_50.LRUCache.Erase,,false,318,321,Erase,,,14,"void leveldb.anonymous_namespace_50.LRUCache.Erase (Slice,uint32_t)"
81035,METHOD,util\cache.cc:<global>,TYPE_DECL,"void LRUCache::Prune() {
  MutexLock l(&mutex_);
  while (lru_.next != &lru_) {
    LRUHandle* e = lru_.next;
    assert(e->refs == 1);
    bool erased = FinishErase(table_.Remove(e->key(), e->hash));
    if (!erased) {  // to avoid unused variable when compiled NDEBUG
      assert(erased);
    }
  }
}",1,1,util\cache.cc,leveldb.anonymous_namespace_52.LRUCache.Prune,,false,323,333,Prune,,,15,void leveldb.anonymous_namespace_52.LRUCache.Prune ()
81098,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"static inline uint32_t HashSlice(const Slice& s) {
    return Hash(s.data(), s.size(), 0);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_55.ShardedLRUCache.HashSlice,,false,344,346,HashSlice,,,4,uint32_t leveldb.anonymous_namespace_55.ShardedLRUCache.HashSlice (Slice)
81114,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"static uint32_t Shard(uint32_t hash) {
    return hash >> (32 - kNumShardBits);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_56.ShardedLRUCache.Shard,,false,348,350,Shard,,,5,uint32_t leveldb.anonymous_namespace_56.ShardedLRUCache.Shard (uint32_t)
81125,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"explicit ShardedLRUCache(size_t capacity)
      : last_id_(0) {
    const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].SetCapacity(per_shard);
    }
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_57.ShardedLRUCache.ShardedLRUCache,,false,353,359,ShardedLRUCache,,,6,ANY leveldb.anonymous_namespace_57.ShardedLRUCache.ShardedLRUCache (size_t)
81159,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,virtual ~ShardedLRUCache() { },3,32,util\cache.cc,leveldb.anonymous_namespace_58.ShardedLRUCache.~ShardedLRUCache,,false,360,360,~ShardedLRUCache,,,7,ANY leveldb.anonymous_namespace_58.ShardedLRUCache.~ShardedLRUCache ()
81163,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual Handle* Insert(const Slice& key, void* value, size_t charge,
                         void (*deleter)(const Slice& key, void* value)) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_59.ShardedLRUCache.Insert,,false,361,365,Insert,,,8,"Handle leveldb.anonymous_namespace_59.ShardedLRUCache.Insert (Slice,void*,size_t,void)"
81189,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual Handle* Lookup(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    return shard_[Shard(hash)].Lookup(key, hash);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_64.ShardedLRUCache.Lookup,,false,366,369,Lookup,,,9,Handle leveldb.anonymous_namespace_64.ShardedLRUCache.Lookup (Slice)
81209,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual void Release(Handle* handle) {
    LRUHandle* h = reinterpret_cast<LRUHandle*>(handle);
    shard_[Shard(h->hash)].Release(handle);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_69.ShardedLRUCache.Release,,false,370,373,Release,,,10,void leveldb.anonymous_namespace_69.ShardedLRUCache.Release (Handle*)
81230,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual void Erase(const Slice& key) {
    const uint32_t hash = HashSlice(key);
    shard_[Shard(hash)].Erase(key, hash);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_72.ShardedLRUCache.Erase,,false,374,377,Erase,,,11,void leveldb.anonymous_namespace_72.ShardedLRUCache.Erase (Slice)
81249,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual void* Value(Handle* handle) {
    return reinterpret_cast<LRUHandle*>(handle)->value;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_77.ShardedLRUCache.Value,,false,378,380,Value,,,12,void* leveldb.anonymous_namespace_77.ShardedLRUCache.Value (Handle*)
81260,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual uint64_t NewId() {
    MutexLock l(&id_mutex_);
    return ++(last_id_);
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_78.ShardedLRUCache.NewId,,false,381,384,NewId,,,13,uint64_t leveldb.anonymous_namespace_78.ShardedLRUCache.NewId ()
81271,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual void Prune() {
    for (int s = 0; s < kNumShards; s++) {
      shard_[s].Prune();
    }
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_79.ShardedLRUCache.Prune,,false,385,389,Prune,,,14,void leveldb.anonymous_namespace_79.ShardedLRUCache.Prune ()
81293,METHOD,leveldb.anonymous_namespace_54.ShardedLRUCache,TYPE_DECL,"virtual size_t TotalCharge() const {
    size_t total = 0;
    for (int s = 0; s < kNumShards; s++) {
      total += shard_[s].TotalCharge();
    }
    return total;
  }",3,3,util\cache.cc,leveldb.anonymous_namespace_80.ShardedLRUCache.TotalCharge,,false,390,396,TotalCharge,,,15,size_t leveldb.anonymous_namespace_80.ShardedLRUCache.TotalCharge ()
81323,METHOD,<empty>,<empty>,<empty>,1,,util\cache.cc,leveldb.anonymous_namespace_54.ShardedLRUCache:<clinit>,,false,338,,<clinit>,,,16,
81329,METHOD,util\cache.cc:<global>,TYPE_DECL,"Cache* NewLRUCache(size_t capacity) {
  return new ShardedLRUCache(capacity);
}",1,1,util\cache.cc,leveldb.NewLRUCache,,false,401,403,NewLRUCache,,,3,Cache leveldb.NewLRUCache (size_t)
81349,METHOD,util\cache_test.cc:<global>,TYPE_DECL,<global>,1,1,util\cache_test.cc,util\cache_test.cc:<global>,,false,1,226,<global>,,,1,
81352,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"static std::string EncodeKey(int k) {
  std::string result;
  PutFixed32(&result, k);
  return result;
}",1,1,util\cache_test.cc,leveldb.EncodeKey,,false,14,18,EncodeKey,,,1,string leveldb.EncodeKey (int)
81364,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"static int DecodeKey(const Slice& k) {
  assert(k.size() == 4);
  return DecodeFixed32(k.data());
}",1,1,util\cache_test.cc,leveldb.DecodeKey,,false,19,22,DecodeKey,,,2,int leveldb.DecodeKey (Slice)
81382,METHOD,util\cache_test.cc:<global>,TYPE_DECL,static void* EncodeValue(uintptr_t v) { return reinterpret_cast<void*>(v); },1,76,util\cache_test.cc,leveldb.EncodeValue,,false,23,23,EncodeValue,,,3,void* leveldb.EncodeValue (uintptr_t)
81391,METHOD,util\cache_test.cc:<global>,TYPE_DECL,static int DecodeValue(void* v) { return reinterpret_cast<uintptr_t>(v); },1,74,util\cache_test.cc,leveldb.DecodeValue,,false,24,24,DecodeValue,,,4,int leveldb.DecodeValue (void*)
81402,METHOD,leveldb.CacheTest,TYPE_DECL,"static void Deleter(const Slice& key, void* v) {
    current_->deleted_keys_.push_back(DecodeKey(key));
    current_->deleted_values_.push_back(DecodeValue(v));
  }",3,3,util\cache_test.cc,leveldb.CacheTest.Deleter,,false,30,33,Deleter,,,2,"void leveldb.CacheTest.Deleter (Slice,void*)"
81428,METHOD,leveldb.CacheTest,TYPE_DECL,"CacheTest() : cache_(NewLRUCache(kCacheSize)) {
    current_ = this;
  }",3,3,util\cache_test.cc,leveldb.CacheTest.CacheTest,,false,40,42,CacheTest,,,7,ANY leveldb.CacheTest.CacheTest ()
81435,METHOD,leveldb.CacheTest,TYPE_DECL,"~CacheTest() {
    delete cache_;
  }",3,3,util\cache_test.cc,leveldb.CacheTest.~CacheTest,,false,44,46,~CacheTest,,,8,ANY leveldb.CacheTest.~CacheTest ()
81441,METHOD,leveldb.CacheTest,TYPE_DECL,"int Lookup(int key) {
    Cache::Handle* handle = cache_->Lookup(EncodeKey(key));
    const int r = (handle == NULL) ? -1 : DecodeValue(cache_->Value(handle));
    if (handle != NULL) {
      cache_->Release(handle);
    }
    return r;
  }",3,3,util\cache_test.cc,leveldb.CacheTest.Lookup,,false,48,55,Lookup,,,9,int leveldb.CacheTest.Lookup (int)
81482,METHOD,leveldb.CacheTest,TYPE_DECL,"void Insert(int key, int value, int charge = 1) {
    cache_->Release(cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                                   &CacheTest::Deleter));
  }",3,3,util\cache_test.cc,leveldb.CacheTest.Insert,,false,57,60,Insert,,,10,"void leveldb.CacheTest.Insert (int,int,int)"
81506,METHOD,leveldb.CacheTest,TYPE_DECL,"Cache::Handle* InsertAndReturnHandle(int key, int value, int charge = 1) {
    return cache_->Insert(EncodeKey(key), EncodeValue(value), charge,
                          &CacheTest::Deleter);
  }",3,3,util\cache_test.cc,leveldb.CacheTest.InsertAndReturnHandle,,false,62,65,InsertAndReturnHandle,,,11,"Handle leveldb.CacheTest.InsertAndReturnHandle (int,int,int)"
81527,METHOD,leveldb.CacheTest,TYPE_DECL,"void Erase(int key) {
    cache_->Erase(EncodeKey(key));
  }",3,3,util\cache_test.cc,leveldb.CacheTest.Erase,,false,67,69,Erase,,,12,void leveldb.CacheTest.Erase (int)
81538,METHOD,<empty>,<empty>,<empty>,1,,util\cache_test.cc,leveldb.CacheTest:<clinit>,,false,26,,<clinit>,,,13,
81547,METHOD,leveldb._Test_HitAndMiss,TYPE_DECL,void void ();,1,27,util\cache_test.cc,leveldb._Test_HitAndMiss._Run,,false,73,73,_Run,,,1,void leveldb._Test_HitAndMiss._Run ()
81551,METHOD,leveldb._Test_HitAndMiss,TYPE_DECL,"TEST(CacheTest, HitAndMiss)",1,27,util\cache_test.cc,leveldb._Test_HitAndMiss._RunIt,,false,73,73,_RunIt,,,2,void leveldb._Test_HitAndMiss._RunIt ()
81575,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, HitAndMiss) {
  ASSERT_EQ(-1, Lookup(100));

  Insert(100, 101);
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(-1,  Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  Insert(200, 201);
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  Insert(100, 102);
  ASSERT_EQ(102, Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(-1,  Lookup(300));

  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);
}",1,27,util\cache_test.cc,leveldb._Test_HitAndMiss._Run,,false,73,94,_Run,,,10,void leveldb._Test_HitAndMiss._Run ()
81854,METHOD,leveldb._Test_Erase,TYPE_DECL,void void ();,1,22,util\cache_test.cc,leveldb._Test_Erase._Run,,false,96,96,_Run,,,1,void leveldb._Test_Erase._Run ()
81858,METHOD,leveldb._Test_Erase,TYPE_DECL,"TEST(CacheTest, Erase)",1,22,util\cache_test.cc,leveldb._Test_Erase._RunIt,,false,96,96,_RunIt,,,2,void leveldb._Test_Erase._RunIt ()
81882,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, Erase) {
  Erase(200);
  ASSERT_EQ(0, deleted_keys_.size());

  Insert(100, 101);
  Insert(200, 201);
  Erase(100);
  ASSERT_EQ(-1,  Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);

  Erase(100);
  ASSERT_EQ(-1,  Lookup(100));
  ASSERT_EQ(201, Lookup(200));
  ASSERT_EQ(1, deleted_keys_.size());
}",1,22,util\cache_test.cc,leveldb._Test_Erase._Run,,false,96,113,_Run,,,14,void leveldb._Test_Erase._Run ()
82090,METHOD,leveldb._Test_EntriesArePinned,TYPE_DECL,void void ();,1,33,util\cache_test.cc,leveldb._Test_EntriesArePinned._Run,,false,115,115,_Run,,,1,void leveldb._Test_EntriesArePinned._Run ()
82094,METHOD,leveldb._Test_EntriesArePinned,TYPE_DECL,"TEST(CacheTest, EntriesArePinned)",1,33,util\cache_test.cc,leveldb._Test_EntriesArePinned._RunIt,,false,115,115,_RunIt,,,2,void leveldb._Test_EntriesArePinned._RunIt ()
82118,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, EntriesArePinned) {
  Insert(100, 101);
  Cache::Handle* h1 = cache_->Lookup(EncodeKey(100));
  ASSERT_EQ(101, DecodeValue(cache_->Value(h1)));

  Insert(100, 102);
  Cache::Handle* h2 = cache_->Lookup(EncodeKey(100));
  ASSERT_EQ(102, DecodeValue(cache_->Value(h2)));
  ASSERT_EQ(0, deleted_keys_.size());

  cache_->Release(h1);
  ASSERT_EQ(1, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[0]);
  ASSERT_EQ(101, deleted_values_[0]);

  Erase(100);
  ASSERT_EQ(-1, Lookup(100));
  ASSERT_EQ(1, deleted_keys_.size());

  cache_->Release(h2);
  ASSERT_EQ(2, deleted_keys_.size());
  ASSERT_EQ(100, deleted_keys_[1]);
  ASSERT_EQ(102, deleted_values_[1]);
}",1,33,util\cache_test.cc,leveldb._Test_EntriesArePinned._Run,,false,115,138,_Run,,,18,void leveldb._Test_EntriesArePinned._Run ()
82410,METHOD,leveldb._Test_EvictionPolicy,TYPE_DECL,void void ();,1,31,util\cache_test.cc,leveldb._Test_EvictionPolicy._Run,,false,140,140,_Run,,,1,void leveldb._Test_EvictionPolicy._Run ()
82414,METHOD,leveldb._Test_EvictionPolicy,TYPE_DECL,"TEST(CacheTest, EvictionPolicy)",1,31,util\cache_test.cc,leveldb._Test_EvictionPolicy._RunIt,,false,140,140,_RunIt,,,2,void leveldb._Test_EvictionPolicy._RunIt ()
82438,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, EvictionPolicy) {
  Insert(100, 101);
  Insert(200, 201);
  Insert(300, 301);
  Cache::Handle* h = cache_->Lookup(EncodeKey(300));

  // Frequently used entry must be kept around,
  // as must things that are still in use.
  for (int i = 0; i < kCacheSize + 100; i++) {
    Insert(1000+i, 2000+i);
    ASSERT_EQ(2000+i, Lookup(1000+i));
    ASSERT_EQ(101, Lookup(100));
  }
  ASSERT_EQ(101, Lookup(100));
  ASSERT_EQ(-1, Lookup(200));
  ASSERT_EQ(301, Lookup(300));
  cache_->Release(h);
}",1,31,util\cache_test.cc,leveldb._Test_EvictionPolicy._Run,,false,140,157,_Run,,,22,void leveldb._Test_EvictionPolicy._Run ()
82585,METHOD,leveldb._Test_UseExceedsCacheSize,TYPE_DECL,void void ();,1,36,util\cache_test.cc,leveldb._Test_UseExceedsCacheSize._Run,,false,159,159,_Run,,,1,void leveldb._Test_UseExceedsCacheSize._Run ()
82589,METHOD,leveldb._Test_UseExceedsCacheSize,TYPE_DECL,"TEST(CacheTest, UseExceedsCacheSize)",1,36,util\cache_test.cc,leveldb._Test_UseExceedsCacheSize._RunIt,,false,159,159,_RunIt,,,2,void leveldb._Test_UseExceedsCacheSize._RunIt ()
82613,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, UseExceedsCacheSize) {
  // Overfill the cache, keeping handles on all inserted entries.
  std::vector<Cache::Handle*> h;
  for (int i = 0; i < kCacheSize + 100; i++) {
    h.push_back(InsertAndReturnHandle(1000+i, 2000+i));
  }

  // Check that all the entries can be found in the cache.
  for (int i = 0; i < h.size(); i++) {
    ASSERT_EQ(2000+i, Lookup(1000+i));
  }

  for (int i = 0; i < h.size(); i++) {
    cache_->Release(h[i]);
  }
}",1,36,util\cache_test.cc,leveldb._Test_UseExceedsCacheSize._Run,,false,159,174,_Run,,,26,void leveldb._Test_UseExceedsCacheSize._Run ()
82701,METHOD,leveldb._Test_HeavyEntries,TYPE_DECL,void void ();,1,29,util\cache_test.cc,leveldb._Test_HeavyEntries._Run,,false,176,176,_Run,,,1,void leveldb._Test_HeavyEntries._Run ()
82705,METHOD,leveldb._Test_HeavyEntries,TYPE_DECL,"TEST(CacheTest, HeavyEntries)",1,29,util\cache_test.cc,leveldb._Test_HeavyEntries._RunIt,,false,176,176,_RunIt,,,2,void leveldb._Test_HeavyEntries._RunIt ()
82729,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, HeavyEntries) {
  // Add a bunch of light and heavy entries and then count the combined
  // size of items still in the cache, which must be approximately the
  // same as the total capacity.
  const int kLight = 1;
  const int kHeavy = 10;
  int added = 0;
  int index = 0;
  while (added < 2*kCacheSize) {
    const int weight = (index & 1) ? kLight : kHeavy;
    Insert(index, 1000+index, weight);
    added += weight;
    index++;
  }

  int cached_weight = 0;
  for (int i = 0; i < index; i++) {
    const int weight = (i & 1 ? kLight : kHeavy);
    int r = Lookup(i);
    if (r >= 0) {
      cached_weight += weight;
      ASSERT_EQ(1000+i, r);
    }
  }
  ASSERT_LE(cached_weight, kCacheSize + kCacheSize/10);
}",1,29,util\cache_test.cc,leveldb._Test_HeavyEntries._Run,,false,176,201,_Run,,,30,void leveldb._Test_HeavyEntries._Run ()
82853,METHOD,leveldb._Test_NewId,TYPE_DECL,void void ();,1,22,util\cache_test.cc,leveldb._Test_NewId._Run,,false,203,203,_Run,,,1,void leveldb._Test_NewId._Run ()
82857,METHOD,leveldb._Test_NewId,TYPE_DECL,"TEST(CacheTest, NewId)",1,22,util\cache_test.cc,leveldb._Test_NewId._RunIt,,false,203,203,_RunIt,,,2,void leveldb._Test_NewId._RunIt ()
82881,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, NewId) {
  uint64_t a = cache_->NewId();
  uint64_t b = cache_->NewId();
  ASSERT_NE(a, b);
}",1,22,util\cache_test.cc,leveldb._Test_NewId._Run,,false,203,207,_Run,,,34,void leveldb._Test_NewId._Run ()
82917,METHOD,leveldb._Test_Prune,TYPE_DECL,void void ();,1,22,util\cache_test.cc,leveldb._Test_Prune._Run,,false,209,209,_Run,,,1,void leveldb._Test_Prune._Run ()
82921,METHOD,leveldb._Test_Prune,TYPE_DECL,"TEST(CacheTest, Prune)",1,22,util\cache_test.cc,leveldb._Test_Prune._RunIt,,false,209,209,_RunIt,,,2,void leveldb._Test_Prune._RunIt ()
82945,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"TEST(CacheTest, Prune) {
  Insert(1, 100);
  Insert(2, 200);

  Cache::Handle* handle = cache_->Lookup(EncodeKey(1));
  ASSERT_TRUE(handle);
  cache_->Prune();
  cache_->Release(handle);

  ASSERT_EQ(100, Lookup(1));
  ASSERT_EQ(-1, Lookup(2));
}",1,22,util\cache_test.cc,leveldb._Test_Prune._Run,,false,209,220,_Run,,,38,void leveldb._Test_Prune._Run ()
83029,METHOD,util\cache_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\cache_test.cc,main,,false,224,226,main,,,2,"int main (int,char**)"
83047,METHOD,util\coding.cc:<global>,TYPE_DECL,<global>,1,1,util\coding.cc,util\coding.cc:<global>,,false,1,194,<global>,,,1,
83050,METHOD,util\coding.cc:<global>,TYPE_DECL,"void EncodeFixed32(char* buf, uint32_t value) {
  if (port::kLittleEndian) {
    memcpy(buf, &value, sizeof(value));
  } else {
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
  }
}",1,1,util\coding.cc,leveldb.EncodeFixed32,,false,9,18,EncodeFixed32,,,1,"void leveldb.EncodeFixed32 (char*,uint32_t)"
83103,METHOD,util\coding.cc:<global>,TYPE_DECL,"void EncodeFixed64(char* buf, uint64_t value) {
  if (port::kLittleEndian) {
    memcpy(buf, &value, sizeof(value));
  } else {
    buf[0] = value & 0xff;
    buf[1] = (value >> 8) & 0xff;
    buf[2] = (value >> 16) & 0xff;
    buf[3] = (value >> 24) & 0xff;
    buf[4] = (value >> 32) & 0xff;
    buf[5] = (value >> 40) & 0xff;
    buf[6] = (value >> 48) & 0xff;
    buf[7] = (value >> 56) & 0xff;
  }
}",1,1,util\coding.cc,leveldb.EncodeFixed64,,false,20,33,EncodeFixed64,,,2,"void leveldb.EncodeFixed64 (char*,uint64_t)"
83192,METHOD,util\coding.cc:<global>,TYPE_DECL,"void PutFixed32(std::string* dst, uint32_t value) {
  char buf[sizeof(value)];
  EncodeFixed32(buf, value);
  dst->append(buf, sizeof(buf));
}",1,1,util\coding.cc,leveldb.PutFixed32,,false,35,39,PutFixed32,,,3,"void leveldb.PutFixed32 (ANY*,uint32_t)"
83209,METHOD,util\coding.cc:<global>,TYPE_DECL,"void PutFixed64(std::string* dst, uint64_t value) {
  char buf[sizeof(value)];
  EncodeFixed64(buf, value);
  dst->append(buf, sizeof(buf));
}",1,1,util\coding.cc,leveldb.PutFixed64,,false,41,45,PutFixed64,,,4,"void leveldb.PutFixed64 (ANY*,uint64_t)"
83226,METHOD,util\coding.cc:<global>,TYPE_DECL,"char* EncodeVarint32(char* dst, uint32_t v) {
  // Operate on characters as unsigneds
  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
  static const int B = 128;
  if (v < (1<<7)) {
    *(ptr++) = v;
  } else if (v < (1<<14)) {
    *(ptr++) = v | B;
    *(ptr++) = v>>7;
  } else if (v < (1<<21)) {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = v>>14;
  } else if (v < (1<<28)) {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = v>>21;
  } else {
    *(ptr++) = v | B;
    *(ptr++) = (v>>7) | B;
    *(ptr++) = (v>>14) | B;
    *(ptr++) = (v>>21) | B;
    *(ptr++) = v>>28;
  }
  return reinterpret_cast<char*>(ptr);
}",1,1,util\coding.cc,leveldb.EncodeVarint32,,false,47,73,EncodeVarint32,,,5,"char* leveldb.EncodeVarint32 (char*,uint32_t)"
83397,METHOD,util\coding.cc:<global>,TYPE_DECL,"void PutVarint32(std::string* dst, uint32_t v) {
  char buf[5];
  char* ptr = EncodeVarint32(buf, v);
  dst->append(buf, ptr - buf);
}",1,1,util\coding.cc,leveldb.PutVarint32,,false,75,79,PutVarint32,,,6,"void leveldb.PutVarint32 (ANY*,uint32_t)"
83418,METHOD,util\coding.cc:<global>,TYPE_DECL,"char* EncodeVarint64(char* dst, uint64_t v) {
  static const int B = 128;
  unsigned char* ptr = reinterpret_cast<unsigned char*>(dst);
  while (v >= B) {
    *(ptr++) = (v & (B-1)) | B;
    v >>= 7;
  }
  *(ptr++) = static_cast<unsigned char>(v);
  return reinterpret_cast<char*>(ptr);
}",1,1,util\coding.cc,leveldb.EncodeVarint64,,false,81,90,EncodeVarint64,,,7,"char* leveldb.EncodeVarint64 (char*,uint64_t)"
83464,METHOD,util\coding.cc:<global>,TYPE_DECL,"void PutVarint64(std::string* dst, uint64_t v) {
  char buf[10];
  char* ptr = EncodeVarint64(buf, v);
  dst->append(buf, ptr - buf);
}",1,1,util\coding.cc,leveldb.PutVarint64,,false,92,96,PutVarint64,,,8,"void leveldb.PutVarint64 (ANY*,uint64_t)"
83485,METHOD,util\coding.cc:<global>,TYPE_DECL,"void PutLengthPrefixedSlice(std::string* dst, const Slice& value) {
  PutVarint32(dst, value.size());
  dst->append(value.data(), value.size());
}",1,1,util\coding.cc,leveldb.PutLengthPrefixedSlice,,false,98,101,PutLengthPrefixedSlice,,,9,"void leveldb.PutLengthPrefixedSlice (ANY*,Slice)"
83509,METHOD,util\coding.cc:<global>,TYPE_DECL,"int VarintLength(uint64_t v) {
  int len = 1;
  while (v >= 128) {
    v >>= 7;
    len++;
  }
  return len;
}",1,1,util\coding.cc,leveldb.VarintLength,,false,103,110,VarintLength,,,10,int leveldb.VarintLength (uint64_t)
83530,METHOD,util\coding.cc:<global>,TYPE_DECL,"const char* GetVarint32PtrFallback(const char* p,
                                   const char* limit,
                                   uint32_t* value) {
  uint32_t result = 0;
  for (uint32_t shift = 0; shift <= 28 && p < limit; shift += 7) {
    uint32_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }
  return NULL;
}",1,1,util\coding.cc,leveldb.GetVarint32PtrFallback,,false,112,129,GetVarint32PtrFallback,,,11,"const char* leveldb.GetVarint32PtrFallback (char*,char*,uint32_t*)"
83596,METHOD,util\coding.cc:<global>,TYPE_DECL,"bool GetVarint32(Slice* input, uint32_t* value) {
  const char* p = input->data();
  const char* limit = p + input->size();
  const char* q = GetVarint32Ptr(p, limit, value);
  if (q == NULL) {
    return false;
  } else {
    *input = Slice(q, limit - q);
    return true;
  }
}",1,1,util\coding.cc,leveldb.GetVarint32,,false,131,141,GetVarint32,,,12,"bool leveldb.GetVarint32 (Slice*,uint32_t*)"
83644,METHOD,util\coding.cc:<global>,TYPE_DECL,"const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* value) {
  uint64_t result = 0;
  for (uint32_t shift = 0; shift <= 63 && p < limit; shift += 7) {
    uint64_t byte = *(reinterpret_cast<const unsigned char*>(p));
    p++;
    if (byte & 128) {
      // More bytes are present
      result |= ((byte & 127) << shift);
    } else {
      result |= (byte << shift);
      *value = result;
      return reinterpret_cast<const char*>(p);
    }
  }
  return NULL;
}",1,1,util\coding.cc,leveldb.GetVarint64Ptr,,false,143,158,GetVarint64Ptr,,,13,"const char* leveldb.GetVarint64Ptr (char*,char*,uint64_t*)"
83710,METHOD,util\coding.cc:<global>,TYPE_DECL,"bool GetVarint64(Slice* input, uint64_t* value) {
  const char* p = input->data();
  const char* limit = p + input->size();
  const char* q = GetVarint64Ptr(p, limit, value);
  if (q == NULL) {
    return false;
  } else {
    *input = Slice(q, limit - q);
    return true;
  }
}",1,1,util\coding.cc,leveldb.GetVarint64,,false,160,170,GetVarint64,,,14,"bool leveldb.GetVarint64 (Slice*,uint64_t*)"
83758,METHOD,util\coding.cc:<global>,TYPE_DECL,"const char* GetLengthPrefixedSlice(const char* p, const char* limit,
                                   Slice* result) {
  uint32_t len;
  p = GetVarint32Ptr(p, limit, &len);
  if (p == NULL) return NULL;
  if (p + len > limit) return NULL;
  *result = Slice(p, len);
  return p + len;
}",1,1,util\coding.cc,leveldb.GetLengthPrefixedSlice,,false,172,180,GetLengthPrefixedSlice,,,15,"const char* leveldb.GetLengthPrefixedSlice (char*,char*,Slice*)"
83799,METHOD,util\coding.cc:<global>,TYPE_DECL,"bool GetLengthPrefixedSlice(Slice* input, Slice* result) {
  uint32_t len;
  if (GetVarint32(input, &len) &&
      input->size() >= len) {
    *result = Slice(input->data(), len);
    input->remove_prefix(len);
    return true;
  } else {
    return false;
  }
}",1,1,util\coding.cc,leveldb.GetLengthPrefixedSlice,,false,182,192,GetLengthPrefixedSlice,,,16,"bool leveldb.GetLengthPrefixedSlice (Slice*,Slice*)"
83852,METHOD,util\coding.hpp:<global>,TYPE_DECL,<global>,1,18,util\coding.hpp,util\coding.hpp:<global>,,false,1,104,<global>,,,1,
83855,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void PutFixed32(std::string* dst, uint32_t value);",13,56,util\coding.hpp,leveldb.PutFixed32,,false,22,22,PutFixed32,,,1,"void leveldb.PutFixed32 (ANY*,uint32_t)"
83861,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void PutFixed64(std::string* dst, uint64_t value);",13,56,util\coding.hpp,leveldb.PutFixed64,,false,23,23,PutFixed64,,,2,"void leveldb.PutFixed64 (ANY*,uint64_t)"
83867,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void PutVarint32(std::string* dst, uint32_t value);",13,57,util\coding.hpp,leveldb.PutVarint32,,false,24,24,PutVarint32,,,3,"void leveldb.PutVarint32 (ANY*,uint32_t)"
83873,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void PutVarint64(std::string* dst, uint64_t value);",13,57,util\coding.hpp,leveldb.PutVarint64,,false,25,25,PutVarint64,,,4,"void leveldb.PutVarint64 (ANY*,uint64_t)"
83879,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void PutLengthPrefixedSlice(std::string* dst, const Slice& value);",13,72,util\coding.hpp,leveldb.PutLengthPrefixedSlice,,false,26,26,PutLengthPrefixedSlice,,,5,"void leveldb.PutLengthPrefixedSlice (ANY*,Slice)"
83885,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern bool GetVarint32(Slice* input, uint32_t* value);",13,54,util\coding.hpp,leveldb.GetVarint32,,false,30,30,GetVarint32,,,6,"bool leveldb.GetVarint32 (Slice*,uint32_t*)"
83891,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern bool GetVarint64(Slice* input, uint64_t* value);",13,54,util\coding.hpp,leveldb.GetVarint64,,false,31,31,GetVarint64,,,7,"bool leveldb.GetVarint64 (Slice*,uint64_t*)"
83897,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern bool GetLengthPrefixedSlice(Slice* input, Slice* result);",13,63,util\coding.hpp,leveldb.GetLengthPrefixedSlice,,false,32,32,GetLengthPrefixedSlice,,,8,"bool leveldb.GetLengthPrefixedSlice (Slice*,Slice*)"
83903,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern const char* GetVarint32Ptr(const char* p,const char* limit, uint32_t* v);",18,79,util\coding.hpp,leveldb.GetVarint32Ptr,,false,38,38,GetVarint32Ptr,,,9,"char* leveldb.GetVarint32Ptr (char*,char*,uint32_t*)"
83910,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern const char* GetVarint64Ptr(const char* p,const char* limit, uint64_t* v);",18,79,util\coding.hpp,leveldb.GetVarint64Ptr,,false,39,39,GetVarint64Ptr,,,10,"char* leveldb.GetVarint64Ptr (char*,char*,uint64_t*)"
83917,METHOD,util\coding.hpp:<global>,TYPE_DECL,extern int VarintLength(uint64_t v);,12,35,util\coding.hpp,leveldb.VarintLength,,false,42,42,VarintLength,,,11,int leveldb.VarintLength (uint64_t)
83922,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void EncodeFixed32(char* dst, uint32_t value);",13,52,util\coding.hpp,leveldb.EncodeFixed32,,false,46,46,EncodeFixed32,,,12,"void leveldb.EncodeFixed32 (char*,uint32_t)"
83928,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern void EncodeFixed64(char* dst, uint64_t value);",13,52,util\coding.hpp,leveldb.EncodeFixed64,,false,47,47,EncodeFixed64,,,13,"void leveldb.EncodeFixed64 (char*,uint64_t)"
83934,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern char* EncodeVarint32(char* dst, uint32_t value);",12,54,util\coding.hpp,leveldb.EncodeVarint32,,false,52,52,EncodeVarint32,,,14,"char* leveldb.EncodeVarint32 (char*,uint32_t)"
83940,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern char* EncodeVarint64(char* dst, uint64_t value);",12,54,util\coding.hpp,leveldb.EncodeVarint64,,false,53,53,EncodeVarint64,,,15,"char* leveldb.EncodeVarint64 (char*,uint64_t)"
83946,METHOD,util\coding.hpp:<global>,TYPE_DECL,"inline uint32_t DecodeFixed32(const char* ptr) {
  if (port::kLittleEndian) {
    // Load the raw bytes
    uint32_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  } else {
    return ((static_cast<uint32_t>(static_cast<unsigned char>(ptr[0])))
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[1])) << 8)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[2])) << 16)
        | (static_cast<uint32_t>(static_cast<unsigned char>(ptr[3])) << 24));
  }
}",1,1,util\coding.hpp,leveldb.DecodeFixed32,,false,58,70,DecodeFixed32,,,16,uint32_t leveldb.DecodeFixed32 (char*)
84005,METHOD,util\coding.hpp:<global>,TYPE_DECL,"inline uint64_t DecodeFixed64(const char* ptr) {
  if (port::kLittleEndian) {
    // Load the raw bytes
    uint64_t result;
    memcpy(&result, ptr, sizeof(result));  // gcc optimizes this to a plain load
    return result;
  } else {
    uint64_t lo = DecodeFixed32(ptr);
    uint64_t hi = DecodeFixed32(ptr + 4);
    return (hi << 32) | lo;
  }
}",1,1,util\coding.hpp,leveldb.DecodeFixed64,,false,72,83,DecodeFixed64,,,17,uint64_t leveldb.DecodeFixed64 (char*)
84044,METHOD,util\coding.hpp:<global>,TYPE_DECL,"extern const char* GetVarint32PtrFallback(const char* p,
                                          const char* limit,
                                          uint32_t* value);",18,58,util\coding.hpp,leveldb.GetVarint32PtrFallback,,false,86,88,GetVarint32PtrFallback,,,18,"char* leveldb.GetVarint32PtrFallback (char*,char*,uint32_t*)"
84051,METHOD,util\coding.hpp:<global>,TYPE_DECL,"inline const char* GetVarint32Ptr(const char* p,
                                  const char* limit,
                                  uint32_t* value) {
  if (p < limit) {
    uint32_t result = *(reinterpret_cast<const unsigned char*>(p));
    if ((result & 128) == 0) {
      *value = result;
      return p + 1;
    }
  }
  return GetVarint32PtrFallback(p, limit, value);
}",1,1,util\coding.hpp,leveldb.GetVarint32Ptr,,false,89,100,GetVarint32Ptr,,,19,"const char* leveldb.GetVarint32Ptr (char*,char*,uint32_t*)"
84097,METHOD,util\coding_test.cc:<global>,TYPE_DECL,<global>,1,1,util\coding_test.cc,util\coding_test.cc:<global>,,false,1,196,<global>,,,1,
84102,METHOD,leveldb._Test_Fixed32,TYPE_DECL,void void ();,1,21,util\coding_test.cc,leveldb._Test_Fixed32._Run,,false,13,13,_Run,,,1,void leveldb._Test_Fixed32._Run ()
84106,METHOD,leveldb._Test_Fixed32,TYPE_DECL,"TEST(Coding, Fixed32)",1,21,util\coding_test.cc,leveldb._Test_Fixed32._RunIt,,false,13,13,_RunIt,,,2,void leveldb._Test_Fixed32._RunIt ()
84130,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Fixed32) {
  std::string s;
  for (uint32_t v = 0; v < 100000; v++) {
    PutFixed32(&s, v);
  }

  const char* p = s.data();
  for (uint32_t v = 0; v < 100000; v++) {
    uint32_t actual = DecodeFixed32(p);
    ASSERT_EQ(v, actual);
    p += sizeof(uint32_t);
  }
}",1,21,util\coding_test.cc,leveldb._Test_Fixed32._Run,,false,13,25,_Run,,,5,void leveldb._Test_Fixed32._Run ()
84197,METHOD,leveldb._Test_Fixed64,TYPE_DECL,void void ();,1,21,util\coding_test.cc,leveldb._Test_Fixed64._Run,,false,27,27,_Run,,,1,void leveldb._Test_Fixed64._Run ()
84201,METHOD,leveldb._Test_Fixed64,TYPE_DECL,"TEST(Coding, Fixed64)",1,21,util\coding_test.cc,leveldb._Test_Fixed64._RunIt,,false,27,27,_RunIt,,,2,void leveldb._Test_Fixed64._RunIt ()
84225,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Fixed64) {
  std::string s;
  for (int power = 0; power <= 63; power++) {
    uint64_t v = static_cast<uint64_t>(1) << power;
    PutFixed64(&s, v - 1);
    PutFixed64(&s, v + 0);
    PutFixed64(&s, v + 1);
  }

  const char* p = s.data();
  for (int power = 0; power <= 63; power++) {
    uint64_t v = static_cast<uint64_t>(1) << power;
    uint64_t actual;
    actual = DecodeFixed64(p);
    ASSERT_EQ(v-1, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+0, actual);
    p += sizeof(uint64_t);

    actual = DecodeFixed64(p);
    ASSERT_EQ(v+1, actual);
    p += sizeof(uint64_t);
  }
}",1,21,util\coding_test.cc,leveldb._Test_Fixed64._Run,,false,27,52,_Run,,,9,void leveldb._Test_Fixed64._Run ()
84375,METHOD,leveldb._Test_EncodingOutput,TYPE_DECL,void void ();,1,28,util\coding_test.cc,leveldb._Test_EncodingOutput._Run,,false,55,55,_Run,,,1,void leveldb._Test_EncodingOutput._Run ()
84379,METHOD,leveldb._Test_EncodingOutput,TYPE_DECL,"TEST(Coding, EncodingOutput)",1,28,util\coding_test.cc,leveldb._Test_EncodingOutput._RunIt,,false,55,55,_RunIt,,,2,void leveldb._Test_EncodingOutput._RunIt ()
84403,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, EncodingOutput) {
  std::string dst;
  PutFixed32(&dst, 0x04030201);
  ASSERT_EQ(4, dst.size());
  ASSERT_EQ(0x01, static_cast<int>(dst[0]));
  ASSERT_EQ(0x02, static_cast<int>(dst[1]));
  ASSERT_EQ(0x03, static_cast<int>(dst[2]));
  ASSERT_EQ(0x04, static_cast<int>(dst[3]));

  dst.clear();
  PutFixed64(&dst, 0x0807060504030201ull);
  ASSERT_EQ(8, dst.size());
  ASSERT_EQ(0x01, static_cast<int>(dst[0]));
  ASSERT_EQ(0x02, static_cast<int>(dst[1]));
  ASSERT_EQ(0x03, static_cast<int>(dst[2]));
  ASSERT_EQ(0x04, static_cast<int>(dst[3]));
  ASSERT_EQ(0x05, static_cast<int>(dst[4]));
  ASSERT_EQ(0x06, static_cast<int>(dst[5]));
  ASSERT_EQ(0x07, static_cast<int>(dst[6]));
  ASSERT_EQ(0x08, static_cast<int>(dst[7]));
}",1,28,util\coding_test.cc,leveldb._Test_EncodingOutput._Run,,false,55,75,_Run,,,13,void leveldb._Test_EncodingOutput._Run ()
84767,METHOD,leveldb._Test_Varint32,TYPE_DECL,void void ();,1,22,util\coding_test.cc,leveldb._Test_Varint32._Run,,false,77,77,_Run,,,1,void leveldb._Test_Varint32._Run ()
84771,METHOD,leveldb._Test_Varint32,TYPE_DECL,"TEST(Coding, Varint32)",1,22,util\coding_test.cc,leveldb._Test_Varint32._RunIt,,false,77,77,_RunIt,,,2,void leveldb._Test_Varint32._RunIt ()
84795,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Varint32) {
  std::string s;
  for (uint32_t i = 0; i < (32 * 32); i++) {
    uint32_t v = (i / 32) << (i % 32);
    PutVarint32(&s, v);
  }

  const char* p = s.data();
  const char* limit = p + s.size();
  for (uint32_t i = 0; i < (32 * 32); i++) {
    uint32_t expected = (i / 32) << (i % 32);
    uint32_t actual;
    const char* start = p;
    p = GetVarint32Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(expected, actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }
  ASSERT_EQ(p, s.data() + s.size());
}",1,22,util\coding_test.cc,leveldb._Test_Varint32._Run,,false,77,96,_Run,,,17,void leveldb._Test_Varint32._Run ()
84959,METHOD,leveldb._Test_Varint64,TYPE_DECL,void void ();,1,22,util\coding_test.cc,leveldb._Test_Varint64._Run,,false,98,98,_Run,,,1,void leveldb._Test_Varint64._Run ()
84963,METHOD,leveldb._Test_Varint64,TYPE_DECL,"TEST(Coding, Varint64)",1,22,util\coding_test.cc,leveldb._Test_Varint64._RunIt,,false,98,98,_RunIt,,,2,void leveldb._Test_Varint64._RunIt ()
84987,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Varint64) {
  // Construct the list of values to check
  std::vector<uint64_t> values;
  // Some special values
  values.push_back(0);
  values.push_back(100);
  values.push_back(~static_cast<uint64_t>(0));
  values.push_back(~static_cast<uint64_t>(0) - 1);
  for (uint32_t k = 0; k < 64; k++) {
    // Test values near powers of two
    const uint64_t power = 1ull << k;
    values.push_back(power);
    values.push_back(power-1);
    values.push_back(power+1);
  }

  std::string s;
  for (size_t i = 0; i < values.size(); i++) {
    PutVarint64(&s, values[i]);
  }

  const char* p = s.data();
  const char* limit = p + s.size();
  for (size_t i = 0; i < values.size(); i++) {
    ASSERT_TRUE(p < limit);
    uint64_t actual;
    const char* start = p;
    p = GetVarint64Ptr(p, limit, &actual);
    ASSERT_TRUE(p != NULL);
    ASSERT_EQ(values[i], actual);
    ASSERT_EQ(VarintLength(actual), p - start);
  }
  ASSERT_EQ(p, limit);

}",1,22,util\coding_test.cc,leveldb._Test_Varint64._Run,,false,98,132,_Run,,,21,void leveldb._Test_Varint64._Run ()
85221,METHOD,leveldb._Test_Varint32Overflow,TYPE_DECL,void void ();,1,30,util\coding_test.cc,leveldb._Test_Varint32Overflow._Run,,false,134,134,_Run,,,1,void leveldb._Test_Varint32Overflow._Run ()
85225,METHOD,leveldb._Test_Varint32Overflow,TYPE_DECL,"TEST(Coding, Varint32Overflow)",1,30,util\coding_test.cc,leveldb._Test_Varint32Overflow._RunIt,,false,134,134,_RunIt,,,2,void leveldb._Test_Varint32Overflow._RunIt ()
85249,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Varint32Overflow) {
  uint32_t result;
  std::string input(""\x81\x82\x83\x84\x85\x11"");
  ASSERT_TRUE(GetVarint32Ptr(input.data(), input.data() + input.size(), &result)
              == NULL);
}",1,30,util\coding_test.cc,leveldb._Test_Varint32Overflow._Run,,false,134,139,_Run,,,25,void leveldb._Test_Varint32Overflow._Run ()
85290,METHOD,leveldb._Test_Varint32Truncation,TYPE_DECL,void void ();,1,32,util\coding_test.cc,leveldb._Test_Varint32Truncation._Run,,false,141,141,_Run,,,1,void leveldb._Test_Varint32Truncation._Run ()
85294,METHOD,leveldb._Test_Varint32Truncation,TYPE_DECL,"TEST(Coding, Varint32Truncation)",1,32,util\coding_test.cc,leveldb._Test_Varint32Truncation._RunIt,,false,141,141,_RunIt,,,2,void leveldb._Test_Varint32Truncation._RunIt ()
85318,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Varint32Truncation) {
  uint32_t large_value = (1u << 31) + 100;
  std::string s;
  PutVarint32(&s, large_value);
  uint32_t result;
  for (size_t len = 0; len < s.size() - 1; len++) {
    ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == NULL);
  }
  ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + s.size(), &result) != NULL);
  ASSERT_EQ(large_value, result);
}",1,32,util\coding_test.cc,leveldb._Test_Varint32Truncation._Run,,false,141,151,_Run,,,29,void leveldb._Test_Varint32Truncation._Run ()
85432,METHOD,leveldb._Test_Varint64Overflow,TYPE_DECL,void void ();,1,30,util\coding_test.cc,leveldb._Test_Varint64Overflow._Run,,false,153,153,_Run,,,1,void leveldb._Test_Varint64Overflow._Run ()
85436,METHOD,leveldb._Test_Varint64Overflow,TYPE_DECL,"TEST(Coding, Varint64Overflow)",1,30,util\coding_test.cc,leveldb._Test_Varint64Overflow._RunIt,,false,153,153,_RunIt,,,2,void leveldb._Test_Varint64Overflow._RunIt ()
85460,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Varint64Overflow) {
  uint64_t result;
  std::string input(""\x81\x82\x83\x84\x85\x81\x82\x83\x84\x85\x11"");
  ASSERT_TRUE(GetVarint64Ptr(input.data(), input.data() + input.size(), &result)
              == NULL);
}",1,30,util\coding_test.cc,leveldb._Test_Varint64Overflow._Run,,false,153,158,_Run,,,33,void leveldb._Test_Varint64Overflow._Run ()
85501,METHOD,leveldb._Test_Varint64Truncation,TYPE_DECL,void void ();,1,32,util\coding_test.cc,leveldb._Test_Varint64Truncation._Run,,false,160,160,_Run,,,1,void leveldb._Test_Varint64Truncation._Run ()
85505,METHOD,leveldb._Test_Varint64Truncation,TYPE_DECL,"TEST(Coding, Varint64Truncation)",1,32,util\coding_test.cc,leveldb._Test_Varint64Truncation._RunIt,,false,160,160,_RunIt,,,2,void leveldb._Test_Varint64Truncation._RunIt ()
85529,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Varint64Truncation) {
  uint64_t large_value = (1ull << 63) + 100ull;
  std::string s;
  PutVarint64(&s, large_value);
  uint64_t result;
  for (size_t len = 0; len < s.size() - 1; len++) {
    ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == NULL);
  }
  ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + s.size(), &result) != NULL);
  ASSERT_EQ(large_value, result);
}",1,32,util\coding_test.cc,leveldb._Test_Varint64Truncation._Run,,false,160,170,_Run,,,37,void leveldb._Test_Varint64Truncation._Run ()
85643,METHOD,leveldb._Test_Strings,TYPE_DECL,void void ();,1,21,util\coding_test.cc,leveldb._Test_Strings._Run,,false,172,172,_Run,,,1,void leveldb._Test_Strings._Run ()
85647,METHOD,leveldb._Test_Strings,TYPE_DECL,"TEST(Coding, Strings)",1,21,util\coding_test.cc,leveldb._Test_Strings._RunIt,,false,172,172,_RunIt,,,2,void leveldb._Test_Strings._RunIt ()
85671,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"TEST(Coding, Strings) {
  std::string s;
  PutLengthPrefixedSlice(&s, Slice(""""));
  PutLengthPrefixedSlice(&s, Slice(""foo""));
  PutLengthPrefixedSlice(&s, Slice(""bar""));
  PutLengthPrefixedSlice(&s, Slice(std::string(200, 'x')));

  Slice input(s);
  Slice v;
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ("""", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(""foo"", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(""bar"", v.ToString());
  ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v));
  ASSERT_EQ(std::string(200, 'x'), v.ToString());
  ASSERT_EQ("""", input.ToString());
}",1,21,util\coding_test.cc,leveldb._Test_Strings._Run,,false,172,190,_Run,,,41,void leveldb._Test_Strings._Run ()
85900,METHOD,util\coding_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\coding_test.cc,main,,false,194,196,main,,,2,"int main (int,char**)"
85928,METHOD,util\comparator.cc:<global>,TYPE_DECL,<global>,1,22,util\comparator.cc,util\comparator.cc:<global>,,false,1,81,<global>,,,1,
85931,METHOD,util\comparator.cc:<global>,TYPE_DECL,Comparator::~Comparator() { },1,29,util\comparator.cc,leveldb.Comparator.~Comparator,,false,14,14,~Comparator,,,1,ANY leveldb.Comparator.~Comparator ()
85937,METHOD,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,TYPE_DECL,BytewiseComparatorImpl() { },3,30,util\comparator.cc,leveldb.anonymous_namespace_2.BytewiseComparatorImpl.BytewiseComparatorImpl,,false,19,19,BytewiseComparatorImpl,,,1,ANY leveldb.anonymous_namespace_2.BytewiseComparatorImpl.BytewiseComparatorImpl ()
85941,METHOD,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,TYPE_DECL,"virtual const char* Name() const {
    return ""leveldb.BytewiseComparator"";
  }",3,3,util\comparator.cc,leveldb.anonymous_namespace_3.BytewiseComparatorImpl.Name,,false,21,23,Name,,,2,const char* leveldb.anonymous_namespace_3.BytewiseComparatorImpl.Name ()
85947,METHOD,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,TYPE_DECL,"virtual int Compare(const Slice& a, const Slice& b) const {
    return a.compare(b);
  }",3,3,util\comparator.cc,leveldb.anonymous_namespace_4.BytewiseComparatorImpl.Compare,,false,25,27,Compare,,,3,"int leveldb.anonymous_namespace_4.BytewiseComparatorImpl.Compare (Slice,Slice)"
85959,METHOD,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,TYPE_DECL,"virtual void FindShortestSeparator(
      std::string* start,
      const Slice& limit) const {
    // Find length of common prefix
    size_t min_length = std::min(start->size(), limit.size());
    size_t diff_index = 0;
    while ((diff_index < min_length) &&
           ((*start)[diff_index] == limit[diff_index])) {
      diff_index++;
    }

    if (diff_index >= min_length) {
      // Do not shorten if one string is a prefix of the other
    } else {
      uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);
      if (diff_byte < static_cast<uint8_t>(0xff) &&
          diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {
        (*start)[diff_index]++;
        start->resize(diff_index + 1);
        assert(Compare(*start, limit) < 0);
      }
    }
  }",3,3,util\comparator.cc,leveldb.anonymous_namespace_5.BytewiseComparatorImpl.FindShortestSeparator,,false,29,51,FindShortestSeparator,,,4,"void leveldb.anonymous_namespace_5.BytewiseComparatorImpl.FindShortestSeparator (ANY*,Slice)"
86052,METHOD,leveldb.anonymous_namespace_1.BytewiseComparatorImpl,TYPE_DECL,"virtual void FindShortSuccessor(std::string* key) const {
    // Find first character that can be incremented
    size_t n = key->size();
    for (size_t i = 0; i < n; i++) {
      const uint8_t byte = (*key)[i];
      if (byte != static_cast<uint8_t>(0xff)) {
        (*key)[i] = byte + 1;
        key->resize(i+1);
        return;
      }
    }
    // *key is a run of 0xffs.  Leave it alone.
  }",3,3,util\comparator.cc,leveldb.anonymous_namespace_7.BytewiseComparatorImpl.FindShortSuccessor,,false,53,65,FindShortSuccessor,,,5,void leveldb.anonymous_namespace_7.BytewiseComparatorImpl.FindShortSuccessor (ANY*)
86111,METHOD,util\comparator.cc:<global>,TYPE_DECL,"static void InitModule() {
  bytewise = new BytewiseComparatorImpl;
}",1,1,util\comparator.cc,leveldb.InitModule,,false,72,74,InitModule,,,6,void leveldb.InitModule ()
86119,METHOD,util\comparator.cc:<global>,TYPE_DECL,"const Comparator* BytewiseComparator() {
  port::InitOnce(&once, InitModule);
  return bytewise;
}",1,1,util\comparator.cc,leveldb.BytewiseComparator,,false,76,79,BytewiseComparator,,,7,Comparator leveldb.BytewiseComparator ()
86143,METHOD,util\crc32c.cc:<global>,TYPE_DECL,<global>,1,1,util\crc32c.cc,util\crc32c.cc:<global>,,false,1,350,<global>,,,1,
87187,METHOD,util\crc32c.cc:<global>,TYPE_DECL,"static inline uint32_t LE_LOAD32(const uint8_t *p) {
  return DecodeFixed32(reinterpret_cast<const char*>(p));
}",1,1,util\crc32c.cc,leveldb.crc32c.LE_LOAD32,,false,284,286,LE_LOAD32,,,9,uint32_t leveldb.crc32c.LE_LOAD32 (uint8_t*)
87197,METHOD,util\crc32c.cc:<global>,TYPE_DECL,"static bool CanAccelerateCRC32C() {
  // port::AcceleretedCRC32C returns zero when unable to accelerate.
  static const char kTestCRCBuffer[] = ""TestCRCBuffer"";
  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;
  static const uint32_t kTestCRCValue = 0xdcbc59fa;

  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;
}",1,1,util\crc32c.cc,leveldb.crc32c.CanAccelerateCRC32C,,false,290,297,CanAccelerateCRC32C,,,10,bool leveldb.crc32c.CanAccelerateCRC32C ()
87226,METHOD,util\crc32c.cc:<global>,TYPE_DECL,"uint32_t Extend(uint32_t crc, const char* buf, size_t size) {
  static bool accelerate = CanAccelerateCRC32C();
  if (accelerate) {
    return port::AcceleratedCRC32C(crc, buf, size);
  }

  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);
  const uint8_t *e = p + size;
  uint32_t l = crc ^ 0xffffffffu;

#define STEP1 do {                              \
    int c = (l & 0xff) ^ *p++;                  \
    l = table0_[c] ^ (l >> 8);                  \
} while (0)
#define STEP4 do {                              \
    uint32_t c = l ^ LE_LOAD32(p);              \
    p += 4;                                     \
    l = table3_[c & 0xff] ^                     \
        table2_[(c >> 8) & 0xff] ^              \
        table1_[(c >> 16) & 0xff] ^             \
        table0_[c >> 24];                       \
} while (0)

  // Point x at first 4-byte aligned byte in string.  This might be
  // just past the end of the string.
  const uintptr_t pval = reinterpret_cast<uintptr_...",1,6,util\crc32c.cc,leveldb.crc32c.Extend,,false,299,347,Extend,,,11,"uint32_t leveldb.crc32c.Extend (uint32_t,char*,size_t)"
87599,METHOD,util\crc32c.hpp:<global>,TYPE_DECL,<global>,1,41,util\crc32c.hpp,util\crc32c.hpp:<global>,,false,1,45,<global>,,,1,
87603,METHOD,util\crc32c.hpp:<global>,TYPE_DECL,"extern uint32_t Extend(uint32_t init_crc, const char* data, size_t n);",17,69,util\crc32c.hpp,leveldb.crc32c.Extend,,false,17,17,Extend,,,1,"uint32_t leveldb.crc32c.Extend (uint32_t,char*,size_t)"
87610,METHOD,util\crc32c.hpp:<global>,TYPE_DECL,"inline uint32_t Value(const char* data, size_t n) {
  return Extend(0, data, n);
}",1,1,util\crc32c.hpp,leveldb.crc32c.Value,,false,20,22,Value,,,2,"uint32_t leveldb.crc32c.Value (char*,size_t)"
87625,METHOD,util\crc32c.hpp:<global>,TYPE_DECL,"inline uint32_t Mask(uint32_t crc) {
  // Rotate right by 15 bits and add a constant.
  return ((crc >> 15) | (crc << 17)) + kMaskDelta;
}",1,1,util\crc32c.hpp,leveldb.crc32c.Mask,,false,31,34,Mask,,,5,uint32_t leveldb.crc32c.Mask (uint32_t)
87640,METHOD,util\crc32c.hpp:<global>,TYPE_DECL,"inline uint32_t Unmask(uint32_t masked_crc) {
  uint32_t rot = masked_crc - kMaskDelta;
  return ((rot >> 17) | (rot << 15));
}",1,1,util\crc32c.hpp,leveldb.crc32c.Unmask,,false,37,40,Unmask,,,6,uint32_t leveldb.crc32c.Unmask (uint32_t)
87666,METHOD,util\crc32c_test.cc:<global>,TYPE_DECL,<global>,1,1,util\crc32c_test.cc,util\crc32c_test.cc:<global>,,false,1,72,<global>,,,1,
87672,METHOD,leveldb.crc32c._Test_StandardResults,TYPE_DECL,void void ();,1,26,util\crc32c_test.cc,leveldb.crc32c._Test_StandardResults._Run,,false,13,13,_Run,,,1,void leveldb.crc32c._Test_StandardResults._Run ()
87676,METHOD,leveldb.crc32c._Test_StandardResults,TYPE_DECL,"TEST(CRC, StandardResults)",1,26,util\crc32c_test.cc,leveldb.crc32c._Test_StandardResults._RunIt,,false,13,13,_RunIt,,,2,void leveldb.crc32c._Test_StandardResults._RunIt ()
87700,METHOD,util\crc32c_test.cc:<global>,TYPE_DECL,"TEST(CRC, StandardResults) {
  // From rfc3720 section B.4.
  char buf[32];

  memset(buf, 0, sizeof(buf));
  ASSERT_EQ(0x8a9136aa, Value(buf, sizeof(buf)));

  memset(buf, 0xff, sizeof(buf));
  ASSERT_EQ(0x62a8ab43, Value(buf, sizeof(buf)));

  for (int i = 0; i < 32; i++) {
    buf[i] = i;
  }
  ASSERT_EQ(0x46dd794e, Value(buf, sizeof(buf)));

  for (int i = 0; i < 32; i++) {
    buf[i] = 31 - i;
  }
  ASSERT_EQ(0x113fdb5c, Value(buf, sizeof(buf)));

  unsigned char data[48] = {
    0x01, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x18,
    0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  };
  ASSERT_EQ(0xd9963a56, Value(reinterpret_cast<char*>(data), sizeof(data)));
}",1,26,util\crc32c_test.cc,leveldb.crc32c._Test_StandardResults._Run,,false,13,48,_Run,,,5,void leveldb.crc32c._Test_StandardResults._Run ()
87901,METHOD,leveldb.crc32c._Test_Values,TYPE_DECL,void void ();,1,17,util\crc32c_test.cc,leveldb.crc32c._Test_Values._Run,,false,50,50,_Run,,,1,void leveldb.crc32c._Test_Values._Run ()
87905,METHOD,leveldb.crc32c._Test_Values,TYPE_DECL,"TEST(CRC, Values)",1,17,util\crc32c_test.cc,leveldb.crc32c._Test_Values._RunIt,,false,50,50,_RunIt,,,2,void leveldb.crc32c._Test_Values._RunIt ()
87929,METHOD,util\crc32c_test.cc:<global>,TYPE_DECL,"TEST(CRC, Values) {
  ASSERT_NE(Value(""a"", 1), Value(""foo"", 3));
}",1,17,util\crc32c_test.cc,leveldb.crc32c._Test_Values._Run,,false,50,52,_Run,,,9,void leveldb.crc32c._Test_Values._Run ()
87953,METHOD,leveldb.crc32c._Test_Extend,TYPE_DECL,void void ();,1,17,util\crc32c_test.cc,leveldb.crc32c._Test_Extend._Run,,false,54,54,_Run,,,1,void leveldb.crc32c._Test_Extend._Run ()
87957,METHOD,leveldb.crc32c._Test_Extend,TYPE_DECL,"TEST(CRC, Extend)",1,17,util\crc32c_test.cc,leveldb.crc32c._Test_Extend._RunIt,,false,54,54,_RunIt,,,2,void leveldb.crc32c._Test_Extend._RunIt ()
87981,METHOD,util\crc32c_test.cc:<global>,TYPE_DECL,"TEST(CRC, Extend) {
  ASSERT_EQ(Value(""hello world"", 11),
            Extend(Value(""hello "", 6), ""world"", 5));
}",1,17,util\crc32c_test.cc,leveldb.crc32c._Test_Extend._Run,,false,54,57,_Run,,,13,void leveldb.crc32c._Test_Extend._Run ()
88008,METHOD,leveldb.crc32c._Test_Mask,TYPE_DECL,void void ();,1,15,util\crc32c_test.cc,leveldb.crc32c._Test_Mask._Run,,false,59,59,_Run,,,1,void leveldb.crc32c._Test_Mask._Run ()
88012,METHOD,leveldb.crc32c._Test_Mask,TYPE_DECL,"TEST(CRC, Mask)",1,15,util\crc32c_test.cc,leveldb.crc32c._Test_Mask._RunIt,,false,59,59,_RunIt,,,2,void leveldb.crc32c._Test_Mask._RunIt ()
88036,METHOD,util\crc32c_test.cc:<global>,TYPE_DECL,"TEST(CRC, Mask) {
  uint32_t crc = Value(""foo"", 3);
  ASSERT_NE(crc, Mask(crc));
  ASSERT_NE(crc, Mask(Mask(crc)));
  ASSERT_EQ(crc, Unmask(Mask(crc)));
  ASSERT_EQ(crc, Unmask(Unmask(Mask(Mask(crc)))));
}",1,15,util\crc32c_test.cc,leveldb.crc32c._Test_Mask._Run,,false,59,65,_Run,,,17,void leveldb.crc32c._Test_Mask._Run ()
88132,METHOD,util\crc32c_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\crc32c_test.cc,main,,false,70,72,main,,,2,"int main (int,char**)"
88150,METHOD,util\env.cc:<global>,TYPE_DECL,<global>,1,1,util\env.cc,util\env.cc:<global>,,false,1,100,<global>,,,1,
88153,METHOD,util\env.cc:<global>,TYPE_DECL,"Env::~Env() {
}",1,1,util\env.cc,leveldb.Env.~Env,,false,9,10,~Env,,,1,ANY leveldb.Env.~Env ()
88157,METHOD,util\env.cc:<global>,TYPE_DECL,"Status Env::NewAppendableFile(const std::string& fname, WritableFile** result) {
  return Status::NotSupported(""NewAppendableFile"", fname);
}",1,1,util\env.cc,leveldb.Env.NewAppendableFile,,false,12,14,NewAppendableFile,,,2,"Status leveldb.Env.NewAppendableFile (ANY,WritableFile**)"
88170,METHOD,util\env.cc:<global>,TYPE_DECL,"SequentialFile::~SequentialFile() {
}",1,1,util\env.cc,leveldb.SequentialFile.~SequentialFile,,false,16,17,~SequentialFile,,,3,ANY leveldb.SequentialFile.~SequentialFile ()
88174,METHOD,util\env.cc:<global>,TYPE_DECL,"RandomAccessFile::~RandomAccessFile() {
}",1,1,util\env.cc,leveldb.RandomAccessFile.~RandomAccessFile,,false,19,20,~RandomAccessFile,,,4,ANY leveldb.RandomAccessFile.~RandomAccessFile ()
88178,METHOD,util\env.cc:<global>,TYPE_DECL,"WritableFile::~WritableFile() {
}",1,1,util\env.cc,leveldb.WritableFile.~WritableFile,,false,22,23,~WritableFile,,,5,ANY leveldb.WritableFile.~WritableFile ()
88182,METHOD,util\env.cc:<global>,TYPE_DECL,"Logger::~Logger() {
}",1,1,util\env.cc,leveldb.Logger.~Logger,,false,25,26,~Logger,,,6,ANY leveldb.Logger.~Logger ()
88186,METHOD,util\env.cc:<global>,TYPE_DECL,"FileLock::~FileLock() {
}",1,1,util\env.cc,leveldb.FileLock.~FileLock,,false,28,29,~FileLock,,,7,ANY leveldb.FileLock.~FileLock ()
88190,METHOD,util\env.cc:<global>,TYPE_DECL,"void Log(Logger* info_log, const char* format, ...) {
  if (info_log != NULL) {
    va_list ap;
    va_start(ap, format);
    info_log->Logv(format, ap);
    va_end(ap);
  }
}",1,1,util\env.cc,leveldb.Log,,false,31,38,Log,,,8,"void leveldb.Log (Logger*,char*...)"
88213,METHOD,util\env.cc:<global>,TYPE_DECL,"static Status DoWriteStringToFile(Env* env, const Slice& data,
                                  const std::string& fname,
                                  bool should_sync) {
  WritableFile* file;
  Status s = env->NewWritableFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  s = file->Append(data);
  if (s.ok() && should_sync) {
    s = file->Sync();
  }
  if (s.ok()) {
    s = file->Close();
  }
  delete file;  // Will auto-close if we did not close above
  if (!s.ok()) {
    env->DeleteFile(fname);
  }
  return s;
}",1,1,util\env.cc,leveldb.DoWriteStringToFile,,false,40,60,DoWriteStringToFile,,,9,"Status leveldb.DoWriteStringToFile (Env*,Slice,ANY,bool)"
88290,METHOD,util\env.cc:<global>,TYPE_DECL,"Status WriteStringToFile(Env* env, const Slice& data,
                         const std::string& fname) {
  return DoWriteStringToFile(env, data, fname, false);
}",1,1,util\env.cc,leveldb.WriteStringToFile,,false,62,65,WriteStringToFile,,,10,"Status leveldb.WriteStringToFile (Env*,Slice,ANY)"
88303,METHOD,util\env.cc:<global>,TYPE_DECL,"Status WriteStringToFileSync(Env* env, const Slice& data,
                             const std::string& fname) {
  return DoWriteStringToFile(env, data, fname, true);
}",1,1,util\env.cc,leveldb.WriteStringToFileSync,,false,67,70,WriteStringToFileSync,,,11,"Status leveldb.WriteStringToFileSync (Env*,Slice,ANY)"
88316,METHOD,util\env.cc:<global>,TYPE_DECL,"Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {
  data->clear();
  SequentialFile* file;
  Status s = env->NewSequentialFile(fname, &file);
  if (!s.ok()) {
    return s;
  }
  static const int kBufferSize = 8192;
  char* space = new char[kBufferSize];
  while (true) {
    Slice fragment;
    s = file->Read(kBufferSize, &fragment, space);
    if (!s.ok()) {
      break;
    }
    data->append(fragment.data(), fragment.size());
    if (fragment.empty()) {
      break;
    }
  }
  delete[] space;
  delete file;
  return s;
}",1,1,util\env.cc,leveldb.ReadFileToString,,false,72,95,ReadFileToString,,,12,"Status leveldb.ReadFileToString (Env*,ANY,ANY*)"
88403,METHOD,util\env.cc:<global>,TYPE_DECL,"EnvWrapper::~EnvWrapper() {
}",1,1,util\env.cc,leveldb.EnvWrapper.~EnvWrapper,,false,97,98,~EnvWrapper,,,13,ANY leveldb.EnvWrapper.~EnvWrapper ()
88458,METHOD,util\env_posix.cc:<global>,TYPE_DECL,<global>,1,15,util\env_posix.cc,util\env_posix.cc:<global>,,false,1,695,<global>,,,1,
88472,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"static Status IOError(const std::string& context, int err_number) {
  return Status::IOError(context, strerror(err_number));
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_1.IOError,,false,37,39,IOError,,,5,"Status leveldb.anonymous_namespace_1.IOError (ANY,int)"
88487,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,"Limiter(intptr_t n) {
    SetAllowed(n);
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_3.Limiter.Limiter,,false,48,50,Limiter,,,1,ANY leveldb.anonymous_namespace_3.Limiter.Limiter (intptr_t)
88494,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,"bool Acquire() {
    if (GetAllowed() <= 0) {
      return false;
    }
    MutexLock l(&mu_);
    intptr_t x = GetAllowed();
    if (x <= 0) {
      return false;
    } else {
      SetAllowed(x - 1);
      return true;
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_5.Limiter.Acquire,,false,54,66,Acquire,,,2,bool leveldb.anonymous_namespace_5.Limiter.Acquire ()
88528,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,"void Release() {
    MutexLock l(&mu_);
    SetAllowed(GetAllowed() + 1);
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_9.Limiter.Release,,false,70,73,Release,,,3,void leveldb.anonymous_namespace_9.Limiter.Release ()
88542,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,"intptr_t GetAllowed() const {
    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_12.Limiter.GetAllowed,,false,79,81,GetAllowed,,,6,intptr_t leveldb.anonymous_namespace_12.Limiter.GetAllowed ()
88553,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,"void SetAllowed(intptr_t v) {
    allowed_.Release_Store(reinterpret_cast<void*>(v));
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_13.Limiter.SetAllowed,,false,84,86,SetAllowed,,,7,void leveldb.anonymous_namespace_13.Limiter.SetAllowed (intptr_t)
88565,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,Limiter(const Limiter&);,3,25,util\env_posix.cc,leveldb.anonymous_namespace_14.Limiter.Limiter,,false,88,88,Limiter,,,8,ANY leveldb.anonymous_namespace_14.Limiter.Limiter (Limiter)
88570,METHOD,leveldb.anonymous_namespace_2.Limiter,TYPE_DECL,void operator=(const Limiter&);,8,32,util\env_posix.cc,leveldb.anonymous_namespace_15.Limiter.operator =,,false,89,89,operator =,,,9,void leveldb.anonymous_namespace_15.Limiter.operator = (Limiter)
88578,METHOD,leveldb.anonymous_namespace_16.PosixSequentialFile,TYPE_DECL,"PosixSequentialFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }",3,38,util\env_posix.cc,leveldb.anonymous_namespace_17.PosixSequentialFile.PosixSequentialFile,,false,98,99,PosixSequentialFile,,,3,"ANY leveldb.anonymous_namespace_17.PosixSequentialFile.PosixSequentialFile (ANY,FILE*)"
88584,METHOD,leveldb.anonymous_namespace_16.PosixSequentialFile,TYPE_DECL,virtual ~PosixSequentialFile() { fclose(file_); },3,51,util\env_posix.cc,leveldb.anonymous_namespace_18.PosixSequentialFile.~PosixSequentialFile,,false,100,100,~PosixSequentialFile,,,4,ANY leveldb.anonymous_namespace_18.PosixSequentialFile.~PosixSequentialFile ()
88590,METHOD,leveldb.anonymous_namespace_16.PosixSequentialFile,TYPE_DECL,"virtual Status Read(size_t n, Slice* result, char* scratch) {
    Status s;
    size_t r = fread_unlocked(scratch, 1, n, file_);
    *result = Slice(scratch, r);
    if (r < n) {
      if (feof(file_)) {
        // We leave status as ok if we hit the end of the file
      } else {
        // A partial read with an error: return a non-ok status
        s = IOError(filename_, errno);
      }
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_19.PosixSequentialFile.Read,,false,102,115,Read,,,5,"Status leveldb.anonymous_namespace_19.PosixSequentialFile.Read (size_t,Slice*,char*)"
88630,METHOD,leveldb.anonymous_namespace_16.PosixSequentialFile,TYPE_DECL,"virtual Status Skip(uint64_t n) {
    if (fseek(file_, n, SEEK_CUR)) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_20.PosixSequentialFile.Skip,,false,117,122,Skip,,,6,Status leveldb.anonymous_namespace_20.PosixSequentialFile.Skip (uint64_t)
88655,METHOD,leveldb.anonymous_namespace_21.PosixRandomAccessFile,TYPE_DECL,"PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)
      : filename_(fname), fd_(fd), limiter_(limiter) {
    temporary_fd_ = !limiter->Acquire();
    if (temporary_fd_) {
      // Open file on every access.
      close(fd_);
      fd_ = -1;
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_22.PosixRandomAccessFile.PosixRandomAccessFile,,false,134,142,PosixRandomAccessFile,,,5,"ANY leveldb.anonymous_namespace_22.PosixRandomAccessFile.PosixRandomAccessFile (ANY,int,Limiter*)"
88678,METHOD,leveldb.anonymous_namespace_21.PosixRandomAccessFile,TYPE_DECL,"virtual ~PosixRandomAccessFile() {
    if (!temporary_fd_) {
      close(fd_);
      limiter_->Release();
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_23.PosixRandomAccessFile.~PosixRandomAccessFile,,false,144,149,~PosixRandomAccessFile,,,6,ANY leveldb.anonymous_namespace_23.PosixRandomAccessFile.~PosixRandomAccessFile ()
88692,METHOD,leveldb.anonymous_namespace_21.PosixRandomAccessFile,TYPE_DECL,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    int fd = fd_;
    if (temporary_fd_) {
      fd = open(filename_.c_str(), O_RDONLY);
      if (fd < 0) {
        return IOError(filename_, errno);
      }
    }

    Status s;
    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));
    *result = Slice(scratch, (r < 0) ? 0 : r);
    if (r < 0) {
      // An error: return a non-ok status
      s = IOError(filename_, errno);
    }
    if (temporary_fd_) {
      // Close the temporary file descriptor opened earlier.
      close(fd);
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_24.PosixRandomAccessFile.Read,,false,151,173,Read,,,7,"Status leveldb.anonymous_namespace_24.PosixRandomAccessFile.Read (uint64_t,size_t,Slice*,char*)"
88768,METHOD,leveldb.anonymous_namespace_25.PosixMmapReadableFile,TYPE_DECL,"PosixMmapReadableFile(const std::string& fname, void* base, size_t length,
                        Limiter* limiter)
      : filename_(fname), mmapped_region_(base), length_(length),
        limiter_(limiter) {
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_26.PosixMmapReadableFile.PosixMmapReadableFile,,false,186,190,PosixMmapReadableFile,,,5,"ANY leveldb.anonymous_namespace_26.PosixMmapReadableFile.PosixMmapReadableFile (ANY,void*,size_t,Limiter*)"
88776,METHOD,leveldb.anonymous_namespace_25.PosixMmapReadableFile,TYPE_DECL,"virtual ~PosixMmapReadableFile() {
    munmap(mmapped_region_, length_);
    limiter_->Release();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_27.PosixMmapReadableFile.~PosixMmapReadableFile,,false,192,195,~PosixMmapReadableFile,,,6,ANY leveldb.anonymous_namespace_27.PosixMmapReadableFile.~PosixMmapReadableFile ()
88787,METHOD,leveldb.anonymous_namespace_25.PosixMmapReadableFile,TYPE_DECL,"virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const {
    Status s;
    if (offset + n > length_) {
      *result = Slice();
      s = IOError(filename_, EINVAL);
    } else {
      *result = Slice(reinterpret_cast<char*>(mmapped_region_) + offset, n);
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_28.PosixMmapReadableFile.Read,,false,197,207,Read,,,7,"Status leveldb.anonymous_namespace_28.PosixMmapReadableFile.Read (uint64_t,size_t,Slice*,char*)"
88829,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"PosixWritableFile(const std::string& fname, FILE* f)
      : filename_(fname), file_(f) { }",3,38,util\env_posix.cc,leveldb.anonymous_namespace_30.PosixWritableFile.PosixWritableFile,,false,216,217,PosixWritableFile,,,3,"ANY leveldb.anonymous_namespace_30.PosixWritableFile.PosixWritableFile (ANY,FILE*)"
88835,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"~PosixWritableFile() {
    if (file_ != NULL) {
      // Ignoring any potential errors
      fclose(file_);
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_31.PosixWritableFile.~PosixWritableFile,,false,219,224,~PosixWritableFile,,,4,ANY leveldb.anonymous_namespace_31.PosixWritableFile.~PosixWritableFile ()
88846,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"virtual Status Append(const Slice& data) {
    size_t r = fwrite_unlocked(data.data(), 1, data.size(), file_);
    if (r != data.size()) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_32.PosixWritableFile.Append,,false,226,232,Append,,,5,Status leveldb.anonymous_namespace_32.PosixWritableFile.Append (Slice)
88882,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"virtual Status Close() {
    Status result;
    if (fclose(file_) != 0) {
      result = IOError(filename_, errno);
    }
    file_ = NULL;
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_33.PosixWritableFile.Close,,false,234,241,Close,,,6,Status leveldb.anonymous_namespace_33.PosixWritableFile.Close ()
88903,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"virtual Status Flush() {
    if (fflush_unlocked(file_) != 0) {
      return IOError(filename_, errno);
    }
    return Status::OK();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_34.PosixWritableFile.Flush,,false,243,248,Flush,,,7,Status leveldb.anonymous_namespace_34.PosixWritableFile.Flush ()
88922,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"Status SyncDirIfManifest() {
    const char* f = filename_.c_str();
    const char* sep = strrchr(f, '/');
    Slice basename;
    std::string dir;
    if (sep == NULL) {
      dir = ""."";
      basename = f;
    } else {
      dir = std::string(f, sep - f);
      basename = sep + 1;
    }
    Status s;
    if (basename.starts_with(""MANIFEST"")) {
      int fd = open(dir.c_str(), O_RDONLY);
      if (fd < 0) {
        s = IOError(dir, errno);
      } else {
        if (fsync(fd) < 0) {
          s = IOError(dir, errno);
        }
        close(fd);
      }
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_35.PosixWritableFile.SyncDirIfManifest,,false,250,275,SyncDirIfManifest,,,8,Status leveldb.anonymous_namespace_35.PosixWritableFile.SyncDirIfManifest ()
89013,METHOD,leveldb.anonymous_namespace_29.PosixWritableFile,TYPE_DECL,"virtual Status Sync() {
    // Ensure new files referred to by the manifest are in the filesystem.
    Status s = SyncDirIfManifest();
    if (!s.ok()) {
      return s;
    }
    if (fflush_unlocked(file_) != 0 ||
        fdatasync(fileno(file_)) != 0) {
      s = Status::IOError(filename_, strerror(errno));
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_36.PosixWritableFile.Sync,,false,277,288,Sync,,,9,Status leveldb.anonymous_namespace_36.PosixWritableFile.Sync ()
89053,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"static int LockOrUnlock(int fd, bool lock) {
  errno = 0;
  struct flock f;
  memset(&f, 0, sizeof(f));
  f.l_type = (lock ? F_WRLCK : F_UNLCK);
  f.l_whence = SEEK_SET;
  f.l_start = 0;
  f.l_len = 0;        // Lock/unlock entire file
  return fcntl(fd, F_SETLK, &f);
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_38.LockOrUnlock,,false,291,300,LockOrUnlock,,,11,"int leveldb.anonymous_namespace_38.LockOrUnlock (int,bool)"
89104,METHOD,leveldb.anonymous_namespace_40.PosixLockTable,TYPE_DECL,"bool Insert(const std::string& fname) {
    MutexLock l(&mu_);
    return locked_files_.insert(fname).second;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_41.PosixLockTable.Insert,,false,316,319,Insert,,,3,bool leveldb.anonymous_namespace_41.PosixLockTable.Insert (ANY)
89121,METHOD,leveldb.anonymous_namespace_40.PosixLockTable,TYPE_DECL,"void Remove(const std::string& fname) {
    MutexLock l(&mu_);
    locked_files_.erase(fname);
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_42.PosixLockTable.Remove,,false,320,323,Remove,,,4,void leveldb.anonymous_namespace_42.PosixLockTable.Remove (ANY)
89136,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,PosixEnv();,3,12,util\env_posix.cc,leveldb.anonymous_namespace_44.PosixEnv.PosixEnv,,false,328,328,PosixEnv,,,1,ANY leveldb.anonymous_namespace_44.PosixEnv.PosixEnv ()
89140,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual ~PosixEnv() {
    char msg[] = ""Destroying Env::Default()\n"";
    fwrite(msg, 1, sizeof(msg), stderr);
    abort();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_45.PosixEnv.~PosixEnv,,false,329,333,~PosixEnv,,,2,ANY leveldb.anonymous_namespace_45.PosixEnv.~PosixEnv ()
89155,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status NewSequentialFile(const std::string& fname,
                                   SequentialFile** result) {
    FILE* f = fopen(fname.c_str(), ""r"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_46.PosixEnv.NewSequentialFile,,false,335,345,NewSequentialFile,,,3,"Status leveldb.anonymous_namespace_46.PosixEnv.NewSequentialFile (ANY,SequentialFile**)"
89197,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status NewRandomAccessFile(const std::string& fname,
                                     RandomAccessFile** result) {
    *result = NULL;
    Status s;
    int fd = open(fname.c_str(), O_RDONLY);
    if (fd < 0) {
      s = IOError(fname, errno);
    } else if (mmap_limit_.Acquire()) {
      uint64_t size;
      s = GetFileSize(fname, &size);
      if (s.ok()) {
        void* base = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (base != MAP_FAILED) {
          *result = new PosixMmapReadableFile(fname, base, size, &mmap_limit_);
        } else {
          s = IOError(fname, errno);
        }
      }
      close(fd);
      if (!s.ok()) {
        mmap_limit_.Release();
      }
    } else {
      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_47.PosixEnv.NewRandomAccessFile,,false,347,373,NewRandomAccessFile,,,4,"Status leveldb.anonymous_namespace_47.PosixEnv.NewRandomAccessFile (ANY,RandomAccessFile**)"
89306,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    Status s;
    FILE* f = fopen(fname.c_str(), ""w"");
    if (f == NULL) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixWritableFile(fname, f);
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_49.PosixEnv.NewWritableFile,,false,375,386,NewWritableFile,,,5,"Status leveldb.anonymous_namespace_49.PosixEnv.NewWritableFile (ANY,WritableFile**)"
89347,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    Status s;
    FILE* f = fopen(fname.c_str(), ""a"");
    if (f == NULL) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixWritableFile(fname, f);
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_50.PosixEnv.NewAppendableFile,,false,388,399,NewAppendableFile,,,6,"Status leveldb.anonymous_namespace_50.PosixEnv.NewAppendableFile (ANY,WritableFile**)"
89388,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual bool FileExists(const std::string& fname) {
    return access(fname.c_str(), F_OK) == 0;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_51.PosixEnv.FileExists,,false,401,403,FileExists,,,7,bool leveldb.anonymous_namespace_51.PosixEnv.FileExists (ANY)
89402,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status GetChildren(const std::string& dir,
                             std::vector<std::string>* result) {
    result->clear();
    DIR* d = opendir(dir.c_str());
    if (d == NULL) {
      return IOError(dir, errno);
    }
    struct dirent* entry;
    while ((entry = readdir(d)) != NULL) {
      result->push_back(entry->d_name);
    }
    closedir(d);
    return Status::OK();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_52.PosixEnv.GetChildren,,false,405,418,GetChildren,,,8,"Status leveldb.anonymous_namespace_52.PosixEnv.GetChildren (ANY,ANY*)"
89452,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status DeleteFile(const std::string& fname) {
    Status result;
    if (unlink(fname.c_str()) != 0) {
      result = IOError(fname, errno);
    }
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_53.PosixEnv.DeleteFile,,false,420,426,DeleteFile,,,9,Status leveldb.anonymous_namespace_53.PosixEnv.DeleteFile (ANY)
89474,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status CreateDir(const std::string& name) {
    Status result;
    if (mkdir(name.c_str(), 0755) != 0) {
      result = IOError(name, errno);
    }
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_54.PosixEnv.CreateDir,,false,428,434,CreateDir,,,10,Status leveldb.anonymous_namespace_54.PosixEnv.CreateDir (ANY)
89497,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status DeleteDir(const std::string& name) {
    Status result;
    if (rmdir(name.c_str()) != 0) {
      result = IOError(name, errno);
    }
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_55.PosixEnv.DeleteDir,,false,436,442,DeleteDir,,,11,Status leveldb.anonymous_namespace_55.PosixEnv.DeleteDir (ANY)
89519,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status GetFileSize(const std::string& fname, uint64_t* size) {
    Status s;
    struct stat sbuf;
    if (stat(fname.c_str(), &sbuf) != 0) {
      *size = 0;
      s = IOError(fname, errno);
    } else {
      *size = sbuf.st_size;
    }
    return s;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_56.PosixEnv.GetFileSize,,false,444,454,GetFileSize,,,12,"Status leveldb.anonymous_namespace_56.PosixEnv.GetFileSize (ANY,uint64_t*)"
89557,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status RenameFile(const std::string& src, const std::string& target) {
    Status result;
    if (rename(src.c_str(), target.c_str()) != 0) {
      result = IOError(src, errno);
    }
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_57.PosixEnv.RenameFile,,false,456,462,RenameFile,,,13,"Status leveldb.anonymous_namespace_57.PosixEnv.RenameFile (ANY,ANY)"
89584,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status LockFile(const std::string& fname, FileLock** lock) {
    *lock = NULL;
    Status result;
    int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644);
    if (fd < 0) {
      result = IOError(fname, errno);
    } else if (!locks_.Insert(fname)) {
      close(fd);
      result = Status::IOError(""lock "" + fname, ""already held by process"");
    } else if (LockOrUnlock(fd, true) == -1) {
      result = IOError(""lock "" + fname, errno);
      close(fd);
      locks_.Remove(fname);
    } else {
      PosixFileLock* my_lock = new PosixFileLock;
      my_lock->fd_ = fd;
      my_lock->name_ = fname;
      *lock = my_lock;
    }
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_58.PosixEnv.LockFile,,false,464,484,LockFile,,,14,"Status leveldb.anonymous_namespace_58.PosixEnv.LockFile (ANY,FileLock**)"
89686,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status UnlockFile(FileLock* lock) {
    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);
    Status result;
    if (LockOrUnlock(my_lock->fd_, false) == -1) {
      result = IOError(""unlock"", errno);
    }
    locks_.Remove(my_lock->name_);
    close(my_lock->fd_);
    delete my_lock;
    return result;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_60.PosixEnv.UnlockFile,,false,486,496,UnlockFile,,,15,Status leveldb.anonymous_namespace_60.PosixEnv.UnlockFile (FileLock*)
89728,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual void Schedule(void (*function)(void*), void* arg);",16,59,util\env_posix.cc,leveldb.anonymous_namespace_62.PosixEnv.Schedule,,false,498,498,Schedule,,,16,"void leveldb.anonymous_namespace_62.PosixEnv.Schedule (void,void*)"
89734,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual void StartThread(void (*function)(void* arg), void* arg);",16,66,util\env_posix.cc,leveldb.anonymous_namespace_63.PosixEnv.StartThread,,false,500,500,StartThread,,,17,"void leveldb.anonymous_namespace_63.PosixEnv.StartThread (void,void*)"
89740,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status GetTestDirectory(std::string* result) {
    const char* env = getenv(""TEST_TMPDIR"");
    if (env && env[0] != '\0') {
      *result = env;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), ""/tmp/leveldbtest-%d"", int(geteuid()));
      *result = buf;
    }
    // Directory may already exist
    CreateDir(*result);
    return Status::OK();
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_64.PosixEnv.GetTestDirectory,,false,502,514,GetTestDirectory,,,18,Status leveldb.anonymous_namespace_64.PosixEnv.GetTestDirectory (ANY*)
89786,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"static uint64_t gettid() {
    pthread_t tid = pthread_self();
    uint64_t thread_id = 0;
    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));
    return thread_id;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_66.PosixEnv.gettid,,false,516,521,gettid,,,19,uint64_t leveldb.anonymous_namespace_66.PosixEnv.gettid ()
89813,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual Status NewLogger(const std::string& fname, Logger** result) {
    FILE* f = fopen(fname.c_str(), ""w"");
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixLogger(f, &PosixEnv::gettid);
      return Status::OK();
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_67.PosixEnv.NewLogger,,false,523,532,NewLogger,,,20,"Status leveldb.anonymous_namespace_67.PosixEnv.NewLogger (ANY,Logger**)"
89858,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual uint64_t NowMicros() {
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_68.PosixEnv.NowMicros,,false,534,538,NowMicros,,,21,uint64_t leveldb.anonymous_namespace_68.PosixEnv.NowMicros ()
89879,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"virtual void SleepForMicroseconds(int micros) {
    usleep(micros);
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_69.PosixEnv.SleepForMicroseconds,,false,540,542,SleepForMicroseconds,,,22,void leveldb.anonymous_namespace_69.PosixEnv.SleepForMicroseconds (int)
89886,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"void PthreadCall(const char* label, int result) {
    if (result != 0) {
      fprintf(stderr, ""pthread %s: %s\n"", label, strerror(result));
      abort();
    }
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_70.PosixEnv.PthreadCall,,false,545,550,PthreadCall,,,23,"void leveldb.anonymous_namespace_70.PosixEnv.PthreadCall (char*,int)"
89904,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,void BGThread();,8,17,util\env_posix.cc,leveldb.anonymous_namespace_71.PosixEnv.BGThread,,false,553,553,BGThread,,,24,void leveldb.anonymous_namespace_71.PosixEnv.BGThread ()
89908,METHOD,leveldb.anonymous_namespace_43.PosixEnv,TYPE_DECL,"static void* BGThreadWrapper(void* arg) {
    reinterpret_cast<PosixEnv*>(arg)->BGThread();
    return NULL;
  }",3,3,util\env_posix.cc,leveldb.anonymous_namespace_72.PosixEnv.BGThreadWrapper,,false,554,557,BGThreadWrapper,,,25,void* leveldb.anonymous_namespace_72.PosixEnv.BGThreadWrapper (void*)
89927,METHOD,leveldb.anonymous_namespace_73.PosixEnv.BGItem,TYPE_DECL,void (*function)(void*);,35,52,util\env_posix.cc,leveldb.anonymous_namespace_74.PosixEnv.BGItem.function,,false,565,565,function,,,2,void leveldb.anonymous_namespace_74.PosixEnv.BGItem.function (void*)
89937,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"static int MaxMmaps() {
  if (mmap_limit >= 0) {
    return mmap_limit;
  }
  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.
  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;
  return mmap_limit;
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_75.MaxMmaps,,false,575,582,MaxMmaps,,,15,int leveldb.anonymous_namespace_75.MaxMmaps ()
89959,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"static intptr_t MaxOpenFiles() {
  if (open_read_only_file_limit >= 0) {
    return open_read_only_file_limit;
  }
  struct rlimit rlim;
  if (getrlimit(RLIMIT_NOFILE, &rlim)) {
    // getrlimit failed, fallback to hard-coded default.
    open_read_only_file_limit = 50;
  } else if (rlim.rlim_cur == RLIM_INFINITY) {
    open_read_only_file_limit = std::numeric_limits<int>::max();
  } else {
    // Allow use of 20% of available file descriptors for read-only files.
    open_read_only_file_limit = rlim.rlim_cur / 5;
  }
  return open_read_only_file_limit;
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_76.MaxOpenFiles,,false,585,600,MaxOpenFiles,,,16,intptr_t leveldb.anonymous_namespace_76.MaxOpenFiles ()
90008,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"PosixEnv::PosixEnv()
    : started_bgthread_(false),
      mmap_limit_(MaxMmaps()),
      fd_limit_(MaxOpenFiles()) {
  PthreadCall(""mutex_init"", pthread_mutex_init(&mu_, NULL));
  PthreadCall(""cvar_init"", pthread_cond_init(&bgsignal_, NULL));
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_77.PosixEnv.PosixEnv,,false,602,608,PosixEnv,,,17,ANY leveldb.anonymous_namespace_77.PosixEnv.PosixEnv ()
90024,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"void PosixEnv::Schedule(void (*function)(void*), void* arg) {
  PthreadCall(""lock"", pthread_mutex_lock(&mu_));

  // Start background thread if necessary
  if (!started_bgthread_) {
    started_bgthread_ = true;
    PthreadCall(
        ""create thread"",
        pthread_create(&bgthread_, NULL,  &PosixEnv::BGThreadWrapper, this));
  }

  // If the queue is currently empty, the background thread may currently be
  // waiting.
  if (queue_.empty()) {
    PthreadCall(""signal"", pthread_cond_signal(&bgsignal_));
  }

  // Add to priority queue
  queue_.push_back(BGItem());
  queue_.back().function = function;
  queue_.back().arg = arg;

  PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_78.PosixEnv.Schedule,,false,610,633,Schedule,,,18,"void leveldb.anonymous_namespace_78.PosixEnv.Schedule (void,void*)"
90090,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"void PosixEnv::BGThread() {
  while (true) {
    // Wait until there is an item that is ready to run
    PthreadCall(""lock"", pthread_mutex_lock(&mu_));
    while (queue_.empty()) {
      PthreadCall(""wait"", pthread_cond_wait(&bgsignal_, &mu_));
    }

    void (*function)(void*) = queue_.front().function;
    void* arg = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(""unlock"", pthread_mutex_unlock(&mu_));
    (*function)(arg);
  }
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_79.PosixEnv.BGThread,,false,635,650,BGThread,,,19,void leveldb.anonymous_namespace_79.PosixEnv.BGThread ()
90113,METHOD,util\env_posix.cc:<global>,TYPE_DECL,void (*function)(void*) = queue_.front().function;,10,53,util\env_posix.cc,leveldb.anonymous_namespace_80.PosixEnv.BGThread.function,,false,643,643,function,,,3,void leveldb.anonymous_namespace_80.PosixEnv.BGThread.function (void*)
90144,METHOD,leveldb.anonymous_namespace_83.anonymous_namespace_84.StartThreadState,TYPE_DECL,void (*user_function)(void*);,8,30,util\env_posix.cc,leveldb.anonymous_namespace_85.anonymous_namespace_86.StartThreadState.user_function,,false,654,654,user_function,,,1,void leveldb.anonymous_namespace_85.anonymous_namespace_86.StartThreadState.user_function (void*)
90150,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"static void* StartThreadWrapper(void* arg) {
  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);
  state->user_function(state->arg);
  delete state;
  return NULL;
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_87.StartThreadWrapper,,false,658,663,StartThreadWrapper,,,21,void* leveldb.anonymous_namespace_87.StartThreadWrapper (void*)
90172,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {
  pthread_t t;
  StartThreadState* state = new StartThreadState;
  state->user_function = function;
  state->arg = arg;
  PthreadCall(""start thread"",
              pthread_create(&t, NULL,  &StartThreadWrapper, state));
}",1,1,util\env_posix.cc,leveldb.anonymous_namespace_88.PosixEnv.StartThread,,false,665,672,StartThread,,,22,"void leveldb.anonymous_namespace_88.PosixEnv.StartThread (void,void*)"
90208,METHOD,util\env_posix.cc:<global>,TYPE_DECL,static void InitDefaultEnv() { default_env = new PosixEnv; },1,60,util\env_posix.cc,leveldb.InitDefaultEnv,,false,678,678,InitDefaultEnv,,,5,void leveldb.InitDefaultEnv ()
90216,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {
  assert(default_env == NULL);
  open_read_only_file_limit = limit;
}",1,1,util\env_posix.cc,leveldb.EnvPosixTestHelper.SetReadOnlyFDLimit,,false,680,683,SetReadOnlyFDLimit,,,6,void leveldb.EnvPosixTestHelper.SetReadOnlyFDLimit (int)
90228,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {
  assert(default_env == NULL);
  mmap_limit = limit;
}",1,1,util\env_posix.cc,leveldb.EnvPosixTestHelper.SetReadOnlyMMapLimit,,false,685,688,SetReadOnlyMMapLimit,,,7,void leveldb.EnvPosixTestHelper.SetReadOnlyMMapLimit (int)
90240,METHOD,util\env_posix.cc:<global>,TYPE_DECL,"Env* Env::Default() {
  pthread_once(&once, InitDefaultEnv);
  return default_env;
}",1,1,util\env_posix.cc,leveldb.Env.Default,,false,690,693,Default,,,8,Env leveldb.Env.Default ()
90261,METHOD,util\env_posix_test.cc:<global>,TYPE_DECL,<global>,1,1,util\env_posix_test.cc,util\env_posix_test.cc:<global>,,false,1,66,<global>,,,1,
90278,METHOD,leveldb.EnvPosixTest,TYPE_DECL,EnvPosixTest() : env_(Env::Default()) { },3,43,util\env_posix_test.cc,leveldb.EnvPosixTest.EnvPosixTest,,false,20,20,EnvPosixTest,,,2,ANY leveldb.EnvPosixTest.EnvPosixTest ()
90282,METHOD,leveldb.EnvPosixTest,TYPE_DECL,"static void SetFileLimits(int read_only_file_limit, int mmap_limit) {
    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);
    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);
  }",3,3,util\env_posix_test.cc,leveldb.EnvPosixTest.SetFileLimits,,false,22,25,SetFileLimits,,,3,"void leveldb.EnvPosixTest.SetFileLimits (int,int)"
90299,METHOD,leveldb._Test_TestOpenOnRead,TYPE_DECL,void void ();,1,34,util\env_posix_test.cc,leveldb._Test_TestOpenOnRead._Run,,false,28,28,_Run,,,1,void leveldb._Test_TestOpenOnRead._Run ()
90303,METHOD,leveldb._Test_TestOpenOnRead,TYPE_DECL,"TEST(EnvPosixTest, TestOpenOnRead)",1,34,util\env_posix_test.cc,leveldb._Test_TestOpenOnRead._RunIt,,false,28,28,_RunIt,,,2,void leveldb._Test_TestOpenOnRead._RunIt ()
90327,METHOD,util\env_posix_test.cc:<global>,TYPE_DECL,"TEST(EnvPosixTest, TestOpenOnRead) {
  // Write some test data to a single file that will be opened |n| times.
  std::string test_dir;
  ASSERT_OK(env_->GetTestDirectory(&test_dir));
  std::string test_file = test_dir + ""/open_on_read.txt"";

  FILE* f = fopen(test_file.c_str(), ""w"");
  ASSERT_TRUE(f != NULL);
  const char kFileData[] = ""abcdefghijklmnopqrstuvwxyz"";
  fputs(kFileData, f);
  fclose(f);

  // Open test file some number above the sum of the two limits to force
  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.
  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;
  leveldb::RandomAccessFile* files[kNumFiles] = {0};
  for (int i = 0; i < kNumFiles; i++) {
    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));
  }
  char scratch;
  Slice read_result;
  for (int i = 0; i < kNumFiles; i++) {
    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));
    ASSERT_EQ(kFileData[i], read_result[0]);
  }
  for (int i = 0; i < kNumFiles; i++) {
   ...",1,34,util\env_posix_test.cc,leveldb._Test_TestOpenOnRead._Run,,false,28,57,_Run,,,11,void leveldb._Test_TestOpenOnRead._Run ()
90548,METHOD,util\env_posix_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  // All tests currently run with the same read-only file limits.
  leveldb::EnvPosixTest::SetFileLimits(leveldb::kReadOnlyFileLimit,
                                       leveldb::kMMapLimit);
  return leveldb::test::RunAllTests();
}",1,1,util\env_posix_test.cc,main,,false,61,66,main,,,2,"int main (int,char**)"
90576,METHOD,util\env_posix_test_helper.hpp:<global>,TYPE_DECL,<global>,1,56,util\env_posix_test_helper.hpp,util\env_posix_test_helper.hpp:<global>,,false,1,28,<global>,,,1,
90582,METHOD,leveldb.EnvPosixTestHelper,TYPE_DECL,static void SetReadOnlyFDLimit(int limit);,15,43,util\env_posix_test_helper.hpp,leveldb.EnvPosixTestHelper.SetReadOnlyFDLimit,,false,19,19,SetReadOnlyFDLimit,,,2,void leveldb.EnvPosixTestHelper.SetReadOnlyFDLimit (int)
90587,METHOD,leveldb.EnvPosixTestHelper,TYPE_DECL,static void SetReadOnlyMMapLimit(int limit);,15,45,util\env_posix_test_helper.hpp,leveldb.EnvPosixTestHelper.SetReadOnlyMMapLimit,,false,23,23,SetReadOnlyMMapLimit,,,3,void leveldb.EnvPosixTestHelper.SetReadOnlyMMapLimit (int)
90601,METHOD,util\env_test.cc:<global>,TYPE_DECL,<global>,1,1,util\env_test.cc,util\env_test.cc:<global>,,false,1,106,<global>,,,1,
90620,METHOD,leveldb.EnvTest,TYPE_DECL,EnvTest() : env_(Env::Default()) { },3,38,util\env_test.cc,leveldb.EnvTest.EnvTest,,false,23,23,EnvTest,,,4,ANY leveldb.EnvTest.EnvTest ()
90624,METHOD,util\env_test.cc:<global>,TYPE_DECL,"static void SetBool(void* ptr) {
  reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);
}",1,1,util\env_test.cc,leveldb.SetBool,,false,26,28,SetBool,,,8,void leveldb.SetBool (void*)
90637,METHOD,leveldb._Test_RunImmediately,TYPE_DECL,void void ();,1,29,util\env_test.cc,leveldb._Test_RunImmediately._Run,,false,30,30,_Run,,,1,void leveldb._Test_RunImmediately._Run ()
90641,METHOD,leveldb._Test_RunImmediately,TYPE_DECL,"TEST(EnvTest, RunImmediately)",1,29,util\env_test.cc,leveldb._Test_RunImmediately._RunIt,,false,30,30,_RunIt,,,2,void leveldb._Test_RunImmediately._RunIt ()
90665,METHOD,util\env_test.cc:<global>,TYPE_DECL,"TEST(EnvTest, RunImmediately) {
  port::AtomicPointer called (NULL);
  env_->Schedule(&SetBool, &called);
  env_->SleepForMicroseconds(kDelayMicros);
  ASSERT_TRUE(called.NoBarrier_Load() != NULL);
}",1,29,util\env_test.cc,leveldb._Test_RunImmediately._Run,,false,30,35,_Run,,,12,void leveldb._Test_RunImmediately._Run ()
90706,METHOD,leveldb._Test_RunMany,TYPE_DECL,void void ();,1,22,util\env_test.cc,leveldb._Test_RunMany._Run,,false,37,37,_Run,,,1,void leveldb._Test_RunMany._Run ()
90710,METHOD,leveldb._Test_RunMany,TYPE_DECL,"TEST(EnvTest, RunMany)",1,22,util\env_test.cc,leveldb._Test_RunMany._RunIt,,false,37,37,_RunIt,,,2,void leveldb._Test_RunMany._RunIt ()
90734,METHOD,util\env_test.cc:<global>,TYPE_DECL,"TEST(EnvTest, RunMany) {
  port::AtomicPointer last_id (NULL);

  struct CB {
    port::AtomicPointer* last_id_ptr;   // Pointer to shared slot
    uintptr_t id;             // Order# for the execution of this callback

    CB(port::AtomicPointer* p, int i) : last_id_ptr(p), id(i) { }

    static void Run(void* v) {
      CB* cb = reinterpret_cast<CB*>(v);
      void* cur = cb->last_id_ptr->NoBarrier_Load();
      ASSERT_EQ(cb->id-1, reinterpret_cast<uintptr_t>(cur));
      cb->last_id_ptr->Release_Store(reinterpret_cast<void*>(cb->id));
    }
  };

  // Schedule in different order than start time
  CB cb1(&last_id, 1);
  CB cb2(&last_id, 2);
  CB cb3(&last_id, 3);
  CB cb4(&last_id, 4);
  env_->Schedule(&CB::Run, &cb1);
  env_->Schedule(&CB::Run, &cb2);
  env_->Schedule(&CB::Run, &cb3);
  env_->Schedule(&CB::Run, &cb4);

  env_->SleepForMicroseconds(kDelayMicros);
  void* cur = last_id.Acquire_Load();
  ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));
}",1,22,util\env_test.cc,leveldb._Test_RunMany._Run,,false,37,67,_Run,,,16,void leveldb._Test_RunMany._Run ()
90838,METHOD,util\env_test.cc:<global>,TYPE_DECL,"static void ThreadBody(void* arg) {
  State* s = reinterpret_cast<State*>(arg);
  s->mu.Lock();
  s->val += 1;
  s->num_running -= 1;
  s->mu.Unlock();
}",1,1,util\env_test.cc,leveldb.ThreadBody,,false,75,81,ThreadBody,,,18,void leveldb.ThreadBody (void*)
90872,METHOD,leveldb._Test_StartThread,TYPE_DECL,void void ();,1,26,util\env_test.cc,leveldb._Test_StartThread._Run,,false,83,83,_Run,,,1,void leveldb._Test_StartThread._Run ()
90876,METHOD,leveldb._Test_StartThread,TYPE_DECL,"TEST(EnvTest, StartThread)",1,26,util\env_test.cc,leveldb._Test_StartThread._RunIt,,false,83,83,_RunIt,,,2,void leveldb._Test_StartThread._RunIt ()
90900,METHOD,util\env_test.cc:<global>,TYPE_DECL,"TEST(EnvTest, StartThread) {
  State state;
  state.val = 0;
  state.num_running = 3;
  for (int i = 0; i < 3; i++) {
    env_->StartThread(&ThreadBody, &state);
  }
  while (true) {
    state.mu.Lock();
    int num = state.num_running;
    state.mu.Unlock();
    if (num == 0) {
      break;
    }
    env_->SleepForMicroseconds(kDelayMicros);
  }
  ASSERT_EQ(state.val, 3);
}",1,26,util\env_test.cc,leveldb._Test_StartThread._Run,,false,83,100,_Run,,,22,void leveldb._Test_StartThread._Run ()
90988,METHOD,util\env_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\env_test.cc,main,,false,104,106,main,,,2,"int main (int,char**)"
91006,METHOD,util\filter_policy.cc:<global>,TYPE_DECL,<global>,1,1,util\filter_policy.cc,util\filter_policy.cc:<global>,,false,1,11,<global>,,,1,
91009,METHOD,util\filter_policy.cc:<global>,TYPE_DECL,FilterPolicy::~FilterPolicy() { },1,33,util\filter_policy.cc,leveldb.FilterPolicy.~FilterPolicy,,false,9,9,~FilterPolicy,,,1,ANY leveldb.FilterPolicy.~FilterPolicy ()
91022,METHOD,util\hash.cc:<global>,TYPE_DECL,<global>,1,22,util\hash.cc,util\hash.cc:<global>,,false,1,52,<global>,,,1,
91025,METHOD,util\hash.cc:<global>,TYPE_DECL,"uint32_t Hash(const char* data, size_t n, uint32_t seed) {
  // Similar to murmur hash
  const uint32_t m = 0xc6a4a793;
  const uint32_t r = 24;
  const char* limit = data + n;
  uint32_t h = seed ^ (n * m);

  // Pick up four bytes at a time
  while (data + 4 <= limit) {
    uint32_t w = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h >> 16);
  }

  // Pick up remaining bytes
  switch (limit - data) {
    case 3:
      h += static_cast<unsigned char>(data[2]) << 16;
      FALLTHROUGH_INTENDED;
    case 2:
      h += static_cast<unsigned char>(data[1]) << 8;
      FALLTHROUGH_INTENDED;
    case 1:
      h += static_cast<unsigned char>(data[0]);
      h *= m;
      h ^= (h >> r);
      break;
  }
  return h;
}",1,6,util\hash.cc,leveldb.Hash,,false,18,49,Hash,,,1,"uint32_t leveldb.Hash (char*,size_t,uint32_t)"
91144,METHOD,util\hash.hpp:<global>,TYPE_DECL,<global>,1,39,util\hash.hpp,util\hash.hpp:<global>,,false,1,19,<global>,,,1,
91147,METHOD,util\hash.hpp:<global>,TYPE_DECL,"extern uint32_t Hash(const char* data, size_t n, uint32_t seed);",17,63,util\hash.hpp,leveldb.Hash,,false,15,15,Hash,,,1,"uint32_t leveldb.Hash (char*,size_t,uint32_t)"
91161,METHOD,util\hash_test.cc:<global>,TYPE_DECL,<global>,1,1,util\hash_test.cc,util\hash_test.cc:<global>,,false,1,54,<global>,,,1,
91166,METHOD,leveldb._Test_SignedUnsignedIssue,TYPE_DECL,void void ();,1,31,util\hash_test.cc,leveldb._Test_SignedUnsignedIssue._Run,,false,12,12,_Run,,,1,void leveldb._Test_SignedUnsignedIssue._Run ()
91170,METHOD,leveldb._Test_SignedUnsignedIssue,TYPE_DECL,"TEST(HASH, SignedUnsignedIssue)",1,31,util\hash_test.cc,leveldb._Test_SignedUnsignedIssue._RunIt,,false,12,12,_RunIt,,,2,void leveldb._Test_SignedUnsignedIssue._RunIt ()
91194,METHOD,util\hash_test.cc:<global>,TYPE_DECL,"TEST(HASH, SignedUnsignedIssue) {
  const unsigned char data1[1] = {0x62};
  const unsigned char data2[2] = {0xc3, 0x97};
  const unsigned char data3[3] = {0xe2, 0x99, 0xa5};
  const unsigned char data4[4] = {0xe1, 0x80, 0xb9, 0x32};
  const unsigned char data5[48] = {
    0x01, 0xc0, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x14, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x04, 0x00,
    0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x00, 0x18,
    0x28, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
  };

  ASSERT_EQ(Hash(0, 0, 0xbc9f1d34), 0xbc9f1d34);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data1), sizeof(data1), 0xbc9f1d34),
      0xef1345c4);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data2), sizeof(data2), 0xbc9f1d34),
      0x5b663814);
  ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data3), sizeof(data3), 0xbc9f1d34),
      0x323c078f);
  ASSERT_...",1,31,util\hash_test.cc,leveldb._Test_SignedUnsignedIssue._Run,,false,12,48,_Run,,,5,void leveldb._Test_SignedUnsignedIssue._Run ()
91405,METHOD,util\hash_test.cc:<global>,TYPE_DECL,"int main(int argc, char** argv) {
  return leveldb::test::RunAllTests();
}",1,1,util\hash_test.cc,main,,false,52,54,main,,,2,"int main (int,char**)"
91429,METHOD,util\histogram.cc:<global>,TYPE_DECL,<global>,1,21,util\histogram.cc,util\histogram.cc:<global>,,false,1,139,<global>,,,1,
91590,METHOD,util\histogram.cc:<global>,TYPE_DECL,"void Histogram::Clear() {
  min_ = kBucketLimit[kNumBuckets-1];
  max_ = 0;
  num_ = 0;
  sum_ = 0;
  sum_squares_ = 0;
  for (int i = 0; i < kNumBuckets; i++) {
    buckets_[i] = 0;
  }
}",1,1,util\histogram.cc,leveldb.Histogram.Clear,,false,33,42,Clear,,,3,void leveldb.Histogram.Clear ()
91630,METHOD,util\histogram.cc:<global>,TYPE_DECL,"void Histogram::Add(double value) {
  // Linear search is fast enough for our usage in db_bench
  int b = 0;
  while (b < kNumBuckets - 1 && kBucketLimit[b] <= value) {
    b++;
  }
  buckets_[b] += 1.0;
  if (min_ > value) min_ = value;
  if (max_ < value) max_ = value;
  num_++;
  sum_ += value;
  sum_squares_ += (value * value);
}",1,1,util\histogram.cc,leveldb.Histogram.Add,,false,44,56,Add,,,4,void leveldb.Histogram.Add (double)
91685,METHOD,util\histogram.cc:<global>,TYPE_DECL,"void Histogram::Merge(const Histogram& other) {
  if (other.min_ < min_) min_ = other.min_;
  if (other.max_ > max_) max_ = other.max_;
  num_ += other.num_;
  sum_ += other.sum_;
  sum_squares_ += other.sum_squares_;
  for (int b = 0; b < kNumBuckets; b++) {
    buckets_[b] += other.buckets_[b];
  }
}",1,1,util\histogram.cc,leveldb.Histogram.Merge,,false,58,67,Merge,,,5,void leveldb.Histogram.Merge (Histogram)
91750,METHOD,util\histogram.cc:<global>,TYPE_DECL,"double Histogram::Median() const {
  return Percentile(50.0);
}",1,1,util\histogram.cc,leveldb.Histogram.Median,,false,69,71,Median,,,6,double leveldb.Histogram.Median ()
91757,METHOD,util\histogram.cc:<global>,TYPE_DECL,"double Histogram::Percentile(double p) const {
  double threshold = num_ * (p / 100.0);
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    sum += buckets_[b];
    if (sum >= threshold) {
      // Scale linearly within this bucket
      double left_point = (b == 0) ? 0 : kBucketLimit[b-1];
      double right_point = kBucketLimit[b];
      double left_sum = sum - buckets_[b];
      double right_sum = sum;
      double pos = (threshold - left_sum) / (right_sum - left_sum);
      double r = left_point + (right_point - left_point) * pos;
      if (r < min_) r = min_;
      if (r > max_) r = max_;
      return r;
    }
  }
  return max_;
}",1,1,util\histogram.cc,leveldb.Histogram.Percentile,,false,73,92,Percentile,,,7,double leveldb.Histogram.Percentile (double)
91867,METHOD,util\histogram.cc:<global>,TYPE_DECL,"double Histogram::Average() const {
  if (num_ == 0.0) return 0;
  return sum_ / num_;
}",1,1,util\histogram.cc,leveldb.Histogram.Average,,false,94,97,Average,,,8,double leveldb.Histogram.Average ()
91882,METHOD,util\histogram.cc:<global>,TYPE_DECL,"double Histogram::StandardDeviation() const {
  if (num_ == 0.0) return 0;
  double variance = (sum_squares_ * num_ - sum_ * sum_) / (num_ * num_);
  return sqrt(variance);
}",1,1,util\histogram.cc,leveldb.Histogram.StandardDeviation,,false,99,103,StandardDeviation,,,9,double leveldb.Histogram.StandardDeviation ()
91910,METHOD,util\histogram.cc:<global>,TYPE_DECL,"std::string Histogram::ToString() const {
  std::string r;
  char buf[200];
  snprintf(buf, sizeof(buf),
           ""Count: %.0f  Average: %.4f  StdDev: %.2f\n"",
           num_, Average(), StandardDeviation());
  r.append(buf);
  snprintf(buf, sizeof(buf),
           ""Min: %.4f  Median: %.4f  Max: %.4f\n"",
           (num_ == 0.0 ? 0.0 : min_), Median(), max_);
  r.append(buf);
  r.append(""------------------------------------------------------\n"");
  const double mult = 100.0 / num_;
  double sum = 0;
  for (int b = 0; b < kNumBuckets; b++) {
    if (buckets_[b] <= 0.0) continue;
    sum += buckets_[b];
    snprintf(buf, sizeof(buf),
             ""[ %7.0f, %7.0f ) %7.0f %7.3f%% %7.3f%% "",
             ((b == 0) ? 0.0 : kBucketLimit[b-1]),      // left
             kBucketLimit[b],                           // right
             buckets_[b],                               // count
             mult * buckets_[b],                        // percentage
             mult * sum);         ...",1,1,util\histogram.cc,leveldb.Histogram.ToString,,false,105,137,ToString,,,10,string leveldb.Histogram.ToString ()
92053,METHOD,util\histogram.hpp:<global>,TYPE_DECL,<global>,1,44,util\histogram.hpp,util\histogram.hpp:<global>,,false,1,42,<global>,,,1,
92057,METHOD,leveldb.Histogram,TYPE_DECL,Histogram() { },3,17,util\histogram.hpp,leveldb.Histogram.Histogram,,false,14,14,Histogram,,,1,ANY leveldb.Histogram.Histogram ()
92061,METHOD,leveldb.Histogram,TYPE_DECL,~Histogram() { },3,18,util\histogram.hpp,leveldb.Histogram.~Histogram,,false,15,15,~Histogram,,,2,ANY leveldb.Histogram.~Histogram ()
92065,METHOD,leveldb.Histogram,TYPE_DECL,void Clear();,8,14,util\histogram.hpp,leveldb.Histogram.Clear,,false,17,17,Clear,,,3,void leveldb.Histogram.Clear ()
92069,METHOD,leveldb.Histogram,TYPE_DECL,void Add(double value);,8,24,util\histogram.hpp,leveldb.Histogram.Add,,false,18,18,Add,,,4,void leveldb.Histogram.Add (double)
92074,METHOD,leveldb.Histogram,TYPE_DECL,void Merge(const Histogram& other);,8,36,util\histogram.hpp,leveldb.Histogram.Merge,,false,19,19,Merge,,,5,void leveldb.Histogram.Merge (Histogram)
92079,METHOD,leveldb.Histogram,TYPE_DECL,std::string ToString() const;,15,30,util\histogram.hpp,leveldb.Histogram.ToString,,false,21,21,ToString,,,6,ANY leveldb.Histogram.ToString ()
92090,METHOD,<empty>,<empty>,<empty>,3,,util\histogram.hpp,leveldb.Histogram.anonymous_enum_0:<clinit>,,false,30,,<clinit>,,,2,
92099,METHOD,leveldb.Histogram,TYPE_DECL,double Median() const;,10,23,util\histogram.hpp,leveldb.Histogram.Median,,false,34,34,Median,,,15,double leveldb.Histogram.Median ()
92103,METHOD,leveldb.Histogram,TYPE_DECL,double Percentile(double p) const;,10,35,util\histogram.hpp,leveldb.Histogram.Percentile,,false,35,35,Percentile,,,16,double leveldb.Histogram.Percentile (double)
92108,METHOD,leveldb.Histogram,TYPE_DECL,double Average() const;,10,24,util\histogram.hpp,leveldb.Histogram.Average,,false,36,36,Average,,,17,double leveldb.Histogram.Average ()
92112,METHOD,leveldb.Histogram,TYPE_DECL,double StandardDeviation() const;,10,34,util\histogram.hpp,leveldb.Histogram.StandardDeviation,,false,37,37,StandardDeviation,,,18,double leveldb.Histogram.StandardDeviation ()
92116,METHOD,<empty>,<empty>,<empty>,1,,util\histogram.hpp,leveldb.Histogram:<clinit>,,false,12,,<clinit>,,,19,
92141,METHOD,util\logging.cc:<global>,TYPE_DECL,<global>,1,1,util\logging.cc,util\logging.cc:<global>,,false,1,72,<global>,,,1,
92144,METHOD,util\logging.cc:<global>,TYPE_DECL,"void AppendNumberTo(std::string* str, uint64_t num) {
  char buf[30];
  snprintf(buf, sizeof(buf), ""%llu"", (unsigned long long) num);
  str->append(buf);
}",1,1,util\logging.cc,leveldb.AppendNumberTo,,false,16,20,AppendNumberTo,,,1,"void leveldb.AppendNumberTo (ANY*,uint64_t)"
92164,METHOD,util\logging.cc:<global>,TYPE_DECL,"void AppendEscapedStringTo(std::string* str, const Slice& value) {
  for (size_t i = 0; i < value.size(); i++) {
    char c = value[i];
    if (c >= ' ' && c <= '~') {
      str->push_back(c);
    } else {
      char buf[10];
      snprintf(buf, sizeof(buf), ""\\x%02x"",
               static_cast<unsigned int>(c) & 0xff);
      str->append(buf);
    }
  }
}",1,1,util\logging.cc,leveldb.AppendEscapedStringTo,,false,22,34,AppendEscapedStringTo,,,2,"void leveldb.AppendEscapedStringTo (ANY*,Slice)"
92223,METHOD,util\logging.cc:<global>,TYPE_DECL,"std::string NumberToString(uint64_t num) {
  std::string r;
  AppendNumberTo(&r, num);
  return r;
}",1,1,util\logging.cc,leveldb.NumberToString,,false,36,40,NumberToString,,,3,string leveldb.NumberToString (uint64_t)
92235,METHOD,util\logging.cc:<global>,TYPE_DECL,"std::string EscapeString(const Slice& value) {
  std::string r;
  AppendEscapedStringTo(&r, value);
  return r;
}",1,1,util\logging.cc,leveldb.EscapeString,,false,42,46,EscapeString,,,4,string leveldb.EscapeString (Slice)
92247,METHOD,util\logging.cc:<global>,TYPE_DECL,"bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {
  uint64_t v = 0;
  int digits = 0;
  while (!in->empty()) {
    char c = (*in)[0];
    if (c >= '0' && c <= '9') {
      ++digits;
      const int delta = (c - '0');
      static const uint64_t kMaxUint64 = ~static_cast<uint64_t>(0);
      if (v > kMaxUint64/10 ||
          (v == kMaxUint64/10 && delta > kMaxUint64%10)) {
        // Overflow
        return false;
      }
      v = (v * 10) + delta;
      in->remove_prefix(1);
    } else {
      break;
    }
  }
  *val = v;
  return (digits > 0);
}",1,1,util\logging.cc,leveldb.ConsumeDecimalNumber,,false,48,70,ConsumeDecimalNumber,,,5,"bool leveldb.ConsumeDecimalNumber (Slice*,uint64_t*)"
92354,METHOD,util\logging.hpp:<global>,TYPE_DECL,<global>,1,18,util\logging.hpp,util\logging.hpp:<global>,,false,1,43,<global>,,,1,
92359,METHOD,util\logging.hpp:<global>,TYPE_DECL,"extern void AppendNumberTo(std::string* str, uint64_t num);",13,58,util\logging.hpp,leveldb.AppendNumberTo,,false,22,22,AppendNumberTo,,,3,"void leveldb.AppendNumberTo (ANY*,uint64_t)"
92365,METHOD,util\logging.hpp:<global>,TYPE_DECL,"extern void AppendEscapedStringTo(std::string* str, const Slice& value);",13,71,util\logging.hpp,leveldb.AppendEscapedStringTo,,false,26,26,AppendEscapedStringTo,,,4,"void leveldb.AppendEscapedStringTo (ANY*,Slice)"
92371,METHOD,util\logging.hpp:<global>,TYPE_DECL,extern std::string NumberToString(uint64_t num);,20,47,util\logging.hpp,leveldb.NumberToString,,false,29,29,NumberToString,,,5,ANY leveldb.NumberToString (uint64_t)
92376,METHOD,util\logging.hpp:<global>,TYPE_DECL,extern std::string EscapeString(const Slice& value);,20,51,util\logging.hpp,leveldb.EscapeString,,false,33,33,EscapeString,,,6,ANY leveldb.EscapeString (Slice)
92381,METHOD,util\logging.hpp:<global>,TYPE_DECL,"extern bool ConsumeDecimalNumber(Slice* in, uint64_t* val);",13,58,util\logging.hpp,leveldb.ConsumeDecimalNumber,,false,39,39,ConsumeDecimalNumber,,,7,"bool leveldb.ConsumeDecimalNumber (Slice*,uint64_t*)"
92394,METHOD,util\mutexlock.hpp:<global>,TYPE_DECL,<global>,1,1,util\mutexlock.hpp,util\mutexlock.hpp:<global>,,false,1,41,<global>,,,1,
92398,METHOD,leveldb.MutexLock,TYPE_DECL,"explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)
      : mu_(mu)  {
    this->mu_->Lock();
  }",3,38,util\mutexlock.hpp,leveldb.MutexLock.MutexLock,,false,25,28,MutexLock,,,1,ANY leveldb.MutexLock.MutexLock (ANY*)
92409,METHOD,leveldb.MutexLock,TYPE_DECL,~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); },3,15,util\mutexlock.hpp,leveldb.MutexLock.~MutexLock,,false,29,29,~MutexLock,,,2,ANY leveldb.MutexLock.~MutexLock ()
92420,METHOD,leveldb.MutexLock,TYPE_DECL,MutexLock(const MutexLock&);,3,29,util\mutexlock.hpp,leveldb.MutexLock.MutexLock,,false,34,34,MutexLock,,,4,ANY leveldb.MutexLock.MutexLock (MutexLock)
92425,METHOD,leveldb.MutexLock,TYPE_DECL,void operator=(const MutexLock&);,8,34,util\mutexlock.hpp,leveldb.MutexLock.operator =,,false,35,35,operator =,,,5,void leveldb.MutexLock.operator = (MutexLock)
92439,METHOD,util\options.cc:<global>,TYPE_DECL,<global>,1,1,util\options.cc,util\options.cc:<global>,,false,1,30,<global>,,,1,
92442,METHOD,util\options.cc:<global>,TYPE_DECL,"Options::Options()
    : comparator(BytewiseComparator()),
      create_if_missing(false),
      error_if_exists(false),
      paranoid_checks(false),
      env(Env::Default()),
      info_log(NULL),
      write_buffer_size(4<<20),
      max_open_files(1000),
      block_cache(NULL),
      block_size(4096),
      block_restart_interval(16),
      max_file_size(2<<20),
      compression(kSnappyCompression),
      reuse_logs(false),
      filter_policy(NULL) {
}",1,1,util\options.cc,leveldb.Options.Options,,false,12,28,Options,,,1,ANY leveldb.Options.Options ()
92459,METHOD,util\posix_logger.hpp:<global>,TYPE_DECL,<global>,1,20,util\posix_logger.hpp,util\posix_logger.hpp:<global>,,false,1,98,<global>,,,1,
92464,METHOD,leveldb.PosixLogger,TYPE_DECL,uint64_t (*gettid_)();,12,23,util\posix_logger.hpp,leveldb.PosixLogger.gettid_,,false,22,22,gettid_,,,2,uint64_t leveldb.PosixLogger.gettid_ ()
92468,METHOD,leveldb.PosixLogger,TYPE_DECL,"PosixLogger(FILE* f, uint64_t (*gettid)()) : file_(f), gettid_(gettid) { }",3,76,util\posix_logger.hpp,leveldb.PosixLogger.PosixLogger,,false,24,24,PosixLogger,,,3,"ANY leveldb.PosixLogger.PosixLogger (FILE*,uint64_t)"
92474,METHOD,leveldb.PosixLogger,TYPE_DECL,"virtual ~PosixLogger() {
    fclose(file_);
  }",3,3,util\posix_logger.hpp,leveldb.PosixLogger.~PosixLogger,,false,25,27,~PosixLogger,,,4,ANY leveldb.PosixLogger.~PosixLogger ()
92480,METHOD,leveldb.PosixLogger,TYPE_DECL,"virtual void Logv(const char* format, va_list ap) {
    const uint64_t thread_id = (*gettid_)();

    // We try twice: the first time with a fixed-size stack allocated buffer,
    // and the second time with a much larger dynamically allocated buffer.
    char buffer[500];
    for (int iter = 0; iter < 2; iter++) {
      char* base;
      int bufsize;
      if (iter == 0) {
        bufsize = sizeof(buffer);
        base = buffer;
      } else {
        bufsize = 30000;
        base = new char[bufsize];
      }
      char* p = base;
      char* limit = base + bufsize;

      struct timeval now_tv;
      gettimeofday(&now_tv, NULL);
      const time_t seconds = now_tv.tv_sec;
      struct tm t;
      localtime_r(&seconds, &t);
      p += snprintf(p, limit - p,
                    ""%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "",
                    t.tm_year + 1900,
                    t.tm_mon + 1,
                    t.tm_mday,
                    t.tm_hour,
                    t.tm_min,
...",3,3,util\posix_logger.hpp,leveldb.PosixLogger.Logv,,false,28,93,Logv,,,5,"void leveldb.PosixLogger.Logv (char*,va_list)"
92674,METHOD,util\random.hpp:<global>,TYPE_DECL,<global>,1,41,util\random.hpp,util\random.hpp:<global>,,false,1,64,<global>,,,1,
92679,METHOD,leveldb.Random,TYPE_DECL,"explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {
    // Avoid bad seeds.
    if (seed_ == 0 || seed_ == 2147483647L) {
      seed_ = 1;
    }
  }",3,3,util\random.hpp,leveldb.Random.Random,,false,19,24,Random,,,2,ANY leveldb.Random.Random (uint32_t)
92696,METHOD,leveldb.Random,TYPE_DECL,"uint32_t Next() {
    static const uint32_t M = 2147483647L;   // 2^31-1
    static const uint64_t A = 16807;  // bits 14, 8, 7, 5, 2, 1, 0
    // We are computing
    //       seed_ = (seed_ * A) % M,    where M = 2^31-1
    //
    // seed_ must not be zero or M, or else all subsequent computed values
    // will be zero or M respectively.  For all other values, seed_ will end
    // up cycling through every number in [1,M-1]
    uint64_t product = seed_ * A;

    // Compute (product % M) using the fact that ((x << 31) % M) == x.
    seed_ = static_cast<uint32_t>((product >> 31) + (product & M));
    // The first reduction may overflow by 1 bit, so we may need to
    // repeat.  mod == M is not possible; using > allows the faster
    // sign-bit-based test.
    if (seed_ > M) {
      seed_ -= M;
    }
    return seed_;
  }",3,3,util\random.hpp,leveldb.Random.Next,,false,25,45,Next,,,3,uint32_t leveldb.Random.Next ()
92735,METHOD,leveldb.Random,TYPE_DECL,uint32_t Uniform(int n) { return Next() % n; },3,48,util\random.hpp,leveldb.Random.Uniform,,false,48,48,Uniform,,,4,uint32_t leveldb.Random.Uniform (int)
92744,METHOD,leveldb.Random,TYPE_DECL,bool OneIn(int n) { return (Next() % n) == 0; },3,49,util\random.hpp,leveldb.Random.OneIn,,false,52,52,OneIn,,,5,bool leveldb.Random.OneIn (int)
92755,METHOD,leveldb.Random,TYPE_DECL,"uint32_t Skewed(int max_log) {
    return Uniform(1 << Uniform(max_log + 1));
  }",3,3,util\random.hpp,leveldb.Random.Skewed,,false,57,59,Skewed,,,6,uint32_t leveldb.Random.Skewed (int)
92777,METHOD,util\status.cc:<global>,TYPE_DECL,<global>,1,21,util\status.cc,util\status.cc:<global>,,false,1,75,<global>,,,1,
92780,METHOD,util\status.cc:<global>,TYPE_DECL,"const char* Status::CopyState(const char* state) {
  uint32_t size;
  memcpy(&size, state, sizeof(size));
  char* result = new char[size + 5];
  memcpy(result, state, size + 5);
  return result;
}",1,1,util\status.cc,leveldb.Status.CopyState,,false,11,17,CopyState,,,1,const char* leveldb.Status.CopyState (char*)
92805,METHOD,util\status.cc:<global>,TYPE_DECL,"Status::Status(Code code, const Slice& msg, const Slice& msg2) {
  assert(code != kOk);
  const uint32_t len1 = msg.size();
  const uint32_t len2 = msg2.size();
  const uint32_t size = len1 + (len2 ? (2 + len2) : 0);
  char* result = new char[size + 5];
  memcpy(result, &size, sizeof(size));
  result[4] = static_cast<char>(code);
  memcpy(result + 5, msg.data(), len1);
  if (len2) {
    result[5 + len1] = ':';
    result[6 + len1] = ' ';
    memcpy(result + 7 + len1, msg2.data(), len2);
  }
  state_ = result;
}",1,1,util\status.cc,leveldb.Status.Status,,false,19,34,Status,,,2,"ANY leveldb.Status.Status (Code,Slice,Slice)"
92899,METHOD,util\status.cc:<global>,TYPE_DECL,"std::string Status::ToString() const {
  if (state_ == NULL) {
    return ""OK"";
  } else {
    char tmp[30];
    const char* type;
    switch (code()) {
      case kOk:
        type = ""OK"";
        break;
      case kNotFound:
        type = ""NotFound: "";
        break;
      case kCorruption:
        type = ""Corruption: "";
        break;
      case kNotSupported:
        type = ""Not implemented: "";
        break;
      case kInvalidArgument:
        type = ""Invalid argument: "";
        break;
      case kIOError:
        type = ""IO error: "";
        break;
      default:
        snprintf(tmp, sizeof(tmp), ""Unknown code(%d): "",
                 static_cast<int>(code()));
        type = tmp;
        break;
    }
    std::string result(type);
    uint32_t length;
    memcpy(&length, state_, sizeof(length));
    result.append(state_ + 5, length);
    return result;
  }
}",1,1,util\status.cc,leveldb.Status.ToString,,false,36,73,ToString,,,3,string leveldb.Status.ToString ()
92999,METHOD,util\testharness.cc:<global>,TYPE_DECL,<global>,1,1,util\testharness.cc,util\testharness.cc:<global>,,false,1,77,<global>,,,1,
93007,METHOD,leveldb.test.anonymous_namespace_1.Test,TYPE_DECL,void (*func)();,8,16,util\testharness.cc,leveldb.test.anonymous_namespace_2.Test.func,,false,19,19,func,,,3,void leveldb.test.anonymous_namespace_2.Test.func ()
93012,METHOD,util\testharness.cc:<global>,TYPE_DECL,"bool RegisterTest(const char* base, const char* name, void (*func)()) {
  if (tests == NULL) {
    tests = new std::vector<Test>;
  }
  Test t;
  t.base = base;
  t.name = name;
  t.func = func;
  tests->push_back(t);
  return true;
}",1,1,util\testharness.cc,leveldb.test.RegisterTest,,false,24,34,RegisterTest,,,2,"bool leveldb.test.RegisterTest (char*,char*,void)"
93051,METHOD,util\testharness.cc:<global>,TYPE_DECL,"int RunAllTests() {
  const char* matcher = getenv(""LEVELDB_TESTS"");

  int num = 0;
  if (tests != NULL) {
    for (size_t i = 0; i < tests->size(); i++) {
      const Test& t = (*tests)[i];
      if (matcher != NULL) {
        std::string name = t.base;
        name.push_back('.');
        name.append(t.name);
        if (strstr(name.c_str(), matcher) == NULL) {
          continue;
        }
      }
      fprintf(stderr, ""==== Test %s.%s\n"", t.base, t.name);
      (*t.func)();
      ++num;
    }
  }
  fprintf(stderr, ""==== PASSED %d tests\n"", num);
  return 0;
}",1,1,util\testharness.cc,leveldb.test.RunAllTests,,false,36,58,RunAllTests,,,3,int leveldb.test.RunAllTests ()
93147,METHOD,util\testharness.cc:<global>,TYPE_DECL,"std::string TmpDir() {
  std::string dir;
  Status s = Env::Default()->GetTestDirectory(&dir);
  ASSERT_TRUE(s.ok()) << s.ToString();
  return dir;
}",1,2,util\testharness.cc,leveldb.test.TmpDir,,false,60,65,TmpDir,,,4,string leveldb.test.TmpDir ()
93193,METHOD,util\testharness.cc:<global>,TYPE_DECL,"int RandomSeed() {
  const char* env = getenv(""TEST_RANDOM_SEED"");
  int result = (env != NULL ? atoi(env) : 301);
  if (result <= 0) {
    result = 301;
  }
  return result;
}",1,1,util\testharness.cc,leveldb.test.RandomSeed,,false,67,74,RandomSeed,,,5,int leveldb.test.RandomSeed ()
93237,METHOD,util\testharness.hpp:<global>,TYPE_DECL,<global>,1,19,util\testharness.hpp,util\testharness.hpp:<global>,,false,1,138,<global>,,,1,
93241,METHOD,util\testharness.hpp:<global>,TYPE_DECL,extern int RunAllTests();,12,24,util\testharness.hpp,leveldb.test.RunAllTests,,false,30,30,RunAllTests,,,1,int leveldb.test.RunAllTests ()
93245,METHOD,util\testharness.hpp:<global>,TYPE_DECL,extern std::string TmpDir();,20,27,util\testharness.hpp,leveldb.test.TmpDir,,false,33,33,TmpDir,,,2,ANY leveldb.test.TmpDir ()
93249,METHOD,util\testharness.hpp:<global>,TYPE_DECL,extern int RandomSeed();,12,23,util\testharness.hpp,leveldb.test.RandomSeed,,false,38,38,RandomSeed,,,3,int leveldb.test.RandomSeed ()
93258,METHOD,leveldb.test.Tester,TYPE_DECL,"Tester(const char* f, int l)
      : ok_(true), fname_(f), line_(l) {
  }",3,3,util\testharness.hpp,leveldb.test.Tester.Tester,,false,50,52,Tester,,,5,"ANY leveldb.test.Tester.Tester (char*,int)"
93264,METHOD,leveldb.test.Tester,TYPE_DECL,"~Tester() {
    if (!ok_) {
      fprintf(stderr, ""%s:%d:%s\n"", fname_, line_, ss_.str().c_str());
      exit(1);
    }
  }",3,3,util\testharness.hpp,leveldb.test.Tester.~Tester,,false,54,59,~Tester,,,6,ANY leveldb.test.Tester.~Tester ()
93286,METHOD,leveldb.test.Tester,TYPE_DECL,"Tester& Is(bool b, const char* msg) {
    if (!b) {
      ss_ << "" Assertion failure "" << msg;
      ok_ = false;
    }
    return *this;
  }",3,3,util\testharness.hpp,leveldb.test.Tester.Is,,false,61,67,Is,,,7,"Tester leveldb.test.Tester.Is (bool,char*)"
93307,METHOD,leveldb.test.Tester,TYPE_DECL,"Tester& IsOk(const Status& s) {
    if (!s.ok()) {
      ss_ << "" "" << s.ToString();
      ok_ = false;
    }
    return *this;
  }",3,3,util\testharness.hpp,leveldb.test.Tester.IsOk,,false,69,75,IsOk,,,8,Tester leveldb.test.Tester.IsOk (Status)
93333,METHOD,leveldb.test.Tester,TYPE_DECL,"BINARY_OP(IsEq, ==)",3,21,util\testharness.hpp,leveldb.test.Tester.IsEq,,false,87,87,IsEq,,,9,"Tester leveldb.test.Tester.IsEq<X,Y> (X,Y)"
93360,METHOD,leveldb.test.Tester,TYPE_DECL,"BINARY_OP(IsNe, !=)",3,21,util\testharness.hpp,leveldb.test.Tester.IsNe,,false,88,88,IsNe,,,10,"Tester leveldb.test.Tester.IsNe<X,Y> (X,Y)"
93387,METHOD,leveldb.test.Tester,TYPE_DECL,"BINARY_OP(IsGe, >=)",3,21,util\testharness.hpp,leveldb.test.Tester.IsGe,,false,89,89,IsGe,,,11,"Tester leveldb.test.Tester.IsGe<X,Y> (X,Y)"
93414,METHOD,leveldb.test.Tester,TYPE_DECL,"BINARY_OP(IsGt, >)",3,20,util\testharness.hpp,leveldb.test.Tester.IsGt,,false,90,90,IsGt,,,12,"Tester leveldb.test.Tester.IsGt<X,Y> (X,Y)"
93441,METHOD,leveldb.test.Tester,TYPE_DECL,"BINARY_OP(IsLe, <=)",3,21,util\testharness.hpp,leveldb.test.Tester.IsLe,,false,91,91,IsLe,,,13,"Tester leveldb.test.Tester.IsLe<X,Y> (X,Y)"
93468,METHOD,leveldb.test.Tester,TYPE_DECL,"BINARY_OP(IsLt, <)",3,20,util\testharness.hpp,leveldb.test.Tester.IsLt,,false,92,92,IsLt,,,14,"Tester leveldb.test.Tester.IsLt<X,Y> (X,Y)"
93495,METHOD,leveldb.test.Tester,TYPE_DECL,"Tester& operator<<(const V& value) {
    if (!ok_) {
      ss_ << "" "" << value;
    }
    return *this;
  }",3,3,util\testharness.hpp,leveldb.test.Tester.operator <<,,false,97,102,operator <<,,,15,Tester leveldb.test.Tester.operator <<<V> (V)
93512,METHOD,util\testharness.hpp:<global>,TYPE_DECL,"extern bool RegisterTest(const char* base, const char* name, void (*func)());",13,76,util\testharness.hpp,leveldb.test.RegisterTest,,false,132,132,RegisterTest,,,5,"bool leveldb.test.RegisterTest (char*,char*,void)"
93526,METHOD,util\testutil.cc:<global>,TYPE_DECL,<global>,1,1,util\testutil.cc,util\testutil.cc:<global>,,false,1,51,<global>,,,1,
93530,METHOD,util\testutil.cc:<global>,TYPE_DECL,"Slice RandomString(Random* rnd, int len, std::string* dst) {
  dst->resize(len);
  for (int i = 0; i < len; i++) {
    (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));   // ' ' .. '~'
  }
  return Slice(*dst);
}",1,1,util\testutil.cc,leveldb.test.RandomString,,false,12,18,RandomString,,,1,"Slice leveldb.test.RandomString (Random*,int,ANY*)"
93572,METHOD,util\testutil.cc:<global>,TYPE_DECL,"std::string RandomKey(Random* rnd, int len) {
  // Make sure to generate a wide variety of characters so we
  // test the boundary conditions for short-key optimizations.
  static const char kTestChars[] = {
    '\0', '\1', 'a', 'b', 'c', 'd', 'e', '\xfd', '\xfe', '\xff'
  };
  std::string result;
  for (int i = 0; i < len; i++) {
    result += kTestChars[rnd->Uniform(sizeof(kTestChars))];
  }
  return result;
}",1,1,util\testutil.cc,leveldb.test.RandomKey,,false,20,31,RandomKey,,,2,"string leveldb.test.RandomKey (Random*,int)"
93617,METHOD,util\testutil.cc:<global>,TYPE_DECL,"extern Slice CompressibleString(Random* rnd, double compressed_fraction,
                                size_t len, std::string* dst) {
  int raw = static_cast<int>(len * compressed_fraction);
  if (raw < 1) raw = 1;
  std::string raw_data;
  RandomString(rnd, raw, &raw_data);

  // Duplicate the random data until we have filled ""len"" bytes
  dst->clear();
  while (dst->size() < len) {
    dst->append(raw_data);
  }
  dst->resize(len);
  return Slice(*dst);
}",1,1,util\testutil.cc,leveldb.test.CompressibleString,,false,34,48,CompressibleString,,,3,"Slice leveldb.test.CompressibleString (Random*,double,size_t,ANY*)"
93682,METHOD,util\testutil.hpp:<global>,TYPE_DECL,<global>,1,1,util\testutil.hpp,util\testutil.hpp:<global>,,false,1,63,<global>,,,1,
93686,METHOD,util\testutil.hpp:<global>,TYPE_DECL,"extern Slice RandomString(Random* rnd, int len, std::string* dst);",14,65,util\testutil.hpp,leveldb.test.RandomString,,false,17,17,RandomString,,,1,"Slice leveldb.test.RandomString (Random*,int,ANY*)"
93693,METHOD,util\testutil.hpp:<global>,TYPE_DECL,"extern std::string RandomKey(Random* rnd, int len);",20,50,util\testutil.hpp,leveldb.test.RandomKey,,false,21,21,RandomKey,,,2,"ANY leveldb.test.RandomKey (Random*,int)"
93699,METHOD,util\testutil.hpp:<global>,TYPE_DECL,"extern Slice CompressibleString(Random* rnd, double compressed_fraction,
                                size_t len, std::string* dst);",14,61,util\testutil.hpp,leveldb.test.CompressibleString,,false,26,27,CompressibleString,,,3,"Slice leveldb.test.CompressibleString (Random*,double,size_t,ANY*)"
93710,METHOD,leveldb.test.ErrorEnv,TYPE_DECL,"ErrorEnv() : EnvWrapper(Env::Default()),
               writable_file_error_(false),
               num_writable_file_errors_(0) { }",3,47,util\testutil.hpp,leveldb.test.ErrorEnv.ErrorEnv,,false,35,37,ErrorEnv,,,3,ANY leveldb.test.ErrorEnv.ErrorEnv ()
93714,METHOD,leveldb.test.ErrorEnv,TYPE_DECL,"virtual Status NewWritableFile(const std::string& fname,
                                 WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewWritableFile(fname, result);
  }",3,3,util\testutil.hpp,leveldb.test.ErrorEnv.NewWritableFile,,false,39,47,NewWritableFile,,,4,"Status leveldb.test.ErrorEnv.NewWritableFile (ANY,WritableFile**)"
93743,METHOD,leveldb.test.ErrorEnv,TYPE_DECL,"virtual Status NewAppendableFile(const std::string& fname,
                                   WritableFile** result) {
    if (writable_file_error_) {
      ++num_writable_file_errors_;
      *result = NULL;
      return Status::IOError(fname, ""fake error"");
    }
    return target()->NewAppendableFile(fname, result);
  }",3,3,util\testutil.hpp,leveldb.test.ErrorEnv.NewAppendableFile,,false,49,57,NewAppendableFile,,,5,"Status leveldb.test.ErrorEnv.NewAppendableFile (ANY,WritableFile**)"
95537,METHOD,<includes>:<global>,NAMESPACE_BLOCK,<global>,,,<includes>,<includes>:<global>,,false,1,,<global>,,,1,
95678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignment,,true,,,<operator>.assignment,,,0,
95683,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addition,,true,,,<operator>.addition,,,0,
95688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,test.TmpDir,,true,,,test.TmpDir,,,0,
95692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.fieldAccess,,true,,,<operator>.fieldAccess,,,0,
95697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewLRUCache,,true,,,NewLRUCache,,,0,
95701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DestroyDB,,true,,,DestroyDB,,,0,
95706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:106:106:ASSERT_OK:1,,true,106,106,ASSERT_OK,,,0,
95710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(DB.Open(options_, dbname_, &db_))",,true,,,"ASSERT_OK(DB.Open(options_, dbname_, &db_))",,,0,
95717,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.addressOf,,true,,,<operator>.addressOf,,,0,
95721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.delete,,true,,,<operator>.delete,,,0,
95725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Options,,true,,,Options,,,0,
95728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,snprintf,,true,,,snprintf,,,0,
95735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.sizeOf,,true,,,<operator>.sizeOf,,,0,
95739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.string,,true,,,std.string,,,0,
95745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,r,,true,,,r,,,0,
95749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetApproximateSizes,,true,,,GetApproximateSizes,,,0,
95756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectFieldAccess,,true,,,<operator>.indirectFieldAccess,,,0,
95761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.multiplication,,true,,,<operator>.multiplication,,,0,
95766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.division,,true,,,<operator>.division,,,0,
95771,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,value,,true,,,value,,,0,
95775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.cast,,true,,,<operator>.cast,,,0,
95780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessThan,,true,,,<operator>.lessThan,,,0,
95785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postIncrement,,true,,,<operator>.postIncrement,,,0,
95789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), Key(i), value))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), Key(i), value))",,,0,
95796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteOptions,,true,,,WriteOptions,,,0,
95799,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AutoCompactTest.Key,,true,,,Key,,,0,
95803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(dbi->TEST_CompactMemTable()),,true,,,ASSERT_OK(dbi->TEST_CompactMemTable()),,,0,
95807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Delete(WriteOptions(), Key(i)))",,true,,,"ASSERT_OK(db_->Delete(WriteOptions(), Key(i)))",,,0,
95813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AutoCompactTest.Size,,true,,,Size,,,0,
95818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.shiftLeft,,true,,,<operator>.shiftLeft,,,0,
95823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:112:112:ASSERT_LT:2,,true,112,112,ASSERT_LT,,,0,
95828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(read, 100)",,true,,,"ASSERT_LT(read, 100)",,,0,
95834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewIterator,,true,,,NewIterator,,,0,
95838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadOptions,,true,,,ReadOptions,,,0,
95841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SeekToFirst,,true,,,SeekToFirst,,,0,
95845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalAnd,,true,,,<operator>.logicalAnd,,,0,
95850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Valid,,true,,,Valid,,,0,
95854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ToString,,true,,,ToString,,,0,
95858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key,,true,,,key,,,0,
95862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Next,,true,,,Next,,,0,
95866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SleepForMicroseconds,,true,,,SleepForMicroseconds,,,0,
95871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Env.Default,,true,,,Env.Default,,,0,
95875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fprintf,,true,,,fprintf,,,0,
95883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.lessEqualsThan,,true,,,<operator>.lessEqualsThan,,,0,
95888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:111:111:ASSERT_LE:2,,true,111,111,ASSERT_LE,,,0,
95892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(final_other_size, initial_other_size + 1048576)",,true,,,"ASSERT_LE(final_other_size, initial_other_size + 1048576)",,,0,
95898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:109:109:ASSERT_GE:2,,true,109,109,ASSERT_GE,,,0,
95903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(final_other_size, initial_other_size/5 - 1048576)",,true,,,"ASSERT_GE(final_other_size, initial_other_size/5 - 1048576)",,,0,
95909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.subtraction,,true,,,<operator>.subtraction,,,0,
95914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadAll.TEST(AutoCompactTest, ReadAll)",,true,,,"TEST(AutoCompactTest, ReadAll)",,,0,
95918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(AutoCompactTest, ReadAll)",,true,,,"TEST(AutoCompactTest, ReadAll)",,,0,
95925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadAll.DoReads,,true,,,DoReads,,,0,
95929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadHalf.TEST(AutoCompactTest, ReadHalf)",,true,,,"TEST(AutoCompactTest, ReadHalf)",,,0,
95933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(AutoCompactTest, ReadHalf)",,true,,,"TEST(AutoCompactTest, ReadHalf)",,,0,
95940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadHalf.DoReads,,true,,,DoReads,,,0,
95944,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableFileName,,true,,,TableFileName,,,0,
95949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewWritableFile,,true,,,NewWritableFile,,,0,
95955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalNot,,true,,,<operator>.logicalNot,,,0,
95959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.ok,,true,,,ok,,,0,
95963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.new,,true,,,<operator>.new,,,0,
95967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeFrom,,true,,,DecodeFrom,,,0,
95972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Add,,true,,,Add,,,0,
95977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Finish,,true,,,Finish,,,0,
95984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileSize,,true,,,FileSize,,,0,
95988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assert,,true,,,assert,,,0,
95992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterThan,,true,,,<operator>.greaterThan,,,0,
95997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Abandon,,true,,,Abandon,,,0,
96001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Sync,,true,,,Sync,,,0,
96005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Close,,true,,,Close,,,0,
96009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,status,,true,,,status,,,0,
96013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ok,,true,,,ok,,,0,
96017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteFile,,true,,,DeleteFile,,,0,
96022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*destructor_,,true,,,*destructor_,,,0,
96027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirection,,true,,,<operator>.indirection,,,0,
96031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*compare_,,true,,,*compare_,,,0,
96040,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,data,,true,,,data,,,0,
96044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,size,,true,,,size,,,0,
96048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*name_,,true,,,*name_,,,0,
96053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_pointers,,true,,,key_pointers,,,0,
96057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,key_sizes,,true,,,key_sizes,,,0,
96061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.indirectIndexAccess,,true,,,<operator>.indirectIndexAccess,,,0,
96066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*create_,,true,,,*create_,,,0,
96075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,append,,true,,,append,,,0,
96080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,free,,true,,,free,,,0,
96084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*key_match_,,true,,,*key_match_,,,0,
96093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.notEquals,,true,,,<operator>.notEquals,,,0,
96098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.equals,,true,,,<operator>.equals,,,0,
96103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strdup,,true,,,strdup,,,0,
96107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,c_str,,true,,,c_str,,,0,
96111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,malloc,,true,,,malloc,,,0,
96115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcpy,,true,,,memcpy,,,0,
96121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DB.Open,,true,,,DB.Open,,,0,
96128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Put,,true,,,Put,,,0,
96134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice,,true,,,Slice,,,0,
96138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Delete,,true,,,Delete,,,0,
96143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Write,,true,,,Write,,,0,
96147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Get,,true,,,Get,,,0,
96157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.IsNotFound,,true,,,IsNotFound,,,0,
96161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetSnapshot,,true,,,GetSnapshot,,,0,
96165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseSnapshot,,true,,,ReleaseSnapshot,,,0,
96170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetProperty,,true,,,GetProperty,,,0,
96176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CompactRange,,true,,,CompactRange,,,0,
96182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.conditional,,true,,,<operator>.conditional,,,0,
96188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.bracketedPrimary,,true,,,<operator>.bracketedPrimary,,,0,
96192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.expressionList,,true,,,<operator>.expressionList,,,0,
96197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RepairDB,,true,,,RepairDB,,,0,
96202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SeekToLast,,true,,,SeekToLast,,,0,
96206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Seek,,true,,,Seek,,,0,
96211,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Prev,,true,,,Prev,,,0,
96215,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.size,,true,,,size,,,0,
96219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.data,,true,,,data,,,0,
96223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Clear,,true,,,Clear,,,0,
96227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iterate,,true,,,Iterate,,,0,
96232,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewBloomFilterPolicy,,true,,,NewBloomFilterPolicy,,,0,
96236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arrayInitializer,,true,,,<operator>.arrayInitializer,,,0,
96249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getenv,,true,,,getenv,,,0,
96253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.logicalOr,,true,,,<operator>.logicalOr,,,0,
96258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strlen,,true,,,strlen,,,0,
96262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memcmp,,true,,,memcmp,,,0,
96268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,abort,,true,,,abort,,,0,
96271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,db\c_test.c,db\c_test.c:29:33:CheckNoError:1,,true,29,33,CheckNoError,,,0,
96275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,db\c_test.c,db\c_test.c:35:39:CheckCondition:1,,true,35,39,CheckCondition,,,0,
96278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.minus,,true,,,<operator>.minus,,,0,
96282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.plus,,true,,,<operator>.plus,,,0,
96286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.greaterEqualsThan,,true,,,<operator>.greaterEqualsThan,,,0,
96291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,geteuid,,true,,,geteuid,,,0,
96294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CorruptionTest.Reopen,,true,,,Reopen,,,0,
96297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CorruptionTest.TryReopen,,true,,,TryReopen,,,0,
96300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(TryReopen()),,true,,,ASSERT_OK(TryReopen()),,,0,
96306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(.leveldb.RepairDB(dbname_, options_))",,true,,,"ASSERT_OK(.leveldb.RepairDB(dbname_, options_))",,,0,
96312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CorruptionTest.Key,,true,,,Key,,,0,
96317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatch.Clear,,true,,,Clear,,,0,
96321,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatch.Put,,true,,,Put,,,0,
96327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CorruptionTest.Value,,true,,,Value,,,0,
96332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Write(options, &batch))",,true,,,"ASSERT_OK(db_->Write(options, &batch))",,,0,
96338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,in,,true,,,in,,,0,
96342,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConsumeDecimalNumber,,true,,,ConsumeDecimalNumber,,,0,
96347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.empty,,true,,,empty,,,0,
96351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentPlus,,true,,,<operator>.assignmentPlus,,,0,
96356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Value,,true,,,Value,,,0,
96361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(min_expected, correct)",,true,,,"ASSERT_LE(min_expected, correct)",,,0,
96367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(max_expected, correct)",,true,,,"ASSERT_GE(max_expected, correct)",,,0,
96373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_.GetChildren(dbname_, &filenames))",,true,,,"ASSERT_OK(env_.GetChildren(dbname_, &filenames))",,,0,
96379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseFileName,,true,,,ParseFileName,,,0,
96385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,int,,true,,,int,,,0,
96389,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.constructorInitializer,,true,,,<operator>.constructorInitializer,,,0,
96393,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:105:105:ASSERT_TRUE:1,,true,105,105,ASSERT_TRUE,,,0,
96397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!fname.empty()),,true,,,ASSERT_TRUE(!fname.empty()),,,0,
96401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,stat,,true,,,stat,,,0,
96406,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strerror,,true,,,strerror,,,0,
96410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(false),,true,,,ASSERT_TRUE(false),,,0,
96416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadFileToString,,true,,,ReadFileToString,,,0,
96422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.ASSERT_TRUE(s.ok()),,true,,,ASSERT_TRUE(s.ok()),,,0,
96426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(s.ok()),,true,,,ASSERT_TRUE(s.ok()),,,0,
96432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.ToString,,true,,,ToString,,,0,
96436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentXor,,true,,,<operators>.assignmentXor,,,0,
96441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteStringToFile,,true,,,WriteStringToFile,,,0,
96447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sscanf,,true,,,sscanf,,,0,
96454,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,assign,,true,,,assign,,,0,
96460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,test.RandomString,,true,,,test.RandomString,,,0,
96467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Recovery.TEST(CorruptionTest, Recovery)",,true,,,"TEST(CorruptionTest, Recovery)",,,0,
96471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, Recovery)",,true,,,"TEST(CorruptionTest, Recovery)",,,0,
96478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Recovery.Build,,true,,,Build,,,0,
96482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Recovery.Check,,true,,,Check,,,0,
96487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Recovery.Corrupt,,true,,,Corrupt,,,0,
96493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Recovery.Reopen,,true,,,Reopen,,,0,
96496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RecoverWriteError.TEST(CorruptionTest, RecoverWriteError)",,true,,,"TEST(CorruptionTest, RecoverWriteError)",,,0,
96500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, RecoverWriteError)",,true,,,"TEST(CorruptionTest, RecoverWriteError)",,,0,
96507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverWriteError.TryReopen,,true,,,TryReopen,,,0,
96510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.ASSERT_TRUE(!s.ok()),,true,,,ASSERT_TRUE(!s.ok()),,,0,
96514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!s.ok()),,true,,,ASSERT_TRUE(!s.ok()),,,0,
96520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_NewFileErrorDuringWrite.TEST(CorruptionTest, NewFileErrorDuringWrite)",,true,,,"TEST(CorruptionTest, NewFileErrorDuringWrite)",,,0,
96524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, NewFileErrorDuringWrite)",,true,,,"TEST(CorruptionTest, NewFileErrorDuringWrite)",,,0,
96531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NewFileErrorDuringWrite.Value,,true,,,Value,,,0,
96536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(env_.num_writable_file_errors_, 1)",,true,,,"ASSERT_GE(env_.num_writable_file_errors_, 1)",,,0,
96542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NewFileErrorDuringWrite.Reopen,,true,,,Reopen,,,0,
96545,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_TableFile.TEST(CorruptionTest, TableFile)",,true,,,"TEST(CorruptionTest, TableFile)",,,0,
96549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, TableFile)",,true,,,"TEST(CorruptionTest, TableFile)",,,0,
96556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFile.Build,,true,,,Build,,,0,
96560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TEST_CompactMemTable,,true,,,TEST_CompactMemTable,,,0,
96564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TEST_CompactRange,,true,,,TEST_CompactRange,,,0,
96571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFile.Corrupt,,true,,,Corrupt,,,0,
96577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFile.Check,,true,,,Check,,,0,
96582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_TableFileRepair.TEST(CorruptionTest, TableFileRepair)",,true,,,"TEST(CorruptionTest, TableFileRepair)",,,0,
96586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, TableFileRepair)",,true,,,"TEST(CorruptionTest, TableFileRepair)",,,0,
96593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileRepair.Reopen,,true,,,Reopen,,,0,
96596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileRepair.Build,,true,,,Build,,,0,
96600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileRepair.Corrupt,,true,,,Corrupt,,,0,
96606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileRepair.RepairDB,,true,,,RepairDB,,,0,
96609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileRepair.Check,,true,,,Check,,,0,
96614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_TableFileIndexData.TEST(CorruptionTest, TableFileIndexData)",,true,,,"TEST(CorruptionTest, TableFileIndexData)",,,0,
96618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, TableFileIndexData)",,true,,,"TEST(CorruptionTest, TableFileIndexData)",,,0,
96625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileIndexData.Build,,true,,,Build,,,0,
96629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileIndexData.Corrupt,,true,,,Corrupt,,,0,
96635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileIndexData.Reopen,,true,,,Reopen,,,0,
96638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TableFileIndexData.Check,,true,,,Check,,,0,
96643,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MissingDescriptor.TEST(CorruptionTest, MissingDescriptor)",,true,,,"TEST(CorruptionTest, MissingDescriptor)",,,0,
96647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, MissingDescriptor)",,true,,,"TEST(CorruptionTest, MissingDescriptor)",,,0,
96654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingDescriptor.Build,,true,,,Build,,,0,
96658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingDescriptor.RepairDB,,true,,,RepairDB,,,0,
96661,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingDescriptor.Reopen,,true,,,Reopen,,,0,
96664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingDescriptor.Check,,true,,,Check,,,0,
96669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SequenceNumberRecovery.TEST(CorruptionTest, SequenceNumberRecovery)",,true,,,"TEST(CorruptionTest, SequenceNumberRecovery)",,,0,
96673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, SequenceNumberRecovery)",,true,,,"TEST(CorruptionTest, SequenceNumberRecovery)",,,0,
96680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v1""))",,,0,
96687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v2""))",,,0,
96694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v3""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v3""))",,,0,
96701,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v4""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v4""))",,,0,
96708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v5""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v5""))",,,0,
96715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SequenceNumberRecovery.RepairDB,,true,,,RepairDB,,,0,
96718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SequenceNumberRecovery.Reopen,,true,,,Reopen,,,0,
96721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v))",,true,,,"ASSERT_OK(db_->Get(ReadOptions(), ""foo"", &v))",,,0,
96728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:107:107:ASSERT_EQ:2,,true,107,107,ASSERT_EQ,,,0,
96732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v5"", v)",,true,,,"ASSERT_EQ(""v5"", v)",,,0,
96738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v6""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""v6""))",,,0,
96745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v6"", v)",,true,,,"ASSERT_EQ(""v6"", v)",,,0,
96751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_CorruptedDescriptor.TEST(CorruptionTest, CorruptedDescriptor)",,true,,,"TEST(CorruptionTest, CorruptedDescriptor)",,,0,
96755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, CorruptedDescriptor)",,true,,,"TEST(CorruptionTest, CorruptedDescriptor)",,,0,
96762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""hello""))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), ""foo"", ""hello""))",,,0,
96769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CorruptedDescriptor.Corrupt,,true,,,Corrupt,,,0,
96775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CorruptedDescriptor.TryReopen,,true,,,TryReopen,,,0,
96778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CorruptedDescriptor.RepairDB,,true,,,RepairDB,,,0,
96781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CorruptedDescriptor.Reopen,,true,,,Reopen,,,0,
96784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""hello"", v)",,true,,,"ASSERT_EQ(""hello"", v)",,,0,
96790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_CompactionInputError.TEST(CorruptionTest, CompactionInputError)",,true,,,"TEST(CorruptionTest, CompactionInputError)",,,0,
96794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, CompactionInputError)",,true,,,"TEST(CorruptionTest, CompactionInputError)",,,0,
96801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputError.Build,,true,,,Build,,,0,
96805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, Property(""leveldb.num-files-at-level"" + NumberToString(last)))",,true,,,"ASSERT_EQ(1, Property(""leveldb.num-files-at-level"" + NumberToString(last)))",,,0,
96811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Property,,true,,,Property,,,0,
96815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumberToString,,true,,,NumberToString,,,0,
96819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputError.Corrupt,,true,,,Corrupt,,,0,
96825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputError.Check,,true,,,Check,,,0,
96830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_CompactionInputErrorParanoid.TEST(CorruptionTest, CompactionInputErrorParanoid)",,true,,,"TEST(CorruptionTest, CompactionInputErrorParanoid)",,,0,
96834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, CompactionInputErrorParanoid)",,true,,,"TEST(CorruptionTest, CompactionInputErrorParanoid)",,,0,
96841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputErrorParanoid.Reopen,,true,,,Reopen,,,0,
96844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputErrorParanoid.Build,,true,,,Build,,,0,
96848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputErrorParanoid.Corrupt,,true,,,Corrupt,,,0,
96854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputErrorParanoid.Key,,true,,,Key,,,0,
96859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionInputErrorParanoid.Value,,true,,,Value,,,0,
96864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_UnrelatedKeys.TEST(CorruptionTest, UnrelatedKeys)",,true,,,"TEST(CorruptionTest, UnrelatedKeys)",,,0,
96868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CorruptionTest, UnrelatedKeys)",,true,,,"TEST(CorruptionTest, UnrelatedKeys)",,,0,
96875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnrelatedKeys.Build,,true,,,Build,,,0,
96879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnrelatedKeys.Corrupt,,true,,,Corrupt,,,0,
96885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), Key(1000, &tmp1), Value(1000, &tmp2)))",,,0,
96892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnrelatedKeys.Key,,true,,,Key,,,0,
96897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnrelatedKeys.Value,,true,,,Value,,,0,
96902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v))",,true,,,"ASSERT_OK(db_->Get(ReadOptions(), Key(1000, &tmp1), &v))",,,0,
96909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(Value(1000, &tmp2).ToString(), v)",,true,,,"ASSERT_EQ(Value(1000, &tmp2).ToString(), v)",,,0,
96913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rnd,,true,,,rnd,,,0,
96917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,test.CompressibleString,,true,,,test.CompressibleString,,,0,
96925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,empty,,true,,,empty,,,0,
96929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,push_back,,true,,,push_back,,,0,
96934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Stats.Start,,true,,,Start,,,0,
96937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NowMicros,,true,,,NowMicros,,,0,
96941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,clear,,true,,,clear,,,0,
96945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Merge,,true,,,Merge,,,0,
96950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendWithSpace,,true,,,AppendWithSpace,,,0,
96955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.PrintEnvironment,,true,,,PrintEnvironment,,,0,
96958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.PrintWarnings,,true,,,PrintWarnings,,,0,
96961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port.Snappy_Compress,,true,,,port.Snappy_Compress,,,0,
96968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetChildren,,true,,,GetChildren,,,0,
96974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,starts_with,,true,,,starts_with,,,0,
96979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.PrintHeader,,true,,,PrintHeader,,,0,
96982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.Open,,true,,,Open,,,0,
96986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strchr,,true,,,strchr,,,0,
96991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentDivision,,true,,,<operator>.assignmentDivision,,,0,
96996,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.HeapProfile,,true,,,HeapProfile,,,0,
96999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.PrintStats,,true,,,PrintStats,,,0,
97003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.ToString,,true,,,ToString,,,0,
97007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.RunBenchmark,,true,,,RunBenchmark,,,0,
97013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,l,,true,,,l,,,0,
97017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SignalAll,,true,,,SignalAll,,,0,
97021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Wait,,true,,,Wait,,,0,
97025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Start,,true,,,Start,,,0,
97029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,arg->bm->*(arg->method),,true,,,arg->bm->*(arg->method),,,0,
97034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Stop,,true,,,Stop,,,0,
97038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartThread,,true,,,StartThread,,,0,
97044,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Lock,,true,,,Lock,,,0,
97048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Unlock,,true,,,Unlock,,,0,
97052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Report,,true,,,Report,,,0,
97057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crc32c.Value,,true,,,crc32c.Value,,,0,
97063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FinishedSingleOp,,true,,,FinishedSingleOp,,,0,
97067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddBytes,,true,,,AddBytes,,,0,
97072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddMessage,,true,,,AddMessage,,,0,
97077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ap,,true,,,ap,,,0,
97081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Acquire_Load,,true,,,Acquire_Load,,,0,
97085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,exit,,true,,,exit,,,0,
97089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomGenerator.Generate,,true,,,Generate,,,0,
97094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port.Snappy_Uncompress,,true,,,port.Snappy_Uncompress,,,0,
97101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.DoWrite,,true,,,DoWrite,,,0,
97106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.modulo,,true,,,<operator>.modulo,,,0,
97111,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preIncrement,,true,,,<operator>.preIncrement,,,0,
97115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatch.Delete,,true,,,Delete,,,0,
97120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.DoDelete,,true,,,DoDelete,,,0,
97125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.ReadRandom,,true,,,ReadRandom,,,0,
97128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Append,,true,,,Append,,,0,
97133,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port.GetHeapProfile,,true,,,port.GetHeapProfile,,,0,
97139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.Options,,true,,,leveldb.Options,,,0,
97143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.Slice,,true,,,leveldb.Slice,,,0,
97148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strncmp,,true,,,strncmp,,,0,
97154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetTestDirectory,,true,,,GetTestDirectory,,,0,
97159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.Run,,true,,,Run,,,0,
97163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ClipToRange,,true,,,ClipToRange,,,0,
97169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateDir,,true,,,CreateDir,,,0,
97174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RenameFile,,true,,,RenameFile,,,0,
97180,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InfoLogFileName,,true,,,InfoLogFileName,,,0,
97184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OldInfoLogFileName,,true,,,OldInfoLogFileName,,,0,
97188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewLogger,,true,,,NewLogger,,,0,
97194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Release_Store,,true,,,Release_Store,,,0,
97199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UnlockFile,,true,,,UnlockFile,,,0,
97204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Unref,,true,,,Unref,,,0,
97208,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.SetComparatorName,,true,,,SetComparatorName,,,0,
97213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Name,,true,,,Name,,,0,
97217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.user_comparator,,true,,,user_comparator,,,0,
97220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.SetLogNumber,,true,,,SetLogNumber,,,0,
97225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.SetNextFile,,true,,,SetNextFile,,,0,
97230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.SetLastSequence,,true,,,SetLastSequence,,,0,
97235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DescriptorFileName,,true,,,DescriptorFileName,,,0,
97240,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,log,,true,,,log,,,0,
97244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.EncodeTo,,true,,,EncodeTo,,,0,
97249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Writer.AddRecord,,true,,,AddRecord,,,0,
97254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCurrentFile,,true,,,SetCurrentFile,,,0,
97260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Log,,true,,,Log,,,0,
97268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddLiveFiles,,true,,,AddLiveFiles,,,0,
97273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogNumber,,true,,,LogNumber,,,0,
97277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrevLogNumber,,true,,,PrevLogNumber,,,0,
97281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ManifestFileNumber,,true,,,ManifestFileNumber,,,0,
97285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,find,,true,,,find,,,0,
97290,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,end,,true,,,end,,,0,
97294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Evict,,true,,,Evict,,,0,
97299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AssertHeld,,true,,,AssertHeld,,,0,
97303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LockFile,,true,,,LockFile,,,0,
97309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LockFileName,,true,,,LockFileName,,,0,
97313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FileExists,,true,,,FileExists,,,0,
97318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CurrentFileName,,true,,,CurrentFileName,,,0,
97322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.NewDB,,true,,,NewDB,,,0,
97325,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Recover,,true,,,Recover,,,0,
97331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,max_sequence,,true,,,max_sequence,,,0,
97335,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,erase,,true,,,erase,,,0,
97340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.Corruption,,true,,,Status.Corruption,,,0,
97346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,begin,,true,,,begin,,,0,
97350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.sort,,true,,,std.sort,,,0,
97357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecoverLogFile,,true,,,RecoverLogFile,,,0,
97365,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MarkFileNumberUsed,,true,,,MarkFileNumberUsed,,,0,
97370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LastSequence,,true,,,LastSequence,,,0,
97374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetLastSequence,,true,,,SetLastSequence,,,0,
97379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogFileName,,true,,,LogFileName,,,0,
97384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewSequentialFile,,true,,,NewSequentialFile,,,0,
97390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.MaybeIgnoreError,,true,,,MaybeIgnoreError,,,0,
97394,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reader,,true,,,reader,,,0,
97399,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reader.ReadRecord,,true,,,ReadRecord,,,0,
97405,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogReporter.Corruption,,true,,,Corruption,,,0,
97411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatchInternal.SetContents,,true,,,WriteBatchInternal.SetContents,,,0,
97417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Ref,,true,,,Ref,,,0,
97421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatchInternal.InsertInto,,true,,,WriteBatchInternal.InsertInto,,,0,
97427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatchInternal.Sequence,,true,,,WriteBatchInternal.Sequence,,,0,
97432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatchInternal.Count,,true,,,WriteBatchInternal.Count,,,0,
97437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ApproximateMemoryUsage,,true,,,ApproximateMemoryUsage,,,0,
97441,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteLevel0Table,,true,,,WriteLevel0Table,,,0,
97447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetFileSize,,true,,,GetFileSize,,,0,
97453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewAppendableFile,,true,,,NewAppendableFile,,,0,
97459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewFileNumber,,true,,,NewFileNumber,,,0,
97463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,insert,,true,,,insert,,,0,
97468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BuildTable,,true,,,BuildTable,,,0,
97477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,user_key,,true,,,user_key,,,0,
97481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PickLevelForMemTableOutput,,true,,,PickLevelForMemTableOutput,,,0,
97487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddFile,,true,,,AddFile,,,0,
97496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,current,,true,,,current,,,0,
97500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.WriteLevel0Table,,true,,,WriteLevel0Table,,,0,
97506,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.SetPrevLogNumber,,true,,,SetPrevLogNumber,,,0,
97511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogAndApply,,true,,,LogAndApply,,,0,
97517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.DeleteObsoleteFiles,,true,,,DeleteObsoleteFiles,,,0,
97520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.RecordBackgroundError,,true,,,RecordBackgroundError,,,0,
97524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OverlapInLevel,,true,,,OverlapInLevel,,,0,
97531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.TEST_CompactMemTable,,true,,,TEST_CompactMemTable,,,0,
97534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.TEST_CompactRange,,true,,,TEST_CompactRange,,,0,
97540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalKey,,true,,,InternalKey,,,0,
97546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.MaybeScheduleCompaction,,true,,,MaybeScheduleCompaction,,,0,
97549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NeedsCompaction,,true,,,NeedsCompaction,,,0,
97553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Schedule,,true,,,Schedule,,,0,
97559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BackgroundCall,,true,,,BackgroundCall,,,0,
97563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.BackgroundCompaction,,true,,,BackgroundCompaction,,,0,
97566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.CompactMemTable,,true,,,CompactMemTable,,,0,
97569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,input,,true,,,input,,,0,
97573,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,num_input_files,,true,,,num_input_files,,,0,
97577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DebugString,,true,,,DebugString,,,0,
97581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalKey.DebugString,,true,,,DebugString,,,0,
97585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PickCompaction,,true,,,PickCompaction,,,0,
97589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsTrivialMove,,true,,,IsTrivialMove,,,0,
97593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,edit,,true,,,edit,,,0,
97597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,level,,true,,,level,,,0,
97601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LevelSummary,,true,,,LevelSummary,,,0,
97606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.DoCompactionWork,,true,,,DoCompactionWork,,,0,
97610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.CleanupCompaction,,true,,,CleanupCompaction,,,0,
97614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReleaseInputs,,true,,,ReleaseInputs,,,0,
97618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,current_output,,true,,,current_output,,,0,
97622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumEntries,,true,,,NumEntries,,,0,
97626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddInputDeletions,,true,,,AddInputDeletions,,,0,
97631,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumLevelFiles,,true,,,NumLevelFiles,,,0,
97636,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,oldest,,true,,,oldest,,,0,
97640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeInputIterator,,true,,,MakeInputIterator,,,0,
97645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NoBarrier_Load,,true,,,NoBarrier_Load,,,0,
97649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShouldStopBefore,,true,,,ShouldStopBefore,,,0,
97654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.FinishCompactionOutputFile,,true,,,FinishCompactionOutputFile,,,0,
97659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParseInternalKey,,true,,,ParseInternalKey,,,0,
97664,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Compare,,true,,,Compare,,,0,
97669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsBaseLevelForKey,,true,,,IsBaseLevelForKey,,,0,
97674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.OpenCompactionOutputFile,,true,,,OpenCompactionOutputFile,,,0,
97678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaxOutputFileSize,,true,,,MaxOutputFileSize,,,0,
97682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.InstallCompactionResults,,true,,,InstallCompactionResults,,,0,
97686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddIterators,,true,,,AddIterators,,,0,
97692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewMergingIterator,,true,,,NewMergingIterator,,,0,
97698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RegisterCleanup,,true,,,RegisterCleanup,,,0,
97705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.NewInternalIterator,,true,,,NewInternalIterator,,,0,
97711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaxNextLevelOverlappingBytes,,true,,,MaxNextLevelOverlappingBytes,,,0,
97715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lkey,,true,,,lkey,,,0,
97720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,UpdateStats,,true,,,UpdateStats,,,0,
97725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewDBIterator,,true,,,NewDBIterator,,,0,
97733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecordReadSample,,true,,,RecordReadSample,,,0,
97738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,New,,true,,,New,,,0,
97743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.DB.Put,,true,,,DB.Put,,,0,
97750,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.DB.Delete,,true,,,DB.Delete,,,0,
97756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,w,,true,,,w,,,0,
97760,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,front,,true,,,front,,,0,
97764,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeRoomForWrite,,true,,,MakeRoomForWrite,,,0,
97768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBImpl.BuildBatchGroup,,true,,,BuildBatchGroup,,,0,
97772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatchInternal.SetSequence,,true,,,WriteBatchInternal.SetSequence,,,0,
97778,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddRecord,,true,,,AddRecord,,,0,
97783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pop_front,,true,,,pop_front,,,0,
97787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Signal,,true,,,Signal,,,0,
97791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatchInternal.Append,,true,,,WriteBatchInternal.Append,,,0,
97797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReuseFileNumber,,true,,,ReuseFileNumber,,,0,
97802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,prefix,,true,,,prefix,,,0,
97806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.starts_with,,true,,,starts_with,,,0,
97811,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.remove_prefix,,true,,,remove_prefix,,,0,
97816,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumLevelBytes,,true,,,NumLevelBytes,,,0,
97821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TotalCharge,,true,,,TotalCharge,,,0,
97825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,k1,,true,,,k1,,,0,
97831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,k2,,true,,,k2,,,0,
97837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ApproximateOffsetOf,,true,,,ApproximateOffsetOf,,,0,
97842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DB.Write,,true,,,Write,,,0,
97847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteObsoleteFiles,,true,,,DeleteObsoleteFiles,,,0,
97851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeScheduleCompaction,,true,,,MaybeScheduleCompaction,,,0,
97855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DeleteDir,,true,,,DeleteDir,,,0,
97860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,user_comparator,,true,,,user_comparator,,,0,
97864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExtractUserKey,,true,,,ExtractUserKey,,,0,
97868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,capacity,,true,,,capacity,,,0,
97872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,swap,,true,,,swap,,,0,
97877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Uniform,,true,,,Uniform,,,0,
97882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMinus,,true,,,<operator>.assignmentMinus,,,0,
97887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBIter.RandomPeriod,,true,,,RandomPeriod,,,0,
97890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBIter.SaveKey,,true,,,SaveKey,,,0,
97895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBIter.FindNextUserEntry,,true,,,FindNextUserEntry,,,0,
97900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBIter.ParseKey,,true,,,ParseKey,,,0,
97904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBIter.ClearSavedValue,,true,,,ClearSavedValue,,,0,
97907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBIter.FindPrevUserEntry,,true,,,FindPrevUserEntry,,,0,
97910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendInternalKey,,true,,,AppendInternalKey,,,0,
97915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParsedInternalKey,,true,,,ParsedInternalKey,,,0,
97921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AtomicCounter.IncrementBy,,true,,,IncrementBy,,,0,
97925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SpecialEnv.target,,true,,,target,,,0,
97928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strstr,,true,,,strstr,,,0,
97933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewRandomAccessFile,,true,,,NewRandomAccessFile,,,0,
97939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.Reopen,,true,,,Reopen,,,0,
97942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.DestroyAndReopen,,true,,,DestroyAndReopen,,,0,
97945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.TryReopen,,true,,,TryReopen,,,0,
97949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(TryReopen(options)),,true,,,ASSERT_OK(TryReopen(options)),,,0,
97955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.CurrentOptions,,true,,,CurrentOptions,,,0,
97958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.IterStatus,,true,,,IterStatus,,,0,
97962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(matched, forward.size())",,true,,,"ASSERT_LT(matched, forward.size())",,,0,
97966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1])",,true,,,"ASSERT_EQ(IterStatus(iter), forward[forward.size() - matched - 1])",,,0,
97970,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(matched, forward.size())",,true,,,"ASSERT_EQ(matched, forward.size())",,,0,
97974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TEST_NewInternalIterator,,true,,,TEST_NewInternalIterator,,,0,
97978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.dbfull,,true,,,dbfull,,,0,
97981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,target,,true,,,target,,,0,
97987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalKey.Encode,,true,,,Encode,,,0,
97991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(
        db_->GetProperty(""leveldb.num-files-at-level"" + NumberToString(level),
                         &property))",,true,,,"ASSERT_TRUE(
        db_->GetProperty(""leveldb.num-files-at-level"" + NumberToString(level),
                         &property))",,,0,
97997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,atoi,,true,,,atoi,,,0,
98001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
98005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,resize,,true,,,resize,,,0,
98010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBTest.MakeTables,,true,,,MakeTables,,,0,
98016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TEST_MaxNextLevelOverlappingBytes,,true,,,TEST_MaxNextLevelOverlappingBytes,,,0,
98020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->GetChildren(dbname_, &filenames))",,true,,,"ASSERT_OK(env_->GetChildren(dbname_, &filenames))",,,0,
98026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)))",,true,,,"ASSERT_OK(env_->DeleteFile(TableFileName(dbname_, number)))",,,0,
98031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SSTTableFileName,,true,,,SSTTableFileName,,,0,
98036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->RenameFile(from, to))",,true,,,"ASSERT_OK(env_->RenameFile(from, to))",,,0,
98042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(DBTest, Empty)",,true,,,"TEST(DBTest, Empty)",,,0,
98046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, Empty)",,true,,,"TEST(DBTest, Empty)",,,0,
98053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(db_ != NULL),,true,,,ASSERT_TRUE(db_ != NULL),,,0,
98059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""foo""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""foo""))",,,0,
98065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Empty.ChangeOptions,,true,,,ChangeOptions,,,0,
98068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadWrite.TEST(DBTest, ReadWrite)",,true,,,"TEST(DBTest, ReadWrite)",,,0,
98072,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, ReadWrite)",,true,,,"TEST(DBTest, ReadWrite)",,,0,
98079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""foo"", ""v1""))",,true,,,"ASSERT_OK(Put(""foo"", ""v1""))",,,0,
98085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v1"", Get(""foo""))",,true,,,"ASSERT_EQ(""v1"", Get(""foo""))",,,0,
98091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""bar"", ""v2""))",,true,,,"ASSERT_OK(Put(""bar"", ""v2""))",,,0,
98097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""foo"", ""v3""))",,true,,,"ASSERT_OK(Put(""foo"", ""v3""))",,,0,
98103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v3"", Get(""foo""))",,true,,,"ASSERT_EQ(""v3"", Get(""foo""))",,,0,
98109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v2"", Get(""bar""))",,true,,,"ASSERT_EQ(""v2"", Get(""bar""))",,,0,
98115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadWrite.ChangeOptions,,true,,,ChangeOptions,,,0,
98118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_PutDeleteGet.TEST(DBTest, PutDeleteGet)",,true,,,"TEST(DBTest, PutDeleteGet)",,,0,
98122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, PutDeleteGet)",,true,,,"TEST(DBTest, PutDeleteGet)",,,0,
98129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v2"", Get(""foo""))",,true,,,"ASSERT_EQ(""v2"", Get(""foo""))",,,0,
98135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Delete(WriteOptions(), ""foo""))",,true,,,"ASSERT_OK(db_->Delete(WriteOptions(), ""foo""))",,,0,
98141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_PutDeleteGet.ChangeOptions,,true,,,ChangeOptions,,,0,
98144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetFromImmutableLayer.TEST(DBTest, GetFromImmutableLayer)",,true,,,"TEST(DBTest, GetFromImmutableLayer)",,,0,
98148,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetFromImmutableLayer)",,true,,,"TEST(DBTest, GetFromImmutableLayer)",,,0,
98155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetFromImmutableLayer.CurrentOptions,,true,,,CurrentOptions,,,0,
98158,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetFromImmutableLayer.Reopen,,true,,,Reopen,,,0,
98162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetFromImmutableLayer.ChangeOptions,,true,,,ChangeOptions,,,0,
98165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetFromVersions.TEST(DBTest, GetFromVersions)",,true,,,"TEST(DBTest, GetFromVersions)",,,0,
98169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetFromVersions)",,true,,,"TEST(DBTest, GetFromVersions)",,,0,
98176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetFromVersions.dbfull,,true,,,dbfull,,,0,
98179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetFromVersions.ChangeOptions,,true,,,ChangeOptions,,,0,
98182,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetMemUsage.TEST(DBTest, GetMemUsage)",,true,,,"TEST(DBTest, GetMemUsage)",,,0,
98186,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetMemUsage)",,true,,,"TEST(DBTest, GetMemUsage)",,,0,
98193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(db_->GetProperty(""leveldb.approximate-memory-usage"", &val))",,true,,,"ASSERT_TRUE(db_->GetProperty(""leveldb.approximate-memory-usage"", &val))",,,0,
98199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:110:110:ASSERT_GT:2,,true,110,110,ASSERT_GT,,,0,
98204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(mem_usage, 0)",,true,,,"ASSERT_GT(mem_usage, 0)",,,0,
98210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(mem_usage, 5*1024*1024)",,true,,,"ASSERT_LT(mem_usage, 5*1024*1024)",,,0,
98216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetMemUsage.ChangeOptions,,true,,,ChangeOptions,,,0,
98219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetSnapshot.TEST(DBTest, GetSnapshot)",,true,,,"TEST(DBTest, GetSnapshot)",,,0,
98223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetSnapshot)",,true,,,"TEST(DBTest, GetSnapshot)",,,0,
98230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(key, ""v1""))",,true,,,"ASSERT_OK(Put(key, ""v1""))",,,0,
98236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(key, ""v2""))",,true,,,"ASSERT_OK(Put(key, ""v2""))",,,0,
98242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetSnapshot.Get,,true,,,Get,,,0,
98247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v2"", Get(key))",,true,,,"ASSERT_EQ(""v2"", Get(key))",,,0,
98253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v1"", Get(key, s1))",,true,,,"ASSERT_EQ(""v1"", Get(key, s1))",,,0,
98259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetSnapshot.dbfull,,true,,,dbfull,,,0,
98262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetSnapshot.ChangeOptions,,true,,,ChangeOptions,,,0,
98265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetLevel0Ordering.TEST(DBTest, GetLevel0Ordering)",,true,,,"TEST(DBTest, GetLevel0Ordering)",,,0,
98269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetLevel0Ordering)",,true,,,"TEST(DBTest, GetLevel0Ordering)",,,0,
98276,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""bar"", ""b""))",,true,,,"ASSERT_OK(Put(""bar"", ""b""))",,,0,
98282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetLevel0Ordering.dbfull,,true,,,dbfull,,,0,
98285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""foo"", ""v2""))",,true,,,"ASSERT_OK(Put(""foo"", ""v2""))",,,0,
98291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetLevel0Ordering.ChangeOptions,,true,,,ChangeOptions,,,0,
98294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetOrderedByLevels.TEST(DBTest, GetOrderedByLevels)",,true,,,"TEST(DBTest, GetOrderedByLevels)",,,0,
98298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetOrderedByLevels)",,true,,,"TEST(DBTest, GetOrderedByLevels)",,,0,
98305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetOrderedByLevels.Compact,,true,,,Compact,,,0,
98310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetOrderedByLevels.dbfull,,true,,,dbfull,,,0,
98313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetOrderedByLevels.ChangeOptions,,true,,,ChangeOptions,,,0,
98316,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetPicksCorrectFile.TEST(DBTest, GetPicksCorrectFile)",,true,,,"TEST(DBTest, GetPicksCorrectFile)",,,0,
98320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetPicksCorrectFile)",,true,,,"TEST(DBTest, GetPicksCorrectFile)",,,0,
98327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""a"", ""va""))",,true,,,"ASSERT_OK(Put(""a"", ""va""))",,,0,
98333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetPicksCorrectFile.Compact,,true,,,Compact,,,0,
98338,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""x"", ""vx""))",,true,,,"ASSERT_OK(Put(""x"", ""vx""))",,,0,
98344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""f"", ""vf""))",,true,,,"ASSERT_OK(Put(""f"", ""vf""))",,,0,
98350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""va"", Get(""a""))",,true,,,"ASSERT_EQ(""va"", Get(""a""))",,,0,
98356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""vf"", Get(""f""))",,true,,,"ASSERT_EQ(""vf"", Get(""f""))",,,0,
98362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""vx"", Get(""x""))",,true,,,"ASSERT_EQ(""vx"", Get(""x""))",,,0,
98368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetPicksCorrectFile.ChangeOptions,,true,,,ChangeOptions,,,0,
98371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_GetEncountersEmptyLevel.TEST(DBTest, GetEncountersEmptyLevel)",,true,,,"TEST(DBTest, GetEncountersEmptyLevel)",,,0,
98375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, GetEncountersEmptyLevel)",,true,,,"TEST(DBTest, GetEncountersEmptyLevel)",,,0,
98382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetEncountersEmptyLevel.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
98386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(compaction_count, 100)",,true,,,"ASSERT_LE(compaction_count, 100)",,,0,
98392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetEncountersEmptyLevel.dbfull,,true,,,dbfull,,,0,
98395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(0), 1)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(0), 1)",,,0,
98401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(1), 0)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(1), 0)",,,0,
98407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(2), 1)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(2), 1)",,,0,
98413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""missing""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""missing""))",,,0,
98419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DelayMilliseconds,,true,,,DelayMilliseconds,,,0,
98423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(0), 0)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(0), 0)",,,0,
98429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_GetEncountersEmptyLevel.ChangeOptions,,true,,,ChangeOptions,,,0,
98432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_IterEmpty.TEST(DBTest, IterEmpty)",,true,,,"TEST(DBTest, IterEmpty)",,,0,
98436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, IterEmpty)",,true,,,"TEST(DBTest, IterEmpty)",,,0,
98443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IterEmpty.IterStatus,,true,,,IterStatus,,,0,
98447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""(invalid)"")",,true,,,"ASSERT_EQ(IterStatus(iter), ""(invalid)"")",,,0,
98453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_IterSingle.TEST(DBTest, IterSingle)",,true,,,"TEST(DBTest, IterSingle)",,,0,
98457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, IterSingle)",,true,,,"TEST(DBTest, IterSingle)",,,0,
98464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IterSingle.IterStatus,,true,,,IterStatus,,,0,
98468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""a->va"")",,true,,,"ASSERT_EQ(IterStatus(iter), ""a->va"")",,,0,
98474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_IterMulti.TEST(DBTest, IterMulti)",,true,,,"TEST(DBTest, IterMulti)",,,0,
98478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, IterMulti)",,true,,,"TEST(DBTest, IterMulti)",,,0,
98485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""b"", ""vb""))",,true,,,"ASSERT_OK(Put(""b"", ""vb""))",,,0,
98491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""c"", ""vc""))",,true,,,"ASSERT_OK(Put(""c"", ""vc""))",,,0,
98497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IterMulti.IterStatus,,true,,,IterStatus,,,0,
98501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""b->vb"")",,true,,,"ASSERT_EQ(IterStatus(iter), ""b->vb"")",,,0,
98507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""c->vc"")",,true,,,"ASSERT_EQ(IterStatus(iter), ""c->vc"")",,,0,
98513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""a"",  ""va2""))",,true,,,"ASSERT_OK(Put(""a"",  ""va2""))",,,0,
98519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""a2"", ""va3""))",,true,,,"ASSERT_OK(Put(""a2"", ""va3""))",,,0,
98525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""b"",  ""vb2""))",,true,,,"ASSERT_OK(Put(""b"",  ""vb2""))",,,0,
98531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""c"",  ""vc2""))",,true,,,"ASSERT_OK(Put(""c"",  ""vc2""))",,,0,
98537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Delete(""b""))",,true,,,"ASSERT_OK(Delete(""b""))",,,0,
98543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_IterSmallAndLargeMix.TEST(DBTest, IterSmallAndLargeMix)",,true,,,"TEST(DBTest, IterSmallAndLargeMix)",,,0,
98547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, IterSmallAndLargeMix)",,true,,,"TEST(DBTest, IterSmallAndLargeMix)",,,0,
98554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""b"", std.string(100000, 'b')))",,true,,,"ASSERT_OK(Put(""b"", std.string(100000, 'b')))",,,0,
98560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""d"", std.string(100000, 'd')))",,true,,,"ASSERT_OK(Put(""d"", std.string(100000, 'd')))",,,0,
98566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""e"", std.string(100000, 'e')))",,true,,,"ASSERT_OK(Put(""e"", std.string(100000, 'e')))",,,0,
98572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IterSmallAndLargeMix.IterStatus,,true,,,IterStatus,,,0,
98576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""b->"" + std.string(100000, 'b'))",,true,,,"ASSERT_EQ(IterStatus(iter), ""b->"" + std.string(100000, 'b'))",,,0,
98582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""d->"" + std.string(100000, 'd'))",,true,,,"ASSERT_EQ(IterStatus(iter), ""d->"" + std.string(100000, 'd'))",,,0,
98588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IterStatus(iter), ""e->"" + std.string(100000, 'e'))",,true,,,"ASSERT_EQ(IterStatus(iter), ""e->"" + std.string(100000, 'e'))",,,0,
98594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_IterMultiWithDelete.TEST(DBTest, IterMultiWithDelete)",,true,,,"TEST(DBTest, IterMultiWithDelete)",,,0,
98598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, IterMultiWithDelete)",,true,,,"TEST(DBTest, IterMultiWithDelete)",,,0,
98605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""b""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""b""))",,,0,
98611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IterMultiWithDelete.IterStatus,,true,,,IterStatus,,,0,
98615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IterMultiWithDelete.ChangeOptions,,true,,,ChangeOptions,,,0,
98618,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Recover.TEST(DBTest, Recover)",,true,,,"TEST(DBTest, Recover)",,,0,
98622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, Recover)",,true,,,"TEST(DBTest, Recover)",,,0,
98629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""baz"", ""v5""))",,true,,,"ASSERT_OK(Put(""baz"", ""v5""))",,,0,
98635,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Recover.Reopen,,true,,,Reopen,,,0,
98638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v5"", Get(""baz""))",,true,,,"ASSERT_EQ(""v5"", Get(""baz""))",,,0,
98644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""foo"", ""v4""))",,true,,,"ASSERT_OK(Put(""foo"", ""v4""))",,,0,
98650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v4"", Get(""foo""))",,true,,,"ASSERT_EQ(""v4"", Get(""foo""))",,,0,
98656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Recover.ChangeOptions,,true,,,ChangeOptions,,,0,
98659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RecoveryWithEmptyLog.TEST(DBTest, RecoveryWithEmptyLog)",,true,,,"TEST(DBTest, RecoveryWithEmptyLog)",,,0,
98663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, RecoveryWithEmptyLog)",,true,,,"TEST(DBTest, RecoveryWithEmptyLog)",,,0,
98670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoveryWithEmptyLog.Reopen,,true,,,Reopen,,,0,
98673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoveryWithEmptyLog.ChangeOptions,,true,,,ChangeOptions,,,0,
98676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RecoverDuringMemtableCompaction.TEST(DBTest, RecoverDuringMemtableCompaction)",,true,,,"TEST(DBTest, RecoverDuringMemtableCompaction)",,,0,
98680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, RecoverDuringMemtableCompaction)",,true,,,"TEST(DBTest, RecoverDuringMemtableCompaction)",,,0,
98687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverDuringMemtableCompaction.CurrentOptions,,true,,,CurrentOptions,,,0,
98690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverDuringMemtableCompaction.Reopen,,true,,,Reopen,,,0,
98694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""big1"", std.string(10000000, 'x')))",,true,,,"ASSERT_OK(Put(""big1"", std.string(10000000, 'x')))",,,0,
98700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""big2"", std.string(1000, 'y')))",,true,,,"ASSERT_OK(Put(""big2"", std.string(1000, 'y')))",,,0,
98706,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(10000000, 'x'), Get(""big1""))",,true,,,"ASSERT_EQ(std.string(10000000, 'x'), Get(""big1""))",,,0,
98712,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(1000, 'y'), Get(""big2""))",,true,,,"ASSERT_EQ(std.string(1000, 'y'), Get(""big2""))",,,0,
98718,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverDuringMemtableCompaction.ChangeOptions,,true,,,ChangeOptions,,,0,
98721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MinorCompactionsHappen.TEST(DBTest, MinorCompactionsHappen)",,true,,,"TEST(DBTest, MinorCompactionsHappen)",,,0,
98725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, MinorCompactionsHappen)",,true,,,"TEST(DBTest, MinorCompactionsHappen)",,,0,
98732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MinorCompactionsHappen.CurrentOptions,,true,,,CurrentOptions,,,0,
98735,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MinorCompactionsHappen.Reopen,,true,,,Reopen,,,0,
98738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MinorCompactionsHappen.TotalTableFiles,,true,,,TotalTableFiles,,,0,
98741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(i), Key(i) + std.string(1000, 'v')))",,true,,,"ASSERT_OK(Put(Key(i), Key(i) + std.string(1000, 'v')))",,,0,
98747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MinorCompactionsHappen.Put,,true,,,Put,,,0,
98752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Key,,true,,,Key,,,0,
98757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(ending_num_tables, starting_num_tables)",,true,,,"ASSERT_GT(ending_num_tables, starting_num_tables)",,,0,
98763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MinorCompactionsHappen.Get,,true,,,Get,,,0,
98767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(Key(i) + std.string(1000, 'v'), Get(Key(i)))",,true,,,"ASSERT_EQ(Key(i) + std.string(1000, 'v'), Get(Key(i)))",,,0,
98773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RecoverWithLargeLog.TEST(DBTest, RecoverWithLargeLog)",,true,,,"TEST(DBTest, RecoverWithLargeLog)",,,0,
98777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, RecoverWithLargeLog)",,true,,,"TEST(DBTest, RecoverWithLargeLog)",,,0,
98784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverWithLargeLog.CurrentOptions,,true,,,CurrentOptions,,,0,
98787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverWithLargeLog.Reopen,,true,,,Reopen,,,0,
98791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""big1"", std.string(200000, '1')))",,true,,,"ASSERT_OK(Put(""big1"", std.string(200000, '1')))",,,0,
98797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""big2"", std.string(200000, '2')))",,true,,,"ASSERT_OK(Put(""big2"", std.string(200000, '2')))",,,0,
98803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""small3"", std.string(10, '3')))",,true,,,"ASSERT_OK(Put(""small3"", std.string(10, '3')))",,,0,
98809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""small4"", std.string(10, '4')))",,true,,,"ASSERT_OK(Put(""small4"", std.string(10, '4')))",,,0,
98815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RecoverWithLargeLog.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
98819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(0), 3)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(0), 3)",,,0,
98825,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(200000, '1'), Get(""big1""))",,true,,,"ASSERT_EQ(std.string(200000, '1'), Get(""big1""))",,,0,
98831,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(200000, '2'), Get(""big2""))",,true,,,"ASSERT_EQ(std.string(200000, '2'), Get(""big2""))",,,0,
98837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(10, '3'), Get(""small3""))",,true,,,"ASSERT_EQ(std.string(10, '3'), Get(""small3""))",,,0,
98843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(10, '4'), Get(""small4""))",,true,,,"ASSERT_EQ(std.string(10, '4'), Get(""small4""))",,,0,
98849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(NumTableFilesAtLevel(0), 1)",,true,,,"ASSERT_GT(NumTableFilesAtLevel(0), 1)",,,0,
98855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_CompactionsGenerateMultipleFiles.TEST(DBTest, CompactionsGenerateMultipleFiles)",,true,,,"TEST(DBTest, CompactionsGenerateMultipleFiles)",,,0,
98859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, CompactionsGenerateMultipleFiles)",,true,,,"TEST(DBTest, CompactionsGenerateMultipleFiles)",,,0,
98866,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionsGenerateMultipleFiles.CurrentOptions,,true,,,CurrentOptions,,,0,
98869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionsGenerateMultipleFiles.Reopen,,true,,,Reopen,,,0,
98873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionsGenerateMultipleFiles.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
98877,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomString,,true,,,RandomString,,,0,
98883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(i), values[i]))",,true,,,"ASSERT_OK(Put(Key(i), values[i]))",,,0,
98889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionsGenerateMultipleFiles.dbfull,,true,,,dbfull,,,0,
98892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(NumTableFilesAtLevel(1), 1)",,true,,,"ASSERT_GT(NumTableFilesAtLevel(1), 1)",,,0,
98898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CompactionsGenerateMultipleFiles.Get,,true,,,Get,,,0,
98902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(Get(Key(i)), values[i])",,true,,,"ASSERT_EQ(Get(Key(i)), values[i])",,,0,
98908,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RepeatedWritesToSameKey.TEST(DBTest, RepeatedWritesToSameKey)",,true,,,"TEST(DBTest, RepeatedWritesToSameKey)",,,0,
98912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, RepeatedWritesToSameKey)",,true,,,"TEST(DBTest, RepeatedWritesToSameKey)",,,0,
98919,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RepeatedWritesToSameKey.CurrentOptions,,true,,,CurrentOptions,,,0,
98922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RepeatedWritesToSameKey.Reopen,,true,,,Reopen,,,0,
98926,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RepeatedWritesToSameKey.TotalTableFiles,,true,,,TotalTableFiles,,,0,
98929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(TotalTableFiles(), kMaxFiles)",,true,,,"ASSERT_LE(TotalTableFiles(), kMaxFiles)",,,0,
98935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SparseMerge.TEST(DBTest, SparseMerge)",,true,,,"TEST(DBTest, SparseMerge)",,,0,
98939,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, SparseMerge)",,true,,,"TEST(DBTest, SparseMerge)",,,0,
98946,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SparseMerge.CurrentOptions,,true,,,CurrentOptions,,,0,
98949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SparseMerge.Reopen,,true,,,Reopen,,,0,
98953,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FillLevels,,true,,,FillLevels,,,0,
98958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SparseMerge.dbfull,,true,,,dbfull,,,0,
98961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(dbfull()->TEST_MaxNextLevelOverlappingBytes(), 20*1048576)",,true,,,"ASSERT_LE(dbfull()->TEST_MaxNextLevelOverlappingBytes(), 20*1048576)",,,0,
98965,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ApproximateSizes.TEST(DBTest, ApproximateSizes)",,true,,,"TEST(DBTest, ApproximateSizes)",,,0,
98969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, ApproximateSizes)",,true,,,"TEST(DBTest, ApproximateSizes)",,,0,
98976,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.CurrentOptions,,true,,,CurrentOptions,,,0,
98979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.DestroyAndReopen,,true,,,DestroyAndReopen,,,0,
98982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0))",,true,,,"ASSERT_TRUE(Between(Size("""", ""xyz""), 0, 0))",,,0,
98988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Between,,true,,,Between,,,0,
98994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.Size,,true,,,Size,,,0,
98999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.Reopen,,true,,,Reopen,,,0,
99003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
99007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)))",,true,,,"ASSERT_OK(Put(Key(i), RandomString(&rnd, S1)))",,,0,
99013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.Put,,true,,,Put,,,0,
99018,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(50)), 0, 0))",,,0,
99024,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(i)), S1*i, S2*i))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(i)), S1*i, S2*i))",,,0,
99030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(i)+"".suffix""), S1*(i+1), S2*(i+1)))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(i)+"".suffix""), S1*(i+1), S2*(i+1)))",,,0,
99036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size(Key(i), Key(i+10)), S1*10, S2*10))",,true,,,"ASSERT_TRUE(Between(Size(Key(i), Key(i+10)), S1*10, S2*10))",,,0,
99042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(50)), S1*50, S2*50))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(50)), S1*50, S2*50))",,,0,
99048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(50)+"".suffix""), S1*50, S2*50))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(50)+"".suffix""), S1*50, S2*50))",,,0,
99054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.dbfull,,true,,,dbfull,,,0,
99057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(NumTableFilesAtLevel(1), 0)",,true,,,"ASSERT_GT(NumTableFilesAtLevel(1), 0)",,,0,
99063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes.ChangeOptions,,true,,,ChangeOptions,,,0,
99066,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ApproximateSizes_MixOfSmallAndLarge.TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",,true,,,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",,,0,
99070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",,true,,,"TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge)",,,0,
99077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes_MixOfSmallAndLarge.CurrentOptions,,true,,,CurrentOptions,,,0,
99080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes_MixOfSmallAndLarge.Reopen,,true,,,Reopen,,,0,
99084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)))",,true,,,"ASSERT_OK(Put(Key(0), RandomString(&rnd, 10000)))",,,0,
99090,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes_MixOfSmallAndLarge.Put,,true,,,Put,,,0,
99095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)))",,true,,,"ASSERT_OK(Put(Key(1), RandomString(&rnd, 10000)))",,,0,
99101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(2), big1))",,true,,,"ASSERT_OK(Put(Key(2), big1))",,,0,
99107,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)))",,true,,,"ASSERT_OK(Put(Key(3), RandomString(&rnd, 10000)))",,,0,
99113,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(4), big1))",,true,,,"ASSERT_OK(Put(Key(4), big1))",,,0,
99119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)))",,true,,,"ASSERT_OK(Put(Key(5), RandomString(&rnd, 10000)))",,,0,
99125,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)))",,true,,,"ASSERT_OK(Put(Key(6), RandomString(&rnd, 300000)))",,,0,
99131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)))",,true,,,"ASSERT_OK(Put(Key(7), RandomString(&rnd, 10000)))",,,0,
99137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(dbfull()->TEST_CompactMemTable()),,true,,,ASSERT_OK(dbfull()->TEST_CompactMemTable()),,,0,
99141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes_MixOfSmallAndLarge.dbfull,,true,,,dbfull,,,0,
99144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(0)), 0, 0))",,,0,
99150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes_MixOfSmallAndLarge.Size,,true,,,Size,,,0,
99155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(1)), 10000, 11000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(1)), 10000, 11000))",,,0,
99161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(2)), 20000, 21000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(2)), 20000, 21000))",,,0,
99167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(3)), 120000, 121000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(3)), 120000, 121000))",,,0,
99173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(4)), 130000, 131000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(4)), 130000, 131000))",,,0,
99179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(5)), 230000, 231000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(5)), 230000, 231000))",,,0,
99185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(6)), 240000, 241000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(6)), 240000, 241000))",,,0,
99191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(7)), 540000, 541000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(7)), 540000, 541000))",,,0,
99197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", Key(8)), 550000, 560000))",,true,,,"ASSERT_TRUE(Between(Size("""", Key(8)), 550000, 560000))",,,0,
99203,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size(Key(3), Key(5)), 110000, 111000))",,true,,,"ASSERT_TRUE(Between(Size(Key(3), Key(5)), 110000, 111000))",,,0,
99209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ApproximateSizes_MixOfSmallAndLarge.ChangeOptions,,true,,,ChangeOptions,,,0,
99212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_IteratorPinsRef.TEST(DBTest, IteratorPinsRef)",,true,,,"TEST(DBTest, IteratorPinsRef)",,,0,
99216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, IteratorPinsRef)",,true,,,"TEST(DBTest, IteratorPinsRef)",,,0,
99223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(i), Key(i) + std.string(100000, 'v')))",,true,,,"ASSERT_OK(Put(Key(i), Key(i) + std.string(100000, 'v')))",,,0,
99229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_IteratorPinsRef.Put,,true,,,Put,,,0,
99234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(iter->Valid()),,true,,,ASSERT_TRUE(iter->Valid()),,,0,
99238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""foo"", iter->key().ToString())",,true,,,"ASSERT_EQ(""foo"", iter->key().ToString())",,,0,
99242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""hello"", iter->value().ToString())",,true,,,"ASSERT_EQ(""hello"", iter->value().ToString())",,,0,
99246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!iter->Valid()),,true,,,ASSERT_TRUE(!iter->Valid()),,,0,
99250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Snapshot.TEST(DBTest, Snapshot)",,true,,,"TEST(DBTest, Snapshot)",,,0,
99254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, Snapshot)",,true,,,"TEST(DBTest, Snapshot)",,,0,
99261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v1"", Get(""foo"", s1))",,true,,,"ASSERT_EQ(""v1"", Get(""foo"", s1))",,,0,
99267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v2"", Get(""foo"", s2))",,true,,,"ASSERT_EQ(""v2"", Get(""foo"", s2))",,,0,
99273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v3"", Get(""foo"", s3))",,true,,,"ASSERT_EQ(""v3"", Get(""foo"", s3))",,,0,
99279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Snapshot.ChangeOptions,,true,,,ChangeOptions,,,0,
99282,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_HiddenValuesAreRemoved.TEST(DBTest, HiddenValuesAreRemoved)",,true,,,"TEST(DBTest, HiddenValuesAreRemoved)",,,0,
99286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, HiddenValuesAreRemoved)",,true,,,"TEST(DBTest, HiddenValuesAreRemoved)",,,0,
99293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HiddenValuesAreRemoved.dbfull,,true,,,dbfull,,,0,
99296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HiddenValuesAreRemoved.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
99300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(NumTableFilesAtLevel(0), 0)",,true,,,"ASSERT_GT(NumTableFilesAtLevel(0), 0)",,,0,
99306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(big, Get(""foo"", snapshot))",,true,,,"ASSERT_EQ(big, Get(""foo"", snapshot))",,,0,
99312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", ""pastfoo""), 50000, 60000))",,true,,,"ASSERT_TRUE(Between(Size("""", ""pastfoo""), 50000, 60000))",,,0,
99318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HiddenValuesAreRemoved.Size,,true,,,Size,,,0,
99323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HiddenValuesAreRemoved.AllEntriesFor,,true,,,AllEntriesFor,,,0,
99327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny, "" + big + "" ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny, "" + big + "" ]"")",,,0,
99333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,x,,true,,,x,,,0,
99337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ tiny ]"")",,,0,
99343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(NumTableFilesAtLevel(1), 1)",,true,,,"ASSERT_GE(NumTableFilesAtLevel(1), 1)",,,0,
99349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(Size("""", ""pastfoo""), 0, 1000))",,true,,,"ASSERT_TRUE(Between(Size("""", ""pastfoo""), 0, 1000))",,,0,
99355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HiddenValuesAreRemoved.ChangeOptions,,true,,,ChangeOptions,,,0,
99358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_DeletionMarkers1.TEST(DBTest, DeletionMarkers1)",,true,,,"TEST(DBTest, DeletionMarkers1)",,,0,
99362,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, DeletionMarkers1)",,true,,,"TEST(DBTest, DeletionMarkers1)",,,0,
99369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_DeletionMarkers1.dbfull,,true,,,dbfull,,,0,
99372,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_DeletionMarkers1.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
99376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(last), 1)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(last), 1)",,,0,
99382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumTableFilesAtLevel(last-1), 1)",,true,,,"ASSERT_EQ(NumTableFilesAtLevel(last-1), 1)",,,0,
99388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_DeletionMarkers1.AllEntriesFor,,true,,,AllEntriesFor,,,0,
99392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, DEL, v1 ]"")",,,0,
99398,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,z,,true,,,z,,,0,
99402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, v1 ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2, v1 ]"")",,,0,
99408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2 ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ v2 ]"")",,,0,
99414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_DeletionMarkers2.TEST(DBTest, DeletionMarkers2)",,true,,,"TEST(DBTest, DeletionMarkers2)",,,0,
99418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, DeletionMarkers2)",,true,,,"TEST(DBTest, DeletionMarkers2)",,,0,
99425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_DeletionMarkers2.dbfull,,true,,,dbfull,,,0,
99428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_DeletionMarkers2.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
99432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_DeletionMarkers2.AllEntriesFor,,true,,,AllEntriesFor,,,0,
99436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ DEL, v1 ]"")",,,0,
99442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ ]"")",,true,,,"ASSERT_EQ(AllEntriesFor(""foo""), ""[ ]"")",,,0,
99448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_OverlapInLevel0.TEST(DBTest, OverlapInLevel0)",,true,,,"TEST(DBTest, OverlapInLevel0)",,,0,
99452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, OverlapInLevel0)",,true,,,"TEST(DBTest, OverlapInLevel0)",,,0,
99459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(config.kMaxMemCompactLevel, 2)",,true,,,"ASSERT_EQ(config.kMaxMemCompactLevel, 2)",,,0,
99465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""100"", ""v100""))",,true,,,"ASSERT_OK(Put(""100"", ""v100""))",,,0,
99471,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""999"", ""v999""))",,true,,,"ASSERT_OK(Put(""999"", ""v999""))",,,0,
99477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OverlapInLevel0.dbfull,,true,,,dbfull,,,0,
99480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Delete(""100""))",,true,,,"ASSERT_OK(Delete(""100""))",,,0,
99486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Delete(""999""))",,true,,,"ASSERT_OK(Delete(""999""))",,,0,
99492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OverlapInLevel0.FilesPerLevel,,true,,,FilesPerLevel,,,0,
99495,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""0,1,1"", FilesPerLevel())",,true,,,"ASSERT_EQ(""0,1,1"", FilesPerLevel())",,,0,
99501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""300"", ""v300""))",,true,,,"ASSERT_OK(Put(""300"", ""v300""))",,,0,
99507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""500"", ""v500""))",,true,,,"ASSERT_OK(Put(""500"", ""v500""))",,,0,
99513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""200"", ""v200""))",,true,,,"ASSERT_OK(Put(""200"", ""v200""))",,,0,
99519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""600"", ""v600""))",,true,,,"ASSERT_OK(Put(""600"", ""v600""))",,,0,
99525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""900"", ""v900""))",,true,,,"ASSERT_OK(Put(""900"", ""v900""))",,,0,
99531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""2,1,1"", FilesPerLevel())",,true,,,"ASSERT_EQ(""2,1,1"", FilesPerLevel())",,,0,
99537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""2"", FilesPerLevel())",,true,,,"ASSERT_EQ(""2"", FilesPerLevel())",,,0,
99543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Delete(""600""))",,true,,,"ASSERT_OK(Delete(""600""))",,,0,
99549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""3"", FilesPerLevel())",,true,,,"ASSERT_EQ(""3"", FilesPerLevel())",,,0,
99555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""600""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""600""))",,,0,
99561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OverlapInLevel0.ChangeOptions,,true,,,ChangeOptions,,,0,
99564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_L0_CompactionBug_Issue44_a.TEST(DBTest, L0_CompactionBug_Issue44_a)",,true,,,"TEST(DBTest, L0_CompactionBug_Issue44_a)",,,0,
99568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, L0_CompactionBug_Issue44_a)",,true,,,"TEST(DBTest, L0_CompactionBug_Issue44_a)",,,0,
99575,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_L0_CompactionBug_Issue44_a.Reopen,,true,,,Reopen,,,0,
99578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""b"", ""v""))",,true,,,"ASSERT_OK(Put(""b"", ""v""))",,,0,
99584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Delete(""a""))",,true,,,"ASSERT_OK(Delete(""a""))",,,0,
99590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""a"", ""v""))",,true,,,"ASSERT_OK(Put(""a"", ""v""))",,,0,
99596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_L0_CompactionBug_Issue44_a.Contents,,true,,,Contents,,,0,
99599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""(a->v)"", Contents())",,true,,,"ASSERT_EQ(""(a->v)"", Contents())",,,0,
99605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_L0_CompactionBug_Issue44_b.TEST(DBTest, L0_CompactionBug_Issue44_b)",,true,,,"TEST(DBTest, L0_CompactionBug_Issue44_b)",,,0,
99609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, L0_CompactionBug_Issue44_b)",,true,,,"TEST(DBTest, L0_CompactionBug_Issue44_b)",,,0,
99616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_L0_CompactionBug_Issue44_b.Reopen,,true,,,Reopen,,,0,
99619,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_L0_CompactionBug_Issue44_b.Contents,,true,,,Contents,,,0,
99622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""(->)(c->cv)"", Contents())",,true,,,"ASSERT_EQ(""(->)(c->cv)"", Contents())",,,0,
99628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ComparatorCheck.TEST(DBTest, ComparatorCheck)",,true,,,"TEST(DBTest, ComparatorCheck)",,,0,
99632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, ComparatorCheck)",,true,,,"TEST(DBTest, ComparatorCheck)",,,0,
99639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ComparatorCheck.CurrentOptions,,true,,,CurrentOptions,,,0,
99642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ComparatorCheck.TryReopen,,true,,,TryReopen,,,0,
99646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(s.ToString().find(""comparator"") != std.string.npos)",,true,,,"ASSERT_TRUE(s.ToString().find(""comparator"") != std.string.npos)",,,0,
99651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Status.ASSERT_TRUE(s.ToString().find(""comparator"") != std.string.npos)",,true,,,"ASSERT_TRUE(s.ToString().find(""comparator"") != std.string.npos)",,,0,
99655,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_CustomComparator.TEST(DBTest, CustomComparator)",,true,,,"TEST(DBTest, CustomComparator)",,,0,
99659,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, CustomComparator)",,true,,,"TEST(DBTest, CustomComparator)",,,0,
99666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CustomComparator.CurrentOptions,,true,,,CurrentOptions,,,0,
99669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CustomComparator.DestroyAndReopen,,true,,,DestroyAndReopen,,,0,
99673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""[10]"", ""ten""))",,true,,,"ASSERT_OK(Put(""[10]"", ""ten""))",,,0,
99679,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""[0x14]"", ""twenty""))",,true,,,"ASSERT_OK(Put(""[0x14]"", ""twenty""))",,,0,
99685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""ten"", Get(""[10]""))",,true,,,"ASSERT_EQ(""ten"", Get(""[10]""))",,,0,
99691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""ten"", Get(""[0xa]""))",,true,,,"ASSERT_EQ(""ten"", Get(""[0xa]""))",,,0,
99697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""twenty"", Get(""[20]""))",,true,,,"ASSERT_EQ(""twenty"", Get(""[20]""))",,,0,
99703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""twenty"", Get(""[0x14]""))",,true,,,"ASSERT_EQ(""twenty"", Get(""[0x14]""))",,,0,
99709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""[15]""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""[15]""))",,,0,
99715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""[0xf]""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""[0xf]""))",,,0,
99721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_CustomComparator.Compact,,true,,,Compact,,,0,
99726,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(buf, buf))",,true,,,"ASSERT_OK(Put(buf, buf))",,,0,
99732,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ManualCompaction.TEST(DBTest, ManualCompaction)",,true,,,"TEST(DBTest, ManualCompaction)",,,0,
99736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, ManualCompaction)",,true,,,"TEST(DBTest, ManualCompaction)",,,0,
99743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeTables,,true,,,MakeTables,,,0,
99749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManualCompaction.FilesPerLevel,,true,,,FilesPerLevel,,,0,
99752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""1,1,1"", FilesPerLevel())",,true,,,"ASSERT_EQ(""1,1,1"", FilesPerLevel())",,,0,
99758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManualCompaction.Compact,,true,,,Compact,,,0,
99763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""0,0,1"", FilesPerLevel())",,true,,,"ASSERT_EQ(""0,0,1"", FilesPerLevel())",,,0,
99769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""1,1,2"", FilesPerLevel())",,true,,,"ASSERT_EQ(""1,1,2"", FilesPerLevel())",,,0,
99775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""0,0,2"", FilesPerLevel())",,true,,,"ASSERT_EQ(""0,0,2"", FilesPerLevel())",,,0,
99781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""0,1,2"", FilesPerLevel())",,true,,,"ASSERT_EQ(""0,1,2"", FilesPerLevel())",,,0,
99787,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_DBOpen_Options.TEST(DBTest, DBOpen_Options)",,true,,,"TEST(DBTest, DBOpen_Options)",,,0,
99791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, DBOpen_Options)",,true,,,"TEST(DBTest, DBOpen_Options)",,,0,
99798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL)",,true,,,"ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL)",,,0,
99802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Status.ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL)",,true,,,"ASSERT_TRUE(strstr(s.ToString().c_str(), ""does not exist"") != NULL)",,,0,
99806,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(db == NULL),,true,,,ASSERT_TRUE(db == NULL),,,0,
99812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(s),,true,,,ASSERT_OK(s),,,0,
99818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(db != NULL),,true,,,ASSERT_TRUE(db != NULL),,,0,
99824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL)",,true,,,"ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL)",,,0,
99828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Status.ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL)",,true,,,"ASSERT_TRUE(strstr(s.ToString().c_str(), ""exists"") != NULL)",,,0,
99832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Locking.TEST(DBTest, Locking)",,true,,,"TEST(DBTest, Locking)",,,0,
99836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, Locking)",,true,,,"TEST(DBTest, Locking)",,,0,
99843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Locking.CurrentOptions,,true,,,CurrentOptions,,,0,
99846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_NoSpace.TEST(DBTest, NoSpace)",,true,,,"TEST(DBTest, NoSpace)",,,0,
99850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, NoSpace)",,true,,,"TEST(DBTest, NoSpace)",,,0,
99857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoSpace.CurrentOptions,,true,,,CurrentOptions,,,0,
99860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoSpace.Reopen,,true,,,Reopen,,,0,
99864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoSpace.Compact,,true,,,Compact,,,0,
99869,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoSpace.CountFiles,,true,,,CountFiles,,,0,
99872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoSpace.dbfull,,true,,,dbfull,,,0,
99875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(CountFiles(), num_files + 3)",,true,,,"ASSERT_LT(CountFiles(), num_files + 3)",,,0,
99881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_NonWritableFileSystem.TEST(DBTest, NonWritableFileSystem)",,true,,,"TEST(DBTest, NonWritableFileSystem)",,,0,
99885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, NonWritableFileSystem)",,true,,,"TEST(DBTest, NonWritableFileSystem)",,,0,
99892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NonWritableFileSystem.CurrentOptions,,true,,,CurrentOptions,,,0,
99895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NonWritableFileSystem.Reopen,,true,,,Reopen,,,0,
99899,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,big,,true,,,big,,,0,
99904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(errors, 0)",,true,,,"ASSERT_GT(errors, 0)",,,0,
99910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_WriteSyncError.TEST(DBTest, WriteSyncError)",,true,,,"TEST(DBTest, WriteSyncError)",,,0,
99914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, WriteSyncError)",,true,,,"TEST(DBTest, WriteSyncError)",,,0,
99921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_WriteSyncError.CurrentOptions,,true,,,CurrentOptions,,,0,
99924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_WriteSyncError.Reopen,,true,,,Reopen,,,0,
99928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(w, ""k1"", ""v1""))",,true,,,"ASSERT_OK(db_->Put(w, ""k1"", ""v1""))",,,0,
99935,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""v1"", Get(""k1""))",,true,,,"ASSERT_EQ(""v1"", Get(""k1""))",,,0,
99941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!db_->Put(w, ""k2"", ""v2"").ok())",,true,,,"ASSERT_TRUE(!db_->Put(w, ""k2"", ""v2"").ok())",,,0,
99948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""k2""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""k2""))",,,0,
99954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!db_->Put(w, ""k3"", ""v3"").ok())",,true,,,"ASSERT_TRUE(!db_->Put(w, ""k3"", ""v3"").ok())",,,0,
99961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(""k3""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(""k3""))",,,0,
99967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ManifestWriteError.TEST(DBTest, ManifestWriteError)",,true,,,"TEST(DBTest, ManifestWriteError)",,,0,
99971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, ManifestWriteError)",,true,,,"TEST(DBTest, ManifestWriteError)",,,0,
99978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestWriteError.CurrentOptions,,true,,,CurrentOptions,,,0,
99981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestWriteError.DestroyAndReopen,,true,,,DestroyAndReopen,,,0,
99985,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(""foo"", ""bar""))",,true,,,"ASSERT_OK(Put(""foo"", ""bar""))",,,0,
99991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""bar"", Get(""foo""))",,true,,,"ASSERT_EQ(""bar"", Get(""foo""))",,,0,
99997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestWriteError.dbfull,,true,,,dbfull,,,0,
100000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestWriteError.NumTableFilesAtLevel,,true,,,NumTableFilesAtLevel,,,0,
100004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestWriteError.Reopen,,true,,,Reopen,,,0,
100008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MissingSSTFile.TEST(DBTest, MissingSSTFile)",,true,,,"TEST(DBTest, MissingSSTFile)",,,0,
100012,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, MissingSSTFile)",,true,,,"TEST(DBTest, MissingSSTFile)",,,0,
100019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingSSTFile.dbfull,,true,,,dbfull,,,0,
100022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingSSTFile.Close,,true,,,Close,,,0,
100025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingSSTFile.DeleteAnSSTFile,,true,,,DeleteAnSSTFile,,,0,
100028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(DeleteAnSSTFile()),,true,,,ASSERT_TRUE(DeleteAnSSTFile()),,,0,
100034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingSSTFile.CurrentOptions,,true,,,CurrentOptions,,,0,
100037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingSSTFile.TryReopen,,true,,,TryReopen,,,0,
100041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(s.ToString().find(""issing"") != std.string.npos)",,true,,,"ASSERT_TRUE(s.ToString().find(""issing"") != std.string.npos)",,,0,
100046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Status.ASSERT_TRUE(s.ToString().find(""issing"") != std.string.npos)",,true,,,"ASSERT_TRUE(s.ToString().find(""issing"") != std.string.npos)",,,0,
100050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_StillReadSST.TEST(DBTest, StillReadSST)",,true,,,"TEST(DBTest, StillReadSST)",,,0,
100054,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, StillReadSST)",,true,,,"TEST(DBTest, StillReadSST)",,,0,
100061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_StillReadSST.dbfull,,true,,,dbfull,,,0,
100064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_StillReadSST.Close,,true,,,Close,,,0,
100067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_StillReadSST.RenameLDBToSST,,true,,,RenameLDBToSST,,,0,
100070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(RenameLDBToSST(), 0)",,true,,,"ASSERT_GT(RenameLDBToSST(), 0)",,,0,
100076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_StillReadSST.CurrentOptions,,true,,,CurrentOptions,,,0,
100079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_StillReadSST.TryReopen,,true,,,TryReopen,,,0,
100083,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_FilesDeletedAfterCompaction.TEST(DBTest, FilesDeletedAfterCompaction)",,true,,,"TEST(DBTest, FilesDeletedAfterCompaction)",,,0,
100087,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, FilesDeletedAfterCompaction)",,true,,,"TEST(DBTest, FilesDeletedAfterCompaction)",,,0,
100094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_FilesDeletedAfterCompaction.Compact,,true,,,Compact,,,0,
100099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_FilesDeletedAfterCompaction.CountFiles,,true,,,CountFiles,,,0,
100102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(CountFiles(), num_files)",,true,,,"ASSERT_EQ(CountFiles(), num_files)",,,0,
100108,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_BloomFilter.TEST(DBTest, BloomFilter)",,true,,,"TEST(DBTest, BloomFilter)",,,0,
100112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, BloomFilter)",,true,,,"TEST(DBTest, BloomFilter)",,,0,
100119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.CurrentOptions,,true,,,CurrentOptions,,,0,
100122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.Reopen,,true,,,Reopen,,,0,
100126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Put(Key(i), Key(i)))",,true,,,"ASSERT_OK(Put(Key(i), Key(i)))",,,0,
100132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.Put,,true,,,Put,,,0,
100137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.Compact,,true,,,Compact,,,0,
100142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.dbfull,,true,,,dbfull,,,0,
100145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reset,,true,,,Reset,,,0,
100149,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.Get,,true,,,Get,,,0,
100153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(Key(i), Get(Key(i)))",,true,,,"ASSERT_EQ(Key(i), Get(Key(i)))",,,0,
100159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Read,,true,,,Read,,,0,
100166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(reads, N)",,true,,,"ASSERT_GE(reads, N)",,,0,
100172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(reads, N + 2*N/100)",,true,,,"ASSERT_LE(reads, N + 2*N/100)",,,0,
100178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""NOT_FOUND"", Get(Key(i) + "".missing""))",,true,,,"ASSERT_EQ(""NOT_FOUND"", Get(Key(i) + "".missing""))",,,0,
100184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(reads, 3*N/100)",,true,,,"ASSERT_LE(reads, 3*N/100)",,,0,
100190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BloomFilter.Close,,true,,,Close,,,0,
100193,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Random.Uniform,,true,,,Uniform,,,0,
100197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Random.OneIn,,true,,,OneIn,,,0,
100202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)))",,true,,,"ASSERT_OK(db->Put(WriteOptions(), Slice(keybuf), Slice(valbuf)))",,,0,
100209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, sscanf(value.c_str(), ""%d.%d.%d"", &k, &w, &c))",,true,,,"ASSERT_EQ(3, sscanf(value.c_str(), ""%d.%d.%d"", &k, &w, &c))",,,0,
100213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(k, key)",,true,,,"ASSERT_EQ(k, key)",,,0,
100219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(w, 0)",,true,,,"ASSERT_GE(w, 0)",,,0,
100225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(w, kNumThreads)",,true,,,"ASSERT_LT(w, kNumThreads)",,,0,
100231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(static_cast<uintptr_t>(c), reinterpret_cast<uintptr_t>(
            t->state->counter[w].Acquire_Load()))",,true,,,"ASSERT_LE(static_cast<uintptr_t>(c), reinterpret_cast<uintptr_t>(
            t->state->counter[w].Acquire_Load()))",,,0,
100235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MultiThreaded.TEST(DBTest, MultiThreaded)",,true,,,"TEST(DBTest, MultiThreaded)",,,0,
100239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, MultiThreaded)",,true,,,"TEST(DBTest, MultiThreaded)",,,0,
100246,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultiThreaded.ChangeOptions,,true,,,ChangeOptions,,,0,
100249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModelDB.DB.Put,,true,,,DB.Put,,,0,
100256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModelDB.DB.Delete,,true,,,DB.Delete,,,0,
100262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rbegin,,true,,,rbegin,,,0,
100266,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lower_bound,,true,,,lower_bound,,,0,
100271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.preDecrement,,true,,,<operator>.preDecrement,,,0,
100275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,OneIn,,true,,,OneIn,,,0,
100280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Skewed,,true,,,Skewed,,,0,
100285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,test.RandomKey,,true,,,test.RandomKey,,,0,
100291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare,,true,,,compare,,,0,
100296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EscapeString,,true,,,EscapeString,,,0,
100300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Randomized.TEST(DBTest, Randomized)",,true,,,"TEST(DBTest, Randomized)",,,0,
100304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(DBTest, Randomized)",,true,,,"TEST(DBTest, Randomized)",,,0,
100311,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,test.RandomSeed,,true,,,test.RandomSeed,,,0,
100315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,model,,true,,,model,,,0,
100319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Randomized.CurrentOptions,,true,,,CurrentOptions,,,0,
100322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomKey,,true,,,RandomKey,,,0,
100326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(model.Put(WriteOptions(), k, v))",,true,,,"ASSERT_OK(model.Put(WriteOptions(), k, v))",,,0,
100332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ModelDB.ASSERT_OK(model.Put(WriteOptions(), k, v))",,true,,,"ASSERT_OK(model.Put(WriteOptions(), k, v))",,,0,
100339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Put(WriteOptions(), k, v))",,true,,,"ASSERT_OK(db_->Put(WriteOptions(), k, v))",,,0,
100346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(model.Delete(WriteOptions(), k))",,true,,,"ASSERT_OK(model.Delete(WriteOptions(), k))",,,0,
100352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ModelDB.ASSERT_OK(model.Delete(WriteOptions(), k))",,true,,,"ASSERT_OK(model.Delete(WriteOptions(), k))",,,0,
100358,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Delete(WriteOptions(), k))",,true,,,"ASSERT_OK(db_->Delete(WriteOptions(), k))",,,0,
100364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(model.Write(WriteOptions(), &b))",,true,,,"ASSERT_OK(model.Write(WriteOptions(), &b))",,,0,
100370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ModelDB.ASSERT_OK(model.Write(WriteOptions(), &b))",,true,,,"ASSERT_OK(model.Write(WriteOptions(), &b))",,,0,
100376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Write(WriteOptions(), &b))",,true,,,"ASSERT_OK(db_->Write(WriteOptions(), &b))",,,0,
100382,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(CompareIterators(step, &model, db_, NULL, NULL))",,true,,,"ASSERT_TRUE(CompareIterators(step, &model, db_, NULL, NULL))",,,0,
100388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CompareIterators,,true,,,CompareIterators,,,0,
100396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(CompareIterators(step, &model, db_, model_snap, db_snap))",,true,,,"ASSERT_TRUE(CompareIterators(step, &model, db_, model_snap, db_snap))",,,0,
100402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModelDB.ReleaseSnapshot,,true,,,ReleaseSnapshot,,,0,
100407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Randomized.Reopen,,true,,,Reopen,,,0,
100410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ModelDB.GetSnapshot,,true,,,GetSnapshot,,,0,
100414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Randomized.ChangeOptions,,true,,,ChangeOptions,,,0,
100417,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cmp,,true,,,cmp,,,0,
100421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BytewiseComparator,,true,,,BytewiseComparator,,,0,
100424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vset,,true,,,vset,,,0,
100431,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.ASSERT_OK(vset.Recover(&save_manifest)),,true,,,ASSERT_OK(vset.Recover(&save_manifest)),,,0,
100436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(vset.Recover(&save_manifest)),,true,,,ASSERT_OK(vset.Recover(&save_manifest)),,,0,
100442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,start,,true,,,start,,,0,
100448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeKey,,true,,,MakeKey,,,0,
100453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,limit,,true,,,limit,,,0,
100459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.AddFile,,true,,,AddFile,,,0,
100468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(vset.LogAndApply(&vbase, &mu))",,true,,,"ASSERT_OK(vset.LogAndApply(&vbase, &mu))",,,0,
100474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"VersionSet.ASSERT_OK(vset.LogAndApply(&vbase, &mu))",,true,,,"ASSERT_OK(vset.LogAndApply(&vbase, &mu))",,,0,
100480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.DeleteFile,,true,,,DeleteFile,,,0,
100486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.LogAndApply,,true,,,LogAndApply,,,0,
100492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.or,,true,,,<operator>.or,,,0,
100497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PutFixed64,,true,,,PutFixed64,,,0,
100502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PackSequenceAndType,,true,,,PackSequenceAndType,,,0,
100507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ParsedInternalKey.DebugString,,true,,,DebugString,,,0,
100511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeFixed64,,true,,,DecodeFixed64,,,0,
100515,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tmp,,true,,,tmp,,,0,
100520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindShortestSeparator,,true,,,FindShortestSeparator,,,0,
100526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindShortSuccessor,,true,,,FindShortSuccessor,,,0,
100531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CreateFilter,,true,,,CreateFilter,,,0,
100538,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyMayMatch,,true,,,KeyMayMatch,,,0,
100544,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeVarint32,,true,,,EncodeVarint32,,,0,
100549,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeFixed64,,true,,,EncodeFixed64,,,0,
100554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.and,,true,,,<operator>.and,,,0,
100559,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Encode,,true,,,Encode,,,0,
100563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.arithmeticShiftRight,,true,,,<operator>.arithmeticShiftRight,,,0,
100568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalKeyComparator,,true,,,InternalKeyComparator,,,0,
100572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IKey,,true,,,IKey,,,0,
100578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,decoded,,true,,,decoded,,,0,
100584,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(ParseInternalKey(in, &decoded))",,true,,,"ASSERT_TRUE(ParseInternalKey(in, &decoded))",,,0,
100590,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(key, decoded.user_key.ToString())",,true,,,"ASSERT_EQ(key, decoded.user_key.ToString())",,,0,
100594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(seq, decoded.sequence)",,true,,,"ASSERT_EQ(seq, decoded.sequence)",,,0,
100600,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(vt, decoded.type)",,true,,,"ASSERT_EQ(vt, decoded.type)",,,0,
100606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!ParseInternalKey(Slice(""bar""), &decoded))",,true,,,"ASSERT_TRUE(!ParseInternalKey(Slice(""bar""), &decoded))",,,0,
100612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_InternalKey_EncodeDecode.TEST(FormatTest, InternalKey_EncodeDecode)",,true,,,"TEST(FormatTest, InternalKey_EncodeDecode)",,,0,
100616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FormatTest, InternalKey_EncodeDecode)",,true,,,"TEST(FormatTest, InternalKey_EncodeDecode)",,,0,
100623,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestKey,,true,,,TestKey,,,0,
100629,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_InternalKeyShortSeparator.TEST(FormatTest, InternalKeyShortSeparator)",,true,,,"TEST(FormatTest, InternalKeyShortSeparator)",,,0,
100633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FormatTest, InternalKeyShortSeparator)",,true,,,"TEST(FormatTest, InternalKeyShortSeparator)",,,0,
100640,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 99, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 99, kTypeValue)))",,,0,
100646,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Shorten,,true,,,Shorten,,,0,
100651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 101, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 101, kTypeValue)))",,,0,
100657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeValue)))",,,0,
100663,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeDeletion)))",,true,,,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foo"", 100, kTypeDeletion)))",,,0,
100669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""bar"", 99, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""bar"", 99, kTypeValue)))",,,0,
100675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""hello"", 200, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""hello"", 200, kTypeValue)))",,,0,
100681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foobar"", 200, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""foo"", 100, kTypeValue),
            Shorten(IKey(""foo"", 100, kTypeValue),
                    IKey(""foobar"", 200, kTypeValue)))",,,0,
100687,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""foobar"", 100, kTypeValue),
            Shorten(IKey(""foobar"", 100, kTypeValue),
                    IKey(""foo"", 200, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""foobar"", 100, kTypeValue),
            Shorten(IKey(""foobar"", 100, kTypeValue),
                    IKey(""foo"", 200, kTypeValue)))",,,0,
100693,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_InternalKeyShortestSuccessor.TEST(FormatTest, InternalKeyShortestSuccessor)",,true,,,"TEST(FormatTest, InternalKeyShortestSuccessor)",,,0,
100697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FormatTest, InternalKeyShortestSuccessor)",,true,,,"TEST(FormatTest, InternalKeyShortestSuccessor)",,,0,
100704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            ShortSuccessor(IKey(""foo"", 100, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""g"", kMaxSequenceNumber, kValueTypeForSeek),
            ShortSuccessor(IKey(""foo"", 100, kTypeValue)))",,,0,
100710,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ShortSuccessor,,true,,,ShortSuccessor,,,0,
100714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(IKey(""\xff\xff"", 100, kTypeValue),
            ShortSuccessor(IKey(""\xff\xff"", 100, kTypeValue)))",,true,,,"ASSERT_EQ(IKey(""\xff\xff"", 100, kTypeValue),
            ShortSuccessor(IKey(""\xff\xff"", 100, kTypeValue)))",,,0,
100720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rfind,,true,,,rfind,,,0,
100725,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendNumberTo,,true,,,AppendNumberTo,,,0,
100730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*func,,true,,,*func,,,0,
100737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reader.LastRecordOffset,,true,,,LastRecordOffset,,,0,
100741,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AppendEscapedStringTo,,true,,,AppendEscapedStringTo,,,0,
100746,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteBatch.Iterate,,true,,,Iterate,,,0,
100751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintLogContents,,true,,,PrintLogContents,,,0,
100758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.DecodeFrom,,true,,,DecodeFrom,,,0,
100763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.DebugString,,true,,,DebugString,,,0,
100767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Table.Open,,true,,,Table.Open,,,0,
100775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GuessType,,true,,,GuessType,,,0,
100780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DumpLog,,true,,,DumpLog,,,0,
100786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DumpDescriptor,,true,,,DumpDescriptor,,,0,
100792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DumpTable,,true,,,DumpTable,,,0,
100798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,find_last_of,,true,,,find_last_of,,,0,
100803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,substr,,true,,,substr,,,0,
100808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetDirName,,true,,,GetDirName,,,0,
100812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestWritableFile.Close,,true,,,Close,,,0,
100815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFilesystemActive,,true,,,IsFilesystemActive,,,0,
100819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WritableFileClosed,,true,,,WritableFileClosed,,,0,
100824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Flush,,true,,,Flush,,,0,
100828,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SyncDir,,true,,,SyncDir,,,0,
100832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DirWasSynced,,true,,,DirWasSynced,,,0,
100836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFileCreatedSinceLastDirSync,,true,,,IsFileCreatedSinceLastDirSync,,,0,
100841,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestWritableFile.SyncParent,,true,,,SyncParent,,,0,
100844,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTestEnv.target,,true,,,target,,,0,
100847,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,state,,true,,,state,,,0,
100851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTestEnv.UntrackFile,,true,,,UntrackFile,,,0,
100855,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,count,,true,,,count,,,0,
100860,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IsFullySynced,,true,,,IsFullySynced,,,0,
100864,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DropUnsyncedData,,true,,,DropUnsyncedData,,,0,
100868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTestEnv.EnvWrapper.DeleteFile,,true,,,EnvWrapper.DeleteFile,,,0,
100873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTestEnv.EnvWrapper.RenameFile,,true,,,EnvWrapper.RenameFile,,,0,
100879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTestEnv.SetFilesystemActive,,true,,,SetFilesystemActive,,,0,
100883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,new_files,,true,,,new_files,,,0,
100888,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTestEnv.DeleteFile,,true,,,DeleteFile,,,0,
100892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Truncate,,true,,,Truncate,,,0,
100897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.CloseDB,,true,,,CloseDB,,,0,
100900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.Key,,true,,,Key,,,0,
100905,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.Value,,true,,,Value,,,0,
100910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadValue,,true,,,ReadValue,,,0,
100915,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(value_space, val)",,true,,,"ASSERT_EQ(value_space, val)",,,0,
100921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ResetState,,true,,,ResetState,,,0,
100925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db_->Delete(WriteOptions(), iter->key()))",,true,,,"ASSERT_OK(db_->Delete(WriteOptions(), iter->key()))",,,0,
100929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(env_->DropUnsyncedFileData()),,true,,,ASSERT_OK(env_->DropUnsyncedFileData()),,,0,
100933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync()),,true,,,ASSERT_OK(env_->DeleteFilesCreatedAfterLastDirSync()),,,0,
100937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.DeleteAllData,,true,,,DeleteAllData,,,0,
100940,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.Build,,true,,,Build,,,0,
100945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetFilesystemActive,,true,,,SetFilesystemActive,,,0,
100950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.ResetDBState,,true,,,ResetDBState,,,0,
100954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.OpenDB,,true,,,OpenDB,,,0,
100957,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(OpenDB()),,true,,,ASSERT_OK(OpenDB()),,,0,
100963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Verify(0, num_pre_sync, FaultInjectionTest.VAL_EXPECT_NO_ERROR))",,true,,,"ASSERT_OK(Verify(0, num_pre_sync, FaultInjectionTest.VAL_EXPECT_NO_ERROR))",,,0,
100969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.Verify,,true,,,Verify,,,0,
100975,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(Verify(num_pre_sync, num_post_sync, FaultInjectionTest.VAL_EXPECT_ERROR))",,true,,,"ASSERT_OK(Verify(num_pre_sync, num_post_sync, FaultInjectionTest.VAL_EXPECT_ERROR))",,,0,
100981,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.PartialCompactTestPreFault,,true,,,PartialCompactTestPreFault,,,0,
100986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.PartialCompactTestReopenWithFault,,true,,,PartialCompactTestReopenWithFault,,,0,
100992,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.NoWriteTestPreFault,,true,,,NoWriteTestPreFault,,,0,
100995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FaultInjectionTest.NoWriteTestReopenWithFault,,true,,,NoWriteTestReopenWithFault,,,0,
100999,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_FaultTestNoLogReuse.TEST(FaultInjectionTest, FaultTestNoLogReuse)",,true,,,"TEST(FaultInjectionTest, FaultTestNoLogReuse)",,,0,
101003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FaultInjectionTest, FaultTestNoLogReuse)",,true,,,"TEST(FaultInjectionTest, FaultTestNoLogReuse)",,,0,
101010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_FaultTestNoLogReuse.ReuseLogs,,true,,,ReuseLogs,,,0,
101014,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_FaultTestNoLogReuse.DoTest,,true,,,DoTest,,,0,
101017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_FaultTestWithLogReuse.TEST(FaultInjectionTest, FaultTestWithLogReuse)",,true,,,"TEST(FaultInjectionTest, FaultTestWithLogReuse)",,,0,
101021,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FaultInjectionTest, FaultTestWithLogReuse)",,true,,,"TEST(FaultInjectionTest, FaultTestWithLogReuse)",,,0,
101028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_FaultTestWithLogReuse.ReuseLogs,,true,,,ReuseLogs,,,0,
101032,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_FaultTestWithLogReuse.DoTest,,true,,,DoTest,,,0,
101035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeFileName,,true,,,MakeFileName,,,0,
101041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rest,,true,,,rest,,,0,
101045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TempFileName,,true,,,TempFileName,,,0,
101050,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteStringToFileSync,,true,,,WriteStringToFileSync,,,0,
101056,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Parse.TEST(FileNameTest, Parse)",,true,,,"TEST(FileNameTest, Parse)",,,0,
101060,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FileNameTest, Parse)",,true,,,"TEST(FileNameTest, Parse)",,,0,
101067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(ParseFileName(f, &number, &type))",,true,,,"ASSERT_TRUE(ParseFileName(f, &number, &type))",,,0,
101073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(cases[i].type, type)",,true,,,"ASSERT_EQ(cases[i].type, type)",,,0,
101079,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(cases[i].number, number)",,true,,,"ASSERT_EQ(cases[i].number, number)",,,0,
101085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!ParseFileName(f, &number, &type))",,true,,,"ASSERT_TRUE(!ParseFileName(f, &number, &type))",,,0,
101091,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Construction.TEST(FileNameTest, Construction)",,true,,,"TEST(FileNameTest, Construction)",,,0,
101095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FileNameTest, Construction)",,true,,,"TEST(FileNameTest, Construction)",,,0,
101102,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""foo/"", std.string(fname.data(), 4))",,true,,,"ASSERT_EQ(""foo/"", std.string(fname.data(), 4))",,,0,
101106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type))",,true,,,"ASSERT_TRUE(ParseFileName(fname.c_str() + 4, &number, &type))",,,0,
101110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, number)",,true,,,"ASSERT_EQ(0, number)",,,0,
101116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kCurrentFile, type)",,true,,,"ASSERT_EQ(kCurrentFile, type)",,,0,
101122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kDBLockFile, type)",,true,,,"ASSERT_EQ(kDBLockFile, type)",,,0,
101128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(192, number)",,true,,,"ASSERT_EQ(192, number)",,,0,
101134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kLogFile, type)",,true,,,"ASSERT_EQ(kLogFile, type)",,,0,
101140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""bar/"", std.string(fname.data(), 4))",,true,,,"ASSERT_EQ(""bar/"", std.string(fname.data(), 4))",,,0,
101144,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(200, number)",,true,,,"ASSERT_EQ(200, number)",,,0,
101150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kTableFile, type)",,true,,,"ASSERT_EQ(kTableFile, type)",,,0,
101156,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(100, number)",,true,,,"ASSERT_EQ(100, number)",,,0,
101162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kDescriptorFile, type)",,true,,,"ASSERT_EQ(kDescriptorFile, type)",,,0,
101168,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""tmp/"", std.string(fname.data(), 4))",,true,,,"ASSERT_EQ(""tmp/"", std.string(fname.data(), 4))",,,0,
101172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(999, number)",,true,,,"ASSERT_EQ(999, number)",,,0,
101178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kTempFile, type)",,true,,,"ASSERT_EQ(kTempFile, type)",,,0,
101184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fwrite,,true,,,fwrite,,,0,
101191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DumpFile,,true,,,DumpFile,,,0,
101197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.HandleDumpCommand,,true,,,leveldb.HandleDumpCommand,,,0,
101204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Skip,,true,,,Skip,,,0,
101209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reader.ReportDrop,,true,,,ReportDrop,,,0,
101214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reader.SkipToInitialBlock,,true,,,SkipToInitialBlock,,,0,
101217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reader.ReadPhysicalRecord,,true,,,ReadPhysicalRecord,,,0,
101221,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportCorruption,,true,,,ReportCorruption,,,0,
101226,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reader.ReportCorruption,,true,,,ReportCorruption,,,0,
101231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Corruption,,true,,,Corruption,,,0,
101237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReportDrop,,true,,,ReportDrop,,,0,
101242,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crc32c.Unmask,,true,,,crc32c.Unmask,,,0,
101247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeFixed32,,true,,,DecodeFixed32,,,0,
101251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,remove_prefix,,true,,,remove_prefix,,,0,
101256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BigString,,true,,,BigString,,,0,
101261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NumberString,,true,,,NumberString,,,0,
101265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!returned_partial_),,true,,,ASSERT_TRUE(!returned_partial_),,,0,
101271,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!reading_),,true,,,ASSERT_TRUE(!reading_),,,0,
101277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadRecord,,true,,,ReadRecord,,,0,
101283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crc32c.Mask,,true,,,crc32c.Mask,,,0,
101288,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeFixed32,,true,,,EncodeFixed32,,,0,
101293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,record,,true,,,record,,,0,
101298,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogTest.Write,,true,,,Write,,,0,
101302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogTest.WriteInitialOffsetLog,,true,,,WriteInitialOffsetLog,,,0,
101305,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogTest.WrittenBytes,,true,,,WrittenBytes,,,0,
101308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch))",,true,,,"ASSERT_TRUE(!offset_reader->ReadRecord(&record, &scratch))",,,0,
101314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(expected_record_offset, num_initial_offset_records_)",,true,,,"ASSERT_LT(expected_record_offset, num_initial_offset_records_)",,,0,
101320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch))",,true,,,"ASSERT_TRUE(offset_reader->ReadRecord(&record, &scratch))",,,0,
101326,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size())",,true,,,"ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size())",,,0,
101330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size())",,true,,,"ASSERT_EQ(initial_offset_record_sizes_[expected_record_offset],
                record.size())",,,0,
101336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset())",,true,,,"ASSERT_EQ(initial_offset_last_record_offsets_[expected_record_offset],
                offset_reader->LastRecordOffset())",,,0,
101340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0])",,true,,,"ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0])",,,0,
101344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0])",,true,,,"ASSERT_EQ((char)('a' + expected_record_offset), record.data()[0])",,,0,
101350,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(LogTest, Empty)",,true,,,"TEST(LogTest, Empty)",,,0,
101354,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, Empty)",,true,,,"TEST(LogTest, Empty)",,,0,
101361,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Empty.Read,,true,,,Read,,,0,
101364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""EOF"", Read())",,true,,,"ASSERT_EQ(""EOF"", Read())",,,0,
101370,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadWrite.TEST(LogTest, ReadWrite)",,true,,,"TEST(LogTest, ReadWrite)",,,0,
101374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadWrite)",,true,,,"TEST(LogTest, ReadWrite)",,,0,
101381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadWrite.Read,,true,,,Read,,,0,
101384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""foo"", Read())",,true,,,"ASSERT_EQ(""foo"", Read())",,,0,
101390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""bar"", Read())",,true,,,"ASSERT_EQ(""bar"", Read())",,,0,
101396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ("""", Read())",,true,,,"ASSERT_EQ("""", Read())",,,0,
101402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""xxxx"", Read())",,true,,,"ASSERT_EQ(""xxxx"", Read())",,,0,
101408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ManyBlocks.TEST(LogTest, ManyBlocks)",,true,,,"TEST(LogTest, ManyBlocks)",,,0,
101412,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ManyBlocks)",,true,,,"TEST(LogTest, ManyBlocks)",,,0,
101419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManyBlocks.Write,,true,,,Write,,,0,
101423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManyBlocks.Read,,true,,,Read,,,0,
101426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(NumberString(i), Read())",,true,,,"ASSERT_EQ(NumberString(i), Read())",,,0,
101432,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Fragmentation.TEST(LogTest, Fragmentation)",,true,,,"TEST(LogTest, Fragmentation)",,,0,
101436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, Fragmentation)",,true,,,"TEST(LogTest, Fragmentation)",,,0,
101443,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Fragmentation.Read,,true,,,Read,,,0,
101446,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""small"", Read())",,true,,,"ASSERT_EQ(""small"", Read())",,,0,
101452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(BigString(""medium"", 50000), Read())",,true,,,"ASSERT_EQ(BigString(""medium"", 50000), Read())",,,0,
101458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(BigString(""large"", 100000), Read())",,true,,,"ASSERT_EQ(BigString(""large"", 100000), Read())",,,0,
101464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MarginalTrailer.TEST(LogTest, MarginalTrailer)",,true,,,"TEST(LogTest, MarginalTrailer)",,,0,
101468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, MarginalTrailer)",,true,,,"TEST(LogTest, MarginalTrailer)",,,0,
101475,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MarginalTrailer.WrittenBytes,,true,,,WrittenBytes,,,0,
101478,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes())",,true,,,"ASSERT_EQ(kBlockSize - kHeaderSize, WrittenBytes())",,,0,
101484,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MarginalTrailer.Read,,true,,,Read,,,0,
101487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(BigString(""foo"", n), Read())",,true,,,"ASSERT_EQ(BigString(""foo"", n), Read())",,,0,
101493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MarginalTrailer2.TEST(LogTest, MarginalTrailer2)",,true,,,"TEST(LogTest, MarginalTrailer2)",,,0,
101497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, MarginalTrailer2)",,true,,,"TEST(LogTest, MarginalTrailer2)",,,0,
101504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MarginalTrailer2.WrittenBytes,,true,,,WrittenBytes,,,0,
101507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MarginalTrailer2.Read,,true,,,Read,,,0,
101510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MarginalTrailer2.DroppedBytes,,true,,,DroppedBytes,,,0,
101513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, DroppedBytes())",,true,,,"ASSERT_EQ(0, DroppedBytes())",,,0,
101519,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MarginalTrailer2.ReportMessage,,true,,,ReportMessage,,,0,
101522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ("""", ReportMessage())",,true,,,"ASSERT_EQ("""", ReportMessage())",,,0,
101528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ShortTrailer.TEST(LogTest, ShortTrailer)",,true,,,"TEST(LogTest, ShortTrailer)",,,0,
101532,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ShortTrailer)",,true,,,"TEST(LogTest, ShortTrailer)",,,0,
101539,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ShortTrailer.WrittenBytes,,true,,,WrittenBytes,,,0,
101542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes())",,true,,,"ASSERT_EQ(kBlockSize - kHeaderSize + 4, WrittenBytes())",,,0,
101548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ShortTrailer.Read,,true,,,Read,,,0,
101551,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_AlignedEof.TEST(LogTest, AlignedEof)",,true,,,"TEST(LogTest, AlignedEof)",,,0,
101555,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, AlignedEof)",,true,,,"TEST(LogTest, AlignedEof)",,,0,
101562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_AlignedEof.WrittenBytes,,true,,,WrittenBytes,,,0,
101565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_AlignedEof.Read,,true,,,Read,,,0,
101568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_OpenForAppend.TEST(LogTest, OpenForAppend)",,true,,,"TEST(LogTest, OpenForAppend)",,,0,
101572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, OpenForAppend)",,true,,,"TEST(LogTest, OpenForAppend)",,,0,
101579,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OpenForAppend.ReopenForAppend,,true,,,ReopenForAppend,,,0,
101582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OpenForAppend.Read,,true,,,Read,,,0,
101585,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""hello"", Read())",,true,,,"ASSERT_EQ(""hello"", Read())",,,0,
101591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""world"", Read())",,true,,,"ASSERT_EQ(""world"", Read())",,,0,
101597,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RandomRead.TEST(LogTest, RandomRead)",,true,,,"TEST(LogTest, RandomRead)",,,0,
101601,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, RandomRead)",,true,,,"TEST(LogTest, RandomRead)",,,0,
101608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,write_rnd,,true,,,write_rnd,,,0,
101612,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RandomRead.Write,,true,,,Write,,,0,
101616,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomSkewedString,,true,,,RandomSkewedString,,,0,
101621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,read_rnd,,true,,,read_rnd,,,0,
101625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RandomRead.Read,,true,,,Read,,,0,
101628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read())",,true,,,"ASSERT_EQ(RandomSkewedString(i, &read_rnd), Read())",,,0,
101634,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadError.TEST(LogTest, ReadError)",,true,,,"TEST(LogTest, ReadError)",,,0,
101638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadError)",,true,,,"TEST(LogTest, ReadError)",,,0,
101645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadError.ForceError,,true,,,ForceError,,,0,
101648,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadError.Read,,true,,,Read,,,0,
101651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ReadError.DroppedBytes,,true,,,DroppedBytes,,,0,
101654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kBlockSize, DroppedBytes())",,true,,,"ASSERT_EQ(kBlockSize, DroppedBytes())",,,0,
101660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""OK"", MatchError(""read error""))",,true,,,"ASSERT_EQ(""OK"", MatchError(""read error""))",,,0,
101666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MatchError,,true,,,MatchError,,,0,
101670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_BadRecordType.TEST(LogTest, BadRecordType)",,true,,,"TEST(LogTest, BadRecordType)",,,0,
101674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, BadRecordType)",,true,,,"TEST(LogTest, BadRecordType)",,,0,
101681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadRecordType.IncrementByte,,true,,,IncrementByte,,,0,
101686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadRecordType.FixChecksum,,true,,,FixChecksum,,,0,
101691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadRecordType.Read,,true,,,Read,,,0,
101694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadRecordType.DroppedBytes,,true,,,DroppedBytes,,,0,
101697,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, DroppedBytes())",,true,,,"ASSERT_EQ(3, DroppedBytes())",,,0,
101703,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""OK"", MatchError(""unknown record type""))",,true,,,"ASSERT_EQ(""OK"", MatchError(""unknown record type""))",,,0,
101709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_TruncatedTrailingRecordIsIgnored.TEST(LogTest, TruncatedTrailingRecordIsIgnored)",,true,,,"TEST(LogTest, TruncatedTrailingRecordIsIgnored)",,,0,
101713,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, TruncatedTrailingRecordIsIgnored)",,true,,,"TEST(LogTest, TruncatedTrailingRecordIsIgnored)",,,0,
101720,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TruncatedTrailingRecordIsIgnored.ShrinkSize,,true,,,ShrinkSize,,,0,
101724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TruncatedTrailingRecordIsIgnored.Read,,true,,,Read,,,0,
101727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TruncatedTrailingRecordIsIgnored.DroppedBytes,,true,,,DroppedBytes,,,0,
101730,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_TruncatedTrailingRecordIsIgnored.ReportMessage,,true,,,ReportMessage,,,0,
101733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_BadLength.TEST(LogTest, BadLength)",,true,,,"TEST(LogTest, BadLength)",,,0,
101737,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, BadLength)",,true,,,"TEST(LogTest, BadLength)",,,0,
101744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLength.IncrementByte,,true,,,IncrementByte,,,0,
101749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLength.Read,,true,,,Read,,,0,
101752,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLength.DroppedBytes,,true,,,DroppedBytes,,,0,
101755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""OK"", MatchError(""bad record length""))",,true,,,"ASSERT_EQ(""OK"", MatchError(""bad record length""))",,,0,
101761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_BadLengthAtEndIsIgnored.TEST(LogTest, BadLengthAtEndIsIgnored)",,true,,,"TEST(LogTest, BadLengthAtEndIsIgnored)",,,0,
101765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, BadLengthAtEndIsIgnored)",,true,,,"TEST(LogTest, BadLengthAtEndIsIgnored)",,,0,
101772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLengthAtEndIsIgnored.ShrinkSize,,true,,,ShrinkSize,,,0,
101776,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLengthAtEndIsIgnored.Read,,true,,,Read,,,0,
101779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLengthAtEndIsIgnored.DroppedBytes,,true,,,DroppedBytes,,,0,
101782,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_BadLengthAtEndIsIgnored.ReportMessage,,true,,,ReportMessage,,,0,
101785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ChecksumMismatch.TEST(LogTest, ChecksumMismatch)",,true,,,"TEST(LogTest, ChecksumMismatch)",,,0,
101789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ChecksumMismatch)",,true,,,"TEST(LogTest, ChecksumMismatch)",,,0,
101796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ChecksumMismatch.IncrementByte,,true,,,IncrementByte,,,0,
101801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ChecksumMismatch.Read,,true,,,Read,,,0,
101804,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ChecksumMismatch.DroppedBytes,,true,,,DroppedBytes,,,0,
101807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(10, DroppedBytes())",,true,,,"ASSERT_EQ(10, DroppedBytes())",,,0,
101813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""OK"", MatchError(""checksum mismatch""))",,true,,,"ASSERT_EQ(""OK"", MatchError(""checksum mismatch""))",,,0,
101819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_UnexpectedMiddleType.TEST(LogTest, UnexpectedMiddleType)",,true,,,"TEST(LogTest, UnexpectedMiddleType)",,,0,
101823,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, UnexpectedMiddleType)",,true,,,"TEST(LogTest, UnexpectedMiddleType)",,,0,
101830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedMiddleType.SetByte,,true,,,SetByte,,,0,
101835,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedMiddleType.FixChecksum,,true,,,FixChecksum,,,0,
101840,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedMiddleType.Read,,true,,,Read,,,0,
101843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedMiddleType.DroppedBytes,,true,,,DroppedBytes,,,0,
101846,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""OK"", MatchError(""missing start""))",,true,,,"ASSERT_EQ(""OK"", MatchError(""missing start""))",,,0,
101852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_UnexpectedLastType.TEST(LogTest, UnexpectedLastType)",,true,,,"TEST(LogTest, UnexpectedLastType)",,,0,
101856,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, UnexpectedLastType)",,true,,,"TEST(LogTest, UnexpectedLastType)",,,0,
101863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedLastType.SetByte,,true,,,SetByte,,,0,
101868,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedLastType.FixChecksum,,true,,,FixChecksum,,,0,
101873,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedLastType.Read,,true,,,Read,,,0,
101876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedLastType.DroppedBytes,,true,,,DroppedBytes,,,0,
101879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_UnexpectedFullType.TEST(LogTest, UnexpectedFullType)",,true,,,"TEST(LogTest, UnexpectedFullType)",,,0,
101883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, UnexpectedFullType)",,true,,,"TEST(LogTest, UnexpectedFullType)",,,0,
101890,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFullType.SetByte,,true,,,SetByte,,,0,
101895,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFullType.FixChecksum,,true,,,FixChecksum,,,0,
101900,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFullType.Read,,true,,,Read,,,0,
101903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFullType.DroppedBytes,,true,,,DroppedBytes,,,0,
101906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""OK"", MatchError(""partial record without end""))",,true,,,"ASSERT_EQ(""OK"", MatchError(""partial record without end""))",,,0,
101912,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_UnexpectedFirstType.TEST(LogTest, UnexpectedFirstType)",,true,,,"TEST(LogTest, UnexpectedFirstType)",,,0,
101916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, UnexpectedFirstType)",,true,,,"TEST(LogTest, UnexpectedFirstType)",,,0,
101923,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFirstType.SetByte,,true,,,SetByte,,,0,
101928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFirstType.FixChecksum,,true,,,FixChecksum,,,0,
101933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFirstType.Read,,true,,,Read,,,0,
101936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(BigString(""bar"", 100000), Read())",,true,,,"ASSERT_EQ(BigString(""bar"", 100000), Read())",,,0,
101942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UnexpectedFirstType.DroppedBytes,,true,,,DroppedBytes,,,0,
101945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MissingLastIsIgnored.TEST(LogTest, MissingLastIsIgnored)",,true,,,"TEST(LogTest, MissingLastIsIgnored)",,,0,
101949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, MissingLastIsIgnored)",,true,,,"TEST(LogTest, MissingLastIsIgnored)",,,0,
101956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingLastIsIgnored.ShrinkSize,,true,,,ShrinkSize,,,0,
101960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingLastIsIgnored.Read,,true,,,Read,,,0,
101963,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingLastIsIgnored.ReportMessage,,true,,,ReportMessage,,,0,
101966,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MissingLastIsIgnored.DroppedBytes,,true,,,DroppedBytes,,,0,
101969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_PartialLastIsIgnored.TEST(LogTest, PartialLastIsIgnored)",,true,,,"TEST(LogTest, PartialLastIsIgnored)",,,0,
101973,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, PartialLastIsIgnored)",,true,,,"TEST(LogTest, PartialLastIsIgnored)",,,0,
101980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_PartialLastIsIgnored.ShrinkSize,,true,,,ShrinkSize,,,0,
101984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_PartialLastIsIgnored.Read,,true,,,Read,,,0,
101987,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_PartialLastIsIgnored.ReportMessage,,true,,,ReportMessage,,,0,
101990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_PartialLastIsIgnored.DroppedBytes,,true,,,DroppedBytes,,,0,
101993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SkipIntoMultiRecord.TEST(LogTest, SkipIntoMultiRecord)",,true,,,"TEST(LogTest, SkipIntoMultiRecord)",,,0,
101997,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, SkipIntoMultiRecord)",,true,,,"TEST(LogTest, SkipIntoMultiRecord)",,,0,
102004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartReadingAt,,true,,,StartReadingAt,,,0,
102008,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SkipIntoMultiRecord.Read,,true,,,Read,,,0,
102011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""correct"", Read())",,true,,,"ASSERT_EQ(""correct"", Read())",,,0,
102017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SkipIntoMultiRecord.ReportMessage,,true,,,ReportMessage,,,0,
102020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SkipIntoMultiRecord.DroppedBytes,,true,,,DroppedBytes,,,0,
102023,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ErrorJoinsRecords.TEST(LogTest, ErrorJoinsRecords)",,true,,,"TEST(LogTest, ErrorJoinsRecords)",,,0,
102027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ErrorJoinsRecords)",,true,,,"TEST(LogTest, ErrorJoinsRecords)",,,0,
102034,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ErrorJoinsRecords.SetByte,,true,,,SetByte,,,0,
102039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ErrorJoinsRecords.Read,,true,,,Read,,,0,
102042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ErrorJoinsRecords.DroppedBytes,,true,,,DroppedBytes,,,0,
102045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(dropped, 2*kBlockSize + 100)",,true,,,"ASSERT_LE(dropped, 2*kBlockSize + 100)",,,0,
102051,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(dropped, 2*kBlockSize)",,true,,,"ASSERT_GE(dropped, 2*kBlockSize)",,,0,
102057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadStart.TEST(LogTest, ReadStart)",,true,,,"TEST(LogTest, ReadStart)",,,0,
102061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadStart)",,true,,,"TEST(LogTest, ReadStart)",,,0,
102068,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckInitialOffsetRecord,,true,,,CheckInitialOffsetRecord,,,0,
102073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadSecondOneOff.TEST(LogTest, ReadSecondOneOff)",,true,,,"TEST(LogTest, ReadSecondOneOff)",,,0,
102077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadSecondOneOff)",,true,,,"TEST(LogTest, ReadSecondOneOff)",,,0,
102084,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadSecondTenThousand.TEST(LogTest, ReadSecondTenThousand)",,true,,,"TEST(LogTest, ReadSecondTenThousand)",,,0,
102088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadSecondTenThousand)",,true,,,"TEST(LogTest, ReadSecondTenThousand)",,,0,
102095,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadSecondStart.TEST(LogTest, ReadSecondStart)",,true,,,"TEST(LogTest, ReadSecondStart)",,,0,
102099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadSecondStart)",,true,,,"TEST(LogTest, ReadSecondStart)",,,0,
102106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadThirdOneOff.TEST(LogTest, ReadThirdOneOff)",,true,,,"TEST(LogTest, ReadThirdOneOff)",,,0,
102110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadThirdOneOff)",,true,,,"TEST(LogTest, ReadThirdOneOff)",,,0,
102117,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadThirdStart.TEST(LogTest, ReadThirdStart)",,true,,,"TEST(LogTest, ReadThirdStart)",,,0,
102121,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadThirdStart)",,true,,,"TEST(LogTest, ReadThirdStart)",,,0,
102128,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadFourthOneOff.TEST(LogTest, ReadFourthOneOff)",,true,,,"TEST(LogTest, ReadFourthOneOff)",,,0,
102132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadFourthOneOff)",,true,,,"TEST(LogTest, ReadFourthOneOff)",,,0,
102139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadFourthFirstBlockTrailer.TEST(LogTest, ReadFourthFirstBlockTrailer)",,true,,,"TEST(LogTest, ReadFourthFirstBlockTrailer)",,,0,
102143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadFourthFirstBlockTrailer)",,true,,,"TEST(LogTest, ReadFourthFirstBlockTrailer)",,,0,
102150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadFourthMiddleBlock.TEST(LogTest, ReadFourthMiddleBlock)",,true,,,"TEST(LogTest, ReadFourthMiddleBlock)",,,0,
102154,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadFourthMiddleBlock)",,true,,,"TEST(LogTest, ReadFourthMiddleBlock)",,,0,
102161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadFourthLastBlock.TEST(LogTest, ReadFourthLastBlock)",,true,,,"TEST(LogTest, ReadFourthLastBlock)",,,0,
102165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadFourthLastBlock)",,true,,,"TEST(LogTest, ReadFourthLastBlock)",,,0,
102172,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadFourthStart.TEST(LogTest, ReadFourthStart)",,true,,,"TEST(LogTest, ReadFourthStart)",,,0,
102176,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadFourthStart)",,true,,,"TEST(LogTest, ReadFourthStart)",,,0,
102183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadInitialOffsetIntoBlockPadding.TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",,true,,,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",,,0,
102187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",,true,,,"TEST(LogTest, ReadInitialOffsetIntoBlockPadding)",,,0,
102194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadEnd.TEST(LogTest, ReadEnd)",,true,,,"TEST(LogTest, ReadEnd)",,,0,
102198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadEnd)",,true,,,"TEST(LogTest, ReadEnd)",,,0,
102205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CheckOffsetPastEndReturnsNoRecords,,true,,,CheckOffsetPastEndReturnsNoRecords,,,0,
102209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadPastEnd.TEST(LogTest, ReadPastEnd)",,true,,,"TEST(LogTest, ReadPastEnd)",,,0,
102213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(LogTest, ReadPastEnd)",,true,,,"TEST(LogTest, ReadPastEnd)",,,0,
102220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InitTypeCrc,,true,,,InitTypeCrc,,,0,
102224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Writer.EmitPhysicalRecord,,true,,,EmitPhysicalRecord,,,0,
102230,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,crc32c.Extend,,true,,,crc32c.Extend,,,0,
102237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetVarint32Ptr,,true,,,GetVarint32Ptr,,,0,
102243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MemoryUsage,,true,,,MemoryUsage,,,0,
102247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLengthPrefixedSlice,,true,,,GetLengthPrefixedSlice,,,0,
102252,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PutVarint32,,true,,,PutVarint32,,,0,
102257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeKey,,true,,,EncodeKey,,,0,
102261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VarintLength,,true,,,VarintLength,,,0,
102265,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Allocate,,true,,,Allocate,,,0,
102270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Insert,,true,,,Insert,,,0,
102275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memtable_key,,true,,,memtable_key,,,0,
102279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,iter,,true,,,iter,,,0,
102283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecoveryTest.Open,,true,,,Open,,,0,
102286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecoveryTest.Close,,true,,,Close,,,0,
102289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.IsNotSupportedError,,true,,,IsNotSupportedError,,,0,
102293,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(DB.Open(opts, dbname_, &db_))",,true,,,"ASSERT_OK(DB.Open(opts, dbname_, &db_))",,,0,
102300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecoveryTest.NumLogs,,true,,,NumLogs,,,0,
102303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, NumLogs())",,true,,,"ASSERT_EQ(1, NumLogs())",,,0,
102309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(ReadFileToString(env_, CurrentFileName(dbname_), &current))",,true,,,"ASSERT_OK(ReadFileToString(env_, CurrentFileName(dbname_), &current))",,,0,
102315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecoveryTest.GetFiles,,true,,,GetFiles,,,0,
102319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(env_->DeleteFile(LogName(logs[i]))),,true,,,ASSERT_OK(env_->DeleteFile(LogName(logs[i]))),,,0,
102324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LogName,,true,,,LogName,,,0,
102328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->GetFileSize(fname, &result))",,true,,,"ASSERT_OK(env_->GetFileSize(fname, &result))",,,0,
102334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RecoveryTest.dbfull,,true,,,dbfull,,,0,
102337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewWritableFile(fname, &file))",,true,,,"ASSERT_OK(env_->NewWritableFile(fname, &file))",,,0,
102343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,writer,,true,,,writer,,,0,
102347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Writer.ASSERT_OK(writer.AddRecord(WriteBatchInternal.Contents(&batch))),,true,,,ASSERT_OK(writer.AddRecord(WriteBatchInternal.Contents(&batch))),,,0,
102352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.WriteBatchInternal.Contents.ASSERT_OK(writer.AddRecord(WriteBatchInternal.Contents(&batch))),,true,,,ASSERT_OK(writer.AddRecord(WriteBatchInternal.Contents(&batch))),,,0,
102357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(writer.AddRecord(WriteBatchInternal.Contents(&batch))),,true,,,ASSERT_OK(writer.AddRecord(WriteBatchInternal.Contents(&batch))),,,0,
102363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(file->Flush()),,true,,,ASSERT_OK(file->Flush()),,,0,
102367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ManifestReused.TEST(RecoveryTest, ManifestReused)",,true,,,"TEST(RecoveryTest, ManifestReused)",,,0,
102371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(RecoveryTest, ManifestReused)",,true,,,"TEST(RecoveryTest, ManifestReused)",,,0,
102378,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestReused.CanAppend,,true,,,CanAppend,,,0,
102381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestReused.Close,,true,,,Close,,,0,
102384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestReused.ManifestFileName,,true,,,ManifestFileName,,,0,
102387,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_ManifestReused.Open,,true,,,Open,,,0,
102390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(old_manifest, ManifestFileName())",,true,,,"ASSERT_EQ(old_manifest, ManifestFileName())",,,0,
102396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_LargeManifestCompacted.TEST(RecoveryTest, LargeManifestCompacted)",,true,,,"TEST(RecoveryTest, LargeManifestCompacted)",,,0,
102400,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(RecoveryTest, LargeManifestCompacted)",,true,,,"TEST(RecoveryTest, LargeManifestCompacted)",,,0,
102407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LargeManifestCompacted.CanAppend,,true,,,CanAppend,,,0,
102410,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LargeManifestCompacted.Close,,true,,,Close,,,0,
102413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LargeManifestCompacted.ManifestFileName,,true,,,ManifestFileName,,,0,
102416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LargeManifestCompacted.FileSize,,true,,,FileSize,,,0,
102420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env()->NewAppendableFile(old_manifest, &file))",,true,,,"ASSERT_OK(env()->NewAppendableFile(old_manifest, &file))",,,0,
102426,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LargeManifestCompacted.env,,true,,,env,,,0,
102429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,zeroes,,true,,,zeroes,,,0,
102434,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(file->Append(zeroes)),,true,,,ASSERT_OK(file->Append(zeroes)),,,0,
102439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LargeManifestCompacted.Open,,true,,,Open,,,0,
102442,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\testharness.hpp,util\testharness.hpp:108:108:ASSERT_NE:2,,true,108,108,ASSERT_NE,,,0,
102447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_NE(old_manifest, new_manifest)",,true,,,"ASSERT_NE(old_manifest, new_manifest)",,,0,
102453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(10000, FileSize(new_manifest))",,true,,,"ASSERT_GT(10000, FileSize(new_manifest))",,,0,
102459,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(new_manifest, ManifestFileName())",,true,,,"ASSERT_EQ(new_manifest, ManifestFileName())",,,0,
102465,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_NoLogFiles.TEST(RecoveryTest, NoLogFiles)",,true,,,"TEST(RecoveryTest, NoLogFiles)",,,0,
102469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(RecoveryTest, NoLogFiles)",,true,,,"TEST(RecoveryTest, NoLogFiles)",,,0,
102476,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoLogFiles.DeleteLogFiles,,true,,,DeleteLogFiles,,,0,
102479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, DeleteLogFiles())",,true,,,"ASSERT_EQ(1, DeleteLogFiles())",,,0,
102485,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_NoLogFiles.Open,,true,,,Open,,,0,
102488,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_LogFileReuse.TEST(RecoveryTest, LogFileReuse)",,true,,,"TEST(RecoveryTest, LogFileReuse)",,,0,
102492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(RecoveryTest, LogFileReuse)",,true,,,"TEST(RecoveryTest, LogFileReuse)",,,0,
102499,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.CanAppend,,true,,,CanAppend,,,0,
102502,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.CompactMemTable,,true,,,CompactMemTable,,,0,
102505,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.Close,,true,,,Close,,,0,
102508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.NumLogs,,true,,,NumLogs,,,0,
102511,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.FirstLogFile,,true,,,FirstLogFile,,,0,
102514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.FileSize,,true,,,FileSize,,,0,
102518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.LogName,,true,,,LogName,,,0,
102522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, FileSize(LogName(number)))",,true,,,"ASSERT_EQ(0, FileSize(LogName(number)))",,,0,
102528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(0, FileSize(LogName(number)))",,true,,,"ASSERT_LT(0, FileSize(LogName(number)))",,,0,
102534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_LogFileReuse.Open,,true,,,Open,,,0,
102537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(number, FirstLogFile())",,true,,,"ASSERT_EQ(number, FirstLogFile())",,,0,
102543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MultipleMemTables.TEST(RecoveryTest, MultipleMemTables)",,true,,,"TEST(RecoveryTest, MultipleMemTables)",,,0,
102547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(RecoveryTest, MultipleMemTables)",,true,,,"TEST(RecoveryTest, MultipleMemTables)",,,0,
102554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleMemTables.NumTables,,true,,,NumTables,,,0,
102557,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, NumTables())",,true,,,"ASSERT_EQ(0, NumTables())",,,0,
102563,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleMemTables.Close,,true,,,Close,,,0,
102566,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleMemTables.NumLogs,,true,,,NumLogs,,,0,
102569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleMemTables.FirstLogFile,,true,,,FirstLogFile,,,0,
102572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleMemTables.Open,,true,,,Open,,,0,
102576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(2, NumTables())",,true,,,"ASSERT_LE(2, NumTables())",,,0,
102582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_NE(old_log_file, FirstLogFile())",,true,,,"ASSERT_NE(old_log_file, FirstLogFile())",,,0,
102588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(buf, Get(buf))",,true,,,"ASSERT_EQ(buf, Get(buf))",,,0,
102594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MultipleLogFiles.TEST(RecoveryTest, MultipleLogFiles)",,true,,,"TEST(RecoveryTest, MultipleLogFiles)",,,0,
102598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(RecoveryTest, MultipleLogFiles)",,true,,,"TEST(RecoveryTest, MultipleLogFiles)",,,0,
102605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleLogFiles.Close,,true,,,Close,,,0,
102608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleLogFiles.NumLogs,,true,,,NumLogs,,,0,
102611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleLogFiles.FirstLogFile,,true,,,FirstLogFile,,,0,
102614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MakeLogFile,,true,,,MakeLogFile,,,0,
102621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleLogFiles.Open,,true,,,Open,,,0,
102624,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleLogFiles.NumTables,,true,,,NumTables,,,0,
102627,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(1, NumTables())",,true,,,"ASSERT_LE(1, NumTables())",,,0,
102633,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(old_log+3, new_log)",,true,,,"ASSERT_LE(old_log+3, new_log)",,,0,
102639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""bar2"", Get(""foo""))",,true,,,"ASSERT_EQ(""bar2"", Get(""foo""))",,,0,
102645,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""world"", Get(""hello""))",,true,,,"ASSERT_EQ(""world"", Get(""hello""))",,,0,
102651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""there"", Get(""hi""))",,true,,,"ASSERT_EQ(""there"", Get(""hi""))",,,0,
102657,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleLogFiles.CanAppend,,true,,,CanAppend,,,0,
102660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(new_log, FirstLogFile())",,true,,,"ASSERT_EQ(new_log, FirstLogFile())",,,0,
102666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.FindFiles,,true,,,FindFiles,,,0,
102669,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.ConvertLogFilesToTables,,true,,,ConvertLogFilesToTables,,,0,
102672,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.ExtractMetaData,,true,,,ExtractMetaData,,,0,
102675,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.WriteDescriptor,,true,,,WriteDescriptor,,,0,
102678,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.ConvertLogToTable,,true,,,ConvertLogToTable,,,0,
102682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.ArchiveFile,,true,,,ArchiveFile,,,0,
102686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.ScanTable,,true,,,ScanTable,,,0,
102690,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.NewTableIterator,,true,,,NewTableIterator,,,0,
102694,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.RepairTable,,true,,,RepairTable,,,0,
102699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetComparatorName,,true,,,SetComparatorName,,,0,
102704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetLogNumber,,true,,,SetLogNumber,,,0,
102709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetNextFile,,true,,,SetNextFile,,,0,
102714,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeTo,,true,,,EncodeTo,,,0,
102719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,strrchr,,true,,,strrchr,,,0,
102724,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,repairer,,true,,,repairer,,,0,
102729,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Repairer.Run,,true,,,Run,,,0,
102733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,compare_,,true,,,compare_,,,0,
102738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NoBarrier_Store,,true,,,NoBarrier_Store,,,0,
102743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AllocateAligned,,true,,,AllocateAligned,,,0,
102748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iterator.Valid,,true,,,Valid,,,0,
102751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindLessThan,,true,,,FindLessThan,,,0,
102756,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindGreaterOrEqual,,true,,,FindGreaterOrEqual,,,0,
102761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindLast,,true,,,FindLast,,,0,
102765,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetMaxHeight,,true,,,GetMaxHeight,,,0,
102768,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,KeyIsAfterNode,,true,,,KeyIsAfterNode,,,0,
102773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.postDecrement,,true,,,<operator>.postDecrement,,,0,
102777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetNext,,true,,,SetNext,,,0,
102783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Equal,,true,,,Equal,,,0,
102788,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RandomHeight,,true,,,RandomHeight,,,0,
102791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewNode,,true,,,NewNode,,,0,
102796,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NoBarrier_SetNext,,true,,,NoBarrier_SetNext,,,0,
102802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,1 127 3 prev 0 3 i 0.NoBarrier_Next,,true,,,NoBarrier_Next,,,0,
102807,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,1 127 3 prev 0 3 i 0.SetNext,,true,,,SetNext,,,0,
102813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(SkipTest, Empty)",,true,,,"TEST(SkipTest, Empty)",,,0,
102817,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, Empty)",,true,,,"TEST(SkipTest, Empty)",,,0,
102824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,list,,true,,,list,,,0,
102829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!list.Contains(10)),,true,,,ASSERT_TRUE(!list.Contains(10)),,,0,
102834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!iter.Valid()),,true,,,ASSERT_TRUE(!iter.Valid()),,,0,
102838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_InsertAndLookup.TEST(SkipTest, InsertAndLookup)",,true,,,"TEST(SkipTest, InsertAndLookup)",,,0,
102842,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, InsertAndLookup)",,true,,,"TEST(SkipTest, InsertAndLookup)",,,0,
102849,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Random.Next,,true,,,Next,,,0,
102852,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Contains,,true,,,Contains,,,0,
102857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(keys.count(i), 1)",,true,,,"ASSERT_EQ(keys.count(i), 1)",,,0,
102862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(keys.count(i), 0)",,true,,,"ASSERT_EQ(keys.count(i), 0)",,,0,
102867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(iter.Valid()),,true,,,ASSERT_TRUE(iter.Valid()),,,0,
102871,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(*(keys.begin()), iter.key())",,true,,,"ASSERT_EQ(*(keys.begin()), iter.key())",,,0,
102875,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(*(keys.rbegin()), iter.key())",,true,,,"ASSERT_EQ(*(keys.rbegin()), iter.key())",,,0,
102879,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(*model_iter, iter.key())",,true,,,"ASSERT_EQ(*model_iter, iter.key())",,,0,
102883,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rend,,true,,,rend,,,0,
102887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Hash,,true,,,Hash,,,0,
102893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Set,,true,,,Set,,,0,
102898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,State.Set,,true,,,Set,,,0,
102904,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(IsValidKey(current)),,true,,,ASSERT_TRUE(IsValidKey(current)),,,0,
102910,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(pos, current)",,true,,,"ASSERT_LE(pos, current)",,,0,
102916,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LT(key(pos), K)",,true,,,"ASSERT_LT(key(pos), K)",,,0,
102922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    )",,true,,,"ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    )",,,0,
102928,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"State.ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    )",,true,,,"ASSERT_TRUE((gen(pos) == 0) ||
                    (gen(pos) > static_cast<Key>(initial_state.Get(key(pos))))
                    )",,,0,
102933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,State.Get,,true,,,Get,,,0,
102938,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ConcurrentWithoutThreads.TEST(SkipTest, ConcurrentWithoutThreads)",,true,,,"TEST(SkipTest, ConcurrentWithoutThreads)",,,0,
102942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, ConcurrentWithoutThreads)",,true,,,"TEST(SkipTest, ConcurrentWithoutThreads)",,,0,
102949,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConcurrentTest.ReadStep,,true,,,ReadStep,,,0,
102954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ConcurrentTest.WriteStep,,true,,,WriteStep,,,0,
102959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Change,,true,,,Change,,,0,
102964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadStep,,true,,,ReadStep,,,0,
102969,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestState.Wait,,true,,,Wait,,,0,
102974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,WriteStep,,true,,,WriteStep,,,0,
102979,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Concurrent1.TEST(SkipTest, Concurrent1)",,true,,,"TEST(SkipTest, Concurrent1)",,,0,
102983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, Concurrent1)",,true,,,"TEST(SkipTest, Concurrent1)",,,0,
102990,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,RunConcurrent,,true,,,RunConcurrent,,,0,
102994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Concurrent2.TEST(SkipTest, Concurrent2)",,true,,,"TEST(SkipTest, Concurrent2)",,,0,
102998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, Concurrent2)",,true,,,"TEST(SkipTest, Concurrent2)",,,0,
103005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Concurrent3.TEST(SkipTest, Concurrent3)",,true,,,"TEST(SkipTest, Concurrent3)",,,0,
103009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, Concurrent3)",,true,,,"TEST(SkipTest, Concurrent3)",,,0,
103016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Concurrent4.TEST(SkipTest, Concurrent4)",,true,,,"TEST(SkipTest, Concurrent4)",,,0,
103020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, Concurrent4)",,true,,,"TEST(SkipTest, Concurrent4)",,,0,
103027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Concurrent5.TEST(SkipTest, Concurrent5)",,true,,,"TEST(SkipTest, Concurrent5)",,,0,
103031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(SkipTest, Concurrent5)",,true,,,"TEST(SkipTest, Concurrent5)",,,0,
103038,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Release,,true,,,Release,,,0,
103042,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Lookup,,true,,,Lookup,,,0,
103047,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableCache.FindTable,,true,,,FindTable,,,0,
103053,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewErrorIterator,,true,,,NewErrorIterator,,,0,
103057,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalGet,,true,,,InternalGet,,,0,
103065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Erase,,true,,,Erase,,,0,
103070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PutLengthPrefixedSlice,,true,,,PutLengthPrefixedSlice,,,0,
103075,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PutVarint64,,true,,,PutVarint64,,,0,
103080,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetVarint32,,true,,,GetVarint32,,,0,
103085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.Clear,,true,,,Clear,,,0,
103088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetVarint64,,true,,,GetVarint64,,,0,
103093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetLevel,,true,,,GetLevel,,,0,
103098,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetInternalKey,,true,,,GetInternalKey,,,0,
103103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.make_pair,,true,,,std.make_pair,,,0,
103109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(encoded, encoded2)",,true,,,"ASSERT_EQ(encoded, encoded2)",,,0,
103115,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_EncodeDecode.TEST(VersionEditTest, EncodeDecode)",,true,,,"TEST(VersionEditTest, EncodeDecode)",,,0,
103119,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(VersionEditTest, EncodeDecode)",,true,,,"TEST(VersionEditTest, EncodeDecode)",,,0,
103126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestEncodeDecode,,true,,,TestEncodeDecode,,,0,
103130,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionEdit.SetCompactPointer,,true,,,SetCompactPointer,,,0,
103136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TargetFileSize,,true,,,TargetFileSize,,,0,
103140,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.assignmentMultiplication,,true,,,<operator>.assignmentMultiplication,,,0,
103145,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalKeyComparator.Compare,,true,,,InternalKeyComparator.Compare,,,0,
103151,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AfterFile,,true,,,AfterFile,,,0,
103157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BeforeFile,,true,,,BeforeFile,,,0,
103163,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,small,,true,,,small,,,0,
103169,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FindFile,,true,,,FindFile,,,0,
103175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LevelFileNumIterator.Valid,,true,,,Valid,,,0,
103178,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewTwoLevelIterator,,true,,,NewTwoLevelIterator,,,0,
103185,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Version.NewConcatenatingIterator,,true,,,NewConcatenatingIterator,,,0,
103190,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,reserve,,true,,,reserve,,,0,
103195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,internal_key,,true,,,internal_key,,,0,
103199,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Version.ForEachOverlapping,,true,,,ForEachOverlapping,,,0,
103206,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Version.UpdateStats,,true,,,UpdateStats,,,0,
103210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SomeFileOverlapsRange,,true,,,SomeFileOverlapsRange,,,0,
103218,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Version.OverlapInLevel,,true,,,OverlapInLevel,,,0,
103224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Version.GetOverlappingInputs,,true,,,GetOverlappingInputs,,,0,
103231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TotalFileSize,,true,,,TotalFileSize,,,0,
103235,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaxGrandParentOverlapBytes,,true,,,MaxGrandParentOverlapBytes,,,0,
103239,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.upper_bound,,true,,,std.upper_bound,,,0,
103247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaybeAddFile,,true,,,MaybeAddFile,,,0,
103253,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.AppendVersion,,true,,,AppendVersion,,,0,
103257,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetPrevLogNumber,,true,,,SetPrevLogNumber,,,0,
103262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,builder,,true,,,builder,,,0,
103267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Builder.Apply,,true,,,Apply,,,0,
103272,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Builder.SaveTo,,true,,,SaveTo,,,0,
103277,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.Finalize,,true,,,Finalize,,,0,
103281,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.WriteSnapshot,,true,,,WriteSnapshot,,,0,
103285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.MarkFileNumberUsed,,true,,,MarkFileNumberUsed,,,0,
103289,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.ReuseManifest,,true,,,ReuseManifest,,,0,
103294,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaxBytesForLevel,,true,,,MaxBytesForLevel,,,0,
103299,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InternalKey.DecodeFrom,,true,,,DecodeFrom,,,0,
103304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetOverlappingInputs,,true,,,GetOverlappingInputs,,,0,
103312,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.GetRange,,true,,,GetRange,,,0,
103318,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.SetupOtherInputs,,true,,,SetupOtherInputs,,,0,
103322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,VersionSet.GetRange2,,true,,,GetRange2,,,0,
103329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ExpandedCompactionByteSizeLimit,,true,,,ExpandedCompactionByteSizeLimit,,,0,
103333,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,long,,true,,,long,,,0,
103337,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCompactPointer,,true,,,SetCompactPointer,,,0,
103343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MaxFileSizeForLevel,,true,,,MaxFileSizeForLevel,,,0,
103348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,s,,true,,,s,,,0,
103352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(FindFileTest, Empty)",,true,,,"TEST(FindFileTest, Empty)",,,0,
103356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FindFileTest, Empty)",,true,,,"TEST(FindFileTest, Empty)",,,0,
103363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Empty.Find,,true,,,Find,,,0,
103367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""foo""))",,true,,,"ASSERT_EQ(0, Find(""foo""))",,,0,
103373,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""a"", ""z""))",,true,,,"ASSERT_TRUE(! Overlaps(""a"", ""z""))",,,0,
103379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Empty.Overlaps,,true,,,Overlaps,,,0,
103384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(NULL, ""z""))",,true,,,"ASSERT_TRUE(! Overlaps(NULL, ""z""))",,,0,
103390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Overlaps,,true,,,Overlaps,,,0,
103395,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""a"", NULL))",,true,,,"ASSERT_TRUE(! Overlaps(""a"", NULL))",,,0,
103401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(NULL, NULL))",,true,,,"ASSERT_TRUE(! Overlaps(NULL, NULL))",,,0,
103407,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Single.TEST(FindFileTest, Single)",,true,,,"TEST(FindFileTest, Single)",,,0,
103411,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FindFileTest, Single)",,true,,,"TEST(FindFileTest, Single)",,,0,
103418,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Single.Add,,true,,,Add,,,0,
103423,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Single.Find,,true,,,Find,,,0,
103427,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""a""))",,true,,,"ASSERT_EQ(0, Find(""a""))",,,0,
103433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""p""))",,true,,,"ASSERT_EQ(0, Find(""p""))",,,0,
103439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""p1""))",,true,,,"ASSERT_EQ(0, Find(""p1""))",,,0,
103445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""q""))",,true,,,"ASSERT_EQ(0, Find(""q""))",,,0,
103451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, Find(""q1""))",,true,,,"ASSERT_EQ(1, Find(""q1""))",,,0,
103457,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, Find(""z""))",,true,,,"ASSERT_EQ(1, Find(""z""))",,,0,
103463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""a"", ""b""))",,true,,,"ASSERT_TRUE(! Overlaps(""a"", ""b""))",,,0,
103469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Single.Overlaps,,true,,,Overlaps,,,0,
103474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""z1"", ""z2""))",,true,,,"ASSERT_TRUE(! Overlaps(""z1"", ""z2""))",,,0,
103480,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""a"", ""p""))",,true,,,"ASSERT_TRUE(Overlaps(""a"", ""p""))",,,0,
103486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""a"", ""q""))",,true,,,"ASSERT_TRUE(Overlaps(""a"", ""q""))",,,0,
103492,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""a"", ""z""))",,true,,,"ASSERT_TRUE(Overlaps(""a"", ""z""))",,,0,
103498,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""p"", ""p1""))",,true,,,"ASSERT_TRUE(Overlaps(""p"", ""p1""))",,,0,
103504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""p"", ""q""))",,true,,,"ASSERT_TRUE(Overlaps(""p"", ""q""))",,,0,
103510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""p"", ""z""))",,true,,,"ASSERT_TRUE(Overlaps(""p"", ""z""))",,,0,
103516,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""p1"", ""p2""))",,true,,,"ASSERT_TRUE(Overlaps(""p1"", ""p2""))",,,0,
103522,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""p1"", ""z""))",,true,,,"ASSERT_TRUE(Overlaps(""p1"", ""z""))",,,0,
103528,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""q"", ""q""))",,true,,,"ASSERT_TRUE(Overlaps(""q"", ""q""))",,,0,
103534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""q"", ""q1""))",,true,,,"ASSERT_TRUE(Overlaps(""q"", ""q1""))",,,0,
103540,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(NULL, ""j""))",,true,,,"ASSERT_TRUE(! Overlaps(NULL, ""j""))",,,0,
103546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""r"", NULL))",,true,,,"ASSERT_TRUE(! Overlaps(""r"", NULL))",,,0,
103552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""p""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""p""))",,,0,
103558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""p1""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""p1""))",,,0,
103564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""q"", NULL))",,true,,,"ASSERT_TRUE(Overlaps(""q"", NULL))",,,0,
103570,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, NULL))",,true,,,"ASSERT_TRUE(Overlaps(NULL, NULL))",,,0,
103576,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Multiple.TEST(FindFileTest, Multiple)",,true,,,"TEST(FindFileTest, Multiple)",,,0,
103580,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FindFileTest, Multiple)",,true,,,"TEST(FindFileTest, Multiple)",,,0,
103587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Multiple.Add,,true,,,Add,,,0,
103592,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Multiple.Find,,true,,,Find,,,0,
103596,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""100""))",,true,,,"ASSERT_EQ(0, Find(""100""))",,,0,
103602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""150""))",,true,,,"ASSERT_EQ(0, Find(""150""))",,,0,
103608,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""151""))",,true,,,"ASSERT_EQ(0, Find(""151""))",,,0,
103614,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""199""))",,true,,,"ASSERT_EQ(0, Find(""199""))",,,0,
103620,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, Find(""200""))",,true,,,"ASSERT_EQ(0, Find(""200""))",,,0,
103626,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, Find(""201""))",,true,,,"ASSERT_EQ(1, Find(""201""))",,,0,
103632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, Find(""249""))",,true,,,"ASSERT_EQ(1, Find(""249""))",,,0,
103638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, Find(""250""))",,true,,,"ASSERT_EQ(1, Find(""250""))",,,0,
103644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2, Find(""251""))",,true,,,"ASSERT_EQ(2, Find(""251""))",,,0,
103650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2, Find(""299""))",,true,,,"ASSERT_EQ(2, Find(""299""))",,,0,
103656,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2, Find(""300""))",,true,,,"ASSERT_EQ(2, Find(""300""))",,,0,
103662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2, Find(""349""))",,true,,,"ASSERT_EQ(2, Find(""349""))",,,0,
103668,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2, Find(""350""))",,true,,,"ASSERT_EQ(2, Find(""350""))",,,0,
103674,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, Find(""351""))",,true,,,"ASSERT_EQ(3, Find(""351""))",,,0,
103680,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, Find(""400""))",,true,,,"ASSERT_EQ(3, Find(""400""))",,,0,
103686,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, Find(""450""))",,true,,,"ASSERT_EQ(3, Find(""450""))",,,0,
103692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(4, Find(""451""))",,true,,,"ASSERT_EQ(4, Find(""451""))",,,0,
103698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""100"", ""149""))",,true,,,"ASSERT_TRUE(! Overlaps(""100"", ""149""))",,,0,
103704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Multiple.Overlaps,,true,,,Overlaps,,,0,
103709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""251"", ""299""))",,true,,,"ASSERT_TRUE(! Overlaps(""251"", ""299""))",,,0,
103715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""451"", ""500""))",,true,,,"ASSERT_TRUE(! Overlaps(""451"", ""500""))",,,0,
103721,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""351"", ""399""))",,true,,,"ASSERT_TRUE(! Overlaps(""351"", ""399""))",,,0,
103727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""100"", ""150""))",,true,,,"ASSERT_TRUE(Overlaps(""100"", ""150""))",,,0,
103733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""100"", ""200""))",,true,,,"ASSERT_TRUE(Overlaps(""100"", ""200""))",,,0,
103739,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""100"", ""300""))",,true,,,"ASSERT_TRUE(Overlaps(""100"", ""300""))",,,0,
103745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""100"", ""400""))",,true,,,"ASSERT_TRUE(Overlaps(""100"", ""400""))",,,0,
103751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""100"", ""500""))",,true,,,"ASSERT_TRUE(Overlaps(""100"", ""500""))",,,0,
103757,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""375"", ""400""))",,true,,,"ASSERT_TRUE(Overlaps(""375"", ""400""))",,,0,
103763,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""450"", ""450""))",,true,,,"ASSERT_TRUE(Overlaps(""450"", ""450""))",,,0,
103769,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""450"", ""500""))",,true,,,"ASSERT_TRUE(Overlaps(""450"", ""500""))",,,0,
103775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MultipleNullBoundaries.TEST(FindFileTest, MultipleNullBoundaries)",,true,,,"TEST(FindFileTest, MultipleNullBoundaries)",,,0,
103779,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FindFileTest, MultipleNullBoundaries)",,true,,,"TEST(FindFileTest, MultipleNullBoundaries)",,,0,
103786,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_MultipleNullBoundaries.Add,,true,,,Add,,,0,
103791,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(NULL, ""149""))",,true,,,"ASSERT_TRUE(! Overlaps(NULL, ""149""))",,,0,
103797,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""451"", NULL))",,true,,,"ASSERT_TRUE(! Overlaps(""451"", NULL))",,,0,
103803,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""150""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""150""))",,,0,
103809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""199""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""199""))",,,0,
103815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""200""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""200""))",,,0,
103821,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""201""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""201""))",,,0,
103827,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""400""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""400""))",,,0,
103833,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(NULL, ""800""))",,true,,,"ASSERT_TRUE(Overlaps(NULL, ""800""))",,,0,
103839,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""100"", NULL))",,true,,,"ASSERT_TRUE(Overlaps(""100"", NULL))",,,0,
103845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""200"", NULL))",,true,,,"ASSERT_TRUE(Overlaps(""200"", NULL))",,,0,
103851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""449"", NULL))",,true,,,"ASSERT_TRUE(Overlaps(""449"", NULL))",,,0,
103857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""450"", NULL))",,true,,,"ASSERT_TRUE(Overlaps(""450"", NULL))",,,0,
103863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_OverlapSequenceChecks.TEST(FindFileTest, OverlapSequenceChecks)",,true,,,"TEST(FindFileTest, OverlapSequenceChecks)",,,0,
103867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FindFileTest, OverlapSequenceChecks)",,true,,,"TEST(FindFileTest, OverlapSequenceChecks)",,,0,
103874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""199"", ""199""))",,true,,,"ASSERT_TRUE(! Overlaps(""199"", ""199""))",,,0,
103880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OverlapSequenceChecks.Overlaps,,true,,,Overlaps,,,0,
103885,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""201"", ""300""))",,true,,,"ASSERT_TRUE(! Overlaps(""201"", ""300""))",,,0,
103891,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""200"", ""200""))",,true,,,"ASSERT_TRUE(Overlaps(""200"", ""200""))",,,0,
103897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""190"", ""200""))",,true,,,"ASSERT_TRUE(Overlaps(""190"", ""200""))",,,0,
103903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""200"", ""210""))",,true,,,"ASSERT_TRUE(Overlaps(""200"", ""210""))",,,0,
103909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_OverlappingFiles.TEST(FindFileTest, OverlappingFiles)",,true,,,"TEST(FindFileTest, OverlappingFiles)",,,0,
103913,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FindFileTest, OverlappingFiles)",,true,,,"TEST(FindFileTest, OverlappingFiles)",,,0,
103920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OverlappingFiles.Add,,true,,,Add,,,0,
103925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_OverlappingFiles.Overlaps,,true,,,Overlaps,,,0,
103930,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Overlaps(""601"", ""700""))",,true,,,"ASSERT_TRUE(! Overlaps(""601"", ""700""))",,,0,
103936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""450"", ""700""))",,true,,,"ASSERT_TRUE(Overlaps(""450"", ""700""))",,,0,
103942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Overlaps(""600"", ""700""))",,true,,,"ASSERT_TRUE(Overlaps(""600"", ""700""))",,,0,
103948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SequenceNumber,,true,,,SequenceNumber,,,0,
103952,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey))",,true,,,"ASSERT_TRUE(ParseInternalKey(iter->key(), &ikey))",,,0,
103956,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(WriteBatchTest, Empty)",,true,,,"TEST(WriteBatchTest, Empty)",,,0,
103960,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(WriteBatchTest, Empty)",,true,,,"TEST(WriteBatchTest, Empty)",,,0,
103967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PrintContents,,true,,,PrintContents,,,0,
103971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ("""", PrintContents(&batch))",,true,,,"ASSERT_EQ("""", PrintContents(&batch))",,,0,
103977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, WriteBatchInternal.Count(&batch))",,true,,,"ASSERT_EQ(0, WriteBatchInternal.Count(&batch))",,,0,
103982,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Multiple.TEST(WriteBatchTest, Multiple)",,true,,,"TEST(WriteBatchTest, Multiple)",,,0,
103986,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(WriteBatchTest, Multiple)",,true,,,"TEST(WriteBatchTest, Multiple)",,,0,
103993,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(100, WriteBatchInternal.Sequence(&batch))",,true,,,"ASSERT_EQ(100, WriteBatchInternal.Sequence(&batch))",,,0,
103998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, WriteBatchInternal.Count(&batch))",,true,,,"ASSERT_EQ(3, WriteBatchInternal.Count(&batch))",,,0,
104003,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""Put(baz, boo)@102""
            ""Delete(box)@101""
            ""Put(foo, bar)@100"",
            PrintContents(&batch))",,true,,,"ASSERT_EQ(""Put(baz, boo)@102""
            ""Delete(box)@101""
            ""Put(foo, bar)@100"",
            PrintContents(&batch))",,,0,
104009,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Corruption.TEST(WriteBatchTest, Corruption)",,true,,,"TEST(WriteBatchTest, Corruption)",,,0,
104013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(WriteBatchTest, Corruption)",,true,,,"TEST(WriteBatchTest, Corruption)",,,0,
104020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""Put(foo, bar)@200""
            ""ParseError()"",
            PrintContents(&batch))",,true,,,"ASSERT_EQ(""Put(foo, bar)@200""
            ""ParseError()"",
            PrintContents(&batch))",,,0,
104026,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Append.TEST(WriteBatchTest, Append)",,true,,,"TEST(WriteBatchTest, Append)",,,0,
104030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(WriteBatchTest, Append)",,true,,,"TEST(WriteBatchTest, Append)",,,0,
104037,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ("""",
            PrintContents(&b1))",,true,,,"ASSERT_EQ("""",
            PrintContents(&b1))",,,0,
104043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""Put(a, va)@200"",
            PrintContents(&b1))",,true,,,"ASSERT_EQ(""Put(a, va)@200"",
            PrintContents(&b1))",,,0,
104049,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@201"",
            PrintContents(&b1))",,true,,,"ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@201"",
            PrintContents(&b1))",,,0,
104055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@202""
            ""Put(b, vb)@201""
            ""Delete(foo)@203"",
            PrintContents(&b1))",,true,,,"ASSERT_EQ(""Put(a, va)@200""
            ""Put(b, vb)@202""
            ""Put(b, vb)@201""
            ""Delete(foo)@203"",
            PrintContents(&b1))",,,0,
104061,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_free,,true,,,sqlite3_free,,,0,
104065,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_wal_checkpoint_v2,,true,,,sqlite3_wal_checkpoint_v2,,,0,
104073,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,isspace,,true,,,isspace,,,0,
104077,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,file_name,,true,,,file_name,,,0,
104081,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_close,,true,,,sqlite3_close,,,0,
104085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.Start,,true,,,Start,,,0,
104088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.Write,,true,,,Write,,,0,
104097,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.ReadSequential,,true,,,ReadSequential,,,0,
104100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.Read,,true,,,Read,,,0,
104105,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.Stop,,true,,,Stop,,,0,
104109,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_open,,true,,,sqlite3_open,,,0,
104114,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_errmsg,,true,,,sqlite3_errmsg,,,0,
104118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_exec,,true,,,sqlite3_exec,,,0,
104126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_prepare_v2,,true,,,sqlite3_prepare_v2,,,0,
104134,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_step,,true,,,sqlite3_step,,,0,
104138,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_reset,,true,,,sqlite3_reset,,,0,
104142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Generate,,true,,,Generate,,,0,
104147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_bind_blob,,true,,,sqlite3_bind_blob,,,0,
104155,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_clear_bindings,,true,,,sqlite3_clear_bindings,,,0,
104159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Benchmark.FinishedSingleOp,,true,,,FinishedSingleOp,,,0,
104162,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_finalize,,true,,,sqlite3_finalize,,,0,
104166,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqlite3_column_bytes,,true,,,sqlite3_column_bytes,,,0,
104171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,synchronize,,true,,,synchronize,,,0,
104175,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,name,,true,,,name,,,0,
104179,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,error,,true,,,error,,,0,
104183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,close,,true,,,close,,,0,
104187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentOr,,true,,,<operators>.assignmentOr,,,0,
104192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tune_compressor,,true,,,tune_compressor,,,0,
104197,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tune_options,,true,,,tune_options,,,0,
104202,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tune_page_cache,,true,,,tune_page_cache,,,0,
104207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tune_page,,true,,,tune_page,,,0,
104212,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,tune_map,,true,,,tune_map,,,0,
104217,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,open,,true,,,open,,,0,
104223,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set,,true,,,set,,,0,
104229,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cursor,,true,,,cursor,,,0,
104233,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,jump,,true,,,jump,,,0,
104237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,get,,true,,,get,,,0,
104243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,lock,,true,,,lock,,,0,
104247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,back,,true,,,back,,,0,
104251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Size,,true,,,Size,,,0,
104255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,InMemoryEnv.DeleteFileInternal,,true,,,DeleteFileInternal,,,0,
104259,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Basics.TEST(MemEnvTest, Basics)",,true,,,"TEST(MemEnvTest, Basics)",,,0,
104263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemEnvTest, Basics)",,true,,,"TEST(MemEnvTest, Basics)",,,0,
104270,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->CreateDir(""/dir""))",,true,,,"ASSERT_OK(env_->CreateDir(""/dir""))",,,0,
104275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->FileExists(""/dir/non_existent""))",,true,,,"ASSERT_TRUE(!env_->FileExists(""/dir/non_existent""))",,,0,
104280,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->GetFileSize(""/dir/non_existent"", &file_size).ok())",,true,,,"ASSERT_TRUE(!env_->GetFileSize(""/dir/non_existent"", &file_size).ok())",,,0,
104286,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->GetChildren(""/dir"", &children))",,true,,,"ASSERT_OK(env_->GetChildren(""/dir"", &children))",,,0,
104292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, children.size())",,true,,,"ASSERT_EQ(0, children.size())",,,0,
104296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file))",,true,,,"ASSERT_OK(env_->NewWritableFile(""/dir/f"", &writable_file))",,,0,
104302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size))",,true,,,"ASSERT_OK(env_->GetFileSize(""/dir/f"", &file_size))",,,0,
104308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, file_size)",,true,,,"ASSERT_EQ(0, file_size)",,,0,
104314,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(env_->FileExists(""/dir/f""))",,true,,,"ASSERT_TRUE(env_->FileExists(""/dir/f""))",,,0,
104319,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, children.size())",,true,,,"ASSERT_EQ(1, children.size())",,,0,
104323,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""f"", children[0])",,true,,,"ASSERT_EQ(""f"", children[0])",,,0,
104329,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(writable_file->Append(""abc""))",,true,,,"ASSERT_OK(writable_file->Append(""abc""))",,,0,
104334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewAppendableFile(""/dir/f"", &writable_file))",,true,,,"ASSERT_OK(env_->NewAppendableFile(""/dir/f"", &writable_file))",,,0,
104340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(3, file_size)",,true,,,"ASSERT_EQ(3, file_size)",,,0,
104346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(writable_file->Append(""hello""))",,true,,,"ASSERT_OK(writable_file->Append(""hello""))",,,0,
104351,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(8, file_size)",,true,,,"ASSERT_EQ(8, file_size)",,,0,
104357,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->RenameFile(""/dir/non_existent"", ""/dir/g"").ok())",,true,,,"ASSERT_TRUE(!env_->RenameFile(""/dir/non_existent"", ""/dir/g"").ok())",,,0,
104363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->RenameFile(""/dir/f"", ""/dir/g""))",,true,,,"ASSERT_OK(env_->RenameFile(""/dir/f"", ""/dir/g""))",,,0,
104369,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->FileExists(""/dir/f""))",,true,,,"ASSERT_TRUE(!env_->FileExists(""/dir/f""))",,,0,
104374,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(env_->FileExists(""/dir/g""))",,true,,,"ASSERT_TRUE(env_->FileExists(""/dir/g""))",,,0,
104379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->GetFileSize(""/dir/g"", &file_size))",,true,,,"ASSERT_OK(env_->GetFileSize(""/dir/g"", &file_size))",,,0,
104385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->NewSequentialFile(""/dir/non_existent"", &seq_file).ok())",,true,,,"ASSERT_TRUE(!env_->NewSequentialFile(""/dir/non_existent"", &seq_file).ok())",,,0,
104391,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!seq_file),,true,,,ASSERT_TRUE(!seq_file),,,0,
104397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->NewRandomAccessFile(""/dir/non_existent"", &rand_file).ok())",,true,,,"ASSERT_TRUE(!env_->NewRandomAccessFile(""/dir/non_existent"", &rand_file).ok())",,,0,
104403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!rand_file),,true,,,ASSERT_TRUE(!rand_file),,,0,
104409,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->DeleteFile(""/dir/non_existent"").ok())",,true,,,"ASSERT_TRUE(!env_->DeleteFile(""/dir/non_existent"").ok())",,,0,
104414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->DeleteFile(""/dir/g""))",,true,,,"ASSERT_OK(env_->DeleteFile(""/dir/g""))",,,0,
104419,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!env_->FileExists(""/dir/g""))",,true,,,"ASSERT_TRUE(!env_->FileExists(""/dir/g""))",,,0,
104424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->DeleteDir(""/dir""))",,true,,,"ASSERT_OK(env_->DeleteDir(""/dir""))",,,0,
104429,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ReadWrite.TEST(MemEnvTest, ReadWrite)",,true,,,"TEST(MemEnvTest, ReadWrite)",,,0,
104433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemEnvTest, ReadWrite)",,true,,,"TEST(MemEnvTest, ReadWrite)",,,0,
104440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(writable_file->Append(""hello ""))",,true,,,"ASSERT_OK(writable_file->Append(""hello ""))",,,0,
104445,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(writable_file->Append(""world""))",,true,,,"ASSERT_OK(writable_file->Append(""world""))",,,0,
104450,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file))",,true,,,"ASSERT_OK(env_->NewSequentialFile(""/dir/f"", &seq_file))",,,0,
104456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(seq_file->Read(5, &result, scratch))",,true,,,"ASSERT_OK(seq_file->Read(5, &result, scratch))",,,0,
104463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(0, result.compare(""hello""))",,true,,,"ASSERT_EQ(0, result.compare(""hello""))",,,0,
104468,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, result.compare(""hello""))",,true,,,"ASSERT_EQ(0, result.compare(""hello""))",,,0,
104474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(seq_file->Skip(1)),,true,,,ASSERT_OK(seq_file->Skip(1)),,,0,
104479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(seq_file->Read(1000, &result, scratch))",,true,,,"ASSERT_OK(seq_file->Read(1000, &result, scratch))",,,0,
104486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(0, result.compare(""world""))",,true,,,"ASSERT_EQ(0, result.compare(""world""))",,,0,
104491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, result.compare(""world""))",,true,,,"ASSERT_EQ(0, result.compare(""world""))",,,0,
104497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(0, result.size())",,true,,,"ASSERT_EQ(0, result.size())",,,0,
104501,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, result.size())",,true,,,"ASSERT_EQ(0, result.size())",,,0,
104507,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(seq_file->Skip(100)),,true,,,ASSERT_OK(seq_file->Skip(100)),,,0,
104512,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewRandomAccessFile(""/dir/f"", &rand_file))",,true,,,"ASSERT_OK(env_->NewRandomAccessFile(""/dir/f"", &rand_file))",,,0,
104518,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(rand_file->Read(6, 5, &result, scratch))",,true,,,"ASSERT_OK(rand_file->Read(6, 5, &result, scratch))",,,0,
104526,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(rand_file->Read(0, 5, &result, scratch))",,true,,,"ASSERT_OK(rand_file->Read(0, 5, &result, scratch))",,,0,
104534,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(rand_file->Read(10, 100, &result, scratch))",,true,,,"ASSERT_OK(rand_file->Read(10, 100, &result, scratch))",,,0,
104542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(0, result.compare(""d""))",,true,,,"ASSERT_EQ(0, result.compare(""d""))",,,0,
104547,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, result.compare(""d""))",,true,,,"ASSERT_EQ(0, result.compare(""d""))",,,0,
104553,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(!rand_file->Read(1000, 5, &result, scratch).ok())",,true,,,"ASSERT_TRUE(!rand_file->Read(1000, 5, &result, scratch).ok())",,,0,
104561,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Locks.TEST(MemEnvTest, Locks)",,true,,,"TEST(MemEnvTest, Locks)",,,0,
104565,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemEnvTest, Locks)",,true,,,"TEST(MemEnvTest, Locks)",,,0,
104572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->LockFile(""some file"", &lock))",,true,,,"ASSERT_OK(env_->LockFile(""some file"", &lock))",,,0,
104578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(env_->UnlockFile(lock)),,true,,,ASSERT_OK(env_->UnlockFile(lock)),,,0,
104583,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Misc.TEST(MemEnvTest, Misc)",,true,,,"TEST(MemEnvTest, Misc)",,,0,
104587,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemEnvTest, Misc)",,true,,,"TEST(MemEnvTest, Misc)",,,0,
104594,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(env_->GetTestDirectory(&test_dir)),,true,,,ASSERT_OK(env_->GetTestDirectory(&test_dir)),,,0,
104599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!test_dir.empty()),,true,,,ASSERT_TRUE(!test_dir.empty()),,,0,
104603,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewWritableFile(""/a/b"", &writable_file))",,true,,,"ASSERT_OK(env_->NewWritableFile(""/a/b"", &writable_file))",,,0,
104609,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(writable_file->Sync()),,true,,,ASSERT_OK(writable_file->Sync()),,,0,
104613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(writable_file->Flush()),,true,,,ASSERT_OK(writable_file->Flush()),,,0,
104617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(writable_file->Close()),,true,,,ASSERT_OK(writable_file->Close()),,,0,
104621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_LargeWrite.TEST(MemEnvTest, LargeWrite)",,true,,,"TEST(MemEnvTest, LargeWrite)",,,0,
104625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemEnvTest, LargeWrite)",,true,,,"TEST(MemEnvTest, LargeWrite)",,,0,
104632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(writable_file->Append(""foo""))",,true,,,"ASSERT_OK(writable_file->Append(""foo""))",,,0,
104637,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(writable_file->Append(write_data)),,true,,,ASSERT_OK(writable_file->Append(write_data)),,,0,
104642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(seq_file->Read(3, &result, scratch))",,true,,,"ASSERT_OK(seq_file->Read(3, &result, scratch))",,,0,
104649,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(0, result.compare(""foo""))",,true,,,"ASSERT_EQ(0, result.compare(""foo""))",,,0,
104654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, result.compare(""foo""))",,true,,,"ASSERT_EQ(0, result.compare(""foo""))",,,0,
104660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch))",,true,,,"ASSERT_OK(seq_file->Read(kWriteSize - read, &result, scratch))",,,0,
104667,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(write_data == read_data),,true,,,ASSERT_TRUE(write_data == read_data),,,0,
104673,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_DBTest.TEST(MemEnvTest, DBTest)",,true,,,"TEST(MemEnvTest, DBTest)",,,0,
104677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemEnvTest, DBTest)",,true,,,"TEST(MemEnvTest, DBTest)",,,0,
104684,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(DB.Open(options, ""/dir/db"", &db))",,true,,,"ASSERT_OK(DB.Open(options, ""/dir/db"", &db))",,,0,
104691,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]))",,true,,,"ASSERT_OK(db->Put(WriteOptions(), keys[i], vals[i]))",,,0,
104698,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Get(ReadOptions(), keys[i], &res))",,true,,,"ASSERT_OK(db->Get(ReadOptions(), keys[i], &res))",,,0,
104705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(res == vals[i]),,true,,,ASSERT_TRUE(res == vals[i]),,,0,
104711,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(iterator->Valid()),,true,,,ASSERT_TRUE(iterator->Valid()),,,0,
104715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(keys[i] == iterator->key()),,true,,,ASSERT_TRUE(keys[i] == iterator->key()),,,0,
104719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(vals[i] == iterator->value()),,true,,,ASSERT_TRUE(vals[i] == iterator->value()),,,0,
104723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(!iterator->Valid()),,true,,,ASSERT_TRUE(!iterator->Valid()),,,0,
104727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status,,true,,,Status,,,0,
104733,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,code,,true,,,code,,,0,
104736,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CopyState,,true,,,CopyState,,,0,
104740,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Key1,,true,,,Key1,,,0,
104744,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Test.TEST(Issue178, Test)",,true,,,"TEST(Issue178, Test)",,,0,
104748,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Issue178, Test)",,true,,,"TEST(Issue178, Test)",,,0,
104755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(leveldb.DB.Open(db_options, dbpath, &db))",,true,,,"ASSERT_OK(leveldb.DB.Open(db_options, dbpath, &db))",,,0,
104762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Write(leveldb.WriteOptions(), &batch))",,true,,,"ASSERT_OK(db->Write(leveldb.WriteOptions(), &batch))",,,0,
104766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Key2,,true,,,Key2,,,0,
104770,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,least,,true,,,least,,,0,
104775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,greatest,,true,,,greatest,,,0,
104780,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.ReadOptions,,true,,,leveldb.ReadOptions,,,0,
104784,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kNumKeys, num_keys)",,true,,,"ASSERT_EQ(kNumKeys, num_keys)",,,0,
104790,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Test.TEST(Issue200, Test)",,true,,,"TEST(Issue200, Test)",,,0,
104794,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Issue200, Test)",,true,,,"TEST(Issue200, Test)",,,0,
104801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(DB.Open(options, dbpath, &db))",,true,,,"ASSERT_OK(DB.Open(options, dbpath, &db))",,,0,
104808,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(write_options, ""1"", ""b""))",,true,,,"ASSERT_OK(db->Put(write_options, ""1"", ""b""))",,,0,
104815,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(write_options, ""2"", ""c""))",,true,,,"ASSERT_OK(db->Put(write_options, ""2"", ""c""))",,,0,
104822,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(write_options, ""3"", ""d""))",,true,,,"ASSERT_OK(db->Put(write_options, ""3"", ""d""))",,,0,
104829,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(write_options, ""4"", ""e""))",,true,,,"ASSERT_OK(db->Put(write_options, ""4"", ""e""))",,,0,
104836,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(write_options, ""5"", ""f""))",,true,,,"ASSERT_OK(db->Put(write_options, ""5"", ""f""))",,,0,
104843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(db->Put(write_options, ""25"", ""cd""))",,true,,,"ASSERT_OK(db->Put(write_options, ""25"", ""cd""))",,,0,
104850,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(iter->key().ToString(), ""5"")",,true,,,"ASSERT_EQ(iter->key().ToString(), ""5"")",,,0,
104854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(iter->key().ToString(), ""4"")",,true,,,"ASSERT_EQ(iter->key().ToString(), ""4"")",,,0,
104858,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(iter->key().ToString(), ""3"")",,true,,,"ASSERT_EQ(iter->key().ToString(), ""3"")",,,0,
104862,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PthreadCall,,true,,,PthreadCall,,,0,
104867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_init,,true,,,pthread_mutex_init,,,0,
104872,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_destroy,,true,,,pthread_mutex_destroy,,,0,
104876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_lock,,true,,,pthread_mutex_lock,,,0,
104880,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_mutex_unlock,,true,,,pthread_mutex_unlock,,,0,
104884,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_init,,true,,,pthread_cond_init,,,0,
104889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_destroy,,true,,,pthread_cond_destroy,,,0,
104893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_wait,,true,,,pthread_cond_wait,,,0,
104898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_signal,,true,,,pthread_cond_signal,,,0,
104902,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_cond_broadcast,,true,,,pthread_cond_broadcast,,,0,
104906,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_once,,true,,,pthread_once,,,0,
104911,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,port\port_posix.hpp,port\port_posix.hpp:50:50:PLATFORM_IS_LITTLE_ENDIAN:0,,true,50,50,PLATFORM_IS_LITTLE_ENDIAN,,,0,
104914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Block.NumRestarts,,true,,,NumRestarts,,,0,
104917,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.GetRestartPoint,,true,,,GetRestartPoint,,,0,
104921,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.Valid,,true,,,Valid,,,0,
104924,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.ParseNextKey,,true,,,ParseNextKey,,,0,
104927,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.SeekToRestartPoint,,true,,,SeekToRestartPoint,,,0,
104931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.NextEntryOffset,,true,,,NextEntryOffset,,,0,
104934,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeEntry,,true,,,DecodeEntry,,,0,
104942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.CorruptionError,,true,,,CorruptionError,,,0,
104945,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mid_key,,true,,,mid_key,,,0,
104950,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Iter.Compare,,true,,,Compare,,,0,
104955,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SeekToRestartPoint,,true,,,SeekToRestartPoint,,,0,
104959,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewEmptyIterator,,true,,,NewEmptyIterator,,,0,
104962,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PutFixed32,,true,,,PutFixed32,,,0,
104967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,last_key_piece,,true,,,last_key_piece,,,0,
104971,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.min,,true,,,std.min,,,0,
104977,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FilterBlockBuilder.GenerateFilter,,true,,,GenerateFilter,,,0,
104980,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_EmptyBuilder.TEST(FilterBlockTest, EmptyBuilder)",,true,,,"TEST(FilterBlockTest, EmptyBuilder)",,,0,
104984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FilterBlockTest, EmptyBuilder)",,true,,,"TEST(FilterBlockTest, EmptyBuilder)",,,0,
104991,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FilterBlockBuilder.Finish,,true,,,Finish,,,0,
104995,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""\\x00\\x00\\x00\\x00\\x0b"", EscapeString(block))",,true,,,"ASSERT_EQ(""\\x00\\x00\\x00\\x00\\x0b"", EscapeString(block))",,,0,
105001,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""))",,,0,
105007,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(0, ""foo""))",,,0,
105013,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""))",,,0,
105019,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100000, ""foo""))",,,0,
105025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SingleChunk.TEST(FilterBlockTest, SingleChunk)",,true,,,"TEST(FilterBlockTest, SingleChunk)",,,0,
105029,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FilterBlockTest, SingleChunk)",,true,,,"TEST(FilterBlockTest, SingleChunk)",,,0,
105036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FilterBlockBuilder.StartBlock,,true,,,StartBlock,,,0,
105041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,FilterBlockBuilder.AddKey,,true,,,AddKey,,,0,
105046,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""))",,,0,
105052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""foo""))",,,0,
105058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""))",,,0,
105064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""bar""))",,,0,
105070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(100, ""box""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""box""))",,,0,
105076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(100, ""box""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""box""))",,,0,
105082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""))",,,0,
105088,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(100, ""hello""))",,,0,
105094,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""))",,,0,
105100,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(100, ""missing""))",,,0,
105106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""))",,,0,
105112,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(100, ""other""))",,,0,
105118,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_MultiChunk.TEST(FilterBlockTest, MultiChunk)",,true,,,"TEST(FilterBlockTest, MultiChunk)",,,0,
105122,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(FilterBlockTest, MultiChunk)",,true,,,"TEST(FilterBlockTest, MultiChunk)",,,0,
105129,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""))",,,0,
105135,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(2000, ""bar""))",,,0,
105141,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""))",,,0,
105147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(0, ""box""))",,,0,
105153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""))",,,0,
105159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(0, ""hello""))",,,0,
105165,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""))",,,0,
105171,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(3100, ""box""))",,,0,
105177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""))",,,0,
105183,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""foo""))",,,0,
105189,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""))",,,0,
105195,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""bar""))",,,0,
105201,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""))",,,0,
105207,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(3100, ""hello""))",,,0,
105213,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo""))",,,0,
105219,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""foo""))",,,0,
105225,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""bar""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""bar""))",,,0,
105231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(4100, ""bar""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""bar""))",,,0,
105237,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""box""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""box""))",,,0,
105243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(4100, ""box""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""box""))",,,0,
105249,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""hello""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""hello""))",,,0,
105255,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(4100, ""hello""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(4100, ""hello""))",,,0,
105261,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(9000, ""box""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(9000, ""box""))",,,0,
105267,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(9000, ""box""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(9000, ""box""))",,,0,
105273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(reader.KeyMayMatch(9000, ""hello""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(9000, ""hello""))",,,0,
105279,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(reader.KeyMayMatch(9000, ""hello""))",,true,,,"ASSERT_TRUE(reader.KeyMayMatch(9000, ""hello""))",,,0,
105285,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(9000, ""foo""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(9000, ""foo""))",,,0,
105291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(9000, ""foo""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(9000, ""foo""))",,,0,
105297,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! reader.KeyMayMatch(9000, ""bar""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(9000, ""bar""))",,,0,
105303,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"FilterBlockReader.ASSERT_TRUE(! reader.KeyMayMatch(9000, ""bar""))",,true,,,"ASSERT_TRUE(! reader.KeyMayMatch(9000, ""bar""))",,,0,
105309,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.not,,true,,,<operator>.not,,,0,
105313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,offset,,true,,,offset,,,0,
105317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port.Snappy_GetUncompressedLength,,true,,,port.Snappy_GetUncompressedLength,,,0,
105324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*cleanup_.function,,true,,,*cleanup_.function,,,0,
105330,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*c->function,,true,,,*c->function,,,0,
105336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IteratorWrapper.Set,,true,,,Set,,,0,
105340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IteratorWrapper.Update,,true,,,Update,,,0,
105343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MergingIterator.FindSmallest,,true,,,FindSmallest,,,0,
105346,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MergingIterator.FindLargest,,true,,,FindLargest,,,0,
105349,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MergingIterator.Valid,,true,,,Valid,,,0,
105352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,MergingIterator.key,,true,,,key,,,0,
105355,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Footer.DecodeFrom,,true,,,DecodeFrom,,,0,
105360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadBlock,,true,,,ReadBlock,,,0,
105367,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Footer.index_handle,,true,,,index_handle,,,0,
105371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Footer.metaindex_handle,,true,,,metaindex_handle,,,0,
105375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NewId,,true,,,NewId,,,0,
105379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ReadMeta,,true,,,ReadMeta,,,0,
105384,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,metaindex_handle,,true,,,metaindex_handle,,,0,
105388,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Table.ReadFilter,,true,,,ReadFilter,,,0,
105392,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockHandle.DecodeFrom,,true,,,DecodeFrom,,,0,
105397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockHandle.offset,,true,,,offset,,,0,
105401,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*saver,,true,,,*saver,,,0,
105408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StartBlock,,true,,,StartBlock,,,0,
105413,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.ok,,true,,,ok,,,0,
105416,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AddKey,,true,,,AddKey,,,0,
105421,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CurrentSizeEstimate,,true,,,CurrentSizeEstimate,,,0,
105425,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.Flush,,true,,,Flush,,,0,
105428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.WriteBlock,,true,,,WriteBlock,,,0,
105433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.WriteRawBlock,,true,,,WriteRawBlock,,,0,
105439,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_offset,,true,,,set_offset,,,0,
105444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,set_size,,true,,,set_size,,,0,
105449,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,meta_index_block,,true,,,meta_index_block,,,0,
105453,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockHandle.EncodeTo,,true,,,EncodeTo,,,0,
105458,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockBuilder.Add,,true,,,Add,,,0,
105464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Footer.set_metaindex_handle,,true,,,set_metaindex_handle,,,0,
105469,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Footer.set_index_handle,,true,,,set_index_handle,,,0,
105474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Footer.EncodeTo,,true,,,EncodeTo,,,0,
105479,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,str,,true,,,str,,,0,
105483,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rev,,true,,,rev,,,0,
105487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Reverse,,true,,,Reverse,,,0,
105491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Constructor.FinishImpl,,true,,,FinishImpl,,,0,
105496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BlockBuilder.Finish,,true,,,Finish,,,0,
105500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableConstructor.Reset,,true,,,Reset,,,0,
105503,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.Add,,true,,,Add,,,0,
105509,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(builder.status().ok()),,true,,,ASSERT_TRUE(builder.status().ok()),,,0,
105513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.ASSERT_TRUE(builder.status().ok()),,true,,,ASSERT_TRUE(builder.status().ok()),,,0,
105517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableBuilder.Finish,,true,,,Finish,,,0,
105521,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(sink.contents().size(), builder.FileSize())",,true,,,"ASSERT_EQ(sink.contents().size(), builder.FileSize())",,,0,
105525,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"StringSink.ASSERT_EQ(sink.contents().size(), builder.FileSize())",,true,,,"ASSERT_EQ(sink.contents().size(), builder.FileSize())",,,0,
105529,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableBuilder.ASSERT_EQ(sink.contents().size(), builder.FileSize())",,true,,,"ASSERT_EQ(sink.contents().size(), builder.FileSize())",,,0,
105533,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StringSink.contents,,true,,,contents,,,0,
105537,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ikey,,true,,,ikey,,,0,
105543,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DBConstructor.NewDB,,true,,,NewDB,,,0,
105546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok())",,true,,,"ASSERT_TRUE(db_->Write(WriteOptions(), &batch).ok())",,,0,
105552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.ASSERT_TRUE(status.ok()),,true,,,ASSERT_TRUE(status.ok()),,,0,
105556,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(status.ok()),,true,,,ASSERT_TRUE(status.ok()),,,0,
105562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestForwardScan,,true,,,TestForwardScan,,,0,
105567,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestBackwardScan,,true,,,TestBackwardScan,,,0,
105572,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TestRandomAccess,,true,,,TestRandomAccess,,,0,
105578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Harness.ToString,,true,,,ToString,,,0,
105582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(ToString(data, model_iter), ToString(iter))",,true,,,"ASSERT_EQ(ToString(data, model_iter), ToString(iter))",,,0,
105588,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Harness.PickRandomKey,,true,,,PickRandomKey,,,0,
105593,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Increment,,true,,,Increment,,,0,
105598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,db,,true,,,db,,,0,
105602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(Harness, Empty)",,true,,,"TEST(Harness, Empty)",,,0,
105606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, Empty)",,true,,,"TEST(Harness, Empty)",,,0,
105613,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Empty.Init,,true,,,Init,,,0,
105617,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Empty.Test,,true,,,Test,,,0,
105621,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ZeroRestartPointsInBlock.TEST(Harness, ZeroRestartPointsInBlock)",,true,,,"TEST(Harness, ZeroRestartPointsInBlock)",,,0,
105625,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, ZeroRestartPointsInBlock)",,true,,,"TEST(Harness, ZeroRestartPointsInBlock)",,,0,
105632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,memset,,true,,,memset,,,0,
105638,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,block,,true,,,block,,,0,
105642,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Block.NewIterator,,true,,,NewIterator,,,0,
105647,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SimpleEmptyKey.TEST(Harness, SimpleEmptyKey)",,true,,,"TEST(Harness, SimpleEmptyKey)",,,0,
105651,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, SimpleEmptyKey)",,true,,,"TEST(Harness, SimpleEmptyKey)",,,0,
105658,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleEmptyKey.Init,,true,,,Init,,,0,
105662,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleEmptyKey.Test,,true,,,Test,,,0,
105666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SimpleSingle.TEST(Harness, SimpleSingle)",,true,,,"TEST(Harness, SimpleSingle)",,,0,
105670,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, SimpleSingle)",,true,,,"TEST(Harness, SimpleSingle)",,,0,
105677,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleSingle.Init,,true,,,Init,,,0,
105681,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleSingle.Test,,true,,,Test,,,0,
105685,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SimpleMulti.TEST(Harness, SimpleMulti)",,true,,,"TEST(Harness, SimpleMulti)",,,0,
105689,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, SimpleMulti)",,true,,,"TEST(Harness, SimpleMulti)",,,0,
105696,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleMulti.Init,,true,,,Init,,,0,
105700,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleMulti.Test,,true,,,Test,,,0,
105704,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SimpleSpecialKey.TEST(Harness, SimpleSpecialKey)",,true,,,"TEST(Harness, SimpleSpecialKey)",,,0,
105708,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, SimpleSpecialKey)",,true,,,"TEST(Harness, SimpleSpecialKey)",,,0,
105715,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleSpecialKey.Init,,true,,,Init,,,0,
105719,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_SimpleSpecialKey.Test,,true,,,Test,,,0,
105723,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Randomized.TEST(Harness, Randomized)",,true,,,"TEST(Harness, Randomized)",,,0,
105727,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, Randomized)",,true,,,"TEST(Harness, Randomized)",,,0,
105734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Randomized.Init,,true,,,Init,,,0,
105738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Random.Skewed,,true,,,Skewed,,,0,
105743,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Randomized.Test,,true,,,Test,,,0,
105747,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RandomizedLongDB.TEST(Harness, RandomizedLongDB)",,true,,,"TEST(Harness, RandomizedLongDB)",,,0,
105751,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Harness, RandomizedLongDB)",,true,,,"TEST(Harness, RandomizedLongDB)",,,0,
105758,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RandomizedLongDB.Init,,true,,,Init,,,0,
105762,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RandomizedLongDB.Test,,true,,,Test,,,0,
105766,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(db()->GetProperty(name, &value))",,true,,,"ASSERT_TRUE(db()->GetProperty(name, &value))",,,0,
105772,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_RandomizedLongDB.db,,true,,,db,,,0,
105775,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GT(files, 0)",,true,,,"ASSERT_GT(files, 0)",,,0,
105781,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Simple.TEST(MemTableTest, Simple)",,true,,,"TEST(MemTableTest, Simple)",,,0,
105785,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(MemTableTest, Simple)",,true,,,"TEST(MemTableTest, Simple)",,,0,
105792,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(WriteBatchInternal.InsertInto(&batch, memtable).ok())",,true,,,"ASSERT_TRUE(WriteBatchInternal.InsertInto(&batch, memtable).ok())",,,0,
105798,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ApproximateOffsetOfPlain.TEST(TableTest, ApproximateOffsetOfPlain)",,true,,,"TEST(TableTest, ApproximateOffsetOfPlain)",,,0,
105802,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(TableTest, ApproximateOffsetOfPlain)",,true,,,"TEST(TableTest, ApproximateOffsetOfPlain)",,,0,
105809,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,c,,true,,,c,,,0,
105813,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableConstructor.Add,,true,,,Add,,,0,
105819,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TableConstructor.Finish,,true,,,Finish,,,0,
105826,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0))",,,0,
105832,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""),       0,      0))",,,0,
105837,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0))",,,0,
105843,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""),       0,      0))",,,0,
105848,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0))",,,0,
105854,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01a""),      0,      0))",,,0,
105859,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0))",,,0,
105865,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""),       0,      0))",,,0,
105870,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0))",,,0,
105876,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""),       0,      0))",,,0,
105881,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000))",,,0,
105887,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""),   10000,  11000))",,,0,
105892,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 211000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 211000))",,,0,
105898,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 211000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04a""), 210000, 211000))",,,0,
105903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k05""),  210000, 211000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k05""),  210000, 211000))",,,0,
105909,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k05""),  210000, 211000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k05""),  210000, 211000))",,,0,
105914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k06""),  510000, 511000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k06""),  510000, 511000))",,,0,
105920,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k06""),  510000, 511000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k06""),  510000, 511000))",,,0,
105925,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k07""),  510000, 511000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k07""),  510000, 511000))",,,0,
105931,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k07""),  510000, 511000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k07""),  510000, 511000))",,,0,
105936,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""),  610000, 612000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""),  610000, 612000))",,,0,
105942,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""),  610000, 612000))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""),  610000, 612000))",,,0,
105947,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_ApproximateOffsetOfCompressed.TEST(TableTest, ApproximateOffsetOfCompressed)",,true,,,"TEST(TableTest, ApproximateOffsetOfCompressed)",,,0,
105951,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(TableTest, ApproximateOffsetOfCompressed)",,true,,,"TEST(TableTest, ApproximateOffsetOfCompressed)",,,0,
105958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SnappyCompressionSupported,,true,,,SnappyCompressionSupported,,,0,
105961,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop))",,,0,
105967,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""abc""), 0, kSlop))",,,0,
105972,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""), 0, kSlop))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""), 0, kSlop))",,,0,
105978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""), 0, kSlop))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k01""), 0, kSlop))",,,0,
105983,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""), 0, kSlop))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""), 0, kSlop))",,,0,
105989,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""), 0, kSlop))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k02""), 0, kSlop))",,,0,
105994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""), min_z, max_z))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""), min_z, max_z))",,,0,
106000,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""), min_z, max_z))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k03""), min_z, max_z))",,,0,
106005,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""), min_z, max_z))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""), min_z, max_z))",,,0,
106011,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""), min_z, max_z))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""k04""), min_z, max_z))",,,0,
106016,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""), 2 * min_z, 2 * max_z))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""), 2 * min_z, 2 * max_z))",,,0,
106022,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TableConstructor.ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""), 2 * min_z, 2 * max_z))",,true,,,"ASSERT_TRUE(Between(c.ApproximateOffsetOf(""xyz""), 2 * min_z, 2 * max_z))",,,0,
106027,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TwoLevelIterator.InitDataBlock,,true,,,InitDataBlock,,,0,
106030,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TwoLevelIterator.SkipEmptyDataBlocksForward,,true,,,SkipEmptyDataBlocksForward,,,0,
106033,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TwoLevelIterator.SkipEmptyDataBlocksBackward,,true,,,SkipEmptyDataBlocksBackward,,,0,
106036,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TwoLevelIterator.Valid,,true,,,Valid,,,0,
106039,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TwoLevelIterator.SaveError,,true,,,SaveError,,,0,
106043,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Slice.compare,,true,,,compare,,,0,
106048,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*block_function_,,true,,,*block_function_,,,0,
106055,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,TwoLevelIterator.SetDataIterator,,true,,,SetDataIterator,,,0,
106059,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Arena.AllocateNewBlock,,true,,,AllocateNewBlock,,,0,
106063,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,AllocateNewBlock,,true,,,AllocateNewBlock,,,0,
106067,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Arena.AllocateFallback,,true,,,AllocateFallback,,,0,
106071,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Arena.MemoryUsage,,true,,,MemoryUsage,,,0,
106074,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Empty.TEST(ArenaTest, Empty)",,true,,,"TEST(ArenaTest, Empty)",,,0,
106078,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(ArenaTest, Empty)",,true,,,"TEST(ArenaTest, Empty)",,,0,
106085,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Simple.TEST(ArenaTest, Simple)",,true,,,"TEST(ArenaTest, Simple)",,,0,
106089,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(ArenaTest, Simple)",,true,,,"TEST(ArenaTest, Simple)",,,0,
106096,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Arena.AllocateAligned,,true,,,AllocateAligned,,,0,
106101,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Arena.Allocate,,true,,,Allocate,,,0,
106106,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Arena.ASSERT_GE(arena.MemoryUsage(), bytes)",,true,,,"ASSERT_GE(arena.MemoryUsage(), bytes)",,,0,
106110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_GE(arena.MemoryUsage(), bytes)",,true,,,"ASSERT_GE(arena.MemoryUsage(), bytes)",,,0,
106116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Arena.ASSERT_LE(arena.MemoryUsage(), bytes * 1.10)",,true,,,"ASSERT_LE(arena.MemoryUsage(), bytes * 1.10)",,,0,
106120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(arena.MemoryUsage(), bytes * 1.10)",,true,,,"ASSERT_LE(arena.MemoryUsage(), bytes * 1.10)",,,0,
106126,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(int(p[b]) & 0xff, i % 256)",,true,,,"ASSERT_EQ(int(p[b]) & 0xff, i % 256)",,,0,
106132,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BloomHash,,true,,,BloomHash,,,0,
106136,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BloomTest.DumpFilter,,true,,,DumpFilter,,,0,
106139,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BloomTest.Build,,true,,,Build,,,0,
106142,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BloomTest.Matches,,true,,,Matches,,,0,
106146,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_EmptyFilter.TEST(BloomTest, EmptyFilter)",,true,,,"TEST(BloomTest, EmptyFilter)",,,0,
106150,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(BloomTest, EmptyFilter)",,true,,,"TEST(BloomTest, EmptyFilter)",,,0,
106157,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_EmptyFilter.Matches,,true,,,Matches,,,0,
106161,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Matches(""hello""))",,true,,,"ASSERT_TRUE(! Matches(""hello""))",,,0,
106167,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Matches(""world""))",,true,,,"ASSERT_TRUE(! Matches(""world""))",,,0,
106173,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Small.TEST(BloomTest, Small)",,true,,,"TEST(BloomTest, Small)",,,0,
106177,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(BloomTest, Small)",,true,,,"TEST(BloomTest, Small)",,,0,
106184,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Small.Add,,true,,,Add,,,0,
106188,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Small.Matches,,true,,,Matches,,,0,
106192,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Matches(""hello""))",,true,,,"ASSERT_TRUE(Matches(""hello""))",,,0,
106198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Matches(""world""))",,true,,,"ASSERT_TRUE(Matches(""world""))",,,0,
106204,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Matches(""x""))",,true,,,"ASSERT_TRUE(! Matches(""x""))",,,0,
106210,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(! Matches(""foo""))",,true,,,"ASSERT_TRUE(! Matches(""foo""))",,,0,
106216,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_VaryingLengths.TEST(BloomTest, VaryingLengths)",,true,,,"TEST(BloomTest, VaryingLengths)",,,0,
106220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(BloomTest, VaryingLengths)",,true,,,"TEST(BloomTest, VaryingLengths)",,,0,
106227,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,NextLength,,true,,,NextLength,,,0,
106231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_VaryingLengths.Reset,,true,,,Reset,,,0,
106234,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_VaryingLengths.Add,,true,,,Add,,,0,
106238,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_VaryingLengths.Build,,true,,,Build,,,0,
106241,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_VaryingLengths.FilterSize,,true,,,FilterSize,,,0,
106244,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(FilterSize(), static_cast<size_t>((length * 10 / 8) + 40))",,true,,,"ASSERT_LE(FilterSize(), static_cast<size_t>((length * 10 / 8) + 40))",,,0,
106250,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(Matches(Key(i, buffer)))",,true,,,"ASSERT_TRUE(Matches(Key(i, buffer)))",,,0,
106256,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_VaryingLengths.Matches,,true,,,Matches,,,0,
106260,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_VaryingLengths.FalsePositiveRate,,true,,,FalsePositiveRate,,,0,
106263,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(rate, 0.02)",,true,,,"ASSERT_LE(rate, 0.02)",,,0,
106269,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(mediocre_filters, good_filters/5)",,true,,,"ASSERT_LE(mediocre_filters, good_filters/5)",,,0,
106275,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleTable.Resize,,true,,,Resize,,,0,
106278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,HandleTable.FindPointer,,true,,,FindPointer,,,0,
106283,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LRUCache.Unref,,true,,,Unref,,,0,
106287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LRUCache.LRU_Remove,,true,,,LRU_Remove,,,0,
106291,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LRUCache.LRU_Append,,true,,,LRU_Append,,,0,
106296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*e->deleter,,true,,,*e->deleter,,,0,
106302,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LRUCache.Ref,,true,,,Ref,,,0,
106306,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LRUCache.FinishErase,,true,,,FinishErase,,,0,
106310,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Remove,,true,,,Remove,,,0,
106315,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,SetCapacity,,true,,,SetCapacity,,,0,
106320,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_61.ShardedLRUCache.HashSlice,,true,,,HashSlice,,,0,
106324,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_63.ShardedLRUCache.Shard,,true,,,Shard,,,0,
106328,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_66.ShardedLRUCache.HashSlice,,true,,,HashSlice,,,0,
106332,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_68.ShardedLRUCache.Shard,,true,,,Shard,,,0,
106336,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_71.ShardedLRUCache.Shard,,true,,,Shard,,,0,
106340,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_74.ShardedLRUCache.HashSlice,,true,,,HashSlice,,,0,
106344,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,leveldb.anonymous_namespace_76.ShardedLRUCache.Shard,,true,,,Shard,,,0,
106348,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Prune,,true,,,Prune,,,0,
106352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeKey,,true,,,DecodeKey,,,0,
106356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DecodeValue,,true,,,DecodeValue,,,0,
106360,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeValue,,true,,,EncodeValue,,,0,
106364,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_HitAndMiss.TEST(CacheTest, HitAndMiss)",,true,,,"TEST(CacheTest, HitAndMiss)",,,0,
106368,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, HitAndMiss)",,true,,,"TEST(CacheTest, HitAndMiss)",,,0,
106375,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HitAndMiss.Lookup,,true,,,Lookup,,,0,
106379,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(-1, Lookup(100))",,true,,,"ASSERT_EQ(-1, Lookup(100))",,,0,
106385,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HitAndMiss.Insert,,true,,,Insert,,,0,
106390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(101, Lookup(100))",,true,,,"ASSERT_EQ(101, Lookup(100))",,,0,
106396,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(-1,  Lookup(200))",,true,,,"ASSERT_EQ(-1,  Lookup(200))",,,0,
106402,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(-1,  Lookup(300))",,true,,,"ASSERT_EQ(-1,  Lookup(300))",,,0,
106408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(201, Lookup(200))",,true,,,"ASSERT_EQ(201, Lookup(200))",,,0,
106414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(102, Lookup(100))",,true,,,"ASSERT_EQ(102, Lookup(100))",,,0,
106420,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1, deleted_keys_.size())",,true,,,"ASSERT_EQ(1, deleted_keys_.size())",,,0,
106424,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(100, deleted_keys_[0])",,true,,,"ASSERT_EQ(100, deleted_keys_[0])",,,0,
106430,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(101, deleted_values_[0])",,true,,,"ASSERT_EQ(101, deleted_values_[0])",,,0,
106436,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Erase.TEST(CacheTest, Erase)",,true,,,"TEST(CacheTest, Erase)",,,0,
106440,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, Erase)",,true,,,"TEST(CacheTest, Erase)",,,0,
106447,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Erase.Erase,,true,,,Erase,,,0,
106451,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0, deleted_keys_.size())",,true,,,"ASSERT_EQ(0, deleted_keys_.size())",,,0,
106455,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Erase.Insert,,true,,,Insert,,,0,
106460,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Erase.Lookup,,true,,,Lookup,,,0,
106464,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(-1,  Lookup(100))",,true,,,"ASSERT_EQ(-1,  Lookup(100))",,,0,
106470,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_EntriesArePinned.TEST(CacheTest, EntriesArePinned)",,true,,,"TEST(CacheTest, EntriesArePinned)",,,0,
106474,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, EntriesArePinned)",,true,,,"TEST(CacheTest, EntriesArePinned)",,,0,
106481,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_EntriesArePinned.Insert,,true,,,Insert,,,0,
106486,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(101, DecodeValue(cache_->Value(h1)))",,true,,,"ASSERT_EQ(101, DecodeValue(cache_->Value(h1)))",,,0,
106491,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(102, DecodeValue(cache_->Value(h2)))",,true,,,"ASSERT_EQ(102, DecodeValue(cache_->Value(h2)))",,,0,
106496,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_EntriesArePinned.Erase,,true,,,Erase,,,0,
106500,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_EntriesArePinned.Lookup,,true,,,Lookup,,,0,
106504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2, deleted_keys_.size())",,true,,,"ASSERT_EQ(2, deleted_keys_.size())",,,0,
106508,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(100, deleted_keys_[1])",,true,,,"ASSERT_EQ(100, deleted_keys_[1])",,,0,
106514,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(102, deleted_values_[1])",,true,,,"ASSERT_EQ(102, deleted_values_[1])",,,0,
106520,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_EvictionPolicy.TEST(CacheTest, EvictionPolicy)",,true,,,"TEST(CacheTest, EvictionPolicy)",,,0,
106524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, EvictionPolicy)",,true,,,"TEST(CacheTest, EvictionPolicy)",,,0,
106531,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_EvictionPolicy.Insert,,true,,,Insert,,,0,
106536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(2000+i, Lookup(1000+i))",,true,,,"ASSERT_EQ(2000+i, Lookup(1000+i))",,,0,
106542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_EvictionPolicy.Lookup,,true,,,Lookup,,,0,
106546,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(-1, Lookup(200))",,true,,,"ASSERT_EQ(-1, Lookup(200))",,,0,
106552,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(301, Lookup(300))",,true,,,"ASSERT_EQ(301, Lookup(300))",,,0,
106558,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_UseExceedsCacheSize.TEST(CacheTest, UseExceedsCacheSize)",,true,,,"TEST(CacheTest, UseExceedsCacheSize)",,,0,
106562,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, UseExceedsCacheSize)",,true,,,"TEST(CacheTest, UseExceedsCacheSize)",,,0,
106569,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UseExceedsCacheSize.InsertAndReturnHandle,,true,,,InsertAndReturnHandle,,,0,
106574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_UseExceedsCacheSize.Lookup,,true,,,Lookup,,,0,
106578,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_HeavyEntries.TEST(CacheTest, HeavyEntries)",,true,,,"TEST(CacheTest, HeavyEntries)",,,0,
106582,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, HeavyEntries)",,true,,,"TEST(CacheTest, HeavyEntries)",,,0,
106589,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HeavyEntries.Insert,,true,,,Insert,,,0,
106595,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_HeavyEntries.Lookup,,true,,,Lookup,,,0,
106599,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(1000+i, r)",,true,,,"ASSERT_EQ(1000+i, r)",,,0,
106605,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_LE(cached_weight, kCacheSize + kCacheSize/10)",,true,,,"ASSERT_LE(cached_weight, kCacheSize + kCacheSize/10)",,,0,
106611,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_NewId.TEST(CacheTest, NewId)",,true,,,"TEST(CacheTest, NewId)",,,0,
106615,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, NewId)",,true,,,"TEST(CacheTest, NewId)",,,0,
106622,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_NE(a, b)",,true,,,"ASSERT_NE(a, b)",,,0,
106628,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Prune.TEST(CacheTest, Prune)",,true,,,"TEST(CacheTest, Prune)",,,0,
106632,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CacheTest, Prune)",,true,,,"TEST(CacheTest, Prune)",,,0,
106639,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Prune.Insert,,true,,,Insert,,,0,
106644,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(handle),,true,,,ASSERT_TRUE(handle),,,0,
106650,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,_Test_Prune.Lookup,,true,,,Lookup,,,0,
106654,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(100, Lookup(1))",,true,,,"ASSERT_EQ(100, Lookup(1))",,,0,
106660,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(-1, Lookup(2))",,true,,,"ASSERT_EQ(-1, Lookup(2))",,,0,
106666,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operators>.assignmentArithmeticShiftRight,,true,,,<operators>.assignmentArithmeticShiftRight,,,0,
106671,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EncodeVarint64,,true,,,EncodeVarint64,,,0,
106676,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetVarint64Ptr,,true,,,GetVarint64Ptr,,,0,
106682,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,GetVarint32PtrFallback,,true,,,GetVarint32PtrFallback,,,0,
106688,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Fixed32.TEST(Coding, Fixed32)",,true,,,"TEST(Coding, Fixed32)",,,0,
106692,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Fixed32)",,true,,,"TEST(Coding, Fixed32)",,,0,
106699,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(v, actual)",,true,,,"ASSERT_EQ(v, actual)",,,0,
106705,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Fixed64.TEST(Coding, Fixed64)",,true,,,"TEST(Coding, Fixed64)",,,0,
106709,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Fixed64)",,true,,,"TEST(Coding, Fixed64)",,,0,
106716,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(v-1, actual)",,true,,,"ASSERT_EQ(v-1, actual)",,,0,
106722,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(v+0, actual)",,true,,,"ASSERT_EQ(v+0, actual)",,,0,
106728,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(v+1, actual)",,true,,,"ASSERT_EQ(v+1, actual)",,,0,
106734,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_EncodingOutput.TEST(Coding, EncodingOutput)",,true,,,"TEST(Coding, EncodingOutput)",,,0,
106738,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, EncodingOutput)",,true,,,"TEST(Coding, EncodingOutput)",,,0,
106745,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(4, dst.size())",,true,,,"ASSERT_EQ(4, dst.size())",,,0,
106749,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x01, static_cast<int>(dst[0]))",,true,,,"ASSERT_EQ(0x01, static_cast<int>(dst[0]))",,,0,
106755,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x02, static_cast<int>(dst[1]))",,true,,,"ASSERT_EQ(0x02, static_cast<int>(dst[1]))",,,0,
106761,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x03, static_cast<int>(dst[2]))",,true,,,"ASSERT_EQ(0x03, static_cast<int>(dst[2]))",,,0,
106767,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x04, static_cast<int>(dst[3]))",,true,,,"ASSERT_EQ(0x04, static_cast<int>(dst[3]))",,,0,
106773,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(8, dst.size())",,true,,,"ASSERT_EQ(8, dst.size())",,,0,
106777,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x05, static_cast<int>(dst[4]))",,true,,,"ASSERT_EQ(0x05, static_cast<int>(dst[4]))",,,0,
106783,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x06, static_cast<int>(dst[5]))",,true,,,"ASSERT_EQ(0x06, static_cast<int>(dst[5]))",,,0,
106789,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x07, static_cast<int>(dst[6]))",,true,,,"ASSERT_EQ(0x07, static_cast<int>(dst[6]))",,,0,
106795,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x08, static_cast<int>(dst[7]))",,true,,,"ASSERT_EQ(0x08, static_cast<int>(dst[7]))",,,0,
106801,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Varint32.TEST(Coding, Varint32)",,true,,,"TEST(Coding, Varint32)",,,0,
106805,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Varint32)",,true,,,"TEST(Coding, Varint32)",,,0,
106812,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(p != NULL),,true,,,ASSERT_TRUE(p != NULL),,,0,
106818,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(expected, actual)",,true,,,"ASSERT_EQ(expected, actual)",,,0,
106824,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(VarintLength(actual), p - start)",,true,,,"ASSERT_EQ(VarintLength(actual), p - start)",,,0,
106830,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(p, s.data() + s.size())",,true,,,"ASSERT_EQ(p, s.data() + s.size())",,,0,
106834,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Varint64.TEST(Coding, Varint64)",,true,,,"TEST(Coding, Varint64)",,,0,
106838,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Varint64)",,true,,,"TEST(Coding, Varint64)",,,0,
106845,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(p < limit),,true,,,ASSERT_TRUE(p < limit),,,0,
106851,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(values[i], actual)",,true,,,"ASSERT_EQ(values[i], actual)",,,0,
106857,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(p, limit)",,true,,,"ASSERT_EQ(p, limit)",,,0,
106863,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Varint32Overflow.TEST(Coding, Varint32Overflow)",,true,,,"TEST(Coding, Varint32Overflow)",,,0,
106867,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Varint32Overflow)",,true,,,"TEST(Coding, Varint32Overflow)",,,0,
106874,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetVarint32Ptr(input.data(), input.data() + input.size(), &result)
              == NULL)",,true,,,"ASSERT_TRUE(GetVarint32Ptr(input.data(), input.data() + input.size(), &result)
              == NULL)",,,0,
106878,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Varint32Truncation.TEST(Coding, Varint32Truncation)",,true,,,"TEST(Coding, Varint32Truncation)",,,0,
106882,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Varint32Truncation)",,true,,,"TEST(Coding, Varint32Truncation)",,,0,
106889,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == NULL)",,true,,,"ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + len, &result) == NULL)",,,0,
106893,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + s.size(), &result) != NULL)",,true,,,"ASSERT_TRUE(GetVarint32Ptr(s.data(), s.data() + s.size(), &result) != NULL)",,,0,
106897,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(large_value, result)",,true,,,"ASSERT_EQ(large_value, result)",,,0,
106903,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Varint64Overflow.TEST(Coding, Varint64Overflow)",,true,,,"TEST(Coding, Varint64Overflow)",,,0,
106907,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Varint64Overflow)",,true,,,"TEST(Coding, Varint64Overflow)",,,0,
106914,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetVarint64Ptr(input.data(), input.data() + input.size(), &result)
              == NULL)",,true,,,"ASSERT_TRUE(GetVarint64Ptr(input.data(), input.data() + input.size(), &result)
              == NULL)",,,0,
106918,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Varint64Truncation.TEST(Coding, Varint64Truncation)",,true,,,"TEST(Coding, Varint64Truncation)",,,0,
106922,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Varint64Truncation)",,true,,,"TEST(Coding, Varint64Truncation)",,,0,
106929,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == NULL)",,true,,,"ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + len, &result) == NULL)",,,0,
106933,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + s.size(), &result) != NULL)",,true,,,"ASSERT_TRUE(GetVarint64Ptr(s.data(), s.data() + s.size(), &result) != NULL)",,,0,
106937,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Strings.TEST(Coding, Strings)",,true,,,"TEST(Coding, Strings)",,,0,
106941,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(Coding, Strings)",,true,,,"TEST(Coding, Strings)",,,0,
106948,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v))",,true,,,"ASSERT_TRUE(GetLengthPrefixedSlice(&input, &v))",,,0,
106954,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ("""", v.ToString())",,true,,,"ASSERT_EQ("""", v.ToString())",,,0,
106958,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ("""", v.ToString())",,true,,,"ASSERT_EQ("""", v.ToString())",,,0,
106964,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(""foo"", v.ToString())",,true,,,"ASSERT_EQ(""foo"", v.ToString())",,,0,
106968,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""foo"", v.ToString())",,true,,,"ASSERT_EQ(""foo"", v.ToString())",,,0,
106974,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(""bar"", v.ToString())",,true,,,"ASSERT_EQ(""bar"", v.ToString())",,,0,
106978,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(""bar"", v.ToString())",,true,,,"ASSERT_EQ(""bar"", v.ToString())",,,0,
106984,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ(std.string(200, 'x'), v.ToString())",,true,,,"ASSERT_EQ(std.string(200, 'x'), v.ToString())",,,0,
106988,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(std.string(200, 'x'), v.ToString())",,true,,,"ASSERT_EQ(std.string(200, 'x'), v.ToString())",,,0,
106994,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"Slice.ASSERT_EQ("""", input.ToString())",,true,,,"ASSERT_EQ("""", input.ToString())",,,0,
106998,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ("""", input.ToString())",,true,,,"ASSERT_EQ("""", input.ToString())",,,0,
107004,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port.InitOnce,,true,,,port.InitOnce,,,0,
107010,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,port.AcceleratedCRC32C,,true,,,port.AcceleratedCRC32C,,,0,
107017,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,CanAccelerateCRC32C,,true,,,CanAccelerateCRC32C,,,0,
107020,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,<operator>.xor,,true,,,<operator>.xor,,,0,
107025,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\crc32c.cc,util\crc32c.cc:309:312:STEP1:0,,true,309,312,STEP1,,,0,
107028,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\crc32c.cc,util\crc32c.cc:313:320:STEP4:0,,true,313,320,STEP4,,,0,
107031,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LE_LOAD32,,true,,,LE_LOAD32,,,0,
107035,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Extend,,true,,,Extend,,,0,
107041,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_StandardResults.TEST(CRC, StandardResults)",,true,,,"TEST(CRC, StandardResults)",,,0,
107045,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CRC, StandardResults)",,true,,,"TEST(CRC, StandardResults)",,,0,
107052,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x8a9136aa, Value(buf, sizeof(buf)))",,true,,,"ASSERT_EQ(0x8a9136aa, Value(buf, sizeof(buf)))",,,0,
107058,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x62a8ab43, Value(buf, sizeof(buf)))",,true,,,"ASSERT_EQ(0x62a8ab43, Value(buf, sizeof(buf)))",,,0,
107064,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x46dd794e, Value(buf, sizeof(buf)))",,true,,,"ASSERT_EQ(0x46dd794e, Value(buf, sizeof(buf)))",,,0,
107070,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0x113fdb5c, Value(buf, sizeof(buf)))",,true,,,"ASSERT_EQ(0x113fdb5c, Value(buf, sizeof(buf)))",,,0,
107076,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(0xd9963a56, Value(reinterpret_cast<char*>(data), sizeof(data)))",,true,,,"ASSERT_EQ(0xd9963a56, Value(reinterpret_cast<char*>(data), sizeof(data)))",,,0,
107082,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Values.TEST(CRC, Values)",,true,,,"TEST(CRC, Values)",,,0,
107086,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CRC, Values)",,true,,,"TEST(CRC, Values)",,,0,
107093,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_NE(Value(""a"", 1), Value(""foo"", 3))",,true,,,"ASSERT_NE(Value(""a"", 1), Value(""foo"", 3))",,,0,
107099,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Extend.TEST(CRC, Extend)",,true,,,"TEST(CRC, Extend)",,,0,
107103,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CRC, Extend)",,true,,,"TEST(CRC, Extend)",,,0,
107110,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(Value(""hello world"", 11),
            Extend(Value(""hello "", 6), ""world"", 5))",,true,,,"ASSERT_EQ(Value(""hello world"", 11),
            Extend(Value(""hello "", 6), ""world"", 5))",,,0,
107116,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_Mask.TEST(CRC, Mask)",,true,,,"TEST(CRC, Mask)",,,0,
107120,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(CRC, Mask)",,true,,,"TEST(CRC, Mask)",,,0,
107127,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Mask,,true,,,Mask,,,0,
107131,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_NE(crc, Mask(crc))",,true,,,"ASSERT_NE(crc, Mask(crc))",,,0,
107137,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_NE(crc, Mask(Mask(crc)))",,true,,,"ASSERT_NE(crc, Mask(Mask(crc)))",,,0,
107143,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Unmask,,true,,,Unmask,,,0,
107147,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(crc, Unmask(Mask(crc)))",,true,,,"ASSERT_EQ(crc, Unmask(Mask(crc)))",,,0,
107153,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(crc, Unmask(Unmask(Mask(Mask(crc)))))",,true,,,"ASSERT_EQ(crc, Unmask(Unmask(Mask(Mask(crc)))))",,,0,
107159,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_start,,true,,,va_start,,,0,
107164,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Logv,,true,,,Logv,,,0,
107170,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_end,,true,,,va_end,,,0,
107174,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,DoWriteStringToFile,,true,,,DoWriteStringToFile,,,0,
107181,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Status.IOError,,true,,,Status.IOError,,,0,
107187,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Limiter.SetAllowed,,true,,,SetAllowed,,,0,
107191,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Limiter.GetAllowed,,true,,,GetAllowed,,,0,
107194,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fclose,,true,,,fclose,,,0,
107198,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fread_unlocked,,true,,,fread_unlocked,,,0,
107205,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,feof,,true,,,feof,,,0,
107209,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,IOError,,true,,,IOError,,,0,
107214,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fseek,,true,,,fseek,,,0,
107220,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Acquire,,true,,,Acquire,,,0,
107224,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pread,,true,,,pread,,,0,
107231,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,munmap,,true,,,munmap,,,0,
107236,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fwrite_unlocked,,true,,,fwrite_unlocked,,,0,
107243,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fflush_unlocked,,true,,,fflush_unlocked,,,0,
107247,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fsync,,true,,,fsync,,,0,
107251,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PosixWritableFile.SyncDirIfManifest,,true,,,SyncDirIfManifest,,,0,
107254,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fdatasync,,true,,,fdatasync,,,0,
107258,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fileno,,true,,,fileno,,,0,
107262,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fcntl,,true,,,fcntl,,,0,
107268,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fopen,,true,,,fopen,,,0,
107273,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PosixEnv.GetFileSize,,true,,,GetFileSize,,,0,
107278,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mmap,,true,,,mmap,,,0,
107287,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,access,,true,,,access,,,0,
107292,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,opendir,,true,,,opendir,,,0,
107296,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,readdir,,true,,,readdir,,,0,
107300,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,closedir,,true,,,closedir,,,0,
107304,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,unlink,,true,,,unlink,,,0,
107308,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,mkdir,,true,,,mkdir,,,0,
107313,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rmdir,,true,,,rmdir,,,0,
107317,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,rename,,true,,,rename,,,0,
107322,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,LockOrUnlock,,true,,,LockOrUnlock,,,0,
107327,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,PosixEnv.CreateDir,,true,,,CreateDir,,,0,
107331,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_self,,true,,,pthread_self,,,0,
107334,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,gettimeofday,,true,,,gettimeofday,,,0,
107339,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,usleep,,true,,,usleep,,,0,
107343,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BGThread,,true,,,BGThread,,,0,
107347,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,getrlimit,,true,,,getrlimit,,,0,
107352,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,std.numeric_limits<int>.max,,true,,,std.numeric_limits<int>.max,,,0,
107356,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,pthread_create,,true,,,pthread_create,,,0,
107363,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,BGItem,,true,,,BGItem,,,0,
107366,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*function,,true,,,*function,,,0,
107371,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,user_function,,true,,,user_function,,,0,
107376,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnvPosixTestHelper.SetReadOnlyFDLimit,,true,,,EnvPosixTestHelper.SetReadOnlyFDLimit,,,0,
107381,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,EnvPosixTestHelper.SetReadOnlyMMapLimit,,true,,,EnvPosixTestHelper.SetReadOnlyMMapLimit,,,0,
107386,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_TestOpenOnRead.TEST(EnvPosixTest, TestOpenOnRead)",,true,,,"TEST(EnvPosixTest, TestOpenOnRead)",,,0,
107390,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(EnvPosixTest, TestOpenOnRead)",,true,,,"TEST(EnvPosixTest, TestOpenOnRead)",,,0,
107397,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(f != NULL),,true,,,ASSERT_TRUE(f != NULL),,,0,
107403,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fputs,,true,,,fputs,,,0,
107408,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]))",,true,,,"ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]))",,,0,
107414,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch))",,true,,,"ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch))",,,0,
107422,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(kFileData[i], read_result[0])",,true,,,"ASSERT_EQ(kFileData[i], read_result[0])",,,0,
107428,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_OK(env_->DeleteFile(test_file)),,true,,,ASSERT_OK(env_->DeleteFile(test_file)),,,0,
107433,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RunImmediately.TEST(EnvTest, RunImmediately)",,true,,,"TEST(EnvTest, RunImmediately)",,,0,
107437,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(EnvTest, RunImmediately)",,true,,,"TEST(EnvTest, RunImmediately)",,,0,
107444,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,called,,true,,,called,,,0,
107448,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ASSERT_TRUE(called.NoBarrier_Load() != NULL),,true,,,ASSERT_TRUE(called.NoBarrier_Load() != NULL),,,0,
107452,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_RunMany.TEST(EnvTest, RunMany)",,true,,,"TEST(EnvTest, RunMany)",,,0,
107456,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(EnvTest, RunMany)",,true,,,"TEST(EnvTest, RunMany)",,,0,
107463,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,last_id,,true,,,last_id,,,0,
107467,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb1,,true,,,cb1,,,0,
107472,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb2,,true,,,cb2,,,0,
107477,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb3,,true,,,cb3,,,0,
107482,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,cb4,,true,,,cb4,,,0,
107487,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur))",,true,,,"ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur))",,,0,
107493,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_StartThread.TEST(EnvTest, StartThread)",,true,,,"TEST(EnvTest, StartThread)",,,0,
107497,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(EnvTest, StartThread)",,true,,,"TEST(EnvTest, StartThread)",,,0,
107504,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(state.val, 3)",,true,,,"ASSERT_EQ(state.val, 3)",,,0,
107510,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,util\hash.cc,util\hash.cc:13:13:FALLTHROUGH_INTENDED:0,,true,13,13,FALLTHROUGH_INTENDED,,,0,
107513,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"_Test_SignedUnsignedIssue.TEST(HASH, SignedUnsignedIssue)",,true,,,"TEST(HASH, SignedUnsignedIssue)",,,0,
107517,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"TEST(HASH, SignedUnsignedIssue)",,true,,,"TEST(HASH, SignedUnsignedIssue)",,,0,
107524,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(Hash(0, 0, 0xbc9f1d34), 0xbc9f1d34)",,true,,,"ASSERT_EQ(Hash(0, 0, 0xbc9f1d34), 0xbc9f1d34)",,,0,
107530,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data1), sizeof(data1), 0xbc9f1d34),
      0xef1345c4)",,true,,,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data1), sizeof(data1), 0xbc9f1d34),
      0xef1345c4)",,,0,
107536,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data2), sizeof(data2), 0xbc9f1d34),
      0x5b663814)",,true,,,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data2), sizeof(data2), 0xbc9f1d34),
      0x5b663814)",,,0,
107542,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data3), sizeof(data3), 0xbc9f1d34),
      0x323c078f)",,true,,,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data3), sizeof(data3), 0xbc9f1d34),
      0x323c078f)",,,0,
107548,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data4), sizeof(data4), 0xbc9f1d34),
      0xed21633a)",,true,,,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data4), sizeof(data4), 0xbc9f1d34),
      0xed21633a)",,,0,
107554,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data5), sizeof(data5), 0x12345678),
      0xf333dabb)",,true,,,"ASSERT_EQ(
      Hash(reinterpret_cast<const char*>(data5), sizeof(data5), 0x12345678),
      0xf333dabb)",,,0,
107560,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Percentile,,true,,,Percentile,,,0,
107564,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,sqrt,,true,,,sqrt,,,0,
107568,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Average,,true,,,Average,,,0,
107571,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,StandardDeviation,,true,,,StandardDeviation,,,0,
107574,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,Median,,true,,,Median,,,0,
107577,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*gettid_,,true,,,*gettid_,,,0,
107581,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,localtime_r,,true,,,localtime_r,,,0,
107586,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,va_copy,,true,,,va_copy,,,0,
107591,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,vsnprintf,,true,,,vsnprintf,,,0,
107598,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,fflush,,true,,,fflush,,,0,
107602,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,result,,true,,,result,,,0,
107606,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,*t.func,,true,,,*t.func,,,0,
107610,METHOD,<global>,NAMESPACE_BLOCK,<empty>,,,<empty>,ErrorEnv.target,,true,,,target,,,0,
